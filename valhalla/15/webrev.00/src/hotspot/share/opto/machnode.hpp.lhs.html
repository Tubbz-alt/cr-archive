<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/machnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_MACHNODE_HPP
  26 #define SHARE_OPTO_MACHNODE_HPP
  27 
  28 #include &quot;opto/callnode.hpp&quot;
<a name="1" id="anc1"></a>
  29 #include &quot;opto/matcher.hpp&quot;
  30 #include &quot;opto/multnode.hpp&quot;
  31 #include &quot;opto/node.hpp&quot;
  32 #include &quot;opto/regmask.hpp&quot;
  33 
  34 class BiasedLockingCounters;
  35 class BufferBlob;
  36 class CodeBuffer;
  37 class JVMState;
  38 class MachCallDynamicJavaNode;
  39 class MachCallJavaNode;
  40 class MachCallLeafNode;
  41 class MachCallNode;
  42 class MachCallRuntimeNode;
  43 class MachCallStaticJavaNode;
  44 class MachEpilogNode;
  45 class MachIfNode;
  46 class MachNullCheckNode;
  47 class MachOper;
  48 class MachProjNode;
  49 class MachPrologNode;
  50 class MachReturnNode;
  51 class MachSafePointNode;
  52 class MachSpillCopyNode;
  53 class MachVEPNode;
  54 class Matcher;
  55 class PhaseRegAlloc;
  56 class RegMask;
  57 class RTMLockingCounters;
  58 class State;
  59 
  60 //---------------------------MachOper------------------------------------------
  61 class MachOper : public ResourceObj {
  62 public:
  63   // Allocate right next to the MachNodes in the same arena
  64   void *operator new(size_t x) throw() {
  65     Compile* C = Compile::current();
  66     return C-&gt;node_arena()-&gt;Amalloc_D(x);
  67   }
  68 
  69   // Opcode
  70   virtual uint opcode() const = 0;
  71 
  72   // Number of input edges.
  73   // Generally at least 1
  74   virtual uint num_edges() const { return 1; }
  75   // Array of Register masks
  76   virtual const RegMask *in_RegMask(int index) const;
  77 
  78   // Methods to output the encoding of the operand
  79 
  80   // Negate conditional branches.  Error for non-branch Nodes
  81   virtual void negate();
  82 
  83   // Return the value requested
  84   // result register lookup, corresponding to int_format
  85   virtual int  reg(PhaseRegAlloc *ra_, const Node *node)   const;
  86   // input register lookup, corresponding to ext_format
  87   virtual int  reg(PhaseRegAlloc *ra_, const Node *node, int idx)   const;
  88 
  89   // helpers for MacroAssembler generation from ADLC
  90   Register  as_Register(PhaseRegAlloc *ra_, const Node *node)   const {
  91     return ::as_Register(reg(ra_, node));
  92   }
  93   Register  as_Register(PhaseRegAlloc *ra_, const Node *node, int idx)   const {
  94     return ::as_Register(reg(ra_, node, idx));
  95   }
  96   FloatRegister  as_FloatRegister(PhaseRegAlloc *ra_, const Node *node)   const {
  97     return ::as_FloatRegister(reg(ra_, node));
  98   }
  99   FloatRegister  as_FloatRegister(PhaseRegAlloc *ra_, const Node *node, int idx)   const {
 100     return ::as_FloatRegister(reg(ra_, node, idx));
 101   }
 102 
 103 #if defined(IA32) || defined(AMD64)
 104   XMMRegister  as_XMMRegister(PhaseRegAlloc *ra_, const Node *node)   const {
 105     return ::as_XMMRegister(reg(ra_, node));
 106   }
 107   XMMRegister  as_XMMRegister(PhaseRegAlloc *ra_, const Node *node, int idx)   const {
 108     return ::as_XMMRegister(reg(ra_, node, idx));
 109   }
 110 #endif
 111   // CondRegister reg converter
 112 #if defined(PPC64)
 113   ConditionRegister as_ConditionRegister(PhaseRegAlloc *ra_, const Node *node) const {
 114     return ::as_ConditionRegister(reg(ra_, node));
 115   }
 116   ConditionRegister as_ConditionRegister(PhaseRegAlloc *ra_, const Node *node, int idx) const {
 117     return ::as_ConditionRegister(reg(ra_, node, idx));
 118   }
 119   VectorRegister as_VectorRegister(PhaseRegAlloc *ra_, const Node *node) const {
 120     return ::as_VectorRegister(reg(ra_, node));
 121   }
 122   VectorRegister as_VectorRegister(PhaseRegAlloc *ra_, const Node *node, int idx) const {
 123     return ::as_VectorRegister(reg(ra_, node, idx));
 124   }
 125   VectorSRegister as_VectorSRegister(PhaseRegAlloc *ra_, const Node *node) const {
 126     return ::as_VectorSRegister(reg(ra_, node));
 127   }
 128   VectorSRegister as_VectorSRegister(PhaseRegAlloc *ra_, const Node *node, int idx) const {
 129     return ::as_VectorSRegister(reg(ra_, node, idx));
 130   }
 131 #endif
 132 
 133   virtual intptr_t  constant() const;
 134   virtual relocInfo::relocType constant_reloc() const;
 135   virtual jdouble constantD() const;
 136   virtual jfloat  constantF() const;
 137   virtual jlong   constantL() const;
 138   virtual TypeOopPtr *oop() const;
 139   virtual int  ccode() const;
 140   // A zero, default, indicates this value is not needed.
 141   // May need to lookup the base register, as done in int_ and ext_format
 142   virtual int  base (PhaseRegAlloc *ra_, const Node *node, int idx) const;
 143   virtual int  index(PhaseRegAlloc *ra_, const Node *node, int idx) const;
 144   virtual int  scale() const;
 145   // Parameters needed to support MEMORY_INTERFACE access to stackSlot
 146   virtual int  disp (PhaseRegAlloc *ra_, const Node *node, int idx) const;
 147   // Check for PC-Relative displacement
 148   virtual relocInfo::relocType disp_reloc() const;
 149   virtual int  constant_disp() const;   // usu. 0, may return Type::OffsetBot
 150   virtual int  base_position()  const;  // base edge position, or -1
 151   virtual int  index_position() const;  // index edge position, or -1
 152 
 153   // Access the TypeKlassPtr of operands with a base==RegI and disp==RegP
 154   // Only returns non-null value for i486.ad&#39;s indOffset32X
 155   virtual const TypePtr *disp_as_type() const { return NULL; }
 156 
 157   // Return the label
 158   virtual Label *label() const;
 159 
 160   // Return the method&#39;s address
 161   virtual intptr_t  method() const;
 162 
 163   // Hash and compare over operands are currently identical
 164   virtual uint  hash() const;
 165   virtual bool  cmp( const MachOper &amp;oper ) const;
 166 
 167   // Virtual clone, since I do not know how big the MachOper is.
 168   virtual MachOper *clone() const = 0;
 169 
 170   // Return ideal Type from simple operands.  Fail for complex operands.
 171   virtual const Type *type() const;
 172 
 173   // Set an integer offset if we have one, or error otherwise
 174   virtual void set_con( jint c0 ) { ShouldNotReachHere();  }
 175 
 176 #ifndef PRODUCT
 177   // Return name of operand
 178   virtual const char    *Name() const { return &quot;???&quot;;}
 179 
 180   // Methods to output the text version of the operand
 181   virtual void int_format(PhaseRegAlloc *,const MachNode *node, outputStream *st) const = 0;
 182   virtual void ext_format(PhaseRegAlloc *,const MachNode *node,int idx, outputStream *st) const=0;
 183 
 184   virtual void dump_spec(outputStream *st) const; // Print per-operand info
 185 
 186   // Check whether o is a valid oper.
 187   static bool notAnOper(const MachOper *o) {
 188     if (o == NULL)                   return true;
 189     if (((intptr_t)o &amp; 1) != 0)      return true;
 190     if (*(address*)o == badAddress)  return true;  // kill by Node::destruct
 191     return false;
 192   }
 193 #endif // !PRODUCT
 194 };
 195 
 196 //------------------------------MachNode---------------------------------------
 197 // Base type for all machine specific nodes.  All node classes generated by the
 198 // ADLC inherit from this class.
 199 class MachNode : public Node {
 200 public:
 201   MachNode() : Node((uint)0), _barrier(0), _num_opnds(0), _opnds(NULL) {
 202     init_class_id(Class_Mach);
 203   }
 204   // Required boilerplate
 205   virtual uint size_of() const { return sizeof(MachNode); }
 206   virtual int  Opcode() const;          // Always equal to MachNode
 207   virtual uint rule() const = 0;        // Machine-specific opcode
 208   // Number of inputs which come before the first operand.
 209   // Generally at least 1, to skip the Control input
 210   virtual uint oper_input_base() const { return 1; }
 211   // Position of constant base node in node&#39;s inputs. -1 if
 212   // no constant base node input.
 213   virtual uint mach_constant_base_node_input() const { return (uint)-1; }
 214 
 215   uint8_t barrier_data() const { return _barrier; }
 216   void set_barrier_data(uint data) { _barrier = data; }
 217 
 218   // Copy inputs and operands to new node of instruction.
 219   // Called from cisc_version() and short_branch_version().
 220   // !!!! The method&#39;s body is defined in ad_&lt;arch&gt;.cpp file.
 221   void fill_new_machnode(MachNode *n) const;
 222 
 223   // Return an equivalent instruction using memory for cisc_operand position
 224   virtual MachNode *cisc_version(int offset);
 225   // Modify this instruction&#39;s register mask to use stack version for cisc_operand
 226   virtual void use_cisc_RegMask();
 227 
 228   // Support for short branches
 229   bool may_be_short_branch() const { return (flags() &amp; Flag_may_be_short_branch) != 0; }
 230 
 231   // Avoid back to back some instructions on some CPUs.
 232   enum AvoidBackToBackFlag { AVOID_NONE = 0,
 233                              AVOID_BEFORE = Flag_avoid_back_to_back_before,
 234                              AVOID_AFTER = Flag_avoid_back_to_back_after,
 235                              AVOID_BEFORE_AND_AFTER = AVOID_BEFORE | AVOID_AFTER };
 236 
 237   bool avoid_back_to_back(AvoidBackToBackFlag flag_value) const {
 238     return (flags() &amp; flag_value) == flag_value;
 239   }
 240 
 241   // instruction implemented with a call
 242   bool has_call() const { return (flags() &amp; Flag_has_call) != 0; }
 243 
 244   // First index in _in[] corresponding to operand, or -1 if there is none
 245   int  operand_index(uint operand) const;
 246   int  operand_index(const MachOper *oper) const;
 247   int  operand_index(Node* m) const;
 248 
 249   // Register class input is expected in
 250   virtual const RegMask &amp;in_RegMask(uint) const;
 251 
 252   // cisc-spillable instructions redefine for use by in_RegMask
 253   virtual const RegMask *cisc_RegMask() const { return NULL; }
 254 
 255   // If this instruction is a 2-address instruction, then return the
 256   // index of the input which must match the output.  Not nessecary
 257   // for instructions which bind the input and output register to the
 258   // same singleton regiser (e.g., Intel IDIV which binds AX to be
 259   // both an input and an output).  It is nessecary when the input and
 260   // output have choices - but they must use the same choice.
 261   virtual uint two_adr( ) const { return 0; }
 262 
 263   // The GC might require some barrier metadata for machine code emission.
 264   uint8_t _barrier;
 265 
 266   // Array of complex operand pointers.  Each corresponds to zero or
 267   // more leafs.  Must be set by MachNode constructor to point to an
 268   // internal array of MachOpers.  The MachOper array is sized by
 269   // specific MachNodes described in the ADL.
 270   uint _num_opnds;
 271   MachOper **_opnds;
 272   uint  num_opnds() const { return _num_opnds; }
 273 
 274   // Emit bytes into cbuf
 275   virtual void  emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 276   // Expand node after register allocation.
 277   // Node is replaced by several nodes in the postalloc expand phase.
 278   // Corresponding methods are generated for nodes if they specify
 279   // postalloc_expand. See block.cpp for more documentation.
 280   virtual bool requires_postalloc_expand() const { return false; }
 281   virtual void postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_);
 282   // Size of instruction in bytes
 283   virtual uint  size(PhaseRegAlloc *ra_) const;
 284   // Helper function that computes size by emitting code
 285   virtual uint  emit_size(PhaseRegAlloc *ra_) const;
 286 
 287   // Return the alignment required (in units of relocInfo::addr_unit())
 288   // for this instruction (must be a power of 2)
 289   virtual int   alignment_required() const { return 1; }
 290 
 291   // Return the padding (in bytes) to be emitted before this
 292   // instruction to properly align it.
 293   virtual int   compute_padding(int current_offset) const { return 0; }
 294 
 295   // Return number of relocatable values contained in this instruction
 296   virtual int   reloc() const { return 0; }
 297 
 298   // Return number of words used for double constants in this instruction
 299   virtual int   ins_num_consts() const { return 0; }
 300 
 301   // Hash and compare over operands.  Used to do GVN on machine Nodes.
 302   virtual uint  hash() const;
 303   virtual bool  cmp( const Node &amp;n ) const;
 304 
 305   // Expand method for MachNode, replaces nodes representing pseudo
 306   // instructions with a set of nodes which represent real machine
 307   // instructions and compute the same value.
 308   virtual MachNode *Expand( State *, Node_List &amp;proj_list, Node* mem ) { return this; }
 309 
 310   // Bottom_type call; value comes from operand0
 311   virtual const class Type *bottom_type() const { return _opnds[0]-&gt;type(); }
 312   virtual uint ideal_reg() const {
 313     const Type *t = _opnds[0]-&gt;type();
 314     if (t == TypeInt::CC) {
 315       return Op_RegFlags;
 316     } else {
 317       return t-&gt;ideal_reg();
 318     }
 319   }
 320 
 321   // If this is a memory op, return the base pointer and fixed offset.
 322   // If there are no such, return NULL.  If there are multiple addresses
 323   // or the address is indeterminate (rare cases) then return (Node*)-1,
 324   // which serves as node bottom.
 325   // If the offset is not statically determined, set it to Type::OffsetBot.
 326   // This method is free to ignore stack slots if that helps.
 327   #define TYPE_PTR_SENTINAL  ((const TypePtr*)-1)
 328   // Passing TYPE_PTR_SENTINAL as adr_type asks for computation of the adr_type if possible
 329   const Node* get_base_and_disp(intptr_t &amp;offset, const TypePtr* &amp;adr_type) const;
 330 
 331   // Helper for get_base_and_disp: find the base and index input nodes.
 332   // Returns the MachOper as determined by memory_operand(), for use, if
 333   // needed by the caller. If (MachOper *)-1 is returned, base and index
 334   // are set to NodeSentinel. If (MachOper *) NULL is returned, base and
 335   // index are set to NULL.
 336   const MachOper* memory_inputs(Node* &amp;base, Node* &amp;index) const;
 337 
 338   // Helper for memory_inputs:  Which operand carries the necessary info?
 339   // By default, returns NULL, which means there is no such operand.
 340   // If it returns (MachOper*)-1, this means there are multiple memories.
 341   virtual const MachOper* memory_operand() const { return NULL; }
 342 
 343   // Call &quot;get_base_and_disp&quot; to decide which category of memory is used here.
 344   virtual const class TypePtr *adr_type() const;
 345 
 346   // Apply peephole rule(s) to this instruction
 347   virtual MachNode *peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &amp;deleted);
 348 
 349   // Top-level ideal Opcode matched
 350   virtual int ideal_Opcode()     const { return Op_Node; }
 351 
 352   // Adds the label for the case
 353   virtual void add_case_label( int switch_val, Label* blockLabel);
 354 
 355   // Set the absolute address for methods
 356   virtual void method_set( intptr_t addr );
 357 
 358   // Should we clone rather than spill this instruction?
 359   bool rematerialize() const;
 360 
 361   // Get the pipeline info
 362   static const Pipeline *pipeline_class();
 363   virtual const Pipeline *pipeline() const;
 364 
 365   // Returns true if this node is a check that can be implemented with a trap.
 366   virtual bool is_TrapBasedCheckNode() const { return false; }
 367 
 368 #ifndef PRODUCT
 369   virtual const char *Name() const = 0; // Machine-specific name
 370   virtual void dump_spec(outputStream *st) const; // Print per-node info
 371   void         dump_format(PhaseRegAlloc *ra, outputStream *st) const; // access to virtual
 372 #endif
 373 };
 374 
 375 //------------------------------MachIdealNode----------------------------
 376 // Machine specific versions of nodes that must be defined by user.
 377 // These are not converted by matcher from ideal nodes to machine nodes
 378 // but are inserted into the code by the compiler.
 379 class MachIdealNode : public MachNode {
 380 public:
 381   MachIdealNode( ) {}
 382 
 383   // Define the following defaults for non-matched machine nodes
 384   virtual uint oper_input_base() const { return 0; }
 385   virtual uint rule()            const { return 9999999; }
 386   virtual const class Type *bottom_type() const { return _opnds == NULL ? Type::CONTROL : MachNode::bottom_type(); }
 387 };
 388 
 389 //------------------------------MachTypeNode----------------------------
 390 // Machine Nodes that need to retain a known Type.
 391 class MachTypeNode : public MachNode {
 392   virtual uint size_of() const { return sizeof(*this); } // Size is bigger
 393 public:
 394   MachTypeNode( ) {}
 395   const Type *_bottom_type;
 396 
 397   virtual const class Type *bottom_type() const { return _bottom_type; }
 398 #ifndef PRODUCT
 399   virtual void dump_spec(outputStream *st) const;
 400 #endif
 401 };
 402 
 403 //------------------------------MachBreakpointNode----------------------------
 404 // Machine breakpoint or interrupt Node
 405 class MachBreakpointNode : public MachIdealNode {
 406 public:
 407   MachBreakpointNode( ) {}
 408   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 409   virtual uint size(PhaseRegAlloc *ra_) const;
 410 
 411 #ifndef PRODUCT
 412   virtual const char *Name() const { return &quot;Breakpoint&quot;; }
 413   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 414 #endif
 415 };
 416 
 417 //------------------------------MachConstantBaseNode--------------------------
 418 // Machine node that represents the base address of the constant table.
 419 class MachConstantBaseNode : public MachIdealNode {
 420 public:
 421   static const RegMask&amp; _out_RegMask;  // We need the out_RegMask statically in MachConstantNode::in_RegMask().
 422 
 423 public:
 424   MachConstantBaseNode() : MachIdealNode() {
 425     init_class_id(Class_MachConstantBase);
 426   }
 427   virtual const class Type* bottom_type() const { return TypeRawPtr::NOTNULL; }
 428   virtual uint ideal_reg() const { return Op_RegP; }
 429   virtual uint oper_input_base() const { return 1; }
 430 
 431   virtual bool requires_postalloc_expand() const;
 432   virtual void postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_);
 433 
 434   virtual void emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const;
 435   virtual uint size(PhaseRegAlloc* ra_) const;
 436   virtual bool pinned() const { return UseRDPCForConstantTableBase; }
 437 
 438   static const RegMask&amp; static_out_RegMask() { return _out_RegMask; }
 439   virtual const RegMask&amp; out_RegMask() const { return static_out_RegMask(); }
 440 
 441 #ifndef PRODUCT
 442   virtual const char* Name() const { return &quot;MachConstantBaseNode&quot;; }
 443   virtual void format(PhaseRegAlloc*, outputStream* st) const;
 444 #endif
 445 };
 446 
 447 //------------------------------MachConstantNode-------------------------------
 448 // Machine node that holds a constant which is stored in the constant table.
 449 class MachConstantNode : public MachTypeNode {
 450 protected:
<a name="2" id="anc2"></a><span class="line-modified"> 451   Compile::Constant _constant;  // This node&#39;s constant.</span>
 452 
 453 public:
 454   MachConstantNode() : MachTypeNode() {
 455     init_class_id(Class_MachConstant);
 456   }
 457 
 458   virtual void eval_constant(Compile* C) {
 459 #ifdef ASSERT
 460     tty-&gt;print(&quot;missing MachConstantNode eval_constant function: &quot;);
 461     dump();
 462 #endif
 463     ShouldNotCallThis();
 464   }
 465 
 466   virtual const RegMask &amp;in_RegMask(uint idx) const {
 467     if (idx == mach_constant_base_node_input())
 468       return MachConstantBaseNode::static_out_RegMask();
 469     return MachNode::in_RegMask(idx);
 470   }
 471 
 472   // Input edge of MachConstantBaseNode.
 473   virtual uint mach_constant_base_node_input() const { return req() - 1; }
 474 
 475   int  constant_offset();
 476   int  constant_offset() const { return ((MachConstantNode*) this)-&gt;constant_offset(); }
 477   // Unchecked version to avoid assertions in debug output.
 478   int  constant_offset_unchecked() const;
 479 };
 480 
 481 //------------------------------MachVEPNode-----------------------------------
 482 // Machine Value Type Entry Point Node
 483 class MachVEPNode : public MachIdealNode {
 484 public:
 485   Label* _verified_entry;
 486 
 487   MachVEPNode(Label* verified_entry, bool verified, bool receiver_only) :
 488     _verified_entry(verified_entry),
 489     _verified(verified),
 490     _receiver_only(receiver_only) {
 491     init_class_id(Class_MachVEP);
 492   }
 493   virtual bool cmp(const Node &amp;n) const {
 494     return (_verified_entry == ((MachVEPNode&amp;)n)._verified_entry) &amp;&amp;
 495            (_verified == ((MachVEPNode&amp;)n)._verified) &amp;&amp;
 496            (_receiver_only == ((MachVEPNode&amp;)n)._receiver_only) &amp;&amp;
 497            MachIdealNode::cmp(n);
 498   }
 499   virtual uint size_of() const { return sizeof(*this); }
 500   virtual void emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const;
 501 
 502 #ifndef PRODUCT
 503   virtual const char* Name() const { return &quot;ValueType Entry-Point&quot;; }
 504   virtual void format(PhaseRegAlloc*, outputStream* st) const;
 505 #endif
 506 private:
 507   bool   _verified;
 508   bool   _receiver_only;
 509 };
 510 
 511 //------------------------------MachUEPNode-----------------------------------
 512 // Machine Unvalidated Entry Point Node
 513 class MachUEPNode : public MachIdealNode {
 514 public:
 515   MachUEPNode( ) {}
 516   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 517 
 518 #ifndef PRODUCT
 519   virtual const char *Name() const { return &quot;Unvalidated-Entry-Point&quot;; }
 520   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 521 #endif
 522 };
 523 
 524 //------------------------------MachPrologNode--------------------------------
 525 // Machine function Prolog Node
 526 class MachPrologNode : public MachIdealNode {
 527 public:
 528   Label* _verified_entry;
 529 
 530   MachPrologNode(Label* verified_entry) : _verified_entry(verified_entry) {
 531     init_class_id(Class_MachProlog);
 532   }
 533   virtual bool cmp(const Node &amp;n) const {
 534     return (_verified_entry == ((MachPrologNode&amp;)n)._verified_entry) &amp;&amp; MachIdealNode::cmp(n);
 535   }
 536   virtual uint size_of() const { return sizeof(*this); }
 537   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 538   virtual int reloc() const;
 539 
 540 #ifndef PRODUCT
 541   virtual const char *Name() const { return &quot;Prolog&quot;; }
 542   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 543 #endif
 544 };
 545 
 546 //------------------------------MachEpilogNode--------------------------------
 547 // Machine function Epilog Node
 548 class MachEpilogNode : public MachIdealNode {
 549 public:
 550   MachEpilogNode(bool do_poll = false) : _do_polling(do_poll) {}
 551   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 552   virtual int reloc() const;
 553   virtual const Pipeline *pipeline() const;
 554 
 555 private:
 556   bool _do_polling;
 557 
 558 public:
 559   bool do_polling() const { return _do_polling; }
 560 
 561   // Offset of safepoint from the beginning of the node
 562   int safepoint_offset() const;
 563 
 564 #ifndef PRODUCT
 565   virtual const char *Name() const { return &quot;Epilog&quot;; }
 566   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 567 #endif
 568 };
 569 
 570 //------------------------------MachNopNode-----------------------------------
 571 // Machine function Nop Node
 572 class MachNopNode : public MachIdealNode {
 573 private:
 574   int _count;
 575 public:
 576   MachNopNode( ) : _count(1) {}
 577   MachNopNode( int count ) : _count(count) {}
 578   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 579   virtual uint size(PhaseRegAlloc *ra_) const;
 580 
 581   virtual const class Type *bottom_type() const { return Type::CONTROL; }
 582 
 583   virtual int ideal_Opcode() const { return Op_Con; } // bogus; see output.cpp
 584   virtual const Pipeline *pipeline() const;
 585 #ifndef PRODUCT
 586   virtual const char *Name() const { return &quot;Nop&quot;; }
 587   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 588   virtual void dump_spec(outputStream *st) const { } // No per-operand info
 589 #endif
 590 };
 591 
 592 //------------------------------MachSpillCopyNode------------------------------
 593 // Machine SpillCopy Node.  Copies 1 or 2 words from any location to any
 594 // location (stack or register).
 595 class MachSpillCopyNode : public MachIdealNode {
 596 public:
 597   enum SpillType {
 598     TwoAddress,                        // Inserted when coalescing of a two-address-instruction node and its input fails
 599     PhiInput,                          // Inserted when coalescing of a phi node and its input fails
 600     DebugUse,                          // Inserted as debug info spills to safepoints in non-frequent blocks
 601     LoopPhiInput,                      // Pre-split compares of loop-phis
 602     Definition,                        // An lrg marked as spilled will be spilled to memory right after its definition,
 603                                        // if in high pressure region or the lrg is bound
 604     RegToReg,                          // A register to register move
 605     RegToMem,                          // A register to memory move
 606     MemToReg,                          // A memory to register move
 607     PhiLocationDifferToInputLocation,  // When coalescing phi nodes in PhaseChaitin::Split(), a move spill is inserted if
 608                                        // the phi and its input resides at different locations (i.e. reg or mem)
 609     BasePointerToMem,                  // Spill base pointer to memory at safepoint
 610     InputToRematerialization,          // When rematerializing a node we stretch the inputs live ranges, and they might be
 611                                        // stretched beyond a new definition point, therefore we split out new copies instead
 612     CallUse,                           // Spill use at a call
 613     Bound                              // An lrg marked as spill that is bound and needs to be spilled at a use
 614   };
 615 private:
 616   const RegMask *_in;           // RegMask for input
 617   const RegMask *_out;          // RegMask for output
 618   const Type *_type;
 619   const SpillType _spill_type;
 620 public:
 621   MachSpillCopyNode(SpillType spill_type, Node *n, const RegMask &amp;in, const RegMask &amp;out ) :
 622     MachIdealNode(), _in(&amp;in), _out(&amp;out), _type(n-&gt;bottom_type()), _spill_type(spill_type) {
 623     init_class_id(Class_MachSpillCopy);
 624     init_flags(Flag_is_Copy);
 625     add_req(NULL);
 626     add_req(n);
 627   }
 628   virtual uint size_of() const { return sizeof(*this); }
 629   void set_out_RegMask(const RegMask &amp;out) { _out = &amp;out; }
 630   void set_in_RegMask(const RegMask &amp;in) { _in = &amp;in; }
 631   virtual const RegMask &amp;out_RegMask() const { return *_out; }
 632   virtual const RegMask &amp;in_RegMask(uint) const { return *_in; }
 633   virtual const class Type *bottom_type() const { return _type; }
 634   virtual uint ideal_reg() const { return _type-&gt;ideal_reg(); }
 635   virtual uint oper_input_base() const { return 1; }
 636   uint implementation( CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const;
 637 
 638   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 639   virtual uint size(PhaseRegAlloc *ra_) const;
 640 
 641 
 642 #ifndef PRODUCT
 643   static const char *spill_type(SpillType st) {
 644     switch (st) {
 645       case TwoAddress:
 646         return &quot;TwoAddressSpillCopy&quot;;
 647       case PhiInput:
 648         return &quot;PhiInputSpillCopy&quot;;
 649       case DebugUse:
 650         return &quot;DebugUseSpillCopy&quot;;
 651       case LoopPhiInput:
 652         return &quot;LoopPhiInputSpillCopy&quot;;
 653       case Definition:
 654         return &quot;DefinitionSpillCopy&quot;;
 655       case RegToReg:
 656         return &quot;RegToRegSpillCopy&quot;;
 657       case RegToMem:
 658         return &quot;RegToMemSpillCopy&quot;;
 659       case MemToReg:
 660         return &quot;MemToRegSpillCopy&quot;;
 661       case PhiLocationDifferToInputLocation:
 662         return &quot;PhiLocationDifferToInputLocationSpillCopy&quot;;
 663       case BasePointerToMem:
 664         return &quot;BasePointerToMemSpillCopy&quot;;
 665       case InputToRematerialization:
 666         return &quot;InputToRematerializationSpillCopy&quot;;
 667       case CallUse:
 668         return &quot;CallUseSpillCopy&quot;;
 669       case Bound:
 670         return &quot;BoundSpillCopy&quot;;
 671       default:
 672         assert(false, &quot;Must have valid spill type&quot;);
 673         return &quot;MachSpillCopy&quot;;
 674     }
 675   }
 676 
 677   virtual const char *Name() const {
 678     return spill_type(_spill_type);
 679   }
 680 
 681   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 682 #endif
 683 };
 684 
 685 // MachMergeNode is similar to a PhiNode in a sense it merges multiple values,
 686 // however it doesn&#39;t have a control input and is more like a MergeMem.
 687 // It is inserted after the register allocation is done to ensure that nodes use single
 688 // definition of a multidef lrg in a block.
 689 class MachMergeNode : public MachIdealNode {
 690 public:
 691   MachMergeNode(Node *n1) {
 692     init_class_id(Class_MachMerge);
 693     add_req(NULL);
 694     add_req(n1);
 695   }
 696   virtual const RegMask &amp;out_RegMask() const { return in(1)-&gt;out_RegMask(); }
 697   virtual const RegMask &amp;in_RegMask(uint idx) const { return in(1)-&gt;in_RegMask(idx); }
 698   virtual const class Type *bottom_type() const { return in(1)-&gt;bottom_type(); }
 699   virtual uint ideal_reg() const { return bottom_type()-&gt;ideal_reg(); }
 700   virtual uint oper_input_base() const { return 1; }
 701   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const { }
 702   virtual uint size(PhaseRegAlloc *ra_) const { return 0; }
 703 #ifndef PRODUCT
 704   virtual const char *Name() const { return &quot;MachMerge&quot;; }
 705 #endif
 706 };
 707 
 708 //------------------------------MachBranchNode--------------------------------
 709 // Abstract machine branch Node
 710 class MachBranchNode : public MachIdealNode {
 711 public:
 712   MachBranchNode() : MachIdealNode() {
 713     init_class_id(Class_MachBranch);
 714   }
 715   virtual void label_set(Label* label, uint block_num) = 0;
 716   virtual void save_label(Label** label, uint* block_num) = 0;
 717 
 718   // Support for short branches
 719   virtual MachNode *short_branch_version() { return NULL; }
 720 
 721   virtual bool pinned() const { return true; };
 722 };
 723 
 724 //------------------------------MachNullChkNode--------------------------------
 725 // Machine-dependent null-pointer-check Node.  Points a real MachNode that is
 726 // also some kind of memory op.  Turns the indicated MachNode into a
 727 // conditional branch with good latency on the ptr-not-null path and awful
 728 // latency on the pointer-is-null path.
 729 
 730 class MachNullCheckNode : public MachBranchNode {
 731 public:
 732   const uint _vidx;             // Index of memop being tested
 733   MachNullCheckNode( Node *ctrl, Node *memop, uint vidx ) : MachBranchNode(), _vidx(vidx) {
 734     init_class_id(Class_MachNullCheck);
 735     add_req(ctrl);
 736     add_req(memop);
 737   }
 738   virtual uint size_of() const { return sizeof(*this); }
 739 
 740   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 741   virtual void label_set(Label* label, uint block_num);
 742   virtual void save_label(Label** label, uint* block_num);
 743   virtual void negate() { }
 744   virtual const class Type *bottom_type() const { return TypeTuple::IFBOTH; }
 745   virtual uint ideal_reg() const { return NotAMachineReg; }
 746   virtual const RegMask &amp;in_RegMask(uint) const;
 747   virtual const RegMask &amp;out_RegMask() const { return RegMask::Empty; }
 748 #ifndef PRODUCT
 749   virtual const char *Name() const { return &quot;NullCheck&quot;; }
 750   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 751 #endif
 752 };
 753 
 754 //------------------------------MachProjNode----------------------------------
 755 // Machine-dependent Ideal projections (how is that for an oxymoron).  Really
 756 // just MachNodes made by the Ideal world that replicate simple projections
 757 // but with machine-dependent input &amp; output register masks.  Generally
 758 // produced as part of calling conventions.  Normally I make MachNodes as part
 759 // of the Matcher process, but the Matcher is ill suited to issues involving
 760 // frame handling, so frame handling is all done in the Ideal world with
 761 // occasional callbacks to the machine model for important info.
 762 class MachProjNode : public ProjNode {
 763 public:
 764   MachProjNode( Node *multi, uint con, const RegMask &amp;out, uint ideal_reg ) : ProjNode(multi,con), _rout(out), _ideal_reg(ideal_reg) {
 765     init_class_id(Class_MachProj);
 766   }
 767   RegMask _rout;
 768   const uint  _ideal_reg;
 769   enum projType {
 770     unmatched_proj = 0,         // Projs for Control, I/O, memory not matched
 771     fat_proj       = 999        // Projs killing many regs, defined by _rout
 772   };
 773   virtual int   Opcode() const;
 774   virtual const Type *bottom_type() const;
 775   virtual const TypePtr *adr_type() const;
 776   virtual const RegMask &amp;in_RegMask(uint) const { return RegMask::Empty; }
 777   virtual const RegMask &amp;out_RegMask() const { return _rout; }
 778   virtual uint  ideal_reg() const { return _ideal_reg; }
 779   // Need size_of() for virtual ProjNode::clone()
 780   virtual uint  size_of() const { return sizeof(MachProjNode); }
 781 #ifndef PRODUCT
 782   virtual void dump_spec(outputStream *st) const;
 783 #endif
 784 };
 785 
 786 //------------------------------MachIfNode-------------------------------------
 787 // Machine-specific versions of IfNodes
 788 class MachIfNode : public MachBranchNode {
 789   virtual uint size_of() const { return sizeof(*this); } // Size is bigger
 790 public:
 791   float _prob;                  // Probability branch goes either way
 792   float _fcnt;                  // Frequency counter
 793   MachIfNode() : MachBranchNode() {
 794     init_class_id(Class_MachIf);
 795   }
 796   // Negate conditional branches.
 797   virtual void negate() = 0;
 798 #ifndef PRODUCT
 799   virtual void dump_spec(outputStream *st) const;
 800 #endif
 801 };
 802 
 803 //------------------------------MachJumpNode-----------------------------------
 804 // Machine-specific versions of JumpNodes
 805 class MachJumpNode : public MachConstantNode {
 806 public:
 807   float* _probs;
 808   MachJumpNode() : MachConstantNode() {
 809     init_class_id(Class_MachJump);
 810   }
 811 };
 812 
 813 //------------------------------MachGotoNode-----------------------------------
 814 // Machine-specific versions of GotoNodes
 815 class MachGotoNode : public MachBranchNode {
 816 public:
 817   MachGotoNode() : MachBranchNode() {
 818     init_class_id(Class_MachGoto);
 819   }
 820 };
 821 
 822 //------------------------------MachFastLockNode-------------------------------------
 823 // Machine-specific versions of FastLockNodes
 824 class MachFastLockNode : public MachNode {
 825   virtual uint size_of() const { return sizeof(*this); } // Size is bigger
 826 public:
 827   BiasedLockingCounters*        _counters;
 828   RTMLockingCounters*       _rtm_counters; // RTM lock counters for inflated locks
 829   RTMLockingCounters* _stack_rtm_counters; // RTM lock counters for stack locks
 830   MachFastLockNode() : MachNode() {}
 831 };
 832 
 833 //------------------------------MachReturnNode--------------------------------
 834 // Machine-specific versions of subroutine returns
 835 class MachReturnNode : public MachNode {
 836   virtual uint size_of() const; // Size is bigger
 837 public:
 838   RegMask *_in_rms;             // Input register masks, set during allocation
 839   ReallocMark _nesting;         // assertion check for reallocations
 840   const TypePtr* _adr_type;     // memory effects of call or return
 841   MachReturnNode() : MachNode() {
 842     init_class_id(Class_MachReturn);
 843     _adr_type = TypePtr::BOTTOM; // the default: all of memory
 844   }
 845 
 846   void set_adr_type(const TypePtr* atp) { _adr_type = atp; }
 847 
 848   virtual const RegMask &amp;in_RegMask(uint) const;
 849   virtual bool pinned() const { return true; };
 850   virtual const TypePtr *adr_type() const;
 851 };
 852 
 853 //------------------------------MachSafePointNode-----------------------------
 854 // Machine-specific versions of safepoints
 855 class MachSafePointNode : public MachReturnNode {
 856 public:
 857   OopMap*         _oop_map;     // Array of OopMap info (8-bit char) for GC
 858   JVMState*       _jvms;        // Pointer to list of JVM State Objects
 859   uint            _jvmadj;      // Extra delta to jvms indexes (mach. args)
 860   OopMap*         oop_map() const { return _oop_map; }
 861   void            set_oop_map(OopMap* om) { _oop_map = om; }
 862 
 863   MachSafePointNode() : MachReturnNode(), _oop_map(NULL), _jvms(NULL), _jvmadj(0) {
 864     init_class_id(Class_MachSafePoint);
 865   }
 866 
 867   virtual JVMState* jvms() const { return _jvms; }
 868   void set_jvms(JVMState* s) {
 869     _jvms = s;
 870   }
 871   virtual const Type    *bottom_type() const;
 872 
 873   virtual const RegMask &amp;in_RegMask(uint) const;
 874 
 875   // Functionality from old debug nodes
 876   Node *returnadr() const { return in(TypeFunc::ReturnAdr); }
 877   Node *frameptr () const { return in(TypeFunc::FramePtr); }
 878 
 879   Node *local(const JVMState* jvms, uint idx) const {
 880     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 881     return in(_jvmadj + jvms-&gt;locoff() + idx);
 882   }
 883   Node *stack(const JVMState* jvms, uint idx) const {
 884     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 885     return in(_jvmadj + jvms-&gt;stkoff() + idx);
 886  }
 887   Node *monitor_obj(const JVMState* jvms, uint idx) const {
 888     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 889     return in(_jvmadj + jvms-&gt;monitor_obj_offset(idx));
 890   }
 891   Node *monitor_box(const JVMState* jvms, uint idx) const {
 892     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 893     return in(_jvmadj + jvms-&gt;monitor_box_offset(idx));
 894   }
 895   void  set_local(const JVMState* jvms, uint idx, Node *c) {
 896     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 897     set_req(_jvmadj + jvms-&gt;locoff() + idx, c);
 898   }
 899   void  set_stack(const JVMState* jvms, uint idx, Node *c) {
 900     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 901     set_req(_jvmadj + jvms-&gt;stkoff() + idx, c);
 902   }
 903   void  set_monitor(const JVMState* jvms, uint idx, Node *c) {
 904     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 905     set_req(_jvmadj + jvms-&gt;monoff() + idx, c);
 906   }
 907 };
 908 
 909 //------------------------------MachCallNode----------------------------------
 910 // Machine-specific versions of subroutine calls
 911 class MachCallNode : public MachSafePointNode {
 912 protected:
 913   virtual uint hash() const { return NO_HASH; }  // CFG nodes do not hash
 914   virtual bool cmp( const Node &amp;n ) const;
 915   virtual uint size_of() const = 0; // Size is bigger
 916 public:
 917   const TypeFunc *_tf;        // Function type
 918   address      _entry_point;  // Address of the method being called
 919   float        _cnt;          // Estimate of number of times called
 920   uint         _argsize;      // Size of argument block on stack
 921 
 922   const TypeFunc* tf()        const { return _tf; }
 923   const address entry_point() const { return _entry_point; }
 924   const float   cnt()         const { return _cnt; }
 925   uint argsize()              const { return _argsize; }
 926 
 927   void set_tf(const TypeFunc* tf) { _tf = tf; }
 928   void set_entry_point(address p) { _entry_point = p; }
 929   void set_cnt(float c)           { _cnt = c; }
 930   void set_argsize(int s)         { _argsize = s; }
 931 
 932   MachCallNode() : MachSafePointNode() {
 933     init_class_id(Class_MachCall);
 934   }
 935 
 936   virtual const Type *bottom_type() const;
 937   virtual bool  pinned() const { return false; }
 938   virtual const Type* Value(PhaseGVN* phase) const;
 939   virtual const RegMask &amp;in_RegMask(uint) const;
 940   virtual int ret_addr_offset() { return 0; }
 941 
 942   bool returns_long() const { return tf()-&gt;return_type() == T_LONG; }
 943   bool return_value_is_used() const;
 944 
 945   // Similar to cousin class CallNode::returns_pointer
 946   bool returns_pointer() const;
 947   bool returns_vt() const;
 948 
 949 #ifndef PRODUCT
 950   virtual void dump_spec(outputStream *st) const;
 951 #endif
 952 };
 953 
 954 //------------------------------MachCallJavaNode------------------------------
 955 // &quot;Base&quot; class for machine-specific versions of subroutine calls
 956 class MachCallJavaNode : public MachCallNode {
 957 protected:
 958   virtual bool cmp( const Node &amp;n ) const;
 959   virtual uint size_of() const; // Size is bigger
 960 public:
 961   ciMethod* _method;                 // Method being direct called
 962   bool      _override_symbolic_info; // Override symbolic call site info from bytecode
 963   int       _bci;                    // Byte Code index of call byte code
 964   bool      _optimized_virtual;      // Tells if node is a static call or an optimized virtual
 965   bool      _method_handle_invoke;   // Tells if the call has to preserve SP
 966   MachCallJavaNode() : MachCallNode(), _override_symbolic_info(false) {
 967     init_class_id(Class_MachCallJava);
 968   }
 969 
 970   virtual const RegMask &amp;in_RegMask(uint) const;
 971 
 972   int resolved_method_index(CodeBuffer &amp;cbuf) const {
 973     if (_override_symbolic_info) {
 974       // Attach corresponding Method* to the call site, so VM can use it during resolution
 975       // instead of querying symbolic info from bytecode.
 976       assert(_method != NULL, &quot;method should be set&quot;);
 977       assert(_method-&gt;constant_encoding()-&gt;is_method(), &quot;should point to a Method&quot;);
 978       return cbuf.oop_recorder()-&gt;find_index(_method-&gt;constant_encoding());
 979     }
 980     return 0; // Use symbolic info from bytecode (resolved_method == NULL).
 981   }
 982 
 983 #ifndef PRODUCT
 984   virtual void dump_spec(outputStream *st) const;
 985 #endif
 986 };
 987 
 988 //------------------------------MachCallStaticJavaNode------------------------
 989 // Machine-specific versions of monomorphic subroutine calls
 990 class MachCallStaticJavaNode : public MachCallJavaNode {
 991   virtual bool cmp( const Node &amp;n ) const;
 992   virtual uint size_of() const; // Size is bigger
 993 public:
 994   const char *_name;            // Runtime wrapper name
 995   MachCallStaticJavaNode() : MachCallJavaNode() {
 996     init_class_id(Class_MachCallStaticJava);
 997   }
 998 
 999   // If this is an uncommon trap, return the request code, else zero.
1000   int uncommon_trap_request() const;
1001 
1002   virtual int ret_addr_offset();
1003 #ifndef PRODUCT
1004   virtual void dump_spec(outputStream *st) const;
1005   void dump_trap_args(outputStream *st) const;
1006 #endif
1007 };
1008 
1009 //------------------------------MachCallDynamicJavaNode------------------------
1010 // Machine-specific versions of possibly megamorphic subroutine calls
1011 class MachCallDynamicJavaNode : public MachCallJavaNode {
1012 public:
1013   int _vtable_index;
1014   MachCallDynamicJavaNode() : MachCallJavaNode() {
1015     init_class_id(Class_MachCallDynamicJava);
1016     DEBUG_ONLY(_vtable_index = -99);  // throw an assert if uninitialized
1017   }
1018   virtual int ret_addr_offset();
1019 #ifndef PRODUCT
1020   virtual void dump_spec(outputStream *st) const;
1021 #endif
1022 };
1023 
1024 //------------------------------MachCallRuntimeNode----------------------------
1025 // Machine-specific versions of subroutine calls
1026 class MachCallRuntimeNode : public MachCallNode {
1027   virtual bool cmp( const Node &amp;n ) const;
1028   virtual uint size_of() const; // Size is bigger
1029 public:
1030   const char *_name;            // Printable name, if _method is NULL
1031   MachCallRuntimeNode() : MachCallNode() {
1032     init_class_id(Class_MachCallRuntime);
1033   }
1034   virtual int ret_addr_offset();
1035 #ifndef PRODUCT
1036   virtual void dump_spec(outputStream *st) const;
1037 #endif
1038 };
1039 
1040 class MachCallLeafNode: public MachCallRuntimeNode {
1041 public:
1042   MachCallLeafNode() : MachCallRuntimeNode() {
1043     init_class_id(Class_MachCallLeaf);
1044   }
1045 };
1046 
1047 //------------------------------MachHaltNode-----------------------------------
1048 // Machine-specific versions of halt nodes
1049 class MachHaltNode : public MachReturnNode {
1050 public:
1051   const char* _halt_reason;
1052   virtual JVMState* jvms() const;
1053 };
1054 
1055 class MachMemBarNode : public MachNode {
1056   virtual uint size_of() const; // Size is bigger
1057 public:
1058   const TypePtr* _adr_type;     // memory effects
1059   MachMemBarNode() : MachNode() {
1060     init_class_id(Class_MachMemBar);
1061     _adr_type = TypePtr::BOTTOM; // the default: all of memory
1062   }
1063 
1064   void set_adr_type(const TypePtr* atp) { _adr_type = atp; }
1065   virtual const TypePtr *adr_type() const;
1066 };
1067 
1068 
1069 //------------------------------MachTempNode-----------------------------------
1070 // Node used by the adlc to construct inputs to represent temporary registers
1071 class MachTempNode : public MachNode {
1072 private:
1073   MachOper *_opnd_array[1];
1074 
1075 public:
1076   virtual const RegMask &amp;out_RegMask() const { return *_opnds[0]-&gt;in_RegMask(0); }
1077   virtual uint rule() const { return 9999999; }
1078   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {}
1079 
1080   MachTempNode(MachOper* oper) {
1081     init_class_id(Class_MachTemp);
1082     _num_opnds = 1;
1083     _opnds = _opnd_array;
1084     add_req(NULL);
1085     _opnds[0] = oper;
1086   }
1087   virtual uint size_of() const { return sizeof(MachTempNode); }
1088 
1089 #ifndef PRODUCT
1090   virtual void format(PhaseRegAlloc *, outputStream *st ) const {}
1091   virtual const char *Name() const { return &quot;MachTemp&quot;;}
1092 #endif
1093 };
1094 
1095 
1096 
1097 //------------------------------labelOper--------------------------------------
1098 // Machine-independent version of label operand
1099 class labelOper : public MachOper {
1100 private:
1101   virtual uint           num_edges() const { return 0; }
1102 public:
1103   // Supported for fixed size branches
1104   Label* _label;                // Label for branch(es)
1105 
1106   uint _block_num;
1107 
1108   labelOper() : _label(0), _block_num(0) {}
1109 
1110   labelOper(Label* label, uint block_num) : _label(label), _block_num(block_num) {}
1111 
1112   labelOper(labelOper* l) : _label(l-&gt;_label) , _block_num(l-&gt;_block_num) {}
1113 
1114   virtual MachOper *clone() const;
1115 
1116   virtual Label *label() const { assert(_label != NULL, &quot;need Label&quot;); return _label; }
1117 
1118   virtual uint           opcode() const;
1119 
1120   virtual uint           hash()   const;
1121   virtual bool           cmp( const MachOper &amp;oper ) const;
1122 #ifndef PRODUCT
1123   virtual const char    *Name()   const { return &quot;Label&quot;;}
1124 
1125   virtual void int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;
1126   virtual void ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const { int_format( ra, node, st ); }
1127 #endif
1128 };
1129 
1130 
1131 //------------------------------methodOper--------------------------------------
1132 // Machine-independent version of method operand
1133 class methodOper : public MachOper {
1134 private:
1135   virtual uint           num_edges() const { return 0; }
1136 public:
1137   intptr_t _method;             // Address of method
1138   methodOper() :   _method(0) {}
1139   methodOper(intptr_t method) : _method(method)  {}
1140 
1141   virtual MachOper *clone() const;
1142 
1143   virtual intptr_t method() const { return _method; }
1144 
1145   virtual uint           opcode() const;
1146 
1147   virtual uint           hash()   const;
1148   virtual bool           cmp( const MachOper &amp;oper ) const;
1149 #ifndef PRODUCT
1150   virtual const char    *Name()   const { return &quot;Method&quot;;}
1151 
1152   virtual void int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;
1153   virtual void ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const { int_format( ra, node, st ); }
1154 #endif
1155 };
1156 
1157 #endif // SHARE_OPTO_MACHNODE_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/compile.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;ci/ciReplay.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;code/exceptionHandlerTable.hpp&quot;
  31 #include &quot;code/nmethod.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/compileLog.hpp&quot;
  34 #include &quot;compiler/disassembler.hpp&quot;
  35 #include &quot;compiler/oopMap.hpp&quot;
  36 #include &quot;gc/shared/barrierSet.hpp&quot;
  37 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;opto/addnode.hpp&quot;
  40 #include &quot;opto/block.hpp&quot;
  41 #include &quot;opto/c2compiler.hpp&quot;
  42 #include &quot;opto/callGenerator.hpp&quot;
  43 #include &quot;opto/callnode.hpp&quot;
  44 #include &quot;opto/castnode.hpp&quot;
  45 #include &quot;opto/cfgnode.hpp&quot;
  46 #include &quot;opto/chaitin.hpp&quot;
  47 #include &quot;opto/compile.hpp&quot;
  48 #include &quot;opto/connode.hpp&quot;
  49 #include &quot;opto/convertnode.hpp&quot;
  50 #include &quot;opto/divnode.hpp&quot;
  51 #include &quot;opto/escape.hpp&quot;
  52 #include &quot;opto/idealGraphPrinter.hpp&quot;
  53 #include &quot;opto/loopnode.hpp&quot;
  54 #include &quot;opto/machnode.hpp&quot;
  55 #include &quot;opto/macro.hpp&quot;
  56 #include &quot;opto/matcher.hpp&quot;
  57 #include &quot;opto/mathexactnode.hpp&quot;
  58 #include &quot;opto/memnode.hpp&quot;
  59 #include &quot;opto/mulnode.hpp&quot;
  60 #include &quot;opto/narrowptrnode.hpp&quot;
  61 #include &quot;opto/node.hpp&quot;
  62 #include &quot;opto/opcodes.hpp&quot;
  63 #include &quot;opto/output.hpp&quot;
  64 #include &quot;opto/parse.hpp&quot;
  65 #include &quot;opto/phaseX.hpp&quot;
  66 #include &quot;opto/rootnode.hpp&quot;
  67 #include &quot;opto/runtime.hpp&quot;
  68 #include &quot;opto/stringopts.hpp&quot;
  69 #include &quot;opto/type.hpp&quot;
  70 #include &quot;opto/valuetypenode.hpp&quot;
  71 #include &quot;opto/vectornode.hpp&quot;
  72 #include &quot;runtime/arguments.hpp&quot;
  73 #include &quot;runtime/sharedRuntime.hpp&quot;
  74 #include &quot;runtime/signature.hpp&quot;
  75 #include &quot;runtime/stubRoutines.hpp&quot;
  76 #include &quot;runtime/timer.hpp&quot;
  77 #include &quot;utilities/align.hpp&quot;
  78 #include &quot;utilities/copy.hpp&quot;
  79 #include &quot;utilities/macros.hpp&quot;
  80 
  81 
  82 // -------------------- Compile::mach_constant_base_node -----------------------
  83 // Constant table base node singleton.
  84 MachConstantBaseNode* Compile::mach_constant_base_node() {
  85   if (_mach_constant_base_node == NULL) {
  86     _mach_constant_base_node = new MachConstantBaseNode();
  87     _mach_constant_base_node-&gt;add_req(C-&gt;root());
  88   }
  89   return _mach_constant_base_node;
  90 }
  91 
  92 
  93 /// Support for intrinsics.
  94 
  95 // Return the index at which m must be inserted (or already exists).
  96 // The sort order is by the address of the ciMethod, with is_virtual as minor key.
  97 class IntrinsicDescPair {
  98  private:
  99   ciMethod* _m;
 100   bool _is_virtual;
 101  public:
 102   IntrinsicDescPair(ciMethod* m, bool is_virtual) : _m(m), _is_virtual(is_virtual) {}
 103   static int compare(IntrinsicDescPair* const&amp; key, CallGenerator* const&amp; elt) {
 104     ciMethod* m= elt-&gt;method();
 105     ciMethod* key_m = key-&gt;_m;
 106     if (key_m &lt; m)      return -1;
 107     else if (key_m &gt; m) return 1;
 108     else {
 109       bool is_virtual = elt-&gt;is_virtual();
 110       bool key_virtual = key-&gt;_is_virtual;
 111       if (key_virtual &lt; is_virtual)      return -1;
 112       else if (key_virtual &gt; is_virtual) return 1;
 113       else                               return 0;
 114     }
 115   }
 116 };
 117 int Compile::intrinsic_insertion_index(ciMethod* m, bool is_virtual, bool&amp; found) {
 118 #ifdef ASSERT
 119   for (int i = 1; i &lt; _intrinsics-&gt;length(); i++) {
 120     CallGenerator* cg1 = _intrinsics-&gt;at(i-1);
 121     CallGenerator* cg2 = _intrinsics-&gt;at(i);
 122     assert(cg1-&gt;method() != cg2-&gt;method()
 123            ? cg1-&gt;method()     &lt; cg2-&gt;method()
 124            : cg1-&gt;is_virtual() &lt; cg2-&gt;is_virtual(),
 125            &quot;compiler intrinsics list must stay sorted&quot;);
 126   }
 127 #endif
 128   IntrinsicDescPair pair(m, is_virtual);
 129   return _intrinsics-&gt;find_sorted&lt;IntrinsicDescPair*, IntrinsicDescPair::compare&gt;(&amp;pair, found);
 130 }
 131 
 132 void Compile::register_intrinsic(CallGenerator* cg) {
 133   if (_intrinsics == NULL) {
 134     _intrinsics = new (comp_arena())GrowableArray&lt;CallGenerator*&gt;(comp_arena(), 60, 0, NULL);
 135   }
 136   int len = _intrinsics-&gt;length();
 137   bool found = false;
 138   int index = intrinsic_insertion_index(cg-&gt;method(), cg-&gt;is_virtual(), found);
 139   assert(!found, &quot;registering twice&quot;);
 140   _intrinsics-&gt;insert_before(index, cg);
 141   assert(find_intrinsic(cg-&gt;method(), cg-&gt;is_virtual()) == cg, &quot;registration worked&quot;);
 142 }
 143 
 144 CallGenerator* Compile::find_intrinsic(ciMethod* m, bool is_virtual) {
 145   assert(m-&gt;is_loaded(), &quot;don&#39;t try this on unloaded methods&quot;);
 146   if (_intrinsics != NULL) {
 147     bool found = false;
 148     int index = intrinsic_insertion_index(m, is_virtual, found);
 149      if (found) {
 150       return _intrinsics-&gt;at(index);
 151     }
 152   }
 153   // Lazily create intrinsics for intrinsic IDs well-known in the runtime.
 154   if (m-&gt;intrinsic_id() != vmIntrinsics::_none &amp;&amp;
 155       m-&gt;intrinsic_id() &lt;= vmIntrinsics::LAST_COMPILER_INLINE) {
 156     CallGenerator* cg = make_vm_intrinsic(m, is_virtual);
 157     if (cg != NULL) {
 158       // Save it for next time:
 159       register_intrinsic(cg);
 160       return cg;
 161     } else {
 162       gather_intrinsic_statistics(m-&gt;intrinsic_id(), is_virtual, _intrinsic_disabled);
 163     }
 164   }
 165   return NULL;
 166 }
 167 
 168 // Compile:: register_library_intrinsics and make_vm_intrinsic are defined
 169 // in library_call.cpp.
 170 
 171 
 172 #ifndef PRODUCT
 173 // statistics gathering...
 174 
 175 juint  Compile::_intrinsic_hist_count[vmIntrinsics::ID_LIMIT] = {0};
 176 jubyte Compile::_intrinsic_hist_flags[vmIntrinsics::ID_LIMIT] = {0};
 177 
 178 bool Compile::gather_intrinsic_statistics(vmIntrinsics::ID id, bool is_virtual, int flags) {
 179   assert(id &gt; vmIntrinsics::_none &amp;&amp; id &lt; vmIntrinsics::ID_LIMIT, &quot;oob&quot;);
 180   int oflags = _intrinsic_hist_flags[id];
 181   assert(flags != 0, &quot;what happened?&quot;);
 182   if (is_virtual) {
 183     flags |= _intrinsic_virtual;
 184   }
 185   bool changed = (flags != oflags);
 186   if ((flags &amp; _intrinsic_worked) != 0) {
 187     juint count = (_intrinsic_hist_count[id] += 1);
 188     if (count == 1) {
 189       changed = true;           // first time
 190     }
 191     // increment the overall count also:
 192     _intrinsic_hist_count[vmIntrinsics::_none] += 1;
 193   }
 194   if (changed) {
 195     if (((oflags ^ flags) &amp; _intrinsic_virtual) != 0) {
 196       // Something changed about the intrinsic&#39;s virtuality.
 197       if ((flags &amp; _intrinsic_virtual) != 0) {
 198         // This is the first use of this intrinsic as a virtual call.
 199         if (oflags != 0) {
 200           // We already saw it as a non-virtual, so note both cases.
 201           flags |= _intrinsic_both;
 202         }
 203       } else if ((oflags &amp; _intrinsic_both) == 0) {
 204         // This is the first use of this intrinsic as a non-virtual
 205         flags |= _intrinsic_both;
 206       }
 207     }
 208     _intrinsic_hist_flags[id] = (jubyte) (oflags | flags);
 209   }
 210   // update the overall flags also:
 211   _intrinsic_hist_flags[vmIntrinsics::_none] |= (jubyte) flags;
 212   return changed;
 213 }
 214 
 215 static char* format_flags(int flags, char* buf) {
 216   buf[0] = 0;
 217   if ((flags &amp; Compile::_intrinsic_worked) != 0)    strcat(buf, &quot;,worked&quot;);
 218   if ((flags &amp; Compile::_intrinsic_failed) != 0)    strcat(buf, &quot;,failed&quot;);
 219   if ((flags &amp; Compile::_intrinsic_disabled) != 0)  strcat(buf, &quot;,disabled&quot;);
 220   if ((flags &amp; Compile::_intrinsic_virtual) != 0)   strcat(buf, &quot;,virtual&quot;);
 221   if ((flags &amp; Compile::_intrinsic_both) != 0)      strcat(buf, &quot;,nonvirtual&quot;);
 222   if (buf[0] == 0)  strcat(buf, &quot;,&quot;);
 223   assert(buf[0] == &#39;,&#39;, &quot;must be&quot;);
 224   return &amp;buf[1];
 225 }
 226 
 227 void Compile::print_intrinsic_statistics() {
 228   char flagsbuf[100];
 229   ttyLocker ttyl;
 230   if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;intrinsic&#39;&quot;);
 231   tty-&gt;print_cr(&quot;Compiler intrinsic usage:&quot;);
 232   juint total = _intrinsic_hist_count[vmIntrinsics::_none];
 233   if (total == 0)  total = 1;  // avoid div0 in case of no successes
 234   #define PRINT_STAT_LINE(name, c, f) \
 235     tty-&gt;print_cr(&quot;  %4d (%4.1f%%) %s (%s)&quot;, (int)(c), ((c) * 100.0) / total, name, f);
 236   for (int index = 1 + (int)vmIntrinsics::_none; index &lt; (int)vmIntrinsics::ID_LIMIT; index++) {
 237     vmIntrinsics::ID id = (vmIntrinsics::ID) index;
 238     int   flags = _intrinsic_hist_flags[id];
 239     juint count = _intrinsic_hist_count[id];
 240     if ((flags | count) != 0) {
 241       PRINT_STAT_LINE(vmIntrinsics::name_at(id), count, format_flags(flags, flagsbuf));
 242     }
 243   }
 244   PRINT_STAT_LINE(&quot;total&quot;, total, format_flags(_intrinsic_hist_flags[vmIntrinsics::_none], flagsbuf));
 245   if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
 246 }
 247 
 248 void Compile::print_statistics() {
 249   { ttyLocker ttyl;
 250     if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;opto&#39;&quot;);
 251     Parse::print_statistics();
 252     PhaseCCP::print_statistics();
 253     PhaseRegAlloc::print_statistics();
<a name="1" id="anc1"></a><span class="line-modified"> 254     PhaseOutput::print_statistics();</span>
 255     PhasePeephole::print_statistics();
 256     PhaseIdealLoop::print_statistics();
 257     if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
 258   }
 259   if (_intrinsic_hist_flags[vmIntrinsics::_none] != 0) {
 260     // put this under its own &lt;statistics&gt; element.
 261     print_intrinsic_statistics();
 262   }
 263 }
 264 #endif //PRODUCT
 265 
<a name="2" id="anc2"></a>










 266 void Compile::gvn_replace_by(Node* n, Node* nn) {
 267   for (DUIterator_Last imin, i = n-&gt;last_outs(imin); i &gt;= imin; ) {
 268     Node* use = n-&gt;last_out(i);
 269     bool is_in_table = initial_gvn()-&gt;hash_delete(use);
 270     uint uses_found = 0;
 271     for (uint j = 0; j &lt; use-&gt;len(); j++) {
 272       if (use-&gt;in(j) == n) {
 273         if (j &lt; use-&gt;req())
 274           use-&gt;set_req(j, nn);
 275         else
 276           use-&gt;set_prec(j, nn);
 277         uses_found++;
 278       }
 279     }
 280     if (is_in_table) {
 281       // reinsert into table
 282       initial_gvn()-&gt;hash_find_insert(use);
 283     }
 284     record_for_igvn(use);
 285     i -= uses_found;    // we deleted 1 or more copies of this edge
 286   }
 287 }
 288 
 289 
 290 static inline bool not_a_node(const Node* n) {
 291   if (n == NULL)                   return true;
 292   if (((intptr_t)n &amp; 1) != 0)      return true;  // uninitialized, etc.
 293   if (*(address*)n == badAddress)  return true;  // kill by Node::destruct
 294   return false;
 295 }
 296 
 297 // Identify all nodes that are reachable from below, useful.
 298 // Use breadth-first pass that records state in a Unique_Node_List,
 299 // recursive traversal is slower.
 300 void Compile::identify_useful_nodes(Unique_Node_List &amp;useful) {
 301   int estimated_worklist_size = live_nodes();
 302   useful.map( estimated_worklist_size, NULL );  // preallocate space
 303 
 304   // Initialize worklist
 305   if (root() != NULL)     { useful.push(root()); }
 306   // If &#39;top&#39; is cached, declare it useful to preserve cached node
 307   if( cached_top_node() ) { useful.push(cached_top_node()); }
 308 
 309   // Push all useful nodes onto the list, breadthfirst
 310   for( uint next = 0; next &lt; useful.size(); ++next ) {
 311     assert( next &lt; unique(), &quot;Unique useful nodes &lt; total nodes&quot;);
 312     Node *n  = useful.at(next);
 313     uint max = n-&gt;len();
 314     for( uint i = 0; i &lt; max; ++i ) {
 315       Node *m = n-&gt;in(i);
 316       if (not_a_node(m))  continue;
 317       useful.push(m);
 318     }
 319   }
 320 }
 321 
 322 // Update dead_node_list with any missing dead nodes using useful
 323 // list. Consider all non-useful nodes to be useless i.e., dead nodes.
 324 void Compile::update_dead_node_list(Unique_Node_List &amp;useful) {
 325   uint max_idx = unique();
 326   VectorSet&amp; useful_node_set = useful.member_set();
 327 
 328   for (uint node_idx = 0; node_idx &lt; max_idx; node_idx++) {
 329     // If node with index node_idx is not in useful set,
 330     // mark it as dead in dead node list.
 331     if (!useful_node_set.test(node_idx)) {
 332       record_dead_node(node_idx);
 333     }
 334   }
 335 }
 336 
 337 void Compile::remove_useless_late_inlines(GrowableArray&lt;CallGenerator*&gt;* inlines, Unique_Node_List &amp;useful) {
 338   int shift = 0;
 339   for (int i = 0; i &lt; inlines-&gt;length(); i++) {
 340     CallGenerator* cg = inlines-&gt;at(i);
 341     CallNode* call = cg-&gt;call_node();
 342     if (shift &gt; 0) {
 343       inlines-&gt;at_put(i-shift, cg);
 344     }
 345     if (!useful.member(call)) {
 346       shift++;
 347     }
 348   }
 349   inlines-&gt;trunc_to(inlines-&gt;length()-shift);
 350 }
 351 
 352 // Disconnect all useless nodes by disconnecting those at the boundary.
 353 void Compile::remove_useless_nodes(Unique_Node_List &amp;useful) {
 354   uint next = 0;
 355   while (next &lt; useful.size()) {
 356     Node *n = useful.at(next++);
 357     if (n-&gt;is_SafePoint()) {
 358       // We&#39;re done with a parsing phase. Replaced nodes are not valid
 359       // beyond that point.
 360       n-&gt;as_SafePoint()-&gt;delete_replaced_nodes();
 361     }
 362     // Use raw traversal of out edges since this code removes out edges
 363     int max = n-&gt;outcnt();
 364     for (int j = 0; j &lt; max; ++j) {
 365       Node* child = n-&gt;raw_out(j);
 366       if (! useful.member(child)) {
 367         assert(!child-&gt;is_top() || child != top(),
 368                &quot;If top is cached in Compile object it is in useful list&quot;);
 369         // Only need to remove this out-edge to the useless node
 370         n-&gt;raw_del_out(j);
 371         --j;
 372         --max;
 373       }
 374     }
 375     if (n-&gt;outcnt() == 1 &amp;&amp; n-&gt;has_special_unique_user()) {
 376       record_for_igvn(n-&gt;unique_out());
 377     }
 378   }
 379   // Remove useless macro and predicate opaq nodes
 380   for (int i = C-&gt;macro_count()-1; i &gt;= 0; i--) {
 381     Node* n = C-&gt;macro_node(i);
 382     if (!useful.member(n)) {
 383       remove_macro_node(n);
 384     }
 385   }
 386   // Remove useless CastII nodes with range check dependency
 387   for (int i = range_check_cast_count() - 1; i &gt;= 0; i--) {
 388     Node* cast = range_check_cast_node(i);
 389     if (!useful.member(cast)) {
 390       remove_range_check_cast(cast);
 391     }
 392   }
 393   // Remove useless expensive nodes
 394   for (int i = C-&gt;expensive_count()-1; i &gt;= 0; i--) {
 395     Node* n = C-&gt;expensive_node(i);
 396     if (!useful.member(n)) {
 397       remove_expensive_node(n);
 398     }
 399   }
 400   // Remove useless Opaque4 nodes
 401   for (int i = opaque4_count() - 1; i &gt;= 0; i--) {
 402     Node* opaq = opaque4_node(i);
 403     if (!useful.member(opaq)) {
 404       remove_opaque4_node(opaq);
 405     }
 406   }
 407   // Remove useless value type nodes
 408   if (_value_type_nodes != NULL) {
 409     _value_type_nodes-&gt;remove_useless_nodes(useful.member_set());
 410   }
 411   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 412   bs-&gt;eliminate_useless_gc_barriers(useful, this);
 413   // clean up the late inline lists
 414   remove_useless_late_inlines(&amp;_string_late_inlines, useful);
 415   remove_useless_late_inlines(&amp;_boxing_late_inlines, useful);
 416   remove_useless_late_inlines(&amp;_late_inlines, useful);
 417   debug_only(verify_graph_edges(true/*check for no_dead_code*/);)
 418 }
 419 
<a name="3" id="anc3"></a>

















 420 // ============================================================================
 421 //------------------------------CompileWrapper---------------------------------
 422 class CompileWrapper : public StackObj {
 423   Compile *const _compile;
 424  public:
 425   CompileWrapper(Compile* compile);
 426 
 427   ~CompileWrapper();
 428 };
 429 
 430 CompileWrapper::CompileWrapper(Compile* compile) : _compile(compile) {
 431   // the Compile* pointer is stored in the current ciEnv:
 432   ciEnv* env = compile-&gt;env();
 433   assert(env == ciEnv::current(), &quot;must already be a ciEnv active&quot;);
 434   assert(env-&gt;compiler_data() == NULL, &quot;compile already active?&quot;);
 435   env-&gt;set_compiler_data(compile);
 436   assert(compile == Compile::current(), &quot;sanity&quot;);
 437 
 438   compile-&gt;set_type_dict(NULL);
 439   compile-&gt;set_clone_map(new Dict(cmpkey, hashkey, _compile-&gt;comp_arena()));
 440   compile-&gt;clone_map().set_clone_idx(0);
 441   compile-&gt;set_type_last_size(0);
 442   compile-&gt;set_last_tf(NULL, NULL);
 443   compile-&gt;set_indexSet_arena(NULL);
 444   compile-&gt;set_indexSet_free_block_list(NULL);
 445   compile-&gt;init_type_arena();
 446   Type::Initialize(compile);
<a name="4" id="anc4"></a>
 447   _compile-&gt;begin_method();
 448   _compile-&gt;clone_map().set_debug(_compile-&gt;has_method() &amp;&amp; _compile-&gt;directive()-&gt;CloneMapDebugOption);
 449 }
 450 CompileWrapper::~CompileWrapper() {
 451   _compile-&gt;end_method();
<a name="5" id="anc5"></a>

 452   _compile-&gt;env()-&gt;set_compiler_data(NULL);
 453 }
 454 
 455 
 456 //----------------------------print_compile_messages---------------------------
 457 void Compile::print_compile_messages() {
 458 #ifndef PRODUCT
 459   // Check if recompiling
 460   if (_subsume_loads == false &amp;&amp; PrintOpto) {
 461     // Recompiling without allowing machine instructions to subsume loads
 462     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 463     tty-&gt;print_cr(&quot;** Bailout: Recompile without subsuming loads          **&quot;);
 464     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 465   }
 466   if (_do_escape_analysis != DoEscapeAnalysis &amp;&amp; PrintOpto) {
 467     // Recompiling without escape analysis
 468     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 469     tty-&gt;print_cr(&quot;** Bailout: Recompile without escape analysis          **&quot;);
 470     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 471   }
 472   if (_eliminate_boxing != EliminateAutoBox &amp;&amp; PrintOpto) {
 473     // Recompiling without boxing elimination
 474     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 475     tty-&gt;print_cr(&quot;** Bailout: Recompile without boxing elimination       **&quot;);
 476     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 477   }
 478   if (C-&gt;directive()-&gt;BreakAtCompileOption) {
 479     // Open the debugger when compiling this method.
 480     tty-&gt;print(&quot;### Breaking when compiling: &quot;);
 481     method()-&gt;print_short_name();
 482     tty-&gt;cr();
 483     BREAKPOINT;
 484   }
 485 
 486   if( PrintOpto ) {
 487     if (is_osr_compilation()) {
 488       tty-&gt;print(&quot;[OSR]%3d&quot;, _compile_id);
 489     } else {
 490       tty-&gt;print(&quot;%3d&quot;, _compile_id);
 491     }
 492   }
 493 #endif
 494 }
 495 
<a name="6" id="anc6"></a>




















































































































 496 // ============================================================================
 497 //------------------------------Compile standard-------------------------------
 498 debug_only( int Compile::_debug_idx = 100000; )
 499 
 500 // Compile a method.  entry_bci is -1 for normal compilations and indicates
 501 // the continuation bci for on stack replacement.
 502 
 503 
<a name="7" id="anc7"></a><span class="line-modified"> 504 Compile::Compile( ciEnv* ci_env, ciMethod* target, int osr_bci,</span>
 505                   bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing, DirectiveSet* directive)
 506                 : Phase(Compiler),
 507                   _compile_id(ci_env-&gt;compile_id()),
 508                   _save_argument_registers(false),
 509                   _subsume_loads(subsume_loads),
 510                   _do_escape_analysis(do_escape_analysis),
 511                   _eliminate_boxing(eliminate_boxing),
 512                   _method(target),
 513                   _entry_bci(osr_bci),
 514                   _stub_function(NULL),
 515                   _stub_name(NULL),
 516                   _stub_entry_point(NULL),
 517                   _max_node_limit(MaxNodeLimit),
<a name="8" id="anc8"></a>



 518                   _inlining_progress(false),
 519                   _inlining_incrementally(false),
 520                   _do_cleanup(false),
 521                   _has_reserved_stack_access(target-&gt;has_reserved_stack_access()),
 522 #ifndef PRODUCT
 523                   _trace_opto_output(directive-&gt;TraceOptoOutputOption),
 524                   _print_ideal(directive-&gt;PrintIdealOption),
 525 #endif
 526                   _has_method_handle_invokes(false),
 527                   _clinit_barrier_on_entry(false),
 528                   _comp_arena(mtCompiler),
 529                   _barrier_set_state(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;create_barrier_state(comp_arena())),
 530                   _env(ci_env),
 531                   _directive(directive),
 532                   _log(ci_env-&gt;log()),
 533                   _failure_reason(NULL),
 534                   _congraph(NULL),
 535 #ifndef PRODUCT
 536                   _printer(IdealGraphPrinter::printer()),
 537 #endif
 538                   _dead_node_list(comp_arena()),
 539                   _dead_node_count(0),
 540                   _node_arena(mtCompiler),
 541                   _old_arena(mtCompiler),
 542                   _mach_constant_base_node(NULL),
 543                   _Compile_types(mtCompiler),
 544                   _initial_gvn(NULL),
 545                   _for_igvn(NULL),
 546                   _warm_calls(NULL),
 547                   _late_inlines(comp_arena(), 2, 0, NULL),
 548                   _string_late_inlines(comp_arena(), 2, 0, NULL),
 549                   _boxing_late_inlines(comp_arena(), 2, 0, NULL),
 550                   _late_inlines_pos(0),
 551                   _number_of_mh_late_inlines(0),
 552                   _print_inlining_stream(NULL),
 553                   _print_inlining_list(NULL),
 554                   _print_inlining_idx(0),
 555                   _print_inlining_output(NULL),
 556                   _replay_inline_data(NULL),
 557                   _java_calls(0),
 558                   _inner_loops(0),
<a name="9" id="anc9"></a><span class="line-modified"> 559                   _interpreter_frame_size(0)</span>





 560 #ifndef PRODUCT
 561                   , _in_dump_cnt(0)
 562 #endif
 563 {
 564   C = this;
 565 #ifndef PRODUCT
 566   if (_printer != NULL) {
 567     _printer-&gt;set_compile(this);
 568   }
 569 #endif
 570   CompileWrapper cw(this);
 571 
 572   if (CITimeVerbose) {
 573     tty-&gt;print(&quot; &quot;);
 574     target-&gt;holder()-&gt;name()-&gt;print();
 575     tty-&gt;print(&quot;.&quot;);
 576     target-&gt;print_short_name();
 577     tty-&gt;print(&quot;  &quot;);
 578   }
 579   TraceTime t1(&quot;Total compilation time&quot;, &amp;_t_totalCompilation, CITime, CITimeVerbose);
 580   TraceTime t2(NULL, &amp;_t_methodCompilation, CITime, false);
 581 
 582 #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)
 583   bool print_opto_assembly = directive-&gt;PrintOptoAssemblyOption;
 584   // We can always print a disassembly, either abstract (hex dump) or
 585   // with the help of a suitable hsdis library. Thus, we should not
 586   // couple print_assembly and print_opto_assembly controls.
 587   // But: always print opto and regular assembly on compile command &#39;print&#39;.
 588   bool print_assembly = directive-&gt;PrintAssemblyOption;
 589   set_print_assembly(print_opto_assembly || print_assembly);
 590 #else
 591   set_print_assembly(false); // must initialize.
 592 #endif
 593 
 594 #ifndef PRODUCT
 595   set_parsed_irreducible_loop(false);
 596 
 597   if (directive-&gt;ReplayInlineOption) {
 598     _replay_inline_data = ciReplay::load_inline_data(method(), entry_bci(), ci_env-&gt;comp_level());
 599   }
 600 #endif
 601   set_print_inlining(directive-&gt;PrintInliningOption || PrintOptoInlining);
 602   set_print_intrinsics(directive-&gt;PrintIntrinsicsOption);
 603   set_has_irreducible_loop(true); // conservative until build_loop_tree() reset it
 604 
 605   if (ProfileTraps RTM_OPT_ONLY( || UseRTMLocking )) {
 606     // Make sure the method being compiled gets its own MDO,
 607     // so we can at least track the decompile_count().
 608     // Need MDO to record RTM code generation state.
 609     method()-&gt;ensure_method_data();
 610   }
 611 
 612   Init(::AliasLevel);
 613 
 614 
 615   print_compile_messages();
 616 
 617   _ilt = InlineTree::build_inline_tree_root();
 618 
 619   // Even if NO memory addresses are used, MergeMem nodes must have at least 1 slice
 620   assert(num_alias_types() &gt;= AliasIdxRaw, &quot;&quot;);
 621 
 622 #define MINIMUM_NODE_HASH  1023
 623   // Node list that Iterative GVN will start with
 624   Unique_Node_List for_igvn(comp_arena());
 625   set_for_igvn(&amp;for_igvn);
 626 
 627   // GVN that will be run immediately on new nodes
 628   uint estimated_size = method()-&gt;code_size()*4+64;
 629   estimated_size = (estimated_size &lt; MINIMUM_NODE_HASH ? MINIMUM_NODE_HASH : estimated_size);
 630   PhaseGVN gvn(node_arena(), estimated_size);
 631   set_initial_gvn(&amp;gvn);
 632 
 633   print_inlining_init();
 634   { // Scope for timing the parser
 635     TracePhase tp(&quot;parse&quot;, &amp;timers[_t_parser]);
 636 
 637     // Put top into the hash table ASAP.
 638     initial_gvn()-&gt;transform_no_reclaim(top());
 639 
 640     // Set up tf(), start(), and find a CallGenerator.
 641     CallGenerator* cg = NULL;
 642     if (is_osr_compilation()) {
 643       init_tf(TypeFunc::make(method(), /* is_osr_compilation = */ true));
 644       StartNode* s = new StartOSRNode(root(), tf()-&gt;domain_sig());
 645       initial_gvn()-&gt;set_type_bottom(s);
 646       init_start(s);
 647       cg = CallGenerator::for_osr(method(), entry_bci());
 648     } else {
 649       // Normal case.
 650       init_tf(TypeFunc::make(method()));
 651       StartNode* s = new StartNode(root(), tf()-&gt;domain_cc());
 652       initial_gvn()-&gt;set_type_bottom(s);
 653       init_start(s);
 654       if (method()-&gt;intrinsic_id() == vmIntrinsics::_Reference_get) {
 655         // With java.lang.ref.reference.get() we must go through the
 656         // intrinsic - even when get() is the root
 657         // method of the compile - so that, if necessary, the value in
 658         // the referent field of the reference object gets recorded by
 659         // the pre-barrier code.
 660         cg = find_intrinsic(method(), false);
 661       }
 662       if (cg == NULL) {
 663         float past_uses = method()-&gt;interpreter_invocation_count();
 664         float expected_uses = past_uses;
 665         cg = CallGenerator::for_inline(method(), expected_uses);
 666       }
 667     }
 668     if (failing())  return;
 669     if (cg == NULL) {
 670       record_method_not_compilable(&quot;cannot parse method&quot;);
 671       return;
 672     }
 673     JVMState* jvms = build_start_state(start(), tf());
 674     if ((jvms = cg-&gt;generate(jvms)) == NULL) {
 675       if (!failure_reason_is(C2Compiler::retry_class_loading_during_parsing())) {
 676         record_method_not_compilable(&quot;method parse failed&quot;);
 677       }
 678       return;
 679     }
 680     GraphKit kit(jvms);
 681 
 682     if (!kit.stopped()) {
 683       // Accept return values, and transfer control we know not where.
 684       // This is done by a special, unique ReturnNode bound to root.
 685       return_values(kit.jvms());
 686     }
 687 
 688     if (kit.has_exceptions()) {
 689       // Any exceptions that escape from this call must be rethrown
 690       // to whatever caller is dynamically above us on the stack.
 691       // This is done by a special, unique RethrowNode bound to root.
 692       rethrow_exceptions(kit.transfer_exceptions_into_jvms());
 693     }
 694 
 695     assert(IncrementalInline || (_late_inlines.length() == 0 &amp;&amp; !has_mh_late_inlines()), &quot;incremental inlining is off&quot;);
 696 
 697     if (_late_inlines.length() == 0 &amp;&amp; !has_mh_late_inlines() &amp;&amp; !failing() &amp;&amp; has_stringbuilder()) {
 698       inline_string_calls(true);
 699     }
 700 
 701     if (failing())  return;
 702 
 703     print_method(PHASE_BEFORE_REMOVEUSELESS, 3);
 704 
 705     // Remove clutter produced by parsing.
 706     if (!failing()) {
 707       ResourceMark rm;
 708       PhaseRemoveUseless pru(initial_gvn(), &amp;for_igvn);
 709     }
 710   }
 711 
 712   // Note:  Large methods are capped off in do_one_bytecode().
 713   if (failing())  return;
 714 
 715   // After parsing, node notes are no longer automagic.
 716   // They must be propagated by register_new_node_with_optimizer(),
 717   // clone(), or the like.
 718   set_default_node_notes(NULL);
 719 
 720   for (;;) {
 721     int successes = Inline_Warm();
 722     if (failing())  return;
 723     if (successes == 0)  break;
 724   }
 725 
 726   // Drain the list.
 727   Finish_Warm();
 728 #ifndef PRODUCT
 729   if (_printer &amp;&amp; _printer-&gt;should_print(1)) {
 730     _printer-&gt;print_inlining();
 731   }
 732 #endif
 733 
 734   if (failing())  return;
 735   NOT_PRODUCT( verify_graph_edges(); )
 736 
 737   // Now optimize
 738   Optimize();
 739   if (failing())  return;
 740   NOT_PRODUCT( verify_graph_edges(); )
 741 
 742 #ifndef PRODUCT
 743   if (print_ideal()) {
 744     ttyLocker ttyl;  // keep the following output all in one block
 745     // This output goes directly to the tty, not the compiler log.
 746     // To enable tools to match it up with the compilation activity,
 747     // be sure to tag this tty output with the compile ID.
 748     if (xtty != NULL) {
 749       xtty-&gt;head(&quot;ideal compile_id=&#39;%d&#39;%s&quot;, compile_id(),
 750                  is_osr_compilation()    ? &quot; compile_kind=&#39;osr&#39;&quot; :
 751                  &quot;&quot;);
 752     }
 753     root()-&gt;dump(9999);
 754     if (xtty != NULL) {
 755       xtty-&gt;tail(&quot;ideal&quot;);
 756     }
 757   }
 758 #endif
 759 
 760 #ifdef ASSERT
 761   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 762   bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeCodeGen);
 763 #endif
 764 
 765   // Dump compilation data to replay it.
 766   if (directive-&gt;DumpReplayOption) {
 767     env()-&gt;dump_replay_data(_compile_id);
 768   }
 769   if (directive-&gt;DumpInlineOption &amp;&amp; (ilt() != NULL)) {
 770     env()-&gt;dump_inline_data(_compile_id);
 771   }
 772 
 773   // Now that we know the size of all the monitors we can add a fixed slot
 774   // for the original deopt pc.
<a name="10" id="anc10"></a><span class="line-modified"> 775   int next_slot = fixed_slots() + (sizeof(address) / VMRegImpl::stack_slot_size);</span>



 776   if (needs_stack_repair()) {
 777     // One extra slot for the special stack increment value
<a name="11" id="anc11"></a>
 778     next_slot += 2;
 779   }
<a name="12" id="anc12"></a>
 780   set_fixed_slots(next_slot);
 781 
 782   // Compute when to use implicit null checks. Used by matching trap based
 783   // nodes and NullCheck optimization.
 784   set_allowed_deopt_reasons();
 785 
 786   // Now generate code
 787   Code_Gen();
<a name="13" id="anc13"></a>











































 788 }
 789 
 790 //------------------------------Compile----------------------------------------
 791 // Compile a runtime stub
 792 Compile::Compile( ciEnv* ci_env,
 793                   TypeFunc_generator generator,
 794                   address stub_function,
 795                   const char *stub_name,
 796                   int is_fancy_jump,
 797                   bool pass_tls,
 798                   bool save_arg_registers,
 799                   bool return_pc,
 800                   DirectiveSet* directive)
 801   : Phase(Compiler),
 802     _compile_id(0),
 803     _save_argument_registers(save_arg_registers),
 804     _subsume_loads(true),
 805     _do_escape_analysis(false),
 806     _eliminate_boxing(false),
 807     _method(NULL),
 808     _entry_bci(InvocationEntryBci),
 809     _stub_function(stub_function),
 810     _stub_name(stub_name),
 811     _stub_entry_point(NULL),
 812     _max_node_limit(MaxNodeLimit),
<a name="14" id="anc14"></a>



 813     _inlining_progress(false),
 814     _inlining_incrementally(false),
 815     _has_reserved_stack_access(false),
 816 #ifndef PRODUCT
 817     _trace_opto_output(directive-&gt;TraceOptoOutputOption),
 818     _print_ideal(directive-&gt;PrintIdealOption),
 819 #endif
 820     _has_method_handle_invokes(false),
 821     _clinit_barrier_on_entry(false),
 822     _comp_arena(mtCompiler),
 823     _barrier_set_state(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;create_barrier_state(comp_arena())),
 824     _env(ci_env),
 825     _directive(directive),
 826     _log(ci_env-&gt;log()),
 827     _failure_reason(NULL),
 828     _congraph(NULL),
 829 #ifndef PRODUCT
 830     _printer(NULL),
 831 #endif
 832     _dead_node_list(comp_arena()),
 833     _dead_node_count(0),
 834     _node_arena(mtCompiler),
 835     _old_arena(mtCompiler),
 836     _mach_constant_base_node(NULL),
 837     _Compile_types(mtCompiler),
 838     _initial_gvn(NULL),
 839     _for_igvn(NULL),
 840     _warm_calls(NULL),
 841     _number_of_mh_late_inlines(0),
 842     _print_inlining_stream(NULL),
 843     _print_inlining_list(NULL),
 844     _print_inlining_idx(0),
 845     _print_inlining_output(NULL),
 846     _replay_inline_data(NULL),
 847     _java_calls(0),
 848     _inner_loops(0),
 849     _interpreter_frame_size(0),
<a name="15" id="anc15"></a>


 850 #ifndef PRODUCT
 851     _in_dump_cnt(0),
 852 #endif
 853     _allowed_reasons(0) {
 854   C = this;
 855 
 856   TraceTime t1(NULL, &amp;_t_totalCompilation, CITime, false);
 857   TraceTime t2(NULL, &amp;_t_stubCompilation, CITime, false);
 858 
 859 #ifndef PRODUCT
 860   set_print_assembly(PrintFrameConverterAssembly);
 861   set_parsed_irreducible_loop(false);
 862 #else
 863   set_print_assembly(false); // Must initialize.
 864 #endif
 865   set_has_irreducible_loop(false); // no loops
 866 
 867   CompileWrapper cw(this);
 868   Init(/*AliasLevel=*/ 0);
 869   init_tf((*generator)());
 870 
 871   {
 872     // The following is a dummy for the sake of GraphKit::gen_stub
 873     Unique_Node_List for_igvn(comp_arena());
 874     set_for_igvn(&amp;for_igvn);  // not used, but some GraphKit guys push on this
 875     PhaseGVN gvn(Thread::current()-&gt;resource_area(),255);
 876     set_initial_gvn(&amp;gvn);    // not significant, but GraphKit guys use it pervasively
 877     gvn.transform_no_reclaim(top());
 878 
 879     GraphKit kit;
 880     kit.gen_stub(stub_function, stub_name, is_fancy_jump, pass_tls, return_pc);
 881   }
 882 
 883   NOT_PRODUCT( verify_graph_edges(); )
<a name="16" id="anc16"></a>












 884 
<a name="17" id="anc17"></a><span class="line-modified"> 885   Code_Gen();</span>













 886 }
 887 
 888 //------------------------------Init-------------------------------------------
 889 // Prepare for a single compilation
 890 void Compile::Init(int aliaslevel) {
 891   _unique  = 0;
 892   _regalloc = NULL;
 893 
 894   _tf      = NULL;  // filled in later
 895   _top     = NULL;  // cached later
 896   _matcher = NULL;  // filled in later
 897   _cfg     = NULL;  // filled in later
 898 
 899   IA32_ONLY( set_24_bit_selection_and_mode(true, false); )
 900 
 901   _node_note_array = NULL;
 902   _default_node_notes = NULL;
 903   DEBUG_ONLY( _modified_nodes = NULL; ) // Used in Optimize()
 904 
 905   _immutable_memory = NULL; // filled in at first inquiry
 906 
 907   // Globally visible Nodes
 908   // First set TOP to NULL to give safe behavior during creation of RootNode
 909   set_cached_top_node(NULL);
 910   set_root(new RootNode());
 911   // Now that you have a Root to point to, create the real TOP
 912   set_cached_top_node( new ConNode(Type::TOP) );
 913   set_recent_alloc(NULL, NULL);
 914 
 915   // Create Debug Information Recorder to record scopes, oopmaps, etc.
 916   env()-&gt;set_oop_recorder(new OopRecorder(env()-&gt;arena()));
 917   env()-&gt;set_debug_info(new DebugInformationRecorder(env()-&gt;oop_recorder()));
 918   env()-&gt;set_dependencies(new Dependencies(env()));
 919 
 920   _fixed_slots = 0;
 921   set_has_split_ifs(false);
 922   set_has_loops(has_method() &amp;&amp; method()-&gt;has_loops()); // first approximation
 923   set_has_stringbuilder(false);
 924   set_has_boxed_value(false);
 925   _trap_can_recompile = false;  // no traps emitted yet
 926   _major_progress = true; // start out assuming good things will happen
 927   set_has_unsafe_access(false);
 928   set_max_vector_size(0);
 929   set_clear_upper_avx(false);  //false as default for clear upper bits of ymm registers
 930   Copy::zero_to_bytes(_trap_hist, sizeof(_trap_hist));
 931   set_decompile_count(0);
 932 
 933   set_do_freq_based_layout(_directive-&gt;BlockLayoutByFrequencyOption);
 934   _loop_opts_cnt = LoopOptsCount;
 935   _has_flattened_accesses = false;
 936   _flattened_accesses_share_alias = true;
 937 
 938   set_do_inlining(Inline);
 939   set_max_inline_size(MaxInlineSize);
 940   set_freq_inline_size(FreqInlineSize);
 941   set_do_scheduling(OptoScheduling);
 942   set_do_count_invocations(false);
 943   set_do_method_data_update(false);
 944 
 945   set_do_vector_loop(false);
 946 
 947   if (AllowVectorizeOnDemand) {
 948     if (has_method() &amp;&amp; (_directive-&gt;VectorizeOption || _directive-&gt;VectorizeDebugOption)) {
 949       set_do_vector_loop(true);
 950       NOT_PRODUCT(if (do_vector_loop() &amp;&amp; Verbose) {tty-&gt;print(&quot;Compile::Init: do vectorized loops (SIMD like) for method %s\n&quot;,  method()-&gt;name()-&gt;as_quoted_ascii());})
 951     } else if (has_method() &amp;&amp; method()-&gt;name() != 0 &amp;&amp;
 952                method()-&gt;intrinsic_id() == vmIntrinsics::_forEachRemaining) {
 953       set_do_vector_loop(true);
 954     }
 955   }
 956   set_use_cmove(UseCMoveUnconditionally /* || do_vector_loop()*/); //TODO: consider do_vector_loop() mandate use_cmove unconditionally
 957   NOT_PRODUCT(if (use_cmove() &amp;&amp; Verbose &amp;&amp; has_method()) {tty-&gt;print(&quot;Compile::Init: use CMove without profitability tests for method %s\n&quot;,  method()-&gt;name()-&gt;as_quoted_ascii());})
 958 
 959   set_age_code(has_method() &amp;&amp; method()-&gt;profile_aging());
 960   set_rtm_state(NoRTM); // No RTM lock eliding by default
 961   _max_node_limit = _directive-&gt;MaxNodeLimitOption;
 962 
 963 #if INCLUDE_RTM_OPT
 964   if (UseRTMLocking &amp;&amp; has_method() &amp;&amp; (method()-&gt;method_data_or_null() != NULL)) {
 965     int rtm_state = method()-&gt;method_data()-&gt;rtm_state();
 966     if (method_has_option(&quot;NoRTMLockEliding&quot;) || ((rtm_state &amp; NoRTM) != 0)) {
 967       // Don&#39;t generate RTM lock eliding code.
 968       set_rtm_state(NoRTM);
 969     } else if (method_has_option(&quot;UseRTMLockEliding&quot;) || ((rtm_state &amp; UseRTM) != 0) || !UseRTMDeopt) {
 970       // Generate RTM lock eliding code without abort ratio calculation code.
 971       set_rtm_state(UseRTM);
 972     } else if (UseRTMDeopt) {
 973       // Generate RTM lock eliding code and include abort ratio calculation
 974       // code if UseRTMDeopt is on.
 975       set_rtm_state(ProfileRTM);
 976     }
 977   }
 978 #endif
 979   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; has_method() &amp;&amp; !is_osr_compilation() &amp;&amp; method()-&gt;needs_clinit_barrier()) {
 980     set_clinit_barrier_on_entry(true);
 981   }
 982   if (debug_info()-&gt;recording_non_safepoints()) {
 983     set_node_note_array(new(comp_arena()) GrowableArray&lt;Node_Notes*&gt;
 984                         (comp_arena(), 8, 0, NULL));
 985     set_default_node_notes(Node_Notes::make(this));
 986   }
 987 
 988   // // -- Initialize types before each compile --
 989   // // Update cached type information
 990   // if( _method &amp;&amp; _method-&gt;constants() )
 991   //   Type::update_loaded_types(_method, _method-&gt;constants());
 992 
 993   // Init alias_type map.
 994   if (!_do_escape_analysis &amp;&amp; aliaslevel == 3)
 995     aliaslevel = 2;  // No unique types without escape analysis
 996   _AliasLevel = aliaslevel;
 997   const int grow_ats = 16;
 998   _max_alias_types = grow_ats;
 999   _alias_types   = NEW_ARENA_ARRAY(comp_arena(), AliasType*, grow_ats);
1000   AliasType* ats = NEW_ARENA_ARRAY(comp_arena(), AliasType,  grow_ats);
1001   Copy::zero_to_bytes(ats, sizeof(AliasType)*grow_ats);
1002   {
1003     for (int i = 0; i &lt; grow_ats; i++)  _alias_types[i] = &amp;ats[i];
1004   }
1005   // Initialize the first few types.
1006   _alias_types[AliasIdxTop]-&gt;Init(AliasIdxTop, NULL);
1007   _alias_types[AliasIdxBot]-&gt;Init(AliasIdxBot, TypePtr::BOTTOM);
1008   _alias_types[AliasIdxRaw]-&gt;Init(AliasIdxRaw, TypeRawPtr::BOTTOM);
1009   _num_alias_types = AliasIdxRaw+1;
1010   // Zero out the alias type cache.
1011   Copy::zero_to_bytes(_alias_cache, sizeof(_alias_cache));
1012   // A NULL adr_type hits in the cache right away.  Preload the right answer.
1013   probe_alias_cache(NULL)-&gt;_index = AliasIdxTop;
1014 
1015   _intrinsics = NULL;
1016   _macro_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1017   _predicate_opaqs = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1018   _expensive_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1019   _range_check_casts = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1020   _opaque4_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1021   _value_type_nodes = new (comp_arena()) Unique_Node_List(comp_arena());
1022   register_library_intrinsics();
<a name="18" id="anc18"></a><span class="line-added">1023 #ifdef ASSERT</span>
<span class="line-added">1024   _type_verify_symmetry = true;</span>
<span class="line-added">1025 #endif</span>
1026 }
1027 
1028 //---------------------------init_start----------------------------------------
1029 // Install the StartNode on this compile object.
1030 void Compile::init_start(StartNode* s) {
1031   if (failing())
1032     return; // already failing
1033   assert(s == start(), &quot;&quot;);
1034 }
1035 
1036 /**
1037  * Return the &#39;StartNode&#39;. We must not have a pending failure, since the ideal graph
1038  * can be in an inconsistent state, i.e., we can get segmentation faults when traversing
1039  * the ideal graph.
1040  */
1041 StartNode* Compile::start() const {
1042   assert (!failing(), &quot;Must not have pending failure. Reason is: %s&quot;, failure_reason());
1043   for (DUIterator_Fast imax, i = root()-&gt;fast_outs(imax); i &lt; imax; i++) {
1044     Node* start = root()-&gt;fast_out(i);
1045     if (start-&gt;is_Start()) {
1046       return start-&gt;as_Start();
1047     }
1048   }
1049   fatal(&quot;Did not find Start node!&quot;);
1050   return NULL;
1051 }
1052 
1053 //-------------------------------immutable_memory-------------------------------------
1054 // Access immutable memory
1055 Node* Compile::immutable_memory() {
1056   if (_immutable_memory != NULL) {
1057     return _immutable_memory;
1058   }
1059   StartNode* s = start();
1060   for (DUIterator_Fast imax, i = s-&gt;fast_outs(imax); true; i++) {
1061     Node *p = s-&gt;fast_out(i);
1062     if (p != s &amp;&amp; p-&gt;as_Proj()-&gt;_con == TypeFunc::Memory) {
1063       _immutable_memory = p;
1064       return _immutable_memory;
1065     }
1066   }
1067   ShouldNotReachHere();
1068   return NULL;
1069 }
1070 
1071 //----------------------set_cached_top_node------------------------------------
1072 // Install the cached top node, and make sure Node::is_top works correctly.
1073 void Compile::set_cached_top_node(Node* tn) {
1074   if (tn != NULL)  verify_top(tn);
1075   Node* old_top = _top;
1076   _top = tn;
1077   // Calling Node::setup_is_top allows the nodes the chance to adjust
1078   // their _out arrays.
1079   if (_top != NULL)     _top-&gt;setup_is_top();
1080   if (old_top != NULL)  old_top-&gt;setup_is_top();
1081   assert(_top == NULL || top()-&gt;is_top(), &quot;&quot;);
1082 }
1083 
1084 #ifdef ASSERT
1085 uint Compile::count_live_nodes_by_graph_walk() {
1086   Unique_Node_List useful(comp_arena());
1087   // Get useful node list by walking the graph.
1088   identify_useful_nodes(useful);
1089   return useful.size();
1090 }
1091 
1092 void Compile::print_missing_nodes() {
1093 
1094   // Return if CompileLog is NULL and PrintIdealNodeCount is false.
1095   if ((_log == NULL) &amp;&amp; (! PrintIdealNodeCount)) {
1096     return;
1097   }
1098 
1099   // This is an expensive function. It is executed only when the user
1100   // specifies VerifyIdealNodeCount option or otherwise knows the
1101   // additional work that needs to be done to identify reachable nodes
1102   // by walking the flow graph and find the missing ones using
1103   // _dead_node_list.
1104 
1105   Unique_Node_List useful(comp_arena());
1106   // Get useful node list by walking the graph.
1107   identify_useful_nodes(useful);
1108 
1109   uint l_nodes = C-&gt;live_nodes();
1110   uint l_nodes_by_walk = useful.size();
1111 
1112   if (l_nodes != l_nodes_by_walk) {
1113     if (_log != NULL) {
1114       _log-&gt;begin_head(&quot;mismatched_nodes count=&#39;%d&#39;&quot;, abs((int) (l_nodes - l_nodes_by_walk)));
1115       _log-&gt;stamp();
1116       _log-&gt;end_head();
1117     }
1118     VectorSet&amp; useful_member_set = useful.member_set();
1119     int last_idx = l_nodes_by_walk;
1120     for (int i = 0; i &lt; last_idx; i++) {
1121       if (useful_member_set.test(i)) {
1122         if (_dead_node_list.test(i)) {
1123           if (_log != NULL) {
1124             _log-&gt;elem(&quot;mismatched_node_info node_idx=&#39;%d&#39; type=&#39;both live and dead&#39;&quot;, i);
1125           }
1126           if (PrintIdealNodeCount) {
1127             // Print the log message to tty
1128               tty-&gt;print_cr(&quot;mismatched_node idx=&#39;%d&#39; both live and dead&#39;&quot;, i);
1129               useful.at(i)-&gt;dump();
1130           }
1131         }
1132       }
1133       else if (! _dead_node_list.test(i)) {
1134         if (_log != NULL) {
1135           _log-&gt;elem(&quot;mismatched_node_info node_idx=&#39;%d&#39; type=&#39;neither live nor dead&#39;&quot;, i);
1136         }
1137         if (PrintIdealNodeCount) {
1138           // Print the log message to tty
1139           tty-&gt;print_cr(&quot;mismatched_node idx=&#39;%d&#39; type=&#39;neither live nor dead&#39;&quot;, i);
1140         }
1141       }
1142     }
1143     if (_log != NULL) {
1144       _log-&gt;tail(&quot;mismatched_nodes&quot;);
1145     }
1146   }
1147 }
1148 void Compile::record_modified_node(Node* n) {
1149   if (_modified_nodes != NULL &amp;&amp; !_inlining_incrementally &amp;&amp;
1150       n-&gt;outcnt() != 0 &amp;&amp; !n-&gt;is_Con()) {
1151     _modified_nodes-&gt;push(n);
1152   }
1153 }
1154 
1155 void Compile::remove_modified_node(Node* n) {
1156   if (_modified_nodes != NULL) {
1157     _modified_nodes-&gt;remove(n);
1158   }
1159 }
1160 #endif
1161 
1162 #ifndef PRODUCT
1163 void Compile::verify_top(Node* tn) const {
1164   if (tn != NULL) {
1165     assert(tn-&gt;is_Con(), &quot;top node must be a constant&quot;);
1166     assert(((ConNode*)tn)-&gt;type() == Type::TOP, &quot;top node must have correct type&quot;);
1167     assert(tn-&gt;in(0) != NULL, &quot;must have live top node&quot;);
1168   }
1169 }
1170 #endif
1171 
1172 
1173 ///-------------------Managing Per-Node Debug &amp; Profile Info-------------------
1174 
1175 void Compile::grow_node_notes(GrowableArray&lt;Node_Notes*&gt;* arr, int grow_by) {
1176   guarantee(arr != NULL, &quot;&quot;);
1177   int num_blocks = arr-&gt;length();
1178   if (grow_by &lt; num_blocks)  grow_by = num_blocks;
1179   int num_notes = grow_by * _node_notes_block_size;
1180   Node_Notes* notes = NEW_ARENA_ARRAY(node_arena(), Node_Notes, num_notes);
1181   Copy::zero_to_bytes(notes, num_notes * sizeof(Node_Notes));
1182   while (num_notes &gt; 0) {
1183     arr-&gt;append(notes);
1184     notes     += _node_notes_block_size;
1185     num_notes -= _node_notes_block_size;
1186   }
1187   assert(num_notes == 0, &quot;exact multiple, please&quot;);
1188 }
1189 
1190 bool Compile::copy_node_notes_to(Node* dest, Node* source) {
1191   if (source == NULL || dest == NULL)  return false;
1192 
1193   if (dest-&gt;is_Con())
1194     return false;               // Do not push debug info onto constants.
1195 
1196 #ifdef ASSERT
1197   // Leave a bread crumb trail pointing to the original node:
1198   if (dest != NULL &amp;&amp; dest != source &amp;&amp; dest-&gt;debug_orig() == NULL) {
1199     dest-&gt;set_debug_orig(source);
1200   }
1201 #endif
1202 
1203   if (node_note_array() == NULL)
1204     return false;               // Not collecting any notes now.
1205 
1206   // This is a copy onto a pre-existing node, which may already have notes.
1207   // If both nodes have notes, do not overwrite any pre-existing notes.
1208   Node_Notes* source_notes = node_notes_at(source-&gt;_idx);
1209   if (source_notes == NULL || source_notes-&gt;is_clear())  return false;
1210   Node_Notes* dest_notes   = node_notes_at(dest-&gt;_idx);
1211   if (dest_notes == NULL || dest_notes-&gt;is_clear()) {
1212     return set_node_notes_at(dest-&gt;_idx, source_notes);
1213   }
1214 
1215   Node_Notes merged_notes = (*source_notes);
1216   // The order of operations here ensures that dest notes will win...
1217   merged_notes.update_from(dest_notes);
1218   return set_node_notes_at(dest-&gt;_idx, &amp;merged_notes);
1219 }
1220 
1221 
1222 //--------------------------allow_range_check_smearing-------------------------
1223 // Gating condition for coalescing similar range checks.
1224 // Sometimes we try &#39;speculatively&#39; replacing a series of a range checks by a
1225 // single covering check that is at least as strong as any of them.
1226 // If the optimization succeeds, the simplified (strengthened) range check
1227 // will always succeed.  If it fails, we will deopt, and then give up
1228 // on the optimization.
1229 bool Compile::allow_range_check_smearing() const {
1230   // If this method has already thrown a range-check,
1231   // assume it was because we already tried range smearing
1232   // and it failed.
1233   uint already_trapped = trap_count(Deoptimization::Reason_range_check);
1234   return !already_trapped;
1235 }
1236 
1237 
1238 //------------------------------flatten_alias_type-----------------------------
1239 const TypePtr *Compile::flatten_alias_type( const TypePtr *tj ) const {
1240   int offset = tj-&gt;offset();
1241   TypePtr::PTR ptr = tj-&gt;ptr();
1242 
1243   // Known instance (scalarizable allocation) alias only with itself.
1244   bool is_known_inst = tj-&gt;isa_oopptr() != NULL &amp;&amp;
1245                        tj-&gt;is_oopptr()-&gt;is_known_instance();
1246 
1247   // Process weird unsafe references.
1248   if (offset == Type::OffsetBot &amp;&amp; (tj-&gt;isa_instptr() /*|| tj-&gt;isa_klassptr()*/)) {
1249     bool default_value_load = EnableValhalla &amp;&amp; tj-&gt;is_instptr()-&gt;klass() == ciEnv::current()-&gt;Class_klass();
1250     assert(InlineUnsafeOps || default_value_load, &quot;indeterminate pointers come only from unsafe ops&quot;);
1251     assert(!is_known_inst, &quot;scalarizable allocation should not have unsafe references&quot;);
1252     tj = TypeOopPtr::BOTTOM;
1253     ptr = tj-&gt;ptr();
1254     offset = tj-&gt;offset();
1255   }
1256 
1257   // Array pointers need some flattening
1258   const TypeAryPtr *ta = tj-&gt;isa_aryptr();
1259   if (ta &amp;&amp; ta-&gt;is_stable()) {
1260     // Erase stability property for alias analysis.
1261     tj = ta = ta-&gt;cast_to_stable(false);
1262   }
1263   if (ta &amp;&amp; ta-&gt;is_not_flat()) {
1264     // Erase not flat property for alias analysis.
1265     tj = ta = ta-&gt;cast_to_not_flat(false);
1266   }
1267   if (ta &amp;&amp; ta-&gt;is_not_null_free()) {
1268     // Erase not null free property for alias analysis.
1269     tj = ta = ta-&gt;cast_to_not_null_free(false);
1270   }
1271 
1272   if( ta &amp;&amp; is_known_inst ) {
1273     if ( offset != Type::OffsetBot &amp;&amp;
1274          offset &gt; arrayOopDesc::length_offset_in_bytes() ) {
1275       offset = Type::OffsetBot; // Flatten constant access into array body only
1276       tj = ta = TypeAryPtr::make(ptr, ta-&gt;ary(), ta-&gt;klass(), true, Type::Offset(offset), ta-&gt;field_offset(), ta-&gt;instance_id());
1277     }
1278   } else if( ta &amp;&amp; _AliasLevel &gt;= 2 ) {
1279     // For arrays indexed by constant indices, we flatten the alias
1280     // space to include all of the array body.  Only the header, klass
1281     // and array length can be accessed un-aliased.
1282     // For flattened value type array, each field has its own slice so
1283     // we must include the field offset.
1284     if( offset != Type::OffsetBot ) {
1285       if( ta-&gt;const_oop() ) { // MethodData* or Method*
1286         offset = Type::OffsetBot;   // Flatten constant access into array body
1287         tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),ta-&gt;ary(),ta-&gt;klass(),false,Type::Offset(offset), ta-&gt;field_offset());
1288       } else if( offset == arrayOopDesc::length_offset_in_bytes() ) {
1289         // range is OK as-is.
1290         tj = ta = TypeAryPtr::RANGE;
1291       } else if( offset == oopDesc::klass_offset_in_bytes() ) {
1292         tj = TypeInstPtr::KLASS; // all klass loads look alike
1293         ta = TypeAryPtr::RANGE; // generic ignored junk
1294         ptr = TypePtr::BotPTR;
1295       } else if( offset == oopDesc::mark_offset_in_bytes() ) {
1296         tj = TypeInstPtr::MARK;
1297         ta = TypeAryPtr::RANGE; // generic ignored junk
1298         ptr = TypePtr::BotPTR;
1299       } else {                  // Random constant offset into array body
1300         offset = Type::OffsetBot;   // Flatten constant access into array body
1301         tj = ta = TypeAryPtr::make(ptr,ta-&gt;ary(),ta-&gt;klass(),false,Type::Offset(offset), ta-&gt;field_offset());
1302       }
1303     }
1304     // Arrays of fixed size alias with arrays of unknown size.
1305     if (ta-&gt;size() != TypeInt::POS) {
1306       const TypeAry *tary = TypeAry::make(ta-&gt;elem(), TypeInt::POS);
1307       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,ta-&gt;klass(),false,Type::Offset(offset), ta-&gt;field_offset());
1308     }
1309     // Arrays of known objects become arrays of unknown objects.
1310     if (ta-&gt;elem()-&gt;isa_narrowoop() &amp;&amp; ta-&gt;elem() != TypeNarrowOop::BOTTOM) {
1311       const TypeAry *tary = TypeAry::make(TypeNarrowOop::BOTTOM, ta-&gt;size());
1312       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,NULL,false,Type::Offset(offset), ta-&gt;field_offset());
1313     }
1314     if (ta-&gt;elem()-&gt;isa_oopptr() &amp;&amp; ta-&gt;elem() != TypeInstPtr::BOTTOM) {
1315       const TypeAry *tary = TypeAry::make(TypeInstPtr::BOTTOM, ta-&gt;size());
1316       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,NULL,false,Type::Offset(offset), ta-&gt;field_offset());
1317     }
1318     // Initially all flattened array accesses share a single slice
1319     if (ta-&gt;elem()-&gt;isa_valuetype() &amp;&amp; ta-&gt;elem() != TypeValueType::BOTTOM &amp;&amp; _flattened_accesses_share_alias) {
1320       const TypeAry *tary = TypeAry::make(TypeValueType::BOTTOM, ta-&gt;size());
1321       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,NULL,false,Type::Offset(offset), Type::Offset(Type::OffsetBot));
1322     }
1323     // Arrays of bytes and of booleans both use &#39;bastore&#39; and &#39;baload&#39; so
1324     // cannot be distinguished by bytecode alone.
1325     if (ta-&gt;elem() == TypeInt::BOOL) {
1326       const TypeAry *tary = TypeAry::make(TypeInt::BYTE, ta-&gt;size());
1327       ciKlass* aklass = ciTypeArrayKlass::make(T_BYTE);
1328       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,aklass,false,Type::Offset(offset), ta-&gt;field_offset());
1329     }
1330     // During the 2nd round of IterGVN, NotNull castings are removed.
1331     // Make sure the Bottom and NotNull variants alias the same.
1332     // Also, make sure exact and non-exact variants alias the same.
1333     if (ptr == TypePtr::NotNull || ta-&gt;klass_is_exact() || ta-&gt;speculative() != NULL) {
1334       tj = ta = TypeAryPtr::make(TypePtr::BotPTR,ta-&gt;ary(),ta-&gt;klass(),false,Type::Offset(offset), ta-&gt;field_offset());
1335     }
1336   }
1337 
1338   // Oop pointers need some flattening
1339   const TypeInstPtr *to = tj-&gt;isa_instptr();
1340   if( to &amp;&amp; _AliasLevel &gt;= 2 &amp;&amp; to != TypeOopPtr::BOTTOM ) {
1341     ciInstanceKlass *k = to-&gt;klass()-&gt;as_instance_klass();
1342     if( ptr == TypePtr::Constant ) {
1343       if (to-&gt;klass() != ciEnv::current()-&gt;Class_klass() ||
1344           offset &lt; k-&gt;size_helper() * wordSize) {
1345         // No constant oop pointers (such as Strings); they alias with
1346         // unknown strings.
1347         assert(!is_known_inst, &quot;not scalarizable allocation&quot;);
1348         tj = to = TypeInstPtr::make(TypePtr::BotPTR,to-&gt;klass(),false,0,Type::Offset(offset), to-&gt;klass()-&gt;flatten_array());
1349       }
1350     } else if( is_known_inst ) {
1351       tj = to; // Keep NotNull and klass_is_exact for instance type
1352     } else if( ptr == TypePtr::NotNull || to-&gt;klass_is_exact() ) {
1353       // During the 2nd round of IterGVN, NotNull castings are removed.
1354       // Make sure the Bottom and NotNull variants alias the same.
1355       // Also, make sure exact and non-exact variants alias the same.
1356       tj = to = TypeInstPtr::make(TypePtr::BotPTR,to-&gt;klass(),false,0,Type::Offset(offset), to-&gt;klass()-&gt;flatten_array());
1357     }
1358     if (to-&gt;speculative() != NULL) {
1359       tj = to = TypeInstPtr::make(to-&gt;ptr(),to-&gt;klass(),to-&gt;klass_is_exact(),to-&gt;const_oop(),Type::Offset(to-&gt;offset()), to-&gt;klass()-&gt;flatten_array(), to-&gt;instance_id());
1360     }
1361     // Canonicalize the holder of this field
1362     if (offset &gt;= 0 &amp;&amp; offset &lt; instanceOopDesc::base_offset_in_bytes()) {
1363       // First handle header references such as a LoadKlassNode, even if the
1364       // object&#39;s klass is unloaded at compile time (4965979).
1365       if (!is_known_inst) { // Do it only for non-instance types
1366         tj = to = TypeInstPtr::make(TypePtr::BotPTR, env()-&gt;Object_klass(), false, NULL, Type::Offset(offset), false);
1367       }
1368     } else if (offset &lt; 0 || offset &gt;= k-&gt;size_helper() * wordSize) {
1369       // Static fields are in the space above the normal instance
1370       // fields in the java.lang.Class instance.
1371       if (to-&gt;klass() != ciEnv::current()-&gt;Class_klass()) {
1372         to = NULL;
1373         tj = TypeOopPtr::BOTTOM;
1374         offset = tj-&gt;offset();
1375       }
1376     } else {
1377       ciInstanceKlass *canonical_holder = k-&gt;get_canonical_holder(offset);
1378       if (!k-&gt;equals(canonical_holder) || tj-&gt;offset() != offset) {
1379         if( is_known_inst ) {
1380           tj = to = TypeInstPtr::make(to-&gt;ptr(), canonical_holder, true, NULL, Type::Offset(offset), canonical_holder-&gt;flatten_array(), to-&gt;instance_id());
1381         } else {
1382           tj = to = TypeInstPtr::make(to-&gt;ptr(), canonical_holder, false, NULL, Type::Offset(offset), canonical_holder-&gt;flatten_array());
1383         }
1384       }
1385     }
1386   }
1387 
1388   // Klass pointers to object array klasses need some flattening
1389   const TypeKlassPtr *tk = tj-&gt;isa_klassptr();
1390   if( tk ) {
1391     // If we are referencing a field within a Klass, we need
1392     // to assume the worst case of an Object.  Both exact and
1393     // inexact types must flatten to the same alias class so
1394     // use NotNull as the PTR.
1395     if ( offset == Type::OffsetBot || (offset &gt;= 0 &amp;&amp; (size_t)offset &lt; sizeof(Klass)) ) {
1396 
1397       tj = tk = TypeKlassPtr::make(TypePtr::NotNull,
1398                                    TypeKlassPtr::OBJECT-&gt;klass(),
1399                                    Type::Offset(offset),
1400                                    false);
1401     }
1402 
1403     ciKlass* klass = tk-&gt;klass();
1404     if (klass != NULL &amp;&amp; klass-&gt;is_obj_array_klass()) {
1405       ciKlass* k = TypeAryPtr::OOPS-&gt;klass();
1406       if( !k || !k-&gt;is_loaded() )                  // Only fails for some -Xcomp runs
1407         k = TypeInstPtr::BOTTOM-&gt;klass();
1408       tj = tk = TypeKlassPtr::make(TypePtr::NotNull, k, Type::Offset(offset), false);
1409     }
1410 
1411     // Check for precise loads from the primary supertype array and force them
1412     // to the supertype cache alias index.  Check for generic array loads from
1413     // the primary supertype array and also force them to the supertype cache
1414     // alias index.  Since the same load can reach both, we need to merge
1415     // these 2 disparate memories into the same alias class.  Since the
1416     // primary supertype array is read-only, there&#39;s no chance of confusion
1417     // where we bypass an array load and an array store.
1418     int primary_supers_offset = in_bytes(Klass::primary_supers_offset());
1419     if (offset == Type::OffsetBot ||
1420         (offset &gt;= primary_supers_offset &amp;&amp;
1421          offset &lt; (int)(primary_supers_offset + Klass::primary_super_limit() * wordSize)) ||
1422         offset == (int)in_bytes(Klass::secondary_super_cache_offset())) {
1423       offset = in_bytes(Klass::secondary_super_cache_offset());
1424       tj = tk = TypeKlassPtr::make(TypePtr::NotNull, tk-&gt;klass(), Type::Offset(offset), tk-&gt;flat_array());
1425     }
1426   }
1427 
1428   // Flatten all Raw pointers together.
1429   if (tj-&gt;base() == Type::RawPtr)
1430     tj = TypeRawPtr::BOTTOM;
1431 
1432   if (tj-&gt;base() == Type::AnyPtr)
1433     tj = TypePtr::BOTTOM;      // An error, which the caller must check for.
1434 
1435   // Flatten all to bottom for now
1436   switch( _AliasLevel ) {
1437   case 0:
1438     tj = TypePtr::BOTTOM;
1439     break;
1440   case 1:                       // Flatten to: oop, static, field or array
1441     switch (tj-&gt;base()) {
1442     //case Type::AryPtr: tj = TypeAryPtr::RANGE;    break;
1443     case Type::RawPtr:   tj = TypeRawPtr::BOTTOM;   break;
1444     case Type::AryPtr:   // do not distinguish arrays at all
1445     case Type::InstPtr:  tj = TypeInstPtr::BOTTOM;  break;
1446     case Type::KlassPtr: tj = TypeKlassPtr::OBJECT; break;
1447     case Type::AnyPtr:   tj = TypePtr::BOTTOM;      break;  // caller checks it
1448     default: ShouldNotReachHere();
1449     }
1450     break;
1451   case 2:                       // No collapsing at level 2; keep all splits
1452   case 3:                       // No collapsing at level 3; keep all splits
1453     break;
1454   default:
1455     Unimplemented();
1456   }
1457 
1458   offset = tj-&gt;offset();
1459   assert( offset != Type::OffsetTop, &quot;Offset has fallen from constant&quot; );
1460 
1461   assert( (offset != Type::OffsetBot &amp;&amp; tj-&gt;base() != Type::AryPtr) ||
1462           (offset == Type::OffsetBot &amp;&amp; tj-&gt;base() == Type::AryPtr) ||
1463           (offset == Type::OffsetBot &amp;&amp; tj == TypeOopPtr::BOTTOM) ||
1464           (offset == Type::OffsetBot &amp;&amp; tj == TypePtr::BOTTOM) ||
1465           (offset == oopDesc::mark_offset_in_bytes() &amp;&amp; tj-&gt;base() == Type::AryPtr) ||
1466           (offset == oopDesc::klass_offset_in_bytes() &amp;&amp; tj-&gt;base() == Type::AryPtr) ||
1467           (offset == arrayOopDesc::length_offset_in_bytes() &amp;&amp; tj-&gt;base() == Type::AryPtr),
1468           &quot;For oops, klasses, raw offset must be constant; for arrays the offset is never known&quot; );
1469   assert( tj-&gt;ptr() != TypePtr::TopPTR &amp;&amp;
1470           tj-&gt;ptr() != TypePtr::AnyNull &amp;&amp;
1471           tj-&gt;ptr() != TypePtr::Null, &quot;No imprecise addresses&quot; );
1472 //    assert( tj-&gt;ptr() != TypePtr::Constant ||
1473 //            tj-&gt;base() == Type::RawPtr ||
1474 //            tj-&gt;base() == Type::KlassPtr, &quot;No constant oop addresses&quot; );
1475 
1476   return tj;
1477 }
1478 
1479 void Compile::AliasType::Init(int i, const TypePtr* at) {
1480   assert(AliasIdxTop &lt;= i &amp;&amp; i &lt; Compile::current()-&gt;_max_alias_types, &quot;Invalid alias index&quot;);
1481   _index = i;
1482   _adr_type = at;
1483   _field = NULL;
1484   _element = NULL;
1485   _is_rewritable = true; // default
1486   const TypeOopPtr *atoop = (at != NULL) ? at-&gt;isa_oopptr() : NULL;
1487   if (atoop != NULL &amp;&amp; atoop-&gt;is_known_instance()) {
1488     const TypeOopPtr *gt = atoop-&gt;cast_to_instance_id(TypeOopPtr::InstanceBot);
1489     _general_index = Compile::current()-&gt;get_alias_index(gt);
1490   } else {
1491     _general_index = 0;
1492   }
1493 }
1494 
1495 BasicType Compile::AliasType::basic_type() const {
1496   if (element() != NULL) {
1497     const Type* element = adr_type()-&gt;is_aryptr()-&gt;elem();
1498     return element-&gt;isa_narrowoop() ? T_OBJECT : element-&gt;array_element_basic_type();
1499   } if (field() != NULL) {
1500     return field()-&gt;layout_type();
1501   } else {
1502     return T_ILLEGAL; // unknown
1503   }
1504 }
1505 
1506 //---------------------------------print_on------------------------------------
1507 #ifndef PRODUCT
1508 void Compile::AliasType::print_on(outputStream* st) {
1509   if (index() &lt; 10)
1510         st-&gt;print(&quot;@ &lt;%d&gt; &quot;, index());
1511   else  st-&gt;print(&quot;@ &lt;%d&gt;&quot;,  index());
1512   st-&gt;print(is_rewritable() ? &quot;   &quot; : &quot; RO&quot;);
1513   int offset = adr_type()-&gt;offset();
1514   if (offset == Type::OffsetBot)
1515         st-&gt;print(&quot; +any&quot;);
1516   else  st-&gt;print(&quot; +%-3d&quot;, offset);
1517   st-&gt;print(&quot; in &quot;);
1518   adr_type()-&gt;dump_on(st);
1519   const TypeOopPtr* tjp = adr_type()-&gt;isa_oopptr();
1520   if (field() != NULL &amp;&amp; tjp) {
1521     if (tjp-&gt;klass()  != field()-&gt;holder() ||
1522         tjp-&gt;offset() != field()-&gt;offset_in_bytes()) {
1523       st-&gt;print(&quot; != &quot;);
1524       field()-&gt;print();
1525       st-&gt;print(&quot; ***&quot;);
1526     }
1527   }
1528 }
1529 
1530 void print_alias_types() {
1531   Compile* C = Compile::current();
1532   tty-&gt;print_cr(&quot;--- Alias types, AliasIdxBot .. %d&quot;, C-&gt;num_alias_types()-1);
1533   for (int idx = Compile::AliasIdxBot; idx &lt; C-&gt;num_alias_types(); idx++) {
1534     C-&gt;alias_type(idx)-&gt;print_on(tty);
1535     tty-&gt;cr();
1536   }
1537 }
1538 #endif
1539 
1540 
1541 //----------------------------probe_alias_cache--------------------------------
1542 Compile::AliasCacheEntry* Compile::probe_alias_cache(const TypePtr* adr_type) {
1543   intptr_t key = (intptr_t) adr_type;
1544   key ^= key &gt;&gt; logAliasCacheSize;
1545   return &amp;_alias_cache[key &amp; right_n_bits(logAliasCacheSize)];
1546 }
1547 
1548 
1549 //-----------------------------grow_alias_types--------------------------------
1550 void Compile::grow_alias_types() {
1551   const int old_ats  = _max_alias_types; // how many before?
1552   const int new_ats  = old_ats;          // how many more?
1553   const int grow_ats = old_ats+new_ats;  // how many now?
1554   _max_alias_types = grow_ats;
1555   _alias_types =  REALLOC_ARENA_ARRAY(comp_arena(), AliasType*, _alias_types, old_ats, grow_ats);
1556   AliasType* ats =    NEW_ARENA_ARRAY(comp_arena(), AliasType, new_ats);
1557   Copy::zero_to_bytes(ats, sizeof(AliasType)*new_ats);
1558   for (int i = 0; i &lt; new_ats; i++)  _alias_types[old_ats+i] = &amp;ats[i];
1559 }
1560 
1561 
1562 //--------------------------------find_alias_type------------------------------
1563 Compile::AliasType* Compile::find_alias_type(const TypePtr* adr_type, bool no_create, ciField* original_field, bool uncached) {
1564   if (_AliasLevel == 0)
1565     return alias_type(AliasIdxBot);
1566 
1567   AliasCacheEntry* ace = NULL;
1568   if (!uncached) {
1569     ace = probe_alias_cache(adr_type);
1570     if (ace-&gt;_adr_type == adr_type) {
1571       return alias_type(ace-&gt;_index);
1572     }
1573   }
1574 
1575   // Handle special cases.
1576   if (adr_type == NULL)             return alias_type(AliasIdxTop);
1577   if (adr_type == TypePtr::BOTTOM)  return alias_type(AliasIdxBot);
1578 
1579   // Do it the slow way.
1580   const TypePtr* flat = flatten_alias_type(adr_type);
1581 
1582 #ifdef ASSERT
1583   {
1584     ResourceMark rm;
1585     assert(flat == flatten_alias_type(flat), &quot;not idempotent: adr_type = %s; flat = %s =&gt; %s&quot;,
1586            Type::str(adr_type), Type::str(flat), Type::str(flatten_alias_type(flat)));
1587     assert(flat != TypePtr::BOTTOM, &quot;cannot alias-analyze an untyped ptr: adr_type = %s&quot;,
1588            Type::str(adr_type));
1589     if (flat-&gt;isa_oopptr() &amp;&amp; !flat-&gt;isa_klassptr()) {
1590       const TypeOopPtr* foop = flat-&gt;is_oopptr();
1591       // Scalarizable allocations have exact klass always.
1592       bool exact = !foop-&gt;klass_is_exact() || foop-&gt;is_known_instance();
1593       const TypePtr* xoop = foop-&gt;cast_to_exactness(exact)-&gt;is_ptr();
1594       assert(foop == flatten_alias_type(xoop), &quot;exactness must not affect alias type: foop = %s; xoop = %s&quot;,
1595              Type::str(foop), Type::str(xoop));
1596     }
1597   }
1598 #endif
1599 
1600   int idx = AliasIdxTop;
1601   for (int i = 0; i &lt; num_alias_types(); i++) {
1602     if (alias_type(i)-&gt;adr_type() == flat) {
1603       idx = i;
1604       break;
1605     }
1606   }
1607 
1608   if (idx == AliasIdxTop) {
1609     if (no_create)  return NULL;
1610     // Grow the array if necessary.
1611     if (_num_alias_types == _max_alias_types)  grow_alias_types();
1612     // Add a new alias type.
1613     idx = _num_alias_types++;
1614     _alias_types[idx]-&gt;Init(idx, flat);
1615     if (flat == TypeInstPtr::KLASS)  alias_type(idx)-&gt;set_rewritable(false);
1616     if (flat == TypeAryPtr::RANGE)   alias_type(idx)-&gt;set_rewritable(false);
1617     if (flat-&gt;isa_instptr()) {
1618       if (flat-&gt;offset() == java_lang_Class::klass_offset_in_bytes()
1619           &amp;&amp; flat-&gt;is_instptr()-&gt;klass() == env()-&gt;Class_klass())
1620         alias_type(idx)-&gt;set_rewritable(false);
1621     }
1622     ciField* field = NULL;
1623     if (flat-&gt;isa_aryptr()) {
1624 #ifdef ASSERT
1625       const int header_size_min  = arrayOopDesc::base_offset_in_bytes(T_BYTE);
1626       // (T_BYTE has the weakest alignment and size restrictions...)
1627       assert(flat-&gt;offset() &lt; header_size_min, &quot;array body reference must be OffsetBot&quot;);
1628 #endif
1629       const Type* elemtype = flat-&gt;is_aryptr()-&gt;elem();
1630       if (flat-&gt;offset() == TypePtr::OffsetBot) {
1631         alias_type(idx)-&gt;set_element(elemtype);
1632       }
1633       int field_offset = flat-&gt;is_aryptr()-&gt;field_offset().get();
1634       if (elemtype-&gt;isa_valuetype() &amp;&amp;
1635           elemtype-&gt;value_klass() != NULL &amp;&amp;
1636           field_offset != Type::OffsetBot) {
1637         ciValueKlass* vk = elemtype-&gt;value_klass();
1638         field_offset += vk-&gt;first_field_offset();
1639         field = vk-&gt;get_field_by_offset(field_offset, false);
1640       }
1641     }
1642     if (flat-&gt;isa_klassptr()) {
1643       if (flat-&gt;offset() == in_bytes(Klass::super_check_offset_offset()))
1644         alias_type(idx)-&gt;set_rewritable(false);
1645       if (flat-&gt;offset() == in_bytes(Klass::modifier_flags_offset()))
1646         alias_type(idx)-&gt;set_rewritable(false);
1647       if (flat-&gt;offset() == in_bytes(Klass::access_flags_offset()))
1648         alias_type(idx)-&gt;set_rewritable(false);
1649       if (flat-&gt;offset() == in_bytes(Klass::java_mirror_offset()))
1650         alias_type(idx)-&gt;set_rewritable(false);
1651       if (flat-&gt;offset() == in_bytes(Klass::layout_helper_offset()))
1652         alias_type(idx)-&gt;set_rewritable(false);
<a name="19" id="anc19"></a><span class="line-added">1653       if (flat-&gt;offset() == in_bytes(Klass::secondary_super_cache_offset()))</span>
<span class="line-added">1654         alias_type(idx)-&gt;set_rewritable(false);</span>
1655     }
1656     // %%% (We would like to finalize JavaThread::threadObj_offset(),
1657     // but the base pointer type is not distinctive enough to identify
1658     // references into JavaThread.)
1659 
1660     // Check for final fields.
1661     const TypeInstPtr* tinst = flat-&gt;isa_instptr();
1662     if (tinst &amp;&amp; tinst-&gt;offset() &gt;= instanceOopDesc::base_offset_in_bytes()) {
1663       if (tinst-&gt;const_oop() != NULL &amp;&amp;
1664           tinst-&gt;klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
1665           tinst-&gt;offset() &gt;= (tinst-&gt;klass()-&gt;as_instance_klass()-&gt;size_helper() * wordSize)) {
1666         // static field
1667         ciInstanceKlass* k = tinst-&gt;const_oop()-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
1668         field = k-&gt;get_field_by_offset(tinst-&gt;offset(), true);
1669       } else if (tinst-&gt;klass()-&gt;is_valuetype()) {
1670         // Value type field
1671         ciValueKlass* vk = tinst-&gt;value_klass();
1672         field = vk-&gt;get_field_by_offset(tinst-&gt;offset(), false);
1673       } else {
1674         ciInstanceKlass* k = tinst-&gt;klass()-&gt;as_instance_klass();
1675         field = k-&gt;get_field_by_offset(tinst-&gt;offset(), false);
1676       }
1677     }
1678     assert(field == NULL ||
1679            original_field == NULL ||
1680            (field-&gt;holder() == original_field-&gt;holder() &amp;&amp;
1681             field-&gt;offset() == original_field-&gt;offset() &amp;&amp;
1682             field-&gt;is_static() == original_field-&gt;is_static()), &quot;wrong field?&quot;);
1683     // Set field() and is_rewritable() attributes.
1684     if (field != NULL) {
1685       alias_type(idx)-&gt;set_field(field);
1686       if (flat-&gt;isa_aryptr()) {
1687         // Fields of flattened inline type arrays are rewritable although they are declared final
1688         assert(flat-&gt;is_aryptr()-&gt;elem()-&gt;isa_valuetype(), &quot;must be a flattened value array&quot;);
1689         alias_type(idx)-&gt;set_rewritable(true);
1690       }
1691     }
1692   }
1693 
1694   // Fill the cache for next time.
1695   if (!uncached) {
1696     ace-&gt;_adr_type = adr_type;
1697     ace-&gt;_index    = idx;
1698     assert(alias_type(adr_type) == alias_type(idx),  &quot;type must be installed&quot;);
1699 
1700     // Might as well try to fill the cache for the flattened version, too.
1701     AliasCacheEntry* face = probe_alias_cache(flat);
1702     if (face-&gt;_adr_type == NULL) {
1703       face-&gt;_adr_type = flat;
1704       face-&gt;_index    = idx;
1705       assert(alias_type(flat) == alias_type(idx), &quot;flat type must work too&quot;);
1706     }
1707   }
1708 
1709   return alias_type(idx);
1710 }
1711 
1712 
1713 Compile::AliasType* Compile::alias_type(ciField* field) {
1714   const TypeOopPtr* t;
1715   if (field-&gt;is_static())
1716     t = TypeInstPtr::make(field-&gt;holder()-&gt;java_mirror());
1717   else
1718     t = TypeOopPtr::make_from_klass_raw(field-&gt;holder());
1719   AliasType* atp = alias_type(t-&gt;add_offset(field-&gt;offset_in_bytes()), field);
1720   assert((field-&gt;is_final() || field-&gt;is_stable()) == !atp-&gt;is_rewritable(), &quot;must get the rewritable bits correct&quot;);
1721   return atp;
1722 }
1723 
1724 
1725 //------------------------------have_alias_type--------------------------------
1726 bool Compile::have_alias_type(const TypePtr* adr_type) {
1727   AliasCacheEntry* ace = probe_alias_cache(adr_type);
1728   if (ace-&gt;_adr_type == adr_type) {
1729     return true;
1730   }
1731 
1732   // Handle special cases.
1733   if (adr_type == NULL)             return true;
1734   if (adr_type == TypePtr::BOTTOM)  return true;
1735 
1736   return find_alias_type(adr_type, true, NULL) != NULL;
1737 }
1738 
1739 //-----------------------------must_alias--------------------------------------
1740 // True if all values of the given address type are in the given alias category.
1741 bool Compile::must_alias(const TypePtr* adr_type, int alias_idx) {
1742   if (alias_idx == AliasIdxBot)         return true;  // the universal category
1743   if (adr_type == NULL)                 return true;  // NULL serves as TypePtr::TOP
1744   if (alias_idx == AliasIdxTop)         return false; // the empty category
1745   if (adr_type-&gt;base() == Type::AnyPtr) return false; // TypePtr::BOTTOM or its twins
1746 
1747   // the only remaining possible overlap is identity
1748   int adr_idx = get_alias_index(adr_type);
1749   assert(adr_idx != AliasIdxBot &amp;&amp; adr_idx != AliasIdxTop, &quot;&quot;);
1750   assert(adr_idx == alias_idx ||
1751          (alias_type(alias_idx)-&gt;adr_type() != TypeOopPtr::BOTTOM
1752           &amp;&amp; adr_type                       != TypeOopPtr::BOTTOM),
1753          &quot;should not be testing for overlap with an unsafe pointer&quot;);
1754   return adr_idx == alias_idx;
1755 }
1756 
1757 //------------------------------can_alias--------------------------------------
1758 // True if any values of the given address type are in the given alias category.
1759 bool Compile::can_alias(const TypePtr* adr_type, int alias_idx) {
1760   if (alias_idx == AliasIdxTop)         return false; // the empty category
1761   if (adr_type == NULL)                 return false; // NULL serves as TypePtr::TOP
<a name="20" id="anc20"></a><span class="line-modified">1762   // Known instance doesn&#39;t alias with bottom memory</span>
<span class="line-modified">1763   if (alias_idx == AliasIdxBot)         return !adr_type-&gt;is_known_instance();                   // the universal category</span>
<span class="line-added">1764   if (adr_type-&gt;base() == Type::AnyPtr) return !C-&gt;get_adr_type(alias_idx)-&gt;is_known_instance(); // TypePtr::BOTTOM or its twins</span>
1765 
1766   // the only remaining possible overlap is identity
1767   int adr_idx = get_alias_index(adr_type);
1768   assert(adr_idx != AliasIdxBot &amp;&amp; adr_idx != AliasIdxTop, &quot;&quot;);
1769   return adr_idx == alias_idx;
1770 }
1771 
1772 
1773 
1774 //---------------------------pop_warm_call-------------------------------------
1775 WarmCallInfo* Compile::pop_warm_call() {
1776   WarmCallInfo* wci = _warm_calls;
1777   if (wci != NULL)  _warm_calls = wci-&gt;remove_from(wci);
1778   return wci;
1779 }
1780 
1781 //----------------------------Inline_Warm--------------------------------------
1782 int Compile::Inline_Warm() {
1783   // If there is room, try to inline some more warm call sites.
1784   // %%% Do a graph index compaction pass when we think we&#39;re out of space?
1785   if (!InlineWarmCalls)  return 0;
1786 
1787   int calls_made_hot = 0;
1788   int room_to_grow   = NodeCountInliningCutoff - unique();
1789   int amount_to_grow = MIN2(room_to_grow, (int)NodeCountInliningStep);
1790   int amount_grown   = 0;
1791   WarmCallInfo* call;
1792   while (amount_to_grow &gt; 0 &amp;&amp; (call = pop_warm_call()) != NULL) {
1793     int est_size = (int)call-&gt;size();
1794     if (est_size &gt; (room_to_grow - amount_grown)) {
1795       // This one won&#39;t fit anyway.  Get rid of it.
1796       call-&gt;make_cold();
1797       continue;
1798     }
1799     call-&gt;make_hot();
1800     calls_made_hot++;
1801     amount_grown   += est_size;
1802     amount_to_grow -= est_size;
1803   }
1804 
1805   if (calls_made_hot &gt; 0)  set_major_progress();
1806   return calls_made_hot;
1807 }
1808 
1809 
1810 //----------------------------Finish_Warm--------------------------------------
1811 void Compile::Finish_Warm() {
1812   if (!InlineWarmCalls)  return;
1813   if (failing())  return;
1814   if (warm_calls() == NULL)  return;
1815 
1816   // Clean up loose ends, if we are out of space for inlining.
1817   WarmCallInfo* call;
1818   while ((call = pop_warm_call()) != NULL) {
1819     call-&gt;make_cold();
1820   }
1821 }
1822 
1823 //---------------------cleanup_loop_predicates-----------------------
1824 // Remove the opaque nodes that protect the predicates so that all unused
1825 // checks and uncommon_traps will be eliminated from the ideal graph
1826 void Compile::cleanup_loop_predicates(PhaseIterGVN &amp;igvn) {
1827   if (predicate_count()==0) return;
1828   for (int i = predicate_count(); i &gt; 0; i--) {
1829     Node * n = predicate_opaque1_node(i-1);
1830     assert(n-&gt;Opcode() == Op_Opaque1, &quot;must be&quot;);
1831     igvn.replace_node(n, n-&gt;in(1));
1832   }
1833   assert(predicate_count()==0, &quot;should be clean!&quot;);
1834 }
1835 
1836 void Compile::add_range_check_cast(Node* n) {
1837   assert(n-&gt;isa_CastII()-&gt;has_range_check(), &quot;CastII should have range check dependency&quot;);
1838   assert(!_range_check_casts-&gt;contains(n), &quot;duplicate entry in range check casts&quot;);
1839   _range_check_casts-&gt;append(n);
1840 }
1841 
1842 // Remove all range check dependent CastIINodes.
1843 void Compile::remove_range_check_casts(PhaseIterGVN &amp;igvn) {
1844   for (int i = range_check_cast_count(); i &gt; 0; i--) {
1845     Node* cast = range_check_cast_node(i-1);
1846     assert(cast-&gt;isa_CastII()-&gt;has_range_check(), &quot;CastII should have range check dependency&quot;);
1847     igvn.replace_node(cast, cast-&gt;in(1));
1848   }
1849   assert(range_check_cast_count() == 0, &quot;should be empty&quot;);
1850 }
1851 
1852 void Compile::add_opaque4_node(Node* n) {
1853   assert(n-&gt;Opcode() == Op_Opaque4, &quot;Opaque4 only&quot;);
1854   assert(!_opaque4_nodes-&gt;contains(n), &quot;duplicate entry in Opaque4 list&quot;);
1855   _opaque4_nodes-&gt;append(n);
1856 }
1857 
1858 // Remove all Opaque4 nodes.
1859 void Compile::remove_opaque4_nodes(PhaseIterGVN &amp;igvn) {
1860   for (int i = opaque4_count(); i &gt; 0; i--) {
1861     Node* opaq = opaque4_node(i-1);
1862     assert(opaq-&gt;Opcode() == Op_Opaque4, &quot;Opaque4 only&quot;);
1863     igvn.replace_node(opaq, opaq-&gt;in(2));
1864   }
1865   assert(opaque4_count() == 0, &quot;should be empty&quot;);
1866 }
1867 
1868 void Compile::add_value_type(Node* n) {
1869   assert(n-&gt;is_ValueTypeBase(), &quot;unexpected node&quot;);
1870   if (_value_type_nodes != NULL) {
1871     _value_type_nodes-&gt;push(n);
1872   }
1873 }
1874 
1875 void Compile::remove_value_type(Node* n) {
1876   assert(n-&gt;is_ValueTypeBase(), &quot;unexpected node&quot;);
1877   if (_value_type_nodes != NULL) {
1878     _value_type_nodes-&gt;remove(n);
1879   }
1880 }
1881 
1882 // Does the return value keep otherwise useless value type allocations
1883 // alive?
1884 static bool return_val_keeps_allocations_alive(Node* ret_val) {
1885   ResourceMark rm;
1886   Unique_Node_List wq;
1887   wq.push(ret_val);
1888   bool some_allocations = false;
1889   for (uint i = 0; i &lt; wq.size(); i++) {
1890     Node* n = wq.at(i);
1891     assert(!n-&gt;is_ValueTypeBase(), &quot;chain of value type nodes&quot;);
1892     if (n-&gt;outcnt() &gt; 1) {
1893       // Some other use for the allocation
1894       return false;
1895     } else if (n-&gt;is_Phi()) {
1896       for (uint j = 1; j &lt; n-&gt;req(); j++) {
1897         wq.push(n-&gt;in(j));
1898       }
1899     } else if (n-&gt;is_CheckCastPP() &amp;&amp;
1900                n-&gt;in(1)-&gt;is_Proj() &amp;&amp;
1901                n-&gt;in(1)-&gt;in(0)-&gt;is_Allocate()) {
1902       some_allocations = true;
1903     }
1904   }
1905   return some_allocations;
1906 }
1907 
1908 void Compile::process_value_types(PhaseIterGVN &amp;igvn) {
1909   // Make value types scalar in safepoints
1910   while (_value_type_nodes-&gt;size() != 0) {
1911     ValueTypeBaseNode* vt = _value_type_nodes-&gt;pop()-&gt;as_ValueTypeBase();
1912     vt-&gt;make_scalar_in_safepoints(&amp;igvn);
1913     if (vt-&gt;is_ValueTypePtr()) {
1914       igvn.replace_node(vt, vt-&gt;get_oop());
1915     } else if (vt-&gt;outcnt() == 0) {
1916       igvn.remove_dead_node(vt);
1917     }
1918   }
1919   _value_type_nodes = NULL;
1920   if (tf()-&gt;returns_value_type_as_fields()) {
1921     Node* ret = NULL;
1922     for (uint i = 1; i &lt; root()-&gt;req(); i++){
1923       Node* in = root()-&gt;in(i);
1924       if (in-&gt;Opcode() == Op_Return) {
1925         assert(ret == NULL, &quot;only one return&quot;);
1926         ret = in;
1927       }
1928     }
1929     if (ret != NULL) {
1930       Node* ret_val = ret-&gt;in(TypeFunc::Parms);
1931       if (igvn.type(ret_val)-&gt;isa_oopptr() &amp;&amp;
1932           return_val_keeps_allocations_alive(ret_val)) {
1933         igvn.replace_input_of(ret, TypeFunc::Parms, ValueTypeNode::tagged_klass(igvn.type(ret_val)-&gt;value_klass(), igvn));
1934         assert(ret_val-&gt;outcnt() == 0, &quot;should be dead now&quot;);
1935         igvn.remove_dead_node(ret_val);
1936       }
1937     }
1938   }
1939   igvn.optimize();
1940 }
1941 
1942 void Compile::adjust_flattened_array_access_aliases(PhaseIterGVN&amp; igvn) {
1943   if (!_has_flattened_accesses) {
1944     return;
1945   }
1946   // Initially, all flattened array accesses share the same slice to
1947   // keep dependencies with Object[] array accesses (that could be
1948   // to a flattened array) correct. We&#39;re done with parsing so we
1949   // now know all flattened array accesses in this compile
1950   // unit. Let&#39;s move flattened array accesses to their own slice,
1951   // one per element field. This should help memory access
1952   // optimizations.
1953   ResourceMark rm;
1954   Unique_Node_List wq;
1955   wq.push(root());
1956 
1957   Node_List mergememnodes;
1958   Node_List memnodes;
1959 
1960   // Alias index currently shared by all flattened memory accesses
1961   int index = get_alias_index(TypeAryPtr::VALUES);
1962 
1963   // Find MergeMem nodes and flattened array accesses
1964   for (uint i = 0; i &lt; wq.size(); i++) {
1965     Node* n = wq.at(i);
1966     if (n-&gt;is_Mem()) {
1967       const TypePtr* adr_type = NULL;
1968       if (n-&gt;Opcode() == Op_StoreCM) {
1969         adr_type = get_adr_type(get_alias_index(n-&gt;in(MemNode::OopStore)-&gt;adr_type()));
1970       } else {
1971         adr_type = get_adr_type(get_alias_index(n-&gt;adr_type()));
1972       }
1973       if (adr_type == TypeAryPtr::VALUES) {
1974         memnodes.push(n);
1975       }
1976     } else if (n-&gt;is_MergeMem()) {
1977       MergeMemNode* mm = n-&gt;as_MergeMem();
1978       if (mm-&gt;memory_at(index) != mm-&gt;base_memory()) {
1979         mergememnodes.push(n);
1980       }
1981     }
1982     for (uint j = 0; j &lt; n-&gt;req(); j++) {
1983       Node* m = n-&gt;in(j);
1984       if (m != NULL) {
1985         wq.push(m);
1986       }
1987     }
1988   }
1989 
1990   if (memnodes.size() &gt; 0) {
1991     _flattened_accesses_share_alias = false;
1992 
1993     // We are going to change the slice for the flattened array
1994     // accesses so we need to clear the cache entries that refer to
1995     // them.
1996     for (uint i = 0; i &lt; AliasCacheSize; i++) {
1997       AliasCacheEntry* ace = &amp;_alias_cache[i];
1998       if (ace-&gt;_adr_type != NULL &amp;&amp;
1999           ace-&gt;_adr_type-&gt;isa_aryptr() &amp;&amp;
2000           ace-&gt;_adr_type-&gt;is_aryptr()-&gt;elem()-&gt;isa_valuetype()) {
2001         ace-&gt;_adr_type = NULL;
2002         ace-&gt;_index = (i != 0) ? 0 : AliasIdxTop; // Make sure the NULL adr_type resolves to AliasIdxTop
2003       }
2004     }
2005 
2006     // Find what aliases we are going to add
2007     int start_alias = num_alias_types()-1;
2008     int stop_alias = 0;
2009 
2010     for (uint i = 0; i &lt; memnodes.size(); i++) {
2011       Node* m = memnodes.at(i);
2012       const TypePtr* adr_type = NULL;
2013       if (m-&gt;Opcode() == Op_StoreCM) {
2014         adr_type = m-&gt;in(MemNode::OopStore)-&gt;adr_type();
2015         Node* clone = new StoreCMNode(m-&gt;in(MemNode::Control), m-&gt;in(MemNode::Memory), m-&gt;in(MemNode::Address),
2016                                       m-&gt;adr_type(), m-&gt;in(MemNode::ValueIn), m-&gt;in(MemNode::OopStore),
2017                                       get_alias_index(adr_type));
2018         igvn.register_new_node_with_optimizer(clone);
2019         igvn.replace_node(m, clone);
2020       } else {
2021         adr_type = m-&gt;adr_type();
2022 #ifdef ASSERT
2023         m-&gt;as_Mem()-&gt;set_adr_type(adr_type);
2024 #endif
2025       }
2026       int idx = get_alias_index(adr_type);
2027       start_alias = MIN2(start_alias, idx);
2028       stop_alias = MAX2(stop_alias, idx);
2029     }
2030 
2031     assert(stop_alias &gt;= start_alias, &quot;should have expanded aliases&quot;);
2032 
2033     Node_Stack stack(0);
2034 #ifdef ASSERT
2035     VectorSet seen(Thread::current()-&gt;resource_area());
2036 #endif
2037     // Now let&#39;s fix the memory graph so each flattened array access
2038     // is moved to the right slice. Start from the MergeMem nodes.
2039     uint last = unique();
2040     for (uint i = 0; i &lt; mergememnodes.size(); i++) {
2041       MergeMemNode* current = mergememnodes.at(i)-&gt;as_MergeMem();
2042       Node* n = current-&gt;memory_at(index);
2043       MergeMemNode* mm = NULL;
2044       do {
2045         // Follow memory edges through memory accesses, phis and
2046         // narrow membars and push nodes on the stack. Once we hit
2047         // bottom memory, we pop element off the stack one at a
2048         // time, in reverse order, and move them to the right slice
2049         // by changing their memory edges.
2050         if ((n-&gt;is_Phi() &amp;&amp; n-&gt;adr_type() != TypePtr::BOTTOM) || n-&gt;is_Mem() || n-&gt;adr_type() == TypeAryPtr::VALUES) {
2051           assert(!seen.test_set(n-&gt;_idx), &quot;&quot;);
2052           // Uses (a load for instance) will need to be moved to the
2053           // right slice as well and will get a new memory state
2054           // that we don&#39;t know yet. The use could also be the
2055           // backedge of a loop. We put a place holder node between
2056           // the memory node and its uses. We replace that place
2057           // holder with the correct memory state once we know it,
2058           // i.e. when nodes are popped off the stack. Using the
2059           // place holder make the logic work in the presence of
2060           // loops.
2061           if (n-&gt;outcnt() &gt; 1) {
2062             Node* place_holder = NULL;
2063             assert(!n-&gt;has_out_with(Op_Node), &quot;&quot;);
2064             for (DUIterator k = n-&gt;outs(); n-&gt;has_out(k); k++) {
2065               Node* u = n-&gt;out(k);
2066               if (u != current &amp;&amp; u-&gt;_idx &lt; last) {
2067                 bool success = false;
2068                 for (uint l = 0; l &lt; u-&gt;req(); l++) {
2069                   if (!stack.is_empty() &amp;&amp; u == stack.node() &amp;&amp; l == stack.index()) {
2070                     continue;
2071                   }
2072                   Node* in = u-&gt;in(l);
2073                   if (in == n) {
2074                     if (place_holder == NULL) {
2075                       place_holder = new Node(1);
2076                       place_holder-&gt;init_req(0, n);
2077                     }
2078                     igvn.replace_input_of(u, l, place_holder);
2079                     success = true;
2080                   }
2081                 }
2082                 if (success) {
2083                   --k;
2084                 }
2085               }
2086             }
2087           }
2088           if (n-&gt;is_Phi()) {
2089             stack.push(n, 1);
2090             n = n-&gt;in(1);
2091           } else if (n-&gt;is_Mem()) {
2092             stack.push(n, n-&gt;req());
2093             n = n-&gt;in(MemNode::Memory);
2094           } else {
2095             assert(n-&gt;is_Proj() &amp;&amp; n-&gt;in(0)-&gt;Opcode() == Op_MemBarCPUOrder, &quot;&quot;);
2096             stack.push(n, n-&gt;req());
2097             n = n-&gt;in(0)-&gt;in(TypeFunc::Memory);
2098           }
2099         } else {
2100           assert(n-&gt;adr_type() == TypePtr::BOTTOM || (n-&gt;Opcode() == Op_Node &amp;&amp; n-&gt;_idx &gt;= last) || (n-&gt;is_Proj() &amp;&amp; n-&gt;in(0)-&gt;is_Initialize()), &quot;&quot;);
2101           // Build a new MergeMem node to carry the new memory state
2102           // as we build it. IGVN should fold extraneous MergeMem
2103           // nodes.
2104           mm = MergeMemNode::make(n);
2105           igvn.register_new_node_with_optimizer(mm);
2106           while (stack.size() &gt; 0) {
2107             Node* m = stack.node();
2108             uint idx = stack.index();
2109             if (m-&gt;is_Mem()) {
2110               // Move memory node to its new slice
2111               const TypePtr* adr_type = m-&gt;adr_type();
2112               int alias = get_alias_index(adr_type);
2113               Node* prev = mm-&gt;memory_at(alias);
2114               igvn.replace_input_of(m, MemNode::Memory, prev);
2115               mm-&gt;set_memory_at(alias, m);
2116             } else if (m-&gt;is_Phi()) {
2117               // We need as many new phis as there are new aliases
2118               igvn.replace_input_of(m, idx, mm);
2119               if (idx == m-&gt;req()-1) {
2120                 Node* r = m-&gt;in(0);
2121                 for (uint j = (uint)start_alias; j &lt;= (uint)stop_alias; j++) {
2122                   const Type* adr_type = get_adr_type(j);
2123                   if (!adr_type-&gt;isa_aryptr() || !adr_type-&gt;is_aryptr()-&gt;elem()-&gt;isa_valuetype()) {
2124                     continue;
2125                   }
2126                   Node* phi = new PhiNode(r, Type::MEMORY, get_adr_type(j));
2127                   igvn.register_new_node_with_optimizer(phi);
2128                   for (uint k = 1; k &lt; m-&gt;req(); k++) {
2129                     phi-&gt;init_req(k, m-&gt;in(k)-&gt;as_MergeMem()-&gt;memory_at(j));
2130                   }
2131                   mm-&gt;set_memory_at(j, phi);
2132                 }
2133                 Node* base_phi = new PhiNode(r, Type::MEMORY, TypePtr::BOTTOM);
2134                 igvn.register_new_node_with_optimizer(base_phi);
2135                 for (uint k = 1; k &lt; m-&gt;req(); k++) {
2136                   base_phi-&gt;init_req(k, m-&gt;in(k)-&gt;as_MergeMem()-&gt;base_memory());
2137                 }
2138                 mm-&gt;set_base_memory(base_phi);
2139               }
2140             } else {
2141               // This is a MemBarCPUOrder node from
2142               // Parse::array_load()/Parse::array_store(), in the
2143               // branch that handles flattened arrays hidden under
2144               // an Object[] array. We also need one new membar per
2145               // new alias to keep the unknown access that the
2146               // membars protect properly ordered with accesses to
2147               // known flattened array.
2148               assert(m-&gt;is_Proj(), &quot;projection expected&quot;);
2149               Node* ctrl = m-&gt;in(0)-&gt;in(TypeFunc::Control);
2150               igvn.replace_input_of(m-&gt;in(0), TypeFunc::Control, top());
2151               for (uint j = (uint)start_alias; j &lt;= (uint)stop_alias; j++) {
2152                 const Type* adr_type = get_adr_type(j);
2153                 if (!adr_type-&gt;isa_aryptr() || !adr_type-&gt;is_aryptr()-&gt;elem()-&gt;isa_valuetype()) {
2154                   continue;
2155                 }
2156                 MemBarNode* mb = new MemBarCPUOrderNode(this, j, NULL);
2157                 igvn.register_new_node_with_optimizer(mb);
2158                 Node* mem = mm-&gt;memory_at(j);
2159                 mb-&gt;init_req(TypeFunc::Control, ctrl);
2160                 mb-&gt;init_req(TypeFunc::Memory, mem);
2161                 ctrl = new ProjNode(mb, TypeFunc::Control);
2162                 igvn.register_new_node_with_optimizer(ctrl);
2163                 mem = new ProjNode(mb, TypeFunc::Memory);
2164                 igvn.register_new_node_with_optimizer(mem);
2165                 mm-&gt;set_memory_at(j, mem);
2166               }
2167               igvn.replace_node(m-&gt;in(0)-&gt;as_Multi()-&gt;proj_out(TypeFunc::Control), ctrl);
2168             }
2169             if (idx &lt; m-&gt;req()-1) {
2170               idx += 1;
2171               stack.set_index(idx);
2172               n = m-&gt;in(idx);
2173               break;
2174             }
2175             // Take care of place holder nodes
2176             if (m-&gt;has_out_with(Op_Node)) {
2177               Node* place_holder = m-&gt;find_out_with(Op_Node);
2178               if (place_holder != NULL) {
2179                 Node* mm_clone = mm-&gt;clone();
2180                 igvn.register_new_node_with_optimizer(mm_clone);
2181                 Node* hook = new Node(1);
2182                 hook-&gt;init_req(0, mm);
2183                 igvn.replace_node(place_holder, mm_clone);
2184                 hook-&gt;destruct();
2185               }
2186               assert(!m-&gt;has_out_with(Op_Node), &quot;place holder should be gone now&quot;);
2187             }
2188             stack.pop();
2189           }
2190         }
2191       } while(stack.size() &gt; 0);
2192       // Fix the memory state at the MergeMem we started from
2193       igvn.rehash_node_delayed(current);
2194       for (uint j = (uint)start_alias; j &lt;= (uint)stop_alias; j++) {
2195         const Type* adr_type = get_adr_type(j);
2196         if (!adr_type-&gt;isa_aryptr() || !adr_type-&gt;is_aryptr()-&gt;elem()-&gt;isa_valuetype()) {
2197           continue;
2198         }
2199         current-&gt;set_memory_at(j, mm);
2200       }
2201       current-&gt;set_memory_at(index, current-&gt;base_memory());
2202     }
2203     igvn.optimize();
2204   }
2205   print_method(PHASE_SPLIT_VALUES_ARRAY, 2);
2206 }
2207 
2208 
2209 // StringOpts and late inlining of string methods
2210 void Compile::inline_string_calls(bool parse_time) {
2211   {
2212     // remove useless nodes to make the usage analysis simpler
2213     ResourceMark rm;
2214     PhaseRemoveUseless pru(initial_gvn(), for_igvn());
2215   }
2216 
2217   {
2218     ResourceMark rm;
2219     print_method(PHASE_BEFORE_STRINGOPTS, 3);
2220     PhaseStringOpts pso(initial_gvn(), for_igvn());
2221     print_method(PHASE_AFTER_STRINGOPTS, 3);
2222   }
2223 
2224   // now inline anything that we skipped the first time around
2225   if (!parse_time) {
2226     _late_inlines_pos = _late_inlines.length();
2227   }
2228 
2229   while (_string_late_inlines.length() &gt; 0) {
2230     CallGenerator* cg = _string_late_inlines.pop();
2231     cg-&gt;do_late_inline();
2232     if (failing())  return;
2233   }
2234   _string_late_inlines.trunc_to(0);
2235 }
2236 
2237 // Late inlining of boxing methods
2238 void Compile::inline_boxing_calls(PhaseIterGVN&amp; igvn) {
2239   if (_boxing_late_inlines.length() &gt; 0) {
2240     assert(has_boxed_value(), &quot;inconsistent&quot;);
2241 
2242     PhaseGVN* gvn = initial_gvn();
2243     set_inlining_incrementally(true);
2244 
2245     assert( igvn._worklist.size() == 0, &quot;should be done with igvn&quot; );
2246     for_igvn()-&gt;clear();
2247     gvn-&gt;replace_with(&amp;igvn);
2248 
2249     _late_inlines_pos = _late_inlines.length();
2250 
2251     while (_boxing_late_inlines.length() &gt; 0) {
2252       CallGenerator* cg = _boxing_late_inlines.pop();
2253       cg-&gt;do_late_inline();
2254       if (failing())  return;
2255     }
2256     _boxing_late_inlines.trunc_to(0);
2257 
2258     inline_incrementally_cleanup(igvn);
2259 
2260     set_inlining_incrementally(false);
2261   }
2262 }
2263 
2264 bool Compile::inline_incrementally_one() {
2265   assert(IncrementalInline, &quot;incremental inlining should be on&quot;);
2266 
2267   TracePhase tp(&quot;incrementalInline_inline&quot;, &amp;timers[_t_incrInline_inline]);
2268   set_inlining_progress(false);
2269   set_do_cleanup(false);
2270   int i = 0;
2271   for (; i &lt;_late_inlines.length() &amp;&amp; !inlining_progress(); i++) {
2272     CallGenerator* cg = _late_inlines.at(i);
2273     _late_inlines_pos = i+1;
2274     cg-&gt;do_late_inline();
2275     if (failing())  return false;
2276   }
2277   int j = 0;
2278   for (; i &lt; _late_inlines.length(); i++, j++) {
2279     _late_inlines.at_put(j, _late_inlines.at(i));
2280   }
2281   _late_inlines.trunc_to(j);
2282   assert(inlining_progress() || _late_inlines.length() == 0, &quot;&quot;);
2283 
2284   bool needs_cleanup = do_cleanup() || over_inlining_cutoff();
2285 
2286   set_inlining_progress(false);
2287   set_do_cleanup(false);
2288   return (_late_inlines.length() &gt; 0) &amp;&amp; !needs_cleanup;
2289 }
2290 
2291 void Compile::inline_incrementally_cleanup(PhaseIterGVN&amp; igvn) {
2292   {
2293     TracePhase tp(&quot;incrementalInline_pru&quot;, &amp;timers[_t_incrInline_pru]);
2294     ResourceMark rm;
2295     PhaseRemoveUseless pru(initial_gvn(), for_igvn());
2296   }
2297   {
2298     TracePhase tp(&quot;incrementalInline_igvn&quot;, &amp;timers[_t_incrInline_igvn]);
2299     igvn = PhaseIterGVN(initial_gvn());
2300     igvn.optimize();
2301   }
2302 }
2303 
2304 // Perform incremental inlining until bound on number of live nodes is reached
2305 void Compile::inline_incrementally(PhaseIterGVN&amp; igvn) {
2306   TracePhase tp(&quot;incrementalInline&quot;, &amp;timers[_t_incrInline]);
2307 
2308   set_inlining_incrementally(true);
2309   uint low_live_nodes = 0;
2310 
2311   while (_late_inlines.length() &gt; 0) {
2312     if (live_nodes() &gt; (uint)LiveNodeCountInliningCutoff) {
2313       if (low_live_nodes &lt; (uint)LiveNodeCountInliningCutoff * 8 / 10) {
2314         TracePhase tp(&quot;incrementalInline_ideal&quot;, &amp;timers[_t_incrInline_ideal]);
2315         // PhaseIdealLoop is expensive so we only try it once we are
2316         // out of live nodes and we only try it again if the previous
2317         // helped got the number of nodes down significantly
2318         PhaseIdealLoop::optimize(igvn, LoopOptsNone);
2319         if (failing())  return;
2320         low_live_nodes = live_nodes();
2321         _major_progress = true;
2322       }
2323 
2324       if (live_nodes() &gt; (uint)LiveNodeCountInliningCutoff) {
2325         break; // finish
2326       }
2327     }
2328 
2329     for_igvn()-&gt;clear();
2330     initial_gvn()-&gt;replace_with(&amp;igvn);
2331 
2332     while (inline_incrementally_one()) {
2333       assert(!failing(), &quot;inconsistent&quot;);
2334     }
2335 
2336     if (failing())  return;
2337 
2338     inline_incrementally_cleanup(igvn);
2339 
2340     if (failing())  return;
2341   }
2342   assert( igvn._worklist.size() == 0, &quot;should be done with igvn&quot; );
2343 
2344   if (_string_late_inlines.length() &gt; 0) {
2345     assert(has_stringbuilder(), &quot;inconsistent&quot;);
2346     for_igvn()-&gt;clear();
2347     initial_gvn()-&gt;replace_with(&amp;igvn);
2348 
2349     inline_string_calls(false);
2350 
2351     if (failing())  return;
2352 
2353     inline_incrementally_cleanup(igvn);
2354   }
2355 
2356   set_inlining_incrementally(false);
2357 }
2358 
2359 
2360 bool Compile::optimize_loops(PhaseIterGVN&amp; igvn, LoopOptsMode mode) {
2361   if(_loop_opts_cnt &gt; 0) {
2362     debug_only( int cnt = 0; );
2363     while(major_progress() &amp;&amp; (_loop_opts_cnt &gt; 0)) {
2364       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2365       assert( cnt++ &lt; 40, &quot;infinite cycle in loop optimization&quot; );
2366       PhaseIdealLoop::optimize(igvn, mode);
2367       _loop_opts_cnt--;
2368       if (failing())  return false;
2369       if (major_progress()) print_method(PHASE_PHASEIDEALLOOP_ITERATIONS, 2);
2370     }
2371   }
2372   return true;
2373 }
2374 
2375 // Remove edges from &quot;root&quot; to each SafePoint at a backward branch.
2376 // They were inserted during parsing (see add_safepoint()) to make
2377 // infinite loops without calls or exceptions visible to root, i.e.,
2378 // useful.
2379 void Compile::remove_root_to_sfpts_edges(PhaseIterGVN&amp; igvn) {
2380   Node *r = root();
2381   if (r != NULL) {
2382     for (uint i = r-&gt;req(); i &lt; r-&gt;len(); ++i) {
2383       Node *n = r-&gt;in(i);
2384       if (n != NULL &amp;&amp; n-&gt;is_SafePoint()) {
2385         r-&gt;rm_prec(i);
2386         if (n-&gt;outcnt() == 0) {
2387           igvn.remove_dead_node(n);
2388         }
2389         --i;
2390       }
2391     }
2392     // Parsing may have added top inputs to the root node (Path
2393     // leading to the Halt node proven dead). Make sure we get a
2394     // chance to clean them up.
2395     igvn._worklist.push(r);
2396     igvn.optimize();
2397   }
2398 }
2399 
2400 //------------------------------Optimize---------------------------------------
2401 // Given a graph, optimize it.
2402 void Compile::Optimize() {
2403   TracePhase tp(&quot;optimizer&quot;, &amp;timers[_t_optimizer]);
2404 
2405 #ifndef PRODUCT
2406   if (_directive-&gt;BreakAtCompileOption) {
2407     BREAKPOINT;
2408   }
2409 
2410 #endif
2411 
2412   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
2413 #ifdef ASSERT
2414   bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeOptimize);
2415 #endif
2416 
2417   ResourceMark rm;
2418 
2419   print_inlining_reinit();
2420 
2421   NOT_PRODUCT( verify_graph_edges(); )
2422 
2423   print_method(PHASE_AFTER_PARSING);
2424 
2425  {
2426   // Iterative Global Value Numbering, including ideal transforms
2427   // Initialize IterGVN with types and values from parse-time GVN
2428   PhaseIterGVN igvn(initial_gvn());
2429 #ifdef ASSERT
2430   _modified_nodes = new (comp_arena()) Unique_Node_List(comp_arena());
2431 #endif
2432   {
2433     TracePhase tp(&quot;iterGVN&quot;, &amp;timers[_t_iterGVN]);
2434     igvn.optimize();
2435   }
2436 
2437   if (failing())  return;
2438 
2439   print_method(PHASE_ITER_GVN1, 2);
2440 
2441   inline_incrementally(igvn);
2442 
2443   print_method(PHASE_INCREMENTAL_INLINE, 2);
2444 
2445   if (failing())  return;
2446 
2447   if (eliminate_boxing()) {
2448     // Inline valueOf() methods now.
2449     inline_boxing_calls(igvn);
2450 
2451     if (AlwaysIncrementalInline) {
2452       inline_incrementally(igvn);
2453     }
2454 
2455     print_method(PHASE_INCREMENTAL_BOXING_INLINE, 2);
2456 
2457     if (failing())  return;
2458   }
2459 
2460   // Now that all inlining is over, cut edge from root to loop
2461   // safepoints
2462   remove_root_to_sfpts_edges(igvn);
2463 
2464   // Remove the speculative part of types and clean up the graph from
2465   // the extra CastPP nodes whose only purpose is to carry them. Do
2466   // that early so that optimizations are not disrupted by the extra
2467   // CastPP nodes.
2468   remove_speculative_types(igvn);
2469 
2470   // No more new expensive nodes will be added to the list from here
2471   // so keep only the actual candidates for optimizations.
2472   cleanup_expensive_nodes(igvn);
2473 
2474   if (!failing() &amp;&amp; RenumberLiveNodes &amp;&amp; live_nodes() + NodeLimitFudgeFactor &lt; unique()) {
2475     Compile::TracePhase tp(&quot;&quot;, &amp;timers[_t_renumberLive]);
2476     initial_gvn()-&gt;replace_with(&amp;igvn);
2477     for_igvn()-&gt;clear();
2478     Unique_Node_List new_worklist(C-&gt;comp_arena());
2479     {
2480       ResourceMark rm;
2481       PhaseRenumberLive prl = PhaseRenumberLive(initial_gvn(), for_igvn(), &amp;new_worklist);
2482     }
2483     set_for_igvn(&amp;new_worklist);
2484     igvn = PhaseIterGVN(initial_gvn());
2485     igvn.optimize();
2486   }
2487 
2488   if (_value_type_nodes-&gt;size() &gt; 0) {
2489     // Do this once all inlining is over to avoid getting inconsistent debug info
2490     process_value_types(igvn);
2491   }
2492 
2493   adjust_flattened_array_access_aliases(igvn);
2494 
2495   // Perform escape analysis
2496   if (_do_escape_analysis &amp;&amp; ConnectionGraph::has_candidates(this)) {
2497     if (has_loops()) {
2498       // Cleanup graph (remove dead nodes).
2499       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2500       PhaseIdealLoop::optimize(igvn, LoopOptsMaxUnroll);
2501       if (major_progress()) print_method(PHASE_PHASEIDEAL_BEFORE_EA, 2);
2502       if (failing())  return;
2503     }
2504     ConnectionGraph::do_analysis(this, &amp;igvn);
2505 
2506     if (failing())  return;
2507 
2508     // Optimize out fields loads from scalar replaceable allocations.
2509     igvn.optimize();
2510     print_method(PHASE_ITER_GVN_AFTER_EA, 2);
2511 
2512     if (failing())  return;
2513 
2514     if (congraph() != NULL &amp;&amp; macro_count() &gt; 0) {
2515       TracePhase tp(&quot;macroEliminate&quot;, &amp;timers[_t_macroEliminate]);
2516       PhaseMacroExpand mexp(igvn);
2517       mexp.eliminate_macro_nodes();
2518       igvn.set_delay_transform(false);
2519 
2520       igvn.optimize();
2521       print_method(PHASE_ITER_GVN_AFTER_ELIMINATION, 2);
2522 
2523       if (failing())  return;
2524     }
2525   }
2526 
2527   // Loop transforms on the ideal graph.  Range Check Elimination,
2528   // peeling, unrolling, etc.
2529 
2530   // Set loop opts counter
2531   if((_loop_opts_cnt &gt; 0) &amp;&amp; (has_loops() || has_split_ifs())) {
2532     {
2533       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2534       PhaseIdealLoop::optimize(igvn, LoopOptsDefault);
2535       _loop_opts_cnt--;
2536       if (major_progress()) print_method(PHASE_PHASEIDEALLOOP1, 2);
2537       if (failing())  return;
2538     }
2539     // Loop opts pass if partial peeling occurred in previous pass
2540     if(PartialPeelLoop &amp;&amp; major_progress() &amp;&amp; (_loop_opts_cnt &gt; 0)) {
2541       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2542       PhaseIdealLoop::optimize(igvn, LoopOptsSkipSplitIf);
2543       _loop_opts_cnt--;
2544       if (major_progress()) print_method(PHASE_PHASEIDEALLOOP2, 2);
2545       if (failing())  return;
2546     }
2547     // Loop opts pass for loop-unrolling before CCP
2548     if(major_progress() &amp;&amp; (_loop_opts_cnt &gt; 0)) {
2549       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2550       PhaseIdealLoop::optimize(igvn, LoopOptsSkipSplitIf);
2551       _loop_opts_cnt--;
2552       if (major_progress()) print_method(PHASE_PHASEIDEALLOOP3, 2);
2553     }
2554     if (!failing()) {
2555       // Verify that last round of loop opts produced a valid graph
2556       TracePhase tp(&quot;idealLoopVerify&quot;, &amp;timers[_t_idealLoopVerify]);
2557       PhaseIdealLoop::verify(igvn);
2558     }
2559   }
2560   if (failing())  return;
2561 
2562   // Conditional Constant Propagation;
2563   PhaseCCP ccp( &amp;igvn );
2564   assert( true, &quot;Break here to ccp.dump_nodes_and_types(_root,999,1)&quot;);
2565   {
2566     TracePhase tp(&quot;ccp&quot;, &amp;timers[_t_ccp]);
2567     ccp.do_transform();
2568   }
2569   print_method(PHASE_CPP1, 2);
2570 
2571   assert( true, &quot;Break here to ccp.dump_old2new_map()&quot;);
2572 
2573   // Iterative Global Value Numbering, including ideal transforms
2574   {
2575     TracePhase tp(&quot;iterGVN2&quot;, &amp;timers[_t_iterGVN2]);
2576     igvn = ccp;
2577     igvn.optimize();
2578   }
2579   print_method(PHASE_ITER_GVN2, 2);
2580 
2581   if (failing())  return;
2582 
2583   // Loop transforms on the ideal graph.  Range Check Elimination,
2584   // peeling, unrolling, etc.
2585   if (!optimize_loops(igvn, LoopOptsDefault)) {
2586     return;
2587   }
2588 
2589   if (failing())  return;
2590 
2591   // Ensure that major progress is now clear
2592   C-&gt;clear_major_progress();
2593 
2594   {
2595     // Verify that all previous optimizations produced a valid graph
2596     // at least to this point, even if no loop optimizations were done.
2597     TracePhase tp(&quot;idealLoopVerify&quot;, &amp;timers[_t_idealLoopVerify]);
2598     PhaseIdealLoop::verify(igvn);
2599   }
2600 
2601   if (range_check_cast_count() &gt; 0) {
2602     // No more loop optimizations. Remove all range check dependent CastIINodes.
2603     C-&gt;remove_range_check_casts(igvn);
2604     igvn.optimize();
2605   }
2606 
2607 #ifdef ASSERT
2608   bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeMacroExpand);
2609 #endif
2610 
2611   {
2612     TracePhase tp(&quot;macroExpand&quot;, &amp;timers[_t_macroExpand]);
2613     PhaseMacroExpand  mex(igvn);
2614     if (mex.expand_macro_nodes()) {
2615       assert(failing(), &quot;must bail out w/ explicit message&quot;);
2616       return;
2617     }
2618     print_method(PHASE_MACRO_EXPANSION, 2);
2619   }
2620 
2621   {
2622     TracePhase tp(&quot;barrierExpand&quot;, &amp;timers[_t_barrierExpand]);
2623     if (bs-&gt;expand_barriers(this, igvn)) {
2624       assert(failing(), &quot;must bail out w/ explicit message&quot;);
2625       return;
2626     }
2627     print_method(PHASE_BARRIER_EXPANSION, 2);
2628   }
2629 
2630   if (opaque4_count() &gt; 0) {
2631     C-&gt;remove_opaque4_nodes(igvn);
2632     igvn.optimize();
2633   }
2634 
2635   DEBUG_ONLY( _modified_nodes = NULL; )
2636  } // (End scope of igvn; run destructor if necessary for asserts.)
2637 
2638  process_print_inlining();
2639  // A method with only infinite loops has no edges entering loops from root
2640  {
2641    TracePhase tp(&quot;graphReshape&quot;, &amp;timers[_t_graphReshaping]);
2642    if (final_graph_reshaping()) {
2643      assert(failing(), &quot;must bail out w/ explicit message&quot;);
2644      return;
2645    }
2646  }
2647 
2648  print_method(PHASE_OPTIMIZE_FINISHED, 2);
2649 }
2650 
2651 //------------------------------Code_Gen---------------------------------------
2652 // Given a graph, generate code for it
2653 void Compile::Code_Gen() {
2654   if (failing()) {
2655     return;
2656   }
2657 
2658   // Perform instruction selection.  You might think we could reclaim Matcher
2659   // memory PDQ, but actually the Matcher is used in generating spill code.
2660   // Internals of the Matcher (including some VectorSets) must remain live
2661   // for awhile - thus I cannot reclaim Matcher memory lest a VectorSet usage
2662   // set a bit in reclaimed memory.
2663 
2664   // In debug mode can dump m._nodes.dump() for mapping of ideal to machine
2665   // nodes.  Mapping is only valid at the root of each matched subtree.
2666   NOT_PRODUCT( verify_graph_edges(); )
2667 
2668   Matcher matcher;
2669   _matcher = &amp;matcher;
2670   {
2671     TracePhase tp(&quot;matcher&quot;, &amp;timers[_t_matcher]);
2672     matcher.match();
2673     if (failing()) {
2674       return;
2675     }
2676   }
2677 
2678   // In debug mode can dump m._nodes.dump() for mapping of ideal to machine
2679   // nodes.  Mapping is only valid at the root of each matched subtree.
2680   NOT_PRODUCT( verify_graph_edges(); )
2681 
2682   // If you have too many nodes, or if matching has failed, bail out
2683   check_node_count(0, &quot;out of nodes matching instructions&quot;);
2684   if (failing()) {
2685     return;
2686   }
2687 
2688   print_method(PHASE_MATCHING, 2);
2689 
2690   // Build a proper-looking CFG
2691   PhaseCFG cfg(node_arena(), root(), matcher);
2692   _cfg = &amp;cfg;
2693   {
2694     TracePhase tp(&quot;scheduler&quot;, &amp;timers[_t_scheduler]);
2695     bool success = cfg.do_global_code_motion();
2696     if (!success) {
2697       return;
2698     }
2699 
2700     print_method(PHASE_GLOBAL_CODE_MOTION, 2);
2701     NOT_PRODUCT( verify_graph_edges(); )
2702     debug_only( cfg.verify(); )
2703   }
2704 
2705   PhaseChaitin regalloc(unique(), cfg, matcher, false);
2706   _regalloc = &amp;regalloc;
2707   {
2708     TracePhase tp(&quot;regalloc&quot;, &amp;timers[_t_registerAllocation]);
2709     // Perform register allocation.  After Chaitin, use-def chains are
2710     // no longer accurate (at spill code) and so must be ignored.
2711     // Node-&gt;LRG-&gt;reg mappings are still accurate.
2712     _regalloc-&gt;Register_Allocate();
2713 
2714     // Bail out if the allocator builds too many nodes
2715     if (failing()) {
2716       return;
2717     }
2718   }
2719 
2720   // Prior to register allocation we kept empty basic blocks in case the
2721   // the allocator needed a place to spill.  After register allocation we
2722   // are not adding any new instructions.  If any basic block is empty, we
2723   // can now safely remove it.
2724   {
2725     TracePhase tp(&quot;blockOrdering&quot;, &amp;timers[_t_blockOrdering]);
2726     cfg.remove_empty_blocks();
2727     if (do_freq_based_layout()) {
2728       PhaseBlockLayout layout(cfg);
2729     } else {
2730       cfg.set_loop_alignment();
2731     }
2732     cfg.fixup_flow();
2733   }
2734 
2735   // Apply peephole optimizations
2736   if( OptoPeephole ) {
2737     TracePhase tp(&quot;peephole&quot;, &amp;timers[_t_peephole]);
2738     PhasePeephole peep( _regalloc, cfg);
2739     peep.do_transform();
2740   }
2741 
2742   // Do late expand if CPU requires this.
2743   if (Matcher::require_postalloc_expand) {
2744     TracePhase tp(&quot;postalloc_expand&quot;, &amp;timers[_t_postalloc_expand]);
2745     cfg.postalloc_expand(_regalloc);
2746   }
2747 
2748   // Convert Nodes to instruction bits in a buffer
2749   {
<a name="21" id="anc21"></a><span class="line-modified">2750     TracePhase tp(&quot;output&quot;, &amp;timers[_t_output]);</span>
<span class="line-modified">2751     PhaseOutput output;</span>
<span class="line-added">2752     output.Output();</span>
<span class="line-added">2753     if (failing())  return;</span>
<span class="line-added">2754     output.install();</span>
2755   }
2756 
2757   print_method(PHASE_FINAL_CODE);
2758 
2759   // He&#39;s dead, Jim.
2760   _cfg     = (PhaseCFG*)((intptr_t)0xdeadbeef);
2761   _regalloc = (PhaseChaitin*)((intptr_t)0xdeadbeef);
2762 }
2763 
<a name="22" id="anc22"></a>








































































































































2764 //------------------------------Final_Reshape_Counts---------------------------
2765 // This class defines counters to help identify when a method
2766 // may/must be executed using hardware with only 24-bit precision.
2767 struct Final_Reshape_Counts : public StackObj {
2768   int  _call_count;             // count non-inlined &#39;common&#39; calls
2769   int  _float_count;            // count float ops requiring 24-bit precision
2770   int  _double_count;           // count double ops requiring more precision
2771   int  _java_call_count;        // count non-inlined &#39;java&#39; calls
2772   int  _inner_loop_count;       // count loops which need alignment
2773   VectorSet _visited;           // Visitation flags
2774   Node_List _tests;             // Set of IfNodes &amp; PCTableNodes
2775 
2776   Final_Reshape_Counts() :
2777     _call_count(0), _float_count(0), _double_count(0),
2778     _java_call_count(0), _inner_loop_count(0),
2779     _visited( Thread::current()-&gt;resource_area() ) { }
2780 
2781   void inc_call_count  () { _call_count  ++; }
2782   void inc_float_count () { _float_count ++; }
2783   void inc_double_count() { _double_count++; }
2784   void inc_java_call_count() { _java_call_count++; }
2785   void inc_inner_loop_count() { _inner_loop_count++; }
2786 
2787   int  get_call_count  () const { return _call_count  ; }
2788   int  get_float_count () const { return _float_count ; }
2789   int  get_double_count() const { return _double_count; }
2790   int  get_java_call_count() const { return _java_call_count; }
2791   int  get_inner_loop_count() const { return _inner_loop_count; }
2792 };
2793 
2794 #ifdef ASSERT
2795 static bool oop_offset_is_sane(const TypeInstPtr* tp) {
2796   ciInstanceKlass *k = tp-&gt;klass()-&gt;as_instance_klass();
2797   // Make sure the offset goes inside the instance layout.
2798   return k-&gt;contains_field_offset(tp-&gt;offset());
2799   // Note that OffsetBot and OffsetTop are very negative.
2800 }
2801 #endif
2802 
2803 // Eliminate trivially redundant StoreCMs and accumulate their
2804 // precedence edges.
2805 void Compile::eliminate_redundant_card_marks(Node* n) {
2806   assert(n-&gt;Opcode() == Op_StoreCM, &quot;expected StoreCM&quot;);
2807   if (n-&gt;in(MemNode::Address)-&gt;outcnt() &gt; 1) {
2808     // There are multiple users of the same address so it might be
2809     // possible to eliminate some of the StoreCMs
2810     Node* mem = n-&gt;in(MemNode::Memory);
2811     Node* adr = n-&gt;in(MemNode::Address);
2812     Node* val = n-&gt;in(MemNode::ValueIn);
2813     Node* prev = n;
2814     bool done = false;
2815     // Walk the chain of StoreCMs eliminating ones that match.  As
2816     // long as it&#39;s a chain of single users then the optimization is
2817     // safe.  Eliminating partially redundant StoreCMs would require
2818     // cloning copies down the other paths.
2819     while (mem-&gt;Opcode() == Op_StoreCM &amp;&amp; mem-&gt;outcnt() == 1 &amp;&amp; !done) {
2820       if (adr == mem-&gt;in(MemNode::Address) &amp;&amp;
2821           val == mem-&gt;in(MemNode::ValueIn)) {
2822         // redundant StoreCM
2823         if (mem-&gt;req() &gt; MemNode::OopStore) {
2824           // Hasn&#39;t been processed by this code yet.
2825           n-&gt;add_prec(mem-&gt;in(MemNode::OopStore));
2826         } else {
2827           // Already converted to precedence edge
2828           for (uint i = mem-&gt;req(); i &lt; mem-&gt;len(); i++) {
2829             // Accumulate any precedence edges
2830             if (mem-&gt;in(i) != NULL) {
2831               n-&gt;add_prec(mem-&gt;in(i));
2832             }
2833           }
2834           // Everything above this point has been processed.
2835           done = true;
2836         }
2837         // Eliminate the previous StoreCM
2838         prev-&gt;set_req(MemNode::Memory, mem-&gt;in(MemNode::Memory));
2839         assert(mem-&gt;outcnt() == 0, &quot;should be dead&quot;);
2840         mem-&gt;disconnect_inputs(NULL, this);
2841       } else {
2842         prev = mem;
2843       }
2844       mem = prev-&gt;in(MemNode::Memory);
2845     }
2846   }
2847 }
2848 
2849 
2850 //------------------------------final_graph_reshaping_impl----------------------
2851 // Implement items 1-5 from final_graph_reshaping below.
2852 void Compile::final_graph_reshaping_impl( Node *n, Final_Reshape_Counts &amp;frc) {
2853 
2854   if ( n-&gt;outcnt() == 0 ) return; // dead node
2855   uint nop = n-&gt;Opcode();
2856 
2857   // Check for 2-input instruction with &quot;last use&quot; on right input.
2858   // Swap to left input.  Implements item (2).
2859   if( n-&gt;req() == 3 &amp;&amp;          // two-input instruction
2860       n-&gt;in(1)-&gt;outcnt() &gt; 1 &amp;&amp; // left use is NOT a last use
2861       (!n-&gt;in(1)-&gt;is_Phi() || n-&gt;in(1)-&gt;in(2) != n) &amp;&amp; // it is not data loop
2862       n-&gt;in(2)-&gt;outcnt() == 1 &amp;&amp;// right use IS a last use
2863       !n-&gt;in(2)-&gt;is_Con() ) {   // right use is not a constant
2864     // Check for commutative opcode
2865     switch( nop ) {
2866     case Op_AddI:  case Op_AddF:  case Op_AddD:  case Op_AddL:
2867     case Op_MaxI:  case Op_MinI:
2868     case Op_MulI:  case Op_MulF:  case Op_MulD:  case Op_MulL:
2869     case Op_AndL:  case Op_XorL:  case Op_OrL:
2870     case Op_AndI:  case Op_XorI:  case Op_OrI: {
2871       // Move &quot;last use&quot; input to left by swapping inputs
2872       n-&gt;swap_edges(1, 2);
2873       break;
2874     }
2875     default:
2876       break;
2877     }
2878   }
2879 
2880 #ifdef ASSERT
2881   if( n-&gt;is_Mem() ) {
2882     int alias_idx = get_alias_index(n-&gt;as_Mem()-&gt;adr_type());
2883     assert( n-&gt;in(0) != NULL || alias_idx != Compile::AliasIdxRaw ||
2884             // oop will be recorded in oop map if load crosses safepoint
2885             n-&gt;is_Load() &amp;&amp; (n-&gt;as_Load()-&gt;bottom_type()-&gt;isa_oopptr() ||
2886                              LoadNode::is_immutable_value(n-&gt;in(MemNode::Address))),
2887             &quot;raw memory operations should have control edge&quot;);
2888   }
2889   if (n-&gt;is_MemBar()) {
2890     MemBarNode* mb = n-&gt;as_MemBar();
2891     if (mb-&gt;trailing_store() || mb-&gt;trailing_load_store()) {
2892       assert(mb-&gt;leading_membar()-&gt;trailing_membar() == mb, &quot;bad membar pair&quot;);
2893       Node* mem = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;step_over_gc_barrier(mb-&gt;in(MemBarNode::Precedent));
2894       assert((mb-&gt;trailing_store() &amp;&amp; mem-&gt;is_Store() &amp;&amp; mem-&gt;as_Store()-&gt;is_release()) ||
2895              (mb-&gt;trailing_load_store() &amp;&amp; mem-&gt;is_LoadStore()), &quot;missing mem op&quot;);
2896     } else if (mb-&gt;leading()) {
2897       assert(mb-&gt;trailing_membar()-&gt;leading_membar() == mb, &quot;bad membar pair&quot;);
2898     }
2899   }
2900 #endif
2901   // Count FPU ops and common calls, implements item (3)
2902   bool gc_handled = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;final_graph_reshaping(this, n, nop);
2903   if (!gc_handled) {
2904     final_graph_reshaping_main_switch(n, frc, nop);
2905   }
2906 
2907   // Collect CFG split points
2908   if (n-&gt;is_MultiBranch() &amp;&amp; !n-&gt;is_RangeCheck()) {
2909     frc._tests.push(n);
2910   }
2911 }
2912 
2913 void Compile::final_graph_reshaping_main_switch(Node* n, Final_Reshape_Counts&amp; frc, uint nop) {
2914   switch( nop ) {
2915   // Count all float operations that may use FPU
2916   case Op_AddF:
2917   case Op_SubF:
2918   case Op_MulF:
2919   case Op_DivF:
2920   case Op_NegF:
2921   case Op_ModF:
2922   case Op_ConvI2F:
2923   case Op_ConF:
2924   case Op_CmpF:
2925   case Op_CmpF3:
2926   // case Op_ConvL2F: // longs are split into 32-bit halves
2927     frc.inc_float_count();
2928     break;
2929 
2930   case Op_ConvF2D:
2931   case Op_ConvD2F:
2932     frc.inc_float_count();
2933     frc.inc_double_count();
2934     break;
2935 
2936   // Count all double operations that may use FPU
2937   case Op_AddD:
2938   case Op_SubD:
2939   case Op_MulD:
2940   case Op_DivD:
2941   case Op_NegD:
2942   case Op_ModD:
2943   case Op_ConvI2D:
2944   case Op_ConvD2I:
2945   // case Op_ConvL2D: // handled by leaf call
2946   // case Op_ConvD2L: // handled by leaf call
2947   case Op_ConD:
2948   case Op_CmpD:
2949   case Op_CmpD3:
2950     frc.inc_double_count();
2951     break;
2952   case Op_Opaque1:              // Remove Opaque Nodes before matching
2953   case Op_Opaque2:              // Remove Opaque Nodes before matching
2954   case Op_Opaque3:
2955     n-&gt;subsume_by(n-&gt;in(1), this);
2956     break;
2957   case Op_CallStaticJava:
2958   case Op_CallJava:
2959   case Op_CallDynamicJava:
2960     frc.inc_java_call_count(); // Count java call site;
2961   case Op_CallRuntime:
2962   case Op_CallLeaf:
2963   case Op_CallLeafNoFP: {
2964     assert (n-&gt;is_Call(), &quot;&quot;);
2965     CallNode *call = n-&gt;as_Call();
2966     // Count call sites where the FP mode bit would have to be flipped.
2967     // Do not count uncommon runtime calls:
2968     // uncommon_trap, _complete_monitor_locking, _complete_monitor_unlocking,
2969     // _new_Java, _new_typeArray, _new_objArray, _rethrow_Java, ...
2970     if (!call-&gt;is_CallStaticJava() || !call-&gt;as_CallStaticJava()-&gt;_name) {
2971       frc.inc_call_count();   // Count the call site
2972     } else {                  // See if uncommon argument is shared
2973       Node *n = call-&gt;in(TypeFunc::Parms);
2974       int nop = n-&gt;Opcode();
2975       // Clone shared simple arguments to uncommon calls, item (1).
2976       if (n-&gt;outcnt() &gt; 1 &amp;&amp;
2977           !n-&gt;is_Proj() &amp;&amp;
2978           nop != Op_CreateEx &amp;&amp;
2979           nop != Op_CheckCastPP &amp;&amp;
2980           nop != Op_DecodeN &amp;&amp;
2981           nop != Op_DecodeNKlass &amp;&amp;
2982           !n-&gt;is_Mem() &amp;&amp;
2983           !n-&gt;is_Phi()) {
2984         Node *x = n-&gt;clone();
2985         call-&gt;set_req(TypeFunc::Parms, x);
2986       }
2987     }
2988     break;
2989   }
2990 
2991   case Op_StoreD:
2992   case Op_LoadD:
2993   case Op_LoadD_unaligned:
2994     frc.inc_double_count();
2995     goto handle_mem;
2996   case Op_StoreF:
2997   case Op_LoadF:
2998     frc.inc_float_count();
2999     goto handle_mem;
3000 
3001   case Op_StoreCM:
3002     {
3003       // Convert OopStore dependence into precedence edge
3004       Node* prec = n-&gt;in(MemNode::OopStore);
3005       n-&gt;del_req(MemNode::OopStore);
3006       n-&gt;add_prec(prec);
3007       eliminate_redundant_card_marks(n);
3008     }
3009 
3010     // fall through
3011 
3012   case Op_StoreB:
3013   case Op_StoreC:
3014   case Op_StorePConditional:
3015   case Op_StoreI:
3016   case Op_StoreL:
3017   case Op_StoreIConditional:
3018   case Op_StoreLConditional:
3019   case Op_CompareAndSwapB:
3020   case Op_CompareAndSwapS:
3021   case Op_CompareAndSwapI:
3022   case Op_CompareAndSwapL:
3023   case Op_CompareAndSwapP:
3024   case Op_CompareAndSwapN:
3025   case Op_WeakCompareAndSwapB:
3026   case Op_WeakCompareAndSwapS:
3027   case Op_WeakCompareAndSwapI:
3028   case Op_WeakCompareAndSwapL:
3029   case Op_WeakCompareAndSwapP:
3030   case Op_WeakCompareAndSwapN:
3031   case Op_CompareAndExchangeB:
3032   case Op_CompareAndExchangeS:
3033   case Op_CompareAndExchangeI:
3034   case Op_CompareAndExchangeL:
3035   case Op_CompareAndExchangeP:
3036   case Op_CompareAndExchangeN:
3037   case Op_GetAndAddS:
3038   case Op_GetAndAddB:
3039   case Op_GetAndAddI:
3040   case Op_GetAndAddL:
3041   case Op_GetAndSetS:
3042   case Op_GetAndSetB:
3043   case Op_GetAndSetI:
3044   case Op_GetAndSetL:
3045   case Op_GetAndSetP:
3046   case Op_GetAndSetN:
3047   case Op_StoreP:
3048   case Op_StoreN:
3049   case Op_StoreNKlass:
3050   case Op_LoadB:
3051   case Op_LoadUB:
3052   case Op_LoadUS:
3053   case Op_LoadI:
3054   case Op_LoadKlass:
3055   case Op_LoadNKlass:
3056   case Op_LoadL:
3057   case Op_LoadL_unaligned:
3058   case Op_LoadPLocked:
3059   case Op_LoadP:
3060   case Op_LoadN:
3061   case Op_LoadRange:
3062   case Op_LoadS: {
3063   handle_mem:
3064 #ifdef ASSERT
3065     if( VerifyOptoOopOffsets ) {
3066       MemNode* mem  = n-&gt;as_Mem();
3067       // Check to see if address types have grounded out somehow.
3068       const TypeInstPtr *tp = mem-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;isa_instptr();
3069       assert( !tp || oop_offset_is_sane(tp), &quot;&quot; );
3070     }
3071 #endif
3072     if (EnableValhalla &amp;&amp;
3073         ((nop == Op_LoadKlass &amp;&amp; ((LoadKlassNode*)n)-&gt;clear_prop_bits()) ||
3074          (nop == Op_LoadNKlass &amp;&amp; ((LoadNKlassNode*)n)-&gt;clear_prop_bits()))) {
3075       const TypeKlassPtr* tk = n-&gt;bottom_type()-&gt;make_ptr()-&gt;is_klassptr();
3076       assert(!tk-&gt;klass_is_exact(), &quot;should have been folded&quot;);
3077       assert(n-&gt;as_Mem()-&gt;adr_type()-&gt;offset() == oopDesc::klass_offset_in_bytes(), &quot;unexpected LoadKlass&quot;);
3078       if (tk-&gt;klass()-&gt;can_be_value_array_klass()) {
3079         // Array load klass needs to filter out property bits (but not
3080         // GetNullFreePropertyNode or GetFlattenedPropertyNode which
3081         // needs to extract the storage property bits)
3082         uint last = unique();
3083         Node* pointer = NULL;
3084         if (nop == Op_LoadKlass) {
3085           Node* cast = new CastP2XNode(NULL, n);
3086           Node* masked = new LShiftXNode(cast, new ConINode(TypeInt::make(oopDesc::storage_props_nof_bits)));
3087           masked = new RShiftXNode(masked, new ConINode(TypeInt::make(oopDesc::storage_props_nof_bits)));
3088           pointer = new CastX2PNode(masked);
3089           pointer = new CheckCastPPNode(NULL, pointer, n-&gt;bottom_type());
3090         } else {
3091           Node* cast = new CastN2INode(n);
3092           Node* masked = new AndINode(cast, new ConINode(TypeInt::make(oopDesc::compressed_klass_mask())));
3093           pointer = new CastI2NNode(masked, n-&gt;bottom_type());
3094         }
3095         for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3096           Node* u = n-&gt;fast_out(i);
3097           if (u-&gt;_idx &lt; last &amp;&amp; u-&gt;Opcode() != Op_GetNullFreeProperty &amp;&amp; u-&gt;Opcode() != Op_GetFlattenedProperty) {
3098             // If user is a comparison with a klass that can&#39;t be a value type
3099             // array klass, we don&#39;t need to clear the storage property bits.
3100             Node* cmp = (u-&gt;is_DecodeNKlass() &amp;&amp; u-&gt;outcnt() == 1) ? u-&gt;unique_out() : u;
3101             if (cmp-&gt;is_Cmp()) {
3102               const TypeKlassPtr* kp1 = cmp-&gt;in(1)-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_klassptr();
3103               const TypeKlassPtr* kp2 = cmp-&gt;in(2)-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_klassptr();
3104               if ((kp1 != NULL &amp;&amp; !kp1-&gt;klass()-&gt;can_be_value_array_klass()) ||
3105                   (kp2 != NULL &amp;&amp; !kp2-&gt;klass()-&gt;can_be_value_array_klass())) {
3106                 continue;
3107               }
3108             }
3109             int nb = u-&gt;replace_edge(n, pointer);
3110             --i, imax -= nb;
3111           }
3112         }
3113       }
3114     }
3115     break;
3116   }
3117 
3118   case Op_AddP: {               // Assert sane base pointers
3119     Node *addp = n-&gt;in(AddPNode::Address);
3120     assert( !addp-&gt;is_AddP() ||
3121             addp-&gt;in(AddPNode::Base)-&gt;is_top() || // Top OK for allocation
3122             addp-&gt;in(AddPNode::Base) == n-&gt;in(AddPNode::Base),
3123             &quot;Base pointers must match (addp %u)&quot;, addp-&gt;_idx );
3124 #ifdef _LP64
3125     if ((UseCompressedOops || UseCompressedClassPointers) &amp;&amp;
3126         addp-&gt;Opcode() == Op_ConP &amp;&amp;
3127         addp == n-&gt;in(AddPNode::Base) &amp;&amp;
3128         n-&gt;in(AddPNode::Offset)-&gt;is_Con()) {
3129       // If the transformation of ConP to ConN+DecodeN is beneficial depends
3130       // on the platform and on the compressed oops mode.
3131       // Use addressing with narrow klass to load with offset on x86.
3132       // Some platforms can use the constant pool to load ConP.
3133       // Do this transformation here since IGVN will convert ConN back to ConP.
3134       const Type* t = addp-&gt;bottom_type();
3135       bool is_oop   = t-&gt;isa_oopptr() != NULL;
3136       bool is_klass = t-&gt;isa_klassptr() != NULL;
3137 
3138       if ((is_oop   &amp;&amp; Matcher::const_oop_prefer_decode()  ) ||
3139           (is_klass &amp;&amp; Matcher::const_klass_prefer_decode())) {
3140         Node* nn = NULL;
3141 
3142         int op = is_oop ? Op_ConN : Op_ConNKlass;
3143 
3144         // Look for existing ConN node of the same exact type.
3145         Node* r  = root();
3146         uint cnt = r-&gt;outcnt();
3147         for (uint i = 0; i &lt; cnt; i++) {
3148           Node* m = r-&gt;raw_out(i);
3149           if (m!= NULL &amp;&amp; m-&gt;Opcode() == op &amp;&amp;
3150               m-&gt;bottom_type()-&gt;make_ptr() == t) {
3151             nn = m;
3152             break;
3153           }
3154         }
3155         if (nn != NULL) {
3156           // Decode a narrow oop to match address
3157           // [R12 + narrow_oop_reg&lt;&lt;3 + offset]
3158           if (is_oop) {
3159             nn = new DecodeNNode(nn, t);
3160           } else {
3161             nn = new DecodeNKlassNode(nn, t);
3162           }
3163           // Check for succeeding AddP which uses the same Base.
3164           // Otherwise we will run into the assertion above when visiting that guy.
3165           for (uint i = 0; i &lt; n-&gt;outcnt(); ++i) {
3166             Node *out_i = n-&gt;raw_out(i);
3167             if (out_i &amp;&amp; out_i-&gt;is_AddP() &amp;&amp; out_i-&gt;in(AddPNode::Base) == addp) {
3168               out_i-&gt;set_req(AddPNode::Base, nn);
3169 #ifdef ASSERT
3170               for (uint j = 0; j &lt; out_i-&gt;outcnt(); ++j) {
3171                 Node *out_j = out_i-&gt;raw_out(j);
3172                 assert(out_j == NULL || !out_j-&gt;is_AddP() || out_j-&gt;in(AddPNode::Base) != addp,
3173                        &quot;more than 2 AddP nodes in a chain (out_j %u)&quot;, out_j-&gt;_idx);
3174               }
3175 #endif
3176             }
3177           }
3178           n-&gt;set_req(AddPNode::Base, nn);
3179           n-&gt;set_req(AddPNode::Address, nn);
3180           if (addp-&gt;outcnt() == 0) {
3181             addp-&gt;disconnect_inputs(NULL, this);
3182           }
3183         }
3184       }
3185     }
3186 #endif
3187     // platform dependent reshaping of the address expression
3188     reshape_address(n-&gt;as_AddP());
3189     break;
3190   }
3191 
3192   case Op_CastPP: {
3193     // Remove CastPP nodes to gain more freedom during scheduling but
3194     // keep the dependency they encode as control or precedence edges
3195     // (if control is set already) on memory operations. Some CastPP
3196     // nodes don&#39;t have a control (don&#39;t carry a dependency): skip
3197     // those.
3198     if (n-&gt;in(0) != NULL) {
3199       ResourceMark rm;
3200       Unique_Node_List wq;
3201       wq.push(n);
3202       for (uint next = 0; next &lt; wq.size(); ++next) {
3203         Node *m = wq.at(next);
3204         for (DUIterator_Fast imax, i = m-&gt;fast_outs(imax); i &lt; imax; i++) {
3205           Node* use = m-&gt;fast_out(i);
3206           if (use-&gt;is_Mem() || use-&gt;is_EncodeNarrowPtr()) {
3207             use-&gt;ensure_control_or_add_prec(n-&gt;in(0));
3208           } else {
3209             switch(use-&gt;Opcode()) {
3210             case Op_AddP:
3211             case Op_DecodeN:
3212             case Op_DecodeNKlass:
3213             case Op_CheckCastPP:
3214             case Op_CastPP:
3215               wq.push(use);
3216               break;
3217             }
3218           }
3219         }
3220       }
3221     }
3222     const bool is_LP64 = LP64_ONLY(true) NOT_LP64(false);
3223     if (is_LP64 &amp;&amp; n-&gt;in(1)-&gt;is_DecodeN() &amp;&amp; Matcher::gen_narrow_oop_implicit_null_checks()) {
3224       Node* in1 = n-&gt;in(1);
3225       const Type* t = n-&gt;bottom_type();
3226       Node* new_in1 = in1-&gt;clone();
3227       new_in1-&gt;as_DecodeN()-&gt;set_type(t);
3228 
3229       if (!Matcher::narrow_oop_use_complex_address()) {
3230         //
3231         // x86, ARM and friends can handle 2 adds in addressing mode
3232         // and Matcher can fold a DecodeN node into address by using
3233         // a narrow oop directly and do implicit NULL check in address:
3234         //
3235         // [R12 + narrow_oop_reg&lt;&lt;3 + offset]
3236         // NullCheck narrow_oop_reg
3237         //
3238         // On other platforms (Sparc) we have to keep new DecodeN node and
3239         // use it to do implicit NULL check in address:
3240         //
3241         // decode_not_null narrow_oop_reg, base_reg
3242         // [base_reg + offset]
3243         // NullCheck base_reg
3244         //
3245         // Pin the new DecodeN node to non-null path on these platform (Sparc)
3246         // to keep the information to which NULL check the new DecodeN node
3247         // corresponds to use it as value in implicit_null_check().
3248         //
3249         new_in1-&gt;set_req(0, n-&gt;in(0));
3250       }
3251 
3252       n-&gt;subsume_by(new_in1, this);
3253       if (in1-&gt;outcnt() == 0) {
3254         in1-&gt;disconnect_inputs(NULL, this);
3255       }
3256     } else {
3257       n-&gt;subsume_by(n-&gt;in(1), this);
3258       if (n-&gt;outcnt() == 0) {
3259         n-&gt;disconnect_inputs(NULL, this);
3260       }
3261     }
3262     break;
3263   }
3264 #ifdef _LP64
3265   case Op_CmpP:
3266     // Do this transformation here to preserve CmpPNode::sub() and
3267     // other TypePtr related Ideal optimizations (for example, ptr nullness).
3268     if (n-&gt;in(1)-&gt;is_DecodeNarrowPtr() || n-&gt;in(2)-&gt;is_DecodeNarrowPtr()) {
3269       Node* in1 = n-&gt;in(1);
3270       Node* in2 = n-&gt;in(2);
3271       if (!in1-&gt;is_DecodeNarrowPtr()) {
3272         in2 = in1;
3273         in1 = n-&gt;in(2);
3274       }
3275       assert(in1-&gt;is_DecodeNarrowPtr(), &quot;sanity&quot;);
3276 
3277       Node* new_in2 = NULL;
3278       if (in2-&gt;is_DecodeNarrowPtr()) {
3279         assert(in2-&gt;Opcode() == in1-&gt;Opcode(), &quot;must be same node type&quot;);
3280         new_in2 = in2-&gt;in(1);
3281       } else if (in2-&gt;Opcode() == Op_ConP) {
3282         const Type* t = in2-&gt;bottom_type();
3283         if (t == TypePtr::NULL_PTR) {
3284           assert(in1-&gt;is_DecodeN(), &quot;compare klass to null?&quot;);
3285           // Don&#39;t convert CmpP null check into CmpN if compressed
3286           // oops implicit null check is not generated.
3287           // This will allow to generate normal oop implicit null check.
3288           if (Matcher::gen_narrow_oop_implicit_null_checks())
3289             new_in2 = ConNode::make(TypeNarrowOop::NULL_PTR);
3290           //
3291           // This transformation together with CastPP transformation above
3292           // will generated code for implicit NULL checks for compressed oops.
3293           //
3294           // The original code after Optimize()
3295           //
3296           //    LoadN memory, narrow_oop_reg
3297           //    decode narrow_oop_reg, base_reg
3298           //    CmpP base_reg, NULL
3299           //    CastPP base_reg // NotNull
3300           //    Load [base_reg + offset], val_reg
3301           //
3302           // after these transformations will be
3303           //
3304           //    LoadN memory, narrow_oop_reg
3305           //    CmpN narrow_oop_reg, NULL
3306           //    decode_not_null narrow_oop_reg, base_reg
3307           //    Load [base_reg + offset], val_reg
3308           //
3309           // and the uncommon path (== NULL) will use narrow_oop_reg directly
3310           // since narrow oops can be used in debug info now (see the code in
3311           // final_graph_reshaping_walk()).
3312           //
3313           // At the end the code will be matched to
3314           // on x86:
3315           //
3316           //    Load_narrow_oop memory, narrow_oop_reg
3317           //    Load [R12 + narrow_oop_reg&lt;&lt;3 + offset], val_reg
3318           //    NullCheck narrow_oop_reg
3319           //
3320           // and on sparc:
3321           //
3322           //    Load_narrow_oop memory, narrow_oop_reg
3323           //    decode_not_null narrow_oop_reg, base_reg
3324           //    Load [base_reg + offset], val_reg
3325           //    NullCheck base_reg
3326           //
3327         } else if (t-&gt;isa_oopptr()) {
3328           new_in2 = ConNode::make(t-&gt;make_narrowoop());
3329         } else if (t-&gt;isa_klassptr()) {
3330           new_in2 = ConNode::make(t-&gt;make_narrowklass());
3331         }
3332       }
3333       if (new_in2 != NULL) {
3334         Node* cmpN = new CmpNNode(in1-&gt;in(1), new_in2);
3335         n-&gt;subsume_by(cmpN, this);
3336         if (in1-&gt;outcnt() == 0) {
3337           in1-&gt;disconnect_inputs(NULL, this);
3338         }
3339         if (in2-&gt;outcnt() == 0) {
3340           in2-&gt;disconnect_inputs(NULL, this);
3341         }
3342       }
3343     }
3344     break;
3345 
3346   case Op_DecodeN:
3347   case Op_DecodeNKlass:
3348     assert(!n-&gt;in(1)-&gt;is_EncodeNarrowPtr(), &quot;should be optimized out&quot;);
3349     // DecodeN could be pinned when it can&#39;t be fold into
3350     // an address expression, see the code for Op_CastPP above.
3351     assert(n-&gt;in(0) == NULL || (UseCompressedOops &amp;&amp; !Matcher::narrow_oop_use_complex_address()), &quot;no control&quot;);
3352     break;
3353 
3354   case Op_EncodeP:
3355   case Op_EncodePKlass: {
3356     Node* in1 = n-&gt;in(1);
3357     if (in1-&gt;is_DecodeNarrowPtr()) {
3358       n-&gt;subsume_by(in1-&gt;in(1), this);
3359     } else if (in1-&gt;Opcode() == Op_ConP) {
3360       const Type* t = in1-&gt;bottom_type();
3361       if (t == TypePtr::NULL_PTR) {
3362         assert(t-&gt;isa_oopptr(), &quot;null klass?&quot;);
3363         n-&gt;subsume_by(ConNode::make(TypeNarrowOop::NULL_PTR), this);
3364       } else if (t-&gt;isa_oopptr()) {
3365         n-&gt;subsume_by(ConNode::make(t-&gt;make_narrowoop()), this);
3366       } else if (t-&gt;isa_klassptr()) {
3367         n-&gt;subsume_by(ConNode::make(t-&gt;make_narrowklass()), this);
3368       }
3369     }
3370     if (in1-&gt;outcnt() == 0) {
3371       in1-&gt;disconnect_inputs(NULL, this);
3372     }
3373     break;
3374   }
3375 
3376   case Op_Proj: {
3377     if (OptimizeStringConcat) {
3378       ProjNode* p = n-&gt;as_Proj();
3379       if (p-&gt;_is_io_use) {
3380         // Separate projections were used for the exception path which
3381         // are normally removed by a late inline.  If it wasn&#39;t inlined
3382         // then they will hang around and should just be replaced with
3383         // the original one.
3384         Node* proj = NULL;
3385         // Replace with just one
3386         for (SimpleDUIterator i(p-&gt;in(0)); i.has_next(); i.next()) {
3387           Node *use = i.get();
3388           if (use-&gt;is_Proj() &amp;&amp; p != use &amp;&amp; use-&gt;as_Proj()-&gt;_con == p-&gt;_con) {
3389             proj = use;
3390             break;
3391           }
3392         }
3393         assert(proj != NULL || p-&gt;_con == TypeFunc::I_O, &quot;io may be dropped at an infinite loop&quot;);
3394         if (proj != NULL) {
3395           p-&gt;subsume_by(proj, this);
3396         }
3397       }
3398     }
3399     break;
3400   }
3401 
3402   case Op_Phi:
3403     if (n-&gt;as_Phi()-&gt;bottom_type()-&gt;isa_narrowoop() || n-&gt;as_Phi()-&gt;bottom_type()-&gt;isa_narrowklass()) {
3404       // The EncodeP optimization may create Phi with the same edges
3405       // for all paths. It is not handled well by Register Allocator.
3406       Node* unique_in = n-&gt;in(1);
3407       assert(unique_in != NULL, &quot;&quot;);
3408       uint cnt = n-&gt;req();
3409       for (uint i = 2; i &lt; cnt; i++) {
3410         Node* m = n-&gt;in(i);
3411         assert(m != NULL, &quot;&quot;);
3412         if (unique_in != m)
3413           unique_in = NULL;
3414       }
3415       if (unique_in != NULL) {
3416         n-&gt;subsume_by(unique_in, this);
3417       }
3418     }
3419     break;
3420 
3421 #endif
3422 
3423 #ifdef ASSERT
3424   case Op_CastII:
3425     // Verify that all range check dependent CastII nodes were removed.
3426     if (n-&gt;isa_CastII()-&gt;has_range_check()) {
3427       n-&gt;dump(3);
3428       assert(false, &quot;Range check dependent CastII node was not removed&quot;);
3429     }
3430     break;
3431 #endif
3432 
3433   case Op_ModI:
3434     if (UseDivMod) {
3435       // Check if a%b and a/b both exist
3436       Node* d = n-&gt;find_similar(Op_DivI);
3437       if (d) {
3438         // Replace them with a fused divmod if supported
3439         if (Matcher::has_match_rule(Op_DivModI)) {
3440           DivModINode* divmod = DivModINode::make(n);
3441           d-&gt;subsume_by(divmod-&gt;div_proj(), this);
3442           n-&gt;subsume_by(divmod-&gt;mod_proj(), this);
3443         } else {
3444           // replace a%b with a-((a/b)*b)
3445           Node* mult = new MulINode(d, d-&gt;in(2));
3446           Node* sub  = new SubINode(d-&gt;in(1), mult);
3447           n-&gt;subsume_by(sub, this);
3448         }
3449       }
3450     }
3451     break;
3452 
3453   case Op_ModL:
3454     if (UseDivMod) {
3455       // Check if a%b and a/b both exist
3456       Node* d = n-&gt;find_similar(Op_DivL);
3457       if (d) {
3458         // Replace them with a fused divmod if supported
3459         if (Matcher::has_match_rule(Op_DivModL)) {
3460           DivModLNode* divmod = DivModLNode::make(n);
3461           d-&gt;subsume_by(divmod-&gt;div_proj(), this);
3462           n-&gt;subsume_by(divmod-&gt;mod_proj(), this);
3463         } else {
3464           // replace a%b with a-((a/b)*b)
3465           Node* mult = new MulLNode(d, d-&gt;in(2));
3466           Node* sub  = new SubLNode(d-&gt;in(1), mult);
3467           n-&gt;subsume_by(sub, this);
3468         }
3469       }
3470     }
3471     break;
3472 
3473   case Op_LoadVector:
3474   case Op_StoreVector:
3475     break;
3476 
3477   case Op_AddReductionVI:
3478   case Op_AddReductionVL:
3479   case Op_AddReductionVF:
3480   case Op_AddReductionVD:
3481   case Op_MulReductionVI:
3482   case Op_MulReductionVL:
3483   case Op_MulReductionVF:
3484   case Op_MulReductionVD:
3485   case Op_MinReductionV:
3486   case Op_MaxReductionV:
<a name="23" id="anc23"></a><span class="line-added">3487   case Op_AndReductionV:</span>
<span class="line-added">3488   case Op_OrReductionV:</span>
<span class="line-added">3489   case Op_XorReductionV:</span>
3490     break;
3491 
3492   case Op_PackB:
3493   case Op_PackS:
3494   case Op_PackI:
3495   case Op_PackF:
3496   case Op_PackL:
3497   case Op_PackD:
3498     if (n-&gt;req()-1 &gt; 2) {
3499       // Replace many operand PackNodes with a binary tree for matching
3500       PackNode* p = (PackNode*) n;
3501       Node* btp = p-&gt;binary_tree_pack(1, n-&gt;req());
3502       n-&gt;subsume_by(btp, this);
3503     }
3504     break;
3505   case Op_Loop:
3506   case Op_CountedLoop:
3507   case Op_OuterStripMinedLoop:
3508     if (n-&gt;as_Loop()-&gt;is_inner_loop()) {
3509       frc.inc_inner_loop_count();
3510     }
3511     n-&gt;as_Loop()-&gt;verify_strip_mined(0);
3512     break;
3513   case Op_LShiftI:
3514   case Op_RShiftI:
3515   case Op_URShiftI:
3516   case Op_LShiftL:
3517   case Op_RShiftL:
3518   case Op_URShiftL:
3519     if (Matcher::need_masked_shift_count) {
3520       // The cpu&#39;s shift instructions don&#39;t restrict the count to the
3521       // lower 5/6 bits. We need to do the masking ourselves.
3522       Node* in2 = n-&gt;in(2);
3523       juint mask = (n-&gt;bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);
3524       const TypeInt* t = in2-&gt;find_int_type();
3525       if (t != NULL &amp;&amp; t-&gt;is_con()) {
3526         juint shift = t-&gt;get_con();
3527         if (shift &gt; mask) { // Unsigned cmp
3528           n-&gt;set_req(2, ConNode::make(TypeInt::make(shift &amp; mask)));
3529         }
3530       } else {
3531         if (t == NULL || t-&gt;_lo &lt; 0 || t-&gt;_hi &gt; (int)mask) {
3532           Node* shift = new AndINode(in2, ConNode::make(TypeInt::make(mask)));
3533           n-&gt;set_req(2, shift);
3534         }
3535       }
3536       if (in2-&gt;outcnt() == 0) { // Remove dead node
3537         in2-&gt;disconnect_inputs(NULL, this);
3538       }
3539     }
3540     break;
3541   case Op_MemBarStoreStore:
3542   case Op_MemBarRelease:
3543     // Break the link with AllocateNode: it is no longer useful and
3544     // confuses register allocation.
3545     if (n-&gt;req() &gt; MemBarNode::Precedent) {
3546       n-&gt;set_req(MemBarNode::Precedent, top());
3547     }
3548     break;
3549   case Op_MemBarAcquire: {
3550     if (n-&gt;as_MemBar()-&gt;trailing_load() &amp;&amp; n-&gt;req() &gt; MemBarNode::Precedent) {
3551       // At parse time, the trailing MemBarAcquire for a volatile load
3552       // is created with an edge to the load. After optimizations,
3553       // that input may be a chain of Phis. If those phis have no
3554       // other use, then the MemBarAcquire keeps them alive and
3555       // register allocation can be confused.
3556       ResourceMark rm;
3557       Unique_Node_List wq;
3558       wq.push(n-&gt;in(MemBarNode::Precedent));
3559       n-&gt;set_req(MemBarNode::Precedent, top());
3560       while (wq.size() &gt; 0) {
3561         Node* m = wq.pop();
3562         if (m-&gt;outcnt() == 0) {
3563           for (uint j = 0; j &lt; m-&gt;req(); j++) {
3564             Node* in = m-&gt;in(j);
3565             if (in != NULL) {
3566               wq.push(in);
3567             }
3568           }
3569           m-&gt;disconnect_inputs(NULL, this);
3570         }
3571       }
3572     }
3573     break;
3574   }
3575   case Op_RangeCheck: {
3576     RangeCheckNode* rc = n-&gt;as_RangeCheck();
3577     Node* iff = new IfNode(rc-&gt;in(0), rc-&gt;in(1), rc-&gt;_prob, rc-&gt;_fcnt);
3578     n-&gt;subsume_by(iff, this);
3579     frc._tests.push(iff);
3580     break;
3581   }
3582   case Op_ConvI2L: {
3583     if (!Matcher::convi2l_type_required) {
3584       // Code generation on some platforms doesn&#39;t need accurate
3585       // ConvI2L types. Widening the type can help remove redundant
3586       // address computations.
3587       n-&gt;as_Type()-&gt;set_type(TypeLong::INT);
3588       ResourceMark rm;
3589       Unique_Node_List wq;
3590       wq.push(n);
3591       for (uint next = 0; next &lt; wq.size(); next++) {
3592         Node *m = wq.at(next);
3593 
3594         for(;;) {
3595           // Loop over all nodes with identical inputs edges as m
3596           Node* k = m-&gt;find_similar(m-&gt;Opcode());
3597           if (k == NULL) {
3598             break;
3599           }
3600           // Push their uses so we get a chance to remove node made
3601           // redundant
3602           for (DUIterator_Fast imax, i = k-&gt;fast_outs(imax); i &lt; imax; i++) {
3603             Node* u = k-&gt;fast_out(i);
3604             if (u-&gt;Opcode() == Op_LShiftL ||
3605                 u-&gt;Opcode() == Op_AddL ||
3606                 u-&gt;Opcode() == Op_SubL ||
3607                 u-&gt;Opcode() == Op_AddP) {
3608               wq.push(u);
3609             }
3610           }
3611           // Replace all nodes with identical edges as m with m
3612           k-&gt;subsume_by(m, this);
3613         }
3614       }
3615     }
3616     break;
3617   }
3618   case Op_CmpUL: {
3619     if (!Matcher::has_match_rule(Op_CmpUL)) {
3620       // No support for unsigned long comparisons
3621       ConINode* sign_pos = new ConINode(TypeInt::make(BitsPerLong - 1));
3622       Node* sign_bit_mask = new RShiftLNode(n-&gt;in(1), sign_pos);
3623       Node* orl = new OrLNode(n-&gt;in(1), sign_bit_mask);
3624       ConLNode* remove_sign_mask = new ConLNode(TypeLong::make(max_jlong));
3625       Node* andl = new AndLNode(orl, remove_sign_mask);
3626       Node* cmp = new CmpLNode(andl, n-&gt;in(2));
3627       n-&gt;subsume_by(cmp, this);
3628     }
3629     break;
3630   }
3631 #ifdef ASSERT
3632   case Op_ValueTypePtr:
3633   case Op_ValueType: {
3634     n-&gt;dump(-1);
3635     assert(false, &quot;value type node was not removed&quot;);
3636     break;
3637   }
3638 #endif
3639   case Op_GetNullFreeProperty:
3640   case Op_GetFlattenedProperty: {
3641     // Extract the null free bits
3642     uint last = unique();
3643     Node* null_free = NULL;
3644     int bit = nop == Op_GetNullFreeProperty ? ArrayStorageProperties::null_free_bit : ArrayStorageProperties::flattened_bit;
3645     if (n-&gt;in(1)-&gt;Opcode() == Op_LoadKlass) {
3646       Node* cast = new CastP2XNode(NULL, n-&gt;in(1));
3647       null_free = new AndLNode(cast, new ConLNode(TypeLong::make(((jlong)1)&lt;&lt;(oopDesc::wide_storage_props_shift + bit))));
3648     } else {
3649       assert(n-&gt;in(1)-&gt;Opcode() == Op_LoadNKlass, &quot;not a compressed klass?&quot;);
3650       Node* cast = new CastN2INode(n-&gt;in(1));
3651       null_free = new AndINode(cast, new ConINode(TypeInt::make(1&lt;&lt;(oopDesc::narrow_storage_props_shift + bit))));
3652     }
3653     n-&gt;subsume_by(null_free, this);
3654     break;
3655   }
3656   default:
3657     assert(!n-&gt;is_Call(), &quot;&quot;);
3658     assert(!n-&gt;is_Mem(), &quot;&quot;);
3659     assert(nop != Op_ProfileBoolean, &quot;should be eliminated during IGVN&quot;);
3660     break;
3661   }
3662 }
3663 
3664 //------------------------------final_graph_reshaping_walk---------------------
3665 // Replacing Opaque nodes with their input in final_graph_reshaping_impl(),
3666 // requires that the walk visits a node&#39;s inputs before visiting the node.
3667 void Compile::final_graph_reshaping_walk( Node_Stack &amp;nstack, Node *root, Final_Reshape_Counts &amp;frc ) {
3668   ResourceArea *area = Thread::current()-&gt;resource_area();
3669   Unique_Node_List sfpt(area);
3670 
3671   frc._visited.set(root-&gt;_idx); // first, mark node as visited
3672   uint cnt = root-&gt;req();
3673   Node *n = root;
3674   uint  i = 0;
3675   while (true) {
3676     if (i &lt; cnt) {
3677       // Place all non-visited non-null inputs onto stack
3678       Node* m = n-&gt;in(i);
3679       ++i;
3680       if (m != NULL &amp;&amp; !frc._visited.test_set(m-&gt;_idx)) {
3681         if (m-&gt;is_SafePoint() &amp;&amp; m-&gt;as_SafePoint()-&gt;jvms() != NULL) {
3682           // compute worst case interpreter size in case of a deoptimization
3683           update_interpreter_frame_size(m-&gt;as_SafePoint()-&gt;jvms()-&gt;interpreter_frame_size());
3684 
3685           sfpt.push(m);
3686         }
3687         cnt = m-&gt;req();
3688         nstack.push(n, i); // put on stack parent and next input&#39;s index
3689         n = m;
3690         i = 0;
3691       }
3692     } else {
3693       // Now do post-visit work
3694       final_graph_reshaping_impl( n, frc );
3695       if (nstack.is_empty())
3696         break;             // finished
3697       n = nstack.node();   // Get node from stack
3698       cnt = n-&gt;req();
3699       i = nstack.index();
3700       nstack.pop();        // Shift to the next node on stack
3701     }
3702   }
3703 
3704   // Skip next transformation if compressed oops are not used.
3705   if ((UseCompressedOops &amp;&amp; !Matcher::gen_narrow_oop_implicit_null_checks()) ||
3706       (!UseCompressedOops &amp;&amp; !UseCompressedClassPointers))
3707     return;
3708 
3709   // Go over safepoints nodes to skip DecodeN/DecodeNKlass nodes for debug edges.
3710   // It could be done for an uncommon traps or any safepoints/calls
3711   // if the DecodeN/DecodeNKlass node is referenced only in a debug info.
3712   while (sfpt.size() &gt; 0) {
3713     n = sfpt.pop();
3714     JVMState *jvms = n-&gt;as_SafePoint()-&gt;jvms();
3715     assert(jvms != NULL, &quot;sanity&quot;);
3716     int start = jvms-&gt;debug_start();
3717     int end   = n-&gt;req();
3718     bool is_uncommon = (n-&gt;is_CallStaticJava() &amp;&amp;
3719                         n-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0);
3720     for (int j = start; j &lt; end; j++) {
3721       Node* in = n-&gt;in(j);
3722       if (in-&gt;is_DecodeNarrowPtr()) {
3723         bool safe_to_skip = true;
3724         if (!is_uncommon ) {
3725           // Is it safe to skip?
3726           for (uint i = 0; i &lt; in-&gt;outcnt(); i++) {
3727             Node* u = in-&gt;raw_out(i);
3728             if (!u-&gt;is_SafePoint() ||
3729                 (u-&gt;is_Call() &amp;&amp; u-&gt;as_Call()-&gt;has_non_debug_use(n))) {
3730               safe_to_skip = false;
3731             }
3732           }
3733         }
3734         if (safe_to_skip) {
3735           n-&gt;set_req(j, in-&gt;in(1));
3736         }
3737         if (in-&gt;outcnt() == 0) {
3738           in-&gt;disconnect_inputs(NULL, this);
3739         }
3740       }
3741     }
3742   }
3743 }
3744 
3745 //------------------------------final_graph_reshaping--------------------------
3746 // Final Graph Reshaping.
3747 //
3748 // (1) Clone simple inputs to uncommon calls, so they can be scheduled late
3749 //     and not commoned up and forced early.  Must come after regular
3750 //     optimizations to avoid GVN undoing the cloning.  Clone constant
3751 //     inputs to Loop Phis; these will be split by the allocator anyways.
3752 //     Remove Opaque nodes.
3753 // (2) Move last-uses by commutative operations to the left input to encourage
3754 //     Intel update-in-place two-address operations and better register usage
3755 //     on RISCs.  Must come after regular optimizations to avoid GVN Ideal
3756 //     calls canonicalizing them back.
3757 // (3) Count the number of double-precision FP ops, single-precision FP ops
3758 //     and call sites.  On Intel, we can get correct rounding either by
3759 //     forcing singles to memory (requires extra stores and loads after each
3760 //     FP bytecode) or we can set a rounding mode bit (requires setting and
3761 //     clearing the mode bit around call sites).  The mode bit is only used
3762 //     if the relative frequency of single FP ops to calls is low enough.
3763 //     This is a key transform for SPEC mpeg_audio.
3764 // (4) Detect infinite loops; blobs of code reachable from above but not
3765 //     below.  Several of the Code_Gen algorithms fail on such code shapes,
3766 //     so we simply bail out.  Happens a lot in ZKM.jar, but also happens
3767 //     from time to time in other codes (such as -Xcomp finalizer loops, etc).
3768 //     Detection is by looking for IfNodes where only 1 projection is
3769 //     reachable from below or CatchNodes missing some targets.
3770 // (5) Assert for insane oop offsets in debug mode.
3771 
3772 bool Compile::final_graph_reshaping() {
3773   // an infinite loop may have been eliminated by the optimizer,
3774   // in which case the graph will be empty.
3775   if (root()-&gt;req() == 1) {
3776     record_method_not_compilable(&quot;trivial infinite loop&quot;);
3777     return true;
3778   }
3779 
3780   // Expensive nodes have their control input set to prevent the GVN
3781   // from freely commoning them. There&#39;s no GVN beyond this point so
3782   // no need to keep the control input. We want the expensive nodes to
3783   // be freely moved to the least frequent code path by gcm.
3784   assert(OptimizeExpensiveOps || expensive_count() == 0, &quot;optimization off but list non empty?&quot;);
3785   for (int i = 0; i &lt; expensive_count(); i++) {
3786     _expensive_nodes-&gt;at(i)-&gt;set_req(0, NULL);
3787   }
3788 
3789   Final_Reshape_Counts frc;
3790 
3791   // Visit everybody reachable!
3792   // Allocate stack of size C-&gt;live_nodes()/2 to avoid frequent realloc
3793   Node_Stack nstack(live_nodes() &gt;&gt; 1);
3794   final_graph_reshaping_walk(nstack, root(), frc);
3795 
3796   // Check for unreachable (from below) code (i.e., infinite loops).
3797   for( uint i = 0; i &lt; frc._tests.size(); i++ ) {
3798     MultiBranchNode *n = frc._tests[i]-&gt;as_MultiBranch();
3799     // Get number of CFG targets.
3800     // Note that PCTables include exception targets after calls.
3801     uint required_outcnt = n-&gt;required_outcnt();
3802     if (n-&gt;outcnt() != required_outcnt) {
3803       // Check for a few special cases.  Rethrow Nodes never take the
3804       // &#39;fall-thru&#39; path, so expected kids is 1 less.
3805       if (n-&gt;is_PCTable() &amp;&amp; n-&gt;in(0) &amp;&amp; n-&gt;in(0)-&gt;in(0)) {
3806         if (n-&gt;in(0)-&gt;in(0)-&gt;is_Call()) {
3807           CallNode *call = n-&gt;in(0)-&gt;in(0)-&gt;as_Call();
3808           if (call-&gt;entry_point() == OptoRuntime::rethrow_stub()) {
3809             required_outcnt--;      // Rethrow always has 1 less kid
3810           } else if (call-&gt;req() &gt; TypeFunc::Parms &amp;&amp;
3811                      call-&gt;is_CallDynamicJava()) {
3812             // Check for null receiver. In such case, the optimizer has
3813             // detected that the virtual call will always result in a null
3814             // pointer exception. The fall-through projection of this CatchNode
3815             // will not be populated.
3816             Node *arg0 = call-&gt;in(TypeFunc::Parms);
3817             if (arg0-&gt;is_Type() &amp;&amp;
3818                 arg0-&gt;as_Type()-&gt;type()-&gt;higher_equal(TypePtr::NULL_PTR)) {
3819               required_outcnt--;
3820             }
3821           } else if (call-&gt;entry_point() == OptoRuntime::new_array_Java() &amp;&amp;
3822                      call-&gt;req() &gt; TypeFunc::Parms+1 &amp;&amp;
3823                      call-&gt;is_CallStaticJava()) {
3824             // Check for negative array length. In such case, the optimizer has
3825             // detected that the allocation attempt will always result in an
3826             // exception. There is no fall-through projection of this CatchNode .
3827             Node *arg1 = call-&gt;in(TypeFunc::Parms+1);
3828             if (arg1-&gt;is_Type() &amp;&amp;
3829                 arg1-&gt;as_Type()-&gt;type()-&gt;join(TypeInt::POS)-&gt;empty()) {
3830               required_outcnt--;
3831             }
3832           }
3833         }
3834       }
3835       // Recheck with a better notion of &#39;required_outcnt&#39;
3836       if (n-&gt;outcnt() != required_outcnt) {
3837         record_method_not_compilable(&quot;malformed control flow&quot;);
3838         return true;            // Not all targets reachable!
3839       }
3840     }
3841     // Check that I actually visited all kids.  Unreached kids
3842     // must be infinite loops.
3843     for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++)
3844       if (!frc._visited.test(n-&gt;fast_out(j)-&gt;_idx)) {
3845         record_method_not_compilable(&quot;infinite loop&quot;);
3846         return true;            // Found unvisited kid; must be unreach
3847       }
3848 
3849     // Here so verification code in final_graph_reshaping_walk()
3850     // always see an OuterStripMinedLoopEnd
3851     if (n-&gt;is_OuterStripMinedLoopEnd()) {
3852       IfNode* init_iff = n-&gt;as_If();
3853       Node* iff = new IfNode(init_iff-&gt;in(0), init_iff-&gt;in(1), init_iff-&gt;_prob, init_iff-&gt;_fcnt);
3854       n-&gt;subsume_by(iff, this);
3855     }
3856   }
3857 
3858 #ifdef IA32
3859   // If original bytecodes contained a mixture of floats and doubles
3860   // check if the optimizer has made it homogenous, item (3).
3861   if (UseSSE == 0 &amp;&amp;
3862       frc.get_float_count() &gt; 32 &amp;&amp;
3863       frc.get_double_count() == 0 &amp;&amp;
3864       (10 * frc.get_call_count() &lt; frc.get_float_count()) ) {
3865     set_24_bit_selection_and_mode(false, true);
3866   }
3867 #endif // IA32
3868 
3869   set_java_calls(frc.get_java_call_count());
3870   set_inner_loops(frc.get_inner_loop_count());
3871 
3872   // No infinite loops, no reason to bail out.
3873   return false;
3874 }
3875 
3876 //-----------------------------too_many_traps----------------------------------
3877 // Report if there are too many traps at the current method and bci.
3878 // Return true if there was a trap, and/or PerMethodTrapLimit is exceeded.
3879 bool Compile::too_many_traps(ciMethod* method,
3880                              int bci,
3881                              Deoptimization::DeoptReason reason) {
3882   ciMethodData* md = method-&gt;method_data();
3883   if (md-&gt;is_empty()) {
3884     // Assume the trap has not occurred, or that it occurred only
3885     // because of a transient condition during start-up in the interpreter.
3886     return false;
3887   }
3888   ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this-&gt;method() : NULL;
3889   if (md-&gt;has_trap_at(bci, m, reason) != 0) {
3890     // Assume PerBytecodeTrapLimit==0, for a more conservative heuristic.
3891     // Also, if there are multiple reasons, or if there is no per-BCI record,
3892     // assume the worst.
3893     if (log())
3894       log()-&gt;elem(&quot;observe trap=&#39;%s&#39; count=&#39;%d&#39;&quot;,
3895                   Deoptimization::trap_reason_name(reason),
3896                   md-&gt;trap_count(reason));
3897     return true;
3898   } else {
3899     // Ignore method/bci and see if there have been too many globally.
3900     return too_many_traps(reason, md);
3901   }
3902 }
3903 
3904 // Less-accurate variant which does not require a method and bci.
3905 bool Compile::too_many_traps(Deoptimization::DeoptReason reason,
3906                              ciMethodData* logmd) {
3907   if (trap_count(reason) &gt;= Deoptimization::per_method_trap_limit(reason)) {
3908     // Too many traps globally.
3909     // Note that we use cumulative trap_count, not just md-&gt;trap_count.
3910     if (log()) {
3911       int mcount = (logmd == NULL)? -1: (int)logmd-&gt;trap_count(reason);
3912       log()-&gt;elem(&quot;observe trap=&#39;%s&#39; count=&#39;0&#39; mcount=&#39;%d&#39; ccount=&#39;%d&#39;&quot;,
3913                   Deoptimization::trap_reason_name(reason),
3914                   mcount, trap_count(reason));
3915     }
3916     return true;
3917   } else {
3918     // The coast is clear.
3919     return false;
3920   }
3921 }
3922 
3923 //--------------------------too_many_recompiles--------------------------------
3924 // Report if there are too many recompiles at the current method and bci.
3925 // Consults PerBytecodeRecompilationCutoff and PerMethodRecompilationCutoff.
3926 // Is not eager to return true, since this will cause the compiler to use
3927 // Action_none for a trap point, to avoid too many recompilations.
3928 bool Compile::too_many_recompiles(ciMethod* method,
3929                                   int bci,
3930                                   Deoptimization::DeoptReason reason) {
3931   ciMethodData* md = method-&gt;method_data();
3932   if (md-&gt;is_empty()) {
3933     // Assume the trap has not occurred, or that it occurred only
3934     // because of a transient condition during start-up in the interpreter.
3935     return false;
3936   }
3937   // Pick a cutoff point well within PerBytecodeRecompilationCutoff.
3938   uint bc_cutoff = (uint) PerBytecodeRecompilationCutoff / 8;
3939   uint m_cutoff  = (uint) PerMethodRecompilationCutoff / 2 + 1;  // not zero
3940   Deoptimization::DeoptReason per_bc_reason
3941     = Deoptimization::reason_recorded_per_bytecode_if_any(reason);
3942   ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this-&gt;method() : NULL;
3943   if ((per_bc_reason == Deoptimization::Reason_none
3944        || md-&gt;has_trap_at(bci, m, reason) != 0)
3945       // The trap frequency measure we care about is the recompile count:
3946       &amp;&amp; md-&gt;trap_recompiled_at(bci, m)
3947       &amp;&amp; md-&gt;overflow_recompile_count() &gt;= bc_cutoff) {
3948     // Do not emit a trap here if it has already caused recompilations.
3949     // Also, if there are multiple reasons, or if there is no per-BCI record,
3950     // assume the worst.
3951     if (log())
3952       log()-&gt;elem(&quot;observe trap=&#39;%s recompiled&#39; count=&#39;%d&#39; recompiles2=&#39;%d&#39;&quot;,
3953                   Deoptimization::trap_reason_name(reason),
3954                   md-&gt;trap_count(reason),
3955                   md-&gt;overflow_recompile_count());
3956     return true;
3957   } else if (trap_count(reason) != 0
3958              &amp;&amp; decompile_count() &gt;= m_cutoff) {
3959     // Too many recompiles globally, and we have seen this sort of trap.
3960     // Use cumulative decompile_count, not just md-&gt;decompile_count.
3961     if (log())
3962       log()-&gt;elem(&quot;observe trap=&#39;%s&#39; count=&#39;%d&#39; mcount=&#39;%d&#39; decompiles=&#39;%d&#39; mdecompiles=&#39;%d&#39;&quot;,
3963                   Deoptimization::trap_reason_name(reason),
3964                   md-&gt;trap_count(reason), trap_count(reason),
3965                   md-&gt;decompile_count(), decompile_count());
3966     return true;
3967   } else {
3968     // The coast is clear.
3969     return false;
3970   }
3971 }
3972 
3973 // Compute when not to trap. Used by matching trap based nodes and
3974 // NullCheck optimization.
3975 void Compile::set_allowed_deopt_reasons() {
3976   _allowed_reasons = 0;
3977   if (is_method_compilation()) {
3978     for (int rs = (int)Deoptimization::Reason_none+1; rs &lt; Compile::trapHistLength; rs++) {
3979       assert(rs &lt; BitsPerInt, &quot;recode bit map&quot;);
3980       if (!too_many_traps((Deoptimization::DeoptReason) rs)) {
3981         _allowed_reasons |= nth_bit(rs);
3982       }
3983     }
3984   }
3985 }
3986 
3987 bool Compile::needs_clinit_barrier(ciMethod* method, ciMethod* accessing_method) {
3988   return method-&gt;is_static() &amp;&amp; needs_clinit_barrier(method-&gt;holder(), accessing_method);
3989 }
3990 
3991 bool Compile::needs_clinit_barrier(ciField* field, ciMethod* accessing_method) {
3992   return field-&gt;is_static() &amp;&amp; needs_clinit_barrier(field-&gt;holder(), accessing_method);
3993 }
3994 
3995 bool Compile::needs_clinit_barrier(ciInstanceKlass* holder, ciMethod* accessing_method) {
3996   if (holder-&gt;is_initialized()) {
3997     return false;
3998   }
3999   if (holder-&gt;is_being_initialized()) {
4000     if (accessing_method-&gt;holder() == holder) {
4001       // Access inside a class. The barrier can be elided when access happens in &lt;clinit&gt;,
4002       // &lt;init&gt;, or a static method. In all those cases, there was an initialization
4003       // barrier on the holder klass passed.
4004       if (accessing_method-&gt;is_class_initializer() ||
4005           accessing_method-&gt;is_object_constructor() ||
4006           accessing_method-&gt;is_static()) {
4007         return false;
4008       }
4009     } else if (accessing_method-&gt;holder()-&gt;is_subclass_of(holder)) {
4010       // Access from a subclass. The barrier can be elided only when access happens in &lt;clinit&gt;.
4011       // In case of &lt;init&gt; or a static method, the barrier is on the subclass is not enough:
4012       // child class can become fully initialized while its parent class is still being initialized.
4013       if (accessing_method-&gt;is_class_initializer()) {
4014         return false;
4015       }
4016     }
4017     ciMethod* root = method(); // the root method of compilation
4018     if (root != accessing_method) {
4019       return needs_clinit_barrier(holder, root); // check access in the context of compilation root
4020     }
4021   }
4022   return true;
4023 }
4024 
4025 #ifndef PRODUCT
4026 //------------------------------verify_graph_edges---------------------------
4027 // Walk the Graph and verify that there is a one-to-one correspondence
4028 // between Use-Def edges and Def-Use edges in the graph.
4029 void Compile::verify_graph_edges(bool no_dead_code) {
4030   if (VerifyGraphEdges) {
4031     ResourceArea *area = Thread::current()-&gt;resource_area();
4032     Unique_Node_List visited(area);
4033     // Call recursive graph walk to check edges
4034     _root-&gt;verify_edges(visited);
4035     if (no_dead_code) {
4036       // Now make sure that no visited node is used by an unvisited node.
4037       bool dead_nodes = false;
4038       Unique_Node_List checked(area);
4039       while (visited.size() &gt; 0) {
4040         Node* n = visited.pop();
4041         checked.push(n);
4042         for (uint i = 0; i &lt; n-&gt;outcnt(); i++) {
4043           Node* use = n-&gt;raw_out(i);
4044           if (checked.member(use))  continue;  // already checked
4045           if (visited.member(use))  continue;  // already in the graph
4046           if (use-&gt;is_Con())        continue;  // a dead ConNode is OK
4047           // At this point, we have found a dead node which is DU-reachable.
4048           if (!dead_nodes) {
4049             tty-&gt;print_cr(&quot;*** Dead nodes reachable via DU edges:&quot;);
4050             dead_nodes = true;
4051           }
4052           use-&gt;dump(2);
4053           tty-&gt;print_cr(&quot;---&quot;);
4054           checked.push(use);  // No repeats; pretend it is now checked.
4055         }
4056       }
4057       assert(!dead_nodes, &quot;using nodes must be reachable from root&quot;);
4058     }
4059   }
4060 }
4061 #endif
4062 
4063 // The Compile object keeps track of failure reasons separately from the ciEnv.
4064 // This is required because there is not quite a 1-1 relation between the
4065 // ciEnv and its compilation task and the Compile object.  Note that one
4066 // ciEnv might use two Compile objects, if C2Compiler::compile_method decides
4067 // to backtrack and retry without subsuming loads.  Other than this backtracking
4068 // behavior, the Compile&#39;s failure reason is quietly copied up to the ciEnv
4069 // by the logic in C2Compiler.
4070 void Compile::record_failure(const char* reason) {
4071   if (log() != NULL) {
4072     log()-&gt;elem(&quot;failure reason=&#39;%s&#39; phase=&#39;compile&#39;&quot;, reason);
4073   }
4074   if (_failure_reason == NULL) {
4075     // Record the first failure reason.
4076     _failure_reason = reason;
4077   }
4078 
4079   if (!C-&gt;failure_reason_is(C2Compiler::retry_no_subsuming_loads())) {
4080     C-&gt;print_method(PHASE_FAILURE);
4081   }
4082   _root = NULL;  // flush the graph, too
4083 }
4084 
4085 Compile::TracePhase::TracePhase(const char* name, elapsedTimer* accumulator)
4086   : TraceTime(name, accumulator, CITime, CITimeVerbose),
4087     _phase_name(name), _dolog(CITimeVerbose)
4088 {
4089   if (_dolog) {
4090     C = Compile::current();
4091     _log = C-&gt;log();
4092   } else {
4093     C = NULL;
4094     _log = NULL;
4095   }
4096   if (_log != NULL) {
4097     _log-&gt;begin_head(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39;&quot;, _phase_name, C-&gt;unique(), C-&gt;live_nodes());
4098     _log-&gt;stamp();
4099     _log-&gt;end_head();
4100   }
4101 }
4102 
4103 Compile::TracePhase::~TracePhase() {
4104 
4105   C = Compile::current();
4106   if (_dolog) {
4107     _log = C-&gt;log();
4108   } else {
4109     _log = NULL;
4110   }
4111 
4112 #ifdef ASSERT
4113   if (PrintIdealNodeCount) {
4114     tty-&gt;print_cr(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39; live_graph_walk=&#39;%d&#39;&quot;,
4115                   _phase_name, C-&gt;unique(), C-&gt;live_nodes(), C-&gt;count_live_nodes_by_graph_walk());
4116   }
4117 
4118   if (VerifyIdealNodeCount) {
4119     Compile::current()-&gt;print_missing_nodes();
4120   }
4121 #endif
4122 
4123   if (_log != NULL) {
4124     _log-&gt;done(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39;&quot;, _phase_name, C-&gt;unique(), C-&gt;live_nodes());
4125   }
4126 }
4127 
<a name="24" id="anc24"></a>























































































































































































































4128 //----------------------------static_subtype_check-----------------------------
4129 // Shortcut important common cases when superklass is exact:
4130 // (0) superklass is java.lang.Object (can occur in reflective code)
4131 // (1) subklass is already limited to a subtype of superklass =&gt; always ok
4132 // (2) subklass does not overlap with superklass =&gt; always fail
4133 // (3) superklass has NO subtypes and we can check with a simple compare.
4134 int Compile::static_subtype_check(ciKlass* superk, ciKlass* subk) {
4135   if (StressReflectiveCode || superk == NULL || subk == NULL) {
4136     return SSC_full_test;       // Let caller generate the general case.
4137   }
4138 
4139   if (superk == env()-&gt;Object_klass()) {
4140     return SSC_always_true;     // (0) this test cannot fail
4141   }
4142 
4143   ciType* superelem = superk;
4144   if (superelem-&gt;is_array_klass()) {
4145     ciArrayKlass* ak = superelem-&gt;as_array_klass();
4146     superelem = superelem-&gt;as_array_klass()-&gt;base_element_type();
4147   }
4148 
4149   if (!subk-&gt;is_interface()) {  // cannot trust static interface types yet
4150     if (subk-&gt;is_subtype_of(superk)) {
4151       return SSC_always_true;   // (1) false path dead; no dynamic test needed
4152     }
4153     if (!(superelem-&gt;is_klass() &amp;&amp; superelem-&gt;as_klass()-&gt;is_interface()) &amp;&amp;
4154         !superk-&gt;is_subtype_of(subk)) {
4155       return SSC_always_false;
4156     }
4157   }
4158 
4159   // Do not fold the subtype check to an array klass pointer comparison for [V? arrays.
4160   // [V is a subtype of [V? but the klass for [V is not equal to the klass for [V?. Perform a full test.
4161   if (superk-&gt;is_obj_array_klass() &amp;&amp; !superk-&gt;as_array_klass()-&gt;storage_properties().is_null_free() &amp;&amp; superk-&gt;as_array_klass()-&gt;element_klass()-&gt;is_valuetype()) {
4162     return SSC_full_test;
4163   }
4164   // If casting to an instance klass, it must have no subtypes
4165   if (superk-&gt;is_interface()) {
4166     // Cannot trust interfaces yet.
4167     // %%% S.B. superk-&gt;nof_implementors() == 1
4168   } else if (superelem-&gt;is_instance_klass()) {
4169     ciInstanceKlass* ik = superelem-&gt;as_instance_klass();
4170     if (!ik-&gt;has_subklass() &amp;&amp; !ik-&gt;is_interface()) {
4171       if (!ik-&gt;is_final()) {
4172         // Add a dependency if there is a chance of a later subclass.
4173         dependencies()-&gt;assert_leaf_type(ik);
4174       }
<a name="25" id="anc25"></a>


4175       return SSC_easy_test;     // (3) caller can do a simple ptr comparison
4176     }
4177   } else {
4178     // A primitive array type has no subtypes.
4179     return SSC_easy_test;       // (3) caller can do a simple ptr comparison
4180   }
4181 
4182   return SSC_full_test;
4183 }
4184 
4185 Node* Compile::conv_I2X_index(PhaseGVN* phase, Node* idx, const TypeInt* sizetype, Node* ctrl) {
4186 #ifdef _LP64
4187   // The scaled index operand to AddP must be a clean 64-bit value.
4188   // Java allows a 32-bit int to be incremented to a negative
4189   // value, which appears in a 64-bit register as a large
4190   // positive number.  Using that large positive number as an
4191   // operand in pointer arithmetic has bad consequences.
4192   // On the other hand, 32-bit overflow is rare, and the possibility
4193   // can often be excluded, if we annotate the ConvI2L node with
4194   // a type assertion that its value is known to be a small positive
4195   // number.  (The prior range check has ensured this.)
4196   // This assertion is used by ConvI2LNode::Ideal.
4197   int index_max = max_jint - 1;  // array size is max_jint, index is one less
4198   if (sizetype != NULL) index_max = sizetype-&gt;_hi - 1;
4199   const TypeInt* iidxtype = TypeInt::make(0, index_max, Type::WidenMax);
4200   idx = constrained_convI2L(phase, idx, iidxtype, ctrl);
4201 #endif
4202   return idx;
4203 }
4204 
4205 // Convert integer value to a narrowed long type dependent on ctrl (for example, a range check)
4206 Node* Compile::constrained_convI2L(PhaseGVN* phase, Node* value, const TypeInt* itype, Node* ctrl) {
4207   if (ctrl != NULL) {
4208     // Express control dependency by a CastII node with a narrow type.
4209     value = new CastIINode(value, itype, false, true /* range check dependency */);
4210     // Make the CastII node dependent on the control input to prevent the narrowed ConvI2L
4211     // node from floating above the range check during loop optimizations. Otherwise, the
4212     // ConvI2L node may be eliminated independently of the range check, causing the data path
4213     // to become TOP while the control path is still there (although it&#39;s unreachable).
4214     value-&gt;set_req(0, ctrl);
4215     // Save CastII node to remove it after loop optimizations.
4216     phase-&gt;C-&gt;add_range_check_cast(value);
4217     value = phase-&gt;transform(value);
4218   }
4219   const TypeLong* ltype = TypeLong::make(itype-&gt;_lo, itype-&gt;_hi, itype-&gt;_widen);
4220   return phase-&gt;transform(new ConvI2LNode(value, ltype));
4221 }
4222 
4223 void Compile::print_inlining_stream_free() {
4224   if (_print_inlining_stream != NULL) {
4225     _print_inlining_stream-&gt;~stringStream();
4226     _print_inlining_stream = NULL;
4227   }
4228 }
4229 
4230 // The message about the current inlining is accumulated in
4231 // _print_inlining_stream and transfered into the _print_inlining_list
4232 // once we know whether inlining succeeds or not. For regular
4233 // inlining, messages are appended to the buffer pointed by
4234 // _print_inlining_idx in the _print_inlining_list. For late inlining,
4235 // a new buffer is added after _print_inlining_idx in the list. This
4236 // way we can update the inlining message for late inlining call site
4237 // when the inlining is attempted again.
4238 void Compile::print_inlining_init() {
4239   if (print_inlining() || print_intrinsics()) {
4240     // print_inlining_init is actually called several times.
4241     print_inlining_stream_free();
4242     _print_inlining_stream = new stringStream();
4243     // Watch out: The memory initialized by the constructor call PrintInliningBuffer()
4244     // will be copied into the only initial element. The default destructor of
4245     // PrintInliningBuffer will be called when leaving the scope here. If it
4246     // would destuct the  enclosed stringStream _print_inlining_list[0]-&gt;_ss
4247     // would be destructed, too!
4248     _print_inlining_list = new (comp_arena())GrowableArray&lt;PrintInliningBuffer&gt;(comp_arena(), 1, 1, PrintInliningBuffer());
4249   }
4250 }
4251 
4252 void Compile::print_inlining_reinit() {
4253   if (print_inlining() || print_intrinsics()) {
4254     print_inlining_stream_free();
4255     // Re allocate buffer when we change ResourceMark
4256     _print_inlining_stream = new stringStream();
4257   }
4258 }
4259 
4260 void Compile::print_inlining_reset() {
4261   _print_inlining_stream-&gt;reset();
4262 }
4263 
4264 void Compile::print_inlining_commit() {
4265   assert(print_inlining() || print_intrinsics(), &quot;PrintInlining off?&quot;);
4266   // Transfer the message from _print_inlining_stream to the current
4267   // _print_inlining_list buffer and clear _print_inlining_stream.
4268   _print_inlining_list-&gt;at(_print_inlining_idx).ss()-&gt;write(_print_inlining_stream-&gt;base(), _print_inlining_stream-&gt;size());
4269   print_inlining_reset();
4270 }
4271 
4272 void Compile::print_inlining_push() {
4273   // Add new buffer to the _print_inlining_list at current position
4274   _print_inlining_idx++;
4275   _print_inlining_list-&gt;insert_before(_print_inlining_idx, PrintInliningBuffer());
4276 }
4277 
4278 Compile::PrintInliningBuffer&amp; Compile::print_inlining_current() {
4279   return _print_inlining_list-&gt;at(_print_inlining_idx);
4280 }
4281 
4282 void Compile::print_inlining_update(CallGenerator* cg) {
4283   if (print_inlining() || print_intrinsics()) {
4284     if (!cg-&gt;is_late_inline()) {
4285       if (print_inlining_current().cg() != NULL) {
4286         print_inlining_push();
4287       }
4288       print_inlining_commit();
4289     } else {
4290       if (print_inlining_current().cg() != cg &amp;&amp;
4291           (print_inlining_current().cg() != NULL ||
4292            print_inlining_current().ss()-&gt;size() != 0)) {
4293         print_inlining_push();
4294       }
4295       print_inlining_commit();
4296       print_inlining_current().set_cg(cg);
4297     }
4298   }
4299 }
4300 
4301 void Compile::print_inlining_move_to(CallGenerator* cg) {
4302   // We resume inlining at a late inlining call site. Locate the
4303   // corresponding inlining buffer so that we can update it.
4304   if (print_inlining()) {
4305     for (int i = 0; i &lt; _print_inlining_list-&gt;length(); i++) {
4306       if (_print_inlining_list-&gt;adr_at(i)-&gt;cg() == cg) {
4307         _print_inlining_idx = i;
4308         return;
4309       }
4310     }
4311     ShouldNotReachHere();
4312   }
4313 }
4314 
4315 void Compile::print_inlining_update_delayed(CallGenerator* cg) {
4316   if (print_inlining()) {
4317     assert(_print_inlining_stream-&gt;size() &gt; 0, &quot;missing inlining msg&quot;);
4318     assert(print_inlining_current().cg() == cg, &quot;wrong entry&quot;);
4319     // replace message with new message
4320     _print_inlining_list-&gt;at_put(_print_inlining_idx, PrintInliningBuffer());
4321     print_inlining_commit();
4322     print_inlining_current().set_cg(cg);
4323   }
4324 }
4325 
4326 void Compile::print_inlining_assert_ready() {
4327   assert(!_print_inlining || _print_inlining_stream-&gt;size() == 0, &quot;loosing data&quot;);
4328 }
4329 
4330 void Compile::process_print_inlining() {
4331   bool do_print_inlining = print_inlining() || print_intrinsics();
4332   if (do_print_inlining || log() != NULL) {
4333     // Print inlining message for candidates that we couldn&#39;t inline
4334     // for lack of space
4335     for (int i = 0; i &lt; _late_inlines.length(); i++) {
4336       CallGenerator* cg = _late_inlines.at(i);
4337       if (!cg-&gt;is_mh_late_inline()) {
4338         const char* msg = &quot;live nodes &gt; LiveNodeCountInliningCutoff&quot;;
4339         if (do_print_inlining) {
4340           cg-&gt;print_inlining_late(msg);
4341         }
4342         log_late_inline_failure(cg, msg);
4343       }
4344     }
4345   }
4346   if (do_print_inlining) {
4347     ResourceMark rm;
4348     stringStream ss;
4349     assert(_print_inlining_list != NULL, &quot;process_print_inlining should be called only once.&quot;);
4350     for (int i = 0; i &lt; _print_inlining_list-&gt;length(); i++) {
4351       ss.print(&quot;%s&quot;, _print_inlining_list-&gt;adr_at(i)-&gt;ss()-&gt;as_string());
4352       _print_inlining_list-&gt;at(i).freeStream();
4353     }
4354     // Reset _print_inlining_list, it only contains destructed objects.
4355     // It is on the arena, so it will be freed when the arena is reset.
4356     _print_inlining_list = NULL;
4357     // _print_inlining_stream won&#39;t be used anymore, either.
4358     print_inlining_stream_free();
4359     size_t end = ss.size();
4360     _print_inlining_output = NEW_ARENA_ARRAY(comp_arena(), char, end+1);
4361     strncpy(_print_inlining_output, ss.base(), end+1);
4362     _print_inlining_output[end] = 0;
4363   }
4364 }
4365 
4366 void Compile::dump_print_inlining() {
4367   if (_print_inlining_output != NULL) {
4368     tty-&gt;print_raw(_print_inlining_output);
4369   }
4370 }
4371 
4372 void Compile::log_late_inline(CallGenerator* cg) {
4373   if (log() != NULL) {
4374     log()-&gt;head(&quot;late_inline method=&#39;%d&#39;  inline_id=&#39;&quot; JLONG_FORMAT &quot;&#39;&quot;, log()-&gt;identify(cg-&gt;method()),
4375                 cg-&gt;unique_id());
4376     JVMState* p = cg-&gt;call_node()-&gt;jvms();
4377     while (p != NULL) {
4378       log()-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log()-&gt;identify(p-&gt;method()));
4379       p = p-&gt;caller();
4380     }
4381     log()-&gt;tail(&quot;late_inline&quot;);
4382   }
4383 }
4384 
4385 void Compile::log_late_inline_failure(CallGenerator* cg, const char* msg) {
4386   log_late_inline(cg);
4387   if (log() != NULL) {
4388     log()-&gt;inline_fail(msg);
4389   }
4390 }
4391 
4392 void Compile::log_inline_id(CallGenerator* cg) {
4393   if (log() != NULL) {
4394     // The LogCompilation tool needs a unique way to identify late
4395     // inline call sites. This id must be unique for this call site in
4396     // this compilation. Try to have it unique across compilations as
4397     // well because it can be convenient when grepping through the log
4398     // file.
4399     // Distinguish OSR compilations from others in case CICountOSR is
4400     // on.
4401     jlong id = ((jlong)unique()) + (((jlong)compile_id()) &lt;&lt; 33) + (CICountOSR &amp;&amp; is_osr_compilation() ? ((jlong)1) &lt;&lt; 32 : 0);
4402     cg-&gt;set_unique_id(id);
4403     log()-&gt;elem(&quot;inline_id id=&#39;&quot; JLONG_FORMAT &quot;&#39;&quot;, id);
4404   }
4405 }
4406 
4407 void Compile::log_inline_failure(const char* msg) {
4408   if (C-&gt;log() != NULL) {
4409     C-&gt;log()-&gt;inline_fail(msg);
4410   }
4411 }
4412 
4413 
4414 // Dump inlining replay data to the stream.
4415 // Don&#39;t change thread state and acquire any locks.
4416 void Compile::dump_inline_data(outputStream* out) {
4417   InlineTree* inl_tree = ilt();
4418   if (inl_tree != NULL) {
4419     out-&gt;print(&quot; inline %d&quot;, inl_tree-&gt;count());
4420     inl_tree-&gt;dump_replay_data(out);
4421   }
4422 }
4423 
4424 int Compile::cmp_expensive_nodes(Node* n1, Node* n2) {
4425   if (n1-&gt;Opcode() &lt; n2-&gt;Opcode())      return -1;
4426   else if (n1-&gt;Opcode() &gt; n2-&gt;Opcode()) return 1;
4427 
4428   assert(n1-&gt;req() == n2-&gt;req(), &quot;can&#39;t compare %s nodes: n1-&gt;req() = %d, n2-&gt;req() = %d&quot;, NodeClassNames[n1-&gt;Opcode()], n1-&gt;req(), n2-&gt;req());
4429   for (uint i = 1; i &lt; n1-&gt;req(); i++) {
4430     if (n1-&gt;in(i) &lt; n2-&gt;in(i))      return -1;
4431     else if (n1-&gt;in(i) &gt; n2-&gt;in(i)) return 1;
4432   }
4433 
4434   return 0;
4435 }
4436 
4437 int Compile::cmp_expensive_nodes(Node** n1p, Node** n2p) {
4438   Node* n1 = *n1p;
4439   Node* n2 = *n2p;
4440 
4441   return cmp_expensive_nodes(n1, n2);
4442 }
4443 
4444 void Compile::sort_expensive_nodes() {
4445   if (!expensive_nodes_sorted()) {
4446     _expensive_nodes-&gt;sort(cmp_expensive_nodes);
4447   }
4448 }
4449 
4450 bool Compile::expensive_nodes_sorted() const {
4451   for (int i = 1; i &lt; _expensive_nodes-&gt;length(); i++) {
4452     if (cmp_expensive_nodes(_expensive_nodes-&gt;adr_at(i), _expensive_nodes-&gt;adr_at(i-1)) &lt; 0) {
4453       return false;
4454     }
4455   }
4456   return true;
4457 }
4458 
4459 bool Compile::should_optimize_expensive_nodes(PhaseIterGVN &amp;igvn) {
4460   if (_expensive_nodes-&gt;length() == 0) {
4461     return false;
4462   }
4463 
4464   assert(OptimizeExpensiveOps, &quot;optimization off?&quot;);
4465 
4466   // Take this opportunity to remove dead nodes from the list
4467   int j = 0;
4468   for (int i = 0; i &lt; _expensive_nodes-&gt;length(); i++) {
4469     Node* n = _expensive_nodes-&gt;at(i);
4470     if (!n-&gt;is_unreachable(igvn)) {
4471       assert(n-&gt;is_expensive(), &quot;should be expensive&quot;);
4472       _expensive_nodes-&gt;at_put(j, n);
4473       j++;
4474     }
4475   }
4476   _expensive_nodes-&gt;trunc_to(j);
4477 
4478   // Then sort the list so that similar nodes are next to each other
4479   // and check for at least two nodes of identical kind with same data
4480   // inputs.
4481   sort_expensive_nodes();
4482 
4483   for (int i = 0; i &lt; _expensive_nodes-&gt;length()-1; i++) {
4484     if (cmp_expensive_nodes(_expensive_nodes-&gt;adr_at(i), _expensive_nodes-&gt;adr_at(i+1)) == 0) {
4485       return true;
4486     }
4487   }
4488 
4489   return false;
4490 }
4491 
4492 void Compile::cleanup_expensive_nodes(PhaseIterGVN &amp;igvn) {
4493   if (_expensive_nodes-&gt;length() == 0) {
4494     return;
4495   }
4496 
4497   assert(OptimizeExpensiveOps, &quot;optimization off?&quot;);
4498 
4499   // Sort to bring similar nodes next to each other and clear the
4500   // control input of nodes for which there&#39;s only a single copy.
4501   sort_expensive_nodes();
4502 
4503   int j = 0;
4504   int identical = 0;
4505   int i = 0;
4506   bool modified = false;
4507   for (; i &lt; _expensive_nodes-&gt;length()-1; i++) {
4508     assert(j &lt;= i, &quot;can&#39;t write beyond current index&quot;);
4509     if (_expensive_nodes-&gt;at(i)-&gt;Opcode() == _expensive_nodes-&gt;at(i+1)-&gt;Opcode()) {
4510       identical++;
4511       _expensive_nodes-&gt;at_put(j++, _expensive_nodes-&gt;at(i));
4512       continue;
4513     }
4514     if (identical &gt; 0) {
4515       _expensive_nodes-&gt;at_put(j++, _expensive_nodes-&gt;at(i));
4516       identical = 0;
4517     } else {
4518       Node* n = _expensive_nodes-&gt;at(i);
4519       igvn.replace_input_of(n, 0, NULL);
4520       igvn.hash_insert(n);
4521       modified = true;
4522     }
4523   }
4524   if (identical &gt; 0) {
4525     _expensive_nodes-&gt;at_put(j++, _expensive_nodes-&gt;at(i));
4526   } else if (_expensive_nodes-&gt;length() &gt;= 1) {
4527     Node* n = _expensive_nodes-&gt;at(i);
4528     igvn.replace_input_of(n, 0, NULL);
4529     igvn.hash_insert(n);
4530     modified = true;
4531   }
4532   _expensive_nodes-&gt;trunc_to(j);
4533   if (modified) {
4534     igvn.optimize();
4535   }
4536 }
4537 
4538 void Compile::add_expensive_node(Node * n) {
4539   assert(!_expensive_nodes-&gt;contains(n), &quot;duplicate entry in expensive list&quot;);
4540   assert(n-&gt;is_expensive(), &quot;expensive nodes with non-null control here only&quot;);
4541   assert(!n-&gt;is_CFG() &amp;&amp; !n-&gt;is_Mem(), &quot;no cfg or memory nodes here&quot;);
4542   if (OptimizeExpensiveOps) {
4543     _expensive_nodes-&gt;append(n);
4544   } else {
4545     // Clear control input and let IGVN optimize expensive nodes if
4546     // OptimizeExpensiveOps is off.
4547     n-&gt;set_req(0, NULL);
4548   }
4549 }
4550 
4551 /**
4552  * Remove the speculative part of types and clean up the graph
4553  */
4554 void Compile::remove_speculative_types(PhaseIterGVN &amp;igvn) {
4555   if (UseTypeSpeculation) {
4556     Unique_Node_List worklist;
4557     worklist.push(root());
4558     int modified = 0;
4559     // Go over all type nodes that carry a speculative type, drop the
4560     // speculative part of the type and enqueue the node for an igvn
4561     // which may optimize it out.
4562     for (uint next = 0; next &lt; worklist.size(); ++next) {
4563       Node *n  = worklist.at(next);
4564       if (n-&gt;is_Type()) {
4565         TypeNode* tn = n-&gt;as_Type();
4566         const Type* t = tn-&gt;type();
4567         const Type* t_no_spec = t-&gt;remove_speculative();
4568         if (t_no_spec != t) {
4569           bool in_hash = igvn.hash_delete(n);
4570           assert(in_hash, &quot;node should be in igvn hash table&quot;);
4571           tn-&gt;set_type(t_no_spec);
4572           igvn.hash_insert(n);
4573           igvn._worklist.push(n); // give it a chance to go away
4574           modified++;
4575         }
4576       }
4577       uint max = n-&gt;len();
4578       for( uint i = 0; i &lt; max; ++i ) {
4579         Node *m = n-&gt;in(i);
4580         if (not_a_node(m))  continue;
4581         worklist.push(m);
4582       }
4583     }
4584     // Drop the speculative part of all types in the igvn&#39;s type table
4585     igvn.remove_speculative_types();
4586     if (modified &gt; 0) {
4587       igvn.optimize();
4588     }
4589 #ifdef ASSERT
4590     // Verify that after the IGVN is over no speculative type has resurfaced
4591     worklist.clear();
4592     worklist.push(root());
4593     for (uint next = 0; next &lt; worklist.size(); ++next) {
4594       Node *n  = worklist.at(next);
4595       const Type* t = igvn.type_or_null(n);
4596       assert((t == NULL) || (t == t-&gt;remove_speculative()), &quot;no more speculative types&quot;);
4597       if (n-&gt;is_Type()) {
4598         t = n-&gt;as_Type()-&gt;type();
4599         assert(t == t-&gt;remove_speculative(), &quot;no more speculative types&quot;);
4600       }
4601       uint max = n-&gt;len();
4602       for( uint i = 0; i &lt; max; ++i ) {
4603         Node *m = n-&gt;in(i);
4604         if (not_a_node(m))  continue;
4605         worklist.push(m);
4606       }
4607     }
4608     igvn.check_no_speculative_types();
4609 #endif
4610   }
4611 }
4612 
4613 Node* Compile::optimize_acmp(PhaseGVN* phase, Node* a, Node* b) {
4614   const TypeInstPtr* ta = phase-&gt;type(a)-&gt;isa_instptr();
4615   const TypeInstPtr* tb = phase-&gt;type(b)-&gt;isa_instptr();
4616   if (!EnableValhalla || ta == NULL || tb == NULL ||
4617       ta-&gt;is_zero_type() || tb-&gt;is_zero_type() ||
4618       !ta-&gt;can_be_value_type() || !tb-&gt;can_be_value_type()) {
4619     // Use old acmp if one operand is null or not a value type
4620     return new CmpPNode(a, b);
4621   } else if (ta-&gt;is_valuetypeptr() || tb-&gt;is_valuetypeptr()) {
4622     // We know that one operand is a value type. Therefore,
4623     // new acmp will only return true if both operands are NULL.
4624     // Check if both operands are null by or&#39;ing the oops.
4625     a = phase-&gt;transform(new CastP2XNode(NULL, a));
4626     b = phase-&gt;transform(new CastP2XNode(NULL, b));
4627     a = phase-&gt;transform(new OrXNode(a, b));
4628     return new CmpXNode(a, phase-&gt;MakeConX(0));
4629   }
4630   // Use new acmp
4631   return NULL;
4632 }
4633 
4634 // Auxiliary method to support randomized stressing/fuzzing.
4635 //
4636 // This method can be called the arbitrary number of times, with current count
4637 // as the argument. The logic allows selecting a single candidate from the
4638 // running list of candidates as follows:
4639 //    int count = 0;
4640 //    Cand* selected = null;
4641 //    while(cand = cand-&gt;next()) {
4642 //      if (randomized_select(++count)) {
4643 //        selected = cand;
4644 //      }
4645 //    }
4646 //
4647 // Including count equalizes the chances any candidate is &quot;selected&quot;.
4648 // This is useful when we don&#39;t have the complete list of candidates to choose
4649 // from uniformly. In this case, we need to adjust the randomicity of the
4650 // selection, or else we will end up biasing the selection towards the latter
4651 // candidates.
4652 //
4653 // Quick back-envelope calculation shows that for the list of n candidates
4654 // the equal probability for the candidate to persist as &quot;best&quot; can be
4655 // achieved by replacing it with &quot;next&quot; k-th candidate with the probability
4656 // of 1/k. It can be easily shown that by the end of the run, the
4657 // probability for any candidate is converged to 1/n, thus giving the
4658 // uniform distribution among all the candidates.
4659 //
4660 // We don&#39;t care about the domain size as long as (RANDOMIZED_DOMAIN / count) is large.
4661 #define RANDOMIZED_DOMAIN_POW 29
4662 #define RANDOMIZED_DOMAIN (1 &lt;&lt; RANDOMIZED_DOMAIN_POW)
4663 #define RANDOMIZED_DOMAIN_MASK ((1 &lt;&lt; (RANDOMIZED_DOMAIN_POW + 1)) - 1)
4664 bool Compile::randomized_select(int count) {
4665   assert(count &gt; 0, &quot;only positive&quot;);
4666   return (os::random() &amp; RANDOMIZED_DOMAIN_MASK) &lt; (RANDOMIZED_DOMAIN / count);
4667 }
4668 
4669 CloneMap&amp;     Compile::clone_map()                 { return _clone_map; }
4670 void          Compile::set_clone_map(Dict* d)      { _clone_map._dict = d; }
4671 
4672 void NodeCloneInfo::dump() const {
4673   tty-&gt;print(&quot; {%d:%d} &quot;, idx(), gen());
4674 }
4675 
4676 void CloneMap::clone(Node* old, Node* nnn, int gen) {
4677   uint64_t val = value(old-&gt;_idx);
4678   NodeCloneInfo cio(val);
4679   assert(val != 0, &quot;old node should be in the map&quot;);
4680   NodeCloneInfo cin(cio.idx(), gen + cio.gen());
4681   insert(nnn-&gt;_idx, cin.get());
4682 #ifndef PRODUCT
4683   if (is_debug()) {
4684     tty-&gt;print_cr(&quot;CloneMap::clone inserted node %d info {%d:%d} into CloneMap&quot;, nnn-&gt;_idx, cin.idx(), cin.gen());
4685   }
4686 #endif
4687 }
4688 
4689 void CloneMap::verify_insert_and_clone(Node* old, Node* nnn, int gen) {
4690   NodeCloneInfo cio(value(old-&gt;_idx));
4691   if (cio.get() == 0) {
4692     cio.set(old-&gt;_idx, 0);
4693     insert(old-&gt;_idx, cio.get());
4694 #ifndef PRODUCT
4695     if (is_debug()) {
4696       tty-&gt;print_cr(&quot;CloneMap::verify_insert_and_clone inserted node %d info {%d:%d} into CloneMap&quot;, old-&gt;_idx, cio.idx(), cio.gen());
4697     }
4698 #endif
4699   }
4700   clone(old, nnn, gen);
4701 }
4702 
4703 int CloneMap::max_gen() const {
4704   int g = 0;
4705   DictI di(_dict);
4706   for(; di.test(); ++di) {
4707     int t = gen(di._key);
4708     if (g &lt; t) {
4709       g = t;
4710 #ifndef PRODUCT
4711       if (is_debug()) {
4712         tty-&gt;print_cr(&quot;CloneMap::max_gen() update max=%d from %d&quot;, g, _2_node_idx_t(di._key));
4713       }
4714 #endif
4715     }
4716   }
4717   return g;
4718 }
4719 
4720 void CloneMap::dump(node_idx_t key) const {
4721   uint64_t val = value(key);
4722   if (val != 0) {
4723     NodeCloneInfo ni(val);
4724     ni.dump();
4725   }
4726 }
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/vectornode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vectornode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jni.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/vectornode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
128   virtual int Opcode() const;
129 };
130 
131 //------------------------------AddVDNode--------------------------------------
132 // Vector add double
133 class AddVDNode : public VectorNode {
134 public:
135   AddVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
136   virtual int Opcode() const;
137 };
138 
139 //------------------------------ReductionNode------------------------------------
140 // Perform reduction of a vector
141 class ReductionNode : public Node {
142  public:
143   ReductionNode(Node *ctrl, Node* in1, Node* in2) : Node(ctrl, in1, in2) {}
144 
145   static ReductionNode* make(int opc, Node *ctrl, Node* in1, Node* in2, BasicType bt);
146   static int  opcode(int opc, BasicType bt);
147   static bool implemented(int opc, uint vlen, BasicType bt);









148 };
149 
150 //------------------------------AddReductionVINode--------------------------------------
151 // Vector add int as a reduction
152 class AddReductionVINode : public ReductionNode {
153 public:
154   AddReductionVINode(Node * ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
155   virtual int Opcode() const;
156   virtual const Type* bottom_type() const { return TypeInt::INT; }
157   virtual uint ideal_reg() const { return Op_RegI; }
158 };
159 
160 //------------------------------AddReductionVLNode--------------------------------------
161 // Vector add long as a reduction
162 class AddReductionVLNode : public ReductionNode {
163 public:
164   AddReductionVLNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
165   virtual int Opcode() const;
166   virtual const Type* bottom_type() const { return TypeLong::LONG; }
167   virtual uint ideal_reg() const { return Op_RegL; }
</pre>
<hr />
<pre>
596   AndVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
597   virtual int Opcode() const;
598 };
599 
600 //------------------------------OrVNode---------------------------------------
601 // Vector or integer
602 class OrVNode : public VectorNode {
603  public:
604   OrVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
605   virtual int Opcode() const;
606 };
607 
608 //------------------------------XorVNode---------------------------------------
609 // Vector xor integer
610 class XorVNode : public VectorNode {
611  public:
612   XorVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
613   virtual int Opcode() const;
614 };
615 
























616 //------------------------------MinVNode--------------------------------------
617 // Vector min
618 class MinVNode : public VectorNode {
619 public:
620   MinVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
621   virtual int Opcode() const;
622 };
623 
624 //------------------------------MaxVNode--------------------------------------
625 // Vector max
626 class MaxVNode : public VectorNode {
627 public:
628   MaxVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
629   virtual int Opcode() const;
630 };
631 
632 //------------------------------MinReductionVNode--------------------------------------
633 // Vector min as a reduction
634 class MinReductionVNode : public ReductionNode {
635 public:
636   MinReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
637   virtual int Opcode() const;
<span class="line-removed">638   virtual const Type* bottom_type() const {</span>
<span class="line-removed">639     BasicType bt = in(1)-&gt;bottom_type()-&gt;basic_type();</span>
<span class="line-removed">640     if (bt == T_FLOAT) {</span>
<span class="line-removed">641       return Type::FLOAT;</span>
<span class="line-removed">642     } else if (bt == T_DOUBLE) {</span>
<span class="line-removed">643       return Type::DOUBLE;</span>
<span class="line-removed">644     }</span>
<span class="line-removed">645     assert(false, &quot;unsupported basic type&quot;);</span>
<span class="line-removed">646     return NULL;</span>
<span class="line-removed">647   }</span>
<span class="line-removed">648   virtual uint ideal_reg() const {</span>
<span class="line-removed">649     BasicType bt = in(1)-&gt;bottom_type()-&gt;basic_type();</span>
<span class="line-removed">650     if (bt == T_FLOAT) {</span>
<span class="line-removed">651       return Op_RegF;</span>
<span class="line-removed">652     } else if (bt == T_DOUBLE) {</span>
<span class="line-removed">653       return Op_RegD;</span>
<span class="line-removed">654     }</span>
<span class="line-removed">655     assert(false, &quot;unsupported basic type&quot;);</span>
<span class="line-removed">656     return 0;</span>
<span class="line-removed">657   }</span>
658 };
659 
660 //------------------------------MaxReductionVNode--------------------------------------
661 // Vector max as a reduction
662 class MaxReductionVNode : public ReductionNode {
663 public:
664   MaxReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
665   virtual int Opcode() const;
<span class="line-removed">666   virtual const Type* bottom_type() const {</span>
<span class="line-removed">667     BasicType bt = in(1)-&gt;bottom_type()-&gt;basic_type();</span>
<span class="line-removed">668     if (bt == T_FLOAT) {</span>
<span class="line-removed">669       return Type::FLOAT;</span>
<span class="line-removed">670     } else {</span>
<span class="line-removed">671       return Type::DOUBLE;</span>
<span class="line-removed">672     }</span>
<span class="line-removed">673     assert(false, &quot;unsupported basic type&quot;);</span>
<span class="line-removed">674     return NULL;</span>
<span class="line-removed">675   }</span>
<span class="line-removed">676   virtual uint ideal_reg() const {</span>
<span class="line-removed">677     BasicType bt = in(1)-&gt;bottom_type()-&gt;basic_type();</span>
<span class="line-removed">678     if (bt == T_FLOAT) {</span>
<span class="line-removed">679       return Op_RegF;</span>
<span class="line-removed">680     } else {</span>
<span class="line-removed">681       return Op_RegD;</span>
<span class="line-removed">682     }</span>
<span class="line-removed">683     assert(false, &quot;unsupported basic type&quot;);</span>
<span class="line-removed">684     return 0;</span>
<span class="line-removed">685   }</span>
686 };
687 
688 //================================= M E M O R Y ===============================
689 
690 //------------------------------LoadVectorNode---------------------------------
691 // Load Vector from memory
692 class LoadVectorNode : public LoadNode {
693  public:
694   LoadVectorNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, ControlDependency control_dependency = LoadNode::DependsOnlyOnTest)
695     : LoadNode(c, mem, adr, at, vt, MemNode::unordered, control_dependency) {
696     init_class_id(Class_LoadVector);
697     set_mismatched_access();
698   }
699 
700   const TypeVect* vect_type() const { return type()-&gt;is_vect(); }
701   uint length() const { return vect_type()-&gt;length(); } // Vector length
702 
703   virtual int Opcode() const;
704 
705   virtual uint ideal_reg() const  { return Matcher::vector_ideal_reg(memory_size()); }
</pre>
</td>
<td>
<hr />
<pre>
128   virtual int Opcode() const;
129 };
130 
131 //------------------------------AddVDNode--------------------------------------
132 // Vector add double
133 class AddVDNode : public VectorNode {
134 public:
135   AddVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
136   virtual int Opcode() const;
137 };
138 
139 //------------------------------ReductionNode------------------------------------
140 // Perform reduction of a vector
141 class ReductionNode : public Node {
142  public:
143   ReductionNode(Node *ctrl, Node* in1, Node* in2) : Node(ctrl, in1, in2) {}
144 
145   static ReductionNode* make(int opc, Node *ctrl, Node* in1, Node* in2, BasicType bt);
146   static int  opcode(int opc, BasicType bt);
147   static bool implemented(int opc, uint vlen, BasicType bt);
<span class="line-added">148 </span>
<span class="line-added">149   virtual const Type* bottom_type() const {</span>
<span class="line-added">150     BasicType vbt = in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type();</span>
<span class="line-added">151     return Type::get_const_basic_type(vbt);</span>
<span class="line-added">152   }</span>
<span class="line-added">153 </span>
<span class="line-added">154   virtual uint ideal_reg() const {</span>
<span class="line-added">155     return bottom_type()-&gt;ideal_reg();</span>
<span class="line-added">156   }</span>
157 };
158 
159 //------------------------------AddReductionVINode--------------------------------------
160 // Vector add int as a reduction
161 class AddReductionVINode : public ReductionNode {
162 public:
163   AddReductionVINode(Node * ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
164   virtual int Opcode() const;
165   virtual const Type* bottom_type() const { return TypeInt::INT; }
166   virtual uint ideal_reg() const { return Op_RegI; }
167 };
168 
169 //------------------------------AddReductionVLNode--------------------------------------
170 // Vector add long as a reduction
171 class AddReductionVLNode : public ReductionNode {
172 public:
173   AddReductionVLNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
174   virtual int Opcode() const;
175   virtual const Type* bottom_type() const { return TypeLong::LONG; }
176   virtual uint ideal_reg() const { return Op_RegL; }
</pre>
<hr />
<pre>
605   AndVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
606   virtual int Opcode() const;
607 };
608 
609 //------------------------------OrVNode---------------------------------------
610 // Vector or integer
611 class OrVNode : public VectorNode {
612  public:
613   OrVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
614   virtual int Opcode() const;
615 };
616 
617 //------------------------------XorVNode---------------------------------------
618 // Vector xor integer
619 class XorVNode : public VectorNode {
620  public:
621   XorVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
622   virtual int Opcode() const;
623 };
624 
<span class="line-added">625 //------------------------------AndReductionVNode--------------------------------------</span>
<span class="line-added">626 // Vector and int, long as a reduction</span>
<span class="line-added">627 class AndReductionVNode : public ReductionNode {</span>
<span class="line-added">628 public:</span>
<span class="line-added">629   AndReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}</span>
<span class="line-added">630   virtual int Opcode() const;</span>
<span class="line-added">631 };</span>
<span class="line-added">632 </span>
<span class="line-added">633 //------------------------------OrReductionVNode--------------------------------------</span>
<span class="line-added">634 // Vector or int, long as a reduction</span>
<span class="line-added">635 class OrReductionVNode : public ReductionNode {</span>
<span class="line-added">636 public:</span>
<span class="line-added">637   OrReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}</span>
<span class="line-added">638   virtual int Opcode() const;</span>
<span class="line-added">639 };</span>
<span class="line-added">640 </span>
<span class="line-added">641 //------------------------------XorReductionVNode--------------------------------------</span>
<span class="line-added">642 // Vector xor int, long as a reduction</span>
<span class="line-added">643 class XorReductionVNode : public ReductionNode {</span>
<span class="line-added">644 public:</span>
<span class="line-added">645   XorReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}</span>
<span class="line-added">646   virtual int Opcode() const;</span>
<span class="line-added">647 };</span>
<span class="line-added">648 </span>
649 //------------------------------MinVNode--------------------------------------
650 // Vector min
651 class MinVNode : public VectorNode {
652 public:
653   MinVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
654   virtual int Opcode() const;
655 };
656 
657 //------------------------------MaxVNode--------------------------------------
658 // Vector max
659 class MaxVNode : public VectorNode {
660 public:
661   MaxVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
662   virtual int Opcode() const;
663 };
664 
665 //------------------------------MinReductionVNode--------------------------------------
666 // Vector min as a reduction
667 class MinReductionVNode : public ReductionNode {
668 public:
669   MinReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
670   virtual int Opcode() const;




















671 };
672 
673 //------------------------------MaxReductionVNode--------------------------------------
674 // Vector max as a reduction
675 class MaxReductionVNode : public ReductionNode {
676 public:
677   MaxReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
678   virtual int Opcode() const;




















679 };
680 
681 //================================= M E M O R Y ===============================
682 
683 //------------------------------LoadVectorNode---------------------------------
684 // Load Vector from memory
685 class LoadVectorNode : public LoadNode {
686  public:
687   LoadVectorNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, ControlDependency control_dependency = LoadNode::DependsOnlyOnTest)
688     : LoadNode(c, mem, adr, at, vt, MemNode::unordered, control_dependency) {
689     init_class_id(Class_LoadVector);
690     set_mismatched_access();
691   }
692 
693   const TypeVect* vect_type() const { return type()-&gt;is_vect(); }
694   uint length() const { return vect_type()-&gt;length(); } // Vector length
695 
696   virtual int Opcode() const;
697 
698   virtual uint ideal_reg() const  { return Matcher::vector_ideal_reg(memory_size()); }
</pre>
</td>
</tr>
</table>
<center><a href="vectornode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jni.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
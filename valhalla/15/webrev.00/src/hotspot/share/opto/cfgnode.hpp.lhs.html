<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/cfgnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OPTO_CFGNODE_HPP
 26 #define SHARE_OPTO_CFGNODE_HPP
 27 
 28 #include &quot;opto/multnode.hpp&quot;
 29 #include &quot;opto/node.hpp&quot;
 30 #include &quot;opto/opcodes.hpp&quot;
 31 #include &quot;opto/type.hpp&quot;
 32 
 33 // Portions of code courtesy of Clifford Click
 34 
 35 // Optimization - Graph Style
 36 
 37 class Matcher;
 38 class Node;
 39 class   RegionNode;
 40 class   TypeNode;
 41 class     PhiNode;
 42 class   GotoNode;
 43 class   MultiNode;
 44 class     MultiBranchNode;
 45 class       IfNode;
 46 class       PCTableNode;
 47 class         JumpNode;
 48 class         CatchNode;
 49 class       NeverBranchNode;
 50 class   ProjNode;
 51 class     CProjNode;
 52 class       IfTrueNode;
 53 class       IfFalseNode;
 54 class       CatchProjNode;
 55 class     JProjNode;
 56 class       JumpProjNode;
 57 class     SCMemProjNode;
 58 class PhaseIdealLoop;
 59 
 60 //------------------------------RegionNode-------------------------------------
 61 // The class of RegionNodes, which can be mapped to basic blocks in the
 62 // program.  Their inputs point to Control sources.  PhiNodes (described
 63 // below) have an input point to a RegionNode.  Merged data inputs to PhiNodes
 64 // correspond 1-to-1 with RegionNode inputs.  The zero input of a PhiNode is
 65 // the RegionNode, and the zero input of the RegionNode is itself.
 66 class RegionNode : public Node {
 67 public:
 68   // Node layout (parallels PhiNode):
 69   enum { Region,                // Generally points to self.
 70          Control                // Control arcs are [1..len)
 71   };
 72 
 73   RegionNode( uint required ) : Node(required) {
 74     init_class_id(Class_Region);
 75     init_req(0,this);
 76   }
 77 
 78   Node* is_copy() const {
 79     const Node* r = _in[Region];
 80     if (r == NULL)
 81       return nonnull_req();
 82     return NULL;  // not a copy!
 83   }
 84   PhiNode* has_phi() const;        // returns an arbitrary phi user, or NULL
 85   PhiNode* has_unique_phi() const; // returns the unique phi user, or NULL
 86   // Is this region node unreachable from root?
 87   bool is_unreachable_region(PhaseGVN *phase) const;
 88   virtual int Opcode() const;
 89   virtual bool pinned() const { return (const Node *)in(0) == this; }
 90   virtual bool  is_CFG   () const { return true; }
 91   virtual uint hash() const { return NO_HASH; }  // CFG nodes do not hash
 92   virtual bool depends_only_on_test() const { return false; }
 93   virtual const Type *bottom_type() const { return Type::CONTROL; }
 94   virtual const Type* Value(PhaseGVN* phase) const;
 95   virtual Node* Identity(PhaseGVN* phase);
 96   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 97   virtual const RegMask &amp;out_RegMask() const;
 98   bool optimize_trichotomy(PhaseIterGVN* igvn);
 99 };
100 
101 //------------------------------JProjNode--------------------------------------
102 // jump projection for node that produces multiple control-flow paths
103 class JProjNode : public ProjNode {
104  public:
105   JProjNode( Node* ctrl, uint idx ) : ProjNode(ctrl,idx) {}
106   virtual int Opcode() const;
107   virtual bool  is_CFG() const { return true; }
108   virtual uint  hash() const { return NO_HASH; }  // CFG nodes do not hash
109   virtual const Node* is_block_proj() const { return in(0); }
110   virtual const RegMask&amp; out_RegMask() const;
111   virtual uint  ideal_reg() const { return 0; }
112 };
113 
114 //------------------------------PhiNode----------------------------------------
115 // PhiNodes merge values from different Control paths.  Slot 0 points to the
116 // controlling RegionNode.  Other slots map 1-for-1 with incoming control flow
117 // paths to the RegionNode.  For speed reasons (to avoid another pass) we
118 // can turn PhiNodes into copys in-place by NULL&#39;ing out their RegionNode
119 // input in slot 0.
120 class PhiNode : public TypeNode {
121   friend class PhaseRenumberLive;
122 
123   const TypePtr* const _adr_type; // non-null only for Type::MEMORY nodes.
124   // The following fields are only used for data PhiNodes to indicate
125   // that the PhiNode represents the value of a known instance field.
126         int _inst_mem_id; // Instance memory id (node index of the memory Phi)
127         int _inst_id;     // Instance id of the memory slice.
128   const int _inst_index;  // Alias index of the instance memory slice.
129   // Array elements references have the same alias_idx but different offset.
130   const int _inst_offset; // Offset of the instance memory slice.
131   // Size is bigger to hold the _adr_type field.
132   virtual uint hash() const;    // Check the type
133   virtual bool cmp( const Node &amp;n ) const;
134   virtual uint size_of() const { return sizeof(*this); }
135 
136   // Determine if CMoveNode::is_cmove_id can be used at this join point.
137   Node* is_cmove_id(PhaseTransform* phase, int true_path);
<a name="1" id="anc1"></a>
138 
139 public:
140   // Node layout (parallels RegionNode):
141   enum { Region,                // Control input is the Phi&#39;s region.
142          Input                  // Input values are [1..len)
143   };
144 
145   PhiNode( Node *r, const Type *t, const TypePtr* at = NULL,
146            const int imid = -1,
147            const int iid = TypeOopPtr::InstanceTop,
148            const int iidx = Compile::AliasIdxTop,
149            const int ioffs = Type::OffsetTop )
150     : TypeNode(t,r-&gt;req()),
151       _adr_type(at),
152       _inst_mem_id(imid),
153       _inst_id(iid),
154       _inst_index(iidx),
155       _inst_offset(ioffs)
156   {
157     init_class_id(Class_Phi);
158     init_req(0, r);
159     verify_adr_type();
160   }
161   // create a new phi with in edges matching r and set (initially) to x
162   static PhiNode* make( Node* r, Node* x );
163   // extra type arguments override the new phi&#39;s bottom_type and adr_type
164   static PhiNode* make( Node* r, Node* x, const Type *t, const TypePtr* at = NULL );
165   // create a new phi with narrowed memory type
166   PhiNode* slice_memory(const TypePtr* adr_type) const;
167   PhiNode* split_out_instance(const TypePtr* at, PhaseIterGVN *igvn) const;
168   // like make(r, x), but does not initialize the in edges to x
169   static PhiNode* make_blank( Node* r, Node* x );
170 
171   // Accessors
172   RegionNode* region() const { Node* r = in(Region); assert(!r || r-&gt;is_Region(), &quot;&quot;); return (RegionNode*)r; }
173 
174   Node* is_copy() const {
175     // The node is a real phi if _in[0] is a Region node.
176     DEBUG_ONLY(const Node* r = _in[Region];)
177     assert(r != NULL &amp;&amp; r-&gt;is_Region(), &quot;Not valid control&quot;);
178     return NULL;  // not a copy!
179   }
180 
181   bool is_tripcount() const;
182 
183   // Determine a unique non-trivial input, if any.
184   // Ignore casts if it helps.  Return NULL on failure.
185   Node* unique_input(PhaseTransform *phase, bool uncast);
186   Node* unique_input(PhaseTransform *phase) {
187     Node* uin = unique_input(phase, false);
188     if (uin == NULL) {
189       uin = unique_input(phase, true);
190     }
191     return uin;
192   }
193 
194   // Check for a simple dead loop.
195   enum LoopSafety { Safe = 0, Unsafe, UnsafeLoop };
196   LoopSafety simple_data_loop_check(Node *in) const;
197   // Is it unsafe data loop? It becomes a dead loop if this phi node removed.
198   bool is_unsafe_data_reference(Node *in) const;
199   int  is_diamond_phi(bool check_control_only = false) const;
200   virtual int Opcode() const;
201   virtual bool pinned() const { return in(0) != 0; }
202   virtual const TypePtr *adr_type() const { verify_adr_type(true); return _adr_type; }
203 
204   void  set_inst_mem_id(int inst_mem_id) { _inst_mem_id = inst_mem_id; }
205   const int inst_mem_id() const { return _inst_mem_id; }
206   const int inst_id()     const { return _inst_id; }
207   const int inst_index()  const { return _inst_index; }
208   const int inst_offset() const { return _inst_offset; }
209   bool is_same_inst_field(const Type* tp, int mem_id, int id, int index, int offset) {
210     return type()-&gt;basic_type() == tp-&gt;basic_type() &amp;&amp;
211            inst_mem_id() == mem_id &amp;&amp;
212            inst_id()     == id     &amp;&amp;
213            inst_index()  == index  &amp;&amp;
214            inst_offset() == offset &amp;&amp;
215            type()-&gt;higher_equal(tp);
216   }
217   Node* try_clean_mem_phi(PhaseGVN *phase);
218 
219   virtual const Type* Value(PhaseGVN* phase) const;
220   virtual Node* Identity(PhaseGVN* phase);
221   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
222   virtual const RegMask &amp;out_RegMask() const;
223   virtual const RegMask &amp;in_RegMask(uint) const;
224 #ifndef PRODUCT
225   virtual void related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const;
226   virtual void dump_spec(outputStream *st) const;
227 #endif
228 #ifdef ASSERT
229   void verify_adr_type(VectorSet&amp; visited, const TypePtr* at) const;
230   void verify_adr_type(bool recursive = false) const;
231 #else //ASSERT
232   void verify_adr_type(bool recursive = false) const {}
233 #endif //ASSERT
234 };
235 
236 //------------------------------GotoNode---------------------------------------
237 // GotoNodes perform direct branches.
238 class GotoNode : public Node {
239 public:
240   GotoNode( Node *control ) : Node(control) {}
241   virtual int Opcode() const;
242   virtual bool pinned() const { return true; }
243   virtual bool  is_CFG() const { return true; }
244   virtual uint hash() const { return NO_HASH; }  // CFG nodes do not hash
245   virtual const Node *is_block_proj() const { return this; }
246   virtual bool depends_only_on_test() const { return false; }
247   virtual const Type *bottom_type() const { return Type::CONTROL; }
248   virtual const Type* Value(PhaseGVN* phase) const;
249   virtual Node* Identity(PhaseGVN* phase);
250   virtual const RegMask &amp;out_RegMask() const;
251 
252 #ifndef PRODUCT
253   virtual void related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const;
254 #endif
255 };
256 
257 //------------------------------CProjNode--------------------------------------
258 // control projection for node that produces multiple control-flow paths
259 class CProjNode : public ProjNode {
260 public:
261   CProjNode( Node *ctrl, uint idx ) : ProjNode(ctrl,idx) {}
262   virtual int Opcode() const;
263   virtual bool  is_CFG() const { return true; }
264   virtual uint hash() const { return NO_HASH; }  // CFG nodes do not hash
265   virtual const Node *is_block_proj() const { return in(0); }
266   virtual const RegMask &amp;out_RegMask() const;
267   virtual uint ideal_reg() const { return 0; }
268 };
269 
270 //---------------------------MultiBranchNode-----------------------------------
271 // This class defines a MultiBranchNode, a MultiNode which yields multiple
272 // control values. These are distinguished from other types of MultiNodes
273 // which yield multiple values, but control is always and only projection #0.
274 class MultiBranchNode : public MultiNode {
275 public:
276   MultiBranchNode( uint required ) : MultiNode(required) {
277     init_class_id(Class_MultiBranch);
278   }
279   // returns required number of users to be well formed.
280   virtual int required_outcnt() const = 0;
281 };
282 
283 //------------------------------IfNode-----------------------------------------
284 // Output selected Control, based on a boolean test
285 class IfNode : public MultiBranchNode {
286   // Size is bigger to hold the probability field.  However, _prob does not
287   // change the semantics so it does not appear in the hash &amp; cmp functions.
288   virtual uint size_of() const { return sizeof(*this); }
289 
290 private:
291   // Helper methods for fold_compares
292   bool cmpi_folds(PhaseIterGVN* igvn, bool fold_ne = false);
293   bool is_ctrl_folds(Node* ctrl, PhaseIterGVN* igvn);
294   bool has_shared_region(ProjNode* proj, ProjNode*&amp; success, ProjNode*&amp; fail);
295   bool has_only_uncommon_traps(ProjNode* proj, ProjNode*&amp; success, ProjNode*&amp; fail, PhaseIterGVN* igvn);
296   Node* merge_uncommon_traps(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn);
297   static void improve_address_types(Node* l, Node* r, ProjNode* fail, PhaseIterGVN* igvn);
298   bool is_cmp_with_loadrange(ProjNode* proj);
299   bool is_null_check(ProjNode* proj, PhaseIterGVN* igvn);
300   bool is_side_effect_free_test(ProjNode* proj, PhaseIterGVN* igvn);
301   void reroute_side_effect_free_unc(ProjNode* proj, ProjNode* dom_proj, PhaseIterGVN* igvn);
302   ProjNode* uncommon_trap_proj(CallStaticJavaNode*&amp; call) const;
303   bool fold_compares_helper(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn);
304   static bool is_dominator_unc(CallStaticJavaNode* dom_unc, CallStaticJavaNode* unc);
305 
306 protected:
307   ProjNode* range_check_trap_proj(int&amp; flip, Node*&amp; l, Node*&amp; r);
308   Node* Ideal_common(PhaseGVN *phase, bool can_reshape);
309   Node* search_identical(int dist);
310 
311   Node* simple_subsuming(PhaseIterGVN* igvn);
312 
313 public:
314 
315   // Degrees of branch prediction probability by order of magnitude:
316   // PROB_UNLIKELY_1e(N) is a 1 in 1eN chance.
317   // PROB_LIKELY_1e(N) is a 1 - PROB_UNLIKELY_1e(N)
318 #define PROB_UNLIKELY_MAG(N)    (1e- ## N ## f)
319 #define PROB_LIKELY_MAG(N)      (1.0f-PROB_UNLIKELY_MAG(N))
320 
321   // Maximum and minimum branch prediction probabilties
322   // 1 in 1,000,000 (magnitude 6)
323   //
324   // Although PROB_NEVER == PROB_MIN and PROB_ALWAYS == PROB_MAX
325   // they are used to distinguish different situations:
326   //
327   // The name PROB_MAX (PROB_MIN) is for probabilities which correspond to
328   // very likely (unlikely) but with a concrete possibility of a rare
329   // contrary case.  These constants would be used for pinning
330   // measurements, and as measures for assertions that have high
331   // confidence, but some evidence of occasional failure.
332   //
333   // The name PROB_ALWAYS (PROB_NEVER) is to stand for situations for which
334   // there is no evidence at all that the contrary case has ever occurred.
335 
336 #define PROB_NEVER              PROB_UNLIKELY_MAG(6)
337 #define PROB_ALWAYS             PROB_LIKELY_MAG(6)
338 
339 #define PROB_MIN                PROB_UNLIKELY_MAG(6)
340 #define PROB_MAX                PROB_LIKELY_MAG(6)
341 
342   // Static branch prediction probabilities
343   // 1 in 10 (magnitude 1)
344 #define PROB_STATIC_INFREQUENT  PROB_UNLIKELY_MAG(1)
345 #define PROB_STATIC_FREQUENT    PROB_LIKELY_MAG(1)
346 
347   // Fair probability 50/50
348 #define PROB_FAIR               (0.5f)
349 
350   // Unknown probability sentinel
351 #define PROB_UNKNOWN            (-1.0f)
352 
353   // Probability &quot;constructors&quot;, to distinguish as a probability any manifest
354   // constant without a names
355 #define PROB_LIKELY(x)          ((float) (x))
356 #define PROB_UNLIKELY(x)        (1.0f - (float)(x))
357 
358   // Other probabilities in use, but without a unique name, are documented
359   // here for lack of a better place:
360   //
361   // 1 in 1000 probabilities (magnitude 3):
362   //     threshold for converting to conditional move
363   //     likelihood of null check failure if a null HAS been seen before
364   //     likelihood of slow path taken in library calls
365   //
366   // 1 in 10,000 probabilities (magnitude 4):
367   //     threshold for making an uncommon trap probability more extreme
368   //     threshold for for making a null check implicit
369   //     likelihood of needing a gc if eden top moves during an allocation
370   //     likelihood of a predicted call failure
371   //
372   // 1 in 100,000 probabilities (magnitude 5):
373   //     threshold for ignoring counts when estimating path frequency
374   //     likelihood of FP clipping failure
375   //     likelihood of catching an exception from a try block
376   //     likelihood of null check failure if a null has NOT been seen before
377   //
378   // Magic manifest probabilities such as 0.83, 0.7, ... can be found in
379   // gen_subtype_check() and catch_inline_exceptions().
380 
381   float _prob;                  // Probability of true path being taken.
382   float _fcnt;                  // Frequency counter
383   IfNode( Node *control, Node *b, float p, float fcnt )
384     : MultiBranchNode(2), _prob(p), _fcnt(fcnt) {
385     init_class_id(Class_If);
386     init_req(0,control);
387     init_req(1,b);
388   }
389   virtual int Opcode() const;
390   virtual bool pinned() const { return true; }
391   virtual const Type *bottom_type() const { return TypeTuple::IFBOTH; }
392   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
393   virtual const Type* Value(PhaseGVN* phase) const;
394   virtual int required_outcnt() const { return 2; }
395   virtual const RegMask &amp;out_RegMask() const;
396   Node* fold_compares(PhaseIterGVN* phase);
397   static Node* up_one_dom(Node* curr, bool linear_only = false);
398   Node* dominated_by(Node* prev_dom, PhaseIterGVN* igvn);
399 
400   // Takes the type of val and filters it through the test represented
401   // by if_proj and returns a more refined type if one is produced.
402   // Returns NULL is it couldn&#39;t improve the type.
403   static const TypeInt* filtered_int_type(PhaseGVN* phase, Node* val, Node* if_proj);
404 
405   bool is_flattened_array_check(PhaseTransform* phase, Node*&amp; array);
406 
407 #ifndef PRODUCT
408   virtual void dump_spec(outputStream *st) const;
409   virtual void related(GrowableArray &lt;Node *&gt; *in_rel, GrowableArray &lt;Node *&gt; *out_rel, bool compact) const;
410 #endif
411 };
412 
413 class RangeCheckNode : public IfNode {
414 private:
415   int is_range_check(Node* &amp;range, Node* &amp;index, jint &amp;offset);
416 
417 public:
418   RangeCheckNode(Node* control, Node *b, float p, float fcnt)
419     : IfNode(control, b, p, fcnt) {
420     init_class_id(Class_RangeCheck);
421   }
422 
423   virtual int Opcode() const;
424   virtual Node* Ideal(PhaseGVN *phase, bool can_reshape);
425 };
426 
427 class IfProjNode : public CProjNode {
428 public:
429   IfProjNode(IfNode *ifnode, uint idx) : CProjNode(ifnode,idx) {}
430   virtual Node* Identity(PhaseGVN* phase);
431 
432 protected:
433   // Type of If input when this branch is always taken
434   virtual bool always_taken(const TypeTuple* t) const = 0;
435 
436 #ifndef PRODUCT
437 public:
438   virtual void related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const;
439 #endif
440 };
441 
442 class IfTrueNode : public IfProjNode {
443 public:
444   IfTrueNode( IfNode *ifnode ) : IfProjNode(ifnode,1) {
445     init_class_id(Class_IfTrue);
446   }
447   virtual int Opcode() const;
448 
449 protected:
450   virtual bool always_taken(const TypeTuple* t) const { return t == TypeTuple::IFTRUE; }
451 };
452 
453 class IfFalseNode : public IfProjNode {
454 public:
455   IfFalseNode( IfNode *ifnode ) : IfProjNode(ifnode,0) {
456     init_class_id(Class_IfFalse);
457   }
458   virtual int Opcode() const;
459 
460 protected:
461   virtual bool always_taken(const TypeTuple* t) const { return t == TypeTuple::IFFALSE; }
462 };
463 
464 
465 //------------------------------PCTableNode------------------------------------
466 // Build an indirect branch table.  Given a control and a table index,
467 // control is passed to the Projection matching the table index.  Used to
468 // implement switch statements and exception-handling capabilities.
469 // Undefined behavior if passed-in index is not inside the table.
470 class PCTableNode : public MultiBranchNode {
471   virtual uint hash() const;    // Target count; table size
472   virtual bool cmp( const Node &amp;n ) const;
473   virtual uint size_of() const { return sizeof(*this); }
474 
475 public:
476   const uint _size;             // Number of targets
477 
478   PCTableNode( Node *ctrl, Node *idx, uint size ) : MultiBranchNode(2), _size(size) {
479     init_class_id(Class_PCTable);
480     init_req(0, ctrl);
481     init_req(1, idx);
482   }
483   virtual int Opcode() const;
484   virtual const Type* Value(PhaseGVN* phase) const;
485   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
486   virtual const Type *bottom_type() const;
487   virtual bool pinned() const { return true; }
488   virtual int required_outcnt() const { return _size; }
489 };
490 
491 //------------------------------JumpNode---------------------------------------
492 // Indirect branch.  Uses PCTable above to implement a switch statement.
493 // It emits as a table load and local branch.
494 class JumpNode : public PCTableNode {
495   virtual uint size_of() const { return sizeof(*this); }
496 public:
497   float* _probs; // probability of each projection
498   float _fcnt;   // total number of times this Jump was executed
499   JumpNode( Node* control, Node* switch_val, uint size, float* probs, float cnt)
500     : PCTableNode(control, switch_val, size),
501       _probs(probs), _fcnt(cnt) {
502     init_class_id(Class_Jump);
503   }
504   virtual int   Opcode() const;
505   virtual const RegMask&amp; out_RegMask() const;
506   virtual const Node* is_block_proj() const { return this; }
507 #ifndef PRODUCT
508   virtual void related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const;
509 #endif
510 };
511 
512 class JumpProjNode : public JProjNode {
513   virtual uint hash() const;
514   virtual bool cmp( const Node &amp;n ) const;
515   virtual uint size_of() const { return sizeof(*this); }
516 
517  private:
518   const int  _dest_bci;
519   const uint _proj_no;
520   const int  _switch_val;
521  public:
522   JumpProjNode(Node* jumpnode, uint proj_no, int dest_bci, int switch_val)
523     : JProjNode(jumpnode, proj_no), _dest_bci(dest_bci), _proj_no(proj_no), _switch_val(switch_val) {
524     init_class_id(Class_JumpProj);
525   }
526 
527   virtual int Opcode() const;
528   virtual const Type* bottom_type() const { return Type::CONTROL; }
529   int  dest_bci()    const { return _dest_bci; }
530   int  switch_val()  const { return _switch_val; }
531   uint proj_no()     const { return _proj_no; }
532 #ifndef PRODUCT
533   virtual void dump_spec(outputStream *st) const;
534   virtual void dump_compact_spec(outputStream *st) const;
535   virtual void related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const;
536 #endif
537 };
538 
539 //------------------------------CatchNode--------------------------------------
540 // Helper node to fork exceptions.  &quot;Catch&quot; catches any exceptions thrown by
541 // a just-prior call.  Looks like a PCTableNode but emits no code - just the
542 // table.  The table lookup and branch is implemented by RethrowNode.
543 class CatchNode : public PCTableNode {
544 public:
545   CatchNode( Node *ctrl, Node *idx, uint size ) : PCTableNode(ctrl,idx,size){
546     init_class_id(Class_Catch);
547   }
548   virtual int Opcode() const;
549   virtual const Type* Value(PhaseGVN* phase) const;
550 };
551 
552 // CatchProjNode controls which exception handler is targetted after a call.
553 // It is passed in the bci of the target handler, or no_handler_bci in case
554 // the projection doesn&#39;t lead to an exception handler.
555 class CatchProjNode : public CProjNode {
556   virtual uint hash() const;
557   virtual bool cmp( const Node &amp;n ) const;
558   virtual uint size_of() const { return sizeof(*this); }
559 
560 private:
561   const int _handler_bci;
562 
563 public:
564   enum {
565     fall_through_index =  0,      // the fall through projection index
566     catch_all_index    =  1,      // the projection index for catch-alls
567     no_handler_bci     = -1       // the bci for fall through or catch-all projs
568   };
569 
570   CatchProjNode(Node* catchnode, uint proj_no, int handler_bci)
571     : CProjNode(catchnode, proj_no), _handler_bci(handler_bci) {
572     init_class_id(Class_CatchProj);
573     assert(proj_no != fall_through_index || handler_bci &lt; 0, &quot;fall through case must have bci &lt; 0&quot;);
574   }
575 
576   virtual int Opcode() const;
577   virtual Node* Identity(PhaseGVN* phase);
578   virtual const Type *bottom_type() const { return Type::CONTROL; }
579   int  handler_bci() const        { return _handler_bci; }
580   bool is_handler_proj() const    { return _handler_bci &gt;= 0; }
581 #ifndef PRODUCT
582   virtual void dump_spec(outputStream *st) const;
583 #endif
584 };
585 
586 
587 //---------------------------------CreateExNode--------------------------------
588 // Helper node to create the exception coming back from a call
589 class CreateExNode : public TypeNode {
590 public:
591   CreateExNode(const Type* t, Node* control, Node* i_o) : TypeNode(t, 2) {
592     init_req(0, control);
593     init_req(1, i_o);
594   }
595   virtual int Opcode() const;
596   virtual Node* Identity(PhaseGVN* phase);
597   virtual bool pinned() const { return true; }
598   uint match_edge(uint idx) const { return 0; }
599   virtual uint ideal_reg() const { return Op_RegP; }
600 };
601 
602 //------------------------------NeverBranchNode-------------------------------
603 // The never-taken branch.  Used to give the appearance of exiting infinite
604 // loops to those algorithms that like all paths to be reachable.  Encodes
605 // empty.
606 class NeverBranchNode : public MultiBranchNode {
607 public:
608   NeverBranchNode( Node *ctrl ) : MultiBranchNode(1) { init_req(0,ctrl); }
609   virtual int Opcode() const;
610   virtual bool pinned() const { return true; };
611   virtual const Type *bottom_type() const { return TypeTuple::IFBOTH; }
612   virtual const Type* Value(PhaseGVN* phase) const;
613   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
614   virtual int required_outcnt() const { return 2; }
615   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const { }
616   virtual uint size(PhaseRegAlloc *ra_) const { return 0; }
617 #ifndef PRODUCT
618   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
619 #endif
620 };
621 
622 #endif // SHARE_OPTO_CFGNODE_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/superword.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="subtypenode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="superword.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/superword.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2242             }
2243             --i; // deleted this edge; rescan position
2244           }
2245         }
2246         previous = current;
2247       } else { // !in_pack(current, pk) ==&gt; a sandwiched store
2248         remove_and_insert(current, previous, lower_insert_pt, upper_insert_pt, schedule_before_pack);
2249       }
2250 
2251       if (current == first) break;
2252       current = my_mem-&gt;as_Mem();
2253     } // end while
2254 
2255     // Reconnect loads back to upper_insert_pt.
2256     for (uint i = 0; i &lt; memops.size(); i++) {
2257       Node *ld = memops.at(i);
2258       if (ld-&gt;in(MemNode::Memory) != upper_insert_pt) {
2259         _igvn.replace_input_of(ld, MemNode::Memory, upper_insert_pt);
2260       }
2261     }
<span class="line-modified">2262   } else if (pk-&gt;at(0)-&gt;is_Load()) { //load</span>
<span class="line-modified">2263     // all loads in the pack should have the same memory state. By default,</span>
2264     // we use the memory state of the last load. However, if any load could
2265     // not be moved down due to the dependence constraint, we use the memory
2266     // state of the first load.
<span class="line-modified">2267     Node* last_mem  = pk-&gt;at(0)-&gt;in(MemNode::Memory);</span>
<span class="line-modified">2268     Node* first_mem = last_mem;</span>
<span class="line-modified">2269     // Walk the memory graph from the current first load until the</span>
<span class="line-modified">2270     // start of the loop and check if nodes on the way are memory</span>
<span class="line-modified">2271     // edges of loads in the pack. The last one we encounter is the</span>
<span class="line-modified">2272     // first load.</span>
<span class="line-modified">2273     for (Node* current = first_mem; in_bb(current); current = current-&gt;is_Phi() ? current-&gt;in(LoopNode::EntryControl) : current-&gt;in(MemNode::Memory)) {</span>
<span class="line-modified">2274      assert(current-&gt;is_Mem() || (current-&gt;is_Phi() &amp;&amp; current-&gt;in(0) == bb()), &quot;unexpected memory&quot;);</span>
<span class="line-modified">2275      for (uint i = 1; i &lt; pk-&gt;size(); i++) {</span>
<span class="line-modified">2276         Node* ld = pk-&gt;at(i);</span>
<span class="line-modified">2277         if (ld-&gt;in(MemNode::Memory) == current) {</span>
<span class="line-modified">2278           first_mem = current;</span>
<span class="line-modified">2279           break;</span>
<span class="line-modified">2280         }</span>





















2281       }
2282     }
<span class="line-modified">2283     // Find the last load by going over the pack again and walking</span>
<span class="line-modified">2284     // the memory graph from the loads of the pack to the memory of</span>
<span class="line-modified">2285     // the first load. If we encounter the memory of the current last</span>
<span class="line-modified">2286     // load, then we started from further down in the memory graph and</span>
<span class="line-modified">2287     // the load we started from is the last load. Check for dependence</span>
<span class="line-modified">2288     // constraints in that loop as well.</span>
<span class="line-modified">2289     bool schedule_last = true;</span>
<span class="line-modified">2290     for (uint i = 0; i &lt; pk-&gt;size(); i++) {</span>





2291       Node* ld = pk-&gt;at(i);
<span class="line-modified">2292       for (Node* current = ld-&gt;in(MemNode::Memory); current != first_mem; current = current-&gt;in(MemNode::Memory)) {</span>
<span class="line-modified">2293         assert(current-&gt;is_Mem() &amp;&amp; in_bb(current), &quot;unexpected memory&quot;);</span>
<span class="line-modified">2294         if (current-&gt;in(MemNode::Memory) == last_mem) {</span>
<span class="line-removed">2295           last_mem = ld-&gt;in(MemNode::Memory);</span>
<span class="line-removed">2296         }</span>
<span class="line-removed">2297         if (!independent(current, ld)) {</span>
<span class="line-removed">2298           schedule_last = false; // a later store depends on this load</span>
<span class="line-removed">2299         }</span>
2300       }
2301     }



2302 
<span class="line-modified">2303     Node* mem_input = schedule_last ? last_mem : first_mem;</span>
<span class="line-modified">2304     _igvn.hash_delete(mem_input);</span>
<span class="line-modified">2305     // Give each load the same memory state</span>
<span class="line-modified">2306     for (uint i = 0; i &lt; pk-&gt;size(); i++) {</span>
<span class="line-modified">2307       LoadNode* ld = pk-&gt;at(i)-&gt;as_Load();</span>
<span class="line-modified">2308       _igvn.replace_input_of(ld, MemNode::Memory, mem_input);</span>








2309     }
2310   }

2311 }
2312 
2313 #ifndef PRODUCT
2314 void SuperWord::print_loop(bool whole) {
2315   Node_Stack stack(_arena, _phase-&gt;C-&gt;unique() &gt;&gt; 2);
2316   Node_List rpo_list;
2317   VectorSet visited(_arena);
2318   visited.set(lpt()-&gt;_head-&gt;_idx);
2319   _phase-&gt;rpo(lpt()-&gt;_head, stack, visited, rpo_list);
2320   _phase-&gt;dump(lpt(), rpo_list.size(), rpo_list );
2321   if(whole) {
2322     tty-&gt;print_cr(&quot;\n Whole loop tree&quot;);
2323     _phase-&gt;dump();
2324     tty-&gt;print_cr(&quot; End of whole loop tree\n&quot;);
2325   }
2326 }
2327 #endif
2328 
2329 //------------------------------output---------------------------
2330 // Convert packs into vector node operations
</pre>
</td>
<td>
<hr />
<pre>
2242             }
2243             --i; // deleted this edge; rescan position
2244           }
2245         }
2246         previous = current;
2247       } else { // !in_pack(current, pk) ==&gt; a sandwiched store
2248         remove_and_insert(current, previous, lower_insert_pt, upper_insert_pt, schedule_before_pack);
2249       }
2250 
2251       if (current == first) break;
2252       current = my_mem-&gt;as_Mem();
2253     } // end while
2254 
2255     // Reconnect loads back to upper_insert_pt.
2256     for (uint i = 0; i &lt; memops.size(); i++) {
2257       Node *ld = memops.at(i);
2258       if (ld-&gt;in(MemNode::Memory) != upper_insert_pt) {
2259         _igvn.replace_input_of(ld, MemNode::Memory, upper_insert_pt);
2260       }
2261     }
<span class="line-modified">2262   } else if (pk-&gt;at(0)-&gt;is_Load()) { // Load pack</span>
<span class="line-modified">2263     // All loads in the pack should have the same memory state. By default,</span>
2264     // we use the memory state of the last load. However, if any load could
2265     // not be moved down due to the dependence constraint, we use the memory
2266     // state of the first load.
<span class="line-modified">2267     Node* mem_input = pick_mem_state(pk);</span>
<span class="line-modified">2268     _igvn.hash_delete(mem_input);</span>
<span class="line-modified">2269     // Give each load the same memory state</span>
<span class="line-modified">2270     for (uint i = 0; i &lt; pk-&gt;size(); i++) {</span>
<span class="line-modified">2271       LoadNode* ld = pk-&gt;at(i)-&gt;as_Load();</span>
<span class="line-modified">2272       _igvn.replace_input_of(ld, MemNode::Memory, mem_input);</span>
<span class="line-modified">2273     }</span>
<span class="line-modified">2274   }</span>
<span class="line-modified">2275 }</span>
<span class="line-modified">2276 </span>
<span class="line-modified">2277 // Finds the first and last memory state and then picks either of them by checking dependence constraints.</span>
<span class="line-modified">2278 // If a store is dependent on an earlier load then we need to pick the memory state of the first load and cannot</span>
<span class="line-modified">2279 // pick the memory state of the last load.</span>
<span class="line-modified">2280 Node* SuperWord::pick_mem_state(Node_List* pk) {</span>
<span class="line-added">2281   Node* first_mem = find_first_mem_state(pk);</span>
<span class="line-added">2282   Node* last_mem  = find_last_mem_state(pk, first_mem);</span>
<span class="line-added">2283 </span>
<span class="line-added">2284   for (uint i = 0; i &lt; pk-&gt;size(); i++) {</span>
<span class="line-added">2285     Node* ld = pk-&gt;at(i);</span>
<span class="line-added">2286     for (Node* current = last_mem; current != ld-&gt;in(MemNode::Memory); current = current-&gt;in(MemNode::Memory)) {</span>
<span class="line-added">2287       assert(current-&gt;is_Mem() &amp;&amp; in_bb(current), &quot;unexpected memory&quot;);</span>
<span class="line-added">2288       assert(current != first_mem, &quot;corrupted memory graph&quot;);</span>
<span class="line-added">2289       if (!independent(current, ld)) {</span>
<span class="line-added">2290 #ifdef ASSERT</span>
<span class="line-added">2291         // Added assertion code since no case has been observed that should pick the first memory state.</span>
<span class="line-added">2292         // Remove the assertion code whenever we find a (valid) case that really needs the first memory state.</span>
<span class="line-added">2293         pk-&gt;dump();</span>
<span class="line-added">2294         first_mem-&gt;dump();</span>
<span class="line-added">2295         last_mem-&gt;dump();</span>
<span class="line-added">2296         current-&gt;dump();</span>
<span class="line-added">2297         ld-&gt;dump();</span>
<span class="line-added">2298         ld-&gt;in(MemNode::Memory)-&gt;dump();</span>
<span class="line-added">2299         assert(false, &quot;never observed that first memory should be picked&quot;);</span>
<span class="line-added">2300 #endif</span>
<span class="line-added">2301         return first_mem; // A later store depends on this load, pick memory state of first load</span>
2302       }
2303     }
<span class="line-modified">2304   }</span>
<span class="line-modified">2305   return last_mem;</span>
<span class="line-modified">2306 }</span>
<span class="line-modified">2307 </span>
<span class="line-modified">2308 // Walk the memory graph from the current first load until the</span>
<span class="line-modified">2309 // start of the loop and check if nodes on the way are memory</span>
<span class="line-modified">2310 // edges of loads in the pack. The last one we encounter is the</span>
<span class="line-modified">2311 // first load.</span>
<span class="line-added">2312 Node* SuperWord::find_first_mem_state(Node_List* pk) {</span>
<span class="line-added">2313   Node* first_mem = pk-&gt;at(0)-&gt;in(MemNode::Memory);</span>
<span class="line-added">2314   for (Node* current = first_mem; in_bb(current); current = current-&gt;is_Phi() ? current-&gt;in(LoopNode::EntryControl) : current-&gt;in(MemNode::Memory)) {</span>
<span class="line-added">2315     assert(current-&gt;is_Mem() || (current-&gt;is_Phi() &amp;&amp; current-&gt;in(0) == bb()), &quot;unexpected memory&quot;);</span>
<span class="line-added">2316     for (uint i = 1; i &lt; pk-&gt;size(); i++) {</span>
2317       Node* ld = pk-&gt;at(i);
<span class="line-modified">2318       if (ld-&gt;in(MemNode::Memory) == current) {</span>
<span class="line-modified">2319         first_mem = current;</span>
<span class="line-modified">2320         break;</span>





2321       }
2322     }
<span class="line-added">2323   }</span>
<span class="line-added">2324   return first_mem;</span>
<span class="line-added">2325 }</span>
2326 
<span class="line-modified">2327 // Find the last load by going over the pack again and walking</span>
<span class="line-modified">2328 // the memory graph from the loads of the pack to the memory of</span>
<span class="line-modified">2329 // the first load. If we encounter the memory of the current last</span>
<span class="line-modified">2330 // load, then we started from further down in the memory graph and</span>
<span class="line-modified">2331 // the load we started from is the last load.</span>
<span class="line-modified">2332 Node* SuperWord::find_last_mem_state(Node_List* pk, Node* first_mem) {</span>
<span class="line-added">2333   Node* last_mem = pk-&gt;at(0)-&gt;in(MemNode::Memory);</span>
<span class="line-added">2334   for (uint i = 0; i &lt; pk-&gt;size(); i++) {</span>
<span class="line-added">2335     Node* ld = pk-&gt;at(i);</span>
<span class="line-added">2336     for (Node* current = ld-&gt;in(MemNode::Memory); current != first_mem; current = current-&gt;in(MemNode::Memory)) {</span>
<span class="line-added">2337       assert(current-&gt;is_Mem() &amp;&amp; in_bb(current), &quot;unexpected memory&quot;);</span>
<span class="line-added">2338       if (current-&gt;in(MemNode::Memory) == last_mem) {</span>
<span class="line-added">2339         last_mem = ld-&gt;in(MemNode::Memory);</span>
<span class="line-added">2340       }</span>
2341     }
2342   }
<span class="line-added">2343   return last_mem;</span>
2344 }
2345 
2346 #ifndef PRODUCT
2347 void SuperWord::print_loop(bool whole) {
2348   Node_Stack stack(_arena, _phase-&gt;C-&gt;unique() &gt;&gt; 2);
2349   Node_List rpo_list;
2350   VectorSet visited(_arena);
2351   visited.set(lpt()-&gt;_head-&gt;_idx);
2352   _phase-&gt;rpo(lpt()-&gt;_head, stack, visited, rpo_list);
2353   _phase-&gt;dump(lpt(), rpo_list.size(), rpo_list );
2354   if(whole) {
2355     tty-&gt;print_cr(&quot;\n Whole loop tree&quot;);
2356     _phase-&gt;dump();
2357     tty-&gt;print_cr(&quot; End of whole loop tree\n&quot;);
2358   }
2359 }
2360 #endif
2361 
2362 //------------------------------output---------------------------
2363 // Convert packs into vector node operations
</pre>
</td>
</tr>
</table>
<center><a href="subtypenode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="superword.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/compile.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;ci/ciReplay.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;code/exceptionHandlerTable.hpp&quot;
  31 #include &quot;code/nmethod.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/compileLog.hpp&quot;
  34 #include &quot;compiler/disassembler.hpp&quot;
  35 #include &quot;compiler/oopMap.hpp&quot;
  36 #include &quot;gc/shared/barrierSet.hpp&quot;
  37 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;opto/addnode.hpp&quot;
  40 #include &quot;opto/block.hpp&quot;
  41 #include &quot;opto/c2compiler.hpp&quot;
  42 #include &quot;opto/callGenerator.hpp&quot;
  43 #include &quot;opto/callnode.hpp&quot;
  44 #include &quot;opto/castnode.hpp&quot;
  45 #include &quot;opto/cfgnode.hpp&quot;
  46 #include &quot;opto/chaitin.hpp&quot;
  47 #include &quot;opto/compile.hpp&quot;
  48 #include &quot;opto/connode.hpp&quot;
  49 #include &quot;opto/convertnode.hpp&quot;
  50 #include &quot;opto/divnode.hpp&quot;
  51 #include &quot;opto/escape.hpp&quot;
  52 #include &quot;opto/idealGraphPrinter.hpp&quot;
  53 #include &quot;opto/loopnode.hpp&quot;
  54 #include &quot;opto/machnode.hpp&quot;
  55 #include &quot;opto/macro.hpp&quot;
  56 #include &quot;opto/matcher.hpp&quot;
  57 #include &quot;opto/mathexactnode.hpp&quot;
  58 #include &quot;opto/memnode.hpp&quot;
  59 #include &quot;opto/mulnode.hpp&quot;
  60 #include &quot;opto/narrowptrnode.hpp&quot;
  61 #include &quot;opto/node.hpp&quot;
  62 #include &quot;opto/opcodes.hpp&quot;
  63 #include &quot;opto/output.hpp&quot;
  64 #include &quot;opto/parse.hpp&quot;
  65 #include &quot;opto/phaseX.hpp&quot;
  66 #include &quot;opto/rootnode.hpp&quot;
  67 #include &quot;opto/runtime.hpp&quot;
  68 #include &quot;opto/stringopts.hpp&quot;
  69 #include &quot;opto/type.hpp&quot;
  70 #include &quot;opto/valuetypenode.hpp&quot;
  71 #include &quot;opto/vectornode.hpp&quot;
  72 #include &quot;runtime/arguments.hpp&quot;
  73 #include &quot;runtime/sharedRuntime.hpp&quot;
  74 #include &quot;runtime/signature.hpp&quot;
  75 #include &quot;runtime/stubRoutines.hpp&quot;
  76 #include &quot;runtime/timer.hpp&quot;
  77 #include &quot;utilities/align.hpp&quot;
  78 #include &quot;utilities/copy.hpp&quot;
  79 #include &quot;utilities/macros.hpp&quot;
  80 
  81 
  82 // -------------------- Compile::mach_constant_base_node -----------------------
  83 // Constant table base node singleton.
  84 MachConstantBaseNode* Compile::mach_constant_base_node() {
  85   if (_mach_constant_base_node == NULL) {
  86     _mach_constant_base_node = new MachConstantBaseNode();
  87     _mach_constant_base_node-&gt;add_req(C-&gt;root());
  88   }
  89   return _mach_constant_base_node;
  90 }
  91 
  92 
  93 /// Support for intrinsics.
  94 
  95 // Return the index at which m must be inserted (or already exists).
  96 // The sort order is by the address of the ciMethod, with is_virtual as minor key.
  97 class IntrinsicDescPair {
  98  private:
  99   ciMethod* _m;
 100   bool _is_virtual;
 101  public:
 102   IntrinsicDescPair(ciMethod* m, bool is_virtual) : _m(m), _is_virtual(is_virtual) {}
 103   static int compare(IntrinsicDescPair* const&amp; key, CallGenerator* const&amp; elt) {
 104     ciMethod* m= elt-&gt;method();
 105     ciMethod* key_m = key-&gt;_m;
 106     if (key_m &lt; m)      return -1;
 107     else if (key_m &gt; m) return 1;
 108     else {
 109       bool is_virtual = elt-&gt;is_virtual();
 110       bool key_virtual = key-&gt;_is_virtual;
 111       if (key_virtual &lt; is_virtual)      return -1;
 112       else if (key_virtual &gt; is_virtual) return 1;
 113       else                               return 0;
 114     }
 115   }
 116 };
 117 int Compile::intrinsic_insertion_index(ciMethod* m, bool is_virtual, bool&amp; found) {
 118 #ifdef ASSERT
 119   for (int i = 1; i &lt; _intrinsics-&gt;length(); i++) {
 120     CallGenerator* cg1 = _intrinsics-&gt;at(i-1);
 121     CallGenerator* cg2 = _intrinsics-&gt;at(i);
 122     assert(cg1-&gt;method() != cg2-&gt;method()
 123            ? cg1-&gt;method()     &lt; cg2-&gt;method()
 124            : cg1-&gt;is_virtual() &lt; cg2-&gt;is_virtual(),
 125            &quot;compiler intrinsics list must stay sorted&quot;);
 126   }
 127 #endif
 128   IntrinsicDescPair pair(m, is_virtual);
 129   return _intrinsics-&gt;find_sorted&lt;IntrinsicDescPair*, IntrinsicDescPair::compare&gt;(&amp;pair, found);
 130 }
 131 
 132 void Compile::register_intrinsic(CallGenerator* cg) {
 133   if (_intrinsics == NULL) {
 134     _intrinsics = new (comp_arena())GrowableArray&lt;CallGenerator*&gt;(comp_arena(), 60, 0, NULL);
 135   }
 136   int len = _intrinsics-&gt;length();
 137   bool found = false;
 138   int index = intrinsic_insertion_index(cg-&gt;method(), cg-&gt;is_virtual(), found);
 139   assert(!found, &quot;registering twice&quot;);
 140   _intrinsics-&gt;insert_before(index, cg);
 141   assert(find_intrinsic(cg-&gt;method(), cg-&gt;is_virtual()) == cg, &quot;registration worked&quot;);
 142 }
 143 
 144 CallGenerator* Compile::find_intrinsic(ciMethod* m, bool is_virtual) {
 145   assert(m-&gt;is_loaded(), &quot;don&#39;t try this on unloaded methods&quot;);
 146   if (_intrinsics != NULL) {
 147     bool found = false;
 148     int index = intrinsic_insertion_index(m, is_virtual, found);
 149      if (found) {
 150       return _intrinsics-&gt;at(index);
 151     }
 152   }
 153   // Lazily create intrinsics for intrinsic IDs well-known in the runtime.
 154   if (m-&gt;intrinsic_id() != vmIntrinsics::_none &amp;&amp;
 155       m-&gt;intrinsic_id() &lt;= vmIntrinsics::LAST_COMPILER_INLINE) {
 156     CallGenerator* cg = make_vm_intrinsic(m, is_virtual);
 157     if (cg != NULL) {
 158       // Save it for next time:
 159       register_intrinsic(cg);
 160       return cg;
 161     } else {
 162       gather_intrinsic_statistics(m-&gt;intrinsic_id(), is_virtual, _intrinsic_disabled);
 163     }
 164   }
 165   return NULL;
 166 }
 167 
 168 // Compile:: register_library_intrinsics and make_vm_intrinsic are defined
 169 // in library_call.cpp.
 170 
 171 
 172 #ifndef PRODUCT
 173 // statistics gathering...
 174 
 175 juint  Compile::_intrinsic_hist_count[vmIntrinsics::ID_LIMIT] = {0};
 176 jubyte Compile::_intrinsic_hist_flags[vmIntrinsics::ID_LIMIT] = {0};
 177 
 178 bool Compile::gather_intrinsic_statistics(vmIntrinsics::ID id, bool is_virtual, int flags) {
 179   assert(id &gt; vmIntrinsics::_none &amp;&amp; id &lt; vmIntrinsics::ID_LIMIT, &quot;oob&quot;);
 180   int oflags = _intrinsic_hist_flags[id];
 181   assert(flags != 0, &quot;what happened?&quot;);
 182   if (is_virtual) {
 183     flags |= _intrinsic_virtual;
 184   }
 185   bool changed = (flags != oflags);
 186   if ((flags &amp; _intrinsic_worked) != 0) {
 187     juint count = (_intrinsic_hist_count[id] += 1);
 188     if (count == 1) {
 189       changed = true;           // first time
 190     }
 191     // increment the overall count also:
 192     _intrinsic_hist_count[vmIntrinsics::_none] += 1;
 193   }
 194   if (changed) {
 195     if (((oflags ^ flags) &amp; _intrinsic_virtual) != 0) {
 196       // Something changed about the intrinsic&#39;s virtuality.
 197       if ((flags &amp; _intrinsic_virtual) != 0) {
 198         // This is the first use of this intrinsic as a virtual call.
 199         if (oflags != 0) {
 200           // We already saw it as a non-virtual, so note both cases.
 201           flags |= _intrinsic_both;
 202         }
 203       } else if ((oflags &amp; _intrinsic_both) == 0) {
 204         // This is the first use of this intrinsic as a non-virtual
 205         flags |= _intrinsic_both;
 206       }
 207     }
 208     _intrinsic_hist_flags[id] = (jubyte) (oflags | flags);
 209   }
 210   // update the overall flags also:
 211   _intrinsic_hist_flags[vmIntrinsics::_none] |= (jubyte) flags;
 212   return changed;
 213 }
 214 
 215 static char* format_flags(int flags, char* buf) {
 216   buf[0] = 0;
 217   if ((flags &amp; Compile::_intrinsic_worked) != 0)    strcat(buf, &quot;,worked&quot;);
 218   if ((flags &amp; Compile::_intrinsic_failed) != 0)    strcat(buf, &quot;,failed&quot;);
 219   if ((flags &amp; Compile::_intrinsic_disabled) != 0)  strcat(buf, &quot;,disabled&quot;);
 220   if ((flags &amp; Compile::_intrinsic_virtual) != 0)   strcat(buf, &quot;,virtual&quot;);
 221   if ((flags &amp; Compile::_intrinsic_both) != 0)      strcat(buf, &quot;,nonvirtual&quot;);
 222   if (buf[0] == 0)  strcat(buf, &quot;,&quot;);
 223   assert(buf[0] == &#39;,&#39;, &quot;must be&quot;);
 224   return &amp;buf[1];
 225 }
 226 
 227 void Compile::print_intrinsic_statistics() {
 228   char flagsbuf[100];
 229   ttyLocker ttyl;
 230   if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;intrinsic&#39;&quot;);
 231   tty-&gt;print_cr(&quot;Compiler intrinsic usage:&quot;);
 232   juint total = _intrinsic_hist_count[vmIntrinsics::_none];
 233   if (total == 0)  total = 1;  // avoid div0 in case of no successes
 234   #define PRINT_STAT_LINE(name, c, f) \
 235     tty-&gt;print_cr(&quot;  %4d (%4.1f%%) %s (%s)&quot;, (int)(c), ((c) * 100.0) / total, name, f);
 236   for (int index = 1 + (int)vmIntrinsics::_none; index &lt; (int)vmIntrinsics::ID_LIMIT; index++) {
 237     vmIntrinsics::ID id = (vmIntrinsics::ID) index;
 238     int   flags = _intrinsic_hist_flags[id];
 239     juint count = _intrinsic_hist_count[id];
 240     if ((flags | count) != 0) {
 241       PRINT_STAT_LINE(vmIntrinsics::name_at(id), count, format_flags(flags, flagsbuf));
 242     }
 243   }
 244   PRINT_STAT_LINE(&quot;total&quot;, total, format_flags(_intrinsic_hist_flags[vmIntrinsics::_none], flagsbuf));
 245   if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
 246 }
 247 
 248 void Compile::print_statistics() {
 249   { ttyLocker ttyl;
 250     if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;opto&#39;&quot;);
 251     Parse::print_statistics();
 252     PhaseCCP::print_statistics();
 253     PhaseRegAlloc::print_statistics();
<a name="1" id="anc1"></a><span class="line-modified"> 254     Scheduling::print_statistics();</span>
 255     PhasePeephole::print_statistics();
 256     PhaseIdealLoop::print_statistics();
 257     if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
 258   }
 259   if (_intrinsic_hist_flags[vmIntrinsics::_none] != 0) {
 260     // put this under its own &lt;statistics&gt; element.
 261     print_intrinsic_statistics();
 262   }
 263 }
 264 #endif //PRODUCT
 265 
<a name="2" id="anc2"></a><span class="line-removed"> 266 // Support for bundling info</span>
<span class="line-removed"> 267 Bundle* Compile::node_bundling(const Node *n) {</span>
<span class="line-removed"> 268   assert(valid_bundle_info(n), &quot;oob&quot;);</span>
<span class="line-removed"> 269   return &amp;_node_bundling_base[n-&gt;_idx];</span>
<span class="line-removed"> 270 }</span>
<span class="line-removed"> 271 </span>
<span class="line-removed"> 272 bool Compile::valid_bundle_info(const Node *n) {</span>
<span class="line-removed"> 273   return (_node_bundling_limit &gt; n-&gt;_idx);</span>
<span class="line-removed"> 274 }</span>
<span class="line-removed"> 275 </span>
<span class="line-removed"> 276 </span>
 277 void Compile::gvn_replace_by(Node* n, Node* nn) {
 278   for (DUIterator_Last imin, i = n-&gt;last_outs(imin); i &gt;= imin; ) {
 279     Node* use = n-&gt;last_out(i);
 280     bool is_in_table = initial_gvn()-&gt;hash_delete(use);
 281     uint uses_found = 0;
 282     for (uint j = 0; j &lt; use-&gt;len(); j++) {
 283       if (use-&gt;in(j) == n) {
 284         if (j &lt; use-&gt;req())
 285           use-&gt;set_req(j, nn);
 286         else
 287           use-&gt;set_prec(j, nn);
 288         uses_found++;
 289       }
 290     }
 291     if (is_in_table) {
 292       // reinsert into table
 293       initial_gvn()-&gt;hash_find_insert(use);
 294     }
 295     record_for_igvn(use);
 296     i -= uses_found;    // we deleted 1 or more copies of this edge
 297   }
 298 }
 299 
 300 
 301 static inline bool not_a_node(const Node* n) {
 302   if (n == NULL)                   return true;
 303   if (((intptr_t)n &amp; 1) != 0)      return true;  // uninitialized, etc.
 304   if (*(address*)n == badAddress)  return true;  // kill by Node::destruct
 305   return false;
 306 }
 307 
 308 // Identify all nodes that are reachable from below, useful.
 309 // Use breadth-first pass that records state in a Unique_Node_List,
 310 // recursive traversal is slower.
 311 void Compile::identify_useful_nodes(Unique_Node_List &amp;useful) {
 312   int estimated_worklist_size = live_nodes();
 313   useful.map( estimated_worklist_size, NULL );  // preallocate space
 314 
 315   // Initialize worklist
 316   if (root() != NULL)     { useful.push(root()); }
 317   // If &#39;top&#39; is cached, declare it useful to preserve cached node
 318   if( cached_top_node() ) { useful.push(cached_top_node()); }
 319 
 320   // Push all useful nodes onto the list, breadthfirst
 321   for( uint next = 0; next &lt; useful.size(); ++next ) {
 322     assert( next &lt; unique(), &quot;Unique useful nodes &lt; total nodes&quot;);
 323     Node *n  = useful.at(next);
 324     uint max = n-&gt;len();
 325     for( uint i = 0; i &lt; max; ++i ) {
 326       Node *m = n-&gt;in(i);
 327       if (not_a_node(m))  continue;
 328       useful.push(m);
 329     }
 330   }
 331 }
 332 
 333 // Update dead_node_list with any missing dead nodes using useful
 334 // list. Consider all non-useful nodes to be useless i.e., dead nodes.
 335 void Compile::update_dead_node_list(Unique_Node_List &amp;useful) {
 336   uint max_idx = unique();
 337   VectorSet&amp; useful_node_set = useful.member_set();
 338 
 339   for (uint node_idx = 0; node_idx &lt; max_idx; node_idx++) {
 340     // If node with index node_idx is not in useful set,
 341     // mark it as dead in dead node list.
 342     if (!useful_node_set.test(node_idx)) {
 343       record_dead_node(node_idx);
 344     }
 345   }
 346 }
 347 
 348 void Compile::remove_useless_late_inlines(GrowableArray&lt;CallGenerator*&gt;* inlines, Unique_Node_List &amp;useful) {
 349   int shift = 0;
 350   for (int i = 0; i &lt; inlines-&gt;length(); i++) {
 351     CallGenerator* cg = inlines-&gt;at(i);
 352     CallNode* call = cg-&gt;call_node();
 353     if (shift &gt; 0) {
 354       inlines-&gt;at_put(i-shift, cg);
 355     }
 356     if (!useful.member(call)) {
 357       shift++;
 358     }
 359   }
 360   inlines-&gt;trunc_to(inlines-&gt;length()-shift);
 361 }
 362 
 363 // Disconnect all useless nodes by disconnecting those at the boundary.
 364 void Compile::remove_useless_nodes(Unique_Node_List &amp;useful) {
 365   uint next = 0;
 366   while (next &lt; useful.size()) {
 367     Node *n = useful.at(next++);
 368     if (n-&gt;is_SafePoint()) {
 369       // We&#39;re done with a parsing phase. Replaced nodes are not valid
 370       // beyond that point.
 371       n-&gt;as_SafePoint()-&gt;delete_replaced_nodes();
 372     }
 373     // Use raw traversal of out edges since this code removes out edges
 374     int max = n-&gt;outcnt();
 375     for (int j = 0; j &lt; max; ++j) {
 376       Node* child = n-&gt;raw_out(j);
 377       if (! useful.member(child)) {
 378         assert(!child-&gt;is_top() || child != top(),
 379                &quot;If top is cached in Compile object it is in useful list&quot;);
 380         // Only need to remove this out-edge to the useless node
 381         n-&gt;raw_del_out(j);
 382         --j;
 383         --max;
 384       }
 385     }
 386     if (n-&gt;outcnt() == 1 &amp;&amp; n-&gt;has_special_unique_user()) {
 387       record_for_igvn(n-&gt;unique_out());
 388     }
 389   }
 390   // Remove useless macro and predicate opaq nodes
 391   for (int i = C-&gt;macro_count()-1; i &gt;= 0; i--) {
 392     Node* n = C-&gt;macro_node(i);
 393     if (!useful.member(n)) {
 394       remove_macro_node(n);
 395     }
 396   }
 397   // Remove useless CastII nodes with range check dependency
 398   for (int i = range_check_cast_count() - 1; i &gt;= 0; i--) {
 399     Node* cast = range_check_cast_node(i);
 400     if (!useful.member(cast)) {
 401       remove_range_check_cast(cast);
 402     }
 403   }
 404   // Remove useless expensive nodes
 405   for (int i = C-&gt;expensive_count()-1; i &gt;= 0; i--) {
 406     Node* n = C-&gt;expensive_node(i);
 407     if (!useful.member(n)) {
 408       remove_expensive_node(n);
 409     }
 410   }
 411   // Remove useless Opaque4 nodes
 412   for (int i = opaque4_count() - 1; i &gt;= 0; i--) {
 413     Node* opaq = opaque4_node(i);
 414     if (!useful.member(opaq)) {
 415       remove_opaque4_node(opaq);
 416     }
 417   }
 418   // Remove useless value type nodes
 419   if (_value_type_nodes != NULL) {
 420     _value_type_nodes-&gt;remove_useless_nodes(useful.member_set());
 421   }
 422   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 423   bs-&gt;eliminate_useless_gc_barriers(useful, this);
 424   // clean up the late inline lists
 425   remove_useless_late_inlines(&amp;_string_late_inlines, useful);
 426   remove_useless_late_inlines(&amp;_boxing_late_inlines, useful);
 427   remove_useless_late_inlines(&amp;_late_inlines, useful);
 428   debug_only(verify_graph_edges(true/*check for no_dead_code*/);)
 429 }
 430 
<a name="3" id="anc3"></a><span class="line-removed"> 431 //------------------------------frame_size_in_words-----------------------------</span>
<span class="line-removed"> 432 // frame_slots in units of words</span>
<span class="line-removed"> 433 int Compile::frame_size_in_words() const {</span>
<span class="line-removed"> 434   // shift is 0 in LP32 and 1 in LP64</span>
<span class="line-removed"> 435   const int shift = (LogBytesPerWord - LogBytesPerInt);</span>
<span class="line-removed"> 436   int words = _frame_slots &gt;&gt; shift;</span>
<span class="line-removed"> 437   assert( words &lt;&lt; shift == _frame_slots, &quot;frame size must be properly aligned in LP64&quot; );</span>
<span class="line-removed"> 438   return words;</span>
<span class="line-removed"> 439 }</span>
<span class="line-removed"> 440 </span>
<span class="line-removed"> 441 // To bang the stack of this compiled method we use the stack size</span>
<span class="line-removed"> 442 // that the interpreter would need in case of a deoptimization. This</span>
<span class="line-removed"> 443 // removes the need to bang the stack in the deoptimization blob which</span>
<span class="line-removed"> 444 // in turn simplifies stack overflow handling.</span>
<span class="line-removed"> 445 int Compile::bang_size_in_bytes() const {</span>
<span class="line-removed"> 446   return MAX2(frame_size_in_bytes() + os::extra_bang_size_in_bytes(), _interpreter_frame_size);</span>
<span class="line-removed"> 447 }</span>
<span class="line-removed"> 448 </span>
 449 // ============================================================================
 450 //------------------------------CompileWrapper---------------------------------
 451 class CompileWrapper : public StackObj {
 452   Compile *const _compile;
 453  public:
 454   CompileWrapper(Compile* compile);
 455 
 456   ~CompileWrapper();
 457 };
 458 
 459 CompileWrapper::CompileWrapper(Compile* compile) : _compile(compile) {
 460   // the Compile* pointer is stored in the current ciEnv:
 461   ciEnv* env = compile-&gt;env();
 462   assert(env == ciEnv::current(), &quot;must already be a ciEnv active&quot;);
 463   assert(env-&gt;compiler_data() == NULL, &quot;compile already active?&quot;);
 464   env-&gt;set_compiler_data(compile);
 465   assert(compile == Compile::current(), &quot;sanity&quot;);
 466 
 467   compile-&gt;set_type_dict(NULL);
 468   compile-&gt;set_clone_map(new Dict(cmpkey, hashkey, _compile-&gt;comp_arena()));
 469   compile-&gt;clone_map().set_clone_idx(0);
 470   compile-&gt;set_type_last_size(0);
 471   compile-&gt;set_last_tf(NULL, NULL);
 472   compile-&gt;set_indexSet_arena(NULL);
 473   compile-&gt;set_indexSet_free_block_list(NULL);
 474   compile-&gt;init_type_arena();
 475   Type::Initialize(compile);
<a name="4" id="anc4"></a><span class="line-removed"> 476   _compile-&gt;set_scratch_buffer_blob(NULL);</span>
 477   _compile-&gt;begin_method();
 478   _compile-&gt;clone_map().set_debug(_compile-&gt;has_method() &amp;&amp; _compile-&gt;directive()-&gt;CloneMapDebugOption);
 479 }
 480 CompileWrapper::~CompileWrapper() {
 481   _compile-&gt;end_method();
<a name="5" id="anc5"></a><span class="line-removed"> 482   if (_compile-&gt;scratch_buffer_blob() != NULL)</span>
<span class="line-removed"> 483     BufferBlob::free(_compile-&gt;scratch_buffer_blob());</span>
 484   _compile-&gt;env()-&gt;set_compiler_data(NULL);
 485 }
 486 
 487 
 488 //----------------------------print_compile_messages---------------------------
 489 void Compile::print_compile_messages() {
 490 #ifndef PRODUCT
 491   // Check if recompiling
 492   if (_subsume_loads == false &amp;&amp; PrintOpto) {
 493     // Recompiling without allowing machine instructions to subsume loads
 494     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 495     tty-&gt;print_cr(&quot;** Bailout: Recompile without subsuming loads          **&quot;);
 496     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 497   }
 498   if (_do_escape_analysis != DoEscapeAnalysis &amp;&amp; PrintOpto) {
 499     // Recompiling without escape analysis
 500     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 501     tty-&gt;print_cr(&quot;** Bailout: Recompile without escape analysis          **&quot;);
 502     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 503   }
 504   if (_eliminate_boxing != EliminateAutoBox &amp;&amp; PrintOpto) {
 505     // Recompiling without boxing elimination
 506     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 507     tty-&gt;print_cr(&quot;** Bailout: Recompile without boxing elimination       **&quot;);
 508     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 509   }
 510   if (C-&gt;directive()-&gt;BreakAtCompileOption) {
 511     // Open the debugger when compiling this method.
 512     tty-&gt;print(&quot;### Breaking when compiling: &quot;);
 513     method()-&gt;print_short_name();
 514     tty-&gt;cr();
 515     BREAKPOINT;
 516   }
 517 
 518   if( PrintOpto ) {
 519     if (is_osr_compilation()) {
 520       tty-&gt;print(&quot;[OSR]%3d&quot;, _compile_id);
 521     } else {
 522       tty-&gt;print(&quot;%3d&quot;, _compile_id);
 523     }
 524   }
 525 #endif
 526 }
 527 
<a name="6" id="anc6"></a><span class="line-removed"> 528 </span>
<span class="line-removed"> 529 //-----------------------init_scratch_buffer_blob------------------------------</span>
<span class="line-removed"> 530 // Construct a temporary BufferBlob and cache it for this compile.</span>
<span class="line-removed"> 531 void Compile::init_scratch_buffer_blob(int const_size) {</span>
<span class="line-removed"> 532   // If there is already a scratch buffer blob allocated and the</span>
<span class="line-removed"> 533   // constant section is big enough, use it.  Otherwise free the</span>
<span class="line-removed"> 534   // current and allocate a new one.</span>
<span class="line-removed"> 535   BufferBlob* blob = scratch_buffer_blob();</span>
<span class="line-removed"> 536   if ((blob != NULL) &amp;&amp; (const_size &lt;= _scratch_const_size)) {</span>
<span class="line-removed"> 537     // Use the current blob.</span>
<span class="line-removed"> 538   } else {</span>
<span class="line-removed"> 539     if (blob != NULL) {</span>
<span class="line-removed"> 540       BufferBlob::free(blob);</span>
<span class="line-removed"> 541     }</span>
<span class="line-removed"> 542 </span>
<span class="line-removed"> 543     ResourceMark rm;</span>
<span class="line-removed"> 544     _scratch_const_size = const_size;</span>
<span class="line-removed"> 545     int size = C2Compiler::initial_code_buffer_size(const_size);</span>
<span class="line-removed"> 546 #ifdef ASSERT</span>
<span class="line-removed"> 547     if (C-&gt;has_scalarized_args()) {</span>
<span class="line-removed"> 548       // Oop verification for loading object fields from scalarized value types in the new entry point requires lots of space</span>
<span class="line-removed"> 549       size += 5120;</span>
<span class="line-removed"> 550     }</span>
<span class="line-removed"> 551 #endif</span>
<span class="line-removed"> 552     blob = BufferBlob::create(&quot;Compile::scratch_buffer&quot;, size);</span>
<span class="line-removed"> 553     // Record the buffer blob for next time.</span>
<span class="line-removed"> 554     set_scratch_buffer_blob(blob);</span>
<span class="line-removed"> 555     // Have we run out of code space?</span>
<span class="line-removed"> 556     if (scratch_buffer_blob() == NULL) {</span>
<span class="line-removed"> 557       // Let CompilerBroker disable further compilations.</span>
<span class="line-removed"> 558       record_failure(&quot;Not enough space for scratch buffer in CodeCache&quot;);</span>
<span class="line-removed"> 559       return;</span>
<span class="line-removed"> 560     }</span>
<span class="line-removed"> 561   }</span>
<span class="line-removed"> 562 </span>
<span class="line-removed"> 563   // Initialize the relocation buffers</span>
<span class="line-removed"> 564   relocInfo* locs_buf = (relocInfo*) blob-&gt;content_end() - MAX_locs_size;</span>
<span class="line-removed"> 565   set_scratch_locs_memory(locs_buf);</span>
<span class="line-removed"> 566 }</span>
<span class="line-removed"> 567 </span>
<span class="line-removed"> 568 </span>
<span class="line-removed"> 569 //-----------------------scratch_emit_size-------------------------------------</span>
<span class="line-removed"> 570 // Helper function that computes size by emitting code</span>
<span class="line-removed"> 571 uint Compile::scratch_emit_size(const Node* n) {</span>
<span class="line-removed"> 572   // Start scratch_emit_size section.</span>
<span class="line-removed"> 573   set_in_scratch_emit_size(true);</span>
<span class="line-removed"> 574 </span>
<span class="line-removed"> 575   // Emit into a trash buffer and count bytes emitted.</span>
<span class="line-removed"> 576   // This is a pretty expensive way to compute a size,</span>
<span class="line-removed"> 577   // but it works well enough if seldom used.</span>
<span class="line-removed"> 578   // All common fixed-size instructions are given a size</span>
<span class="line-removed"> 579   // method by the AD file.</span>
<span class="line-removed"> 580   // Note that the scratch buffer blob and locs memory are</span>
<span class="line-removed"> 581   // allocated at the beginning of the compile task, and</span>
<span class="line-removed"> 582   // may be shared by several calls to scratch_emit_size.</span>
<span class="line-removed"> 583   // The allocation of the scratch buffer blob is particularly</span>
<span class="line-removed"> 584   // expensive, since it has to grab the code cache lock.</span>
<span class="line-removed"> 585   BufferBlob* blob = this-&gt;scratch_buffer_blob();</span>
<span class="line-removed"> 586   assert(blob != NULL, &quot;Initialize BufferBlob at start&quot;);</span>
<span class="line-removed"> 587   assert(blob-&gt;size() &gt; MAX_inst_size, &quot;sanity&quot;);</span>
<span class="line-removed"> 588   relocInfo* locs_buf = scratch_locs_memory();</span>
<span class="line-removed"> 589   address blob_begin = blob-&gt;content_begin();</span>
<span class="line-removed"> 590   address blob_end   = (address)locs_buf;</span>
<span class="line-removed"> 591   assert(blob-&gt;contains(blob_end), &quot;sanity&quot;);</span>
<span class="line-removed"> 592   CodeBuffer buf(blob_begin, blob_end - blob_begin);</span>
<span class="line-removed"> 593   buf.initialize_consts_size(_scratch_const_size);</span>
<span class="line-removed"> 594   buf.initialize_stubs_size(MAX_stubs_size);</span>
<span class="line-removed"> 595   assert(locs_buf != NULL, &quot;sanity&quot;);</span>
<span class="line-removed"> 596   int lsize = MAX_locs_size / 3;</span>
<span class="line-removed"> 597   buf.consts()-&gt;initialize_shared_locs(&amp;locs_buf[lsize * 0], lsize);</span>
<span class="line-removed"> 598   buf.insts()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 1], lsize);</span>
<span class="line-removed"> 599   buf.stubs()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 2], lsize);</span>
<span class="line-removed"> 600   // Mark as scratch buffer.</span>
<span class="line-removed"> 601   buf.consts()-&gt;set_scratch_emit();</span>
<span class="line-removed"> 602   buf.insts()-&gt;set_scratch_emit();</span>
<span class="line-removed"> 603   buf.stubs()-&gt;set_scratch_emit();</span>
<span class="line-removed"> 604 </span>
<span class="line-removed"> 605   // Do the emission.</span>
<span class="line-removed"> 606 </span>
<span class="line-removed"> 607   Label fakeL; // Fake label for branch instructions.</span>
<span class="line-removed"> 608   Label*   saveL = NULL;</span>
<span class="line-removed"> 609   uint save_bnum = 0;</span>
<span class="line-removed"> 610   bool is_branch = n-&gt;is_MachBranch();</span>
<span class="line-removed"> 611   if (is_branch) {</span>
<span class="line-removed"> 612     MacroAssembler masm(&amp;buf);</span>
<span class="line-removed"> 613     masm.bind(fakeL);</span>
<span class="line-removed"> 614     n-&gt;as_MachBranch()-&gt;save_label(&amp;saveL, &amp;save_bnum);</span>
<span class="line-removed"> 615     n-&gt;as_MachBranch()-&gt;label_set(&amp;fakeL, 0);</span>
<span class="line-removed"> 616   } else if (n-&gt;is_MachProlog()) {</span>
<span class="line-removed"> 617     saveL = ((MachPrologNode*)n)-&gt;_verified_entry;</span>
<span class="line-removed"> 618     ((MachPrologNode*)n)-&gt;_verified_entry = &amp;fakeL;</span>
<span class="line-removed"> 619   } else if (n-&gt;is_MachVEP()) {</span>
<span class="line-removed"> 620     saveL = ((MachVEPNode*)n)-&gt;_verified_entry;</span>
<span class="line-removed"> 621     ((MachVEPNode*)n)-&gt;_verified_entry = &amp;fakeL;</span>
<span class="line-removed"> 622   }</span>
<span class="line-removed"> 623 </span>
<span class="line-removed"> 624   n-&gt;emit(buf, this-&gt;regalloc());</span>
<span class="line-removed"> 625 </span>
<span class="line-removed"> 626   // Emitting into the scratch buffer should not fail</span>
<span class="line-removed"> 627   assert (!failing(), &quot;Must not have pending failure. Reason is: %s&quot;, failure_reason());</span>
<span class="line-removed"> 628 </span>
<span class="line-removed"> 629   // Restore label.</span>
<span class="line-removed"> 630   if (is_branch) {</span>
<span class="line-removed"> 631     n-&gt;as_MachBranch()-&gt;label_set(saveL, save_bnum);</span>
<span class="line-removed"> 632   } else if (n-&gt;is_MachProlog()) {</span>
<span class="line-removed"> 633     ((MachPrologNode*)n)-&gt;_verified_entry = saveL;</span>
<span class="line-removed"> 634   } else if (n-&gt;is_MachVEP()) {</span>
<span class="line-removed"> 635     ((MachVEPNode*)n)-&gt;_verified_entry = saveL;</span>
<span class="line-removed"> 636   }</span>
<span class="line-removed"> 637 </span>
<span class="line-removed"> 638   // End scratch_emit_size section.</span>
<span class="line-removed"> 639   set_in_scratch_emit_size(false);</span>
<span class="line-removed"> 640 </span>
<span class="line-removed"> 641   return buf.insts_size();</span>
<span class="line-removed"> 642 }</span>
<span class="line-removed"> 643 </span>
<span class="line-removed"> 644 </span>
 645 // ============================================================================
 646 //------------------------------Compile standard-------------------------------
 647 debug_only( int Compile::_debug_idx = 100000; )
 648 
 649 // Compile a method.  entry_bci is -1 for normal compilations and indicates
 650 // the continuation bci for on stack replacement.
 651 
 652 
<a name="7" id="anc7"></a><span class="line-modified"> 653 Compile::Compile( ciEnv* ci_env, C2Compiler* compiler, ciMethod* target, int osr_bci,</span>
 654                   bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing, DirectiveSet* directive)
 655                 : Phase(Compiler),
 656                   _compile_id(ci_env-&gt;compile_id()),
 657                   _save_argument_registers(false),
 658                   _subsume_loads(subsume_loads),
 659                   _do_escape_analysis(do_escape_analysis),
 660                   _eliminate_boxing(eliminate_boxing),
 661                   _method(target),
 662                   _entry_bci(osr_bci),
 663                   _stub_function(NULL),
 664                   _stub_name(NULL),
 665                   _stub_entry_point(NULL),
 666                   _max_node_limit(MaxNodeLimit),
<a name="8" id="anc8"></a><span class="line-removed"> 667                   _orig_pc_slot(0),</span>
<span class="line-removed"> 668                   _orig_pc_slot_offset_in_bytes(0),</span>
<span class="line-removed"> 669                   _sp_inc_slot(0),</span>
<span class="line-removed"> 670                   _sp_inc_slot_offset_in_bytes(0),</span>
 671                   _inlining_progress(false),
 672                   _inlining_incrementally(false),
 673                   _do_cleanup(false),
 674                   _has_reserved_stack_access(target-&gt;has_reserved_stack_access()),
 675 #ifndef PRODUCT
 676                   _trace_opto_output(directive-&gt;TraceOptoOutputOption),
 677                   _print_ideal(directive-&gt;PrintIdealOption),
 678 #endif
 679                   _has_method_handle_invokes(false),
 680                   _clinit_barrier_on_entry(false),
 681                   _comp_arena(mtCompiler),
 682                   _barrier_set_state(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;create_barrier_state(comp_arena())),
 683                   _env(ci_env),
 684                   _directive(directive),
 685                   _log(ci_env-&gt;log()),
 686                   _failure_reason(NULL),
 687                   _congraph(NULL),
 688 #ifndef PRODUCT
 689                   _printer(IdealGraphPrinter::printer()),
 690 #endif
 691                   _dead_node_list(comp_arena()),
 692                   _dead_node_count(0),
 693                   _node_arena(mtCompiler),
 694                   _old_arena(mtCompiler),
 695                   _mach_constant_base_node(NULL),
 696                   _Compile_types(mtCompiler),
 697                   _initial_gvn(NULL),
 698                   _for_igvn(NULL),
 699                   _warm_calls(NULL),
 700                   _late_inlines(comp_arena(), 2, 0, NULL),
 701                   _string_late_inlines(comp_arena(), 2, 0, NULL),
 702                   _boxing_late_inlines(comp_arena(), 2, 0, NULL),
 703                   _late_inlines_pos(0),
 704                   _number_of_mh_late_inlines(0),
 705                   _print_inlining_stream(NULL),
 706                   _print_inlining_list(NULL),
 707                   _print_inlining_idx(0),
 708                   _print_inlining_output(NULL),
 709                   _replay_inline_data(NULL),
 710                   _java_calls(0),
 711                   _inner_loops(0),
<a name="9" id="anc9"></a><span class="line-modified"> 712                   _interpreter_frame_size(0),</span>
<span class="line-removed"> 713                   _node_bundling_limit(0),</span>
<span class="line-removed"> 714                   _node_bundling_base(NULL),</span>
<span class="line-removed"> 715                   _code_buffer(&quot;Compile::Fill_buffer&quot;),</span>
<span class="line-removed"> 716                   _scratch_const_size(-1),</span>
<span class="line-removed"> 717                   _in_scratch_emit_size(false)</span>
 718 #ifndef PRODUCT
 719                   , _in_dump_cnt(0)
 720 #endif
 721 {
 722   C = this;
 723 #ifndef PRODUCT
 724   if (_printer != NULL) {
 725     _printer-&gt;set_compile(this);
 726   }
 727 #endif
 728   CompileWrapper cw(this);
 729 
 730   if (CITimeVerbose) {
 731     tty-&gt;print(&quot; &quot;);
 732     target-&gt;holder()-&gt;name()-&gt;print();
 733     tty-&gt;print(&quot;.&quot;);
 734     target-&gt;print_short_name();
 735     tty-&gt;print(&quot;  &quot;);
 736   }
 737   TraceTime t1(&quot;Total compilation time&quot;, &amp;_t_totalCompilation, CITime, CITimeVerbose);
 738   TraceTime t2(NULL, &amp;_t_methodCompilation, CITime, false);
 739 
 740 #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)
 741   bool print_opto_assembly = directive-&gt;PrintOptoAssemblyOption;
 742   // We can always print a disassembly, either abstract (hex dump) or
 743   // with the help of a suitable hsdis library. Thus, we should not
 744   // couple print_assembly and print_opto_assembly controls.
 745   // But: always print opto and regular assembly on compile command &#39;print&#39;.
 746   bool print_assembly = directive-&gt;PrintAssemblyOption;
 747   set_print_assembly(print_opto_assembly || print_assembly);
 748 #else
 749   set_print_assembly(false); // must initialize.
 750 #endif
 751 
 752 #ifndef PRODUCT
 753   set_parsed_irreducible_loop(false);
 754 
 755   if (directive-&gt;ReplayInlineOption) {
 756     _replay_inline_data = ciReplay::load_inline_data(method(), entry_bci(), ci_env-&gt;comp_level());
 757   }
 758 #endif
 759   set_print_inlining(directive-&gt;PrintInliningOption || PrintOptoInlining);
 760   set_print_intrinsics(directive-&gt;PrintIntrinsicsOption);
 761   set_has_irreducible_loop(true); // conservative until build_loop_tree() reset it
 762 
 763   if (ProfileTraps RTM_OPT_ONLY( || UseRTMLocking )) {
 764     // Make sure the method being compiled gets its own MDO,
 765     // so we can at least track the decompile_count().
 766     // Need MDO to record RTM code generation state.
 767     method()-&gt;ensure_method_data();
 768   }
 769 
 770   Init(::AliasLevel);
 771 
 772 
 773   print_compile_messages();
 774 
 775   _ilt = InlineTree::build_inline_tree_root();
 776 
 777   // Even if NO memory addresses are used, MergeMem nodes must have at least 1 slice
 778   assert(num_alias_types() &gt;= AliasIdxRaw, &quot;&quot;);
 779 
 780 #define MINIMUM_NODE_HASH  1023
 781   // Node list that Iterative GVN will start with
 782   Unique_Node_List for_igvn(comp_arena());
 783   set_for_igvn(&amp;for_igvn);
 784 
 785   // GVN that will be run immediately on new nodes
 786   uint estimated_size = method()-&gt;code_size()*4+64;
 787   estimated_size = (estimated_size &lt; MINIMUM_NODE_HASH ? MINIMUM_NODE_HASH : estimated_size);
 788   PhaseGVN gvn(node_arena(), estimated_size);
 789   set_initial_gvn(&amp;gvn);
 790 
 791   print_inlining_init();
 792   { // Scope for timing the parser
 793     TracePhase tp(&quot;parse&quot;, &amp;timers[_t_parser]);
 794 
 795     // Put top into the hash table ASAP.
 796     initial_gvn()-&gt;transform_no_reclaim(top());
 797 
 798     // Set up tf(), start(), and find a CallGenerator.
 799     CallGenerator* cg = NULL;
 800     if (is_osr_compilation()) {
 801       init_tf(TypeFunc::make(method(), /* is_osr_compilation = */ true));
 802       StartNode* s = new StartOSRNode(root(), tf()-&gt;domain_sig());
 803       initial_gvn()-&gt;set_type_bottom(s);
 804       init_start(s);
 805       cg = CallGenerator::for_osr(method(), entry_bci());
 806     } else {
 807       // Normal case.
 808       init_tf(TypeFunc::make(method()));
 809       StartNode* s = new StartNode(root(), tf()-&gt;domain_cc());
 810       initial_gvn()-&gt;set_type_bottom(s);
 811       init_start(s);
 812       if (method()-&gt;intrinsic_id() == vmIntrinsics::_Reference_get) {
 813         // With java.lang.ref.reference.get() we must go through the
 814         // intrinsic - even when get() is the root
 815         // method of the compile - so that, if necessary, the value in
 816         // the referent field of the reference object gets recorded by
 817         // the pre-barrier code.
 818         cg = find_intrinsic(method(), false);
 819       }
 820       if (cg == NULL) {
 821         float past_uses = method()-&gt;interpreter_invocation_count();
 822         float expected_uses = past_uses;
 823         cg = CallGenerator::for_inline(method(), expected_uses);
 824       }
 825     }
 826     if (failing())  return;
 827     if (cg == NULL) {
 828       record_method_not_compilable(&quot;cannot parse method&quot;);
 829       return;
 830     }
 831     JVMState* jvms = build_start_state(start(), tf());
 832     if ((jvms = cg-&gt;generate(jvms)) == NULL) {
 833       if (!failure_reason_is(C2Compiler::retry_class_loading_during_parsing())) {
 834         record_method_not_compilable(&quot;method parse failed&quot;);
 835       }
 836       return;
 837     }
 838     GraphKit kit(jvms);
 839 
 840     if (!kit.stopped()) {
 841       // Accept return values, and transfer control we know not where.
 842       // This is done by a special, unique ReturnNode bound to root.
 843       return_values(kit.jvms());
 844     }
 845 
 846     if (kit.has_exceptions()) {
 847       // Any exceptions that escape from this call must be rethrown
 848       // to whatever caller is dynamically above us on the stack.
 849       // This is done by a special, unique RethrowNode bound to root.
 850       rethrow_exceptions(kit.transfer_exceptions_into_jvms());
 851     }
 852 
 853     assert(IncrementalInline || (_late_inlines.length() == 0 &amp;&amp; !has_mh_late_inlines()), &quot;incremental inlining is off&quot;);
 854 
 855     if (_late_inlines.length() == 0 &amp;&amp; !has_mh_late_inlines() &amp;&amp; !failing() &amp;&amp; has_stringbuilder()) {
 856       inline_string_calls(true);
 857     }
 858 
 859     if (failing())  return;
 860 
 861     print_method(PHASE_BEFORE_REMOVEUSELESS, 3);
 862 
 863     // Remove clutter produced by parsing.
 864     if (!failing()) {
 865       ResourceMark rm;
 866       PhaseRemoveUseless pru(initial_gvn(), &amp;for_igvn);
 867     }
 868   }
 869 
 870   // Note:  Large methods are capped off in do_one_bytecode().
 871   if (failing())  return;
 872 
 873   // After parsing, node notes are no longer automagic.
 874   // They must be propagated by register_new_node_with_optimizer(),
 875   // clone(), or the like.
 876   set_default_node_notes(NULL);
 877 
 878   for (;;) {
 879     int successes = Inline_Warm();
 880     if (failing())  return;
 881     if (successes == 0)  break;
 882   }
 883 
 884   // Drain the list.
 885   Finish_Warm();
 886 #ifndef PRODUCT
 887   if (_printer &amp;&amp; _printer-&gt;should_print(1)) {
 888     _printer-&gt;print_inlining();
 889   }
 890 #endif
 891 
 892   if (failing())  return;
 893   NOT_PRODUCT( verify_graph_edges(); )
 894 
 895   // Now optimize
 896   Optimize();
 897   if (failing())  return;
 898   NOT_PRODUCT( verify_graph_edges(); )
 899 
 900 #ifndef PRODUCT
 901   if (print_ideal()) {
 902     ttyLocker ttyl;  // keep the following output all in one block
 903     // This output goes directly to the tty, not the compiler log.
 904     // To enable tools to match it up with the compilation activity,
 905     // be sure to tag this tty output with the compile ID.
 906     if (xtty != NULL) {
 907       xtty-&gt;head(&quot;ideal compile_id=&#39;%d&#39;%s&quot;, compile_id(),
 908                  is_osr_compilation()    ? &quot; compile_kind=&#39;osr&#39;&quot; :
 909                  &quot;&quot;);
 910     }
 911     root()-&gt;dump(9999);
 912     if (xtty != NULL) {
 913       xtty-&gt;tail(&quot;ideal&quot;);
 914     }
 915   }
 916 #endif
 917 
 918 #ifdef ASSERT
 919   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 920   bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeCodeGen);
 921 #endif
 922 
 923   // Dump compilation data to replay it.
 924   if (directive-&gt;DumpReplayOption) {
 925     env()-&gt;dump_replay_data(_compile_id);
 926   }
 927   if (directive-&gt;DumpInlineOption &amp;&amp; (ilt() != NULL)) {
 928     env()-&gt;dump_inline_data(_compile_id);
 929   }
 930 
 931   // Now that we know the size of all the monitors we can add a fixed slot
 932   // for the original deopt pc.
<a name="10" id="anc10"></a><span class="line-modified"> 933 </span>
<span class="line-removed"> 934   _orig_pc_slot = fixed_slots();</span>
<span class="line-removed"> 935   int next_slot = _orig_pc_slot + (sizeof(address) / VMRegImpl::stack_slot_size);</span>
<span class="line-removed"> 936 </span>
 937   if (needs_stack_repair()) {
 938     // One extra slot for the special stack increment value
<a name="11" id="anc11"></a><span class="line-removed"> 939     _sp_inc_slot = next_slot;</span>
 940     next_slot += 2;
 941   }
<a name="12" id="anc12"></a><span class="line-removed"> 942 </span>
 943   set_fixed_slots(next_slot);
 944 
 945   // Compute when to use implicit null checks. Used by matching trap based
 946   // nodes and NullCheck optimization.
 947   set_allowed_deopt_reasons();
 948 
 949   // Now generate code
 950   Code_Gen();
<a name="13" id="anc13"></a><span class="line-removed"> 951   if (failing())  return;</span>
<span class="line-removed"> 952 </span>
<span class="line-removed"> 953   // Check if we want to skip execution of all compiled code.</span>
<span class="line-removed"> 954   {</span>
<span class="line-removed"> 955 #ifndef PRODUCT</span>
<span class="line-removed"> 956     if (OptoNoExecute) {</span>
<span class="line-removed"> 957       record_method_not_compilable(&quot;+OptoNoExecute&quot;);  // Flag as failed</span>
<span class="line-removed"> 958       return;</span>
<span class="line-removed"> 959     }</span>
<span class="line-removed"> 960 #endif</span>
<span class="line-removed"> 961     TracePhase tp(&quot;install_code&quot;, &amp;timers[_t_registerMethod]);</span>
<span class="line-removed"> 962 </span>
<span class="line-removed"> 963     if (is_osr_compilation()) {</span>
<span class="line-removed"> 964       _code_offsets.set_value(CodeOffsets::Verified_Entry, 0);</span>
<span class="line-removed"> 965       _code_offsets.set_value(CodeOffsets::OSR_Entry, _first_block_size);</span>
<span class="line-removed"> 966     } else {</span>
<span class="line-removed"> 967       _code_offsets.set_value(CodeOffsets::Verified_Entry, _first_block_size);</span>
<span class="line-removed"> 968       if (_code_offsets.value(CodeOffsets::Verified_Value_Entry) == -1) {</span>
<span class="line-removed"> 969         _code_offsets.set_value(CodeOffsets::Verified_Value_Entry, _first_block_size);</span>
<span class="line-removed"> 970       }</span>
<span class="line-removed"> 971       if (_code_offsets.value(CodeOffsets::Verified_Value_Entry_RO) == -1) {</span>
<span class="line-removed"> 972         _code_offsets.set_value(CodeOffsets::Verified_Value_Entry_RO, _first_block_size);</span>
<span class="line-removed"> 973       }</span>
<span class="line-removed"> 974       if (_code_offsets.value(CodeOffsets::Entry) == -1) {</span>
<span class="line-removed"> 975         _code_offsets.set_value(CodeOffsets::Entry, _first_block_size);</span>
<span class="line-removed"> 976       }</span>
<span class="line-removed"> 977       _code_offsets.set_value(CodeOffsets::OSR_Entry, 0);</span>
<span class="line-removed"> 978     }</span>
<span class="line-removed"> 979 </span>
<span class="line-removed"> 980     env()-&gt;register_method(_method, _entry_bci,</span>
<span class="line-removed"> 981                            &amp;_code_offsets,</span>
<span class="line-removed"> 982                            _orig_pc_slot_offset_in_bytes,</span>
<span class="line-removed"> 983                            code_buffer(),</span>
<span class="line-removed"> 984                            frame_size_in_words(), _oop_map_set,</span>
<span class="line-removed"> 985                            &amp;_handler_table, &amp;_inc_table,</span>
<span class="line-removed"> 986                            compiler,</span>
<span class="line-removed"> 987                            has_unsafe_access(),</span>
<span class="line-removed"> 988                            SharedRuntime::is_wide_vector(max_vector_size()),</span>
<span class="line-removed"> 989                            rtm_state()</span>
<span class="line-removed"> 990                            );</span>
<span class="line-removed"> 991 </span>
<span class="line-removed"> 992     if (log() != NULL) // Print code cache state into compiler log</span>
<span class="line-removed"> 993       log()-&gt;code_cache_state();</span>
<span class="line-removed"> 994   }</span>
 995 }
 996 
 997 //------------------------------Compile----------------------------------------
 998 // Compile a runtime stub
 999 Compile::Compile( ciEnv* ci_env,
1000                   TypeFunc_generator generator,
1001                   address stub_function,
1002                   const char *stub_name,
1003                   int is_fancy_jump,
1004                   bool pass_tls,
1005                   bool save_arg_registers,
1006                   bool return_pc,
1007                   DirectiveSet* directive)
1008   : Phase(Compiler),
1009     _compile_id(0),
1010     _save_argument_registers(save_arg_registers),
1011     _subsume_loads(true),
1012     _do_escape_analysis(false),
1013     _eliminate_boxing(false),
1014     _method(NULL),
1015     _entry_bci(InvocationEntryBci),
1016     _stub_function(stub_function),
1017     _stub_name(stub_name),
1018     _stub_entry_point(NULL),
1019     _max_node_limit(MaxNodeLimit),
<a name="14" id="anc14"></a><span class="line-removed">1020     _orig_pc_slot(0),</span>
<span class="line-removed">1021     _orig_pc_slot_offset_in_bytes(0),</span>
<span class="line-removed">1022     _sp_inc_slot(0),</span>
<span class="line-removed">1023     _sp_inc_slot_offset_in_bytes(0),</span>
1024     _inlining_progress(false),
1025     _inlining_incrementally(false),
1026     _has_reserved_stack_access(false),
1027 #ifndef PRODUCT
1028     _trace_opto_output(directive-&gt;TraceOptoOutputOption),
1029     _print_ideal(directive-&gt;PrintIdealOption),
1030 #endif
1031     _has_method_handle_invokes(false),
1032     _clinit_barrier_on_entry(false),
1033     _comp_arena(mtCompiler),
1034     _barrier_set_state(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;create_barrier_state(comp_arena())),
1035     _env(ci_env),
1036     _directive(directive),
1037     _log(ci_env-&gt;log()),
1038     _failure_reason(NULL),
1039     _congraph(NULL),
1040 #ifndef PRODUCT
1041     _printer(NULL),
1042 #endif
1043     _dead_node_list(comp_arena()),
1044     _dead_node_count(0),
1045     _node_arena(mtCompiler),
1046     _old_arena(mtCompiler),
1047     _mach_constant_base_node(NULL),
1048     _Compile_types(mtCompiler),
1049     _initial_gvn(NULL),
1050     _for_igvn(NULL),
1051     _warm_calls(NULL),
1052     _number_of_mh_late_inlines(0),
1053     _print_inlining_stream(NULL),
1054     _print_inlining_list(NULL),
1055     _print_inlining_idx(0),
1056     _print_inlining_output(NULL),
1057     _replay_inline_data(NULL),
1058     _java_calls(0),
1059     _inner_loops(0),
1060     _interpreter_frame_size(0),
<a name="15" id="anc15"></a><span class="line-removed">1061     _node_bundling_limit(0),</span>
<span class="line-removed">1062     _node_bundling_base(NULL),</span>
<span class="line-removed">1063     _code_buffer(&quot;Compile::Fill_buffer&quot;),</span>
1064 #ifndef PRODUCT
1065     _in_dump_cnt(0),
1066 #endif
1067     _allowed_reasons(0) {
1068   C = this;
1069 
1070   TraceTime t1(NULL, &amp;_t_totalCompilation, CITime, false);
1071   TraceTime t2(NULL, &amp;_t_stubCompilation, CITime, false);
1072 
1073 #ifndef PRODUCT
1074   set_print_assembly(PrintFrameConverterAssembly);
1075   set_parsed_irreducible_loop(false);
1076 #else
1077   set_print_assembly(false); // Must initialize.
1078 #endif
1079   set_has_irreducible_loop(false); // no loops
1080 
1081   CompileWrapper cw(this);
1082   Init(/*AliasLevel=*/ 0);
1083   init_tf((*generator)());
1084 
1085   {
1086     // The following is a dummy for the sake of GraphKit::gen_stub
1087     Unique_Node_List for_igvn(comp_arena());
1088     set_for_igvn(&amp;for_igvn);  // not used, but some GraphKit guys push on this
1089     PhaseGVN gvn(Thread::current()-&gt;resource_area(),255);
1090     set_initial_gvn(&amp;gvn);    // not significant, but GraphKit guys use it pervasively
1091     gvn.transform_no_reclaim(top());
1092 
1093     GraphKit kit;
1094     kit.gen_stub(stub_function, stub_name, is_fancy_jump, pass_tls, return_pc);
1095   }
1096 
1097   NOT_PRODUCT( verify_graph_edges(); )
<a name="16" id="anc16"></a><span class="line-removed">1098   Code_Gen();</span>
<span class="line-removed">1099   if (failing())  return;</span>
<span class="line-removed">1100 </span>
<span class="line-removed">1101 </span>
<span class="line-removed">1102   // Entry point will be accessed using compile-&gt;stub_entry_point();</span>
<span class="line-removed">1103   if (code_buffer() == NULL) {</span>
<span class="line-removed">1104     Matcher::soft_match_failure();</span>
<span class="line-removed">1105   } else {</span>
<span class="line-removed">1106     if (PrintAssembly &amp;&amp; (WizardMode || Verbose))</span>
<span class="line-removed">1107       tty-&gt;print_cr(&quot;### Stub::%s&quot;, stub_name);</span>
<span class="line-removed">1108 </span>
<span class="line-removed">1109     if (!failing()) {</span>
<span class="line-removed">1110       assert(_fixed_slots == 0, &quot;no fixed slots used for runtime stubs&quot;);</span>
1111 
<a name="17" id="anc17"></a><span class="line-modified">1112       // Make the NMethod</span>
<span class="line-removed">1113       // For now we mark the frame as never safe for profile stackwalking</span>
<span class="line-removed">1114       RuntimeStub *rs = RuntimeStub::new_runtime_stub(stub_name,</span>
<span class="line-removed">1115                                                       code_buffer(),</span>
<span class="line-removed">1116                                                       CodeOffsets::frame_never_safe,</span>
<span class="line-removed">1117                                                       // _code_offsets.value(CodeOffsets::Frame_Complete),</span>
<span class="line-removed">1118                                                       frame_size_in_words(),</span>
<span class="line-removed">1119                                                       _oop_map_set,</span>
<span class="line-removed">1120                                                       save_arg_registers);</span>
<span class="line-removed">1121       assert(rs != NULL &amp;&amp; rs-&gt;is_runtime_stub(), &quot;sanity check&quot;);</span>
<span class="line-removed">1122 </span>
<span class="line-removed">1123       _stub_entry_point = rs-&gt;entry_point();</span>
<span class="line-removed">1124     }</span>
<span class="line-removed">1125   }</span>
1126 }
1127 
1128 //------------------------------Init-------------------------------------------
1129 // Prepare for a single compilation
1130 void Compile::Init(int aliaslevel) {
1131   _unique  = 0;
1132   _regalloc = NULL;
1133 
1134   _tf      = NULL;  // filled in later
1135   _top     = NULL;  // cached later
1136   _matcher = NULL;  // filled in later
1137   _cfg     = NULL;  // filled in later
1138 
1139   IA32_ONLY( set_24_bit_selection_and_mode(true, false); )
1140 
1141   _node_note_array = NULL;
1142   _default_node_notes = NULL;
1143   DEBUG_ONLY( _modified_nodes = NULL; ) // Used in Optimize()
1144 
1145   _immutable_memory = NULL; // filled in at first inquiry
1146 
1147   // Globally visible Nodes
1148   // First set TOP to NULL to give safe behavior during creation of RootNode
1149   set_cached_top_node(NULL);
1150   set_root(new RootNode());
1151   // Now that you have a Root to point to, create the real TOP
1152   set_cached_top_node( new ConNode(Type::TOP) );
1153   set_recent_alloc(NULL, NULL);
1154 
1155   // Create Debug Information Recorder to record scopes, oopmaps, etc.
1156   env()-&gt;set_oop_recorder(new OopRecorder(env()-&gt;arena()));
1157   env()-&gt;set_debug_info(new DebugInformationRecorder(env()-&gt;oop_recorder()));
1158   env()-&gt;set_dependencies(new Dependencies(env()));
1159 
1160   _fixed_slots = 0;
1161   set_has_split_ifs(false);
1162   set_has_loops(has_method() &amp;&amp; method()-&gt;has_loops()); // first approximation
1163   set_has_stringbuilder(false);
1164   set_has_boxed_value(false);
1165   _trap_can_recompile = false;  // no traps emitted yet
1166   _major_progress = true; // start out assuming good things will happen
1167   set_has_unsafe_access(false);
1168   set_max_vector_size(0);
1169   set_clear_upper_avx(false);  //false as default for clear upper bits of ymm registers
1170   Copy::zero_to_bytes(_trap_hist, sizeof(_trap_hist));
1171   set_decompile_count(0);
1172 
1173   set_do_freq_based_layout(_directive-&gt;BlockLayoutByFrequencyOption);
1174   _loop_opts_cnt = LoopOptsCount;
1175   _has_flattened_accesses = false;
1176   _flattened_accesses_share_alias = true;
1177 
1178   set_do_inlining(Inline);
1179   set_max_inline_size(MaxInlineSize);
1180   set_freq_inline_size(FreqInlineSize);
1181   set_do_scheduling(OptoScheduling);
1182   set_do_count_invocations(false);
1183   set_do_method_data_update(false);
1184 
1185   set_do_vector_loop(false);
1186 
1187   if (AllowVectorizeOnDemand) {
1188     if (has_method() &amp;&amp; (_directive-&gt;VectorizeOption || _directive-&gt;VectorizeDebugOption)) {
1189       set_do_vector_loop(true);
1190       NOT_PRODUCT(if (do_vector_loop() &amp;&amp; Verbose) {tty-&gt;print(&quot;Compile::Init: do vectorized loops (SIMD like) for method %s\n&quot;,  method()-&gt;name()-&gt;as_quoted_ascii());})
1191     } else if (has_method() &amp;&amp; method()-&gt;name() != 0 &amp;&amp;
1192                method()-&gt;intrinsic_id() == vmIntrinsics::_forEachRemaining) {
1193       set_do_vector_loop(true);
1194     }
1195   }
1196   set_use_cmove(UseCMoveUnconditionally /* || do_vector_loop()*/); //TODO: consider do_vector_loop() mandate use_cmove unconditionally
1197   NOT_PRODUCT(if (use_cmove() &amp;&amp; Verbose &amp;&amp; has_method()) {tty-&gt;print(&quot;Compile::Init: use CMove without profitability tests for method %s\n&quot;,  method()-&gt;name()-&gt;as_quoted_ascii());})
1198 
1199   set_age_code(has_method() &amp;&amp; method()-&gt;profile_aging());
1200   set_rtm_state(NoRTM); // No RTM lock eliding by default
1201   _max_node_limit = _directive-&gt;MaxNodeLimitOption;
1202 
1203 #if INCLUDE_RTM_OPT
1204   if (UseRTMLocking &amp;&amp; has_method() &amp;&amp; (method()-&gt;method_data_or_null() != NULL)) {
1205     int rtm_state = method()-&gt;method_data()-&gt;rtm_state();
1206     if (method_has_option(&quot;NoRTMLockEliding&quot;) || ((rtm_state &amp; NoRTM) != 0)) {
1207       // Don&#39;t generate RTM lock eliding code.
1208       set_rtm_state(NoRTM);
1209     } else if (method_has_option(&quot;UseRTMLockEliding&quot;) || ((rtm_state &amp; UseRTM) != 0) || !UseRTMDeopt) {
1210       // Generate RTM lock eliding code without abort ratio calculation code.
1211       set_rtm_state(UseRTM);
1212     } else if (UseRTMDeopt) {
1213       // Generate RTM lock eliding code and include abort ratio calculation
1214       // code if UseRTMDeopt is on.
1215       set_rtm_state(ProfileRTM);
1216     }
1217   }
1218 #endif
1219   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; has_method() &amp;&amp; !is_osr_compilation() &amp;&amp; method()-&gt;needs_clinit_barrier()) {
1220     set_clinit_barrier_on_entry(true);
1221   }
1222   if (debug_info()-&gt;recording_non_safepoints()) {
1223     set_node_note_array(new(comp_arena()) GrowableArray&lt;Node_Notes*&gt;
1224                         (comp_arena(), 8, 0, NULL));
1225     set_default_node_notes(Node_Notes::make(this));
1226   }
1227 
1228   // // -- Initialize types before each compile --
1229   // // Update cached type information
1230   // if( _method &amp;&amp; _method-&gt;constants() )
1231   //   Type::update_loaded_types(_method, _method-&gt;constants());
1232 
1233   // Init alias_type map.
1234   if (!_do_escape_analysis &amp;&amp; aliaslevel == 3)
1235     aliaslevel = 2;  // No unique types without escape analysis
1236   _AliasLevel = aliaslevel;
1237   const int grow_ats = 16;
1238   _max_alias_types = grow_ats;
1239   _alias_types   = NEW_ARENA_ARRAY(comp_arena(), AliasType*, grow_ats);
1240   AliasType* ats = NEW_ARENA_ARRAY(comp_arena(), AliasType,  grow_ats);
1241   Copy::zero_to_bytes(ats, sizeof(AliasType)*grow_ats);
1242   {
1243     for (int i = 0; i &lt; grow_ats; i++)  _alias_types[i] = &amp;ats[i];
1244   }
1245   // Initialize the first few types.
1246   _alias_types[AliasIdxTop]-&gt;Init(AliasIdxTop, NULL);
1247   _alias_types[AliasIdxBot]-&gt;Init(AliasIdxBot, TypePtr::BOTTOM);
1248   _alias_types[AliasIdxRaw]-&gt;Init(AliasIdxRaw, TypeRawPtr::BOTTOM);
1249   _num_alias_types = AliasIdxRaw+1;
1250   // Zero out the alias type cache.
1251   Copy::zero_to_bytes(_alias_cache, sizeof(_alias_cache));
1252   // A NULL adr_type hits in the cache right away.  Preload the right answer.
1253   probe_alias_cache(NULL)-&gt;_index = AliasIdxTop;
1254 
1255   _intrinsics = NULL;
1256   _macro_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1257   _predicate_opaqs = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1258   _expensive_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1259   _range_check_casts = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1260   _opaque4_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1261   _value_type_nodes = new (comp_arena()) Unique_Node_List(comp_arena());
1262   register_library_intrinsics();
<a name="18" id="anc18"></a>


1263 }
1264 
1265 //---------------------------init_start----------------------------------------
1266 // Install the StartNode on this compile object.
1267 void Compile::init_start(StartNode* s) {
1268   if (failing())
1269     return; // already failing
1270   assert(s == start(), &quot;&quot;);
1271 }
1272 
1273 /**
1274  * Return the &#39;StartNode&#39;. We must not have a pending failure, since the ideal graph
1275  * can be in an inconsistent state, i.e., we can get segmentation faults when traversing
1276  * the ideal graph.
1277  */
1278 StartNode* Compile::start() const {
1279   assert (!failing(), &quot;Must not have pending failure. Reason is: %s&quot;, failure_reason());
1280   for (DUIterator_Fast imax, i = root()-&gt;fast_outs(imax); i &lt; imax; i++) {
1281     Node* start = root()-&gt;fast_out(i);
1282     if (start-&gt;is_Start()) {
1283       return start-&gt;as_Start();
1284     }
1285   }
1286   fatal(&quot;Did not find Start node!&quot;);
1287   return NULL;
1288 }
1289 
1290 //-------------------------------immutable_memory-------------------------------------
1291 // Access immutable memory
1292 Node* Compile::immutable_memory() {
1293   if (_immutable_memory != NULL) {
1294     return _immutable_memory;
1295   }
1296   StartNode* s = start();
1297   for (DUIterator_Fast imax, i = s-&gt;fast_outs(imax); true; i++) {
1298     Node *p = s-&gt;fast_out(i);
1299     if (p != s &amp;&amp; p-&gt;as_Proj()-&gt;_con == TypeFunc::Memory) {
1300       _immutable_memory = p;
1301       return _immutable_memory;
1302     }
1303   }
1304   ShouldNotReachHere();
1305   return NULL;
1306 }
1307 
1308 //----------------------set_cached_top_node------------------------------------
1309 // Install the cached top node, and make sure Node::is_top works correctly.
1310 void Compile::set_cached_top_node(Node* tn) {
1311   if (tn != NULL)  verify_top(tn);
1312   Node* old_top = _top;
1313   _top = tn;
1314   // Calling Node::setup_is_top allows the nodes the chance to adjust
1315   // their _out arrays.
1316   if (_top != NULL)     _top-&gt;setup_is_top();
1317   if (old_top != NULL)  old_top-&gt;setup_is_top();
1318   assert(_top == NULL || top()-&gt;is_top(), &quot;&quot;);
1319 }
1320 
1321 #ifdef ASSERT
1322 uint Compile::count_live_nodes_by_graph_walk() {
1323   Unique_Node_List useful(comp_arena());
1324   // Get useful node list by walking the graph.
1325   identify_useful_nodes(useful);
1326   return useful.size();
1327 }
1328 
1329 void Compile::print_missing_nodes() {
1330 
1331   // Return if CompileLog is NULL and PrintIdealNodeCount is false.
1332   if ((_log == NULL) &amp;&amp; (! PrintIdealNodeCount)) {
1333     return;
1334   }
1335 
1336   // This is an expensive function. It is executed only when the user
1337   // specifies VerifyIdealNodeCount option or otherwise knows the
1338   // additional work that needs to be done to identify reachable nodes
1339   // by walking the flow graph and find the missing ones using
1340   // _dead_node_list.
1341 
1342   Unique_Node_List useful(comp_arena());
1343   // Get useful node list by walking the graph.
1344   identify_useful_nodes(useful);
1345 
1346   uint l_nodes = C-&gt;live_nodes();
1347   uint l_nodes_by_walk = useful.size();
1348 
1349   if (l_nodes != l_nodes_by_walk) {
1350     if (_log != NULL) {
1351       _log-&gt;begin_head(&quot;mismatched_nodes count=&#39;%d&#39;&quot;, abs((int) (l_nodes - l_nodes_by_walk)));
1352       _log-&gt;stamp();
1353       _log-&gt;end_head();
1354     }
1355     VectorSet&amp; useful_member_set = useful.member_set();
1356     int last_idx = l_nodes_by_walk;
1357     for (int i = 0; i &lt; last_idx; i++) {
1358       if (useful_member_set.test(i)) {
1359         if (_dead_node_list.test(i)) {
1360           if (_log != NULL) {
1361             _log-&gt;elem(&quot;mismatched_node_info node_idx=&#39;%d&#39; type=&#39;both live and dead&#39;&quot;, i);
1362           }
1363           if (PrintIdealNodeCount) {
1364             // Print the log message to tty
1365               tty-&gt;print_cr(&quot;mismatched_node idx=&#39;%d&#39; both live and dead&#39;&quot;, i);
1366               useful.at(i)-&gt;dump();
1367           }
1368         }
1369       }
1370       else if (! _dead_node_list.test(i)) {
1371         if (_log != NULL) {
1372           _log-&gt;elem(&quot;mismatched_node_info node_idx=&#39;%d&#39; type=&#39;neither live nor dead&#39;&quot;, i);
1373         }
1374         if (PrintIdealNodeCount) {
1375           // Print the log message to tty
1376           tty-&gt;print_cr(&quot;mismatched_node idx=&#39;%d&#39; type=&#39;neither live nor dead&#39;&quot;, i);
1377         }
1378       }
1379     }
1380     if (_log != NULL) {
1381       _log-&gt;tail(&quot;mismatched_nodes&quot;);
1382     }
1383   }
1384 }
1385 void Compile::record_modified_node(Node* n) {
1386   if (_modified_nodes != NULL &amp;&amp; !_inlining_incrementally &amp;&amp;
1387       n-&gt;outcnt() != 0 &amp;&amp; !n-&gt;is_Con()) {
1388     _modified_nodes-&gt;push(n);
1389   }
1390 }
1391 
1392 void Compile::remove_modified_node(Node* n) {
1393   if (_modified_nodes != NULL) {
1394     _modified_nodes-&gt;remove(n);
1395   }
1396 }
1397 #endif
1398 
1399 #ifndef PRODUCT
1400 void Compile::verify_top(Node* tn) const {
1401   if (tn != NULL) {
1402     assert(tn-&gt;is_Con(), &quot;top node must be a constant&quot;);
1403     assert(((ConNode*)tn)-&gt;type() == Type::TOP, &quot;top node must have correct type&quot;);
1404     assert(tn-&gt;in(0) != NULL, &quot;must have live top node&quot;);
1405   }
1406 }
1407 #endif
1408 
1409 
1410 ///-------------------Managing Per-Node Debug &amp; Profile Info-------------------
1411 
1412 void Compile::grow_node_notes(GrowableArray&lt;Node_Notes*&gt;* arr, int grow_by) {
1413   guarantee(arr != NULL, &quot;&quot;);
1414   int num_blocks = arr-&gt;length();
1415   if (grow_by &lt; num_blocks)  grow_by = num_blocks;
1416   int num_notes = grow_by * _node_notes_block_size;
1417   Node_Notes* notes = NEW_ARENA_ARRAY(node_arena(), Node_Notes, num_notes);
1418   Copy::zero_to_bytes(notes, num_notes * sizeof(Node_Notes));
1419   while (num_notes &gt; 0) {
1420     arr-&gt;append(notes);
1421     notes     += _node_notes_block_size;
1422     num_notes -= _node_notes_block_size;
1423   }
1424   assert(num_notes == 0, &quot;exact multiple, please&quot;);
1425 }
1426 
1427 bool Compile::copy_node_notes_to(Node* dest, Node* source) {
1428   if (source == NULL || dest == NULL)  return false;
1429 
1430   if (dest-&gt;is_Con())
1431     return false;               // Do not push debug info onto constants.
1432 
1433 #ifdef ASSERT
1434   // Leave a bread crumb trail pointing to the original node:
1435   if (dest != NULL &amp;&amp; dest != source &amp;&amp; dest-&gt;debug_orig() == NULL) {
1436     dest-&gt;set_debug_orig(source);
1437   }
1438 #endif
1439 
1440   if (node_note_array() == NULL)
1441     return false;               // Not collecting any notes now.
1442 
1443   // This is a copy onto a pre-existing node, which may already have notes.
1444   // If both nodes have notes, do not overwrite any pre-existing notes.
1445   Node_Notes* source_notes = node_notes_at(source-&gt;_idx);
1446   if (source_notes == NULL || source_notes-&gt;is_clear())  return false;
1447   Node_Notes* dest_notes   = node_notes_at(dest-&gt;_idx);
1448   if (dest_notes == NULL || dest_notes-&gt;is_clear()) {
1449     return set_node_notes_at(dest-&gt;_idx, source_notes);
1450   }
1451 
1452   Node_Notes merged_notes = (*source_notes);
1453   // The order of operations here ensures that dest notes will win...
1454   merged_notes.update_from(dest_notes);
1455   return set_node_notes_at(dest-&gt;_idx, &amp;merged_notes);
1456 }
1457 
1458 
1459 //--------------------------allow_range_check_smearing-------------------------
1460 // Gating condition for coalescing similar range checks.
1461 // Sometimes we try &#39;speculatively&#39; replacing a series of a range checks by a
1462 // single covering check that is at least as strong as any of them.
1463 // If the optimization succeeds, the simplified (strengthened) range check
1464 // will always succeed.  If it fails, we will deopt, and then give up
1465 // on the optimization.
1466 bool Compile::allow_range_check_smearing() const {
1467   // If this method has already thrown a range-check,
1468   // assume it was because we already tried range smearing
1469   // and it failed.
1470   uint already_trapped = trap_count(Deoptimization::Reason_range_check);
1471   return !already_trapped;
1472 }
1473 
1474 
1475 //------------------------------flatten_alias_type-----------------------------
1476 const TypePtr *Compile::flatten_alias_type( const TypePtr *tj ) const {
1477   int offset = tj-&gt;offset();
1478   TypePtr::PTR ptr = tj-&gt;ptr();
1479 
1480   // Known instance (scalarizable allocation) alias only with itself.
1481   bool is_known_inst = tj-&gt;isa_oopptr() != NULL &amp;&amp;
1482                        tj-&gt;is_oopptr()-&gt;is_known_instance();
1483 
1484   // Process weird unsafe references.
1485   if (offset == Type::OffsetBot &amp;&amp; (tj-&gt;isa_instptr() /*|| tj-&gt;isa_klassptr()*/)) {
1486     bool default_value_load = EnableValhalla &amp;&amp; tj-&gt;is_instptr()-&gt;klass() == ciEnv::current()-&gt;Class_klass();
1487     assert(InlineUnsafeOps || default_value_load, &quot;indeterminate pointers come only from unsafe ops&quot;);
1488     assert(!is_known_inst, &quot;scalarizable allocation should not have unsafe references&quot;);
1489     tj = TypeOopPtr::BOTTOM;
1490     ptr = tj-&gt;ptr();
1491     offset = tj-&gt;offset();
1492   }
1493 
1494   // Array pointers need some flattening
1495   const TypeAryPtr *ta = tj-&gt;isa_aryptr();
1496   if (ta &amp;&amp; ta-&gt;is_stable()) {
1497     // Erase stability property for alias analysis.
1498     tj = ta = ta-&gt;cast_to_stable(false);
1499   }
1500   if (ta &amp;&amp; ta-&gt;is_not_flat()) {
1501     // Erase not flat property for alias analysis.
1502     tj = ta = ta-&gt;cast_to_not_flat(false);
1503   }
1504   if (ta &amp;&amp; ta-&gt;is_not_null_free()) {
1505     // Erase not null free property for alias analysis.
1506     tj = ta = ta-&gt;cast_to_not_null_free(false);
1507   }
1508 
1509   if( ta &amp;&amp; is_known_inst ) {
1510     if ( offset != Type::OffsetBot &amp;&amp;
1511          offset &gt; arrayOopDesc::length_offset_in_bytes() ) {
1512       offset = Type::OffsetBot; // Flatten constant access into array body only
1513       tj = ta = TypeAryPtr::make(ptr, ta-&gt;ary(), ta-&gt;klass(), true, Type::Offset(offset), ta-&gt;field_offset(), ta-&gt;instance_id());
1514     }
1515   } else if( ta &amp;&amp; _AliasLevel &gt;= 2 ) {
1516     // For arrays indexed by constant indices, we flatten the alias
1517     // space to include all of the array body.  Only the header, klass
1518     // and array length can be accessed un-aliased.
1519     // For flattened value type array, each field has its own slice so
1520     // we must include the field offset.
1521     if( offset != Type::OffsetBot ) {
1522       if( ta-&gt;const_oop() ) { // MethodData* or Method*
1523         offset = Type::OffsetBot;   // Flatten constant access into array body
1524         tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),ta-&gt;ary(),ta-&gt;klass(),false,Type::Offset(offset), ta-&gt;field_offset());
1525       } else if( offset == arrayOopDesc::length_offset_in_bytes() ) {
1526         // range is OK as-is.
1527         tj = ta = TypeAryPtr::RANGE;
1528       } else if( offset == oopDesc::klass_offset_in_bytes() ) {
1529         tj = TypeInstPtr::KLASS; // all klass loads look alike
1530         ta = TypeAryPtr::RANGE; // generic ignored junk
1531         ptr = TypePtr::BotPTR;
1532       } else if( offset == oopDesc::mark_offset_in_bytes() ) {
1533         tj = TypeInstPtr::MARK;
1534         ta = TypeAryPtr::RANGE; // generic ignored junk
1535         ptr = TypePtr::BotPTR;
1536       } else {                  // Random constant offset into array body
1537         offset = Type::OffsetBot;   // Flatten constant access into array body
1538         tj = ta = TypeAryPtr::make(ptr,ta-&gt;ary(),ta-&gt;klass(),false,Type::Offset(offset), ta-&gt;field_offset());
1539       }
1540     }
1541     // Arrays of fixed size alias with arrays of unknown size.
1542     if (ta-&gt;size() != TypeInt::POS) {
1543       const TypeAry *tary = TypeAry::make(ta-&gt;elem(), TypeInt::POS);
1544       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,ta-&gt;klass(),false,Type::Offset(offset), ta-&gt;field_offset());
1545     }
1546     // Arrays of known objects become arrays of unknown objects.
1547     if (ta-&gt;elem()-&gt;isa_narrowoop() &amp;&amp; ta-&gt;elem() != TypeNarrowOop::BOTTOM) {
1548       const TypeAry *tary = TypeAry::make(TypeNarrowOop::BOTTOM, ta-&gt;size());
1549       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,NULL,false,Type::Offset(offset), ta-&gt;field_offset());
1550     }
1551     if (ta-&gt;elem()-&gt;isa_oopptr() &amp;&amp; ta-&gt;elem() != TypeInstPtr::BOTTOM) {
1552       const TypeAry *tary = TypeAry::make(TypeInstPtr::BOTTOM, ta-&gt;size());
1553       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,NULL,false,Type::Offset(offset), ta-&gt;field_offset());
1554     }
1555     // Initially all flattened array accesses share a single slice
1556     if (ta-&gt;elem()-&gt;isa_valuetype() &amp;&amp; ta-&gt;elem() != TypeValueType::BOTTOM &amp;&amp; _flattened_accesses_share_alias) {
1557       const TypeAry *tary = TypeAry::make(TypeValueType::BOTTOM, ta-&gt;size());
1558       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,NULL,false,Type::Offset(offset), Type::Offset(Type::OffsetBot));
1559     }
1560     // Arrays of bytes and of booleans both use &#39;bastore&#39; and &#39;baload&#39; so
1561     // cannot be distinguished by bytecode alone.
1562     if (ta-&gt;elem() == TypeInt::BOOL) {
1563       const TypeAry *tary = TypeAry::make(TypeInt::BYTE, ta-&gt;size());
1564       ciKlass* aklass = ciTypeArrayKlass::make(T_BYTE);
1565       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,aklass,false,Type::Offset(offset), ta-&gt;field_offset());
1566     }
1567     // During the 2nd round of IterGVN, NotNull castings are removed.
1568     // Make sure the Bottom and NotNull variants alias the same.
1569     // Also, make sure exact and non-exact variants alias the same.
1570     if (ptr == TypePtr::NotNull || ta-&gt;klass_is_exact() || ta-&gt;speculative() != NULL) {
1571       tj = ta = TypeAryPtr::make(TypePtr::BotPTR,ta-&gt;ary(),ta-&gt;klass(),false,Type::Offset(offset), ta-&gt;field_offset());
1572     }
1573   }
1574 
1575   // Oop pointers need some flattening
1576   const TypeInstPtr *to = tj-&gt;isa_instptr();
1577   if( to &amp;&amp; _AliasLevel &gt;= 2 &amp;&amp; to != TypeOopPtr::BOTTOM ) {
1578     ciInstanceKlass *k = to-&gt;klass()-&gt;as_instance_klass();
1579     if( ptr == TypePtr::Constant ) {
1580       if (to-&gt;klass() != ciEnv::current()-&gt;Class_klass() ||
1581           offset &lt; k-&gt;size_helper() * wordSize) {
1582         // No constant oop pointers (such as Strings); they alias with
1583         // unknown strings.
1584         assert(!is_known_inst, &quot;not scalarizable allocation&quot;);
1585         tj = to = TypeInstPtr::make(TypePtr::BotPTR,to-&gt;klass(),false,0,Type::Offset(offset), to-&gt;klass()-&gt;flatten_array());
1586       }
1587     } else if( is_known_inst ) {
1588       tj = to; // Keep NotNull and klass_is_exact for instance type
1589     } else if( ptr == TypePtr::NotNull || to-&gt;klass_is_exact() ) {
1590       // During the 2nd round of IterGVN, NotNull castings are removed.
1591       // Make sure the Bottom and NotNull variants alias the same.
1592       // Also, make sure exact and non-exact variants alias the same.
1593       tj = to = TypeInstPtr::make(TypePtr::BotPTR,to-&gt;klass(),false,0,Type::Offset(offset), to-&gt;klass()-&gt;flatten_array());
1594     }
1595     if (to-&gt;speculative() != NULL) {
1596       tj = to = TypeInstPtr::make(to-&gt;ptr(),to-&gt;klass(),to-&gt;klass_is_exact(),to-&gt;const_oop(),Type::Offset(to-&gt;offset()), to-&gt;klass()-&gt;flatten_array(), to-&gt;instance_id());
1597     }
1598     // Canonicalize the holder of this field
1599     if (offset &gt;= 0 &amp;&amp; offset &lt; instanceOopDesc::base_offset_in_bytes()) {
1600       // First handle header references such as a LoadKlassNode, even if the
1601       // object&#39;s klass is unloaded at compile time (4965979).
1602       if (!is_known_inst) { // Do it only for non-instance types
1603         tj = to = TypeInstPtr::make(TypePtr::BotPTR, env()-&gt;Object_klass(), false, NULL, Type::Offset(offset), false);
1604       }
1605     } else if (offset &lt; 0 || offset &gt;= k-&gt;size_helper() * wordSize) {
1606       // Static fields are in the space above the normal instance
1607       // fields in the java.lang.Class instance.
1608       if (to-&gt;klass() != ciEnv::current()-&gt;Class_klass()) {
1609         to = NULL;
1610         tj = TypeOopPtr::BOTTOM;
1611         offset = tj-&gt;offset();
1612       }
1613     } else {
1614       ciInstanceKlass *canonical_holder = k-&gt;get_canonical_holder(offset);
1615       if (!k-&gt;equals(canonical_holder) || tj-&gt;offset() != offset) {
1616         if( is_known_inst ) {
1617           tj = to = TypeInstPtr::make(to-&gt;ptr(), canonical_holder, true, NULL, Type::Offset(offset), canonical_holder-&gt;flatten_array(), to-&gt;instance_id());
1618         } else {
1619           tj = to = TypeInstPtr::make(to-&gt;ptr(), canonical_holder, false, NULL, Type::Offset(offset), canonical_holder-&gt;flatten_array());
1620         }
1621       }
1622     }
1623   }
1624 
1625   // Klass pointers to object array klasses need some flattening
1626   const TypeKlassPtr *tk = tj-&gt;isa_klassptr();
1627   if( tk ) {
1628     // If we are referencing a field within a Klass, we need
1629     // to assume the worst case of an Object.  Both exact and
1630     // inexact types must flatten to the same alias class so
1631     // use NotNull as the PTR.
1632     if ( offset == Type::OffsetBot || (offset &gt;= 0 &amp;&amp; (size_t)offset &lt; sizeof(Klass)) ) {
1633 
1634       tj = tk = TypeKlassPtr::make(TypePtr::NotNull,
1635                                    TypeKlassPtr::OBJECT-&gt;klass(),
1636                                    Type::Offset(offset),
1637                                    false);
1638     }
1639 
1640     ciKlass* klass = tk-&gt;klass();
1641     if (klass != NULL &amp;&amp; klass-&gt;is_obj_array_klass()) {
1642       ciKlass* k = TypeAryPtr::OOPS-&gt;klass();
1643       if( !k || !k-&gt;is_loaded() )                  // Only fails for some -Xcomp runs
1644         k = TypeInstPtr::BOTTOM-&gt;klass();
1645       tj = tk = TypeKlassPtr::make(TypePtr::NotNull, k, Type::Offset(offset), false);
1646     }
1647 
1648     // Check for precise loads from the primary supertype array and force them
1649     // to the supertype cache alias index.  Check for generic array loads from
1650     // the primary supertype array and also force them to the supertype cache
1651     // alias index.  Since the same load can reach both, we need to merge
1652     // these 2 disparate memories into the same alias class.  Since the
1653     // primary supertype array is read-only, there&#39;s no chance of confusion
1654     // where we bypass an array load and an array store.
1655     int primary_supers_offset = in_bytes(Klass::primary_supers_offset());
1656     if (offset == Type::OffsetBot ||
1657         (offset &gt;= primary_supers_offset &amp;&amp;
1658          offset &lt; (int)(primary_supers_offset + Klass::primary_super_limit() * wordSize)) ||
1659         offset == (int)in_bytes(Klass::secondary_super_cache_offset())) {
1660       offset = in_bytes(Klass::secondary_super_cache_offset());
1661       tj = tk = TypeKlassPtr::make(TypePtr::NotNull, tk-&gt;klass(), Type::Offset(offset), tk-&gt;flat_array());
1662     }
1663   }
1664 
1665   // Flatten all Raw pointers together.
1666   if (tj-&gt;base() == Type::RawPtr)
1667     tj = TypeRawPtr::BOTTOM;
1668 
1669   if (tj-&gt;base() == Type::AnyPtr)
1670     tj = TypePtr::BOTTOM;      // An error, which the caller must check for.
1671 
1672   // Flatten all to bottom for now
1673   switch( _AliasLevel ) {
1674   case 0:
1675     tj = TypePtr::BOTTOM;
1676     break;
1677   case 1:                       // Flatten to: oop, static, field or array
1678     switch (tj-&gt;base()) {
1679     //case Type::AryPtr: tj = TypeAryPtr::RANGE;    break;
1680     case Type::RawPtr:   tj = TypeRawPtr::BOTTOM;   break;
1681     case Type::AryPtr:   // do not distinguish arrays at all
1682     case Type::InstPtr:  tj = TypeInstPtr::BOTTOM;  break;
1683     case Type::KlassPtr: tj = TypeKlassPtr::OBJECT; break;
1684     case Type::AnyPtr:   tj = TypePtr::BOTTOM;      break;  // caller checks it
1685     default: ShouldNotReachHere();
1686     }
1687     break;
1688   case 2:                       // No collapsing at level 2; keep all splits
1689   case 3:                       // No collapsing at level 3; keep all splits
1690     break;
1691   default:
1692     Unimplemented();
1693   }
1694 
1695   offset = tj-&gt;offset();
1696   assert( offset != Type::OffsetTop, &quot;Offset has fallen from constant&quot; );
1697 
1698   assert( (offset != Type::OffsetBot &amp;&amp; tj-&gt;base() != Type::AryPtr) ||
1699           (offset == Type::OffsetBot &amp;&amp; tj-&gt;base() == Type::AryPtr) ||
1700           (offset == Type::OffsetBot &amp;&amp; tj == TypeOopPtr::BOTTOM) ||
1701           (offset == Type::OffsetBot &amp;&amp; tj == TypePtr::BOTTOM) ||
1702           (offset == oopDesc::mark_offset_in_bytes() &amp;&amp; tj-&gt;base() == Type::AryPtr) ||
1703           (offset == oopDesc::klass_offset_in_bytes() &amp;&amp; tj-&gt;base() == Type::AryPtr) ||
1704           (offset == arrayOopDesc::length_offset_in_bytes() &amp;&amp; tj-&gt;base() == Type::AryPtr),
1705           &quot;For oops, klasses, raw offset must be constant; for arrays the offset is never known&quot; );
1706   assert( tj-&gt;ptr() != TypePtr::TopPTR &amp;&amp;
1707           tj-&gt;ptr() != TypePtr::AnyNull &amp;&amp;
1708           tj-&gt;ptr() != TypePtr::Null, &quot;No imprecise addresses&quot; );
1709 //    assert( tj-&gt;ptr() != TypePtr::Constant ||
1710 //            tj-&gt;base() == Type::RawPtr ||
1711 //            tj-&gt;base() == Type::KlassPtr, &quot;No constant oop addresses&quot; );
1712 
1713   return tj;
1714 }
1715 
1716 void Compile::AliasType::Init(int i, const TypePtr* at) {
1717   assert(AliasIdxTop &lt;= i &amp;&amp; i &lt; Compile::current()-&gt;_max_alias_types, &quot;Invalid alias index&quot;);
1718   _index = i;
1719   _adr_type = at;
1720   _field = NULL;
1721   _element = NULL;
1722   _is_rewritable = true; // default
1723   const TypeOopPtr *atoop = (at != NULL) ? at-&gt;isa_oopptr() : NULL;
1724   if (atoop != NULL &amp;&amp; atoop-&gt;is_known_instance()) {
1725     const TypeOopPtr *gt = atoop-&gt;cast_to_instance_id(TypeOopPtr::InstanceBot);
1726     _general_index = Compile::current()-&gt;get_alias_index(gt);
1727   } else {
1728     _general_index = 0;
1729   }
1730 }
1731 
1732 BasicType Compile::AliasType::basic_type() const {
1733   if (element() != NULL) {
1734     const Type* element = adr_type()-&gt;is_aryptr()-&gt;elem();
1735     return element-&gt;isa_narrowoop() ? T_OBJECT : element-&gt;array_element_basic_type();
1736   } if (field() != NULL) {
1737     return field()-&gt;layout_type();
1738   } else {
1739     return T_ILLEGAL; // unknown
1740   }
1741 }
1742 
1743 //---------------------------------print_on------------------------------------
1744 #ifndef PRODUCT
1745 void Compile::AliasType::print_on(outputStream* st) {
1746   if (index() &lt; 10)
1747         st-&gt;print(&quot;@ &lt;%d&gt; &quot;, index());
1748   else  st-&gt;print(&quot;@ &lt;%d&gt;&quot;,  index());
1749   st-&gt;print(is_rewritable() ? &quot;   &quot; : &quot; RO&quot;);
1750   int offset = adr_type()-&gt;offset();
1751   if (offset == Type::OffsetBot)
1752         st-&gt;print(&quot; +any&quot;);
1753   else  st-&gt;print(&quot; +%-3d&quot;, offset);
1754   st-&gt;print(&quot; in &quot;);
1755   adr_type()-&gt;dump_on(st);
1756   const TypeOopPtr* tjp = adr_type()-&gt;isa_oopptr();
1757   if (field() != NULL &amp;&amp; tjp) {
1758     if (tjp-&gt;klass()  != field()-&gt;holder() ||
1759         tjp-&gt;offset() != field()-&gt;offset_in_bytes()) {
1760       st-&gt;print(&quot; != &quot;);
1761       field()-&gt;print();
1762       st-&gt;print(&quot; ***&quot;);
1763     }
1764   }
1765 }
1766 
1767 void print_alias_types() {
1768   Compile* C = Compile::current();
1769   tty-&gt;print_cr(&quot;--- Alias types, AliasIdxBot .. %d&quot;, C-&gt;num_alias_types()-1);
1770   for (int idx = Compile::AliasIdxBot; idx &lt; C-&gt;num_alias_types(); idx++) {
1771     C-&gt;alias_type(idx)-&gt;print_on(tty);
1772     tty-&gt;cr();
1773   }
1774 }
1775 #endif
1776 
1777 
1778 //----------------------------probe_alias_cache--------------------------------
1779 Compile::AliasCacheEntry* Compile::probe_alias_cache(const TypePtr* adr_type) {
1780   intptr_t key = (intptr_t) adr_type;
1781   key ^= key &gt;&gt; logAliasCacheSize;
1782   return &amp;_alias_cache[key &amp; right_n_bits(logAliasCacheSize)];
1783 }
1784 
1785 
1786 //-----------------------------grow_alias_types--------------------------------
1787 void Compile::grow_alias_types() {
1788   const int old_ats  = _max_alias_types; // how many before?
1789   const int new_ats  = old_ats;          // how many more?
1790   const int grow_ats = old_ats+new_ats;  // how many now?
1791   _max_alias_types = grow_ats;
1792   _alias_types =  REALLOC_ARENA_ARRAY(comp_arena(), AliasType*, _alias_types, old_ats, grow_ats);
1793   AliasType* ats =    NEW_ARENA_ARRAY(comp_arena(), AliasType, new_ats);
1794   Copy::zero_to_bytes(ats, sizeof(AliasType)*new_ats);
1795   for (int i = 0; i &lt; new_ats; i++)  _alias_types[old_ats+i] = &amp;ats[i];
1796 }
1797 
1798 
1799 //--------------------------------find_alias_type------------------------------
1800 Compile::AliasType* Compile::find_alias_type(const TypePtr* adr_type, bool no_create, ciField* original_field, bool uncached) {
1801   if (_AliasLevel == 0)
1802     return alias_type(AliasIdxBot);
1803 
1804   AliasCacheEntry* ace = NULL;
1805   if (!uncached) {
1806     ace = probe_alias_cache(adr_type);
1807     if (ace-&gt;_adr_type == adr_type) {
1808       return alias_type(ace-&gt;_index);
1809     }
1810   }
1811 
1812   // Handle special cases.
1813   if (adr_type == NULL)             return alias_type(AliasIdxTop);
1814   if (adr_type == TypePtr::BOTTOM)  return alias_type(AliasIdxBot);
1815 
1816   // Do it the slow way.
1817   const TypePtr* flat = flatten_alias_type(adr_type);
1818 
1819 #ifdef ASSERT
1820   {
1821     ResourceMark rm;
1822     assert(flat == flatten_alias_type(flat), &quot;not idempotent: adr_type = %s; flat = %s =&gt; %s&quot;,
1823            Type::str(adr_type), Type::str(flat), Type::str(flatten_alias_type(flat)));
1824     assert(flat != TypePtr::BOTTOM, &quot;cannot alias-analyze an untyped ptr: adr_type = %s&quot;,
1825            Type::str(adr_type));
1826     if (flat-&gt;isa_oopptr() &amp;&amp; !flat-&gt;isa_klassptr()) {
1827       const TypeOopPtr* foop = flat-&gt;is_oopptr();
1828       // Scalarizable allocations have exact klass always.
1829       bool exact = !foop-&gt;klass_is_exact() || foop-&gt;is_known_instance();
1830       const TypePtr* xoop = foop-&gt;cast_to_exactness(exact)-&gt;is_ptr();
1831       assert(foop == flatten_alias_type(xoop), &quot;exactness must not affect alias type: foop = %s; xoop = %s&quot;,
1832              Type::str(foop), Type::str(xoop));
1833     }
1834   }
1835 #endif
1836 
1837   int idx = AliasIdxTop;
1838   for (int i = 0; i &lt; num_alias_types(); i++) {
1839     if (alias_type(i)-&gt;adr_type() == flat) {
1840       idx = i;
1841       break;
1842     }
1843   }
1844 
1845   if (idx == AliasIdxTop) {
1846     if (no_create)  return NULL;
1847     // Grow the array if necessary.
1848     if (_num_alias_types == _max_alias_types)  grow_alias_types();
1849     // Add a new alias type.
1850     idx = _num_alias_types++;
1851     _alias_types[idx]-&gt;Init(idx, flat);
1852     if (flat == TypeInstPtr::KLASS)  alias_type(idx)-&gt;set_rewritable(false);
1853     if (flat == TypeAryPtr::RANGE)   alias_type(idx)-&gt;set_rewritable(false);
1854     if (flat-&gt;isa_instptr()) {
1855       if (flat-&gt;offset() == java_lang_Class::klass_offset_in_bytes()
1856           &amp;&amp; flat-&gt;is_instptr()-&gt;klass() == env()-&gt;Class_klass())
1857         alias_type(idx)-&gt;set_rewritable(false);
1858     }
1859     ciField* field = NULL;
1860     if (flat-&gt;isa_aryptr()) {
1861 #ifdef ASSERT
1862       const int header_size_min  = arrayOopDesc::base_offset_in_bytes(T_BYTE);
1863       // (T_BYTE has the weakest alignment and size restrictions...)
1864       assert(flat-&gt;offset() &lt; header_size_min, &quot;array body reference must be OffsetBot&quot;);
1865 #endif
1866       const Type* elemtype = flat-&gt;is_aryptr()-&gt;elem();
1867       if (flat-&gt;offset() == TypePtr::OffsetBot) {
1868         alias_type(idx)-&gt;set_element(elemtype);
1869       }
1870       int field_offset = flat-&gt;is_aryptr()-&gt;field_offset().get();
1871       if (elemtype-&gt;isa_valuetype() &amp;&amp;
1872           elemtype-&gt;value_klass() != NULL &amp;&amp;
1873           field_offset != Type::OffsetBot) {
1874         ciValueKlass* vk = elemtype-&gt;value_klass();
1875         field_offset += vk-&gt;first_field_offset();
1876         field = vk-&gt;get_field_by_offset(field_offset, false);
1877       }
1878     }
1879     if (flat-&gt;isa_klassptr()) {
1880       if (flat-&gt;offset() == in_bytes(Klass::super_check_offset_offset()))
1881         alias_type(idx)-&gt;set_rewritable(false);
1882       if (flat-&gt;offset() == in_bytes(Klass::modifier_flags_offset()))
1883         alias_type(idx)-&gt;set_rewritable(false);
1884       if (flat-&gt;offset() == in_bytes(Klass::access_flags_offset()))
1885         alias_type(idx)-&gt;set_rewritable(false);
1886       if (flat-&gt;offset() == in_bytes(Klass::java_mirror_offset()))
1887         alias_type(idx)-&gt;set_rewritable(false);
1888       if (flat-&gt;offset() == in_bytes(Klass::layout_helper_offset()))
1889         alias_type(idx)-&gt;set_rewritable(false);
<a name="19" id="anc19"></a>

1890     }
1891     // %%% (We would like to finalize JavaThread::threadObj_offset(),
1892     // but the base pointer type is not distinctive enough to identify
1893     // references into JavaThread.)
1894 
1895     // Check for final fields.
1896     const TypeInstPtr* tinst = flat-&gt;isa_instptr();
1897     if (tinst &amp;&amp; tinst-&gt;offset() &gt;= instanceOopDesc::base_offset_in_bytes()) {
1898       if (tinst-&gt;const_oop() != NULL &amp;&amp;
1899           tinst-&gt;klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
1900           tinst-&gt;offset() &gt;= (tinst-&gt;klass()-&gt;as_instance_klass()-&gt;size_helper() * wordSize)) {
1901         // static field
1902         ciInstanceKlass* k = tinst-&gt;const_oop()-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
1903         field = k-&gt;get_field_by_offset(tinst-&gt;offset(), true);
1904       } else if (tinst-&gt;klass()-&gt;is_valuetype()) {
1905         // Value type field
1906         ciValueKlass* vk = tinst-&gt;value_klass();
1907         field = vk-&gt;get_field_by_offset(tinst-&gt;offset(), false);
1908       } else {
1909         ciInstanceKlass* k = tinst-&gt;klass()-&gt;as_instance_klass();
1910         field = k-&gt;get_field_by_offset(tinst-&gt;offset(), false);
1911       }
1912     }
1913     assert(field == NULL ||
1914            original_field == NULL ||
1915            (field-&gt;holder() == original_field-&gt;holder() &amp;&amp;
1916             field-&gt;offset() == original_field-&gt;offset() &amp;&amp;
1917             field-&gt;is_static() == original_field-&gt;is_static()), &quot;wrong field?&quot;);
1918     // Set field() and is_rewritable() attributes.
1919     if (field != NULL) {
1920       alias_type(idx)-&gt;set_field(field);
1921       if (flat-&gt;isa_aryptr()) {
1922         // Fields of flattened inline type arrays are rewritable although they are declared final
1923         assert(flat-&gt;is_aryptr()-&gt;elem()-&gt;isa_valuetype(), &quot;must be a flattened value array&quot;);
1924         alias_type(idx)-&gt;set_rewritable(true);
1925       }
1926     }
1927   }
1928 
1929   // Fill the cache for next time.
1930   if (!uncached) {
1931     ace-&gt;_adr_type = adr_type;
1932     ace-&gt;_index    = idx;
1933     assert(alias_type(adr_type) == alias_type(idx),  &quot;type must be installed&quot;);
1934 
1935     // Might as well try to fill the cache for the flattened version, too.
1936     AliasCacheEntry* face = probe_alias_cache(flat);
1937     if (face-&gt;_adr_type == NULL) {
1938       face-&gt;_adr_type = flat;
1939       face-&gt;_index    = idx;
1940       assert(alias_type(flat) == alias_type(idx), &quot;flat type must work too&quot;);
1941     }
1942   }
1943 
1944   return alias_type(idx);
1945 }
1946 
1947 
1948 Compile::AliasType* Compile::alias_type(ciField* field) {
1949   const TypeOopPtr* t;
1950   if (field-&gt;is_static())
1951     t = TypeInstPtr::make(field-&gt;holder()-&gt;java_mirror());
1952   else
1953     t = TypeOopPtr::make_from_klass_raw(field-&gt;holder());
1954   AliasType* atp = alias_type(t-&gt;add_offset(field-&gt;offset_in_bytes()), field);
1955   assert((field-&gt;is_final() || field-&gt;is_stable()) == !atp-&gt;is_rewritable(), &quot;must get the rewritable bits correct&quot;);
1956   return atp;
1957 }
1958 
1959 
1960 //------------------------------have_alias_type--------------------------------
1961 bool Compile::have_alias_type(const TypePtr* adr_type) {
1962   AliasCacheEntry* ace = probe_alias_cache(adr_type);
1963   if (ace-&gt;_adr_type == adr_type) {
1964     return true;
1965   }
1966 
1967   // Handle special cases.
1968   if (adr_type == NULL)             return true;
1969   if (adr_type == TypePtr::BOTTOM)  return true;
1970 
1971   return find_alias_type(adr_type, true, NULL) != NULL;
1972 }
1973 
1974 //-----------------------------must_alias--------------------------------------
1975 // True if all values of the given address type are in the given alias category.
1976 bool Compile::must_alias(const TypePtr* adr_type, int alias_idx) {
1977   if (alias_idx == AliasIdxBot)         return true;  // the universal category
1978   if (adr_type == NULL)                 return true;  // NULL serves as TypePtr::TOP
1979   if (alias_idx == AliasIdxTop)         return false; // the empty category
1980   if (adr_type-&gt;base() == Type::AnyPtr) return false; // TypePtr::BOTTOM or its twins
1981 
1982   // the only remaining possible overlap is identity
1983   int adr_idx = get_alias_index(adr_type);
1984   assert(adr_idx != AliasIdxBot &amp;&amp; adr_idx != AliasIdxTop, &quot;&quot;);
1985   assert(adr_idx == alias_idx ||
1986          (alias_type(alias_idx)-&gt;adr_type() != TypeOopPtr::BOTTOM
1987           &amp;&amp; adr_type                       != TypeOopPtr::BOTTOM),
1988          &quot;should not be testing for overlap with an unsafe pointer&quot;);
1989   return adr_idx == alias_idx;
1990 }
1991 
1992 //------------------------------can_alias--------------------------------------
1993 // True if any values of the given address type are in the given alias category.
1994 bool Compile::can_alias(const TypePtr* adr_type, int alias_idx) {
1995   if (alias_idx == AliasIdxTop)         return false; // the empty category
1996   if (adr_type == NULL)                 return false; // NULL serves as TypePtr::TOP
<a name="20" id="anc20"></a><span class="line-modified">1997   if (alias_idx == AliasIdxBot)         return true;  // the universal category</span>
<span class="line-modified">1998   if (adr_type-&gt;base() == Type::AnyPtr) return true;  // TypePtr::BOTTOM or its twins</span>

1999 
2000   // the only remaining possible overlap is identity
2001   int adr_idx = get_alias_index(adr_type);
2002   assert(adr_idx != AliasIdxBot &amp;&amp; adr_idx != AliasIdxTop, &quot;&quot;);
2003   return adr_idx == alias_idx;
2004 }
2005 
2006 
2007 
2008 //---------------------------pop_warm_call-------------------------------------
2009 WarmCallInfo* Compile::pop_warm_call() {
2010   WarmCallInfo* wci = _warm_calls;
2011   if (wci != NULL)  _warm_calls = wci-&gt;remove_from(wci);
2012   return wci;
2013 }
2014 
2015 //----------------------------Inline_Warm--------------------------------------
2016 int Compile::Inline_Warm() {
2017   // If there is room, try to inline some more warm call sites.
2018   // %%% Do a graph index compaction pass when we think we&#39;re out of space?
2019   if (!InlineWarmCalls)  return 0;
2020 
2021   int calls_made_hot = 0;
2022   int room_to_grow   = NodeCountInliningCutoff - unique();
2023   int amount_to_grow = MIN2(room_to_grow, (int)NodeCountInliningStep);
2024   int amount_grown   = 0;
2025   WarmCallInfo* call;
2026   while (amount_to_grow &gt; 0 &amp;&amp; (call = pop_warm_call()) != NULL) {
2027     int est_size = (int)call-&gt;size();
2028     if (est_size &gt; (room_to_grow - amount_grown)) {
2029       // This one won&#39;t fit anyway.  Get rid of it.
2030       call-&gt;make_cold();
2031       continue;
2032     }
2033     call-&gt;make_hot();
2034     calls_made_hot++;
2035     amount_grown   += est_size;
2036     amount_to_grow -= est_size;
2037   }
2038 
2039   if (calls_made_hot &gt; 0)  set_major_progress();
2040   return calls_made_hot;
2041 }
2042 
2043 
2044 //----------------------------Finish_Warm--------------------------------------
2045 void Compile::Finish_Warm() {
2046   if (!InlineWarmCalls)  return;
2047   if (failing())  return;
2048   if (warm_calls() == NULL)  return;
2049 
2050   // Clean up loose ends, if we are out of space for inlining.
2051   WarmCallInfo* call;
2052   while ((call = pop_warm_call()) != NULL) {
2053     call-&gt;make_cold();
2054   }
2055 }
2056 
2057 //---------------------cleanup_loop_predicates-----------------------
2058 // Remove the opaque nodes that protect the predicates so that all unused
2059 // checks and uncommon_traps will be eliminated from the ideal graph
2060 void Compile::cleanup_loop_predicates(PhaseIterGVN &amp;igvn) {
2061   if (predicate_count()==0) return;
2062   for (int i = predicate_count(); i &gt; 0; i--) {
2063     Node * n = predicate_opaque1_node(i-1);
2064     assert(n-&gt;Opcode() == Op_Opaque1, &quot;must be&quot;);
2065     igvn.replace_node(n, n-&gt;in(1));
2066   }
2067   assert(predicate_count()==0, &quot;should be clean!&quot;);
2068 }
2069 
2070 void Compile::add_range_check_cast(Node* n) {
2071   assert(n-&gt;isa_CastII()-&gt;has_range_check(), &quot;CastII should have range check dependency&quot;);
2072   assert(!_range_check_casts-&gt;contains(n), &quot;duplicate entry in range check casts&quot;);
2073   _range_check_casts-&gt;append(n);
2074 }
2075 
2076 // Remove all range check dependent CastIINodes.
2077 void Compile::remove_range_check_casts(PhaseIterGVN &amp;igvn) {
2078   for (int i = range_check_cast_count(); i &gt; 0; i--) {
2079     Node* cast = range_check_cast_node(i-1);
2080     assert(cast-&gt;isa_CastII()-&gt;has_range_check(), &quot;CastII should have range check dependency&quot;);
2081     igvn.replace_node(cast, cast-&gt;in(1));
2082   }
2083   assert(range_check_cast_count() == 0, &quot;should be empty&quot;);
2084 }
2085 
2086 void Compile::add_opaque4_node(Node* n) {
2087   assert(n-&gt;Opcode() == Op_Opaque4, &quot;Opaque4 only&quot;);
2088   assert(!_opaque4_nodes-&gt;contains(n), &quot;duplicate entry in Opaque4 list&quot;);
2089   _opaque4_nodes-&gt;append(n);
2090 }
2091 
2092 // Remove all Opaque4 nodes.
2093 void Compile::remove_opaque4_nodes(PhaseIterGVN &amp;igvn) {
2094   for (int i = opaque4_count(); i &gt; 0; i--) {
2095     Node* opaq = opaque4_node(i-1);
2096     assert(opaq-&gt;Opcode() == Op_Opaque4, &quot;Opaque4 only&quot;);
2097     igvn.replace_node(opaq, opaq-&gt;in(2));
2098   }
2099   assert(opaque4_count() == 0, &quot;should be empty&quot;);
2100 }
2101 
2102 void Compile::add_value_type(Node* n) {
2103   assert(n-&gt;is_ValueTypeBase(), &quot;unexpected node&quot;);
2104   if (_value_type_nodes != NULL) {
2105     _value_type_nodes-&gt;push(n);
2106   }
2107 }
2108 
2109 void Compile::remove_value_type(Node* n) {
2110   assert(n-&gt;is_ValueTypeBase(), &quot;unexpected node&quot;);
2111   if (_value_type_nodes != NULL) {
2112     _value_type_nodes-&gt;remove(n);
2113   }
2114 }
2115 
2116 // Does the return value keep otherwise useless value type allocations
2117 // alive?
2118 static bool return_val_keeps_allocations_alive(Node* ret_val) {
2119   ResourceMark rm;
2120   Unique_Node_List wq;
2121   wq.push(ret_val);
2122   bool some_allocations = false;
2123   for (uint i = 0; i &lt; wq.size(); i++) {
2124     Node* n = wq.at(i);
2125     assert(!n-&gt;is_ValueTypeBase(), &quot;chain of value type nodes&quot;);
2126     if (n-&gt;outcnt() &gt; 1) {
2127       // Some other use for the allocation
2128       return false;
2129     } else if (n-&gt;is_Phi()) {
2130       for (uint j = 1; j &lt; n-&gt;req(); j++) {
2131         wq.push(n-&gt;in(j));
2132       }
2133     } else if (n-&gt;is_CheckCastPP() &amp;&amp;
2134                n-&gt;in(1)-&gt;is_Proj() &amp;&amp;
2135                n-&gt;in(1)-&gt;in(0)-&gt;is_Allocate()) {
2136       some_allocations = true;
2137     }
2138   }
2139   return some_allocations;
2140 }
2141 
2142 void Compile::process_value_types(PhaseIterGVN &amp;igvn) {
2143   // Make value types scalar in safepoints
2144   while (_value_type_nodes-&gt;size() != 0) {
2145     ValueTypeBaseNode* vt = _value_type_nodes-&gt;pop()-&gt;as_ValueTypeBase();
2146     vt-&gt;make_scalar_in_safepoints(&amp;igvn);
2147     if (vt-&gt;is_ValueTypePtr()) {
2148       igvn.replace_node(vt, vt-&gt;get_oop());
2149     } else if (vt-&gt;outcnt() == 0) {
2150       igvn.remove_dead_node(vt);
2151     }
2152   }
2153   _value_type_nodes = NULL;
2154   if (tf()-&gt;returns_value_type_as_fields()) {
2155     Node* ret = NULL;
2156     for (uint i = 1; i &lt; root()-&gt;req(); i++){
2157       Node* in = root()-&gt;in(i);
2158       if (in-&gt;Opcode() == Op_Return) {
2159         assert(ret == NULL, &quot;only one return&quot;);
2160         ret = in;
2161       }
2162     }
2163     if (ret != NULL) {
2164       Node* ret_val = ret-&gt;in(TypeFunc::Parms);
2165       if (igvn.type(ret_val)-&gt;isa_oopptr() &amp;&amp;
2166           return_val_keeps_allocations_alive(ret_val)) {
2167         igvn.replace_input_of(ret, TypeFunc::Parms, ValueTypeNode::tagged_klass(igvn.type(ret_val)-&gt;value_klass(), igvn));
2168         assert(ret_val-&gt;outcnt() == 0, &quot;should be dead now&quot;);
2169         igvn.remove_dead_node(ret_val);
2170       }
2171     }
2172   }
2173   igvn.optimize();
2174 }
2175 
2176 void Compile::adjust_flattened_array_access_aliases(PhaseIterGVN&amp; igvn) {
2177   if (!_has_flattened_accesses) {
2178     return;
2179   }
2180   // Initially, all flattened array accesses share the same slice to
2181   // keep dependencies with Object[] array accesses (that could be
2182   // to a flattened array) correct. We&#39;re done with parsing so we
2183   // now know all flattened array accesses in this compile
2184   // unit. Let&#39;s move flattened array accesses to their own slice,
2185   // one per element field. This should help memory access
2186   // optimizations.
2187   ResourceMark rm;
2188   Unique_Node_List wq;
2189   wq.push(root());
2190 
2191   Node_List mergememnodes;
2192   Node_List memnodes;
2193 
2194   // Alias index currently shared by all flattened memory accesses
2195   int index = get_alias_index(TypeAryPtr::VALUES);
2196 
2197   // Find MergeMem nodes and flattened array accesses
2198   for (uint i = 0; i &lt; wq.size(); i++) {
2199     Node* n = wq.at(i);
2200     if (n-&gt;is_Mem()) {
2201       const TypePtr* adr_type = NULL;
2202       if (n-&gt;Opcode() == Op_StoreCM) {
2203         adr_type = get_adr_type(get_alias_index(n-&gt;in(MemNode::OopStore)-&gt;adr_type()));
2204       } else {
2205         adr_type = get_adr_type(get_alias_index(n-&gt;adr_type()));
2206       }
2207       if (adr_type == TypeAryPtr::VALUES) {
2208         memnodes.push(n);
2209       }
2210     } else if (n-&gt;is_MergeMem()) {
2211       MergeMemNode* mm = n-&gt;as_MergeMem();
2212       if (mm-&gt;memory_at(index) != mm-&gt;base_memory()) {
2213         mergememnodes.push(n);
2214       }
2215     }
2216     for (uint j = 0; j &lt; n-&gt;req(); j++) {
2217       Node* m = n-&gt;in(j);
2218       if (m != NULL) {
2219         wq.push(m);
2220       }
2221     }
2222   }
2223 
2224   if (memnodes.size() &gt; 0) {
2225     _flattened_accesses_share_alias = false;
2226 
2227     // We are going to change the slice for the flattened array
2228     // accesses so we need to clear the cache entries that refer to
2229     // them.
2230     for (uint i = 0; i &lt; AliasCacheSize; i++) {
2231       AliasCacheEntry* ace = &amp;_alias_cache[i];
2232       if (ace-&gt;_adr_type != NULL &amp;&amp;
2233           ace-&gt;_adr_type-&gt;isa_aryptr() &amp;&amp;
2234           ace-&gt;_adr_type-&gt;is_aryptr()-&gt;elem()-&gt;isa_valuetype()) {
2235         ace-&gt;_adr_type = NULL;
2236         ace-&gt;_index = (i != 0) ? 0 : AliasIdxTop; // Make sure the NULL adr_type resolves to AliasIdxTop
2237       }
2238     }
2239 
2240     // Find what aliases we are going to add
2241     int start_alias = num_alias_types()-1;
2242     int stop_alias = 0;
2243 
2244     for (uint i = 0; i &lt; memnodes.size(); i++) {
2245       Node* m = memnodes.at(i);
2246       const TypePtr* adr_type = NULL;
2247       if (m-&gt;Opcode() == Op_StoreCM) {
2248         adr_type = m-&gt;in(MemNode::OopStore)-&gt;adr_type();
2249         Node* clone = new StoreCMNode(m-&gt;in(MemNode::Control), m-&gt;in(MemNode::Memory), m-&gt;in(MemNode::Address),
2250                                       m-&gt;adr_type(), m-&gt;in(MemNode::ValueIn), m-&gt;in(MemNode::OopStore),
2251                                       get_alias_index(adr_type));
2252         igvn.register_new_node_with_optimizer(clone);
2253         igvn.replace_node(m, clone);
2254       } else {
2255         adr_type = m-&gt;adr_type();
2256 #ifdef ASSERT
2257         m-&gt;as_Mem()-&gt;set_adr_type(adr_type);
2258 #endif
2259       }
2260       int idx = get_alias_index(adr_type);
2261       start_alias = MIN2(start_alias, idx);
2262       stop_alias = MAX2(stop_alias, idx);
2263     }
2264 
2265     assert(stop_alias &gt;= start_alias, &quot;should have expanded aliases&quot;);
2266 
2267     Node_Stack stack(0);
2268 #ifdef ASSERT
2269     VectorSet seen(Thread::current()-&gt;resource_area());
2270 #endif
2271     // Now let&#39;s fix the memory graph so each flattened array access
2272     // is moved to the right slice. Start from the MergeMem nodes.
2273     uint last = unique();
2274     for (uint i = 0; i &lt; mergememnodes.size(); i++) {
2275       MergeMemNode* current = mergememnodes.at(i)-&gt;as_MergeMem();
2276       Node* n = current-&gt;memory_at(index);
2277       MergeMemNode* mm = NULL;
2278       do {
2279         // Follow memory edges through memory accesses, phis and
2280         // narrow membars and push nodes on the stack. Once we hit
2281         // bottom memory, we pop element off the stack one at a
2282         // time, in reverse order, and move them to the right slice
2283         // by changing their memory edges.
2284         if ((n-&gt;is_Phi() &amp;&amp; n-&gt;adr_type() != TypePtr::BOTTOM) || n-&gt;is_Mem() || n-&gt;adr_type() == TypeAryPtr::VALUES) {
2285           assert(!seen.test_set(n-&gt;_idx), &quot;&quot;);
2286           // Uses (a load for instance) will need to be moved to the
2287           // right slice as well and will get a new memory state
2288           // that we don&#39;t know yet. The use could also be the
2289           // backedge of a loop. We put a place holder node between
2290           // the memory node and its uses. We replace that place
2291           // holder with the correct memory state once we know it,
2292           // i.e. when nodes are popped off the stack. Using the
2293           // place holder make the logic work in the presence of
2294           // loops.
2295           if (n-&gt;outcnt() &gt; 1) {
2296             Node* place_holder = NULL;
2297             assert(!n-&gt;has_out_with(Op_Node), &quot;&quot;);
2298             for (DUIterator k = n-&gt;outs(); n-&gt;has_out(k); k++) {
2299               Node* u = n-&gt;out(k);
2300               if (u != current &amp;&amp; u-&gt;_idx &lt; last) {
2301                 bool success = false;
2302                 for (uint l = 0; l &lt; u-&gt;req(); l++) {
2303                   if (!stack.is_empty() &amp;&amp; u == stack.node() &amp;&amp; l == stack.index()) {
2304                     continue;
2305                   }
2306                   Node* in = u-&gt;in(l);
2307                   if (in == n) {
2308                     if (place_holder == NULL) {
2309                       place_holder = new Node(1);
2310                       place_holder-&gt;init_req(0, n);
2311                     }
2312                     igvn.replace_input_of(u, l, place_holder);
2313                     success = true;
2314                   }
2315                 }
2316                 if (success) {
2317                   --k;
2318                 }
2319               }
2320             }
2321           }
2322           if (n-&gt;is_Phi()) {
2323             stack.push(n, 1);
2324             n = n-&gt;in(1);
2325           } else if (n-&gt;is_Mem()) {
2326             stack.push(n, n-&gt;req());
2327             n = n-&gt;in(MemNode::Memory);
2328           } else {
2329             assert(n-&gt;is_Proj() &amp;&amp; n-&gt;in(0)-&gt;Opcode() == Op_MemBarCPUOrder, &quot;&quot;);
2330             stack.push(n, n-&gt;req());
2331             n = n-&gt;in(0)-&gt;in(TypeFunc::Memory);
2332           }
2333         } else {
2334           assert(n-&gt;adr_type() == TypePtr::BOTTOM || (n-&gt;Opcode() == Op_Node &amp;&amp; n-&gt;_idx &gt;= last) || (n-&gt;is_Proj() &amp;&amp; n-&gt;in(0)-&gt;is_Initialize()), &quot;&quot;);
2335           // Build a new MergeMem node to carry the new memory state
2336           // as we build it. IGVN should fold extraneous MergeMem
2337           // nodes.
2338           mm = MergeMemNode::make(n);
2339           igvn.register_new_node_with_optimizer(mm);
2340           while (stack.size() &gt; 0) {
2341             Node* m = stack.node();
2342             uint idx = stack.index();
2343             if (m-&gt;is_Mem()) {
2344               // Move memory node to its new slice
2345               const TypePtr* adr_type = m-&gt;adr_type();
2346               int alias = get_alias_index(adr_type);
2347               Node* prev = mm-&gt;memory_at(alias);
2348               igvn.replace_input_of(m, MemNode::Memory, prev);
2349               mm-&gt;set_memory_at(alias, m);
2350             } else if (m-&gt;is_Phi()) {
2351               // We need as many new phis as there are new aliases
2352               igvn.replace_input_of(m, idx, mm);
2353               if (idx == m-&gt;req()-1) {
2354                 Node* r = m-&gt;in(0);
2355                 for (uint j = (uint)start_alias; j &lt;= (uint)stop_alias; j++) {
2356                   const Type* adr_type = get_adr_type(j);
2357                   if (!adr_type-&gt;isa_aryptr() || !adr_type-&gt;is_aryptr()-&gt;elem()-&gt;isa_valuetype()) {
2358                     continue;
2359                   }
2360                   Node* phi = new PhiNode(r, Type::MEMORY, get_adr_type(j));
2361                   igvn.register_new_node_with_optimizer(phi);
2362                   for (uint k = 1; k &lt; m-&gt;req(); k++) {
2363                     phi-&gt;init_req(k, m-&gt;in(k)-&gt;as_MergeMem()-&gt;memory_at(j));
2364                   }
2365                   mm-&gt;set_memory_at(j, phi);
2366                 }
2367                 Node* base_phi = new PhiNode(r, Type::MEMORY, TypePtr::BOTTOM);
2368                 igvn.register_new_node_with_optimizer(base_phi);
2369                 for (uint k = 1; k &lt; m-&gt;req(); k++) {
2370                   base_phi-&gt;init_req(k, m-&gt;in(k)-&gt;as_MergeMem()-&gt;base_memory());
2371                 }
2372                 mm-&gt;set_base_memory(base_phi);
2373               }
2374             } else {
2375               // This is a MemBarCPUOrder node from
2376               // Parse::array_load()/Parse::array_store(), in the
2377               // branch that handles flattened arrays hidden under
2378               // an Object[] array. We also need one new membar per
2379               // new alias to keep the unknown access that the
2380               // membars protect properly ordered with accesses to
2381               // known flattened array.
2382               assert(m-&gt;is_Proj(), &quot;projection expected&quot;);
2383               Node* ctrl = m-&gt;in(0)-&gt;in(TypeFunc::Control);
2384               igvn.replace_input_of(m-&gt;in(0), TypeFunc::Control, top());
2385               for (uint j = (uint)start_alias; j &lt;= (uint)stop_alias; j++) {
2386                 const Type* adr_type = get_adr_type(j);
2387                 if (!adr_type-&gt;isa_aryptr() || !adr_type-&gt;is_aryptr()-&gt;elem()-&gt;isa_valuetype()) {
2388                   continue;
2389                 }
2390                 MemBarNode* mb = new MemBarCPUOrderNode(this, j, NULL);
2391                 igvn.register_new_node_with_optimizer(mb);
2392                 Node* mem = mm-&gt;memory_at(j);
2393                 mb-&gt;init_req(TypeFunc::Control, ctrl);
2394                 mb-&gt;init_req(TypeFunc::Memory, mem);
2395                 ctrl = new ProjNode(mb, TypeFunc::Control);
2396                 igvn.register_new_node_with_optimizer(ctrl);
2397                 mem = new ProjNode(mb, TypeFunc::Memory);
2398                 igvn.register_new_node_with_optimizer(mem);
2399                 mm-&gt;set_memory_at(j, mem);
2400               }
2401               igvn.replace_node(m-&gt;in(0)-&gt;as_Multi()-&gt;proj_out(TypeFunc::Control), ctrl);
2402             }
2403             if (idx &lt; m-&gt;req()-1) {
2404               idx += 1;
2405               stack.set_index(idx);
2406               n = m-&gt;in(idx);
2407               break;
2408             }
2409             // Take care of place holder nodes
2410             if (m-&gt;has_out_with(Op_Node)) {
2411               Node* place_holder = m-&gt;find_out_with(Op_Node);
2412               if (place_holder != NULL) {
2413                 Node* mm_clone = mm-&gt;clone();
2414                 igvn.register_new_node_with_optimizer(mm_clone);
2415                 Node* hook = new Node(1);
2416                 hook-&gt;init_req(0, mm);
2417                 igvn.replace_node(place_holder, mm_clone);
2418                 hook-&gt;destruct();
2419               }
2420               assert(!m-&gt;has_out_with(Op_Node), &quot;place holder should be gone now&quot;);
2421             }
2422             stack.pop();
2423           }
2424         }
2425       } while(stack.size() &gt; 0);
2426       // Fix the memory state at the MergeMem we started from
2427       igvn.rehash_node_delayed(current);
2428       for (uint j = (uint)start_alias; j &lt;= (uint)stop_alias; j++) {
2429         const Type* adr_type = get_adr_type(j);
2430         if (!adr_type-&gt;isa_aryptr() || !adr_type-&gt;is_aryptr()-&gt;elem()-&gt;isa_valuetype()) {
2431           continue;
2432         }
2433         current-&gt;set_memory_at(j, mm);
2434       }
2435       current-&gt;set_memory_at(index, current-&gt;base_memory());
2436     }
2437     igvn.optimize();
2438   }
2439   print_method(PHASE_SPLIT_VALUES_ARRAY, 2);
2440 }
2441 
2442 
2443 // StringOpts and late inlining of string methods
2444 void Compile::inline_string_calls(bool parse_time) {
2445   {
2446     // remove useless nodes to make the usage analysis simpler
2447     ResourceMark rm;
2448     PhaseRemoveUseless pru(initial_gvn(), for_igvn());
2449   }
2450 
2451   {
2452     ResourceMark rm;
2453     print_method(PHASE_BEFORE_STRINGOPTS, 3);
2454     PhaseStringOpts pso(initial_gvn(), for_igvn());
2455     print_method(PHASE_AFTER_STRINGOPTS, 3);
2456   }
2457 
2458   // now inline anything that we skipped the first time around
2459   if (!parse_time) {
2460     _late_inlines_pos = _late_inlines.length();
2461   }
2462 
2463   while (_string_late_inlines.length() &gt; 0) {
2464     CallGenerator* cg = _string_late_inlines.pop();
2465     cg-&gt;do_late_inline();
2466     if (failing())  return;
2467   }
2468   _string_late_inlines.trunc_to(0);
2469 }
2470 
2471 // Late inlining of boxing methods
2472 void Compile::inline_boxing_calls(PhaseIterGVN&amp; igvn) {
2473   if (_boxing_late_inlines.length() &gt; 0) {
2474     assert(has_boxed_value(), &quot;inconsistent&quot;);
2475 
2476     PhaseGVN* gvn = initial_gvn();
2477     set_inlining_incrementally(true);
2478 
2479     assert( igvn._worklist.size() == 0, &quot;should be done with igvn&quot; );
2480     for_igvn()-&gt;clear();
2481     gvn-&gt;replace_with(&amp;igvn);
2482 
2483     _late_inlines_pos = _late_inlines.length();
2484 
2485     while (_boxing_late_inlines.length() &gt; 0) {
2486       CallGenerator* cg = _boxing_late_inlines.pop();
2487       cg-&gt;do_late_inline();
2488       if (failing())  return;
2489     }
2490     _boxing_late_inlines.trunc_to(0);
2491 
2492     inline_incrementally_cleanup(igvn);
2493 
2494     set_inlining_incrementally(false);
2495   }
2496 }
2497 
2498 bool Compile::inline_incrementally_one() {
2499   assert(IncrementalInline, &quot;incremental inlining should be on&quot;);
2500 
2501   TracePhase tp(&quot;incrementalInline_inline&quot;, &amp;timers[_t_incrInline_inline]);
2502   set_inlining_progress(false);
2503   set_do_cleanup(false);
2504   int i = 0;
2505   for (; i &lt;_late_inlines.length() &amp;&amp; !inlining_progress(); i++) {
2506     CallGenerator* cg = _late_inlines.at(i);
2507     _late_inlines_pos = i+1;
2508     cg-&gt;do_late_inline();
2509     if (failing())  return false;
2510   }
2511   int j = 0;
2512   for (; i &lt; _late_inlines.length(); i++, j++) {
2513     _late_inlines.at_put(j, _late_inlines.at(i));
2514   }
2515   _late_inlines.trunc_to(j);
2516   assert(inlining_progress() || _late_inlines.length() == 0, &quot;&quot;);
2517 
2518   bool needs_cleanup = do_cleanup() || over_inlining_cutoff();
2519 
2520   set_inlining_progress(false);
2521   set_do_cleanup(false);
2522   return (_late_inlines.length() &gt; 0) &amp;&amp; !needs_cleanup;
2523 }
2524 
2525 void Compile::inline_incrementally_cleanup(PhaseIterGVN&amp; igvn) {
2526   {
2527     TracePhase tp(&quot;incrementalInline_pru&quot;, &amp;timers[_t_incrInline_pru]);
2528     ResourceMark rm;
2529     PhaseRemoveUseless pru(initial_gvn(), for_igvn());
2530   }
2531   {
2532     TracePhase tp(&quot;incrementalInline_igvn&quot;, &amp;timers[_t_incrInline_igvn]);
2533     igvn = PhaseIterGVN(initial_gvn());
2534     igvn.optimize();
2535   }
2536 }
2537 
2538 // Perform incremental inlining until bound on number of live nodes is reached
2539 void Compile::inline_incrementally(PhaseIterGVN&amp; igvn) {
2540   TracePhase tp(&quot;incrementalInline&quot;, &amp;timers[_t_incrInline]);
2541 
2542   set_inlining_incrementally(true);
2543   uint low_live_nodes = 0;
2544 
2545   while (_late_inlines.length() &gt; 0) {
2546     if (live_nodes() &gt; (uint)LiveNodeCountInliningCutoff) {
2547       if (low_live_nodes &lt; (uint)LiveNodeCountInliningCutoff * 8 / 10) {
2548         TracePhase tp(&quot;incrementalInline_ideal&quot;, &amp;timers[_t_incrInline_ideal]);
2549         // PhaseIdealLoop is expensive so we only try it once we are
2550         // out of live nodes and we only try it again if the previous
2551         // helped got the number of nodes down significantly
2552         PhaseIdealLoop::optimize(igvn, LoopOptsNone);
2553         if (failing())  return;
2554         low_live_nodes = live_nodes();
2555         _major_progress = true;
2556       }
2557 
2558       if (live_nodes() &gt; (uint)LiveNodeCountInliningCutoff) {
2559         break; // finish
2560       }
2561     }
2562 
2563     for_igvn()-&gt;clear();
2564     initial_gvn()-&gt;replace_with(&amp;igvn);
2565 
2566     while (inline_incrementally_one()) {
2567       assert(!failing(), &quot;inconsistent&quot;);
2568     }
2569 
2570     if (failing())  return;
2571 
2572     inline_incrementally_cleanup(igvn);
2573 
2574     if (failing())  return;
2575   }
2576   assert( igvn._worklist.size() == 0, &quot;should be done with igvn&quot; );
2577 
2578   if (_string_late_inlines.length() &gt; 0) {
2579     assert(has_stringbuilder(), &quot;inconsistent&quot;);
2580     for_igvn()-&gt;clear();
2581     initial_gvn()-&gt;replace_with(&amp;igvn);
2582 
2583     inline_string_calls(false);
2584 
2585     if (failing())  return;
2586 
2587     inline_incrementally_cleanup(igvn);
2588   }
2589 
2590   set_inlining_incrementally(false);
2591 }
2592 
2593 
2594 bool Compile::optimize_loops(PhaseIterGVN&amp; igvn, LoopOptsMode mode) {
2595   if(_loop_opts_cnt &gt; 0) {
2596     debug_only( int cnt = 0; );
2597     while(major_progress() &amp;&amp; (_loop_opts_cnt &gt; 0)) {
2598       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2599       assert( cnt++ &lt; 40, &quot;infinite cycle in loop optimization&quot; );
2600       PhaseIdealLoop::optimize(igvn, mode);
2601       _loop_opts_cnt--;
2602       if (failing())  return false;
2603       if (major_progress()) print_method(PHASE_PHASEIDEALLOOP_ITERATIONS, 2);
2604     }
2605   }
2606   return true;
2607 }
2608 
2609 // Remove edges from &quot;root&quot; to each SafePoint at a backward branch.
2610 // They were inserted during parsing (see add_safepoint()) to make
2611 // infinite loops without calls or exceptions visible to root, i.e.,
2612 // useful.
2613 void Compile::remove_root_to_sfpts_edges(PhaseIterGVN&amp; igvn) {
2614   Node *r = root();
2615   if (r != NULL) {
2616     for (uint i = r-&gt;req(); i &lt; r-&gt;len(); ++i) {
2617       Node *n = r-&gt;in(i);
2618       if (n != NULL &amp;&amp; n-&gt;is_SafePoint()) {
2619         r-&gt;rm_prec(i);
2620         if (n-&gt;outcnt() == 0) {
2621           igvn.remove_dead_node(n);
2622         }
2623         --i;
2624       }
2625     }
2626     // Parsing may have added top inputs to the root node (Path
2627     // leading to the Halt node proven dead). Make sure we get a
2628     // chance to clean them up.
2629     igvn._worklist.push(r);
2630     igvn.optimize();
2631   }
2632 }
2633 
2634 //------------------------------Optimize---------------------------------------
2635 // Given a graph, optimize it.
2636 void Compile::Optimize() {
2637   TracePhase tp(&quot;optimizer&quot;, &amp;timers[_t_optimizer]);
2638 
2639 #ifndef PRODUCT
2640   if (_directive-&gt;BreakAtCompileOption) {
2641     BREAKPOINT;
2642   }
2643 
2644 #endif
2645 
2646   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
2647 #ifdef ASSERT
2648   bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeOptimize);
2649 #endif
2650 
2651   ResourceMark rm;
2652 
2653   print_inlining_reinit();
2654 
2655   NOT_PRODUCT( verify_graph_edges(); )
2656 
2657   print_method(PHASE_AFTER_PARSING);
2658 
2659  {
2660   // Iterative Global Value Numbering, including ideal transforms
2661   // Initialize IterGVN with types and values from parse-time GVN
2662   PhaseIterGVN igvn(initial_gvn());
2663 #ifdef ASSERT
2664   _modified_nodes = new (comp_arena()) Unique_Node_List(comp_arena());
2665 #endif
2666   {
2667     TracePhase tp(&quot;iterGVN&quot;, &amp;timers[_t_iterGVN]);
2668     igvn.optimize();
2669   }
2670 
2671   if (failing())  return;
2672 
2673   print_method(PHASE_ITER_GVN1, 2);
2674 
2675   inline_incrementally(igvn);
2676 
2677   print_method(PHASE_INCREMENTAL_INLINE, 2);
2678 
2679   if (failing())  return;
2680 
2681   if (eliminate_boxing()) {
2682     // Inline valueOf() methods now.
2683     inline_boxing_calls(igvn);
2684 
2685     if (AlwaysIncrementalInline) {
2686       inline_incrementally(igvn);
2687     }
2688 
2689     print_method(PHASE_INCREMENTAL_BOXING_INLINE, 2);
2690 
2691     if (failing())  return;
2692   }
2693 
2694   // Now that all inlining is over, cut edge from root to loop
2695   // safepoints
2696   remove_root_to_sfpts_edges(igvn);
2697 
2698   // Remove the speculative part of types and clean up the graph from
2699   // the extra CastPP nodes whose only purpose is to carry them. Do
2700   // that early so that optimizations are not disrupted by the extra
2701   // CastPP nodes.
2702   remove_speculative_types(igvn);
2703 
2704   // No more new expensive nodes will be added to the list from here
2705   // so keep only the actual candidates for optimizations.
2706   cleanup_expensive_nodes(igvn);
2707 
2708   if (!failing() &amp;&amp; RenumberLiveNodes &amp;&amp; live_nodes() + NodeLimitFudgeFactor &lt; unique()) {
2709     Compile::TracePhase tp(&quot;&quot;, &amp;timers[_t_renumberLive]);
2710     initial_gvn()-&gt;replace_with(&amp;igvn);
2711     for_igvn()-&gt;clear();
2712     Unique_Node_List new_worklist(C-&gt;comp_arena());
2713     {
2714       ResourceMark rm;
2715       PhaseRenumberLive prl = PhaseRenumberLive(initial_gvn(), for_igvn(), &amp;new_worklist);
2716     }
2717     set_for_igvn(&amp;new_worklist);
2718     igvn = PhaseIterGVN(initial_gvn());
2719     igvn.optimize();
2720   }
2721 
2722   if (_value_type_nodes-&gt;size() &gt; 0) {
2723     // Do this once all inlining is over to avoid getting inconsistent debug info
2724     process_value_types(igvn);
2725   }
2726 
2727   adjust_flattened_array_access_aliases(igvn);
2728 
2729   // Perform escape analysis
2730   if (_do_escape_analysis &amp;&amp; ConnectionGraph::has_candidates(this)) {
2731     if (has_loops()) {
2732       // Cleanup graph (remove dead nodes).
2733       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2734       PhaseIdealLoop::optimize(igvn, LoopOptsMaxUnroll);
2735       if (major_progress()) print_method(PHASE_PHASEIDEAL_BEFORE_EA, 2);
2736       if (failing())  return;
2737     }
2738     ConnectionGraph::do_analysis(this, &amp;igvn);
2739 
2740     if (failing())  return;
2741 
2742     // Optimize out fields loads from scalar replaceable allocations.
2743     igvn.optimize();
2744     print_method(PHASE_ITER_GVN_AFTER_EA, 2);
2745 
2746     if (failing())  return;
2747 
2748     if (congraph() != NULL &amp;&amp; macro_count() &gt; 0) {
2749       TracePhase tp(&quot;macroEliminate&quot;, &amp;timers[_t_macroEliminate]);
2750       PhaseMacroExpand mexp(igvn);
2751       mexp.eliminate_macro_nodes();
2752       igvn.set_delay_transform(false);
2753 
2754       igvn.optimize();
2755       print_method(PHASE_ITER_GVN_AFTER_ELIMINATION, 2);
2756 
2757       if (failing())  return;
2758     }
2759   }
2760 
2761   // Loop transforms on the ideal graph.  Range Check Elimination,
2762   // peeling, unrolling, etc.
2763 
2764   // Set loop opts counter
2765   if((_loop_opts_cnt &gt; 0) &amp;&amp; (has_loops() || has_split_ifs())) {
2766     {
2767       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2768       PhaseIdealLoop::optimize(igvn, LoopOptsDefault);
2769       _loop_opts_cnt--;
2770       if (major_progress()) print_method(PHASE_PHASEIDEALLOOP1, 2);
2771       if (failing())  return;
2772     }
2773     // Loop opts pass if partial peeling occurred in previous pass
2774     if(PartialPeelLoop &amp;&amp; major_progress() &amp;&amp; (_loop_opts_cnt &gt; 0)) {
2775       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2776       PhaseIdealLoop::optimize(igvn, LoopOptsSkipSplitIf);
2777       _loop_opts_cnt--;
2778       if (major_progress()) print_method(PHASE_PHASEIDEALLOOP2, 2);
2779       if (failing())  return;
2780     }
2781     // Loop opts pass for loop-unrolling before CCP
2782     if(major_progress() &amp;&amp; (_loop_opts_cnt &gt; 0)) {
2783       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2784       PhaseIdealLoop::optimize(igvn, LoopOptsSkipSplitIf);
2785       _loop_opts_cnt--;
2786       if (major_progress()) print_method(PHASE_PHASEIDEALLOOP3, 2);
2787     }
2788     if (!failing()) {
2789       // Verify that last round of loop opts produced a valid graph
2790       TracePhase tp(&quot;idealLoopVerify&quot;, &amp;timers[_t_idealLoopVerify]);
2791       PhaseIdealLoop::verify(igvn);
2792     }
2793   }
2794   if (failing())  return;
2795 
2796   // Conditional Constant Propagation;
2797   PhaseCCP ccp( &amp;igvn );
2798   assert( true, &quot;Break here to ccp.dump_nodes_and_types(_root,999,1)&quot;);
2799   {
2800     TracePhase tp(&quot;ccp&quot;, &amp;timers[_t_ccp]);
2801     ccp.do_transform();
2802   }
2803   print_method(PHASE_CPP1, 2);
2804 
2805   assert( true, &quot;Break here to ccp.dump_old2new_map()&quot;);
2806 
2807   // Iterative Global Value Numbering, including ideal transforms
2808   {
2809     TracePhase tp(&quot;iterGVN2&quot;, &amp;timers[_t_iterGVN2]);
2810     igvn = ccp;
2811     igvn.optimize();
2812   }
2813   print_method(PHASE_ITER_GVN2, 2);
2814 
2815   if (failing())  return;
2816 
2817   // Loop transforms on the ideal graph.  Range Check Elimination,
2818   // peeling, unrolling, etc.
2819   if (!optimize_loops(igvn, LoopOptsDefault)) {
2820     return;
2821   }
2822 
2823   if (failing())  return;
2824 
2825   // Ensure that major progress is now clear
2826   C-&gt;clear_major_progress();
2827 
2828   {
2829     // Verify that all previous optimizations produced a valid graph
2830     // at least to this point, even if no loop optimizations were done.
2831     TracePhase tp(&quot;idealLoopVerify&quot;, &amp;timers[_t_idealLoopVerify]);
2832     PhaseIdealLoop::verify(igvn);
2833   }
2834 
2835   if (range_check_cast_count() &gt; 0) {
2836     // No more loop optimizations. Remove all range check dependent CastIINodes.
2837     C-&gt;remove_range_check_casts(igvn);
2838     igvn.optimize();
2839   }
2840 
2841 #ifdef ASSERT
2842   bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeMacroExpand);
2843 #endif
2844 
2845   {
2846     TracePhase tp(&quot;macroExpand&quot;, &amp;timers[_t_macroExpand]);
2847     PhaseMacroExpand  mex(igvn);
2848     if (mex.expand_macro_nodes()) {
2849       assert(failing(), &quot;must bail out w/ explicit message&quot;);
2850       return;
2851     }
2852     print_method(PHASE_MACRO_EXPANSION, 2);
2853   }
2854 
2855   {
2856     TracePhase tp(&quot;barrierExpand&quot;, &amp;timers[_t_barrierExpand]);
2857     if (bs-&gt;expand_barriers(this, igvn)) {
2858       assert(failing(), &quot;must bail out w/ explicit message&quot;);
2859       return;
2860     }
2861     print_method(PHASE_BARRIER_EXPANSION, 2);
2862   }
2863 
2864   if (opaque4_count() &gt; 0) {
2865     C-&gt;remove_opaque4_nodes(igvn);
2866     igvn.optimize();
2867   }
2868 
2869   DEBUG_ONLY( _modified_nodes = NULL; )
2870  } // (End scope of igvn; run destructor if necessary for asserts.)
2871 
2872  process_print_inlining();
2873  // A method with only infinite loops has no edges entering loops from root
2874  {
2875    TracePhase tp(&quot;graphReshape&quot;, &amp;timers[_t_graphReshaping]);
2876    if (final_graph_reshaping()) {
2877      assert(failing(), &quot;must bail out w/ explicit message&quot;);
2878      return;
2879    }
2880  }
2881 
2882  print_method(PHASE_OPTIMIZE_FINISHED, 2);
2883 }
2884 
2885 //------------------------------Code_Gen---------------------------------------
2886 // Given a graph, generate code for it
2887 void Compile::Code_Gen() {
2888   if (failing()) {
2889     return;
2890   }
2891 
2892   // Perform instruction selection.  You might think we could reclaim Matcher
2893   // memory PDQ, but actually the Matcher is used in generating spill code.
2894   // Internals of the Matcher (including some VectorSets) must remain live
2895   // for awhile - thus I cannot reclaim Matcher memory lest a VectorSet usage
2896   // set a bit in reclaimed memory.
2897 
2898   // In debug mode can dump m._nodes.dump() for mapping of ideal to machine
2899   // nodes.  Mapping is only valid at the root of each matched subtree.
2900   NOT_PRODUCT( verify_graph_edges(); )
2901 
2902   Matcher matcher;
2903   _matcher = &amp;matcher;
2904   {
2905     TracePhase tp(&quot;matcher&quot;, &amp;timers[_t_matcher]);
2906     matcher.match();
2907     if (failing()) {
2908       return;
2909     }
2910   }
2911 
2912   // In debug mode can dump m._nodes.dump() for mapping of ideal to machine
2913   // nodes.  Mapping is only valid at the root of each matched subtree.
2914   NOT_PRODUCT( verify_graph_edges(); )
2915 
2916   // If you have too many nodes, or if matching has failed, bail out
2917   check_node_count(0, &quot;out of nodes matching instructions&quot;);
2918   if (failing()) {
2919     return;
2920   }
2921 
2922   print_method(PHASE_MATCHING, 2);
2923 
2924   // Build a proper-looking CFG
2925   PhaseCFG cfg(node_arena(), root(), matcher);
2926   _cfg = &amp;cfg;
2927   {
2928     TracePhase tp(&quot;scheduler&quot;, &amp;timers[_t_scheduler]);
2929     bool success = cfg.do_global_code_motion();
2930     if (!success) {
2931       return;
2932     }
2933 
2934     print_method(PHASE_GLOBAL_CODE_MOTION, 2);
2935     NOT_PRODUCT( verify_graph_edges(); )
2936     debug_only( cfg.verify(); )
2937   }
2938 
2939   PhaseChaitin regalloc(unique(), cfg, matcher, false);
2940   _regalloc = &amp;regalloc;
2941   {
2942     TracePhase tp(&quot;regalloc&quot;, &amp;timers[_t_registerAllocation]);
2943     // Perform register allocation.  After Chaitin, use-def chains are
2944     // no longer accurate (at spill code) and so must be ignored.
2945     // Node-&gt;LRG-&gt;reg mappings are still accurate.
2946     _regalloc-&gt;Register_Allocate();
2947 
2948     // Bail out if the allocator builds too many nodes
2949     if (failing()) {
2950       return;
2951     }
2952   }
2953 
2954   // Prior to register allocation we kept empty basic blocks in case the
2955   // the allocator needed a place to spill.  After register allocation we
2956   // are not adding any new instructions.  If any basic block is empty, we
2957   // can now safely remove it.
2958   {
2959     TracePhase tp(&quot;blockOrdering&quot;, &amp;timers[_t_blockOrdering]);
2960     cfg.remove_empty_blocks();
2961     if (do_freq_based_layout()) {
2962       PhaseBlockLayout layout(cfg);
2963     } else {
2964       cfg.set_loop_alignment();
2965     }
2966     cfg.fixup_flow();
2967   }
2968 
2969   // Apply peephole optimizations
2970   if( OptoPeephole ) {
2971     TracePhase tp(&quot;peephole&quot;, &amp;timers[_t_peephole]);
2972     PhasePeephole peep( _regalloc, cfg);
2973     peep.do_transform();
2974   }
2975 
2976   // Do late expand if CPU requires this.
2977   if (Matcher::require_postalloc_expand) {
2978     TracePhase tp(&quot;postalloc_expand&quot;, &amp;timers[_t_postalloc_expand]);
2979     cfg.postalloc_expand(_regalloc);
2980   }
2981 
2982   // Convert Nodes to instruction bits in a buffer
2983   {
<a name="21" id="anc21"></a><span class="line-modified">2984     TraceTime tp(&quot;output&quot;, &amp;timers[_t_output], CITime);</span>
<span class="line-modified">2985     Output();</span>



2986   }
2987 
2988   print_method(PHASE_FINAL_CODE);
2989 
2990   // He&#39;s dead, Jim.
2991   _cfg     = (PhaseCFG*)((intptr_t)0xdeadbeef);
2992   _regalloc = (PhaseChaitin*)((intptr_t)0xdeadbeef);
2993 }
2994 
<a name="22" id="anc22"></a><span class="line-removed">2995 </span>
<span class="line-removed">2996 //------------------------------dump_asm---------------------------------------</span>
<span class="line-removed">2997 // Dump formatted assembly</span>
<span class="line-removed">2998 #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="line-removed">2999 void Compile::dump_asm_on(outputStream* st, int* pcs, uint pc_limit) {</span>
<span class="line-removed">3000 </span>
<span class="line-removed">3001   int pc_digits = 3; // #chars required for pc</span>
<span class="line-removed">3002   int sb_chars  = 3; // #chars for &quot;start bundle&quot; indicator</span>
<span class="line-removed">3003   int tab_size  = 8;</span>
<span class="line-removed">3004   if (pcs != NULL) {</span>
<span class="line-removed">3005     int max_pc = 0;</span>
<span class="line-removed">3006     for (uint i = 0; i &lt; pc_limit; i++) {</span>
<span class="line-removed">3007       max_pc = (max_pc &lt; pcs[i]) ? pcs[i] : max_pc;</span>
<span class="line-removed">3008     }</span>
<span class="line-removed">3009     pc_digits  = ((max_pc &lt; 4096) ? 3 : ((max_pc &lt; 65536) ? 4 : ((max_pc &lt; 65536*256) ? 6 : 8))); // #chars required for pc</span>
<span class="line-removed">3010   }</span>
<span class="line-removed">3011   int prefix_len = ((pc_digits + sb_chars + tab_size - 1)/tab_size)*tab_size;</span>
<span class="line-removed">3012 </span>
<span class="line-removed">3013   bool cut_short = false;</span>
<span class="line-removed">3014   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="line-removed">3015   st-&gt;print(&quot;#  &quot;);  _tf-&gt;dump_on(st);  st-&gt;cr();</span>
<span class="line-removed">3016   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="line-removed">3017 </span>
<span class="line-removed">3018   // For all blocks</span>
<span class="line-removed">3019   int pc = 0x0;                 // Program counter</span>
<span class="line-removed">3020   char starts_bundle = &#39; &#39;;</span>
<span class="line-removed">3021   _regalloc-&gt;dump_frame();</span>
<span class="line-removed">3022 </span>
<span class="line-removed">3023   Node *n = NULL;</span>
<span class="line-removed">3024   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="line-removed">3025     if (VMThread::should_terminate()) {</span>
<span class="line-removed">3026       cut_short = true;</span>
<span class="line-removed">3027       break;</span>
<span class="line-removed">3028     }</span>
<span class="line-removed">3029     Block* block = _cfg-&gt;get_block(i);</span>
<span class="line-removed">3030     if (block-&gt;is_connector() &amp;&amp; !Verbose) {</span>
<span class="line-removed">3031       continue;</span>
<span class="line-removed">3032     }</span>
<span class="line-removed">3033     n = block-&gt;head();</span>
<span class="line-removed">3034     if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-removed">3035       pc = pcs[n-&gt;_idx];</span>
<span class="line-removed">3036       st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-removed">3037     }</span>
<span class="line-removed">3038     st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">3039     block-&gt;dump_head(_cfg, st);</span>
<span class="line-removed">3040     if (block-&gt;is_connector()) {</span>
<span class="line-removed">3041       st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">3042       st-&gt;print_cr(&quot;# Empty connector block&quot;);</span>
<span class="line-removed">3043     } else if (block-&gt;num_preds() == 2 &amp;&amp; block-&gt;pred(1)-&gt;is_CatchProj() &amp;&amp; block-&gt;pred(1)-&gt;as_CatchProj()-&gt;_con == CatchProjNode::fall_through_index) {</span>
<span class="line-removed">3044       st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">3045       st-&gt;print_cr(&quot;# Block is sole successor of call&quot;);</span>
<span class="line-removed">3046     }</span>
<span class="line-removed">3047 </span>
<span class="line-removed">3048     // For all instructions</span>
<span class="line-removed">3049     Node *delay = NULL;</span>
<span class="line-removed">3050     for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {</span>
<span class="line-removed">3051       if (VMThread::should_terminate()) {</span>
<span class="line-removed">3052         cut_short = true;</span>
<span class="line-removed">3053         break;</span>
<span class="line-removed">3054       }</span>
<span class="line-removed">3055       n = block-&gt;get_node(j);</span>
<span class="line-removed">3056       if (valid_bundle_info(n)) {</span>
<span class="line-removed">3057         Bundle* bundle = node_bundling(n);</span>
<span class="line-removed">3058         if (bundle-&gt;used_in_unconditional_delay()) {</span>
<span class="line-removed">3059           delay = n;</span>
<span class="line-removed">3060           continue;</span>
<span class="line-removed">3061         }</span>
<span class="line-removed">3062         if (bundle-&gt;starts_bundle()) {</span>
<span class="line-removed">3063           starts_bundle = &#39;+&#39;;</span>
<span class="line-removed">3064         }</span>
<span class="line-removed">3065       }</span>
<span class="line-removed">3066 </span>
<span class="line-removed">3067       if (WizardMode) {</span>
<span class="line-removed">3068         n-&gt;dump();</span>
<span class="line-removed">3069       }</span>
<span class="line-removed">3070 </span>
<span class="line-removed">3071       if( !n-&gt;is_Region() &amp;&amp;    // Dont print in the Assembly</span>
<span class="line-removed">3072           !n-&gt;is_Phi() &amp;&amp;       // a few noisely useless nodes</span>
<span class="line-removed">3073           !n-&gt;is_Proj() &amp;&amp;</span>
<span class="line-removed">3074           !n-&gt;is_MachTemp() &amp;&amp;</span>
<span class="line-removed">3075           !n-&gt;is_SafePointScalarObject() &amp;&amp;</span>
<span class="line-removed">3076           !n-&gt;is_Catch() &amp;&amp;     // Would be nice to print exception table targets</span>
<span class="line-removed">3077           !n-&gt;is_MergeMem() &amp;&amp;  // Not very interesting</span>
<span class="line-removed">3078           !n-&gt;is_top() &amp;&amp;       // Debug info table constants</span>
<span class="line-removed">3079           !(n-&gt;is_Con() &amp;&amp; !n-&gt;is_Mach())// Debug info table constants</span>
<span class="line-removed">3080           ) {</span>
<span class="line-removed">3081         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-removed">3082           pc = pcs[n-&gt;_idx];</span>
<span class="line-removed">3083           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-removed">3084         } else {</span>
<span class="line-removed">3085           st-&gt;fill_to(pc_digits);</span>
<span class="line-removed">3086         }</span>
<span class="line-removed">3087         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="line-removed">3088         starts_bundle = &#39; &#39;;</span>
<span class="line-removed">3089         st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">3090         n-&gt;format(_regalloc, st);</span>
<span class="line-removed">3091         st-&gt;cr();</span>
<span class="line-removed">3092       }</span>
<span class="line-removed">3093 </span>
<span class="line-removed">3094       // If we have an instruction with a delay slot, and have seen a delay,</span>
<span class="line-removed">3095       // then back up and print it</span>
<span class="line-removed">3096       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;use_unconditional_delay()) {</span>
<span class="line-removed">3097         // Coverity finding - Explicit null dereferenced.</span>
<span class="line-removed">3098         guarantee(delay != NULL, &quot;no unconditional delay instruction&quot;);</span>
<span class="line-removed">3099         if (WizardMode) delay-&gt;dump();</span>
<span class="line-removed">3100 </span>
<span class="line-removed">3101         if (node_bundling(delay)-&gt;starts_bundle())</span>
<span class="line-removed">3102           starts_bundle = &#39;+&#39;;</span>
<span class="line-removed">3103         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-removed">3104           pc = pcs[n-&gt;_idx];</span>
<span class="line-removed">3105           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-removed">3106         } else {</span>
<span class="line-removed">3107           st-&gt;fill_to(pc_digits);</span>
<span class="line-removed">3108         }</span>
<span class="line-removed">3109         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="line-removed">3110         starts_bundle = &#39; &#39;;</span>
<span class="line-removed">3111         st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">3112         delay-&gt;format(_regalloc, st);</span>
<span class="line-removed">3113         st-&gt;cr();</span>
<span class="line-removed">3114         delay = NULL;</span>
<span class="line-removed">3115       }</span>
<span class="line-removed">3116 </span>
<span class="line-removed">3117       // Dump the exception table as well</span>
<span class="line-removed">3118       if( n-&gt;is_Catch() &amp;&amp; (Verbose || WizardMode) ) {</span>
<span class="line-removed">3119         // Print the exception table for this offset</span>
<span class="line-removed">3120         _handler_table.print_subtable_for(pc);</span>
<span class="line-removed">3121       }</span>
<span class="line-removed">3122       st-&gt;bol(); // Make sure we start on a new line</span>
<span class="line-removed">3123     }</span>
<span class="line-removed">3124     st-&gt;cr(); // one empty line between blocks</span>
<span class="line-removed">3125     assert(cut_short || delay == NULL, &quot;no unconditional delay branch&quot;);</span>
<span class="line-removed">3126   } // End of per-block dump</span>
<span class="line-removed">3127 </span>
<span class="line-removed">3128   if (cut_short)  st-&gt;print_cr(&quot;*** disassembly is cut short ***&quot;);</span>
<span class="line-removed">3129 }</span>
<span class="line-removed">3130 #endif</span>
<span class="line-removed">3131 </span>
3132 //------------------------------Final_Reshape_Counts---------------------------
3133 // This class defines counters to help identify when a method
3134 // may/must be executed using hardware with only 24-bit precision.
3135 struct Final_Reshape_Counts : public StackObj {
3136   int  _call_count;             // count non-inlined &#39;common&#39; calls
3137   int  _float_count;            // count float ops requiring 24-bit precision
3138   int  _double_count;           // count double ops requiring more precision
3139   int  _java_call_count;        // count non-inlined &#39;java&#39; calls
3140   int  _inner_loop_count;       // count loops which need alignment
3141   VectorSet _visited;           // Visitation flags
3142   Node_List _tests;             // Set of IfNodes &amp; PCTableNodes
3143 
3144   Final_Reshape_Counts() :
3145     _call_count(0), _float_count(0), _double_count(0),
3146     _java_call_count(0), _inner_loop_count(0),
3147     _visited( Thread::current()-&gt;resource_area() ) { }
3148 
3149   void inc_call_count  () { _call_count  ++; }
3150   void inc_float_count () { _float_count ++; }
3151   void inc_double_count() { _double_count++; }
3152   void inc_java_call_count() { _java_call_count++; }
3153   void inc_inner_loop_count() { _inner_loop_count++; }
3154 
3155   int  get_call_count  () const { return _call_count  ; }
3156   int  get_float_count () const { return _float_count ; }
3157   int  get_double_count() const { return _double_count; }
3158   int  get_java_call_count() const { return _java_call_count; }
3159   int  get_inner_loop_count() const { return _inner_loop_count; }
3160 };
3161 
3162 #ifdef ASSERT
3163 static bool oop_offset_is_sane(const TypeInstPtr* tp) {
3164   ciInstanceKlass *k = tp-&gt;klass()-&gt;as_instance_klass();
3165   // Make sure the offset goes inside the instance layout.
3166   return k-&gt;contains_field_offset(tp-&gt;offset());
3167   // Note that OffsetBot and OffsetTop are very negative.
3168 }
3169 #endif
3170 
3171 // Eliminate trivially redundant StoreCMs and accumulate their
3172 // precedence edges.
3173 void Compile::eliminate_redundant_card_marks(Node* n) {
3174   assert(n-&gt;Opcode() == Op_StoreCM, &quot;expected StoreCM&quot;);
3175   if (n-&gt;in(MemNode::Address)-&gt;outcnt() &gt; 1) {
3176     // There are multiple users of the same address so it might be
3177     // possible to eliminate some of the StoreCMs
3178     Node* mem = n-&gt;in(MemNode::Memory);
3179     Node* adr = n-&gt;in(MemNode::Address);
3180     Node* val = n-&gt;in(MemNode::ValueIn);
3181     Node* prev = n;
3182     bool done = false;
3183     // Walk the chain of StoreCMs eliminating ones that match.  As
3184     // long as it&#39;s a chain of single users then the optimization is
3185     // safe.  Eliminating partially redundant StoreCMs would require
3186     // cloning copies down the other paths.
3187     while (mem-&gt;Opcode() == Op_StoreCM &amp;&amp; mem-&gt;outcnt() == 1 &amp;&amp; !done) {
3188       if (adr == mem-&gt;in(MemNode::Address) &amp;&amp;
3189           val == mem-&gt;in(MemNode::ValueIn)) {
3190         // redundant StoreCM
3191         if (mem-&gt;req() &gt; MemNode::OopStore) {
3192           // Hasn&#39;t been processed by this code yet.
3193           n-&gt;add_prec(mem-&gt;in(MemNode::OopStore));
3194         } else {
3195           // Already converted to precedence edge
3196           for (uint i = mem-&gt;req(); i &lt; mem-&gt;len(); i++) {
3197             // Accumulate any precedence edges
3198             if (mem-&gt;in(i) != NULL) {
3199               n-&gt;add_prec(mem-&gt;in(i));
3200             }
3201           }
3202           // Everything above this point has been processed.
3203           done = true;
3204         }
3205         // Eliminate the previous StoreCM
3206         prev-&gt;set_req(MemNode::Memory, mem-&gt;in(MemNode::Memory));
3207         assert(mem-&gt;outcnt() == 0, &quot;should be dead&quot;);
3208         mem-&gt;disconnect_inputs(NULL, this);
3209       } else {
3210         prev = mem;
3211       }
3212       mem = prev-&gt;in(MemNode::Memory);
3213     }
3214   }
3215 }
3216 
3217 
3218 //------------------------------final_graph_reshaping_impl----------------------
3219 // Implement items 1-5 from final_graph_reshaping below.
3220 void Compile::final_graph_reshaping_impl( Node *n, Final_Reshape_Counts &amp;frc) {
3221 
3222   if ( n-&gt;outcnt() == 0 ) return; // dead node
3223   uint nop = n-&gt;Opcode();
3224 
3225   // Check for 2-input instruction with &quot;last use&quot; on right input.
3226   // Swap to left input.  Implements item (2).
3227   if( n-&gt;req() == 3 &amp;&amp;          // two-input instruction
3228       n-&gt;in(1)-&gt;outcnt() &gt; 1 &amp;&amp; // left use is NOT a last use
3229       (!n-&gt;in(1)-&gt;is_Phi() || n-&gt;in(1)-&gt;in(2) != n) &amp;&amp; // it is not data loop
3230       n-&gt;in(2)-&gt;outcnt() == 1 &amp;&amp;// right use IS a last use
3231       !n-&gt;in(2)-&gt;is_Con() ) {   // right use is not a constant
3232     // Check for commutative opcode
3233     switch( nop ) {
3234     case Op_AddI:  case Op_AddF:  case Op_AddD:  case Op_AddL:
3235     case Op_MaxI:  case Op_MinI:
3236     case Op_MulI:  case Op_MulF:  case Op_MulD:  case Op_MulL:
3237     case Op_AndL:  case Op_XorL:  case Op_OrL:
3238     case Op_AndI:  case Op_XorI:  case Op_OrI: {
3239       // Move &quot;last use&quot; input to left by swapping inputs
3240       n-&gt;swap_edges(1, 2);
3241       break;
3242     }
3243     default:
3244       break;
3245     }
3246   }
3247 
3248 #ifdef ASSERT
3249   if( n-&gt;is_Mem() ) {
3250     int alias_idx = get_alias_index(n-&gt;as_Mem()-&gt;adr_type());
3251     assert( n-&gt;in(0) != NULL || alias_idx != Compile::AliasIdxRaw ||
3252             // oop will be recorded in oop map if load crosses safepoint
3253             n-&gt;is_Load() &amp;&amp; (n-&gt;as_Load()-&gt;bottom_type()-&gt;isa_oopptr() ||
3254                              LoadNode::is_immutable_value(n-&gt;in(MemNode::Address))),
3255             &quot;raw memory operations should have control edge&quot;);
3256   }
3257   if (n-&gt;is_MemBar()) {
3258     MemBarNode* mb = n-&gt;as_MemBar();
3259     if (mb-&gt;trailing_store() || mb-&gt;trailing_load_store()) {
3260       assert(mb-&gt;leading_membar()-&gt;trailing_membar() == mb, &quot;bad membar pair&quot;);
3261       Node* mem = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;step_over_gc_barrier(mb-&gt;in(MemBarNode::Precedent));
3262       assert((mb-&gt;trailing_store() &amp;&amp; mem-&gt;is_Store() &amp;&amp; mem-&gt;as_Store()-&gt;is_release()) ||
3263              (mb-&gt;trailing_load_store() &amp;&amp; mem-&gt;is_LoadStore()), &quot;missing mem op&quot;);
3264     } else if (mb-&gt;leading()) {
3265       assert(mb-&gt;trailing_membar()-&gt;leading_membar() == mb, &quot;bad membar pair&quot;);
3266     }
3267   }
3268 #endif
3269   // Count FPU ops and common calls, implements item (3)
3270   bool gc_handled = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;final_graph_reshaping(this, n, nop);
3271   if (!gc_handled) {
3272     final_graph_reshaping_main_switch(n, frc, nop);
3273   }
3274 
3275   // Collect CFG split points
3276   if (n-&gt;is_MultiBranch() &amp;&amp; !n-&gt;is_RangeCheck()) {
3277     frc._tests.push(n);
3278   }
3279 }
3280 
3281 void Compile::final_graph_reshaping_main_switch(Node* n, Final_Reshape_Counts&amp; frc, uint nop) {
3282   switch( nop ) {
3283   // Count all float operations that may use FPU
3284   case Op_AddF:
3285   case Op_SubF:
3286   case Op_MulF:
3287   case Op_DivF:
3288   case Op_NegF:
3289   case Op_ModF:
3290   case Op_ConvI2F:
3291   case Op_ConF:
3292   case Op_CmpF:
3293   case Op_CmpF3:
3294   // case Op_ConvL2F: // longs are split into 32-bit halves
3295     frc.inc_float_count();
3296     break;
3297 
3298   case Op_ConvF2D:
3299   case Op_ConvD2F:
3300     frc.inc_float_count();
3301     frc.inc_double_count();
3302     break;
3303 
3304   // Count all double operations that may use FPU
3305   case Op_AddD:
3306   case Op_SubD:
3307   case Op_MulD:
3308   case Op_DivD:
3309   case Op_NegD:
3310   case Op_ModD:
3311   case Op_ConvI2D:
3312   case Op_ConvD2I:
3313   // case Op_ConvL2D: // handled by leaf call
3314   // case Op_ConvD2L: // handled by leaf call
3315   case Op_ConD:
3316   case Op_CmpD:
3317   case Op_CmpD3:
3318     frc.inc_double_count();
3319     break;
3320   case Op_Opaque1:              // Remove Opaque Nodes before matching
3321   case Op_Opaque2:              // Remove Opaque Nodes before matching
3322   case Op_Opaque3:
3323     n-&gt;subsume_by(n-&gt;in(1), this);
3324     break;
3325   case Op_CallStaticJava:
3326   case Op_CallJava:
3327   case Op_CallDynamicJava:
3328     frc.inc_java_call_count(); // Count java call site;
3329   case Op_CallRuntime:
3330   case Op_CallLeaf:
3331   case Op_CallLeafNoFP: {
3332     assert (n-&gt;is_Call(), &quot;&quot;);
3333     CallNode *call = n-&gt;as_Call();
3334     // Count call sites where the FP mode bit would have to be flipped.
3335     // Do not count uncommon runtime calls:
3336     // uncommon_trap, _complete_monitor_locking, _complete_monitor_unlocking,
3337     // _new_Java, _new_typeArray, _new_objArray, _rethrow_Java, ...
3338     if (!call-&gt;is_CallStaticJava() || !call-&gt;as_CallStaticJava()-&gt;_name) {
3339       frc.inc_call_count();   // Count the call site
3340     } else {                  // See if uncommon argument is shared
3341       Node *n = call-&gt;in(TypeFunc::Parms);
3342       int nop = n-&gt;Opcode();
3343       // Clone shared simple arguments to uncommon calls, item (1).
3344       if (n-&gt;outcnt() &gt; 1 &amp;&amp;
3345           !n-&gt;is_Proj() &amp;&amp;
3346           nop != Op_CreateEx &amp;&amp;
3347           nop != Op_CheckCastPP &amp;&amp;
3348           nop != Op_DecodeN &amp;&amp;
3349           nop != Op_DecodeNKlass &amp;&amp;
3350           !n-&gt;is_Mem() &amp;&amp;
3351           !n-&gt;is_Phi()) {
3352         Node *x = n-&gt;clone();
3353         call-&gt;set_req(TypeFunc::Parms, x);
3354       }
3355     }
3356     break;
3357   }
3358 
3359   case Op_StoreD:
3360   case Op_LoadD:
3361   case Op_LoadD_unaligned:
3362     frc.inc_double_count();
3363     goto handle_mem;
3364   case Op_StoreF:
3365   case Op_LoadF:
3366     frc.inc_float_count();
3367     goto handle_mem;
3368 
3369   case Op_StoreCM:
3370     {
3371       // Convert OopStore dependence into precedence edge
3372       Node* prec = n-&gt;in(MemNode::OopStore);
3373       n-&gt;del_req(MemNode::OopStore);
3374       n-&gt;add_prec(prec);
3375       eliminate_redundant_card_marks(n);
3376     }
3377 
3378     // fall through
3379 
3380   case Op_StoreB:
3381   case Op_StoreC:
3382   case Op_StorePConditional:
3383   case Op_StoreI:
3384   case Op_StoreL:
3385   case Op_StoreIConditional:
3386   case Op_StoreLConditional:
3387   case Op_CompareAndSwapB:
3388   case Op_CompareAndSwapS:
3389   case Op_CompareAndSwapI:
3390   case Op_CompareAndSwapL:
3391   case Op_CompareAndSwapP:
3392   case Op_CompareAndSwapN:
3393   case Op_WeakCompareAndSwapB:
3394   case Op_WeakCompareAndSwapS:
3395   case Op_WeakCompareAndSwapI:
3396   case Op_WeakCompareAndSwapL:
3397   case Op_WeakCompareAndSwapP:
3398   case Op_WeakCompareAndSwapN:
3399   case Op_CompareAndExchangeB:
3400   case Op_CompareAndExchangeS:
3401   case Op_CompareAndExchangeI:
3402   case Op_CompareAndExchangeL:
3403   case Op_CompareAndExchangeP:
3404   case Op_CompareAndExchangeN:
3405   case Op_GetAndAddS:
3406   case Op_GetAndAddB:
3407   case Op_GetAndAddI:
3408   case Op_GetAndAddL:
3409   case Op_GetAndSetS:
3410   case Op_GetAndSetB:
3411   case Op_GetAndSetI:
3412   case Op_GetAndSetL:
3413   case Op_GetAndSetP:
3414   case Op_GetAndSetN:
3415   case Op_StoreP:
3416   case Op_StoreN:
3417   case Op_StoreNKlass:
3418   case Op_LoadB:
3419   case Op_LoadUB:
3420   case Op_LoadUS:
3421   case Op_LoadI:
3422   case Op_LoadKlass:
3423   case Op_LoadNKlass:
3424   case Op_LoadL:
3425   case Op_LoadL_unaligned:
3426   case Op_LoadPLocked:
3427   case Op_LoadP:
3428   case Op_LoadN:
3429   case Op_LoadRange:
3430   case Op_LoadS: {
3431   handle_mem:
3432 #ifdef ASSERT
3433     if( VerifyOptoOopOffsets ) {
3434       MemNode* mem  = n-&gt;as_Mem();
3435       // Check to see if address types have grounded out somehow.
3436       const TypeInstPtr *tp = mem-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;isa_instptr();
3437       assert( !tp || oop_offset_is_sane(tp), &quot;&quot; );
3438     }
3439 #endif
3440     if (EnableValhalla &amp;&amp;
3441         ((nop == Op_LoadKlass &amp;&amp; ((LoadKlassNode*)n)-&gt;clear_prop_bits()) ||
3442          (nop == Op_LoadNKlass &amp;&amp; ((LoadNKlassNode*)n)-&gt;clear_prop_bits()))) {
3443       const TypeKlassPtr* tk = n-&gt;bottom_type()-&gt;make_ptr()-&gt;is_klassptr();
3444       assert(!tk-&gt;klass_is_exact(), &quot;should have been folded&quot;);
3445       assert(n-&gt;as_Mem()-&gt;adr_type()-&gt;offset() == oopDesc::klass_offset_in_bytes(), &quot;unexpected LoadKlass&quot;);
3446       if (tk-&gt;klass()-&gt;can_be_value_array_klass()) {
3447         // Array load klass needs to filter out property bits (but not
3448         // GetNullFreePropertyNode or GetFlattenedPropertyNode which
3449         // needs to extract the storage property bits)
3450         uint last = unique();
3451         Node* pointer = NULL;
3452         if (nop == Op_LoadKlass) {
3453           Node* cast = new CastP2XNode(NULL, n);
3454           Node* masked = new LShiftXNode(cast, new ConINode(TypeInt::make(oopDesc::storage_props_nof_bits)));
3455           masked = new RShiftXNode(masked, new ConINode(TypeInt::make(oopDesc::storage_props_nof_bits)));
3456           pointer = new CastX2PNode(masked);
3457           pointer = new CheckCastPPNode(NULL, pointer, n-&gt;bottom_type());
3458         } else {
3459           Node* cast = new CastN2INode(n);
3460           Node* masked = new AndINode(cast, new ConINode(TypeInt::make(oopDesc::compressed_klass_mask())));
3461           pointer = new CastI2NNode(masked, n-&gt;bottom_type());
3462         }
3463         for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3464           Node* u = n-&gt;fast_out(i);
3465           if (u-&gt;_idx &lt; last &amp;&amp; u-&gt;Opcode() != Op_GetNullFreeProperty &amp;&amp; u-&gt;Opcode() != Op_GetFlattenedProperty) {
3466             // If user is a comparison with a klass that can&#39;t be a value type
3467             // array klass, we don&#39;t need to clear the storage property bits.
3468             Node* cmp = (u-&gt;is_DecodeNKlass() &amp;&amp; u-&gt;outcnt() == 1) ? u-&gt;unique_out() : u;
3469             if (cmp-&gt;is_Cmp()) {
3470               const TypeKlassPtr* kp1 = cmp-&gt;in(1)-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_klassptr();
3471               const TypeKlassPtr* kp2 = cmp-&gt;in(2)-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_klassptr();
3472               if ((kp1 != NULL &amp;&amp; !kp1-&gt;klass()-&gt;can_be_value_array_klass()) ||
3473                   (kp2 != NULL &amp;&amp; !kp2-&gt;klass()-&gt;can_be_value_array_klass())) {
3474                 continue;
3475               }
3476             }
3477             int nb = u-&gt;replace_edge(n, pointer);
3478             --i, imax -= nb;
3479           }
3480         }
3481       }
3482     }
3483     break;
3484   }
3485 
3486   case Op_AddP: {               // Assert sane base pointers
3487     Node *addp = n-&gt;in(AddPNode::Address);
3488     assert( !addp-&gt;is_AddP() ||
3489             addp-&gt;in(AddPNode::Base)-&gt;is_top() || // Top OK for allocation
3490             addp-&gt;in(AddPNode::Base) == n-&gt;in(AddPNode::Base),
3491             &quot;Base pointers must match (addp %u)&quot;, addp-&gt;_idx );
3492 #ifdef _LP64
3493     if ((UseCompressedOops || UseCompressedClassPointers) &amp;&amp;
3494         addp-&gt;Opcode() == Op_ConP &amp;&amp;
3495         addp == n-&gt;in(AddPNode::Base) &amp;&amp;
3496         n-&gt;in(AddPNode::Offset)-&gt;is_Con()) {
3497       // If the transformation of ConP to ConN+DecodeN is beneficial depends
3498       // on the platform and on the compressed oops mode.
3499       // Use addressing with narrow klass to load with offset on x86.
3500       // Some platforms can use the constant pool to load ConP.
3501       // Do this transformation here since IGVN will convert ConN back to ConP.
3502       const Type* t = addp-&gt;bottom_type();
3503       bool is_oop   = t-&gt;isa_oopptr() != NULL;
3504       bool is_klass = t-&gt;isa_klassptr() != NULL;
3505 
3506       if ((is_oop   &amp;&amp; Matcher::const_oop_prefer_decode()  ) ||
3507           (is_klass &amp;&amp; Matcher::const_klass_prefer_decode())) {
3508         Node* nn = NULL;
3509 
3510         int op = is_oop ? Op_ConN : Op_ConNKlass;
3511 
3512         // Look for existing ConN node of the same exact type.
3513         Node* r  = root();
3514         uint cnt = r-&gt;outcnt();
3515         for (uint i = 0; i &lt; cnt; i++) {
3516           Node* m = r-&gt;raw_out(i);
3517           if (m!= NULL &amp;&amp; m-&gt;Opcode() == op &amp;&amp;
3518               m-&gt;bottom_type()-&gt;make_ptr() == t) {
3519             nn = m;
3520             break;
3521           }
3522         }
3523         if (nn != NULL) {
3524           // Decode a narrow oop to match address
3525           // [R12 + narrow_oop_reg&lt;&lt;3 + offset]
3526           if (is_oop) {
3527             nn = new DecodeNNode(nn, t);
3528           } else {
3529             nn = new DecodeNKlassNode(nn, t);
3530           }
3531           // Check for succeeding AddP which uses the same Base.
3532           // Otherwise we will run into the assertion above when visiting that guy.
3533           for (uint i = 0; i &lt; n-&gt;outcnt(); ++i) {
3534             Node *out_i = n-&gt;raw_out(i);
3535             if (out_i &amp;&amp; out_i-&gt;is_AddP() &amp;&amp; out_i-&gt;in(AddPNode::Base) == addp) {
3536               out_i-&gt;set_req(AddPNode::Base, nn);
3537 #ifdef ASSERT
3538               for (uint j = 0; j &lt; out_i-&gt;outcnt(); ++j) {
3539                 Node *out_j = out_i-&gt;raw_out(j);
3540                 assert(out_j == NULL || !out_j-&gt;is_AddP() || out_j-&gt;in(AddPNode::Base) != addp,
3541                        &quot;more than 2 AddP nodes in a chain (out_j %u)&quot;, out_j-&gt;_idx);
3542               }
3543 #endif
3544             }
3545           }
3546           n-&gt;set_req(AddPNode::Base, nn);
3547           n-&gt;set_req(AddPNode::Address, nn);
3548           if (addp-&gt;outcnt() == 0) {
3549             addp-&gt;disconnect_inputs(NULL, this);
3550           }
3551         }
3552       }
3553     }
3554 #endif
3555     // platform dependent reshaping of the address expression
3556     reshape_address(n-&gt;as_AddP());
3557     break;
3558   }
3559 
3560   case Op_CastPP: {
3561     // Remove CastPP nodes to gain more freedom during scheduling but
3562     // keep the dependency they encode as control or precedence edges
3563     // (if control is set already) on memory operations. Some CastPP
3564     // nodes don&#39;t have a control (don&#39;t carry a dependency): skip
3565     // those.
3566     if (n-&gt;in(0) != NULL) {
3567       ResourceMark rm;
3568       Unique_Node_List wq;
3569       wq.push(n);
3570       for (uint next = 0; next &lt; wq.size(); ++next) {
3571         Node *m = wq.at(next);
3572         for (DUIterator_Fast imax, i = m-&gt;fast_outs(imax); i &lt; imax; i++) {
3573           Node* use = m-&gt;fast_out(i);
3574           if (use-&gt;is_Mem() || use-&gt;is_EncodeNarrowPtr()) {
3575             use-&gt;ensure_control_or_add_prec(n-&gt;in(0));
3576           } else {
3577             switch(use-&gt;Opcode()) {
3578             case Op_AddP:
3579             case Op_DecodeN:
3580             case Op_DecodeNKlass:
3581             case Op_CheckCastPP:
3582             case Op_CastPP:
3583               wq.push(use);
3584               break;
3585             }
3586           }
3587         }
3588       }
3589     }
3590     const bool is_LP64 = LP64_ONLY(true) NOT_LP64(false);
3591     if (is_LP64 &amp;&amp; n-&gt;in(1)-&gt;is_DecodeN() &amp;&amp; Matcher::gen_narrow_oop_implicit_null_checks()) {
3592       Node* in1 = n-&gt;in(1);
3593       const Type* t = n-&gt;bottom_type();
3594       Node* new_in1 = in1-&gt;clone();
3595       new_in1-&gt;as_DecodeN()-&gt;set_type(t);
3596 
3597       if (!Matcher::narrow_oop_use_complex_address()) {
3598         //
3599         // x86, ARM and friends can handle 2 adds in addressing mode
3600         // and Matcher can fold a DecodeN node into address by using
3601         // a narrow oop directly and do implicit NULL check in address:
3602         //
3603         // [R12 + narrow_oop_reg&lt;&lt;3 + offset]
3604         // NullCheck narrow_oop_reg
3605         //
3606         // On other platforms (Sparc) we have to keep new DecodeN node and
3607         // use it to do implicit NULL check in address:
3608         //
3609         // decode_not_null narrow_oop_reg, base_reg
3610         // [base_reg + offset]
3611         // NullCheck base_reg
3612         //
3613         // Pin the new DecodeN node to non-null path on these platform (Sparc)
3614         // to keep the information to which NULL check the new DecodeN node
3615         // corresponds to use it as value in implicit_null_check().
3616         //
3617         new_in1-&gt;set_req(0, n-&gt;in(0));
3618       }
3619 
3620       n-&gt;subsume_by(new_in1, this);
3621       if (in1-&gt;outcnt() == 0) {
3622         in1-&gt;disconnect_inputs(NULL, this);
3623       }
3624     } else {
3625       n-&gt;subsume_by(n-&gt;in(1), this);
3626       if (n-&gt;outcnt() == 0) {
3627         n-&gt;disconnect_inputs(NULL, this);
3628       }
3629     }
3630     break;
3631   }
3632 #ifdef _LP64
3633   case Op_CmpP:
3634     // Do this transformation here to preserve CmpPNode::sub() and
3635     // other TypePtr related Ideal optimizations (for example, ptr nullness).
3636     if (n-&gt;in(1)-&gt;is_DecodeNarrowPtr() || n-&gt;in(2)-&gt;is_DecodeNarrowPtr()) {
3637       Node* in1 = n-&gt;in(1);
3638       Node* in2 = n-&gt;in(2);
3639       if (!in1-&gt;is_DecodeNarrowPtr()) {
3640         in2 = in1;
3641         in1 = n-&gt;in(2);
3642       }
3643       assert(in1-&gt;is_DecodeNarrowPtr(), &quot;sanity&quot;);
3644 
3645       Node* new_in2 = NULL;
3646       if (in2-&gt;is_DecodeNarrowPtr()) {
3647         assert(in2-&gt;Opcode() == in1-&gt;Opcode(), &quot;must be same node type&quot;);
3648         new_in2 = in2-&gt;in(1);
3649       } else if (in2-&gt;Opcode() == Op_ConP) {
3650         const Type* t = in2-&gt;bottom_type();
3651         if (t == TypePtr::NULL_PTR) {
3652           assert(in1-&gt;is_DecodeN(), &quot;compare klass to null?&quot;);
3653           // Don&#39;t convert CmpP null check into CmpN if compressed
3654           // oops implicit null check is not generated.
3655           // This will allow to generate normal oop implicit null check.
3656           if (Matcher::gen_narrow_oop_implicit_null_checks())
3657             new_in2 = ConNode::make(TypeNarrowOop::NULL_PTR);
3658           //
3659           // This transformation together with CastPP transformation above
3660           // will generated code for implicit NULL checks for compressed oops.
3661           //
3662           // The original code after Optimize()
3663           //
3664           //    LoadN memory, narrow_oop_reg
3665           //    decode narrow_oop_reg, base_reg
3666           //    CmpP base_reg, NULL
3667           //    CastPP base_reg // NotNull
3668           //    Load [base_reg + offset], val_reg
3669           //
3670           // after these transformations will be
3671           //
3672           //    LoadN memory, narrow_oop_reg
3673           //    CmpN narrow_oop_reg, NULL
3674           //    decode_not_null narrow_oop_reg, base_reg
3675           //    Load [base_reg + offset], val_reg
3676           //
3677           // and the uncommon path (== NULL) will use narrow_oop_reg directly
3678           // since narrow oops can be used in debug info now (see the code in
3679           // final_graph_reshaping_walk()).
3680           //
3681           // At the end the code will be matched to
3682           // on x86:
3683           //
3684           //    Load_narrow_oop memory, narrow_oop_reg
3685           //    Load [R12 + narrow_oop_reg&lt;&lt;3 + offset], val_reg
3686           //    NullCheck narrow_oop_reg
3687           //
3688           // and on sparc:
3689           //
3690           //    Load_narrow_oop memory, narrow_oop_reg
3691           //    decode_not_null narrow_oop_reg, base_reg
3692           //    Load [base_reg + offset], val_reg
3693           //    NullCheck base_reg
3694           //
3695         } else if (t-&gt;isa_oopptr()) {
3696           new_in2 = ConNode::make(t-&gt;make_narrowoop());
3697         } else if (t-&gt;isa_klassptr()) {
3698           new_in2 = ConNode::make(t-&gt;make_narrowklass());
3699         }
3700       }
3701       if (new_in2 != NULL) {
3702         Node* cmpN = new CmpNNode(in1-&gt;in(1), new_in2);
3703         n-&gt;subsume_by(cmpN, this);
3704         if (in1-&gt;outcnt() == 0) {
3705           in1-&gt;disconnect_inputs(NULL, this);
3706         }
3707         if (in2-&gt;outcnt() == 0) {
3708           in2-&gt;disconnect_inputs(NULL, this);
3709         }
3710       }
3711     }
3712     break;
3713 
3714   case Op_DecodeN:
3715   case Op_DecodeNKlass:
3716     assert(!n-&gt;in(1)-&gt;is_EncodeNarrowPtr(), &quot;should be optimized out&quot;);
3717     // DecodeN could be pinned when it can&#39;t be fold into
3718     // an address expression, see the code for Op_CastPP above.
3719     assert(n-&gt;in(0) == NULL || (UseCompressedOops &amp;&amp; !Matcher::narrow_oop_use_complex_address()), &quot;no control&quot;);
3720     break;
3721 
3722   case Op_EncodeP:
3723   case Op_EncodePKlass: {
3724     Node* in1 = n-&gt;in(1);
3725     if (in1-&gt;is_DecodeNarrowPtr()) {
3726       n-&gt;subsume_by(in1-&gt;in(1), this);
3727     } else if (in1-&gt;Opcode() == Op_ConP) {
3728       const Type* t = in1-&gt;bottom_type();
3729       if (t == TypePtr::NULL_PTR) {
3730         assert(t-&gt;isa_oopptr(), &quot;null klass?&quot;);
3731         n-&gt;subsume_by(ConNode::make(TypeNarrowOop::NULL_PTR), this);
3732       } else if (t-&gt;isa_oopptr()) {
3733         n-&gt;subsume_by(ConNode::make(t-&gt;make_narrowoop()), this);
3734       } else if (t-&gt;isa_klassptr()) {
3735         n-&gt;subsume_by(ConNode::make(t-&gt;make_narrowklass()), this);
3736       }
3737     }
3738     if (in1-&gt;outcnt() == 0) {
3739       in1-&gt;disconnect_inputs(NULL, this);
3740     }
3741     break;
3742   }
3743 
3744   case Op_Proj: {
3745     if (OptimizeStringConcat) {
3746       ProjNode* p = n-&gt;as_Proj();
3747       if (p-&gt;_is_io_use) {
3748         // Separate projections were used for the exception path which
3749         // are normally removed by a late inline.  If it wasn&#39;t inlined
3750         // then they will hang around and should just be replaced with
3751         // the original one.
3752         Node* proj = NULL;
3753         // Replace with just one
3754         for (SimpleDUIterator i(p-&gt;in(0)); i.has_next(); i.next()) {
3755           Node *use = i.get();
3756           if (use-&gt;is_Proj() &amp;&amp; p != use &amp;&amp; use-&gt;as_Proj()-&gt;_con == p-&gt;_con) {
3757             proj = use;
3758             break;
3759           }
3760         }
3761         assert(proj != NULL || p-&gt;_con == TypeFunc::I_O, &quot;io may be dropped at an infinite loop&quot;);
3762         if (proj != NULL) {
3763           p-&gt;subsume_by(proj, this);
3764         }
3765       }
3766     }
3767     break;
3768   }
3769 
3770   case Op_Phi:
3771     if (n-&gt;as_Phi()-&gt;bottom_type()-&gt;isa_narrowoop() || n-&gt;as_Phi()-&gt;bottom_type()-&gt;isa_narrowklass()) {
3772       // The EncodeP optimization may create Phi with the same edges
3773       // for all paths. It is not handled well by Register Allocator.
3774       Node* unique_in = n-&gt;in(1);
3775       assert(unique_in != NULL, &quot;&quot;);
3776       uint cnt = n-&gt;req();
3777       for (uint i = 2; i &lt; cnt; i++) {
3778         Node* m = n-&gt;in(i);
3779         assert(m != NULL, &quot;&quot;);
3780         if (unique_in != m)
3781           unique_in = NULL;
3782       }
3783       if (unique_in != NULL) {
3784         n-&gt;subsume_by(unique_in, this);
3785       }
3786     }
3787     break;
3788 
3789 #endif
3790 
3791 #ifdef ASSERT
3792   case Op_CastII:
3793     // Verify that all range check dependent CastII nodes were removed.
3794     if (n-&gt;isa_CastII()-&gt;has_range_check()) {
3795       n-&gt;dump(3);
3796       assert(false, &quot;Range check dependent CastII node was not removed&quot;);
3797     }
3798     break;
3799 #endif
3800 
3801   case Op_ModI:
3802     if (UseDivMod) {
3803       // Check if a%b and a/b both exist
3804       Node* d = n-&gt;find_similar(Op_DivI);
3805       if (d) {
3806         // Replace them with a fused divmod if supported
3807         if (Matcher::has_match_rule(Op_DivModI)) {
3808           DivModINode* divmod = DivModINode::make(n);
3809           d-&gt;subsume_by(divmod-&gt;div_proj(), this);
3810           n-&gt;subsume_by(divmod-&gt;mod_proj(), this);
3811         } else {
3812           // replace a%b with a-((a/b)*b)
3813           Node* mult = new MulINode(d, d-&gt;in(2));
3814           Node* sub  = new SubINode(d-&gt;in(1), mult);
3815           n-&gt;subsume_by(sub, this);
3816         }
3817       }
3818     }
3819     break;
3820 
3821   case Op_ModL:
3822     if (UseDivMod) {
3823       // Check if a%b and a/b both exist
3824       Node* d = n-&gt;find_similar(Op_DivL);
3825       if (d) {
3826         // Replace them with a fused divmod if supported
3827         if (Matcher::has_match_rule(Op_DivModL)) {
3828           DivModLNode* divmod = DivModLNode::make(n);
3829           d-&gt;subsume_by(divmod-&gt;div_proj(), this);
3830           n-&gt;subsume_by(divmod-&gt;mod_proj(), this);
3831         } else {
3832           // replace a%b with a-((a/b)*b)
3833           Node* mult = new MulLNode(d, d-&gt;in(2));
3834           Node* sub  = new SubLNode(d-&gt;in(1), mult);
3835           n-&gt;subsume_by(sub, this);
3836         }
3837       }
3838     }
3839     break;
3840 
3841   case Op_LoadVector:
3842   case Op_StoreVector:
3843     break;
3844 
3845   case Op_AddReductionVI:
3846   case Op_AddReductionVL:
3847   case Op_AddReductionVF:
3848   case Op_AddReductionVD:
3849   case Op_MulReductionVI:
3850   case Op_MulReductionVL:
3851   case Op_MulReductionVF:
3852   case Op_MulReductionVD:
3853   case Op_MinReductionV:
3854   case Op_MaxReductionV:
<a name="23" id="anc23"></a>


3855     break;
3856 
3857   case Op_PackB:
3858   case Op_PackS:
3859   case Op_PackI:
3860   case Op_PackF:
3861   case Op_PackL:
3862   case Op_PackD:
3863     if (n-&gt;req()-1 &gt; 2) {
3864       // Replace many operand PackNodes with a binary tree for matching
3865       PackNode* p = (PackNode*) n;
3866       Node* btp = p-&gt;binary_tree_pack(1, n-&gt;req());
3867       n-&gt;subsume_by(btp, this);
3868     }
3869     break;
3870   case Op_Loop:
3871   case Op_CountedLoop:
3872   case Op_OuterStripMinedLoop:
3873     if (n-&gt;as_Loop()-&gt;is_inner_loop()) {
3874       frc.inc_inner_loop_count();
3875     }
3876     n-&gt;as_Loop()-&gt;verify_strip_mined(0);
3877     break;
3878   case Op_LShiftI:
3879   case Op_RShiftI:
3880   case Op_URShiftI:
3881   case Op_LShiftL:
3882   case Op_RShiftL:
3883   case Op_URShiftL:
3884     if (Matcher::need_masked_shift_count) {
3885       // The cpu&#39;s shift instructions don&#39;t restrict the count to the
3886       // lower 5/6 bits. We need to do the masking ourselves.
3887       Node* in2 = n-&gt;in(2);
3888       juint mask = (n-&gt;bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);
3889       const TypeInt* t = in2-&gt;find_int_type();
3890       if (t != NULL &amp;&amp; t-&gt;is_con()) {
3891         juint shift = t-&gt;get_con();
3892         if (shift &gt; mask) { // Unsigned cmp
3893           n-&gt;set_req(2, ConNode::make(TypeInt::make(shift &amp; mask)));
3894         }
3895       } else {
3896         if (t == NULL || t-&gt;_lo &lt; 0 || t-&gt;_hi &gt; (int)mask) {
3897           Node* shift = new AndINode(in2, ConNode::make(TypeInt::make(mask)));
3898           n-&gt;set_req(2, shift);
3899         }
3900       }
3901       if (in2-&gt;outcnt() == 0) { // Remove dead node
3902         in2-&gt;disconnect_inputs(NULL, this);
3903       }
3904     }
3905     break;
3906   case Op_MemBarStoreStore:
3907   case Op_MemBarRelease:
3908     // Break the link with AllocateNode: it is no longer useful and
3909     // confuses register allocation.
3910     if (n-&gt;req() &gt; MemBarNode::Precedent) {
3911       n-&gt;set_req(MemBarNode::Precedent, top());
3912     }
3913     break;
3914   case Op_MemBarAcquire: {
3915     if (n-&gt;as_MemBar()-&gt;trailing_load() &amp;&amp; n-&gt;req() &gt; MemBarNode::Precedent) {
3916       // At parse time, the trailing MemBarAcquire for a volatile load
3917       // is created with an edge to the load. After optimizations,
3918       // that input may be a chain of Phis. If those phis have no
3919       // other use, then the MemBarAcquire keeps them alive and
3920       // register allocation can be confused.
3921       ResourceMark rm;
3922       Unique_Node_List wq;
3923       wq.push(n-&gt;in(MemBarNode::Precedent));
3924       n-&gt;set_req(MemBarNode::Precedent, top());
3925       while (wq.size() &gt; 0) {
3926         Node* m = wq.pop();
3927         if (m-&gt;outcnt() == 0) {
3928           for (uint j = 0; j &lt; m-&gt;req(); j++) {
3929             Node* in = m-&gt;in(j);
3930             if (in != NULL) {
3931               wq.push(in);
3932             }
3933           }
3934           m-&gt;disconnect_inputs(NULL, this);
3935         }
3936       }
3937     }
3938     break;
3939   }
3940   case Op_RangeCheck: {
3941     RangeCheckNode* rc = n-&gt;as_RangeCheck();
3942     Node* iff = new IfNode(rc-&gt;in(0), rc-&gt;in(1), rc-&gt;_prob, rc-&gt;_fcnt);
3943     n-&gt;subsume_by(iff, this);
3944     frc._tests.push(iff);
3945     break;
3946   }
3947   case Op_ConvI2L: {
3948     if (!Matcher::convi2l_type_required) {
3949       // Code generation on some platforms doesn&#39;t need accurate
3950       // ConvI2L types. Widening the type can help remove redundant
3951       // address computations.
3952       n-&gt;as_Type()-&gt;set_type(TypeLong::INT);
3953       ResourceMark rm;
3954       Unique_Node_List wq;
3955       wq.push(n);
3956       for (uint next = 0; next &lt; wq.size(); next++) {
3957         Node *m = wq.at(next);
3958 
3959         for(;;) {
3960           // Loop over all nodes with identical inputs edges as m
3961           Node* k = m-&gt;find_similar(m-&gt;Opcode());
3962           if (k == NULL) {
3963             break;
3964           }
3965           // Push their uses so we get a chance to remove node made
3966           // redundant
3967           for (DUIterator_Fast imax, i = k-&gt;fast_outs(imax); i &lt; imax; i++) {
3968             Node* u = k-&gt;fast_out(i);
3969             if (u-&gt;Opcode() == Op_LShiftL ||
3970                 u-&gt;Opcode() == Op_AddL ||
3971                 u-&gt;Opcode() == Op_SubL ||
3972                 u-&gt;Opcode() == Op_AddP) {
3973               wq.push(u);
3974             }
3975           }
3976           // Replace all nodes with identical edges as m with m
3977           k-&gt;subsume_by(m, this);
3978         }
3979       }
3980     }
3981     break;
3982   }
3983   case Op_CmpUL: {
3984     if (!Matcher::has_match_rule(Op_CmpUL)) {
3985       // No support for unsigned long comparisons
3986       ConINode* sign_pos = new ConINode(TypeInt::make(BitsPerLong - 1));
3987       Node* sign_bit_mask = new RShiftLNode(n-&gt;in(1), sign_pos);
3988       Node* orl = new OrLNode(n-&gt;in(1), sign_bit_mask);
3989       ConLNode* remove_sign_mask = new ConLNode(TypeLong::make(max_jlong));
3990       Node* andl = new AndLNode(orl, remove_sign_mask);
3991       Node* cmp = new CmpLNode(andl, n-&gt;in(2));
3992       n-&gt;subsume_by(cmp, this);
3993     }
3994     break;
3995   }
3996 #ifdef ASSERT
3997   case Op_ValueTypePtr:
3998   case Op_ValueType: {
3999     n-&gt;dump(-1);
4000     assert(false, &quot;value type node was not removed&quot;);
4001     break;
4002   }
4003 #endif
4004   case Op_GetNullFreeProperty:
4005   case Op_GetFlattenedProperty: {
4006     // Extract the null free bits
4007     uint last = unique();
4008     Node* null_free = NULL;
4009     int bit = nop == Op_GetNullFreeProperty ? ArrayStorageProperties::null_free_bit : ArrayStorageProperties::flattened_bit;
4010     if (n-&gt;in(1)-&gt;Opcode() == Op_LoadKlass) {
4011       Node* cast = new CastP2XNode(NULL, n-&gt;in(1));
4012       null_free = new AndLNode(cast, new ConLNode(TypeLong::make(((jlong)1)&lt;&lt;(oopDesc::wide_storage_props_shift + bit))));
4013     } else {
4014       assert(n-&gt;in(1)-&gt;Opcode() == Op_LoadNKlass, &quot;not a compressed klass?&quot;);
4015       Node* cast = new CastN2INode(n-&gt;in(1));
4016       null_free = new AndINode(cast, new ConINode(TypeInt::make(1&lt;&lt;(oopDesc::narrow_storage_props_shift + bit))));
4017     }
4018     n-&gt;subsume_by(null_free, this);
4019     break;
4020   }
4021   default:
4022     assert(!n-&gt;is_Call(), &quot;&quot;);
4023     assert(!n-&gt;is_Mem(), &quot;&quot;);
4024     assert(nop != Op_ProfileBoolean, &quot;should be eliminated during IGVN&quot;);
4025     break;
4026   }
4027 }
4028 
4029 //------------------------------final_graph_reshaping_walk---------------------
4030 // Replacing Opaque nodes with their input in final_graph_reshaping_impl(),
4031 // requires that the walk visits a node&#39;s inputs before visiting the node.
4032 void Compile::final_graph_reshaping_walk( Node_Stack &amp;nstack, Node *root, Final_Reshape_Counts &amp;frc ) {
4033   ResourceArea *area = Thread::current()-&gt;resource_area();
4034   Unique_Node_List sfpt(area);
4035 
4036   frc._visited.set(root-&gt;_idx); // first, mark node as visited
4037   uint cnt = root-&gt;req();
4038   Node *n = root;
4039   uint  i = 0;
4040   while (true) {
4041     if (i &lt; cnt) {
4042       // Place all non-visited non-null inputs onto stack
4043       Node* m = n-&gt;in(i);
4044       ++i;
4045       if (m != NULL &amp;&amp; !frc._visited.test_set(m-&gt;_idx)) {
4046         if (m-&gt;is_SafePoint() &amp;&amp; m-&gt;as_SafePoint()-&gt;jvms() != NULL) {
4047           // compute worst case interpreter size in case of a deoptimization
4048           update_interpreter_frame_size(m-&gt;as_SafePoint()-&gt;jvms()-&gt;interpreter_frame_size());
4049 
4050           sfpt.push(m);
4051         }
4052         cnt = m-&gt;req();
4053         nstack.push(n, i); // put on stack parent and next input&#39;s index
4054         n = m;
4055         i = 0;
4056       }
4057     } else {
4058       // Now do post-visit work
4059       final_graph_reshaping_impl( n, frc );
4060       if (nstack.is_empty())
4061         break;             // finished
4062       n = nstack.node();   // Get node from stack
4063       cnt = n-&gt;req();
4064       i = nstack.index();
4065       nstack.pop();        // Shift to the next node on stack
4066     }
4067   }
4068 
4069   // Skip next transformation if compressed oops are not used.
4070   if ((UseCompressedOops &amp;&amp; !Matcher::gen_narrow_oop_implicit_null_checks()) ||
4071       (!UseCompressedOops &amp;&amp; !UseCompressedClassPointers))
4072     return;
4073 
4074   // Go over safepoints nodes to skip DecodeN/DecodeNKlass nodes for debug edges.
4075   // It could be done for an uncommon traps or any safepoints/calls
4076   // if the DecodeN/DecodeNKlass node is referenced only in a debug info.
4077   while (sfpt.size() &gt; 0) {
4078     n = sfpt.pop();
4079     JVMState *jvms = n-&gt;as_SafePoint()-&gt;jvms();
4080     assert(jvms != NULL, &quot;sanity&quot;);
4081     int start = jvms-&gt;debug_start();
4082     int end   = n-&gt;req();
4083     bool is_uncommon = (n-&gt;is_CallStaticJava() &amp;&amp;
4084                         n-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0);
4085     for (int j = start; j &lt; end; j++) {
4086       Node* in = n-&gt;in(j);
4087       if (in-&gt;is_DecodeNarrowPtr()) {
4088         bool safe_to_skip = true;
4089         if (!is_uncommon ) {
4090           // Is it safe to skip?
4091           for (uint i = 0; i &lt; in-&gt;outcnt(); i++) {
4092             Node* u = in-&gt;raw_out(i);
4093             if (!u-&gt;is_SafePoint() ||
4094                 (u-&gt;is_Call() &amp;&amp; u-&gt;as_Call()-&gt;has_non_debug_use(n))) {
4095               safe_to_skip = false;
4096             }
4097           }
4098         }
4099         if (safe_to_skip) {
4100           n-&gt;set_req(j, in-&gt;in(1));
4101         }
4102         if (in-&gt;outcnt() == 0) {
4103           in-&gt;disconnect_inputs(NULL, this);
4104         }
4105       }
4106     }
4107   }
4108 }
4109 
4110 //------------------------------final_graph_reshaping--------------------------
4111 // Final Graph Reshaping.
4112 //
4113 // (1) Clone simple inputs to uncommon calls, so they can be scheduled late
4114 //     and not commoned up and forced early.  Must come after regular
4115 //     optimizations to avoid GVN undoing the cloning.  Clone constant
4116 //     inputs to Loop Phis; these will be split by the allocator anyways.
4117 //     Remove Opaque nodes.
4118 // (2) Move last-uses by commutative operations to the left input to encourage
4119 //     Intel update-in-place two-address operations and better register usage
4120 //     on RISCs.  Must come after regular optimizations to avoid GVN Ideal
4121 //     calls canonicalizing them back.
4122 // (3) Count the number of double-precision FP ops, single-precision FP ops
4123 //     and call sites.  On Intel, we can get correct rounding either by
4124 //     forcing singles to memory (requires extra stores and loads after each
4125 //     FP bytecode) or we can set a rounding mode bit (requires setting and
4126 //     clearing the mode bit around call sites).  The mode bit is only used
4127 //     if the relative frequency of single FP ops to calls is low enough.
4128 //     This is a key transform for SPEC mpeg_audio.
4129 // (4) Detect infinite loops; blobs of code reachable from above but not
4130 //     below.  Several of the Code_Gen algorithms fail on such code shapes,
4131 //     so we simply bail out.  Happens a lot in ZKM.jar, but also happens
4132 //     from time to time in other codes (such as -Xcomp finalizer loops, etc).
4133 //     Detection is by looking for IfNodes where only 1 projection is
4134 //     reachable from below or CatchNodes missing some targets.
4135 // (5) Assert for insane oop offsets in debug mode.
4136 
4137 bool Compile::final_graph_reshaping() {
4138   // an infinite loop may have been eliminated by the optimizer,
4139   // in which case the graph will be empty.
4140   if (root()-&gt;req() == 1) {
4141     record_method_not_compilable(&quot;trivial infinite loop&quot;);
4142     return true;
4143   }
4144 
4145   // Expensive nodes have their control input set to prevent the GVN
4146   // from freely commoning them. There&#39;s no GVN beyond this point so
4147   // no need to keep the control input. We want the expensive nodes to
4148   // be freely moved to the least frequent code path by gcm.
4149   assert(OptimizeExpensiveOps || expensive_count() == 0, &quot;optimization off but list non empty?&quot;);
4150   for (int i = 0; i &lt; expensive_count(); i++) {
4151     _expensive_nodes-&gt;at(i)-&gt;set_req(0, NULL);
4152   }
4153 
4154   Final_Reshape_Counts frc;
4155 
4156   // Visit everybody reachable!
4157   // Allocate stack of size C-&gt;live_nodes()/2 to avoid frequent realloc
4158   Node_Stack nstack(live_nodes() &gt;&gt; 1);
4159   final_graph_reshaping_walk(nstack, root(), frc);
4160 
4161   // Check for unreachable (from below) code (i.e., infinite loops).
4162   for( uint i = 0; i &lt; frc._tests.size(); i++ ) {
4163     MultiBranchNode *n = frc._tests[i]-&gt;as_MultiBranch();
4164     // Get number of CFG targets.
4165     // Note that PCTables include exception targets after calls.
4166     uint required_outcnt = n-&gt;required_outcnt();
4167     if (n-&gt;outcnt() != required_outcnt) {
4168       // Check for a few special cases.  Rethrow Nodes never take the
4169       // &#39;fall-thru&#39; path, so expected kids is 1 less.
4170       if (n-&gt;is_PCTable() &amp;&amp; n-&gt;in(0) &amp;&amp; n-&gt;in(0)-&gt;in(0)) {
4171         if (n-&gt;in(0)-&gt;in(0)-&gt;is_Call()) {
4172           CallNode *call = n-&gt;in(0)-&gt;in(0)-&gt;as_Call();
4173           if (call-&gt;entry_point() == OptoRuntime::rethrow_stub()) {
4174             required_outcnt--;      // Rethrow always has 1 less kid
4175           } else if (call-&gt;req() &gt; TypeFunc::Parms &amp;&amp;
4176                      call-&gt;is_CallDynamicJava()) {
4177             // Check for null receiver. In such case, the optimizer has
4178             // detected that the virtual call will always result in a null
4179             // pointer exception. The fall-through projection of this CatchNode
4180             // will not be populated.
4181             Node *arg0 = call-&gt;in(TypeFunc::Parms);
4182             if (arg0-&gt;is_Type() &amp;&amp;
4183                 arg0-&gt;as_Type()-&gt;type()-&gt;higher_equal(TypePtr::NULL_PTR)) {
4184               required_outcnt--;
4185             }
4186           } else if (call-&gt;entry_point() == OptoRuntime::new_array_Java() &amp;&amp;
4187                      call-&gt;req() &gt; TypeFunc::Parms+1 &amp;&amp;
4188                      call-&gt;is_CallStaticJava()) {
4189             // Check for negative array length. In such case, the optimizer has
4190             // detected that the allocation attempt will always result in an
4191             // exception. There is no fall-through projection of this CatchNode .
4192             Node *arg1 = call-&gt;in(TypeFunc::Parms+1);
4193             if (arg1-&gt;is_Type() &amp;&amp;
4194                 arg1-&gt;as_Type()-&gt;type()-&gt;join(TypeInt::POS)-&gt;empty()) {
4195               required_outcnt--;
4196             }
4197           }
4198         }
4199       }
4200       // Recheck with a better notion of &#39;required_outcnt&#39;
4201       if (n-&gt;outcnt() != required_outcnt) {
4202         record_method_not_compilable(&quot;malformed control flow&quot;);
4203         return true;            // Not all targets reachable!
4204       }
4205     }
4206     // Check that I actually visited all kids.  Unreached kids
4207     // must be infinite loops.
4208     for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++)
4209       if (!frc._visited.test(n-&gt;fast_out(j)-&gt;_idx)) {
4210         record_method_not_compilable(&quot;infinite loop&quot;);
4211         return true;            // Found unvisited kid; must be unreach
4212       }
4213 
4214     // Here so verification code in final_graph_reshaping_walk()
4215     // always see an OuterStripMinedLoopEnd
4216     if (n-&gt;is_OuterStripMinedLoopEnd()) {
4217       IfNode* init_iff = n-&gt;as_If();
4218       Node* iff = new IfNode(init_iff-&gt;in(0), init_iff-&gt;in(1), init_iff-&gt;_prob, init_iff-&gt;_fcnt);
4219       n-&gt;subsume_by(iff, this);
4220     }
4221   }
4222 
4223 #ifdef IA32
4224   // If original bytecodes contained a mixture of floats and doubles
4225   // check if the optimizer has made it homogenous, item (3).
4226   if (UseSSE == 0 &amp;&amp;
4227       frc.get_float_count() &gt; 32 &amp;&amp;
4228       frc.get_double_count() == 0 &amp;&amp;
4229       (10 * frc.get_call_count() &lt; frc.get_float_count()) ) {
4230     set_24_bit_selection_and_mode(false, true);
4231   }
4232 #endif // IA32
4233 
4234   set_java_calls(frc.get_java_call_count());
4235   set_inner_loops(frc.get_inner_loop_count());
4236 
4237   // No infinite loops, no reason to bail out.
4238   return false;
4239 }
4240 
4241 //-----------------------------too_many_traps----------------------------------
4242 // Report if there are too many traps at the current method and bci.
4243 // Return true if there was a trap, and/or PerMethodTrapLimit is exceeded.
4244 bool Compile::too_many_traps(ciMethod* method,
4245                              int bci,
4246                              Deoptimization::DeoptReason reason) {
4247   ciMethodData* md = method-&gt;method_data();
4248   if (md-&gt;is_empty()) {
4249     // Assume the trap has not occurred, or that it occurred only
4250     // because of a transient condition during start-up in the interpreter.
4251     return false;
4252   }
4253   ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this-&gt;method() : NULL;
4254   if (md-&gt;has_trap_at(bci, m, reason) != 0) {
4255     // Assume PerBytecodeTrapLimit==0, for a more conservative heuristic.
4256     // Also, if there are multiple reasons, or if there is no per-BCI record,
4257     // assume the worst.
4258     if (log())
4259       log()-&gt;elem(&quot;observe trap=&#39;%s&#39; count=&#39;%d&#39;&quot;,
4260                   Deoptimization::trap_reason_name(reason),
4261                   md-&gt;trap_count(reason));
4262     return true;
4263   } else {
4264     // Ignore method/bci and see if there have been too many globally.
4265     return too_many_traps(reason, md);
4266   }
4267 }
4268 
4269 // Less-accurate variant which does not require a method and bci.
4270 bool Compile::too_many_traps(Deoptimization::DeoptReason reason,
4271                              ciMethodData* logmd) {
4272   if (trap_count(reason) &gt;= Deoptimization::per_method_trap_limit(reason)) {
4273     // Too many traps globally.
4274     // Note that we use cumulative trap_count, not just md-&gt;trap_count.
4275     if (log()) {
4276       int mcount = (logmd == NULL)? -1: (int)logmd-&gt;trap_count(reason);
4277       log()-&gt;elem(&quot;observe trap=&#39;%s&#39; count=&#39;0&#39; mcount=&#39;%d&#39; ccount=&#39;%d&#39;&quot;,
4278                   Deoptimization::trap_reason_name(reason),
4279                   mcount, trap_count(reason));
4280     }
4281     return true;
4282   } else {
4283     // The coast is clear.
4284     return false;
4285   }
4286 }
4287 
4288 //--------------------------too_many_recompiles--------------------------------
4289 // Report if there are too many recompiles at the current method and bci.
4290 // Consults PerBytecodeRecompilationCutoff and PerMethodRecompilationCutoff.
4291 // Is not eager to return true, since this will cause the compiler to use
4292 // Action_none for a trap point, to avoid too many recompilations.
4293 bool Compile::too_many_recompiles(ciMethod* method,
4294                                   int bci,
4295                                   Deoptimization::DeoptReason reason) {
4296   ciMethodData* md = method-&gt;method_data();
4297   if (md-&gt;is_empty()) {
4298     // Assume the trap has not occurred, or that it occurred only
4299     // because of a transient condition during start-up in the interpreter.
4300     return false;
4301   }
4302   // Pick a cutoff point well within PerBytecodeRecompilationCutoff.
4303   uint bc_cutoff = (uint) PerBytecodeRecompilationCutoff / 8;
4304   uint m_cutoff  = (uint) PerMethodRecompilationCutoff / 2 + 1;  // not zero
4305   Deoptimization::DeoptReason per_bc_reason
4306     = Deoptimization::reason_recorded_per_bytecode_if_any(reason);
4307   ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this-&gt;method() : NULL;
4308   if ((per_bc_reason == Deoptimization::Reason_none
4309        || md-&gt;has_trap_at(bci, m, reason) != 0)
4310       // The trap frequency measure we care about is the recompile count:
4311       &amp;&amp; md-&gt;trap_recompiled_at(bci, m)
4312       &amp;&amp; md-&gt;overflow_recompile_count() &gt;= bc_cutoff) {
4313     // Do not emit a trap here if it has already caused recompilations.
4314     // Also, if there are multiple reasons, or if there is no per-BCI record,
4315     // assume the worst.
4316     if (log())
4317       log()-&gt;elem(&quot;observe trap=&#39;%s recompiled&#39; count=&#39;%d&#39; recompiles2=&#39;%d&#39;&quot;,
4318                   Deoptimization::trap_reason_name(reason),
4319                   md-&gt;trap_count(reason),
4320                   md-&gt;overflow_recompile_count());
4321     return true;
4322   } else if (trap_count(reason) != 0
4323              &amp;&amp; decompile_count() &gt;= m_cutoff) {
4324     // Too many recompiles globally, and we have seen this sort of trap.
4325     // Use cumulative decompile_count, not just md-&gt;decompile_count.
4326     if (log())
4327       log()-&gt;elem(&quot;observe trap=&#39;%s&#39; count=&#39;%d&#39; mcount=&#39;%d&#39; decompiles=&#39;%d&#39; mdecompiles=&#39;%d&#39;&quot;,
4328                   Deoptimization::trap_reason_name(reason),
4329                   md-&gt;trap_count(reason), trap_count(reason),
4330                   md-&gt;decompile_count(), decompile_count());
4331     return true;
4332   } else {
4333     // The coast is clear.
4334     return false;
4335   }
4336 }
4337 
4338 // Compute when not to trap. Used by matching trap based nodes and
4339 // NullCheck optimization.
4340 void Compile::set_allowed_deopt_reasons() {
4341   _allowed_reasons = 0;
4342   if (is_method_compilation()) {
4343     for (int rs = (int)Deoptimization::Reason_none+1; rs &lt; Compile::trapHistLength; rs++) {
4344       assert(rs &lt; BitsPerInt, &quot;recode bit map&quot;);
4345       if (!too_many_traps((Deoptimization::DeoptReason) rs)) {
4346         _allowed_reasons |= nth_bit(rs);
4347       }
4348     }
4349   }
4350 }
4351 
4352 bool Compile::needs_clinit_barrier(ciMethod* method, ciMethod* accessing_method) {
4353   return method-&gt;is_static() &amp;&amp; needs_clinit_barrier(method-&gt;holder(), accessing_method);
4354 }
4355 
4356 bool Compile::needs_clinit_barrier(ciField* field, ciMethod* accessing_method) {
4357   return field-&gt;is_static() &amp;&amp; needs_clinit_barrier(field-&gt;holder(), accessing_method);
4358 }
4359 
4360 bool Compile::needs_clinit_barrier(ciInstanceKlass* holder, ciMethod* accessing_method) {
4361   if (holder-&gt;is_initialized()) {
4362     return false;
4363   }
4364   if (holder-&gt;is_being_initialized()) {
4365     if (accessing_method-&gt;holder() == holder) {
4366       // Access inside a class. The barrier can be elided when access happens in &lt;clinit&gt;,
4367       // &lt;init&gt;, or a static method. In all those cases, there was an initialization
4368       // barrier on the holder klass passed.
4369       if (accessing_method-&gt;is_class_initializer() ||
4370           accessing_method-&gt;is_object_constructor() ||
4371           accessing_method-&gt;is_static()) {
4372         return false;
4373       }
4374     } else if (accessing_method-&gt;holder()-&gt;is_subclass_of(holder)) {
4375       // Access from a subclass. The barrier can be elided only when access happens in &lt;clinit&gt;.
4376       // In case of &lt;init&gt; or a static method, the barrier is on the subclass is not enough:
4377       // child class can become fully initialized while its parent class is still being initialized.
4378       if (accessing_method-&gt;is_class_initializer()) {
4379         return false;
4380       }
4381     }
4382     ciMethod* root = method(); // the root method of compilation
4383     if (root != accessing_method) {
4384       return needs_clinit_barrier(holder, root); // check access in the context of compilation root
4385     }
4386   }
4387   return true;
4388 }
4389 
4390 #ifndef PRODUCT
4391 //------------------------------verify_graph_edges---------------------------
4392 // Walk the Graph and verify that there is a one-to-one correspondence
4393 // between Use-Def edges and Def-Use edges in the graph.
4394 void Compile::verify_graph_edges(bool no_dead_code) {
4395   if (VerifyGraphEdges) {
4396     ResourceArea *area = Thread::current()-&gt;resource_area();
4397     Unique_Node_List visited(area);
4398     // Call recursive graph walk to check edges
4399     _root-&gt;verify_edges(visited);
4400     if (no_dead_code) {
4401       // Now make sure that no visited node is used by an unvisited node.
4402       bool dead_nodes = false;
4403       Unique_Node_List checked(area);
4404       while (visited.size() &gt; 0) {
4405         Node* n = visited.pop();
4406         checked.push(n);
4407         for (uint i = 0; i &lt; n-&gt;outcnt(); i++) {
4408           Node* use = n-&gt;raw_out(i);
4409           if (checked.member(use))  continue;  // already checked
4410           if (visited.member(use))  continue;  // already in the graph
4411           if (use-&gt;is_Con())        continue;  // a dead ConNode is OK
4412           // At this point, we have found a dead node which is DU-reachable.
4413           if (!dead_nodes) {
4414             tty-&gt;print_cr(&quot;*** Dead nodes reachable via DU edges:&quot;);
4415             dead_nodes = true;
4416           }
4417           use-&gt;dump(2);
4418           tty-&gt;print_cr(&quot;---&quot;);
4419           checked.push(use);  // No repeats; pretend it is now checked.
4420         }
4421       }
4422       assert(!dead_nodes, &quot;using nodes must be reachable from root&quot;);
4423     }
4424   }
4425 }
4426 #endif
4427 
4428 // The Compile object keeps track of failure reasons separately from the ciEnv.
4429 // This is required because there is not quite a 1-1 relation between the
4430 // ciEnv and its compilation task and the Compile object.  Note that one
4431 // ciEnv might use two Compile objects, if C2Compiler::compile_method decides
4432 // to backtrack and retry without subsuming loads.  Other than this backtracking
4433 // behavior, the Compile&#39;s failure reason is quietly copied up to the ciEnv
4434 // by the logic in C2Compiler.
4435 void Compile::record_failure(const char* reason) {
4436   if (log() != NULL) {
4437     log()-&gt;elem(&quot;failure reason=&#39;%s&#39; phase=&#39;compile&#39;&quot;, reason);
4438   }
4439   if (_failure_reason == NULL) {
4440     // Record the first failure reason.
4441     _failure_reason = reason;
4442   }
4443 
4444   if (!C-&gt;failure_reason_is(C2Compiler::retry_no_subsuming_loads())) {
4445     C-&gt;print_method(PHASE_FAILURE);
4446   }
4447   _root = NULL;  // flush the graph, too
4448 }
4449 
4450 Compile::TracePhase::TracePhase(const char* name, elapsedTimer* accumulator)
4451   : TraceTime(name, accumulator, CITime, CITimeVerbose),
4452     _phase_name(name), _dolog(CITimeVerbose)
4453 {
4454   if (_dolog) {
4455     C = Compile::current();
4456     _log = C-&gt;log();
4457   } else {
4458     C = NULL;
4459     _log = NULL;
4460   }
4461   if (_log != NULL) {
4462     _log-&gt;begin_head(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39;&quot;, _phase_name, C-&gt;unique(), C-&gt;live_nodes());
4463     _log-&gt;stamp();
4464     _log-&gt;end_head();
4465   }
4466 }
4467 
4468 Compile::TracePhase::~TracePhase() {
4469 
4470   C = Compile::current();
4471   if (_dolog) {
4472     _log = C-&gt;log();
4473   } else {
4474     _log = NULL;
4475   }
4476 
4477 #ifdef ASSERT
4478   if (PrintIdealNodeCount) {
4479     tty-&gt;print_cr(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39; live_graph_walk=&#39;%d&#39;&quot;,
4480                   _phase_name, C-&gt;unique(), C-&gt;live_nodes(), C-&gt;count_live_nodes_by_graph_walk());
4481   }
4482 
4483   if (VerifyIdealNodeCount) {
4484     Compile::current()-&gt;print_missing_nodes();
4485   }
4486 #endif
4487 
4488   if (_log != NULL) {
4489     _log-&gt;done(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39;&quot;, _phase_name, C-&gt;unique(), C-&gt;live_nodes());
4490   }
4491 }
4492 
<a name="24" id="anc24"></a><span class="line-removed">4493 //=============================================================================</span>
<span class="line-removed">4494 // Two Constant&#39;s are equal when the type and the value are equal.</span>
<span class="line-removed">4495 bool Compile::Constant::operator==(const Constant&amp; other) {</span>
<span class="line-removed">4496   if (type()          != other.type()         )  return false;</span>
<span class="line-removed">4497   if (can_be_reused() != other.can_be_reused())  return false;</span>
<span class="line-removed">4498   // For floating point values we compare the bit pattern.</span>
<span class="line-removed">4499   switch (type()) {</span>
<span class="line-removed">4500   case T_INT:</span>
<span class="line-removed">4501   case T_FLOAT:   return (_v._value.i == other._v._value.i);</span>
<span class="line-removed">4502   case T_LONG:</span>
<span class="line-removed">4503   case T_DOUBLE:  return (_v._value.j == other._v._value.j);</span>
<span class="line-removed">4504   case T_OBJECT:</span>
<span class="line-removed">4505   case T_ADDRESS: return (_v._value.l == other._v._value.l);</span>
<span class="line-removed">4506   case T_VOID:    return (_v._value.l == other._v._value.l);  // jump-table entries</span>
<span class="line-removed">4507   case T_METADATA: return (_v._metadata == other._v._metadata);</span>
<span class="line-removed">4508   default: ShouldNotReachHere(); return false;</span>
<span class="line-removed">4509   }</span>
<span class="line-removed">4510 }</span>
<span class="line-removed">4511 </span>
<span class="line-removed">4512 static int type_to_size_in_bytes(BasicType t) {</span>
<span class="line-removed">4513   switch (t) {</span>
<span class="line-removed">4514   case T_INT:     return sizeof(jint   );</span>
<span class="line-removed">4515   case T_LONG:    return sizeof(jlong  );</span>
<span class="line-removed">4516   case T_FLOAT:   return sizeof(jfloat );</span>
<span class="line-removed">4517   case T_DOUBLE:  return sizeof(jdouble);</span>
<span class="line-removed">4518   case T_METADATA: return sizeof(Metadata*);</span>
<span class="line-removed">4519     // We use T_VOID as marker for jump-table entries (labels) which</span>
<span class="line-removed">4520     // need an internal word relocation.</span>
<span class="line-removed">4521   case T_VOID:</span>
<span class="line-removed">4522   case T_ADDRESS:</span>
<span class="line-removed">4523   case T_OBJECT:  return sizeof(jobject);</span>
<span class="line-removed">4524   default:</span>
<span class="line-removed">4525     ShouldNotReachHere();</span>
<span class="line-removed">4526     return -1;</span>
<span class="line-removed">4527   }</span>
<span class="line-removed">4528 }</span>
<span class="line-removed">4529 </span>
<span class="line-removed">4530 int Compile::ConstantTable::qsort_comparator(Constant* a, Constant* b) {</span>
<span class="line-removed">4531   // sort descending</span>
<span class="line-removed">4532   if (a-&gt;freq() &gt; b-&gt;freq())  return -1;</span>
<span class="line-removed">4533   if (a-&gt;freq() &lt; b-&gt;freq())  return  1;</span>
<span class="line-removed">4534   return 0;</span>
<span class="line-removed">4535 }</span>
<span class="line-removed">4536 </span>
<span class="line-removed">4537 void Compile::ConstantTable::calculate_offsets_and_size() {</span>
<span class="line-removed">4538   // First, sort the array by frequencies.</span>
<span class="line-removed">4539   _constants.sort(qsort_comparator);</span>
<span class="line-removed">4540 </span>
<span class="line-removed">4541 #ifdef ASSERT</span>
<span class="line-removed">4542   // Make sure all jump-table entries were sorted to the end of the</span>
<span class="line-removed">4543   // array (they have a negative frequency).</span>
<span class="line-removed">4544   bool found_void = false;</span>
<span class="line-removed">4545   for (int i = 0; i &lt; _constants.length(); i++) {</span>
<span class="line-removed">4546     Constant con = _constants.at(i);</span>
<span class="line-removed">4547     if (con.type() == T_VOID)</span>
<span class="line-removed">4548       found_void = true;  // jump-tables</span>
<span class="line-removed">4549     else</span>
<span class="line-removed">4550       assert(!found_void, &quot;wrong sorting&quot;);</span>
<span class="line-removed">4551   }</span>
<span class="line-removed">4552 #endif</span>
<span class="line-removed">4553 </span>
<span class="line-removed">4554   int offset = 0;</span>
<span class="line-removed">4555   for (int i = 0; i &lt; _constants.length(); i++) {</span>
<span class="line-removed">4556     Constant* con = _constants.adr_at(i);</span>
<span class="line-removed">4557 </span>
<span class="line-removed">4558     // Align offset for type.</span>
<span class="line-removed">4559     int typesize = type_to_size_in_bytes(con-&gt;type());</span>
<span class="line-removed">4560     offset = align_up(offset, typesize);</span>
<span class="line-removed">4561     con-&gt;set_offset(offset);   // set constant&#39;s offset</span>
<span class="line-removed">4562 </span>
<span class="line-removed">4563     if (con-&gt;type() == T_VOID) {</span>
<span class="line-removed">4564       MachConstantNode* n = (MachConstantNode*) con-&gt;get_jobject();</span>
<span class="line-removed">4565       offset = offset + typesize * n-&gt;outcnt();  // expand jump-table</span>
<span class="line-removed">4566     } else {</span>
<span class="line-removed">4567       offset = offset + typesize;</span>
<span class="line-removed">4568     }</span>
<span class="line-removed">4569   }</span>
<span class="line-removed">4570 </span>
<span class="line-removed">4571   // Align size up to the next section start (which is insts; see</span>
<span class="line-removed">4572   // CodeBuffer::align_at_start).</span>
<span class="line-removed">4573   assert(_size == -1, &quot;already set?&quot;);</span>
<span class="line-removed">4574   _size = align_up(offset, (int)CodeEntryAlignment);</span>
<span class="line-removed">4575 }</span>
<span class="line-removed">4576 </span>
<span class="line-removed">4577 void Compile::ConstantTable::emit(CodeBuffer&amp; cb) {</span>
<span class="line-removed">4578   MacroAssembler _masm(&amp;cb);</span>
<span class="line-removed">4579   for (int i = 0; i &lt; _constants.length(); i++) {</span>
<span class="line-removed">4580     Constant con = _constants.at(i);</span>
<span class="line-removed">4581     address constant_addr = NULL;</span>
<span class="line-removed">4582     switch (con.type()) {</span>
<span class="line-removed">4583     case T_INT:    constant_addr = _masm.int_constant(   con.get_jint()   ); break;</span>
<span class="line-removed">4584     case T_LONG:   constant_addr = _masm.long_constant(  con.get_jlong()  ); break;</span>
<span class="line-removed">4585     case T_FLOAT:  constant_addr = _masm.float_constant( con.get_jfloat() ); break;</span>
<span class="line-removed">4586     case T_DOUBLE: constant_addr = _masm.double_constant(con.get_jdouble()); break;</span>
<span class="line-removed">4587     case T_OBJECT: {</span>
<span class="line-removed">4588       jobject obj = con.get_jobject();</span>
<span class="line-removed">4589       int oop_index = _masm.oop_recorder()-&gt;find_index(obj);</span>
<span class="line-removed">4590       constant_addr = _masm.address_constant((address) obj, oop_Relocation::spec(oop_index));</span>
<span class="line-removed">4591       break;</span>
<span class="line-removed">4592     }</span>
<span class="line-removed">4593     case T_ADDRESS: {</span>
<span class="line-removed">4594       address addr = (address) con.get_jobject();</span>
<span class="line-removed">4595       constant_addr = _masm.address_constant(addr);</span>
<span class="line-removed">4596       break;</span>
<span class="line-removed">4597     }</span>
<span class="line-removed">4598     // We use T_VOID as marker for jump-table entries (labels) which</span>
<span class="line-removed">4599     // need an internal word relocation.</span>
<span class="line-removed">4600     case T_VOID: {</span>
<span class="line-removed">4601       MachConstantNode* n = (MachConstantNode*) con.get_jobject();</span>
<span class="line-removed">4602       // Fill the jump-table with a dummy word.  The real value is</span>
<span class="line-removed">4603       // filled in later in fill_jump_table.</span>
<span class="line-removed">4604       address dummy = (address) n;</span>
<span class="line-removed">4605       constant_addr = _masm.address_constant(dummy);</span>
<span class="line-removed">4606       // Expand jump-table</span>
<span class="line-removed">4607       for (uint i = 1; i &lt; n-&gt;outcnt(); i++) {</span>
<span class="line-removed">4608         address temp_addr = _masm.address_constant(dummy + i);</span>
<span class="line-removed">4609         assert(temp_addr, &quot;consts section too small&quot;);</span>
<span class="line-removed">4610       }</span>
<span class="line-removed">4611       break;</span>
<span class="line-removed">4612     }</span>
<span class="line-removed">4613     case T_METADATA: {</span>
<span class="line-removed">4614       Metadata* obj = con.get_metadata();</span>
<span class="line-removed">4615       int metadata_index = _masm.oop_recorder()-&gt;find_index(obj);</span>
<span class="line-removed">4616       constant_addr = _masm.address_constant((address) obj, metadata_Relocation::spec(metadata_index));</span>
<span class="line-removed">4617       break;</span>
<span class="line-removed">4618     }</span>
<span class="line-removed">4619     default: ShouldNotReachHere();</span>
<span class="line-removed">4620     }</span>
<span class="line-removed">4621     assert(constant_addr, &quot;consts section too small&quot;);</span>
<span class="line-removed">4622     assert((constant_addr - _masm.code()-&gt;consts()-&gt;start()) == con.offset(),</span>
<span class="line-removed">4623             &quot;must be: %d == %d&quot;, (int) (constant_addr - _masm.code()-&gt;consts()-&gt;start()), (int)(con.offset()));</span>
<span class="line-removed">4624   }</span>
<span class="line-removed">4625 }</span>
<span class="line-removed">4626 </span>
<span class="line-removed">4627 int Compile::ConstantTable::find_offset(Constant&amp; con) const {</span>
<span class="line-removed">4628   int idx = _constants.find(con);</span>
<span class="line-removed">4629   guarantee(idx != -1, &quot;constant must be in constant table&quot;);</span>
<span class="line-removed">4630   int offset = _constants.at(idx).offset();</span>
<span class="line-removed">4631   guarantee(offset != -1, &quot;constant table not emitted yet?&quot;);</span>
<span class="line-removed">4632   return offset;</span>
<span class="line-removed">4633 }</span>
<span class="line-removed">4634 </span>
<span class="line-removed">4635 void Compile::ConstantTable::add(Constant&amp; con) {</span>
<span class="line-removed">4636   if (con.can_be_reused()) {</span>
<span class="line-removed">4637     int idx = _constants.find(con);</span>
<span class="line-removed">4638     if (idx != -1 &amp;&amp; _constants.at(idx).can_be_reused()) {</span>
<span class="line-removed">4639       _constants.adr_at(idx)-&gt;inc_freq(con.freq());  // increase the frequency by the current value</span>
<span class="line-removed">4640       return;</span>
<span class="line-removed">4641     }</span>
<span class="line-removed">4642   }</span>
<span class="line-removed">4643   (void) _constants.append(con);</span>
<span class="line-removed">4644 }</span>
<span class="line-removed">4645 </span>
<span class="line-removed">4646 Compile::Constant Compile::ConstantTable::add(MachConstantNode* n, BasicType type, jvalue value) {</span>
<span class="line-removed">4647   Block* b = Compile::current()-&gt;cfg()-&gt;get_block_for_node(n);</span>
<span class="line-removed">4648   Constant con(type, value, b-&gt;_freq);</span>
<span class="line-removed">4649   add(con);</span>
<span class="line-removed">4650   return con;</span>
<span class="line-removed">4651 }</span>
<span class="line-removed">4652 </span>
<span class="line-removed">4653 Compile::Constant Compile::ConstantTable::add(Metadata* metadata) {</span>
<span class="line-removed">4654   Constant con(metadata);</span>
<span class="line-removed">4655   add(con);</span>
<span class="line-removed">4656   return con;</span>
<span class="line-removed">4657 }</span>
<span class="line-removed">4658 </span>
<span class="line-removed">4659 Compile::Constant Compile::ConstantTable::add(MachConstantNode* n, MachOper* oper) {</span>
<span class="line-removed">4660   jvalue value;</span>
<span class="line-removed">4661   BasicType type = oper-&gt;type()-&gt;basic_type();</span>
<span class="line-removed">4662   switch (type) {</span>
<span class="line-removed">4663   case T_LONG:    value.j = oper-&gt;constantL(); break;</span>
<span class="line-removed">4664   case T_FLOAT:   value.f = oper-&gt;constantF(); break;</span>
<span class="line-removed">4665   case T_DOUBLE:  value.d = oper-&gt;constantD(); break;</span>
<span class="line-removed">4666   case T_OBJECT:</span>
<span class="line-removed">4667   case T_ADDRESS: value.l = (jobject) oper-&gt;constant(); break;</span>
<span class="line-removed">4668   case T_METADATA: return add((Metadata*)oper-&gt;constant()); break;</span>
<span class="line-removed">4669   default: guarantee(false, &quot;unhandled type: %s&quot;, type2name(type));</span>
<span class="line-removed">4670   }</span>
<span class="line-removed">4671   return add(n, type, value);</span>
<span class="line-removed">4672 }</span>
<span class="line-removed">4673 </span>
<span class="line-removed">4674 Compile::Constant Compile::ConstantTable::add_jump_table(MachConstantNode* n) {</span>
<span class="line-removed">4675   jvalue value;</span>
<span class="line-removed">4676   // We can use the node pointer here to identify the right jump-table</span>
<span class="line-removed">4677   // as this method is called from Compile::Fill_buffer right before</span>
<span class="line-removed">4678   // the MachNodes are emitted and the jump-table is filled (means the</span>
<span class="line-removed">4679   // MachNode pointers do not change anymore).</span>
<span class="line-removed">4680   value.l = (jobject) n;</span>
<span class="line-removed">4681   Constant con(T_VOID, value, next_jump_table_freq(), false);  // Labels of a jump-table cannot be reused.</span>
<span class="line-removed">4682   add(con);</span>
<span class="line-removed">4683   return con;</span>
<span class="line-removed">4684 }</span>
<span class="line-removed">4685 </span>
<span class="line-removed">4686 void Compile::ConstantTable::fill_jump_table(CodeBuffer&amp; cb, MachConstantNode* n, GrowableArray&lt;Label*&gt; labels) const {</span>
<span class="line-removed">4687   // If called from Compile::scratch_emit_size do nothing.</span>
<span class="line-removed">4688   if (Compile::current()-&gt;in_scratch_emit_size())  return;</span>
<span class="line-removed">4689 </span>
<span class="line-removed">4690   assert(labels.is_nonempty(), &quot;must be&quot;);</span>
<span class="line-removed">4691   assert((uint) labels.length() == n-&gt;outcnt(), &quot;must be equal: %d == %d&quot;, labels.length(), n-&gt;outcnt());</span>
<span class="line-removed">4692 </span>
<span class="line-removed">4693   // Since MachConstantNode::constant_offset() also contains</span>
<span class="line-removed">4694   // table_base_offset() we need to subtract the table_base_offset()</span>
<span class="line-removed">4695   // to get the plain offset into the constant table.</span>
<span class="line-removed">4696   int offset = n-&gt;constant_offset() - table_base_offset();</span>
<span class="line-removed">4697 </span>
<span class="line-removed">4698   MacroAssembler _masm(&amp;cb);</span>
<span class="line-removed">4699   address* jump_table_base = (address*) (_masm.code()-&gt;consts()-&gt;start() + offset);</span>
<span class="line-removed">4700 </span>
<span class="line-removed">4701   for (uint i = 0; i &lt; n-&gt;outcnt(); i++) {</span>
<span class="line-removed">4702     address* constant_addr = &amp;jump_table_base[i];</span>
<span class="line-removed">4703     assert(*constant_addr == (((address) n) + i), &quot;all jump-table entries must contain adjusted node pointer: &quot; INTPTR_FORMAT &quot; == &quot; INTPTR_FORMAT, p2i(*constant_addr), p2i(((address) n) + i));</span>
<span class="line-removed">4704     *constant_addr = cb.consts()-&gt;target(*labels.at(i), (address) constant_addr);</span>
<span class="line-removed">4705     cb.consts()-&gt;relocate((address) constant_addr, relocInfo::internal_word_type);</span>
<span class="line-removed">4706   }</span>
<span class="line-removed">4707 }</span>
<span class="line-removed">4708 </span>
4709 //----------------------------static_subtype_check-----------------------------
4710 // Shortcut important common cases when superklass is exact:
4711 // (0) superklass is java.lang.Object (can occur in reflective code)
4712 // (1) subklass is already limited to a subtype of superklass =&gt; always ok
4713 // (2) subklass does not overlap with superklass =&gt; always fail
4714 // (3) superklass has NO subtypes and we can check with a simple compare.
4715 int Compile::static_subtype_check(ciKlass* superk, ciKlass* subk) {
4716   if (StressReflectiveCode || superk == NULL || subk == NULL) {
4717     return SSC_full_test;       // Let caller generate the general case.
4718   }
4719 
4720   if (superk == env()-&gt;Object_klass()) {
4721     return SSC_always_true;     // (0) this test cannot fail
4722   }
4723 
4724   ciType* superelem = superk;
4725   if (superelem-&gt;is_array_klass()) {
4726     ciArrayKlass* ak = superelem-&gt;as_array_klass();
4727     superelem = superelem-&gt;as_array_klass()-&gt;base_element_type();
4728   }
4729 
4730   if (!subk-&gt;is_interface()) {  // cannot trust static interface types yet
4731     if (subk-&gt;is_subtype_of(superk)) {
4732       return SSC_always_true;   // (1) false path dead; no dynamic test needed
4733     }
4734     if (!(superelem-&gt;is_klass() &amp;&amp; superelem-&gt;as_klass()-&gt;is_interface()) &amp;&amp;
4735         !superk-&gt;is_subtype_of(subk)) {
4736       return SSC_always_false;
4737     }
4738   }
4739 
4740   // Do not fold the subtype check to an array klass pointer comparison for [V? arrays.
4741   // [V is a subtype of [V? but the klass for [V is not equal to the klass for [V?. Perform a full test.
4742   if (superk-&gt;is_obj_array_klass() &amp;&amp; !superk-&gt;as_array_klass()-&gt;storage_properties().is_null_free() &amp;&amp; superk-&gt;as_array_klass()-&gt;element_klass()-&gt;is_valuetype()) {
4743     return SSC_full_test;
4744   }
4745   // If casting to an instance klass, it must have no subtypes
4746   if (superk-&gt;is_interface()) {
4747     // Cannot trust interfaces yet.
4748     // %%% S.B. superk-&gt;nof_implementors() == 1
4749   } else if (superelem-&gt;is_instance_klass()) {
4750     ciInstanceKlass* ik = superelem-&gt;as_instance_klass();
4751     if (!ik-&gt;has_subklass() &amp;&amp; !ik-&gt;is_interface()) {
4752       if (!ik-&gt;is_final()) {
4753         // Add a dependency if there is a chance of a later subclass.
4754         dependencies()-&gt;assert_leaf_type(ik);
4755       }
<a name="25" id="anc25"></a><span class="line-removed">4756       if (ik-&gt;is_abstract()) {</span>
<span class="line-removed">4757         return SSC_always_false;</span>
<span class="line-removed">4758       }</span>
4759       return SSC_easy_test;     // (3) caller can do a simple ptr comparison
4760     }
4761   } else {
4762     // A primitive array type has no subtypes.
4763     return SSC_easy_test;       // (3) caller can do a simple ptr comparison
4764   }
4765 
4766   return SSC_full_test;
4767 }
4768 
4769 Node* Compile::conv_I2X_index(PhaseGVN* phase, Node* idx, const TypeInt* sizetype, Node* ctrl) {
4770 #ifdef _LP64
4771   // The scaled index operand to AddP must be a clean 64-bit value.
4772   // Java allows a 32-bit int to be incremented to a negative
4773   // value, which appears in a 64-bit register as a large
4774   // positive number.  Using that large positive number as an
4775   // operand in pointer arithmetic has bad consequences.
4776   // On the other hand, 32-bit overflow is rare, and the possibility
4777   // can often be excluded, if we annotate the ConvI2L node with
4778   // a type assertion that its value is known to be a small positive
4779   // number.  (The prior range check has ensured this.)
4780   // This assertion is used by ConvI2LNode::Ideal.
4781   int index_max = max_jint - 1;  // array size is max_jint, index is one less
4782   if (sizetype != NULL) index_max = sizetype-&gt;_hi - 1;
4783   const TypeInt* iidxtype = TypeInt::make(0, index_max, Type::WidenMax);
4784   idx = constrained_convI2L(phase, idx, iidxtype, ctrl);
4785 #endif
4786   return idx;
4787 }
4788 
4789 // Convert integer value to a narrowed long type dependent on ctrl (for example, a range check)
4790 Node* Compile::constrained_convI2L(PhaseGVN* phase, Node* value, const TypeInt* itype, Node* ctrl) {
4791   if (ctrl != NULL) {
4792     // Express control dependency by a CastII node with a narrow type.
4793     value = new CastIINode(value, itype, false, true /* range check dependency */);
4794     // Make the CastII node dependent on the control input to prevent the narrowed ConvI2L
4795     // node from floating above the range check during loop optimizations. Otherwise, the
4796     // ConvI2L node may be eliminated independently of the range check, causing the data path
4797     // to become TOP while the control path is still there (although it&#39;s unreachable).
4798     value-&gt;set_req(0, ctrl);
4799     // Save CastII node to remove it after loop optimizations.
4800     phase-&gt;C-&gt;add_range_check_cast(value);
4801     value = phase-&gt;transform(value);
4802   }
4803   const TypeLong* ltype = TypeLong::make(itype-&gt;_lo, itype-&gt;_hi, itype-&gt;_widen);
4804   return phase-&gt;transform(new ConvI2LNode(value, ltype));
4805 }
4806 
4807 void Compile::print_inlining_stream_free() {
4808   if (_print_inlining_stream != NULL) {
4809     _print_inlining_stream-&gt;~stringStream();
4810     _print_inlining_stream = NULL;
4811   }
4812 }
4813 
4814 // The message about the current inlining is accumulated in
4815 // _print_inlining_stream and transfered into the _print_inlining_list
4816 // once we know whether inlining succeeds or not. For regular
4817 // inlining, messages are appended to the buffer pointed by
4818 // _print_inlining_idx in the _print_inlining_list. For late inlining,
4819 // a new buffer is added after _print_inlining_idx in the list. This
4820 // way we can update the inlining message for late inlining call site
4821 // when the inlining is attempted again.
4822 void Compile::print_inlining_init() {
4823   if (print_inlining() || print_intrinsics()) {
4824     // print_inlining_init is actually called several times.
4825     print_inlining_stream_free();
4826     _print_inlining_stream = new stringStream();
4827     // Watch out: The memory initialized by the constructor call PrintInliningBuffer()
4828     // will be copied into the only initial element. The default destructor of
4829     // PrintInliningBuffer will be called when leaving the scope here. If it
4830     // would destuct the  enclosed stringStream _print_inlining_list[0]-&gt;_ss
4831     // would be destructed, too!
4832     _print_inlining_list = new (comp_arena())GrowableArray&lt;PrintInliningBuffer&gt;(comp_arena(), 1, 1, PrintInliningBuffer());
4833   }
4834 }
4835 
4836 void Compile::print_inlining_reinit() {
4837   if (print_inlining() || print_intrinsics()) {
4838     print_inlining_stream_free();
4839     // Re allocate buffer when we change ResourceMark
4840     _print_inlining_stream = new stringStream();
4841   }
4842 }
4843 
4844 void Compile::print_inlining_reset() {
4845   _print_inlining_stream-&gt;reset();
4846 }
4847 
4848 void Compile::print_inlining_commit() {
4849   assert(print_inlining() || print_intrinsics(), &quot;PrintInlining off?&quot;);
4850   // Transfer the message from _print_inlining_stream to the current
4851   // _print_inlining_list buffer and clear _print_inlining_stream.
4852   _print_inlining_list-&gt;at(_print_inlining_idx).ss()-&gt;write(_print_inlining_stream-&gt;base(), _print_inlining_stream-&gt;size());
4853   print_inlining_reset();
4854 }
4855 
4856 void Compile::print_inlining_push() {
4857   // Add new buffer to the _print_inlining_list at current position
4858   _print_inlining_idx++;
4859   _print_inlining_list-&gt;insert_before(_print_inlining_idx, PrintInliningBuffer());
4860 }
4861 
4862 Compile::PrintInliningBuffer&amp; Compile::print_inlining_current() {
4863   return _print_inlining_list-&gt;at(_print_inlining_idx);
4864 }
4865 
4866 void Compile::print_inlining_update(CallGenerator* cg) {
4867   if (print_inlining() || print_intrinsics()) {
4868     if (!cg-&gt;is_late_inline()) {
4869       if (print_inlining_current().cg() != NULL) {
4870         print_inlining_push();
4871       }
4872       print_inlining_commit();
4873     } else {
4874       if (print_inlining_current().cg() != cg &amp;&amp;
4875           (print_inlining_current().cg() != NULL ||
4876            print_inlining_current().ss()-&gt;size() != 0)) {
4877         print_inlining_push();
4878       }
4879       print_inlining_commit();
4880       print_inlining_current().set_cg(cg);
4881     }
4882   }
4883 }
4884 
4885 void Compile::print_inlining_move_to(CallGenerator* cg) {
4886   // We resume inlining at a late inlining call site. Locate the
4887   // corresponding inlining buffer so that we can update it.
4888   if (print_inlining()) {
4889     for (int i = 0; i &lt; _print_inlining_list-&gt;length(); i++) {
4890       if (_print_inlining_list-&gt;adr_at(i)-&gt;cg() == cg) {
4891         _print_inlining_idx = i;
4892         return;
4893       }
4894     }
4895     ShouldNotReachHere();
4896   }
4897 }
4898 
4899 void Compile::print_inlining_update_delayed(CallGenerator* cg) {
4900   if (print_inlining()) {
4901     assert(_print_inlining_stream-&gt;size() &gt; 0, &quot;missing inlining msg&quot;);
4902     assert(print_inlining_current().cg() == cg, &quot;wrong entry&quot;);
4903     // replace message with new message
4904     _print_inlining_list-&gt;at_put(_print_inlining_idx, PrintInliningBuffer());
4905     print_inlining_commit();
4906     print_inlining_current().set_cg(cg);
4907   }
4908 }
4909 
4910 void Compile::print_inlining_assert_ready() {
4911   assert(!_print_inlining || _print_inlining_stream-&gt;size() == 0, &quot;loosing data&quot;);
4912 }
4913 
4914 void Compile::process_print_inlining() {
4915   bool do_print_inlining = print_inlining() || print_intrinsics();
4916   if (do_print_inlining || log() != NULL) {
4917     // Print inlining message for candidates that we couldn&#39;t inline
4918     // for lack of space
4919     for (int i = 0; i &lt; _late_inlines.length(); i++) {
4920       CallGenerator* cg = _late_inlines.at(i);
4921       if (!cg-&gt;is_mh_late_inline()) {
4922         const char* msg = &quot;live nodes &gt; LiveNodeCountInliningCutoff&quot;;
4923         if (do_print_inlining) {
4924           cg-&gt;print_inlining_late(msg);
4925         }
4926         log_late_inline_failure(cg, msg);
4927       }
4928     }
4929   }
4930   if (do_print_inlining) {
4931     ResourceMark rm;
4932     stringStream ss;
4933     assert(_print_inlining_list != NULL, &quot;process_print_inlining should be called only once.&quot;);
4934     for (int i = 0; i &lt; _print_inlining_list-&gt;length(); i++) {
4935       ss.print(&quot;%s&quot;, _print_inlining_list-&gt;adr_at(i)-&gt;ss()-&gt;as_string());
4936       _print_inlining_list-&gt;at(i).freeStream();
4937     }
4938     // Reset _print_inlining_list, it only contains destructed objects.
4939     // It is on the arena, so it will be freed when the arena is reset.
4940     _print_inlining_list = NULL;
4941     // _print_inlining_stream won&#39;t be used anymore, either.
4942     print_inlining_stream_free();
4943     size_t end = ss.size();
4944     _print_inlining_output = NEW_ARENA_ARRAY(comp_arena(), char, end+1);
4945     strncpy(_print_inlining_output, ss.base(), end+1);
4946     _print_inlining_output[end] = 0;
4947   }
4948 }
4949 
4950 void Compile::dump_print_inlining() {
4951   if (_print_inlining_output != NULL) {
4952     tty-&gt;print_raw(_print_inlining_output);
4953   }
4954 }
4955 
4956 void Compile::log_late_inline(CallGenerator* cg) {
4957   if (log() != NULL) {
4958     log()-&gt;head(&quot;late_inline method=&#39;%d&#39;  inline_id=&#39;&quot; JLONG_FORMAT &quot;&#39;&quot;, log()-&gt;identify(cg-&gt;method()),
4959                 cg-&gt;unique_id());
4960     JVMState* p = cg-&gt;call_node()-&gt;jvms();
4961     while (p != NULL) {
4962       log()-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log()-&gt;identify(p-&gt;method()));
4963       p = p-&gt;caller();
4964     }
4965     log()-&gt;tail(&quot;late_inline&quot;);
4966   }
4967 }
4968 
4969 void Compile::log_late_inline_failure(CallGenerator* cg, const char* msg) {
4970   log_late_inline(cg);
4971   if (log() != NULL) {
4972     log()-&gt;inline_fail(msg);
4973   }
4974 }
4975 
4976 void Compile::log_inline_id(CallGenerator* cg) {
4977   if (log() != NULL) {
4978     // The LogCompilation tool needs a unique way to identify late
4979     // inline call sites. This id must be unique for this call site in
4980     // this compilation. Try to have it unique across compilations as
4981     // well because it can be convenient when grepping through the log
4982     // file.
4983     // Distinguish OSR compilations from others in case CICountOSR is
4984     // on.
4985     jlong id = ((jlong)unique()) + (((jlong)compile_id()) &lt;&lt; 33) + (CICountOSR &amp;&amp; is_osr_compilation() ? ((jlong)1) &lt;&lt; 32 : 0);
4986     cg-&gt;set_unique_id(id);
4987     log()-&gt;elem(&quot;inline_id id=&#39;&quot; JLONG_FORMAT &quot;&#39;&quot;, id);
4988   }
4989 }
4990 
4991 void Compile::log_inline_failure(const char* msg) {
4992   if (C-&gt;log() != NULL) {
4993     C-&gt;log()-&gt;inline_fail(msg);
4994   }
4995 }
4996 
4997 
4998 // Dump inlining replay data to the stream.
4999 // Don&#39;t change thread state and acquire any locks.
5000 void Compile::dump_inline_data(outputStream* out) {
5001   InlineTree* inl_tree = ilt();
5002   if (inl_tree != NULL) {
5003     out-&gt;print(&quot; inline %d&quot;, inl_tree-&gt;count());
5004     inl_tree-&gt;dump_replay_data(out);
5005   }
5006 }
5007 
5008 int Compile::cmp_expensive_nodes(Node* n1, Node* n2) {
5009   if (n1-&gt;Opcode() &lt; n2-&gt;Opcode())      return -1;
5010   else if (n1-&gt;Opcode() &gt; n2-&gt;Opcode()) return 1;
5011 
5012   assert(n1-&gt;req() == n2-&gt;req(), &quot;can&#39;t compare %s nodes: n1-&gt;req() = %d, n2-&gt;req() = %d&quot;, NodeClassNames[n1-&gt;Opcode()], n1-&gt;req(), n2-&gt;req());
5013   for (uint i = 1; i &lt; n1-&gt;req(); i++) {
5014     if (n1-&gt;in(i) &lt; n2-&gt;in(i))      return -1;
5015     else if (n1-&gt;in(i) &gt; n2-&gt;in(i)) return 1;
5016   }
5017 
5018   return 0;
5019 }
5020 
5021 int Compile::cmp_expensive_nodes(Node** n1p, Node** n2p) {
5022   Node* n1 = *n1p;
5023   Node* n2 = *n2p;
5024 
5025   return cmp_expensive_nodes(n1, n2);
5026 }
5027 
5028 void Compile::sort_expensive_nodes() {
5029   if (!expensive_nodes_sorted()) {
5030     _expensive_nodes-&gt;sort(cmp_expensive_nodes);
5031   }
5032 }
5033 
5034 bool Compile::expensive_nodes_sorted() const {
5035   for (int i = 1; i &lt; _expensive_nodes-&gt;length(); i++) {
5036     if (cmp_expensive_nodes(_expensive_nodes-&gt;adr_at(i), _expensive_nodes-&gt;adr_at(i-1)) &lt; 0) {
5037       return false;
5038     }
5039   }
5040   return true;
5041 }
5042 
5043 bool Compile::should_optimize_expensive_nodes(PhaseIterGVN &amp;igvn) {
5044   if (_expensive_nodes-&gt;length() == 0) {
5045     return false;
5046   }
5047 
5048   assert(OptimizeExpensiveOps, &quot;optimization off?&quot;);
5049 
5050   // Take this opportunity to remove dead nodes from the list
5051   int j = 0;
5052   for (int i = 0; i &lt; _expensive_nodes-&gt;length(); i++) {
5053     Node* n = _expensive_nodes-&gt;at(i);
5054     if (!n-&gt;is_unreachable(igvn)) {
5055       assert(n-&gt;is_expensive(), &quot;should be expensive&quot;);
5056       _expensive_nodes-&gt;at_put(j, n);
5057       j++;
5058     }
5059   }
5060   _expensive_nodes-&gt;trunc_to(j);
5061 
5062   // Then sort the list so that similar nodes are next to each other
5063   // and check for at least two nodes of identical kind with same data
5064   // inputs.
5065   sort_expensive_nodes();
5066 
5067   for (int i = 0; i &lt; _expensive_nodes-&gt;length()-1; i++) {
5068     if (cmp_expensive_nodes(_expensive_nodes-&gt;adr_at(i), _expensive_nodes-&gt;adr_at(i+1)) == 0) {
5069       return true;
5070     }
5071   }
5072 
5073   return false;
5074 }
5075 
5076 void Compile::cleanup_expensive_nodes(PhaseIterGVN &amp;igvn) {
5077   if (_expensive_nodes-&gt;length() == 0) {
5078     return;
5079   }
5080 
5081   assert(OptimizeExpensiveOps, &quot;optimization off?&quot;);
5082 
5083   // Sort to bring similar nodes next to each other and clear the
5084   // control input of nodes for which there&#39;s only a single copy.
5085   sort_expensive_nodes();
5086 
5087   int j = 0;
5088   int identical = 0;
5089   int i = 0;
5090   bool modified = false;
5091   for (; i &lt; _expensive_nodes-&gt;length()-1; i++) {
5092     assert(j &lt;= i, &quot;can&#39;t write beyond current index&quot;);
5093     if (_expensive_nodes-&gt;at(i)-&gt;Opcode() == _expensive_nodes-&gt;at(i+1)-&gt;Opcode()) {
5094       identical++;
5095       _expensive_nodes-&gt;at_put(j++, _expensive_nodes-&gt;at(i));
5096       continue;
5097     }
5098     if (identical &gt; 0) {
5099       _expensive_nodes-&gt;at_put(j++, _expensive_nodes-&gt;at(i));
5100       identical = 0;
5101     } else {
5102       Node* n = _expensive_nodes-&gt;at(i);
5103       igvn.replace_input_of(n, 0, NULL);
5104       igvn.hash_insert(n);
5105       modified = true;
5106     }
5107   }
5108   if (identical &gt; 0) {
5109     _expensive_nodes-&gt;at_put(j++, _expensive_nodes-&gt;at(i));
5110   } else if (_expensive_nodes-&gt;length() &gt;= 1) {
5111     Node* n = _expensive_nodes-&gt;at(i);
5112     igvn.replace_input_of(n, 0, NULL);
5113     igvn.hash_insert(n);
5114     modified = true;
5115   }
5116   _expensive_nodes-&gt;trunc_to(j);
5117   if (modified) {
5118     igvn.optimize();
5119   }
5120 }
5121 
5122 void Compile::add_expensive_node(Node * n) {
5123   assert(!_expensive_nodes-&gt;contains(n), &quot;duplicate entry in expensive list&quot;);
5124   assert(n-&gt;is_expensive(), &quot;expensive nodes with non-null control here only&quot;);
5125   assert(!n-&gt;is_CFG() &amp;&amp; !n-&gt;is_Mem(), &quot;no cfg or memory nodes here&quot;);
5126   if (OptimizeExpensiveOps) {
5127     _expensive_nodes-&gt;append(n);
5128   } else {
5129     // Clear control input and let IGVN optimize expensive nodes if
5130     // OptimizeExpensiveOps is off.
5131     n-&gt;set_req(0, NULL);
5132   }
5133 }
5134 
5135 /**
5136  * Remove the speculative part of types and clean up the graph
5137  */
5138 void Compile::remove_speculative_types(PhaseIterGVN &amp;igvn) {
5139   if (UseTypeSpeculation) {
5140     Unique_Node_List worklist;
5141     worklist.push(root());
5142     int modified = 0;
5143     // Go over all type nodes that carry a speculative type, drop the
5144     // speculative part of the type and enqueue the node for an igvn
5145     // which may optimize it out.
5146     for (uint next = 0; next &lt; worklist.size(); ++next) {
5147       Node *n  = worklist.at(next);
5148       if (n-&gt;is_Type()) {
5149         TypeNode* tn = n-&gt;as_Type();
5150         const Type* t = tn-&gt;type();
5151         const Type* t_no_spec = t-&gt;remove_speculative();
5152         if (t_no_spec != t) {
5153           bool in_hash = igvn.hash_delete(n);
5154           assert(in_hash, &quot;node should be in igvn hash table&quot;);
5155           tn-&gt;set_type(t_no_spec);
5156           igvn.hash_insert(n);
5157           igvn._worklist.push(n); // give it a chance to go away
5158           modified++;
5159         }
5160       }
5161       uint max = n-&gt;len();
5162       for( uint i = 0; i &lt; max; ++i ) {
5163         Node *m = n-&gt;in(i);
5164         if (not_a_node(m))  continue;
5165         worklist.push(m);
5166       }
5167     }
5168     // Drop the speculative part of all types in the igvn&#39;s type table
5169     igvn.remove_speculative_types();
5170     if (modified &gt; 0) {
5171       igvn.optimize();
5172     }
5173 #ifdef ASSERT
5174     // Verify that after the IGVN is over no speculative type has resurfaced
5175     worklist.clear();
5176     worklist.push(root());
5177     for (uint next = 0; next &lt; worklist.size(); ++next) {
5178       Node *n  = worklist.at(next);
5179       const Type* t = igvn.type_or_null(n);
5180       assert((t == NULL) || (t == t-&gt;remove_speculative()), &quot;no more speculative types&quot;);
5181       if (n-&gt;is_Type()) {
5182         t = n-&gt;as_Type()-&gt;type();
5183         assert(t == t-&gt;remove_speculative(), &quot;no more speculative types&quot;);
5184       }
5185       uint max = n-&gt;len();
5186       for( uint i = 0; i &lt; max; ++i ) {
5187         Node *m = n-&gt;in(i);
5188         if (not_a_node(m))  continue;
5189         worklist.push(m);
5190       }
5191     }
5192     igvn.check_no_speculative_types();
5193 #endif
5194   }
5195 }
5196 
5197 Node* Compile::optimize_acmp(PhaseGVN* phase, Node* a, Node* b) {
5198   const TypeInstPtr* ta = phase-&gt;type(a)-&gt;isa_instptr();
5199   const TypeInstPtr* tb = phase-&gt;type(b)-&gt;isa_instptr();
5200   if (!EnableValhalla || ta == NULL || tb == NULL ||
5201       ta-&gt;is_zero_type() || tb-&gt;is_zero_type() ||
5202       !ta-&gt;can_be_value_type() || !tb-&gt;can_be_value_type()) {
5203     // Use old acmp if one operand is null or not a value type
5204     return new CmpPNode(a, b);
5205   } else if (ta-&gt;is_valuetypeptr() || tb-&gt;is_valuetypeptr()) {
5206     // We know that one operand is a value type. Therefore,
5207     // new acmp will only return true if both operands are NULL.
5208     // Check if both operands are null by or&#39;ing the oops.
5209     a = phase-&gt;transform(new CastP2XNode(NULL, a));
5210     b = phase-&gt;transform(new CastP2XNode(NULL, b));
5211     a = phase-&gt;transform(new OrXNode(a, b));
5212     return new CmpXNode(a, phase-&gt;MakeConX(0));
5213   }
5214   // Use new acmp
5215   return NULL;
5216 }
5217 
5218 // Auxiliary method to support randomized stressing/fuzzing.
5219 //
5220 // This method can be called the arbitrary number of times, with current count
5221 // as the argument. The logic allows selecting a single candidate from the
5222 // running list of candidates as follows:
5223 //    int count = 0;
5224 //    Cand* selected = null;
5225 //    while(cand = cand-&gt;next()) {
5226 //      if (randomized_select(++count)) {
5227 //        selected = cand;
5228 //      }
5229 //    }
5230 //
5231 // Including count equalizes the chances any candidate is &quot;selected&quot;.
5232 // This is useful when we don&#39;t have the complete list of candidates to choose
5233 // from uniformly. In this case, we need to adjust the randomicity of the
5234 // selection, or else we will end up biasing the selection towards the latter
5235 // candidates.
5236 //
5237 // Quick back-envelope calculation shows that for the list of n candidates
5238 // the equal probability for the candidate to persist as &quot;best&quot; can be
5239 // achieved by replacing it with &quot;next&quot; k-th candidate with the probability
5240 // of 1/k. It can be easily shown that by the end of the run, the
5241 // probability for any candidate is converged to 1/n, thus giving the
5242 // uniform distribution among all the candidates.
5243 //
5244 // We don&#39;t care about the domain size as long as (RANDOMIZED_DOMAIN / count) is large.
5245 #define RANDOMIZED_DOMAIN_POW 29
5246 #define RANDOMIZED_DOMAIN (1 &lt;&lt; RANDOMIZED_DOMAIN_POW)
5247 #define RANDOMIZED_DOMAIN_MASK ((1 &lt;&lt; (RANDOMIZED_DOMAIN_POW + 1)) - 1)
5248 bool Compile::randomized_select(int count) {
5249   assert(count &gt; 0, &quot;only positive&quot;);
5250   return (os::random() &amp; RANDOMIZED_DOMAIN_MASK) &lt; (RANDOMIZED_DOMAIN / count);
5251 }
5252 
5253 CloneMap&amp;     Compile::clone_map()                 { return _clone_map; }
5254 void          Compile::set_clone_map(Dict* d)      { _clone_map._dict = d; }
5255 
5256 void NodeCloneInfo::dump() const {
5257   tty-&gt;print(&quot; {%d:%d} &quot;, idx(), gen());
5258 }
5259 
5260 void CloneMap::clone(Node* old, Node* nnn, int gen) {
5261   uint64_t val = value(old-&gt;_idx);
5262   NodeCloneInfo cio(val);
5263   assert(val != 0, &quot;old node should be in the map&quot;);
5264   NodeCloneInfo cin(cio.idx(), gen + cio.gen());
5265   insert(nnn-&gt;_idx, cin.get());
5266 #ifndef PRODUCT
5267   if (is_debug()) {
5268     tty-&gt;print_cr(&quot;CloneMap::clone inserted node %d info {%d:%d} into CloneMap&quot;, nnn-&gt;_idx, cin.idx(), cin.gen());
5269   }
5270 #endif
5271 }
5272 
5273 void CloneMap::verify_insert_and_clone(Node* old, Node* nnn, int gen) {
5274   NodeCloneInfo cio(value(old-&gt;_idx));
5275   if (cio.get() == 0) {
5276     cio.set(old-&gt;_idx, 0);
5277     insert(old-&gt;_idx, cio.get());
5278 #ifndef PRODUCT
5279     if (is_debug()) {
5280       tty-&gt;print_cr(&quot;CloneMap::verify_insert_and_clone inserted node %d info {%d:%d} into CloneMap&quot;, old-&gt;_idx, cio.idx(), cio.gen());
5281     }
5282 #endif
5283   }
5284   clone(old, nnn, gen);
5285 }
5286 
5287 int CloneMap::max_gen() const {
5288   int g = 0;
5289   DictI di(_dict);
5290   for(; di.test(); ++di) {
5291     int t = gen(di._key);
5292     if (g &lt; t) {
5293       g = t;
5294 #ifndef PRODUCT
5295       if (is_debug()) {
5296         tty-&gt;print_cr(&quot;CloneMap::max_gen() update max=%d from %d&quot;, g, _2_node_idx_t(di._key));
5297       }
5298 #endif
5299     }
5300   }
5301   return g;
5302 }
5303 
5304 void CloneMap::dump(node_idx_t key) const {
5305   uint64_t val = value(key);
5306   if (val != 0) {
5307     NodeCloneInfo ni(val);
5308     ni.dump();
5309   }
5310 }
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/vectornode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="type.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vectornode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/vectornode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
656     case Op_MulD:
657       assert(bt == T_DOUBLE, &quot;must be&quot;);
658       vopc = Op_MulReductionVD;
659       break;
660     case Op_MinF:
661       assert(bt == T_FLOAT, &quot;must be&quot;);
662       vopc = Op_MinReductionV;
663       break;
664     case Op_MinD:
665       assert(bt == T_DOUBLE, &quot;must be&quot;);
666       vopc = Op_MinReductionV;
667       break;
668     case Op_MaxF:
669       assert(bt == T_FLOAT, &quot;must be&quot;);
670       vopc = Op_MaxReductionV;
671       break;
672     case Op_MaxD:
673       assert(bt == T_DOUBLE, &quot;must be&quot;);
674       vopc = Op_MaxReductionV;
675       break;
<span class="line-modified">676     // TODO: add MulL for targets that support it</span>























677     default:
678       break;
679   }
680   return vopc;
681 }
682 
683 // Return the appropriate reduction node.
684 ReductionNode* ReductionNode::make(int opc, Node *ctrl, Node* n1, Node* n2, BasicType bt) {
685 
686   int vopc = opcode(opc, bt);
687 
688   // This method should not be called for unimplemented vectors.
689   guarantee(vopc != opc, &quot;Vector for &#39;%s&#39; is not implemented&quot;, NodeClassNames[opc]);
690 
691   switch (vopc) {
692   case Op_AddReductionVI: return new AddReductionVINode(ctrl, n1, n2);
693   case Op_AddReductionVL: return new AddReductionVLNode(ctrl, n1, n2);
694   case Op_AddReductionVF: return new AddReductionVFNode(ctrl, n1, n2);
695   case Op_AddReductionVD: return new AddReductionVDNode(ctrl, n1, n2);
696   case Op_MulReductionVI: return new MulReductionVINode(ctrl, n1, n2);
697   case Op_MulReductionVL: return new MulReductionVLNode(ctrl, n1, n2);
698   case Op_MulReductionVF: return new MulReductionVFNode(ctrl, n1, n2);
699   case Op_MulReductionVD: return new MulReductionVDNode(ctrl, n1, n2);
<span class="line-modified">700   case Op_MinReductionV: return new MinReductionVNode(ctrl, n1, n2);</span>
<span class="line-modified">701   case Op_MaxReductionV: return new MaxReductionVNode(ctrl, n1, n2);</span>



702   default:
703     fatal(&quot;Missed vector creation for &#39;%s&#39;&quot;, NodeClassNames[vopc]);
704     return NULL;
705   }
706 }
707 
708 bool ReductionNode::implemented(int opc, uint vlen, BasicType bt) {
709   if (is_java_primitive(bt) &amp;&amp;
710       (vlen &gt; 1) &amp;&amp; is_power_of_2(vlen) &amp;&amp;
711       Matcher::vector_size_supported(bt, vlen)) {
712     int vopc = ReductionNode::opcode(opc, bt);
713     return vopc != opc &amp;&amp; Matcher::match_rule_supported(vopc);
714   }
715   return false;
716 }
</pre>
</td>
<td>
<hr />
<pre>
656     case Op_MulD:
657       assert(bt == T_DOUBLE, &quot;must be&quot;);
658       vopc = Op_MulReductionVD;
659       break;
660     case Op_MinF:
661       assert(bt == T_FLOAT, &quot;must be&quot;);
662       vopc = Op_MinReductionV;
663       break;
664     case Op_MinD:
665       assert(bt == T_DOUBLE, &quot;must be&quot;);
666       vopc = Op_MinReductionV;
667       break;
668     case Op_MaxF:
669       assert(bt == T_FLOAT, &quot;must be&quot;);
670       vopc = Op_MaxReductionV;
671       break;
672     case Op_MaxD:
673       assert(bt == T_DOUBLE, &quot;must be&quot;);
674       vopc = Op_MaxReductionV;
675       break;
<span class="line-modified">676     case Op_AndI:</span>
<span class="line-added">677       assert(bt == T_INT, &quot;must be&quot;);</span>
<span class="line-added">678       vopc = Op_AndReductionV;</span>
<span class="line-added">679       break;</span>
<span class="line-added">680     case Op_AndL:</span>
<span class="line-added">681       assert(bt == T_LONG, &quot;must be&quot;);</span>
<span class="line-added">682       vopc = Op_AndReductionV;</span>
<span class="line-added">683       break;</span>
<span class="line-added">684     case Op_OrI:</span>
<span class="line-added">685       assert(bt == T_INT, &quot;must be&quot;);</span>
<span class="line-added">686       vopc = Op_OrReductionV;</span>
<span class="line-added">687       break;</span>
<span class="line-added">688     case Op_OrL:</span>
<span class="line-added">689       assert(bt == T_LONG, &quot;must be&quot;);</span>
<span class="line-added">690       vopc = Op_OrReductionV;</span>
<span class="line-added">691       break;</span>
<span class="line-added">692     case Op_XorI:</span>
<span class="line-added">693       assert(bt == T_INT, &quot;must be&quot;);</span>
<span class="line-added">694       vopc = Op_XorReductionV;</span>
<span class="line-added">695       break;</span>
<span class="line-added">696     case Op_XorL:</span>
<span class="line-added">697       assert(bt == T_LONG, &quot;must be&quot;);</span>
<span class="line-added">698       vopc = Op_XorReductionV;</span>
<span class="line-added">699       break;</span>
700     default:
701       break;
702   }
703   return vopc;
704 }
705 
706 // Return the appropriate reduction node.
707 ReductionNode* ReductionNode::make(int opc, Node *ctrl, Node* n1, Node* n2, BasicType bt) {
708 
709   int vopc = opcode(opc, bt);
710 
711   // This method should not be called for unimplemented vectors.
712   guarantee(vopc != opc, &quot;Vector for &#39;%s&#39; is not implemented&quot;, NodeClassNames[opc]);
713 
714   switch (vopc) {
715   case Op_AddReductionVI: return new AddReductionVINode(ctrl, n1, n2);
716   case Op_AddReductionVL: return new AddReductionVLNode(ctrl, n1, n2);
717   case Op_AddReductionVF: return new AddReductionVFNode(ctrl, n1, n2);
718   case Op_AddReductionVD: return new AddReductionVDNode(ctrl, n1, n2);
719   case Op_MulReductionVI: return new MulReductionVINode(ctrl, n1, n2);
720   case Op_MulReductionVL: return new MulReductionVLNode(ctrl, n1, n2);
721   case Op_MulReductionVF: return new MulReductionVFNode(ctrl, n1, n2);
722   case Op_MulReductionVD: return new MulReductionVDNode(ctrl, n1, n2);
<span class="line-modified">723   case Op_MinReductionV:  return new MinReductionVNode(ctrl, n1, n2);</span>
<span class="line-modified">724   case Op_MaxReductionV:  return new MaxReductionVNode(ctrl, n1, n2);</span>
<span class="line-added">725   case Op_AndReductionV:  return new AndReductionVNode(ctrl, n1, n2);</span>
<span class="line-added">726   case Op_OrReductionV:   return new OrReductionVNode(ctrl, n1, n2);</span>
<span class="line-added">727   case Op_XorReductionV:  return new XorReductionVNode(ctrl, n1, n2);</span>
728   default:
729     fatal(&quot;Missed vector creation for &#39;%s&#39;&quot;, NodeClassNames[vopc]);
730     return NULL;
731   }
732 }
733 
734 bool ReductionNode::implemented(int opc, uint vlen, BasicType bt) {
735   if (is_java_primitive(bt) &amp;&amp;
736       (vlen &gt; 1) &amp;&amp; is_power_of_2(vlen) &amp;&amp;
737       Matcher::vector_size_supported(bt, vlen)) {
738     int vopc = ReductionNode::opcode(opc, bt);
739     return vopc != opc &amp;&amp; Matcher::match_rule_supported(vopc);
740   }
741   return false;
742 }
</pre>
</td>
</tr>
</table>
<center><a href="type.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vectornode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
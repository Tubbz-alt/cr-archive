<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/loopUnswitch.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopTransform.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopnode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopUnswitch.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
165   assert(unswitch_iff != NULL || flattened_checks.size() &gt; 0, &quot;should be at least one&quot;);
166   if (unswitch_iff == NULL) {
167     unswitch_iff = flattened_checks.at(0)-&gt;as_If();
168   }
169 
170 #ifndef PRODUCT
171   if (TraceLoopOpts) {
172     tty-&gt;print(&quot;Unswitch   %d &quot;, head-&gt;unswitch_count()+1);
173     loop-&gt;dump_head();
174   }
175 #endif
176 
177   // Need to revert back to normal loop
178   if (head-&gt;is_CountedLoop() &amp;&amp; !head-&gt;as_CountedLoop()-&gt;is_normal_loop()) {
179     head-&gt;as_CountedLoop()-&gt;set_normal_loop();
180   }
181 
182   ProjNode* proj_true = create_slow_version_of_loop(loop, old_new, unswitch_iff-&gt;Opcode(), CloneIncludesStripMined);
183 
184 #ifdef ASSERT
<span class="line-modified">185   Node* uniqc = proj_true-&gt;unique_ctrl_out();</span>
186   entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
187   Node* predicate = find_predicate(entry);
<span class="line-modified">188   if (predicate != NULL) {</span>
<span class="line-modified">189     entry = skip_loop_predicates(entry);</span>
<span class="line-modified">190   }</span>
<span class="line-modified">191   if (predicate != NULL &amp;&amp; UseLoopPredicate) {</span>
<span class="line-modified">192     // We may have two predicates, find first.</span>
<span class="line-modified">193     Node* n = find_predicate(entry);</span>
<span class="line-modified">194     if (n != NULL) {</span>
<span class="line-modified">195       predicate = n;</span>
<span class="line-modified">196       entry = skip_loop_predicates(entry);</span>





197     }







198   }
<span class="line-removed">199   if (predicate != NULL &amp;&amp; UseProfiledLoopPredicate) {</span>
<span class="line-removed">200     entry = find_predicate(entry);</span>
<span class="line-removed">201     if (entry != NULL) predicate = entry;</span>
<span class="line-removed">202   }</span>
<span class="line-removed">203   if (predicate != NULL) predicate = predicate-&gt;in(0);</span>
<span class="line-removed">204   assert(proj_true-&gt;is_IfTrue() &amp;&amp;</span>
<span class="line-removed">205          (predicate == NULL &amp;&amp; uniqc == head &amp;&amp; !head-&gt;is_strip_mined() ||</span>
<span class="line-removed">206           predicate == NULL &amp;&amp; uniqc == head-&gt;in(LoopNode::EntryControl) &amp;&amp; head-&gt;is_strip_mined() ||</span>
<span class="line-removed">207           predicate != NULL &amp;&amp; uniqc == predicate), &quot;by construction&quot;);</span>
208 #endif
209   // Increment unswitch count
210   LoopNode* head_clone = old_new[head-&gt;_idx]-&gt;as_Loop();
211   int nct = head-&gt;unswitch_count() + 1;
212   head-&gt;set_unswitch_count(nct);
213   head_clone-&gt;set_unswitch_count(nct);
214   if (flattened_checks.size() &gt; 0) {
215     head-&gt;mark_flattened_arrays();
216   }
217 
218   // Add test to new &quot;if&quot; outside of loop
219   IfNode* invar_iff   = proj_true-&gt;in(0)-&gt;as_If();
220   Node* invar_iff_c   = invar_iff-&gt;in(0);
221   invar_iff-&gt;_prob    = unswitch_iff-&gt;_prob;
222   if (flattened_checks.size() &gt; 0) {
223     // Flattened array checks are used in
224     // Parse::array_store()/Parse::array_load() to switch between a
225     // legacy object array access and a flattened value array
226     // access. We want the performance impact on legacy accesses to be
227     // as small as possible so we make 2 copies of the loops: a fast
</pre>
<hr />
<pre>
356   bool counted_loop = head-&gt;is_CountedLoop();
357   Node*     entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
358   _igvn.rehash_node_delayed(entry);
359   IdealLoopTree* outer_loop = loop-&gt;_parent;
360 
361   head-&gt;verify_strip_mined(1);
362 
363   Node *cont      = _igvn.intcon(1);
364   set_ctrl(cont, C-&gt;root());
365   Node* opq       = new Opaque1Node(C, cont);
366   register_node(opq, outer_loop, entry, dom_depth(entry));
367   Node *bol       = new Conv2BNode(opq);
368   register_node(bol, outer_loop, entry, dom_depth(entry));
369   IfNode* iff = (opcode == Op_RangeCheck) ? new RangeCheckNode(entry, bol, PROB_MAX, COUNT_UNKNOWN) :
370     new IfNode(entry, bol, PROB_MAX, COUNT_UNKNOWN);
371   register_node(iff, outer_loop, entry, dom_depth(entry));
372   ProjNode* iffast = new IfTrueNode(iff);
373   register_node(iffast, outer_loop, iff, dom_depth(iff));
374   ProjNode* ifslow = new IfFalseNode(iff);
375   register_node(ifslow, outer_loop, iff, dom_depth(iff));

376 
377   // Clone the loop body.  The clone becomes the slow loop.  The
378   // original pre-header will (illegally) have 3 control users
379   // (old &amp; new loops &amp; new if).
380   clone_loop(loop, old_new, dom_depth(head-&gt;skip_strip_mined()), mode, iff);
381   assert(old_new[head-&gt;_idx]-&gt;is_Loop(), &quot;&quot; );
382 
383   // Fast (true) control
<span class="line-modified">384   Node* iffast_pred = clone_loop_predicates(entry, iffast, !counted_loop);</span>
385 
386   // Slow (false) control
<span class="line-modified">387   Node* ifslow_pred = clone_loop_predicates(entry, ifslow, !counted_loop);</span>
388 
389   Node* l = head-&gt;skip_strip_mined();
390   _igvn.replace_input_of(l, LoopNode::EntryControl, iffast_pred);
391   set_idom(l, iffast_pred, dom_depth(l));
392   LoopNode* slow_l = old_new[head-&gt;_idx]-&gt;as_Loop()-&gt;skip_strip_mined();
393   _igvn.replace_input_of(slow_l, LoopNode::EntryControl, ifslow_pred);
394   set_idom(slow_l, ifslow_pred, dom_depth(l));
395 
396   recompute_dom_depth();
397 
398   return iffast;
399 }
400 
401 LoopNode* PhaseIdealLoop::create_reserve_version_of_loop(IdealLoopTree *loop, CountedLoopReserveKit* lk) {
402   Node_List old_new;
403   LoopNode* head  = loop-&gt;_head-&gt;as_Loop();
404   bool counted_loop = head-&gt;is_CountedLoop();
405   Node*     entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
406   _igvn.rehash_node_delayed(entry);
407   IdealLoopTree* outer_loop = head-&gt;is_strip_mined() ? loop-&gt;_parent-&gt;_parent : loop-&gt;_parent;
</pre>
</td>
<td>
<hr />
<pre>
165   assert(unswitch_iff != NULL || flattened_checks.size() &gt; 0, &quot;should be at least one&quot;);
166   if (unswitch_iff == NULL) {
167     unswitch_iff = flattened_checks.at(0)-&gt;as_If();
168   }
169 
170 #ifndef PRODUCT
171   if (TraceLoopOpts) {
172     tty-&gt;print(&quot;Unswitch   %d &quot;, head-&gt;unswitch_count()+1);
173     loop-&gt;dump_head();
174   }
175 #endif
176 
177   // Need to revert back to normal loop
178   if (head-&gt;is_CountedLoop() &amp;&amp; !head-&gt;as_CountedLoop()-&gt;is_normal_loop()) {
179     head-&gt;as_CountedLoop()-&gt;set_normal_loop();
180   }
181 
182   ProjNode* proj_true = create_slow_version_of_loop(loop, old_new, unswitch_iff-&gt;Opcode(), CloneIncludesStripMined);
183 
184 #ifdef ASSERT
<span class="line-modified">185   assert(proj_true-&gt;is_IfTrue(), &quot;must be true projection&quot;);</span>
186   entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
187   Node* predicate = find_predicate(entry);
<span class="line-modified">188   if (predicate == NULL) {</span>
<span class="line-modified">189     // No empty predicate</span>
<span class="line-modified">190     Node* uniqc = proj_true-&gt;unique_ctrl_out();</span>
<span class="line-modified">191     assert((uniqc == head &amp;&amp; !head-&gt;is_strip_mined()) || (uniqc == head-&gt;in(LoopNode::EntryControl)</span>
<span class="line-modified">192            &amp;&amp; head-&gt;is_strip_mined()), &quot;must hold by construction if no predicates&quot;);</span>
<span class="line-modified">193   } else {</span>
<span class="line-modified">194     // There is at least one empty predicate. When calling &#39;skip_loop_predicates&#39; on each found empty predicate,</span>
<span class="line-modified">195     // we should end up at &#39;proj_true&#39;.</span>
<span class="line-modified">196     Node* proj_before_first_empty_predicate = skip_loop_predicates(entry);</span>
<span class="line-added">197     if (UseProfiledLoopPredicate) {</span>
<span class="line-added">198       predicate = find_predicate(proj_before_first_empty_predicate);</span>
<span class="line-added">199       if (predicate != NULL) {</span>
<span class="line-added">200         proj_before_first_empty_predicate = skip_loop_predicates(predicate);</span>
<span class="line-added">201       }</span>
202     }
<span class="line-added">203     if (UseLoopPredicate) {</span>
<span class="line-added">204       predicate = find_predicate(proj_before_first_empty_predicate);</span>
<span class="line-added">205       if (predicate != NULL) {</span>
<span class="line-added">206         proj_before_first_empty_predicate = skip_loop_predicates(predicate);</span>
<span class="line-added">207       }</span>
<span class="line-added">208     }</span>
<span class="line-added">209     assert(proj_true == proj_before_first_empty_predicate, &quot;must hold by construction if at least one predicate&quot;);</span>
210   }









211 #endif
212   // Increment unswitch count
213   LoopNode* head_clone = old_new[head-&gt;_idx]-&gt;as_Loop();
214   int nct = head-&gt;unswitch_count() + 1;
215   head-&gt;set_unswitch_count(nct);
216   head_clone-&gt;set_unswitch_count(nct);
217   if (flattened_checks.size() &gt; 0) {
218     head-&gt;mark_flattened_arrays();
219   }
220 
221   // Add test to new &quot;if&quot; outside of loop
222   IfNode* invar_iff   = proj_true-&gt;in(0)-&gt;as_If();
223   Node* invar_iff_c   = invar_iff-&gt;in(0);
224   invar_iff-&gt;_prob    = unswitch_iff-&gt;_prob;
225   if (flattened_checks.size() &gt; 0) {
226     // Flattened array checks are used in
227     // Parse::array_store()/Parse::array_load() to switch between a
228     // legacy object array access and a flattened value array
229     // access. We want the performance impact on legacy accesses to be
230     // as small as possible so we make 2 copies of the loops: a fast
</pre>
<hr />
<pre>
359   bool counted_loop = head-&gt;is_CountedLoop();
360   Node*     entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
361   _igvn.rehash_node_delayed(entry);
362   IdealLoopTree* outer_loop = loop-&gt;_parent;
363 
364   head-&gt;verify_strip_mined(1);
365 
366   Node *cont      = _igvn.intcon(1);
367   set_ctrl(cont, C-&gt;root());
368   Node* opq       = new Opaque1Node(C, cont);
369   register_node(opq, outer_loop, entry, dom_depth(entry));
370   Node *bol       = new Conv2BNode(opq);
371   register_node(bol, outer_loop, entry, dom_depth(entry));
372   IfNode* iff = (opcode == Op_RangeCheck) ? new RangeCheckNode(entry, bol, PROB_MAX, COUNT_UNKNOWN) :
373     new IfNode(entry, bol, PROB_MAX, COUNT_UNKNOWN);
374   register_node(iff, outer_loop, entry, dom_depth(entry));
375   ProjNode* iffast = new IfTrueNode(iff);
376   register_node(iffast, outer_loop, iff, dom_depth(iff));
377   ProjNode* ifslow = new IfFalseNode(iff);
378   register_node(ifslow, outer_loop, iff, dom_depth(iff));
<span class="line-added">379   uint idx_before_clone = Compile::current()-&gt;unique();</span>
380 
381   // Clone the loop body.  The clone becomes the slow loop.  The
382   // original pre-header will (illegally) have 3 control users
383   // (old &amp; new loops &amp; new if).
384   clone_loop(loop, old_new, dom_depth(head-&gt;skip_strip_mined()), mode, iff);
385   assert(old_new[head-&gt;_idx]-&gt;is_Loop(), &quot;&quot; );
386 
387   // Fast (true) control
<span class="line-modified">388   Node* iffast_pred = clone_loop_predicates(entry, iffast, !counted_loop, false, idx_before_clone, old_new);</span>
389 
390   // Slow (false) control
<span class="line-modified">391   Node* ifslow_pred = clone_loop_predicates(entry, ifslow, !counted_loop, true, idx_before_clone, old_new);</span>
392 
393   Node* l = head-&gt;skip_strip_mined();
394   _igvn.replace_input_of(l, LoopNode::EntryControl, iffast_pred);
395   set_idom(l, iffast_pred, dom_depth(l));
396   LoopNode* slow_l = old_new[head-&gt;_idx]-&gt;as_Loop()-&gt;skip_strip_mined();
397   _igvn.replace_input_of(slow_l, LoopNode::EntryControl, ifslow_pred);
398   set_idom(slow_l, ifslow_pred, dom_depth(l));
399 
400   recompute_dom_depth();
401 
402   return iffast;
403 }
404 
405 LoopNode* PhaseIdealLoop::create_reserve_version_of_loop(IdealLoopTree *loop, CountedLoopReserveKit* lk) {
406   Node_List old_new;
407   LoopNode* head  = loop-&gt;_head-&gt;as_Loop();
408   bool counted_loop = head-&gt;is_CountedLoop();
409   Node*     entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
410   _igvn.rehash_node_delayed(entry);
411   IdealLoopTree* outer_loop = head-&gt;is_strip_mined() ? loop-&gt;_parent-&gt;_parent : loop-&gt;_parent;
</pre>
</td>
</tr>
</table>
<center><a href="loopTransform.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopnode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
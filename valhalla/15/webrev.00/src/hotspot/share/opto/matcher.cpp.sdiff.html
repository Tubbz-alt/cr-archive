<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/matcher.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macro.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="matcher.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/matcher.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1404   // Set the mark for all locally allocated State objects.
1405   // When this call returns, the _states_arena arena will be reset
1406   // freeing all State objects.
1407   ResourceMark rm( &amp;_states_arena );
1408 
1409   LabelRootDepth = 0;
1410 
1411   // StoreNodes require their Memory input to match any LoadNodes
1412   Node *mem = n-&gt;is_Store() ? n-&gt;in(MemNode::Memory) : (Node*)1 ;
1413 #ifdef ASSERT
1414   Node* save_mem_node = _mem_node;
1415   _mem_node = n-&gt;is_Store() ? (Node*)n : NULL;
1416 #endif
1417   // State object for root node of match tree
1418   // Allocate it on _states_arena - stack allocation can cause stack overflow.
1419   State *s = new (&amp;_states_arena) State;
1420   s-&gt;_kids[0] = NULL;
1421   s-&gt;_kids[1] = NULL;
1422   s-&gt;_leaf = (Node*)n;
1423   // Label the input tree, allocating labels from top-level arena
<span class="line-modified">1424   Label_Root( n, s, n-&gt;in(0), mem );</span>

1425   if (C-&gt;failing())  return NULL;
1426 
1427   // The minimum cost match for the whole tree is found at the root State
1428   uint mincost = max_juint;
1429   uint cost = max_juint;
1430   uint i;
1431   for( i = 0; i &lt; NUM_OPERANDS; i++ ) {
1432     if( s-&gt;valid(i) &amp;&amp;                // valid entry and
1433         s-&gt;_cost[i] &lt; cost &amp;&amp;         // low cost and
1434         s-&gt;_rule[i] &gt;= NUM_OPERANDS ) // not an operand
1435       cost = s-&gt;_cost[mincost=i];
1436   }
1437   if (mincost == max_juint) {
1438 #ifndef PRODUCT
1439     tty-&gt;print(&quot;No matching rule for:&quot;);
1440     s-&gt;dump();
1441 #endif
1442     Matcher::soft_match_failure();
1443     return NULL;
1444   }
</pre>
<hr />
<pre>
1518       return false;
1519     }
1520   }
1521 
1522   // Not forceable cloning.  If shared, put it into a register.
1523   return shared;
1524 }
1525 
1526 
1527 //------------------------------Instruction Selection--------------------------
1528 // Label method walks a &quot;tree&quot; of nodes, using the ADLC generated DFA to match
1529 // ideal nodes to machine instructions.  Trees are delimited by shared Nodes,
1530 // things the Matcher does not match (e.g., Memory), and things with different
1531 // Controls (hence forced into different blocks).  We pass in the Control
1532 // selected for this entire State tree.
1533 
1534 // The Matcher works on Trees, but an Intel add-to-memory requires a DAG: the
1535 // Store and the Load must have identical Memories (as well as identical
1536 // pointers).  Since the Matcher does not have anything for Memory (and
1537 // does not handle DAGs), I have to match the Memory input myself.  If the
<span class="line-modified">1538 // Tree root is a Store, I require all Loads to have the identical memory.</span>
<span class="line-modified">1539 Node *Matcher::Label_Root( const Node *n, State *svec, Node *control, const Node *mem){</span>

1540   // Since Label_Root is a recursive function, its possible that we might run
1541   // out of stack space.  See bugs 6272980 &amp; 6227033 for more info.
1542   LabelRootDepth++;
1543   if (LabelRootDepth &gt; MaxLabelRootDepth) {
1544     C-&gt;record_method_not_compilable(&quot;Out of stack space, increase MaxLabelRootDepth&quot;);
1545     return NULL;
1546   }
1547   uint care = 0;                // Edges matcher cares about
1548   uint cnt = n-&gt;req();
1549   uint i = 0;
1550 
1551   // Examine children for memory state
1552   // Can only subsume a child into your match-tree if that child&#39;s memory state
1553   // is not modified along the path to another input.
1554   // It is unsafe even if the other inputs are separate roots.
1555   Node *input_mem = NULL;
1556   for( i = 1; i &lt; cnt; i++ ) {
1557     if( !n-&gt;match_edge(i) ) continue;
1558     Node *m = n-&gt;in(i);         // Get ith input
1559     assert( m, &quot;expect non-null children&quot; );
1560     if( m-&gt;is_Load() ) {
1561       if( input_mem == NULL ) {
1562         input_mem = m-&gt;in(MemNode::Memory);





1563       } else if( input_mem != m-&gt;in(MemNode::Memory) ) {
1564         input_mem = NodeSentinel;
1565       }
1566     }
1567   }
1568 
1569   for( i = 1; i &lt; cnt; i++ ){// For my children
1570     if( !n-&gt;match_edge(i) ) continue;
1571     Node *m = n-&gt;in(i);         // Get ith input
1572     // Allocate states out of a private arena
1573     State *s = new (&amp;_states_arena) State;
1574     svec-&gt;_kids[care++] = s;
1575     assert( care &lt;= 2, &quot;binary only for now&quot; );
1576 
1577     // Recursively label the State tree.
1578     s-&gt;_kids[0] = NULL;
1579     s-&gt;_kids[1] = NULL;
1580     s-&gt;_leaf = m;
1581 
1582     // Check for leaves of the State Tree; things that cannot be a part of
1583     // the current tree.  If it finds any, that value is matched as a
1584     // register operand.  If not, then the normal matching is used.
1585     if( match_into_reg(n, m, control, i, is_shared(m)) ||
<span class="line-modified">1586         //</span>
<span class="line-modified">1587         // Stop recursion if this is LoadNode and the root of this tree is a</span>
<span class="line-modified">1588         // StoreNode and the load &amp; store have different memories.</span>
1589         ((mem!=(Node*)1) &amp;&amp; m-&gt;is_Load() &amp;&amp; m-&gt;in(MemNode::Memory) != mem) ||
1590         // Can NOT include the match of a subtree when its memory state
1591         // is used by any of the other subtrees
1592         (input_mem == NodeSentinel) ) {
1593       // Print when we exclude matching due to different memory states at input-loads
1594       if (PrintOpto &amp;&amp; (Verbose &amp;&amp; WizardMode) &amp;&amp; (input_mem == NodeSentinel)
<span class="line-modified">1595         &amp;&amp; !((mem!=(Node*)1) &amp;&amp; m-&gt;is_Load() &amp;&amp; m-&gt;in(MemNode::Memory) != mem)) {</span>
1596         tty-&gt;print_cr(&quot;invalid input_mem&quot;);
1597       }
1598       // Switch to a register-only opcode; this value must be in a register
1599       // and cannot be subsumed as part of a larger instruction.
1600       s-&gt;DFA( m-&gt;ideal_reg(), m );
1601 
1602     } else {
1603       // If match tree has no control and we do, adopt it for entire tree
1604       if( control == NULL &amp;&amp; m-&gt;in(0) != NULL &amp;&amp; m-&gt;req() &gt; 1 )
1605         control = m-&gt;in(0);         // Pick up control
1606       // Else match as a normal part of the match tree.
<span class="line-modified">1607       control = Label_Root(m,s,control,mem);</span>
1608       if (C-&gt;failing()) return NULL;
1609     }
1610   }
1611 
1612 
1613   // Call DFA to match this node, and return
1614   svec-&gt;DFA( n-&gt;Opcode(), n );
1615 
1616 #ifdef ASSERT
1617   uint x;
1618   for( x = 0; x &lt; _LAST_MACH_OPER; x++ )
1619     if( svec-&gt;valid(x) )
1620       break;
1621 
1622   if (x &gt;= _LAST_MACH_OPER) {
1623     n-&gt;dump();
1624     svec-&gt;dump();
1625     assert( false, &quot;bad AD file&quot; );
1626   }
1627 #endif
</pre>
</td>
<td>
<hr />
<pre>
1404   // Set the mark for all locally allocated State objects.
1405   // When this call returns, the _states_arena arena will be reset
1406   // freeing all State objects.
1407   ResourceMark rm( &amp;_states_arena );
1408 
1409   LabelRootDepth = 0;
1410 
1411   // StoreNodes require their Memory input to match any LoadNodes
1412   Node *mem = n-&gt;is_Store() ? n-&gt;in(MemNode::Memory) : (Node*)1 ;
1413 #ifdef ASSERT
1414   Node* save_mem_node = _mem_node;
1415   _mem_node = n-&gt;is_Store() ? (Node*)n : NULL;
1416 #endif
1417   // State object for root node of match tree
1418   // Allocate it on _states_arena - stack allocation can cause stack overflow.
1419   State *s = new (&amp;_states_arena) State;
1420   s-&gt;_kids[0] = NULL;
1421   s-&gt;_kids[1] = NULL;
1422   s-&gt;_leaf = (Node*)n;
1423   // Label the input tree, allocating labels from top-level arena
<span class="line-modified">1424   Node* root_mem = mem;</span>
<span class="line-added">1425   Label_Root(n, s, n-&gt;in(0), root_mem);</span>
1426   if (C-&gt;failing())  return NULL;
1427 
1428   // The minimum cost match for the whole tree is found at the root State
1429   uint mincost = max_juint;
1430   uint cost = max_juint;
1431   uint i;
1432   for( i = 0; i &lt; NUM_OPERANDS; i++ ) {
1433     if( s-&gt;valid(i) &amp;&amp;                // valid entry and
1434         s-&gt;_cost[i] &lt; cost &amp;&amp;         // low cost and
1435         s-&gt;_rule[i] &gt;= NUM_OPERANDS ) // not an operand
1436       cost = s-&gt;_cost[mincost=i];
1437   }
1438   if (mincost == max_juint) {
1439 #ifndef PRODUCT
1440     tty-&gt;print(&quot;No matching rule for:&quot;);
1441     s-&gt;dump();
1442 #endif
1443     Matcher::soft_match_failure();
1444     return NULL;
1445   }
</pre>
<hr />
<pre>
1519       return false;
1520     }
1521   }
1522 
1523   // Not forceable cloning.  If shared, put it into a register.
1524   return shared;
1525 }
1526 
1527 
1528 //------------------------------Instruction Selection--------------------------
1529 // Label method walks a &quot;tree&quot; of nodes, using the ADLC generated DFA to match
1530 // ideal nodes to machine instructions.  Trees are delimited by shared Nodes,
1531 // things the Matcher does not match (e.g., Memory), and things with different
1532 // Controls (hence forced into different blocks).  We pass in the Control
1533 // selected for this entire State tree.
1534 
1535 // The Matcher works on Trees, but an Intel add-to-memory requires a DAG: the
1536 // Store and the Load must have identical Memories (as well as identical
1537 // pointers).  Since the Matcher does not have anything for Memory (and
1538 // does not handle DAGs), I have to match the Memory input myself.  If the
<span class="line-modified">1539 // Tree root is a Store or if there are multiple Loads in the tree, I require</span>
<span class="line-modified">1540 // all Loads to have the identical memory.</span>
<span class="line-added">1541 Node* Matcher::Label_Root(const Node* n, State* svec, Node* control, Node*&amp; mem) {</span>
1542   // Since Label_Root is a recursive function, its possible that we might run
1543   // out of stack space.  See bugs 6272980 &amp; 6227033 for more info.
1544   LabelRootDepth++;
1545   if (LabelRootDepth &gt; MaxLabelRootDepth) {
1546     C-&gt;record_method_not_compilable(&quot;Out of stack space, increase MaxLabelRootDepth&quot;);
1547     return NULL;
1548   }
1549   uint care = 0;                // Edges matcher cares about
1550   uint cnt = n-&gt;req();
1551   uint i = 0;
1552 
1553   // Examine children for memory state
1554   // Can only subsume a child into your match-tree if that child&#39;s memory state
1555   // is not modified along the path to another input.
1556   // It is unsafe even if the other inputs are separate roots.
1557   Node *input_mem = NULL;
1558   for( i = 1; i &lt; cnt; i++ ) {
1559     if( !n-&gt;match_edge(i) ) continue;
1560     Node *m = n-&gt;in(i);         // Get ith input
1561     assert( m, &quot;expect non-null children&quot; );
1562     if( m-&gt;is_Load() ) {
1563       if( input_mem == NULL ) {
1564         input_mem = m-&gt;in(MemNode::Memory);
<span class="line-added">1565         if (mem == (Node*)1) {</span>
<span class="line-added">1566           // Save this memory to bail out if there&#39;s another memory access</span>
<span class="line-added">1567           // to a different memory location in the same tree.</span>
<span class="line-added">1568           mem = input_mem;</span>
<span class="line-added">1569         }</span>
1570       } else if( input_mem != m-&gt;in(MemNode::Memory) ) {
1571         input_mem = NodeSentinel;
1572       }
1573     }
1574   }
1575 
1576   for( i = 1; i &lt; cnt; i++ ){// For my children
1577     if( !n-&gt;match_edge(i) ) continue;
1578     Node *m = n-&gt;in(i);         // Get ith input
1579     // Allocate states out of a private arena
1580     State *s = new (&amp;_states_arena) State;
1581     svec-&gt;_kids[care++] = s;
1582     assert( care &lt;= 2, &quot;binary only for now&quot; );
1583 
1584     // Recursively label the State tree.
1585     s-&gt;_kids[0] = NULL;
1586     s-&gt;_kids[1] = NULL;
1587     s-&gt;_leaf = m;
1588 
1589     // Check for leaves of the State Tree; things that cannot be a part of
1590     // the current tree.  If it finds any, that value is matched as a
1591     // register operand.  If not, then the normal matching is used.
1592     if( match_into_reg(n, m, control, i, is_shared(m)) ||
<span class="line-modified">1593         // Stop recursion if this is a LoadNode and there is another memory access</span>
<span class="line-modified">1594         // to a different memory location in the same tree (for example, a StoreNode</span>
<span class="line-modified">1595         // at the root of this tree or another LoadNode in one of the children).</span>
1596         ((mem!=(Node*)1) &amp;&amp; m-&gt;is_Load() &amp;&amp; m-&gt;in(MemNode::Memory) != mem) ||
1597         // Can NOT include the match of a subtree when its memory state
1598         // is used by any of the other subtrees
1599         (input_mem == NodeSentinel) ) {
1600       // Print when we exclude matching due to different memory states at input-loads
1601       if (PrintOpto &amp;&amp; (Verbose &amp;&amp; WizardMode) &amp;&amp; (input_mem == NodeSentinel)
<span class="line-modified">1602           &amp;&amp; !((mem!=(Node*)1) &amp;&amp; m-&gt;is_Load() &amp;&amp; m-&gt;in(MemNode::Memory) != mem)) {</span>
1603         tty-&gt;print_cr(&quot;invalid input_mem&quot;);
1604       }
1605       // Switch to a register-only opcode; this value must be in a register
1606       // and cannot be subsumed as part of a larger instruction.
1607       s-&gt;DFA( m-&gt;ideal_reg(), m );
1608 
1609     } else {
1610       // If match tree has no control and we do, adopt it for entire tree
1611       if( control == NULL &amp;&amp; m-&gt;in(0) != NULL &amp;&amp; m-&gt;req() &gt; 1 )
1612         control = m-&gt;in(0);         // Pick up control
1613       // Else match as a normal part of the match tree.
<span class="line-modified">1614       control = Label_Root(m, s, control, mem);</span>
1615       if (C-&gt;failing()) return NULL;
1616     }
1617   }
1618 
1619 
1620   // Call DFA to match this node, and return
1621   svec-&gt;DFA( n-&gt;Opcode(), n );
1622 
1623 #ifdef ASSERT
1624   uint x;
1625   for( x = 0; x &lt; _LAST_MACH_OPER; x++ )
1626     if( svec-&gt;valid(x) )
1627       break;
1628 
1629   if (x &gt;= _LAST_MACH_OPER) {
1630     n-&gt;dump();
1631     svec-&gt;dump();
1632     assert( false, &quot;bad AD file&quot; );
1633   }
1634 #endif
</pre>
</td>
</tr>
</table>
<center><a href="macro.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="matcher.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
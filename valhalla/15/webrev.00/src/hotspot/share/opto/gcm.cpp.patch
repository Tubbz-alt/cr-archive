diff a/src/hotspot/share/opto/gcm.cpp b/src/hotspot/share/opto/gcm.cpp
--- a/src/hotspot/share/opto/gcm.cpp
+++ b/src/hotspot/share/opto/gcm.cpp
@@ -705,23 +705,10 @@
         // Same for SafePoints: they read/write Raw but only read otherwise.
         // This is basically a workaround for SafePoints only defining control
         // instead of control + memory.
         if (mstore->ideal_Opcode() == Op_SafePoint)
           continue;
-
-        // Check if the store is a membar on which the load is control dependent.
-        // Inserting an anti-dependency between that membar and the load would
-        // create a cycle that causes local scheduling to fail.
-        if (mstore->isa_MachMemBar()) {
-          Node* dom = load->find_exact_control(load->in(0));
-          while (dom != NULL && dom != dom->in(0) && dom != mstore) {
-            dom = dom->in(0);
-          }
-          if (dom == mstore) {
-            continue;
-          }
-        }
       } else {
         // Some raw memory, such as the load of "top" at an allocation,
         // can be control dependent on the previous safepoint. See
         // comments in GraphKit::allocate_heap() about control input.
         // Inserting an anti-dep between such a safepoint and a use
@@ -1437,12 +1424,10 @@
   // dominator tree of all USES of a value.  Pick the block with the least
   // loop nesting depth that is lowest in the dominator tree.
   // ( visited.clear() called in schedule_late()->Node_Backward_Iterator() )
   schedule_late(visited, stack);
   if (C->failing()) {
-    // schedule_late fails only when graph is incorrect.
-    assert(!VerifyGraphEdges, "verification should have failed");
     return;
   }
 
 #ifndef PRODUCT
   if (trace_opto_pipelining()) {

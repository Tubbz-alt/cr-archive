<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/macro.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="machnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="matcher.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/macro.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1662     _igvn.remove_dead_node(_fallthroughproj);
1663   }
1664   if (_memproj_fallthrough != NULL) {
1665     _igvn.replace_in_uses(_memproj_fallthrough, mem);
1666     _igvn.remove_dead_node(_memproj_fallthrough);
1667   }
1668   if (_ioproj_fallthrough != NULL) {
1669     _igvn.replace_in_uses(_ioproj_fallthrough, i_o);
1670     _igvn.remove_dead_node(_ioproj_fallthrough);
1671   }
1672   if (_memproj_catchall != NULL) {
1673     _igvn.rehash_node_delayed(_memproj_catchall);
1674     _memproj_catchall-&gt;set_req(0, top());
1675   }
1676   if (_ioproj_catchall != NULL) {
1677     _igvn.rehash_node_delayed(_ioproj_catchall);
1678     _ioproj_catchall-&gt;set_req(0, top());
1679   }
1680 #ifndef PRODUCT
1681   if (PrintEliminateAllocations) {
<span class="line-modified">1682     if (alloc-&gt;is_AllocateArray()) {}</span>
1683       tty-&gt;print_cr(&quot;++++ Eliminated: %d AllocateArray&quot;, alloc-&gt;_idx);
1684     } else {
1685       tty-&gt;print_cr(&quot;++++ Eliminated: %d Allocate&quot;, alloc-&gt;_idx);
1686     }

1687 #endif
1688   _igvn.remove_dead_node(alloc);
1689 }
1690 
1691 void PhaseMacroExpand::expand_initialize_membar(AllocateNode* alloc, InitializeNode* init,
1692                                                 Node*&amp; fast_oop_ctrl, Node*&amp; fast_oop_rawmem) {
1693   // If initialization is performed by an array copy, any required
1694   // MemBarStoreStore was already added. If the object does not
1695   // escape no need for a MemBarStoreStore. If the object does not
1696   // escape in its initializer and memory barrier (MemBarStoreStore or
1697   // stronger) is already added at exit of initializer, also no need
1698   // for a MemBarStoreStore. Otherwise we need a MemBarStoreStore
1699   // so that stores that initialize this object can&#39;t be reordered
1700   // with a subsequent store that makes this object accessible by
1701   // other threads.
1702   // Other threads include java threads and JVM internal threads
1703   // (for example concurrent GC threads). Current concurrent GC
1704   // implementation: G1 will not scan newly created object,
1705   // so it&#39;s safe to skip storestore barrier when allocation does
1706   // not escape.
</pre>
</td>
<td>
<hr />
<pre>
1662     _igvn.remove_dead_node(_fallthroughproj);
1663   }
1664   if (_memproj_fallthrough != NULL) {
1665     _igvn.replace_in_uses(_memproj_fallthrough, mem);
1666     _igvn.remove_dead_node(_memproj_fallthrough);
1667   }
1668   if (_ioproj_fallthrough != NULL) {
1669     _igvn.replace_in_uses(_ioproj_fallthrough, i_o);
1670     _igvn.remove_dead_node(_ioproj_fallthrough);
1671   }
1672   if (_memproj_catchall != NULL) {
1673     _igvn.rehash_node_delayed(_memproj_catchall);
1674     _memproj_catchall-&gt;set_req(0, top());
1675   }
1676   if (_ioproj_catchall != NULL) {
1677     _igvn.rehash_node_delayed(_ioproj_catchall);
1678     _ioproj_catchall-&gt;set_req(0, top());
1679   }
1680 #ifndef PRODUCT
1681   if (PrintEliminateAllocations) {
<span class="line-modified">1682     if (alloc-&gt;is_AllocateArray()) {</span>
1683       tty-&gt;print_cr(&quot;++++ Eliminated: %d AllocateArray&quot;, alloc-&gt;_idx);
1684     } else {
1685       tty-&gt;print_cr(&quot;++++ Eliminated: %d Allocate&quot;, alloc-&gt;_idx);
1686     }
<span class="line-added">1687   }</span>
1688 #endif
1689   _igvn.remove_dead_node(alloc);
1690 }
1691 
1692 void PhaseMacroExpand::expand_initialize_membar(AllocateNode* alloc, InitializeNode* init,
1693                                                 Node*&amp; fast_oop_ctrl, Node*&amp; fast_oop_rawmem) {
1694   // If initialization is performed by an array copy, any required
1695   // MemBarStoreStore was already added. If the object does not
1696   // escape no need for a MemBarStoreStore. If the object does not
1697   // escape in its initializer and memory barrier (MemBarStoreStore or
1698   // stronger) is already added at exit of initializer, also no need
1699   // for a MemBarStoreStore. Otherwise we need a MemBarStoreStore
1700   // so that stores that initialize this object can&#39;t be reordered
1701   // with a subsequent store that makes this object accessible by
1702   // other threads.
1703   // Other threads include java threads and JVM internal threads
1704   // (for example concurrent GC threads). Current concurrent GC
1705   // implementation: G1 will not scan newly created object,
1706   // so it&#39;s safe to skip storestore barrier when allocation does
1707   // not escape.
</pre>
</td>
</tr>
</table>
<center><a href="machnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="matcher.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
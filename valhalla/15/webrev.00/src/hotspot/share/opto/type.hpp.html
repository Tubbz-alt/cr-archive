<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/type.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_TYPE_HPP
  26 #define SHARE_OPTO_TYPE_HPP
  27 
  28 #include &quot;ci/ciValueKlass.hpp&quot;
  29 #include &quot;opto/adlcVMDeps.hpp&quot;
  30 #include &quot;runtime/handles.hpp&quot;
  31 #include &quot;runtime/sharedRuntime.hpp&quot;
  32 
  33 // Portions of code courtesy of Clifford Click
  34 
  35 // Optimization - Graph Style
  36 
  37 
  38 // This class defines a Type lattice.  The lattice is used in the constant
  39 // propagation algorithms, and for some type-checking of the iloc code.
  40 // Basic types include RSD&#39;s (lower bound, upper bound, stride for integers),
  41 // float &amp; double precision constants, sets of data-labels and code-labels.
  42 // The complete lattice is described below.  Subtypes have no relationship to
  43 // up or down in the lattice; that is entirely determined by the behavior of
  44 // the MEET/JOIN functions.
  45 
  46 class Dict;
  47 class Type;
  48 class   TypeD;
  49 class   TypeF;
  50 class   TypeInt;
  51 class   TypeLong;
  52 class   TypeNarrowPtr;
  53 class     TypeNarrowOop;
  54 class     TypeNarrowKlass;
  55 class   TypeAry;
  56 class   TypeTuple;
  57 class   TypeValueType;
  58 class   TypeVect;
  59 class     TypeVectS;
  60 class     TypeVectD;
  61 class     TypeVectX;
  62 class     TypeVectY;
  63 class     TypeVectZ;
  64 class   TypePtr;
  65 class     TypeRawPtr;
  66 class     TypeOopPtr;
  67 class       TypeInstPtr;
  68 class       TypeAryPtr;
  69 class     TypeKlassPtr;
  70 class     TypeMetadataPtr;
  71 
  72 //------------------------------Type-------------------------------------------
  73 // Basic Type object, represents a set of primitive Values.
  74 // Types are hash-cons&#39;d into a private class dictionary, so only one of each
  75 // different kind of Type exists.  Types are never modified after creation, so
  76 // all their interesting fields are constant.
  77 class Type {
  78   friend class VMStructs;
  79 
  80 public:
  81   enum TYPES {
  82     Bad=0,                      // Type check
  83     Control,                    // Control of code (not in lattice)
  84     Top,                        // Top of the lattice
  85     Int,                        // Integer range (lo-hi)
  86     Long,                       // Long integer range (lo-hi)
  87     Half,                       // Placeholder half of doubleword
  88     NarrowOop,                  // Compressed oop pointer
  89     NarrowKlass,                // Compressed klass pointer
  90 
  91     Tuple,                      // Method signature or object layout
  92     Array,                      // Array types
  93     VectorS,                    //  32bit Vector types
  94     VectorD,                    //  64bit Vector types
  95     VectorX,                    // 128bit Vector types
  96     VectorY,                    // 256bit Vector types
  97     VectorZ,                    // 512bit Vector types
  98     ValueType,                  // Value type
  99 
 100     AnyPtr,                     // Any old raw, klass, inst, or array pointer
 101     RawPtr,                     // Raw (non-oop) pointers
 102     OopPtr,                     // Any and all Java heap entities
 103     InstPtr,                    // Instance pointers (non-array objects)
 104     AryPtr,                     // Array pointers
 105     // (Ptr order matters:  See is_ptr, isa_ptr, is_oopptr, isa_oopptr.)
 106 
 107     MetadataPtr,                // Generic metadata
 108     KlassPtr,                   // Klass pointers
 109 
 110     Function,                   // Function signature
 111     Abio,                       // Abstract I/O
 112     Return_Address,             // Subroutine return address
 113     Memory,                     // Abstract store
 114     FloatTop,                   // No float value
 115     FloatCon,                   // Floating point constant
 116     FloatBot,                   // Any float value
 117     DoubleTop,                  // No double value
 118     DoubleCon,                  // Double precision constant
 119     DoubleBot,                  // Any double value
 120     Bottom,                     // Bottom of lattice
 121     lastype                     // Bogus ending type (not in lattice)
 122   };
 123 
 124   // Signal values for offsets from a base pointer
 125   enum OFFSET_SIGNALS {
 126     OffsetTop = -2000000000,    // undefined offset
 127     OffsetBot = -2000000001     // any possible offset
 128   };
 129 
 130   class Offset {
 131   private:
 132     int _offset;
 133 
 134   public:
 135     explicit Offset(int offset) : _offset(offset) {}
 136 
 137     const Offset meet(const Offset other) const;
 138     const Offset dual() const;
 139     const Offset add(intptr_t offset) const;
 140     bool operator==(const Offset&amp; other) const {
 141       return _offset == other._offset;
 142     }
 143     bool operator!=(const Offset&amp; other) const {
 144       return _offset != other._offset;
 145     }
 146     int get() const { return _offset; }
 147 
 148     void dump2(outputStream *st) const;
 149 
 150     static const Offset top;
 151     static const Offset bottom;
 152   };
 153 
 154   // Min and max WIDEN values.
 155   enum WIDEN {
 156     WidenMin = 0,
 157     WidenMax = 3
 158   };
 159 
 160 private:
 161   typedef struct {
 162     TYPES                dual_type;
 163     BasicType            basic_type;
 164     const char*          msg;
 165     bool                 isa_oop;
 166     uint                 ideal_reg;
 167     relocInfo::relocType reloc;
 168   } TypeInfo;
 169 
 170   // Dictionary of types shared among compilations.
 171   static Dict* _shared_type_dict;
 172   static const TypeInfo _type_info[];
 173 
 174   static int uhash( const Type *const t );
 175   // Structural equality check.  Assumes that cmp() has already compared
 176   // the _base types and thus knows it can cast &#39;t&#39; appropriately.
 177   virtual bool eq( const Type *t ) const;
 178 
 179   // Top-level hash-table of types
 180   static Dict *type_dict() {
 181     return Compile::current()-&gt;type_dict();
 182   }
 183 
 184   // DUAL operation: reflect around lattice centerline.  Used instead of
 185   // join to ensure my lattice is symmetric up and down.  Dual is computed
 186   // lazily, on demand, and cached in _dual.
 187   const Type *_dual;            // Cached dual value
 188   // Table for efficient dualing of base types
 189   static const TYPES dual_type[lastype];
 190 
 191 #ifdef ASSERT
 192   // One type is interface, the other is oop
 193   virtual bool interface_vs_oop_helper(const Type *t) const;
 194 #endif
 195 
 196   const Type *meet_helper(const Type *t, bool include_speculative) const;
 197   void check_symmetrical(const Type *t, const Type *mt) const;
 198 
 199 protected:
 200   // Each class of type is also identified by its base.
 201   const TYPES _base;            // Enum of Types type
 202 
 203   Type( TYPES t ) : _dual(NULL),  _base(t) {} // Simple types
 204   // ~Type();                   // Use fast deallocation
 205   const Type *hashcons();       // Hash-cons the type
 206   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 207   const Type *join_helper(const Type *t, bool include_speculative) const {
 208     return dual()-&gt;meet_helper(t-&gt;dual(), include_speculative)-&gt;dual();
 209   }
 210 
 211 public:
 212 
 213   inline void* operator new( size_t x ) throw() {
 214     Compile* compile = Compile::current();
 215     compile-&gt;set_type_last_size(x);
 216     return compile-&gt;type_arena()-&gt;Amalloc_D(x);
 217   }
 218   inline void operator delete( void* ptr ) {
 219     Compile* compile = Compile::current();
 220     compile-&gt;type_arena()-&gt;Afree(ptr,compile-&gt;type_last_size());
 221   }
 222 
 223   // Initialize the type system for a particular compilation.
 224   static void Initialize(Compile* compile);
 225 
 226   // Initialize the types shared by all compilations.
 227   static void Initialize_shared(Compile* compile);
 228 
 229   TYPES base() const {
 230     assert(_base &gt; Bad &amp;&amp; _base &lt; lastype, &quot;sanity&quot;);
 231     return _base;
 232   }
 233 
 234   // Create a new hash-consd type
 235   static const Type *make(enum TYPES);
 236   // Test for equivalence of types
 237   static int cmp( const Type *const t1, const Type *const t2 );
 238   // Test for higher or equal in lattice
 239   // Variant that drops the speculative part of the types
 240   bool higher_equal(const Type *t) const {
 241     return !cmp(meet(t),t-&gt;remove_speculative());
 242   }
 243   // Variant that keeps the speculative part of the types
 244   bool higher_equal_speculative(const Type *t) const {
 245     return !cmp(meet_speculative(t),t);
 246   }
 247 
 248   // MEET operation; lower in lattice.
 249   // Variant that drops the speculative part of the types
 250   const Type *meet(const Type *t) const {
 251     return meet_helper(t, false);
 252   }
 253   // Variant that keeps the speculative part of the types
 254   const Type *meet_speculative(const Type *t) const {
 255     return meet_helper(t, true)-&gt;cleanup_speculative();
 256   }
 257   // WIDEN: &#39;widens&#39; for Ints and other range types
 258   virtual const Type *widen( const Type *old, const Type* limit ) const { return this; }
 259   // NARROW: complement for widen, used by pessimistic phases
 260   virtual const Type *narrow( const Type *old ) const { return this; }
 261 
 262   // DUAL operation: reflect around lattice centerline.  Used instead of
 263   // join to ensure my lattice is symmetric up and down.
 264   const Type *dual() const { return _dual; }
 265 
 266   // Compute meet dependent on base type
 267   virtual const Type *xmeet( const Type *t ) const;
 268   virtual const Type *xdual() const;    // Compute dual right now.
 269 
 270   // JOIN operation; higher in lattice.  Done by finding the dual of the
 271   // meet of the dual of the 2 inputs.
 272   // Variant that drops the speculative part of the types
 273   const Type *join(const Type *t) const {
 274     return join_helper(t, false);
 275   }
 276   // Variant that keeps the speculative part of the types
 277   const Type *join_speculative(const Type *t) const {
 278     return join_helper(t, true)-&gt;cleanup_speculative();
 279   }
 280 
 281   // Modified version of JOIN adapted to the needs Node::Value.
 282   // Normalizes all empty values to TOP.  Does not kill _widen bits.
 283   // Currently, it also works around limitations involving interface types.
 284   // Variant that drops the speculative part of the types
 285   const Type *filter(const Type *kills) const {
 286     return filter_helper(kills, false);
 287   }
 288   // Variant that keeps the speculative part of the types
 289   const Type *filter_speculative(const Type *kills) const {
 290     return filter_helper(kills, true)-&gt;cleanup_speculative();
 291   }
 292 
 293 #ifdef ASSERT
 294   // One type is interface, the other is oop
 295   virtual bool interface_vs_oop(const Type *t) const;
 296 #endif
 297 
 298   // Returns true if this pointer points at memory which contains a
 299   // compressed oop references.
 300   bool is_ptr_to_narrowoop() const;
 301   bool is_ptr_to_narrowklass() const;
 302 
 303   // Convenience access
 304   float getf() const;
 305   double getd() const;
 306 
 307   const TypeInt    *is_int() const;
 308   const TypeInt    *isa_int() const;             // Returns NULL if not an Int
 309   const TypeLong   *is_long() const;
 310   const TypeLong   *isa_long() const;            // Returns NULL if not a Long
 311   const TypeD      *isa_double() const;          // Returns NULL if not a Double{Top,Con,Bot}
 312   const TypeD      *is_double_constant() const;  // Asserts it is a DoubleCon
 313   const TypeD      *isa_double_constant() const; // Returns NULL if not a DoubleCon
 314   const TypeF      *isa_float() const;           // Returns NULL if not a Float{Top,Con,Bot}
 315   const TypeF      *is_float_constant() const;   // Asserts it is a FloatCon
 316   const TypeF      *isa_float_constant() const;  // Returns NULL if not a FloatCon
 317   const TypeTuple  *is_tuple() const;            // Collection of fields, NOT a pointer
 318   const TypeAry    *is_ary() const;              // Array, NOT array pointer
 319   const TypeAry    *isa_ary() const;             // Returns NULL of not ary
 320   const TypeVect   *is_vect() const;             // Vector
 321   const TypeVect   *isa_vect() const;            // Returns NULL if not a Vector
 322   const TypePtr    *is_ptr() const;              // Asserts it is a ptr type
 323   const TypePtr    *isa_ptr() const;             // Returns NULL if not ptr type
 324   const TypeRawPtr *isa_rawptr() const;          // NOT Java oop
 325   const TypeRawPtr *is_rawptr() const;           // Asserts is rawptr
 326   const TypeNarrowOop  *is_narrowoop() const;    // Java-style GC&#39;d pointer
 327   const TypeNarrowOop  *isa_narrowoop() const;   // Returns NULL if not oop ptr type
 328   const TypeNarrowKlass *is_narrowklass() const; // compressed klass pointer
 329   const TypeNarrowKlass *isa_narrowklass() const;// Returns NULL if not oop ptr type
 330   const TypeOopPtr   *isa_oopptr() const;        // Returns NULL if not oop ptr type
 331   const TypeOopPtr   *is_oopptr() const;         // Java-style GC&#39;d pointer
 332   const TypeInstPtr  *isa_instptr() const;       // Returns NULL if not InstPtr
 333   const TypeInstPtr  *is_instptr() const;        // Instance
 334   const TypeAryPtr   *isa_aryptr() const;        // Returns NULL if not AryPtr
 335   const TypeAryPtr   *is_aryptr() const;         // Array oop
 336   const TypeValueType* isa_valuetype() const;    // Returns NULL if not Value Type
 337   const TypeValueType* is_valuetype() const;     // Value Type
 338 
 339   const TypeMetadataPtr   *isa_metadataptr() const;   // Returns NULL if not oop ptr type
 340   const TypeMetadataPtr   *is_metadataptr() const;    // Java-style GC&#39;d pointer
 341   const TypeKlassPtr      *isa_klassptr() const;      // Returns NULL if not KlassPtr
 342   const TypeKlassPtr      *is_klassptr() const;       // assert if not KlassPtr
 343 
 344   virtual bool      is_finite() const;           // Has a finite value
 345   virtual bool      is_nan()    const;           // Is not a number (NaN)
 346 
 347   bool is_valuetypeptr() const;
 348   virtual ciValueKlass* value_klass() const;
 349 
 350   // Returns this ptr type or the equivalent ptr type for this compressed pointer.
 351   const TypePtr* make_ptr() const;
 352 
 353   // Returns this oopptr type or the equivalent oopptr type for this compressed pointer.
 354   // Asserts if the underlying type is not an oopptr or narrowoop.
 355   const TypeOopPtr* make_oopptr() const;
 356 
 357   // Returns this compressed pointer or the equivalent compressed version
 358   // of this pointer type.
 359   const TypeNarrowOop* make_narrowoop() const;
 360 
 361   // Returns this compressed klass pointer or the equivalent
 362   // compressed version of this pointer type.
 363   const TypeNarrowKlass* make_narrowklass() const;
 364 
 365   // Special test for register pressure heuristic
 366   bool is_floatingpoint() const;        // True if Float or Double base type
 367 
 368   // Do you have memory, directly or through a tuple?
 369   bool has_memory( ) const;
 370 
 371   // TRUE if type is a singleton
 372   virtual bool singleton(void) const;
 373 
 374   // TRUE if type is above the lattice centerline, and is therefore vacuous
 375   virtual bool empty(void) const;
 376 
 377   // Return a hash for this type.  The hash function is public so ConNode
 378   // (constants) can hash on their constant, which is represented by a Type.
 379   virtual int hash() const;
 380 
 381   // Map ideal registers (machine types) to ideal types
 382   static const Type *mreg2type[];
 383 
 384   // Printing, statistics
 385 #ifndef PRODUCT
 386   void         dump_on(outputStream *st) const;
 387   void         dump() const {
 388     dump_on(tty);
 389   }
 390   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 391   static  void dump_stats();
 392 
 393   static const char* str(const Type* t);
 394 #endif
 395   void typerr(const Type *t) const; // Mixing types error
 396 
 397   // Create basic type
 398   static const Type* get_const_basic_type(BasicType type) {
 399     assert((uint)type &lt;= T_CONFLICT &amp;&amp; _const_basic_type[type] != NULL, &quot;bad type&quot;);
 400     return _const_basic_type[type];
 401   }
 402 
 403   // For two instance arrays of same dimension, return the base element types.
 404   // Otherwise or if the arrays have different dimensions, return NULL.
 405   static void get_arrays_base_elements(const Type *a1, const Type *a2,
 406                                        const TypeInstPtr **e1, const TypeInstPtr **e2);
 407 
 408   // Mapping to the array element&#39;s basic type.
 409   BasicType array_element_basic_type() const;
 410 
 411   // Create standard type for a ciType:
 412   static const Type* get_const_type(ciType* type);
 413 
 414   // Create standard zero value:
 415   static const Type* get_zero_type(BasicType type) {
 416     assert((uint)type &lt;= T_CONFLICT &amp;&amp; _zero_type[type] != NULL, &quot;bad type&quot;);
 417     return _zero_type[type];
 418   }
 419 
 420   // Report if this is a zero value (not top).
 421   bool is_zero_type() const {
 422     BasicType type = basic_type();
 423     if (type == T_VOID || type &gt;= T_CONFLICT)
 424       return false;
 425     else
 426       return (this == _zero_type[type]);
 427   }
 428 
 429   // Convenience common pre-built types.
 430   static const Type *ABIO;
 431   static const Type *BOTTOM;
 432   static const Type *CONTROL;
 433   static const Type *DOUBLE;
 434   static const Type *FLOAT;
 435   static const Type *HALF;
 436   static const Type *MEMORY;
 437   static const Type *MULTI;
 438   static const Type *RETURN_ADDRESS;
 439   static const Type *TOP;
 440 
 441   // Mapping from compiler type to VM BasicType
 442   BasicType basic_type() const       { return _type_info[_base].basic_type; }
 443   uint ideal_reg() const             { return _type_info[_base].ideal_reg; }
 444   const char* msg() const            { return _type_info[_base].msg; }
 445   bool isa_oop_ptr() const           { return _type_info[_base].isa_oop; }
 446   relocInfo::relocType reloc() const { return _type_info[_base].reloc; }
 447 
 448   // Mapping from CI type system to compiler type:
 449   static const Type* get_typeflow_type(ciType* type);
 450 
 451   static const Type* make_from_constant(ciConstant constant,
 452                                         bool require_constant = false,
 453                                         int stable_dimension = 0,
 454                                         bool is_narrow = false,
 455                                         bool is_autobox_cache = false);
 456 
 457   static const Type* make_constant_from_field(ciInstance* holder,
 458                                               int off,
 459                                               bool is_unsigned_load,
 460                                               BasicType loadbt);
 461 
 462   static const Type* make_constant_from_field(ciField* field,
 463                                               ciInstance* holder,
 464                                               BasicType loadbt,
 465                                               bool is_unsigned_load);
 466 
 467   static const Type* make_constant_from_array_element(ciArray* array,
 468                                                       int off,
 469                                                       int stable_dimension,
 470                                                       BasicType loadbt,
 471                                                       bool is_unsigned_load);
 472 
 473   // Speculative type helper methods. See TypePtr.
 474   virtual const TypePtr* speculative() const                                  { return NULL; }
 475   virtual ciKlass* speculative_type() const                                   { return NULL; }
 476   virtual ciKlass* speculative_type_not_null() const                          { return NULL; }
 477   virtual bool speculative_maybe_null() const                                 { return true; }
 478   virtual bool speculative_always_null() const                                { return true; }
 479   virtual const Type* remove_speculative() const                              { return this; }
 480   virtual const Type* cleanup_speculative() const                             { return this; }
 481   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return exact_kls != NULL; }
 482   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return ptr_kind == ProfileAlwaysNull || ptr_kind == ProfileNeverNull; }
 483   const Type* maybe_remove_speculative(bool include_speculative) const;
 484 
 485   virtual bool maybe_null() const { return true; }
 486   virtual bool is_known_instance() const { return false; }
 487 
 488 private:
 489   // support arrays
 490   static const Type*        _zero_type[T_CONFLICT+1];
 491   static const Type* _const_basic_type[T_CONFLICT+1];
 492 };
 493 
 494 //------------------------------TypeF------------------------------------------
 495 // Class of Float-Constant Types.
 496 class TypeF : public Type {
 497   TypeF( float f ) : Type(FloatCon), _f(f) {};
 498 public:
 499   virtual bool eq( const Type *t ) const;
 500   virtual int  hash() const;             // Type specific hashing
 501   virtual bool singleton(void) const;    // TRUE if type is a singleton
 502   virtual bool empty(void) const;        // TRUE if type is vacuous
 503 public:
 504   const float _f;               // Float constant
 505 
 506   static const TypeF *make(float f);
 507 
 508   virtual bool        is_finite() const;  // Has a finite value
 509   virtual bool        is_nan()    const;  // Is not a number (NaN)
 510 
 511   virtual const Type *xmeet( const Type *t ) const;
 512   virtual const Type *xdual() const;    // Compute dual right now.
 513   // Convenience common pre-built types.
 514   static const TypeF *ZERO; // positive zero only
 515   static const TypeF *ONE;
 516   static const TypeF *POS_INF;
 517   static const TypeF *NEG_INF;
 518 #ifndef PRODUCT
 519   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 520 #endif
 521 };
 522 
 523 //------------------------------TypeD------------------------------------------
 524 // Class of Double-Constant Types.
 525 class TypeD : public Type {
 526   TypeD( double d ) : Type(DoubleCon), _d(d) {};
 527 public:
 528   virtual bool eq( const Type *t ) const;
 529   virtual int  hash() const;             // Type specific hashing
 530   virtual bool singleton(void) const;    // TRUE if type is a singleton
 531   virtual bool empty(void) const;        // TRUE if type is vacuous
 532 public:
 533   const double _d;              // Double constant
 534 
 535   static const TypeD *make(double d);
 536 
 537   virtual bool        is_finite() const;  // Has a finite value
 538   virtual bool        is_nan()    const;  // Is not a number (NaN)
 539 
 540   virtual const Type *xmeet( const Type *t ) const;
 541   virtual const Type *xdual() const;    // Compute dual right now.
 542   // Convenience common pre-built types.
 543   static const TypeD *ZERO; // positive zero only
 544   static const TypeD *ONE;
 545   static const TypeD *POS_INF;
 546   static const TypeD *NEG_INF;
 547 #ifndef PRODUCT
 548   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 549 #endif
 550 };
 551 
 552 //------------------------------TypeInt----------------------------------------
 553 // Class of integer ranges, the set of integers between a lower bound and an
 554 // upper bound, inclusive.
 555 class TypeInt : public Type {
 556   TypeInt( jint lo, jint hi, int w );
 557 protected:
 558   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 559 
 560 public:
 561   typedef jint NativeType;
 562   virtual bool eq( const Type *t ) const;
 563   virtual int  hash() const;             // Type specific hashing
 564   virtual bool singleton(void) const;    // TRUE if type is a singleton
 565   virtual bool empty(void) const;        // TRUE if type is vacuous
 566   const jint _lo, _hi;          // Lower bound, upper bound
 567   const short _widen;           // Limit on times we widen this sucker
 568 
 569   static const TypeInt *make(jint lo);
 570   // must always specify w
 571   static const TypeInt *make(jint lo, jint hi, int w);
 572 
 573   // Check for single integer
 574   int is_con() const { return _lo==_hi; }
 575   bool is_con(int i) const { return is_con() &amp;&amp; _lo == i; }
 576   jint get_con() const { assert( is_con(), &quot;&quot; );  return _lo; }
 577 
 578   virtual bool        is_finite() const;  // Has a finite value
 579 
 580   virtual const Type *xmeet( const Type *t ) const;
 581   virtual const Type *xdual() const;    // Compute dual right now.
 582   virtual const Type *widen( const Type *t, const Type* limit_type ) const;
 583   virtual const Type *narrow( const Type *t ) const;
 584   // Do not kill _widen bits.
 585   // Convenience common pre-built types.
 586   static const TypeInt *MINUS_1;
 587   static const TypeInt *ZERO;
 588   static const TypeInt *ONE;
 589   static const TypeInt *BOOL;
 590   static const TypeInt *CC;
 591   static const TypeInt *CC_LT;  // [-1]  == MINUS_1
 592   static const TypeInt *CC_GT;  // [1]   == ONE
 593   static const TypeInt *CC_EQ;  // [0]   == ZERO
 594   static const TypeInt *CC_LE;  // [-1,0]
 595   static const TypeInt *CC_GE;  // [0,1] == BOOL (!)
 596   static const TypeInt *BYTE;
 597   static const TypeInt *UBYTE;
 598   static const TypeInt *CHAR;
 599   static const TypeInt *SHORT;
 600   static const TypeInt *POS;
 601   static const TypeInt *POS1;
 602   static const TypeInt *INT;
 603   static const TypeInt *SYMINT; // symmetric range [-max_jint..max_jint]
 604   static const TypeInt *TYPE_DOMAIN; // alias for TypeInt::INT
 605 
 606   static const TypeInt *as_self(const Type *t) { return t-&gt;is_int(); }
 607 #ifndef PRODUCT
 608   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 609 #endif
 610 };
 611 
 612 
 613 //------------------------------TypeLong---------------------------------------
 614 // Class of long integer ranges, the set of integers between a lower bound and
 615 // an upper bound, inclusive.
 616 class TypeLong : public Type {
 617   TypeLong( jlong lo, jlong hi, int w );
 618 protected:
 619   // Do not kill _widen bits.
 620   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 621 public:
 622   typedef jlong NativeType;
 623   virtual bool eq( const Type *t ) const;
 624   virtual int  hash() const;             // Type specific hashing
 625   virtual bool singleton(void) const;    // TRUE if type is a singleton
 626   virtual bool empty(void) const;        // TRUE if type is vacuous
 627 public:
 628   const jlong _lo, _hi;         // Lower bound, upper bound
 629   const short _widen;           // Limit on times we widen this sucker
 630 
 631   static const TypeLong *make(jlong lo);
 632   // must always specify w
 633   static const TypeLong *make(jlong lo, jlong hi, int w);
 634 
 635   // Check for single integer
 636   int is_con() const { return _lo==_hi; }
 637   bool is_con(int i) const { return is_con() &amp;&amp; _lo == i; }
 638   jlong get_con() const { assert( is_con(), &quot;&quot; ); return _lo; }
 639 
 640   // Check for positive 32-bit value.
 641   int is_positive_int() const { return _lo &gt;= 0 &amp;&amp; _hi &lt;= (jlong)max_jint; }
 642 
 643   virtual bool        is_finite() const;  // Has a finite value
 644 
 645 
 646   virtual const Type *xmeet( const Type *t ) const;
 647   virtual const Type *xdual() const;    // Compute dual right now.
 648   virtual const Type *widen( const Type *t, const Type* limit_type ) const;
 649   virtual const Type *narrow( const Type *t ) const;
 650   // Convenience common pre-built types.
 651   static const TypeLong *MINUS_1;
 652   static const TypeLong *ZERO;
 653   static const TypeLong *ONE;
 654   static const TypeLong *POS;
 655   static const TypeLong *LONG;
 656   static const TypeLong *INT;    // 32-bit subrange [min_jint..max_jint]
 657   static const TypeLong *UINT;   // 32-bit unsigned [0..max_juint]
 658   static const TypeLong *TYPE_DOMAIN; // alias for TypeLong::LONG
 659 
 660   // static convenience methods.
 661   static const TypeLong *as_self(const Type *t) { return t-&gt;is_long(); }
 662 
 663 #ifndef PRODUCT
 664   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const;// Specialized per-Type dumping
 665 #endif
 666 };
 667 
 668 //------------------------------TypeTuple--------------------------------------
 669 // Class of Tuple Types, essentially type collections for function signatures
 670 // and class layouts.  It happens to also be a fast cache for the HotSpot
 671 // signature types.
 672 class TypeTuple : public Type {
 673   TypeTuple( uint cnt, const Type **fields ) : Type(Tuple), _cnt(cnt), _fields(fields) { }
 674 
 675   const uint          _cnt;              // Count of fields
 676   const Type ** const _fields;           // Array of field types
 677 
 678 public:
 679   virtual bool eq( const Type *t ) const;
 680   virtual int  hash() const;             // Type specific hashing
 681   virtual bool singleton(void) const;    // TRUE if type is a singleton
 682   virtual bool empty(void) const;        // TRUE if type is vacuous
 683 
 684   // Accessors:
 685   uint cnt() const { return _cnt; }
 686   const Type* field_at(uint i) const {
 687     assert(i &lt; _cnt, &quot;oob&quot;);
 688     return _fields[i];
 689   }
 690   void set_field_at(uint i, const Type* t) {
 691     assert(i &lt; _cnt, &quot;oob&quot;);
 692     _fields[i] = t;
 693   }
 694 
 695   static const TypeTuple *make( uint cnt, const Type **fields );
 696   static const TypeTuple *make_range(ciSignature* sig, bool ret_vt_fields = false);
 697   static const TypeTuple *make_domain(ciMethod* method, bool vt_fields_as_args = false);
 698 
 699   // Subroutine call type with space allocated for argument types
 700   // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
 701   static const Type **fields( uint arg_cnt );
 702 
 703   virtual const Type *xmeet( const Type *t ) const;
 704   virtual const Type *xdual() const;    // Compute dual right now.
 705   // Convenience common pre-built types.
 706   static const TypeTuple *IFBOTH;
 707   static const TypeTuple *IFFALSE;
 708   static const TypeTuple *IFTRUE;
 709   static const TypeTuple *IFNEITHER;
 710   static const TypeTuple *LOOPBODY;
 711   static const TypeTuple *MEMBAR;
 712   static const TypeTuple *STORECONDITIONAL;
 713   static const TypeTuple *START_I2C;
 714   static const TypeTuple *INT_PAIR;
 715   static const TypeTuple *LONG_PAIR;
 716   static const TypeTuple *INT_CC_PAIR;
 717   static const TypeTuple *LONG_CC_PAIR;
 718 #ifndef PRODUCT
 719   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 720 #endif
 721 };
 722 
 723 //------------------------------TypeAry----------------------------------------
 724 // Class of Array Types
 725 class TypeAry : public Type {
 726   TypeAry(const Type* elem, const TypeInt* size, bool stable, bool not_flat, bool not_null_free) : Type(Array),
 727       _elem(elem), _size(size), _stable(stable), _not_flat(not_flat), _not_null_free(not_null_free) {}
 728 public:
 729   virtual bool eq( const Type *t ) const;
 730   virtual int  hash() const;             // Type specific hashing
 731   virtual bool singleton(void) const;    // TRUE if type is a singleton
 732   virtual bool empty(void) const;        // TRUE if type is vacuous
 733 
 734 private:
 735   const Type *_elem;            // Element type of array
 736   const TypeInt *_size;         // Elements in array
 737   const bool _stable;           // Are elements @Stable?
 738 
 739   // Value type array properties
 740   const bool _not_flat;         // Array is never flattened
 741   const bool _not_null_free;    // Array is never null-free
 742 
 743   friend class TypeAryPtr;
 744 
 745 public:
 746   static const TypeAry* make(const Type* elem, const TypeInt* size, bool stable = false,
 747                              bool not_flat = false, bool not_null_free = false);
 748 
 749   virtual const Type *xmeet( const Type *t ) const;
 750   virtual const Type *xdual() const;    // Compute dual right now.
 751   bool ary_must_be_exact() const;  // true if arrays of such are never generic
 752   virtual const Type* remove_speculative() const;
 753   virtual const Type* cleanup_speculative() const;
 754 
 755 #ifdef ASSERT
 756   // One type is interface, the other is oop
 757   virtual bool interface_vs_oop(const Type *t) const;
 758 #endif
 759 #ifndef PRODUCT
 760   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 761 #endif
 762 };
 763 
 764 
 765 //------------------------------TypeValue---------------------------------------
 766 // Class of Value Type Types
 767 class TypeValueType : public Type {
 768 private:
 769   ciValueKlass* _vk;
 770   bool _larval;
 771 
 772 protected:
 773   TypeValueType(ciValueKlass* vk, bool larval)
 774     : Type(ValueType),
 775       _vk(vk), _larval(larval) {
 776   }
 777 
 778 public:
 779   static const TypeValueType* make(ciValueKlass* vk, bool larval = false);
 780   virtual ciValueKlass* value_klass() const { return _vk; }
 781   bool larval() const { return _larval; }
 782 
 783   virtual bool eq(const Type* t) const;
 784   virtual int  hash() const;             // Type specific hashing
 785   virtual bool singleton(void) const;    // TRUE if type is a singleton
 786   virtual bool empty(void) const;        // TRUE if type is vacuous
 787 
 788   virtual const Type* xmeet(const Type* t) const;
 789   virtual const Type* xdual() const;     // Compute dual right now.
 790 
 791   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return false; }
 792   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return false; }
 793 
 794   static const TypeValueType *BOTTOM;
 795 
 796 #ifndef PRODUCT
 797   virtual void dump2(Dict &amp;d, uint, outputStream* st) const; // Specialized per-Type dumping
 798 #endif
 799 };
 800 
 801 //------------------------------TypeVect---------------------------------------
 802 // Class of Vector Types
 803 class TypeVect : public Type {
 804   const Type*   _elem;  // Vector&#39;s element type
 805   const uint  _length;  // Elements in vector (power of 2)
 806 
 807 protected:
 808   TypeVect(TYPES t, const Type* elem, uint length) : Type(t),
 809     _elem(elem), _length(length) {}
 810 
 811 public:
 812   const Type* element_type() const { return _elem; }
 813   BasicType element_basic_type() const { return _elem-&gt;array_element_basic_type(); }
 814   uint length() const { return _length; }
 815   uint length_in_bytes() const {
 816    return _length * type2aelembytes(element_basic_type());
 817   }
 818 
 819   virtual bool eq(const Type *t) const;
 820   virtual int  hash() const;             // Type specific hashing
 821   virtual bool singleton(void) const;    // TRUE if type is a singleton
 822   virtual bool empty(void) const;        // TRUE if type is vacuous
 823 
 824   static const TypeVect *make(const BasicType elem_bt, uint length) {
 825     // Use bottom primitive type.
 826     return make(get_const_basic_type(elem_bt), length);
 827   }
 828   // Used directly by Replicate nodes to construct singleton vector.
 829   static const TypeVect *make(const Type* elem, uint length);
 830 
 831   virtual const Type *xmeet( const Type *t) const;
 832   virtual const Type *xdual() const;     // Compute dual right now.
 833 
 834   static const TypeVect *VECTS;
 835   static const TypeVect *VECTD;
 836   static const TypeVect *VECTX;
 837   static const TypeVect *VECTY;
 838   static const TypeVect *VECTZ;
 839 
 840 #ifndef PRODUCT
 841   virtual void dump2(Dict &amp;d, uint, outputStream *st) const; // Specialized per-Type dumping
 842 #endif
 843 };
 844 
 845 class TypeVectS : public TypeVect {
 846   friend class TypeVect;
 847   TypeVectS(const Type* elem, uint length) : TypeVect(VectorS, elem, length) {}
 848 };
 849 
 850 class TypeVectD : public TypeVect {
 851   friend class TypeVect;
 852   TypeVectD(const Type* elem, uint length) : TypeVect(VectorD, elem, length) {}
 853 };
 854 
 855 class TypeVectX : public TypeVect {
 856   friend class TypeVect;
 857   TypeVectX(const Type* elem, uint length) : TypeVect(VectorX, elem, length) {}
 858 };
 859 
 860 class TypeVectY : public TypeVect {
 861   friend class TypeVect;
 862   TypeVectY(const Type* elem, uint length) : TypeVect(VectorY, elem, length) {}
 863 };
 864 
 865 class TypeVectZ : public TypeVect {
 866   friend class TypeVect;
 867   TypeVectZ(const Type* elem, uint length) : TypeVect(VectorZ, elem, length) {}
 868 };
 869 
 870 //------------------------------TypePtr----------------------------------------
 871 // Class of machine Pointer Types: raw data, instances or arrays.
 872 // If the _base enum is AnyPtr, then this refers to all of the above.
 873 // Otherwise the _base will indicate which subset of pointers is affected,
 874 // and the class will be inherited from.
 875 class TypePtr : public Type {
 876   friend class TypeNarrowPtr;
 877 public:
 878   enum PTR { TopPTR, AnyNull, Constant, Null, NotNull, BotPTR, lastPTR };
 879 protected:
 880   TypePtr(TYPES t, PTR ptr, Offset offset,
 881           const TypePtr* speculative = NULL,
 882           int inline_depth = InlineDepthBottom) :
 883     Type(t), _speculative(speculative), _inline_depth(inline_depth), _offset(offset),
 884     _ptr(ptr) {}
 885   static const PTR ptr_meet[lastPTR][lastPTR];
 886   static const PTR ptr_dual[lastPTR];
 887   static const char * const ptr_msg[lastPTR];
 888 
 889   enum {
 890     InlineDepthBottom = INT_MAX,
 891     InlineDepthTop = -InlineDepthBottom
 892   };
 893 
 894   // Extra type information profiling gave us. We propagate it the
 895   // same way the rest of the type info is propagated. If we want to
 896   // use it, then we have to emit a guard: this part of the type is
 897   // not something we know but something we speculate about the type.
 898   const TypePtr*   _speculative;
 899   // For speculative types, we record at what inlining depth the
 900   // profiling point that provided the data is. We want to favor
 901   // profile data coming from outer scopes which are likely better for
 902   // the current compilation.
 903   int _inline_depth;
 904 
 905   // utility methods to work on the speculative part of the type
 906   const TypePtr* dual_speculative() const;
 907   const TypePtr* xmeet_speculative(const TypePtr* other) const;
 908   bool eq_speculative(const TypePtr* other) const;
 909   int hash_speculative() const;
 910   const TypePtr* add_offset_speculative(intptr_t offset) const;
 911 #ifndef PRODUCT
 912   void dump_speculative(outputStream *st) const;
 913 #endif
 914 
 915   // utility methods to work on the inline depth of the type
 916   int dual_inline_depth() const;
 917   int meet_inline_depth(int depth) const;
 918 #ifndef PRODUCT
 919   void dump_inline_depth(outputStream *st) const;
 920 #endif
 921 
 922 public:
 923   const Offset _offset;         // Offset into oop, with TOP &amp; BOT
 924   const PTR _ptr;               // Pointer equivalence class
 925 
 926   const int offset() const { return _offset.get(); }
 927   const PTR ptr()    const { return _ptr; }
 928 
 929   static const TypePtr* make(TYPES t, PTR ptr, Offset offset,
 930                              const TypePtr* speculative = NULL,
 931                              int inline_depth = InlineDepthBottom);
 932 
 933   // Return a &#39;ptr&#39; version of this type
 934   virtual const Type *cast_to_ptr_type(PTR ptr) const;
 935 
 936   virtual intptr_t get_con() const;
 937 
 938   Offset xadd_offset(intptr_t offset) const;
 939   virtual const TypePtr *add_offset( intptr_t offset ) const;
 940   virtual const int flattened_offset() const { return offset(); }
 941 
 942   virtual bool eq(const Type *t) const;
 943   virtual int  hash() const;             // Type specific hashing
 944 
 945   virtual bool singleton(void) const;    // TRUE if type is a singleton
 946   virtual bool empty(void) const;        // TRUE if type is vacuous
 947   virtual const Type *xmeet( const Type *t ) const;
 948   virtual const Type *xmeet_helper( const Type *t ) const;
 949   Offset meet_offset(int offset) const;
 950   Offset dual_offset() const;
 951   virtual const Type *xdual() const;    // Compute dual right now.
 952 
 953   // meet, dual and join over pointer equivalence sets
 954   PTR meet_ptr( const PTR in_ptr ) const { return ptr_meet[in_ptr][ptr()]; }
 955   PTR dual_ptr()                   const { return ptr_dual[ptr()];      }
 956 
 957   // This is textually confusing unless one recalls that
 958   // join(t) == dual()-&gt;meet(t-&gt;dual())-&gt;dual().
 959   PTR join_ptr( const PTR in_ptr ) const {
 960     return ptr_dual[ ptr_meet[ ptr_dual[in_ptr] ] [ dual_ptr() ] ];
 961   }
 962 
 963   // Speculative type helper methods.
 964   virtual const TypePtr* speculative() const { return _speculative; }
 965   int inline_depth() const                   { return _inline_depth; }
 966   virtual ciKlass* speculative_type() const;
 967   virtual ciKlass* speculative_type_not_null() const;
 968   virtual bool speculative_maybe_null() const;
 969   virtual bool speculative_always_null() const;
 970   virtual const Type* remove_speculative() const;
 971   virtual const Type* cleanup_speculative() const;
 972   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
 973   virtual bool would_improve_ptr(ProfilePtrKind maybe_null) const;
 974   virtual const TypePtr* with_inline_depth(int depth) const;
 975 
 976   virtual bool maybe_null() const { return meet_ptr(Null) == ptr(); }
 977 
 978   virtual bool can_be_value_type() const { return false; }
 979   virtual bool flat_array() const { return false; }
 980 
 981   // Tests for relation to centerline of type lattice:
 982   static bool above_centerline(PTR ptr) { return (ptr &lt;= AnyNull); }
 983   static bool below_centerline(PTR ptr) { return (ptr &gt;= NotNull); }
 984   // Convenience common pre-built types.
 985   static const TypePtr *NULL_PTR;
 986   static const TypePtr *NOTNULL;
 987   static const TypePtr *BOTTOM;
 988 #ifndef PRODUCT
 989   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
 990 #endif
 991 };
 992 
 993 //------------------------------TypeRawPtr-------------------------------------
 994 // Class of raw pointers, pointers to things other than Oops.  Examples
 995 // include the stack pointer, top of heap, card-marking area, handles, etc.
 996 class TypeRawPtr : public TypePtr {
 997 protected:
 998   TypeRawPtr(PTR ptr, address bits) : TypePtr(RawPtr,ptr,Offset(0)), _bits(bits){}
 999 public:
1000   virtual bool eq( const Type *t ) const;
1001   virtual int  hash() const;     // Type specific hashing
1002 
1003   const address _bits;          // Constant value, if applicable
1004 
1005   static const TypeRawPtr *make( PTR ptr );
1006   static const TypeRawPtr *make( address bits );
1007 
1008   // Return a &#39;ptr&#39; version of this type
1009   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1010 
1011   virtual intptr_t get_con() const;
1012 
1013   virtual const TypePtr *add_offset( intptr_t offset ) const;
1014 
1015   virtual const Type *xmeet( const Type *t ) const;
1016   virtual const Type *xdual() const;    // Compute dual right now.
1017   // Convenience common pre-built types.
1018   static const TypeRawPtr *BOTTOM;
1019   static const TypeRawPtr *NOTNULL;
1020 #ifndef PRODUCT
1021   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
1022 #endif
1023 };
1024 
1025 //------------------------------TypeOopPtr-------------------------------------
1026 // Some kind of oop (Java pointer), either instance or array.
1027 class TypeOopPtr : public TypePtr {
1028 protected:
1029   TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset, Offset field_offset,
1030              int instance_id, const TypePtr* speculative, int inline_depth);
1031 public:
1032   virtual bool eq( const Type *t ) const;
1033   virtual int  hash() const;             // Type specific hashing
1034   virtual bool singleton(void) const;    // TRUE if type is a singleton
1035   enum {
1036    InstanceTop = -1,   // undefined instance
1037    InstanceBot = 0     // any possible instance
1038   };
1039 protected:
1040 
1041   // Oop is NULL, unless this is a constant oop.
1042   ciObject*     _const_oop;   // Constant oop
1043   // If _klass is NULL, then so is _sig.  This is an unloaded klass.
1044   ciKlass*      _klass;       // Klass object
1045   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
1046   bool          _klass_is_exact;
1047   bool          _is_ptr_to_narrowoop;
1048   bool          _is_ptr_to_narrowklass;
1049   bool          _is_ptr_to_boxed_value;
1050 
1051   // If not InstanceTop or InstanceBot, indicates that this is
1052   // a particular instance of this type which is distinct.
1053   // This is the node index of the allocation node creating this instance.
1054   int           _instance_id;
1055 
1056   static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);
1057 
1058   int dual_instance_id() const;
1059   int meet_instance_id(int uid) const;
1060 
1061   // Do not allow interface-vs.-noninterface joins to collapse to top.
1062   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1063 
1064 public:
1065   // Creates a type given a klass. Correctly handles multi-dimensional arrays
1066   // Respects UseUniqueSubclasses.
1067   // If the klass is final, the resulting type will be exact.
1068   static const TypeOopPtr* make_from_klass(ciKlass* klass) {
1069     return make_from_klass_common(klass, true, false);
1070   }
1071   // Same as before, but will produce an exact type, even if
1072   // the klass is not final, as long as it has exactly one implementation.
1073   static const TypeOopPtr* make_from_klass_unique(ciKlass* klass) {
1074     return make_from_klass_common(klass, true, true);
1075   }
1076   // Same as before, but does not respects UseUniqueSubclasses.
1077   // Use this only for creating array element types.
1078   static const TypeOopPtr* make_from_klass_raw(ciKlass* klass) {
1079     return make_from_klass_common(klass, false, false);
1080   }
1081   // Creates a singleton type given an object.
1082   // If the object cannot be rendered as a constant,
1083   // may return a non-singleton type.
1084   // If require_constant, produce a NULL if a singleton is not possible.
1085   static const TypeOopPtr* make_from_constant(ciObject* o,
1086                                               bool require_constant = false);
1087 
1088   // Make a generic (unclassed) pointer to an oop.
1089   static const TypeOopPtr* make(PTR ptr, Offset offset, int instance_id,
1090                                 const TypePtr* speculative = NULL,
1091                                 int inline_depth = InlineDepthBottom);
1092 
1093   ciObject* const_oop()    const { return _const_oop; }
1094   virtual ciKlass* klass() const { return _klass;     }
1095   bool klass_is_exact()    const { return _klass_is_exact; }
1096 
1097   // Returns true if this pointer points at memory which contains a
1098   // compressed oop references.
1099   bool is_ptr_to_narrowoop_nv() const { return _is_ptr_to_narrowoop; }
1100   bool is_ptr_to_narrowklass_nv() const { return _is_ptr_to_narrowklass; }
1101   bool is_ptr_to_boxed_value()   const { return _is_ptr_to_boxed_value; }
1102   bool is_known_instance()       const { return _instance_id &gt; 0; }
1103   int  instance_id()             const { return _instance_id; }
1104   bool is_known_instance_field() const { return is_known_instance() &amp;&amp; _offset.get() &gt;= 0; }
1105 
1106   virtual bool can_be_value_type() const { return EnableValhalla &amp;&amp; (_klass == NULL || _klass-&gt;can_be_value_klass(_klass_is_exact)); }
1107 
1108   virtual intptr_t get_con() const;
1109 
1110   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1111 
1112   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1113 
1114   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1115 
1116   // corresponding pointer to klass, for a given instance
1117   const TypeKlassPtr* as_klass_type() const;
1118 
1119   virtual const TypePtr *add_offset( intptr_t offset ) const;
1120 
1121   // Speculative type helper methods.
1122   virtual const Type* remove_speculative() const;
1123   virtual const Type* cleanup_speculative() const;
1124   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
1125   virtual const TypePtr* with_inline_depth(int depth) const;
1126 
1127   virtual const TypePtr* with_instance_id(int instance_id) const;
1128 
1129   virtual const Type *xdual() const;    // Compute dual right now.
1130   // the core of the computation of the meet for TypeOopPtr and for its subclasses
1131   virtual const Type *xmeet_helper(const Type *t) const;
1132 
1133   // Convenience common pre-built type.
1134   static const TypeOopPtr *BOTTOM;
1135 #ifndef PRODUCT
1136   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1137 #endif
1138 };
1139 
1140 //------------------------------TypeInstPtr------------------------------------
1141 // Class of Java object pointers, pointing either to non-array Java instances
1142 // or to a Klass* (including array klasses).
1143 class TypeInstPtr : public TypeOopPtr {
1144   TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
1145               bool is_value, int instance_id, const TypePtr* speculative,
1146               int inline_depth);
1147   virtual bool eq( const Type *t ) const;
1148   virtual int  hash() const;             // Type specific hashing
1149 
1150   ciSymbol*  _name;        // class name
1151   bool _flat_array;
1152 
1153   bool meet_flat_array(bool other_flat_array) const {
1154     return (_flat_array &amp;&amp; other_flat_array) ? true : false;
1155   }
1156 
1157  public:
1158   ciSymbol* name()         const { return _name; }
1159 
1160   bool  is_loaded() const { return _klass-&gt;is_loaded(); }
1161 
1162   // Make a pointer to a constant oop.
1163   static const TypeInstPtr *make(ciObject* o) {
1164     return make(TypePtr::Constant, o-&gt;klass(), true, o, Offset(0), o-&gt;klass()-&gt;is_valuetype() &amp;&amp; o-&gt;klass()-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);
1165   }
1166   // Make a pointer to a constant oop with offset.
1167   static const TypeInstPtr* make(ciObject* o, Offset offset) {
1168     return make(TypePtr::Constant, o-&gt;klass(), true, o, offset, o-&gt;klass()-&gt;is_valuetype() &amp;&amp; o-&gt;klass()-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);
1169   }
1170 
1171   // Make a pointer to some value of type klass.
1172   static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {
1173     return make(ptr, klass, false, NULL, Offset(0), klass-&gt;is_valuetype() &amp;&amp; klass-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);
1174   }
1175 
1176   // Make a pointer to some non-polymorphic value of exactly type klass.
1177   static const TypeInstPtr *make_exact(PTR ptr, ciKlass* klass) {
1178     return make(ptr, klass, true, NULL, Offset(0), klass-&gt;is_valuetype() &amp;&amp; klass-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);
1179   }
1180 
1181   // Make a pointer to some value of type klass with offset.
1182   static const TypeInstPtr *make(PTR ptr, ciKlass* klass, Offset offset) {
1183     return make(ptr, klass, false, NULL, offset, klass-&gt;is_valuetype() &amp;&amp; klass-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);
1184   }
1185 
1186   // Make a pointer to an oop.
1187   static const TypeInstPtr* make(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
1188                                  bool flat_array,
1189                                  int instance_id = InstanceBot,
1190                                  const TypePtr* speculative = NULL,
1191                                  int inline_depth = InlineDepthBottom);
1192 
1193   /** Create constant type for a constant boxed value */
1194   const Type* get_const_boxed_value() const;
1195 
1196   // If this is a java.lang.Class constant, return the type for it or NULL.
1197   // Pass to Type::get_const_type to turn it to a type, which will usually
1198   // be a TypeInstPtr, but may also be a TypeInt::INT for int.class, etc.
1199   ciType* java_mirror_type(bool* is_indirect_type = NULL) const;
1200 
1201   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1202 
1203   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1204 
1205   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1206 
1207   virtual const TypePtr *add_offset( intptr_t offset ) const;
1208 
1209   // Speculative type helper methods.
1210   virtual const Type* remove_speculative() const;
1211   virtual const TypePtr* with_inline_depth(int depth) const;
1212   virtual const TypePtr* with_instance_id(int instance_id) const;
1213 
1214   virtual const TypeInstPtr* cast_to_flat_array() const;
1215   virtual bool flat_array() const {
1216     assert(!klass()-&gt;is_valuetype() || !klass()-&gt;as_value_klass()-&gt;flatten_array() || _flat_array, &quot;incorrect value bit&quot;);
1217     assert(!_flat_array || can_be_value_type(), &quot;incorrect value bit&quot;);
1218     return _flat_array;
1219   }
1220 
1221   // the core of the computation of the meet of 2 types
1222   virtual const Type *xmeet_helper(const Type *t) const;
1223   virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;
1224   virtual const Type *xdual() const;    // Compute dual right now.
1225 
1226   // Convenience common pre-built types.
1227   static const TypeInstPtr *NOTNULL;
1228   static const TypeInstPtr *BOTTOM;
1229   static const TypeInstPtr *MIRROR;
1230   static const TypeInstPtr *MARK;
1231   static const TypeInstPtr *KLASS;
1232 #ifndef PRODUCT
1233   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1234 #endif
1235 };
1236 
1237 //------------------------------TypeAryPtr-------------------------------------
1238 // Class of Java array pointers
1239 class TypeAryPtr : public TypeOopPtr {
1240   TypeAryPtr(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk,
1241              Offset offset, Offset field_offset, int instance_id, bool is_autobox_cache,
1242              const TypePtr* speculative, int inline_depth)
1243     : TypeOopPtr(AryPtr, ptr, k, xk, o, offset, field_offset, instance_id, speculative, inline_depth),
1244     _ary(ary),
1245     _is_autobox_cache(is_autobox_cache),
1246     _field_offset(field_offset)
1247  {
1248 #ifdef ASSERT
1249     if (k != NULL) {
1250       // Verify that specified klass and TypeAryPtr::klass() follow the same rules.
1251       ciKlass* ck = compute_klass(true);
1252       if (k != ck) {
1253         this-&gt;dump(); tty-&gt;cr();
1254         tty-&gt;print(&quot; k: &quot;);
1255         k-&gt;print(); tty-&gt;cr();
1256         tty-&gt;print(&quot;ck: &quot;);
1257         if (ck != NULL) ck-&gt;print();
1258         else tty-&gt;print(&quot;&lt;NULL&gt;&quot;);
1259         tty-&gt;cr();
1260         assert(false, &quot;unexpected TypeAryPtr::_klass&quot;);
1261       }
1262     }
1263 #endif
1264   }
1265   virtual bool eq( const Type *t ) const;
1266   virtual int hash() const;     // Type specific hashing
1267   const TypeAry *_ary;          // Array we point into
1268   const bool     _is_autobox_cache;
1269   // For flattened value type arrays, each field of the value type in
1270   // the array has its own memory slice so we need to keep track of
1271   // which field is accessed
1272   const Offset _field_offset;
1273   Offset meet_field_offset(const Type::Offset offset) const;
1274   Offset dual_field_offset() const;
1275 
1276   ciKlass* compute_klass(DEBUG_ONLY(bool verify = false)) const;
1277 
1278 public:
1279   // Accessors
1280   ciKlass* klass() const;
1281   const TypeAry* ary() const  { return _ary; }
1282   const Type*    elem() const { return _ary-&gt;_elem; }
1283   const TypeInt* size() const { return _ary-&gt;_size; }
1284   bool      is_stable() const { return _ary-&gt;_stable; }
1285 
1286   // Value type array properties
1287   bool is_not_flat()      const { return _ary-&gt;_not_flat; }
1288   bool is_not_null_free() const { return _ary-&gt;_not_null_free; }
1289 
1290   bool is_autobox_cache() const { return _is_autobox_cache; }
1291 
1292   static const TypeAryPtr* make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset,
1293                                 Offset field_offset = Offset::bottom,
1294                                 int instance_id = InstanceBot,
1295                                 const TypePtr* speculative = NULL,
1296                                 int inline_depth = InlineDepthBottom);
1297   // Constant pointer to array
1298   static const TypeAryPtr* make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, Offset offset,
1299                                 Offset field_offset = Offset::bottom,
1300                                 int instance_id = InstanceBot,
1301                                 const TypePtr* speculative = NULL,
1302                                 int inline_depth = InlineDepthBottom,
1303                                 bool is_autobox_cache = false);
1304 
1305   // Return a &#39;ptr&#39; version of this type
1306   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1307 
1308   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1309 
1310   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1311 
1312   virtual const TypeAryPtr* cast_to_size(const TypeInt* size) const;
1313   virtual const TypeInt* narrow_size_type(const TypeInt* size) const;
1314 
1315   virtual bool empty(void) const;        // TRUE if type is vacuous
1316   virtual const TypePtr *add_offset( intptr_t offset ) const;
1317 
1318   // Speculative type helper methods.
1319   virtual const Type* remove_speculative() const;
1320   virtual const Type* cleanup_speculative() const;
1321   virtual const TypePtr* with_inline_depth(int depth) const;
1322   virtual const TypePtr* with_instance_id(int instance_id) const;
1323 
1324   // the core of the computation of the meet of 2 types
1325   virtual const Type *xmeet_helper(const Type *t) const;
1326   virtual const Type *xdual() const;    // Compute dual right now.
1327 
1328   const TypeAryPtr* cast_to_not_flat(bool not_flat = true) const;
1329   const TypeAryPtr* cast_to_not_null_free(bool not_null_free = true) const;
1330 
1331   const TypeAryPtr* cast_to_stable(bool stable, int stable_dimension = 1) const;
1332   int stable_dimension() const;
1333 
1334   const TypeAryPtr* cast_to_autobox_cache(bool cache) const;
1335 
1336   static jint max_array_length(BasicType etype);
1337 
1338   const int flattened_offset() const;
1339   const Offset field_offset() const { return _field_offset; }
1340   const TypeAryPtr* with_field_offset(int offset) const;
1341   const TypePtr* add_field_offset_and_offset(intptr_t offset) const;
1342 
1343   virtual bool can_be_value_type() const { return false; }
1344 
1345   // Convenience common pre-built types.
1346   static const TypeAryPtr *RANGE;
1347   static const TypeAryPtr *OOPS;
1348   static const TypeAryPtr *NARROWOOPS;
1349   static const TypeAryPtr *BYTES;
1350   static const TypeAryPtr *SHORTS;
1351   static const TypeAryPtr *CHARS;
1352   static const TypeAryPtr *INTS;
1353   static const TypeAryPtr *LONGS;
1354   static const TypeAryPtr *FLOATS;
1355   static const TypeAryPtr *DOUBLES;
1356   static const TypeAryPtr *VALUES;
1357   // selects one of the above:
1358   static const TypeAryPtr *get_array_body_type(BasicType elem) {
1359     assert((uint)elem &lt;= T_CONFLICT &amp;&amp; _array_body_type[elem] != NULL, &quot;bad elem type&quot;);
1360     return _array_body_type[elem];
1361   }
1362   static const TypeAryPtr *_array_body_type[T_CONFLICT+1];
1363   // sharpen the type of an int which is used as an array size
1364 #ifdef ASSERT
1365   // One type is interface, the other is oop
1366   virtual bool interface_vs_oop(const Type *t) const;
1367 #endif
1368 #ifndef PRODUCT
1369   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1370 #endif
1371 };
1372 
1373 //------------------------------TypeMetadataPtr-------------------------------------
1374 // Some kind of metadata, either Method*, MethodData* or CPCacheOop
1375 class TypeMetadataPtr : public TypePtr {
1376 protected:
1377   TypeMetadataPtr(PTR ptr, ciMetadata* metadata, Offset offset);
1378   // Do not allow interface-vs.-noninterface joins to collapse to top.
1379   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1380 public:
1381   virtual bool eq( const Type *t ) const;
1382   virtual int  hash() const;             // Type specific hashing
1383   virtual bool singleton(void) const;    // TRUE if type is a singleton
1384 
1385 private:
1386   ciMetadata*   _metadata;
1387 
1388 public:
1389   static const TypeMetadataPtr* make(PTR ptr, ciMetadata* m, Offset offset);
1390 
1391   static const TypeMetadataPtr* make(ciMethod* m);
1392   static const TypeMetadataPtr* make(ciMethodData* m);
1393 
1394   ciMetadata* metadata() const { return _metadata; }
1395 
1396   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1397 
1398   virtual const TypePtr *add_offset( intptr_t offset ) const;
1399 
1400   virtual const Type *xmeet( const Type *t ) const;
1401   virtual const Type *xdual() const;    // Compute dual right now.
1402 
1403   virtual intptr_t get_con() const;
1404 
1405   // Convenience common pre-built types.
1406   static const TypeMetadataPtr *BOTTOM;
1407 
1408 #ifndef PRODUCT
1409   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1410 #endif
1411 };
1412 
1413 //------------------------------TypeKlassPtr-----------------------------------
1414 // Class of Java Klass pointers
1415 class TypeKlassPtr : public TypePtr {
1416   TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array);
1417 
1418 protected:
1419   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1420  public:
1421   virtual bool eq( const Type *t ) const;
1422   virtual int hash() const;             // Type specific hashing
1423   virtual bool singleton(void) const;    // TRUE if type is a singleton
1424  private:
1425 
1426   ciKlass* _klass;
1427 
1428   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
1429   bool          _klass_is_exact;
1430   bool _flat_array;
1431 
1432 public:
1433   ciKlass* klass() const { return  _klass; }
1434   bool klass_is_exact()    const { return _klass_is_exact; }
1435 
1436   virtual bool can_be_value_type() const { return EnableValhalla &amp;&amp; (_klass == NULL || _klass-&gt;can_be_value_klass(_klass_is_exact)); }
1437   virtual bool flat_array() const {
1438     assert(!klass()-&gt;is_valuetype() || !klass()-&gt;as_value_klass()-&gt;flatten_array() || _flat_array, &quot;incorrect value bit&quot;);
1439     assert(!_flat_array || can_be_value_type(), &quot;incorrect value bit&quot;);
1440     return _flat_array;
1441   }
1442 
1443   bool  is_loaded() const { return klass() != NULL &amp;&amp; klass()-&gt;is_loaded(); }
1444 
1445   // ptr to klass &#39;k&#39;
1446   static const TypeKlassPtr* make(ciKlass* k) { return make( TypePtr::Constant, k, Offset(0), k-&gt;is_valuetype() &amp;&amp; k-&gt;as_value_klass()-&gt;flatten_array()); }
1447   // ptr to klass &#39;k&#39; with offset
1448   static const TypeKlassPtr* make(ciKlass* k, Offset offset) { return make( TypePtr::Constant, k, offset, k-&gt;is_valuetype() &amp;&amp; k-&gt;as_value_klass()-&gt;flatten_array()); }
1449   // ptr to klass &#39;k&#39; or sub-klass
1450   static const TypeKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, bool flat_array);
1451 
1452   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1453 
1454   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1455 
1456   // corresponding pointer to instance, for a given class
1457   const TypeOopPtr* as_instance_type() const;
1458 
1459   virtual const TypePtr *add_offset( intptr_t offset ) const;
1460   virtual const Type    *xmeet( const Type *t ) const;
1461   virtual const Type    *xdual() const;      // Compute dual right now.
1462 
1463   virtual intptr_t get_con() const;
1464 
1465   // Convenience common pre-built types.
1466   static const TypeKlassPtr* OBJECT; // Not-null object klass or below
1467   static const TypeKlassPtr* OBJECT_OR_NULL; // Maybe-null version of same
1468 #ifndef PRODUCT
1469   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1470 #endif
1471 };
1472 
1473 class TypeNarrowPtr : public Type {
1474 protected:
1475   const TypePtr* _ptrtype; // Could be TypePtr::NULL_PTR
1476 
1477   TypeNarrowPtr(TYPES t, const TypePtr* ptrtype): Type(t),
1478                                                   _ptrtype(ptrtype) {
1479     assert(ptrtype-&gt;offset() == 0 ||
1480            ptrtype-&gt;offset() == OffsetBot ||
1481            ptrtype-&gt;offset() == OffsetTop, &quot;no real offsets&quot;);
1482   }
1483 
1484   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const = 0;
1485   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const = 0;
1486   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const = 0;
1487   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const = 0;
1488   // Do not allow interface-vs.-noninterface joins to collapse to top.
1489   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1490 public:
1491   virtual bool eq( const Type *t ) const;
1492   virtual int  hash() const;             // Type specific hashing
1493   virtual bool singleton(void) const;    // TRUE if type is a singleton
1494 
1495   virtual const Type *xmeet( const Type *t ) const;
1496   virtual const Type *xdual() const;    // Compute dual right now.
1497 
1498   virtual intptr_t get_con() const;
1499 
1500   virtual bool empty(void) const;        // TRUE if type is vacuous
1501 
1502   // returns the equivalent ptr type for this compressed pointer
1503   const TypePtr *get_ptrtype() const {
1504     return _ptrtype;
1505   }
1506 
1507   bool is_known_instance() const {
1508     return _ptrtype-&gt;is_known_instance();
1509   }
1510 
1511 #ifndef PRODUCT
1512   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1513 #endif
1514 };
1515 
1516 //------------------------------TypeNarrowOop----------------------------------
1517 // A compressed reference to some kind of Oop.  This type wraps around
1518 // a preexisting TypeOopPtr and forwards most of it&#39;s operations to
1519 // the underlying type.  It&#39;s only real purpose is to track the
1520 // oopness of the compressed oop value when we expose the conversion
1521 // between the normal and the compressed form.
1522 class TypeNarrowOop : public TypeNarrowPtr {
1523 protected:
1524   TypeNarrowOop( const TypePtr* ptrtype): TypeNarrowPtr(NarrowOop, ptrtype) {
1525   }
1526 
1527   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1528     return t-&gt;isa_narrowoop();
1529   }
1530 
1531   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const {
1532     return t-&gt;is_narrowoop();
1533   }
1534 
1535   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const {
1536     return new TypeNarrowOop(t);
1537   }
1538 
1539   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const {
1540     return (const TypeNarrowPtr*)((new TypeNarrowOop(t))-&gt;hashcons());
1541   }
1542 
1543 public:
1544 
1545   static const TypeNarrowOop *make( const TypePtr* type);
1546 
1547   static const TypeNarrowOop* make_from_constant(ciObject* con, bool require_constant = false) {
1548     return make(TypeOopPtr::make_from_constant(con, require_constant));
1549   }
1550 
1551   static const TypeNarrowOop *BOTTOM;
1552   static const TypeNarrowOop *NULL_PTR;
1553 
1554   virtual const Type* remove_speculative() const;
1555   virtual const Type* cleanup_speculative() const;
1556 
1557 #ifndef PRODUCT
1558   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1559 #endif
1560 };
1561 
1562 //------------------------------TypeNarrowKlass----------------------------------
1563 // A compressed reference to klass pointer.  This type wraps around a
1564 // preexisting TypeKlassPtr and forwards most of it&#39;s operations to
1565 // the underlying type.
1566 class TypeNarrowKlass : public TypeNarrowPtr {
1567 protected:
1568   TypeNarrowKlass( const TypePtr* ptrtype): TypeNarrowPtr(NarrowKlass, ptrtype) {
1569   }
1570 
1571   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1572     return t-&gt;isa_narrowklass();
1573   }
1574 
1575   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const {
1576     return t-&gt;is_narrowklass();
1577   }
1578 
1579   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const {
1580     return new TypeNarrowKlass(t);
1581   }
1582 
1583   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const {
1584     return (const TypeNarrowPtr*)((new TypeNarrowKlass(t))-&gt;hashcons());
1585   }
1586 
1587 public:
1588   static const TypeNarrowKlass *make( const TypePtr* type);
1589 
1590   // static const TypeNarrowKlass *BOTTOM;
1591   static const TypeNarrowKlass *NULL_PTR;
1592 
1593 #ifndef PRODUCT
1594   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1595 #endif
1596 };
1597 
1598 //------------------------------TypeFunc---------------------------------------
1599 // Class of Array Types
1600 class TypeFunc : public Type {
1601   TypeFunc(const TypeTuple *domain_sig, const TypeTuple *domain_cc, const TypeTuple *range_sig, const TypeTuple *range_cc)
1602     : Type(Function), _domain_sig(domain_sig), _domain_cc(domain_cc), _range_sig(range_sig), _range_cc(range_cc) {}
1603   virtual bool eq( const Type *t ) const;
1604   virtual int  hash() const;             // Type specific hashing
1605   virtual bool singleton(void) const;    // TRUE if type is a singleton
1606   virtual bool empty(void) const;        // TRUE if type is vacuous
1607 
1608   // Domains of inputs: value type arguments are not passed by
1609   // reference, instead each field of the value type is passed as an
1610   // argument. We maintain 2 views of the argument list here: one
1611   // based on the signature (with a value type argument as a single
1612   // slot), one based on the actual calling convention (with a value
1613   // type argument as a list of its fields).
1614   const TypeTuple* const _domain_sig;
1615   const TypeTuple* const _domain_cc;
1616   // Range of results. Similar to domains: a value type result can be
1617   // returned in registers in which case range_cc lists all fields and
1618   // is the actual calling convention.
1619   const TypeTuple* const _range_sig;
1620   const TypeTuple* const _range_cc;
1621 
1622 public:
1623   // Constants are shared among ADLC and VM
1624   enum { Control    = AdlcVMDeps::Control,
1625          I_O        = AdlcVMDeps::I_O,
1626          Memory     = AdlcVMDeps::Memory,
1627          FramePtr   = AdlcVMDeps::FramePtr,
1628          ReturnAdr  = AdlcVMDeps::ReturnAdr,
1629          Parms      = AdlcVMDeps::Parms
1630   };
1631 
1632 
1633   // Accessors:
1634   const TypeTuple* domain_sig() const { return _domain_sig; }
1635   const TypeTuple* domain_cc()  const { return _domain_cc; }
1636   const TypeTuple* range_sig()  const { return _range_sig; }
1637   const TypeTuple* range_cc()   const { return _range_cc; }
1638 
1639   static const TypeFunc* make(ciMethod* method, bool is_osr_compilation = false);
1640   static const TypeFunc *make(const TypeTuple* domain_sig, const TypeTuple* domain_cc,
1641                               const TypeTuple* range_sig, const TypeTuple* range_cc);
1642   static const TypeFunc *make(const TypeTuple* domain, const TypeTuple* range);
1643 
1644   virtual const Type *xmeet( const Type *t ) const;
1645   virtual const Type *xdual() const;    // Compute dual right now.
1646 
1647   BasicType return_type() const;
1648 
1649   bool returns_value_type_as_fields() const { return range_sig() != range_cc(); }
1650 
1651 #ifndef PRODUCT
1652   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1653 #endif
1654   // Convenience common pre-built types.
1655 };
1656 
1657 //------------------------------accessors--------------------------------------
1658 inline bool Type::is_ptr_to_narrowoop() const {
1659 #ifdef _LP64
1660   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowoop_nv());
1661 #else
1662   return false;
1663 #endif
1664 }
1665 
1666 inline bool Type::is_ptr_to_narrowklass() const {
1667 #ifdef _LP64
1668   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowklass_nv());
1669 #else
1670   return false;
1671 #endif
1672 }
1673 
1674 inline float Type::getf() const {
1675   assert( _base == FloatCon, &quot;Not a FloatCon&quot; );
1676   return ((TypeF*)this)-&gt;_f;
1677 }
1678 
1679 inline double Type::getd() const {
1680   assert( _base == DoubleCon, &quot;Not a DoubleCon&quot; );
1681   return ((TypeD*)this)-&gt;_d;
1682 }
1683 
1684 inline const TypeInt *Type::is_int() const {
1685   assert( _base == Int, &quot;Not an Int&quot; );
1686   return (TypeInt*)this;
1687 }
1688 
1689 inline const TypeInt *Type::isa_int() const {
1690   return ( _base == Int ? (TypeInt*)this : NULL);
1691 }
1692 
1693 inline const TypeLong *Type::is_long() const {
1694   assert( _base == Long, &quot;Not a Long&quot; );
1695   return (TypeLong*)this;
1696 }
1697 
1698 inline const TypeLong *Type::isa_long() const {
1699   return ( _base == Long ? (TypeLong*)this : NULL);
1700 }
1701 
1702 inline const TypeF *Type::isa_float() const {
1703   return ((_base == FloatTop ||
1704            _base == FloatCon ||
1705            _base == FloatBot) ? (TypeF*)this : NULL);
1706 }
1707 
1708 inline const TypeF *Type::is_float_constant() const {
1709   assert( _base == FloatCon, &quot;Not a Float&quot; );
1710   return (TypeF*)this;
1711 }
1712 
1713 inline const TypeF *Type::isa_float_constant() const {
1714   return ( _base == FloatCon ? (TypeF*)this : NULL);
1715 }
1716 
1717 inline const TypeD *Type::isa_double() const {
1718   return ((_base == DoubleTop ||
1719            _base == DoubleCon ||
1720            _base == DoubleBot) ? (TypeD*)this : NULL);
1721 }
1722 
1723 inline const TypeD *Type::is_double_constant() const {
1724   assert( _base == DoubleCon, &quot;Not a Double&quot; );
1725   return (TypeD*)this;
1726 }
1727 
1728 inline const TypeD *Type::isa_double_constant() const {
1729   return ( _base == DoubleCon ? (TypeD*)this : NULL);
1730 }
1731 
1732 inline const TypeTuple *Type::is_tuple() const {
1733   assert( _base == Tuple, &quot;Not a Tuple&quot; );
1734   return (TypeTuple*)this;
1735 }
1736 
1737 inline const TypeAry *Type::is_ary() const {
1738   assert( _base == Array , &quot;Not an Array&quot; );
1739   return (TypeAry*)this;
1740 }
1741 
1742 inline const TypeAry *Type::isa_ary() const {
1743   return ((_base == Array) ? (TypeAry*)this : NULL);
1744 }
1745 
1746 inline const TypeVect *Type::is_vect() const {
1747   assert( _base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ, &quot;Not a Vector&quot; );
1748   return (TypeVect*)this;
1749 }
1750 
1751 inline const TypeVect *Type::isa_vect() const {
1752   return (_base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ) ? (TypeVect*)this : NULL;
1753 }
1754 
1755 inline const TypePtr *Type::is_ptr() const {
1756   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1757   assert(_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr, &quot;Not a pointer&quot;);
1758   return (TypePtr*)this;
1759 }
1760 
1761 inline const TypePtr *Type::isa_ptr() const {
1762   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1763   return (_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr) ? (TypePtr*)this : NULL;
1764 }
1765 
1766 inline const TypeOopPtr *Type::is_oopptr() const {
1767   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1768   assert(_base &gt;= OopPtr &amp;&amp; _base &lt;= AryPtr, &quot;Not a Java pointer&quot; ) ;
1769   return (TypeOopPtr*)this;
1770 }
1771 
1772 inline const TypeOopPtr *Type::isa_oopptr() const {
1773   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1774   return (_base &gt;= OopPtr &amp;&amp; _base &lt;= AryPtr) ? (TypeOopPtr*)this : NULL;
1775 }
1776 
1777 inline const TypeRawPtr *Type::isa_rawptr() const {
1778   return (_base == RawPtr) ? (TypeRawPtr*)this : NULL;
1779 }
1780 
1781 inline const TypeRawPtr *Type::is_rawptr() const {
1782   assert( _base == RawPtr, &quot;Not a raw pointer&quot; );
1783   return (TypeRawPtr*)this;
1784 }
1785 
1786 inline const TypeInstPtr *Type::isa_instptr() const {
1787   return (_base == InstPtr) ? (TypeInstPtr*)this : NULL;
1788 }
1789 
1790 inline const TypeInstPtr *Type::is_instptr() const {
1791   assert( _base == InstPtr, &quot;Not an object pointer&quot; );
1792   return (TypeInstPtr*)this;
1793 }
1794 
1795 inline const TypeAryPtr *Type::isa_aryptr() const {
1796   return (_base == AryPtr) ? (TypeAryPtr*)this : NULL;
1797 }
1798 
1799 inline const TypeAryPtr *Type::is_aryptr() const {
1800   assert( _base == AryPtr, &quot;Not an array pointer&quot; );
1801   return (TypeAryPtr*)this;
1802 }
1803 
1804 inline const TypeValueType* Type::isa_valuetype() const {
1805   return (_base == ValueType) ? (TypeValueType*)this : NULL;
1806 }
1807 
1808 inline const TypeValueType* Type::is_valuetype() const {
1809   assert(_base == ValueType, &quot;Not a value type&quot;);
1810   return (TypeValueType*)this;
1811 }
1812 
1813 inline const TypeNarrowOop *Type::is_narrowoop() const {
1814   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1815   assert(_base == NarrowOop, &quot;Not a narrow oop&quot; ) ;
1816   return (TypeNarrowOop*)this;
1817 }
1818 
1819 inline const TypeNarrowOop *Type::isa_narrowoop() const {
1820   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1821   return (_base == NarrowOop) ? (TypeNarrowOop*)this : NULL;
1822 }
1823 
1824 inline const TypeNarrowKlass *Type::is_narrowklass() const {
1825   assert(_base == NarrowKlass, &quot;Not a narrow oop&quot; ) ;
1826   return (TypeNarrowKlass*)this;
1827 }
1828 
1829 inline const TypeNarrowKlass *Type::isa_narrowklass() const {
1830   return (_base == NarrowKlass) ? (TypeNarrowKlass*)this : NULL;
1831 }
1832 
1833 inline const TypeMetadataPtr *Type::is_metadataptr() const {
1834   // MetadataPtr is the first and CPCachePtr the last
1835   assert(_base == MetadataPtr, &quot;Not a metadata pointer&quot; ) ;
1836   return (TypeMetadataPtr*)this;
1837 }
1838 
1839 inline const TypeMetadataPtr *Type::isa_metadataptr() const {
1840   return (_base == MetadataPtr) ? (TypeMetadataPtr*)this : NULL;
1841 }
1842 
1843 inline const TypeKlassPtr *Type::isa_klassptr() const {
1844   return (_base == KlassPtr) ? (TypeKlassPtr*)this : NULL;
1845 }
1846 
1847 inline const TypeKlassPtr *Type::is_klassptr() const {
1848   assert( _base == KlassPtr, &quot;Not a klass pointer&quot; );
1849   return (TypeKlassPtr*)this;
1850 }
1851 
1852 inline const TypePtr* Type::make_ptr() const {
1853   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype() :
1854                               ((_base == NarrowKlass) ? is_narrowklass()-&gt;get_ptrtype() :
1855                                                        isa_ptr());
1856 }
1857 
1858 inline const TypeOopPtr* Type::make_oopptr() const {
1859   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype()-&gt;isa_oopptr() : isa_oopptr();
1860 }
1861 
1862 inline const TypeNarrowOop* Type::make_narrowoop() const {
1863   return (_base == NarrowOop) ? is_narrowoop() :
1864                                 (isa_ptr() ? TypeNarrowOop::make(is_ptr()) : NULL);
1865 }
1866 
1867 inline const TypeNarrowKlass* Type::make_narrowklass() const {
1868   return (_base == NarrowKlass) ? is_narrowklass() :
1869                                   (isa_ptr() ? TypeNarrowKlass::make(is_ptr()) : NULL);
1870 }
1871 
1872 inline bool Type::is_floatingpoint() const {
1873   if( (_base == FloatCon)  || (_base == FloatBot) ||
1874       (_base == DoubleCon) || (_base == DoubleBot) )
1875     return true;
1876   return false;
1877 }
1878 
1879 inline bool Type::is_valuetypeptr() const {
1880   return isa_instptr() != NULL &amp;&amp; is_instptr()-&gt;klass()-&gt;is_valuetype();
1881 }
1882 
1883 
1884 inline ciValueKlass* Type::value_klass() const {
1885   assert(is_valuetypeptr(), &quot;must be a value type ptr&quot;);
1886   return is_instptr()-&gt;klass()-&gt;as_value_klass();
1887 }
1888 
1889 
1890 // ===============================================================
1891 // Things that need to be 64-bits in the 64-bit build but
1892 // 32-bits in the 32-bit build.  Done this way to get full
1893 // optimization AND strong typing.
1894 #ifdef _LP64
1895 
1896 // For type queries and asserts
1897 #define is_intptr_t  is_long
1898 #define isa_intptr_t isa_long
1899 #define find_intptr_t_type find_long_type
1900 #define find_intptr_t_con  find_long_con
1901 #define TypeX        TypeLong
1902 #define Type_X       Type::Long
1903 #define TypeX_X      TypeLong::LONG
1904 #define TypeX_ZERO   TypeLong::ZERO
1905 // For &#39;ideal_reg&#39; machine registers
1906 #define Op_RegX      Op_RegL
1907 // For phase-&gt;intcon variants
1908 #define MakeConX     longcon
1909 #define ConXNode     ConLNode
1910 // For array index arithmetic
1911 #define MulXNode     MulLNode
1912 #define AndXNode     AndLNode
1913 #define OrXNode      OrLNode
1914 #define CmpXNode     CmpLNode
1915 #define CmpUXNode    CmpULNode
1916 #define SubXNode     SubLNode
1917 #define LShiftXNode  LShiftLNode
1918 // For object size computation:
1919 #define AddXNode     AddLNode
1920 #define RShiftXNode  RShiftLNode
1921 // For card marks and hashcodes
1922 #define URShiftXNode URShiftLNode
1923 // UseOptoBiasInlining
1924 #define XorXNode     XorLNode
1925 #define StoreXConditionalNode StoreLConditionalNode
1926 #define LoadXNode    LoadLNode
1927 #define StoreXNode   StoreLNode
1928 // Opcodes
1929 #define Op_LShiftX   Op_LShiftL
1930 #define Op_AndX      Op_AndL
1931 #define Op_AddX      Op_AddL
1932 #define Op_SubX      Op_SubL
1933 #define Op_XorX      Op_XorL
1934 #define Op_URShiftX  Op_URShiftL
1935 #define Op_LoadX     Op_LoadL
1936 #define Op_StoreX    Op_StoreL
1937 // conversions
1938 #define ConvI2X(x)   ConvI2L(x)
1939 #define ConvL2X(x)   (x)
1940 #define ConvX2I(x)   ConvL2I(x)
1941 #define ConvX2L(x)   (x)
1942 #define ConvX2UL(x)  (x)
1943 
1944 #else
1945 
1946 // For type queries and asserts
1947 #define is_intptr_t  is_int
1948 #define isa_intptr_t isa_int
1949 #define find_intptr_t_type find_int_type
1950 #define find_intptr_t_con  find_int_con
1951 #define TypeX        TypeInt
1952 #define Type_X       Type::Int
1953 #define TypeX_X      TypeInt::INT
1954 #define TypeX_ZERO   TypeInt::ZERO
1955 // For &#39;ideal_reg&#39; machine registers
1956 #define Op_RegX      Op_RegI
1957 // For phase-&gt;intcon variants
1958 #define MakeConX     intcon
1959 #define ConXNode     ConINode
1960 // For array index arithmetic
1961 #define MulXNode     MulINode
1962 #define AndXNode     AndINode
1963 #define OrXNode      OrINode
1964 #define CmpXNode     CmpINode
1965 #define CmpUXNode    CmpUNode
1966 #define SubXNode     SubINode
1967 #define LShiftXNode  LShiftINode
1968 // For object size computation:
1969 #define AddXNode     AddINode
1970 #define RShiftXNode  RShiftINode
1971 // For card marks and hashcodes
1972 #define URShiftXNode URShiftINode
1973 // UseOptoBiasInlining
1974 #define XorXNode     XorINode
1975 #define StoreXConditionalNode StoreIConditionalNode
1976 #define LoadXNode    LoadINode
1977 #define StoreXNode   StoreINode
1978 // Opcodes
1979 #define Op_LShiftX   Op_LShiftI
1980 #define Op_AndX      Op_AndI
1981 #define Op_AddX      Op_AddI
1982 #define Op_SubX      Op_SubI
1983 #define Op_XorX      Op_XorI
1984 #define Op_URShiftX  Op_URShiftI
1985 #define Op_LoadX     Op_LoadI
1986 #define Op_StoreX    Op_StoreI
1987 // conversions
1988 #define ConvI2X(x)   (x)
1989 #define ConvL2X(x)   ConvL2I(x)
1990 #define ConvX2I(x)   (x)
1991 #define ConvX2L(x)   ConvI2L(x)
1992 #define ConvX2UL(x)  ConvI2UL(x)
1993 
1994 #endif
1995 
1996 #endif // SHARE_OPTO_TYPE_HPP
    </pre>
  </body>
</html>
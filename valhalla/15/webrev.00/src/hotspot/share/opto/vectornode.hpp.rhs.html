<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/vectornode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_OPTO_VECTORNODE_HPP
 25 #define SHARE_OPTO_VECTORNODE_HPP
 26 
 27 #include &quot;opto/matcher.hpp&quot;
 28 #include &quot;opto/memnode.hpp&quot;
 29 #include &quot;opto/node.hpp&quot;
 30 #include &quot;opto/opcodes.hpp&quot;
 31 
 32 //------------------------------VectorNode-------------------------------------
 33 // Vector Operation
 34 class VectorNode : public TypeNode {
 35  public:
 36 
 37   VectorNode(Node* n1, const TypeVect* vt) : TypeNode(vt, 2) {
 38     init_class_id(Class_Vector);
 39     init_req(1, n1);
 40   }
 41   VectorNode(Node* n1, Node* n2, const TypeVect* vt) : TypeNode(vt, 3) {
 42     init_class_id(Class_Vector);
 43     init_req(1, n1);
 44     init_req(2, n2);
 45   }
 46 
 47   VectorNode(Node* n1, Node* n2, Node* n3, const TypeVect* vt) : TypeNode(vt, 4) {
 48     init_class_id(Class_Vector);
 49     init_req(1, n1);
 50     init_req(2, n2);
 51     init_req(3, n3);
 52   }
 53 
 54   const TypeVect* vect_type() const { return type()-&gt;is_vect(); }
 55   uint length() const { return vect_type()-&gt;length(); } // Vector length
 56   uint length_in_bytes() const { return vect_type()-&gt;length_in_bytes(); }
 57 
 58   virtual int Opcode() const;
 59 
 60   virtual uint ideal_reg() const { return Matcher::vector_ideal_reg(vect_type()-&gt;length_in_bytes()); }
 61 
 62   static VectorNode* scalar2vector(Node* s, uint vlen, const Type* opd_t);
 63   static VectorNode* shift_count(Node* shift, Node* cnt, uint vlen, BasicType bt);
 64   static VectorNode* make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt);
 65   static VectorNode* make(int opc, Node* n1, Node* n2, Node* n3, uint vlen, BasicType bt);
 66 
 67   static int  opcode(int opc, BasicType bt);
 68   static bool implemented(int opc, uint vlen, BasicType bt);
 69   static bool is_shift(Node* n);
 70   static bool is_type_transition_short_to_int(Node* n);
 71   static bool is_type_transition_to_int(Node* n);
 72   static bool is_muladds2i(Node* n);
 73   static bool is_roundopD(Node * n);
 74   static bool is_invariant_vector(Node* n);
 75   // [Start, end) half-open range defining which operands are vectors
 76   static void vector_operands(Node* n, uint* start, uint* end);
 77 
 78   static bool is_vector_shift(int opc);
 79   static bool is_vector_shift_count(int opc);
 80 
 81   static bool is_vector_shift(Node* n) {
 82     return is_vector_shift(n-&gt;Opcode());
 83   }
 84   static bool is_vector_shift_count(Node* n) {
 85     return is_vector_shift_count(n-&gt;Opcode());
 86   }
 87 };
 88 
 89 //===========================Vector=ALU=Operations=============================
 90 
 91 //------------------------------AddVBNode--------------------------------------
 92 // Vector add byte
 93 class AddVBNode : public VectorNode {
 94  public:
 95   AddVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 96   virtual int Opcode() const;
 97 };
 98 
 99 //------------------------------AddVSNode--------------------------------------
100 // Vector add char/short
101 class AddVSNode : public VectorNode {
102  public:
103   AddVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
104   virtual int Opcode() const;
105 };
106 
107 //------------------------------AddVINode--------------------------------------
108 // Vector add int
109 class AddVINode : public VectorNode {
110  public:
111   AddVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
112   virtual int Opcode() const;
113 };
114 
115 //------------------------------AddVLNode--------------------------------------
116 // Vector add long
117 class AddVLNode : public VectorNode {
118 public:
119   AddVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
120   virtual int Opcode() const;
121 };
122 
123 //------------------------------AddVFNode--------------------------------------
124 // Vector add float
125 class AddVFNode : public VectorNode {
126 public:
127   AddVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
128   virtual int Opcode() const;
129 };
130 
131 //------------------------------AddVDNode--------------------------------------
132 // Vector add double
133 class AddVDNode : public VectorNode {
134 public:
135   AddVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
136   virtual int Opcode() const;
137 };
138 
139 //------------------------------ReductionNode------------------------------------
140 // Perform reduction of a vector
141 class ReductionNode : public Node {
142  public:
143   ReductionNode(Node *ctrl, Node* in1, Node* in2) : Node(ctrl, in1, in2) {}
144 
145   static ReductionNode* make(int opc, Node *ctrl, Node* in1, Node* in2, BasicType bt);
146   static int  opcode(int opc, BasicType bt);
147   static bool implemented(int opc, uint vlen, BasicType bt);
<a name="1" id="anc1"></a><span class="line-added">148 </span>
<span class="line-added">149   virtual const Type* bottom_type() const {</span>
<span class="line-added">150     BasicType vbt = in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type();</span>
<span class="line-added">151     return Type::get_const_basic_type(vbt);</span>
<span class="line-added">152   }</span>
<span class="line-added">153 </span>
<span class="line-added">154   virtual uint ideal_reg() const {</span>
<span class="line-added">155     return bottom_type()-&gt;ideal_reg();</span>
<span class="line-added">156   }</span>
157 };
158 
159 //------------------------------AddReductionVINode--------------------------------------
160 // Vector add int as a reduction
161 class AddReductionVINode : public ReductionNode {
162 public:
163   AddReductionVINode(Node * ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
164   virtual int Opcode() const;
165   virtual const Type* bottom_type() const { return TypeInt::INT; }
166   virtual uint ideal_reg() const { return Op_RegI; }
167 };
168 
169 //------------------------------AddReductionVLNode--------------------------------------
170 // Vector add long as a reduction
171 class AddReductionVLNode : public ReductionNode {
172 public:
173   AddReductionVLNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
174   virtual int Opcode() const;
175   virtual const Type* bottom_type() const { return TypeLong::LONG; }
176   virtual uint ideal_reg() const { return Op_RegL; }
177 };
178 
179 //------------------------------AddReductionVFNode--------------------------------------
180 // Vector add float as a reduction
181 class AddReductionVFNode : public ReductionNode {
182 public:
183   AddReductionVFNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
184   virtual int Opcode() const;
185   virtual const Type* bottom_type() const { return Type::FLOAT; }
186   virtual uint ideal_reg() const { return Op_RegF; }
187 };
188 
189 //------------------------------AddReductionVDNode--------------------------------------
190 // Vector add double as a reduction
191 class AddReductionVDNode : public ReductionNode {
192 public:
193   AddReductionVDNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
194   virtual int Opcode() const;
195   virtual const Type* bottom_type() const { return Type::DOUBLE; }
196   virtual uint ideal_reg() const { return Op_RegD; }
197 };
198 
199 //------------------------------SubVBNode--------------------------------------
200 // Vector subtract byte
201 class SubVBNode : public VectorNode {
202  public:
203   SubVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
204   virtual int Opcode() const;
205 };
206 
207 //------------------------------SubVSNode--------------------------------------
208 // Vector subtract short
209 class SubVSNode : public VectorNode {
210  public:
211   SubVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
212   virtual int Opcode() const;
213 };
214 
215 //------------------------------SubVINode--------------------------------------
216 // Vector subtract int
217 class SubVINode : public VectorNode {
218  public:
219   SubVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
220   virtual int Opcode() const;
221 };
222 
223 //------------------------------SubVLNode--------------------------------------
224 // Vector subtract long
225 class SubVLNode : public VectorNode {
226  public:
227   SubVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
228   virtual int Opcode() const;
229 };
230 
231 //------------------------------SubVFNode--------------------------------------
232 // Vector subtract float
233 class SubVFNode : public VectorNode {
234  public:
235   SubVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
236   virtual int Opcode() const;
237 };
238 
239 //------------------------------SubVDNode--------------------------------------
240 // Vector subtract double
241 class SubVDNode : public VectorNode {
242  public:
243   SubVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
244   virtual int Opcode() const;
245 };
246 
247 //------------------------------MulVBNode--------------------------------------
248 // Vector multiply byte
249 class MulVBNode : public VectorNode {
250  public:
251   MulVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
252   virtual int Opcode() const;
253 };
254 
255 //------------------------------MulVSNode--------------------------------------
256 // Vector multiply short
257 class MulVSNode : public VectorNode {
258  public:
259   MulVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
260   virtual int Opcode() const;
261 };
262 
263 //------------------------------MulVINode--------------------------------------
264 // Vector multiply int
265 class MulVINode : public VectorNode {
266  public:
267   MulVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
268   virtual int Opcode() const;
269 };
270 
271 //------------------------------MulVLNode--------------------------------------
272 // Vector multiply long
273 class MulVLNode : public VectorNode {
274 public:
275   MulVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
276   virtual int Opcode() const;
277 };
278 
279 //------------------------------MulVFNode--------------------------------------
280 // Vector multiply float
281 class MulVFNode : public VectorNode {
282 public:
283   MulVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
284   virtual int Opcode() const;
285 };
286 
287 //------------------------------MulVDNode--------------------------------------
288 // Vector multiply double
289 class MulVDNode : public VectorNode {
290 public:
291   MulVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
292   virtual int Opcode() const;
293 };
294 
295 //------------------------------MulAddVS2VINode--------------------------------
296 // Vector multiply shorts to int and add adjacent ints.
297 class MulAddVS2VINode : public VectorNode {
298   public:
299     MulAddVS2VINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
300     virtual int Opcode() const;
301 };
302 
303 //------------------------------FmaVDNode--------------------------------------
304 // Vector multiply double
305 class FmaVDNode : public VectorNode {
306 public:
307   FmaVDNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
308   virtual int Opcode() const;
309 };
310 
311 //------------------------------FmaVFNode--------------------------------------
312 // Vector multiply float
313 class FmaVFNode : public VectorNode {
314 public:
315   FmaVFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
316   virtual int Opcode() const;
317 };
318 
319 //------------------------------CMoveVFNode--------------------------------------
320 // Vector float conditional move
321 class CMoveVFNode : public VectorNode {
322 public:
323   CMoveVFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
324   virtual int Opcode() const;
325 };
326 
327 //------------------------------CMoveVDNode--------------------------------------
328 // Vector double conditional move
329 class CMoveVDNode : public VectorNode {
330 public:
331   CMoveVDNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
332   virtual int Opcode() const;
333 };
334 
335 //------------------------------MulReductionVINode--------------------------------------
336 // Vector multiply int as a reduction
337 class MulReductionVINode : public ReductionNode {
338 public:
339   MulReductionVINode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
340   virtual int Opcode() const;
341   virtual const Type* bottom_type() const { return TypeInt::INT; }
342   virtual uint ideal_reg() const { return Op_RegI; }
343 };
344 
345 //------------------------------MulReductionVLNode--------------------------------------
346 // Vector multiply int as a reduction
347 class MulReductionVLNode : public ReductionNode {
348 public:
349   MulReductionVLNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
350   virtual int Opcode() const;
351   virtual const Type* bottom_type() const { return TypeLong::LONG; }
352   virtual uint ideal_reg() const { return Op_RegI; }
353 };
354 
355 //------------------------------MulReductionVFNode--------------------------------------
356 // Vector multiply float as a reduction
357 class MulReductionVFNode : public ReductionNode {
358 public:
359   MulReductionVFNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
360   virtual int Opcode() const;
361   virtual const Type* bottom_type() const { return Type::FLOAT; }
362   virtual uint ideal_reg() const { return Op_RegF; }
363 };
364 
365 //------------------------------MulReductionVDNode--------------------------------------
366 // Vector multiply double as a reduction
367 class MulReductionVDNode : public ReductionNode {
368 public:
369   MulReductionVDNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
370   virtual int Opcode() const;
371   virtual const Type* bottom_type() const { return Type::DOUBLE; }
372   virtual uint ideal_reg() const { return Op_RegD; }
373 };
374 
375 //------------------------------DivVFNode--------------------------------------
376 // Vector divide float
377 class DivVFNode : public VectorNode {
378  public:
379   DivVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
380   virtual int Opcode() const;
381 };
382 
383 //------------------------------DivVDNode--------------------------------------
384 // Vector Divide double
385 class DivVDNode : public VectorNode {
386  public:
387   DivVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
388   virtual int Opcode() const;
389 };
390 
391 //------------------------------AbsVBNode--------------------------------------
392 // Vector Abs byte
393 class AbsVBNode : public VectorNode {
394 public:
395   AbsVBNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}
396   virtual int Opcode() const;
397 };
398 
399 //------------------------------AbsVSNode--------------------------------------
400 // Vector Abs short
401 class AbsVSNode : public VectorNode {
402 public:
403   AbsVSNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}
404   virtual int Opcode() const;
405 };
406 
407 //------------------------------AbsVINode--------------------------------------
408 // Vector Abs int
409 class AbsVINode : public VectorNode {
410 public:
411   AbsVINode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}
412   virtual int Opcode() const;
413 };
414 
415 //------------------------------AbsVLNode--------------------------------------
416 // Vector Abs long
417 class AbsVLNode : public VectorNode {
418 public:
419   AbsVLNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}
420   virtual int Opcode() const;
421 };
422 
423 //------------------------------AbsVFNode--------------------------------------
424 // Vector Abs float
425 class AbsVFNode : public VectorNode {
426  public:
427   AbsVFNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
428   virtual int Opcode() const;
429 };
430 
431 //------------------------------AbsVDNode--------------------------------------
432 // Vector Abs double
433 class AbsVDNode : public VectorNode {
434  public:
435   AbsVDNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
436   virtual int Opcode() const;
437 };
438 
439 //------------------------------NegVFNode--------------------------------------
440 // Vector Neg float
441 class NegVFNode : public VectorNode {
442  public:
443   NegVFNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
444   virtual int Opcode() const;
445 };
446 
447 //------------------------------NegVDNode--------------------------------------
448 // Vector Neg double
449 class NegVDNode : public VectorNode {
450  public:
451   NegVDNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
452   virtual int Opcode() const;
453 };
454 
455 //------------------------------PopCountVINode---------------------------------
456 // Vector popcount integer bits
457 class PopCountVINode : public VectorNode {
458  public:
459   PopCountVINode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
460   virtual int Opcode() const;
461 };
462 
463 //------------------------------SqrtVFNode--------------------------------------
464 // Vector Sqrt float
465 class SqrtVFNode : public VectorNode {
466  public:
467   SqrtVFNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
468   virtual int Opcode() const;
469 };
470 //------------------------------RoundDoubleVNode--------------------------------
471 // Vector round double
472 class RoundDoubleModeVNode : public VectorNode {
473  public:
474   RoundDoubleModeVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
475   virtual int Opcode() const;
476 };
477 
478 //------------------------------SqrtVDNode--------------------------------------
479 // Vector Sqrt double
480 class SqrtVDNode : public VectorNode {
481  public:
482   SqrtVDNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
483   virtual int Opcode() const;
484 };
485 
486 //------------------------------LShiftVBNode-----------------------------------
487 // Vector left shift bytes
488 class LShiftVBNode : public VectorNode {
489  public:
490   LShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
491   virtual int Opcode() const;
492 };
493 
494 //------------------------------LShiftVSNode-----------------------------------
495 // Vector left shift shorts
496 class LShiftVSNode : public VectorNode {
497  public:
498   LShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
499   virtual int Opcode() const;
500 };
501 
502 //------------------------------LShiftVINode-----------------------------------
503 // Vector left shift ints
504 class LShiftVINode : public VectorNode {
505  public:
506   LShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
507   virtual int Opcode() const;
508 };
509 
510 //------------------------------LShiftVLNode-----------------------------------
511 // Vector left shift longs
512 class LShiftVLNode : public VectorNode {
513  public:
514   LShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
515   virtual int Opcode() const;
516 };
517 
518 //------------------------------RShiftVBNode-----------------------------------
519 // Vector right arithmetic (signed) shift bytes
520 class RShiftVBNode : public VectorNode {
521  public:
522   RShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
523   virtual int Opcode() const;
524 };
525 
526 //------------------------------RShiftVSNode-----------------------------------
527 // Vector right arithmetic (signed) shift shorts
528 class RShiftVSNode : public VectorNode {
529  public:
530   RShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
531   virtual int Opcode() const;
532 };
533 
534 //------------------------------RShiftVINode-----------------------------------
535 // Vector right arithmetic (signed) shift ints
536 class RShiftVINode : public VectorNode {
537  public:
538   RShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
539   virtual int Opcode() const;
540 };
541 
542 //------------------------------RShiftVLNode-----------------------------------
543 // Vector right arithmetic (signed) shift longs
544 class RShiftVLNode : public VectorNode {
545  public:
546   RShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
547   virtual int Opcode() const;
548 };
549 
550 //------------------------------URShiftVBNode----------------------------------
551 // Vector right logical (unsigned) shift bytes
552 class URShiftVBNode : public VectorNode {
553  public:
554   URShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
555   virtual int Opcode() const;
556 };
557 
558 //------------------------------URShiftVSNode----------------------------------
559 // Vector right logical (unsigned) shift shorts
560 class URShiftVSNode : public VectorNode {
561  public:
562   URShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
563   virtual int Opcode() const;
564 };
565 
566 //------------------------------URShiftVINode----------------------------------
567 // Vector right logical (unsigned) shift ints
568 class URShiftVINode : public VectorNode {
569  public:
570   URShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
571   virtual int Opcode() const;
572 };
573 
574 //------------------------------URShiftVLNode----------------------------------
575 // Vector right logical (unsigned) shift longs
576 class URShiftVLNode : public VectorNode {
577  public:
578   URShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
579   virtual int Opcode() const;
580 };
581 
582 //------------------------------LShiftCntVNode---------------------------------
583 // Vector left shift count
584 class LShiftCntVNode : public VectorNode {
585  public:
586   LShiftCntVNode(Node* cnt, const TypeVect* vt) : VectorNode(cnt,vt) {}
587   virtual int Opcode() const;
588   virtual uint ideal_reg() const { return Matcher::vector_shift_count_ideal_reg(vect_type()-&gt;length_in_bytes()); }
589 };
590 
591 //------------------------------RShiftCntVNode---------------------------------
592 // Vector right shift count
593 class RShiftCntVNode : public VectorNode {
594  public:
595   RShiftCntVNode(Node* cnt, const TypeVect* vt) : VectorNode(cnt,vt) {}
596   virtual int Opcode() const;
597   virtual uint ideal_reg() const { return Matcher::vector_shift_count_ideal_reg(vect_type()-&gt;length_in_bytes()); }
598 };
599 
600 
601 //------------------------------AndVNode---------------------------------------
602 // Vector and integer
603 class AndVNode : public VectorNode {
604  public:
605   AndVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
606   virtual int Opcode() const;
607 };
608 
609 //------------------------------OrVNode---------------------------------------
610 // Vector or integer
611 class OrVNode : public VectorNode {
612  public:
613   OrVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
614   virtual int Opcode() const;
615 };
616 
617 //------------------------------XorVNode---------------------------------------
618 // Vector xor integer
619 class XorVNode : public VectorNode {
620  public:
621   XorVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
622   virtual int Opcode() const;
623 };
624 
<a name="2" id="anc2"></a><span class="line-added">625 //------------------------------AndReductionVNode--------------------------------------</span>
<span class="line-added">626 // Vector and int, long as a reduction</span>
<span class="line-added">627 class AndReductionVNode : public ReductionNode {</span>
<span class="line-added">628 public:</span>
<span class="line-added">629   AndReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}</span>
<span class="line-added">630   virtual int Opcode() const;</span>
<span class="line-added">631 };</span>
<span class="line-added">632 </span>
<span class="line-added">633 //------------------------------OrReductionVNode--------------------------------------</span>
<span class="line-added">634 // Vector or int, long as a reduction</span>
<span class="line-added">635 class OrReductionVNode : public ReductionNode {</span>
<span class="line-added">636 public:</span>
<span class="line-added">637   OrReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}</span>
<span class="line-added">638   virtual int Opcode() const;</span>
<span class="line-added">639 };</span>
<span class="line-added">640 </span>
<span class="line-added">641 //------------------------------XorReductionVNode--------------------------------------</span>
<span class="line-added">642 // Vector xor int, long as a reduction</span>
<span class="line-added">643 class XorReductionVNode : public ReductionNode {</span>
<span class="line-added">644 public:</span>
<span class="line-added">645   XorReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}</span>
<span class="line-added">646   virtual int Opcode() const;</span>
<span class="line-added">647 };</span>
<span class="line-added">648 </span>
649 //------------------------------MinVNode--------------------------------------
650 // Vector min
651 class MinVNode : public VectorNode {
652 public:
653   MinVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
654   virtual int Opcode() const;
655 };
656 
657 //------------------------------MaxVNode--------------------------------------
658 // Vector max
659 class MaxVNode : public VectorNode {
660 public:
661   MaxVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
662   virtual int Opcode() const;
663 };
664 
665 //------------------------------MinReductionVNode--------------------------------------
666 // Vector min as a reduction
667 class MinReductionVNode : public ReductionNode {
668 public:
669   MinReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
670   virtual int Opcode() const;
<a name="3" id="anc3"></a>



















671 };
672 
673 //------------------------------MaxReductionVNode--------------------------------------
674 // Vector max as a reduction
675 class MaxReductionVNode : public ReductionNode {
676 public:
677   MaxReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
678   virtual int Opcode() const;
<a name="4" id="anc4"></a>



















679 };
680 
681 //================================= M E M O R Y ===============================
682 
683 //------------------------------LoadVectorNode---------------------------------
684 // Load Vector from memory
685 class LoadVectorNode : public LoadNode {
686  public:
687   LoadVectorNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, ControlDependency control_dependency = LoadNode::DependsOnlyOnTest)
688     : LoadNode(c, mem, adr, at, vt, MemNode::unordered, control_dependency) {
689     init_class_id(Class_LoadVector);
690     set_mismatched_access();
691   }
692 
693   const TypeVect* vect_type() const { return type()-&gt;is_vect(); }
694   uint length() const { return vect_type()-&gt;length(); } // Vector length
695 
696   virtual int Opcode() const;
697 
698   virtual uint ideal_reg() const  { return Matcher::vector_ideal_reg(memory_size()); }
699   virtual BasicType memory_type() const { return T_VOID; }
700   virtual int memory_size() const { return vect_type()-&gt;length_in_bytes(); }
701 
702   virtual int store_Opcode() const { return Op_StoreVector; }
703 
704   static LoadVectorNode* make(int opc, Node* ctl, Node* mem,
705                               Node* adr, const TypePtr* atyp,
706                               uint vlen, BasicType bt,
707                               ControlDependency control_dependency = LoadNode::DependsOnlyOnTest);
708   uint element_size(void) { return type2aelembytes(vect_type()-&gt;element_basic_type()); }
709 };
710 
711 //------------------------------StoreVectorNode--------------------------------
712 // Store Vector to memory
713 class StoreVectorNode : public StoreNode {
714  public:
715   StoreVectorNode(Node* c, Node* mem, Node* adr, const TypePtr* at, Node* val)
716     : StoreNode(c, mem, adr, at, val, MemNode::unordered) {
717     assert(val-&gt;is_Vector() || val-&gt;is_LoadVector(), &quot;sanity&quot;);
718     init_class_id(Class_StoreVector);
719     set_mismatched_access();
720   }
721 
722   const TypeVect* vect_type() const { return in(MemNode::ValueIn)-&gt;bottom_type()-&gt;is_vect(); }
723   uint length() const { return vect_type()-&gt;length(); } // Vector length
724 
725   virtual int Opcode() const;
726 
727   virtual uint ideal_reg() const  { return Matcher::vector_ideal_reg(memory_size()); }
728   virtual BasicType memory_type() const { return T_VOID; }
729   virtual int memory_size() const { return vect_type()-&gt;length_in_bytes(); }
730 
731   static StoreVectorNode* make(int opc, Node* ctl, Node* mem,
732                                Node* adr, const TypePtr* atyp, Node* val,
733                                uint vlen);
734 
735   uint element_size(void) { return type2aelembytes(vect_type()-&gt;element_basic_type()); }
736 };
737 
738 
739 //=========================Promote_Scalar_to_Vector============================
740 
741 //------------------------------ReplicateBNode---------------------------------
742 // Replicate byte scalar to be vector
743 class ReplicateBNode : public VectorNode {
744  public:
745   ReplicateBNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
746   virtual int Opcode() const;
747 };
748 
749 //------------------------------ReplicateSNode---------------------------------
750 // Replicate short scalar to be vector
751 class ReplicateSNode : public VectorNode {
752  public:
753   ReplicateSNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
754   virtual int Opcode() const;
755 };
756 
757 //------------------------------ReplicateINode---------------------------------
758 // Replicate int scalar to be vector
759 class ReplicateINode : public VectorNode {
760  public:
761   ReplicateINode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
762   virtual int Opcode() const;
763 };
764 
765 //------------------------------ReplicateLNode---------------------------------
766 // Replicate long scalar to be vector
767 class ReplicateLNode : public VectorNode {
768  public:
769   ReplicateLNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
770   virtual int Opcode() const;
771 };
772 
773 //------------------------------ReplicateFNode---------------------------------
774 // Replicate float scalar to be vector
775 class ReplicateFNode : public VectorNode {
776  public:
777   ReplicateFNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
778   virtual int Opcode() const;
779 };
780 
781 //------------------------------ReplicateDNode---------------------------------
782 // Replicate double scalar to be vector
783 class ReplicateDNode : public VectorNode {
784  public:
785   ReplicateDNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
786   virtual int Opcode() const;
787 };
788 
789 //========================Pack_Scalars_into_a_Vector===========================
790 
791 //------------------------------PackNode---------------------------------------
792 // Pack parent class (not for code generation).
793 class PackNode : public VectorNode {
794  public:
795   PackNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
796   PackNode(Node* in1, Node* n2, const TypeVect* vt) : VectorNode(in1, n2, vt) {}
797   virtual int Opcode() const;
798 
799   void add_opd(Node* n) {
800     add_req(n);
801   }
802 
803   // Create a binary tree form for Packs. [lo, hi) (half-open) range
804   PackNode* binary_tree_pack(int lo, int hi);
805 
806   static PackNode* make(Node* s, uint vlen, BasicType bt);
807 };
808 
809 //------------------------------PackBNode--------------------------------------
810 // Pack byte scalars into vector
811 class PackBNode : public PackNode {
812  public:
813   PackBNode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
814   virtual int Opcode() const;
815 };
816 
817 //------------------------------PackSNode--------------------------------------
818 // Pack short scalars into a vector
819 class PackSNode : public PackNode {
820  public:
821   PackSNode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
822   PackSNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
823   virtual int Opcode() const;
824 };
825 
826 //------------------------------PackINode--------------------------------------
827 // Pack integer scalars into a vector
828 class PackINode : public PackNode {
829  public:
830   PackINode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
831   PackINode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
832   virtual int Opcode() const;
833 };
834 
835 //------------------------------PackLNode--------------------------------------
836 // Pack long scalars into a vector
837 class PackLNode : public PackNode {
838  public:
839   PackLNode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
840   PackLNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
841   virtual int Opcode() const;
842 };
843 
844 //------------------------------Pack2LNode-------------------------------------
845 // Pack 2 long scalars into a vector
846 class Pack2LNode : public PackNode {
847  public:
848   Pack2LNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
849   virtual int Opcode() const;
850 };
851 
852 //------------------------------PackFNode--------------------------------------
853 // Pack float scalars into vector
854 class PackFNode : public PackNode {
855  public:
856   PackFNode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
857   PackFNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
858   virtual int Opcode() const;
859 };
860 
861 //------------------------------PackDNode--------------------------------------
862 // Pack double scalars into a vector
863 class PackDNode : public PackNode {
864  public:
865   PackDNode(Node* in1, const TypeVect* vt) : PackNode(in1, vt) {}
866   PackDNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
867   virtual int Opcode() const;
868 };
869 
870 //------------------------------Pack2DNode-------------------------------------
871 // Pack 2 double scalars into a vector
872 class Pack2DNode : public PackNode {
873  public:
874   Pack2DNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
875   virtual int Opcode() const;
876 };
877 
878 
879 //========================Extract_Scalar_from_Vector===========================
880 
881 //------------------------------ExtractNode------------------------------------
882 // Extract a scalar from a vector at position &quot;pos&quot;
883 class ExtractNode : public Node {
884  public:
885   ExtractNode(Node* src, ConINode* pos) : Node(NULL, src, (Node*)pos) {
886     assert(in(2)-&gt;get_int() &gt;= 0, &quot;positive constants&quot;);
887   }
888   virtual int Opcode() const;
889   uint  pos() const { return in(2)-&gt;get_int(); }
890 
891   static Node* make(Node* v, uint position, BasicType bt);
892 };
893 
894 //------------------------------ExtractBNode-----------------------------------
895 // Extract a byte from a vector at position &quot;pos&quot;
896 class ExtractBNode : public ExtractNode {
897  public:
898   ExtractBNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
899   virtual int Opcode() const;
900   virtual const Type *bottom_type() const { return TypeInt::INT; }
901   virtual uint ideal_reg() const { return Op_RegI; }
902 };
903 
904 //------------------------------ExtractUBNode----------------------------------
905 // Extract a boolean from a vector at position &quot;pos&quot;
906 class ExtractUBNode : public ExtractNode {
907  public:
908   ExtractUBNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
909   virtual int Opcode() const;
910   virtual const Type *bottom_type() const { return TypeInt::INT; }
911   virtual uint ideal_reg() const { return Op_RegI; }
912 };
913 
914 //------------------------------ExtractCNode-----------------------------------
915 // Extract a char from a vector at position &quot;pos&quot;
916 class ExtractCNode : public ExtractNode {
917  public:
918   ExtractCNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
919   virtual int Opcode() const;
920   virtual const Type *bottom_type() const { return TypeInt::INT; }
921   virtual uint ideal_reg() const { return Op_RegI; }
922 };
923 
924 //------------------------------ExtractSNode-----------------------------------
925 // Extract a short from a vector at position &quot;pos&quot;
926 class ExtractSNode : public ExtractNode {
927  public:
928   ExtractSNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
929   virtual int Opcode() const;
930   virtual const Type *bottom_type() const { return TypeInt::INT; }
931   virtual uint ideal_reg() const { return Op_RegI; }
932 };
933 
934 //------------------------------ExtractINode-----------------------------------
935 // Extract an int from a vector at position &quot;pos&quot;
936 class ExtractINode : public ExtractNode {
937  public:
938   ExtractINode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
939   virtual int Opcode() const;
940   virtual const Type *bottom_type() const { return TypeInt::INT; }
941   virtual uint ideal_reg() const { return Op_RegI; }
942 };
943 
944 //------------------------------ExtractLNode-----------------------------------
945 // Extract a long from a vector at position &quot;pos&quot;
946 class ExtractLNode : public ExtractNode {
947  public:
948   ExtractLNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
949   virtual int Opcode() const;
950   virtual const Type *bottom_type() const { return TypeLong::LONG; }
951   virtual uint ideal_reg() const { return Op_RegL; }
952 };
953 
954 //------------------------------ExtractFNode-----------------------------------
955 // Extract a float from a vector at position &quot;pos&quot;
956 class ExtractFNode : public ExtractNode {
957  public:
958   ExtractFNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
959   virtual int Opcode() const;
960   virtual const Type *bottom_type() const { return Type::FLOAT; }
961   virtual uint ideal_reg() const { return Op_RegF; }
962 };
963 
964 //------------------------------ExtractDNode-----------------------------------
965 // Extract a double from a vector at position &quot;pos&quot;
966 class ExtractDNode : public ExtractNode {
967  public:
968   ExtractDNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
969   virtual int Opcode() const;
970   virtual const Type *bottom_type() const { return Type::DOUBLE; }
971   virtual uint ideal_reg() const { return Op_RegD; }
972 };
973 
974 //------------------------------SetVectMaskINode-------------------------------
975 // Provide a mask for a vector predicate machine
976 class SetVectMaskINode : public Node {
977 public:
978   SetVectMaskINode(Node *c, Node *in1) : Node(c, in1) {}
979   virtual int Opcode() const;
980   const Type *bottom_type() const { return TypeInt::INT; }
981   virtual uint ideal_reg() const { return Op_RegI; }
982   virtual const Type *Value(PhaseGVN *phase) const { return TypeInt::INT; }
983 };
984 
985 #endif // SHARE_OPTO_VECTORNODE_HPP
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
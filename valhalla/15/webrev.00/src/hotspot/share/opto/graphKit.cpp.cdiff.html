<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/graphKit.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="gcm.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/graphKit.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 2751,83 ***</span>
    gvn.transform(iff);
    if (!bol-&gt;is_Con()) gvn.record_for_igvn(iff);
    return iff;
  }
  
<span class="line-removed">- // Find the memory state for the secondary super type cache load when</span>
<span class="line-removed">- // a subtype check is expanded at macro expansion time. That field is</span>
<span class="line-removed">- // mutable so should not use immutable memory but</span>
<span class="line-removed">- // PartialSubtypeCheckNode that might modify it doesn&#39;t produce a new</span>
<span class="line-removed">- // memory state so bottom memory is the most accurate memory state to</span>
<span class="line-removed">- // hook the load with. This follows the implementation used when the</span>
<span class="line-removed">- // subtype check is expanded at parse time.</span>
<span class="line-removed">- static Node* find_bottom_mem(Node* ctrl, Compile* C) {</span>
<span class="line-removed">-   const TypePtr* adr_type = TypeKlassPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;Object_klass(), Type::Offset::bottom, false);</span>
<span class="line-removed">-   Node_Stack stack(0);</span>
<span class="line-removed">-   VectorSet seen(Thread::current()-&gt;resource_area());</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* c = ctrl;</span>
<span class="line-removed">-   Node* mem = NULL;</span>
<span class="line-removed">-   uint iter = 0;</span>
<span class="line-removed">-   do {</span>
<span class="line-removed">-     iter++;</span>
<span class="line-removed">-     assert(iter &lt; C-&gt;live_nodes(), &quot;infinite loop&quot;);</span>
<span class="line-removed">-     if (c-&gt;is_Region()) {</span>
<span class="line-removed">-       for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax &amp;&amp; mem == NULL; i++) {</span>
<span class="line-removed">-         Node* u = c-&gt;fast_out(i);</span>
<span class="line-removed">-         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY &amp;&amp;</span>
<span class="line-removed">-             (u-&gt;adr_type() == TypePtr::BOTTOM || u-&gt;adr_type() == adr_type)) {</span>
<span class="line-removed">-           mem = u;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (mem == NULL) {</span>
<span class="line-removed">-         if (!seen.test_set(c-&gt;_idx)) {</span>
<span class="line-removed">-           stack.push(c, 2);</span>
<span class="line-removed">-           c = c-&gt;in(1);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           Node* phi = NULL;</span>
<span class="line-removed">-           uint idx = 0;</span>
<span class="line-removed">-           for (;;) {</span>
<span class="line-removed">-             phi = stack.node();</span>
<span class="line-removed">-             idx = stack.index();</span>
<span class="line-removed">-             if (idx &lt; phi-&gt;req()) {</span>
<span class="line-removed">-               break;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             stack.pop();</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-           c = phi-&gt;in(idx);</span>
<span class="line-removed">-           stack.set_index(idx+1);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     } else if (c-&gt;is_Proj() &amp;&amp; c-&gt;in(0)-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-removed">-       for (DUIterator_Fast imax, i = c-&gt;in(0)-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">-         Node* u = c-&gt;in(0)-&gt;fast_out(i);</span>
<span class="line-removed">-         if (u-&gt;bottom_type() == Type::MEMORY &amp;&amp; u-&gt;as_Proj()-&gt;_is_io_use == c-&gt;as_Proj()-&gt;_is_io_use) {</span>
<span class="line-removed">-           assert(mem == NULL, &quot;&quot;);</span>
<span class="line-removed">-           mem = u;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     } else if (c-&gt;is_CatchProj() &amp;&amp; c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-removed">-       Node* call = c-&gt;in(0)-&gt;in(0)-&gt;in(0);</span>
<span class="line-removed">-       assert(call-&gt;is_Call(), &quot;CatchProj with no call?&quot;);</span>
<span class="line-removed">-       CallProjections* projs = call-&gt;as_Call()-&gt;extract_projections(false, false);</span>
<span class="line-removed">-       if (projs-&gt;catchall_memproj == NULL) {</span>
<span class="line-removed">-         mem = projs-&gt;fallthrough_memproj;</span>
<span class="line-removed">-       } else if (c == projs-&gt;fallthrough_catchproj) {</span>
<span class="line-removed">-         mem = projs-&gt;fallthrough_memproj;</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         assert(c == projs-&gt;catchall_catchproj, &quot;strange control&quot;);</span>
<span class="line-removed">-         mem = projs-&gt;catchall_memproj;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(!c-&gt;is_Start(), &quot;should stop before start&quot;);</span>
<span class="line-removed">-       c = c-&gt;in(0);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   } while (mem == NULL);</span>
<span class="line-removed">-   return mem;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  //-------------------------------gen_subtype_check-----------------------------
  // Generate a subtyping check.  Takes as input the subtype and supertype.
  // Returns 2 values: sets the default control() to the true path and returns
  // the false path.  Only reads invariant memory; sets no (visible) memory.
  // The PartialSubtypeCheckNode sets the hidden 1-word cache in the encoding
<span class="line-new-header">--- 2751,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2906,16 ***</span>
    Node *p2 = gvn.transform(new AddPNode(subklass,subklass,chk_off_X));
    // For some types like interfaces the following loadKlass is from a 1-word
    // cache which is mutable so can&#39;t use immutable memory.  Other
    // types load from the super-class display table which is immutable.
    Node *kmem = C-&gt;immutable_memory();
<span class="line-modified">!   if (might_be_cache) {</span>
<span class="line-modified">!     assert((C-&gt;get_alias_index(TypeKlassPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;Object_klass(), Type::Offset::bottom, false)) ==</span>
<span class="line-modified">!             C-&gt;get_alias_index(gvn.type(p2)-&gt;is_ptr())), &quot;&quot;);</span>
<span class="line-modified">!     if (mem == NULL) {</span>
<span class="line-modified">!       mem = find_bottom_mem(*ctrl, C);</span>
<span class="line-modified">!     }</span>
      kmem = mem-&gt;is_MergeMem() ? mem-&gt;as_MergeMem()-&gt;memory_at(C-&gt;get_alias_index(gvn.type(p2)-&gt;is_ptr())) : mem;
    }
    Node *nkls = gvn.transform(LoadKlassNode::make(gvn, NULL, kmem, p2, gvn.type(p2)-&gt;is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));
  
    // Compile speed common case: ARE a subtype and we canNOT fail
<span class="line-new-header">--- 2833,16 ---</span>
    Node *p2 = gvn.transform(new AddPNode(subklass,subklass,chk_off_X));
    // For some types like interfaces the following loadKlass is from a 1-word
    // cache which is mutable so can&#39;t use immutable memory.  Other
    // types load from the super-class display table which is immutable.
    Node *kmem = C-&gt;immutable_memory();
<span class="line-modified">!   // secondary_super_cache is not immutable but can be treated as such because:</span>
<span class="line-modified">!   // - no ideal node writes to it in a way that could cause an</span>
<span class="line-modified">!   //   incorrect/missed optimization of the following Load.</span>
<span class="line-modified">!   // - it&#39;s a cache so, worse case, not reading the latest value</span>
<span class="line-modified">!   //   wouldn&#39;t cause incorrect execution</span>
<span class="line-modified">!   if (might_be_cache &amp;&amp; mem != NULL) {</span>
      kmem = mem-&gt;is_MergeMem() ? mem-&gt;as_MergeMem()-&gt;memory_at(C-&gt;get_alias_index(gvn.type(p2)-&gt;is_ptr())) : mem;
    }
    Node *nkls = gvn.transform(LoadKlassNode::make(gvn, NULL, kmem, p2, gvn.type(p2)-&gt;is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));
  
    // Compile speed common case: ARE a subtype and we canNOT fail
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4472,11 ***</span>
  }
  
  //----------------------------- loop predicates ---------------------------
  
  //------------------------------add_predicate_impl----------------------------
<span class="line-modified">! void GraphKit::add_predicate_impl(Deoptimization::DeoptReason reason, int nargs) {</span>
    // Too many traps seen?
    if (too_many_traps(reason)) {
  #ifdef ASSERT
      if (TraceLoopPredicate) {
        int tc = C-&gt;trap_count(reason);
<span class="line-new-header">--- 4399,11 ---</span>
  }
  
  //----------------------------- loop predicates ---------------------------
  
  //------------------------------add_predicate_impl----------------------------
<span class="line-modified">! void GraphKit::add_empty_predicate_impl(Deoptimization::DeoptReason reason, int nargs) {</span>
    // Too many traps seen?
    if (too_many_traps(reason)) {
  #ifdef ASSERT
      if (TraceLoopPredicate) {
        int tc = C-&gt;trap_count(reason);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4506,19 ***</span>
    Node* iftrue = _gvn.transform(new IfTrueNode(iff));
    set_control(iftrue);
  }
  
  //------------------------------add_predicate---------------------------------
<span class="line-modified">! void GraphKit::add_predicate(int nargs) {</span>
    if (UseLoopPredicate) {
<span class="line-modified">!     add_predicate_impl(Deoptimization::Reason_predicate, nargs);</span>
    }
    if (UseProfiledLoopPredicate) {
<span class="line-modified">!     add_predicate_impl(Deoptimization::Reason_profile_predicate, nargs);</span>
    }
    // loop&#39;s limit check predicate should be near the loop.
<span class="line-modified">!   add_predicate_impl(Deoptimization::Reason_loop_limit_check, nargs);</span>
  }
  
  void GraphKit::sync_kit(IdealKit&amp; ideal) {
    set_all_memory(ideal.merged_memory());
    set_i_o(ideal.i_o());
<span class="line-new-header">--- 4433,22 ---</span>
    Node* iftrue = _gvn.transform(new IfTrueNode(iff));
    set_control(iftrue);
  }
  
  //------------------------------add_predicate---------------------------------
<span class="line-modified">! void GraphKit::add_empty_predicates(int nargs) {</span>
<span class="line-added">+   // These loop predicates remain empty. All concrete loop predicates are inserted above the corresponding</span>
<span class="line-added">+   // empty loop predicate later by &#39;PhaseIdealLoop::create_new_if_for_predicate&#39;. All concrete loop predicates of</span>
<span class="line-added">+   // a specific kind (normal, profile or limit check) share the same uncommon trap as the empty loop predicate.</span>
    if (UseLoopPredicate) {
<span class="line-modified">!     add_empty_predicate_impl(Deoptimization::Reason_predicate, nargs);</span>
    }
    if (UseProfiledLoopPredicate) {
<span class="line-modified">!     add_empty_predicate_impl(Deoptimization::Reason_profile_predicate, nargs);</span>
    }
    // loop&#39;s limit check predicate should be near the loop.
<span class="line-modified">!   add_empty_predicate_impl(Deoptimization::Reason_loop_limit_check, nargs);</span>
  }
  
  void GraphKit::sync_kit(IdealKit&amp; ideal) {
    set_all_memory(ideal.merged_memory());
    set_i_o(ideal.i_o());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4638,11 ***</span>
     * int i_char = start;
     * for (int i_byte = 0; i_byte &lt; count; i_byte++) {
     *   dst[i_char++] = (char)(src[i_byte] &amp; 0xff);
     * }
     */
<span class="line-modified">!   add_predicate();</span>
    RegionNode* head = new RegionNode(3);
    head-&gt;init_req(1, control());
    gvn().set_type(head, Type::CONTROL);
    record_for_igvn(head);
  
<span class="line-new-header">--- 4568,11 ---</span>
     * int i_char = start;
     * for (int i_byte = 0; i_byte &lt; count; i_byte++) {
     *   dst[i_char++] = (char)(src[i_byte] &amp; 0xff);
     * }
     */
<span class="line-modified">!   add_empty_predicates();</span>
    RegionNode* head = new RegionNode(3);
    head-&gt;init_req(1, control());
    gvn().set_type(head, Type::CONTROL);
    record_for_igvn(head);
  
</pre>
<center><a href="gcm.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciField.hpp&quot;
  27 #include &quot;ci/ciMethodData.hpp&quot;
  28 #include &quot;ci/ciTypeFlow.hpp&quot;
  29 #include &quot;ci/ciValueKlass.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;compiler/compileLog.hpp&quot;
  33 #include &quot;libadt/dict.hpp&quot;
  34 #include &quot;memory/oopFactory.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;oops/instanceKlass.hpp&quot;
  37 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  38 #include &quot;oops/objArrayKlass.hpp&quot;
  39 #include &quot;oops/typeArrayKlass.hpp&quot;
  40 #include &quot;opto/matcher.hpp&quot;
  41 #include &quot;opto/node.hpp&quot;
  42 #include &quot;opto/opcodes.hpp&quot;
  43 #include &quot;opto/type.hpp&quot;
  44 #include &quot;utilities/powerOfTwo.hpp&quot;
  45 
  46 // Portions of code courtesy of Clifford Click
  47 
  48 // Optimization - Graph Style
  49 
  50 // Dictionary of types shared among compilations.
  51 Dict* Type::_shared_type_dict = NULL;
  52 const Type::Offset Type::Offset::top(Type::OffsetTop);
  53 const Type::Offset Type::Offset::bottom(Type::OffsetBot);
  54 
  55 const Type::Offset Type::Offset::meet(const Type::Offset other) const {
  56   // Either is &#39;TOP&#39; offset?  Return the other offset!
  57   int offset = other._offset;
  58   if (_offset == OffsetTop) return Offset(offset);
  59   if (offset == OffsetTop) return Offset(_offset);
  60   // If either is different, return &#39;BOTTOM&#39; offset
  61   if (_offset != offset) return bottom;
  62   return Offset(_offset);
  63 }
  64 
  65 const Type::Offset Type::Offset::dual() const {
  66   if (_offset == OffsetTop) return bottom;// Map &#39;TOP&#39; into &#39;BOTTOM&#39;
  67   if (_offset == OffsetBot) return top;// Map &#39;BOTTOM&#39; into &#39;TOP&#39;
  68   return Offset(_offset);               // Map everything else into self
  69 }
  70 
  71 const Type::Offset Type::Offset::add(intptr_t offset) const {
  72   // Adding to &#39;TOP&#39; offset?  Return &#39;TOP&#39;!
  73   if (_offset == OffsetTop || offset == OffsetTop) return top;
  74   // Adding to &#39;BOTTOM&#39; offset?  Return &#39;BOTTOM&#39;!
  75   if (_offset == OffsetBot || offset == OffsetBot) return bottom;
  76   // Addition overflows or &quot;accidentally&quot; equals to OffsetTop? Return &#39;BOTTOM&#39;!
  77   offset += (intptr_t)_offset;
  78   if (offset != (int)offset || offset == OffsetTop) return bottom;
  79 
  80   // assert( _offset &gt;= 0 &amp;&amp; _offset+offset &gt;= 0, &quot;&quot; );
  81   // It is possible to construct a negative offset during PhaseCCP
  82 
  83   return Offset((int)offset);        // Sum valid offsets
  84 }
  85 
  86 void Type::Offset::dump2(outputStream *st) const {
  87   if (_offset == 0) {
  88     return;
  89   } else if (_offset == OffsetTop) {
  90     st-&gt;print(&quot;+top&quot;);
  91   }
  92   else if (_offset == OffsetBot) {
  93     st-&gt;print(&quot;+bot&quot;);
  94   } else if (_offset) {
  95     st-&gt;print(&quot;+%d&quot;, _offset);
  96   }
  97 }
  98 
  99 // Array which maps compiler types to Basic Types
 100 const Type::TypeInfo Type::_type_info[Type::lastype] = {
 101   { Bad,             T_ILLEGAL,    &quot;bad&quot;,           false, Node::NotAMachineReg, relocInfo::none          },  // Bad
 102   { Control,         T_ILLEGAL,    &quot;control&quot;,       false, 0,                    relocInfo::none          },  // Control
 103   { Bottom,          T_VOID,       &quot;top&quot;,           false, 0,                    relocInfo::none          },  // Top
 104   { Bad,             T_INT,        &quot;int:&quot;,          false, Op_RegI,              relocInfo::none          },  // Int
 105   { Bad,             T_LONG,       &quot;long:&quot;,         false, Op_RegL,              relocInfo::none          },  // Long
 106   { Half,            T_VOID,       &quot;half&quot;,          false, 0,                    relocInfo::none          },  // Half
 107   { Bad,             T_NARROWOOP,  &quot;narrowoop:&quot;,    false, Op_RegN,              relocInfo::none          },  // NarrowOop
 108   { Bad,             T_NARROWKLASS,&quot;narrowklass:&quot;,  false, Op_RegN,              relocInfo::none          },  // NarrowKlass
 109   { Bad,             T_ILLEGAL,    &quot;tuple:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Tuple
 110   { Bad,             T_ARRAY,      &quot;array:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Array
 111 
 112 #ifdef SPARC
 113   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 114   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegD,              relocInfo::none          },  // VectorD
 115   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
 116   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 117   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 118 #elif defined(PPC64)
 119   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 120   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 121   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 122   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 123   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 124 #elif defined(S390)
 125   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 126   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 127   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
 128   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 129   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 130 #else // all other
 131   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, Op_VecS,              relocInfo::none          },  // VectorS
 132   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
 133   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 134   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
 135   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
 136 #endif
 137   { Bad,             T_VALUETYPE,  &quot;value:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // ValueType
 138   { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
 139   { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
 140   { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
 141   { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
 142   { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
 143   { Bad,             T_METADATA,   &quot;metadata:&quot;,     false, Op_RegP,              relocInfo::metadata_type },  // MetadataPtr
 144   { Bad,             T_METADATA,   &quot;klass:&quot;,        false, Op_RegP,              relocInfo::metadata_type },  // KlassPtr
 145   { Bad,             T_OBJECT,     &quot;func&quot;,          false, 0,                    relocInfo::none          },  // Function
 146   { Abio,            T_ILLEGAL,    &quot;abIO&quot;,          false, 0,                    relocInfo::none          },  // Abio
 147   { Return_Address,  T_ADDRESS,    &quot;return_address&quot;,false, Op_RegP,              relocInfo::none          },  // Return_Address
 148   { Memory,          T_ILLEGAL,    &quot;memory&quot;,        false, 0,                    relocInfo::none          },  // Memory
 149   { FloatBot,        T_FLOAT,      &quot;float_top&quot;,     false, Op_RegF,              relocInfo::none          },  // FloatTop
 150   { FloatCon,        T_FLOAT,      &quot;ftcon:&quot;,        false, Op_RegF,              relocInfo::none          },  // FloatCon
 151   { FloatTop,        T_FLOAT,      &quot;float&quot;,         false, Op_RegF,              relocInfo::none          },  // FloatBot
 152   { DoubleBot,       T_DOUBLE,     &quot;double_top&quot;,    false, Op_RegD,              relocInfo::none          },  // DoubleTop
 153   { DoubleCon,       T_DOUBLE,     &quot;dblcon:&quot;,       false, Op_RegD,              relocInfo::none          },  // DoubleCon
 154   { DoubleTop,       T_DOUBLE,     &quot;double&quot;,        false, Op_RegD,              relocInfo::none          },  // DoubleBot
 155   { Top,             T_ILLEGAL,    &quot;bottom&quot;,        false, 0,                    relocInfo::none          }   // Bottom
 156 };
 157 
 158 // Map ideal registers (machine types) to ideal types
 159 const Type *Type::mreg2type[_last_machine_leaf];
 160 
 161 // Map basic types to canonical Type* pointers.
 162 const Type* Type::     _const_basic_type[T_CONFLICT+1];
 163 
 164 // Map basic types to constant-zero Types.
 165 const Type* Type::            _zero_type[T_CONFLICT+1];
 166 
 167 // Map basic types to array-body alias types.
 168 const TypeAryPtr* TypeAryPtr::_array_body_type[T_CONFLICT+1];
 169 
 170 //=============================================================================
 171 // Convenience common pre-built types.
 172 const Type *Type::ABIO;         // State-of-machine only
 173 const Type *Type::BOTTOM;       // All values
 174 const Type *Type::CONTROL;      // Control only
 175 const Type *Type::DOUBLE;       // All doubles
 176 const Type *Type::FLOAT;        // All floats
 177 const Type *Type::HALF;         // Placeholder half of doublewide type
 178 const Type *Type::MEMORY;       // Abstract store only
 179 const Type *Type::RETURN_ADDRESS;
 180 const Type *Type::TOP;          // No values in set
 181 
 182 //------------------------------get_const_type---------------------------
 183 const Type* Type::get_const_type(ciType* type) {
 184   if (type == NULL) {
 185     return NULL;
 186   } else if (type-&gt;is_primitive_type()) {
 187     return get_const_basic_type(type-&gt;basic_type());
 188   } else {
 189     return TypeOopPtr::make_from_klass(type-&gt;as_klass());
 190   }
 191 }
 192 
 193 //---------------------------array_element_basic_type---------------------------------
 194 // Mapping to the array element&#39;s basic type.
 195 BasicType Type::array_element_basic_type() const {
 196   BasicType bt = basic_type();
 197   if (bt == T_INT) {
 198     if (this == TypeInt::INT)   return T_INT;
 199     if (this == TypeInt::CHAR)  return T_CHAR;
 200     if (this == TypeInt::BYTE)  return T_BYTE;
 201     if (this == TypeInt::BOOL)  return T_BOOLEAN;
 202     if (this == TypeInt::SHORT) return T_SHORT;
 203     return T_VOID;
 204   }
 205   return bt;
 206 }
 207 
 208 // For two instance arrays of same dimension, return the base element types.
 209 // Otherwise or if the arrays have different dimensions, return NULL.
 210 void Type::get_arrays_base_elements(const Type *a1, const Type *a2,
 211                                     const TypeInstPtr **e1, const TypeInstPtr **e2) {
 212 
 213   if (e1) *e1 = NULL;
 214   if (e2) *e2 = NULL;
 215   const TypeAryPtr* a1tap = (a1 == NULL) ? NULL : a1-&gt;isa_aryptr();
 216   const TypeAryPtr* a2tap = (a2 == NULL) ? NULL : a2-&gt;isa_aryptr();
 217 
 218   if (a1tap != NULL &amp;&amp; a2tap != NULL) {
 219     // Handle multidimensional arrays
 220     const TypePtr* a1tp = a1tap-&gt;elem()-&gt;make_ptr();
 221     const TypePtr* a2tp = a2tap-&gt;elem()-&gt;make_ptr();
 222     while (a1tp &amp;&amp; a1tp-&gt;isa_aryptr() &amp;&amp; a2tp &amp;&amp; a2tp-&gt;isa_aryptr()) {
 223       a1tap = a1tp-&gt;is_aryptr();
 224       a2tap = a2tp-&gt;is_aryptr();
 225       a1tp = a1tap-&gt;elem()-&gt;make_ptr();
 226       a2tp = a2tap-&gt;elem()-&gt;make_ptr();
 227     }
 228     if (a1tp &amp;&amp; a1tp-&gt;isa_instptr() &amp;&amp; a2tp &amp;&amp; a2tp-&gt;isa_instptr()) {
 229       if (e1) *e1 = a1tp-&gt;is_instptr();
 230       if (e2) *e2 = a2tp-&gt;is_instptr();
 231     }
 232   }
 233 }
 234 
 235 //---------------------------get_typeflow_type---------------------------------
 236 // Import a type produced by ciTypeFlow.
 237 const Type* Type::get_typeflow_type(ciType* type) {
 238   switch (type-&gt;basic_type()) {
 239 
 240   case ciTypeFlow::StateVector::T_BOTTOM:
 241     assert(type == ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 242     return Type::BOTTOM;
 243 
 244   case ciTypeFlow::StateVector::T_TOP:
 245     assert(type == ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 246     return Type::TOP;
 247 
 248   case ciTypeFlow::StateVector::T_NULL:
 249     assert(type == ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 250     return TypePtr::NULL_PTR;
 251 
 252   case ciTypeFlow::StateVector::T_LONG2:
 253     // The ciTypeFlow pass pushes a long, then the half.
 254     // We do the same.
 255     assert(type == ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 256     return TypeInt::TOP;
 257 
 258   case ciTypeFlow::StateVector::T_DOUBLE2:
 259     // The ciTypeFlow pass pushes double, then the half.
 260     // Our convention is the same.
 261     assert(type == ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 262     return Type::TOP;
 263 
 264   case T_ADDRESS:
 265     assert(type-&gt;is_return_address(), &quot;&quot;);
 266     return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
 267 
 268   case T_VALUETYPE: {
 269     bool is_never_null = type-&gt;is_never_null();
 270     ciValueKlass* vk = type-&gt;unwrap()-&gt;as_value_klass();
 271     if (vk-&gt;is_scalarizable() &amp;&amp; is_never_null) {
 272       return TypeValueType::make(vk);
 273     } else {
 274       return TypeOopPtr::make_from_klass(vk)-&gt;join_speculative(is_never_null ? TypePtr::NOTNULL : TypePtr::BOTTOM);
 275     }
 276   }
 277 
 278   default:
 279     // make sure we did not mix up the cases:
 280     assert(type != ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 281     assert(type != ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 282     assert(type != ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 283     assert(type != ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 284     assert(type != ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 285     assert(!type-&gt;is_return_address(), &quot;&quot;);
 286 
 287     return Type::get_const_type(type);
 288   }
 289 }
 290 
 291 
 292 //-----------------------make_from_constant------------------------------------
 293 const Type* Type::make_from_constant(ciConstant constant, bool require_constant,
 294                                      int stable_dimension, bool is_narrow_oop,
 295                                      bool is_autobox_cache) {
 296   switch (constant.basic_type()) {
 297     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
 298     case T_CHAR:     return TypeInt::make(constant.as_char());
 299     case T_BYTE:     return TypeInt::make(constant.as_byte());
 300     case T_SHORT:    return TypeInt::make(constant.as_short());
 301     case T_INT:      return TypeInt::make(constant.as_int());
 302     case T_LONG:     return TypeLong::make(constant.as_long());
 303     case T_FLOAT:    return TypeF::make(constant.as_float());
 304     case T_DOUBLE:   return TypeD::make(constant.as_double());
 305     case T_ARRAY:
 306     case T_VALUETYPE:
 307     case T_OBJECT: {
 308         const Type* con_type = NULL;
 309         ciObject* oop_constant = constant.as_object();
 310         if (oop_constant-&gt;is_null_object()) {
 311           con_type = Type::get_zero_type(T_OBJECT);
 312         } else {
 313           guarantee(require_constant || oop_constant-&gt;should_be_constant(), &quot;con_type must get computed&quot;);
 314           con_type = TypeOopPtr::make_from_constant(oop_constant, require_constant);
 315           if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; is_autobox_cache) {
 316             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_autobox_cache(true);
 317           }
 318           if (stable_dimension &gt; 0) {
 319             assert(FoldStableValues, &quot;sanity&quot;);
 320             assert(!con_type-&gt;is_zero_type(), &quot;default value for stable field&quot;);
 321             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_stable(true, stable_dimension);
 322           }
 323         }
 324         if (is_narrow_oop) {
 325           con_type = con_type-&gt;make_narrowoop();
 326         }
 327         return con_type;
 328       }
 329     case T_ILLEGAL:
 330       // Invalid ciConstant returned due to OutOfMemoryError in the CI
 331       assert(Compile::current()-&gt;env()-&gt;failing(), &quot;otherwise should not see this&quot;);
 332       return NULL;
 333     default:
 334       // Fall through to failure
 335       return NULL;
 336   }
 337 }
 338 
 339 static ciConstant check_mismatched_access(ciConstant con, BasicType loadbt, bool is_unsigned) {
 340   BasicType conbt = con.basic_type();
 341   switch (conbt) {
 342     case T_BOOLEAN: conbt = T_BYTE;   break;
 343     case T_ARRAY:   conbt = T_OBJECT; break;
 344     case T_VALUETYPE: conbt = T_OBJECT; break;
 345     default:                          break;
 346   }
 347   switch (loadbt) {
 348     case T_BOOLEAN:   loadbt = T_BYTE;   break;
 349     case T_NARROWOOP: loadbt = T_OBJECT; break;
 350     case T_ARRAY:     loadbt = T_OBJECT; break;
 351     case T_VALUETYPE: loadbt = T_OBJECT; break;
 352     case T_ADDRESS:   loadbt = T_OBJECT; break;
 353     default:                             break;
 354   }
 355   if (conbt == loadbt) {
 356     if (is_unsigned &amp;&amp; conbt == T_BYTE) {
 357       // LoadB (T_BYTE) with a small mask (&lt;=8-bit) is converted to LoadUB (T_BYTE).
 358       return ciConstant(T_INT, con.as_int() &amp; 0xFF);
 359     } else {
 360       return con;
 361     }
 362   }
 363   if (conbt == T_SHORT &amp;&amp; loadbt == T_CHAR) {
 364     // LoadS (T_SHORT) with a small mask (&lt;=16-bit) is converted to LoadUS (T_CHAR).
 365     return ciConstant(T_INT, con.as_int() &amp; 0xFFFF);
 366   }
 367   return ciConstant(); // T_ILLEGAL
 368 }
 369 
 370 // Try to constant-fold a stable array element.
 371 const Type* Type::make_constant_from_array_element(ciArray* array, int off, int stable_dimension,
 372                                                    BasicType loadbt, bool is_unsigned_load) {
 373   // Decode the results of GraphKit::array_element_address.
 374   ciConstant element_value = array-&gt;element_value_by_offset(off);
 375   if (element_value.basic_type() == T_ILLEGAL) {
 376     return NULL; // wrong offset
 377   }
 378   ciConstant con = check_mismatched_access(element_value, loadbt, is_unsigned_load);
 379 
 380   assert(con.basic_type() != T_ILLEGAL, &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 381          type2name(element_value.basic_type()), type2name(loadbt), is_unsigned_load);
 382 
 383   if (con.is_valid() &amp;&amp;          // not a mismatched access
 384       !con.is_null_or_zero()) {  // not a default value
 385     bool is_narrow_oop = (loadbt == T_NARROWOOP);
 386     return Type::make_from_constant(con, /*require_constant=*/true, stable_dimension, is_narrow_oop, /*is_autobox_cache=*/false);
 387   }
 388   return NULL;
 389 }
 390 
 391 const Type* Type::make_constant_from_field(ciInstance* holder, int off, bool is_unsigned_load, BasicType loadbt) {
 392   ciField* field;
 393   ciType* type = holder-&gt;java_mirror_type();
 394   if (type != NULL &amp;&amp; type-&gt;is_instance_klass() &amp;&amp; off &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
 395     // Static field
 396     field = type-&gt;as_instance_klass()-&gt;get_field_by_offset(off, /*is_static=*/true);
 397   } else {
 398     // Instance field
 399     field = holder-&gt;klass()-&gt;as_instance_klass()-&gt;get_field_by_offset(off, /*is_static=*/false);
 400   }
 401   if (field == NULL) {
 402     return NULL; // Wrong offset
 403   }
 404   return Type::make_constant_from_field(field, holder, loadbt, is_unsigned_load);
 405 }
 406 
 407 const Type* Type::make_constant_from_field(ciField* field, ciInstance* holder,
 408                                            BasicType loadbt, bool is_unsigned_load) {
 409   if (!field-&gt;is_constant()) {
 410     return NULL; // Non-constant field
 411   }
 412   ciConstant field_value;
 413   if (field-&gt;is_static()) {
 414     // final static field
 415     field_value = field-&gt;constant_value();
 416   } else if (holder != NULL) {
 417     // final or stable non-static field
 418     // Treat final non-static fields of trusted classes (classes in
 419     // java.lang.invoke and sun.invoke packages and subpackages) as
 420     // compile time constants.
 421     field_value = field-&gt;constant_value_of(holder);
 422   }
 423   if (!field_value.is_valid()) {
 424     return NULL; // Not a constant
 425   }
 426 
 427   ciConstant con = check_mismatched_access(field_value, loadbt, is_unsigned_load);
 428 
 429   assert(con.is_valid(), &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 430          type2name(field_value.basic_type()), type2name(loadbt), is_unsigned_load);
 431 
 432   bool is_stable_array = FoldStableValues &amp;&amp; field-&gt;is_stable() &amp;&amp; field-&gt;type()-&gt;is_array_klass();
 433   int stable_dimension = (is_stable_array ? field-&gt;type()-&gt;as_array_klass()-&gt;dimension() : 0);
 434   bool is_narrow_oop = (loadbt == T_NARROWOOP);
 435 
 436   const Type* con_type = make_from_constant(con, /*require_constant=*/ true,
 437                                             stable_dimension, is_narrow_oop,
 438                                             field-&gt;is_autobox_cache());
 439   if (con_type != NULL &amp;&amp; field-&gt;is_call_site_target()) {
 440     ciCallSite* call_site = holder-&gt;as_call_site();
 441     if (!call_site-&gt;is_fully_initialized_constant_call_site()) {
 442       ciMethodHandle* target = con.as_object()-&gt;as_method_handle();
 443       Compile::current()-&gt;dependencies()-&gt;assert_call_site_target_value(call_site, target);
 444     }
 445   }
 446   return con_type;
 447 }
 448 
 449 //------------------------------make-------------------------------------------
 450 // Create a simple Type, with default empty symbol sets.  Then hashcons it
 451 // and look for an existing copy in the type dictionary.
 452 const Type *Type::make( enum TYPES t ) {
 453   return (new Type(t))-&gt;hashcons();
 454 }
 455 
 456 //------------------------------cmp--------------------------------------------
 457 int Type::cmp( const Type *const t1, const Type *const t2 ) {
 458   if( t1-&gt;_base != t2-&gt;_base )
 459     return 1;                   // Missed badly
 460   assert(t1 != t2 || t1-&gt;eq(t2), &quot;eq must be reflexive&quot;);
 461   return !t1-&gt;eq(t2);           // Return ZERO if equal
 462 }
 463 
 464 const Type* Type::maybe_remove_speculative(bool include_speculative) const {
 465   if (!include_speculative) {
 466     return remove_speculative();
 467   }
 468   return this;
 469 }
 470 
 471 //------------------------------hash-------------------------------------------
 472 int Type::uhash( const Type *const t ) {
 473   return t-&gt;hash();
 474 }
 475 
 476 #define SMALLINT ((juint)3)  // a value too insignificant to consider widening
 477 #define POSITIVE_INFINITE_F 0x7f800000 // hex representation for IEEE 754 single precision positive infinite
 478 #define POSITIVE_INFINITE_D 0x7ff0000000000000 // hex representation for IEEE 754 double precision positive infinite
 479 
 480 //--------------------------Initialize_shared----------------------------------
 481 void Type::Initialize_shared(Compile* current) {
 482   // This method does not need to be locked because the first system
 483   // compilations (stub compilations) occur serially.  If they are
 484   // changed to proceed in parallel, then this section will need
 485   // locking.
 486 
 487   Arena* save = current-&gt;type_arena();
 488   Arena* shared_type_arena = new (mtCompiler)Arena(mtCompiler);
 489 
 490   current-&gt;set_type_arena(shared_type_arena);
 491   _shared_type_dict =
 492     new (shared_type_arena) Dict( (CmpKey)Type::cmp, (Hash)Type::uhash,
 493                                   shared_type_arena, 128 );
 494   current-&gt;set_type_dict(_shared_type_dict);
 495 
 496   // Make shared pre-built types.
 497   CONTROL = make(Control);      // Control only
 498   TOP     = make(Top);          // No values in set
 499   MEMORY  = make(Memory);       // Abstract store only
 500   ABIO    = make(Abio);         // State-of-machine only
 501   RETURN_ADDRESS=make(Return_Address);
 502   FLOAT   = make(FloatBot);     // All floats
 503   DOUBLE  = make(DoubleBot);    // All doubles
 504   BOTTOM  = make(Bottom);       // Everything
 505   HALF    = make(Half);         // Placeholder half of doublewide type
 506 
 507   TypeF::ZERO = TypeF::make(0.0); // Float 0 (positive zero)
 508   TypeF::ONE  = TypeF::make(1.0); // Float 1
 509   TypeF::POS_INF = TypeF::make(jfloat_cast(POSITIVE_INFINITE_F));
 510   TypeF::NEG_INF = TypeF::make(-jfloat_cast(POSITIVE_INFINITE_F));
 511 
 512   TypeD::ZERO = TypeD::make(0.0); // Double 0 (positive zero)
 513   TypeD::ONE  = TypeD::make(1.0); // Double 1
 514   TypeD::POS_INF = TypeD::make(jdouble_cast(POSITIVE_INFINITE_D));
 515   TypeD::NEG_INF = TypeD::make(-jdouble_cast(POSITIVE_INFINITE_D));
 516 
 517   TypeInt::MINUS_1 = TypeInt::make(-1);  // -1
 518   TypeInt::ZERO    = TypeInt::make( 0);  //  0
 519   TypeInt::ONE     = TypeInt::make( 1);  //  1
 520   TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  // 0 or 1, FALSE or TRUE.
 521   TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  // -1, 0 or 1, condition codes
 522   TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  // == TypeInt::MINUS_1
 523   TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  // == TypeInt::ONE
 524   TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  // == TypeInt::ZERO
 525   TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);
 526   TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  // == TypeInt::BOOL
 527   TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); // Bytes
 528   TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); // Unsigned Bytes
 529   TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); // Java chars
 530   TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); // Java shorts
 531   TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); // Non-neg values
 532   TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); // Positive values
 533   TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); // 32-bit integers
 534   TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); // symmetric range
 535   TypeInt::TYPE_DOMAIN  = TypeInt::INT;
 536   // CmpL is overloaded both as the bytecode computation returning
 537   // a trinary (-1,0,+1) integer result AND as an efficient long
 538   // compare returning optimizer ideal-type flags.
 539   assert( TypeInt::CC_LT == TypeInt::MINUS_1, &quot;types must match for CmpL to work&quot; );
 540   assert( TypeInt::CC_GT == TypeInt::ONE,     &quot;types must match for CmpL to work&quot; );
 541   assert( TypeInt::CC_EQ == TypeInt::ZERO,    &quot;types must match for CmpL to work&quot; );
 542   assert( TypeInt::CC_GE == TypeInt::BOOL,    &quot;types must match for CmpL to work&quot; );
 543   assert( (juint)(TypeInt::CC-&gt;_hi - TypeInt::CC-&gt;_lo) &lt;= SMALLINT, &quot;CC is truly small&quot;);
 544 
 545   TypeLong::MINUS_1 = TypeLong::make(-1);        // -1
 546   TypeLong::ZERO    = TypeLong::make( 0);        //  0
 547   TypeLong::ONE     = TypeLong::make( 1);        //  1
 548   TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin); // Non-neg values
 549   TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax); // 64-bit integers
 550   TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin);
 551   TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin);
 552   TypeLong::TYPE_DOMAIN  = TypeLong::LONG;
 553 
 554   const Type **fboth =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 555   fboth[0] = Type::CONTROL;
 556   fboth[1] = Type::CONTROL;
 557   TypeTuple::IFBOTH = TypeTuple::make( 2, fboth );
 558 
 559   const Type **ffalse =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 560   ffalse[0] = Type::CONTROL;
 561   ffalse[1] = Type::TOP;
 562   TypeTuple::IFFALSE = TypeTuple::make( 2, ffalse );
 563 
 564   const Type **fneither =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 565   fneither[0] = Type::TOP;
 566   fneither[1] = Type::TOP;
 567   TypeTuple::IFNEITHER = TypeTuple::make( 2, fneither );
 568 
 569   const Type **ftrue =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 570   ftrue[0] = Type::TOP;
 571   ftrue[1] = Type::CONTROL;
 572   TypeTuple::IFTRUE = TypeTuple::make( 2, ftrue );
 573 
 574   const Type **floop =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 575   floop[0] = Type::CONTROL;
 576   floop[1] = TypeInt::INT;
 577   TypeTuple::LOOPBODY = TypeTuple::make( 2, floop );
 578 
 579   TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, Offset(0));
 580   TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, Offset::bottom);
 581   TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, Offset::bottom);
 582 
 583   TypeRawPtr::BOTTOM = TypeRawPtr::make( TypePtr::BotPTR );
 584   TypeRawPtr::NOTNULL= TypeRawPtr::make( TypePtr::NotNull );
 585 
 586   const Type **fmembar = TypeTuple::fields(0);
 587   TypeTuple::MEMBAR = TypeTuple::make(TypeFunc::Parms+0, fmembar);
 588 
 589   const Type **fsc = (const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 590   fsc[0] = TypeInt::CC;
 591   fsc[1] = Type::MEMORY;
 592   TypeTuple::STORECONDITIONAL = TypeTuple::make(2, fsc);
 593 
 594   TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
 595   TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
 596   TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
 597   TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 598                                            false, 0, Offset(oopDesc::mark_offset_in_bytes()), false);
 599   TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 600                                            false, 0, Offset(oopDesc::klass_offset_in_bytes()), false);
 601   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, Offset::bottom, TypeOopPtr::InstanceBot);
 602 
 603   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, Offset::bottom);
 604 
 605   TypeValueType::BOTTOM = TypeValueType::make(NULL);
 606 
 607   TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
 608   TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
 609 
 610   TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
 611 
 612   mreg2type[Op_Node] = Type::BOTTOM;
 613   mreg2type[Op_Set ] = 0;
 614   mreg2type[Op_RegN] = TypeNarrowOop::BOTTOM;
 615   mreg2type[Op_RegI] = TypeInt::INT;
 616   mreg2type[Op_RegP] = TypePtr::BOTTOM;
 617   mreg2type[Op_RegF] = Type::FLOAT;
 618   mreg2type[Op_RegD] = Type::DOUBLE;
 619   mreg2type[Op_RegL] = TypeLong::LONG;
 620   mreg2type[Op_RegFlags] = TypeInt::CC;
 621 
 622   TypeAryPtr::RANGE   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL /* current-&gt;env()-&gt;Object_klass() */, false, Offset(arrayOopDesc::length_offset_in_bytes()));
 623 
 624   TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);
 625 
 626 #ifdef _LP64
 627   if (UseCompressedOops) {
 628     assert(TypeAryPtr::NARROWOOPS-&gt;is_ptr_to_narrowoop(), &quot;array of narrow oops must be ptr to narrow oop&quot;);
 629     TypeAryPtr::OOPS  = TypeAryPtr::NARROWOOPS;
 630   } else
 631 #endif
 632   {
 633     // There is no shared klass for Object[].  See note in TypeAryPtr::klass().
 634     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);
 635   }
 636   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Offset::bottom);
 637   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Offset::bottom);
 638   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Offset::bottom);
 639   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);
 640   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);
 641   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);
 642   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);
 643   TypeAryPtr::VALUES  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeValueType::BOTTOM,TypeInt::POS), NULL, false,  Offset::bottom);
 644 
 645   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 646   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 647   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
 648   TypeAryPtr::_array_body_type[T_VALUETYPE] = TypeAryPtr::OOPS;
 649   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 650   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 651   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 652   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 653   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 654   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 655   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 656   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 657   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 658 
 659   TypeKlassPtr::OBJECT = TypeKlassPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), Offset(0), false);
 660   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make(TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), Offset(0), false);
 661 
 662   const Type **fi2c = TypeTuple::fields(2);
 663   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
 664   fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
 665   TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
 666 
 667   const Type **intpair = TypeTuple::fields(2);
 668   intpair[0] = TypeInt::INT;
 669   intpair[1] = TypeInt::INT;
 670   TypeTuple::INT_PAIR = TypeTuple::make(2, intpair);
 671 
 672   const Type **longpair = TypeTuple::fields(2);
 673   longpair[0] = TypeLong::LONG;
 674   longpair[1] = TypeLong::LONG;
 675   TypeTuple::LONG_PAIR = TypeTuple::make(2, longpair);
 676 
 677   const Type **intccpair = TypeTuple::fields(2);
 678   intccpair[0] = TypeInt::INT;
 679   intccpair[1] = TypeInt::CC;
 680   TypeTuple::INT_CC_PAIR = TypeTuple::make(2, intccpair);
 681 
 682   const Type **longccpair = TypeTuple::fields(2);
 683   longccpair[0] = TypeLong::LONG;
 684   longccpair[1] = TypeInt::CC;
 685   TypeTuple::LONG_CC_PAIR = TypeTuple::make(2, longccpair);
 686 
 687   _const_basic_type[T_NARROWOOP]   = TypeNarrowOop::BOTTOM;
 688   _const_basic_type[T_NARROWKLASS] = Type::BOTTOM;
 689   _const_basic_type[T_BOOLEAN]     = TypeInt::BOOL;
 690   _const_basic_type[T_CHAR]        = TypeInt::CHAR;
 691   _const_basic_type[T_BYTE]        = TypeInt::BYTE;
 692   _const_basic_type[T_SHORT]       = TypeInt::SHORT;
 693   _const_basic_type[T_INT]         = TypeInt::INT;
 694   _const_basic_type[T_LONG]        = TypeLong::LONG;
 695   _const_basic_type[T_FLOAT]       = Type::FLOAT;
 696   _const_basic_type[T_DOUBLE]      = Type::DOUBLE;
 697   _const_basic_type[T_OBJECT]      = TypeInstPtr::BOTTOM;
 698   _const_basic_type[T_ARRAY]       = TypeInstPtr::BOTTOM; // there is no separate bottom for arrays
 699   _const_basic_type[T_VALUETYPE]   = TypeInstPtr::BOTTOM;
 700   _const_basic_type[T_VOID]        = TypePtr::NULL_PTR;   // reflection represents void this way
 701   _const_basic_type[T_ADDRESS]     = TypeRawPtr::BOTTOM;  // both interpreter return addresses &amp; random raw ptrs
 702   _const_basic_type[T_CONFLICT]    = Type::BOTTOM;        // why not?
 703 
 704   _zero_type[T_NARROWOOP]   = TypeNarrowOop::NULL_PTR;
 705   _zero_type[T_NARROWKLASS] = TypeNarrowKlass::NULL_PTR;
 706   _zero_type[T_BOOLEAN]     = TypeInt::ZERO;     // false == 0
 707   _zero_type[T_CHAR]        = TypeInt::ZERO;     // &#39;\0&#39; == 0
 708   _zero_type[T_BYTE]        = TypeInt::ZERO;     // 0x00 == 0
 709   _zero_type[T_SHORT]       = TypeInt::ZERO;     // 0x0000 == 0
 710   _zero_type[T_INT]         = TypeInt::ZERO;
 711   _zero_type[T_LONG]        = TypeLong::ZERO;
 712   _zero_type[T_FLOAT]       = TypeF::ZERO;
 713   _zero_type[T_DOUBLE]      = TypeD::ZERO;
 714   _zero_type[T_OBJECT]      = TypePtr::NULL_PTR;
 715   _zero_type[T_ARRAY]       = TypePtr::NULL_PTR; // null array is null oop
 716   _zero_type[T_VALUETYPE]   = TypePtr::NULL_PTR;
 717   _zero_type[T_ADDRESS]     = TypePtr::NULL_PTR; // raw pointers use the same null
 718   _zero_type[T_VOID]        = Type::TOP;         // the only void value is no value at all
 719 
 720   // get_zero_type() should not happen for T_CONFLICT
 721   _zero_type[T_CONFLICT]= NULL;
 722 
 723   // Vector predefined types, it needs initialized _const_basic_type[].
 724   if (Matcher::vector_size_supported(T_BYTE,4)) {
 725     TypeVect::VECTS = TypeVect::make(T_BYTE,4);
 726   }
 727   if (Matcher::vector_size_supported(T_FLOAT,2)) {
 728     TypeVect::VECTD = TypeVect::make(T_FLOAT,2);
 729   }
 730   if (Matcher::vector_size_supported(T_FLOAT,4)) {
 731     TypeVect::VECTX = TypeVect::make(T_FLOAT,4);
 732   }
 733   if (Matcher::vector_size_supported(T_FLOAT,8)) {
 734     TypeVect::VECTY = TypeVect::make(T_FLOAT,8);
 735   }
 736   if (Matcher::vector_size_supported(T_FLOAT,16)) {
 737     TypeVect::VECTZ = TypeVect::make(T_FLOAT,16);
 738   }
 739   mreg2type[Op_VecS] = TypeVect::VECTS;
 740   mreg2type[Op_VecD] = TypeVect::VECTD;
 741   mreg2type[Op_VecX] = TypeVect::VECTX;
 742   mreg2type[Op_VecY] = TypeVect::VECTY;
 743   mreg2type[Op_VecZ] = TypeVect::VECTZ;
 744 
 745   // Restore working type arena.
 746   current-&gt;set_type_arena(save);
 747   current-&gt;set_type_dict(NULL);
 748 }
 749 
 750 //------------------------------Initialize-------------------------------------
 751 void Type::Initialize(Compile* current) {
 752   assert(current-&gt;type_arena() != NULL, &quot;must have created type arena&quot;);
 753 
 754   if (_shared_type_dict == NULL) {
 755     Initialize_shared(current);
 756   }
 757 
 758   Arena* type_arena = current-&gt;type_arena();
 759 
 760   // Create the hash-cons&#39;ing dictionary with top-level storage allocation
 761   Dict *tdic = new (type_arena) Dict( (CmpKey)Type::cmp,(Hash)Type::uhash, type_arena, 128 );
 762   current-&gt;set_type_dict(tdic);
 763 
 764   // Transfer the shared types.
 765   DictI i(_shared_type_dict);
 766   for( ; i.test(); ++i ) {
 767     Type* t = (Type*)i._value;
 768     tdic-&gt;Insert(t,t);  // New Type, insert into Type table
 769   }
 770 }
 771 
 772 //------------------------------hashcons---------------------------------------
 773 // Do the hash-cons trick.  If the Type already exists in the type table,
 774 // delete the current Type and return the existing Type.  Otherwise stick the
 775 // current Type in the Type table.
 776 const Type *Type::hashcons(void) {
 777   debug_only(base());           // Check the assertion in Type::base().
 778   // Look up the Type in the Type dictionary
 779   Dict *tdic = type_dict();
 780   Type* old = (Type*)(tdic-&gt;Insert(this, this, false));
 781   if( old ) {                   // Pre-existing Type?
 782     if( old != this )           // Yes, this guy is not the pre-existing?
 783       delete this;              // Yes, Nuke this guy
 784     assert( old-&gt;_dual, &quot;&quot; );
 785     return old;                 // Return pre-existing
 786   }
 787 
 788   // Every type has a dual (to make my lattice symmetric).
 789   // Since we just discovered a new Type, compute its dual right now.
 790   assert( !_dual, &quot;&quot; );         // No dual yet
 791   _dual = xdual();              // Compute the dual
 792   if (cmp(this, _dual) == 0) {  // Handle self-symmetric
 793     if (_dual != this) {
 794       delete _dual;
 795       _dual = this;
 796     }
 797     return this;
 798   }
 799   assert( !_dual-&gt;_dual, &quot;&quot; );  // No reverse dual yet
 800   assert( !(*tdic)[_dual], &quot;&quot; ); // Dual not in type system either
 801   // New Type, insert into Type table
 802   tdic-&gt;Insert((void*)_dual,(void*)_dual);
 803   ((Type*)_dual)-&gt;_dual = this; // Finish up being symmetric
 804 #ifdef ASSERT
 805   Type *dual_dual = (Type*)_dual-&gt;xdual();
 806   assert( eq(dual_dual), &quot;xdual(xdual()) should be identity&quot; );
 807   delete dual_dual;
 808 #endif
 809   return this;                  // Return new Type
 810 }
 811 
 812 //------------------------------eq---------------------------------------------
 813 // Structural equality check for Type representations
 814 bool Type::eq( const Type * ) const {
 815   return true;                  // Nothing else can go wrong
 816 }
 817 
 818 //------------------------------hash-------------------------------------------
 819 // Type-specific hashing function.
 820 int Type::hash(void) const {
 821   return _base;
 822 }
 823 
 824 //------------------------------is_finite--------------------------------------
 825 // Has a finite value
 826 bool Type::is_finite() const {
 827   return false;
 828 }
 829 
 830 //------------------------------is_nan-----------------------------------------
 831 // Is not a number (NaN)
 832 bool Type::is_nan()    const {
 833   return false;
 834 }
 835 
 836 //----------------------interface_vs_oop---------------------------------------
 837 #ifdef ASSERT
 838 bool Type::interface_vs_oop_helper(const Type *t) const {
 839   bool result = false;
 840 
 841   const TypePtr* this_ptr = this-&gt;make_ptr(); // In case it is narrow_oop
 842   const TypePtr*    t_ptr =    t-&gt;make_ptr();
 843   if( this_ptr == NULL || t_ptr == NULL )
 844     return result;
 845 
 846   const TypeInstPtr* this_inst = this_ptr-&gt;isa_instptr();
 847   const TypeInstPtr*    t_inst =    t_ptr-&gt;isa_instptr();
 848   if( this_inst &amp;&amp; this_inst-&gt;is_loaded() &amp;&amp; t_inst &amp;&amp; t_inst-&gt;is_loaded() ) {
 849     bool this_interface = this_inst-&gt;klass()-&gt;is_interface();
 850     bool    t_interface =    t_inst-&gt;klass()-&gt;is_interface();
 851     result = this_interface ^ t_interface;
 852   }
 853 
 854   return result;
 855 }
 856 
 857 bool Type::interface_vs_oop(const Type *t) const {
 858   if (interface_vs_oop_helper(t)) {
 859     return true;
 860   }
 861   // Now check the speculative parts as well
 862   const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()-&gt;speculative() : NULL;
 863   const TypePtr* t_spec = t-&gt;isa_ptr() != NULL ? t-&gt;is_ptr()-&gt;speculative() : NULL;
 864   if (this_spec != NULL &amp;&amp; t_spec != NULL) {
 865     if (this_spec-&gt;interface_vs_oop_helper(t_spec)) {
 866       return true;
 867     }
 868     return false;
 869   }
 870   if (this_spec != NULL &amp;&amp; this_spec-&gt;interface_vs_oop_helper(t)) {
 871     return true;
 872   }
 873   if (t_spec != NULL &amp;&amp; interface_vs_oop_helper(t_spec)) {
 874     return true;
 875   }
 876   return false;
 877 }
 878 
 879 #endif
 880 
<a name="1" id="anc1"></a><span class="line-modified"> 881 //------------------------------meet-------------------------------------------</span>
<span class="line-removed"> 882 // Compute the MEET of two types.  NOT virtual.  It enforces that meet is</span>
<span class="line-removed"> 883 // commutative and the lattice is symmetric.</span>
<span class="line-removed"> 884 const Type *Type::meet_helper(const Type *t, bool include_speculative) const {</span>
<span class="line-removed"> 885   if (isa_narrowoop() &amp;&amp; t-&gt;isa_narrowoop()) {</span>
<span class="line-removed"> 886     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);</span>
<span class="line-removed"> 887     return result-&gt;make_narrowoop();</span>
<span class="line-removed"> 888   }</span>
<span class="line-removed"> 889   if (isa_narrowklass() &amp;&amp; t-&gt;isa_narrowklass()) {</span>
<span class="line-removed"> 890     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);</span>
<span class="line-removed"> 891     return result-&gt;make_narrowklass();</span>
<span class="line-removed"> 892   }</span>
<span class="line-removed"> 893 </span>
<span class="line-removed"> 894   const Type *this_t = maybe_remove_speculative(include_speculative);</span>
<span class="line-removed"> 895   t = t-&gt;maybe_remove_speculative(include_speculative);</span>
<span class="line-removed"> 896 </span>
<span class="line-removed"> 897   const Type *mt = this_t-&gt;xmeet(t);</span>
<span class="line-removed"> 898   if (isa_narrowoop() || t-&gt;isa_narrowoop()) return mt;</span>
<span class="line-removed"> 899   if (isa_narrowklass() || t-&gt;isa_narrowklass()) return mt;</span>
 900 #ifdef ASSERT
<a name="2" id="anc2"></a><span class="line-modified"> 901   assert(mt == t-&gt;xmeet(this_t), &quot;meet not commutative&quot;);</span>
 902   const Type* dual_join = mt-&gt;_dual;
 903   const Type *t2t    = dual_join-&gt;xmeet(t-&gt;_dual);
<a name="3" id="anc3"></a><span class="line-modified"> 904   const Type *t2this = dual_join-&gt;xmeet(this_t-&gt;_dual);</span>
 905 
 906   // Interface meet Oop is Not Symmetric:
 907   // Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull
 908   // Interface:NotNull meet Oop:NotNull == java/lang/Object:NotNull
 909 
<a name="4" id="anc4"></a><span class="line-modified"> 910   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this_t-&gt;_dual) ) {</span>

 911     tty-&gt;print_cr(&quot;=== Meet Not Symmetric ===&quot;);
 912     tty-&gt;print(&quot;t   =                   &quot;);              t-&gt;dump(); tty-&gt;cr();
<a name="5" id="anc5"></a><span class="line-modified"> 913     tty-&gt;print(&quot;this=                   &quot;);         this_t-&gt;dump(); tty-&gt;cr();</span>
 914     tty-&gt;print(&quot;mt=(t meet this)=       &quot;);             mt-&gt;dump(); tty-&gt;cr();
 915 
 916     tty-&gt;print(&quot;t_dual=                 &quot;);       t-&gt;_dual-&gt;dump(); tty-&gt;cr();
<a name="6" id="anc6"></a><span class="line-modified"> 917     tty-&gt;print(&quot;this_dual=              &quot;);  this_t-&gt;_dual-&gt;dump(); tty-&gt;cr();</span>
 918     tty-&gt;print(&quot;mt_dual=                &quot;);      mt-&gt;_dual-&gt;dump(); tty-&gt;cr();
 919 
 920     tty-&gt;print(&quot;mt_dual meet t_dual=    &quot;); t2t           -&gt;dump(); tty-&gt;cr();
 921     tty-&gt;print(&quot;mt_dual meet this_dual= &quot;); t2this        -&gt;dump(); tty-&gt;cr();
 922 
 923     fatal(&quot;meet not symmetric&quot; );
 924   }
<a name="7" id="anc7"></a>









































 925 #endif
 926   return mt;
 927 }
 928 
 929 //------------------------------xmeet------------------------------------------
 930 // Compute the MEET of two types.  It returns a new Type object.
 931 const Type *Type::xmeet( const Type *t ) const {
 932   // Perform a fast test for common case; meeting the same types together.
 933   if( this == t ) return this;  // Meeting same type-rep?
 934 
 935   // Meeting TOP with anything?
 936   if( _base == Top ) return t;
 937 
 938   // Meeting BOTTOM with anything?
 939   if( _base == Bottom ) return BOTTOM;
 940 
 941   // Current &quot;this-&gt;_base&quot; is one of: Bad, Multi, Control, Top,
 942   // Abio, Abstore, Floatxxx, Doublexxx, Bottom, lastype.
 943   switch (t-&gt;base()) {  // Switch on original type
 944 
 945   // Cut in half the number of cases I must handle.  Only need cases for when
 946   // the given enum &quot;t-&gt;type&quot; is less than or equal to the local enum &quot;type&quot;.
 947   case FloatCon:
 948   case DoubleCon:
 949   case Int:
 950   case Long:
 951     return t-&gt;xmeet(this);
 952 
 953   case OopPtr:
 954     return t-&gt;xmeet(this);
 955 
 956   case InstPtr:
 957     return t-&gt;xmeet(this);
 958 
 959   case MetadataPtr:
 960   case KlassPtr:
 961     return t-&gt;xmeet(this);
 962 
 963   case AryPtr:
 964     return t-&gt;xmeet(this);
 965 
 966   case NarrowOop:
 967     return t-&gt;xmeet(this);
 968 
 969   case NarrowKlass:
 970     return t-&gt;xmeet(this);
 971 
 972   case ValueType:
 973     return t-&gt;xmeet(this);
 974 
 975   case Bad:                     // Type check
 976   default:                      // Bogus type not in lattice
 977     typerr(t);
 978     return Type::BOTTOM;
 979 
 980   case Bottom:                  // Ye Olde Default
 981     return t;
 982 
 983   case FloatTop:
 984     if( _base == FloatTop ) return this;
 985   case FloatBot:                // Float
 986     if( _base == FloatBot || _base == FloatTop ) return FLOAT;
 987     if( _base == DoubleTop || _base == DoubleBot ) return Type::BOTTOM;
 988     typerr(t);
 989     return Type::BOTTOM;
 990 
 991   case DoubleTop:
 992     if( _base == DoubleTop ) return this;
 993   case DoubleBot:               // Double
 994     if( _base == DoubleBot || _base == DoubleTop ) return DOUBLE;
 995     if( _base == FloatTop || _base == FloatBot ) return Type::BOTTOM;
 996     typerr(t);
 997     return Type::BOTTOM;
 998 
 999   // These next few cases must match exactly or it is a compile-time error.
1000   case Control:                 // Control of code
1001   case Abio:                    // State of world outside of program
1002   case Memory:
1003     if( _base == t-&gt;_base )  return this;
1004     typerr(t);
1005     return Type::BOTTOM;
1006 
1007   case Top:                     // Top of the lattice
1008     return this;
1009   }
1010 
1011   // The type is unchanged
1012   return this;
1013 }
1014 
1015 //-----------------------------filter------------------------------------------
1016 const Type *Type::filter_helper(const Type *kills, bool include_speculative) const {
1017   const Type* ft = join_helper(kills, include_speculative);
1018   if (ft-&gt;empty())
1019     return Type::TOP;           // Canonical empty value
1020   return ft;
1021 }
1022 
1023 //------------------------------xdual------------------------------------------
1024 // Compute dual right now.
1025 const Type::TYPES Type::dual_type[Type::lastype] = {
1026   Bad,          // Bad
1027   Control,      // Control
1028   Bottom,       // Top
1029   Bad,          // Int - handled in v-call
1030   Bad,          // Long - handled in v-call
1031   Half,         // Half
1032   Bad,          // NarrowOop - handled in v-call
1033   Bad,          // NarrowKlass - handled in v-call
1034 
1035   Bad,          // Tuple - handled in v-call
1036   Bad,          // Array - handled in v-call
1037   Bad,          // VectorS - handled in v-call
1038   Bad,          // VectorD - handled in v-call
1039   Bad,          // VectorX - handled in v-call
1040   Bad,          // VectorY - handled in v-call
1041   Bad,          // VectorZ - handled in v-call
1042   Bad,          // ValueType - handled in v-call
1043 
1044   Bad,          // AnyPtr - handled in v-call
1045   Bad,          // RawPtr - handled in v-call
1046   Bad,          // OopPtr - handled in v-call
1047   Bad,          // InstPtr - handled in v-call
1048   Bad,          // AryPtr - handled in v-call
1049 
1050   Bad,          //  MetadataPtr - handled in v-call
1051   Bad,          // KlassPtr - handled in v-call
1052 
1053   Bad,          // Function - handled in v-call
1054   Abio,         // Abio
1055   Return_Address,// Return_Address
1056   Memory,       // Memory
1057   FloatBot,     // FloatTop
1058   FloatCon,     // FloatCon
1059   FloatTop,     // FloatBot
1060   DoubleBot,    // DoubleTop
1061   DoubleCon,    // DoubleCon
1062   DoubleTop,    // DoubleBot
1063   Top           // Bottom
1064 };
1065 
1066 const Type *Type::xdual() const {
1067   // Note: the base() accessor asserts the sanity of _base.
1068   assert(_type_info[base()].dual_type != Bad, &quot;implement with v-call&quot;);
1069   return new Type(_type_info[_base].dual_type);
1070 }
1071 
1072 //------------------------------has_memory-------------------------------------
1073 bool Type::has_memory() const {
1074   Type::TYPES tx = base();
1075   if (tx == Memory) return true;
1076   if (tx == Tuple) {
1077     const TypeTuple *t = is_tuple();
1078     for (uint i=0; i &lt; t-&gt;cnt(); i++) {
1079       tx = t-&gt;field_at(i)-&gt;base();
1080       if (tx == Memory)  return true;
1081     }
1082   }
1083   return false;
1084 }
1085 
1086 #ifndef PRODUCT
1087 //------------------------------dump2------------------------------------------
1088 void Type::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1089   st-&gt;print(&quot;%s&quot;, _type_info[_base].msg);
1090 }
1091 
1092 //------------------------------dump-------------------------------------------
1093 void Type::dump_on(outputStream *st) const {
1094   ResourceMark rm;
1095   Dict d(cmpkey,hashkey);       // Stop recursive type dumping
1096   dump2(d,1, st);
1097   if (is_ptr_to_narrowoop()) {
1098     st-&gt;print(&quot; [narrow]&quot;);
1099   } else if (is_ptr_to_narrowklass()) {
1100     st-&gt;print(&quot; [narrowklass]&quot;);
1101   }
1102 }
1103 
1104 //-----------------------------------------------------------------------------
1105 const char* Type::str(const Type* t) {
1106   stringStream ss;
1107   t-&gt;dump_on(&amp;ss);
1108   return ss.as_string();
1109 }
1110 #endif
1111 
1112 //------------------------------singleton--------------------------------------
1113 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1114 // constants (Ldi nodes).  Singletons are integer, float or double constants.
1115 bool Type::singleton(void) const {
1116   return _base == Top || _base == Half;
1117 }
1118 
1119 //------------------------------empty------------------------------------------
1120 // TRUE if Type is a type with no values, FALSE otherwise.
1121 bool Type::empty(void) const {
1122   switch (_base) {
1123   case DoubleTop:
1124   case FloatTop:
1125   case Top:
1126     return true;
1127 
1128   case Half:
1129   case Abio:
1130   case Return_Address:
1131   case Memory:
1132   case Bottom:
1133   case FloatBot:
1134   case DoubleBot:
1135     return false;  // never a singleton, therefore never empty
1136 
1137   default:
1138     ShouldNotReachHere();
1139     return false;
1140   }
1141 }
1142 
1143 //------------------------------dump_stats-------------------------------------
1144 // Dump collected statistics to stderr
1145 #ifndef PRODUCT
1146 void Type::dump_stats() {
1147   tty-&gt;print(&quot;Types made: %d\n&quot;, type_dict()-&gt;Size());
1148 }
1149 #endif
1150 
1151 //------------------------------typerr-----------------------------------------
1152 void Type::typerr( const Type *t ) const {
1153 #ifndef PRODUCT
1154   tty-&gt;print(&quot;\nError mixing types: &quot;);
1155   dump();
1156   tty-&gt;print(&quot; and &quot;);
1157   t-&gt;dump();
1158   tty-&gt;print(&quot;\n&quot;);
1159 #endif
1160   ShouldNotReachHere();
1161 }
1162 
1163 
1164 //=============================================================================
1165 // Convenience common pre-built types.
1166 const TypeF *TypeF::ZERO;       // Floating point zero
1167 const TypeF *TypeF::ONE;        // Floating point one
1168 const TypeF *TypeF::POS_INF;    // Floating point positive infinity
1169 const TypeF *TypeF::NEG_INF;    // Floating point negative infinity
1170 
1171 //------------------------------make-------------------------------------------
1172 // Create a float constant
1173 const TypeF *TypeF::make(float f) {
1174   return (TypeF*)(new TypeF(f))-&gt;hashcons();
1175 }
1176 
1177 //------------------------------meet-------------------------------------------
1178 // Compute the MEET of two types.  It returns a new Type object.
1179 const Type *TypeF::xmeet( const Type *t ) const {
1180   // Perform a fast test for common case; meeting the same types together.
1181   if( this == t ) return this;  // Meeting same type-rep?
1182 
1183   // Current &quot;this-&gt;_base&quot; is FloatCon
1184   switch (t-&gt;base()) {          // Switch on original type
1185   case AnyPtr:                  // Mixing with oops happens when javac
1186   case RawPtr:                  // reuses local variables
1187   case OopPtr:
1188   case InstPtr:
1189   case AryPtr:
1190   case MetadataPtr:
1191   case KlassPtr:
1192   case NarrowOop:
1193   case NarrowKlass:
1194   case Int:
1195   case Long:
1196   case DoubleTop:
1197   case DoubleCon:
1198   case DoubleBot:
1199   case Bottom:                  // Ye Olde Default
1200     return Type::BOTTOM;
1201 
1202   case FloatBot:
1203     return t;
1204 
1205   default:                      // All else is a mistake
1206     typerr(t);
1207 
1208   case FloatCon:                // Float-constant vs Float-constant?
1209     if( jint_cast(_f) != jint_cast(t-&gt;getf()) )         // unequal constants?
1210                                 // must compare bitwise as positive zero, negative zero and NaN have
1211                                 // all the same representation in C++
1212       return FLOAT;             // Return generic float
1213                                 // Equal constants
1214   case Top:
1215   case FloatTop:
1216     break;                      // Return the float constant
1217   }
1218   return this;                  // Return the float constant
1219 }
1220 
1221 //------------------------------xdual------------------------------------------
1222 // Dual: symmetric
1223 const Type *TypeF::xdual() const {
1224   return this;
1225 }
1226 
1227 //------------------------------eq---------------------------------------------
1228 // Structural equality check for Type representations
1229 bool TypeF::eq(const Type *t) const {
1230   // Bitwise comparison to distinguish between +/-0. These values must be treated
1231   // as different to be consistent with C1 and the interpreter.
1232   return (jint_cast(_f) == jint_cast(t-&gt;getf()));
1233 }
1234 
1235 //------------------------------hash-------------------------------------------
1236 // Type-specific hashing function.
1237 int TypeF::hash(void) const {
1238   return *(int*)(&amp;_f);
1239 }
1240 
1241 //------------------------------is_finite--------------------------------------
1242 // Has a finite value
1243 bool TypeF::is_finite() const {
1244   return g_isfinite(getf()) != 0;
1245 }
1246 
1247 //------------------------------is_nan-----------------------------------------
1248 // Is not a number (NaN)
1249 bool TypeF::is_nan()    const {
1250   return g_isnan(getf()) != 0;
1251 }
1252 
1253 //------------------------------dump2------------------------------------------
1254 // Dump float constant Type
1255 #ifndef PRODUCT
1256 void TypeF::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1257   Type::dump2(d,depth, st);
1258   st-&gt;print(&quot;%f&quot;, _f);
1259 }
1260 #endif
1261 
1262 //------------------------------singleton--------------------------------------
1263 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1264 // constants (Ldi nodes).  Singletons are integer, float or double constants
1265 // or a single symbol.
1266 bool TypeF::singleton(void) const {
1267   return true;                  // Always a singleton
1268 }
1269 
1270 bool TypeF::empty(void) const {
1271   return false;                 // always exactly a singleton
1272 }
1273 
1274 //=============================================================================
1275 // Convenience common pre-built types.
1276 const TypeD *TypeD::ZERO;       // Floating point zero
1277 const TypeD *TypeD::ONE;        // Floating point one
1278 const TypeD *TypeD::POS_INF;    // Floating point positive infinity
1279 const TypeD *TypeD::NEG_INF;    // Floating point negative infinity
1280 
1281 //------------------------------make-------------------------------------------
1282 const TypeD *TypeD::make(double d) {
1283   return (TypeD*)(new TypeD(d))-&gt;hashcons();
1284 }
1285 
1286 //------------------------------meet-------------------------------------------
1287 // Compute the MEET of two types.  It returns a new Type object.
1288 const Type *TypeD::xmeet( const Type *t ) const {
1289   // Perform a fast test for common case; meeting the same types together.
1290   if( this == t ) return this;  // Meeting same type-rep?
1291 
1292   // Current &quot;this-&gt;_base&quot; is DoubleCon
1293   switch (t-&gt;base()) {          // Switch on original type
1294   case AnyPtr:                  // Mixing with oops happens when javac
1295   case RawPtr:                  // reuses local variables
1296   case OopPtr:
1297   case InstPtr:
1298   case AryPtr:
1299   case MetadataPtr:
1300   case KlassPtr:
1301   case NarrowOop:
1302   case NarrowKlass:
1303   case Int:
1304   case Long:
1305   case FloatTop:
1306   case FloatCon:
1307   case FloatBot:
1308   case Bottom:                  // Ye Olde Default
1309     return Type::BOTTOM;
1310 
1311   case DoubleBot:
1312     return t;
1313 
1314   default:                      // All else is a mistake
1315     typerr(t);
1316 
1317   case DoubleCon:               // Double-constant vs Double-constant?
1318     if( jlong_cast(_d) != jlong_cast(t-&gt;getd()) )       // unequal constants? (see comment in TypeF::xmeet)
1319       return DOUBLE;            // Return generic double
1320   case Top:
1321   case DoubleTop:
1322     break;
1323   }
1324   return this;                  // Return the double constant
1325 }
1326 
1327 //------------------------------xdual------------------------------------------
1328 // Dual: symmetric
1329 const Type *TypeD::xdual() const {
1330   return this;
1331 }
1332 
1333 //------------------------------eq---------------------------------------------
1334 // Structural equality check for Type representations
1335 bool TypeD::eq(const Type *t) const {
1336   // Bitwise comparison to distinguish between +/-0. These values must be treated
1337   // as different to be consistent with C1 and the interpreter.
1338   return (jlong_cast(_d) == jlong_cast(t-&gt;getd()));
1339 }
1340 
1341 //------------------------------hash-------------------------------------------
1342 // Type-specific hashing function.
1343 int TypeD::hash(void) const {
1344   return *(int*)(&amp;_d);
1345 }
1346 
1347 //------------------------------is_finite--------------------------------------
1348 // Has a finite value
1349 bool TypeD::is_finite() const {
1350   return g_isfinite(getd()) != 0;
1351 }
1352 
1353 //------------------------------is_nan-----------------------------------------
1354 // Is not a number (NaN)
1355 bool TypeD::is_nan()    const {
1356   return g_isnan(getd()) != 0;
1357 }
1358 
1359 //------------------------------dump2------------------------------------------
1360 // Dump double constant Type
1361 #ifndef PRODUCT
1362 void TypeD::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1363   Type::dump2(d,depth,st);
1364   st-&gt;print(&quot;%f&quot;, _d);
1365 }
1366 #endif
1367 
1368 //------------------------------singleton--------------------------------------
1369 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1370 // constants (Ldi nodes).  Singletons are integer, float or double constants
1371 // or a single symbol.
1372 bool TypeD::singleton(void) const {
1373   return true;                  // Always a singleton
1374 }
1375 
1376 bool TypeD::empty(void) const {
1377   return false;                 // always exactly a singleton
1378 }
1379 
1380 //=============================================================================
1381 // Convience common pre-built types.
1382 const TypeInt *TypeInt::MINUS_1;// -1
1383 const TypeInt *TypeInt::ZERO;   // 0
1384 const TypeInt *TypeInt::ONE;    // 1
1385 const TypeInt *TypeInt::BOOL;   // 0 or 1, FALSE or TRUE.
1386 const TypeInt *TypeInt::CC;     // -1,0 or 1, condition codes
1387 const TypeInt *TypeInt::CC_LT;  // [-1]  == MINUS_1
1388 const TypeInt *TypeInt::CC_GT;  // [1]   == ONE
1389 const TypeInt *TypeInt::CC_EQ;  // [0]   == ZERO
1390 const TypeInt *TypeInt::CC_LE;  // [-1,0]
1391 const TypeInt *TypeInt::CC_GE;  // [0,1] == BOOL (!)
1392 const TypeInt *TypeInt::BYTE;   // Bytes, -128 to 127
1393 const TypeInt *TypeInt::UBYTE;  // Unsigned Bytes, 0 to 255
1394 const TypeInt *TypeInt::CHAR;   // Java chars, 0-65535
1395 const TypeInt *TypeInt::SHORT;  // Java shorts, -32768-32767
1396 const TypeInt *TypeInt::POS;    // Positive 32-bit integers or zero
1397 const TypeInt *TypeInt::POS1;   // Positive 32-bit integers
1398 const TypeInt *TypeInt::INT;    // 32-bit integers
1399 const TypeInt *TypeInt::SYMINT; // symmetric range [-max_jint..max_jint]
1400 const TypeInt *TypeInt::TYPE_DOMAIN; // alias for TypeInt::INT
1401 
1402 //------------------------------TypeInt----------------------------------------
1403 TypeInt::TypeInt( jint lo, jint hi, int w ) : Type(Int), _lo(lo), _hi(hi), _widen(w) {
1404 }
1405 
1406 //------------------------------make-------------------------------------------
1407 const TypeInt *TypeInt::make( jint lo ) {
1408   return (TypeInt*)(new TypeInt(lo,lo,WidenMin))-&gt;hashcons();
1409 }
1410 
1411 static int normalize_int_widen( jint lo, jint hi, int w ) {
1412   // Certain normalizations keep us sane when comparing types.
1413   // The &#39;SMALLINT&#39; covers constants and also CC and its relatives.
1414   if (lo &lt;= hi) {
1415     if (((juint)hi - lo) &lt;= SMALLINT)  w = Type::WidenMin;
1416     if (((juint)hi - lo) &gt;= max_juint) w = Type::WidenMax; // TypeInt::INT
1417   } else {
1418     if (((juint)lo - hi) &lt;= SMALLINT)  w = Type::WidenMin;
1419     if (((juint)lo - hi) &gt;= max_juint) w = Type::WidenMin; // dual TypeInt::INT
1420   }
1421   return w;
1422 }
1423 
1424 const TypeInt *TypeInt::make( jint lo, jint hi, int w ) {
1425   w = normalize_int_widen(lo, hi, w);
1426   return (TypeInt*)(new TypeInt(lo,hi,w))-&gt;hashcons();
1427 }
1428 
1429 //------------------------------meet-------------------------------------------
1430 // Compute the MEET of two types.  It returns a new Type representation object
1431 // with reference count equal to the number of Types pointing at it.
1432 // Caller should wrap a Types around it.
1433 const Type *TypeInt::xmeet( const Type *t ) const {
1434   // Perform a fast test for common case; meeting the same types together.
1435   if( this == t ) return this;  // Meeting same type?
1436 
1437   // Currently &quot;this-&gt;_base&quot; is a TypeInt
1438   switch (t-&gt;base()) {          // Switch on original type
1439   case AnyPtr:                  // Mixing with oops happens when javac
1440   case RawPtr:                  // reuses local variables
1441   case OopPtr:
1442   case InstPtr:
1443   case AryPtr:
1444   case MetadataPtr:
1445   case KlassPtr:
1446   case NarrowOop:
1447   case NarrowKlass:
1448   case Long:
1449   case FloatTop:
1450   case FloatCon:
1451   case FloatBot:
1452   case DoubleTop:
1453   case DoubleCon:
1454   case DoubleBot:
1455   case Bottom:                  // Ye Olde Default
1456     return Type::BOTTOM;
1457   default:                      // All else is a mistake
1458     typerr(t);
1459   case Top:                     // No change
1460     return this;
1461   case Int:                     // Int vs Int?
1462     break;
1463   }
1464 
1465   // Expand covered set
1466   const TypeInt *r = t-&gt;is_int();
1467   return make( MIN2(_lo,r-&gt;_lo), MAX2(_hi,r-&gt;_hi), MAX2(_widen,r-&gt;_widen) );
1468 }
1469 
1470 //------------------------------xdual------------------------------------------
1471 // Dual: reverse hi &amp; lo; flip widen
1472 const Type *TypeInt::xdual() const {
1473   int w = normalize_int_widen(_hi,_lo, WidenMax-_widen);
1474   return new TypeInt(_hi,_lo,w);
1475 }
1476 
1477 //------------------------------widen------------------------------------------
1478 // Only happens for optimistic top-down optimizations.
1479 const Type *TypeInt::widen( const Type *old, const Type* limit ) const {
1480   // Coming from TOP or such; no widening
1481   if( old-&gt;base() != Int ) return this;
1482   const TypeInt *ot = old-&gt;is_int();
1483 
1484   // If new guy is equal to old guy, no widening
1485   if( _lo == ot-&gt;_lo &amp;&amp; _hi == ot-&gt;_hi )
1486     return old;
1487 
1488   // If new guy contains old, then we widened
1489   if( _lo &lt;= ot-&gt;_lo &amp;&amp; _hi &gt;= ot-&gt;_hi ) {
1490     // New contains old
1491     // If new guy is already wider than old, no widening
1492     if( _widen &gt; ot-&gt;_widen ) return this;
1493     // If old guy was a constant, do not bother
1494     if (ot-&gt;_lo == ot-&gt;_hi)  return this;
1495     // Now widen new guy.
1496     // Check for widening too far
1497     if (_widen == WidenMax) {
1498       int max = max_jint;
1499       int min = min_jint;
1500       if (limit-&gt;isa_int()) {
1501         max = limit-&gt;is_int()-&gt;_hi;
1502         min = limit-&gt;is_int()-&gt;_lo;
1503       }
1504       if (min &lt; _lo &amp;&amp; _hi &lt; max) {
1505         // If neither endpoint is extremal yet, push out the endpoint
1506         // which is closer to its respective limit.
1507         if (_lo &gt;= 0 ||                 // easy common case
1508             (juint)(_lo - min) &gt;= (juint)(max - _hi)) {
1509           // Try to widen to an unsigned range type of 31 bits:
1510           return make(_lo, max, WidenMax);
1511         } else {
1512           return make(min, _hi, WidenMax);
1513         }
1514       }
1515       return TypeInt::INT;
1516     }
1517     // Returned widened new guy
1518     return make(_lo,_hi,_widen+1);
1519   }
1520 
1521   // If old guy contains new, then we probably widened too far &amp; dropped to
1522   // bottom.  Return the wider fellow.
1523   if ( ot-&gt;_lo &lt;= _lo &amp;&amp; ot-&gt;_hi &gt;= _hi )
1524     return old;
1525 
1526   //fatal(&quot;Integer value range is not subset&quot;);
1527   //return this;
1528   return TypeInt::INT;
1529 }
1530 
1531 //------------------------------narrow---------------------------------------
1532 // Only happens for pessimistic optimizations.
1533 const Type *TypeInt::narrow( const Type *old ) const {
1534   if (_lo &gt;= _hi)  return this;   // already narrow enough
1535   if (old == NULL)  return this;
1536   const TypeInt* ot = old-&gt;isa_int();
1537   if (ot == NULL)  return this;
1538   jint olo = ot-&gt;_lo;
1539   jint ohi = ot-&gt;_hi;
1540 
1541   // If new guy is equal to old guy, no narrowing
1542   if (_lo == olo &amp;&amp; _hi == ohi)  return old;
1543 
1544   // If old guy was maximum range, allow the narrowing
1545   if (olo == min_jint &amp;&amp; ohi == max_jint)  return this;
1546 
1547   if (_lo &lt; olo || _hi &gt; ohi)
1548     return this;                // doesn&#39;t narrow; pretty wierd
1549 
1550   // The new type narrows the old type, so look for a &quot;death march&quot;.
1551   // See comments on PhaseTransform::saturate.
1552   juint nrange = (juint)_hi - _lo;
1553   juint orange = (juint)ohi - olo;
1554   if (nrange &lt; max_juint - 1 &amp;&amp; nrange &gt; (orange &gt;&gt; 1) + (SMALLINT*2)) {
1555     // Use the new type only if the range shrinks a lot.
1556     // We do not want the optimizer computing 2^31 point by point.
1557     return old;
1558   }
1559 
1560   return this;
1561 }
1562 
1563 //-----------------------------filter------------------------------------------
1564 const Type *TypeInt::filter_helper(const Type *kills, bool include_speculative) const {
1565   const TypeInt* ft = join_helper(kills, include_speculative)-&gt;isa_int();
1566   if (ft == NULL || ft-&gt;empty())
1567     return Type::TOP;           // Canonical empty value
1568   if (ft-&gt;_widen &lt; this-&gt;_widen) {
1569     // Do not allow the value of kill-&gt;_widen to affect the outcome.
1570     // The widen bits must be allowed to run freely through the graph.
1571     ft = TypeInt::make(ft-&gt;_lo, ft-&gt;_hi, this-&gt;_widen);
1572   }
1573   return ft;
1574 }
1575 
1576 //------------------------------eq---------------------------------------------
1577 // Structural equality check for Type representations
1578 bool TypeInt::eq( const Type *t ) const {
1579   const TypeInt *r = t-&gt;is_int(); // Handy access
1580   return r-&gt;_lo == _lo &amp;&amp; r-&gt;_hi == _hi &amp;&amp; r-&gt;_widen == _widen;
1581 }
1582 
1583 //------------------------------hash-------------------------------------------
1584 // Type-specific hashing function.
1585 int TypeInt::hash(void) const {
1586   return java_add(java_add(_lo, _hi), java_add((jint)_widen, (jint)Type::Int));
1587 }
1588 
1589 //------------------------------is_finite--------------------------------------
1590 // Has a finite value
1591 bool TypeInt::is_finite() const {
1592   return true;
1593 }
1594 
1595 //------------------------------dump2------------------------------------------
1596 // Dump TypeInt
1597 #ifndef PRODUCT
1598 static const char* intname(char* buf, jint n) {
1599   if (n == min_jint)
1600     return &quot;min&quot;;
1601   else if (n &lt; min_jint + 10000)
1602     sprintf(buf, &quot;min+&quot; INT32_FORMAT, n - min_jint);
1603   else if (n == max_jint)
1604     return &quot;max&quot;;
1605   else if (n &gt; max_jint - 10000)
1606     sprintf(buf, &quot;max-&quot; INT32_FORMAT, max_jint - n);
1607   else
1608     sprintf(buf, INT32_FORMAT, n);
1609   return buf;
1610 }
1611 
1612 void TypeInt::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1613   char buf[40], buf2[40];
1614   if (_lo == min_jint &amp;&amp; _hi == max_jint)
1615     st-&gt;print(&quot;int&quot;);
1616   else if (is_con())
1617     st-&gt;print(&quot;int:%s&quot;, intname(buf, get_con()));
1618   else if (_lo == BOOL-&gt;_lo &amp;&amp; _hi == BOOL-&gt;_hi)
1619     st-&gt;print(&quot;bool&quot;);
1620   else if (_lo == BYTE-&gt;_lo &amp;&amp; _hi == BYTE-&gt;_hi)
1621     st-&gt;print(&quot;byte&quot;);
1622   else if (_lo == CHAR-&gt;_lo &amp;&amp; _hi == CHAR-&gt;_hi)
1623     st-&gt;print(&quot;char&quot;);
1624   else if (_lo == SHORT-&gt;_lo &amp;&amp; _hi == SHORT-&gt;_hi)
1625     st-&gt;print(&quot;short&quot;);
1626   else if (_hi == max_jint)
1627     st-&gt;print(&quot;int:&gt;=%s&quot;, intname(buf, _lo));
1628   else if (_lo == min_jint)
1629     st-&gt;print(&quot;int:&lt;=%s&quot;, intname(buf, _hi));
1630   else
1631     st-&gt;print(&quot;int:%s..%s&quot;, intname(buf, _lo), intname(buf2, _hi));
1632 
1633   if (_widen != 0 &amp;&amp; this != TypeInt::INT)
1634     st-&gt;print(&quot;:%.*s&quot;, _widen, &quot;wwww&quot;);
1635 }
1636 #endif
1637 
1638 //------------------------------singleton--------------------------------------
1639 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1640 // constants.
1641 bool TypeInt::singleton(void) const {
1642   return _lo &gt;= _hi;
1643 }
1644 
1645 bool TypeInt::empty(void) const {
1646   return _lo &gt; _hi;
1647 }
1648 
1649 //=============================================================================
1650 // Convenience common pre-built types.
1651 const TypeLong *TypeLong::MINUS_1;// -1
1652 const TypeLong *TypeLong::ZERO; // 0
1653 const TypeLong *TypeLong::ONE;  // 1
1654 const TypeLong *TypeLong::POS;  // &gt;=0
1655 const TypeLong *TypeLong::LONG; // 64-bit integers
1656 const TypeLong *TypeLong::INT;  // 32-bit subrange
1657 const TypeLong *TypeLong::UINT; // 32-bit unsigned subrange
1658 const TypeLong *TypeLong::TYPE_DOMAIN; // alias for TypeLong::LONG
1659 
1660 //------------------------------TypeLong---------------------------------------
1661 TypeLong::TypeLong( jlong lo, jlong hi, int w ) : Type(Long), _lo(lo), _hi(hi), _widen(w) {
1662 }
1663 
1664 //------------------------------make-------------------------------------------
1665 const TypeLong *TypeLong::make( jlong lo ) {
1666   return (TypeLong*)(new TypeLong(lo,lo,WidenMin))-&gt;hashcons();
1667 }
1668 
1669 static int normalize_long_widen( jlong lo, jlong hi, int w ) {
1670   // Certain normalizations keep us sane when comparing types.
1671   // The &#39;SMALLINT&#39; covers constants.
1672   if (lo &lt;= hi) {
1673     if (((julong)hi - lo) &lt;= SMALLINT)   w = Type::WidenMin;
1674     if (((julong)hi - lo) &gt;= max_julong) w = Type::WidenMax; // TypeLong::LONG
1675   } else {
1676     if (((julong)lo - hi) &lt;= SMALLINT)   w = Type::WidenMin;
1677     if (((julong)lo - hi) &gt;= max_julong) w = Type::WidenMin; // dual TypeLong::LONG
1678   }
1679   return w;
1680 }
1681 
1682 const TypeLong *TypeLong::make( jlong lo, jlong hi, int w ) {
1683   w = normalize_long_widen(lo, hi, w);
1684   return (TypeLong*)(new TypeLong(lo,hi,w))-&gt;hashcons();
1685 }
1686 
1687 
1688 //------------------------------meet-------------------------------------------
1689 // Compute the MEET of two types.  It returns a new Type representation object
1690 // with reference count equal to the number of Types pointing at it.
1691 // Caller should wrap a Types around it.
1692 const Type *TypeLong::xmeet( const Type *t ) const {
1693   // Perform a fast test for common case; meeting the same types together.
1694   if( this == t ) return this;  // Meeting same type?
1695 
1696   // Currently &quot;this-&gt;_base&quot; is a TypeLong
1697   switch (t-&gt;base()) {          // Switch on original type
1698   case AnyPtr:                  // Mixing with oops happens when javac
1699   case RawPtr:                  // reuses local variables
1700   case OopPtr:
1701   case InstPtr:
1702   case AryPtr:
1703   case MetadataPtr:
1704   case KlassPtr:
1705   case NarrowOop:
1706   case NarrowKlass:
1707   case Int:
1708   case FloatTop:
1709   case FloatCon:
1710   case FloatBot:
1711   case DoubleTop:
1712   case DoubleCon:
1713   case DoubleBot:
1714   case Bottom:                  // Ye Olde Default
1715     return Type::BOTTOM;
1716   default:                      // All else is a mistake
1717     typerr(t);
1718   case Top:                     // No change
1719     return this;
1720   case Long:                    // Long vs Long?
1721     break;
1722   }
1723 
1724   // Expand covered set
1725   const TypeLong *r = t-&gt;is_long(); // Turn into a TypeLong
1726   return make( MIN2(_lo,r-&gt;_lo), MAX2(_hi,r-&gt;_hi), MAX2(_widen,r-&gt;_widen) );
1727 }
1728 
1729 //------------------------------xdual------------------------------------------
1730 // Dual: reverse hi &amp; lo; flip widen
1731 const Type *TypeLong::xdual() const {
1732   int w = normalize_long_widen(_hi,_lo, WidenMax-_widen);
1733   return new TypeLong(_hi,_lo,w);
1734 }
1735 
1736 //------------------------------widen------------------------------------------
1737 // Only happens for optimistic top-down optimizations.
1738 const Type *TypeLong::widen( const Type *old, const Type* limit ) const {
1739   // Coming from TOP or such; no widening
1740   if( old-&gt;base() != Long ) return this;
1741   const TypeLong *ot = old-&gt;is_long();
1742 
1743   // If new guy is equal to old guy, no widening
1744   if( _lo == ot-&gt;_lo &amp;&amp; _hi == ot-&gt;_hi )
1745     return old;
1746 
1747   // If new guy contains old, then we widened
1748   if( _lo &lt;= ot-&gt;_lo &amp;&amp; _hi &gt;= ot-&gt;_hi ) {
1749     // New contains old
1750     // If new guy is already wider than old, no widening
1751     if( _widen &gt; ot-&gt;_widen ) return this;
1752     // If old guy was a constant, do not bother
1753     if (ot-&gt;_lo == ot-&gt;_hi)  return this;
1754     // Now widen new guy.
1755     // Check for widening too far
1756     if (_widen == WidenMax) {
1757       jlong max = max_jlong;
1758       jlong min = min_jlong;
1759       if (limit-&gt;isa_long()) {
1760         max = limit-&gt;is_long()-&gt;_hi;
1761         min = limit-&gt;is_long()-&gt;_lo;
1762       }
1763       if (min &lt; _lo &amp;&amp; _hi &lt; max) {
1764         // If neither endpoint is extremal yet, push out the endpoint
1765         // which is closer to its respective limit.
1766         if (_lo &gt;= 0 ||                 // easy common case
1767             ((julong)_lo - min) &gt;= ((julong)max - _hi)) {
1768           // Try to widen to an unsigned range type of 32/63 bits:
1769           if (max &gt;= max_juint &amp;&amp; _hi &lt; max_juint)
1770             return make(_lo, max_juint, WidenMax);
1771           else
1772             return make(_lo, max, WidenMax);
1773         } else {
1774           return make(min, _hi, WidenMax);
1775         }
1776       }
1777       return TypeLong::LONG;
1778     }
1779     // Returned widened new guy
1780     return make(_lo,_hi,_widen+1);
1781   }
1782 
1783   // If old guy contains new, then we probably widened too far &amp; dropped to
1784   // bottom.  Return the wider fellow.
1785   if ( ot-&gt;_lo &lt;= _lo &amp;&amp; ot-&gt;_hi &gt;= _hi )
1786     return old;
1787 
1788   //  fatal(&quot;Long value range is not subset&quot;);
1789   // return this;
1790   return TypeLong::LONG;
1791 }
1792 
1793 //------------------------------narrow----------------------------------------
1794 // Only happens for pessimistic optimizations.
1795 const Type *TypeLong::narrow( const Type *old ) const {
1796   if (_lo &gt;= _hi)  return this;   // already narrow enough
1797   if (old == NULL)  return this;
1798   const TypeLong* ot = old-&gt;isa_long();
1799   if (ot == NULL)  return this;
1800   jlong olo = ot-&gt;_lo;
1801   jlong ohi = ot-&gt;_hi;
1802 
1803   // If new guy is equal to old guy, no narrowing
1804   if (_lo == olo &amp;&amp; _hi == ohi)  return old;
1805 
1806   // If old guy was maximum range, allow the narrowing
1807   if (olo == min_jlong &amp;&amp; ohi == max_jlong)  return this;
1808 
1809   if (_lo &lt; olo || _hi &gt; ohi)
1810     return this;                // doesn&#39;t narrow; pretty wierd
1811 
1812   // The new type narrows the old type, so look for a &quot;death march&quot;.
1813   // See comments on PhaseTransform::saturate.
1814   julong nrange = _hi - _lo;
1815   julong orange = ohi - olo;
1816   if (nrange &lt; max_julong - 1 &amp;&amp; nrange &gt; (orange &gt;&gt; 1) + (SMALLINT*2)) {
1817     // Use the new type only if the range shrinks a lot.
1818     // We do not want the optimizer computing 2^31 point by point.
1819     return old;
1820   }
1821 
1822   return this;
1823 }
1824 
1825 //-----------------------------filter------------------------------------------
1826 const Type *TypeLong::filter_helper(const Type *kills, bool include_speculative) const {
1827   const TypeLong* ft = join_helper(kills, include_speculative)-&gt;isa_long();
1828   if (ft == NULL || ft-&gt;empty())
1829     return Type::TOP;           // Canonical empty value
1830   if (ft-&gt;_widen &lt; this-&gt;_widen) {
1831     // Do not allow the value of kill-&gt;_widen to affect the outcome.
1832     // The widen bits must be allowed to run freely through the graph.
1833     ft = TypeLong::make(ft-&gt;_lo, ft-&gt;_hi, this-&gt;_widen);
1834   }
1835   return ft;
1836 }
1837 
1838 //------------------------------eq---------------------------------------------
1839 // Structural equality check for Type representations
1840 bool TypeLong::eq( const Type *t ) const {
1841   const TypeLong *r = t-&gt;is_long(); // Handy access
1842   return r-&gt;_lo == _lo &amp;&amp;  r-&gt;_hi == _hi  &amp;&amp; r-&gt;_widen == _widen;
1843 }
1844 
1845 //------------------------------hash-------------------------------------------
1846 // Type-specific hashing function.
1847 int TypeLong::hash(void) const {
1848   return (int)(_lo+_hi+_widen+(int)Type::Long);
1849 }
1850 
1851 //------------------------------is_finite--------------------------------------
1852 // Has a finite value
1853 bool TypeLong::is_finite() const {
1854   return true;
1855 }
1856 
1857 //------------------------------dump2------------------------------------------
1858 // Dump TypeLong
1859 #ifndef PRODUCT
1860 static const char* longnamenear(jlong x, const char* xname, char* buf, jlong n) {
1861   if (n &gt; x) {
1862     if (n &gt;= x + 10000)  return NULL;
1863     sprintf(buf, &quot;%s+&quot; JLONG_FORMAT, xname, n - x);
1864   } else if (n &lt; x) {
1865     if (n &lt;= x - 10000)  return NULL;
1866     sprintf(buf, &quot;%s-&quot; JLONG_FORMAT, xname, x - n);
1867   } else {
1868     return xname;
1869   }
1870   return buf;
1871 }
1872 
1873 static const char* longname(char* buf, jlong n) {
1874   const char* str;
1875   if (n == min_jlong)
1876     return &quot;min&quot;;
1877   else if (n &lt; min_jlong + 10000)
1878     sprintf(buf, &quot;min+&quot; JLONG_FORMAT, n - min_jlong);
1879   else if (n == max_jlong)
1880     return &quot;max&quot;;
1881   else if (n &gt; max_jlong - 10000)
1882     sprintf(buf, &quot;max-&quot; JLONG_FORMAT, max_jlong - n);
1883   else if ((str = longnamenear(max_juint, &quot;maxuint&quot;, buf, n)) != NULL)
1884     return str;
1885   else if ((str = longnamenear(max_jint, &quot;maxint&quot;, buf, n)) != NULL)
1886     return str;
1887   else if ((str = longnamenear(min_jint, &quot;minint&quot;, buf, n)) != NULL)
1888     return str;
1889   else
1890     sprintf(buf, JLONG_FORMAT, n);
1891   return buf;
1892 }
1893 
1894 void TypeLong::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1895   char buf[80], buf2[80];
1896   if (_lo == min_jlong &amp;&amp; _hi == max_jlong)
1897     st-&gt;print(&quot;long&quot;);
1898   else if (is_con())
1899     st-&gt;print(&quot;long:%s&quot;, longname(buf, get_con()));
1900   else if (_hi == max_jlong)
1901     st-&gt;print(&quot;long:&gt;=%s&quot;, longname(buf, _lo));
1902   else if (_lo == min_jlong)
1903     st-&gt;print(&quot;long:&lt;=%s&quot;, longname(buf, _hi));
1904   else
1905     st-&gt;print(&quot;long:%s..%s&quot;, longname(buf, _lo), longname(buf2, _hi));
1906 
1907   if (_widen != 0 &amp;&amp; this != TypeLong::LONG)
1908     st-&gt;print(&quot;:%.*s&quot;, _widen, &quot;wwww&quot;);
1909 }
1910 #endif
1911 
1912 //------------------------------singleton--------------------------------------
1913 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1914 // constants
1915 bool TypeLong::singleton(void) const {
1916   return _lo &gt;= _hi;
1917 }
1918 
1919 bool TypeLong::empty(void) const {
1920   return _lo &gt; _hi;
1921 }
1922 
1923 //=============================================================================
1924 // Convenience common pre-built types.
1925 const TypeTuple *TypeTuple::IFBOTH;     // Return both arms of IF as reachable
1926 const TypeTuple *TypeTuple::IFFALSE;
1927 const TypeTuple *TypeTuple::IFTRUE;
1928 const TypeTuple *TypeTuple::IFNEITHER;
1929 const TypeTuple *TypeTuple::LOOPBODY;
1930 const TypeTuple *TypeTuple::MEMBAR;
1931 const TypeTuple *TypeTuple::STORECONDITIONAL;
1932 const TypeTuple *TypeTuple::START_I2C;
1933 const TypeTuple *TypeTuple::INT_PAIR;
1934 const TypeTuple *TypeTuple::LONG_PAIR;
1935 const TypeTuple *TypeTuple::INT_CC_PAIR;
1936 const TypeTuple *TypeTuple::LONG_CC_PAIR;
1937 
1938 static void collect_value_fields(ciValueKlass* vk, const Type** field_array, uint&amp; pos, ExtendedSignature&amp; sig_cc) {
1939   for (int j = 0; j &lt; vk-&gt;nof_nonstatic_fields(); j++) {
1940     ciField* field = vk-&gt;nonstatic_field_at(j);
1941     BasicType bt = field-&gt;type()-&gt;basic_type();
1942     const Type* ft = Type::get_const_type(field-&gt;type());
1943     field_array[pos++] = ft;
1944     if (type2size[bt] == 2) {
1945       field_array[pos++] = Type::HALF;
1946     }
1947     // Skip reserved arguments
1948     while (SigEntry::next_is_reserved(sig_cc, bt)) {
1949       field_array[pos++] = Type::get_const_basic_type(bt);
1950       if (type2size[bt] == 2) {
1951         field_array[pos++] = Type::HALF;
1952       }
1953     }
1954   }
1955 }
1956 
1957 //------------------------------make-------------------------------------------
1958 // Make a TypeTuple from the range of a method signature
1959 const TypeTuple *TypeTuple::make_range(ciSignature* sig, bool ret_vt_fields) {
1960   ciType* return_type = sig-&gt;return_type();
1961   uint arg_cnt = return_type-&gt;size();
1962   if (ret_vt_fields) {
1963     arg_cnt = return_type-&gt;as_value_klass()-&gt;value_arg_slots() + 1;
1964   }
1965 
1966   const Type **field_array = fields(arg_cnt);
1967   switch (return_type-&gt;basic_type()) {
1968   case T_LONG:
1969     field_array[TypeFunc::Parms]   = TypeLong::LONG;
1970     field_array[TypeFunc::Parms+1] = Type::HALF;
1971     break;
1972   case T_DOUBLE:
1973     field_array[TypeFunc::Parms]   = Type::DOUBLE;
1974     field_array[TypeFunc::Parms+1] = Type::HALF;
1975     break;
1976   case T_OBJECT:
1977   case T_ARRAY:
1978   case T_BOOLEAN:
1979   case T_CHAR:
1980   case T_FLOAT:
1981   case T_BYTE:
1982   case T_SHORT:
1983   case T_INT:
1984     field_array[TypeFunc::Parms] = get_const_type(return_type);
1985     break;
1986   case T_VALUETYPE:
1987     if (ret_vt_fields) {
1988       uint pos = TypeFunc::Parms;
1989       field_array[pos] = TypePtr::BOTTOM;
1990       pos++;
1991       ExtendedSignature sig = ExtendedSignature(NULL, SigEntryFilter());
1992       collect_value_fields(return_type-&gt;as_value_klass(), field_array, pos, sig);
1993     } else {
1994       field_array[TypeFunc::Parms] = get_const_type(return_type)-&gt;join_speculative(sig-&gt;returns_never_null() ? TypePtr::NOTNULL : TypePtr::BOTTOM);
1995     }
1996     break;
1997   case T_VOID:
1998     break;
1999   default:
2000     ShouldNotReachHere();
2001   }
2002   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
2003 }
2004 
2005 // Make a TypeTuple from the domain of a method signature
2006 const TypeTuple *TypeTuple::make_domain(ciMethod* method, bool vt_fields_as_args) {
2007   ciSignature* sig = method-&gt;signature();
2008   ExtendedSignature sig_cc = ExtendedSignature(vt_fields_as_args ? method-&gt;get_sig_cc() : NULL, SigEntryFilter());
2009 
2010   uint arg_cnt = sig-&gt;size() + (method-&gt;is_static() ? 0 : 1);
2011   if (vt_fields_as_args) {
2012     for (arg_cnt = 0; !sig_cc.at_end(); ++sig_cc) {
2013       arg_cnt += type2size[(*sig_cc)._bt];
2014     }
2015     sig_cc = ExtendedSignature(method-&gt;get_sig_cc(), SigEntryFilter());
2016   }
2017 
2018   uint pos = TypeFunc::Parms;
2019   const Type** field_array = fields(arg_cnt);
2020   if (!method-&gt;is_static()) {
2021     ciInstanceKlass* recv = method-&gt;holder();
2022     if (vt_fields_as_args &amp;&amp; recv-&gt;is_valuetype() &amp;&amp; recv-&gt;as_value_klass()-&gt;is_scalarizable()) {
2023       collect_value_fields(recv-&gt;as_value_klass(), field_array, pos, sig_cc);
2024     } else {
2025       field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);
2026       if (vt_fields_as_args) {
2027         ++sig_cc;
2028       }
2029     }
2030   }
2031 
2032   int i = 0;
2033   while (pos &lt; TypeFunc::Parms + arg_cnt) {
2034     ciType* type = sig-&gt;type_at(i);
2035     BasicType bt = type-&gt;basic_type();
2036     bool is_flattened = false;
2037 
2038     switch (bt) {
2039     case T_LONG:
2040       field_array[pos++] = TypeLong::LONG;
2041       field_array[pos++] = Type::HALF;
2042       break;
2043     case T_DOUBLE:
2044       field_array[pos++] = Type::DOUBLE;
2045       field_array[pos++] = Type::HALF;
2046       break;
2047     case T_OBJECT:
2048     case T_ARRAY:
2049     case T_FLOAT:
2050     case T_INT:
2051       field_array[pos++] = get_const_type(type);
2052       break;
2053     case T_BOOLEAN:
2054     case T_CHAR:
2055     case T_BYTE:
2056     case T_SHORT:
2057       field_array[pos++] = TypeInt::INT;
2058       break;
2059     case T_VALUETYPE: {
2060       bool never_null = sig-&gt;is_never_null_at(i);
2061       if (vt_fields_as_args &amp;&amp; type-&gt;as_value_klass()-&gt;is_scalarizable() &amp;&amp; never_null) {
2062         is_flattened = true;
2063         collect_value_fields(type-&gt;as_value_klass(), field_array, pos, sig_cc);
2064       } else {
2065         field_array[pos++] = get_const_type(type)-&gt;join_speculative(never_null ? TypePtr::NOTNULL : TypePtr::BOTTOM);
2066       }
2067       break;
2068     }
2069     default:
2070       ShouldNotReachHere();
2071     }
2072     // Skip reserved arguments
2073     while (!is_flattened &amp;&amp; SigEntry::next_is_reserved(sig_cc, bt)) {
2074       field_array[pos++] = Type::get_const_basic_type(bt);
2075       if (type2size[bt] == 2) {
2076         field_array[pos++] = Type::HALF;
2077       }
2078     }
2079     i++;
2080   }
2081   assert(pos == TypeFunc::Parms + arg_cnt, &quot;wrong number of arguments&quot;);
2082 
2083   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
2084 }
2085 
2086 const TypeTuple *TypeTuple::make( uint cnt, const Type **fields ) {
2087   return (TypeTuple*)(new TypeTuple(cnt,fields))-&gt;hashcons();
2088 }
2089 
2090 //------------------------------fields-----------------------------------------
2091 // Subroutine call type with space allocated for argument types
2092 // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
2093 const Type **TypeTuple::fields( uint arg_cnt ) {
2094   const Type **flds = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4((TypeFunc::Parms+arg_cnt)*sizeof(Type*) ));
2095   flds[TypeFunc::Control  ] = Type::CONTROL;
2096   flds[TypeFunc::I_O      ] = Type::ABIO;
2097   flds[TypeFunc::Memory   ] = Type::MEMORY;
2098   flds[TypeFunc::FramePtr ] = TypeRawPtr::BOTTOM;
2099   flds[TypeFunc::ReturnAdr] = Type::RETURN_ADDRESS;
2100 
2101   return flds;
2102 }
2103 
2104 //------------------------------meet-------------------------------------------
2105 // Compute the MEET of two types.  It returns a new Type object.
2106 const Type *TypeTuple::xmeet( const Type *t ) const {
2107   // Perform a fast test for common case; meeting the same types together.
2108   if( this == t ) return this;  // Meeting same type-rep?
2109 
2110   // Current &quot;this-&gt;_base&quot; is Tuple
2111   switch (t-&gt;base()) {          // switch on original type
2112 
2113   case Bottom:                  // Ye Olde Default
2114     return t;
2115 
2116   default:                      // All else is a mistake
2117     typerr(t);
2118 
2119   case Tuple: {                 // Meeting 2 signatures?
2120     const TypeTuple *x = t-&gt;is_tuple();
2121     assert( _cnt == x-&gt;_cnt, &quot;&quot; );
2122     const Type **fields = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4( _cnt*sizeof(Type*) ));
2123     for( uint i=0; i&lt;_cnt; i++ )
2124       fields[i] = field_at(i)-&gt;xmeet( x-&gt;field_at(i) );
2125     return TypeTuple::make(_cnt,fields);
2126   }
2127   case Top:
2128     break;
2129   }
2130   return this;                  // Return the double constant
2131 }
2132 
2133 //------------------------------xdual------------------------------------------
2134 // Dual: compute field-by-field dual
2135 const Type *TypeTuple::xdual() const {
2136   const Type **fields = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4( _cnt*sizeof(Type*) ));
2137   for( uint i=0; i&lt;_cnt; i++ )
2138     fields[i] = _fields[i]-&gt;dual();
2139   return new TypeTuple(_cnt,fields);
2140 }
2141 
2142 //------------------------------eq---------------------------------------------
2143 // Structural equality check for Type representations
2144 bool TypeTuple::eq( const Type *t ) const {
2145   const TypeTuple *s = (const TypeTuple *)t;
2146   if (_cnt != s-&gt;_cnt)  return false;  // Unequal field counts
2147   for (uint i = 0; i &lt; _cnt; i++)
2148     if (field_at(i) != s-&gt;field_at(i)) // POINTER COMPARE!  NO RECURSION!
2149       return false;             // Missed
2150   return true;
2151 }
2152 
2153 //------------------------------hash-------------------------------------------
2154 // Type-specific hashing function.
2155 int TypeTuple::hash(void) const {
2156   intptr_t sum = _cnt;
2157   for( uint i=0; i&lt;_cnt; i++ )
2158     sum += (intptr_t)_fields[i];     // Hash on pointers directly
2159   return sum;
2160 }
2161 
2162 //------------------------------dump2------------------------------------------
2163 // Dump signature Type
2164 #ifndef PRODUCT
2165 void TypeTuple::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2166   st-&gt;print(&quot;{&quot;);
2167   if( !depth || d[this] ) {     // Check for recursive print
2168     st-&gt;print(&quot;...}&quot;);
2169     return;
2170   }
2171   d.Insert((void*)this, (void*)this);   // Stop recursion
2172   if( _cnt ) {
2173     uint i;
2174     for( i=0; i&lt;_cnt-1; i++ ) {
2175       st-&gt;print(&quot;%d:&quot;, i);
2176       _fields[i]-&gt;dump2(d, depth-1, st);
2177       st-&gt;print(&quot;, &quot;);
2178     }
2179     st-&gt;print(&quot;%d:&quot;, i);
2180     _fields[i]-&gt;dump2(d, depth-1, st);
2181   }
2182   st-&gt;print(&quot;}&quot;);
2183 }
2184 #endif
2185 
2186 //------------------------------singleton--------------------------------------
2187 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2188 // constants (Ldi nodes).  Singletons are integer, float or double constants
2189 // or a single symbol.
2190 bool TypeTuple::singleton(void) const {
2191   return false;                 // Never a singleton
2192 }
2193 
2194 bool TypeTuple::empty(void) const {
2195   for( uint i=0; i&lt;_cnt; i++ ) {
2196     if (_fields[i]-&gt;empty())  return true;
2197   }
2198   return false;
2199 }
2200 
2201 //=============================================================================
2202 // Convenience common pre-built types.
2203 
2204 inline const TypeInt* normalize_array_size(const TypeInt* size) {
2205   // Certain normalizations keep us sane when comparing types.
2206   // We do not want arrayOop variables to differ only by the wideness
2207   // of their index types.  Pick minimum wideness, since that is the
2208   // forced wideness of small ranges anyway.
2209   if (size-&gt;_widen != Type::WidenMin)
2210     return TypeInt::make(size-&gt;_lo, size-&gt;_hi, Type::WidenMin);
2211   else
2212     return size;
2213 }
2214 
2215 //------------------------------make-------------------------------------------
2216 const TypeAry* TypeAry::make(const Type* elem, const TypeInt* size, bool stable,
2217                              bool not_flat, bool not_null_free) {
2218   if (UseCompressedOops &amp;&amp; elem-&gt;isa_oopptr()) {
2219     elem = elem-&gt;make_narrowoop();
2220   }
2221   size = normalize_array_size(size);
2222   return (TypeAry*)(new TypeAry(elem, size, stable, not_flat, not_null_free))-&gt;hashcons();
2223 }
2224 
2225 //------------------------------meet-------------------------------------------
2226 // Compute the MEET of two types.  It returns a new Type object.
2227 const Type *TypeAry::xmeet( const Type *t ) const {
2228   // Perform a fast test for common case; meeting the same types together.
2229   if( this == t ) return this;  // Meeting same type-rep?
2230 
2231   // Current &quot;this-&gt;_base&quot; is Ary
2232   switch (t-&gt;base()) {          // switch on original type
2233 
2234   case Bottom:                  // Ye Olde Default
2235     return t;
2236 
2237   default:                      // All else is a mistake
2238     typerr(t);
2239 
2240   case Array: {                 // Meeting 2 arrays?
2241     const TypeAry *a = t-&gt;is_ary();
2242     return TypeAry::make(_elem-&gt;meet_speculative(a-&gt;_elem),
2243                          _size-&gt;xmeet(a-&gt;_size)-&gt;is_int(),
2244                          _stable &amp;&amp; a-&gt;_stable,
2245                          _not_flat &amp;&amp; a-&gt;_not_flat,
2246                          _not_null_free &amp;&amp; a-&gt;_not_null_free);
2247   }
2248   case Top:
2249     break;
2250   }
2251   return this;                  // Return the double constant
2252 }
2253 
2254 //------------------------------xdual------------------------------------------
2255 // Dual: compute field-by-field dual
2256 const Type *TypeAry::xdual() const {
2257   const TypeInt* size_dual = _size-&gt;dual()-&gt;is_int();
2258   size_dual = normalize_array_size(size_dual);
2259   return new TypeAry(_elem-&gt;dual(), size_dual, !_stable, !_not_flat, !_not_null_free);
2260 }
2261 
2262 //------------------------------eq---------------------------------------------
2263 // Structural equality check for Type representations
2264 bool TypeAry::eq( const Type *t ) const {
2265   const TypeAry *a = (const TypeAry*)t;
2266   return _elem == a-&gt;_elem &amp;&amp;
2267     _stable == a-&gt;_stable &amp;&amp;
2268     _size == a-&gt;_size &amp;&amp;
2269     _not_flat == a-&gt;_not_flat &amp;&amp;
2270     _not_null_free == a-&gt;_not_null_free;
2271 
2272 }
2273 
2274 //------------------------------hash-------------------------------------------
2275 // Type-specific hashing function.
2276 int TypeAry::hash(void) const {
2277   return (intptr_t)_elem + (intptr_t)_size + (_stable ? 43 : 0);
2278 }
2279 
2280 /**
2281  * Return same type without a speculative part in the element
2282  */
2283 const Type* TypeAry::remove_speculative() const {
2284   return make(_elem-&gt;remove_speculative(), _size, _stable, _not_flat, _not_null_free);
2285 }
2286 
2287 /**
2288  * Return same type with cleaned up speculative part of element
2289  */
2290 const Type* TypeAry::cleanup_speculative() const {
2291   return make(_elem-&gt;cleanup_speculative(), _size, _stable, _not_flat, _not_null_free);
2292 }
2293 
2294 /**
2295  * Return same type but with a different inline depth (used for speculation)
2296  *
2297  * @param depth  depth to meet with
2298  */
2299 const TypePtr* TypePtr::with_inline_depth(int depth) const {
2300   if (!UseInlineDepthForSpeculativeTypes) {
2301     return this;
2302   }
2303   return make(AnyPtr, _ptr, _offset, _speculative, depth);
2304 }
2305 
2306 //----------------------interface_vs_oop---------------------------------------
2307 #ifdef ASSERT
2308 bool TypeAry::interface_vs_oop(const Type *t) const {
2309   const TypeAry* t_ary = t-&gt;is_ary();
2310   if (t_ary) {
2311     const TypePtr* this_ptr = _elem-&gt;make_ptr(); // In case we have narrow_oops
2312     const TypePtr*    t_ptr = t_ary-&gt;_elem-&gt;make_ptr();
2313     if(this_ptr != NULL &amp;&amp; t_ptr != NULL) {
2314       return this_ptr-&gt;interface_vs_oop(t_ptr);
2315     }
2316   }
2317   return false;
2318 }
2319 #endif
2320 
2321 //------------------------------dump2------------------------------------------
2322 #ifndef PRODUCT
2323 void TypeAry::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2324   if (_stable)  st-&gt;print(&quot;stable:&quot;);
2325   if (Verbose) {
2326     if (_not_flat) st-&gt;print(&quot;not flat:&quot;);
2327     if (_not_null_free) st-&gt;print(&quot;not null free:&quot;);
2328   }
2329   _elem-&gt;dump2(d, depth, st);
2330   st-&gt;print(&quot;[&quot;);
2331   _size-&gt;dump2(d, depth, st);
2332   st-&gt;print(&quot;]&quot;);
2333 }
2334 #endif
2335 
2336 //------------------------------singleton--------------------------------------
2337 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2338 // constants (Ldi nodes).  Singletons are integer, float or double constants
2339 // or a single symbol.
2340 bool TypeAry::singleton(void) const {
2341   return false;                 // Never a singleton
2342 }
2343 
2344 bool TypeAry::empty(void) const {
2345   return _elem-&gt;empty() || _size-&gt;empty();
2346 }
2347 
2348 //--------------------------ary_must_be_exact----------------------------------
2349 bool TypeAry::ary_must_be_exact() const {
2350   if (!UseExactTypes)       return false;
2351   // This logic looks at the element type of an array, and returns true
2352   // if the element type is either a primitive or a final instance class.
2353   // In such cases, an array built on this ary must have no subclasses.
2354   if (_elem == BOTTOM)      return false;  // general array not exact
2355   if (_elem == TOP   )      return false;  // inverted general array not exact
2356   const TypeOopPtr*  toop = NULL;
2357   if (UseCompressedOops &amp;&amp; _elem-&gt;isa_narrowoop()) {
2358     toop = _elem-&gt;make_ptr()-&gt;isa_oopptr();
2359   } else {
2360     toop = _elem-&gt;isa_oopptr();
2361   }
2362   if (!toop)                return true;   // a primitive type, like int
2363   ciKlass* tklass = toop-&gt;klass();
2364   if (tklass == NULL)       return false;  // unloaded class
2365   if (!tklass-&gt;is_loaded()) return false;  // unloaded class
2366   const TypeInstPtr* tinst;
2367   if (_elem-&gt;isa_narrowoop())
2368     tinst = _elem-&gt;make_ptr()-&gt;isa_instptr();
2369   else
2370     tinst = _elem-&gt;isa_instptr();
2371   if (tinst) {
2372     // [V? has a subtype: [V. So even though V is final, [V? is not exact.
2373     if (tklass-&gt;as_instance_klass()-&gt;is_final()) {
2374       if (tinst-&gt;is_valuetypeptr() &amp;&amp; (tinst-&gt;ptr() == TypePtr::BotPTR || tinst-&gt;ptr() == TypePtr::TopPTR)) {
2375         return false;
2376       }
2377       return true;
2378     }
2379     return false;
2380   }
2381   const TypeAryPtr*  tap;
2382   if (_elem-&gt;isa_narrowoop())
2383     tap = _elem-&gt;make_ptr()-&gt;isa_aryptr();
2384   else
2385     tap = _elem-&gt;isa_aryptr();
2386   if (tap)
2387     return tap-&gt;ary()-&gt;ary_must_be_exact();
2388   return false;
2389 }
2390 
2391 //==============================TypeValueType=======================================
2392 
2393 const TypeValueType *TypeValueType::BOTTOM;
2394 
2395 //------------------------------make-------------------------------------------
2396 const TypeValueType* TypeValueType::make(ciValueKlass* vk, bool larval) {
2397   return (TypeValueType*)(new TypeValueType(vk, larval))-&gt;hashcons();
2398 }
2399 
2400 //------------------------------meet-------------------------------------------
2401 // Compute the MEET of two types.  It returns a new Type object.
2402 const Type* TypeValueType::xmeet(const Type* t) const {
2403   // Perform a fast test for common case; meeting the same types together.
2404   if(this == t) return this;  // Meeting same type-rep?
2405 
2406   // Current &quot;this-&gt;_base&quot; is ValueType
2407   switch (t-&gt;base()) {          // switch on original type
2408 
2409   case Int:
2410   case Long:
2411   case FloatTop:
2412   case FloatCon:
2413   case FloatBot:
2414   case DoubleTop:
2415   case DoubleCon:
2416   case DoubleBot:
2417   case NarrowKlass:
2418   case Bottom:
2419     return Type::BOTTOM;
2420 
2421   case OopPtr:
2422   case MetadataPtr:
2423   case KlassPtr:
2424   case RawPtr:
2425     return TypePtr::BOTTOM;
2426 
2427   case Top:
2428     return this;
2429 
2430   case NarrowOop: {
2431     const Type* res = t-&gt;make_ptr()-&gt;xmeet(this);
2432     if (res-&gt;isa_ptr()) {
2433       return res-&gt;make_narrowoop();
2434     }
2435     return res;
2436   }
2437 
2438   case AryPtr:
2439   case InstPtr: {
2440     return t-&gt;xmeet(this);
2441   }
2442 
2443   case ValueType: {
2444     // All value types inherit from Object
2445     const TypeValueType* other = t-&gt;is_valuetype();
2446     if (_vk == NULL) {
2447       return this;
2448     } else if (other-&gt;_vk == NULL) {
2449       return other;
2450     } else if (_vk == other-&gt;_vk) {
2451       if (_larval == other-&gt;_larval ||
2452           !_larval) {
2453         return this;
2454       } else {
2455         return t;
2456       }
2457     }
2458     return TypeInstPtr::NOTNULL;
2459   }
2460 
2461   default:                      // All else is a mistake
2462     typerr(t);
2463 
2464   }
2465   return this;
2466 }
2467 
2468 //------------------------------xdual------------------------------------------
2469 const Type* TypeValueType::xdual() const {
2470   return this;
2471 }
2472 
2473 //------------------------------eq---------------------------------------------
2474 // Structural equality check for Type representations
2475 bool TypeValueType::eq(const Type* t) const {
2476   const TypeValueType* vt = t-&gt;is_valuetype();
2477   return (_vk == vt-&gt;value_klass() &amp;&amp; _larval == vt-&gt;larval());
2478 }
2479 
2480 //------------------------------hash-------------------------------------------
2481 // Type-specific hashing function.
2482 int TypeValueType::hash(void) const {
2483   return (intptr_t)_vk;
2484 }
2485 
2486 //------------------------------singleton--------------------------------------
2487 // TRUE if Type is a singleton type, FALSE otherwise. Singletons are simple constants.
2488 bool TypeValueType::singleton(void) const {
2489   return false;
2490 }
2491 
2492 //------------------------------empty------------------------------------------
2493 // TRUE if Type is a type with no values, FALSE otherwise.
2494 bool TypeValueType::empty(void) const {
2495   return false;
2496 }
2497 
2498 //------------------------------dump2------------------------------------------
2499 #ifndef PRODUCT
2500 void TypeValueType::dump2(Dict &amp;d, uint depth, outputStream* st) const {
2501   if (_vk == NULL) {
2502     st-&gt;print(&quot;BOTTOM valuetype&quot;);
2503     return;
2504   }
2505   int count = _vk-&gt;nof_declared_nonstatic_fields();
2506   st-&gt;print(&quot;valuetype[%d]:{&quot;, count);
2507   st-&gt;print(&quot;%s&quot;, count != 0 ? _vk-&gt;declared_nonstatic_field_at(0)-&gt;type()-&gt;name() : &quot;empty&quot;);
2508   for (int i = 1; i &lt; count; ++i) {
2509     st-&gt;print(&quot;, %s&quot;, _vk-&gt;declared_nonstatic_field_at(i)-&gt;type()-&gt;name());
2510   }
2511   st-&gt;print(&quot;}%s&quot;, _larval?&quot; : larval&quot;:&quot;&quot;);
2512 }
2513 #endif
2514 
2515 //==============================TypeVect=======================================
2516 // Convenience common pre-built types.
2517 const TypeVect *TypeVect::VECTS = NULL; //  32-bit vectors
2518 const TypeVect *TypeVect::VECTD = NULL; //  64-bit vectors
2519 const TypeVect *TypeVect::VECTX = NULL; // 128-bit vectors
2520 const TypeVect *TypeVect::VECTY = NULL; // 256-bit vectors
2521 const TypeVect *TypeVect::VECTZ = NULL; // 512-bit vectors
2522 
2523 //------------------------------make-------------------------------------------
2524 const TypeVect* TypeVect::make(const Type *elem, uint length) {
2525   BasicType elem_bt = elem-&gt;array_element_basic_type();
2526   assert(is_java_primitive(elem_bt), &quot;only primitive types in vector&quot;);
2527   assert(length &gt; 1 &amp;&amp; is_power_of_2(length), &quot;vector length is power of 2&quot;);
2528   assert(Matcher::vector_size_supported(elem_bt, length), &quot;length in range&quot;);
2529   int size = length * type2aelembytes(elem_bt);
2530   switch (Matcher::vector_ideal_reg(size)) {
2531   case Op_VecS:
2532     return (TypeVect*)(new TypeVectS(elem, length))-&gt;hashcons();
2533   case Op_RegL:
2534   case Op_VecD:
2535   case Op_RegD:
2536     return (TypeVect*)(new TypeVectD(elem, length))-&gt;hashcons();
2537   case Op_VecX:
2538     return (TypeVect*)(new TypeVectX(elem, length))-&gt;hashcons();
2539   case Op_VecY:
2540     return (TypeVect*)(new TypeVectY(elem, length))-&gt;hashcons();
2541   case Op_VecZ:
2542     return (TypeVect*)(new TypeVectZ(elem, length))-&gt;hashcons();
2543   }
2544  ShouldNotReachHere();
2545   return NULL;
2546 }
2547 
2548 //------------------------------meet-------------------------------------------
2549 // Compute the MEET of two types.  It returns a new Type object.
2550 const Type *TypeVect::xmeet( const Type *t ) const {
2551   // Perform a fast test for common case; meeting the same types together.
2552   if( this == t ) return this;  // Meeting same type-rep?
2553 
2554   // Current &quot;this-&gt;_base&quot; is Vector
2555   switch (t-&gt;base()) {          // switch on original type
2556 
2557   case Bottom:                  // Ye Olde Default
2558     return t;
2559 
2560   default:                      // All else is a mistake
2561     typerr(t);
2562 
2563   case VectorS:
2564   case VectorD:
2565   case VectorX:
2566   case VectorY:
2567   case VectorZ: {                // Meeting 2 vectors?
2568     const TypeVect* v = t-&gt;is_vect();
2569     assert(  base() == v-&gt;base(), &quot;&quot;);
2570     assert(length() == v-&gt;length(), &quot;&quot;);
2571     assert(element_basic_type() == v-&gt;element_basic_type(), &quot;&quot;);
2572     return TypeVect::make(_elem-&gt;xmeet(v-&gt;_elem), _length);
2573   }
2574   case Top:
2575     break;
2576   }
2577   return this;
2578 }
2579 
2580 //------------------------------xdual------------------------------------------
2581 // Dual: compute field-by-field dual
2582 const Type *TypeVect::xdual() const {
2583   return new TypeVect(base(), _elem-&gt;dual(), _length);
2584 }
2585 
2586 //------------------------------eq---------------------------------------------
2587 // Structural equality check for Type representations
2588 bool TypeVect::eq(const Type *t) const {
2589   const TypeVect *v = t-&gt;is_vect();
2590   return (_elem == v-&gt;_elem) &amp;&amp; (_length == v-&gt;_length);
2591 }
2592 
2593 //------------------------------hash-------------------------------------------
2594 // Type-specific hashing function.
2595 int TypeVect::hash(void) const {
2596   return (intptr_t)_elem + (intptr_t)_length;
2597 }
2598 
2599 //------------------------------singleton--------------------------------------
2600 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2601 // constants (Ldi nodes).  Vector is singleton if all elements are the same
2602 // constant value (when vector is created with Replicate code).
2603 bool TypeVect::singleton(void) const {
2604 // There is no Con node for vectors yet.
2605 //  return _elem-&gt;singleton();
2606   return false;
2607 }
2608 
2609 bool TypeVect::empty(void) const {
2610   return _elem-&gt;empty();
2611 }
2612 
2613 //------------------------------dump2------------------------------------------
2614 #ifndef PRODUCT
2615 void TypeVect::dump2(Dict &amp;d, uint depth, outputStream *st) const {
2616   switch (base()) {
2617   case VectorS:
2618     st-&gt;print(&quot;vectors[&quot;); break;
2619   case VectorD:
2620     st-&gt;print(&quot;vectord[&quot;); break;
2621   case VectorX:
2622     st-&gt;print(&quot;vectorx[&quot;); break;
2623   case VectorY:
2624     st-&gt;print(&quot;vectory[&quot;); break;
2625   case VectorZ:
2626     st-&gt;print(&quot;vectorz[&quot;); break;
2627   default:
2628     ShouldNotReachHere();
2629   }
2630   st-&gt;print(&quot;%d]:{&quot;, _length);
2631   _elem-&gt;dump2(d, depth, st);
2632   st-&gt;print(&quot;}&quot;);
2633 }
2634 #endif
2635 
2636 
2637 //=============================================================================
2638 // Convenience common pre-built types.
2639 const TypePtr *TypePtr::NULL_PTR;
2640 const TypePtr *TypePtr::NOTNULL;
2641 const TypePtr *TypePtr::BOTTOM;
2642 
2643 //------------------------------meet-------------------------------------------
2644 // Meet over the PTR enum
2645 const TypePtr::PTR TypePtr::ptr_meet[TypePtr::lastPTR][TypePtr::lastPTR] = {
2646   //              TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,
2647   { /* Top     */ TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,},
2648   { /* AnyNull */ AnyNull,   AnyNull,   Constant, BotPTR, NotNull, BotPTR,},
2649   { /* Constant*/ Constant,  Constant,  Constant, BotPTR, NotNull, BotPTR,},
2650   { /* Null    */ Null,      BotPTR,    BotPTR,   Null,   BotPTR,  BotPTR,},
2651   { /* NotNull */ NotNull,   NotNull,   NotNull,  BotPTR, NotNull, BotPTR,},
2652   { /* BotPTR  */ BotPTR,    BotPTR,    BotPTR,   BotPTR, BotPTR,  BotPTR,}
2653 };
2654 
2655 //------------------------------make-------------------------------------------
2656 const TypePtr* TypePtr::make(TYPES t, enum PTR ptr, Offset offset, const TypePtr* speculative, int inline_depth) {
2657   return (TypePtr*)(new TypePtr(t,ptr,offset, speculative, inline_depth))-&gt;hashcons();
2658 }
2659 
2660 //------------------------------cast_to_ptr_type-------------------------------
2661 const Type *TypePtr::cast_to_ptr_type(PTR ptr) const {
2662   assert(_base == AnyPtr, &quot;subclass must override cast_to_ptr_type&quot;);
2663   if( ptr == _ptr ) return this;
2664   return make(_base, ptr, _offset, _speculative, _inline_depth);
2665 }
2666 
2667 //------------------------------get_con----------------------------------------
2668 intptr_t TypePtr::get_con() const {
2669   assert( _ptr == Null, &quot;&quot; );
2670   return offset();
2671 }
2672 
2673 //------------------------------meet-------------------------------------------
2674 // Compute the MEET of two types.  It returns a new Type object.
2675 const Type *TypePtr::xmeet(const Type *t) const {
2676   const Type* res = xmeet_helper(t);
2677   if (res-&gt;isa_ptr() == NULL) {
2678     return res;
2679   }
2680 
2681   const TypePtr* res_ptr = res-&gt;is_ptr();
2682   if (res_ptr-&gt;speculative() != NULL) {
2683     // type-&gt;speculative() == NULL means that speculation is no better
2684     // than type, i.e. type-&gt;speculative() == type. So there are 2
2685     // ways to represent the fact that we have no useful speculative
2686     // data and we should use a single one to be able to test for
2687     // equality between types. Check whether type-&gt;speculative() ==
2688     // type and set speculative to NULL if it is the case.
2689     if (res_ptr-&gt;remove_speculative() == res_ptr-&gt;speculative()) {
2690       return res_ptr-&gt;remove_speculative();
2691     }
2692   }
2693 
2694   return res;
2695 }
2696 
2697 const Type *TypePtr::xmeet_helper(const Type *t) const {
2698   // Perform a fast test for common case; meeting the same types together.
2699   if( this == t ) return this;  // Meeting same type-rep?
2700 
2701   // Current &quot;this-&gt;_base&quot; is AnyPtr
2702   switch (t-&gt;base()) {          // switch on original type
2703   case Int:                     // Mixing ints &amp; oops happens when javac
2704   case Long:                    // reuses local variables
2705   case FloatTop:
2706   case FloatCon:
2707   case FloatBot:
2708   case DoubleTop:
2709   case DoubleCon:
2710   case DoubleBot:
2711   case NarrowOop:
2712   case NarrowKlass:
2713   case Bottom:                  // Ye Olde Default
2714     return Type::BOTTOM;
2715   case Top:
2716     return this;
2717 
2718   case AnyPtr: {                // Meeting to AnyPtrs
2719     const TypePtr *tp = t-&gt;is_ptr();
2720     const TypePtr* speculative = xmeet_speculative(tp);
2721     int depth = meet_inline_depth(tp-&gt;inline_depth());
2722     return make(AnyPtr, meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), speculative, depth);
2723   }
2724   case RawPtr:                  // For these, flip the call around to cut down
2725   case OopPtr:
2726   case InstPtr:                 // on the cases I have to handle.
2727   case AryPtr:
2728   case MetadataPtr:
2729   case KlassPtr:
2730     return t-&gt;xmeet(this);      // Call in reverse direction
2731   default:                      // All else is a mistake
2732     typerr(t);
2733 
2734   }
2735   return this;
2736 }
2737 
2738 //------------------------------meet_offset------------------------------------
2739 Type::Offset TypePtr::meet_offset(int offset) const {
2740   return _offset.meet(Offset(offset));
2741 }
2742 
2743 //------------------------------dual_offset------------------------------------
2744 Type::Offset TypePtr::dual_offset() const {
2745   return _offset.dual();
2746 }
2747 
2748 //------------------------------xdual------------------------------------------
2749 // Dual: compute field-by-field dual
2750 const TypePtr::PTR TypePtr::ptr_dual[TypePtr::lastPTR] = {
2751   BotPTR, NotNull, Constant, Null, AnyNull, TopPTR
2752 };
2753 const Type *TypePtr::xdual() const {
2754   return new TypePtr(AnyPtr, dual_ptr(), dual_offset(), dual_speculative(), dual_inline_depth());
2755 }
2756 
2757 //------------------------------xadd_offset------------------------------------
2758 Type::Offset TypePtr::xadd_offset(intptr_t offset) const {
2759   return _offset.add(offset);
2760 }
2761 
2762 //------------------------------add_offset-------------------------------------
2763 const TypePtr *TypePtr::add_offset( intptr_t offset ) const {
2764   return make(AnyPtr, _ptr, xadd_offset(offset), _speculative, _inline_depth);
2765 }
2766 
2767 //------------------------------eq---------------------------------------------
2768 // Structural equality check for Type representations
2769 bool TypePtr::eq( const Type *t ) const {
2770   const TypePtr *a = (const TypePtr*)t;
2771   return _ptr == a-&gt;ptr() &amp;&amp; _offset == a-&gt;_offset &amp;&amp; eq_speculative(a) &amp;&amp; _inline_depth == a-&gt;_inline_depth;
2772 }
2773 
2774 //------------------------------hash-------------------------------------------
2775 // Type-specific hashing function.
2776 int TypePtr::hash(void) const {
2777   return java_add(java_add((jint)_ptr, (jint)offset()), java_add((jint)hash_speculative(), (jint)_inline_depth));
2778 ;
2779 }
2780 
2781 /**
2782  * Return same type without a speculative part
2783  */
2784 const Type* TypePtr::remove_speculative() const {
2785   if (_speculative == NULL) {
2786     return this;
2787   }
2788   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
2789   return make(AnyPtr, _ptr, _offset, NULL, _inline_depth);
2790 }
2791 
2792 /**
2793  * Return same type but drop speculative part if we know we won&#39;t use
2794  * it
2795  */
2796 const Type* TypePtr::cleanup_speculative() const {
2797   if (speculative() == NULL) {
2798     return this;
2799   }
2800   const Type* no_spec = remove_speculative();
2801   // If this is NULL_PTR then we don&#39;t need the speculative type
2802   // (with_inline_depth in case the current type inline depth is
2803   // InlineDepthTop)
2804   if (no_spec == NULL_PTR-&gt;with_inline_depth(inline_depth())) {
2805     return no_spec;
2806   }
2807   if (above_centerline(speculative()-&gt;ptr())) {
2808     return no_spec;
2809   }
2810   const TypeOopPtr* spec_oopptr = speculative()-&gt;isa_oopptr();
2811   // If the speculative may be null and is an inexact klass then it
2812   // doesn&#39;t help
2813   if (speculative() != TypePtr::NULL_PTR &amp;&amp; speculative()-&gt;maybe_null() &amp;&amp;
2814       (spec_oopptr == NULL || !spec_oopptr-&gt;klass_is_exact())) {
2815     return no_spec;
2816   }
2817   return this;
2818 }
2819 
2820 /**
2821  * dual of the speculative part of the type
2822  */
2823 const TypePtr* TypePtr::dual_speculative() const {
2824   if (_speculative == NULL) {
2825     return NULL;
2826   }
2827   return _speculative-&gt;dual()-&gt;is_ptr();
2828 }
2829 
2830 /**
2831  * meet of the speculative parts of 2 types
2832  *
2833  * @param other  type to meet with
2834  */
2835 const TypePtr* TypePtr::xmeet_speculative(const TypePtr* other) const {
2836   bool this_has_spec = (_speculative != NULL);
2837   bool other_has_spec = (other-&gt;speculative() != NULL);
2838 
2839   if (!this_has_spec &amp;&amp; !other_has_spec) {
2840     return NULL;
2841   }
2842 
2843   // If we are at a point where control flow meets and one branch has
2844   // a speculative type and the other has not, we meet the speculative
2845   // type of one branch with the actual type of the other. If the
2846   // actual type is exact and the speculative is as well, then the
2847   // result is a speculative type which is exact and we can continue
2848   // speculation further.
2849   const TypePtr* this_spec = _speculative;
2850   const TypePtr* other_spec = other-&gt;speculative();
2851 
2852   if (!this_has_spec) {
2853     this_spec = this;
2854   }
2855 
2856   if (!other_has_spec) {
2857     other_spec = other;
2858   }
2859 
2860   return this_spec-&gt;meet(other_spec)-&gt;is_ptr();
2861 }
2862 
2863 /**
2864  * dual of the inline depth for this type (used for speculation)
2865  */
2866 int TypePtr::dual_inline_depth() const {
2867   return -inline_depth();
2868 }
2869 
2870 /**
2871  * meet of 2 inline depths (used for speculation)
2872  *
2873  * @param depth  depth to meet with
2874  */
2875 int TypePtr::meet_inline_depth(int depth) const {
2876   return MAX2(inline_depth(), depth);
2877 }
2878 
2879 /**
2880  * Are the speculative parts of 2 types equal?
2881  *
2882  * @param other  type to compare this one to
2883  */
2884 bool TypePtr::eq_speculative(const TypePtr* other) const {
2885   if (_speculative == NULL || other-&gt;speculative() == NULL) {
2886     return _speculative == other-&gt;speculative();
2887   }
2888 
2889   if (_speculative-&gt;base() != other-&gt;speculative()-&gt;base()) {
2890     return false;
2891   }
2892 
2893   return _speculative-&gt;eq(other-&gt;speculative());
2894 }
2895 
2896 /**
2897  * Hash of the speculative part of the type
2898  */
2899 int TypePtr::hash_speculative() const {
2900   if (_speculative == NULL) {
2901     return 0;
2902   }
2903 
2904   return _speculative-&gt;hash();
2905 }
2906 
2907 /**
2908  * add offset to the speculative part of the type
2909  *
2910  * @param offset  offset to add
2911  */
2912 const TypePtr* TypePtr::add_offset_speculative(intptr_t offset) const {
2913   if (_speculative == NULL) {
2914     return NULL;
2915   }
2916   return _speculative-&gt;add_offset(offset)-&gt;is_ptr();
2917 }
2918 
2919 /**
2920  * return exact klass from the speculative type if there&#39;s one
2921  */
2922 ciKlass* TypePtr::speculative_type() const {
2923   if (_speculative != NULL &amp;&amp; _speculative-&gt;isa_oopptr()) {
2924     const TypeOopPtr* speculative = _speculative-&gt;join(this)-&gt;is_oopptr();
2925     if (speculative-&gt;klass_is_exact()) {
2926       return speculative-&gt;klass();
2927     }
2928   }
2929   return NULL;
2930 }
2931 
2932 /**
2933  * return true if speculative type may be null
2934  */
2935 bool TypePtr::speculative_maybe_null() const {
2936   if (_speculative != NULL) {
2937     const TypePtr* speculative = _speculative-&gt;join(this)-&gt;is_ptr();
2938     return speculative-&gt;maybe_null();
2939   }
2940   return true;
2941 }
2942 
2943 bool TypePtr::speculative_always_null() const {
2944   if (_speculative != NULL) {
2945     const TypePtr* speculative = _speculative-&gt;join(this)-&gt;is_ptr();
2946     return speculative == TypePtr::NULL_PTR;
2947   }
2948   return false;
2949 }
2950 
2951 /**
2952  * Same as TypePtr::speculative_type() but return the klass only if
2953  * the speculative tells us is not null
2954  */
2955 ciKlass* TypePtr::speculative_type_not_null() const {
2956   if (speculative_maybe_null()) {
2957     return NULL;
2958   }
2959   return speculative_type();
2960 }
2961 
2962 /**
2963  * Check whether new profiling would improve speculative type
2964  *
2965  * @param   exact_kls    class from profiling
2966  * @param   inline_depth inlining depth of profile point
2967  *
2968  * @return  true if type profile is valuable
2969  */
2970 bool TypePtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
2971   // no profiling?
2972   if (exact_kls == NULL) {
2973     return false;
2974   }
2975   if (speculative() == TypePtr::NULL_PTR) {
2976     return false;
2977   }
2978   // no speculative type or non exact speculative type?
2979   if (speculative_type() == NULL) {
2980     return true;
2981   }
2982   // If the node already has an exact speculative type keep it,
2983   // unless it was provided by profiling that is at a deeper
2984   // inlining level. Profiling at a higher inlining depth is
2985   // expected to be less accurate.
2986   if (_speculative-&gt;inline_depth() == InlineDepthBottom) {
2987     return false;
2988   }
2989   assert(_speculative-&gt;inline_depth() != InlineDepthTop, &quot;can&#39;t do the comparison&quot;);
2990   return inline_depth &lt; _speculative-&gt;inline_depth();
2991 }
2992 
2993 /**
2994  * Check whether new profiling would improve ptr (= tells us it is non
2995  * null)
2996  *
2997  * @param   ptr_kind always null or not null?
2998  *
2999  * @return  true if ptr profile is valuable
3000  */
3001 bool TypePtr::would_improve_ptr(ProfilePtrKind ptr_kind) const {
3002   // profiling doesn&#39;t tell us anything useful
3003   if (ptr_kind != ProfileAlwaysNull &amp;&amp; ptr_kind != ProfileNeverNull) {
3004     return false;
3005   }
3006   // We already know this is not null
3007   if (!this-&gt;maybe_null()) {
3008     return false;
3009   }
3010   // We already know the speculative type cannot be null
3011   if (!speculative_maybe_null()) {
3012     return false;
3013   }
3014   // We already know this is always null
3015   if (this == TypePtr::NULL_PTR) {
3016     return false;
3017   }
3018   // We already know the speculative type is always null
3019   if (speculative_always_null()) {
3020     return false;
3021   }
3022   if (ptr_kind == ProfileAlwaysNull &amp;&amp; speculative() != NULL &amp;&amp; speculative()-&gt;isa_oopptr()) {
3023     return false;
3024   }
3025   return true;
3026 }
3027 
3028 //------------------------------dump2------------------------------------------
3029 const char *const TypePtr::ptr_msg[TypePtr::lastPTR] = {
3030   &quot;TopPTR&quot;,&quot;AnyNull&quot;,&quot;Constant&quot;,&quot;NULL&quot;,&quot;NotNull&quot;,&quot;BotPTR&quot;
3031 };
3032 
3033 #ifndef PRODUCT
3034 void TypePtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3035   if( _ptr == Null ) st-&gt;print(&quot;NULL&quot;);
3036   else st-&gt;print(&quot;%s *&quot;, ptr_msg[_ptr]);
3037   _offset.dump2(st);
3038   dump_inline_depth(st);
3039   dump_speculative(st);
3040 }
3041 
3042 /**
3043  *dump the speculative part of the type
3044  */
3045 void TypePtr::dump_speculative(outputStream *st) const {
3046   if (_speculative != NULL) {
3047     st-&gt;print(&quot; (speculative=&quot;);
3048     _speculative-&gt;dump_on(st);
3049     st-&gt;print(&quot;)&quot;);
3050   }
3051 }
3052 
3053 /**
3054  *dump the inline depth of the type
3055  */
3056 void TypePtr::dump_inline_depth(outputStream *st) const {
3057   if (_inline_depth != InlineDepthBottom) {
3058     if (_inline_depth == InlineDepthTop) {
3059       st-&gt;print(&quot; (inline_depth=InlineDepthTop)&quot;);
3060     } else {
3061       st-&gt;print(&quot; (inline_depth=%d)&quot;, _inline_depth);
3062     }
3063   }
3064 }
3065 #endif
3066 
3067 //------------------------------singleton--------------------------------------
3068 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3069 // constants
3070 bool TypePtr::singleton(void) const {
3071   // TopPTR, Null, AnyNull, Constant are all singletons
3072   return (_offset != Offset::bottom) &amp;&amp; !below_centerline(_ptr);
3073 }
3074 
3075 bool TypePtr::empty(void) const {
3076   return (_offset == Offset::top) || above_centerline(_ptr);
3077 }
3078 
3079 //=============================================================================
3080 // Convenience common pre-built types.
3081 const TypeRawPtr *TypeRawPtr::BOTTOM;
3082 const TypeRawPtr *TypeRawPtr::NOTNULL;
3083 
3084 //------------------------------make-------------------------------------------
3085 const TypeRawPtr *TypeRawPtr::make( enum PTR ptr ) {
3086   assert( ptr != Constant, &quot;what is the constant?&quot; );
3087   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
3088   return (TypeRawPtr*)(new TypeRawPtr(ptr,0))-&gt;hashcons();
3089 }
3090 
3091 const TypeRawPtr *TypeRawPtr::make( address bits ) {
3092   assert( bits, &quot;Use TypePtr for NULL&quot; );
3093   return (TypeRawPtr*)(new TypeRawPtr(Constant,bits))-&gt;hashcons();
3094 }
3095 
3096 //------------------------------cast_to_ptr_type-------------------------------
3097 const Type *TypeRawPtr::cast_to_ptr_type(PTR ptr) const {
3098   assert( ptr != Constant, &quot;what is the constant?&quot; );
3099   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
3100   assert( _bits==0, &quot;Why cast a constant address?&quot;);
3101   if( ptr == _ptr ) return this;
3102   return make(ptr);
3103 }
3104 
3105 //------------------------------get_con----------------------------------------
3106 intptr_t TypeRawPtr::get_con() const {
3107   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
3108   return (intptr_t)_bits;
3109 }
3110 
3111 //------------------------------meet-------------------------------------------
3112 // Compute the MEET of two types.  It returns a new Type object.
3113 const Type *TypeRawPtr::xmeet( const Type *t ) const {
3114   // Perform a fast test for common case; meeting the same types together.
3115   if( this == t ) return this;  // Meeting same type-rep?
3116 
3117   // Current &quot;this-&gt;_base&quot; is RawPtr
3118   switch( t-&gt;base() ) {         // switch on original type
3119   case Bottom:                  // Ye Olde Default
3120     return t;
3121   case Top:
3122     return this;
3123   case AnyPtr:                  // Meeting to AnyPtrs
3124     break;
3125   case RawPtr: {                // might be top, bot, any/not or constant
3126     enum PTR tptr = t-&gt;is_ptr()-&gt;ptr();
3127     enum PTR ptr = meet_ptr( tptr );
3128     if( ptr == Constant ) {     // Cannot be equal constants, so...
3129       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
3130       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
3131       ptr = NotNull;            // Fall down in lattice
3132     }
3133     return make( ptr );
3134   }
3135 
3136   case OopPtr:
3137   case InstPtr:
3138   case AryPtr:
3139   case MetadataPtr:
3140   case KlassPtr:
3141     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
3142   default:                      // All else is a mistake
3143     typerr(t);
3144   }
3145 
3146   // Found an AnyPtr type vs self-RawPtr type
3147   const TypePtr *tp = t-&gt;is_ptr();
3148   switch (tp-&gt;ptr()) {
3149   case TypePtr::TopPTR:  return this;
3150   case TypePtr::BotPTR:  return t;
3151   case TypePtr::Null:
3152     if( _ptr == TypePtr::TopPTR ) return t;
3153     return TypeRawPtr::BOTTOM;
3154   case TypePtr::NotNull: return TypePtr::make(AnyPtr, meet_ptr(TypePtr::NotNull), tp-&gt;meet_offset(0), tp-&gt;speculative(), tp-&gt;inline_depth());
3155   case TypePtr::AnyNull:
3156     if( _ptr == TypePtr::Constant) return this;
3157     return make( meet_ptr(TypePtr::AnyNull) );
3158   default: ShouldNotReachHere();
3159   }
3160   return this;
3161 }
3162 
3163 //------------------------------xdual------------------------------------------
3164 // Dual: compute field-by-field dual
3165 const Type *TypeRawPtr::xdual() const {
3166   return new TypeRawPtr( dual_ptr(), _bits );
3167 }
3168 
3169 //------------------------------add_offset-------------------------------------
3170 const TypePtr *TypeRawPtr::add_offset( intptr_t offset ) const {
3171   if( offset == OffsetTop ) return BOTTOM; // Undefined offset-&gt; undefined pointer
3172   if( offset == OffsetBot ) return BOTTOM; // Unknown offset-&gt; unknown pointer
3173   if( offset == 0 ) return this; // No change
3174   switch (_ptr) {
3175   case TypePtr::TopPTR:
3176   case TypePtr::BotPTR:
3177   case TypePtr::NotNull:
3178     return this;
3179   case TypePtr::Null:
3180   case TypePtr::Constant: {
3181     address bits = _bits+offset;
3182     if ( bits == 0 ) return TypePtr::NULL_PTR;
3183     return make( bits );
3184   }
3185   default:  ShouldNotReachHere();
3186   }
3187   return NULL;                  // Lint noise
3188 }
3189 
3190 //------------------------------eq---------------------------------------------
3191 // Structural equality check for Type representations
3192 bool TypeRawPtr::eq( const Type *t ) const {
3193   const TypeRawPtr *a = (const TypeRawPtr*)t;
3194   return _bits == a-&gt;_bits &amp;&amp; TypePtr::eq(t);
3195 }
3196 
3197 //------------------------------hash-------------------------------------------
3198 // Type-specific hashing function.
3199 int TypeRawPtr::hash(void) const {
3200   return (intptr_t)_bits + TypePtr::hash();
3201 }
3202 
3203 //------------------------------dump2------------------------------------------
3204 #ifndef PRODUCT
3205 void TypeRawPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3206   if( _ptr == Constant )
3207     st-&gt;print(INTPTR_FORMAT, p2i(_bits));
3208   else
3209     st-&gt;print(&quot;rawptr:%s&quot;, ptr_msg[_ptr]);
3210 }
3211 #endif
3212 
3213 //=============================================================================
3214 // Convenience common pre-built type.
3215 const TypeOopPtr *TypeOopPtr::BOTTOM;
3216 
3217 //------------------------------TypeOopPtr-------------------------------------
3218 TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset, Offset field_offset,
3219                        int instance_id, const TypePtr* speculative, int inline_depth)
3220   : TypePtr(t, ptr, offset, speculative, inline_depth),
3221     _const_oop(o), _klass(k),
3222     _klass_is_exact(xk),
3223     _is_ptr_to_narrowoop(false),
3224     _is_ptr_to_narrowklass(false),
3225     _is_ptr_to_boxed_value(false),
3226     _instance_id(instance_id) {
3227   if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; (t == InstPtr) &amp;&amp;
3228       (offset.get() &gt; 0) &amp;&amp; xk &amp;&amp; (k != 0) &amp;&amp; k-&gt;is_instance_klass()) {
3229     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset.get());
3230   }
3231 #ifdef _LP64
3232   if (this-&gt;offset() &gt; 0 || this-&gt;offset() == Type::OffsetTop || this-&gt;offset() == Type::OffsetBot) {
3233     if (this-&gt;offset() == oopDesc::klass_offset_in_bytes()) {
3234       _is_ptr_to_narrowklass = UseCompressedClassPointers;
3235     } else if (klass() == NULL) {
3236       // Array with unknown body type
3237       assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
3238       _is_ptr_to_narrowoop = UseCompressedOops;
3239     } else if (UseCompressedOops &amp;&amp; this-&gt;isa_aryptr() &amp;&amp; this-&gt;offset() != arrayOopDesc::length_offset_in_bytes()) {
3240       if (klass()-&gt;is_obj_array_klass()) {
3241         _is_ptr_to_narrowoop = true;
3242       } else if (klass()-&gt;is_value_array_klass() &amp;&amp; field_offset != Offset::top &amp;&amp; field_offset != Offset::bottom) {
3243         // Check if the field of the value type array element contains oops
3244         ciValueKlass* vk = klass()-&gt;as_value_array_klass()-&gt;element_klass()-&gt;as_value_klass();
3245         int foffset = field_offset.get() + vk-&gt;first_field_offset();
3246         ciField* field = vk-&gt;get_field_by_offset(foffset, false);
3247         assert(field != NULL, &quot;missing field&quot;);
3248         BasicType bt = field-&gt;layout_type();
3249         _is_ptr_to_narrowoop = (bt == T_OBJECT || bt == T_ARRAY || T_VALUETYPE);
3250       }
3251     } else if (klass()-&gt;is_instance_klass()) {
3252       if (this-&gt;isa_klassptr()) {
3253         // Perm objects don&#39;t use compressed references
3254       } else if (_offset == Offset::bottom || _offset == Offset::top) {
3255         // unsafe access
3256         _is_ptr_to_narrowoop = UseCompressedOops;
3257       } else { // exclude unsafe ops
3258         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3259         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3260             (this-&gt;offset() == java_lang_Class::klass_offset_in_bytes() ||
3261              this-&gt;offset() == java_lang_Class::array_klass_offset_in_bytes())) {
3262           // Special hidden fields from the Class.
3263           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3264           _is_ptr_to_narrowoop = false;
3265         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3266                    this-&gt;offset() &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
3267           // Static fields
3268           assert(o != NULL, &quot;must be constant&quot;);
3269           ciInstanceKlass* ik = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
3270           BasicType basic_elem_type;
3271           if (ik-&gt;is_valuetype() &amp;&amp; this-&gt;offset() == ik-&gt;as_value_klass()-&gt;default_value_offset()) {
3272             // Special hidden field that contains the oop of the default value type
3273             basic_elem_type = T_VALUETYPE;
3274           } else {
3275             ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), true);
3276             assert(field != NULL, &quot;missing field&quot;);
3277             basic_elem_type = field-&gt;layout_type();
3278           }
3279           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3280         } else {
3281           // Instance fields which contains a compressed oop references.
3282           ciInstanceKlass* ik = klass()-&gt;as_instance_klass();
3283           ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), false);
3284           if (field != NULL) {
3285             BasicType basic_elem_type = field-&gt;layout_type();
3286             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3287           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3288             // Compile::find_alias_type() cast exactness on all types to verify
3289             // that it does not affect alias type.
3290             _is_ptr_to_narrowoop = UseCompressedOops;
3291           } else {
3292             // Type for the copy start in LibraryCallKit::inline_native_clone().
3293             _is_ptr_to_narrowoop = UseCompressedOops;
3294           }
3295         }
3296       }
3297     }
3298   }
3299 #endif
3300 }
3301 
3302 //------------------------------make-------------------------------------------
3303 const TypeOopPtr *TypeOopPtr::make(PTR ptr, Offset offset, int instance_id,
3304                                    const TypePtr* speculative, int inline_depth) {
3305   assert(ptr != Constant, &quot;no constant generic pointers&quot;);
3306   ciKlass*  k = Compile::current()-&gt;env()-&gt;Object_klass();
3307   bool      xk = false;
3308   ciObject* o = NULL;
3309   return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, Offset::bottom, instance_id, speculative, inline_depth))-&gt;hashcons();
3310 }
3311 
3312 
3313 //------------------------------cast_to_ptr_type-------------------------------
3314 const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {
3315   assert(_base == OopPtr, &quot;subclass must override cast_to_ptr_type&quot;);
3316   if( ptr == _ptr ) return this;
3317   return make(ptr, _offset, _instance_id, _speculative, _inline_depth);
3318 }
3319 
3320 //-----------------------------cast_to_instance_id----------------------------
3321 const TypeOopPtr *TypeOopPtr::cast_to_instance_id(int instance_id) const {
3322   // There are no instances of a general oop.
3323   // Return self unchanged.
3324   return this;
3325 }
3326 
3327 //-----------------------------cast_to_exactness-------------------------------
3328 const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {
3329   // There is no such thing as an exact general oop.
3330   // Return self unchanged.
3331   return this;
3332 }
3333 
3334 
3335 //------------------------------as_klass_type----------------------------------
3336 // Return the klass type corresponding to this instance or array type.
3337 // It is the type that is loaded from an object of this type.
3338 const TypeKlassPtr* TypeOopPtr::as_klass_type() const {
3339   ciKlass* k = klass();
3340   bool    xk = klass_is_exact();
3341   if (k == NULL)
3342     return TypeKlassPtr::OBJECT;
3343   else
3344     return TypeKlassPtr::make(xk? Constant: NotNull, k, Offset(0), isa_instptr() &amp;&amp; is_instptr()-&gt;flat_array());
3345 }
3346 
3347 //------------------------------meet-------------------------------------------
3348 // Compute the MEET of two types.  It returns a new Type object.
3349 const Type *TypeOopPtr::xmeet_helper(const Type *t) const {
3350   // Perform a fast test for common case; meeting the same types together.
3351   if( this == t ) return this;  // Meeting same type-rep?
3352 
3353   // Current &quot;this-&gt;_base&quot; is OopPtr
3354   switch (t-&gt;base()) {          // switch on original type
3355 
3356   case Int:                     // Mixing ints &amp; oops happens when javac
3357   case Long:                    // reuses local variables
3358   case FloatTop:
3359   case FloatCon:
3360   case FloatBot:
3361   case DoubleTop:
3362   case DoubleCon:
3363   case DoubleBot:
3364   case NarrowOop:
3365   case NarrowKlass:
3366   case Bottom:                  // Ye Olde Default
3367     return Type::BOTTOM;
3368   case Top:
3369     return this;
3370 
3371   default:                      // All else is a mistake
3372     typerr(t);
3373 
3374   case RawPtr:
3375   case MetadataPtr:
3376   case KlassPtr:
3377     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
3378 
3379   case AnyPtr: {
3380     // Found an AnyPtr type vs self-OopPtr type
3381     const TypePtr *tp = t-&gt;is_ptr();
3382     Offset offset = meet_offset(tp-&gt;offset());
3383     PTR ptr = meet_ptr(tp-&gt;ptr());
3384     const TypePtr* speculative = xmeet_speculative(tp);
3385     int depth = meet_inline_depth(tp-&gt;inline_depth());
3386     switch (tp-&gt;ptr()) {
3387     case Null:
3388       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3389       // else fall through:
3390     case TopPTR:
3391     case AnyNull: {
3392       int instance_id = meet_instance_id(InstanceTop);
3393       return make(ptr, offset, instance_id, speculative, depth);
3394     }
3395     case BotPTR:
3396     case NotNull:
3397       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3398     default: typerr(t);
3399     }
3400   }
3401 
3402   case OopPtr: {                 // Meeting to other OopPtrs
3403     const TypeOopPtr *tp = t-&gt;is_oopptr();
3404     int instance_id = meet_instance_id(tp-&gt;instance_id());
3405     const TypePtr* speculative = xmeet_speculative(tp);
3406     int depth = meet_inline_depth(tp-&gt;inline_depth());
3407     return make(meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), instance_id, speculative, depth);
3408   }
3409 
3410   case InstPtr:                  // For these, flip the call around to cut down
3411   case AryPtr:
3412     return t-&gt;xmeet(this);      // Call in reverse direction
3413 
3414   } // End of switch
3415   return this;                  // Return the double constant
3416 }
3417 
3418 
3419 //------------------------------xdual------------------------------------------
3420 // Dual of a pure heap pointer.  No relevant klass or oop information.
3421 const Type *TypeOopPtr::xdual() const {
3422   assert(klass() == Compile::current()-&gt;env()-&gt;Object_klass(), &quot;no klasses here&quot;);
3423   assert(const_oop() == NULL,             &quot;no constants here&quot;);
3424   return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), Offset::bottom, dual_instance_id(), dual_speculative(), dual_inline_depth());
3425 }
3426 
3427 //--------------------------make_from_klass_common-----------------------------
3428 // Computes the element-type given a klass.
3429 const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {
3430   if (klass-&gt;is_instance_klass() || klass-&gt;is_valuetype()) {
3431     Compile* C = Compile::current();
3432     Dependencies* deps = C-&gt;dependencies();
3433     assert((deps != NULL) == (C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;code_size() &gt; 0), &quot;sanity&quot;);
3434     // Element is an instance
3435     bool klass_is_exact = false;
3436     if (klass-&gt;is_loaded()) {
3437       // Try to set klass_is_exact.
3438       ciInstanceKlass* ik = klass-&gt;as_instance_klass();
3439       klass_is_exact = ik-&gt;is_final();
3440       if (!klass_is_exact &amp;&amp; klass_change
3441           &amp;&amp; deps != NULL &amp;&amp; UseUniqueSubclasses) {
3442         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3443         if (sub != NULL) {
3444           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3445           klass = ik = sub;
3446           klass_is_exact = sub-&gt;is_final();
3447         }
3448       }
3449       if (!klass_is_exact &amp;&amp; try_for_exact
3450           &amp;&amp; deps != NULL &amp;&amp; UseExactTypes) {
3451         if (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3452           // Add a dependence; if concrete subclass added we need to recompile
3453           deps-&gt;assert_leaf_type(ik);
3454           klass_is_exact = true;
3455         }
3456       }
3457     }
3458     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0), klass-&gt;flatten_array());
3459   } else if (klass-&gt;is_obj_array_klass()) {
3460     // Element is an object or value array. Recursively call ourself.
3461     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), false, try_for_exact);
3462     bool null_free = klass-&gt;is_loaded() &amp;&amp; klass-&gt;as_array_klass()-&gt;storage_properties().is_null_free();
3463     if (null_free) {
3464       assert(etype-&gt;is_valuetypeptr(), &quot;must be a valuetypeptr&quot;);
3465       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3466     }
3467     // [V? has a subtype: [V. So even though V is final, [V? is not exact.
3468     bool xk = etype-&gt;klass_is_exact() &amp;&amp; (!etype-&gt;is_valuetypeptr() || null_free);
3469     bool not_null_free = !etype-&gt;can_be_value_type() || xk;
3470     bool not_flat = !ValueArrayFlatten || not_null_free || (etype-&gt;is_valuetypeptr() &amp;&amp; !etype-&gt;value_klass()-&gt;flatten_array());
3471     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);
3472     // We used to pass NotNull in here, asserting that the sub-arrays
3473     // are all not-null.  This is not true in generally, as code can
3474     // slam NULLs down in the subarrays.
3475     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, Offset(0));
3476     return arr;
3477   } else if (klass-&gt;is_type_array_klass()) {
3478     // Element is an typeArray
3479     const Type* etype = get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3480     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS,
3481                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);
3482     // We used to pass NotNull in here, asserting that the array pointer
3483     // is not-null. That was not true in general.
3484     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
3485     return arr;
3486   } else if (klass-&gt;is_value_array_klass()) {
3487     ciValueKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_value_klass();
3488     const TypeAry* arr0 = TypeAry::make(TypeValueType::make(vk), TypeInt::POS);
3489     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
3490     return arr;
3491   } else {
3492     ShouldNotReachHere();
3493     return NULL;
3494   }
3495 }
3496 
3497 //------------------------------make_from_constant-----------------------------
3498 // Make a java pointer from an oop constant
3499 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3500   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3501 
3502   const bool make_constant = require_constant || o-&gt;should_be_constant();
3503 
3504   ciKlass* klass = o-&gt;klass();
3505   if (klass-&gt;is_instance_klass() || klass-&gt;is_valuetype()) {
3506     // Element is an instance or value type
3507     if (make_constant) {
3508       return TypeInstPtr::make(o);
3509     } else {
3510       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0), klass-&gt;flatten_array());
3511     }
3512   } else if (klass-&gt;is_obj_array_klass()) {
3513     // Element is an object array. Recursively call ourself.
3514     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass-&gt;as_array_klass()-&gt;element_klass());
3515     bool null_free = klass-&gt;is_loaded() &amp;&amp; klass-&gt;as_array_klass()-&gt;storage_properties().is_null_free();
3516     if (null_free) {
3517       assert(etype-&gt;is_valuetypeptr(), &quot;must be a valuetypeptr&quot;);
3518       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3519     }
3520     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
3521                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ !null_free);
3522     // We used to pass NotNull in here, asserting that the sub-arrays
3523     // are all not-null.  This is not true in generally, as code can
3524     // slam NULLs down in the subarrays.
3525     if (make_constant) {
3526       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3527     } else {
3528       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3529     }
3530   } else if (klass-&gt;is_type_array_klass()) {
3531     // Element is an typeArray
3532     const Type* etype = (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3533     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
3534                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);
3535     // We used to pass NotNull in here, asserting that the array pointer
3536     // is not-null. That was not true in general.
3537     if (make_constant) {
3538       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3539     } else {
3540       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3541     }
3542   } else if (klass-&gt;is_value_array_klass()) {
3543     ciValueKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_value_klass();
3544     const TypeAry* arr0 = TypeAry::make(TypeValueType::make(vk), TypeInt::make(o-&gt;as_array()-&gt;length()));
3545     // We used to pass NotNull in here, asserting that the sub-arrays
3546     // are all not-null.  This is not true in generally, as code can
3547     // slam NULLs down in the subarrays.
3548     if (make_constant) {
3549       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3550     } else {
3551       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3552     }
3553   }
3554 
3555   fatal(&quot;unhandled object type&quot;);
3556   return NULL;
3557 }
3558 
3559 //------------------------------get_con----------------------------------------
3560 intptr_t TypeOopPtr::get_con() const {
3561   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
3562   assert(offset() &gt;= 0, &quot;&quot;);
3563 
3564   if (offset() != 0) {
3565     // After being ported to the compiler interface, the compiler no longer
3566     // directly manipulates the addresses of oops.  Rather, it only has a pointer
3567     // to a handle at compile time.  This handle is embedded in the generated
3568     // code and dereferenced at the time the nmethod is made.  Until that time,
3569     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
3570     // have access to the addresses!).  This does not seem to currently happen,
3571     // but this assertion here is to help prevent its occurence.
3572     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
3573     ShouldNotReachHere();
3574   }
3575 
3576   return (intptr_t)const_oop()-&gt;constant_encoding();
3577 }
3578 
3579 
3580 //-----------------------------filter------------------------------------------
3581 // Do not allow interface-vs.-noninterface joins to collapse to top.
3582 const Type *TypeOopPtr::filter_helper(const Type *kills, bool include_speculative) const {
3583 
3584   const Type* ft = join_helper(kills, include_speculative);
3585   const TypeInstPtr* ftip = ft-&gt;isa_instptr();
3586   const TypeInstPtr* ktip = kills-&gt;isa_instptr();
3587 
3588   if (ft-&gt;empty()) {
3589     // Check for evil case of &#39;this&#39; being a class and &#39;kills&#39; expecting an
3590     // interface.  This can happen because the bytecodes do not contain
3591     // enough type info to distinguish a Java-level interface variable
3592     // from a Java-level object variable.  If we meet 2 classes which
3593     // both implement interface I, but their meet is at &#39;j/l/O&#39; which
3594     // doesn&#39;t implement I, we have no way to tell if the result should
3595     // be &#39;I&#39; or &#39;j/l/O&#39;.  Thus we&#39;ll pick &#39;j/l/O&#39;.  If this then flows
3596     // into a Phi which &quot;knows&quot; it&#39;s an Interface type we&#39;ll have to
3597     // uplift the type.
3598     if (!empty()) {
3599       if (ktip != NULL &amp;&amp; ktip-&gt;is_loaded() &amp;&amp; ktip-&gt;klass()-&gt;is_interface()) {
3600         return kills;           // Uplift to interface
3601       }
3602       // Also check for evil cases of &#39;this&#39; being a class array
3603       // and &#39;kills&#39; expecting an array of interfaces.
3604       Type::get_arrays_base_elements(ft, kills, NULL, &amp;ktip);
3605       if (ktip != NULL &amp;&amp; ktip-&gt;is_loaded() &amp;&amp; ktip-&gt;klass()-&gt;is_interface()) {
3606         return kills;           // Uplift to array of interface
3607       }
3608     }
3609 
3610     return Type::TOP;           // Canonical empty value
3611   }
3612 
3613   // If we have an interface-typed Phi or cast and we narrow to a class type,
3614   // the join should report back the class.  However, if we have a J/L/Object
3615   // class-typed Phi and an interface flows in, it&#39;s possible that the meet &amp;
3616   // join report an interface back out.  This isn&#39;t possible but happens
3617   // because the type system doesn&#39;t interact well with interfaces.
3618   if (ftip != NULL &amp;&amp; ktip != NULL &amp;&amp;
3619       ftip-&gt;is_loaded() &amp;&amp;  ftip-&gt;klass()-&gt;is_interface() &amp;&amp;
3620       ktip-&gt;is_loaded() &amp;&amp; !ktip-&gt;klass()-&gt;is_interface()) {
3621     assert(!ftip-&gt;klass_is_exact(), &quot;interface could not be exact&quot;);
3622     return ktip-&gt;cast_to_ptr_type(ftip-&gt;ptr());
3623   }
3624 
3625   return ft;
3626 }
3627 
3628 //------------------------------eq---------------------------------------------
3629 // Structural equality check for Type representations
3630 bool TypeOopPtr::eq( const Type *t ) const {
3631   const TypeOopPtr *a = (const TypeOopPtr*)t;
3632   if (_klass_is_exact != a-&gt;_klass_is_exact ||
3633       _instance_id != a-&gt;_instance_id)  return false;
3634   ciObject* one = const_oop();
3635   ciObject* two = a-&gt;const_oop();
3636   if (one == NULL || two == NULL) {
3637     return (one == two) &amp;&amp; TypePtr::eq(t);
3638   } else {
3639     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
3640   }
3641 }
3642 
3643 //------------------------------hash-------------------------------------------
3644 // Type-specific hashing function.
3645 int TypeOopPtr::hash(void) const {
3646   return
3647     java_add(java_add((jint)(const_oop() ? const_oop()-&gt;hash() : 0), (jint)_klass_is_exact),
3648              java_add((jint)_instance_id, (jint)TypePtr::hash()));
3649 }
3650 
3651 //------------------------------dump2------------------------------------------
3652 #ifndef PRODUCT
3653 void TypeOopPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3654   st-&gt;print(&quot;oopptr:%s&quot;, ptr_msg[_ptr]);
3655   if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3656   if( const_oop() ) st-&gt;print(INTPTR_FORMAT, p2i(const_oop()));
3657   _offset.dump2(st);
3658   if (_instance_id == InstanceTop)
3659     st-&gt;print(&quot;,iid=top&quot;);
3660   else if (_instance_id != InstanceBot)
3661     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
3662 
3663   dump_inline_depth(st);
3664   dump_speculative(st);
3665 }
3666 #endif
3667 
3668 //------------------------------singleton--------------------------------------
3669 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3670 // constants
3671 bool TypeOopPtr::singleton(void) const {
3672   // detune optimizer to not generate constant oop + constant offset as a constant!
3673   // TopPTR, Null, AnyNull, Constant are all singletons
3674   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);
3675 }
3676 
3677 //------------------------------add_offset-------------------------------------
3678 const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {
3679   return make(_ptr, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
3680 }
3681 
3682 /**
3683  * Return same type without a speculative part
3684  */
3685 const Type* TypeOopPtr::remove_speculative() const {
3686   if (_speculative == NULL) {
3687     return this;
3688   }
3689   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
3690   return make(_ptr, _offset, _instance_id, NULL, _inline_depth);
3691 }
3692 
3693 /**
3694  * Return same type but drop speculative part if we know we won&#39;t use
3695  * it
3696  */
3697 const Type* TypeOopPtr::cleanup_speculative() const {
3698   // If the klass is exact and the ptr is not null then there&#39;s
3699   // nothing that the speculative type can help us with
3700   if (klass_is_exact() &amp;&amp; !maybe_null()) {
3701     return remove_speculative();
3702   }
3703   return TypePtr::cleanup_speculative();
3704 }
3705 
3706 /**
3707  * Return same type but with a different inline depth (used for speculation)
3708  *
3709  * @param depth  depth to meet with
3710  */
3711 const TypePtr* TypeOopPtr::with_inline_depth(int depth) const {
3712   if (!UseInlineDepthForSpeculativeTypes) {
3713     return this;
3714   }
3715   return make(_ptr, _offset, _instance_id, _speculative, depth);
3716 }
3717 
3718 //------------------------------with_instance_id--------------------------------
3719 const TypePtr* TypeOopPtr::with_instance_id(int instance_id) const {
3720   assert(_instance_id != -1, &quot;should be known&quot;);
3721   return make(_ptr, _offset, instance_id, _speculative, _inline_depth);
3722 }
3723 
3724 //------------------------------meet_instance_id--------------------------------
3725 int TypeOopPtr::meet_instance_id( int instance_id ) const {
3726   // Either is &#39;TOP&#39; instance?  Return the other instance!
3727   if( _instance_id == InstanceTop ) return  instance_id;
3728   if(  instance_id == InstanceTop ) return _instance_id;
3729   // If either is different, return &#39;BOTTOM&#39; instance
3730   if( _instance_id != instance_id ) return InstanceBot;
3731   return _instance_id;
3732 }
3733 
3734 //------------------------------dual_instance_id--------------------------------
3735 int TypeOopPtr::dual_instance_id( ) const {
3736   if( _instance_id == InstanceTop ) return InstanceBot; // Map TOP into BOTTOM
3737   if( _instance_id == InstanceBot ) return InstanceTop; // Map BOTTOM into TOP
3738   return _instance_id;              // Map everything else into self
3739 }
3740 
3741 /**
3742  * Check whether new profiling would improve speculative type
3743  *
3744  * @param   exact_kls    class from profiling
3745  * @param   inline_depth inlining depth of profile point
3746  *
3747  * @return  true if type profile is valuable
3748  */
3749 bool TypeOopPtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
3750   // no way to improve an already exact type
3751   if (klass_is_exact()) {
3752     return false;
3753   }
3754   return TypePtr::would_improve_type(exact_kls, inline_depth);
3755 }
3756 
3757 //=============================================================================
3758 // Convenience common pre-built types.
3759 const TypeInstPtr *TypeInstPtr::NOTNULL;
3760 const TypeInstPtr *TypeInstPtr::BOTTOM;
3761 const TypeInstPtr *TypeInstPtr::MIRROR;
3762 const TypeInstPtr *TypeInstPtr::MARK;
3763 const TypeInstPtr *TypeInstPtr::KLASS;
3764 
3765 //------------------------------TypeInstPtr-------------------------------------
3766 TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset off,
3767                          bool flat_array, int instance_id, const TypePtr* speculative,
3768                          int inline_depth)
3769   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),
3770     _name(k-&gt;name()), _flat_array(flat_array) {
3771    assert(k != NULL &amp;&amp;
3772           (k-&gt;is_loaded() || o == NULL),
3773           &quot;cannot have constants with non-loaded klass&quot;);
3774    assert(!klass()-&gt;is_valuetype() || !klass()-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);
3775    assert(!flat_array || can_be_value_type(), &quot;incorrect flatten array bit&quot;);
3776 };
3777 
3778 //------------------------------make-------------------------------------------
3779 const TypeInstPtr *TypeInstPtr::make(PTR ptr,
3780                                      ciKlass* k,
3781                                      bool xk,
3782                                      ciObject* o,
3783                                      Offset offset,
3784                                      bool flat_array,
3785                                      int instance_id,
3786                                      const TypePtr* speculative,
3787                                      int inline_depth) {
3788   assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
3789   // Either const_oop() is NULL or else ptr is Constant
3790   assert( (!o &amp;&amp; ptr != Constant) || (o &amp;&amp; ptr == Constant),
3791           &quot;constant pointers must have a value supplied&quot; );
3792   // Ptr is never Null
3793   assert( ptr != Null, &quot;NULL pointers are not typed&quot; );
3794 
3795   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
3796   if (!UseExactTypes)  xk = false;
3797   if (ptr == Constant) {
3798     // Note:  This case includes meta-object constants, such as methods.
3799     xk = true;
3800   } else if (k-&gt;is_loaded()) {
3801     ciInstanceKlass* ik = k-&gt;as_instance_klass();
3802     if (!xk &amp;&amp; ik-&gt;is_final())     xk = true;   // no inexact final klass
3803     if (xk &amp;&amp; ik-&gt;is_interface())  xk = false;  // no exact interface
3804   }
3805 
3806   // Now hash this baby
3807   TypeInstPtr *result =
3808     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, flat_array, instance_id, speculative, inline_depth))-&gt;hashcons();
3809 
3810   return result;
3811 }
3812 
3813 /**
3814  *  Create constant type for a constant boxed value
3815  */
3816 const Type* TypeInstPtr::get_const_boxed_value() const {
3817   assert(is_ptr_to_boxed_value(), &quot;should be called only for boxed value&quot;);
3818   assert((const_oop() != NULL), &quot;should be called only for constant object&quot;);
3819   ciConstant constant = const_oop()-&gt;as_instance()-&gt;field_value_by_offset(offset());
3820   BasicType bt = constant.basic_type();
3821   switch (bt) {
3822     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
3823     case T_INT:      return TypeInt::make(constant.as_int());
3824     case T_CHAR:     return TypeInt::make(constant.as_char());
3825     case T_BYTE:     return TypeInt::make(constant.as_byte());
3826     case T_SHORT:    return TypeInt::make(constant.as_short());
3827     case T_FLOAT:    return TypeF::make(constant.as_float());
3828     case T_DOUBLE:   return TypeD::make(constant.as_double());
3829     case T_LONG:     return TypeLong::make(constant.as_long());
3830     default:         break;
3831   }
3832   fatal(&quot;Invalid boxed value type &#39;%s&#39;&quot;, type2name(bt));
3833   return NULL;
3834 }
3835 
3836 //------------------------------cast_to_ptr_type-------------------------------
3837 const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
3838   if( ptr == _ptr ) return this;
3839   // Reconstruct _sig info here since not a problem with later lazy
3840   // construction, _sig will show up on demand.
3841   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);
3842 }
3843 
3844 
3845 //-----------------------------cast_to_exactness-------------------------------
3846 const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
3847   if( klass_is_exact == _klass_is_exact ) return this;
3848   if (!UseExactTypes)  return this;
3849   if (!_klass-&gt;is_loaded())  return this;
3850   ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
3851   if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
3852   if( ik-&gt;is_interface() )              return this;  // cannot set xk
3853   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);
3854 }
3855 
3856 //-----------------------------cast_to_instance_id----------------------------
3857 const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
3858   if( instance_id == _instance_id ) return this;
3859   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, _flat_array, instance_id, _speculative, _inline_depth);
3860 }
3861 
3862 //------------------------------xmeet_unloaded---------------------------------
3863 // Compute the MEET of two InstPtrs when at least one is unloaded.
3864 // Assume classes are different since called after check for same name/class-loader
3865 const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
3866     Offset off = meet_offset(tinst-&gt;offset());
3867     PTR ptr = meet_ptr(tinst-&gt;ptr());
3868     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3869     const TypePtr* speculative = xmeet_speculative(tinst);
3870     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3871 
3872     const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;
3873     const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;
3874     if( loaded-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) ) {
3875       //
3876       // Meet unloaded class with java/lang/Object
3877       //
3878       // Meet
3879       //          |                     Unloaded Class
3880       //  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |
3881       //  ===================================================================
3882       //   TOP    | ..........................Unloaded......................|
3883       //  AnyNull |  U-AN    |................Unloaded......................|
3884       // Constant | ... O-NN .................................. |   O-BOT   |
3885       //  NotNull | ... O-NN .................................. |   O-BOT   |
3886       //  BOTTOM  | ........................Object-BOTTOM ..................|
3887       //
3888       assert(loaded-&gt;ptr() != TypePtr::Null, &quot;insanity check&quot;);
3889       //
3890       if(      loaded-&gt;ptr() == TypePtr::TopPTR ) { return unloaded; }
3891       else if (loaded-&gt;ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded-&gt;klass(), false, NULL, off, false, instance_id, speculative, depth); }
3892       else if (loaded-&gt;ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }
3893       else if (loaded-&gt;ptr() == TypePtr::Constant || loaded-&gt;ptr() == TypePtr::NotNull) {
3894         if (unloaded-&gt;ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }
3895         else                                      { return TypeInstPtr::NOTNULL; }
3896       }
3897       else if( unloaded-&gt;ptr() == TypePtr::TopPTR )  { return unloaded; }
3898 
3899       return unloaded-&gt;cast_to_ptr_type(TypePtr::AnyNull)-&gt;is_instptr();
3900     }
3901 
3902     // Both are unloaded, not the same class, not Object
3903     // Or meet unloaded with a different loaded class, not java/lang/Object
3904     if( ptr != TypePtr::BotPTR ) {
3905       return TypeInstPtr::NOTNULL;
3906     }
3907     return TypeInstPtr::BOTTOM;
3908 }
3909 
3910 
3911 //------------------------------meet-------------------------------------------
3912 // Compute the MEET of two types.  It returns a new Type object.
3913 const Type *TypeInstPtr::xmeet_helper(const Type *t) const {
3914   // Perform a fast test for common case; meeting the same types together.
3915   if( this == t ) return this;  // Meeting same type-rep?
3916 
3917   // Current &quot;this-&gt;_base&quot; is Pointer
3918   switch (t-&gt;base()) {          // switch on original type
3919 
3920   case Int:                     // Mixing ints &amp; oops happens when javac
3921   case Long:                    // reuses local variables
3922   case FloatTop:
3923   case FloatCon:
3924   case FloatBot:
3925   case DoubleTop:
3926   case DoubleCon:
3927   case DoubleBot:
3928   case NarrowOop:
3929   case NarrowKlass:
3930   case Bottom:                  // Ye Olde Default
3931     return Type::BOTTOM;
3932   case Top:
3933     return this;
3934 
3935   default:                      // All else is a mistake
3936     typerr(t);
3937 
3938   case MetadataPtr:
3939   case KlassPtr:
3940   case RawPtr: return TypePtr::BOTTOM;
3941 
3942   case AryPtr: {                // All arrays inherit from Object class
3943     const TypeAryPtr *tp = t-&gt;is_aryptr();
3944     Offset offset = meet_offset(tp-&gt;offset());
3945     PTR ptr = meet_ptr(tp-&gt;ptr());
3946     int instance_id = meet_instance_id(tp-&gt;instance_id());
3947     const TypePtr* speculative = xmeet_speculative(tp);
3948     int depth = meet_inline_depth(tp-&gt;inline_depth());
3949     switch (ptr) {
3950     case TopPTR:
3951     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
3952       // For instances when a subclass meets a superclass we fall
3953       // below the centerline when the superclass is exact. We need to
3954       // do the same here.
3955       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {
3956         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
3957       } else {
3958         // cannot subclass, so the meet has to fall badly below the centerline
3959         ptr = NotNull;
3960         instance_id = InstanceBot;
3961         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
3962       }
3963     case Constant:
3964     case NotNull:
3965     case BotPTR:                // Fall down to object klass
3966       // LCA is object_klass, but if we subclass from the top we can do better
3967       if( above_centerline(_ptr) ) { // if( _ptr == TopPTR || _ptr == AnyNull )
3968         // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
3969         // then we can subclass in the Java class hierarchy.
3970         // For instances when a subclass meets a superclass we fall
3971         // below the centerline when the superclass is exact. We need
3972         // to do the same here.
3973         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {
3974           // that is, tp&#39;s array type is a subtype of my klass
3975           return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
3976                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
3977         }
3978       }
3979       // The other case cannot happen, since I cannot be a subtype of an array.
3980       // The meet falls down to Object class below centerline.
3981       if( ptr == Constant )
3982          ptr = NotNull;
3983       instance_id = InstanceBot;
3984       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
3985     default: typerr(t);
3986     }
3987   }
3988 
3989   case OopPtr: {                // Meeting to OopPtrs
3990     // Found a OopPtr type vs self-InstPtr type
3991     const TypeOopPtr *tp = t-&gt;is_oopptr();
3992     Offset offset = meet_offset(tp-&gt;offset());
3993     PTR ptr = meet_ptr(tp-&gt;ptr());
3994     switch (tp-&gt;ptr()) {
3995     case TopPTR:
3996     case AnyNull: {
3997       int instance_id = meet_instance_id(InstanceTop);
3998       const TypePtr* speculative = xmeet_speculative(tp);
3999       int depth = meet_inline_depth(tp-&gt;inline_depth());
4000       return make(ptr, klass(), klass_is_exact(),
4001                   (ptr == Constant ? const_oop() : NULL), offset, flat_array(), instance_id, speculative, depth);
4002     }
4003     case NotNull:
4004     case BotPTR: {
4005       int instance_id = meet_instance_id(tp-&gt;instance_id());
4006       const TypePtr* speculative = xmeet_speculative(tp);
4007       int depth = meet_inline_depth(tp-&gt;inline_depth());
4008       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4009     }
4010     default: typerr(t);
4011     }
4012   }
4013 
4014   case AnyPtr: {                // Meeting to AnyPtrs
4015     // Found an AnyPtr type vs self-InstPtr type
4016     const TypePtr *tp = t-&gt;is_ptr();
4017     Offset offset = meet_offset(tp-&gt;offset());
4018     PTR ptr = meet_ptr(tp-&gt;ptr());
4019     int instance_id = meet_instance_id(InstanceTop);
4020     const TypePtr* speculative = xmeet_speculative(tp);
4021     int depth = meet_inline_depth(tp-&gt;inline_depth());
4022     switch (tp-&gt;ptr()) {
4023     case Null:
4024       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4025       // else fall through to AnyNull
4026     case TopPTR:
4027     case AnyNull: {
4028       return make(ptr, klass(), klass_is_exact(),
4029                   (ptr == Constant ? const_oop() : NULL), offset, flat_array(), instance_id, speculative, depth);
4030     }
4031     case NotNull:
4032     case BotPTR:
4033       return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
4034     default: typerr(t);
4035     }
4036   }
4037 
4038   /*
4039                  A-top         }
4040                /   |   \       }  Tops
4041            B-top A-any C-top   }
4042               | /  |  \ |      }  Any-nulls
4043            B-any   |   C-any   }
4044               |    |    |
4045            B-con A-con C-con   } constants; not comparable across classes
4046               |    |    |
4047            B-not   |   C-not   }
4048               | \  |  / |      }  not-nulls
4049            B-bot A-not C-bot   }
4050                \   |   /       }  Bottoms
4051                  A-bot         }
4052   */
4053 
4054   case InstPtr: {                // Meeting 2 Oops?
4055     // Found an InstPtr sub-type vs self-InstPtr type
4056     const TypeInstPtr *tinst = t-&gt;is_instptr();
4057     Offset off = meet_offset( tinst-&gt;offset() );
4058     PTR ptr = meet_ptr( tinst-&gt;ptr() );
4059     int instance_id = meet_instance_id(tinst-&gt;instance_id());
4060     const TypePtr* speculative = xmeet_speculative(tinst);
4061     int depth = meet_inline_depth(tinst-&gt;inline_depth());
4062 
4063     // Check for easy case; klasses are equal (and perhaps not loaded!)
4064     // If we have constants, then we created oops so classes are loaded
4065     // and we can handle the constants further down.  This case handles
4066     // both-not-loaded or both-loaded classes
4067     if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact() &amp;&amp;
4068         flat_array() == tinst-&gt;flat_array()) {
4069       return make(ptr, klass(), klass_is_exact(), NULL, off, flat_array(), instance_id, speculative, depth);
4070     }
4071 
4072     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
4073     ciKlass* tinst_klass = tinst-&gt;klass();
4074     ciKlass* this_klass  = this-&gt;klass();
4075     bool tinst_xk = tinst-&gt;klass_is_exact();
4076     bool this_xk  = this-&gt;klass_is_exact();
4077     bool tinst_flat_array = tinst-&gt;flat_array();
4078     bool this_flat_array  = this-&gt;flat_array();
4079     if (!tinst_klass-&gt;is_loaded() || !this_klass-&gt;is_loaded() ) {
4080       // One of these classes has not been loaded
4081       const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
4082 #ifndef PRODUCT
4083       if( PrintOpto &amp;&amp; Verbose ) {
4084         tty-&gt;print(&quot;meet of unloaded classes resulted in: &quot;); unloaded_meet-&gt;dump(); tty-&gt;cr();
4085         tty-&gt;print(&quot;  this == &quot;); this-&gt;dump(); tty-&gt;cr();
4086         tty-&gt;print(&quot; tinst == &quot;); tinst-&gt;dump(); tty-&gt;cr();
4087       }
4088 #endif
4089       return unloaded_meet;
4090     }
4091 
4092     // Handle mixing oops and interfaces first.
4093     if( this_klass-&gt;is_interface() &amp;&amp; !(tinst_klass-&gt;is_interface() ||
4094                                         tinst_klass == ciEnv::current()-&gt;Object_klass())) {
4095       ciKlass *tmp = tinst_klass; // Swap interface around
4096       tinst_klass = this_klass;
4097       this_klass = tmp;
4098       bool tmp2 = tinst_xk;
4099       tinst_xk = this_xk;
4100       this_xk = tmp2;
4101       tmp2 = tinst_flat_array;
4102       tinst_flat_array = this_flat_array;
4103       this_flat_array = tmp2;
4104     }
4105     if (tinst_klass-&gt;is_interface() &amp;&amp;
4106         !(this_klass-&gt;is_interface() ||
4107           // Treat java/lang/Object as an honorary interface,
4108           // because we need a bottom for the interface hierarchy.
4109           this_klass == ciEnv::current()-&gt;Object_klass())) {
4110       // Oop meets interface!
4111 
4112       // See if the oop subtypes (implements) interface.
4113       ciKlass *k;
4114       bool xk;
4115       bool flat_array;
4116       if( this_klass-&gt;is_subtype_of( tinst_klass ) ) {
4117         // Oop indeed subtypes.  Now keep oop or interface depending
4118         // on whether we are both above the centerline or either is
4119         // below the centerline.  If we are on the centerline
4120         // (e.g., Constant vs. AnyNull interface), use the constant.
4121         k  = below_centerline(ptr) ? tinst_klass : this_klass;
4122         // If we are keeping this_klass, keep its exactness too.
4123         xk = below_centerline(ptr) ? tinst_xk    : this_xk;
4124         flat_array = below_centerline(ptr) ? tinst_flat_array    : this_flat_array;
4125       } else {                  // Does not implement, fall to Object
4126         // Oop does not implement interface, so mixing falls to Object
4127         // just like the verifier does (if both are above the
4128         // centerline fall to interface)
4129         k = above_centerline(ptr) ? tinst_klass : ciEnv::current()-&gt;Object_klass();
4130         xk = above_centerline(ptr) ? tinst_xk : false;
4131         flat_array = above_centerline(ptr) ? tinst_flat_array : false;
4132         // Watch out for Constant vs. AnyNull interface.
4133         if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
4134         instance_id = InstanceBot;
4135       }
4136       ciObject* o = NULL;  // the Constant value, if any
4137       if (ptr == Constant) {
4138         // Find out which constant.
4139         o = (this_klass == klass()) ? const_oop() : tinst-&gt;const_oop();
4140       }
4141       return make(ptr, k, xk, o, off, flat_array, instance_id, speculative, depth);
4142     }
4143 
4144     // Either oop vs oop or interface vs interface or interface vs Object
4145 
4146     // !!! Here&#39;s how the symmetry requirement breaks down into invariants:
4147     // If we split one up &amp; one down AND they subtype, take the down man.
4148     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
4149     // If both are up and they subtype, take the subtype class.
4150     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
4151     // If both are down and they subtype, take the supertype class.
4152     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
4153     // Constants treated as down.
4154 
4155     // Now, reorder the above list; observe that both-down+subtype is also
4156     // &quot;fall hard&quot;; &quot;fall hard&quot; becomes the default case:
4157     // If we split one up &amp; one down AND they subtype, take the down man.
4158     // If both are up and they subtype, take the subtype class.
4159 
4160     // If both are down and they subtype, &quot;fall hard&quot;.
4161     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
4162     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
4163     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
4164 
4165     // If a proper subtype is exact, and we return it, we return it exactly.
4166     // If a proper supertype is exact, there can be no subtyping relationship!
4167     // If both types are equal to the subtype, exactness is and-ed below the
4168     // centerline and or-ed above it.  (N.B. Constants are always exact.)
4169 
4170     // Check for subtyping:
4171     ciKlass *subtype = NULL;
4172     bool subtype_exact = false;
4173     bool flat_array = false;
4174     if( tinst_klass-&gt;equals(this_klass) ) {
4175       subtype = this_klass;
4176       subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
4177       flat_array = below_centerline(ptr) ? (this_flat_array &amp;&amp; tinst_flat_array) : (this_flat_array || tinst_flat_array);
4178     } else if( !tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of( tinst_klass ) ) {
4179       subtype = this_klass;     // Pick subtyping class
4180       subtype_exact = this_xk;
4181       flat_array = this_flat_array;
4182     } else if( !this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of( this_klass ) ) {
4183       subtype = tinst_klass;    // Pick subtyping class
4184       subtype_exact = tinst_xk;
4185       flat_array = tinst_flat_array;
4186     }
4187 
4188     if( subtype ) {
4189       if( above_centerline(ptr) ) { // both are up?
4190         this_klass = tinst_klass = subtype;
4191         this_xk = tinst_xk = subtype_exact;
4192         this_flat_array = tinst_flat_array = flat_array;
4193       } else if( above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr) ) {
4194         this_klass = tinst_klass; // tinst is down; keep down man
4195         this_xk = tinst_xk;
4196         this_flat_array = tinst_flat_array;
4197       } else if( above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr) ) {
4198         tinst_klass = this_klass; // this is down; keep down man
4199         tinst_xk = this_xk;
4200         tinst_flat_array = this_flat_array;
4201       } else {
4202         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
4203         this_flat_array = flat_array;
4204       }
4205     }
4206 
4207     // Check for classes now being equal
4208     if (tinst_klass-&gt;equals(this_klass)) {
4209       // If the klasses are equal, the constants may still differ.  Fall to
4210       // NotNull if they do (neither constant is NULL; that is a special case
4211       // handled elsewhere).
4212       ciObject* o = NULL;             // Assume not constant when done
4213       ciObject* this_oop  = const_oop();
4214       ciObject* tinst_oop = tinst-&gt;const_oop();
4215       if( ptr == Constant ) {
4216         if (this_oop != NULL &amp;&amp; tinst_oop != NULL &amp;&amp;
4217             this_oop-&gt;equals(tinst_oop) )
4218           o = this_oop;
4219         else if (above_centerline(this -&gt;_ptr))
4220           o = tinst_oop;
4221         else if (above_centerline(tinst -&gt;_ptr))
4222           o = this_oop;
4223         else
4224           ptr = NotNull;
4225       }
4226       return make(ptr, this_klass, this_xk, o, off, this_flat_array, instance_id, speculative, depth);
4227     } // Else classes are not equal
4228 
4229     // Since klasses are different, we require a LCA in the Java
4230     // class hierarchy - which means we have to fall to at least NotNull.
4231     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
4232       ptr = NotNull;
4233 
4234     instance_id = InstanceBot;
4235 
4236     // Now we find the LCA of Java classes
4237     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
4238     return make(ptr, k, false, NULL, off, false, instance_id, speculative, depth);
4239   } // End of case InstPtr
4240 
4241   case ValueType: {
4242     const TypeValueType* tv = t-&gt;is_valuetype();
4243     if (above_centerline(ptr())) {
4244       if (tv-&gt;value_klass()-&gt;is_subtype_of(_klass)) {
4245         return t;
4246       } else {
4247         return TypeInstPtr::make(NotNull, _klass);
4248       }
4249     } else {
4250       PTR ptr = this-&gt;_ptr;
4251       if (ptr == Constant) {
4252         ptr = NotNull;
4253       }
4254       if (tv-&gt;value_klass()-&gt;is_subtype_of(_klass)) {
4255         return TypeInstPtr::make(ptr, _klass);
4256       } else {
4257         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());
4258       }
4259     }
4260   }
4261 
4262   } // End of switch
4263   return this;                  // Return the double constant
4264 }
4265 
4266 
4267 //------------------------java_mirror_type--------------------------------------
4268 ciType* TypeInstPtr::java_mirror_type(bool* is_indirect_type) const {
4269   // must be a singleton type
4270   if( const_oop() == NULL )  return NULL;
4271 
4272   // must be of type java.lang.Class
4273   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;
4274 
4275   return const_oop()-&gt;as_instance()-&gt;java_mirror_type(is_indirect_type);
4276 }
4277 
4278 
4279 //------------------------------xdual------------------------------------------
4280 // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
4281 // inheritance mechanism.
4282 const Type *TypeInstPtr::xdual() const {
4283   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), flat_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());
4284 }
4285 
4286 //------------------------------eq---------------------------------------------
4287 // Structural equality check for Type representations
4288 bool TypeInstPtr::eq( const Type *t ) const {
4289   const TypeInstPtr *p = t-&gt;is_instptr();
4290   return
4291     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
4292     flat_array() == p-&gt;flat_array() &amp;&amp;
4293     TypeOopPtr::eq(p);          // Check sub-type stuff
4294 }
4295 
4296 //------------------------------hash-------------------------------------------
4297 // Type-specific hashing function.
4298 int TypeInstPtr::hash(void) const {
4299   int hash = java_add(java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash()), (jint)flat_array());
4300   return hash;
4301 }
4302 
4303 //------------------------------dump2------------------------------------------
4304 // Dump oop Type
4305 #ifndef PRODUCT
4306 void TypeInstPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4307   // Print the name of the klass.
4308   klass()-&gt;print_name_on(st);
4309 
4310   switch( _ptr ) {
4311   case Constant:
4312     // TO DO: Make CI print the hex address of the underlying oop.
4313     if (WizardMode || Verbose) {
4314       const_oop()-&gt;print_oop(st);
4315     }
4316   case BotPTR:
4317     if (!WizardMode &amp;&amp; !Verbose) {
4318       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4319       break;
4320     }
4321   case TopPTR:
4322   case AnyNull:
4323   case NotNull:
4324     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4325     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4326     break;
4327   default:
4328     break;
4329   }
4330 
4331   _offset.dump2(st);
4332 
4333   st-&gt;print(&quot; *&quot;);
4334 
4335   if (flat_array() &amp;&amp; !klass()-&gt;is_valuetype()) {
4336     st-&gt;print(&quot; (flatten array)&quot;);
4337   }
4338 
4339   if (_instance_id == InstanceTop)
4340     st-&gt;print(&quot;,iid=top&quot;);
4341   else if (_instance_id != InstanceBot)
4342     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4343 
4344   dump_inline_depth(st);
4345   dump_speculative(st);
4346 }
4347 #endif
4348 
4349 //------------------------------add_offset-------------------------------------
4350 const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
4351   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset), flat_array(),
4352               _instance_id, add_offset_speculative(offset), _inline_depth);
4353 }
4354 
4355 const Type *TypeInstPtr::remove_speculative() const {
4356   if (_speculative == NULL) {
4357     return this;
4358   }
4359   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
4360   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(),
4361               _instance_id, NULL, _inline_depth);
4362 }
4363 
4364 const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
4365   if (!UseInlineDepthForSpeculativeTypes) {
4366     return this;
4367   }
4368   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), _instance_id, _speculative, depth);
4369 }
4370 
4371 const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
4372   assert(is_known_instance(), &quot;should be known&quot;);
4373   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), instance_id, _speculative, _inline_depth);
4374 }
4375 
4376 const TypeInstPtr *TypeInstPtr::cast_to_flat_array() const {
4377   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, true, _instance_id, _speculative, _inline_depth);
4378 }
4379 
4380 
4381 //=============================================================================
4382 // Convenience common pre-built types.
4383 const TypeAryPtr *TypeAryPtr::RANGE;
4384 const TypeAryPtr *TypeAryPtr::OOPS;
4385 const TypeAryPtr *TypeAryPtr::NARROWOOPS;
4386 const TypeAryPtr *TypeAryPtr::BYTES;
4387 const TypeAryPtr *TypeAryPtr::SHORTS;
4388 const TypeAryPtr *TypeAryPtr::CHARS;
4389 const TypeAryPtr *TypeAryPtr::INTS;
4390 const TypeAryPtr *TypeAryPtr::LONGS;
4391 const TypeAryPtr *TypeAryPtr::FLOATS;
4392 const TypeAryPtr *TypeAryPtr::DOUBLES;
4393 const TypeAryPtr *TypeAryPtr::VALUES;
4394 
4395 //------------------------------make-------------------------------------------
4396 const TypeAryPtr* TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,
4397                                    int instance_id, const TypePtr* speculative, int inline_depth) {
4398   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4399          &quot;integral arrays must be pre-equipped with a class&quot;);
4400   if (!xk) xk = ary-&gt;ary_must_be_exact();
4401   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4402   if (!UseExactTypes)  xk = (ptr == Constant);
4403   return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, field_offset, instance_id, false, speculative, inline_depth))-&gt;hashcons();
4404 }
4405 
4406 //------------------------------make-------------------------------------------
4407 const TypeAryPtr* TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,
4408                                    int instance_id, const TypePtr* speculative, int inline_depth,
4409                                    bool is_autobox_cache) {
4410   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4411          &quot;integral arrays must be pre-equipped with a class&quot;);
4412   assert( (ptr==Constant &amp;&amp; o) || (ptr!=Constant &amp;&amp; !o), &quot;&quot; );
4413   if (!xk)  xk = (o != NULL) || ary-&gt;ary_must_be_exact();
4414   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4415   if (!UseExactTypes)  xk = (ptr == Constant);
4416   return (TypeAryPtr*)(new TypeAryPtr(ptr, o, ary, k, xk, offset, field_offset, instance_id, is_autobox_cache, speculative, inline_depth))-&gt;hashcons();
4417 }
4418 
4419 //------------------------------cast_to_ptr_type-------------------------------
4420 const Type *TypeAryPtr::cast_to_ptr_type(PTR ptr) const {
4421   if( ptr == _ptr ) return this;
4422   return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4423 }
4424 
4425 
4426 //-----------------------------cast_to_exactness-------------------------------
4427 const Type *TypeAryPtr::cast_to_exactness(bool klass_is_exact) const {
4428   if( klass_is_exact == _klass_is_exact ) return this;
4429   if (!UseExactTypes)  return this;
4430   if (_ary-&gt;ary_must_be_exact())  return this;  // cannot clear xk
4431 
4432   const TypeAry* new_ary = _ary;
4433   if (klass() != NULL &amp;&amp; klass()-&gt;is_obj_array_klass() &amp;&amp; klass_is_exact) {
4434     // An object array can&#39;t be flat or null-free if the klass is exact
4435     new_ary = TypeAry::make(elem(), size(), is_stable(), /* not_flat= */ true, /* not_null_free= */ true);
4436   }
4437   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact, _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4438 }
4439 
4440 //-----------------------------cast_to_instance_id----------------------------
4441 const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {
4442   if( instance_id == _instance_id ) return this;
4443   return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, _field_offset, instance_id, _speculative, _inline_depth, _is_autobox_cache);
4444 }
4445 
4446 
4447 //-----------------------------max_array_length-------------------------------
4448 // A wrapper around arrayOopDesc::max_array_length(etype) with some input normalization.
4449 jint TypeAryPtr::max_array_length(BasicType etype) {
4450   if (!is_java_primitive(etype) &amp;&amp; !is_reference_type(etype)) {
4451     if (etype == T_NARROWOOP) {
4452       etype = T_OBJECT;
4453     } else if (etype == T_ILLEGAL) { // bottom[]
4454       etype = T_BYTE; // will produce conservatively high value
4455     } else {
4456       fatal(&quot;not an element type: %s&quot;, type2name(etype));
4457     }
4458   }
4459   return arrayOopDesc::max_array_length(etype);
4460 }
4461 
4462 //-----------------------------narrow_size_type-------------------------------
4463 // Narrow the given size type to the index range for the given array base type.
4464 // Return NULL if the resulting int type becomes empty.
4465 const TypeInt* TypeAryPtr::narrow_size_type(const TypeInt* size) const {
4466   jint hi = size-&gt;_hi;
4467   jint lo = size-&gt;_lo;
4468   jint min_lo = 0;
4469   jint max_hi = max_array_length(elem()-&gt;basic_type());
4470   //if (index_not_size)  --max_hi;     // type of a valid array index, FTR
4471   bool chg = false;
4472   if (lo &lt; min_lo) {
4473     lo = min_lo;
4474     if (size-&gt;is_con()) {
4475       hi = lo;
4476     }
4477     chg = true;
4478   }
4479   if (hi &gt; max_hi) {
4480     hi = max_hi;
4481     if (size-&gt;is_con()) {
4482       lo = hi;
4483     }
4484     chg = true;
4485   }
4486   // Negative length arrays will produce weird intermediate dead fast-path code
4487   if (lo &gt; hi)
4488     return TypeInt::ZERO;
4489   if (!chg)
4490     return size;
4491   return TypeInt::make(lo, hi, Type::WidenMin);
4492 }
4493 
4494 //-------------------------------cast_to_size----------------------------------
4495 const TypeAryPtr* TypeAryPtr::cast_to_size(const TypeInt* new_size) const {
4496   assert(new_size != NULL, &quot;&quot;);
4497   new_size = narrow_size_type(new_size);
4498   if (new_size == size())  return this;
4499   const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable(), is_not_flat(), is_not_null_free());
4500   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4501 }
4502 
4503 //-------------------------------cast_to_not_flat------------------------------
4504 const TypeAryPtr* TypeAryPtr::cast_to_not_flat(bool not_flat) const {
4505   if (not_flat == is_not_flat()) {
4506     return this;
4507   }
4508   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_flat, is_not_null_free());
4509   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4510 }
4511 
4512 //-------------------------------cast_to_not_null_free-------------------------
4513 const TypeAryPtr* TypeAryPtr::cast_to_not_null_free(bool not_null_free) const {
4514   if (not_null_free == is_not_null_free()) {
4515     return this;
4516   }
4517   // Not null free implies not flat
4518   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_null_free ? true : is_not_flat(), not_null_free);
4519   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4520 }
4521 
4522 //------------------------------cast_to_stable---------------------------------
4523 const TypeAryPtr* TypeAryPtr::cast_to_stable(bool stable, int stable_dimension) const {
4524   if (stable_dimension &lt;= 0 || (stable_dimension == 1 &amp;&amp; stable == this-&gt;is_stable()))
4525     return this;
4526 
4527   const Type* elem = this-&gt;elem();
4528   const TypePtr* elem_ptr = elem-&gt;make_ptr();
4529 
4530   if (stable_dimension &gt; 1 &amp;&amp; elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr()) {
4531     // If this is widened from a narrow oop, TypeAry::make will re-narrow it.
4532     elem = elem_ptr = elem_ptr-&gt;is_aryptr()-&gt;cast_to_stable(stable, stable_dimension - 1);
4533   }
4534 
4535   const TypeAry* new_ary = TypeAry::make(elem, size(), stable, is_not_flat(), is_not_null_free());
4536 
4537   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4538 }
4539 
4540 //-----------------------------stable_dimension--------------------------------
4541 int TypeAryPtr::stable_dimension() const {
4542   if (!is_stable())  return 0;
4543   int dim = 1;
4544   const TypePtr* elem_ptr = elem()-&gt;make_ptr();
4545   if (elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr())
4546     dim += elem_ptr-&gt;is_aryptr()-&gt;stable_dimension();
4547   return dim;
4548 }
4549 
4550 //----------------------cast_to_autobox_cache-----------------------------------
4551 const TypeAryPtr* TypeAryPtr::cast_to_autobox_cache(bool cache) const {
4552   if (is_autobox_cache() == cache)  return this;
4553   const TypeOopPtr* etype = elem()-&gt;make_oopptr();
4554   if (etype == NULL)  return this;
4555   // The pointers in the autobox arrays are always non-null.
4556   TypePtr::PTR ptr_type = cache ? TypePtr::NotNull : TypePtr::AnyNull;
4557   etype = etype-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
4558   const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable(), is_not_flat(), is_not_null_free());
4559   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, cache);
4560 }
4561 
4562 //------------------------------eq---------------------------------------------
4563 // Structural equality check for Type representations
4564 bool TypeAryPtr::eq( const Type *t ) const {
4565   const TypeAryPtr *p = t-&gt;is_aryptr();
4566   return
4567     _ary == p-&gt;_ary &amp;&amp;  // Check array
4568     TypeOopPtr::eq(p) &amp;&amp;// Check sub-parts
4569     _field_offset == p-&gt;_field_offset;
4570 }
4571 
4572 //------------------------------hash-------------------------------------------
4573 // Type-specific hashing function.
4574 int TypeAryPtr::hash(void) const {
4575   return (intptr_t)_ary + TypeOopPtr::hash() + _field_offset.get();
4576 }
4577 
4578 //------------------------------meet-------------------------------------------
4579 // Compute the MEET of two types.  It returns a new Type object.
4580 const Type *TypeAryPtr::xmeet_helper(const Type *t) const {
4581   // Perform a fast test for common case; meeting the same types together.
4582   if( this == t ) return this;  // Meeting same type-rep?
4583   // Current &quot;this-&gt;_base&quot; is Pointer
4584   switch (t-&gt;base()) {          // switch on original type
4585 
4586   // Mixing ints &amp; oops happens when javac reuses local variables
4587   case Int:
4588   case Long:
4589   case FloatTop:
4590   case FloatCon:
4591   case FloatBot:
4592   case DoubleTop:
4593   case DoubleCon:
4594   case DoubleBot:
4595   case NarrowOop:
4596   case NarrowKlass:
4597   case Bottom:                  // Ye Olde Default
4598     return Type::BOTTOM;
4599   case Top:
4600     return this;
4601 
4602   default:                      // All else is a mistake
4603     typerr(t);
4604 
4605   case OopPtr: {                // Meeting to OopPtrs
4606     // Found a OopPtr type vs self-AryPtr type
4607     const TypeOopPtr *tp = t-&gt;is_oopptr();
4608     Offset offset = meet_offset(tp-&gt;offset());
4609     PTR ptr = meet_ptr(tp-&gt;ptr());
4610     int depth = meet_inline_depth(tp-&gt;inline_depth());
4611     const TypePtr* speculative = xmeet_speculative(tp);
4612     switch (tp-&gt;ptr()) {
4613     case TopPTR:
4614     case AnyNull: {
4615       int instance_id = meet_instance_id(InstanceTop);
4616       return make(ptr, (ptr == Constant ? const_oop() : NULL),
4617                   _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4618     }
4619     case BotPTR:
4620     case NotNull: {
4621       int instance_id = meet_instance_id(tp-&gt;instance_id());
4622       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4623     }
4624     default: ShouldNotReachHere();
4625     }
4626   }
4627 
4628   case AnyPtr: {                // Meeting two AnyPtrs
4629     // Found an AnyPtr type vs self-AryPtr type
4630     const TypePtr *tp = t-&gt;is_ptr();
4631     Offset offset = meet_offset(tp-&gt;offset());
4632     PTR ptr = meet_ptr(tp-&gt;ptr());
4633     const TypePtr* speculative = xmeet_speculative(tp);
4634     int depth = meet_inline_depth(tp-&gt;inline_depth());
4635     switch (tp-&gt;ptr()) {
4636     case TopPTR:
4637       return this;
4638     case BotPTR:
4639     case NotNull:
4640       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4641     case Null:
4642       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4643       // else fall through to AnyNull
4644     case AnyNull: {
4645       int instance_id = meet_instance_id(InstanceTop);
4646       return make(ptr, (ptr == Constant ? const_oop() : NULL),
4647                   _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4648     }
4649     default: ShouldNotReachHere();
4650     }
4651   }
4652 
4653   case MetadataPtr:
4654   case KlassPtr:
4655   case RawPtr: return TypePtr::BOTTOM;
4656 
4657   case AryPtr: {                // Meeting 2 references?
4658     const TypeAryPtr *tap = t-&gt;is_aryptr();
4659     Offset off = meet_offset(tap-&gt;offset());
4660     Offset field_off = meet_field_offset(tap-&gt;field_offset());
4661     const TypeAry *tary = _ary-&gt;meet_speculative(tap-&gt;_ary)-&gt;is_ary();
4662     PTR ptr = meet_ptr(tap-&gt;ptr());
4663     int instance_id = meet_instance_id(tap-&gt;instance_id());
4664     const TypePtr* speculative = xmeet_speculative(tap);
4665     int depth = meet_inline_depth(tap-&gt;inline_depth());
4666     ciKlass* lazy_klass = NULL;
4667     if (tary-&gt;_elem-&gt;isa_int()) {
4668       // Integral array element types have irrelevant lattice relations.
4669       // It is the klass that determines array layout, not the element type.
4670       if (_klass == NULL)
4671         lazy_klass = tap-&gt;_klass;
4672       else if (tap-&gt;_klass == NULL || tap-&gt;_klass == _klass) {
4673         lazy_klass = _klass;
4674       } else {
4675         // Something like byte[int+] meets char[int+].
4676         // This must fall to bottom, not (int[-128..65535])[int+].
4677         instance_id = InstanceBot;
4678         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4679       }
4680     } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp;
4681                klass()-&gt;as_array_klass()-&gt;storage_properties().value() != tap-&gt;klass()-&gt;as_array_klass()-&gt;storage_properties().value()) {
4682       // Meeting value type arrays with conflicting storage properties
4683       if (tary-&gt;_elem-&gt;isa_valuetype()) {
4684         // Result is flattened
4685         off = Offset(elem()-&gt;isa_valuetype() ? offset() : tap-&gt;offset());
4686         field_off = elem()-&gt;isa_valuetype() ? field_offset() : tap-&gt;field_offset();
4687       } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {
4688         // Result is non-flattened
4689         off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));
4690         field_off = Offset::bottom;
4691       }
4692     } else // Non integral arrays.
4693       // Must fall to bottom if exact klasses in upper lattice
4694       // are not equal or super klass is exact.
4695       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4696           // meet with top[] and bottom[] are processed further down:
4697           tap-&gt;_klass != NULL &amp;&amp; this-&gt;_klass != NULL &amp;&amp;
4698           // both are exact and not equal:
4699           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4700            // &#39;tap&#39; is exact and super or unrelated:
4701            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4702            // &#39;this&#39; is exact and super or unrelated:
4703            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
<a name="8" id="anc8"></a><span class="line-modified">4704       if (above_centerline(ptr)) {</span>
4705         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4706       }
4707       return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);
4708     }
4709 
4710     bool xk = false;
4711     switch (tap-&gt;ptr()) {
4712     case AnyNull:
4713     case TopPTR:
4714       // Compute new klass on demand, do not use tap-&gt;_klass
4715       if (below_centerline(this-&gt;_ptr)) {
4716         xk = this-&gt;_klass_is_exact;
4717       } else {
4718         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4719       }
4720       return make(ptr, const_oop(), tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4721     case Constant: {
4722       ciObject* o = const_oop();
4723       if( _ptr == Constant ) {
4724         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
4725           xk = (klass() == tap-&gt;klass());
4726           ptr = NotNull;
4727           o = NULL;
4728           instance_id = InstanceBot;
4729         } else {
4730           xk = true;
4731         }
4732       } else if(above_centerline(_ptr)) {
4733         o = tap-&gt;const_oop();
4734         xk = true;
4735       } else {
4736         // Only precise for identical arrays
4737         xk = this-&gt;_klass_is_exact &amp;&amp; (klass() == tap-&gt;klass());
4738       }
4739       return TypeAryPtr::make(ptr, o, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4740     }
4741     case NotNull:
4742     case BotPTR:
4743       // Compute new klass on demand, do not use tap-&gt;_klass
4744       if (above_centerline(this-&gt;_ptr))
4745             xk = tap-&gt;_klass_is_exact;
4746       else  xk = (tap-&gt;_klass_is_exact &amp; this-&gt;_klass_is_exact) &amp;&amp;
4747               (klass() == tap-&gt;klass()); // Only precise for identical arrays
4748       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4749     default: ShouldNotReachHere();
4750     }
4751   }
4752 
4753   // All arrays inherit from Object class
4754   case InstPtr: {
4755     const TypeInstPtr *tp = t-&gt;is_instptr();
4756     Offset offset = meet_offset(tp-&gt;offset());
4757     PTR ptr = meet_ptr(tp-&gt;ptr());
4758     int instance_id = meet_instance_id(tp-&gt;instance_id());
4759     const TypePtr* speculative = xmeet_speculative(tp);
4760     int depth = meet_inline_depth(tp-&gt;inline_depth());
4761     switch (ptr) {
4762     case TopPTR:
4763     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
4764       // For instances when a subclass meets a superclass we fall
4765       // below the centerline when the superclass is exact. We need to
4766       // do the same here.
4767       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {
4768         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4769       } else {
4770         // cannot subclass, so the meet has to fall badly below the centerline
4771         ptr = NotNull;
4772         instance_id = InstanceBot;
4773         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4774       }
4775     case Constant:
4776     case NotNull:
4777     case BotPTR:                // Fall down to object klass
4778       // LCA is object_klass, but if we subclass from the top we can do better
4779       if (above_centerline(tp-&gt;ptr())) {
4780         // If &#39;tp&#39;  is above the centerline and it is Object class
4781         // then we can subclass in the Java class hierarchy.
4782         // For instances when a subclass meets a superclass we fall
4783         // below the centerline when the superclass is exact. We need
4784         // to do the same here.
4785         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {
4786           // that is, my array type is a subtype of &#39;tp&#39; klass
4787           return make(ptr, (ptr == Constant ? const_oop() : NULL),
4788                       _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4789         }
4790       }
4791       // The other case cannot happen, since t cannot be a subtype of an array.
4792       // The meet falls down to Object class below centerline.
4793       if( ptr == Constant )
4794          ptr = NotNull;
4795       instance_id = InstanceBot;
4796       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4797     default: typerr(t);
4798     }
4799   }
4800 
4801   case ValueType: {
4802     // All value types inherit from Object
4803     PTR ptr = this-&gt;_ptr;
4804     if (ptr == Constant) {
4805       ptr = NotNull;
4806     }
4807     return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());
4808   }
4809 
4810   }
4811   return this;                  // Lint noise
4812 }
4813 
4814 //------------------------------xdual------------------------------------------
4815 // Dual: compute field-by-field dual
4816 const Type *TypeAryPtr::xdual() const {
4817   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(), _klass, _klass_is_exact, dual_offset(), dual_field_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());
4818 }
4819 
4820 Type::Offset TypeAryPtr::meet_field_offset(const Type::Offset offset) const {
4821   return _field_offset.meet(offset);
4822 }
4823 
4824 //------------------------------dual_offset------------------------------------
4825 Type::Offset TypeAryPtr::dual_field_offset() const {
4826   return _field_offset.dual();
4827 }
4828 
4829 //----------------------interface_vs_oop---------------------------------------
4830 #ifdef ASSERT
4831 bool TypeAryPtr::interface_vs_oop(const Type *t) const {
4832   const TypeAryPtr* t_aryptr = t-&gt;isa_aryptr();
4833   if (t_aryptr) {
4834     return _ary-&gt;interface_vs_oop(t_aryptr-&gt;_ary);
4835   }
4836   return false;
4837 }
4838 #endif
4839 
4840 //------------------------------dump2------------------------------------------
4841 #ifndef PRODUCT
4842 void TypeAryPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4843   _ary-&gt;dump2(d,depth,st);
4844   switch( _ptr ) {
4845   case Constant:
4846     const_oop()-&gt;print(st);
4847     break;
4848   case BotPTR:
4849     if (!WizardMode &amp;&amp; !Verbose) {
4850       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4851       break;
4852     }
4853   case TopPTR:
4854   case AnyNull:
4855   case NotNull:
4856     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4857     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4858     break;
4859   default:
4860     break;
4861   }
4862 
4863   if (elem()-&gt;isa_valuetype()) {
4864     st-&gt;print(&quot;(&quot;);
4865     _field_offset.dump2(st);
4866     st-&gt;print(&quot;)&quot;);
4867   }
4868   if (offset() != 0) {
4869     int header_size = objArrayOopDesc::header_size() * wordSize;
4870     if( _offset == Offset::top )       st-&gt;print(&quot;+undefined&quot;);
4871     else if( _offset == Offset::bottom )  st-&gt;print(&quot;+any&quot;);
4872     else if( offset() &lt; header_size ) st-&gt;print(&quot;+%d&quot;, offset());
4873     else {
4874       BasicType basic_elem_type = elem()-&gt;basic_type();
4875       int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
4876       int elem_size = type2aelembytes(basic_elem_type);
4877       st-&gt;print(&quot;[%d]&quot;, (offset() - array_base)/elem_size);
4878     }
4879   }
4880   st-&gt;print(&quot; *&quot;);
4881   if (_instance_id == InstanceTop)
4882     st-&gt;print(&quot;,iid=top&quot;);
4883   else if (_instance_id != InstanceBot)
4884     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4885 
4886   dump_inline_depth(st);
4887   dump_speculative(st);
4888 }
4889 #endif
4890 
4891 bool TypeAryPtr::empty(void) const {
4892   if (_ary-&gt;empty())       return true;
4893   return TypeOopPtr::empty();
4894 }
4895 
4896 //------------------------------add_offset-------------------------------------
4897 const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {
4898   return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, xadd_offset(offset), _field_offset, _instance_id, add_offset_speculative(offset), _inline_depth, _is_autobox_cache);
4899 }
4900 
4901 const Type *TypeAryPtr::remove_speculative() const {
4902   if (_speculative == NULL) {
4903     return this;
4904   }
4905   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
4906   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, NULL, _inline_depth, _is_autobox_cache);
4907 }
4908 
4909 const Type* TypeAryPtr::cleanup_speculative() const {
4910   if (speculative() == NULL) {
4911     return this;
4912   }
4913   // Keep speculative part if it contains information about flat-/nullability
4914   const TypeAryPtr* spec_aryptr = speculative()-&gt;isa_aryptr();
4915   if (spec_aryptr != NULL &amp;&amp; (spec_aryptr-&gt;is_not_flat() || spec_aryptr-&gt;is_not_null_free())) {
4916     return this;
4917   }
4918   return TypeOopPtr::cleanup_speculative();
4919 }
4920 
4921 const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {
4922   if (!UseInlineDepthForSpeculativeTypes) {
4923     return this;
4924   }
4925   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, _speculative, depth, _is_autobox_cache);
4926 }
4927 
4928 const TypeAryPtr* TypeAryPtr::with_field_offset(int offset) const {
4929   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, Offset(offset), _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4930 }
4931 
4932 const TypePtr* TypeAryPtr::add_field_offset_and_offset(intptr_t offset) const {
4933   int adj = 0;
4934   if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop) {
4935     const Type* elemtype = elem();
4936     if (elemtype-&gt;isa_valuetype()) {
4937       if (_offset.get() != OffsetBot &amp;&amp; _offset.get() != OffsetTop) {
4938         adj = _offset.get();
4939         offset += _offset.get();
4940       }
4941       uint header = arrayOopDesc::base_offset_in_bytes(T_OBJECT);
4942       if (_field_offset.get() != OffsetBot &amp;&amp; _field_offset.get() != OffsetTop) {
4943         offset += _field_offset.get();
4944         if (_offset.get() == OffsetBot || _offset.get() == OffsetTop) {
4945           offset += header;
4946         }
4947       }
4948       if (offset &gt;= (intptr_t)header || offset &lt; 0) {
4949         // Try to get the field of the value type array element we are pointing to
4950         ciKlass* arytype_klass = klass();
4951         ciValueArrayKlass* vak = arytype_klass-&gt;as_value_array_klass();
4952         ciValueKlass* vk = vak-&gt;element_klass()-&gt;as_value_klass();
4953         int shift = vak-&gt;log2_element_size();
4954         int mask = (1 &lt;&lt; shift) - 1;
4955         intptr_t field_offset = ((offset - header) &amp; mask);
4956         ciField* field = vk-&gt;get_field_by_offset(field_offset + vk-&gt;first_field_offset(), false);
4957         if (field == NULL) {
4958           // This may happen with nested AddP(base, AddP(base, base, offset), longcon(16))
4959           return add_offset(offset);
4960         } else {
4961           return with_field_offset(field_offset)-&gt;add_offset(offset - field_offset - adj);
4962         }
4963       }
4964     }
4965   }
4966   return add_offset(offset - adj);
4967 }
4968 
4969 // Return offset incremented by field_offset for flattened value type arrays
4970 const int TypeAryPtr::flattened_offset() const {
4971   int offset = _offset.get();
4972   if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop &amp;&amp;
4973       _field_offset != Offset::bottom &amp;&amp; _field_offset != Offset::top) {
4974     offset += _field_offset.get();
4975   }
4976   return offset;
4977 }
4978 
4979 const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {
4980   assert(is_known_instance(), &quot;should be known&quot;);
4981   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, instance_id, _speculative, _inline_depth);
4982 }
4983 
4984 //=============================================================================
4985 
4986 
4987 //------------------------------hash-------------------------------------------
4988 // Type-specific hashing function.
4989 int TypeNarrowPtr::hash(void) const {
4990   return _ptrtype-&gt;hash() + 7;
4991 }
4992 
4993 bool TypeNarrowPtr::singleton(void) const {    // TRUE if type is a singleton
4994   return _ptrtype-&gt;singleton();
4995 }
4996 
4997 bool TypeNarrowPtr::empty(void) const {
4998   return _ptrtype-&gt;empty();
4999 }
5000 
5001 intptr_t TypeNarrowPtr::get_con() const {
5002   return _ptrtype-&gt;get_con();
5003 }
5004 
5005 bool TypeNarrowPtr::eq( const Type *t ) const {
5006   const TypeNarrowPtr* tc = isa_same_narrowptr(t);
5007   if (tc != NULL) {
5008     if (_ptrtype-&gt;base() != tc-&gt;_ptrtype-&gt;base()) {
5009       return false;
5010     }
5011     return tc-&gt;_ptrtype-&gt;eq(_ptrtype);
5012   }
5013   return false;
5014 }
5015 
5016 const Type *TypeNarrowPtr::xdual() const {    // Compute dual right now.
5017   const TypePtr* odual = _ptrtype-&gt;dual()-&gt;is_ptr();
5018   return make_same_narrowptr(odual);
5019 }
5020 
5021 
5022 const Type *TypeNarrowPtr::filter_helper(const Type *kills, bool include_speculative) const {
5023   if (isa_same_narrowptr(kills)) {
5024     const Type* ft =_ptrtype-&gt;filter_helper(is_same_narrowptr(kills)-&gt;_ptrtype, include_speculative);
5025     if (ft-&gt;empty())
5026       return Type::TOP;           // Canonical empty value
5027     if (ft-&gt;isa_ptr()) {
5028       return make_hash_same_narrowptr(ft-&gt;isa_ptr());
5029     }
5030     return ft;
5031   } else if (kills-&gt;isa_ptr()) {
5032     const Type* ft = _ptrtype-&gt;join_helper(kills, include_speculative);
5033     if (ft-&gt;empty())
5034       return Type::TOP;           // Canonical empty value
5035     return ft;
5036   } else {
5037     return Type::TOP;
5038   }
5039 }
5040 
5041 //------------------------------xmeet------------------------------------------
5042 // Compute the MEET of two types.  It returns a new Type object.
5043 const Type *TypeNarrowPtr::xmeet( const Type *t ) const {
5044   // Perform a fast test for common case; meeting the same types together.
5045   if( this == t ) return this;  // Meeting same type-rep?
5046 
5047   if (t-&gt;base() == base()) {
5048     const Type* result = _ptrtype-&gt;xmeet(t-&gt;make_ptr());
5049     if (result-&gt;isa_ptr()) {
5050       return make_hash_same_narrowptr(result-&gt;is_ptr());
5051     }
5052     return result;
5053   }
5054 
5055   // Current &quot;this-&gt;_base&quot; is NarrowKlass or NarrowOop
5056   switch (t-&gt;base()) {          // switch on original type
5057 
5058   case Int:                     // Mixing ints &amp; oops happens when javac
5059   case Long:                    // reuses local variables
5060   case FloatTop:
5061   case FloatCon:
5062   case FloatBot:
5063   case DoubleTop:
5064   case DoubleCon:
5065   case DoubleBot:
5066   case AnyPtr:
5067   case RawPtr:
5068   case OopPtr:
5069   case InstPtr:
5070   case AryPtr:
5071   case MetadataPtr:
5072   case KlassPtr:
5073   case NarrowOop:
5074   case NarrowKlass:
5075   case Bottom:                  // Ye Olde Default
5076     return Type::BOTTOM;
5077   case Top:
5078     return this;
5079 
5080   case ValueType:
5081     return t-&gt;xmeet(this);
5082 
5083   default:                      // All else is a mistake
5084     typerr(t);
5085 
5086   } // End of switch
5087 
5088   return this;
5089 }
5090 
5091 #ifndef PRODUCT
5092 void TypeNarrowPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5093   _ptrtype-&gt;dump2(d, depth, st);
5094 }
5095 #endif
5096 
5097 const TypeNarrowOop *TypeNarrowOop::BOTTOM;
5098 const TypeNarrowOop *TypeNarrowOop::NULL_PTR;
5099 
5100 
5101 const TypeNarrowOop* TypeNarrowOop::make(const TypePtr* type) {
5102   return (const TypeNarrowOop*)(new TypeNarrowOop(type))-&gt;hashcons();
5103 }
5104 
5105 const Type* TypeNarrowOop::remove_speculative() const {
5106   return make(_ptrtype-&gt;remove_speculative()-&gt;is_ptr());
5107 }
5108 
5109 const Type* TypeNarrowOop::cleanup_speculative() const {
5110   return make(_ptrtype-&gt;cleanup_speculative()-&gt;is_ptr());
5111 }
5112 
5113 #ifndef PRODUCT
5114 void TypeNarrowOop::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5115   st-&gt;print(&quot;narrowoop: &quot;);
5116   TypeNarrowPtr::dump2(d, depth, st);
5117 }
5118 #endif
5119 
5120 const TypeNarrowKlass *TypeNarrowKlass::NULL_PTR;
5121 
5122 const TypeNarrowKlass* TypeNarrowKlass::make(const TypePtr* type) {
5123   return (const TypeNarrowKlass*)(new TypeNarrowKlass(type))-&gt;hashcons();
5124 }
5125 
5126 #ifndef PRODUCT
5127 void TypeNarrowKlass::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5128   st-&gt;print(&quot;narrowklass: &quot;);
5129   TypeNarrowPtr::dump2(d, depth, st);
5130 }
5131 #endif
5132 
5133 
5134 //------------------------------eq---------------------------------------------
5135 // Structural equality check for Type representations
5136 bool TypeMetadataPtr::eq( const Type *t ) const {
5137   const TypeMetadataPtr *a = (const TypeMetadataPtr*)t;
5138   ciMetadata* one = metadata();
5139   ciMetadata* two = a-&gt;metadata();
5140   if (one == NULL || two == NULL) {
5141     return (one == two) &amp;&amp; TypePtr::eq(t);
5142   } else {
5143     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
5144   }
5145 }
5146 
5147 //------------------------------hash-------------------------------------------
5148 // Type-specific hashing function.
5149 int TypeMetadataPtr::hash(void) const {
5150   return
5151     (metadata() ? metadata()-&gt;hash() : 0) +
5152     TypePtr::hash();
5153 }
5154 
5155 //------------------------------singleton--------------------------------------
5156 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5157 // constants
5158 bool TypeMetadataPtr::singleton(void) const {
5159   // detune optimizer to not generate constant metadata + constant offset as a constant!
5160   // TopPTR, Null, AnyNull, Constant are all singletons
5161   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);
5162 }
5163 
5164 //------------------------------add_offset-------------------------------------
5165 const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {
5166   return make( _ptr, _metadata, xadd_offset(offset));
5167 }
5168 
5169 //-----------------------------filter------------------------------------------
5170 // Do not allow interface-vs.-noninterface joins to collapse to top.
5171 const Type *TypeMetadataPtr::filter_helper(const Type *kills, bool include_speculative) const {
5172   const TypeMetadataPtr* ft = join_helper(kills, include_speculative)-&gt;isa_metadataptr();
5173   if (ft == NULL || ft-&gt;empty())
5174     return Type::TOP;           // Canonical empty value
5175   return ft;
5176 }
5177 
5178  //------------------------------get_con----------------------------------------
5179 intptr_t TypeMetadataPtr::get_con() const {
5180   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
5181   assert(offset() &gt;= 0, &quot;&quot;);
5182 
5183   if (offset() != 0) {
5184     // After being ported to the compiler interface, the compiler no longer
5185     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5186     // to a handle at compile time.  This handle is embedded in the generated
5187     // code and dereferenced at the time the nmethod is made.  Until that time,
5188     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5189     // have access to the addresses!).  This does not seem to currently happen,
5190     // but this assertion here is to help prevent its occurence.
5191     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5192     ShouldNotReachHere();
5193   }
5194 
5195   return (intptr_t)metadata()-&gt;constant_encoding();
5196 }
5197 
5198 //------------------------------cast_to_ptr_type-------------------------------
5199 const Type *TypeMetadataPtr::cast_to_ptr_type(PTR ptr) const {
5200   if( ptr == _ptr ) return this;
5201   return make(ptr, metadata(), _offset);
5202 }
5203 
5204 //------------------------------meet-------------------------------------------
5205 // Compute the MEET of two types.  It returns a new Type object.
5206 const Type *TypeMetadataPtr::xmeet( const Type *t ) const {
5207   // Perform a fast test for common case; meeting the same types together.
5208   if( this == t ) return this;  // Meeting same type-rep?
5209 
5210   // Current &quot;this-&gt;_base&quot; is OopPtr
5211   switch (t-&gt;base()) {          // switch on original type
5212 
5213   case Int:                     // Mixing ints &amp; oops happens when javac
5214   case Long:                    // reuses local variables
5215   case FloatTop:
5216   case FloatCon:
5217   case FloatBot:
5218   case DoubleTop:
5219   case DoubleCon:
5220   case DoubleBot:
5221   case NarrowOop:
5222   case NarrowKlass:
5223   case Bottom:                  // Ye Olde Default
5224     return Type::BOTTOM;
5225   case Top:
5226     return this;
5227 
5228   default:                      // All else is a mistake
5229     typerr(t);
5230 
5231   case AnyPtr: {
5232     // Found an AnyPtr type vs self-OopPtr type
5233     const TypePtr *tp = t-&gt;is_ptr();
5234     Offset offset = meet_offset(tp-&gt;offset());
5235     PTR ptr = meet_ptr(tp-&gt;ptr());
5236     switch (tp-&gt;ptr()) {
5237     case Null:
5238       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5239       // else fall through:
5240     case TopPTR:
5241     case AnyNull: {
5242       return make(ptr, _metadata, offset);
5243     }
5244     case BotPTR:
5245     case NotNull:
5246       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5247     default: typerr(t);
5248     }
5249   }
5250 
5251   case RawPtr:
5252   case KlassPtr:
5253   case OopPtr:
5254   case InstPtr:
5255   case AryPtr:
5256     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
5257 
5258   case MetadataPtr: {
5259     const TypeMetadataPtr *tp = t-&gt;is_metadataptr();
5260     Offset offset = meet_offset(tp-&gt;offset());
5261     PTR tptr = tp-&gt;ptr();
5262     PTR ptr = meet_ptr(tptr);
5263     ciMetadata* md = (tptr == TopPTR) ? metadata() : tp-&gt;metadata();
5264     if (tptr == TopPTR || _ptr == TopPTR ||
5265         metadata()-&gt;equals(tp-&gt;metadata())) {
5266       return make(ptr, md, offset);
5267     }
5268     // metadata is different
5269     if( ptr == Constant ) {  // Cannot be equal constants, so...
5270       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
5271       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
5272       ptr = NotNull;            // Fall down in lattice
5273     }
5274     return make(ptr, NULL, offset);
5275     break;
5276   }
5277   } // End of switch
5278   return this;                  // Return the double constant
5279 }
5280 
5281 
5282 //------------------------------xdual------------------------------------------
5283 // Dual of a pure metadata pointer.
5284 const Type *TypeMetadataPtr::xdual() const {
5285   return new TypeMetadataPtr(dual_ptr(), metadata(), dual_offset());
5286 }
5287 
5288 //------------------------------dump2------------------------------------------
5289 #ifndef PRODUCT
5290 void TypeMetadataPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
5291   st-&gt;print(&quot;metadataptr:%s&quot;, ptr_msg[_ptr]);
5292   if( metadata() ) st-&gt;print(INTPTR_FORMAT, p2i(metadata()));
5293   switch (offset()) {
5294   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
5295   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
5296   case         0: break;
5297   default:        st-&gt;print(&quot;+%d&quot;,offset()); break;
5298   }
5299 }
5300 #endif
5301 
5302 
5303 //=============================================================================
5304 // Convenience common pre-built type.
5305 const TypeMetadataPtr *TypeMetadataPtr::BOTTOM;
5306 
5307 TypeMetadataPtr::TypeMetadataPtr(PTR ptr, ciMetadata* metadata, Offset offset):
5308   TypePtr(MetadataPtr, ptr, offset), _metadata(metadata) {
5309 }
5310 
5311 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethod* m) {
5312   return make(Constant, m, Offset(0));
5313 }
5314 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethodData* m) {
5315   return make(Constant, m, Offset(0));
5316 }
5317 
5318 //------------------------------make-------------------------------------------
5319 // Create a meta data constant
5320 const TypeMetadataPtr* TypeMetadataPtr::make(PTR ptr, ciMetadata* m, Offset offset) {
5321   assert(m == NULL || !m-&gt;is_klass(), &quot;wrong type&quot;);
5322   return (TypeMetadataPtr*)(new TypeMetadataPtr(ptr, m, offset))-&gt;hashcons();
5323 }
5324 
5325 
5326 //=============================================================================
5327 // Convenience common pre-built types.
5328 
5329 // Not-null object klass or below
5330 const TypeKlassPtr *TypeKlassPtr::OBJECT;
5331 const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
5332 
5333 //------------------------------TypeKlassPtr-----------------------------------
5334 TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array)
5335   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant), _flat_array(flat_array) {
5336    assert(!klass-&gt;is_valuetype() || !klass-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);
5337    assert(!flat_array || can_be_value_type(), &quot;incorrect flatten array bit&quot;);
5338 }
5339 
5340 //------------------------------make-------------------------------------------
5341 // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
5342 const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flat_array) {
5343   assert(k == NULL || k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);
5344   return (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset, flat_array))-&gt;hashcons();
5345 }
5346 
5347 //------------------------------eq---------------------------------------------
5348 // Structural equality check for Type representations
5349 bool TypeKlassPtr::eq( const Type *t ) const {
5350   const TypeKlassPtr *p = t-&gt;is_klassptr();
5351   return klass() == p-&gt;klass() &amp;&amp; TypePtr::eq(p) &amp;&amp; flat_array() == p-&gt;flat_array();
5352 }
5353 
5354 //------------------------------hash-------------------------------------------
5355 // Type-specific hashing function.
5356 int TypeKlassPtr::hash(void) const {
5357   return java_add(java_add(klass() != NULL ? klass()-&gt;hash() : (jint)0, (jint)TypePtr::hash()), (jint)flat_array());
5358 }
5359 
5360 //------------------------------singleton--------------------------------------
5361 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5362 // constants
5363 bool TypeKlassPtr::singleton(void) const {
5364   // detune optimizer to not generate constant klass + constant offset as a constant!
5365   // TopPTR, Null, AnyNull, Constant are all singletons
5366   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);
5367 }
5368 
5369 // Do not allow interface-vs.-noninterface joins to collapse to top.
5370 const Type *TypeKlassPtr::filter_helper(const Type *kills, bool include_speculative) const {
5371   // logic here mirrors the one from TypeOopPtr::filter. See comments
5372   // there.
5373   const Type* ft = join_helper(kills, include_speculative);
5374   const TypeKlassPtr* ftkp = ft-&gt;isa_klassptr();
5375   const TypeKlassPtr* ktkp = kills-&gt;isa_klassptr();
5376 
5377   if (ft-&gt;empty()) {
5378     if (!empty() &amp;&amp; ktkp != NULL &amp;&amp; ktkp-&gt;is_loaded() &amp;&amp; ktkp-&gt;klass()-&gt;is_interface())
5379       return kills;             // Uplift to interface
5380 
5381     return Type::TOP;           // Canonical empty value
5382   }
5383 
5384   // Interface klass type could be exact in opposite to interface type,
5385   // return it here instead of incorrect Constant ptr J/L/Object (6894807).
5386   if (ftkp != NULL &amp;&amp; ktkp != NULL &amp;&amp;
5387       ftkp-&gt;is_loaded() &amp;&amp;  ftkp-&gt;klass()-&gt;is_interface() &amp;&amp;
5388       !ftkp-&gt;klass_is_exact() &amp;&amp; // Keep exact interface klass
5389       ktkp-&gt;is_loaded() &amp;&amp; !ktkp-&gt;klass()-&gt;is_interface()) {
5390     return ktkp-&gt;cast_to_ptr_type(ftkp-&gt;ptr());
5391   }
5392 
5393   return ft;
5394 }
5395 
5396 //----------------------compute_klass------------------------------------------
5397 // Compute the defining klass for this class
5398 ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {
5399   // Compute _klass based on element type.
5400   ciKlass* k_ary = NULL;
5401   const TypeAryPtr *tary;
5402   const Type* el = elem();
5403   if (el-&gt;isa_narrowoop()) {
5404     el = el-&gt;make_ptr();
5405   }
5406 
5407   // Get element klass
5408   if (el-&gt;isa_instptr()) {
5409     // Compute object array klass from element klass
5410     bool null_free = el-&gt;is_valuetypeptr() &amp;&amp; el-&gt;isa_instptr()-&gt;ptr() != TypePtr::TopPTR &amp;&amp; !el-&gt;isa_instptr()-&gt;maybe_null();
5411     k_ary = ciArrayKlass::make(el-&gt;is_oopptr()-&gt;klass(), null_free);
5412   } else if (el-&gt;isa_valuetype()) {
5413     if (el-&gt;value_klass() != NULL) {
5414       k_ary = ciArrayKlass::make(el-&gt;value_klass(), /* null_free */ true);
5415     }
5416   } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
5417     // Compute array klass from element klass
5418     ciKlass* k_elem = tary-&gt;klass();
5419     // If element type is something like bottom[], k_elem will be null.
5420     if (k_elem != NULL)
5421       k_ary = ciObjArrayKlass::make(k_elem);
5422   } else if ((el-&gt;base() == Type::Top) ||
5423              (el-&gt;base() == Type::Bottom)) {
5424     // element type of Bottom occurs from meet of basic type
5425     // and object; Top occurs when doing join on Bottom.
5426     // Leave k_ary at NULL.
5427   } else {
5428     // Cannot compute array klass directly from basic type,
5429     // since subtypes of TypeInt all have basic type T_INT.
5430 #ifdef ASSERT
5431     if (verify &amp;&amp; el-&gt;isa_int()) {
5432       // Check simple cases when verifying klass.
5433       BasicType bt = T_ILLEGAL;
5434       if (el == TypeInt::BYTE) {
5435         bt = T_BYTE;
5436       } else if (el == TypeInt::SHORT) {
5437         bt = T_SHORT;
5438       } else if (el == TypeInt::CHAR) {
5439         bt = T_CHAR;
5440       } else if (el == TypeInt::INT) {
5441         bt = T_INT;
5442       } else {
5443         return _klass; // just return specified klass
5444       }
5445       return ciTypeArrayKlass::make(bt);
5446     }
5447 #endif
5448     assert(!el-&gt;isa_int(),
5449            &quot;integral arrays must be pre-equipped with a class&quot;);
5450     // Compute array klass directly from basic type
5451     k_ary = ciTypeArrayKlass::make(el-&gt;basic_type());
5452   }
5453   return k_ary;
5454 }
5455 
5456 //------------------------------klass------------------------------------------
5457 // Return the defining klass for this class
5458 ciKlass* TypeAryPtr::klass() const {
5459   if( _klass ) return _klass;   // Return cached value, if possible
5460 
5461   // Oops, need to compute _klass and cache it
5462   ciKlass* k_ary = compute_klass();
5463 
5464   if( this != TypeAryPtr::OOPS &amp;&amp; this-&gt;dual() != TypeAryPtr::OOPS ) {
5465     // The _klass field acts as a cache of the underlying
5466     // ciKlass for this array type.  In order to set the field,
5467     // we need to cast away const-ness.
5468     //
5469     // IMPORTANT NOTE: we *never* set the _klass field for the
5470     // type TypeAryPtr::OOPS.  This Type is shared between all
5471     // active compilations.  However, the ciKlass which represents
5472     // this Type is *not* shared between compilations, so caching
5473     // this value would result in fetching a dangling pointer.
5474     //
5475     // Recomputing the underlying ciKlass for each request is
5476     // a bit less efficient than caching, but calls to
5477     // TypeAryPtr::OOPS-&gt;klass() are not common enough to matter.
5478     ((TypeAryPtr*)this)-&gt;_klass = k_ary;
5479     if (UseCompressedOops &amp;&amp; k_ary != NULL &amp;&amp; k_ary-&gt;is_obj_array_klass() &amp;&amp;
5480         offset() != 0 &amp;&amp; offset() != arrayOopDesc::length_offset_in_bytes()) {
5481       ((TypeAryPtr*)this)-&gt;_is_ptr_to_narrowoop = true;
5482     }
5483   }
5484   return k_ary;
5485 }
5486 
5487 
5488 //------------------------------add_offset-------------------------------------
5489 // Access internals of klass object
5490 const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
5491   return make(_ptr, klass(), xadd_offset(offset), flat_array());
5492 }
5493 
5494 //------------------------------cast_to_ptr_type-------------------------------
5495 const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
5496   assert(_base == KlassPtr, &quot;subclass must override cast_to_ptr_type&quot;);
5497   if( ptr == _ptr ) return this;
5498   return make(ptr, _klass, _offset, _flat_array);
5499 }
5500 
5501 
5502 //-----------------------------cast_to_exactness-------------------------------
5503 const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
5504   if( klass_is_exact == _klass_is_exact ) return this;
5505   if (!UseExactTypes)  return this;
5506   return make(klass_is_exact ? Constant : NotNull, _klass, _offset, _flat_array);
5507 }
5508 
5509 
5510 //-----------------------------as_instance_type--------------------------------
5511 // Corresponding type for an instance of the given class.
5512 // It will be NotNull, and exact if and only if the klass type is exact.
5513 const TypeOopPtr* TypeKlassPtr::as_instance_type() const {
5514   ciKlass* k = klass();
5515   assert(k != NULL, &quot;klass should not be NULL&quot;);
5516   bool    xk = klass_is_exact();
5517   //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
5518   const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
5519   guarantee(toop != NULL, &quot;need type for given klass&quot;);
5520   toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
5521   if (flat_array() &amp;&amp; !klass()-&gt;is_valuetype()) {
5522     toop = toop-&gt;is_instptr()-&gt;cast_to_flat_array();
5523   }
5524   return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
5525 }
5526 
5527 
5528 //------------------------------xmeet------------------------------------------
5529 // Compute the MEET of two types, return a new Type object.
5530 const Type    *TypeKlassPtr::xmeet( const Type *t ) const {
5531   // Perform a fast test for common case; meeting the same types together.
5532   if( this == t ) return this;  // Meeting same type-rep?
5533 
5534   // Current &quot;this-&gt;_base&quot; is Pointer
5535   switch (t-&gt;base()) {          // switch on original type
5536 
5537   case Int:                     // Mixing ints &amp; oops happens when javac
5538   case Long:                    // reuses local variables
5539   case FloatTop:
5540   case FloatCon:
5541   case FloatBot:
5542   case DoubleTop:
5543   case DoubleCon:
5544   case DoubleBot:
5545   case NarrowOop:
5546   case NarrowKlass:
5547   case Bottom:                  // Ye Olde Default
5548     return Type::BOTTOM;
5549   case Top:
5550     return this;
5551 
5552   default:                      // All else is a mistake
5553     typerr(t);
5554 
5555   case AnyPtr: {                // Meeting to AnyPtrs
5556     // Found an AnyPtr type vs self-KlassPtr type
5557     const TypePtr *tp = t-&gt;is_ptr();
5558     Offset offset = meet_offset(tp-&gt;offset());
5559     PTR ptr = meet_ptr(tp-&gt;ptr());
5560     switch (tp-&gt;ptr()) {
5561     case TopPTR:
5562       return this;
5563     case Null:
5564       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5565     case AnyNull:
5566       return make(ptr, klass(), offset, flat_array());
5567     case BotPTR:
5568     case NotNull:
5569       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5570     default: typerr(t);
5571     }
5572   }
5573 
5574   case RawPtr:
5575   case MetadataPtr:
5576   case OopPtr:
5577   case AryPtr:                  // Meet with AryPtr
5578   case InstPtr:                 // Meet with InstPtr
5579     return TypePtr::BOTTOM;
5580 
5581   //
5582   //             A-top         }
5583   //           /   |   \       }  Tops
5584   //       B-top A-any C-top   }
5585   //          | /  |  \ |      }  Any-nulls
5586   //       B-any   |   C-any   }
5587   //          |    |    |
5588   //       B-con A-con C-con   } constants; not comparable across classes
5589   //          |    |    |
5590   //       B-not   |   C-not   }
5591   //          | \  |  / |      }  not-nulls
5592   //       B-bot A-not C-bot   }
5593   //           \   |   /       }  Bottoms
5594   //             A-bot         }
5595   //
5596 
5597   case KlassPtr: {  // Meet two KlassPtr types
5598     const TypeKlassPtr *tkls = t-&gt;is_klassptr();
5599     Offset  off  = meet_offset(tkls-&gt;offset());
5600     PTR  ptr     = meet_ptr(tkls-&gt;ptr());
5601 
5602     if (klass() == NULL || tkls-&gt;klass() == NULL) {
5603       ciKlass* k = NULL;
5604       if (ptr == Constant) {
5605         k = (klass() == NULL) ? tkls-&gt;klass() : klass();
5606       }
5607       return make(ptr, k, off, false);
5608     }
5609 
5610     // Check for easy case; klasses are equal (and perhaps not loaded!)
5611     // If we have constants, then we created oops so classes are loaded
5612     // and we can handle the constants further down.  This case handles
5613     // not-loaded classes
5614     if (ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) &amp;&amp; flat_array() == tkls-&gt;flat_array()) {
5615       return make(ptr, klass(), off, flat_array());
5616     }
5617 
5618     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
5619     ciKlass* tkls_klass = tkls-&gt;klass();
5620     ciKlass* this_klass = this-&gt;klass();
5621     assert( tkls_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5622     assert( this_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5623     bool tkls_flat_array = tkls-&gt;flat_array();
5624     bool this_flat_array  = this-&gt;flat_array();
5625     bool flat_array = below_centerline(ptr) ? (this_flat_array &amp;&amp; tkls_flat_array) : (this_flat_array || tkls_flat_array);
5626 
5627     // If &#39;this&#39; type is above the centerline and is a superclass of the
5628     // other, we can treat &#39;this&#39; as having the same type as the other.
5629     if ((above_centerline(this-&gt;ptr())) &amp;&amp;
5630         tkls_klass-&gt;is_subtype_of(this_klass)) {
5631       this_klass = tkls_klass;
5632     }
5633     // If &#39;tinst&#39; type is above the centerline and is a superclass of the
5634     // other, we can treat &#39;tinst&#39; as having the same type as the other.
5635     if ((above_centerline(tkls-&gt;ptr())) &amp;&amp;
5636         this_klass-&gt;is_subtype_of(tkls_klass)) {
5637       tkls_klass = this_klass;
5638     }
5639 
5640     // Check for classes now being equal
5641     if (tkls_klass-&gt;equals(this_klass)) {
5642       // If the klasses are equal, the constants may still differ.  Fall to
5643       // NotNull if they do (neither constant is NULL; that is a special case
5644       // handled elsewhere).
5645       if( ptr == Constant ) {
5646         if (this-&gt;_ptr == Constant &amp;&amp; tkls-&gt;_ptr == Constant &amp;&amp;
5647             this-&gt;klass()-&gt;equals(tkls-&gt;klass()));
5648         else if (above_centerline(this-&gt;ptr()));
5649         else if (above_centerline(tkls-&gt;ptr()));
5650         else
5651           ptr = NotNull;
5652       }
5653       return make(ptr, this_klass, off, flat_array);
5654     } // Else classes are not equal
5655 
5656     // Since klasses are different, we require the LCA in the Java
5657     // class hierarchy - which means we have to fall to at least NotNull.
5658     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
5659       ptr = NotNull;
5660     // Now we find the LCA of Java classes
5661     ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
5662     return   make(ptr, k, off, k-&gt;is_valuetype() &amp;&amp; k-&gt;flatten_array());
5663   } // End of case KlassPtr
5664 
5665   } // End of switch
5666   return this;                  // Return the double constant
5667 }
5668 
5669 //------------------------------xdual------------------------------------------
5670 // Dual: compute field-by-field dual
5671 const Type    *TypeKlassPtr::xdual() const {
5672   return new TypeKlassPtr(dual_ptr(), klass(), dual_offset(), flat_array());
5673 }
5674 
5675 //------------------------------get_con----------------------------------------
5676 intptr_t TypeKlassPtr::get_con() const {
5677   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
5678   assert(offset() &gt;= 0, &quot;&quot;);
5679 
5680   if (offset() != 0) {
5681     // After being ported to the compiler interface, the compiler no longer
5682     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5683     // to a handle at compile time.  This handle is embedded in the generated
5684     // code and dereferenced at the time the nmethod is made.  Until that time,
5685     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5686     // have access to the addresses!).  This does not seem to currently happen,
5687     // but this assertion here is to help prevent its occurence.
5688     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5689     ShouldNotReachHere();
5690   }
5691 
5692   return (intptr_t)klass()-&gt;constant_encoding();
5693 }
5694 //------------------------------dump2------------------------------------------
5695 // Dump Klass Type
5696 #ifndef PRODUCT
5697 void TypeKlassPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5698   switch( _ptr ) {
5699   case Constant:
5700     st-&gt;print(&quot;precise &quot;);
5701   case NotNull:
5702     {
5703       if (klass() != NULL) {
5704         const char* name = klass()-&gt;name()-&gt;as_utf8();
5705         st-&gt;print(&quot;klass %s: &quot; INTPTR_FORMAT, name, p2i(klass()));
5706       } else {
5707         st-&gt;print(&quot;klass BOTTOM&quot;);
5708       }
5709     }
5710   case BotPTR:
5711     if( !WizardMode &amp;&amp; !Verbose &amp;&amp; !_klass_is_exact ) break;
5712   case TopPTR:
5713   case AnyNull:
5714     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
5715     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
5716     break;
5717   default:
5718     break;
5719   }
5720 
5721   _offset.dump2(st);
5722 
5723   st-&gt;print(&quot; *&quot;);
5724 }
5725 #endif
5726 
5727 
5728 
5729 //=============================================================================
5730 // Convenience common pre-built types.
5731 
5732 //------------------------------make-------------------------------------------
5733 const TypeFunc *TypeFunc::make(const TypeTuple *domain_sig, const TypeTuple* domain_cc,
5734                                const TypeTuple *range_sig, const TypeTuple *range_cc) {
5735   return (TypeFunc*)(new TypeFunc(domain_sig, domain_cc, range_sig, range_cc))-&gt;hashcons();
5736 }
5737 
5738 const TypeFunc *TypeFunc::make(const TypeTuple *domain, const TypeTuple *range) {
5739   return make(domain, domain, range, range);
5740 }
5741 
5742 //------------------------------osr_domain-----------------------------
5743 const TypeTuple* osr_domain() {
5744   const Type **fields = TypeTuple::fields(2);
5745   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM;  // address of osr buffer
5746   return TypeTuple::make(TypeFunc::Parms+1, fields);
5747 }
5748 
5749 //------------------------------make-------------------------------------------
5750 const TypeFunc* TypeFunc::make(ciMethod* method, bool is_osr_compilation) {
5751   Compile* C = Compile::current();
5752   const TypeFunc* tf = NULL;
5753   if (!is_osr_compilation) {
5754     tf = C-&gt;last_tf(method); // check cache
5755     if (tf != NULL)  return tf;  // The hit rate here is almost 50%.
5756   }
5757   // Value types are not passed/returned by reference, instead each field of
5758   // the value type is passed/returned as an argument. We maintain two views of
5759   // the argument/return list here: one based on the signature (with a value
5760   // type argument/return as a single slot), one based on the actual calling
5761   // convention (with a value type argument/return as a list of its fields).
5762   bool has_scalar_args = method-&gt;has_scalarized_args() &amp;&amp; !is_osr_compilation;
5763   const TypeTuple* domain_sig = is_osr_compilation ? osr_domain() : TypeTuple::make_domain(method, false);
5764   const TypeTuple* domain_cc = has_scalar_args ? TypeTuple::make_domain(method, true) : domain_sig;
5765   ciSignature* sig = method-&gt;signature();
5766   bool has_scalar_ret = sig-&gt;returns_never_null() &amp;&amp; sig-&gt;return_type()-&gt;as_value_klass()-&gt;can_be_returned_as_fields();
5767   const TypeTuple* range_sig = TypeTuple::make_range(sig, false);
5768   const TypeTuple* range_cc = has_scalar_ret ? TypeTuple::make_range(sig, true) : range_sig;
5769   tf = TypeFunc::make(domain_sig, domain_cc, range_sig, range_cc);
5770   if (!is_osr_compilation) {
5771     C-&gt;set_last_tf(method, tf);  // fill cache
5772   }
5773   return tf;
5774 }
5775 
5776 //------------------------------meet-------------------------------------------
5777 // Compute the MEET of two types.  It returns a new Type object.
5778 const Type *TypeFunc::xmeet( const Type *t ) const {
5779   // Perform a fast test for common case; meeting the same types together.
5780   if( this == t ) return this;  // Meeting same type-rep?
5781 
5782   // Current &quot;this-&gt;_base&quot; is Func
5783   switch (t-&gt;base()) {          // switch on original type
5784 
5785   case Bottom:                  // Ye Olde Default
5786     return t;
5787 
5788   default:                      // All else is a mistake
5789     typerr(t);
5790 
5791   case Top:
5792     break;
5793   }
5794   return this;                  // Return the double constant
5795 }
5796 
5797 //------------------------------xdual------------------------------------------
5798 // Dual: compute field-by-field dual
5799 const Type *TypeFunc::xdual() const {
5800   return this;
5801 }
5802 
5803 //------------------------------eq---------------------------------------------
5804 // Structural equality check for Type representations
5805 bool TypeFunc::eq( const Type *t ) const {
5806   const TypeFunc *a = (const TypeFunc*)t;
5807   return _domain_sig == a-&gt;_domain_sig &amp;&amp;
5808     _domain_cc == a-&gt;_domain_cc &amp;&amp;
5809     _range_sig == a-&gt;_range_sig &amp;&amp;
5810     _range_cc == a-&gt;_range_cc;
5811 }
5812 
5813 //------------------------------hash-------------------------------------------
5814 // Type-specific hashing function.
5815 int TypeFunc::hash(void) const {
5816   return (intptr_t)_domain_sig + (intptr_t)_domain_cc + (intptr_t)_range_sig + (intptr_t)_range_cc;
5817 }
5818 
5819 //------------------------------dump2------------------------------------------
5820 // Dump Function Type
5821 #ifndef PRODUCT
5822 void TypeFunc::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
5823   if( _range_sig-&gt;cnt() &lt;= Parms )
5824     st-&gt;print(&quot;void&quot;);
5825   else {
5826     uint i;
5827     for (i = Parms; i &lt; _range_sig-&gt;cnt()-1; i++) {
5828       _range_sig-&gt;field_at(i)-&gt;dump2(d,depth,st);
5829       st-&gt;print(&quot;/&quot;);
5830     }
5831     _range_sig-&gt;field_at(i)-&gt;dump2(d,depth,st);
5832   }
5833   st-&gt;print(&quot; &quot;);
5834   st-&gt;print(&quot;( &quot;);
5835   if( !depth || d[this] ) {     // Check for recursive dump
5836     st-&gt;print(&quot;...)&quot;);
5837     return;
5838   }
5839   d.Insert((void*)this,(void*)this);    // Stop recursion
5840   if (Parms &lt; _domain_sig-&gt;cnt())
5841     _domain_sig-&gt;field_at(Parms)-&gt;dump2(d,depth-1,st);
5842   for (uint i = Parms+1; i &lt; _domain_sig-&gt;cnt(); i++) {
5843     st-&gt;print(&quot;, &quot;);
5844     _domain_sig-&gt;field_at(i)-&gt;dump2(d,depth-1,st);
5845   }
5846   st-&gt;print(&quot; )&quot;);
5847 }
5848 #endif
5849 
5850 //------------------------------singleton--------------------------------------
5851 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5852 // constants (Ldi nodes).  Singletons are integer, float or double constants
5853 // or a single symbol.
5854 bool TypeFunc::singleton(void) const {
5855   return false;                 // Never a singleton
5856 }
5857 
5858 bool TypeFunc::empty(void) const {
5859   return false;                 // Never empty
5860 }
5861 
5862 
5863 BasicType TypeFunc::return_type() const{
5864   if (range_sig()-&gt;cnt() == TypeFunc::Parms) {
5865     return T_VOID;
5866   }
5867   return range_sig()-&gt;field_at(TypeFunc::Parms)-&gt;basic_type();
5868 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/loopnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="machnode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopnode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 769       assert( lca-&gt;is_CFG(), &quot;&quot; );
 770       // find LCA of all uses
 771       n = dom_lca_for_get_late_ctrl_internal( lca, n, tag );
 772     }
 773     return find_non_split_ctrl(n);
 774   }
 775   Node *dom_lca_for_get_late_ctrl_internal( Node *lca, Node *n, Node *tag );
 776 
 777   // Helper function for directing control inputs away from CFG split points.
 778   Node *find_non_split_ctrl( Node *ctrl ) const {
 779     if (ctrl != NULL) {
 780       if (ctrl-&gt;is_MultiBranch()) {
 781         ctrl = ctrl-&gt;in(0);
 782       }
 783       assert(ctrl-&gt;is_CFG(), &quot;CFG&quot;);
 784     }
 785     return ctrl;
 786   }
 787 
 788   Node* cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop);
<span class="line-modified"> 789   void duplicate_predicates_helper(Node* predicate, Node* start, Node* end, IdealLoopTree* outer_loop,</span>
<span class="line-modified"> 790                                    LoopNode* outer_main_head, uint dd_main_head);</span>
<span class="line-modified"> 791   void duplicate_predicates(CountedLoopNode* pre_head, Node* start, Node* end, IdealLoopTree* outer_loop,</span>
<span class="line-modified"> 792                             LoopNode* outer_main_head, uint dd_main_head);</span>






 793   Node* clone_skeleton_predicate(Node* iff, Node* value, Node* predicate, Node* uncommon_proj,
<span class="line-modified"> 794                                   Node* current_proj, IdealLoopTree* outer_loop, Node* prev_proj);</span>
 795   bool skeleton_predicate_has_opaque(IfNode* iff);
<span class="line-modified"> 796   void update_skeleton_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init, int stride_con);</span>
 797   void insert_loop_limit_check(ProjNode* limit_check_proj, Node* cmp_limit, Node* bol);
 798 
 799 public:
 800 
 801   PhaseIterGVN &amp;igvn() const { return _igvn; }
 802 
 803   static bool is_canonical_loop_entry(CountedLoopNode* cl);
 804 
 805   bool has_node( Node* n ) const {
 806     guarantee(n != NULL, &quot;No Node.&quot;);
 807     return _nodes[n-&gt;_idx] != NULL;
 808   }
 809   // check if transform created new nodes that need _ctrl recorded
 810   Node *get_late_ctrl( Node *n, Node *early );
 811   Node *get_early_ctrl( Node *n );
 812   Node *get_early_ctrl_for_expensive(Node *n, Node* earliest);
 813   void set_early_ctrl( Node *n );
 814   void set_subtree_ctrl( Node *root );
 815   void set_ctrl( Node *n, Node *ctrl ) {
 816     assert( !has_node(n) || has_ctrl(n), &quot;&quot; );
</pre>
<hr />
<pre>
1113 
1114   // Take steps to maximally unroll the loop.  Peel any odd iterations, then
1115   // unroll to do double iterations.  The next round of major loop transforms
1116   // will repeat till the doubled loop body does all remaining iterations in 1
1117   // pass.
1118   void do_maximally_unroll( IdealLoopTree *loop, Node_List &amp;old_new );
1119 
1120   // Unroll the loop body one step - make each trip do 2 iterations.
1121   void do_unroll( IdealLoopTree *loop, Node_List &amp;old_new, bool adjust_min_trip );
1122 
1123   // Mark vector reduction candidates before loop unrolling
1124   void mark_reductions( IdealLoopTree *loop );
1125 
1126   // Return true if exp is a constant times an induction var
1127   bool is_scaled_iv(Node* exp, Node* iv, int* p_scale);
1128 
1129   // Return true if exp is a scaled induction var plus (or minus) constant
1130   bool is_scaled_iv_plus_offset(Node* exp, Node* iv, int* p_scale, Node** p_offset, int depth = 0);
1131 
1132   // Create a new if above the uncommon_trap_if_pattern for the predicate to be promoted
<span class="line-modified">1133   ProjNode* create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry,</span>
<span class="line-modified">1134                                         Deoptimization::DeoptReason reason,</span>
<span class="line-removed">1135                                         int opcode);</span>
<span class="line-removed">1136   void register_control(Node* n, IdealLoopTree *loop, Node* pred);</span>
1137 
<span class="line-modified">1138   // Clone loop predicates to cloned loops (peeled, unswitched)</span>
<span class="line-removed">1139   static ProjNode* clone_predicate(ProjNode* predicate_proj, Node* new_entry,</span>
<span class="line-removed">1140                                    Deoptimization::DeoptReason reason,</span>
<span class="line-removed">1141                                    PhaseIdealLoop* loop_phase,</span>
<span class="line-removed">1142                                    PhaseIterGVN* igvn);</span>
<span class="line-removed">1143 </span>
<span class="line-removed">1144   static Node* clone_loop_predicates(Node* old_entry, Node* new_entry,</span>
<span class="line-removed">1145                                          bool clone_limit_check,</span>
<span class="line-removed">1146                                          PhaseIdealLoop* loop_phase,</span>
<span class="line-removed">1147                                          PhaseIterGVN* igvn);</span>
<span class="line-removed">1148   Node* clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check);</span>
1149 
1150   static Node* skip_all_loop_predicates(Node* entry);
1151   static Node* skip_loop_predicates(Node* entry);
1152 
1153   // Find a good location to insert a predicate
1154   static ProjNode* find_predicate_insertion_point(Node* start_c, Deoptimization::DeoptReason reason);
1155   // Find a predicate
1156   static Node* find_predicate(Node* entry);
1157   // Construct a range check for a predicate if
1158   BoolNode* rc_predicate(IdealLoopTree *loop, Node* ctrl,
1159                          int scale, Node* offset,
1160                          Node* init, Node* limit, jint stride,
1161                          Node* range, bool upper, bool &amp;overflow);
1162 
1163   // Implementation of the loop predication to promote checks outside the loop
1164   bool loop_predication_impl(IdealLoopTree *loop);
1165   bool loop_predication_impl_helper(IdealLoopTree *loop, ProjNode* proj, ProjNode *predicate_proj,
1166                                     CountedLoopNode *cl, ConNode* zero, Invariance&amp; invar,
1167                                     Deoptimization::DeoptReason reason);
1168   bool loop_predication_should_follow_branches(IdealLoopTree *loop, ProjNode *predicate_proj, float&amp; loop_trip_cnt);
1169   void loop_predication_follow_branches(Node *c, IdealLoopTree *loop, float loop_trip_cnt,
1170                                         PathFrequency&amp; pf, Node_Stack&amp; stack, VectorSet&amp; seen,
1171                                         Node_List&amp; if_proj_list);
<span class="line-modified">1172   ProjNode* insert_skeleton_predicate(IfNode* iff, IdealLoopTree *loop,</span>
<span class="line-modified">1173                                       ProjNode* proj, ProjNode *predicate_proj,</span>
<span class="line-modified">1174                                       ProjNode* upper_bound_proj,</span>
<span class="line-modified">1175                                       int scale, Node* offset,</span>
<span class="line-modified">1176                                       Node* init, Node* limit, jint stride,</span>
<span class="line-modified">1177                                       Node* rng, bool&amp; overflow,</span>
<span class="line-modified">1178                                       Deoptimization::DeoptReason reason);</span>
1179   Node* add_range_check_predicate(IdealLoopTree* loop, CountedLoopNode* cl,
1180                                   Node* predicate_proj, int scale_con, Node* offset,
1181                                   Node* limit, jint stride_con, Node* value);
1182 
1183   // Helper function to collect predicate for eliminating the useless ones
1184   void collect_potentially_useful_predicates(IdealLoopTree *loop, Unique_Node_List &amp;predicate_opaque1);
1185   void eliminate_useless_predicates();
1186 
1187   // Change the control input of expensive nodes to allow commoning by
1188   // IGVN when it is guaranteed to not result in a more frequent
1189   // execution of the expensive node. Return true if progress.
1190   bool process_expensive_nodes();
1191 
1192   // Check whether node has become unreachable
1193   bool is_node_unreachable(Node *n) const {
1194     return !has_node(n) || n-&gt;is_unreachable(_igvn);
1195   }
1196 
1197   // Eliminate range-checks and other trip-counter vs loop-invariant tests.
1198   int do_range_check( IdealLoopTree *loop, Node_List &amp;old_new );
</pre>
<hr />
<pre>
1408   void require_nodes_final(uint live_at_begin, bool check_estimate) {
1409     assert(_nodes_required &lt; UINT_MAX, &quot;Bad state (final).&quot;);
1410 
1411     if (check_estimate) {
1412       // Assert that the node budget request was not off by too much (x2).
1413       // Should this be the case we _surely_ need to improve the estimates
1414       // used in our budget calculations.
1415       assert(C-&gt;live_nodes() - live_at_begin &lt;= 2 * _nodes_required,
1416              &quot;Bad node estimate: actual = %d &gt;&gt; request = %d&quot;,
1417              C-&gt;live_nodes() - live_at_begin, _nodes_required);
1418     }
1419     // Assert that we have stayed within the node budget limit.
1420     assert(C-&gt;live_nodes() &lt; C-&gt;max_node_limit(),
1421            &quot;Exceeding node budget limit: %d + %d &gt; %d (request = %d)&quot;,
1422            C-&gt;live_nodes() - live_at_begin, live_at_begin,
1423            C-&gt;max_node_limit(), _nodes_required);
1424 
1425     _nodes_required = UINT_MAX;
1426   }
1427 









1428   bool _created_loop_node;
1429 
1430 public:
1431   void set_created_loop_node() { _created_loop_node = true; }
1432   bool created_loop_node()     { return _created_loop_node; }
1433   void register_new_node(Node* n, Node* blk);
1434 
1435 #ifdef ASSERT
1436   void dump_bad_graph(const char* msg, Node* n, Node* early, Node* LCA);
1437 #endif
1438 
1439 #ifndef PRODUCT
1440   void dump() const;
1441   void dump(IdealLoopTree* loop, uint rpo_idx, Node_List &amp;rpo_list) const;
1442   void verify() const;          // Major slow  :-)
1443   void verify_compare(Node* n, const PhaseIdealLoop* loop_verify, VectorSet &amp;visited) const;
1444   IdealLoopTree* get_loop_idx(Node* n) const {
1445     // Dead nodes have no loop, so return the top level loop instead
1446     return _nodes[n-&gt;_idx] ? (IdealLoopTree*)_nodes[n-&gt;_idx] : _ltree_root;
1447   }
</pre>
</td>
<td>
<hr />
<pre>
 769       assert( lca-&gt;is_CFG(), &quot;&quot; );
 770       // find LCA of all uses
 771       n = dom_lca_for_get_late_ctrl_internal( lca, n, tag );
 772     }
 773     return find_non_split_ctrl(n);
 774   }
 775   Node *dom_lca_for_get_late_ctrl_internal( Node *lca, Node *n, Node *tag );
 776 
 777   // Helper function for directing control inputs away from CFG split points.
 778   Node *find_non_split_ctrl( Node *ctrl ) const {
 779     if (ctrl != NULL) {
 780       if (ctrl-&gt;is_MultiBranch()) {
 781         ctrl = ctrl-&gt;in(0);
 782       }
 783       assert(ctrl-&gt;is_CFG(), &quot;CFG&quot;);
 784     }
 785     return ctrl;
 786   }
 787 
 788   Node* cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop);
<span class="line-modified"> 789 </span>
<span class="line-modified"> 790 #ifdef ASSERT</span>
<span class="line-modified"> 791   void ensure_zero_trip_guard_proj(Node* node, bool is_main_loop);</span>
<span class="line-modified"> 792 #endif</span>
<span class="line-added"> 793   void copy_skeleton_predicates_to_main_loop_helper(Node* predicate, Node* start, Node* end, IdealLoopTree* outer_loop, LoopNode* outer_main_head,</span>
<span class="line-added"> 794                                                     uint dd_main_head, const uint idx_before_pre_post, const uint idx_after_post_before_pre,</span>
<span class="line-added"> 795                                                     Node* zero_trip_guard_proj_main, Node* zero_trip_guard_proj_post, const Node_List &amp;old_new);</span>
<span class="line-added"> 796   void copy_skeleton_predicates_to_main_loop(CountedLoopNode* pre_head, Node* start, Node* end, IdealLoopTree* outer_loop, LoopNode* outer_main_head,</span>
<span class="line-added"> 797                                              uint dd_main_head, const uint idx_before_pre_post, const uint idx_after_post_before_pre,</span>
<span class="line-added"> 798                                              Node* zero_trip_guard_proj_main, Node* zero_trip_guard_proj_post, const Node_List &amp;old_new);</span>
 799   Node* clone_skeleton_predicate(Node* iff, Node* value, Node* predicate, Node* uncommon_proj,
<span class="line-modified"> 800                                  Node* current_proj, IdealLoopTree* outer_loop, Node* prev_proj);</span>
 801   bool skeleton_predicate_has_opaque(IfNode* iff);
<span class="line-modified"> 802   void update_main_loop_skeleton_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init, int stride_con);</span>
 803   void insert_loop_limit_check(ProjNode* limit_check_proj, Node* cmp_limit, Node* bol);
 804 
 805 public:
 806 
 807   PhaseIterGVN &amp;igvn() const { return _igvn; }
 808 
 809   static bool is_canonical_loop_entry(CountedLoopNode* cl);
 810 
 811   bool has_node( Node* n ) const {
 812     guarantee(n != NULL, &quot;No Node.&quot;);
 813     return _nodes[n-&gt;_idx] != NULL;
 814   }
 815   // check if transform created new nodes that need _ctrl recorded
 816   Node *get_late_ctrl( Node *n, Node *early );
 817   Node *get_early_ctrl( Node *n );
 818   Node *get_early_ctrl_for_expensive(Node *n, Node* earliest);
 819   void set_early_ctrl( Node *n );
 820   void set_subtree_ctrl( Node *root );
 821   void set_ctrl( Node *n, Node *ctrl ) {
 822     assert( !has_node(n) || has_ctrl(n), &quot;&quot; );
</pre>
<hr />
<pre>
1119 
1120   // Take steps to maximally unroll the loop.  Peel any odd iterations, then
1121   // unroll to do double iterations.  The next round of major loop transforms
1122   // will repeat till the doubled loop body does all remaining iterations in 1
1123   // pass.
1124   void do_maximally_unroll( IdealLoopTree *loop, Node_List &amp;old_new );
1125 
1126   // Unroll the loop body one step - make each trip do 2 iterations.
1127   void do_unroll( IdealLoopTree *loop, Node_List &amp;old_new, bool adjust_min_trip );
1128 
1129   // Mark vector reduction candidates before loop unrolling
1130   void mark_reductions( IdealLoopTree *loop );
1131 
1132   // Return true if exp is a constant times an induction var
1133   bool is_scaled_iv(Node* exp, Node* iv, int* p_scale);
1134 
1135   // Return true if exp is a scaled induction var plus (or minus) constant
1136   bool is_scaled_iv_plus_offset(Node* exp, Node* iv, int* p_scale, Node** p_offset, int depth = 0);
1137 
1138   // Create a new if above the uncommon_trap_if_pattern for the predicate to be promoted
<span class="line-modified">1139   ProjNode* create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry, Deoptimization::DeoptReason reason,</span>
<span class="line-modified">1140                                         int opcode, bool if_cont_is_true_proj = true);</span>


1141 
<span class="line-modified">1142   void register_control(Node* n, IdealLoopTree *loop, Node* pred);</span>










1143 
1144   static Node* skip_all_loop_predicates(Node* entry);
1145   static Node* skip_loop_predicates(Node* entry);
1146 
1147   // Find a good location to insert a predicate
1148   static ProjNode* find_predicate_insertion_point(Node* start_c, Deoptimization::DeoptReason reason);
1149   // Find a predicate
1150   static Node* find_predicate(Node* entry);
1151   // Construct a range check for a predicate if
1152   BoolNode* rc_predicate(IdealLoopTree *loop, Node* ctrl,
1153                          int scale, Node* offset,
1154                          Node* init, Node* limit, jint stride,
1155                          Node* range, bool upper, bool &amp;overflow);
1156 
1157   // Implementation of the loop predication to promote checks outside the loop
1158   bool loop_predication_impl(IdealLoopTree *loop);
1159   bool loop_predication_impl_helper(IdealLoopTree *loop, ProjNode* proj, ProjNode *predicate_proj,
1160                                     CountedLoopNode *cl, ConNode* zero, Invariance&amp; invar,
1161                                     Deoptimization::DeoptReason reason);
1162   bool loop_predication_should_follow_branches(IdealLoopTree *loop, ProjNode *predicate_proj, float&amp; loop_trip_cnt);
1163   void loop_predication_follow_branches(Node *c, IdealLoopTree *loop, float loop_trip_cnt,
1164                                         PathFrequency&amp; pf, Node_Stack&amp; stack, VectorSet&amp; seen,
1165                                         Node_List&amp; if_proj_list);
<span class="line-modified">1166   ProjNode* insert_initial_skeleton_predicate(IfNode* iff, IdealLoopTree *loop,</span>
<span class="line-modified">1167                                               ProjNode* proj, ProjNode *predicate_proj,</span>
<span class="line-modified">1168                                               ProjNode* upper_bound_proj,</span>
<span class="line-modified">1169                                               int scale, Node* offset,</span>
<span class="line-modified">1170                                               Node* init, Node* limit, jint stride,</span>
<span class="line-modified">1171                                               Node* rng, bool&amp; overflow,</span>
<span class="line-modified">1172                                               Deoptimization::DeoptReason reason);</span>
1173   Node* add_range_check_predicate(IdealLoopTree* loop, CountedLoopNode* cl,
1174                                   Node* predicate_proj, int scale_con, Node* offset,
1175                                   Node* limit, jint stride_con, Node* value);
1176 
1177   // Helper function to collect predicate for eliminating the useless ones
1178   void collect_potentially_useful_predicates(IdealLoopTree *loop, Unique_Node_List &amp;predicate_opaque1);
1179   void eliminate_useless_predicates();
1180 
1181   // Change the control input of expensive nodes to allow commoning by
1182   // IGVN when it is guaranteed to not result in a more frequent
1183   // execution of the expensive node. Return true if progress.
1184   bool process_expensive_nodes();
1185 
1186   // Check whether node has become unreachable
1187   bool is_node_unreachable(Node *n) const {
1188     return !has_node(n) || n-&gt;is_unreachable(_igvn);
1189   }
1190 
1191   // Eliminate range-checks and other trip-counter vs loop-invariant tests.
1192   int do_range_check( IdealLoopTree *loop, Node_List &amp;old_new );
</pre>
<hr />
<pre>
1402   void require_nodes_final(uint live_at_begin, bool check_estimate) {
1403     assert(_nodes_required &lt; UINT_MAX, &quot;Bad state (final).&quot;);
1404 
1405     if (check_estimate) {
1406       // Assert that the node budget request was not off by too much (x2).
1407       // Should this be the case we _surely_ need to improve the estimates
1408       // used in our budget calculations.
1409       assert(C-&gt;live_nodes() - live_at_begin &lt;= 2 * _nodes_required,
1410              &quot;Bad node estimate: actual = %d &gt;&gt; request = %d&quot;,
1411              C-&gt;live_nodes() - live_at_begin, _nodes_required);
1412     }
1413     // Assert that we have stayed within the node budget limit.
1414     assert(C-&gt;live_nodes() &lt; C-&gt;max_node_limit(),
1415            &quot;Exceeding node budget limit: %d + %d &gt; %d (request = %d)&quot;,
1416            C-&gt;live_nodes() - live_at_begin, live_at_begin,
1417            C-&gt;max_node_limit(), _nodes_required);
1418 
1419     _nodes_required = UINT_MAX;
1420   }
1421 
<span class="line-added">1422   // Clone loop predicates to slow and fast loop when unswitching a loop</span>
<span class="line-added">1423   Node* clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check, bool is_slow_loop,</span>
<span class="line-added">1424                               uint idx_before_clone, Node_List &amp;old_new);</span>
<span class="line-added">1425   ProjNode* clone_loop_predicate(ProjNode* predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason,</span>
<span class="line-added">1426                                  bool is_slow_loop, uint idx_before_clone, Node_List &amp;old_new);</span>
<span class="line-added">1427   void clone_concrete_loop_predicates(Deoptimization::DeoptReason reason, ProjNode* old_predicate_proj,</span>
<span class="line-added">1428                                       ProjNode* new_predicate_proj, bool is_slow_loop,</span>
<span class="line-added">1429                                       uint idx_before_clone, Node_List &amp;old_new);</span>
<span class="line-added">1430 </span>
1431   bool _created_loop_node;
1432 
1433 public:
1434   void set_created_loop_node() { _created_loop_node = true; }
1435   bool created_loop_node()     { return _created_loop_node; }
1436   void register_new_node(Node* n, Node* blk);
1437 
1438 #ifdef ASSERT
1439   void dump_bad_graph(const char* msg, Node* n, Node* early, Node* LCA);
1440 #endif
1441 
1442 #ifndef PRODUCT
1443   void dump() const;
1444   void dump(IdealLoopTree* loop, uint rpo_idx, Node_List &amp;rpo_list) const;
1445   void verify() const;          // Major slow  :-)
1446   void verify_compare(Node* n, const PhaseIdealLoop* loop_verify, VectorSet &amp;visited) const;
1447   IdealLoopTree* get_loop_idx(Node* n) const {
1448     // Dead nodes have no loop, so return the top level loop instead
1449     return _nodes[n-&gt;_idx] ? (IdealLoopTree*)_nodes[n-&gt;_idx] : _ltree_root;
1450   }
</pre>
</td>
</tr>
</table>
<center><a href="loopnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="machnode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
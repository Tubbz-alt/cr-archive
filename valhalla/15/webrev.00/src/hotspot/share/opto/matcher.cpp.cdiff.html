<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/matcher.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macro.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="matcher.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/matcher.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1419,11 ***</span>
    State *s = new (&amp;_states_arena) State;
    s-&gt;_kids[0] = NULL;
    s-&gt;_kids[1] = NULL;
    s-&gt;_leaf = (Node*)n;
    // Label the input tree, allocating labels from top-level arena
<span class="line-modified">!   Label_Root( n, s, n-&gt;in(0), mem );</span>
    if (C-&gt;failing())  return NULL;
  
    // The minimum cost match for the whole tree is found at the root State
    uint mincost = max_juint;
    uint cost = max_juint;
<span class="line-new-header">--- 1419,12 ---</span>
    State *s = new (&amp;_states_arena) State;
    s-&gt;_kids[0] = NULL;
    s-&gt;_kids[1] = NULL;
    s-&gt;_leaf = (Node*)n;
    // Label the input tree, allocating labels from top-level arena
<span class="line-modified">!   Node* root_mem = mem;</span>
<span class="line-added">+   Label_Root(n, s, n-&gt;in(0), root_mem);</span>
    if (C-&gt;failing())  return NULL;
  
    // The minimum cost match for the whole tree is found at the root State
    uint mincost = max_juint;
    uint cost = max_juint;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1533,12 ***</span>
  
  // The Matcher works on Trees, but an Intel add-to-memory requires a DAG: the
  // Store and the Load must have identical Memories (as well as identical
  // pointers).  Since the Matcher does not have anything for Memory (and
  // does not handle DAGs), I have to match the Memory input myself.  If the
<span class="line-modified">! // Tree root is a Store, I require all Loads to have the identical memory.</span>
<span class="line-modified">! Node *Matcher::Label_Root( const Node *n, State *svec, Node *control, const Node *mem){</span>
    // Since Label_Root is a recursive function, its possible that we might run
    // out of stack space.  See bugs 6272980 &amp; 6227033 for more info.
    LabelRootDepth++;
    if (LabelRootDepth &gt; MaxLabelRootDepth) {
      C-&gt;record_method_not_compilable(&quot;Out of stack space, increase MaxLabelRootDepth&quot;);
<span class="line-new-header">--- 1534,13 ---</span>
  
  // The Matcher works on Trees, but an Intel add-to-memory requires a DAG: the
  // Store and the Load must have identical Memories (as well as identical
  // pointers).  Since the Matcher does not have anything for Memory (and
  // does not handle DAGs), I have to match the Memory input myself.  If the
<span class="line-modified">! // Tree root is a Store or if there are multiple Loads in the tree, I require</span>
<span class="line-modified">! // all Loads to have the identical memory.</span>
<span class="line-added">+ Node* Matcher::Label_Root(const Node* n, State* svec, Node* control, Node*&amp; mem) {</span>
    // Since Label_Root is a recursive function, its possible that we might run
    // out of stack space.  See bugs 6272980 &amp; 6227033 for more info.
    LabelRootDepth++;
    if (LabelRootDepth &gt; MaxLabelRootDepth) {
      C-&gt;record_method_not_compilable(&quot;Out of stack space, increase MaxLabelRootDepth&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1558,10 ***</span>
<span class="line-new-header">--- 1560,15 ---</span>
      Node *m = n-&gt;in(i);         // Get ith input
      assert( m, &quot;expect non-null children&quot; );
      if( m-&gt;is_Load() ) {
        if( input_mem == NULL ) {
          input_mem = m-&gt;in(MemNode::Memory);
<span class="line-added">+         if (mem == (Node*)1) {</span>
<span class="line-added">+           // Save this memory to bail out if there&#39;s another memory access</span>
<span class="line-added">+           // to a different memory location in the same tree.</span>
<span class="line-added">+           mem = input_mem;</span>
<span class="line-added">+         }</span>
        } else if( input_mem != m-&gt;in(MemNode::Memory) ) {
          input_mem = NodeSentinel;
        }
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1581,20 ***</span>
  
      // Check for leaves of the State Tree; things that cannot be a part of
      // the current tree.  If it finds any, that value is matched as a
      // register operand.  If not, then the normal matching is used.
      if( match_into_reg(n, m, control, i, is_shared(m)) ||
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Stop recursion if this is LoadNode and the root of this tree is a</span>
<span class="line-modified">!         // StoreNode and the load &amp; store have different memories.</span>
          ((mem!=(Node*)1) &amp;&amp; m-&gt;is_Load() &amp;&amp; m-&gt;in(MemNode::Memory) != mem) ||
          // Can NOT include the match of a subtree when its memory state
          // is used by any of the other subtrees
          (input_mem == NodeSentinel) ) {
        // Print when we exclude matching due to different memory states at input-loads
        if (PrintOpto &amp;&amp; (Verbose &amp;&amp; WizardMode) &amp;&amp; (input_mem == NodeSentinel)
<span class="line-modified">!         &amp;&amp; !((mem!=(Node*)1) &amp;&amp; m-&gt;is_Load() &amp;&amp; m-&gt;in(MemNode::Memory) != mem)) {</span>
          tty-&gt;print_cr(&quot;invalid input_mem&quot;);
        }
        // Switch to a register-only opcode; this value must be in a register
        // and cannot be subsumed as part of a larger instruction.
        s-&gt;DFA( m-&gt;ideal_reg(), m );
<span class="line-new-header">--- 1588,20 ---</span>
  
      // Check for leaves of the State Tree; things that cannot be a part of
      // the current tree.  If it finds any, that value is matched as a
      // register operand.  If not, then the normal matching is used.
      if( match_into_reg(n, m, control, i, is_shared(m)) ||
<span class="line-modified">!         // Stop recursion if this is a LoadNode and there is another memory access</span>
<span class="line-modified">!         // to a different memory location in the same tree (for example, a StoreNode</span>
<span class="line-modified">!         // at the root of this tree or another LoadNode in one of the children).</span>
          ((mem!=(Node*)1) &amp;&amp; m-&gt;is_Load() &amp;&amp; m-&gt;in(MemNode::Memory) != mem) ||
          // Can NOT include the match of a subtree when its memory state
          // is used by any of the other subtrees
          (input_mem == NodeSentinel) ) {
        // Print when we exclude matching due to different memory states at input-loads
        if (PrintOpto &amp;&amp; (Verbose &amp;&amp; WizardMode) &amp;&amp; (input_mem == NodeSentinel)
<span class="line-modified">!           &amp;&amp; !((mem!=(Node*)1) &amp;&amp; m-&gt;is_Load() &amp;&amp; m-&gt;in(MemNode::Memory) != mem)) {</span>
          tty-&gt;print_cr(&quot;invalid input_mem&quot;);
        }
        // Switch to a register-only opcode; this value must be in a register
        // and cannot be subsumed as part of a larger instruction.
        s-&gt;DFA( m-&gt;ideal_reg(), m );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1602,11 ***</span>
      } else {
        // If match tree has no control and we do, adopt it for entire tree
        if( control == NULL &amp;&amp; m-&gt;in(0) != NULL &amp;&amp; m-&gt;req() &gt; 1 )
          control = m-&gt;in(0);         // Pick up control
        // Else match as a normal part of the match tree.
<span class="line-modified">!       control = Label_Root(m,s,control,mem);</span>
        if (C-&gt;failing()) return NULL;
      }
    }
  
  
<span class="line-new-header">--- 1609,11 ---</span>
      } else {
        // If match tree has no control and we do, adopt it for entire tree
        if( control == NULL &amp;&amp; m-&gt;in(0) != NULL &amp;&amp; m-&gt;req() &gt; 1 )
          control = m-&gt;in(0);         // Pick up control
        // Else match as a normal part of the match tree.
<span class="line-modified">!       control = Label_Root(m, s, control, mem);</span>
        if (C-&gt;failing()) return NULL;
      }
    }
  
  
</pre>
<center><a href="macro.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="matcher.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
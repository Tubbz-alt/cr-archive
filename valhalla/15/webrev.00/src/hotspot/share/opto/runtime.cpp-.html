<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/runtime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/systemDictionary.hpp&quot;
  27 #include &quot;classfile/vmSymbols.hpp&quot;
  28 #include &quot;code/codeCache.hpp&quot;
  29 #include &quot;code/compiledMethod.inline.hpp&quot;
  30 #include &quot;code/compiledIC.hpp&quot;
  31 #include &quot;code/icBuffer.hpp&quot;
  32 #include &quot;code/nmethod.hpp&quot;
  33 #include &quot;code/pcDesc.hpp&quot;
  34 #include &quot;code/scopeDesc.hpp&quot;
  35 #include &quot;code/vtableStubs.hpp&quot;
  36 #include &quot;compiler/compileBroker.hpp&quot;
  37 #include &quot;compiler/oopMap.hpp&quot;
  38 #include &quot;gc/g1/heapRegion.hpp&quot;
  39 #include &quot;gc/shared/barrierSet.hpp&quot;
  40 #include &quot;gc/shared/collectedHeap.hpp&quot;
  41 #include &quot;gc/shared/gcLocker.hpp&quot;
  42 #include &quot;interpreter/bytecode.hpp&quot;
  43 #include &quot;interpreter/interpreter.hpp&quot;
  44 #include &quot;interpreter/linkResolver.hpp&quot;
  45 #include &quot;logging/log.hpp&quot;
  46 #include &quot;logging/logStream.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;oops/objArrayKlass.hpp&quot;
  50 #include &quot;oops/oop.inline.hpp&quot;
  51 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  52 #include &quot;oops/valueArrayKlass.hpp&quot;
  53 #include &quot;oops/valueArrayOop.inline.hpp&quot;
  54 #include &quot;opto/ad.hpp&quot;
  55 #include &quot;opto/addnode.hpp&quot;
  56 #include &quot;opto/callnode.hpp&quot;
  57 #include &quot;opto/cfgnode.hpp&quot;
  58 #include &quot;opto/graphKit.hpp&quot;
  59 #include &quot;opto/machnode.hpp&quot;
  60 #include &quot;opto/matcher.hpp&quot;
  61 #include &quot;opto/memnode.hpp&quot;
  62 #include &quot;opto/mulnode.hpp&quot;
  63 #include &quot;opto/runtime.hpp&quot;
  64 #include &quot;opto/subnode.hpp&quot;
  65 #include &quot;runtime/atomic.hpp&quot;
  66 #include &quot;runtime/frame.inline.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  69 #include &quot;runtime/javaCalls.hpp&quot;
  70 #include &quot;runtime/sharedRuntime.hpp&quot;
  71 #include &quot;runtime/signature.hpp&quot;
  72 #include &quot;runtime/threadCritical.hpp&quot;
  73 #include &quot;runtime/vframe.hpp&quot;
  74 #include &quot;runtime/vframeArray.hpp&quot;
  75 #include &quot;runtime/vframe_hp.hpp&quot;
  76 #include &quot;utilities/copy.hpp&quot;
  77 #include &quot;utilities/preserveException.hpp&quot;
  78 
  79 
  80 // For debugging purposes:
  81 //  To force FullGCALot inside a runtime function, add the following two lines
  82 //
  83 //  Universe::release_fullgc_alot_dummy();
  84 //  MarkSweep::invoke(0, &quot;Debugging&quot;);
  85 //
  86 // At command line specify the parameters: -XX:+FullGCALot -XX:FullGCALotStart=100000000
  87 
  88 
  89 
  90 
  91 // Compiled code entry points
  92 address OptoRuntime::_new_instance_Java                           = NULL;
  93 address OptoRuntime::_new_array_Java                              = NULL;
  94 address OptoRuntime::_new_array_nozero_Java                       = NULL;
  95 address OptoRuntime::_multianewarray2_Java                        = NULL;
  96 address OptoRuntime::_multianewarray3_Java                        = NULL;
  97 address OptoRuntime::_multianewarray4_Java                        = NULL;
  98 address OptoRuntime::_multianewarray5_Java                        = NULL;
  99 address OptoRuntime::_multianewarrayN_Java                        = NULL;
 100 address OptoRuntime::_vtable_must_compile_Java                    = NULL;
 101 address OptoRuntime::_complete_monitor_locking_Java               = NULL;
 102 address OptoRuntime::_monitor_notify_Java                         = NULL;
 103 address OptoRuntime::_monitor_notifyAll_Java                      = NULL;
 104 address OptoRuntime::_rethrow_Java                                = NULL;
 105 
 106 address OptoRuntime::_slow_arraycopy_Java                         = NULL;
 107 address OptoRuntime::_register_finalizer_Java                     = NULL;
 108 
 109 ExceptionBlob* OptoRuntime::_exception_blob;
 110 
 111 // This should be called in an assertion at the start of OptoRuntime routines
 112 // which are entered from compiled code (all of them)
 113 #ifdef ASSERT
 114 static bool check_compiled_frame(JavaThread* thread) {
 115   assert(thread-&gt;last_frame().is_runtime_frame(), &quot;cannot call runtime directly from compiled code&quot;);
 116   RegisterMap map(thread, false);
 117   frame caller = thread-&gt;last_frame().sender(&amp;map);
 118   assert(caller.is_compiled_frame(), &quot;not being called from compiled like code&quot;);
 119   return true;
 120 }
 121 #endif // ASSERT
 122 
 123 
 124 #define gen(env, var, type_func_gen, c_func, fancy_jump, pass_tls, save_arg_regs, return_pc) \
 125   var = generate_stub(env, type_func_gen, CAST_FROM_FN_PTR(address, c_func), #var, fancy_jump, pass_tls, save_arg_regs, return_pc); \
 126   if (var == NULL) { return false; }
 127 
 128 bool OptoRuntime::generate(ciEnv* env) {
 129 
 130   generate_exception_blob();
 131 
 132   // Note: tls: Means fetching the return oop out of the thread-local storage
 133   //
 134   //   variable/name                       type-function-gen              , runtime method                  ,fncy_jp, tls,save_args,retpc
 135   // -------------------------------------------------------------------------------------------------------------------------------
 136   gen(env, _new_instance_Java              , new_instance_Type            , new_instance_C                  ,    0 , true , false, false);
 137   gen(env, _new_array_Java                 , new_array_Type               , new_array_C                     ,    0 , true , false, false);
 138   gen(env, _new_array_nozero_Java          , new_array_Type               , new_array_nozero_C              ,    0 , true , false, false);
 139   gen(env, _multianewarray2_Java           , multianewarray2_Type         , multianewarray2_C               ,    0 , true , false, false);
 140   gen(env, _multianewarray3_Java           , multianewarray3_Type         , multianewarray3_C               ,    0 , true , false, false);
 141   gen(env, _multianewarray4_Java           , multianewarray4_Type         , multianewarray4_C               ,    0 , true , false, false);
 142   gen(env, _multianewarray5_Java           , multianewarray5_Type         , multianewarray5_C               ,    0 , true , false, false);
 143   gen(env, _multianewarrayN_Java           , multianewarrayN_Type         , multianewarrayN_C               ,    0 , true , false, false);
 144   gen(env, _complete_monitor_locking_Java  , complete_monitor_enter_Type  , SharedRuntime::complete_monitor_locking_C, 0, false, false, false);
 145   gen(env, _monitor_notify_Java            , monitor_notify_Type          , monitor_notify_C                ,    0 , false, false, false);
 146   gen(env, _monitor_notifyAll_Java         , monitor_notify_Type          , monitor_notifyAll_C             ,    0 , false, false, false);
 147   gen(env, _rethrow_Java                   , rethrow_Type                 , rethrow_C                       ,    2 , true , false, true );
 148 
 149   gen(env, _slow_arraycopy_Java            , slow_arraycopy_Type          , SharedRuntime::slow_arraycopy_C ,    0 , false, false, false);
 150   gen(env, _register_finalizer_Java        , register_finalizer_Type      , register_finalizer              ,    0 , false, false, false);
 151 
 152   return true;
 153 }
 154 
 155 #undef gen
 156 
 157 
 158 // Helper method to do generation of RunTimeStub&#39;s
 159 address OptoRuntime::generate_stub( ciEnv* env,
 160                                     TypeFunc_generator gen, address C_function,
 161                                     const char *name, int is_fancy_jump,
 162                                     bool pass_tls,
 163                                     bool save_argument_registers,
 164                                     bool return_pc) {
 165 
 166   // Matching the default directive, we currently have no method to match.
 167   DirectiveSet* directive = DirectivesStack::getDefaultDirective(CompileBroker::compiler(CompLevel_full_optimization));
 168   ResourceMark rm;
 169   Compile C( env, gen, C_function, name, is_fancy_jump, pass_tls, save_argument_registers, return_pc, directive);
 170   DirectivesStack::release(directive);
 171   return  C.stub_entry_point();
 172 }
 173 
 174 const char* OptoRuntime::stub_name(address entry) {
 175 #ifndef PRODUCT
 176   CodeBlob* cb = CodeCache::find_blob(entry);
 177   RuntimeStub* rs =(RuntimeStub *)cb;
 178   assert(rs != NULL &amp;&amp; rs-&gt;is_runtime_stub(), &quot;not a runtime stub&quot;);
 179   return rs-&gt;name();
 180 #else
 181   // Fast implementation for product mode (maybe it should be inlined too)
 182   return &quot;runtime stub&quot;;
 183 #endif
 184 }
 185 
 186 
 187 //=============================================================================
 188 // Opto compiler runtime routines
 189 //=============================================================================
 190 
 191 
 192 //=============================allocation======================================
 193 // We failed the fast-path allocation.  Now we need to do a scavenge or GC
 194 // and try allocation again.
 195 
 196 // object allocation
 197 JRT_BLOCK_ENTRY(void, OptoRuntime::new_instance_C(Klass* klass, bool is_larval, JavaThread* thread))
 198   JRT_BLOCK;
 199 #ifndef PRODUCT
 200   SharedRuntime::_new_instance_ctr++;         // new instance requires GC
 201 #endif
 202   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 203 
 204   // These checks are cheap to make and support reflective allocation.
 205   int lh = klass-&gt;layout_helper();
 206   if (Klass::layout_helper_needs_slow_path(lh) || !InstanceKlass::cast(klass)-&gt;is_initialized()) {
 207     Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 208     klass-&gt;check_valid_for_instantiation(false, THREAD);
 209     if (!HAS_PENDING_EXCEPTION) {
 210       InstanceKlass::cast(klass)-&gt;initialize(THREAD);
 211     }
 212   }
 213 
 214   if (!HAS_PENDING_EXCEPTION) {
 215     // Scavenge and allocate an instance.
 216     Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 217     instanceOop result = InstanceKlass::cast(klass)-&gt;allocate_instance(THREAD);
 218     if (is_larval) {
 219       // Check if this is a larval buffer allocation
 220       result-&gt;set_mark(result-&gt;mark().enter_larval_state());
 221     }
 222     thread-&gt;set_vm_result(result);
 223 
 224     // Pass oops back through thread local storage.  Our apparent type to Java
 225     // is that we return an oop, but we can block on exit from this routine and
 226     // a GC can trash the oop in C&#39;s return register.  The generated stub will
 227     // fetch the oop from TLS after any possible GC.
 228   }
 229 
 230   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 231   JRT_BLOCK_END;
 232 
 233   // inform GC that we won&#39;t do card marks for initializing writes.
 234   SharedRuntime::on_slowpath_allocation_exit(thread);
 235 JRT_END
 236 
 237 
 238 // array allocation
 239 JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_C(Klass* array_type, int len, JavaThread *thread))
 240   JRT_BLOCK;
 241 #ifndef PRODUCT
 242   SharedRuntime::_new_array_ctr++;            // new array requires GC
 243 #endif
 244   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 245 
 246   // Scavenge and allocate an instance.
 247   oop result;
 248 
 249   if (array_type-&gt;is_valueArray_klass()) {
 250     Klass* elem_type = ValueArrayKlass::cast(array_type)-&gt;element_klass();
 251     result = oopFactory::new_valueArray(elem_type, len, THREAD);
 252   } else if (array_type-&gt;is_typeArray_klass()) {
 253     // The oopFactory likes to work with the element type.
 254     // (We could bypass the oopFactory, since it doesn&#39;t add much value.)
 255     BasicType elem_type = TypeArrayKlass::cast(array_type)-&gt;element_type();
 256     result = oopFactory::new_typeArray(elem_type, len, THREAD);
 257   } else {
 258     Handle holder(THREAD, array_type-&gt;klass_holder()); // keep the array klass alive
 259     result = ObjArrayKlass::cast(array_type)-&gt;allocate(len, THREAD);
 260   }
 261 
 262   // Pass oops back through thread local storage.  Our apparent type to Java
 263   // is that we return an oop, but we can block on exit from this routine and
 264   // a GC can trash the oop in C&#39;s return register.  The generated stub will
 265   // fetch the oop from TLS after any possible GC.
 266   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 267   thread-&gt;set_vm_result(result);
 268   JRT_BLOCK_END;
 269 
 270   // inform GC that we won&#39;t do card marks for initializing writes.
 271   SharedRuntime::on_slowpath_allocation_exit(thread);
 272 JRT_END
 273 
 274 // array allocation without zeroing
 275 JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_nozero_C(Klass* array_type, int len, JavaThread *thread))
 276   JRT_BLOCK;
 277 #ifndef PRODUCT
 278   SharedRuntime::_new_array_ctr++;            // new array requires GC
 279 #endif
 280   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 281 
 282   // Scavenge and allocate an instance.
 283   oop result;
 284 
 285   assert(array_type-&gt;is_typeArray_klass(), &quot;should be called only for type array&quot;);
 286   // The oopFactory likes to work with the element type.
 287   BasicType elem_type = TypeArrayKlass::cast(array_type)-&gt;element_type();
 288   result = oopFactory::new_typeArray_nozero(elem_type, len, THREAD);
 289 
 290   // Pass oops back through thread local storage.  Our apparent type to Java
 291   // is that we return an oop, but we can block on exit from this routine and
 292   // a GC can trash the oop in C&#39;s return register.  The generated stub will
 293   // fetch the oop from TLS after any possible GC.
 294   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 295   thread-&gt;set_vm_result(result);
 296   JRT_BLOCK_END;
 297 
 298 
 299   // inform GC that we won&#39;t do card marks for initializing writes.
 300   SharedRuntime::on_slowpath_allocation_exit(thread);
 301 
 302   oop result = thread-&gt;vm_result();
 303   if ((len &gt; 0) &amp;&amp; (result != NULL) &amp;&amp;
 304       is_deoptimized_caller_frame(thread)) {
 305     // Zero array here if the caller is deoptimized.
 306     int size = ((typeArrayOop)result)-&gt;object_size();
 307     BasicType elem_type = TypeArrayKlass::cast(array_type)-&gt;element_type();
 308     const size_t hs = arrayOopDesc::header_size(elem_type);
 309     // Align to next 8 bytes to avoid trashing arrays&#39;s length.
 310     const size_t aligned_hs = align_object_offset(hs);
 311     HeapWord* obj = cast_from_oop&lt;HeapWord*&gt;(result);
 312     if (aligned_hs &gt; hs) {
 313       Copy::zero_to_words(obj+hs, aligned_hs-hs);
 314     }
 315     // Optimized zeroing.
 316     Copy::fill_to_aligned_words(obj+aligned_hs, size-aligned_hs);
 317   }
 318 
 319 JRT_END
 320 
 321 // Note: multianewarray for one dimension is handled inline by GraphKit::new_array.
 322 
 323 // multianewarray for 2 dimensions
 324 JRT_ENTRY(void, OptoRuntime::multianewarray2_C(Klass* elem_type, int len1, int len2, JavaThread *thread))
 325 #ifndef PRODUCT
 326   SharedRuntime::_multi2_ctr++;                // multianewarray for 1 dimension
 327 #endif
 328   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 329   assert(elem_type-&gt;is_klass(), &quot;not a class&quot;);
 330   jint dims[2];
 331   dims[0] = len1;
 332   dims[1] = len2;
 333   Handle holder(THREAD, elem_type-&gt;klass_holder()); // keep the klass alive
 334   oop obj = ArrayKlass::cast(elem_type)-&gt;multi_allocate(2, dims, THREAD);
 335   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 336   thread-&gt;set_vm_result(obj);
 337 JRT_END
 338 
 339 // multianewarray for 3 dimensions
 340 JRT_ENTRY(void, OptoRuntime::multianewarray3_C(Klass* elem_type, int len1, int len2, int len3, JavaThread *thread))
 341 #ifndef PRODUCT
 342   SharedRuntime::_multi3_ctr++;                // multianewarray for 1 dimension
 343 #endif
 344   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 345   assert(elem_type-&gt;is_klass(), &quot;not a class&quot;);
 346   jint dims[3];
 347   dims[0] = len1;
 348   dims[1] = len2;
 349   dims[2] = len3;
 350   Handle holder(THREAD, elem_type-&gt;klass_holder()); // keep the klass alive
 351   oop obj = ArrayKlass::cast(elem_type)-&gt;multi_allocate(3, dims, THREAD);
 352   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 353   thread-&gt;set_vm_result(obj);
 354 JRT_END
 355 
 356 // multianewarray for 4 dimensions
 357 JRT_ENTRY(void, OptoRuntime::multianewarray4_C(Klass* elem_type, int len1, int len2, int len3, int len4, JavaThread *thread))
 358 #ifndef PRODUCT
 359   SharedRuntime::_multi4_ctr++;                // multianewarray for 1 dimension
 360 #endif
 361   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 362   assert(elem_type-&gt;is_klass(), &quot;not a class&quot;);
 363   jint dims[4];
 364   dims[0] = len1;
 365   dims[1] = len2;
 366   dims[2] = len3;
 367   dims[3] = len4;
 368   Handle holder(THREAD, elem_type-&gt;klass_holder()); // keep the klass alive
 369   oop obj = ArrayKlass::cast(elem_type)-&gt;multi_allocate(4, dims, THREAD);
 370   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 371   thread-&gt;set_vm_result(obj);
 372 JRT_END
 373 
 374 // multianewarray for 5 dimensions
 375 JRT_ENTRY(void, OptoRuntime::multianewarray5_C(Klass* elem_type, int len1, int len2, int len3, int len4, int len5, JavaThread *thread))
 376 #ifndef PRODUCT
 377   SharedRuntime::_multi5_ctr++;                // multianewarray for 1 dimension
 378 #endif
 379   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 380   assert(elem_type-&gt;is_klass(), &quot;not a class&quot;);
 381   jint dims[5];
 382   dims[0] = len1;
 383   dims[1] = len2;
 384   dims[2] = len3;
 385   dims[3] = len4;
 386   dims[4] = len5;
 387   Handle holder(THREAD, elem_type-&gt;klass_holder()); // keep the klass alive
 388   oop obj = ArrayKlass::cast(elem_type)-&gt;multi_allocate(5, dims, THREAD);
 389   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 390   thread-&gt;set_vm_result(obj);
 391 JRT_END
 392 
 393 JRT_ENTRY(void, OptoRuntime::multianewarrayN_C(Klass* elem_type, arrayOopDesc* dims, JavaThread *thread))
 394   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 395   assert(elem_type-&gt;is_klass(), &quot;not a class&quot;);
 396   assert(oop(dims)-&gt;is_typeArray(), &quot;not an array&quot;);
 397 
 398   ResourceMark rm;
 399   jint len = dims-&gt;length();
 400   assert(len &gt; 0, &quot;Dimensions array should contain data&quot;);
 401   jint *c_dims = NEW_RESOURCE_ARRAY(jint, len);
 402   ArrayAccess&lt;&gt;::arraycopy_to_native&lt;&gt;(dims, typeArrayOopDesc::element_offset&lt;jint&gt;(0),
 403                                        c_dims, len);
 404 
 405   Handle holder(THREAD, elem_type-&gt;klass_holder()); // keep the klass alive
 406   oop obj = ArrayKlass::cast(elem_type)-&gt;multi_allocate(len, c_dims, THREAD);
 407   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 408   thread-&gt;set_vm_result(obj);
 409 JRT_END
 410 
 411 JRT_BLOCK_ENTRY(void, OptoRuntime::monitor_notify_C(oopDesc* obj, JavaThread *thread))
 412 
 413   // Very few notify/notifyAll operations find any threads on the waitset, so
 414   // the dominant fast-path is to simply return.
 415   // Relatedly, it&#39;s critical that notify/notifyAll be fast in order to
 416   // reduce lock hold times.
 417   if (!SafepointSynchronize::is_synchronizing()) {
 418     if (ObjectSynchronizer::quick_notify(obj, thread, false)) {
 419       return;
 420     }
 421   }
 422 
 423   // This is the case the fast-path above isn&#39;t provisioned to handle.
 424   // The fast-path is designed to handle frequently arising cases in an efficient manner.
 425   // (The fast-path is just a degenerate variant of the slow-path).
 426   // Perform the dreaded state transition and pass control into the slow-path.
 427   JRT_BLOCK;
 428   Handle h_obj(THREAD, obj);
 429   ObjectSynchronizer::notify(h_obj, CHECK);
 430   JRT_BLOCK_END;
 431 JRT_END
 432 
 433 JRT_BLOCK_ENTRY(void, OptoRuntime::monitor_notifyAll_C(oopDesc* obj, JavaThread *thread))
 434 
 435   if (!SafepointSynchronize::is_synchronizing() ) {
 436     if (ObjectSynchronizer::quick_notify(obj, thread, true)) {
 437       return;
 438     }
 439   }
 440 
 441   // This is the case the fast-path above isn&#39;t provisioned to handle.
 442   // The fast-path is designed to handle frequently arising cases in an efficient manner.
 443   // (The fast-path is just a degenerate variant of the slow-path).
 444   // Perform the dreaded state transition and pass control into the slow-path.
 445   JRT_BLOCK;
 446   Handle h_obj(THREAD, obj);
 447   ObjectSynchronizer::notifyall(h_obj, CHECK);
 448   JRT_BLOCK_END;
 449 JRT_END
 450 
 451 const TypeFunc *OptoRuntime::new_instance_Type() {
 452   // create input type (domain)
 453   const Type **fields = TypeTuple::fields(2);
 454   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // Klass to be allocated
 455   fields[TypeFunc::Parms+1] = TypeInt::BOOL;        // is_larval
 456   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 457 
 458   // create result type (range)
 459   fields = TypeTuple::fields(1);
 460   fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL; // Returned oop
 461 
 462   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 463 
 464   return TypeFunc::make(domain, range);
 465 }
 466 
 467 
 468 const TypeFunc *OptoRuntime::athrow_Type() {
 469   // create input type (domain)
 470   const Type **fields = TypeTuple::fields(1);
 471   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // Klass to be allocated
 472   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 473 
 474   // create result type (range)
 475   fields = TypeTuple::fields(0);
 476 
 477   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 478 
 479   return TypeFunc::make(domain, range);
 480 }
 481 
 482 
 483 const TypeFunc *OptoRuntime::new_array_Type() {
 484   // create input type (domain)
 485   const Type **fields = TypeTuple::fields(2);
 486   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;   // element klass
 487   fields[TypeFunc::Parms+1] = TypeInt::INT;       // array size
 488   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 489 
 490   // create result type (range)
 491   fields = TypeTuple::fields(1);
 492   fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL; // Returned oop
 493 
 494   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 495 
 496   return TypeFunc::make(domain, range);
 497 }
 498 
 499 const TypeFunc *OptoRuntime::multianewarray_Type(int ndim) {
 500   // create input type (domain)
 501   const int nargs = ndim + 1;
 502   const Type **fields = TypeTuple::fields(nargs);
 503   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;   // element klass
 504   for( int i = 1; i &lt; nargs; i++ )
 505     fields[TypeFunc::Parms + i] = TypeInt::INT;       // array size
 506   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+nargs, fields);
 507 
 508   // create result type (range)
 509   fields = TypeTuple::fields(1);
 510   fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL; // Returned oop
 511   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 512 
 513   return TypeFunc::make(domain, range);
 514 }
 515 
 516 const TypeFunc *OptoRuntime::multianewarray2_Type() {
 517   return multianewarray_Type(2);
 518 }
 519 
 520 const TypeFunc *OptoRuntime::multianewarray3_Type() {
 521   return multianewarray_Type(3);
 522 }
 523 
 524 const TypeFunc *OptoRuntime::multianewarray4_Type() {
 525   return multianewarray_Type(4);
 526 }
 527 
 528 const TypeFunc *OptoRuntime::multianewarray5_Type() {
 529   return multianewarray_Type(5);
 530 }
 531 
 532 const TypeFunc *OptoRuntime::multianewarrayN_Type() {
 533   // create input type (domain)
 534   const Type **fields = TypeTuple::fields(2);
 535   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;   // element klass
 536   fields[TypeFunc::Parms+1] = TypeInstPtr::NOTNULL;   // array of dim sizes
 537   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 538 
 539   // create result type (range)
 540   fields = TypeTuple::fields(1);
 541   fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL; // Returned oop
 542   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 543 
 544   return TypeFunc::make(domain, range);
 545 }
 546 
 547 const TypeFunc *OptoRuntime::uncommon_trap_Type() {
 548   // create input type (domain)
 549   const Type **fields = TypeTuple::fields(1);
 550   fields[TypeFunc::Parms+0] = TypeInt::INT; // trap_reason (deopt reason and action)
 551   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 552 
 553   // create result type (range)
 554   fields = TypeTuple::fields(0);
 555   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 556 
 557   return TypeFunc::make(domain, range);
 558 }
 559 
 560 //-----------------------------------------------------------------------------
 561 // Monitor Handling
 562 const TypeFunc *OptoRuntime::complete_monitor_enter_Type() {
 563   // create input type (domain)
 564   const Type **fields = TypeTuple::fields(2);
 565   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;  // Object to be Locked
 566   fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM;   // Address of stack location for lock
 567   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2,fields);
 568 
 569   // create result type (range)
 570   fields = TypeTuple::fields(0);
 571 
 572   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0,fields);
 573 
 574   return TypeFunc::make(domain, range);
 575 }
 576 
 577 
 578 //-----------------------------------------------------------------------------
 579 const TypeFunc *OptoRuntime::complete_monitor_exit_Type() {
 580   // create input type (domain)
 581   const Type **fields = TypeTuple::fields(3);
 582   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;  // Object to be Locked
 583   fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM;    // Address of stack location for lock - BasicLock
 584   fields[TypeFunc::Parms+2] = TypeRawPtr::BOTTOM;    // Thread pointer (Self)
 585   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+3, fields);
 586 
 587   // create result type (range)
 588   fields = TypeTuple::fields(0);
 589 
 590   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 591 
 592   return TypeFunc::make(domain, range);
 593 }
 594 
 595 const TypeFunc *OptoRuntime::monitor_notify_Type() {
 596   // create input type (domain)
 597   const Type **fields = TypeTuple::fields(1);
 598   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;  // Object to be Locked
 599   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 600 
 601   // create result type (range)
 602   fields = TypeTuple::fields(0);
 603   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 604   return TypeFunc::make(domain, range);
 605 }
 606 
 607 const TypeFunc* OptoRuntime::flush_windows_Type() {
 608   // create input type (domain)
 609   const Type** fields = TypeTuple::fields(1);
 610   fields[TypeFunc::Parms+0] = NULL; // void
 611   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms, fields);
 612 
 613   // create result type
 614   fields = TypeTuple::fields(1);
 615   fields[TypeFunc::Parms+0] = NULL; // void
 616   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);
 617 
 618   return TypeFunc::make(domain, range);
 619 }
 620 
 621 const TypeFunc* OptoRuntime::l2f_Type() {
 622   // create input type (domain)
 623   const Type **fields = TypeTuple::fields(2);
 624   fields[TypeFunc::Parms+0] = TypeLong::LONG;
 625   fields[TypeFunc::Parms+1] = Type::HALF;
 626   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 627 
 628   // create result type (range)
 629   fields = TypeTuple::fields(1);
 630   fields[TypeFunc::Parms+0] = Type::FLOAT;
 631   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 632 
 633   return TypeFunc::make(domain, range);
 634 }
 635 
 636 const TypeFunc* OptoRuntime::modf_Type() {
 637   const Type **fields = TypeTuple::fields(2);
 638   fields[TypeFunc::Parms+0] = Type::FLOAT;
 639   fields[TypeFunc::Parms+1] = Type::FLOAT;
 640   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 641 
 642   // create result type (range)
 643   fields = TypeTuple::fields(1);
 644   fields[TypeFunc::Parms+0] = Type::FLOAT;
 645 
 646   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 647 
 648   return TypeFunc::make(domain, range);
 649 }
 650 
 651 const TypeFunc *OptoRuntime::Math_D_D_Type() {
 652   // create input type (domain)
 653   const Type **fields = TypeTuple::fields(2);
 654   // Symbol* name of class to be loaded
 655   fields[TypeFunc::Parms+0] = Type::DOUBLE;
 656   fields[TypeFunc::Parms+1] = Type::HALF;
 657   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 658 
 659   // create result type (range)
 660   fields = TypeTuple::fields(2);
 661   fields[TypeFunc::Parms+0] = Type::DOUBLE;
 662   fields[TypeFunc::Parms+1] = Type::HALF;
 663   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+2, fields);
 664 
 665   return TypeFunc::make(domain, range);
 666 }
 667 
 668 const TypeFunc* OptoRuntime::Math_DD_D_Type() {
 669   const Type **fields = TypeTuple::fields(4);
 670   fields[TypeFunc::Parms+0] = Type::DOUBLE;
 671   fields[TypeFunc::Parms+1] = Type::HALF;
 672   fields[TypeFunc::Parms+2] = Type::DOUBLE;
 673   fields[TypeFunc::Parms+3] = Type::HALF;
 674   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+4, fields);
 675 
 676   // create result type (range)
 677   fields = TypeTuple::fields(2);
 678   fields[TypeFunc::Parms+0] = Type::DOUBLE;
 679   fields[TypeFunc::Parms+1] = Type::HALF;
 680   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+2, fields);
 681 
 682   return TypeFunc::make(domain, range);
 683 }
 684 
 685 //-------------- currentTimeMillis, currentTimeNanos, etc
 686 
 687 const TypeFunc* OptoRuntime::void_long_Type() {
 688   // create input type (domain)
 689   const Type **fields = TypeTuple::fields(0);
 690   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+0, fields);
 691 
 692   // create result type (range)
 693   fields = TypeTuple::fields(2);
 694   fields[TypeFunc::Parms+0] = TypeLong::LONG;
 695   fields[TypeFunc::Parms+1] = Type::HALF;
 696   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+2, fields);
 697 
 698   return TypeFunc::make(domain, range);
 699 }
 700 
 701 // arraycopy stub variations:
 702 enum ArrayCopyType {
 703   ac_fast,                      // void(ptr, ptr, size_t)
 704   ac_checkcast,                 //  int(ptr, ptr, size_t, size_t, ptr)
 705   ac_slow,                      // void(ptr, int, ptr, int, int)
 706   ac_generic                    //  int(ptr, int, ptr, int, int)
 707 };
 708 
 709 static const TypeFunc* make_arraycopy_Type(ArrayCopyType act) {
 710   // create input type (domain)
 711   int num_args      = (act == ac_fast ? 3 : 5);
 712   int num_size_args = (act == ac_fast ? 1 : act == ac_checkcast ? 2 : 0);
 713   int argcnt = num_args;
 714   LP64_ONLY(argcnt += num_size_args); // halfwords for lengths
 715   const Type** fields = TypeTuple::fields(argcnt);
 716   int argp = TypeFunc::Parms;
 717   fields[argp++] = TypePtr::NOTNULL;    // src
 718   if (num_size_args == 0) {
 719     fields[argp++] = TypeInt::INT;      // src_pos
 720   }
 721   fields[argp++] = TypePtr::NOTNULL;    // dest
 722   if (num_size_args == 0) {
 723     fields[argp++] = TypeInt::INT;      // dest_pos
 724     fields[argp++] = TypeInt::INT;      // length
 725   }
 726   while (num_size_args-- &gt; 0) {
 727     fields[argp++] = TypeX_X;               // size in whatevers (size_t)
 728     LP64_ONLY(fields[argp++] = Type::HALF); // other half of long length
 729   }
 730   if (act == ac_checkcast) {
 731     fields[argp++] = TypePtr::NOTNULL;  // super_klass
 732   }
 733   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding of act&quot;);
 734   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 735 
 736   // create result type if needed
 737   int retcnt = (act == ac_checkcast || act == ac_generic ? 1 : 0);
 738   fields = TypeTuple::fields(1);
 739   if (retcnt == 0)
 740     fields[TypeFunc::Parms+0] = NULL; // void
 741   else
 742     fields[TypeFunc::Parms+0] = TypeInt::INT; // status result, if needed
 743   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+retcnt, fields);
 744   return TypeFunc::make(domain, range);
 745 }
 746 
 747 const TypeFunc* OptoRuntime::fast_arraycopy_Type() {
 748   // This signature is simple:  Two base pointers and a size_t.
 749   return make_arraycopy_Type(ac_fast);
 750 }
 751 
 752 const TypeFunc* OptoRuntime::checkcast_arraycopy_Type() {
 753   // An extension of fast_arraycopy_Type which adds type checking.
 754   return make_arraycopy_Type(ac_checkcast);
 755 }
 756 
 757 const TypeFunc* OptoRuntime::slow_arraycopy_Type() {
 758   // This signature is exactly the same as System.arraycopy.
 759   // There are no intptr_t (int/long) arguments.
 760   return make_arraycopy_Type(ac_slow);
 761 }
 762 
 763 const TypeFunc* OptoRuntime::generic_arraycopy_Type() {
 764   // This signature is like System.arraycopy, except that it returns status.
 765   return make_arraycopy_Type(ac_generic);
 766 }
 767 
 768 
 769 const TypeFunc* OptoRuntime::array_fill_Type() {
 770   const Type** fields;
 771   int argp = TypeFunc::Parms;
 772   // create input type (domain): pointer, int, size_t
 773   fields = TypeTuple::fields(3 LP64_ONLY( + 1));
 774   fields[argp++] = TypePtr::NOTNULL;
 775   fields[argp++] = TypeInt::INT;
 776   fields[argp++] = TypeX_X;               // size in whatevers (size_t)
 777   LP64_ONLY(fields[argp++] = Type::HALF); // other half of long length
 778   const TypeTuple *domain = TypeTuple::make(argp, fields);
 779 
 780   // create result type
 781   fields = TypeTuple::fields(1);
 782   fields[TypeFunc::Parms+0] = NULL; // void
 783   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);
 784 
 785   return TypeFunc::make(domain, range);
 786 }
 787 
 788 // for aescrypt encrypt/decrypt operations, just three pointers returning void (length is constant)
 789 const TypeFunc* OptoRuntime::aescrypt_block_Type() {
 790   // create input type (domain)
 791   int num_args      = 3;
 792   if (Matcher::pass_original_key_for_aes()) {
 793     num_args = 4;
 794   }
 795   int argcnt = num_args;
 796   const Type** fields = TypeTuple::fields(argcnt);
 797   int argp = TypeFunc::Parms;
 798   fields[argp++] = TypePtr::NOTNULL;    // src
 799   fields[argp++] = TypePtr::NOTNULL;    // dest
 800   fields[argp++] = TypePtr::NOTNULL;    // k array
 801   if (Matcher::pass_original_key_for_aes()) {
 802     fields[argp++] = TypePtr::NOTNULL;    // original k array
 803   }
 804   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 805   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 806 
 807   // no result type needed
 808   fields = TypeTuple::fields(1);
 809   fields[TypeFunc::Parms+0] = NULL; // void
 810   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
 811   return TypeFunc::make(domain, range);
 812 }
 813 
 814 /**
 815  * int updateBytesCRC32(int crc, byte* b, int len)
 816  */
 817 const TypeFunc* OptoRuntime::updateBytesCRC32_Type() {
 818   // create input type (domain)
 819   int num_args      = 3;
 820   int argcnt = num_args;
 821   const Type** fields = TypeTuple::fields(argcnt);
 822   int argp = TypeFunc::Parms;
 823   fields[argp++] = TypeInt::INT;        // crc
 824   fields[argp++] = TypePtr::NOTNULL;    // src
 825   fields[argp++] = TypeInt::INT;        // len
 826   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 827   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 828 
 829   // result type needed
 830   fields = TypeTuple::fields(1);
 831   fields[TypeFunc::Parms+0] = TypeInt::INT; // crc result
 832   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
 833   return TypeFunc::make(domain, range);
 834 }
 835 
 836 /**
 837  * int updateBytesCRC32C(int crc, byte* buf, int len, int* table)
 838  */
 839 const TypeFunc* OptoRuntime::updateBytesCRC32C_Type() {
 840   // create input type (domain)
 841   int num_args      = 4;
 842   int argcnt = num_args;
 843   const Type** fields = TypeTuple::fields(argcnt);
 844   int argp = TypeFunc::Parms;
 845   fields[argp++] = TypeInt::INT;        // crc
 846   fields[argp++] = TypePtr::NOTNULL;    // buf
 847   fields[argp++] = TypeInt::INT;        // len
 848   fields[argp++] = TypePtr::NOTNULL;    // table
 849   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 850   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 851 
 852   // result type needed
 853   fields = TypeTuple::fields(1);
 854   fields[TypeFunc::Parms+0] = TypeInt::INT; // crc result
 855   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
 856   return TypeFunc::make(domain, range);
 857 }
 858 
 859 /**
 860 *  int updateBytesAdler32(int adler, bytes* b, int off, int len)
 861 */
 862 const TypeFunc* OptoRuntime::updateBytesAdler32_Type() {
 863   // create input type (domain)
 864   int num_args      = 3;
 865   int argcnt = num_args;
 866   const Type** fields = TypeTuple::fields(argcnt);
 867   int argp = TypeFunc::Parms;
 868   fields[argp++] = TypeInt::INT;        // crc
 869   fields[argp++] = TypePtr::NOTNULL;    // src + offset
 870   fields[argp++] = TypeInt::INT;        // len
 871   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 872   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 873 
 874   // result type needed
 875   fields = TypeTuple::fields(1);
 876   fields[TypeFunc::Parms+0] = TypeInt::INT; // crc result
 877   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
 878   return TypeFunc::make(domain, range);
 879 }
 880 
 881 // for cipherBlockChaining calls of aescrypt encrypt/decrypt, four pointers and a length, returning int
 882 const TypeFunc* OptoRuntime::cipherBlockChaining_aescrypt_Type() {
 883   // create input type (domain)
 884   int num_args      = 5;
 885   if (Matcher::pass_original_key_for_aes()) {
 886     num_args = 6;
 887   }
 888   int argcnt = num_args;
 889   const Type** fields = TypeTuple::fields(argcnt);
 890   int argp = TypeFunc::Parms;
 891   fields[argp++] = TypePtr::NOTNULL;    // src
 892   fields[argp++] = TypePtr::NOTNULL;    // dest
 893   fields[argp++] = TypePtr::NOTNULL;    // k array
 894   fields[argp++] = TypePtr::NOTNULL;    // r array
 895   fields[argp++] = TypeInt::INT;        // src len
 896   if (Matcher::pass_original_key_for_aes()) {
 897     fields[argp++] = TypePtr::NOTNULL;    // original k array
 898   }
 899   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 900   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 901 
 902   // returning cipher len (int)
 903   fields = TypeTuple::fields(1);
 904   fields[TypeFunc::Parms+0] = TypeInt::INT;
 905   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
 906   return TypeFunc::make(domain, range);
 907 }
 908 
 909 // for electronicCodeBook calls of aescrypt encrypt/decrypt, three pointers and a length, returning int
 910 const TypeFunc* OptoRuntime::electronicCodeBook_aescrypt_Type() {
 911   // create input type (domain)
 912   int num_args = 4;
 913   if (Matcher::pass_original_key_for_aes()) {
 914      num_args = 5;
 915   }
 916   int argcnt = num_args;
 917   const Type** fields = TypeTuple::fields(argcnt);
 918   int argp = TypeFunc::Parms;
 919   fields[argp++] = TypePtr::NOTNULL;    // src
 920   fields[argp++] = TypePtr::NOTNULL;    // dest
 921   fields[argp++] = TypePtr::NOTNULL;    // k array
 922   fields[argp++] = TypeInt::INT;        // src len
 923   if (Matcher::pass_original_key_for_aes()) {
 924      fields[argp++] = TypePtr::NOTNULL;    // original k array
 925   }
 926   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);
 927   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);
 928 
 929   // returning cipher len (int)
 930   fields = TypeTuple::fields(1);
 931   fields[TypeFunc::Parms + 0] = TypeInt::INT;
 932   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);
 933   return TypeFunc::make(domain, range);
 934 }
 935 
 936 //for counterMode calls of aescrypt encrypt/decrypt, four pointers and a length, returning int
 937 const TypeFunc* OptoRuntime::counterMode_aescrypt_Type() {
 938   // create input type (domain)
 939   int num_args = 7;
 940   if (Matcher::pass_original_key_for_aes()) {
 941     num_args = 8;
 942   }
 943   int argcnt = num_args;
 944   const Type** fields = TypeTuple::fields(argcnt);
 945   int argp = TypeFunc::Parms;
 946   fields[argp++] = TypePtr::NOTNULL; // src
 947   fields[argp++] = TypePtr::NOTNULL; // dest
 948   fields[argp++] = TypePtr::NOTNULL; // k array
 949   fields[argp++] = TypePtr::NOTNULL; // counter array
 950   fields[argp++] = TypeInt::INT; // src len
 951   fields[argp++] = TypePtr::NOTNULL; // saved_encCounter
 952   fields[argp++] = TypePtr::NOTNULL; // saved used addr
 953   if (Matcher::pass_original_key_for_aes()) {
 954     fields[argp++] = TypePtr::NOTNULL; // original k array
 955   }
 956   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);
 957   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);
 958   // returning cipher len (int)
 959   fields = TypeTuple::fields(1);
 960   fields[TypeFunc::Parms + 0] = TypeInt::INT;
 961   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);
 962   return TypeFunc::make(domain, range);
 963 }
 964 
 965 /*
 966  * void implCompress(byte[] buf, int ofs)
 967  */
 968 const TypeFunc* OptoRuntime::sha_implCompress_Type() {
 969   // create input type (domain)
 970   int num_args = 2;
 971   int argcnt = num_args;
 972   const Type** fields = TypeTuple::fields(argcnt);
 973   int argp = TypeFunc::Parms;
 974   fields[argp++] = TypePtr::NOTNULL; // buf
 975   fields[argp++] = TypePtr::NOTNULL; // state
 976   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 977   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 978 
 979   // no result type needed
 980   fields = TypeTuple::fields(1);
 981   fields[TypeFunc::Parms+0] = NULL; // void
 982   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
 983   return TypeFunc::make(domain, range);
 984 }
 985 
 986 /*
 987  * int implCompressMultiBlock(byte[] b, int ofs, int limit)
 988  */
 989 const TypeFunc* OptoRuntime::digestBase_implCompressMB_Type() {
 990   // create input type (domain)
 991   int num_args = 4;
 992   int argcnt = num_args;
 993   const Type** fields = TypeTuple::fields(argcnt);
 994   int argp = TypeFunc::Parms;
 995   fields[argp++] = TypePtr::NOTNULL; // buf
 996   fields[argp++] = TypePtr::NOTNULL; // state
 997   fields[argp++] = TypeInt::INT;     // ofs
 998   fields[argp++] = TypeInt::INT;     // limit
 999   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1000   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1001 
1002   // returning ofs (int)
1003   fields = TypeTuple::fields(1);
1004   fields[TypeFunc::Parms+0] = TypeInt::INT; // ofs
1005   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
1006   return TypeFunc::make(domain, range);
1007 }
1008 
1009 const TypeFunc* OptoRuntime::multiplyToLen_Type() {
1010   // create input type (domain)
1011   int num_args      = 6;
1012   int argcnt = num_args;
1013   const Type** fields = TypeTuple::fields(argcnt);
1014   int argp = TypeFunc::Parms;
1015   fields[argp++] = TypePtr::NOTNULL;    // x
1016   fields[argp++] = TypeInt::INT;        // xlen
1017   fields[argp++] = TypePtr::NOTNULL;    // y
1018   fields[argp++] = TypeInt::INT;        // ylen
1019   fields[argp++] = TypePtr::NOTNULL;    // z
1020   fields[argp++] = TypeInt::INT;        // zlen
1021   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1022   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1023 
1024   // no result type needed
1025   fields = TypeTuple::fields(1);
1026   fields[TypeFunc::Parms+0] = NULL;
1027   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1028   return TypeFunc::make(domain, range);
1029 }
1030 
1031 const TypeFunc* OptoRuntime::squareToLen_Type() {
1032   // create input type (domain)
1033   int num_args      = 4;
1034   int argcnt = num_args;
1035   const Type** fields = TypeTuple::fields(argcnt);
1036   int argp = TypeFunc::Parms;
1037   fields[argp++] = TypePtr::NOTNULL;    // x
1038   fields[argp++] = TypeInt::INT;        // len
1039   fields[argp++] = TypePtr::NOTNULL;    // z
1040   fields[argp++] = TypeInt::INT;        // zlen
1041   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1042   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1043 
1044   // no result type needed
1045   fields = TypeTuple::fields(1);
1046   fields[TypeFunc::Parms+0] = NULL;
1047   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1048   return TypeFunc::make(domain, range);
1049 }
1050 
1051 // for mulAdd calls, 2 pointers and 3 ints, returning int
1052 const TypeFunc* OptoRuntime::mulAdd_Type() {
1053   // create input type (domain)
1054   int num_args      = 5;
1055   int argcnt = num_args;
1056   const Type** fields = TypeTuple::fields(argcnt);
1057   int argp = TypeFunc::Parms;
1058   fields[argp++] = TypePtr::NOTNULL;    // out
1059   fields[argp++] = TypePtr::NOTNULL;    // in
1060   fields[argp++] = TypeInt::INT;        // offset
1061   fields[argp++] = TypeInt::INT;        // len
1062   fields[argp++] = TypeInt::INT;        // k
1063   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1064   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1065 
1066   // returning carry (int)
1067   fields = TypeTuple::fields(1);
1068   fields[TypeFunc::Parms+0] = TypeInt::INT;
1069   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
1070   return TypeFunc::make(domain, range);
1071 }
1072 
1073 const TypeFunc* OptoRuntime::montgomeryMultiply_Type() {
1074   // create input type (domain)
1075   int num_args      = 7;
1076   int argcnt = num_args;
1077   const Type** fields = TypeTuple::fields(argcnt);
1078   int argp = TypeFunc::Parms;
1079   fields[argp++] = TypePtr::NOTNULL;    // a
1080   fields[argp++] = TypePtr::NOTNULL;    // b
1081   fields[argp++] = TypePtr::NOTNULL;    // n
1082   fields[argp++] = TypeInt::INT;        // len
1083   fields[argp++] = TypeLong::LONG;      // inv
1084   fields[argp++] = Type::HALF;
1085   fields[argp++] = TypePtr::NOTNULL;    // result
1086   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1087   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1088 
1089   // result type needed
1090   fields = TypeTuple::fields(1);
1091   fields[TypeFunc::Parms+0] = TypePtr::NOTNULL;
1092 
1093   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1094   return TypeFunc::make(domain, range);
1095 }
1096 
1097 const TypeFunc* OptoRuntime::montgomerySquare_Type() {
1098   // create input type (domain)
1099   int num_args      = 6;
1100   int argcnt = num_args;
1101   const Type** fields = TypeTuple::fields(argcnt);
1102   int argp = TypeFunc::Parms;
1103   fields[argp++] = TypePtr::NOTNULL;    // a
1104   fields[argp++] = TypePtr::NOTNULL;    // n
1105   fields[argp++] = TypeInt::INT;        // len
1106   fields[argp++] = TypeLong::LONG;      // inv
1107   fields[argp++] = Type::HALF;
1108   fields[argp++] = TypePtr::NOTNULL;    // result
1109   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1110   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1111 
1112   // result type needed
1113   fields = TypeTuple::fields(1);
1114   fields[TypeFunc::Parms+0] = TypePtr::NOTNULL;
1115 
1116   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1117   return TypeFunc::make(domain, range);
1118 }
1119 
1120 const TypeFunc * OptoRuntime::bigIntegerShift_Type() {
1121   int argcnt = 5;
1122   const Type** fields = TypeTuple::fields(argcnt);
1123   int argp = TypeFunc::Parms;
1124   fields[argp++] = TypePtr::NOTNULL;    // newArr
1125   fields[argp++] = TypePtr::NOTNULL;    // oldArr
1126   fields[argp++] = TypeInt::INT;        // newIdx
1127   fields[argp++] = TypeInt::INT;        // shiftCount
1128   fields[argp++] = TypeInt::INT;        // numIter
1129   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);
1130   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);
1131 
1132   // no result type needed
1133   fields = TypeTuple::fields(1);
1134   fields[TypeFunc::Parms + 0] = NULL;
1135   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1136   return TypeFunc::make(domain, range);
1137 }
1138 
1139 const TypeFunc* OptoRuntime::vectorizedMismatch_Type() {
1140   // create input type (domain)
1141   int num_args = 4;
1142   int argcnt = num_args;
1143   const Type** fields = TypeTuple::fields(argcnt);
1144   int argp = TypeFunc::Parms;
1145   fields[argp++] = TypePtr::NOTNULL;    // obja
1146   fields[argp++] = TypePtr::NOTNULL;    // objb
1147   fields[argp++] = TypeInt::INT;        // length, number of elements
1148   fields[argp++] = TypeInt::INT;        // log2scale, element size
1149   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);
1150   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);
1151 
1152   //return mismatch index (int)
1153   fields = TypeTuple::fields(1);
1154   fields[TypeFunc::Parms + 0] = TypeInt::INT;
1155   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);
1156   return TypeFunc::make(domain, range);
1157 }
1158 
1159 // GHASH block processing
1160 const TypeFunc* OptoRuntime::ghash_processBlocks_Type() {
1161     int argcnt = 4;
1162 
1163     const Type** fields = TypeTuple::fields(argcnt);
1164     int argp = TypeFunc::Parms;
1165     fields[argp++] = TypePtr::NOTNULL;    // state
1166     fields[argp++] = TypePtr::NOTNULL;    // subkeyH
1167     fields[argp++] = TypePtr::NOTNULL;    // data
1168     fields[argp++] = TypeInt::INT;        // blocks
1169     assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1170     const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1171 
1172     // result type needed
1173     fields = TypeTuple::fields(1);
1174     fields[TypeFunc::Parms+0] = NULL; // void
1175     const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1176     return TypeFunc::make(domain, range);
1177 }
1178 // Base64 encode function
1179 const TypeFunc* OptoRuntime::base64_encodeBlock_Type() {
1180   int argcnt = 6;
1181 
1182   const Type** fields = TypeTuple::fields(argcnt);
1183   int argp = TypeFunc::Parms;
1184   fields[argp++] = TypePtr::NOTNULL;    // src array
1185   fields[argp++] = TypeInt::INT;        // offset
1186   fields[argp++] = TypeInt::INT;        // length
1187   fields[argp++] = TypePtr::NOTNULL;    // dest array
1188   fields[argp++] = TypeInt::INT;       // dp
1189   fields[argp++] = TypeInt::BOOL;       // isURL
1190   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);
1191   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1192 
1193   // result type needed
1194   fields = TypeTuple::fields(1);
1195   fields[TypeFunc::Parms + 0] = NULL; // void
1196   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1197   return TypeFunc::make(domain, range);
1198 }
1199 
1200 //------------- Interpreter state access for on stack replacement
1201 const TypeFunc* OptoRuntime::osr_end_Type() {
1202   // create input type (domain)
1203   const Type **fields = TypeTuple::fields(1);
1204   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM; // OSR temp buf
1205   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
1206 
1207   // create result type
1208   fields = TypeTuple::fields(1);
1209   // fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // locked oop
1210   fields[TypeFunc::Parms+0] = NULL; // void
1211   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);
1212   return TypeFunc::make(domain, range);
1213 }
1214 
1215 //-------------- methodData update helpers
1216 
1217 const TypeFunc* OptoRuntime::profile_receiver_type_Type() {
1218   // create input type (domain)
1219   const Type **fields = TypeTuple::fields(2);
1220   fields[TypeFunc::Parms+0] = TypeAryPtr::NOTNULL;    // methodData pointer
1221   fields[TypeFunc::Parms+1] = TypeInstPtr::BOTTOM;    // receiver oop
1222   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
1223 
1224   // create result type
1225   fields = TypeTuple::fields(1);
1226   fields[TypeFunc::Parms+0] = NULL; // void
1227   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);
1228   return TypeFunc::make(domain, range);
1229 }
1230 
1231 JRT_LEAF(void, OptoRuntime::profile_receiver_type_C(DataLayout* data, oopDesc* receiver))
1232   if (receiver == NULL) return;
1233   Klass* receiver_klass = receiver-&gt;klass();
1234 
1235   intptr_t* mdp = ((intptr_t*)(data)) + DataLayout::header_size_in_cells();
1236   int empty_row = -1;           // free row, if any is encountered
1237 
1238   // ReceiverTypeData* vc = new ReceiverTypeData(mdp);
1239   for (uint row = 0; row &lt; ReceiverTypeData::row_limit(); row++) {
1240     // if (vc-&gt;receiver(row) == receiver_klass)
1241     int receiver_off = ReceiverTypeData::receiver_cell_index(row);
1242     intptr_t row_recv = *(mdp + receiver_off);
1243     if (row_recv == (intptr_t) receiver_klass) {
1244       // vc-&gt;set_receiver_count(row, vc-&gt;receiver_count(row) + DataLayout::counter_increment);
1245       int count_off = ReceiverTypeData::receiver_count_cell_index(row);
1246       *(mdp + count_off) += DataLayout::counter_increment;
1247       return;
1248     } else if (row_recv == 0) {
1249       // else if (vc-&gt;receiver(row) == NULL)
1250       empty_row = (int) row;
1251     }
1252   }
1253 
1254   if (empty_row != -1) {
1255     int receiver_off = ReceiverTypeData::receiver_cell_index(empty_row);
1256     // vc-&gt;set_receiver(empty_row, receiver_klass);
1257     *(mdp + receiver_off) = (intptr_t) receiver_klass;
1258     // vc-&gt;set_receiver_count(empty_row, DataLayout::counter_increment);
1259     int count_off = ReceiverTypeData::receiver_count_cell_index(empty_row);
1260     *(mdp + count_off) = DataLayout::counter_increment;
1261   } else {
1262     // Receiver did not match any saved receiver and there is no empty row for it.
1263     // Increment total counter to indicate polymorphic case.
1264     intptr_t* count_p = (intptr_t*)(((uint8_t*)(data)) + in_bytes(CounterData::count_offset()));
1265     *count_p += DataLayout::counter_increment;
1266   }
1267 JRT_END
1268 
1269 //-------------------------------------------------------------------------------------
1270 // register policy
1271 
1272 bool OptoRuntime::is_callee_saved_register(MachRegisterNumbers reg) {
1273   assert(reg &gt;= 0 &amp;&amp; reg &lt; _last_Mach_Reg, &quot;must be a machine register&quot;);
1274   switch (register_save_policy[reg]) {
1275     case &#39;C&#39;: return false; //SOC
1276     case &#39;E&#39;: return true ; //SOE
1277     case &#39;N&#39;: return false; //NS
1278     case &#39;A&#39;: return false; //AS
1279   }
1280   ShouldNotReachHere();
1281   return false;
1282 }
1283 
1284 //-----------------------------------------------------------------------
1285 // Exceptions
1286 //
1287 
1288 static void trace_exception(outputStream* st, oop exception_oop, address exception_pc, const char* msg);
1289 
1290 // The method is an entry that is always called by a C++ method not
1291 // directly from compiled code. Compiled code will call the C++ method following.
1292 // We can&#39;t allow async exception to be installed during  exception processing.
1293 JRT_ENTRY_NO_ASYNC(address, OptoRuntime::handle_exception_C_helper(JavaThread* thread, nmethod* &amp;nm))
1294 
1295   // Do not confuse exception_oop with pending_exception. The exception_oop
1296   // is only used to pass arguments into the method. Not for general
1297   // exception handling.  DO NOT CHANGE IT to use pending_exception, since
1298   // the runtime stubs checks this on exit.
1299   assert(thread-&gt;exception_oop() != NULL, &quot;exception oop is found&quot;);
1300   address handler_address = NULL;
1301 
1302   Handle exception(thread, thread-&gt;exception_oop());
1303   address pc = thread-&gt;exception_pc();
1304 
1305   // Clear out the exception oop and pc since looking up an
1306   // exception handler can cause class loading, which might throw an
1307   // exception and those fields are expected to be clear during
1308   // normal bytecode execution.
1309   thread-&gt;clear_exception_oop_and_pc();
1310 
1311   LogTarget(Info, exceptions) lt;
1312   if (lt.is_enabled()) {
1313     ResourceMark rm;
1314     LogStream ls(lt);
1315     trace_exception(&amp;ls, exception(), pc, &quot;&quot;);
1316   }
1317 
1318   // for AbortVMOnException flag
1319   Exceptions::debug_check_abort(exception);
1320 
1321 #ifdef ASSERT
1322   if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
1323     // should throw an exception here
1324     ShouldNotReachHere();
1325   }
1326 #endif
1327 
1328   // new exception handling: this method is entered only from adapters
1329   // exceptions from compiled java methods are handled in compiled code
1330   // using rethrow node
1331 
1332   nm = CodeCache::find_nmethod(pc);
1333   assert(nm != NULL, &quot;No NMethod found&quot;);
1334   if (nm-&gt;is_native_method()) {
1335     fatal(&quot;Native method should not have path to exception handling&quot;);
1336   } else {
1337     // we are switching to old paradigm: search for exception handler in caller_frame
1338     // instead in exception handler of caller_frame.sender()
1339 
1340     if (JvmtiExport::can_post_on_exceptions()) {
1341       // &quot;Full-speed catching&quot; is not necessary here,
1342       // since we&#39;re notifying the VM on every catch.
1343       // Force deoptimization and the rest of the lookup
1344       // will be fine.
1345       deoptimize_caller_frame(thread);
1346     }
1347 
1348     // Check the stack guard pages.  If enabled, look for handler in this frame;
1349     // otherwise, forcibly unwind the frame.
1350     //
1351     // 4826555: use default current sp for reguard_stack instead of &amp;nm: it&#39;s more accurate.
1352     bool force_unwind = !thread-&gt;reguard_stack();
1353     bool deopting = false;
1354     if (nm-&gt;is_deopt_pc(pc)) {
1355       deopting = true;
1356       RegisterMap map(thread, false);
1357       frame deoptee = thread-&gt;last_frame().sender(&amp;map);
1358       assert(deoptee.is_deoptimized_frame(), &quot;must be deopted&quot;);
1359       // Adjust the pc back to the original throwing pc
1360       pc = deoptee.pc();
1361     }
1362 
1363     // If we are forcing an unwind because of stack overflow then deopt is
1364     // irrelevant since we are throwing the frame away anyway.
1365 
1366     if (deopting &amp;&amp; !force_unwind) {
1367       handler_address = SharedRuntime::deopt_blob()-&gt;unpack_with_exception();
1368     } else {
1369 
1370       handler_address =
1371         force_unwind ? NULL : nm-&gt;handler_for_exception_and_pc(exception, pc);
1372 
1373       if (handler_address == NULL) {
1374         bool recursive_exception = false;
1375         handler_address = SharedRuntime::compute_compiled_exc_handler(nm, pc, exception, force_unwind, true, recursive_exception);
1376         assert (handler_address != NULL, &quot;must have compiled handler&quot;);
1377         // Update the exception cache only when the unwind was not forced
1378         // and there didn&#39;t happen another exception during the computation of the
1379         // compiled exception handler. Checking for exception oop equality is not
1380         // sufficient because some exceptions are pre-allocated and reused.
1381         if (!force_unwind &amp;&amp; !recursive_exception) {
1382           nm-&gt;add_handler_for_exception_and_pc(exception,pc,handler_address);
1383         }
1384       } else {
1385 #ifdef ASSERT
1386         bool recursive_exception = false;
1387         address computed_address = SharedRuntime::compute_compiled_exc_handler(nm, pc, exception, force_unwind, true, recursive_exception);
1388         vmassert(recursive_exception || (handler_address == computed_address), &quot;Handler address inconsistency: &quot; PTR_FORMAT &quot; != &quot; PTR_FORMAT,
1389                  p2i(handler_address), p2i(computed_address));
1390 #endif
1391       }
1392     }
1393 
1394     thread-&gt;set_exception_pc(pc);
1395     thread-&gt;set_exception_handler_pc(handler_address);
1396 
1397     // Check if the exception PC is a MethodHandle call site.
1398     thread-&gt;set_is_method_handle_return(nm-&gt;is_method_handle_return(pc));
1399   }
1400 
1401   // Restore correct return pc.  Was saved above.
1402   thread-&gt;set_exception_oop(exception());
1403   return handler_address;
1404 
1405 JRT_END
1406 
1407 // We are entering here from exception_blob
1408 // If there is a compiled exception handler in this method, we will continue there;
1409 // otherwise we will unwind the stack and continue at the caller of top frame method
1410 // Note we enter without the usual JRT wrapper. We will call a helper routine that
1411 // will do the normal VM entry. We do it this way so that we can see if the nmethod
1412 // we looked up the handler for has been deoptimized in the meantime. If it has been
1413 // we must not use the handler and instead return the deopt blob.
1414 address OptoRuntime::handle_exception_C(JavaThread* thread) {
1415 //
1416 // We are in Java not VM and in debug mode we have a NoHandleMark
1417 //
1418 #ifndef PRODUCT
1419   SharedRuntime::_find_handler_ctr++;          // find exception handler
1420 #endif
1421   debug_only(NoHandleMark __hm;)
1422   nmethod* nm = NULL;
1423   address handler_address = NULL;
1424   {
1425     // Enter the VM
1426 
1427     ResetNoHandleMark rnhm;
1428     handler_address = handle_exception_C_helper(thread, nm);
1429   }
1430 
1431   // Back in java: Use no oops, DON&#39;T safepoint
1432 
1433   // Now check to see if the handler we are returning is in a now
1434   // deoptimized frame
1435 
1436   if (nm != NULL) {
1437     RegisterMap map(thread, false);
1438     frame caller = thread-&gt;last_frame().sender(&amp;map);
1439 #ifdef ASSERT
1440     assert(caller.is_compiled_frame(), &quot;must be&quot;);
1441 #endif // ASSERT
1442     if (caller.is_deoptimized_frame()) {
1443       handler_address = SharedRuntime::deopt_blob()-&gt;unpack_with_exception();
1444     }
1445   }
1446   return handler_address;
1447 }
1448 
1449 //------------------------------rethrow----------------------------------------
1450 // We get here after compiled code has executed a &#39;RethrowNode&#39;.  The callee
1451 // is either throwing or rethrowing an exception.  The callee-save registers
1452 // have been restored, synchronized objects have been unlocked and the callee
1453 // stack frame has been removed.  The return address was passed in.
1454 // Exception oop is passed as the 1st argument.  This routine is then called
1455 // from the stub.  On exit, we know where to jump in the caller&#39;s code.
1456 // After this C code exits, the stub will pop his frame and end in a jump
1457 // (instead of a return).  We enter the caller&#39;s default handler.
1458 //
1459 // This must be JRT_LEAF:
1460 //     - caller will not change its state as we cannot block on exit,
1461 //       therefore raw_exception_handler_for_return_address is all it takes
1462 //       to handle deoptimized blobs
1463 //
1464 // However, there needs to be a safepoint check in the middle!  So compiled
1465 // safepoints are completely watertight.
1466 //
1467 // Thus, it cannot be a leaf since it contains the NoSafepointVerifier.
1468 //
1469 // *THIS IS NOT RECOMMENDED PROGRAMMING STYLE*
1470 //
1471 address OptoRuntime::rethrow_C(oopDesc* exception, JavaThread* thread, address ret_pc) {
1472 #ifndef PRODUCT
1473   SharedRuntime::_rethrow_ctr++;               // count rethrows
1474 #endif
1475   assert (exception != NULL, &quot;should have thrown a NULLPointerException&quot;);
1476 #ifdef ASSERT
1477   if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
1478     // should throw an exception here
1479     ShouldNotReachHere();
1480   }
1481 #endif
1482 
1483   thread-&gt;set_vm_result(exception);
1484   // Frame not compiled (handles deoptimization blob)
1485   return SharedRuntime::raw_exception_handler_for_return_address(thread, ret_pc);
1486 }
1487 
1488 
1489 const TypeFunc *OptoRuntime::rethrow_Type() {
1490   // create input type (domain)
1491   const Type **fields = TypeTuple::fields(1);
1492   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // Exception oop
1493   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1,fields);
1494 
1495   // create result type (range)
1496   fields = TypeTuple::fields(1);
1497   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // Exception oop
1498   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
1499 
1500   return TypeFunc::make(domain, range);
1501 }
1502 
1503 
1504 void OptoRuntime::deoptimize_caller_frame(JavaThread *thread, bool doit) {
1505   // Deoptimize the caller before continuing, as the compiled
1506   // exception handler table may not be valid.
1507   if (!StressCompiledExceptionHandlers &amp;&amp; doit) {
1508     deoptimize_caller_frame(thread);
1509   }
1510 }
1511 
1512 void OptoRuntime::deoptimize_caller_frame(JavaThread *thread) {
1513   // Called from within the owner thread, so no need for safepoint
1514   RegisterMap reg_map(thread);
1515   frame stub_frame = thread-&gt;last_frame();
1516   assert(stub_frame.is_runtime_frame() || exception_blob()-&gt;contains(stub_frame.pc()), &quot;sanity check&quot;);
1517   frame caller_frame = stub_frame.sender(&amp;reg_map);
1518 
1519   // Deoptimize the caller frame.
1520   Deoptimization::deoptimize_frame(thread, caller_frame.id());
1521 }
1522 
1523 
1524 bool OptoRuntime::is_deoptimized_caller_frame(JavaThread *thread) {
1525   // Called from within the owner thread, so no need for safepoint
1526   RegisterMap reg_map(thread);
1527   frame stub_frame = thread-&gt;last_frame();
1528   assert(stub_frame.is_runtime_frame() || exception_blob()-&gt;contains(stub_frame.pc()), &quot;sanity check&quot;);
1529   frame caller_frame = stub_frame.sender(&amp;reg_map);
1530   return caller_frame.is_deoptimized_frame();
1531 }
1532 
1533 
1534 const TypeFunc *OptoRuntime::register_finalizer_Type() {
1535   // create input type (domain)
1536   const Type **fields = TypeTuple::fields(1);
1537   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;  // oop;          Receiver
1538   // // The JavaThread* is passed to each routine as the last argument
1539   // fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL;  // JavaThread *; Executing thread
1540   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1,fields);
1541 
1542   // create result type (range)
1543   fields = TypeTuple::fields(0);
1544 
1545   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0,fields);
1546 
1547   return TypeFunc::make(domain, range);
1548 }
1549 
1550 
1551 //-----------------------------------------------------------------------------
1552 // Dtrace support.  entry and exit probes have the same signature
1553 const TypeFunc *OptoRuntime::dtrace_method_entry_exit_Type() {
1554   // create input type (domain)
1555   const Type **fields = TypeTuple::fields(2);
1556   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM; // Thread-local storage
1557   fields[TypeFunc::Parms+1] = TypeMetadataPtr::BOTTOM;  // Method*;    Method we are entering
1558   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2,fields);
1559 
1560   // create result type (range)
1561   fields = TypeTuple::fields(0);
1562 
1563   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0,fields);
1564 
1565   return TypeFunc::make(domain, range);
1566 }
1567 
1568 const TypeFunc *OptoRuntime::dtrace_object_alloc_Type() {
1569   // create input type (domain)
1570   const Type **fields = TypeTuple::fields(2);
1571   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM; // Thread-local storage
1572   fields[TypeFunc::Parms+1] = TypeInstPtr::NOTNULL;  // oop;    newly allocated object
1573 
1574   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2,fields);
1575 
1576   // create result type (range)
1577   fields = TypeTuple::fields(0);
1578 
1579   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0,fields);
1580 
1581   return TypeFunc::make(domain, range);
1582 }
1583 
1584 
1585 JRT_ENTRY_NO_ASYNC(void, OptoRuntime::register_finalizer(oopDesc* obj, JavaThread* thread))
1586   assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
1587   assert(obj-&gt;klass()-&gt;has_finalizer(), &quot;shouldn&#39;t be here otherwise&quot;);
1588   InstanceKlass::register_finalizer(instanceOop(obj), CHECK);
1589 JRT_END
1590 
1591 //-----------------------------------------------------------------------------
1592 
1593 NamedCounter * volatile OptoRuntime::_named_counters = NULL;
1594 
1595 //
1596 // dump the collected NamedCounters.
1597 //
1598 void OptoRuntime::print_named_counters() {
1599   int total_lock_count = 0;
1600   int eliminated_lock_count = 0;
1601 
1602   NamedCounter* c = _named_counters;
1603   while (c) {
1604     if (c-&gt;tag() == NamedCounter::LockCounter || c-&gt;tag() == NamedCounter::EliminatedLockCounter) {
1605       int count = c-&gt;count();
1606       if (count &gt; 0) {
1607         bool eliminated = c-&gt;tag() == NamedCounter::EliminatedLockCounter;
1608         if (Verbose) {
1609           tty-&gt;print_cr(&quot;%d %s%s&quot;, count, c-&gt;name(), eliminated ? &quot; (eliminated)&quot; : &quot;&quot;);
1610         }
1611         total_lock_count += count;
1612         if (eliminated) {
1613           eliminated_lock_count += count;
1614         }
1615       }
1616     } else if (c-&gt;tag() == NamedCounter::BiasedLockingCounter) {
1617       BiasedLockingCounters* blc = ((BiasedLockingNamedCounter*)c)-&gt;counters();
1618       if (blc-&gt;nonzero()) {
1619         tty-&gt;print_cr(&quot;%s&quot;, c-&gt;name());
1620         blc-&gt;print_on(tty);
1621       }
1622 #if INCLUDE_RTM_OPT
1623     } else if (c-&gt;tag() == NamedCounter::RTMLockingCounter) {
1624       RTMLockingCounters* rlc = ((RTMLockingNamedCounter*)c)-&gt;counters();
1625       if (rlc-&gt;nonzero()) {
1626         tty-&gt;print_cr(&quot;%s&quot;, c-&gt;name());
1627         rlc-&gt;print_on(tty);
1628       }
1629 #endif
1630     }
1631     c = c-&gt;next();
1632   }
1633   if (total_lock_count &gt; 0) {
1634     tty-&gt;print_cr(&quot;dynamic locks: %d&quot;, total_lock_count);
1635     if (eliminated_lock_count) {
1636       tty-&gt;print_cr(&quot;eliminated locks: %d (%d%%)&quot;, eliminated_lock_count,
1637                     (int)(eliminated_lock_count * 100.0 / total_lock_count));
1638     }
1639   }
1640 }
1641 
1642 //
1643 //  Allocate a new NamedCounter.  The JVMState is used to generate the
1644 //  name which consists of method@line for the inlining tree.
1645 //
1646 
1647 NamedCounter* OptoRuntime::new_named_counter(JVMState* youngest_jvms, NamedCounter::CounterTag tag) {
1648   int max_depth = youngest_jvms-&gt;depth();
1649 
1650   // Visit scopes from youngest to oldest.
1651   bool first = true;
1652   stringStream st;
1653   for (int depth = max_depth; depth &gt;= 1; depth--) {
1654     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
1655     ciMethod* m = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
1656     if (!first) {
1657       st.print(&quot; &quot;);
1658     } else {
1659       first = false;
1660     }
1661     int bci = jvms-&gt;bci();
1662     if (bci &lt; 0) bci = 0;
1663     if (m != NULL) {
1664       st.print(&quot;%s.%s&quot;, m-&gt;holder()-&gt;name()-&gt;as_utf8(), m-&gt;name()-&gt;as_utf8());
1665     } else {
1666       st.print(&quot;no method&quot;);
1667     }
1668     st.print(&quot;@%d&quot;, bci);
1669     // To print linenumbers instead of bci use: m-&gt;line_number_from_bci(bci)
1670   }
1671   NamedCounter* c;
1672   if (tag == NamedCounter::BiasedLockingCounter) {
1673     c = new BiasedLockingNamedCounter(st.as_string());
1674   } else if (tag == NamedCounter::RTMLockingCounter) {
1675     c = new RTMLockingNamedCounter(st.as_string());
1676   } else {
1677     c = new NamedCounter(st.as_string(), tag);
1678   }
1679 
1680   // atomically add the new counter to the head of the list.  We only
1681   // add counters so this is safe.
1682   NamedCounter* head;
1683   do {
1684     c-&gt;set_next(NULL);
1685     head = _named_counters;
1686     c-&gt;set_next(head);
1687   } while (Atomic::cmpxchg(&amp;_named_counters, head, c) != head);
1688   return c;
1689 }
1690 
1691 int trace_exception_counter = 0;
1692 static void trace_exception(outputStream* st, oop exception_oop, address exception_pc, const char* msg) {
1693   trace_exception_counter++;
1694   stringStream tempst;
1695 
1696   tempst.print(&quot;%d [Exception (%s): &quot;, trace_exception_counter, msg);
1697   exception_oop-&gt;print_value_on(&amp;tempst);
1698   tempst.print(&quot; in &quot;);
1699   CodeBlob* blob = CodeCache::find_blob(exception_pc);
1700   if (blob-&gt;is_compiled()) {
1701     CompiledMethod* cm = blob-&gt;as_compiled_method_or_null();
1702     cm-&gt;method()-&gt;print_value_on(&amp;tempst);
1703   } else if (blob-&gt;is_runtime_stub()) {
1704     tempst.print(&quot;&lt;runtime-stub&gt;&quot;);
1705   } else {
1706     tempst.print(&quot;&lt;unknown&gt;&quot;);
1707   }
1708   tempst.print(&quot; at &quot; INTPTR_FORMAT,  p2i(exception_pc));
1709   tempst.print(&quot;]&quot;);
1710 
1711   st-&gt;print_raw_cr(tempst.as_string());
1712 }
1713 
1714 const TypeFunc *OptoRuntime::store_value_type_fields_Type() {
1715   // create input type (domain)
1716   uint total = SharedRuntime::java_return_convention_max_int + SharedRuntime::java_return_convention_max_float*2;
1717   const Type **fields = TypeTuple::fields(total);
1718   // We don&#39;t know the number of returned values and their
1719   // types. Assume all registers available to the return convention
1720   // are used.
1721   fields[TypeFunc::Parms] = TypePtr::BOTTOM;
1722   uint i = 1;
1723   for (; i &lt; SharedRuntime::java_return_convention_max_int; i++) {
1724     fields[TypeFunc::Parms+i] = TypeInt::INT;
1725   }
1726   for (; i &lt; total; i+=2) {
1727     fields[TypeFunc::Parms+i] = Type::DOUBLE;
1728     fields[TypeFunc::Parms+i+1] = Type::HALF;
1729   }
1730   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + total, fields);
1731 
1732   // create result type (range)
1733   fields = TypeTuple::fields(1);
1734   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;
1735 
1736   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1,fields);
1737 
1738   return TypeFunc::make(domain, range);
1739 }
1740 
1741 const TypeFunc *OptoRuntime::pack_value_type_Type() {
1742   // create input type (domain)
1743   uint total = 1 + SharedRuntime::java_return_convention_max_int + SharedRuntime::java_return_convention_max_float*2;
1744   const Type **fields = TypeTuple::fields(total);
1745   // We don&#39;t know the number of returned values and their
1746   // types. Assume all registers available to the return convention
1747   // are used.
1748   fields[TypeFunc::Parms] = TypeRawPtr::BOTTOM;
1749   fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM;
1750   uint i = 2;
1751   for (; i &lt; SharedRuntime::java_return_convention_max_int+1; i++) {
1752     fields[TypeFunc::Parms+i] = TypeInt::INT;
1753   }
1754   for (; i &lt; total; i+=2) {
1755     fields[TypeFunc::Parms+i] = Type::DOUBLE;
1756     fields[TypeFunc::Parms+i+1] = Type::HALF;
1757   }
1758   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + total, fields);
1759 
1760   // create result type (range)
1761   fields = TypeTuple::fields(1);
1762   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;
1763 
1764   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1,fields);
1765 
1766   return TypeFunc::make(domain, range);
1767 }
1768 
1769 JRT_LEAF(void, OptoRuntime::load_unknown_value(valueArrayOopDesc* array, int index, instanceOopDesc* buffer))
1770 {
1771   array-&gt;value_copy_from_index(index, buffer);
1772 }
1773 JRT_END
1774 
1775 const TypeFunc *OptoRuntime::load_unknown_value_Type() {
1776   // create input type (domain)
1777   const Type **fields = TypeTuple::fields(3);
1778   // We don&#39;t know the number of returned values and their
1779   // types. Assume all registers available to the return convention
1780   // are used.
1781   fields[TypeFunc::Parms] = TypeOopPtr::NOTNULL;
1782   fields[TypeFunc::Parms+1] = TypeInt::POS;
1783   fields[TypeFunc::Parms+2] = TypeInstPtr::NOTNULL;
1784 
1785   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+3, fields);
1786 
1787   // create result type (range)
1788   fields = TypeTuple::fields(0);
1789   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
1790 
1791   return TypeFunc::make(domain, range);
1792 }
1793 
1794 JRT_LEAF(void, OptoRuntime::store_unknown_value(instanceOopDesc* buffer, valueArrayOopDesc* array, int index))
1795 {
1796   assert(buffer != NULL, &quot;can&#39;t store null into flat array&quot;);
1797   array-&gt;value_copy_to_index(buffer, index);
1798 }
1799 JRT_END
1800 
1801 const TypeFunc *OptoRuntime::store_unknown_value_Type() {
1802   // create input type (domain)
1803   const Type **fields = TypeTuple::fields(3);
1804   // We don&#39;t know the number of returned values and their
1805   // types. Assume all registers available to the return convention
1806   // are used.
1807   fields[TypeFunc::Parms] = TypeInstPtr::NOTNULL;
1808   fields[TypeFunc::Parms+1] = TypeOopPtr::NOTNULL;
1809   fields[TypeFunc::Parms+2] = TypeInt::POS;
1810 
1811   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+3, fields);
1812 
1813   // create result type (range)
1814   fields = TypeTuple::fields(0);
1815   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
1816 
1817   return TypeFunc::make(domain, range);
1818 }
    </pre>
  </body>
</html>
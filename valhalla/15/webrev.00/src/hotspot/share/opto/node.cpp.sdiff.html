<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/node.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="matcher.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="node.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/node.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1616   return result;
1617 }
1618 #endif
1619 
1620 
1621 
1622 #ifndef PRODUCT
1623 
1624 // -----------------------------Name-------------------------------------------
1625 extern const char *NodeClassNames[];
1626 const char *Node::Name() const { return NodeClassNames[Opcode()]; }
1627 
1628 static bool is_disconnected(const Node* n) {
1629   for (uint i = 0; i &lt; n-&gt;req(); i++) {
1630     if (n-&gt;in(i) != NULL)  return false;
1631   }
1632   return true;
1633 }
1634 
1635 #ifdef ASSERT
<span class="line-modified">1636 static void dump_orig(Node* orig, outputStream *st) {</span>
1637   Compile* C = Compile::current();

1638   if (NotANode(orig)) orig = NULL;
1639   if (orig != NULL &amp;&amp; !C-&gt;node_arena()-&gt;contains(orig)) orig = NULL;
1640   if (orig == NULL) return;
<span class="line-modified">1641   st-&gt;print(&quot; !orig=&quot;);</span>


1642   Node* fast = orig-&gt;debug_orig(); // tortoise &amp; hare algorithm to detect loops
1643   if (NotANode(fast)) fast = NULL;
1644   while (orig != NULL) {
1645     bool discon = is_disconnected(orig);  // if discon, print [123] else 123
1646     if (discon) st-&gt;print(&quot;[&quot;);
1647     if (!Compile::current()-&gt;node_arena()-&gt;contains(orig))
1648       st-&gt;print(&quot;o&quot;);
1649     st-&gt;print(&quot;%d&quot;, orig-&gt;_idx);
1650     if (discon) st-&gt;print(&quot;]&quot;);
1651     orig = orig-&gt;debug_orig();
1652     if (NotANode(orig)) orig = NULL;
1653     if (orig != NULL &amp;&amp; !C-&gt;node_arena()-&gt;contains(orig)) orig = NULL;
1654     if (orig != NULL) st-&gt;print(&quot;,&quot;);
1655     if (fast != NULL) {
1656       // Step fast twice for each single step of orig:
1657       fast = fast-&gt;debug_orig();
1658       if (NotANode(fast)) fast = NULL;
1659       if (fast != NULL &amp;&amp; fast != orig) {
1660         fast = fast-&gt;debug_orig();
1661         if (NotANode(fast)) fast = NULL;
</pre>
<hr />
<pre>
1686 }
1687 #endif //ASSERT
1688 
1689 //------------------------------dump------------------------------------------
1690 // Dump a Node
1691 void Node::dump(const char* suffix, bool mark, outputStream *st) const {
1692   Compile* C = Compile::current();
1693   bool is_new = C-&gt;node_arena()-&gt;contains(this);
1694   C-&gt;_in_dump_cnt++;
1695   st-&gt;print(&quot;%c%d%s\t%s\t=== &quot;, is_new ? &#39; &#39; : &#39;o&#39;, _idx, mark ? &quot; &gt;&quot; : &quot;&quot;, Name());
1696 
1697   // Dump the required and precedence inputs
1698   dump_req(st);
1699   dump_prec(st);
1700   // Dump the outputs
1701   dump_out(st);
1702 
1703   if (is_disconnected(this)) {
1704 #ifdef ASSERT
1705     st-&gt;print(&quot;  [%d]&quot;,debug_idx());
<span class="line-modified">1706     dump_orig(debug_orig(), st);</span>
1707 #endif
1708     st-&gt;cr();
1709     C-&gt;_in_dump_cnt--;
1710     return;                     // don&#39;t process dead nodes
1711   }
1712 
1713   if (C-&gt;clone_map().value(_idx) != 0) {
1714     C-&gt;clone_map().dump(_idx);
1715   }
1716   // Dump node-specific info
1717   dump_spec(st);
1718 #ifdef ASSERT
1719   // Dump the non-reset _debug_idx
1720   if (Verbose &amp;&amp; WizardMode) {
1721     st-&gt;print(&quot;  [%d]&quot;,debug_idx());
1722   }
1723 #endif
1724 
1725   const Type *t = bottom_type();
1726 
</pre>
<hr />
<pre>
1734       st-&gt;print(&quot;  Oop:&quot;);
1735     } else if (tkls) {
1736       st-&gt;print(&quot;  Klass:&quot;);
1737     }
1738     t-&gt;dump_on(st);
1739   } else if (t == Type::MEMORY) {
1740     st-&gt;print(&quot;  Memory:&quot;);
1741     MemNode::dump_adr_type(this, adr_type(), st);
1742   } else if (Verbose || WizardMode) {
1743     st-&gt;print(&quot;  Type:&quot;);
1744     if (t) {
1745       t-&gt;dump_on(st);
1746     } else {
1747       st-&gt;print(&quot;no type&quot;);
1748     }
1749   } else if (t-&gt;isa_vect() &amp;&amp; this-&gt;is_MachSpillCopy()) {
1750     // Dump MachSpillcopy vector type.
1751     t-&gt;dump_on(st);
1752   }
1753   if (is_new) {
<span class="line-modified">1754     debug_only(dump_orig(debug_orig(), st));</span>
1755     Node_Notes* nn = C-&gt;node_notes_at(_idx);
1756     if (nn != NULL &amp;&amp; !nn-&gt;is_clear()) {
1757       if (nn-&gt;jvms() != NULL) {
1758         st-&gt;print(&quot; !jvms:&quot;);
1759         nn-&gt;jvms()-&gt;dump_spec(st);
1760       }
1761     }
1762   }
1763   if (suffix) st-&gt;print(&quot;%s&quot;, suffix);
1764   C-&gt;_in_dump_cnt--;
1765 }
1766 
1767 //------------------------------dump_req--------------------------------------
1768 void Node::dump_req(outputStream *st) const {
1769   // Dump the required input edges
1770   for (uint i = 0; i &lt; req(); i++) {    // For all required inputs
1771     Node* d = in(i);
1772     if (d == NULL) {
1773       st-&gt;print(&quot;_ &quot;);
1774     } else if (NotANode(d)) {
</pre>
</td>
<td>
<hr />
<pre>
1616   return result;
1617 }
1618 #endif
1619 
1620 
1621 
1622 #ifndef PRODUCT
1623 
1624 // -----------------------------Name-------------------------------------------
1625 extern const char *NodeClassNames[];
1626 const char *Node::Name() const { return NodeClassNames[Opcode()]; }
1627 
1628 static bool is_disconnected(const Node* n) {
1629   for (uint i = 0; i &lt; n-&gt;req(); i++) {
1630     if (n-&gt;in(i) != NULL)  return false;
1631   }
1632   return true;
1633 }
1634 
1635 #ifdef ASSERT
<span class="line-modified">1636 void Node::dump_orig(outputStream *st, bool print_key) const {</span>
1637   Compile* C = Compile::current();
<span class="line-added">1638   Node* orig = _debug_orig;</span>
1639   if (NotANode(orig)) orig = NULL;
1640   if (orig != NULL &amp;&amp; !C-&gt;node_arena()-&gt;contains(orig)) orig = NULL;
1641   if (orig == NULL) return;
<span class="line-modified">1642   if (print_key) {</span>
<span class="line-added">1643     st-&gt;print(&quot; !orig=&quot;);</span>
<span class="line-added">1644   }</span>
1645   Node* fast = orig-&gt;debug_orig(); // tortoise &amp; hare algorithm to detect loops
1646   if (NotANode(fast)) fast = NULL;
1647   while (orig != NULL) {
1648     bool discon = is_disconnected(orig);  // if discon, print [123] else 123
1649     if (discon) st-&gt;print(&quot;[&quot;);
1650     if (!Compile::current()-&gt;node_arena()-&gt;contains(orig))
1651       st-&gt;print(&quot;o&quot;);
1652     st-&gt;print(&quot;%d&quot;, orig-&gt;_idx);
1653     if (discon) st-&gt;print(&quot;]&quot;);
1654     orig = orig-&gt;debug_orig();
1655     if (NotANode(orig)) orig = NULL;
1656     if (orig != NULL &amp;&amp; !C-&gt;node_arena()-&gt;contains(orig)) orig = NULL;
1657     if (orig != NULL) st-&gt;print(&quot;,&quot;);
1658     if (fast != NULL) {
1659       // Step fast twice for each single step of orig:
1660       fast = fast-&gt;debug_orig();
1661       if (NotANode(fast)) fast = NULL;
1662       if (fast != NULL &amp;&amp; fast != orig) {
1663         fast = fast-&gt;debug_orig();
1664         if (NotANode(fast)) fast = NULL;
</pre>
<hr />
<pre>
1689 }
1690 #endif //ASSERT
1691 
1692 //------------------------------dump------------------------------------------
1693 // Dump a Node
1694 void Node::dump(const char* suffix, bool mark, outputStream *st) const {
1695   Compile* C = Compile::current();
1696   bool is_new = C-&gt;node_arena()-&gt;contains(this);
1697   C-&gt;_in_dump_cnt++;
1698   st-&gt;print(&quot;%c%d%s\t%s\t=== &quot;, is_new ? &#39; &#39; : &#39;o&#39;, _idx, mark ? &quot; &gt;&quot; : &quot;&quot;, Name());
1699 
1700   // Dump the required and precedence inputs
1701   dump_req(st);
1702   dump_prec(st);
1703   // Dump the outputs
1704   dump_out(st);
1705 
1706   if (is_disconnected(this)) {
1707 #ifdef ASSERT
1708     st-&gt;print(&quot;  [%d]&quot;,debug_idx());
<span class="line-modified">1709     dump_orig(st);</span>
1710 #endif
1711     st-&gt;cr();
1712     C-&gt;_in_dump_cnt--;
1713     return;                     // don&#39;t process dead nodes
1714   }
1715 
1716   if (C-&gt;clone_map().value(_idx) != 0) {
1717     C-&gt;clone_map().dump(_idx);
1718   }
1719   // Dump node-specific info
1720   dump_spec(st);
1721 #ifdef ASSERT
1722   // Dump the non-reset _debug_idx
1723   if (Verbose &amp;&amp; WizardMode) {
1724     st-&gt;print(&quot;  [%d]&quot;,debug_idx());
1725   }
1726 #endif
1727 
1728   const Type *t = bottom_type();
1729 
</pre>
<hr />
<pre>
1737       st-&gt;print(&quot;  Oop:&quot;);
1738     } else if (tkls) {
1739       st-&gt;print(&quot;  Klass:&quot;);
1740     }
1741     t-&gt;dump_on(st);
1742   } else if (t == Type::MEMORY) {
1743     st-&gt;print(&quot;  Memory:&quot;);
1744     MemNode::dump_adr_type(this, adr_type(), st);
1745   } else if (Verbose || WizardMode) {
1746     st-&gt;print(&quot;  Type:&quot;);
1747     if (t) {
1748       t-&gt;dump_on(st);
1749     } else {
1750       st-&gt;print(&quot;no type&quot;);
1751     }
1752   } else if (t-&gt;isa_vect() &amp;&amp; this-&gt;is_MachSpillCopy()) {
1753     // Dump MachSpillcopy vector type.
1754     t-&gt;dump_on(st);
1755   }
1756   if (is_new) {
<span class="line-modified">1757     DEBUG_ONLY(dump_orig(st));</span>
1758     Node_Notes* nn = C-&gt;node_notes_at(_idx);
1759     if (nn != NULL &amp;&amp; !nn-&gt;is_clear()) {
1760       if (nn-&gt;jvms() != NULL) {
1761         st-&gt;print(&quot; !jvms:&quot;);
1762         nn-&gt;jvms()-&gt;dump_spec(st);
1763       }
1764     }
1765   }
1766   if (suffix) st-&gt;print(&quot;%s&quot;, suffix);
1767   C-&gt;_in_dump_cnt--;
1768 }
1769 
1770 //------------------------------dump_req--------------------------------------
1771 void Node::dump_req(outputStream *st) const {
1772   // Dump the required input edges
1773   for (uint i = 0; i &lt; req(); i++) {    // For all required inputs
1774     Node* d = in(i);
1775     if (d == NULL) {
1776       st-&gt;print(&quot;_ &quot;);
1777     } else if (NotANode(d)) {
</pre>
</td>
</tr>
</table>
<center><a href="matcher.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="node.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
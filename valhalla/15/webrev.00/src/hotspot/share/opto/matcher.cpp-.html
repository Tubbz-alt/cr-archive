<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/matcher.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;oops/compressedOops.hpp&quot;
  31 #include &quot;opto/ad.hpp&quot;
  32 #include &quot;opto/addnode.hpp&quot;
  33 #include &quot;opto/callnode.hpp&quot;
  34 #include &quot;opto/idealGraphPrinter.hpp&quot;
  35 #include &quot;opto/matcher.hpp&quot;
  36 #include &quot;opto/memnode.hpp&quot;
  37 #include &quot;opto/movenode.hpp&quot;
  38 #include &quot;opto/opcodes.hpp&quot;
  39 #include &quot;opto/regmask.hpp&quot;
  40 #include &quot;opto/rootnode.hpp&quot;
  41 #include &quot;opto/runtime.hpp&quot;
  42 #include &quot;opto/type.hpp&quot;
  43 #include &quot;opto/vectornode.hpp&quot;
  44 #include &quot;runtime/os.hpp&quot;
  45 #include &quot;runtime/sharedRuntime.hpp&quot;
  46 #include &quot;utilities/align.hpp&quot;
  47 
  48 OptoReg::Name OptoReg::c_frame_pointer;
  49 
  50 const RegMask *Matcher::idealreg2regmask[_last_machine_leaf];
  51 RegMask Matcher::mreg2regmask[_last_Mach_Reg];
  52 RegMask Matcher::STACK_ONLY_mask;
  53 RegMask Matcher::c_frame_ptr_mask;
  54 const uint Matcher::_begin_rematerialize = _BEGIN_REMATERIALIZE;
  55 const uint Matcher::_end_rematerialize   = _END_REMATERIALIZE;
  56 
  57 //---------------------------Matcher-------------------------------------------
  58 Matcher::Matcher()
  59 : PhaseTransform( Phase::Ins_Select ),
  60   _states_arena(Chunk::medium_size, mtCompiler),
  61   _visited(&amp;_states_arena),
  62   _shared(&amp;_states_arena),
  63   _dontcare(&amp;_states_arena),
  64   _reduceOp(reduceOp), _leftOp(leftOp), _rightOp(rightOp),
  65   _swallowed(swallowed),
  66   _begin_inst_chain_rule(_BEGIN_INST_CHAIN_RULE),
  67   _end_inst_chain_rule(_END_INST_CHAIN_RULE),
  68   _must_clone(must_clone),
  69   _shared_nodes(C-&gt;comp_arena()),
  70 #ifdef ASSERT
  71   _old2new_map(C-&gt;comp_arena()),
  72   _new2old_map(C-&gt;comp_arena()),
  73 #endif
  74   _allocation_started(false),
  75   _ruleName(ruleName),
  76   _register_save_policy(register_save_policy),
  77   _c_reg_save_policy(c_reg_save_policy),
  78   _register_save_type(register_save_type) {
  79   C-&gt;set_matcher(this);
  80 
  81   idealreg2spillmask  [Op_RegI] = NULL;
  82   idealreg2spillmask  [Op_RegN] = NULL;
  83   idealreg2spillmask  [Op_RegL] = NULL;
  84   idealreg2spillmask  [Op_RegF] = NULL;
  85   idealreg2spillmask  [Op_RegD] = NULL;
  86   idealreg2spillmask  [Op_RegP] = NULL;
  87   idealreg2spillmask  [Op_VecS] = NULL;
  88   idealreg2spillmask  [Op_VecD] = NULL;
  89   idealreg2spillmask  [Op_VecX] = NULL;
  90   idealreg2spillmask  [Op_VecY] = NULL;
  91   idealreg2spillmask  [Op_VecZ] = NULL;
  92   idealreg2spillmask  [Op_RegFlags] = NULL;
  93 
  94   idealreg2debugmask  [Op_RegI] = NULL;
  95   idealreg2debugmask  [Op_RegN] = NULL;
  96   idealreg2debugmask  [Op_RegL] = NULL;
  97   idealreg2debugmask  [Op_RegF] = NULL;
  98   idealreg2debugmask  [Op_RegD] = NULL;
  99   idealreg2debugmask  [Op_RegP] = NULL;
 100   idealreg2debugmask  [Op_VecS] = NULL;
 101   idealreg2debugmask  [Op_VecD] = NULL;
 102   idealreg2debugmask  [Op_VecX] = NULL;
 103   idealreg2debugmask  [Op_VecY] = NULL;
 104   idealreg2debugmask  [Op_VecZ] = NULL;
 105   idealreg2debugmask  [Op_RegFlags] = NULL;
 106 
 107   idealreg2mhdebugmask[Op_RegI] = NULL;
 108   idealreg2mhdebugmask[Op_RegN] = NULL;
 109   idealreg2mhdebugmask[Op_RegL] = NULL;
 110   idealreg2mhdebugmask[Op_RegF] = NULL;
 111   idealreg2mhdebugmask[Op_RegD] = NULL;
 112   idealreg2mhdebugmask[Op_RegP] = NULL;
 113   idealreg2mhdebugmask[Op_VecS] = NULL;
 114   idealreg2mhdebugmask[Op_VecD] = NULL;
 115   idealreg2mhdebugmask[Op_VecX] = NULL;
 116   idealreg2mhdebugmask[Op_VecY] = NULL;
 117   idealreg2mhdebugmask[Op_VecZ] = NULL;
 118   idealreg2mhdebugmask[Op_RegFlags] = NULL;
 119 
 120   debug_only(_mem_node = NULL;)   // Ideal memory node consumed by mach node
 121 }
 122 
 123 //------------------------------warp_incoming_stk_arg------------------------
 124 // This warps a VMReg into an OptoReg::Name
 125 OptoReg::Name Matcher::warp_incoming_stk_arg( VMReg reg ) {
 126   OptoReg::Name warped;
 127   if( reg-&gt;is_stack() ) {  // Stack slot argument?
 128     warped = OptoReg::add(_old_SP, reg-&gt;reg2stack() );
 129     warped = OptoReg::add(warped, C-&gt;out_preserve_stack_slots());
 130     if( warped &gt;= _in_arg_limit )
 131       _in_arg_limit = OptoReg::add(warped, 1); // Bump max stack slot seen
 132     if (!RegMask::can_represent_arg(warped)) {
 133       // the compiler cannot represent this method&#39;s calling sequence
 134       C-&gt;record_method_not_compilable(&quot;unsupported incoming calling sequence&quot;);
 135       return OptoReg::Bad;
 136     }
 137     return warped;
 138   }
 139   return OptoReg::as_OptoReg(reg);
 140 }
 141 
 142 //---------------------------compute_old_SP------------------------------------
 143 OptoReg::Name Compile::compute_old_SP() {
 144   int fixed    = fixed_slots();
 145   int preserve = in_preserve_stack_slots();
 146   return OptoReg::stack2reg(align_up(fixed + preserve, (int)Matcher::stack_alignment_in_slots()));
 147 }
 148 
 149 
 150 
 151 #ifdef ASSERT
 152 void Matcher::verify_new_nodes_only(Node* xroot) {
 153   // Make sure that the new graph only references new nodes
 154   ResourceMark rm;
 155   Unique_Node_List worklist;
 156   VectorSet visited(Thread::current()-&gt;resource_area());
 157   worklist.push(xroot);
 158   while (worklist.size() &gt; 0) {
 159     Node* n = worklist.pop();
 160     visited.set(n-&gt;_idx);
 161     assert(C-&gt;node_arena()-&gt;contains(n), &quot;dead node&quot;);
 162     for (uint j = 0; j &lt; n-&gt;req(); j++) {
 163       Node* in = n-&gt;in(j);
 164       if (in != NULL) {
 165         assert(C-&gt;node_arena()-&gt;contains(in), &quot;dead node&quot;);
 166         if (!visited.test(in-&gt;_idx)) {
 167           worklist.push(in);
 168         }
 169       }
 170     }
 171   }
 172 }
 173 #endif
 174 
 175 // Array of RegMask, one per returned values (value type instances can
 176 // be returned as multiple return values, one per field)
 177 RegMask* Matcher::return_values_mask(const TypeTuple *range) {
 178   uint cnt = range-&gt;cnt() - TypeFunc::Parms;
 179   if (cnt == 0) {
 180     return NULL;
 181   }
 182   RegMask* mask = NEW_RESOURCE_ARRAY(RegMask, cnt);
 183 
 184   if (!ValueTypeReturnedAsFields) {
 185     // Get ideal-register return type
 186     uint ireg = range-&gt;field_at(TypeFunc::Parms)-&gt;ideal_reg();
 187     // Get machine return register
 188     OptoRegPair regs = return_value(ireg, false);
 189 
 190     // And mask for same
 191     mask[0].Clear();
 192     mask[0].Insert(regs.first());
 193     if (OptoReg::is_valid(regs.second())) {
 194       mask[0].Insert(regs.second());
 195     }
 196   } else {
 197     BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, cnt);
 198     VMRegPair* vm_parm_regs = NEW_RESOURCE_ARRAY(VMRegPair, cnt);
 199 
 200     for (uint i = 0; i &lt; cnt; i++) {
 201       sig_bt[i] = range-&gt;field_at(i+TypeFunc::Parms)-&gt;basic_type();
 202     }
 203 
 204     int regs = SharedRuntime::java_return_convention(sig_bt, vm_parm_regs, cnt);
 205     assert(regs &gt; 0, &quot;should have been tested during graph construction&quot;);
 206     for (uint i = 0; i &lt; cnt; i++) {
 207       mask[i].Clear();
 208 
 209       OptoReg::Name reg1 = OptoReg::as_OptoReg(vm_parm_regs[i].first());
 210       if (OptoReg::is_valid(reg1)) {
 211         mask[i].Insert(reg1);
 212       }
 213       OptoReg::Name reg2 = OptoReg::as_OptoReg(vm_parm_regs[i].second());
 214       if (OptoReg::is_valid(reg2)) {
 215         mask[i].Insert(reg2);
 216       }
 217     }
 218   }
 219   return mask;
 220 }
 221 
 222 //---------------------------match---------------------------------------------
 223 void Matcher::match( ) {
 224   if( MaxLabelRootDepth &lt; 100 ) { // Too small?
 225     assert(false, &quot;invalid MaxLabelRootDepth, increase it to 100 minimum&quot;);
 226     MaxLabelRootDepth = 100;
 227   }
 228   // One-time initialization of some register masks.
 229   init_spill_mask( C-&gt;root()-&gt;in(1) );
 230   _return_addr_mask = return_addr();
 231 #ifdef _LP64
 232   // Pointers take 2 slots in 64-bit land
 233   _return_addr_mask.Insert(OptoReg::add(return_addr(),1));
 234 #endif
 235 
 236   // Map Java-signature return types into return register-value
 237   // machine registers.
 238   const TypeTuple *range = C-&gt;tf()-&gt;range_cc();
 239   _return_values_mask = return_values_mask(range);
 240 
 241   // ---------------
 242   // Frame Layout
 243 
 244   // Need the method signature to determine the incoming argument types,
 245   // because the types determine which registers the incoming arguments are
 246   // in, and this affects the matched code.
 247   const TypeTuple *domain = C-&gt;tf()-&gt;domain_cc();
 248   uint             argcnt = domain-&gt;cnt() - TypeFunc::Parms;
 249   BasicType *sig_bt        = NEW_RESOURCE_ARRAY( BasicType, argcnt );
 250   VMRegPair *vm_parm_regs  = NEW_RESOURCE_ARRAY( VMRegPair, argcnt );
 251   _parm_regs               = NEW_RESOURCE_ARRAY( OptoRegPair, argcnt );
 252   _calling_convention_mask = NEW_RESOURCE_ARRAY( RegMask, argcnt );
 253   uint i;
 254   for( i = 0; i&lt;argcnt; i++ ) {
 255     sig_bt[i] = domain-&gt;field_at(i+TypeFunc::Parms)-&gt;basic_type();
 256   }
 257 
 258   // Pass array of ideal registers and length to USER code (from the AD file)
 259   // that will convert this to an array of register numbers.
 260   const StartNode *start = C-&gt;start();
 261   start-&gt;calling_convention( sig_bt, vm_parm_regs, argcnt );
 262 #ifdef ASSERT
 263   // Sanity check users&#39; calling convention.  Real handy while trying to
 264   // get the initial port correct.
 265   { for (uint i = 0; i&lt;argcnt; i++) {
 266       if( !vm_parm_regs[i].first()-&gt;is_valid() &amp;&amp; !vm_parm_regs[i].second()-&gt;is_valid() ) {
 267         assert(domain-&gt;field_at(i+TypeFunc::Parms)==Type::HALF, &quot;only allowed on halve&quot; );
 268         _parm_regs[i].set_bad();
 269         continue;
 270       }
 271       VMReg parm_reg = vm_parm_regs[i].first();
 272       assert(parm_reg-&gt;is_valid(), &quot;invalid arg?&quot;);
 273       if (parm_reg-&gt;is_reg()) {
 274         OptoReg::Name opto_parm_reg = OptoReg::as_OptoReg(parm_reg);
 275         assert(can_be_java_arg(opto_parm_reg) ||
 276                C-&gt;stub_function() == CAST_FROM_FN_PTR(address, OptoRuntime::rethrow_C) ||
 277                opto_parm_reg == inline_cache_reg(),
 278                &quot;parameters in register must be preserved by runtime stubs&quot;);
 279       }
 280       for (uint j = 0; j &lt; i; j++) {
 281         assert(parm_reg != vm_parm_regs[j].first(),
 282                &quot;calling conv. must produce distinct regs&quot;);
 283       }
 284     }
 285   }
 286 #endif
 287 
 288   // Do some initial frame layout.
 289 
 290   // Compute the old incoming SP (may be called FP) as
 291   //   OptoReg::stack0() + locks + in_preserve_stack_slots + pad2.
 292   _old_SP = C-&gt;compute_old_SP();
 293   assert( is_even(_old_SP), &quot;must be even&quot; );
 294 
 295   // Compute highest incoming stack argument as
 296   //   _old_SP + out_preserve_stack_slots + incoming argument size.
 297   _in_arg_limit = OptoReg::add(_old_SP, C-&gt;out_preserve_stack_slots());
 298   assert( is_even(_in_arg_limit), &quot;out_preserve must be even&quot; );
 299   for( i = 0; i &lt; argcnt; i++ ) {
 300     // Permit args to have no register
 301     _calling_convention_mask[i].Clear();
 302     if( !vm_parm_regs[i].first()-&gt;is_valid() &amp;&amp; !vm_parm_regs[i].second()-&gt;is_valid() ) {
 303       continue;
 304     }
 305     // calling_convention returns stack arguments as a count of
 306     // slots beyond OptoReg::stack0()/VMRegImpl::stack0.  We need to convert this to
 307     // the allocators point of view, taking into account all the
 308     // preserve area, locks &amp; pad2.
 309 
 310     OptoReg::Name reg1 = warp_incoming_stk_arg(vm_parm_regs[i].first());
 311     if( OptoReg::is_valid(reg1))
 312       _calling_convention_mask[i].Insert(reg1);
 313 
 314     OptoReg::Name reg2 = warp_incoming_stk_arg(vm_parm_regs[i].second());
 315     if( OptoReg::is_valid(reg2))
 316       _calling_convention_mask[i].Insert(reg2);
 317 
 318     // Saved biased stack-slot register number
 319     _parm_regs[i].set_pair(reg2, reg1);
 320   }
 321 
 322   // Finally, make sure the incoming arguments take up an even number of
 323   // words, in case the arguments or locals need to contain doubleword stack
 324   // slots.  The rest of the system assumes that stack slot pairs (in
 325   // particular, in the spill area) which look aligned will in fact be
 326   // aligned relative to the stack pointer in the target machine.  Double
 327   // stack slots will always be allocated aligned.
 328   _new_SP = OptoReg::Name(align_up(_in_arg_limit, (int)RegMask::SlotsPerLong));
 329 
 330   // Compute highest outgoing stack argument as
 331   //   _new_SP + out_preserve_stack_slots + max(outgoing argument size).
 332   _out_arg_limit = OptoReg::add(_new_SP, C-&gt;out_preserve_stack_slots());
 333   assert( is_even(_out_arg_limit), &quot;out_preserve must be even&quot; );
 334 
 335   if (!RegMask::can_represent_arg(OptoReg::add(_out_arg_limit,-1))) {
 336     // the compiler cannot represent this method&#39;s calling sequence
 337     C-&gt;record_method_not_compilable(&quot;must be able to represent all call arguments in reg mask&quot;);
 338   }
 339 
 340   if (C-&gt;failing())  return;  // bailed out on incoming arg failure
 341 
 342   // ---------------
 343   // Collect roots of matcher trees.  Every node for which
 344   // _shared[_idx] is cleared is guaranteed to not be shared, and thus
 345   // can be a valid interior of some tree.
 346   find_shared( C-&gt;root() );
 347   find_shared( C-&gt;top() );
 348 
 349   C-&gt;print_method(PHASE_BEFORE_MATCHING);
 350 
 351   // Create new ideal node ConP #NULL even if it does exist in old space
 352   // to avoid false sharing if the corresponding mach node is not used.
 353   // The corresponding mach node is only used in rare cases for derived
 354   // pointers.
 355   Node* new_ideal_null = ConNode::make(TypePtr::NULL_PTR);
 356 
 357   // Swap out to old-space; emptying new-space
 358   Arena *old = C-&gt;node_arena()-&gt;move_contents(C-&gt;old_arena());
 359 
 360   // Save debug and profile information for nodes in old space:
 361   _old_node_note_array = C-&gt;node_note_array();
 362   if (_old_node_note_array != NULL) {
 363     C-&gt;set_node_note_array(new(C-&gt;comp_arena()) GrowableArray&lt;Node_Notes*&gt;
 364                            (C-&gt;comp_arena(), _old_node_note_array-&gt;length(),
 365                             0, NULL));
 366   }
 367 
 368   // Pre-size the new_node table to avoid the need for range checks.
 369   grow_new_node_array(C-&gt;unique());
 370 
 371   // Reset node counter so MachNodes start with _idx at 0
 372   int live_nodes = C-&gt;live_nodes();
 373   C-&gt;set_unique(0);
 374   C-&gt;reset_dead_node_list();
 375 
 376   // Recursively match trees from old space into new space.
 377   // Correct leaves of new-space Nodes; they point to old-space.
 378   _visited.clear();
 379   C-&gt;set_cached_top_node(xform( C-&gt;top(), live_nodes ));
 380   if (!C-&gt;failing()) {
 381     Node* xroot =        xform( C-&gt;root(), 1 );
 382     if (xroot == NULL) {
 383       Matcher::soft_match_failure();  // recursive matching process failed
 384       C-&gt;record_method_not_compilable(&quot;instruction match failed&quot;);
 385     } else {
 386       // During matching shared constants were attached to C-&gt;root()
 387       // because xroot wasn&#39;t available yet, so transfer the uses to
 388       // the xroot.
 389       for( DUIterator_Fast jmax, j = C-&gt;root()-&gt;fast_outs(jmax); j &lt; jmax; j++ ) {
 390         Node* n = C-&gt;root()-&gt;fast_out(j);
 391         if (C-&gt;node_arena()-&gt;contains(n)) {
 392           assert(n-&gt;in(0) == C-&gt;root(), &quot;should be control user&quot;);
 393           n-&gt;set_req(0, xroot);
 394           --j;
 395           --jmax;
 396         }
 397       }
 398 
 399       // Generate new mach node for ConP #NULL
 400       assert(new_ideal_null != NULL, &quot;sanity&quot;);
 401       _mach_null = match_tree(new_ideal_null);
 402       // Don&#39;t set control, it will confuse GCM since there are no uses.
 403       // The control will be set when this node is used first time
 404       // in find_base_for_derived().
 405       assert(_mach_null != NULL, &quot;&quot;);
 406 
 407       C-&gt;set_root(xroot-&gt;is_Root() ? xroot-&gt;as_Root() : NULL);
 408 
 409 #ifdef ASSERT
 410       verify_new_nodes_only(xroot);
 411 #endif
 412     }
 413   }
 414   if (C-&gt;top() == NULL || C-&gt;root() == NULL) {
 415     C-&gt;record_method_not_compilable(&quot;graph lost&quot;); // %%% cannot happen?
 416   }
 417   if (C-&gt;failing()) {
 418     // delete old;
 419     old-&gt;destruct_contents();
 420     return;
 421   }
 422   assert( C-&gt;top(), &quot;&quot; );
 423   assert( C-&gt;root(), &quot;&quot; );
 424   validate_null_checks();
 425 
 426   // Now smoke old-space
 427   NOT_DEBUG( old-&gt;destruct_contents() );
 428 
 429   // ------------------------
 430   // Set up save-on-entry registers.
 431   Fixup_Save_On_Entry( );
 432 
 433   { // Cleanup mach IR after selection phase is over.
 434     Compile::TracePhase tp(&quot;postselect_cleanup&quot;, &amp;timers[_t_postselect_cleanup]);
 435     do_postselect_cleanup();
 436     if (C-&gt;failing())  return;
 437     assert(verify_after_postselect_cleanup(), &quot;&quot;);
 438   }
 439 }
 440 
 441 //------------------------------Fixup_Save_On_Entry----------------------------
 442 // The stated purpose of this routine is to take care of save-on-entry
 443 // registers.  However, the overall goal of the Match phase is to convert into
 444 // machine-specific instructions which have RegMasks to guide allocation.
 445 // So what this procedure really does is put a valid RegMask on each input
 446 // to the machine-specific variations of all Return, TailCall and Halt
 447 // instructions.  It also adds edgs to define the save-on-entry values (and of
 448 // course gives them a mask).
 449 
 450 static RegMask *init_input_masks( uint size, RegMask &amp;ret_adr, RegMask &amp;fp ) {
 451   RegMask *rms = NEW_RESOURCE_ARRAY( RegMask, size );
 452   // Do all the pre-defined register masks
 453   rms[TypeFunc::Control  ] = RegMask::Empty;
 454   rms[TypeFunc::I_O      ] = RegMask::Empty;
 455   rms[TypeFunc::Memory   ] = RegMask::Empty;
 456   rms[TypeFunc::ReturnAdr] = ret_adr;
 457   rms[TypeFunc::FramePtr ] = fp;
 458   return rms;
 459 }
 460 
 461 #define NOF_STACK_MASKS (3*6+5)
 462 
 463 // Create the initial stack mask used by values spilling to the stack.
 464 // Disallow any debug info in outgoing argument areas by setting the
 465 // initial mask accordingly.
 466 void Matcher::init_first_stack_mask() {
 467 
 468   // Allocate storage for spill masks as masks for the appropriate load type.
 469   RegMask *rms = (RegMask*)C-&gt;comp_arena()-&gt;Amalloc_D(sizeof(RegMask) * NOF_STACK_MASKS);
 470 
 471   // Initialize empty placeholder masks into the newly allocated arena
 472   for (int i = 0; i &lt; NOF_STACK_MASKS; i++) {
 473     new (rms + i) RegMask();
 474   }
 475 
 476   idealreg2spillmask  [Op_RegN] = &amp;rms[0];
 477   idealreg2spillmask  [Op_RegI] = &amp;rms[1];
 478   idealreg2spillmask  [Op_RegL] = &amp;rms[2];
 479   idealreg2spillmask  [Op_RegF] = &amp;rms[3];
 480   idealreg2spillmask  [Op_RegD] = &amp;rms[4];
 481   idealreg2spillmask  [Op_RegP] = &amp;rms[5];
 482 
 483   idealreg2debugmask  [Op_RegN] = &amp;rms[6];
 484   idealreg2debugmask  [Op_RegI] = &amp;rms[7];
 485   idealreg2debugmask  [Op_RegL] = &amp;rms[8];
 486   idealreg2debugmask  [Op_RegF] = &amp;rms[9];
 487   idealreg2debugmask  [Op_RegD] = &amp;rms[10];
 488   idealreg2debugmask  [Op_RegP] = &amp;rms[11];
 489 
 490   idealreg2mhdebugmask[Op_RegN] = &amp;rms[12];
 491   idealreg2mhdebugmask[Op_RegI] = &amp;rms[13];
 492   idealreg2mhdebugmask[Op_RegL] = &amp;rms[14];
 493   idealreg2mhdebugmask[Op_RegF] = &amp;rms[15];
 494   idealreg2mhdebugmask[Op_RegD] = &amp;rms[16];
 495   idealreg2mhdebugmask[Op_RegP] = &amp;rms[17];
 496 
 497   idealreg2spillmask  [Op_VecS] = &amp;rms[18];
 498   idealreg2spillmask  [Op_VecD] = &amp;rms[19];
 499   idealreg2spillmask  [Op_VecX] = &amp;rms[20];
 500   idealreg2spillmask  [Op_VecY] = &amp;rms[21];
 501   idealreg2spillmask  [Op_VecZ] = &amp;rms[22];
 502 
 503   OptoReg::Name i;
 504 
 505   // At first, start with the empty mask
 506   C-&gt;FIRST_STACK_mask().Clear();
 507 
 508   // Add in the incoming argument area
 509   OptoReg::Name init_in = OptoReg::add(_old_SP, C-&gt;out_preserve_stack_slots());
 510   for (i = init_in; i &lt; _in_arg_limit; i = OptoReg::add(i,1)) {
 511     C-&gt;FIRST_STACK_mask().Insert(i);
 512   }
 513 
 514   // Check if the method has a reserved entry in the argument stack area that
 515   // should not be used for spilling because it may hold the return address.
 516   if (!C-&gt;is_osr_compilation() &amp;&amp; C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;has_scalarized_args()) {
 517     ExtendedSignature sig_cc = ExtendedSignature(C-&gt;method()-&gt;get_sig_cc(), SigEntryFilter());
 518     for (int off = 0; !sig_cc.at_end(); ) {
 519       BasicType bt = (*sig_cc)._bt;
 520       off += type2size[bt];
 521       while (SigEntry::next_is_reserved(sig_cc, bt)) {
 522         // Remove reserved stack slot from mask to avoid spilling
 523         OptoRegPair reg = _parm_regs[off];
 524         assert(OptoReg::is_valid(reg.first()), &quot;invalid reserved register&quot;);
 525         C-&gt;FIRST_STACK_mask().Remove(reg.first());
 526         C-&gt;FIRST_STACK_mask().Remove(reg.first()+1); // Always occupies two stack slots
 527         off += type2size[bt];
 528       }
 529     }
 530   }
 531 
 532   // Add in all bits past the outgoing argument area
 533   guarantee(RegMask::can_represent_arg(OptoReg::add(_out_arg_limit,-1)),
 534             &quot;must be able to represent all call arguments in reg mask&quot;);
 535   OptoReg::Name init = _out_arg_limit;
 536   for (i = init; RegMask::can_represent(i); i = OptoReg::add(i,1)) {
 537     C-&gt;FIRST_STACK_mask().Insert(i);
 538   }
 539   // Finally, set the &quot;infinite stack&quot; bit.
 540   C-&gt;FIRST_STACK_mask().set_AllStack();
 541 
 542   // Make spill masks.  Registers for their class, plus FIRST_STACK_mask.
 543   RegMask aligned_stack_mask = C-&gt;FIRST_STACK_mask();
 544   // Keep spill masks aligned.
 545   aligned_stack_mask.clear_to_pairs();
 546   assert(aligned_stack_mask.is_AllStack(), &quot;should be infinite stack&quot;);
 547 
 548   *idealreg2spillmask[Op_RegP] = *idealreg2regmask[Op_RegP];
 549 #ifdef _LP64
 550   *idealreg2spillmask[Op_RegN] = *idealreg2regmask[Op_RegN];
 551    idealreg2spillmask[Op_RegN]-&gt;OR(C-&gt;FIRST_STACK_mask());
 552    idealreg2spillmask[Op_RegP]-&gt;OR(aligned_stack_mask);
 553 #else
 554    idealreg2spillmask[Op_RegP]-&gt;OR(C-&gt;FIRST_STACK_mask());
 555 #endif
 556   *idealreg2spillmask[Op_RegI] = *idealreg2regmask[Op_RegI];
 557    idealreg2spillmask[Op_RegI]-&gt;OR(C-&gt;FIRST_STACK_mask());
 558   *idealreg2spillmask[Op_RegL] = *idealreg2regmask[Op_RegL];
 559    idealreg2spillmask[Op_RegL]-&gt;OR(aligned_stack_mask);
 560   *idealreg2spillmask[Op_RegF] = *idealreg2regmask[Op_RegF];
 561    idealreg2spillmask[Op_RegF]-&gt;OR(C-&gt;FIRST_STACK_mask());
 562   *idealreg2spillmask[Op_RegD] = *idealreg2regmask[Op_RegD];
 563    idealreg2spillmask[Op_RegD]-&gt;OR(aligned_stack_mask);
 564 
 565   if (Matcher::vector_size_supported(T_BYTE,4)) {
 566     *idealreg2spillmask[Op_VecS] = *idealreg2regmask[Op_VecS];
 567      idealreg2spillmask[Op_VecS]-&gt;OR(C-&gt;FIRST_STACK_mask());
 568   }
 569   if (Matcher::vector_size_supported(T_FLOAT,2)) {
 570     // For VecD we need dual alignment and 8 bytes (2 slots) for spills.
 571     // RA guarantees such alignment since it is needed for Double and Long values.
 572     *idealreg2spillmask[Op_VecD] = *idealreg2regmask[Op_VecD];
 573      idealreg2spillmask[Op_VecD]-&gt;OR(aligned_stack_mask);
 574   }
 575   if (Matcher::vector_size_supported(T_FLOAT,4)) {
 576     // For VecX we need quadro alignment and 16 bytes (4 slots) for spills.
 577     //
 578     // RA can use input arguments stack slots for spills but until RA
 579     // we don&#39;t know frame size and offset of input arg stack slots.
 580     //
 581     // Exclude last input arg stack slots to avoid spilling vectors there
 582     // otherwise vector spills could stomp over stack slots in caller frame.
 583     OptoReg::Name in = OptoReg::add(_in_arg_limit, -1);
 584     for (int k = 1; (in &gt;= init_in) &amp;&amp; (k &lt; RegMask::SlotsPerVecX); k++) {
 585       aligned_stack_mask.Remove(in);
 586       in = OptoReg::add(in, -1);
 587     }
 588      aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecX);
 589      assert(aligned_stack_mask.is_AllStack(), &quot;should be infinite stack&quot;);
 590     *idealreg2spillmask[Op_VecX] = *idealreg2regmask[Op_VecX];
 591      idealreg2spillmask[Op_VecX]-&gt;OR(aligned_stack_mask);
 592   }
 593   if (Matcher::vector_size_supported(T_FLOAT,8)) {
 594     // For VecY we need octo alignment and 32 bytes (8 slots) for spills.
 595     OptoReg::Name in = OptoReg::add(_in_arg_limit, -1);
 596     for (int k = 1; (in &gt;= init_in) &amp;&amp; (k &lt; RegMask::SlotsPerVecY); k++) {
 597       aligned_stack_mask.Remove(in);
 598       in = OptoReg::add(in, -1);
 599     }
 600      aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecY);
 601      assert(aligned_stack_mask.is_AllStack(), &quot;should be infinite stack&quot;);
 602     *idealreg2spillmask[Op_VecY] = *idealreg2regmask[Op_VecY];
 603      idealreg2spillmask[Op_VecY]-&gt;OR(aligned_stack_mask);
 604   }
 605   if (Matcher::vector_size_supported(T_FLOAT,16)) {
 606     // For VecZ we need enough alignment and 64 bytes (16 slots) for spills.
 607     OptoReg::Name in = OptoReg::add(_in_arg_limit, -1);
 608     for (int k = 1; (in &gt;= init_in) &amp;&amp; (k &lt; RegMask::SlotsPerVecZ); k++) {
 609       aligned_stack_mask.Remove(in);
 610       in = OptoReg::add(in, -1);
 611     }
 612      aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecZ);
 613      assert(aligned_stack_mask.is_AllStack(), &quot;should be infinite stack&quot;);
 614     *idealreg2spillmask[Op_VecZ] = *idealreg2regmask[Op_VecZ];
 615      idealreg2spillmask[Op_VecZ]-&gt;OR(aligned_stack_mask);
 616   }
 617    if (UseFPUForSpilling) {
 618      // This mask logic assumes that the spill operations are
 619      // symmetric and that the registers involved are the same size.
 620      // On sparc for instance we may have to use 64 bit moves will
 621      // kill 2 registers when used with F0-F31.
 622      idealreg2spillmask[Op_RegI]-&gt;OR(*idealreg2regmask[Op_RegF]);
 623      idealreg2spillmask[Op_RegF]-&gt;OR(*idealreg2regmask[Op_RegI]);
 624 #ifdef _LP64
 625      idealreg2spillmask[Op_RegN]-&gt;OR(*idealreg2regmask[Op_RegF]);
 626      idealreg2spillmask[Op_RegL]-&gt;OR(*idealreg2regmask[Op_RegD]);
 627      idealreg2spillmask[Op_RegD]-&gt;OR(*idealreg2regmask[Op_RegL]);
 628      idealreg2spillmask[Op_RegP]-&gt;OR(*idealreg2regmask[Op_RegD]);
 629 #else
 630      idealreg2spillmask[Op_RegP]-&gt;OR(*idealreg2regmask[Op_RegF]);
 631 #ifdef ARM
 632      // ARM has support for moving 64bit values between a pair of
 633      // integer registers and a double register
 634      idealreg2spillmask[Op_RegL]-&gt;OR(*idealreg2regmask[Op_RegD]);
 635      idealreg2spillmask[Op_RegD]-&gt;OR(*idealreg2regmask[Op_RegL]);
 636 #endif
 637 #endif
 638    }
 639 
 640   // Make up debug masks.  Any spill slot plus callee-save registers.
 641   // Caller-save registers are assumed to be trashable by the various
 642   // inline-cache fixup routines.
 643   *idealreg2debugmask  [Op_RegN]= *idealreg2spillmask[Op_RegN];
 644   *idealreg2debugmask  [Op_RegI]= *idealreg2spillmask[Op_RegI];
 645   *idealreg2debugmask  [Op_RegL]= *idealreg2spillmask[Op_RegL];
 646   *idealreg2debugmask  [Op_RegF]= *idealreg2spillmask[Op_RegF];
 647   *idealreg2debugmask  [Op_RegD]= *idealreg2spillmask[Op_RegD];
 648   *idealreg2debugmask  [Op_RegP]= *idealreg2spillmask[Op_RegP];
 649 
 650   *idealreg2mhdebugmask[Op_RegN]= *idealreg2spillmask[Op_RegN];
 651   *idealreg2mhdebugmask[Op_RegI]= *idealreg2spillmask[Op_RegI];
 652   *idealreg2mhdebugmask[Op_RegL]= *idealreg2spillmask[Op_RegL];
 653   *idealreg2mhdebugmask[Op_RegF]= *idealreg2spillmask[Op_RegF];
 654   *idealreg2mhdebugmask[Op_RegD]= *idealreg2spillmask[Op_RegD];
 655   *idealreg2mhdebugmask[Op_RegP]= *idealreg2spillmask[Op_RegP];
 656 
 657   // Prevent stub compilations from attempting to reference
 658   // callee-saved registers from debug info
 659   bool exclude_soe = !Compile::current()-&gt;is_method_compilation();
 660 
 661   for( i=OptoReg::Name(0); i&lt;OptoReg::Name(_last_Mach_Reg); i = OptoReg::add(i,1) ) {
 662     // registers the caller has to save do not work
 663     if( _register_save_policy[i] == &#39;C&#39; ||
 664         _register_save_policy[i] == &#39;A&#39; ||
 665         (_register_save_policy[i] == &#39;E&#39; &amp;&amp; exclude_soe) ) {
 666       idealreg2debugmask  [Op_RegN]-&gt;Remove(i);
 667       idealreg2debugmask  [Op_RegI]-&gt;Remove(i); // Exclude save-on-call
 668       idealreg2debugmask  [Op_RegL]-&gt;Remove(i); // registers from debug
 669       idealreg2debugmask  [Op_RegF]-&gt;Remove(i); // masks
 670       idealreg2debugmask  [Op_RegD]-&gt;Remove(i);
 671       idealreg2debugmask  [Op_RegP]-&gt;Remove(i);
 672 
 673       idealreg2mhdebugmask[Op_RegN]-&gt;Remove(i);
 674       idealreg2mhdebugmask[Op_RegI]-&gt;Remove(i);
 675       idealreg2mhdebugmask[Op_RegL]-&gt;Remove(i);
 676       idealreg2mhdebugmask[Op_RegF]-&gt;Remove(i);
 677       idealreg2mhdebugmask[Op_RegD]-&gt;Remove(i);
 678       idealreg2mhdebugmask[Op_RegP]-&gt;Remove(i);
 679     }
 680   }
 681 
 682   // Subtract the register we use to save the SP for MethodHandle
 683   // invokes to from the debug mask.
 684   const RegMask save_mask = method_handle_invoke_SP_save_mask();
 685   idealreg2mhdebugmask[Op_RegN]-&gt;SUBTRACT(save_mask);
 686   idealreg2mhdebugmask[Op_RegI]-&gt;SUBTRACT(save_mask);
 687   idealreg2mhdebugmask[Op_RegL]-&gt;SUBTRACT(save_mask);
 688   idealreg2mhdebugmask[Op_RegF]-&gt;SUBTRACT(save_mask);
 689   idealreg2mhdebugmask[Op_RegD]-&gt;SUBTRACT(save_mask);
 690   idealreg2mhdebugmask[Op_RegP]-&gt;SUBTRACT(save_mask);
 691 }
 692 
 693 //---------------------------is_save_on_entry----------------------------------
 694 bool Matcher::is_save_on_entry( int reg ) {
 695   return
 696     _register_save_policy[reg] == &#39;E&#39; ||
 697     _register_save_policy[reg] == &#39;A&#39; || // Save-on-entry register?
 698     // Also save argument registers in the trampolining stubs
 699     (C-&gt;save_argument_registers() &amp;&amp; is_spillable_arg(reg));
 700 }
 701 
 702 //---------------------------Fixup_Save_On_Entry-------------------------------
 703 void Matcher::Fixup_Save_On_Entry( ) {
 704   init_first_stack_mask();
 705 
 706   Node *root = C-&gt;root();       // Short name for root
 707   // Count number of save-on-entry registers.
 708   uint soe_cnt = number_of_saved_registers();
 709   uint i;
 710 
 711   // Find the procedure Start Node
 712   StartNode *start = C-&gt;start();
 713   assert( start, &quot;Expect a start node&quot; );
 714 
 715   // Save argument registers in the trampolining stubs
 716   if( C-&gt;save_argument_registers() )
 717     for( i = 0; i &lt; _last_Mach_Reg; i++ )
 718       if( is_spillable_arg(i) )
 719         soe_cnt++;
 720 
 721   // Input RegMask array shared by all Returns.
 722   // The type for doubles and longs has a count of 2, but
 723   // there is only 1 returned value
 724   uint ret_edge_cnt = C-&gt;tf()-&gt;range_cc()-&gt;cnt();
 725   RegMask *ret_rms  = init_input_masks( ret_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 726   for (i = TypeFunc::Parms; i &lt; ret_edge_cnt; i++) {
 727     ret_rms[i] = _return_values_mask[i-TypeFunc::Parms];
 728   }
 729 
 730   // Input RegMask array shared by all Rethrows.
 731   uint reth_edge_cnt = TypeFunc::Parms+1;
 732   RegMask *reth_rms  = init_input_masks( reth_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 733   // Rethrow takes exception oop only, but in the argument 0 slot.
 734   OptoReg::Name reg = find_receiver(false);
 735   if (reg &gt;= 0) {
 736     reth_rms[TypeFunc::Parms] = mreg2regmask[reg];
 737 #ifdef _LP64
 738     // Need two slots for ptrs in 64-bit land
 739     reth_rms[TypeFunc::Parms].Insert(OptoReg::add(OptoReg::Name(reg), 1));
 740 #endif
 741   }
 742 
 743   // Input RegMask array shared by all TailCalls
 744   uint tail_call_edge_cnt = TypeFunc::Parms+2;
 745   RegMask *tail_call_rms = init_input_masks( tail_call_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 746 
 747   // Input RegMask array shared by all TailJumps
 748   uint tail_jump_edge_cnt = TypeFunc::Parms+2;
 749   RegMask *tail_jump_rms = init_input_masks( tail_jump_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 750 
 751   // TailCalls have 2 returned values (target &amp; moop), whose masks come
 752   // from the usual MachNode/MachOper mechanism.  Find a sample
 753   // TailCall to extract these masks and put the correct masks into
 754   // the tail_call_rms array.
 755   for( i=1; i &lt; root-&gt;req(); i++ ) {
 756     MachReturnNode *m = root-&gt;in(i)-&gt;as_MachReturn();
 757     if( m-&gt;ideal_Opcode() == Op_TailCall ) {
 758       tail_call_rms[TypeFunc::Parms+0] = m-&gt;MachNode::in_RegMask(TypeFunc::Parms+0);
 759       tail_call_rms[TypeFunc::Parms+1] = m-&gt;MachNode::in_RegMask(TypeFunc::Parms+1);
 760       break;
 761     }
 762   }
 763 
 764   // TailJumps have 2 returned values (target &amp; ex_oop), whose masks come
 765   // from the usual MachNode/MachOper mechanism.  Find a sample
 766   // TailJump to extract these masks and put the correct masks into
 767   // the tail_jump_rms array.
 768   for( i=1; i &lt; root-&gt;req(); i++ ) {
 769     MachReturnNode *m = root-&gt;in(i)-&gt;as_MachReturn();
 770     if( m-&gt;ideal_Opcode() == Op_TailJump ) {
 771       tail_jump_rms[TypeFunc::Parms+0] = m-&gt;MachNode::in_RegMask(TypeFunc::Parms+0);
 772       tail_jump_rms[TypeFunc::Parms+1] = m-&gt;MachNode::in_RegMask(TypeFunc::Parms+1);
 773       break;
 774     }
 775   }
 776 
 777   // Input RegMask array shared by all Halts
 778   uint halt_edge_cnt = TypeFunc::Parms;
 779   RegMask *halt_rms = init_input_masks( halt_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 780 
 781   // Capture the return input masks into each exit flavor
 782   for( i=1; i &lt; root-&gt;req(); i++ ) {
 783     MachReturnNode *exit = root-&gt;in(i)-&gt;as_MachReturn();
 784     switch( exit-&gt;ideal_Opcode() ) {
 785       case Op_Return   : exit-&gt;_in_rms = ret_rms;  break;
 786       case Op_Rethrow  : exit-&gt;_in_rms = reth_rms; break;
 787       case Op_TailCall : exit-&gt;_in_rms = tail_call_rms; break;
 788       case Op_TailJump : exit-&gt;_in_rms = tail_jump_rms; break;
 789       case Op_Halt     : exit-&gt;_in_rms = halt_rms; break;
 790       default          : ShouldNotReachHere();
 791     }
 792   }
 793 
 794   // Next unused projection number from Start.
 795   int proj_cnt = C-&gt;tf()-&gt;domain_cc()-&gt;cnt();
 796 
 797   // Do all the save-on-entry registers.  Make projections from Start for
 798   // them, and give them a use at the exit points.  To the allocator, they
 799   // look like incoming register arguments.
 800   for( i = 0; i &lt; _last_Mach_Reg; i++ ) {
 801     if( is_save_on_entry(i) ) {
 802 
 803       // Add the save-on-entry to the mask array
 804       ret_rms      [      ret_edge_cnt] = mreg2regmask[i];
 805       reth_rms     [     reth_edge_cnt] = mreg2regmask[i];
 806       tail_call_rms[tail_call_edge_cnt] = mreg2regmask[i];
 807       tail_jump_rms[tail_jump_edge_cnt] = mreg2regmask[i];
 808       // Halts need the SOE registers, but only in the stack as debug info.
 809       // A just-prior uncommon-trap or deoptimization will use the SOE regs.
 810       halt_rms     [     halt_edge_cnt] = *idealreg2spillmask[_register_save_type[i]];
 811 
 812       Node *mproj;
 813 
 814       // Is this a RegF low half of a RegD?  Double up 2 adjacent RegF&#39;s
 815       // into a single RegD.
 816       if( (i&amp;1) == 0 &amp;&amp;
 817           _register_save_type[i  ] == Op_RegF &amp;&amp;
 818           _register_save_type[i+1] == Op_RegF &amp;&amp;
 819           is_save_on_entry(i+1) ) {
 820         // Add other bit for double
 821         ret_rms      [      ret_edge_cnt].Insert(OptoReg::Name(i+1));
 822         reth_rms     [     reth_edge_cnt].Insert(OptoReg::Name(i+1));
 823         tail_call_rms[tail_call_edge_cnt].Insert(OptoReg::Name(i+1));
 824         tail_jump_rms[tail_jump_edge_cnt].Insert(OptoReg::Name(i+1));
 825         halt_rms     [     halt_edge_cnt].Insert(OptoReg::Name(i+1));
 826         mproj = new MachProjNode( start, proj_cnt, ret_rms[ret_edge_cnt], Op_RegD );
 827         proj_cnt += 2;          // Skip 2 for doubles
 828       }
 829       else if( (i&amp;1) == 1 &amp;&amp;    // Else check for high half of double
 830                _register_save_type[i-1] == Op_RegF &amp;&amp;
 831                _register_save_type[i  ] == Op_RegF &amp;&amp;
 832                is_save_on_entry(i-1) ) {
 833         ret_rms      [      ret_edge_cnt] = RegMask::Empty;
 834         reth_rms     [     reth_edge_cnt] = RegMask::Empty;
 835         tail_call_rms[tail_call_edge_cnt] = RegMask::Empty;
 836         tail_jump_rms[tail_jump_edge_cnt] = RegMask::Empty;
 837         halt_rms     [     halt_edge_cnt] = RegMask::Empty;
 838         mproj = C-&gt;top();
 839       }
 840       // Is this a RegI low half of a RegL?  Double up 2 adjacent RegI&#39;s
 841       // into a single RegL.
 842       else if( (i&amp;1) == 0 &amp;&amp;
 843           _register_save_type[i  ] == Op_RegI &amp;&amp;
 844           _register_save_type[i+1] == Op_RegI &amp;&amp;
 845         is_save_on_entry(i+1) ) {
 846         // Add other bit for long
 847         ret_rms      [      ret_edge_cnt].Insert(OptoReg::Name(i+1));
 848         reth_rms     [     reth_edge_cnt].Insert(OptoReg::Name(i+1));
 849         tail_call_rms[tail_call_edge_cnt].Insert(OptoReg::Name(i+1));
 850         tail_jump_rms[tail_jump_edge_cnt].Insert(OptoReg::Name(i+1));
 851         halt_rms     [     halt_edge_cnt].Insert(OptoReg::Name(i+1));
 852         mproj = new MachProjNode( start, proj_cnt, ret_rms[ret_edge_cnt], Op_RegL );
 853         proj_cnt += 2;          // Skip 2 for longs
 854       }
 855       else if( (i&amp;1) == 1 &amp;&amp;    // Else check for high half of long
 856                _register_save_type[i-1] == Op_RegI &amp;&amp;
 857                _register_save_type[i  ] == Op_RegI &amp;&amp;
 858                is_save_on_entry(i-1) ) {
 859         ret_rms      [      ret_edge_cnt] = RegMask::Empty;
 860         reth_rms     [     reth_edge_cnt] = RegMask::Empty;
 861         tail_call_rms[tail_call_edge_cnt] = RegMask::Empty;
 862         tail_jump_rms[tail_jump_edge_cnt] = RegMask::Empty;
 863         halt_rms     [     halt_edge_cnt] = RegMask::Empty;
 864         mproj = C-&gt;top();
 865       } else {
 866         // Make a projection for it off the Start
 867         mproj = new MachProjNode( start, proj_cnt++, ret_rms[ret_edge_cnt], _register_save_type[i] );
 868       }
 869 
 870       ret_edge_cnt ++;
 871       reth_edge_cnt ++;
 872       tail_call_edge_cnt ++;
 873       tail_jump_edge_cnt ++;
 874       halt_edge_cnt ++;
 875 
 876       // Add a use of the SOE register to all exit paths
 877       for( uint j=1; j &lt; root-&gt;req(); j++ )
 878         root-&gt;in(j)-&gt;add_req(mproj);
 879     } // End of if a save-on-entry register
 880   } // End of for all machine registers
 881 }
 882 
 883 //------------------------------init_spill_mask--------------------------------
 884 void Matcher::init_spill_mask( Node *ret ) {
 885   if( idealreg2regmask[Op_RegI] ) return; // One time only init
 886 
 887   OptoReg::c_frame_pointer = c_frame_pointer();
 888   c_frame_ptr_mask = c_frame_pointer();
 889 #ifdef _LP64
 890   // pointers are twice as big
 891   c_frame_ptr_mask.Insert(OptoReg::add(c_frame_pointer(),1));
 892 #endif
 893 
 894   // Start at OptoReg::stack0()
 895   STACK_ONLY_mask.Clear();
 896   OptoReg::Name init = OptoReg::stack2reg(0);
 897   // STACK_ONLY_mask is all stack bits
 898   OptoReg::Name i;
 899   for (i = init; RegMask::can_represent(i); i = OptoReg::add(i,1))
 900     STACK_ONLY_mask.Insert(i);
 901   // Also set the &quot;infinite stack&quot; bit.
 902   STACK_ONLY_mask.set_AllStack();
 903 
 904   // Copy the register names over into the shared world
 905   for( i=OptoReg::Name(0); i&lt;OptoReg::Name(_last_Mach_Reg); i = OptoReg::add(i,1) ) {
 906     // SharedInfo::regName[i] = regName[i];
 907     // Handy RegMasks per machine register
 908     mreg2regmask[i].Insert(i);
 909   }
 910 
 911   // Grab the Frame Pointer
 912   Node *fp  = ret-&gt;in(TypeFunc::FramePtr);
 913   // Share frame pointer while making spill ops
 914   set_shared(fp);
 915 
 916 // Get the ADLC notion of the right regmask, for each basic type.
 917 #ifdef _LP64
 918   idealreg2regmask[Op_RegN] = regmask_for_ideal_register(Op_RegN, ret);
 919 #endif
 920   idealreg2regmask[Op_RegI] = regmask_for_ideal_register(Op_RegI, ret);
 921   idealreg2regmask[Op_RegP] = regmask_for_ideal_register(Op_RegP, ret);
 922   idealreg2regmask[Op_RegF] = regmask_for_ideal_register(Op_RegF, ret);
 923   idealreg2regmask[Op_RegD] = regmask_for_ideal_register(Op_RegD, ret);
 924   idealreg2regmask[Op_RegL] = regmask_for_ideal_register(Op_RegL, ret);
 925   idealreg2regmask[Op_VecS] = regmask_for_ideal_register(Op_VecS, ret);
 926   idealreg2regmask[Op_VecD] = regmask_for_ideal_register(Op_VecD, ret);
 927   idealreg2regmask[Op_VecX] = regmask_for_ideal_register(Op_VecX, ret);
 928   idealreg2regmask[Op_VecY] = regmask_for_ideal_register(Op_VecY, ret);
 929   idealreg2regmask[Op_VecZ] = regmask_for_ideal_register(Op_VecZ, ret);
 930 }
 931 
 932 #ifdef ASSERT
 933 static void match_alias_type(Compile* C, Node* n, Node* m) {
 934   if (!VerifyAliases)  return;  // do not go looking for trouble by default
 935   const TypePtr* nat = n-&gt;adr_type();
 936   const TypePtr* mat = m-&gt;adr_type();
 937   int nidx = C-&gt;get_alias_index(nat);
 938   int midx = C-&gt;get_alias_index(mat);
 939   // Detune the assert for cases like (AndI 0xFF (LoadB p)).
 940   if (nidx == Compile::AliasIdxTop &amp;&amp; midx &gt;= Compile::AliasIdxRaw) {
 941     for (uint i = 1; i &lt; n-&gt;req(); i++) {
 942       Node* n1 = n-&gt;in(i);
 943       const TypePtr* n1at = n1-&gt;adr_type();
 944       if (n1at != NULL) {
 945         nat = n1at;
 946         nidx = C-&gt;get_alias_index(n1at);
 947       }
 948     }
 949   }
 950   // %%% Kludgery.  Instead, fix ideal adr_type methods for all these cases:
 951   if (nidx == Compile::AliasIdxTop &amp;&amp; midx == Compile::AliasIdxRaw) {
 952     switch (n-&gt;Opcode()) {
 953     case Op_PrefetchAllocation:
 954       nidx = Compile::AliasIdxRaw;
 955       nat = TypeRawPtr::BOTTOM;
 956       break;
 957     }
 958   }
 959   if (nidx == Compile::AliasIdxRaw &amp;&amp; midx == Compile::AliasIdxTop) {
 960     switch (n-&gt;Opcode()) {
 961     case Op_ClearArray:
 962       midx = Compile::AliasIdxRaw;
 963       mat = TypeRawPtr::BOTTOM;
 964       break;
 965     }
 966   }
 967   if (nidx == Compile::AliasIdxTop &amp;&amp; midx == Compile::AliasIdxBot) {
 968     switch (n-&gt;Opcode()) {
 969     case Op_Return:
 970     case Op_Rethrow:
 971     case Op_Halt:
 972     case Op_TailCall:
 973     case Op_TailJump:
 974       nidx = Compile::AliasIdxBot;
 975       nat = TypePtr::BOTTOM;
 976       break;
 977     }
 978   }
 979   if (nidx == Compile::AliasIdxBot &amp;&amp; midx == Compile::AliasIdxTop) {
 980     switch (n-&gt;Opcode()) {
 981     case Op_StrComp:
 982     case Op_StrEquals:
 983     case Op_StrIndexOf:
 984     case Op_StrIndexOfChar:
 985     case Op_AryEq:
 986     case Op_HasNegatives:
 987     case Op_MemBarVolatile:
 988     case Op_MemBarCPUOrder: // %%% these ideals should have narrower adr_type?
 989     case Op_StrInflatedCopy:
 990     case Op_StrCompressedCopy:
 991     case Op_OnSpinWait:
 992     case Op_EncodeISOArray:
 993       nidx = Compile::AliasIdxTop;
 994       nat = NULL;
 995       break;
 996     }
 997   }
 998   if (nidx != midx) {
 999     if (PrintOpto || (PrintMiscellaneous &amp;&amp; (WizardMode || Verbose))) {
1000       tty-&gt;print_cr(&quot;==== Matcher alias shift %d =&gt; %d&quot;, nidx, midx);
1001       n-&gt;dump();
1002       m-&gt;dump();
1003     }
1004     assert(C-&gt;subsume_loads() &amp;&amp; C-&gt;must_alias(nat, midx),
1005            &quot;must not lose alias info when matching&quot;);
1006   }
1007 }
1008 #endif
1009 
1010 //------------------------------xform------------------------------------------
1011 // Given a Node in old-space, Match him (Label/Reduce) to produce a machine
1012 // Node in new-space.  Given a new-space Node, recursively walk his children.
1013 Node *Matcher::transform( Node *n ) { ShouldNotCallThis(); return n; }
1014 Node *Matcher::xform( Node *n, int max_stack ) {
1015   // Use one stack to keep both: child&#39;s node/state and parent&#39;s node/index
1016   MStack mstack(max_stack * 2 * 2); // usually: C-&gt;live_nodes() * 2 * 2
1017   mstack.push(n, Visit, NULL, -1);  // set NULL as parent to indicate root
1018   while (mstack.is_nonempty()) {
1019     C-&gt;check_node_count(NodeLimitFudgeFactor, &quot;too many nodes matching instructions&quot;);
1020     if (C-&gt;failing()) return NULL;
1021     n = mstack.node();          // Leave node on stack
1022     Node_State nstate = mstack.state();
1023     if (nstate == Visit) {
1024       mstack.set_state(Post_Visit);
1025       Node *oldn = n;
1026       // Old-space or new-space check
1027       if (!C-&gt;node_arena()-&gt;contains(n)) {
1028         // Old space!
1029         Node* m;
1030         if (has_new_node(n)) {  // Not yet Label/Reduced
1031           m = new_node(n);
1032         } else {
1033           if (!is_dontcare(n)) { // Matcher can match this guy
1034             // Calls match special.  They match alone with no children.
1035             // Their children, the incoming arguments, match normally.
1036             m = n-&gt;is_SafePoint() ? match_sfpt(n-&gt;as_SafePoint()):match_tree(n);
1037             if (C-&gt;failing())  return NULL;
1038             if (m == NULL) { Matcher::soft_match_failure(); return NULL; }
1039             if (n-&gt;is_MemBar()) {
1040               m-&gt;as_MachMemBar()-&gt;set_adr_type(n-&gt;adr_type());
1041             }
1042           } else {                  // Nothing the matcher cares about
1043             if (n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_Multi()) {       // Projections?
1044               // Convert to machine-dependent projection
1045               RegMask* mask = NULL;
1046               if (n-&gt;in(0)-&gt;is_Call()) {
1047                 mask = return_values_mask(n-&gt;in(0)-&gt;as_Call()-&gt;tf()-&gt;range_cc());
1048               }
1049               m = n-&gt;in(0)-&gt;as_Multi()-&gt;match(n-&gt;as_Proj(), this, mask);
1050 #ifdef ASSERT
1051               _new2old_map.map(m-&gt;_idx, n);
1052 #endif
1053               if (m-&gt;in(0) != NULL) // m might be top
1054                 collect_null_checks(m, n);
1055             } else {                // Else just a regular &#39;ol guy
1056               m = n-&gt;clone();       // So just clone into new-space
1057 #ifdef ASSERT
1058               _new2old_map.map(m-&gt;_idx, n);
1059 #endif
1060               // Def-Use edges will be added incrementally as Uses
1061               // of this node are matched.
1062               assert(m-&gt;outcnt() == 0, &quot;no Uses of this clone yet&quot;);
1063             }
1064           }
1065 
1066           set_new_node(n, m);       // Map old to new
1067           if (_old_node_note_array != NULL) {
1068             Node_Notes* nn = C-&gt;locate_node_notes(_old_node_note_array,
1069                                                   n-&gt;_idx);
1070             C-&gt;set_node_notes_at(m-&gt;_idx, nn);
1071           }
1072           debug_only(match_alias_type(C, n, m));
1073         }
1074         n = m;    // n is now a new-space node
1075         mstack.set_node(n);
1076       }
1077 
1078       // New space!
1079       if (_visited.test_set(n-&gt;_idx)) continue; // while(mstack.is_nonempty())
1080 
1081       int i;
1082       // Put precedence edges on stack first (match them last).
1083       for (i = oldn-&gt;req(); (uint)i &lt; oldn-&gt;len(); i++) {
1084         Node *m = oldn-&gt;in(i);
1085         if (m == NULL) break;
1086         // set -1 to call add_prec() instead of set_req() during Step1
1087         mstack.push(m, Visit, n, -1);
1088       }
1089 
1090       // Handle precedence edges for interior nodes
1091       for (i = n-&gt;len()-1; (uint)i &gt;= n-&gt;req(); i--) {
1092         Node *m = n-&gt;in(i);
1093         if (m == NULL || C-&gt;node_arena()-&gt;contains(m)) continue;
1094         n-&gt;rm_prec(i);
1095         // set -1 to call add_prec() instead of set_req() during Step1
1096         mstack.push(m, Visit, n, -1);
1097       }
1098 
1099       // For constant debug info, I&#39;d rather have unmatched constants.
1100       int cnt = n-&gt;req();
1101       JVMState* jvms = n-&gt;jvms();
1102       int debug_cnt = jvms ? jvms-&gt;debug_start() : cnt;
1103 
1104       // Now do only debug info.  Clone constants rather than matching.
1105       // Constants are represented directly in the debug info without
1106       // the need for executable machine instructions.
1107       // Monitor boxes are also represented directly.
1108       for (i = cnt - 1; i &gt;= debug_cnt; --i) { // For all debug inputs do
1109         Node *m = n-&gt;in(i);          // Get input
1110         int op = m-&gt;Opcode();
1111         assert((op == Op_BoxLock) == jvms-&gt;is_monitor_use(i), &quot;boxes only at monitor sites&quot;);
1112         if( op == Op_ConI || op == Op_ConP || op == Op_ConN || op == Op_ConNKlass ||
1113             op == Op_ConF || op == Op_ConD || op == Op_ConL
1114             // || op == Op_BoxLock  // %%%% enable this and remove (+++) in chaitin.cpp
1115             ) {
1116           m = m-&gt;clone();
1117 #ifdef ASSERT
1118           _new2old_map.map(m-&gt;_idx, n);
1119 #endif
1120           mstack.push(m, Post_Visit, n, i); // Don&#39;t need to visit
1121           mstack.push(m-&gt;in(0), Visit, m, 0);
1122         } else {
1123           mstack.push(m, Visit, n, i);
1124         }
1125       }
1126 
1127       // And now walk his children, and convert his inputs to new-space.
1128       for( ; i &gt;= 0; --i ) { // For all normal inputs do
1129         Node *m = n-&gt;in(i);  // Get input
1130         if(m != NULL)
1131           mstack.push(m, Visit, n, i);
1132       }
1133 
1134     }
1135     else if (nstate == Post_Visit) {
1136       // Set xformed input
1137       Node *p = mstack.parent();
1138       if (p != NULL) { // root doesn&#39;t have parent
1139         int i = (int)mstack.index();
1140         if (i &gt;= 0)
1141           p-&gt;set_req(i, n); // required input
1142         else if (i == -1)
1143           p-&gt;add_prec(n);   // precedence input
1144         else
1145           ShouldNotReachHere();
1146       }
1147       mstack.pop(); // remove processed node from stack
1148     }
1149     else {
1150       ShouldNotReachHere();
1151     }
1152   } // while (mstack.is_nonempty())
1153   return n; // Return new-space Node
1154 }
1155 
1156 //------------------------------warp_outgoing_stk_arg------------------------
1157 OptoReg::Name Matcher::warp_outgoing_stk_arg( VMReg reg, OptoReg::Name begin_out_arg_area, OptoReg::Name &amp;out_arg_limit_per_call ) {
1158   // Convert outgoing argument location to a pre-biased stack offset
1159   if (reg-&gt;is_stack()) {
1160     OptoReg::Name warped = reg-&gt;reg2stack();
1161     // Adjust the stack slot offset to be the register number used
1162     // by the allocator.
1163     warped = OptoReg::add(begin_out_arg_area, warped);
1164     // Keep track of the largest numbered stack slot used for an arg.
1165     // Largest used slot per call-site indicates the amount of stack
1166     // that is killed by the call.
1167     if( warped &gt;= out_arg_limit_per_call )
1168       out_arg_limit_per_call = OptoReg::add(warped,1);
1169     if (!RegMask::can_represent_arg(warped)) {
1170       C-&gt;record_method_not_compilable(&quot;unsupported calling sequence&quot;);
1171       return OptoReg::Bad;
1172     }
1173     return warped;
1174   }
1175   return OptoReg::as_OptoReg(reg);
1176 }
1177 
1178 
1179 //------------------------------match_sfpt-------------------------------------
1180 // Helper function to match call instructions.  Calls match special.
1181 // They match alone with no children.  Their children, the incoming
1182 // arguments, match normally.
1183 MachNode *Matcher::match_sfpt( SafePointNode *sfpt ) {
1184   MachSafePointNode *msfpt = NULL;
1185   MachCallNode      *mcall = NULL;
1186   uint               cnt;
1187   // Split out case for SafePoint vs Call
1188   CallNode *call;
1189   const TypeTuple *domain;
1190   ciMethod*        method = NULL;
1191   bool             is_method_handle_invoke = false;  // for special kill effects
1192   if( sfpt-&gt;is_Call() ) {
1193     call = sfpt-&gt;as_Call();
1194     domain = call-&gt;tf()-&gt;domain_cc();
1195     cnt = domain-&gt;cnt();
1196 
1197     // Match just the call, nothing else
1198     MachNode *m = match_tree(call);
1199     if (C-&gt;failing())  return NULL;
1200     if( m == NULL ) { Matcher::soft_match_failure(); return NULL; }
1201 
1202     // Copy data from the Ideal SafePoint to the machine version
1203     mcall = m-&gt;as_MachCall();
1204 
1205     mcall-&gt;set_tf(         call-&gt;tf());
1206     mcall-&gt;set_entry_point(call-&gt;entry_point());
1207     mcall-&gt;set_cnt(        call-&gt;cnt());
1208 
1209     if( mcall-&gt;is_MachCallJava() ) {
1210       MachCallJavaNode *mcall_java  = mcall-&gt;as_MachCallJava();
1211       const CallJavaNode *call_java =  call-&gt;as_CallJava();
1212       assert(call_java-&gt;validate_symbolic_info(), &quot;inconsistent info&quot;);
1213       method = call_java-&gt;method();
1214       mcall_java-&gt;_method = method;
1215       mcall_java-&gt;_bci = call_java-&gt;_bci;
1216       mcall_java-&gt;_optimized_virtual = call_java-&gt;is_optimized_virtual();
1217       is_method_handle_invoke = call_java-&gt;is_method_handle_invoke();
1218       mcall_java-&gt;_method_handle_invoke = is_method_handle_invoke;
1219       mcall_java-&gt;_override_symbolic_info = call_java-&gt;override_symbolic_info();
1220       if (is_method_handle_invoke) {
1221         C-&gt;set_has_method_handle_invokes(true);
1222       }
1223       if( mcall_java-&gt;is_MachCallStaticJava() )
1224         mcall_java-&gt;as_MachCallStaticJava()-&gt;_name =
1225          call_java-&gt;as_CallStaticJava()-&gt;_name;
1226       if( mcall_java-&gt;is_MachCallDynamicJava() )
1227         mcall_java-&gt;as_MachCallDynamicJava()-&gt;_vtable_index =
1228          call_java-&gt;as_CallDynamicJava()-&gt;_vtable_index;
1229     }
1230     else if( mcall-&gt;is_MachCallRuntime() ) {
1231       mcall-&gt;as_MachCallRuntime()-&gt;_name = call-&gt;as_CallRuntime()-&gt;_name;
1232     }
1233     msfpt = mcall;
1234   }
1235   // This is a non-call safepoint
1236   else {
1237     call = NULL;
1238     domain = NULL;
1239     MachNode *mn = match_tree(sfpt);
1240     if (C-&gt;failing())  return NULL;
1241     msfpt = mn-&gt;as_MachSafePoint();
1242     cnt = TypeFunc::Parms;
1243   }
1244 
1245   // Advertise the correct memory effects (for anti-dependence computation).
1246   msfpt-&gt;set_adr_type(sfpt-&gt;adr_type());
1247 
1248   // Allocate a private array of RegMasks.  These RegMasks are not shared.
1249   msfpt-&gt;_in_rms = NEW_RESOURCE_ARRAY( RegMask, cnt );
1250   // Empty them all.
1251   for (uint i = 0; i &lt; cnt; i++) ::new (&amp;(msfpt-&gt;_in_rms[i])) RegMask();
1252 
1253   // Do all the pre-defined non-Empty register masks
1254   msfpt-&gt;_in_rms[TypeFunc::ReturnAdr] = _return_addr_mask;
1255   msfpt-&gt;_in_rms[TypeFunc::FramePtr ] = c_frame_ptr_mask;
1256 
1257   // Place first outgoing argument can possibly be put.
1258   OptoReg::Name begin_out_arg_area = OptoReg::add(_new_SP, C-&gt;out_preserve_stack_slots());
1259   assert( is_even(begin_out_arg_area), &quot;&quot; );
1260   // Compute max outgoing register number per call site.
1261   OptoReg::Name out_arg_limit_per_call = begin_out_arg_area;
1262   // Calls to C may hammer extra stack slots above and beyond any arguments.
1263   // These are usually backing store for register arguments for varargs.
1264   if( call != NULL &amp;&amp; call-&gt;is_CallRuntime() )
1265     out_arg_limit_per_call = OptoReg::add(out_arg_limit_per_call,C-&gt;varargs_C_out_slots_killed());
1266 
1267 
1268   // Do the normal argument list (parameters) register masks
1269   // Null entry point is a special cast where the target of the call
1270   // is in a register.
1271   int adj = (call != NULL &amp;&amp; call-&gt;entry_point() == NULL) ? 1 : 0;
1272   int argcnt = cnt - TypeFunc::Parms - adj;
1273   if( argcnt &gt; 0 ) {          // Skip it all if we have no args
1274     BasicType *sig_bt  = NEW_RESOURCE_ARRAY( BasicType, argcnt );
1275     VMRegPair *parm_regs = NEW_RESOURCE_ARRAY( VMRegPair, argcnt );
1276     int i;
1277     for( i = 0; i &lt; argcnt; i++ ) {
1278       sig_bt[i] = domain-&gt;field_at(i+TypeFunc::Parms+adj)-&gt;basic_type();
1279     }
1280     // V-call to pick proper calling convention
1281     call-&gt;calling_convention( sig_bt, parm_regs, argcnt );
1282 
1283 #ifdef ASSERT
1284     // Sanity check users&#39; calling convention.  Really handy during
1285     // the initial porting effort.  Fairly expensive otherwise.
1286     { for (int i = 0; i&lt;argcnt; i++) {
1287       if( !parm_regs[i].first()-&gt;is_valid() &amp;&amp;
1288           !parm_regs[i].second()-&gt;is_valid() ) continue;
1289       VMReg reg1 = parm_regs[i].first();
1290       VMReg reg2 = parm_regs[i].second();
1291       for (int j = 0; j &lt; i; j++) {
1292         if( !parm_regs[j].first()-&gt;is_valid() &amp;&amp;
1293             !parm_regs[j].second()-&gt;is_valid() ) continue;
1294         VMReg reg3 = parm_regs[j].first();
1295         VMReg reg4 = parm_regs[j].second();
1296         if( !reg1-&gt;is_valid() ) {
1297           assert( !reg2-&gt;is_valid(), &quot;valid halvsies&quot; );
1298         } else if( !reg3-&gt;is_valid() ) {
1299           assert( !reg4-&gt;is_valid(), &quot;valid halvsies&quot; );
1300         } else {
1301           assert( reg1 != reg2, &quot;calling conv. must produce distinct regs&quot;);
1302           assert( reg1 != reg3, &quot;calling conv. must produce distinct regs&quot;);
1303           assert( reg1 != reg4, &quot;calling conv. must produce distinct regs&quot;);
1304           assert( reg2 != reg3, &quot;calling conv. must produce distinct regs&quot;);
1305           assert( reg2 != reg4 || !reg2-&gt;is_valid(), &quot;calling conv. must produce distinct regs&quot;);
1306           assert( reg3 != reg4, &quot;calling conv. must produce distinct regs&quot;);
1307         }
1308       }
1309     }
1310     }
1311 #endif
1312 
1313     // Visit each argument.  Compute its outgoing register mask.
1314     // Return results now can have 2 bits returned.
1315     // Compute max over all outgoing arguments both per call-site
1316     // and over the entire method.
1317     for( i = 0; i &lt; argcnt; i++ ) {
1318       // Address of incoming argument mask to fill in
1319       RegMask *rm = &amp;mcall-&gt;_in_rms[i+TypeFunc::Parms+adj];
1320       if( !parm_regs[i].first()-&gt;is_valid() &amp;&amp;
1321           !parm_regs[i].second()-&gt;is_valid() ) {
1322         continue;               // Avoid Halves
1323       }
1324       // Grab first register, adjust stack slots and insert in mask.
1325       OptoReg::Name reg1 = warp_outgoing_stk_arg(parm_regs[i].first(), begin_out_arg_area, out_arg_limit_per_call );
1326       if (OptoReg::is_valid(reg1)) {
1327         rm-&gt;Insert( reg1 );
1328       }
1329       // Grab second register (if any), adjust stack slots and insert in mask.
1330       OptoReg::Name reg2 = warp_outgoing_stk_arg(parm_regs[i].second(), begin_out_arg_area, out_arg_limit_per_call );
1331       if (OptoReg::is_valid(reg2)) {
1332         rm-&gt;Insert( reg2 );
1333       }
1334     } // End of for all arguments
1335 
1336     // Compute number of stack slots needed to restore stack in case of
1337     // Pascal-style argument popping.
1338     mcall-&gt;_argsize = out_arg_limit_per_call - begin_out_arg_area;
1339   }
1340 
1341   // Compute the max stack slot killed by any call.  These will not be
1342   // available for debug info, and will be used to adjust FIRST_STACK_mask
1343   // after all call sites have been visited.
1344   if( _out_arg_limit &lt; out_arg_limit_per_call)
1345     _out_arg_limit = out_arg_limit_per_call;
1346 
1347   if (mcall) {
1348     // Kill the outgoing argument area, including any non-argument holes and
1349     // any legacy C-killed slots.  Use Fat-Projections to do the killing.
1350     // Since the max-per-method covers the max-per-call-site and debug info
1351     // is excluded on the max-per-method basis, debug info cannot land in
1352     // this killed area.
1353     uint r_cnt = mcall-&gt;tf()-&gt;range_sig()-&gt;cnt();
1354     MachProjNode *proj = new MachProjNode( mcall, r_cnt+10000, RegMask::Empty, MachProjNode::fat_proj );
1355     if (!RegMask::can_represent_arg(OptoReg::Name(out_arg_limit_per_call-1))) {
1356       C-&gt;record_method_not_compilable(&quot;unsupported outgoing calling sequence&quot;);
1357     } else {
1358       for (int i = begin_out_arg_area; i &lt; out_arg_limit_per_call; i++)
1359         proj-&gt;_rout.Insert(OptoReg::Name(i));
1360     }
1361     if (proj-&gt;_rout.is_NotEmpty()) {
1362       push_projection(proj);
1363     }
1364   }
1365   // Transfer the safepoint information from the call to the mcall
1366   // Move the JVMState list
1367   msfpt-&gt;set_jvms(sfpt-&gt;jvms());
1368   for (JVMState* jvms = msfpt-&gt;jvms(); jvms; jvms = jvms-&gt;caller()) {
1369     jvms-&gt;set_map(sfpt);
1370   }
1371 
1372   // Debug inputs begin just after the last incoming parameter
1373   assert((mcall == NULL) || (mcall-&gt;jvms() == NULL) ||
1374          (mcall-&gt;jvms()-&gt;debug_start() + mcall-&gt;_jvmadj == mcall-&gt;tf()-&gt;domain_cc()-&gt;cnt()), &quot;&quot;);
1375 
1376   // Move the OopMap
1377   msfpt-&gt;_oop_map = sfpt-&gt;_oop_map;
1378 
1379   // Add additional edges.
1380   if (msfpt-&gt;mach_constant_base_node_input() != (uint)-1 &amp;&amp; !msfpt-&gt;is_MachCallLeaf()) {
1381     // For these calls we can not add MachConstantBase in expand(), as the
1382     // ins are not complete then.
1383     msfpt-&gt;ins_req(msfpt-&gt;mach_constant_base_node_input(), C-&gt;mach_constant_base_node());
1384     if (msfpt-&gt;jvms() &amp;&amp;
1385         msfpt-&gt;mach_constant_base_node_input() &lt;= msfpt-&gt;jvms()-&gt;debug_start() + msfpt-&gt;_jvmadj) {
1386       // We added an edge before jvms, so we must adapt the position of the ins.
1387       msfpt-&gt;jvms()-&gt;adapt_position(+1);
1388     }
1389   }
1390 
1391   // Registers killed by the call are set in the local scheduling pass
1392   // of Global Code Motion.
1393   return msfpt;
1394 }
1395 
1396 //---------------------------match_tree----------------------------------------
1397 // Match a Ideal Node DAG - turn it into a tree; Label &amp; Reduce.  Used as part
1398 // of the whole-sale conversion from Ideal to Mach Nodes.  Also used for
1399 // making GotoNodes while building the CFG and in init_spill_mask() to identify
1400 // a Load&#39;s result RegMask for memoization in idealreg2regmask[]
1401 MachNode *Matcher::match_tree( const Node *n ) {
1402   assert( n-&gt;Opcode() != Op_Phi, &quot;cannot match&quot; );
1403   assert( !n-&gt;is_block_start(), &quot;cannot match&quot; );
1404   // Set the mark for all locally allocated State objects.
1405   // When this call returns, the _states_arena arena will be reset
1406   // freeing all State objects.
1407   ResourceMark rm( &amp;_states_arena );
1408 
1409   LabelRootDepth = 0;
1410 
1411   // StoreNodes require their Memory input to match any LoadNodes
1412   Node *mem = n-&gt;is_Store() ? n-&gt;in(MemNode::Memory) : (Node*)1 ;
1413 #ifdef ASSERT
1414   Node* save_mem_node = _mem_node;
1415   _mem_node = n-&gt;is_Store() ? (Node*)n : NULL;
1416 #endif
1417   // State object for root node of match tree
1418   // Allocate it on _states_arena - stack allocation can cause stack overflow.
1419   State *s = new (&amp;_states_arena) State;
1420   s-&gt;_kids[0] = NULL;
1421   s-&gt;_kids[1] = NULL;
1422   s-&gt;_leaf = (Node*)n;
1423   // Label the input tree, allocating labels from top-level arena
1424   Label_Root( n, s, n-&gt;in(0), mem );
1425   if (C-&gt;failing())  return NULL;
1426 
1427   // The minimum cost match for the whole tree is found at the root State
1428   uint mincost = max_juint;
1429   uint cost = max_juint;
1430   uint i;
1431   for( i = 0; i &lt; NUM_OPERANDS; i++ ) {
1432     if( s-&gt;valid(i) &amp;&amp;                // valid entry and
1433         s-&gt;_cost[i] &lt; cost &amp;&amp;         // low cost and
1434         s-&gt;_rule[i] &gt;= NUM_OPERANDS ) // not an operand
1435       cost = s-&gt;_cost[mincost=i];
1436   }
1437   if (mincost == max_juint) {
1438 #ifndef PRODUCT
1439     tty-&gt;print(&quot;No matching rule for:&quot;);
1440     s-&gt;dump();
1441 #endif
1442     Matcher::soft_match_failure();
1443     return NULL;
1444   }
1445   // Reduce input tree based upon the state labels to machine Nodes
1446   MachNode *m = ReduceInst( s, s-&gt;_rule[mincost], mem );
1447 #ifdef ASSERT
1448   _old2new_map.map(n-&gt;_idx, m);
1449   _new2old_map.map(m-&gt;_idx, (Node*)n);
1450 #endif
1451 
1452   // Add any Matcher-ignored edges
1453   uint cnt = n-&gt;req();
1454   uint start = 1;
1455   if( mem != (Node*)1 ) start = MemNode::Memory+1;
1456   if( n-&gt;is_AddP() ) {
1457     assert( mem == (Node*)1, &quot;&quot; );
1458     start = AddPNode::Base+1;
1459   }
1460   for( i = start; i &lt; cnt; i++ ) {
1461     if( !n-&gt;match_edge(i) ) {
1462       if( i &lt; m-&gt;req() )
1463         m-&gt;ins_req( i, n-&gt;in(i) );
1464       else
1465         m-&gt;add_req( n-&gt;in(i) );
1466     }
1467   }
1468 
1469   debug_only( _mem_node = save_mem_node; )
1470   return m;
1471 }
1472 
1473 
1474 //------------------------------match_into_reg---------------------------------
1475 // Choose to either match this Node in a register or part of the current
1476 // match tree.  Return true for requiring a register and false for matching
1477 // as part of the current match tree.
1478 static bool match_into_reg( const Node *n, Node *m, Node *control, int i, bool shared ) {
1479 
1480   const Type *t = m-&gt;bottom_type();
1481 
1482   if (t-&gt;singleton()) {
1483     // Never force constants into registers.  Allow them to match as
1484     // constants or registers.  Copies of the same value will share
1485     // the same register.  See find_shared_node.
1486     return false;
1487   } else {                      // Not a constant
1488     // Stop recursion if they have different Controls.
1489     Node* m_control = m-&gt;in(0);
1490     // Control of load&#39;s memory can post-dominates load&#39;s control.
1491     // So use it since load can&#39;t float above its memory.
1492     Node* mem_control = (m-&gt;is_Load()) ? m-&gt;in(MemNode::Memory)-&gt;in(0) : NULL;
1493     if (control &amp;&amp; m_control &amp;&amp; control != m_control &amp;&amp; control != mem_control) {
1494 
1495       // Actually, we can live with the most conservative control we
1496       // find, if it post-dominates the others.  This allows us to
1497       // pick up load/op/store trees where the load can float a little
1498       // above the store.
1499       Node *x = control;
1500       const uint max_scan = 6;  // Arbitrary scan cutoff
1501       uint j;
1502       for (j=0; j&lt;max_scan; j++) {
1503         if (x-&gt;is_Region())     // Bail out at merge points
1504           return true;
1505         x = x-&gt;in(0);
1506         if (x == m_control)     // Does &#39;control&#39; post-dominate
1507           break;                // m-&gt;in(0)?  If so, we can use it
1508         if (x == mem_control)   // Does &#39;control&#39; post-dominate
1509           break;                // mem_control?  If so, we can use it
1510       }
1511       if (j == max_scan)        // No post-domination before scan end?
1512         return true;            // Then break the match tree up
1513     }
1514     if ((m-&gt;is_DecodeN() &amp;&amp; Matcher::narrow_oop_use_complex_address()) ||
1515         (m-&gt;is_DecodeNKlass() &amp;&amp; Matcher::narrow_klass_use_complex_address())) {
1516       // These are commonly used in address expressions and can
1517       // efficiently fold into them on X64 in some cases.
1518       return false;
1519     }
1520   }
1521 
1522   // Not forceable cloning.  If shared, put it into a register.
1523   return shared;
1524 }
1525 
1526 
1527 //------------------------------Instruction Selection--------------------------
1528 // Label method walks a &quot;tree&quot; of nodes, using the ADLC generated DFA to match
1529 // ideal nodes to machine instructions.  Trees are delimited by shared Nodes,
1530 // things the Matcher does not match (e.g., Memory), and things with different
1531 // Controls (hence forced into different blocks).  We pass in the Control
1532 // selected for this entire State tree.
1533 
1534 // The Matcher works on Trees, but an Intel add-to-memory requires a DAG: the
1535 // Store and the Load must have identical Memories (as well as identical
1536 // pointers).  Since the Matcher does not have anything for Memory (and
1537 // does not handle DAGs), I have to match the Memory input myself.  If the
1538 // Tree root is a Store, I require all Loads to have the identical memory.
1539 Node *Matcher::Label_Root( const Node *n, State *svec, Node *control, const Node *mem){
1540   // Since Label_Root is a recursive function, its possible that we might run
1541   // out of stack space.  See bugs 6272980 &amp; 6227033 for more info.
1542   LabelRootDepth++;
1543   if (LabelRootDepth &gt; MaxLabelRootDepth) {
1544     C-&gt;record_method_not_compilable(&quot;Out of stack space, increase MaxLabelRootDepth&quot;);
1545     return NULL;
1546   }
1547   uint care = 0;                // Edges matcher cares about
1548   uint cnt = n-&gt;req();
1549   uint i = 0;
1550 
1551   // Examine children for memory state
1552   // Can only subsume a child into your match-tree if that child&#39;s memory state
1553   // is not modified along the path to another input.
1554   // It is unsafe even if the other inputs are separate roots.
1555   Node *input_mem = NULL;
1556   for( i = 1; i &lt; cnt; i++ ) {
1557     if( !n-&gt;match_edge(i) ) continue;
1558     Node *m = n-&gt;in(i);         // Get ith input
1559     assert( m, &quot;expect non-null children&quot; );
1560     if( m-&gt;is_Load() ) {
1561       if( input_mem == NULL ) {
1562         input_mem = m-&gt;in(MemNode::Memory);
1563       } else if( input_mem != m-&gt;in(MemNode::Memory) ) {
1564         input_mem = NodeSentinel;
1565       }
1566     }
1567   }
1568 
1569   for( i = 1; i &lt; cnt; i++ ){// For my children
1570     if( !n-&gt;match_edge(i) ) continue;
1571     Node *m = n-&gt;in(i);         // Get ith input
1572     // Allocate states out of a private arena
1573     State *s = new (&amp;_states_arena) State;
1574     svec-&gt;_kids[care++] = s;
1575     assert( care &lt;= 2, &quot;binary only for now&quot; );
1576 
1577     // Recursively label the State tree.
1578     s-&gt;_kids[0] = NULL;
1579     s-&gt;_kids[1] = NULL;
1580     s-&gt;_leaf = m;
1581 
1582     // Check for leaves of the State Tree; things that cannot be a part of
1583     // the current tree.  If it finds any, that value is matched as a
1584     // register operand.  If not, then the normal matching is used.
1585     if( match_into_reg(n, m, control, i, is_shared(m)) ||
1586         //
1587         // Stop recursion if this is LoadNode and the root of this tree is a
1588         // StoreNode and the load &amp; store have different memories.
1589         ((mem!=(Node*)1) &amp;&amp; m-&gt;is_Load() &amp;&amp; m-&gt;in(MemNode::Memory) != mem) ||
1590         // Can NOT include the match of a subtree when its memory state
1591         // is used by any of the other subtrees
1592         (input_mem == NodeSentinel) ) {
1593       // Print when we exclude matching due to different memory states at input-loads
1594       if (PrintOpto &amp;&amp; (Verbose &amp;&amp; WizardMode) &amp;&amp; (input_mem == NodeSentinel)
1595         &amp;&amp; !((mem!=(Node*)1) &amp;&amp; m-&gt;is_Load() &amp;&amp; m-&gt;in(MemNode::Memory) != mem)) {
1596         tty-&gt;print_cr(&quot;invalid input_mem&quot;);
1597       }
1598       // Switch to a register-only opcode; this value must be in a register
1599       // and cannot be subsumed as part of a larger instruction.
1600       s-&gt;DFA( m-&gt;ideal_reg(), m );
1601 
1602     } else {
1603       // If match tree has no control and we do, adopt it for entire tree
1604       if( control == NULL &amp;&amp; m-&gt;in(0) != NULL &amp;&amp; m-&gt;req() &gt; 1 )
1605         control = m-&gt;in(0);         // Pick up control
1606       // Else match as a normal part of the match tree.
1607       control = Label_Root(m,s,control,mem);
1608       if (C-&gt;failing()) return NULL;
1609     }
1610   }
1611 
1612 
1613   // Call DFA to match this node, and return
1614   svec-&gt;DFA( n-&gt;Opcode(), n );
1615 
1616 #ifdef ASSERT
1617   uint x;
1618   for( x = 0; x &lt; _LAST_MACH_OPER; x++ )
1619     if( svec-&gt;valid(x) )
1620       break;
1621 
1622   if (x &gt;= _LAST_MACH_OPER) {
1623     n-&gt;dump();
1624     svec-&gt;dump();
1625     assert( false, &quot;bad AD file&quot; );
1626   }
1627 #endif
1628   return control;
1629 }
1630 
1631 
1632 // Con nodes reduced using the same rule can share their MachNode
1633 // which reduces the number of copies of a constant in the final
1634 // program.  The register allocator is free to split uses later to
1635 // split live ranges.
1636 MachNode* Matcher::find_shared_node(Node* leaf, uint rule) {
1637   if (!leaf-&gt;is_Con() &amp;&amp; !leaf-&gt;is_DecodeNarrowPtr()) return NULL;
1638 
1639   // See if this Con has already been reduced using this rule.
1640   if (_shared_nodes.Size() &lt;= leaf-&gt;_idx) return NULL;
1641   MachNode* last = (MachNode*)_shared_nodes.at(leaf-&gt;_idx);
1642   if (last != NULL &amp;&amp; rule == last-&gt;rule()) {
1643     // Don&#39;t expect control change for DecodeN
1644     if (leaf-&gt;is_DecodeNarrowPtr())
1645       return last;
1646     // Get the new space root.
1647     Node* xroot = new_node(C-&gt;root());
1648     if (xroot == NULL) {
1649       // This shouldn&#39;t happen give the order of matching.
1650       return NULL;
1651     }
1652 
1653     // Shared constants need to have their control be root so they
1654     // can be scheduled properly.
1655     Node* control = last-&gt;in(0);
1656     if (control != xroot) {
1657       if (control == NULL || control == C-&gt;root()) {
1658         last-&gt;set_req(0, xroot);
1659       } else {
1660         assert(false, &quot;unexpected control&quot;);
1661         return NULL;
1662       }
1663     }
1664     return last;
1665   }
1666   return NULL;
1667 }
1668 
1669 
1670 //------------------------------ReduceInst-------------------------------------
1671 // Reduce a State tree (with given Control) into a tree of MachNodes.
1672 // This routine (and it&#39;s cohort ReduceOper) convert Ideal Nodes into
1673 // complicated machine Nodes.  Each MachNode covers some tree of Ideal Nodes.
1674 // Each MachNode has a number of complicated MachOper operands; each
1675 // MachOper also covers a further tree of Ideal Nodes.
1676 
1677 // The root of the Ideal match tree is always an instruction, so we enter
1678 // the recursion here.  After building the MachNode, we need to recurse
1679 // the tree checking for these cases:
1680 // (1) Child is an instruction -
1681 //     Build the instruction (recursively), add it as an edge.
1682 //     Build a simple operand (register) to hold the result of the instruction.
1683 // (2) Child is an interior part of an instruction -
1684 //     Skip over it (do nothing)
1685 // (3) Child is the start of a operand -
1686 //     Build the operand, place it inside the instruction
1687 //     Call ReduceOper.
1688 MachNode *Matcher::ReduceInst( State *s, int rule, Node *&amp;mem ) {
1689   assert( rule &gt;= NUM_OPERANDS, &quot;called with operand rule&quot; );
1690 
1691   MachNode* shared_node = find_shared_node(s-&gt;_leaf, rule);
1692   if (shared_node != NULL) {
1693     return shared_node;
1694   }
1695 
1696   // Build the object to represent this state &amp; prepare for recursive calls
1697   MachNode *mach = s-&gt;MachNodeGenerator(rule);
1698   guarantee(mach != NULL, &quot;Missing MachNode&quot;);
1699   mach-&gt;_opnds[0] = s-&gt;MachOperGenerator(_reduceOp[rule]);
1700   assert( mach-&gt;_opnds[0] != NULL, &quot;Missing result operand&quot; );
1701   Node *leaf = s-&gt;_leaf;
1702   // Check for instruction or instruction chain rule
1703   if( rule &gt;= _END_INST_CHAIN_RULE || rule &lt; _BEGIN_INST_CHAIN_RULE ) {
1704     assert(C-&gt;node_arena()-&gt;contains(s-&gt;_leaf) || !has_new_node(s-&gt;_leaf),
1705            &quot;duplicating node that&#39;s already been matched&quot;);
1706     // Instruction
1707     mach-&gt;add_req( leaf-&gt;in(0) ); // Set initial control
1708     // Reduce interior of complex instruction
1709     ReduceInst_Interior( s, rule, mem, mach, 1 );
1710   } else {
1711     // Instruction chain rules are data-dependent on their inputs
1712     mach-&gt;add_req(0);             // Set initial control to none
1713     ReduceInst_Chain_Rule( s, rule, mem, mach );
1714   }
1715 
1716   // If a Memory was used, insert a Memory edge
1717   if( mem != (Node*)1 ) {
1718     mach-&gt;ins_req(MemNode::Memory,mem);
1719 #ifdef ASSERT
1720     // Verify adr type after matching memory operation
1721     const MachOper* oper = mach-&gt;memory_operand();
1722     if (oper != NULL &amp;&amp; oper != (MachOper*)-1) {
1723       // It has a unique memory operand.  Find corresponding ideal mem node.
1724       Node* m = NULL;
1725       if (leaf-&gt;is_Mem()) {
1726         m = leaf;
1727       } else {
1728         m = _mem_node;
1729         assert(m != NULL &amp;&amp; m-&gt;is_Mem(), &quot;expecting memory node&quot;);
1730       }
1731       const Type* mach_at = mach-&gt;adr_type();
1732       // DecodeN node consumed by an address may have different type
1733       // than its input. Don&#39;t compare types for such case.
1734       if (m-&gt;adr_type() != mach_at &amp;&amp;
1735           (m-&gt;in(MemNode::Address)-&gt;is_DecodeNarrowPtr() ||
1736            (m-&gt;in(MemNode::Address)-&gt;is_AddP() &amp;&amp;
1737             m-&gt;in(MemNode::Address)-&gt;in(AddPNode::Address)-&gt;is_DecodeNarrowPtr()) ||
1738            (m-&gt;in(MemNode::Address)-&gt;is_AddP() &amp;&amp;
1739             m-&gt;in(MemNode::Address)-&gt;in(AddPNode::Address)-&gt;is_AddP() &amp;&amp;
1740             m-&gt;in(MemNode::Address)-&gt;in(AddPNode::Address)-&gt;in(AddPNode::Address)-&gt;is_DecodeNarrowPtr()))) {
1741         mach_at = m-&gt;adr_type();
1742       }
1743       if (m-&gt;adr_type() != mach_at) {
1744         m-&gt;dump();
1745         tty-&gt;print_cr(&quot;mach:&quot;);
1746         mach-&gt;dump(1);
1747       }
1748       assert(m-&gt;adr_type() == mach_at, &quot;matcher should not change adr type&quot;);
1749     }
1750 #endif
1751   }
1752 
1753   // If the _leaf is an AddP, insert the base edge
1754   if (leaf-&gt;is_AddP()) {
1755     mach-&gt;ins_req(AddPNode::Base,leaf-&gt;in(AddPNode::Base));
1756   }
1757 
1758   uint number_of_projections_prior = number_of_projections();
1759 
1760   // Perform any 1-to-many expansions required
1761   MachNode *ex = mach-&gt;Expand(s, _projection_list, mem);
1762   if (ex != mach) {
1763     assert(ex-&gt;ideal_reg() == mach-&gt;ideal_reg(), &quot;ideal types should match&quot;);
1764     if( ex-&gt;in(1)-&gt;is_Con() )
1765       ex-&gt;in(1)-&gt;set_req(0, C-&gt;root());
1766     // Remove old node from the graph
1767     for( uint i=0; i&lt;mach-&gt;req(); i++ ) {
1768       mach-&gt;set_req(i,NULL);
1769     }
1770 #ifdef ASSERT
1771     _new2old_map.map(ex-&gt;_idx, s-&gt;_leaf);
1772 #endif
1773   }
1774 
1775   // PhaseChaitin::fixup_spills will sometimes generate spill code
1776   // via the matcher.  By the time, nodes have been wired into the CFG,
1777   // and any further nodes generated by expand rules will be left hanging
1778   // in space, and will not get emitted as output code.  Catch this.
1779   // Also, catch any new register allocation constraints (&quot;projections&quot;)
1780   // generated belatedly during spill code generation.
1781   if (_allocation_started) {
1782     guarantee(ex == mach, &quot;no expand rules during spill generation&quot;);
1783     guarantee(number_of_projections_prior == number_of_projections(), &quot;no allocation during spill generation&quot;);
1784   }
1785 
1786   if (leaf-&gt;is_Con() || leaf-&gt;is_DecodeNarrowPtr()) {
1787     // Record the con for sharing
1788     _shared_nodes.map(leaf-&gt;_idx, ex);
1789   }
1790 
1791   // Have mach nodes inherit GC barrier data
1792   if (leaf-&gt;is_LoadStore()) {
1793     mach-&gt;set_barrier_data(leaf-&gt;as_LoadStore()-&gt;barrier_data());
1794   } else if (leaf-&gt;is_Mem()) {
1795     mach-&gt;set_barrier_data(leaf-&gt;as_Mem()-&gt;barrier_data());
1796   }
1797 
1798   return ex;
1799 }
1800 
1801 void Matcher::handle_precedence_edges(Node* n, MachNode *mach) {
1802   for (uint i = n-&gt;req(); i &lt; n-&gt;len(); i++) {
1803     if (n-&gt;in(i) != NULL) {
1804       mach-&gt;add_prec(n-&gt;in(i));
1805     }
1806   }
1807 }
1808 
1809 void Matcher::ReduceInst_Chain_Rule( State *s, int rule, Node *&amp;mem, MachNode *mach ) {
1810   // &#39;op&#39; is what I am expecting to receive
1811   int op = _leftOp[rule];
1812   // Operand type to catch childs result
1813   // This is what my child will give me.
1814   int opnd_class_instance = s-&gt;_rule[op];
1815   // Choose between operand class or not.
1816   // This is what I will receive.
1817   int catch_op = (FIRST_OPERAND_CLASS &lt;= op &amp;&amp; op &lt; NUM_OPERANDS) ? opnd_class_instance : op;
1818   // New rule for child.  Chase operand classes to get the actual rule.
1819   int newrule = s-&gt;_rule[catch_op];
1820 
1821   if( newrule &lt; NUM_OPERANDS ) {
1822     // Chain from operand or operand class, may be output of shared node
1823     assert( 0 &lt;= opnd_class_instance &amp;&amp; opnd_class_instance &lt; NUM_OPERANDS,
1824             &quot;Bad AD file: Instruction chain rule must chain from operand&quot;);
1825     // Insert operand into array of operands for this instruction
1826     mach-&gt;_opnds[1] = s-&gt;MachOperGenerator(opnd_class_instance);
1827 
1828     ReduceOper( s, newrule, mem, mach );
1829   } else {
1830     // Chain from the result of an instruction
1831     assert( newrule &gt;= _LAST_MACH_OPER, &quot;Do NOT chain from internal operand&quot;);
1832     mach-&gt;_opnds[1] = s-&gt;MachOperGenerator(_reduceOp[catch_op]);
1833     Node *mem1 = (Node*)1;
1834     debug_only(Node *save_mem_node = _mem_node;)
1835     mach-&gt;add_req( ReduceInst(s, newrule, mem1) );
1836     debug_only(_mem_node = save_mem_node;)
1837   }
1838   return;
1839 }
1840 
1841 
1842 uint Matcher::ReduceInst_Interior( State *s, int rule, Node *&amp;mem, MachNode *mach, uint num_opnds ) {
1843   handle_precedence_edges(s-&gt;_leaf, mach);
1844 
1845   if( s-&gt;_leaf-&gt;is_Load() ) {
1846     Node *mem2 = s-&gt;_leaf-&gt;in(MemNode::Memory);
1847     assert( mem == (Node*)1 || mem == mem2, &quot;multiple Memories being matched at once?&quot; );
1848     debug_only( if( mem == (Node*)1 ) _mem_node = s-&gt;_leaf;)
1849     mem = mem2;
1850   }
1851   if( s-&gt;_leaf-&gt;in(0) != NULL &amp;&amp; s-&gt;_leaf-&gt;req() &gt; 1) {
1852     if( mach-&gt;in(0) == NULL )
1853       mach-&gt;set_req(0, s-&gt;_leaf-&gt;in(0));
1854   }
1855 
1856   // Now recursively walk the state tree &amp; add operand list.
1857   for( uint i=0; i&lt;2; i++ ) {   // binary tree
1858     State *newstate = s-&gt;_kids[i];
1859     if( newstate == NULL ) break;      // Might only have 1 child
1860     // &#39;op&#39; is what I am expecting to receive
1861     int op;
1862     if( i == 0 ) {
1863       op = _leftOp[rule];
1864     } else {
1865       op = _rightOp[rule];
1866     }
1867     // Operand type to catch childs result
1868     // This is what my child will give me.
1869     int opnd_class_instance = newstate-&gt;_rule[op];
1870     // Choose between operand class or not.
1871     // This is what I will receive.
1872     int catch_op = (op &gt;= FIRST_OPERAND_CLASS &amp;&amp; op &lt; NUM_OPERANDS) ? opnd_class_instance : op;
1873     // New rule for child.  Chase operand classes to get the actual rule.
1874     int newrule = newstate-&gt;_rule[catch_op];
1875 
1876     if( newrule &lt; NUM_OPERANDS ) { // Operand/operandClass or internalOp/instruction?
1877       // Operand/operandClass
1878       // Insert operand into array of operands for this instruction
1879       mach-&gt;_opnds[num_opnds++] = newstate-&gt;MachOperGenerator(opnd_class_instance);
1880       ReduceOper( newstate, newrule, mem, mach );
1881 
1882     } else {                    // Child is internal operand or new instruction
1883       if( newrule &lt; _LAST_MACH_OPER ) { // internal operand or instruction?
1884         // internal operand --&gt; call ReduceInst_Interior
1885         // Interior of complex instruction.  Do nothing but recurse.
1886         num_opnds = ReduceInst_Interior( newstate, newrule, mem, mach, num_opnds );
1887       } else {
1888         // instruction --&gt; call build operand(  ) to catch result
1889         //             --&gt; ReduceInst( newrule )
1890         mach-&gt;_opnds[num_opnds++] = s-&gt;MachOperGenerator(_reduceOp[catch_op]);
1891         Node *mem1 = (Node*)1;
1892         debug_only(Node *save_mem_node = _mem_node;)
1893         mach-&gt;add_req( ReduceInst( newstate, newrule, mem1 ) );
1894         debug_only(_mem_node = save_mem_node;)
1895       }
1896     }
1897     assert( mach-&gt;_opnds[num_opnds-1], &quot;&quot; );
1898   }
1899   return num_opnds;
1900 }
1901 
1902 // This routine walks the interior of possible complex operands.
1903 // At each point we check our children in the match tree:
1904 // (1) No children -
1905 //     We are a leaf; add _leaf field as an input to the MachNode
1906 // (2) Child is an internal operand -
1907 //     Skip over it ( do nothing )
1908 // (3) Child is an instruction -
1909 //     Call ReduceInst recursively and
1910 //     and instruction as an input to the MachNode
1911 void Matcher::ReduceOper( State *s, int rule, Node *&amp;mem, MachNode *mach ) {
1912   assert( rule &lt; _LAST_MACH_OPER, &quot;called with operand rule&quot; );
1913   State *kid = s-&gt;_kids[0];
1914   assert( kid == NULL || s-&gt;_leaf-&gt;in(0) == NULL, &quot;internal operands have no control&quot; );
1915 
1916   // Leaf?  And not subsumed?
1917   if( kid == NULL &amp;&amp; !_swallowed[rule] ) {
1918     mach-&gt;add_req( s-&gt;_leaf );  // Add leaf pointer
1919     return;                     // Bail out
1920   }
1921 
1922   if( s-&gt;_leaf-&gt;is_Load() ) {
1923     assert( mem == (Node*)1, &quot;multiple Memories being matched at once?&quot; );
1924     mem = s-&gt;_leaf-&gt;in(MemNode::Memory);
1925     debug_only(_mem_node = s-&gt;_leaf;)
1926   }
1927 
1928   handle_precedence_edges(s-&gt;_leaf, mach);
1929 
1930   if( s-&gt;_leaf-&gt;in(0) &amp;&amp; s-&gt;_leaf-&gt;req() &gt; 1) {
1931     if( !mach-&gt;in(0) )
1932       mach-&gt;set_req(0,s-&gt;_leaf-&gt;in(0));
1933     else {
1934       assert( s-&gt;_leaf-&gt;in(0) == mach-&gt;in(0), &quot;same instruction, differing controls?&quot; );
1935     }
1936   }
1937 
1938   for( uint i=0; kid != NULL &amp;&amp; i&lt;2; kid = s-&gt;_kids[1], i++ ) {   // binary tree
1939     int newrule;
1940     if( i == 0)
1941       newrule = kid-&gt;_rule[_leftOp[rule]];
1942     else
1943       newrule = kid-&gt;_rule[_rightOp[rule]];
1944 
1945     if( newrule &lt; _LAST_MACH_OPER ) { // Operand or instruction?
1946       // Internal operand; recurse but do nothing else
1947       ReduceOper( kid, newrule, mem, mach );
1948 
1949     } else {                    // Child is a new instruction
1950       // Reduce the instruction, and add a direct pointer from this
1951       // machine instruction to the newly reduced one.
1952       Node *mem1 = (Node*)1;
1953       debug_only(Node *save_mem_node = _mem_node;)
1954       mach-&gt;add_req( ReduceInst( kid, newrule, mem1 ) );
1955       debug_only(_mem_node = save_mem_node;)
1956     }
1957   }
1958 }
1959 
1960 
1961 // -------------------------------------------------------------------------
1962 // Java-Java calling convention
1963 // (what you use when Java calls Java)
1964 
1965 //------------------------------find_receiver----------------------------------
1966 // For a given signature, return the OptoReg for parameter 0.
1967 OptoReg::Name Matcher::find_receiver( bool is_outgoing ) {
1968   VMRegPair regs;
1969   BasicType sig_bt = T_OBJECT;
1970   calling_convention(&amp;sig_bt, &amp;regs, 1, is_outgoing);
1971   // Return argument 0 register.  In the LP64 build pointers
1972   // take 2 registers, but the VM wants only the &#39;main&#39; name.
1973   return OptoReg::as_OptoReg(regs.first());
1974 }
1975 
1976 // This function identifies sub-graphs in which a &#39;load&#39; node is
1977 // input to two different nodes, and such that it can be matched
1978 // with BMI instructions like blsi, blsr, etc.
1979 // Example : for b = -a[i] &amp; a[i] can be matched to blsi r32, m32.
1980 // The graph is (AndL (SubL Con0 LoadL*) LoadL*), where LoadL*
1981 // refers to the same node.
1982 #ifdef X86
1983 // Match the generic fused operations pattern (op1 (op2 Con{ConType} mop) mop)
1984 // This is a temporary solution until we make DAGs expressible in ADL.
1985 template&lt;typename ConType&gt;
1986 class FusedPatternMatcher {
1987   Node* _op1_node;
1988   Node* _mop_node;
1989   int _con_op;
1990 
1991   static int match_next(Node* n, int next_op, int next_op_idx) {
1992     if (n-&gt;in(1) == NULL || n-&gt;in(2) == NULL) {
1993       return -1;
1994     }
1995 
1996     if (next_op_idx == -1) { // n is commutative, try rotations
1997       if (n-&gt;in(1)-&gt;Opcode() == next_op) {
1998         return 1;
1999       } else if (n-&gt;in(2)-&gt;Opcode() == next_op) {
2000         return 2;
2001       }
2002     } else {
2003       assert(next_op_idx &gt; 0 &amp;&amp; next_op_idx &lt;= 2, &quot;Bad argument index&quot;);
2004       if (n-&gt;in(next_op_idx)-&gt;Opcode() == next_op) {
2005         return next_op_idx;
2006       }
2007     }
2008     return -1;
2009   }
2010 public:
2011   FusedPatternMatcher(Node* op1_node, Node *mop_node, int con_op) :
2012     _op1_node(op1_node), _mop_node(mop_node), _con_op(con_op) { }
2013 
2014   bool match(int op1, int op1_op2_idx,  // op1 and the index of the op1-&gt;op2 edge, -1 if op1 is commutative
2015              int op2, int op2_con_idx,  // op2 and the index of the op2-&gt;con edge, -1 if op2 is commutative
2016              typename ConType::NativeType con_value) {
2017     if (_op1_node-&gt;Opcode() != op1) {
2018       return false;
2019     }
2020     if (_mop_node-&gt;outcnt() &gt; 2) {
2021       return false;
2022     }
2023     op1_op2_idx = match_next(_op1_node, op2, op1_op2_idx);
2024     if (op1_op2_idx == -1) {
2025       return false;
2026     }
2027     // Memory operation must be the other edge
2028     int op1_mop_idx = (op1_op2_idx &amp; 1) + 1;
2029 
2030     // Check that the mop node is really what we want
2031     if (_op1_node-&gt;in(op1_mop_idx) == _mop_node) {
2032       Node *op2_node = _op1_node-&gt;in(op1_op2_idx);
2033       if (op2_node-&gt;outcnt() &gt; 1) {
2034         return false;
2035       }
2036       assert(op2_node-&gt;Opcode() == op2, &quot;Should be&quot;);
2037       op2_con_idx = match_next(op2_node, _con_op, op2_con_idx);
2038       if (op2_con_idx == -1) {
2039         return false;
2040       }
2041       // Memory operation must be the other edge
2042       int op2_mop_idx = (op2_con_idx &amp; 1) + 1;
2043       // Check that the memory operation is the same node
2044       if (op2_node-&gt;in(op2_mop_idx) == _mop_node) {
2045         // Now check the constant
2046         const Type* con_type = op2_node-&gt;in(op2_con_idx)-&gt;bottom_type();
2047         if (con_type != Type::TOP &amp;&amp; ConType::as_self(con_type)-&gt;get_con() == con_value) {
2048           return true;
2049         }
2050       }
2051     }
2052     return false;
2053   }
2054 };
2055 
2056 
2057 bool Matcher::is_bmi_pattern(Node *n, Node *m) {
2058   if (n != NULL &amp;&amp; m != NULL) {
2059     if (m-&gt;Opcode() == Op_LoadI) {
2060       FusedPatternMatcher&lt;TypeInt&gt; bmii(n, m, Op_ConI);
2061       return bmii.match(Op_AndI, -1, Op_SubI,  1,  0)  ||
2062              bmii.match(Op_AndI, -1, Op_AddI, -1, -1)  ||
2063              bmii.match(Op_XorI, -1, Op_AddI, -1, -1);
2064     } else if (m-&gt;Opcode() == Op_LoadL) {
2065       FusedPatternMatcher&lt;TypeLong&gt; bmil(n, m, Op_ConL);
2066       return bmil.match(Op_AndL, -1, Op_SubL,  1,  0) ||
2067              bmil.match(Op_AndL, -1, Op_AddL, -1, -1) ||
2068              bmil.match(Op_XorL, -1, Op_AddL, -1, -1);
2069     }
2070   }
2071   return false;
2072 }
2073 #endif // X86
2074 
2075 bool Matcher::is_vshift_con_pattern(Node *n, Node *m) {
2076   if (n != NULL &amp;&amp; m != NULL) {
2077     return VectorNode::is_vector_shift(n) &amp;&amp;
2078            VectorNode::is_vector_shift_count(m) &amp;&amp; m-&gt;in(1)-&gt;is_Con();
2079   }
2080   return false;
2081 }
2082 
2083 
2084 bool Matcher::clone_base_plus_offset_address(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
2085   Node *off = m-&gt;in(AddPNode::Offset);
2086   if (off-&gt;is_Con()) {
2087     address_visited.test_set(m-&gt;_idx); // Flag as address_visited
2088     mstack.push(m-&gt;in(AddPNode::Address), Pre_Visit);
2089     // Clone X+offset as it also folds into most addressing expressions
2090     mstack.push(off, Visit);
2091     mstack.push(m-&gt;in(AddPNode::Base), Pre_Visit);
2092     return true;
2093   }
2094   return false;
2095 }
2096 
2097 // A method-klass-holder may be passed in the inline_cache_reg
2098 // and then expanded into the inline_cache_reg and a method_oop register
2099 //   defined in ad_&lt;arch&gt;.cpp
2100 
2101 //------------------------------find_shared------------------------------------
2102 // Set bits if Node is shared or otherwise a root
2103 void Matcher::find_shared( Node *n ) {
2104   // Allocate stack of size C-&gt;live_nodes() * 2 to avoid frequent realloc
2105   MStack mstack(C-&gt;live_nodes() * 2);
2106   // Mark nodes as address_visited if they are inputs to an address expression
2107   VectorSet address_visited(Thread::current()-&gt;resource_area());
2108   mstack.push(n, Visit);     // Don&#39;t need to pre-visit root node
2109   while (mstack.is_nonempty()) {
2110     n = mstack.node();       // Leave node on stack
2111     Node_State nstate = mstack.state();
2112     uint nop = n-&gt;Opcode();
2113     if (nstate == Pre_Visit) {
2114       if (address_visited.test(n-&gt;_idx)) { // Visited in address already?
2115         // Flag as visited and shared now.
2116         set_visited(n);
2117       }
2118       if (is_visited(n)) {   // Visited already?
2119         // Node is shared and has no reason to clone.  Flag it as shared.
2120         // This causes it to match into a register for the sharing.
2121         set_shared(n);       // Flag as shared and
2122         if (n-&gt;is_DecodeNarrowPtr()) {
2123           // Oop field/array element loads must be shared but since
2124           // they are shared through a DecodeN they may appear to have
2125           // a single use so force sharing here.
2126           set_shared(n-&gt;in(1));
2127         }
2128         mstack.pop();        // remove node from stack
2129         continue;
2130       }
2131       nstate = Visit; // Not already visited; so visit now
2132     }
2133     if (nstate == Visit) {
2134       mstack.set_state(Post_Visit);
2135       set_visited(n);   // Flag as visited now
2136       bool mem_op = false;
2137       int mem_addr_idx = MemNode::Address;
2138       if (find_shared_visit(mstack, n, nop, mem_op, mem_addr_idx)) {
2139         continue;
2140       }
2141       for(int i = n-&gt;req() - 1; i &gt;= 0; --i) { // For my children
2142         Node *m = n-&gt;in(i); // Get ith input
2143         if (m == NULL) continue;  // Ignore NULLs
2144         uint mop = m-&gt;Opcode();
2145 
2146         // Must clone all producers of flags, or we will not match correctly.
2147         // Suppose a compare setting int-flags is shared (e.g., a switch-tree)
2148         // then it will match into an ideal Op_RegFlags.  Alas, the fp-flags
2149         // are also there, so we may match a float-branch to int-flags and
2150         // expect the allocator to haul the flags from the int-side to the
2151         // fp-side.  No can do.
2152         if( _must_clone[mop] ) {
2153           mstack.push(m, Visit);
2154           continue; // for(int i = ...)
2155         }
2156 
2157         // if &#39;n&#39; and &#39;m&#39; are part of a graph for BMI instruction, clone this node.
2158 #ifdef X86
2159         if (UseBMI1Instructions &amp;&amp; is_bmi_pattern(n, m)) {
2160           mstack.push(m, Visit);
2161           continue;
2162         }
2163 #endif
2164         if (is_vshift_con_pattern(n, m)) {
2165           mstack.push(m, Visit);
2166           continue;
2167         }
2168 
2169         // Clone addressing expressions as they are &quot;free&quot; in memory access instructions
2170         if (mem_op &amp;&amp; i == mem_addr_idx &amp;&amp; mop == Op_AddP &amp;&amp;
2171             // When there are other uses besides address expressions
2172             // put it on stack and mark as shared.
2173             !is_visited(m)) {
2174           // Some inputs for address expression are not put on stack
2175           // to avoid marking them as shared and forcing them into register
2176           // if they are used only in address expressions.
2177           // But they should be marked as shared if there are other uses
2178           // besides address expressions.
2179 
2180           if (clone_address_expressions(m-&gt;as_AddP(), mstack, address_visited)) {
2181             continue;
2182           }
2183         }   // if( mem_op &amp;&amp;
2184         mstack.push(m, Pre_Visit);
2185       }     // for(int i = ...)
2186     }
2187     else if (nstate == Alt_Post_Visit) {
2188       mstack.pop(); // Remove node from stack
2189       // We cannot remove the Cmp input from the Bool here, as the Bool may be
2190       // shared and all users of the Bool need to move the Cmp in parallel.
2191       // This leaves both the Bool and the If pointing at the Cmp.  To
2192       // prevent the Matcher from trying to Match the Cmp along both paths
2193       // BoolNode::match_edge always returns a zero.
2194 
2195       // We reorder the Op_If in a pre-order manner, so we can visit without
2196       // accidentally sharing the Cmp (the Bool and the If make 2 users).
2197       n-&gt;add_req( n-&gt;in(1)-&gt;in(1) ); // Add the Cmp next to the Bool
2198     }
2199     else if (nstate == Post_Visit) {
2200       mstack.pop(); // Remove node from stack
2201 
2202       // Now hack a few special opcodes
2203       uint opcode = n-&gt;Opcode();
2204       bool gc_handled = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;matcher_find_shared_post_visit(this, n, opcode);
2205       if (!gc_handled) {
2206         find_shared_post_visit(n, opcode);
2207       }
2208     }
2209     else {
2210       ShouldNotReachHere();
2211     }
2212   } // end of while (mstack.is_nonempty())
2213 }
2214 
2215 bool Matcher::find_shared_visit(MStack&amp; mstack, Node* n, uint opcode, bool&amp; mem_op, int&amp; mem_addr_idx) {
2216   switch(opcode) {  // Handle some opcodes special
2217     case Op_Phi:             // Treat Phis as shared roots
2218     case Op_Parm:
2219     case Op_Proj:            // All handled specially during matching
2220     case Op_SafePointScalarObject:
2221       set_shared(n);
2222       set_dontcare(n);
2223       break;
2224     case Op_If:
2225     case Op_CountedLoopEnd:
2226       mstack.set_state(Alt_Post_Visit); // Alternative way
2227       // Convert (If (Bool (CmpX A B))) into (If (Bool) (CmpX A B)).  Helps
2228       // with matching cmp/branch in 1 instruction.  The Matcher needs the
2229       // Bool and CmpX side-by-side, because it can only get at constants
2230       // that are at the leaves of Match trees, and the Bool&#39;s condition acts
2231       // as a constant here.
2232       mstack.push(n-&gt;in(1), Visit);         // Clone the Bool
2233       mstack.push(n-&gt;in(0), Pre_Visit);     // Visit control input
2234       return true; // while (mstack.is_nonempty())
2235     case Op_ConvI2D:         // These forms efficiently match with a prior
2236     case Op_ConvI2F:         //   Load but not a following Store
2237       if( n-&gt;in(1)-&gt;is_Load() &amp;&amp;        // Prior load
2238           n-&gt;outcnt() == 1 &amp;&amp;           // Not already shared
2239           n-&gt;unique_out()-&gt;is_Store() ) // Following store
2240         set_shared(n);       // Force it to be a root
2241       break;
2242     case Op_ReverseBytesI:
2243     case Op_ReverseBytesL:
2244       if( n-&gt;in(1)-&gt;is_Load() &amp;&amp;        // Prior load
2245           n-&gt;outcnt() == 1 )            // Not already shared
2246         set_shared(n);                  // Force it to be a root
2247       break;
2248     case Op_BoxLock:         // Cant match until we get stack-regs in ADLC
2249     case Op_IfFalse:
2250     case Op_IfTrue:
2251     case Op_MachProj:
2252     case Op_MergeMem:
2253     case Op_Catch:
2254     case Op_CatchProj:
2255     case Op_CProj:
2256     case Op_JumpProj:
2257     case Op_JProj:
2258     case Op_NeverBranch:
2259       set_dontcare(n);
2260       break;
2261     case Op_Jump:
2262       mstack.push(n-&gt;in(1), Pre_Visit);     // Switch Value (could be shared)
2263       mstack.push(n-&gt;in(0), Pre_Visit);     // Visit Control input
2264       return true;                             // while (mstack.is_nonempty())
2265     case Op_StrComp:
2266     case Op_StrEquals:
2267     case Op_StrIndexOf:
2268     case Op_StrIndexOfChar:
2269     case Op_AryEq:
2270     case Op_HasNegatives:
2271     case Op_StrInflatedCopy:
2272     case Op_StrCompressedCopy:
2273     case Op_EncodeISOArray:
2274     case Op_FmaD:
2275     case Op_FmaF:
2276     case Op_FmaVD:
2277     case Op_FmaVF:
2278       set_shared(n); // Force result into register (it will be anyways)
2279       break;
2280     case Op_ConP: {  // Convert pointers above the centerline to NUL
2281       TypeNode *tn = n-&gt;as_Type(); // Constants derive from type nodes
2282       const TypePtr* tp = tn-&gt;type()-&gt;is_ptr();
2283       if (tp-&gt;_ptr == TypePtr::AnyNull) {
2284         tn-&gt;set_type(TypePtr::NULL_PTR);
2285       }
2286       break;
2287     }
2288     case Op_ConN: {  // Convert narrow pointers above the centerline to NUL
2289       TypeNode *tn = n-&gt;as_Type(); // Constants derive from type nodes
2290       const TypePtr* tp = tn-&gt;type()-&gt;make_ptr();
2291       if (tp &amp;&amp; tp-&gt;_ptr == TypePtr::AnyNull) {
2292         tn-&gt;set_type(TypeNarrowOop::NULL_PTR);
2293       }
2294       break;
2295     }
2296     case Op_Binary:         // These are introduced in the Post_Visit state.
2297       ShouldNotReachHere();
2298       break;
2299     case Op_ClearArray:
2300     case Op_SafePoint:
2301       mem_op = true;
2302       break;
2303     default:
2304       if( n-&gt;is_Store() ) {
2305         // Do match stores, despite no ideal reg
2306         mem_op = true;
2307         break;
2308       }
2309       if( n-&gt;is_Mem() ) { // Loads and LoadStores
2310         mem_op = true;
2311         // Loads must be root of match tree due to prior load conflict
2312         if( C-&gt;subsume_loads() == false )
2313           set_shared(n);
2314       }
2315       // Fall into default case
2316       if( !n-&gt;ideal_reg() )
2317         set_dontcare(n);  // Unmatchable Nodes
2318   } // end_switch
2319   return false;
2320 }
2321 
2322 void Matcher::find_shared_post_visit(Node* n, uint opcode) {
2323   switch(opcode) {       // Handle some opcodes special
2324     case Op_StorePConditional:
2325     case Op_StoreIConditional:
2326     case Op_StoreLConditional:
2327     case Op_CompareAndExchangeB:
2328     case Op_CompareAndExchangeS:
2329     case Op_CompareAndExchangeI:
2330     case Op_CompareAndExchangeL:
2331     case Op_CompareAndExchangeP:
2332     case Op_CompareAndExchangeN:
2333     case Op_WeakCompareAndSwapB:
2334     case Op_WeakCompareAndSwapS:
2335     case Op_WeakCompareAndSwapI:
2336     case Op_WeakCompareAndSwapL:
2337     case Op_WeakCompareAndSwapP:
2338     case Op_WeakCompareAndSwapN:
2339     case Op_CompareAndSwapB:
2340     case Op_CompareAndSwapS:
2341     case Op_CompareAndSwapI:
2342     case Op_CompareAndSwapL:
2343     case Op_CompareAndSwapP:
2344     case Op_CompareAndSwapN: {   // Convert trinary to binary-tree
2345       Node* newval = n-&gt;in(MemNode::ValueIn);
2346       Node* oldval = n-&gt;in(LoadStoreConditionalNode::ExpectedIn);
2347       Node* pair = new BinaryNode(oldval, newval);
2348       n-&gt;set_req(MemNode::ValueIn, pair);
2349       n-&gt;del_req(LoadStoreConditionalNode::ExpectedIn);
2350       break;
2351     }
2352     case Op_CMoveD:              // Convert trinary to binary-tree
2353     case Op_CMoveF:
2354     case Op_CMoveI:
2355     case Op_CMoveL:
2356     case Op_CMoveN:
2357     case Op_CMoveP:
2358     case Op_CMoveVF:
2359     case Op_CMoveVD:  {
2360       // Restructure into a binary tree for Matching.  It&#39;s possible that
2361       // we could move this code up next to the graph reshaping for IfNodes
2362       // or vice-versa, but I do not want to debug this for Ladybird.
2363       // 10/2/2000 CNC.
2364       Node* pair1 = new BinaryNode(n-&gt;in(1), n-&gt;in(1)-&gt;in(1));
2365       n-&gt;set_req(1, pair1);
2366       Node* pair2 = new BinaryNode(n-&gt;in(2), n-&gt;in(3));
2367       n-&gt;set_req(2, pair2);
2368       n-&gt;del_req(3);
2369       break;
2370     }
2371     case Op_LoopLimit: {
2372       Node* pair1 = new BinaryNode(n-&gt;in(1), n-&gt;in(2));
2373       n-&gt;set_req(1, pair1);
2374       n-&gt;set_req(2, n-&gt;in(3));
2375       n-&gt;del_req(3);
2376       break;
2377     }
2378     case Op_StrEquals:
2379     case Op_StrIndexOfChar: {
2380       Node* pair1 = new BinaryNode(n-&gt;in(2), n-&gt;in(3));
2381       n-&gt;set_req(2, pair1);
2382       n-&gt;set_req(3, n-&gt;in(4));
2383       n-&gt;del_req(4);
2384       break;
2385     }
2386     case Op_StrComp:
2387     case Op_StrIndexOf: {
2388       Node* pair1 = new BinaryNode(n-&gt;in(2), n-&gt;in(3));
2389       n-&gt;set_req(2, pair1);
2390       Node* pair2 = new BinaryNode(n-&gt;in(4),n-&gt;in(5));
2391       n-&gt;set_req(3, pair2);
2392       n-&gt;del_req(5);
2393       n-&gt;del_req(4);
2394       break;
2395     }
2396     case Op_StrCompressedCopy:
2397     case Op_StrInflatedCopy:
2398     case Op_EncodeISOArray: {
2399       // Restructure into a binary tree for Matching.
2400       Node* pair = new BinaryNode(n-&gt;in(3), n-&gt;in(4));
2401       n-&gt;set_req(3, pair);
2402       n-&gt;del_req(4);
2403       break;
2404     }
2405     case Op_FmaD:
2406     case Op_FmaF:
2407     case Op_FmaVD:
2408     case Op_FmaVF: {
2409       // Restructure into a binary tree for Matching.
2410       Node* pair = new BinaryNode(n-&gt;in(1), n-&gt;in(2));
2411       n-&gt;set_req(2, pair);
2412       n-&gt;set_req(1, n-&gt;in(3));
2413       n-&gt;del_req(3);
2414       break;
2415     }
2416     case Op_MulAddS2I: {
2417       Node* pair1 = new BinaryNode(n-&gt;in(1), n-&gt;in(2));
2418       Node* pair2 = new BinaryNode(n-&gt;in(3), n-&gt;in(4));
2419       n-&gt;set_req(1, pair1);
2420       n-&gt;set_req(2, pair2);
2421       n-&gt;del_req(4);
2422       n-&gt;del_req(3);
2423       break;
2424     }
2425     case Op_ClearArray: {
2426       Node* pair = new BinaryNode(n-&gt;in(2), n-&gt;in(3));
2427       n-&gt;set_req(2, pair);
2428       n-&gt;set_req(3, n-&gt;in(4));
2429       n-&gt;del_req(4);
2430       break;
2431     }
2432     default:
2433       break;
2434   }
2435 }
2436 
2437 #ifdef ASSERT
2438 // machine-independent root to machine-dependent root
2439 void Matcher::dump_old2new_map() {
2440   _old2new_map.dump();
2441 }
2442 #endif
2443 
2444 //---------------------------collect_null_checks-------------------------------
2445 // Find null checks in the ideal graph; write a machine-specific node for
2446 // it.  Used by later implicit-null-check handling.  Actually collects
2447 // either an IfTrue or IfFalse for the common NOT-null path, AND the ideal
2448 // value being tested.
2449 void Matcher::collect_null_checks( Node *proj, Node *orig_proj ) {
2450   Node *iff = proj-&gt;in(0);
2451   if( iff-&gt;Opcode() == Op_If ) {
2452     // During matching If&#39;s have Bool &amp; Cmp side-by-side
2453     BoolNode *b = iff-&gt;in(1)-&gt;as_Bool();
2454     Node *cmp = iff-&gt;in(2);
2455     int opc = cmp-&gt;Opcode();
2456     if (opc != Op_CmpP &amp;&amp; opc != Op_CmpN) return;
2457 
2458     const Type* ct = cmp-&gt;in(2)-&gt;bottom_type();
2459     if (ct == TypePtr::NULL_PTR ||
2460         (opc == Op_CmpN &amp;&amp; ct == TypeNarrowOop::NULL_PTR)) {
2461 
2462       bool push_it = false;
2463       if( proj-&gt;Opcode() == Op_IfTrue ) {
2464 #ifndef PRODUCT
2465         extern int all_null_checks_found;
2466         all_null_checks_found++;
2467 #endif
2468         if( b-&gt;_test._test == BoolTest::ne ) {
2469           push_it = true;
2470         }
2471       } else {
2472         assert( proj-&gt;Opcode() == Op_IfFalse, &quot;&quot; );
2473         if( b-&gt;_test._test == BoolTest::eq ) {
2474           push_it = true;
2475         }
2476       }
2477       if( push_it ) {
2478         _null_check_tests.push(proj);
2479         Node* val = cmp-&gt;in(1);
2480 #ifdef _LP64
2481         if (val-&gt;bottom_type()-&gt;isa_narrowoop() &amp;&amp;
2482             !Matcher::narrow_oop_use_complex_address()) {
2483           //
2484           // Look for DecodeN node which should be pinned to orig_proj.
2485           // On platforms (Sparc) which can not handle 2 adds
2486           // in addressing mode we have to keep a DecodeN node and
2487           // use it to do implicit NULL check in address.
2488           //
2489           // DecodeN node was pinned to non-null path (orig_proj) during
2490           // CastPP transformation in final_graph_reshaping_impl().
2491           //
2492           uint cnt = orig_proj-&gt;outcnt();
2493           for (uint i = 0; i &lt; orig_proj-&gt;outcnt(); i++) {
2494             Node* d = orig_proj-&gt;raw_out(i);
2495             if (d-&gt;is_DecodeN() &amp;&amp; d-&gt;in(1) == val) {
2496               val = d;
2497               val-&gt;set_req(0, NULL); // Unpin now.
2498               // Mark this as special case to distinguish from
2499               // a regular case: CmpP(DecodeN, NULL).
2500               val = (Node*)(((intptr_t)val) | 1);
2501               break;
2502             }
2503           }
2504         }
2505 #endif
2506         _null_check_tests.push(val);
2507       }
2508     }
2509   }
2510 }
2511 
2512 //---------------------------validate_null_checks------------------------------
2513 // Its possible that the value being NULL checked is not the root of a match
2514 // tree.  If so, I cannot use the value in an implicit null check.
2515 void Matcher::validate_null_checks( ) {
2516   uint cnt = _null_check_tests.size();
2517   for( uint i=0; i &lt; cnt; i+=2 ) {
2518     Node *test = _null_check_tests[i];
2519     Node *val = _null_check_tests[i+1];
2520     bool is_decoden = ((intptr_t)val) &amp; 1;
2521     val = (Node*)(((intptr_t)val) &amp; ~1);
2522     if (has_new_node(val)) {
2523       Node* new_val = new_node(val);
2524       if (is_decoden) {
2525         assert(val-&gt;is_DecodeNarrowPtr() &amp;&amp; val-&gt;in(0) == NULL, &quot;sanity&quot;);
2526         // Note: new_val may have a control edge if
2527         // the original ideal node DecodeN was matched before
2528         // it was unpinned in Matcher::collect_null_checks().
2529         // Unpin the mach node and mark it.
2530         new_val-&gt;set_req(0, NULL);
2531         new_val = (Node*)(((intptr_t)new_val) | 1);
2532       }
2533       // Is a match-tree root, so replace with the matched value
2534       _null_check_tests.map(i+1, new_val);
2535     } else {
2536       // Yank from candidate list
2537       _null_check_tests.map(i+1,_null_check_tests[--cnt]);
2538       _null_check_tests.map(i,_null_check_tests[--cnt]);
2539       _null_check_tests.pop();
2540       _null_check_tests.pop();
2541       i-=2;
2542     }
2543   }
2544 }
2545 
2546 bool Matcher::gen_narrow_oop_implicit_null_checks() {
2547   // Advice matcher to perform null checks on the narrow oop side.
2548   // Implicit checks are not possible on the uncompressed oop side anyway
2549   // (at least not for read accesses).
2550   // Performs significantly better (especially on Power 6).
2551   if (!os::zero_page_read_protected()) {
2552     return true;
2553   }
2554   return CompressedOops::use_implicit_null_checks() &amp;&amp;
2555          (narrow_oop_use_complex_address() ||
2556           CompressedOops::base() != NULL);
2557 }
2558 
2559 // Compute RegMask for an ideal register.
2560 const RegMask* Matcher::regmask_for_ideal_register(uint ideal_reg, Node* ret) {
2561   const Type* t = Type::mreg2type[ideal_reg];
2562   if (t == NULL) {
2563     assert(ideal_reg &gt;= Op_VecS &amp;&amp; ideal_reg &lt;= Op_VecZ, &quot;not a vector: %d&quot;, ideal_reg);
2564     return NULL; // not supported
2565   }
2566   Node* fp  = ret-&gt;in(TypeFunc::FramePtr);
2567   Node* mem = ret-&gt;in(TypeFunc::Memory);
2568   const TypePtr* atp = TypePtr::BOTTOM;
2569   MemNode::MemOrd mo = MemNode::unordered;
2570 
2571   Node* spill;
2572   switch (ideal_reg) {
2573     case Op_RegN: spill = new LoadNNode(NULL, mem, fp, atp, t-&gt;is_narrowoop(), mo); break;
2574     case Op_RegI: spill = new LoadINode(NULL, mem, fp, atp, t-&gt;is_int(),       mo); break;
2575     case Op_RegP: spill = new LoadPNode(NULL, mem, fp, atp, t-&gt;is_ptr(),       mo); break;
2576     case Op_RegF: spill = new LoadFNode(NULL, mem, fp, atp, t,                 mo); break;
2577     case Op_RegD: spill = new LoadDNode(NULL, mem, fp, atp, t,                 mo); break;
2578     case Op_RegL: spill = new LoadLNode(NULL, mem, fp, atp, t-&gt;is_long(),      mo); break;
2579 
2580     case Op_VecS: // fall-through
2581     case Op_VecD: // fall-through
2582     case Op_VecX: // fall-through
2583     case Op_VecY: // fall-through
2584     case Op_VecZ: spill = new LoadVectorNode(NULL, mem, fp, atp, t-&gt;is_vect()); break;
2585 
2586     default: ShouldNotReachHere();
2587   }
2588   MachNode* mspill = match_tree(spill);
2589   assert(mspill != NULL, &quot;matching failed: %d&quot;, ideal_reg);
2590   // Handle generic vector operand case
2591   if (Matcher::supports_generic_vector_operands &amp;&amp; t-&gt;isa_vect()) {
2592     specialize_mach_node(mspill);
2593   }
2594   return &amp;mspill-&gt;out_RegMask();
2595 }
2596 
2597 // Process Mach IR right after selection phase is over.
2598 void Matcher::do_postselect_cleanup() {
2599   if (supports_generic_vector_operands) {
2600     specialize_generic_vector_operands();
2601     if (C-&gt;failing())  return;
2602   }
2603 }
2604 
2605 //----------------------------------------------------------------------
2606 // Generic machine operands elision.
2607 //----------------------------------------------------------------------
2608 
2609 // Convert (leg)Vec to (leg)Vec[SDXYZ].
2610 MachOper* Matcher::specialize_vector_operand_helper(MachNode* m, uint opnd_idx, const TypeVect* vt) {
2611   MachOper* original_opnd = m-&gt;_opnds[opnd_idx];
2612   uint ideal_reg = vt-&gt;ideal_reg();
2613   // Handle special cases.
2614   // LShiftCntV/RShiftCntV report wide vector type, but Matcher::vector_shift_count_ideal_reg() as ideal register (see vectornode.hpp).
2615   // Look for shift count use sites as well (at vector shift nodes).
2616   int opc = m-&gt;ideal_Opcode();
2617   if ((VectorNode::is_vector_shift_count(opc)  &amp;&amp; opnd_idx == 0) || // DEF operand of LShiftCntV/RShiftCntV
2618       (VectorNode::is_vector_shift(opc)        &amp;&amp; opnd_idx == 2)) { // shift operand of a vector shift node
2619     ideal_reg = Matcher::vector_shift_count_ideal_reg(vt-&gt;length_in_bytes());
2620   }
2621   return Matcher::specialize_generic_vector_operand(original_opnd, ideal_reg, false);
2622 }
2623 
2624 // Compute concrete vector operand for a generic TEMP vector mach node based on its user info.
2625 void Matcher::specialize_temp_node(MachTempNode* tmp, MachNode* use, uint idx) {
2626   assert(use-&gt;in(idx) == tmp, &quot;not a user&quot;);
2627   assert(!Matcher::is_generic_vector(use-&gt;_opnds[0]), &quot;use not processed yet&quot;);
2628 
2629   if ((uint)idx == use-&gt;two_adr()) { // DEF_TEMP case
2630     tmp-&gt;_opnds[0] = use-&gt;_opnds[0]-&gt;clone();
2631   } else {
2632     uint ideal_vreg = vector_ideal_reg(C-&gt;max_vector_size());
2633     tmp-&gt;_opnds[0] = specialize_generic_vector_operand(tmp-&gt;_opnds[0], ideal_vreg, true);
2634   }
2635 }
2636 
2637 // Compute concrete vector operand for a generic DEF/USE vector operand (of mach node m at index idx).
2638 MachOper* Matcher::specialize_vector_operand(MachNode* m, uint opnd_idx) {
2639   assert(Matcher::is_generic_vector(m-&gt;_opnds[opnd_idx]), &quot;repeated updates&quot;);
2640   Node* def = NULL;
2641   if (opnd_idx == 0) { // DEF
2642     def = m; // use mach node itself to compute vector operand type
2643   } else {
2644     int base_idx = m-&gt;operand_index(opnd_idx);
2645     def = m-&gt;in(base_idx);
2646     if (def-&gt;is_Mach()) {
2647       if (def-&gt;is_MachTemp() &amp;&amp; Matcher::is_generic_vector(def-&gt;as_Mach()-&gt;_opnds[0])) {
2648         specialize_temp_node(def-&gt;as_MachTemp(), m, base_idx); // MachTemp node use site
2649       } else if (is_generic_reg2reg_move(def-&gt;as_Mach())) {
2650         def = def-&gt;in(1); // skip over generic reg-to-reg moves
2651       }
2652     }
2653   }
2654   return specialize_vector_operand_helper(m, opnd_idx, def-&gt;bottom_type()-&gt;is_vect());
2655 }
2656 
2657 void Matcher::specialize_mach_node(MachNode* m) {
2658   assert(!m-&gt;is_MachTemp(), &quot;processed along with its user&quot;);
2659   // For generic use operands pull specific register class operands from
2660   // its def instruction&#39;s output operand (def operand).
2661   for (uint i = 0; i &lt; m-&gt;num_opnds(); i++) {
2662     if (Matcher::is_generic_vector(m-&gt;_opnds[i])) {
2663       m-&gt;_opnds[i] = specialize_vector_operand(m, i);
2664     }
2665   }
2666 }
2667 
2668 // Replace generic vector operands with concrete vector operands and eliminate generic reg-to-reg moves from the graph.
2669 void Matcher::specialize_generic_vector_operands() {
2670   assert(supports_generic_vector_operands, &quot;sanity&quot;);
2671   ResourceMark rm;
2672 
2673   if (C-&gt;max_vector_size() == 0) {
2674     return; // no vector instructions or operands
2675   }
2676   // Replace generic vector operands (vec/legVec) with concrete ones (vec[SDXYZ]/legVec[SDXYZ])
2677   // and remove reg-to-reg vector moves (MoveVec2Leg and MoveLeg2Vec).
2678   Unique_Node_List live_nodes;
2679   C-&gt;identify_useful_nodes(live_nodes);
2680 
2681   while (live_nodes.size() &gt; 0) {
2682     MachNode* m = live_nodes.pop()-&gt;isa_Mach();
2683     if (m != NULL) {
2684       if (Matcher::is_generic_reg2reg_move(m)) {
2685         // Register allocator properly handles vec &lt;=&gt; leg moves using register masks.
2686         int opnd_idx = m-&gt;operand_index(1);
2687         Node* def = m-&gt;in(opnd_idx);
2688         m-&gt;subsume_by(def, C);
2689       } else if (m-&gt;is_MachTemp()) {
2690         // process MachTemp nodes at use site (see Matcher::specialize_vector_operand)
2691       } else {
2692         specialize_mach_node(m);
2693       }
2694     }
2695   }
2696 }
2697 
2698 #ifdef ASSERT
2699 bool Matcher::verify_after_postselect_cleanup() {
2700   assert(!C-&gt;failing(), &quot;sanity&quot;);
2701   if (supports_generic_vector_operands) {
2702     Unique_Node_List useful;
2703     C-&gt;identify_useful_nodes(useful);
2704     for (uint i = 0; i &lt; useful.size(); i++) {
2705       MachNode* m = useful.at(i)-&gt;isa_Mach();
2706       if (m != NULL) {
2707         assert(!Matcher::is_generic_reg2reg_move(m), &quot;no MoveVec nodes allowed&quot;);
2708         for (uint j = 0; j &lt; m-&gt;num_opnds(); j++) {
2709           assert(!Matcher::is_generic_vector(m-&gt;_opnds[j]), &quot;no generic vector operands allowed&quot;);
2710         }
2711       }
2712     }
2713   }
2714   return true;
2715 }
2716 #endif // ASSERT
2717 
2718 // Used by the DFA in dfa_xxx.cpp.  Check for a following barrier or
2719 // atomic instruction acting as a store_load barrier without any
2720 // intervening volatile load, and thus we don&#39;t need a barrier here.
2721 // We retain the Node to act as a compiler ordering barrier.
2722 bool Matcher::post_store_load_barrier(const Node* vmb) {
2723   Compile* C = Compile::current();
2724   assert(vmb-&gt;is_MemBar(), &quot;&quot;);
2725   assert(vmb-&gt;Opcode() != Op_MemBarAcquire &amp;&amp; vmb-&gt;Opcode() != Op_LoadFence, &quot;&quot;);
2726   const MemBarNode* membar = vmb-&gt;as_MemBar();
2727 
2728   // Get the Ideal Proj node, ctrl, that can be used to iterate forward
2729   Node* ctrl = NULL;
2730   for (DUIterator_Fast imax, i = membar-&gt;fast_outs(imax); i &lt; imax; i++) {
2731     Node* p = membar-&gt;fast_out(i);
2732     assert(p-&gt;is_Proj(), &quot;only projections here&quot;);
2733     if ((p-&gt;as_Proj()-&gt;_con == TypeFunc::Control) &amp;&amp;
2734         !C-&gt;node_arena()-&gt;contains(p)) { // Unmatched old-space only
2735       ctrl = p;
2736       break;
2737     }
2738   }
2739   assert((ctrl != NULL), &quot;missing control projection&quot;);
2740 
2741   for (DUIterator_Fast jmax, j = ctrl-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2742     Node *x = ctrl-&gt;fast_out(j);
2743     int xop = x-&gt;Opcode();
2744 
2745     // We don&#39;t need current barrier if we see another or a lock
2746     // before seeing volatile load.
2747     //
2748     // Op_Fastunlock previously appeared in the Op_* list below.
2749     // With the advent of 1-0 lock operations we&#39;re no longer guaranteed
2750     // that a monitor exit operation contains a serializing instruction.
2751 
2752     if (xop == Op_MemBarVolatile ||
2753         xop == Op_CompareAndExchangeB ||
2754         xop == Op_CompareAndExchangeS ||
2755         xop == Op_CompareAndExchangeI ||
2756         xop == Op_CompareAndExchangeL ||
2757         xop == Op_CompareAndExchangeP ||
2758         xop == Op_CompareAndExchangeN ||
2759         xop == Op_WeakCompareAndSwapB ||
2760         xop == Op_WeakCompareAndSwapS ||
2761         xop == Op_WeakCompareAndSwapL ||
2762         xop == Op_WeakCompareAndSwapP ||
2763         xop == Op_WeakCompareAndSwapN ||
2764         xop == Op_WeakCompareAndSwapI ||
2765         xop == Op_CompareAndSwapB ||
2766         xop == Op_CompareAndSwapS ||
2767         xop == Op_CompareAndSwapL ||
2768         xop == Op_CompareAndSwapP ||
2769         xop == Op_CompareAndSwapN ||
2770         xop == Op_CompareAndSwapI ||
2771         BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;matcher_is_store_load_barrier(x, xop)) {
2772       return true;
2773     }
2774 
2775     // Op_FastLock previously appeared in the Op_* list above.
2776     // With biased locking we&#39;re no longer guaranteed that a monitor
2777     // enter operation contains a serializing instruction.
2778     if ((xop == Op_FastLock) &amp;&amp; !UseBiasedLocking) {
2779       return true;
2780     }
2781 
2782     if (x-&gt;is_MemBar()) {
2783       // We must retain this membar if there is an upcoming volatile
2784       // load, which will be followed by acquire membar.
2785       if (xop == Op_MemBarAcquire || xop == Op_LoadFence) {
2786         return false;
2787       } else {
2788         // For other kinds of barriers, check by pretending we
2789         // are them, and seeing if we can be removed.
2790         return post_store_load_barrier(x-&gt;as_MemBar());
2791       }
2792     }
2793 
2794     // probably not necessary to check for these
2795     if (x-&gt;is_Call() || x-&gt;is_SafePoint() || x-&gt;is_block_proj()) {
2796       return false;
2797     }
2798   }
2799   return false;
2800 }
2801 
2802 // Check whether node n is a branch to an uncommon trap that we could
2803 // optimize as test with very high branch costs in case of going to
2804 // the uncommon trap. The code must be able to be recompiled to use
2805 // a cheaper test.
2806 bool Matcher::branches_to_uncommon_trap(const Node *n) {
2807   // Don&#39;t do it for natives, adapters, or runtime stubs
2808   Compile *C = Compile::current();
2809   if (!C-&gt;is_method_compilation()) return false;
2810 
2811   assert(n-&gt;is_If(), &quot;You should only call this on if nodes.&quot;);
2812   IfNode *ifn = n-&gt;as_If();
2813 
2814   Node *ifFalse = NULL;
2815   for (DUIterator_Fast imax, i = ifn-&gt;fast_outs(imax); i &lt; imax; i++) {
2816     if (ifn-&gt;fast_out(i)-&gt;is_IfFalse()) {
2817       ifFalse = ifn-&gt;fast_out(i);
2818       break;
2819     }
2820   }
2821   assert(ifFalse, &quot;An If should have an ifFalse. Graph is broken.&quot;);
2822 
2823   Node *reg = ifFalse;
2824   int cnt = 4; // We must protect against cycles.  Limit to 4 iterations.
2825                // Alternatively use visited set?  Seems too expensive.
2826   while (reg != NULL &amp;&amp; cnt &gt; 0) {
2827     CallNode *call = NULL;
2828     RegionNode *nxt_reg = NULL;
2829     for (DUIterator_Fast imax, i = reg-&gt;fast_outs(imax); i &lt; imax; i++) {
2830       Node *o = reg-&gt;fast_out(i);
2831       if (o-&gt;is_Call()) {
2832         call = o-&gt;as_Call();
2833       }
2834       if (o-&gt;is_Region()) {
2835         nxt_reg = o-&gt;as_Region();
2836       }
2837     }
2838 
2839     if (call &amp;&amp;
2840         call-&gt;entry_point() == SharedRuntime::uncommon_trap_blob()-&gt;entry_point()) {
2841       const Type* trtype = call-&gt;in(TypeFunc::Parms)-&gt;bottom_type();
2842       if (trtype-&gt;isa_int() &amp;&amp; trtype-&gt;is_int()-&gt;is_con()) {
2843         jint tr_con = trtype-&gt;is_int()-&gt;get_con();
2844         Deoptimization::DeoptReason reason = Deoptimization::trap_request_reason(tr_con);
2845         Deoptimization::DeoptAction action = Deoptimization::trap_request_action(tr_con);
2846         assert((int)reason &lt; (int)BitsPerInt, &quot;recode bit map&quot;);
2847 
2848         if (is_set_nth_bit(C-&gt;allowed_deopt_reasons(), (int)reason)
2849             &amp;&amp; action != Deoptimization::Action_none) {
2850           // This uncommon trap is sure to recompile, eventually.
2851           // When that happens, C-&gt;too_many_traps will prevent
2852           // this transformation from happening again.
2853           return true;
2854         }
2855       }
2856     }
2857 
2858     reg = nxt_reg;
2859     cnt--;
2860   }
2861 
2862   return false;
2863 }
2864 
2865 //=============================================================================
2866 //---------------------------State---------------------------------------------
2867 State::State(void) {
2868 #ifdef ASSERT
2869   _id = 0;
2870   _kids[0] = _kids[1] = (State*)(intptr_t) CONST64(0xcafebabecafebabe);
2871   _leaf = (Node*)(intptr_t) CONST64(0xbaadf00dbaadf00d);
2872   //memset(_cost, -1, sizeof(_cost));
2873   //memset(_rule, -1, sizeof(_rule));
2874 #endif
2875   memset(_valid, 0, sizeof(_valid));
2876 }
2877 
2878 #ifdef ASSERT
2879 State::~State() {
2880   _id = 99;
2881   _kids[0] = _kids[1] = (State*)(intptr_t) CONST64(0xcafebabecafebabe);
2882   _leaf = (Node*)(intptr_t) CONST64(0xbaadf00dbaadf00d);
2883   memset(_cost, -3, sizeof(_cost));
2884   memset(_rule, -3, sizeof(_rule));
2885 }
2886 #endif
2887 
2888 #ifndef PRODUCT
2889 //---------------------------dump----------------------------------------------
2890 void State::dump() {
2891   tty-&gt;print(&quot;\n&quot;);
2892   dump(0);
2893 }
2894 
2895 void State::dump(int depth) {
2896   for( int j = 0; j &lt; depth; j++ )
2897     tty-&gt;print(&quot;   &quot;);
2898   tty-&gt;print(&quot;--N: &quot;);
2899   _leaf-&gt;dump();
2900   uint i;
2901   for( i = 0; i &lt; _LAST_MACH_OPER; i++ )
2902     // Check for valid entry
2903     if( valid(i) ) {
2904       for( int j = 0; j &lt; depth; j++ )
2905         tty-&gt;print(&quot;   &quot;);
2906         assert(_cost[i] != max_juint, &quot;cost must be a valid value&quot;);
2907         assert(_rule[i] &lt; _last_Mach_Node, &quot;rule[i] must be valid rule&quot;);
2908         tty-&gt;print_cr(&quot;%s  %d  %s&quot;,
2909                       ruleName[i], _cost[i], ruleName[_rule[i]] );
2910       }
2911   tty-&gt;cr();
2912 
2913   for( i=0; i&lt;2; i++ )
2914     if( _kids[i] )
2915       _kids[i]-&gt;dump(depth+1);
2916 }
2917 #endif
    </pre>
  </body>
</html>
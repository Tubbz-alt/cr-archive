<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/node.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="node.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="output.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/node.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1179   void fast_dump() const {
1180     tty-&gt;print(&quot;%4d: %-17s&quot;, _idx, Name());
1181     for (uint i = 0; i &lt; len(); i++)
1182       if (in(i))
1183         tty-&gt;print(&quot; %4d&quot;, in(i)-&gt;_idx);
1184       else
1185         tty-&gt;print(&quot; NULL&quot;);
1186     tty-&gt;print(&quot;\n&quot;);
1187   }
1188 #endif
1189 #ifdef ASSERT
1190   void verify_construction();
1191   bool verify_jvms(const JVMState* jvms) const;
1192   int  _debug_idx;                     // Unique value assigned to every node.
1193   int   debug_idx() const              { return _debug_idx; }
1194   void  set_debug_idx( int debug_idx ) { _debug_idx = debug_idx; }
1195 
1196   Node* _debug_orig;                   // Original version of this, if any.
1197   Node*  debug_orig() const            { return _debug_orig; }
1198   void   set_debug_orig(Node* orig);   // _debug_orig = orig

1199 
1200   int        _hash_lock;               // Barrier to modifications of nodes in the hash table
1201   void  enter_hash_lock() { ++_hash_lock; assert(_hash_lock &lt; 99, &quot;in too many hash tables?&quot;); }
1202   void   exit_hash_lock() { --_hash_lock; assert(_hash_lock &gt;= 0, &quot;mispaired hash locks&quot;); }
1203 
1204   static void init_NodeProperty();
1205 
1206   #if OPTO_DU_ITERATOR_ASSERT
1207   const Node* _last_del;               // The last deleted node.
1208   uint        _del_tick;               // Bumped when a deletion happens..
1209   #endif
1210 #endif
1211 };
1212 
1213 
1214 #ifndef PRODUCT
1215 
1216 // Used in debugging code to avoid walking across dead or uninitialized edges.
1217 inline bool NotANode(const Node* n) {
1218   if (n == NULL)                   return true;
</pre>
<hr />
<pre>
1556   }
1557   Node *remove(uint i) {
1558     Node *b = Node_List::at(i);
1559     _in_worklist.remove(b-&gt;_idx);
1560     map(i,Node_List::pop());
1561     return b;
1562   }
1563   void yank(Node *n) {
1564     _in_worklist.remove(n-&gt;_idx);
1565     Node_List::yank(n);
1566   }
1567   void  clear() {
1568     _in_worklist.clear();        // Discards storage but grows automatically
1569     Node_List::clear();
1570     _clock_index = 0;
1571   }
1572 
1573   // Used after parsing to remove useless nodes before Iterative GVN
1574   void remove_useless_nodes(VectorSet&amp; useful);
1575 





1576 #ifndef PRODUCT
1577   void print_set() const { _in_worklist.print(); }
1578 #endif
1579 };
1580 
1581 // Inline definition of Compile::record_for_igvn must be deferred to this point.
1582 inline void Compile::record_for_igvn(Node* n) {
1583   _for_igvn-&gt;push(n);
1584 }
1585 
1586 //------------------------------Node_Stack-------------------------------------
1587 class Node_Stack {
1588   friend class VMStructs;
1589 protected:
1590   struct INode {
1591     Node *node; // Processed node
1592     uint  indx; // Index of next node&#39;s child
1593   };
1594   INode *_inode_top; // tos, stack grows up
1595   INode *_inode_max; // End of _inodes == _inodes + _max
</pre>
</td>
<td>
<hr />
<pre>
1179   void fast_dump() const {
1180     tty-&gt;print(&quot;%4d: %-17s&quot;, _idx, Name());
1181     for (uint i = 0; i &lt; len(); i++)
1182       if (in(i))
1183         tty-&gt;print(&quot; %4d&quot;, in(i)-&gt;_idx);
1184       else
1185         tty-&gt;print(&quot; NULL&quot;);
1186     tty-&gt;print(&quot;\n&quot;);
1187   }
1188 #endif
1189 #ifdef ASSERT
1190   void verify_construction();
1191   bool verify_jvms(const JVMState* jvms) const;
1192   int  _debug_idx;                     // Unique value assigned to every node.
1193   int   debug_idx() const              { return _debug_idx; }
1194   void  set_debug_idx( int debug_idx ) { _debug_idx = debug_idx; }
1195 
1196   Node* _debug_orig;                   // Original version of this, if any.
1197   Node*  debug_orig() const            { return _debug_orig; }
1198   void   set_debug_orig(Node* orig);   // _debug_orig = orig
<span class="line-added">1199   void   dump_orig(outputStream *st, bool print_key = true) const;</span>
1200 
1201   int        _hash_lock;               // Barrier to modifications of nodes in the hash table
1202   void  enter_hash_lock() { ++_hash_lock; assert(_hash_lock &lt; 99, &quot;in too many hash tables?&quot;); }
1203   void   exit_hash_lock() { --_hash_lock; assert(_hash_lock &gt;= 0, &quot;mispaired hash locks&quot;); }
1204 
1205   static void init_NodeProperty();
1206 
1207   #if OPTO_DU_ITERATOR_ASSERT
1208   const Node* _last_del;               // The last deleted node.
1209   uint        _del_tick;               // Bumped when a deletion happens..
1210   #endif
1211 #endif
1212 };
1213 
1214 
1215 #ifndef PRODUCT
1216 
1217 // Used in debugging code to avoid walking across dead or uninitialized edges.
1218 inline bool NotANode(const Node* n) {
1219   if (n == NULL)                   return true;
</pre>
<hr />
<pre>
1557   }
1558   Node *remove(uint i) {
1559     Node *b = Node_List::at(i);
1560     _in_worklist.remove(b-&gt;_idx);
1561     map(i,Node_List::pop());
1562     return b;
1563   }
1564   void yank(Node *n) {
1565     _in_worklist.remove(n-&gt;_idx);
1566     Node_List::yank(n);
1567   }
1568   void  clear() {
1569     _in_worklist.clear();        // Discards storage but grows automatically
1570     Node_List::clear();
1571     _clock_index = 0;
1572   }
1573 
1574   // Used after parsing to remove useless nodes before Iterative GVN
1575   void remove_useless_nodes(VectorSet&amp; useful);
1576 
<span class="line-added">1577   bool contains(const Node* n) const {</span>
<span class="line-added">1578     fatal(&quot;use faster member() instead&quot;);</span>
<span class="line-added">1579     return false;</span>
<span class="line-added">1580   }</span>
<span class="line-added">1581 </span>
1582 #ifndef PRODUCT
1583   void print_set() const { _in_worklist.print(); }
1584 #endif
1585 };
1586 
1587 // Inline definition of Compile::record_for_igvn must be deferred to this point.
1588 inline void Compile::record_for_igvn(Node* n) {
1589   _for_igvn-&gt;push(n);
1590 }
1591 
1592 //------------------------------Node_Stack-------------------------------------
1593 class Node_Stack {
1594   friend class VMStructs;
1595 protected:
1596   struct INode {
1597     Node *node; // Processed node
1598     uint  indx; // Index of next node&#39;s child
1599   };
1600   INode *_inode_top; // tos, stack grows up
1601   INode *_inode_max; // End of _inodes == _inodes + _max
</pre>
</td>
</tr>
</table>
<center><a href="node.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="output.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
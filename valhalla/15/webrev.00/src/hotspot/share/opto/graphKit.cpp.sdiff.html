<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/graphKit.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="gcm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/graphKit.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2736 
2737   // Get the no-exception control from the CatchNode.
2738   set_control(norm);
2739 }
2740 
2741 static IfNode* gen_subtype_check_compare(Node* ctrl, Node* in1, Node* in2, BoolTest::mask test, float p, PhaseGVN&amp; gvn, BasicType bt) {
2742   Node* cmp = NULL;
2743   switch(bt) {
2744   case T_INT: cmp = new CmpINode(in1, in2); break;
2745   case T_ADDRESS: cmp = new CmpPNode(in1, in2); break;
2746   default: fatal(&quot;unexpected comparison type %s&quot;, type2name(bt));
2747   }
2748   gvn.transform(cmp);
2749   Node* bol = gvn.transform(new BoolNode(cmp, test));
2750   IfNode* iff = new IfNode(ctrl, bol, p, COUNT_UNKNOWN);
2751   gvn.transform(iff);
2752   if (!bol-&gt;is_Con()) gvn.record_for_igvn(iff);
2753   return iff;
2754 }
2755 
<span class="line-removed">2756 // Find the memory state for the secondary super type cache load when</span>
<span class="line-removed">2757 // a subtype check is expanded at macro expansion time. That field is</span>
<span class="line-removed">2758 // mutable so should not use immutable memory but</span>
<span class="line-removed">2759 // PartialSubtypeCheckNode that might modify it doesn&#39;t produce a new</span>
<span class="line-removed">2760 // memory state so bottom memory is the most accurate memory state to</span>
<span class="line-removed">2761 // hook the load with. This follows the implementation used when the</span>
<span class="line-removed">2762 // subtype check is expanded at parse time.</span>
<span class="line-removed">2763 static Node* find_bottom_mem(Node* ctrl, Compile* C) {</span>
<span class="line-removed">2764   const TypePtr* adr_type = TypeKlassPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;Object_klass(), Type::Offset::bottom, false);</span>
<span class="line-removed">2765   Node_Stack stack(0);</span>
<span class="line-removed">2766   VectorSet seen(Thread::current()-&gt;resource_area());</span>
<span class="line-removed">2767 </span>
<span class="line-removed">2768   Node* c = ctrl;</span>
<span class="line-removed">2769   Node* mem = NULL;</span>
<span class="line-removed">2770   uint iter = 0;</span>
<span class="line-removed">2771   do {</span>
<span class="line-removed">2772     iter++;</span>
<span class="line-removed">2773     assert(iter &lt; C-&gt;live_nodes(), &quot;infinite loop&quot;);</span>
<span class="line-removed">2774     if (c-&gt;is_Region()) {</span>
<span class="line-removed">2775       for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax &amp;&amp; mem == NULL; i++) {</span>
<span class="line-removed">2776         Node* u = c-&gt;fast_out(i);</span>
<span class="line-removed">2777         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY &amp;&amp;</span>
<span class="line-removed">2778             (u-&gt;adr_type() == TypePtr::BOTTOM || u-&gt;adr_type() == adr_type)) {</span>
<span class="line-removed">2779           mem = u;</span>
<span class="line-removed">2780         }</span>
<span class="line-removed">2781       }</span>
<span class="line-removed">2782       if (mem == NULL) {</span>
<span class="line-removed">2783         if (!seen.test_set(c-&gt;_idx)) {</span>
<span class="line-removed">2784           stack.push(c, 2);</span>
<span class="line-removed">2785           c = c-&gt;in(1);</span>
<span class="line-removed">2786         } else {</span>
<span class="line-removed">2787           Node* phi = NULL;</span>
<span class="line-removed">2788           uint idx = 0;</span>
<span class="line-removed">2789           for (;;) {</span>
<span class="line-removed">2790             phi = stack.node();</span>
<span class="line-removed">2791             idx = stack.index();</span>
<span class="line-removed">2792             if (idx &lt; phi-&gt;req()) {</span>
<span class="line-removed">2793               break;</span>
<span class="line-removed">2794             }</span>
<span class="line-removed">2795             stack.pop();</span>
<span class="line-removed">2796           }</span>
<span class="line-removed">2797           c = phi-&gt;in(idx);</span>
<span class="line-removed">2798           stack.set_index(idx+1);</span>
<span class="line-removed">2799         }</span>
<span class="line-removed">2800       }</span>
<span class="line-removed">2801     } else if (c-&gt;is_Proj() &amp;&amp; c-&gt;in(0)-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-removed">2802       for (DUIterator_Fast imax, i = c-&gt;in(0)-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">2803         Node* u = c-&gt;in(0)-&gt;fast_out(i);</span>
<span class="line-removed">2804         if (u-&gt;bottom_type() == Type::MEMORY &amp;&amp; u-&gt;as_Proj()-&gt;_is_io_use == c-&gt;as_Proj()-&gt;_is_io_use) {</span>
<span class="line-removed">2805           assert(mem == NULL, &quot;&quot;);</span>
<span class="line-removed">2806           mem = u;</span>
<span class="line-removed">2807         }</span>
<span class="line-removed">2808       }</span>
<span class="line-removed">2809     } else if (c-&gt;is_CatchProj() &amp;&amp; c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-removed">2810       Node* call = c-&gt;in(0)-&gt;in(0)-&gt;in(0);</span>
<span class="line-removed">2811       assert(call-&gt;is_Call(), &quot;CatchProj with no call?&quot;);</span>
<span class="line-removed">2812       CallProjections* projs = call-&gt;as_Call()-&gt;extract_projections(false, false);</span>
<span class="line-removed">2813       if (projs-&gt;catchall_memproj == NULL) {</span>
<span class="line-removed">2814         mem = projs-&gt;fallthrough_memproj;</span>
<span class="line-removed">2815       } else if (c == projs-&gt;fallthrough_catchproj) {</span>
<span class="line-removed">2816         mem = projs-&gt;fallthrough_memproj;</span>
<span class="line-removed">2817       } else {</span>
<span class="line-removed">2818         assert(c == projs-&gt;catchall_catchproj, &quot;strange control&quot;);</span>
<span class="line-removed">2819         mem = projs-&gt;catchall_memproj;</span>
<span class="line-removed">2820       }</span>
<span class="line-removed">2821     } else {</span>
<span class="line-removed">2822       assert(!c-&gt;is_Start(), &quot;should stop before start&quot;);</span>
<span class="line-removed">2823       c = c-&gt;in(0);</span>
<span class="line-removed">2824     }</span>
<span class="line-removed">2825   } while (mem == NULL);</span>
<span class="line-removed">2826   return mem;</span>
<span class="line-removed">2827 }</span>
<span class="line-removed">2828 </span>
2829 //-------------------------------gen_subtype_check-----------------------------
2830 // Generate a subtyping check.  Takes as input the subtype and supertype.
2831 // Returns 2 values: sets the default control() to the true path and returns
2832 // the false path.  Only reads invariant memory; sets no (visible) memory.
2833 // The PartialSubtypeCheckNode sets the hidden 1-word cache in the encoding
2834 // but that&#39;s not exposed to the optimizer.  This call also doesn&#39;t take in an
2835 // Object; if you wish to check an Object you need to load the Object&#39;s class
2836 // prior to coming here.
2837 Node* Phase::gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, Node* mem, PhaseGVN&amp; gvn) {
2838   Compile* C = gvn.C;
2839   if ((*ctrl)-&gt;is_top()) {
2840     return C-&gt;top();
2841   }
2842 
2843   // Fast check for identical types, perhaps identical constants.
2844   // The types can even be identical non-constants, in cases
2845   // involving Array.newInstance, Object.clone, etc.
2846   if (subklass == superklass)
2847     return C-&gt;top();             // false path is dead; no test needed.
2848 
</pre>
<hr />
<pre>
2891   Node* m = C-&gt;immutable_memory();
2892   Node *chk_off = gvn.transform(new LoadINode(NULL, m, p1, gvn.type(p1)-&gt;is_ptr(), TypeInt::INT, MemNode::unordered));
2893   int cacheoff_con = in_bytes(Klass::secondary_super_cache_offset());
2894   bool might_be_cache = (gvn.find_int_con(chk_off, cacheoff_con) == cacheoff_con);
2895 
2896   // Load from the sub-klass&#39;s super-class display list, or a 1-word cache of
2897   // the secondary superclass list, or a failing value with a sentinel offset
2898   // if the super-klass is an interface or exceptionally deep in the Java
2899   // hierarchy and we have to scan the secondary superclass list the hard way.
2900   // Worst-case type is a little odd: NULL is allowed as a result (usually
2901   // klass loads can never produce a NULL).
2902   Node *chk_off_X = chk_off;
2903 #ifdef _LP64
2904   chk_off_X = gvn.transform(new ConvI2LNode(chk_off_X));
2905 #endif
2906   Node *p2 = gvn.transform(new AddPNode(subklass,subklass,chk_off_X));
2907   // For some types like interfaces the following loadKlass is from a 1-word
2908   // cache which is mutable so can&#39;t use immutable memory.  Other
2909   // types load from the super-class display table which is immutable.
2910   Node *kmem = C-&gt;immutable_memory();
<span class="line-modified">2911   if (might_be_cache) {</span>
<span class="line-modified">2912     assert((C-&gt;get_alias_index(TypeKlassPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;Object_klass(), Type::Offset::bottom, false)) ==</span>
<span class="line-modified">2913             C-&gt;get_alias_index(gvn.type(p2)-&gt;is_ptr())), &quot;&quot;);</span>
<span class="line-modified">2914     if (mem == NULL) {</span>
<span class="line-modified">2915       mem = find_bottom_mem(*ctrl, C);</span>
<span class="line-modified">2916     }</span>
2917     kmem = mem-&gt;is_MergeMem() ? mem-&gt;as_MergeMem()-&gt;memory_at(C-&gt;get_alias_index(gvn.type(p2)-&gt;is_ptr())) : mem;
2918   }
2919   Node *nkls = gvn.transform(LoadKlassNode::make(gvn, NULL, kmem, p2, gvn.type(p2)-&gt;is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));
2920 
2921   // Compile speed common case: ARE a subtype and we canNOT fail
2922   if( superklass == nkls )
2923     return C-&gt;top();             // false path is dead; no test needed.
2924 
2925   // See if we get an immediate positive hit.  Happens roughly 83% of the
2926   // time.  Test to see if the value loaded just previously from the subklass
2927   // is exactly the superklass.
2928   IfNode *iff1 = gen_subtype_check_compare(*ctrl, superklass, nkls, BoolTest::eq, PROB_LIKELY(0.83f), gvn, T_ADDRESS);
2929   Node *iftrue1 = gvn.transform( new IfTrueNode (iff1));
2930   *ctrl = gvn.transform(new IfFalseNode(iff1));
2931 
2932   // Compile speed common case: Check for being deterministic right now.  If
2933   // chk_off is a constant and not equal to cacheoff then we are NOT a
2934   // subklass.  In this case we need exactly the 1 test above and we can
2935   // return those results immediately.
2936   if (!might_be_cache) {
</pre>
<hr />
<pre>
4457   return NULL;
4458 }
4459 
4460 // Trace Allocate -&gt; Proj[Parm] -&gt; Initialize
4461 InitializeNode* AllocateNode::initialization() {
4462   ProjNode* rawoop = proj_out_or_null(AllocateNode::RawAddress);
4463   if (rawoop == NULL)  return NULL;
4464   for (DUIterator_Fast imax, i = rawoop-&gt;fast_outs(imax); i &lt; imax; i++) {
4465     Node* init = rawoop-&gt;fast_out(i);
4466     if (init-&gt;is_Initialize()) {
4467       assert(init-&gt;as_Initialize()-&gt;allocation() == this, &quot;2-way link&quot;);
4468       return init-&gt;as_Initialize();
4469     }
4470   }
4471   return NULL;
4472 }
4473 
4474 //----------------------------- loop predicates ---------------------------
4475 
4476 //------------------------------add_predicate_impl----------------------------
<span class="line-modified">4477 void GraphKit::add_predicate_impl(Deoptimization::DeoptReason reason, int nargs) {</span>
4478   // Too many traps seen?
4479   if (too_many_traps(reason)) {
4480 #ifdef ASSERT
4481     if (TraceLoopPredicate) {
4482       int tc = C-&gt;trap_count(reason);
4483       tty-&gt;print(&quot;too many traps=%s tcount=%d in &quot;,
4484                     Deoptimization::trap_reason_name(reason), tc);
4485       method()-&gt;print(); // which method has too many predicate traps
4486       tty-&gt;cr();
4487     }
4488 #endif
4489     // We cannot afford to take more traps here,
4490     // do not generate predicate.
4491     return;
4492   }
4493 
4494   Node *cont    = _gvn.intcon(1);
4495   Node* opq     = _gvn.transform(new Opaque1Node(C, cont));
4496   Node *bol     = _gvn.transform(new Conv2BNode(opq));
4497   IfNode* iff   = create_and_map_if(control(), bol, PROB_MAX, COUNT_UNKNOWN);
4498   Node* iffalse = _gvn.transform(new IfFalseNode(iff));
4499   C-&gt;add_predicate_opaq(opq);
4500   {
4501     PreserveJVMState pjvms(this);
4502     set_control(iffalse);
4503     inc_sp(nargs);
4504     uncommon_trap(reason, Deoptimization::Action_maybe_recompile);
4505   }
4506   Node* iftrue = _gvn.transform(new IfTrueNode(iff));
4507   set_control(iftrue);
4508 }
4509 
4510 //------------------------------add_predicate---------------------------------
<span class="line-modified">4511 void GraphKit::add_predicate(int nargs) {</span>



4512   if (UseLoopPredicate) {
<span class="line-modified">4513     add_predicate_impl(Deoptimization::Reason_predicate, nargs);</span>
4514   }
4515   if (UseProfiledLoopPredicate) {
<span class="line-modified">4516     add_predicate_impl(Deoptimization::Reason_profile_predicate, nargs);</span>
4517   }
4518   // loop&#39;s limit check predicate should be near the loop.
<span class="line-modified">4519   add_predicate_impl(Deoptimization::Reason_loop_limit_check, nargs);</span>
4520 }
4521 
4522 void GraphKit::sync_kit(IdealKit&amp; ideal) {
4523   set_all_memory(ideal.merged_memory());
4524   set_i_o(ideal.i_o());
4525   set_control(ideal.ctrl());
4526 }
4527 
4528 void GraphKit::final_sync(IdealKit&amp; ideal) {
4529   // Final sync IdealKit and graphKit.
4530   sync_kit(ideal);
4531 }
4532 
4533 Node* GraphKit::load_String_length(Node* str, bool set_ctrl) {
4534   Node* len = load_array_length(load_String_value(str, set_ctrl));
4535   Node* coder = load_String_coder(str, set_ctrl);
4536   // Divide length by 2 if coder is UTF16
4537   return _gvn.transform(new RShiftINode(len, coder));
4538 }
4539 
</pre>
<hr />
<pre>
4623   set_memory(res_mem, TypeAryPtr::BYTES);
4624   return str;
4625 }
4626 
4627 void GraphKit::inflate_string(Node* src, Node* dst, const TypeAryPtr* dst_type, Node* count) {
4628   assert(Matcher::match_rule_supported(Op_StrInflatedCopy), &quot;Intrinsic not supported&quot;);
4629   assert(dst_type == TypeAryPtr::BYTES || dst_type == TypeAryPtr::CHARS, &quot;invalid dest type&quot;);
4630   // Capture src and dst memory (see comment in &#39;compress_string&#39;).
4631   Node* mem = capture_memory(TypeAryPtr::BYTES, dst_type);
4632   StrInflatedCopyNode* str = new StrInflatedCopyNode(control(), mem, src, dst, count);
4633   set_memory(_gvn.transform(str), dst_type);
4634 }
4635 
4636 void GraphKit::inflate_string_slow(Node* src, Node* dst, Node* start, Node* count) {
4637   /**
4638    * int i_char = start;
4639    * for (int i_byte = 0; i_byte &lt; count; i_byte++) {
4640    *   dst[i_char++] = (char)(src[i_byte] &amp; 0xff);
4641    * }
4642    */
<span class="line-modified">4643   add_predicate();</span>
4644   RegionNode* head = new RegionNode(3);
4645   head-&gt;init_req(1, control());
4646   gvn().set_type(head, Type::CONTROL);
4647   record_for_igvn(head);
4648 
4649   Node* i_byte = new PhiNode(head, TypeInt::INT);
4650   i_byte-&gt;init_req(1, intcon(0));
4651   gvn().set_type(i_byte, TypeInt::INT);
4652   record_for_igvn(i_byte);
4653 
4654   Node* i_char = new PhiNode(head, TypeInt::INT);
4655   i_char-&gt;init_req(1, start);
4656   gvn().set_type(i_char, TypeInt::INT);
4657   record_for_igvn(i_char);
4658 
4659   Node* mem = PhiNode::make(head, memory(TypeAryPtr::BYTES), Type::MEMORY, TypeAryPtr::BYTES);
4660   gvn().set_type(mem, Type::MEMORY);
4661   record_for_igvn(mem);
4662   set_control(head);
4663   set_memory(mem, TypeAryPtr::BYTES);
</pre>
</td>
<td>
<hr />
<pre>
2736 
2737   // Get the no-exception control from the CatchNode.
2738   set_control(norm);
2739 }
2740 
2741 static IfNode* gen_subtype_check_compare(Node* ctrl, Node* in1, Node* in2, BoolTest::mask test, float p, PhaseGVN&amp; gvn, BasicType bt) {
2742   Node* cmp = NULL;
2743   switch(bt) {
2744   case T_INT: cmp = new CmpINode(in1, in2); break;
2745   case T_ADDRESS: cmp = new CmpPNode(in1, in2); break;
2746   default: fatal(&quot;unexpected comparison type %s&quot;, type2name(bt));
2747   }
2748   gvn.transform(cmp);
2749   Node* bol = gvn.transform(new BoolNode(cmp, test));
2750   IfNode* iff = new IfNode(ctrl, bol, p, COUNT_UNKNOWN);
2751   gvn.transform(iff);
2752   if (!bol-&gt;is_Con()) gvn.record_for_igvn(iff);
2753   return iff;
2754 }
2755 









































































2756 //-------------------------------gen_subtype_check-----------------------------
2757 // Generate a subtyping check.  Takes as input the subtype and supertype.
2758 // Returns 2 values: sets the default control() to the true path and returns
2759 // the false path.  Only reads invariant memory; sets no (visible) memory.
2760 // The PartialSubtypeCheckNode sets the hidden 1-word cache in the encoding
2761 // but that&#39;s not exposed to the optimizer.  This call also doesn&#39;t take in an
2762 // Object; if you wish to check an Object you need to load the Object&#39;s class
2763 // prior to coming here.
2764 Node* Phase::gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, Node* mem, PhaseGVN&amp; gvn) {
2765   Compile* C = gvn.C;
2766   if ((*ctrl)-&gt;is_top()) {
2767     return C-&gt;top();
2768   }
2769 
2770   // Fast check for identical types, perhaps identical constants.
2771   // The types can even be identical non-constants, in cases
2772   // involving Array.newInstance, Object.clone, etc.
2773   if (subklass == superklass)
2774     return C-&gt;top();             // false path is dead; no test needed.
2775 
</pre>
<hr />
<pre>
2818   Node* m = C-&gt;immutable_memory();
2819   Node *chk_off = gvn.transform(new LoadINode(NULL, m, p1, gvn.type(p1)-&gt;is_ptr(), TypeInt::INT, MemNode::unordered));
2820   int cacheoff_con = in_bytes(Klass::secondary_super_cache_offset());
2821   bool might_be_cache = (gvn.find_int_con(chk_off, cacheoff_con) == cacheoff_con);
2822 
2823   // Load from the sub-klass&#39;s super-class display list, or a 1-word cache of
2824   // the secondary superclass list, or a failing value with a sentinel offset
2825   // if the super-klass is an interface or exceptionally deep in the Java
2826   // hierarchy and we have to scan the secondary superclass list the hard way.
2827   // Worst-case type is a little odd: NULL is allowed as a result (usually
2828   // klass loads can never produce a NULL).
2829   Node *chk_off_X = chk_off;
2830 #ifdef _LP64
2831   chk_off_X = gvn.transform(new ConvI2LNode(chk_off_X));
2832 #endif
2833   Node *p2 = gvn.transform(new AddPNode(subklass,subklass,chk_off_X));
2834   // For some types like interfaces the following loadKlass is from a 1-word
2835   // cache which is mutable so can&#39;t use immutable memory.  Other
2836   // types load from the super-class display table which is immutable.
2837   Node *kmem = C-&gt;immutable_memory();
<span class="line-modified">2838   // secondary_super_cache is not immutable but can be treated as such because:</span>
<span class="line-modified">2839   // - no ideal node writes to it in a way that could cause an</span>
<span class="line-modified">2840   //   incorrect/missed optimization of the following Load.</span>
<span class="line-modified">2841   // - it&#39;s a cache so, worse case, not reading the latest value</span>
<span class="line-modified">2842   //   wouldn&#39;t cause incorrect execution</span>
<span class="line-modified">2843   if (might_be_cache &amp;&amp; mem != NULL) {</span>
2844     kmem = mem-&gt;is_MergeMem() ? mem-&gt;as_MergeMem()-&gt;memory_at(C-&gt;get_alias_index(gvn.type(p2)-&gt;is_ptr())) : mem;
2845   }
2846   Node *nkls = gvn.transform(LoadKlassNode::make(gvn, NULL, kmem, p2, gvn.type(p2)-&gt;is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));
2847 
2848   // Compile speed common case: ARE a subtype and we canNOT fail
2849   if( superklass == nkls )
2850     return C-&gt;top();             // false path is dead; no test needed.
2851 
2852   // See if we get an immediate positive hit.  Happens roughly 83% of the
2853   // time.  Test to see if the value loaded just previously from the subklass
2854   // is exactly the superklass.
2855   IfNode *iff1 = gen_subtype_check_compare(*ctrl, superklass, nkls, BoolTest::eq, PROB_LIKELY(0.83f), gvn, T_ADDRESS);
2856   Node *iftrue1 = gvn.transform( new IfTrueNode (iff1));
2857   *ctrl = gvn.transform(new IfFalseNode(iff1));
2858 
2859   // Compile speed common case: Check for being deterministic right now.  If
2860   // chk_off is a constant and not equal to cacheoff then we are NOT a
2861   // subklass.  In this case we need exactly the 1 test above and we can
2862   // return those results immediately.
2863   if (!might_be_cache) {
</pre>
<hr />
<pre>
4384   return NULL;
4385 }
4386 
4387 // Trace Allocate -&gt; Proj[Parm] -&gt; Initialize
4388 InitializeNode* AllocateNode::initialization() {
4389   ProjNode* rawoop = proj_out_or_null(AllocateNode::RawAddress);
4390   if (rawoop == NULL)  return NULL;
4391   for (DUIterator_Fast imax, i = rawoop-&gt;fast_outs(imax); i &lt; imax; i++) {
4392     Node* init = rawoop-&gt;fast_out(i);
4393     if (init-&gt;is_Initialize()) {
4394       assert(init-&gt;as_Initialize()-&gt;allocation() == this, &quot;2-way link&quot;);
4395       return init-&gt;as_Initialize();
4396     }
4397   }
4398   return NULL;
4399 }
4400 
4401 //----------------------------- loop predicates ---------------------------
4402 
4403 //------------------------------add_predicate_impl----------------------------
<span class="line-modified">4404 void GraphKit::add_empty_predicate_impl(Deoptimization::DeoptReason reason, int nargs) {</span>
4405   // Too many traps seen?
4406   if (too_many_traps(reason)) {
4407 #ifdef ASSERT
4408     if (TraceLoopPredicate) {
4409       int tc = C-&gt;trap_count(reason);
4410       tty-&gt;print(&quot;too many traps=%s tcount=%d in &quot;,
4411                     Deoptimization::trap_reason_name(reason), tc);
4412       method()-&gt;print(); // which method has too many predicate traps
4413       tty-&gt;cr();
4414     }
4415 #endif
4416     // We cannot afford to take more traps here,
4417     // do not generate predicate.
4418     return;
4419   }
4420 
4421   Node *cont    = _gvn.intcon(1);
4422   Node* opq     = _gvn.transform(new Opaque1Node(C, cont));
4423   Node *bol     = _gvn.transform(new Conv2BNode(opq));
4424   IfNode* iff   = create_and_map_if(control(), bol, PROB_MAX, COUNT_UNKNOWN);
4425   Node* iffalse = _gvn.transform(new IfFalseNode(iff));
4426   C-&gt;add_predicate_opaq(opq);
4427   {
4428     PreserveJVMState pjvms(this);
4429     set_control(iffalse);
4430     inc_sp(nargs);
4431     uncommon_trap(reason, Deoptimization::Action_maybe_recompile);
4432   }
4433   Node* iftrue = _gvn.transform(new IfTrueNode(iff));
4434   set_control(iftrue);
4435 }
4436 
4437 //------------------------------add_predicate---------------------------------
<span class="line-modified">4438 void GraphKit::add_empty_predicates(int nargs) {</span>
<span class="line-added">4439   // These loop predicates remain empty. All concrete loop predicates are inserted above the corresponding</span>
<span class="line-added">4440   // empty loop predicate later by &#39;PhaseIdealLoop::create_new_if_for_predicate&#39;. All concrete loop predicates of</span>
<span class="line-added">4441   // a specific kind (normal, profile or limit check) share the same uncommon trap as the empty loop predicate.</span>
4442   if (UseLoopPredicate) {
<span class="line-modified">4443     add_empty_predicate_impl(Deoptimization::Reason_predicate, nargs);</span>
4444   }
4445   if (UseProfiledLoopPredicate) {
<span class="line-modified">4446     add_empty_predicate_impl(Deoptimization::Reason_profile_predicate, nargs);</span>
4447   }
4448   // loop&#39;s limit check predicate should be near the loop.
<span class="line-modified">4449   add_empty_predicate_impl(Deoptimization::Reason_loop_limit_check, nargs);</span>
4450 }
4451 
4452 void GraphKit::sync_kit(IdealKit&amp; ideal) {
4453   set_all_memory(ideal.merged_memory());
4454   set_i_o(ideal.i_o());
4455   set_control(ideal.ctrl());
4456 }
4457 
4458 void GraphKit::final_sync(IdealKit&amp; ideal) {
4459   // Final sync IdealKit and graphKit.
4460   sync_kit(ideal);
4461 }
4462 
4463 Node* GraphKit::load_String_length(Node* str, bool set_ctrl) {
4464   Node* len = load_array_length(load_String_value(str, set_ctrl));
4465   Node* coder = load_String_coder(str, set_ctrl);
4466   // Divide length by 2 if coder is UTF16
4467   return _gvn.transform(new RShiftINode(len, coder));
4468 }
4469 
</pre>
<hr />
<pre>
4553   set_memory(res_mem, TypeAryPtr::BYTES);
4554   return str;
4555 }
4556 
4557 void GraphKit::inflate_string(Node* src, Node* dst, const TypeAryPtr* dst_type, Node* count) {
4558   assert(Matcher::match_rule_supported(Op_StrInflatedCopy), &quot;Intrinsic not supported&quot;);
4559   assert(dst_type == TypeAryPtr::BYTES || dst_type == TypeAryPtr::CHARS, &quot;invalid dest type&quot;);
4560   // Capture src and dst memory (see comment in &#39;compress_string&#39;).
4561   Node* mem = capture_memory(TypeAryPtr::BYTES, dst_type);
4562   StrInflatedCopyNode* str = new StrInflatedCopyNode(control(), mem, src, dst, count);
4563   set_memory(_gvn.transform(str), dst_type);
4564 }
4565 
4566 void GraphKit::inflate_string_slow(Node* src, Node* dst, Node* start, Node* count) {
4567   /**
4568    * int i_char = start;
4569    * for (int i_byte = 0; i_byte &lt; count; i_byte++) {
4570    *   dst[i_char++] = (char)(src[i_byte] &amp; 0xff);
4571    * }
4572    */
<span class="line-modified">4573   add_empty_predicates();</span>
4574   RegionNode* head = new RegionNode(3);
4575   head-&gt;init_req(1, control());
4576   gvn().set_type(head, Type::CONTROL);
4577   record_for_igvn(head);
4578 
4579   Node* i_byte = new PhiNode(head, TypeInt::INT);
4580   i_byte-&gt;init_req(1, intcon(0));
4581   gvn().set_type(i_byte, TypeInt::INT);
4582   record_for_igvn(i_byte);
4583 
4584   Node* i_char = new PhiNode(head, TypeInt::INT);
4585   i_char-&gt;init_req(1, start);
4586   gvn().set_type(i_char, TypeInt::INT);
4587   record_for_igvn(i_char);
4588 
4589   Node* mem = PhiNode::make(head, memory(TypeAryPtr::BYTES), Type::MEMORY, TypeAryPtr::BYTES);
4590   gvn().set_type(mem, Type::MEMORY);
4591   record_for_igvn(mem);
4592   set_control(head);
4593   set_memory(mem, TypeAryPtr::BYTES);
</pre>
</td>
</tr>
</table>
<center><a href="gcm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/loopPredicate.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="library_call.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopTransform.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopPredicate.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  74 //  uncommon_proj cont_proj                   if_uct     if_cont
  75 // \      |        |                           |          |
  76 //  \     |        |                           |          |
  77 //   v    v        v                           |          v
  78 //     rgn       loop                          |         iff
  79 //      |                                      |        /     \
  80 //      |                                      |       /       \
  81 //      v                                      |      v         v
  82 // uncommon_trap                               | uncommon_proj cont_proj
  83 //                                           \  \    |           |
  84 //                                            \  \   |           |
  85 //                                             v  v  v           v
  86 //                                               rgn           loop
  87 //                                                |
  88 //                                                |
  89 //                                                v
  90 //                                           uncommon_trap
  91 //
  92 //
  93 // We will create a region to guard the uct call if there is no one there.
<span class="line-modified">  94 // The true projection (if_cont) of the new_iff is returned.</span>
<span class="line-modified">  95 // This code is also used to clone predicates to cloned loops.</span>


  96 ProjNode* PhaseIdealLoop::create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry,
  97                                                       Deoptimization::DeoptReason reason,
<span class="line-modified">  98                                                       int opcode) {</span>
  99   assert(cont_proj-&gt;is_uncommon_trap_if_pattern(reason), &quot;must be a uct if pattern!&quot;);
 100   IfNode* iff = cont_proj-&gt;in(0)-&gt;as_If();
 101 
 102   ProjNode *uncommon_proj = iff-&gt;proj_out(1 - cont_proj-&gt;_con);
 103   Node     *rgn   = uncommon_proj-&gt;unique_ctrl_out();
 104   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
 105 
 106   uint proj_index = 1; // region&#39;s edge corresponding to uncommon_proj
 107   if (!rgn-&gt;is_Region()) { // create a region to guard the call
 108     assert(rgn-&gt;is_Call(), &quot;must be call uct&quot;);
 109     CallNode* call = rgn-&gt;as_Call();
 110     IdealLoopTree* loop = get_loop(call);
 111     rgn = new RegionNode(1);
 112     rgn-&gt;add_req(uncommon_proj);
 113     register_control(rgn, loop, uncommon_proj);
 114     _igvn.replace_input_of(call, 0, rgn);
 115     // When called from beautify_loops() idom is not constructed yet.
 116     if (_idom != NULL) {
 117       set_idom(call, rgn, dom_depth(rgn));
 118     }
</pre>
<hr />
<pre>
 128     for (; proj_index &lt; rgn-&gt;req(); proj_index++)
 129       if (rgn-&gt;in(proj_index) == uncommon_proj) break;
 130     assert(proj_index &lt; rgn-&gt;req(), &quot;sanity&quot;);
 131   }
 132 
 133   Node* entry = iff-&gt;in(0);
 134   if (new_entry != NULL) {
 135     // Clonning the predicate to new location.
 136     entry = new_entry;
 137   }
 138   // Create new_iff
 139   IdealLoopTree* lp = get_loop(entry);
 140   IfNode* new_iff = NULL;
 141   if (opcode == Op_If) {
 142     new_iff = new IfNode(entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
 143   } else {
 144     assert(opcode == Op_RangeCheck, &quot;no other if variant here&quot;);
 145     new_iff = new RangeCheckNode(entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
 146   }
 147   register_control(new_iff, lp, entry);
<span class="line-modified"> 148   Node *if_cont = new IfTrueNode(new_iff);</span>
<span class="line-modified"> 149   Node *if_uct  = new IfFalseNode(new_iff);</span>








 150   if (cont_proj-&gt;is_IfFalse()) {
 151     // Swap
 152     Node* tmp = if_uct; if_uct = if_cont; if_cont = tmp;
 153   }
 154   register_control(if_cont, lp, new_iff);
 155   register_control(if_uct, get_loop(rgn), new_iff);
 156 
 157   // if_uct to rgn
 158   _igvn.hash_delete(rgn);
 159   rgn-&gt;add_req(if_uct);
 160   // When called from beautify_loops() idom is not constructed yet.
 161   if (_idom != NULL) {
 162     Node* ridom = idom(rgn);
 163     Node* nrdom = dom_lca_internal(ridom, new_iff);
 164     set_idom(rgn, nrdom, dom_depth(rgn));
 165   }
 166 
 167   // If rgn has phis add new edges which has the same
 168   // value as on original uncommon_proj pass.
 169   assert(rgn-&gt;in(rgn-&gt;req() -1) == if_uct, &quot;new edge should be last&quot;);
</pre>
<hr />
<pre>
 172     Node* use = rgn-&gt;fast_out(i);
 173     if (use-&gt;is_Phi() &amp;&amp; use-&gt;outcnt() &gt; 0) {
 174       assert(use-&gt;in(0) == rgn, &quot;&quot;);
 175       _igvn.rehash_node_delayed(use);
 176       use-&gt;add_req(use-&gt;in(proj_index));
 177       has_phi = true;
 178     }
 179   }
 180   assert(!has_phi || rgn-&gt;req() &gt; 3, &quot;no phis when region is created&quot;);
 181 
 182   if (new_entry == NULL) {
 183     // Attach if_cont to iff
 184     _igvn.replace_input_of(iff, 0, if_cont);
 185     if (_idom != NULL) {
 186       set_idom(iff, if_cont, dom_depth(iff));
 187     }
 188   }
 189   return if_cont-&gt;as_Proj();
 190 }
 191 
<span class="line-removed"> 192 //------------------------------create_new_if_for_predicate------------------------</span>
<span class="line-removed"> 193 // Create a new if below new_entry for the predicate to be cloned (IGVN optimization)</span>
<span class="line-removed"> 194 ProjNode* PhaseIterGVN::create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry,</span>
<span class="line-removed"> 195                                                     Deoptimization::DeoptReason reason,</span>
<span class="line-removed"> 196                                                     int opcode) {</span>
<span class="line-removed"> 197   assert(new_entry != 0, &quot;only used for clone predicate&quot;);</span>
<span class="line-removed"> 198   assert(cont_proj-&gt;is_uncommon_trap_if_pattern(reason), &quot;must be a uct if pattern!&quot;);</span>
<span class="line-removed"> 199   IfNode* iff = cont_proj-&gt;in(0)-&gt;as_If();</span>
<span class="line-removed"> 200 </span>
<span class="line-removed"> 201   ProjNode *uncommon_proj = iff-&gt;proj_out(1 - cont_proj-&gt;_con);</span>
<span class="line-removed"> 202   Node     *rgn   = uncommon_proj-&gt;unique_ctrl_out();</span>
<span class="line-removed"> 203   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);</span>
<span class="line-removed"> 204 </span>
<span class="line-removed"> 205   uint proj_index = 1; // region&#39;s edge corresponding to uncommon_proj</span>
<span class="line-removed"> 206   if (!rgn-&gt;is_Region()) { // create a region to guard the call</span>
<span class="line-removed"> 207     assert(rgn-&gt;is_Call(), &quot;must be call uct&quot;);</span>
<span class="line-removed"> 208     CallNode* call = rgn-&gt;as_Call();</span>
<span class="line-removed"> 209     rgn = new RegionNode(1);</span>
<span class="line-removed"> 210     register_new_node_with_optimizer(rgn);</span>
<span class="line-removed"> 211     rgn-&gt;add_req(uncommon_proj);</span>
<span class="line-removed"> 212     replace_input_of(call, 0, rgn);</span>
<span class="line-removed"> 213   } else {</span>
<span class="line-removed"> 214     // Find region&#39;s edge corresponding to uncommon_proj</span>
<span class="line-removed"> 215     for (; proj_index &lt; rgn-&gt;req(); proj_index++)</span>
<span class="line-removed"> 216       if (rgn-&gt;in(proj_index) == uncommon_proj) break;</span>
<span class="line-removed"> 217     assert(proj_index &lt; rgn-&gt;req(), &quot;sanity&quot;);</span>
<span class="line-removed"> 218   }</span>
<span class="line-removed"> 219 </span>
<span class="line-removed"> 220   // Create new_iff in new location.</span>
<span class="line-removed"> 221   IfNode* new_iff = NULL;</span>
<span class="line-removed"> 222   if (opcode == Op_If) {</span>
<span class="line-removed"> 223     new_iff = new IfNode(new_entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);</span>
<span class="line-removed"> 224   } else {</span>
<span class="line-removed"> 225     assert(opcode == Op_RangeCheck, &quot;no other if variant here&quot;);</span>
<span class="line-removed"> 226     new_iff = new RangeCheckNode(new_entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);</span>
<span class="line-removed"> 227   }</span>
<span class="line-removed"> 228 </span>
<span class="line-removed"> 229   register_new_node_with_optimizer(new_iff);</span>
<span class="line-removed"> 230   Node *if_cont = new IfTrueNode(new_iff);</span>
<span class="line-removed"> 231   Node *if_uct  = new IfFalseNode(new_iff);</span>
<span class="line-removed"> 232   if (cont_proj-&gt;is_IfFalse()) {</span>
<span class="line-removed"> 233     // Swap</span>
<span class="line-removed"> 234     Node* tmp = if_uct; if_uct = if_cont; if_cont = tmp;</span>
<span class="line-removed"> 235   }</span>
<span class="line-removed"> 236   register_new_node_with_optimizer(if_cont);</span>
<span class="line-removed"> 237   register_new_node_with_optimizer(if_uct);</span>
<span class="line-removed"> 238 </span>
<span class="line-removed"> 239   // if_uct to rgn</span>
<span class="line-removed"> 240   hash_delete(rgn);</span>
<span class="line-removed"> 241   rgn-&gt;add_req(if_uct);</span>
<span class="line-removed"> 242 </span>
<span class="line-removed"> 243   // If rgn has phis add corresponding new edges which has the same</span>
<span class="line-removed"> 244   // value as on original uncommon_proj pass.</span>
<span class="line-removed"> 245   assert(rgn-&gt;in(rgn-&gt;req() -1) == if_uct, &quot;new edge should be last&quot;);</span>
<span class="line-removed"> 246   bool has_phi = false;</span>
<span class="line-removed"> 247   for (DUIterator_Fast imax, i = rgn-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed"> 248     Node* use = rgn-&gt;fast_out(i);</span>
<span class="line-removed"> 249     if (use-&gt;is_Phi() &amp;&amp; use-&gt;outcnt() &gt; 0) {</span>
<span class="line-removed"> 250       rehash_node_delayed(use);</span>
<span class="line-removed"> 251       use-&gt;add_req(use-&gt;in(proj_index));</span>
<span class="line-removed"> 252       has_phi = true;</span>
<span class="line-removed"> 253     }</span>
<span class="line-removed"> 254   }</span>
<span class="line-removed"> 255   assert(!has_phi || rgn-&gt;req() &gt; 3, &quot;no phis when region is created&quot;);</span>
<span class="line-removed"> 256 </span>
<span class="line-removed"> 257   return if_cont-&gt;as_Proj();</span>
<span class="line-removed"> 258 }</span>
<span class="line-removed"> 259 </span>
 260 //--------------------------clone_predicate-----------------------
<span class="line-modified"> 261 ProjNode* PhaseIdealLoop::clone_predicate(ProjNode* predicate_proj, Node* new_entry,</span>
<span class="line-modified"> 262                                           Deoptimization::DeoptReason reason,</span>
<span class="line-modified"> 263                                           PhaseIdealLoop* loop_phase,</span>
<span class="line-removed"> 264                                           PhaseIterGVN* igvn) {</span>
<span class="line-removed"> 265   ProjNode* new_predicate_proj;</span>
<span class="line-removed"> 266   if (loop_phase != NULL) {</span>
<span class="line-removed"> 267     new_predicate_proj = loop_phase-&gt;create_new_if_for_predicate(predicate_proj, new_entry, reason, Op_If);</span>
<span class="line-removed"> 268   } else {</span>
<span class="line-removed"> 269     new_predicate_proj =       igvn-&gt;create_new_if_for_predicate(predicate_proj, new_entry, reason, Op_If);</span>
<span class="line-removed"> 270   }</span>
 271   IfNode* iff = new_predicate_proj-&gt;in(0)-&gt;as_If();
 272   Node* ctrl  = iff-&gt;in(0);
 273 
 274   // Match original condition since predicate&#39;s projections could be swapped.
 275   assert(predicate_proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode()==Op_Opaque1, &quot;must be&quot;);
<span class="line-modified"> 276   Node* opq = new Opaque1Node(igvn-&gt;C, predicate_proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1));</span>
<span class="line-modified"> 277   igvn-&gt;C-&gt;add_predicate_opaq(opq);</span>
<span class="line-removed"> 278 </span>
 279   Node* bol = new Conv2BNode(opq);
<span class="line-modified"> 280   if (loop_phase != NULL) {</span>
<span class="line-modified"> 281     loop_phase-&gt;register_new_node(opq, ctrl);</span>
<span class="line-modified"> 282     loop_phase-&gt;register_new_node(bol, ctrl);</span>
<span class="line-removed"> 283   } else {</span>
<span class="line-removed"> 284     igvn-&gt;register_new_node_with_optimizer(opq);</span>
<span class="line-removed"> 285     igvn-&gt;register_new_node_with_optimizer(bol);</span>
<span class="line-removed"> 286   }</span>
<span class="line-removed"> 287   igvn-&gt;hash_delete(iff);</span>
 288   iff-&gt;set_req(1, bol);

 289   return new_predicate_proj;
 290 }
 291 







































 292 
<span class="line-modified"> 293 //--------------------------clone_loop_predicates-----------------------</span>
<span class="line-modified"> 294 // Interface from IGVN</span>
<span class="line-modified"> 295 Node* PhaseIterGVN::clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check) {</span>
<span class="line-modified"> 296   return PhaseIdealLoop::clone_loop_predicates(old_entry, new_entry, clone_limit_check, NULL, this);</span>
<span class="line-modified"> 297 }</span>























 298 
<span class="line-modified"> 299 // Interface from PhaseIdealLoop</span>
<span class="line-modified"> 300 Node* PhaseIdealLoop::clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check) {</span>
<span class="line-modified"> 301   return clone_loop_predicates(old_entry, new_entry, clone_limit_check, this, &amp;this-&gt;_igvn);</span>



















 302 }
 303 
<span class="line-modified"> 304 // Clone loop predicates to cloned loops (peeled, unswitched, split_if).</span>
<span class="line-modified"> 305 Node* PhaseIdealLoop::clone_loop_predicates(Node* old_entry, Node* new_entry,</span>
<span class="line-modified"> 306                                             bool clone_limit_check,</span>
<span class="line-modified"> 307                                             PhaseIdealLoop* loop_phase,</span>
<span class="line-removed"> 308                                             PhaseIterGVN* igvn) {</span>
 309 #ifdef ASSERT

 310   if (new_entry == NULL || !(new_entry-&gt;is_Proj() || new_entry-&gt;is_Region() || new_entry-&gt;is_SafePoint())) {
 311     if (new_entry != NULL)
 312       new_entry-&gt;dump();
 313     assert(false, &quot;not IfTrue, IfFalse, Region or SafePoint&quot;);
 314   }
 315 #endif
 316   // Search original predicates
 317   Node* entry = old_entry;
 318   ProjNode* limit_check_proj = NULL;
 319   limit_check_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
 320   if (limit_check_proj != NULL) {
 321     entry = skip_loop_predicates(entry);
 322   }
 323   ProjNode* profile_predicate_proj = NULL;
 324   ProjNode* predicate_proj = NULL;
 325   if (UseProfiledLoopPredicate) {
 326     profile_predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
 327     if (profile_predicate_proj != NULL) {
 328       entry = skip_loop_predicates(entry);
 329     }
 330   }
 331   if (UseLoopPredicate) {
 332     predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
 333   }
 334   if (predicate_proj != NULL) { // right pattern that can be used by loop predication
 335     // clone predicate
<span class="line-modified"> 336     new_entry = clone_predicate(predicate_proj, new_entry,</span>
<span class="line-modified"> 337                                 Deoptimization::Reason_predicate,</span>
<span class="line-removed"> 338                                 loop_phase, igvn);</span>
 339     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone predicate&quot;);
 340     if (TraceLoopPredicate) {
 341       tty-&gt;print(&quot;Loop Predicate cloned: &quot;);
 342       debug_only( new_entry-&gt;in(0)-&gt;dump(); );
 343     }
 344   }
 345   if (profile_predicate_proj != NULL) { // right pattern that can be used by loop predication
 346     // clone predicate
<span class="line-modified"> 347     new_entry = clone_predicate(profile_predicate_proj, new_entry,</span>
<span class="line-modified"> 348                                 Deoptimization::Reason_profile_predicate,</span>
<span class="line-removed"> 349                                 loop_phase, igvn);</span>
 350     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone predicate&quot;);
 351     if (TraceLoopPredicate) {
 352       tty-&gt;print(&quot;Loop Predicate cloned: &quot;);
 353       debug_only( new_entry-&gt;in(0)-&gt;dump(); );
 354     }
 355   }
 356   if (limit_check_proj != NULL &amp;&amp; clone_limit_check) {
 357     // Clone loop limit check last to insert it before loop.
 358     // Don&#39;t clone a limit check which was already finalized
 359     // for this counted loop (only one limit check is needed).
<span class="line-modified"> 360     new_entry = clone_predicate(limit_check_proj, new_entry,</span>
<span class="line-modified"> 361                                 Deoptimization::Reason_loop_limit_check,</span>
<span class="line-removed"> 362                                 loop_phase, igvn);</span>
 363     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone limit check&quot;);
 364     if (TraceLoopLimitCheck) {
 365       tty-&gt;print(&quot;Loop Limit Check cloned: &quot;);
 366       debug_only( new_entry-&gt;in(0)-&gt;dump(); )
 367     }
 368   }
 369   return new_entry;
 370 }
 371 
 372 //--------------------------skip_loop_predicates------------------------------
 373 // Skip related predicates.
 374 Node* PhaseIdealLoop::skip_loop_predicates(Node* entry) {
 375   IfNode* iff = entry-&gt;in(0)-&gt;as_If();
 376   ProjNode* uncommon_proj = iff-&gt;proj_out(1 - entry-&gt;as_Proj()-&gt;_con);
 377   Node* rgn = uncommon_proj-&gt;unique_ctrl_out();
 378   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
 379   entry = entry-&gt;in(0)-&gt;in(0);
 380   while (entry != NULL &amp;&amp; entry-&gt;is_Proj() &amp;&amp; entry-&gt;in(0)-&gt;is_If()) {
 381     uncommon_proj = entry-&gt;in(0)-&gt;as_If()-&gt;proj_out(1 - entry-&gt;as_Proj()-&gt;_con);
 382     if (uncommon_proj-&gt;unique_ctrl_out() != rgn)
</pre>
<hr />
<pre>
1182     // Test the upper bound
1183     BoolNode* upper_bound_bol = rc_predicate(loop, lower_bound_proj, scale, offset, init, limit, stride, rng, true, overflow);
1184     negated = false;
1185     if (proj-&gt;_con != predicate_proj-&gt;_con) {
1186       upper_bound_bol = new BoolNode(upper_bound_bol-&gt;in(1), upper_bound_bol-&gt;_test.negate());
1187       register_new_node(upper_bound_bol, ctrl);
1188       negated = true;
1189     }
1190     ProjNode* upper_bound_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff-&gt;Opcode());
1191     assert(upper_bound_proj-&gt;in(0)-&gt;as_If()-&gt;in(0) == lower_bound_proj, &quot;should dominate&quot;);
1192     IfNode* upper_bound_iff = upper_bound_proj-&gt;in(0)-&gt;as_If();
1193     _igvn.hash_delete(upper_bound_iff);
1194     upper_bound_iff-&gt;set_req(1, upper_bound_bol);
1195     if (TraceLoopPredicate) tty-&gt;print_cr(&quot;upper bound check if: %s %d &quot;, negated ? &quot; negated&quot; : &quot;&quot;, lower_bound_iff-&gt;_idx);
1196 
1197     // Fall through into rest of the clean up code which will move
1198     // any dependent nodes onto the upper bound test.
1199     new_predicate_proj = upper_bound_proj;
1200 
1201     if (iff-&gt;is_RangeCheck()) {
<span class="line-modified">1202       new_predicate_proj = insert_skeleton_predicate(iff, loop, proj, predicate_proj, upper_bound_proj, scale, offset, init, limit, stride, rng, overflow, reason);</span>
1203     }
1204 
1205 #ifndef PRODUCT
1206     if (TraceLoopOpts &amp;&amp; !TraceLoopPredicate) {
1207       tty-&gt;print(&quot;Predicate RC &quot;);
1208       loop-&gt;dump_head();
1209     }
1210 #endif
1211   } else {
1212     // Loop variant check (for example, range check in non-counted loop)
1213     // with uncommon trap.
1214     return false;
1215   }
1216   assert(new_predicate_proj != NULL, &quot;sanity&quot;);
1217   // Success - attach condition (new_predicate_bol) to predicate if
1218   invar.map_ctrl(proj, new_predicate_proj); // so that invariance test can be appropriate
1219 
1220   // Eliminate the old If in the loop body
1221   dominated_by( new_predicate_proj, iff, proj-&gt;_con != new_predicate_proj-&gt;_con );
1222 
1223   C-&gt;set_major_progress();
1224   return true;
1225 }
1226 
1227 
1228 // After pre/main/post loops are created, we&#39;ll put a copy of some
1229 // range checks between the pre and main loop to validate the value
1230 // of the main loop induction variable. Make a copy of the predicates
1231 // here with an opaque node as a place holder for the value (will be
1232 // updated by PhaseIdealLoop::clone_skeleton_predicate()).
<span class="line-modified">1233 ProjNode* PhaseIdealLoop::insert_skeleton_predicate(IfNode* iff, IdealLoopTree *loop,</span>
<span class="line-modified">1234                                                     ProjNode* proj, ProjNode *predicate_proj,</span>
<span class="line-modified">1235                                                     ProjNode* upper_bound_proj,</span>
<span class="line-modified">1236                                                     int scale, Node* offset,</span>
<span class="line-modified">1237                                                     Node* init, Node* limit, jint stride,</span>
<span class="line-modified">1238                                                     Node* rng, bool &amp;overflow,</span>
<span class="line-modified">1239                                                     Deoptimization::DeoptReason reason) {</span>
1240   assert(proj-&gt;_con &amp;&amp; predicate_proj-&gt;_con, &quot;not a range check?&quot;);
1241   Node* opaque_init = new Opaque1Node(C, init);
1242   register_new_node(opaque_init, upper_bound_proj);
1243   BoolNode* bol = rc_predicate(loop, upper_bound_proj, scale, offset, opaque_init, limit, stride, rng, (stride &gt; 0) != (scale &gt; 0), overflow);
1244   Node* opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1)); // This will go away once loop opts are over
1245   register_new_node(opaque_bol, upper_bound_proj);
1246   ProjNode* new_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff-&gt;Opcode());
1247   _igvn.replace_input_of(new_proj-&gt;in(0), 1, opaque_bol);
1248   assert(opaque_init-&gt;outcnt() &gt; 0, &quot;should be used&quot;);
1249   return new_proj;
1250 }
1251 
1252 //------------------------------ loop_predication_impl--------------------------
1253 // Insert loop predicates for null checks and range checks
1254 bool PhaseIdealLoop::loop_predication_impl(IdealLoopTree *loop) {
1255   if (!UseLoopPredicate) return false;
1256 
1257   if (!loop-&gt;_head-&gt;is_Loop()) {
1258     // Could be a simple region when irreducible loops are present.
1259     return false;
</pre>
</td>
<td>
<hr />
<pre>
  74 //  uncommon_proj cont_proj                   if_uct     if_cont
  75 // \      |        |                           |          |
  76 //  \     |        |                           |          |
  77 //   v    v        v                           |          v
  78 //     rgn       loop                          |         iff
  79 //      |                                      |        /     \
  80 //      |                                      |       /       \
  81 //      v                                      |      v         v
  82 // uncommon_trap                               | uncommon_proj cont_proj
  83 //                                           \  \    |           |
  84 //                                            \  \   |           |
  85 //                                             v  v  v           v
  86 //                                               rgn           loop
  87 //                                                |
  88 //                                                |
  89 //                                                v
  90 //                                           uncommon_trap
  91 //
  92 //
  93 // We will create a region to guard the uct call if there is no one there.
<span class="line-modified">  94 // The continuation projection (if_cont) of the new_iff is returned which</span>
<span class="line-modified">  95 // is by default a true projection if &#39;if_cont_is_true_proj&#39; is true.</span>
<span class="line-added">  96 // Otherwise, the continuation projection is set up to be the false</span>
<span class="line-added">  97 // projection. This code is also used to clone predicates to cloned loops.</span>
  98 ProjNode* PhaseIdealLoop::create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry,
  99                                                       Deoptimization::DeoptReason reason,
<span class="line-modified"> 100                                                       int opcode, bool if_cont_is_true_proj) {</span>
 101   assert(cont_proj-&gt;is_uncommon_trap_if_pattern(reason), &quot;must be a uct if pattern!&quot;);
 102   IfNode* iff = cont_proj-&gt;in(0)-&gt;as_If();
 103 
 104   ProjNode *uncommon_proj = iff-&gt;proj_out(1 - cont_proj-&gt;_con);
 105   Node     *rgn   = uncommon_proj-&gt;unique_ctrl_out();
 106   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
 107 
 108   uint proj_index = 1; // region&#39;s edge corresponding to uncommon_proj
 109   if (!rgn-&gt;is_Region()) { // create a region to guard the call
 110     assert(rgn-&gt;is_Call(), &quot;must be call uct&quot;);
 111     CallNode* call = rgn-&gt;as_Call();
 112     IdealLoopTree* loop = get_loop(call);
 113     rgn = new RegionNode(1);
 114     rgn-&gt;add_req(uncommon_proj);
 115     register_control(rgn, loop, uncommon_proj);
 116     _igvn.replace_input_of(call, 0, rgn);
 117     // When called from beautify_loops() idom is not constructed yet.
 118     if (_idom != NULL) {
 119       set_idom(call, rgn, dom_depth(rgn));
 120     }
</pre>
<hr />
<pre>
 130     for (; proj_index &lt; rgn-&gt;req(); proj_index++)
 131       if (rgn-&gt;in(proj_index) == uncommon_proj) break;
 132     assert(proj_index &lt; rgn-&gt;req(), &quot;sanity&quot;);
 133   }
 134 
 135   Node* entry = iff-&gt;in(0);
 136   if (new_entry != NULL) {
 137     // Clonning the predicate to new location.
 138     entry = new_entry;
 139   }
 140   // Create new_iff
 141   IdealLoopTree* lp = get_loop(entry);
 142   IfNode* new_iff = NULL;
 143   if (opcode == Op_If) {
 144     new_iff = new IfNode(entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
 145   } else {
 146     assert(opcode == Op_RangeCheck, &quot;no other if variant here&quot;);
 147     new_iff = new RangeCheckNode(entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
 148   }
 149   register_control(new_iff, lp, entry);
<span class="line-modified"> 150   Node* if_cont;</span>
<span class="line-modified"> 151   Node* if_uct;</span>
<span class="line-added"> 152   if (if_cont_is_true_proj) {</span>
<span class="line-added"> 153     if_cont = new IfTrueNode(new_iff);</span>
<span class="line-added"> 154     if_uct  = new IfFalseNode(new_iff);</span>
<span class="line-added"> 155   } else {</span>
<span class="line-added"> 156     if_uct  = new IfTrueNode(new_iff);</span>
<span class="line-added"> 157     if_cont = new IfFalseNode(new_iff);</span>
<span class="line-added"> 158   }</span>
<span class="line-added"> 159 </span>
 160   if (cont_proj-&gt;is_IfFalse()) {
 161     // Swap
 162     Node* tmp = if_uct; if_uct = if_cont; if_cont = tmp;
 163   }
 164   register_control(if_cont, lp, new_iff);
 165   register_control(if_uct, get_loop(rgn), new_iff);
 166 
 167   // if_uct to rgn
 168   _igvn.hash_delete(rgn);
 169   rgn-&gt;add_req(if_uct);
 170   // When called from beautify_loops() idom is not constructed yet.
 171   if (_idom != NULL) {
 172     Node* ridom = idom(rgn);
 173     Node* nrdom = dom_lca_internal(ridom, new_iff);
 174     set_idom(rgn, nrdom, dom_depth(rgn));
 175   }
 176 
 177   // If rgn has phis add new edges which has the same
 178   // value as on original uncommon_proj pass.
 179   assert(rgn-&gt;in(rgn-&gt;req() -1) == if_uct, &quot;new edge should be last&quot;);
</pre>
<hr />
<pre>
 182     Node* use = rgn-&gt;fast_out(i);
 183     if (use-&gt;is_Phi() &amp;&amp; use-&gt;outcnt() &gt; 0) {
 184       assert(use-&gt;in(0) == rgn, &quot;&quot;);
 185       _igvn.rehash_node_delayed(use);
 186       use-&gt;add_req(use-&gt;in(proj_index));
 187       has_phi = true;
 188     }
 189   }
 190   assert(!has_phi || rgn-&gt;req() &gt; 3, &quot;no phis when region is created&quot;);
 191 
 192   if (new_entry == NULL) {
 193     // Attach if_cont to iff
 194     _igvn.replace_input_of(iff, 0, if_cont);
 195     if (_idom != NULL) {
 196       set_idom(iff, if_cont, dom_depth(iff));
 197     }
 198   }
 199   return if_cont-&gt;as_Proj();
 200 }
 201 




































































 202 //--------------------------clone_predicate-----------------------
<span class="line-modified"> 203 ProjNode* PhaseIdealLoop::clone_loop_predicate(ProjNode* predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason,</span>
<span class="line-modified"> 204                                                bool is_slow_loop, uint idx_before_clone, Node_List &amp;old_new) {</span>
<span class="line-modified"> 205   ProjNode* new_predicate_proj = create_new_if_for_predicate(predicate_proj, new_entry, reason, Op_If);</span>







 206   IfNode* iff = new_predicate_proj-&gt;in(0)-&gt;as_If();
 207   Node* ctrl  = iff-&gt;in(0);
 208 
 209   // Match original condition since predicate&#39;s projections could be swapped.
 210   assert(predicate_proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode()==Op_Opaque1, &quot;must be&quot;);
<span class="line-modified"> 211   Node* opq = new Opaque1Node(C, predicate_proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1));</span>
<span class="line-modified"> 212   C-&gt;add_predicate_opaq(opq);</span>

 213   Node* bol = new Conv2BNode(opq);
<span class="line-modified"> 214   register_new_node(opq, ctrl);</span>
<span class="line-modified"> 215   register_new_node(bol, ctrl);</span>
<span class="line-modified"> 216   _igvn.hash_delete(iff);</span>





 217   iff-&gt;set_req(1, bol);
<span class="line-added"> 218   clone_concrete_loop_predicates(reason, predicate_proj, new_predicate_proj, is_slow_loop, idx_before_clone, old_new);</span>
 219   return new_predicate_proj;
 220 }
 221 
<span class="line-added"> 222 // Clones all non-empty loop predicates (including skeleton predicates) starting at &#39;old_predicate_proj&#39; to &#39;new_predicate_proj&#39;</span>
<span class="line-added"> 223 // and rewires the control edges of data nodes in the loop to the old predicates to the new cloned predicates.</span>
<span class="line-added"> 224 void PhaseIdealLoop::clone_concrete_loop_predicates(Deoptimization::DeoptReason reason, ProjNode* old_predicate_proj,</span>
<span class="line-added"> 225                                                     ProjNode* new_predicate_proj, bool is_slow_loop, uint idx_before_clone,</span>
<span class="line-added"> 226                                                     Node_List &amp;old_new) {</span>
<span class="line-added"> 227   assert(old_predicate_proj-&gt;is_Proj(), &quot;must be projection&quot;);</span>
<span class="line-added"> 228   IfNode* iff = old_predicate_proj-&gt;in(0)-&gt;as_If();</span>
<span class="line-added"> 229   ProjNode* uncommon_proj = iff-&gt;proj_out(1 - old_predicate_proj-&gt;as_Proj()-&gt;_con);</span>
<span class="line-added"> 230   Node* rgn = uncommon_proj-&gt;unique_ctrl_out();</span>
<span class="line-added"> 231   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);</span>
<span class="line-added"> 232   assert(iff-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_Opaque1, &quot;unexpected predicate shape&quot;);</span>
<span class="line-added"> 233   Node* predicate = iff-&gt;in(0);</span>
<span class="line-added"> 234   Node* current_proj = old_predicate_proj;</span>
<span class="line-added"> 235   Node* prev_proj = current_proj;</span>
<span class="line-added"> 236   Unique_Node_List list;</span>
<span class="line-added"> 237   while (predicate != NULL &amp;&amp; predicate-&gt;is_Proj() &amp;&amp; predicate-&gt;in(0)-&gt;is_If()) {</span>
<span class="line-added"> 238     iff = predicate-&gt;in(0)-&gt;as_If();</span>
<span class="line-added"> 239     uncommon_proj = iff-&gt;proj_out(1 - predicate-&gt;as_Proj()-&gt;_con);</span>
<span class="line-added"> 240     if (uncommon_proj-&gt;unique_ctrl_out() != rgn)</span>
<span class="line-added"> 241       break;</span>
<span class="line-added"> 242     if (iff-&gt;is_RangeCheck()) {</span>
<span class="line-added"> 243       // Only need to clone range check predicates as those can be changed and duplicated by inserting pre/main/post loops</span>
<span class="line-added"> 244       // and doing loop unrolling. Push the original predicates on a list to later process them in reverse order to keep the</span>
<span class="line-added"> 245       // original predicate order.</span>
<span class="line-added"> 246       list.push(predicate);</span>
<span class="line-added"> 247 #ifdef ASSERT</span>
<span class="line-added"> 248     } else {</span>
<span class="line-added"> 249       // All other If predicates should not have a control input to nodes belonging to the original loop</span>
<span class="line-added"> 250       for (DUIterator i = predicate-&gt;outs(); predicate-&gt;has_out(i); i++) {</span>
<span class="line-added"> 251         Node* old_node = predicate-&gt;out(i);</span>
<span class="line-added"> 252         Node* new_node = old_new[old_node-&gt;_idx];</span>
<span class="line-added"> 253         if (!old_node-&gt;is_CFG() &amp;&amp; new_node != NULL &amp;&amp; old_node-&gt;_idx &gt;= idx_before_clone) {</span>
<span class="line-added"> 254           assert(false, &quot;should not be part of the original loop&quot;);</span>
<span class="line-added"> 255         }</span>
<span class="line-added"> 256       }</span>
<span class="line-added"> 257 #endif</span>
<span class="line-added"> 258     }</span>
<span class="line-added"> 259     predicate = predicate-&gt;in(0)-&gt;in(0);</span>
<span class="line-added"> 260   }</span>
 261 
<span class="line-modified"> 262   // Process in reverse order such that &#39;create_new_if_for_predicate&#39; can be used and the original order is maintained</span>
<span class="line-modified"> 263   for (int i = list.size()-1; i &gt;= 0; i--) {</span>
<span class="line-modified"> 264     predicate = list.at(i);</span>
<span class="line-modified"> 265     assert(predicate-&gt;in(0)-&gt;is_If(), &quot;must be If node&quot;);</span>
<span class="line-modified"> 266     iff = predicate-&gt;in(0)-&gt;as_If();</span>
<span class="line-added"> 267     assert(predicate-&gt;is_Proj() &amp;&amp; predicate-&gt;as_Proj()-&gt;is_IfProj() &amp;&amp; iff-&gt;is_RangeCheck(), &quot;predicate must be a projection of a range check&quot;);</span>
<span class="line-added"> 268     IfProjNode* predicate_proj = predicate-&gt;as_IfProj();</span>
<span class="line-added"> 269 </span>
<span class="line-added"> 270     // cloned_proj is the same type of projection as the original predicate projection (IfTrue or IfFalse)</span>
<span class="line-added"> 271     ProjNode* cloned_proj = create_new_if_for_predicate(new_predicate_proj, NULL, reason, Op_RangeCheck, predicate_proj-&gt;is_IfTrue());</span>
<span class="line-added"> 272 </span>
<span class="line-added"> 273     // Replace bool input by input from original predicate</span>
<span class="line-added"> 274     _igvn.replace_input_of(cloned_proj-&gt;in(0), 1, iff-&gt;in(1));</span>
<span class="line-added"> 275 </span>
<span class="line-added"> 276     if (is_slow_loop) {</span>
<span class="line-added"> 277       for (DUIterator i = predicate-&gt;outs(); predicate-&gt;has_out(i); i++) {</span>
<span class="line-added"> 278         Node* slow_node = predicate-&gt;out(i);</span>
<span class="line-added"> 279         Node* fast_node = old_new[slow_node-&gt;_idx];</span>
<span class="line-added"> 280         if (!slow_node-&gt;is_CFG() &amp;&amp; fast_node != NULL &amp;&amp; slow_node-&gt;_idx &gt; idx_before_clone) {</span>
<span class="line-added"> 281           // &#39;slow_node&#39; is a data node and part of the slow loop. This is a clone of the fast loop node</span>
<span class="line-added"> 282           // which was temporarily added below in order to verify that &#39;slow_node&#39; is a clone of &#39;fast_node&#39;.</span>
<span class="line-added"> 283           // Update the control input and reset the mapping for &#39;slow_node&#39; back to NULL.</span>
<span class="line-added"> 284           _igvn.replace_input_of(slow_node, 0, cloned_proj);</span>
<span class="line-added"> 285           old_new.map(slow_node-&gt;_idx, NULL);</span>
<span class="line-added"> 286           --i;</span>
<span class="line-added"> 287         }</span>
<span class="line-added"> 288         assert(slow_node-&gt;_idx &lt;= idx_before_clone || old_new[slow_node-&gt;_idx] == NULL, &quot;mapping of cloned nodes must be null&quot;);</span>
<span class="line-added"> 289       }</span>
 290 
<span class="line-modified"> 291       // Let old predicates before unswitched loops which were cloned die if all their control edges were rewired</span>
<span class="line-modified"> 292       // to the cloned predicates in the unswitched loops.</span>
<span class="line-modified"> 293       if (predicate-&gt;outcnt() == 1) {</span>
<span class="line-added"> 294         _igvn.replace_input_of(iff, 1, _igvn.intcon(predicate_proj-&gt;_con));</span>
<span class="line-added"> 295       }</span>
<span class="line-added"> 296     } else {</span>
<span class="line-added"> 297       // Fast loop</span>
<span class="line-added"> 298       for (DUIterator i = predicate-&gt;outs(); predicate-&gt;has_out(i); i++) {</span>
<span class="line-added"> 299         Node* fast_node = predicate-&gt;out(i);</span>
<span class="line-added"> 300         Node* slow_node = old_new[fast_node-&gt;_idx];</span>
<span class="line-added"> 301         if (!fast_node-&gt;is_CFG() &amp;&amp; slow_node != NULL &amp;&amp; slow_node-&gt;_idx &gt; idx_before_clone) {</span>
<span class="line-added"> 302           // &#39;fast_node&#39; is a data node and part of the fast loop. Add the clone of the fast loop node</span>
<span class="line-added"> 303           // to the &#39;old_new&#39; mapping in order to verify later when cloning the predicates for the slow loop</span>
<span class="line-added"> 304           // that &#39;slow_node&#39; is a clone of &#39;fast_node&#39;. Update the control input for &#39;fast_node&#39;.</span>
<span class="line-added"> 305           _igvn.replace_input_of(fast_node, 0, cloned_proj);</span>
<span class="line-added"> 306           assert(old_new[slow_node-&gt;_idx] == NULL, &quot;mapping must be null for cloned nodes&quot;);</span>
<span class="line-added"> 307           old_new.map(slow_node-&gt;_idx, fast_node);</span>
<span class="line-added"> 308           --i;</span>
<span class="line-added"> 309         }</span>
<span class="line-added"> 310       }</span>
<span class="line-added"> 311     }</span>
<span class="line-added"> 312   }</span>
 313 }
 314 
<span class="line-modified"> 315 //--------------------------clone_loop_predicates-----------------------</span>
<span class="line-modified"> 316 // Clone loop predicates to cloned loops when unswitching a loop.</span>
<span class="line-modified"> 317 Node* PhaseIdealLoop::clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check,</span>
<span class="line-modified"> 318                                             bool is_slow_loop, uint idx_before_clone, Node_List &amp;old_new) {</span>

 319 #ifdef ASSERT
<span class="line-added"> 320   assert(LoopUnswitching, &quot;sanity - only called when unswitching a loop&quot;);</span>
 321   if (new_entry == NULL || !(new_entry-&gt;is_Proj() || new_entry-&gt;is_Region() || new_entry-&gt;is_SafePoint())) {
 322     if (new_entry != NULL)
 323       new_entry-&gt;dump();
 324     assert(false, &quot;not IfTrue, IfFalse, Region or SafePoint&quot;);
 325   }
 326 #endif
 327   // Search original predicates
 328   Node* entry = old_entry;
 329   ProjNode* limit_check_proj = NULL;
 330   limit_check_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
 331   if (limit_check_proj != NULL) {
 332     entry = skip_loop_predicates(entry);
 333   }
 334   ProjNode* profile_predicate_proj = NULL;
 335   ProjNode* predicate_proj = NULL;
 336   if (UseProfiledLoopPredicate) {
 337     profile_predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
 338     if (profile_predicate_proj != NULL) {
 339       entry = skip_loop_predicates(entry);
 340     }
 341   }
 342   if (UseLoopPredicate) {
 343     predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
 344   }
 345   if (predicate_proj != NULL) { // right pattern that can be used by loop predication
 346     // clone predicate
<span class="line-modified"> 347     new_entry = clone_loop_predicate(predicate_proj, new_entry, Deoptimization::Reason_predicate, is_slow_loop,</span>
<span class="line-modified"> 348                                      idx_before_clone, old_new);</span>

 349     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone predicate&quot;);
 350     if (TraceLoopPredicate) {
 351       tty-&gt;print(&quot;Loop Predicate cloned: &quot;);
 352       debug_only( new_entry-&gt;in(0)-&gt;dump(); );
 353     }
 354   }
 355   if (profile_predicate_proj != NULL) { // right pattern that can be used by loop predication
 356     // clone predicate
<span class="line-modified"> 357     new_entry = clone_loop_predicate(profile_predicate_proj, new_entry,Deoptimization::Reason_profile_predicate,</span>
<span class="line-modified"> 358                                      is_slow_loop, idx_before_clone, old_new);</span>

 359     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone predicate&quot;);
 360     if (TraceLoopPredicate) {
 361       tty-&gt;print(&quot;Loop Predicate cloned: &quot;);
 362       debug_only( new_entry-&gt;in(0)-&gt;dump(); );
 363     }
 364   }
 365   if (limit_check_proj != NULL &amp;&amp; clone_limit_check) {
 366     // Clone loop limit check last to insert it before loop.
 367     // Don&#39;t clone a limit check which was already finalized
 368     // for this counted loop (only one limit check is needed).
<span class="line-modified"> 369     new_entry = clone_loop_predicate(limit_check_proj, new_entry, Deoptimization::Reason_loop_limit_check,</span>
<span class="line-modified"> 370                                      is_slow_loop, idx_before_clone, old_new);</span>

 371     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone limit check&quot;);
 372     if (TraceLoopLimitCheck) {
 373       tty-&gt;print(&quot;Loop Limit Check cloned: &quot;);
 374       debug_only( new_entry-&gt;in(0)-&gt;dump(); )
 375     }
 376   }
 377   return new_entry;
 378 }
 379 
 380 //--------------------------skip_loop_predicates------------------------------
 381 // Skip related predicates.
 382 Node* PhaseIdealLoop::skip_loop_predicates(Node* entry) {
 383   IfNode* iff = entry-&gt;in(0)-&gt;as_If();
 384   ProjNode* uncommon_proj = iff-&gt;proj_out(1 - entry-&gt;as_Proj()-&gt;_con);
 385   Node* rgn = uncommon_proj-&gt;unique_ctrl_out();
 386   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
 387   entry = entry-&gt;in(0)-&gt;in(0);
 388   while (entry != NULL &amp;&amp; entry-&gt;is_Proj() &amp;&amp; entry-&gt;in(0)-&gt;is_If()) {
 389     uncommon_proj = entry-&gt;in(0)-&gt;as_If()-&gt;proj_out(1 - entry-&gt;as_Proj()-&gt;_con);
 390     if (uncommon_proj-&gt;unique_ctrl_out() != rgn)
</pre>
<hr />
<pre>
1190     // Test the upper bound
1191     BoolNode* upper_bound_bol = rc_predicate(loop, lower_bound_proj, scale, offset, init, limit, stride, rng, true, overflow);
1192     negated = false;
1193     if (proj-&gt;_con != predicate_proj-&gt;_con) {
1194       upper_bound_bol = new BoolNode(upper_bound_bol-&gt;in(1), upper_bound_bol-&gt;_test.negate());
1195       register_new_node(upper_bound_bol, ctrl);
1196       negated = true;
1197     }
1198     ProjNode* upper_bound_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff-&gt;Opcode());
1199     assert(upper_bound_proj-&gt;in(0)-&gt;as_If()-&gt;in(0) == lower_bound_proj, &quot;should dominate&quot;);
1200     IfNode* upper_bound_iff = upper_bound_proj-&gt;in(0)-&gt;as_If();
1201     _igvn.hash_delete(upper_bound_iff);
1202     upper_bound_iff-&gt;set_req(1, upper_bound_bol);
1203     if (TraceLoopPredicate) tty-&gt;print_cr(&quot;upper bound check if: %s %d &quot;, negated ? &quot; negated&quot; : &quot;&quot;, lower_bound_iff-&gt;_idx);
1204 
1205     // Fall through into rest of the clean up code which will move
1206     // any dependent nodes onto the upper bound test.
1207     new_predicate_proj = upper_bound_proj;
1208 
1209     if (iff-&gt;is_RangeCheck()) {
<span class="line-modified">1210       new_predicate_proj = insert_initial_skeleton_predicate(iff, loop, proj, predicate_proj, upper_bound_proj, scale, offset, init, limit, stride, rng, overflow, reason);</span>
1211     }
1212 
1213 #ifndef PRODUCT
1214     if (TraceLoopOpts &amp;&amp; !TraceLoopPredicate) {
1215       tty-&gt;print(&quot;Predicate RC &quot;);
1216       loop-&gt;dump_head();
1217     }
1218 #endif
1219   } else {
1220     // Loop variant check (for example, range check in non-counted loop)
1221     // with uncommon trap.
1222     return false;
1223   }
1224   assert(new_predicate_proj != NULL, &quot;sanity&quot;);
1225   // Success - attach condition (new_predicate_bol) to predicate if
1226   invar.map_ctrl(proj, new_predicate_proj); // so that invariance test can be appropriate
1227 
1228   // Eliminate the old If in the loop body
1229   dominated_by( new_predicate_proj, iff, proj-&gt;_con != new_predicate_proj-&gt;_con );
1230 
1231   C-&gt;set_major_progress();
1232   return true;
1233 }
1234 
1235 
1236 // After pre/main/post loops are created, we&#39;ll put a copy of some
1237 // range checks between the pre and main loop to validate the value
1238 // of the main loop induction variable. Make a copy of the predicates
1239 // here with an opaque node as a place holder for the value (will be
1240 // updated by PhaseIdealLoop::clone_skeleton_predicate()).
<span class="line-modified">1241 ProjNode* PhaseIdealLoop::insert_initial_skeleton_predicate(IfNode* iff, IdealLoopTree *loop,</span>
<span class="line-modified">1242                                                             ProjNode* proj, ProjNode *predicate_proj,</span>
<span class="line-modified">1243                                                             ProjNode* upper_bound_proj,</span>
<span class="line-modified">1244                                                             int scale, Node* offset,</span>
<span class="line-modified">1245                                                             Node* init, Node* limit, jint stride,</span>
<span class="line-modified">1246                                                             Node* rng, bool &amp;overflow,</span>
<span class="line-modified">1247                                                             Deoptimization::DeoptReason reason) {</span>
1248   assert(proj-&gt;_con &amp;&amp; predicate_proj-&gt;_con, &quot;not a range check?&quot;);
1249   Node* opaque_init = new Opaque1Node(C, init);
1250   register_new_node(opaque_init, upper_bound_proj);
1251   BoolNode* bol = rc_predicate(loop, upper_bound_proj, scale, offset, opaque_init, limit, stride, rng, (stride &gt; 0) != (scale &gt; 0), overflow);
1252   Node* opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1)); // This will go away once loop opts are over
1253   register_new_node(opaque_bol, upper_bound_proj);
1254   ProjNode* new_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff-&gt;Opcode());
1255   _igvn.replace_input_of(new_proj-&gt;in(0), 1, opaque_bol);
1256   assert(opaque_init-&gt;outcnt() &gt; 0, &quot;should be used&quot;);
1257   return new_proj;
1258 }
1259 
1260 //------------------------------ loop_predication_impl--------------------------
1261 // Insert loop predicates for null checks and range checks
1262 bool PhaseIdealLoop::loop_predication_impl(IdealLoopTree *loop) {
1263   if (!UseLoopPredicate) return false;
1264 
1265   if (!loop-&gt;_head-&gt;is_Loop()) {
1266     // Could be a simple region when irreducible loops are present.
1267     return false;
</pre>
</td>
</tr>
</table>
<center><a href="library_call.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopTransform.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
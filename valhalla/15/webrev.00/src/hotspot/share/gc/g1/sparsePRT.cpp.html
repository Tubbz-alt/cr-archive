<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/g1/sparsePRT.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/heapRegion.hpp&quot;
 27 #include &quot;gc/g1/heapRegionBounds.inline.hpp&quot;
 28 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
 29 #include &quot;gc/g1/sparsePRT.hpp&quot;
 30 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 31 #include &quot;gc/shared/space.inline.hpp&quot;
 32 #include &quot;memory/allocation.inline.hpp&quot;
 33 
 34 // Check that the size of the SparsePRTEntry is evenly divisible by the maximum
 35 // member type to avoid SIGBUS when accessing them.
 36 STATIC_ASSERT(sizeof(SparsePRTEntry) % sizeof(int) == 0);
 37 
 38 void SparsePRTEntry::init(RegionIdx_t region_ind) {
 39   // Check that the card array element type can represent all cards in the region.
 40   // Choose a large SparsePRTEntry::card_elem_t (e.g. CardIdx_t) if required.
 41   assert(((size_t)1 &lt;&lt; (sizeof(SparsePRTEntry::card_elem_t) * BitsPerByte)) *
 42          G1CardTable::card_size &gt;= HeapRegionBounds::max_size(), &quot;precondition&quot;);
 43   assert(G1RSetSparseRegionEntries &gt; 0, &quot;precondition&quot;);
 44   _region_ind = region_ind;
 45   _next_index = RSHashTable::NullEntry;
 46   _next_null = 0;
 47 }
 48 
 49 bool SparsePRTEntry::contains_card(CardIdx_t card_index) const {
 50   for (int i = 0; i &lt; num_valid_cards(); i++) {
 51     if (card(i) == card_index) {
 52       return true;
 53     }
 54   }
 55   return false;
 56 }
 57 
 58 SparsePRT::AddCardResult SparsePRTEntry::add_card(CardIdx_t card_index) {
 59   for (int i = 0; i &lt; num_valid_cards(); i++) {
 60     if (card(i) == card_index) {
 61       return SparsePRT::found;
 62     }
 63   }
 64   if (num_valid_cards() &lt; cards_num() - 1) {
 65     _cards[_next_null] = (card_elem_t)card_index;
 66     _next_null++;
 67     return SparsePRT::added;
 68    }
 69   // Otherwise, we&#39;re full.
 70   return SparsePRT::overflow;
 71 }
 72 
 73 void SparsePRTEntry::copy_cards(card_elem_t* cards) const {
 74   memcpy(cards, _cards, cards_num() * sizeof(card_elem_t));
 75 }
 76 
 77 void SparsePRTEntry::copy_cards(SparsePRTEntry* e) const {
 78   copy_cards(e-&gt;_cards);
 79   assert(_next_null &gt;= 0, &quot;invariant&quot;);
 80   assert(_next_null &lt;= cards_num(), &quot;invariant&quot;);
 81   e-&gt;_next_null = _next_null;
 82 }
 83 
 84 // ----------------------------------------------------------------------
 85 
 86 float RSHashTable::TableOccupancyFactor = 0.5f;
 87 
 88 RSHashTable::RSHashTable(size_t capacity) :
 89   _num_entries((capacity * TableOccupancyFactor) + 1),
 90   _capacity(capacity),
 91   _capacity_mask(capacity - 1),
 92   _occupied_entries(0),
 93   _entries((SparsePRTEntry*)NEW_C_HEAP_ARRAY(char, _num_entries * SparsePRTEntry::size(), mtGC)),
 94   _buckets(NEW_C_HEAP_ARRAY(int, capacity, mtGC)),
 95   _free_region(0),
 96   _free_list(NullEntry)
 97 {
 98   clear();
 99 }
100 
101 RSHashTable::~RSHashTable() {
102   FREE_C_HEAP_ARRAY(SparsePRTEntry, _entries);
103   FREE_C_HEAP_ARRAY(int, _buckets);
104 }
105 
106 void RSHashTable::clear() {
107   _occupied_entries = 0;
108   guarantee(_entries != NULL, &quot;INV&quot;);
109   guarantee(_buckets != NULL, &quot;INV&quot;);
110 
111   guarantee(_capacity &lt;= ((size_t)1 &lt;&lt; (sizeof(int)*BitsPerByte-1)) - 1,
112                 &quot;_capacity too large&quot;);
113 
114   // This will put -1 == NullEntry in the key field of all entries.
115   memset((void*)_entries, NullEntry, _num_entries * SparsePRTEntry::size());
116   memset((void*)_buckets, NullEntry, _capacity * sizeof(int));
117   _free_list = NullEntry;
118   _free_region = 0;
119 }
120 
121 SparsePRT::AddCardResult RSHashTable::add_card(RegionIdx_t region_ind, CardIdx_t card_index) {
122   SparsePRTEntry* e = entry_for_region_ind_create(region_ind);
123   assert(e != NULL &amp;&amp; e-&gt;r_ind() == region_ind,
124          &quot;Postcondition of call above.&quot;);
125   SparsePRT::AddCardResult res = e-&gt;add_card(card_index);
126   assert(e-&gt;num_valid_cards() &gt; 0, &quot;Postcondition&quot;);
127   return res;
128 }
129 
130 SparsePRTEntry* RSHashTable::get_entry(RegionIdx_t region_ind) const {
131   int ind = (int) (region_ind &amp; capacity_mask());
132   int cur_ind = _buckets[ind];
133   SparsePRTEntry* cur;
134   while (cur_ind != NullEntry &amp;&amp;
135          (cur = entry(cur_ind))-&gt;r_ind() != region_ind) {
136     cur_ind = cur-&gt;next_index();
137   }
138 
139   if (cur_ind == NullEntry) return NULL;
140   // Otherwise...
141   assert(cur-&gt;r_ind() == region_ind, &quot;Postcondition of loop + test above.&quot;);
142   assert(cur-&gt;num_valid_cards() &gt; 0, &quot;Inv&quot;);
143   return cur;
144 }
145 
146 bool RSHashTable::delete_entry(RegionIdx_t region_ind) {
147   int ind = (int) (region_ind &amp; capacity_mask());
148   int* prev_loc = &amp;_buckets[ind];
149   int cur_ind = *prev_loc;
150   SparsePRTEntry* cur;
151   while (cur_ind != NullEntry &amp;&amp;
152          (cur = entry(cur_ind))-&gt;r_ind() != region_ind) {
153     prev_loc = cur-&gt;next_index_addr();
154     cur_ind = *prev_loc;
155   }
156 
157   if (cur_ind == NullEntry) return false;
158   // Otherwise, splice out &quot;cur&quot;.
159   *prev_loc = cur-&gt;next_index();
160   free_entry(cur_ind);
161   _occupied_entries--;
162   return true;
163 }
164 
165 SparsePRTEntry*
166 RSHashTable::entry_for_region_ind_create(RegionIdx_t region_ind) {
167   SparsePRTEntry* res = get_entry(region_ind);
168   if (res == NULL) {
169     int new_ind = alloc_entry();
170     res = entry(new_ind);
171     res-&gt;init(region_ind);
172     // Insert at front.
173     int ind = (int) (region_ind &amp; capacity_mask());
174     res-&gt;set_next_index(_buckets[ind]);
175     _buckets[ind] = new_ind;
176     _occupied_entries++;
177   }
178   return res;
179 }
180 
181 int RSHashTable::alloc_entry() {
182   int res;
183   if (_free_list != NullEntry) {
184     res = _free_list;
185     _free_list = entry(res)-&gt;next_index();
186     return res;
187   } else if ((size_t)_free_region &lt; _num_entries) {
188     res = _free_region;
189     _free_region++;
190     return res;
191   } else {
192     return NullEntry;
193   }
194 }
195 
196 void RSHashTable::free_entry(int fi) {
197   entry(fi)-&gt;set_next_index(_free_list);
198   _free_list = fi;
199 }
200 
201 void RSHashTable::add_entry(SparsePRTEntry* e) {
202   assert(e-&gt;num_valid_cards() &gt; 0, &quot;Precondition.&quot;);
203   SparsePRTEntry* e2 = entry_for_region_ind_create(e-&gt;r_ind());
204   e-&gt;copy_cards(e2);
205   assert(e2-&gt;num_valid_cards() &gt; 0, &quot;Postcondition.&quot;);
206 }
207 
208 bool RSHashTableBucketIter::has_next(SparsePRTEntry*&amp; entry) {
209   while (_bl_ind == RSHashTable::NullEntry)  {
210     if (_tbl_ind == (int)_rsht-&gt;capacity() - 1) {
211       return false;
212     }
213     _tbl_ind++;
214     _bl_ind = _rsht-&gt;_buckets[_tbl_ind];
215   }
216   entry = _rsht-&gt;entry(_bl_ind);
217   _bl_ind = entry-&gt;next_index();
218   return true;
219 }
220 
221 bool RSHashTable::contains_card(RegionIdx_t region_index, CardIdx_t card_index) const {
222   SparsePRTEntry* e = get_entry(region_index);
223   return (e != NULL &amp;&amp; e-&gt;contains_card(card_index));
224 }
225 
226 size_t RSHashTable::mem_size() const {
227   return sizeof(RSHashTable) +
228     _num_entries * (SparsePRTEntry::size() + sizeof(int));
229 }
230 
231 // ----------------------------------------------------------------------
232 
233 SparsePRT::SparsePRT() :
234   _table(new RSHashTable(InitialCapacity)) {
235 }
236 
237 
238 SparsePRT::~SparsePRT() {
239   delete _table;
240 }
241 
242 
243 size_t SparsePRT::mem_size() const {
244   // We ignore &quot;_cur&quot; here, because it either = _next, or else it is
245   // on the deleted list.
246   return sizeof(SparsePRT) + _table-&gt;mem_size();
247 }
248 
249 SparsePRT::AddCardResult SparsePRT::add_card(RegionIdx_t region_id, CardIdx_t card_index) {
250   if (_table-&gt;should_expand()) {
251     expand();
252   }
253   return _table-&gt;add_card(region_id, card_index);
254 }
255 
256 SparsePRTEntry* SparsePRT::get_entry(RegionIdx_t region_id) {
257   return _table-&gt;get_entry(region_id);
258 }
259 
260 bool SparsePRT::delete_entry(RegionIdx_t region_id) {
261   return _table-&gt;delete_entry(region_id);
262 }
263 
264 void SparsePRT::clear() {
265   // If the entry table is not at initial capacity, just create a new one.
266   if (_table-&gt;capacity() != InitialCapacity) {
267     delete _table;
268     _table = new RSHashTable(InitialCapacity);
269   } else {
270     _table-&gt;clear();
271   }
272 }
273 
274 void SparsePRT::expand() {
275   RSHashTable* last = _table;
276   _table = new RSHashTable(last-&gt;capacity() * 2);
277   for (size_t i = 0; i &lt; last-&gt;num_entries(); i++) {
278     SparsePRTEntry* e = last-&gt;entry((int)i);
279     if (e-&gt;valid_entry()) {
280       _table-&gt;add_entry(e);
281     }
282   }
283   delete last;
284 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/sparsePRT.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="heapRegionRemSet.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="sparsePRT.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/sparsePRT.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/heapRegion.hpp&quot;
 27 #include &quot;gc/g1/heapRegionBounds.inline.hpp&quot;
 28 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
 29 #include &quot;gc/g1/sparsePRT.hpp&quot;
 30 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 31 #include &quot;gc/shared/space.inline.hpp&quot;
 32 #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-removed"> 33 #include &quot;runtime/mutexLocker.hpp&quot;</span>
 34 
 35 // Check that the size of the SparsePRTEntry is evenly divisible by the maximum
 36 // member type to avoid SIGBUS when accessing them.
 37 STATIC_ASSERT(sizeof(SparsePRTEntry) % sizeof(int) == 0);
 38 
 39 void SparsePRTEntry::init(RegionIdx_t region_ind) {
 40   // Check that the card array element type can represent all cards in the region.
 41   // Choose a large SparsePRTEntry::card_elem_t (e.g. CardIdx_t) if required.
 42   assert(((size_t)1 &lt;&lt; (sizeof(SparsePRTEntry::card_elem_t) * BitsPerByte)) *
 43          G1CardTable::card_size &gt;= HeapRegionBounds::max_size(), &quot;precondition&quot;);
 44   assert(G1RSetSparseRegionEntries &gt; 0, &quot;precondition&quot;);
 45   _region_ind = region_ind;
 46   _next_index = RSHashTable::NullEntry;
 47   _next_null = 0;
 48 }
 49 
 50 bool SparsePRTEntry::contains_card(CardIdx_t card_index) const {
 51   for (int i = 0; i &lt; num_valid_cards(); i++) {
 52     if (card(i) == card_index) {
 53       return true;
</pre>
<hr />
<pre>
 70   // Otherwise, we&#39;re full.
 71   return SparsePRT::overflow;
 72 }
 73 
 74 void SparsePRTEntry::copy_cards(card_elem_t* cards) const {
 75   memcpy(cards, _cards, cards_num() * sizeof(card_elem_t));
 76 }
 77 
 78 void SparsePRTEntry::copy_cards(SparsePRTEntry* e) const {
 79   copy_cards(e-&gt;_cards);
 80   assert(_next_null &gt;= 0, &quot;invariant&quot;);
 81   assert(_next_null &lt;= cards_num(), &quot;invariant&quot;);
 82   e-&gt;_next_null = _next_null;
 83 }
 84 
 85 // ----------------------------------------------------------------------
 86 
 87 float RSHashTable::TableOccupancyFactor = 0.5f;
 88 
 89 RSHashTable::RSHashTable(size_t capacity) :
<span class="line-modified"> 90   _num_entries(0),</span>
 91   _capacity(capacity),
<span class="line-modified"> 92   _capacity_mask(capacity-1),</span>
 93   _occupied_entries(0),
<span class="line-modified"> 94   _entries(NULL),</span>
 95   _buckets(NEW_C_HEAP_ARRAY(int, capacity, mtGC)),
 96   _free_region(0),
 97   _free_list(NullEntry)
 98 {
<span class="line-removed"> 99   _num_entries = (capacity * TableOccupancyFactor) + 1;</span>
<span class="line-removed">100   _entries = (SparsePRTEntry*)NEW_C_HEAP_ARRAY(char, _num_entries * SparsePRTEntry::size(), mtGC);</span>
101   clear();
102 }
103 
104 RSHashTable::~RSHashTable() {
105   FREE_C_HEAP_ARRAY(SparsePRTEntry, _entries);
106   FREE_C_HEAP_ARRAY(int, _buckets);
107 }
108 
109 void RSHashTable::clear() {
110   _occupied_entries = 0;
111   guarantee(_entries != NULL, &quot;INV&quot;);
112   guarantee(_buckets != NULL, &quot;INV&quot;);
113 
114   guarantee(_capacity &lt;= ((size_t)1 &lt;&lt; (sizeof(int)*BitsPerByte-1)) - 1,
115                 &quot;_capacity too large&quot;);
116 
117   // This will put -1 == NullEntry in the key field of all entries.
118   memset((void*)_entries, NullEntry, _num_entries * SparsePRTEntry::size());
119   memset((void*)_buckets, NullEntry, _capacity * sizeof(int));
120   _free_list = NullEntry;
</pre>
<hr />
<pre>
191     res = _free_region;
192     _free_region++;
193     return res;
194   } else {
195     return NullEntry;
196   }
197 }
198 
199 void RSHashTable::free_entry(int fi) {
200   entry(fi)-&gt;set_next_index(_free_list);
201   _free_list = fi;
202 }
203 
204 void RSHashTable::add_entry(SparsePRTEntry* e) {
205   assert(e-&gt;num_valid_cards() &gt; 0, &quot;Precondition.&quot;);
206   SparsePRTEntry* e2 = entry_for_region_ind_create(e-&gt;r_ind());
207   e-&gt;copy_cards(e2);
208   assert(e2-&gt;num_valid_cards() &gt; 0, &quot;Postcondition.&quot;);
209 }
210 
<span class="line-removed">211 CardIdx_t RSHashTableIter::find_first_card_in_list() {</span>
<span class="line-removed">212   while (_bl_ind != RSHashTable::NullEntry) {</span>
<span class="line-removed">213     SparsePRTEntry* sparse_entry = _rsht-&gt;entry(_bl_ind);</span>
<span class="line-removed">214     if (sparse_entry-&gt;num_valid_cards() &gt; 0) {</span>
<span class="line-removed">215       return sparse_entry-&gt;card(0);</span>
<span class="line-removed">216     } else {</span>
<span class="line-removed">217       _bl_ind = sparse_entry-&gt;next_index();</span>
<span class="line-removed">218     }</span>
<span class="line-removed">219   }</span>
<span class="line-removed">220   // Otherwise, none found:</span>
<span class="line-removed">221   return NoCardFound;</span>
<span class="line-removed">222 }</span>
<span class="line-removed">223 </span>
<span class="line-removed">224 size_t RSHashTableIter::compute_card_ind(CardIdx_t ci) {</span>
<span class="line-removed">225   return (_rsht-&gt;entry(_bl_ind)-&gt;r_ind() * HeapRegion::CardsPerRegion) + ci;</span>
<span class="line-removed">226 }</span>
<span class="line-removed">227 </span>
<span class="line-removed">228 bool RSHashTableIter::has_next(size_t&amp; card_index) {</span>
<span class="line-removed">229   _card_ind++;</span>
<span class="line-removed">230   if (_bl_ind &gt;= 0) {</span>
<span class="line-removed">231     SparsePRTEntry* e = _rsht-&gt;entry(_bl_ind);</span>
<span class="line-removed">232     if (_card_ind &lt; e-&gt;num_valid_cards()) {</span>
<span class="line-removed">233       CardIdx_t ci = e-&gt;card(_card_ind);</span>
<span class="line-removed">234       card_index = compute_card_ind(ci);</span>
<span class="line-removed">235       return true;</span>
<span class="line-removed">236     }</span>
<span class="line-removed">237   }</span>
<span class="line-removed">238 </span>
<span class="line-removed">239   // Otherwise, must find the next valid entry.</span>
<span class="line-removed">240   _card_ind = 0;</span>
<span class="line-removed">241 </span>
<span class="line-removed">242   if (_bl_ind != RSHashTable::NullEntry) {</span>
<span class="line-removed">243       _bl_ind = _rsht-&gt;entry(_bl_ind)-&gt;next_index();</span>
<span class="line-removed">244       CardIdx_t ci = find_first_card_in_list();</span>
<span class="line-removed">245       if (ci != NoCardFound) {</span>
<span class="line-removed">246         card_index = compute_card_ind(ci);</span>
<span class="line-removed">247         return true;</span>
<span class="line-removed">248       }</span>
<span class="line-removed">249   }</span>
<span class="line-removed">250   // If we didn&#39;t return above, must go to the next non-null table index.</span>
<span class="line-removed">251   _tbl_ind++;</span>
<span class="line-removed">252   while ((size_t)_tbl_ind &lt; _rsht-&gt;capacity()) {</span>
<span class="line-removed">253     _bl_ind = _rsht-&gt;_buckets[_tbl_ind];</span>
<span class="line-removed">254     CardIdx_t ci = find_first_card_in_list();</span>
<span class="line-removed">255     if (ci != NoCardFound) {</span>
<span class="line-removed">256       card_index = compute_card_ind(ci);</span>
<span class="line-removed">257       return true;</span>
<span class="line-removed">258     }</span>
<span class="line-removed">259     // Otherwise, try next entry.</span>
<span class="line-removed">260     _tbl_ind++;</span>
<span class="line-removed">261   }</span>
<span class="line-removed">262   // Otherwise, there were no entry.</span>
<span class="line-removed">263   return false;</span>
<span class="line-removed">264 }</span>
<span class="line-removed">265 </span>
266 bool RSHashTableBucketIter::has_next(SparsePRTEntry*&amp; entry) {
267   while (_bl_ind == RSHashTable::NullEntry)  {
268     if (_tbl_ind == (int)_rsht-&gt;capacity() - 1) {
269       return false;
270     }
271     _tbl_ind++;
272     _bl_ind = _rsht-&gt;_buckets[_tbl_ind];
273   }
274   entry = _rsht-&gt;entry(_bl_ind);
275   _bl_ind = entry-&gt;next_index();
276   return true;
277 }
278 
279 bool RSHashTable::contains_card(RegionIdx_t region_index, CardIdx_t card_index) const {
280   SparsePRTEntry* e = get_entry(region_index);
281   return (e != NULL &amp;&amp; e-&gt;contains_card(card_index));
282 }
283 
284 size_t RSHashTable::mem_size() const {
285   return sizeof(RSHashTable) +
</pre>
</td>
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/heapRegion.hpp&quot;
 27 #include &quot;gc/g1/heapRegionBounds.inline.hpp&quot;
 28 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
 29 #include &quot;gc/g1/sparsePRT.hpp&quot;
 30 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 31 #include &quot;gc/shared/space.inline.hpp&quot;
 32 #include &quot;memory/allocation.inline.hpp&quot;

 33 
 34 // Check that the size of the SparsePRTEntry is evenly divisible by the maximum
 35 // member type to avoid SIGBUS when accessing them.
 36 STATIC_ASSERT(sizeof(SparsePRTEntry) % sizeof(int) == 0);
 37 
 38 void SparsePRTEntry::init(RegionIdx_t region_ind) {
 39   // Check that the card array element type can represent all cards in the region.
 40   // Choose a large SparsePRTEntry::card_elem_t (e.g. CardIdx_t) if required.
 41   assert(((size_t)1 &lt;&lt; (sizeof(SparsePRTEntry::card_elem_t) * BitsPerByte)) *
 42          G1CardTable::card_size &gt;= HeapRegionBounds::max_size(), &quot;precondition&quot;);
 43   assert(G1RSetSparseRegionEntries &gt; 0, &quot;precondition&quot;);
 44   _region_ind = region_ind;
 45   _next_index = RSHashTable::NullEntry;
 46   _next_null = 0;
 47 }
 48 
 49 bool SparsePRTEntry::contains_card(CardIdx_t card_index) const {
 50   for (int i = 0; i &lt; num_valid_cards(); i++) {
 51     if (card(i) == card_index) {
 52       return true;
</pre>
<hr />
<pre>
 69   // Otherwise, we&#39;re full.
 70   return SparsePRT::overflow;
 71 }
 72 
 73 void SparsePRTEntry::copy_cards(card_elem_t* cards) const {
 74   memcpy(cards, _cards, cards_num() * sizeof(card_elem_t));
 75 }
 76 
 77 void SparsePRTEntry::copy_cards(SparsePRTEntry* e) const {
 78   copy_cards(e-&gt;_cards);
 79   assert(_next_null &gt;= 0, &quot;invariant&quot;);
 80   assert(_next_null &lt;= cards_num(), &quot;invariant&quot;);
 81   e-&gt;_next_null = _next_null;
 82 }
 83 
 84 // ----------------------------------------------------------------------
 85 
 86 float RSHashTable::TableOccupancyFactor = 0.5f;
 87 
 88 RSHashTable::RSHashTable(size_t capacity) :
<span class="line-modified"> 89   _num_entries((capacity * TableOccupancyFactor) + 1),</span>
 90   _capacity(capacity),
<span class="line-modified"> 91   _capacity_mask(capacity - 1),</span>
 92   _occupied_entries(0),
<span class="line-modified"> 93   _entries((SparsePRTEntry*)NEW_C_HEAP_ARRAY(char, _num_entries * SparsePRTEntry::size(), mtGC)),</span>
 94   _buckets(NEW_C_HEAP_ARRAY(int, capacity, mtGC)),
 95   _free_region(0),
 96   _free_list(NullEntry)
 97 {


 98   clear();
 99 }
100 
101 RSHashTable::~RSHashTable() {
102   FREE_C_HEAP_ARRAY(SparsePRTEntry, _entries);
103   FREE_C_HEAP_ARRAY(int, _buckets);
104 }
105 
106 void RSHashTable::clear() {
107   _occupied_entries = 0;
108   guarantee(_entries != NULL, &quot;INV&quot;);
109   guarantee(_buckets != NULL, &quot;INV&quot;);
110 
111   guarantee(_capacity &lt;= ((size_t)1 &lt;&lt; (sizeof(int)*BitsPerByte-1)) - 1,
112                 &quot;_capacity too large&quot;);
113 
114   // This will put -1 == NullEntry in the key field of all entries.
115   memset((void*)_entries, NullEntry, _num_entries * SparsePRTEntry::size());
116   memset((void*)_buckets, NullEntry, _capacity * sizeof(int));
117   _free_list = NullEntry;
</pre>
<hr />
<pre>
188     res = _free_region;
189     _free_region++;
190     return res;
191   } else {
192     return NullEntry;
193   }
194 }
195 
196 void RSHashTable::free_entry(int fi) {
197   entry(fi)-&gt;set_next_index(_free_list);
198   _free_list = fi;
199 }
200 
201 void RSHashTable::add_entry(SparsePRTEntry* e) {
202   assert(e-&gt;num_valid_cards() &gt; 0, &quot;Precondition.&quot;);
203   SparsePRTEntry* e2 = entry_for_region_ind_create(e-&gt;r_ind());
204   e-&gt;copy_cards(e2);
205   assert(e2-&gt;num_valid_cards() &gt; 0, &quot;Postcondition.&quot;);
206 }
207 























































208 bool RSHashTableBucketIter::has_next(SparsePRTEntry*&amp; entry) {
209   while (_bl_ind == RSHashTable::NullEntry)  {
210     if (_tbl_ind == (int)_rsht-&gt;capacity() - 1) {
211       return false;
212     }
213     _tbl_ind++;
214     _bl_ind = _rsht-&gt;_buckets[_tbl_ind];
215   }
216   entry = _rsht-&gt;entry(_bl_ind);
217   _bl_ind = entry-&gt;next_index();
218   return true;
219 }
220 
221 bool RSHashTable::contains_card(RegionIdx_t region_index, CardIdx_t card_index) const {
222   SparsePRTEntry* e = get_entry(region_index);
223   return (e != NULL &amp;&amp; e-&gt;contains_card(card_index));
224 }
225 
226 size_t RSHashTable::mem_size() const {
227   return sizeof(RSHashTable) +
</pre>
</td>
</tr>
</table>
<center><a href="heapRegionRemSet.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="sparsePRT.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
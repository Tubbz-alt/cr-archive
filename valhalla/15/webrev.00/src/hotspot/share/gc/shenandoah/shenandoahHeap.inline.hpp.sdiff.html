<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahHeap.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeap.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 31 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahBarrierSet.inline.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahCollectionSet.inline.hpp&quot;
 35 #include &quot;gc/shenandoah/shenandoahForwarding.inline.hpp&quot;
 36 #include &quot;gc/shenandoah/shenandoahWorkGroup.hpp&quot;
 37 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
 38 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
 39 #include &quot;gc/shenandoah/shenandoahHeapRegion.inline.hpp&quot;
 40 #include &quot;gc/shenandoah/shenandoahControlThread.hpp&quot;
 41 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 42 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
 43 #include &quot;oops/compressedOops.inline.hpp&quot;
 44 #include &quot;oops/oop.inline.hpp&quot;
 45 #include &quot;runtime/atomic.hpp&quot;
 46 #include &quot;runtime/prefetch.inline.hpp&quot;
 47 #include &quot;runtime/thread.hpp&quot;
 48 #include &quot;utilities/copy.hpp&quot;
 49 #include &quot;utilities/globalDefinitions.hpp&quot;
 50 




 51 
 52 inline ShenandoahHeapRegion* ShenandoahRegionIterator::next() {
 53   size_t new_index = Atomic::add(&amp;_index, (size_t) 1);
 54   // get_region() provides the bounds-check and returns NULL on OOB.
 55   return _heap-&gt;get_region(new_index - 1);
 56 }
 57 
 58 inline bool ShenandoahHeap::has_forwarded_objects() const {
 59   return _gc_state.is_set(HAS_FORWARDED);
 60 }
 61 
 62 inline WorkGang* ShenandoahHeap::workers() const {
 63   return _workers;
 64 }
 65 
 66 inline WorkGang* ShenandoahHeap::get_safepoint_workers() {
 67   return _safepoint_workers;
 68 }
 69 
 70 inline size_t ShenandoahHeap::heap_region_index_containing(const void* addr) const {
</pre>
<hr />
<pre>
231            &quot;Performance: thread should have GCLAB: %s&quot;, thread-&gt;name());
232     // No GCLABs in this thread, fallback to shared allocation
233     return NULL;
234   }
235   HeapWord* obj = gclab-&gt;allocate(size);
236   if (obj != NULL) {
237     return obj;
238   }
239   // Otherwise...
240   return allocate_from_gclab_slow(thread, size);
241 }
242 
243 inline oop ShenandoahHeap::evacuate_object(oop p, Thread* thread) {
244   if (ShenandoahThreadLocalData::is_oom_during_evac(Thread::current())) {
245     // This thread went through the OOM during evac protocol and it is safe to return
246     // the forward pointer. It must not attempt to evacuate any more.
247     return ShenandoahBarrierSet::resolve_forwarded(p);
248   }
249 
250   assert(ShenandoahThreadLocalData::is_evac_allowed(thread), &quot;must be enclosed in oom-evac scope&quot;);

251 
252   size_t size = p-&gt;size();
253 
254   assert(!heap_region_containing(p)-&gt;is_humongous(), &quot;never evacuate humongous objects&quot;);
255 
256   bool alloc_from_gclab = true;
257   HeapWord* copy = NULL;
258 
259 #ifdef ASSERT
260   if (ShenandoahOOMDuringEvacALot &amp;&amp;
261       (os::random() &amp; 1) == 0) { // Simulate OOM every ~2nd slow-path call
262         copy = NULL;
263   } else {
264 #endif
265     if (UseTLAB) {
266       copy = allocate_from_gclab(thread, size);
267     }
268     if (copy == NULL) {
269       ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size);
270       copy = allocate_memory(req);
</pre>
<hr />
<pre>
309     } else {
310       fill_with_object(copy, size);
311       shenandoah_assert_correct(NULL, copy_val);
312     }
313     shenandoah_assert_correct(NULL, result);
314     return result;
315   }
316 }
317 
318 template&lt;bool RESOLVE&gt;
319 inline bool ShenandoahHeap::requires_marking(const void* entry) const {
320   oop obj = oop(entry);
321   if (RESOLVE) {
322     obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
323   }
324   return !_marking_context-&gt;is_marked(obj);
325 }
326 
327 inline bool ShenandoahHeap::in_collection_set(oop p) const {
328   assert(collection_set() != NULL, &quot;Sanity&quot;);
<span class="line-removed">329   assert(is_in(p), &quot;should be in heap&quot;);</span>
330   return collection_set()-&gt;is_in(p);
331 }
332 
333 inline bool ShenandoahHeap::in_collection_set_loc(void* p) const {
334   assert(collection_set() != NULL, &quot;Sanity&quot;);
<span class="line-modified">335   assert(is_in(p), &quot;should be in heap&quot;);</span>
<span class="line-removed">336   return collection_set()-&gt;is_in((HeapWord*)p);</span>
337 }
338 
339 inline bool ShenandoahHeap::is_stable() const {
340   return _gc_state.is_clear();
341 }
342 
343 inline bool ShenandoahHeap::is_idle() const {
344   return _gc_state.is_unset(MARKING | EVACUATION | UPDATEREFS | TRAVERSAL);
345 }
346 
347 inline bool ShenandoahHeap::is_concurrent_mark_in_progress() const {
348   return _gc_state.is_set(MARKING);
349 }
350 
351 inline bool ShenandoahHeap::is_concurrent_traversal_in_progress() const {
352   return _gc_state.is_set(TRAVERSAL);
353 }
354 
355 inline bool ShenandoahHeap::is_evacuation_in_progress() const {
356   return _gc_state.is_set(EVACUATION);
</pre>
</td>
<td>
<hr />
<pre>
 31 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahBarrierSet.inline.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahCollectionSet.inline.hpp&quot;
 35 #include &quot;gc/shenandoah/shenandoahForwarding.inline.hpp&quot;
 36 #include &quot;gc/shenandoah/shenandoahWorkGroup.hpp&quot;
 37 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
 38 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
 39 #include &quot;gc/shenandoah/shenandoahHeapRegion.inline.hpp&quot;
 40 #include &quot;gc/shenandoah/shenandoahControlThread.hpp&quot;
 41 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 42 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
 43 #include &quot;oops/compressedOops.inline.hpp&quot;
 44 #include &quot;oops/oop.inline.hpp&quot;
 45 #include &quot;runtime/atomic.hpp&quot;
 46 #include &quot;runtime/prefetch.inline.hpp&quot;
 47 #include &quot;runtime/thread.hpp&quot;
 48 #include &quot;utilities/copy.hpp&quot;
 49 #include &quot;utilities/globalDefinitions.hpp&quot;
 50 
<span class="line-added"> 51 inline ShenandoahHeap* ShenandoahHeap::heap() {</span>
<span class="line-added"> 52   assert(_heap != NULL, &quot;Heap is not initialized yet&quot;);</span>
<span class="line-added"> 53   return _heap;</span>
<span class="line-added"> 54 }</span>
 55 
 56 inline ShenandoahHeapRegion* ShenandoahRegionIterator::next() {
 57   size_t new_index = Atomic::add(&amp;_index, (size_t) 1);
 58   // get_region() provides the bounds-check and returns NULL on OOB.
 59   return _heap-&gt;get_region(new_index - 1);
 60 }
 61 
 62 inline bool ShenandoahHeap::has_forwarded_objects() const {
 63   return _gc_state.is_set(HAS_FORWARDED);
 64 }
 65 
 66 inline WorkGang* ShenandoahHeap::workers() const {
 67   return _workers;
 68 }
 69 
 70 inline WorkGang* ShenandoahHeap::get_safepoint_workers() {
 71   return _safepoint_workers;
 72 }
 73 
 74 inline size_t ShenandoahHeap::heap_region_index_containing(const void* addr) const {
</pre>
<hr />
<pre>
235            &quot;Performance: thread should have GCLAB: %s&quot;, thread-&gt;name());
236     // No GCLABs in this thread, fallback to shared allocation
237     return NULL;
238   }
239   HeapWord* obj = gclab-&gt;allocate(size);
240   if (obj != NULL) {
241     return obj;
242   }
243   // Otherwise...
244   return allocate_from_gclab_slow(thread, size);
245 }
246 
247 inline oop ShenandoahHeap::evacuate_object(oop p, Thread* thread) {
248   if (ShenandoahThreadLocalData::is_oom_during_evac(Thread::current())) {
249     // This thread went through the OOM during evac protocol and it is safe to return
250     // the forward pointer. It must not attempt to evacuate any more.
251     return ShenandoahBarrierSet::resolve_forwarded(p);
252   }
253 
254   assert(ShenandoahThreadLocalData::is_evac_allowed(thread), &quot;must be enclosed in oom-evac scope&quot;);
<span class="line-added">255   assert(is_concurrent_traversal_in_progress() || !is_traversal_mode(), &quot;Should not evacuate objects&quot;);</span>
256 
257   size_t size = p-&gt;size();
258 
259   assert(!heap_region_containing(p)-&gt;is_humongous(), &quot;never evacuate humongous objects&quot;);
260 
261   bool alloc_from_gclab = true;
262   HeapWord* copy = NULL;
263 
264 #ifdef ASSERT
265   if (ShenandoahOOMDuringEvacALot &amp;&amp;
266       (os::random() &amp; 1) == 0) { // Simulate OOM every ~2nd slow-path call
267         copy = NULL;
268   } else {
269 #endif
270     if (UseTLAB) {
271       copy = allocate_from_gclab(thread, size);
272     }
273     if (copy == NULL) {
274       ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size);
275       copy = allocate_memory(req);
</pre>
<hr />
<pre>
314     } else {
315       fill_with_object(copy, size);
316       shenandoah_assert_correct(NULL, copy_val);
317     }
318     shenandoah_assert_correct(NULL, result);
319     return result;
320   }
321 }
322 
323 template&lt;bool RESOLVE&gt;
324 inline bool ShenandoahHeap::requires_marking(const void* entry) const {
325   oop obj = oop(entry);
326   if (RESOLVE) {
327     obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
328   }
329   return !_marking_context-&gt;is_marked(obj);
330 }
331 
332 inline bool ShenandoahHeap::in_collection_set(oop p) const {
333   assert(collection_set() != NULL, &quot;Sanity&quot;);

334   return collection_set()-&gt;is_in(p);
335 }
336 
337 inline bool ShenandoahHeap::in_collection_set_loc(void* p) const {
338   assert(collection_set() != NULL, &quot;Sanity&quot;);
<span class="line-modified">339   return collection_set()-&gt;is_in_loc(p);</span>

340 }
341 
342 inline bool ShenandoahHeap::is_stable() const {
343   return _gc_state.is_clear();
344 }
345 
346 inline bool ShenandoahHeap::is_idle() const {
347   return _gc_state.is_unset(MARKING | EVACUATION | UPDATEREFS | TRAVERSAL);
348 }
349 
350 inline bool ShenandoahHeap::is_concurrent_mark_in_progress() const {
351   return _gc_state.is_set(MARKING);
352 }
353 
354 inline bool ShenandoahHeap::is_concurrent_traversal_in_progress() const {
355   return _gc_state.is_set(TRAVERSAL);
356 }
357 
358 inline bool ShenandoahHeap::is_evacuation_in_progress() const {
359   return _gc_state.is_set(EVACUATION);
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
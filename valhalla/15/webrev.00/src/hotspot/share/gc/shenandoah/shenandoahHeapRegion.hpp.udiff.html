<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeapRegion.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.inline.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -23,21 +23,22 @@</span>
   */
  
  #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGION_HPP
  #define SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGION_HPP
  
<span class="udiff-line-modified-removed">- #include &quot;gc/shared/space.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/shared/spaceDecorator.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahAllocRequest.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahPacer.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shenandoah/shenandoahPadding.hpp&quot;</span>
  #include &quot;utilities/sizes.hpp&quot;
  
  class VMStructs;
  class ShenandoahHeapRegionStateConstant;
  
<span class="udiff-line-modified-removed">- class ShenandoahHeapRegion : public ContiguousSpace {</span>
<span class="udiff-line-modified-added">+ class ShenandoahHeapRegion : public CHeapObj&lt;mtGC&gt; {</span>
    friend class VMStructs;
    friend class ShenandoahHeapRegionStateConstant;
  private:
    /*
      Region state is described by a state machine. Transitions are guarded by
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -222,52 +223,53 @@</span>
    static size_t MaxTLABSizeWords;
  
    // Global allocation counter, increased for each allocation under Shenandoah heap lock.
    // Padded to avoid false sharing with the read-only fields above.
    struct PaddedAllocSeqNum {
<span class="udiff-line-modified-removed">-     DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(uint64_t));</span>
<span class="udiff-line-modified-added">+     shenandoah_padding(0);</span>
      uint64_t value;
<span class="udiff-line-modified-removed">-     DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);</span>
<span class="udiff-line-modified-added">+     shenandoah_padding(1);</span>
  
      PaddedAllocSeqNum() {
        // start with 1, reserve 0 for uninitialized value
        value = 1;
      }
    };
  
    static PaddedAllocSeqNum _alloc_seq_num;
  
    // Never updated fields
<span class="udiff-line-modified-removed">-   ShenandoahHeap* _heap;</span>
<span class="udiff-line-modified-removed">-   MemRegion _reserved;</span>
<span class="udiff-line-modified-removed">-   size_t _region_number;</span>
<span class="udiff-line-modified-added">+   size_t const _region_number;</span>
<span class="udiff-line-modified-added">+   HeapWord* const _bottom;</span>
<span class="udiff-line-modified-added">+   HeapWord* const _end;</span>
  
    // Rarely updated fields
    HeapWord* _new_top;
    double _empty_time;
  
    // Seldom updated fields
    RegionState _state;
  
    // Frequently updated fields
<span class="udiff-line-added">+   HeapWord* _top;</span>
<span class="udiff-line-added">+ </span>
    size_t _tlab_allocs;
    size_t _gclab_allocs;
    size_t _shared_allocs;
  
<span class="udiff-line-removed">-   uint64_t _seqnum_first_alloc_mutator;</span>
<span class="udiff-line-removed">-   uint64_t _seqnum_first_alloc_gc;</span>
    uint64_t _seqnum_last_alloc_mutator;
<span class="udiff-line-removed">-   uint64_t _seqnum_last_alloc_gc;</span>
  
    volatile size_t _live_data;
    volatile size_t _critical_pins;
  
<span class="udiff-line-added">+   HeapWord* _update_watermark;</span>
<span class="udiff-line-added">+ </span>
    // Claim some space at the end to protect next region
<span class="udiff-line-modified-removed">-   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);</span>
<span class="udiff-line-modified-added">+   shenandoah_padding(0);</span>
  
  public:
<span class="udiff-line-modified-removed">-   ShenandoahHeapRegion(ShenandoahHeap* heap, HeapWord* start, size_t size_words, size_t index, bool committed);</span>
<span class="udiff-line-modified-added">+   ShenandoahHeapRegion(HeapWord* start, size_t index, bool committed);</span>
  
    static const size_t MIN_NUM_REGIONS = 10;
  
    static void setup_sizes(size_t max_heap_size);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -355,12 +357,10 @@</span>
    size_t region_number() const;
  
    // Allocation (return NULL if full)
    inline HeapWord* allocate(size_t word_size, ShenandoahAllocRequest::Type type);
  
<span class="udiff-line-removed">-   HeapWord* allocate(size_t word_size) shenandoah_not_implemented_return(NULL)</span>
<span class="udiff-line-removed">- </span>
    void clear_live_data();
    void set_live_data(size_t s);
  
    // Increase live data for newly allocated region
    inline void increase_live_data_alloc_words(size_t s);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -378,56 +378,55 @@</span>
  
    void recycle();
  
    void oop_iterate(OopIterateClosure* cl);
  
<span class="udiff-line-modified-removed">-   HeapWord* block_start_const(const void* p) const;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   bool in_collection_set() const;</span>
<span class="udiff-line-modified-added">+   HeapWord* block_start(const void* p) const;</span>
<span class="udiff-line-modified-added">+   size_t block_size(const HeapWord* p) const;</span>
<span class="udiff-line-modified-added">+   bool block_is_obj(const HeapWord* p) const { return p &lt; top(); }</span>
  
    // Find humongous start region that this region belongs to
    ShenandoahHeapRegion* humongous_start_region() const;
  
<span class="udiff-line-modified-removed">-   CompactibleSpace* next_compaction_space() const shenandoah_not_implemented_return(NULL);</span>
<span class="udiff-line-modified-removed">-   void prepare_for_compaction(CompactPoint* cp)   shenandoah_not_implemented;</span>
<span class="udiff-line-removed">-   void adjust_pointers()                          shenandoah_not_implemented;</span>
<span class="udiff-line-removed">-   void compact()                                  shenandoah_not_implemented;</span>
<span class="udiff-line-modified-added">+   HeapWord* top() const         { return _top;     }</span>
<span class="udiff-line-modified-added">+   void set_top(HeapWord* v)     { _top = v;        }</span>
  
<span class="udiff-line-modified-removed">-   void set_new_top(HeapWord* new_top) { _new_top = new_top; }</span>
<span class="udiff-line-modified-removed">-   HeapWord* new_top() const { return _new_top; }</span>
<span class="udiff-line-modified-added">+   HeapWord* new_top() const     { return _new_top; }</span>
<span class="udiff-line-modified-added">+   void set_new_top(HeapWord* v) { _new_top = v;    }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   HeapWord* bottom() const      { return _bottom;  }</span>
<span class="udiff-line-added">+   HeapWord* end() const         { return _end;     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size_t capacity() const       { return byte_size(bottom(), end()); }</span>
<span class="udiff-line-added">+   size_t used() const           { return byte_size(bottom(), top()); }</span>
<span class="udiff-line-added">+   size_t free() const           { return byte_size(top(),    end()); }</span>
  
    inline void adjust_alloc_metadata(ShenandoahAllocRequest::Type type, size_t);
    void reset_alloc_metadata_to_shared();
    void reset_alloc_metadata();
    size_t get_shared_allocs() const;
    size_t get_tlab_allocs() const;
    size_t get_gclab_allocs() const;
  
<span class="udiff-line-modified-removed">-   uint64_t seqnum_first_alloc() const {</span>
<span class="udiff-line-modified-removed">-     if (_seqnum_first_alloc_mutator == 0) return _seqnum_first_alloc_gc;</span>
<span class="udiff-line-modified-removed">-     if (_seqnum_first_alloc_gc == 0)      return _seqnum_first_alloc_mutator;</span>
<span class="udiff-line-modified-removed">-     return MIN2(_seqnum_first_alloc_mutator, _seqnum_first_alloc_gc);</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   uint64_t seqnum_last_alloc() const {</span>
<span class="udiff-line-modified-removed">-     return MAX2(_seqnum_last_alloc_mutator, _seqnum_last_alloc_gc);</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   uint64_t seqnum_first_alloc_mutator() const {</span>
<span class="udiff-line-modified-removed">-     return _seqnum_first_alloc_mutator;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   uint64_t seqnum_last_alloc_mutator()  const {</span>
<span class="udiff-line-removed">-     return _seqnum_last_alloc_mutator;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   uint64_t seqnum_first_alloc_gc() const {</span>
<span class="udiff-line-removed">-     return _seqnum_first_alloc_gc;</span>
<span class="udiff-line-modified-added">+   inline uint64_t seqnum_last_alloc_mutator() const;</span>
<span class="udiff-line-modified-added">+   void update_seqnum_last_alloc_mutator();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   HeapWord* get_update_watermark() const {</span>
<span class="udiff-line-modified-added">+     // Updates to the update-watermark only happen at safepoints or, when pushing</span>
<span class="udiff-line-modified-added">+     // back the watermark for evacuation regions, under the Shenandoah heap-lock.</span>
<span class="udiff-line-modified-added">+     // Consequently, we should access the field under the same lock. However, since</span>
<span class="udiff-line-modified-added">+     // those updates are only monotonically increasing, possibly reading a stale value</span>
<span class="udiff-line-modified-added">+     // is only conservative - we would not miss to update any fields.</span>
<span class="udiff-line-modified-added">+     HeapWord* watermark = _update_watermark;</span>
<span class="udiff-line-modified-added">+     assert(bottom() &lt;= watermark &amp;&amp; watermark &lt;= top(), &quot;within bounds&quot;);</span>
<span class="udiff-line-modified-added">+     return watermark;</span>
    }
  
<span class="udiff-line-modified-removed">-   uint64_t seqnum_last_alloc_gc()  const {</span>
<span class="udiff-line-modified-removed">-     return _seqnum_last_alloc_gc;</span>
<span class="udiff-line-modified-added">+   void set_update_watermark(HeapWord* w) {</span>
<span class="udiff-line-modified-added">+     shenandoah_assert_heaplocked_or_safepoint();</span>
<span class="udiff-line-added">+     assert(bottom() &lt;= w &amp;&amp; w &lt;= top(), &quot;within bounds&quot;);</span>
<span class="udiff-line-added">+     _update_watermark = w;</span>
    }
  
  private:
    void do_commit();
    void do_uncommit();
</pre>
<center><a href="shenandoahHeapRegion.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.inline.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
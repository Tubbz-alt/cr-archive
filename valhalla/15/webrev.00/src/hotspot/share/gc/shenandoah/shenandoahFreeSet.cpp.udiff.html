<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shenandoah/shenandoahFreeSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahForwarding.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahFreeSet.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahFreeSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -40,11 +40,11 @@</span>
  {
    clear_internal();
  }
  
  void ShenandoahFreeSet::increase_used(size_t num_bytes) {
<span class="udiff-line-modified-removed">-   assert_heaplock_owned_by_current_thread();</span>
<span class="udiff-line-modified-added">+   shenandoah_assert_heaplocked();</span>
    _used += num_bytes;
  
    assert(_used &lt;= _capacity, &quot;must not use more than we have: used: &quot; SIZE_FORMAT
           &quot;, capacity: &quot; SIZE_FORMAT &quot;, num_bytes: &quot; SIZE_FORMAT, _used, _capacity, num_bytes);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -177,22 +177,28 @@</span>
  
    if (result != NULL) {
      // Allocation successful, bump stats:
      if (req.is_mutator_alloc()) {
        increase_used(size * HeapWordSize);
<span class="udiff-line-added">+       if (_heap-&gt;is_traversal_mode()) {</span>
<span class="udiff-line-added">+         r-&gt;update_seqnum_last_alloc_mutator();</span>
<span class="udiff-line-added">+       }</span>
      }
  
      // Record actual allocation size
      req.set_actual_size(size);
  
<span class="udiff-line-modified-removed">-     if (req.is_gc_alloc() &amp;&amp; _heap-&gt;is_concurrent_traversal_in_progress()) {</span>
<span class="udiff-line-modified-removed">-       // Traversal needs to traverse through GC allocs. Adjust TAMS to the new top</span>
<span class="udiff-line-modified-removed">-       // so that these allocations appear below TAMS, and thus get traversed.</span>
<span class="udiff-line-modified-removed">-       // See top of shenandoahTraversal.cpp for an explanation.</span>
<span class="udiff-line-modified-removed">-       _heap-&gt;marking_context()-&gt;capture_top_at_mark_start(r);</span>
<span class="udiff-line-modified-removed">-       _heap-&gt;traversal_gc()-&gt;traversal_set()-&gt;add_region_check_for_duplicates(r);</span>
<span class="udiff-line-modified-removed">-       OrderAccess::fence();</span>
<span class="udiff-line-modified-added">+     if (req.is_gc_alloc()) {</span>
<span class="udiff-line-modified-added">+       r-&gt;set_update_watermark(r-&gt;top());</span>
<span class="udiff-line-modified-added">+       if (_heap-&gt;is_concurrent_traversal_in_progress()) {</span>
<span class="udiff-line-modified-added">+         // Traversal needs to traverse through GC allocs. Adjust TAMS to the new top</span>
<span class="udiff-line-modified-added">+         // so that these allocations appear below TAMS, and thus get traversed.</span>
<span class="udiff-line-modified-added">+         // See top of shenandoahTraversal.cpp for an explanation.</span>
<span class="udiff-line-modified-added">+         _heap-&gt;marking_context()-&gt;capture_top_at_mark_start(r);</span>
<span class="udiff-line-added">+         _heap-&gt;traversal_gc()-&gt;traversal_set()-&gt;add_region_check_for_duplicates(r);</span>
<span class="udiff-line-added">+         OrderAccess::fence();</span>
<span class="udiff-line-added">+       }</span>
      }
    }
  
    if (result == NULL || has_no_alloc_capacity(r)) {
      // Region cannot afford this or future allocations. Retire it.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -254,11 +260,11 @@</span>
      _collector_rightmost--;
    }
  }
  
  HeapWord* ShenandoahFreeSet::allocate_contiguous(ShenandoahAllocRequest&amp; req) {
<span class="udiff-line-modified-removed">-   assert_heaplock_owned_by_current_thread();</span>
<span class="udiff-line-modified-added">+   shenandoah_assert_heaplocked();</span>
  
    size_t words_size = req.size();
    size_t num = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);
  
    // No regions left to satisfy allocation, bye.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -367,11 +373,11 @@</span>
    }
  }
  
  void ShenandoahFreeSet::recycle_trash() {
    // lock is not reentrable, check we don&#39;t have it
<span class="udiff-line-modified-removed">-   assert_heaplock_not_owned_by_current_thread();</span>
<span class="udiff-line-modified-added">+   shenandoah_assert_not_heaplocked();</span>
  
    for (size_t i = 0; i &lt; _heap-&gt;num_regions(); i++) {
      ShenandoahHeapRegion* r = _heap-&gt;get_region(i);
      if (r-&gt;is_trash()) {
        ShenandoahHeapLocker locker(_heap-&gt;lock());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -399,11 +405,11 @@</span>
    }
    assert_bounds();
  }
  
  void ShenandoahFreeSet::clear() {
<span class="udiff-line-modified-removed">-   assert_heaplock_owned_by_current_thread();</span>
<span class="udiff-line-modified-added">+   shenandoah_assert_heaplocked();</span>
    clear_internal();
  }
  
  void ShenandoahFreeSet::clear_internal() {
    _mutator_free_bitmap.clear();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -415,11 +421,11 @@</span>
    _capacity = 0;
    _used = 0;
  }
  
  void ShenandoahFreeSet::rebuild() {
<span class="udiff-line-modified-removed">-   assert_heaplock_owned_by_current_thread();</span>
<span class="udiff-line-modified-added">+   shenandoah_assert_heaplocked();</span>
    clear();
  
    for (size_t idx = 0; idx &lt; _heap-&gt;num_regions(); idx++) {
      ShenandoahHeapRegion* region = _heap-&gt;get_region(idx);
      if (region-&gt;is_alloc_allowed() || region-&gt;is_trash()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -456,11 +462,11 @@</span>
    recompute_bounds();
    assert_bounds();
  }
  
  void ShenandoahFreeSet::log_status() {
<span class="udiff-line-modified-removed">-   assert_heaplock_owned_by_current_thread();</span>
<span class="udiff-line-modified-added">+   shenandoah_assert_heaplocked();</span>
  
    LogTarget(Info, gc, ergo) lt;
    if (lt.is_enabled()) {
      ResourceMark rm;
      LogStream ls(lt);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -471,20 +477,26 @@</span>
        size_t max_contig = 0;
        size_t empty_contig = 0;
  
        size_t total_used = 0;
        size_t total_free = 0;
<span class="udiff-line-added">+       size_t total_free_ext = 0;</span>
  
        for (size_t idx = _mutator_leftmost; idx &lt;= _mutator_rightmost; idx++) {
          if (is_mutator_free(idx)) {
            ShenandoahHeapRegion *r = _heap-&gt;get_region(idx);
            size_t free = alloc_capacity(r);
  
            max = MAX2(max, free);
  
<span class="udiff-line-modified-removed">-           if (r-&gt;is_empty() &amp;&amp; (last_idx + 1 == idx)) {</span>
<span class="udiff-line-modified-removed">-             empty_contig++;</span>
<span class="udiff-line-modified-added">+           if (r-&gt;is_empty()) {</span>
<span class="udiff-line-modified-added">+             total_free_ext += free;</span>
<span class="udiff-line-added">+             if (last_idx + 1 == idx) {</span>
<span class="udiff-line-added">+               empty_contig++;</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+               empty_contig = 1;</span>
<span class="udiff-line-added">+             }</span>
            } else {
              empty_contig = 0;
            }
  
            total_used += r-&gt;used();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -504,12 +516,12 @@</span>
                 byte_size_in_proper_unit(max),           proper_unit_for_byte_size(max),
                 byte_size_in_proper_unit(max_humongous), proper_unit_for_byte_size(max_humongous)
        );
  
        size_t frag_ext;
<span class="udiff-line-modified-removed">-       if (free &gt; 0) {</span>
<span class="udiff-line-modified-removed">-         frag_ext = 100 - (100 * max_humongous / free);</span>
<span class="udiff-line-modified-added">+       if (total_free_ext &gt; 0) {</span>
<span class="udiff-line-modified-added">+         frag_ext = 100 - (100 * max_humongous / total_free_ext);</span>
        } else {
          frag_ext = 0;
        }
        ls.print(&quot;External frag: &quot; SIZE_FORMAT &quot;%%, &quot;, frag_ext);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -543,11 +555,11 @@</span>
      }
    }
  }
  
  HeapWord* ShenandoahFreeSet::allocate(ShenandoahAllocRequest&amp; req, bool&amp; in_new_region) {
<span class="udiff-line-modified-removed">-   assert_heaplock_owned_by_current_thread();</span>
<span class="udiff-line-modified-added">+   shenandoah_assert_heaplocked();</span>
    assert_bounds();
  
    if (req.size() &gt; ShenandoahHeapRegion::humongous_threshold_words()) {
      switch (req.type()) {
        case ShenandoahAllocRequest::_alloc_shared:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -598,19 +610,101 @@</span>
        _heap-&gt;get_region(index)-&gt;print_on(out);
      }
    }
  }
  
<span class="udiff-line-modified-removed">- #ifdef ASSERT</span>
<span class="udiff-line-modified-removed">- void ShenandoahFreeSet::assert_heaplock_owned_by_current_thread() const {</span>
<span class="udiff-line-modified-removed">-   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
<span class="udiff-line-modified-added">+ /*</span>
<span class="udiff-line-modified-added">+  * Internal fragmentation metric: describes how fragmented the heap regions are.</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-added">+  * It is derived as:</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  *               sum(used[i]^2, i=0..k)</span>
<span class="udiff-line-added">+  *   IF = 1 - ------------------------------</span>
<span class="udiff-line-added">+  *              C * sum(used[i], i=0..k)</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * ...where k is the number of regions in computation, C is the region capacity, and</span>
<span class="udiff-line-added">+  * used[i] is the used space in the region.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * The non-linearity causes IF to be lower for the cases where the same total heap</span>
<span class="udiff-line-added">+  * used is densely packed. For example:</span>
<span class="udiff-line-added">+  *   a) Heap is completely full  =&gt; IF = 0</span>
<span class="udiff-line-added">+  *   b) Heap is half full, first 50% regions are completely full =&gt; IF = 0</span>
<span class="udiff-line-added">+  *   c) Heap is half full, each region is 50% full =&gt; IF = 1/2</span>
<span class="udiff-line-added">+  *   d) Heap is quarter full, first 50% regions are completely full =&gt; IF = 0</span>
<span class="udiff-line-added">+  *   e) Heap is quarter full, each region is 25% full =&gt; IF = 3/4</span>
<span class="udiff-line-added">+  *   f) Heap has one small object per each region =&gt; IF =~ 1</span>
<span class="udiff-line-added">+  */</span>
<span class="udiff-line-added">+ double ShenandoahFreeSet::internal_fragmentation() {</span>
<span class="udiff-line-added">+   double squared = 0;</span>
<span class="udiff-line-added">+   double linear = 0;</span>
<span class="udiff-line-added">+   int count = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   for (size_t index = _mutator_leftmost; index &lt;= _mutator_rightmost; index++) {</span>
<span class="udiff-line-added">+     if (is_mutator_free(index)) {</span>
<span class="udiff-line-added">+       ShenandoahHeapRegion* r = _heap-&gt;get_region(index);</span>
<span class="udiff-line-added">+       size_t used = r-&gt;used();</span>
<span class="udiff-line-added">+       squared += used * used;</span>
<span class="udiff-line-added">+       linear += used;</span>
<span class="udiff-line-added">+       count++;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (count &gt; 0) {</span>
<span class="udiff-line-added">+     double s = squared / (ShenandoahHeapRegion::region_size_bytes() * linear);</span>
<span class="udiff-line-added">+     return 1 - s;</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     return 0;</span>
<span class="udiff-line-added">+   }</span>
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahFreeSet::assert_heaplock_not_owned_by_current_thread() const {</span>
<span class="udiff-line-modified-removed">-   _heap-&gt;assert_heaplock_not_owned_by_current_thread();</span>
<span class="udiff-line-modified-added">+ /*</span>
<span class="udiff-line-modified-added">+  * External fragmentation metric: describes how fragmented the heap is.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * It is derived as:</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  *   EF = 1 - largest_contiguous_free / total_free</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * For example:</span>
<span class="udiff-line-added">+  *   a) Heap is completely empty =&gt; EF = 0</span>
<span class="udiff-line-added">+  *   b) Heap is completely full =&gt; EF = 0</span>
<span class="udiff-line-added">+  *   c) Heap is first-half full =&gt; EF = 1/2</span>
<span class="udiff-line-added">+  *   d) Heap is half full, full and empty regions interleave =&gt; EF =~ 1</span>
<span class="udiff-line-added">+  */</span>
<span class="udiff-line-added">+ double ShenandoahFreeSet::external_fragmentation() {</span>
<span class="udiff-line-added">+   size_t last_idx = 0;</span>
<span class="udiff-line-added">+   size_t max_contig = 0;</span>
<span class="udiff-line-added">+   size_t empty_contig = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size_t free = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   for (size_t index = _mutator_leftmost; index &lt;= _mutator_rightmost; index++) {</span>
<span class="udiff-line-added">+     if (is_mutator_free(index)) {</span>
<span class="udiff-line-added">+       ShenandoahHeapRegion* r = _heap-&gt;get_region(index);</span>
<span class="udiff-line-added">+       if (r-&gt;is_empty()) {</span>
<span class="udiff-line-added">+         free += ShenandoahHeapRegion::region_size_bytes();</span>
<span class="udiff-line-added">+         if (last_idx + 1 == index) {</span>
<span class="udiff-line-added">+           empty_contig++;</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           empty_contig = 1;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         empty_contig = 0;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       max_contig = MAX2(max_contig, empty_contig);</span>
<span class="udiff-line-added">+       last_idx = index;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (free &gt; 0) {</span>
<span class="udiff-line-added">+     return 1 - (1.0 * max_contig * ShenandoahHeapRegion::region_size_bytes() / free);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     return 0;</span>
<span class="udiff-line-added">+   }</span>
  }
  
<span class="udiff-line-added">+ #ifdef ASSERT</span>
  void ShenandoahFreeSet::assert_bounds() const {
    // Performance invariants. Failing these would not break the free set, but performance
    // would suffer.
    assert (_mutator_leftmost &lt;= _max, &quot;leftmost in bounds: &quot;  SIZE_FORMAT &quot; &lt; &quot; SIZE_FORMAT, _mutator_leftmost,  _max);
    assert (_mutator_rightmost &lt; _max, &quot;rightmost in bounds: &quot; SIZE_FORMAT &quot; &lt; &quot; SIZE_FORMAT, _mutator_rightmost, _max);
</pre>
<center><a href="shenandoahForwarding.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahFreeSet.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahAsserts.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahArguments.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahAsserts.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahAsserts.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
152     } else {
153       msg.append(&quot;  (the object itself)&quot;);
154     }
155     msg.append(&quot;\n&quot;);
156   }
157 
158   if (level &gt;= _safe_oop_fwd) {
159     oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);
160     oop fwd2 = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(fwd);
161     if (fwd != fwd2) {
162       msg.append(&quot;Second forwardee:\n&quot;);
163       print_obj_safe(msg, fwd2);
164       msg.append(&quot;\n&quot;);
165     }
166   }
167 
168   report_vm_error(file, line, msg.buffer());
169 }
170 
171 void ShenandoahAsserts::assert_in_heap(void* interior_loc, oop obj, const char *file, int line) {
<span class="line-modified">172   ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();</span>
173 
174   if (!heap-&gt;is_in(obj)) {
175     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_in_heap failed&quot;,
176                   &quot;oop must point to a heap address&quot;,
177                   file, line);
178   }
179 }
180 
181 void ShenandoahAsserts::assert_correct(void* interior_loc, oop obj, const char* file, int line) {
<span class="line-modified">182   ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();</span>
183 
184   // Step 1. Check that obj is correct.
185   // After this step, it is safe to call heap_region_containing().
186   if (!heap-&gt;is_in(obj)) {
187     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
188                   &quot;oop must point to a heap address&quot;,
189                   file, line);
190   }
191 
192   Klass* obj_klass = obj-&gt;klass_or_null();
193   if (obj_klass == NULL) {
194     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
195                   &quot;Object klass pointer should not be NULL&quot;,
196                   file,line);
197   }
198 
199   if (!Metaspace::contains(obj_klass)) {
200     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
201                   &quot;Object klass pointer must go to metaspace&quot;,
202                   file,line);
</pre>
<hr />
<pre>
230     // Step 3. Check that forwardee points to correct region
231     if (heap-&gt;heap_region_index_containing(fwd) == heap-&gt;heap_region_index_containing(obj)) {
232       print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
233                     &quot;Non-trivial forwardee should in another region&quot;,
234                     file, line);
235     }
236 
237     // Step 4. Check for multiple forwardings
238     oop fwd2 = oop(ShenandoahForwarding::get_forwardee_raw_unchecked(fwd));
239     if (fwd != fwd2) {
240       print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
241                     &quot;Multiple forwardings&quot;,
242                     file, line);
243     }
244   }
245 }
246 
247 void ShenandoahAsserts::assert_in_correct_region(void* interior_loc, oop obj, const char* file, int line) {
248   assert_correct(interior_loc, obj, file, line);
249 
<span class="line-modified">250   ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();</span>
251   ShenandoahHeapRegion* r = heap-&gt;heap_region_containing(obj);
252   if (!r-&gt;is_active()) {
253     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_in_correct_region failed&quot;,
254                   &quot;Object must reside in active region&quot;,
255                   file, line);
256   }
257 
258   size_t alloc_size = obj-&gt;size();
259   if (alloc_size &gt; ShenandoahHeapRegion::humongous_threshold_words()) {
260     size_t idx = r-&gt;region_number();
261     size_t num_regions = ShenandoahHeapRegion::required_regions(alloc_size * HeapWordSize);
262     for (size_t i = idx; i &lt; idx + num_regions; i++) {
263       ShenandoahHeapRegion* chain_reg = heap-&gt;get_region(i);
264       if (i == idx &amp;&amp; !chain_reg-&gt;is_humongous_start()) {
265         print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_in_correct_region failed&quot;,
266                       &quot;Object must reside in humongous start&quot;,
267                       file, line);
268       }
269       if (i != idx &amp;&amp; !chain_reg-&gt;is_humongous_continuation()) {
270         print_failure(_safe_oop, obj, interior_loc, NULL, &quot;Shenandoah assert_in_correct_region failed&quot;,
</pre>
<hr />
<pre>
283     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_forwarded failed&quot;,
284                   &quot;Object should be forwarded&quot;,
285                   file, line);
286   }
287 }
288 
289 void ShenandoahAsserts::assert_not_forwarded(void* interior_loc, oop obj, const char* file, int line) {
290   assert_correct(interior_loc, obj, file, line);
291   oop fwd = oop(ShenandoahForwarding::get_forwardee_raw_unchecked(obj));
292 
293   if (obj != fwd) {
294     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_not_forwarded failed&quot;,
295                   &quot;Object should not be forwarded&quot;,
296                   file, line);
297   }
298 }
299 
300 void ShenandoahAsserts::assert_marked(void *interior_loc, oop obj, const char *file, int line) {
301   assert_correct(interior_loc, obj, file, line);
302 
<span class="line-modified">303   ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();</span>
304   if (!heap-&gt;marking_context()-&gt;is_marked(obj)) {
305     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_marked failed&quot;,
306                   &quot;Object should be marked&quot;,
307                   file, line);
308   }
309 }
310 
311 void ShenandoahAsserts::assert_in_cset(void* interior_loc, oop obj, const char* file, int line) {
312   assert_correct(interior_loc, obj, file, line);
313 
<span class="line-modified">314   ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();</span>
315   if (!heap-&gt;in_collection_set(obj)) {
316     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_in_cset failed&quot;,
317                   &quot;Object should be in collection set&quot;,
318                   file, line);
319   }
320 }
321 
322 void ShenandoahAsserts::assert_not_in_cset(void* interior_loc, oop obj, const char* file, int line) {
323   assert_correct(interior_loc, obj, file, line);
324 
<span class="line-modified">325   ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();</span>
326   if (heap-&gt;in_collection_set(obj)) {
327     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_not_in_cset failed&quot;,
328                   &quot;Object should not be in collection set&quot;,
329                   file, line);
330   }
331 }
332 
333 void ShenandoahAsserts::assert_not_in_cset_loc(void* interior_loc, const char* file, int line) {
<span class="line-modified">334   ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();</span>
335   if (heap-&gt;in_collection_set_loc(interior_loc)) {
336     print_failure(_safe_unknown, NULL, interior_loc, NULL, &quot;Shenandoah assert_not_in_cset_loc failed&quot;,
337                   &quot;Interior location should not be in collection set&quot;,
338                   file, line);
339   }
340 }
341 
342 void ShenandoahAsserts::print_rp_failure(const char *label, BoolObjectClosure* actual,
343                                          const char *file, int line) {
344   ShenandoahMessageBuffer msg(&quot;%s\n&quot;, label);
345   msg.append(&quot; Actual:                  &quot; PTR_FORMAT &quot;\n&quot;, p2i(actual));
346   report_vm_error(file, line, msg.buffer());
347 }
348 
349 void ShenandoahAsserts::assert_rp_isalive_not_installed(const char *file, int line) {
350   ShenandoahHeap* heap = ShenandoahHeap::heap();
351   ReferenceProcessor* rp = heap-&gt;ref_processor();
352   if (rp-&gt;is_alive_non_header() != NULL) {
353     print_rp_failure(&quot;Shenandoah assert_rp_isalive_not_installed failed&quot;, rp-&gt;is_alive_non_header(),
354                      file, line);
</pre>
<hr />
<pre>
359   ShenandoahHeap* heap = ShenandoahHeap::heap();
360   ReferenceProcessor* rp = heap-&gt;ref_processor();
361   if (rp-&gt;is_alive_non_header() == NULL) {
362     print_rp_failure(&quot;Shenandoah assert_rp_isalive_installed failed&quot;, rp-&gt;is_alive_non_header(),
363                      file, line);
364   }
365 }
366 
367 void ShenandoahAsserts::assert_locked_or_shenandoah_safepoint(Mutex* lock, const char* file, int line) {
368   if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {
369     return;
370   }
371 
372   if (lock-&gt;owned_by_self()) {
373     return;
374   }
375 
376   ShenandoahMessageBuffer msg(&quot;Must ba at a Shenandoah safepoint or held %s lock&quot;, lock-&gt;name());
377   report_vm_error(file, line, msg.buffer());
378 }





































</pre>
</td>
<td>
<hr />
<pre>
152     } else {
153       msg.append(&quot;  (the object itself)&quot;);
154     }
155     msg.append(&quot;\n&quot;);
156   }
157 
158   if (level &gt;= _safe_oop_fwd) {
159     oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);
160     oop fwd2 = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(fwd);
161     if (fwd != fwd2) {
162       msg.append(&quot;Second forwardee:\n&quot;);
163       print_obj_safe(msg, fwd2);
164       msg.append(&quot;\n&quot;);
165     }
166   }
167 
168   report_vm_error(file, line, msg.buffer());
169 }
170 
171 void ShenandoahAsserts::assert_in_heap(void* interior_loc, oop obj, const char *file, int line) {
<span class="line-modified">172   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
173 
174   if (!heap-&gt;is_in(obj)) {
175     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_in_heap failed&quot;,
176                   &quot;oop must point to a heap address&quot;,
177                   file, line);
178   }
179 }
180 
181 void ShenandoahAsserts::assert_correct(void* interior_loc, oop obj, const char* file, int line) {
<span class="line-modified">182   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
183 
184   // Step 1. Check that obj is correct.
185   // After this step, it is safe to call heap_region_containing().
186   if (!heap-&gt;is_in(obj)) {
187     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
188                   &quot;oop must point to a heap address&quot;,
189                   file, line);
190   }
191 
192   Klass* obj_klass = obj-&gt;klass_or_null();
193   if (obj_klass == NULL) {
194     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
195                   &quot;Object klass pointer should not be NULL&quot;,
196                   file,line);
197   }
198 
199   if (!Metaspace::contains(obj_klass)) {
200     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
201                   &quot;Object klass pointer must go to metaspace&quot;,
202                   file,line);
</pre>
<hr />
<pre>
230     // Step 3. Check that forwardee points to correct region
231     if (heap-&gt;heap_region_index_containing(fwd) == heap-&gt;heap_region_index_containing(obj)) {
232       print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
233                     &quot;Non-trivial forwardee should in another region&quot;,
234                     file, line);
235     }
236 
237     // Step 4. Check for multiple forwardings
238     oop fwd2 = oop(ShenandoahForwarding::get_forwardee_raw_unchecked(fwd));
239     if (fwd != fwd2) {
240       print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
241                     &quot;Multiple forwardings&quot;,
242                     file, line);
243     }
244   }
245 }
246 
247 void ShenandoahAsserts::assert_in_correct_region(void* interior_loc, oop obj, const char* file, int line) {
248   assert_correct(interior_loc, obj, file, line);
249 
<span class="line-modified">250   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
251   ShenandoahHeapRegion* r = heap-&gt;heap_region_containing(obj);
252   if (!r-&gt;is_active()) {
253     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_in_correct_region failed&quot;,
254                   &quot;Object must reside in active region&quot;,
255                   file, line);
256   }
257 
258   size_t alloc_size = obj-&gt;size();
259   if (alloc_size &gt; ShenandoahHeapRegion::humongous_threshold_words()) {
260     size_t idx = r-&gt;region_number();
261     size_t num_regions = ShenandoahHeapRegion::required_regions(alloc_size * HeapWordSize);
262     for (size_t i = idx; i &lt; idx + num_regions; i++) {
263       ShenandoahHeapRegion* chain_reg = heap-&gt;get_region(i);
264       if (i == idx &amp;&amp; !chain_reg-&gt;is_humongous_start()) {
265         print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_in_correct_region failed&quot;,
266                       &quot;Object must reside in humongous start&quot;,
267                       file, line);
268       }
269       if (i != idx &amp;&amp; !chain_reg-&gt;is_humongous_continuation()) {
270         print_failure(_safe_oop, obj, interior_loc, NULL, &quot;Shenandoah assert_in_correct_region failed&quot;,
</pre>
<hr />
<pre>
283     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_forwarded failed&quot;,
284                   &quot;Object should be forwarded&quot;,
285                   file, line);
286   }
287 }
288 
289 void ShenandoahAsserts::assert_not_forwarded(void* interior_loc, oop obj, const char* file, int line) {
290   assert_correct(interior_loc, obj, file, line);
291   oop fwd = oop(ShenandoahForwarding::get_forwardee_raw_unchecked(obj));
292 
293   if (obj != fwd) {
294     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_not_forwarded failed&quot;,
295                   &quot;Object should not be forwarded&quot;,
296                   file, line);
297   }
298 }
299 
300 void ShenandoahAsserts::assert_marked(void *interior_loc, oop obj, const char *file, int line) {
301   assert_correct(interior_loc, obj, file, line);
302 
<span class="line-modified">303   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
304   if (!heap-&gt;marking_context()-&gt;is_marked(obj)) {
305     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_marked failed&quot;,
306                   &quot;Object should be marked&quot;,
307                   file, line);
308   }
309 }
310 
311 void ShenandoahAsserts::assert_in_cset(void* interior_loc, oop obj, const char* file, int line) {
312   assert_correct(interior_loc, obj, file, line);
313 
<span class="line-modified">314   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
315   if (!heap-&gt;in_collection_set(obj)) {
316     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_in_cset failed&quot;,
317                   &quot;Object should be in collection set&quot;,
318                   file, line);
319   }
320 }
321 
322 void ShenandoahAsserts::assert_not_in_cset(void* interior_loc, oop obj, const char* file, int line) {
323   assert_correct(interior_loc, obj, file, line);
324 
<span class="line-modified">325   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
326   if (heap-&gt;in_collection_set(obj)) {
327     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_not_in_cset failed&quot;,
328                   &quot;Object should not be in collection set&quot;,
329                   file, line);
330   }
331 }
332 
333 void ShenandoahAsserts::assert_not_in_cset_loc(void* interior_loc, const char* file, int line) {
<span class="line-modified">334   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
335   if (heap-&gt;in_collection_set_loc(interior_loc)) {
336     print_failure(_safe_unknown, NULL, interior_loc, NULL, &quot;Shenandoah assert_not_in_cset_loc failed&quot;,
337                   &quot;Interior location should not be in collection set&quot;,
338                   file, line);
339   }
340 }
341 
342 void ShenandoahAsserts::print_rp_failure(const char *label, BoolObjectClosure* actual,
343                                          const char *file, int line) {
344   ShenandoahMessageBuffer msg(&quot;%s\n&quot;, label);
345   msg.append(&quot; Actual:                  &quot; PTR_FORMAT &quot;\n&quot;, p2i(actual));
346   report_vm_error(file, line, msg.buffer());
347 }
348 
349 void ShenandoahAsserts::assert_rp_isalive_not_installed(const char *file, int line) {
350   ShenandoahHeap* heap = ShenandoahHeap::heap();
351   ReferenceProcessor* rp = heap-&gt;ref_processor();
352   if (rp-&gt;is_alive_non_header() != NULL) {
353     print_rp_failure(&quot;Shenandoah assert_rp_isalive_not_installed failed&quot;, rp-&gt;is_alive_non_header(),
354                      file, line);
</pre>
<hr />
<pre>
359   ShenandoahHeap* heap = ShenandoahHeap::heap();
360   ReferenceProcessor* rp = heap-&gt;ref_processor();
361   if (rp-&gt;is_alive_non_header() == NULL) {
362     print_rp_failure(&quot;Shenandoah assert_rp_isalive_installed failed&quot;, rp-&gt;is_alive_non_header(),
363                      file, line);
364   }
365 }
366 
367 void ShenandoahAsserts::assert_locked_or_shenandoah_safepoint(Mutex* lock, const char* file, int line) {
368   if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {
369     return;
370   }
371 
372   if (lock-&gt;owned_by_self()) {
373     return;
374   }
375 
376   ShenandoahMessageBuffer msg(&quot;Must ba at a Shenandoah safepoint or held %s lock&quot;, lock-&gt;name());
377   report_vm_error(file, line, msg.buffer());
378 }
<span class="line-added">379 </span>
<span class="line-added">380 void ShenandoahAsserts::assert_heaplocked(const char* file, int line) {</span>
<span class="line-added">381   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-added">382 </span>
<span class="line-added">383   if (heap-&gt;lock()-&gt;owned_by_self()) {</span>
<span class="line-added">384     return;</span>
<span class="line-added">385   }</span>
<span class="line-added">386 </span>
<span class="line-added">387   ShenandoahMessageBuffer msg(&quot;Heap lock must be owned by current thread&quot;);</span>
<span class="line-added">388   report_vm_error(file, line, msg.buffer());</span>
<span class="line-added">389 }</span>
<span class="line-added">390 </span>
<span class="line-added">391 void ShenandoahAsserts::assert_not_heaplocked(const char* file, int line) {</span>
<span class="line-added">392   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-added">393 </span>
<span class="line-added">394   if (!heap-&gt;lock()-&gt;owned_by_self()) {</span>
<span class="line-added">395     return;</span>
<span class="line-added">396   }</span>
<span class="line-added">397 </span>
<span class="line-added">398   ShenandoahMessageBuffer msg(&quot;Heap lock must not be owned by current thread&quot;);</span>
<span class="line-added">399   report_vm_error(file, line, msg.buffer());</span>
<span class="line-added">400 }</span>
<span class="line-added">401 </span>
<span class="line-added">402 void ShenandoahAsserts::assert_heaplocked_or_safepoint(const char* file, int line) {</span>
<span class="line-added">403   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-added">404 </span>
<span class="line-added">405   if (heap-&gt;lock()-&gt;owned_by_self()) {</span>
<span class="line-added">406     return;</span>
<span class="line-added">407   }</span>
<span class="line-added">408 </span>
<span class="line-added">409   if (ShenandoahSafepoint::is_at_shenandoah_safepoint() &amp;&amp; Thread::current()-&gt;is_VM_thread()) {</span>
<span class="line-added">410     return;</span>
<span class="line-added">411   }</span>
<span class="line-added">412 </span>
<span class="line-added">413   ShenandoahMessageBuffer msg(&quot;Heap lock must be owned by current thread, or be at safepoint&quot;);</span>
<span class="line-added">414   report_vm_error(file, line, msg.buffer());</span>
<span class="line-added">415 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahArguments.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahAsserts.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2013, 2020, Red Hat, Inc. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;memory/allocation.hpp&quot;
  27 #include &quot;memory/universe.hpp&quot;
  28 
  29 #include &quot;gc/shared/gcArguments.hpp&quot;
  30 #include &quot;gc/shared/gcTimer.hpp&quot;
  31 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  32 #include &quot;gc/shared/locationPrinter.inline.hpp&quot;
  33 #include &quot;gc/shared/memAllocator.hpp&quot;
  34 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  35 #include &quot;gc/shared/plab.hpp&quot;
  36 
<a name="1" id="anc1"></a><span class="line-removed">  37 #include &quot;gc/shenandoah/shenandoahAllocTracker.hpp&quot;</span>
  38 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
  39 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;
  40 #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  41 #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
  42 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
  43 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;
  44 #include &quot;gc/shenandoah/shenandoahControlThread.hpp&quot;
  45 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  46 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  47 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  48 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  49 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
  50 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
  51 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  52 #include &quot;gc/shenandoah/shenandoahMemoryPool.hpp&quot;
  53 #include &quot;gc/shenandoah/shenandoahMetrics.hpp&quot;
  54 #include &quot;gc/shenandoah/shenandoahMonitoringSupport.hpp&quot;
  55 #include &quot;gc/shenandoah/shenandoahNormalMode.hpp&quot;
  56 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
  57 #include &quot;gc/shenandoah/shenandoahPacer.inline.hpp&quot;
<a name="2" id="anc2"></a>
  58 #include &quot;gc/shenandoah/shenandoahParallelCleaning.inline.hpp&quot;
  59 #include &quot;gc/shenandoah/shenandoahPassiveMode.hpp&quot;
  60 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;
  61 #include &quot;gc/shenandoah/shenandoahStringDedup.hpp&quot;
  62 #include &quot;gc/shenandoah/shenandoahTaskqueue.hpp&quot;
  63 #include &quot;gc/shenandoah/shenandoahTraversalMode.hpp&quot;
  64 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  65 #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  66 #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
  67 #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
  68 #include &quot;gc/shenandoah/shenandoahWorkGroup.hpp&quot;
  69 #include &quot;gc/shenandoah/shenandoahWorkerPolicy.hpp&quot;
  70 #if INCLUDE_JFR
  71 #include &quot;gc/shenandoah/shenandoahJfrSupport.hpp&quot;
  72 #endif
  73 
  74 #include &quot;memory/metaspace.hpp&quot;
  75 #include &quot;oops/compressedOops.inline.hpp&quot;
  76 #include &quot;runtime/atomic.hpp&quot;
  77 #include &quot;runtime/globals.hpp&quot;
  78 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  79 #include &quot;runtime/orderAccess.hpp&quot;
  80 #include &quot;runtime/safepointMechanism.hpp&quot;
  81 #include &quot;runtime/vmThread.hpp&quot;
  82 #include &quot;services/mallocTracker.hpp&quot;
  83 #include &quot;utilities/powerOfTwo.hpp&quot;
  84 
<a name="3" id="anc3"></a>

  85 #ifdef ASSERT
  86 template &lt;class T&gt;
  87 void ShenandoahAssertToSpaceClosure::do_oop_work(T* p) {
  88   T o = RawAccess&lt;&gt;::oop_load(p);
  89   if (! CompressedOops::is_null(o)) {
  90     oop obj = CompressedOops::decode_not_null(o);
  91     shenandoah_assert_not_forwarded(p, obj);
  92   }
  93 }
  94 
  95 void ShenandoahAssertToSpaceClosure::do_oop(narrowOop* p) { do_oop_work(p); }
  96 void ShenandoahAssertToSpaceClosure::do_oop(oop* p)       { do_oop_work(p); }
  97 #endif
  98 
  99 class ShenandoahPretouchHeapTask : public AbstractGangTask {
 100 private:
 101   ShenandoahRegionIterator _regions;
 102   const size_t _page_size;
 103 public:
 104   ShenandoahPretouchHeapTask(size_t page_size) :
 105     AbstractGangTask(&quot;Shenandoah Pretouch Heap&quot;),
 106     _page_size(page_size) {}
 107 
 108   virtual void work(uint worker_id) {
 109     ShenandoahHeapRegion* r = _regions.next();
 110     while (r != NULL) {
 111       os::pretouch_memory(r-&gt;bottom(), r-&gt;end(), _page_size);
 112       r = _regions.next();
 113     }
 114   }
 115 };
 116 
 117 class ShenandoahPretouchBitmapTask : public AbstractGangTask {
 118 private:
 119   ShenandoahRegionIterator _regions;
 120   char* _bitmap_base;
 121   const size_t _bitmap_size;
 122   const size_t _page_size;
 123 public:
 124   ShenandoahPretouchBitmapTask(char* bitmap_base, size_t bitmap_size, size_t page_size) :
 125     AbstractGangTask(&quot;Shenandoah Pretouch Bitmap&quot;),
 126     _bitmap_base(bitmap_base),
 127     _bitmap_size(bitmap_size),
 128     _page_size(page_size) {}
 129 
 130   virtual void work(uint worker_id) {
 131     ShenandoahHeapRegion* r = _regions.next();
 132     while (r != NULL) {
 133       size_t start = r-&gt;region_number()       * ShenandoahHeapRegion::region_size_bytes() / MarkBitMap::heap_map_factor();
 134       size_t end   = (r-&gt;region_number() + 1) * ShenandoahHeapRegion::region_size_bytes() / MarkBitMap::heap_map_factor();
 135       assert (end &lt;= _bitmap_size, &quot;end is sane: &quot; SIZE_FORMAT &quot; &lt; &quot; SIZE_FORMAT, end, _bitmap_size);
 136 
 137       os::pretouch_memory(_bitmap_base + start, _bitmap_base + end, _page_size);
 138 
 139       r = _regions.next();
 140     }
 141   }
 142 };
 143 
 144 jint ShenandoahHeap::initialize() {
 145   initialize_heuristics();
 146 
 147   //
 148   // Figure out heap sizing
 149   //
 150 
 151   size_t init_byte_size = InitialHeapSize;
 152   size_t min_byte_size  = MinHeapSize;
 153   size_t max_byte_size  = MaxHeapSize;
 154   size_t heap_alignment = HeapAlignment;
 155 
 156   size_t reg_size_bytes = ShenandoahHeapRegion::region_size_bytes();
 157 
 158   if (ShenandoahAlwaysPreTouch) {
 159     // Enabled pre-touch means the entire heap is committed right away.
 160     init_byte_size = max_byte_size;
 161   }
 162 
 163   Universe::check_alignment(max_byte_size,  reg_size_bytes, &quot;Shenandoah heap&quot;);
 164   Universe::check_alignment(init_byte_size, reg_size_bytes, &quot;Shenandoah heap&quot;);
 165 
 166   _num_regions = ShenandoahHeapRegion::region_count();
 167 
 168   size_t num_committed_regions = init_byte_size / reg_size_bytes;
 169   num_committed_regions = MIN2(num_committed_regions, _num_regions);
 170   assert(num_committed_regions &lt;= _num_regions, &quot;sanity&quot;);
 171   _initial_size = num_committed_regions * reg_size_bytes;
 172 
 173   size_t num_min_regions = min_byte_size / reg_size_bytes;
 174   num_min_regions = MIN2(num_min_regions, _num_regions);
 175   assert(num_min_regions &lt;= _num_regions, &quot;sanity&quot;);
 176   _minimum_size = num_min_regions * reg_size_bytes;
 177 
 178   _committed = _initial_size;
 179 
 180   size_t heap_page_size   = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
 181   size_t bitmap_page_size = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
 182 
 183   //
 184   // Reserve and commit memory for heap
 185   //
 186 
 187   ReservedHeapSpace heap_rs = Universe::reserve_heap(max_byte_size, heap_alignment);
 188   initialize_reserved_region(heap_rs);
 189   _heap_region = MemRegion((HeapWord*)heap_rs.base(), heap_rs.size() / HeapWordSize);
 190   _heap_region_special = heap_rs.special();
 191 
 192   assert((((size_t) base()) &amp; ShenandoahHeapRegion::region_size_bytes_mask()) == 0,
 193          &quot;Misaligned heap: &quot; PTR_FORMAT, p2i(base()));
 194 
 195 #if SHENANDOAH_OPTIMIZED_OBJTASK
 196   // The optimized ObjArrayChunkedTask takes some bits away from the full object bits.
 197   // Fail if we ever attempt to address more than we can.
 198   if ((uintptr_t)heap_rs.end() &gt;= ObjArrayChunkedTask::max_addressable()) {
 199     FormatBuffer&lt;512&gt; buf(&quot;Shenandoah reserved [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT&quot;) for the heap, \n&quot;
 200                           &quot;but max object address is &quot; PTR_FORMAT &quot;. Try to reduce heap size, or try other \n&quot;
 201                           &quot;VM options that allocate heap at lower addresses (HeapBaseMinAddress, AllocateHeapAt, etc).&quot;,
 202                 p2i(heap_rs.base()), p2i(heap_rs.end()), ObjArrayChunkedTask::max_addressable());
 203     vm_exit_during_initialization(&quot;Fatal Error&quot;, buf);
 204   }
 205 #endif
 206 
 207   ReservedSpace sh_rs = heap_rs.first_part(max_byte_size);
 208   if (!_heap_region_special) {
 209     os::commit_memory_or_exit(sh_rs.base(), _initial_size, heap_alignment, false,
 210                               &quot;Cannot commit heap memory&quot;);
 211   }
 212 
 213   //
 214   // Reserve and commit memory for bitmap(s)
 215   //
 216 
 217   _bitmap_size = MarkBitMap::compute_size(heap_rs.size());
 218   _bitmap_size = align_up(_bitmap_size, bitmap_page_size);
 219 
 220   size_t bitmap_bytes_per_region = reg_size_bytes / MarkBitMap::heap_map_factor();
 221 
 222   guarantee(bitmap_bytes_per_region != 0,
 223             &quot;Bitmap bytes per region should not be zero&quot;);
 224   guarantee(is_power_of_2(bitmap_bytes_per_region),
 225             &quot;Bitmap bytes per region should be power of two: &quot; SIZE_FORMAT, bitmap_bytes_per_region);
 226 
 227   if (bitmap_page_size &gt; bitmap_bytes_per_region) {
 228     _bitmap_regions_per_slice = bitmap_page_size / bitmap_bytes_per_region;
 229     _bitmap_bytes_per_slice = bitmap_page_size;
 230   } else {
 231     _bitmap_regions_per_slice = 1;
 232     _bitmap_bytes_per_slice = bitmap_bytes_per_region;
 233   }
 234 
 235   guarantee(_bitmap_regions_per_slice &gt;= 1,
 236             &quot;Should have at least one region per slice: &quot; SIZE_FORMAT,
 237             _bitmap_regions_per_slice);
 238 
 239   guarantee(((_bitmap_bytes_per_slice) % bitmap_page_size) == 0,
 240             &quot;Bitmap slices should be page-granular: bps = &quot; SIZE_FORMAT &quot;, page size = &quot; SIZE_FORMAT,
 241             _bitmap_bytes_per_slice, bitmap_page_size);
 242 
 243   ReservedSpace bitmap(_bitmap_size, bitmap_page_size);
 244   MemTracker::record_virtual_memory_type(bitmap.base(), mtGC);
 245   _bitmap_region = MemRegion((HeapWord*) bitmap.base(), bitmap.size() / HeapWordSize);
 246   _bitmap_region_special = bitmap.special();
 247 
 248   size_t bitmap_init_commit = _bitmap_bytes_per_slice *
 249                               align_up(num_committed_regions, _bitmap_regions_per_slice) / _bitmap_regions_per_slice;
 250   bitmap_init_commit = MIN2(_bitmap_size, bitmap_init_commit);
 251   if (!_bitmap_region_special) {
 252     os::commit_memory_or_exit((char *) _bitmap_region.start(), bitmap_init_commit, bitmap_page_size, false,
 253                               &quot;Cannot commit bitmap memory&quot;);
 254   }
 255 
 256   _marking_context = new ShenandoahMarkingContext(_heap_region, _bitmap_region, _num_regions);
 257 
 258   if (ShenandoahVerify) {
 259     ReservedSpace verify_bitmap(_bitmap_size, bitmap_page_size);
 260     if (!verify_bitmap.special()) {
 261       os::commit_memory_or_exit(verify_bitmap.base(), verify_bitmap.size(), bitmap_page_size, false,
 262                                 &quot;Cannot commit verification bitmap memory&quot;);
 263     }
 264     MemTracker::record_virtual_memory_type(verify_bitmap.base(), mtGC);
 265     MemRegion verify_bitmap_region = MemRegion((HeapWord *) verify_bitmap.base(), verify_bitmap.size() / HeapWordSize);
 266     _verification_bit_map.initialize(_heap_region, verify_bitmap_region);
 267     _verifier = new ShenandoahVerifier(this, &amp;_verification_bit_map);
 268   }
 269 
 270   // Reserve aux bitmap for use in object_iterate(). We don&#39;t commit it here.
 271   ReservedSpace aux_bitmap(_bitmap_size, bitmap_page_size);
 272   MemTracker::record_virtual_memory_type(aux_bitmap.base(), mtGC);
 273   _aux_bitmap_region = MemRegion((HeapWord*) aux_bitmap.base(), aux_bitmap.size() / HeapWordSize);
 274   _aux_bitmap_region_special = aux_bitmap.special();
 275   _aux_bit_map.initialize(_heap_region, _aux_bitmap_region);
 276 
 277   //
 278   // Create regions and region sets
 279   //
 280 
 281   _regions = NEW_C_HEAP_ARRAY(ShenandoahHeapRegion*, _num_regions, mtGC);
 282   _free_set = new ShenandoahFreeSet(this, _num_regions);
 283   _collection_set = new ShenandoahCollectionSet(this, sh_rs.base(), sh_rs.size());
 284 
 285   {
 286     ShenandoahHeapLocker locker(lock());
 287 
<a name="4" id="anc4"></a><span class="line-removed"> 288     size_t size_words = ShenandoahHeapRegion::region_size_words();</span>
<span class="line-removed"> 289 </span>
 290     for (size_t i = 0; i &lt; _num_regions; i++) {
<a name="5" id="anc5"></a><span class="line-modified"> 291       HeapWord* start = (HeapWord*)sh_rs.base() + size_words * i;</span>
 292       bool is_committed = i &lt; num_committed_regions;
<a name="6" id="anc6"></a><span class="line-modified"> 293       ShenandoahHeapRegion* r = new ShenandoahHeapRegion(this, start, size_words, i, is_committed);</span>
 294 
 295       _marking_context-&gt;initialize_top_at_mark_start(r);
 296       _regions[i] = r;
 297       assert(!collection_set()-&gt;is_in(i), &quot;New region should not be in collection set&quot;);
 298     }
 299 
 300     // Initialize to complete
 301     _marking_context-&gt;mark_complete();
 302 
 303     _free_set-&gt;rebuild();
 304   }
 305 
 306   if (ShenandoahAlwaysPreTouch) {
 307     assert(!AlwaysPreTouch, &quot;Should have been overridden&quot;);
 308 
 309     // For NUMA, it is important to pre-touch the storage under bitmaps with worker threads,
 310     // before initialize() below zeroes it with initializing thread. For any given region,
 311     // we touch the region and the corresponding bitmaps from the same thread.
 312     ShenandoahPushWorkerScope scope(workers(), _max_workers, false);
 313 
 314     size_t pretouch_heap_page_size = heap_page_size;
 315     size_t pretouch_bitmap_page_size = bitmap_page_size;
 316 
 317 #ifdef LINUX
 318     // UseTransparentHugePages would madvise that backing memory can be coalesced into huge
 319     // pages. But, the kernel needs to know that every small page is used, in order to coalesce
 320     // them into huge one. Therefore, we need to pretouch with smaller pages.
 321     if (UseTransparentHugePages) {
 322       pretouch_heap_page_size = (size_t)os::vm_page_size();
 323       pretouch_bitmap_page_size = (size_t)os::vm_page_size();
 324     }
 325 #endif
 326 
 327     // OS memory managers may want to coalesce back-to-back pages. Make their jobs
 328     // simpler by pre-touching continuous spaces (heap and bitmap) separately.
 329 
 330     log_info(gc, init)(&quot;Pretouch bitmap: &quot; SIZE_FORMAT &quot; regions, &quot; SIZE_FORMAT &quot; bytes page&quot;,
 331                        _num_regions, pretouch_bitmap_page_size);
 332     ShenandoahPretouchBitmapTask bcl(bitmap.base(), _bitmap_size, pretouch_bitmap_page_size);
 333     _workers-&gt;run_task(&amp;bcl);
 334 
 335     log_info(gc, init)(&quot;Pretouch heap: &quot; SIZE_FORMAT &quot; regions, &quot; SIZE_FORMAT &quot; bytes page&quot;,
 336                        _num_regions, pretouch_heap_page_size);
 337     ShenandoahPretouchHeapTask hcl(pretouch_heap_page_size);
 338     _workers-&gt;run_task(&amp;hcl);
 339   }
 340 
 341   //
 342   // Initialize the rest of GC subsystems
 343   //
 344 
 345   _liveness_cache = NEW_C_HEAP_ARRAY(jushort*, _max_workers, mtGC);
 346   for (uint worker = 0; worker &lt; _max_workers; worker++) {
 347     _liveness_cache[worker] = NEW_C_HEAP_ARRAY(jushort, _num_regions, mtGC);
 348     Copy::fill_to_bytes(_liveness_cache[worker], _num_regions * sizeof(jushort));
 349   }
 350 
 351   // There should probably be Shenandoah-specific options for these,
 352   // just as there are G1-specific options.
 353   {
 354     ShenandoahSATBMarkQueueSet&amp; satbqs = ShenandoahBarrierSet::satb_mark_queue_set();
 355     satbqs.set_process_completed_buffers_threshold(20); // G1SATBProcessCompletedThreshold
 356     satbqs.set_buffer_enqueue_threshold_percentage(60); // G1SATBBufferEnqueueingThresholdPercent
 357   }
 358 
 359   _monitoring_support = new ShenandoahMonitoringSupport(this);
 360   _phase_timings = new ShenandoahPhaseTimings();
 361   ShenandoahStringDedup::initialize();
 362   ShenandoahCodeRoots::initialize();
 363 
<a name="7" id="anc7"></a><span class="line-removed"> 364   if (ShenandoahAllocationTrace) {</span>
<span class="line-removed"> 365     _alloc_tracker = new ShenandoahAllocTracker();</span>
<span class="line-removed"> 366   }</span>
<span class="line-removed"> 367 </span>
 368   if (ShenandoahPacing) {
 369     _pacer = new ShenandoahPacer(this);
 370     _pacer-&gt;setup_for_idle();
 371   } else {
 372     _pacer = NULL;
 373   }
 374 
 375   _traversal_gc = strcmp(ShenandoahGCMode, &quot;traversal&quot;) == 0 ?
<a name="8" id="anc8"></a><span class="line-modified"> 376                   new ShenandoahTraversalGC(this, _num_regions) :</span>
 377                   NULL;
 378 
 379   _control_thread = new ShenandoahControlThread();
 380 
 381   log_info(gc, init)(&quot;Initialize Shenandoah heap: &quot; SIZE_FORMAT &quot;%s initial, &quot; SIZE_FORMAT &quot;%s min, &quot; SIZE_FORMAT &quot;%s max&quot;,
 382                      byte_size_in_proper_unit(_initial_size),  proper_unit_for_byte_size(_initial_size),
 383                      byte_size_in_proper_unit(_minimum_size),  proper_unit_for_byte_size(_minimum_size),
 384                      byte_size_in_proper_unit(max_capacity()), proper_unit_for_byte_size(max_capacity())
 385   );
 386 
 387   log_info(gc, init)(&quot;Safepointing mechanism: %s&quot;,
 388                      SafepointMechanism::uses_thread_local_poll() ? &quot;thread-local poll&quot; :
 389                      (SafepointMechanism::uses_global_page_poll() ? &quot;global-page poll&quot; : &quot;unknown&quot;));
 390 
 391   return JNI_OK;
 392 }
 393 
 394 void ShenandoahHeap::initialize_heuristics() {
 395   if (ShenandoahGCMode != NULL) {
 396     if (strcmp(ShenandoahGCMode, &quot;traversal&quot;) == 0) {
 397       _gc_mode = new ShenandoahTraversalMode();
 398     } else if (strcmp(ShenandoahGCMode, &quot;normal&quot;) == 0) {
 399       _gc_mode = new ShenandoahNormalMode();
 400     } else if (strcmp(ShenandoahGCMode, &quot;passive&quot;) == 0) {
 401       _gc_mode = new ShenandoahPassiveMode();
 402     } else {
 403       vm_exit_during_initialization(&quot;Unknown -XX:ShenandoahGCMode option&quot;);
 404     }
 405   } else {
 406     ShouldNotReachHere();
 407   }
 408   _gc_mode-&gt;initialize_flags();
 409   _heuristics = _gc_mode-&gt;initialize_heuristics();
 410 
 411   if (_heuristics-&gt;is_diagnostic() &amp;&amp; !UnlockDiagnosticVMOptions) {
 412     vm_exit_during_initialization(
 413             err_msg(&quot;Heuristics \&quot;%s\&quot; is diagnostic, and must be enabled via -XX:+UnlockDiagnosticVMOptions.&quot;,
 414                     _heuristics-&gt;name()));
 415   }
 416   if (_heuristics-&gt;is_experimental() &amp;&amp; !UnlockExperimentalVMOptions) {
 417     vm_exit_during_initialization(
 418             err_msg(&quot;Heuristics \&quot;%s\&quot; is experimental, and must be enabled via -XX:+UnlockExperimentalVMOptions.&quot;,
 419                     _heuristics-&gt;name()));
 420   }
 421   log_info(gc, init)(&quot;Shenandoah heuristics: %s&quot;,
 422                      _heuristics-&gt;name());
 423 }
 424 
 425 #ifdef _MSC_VER
 426 #pragma warning( push )
 427 #pragma warning( disable:4355 ) // &#39;this&#39; : used in base member initializer list
 428 #endif
 429 
 430 ShenandoahHeap::ShenandoahHeap(ShenandoahCollectorPolicy* policy) :
 431   CollectedHeap(),
 432   _initial_size(0),
 433   _used(0),
 434   _committed(0),
 435   _bytes_allocated_since_gc_start(0),
 436   _max_workers(MAX2(ConcGCThreads, ParallelGCThreads)),
 437   _workers(NULL),
 438   _safepoint_workers(NULL),
 439   _heap_region_special(false),
 440   _num_regions(0),
 441   _regions(NULL),
 442   _update_refs_iterator(this),
 443   _control_thread(NULL),
 444   _shenandoah_policy(policy),
 445   _heuristics(NULL),
 446   _free_set(NULL),
 447   _scm(new ShenandoahConcurrentMark()),
 448   _traversal_gc(NULL),
 449   _full_gc(new ShenandoahMarkCompact()),
 450   _pacer(NULL),
 451   _verifier(NULL),
<a name="9" id="anc9"></a><span class="line-removed"> 452   _alloc_tracker(NULL),</span>
 453   _phase_timings(NULL),
 454   _monitoring_support(NULL),
 455   _memory_pool(NULL),
 456   _stw_memory_manager(&quot;Shenandoah Pauses&quot;, &quot;end of GC pause&quot;),
 457   _cycle_memory_manager(&quot;Shenandoah Cycles&quot;, &quot;end of GC cycle&quot;),
 458   _gc_timer(new (ResourceObj::C_HEAP, mtGC) ConcurrentGCTimer()),
 459   _soft_ref_policy(),
 460   _log_min_obj_alignment_in_bytes(LogMinObjAlignmentInBytes),
 461   _ref_processor(NULL),
 462   _marking_context(NULL),
 463   _bitmap_size(0),
 464   _bitmap_regions_per_slice(0),
 465   _bitmap_bytes_per_slice(0),
 466   _bitmap_region_special(false),
 467   _aux_bitmap_region_special(false),
 468   _liveness_cache(NULL),
 469   _collection_set(NULL)
 470 {
<a name="10" id="anc10"></a>

 471   log_info(gc, init)(&quot;GC threads: &quot; UINT32_FORMAT &quot; parallel, &quot; UINT32_FORMAT &quot; concurrent&quot;, ParallelGCThreads, ConcGCThreads);
 472   log_info(gc, init)(&quot;Reference processing: %s&quot;, ParallelRefProcEnabled ? &quot;parallel&quot; : &quot;serial&quot;);
 473 
 474   BarrierSet::set_barrier_set(new ShenandoahBarrierSet(this));
 475 
 476   _max_workers = MAX2(_max_workers, 1U);
 477   _workers = new ShenandoahWorkGang(&quot;Shenandoah GC Threads&quot;, _max_workers,
 478                             /* are_GC_task_threads */ true,
 479                             /* are_ConcurrentGC_threads */ true);
 480   if (_workers == NULL) {
 481     vm_exit_during_initialization(&quot;Failed necessary allocation.&quot;);
 482   } else {
 483     _workers-&gt;initialize_workers();
 484   }
 485 
<a name="11" id="anc11"></a><span class="line-modified"> 486   if (ShenandoahParallelSafepointThreads &gt; 1) {</span>
 487     _safepoint_workers = new ShenandoahWorkGang(&quot;Safepoint Cleanup Thread&quot;,
<a name="12" id="anc12"></a><span class="line-modified"> 488                                                 ShenandoahParallelSafepointThreads,</span>
 489                       /* are_GC_task_threads */ false,
 490                  /* are_ConcurrentGC_threads */ false);
 491     _safepoint_workers-&gt;initialize_workers();
 492   }
 493 }
 494 
 495 #ifdef _MSC_VER
 496 #pragma warning( pop )
 497 #endif
 498 
 499 class ShenandoahResetBitmapTask : public AbstractGangTask {
 500 private:
 501   ShenandoahRegionIterator _regions;
 502 
 503 public:
 504   ShenandoahResetBitmapTask() :
 505     AbstractGangTask(&quot;Parallel Reset Bitmap Task&quot;) {}
 506 
 507   void work(uint worker_id) {
 508     ShenandoahHeapRegion* region = _regions.next();
 509     ShenandoahHeap* heap = ShenandoahHeap::heap();
 510     ShenandoahMarkingContext* const ctx = heap-&gt;marking_context();
 511     while (region != NULL) {
 512       if (heap-&gt;is_bitmap_slice_committed(region)) {
 513         ctx-&gt;clear_bitmap(region);
 514       }
 515       region = _regions.next();
 516     }
 517   }
 518 };
 519 
 520 void ShenandoahHeap::reset_mark_bitmap() {
 521   assert_gc_workers(_workers-&gt;active_workers());
 522   mark_incomplete_marking_context();
 523 
 524   ShenandoahResetBitmapTask task;
 525   _workers-&gt;run_task(&amp;task);
 526 }
 527 
 528 void ShenandoahHeap::print_on(outputStream* st) const {
 529   st-&gt;print_cr(&quot;Shenandoah Heap&quot;);
 530   st-&gt;print_cr(&quot; &quot; SIZE_FORMAT &quot;%s total, &quot; SIZE_FORMAT &quot;%s committed, &quot; SIZE_FORMAT &quot;%s used&quot;,
 531                byte_size_in_proper_unit(max_capacity()), proper_unit_for_byte_size(max_capacity()),
 532                byte_size_in_proper_unit(committed()),    proper_unit_for_byte_size(committed()),
 533                byte_size_in_proper_unit(used()),         proper_unit_for_byte_size(used()));
 534   st-&gt;print_cr(&quot; &quot; SIZE_FORMAT &quot; x &quot; SIZE_FORMAT&quot;%s regions&quot;,
 535                num_regions(),
 536                byte_size_in_proper_unit(ShenandoahHeapRegion::region_size_bytes()),
 537                proper_unit_for_byte_size(ShenandoahHeapRegion::region_size_bytes()));
 538 
 539   st-&gt;print(&quot;Status: &quot;);
 540   if (has_forwarded_objects())               st-&gt;print(&quot;has forwarded objects, &quot;);
 541   if (is_concurrent_mark_in_progress())      st-&gt;print(&quot;marking, &quot;);
 542   if (is_evacuation_in_progress())           st-&gt;print(&quot;evacuating, &quot;);
 543   if (is_update_refs_in_progress())          st-&gt;print(&quot;updating refs, &quot;);
 544   if (is_concurrent_traversal_in_progress()) st-&gt;print(&quot;traversal, &quot;);
 545   if (is_degenerated_gc_in_progress())       st-&gt;print(&quot;degenerated gc, &quot;);
 546   if (is_full_gc_in_progress())              st-&gt;print(&quot;full gc, &quot;);
 547   if (is_full_gc_move_in_progress())         st-&gt;print(&quot;full gc move, &quot;);
 548   if (is_concurrent_root_in_progress())      st-&gt;print(&quot;concurrent roots, &quot;);
 549 
 550   if (cancelled_gc()) {
 551     st-&gt;print(&quot;cancelled&quot;);
 552   } else {
 553     st-&gt;print(&quot;not cancelled&quot;);
 554   }
 555   st-&gt;cr();
 556 
 557   st-&gt;print_cr(&quot;Reserved region:&quot;);
 558   st-&gt;print_cr(&quot; - [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;,
 559                p2i(reserved_region().start()),
 560                p2i(reserved_region().end()));
 561 
 562   ShenandoahCollectionSet* cset = collection_set();
 563   st-&gt;print_cr(&quot;Collection set:&quot;);
 564   if (cset != NULL) {
 565     st-&gt;print_cr(&quot; - map (vanilla): &quot; PTR_FORMAT, p2i(cset-&gt;map_address()));
 566     st-&gt;print_cr(&quot; - map (biased):  &quot; PTR_FORMAT, p2i(cset-&gt;biased_map_address()));
 567   } else {
 568     st-&gt;print_cr(&quot; (NULL)&quot;);
 569   }
 570 
 571   st-&gt;cr();
 572   MetaspaceUtils::print_on(st);
 573 
 574   if (Verbose) {
 575     print_heap_regions_on(st);
 576   }
 577 }
 578 
 579 class ShenandoahInitWorkerGCLABClosure : public ThreadClosure {
 580 public:
 581   void do_thread(Thread* thread) {
 582     assert(thread != NULL, &quot;Sanity&quot;);
 583     assert(thread-&gt;is_Worker_thread(), &quot;Only worker thread expected&quot;);
 584     ShenandoahThreadLocalData::initialize_gclab(thread);
 585   }
 586 };
 587 
 588 void ShenandoahHeap::post_initialize() {
 589   CollectedHeap::post_initialize();
 590   MutexLocker ml(Threads_lock);
 591 
 592   ShenandoahInitWorkerGCLABClosure init_gclabs;
 593   _workers-&gt;threads_do(&amp;init_gclabs);
 594 
 595   // gclab can not be initialized early during VM startup, as it can not determinate its max_size.
 596   // Now, we will let WorkGang to initialize gclab when new worker is created.
 597   _workers-&gt;set_initialize_gclab();
 598 
 599   _scm-&gt;initialize(_max_workers);
 600   _full_gc-&gt;initialize(_gc_timer);
 601 
 602   ref_processing_init();
 603 
 604   _heuristics-&gt;initialize();
 605 
 606   JFR_ONLY(ShenandoahJFRSupport::register_jfr_type_serializers());
 607 }
 608 
 609 size_t ShenandoahHeap::used() const {
 610   return Atomic::load_acquire(&amp;_used);
 611 }
 612 
 613 size_t ShenandoahHeap::committed() const {
 614   OrderAccess::acquire();
 615   return _committed;
 616 }
 617 
 618 void ShenandoahHeap::increase_committed(size_t bytes) {
<a name="13" id="anc13"></a><span class="line-modified"> 619   assert_heaplock_or_safepoint();</span>
 620   _committed += bytes;
 621 }
 622 
 623 void ShenandoahHeap::decrease_committed(size_t bytes) {
<a name="14" id="anc14"></a><span class="line-modified"> 624   assert_heaplock_or_safepoint();</span>
 625   _committed -= bytes;
 626 }
 627 
 628 void ShenandoahHeap::increase_used(size_t bytes) {
 629   Atomic::add(&amp;_used, bytes);
 630 }
 631 
 632 void ShenandoahHeap::set_used(size_t bytes) {
 633   Atomic::release_store_fence(&amp;_used, bytes);
 634 }
 635 
 636 void ShenandoahHeap::decrease_used(size_t bytes) {
 637   assert(used() &gt;= bytes, &quot;never decrease heap size by more than we&#39;ve left&quot;);
 638   Atomic::sub(&amp;_used, bytes);
 639 }
 640 
 641 void ShenandoahHeap::increase_allocated(size_t bytes) {
 642   Atomic::add(&amp;_bytes_allocated_since_gc_start, bytes);
 643 }
 644 
 645 void ShenandoahHeap::notify_mutator_alloc_words(size_t words, bool waste) {
 646   size_t bytes = words * HeapWordSize;
 647   if (!waste) {
 648     increase_used(bytes);
 649   }
 650   increase_allocated(bytes);
 651   if (ShenandoahPacing) {
 652     control_thread()-&gt;pacing_notify_alloc(words);
 653     if (waste) {
 654       pacer()-&gt;claim_for_alloc(words, true);
 655     }
 656   }
 657 }
 658 
 659 size_t ShenandoahHeap::capacity() const {
 660   return committed();
 661 }
 662 
 663 size_t ShenandoahHeap::max_capacity() const {
 664   return _num_regions * ShenandoahHeapRegion::region_size_bytes();
 665 }
 666 
 667 size_t ShenandoahHeap::min_capacity() const {
 668   return _minimum_size;
 669 }
 670 
 671 size_t ShenandoahHeap::initial_capacity() const {
 672   return _initial_size;
 673 }
 674 
 675 bool ShenandoahHeap::is_in(const void* p) const {
 676   HeapWord* heap_base = (HeapWord*) base();
 677   HeapWord* last_region_end = heap_base + ShenandoahHeapRegion::region_size_words() * num_regions();
 678   return p &gt;= heap_base &amp;&amp; p &lt; last_region_end;
 679 }
 680 
 681 void ShenandoahHeap::op_uncommit(double shrink_before) {
 682   assert (ShenandoahUncommit, &quot;should be enabled&quot;);
 683 
 684   // Application allocates from the beginning of the heap, and GC allocates at
 685   // the end of it. It is more efficient to uncommit from the end, so that applications
 686   // could enjoy the near committed regions. GC allocations are much less frequent,
 687   // and therefore can accept the committing costs.
 688 
 689   size_t count = 0;
 690   for (size_t i = num_regions(); i &gt; 0; i--) { // care about size_t underflow
 691     ShenandoahHeapRegion* r = get_region(i - 1);
 692     if (r-&gt;is_empty_committed() &amp;&amp; (r-&gt;empty_time() &lt; shrink_before)) {
 693       ShenandoahHeapLocker locker(lock());
 694       if (r-&gt;is_empty_committed()) {
 695         // Do not uncommit below minimal capacity
 696         if (committed() &lt; min_capacity() + ShenandoahHeapRegion::region_size_bytes()) {
 697           break;
 698         }
 699 
 700         r-&gt;make_uncommitted();
 701         count++;
 702       }
 703     }
 704     SpinPause(); // allow allocators to take the lock
 705   }
 706 
 707   if (count &gt; 0) {
 708     control_thread()-&gt;notify_heap_changed();
 709   }
 710 }
 711 
 712 HeapWord* ShenandoahHeap::allocate_from_gclab_slow(Thread* thread, size_t size) {
 713   // New object should fit the GCLAB size
 714   size_t min_size = MAX2(size, PLAB::min_size());
 715 
 716   // Figure out size of new GCLAB, looking back at heuristics. Expand aggressively.
 717   size_t new_size = ShenandoahThreadLocalData::gclab_size(thread) * 2;
 718   new_size = MIN2(new_size, PLAB::max_size());
 719   new_size = MAX2(new_size, PLAB::min_size());
 720 
 721   // Record new heuristic value even if we take any shortcut. This captures
 722   // the case when moderately-sized objects always take a shortcut. At some point,
 723   // heuristics should catch up with them.
 724   ShenandoahThreadLocalData::set_gclab_size(thread, new_size);
 725 
 726   if (new_size &lt; size) {
 727     // New size still does not fit the object. Fall back to shared allocation.
 728     // This avoids retiring perfectly good GCLABs, when we encounter a large object.
 729     return NULL;
 730   }
 731 
 732   // Retire current GCLAB, and allocate a new one.
 733   PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);
 734   gclab-&gt;retire();
 735 
 736   size_t actual_size = 0;
 737   HeapWord* gclab_buf = allocate_new_gclab(min_size, new_size, &amp;actual_size);
 738   if (gclab_buf == NULL) {
 739     return NULL;
 740   }
 741 
 742   assert (size &lt;= actual_size, &quot;allocation should fit&quot;);
 743 
 744   if (ZeroTLAB) {
 745     // ..and clear it.
 746     Copy::zero_to_words(gclab_buf, actual_size);
 747   } else {
 748     // ...and zap just allocated object.
 749 #ifdef ASSERT
 750     // Skip mangling the space corresponding to the object header to
 751     // ensure that the returned space is not considered parsable by
 752     // any concurrent GC thread.
 753     size_t hdr_size = oopDesc::header_size();
 754     Copy::fill_to_words(gclab_buf + hdr_size, actual_size - hdr_size, badHeapWordVal);
 755 #endif // ASSERT
 756   }
 757   gclab-&gt;set_buf(gclab_buf, actual_size);
 758   return gclab-&gt;allocate(size);
 759 }
 760 
 761 HeapWord* ShenandoahHeap::allocate_new_tlab(size_t min_size,
 762                                             size_t requested_size,
 763                                             size_t* actual_size) {
 764   ShenandoahAllocRequest req = ShenandoahAllocRequest::for_tlab(min_size, requested_size);
 765   HeapWord* res = allocate_memory(req);
 766   if (res != NULL) {
 767     *actual_size = req.actual_size();
 768   } else {
 769     *actual_size = 0;
 770   }
 771   return res;
 772 }
 773 
 774 HeapWord* ShenandoahHeap::allocate_new_gclab(size_t min_size,
 775                                              size_t word_size,
 776                                              size_t* actual_size) {
 777   ShenandoahAllocRequest req = ShenandoahAllocRequest::for_gclab(min_size, word_size);
 778   HeapWord* res = allocate_memory(req);
 779   if (res != NULL) {
 780     *actual_size = req.actual_size();
 781   } else {
 782     *actual_size = 0;
 783   }
 784   return res;
 785 }
 786 
<a name="15" id="anc15"></a><span class="line-removed"> 787 ShenandoahHeap* ShenandoahHeap::heap() {</span>
<span class="line-removed"> 788   CollectedHeap* heap = Universe::heap();</span>
<span class="line-removed"> 789   assert(heap != NULL, &quot;Unitialized access to ShenandoahHeap::heap()&quot;);</span>
<span class="line-removed"> 790   assert(heap-&gt;kind() == CollectedHeap::Shenandoah, &quot;not a shenandoah heap&quot;);</span>
<span class="line-removed"> 791   return (ShenandoahHeap*) heap;</span>
<span class="line-removed"> 792 }</span>
<span class="line-removed"> 793 </span>
<span class="line-removed"> 794 ShenandoahHeap* ShenandoahHeap::heap_no_check() {</span>
<span class="line-removed"> 795   CollectedHeap* heap = Universe::heap();</span>
<span class="line-removed"> 796   return (ShenandoahHeap*) heap;</span>
<span class="line-removed"> 797 }</span>
<span class="line-removed"> 798 </span>
 799 HeapWord* ShenandoahHeap::allocate_memory(ShenandoahAllocRequest&amp; req) {
<a name="16" id="anc16"></a><span class="line-removed"> 800   ShenandoahAllocTrace trace_alloc(req.size(), req.type());</span>
<span class="line-removed"> 801 </span>
 802   intptr_t pacer_epoch = 0;
 803   bool in_new_region = false;
 804   HeapWord* result = NULL;
 805 
 806   if (req.is_mutator_alloc()) {
 807     if (ShenandoahPacing) {
 808       pacer()-&gt;pace_for_alloc(req.size());
 809       pacer_epoch = pacer()-&gt;epoch();
 810     }
 811 
 812     if (!ShenandoahAllocFailureALot || !should_inject_alloc_failure()) {
 813       result = allocate_memory_under_lock(req, in_new_region);
 814     }
 815 
 816     // Allocation failed, block until control thread reacted, then retry allocation.
 817     //
 818     // It might happen that one of the threads requesting allocation would unblock
 819     // way later after GC happened, only to fail the second allocation, because
 820     // other threads have already depleted the free storage. In this case, a better
 821     // strategy is to try again, as long as GC makes progress.
 822     //
 823     // Then, we need to make sure the allocation was retried after at least one
 824     // Full GC, which means we want to try more than ShenandoahFullGCThreshold times.
 825 
 826     size_t tries = 0;
 827 
 828     while (result == NULL &amp;&amp; _progress_last_gc.is_set()) {
 829       tries++;
 830       control_thread()-&gt;handle_alloc_failure(req.size());
 831       result = allocate_memory_under_lock(req, in_new_region);
 832     }
 833 
 834     while (result == NULL &amp;&amp; tries &lt;= ShenandoahFullGCThreshold) {
 835       tries++;
 836       control_thread()-&gt;handle_alloc_failure(req.size());
 837       result = allocate_memory_under_lock(req, in_new_region);
 838     }
 839 
 840   } else {
 841     assert(req.is_gc_alloc(), &quot;Can only accept GC allocs here&quot;);
 842     result = allocate_memory_under_lock(req, in_new_region);
 843     // Do not call handle_alloc_failure() here, because we cannot block.
 844     // The allocation failure would be handled by the LRB slowpath with handle_alloc_failure_evac().
 845   }
 846 
 847   if (in_new_region) {
 848     control_thread()-&gt;notify_heap_changed();
 849   }
 850 
 851   if (result != NULL) {
 852     size_t requested = req.size();
 853     size_t actual = req.actual_size();
 854 
 855     assert (req.is_lab_alloc() || (requested == actual),
 856             &quot;Only LAB allocations are elastic: %s, requested = &quot; SIZE_FORMAT &quot;, actual = &quot; SIZE_FORMAT,
 857             ShenandoahAllocRequest::alloc_type_to_string(req.type()), requested, actual);
 858 
 859     if (req.is_mutator_alloc()) {
 860       notify_mutator_alloc_words(actual, false);
 861 
 862       // If we requested more than we were granted, give the rest back to pacer.
 863       // This only matters if we are in the same pacing epoch: do not try to unpace
 864       // over the budget for the other phase.
 865       if (ShenandoahPacing &amp;&amp; (pacer_epoch &gt; 0) &amp;&amp; (requested &gt; actual)) {
 866         pacer()-&gt;unpace_for_alloc(pacer_epoch, requested - actual);
 867       }
 868     } else {
 869       increase_used(actual*HeapWordSize);
 870     }
 871   }
 872 
 873   return result;
 874 }
 875 
 876 HeapWord* ShenandoahHeap::allocate_memory_under_lock(ShenandoahAllocRequest&amp; req, bool&amp; in_new_region) {
 877   ShenandoahHeapLocker locker(lock());
 878   return _free_set-&gt;allocate(req, in_new_region);
 879 }
 880 
 881 HeapWord* ShenandoahHeap::mem_allocate(size_t size,
 882                                         bool*  gc_overhead_limit_was_exceeded) {
 883   ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared(size);
 884   return allocate_memory(req);
 885 }
 886 
 887 MetaWord* ShenandoahHeap::satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
 888                                                              size_t size,
 889                                                              Metaspace::MetadataType mdtype) {
 890   MetaWord* result;
 891 
 892   // Inform metaspace OOM to GC heuristics if class unloading is possible.
 893   if (heuristics()-&gt;can_unload_classes()) {
 894     ShenandoahHeuristics* h = heuristics();
 895     h-&gt;record_metaspace_oom();
 896   }
 897 
 898   // Expand and retry allocation
 899   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
 900   if (result != NULL) {
 901     return result;
 902   }
 903 
 904   // Start full GC
 905   collect(GCCause::_metadata_GC_clear_soft_refs);
 906 
 907   // Retry allocation
 908   result = loader_data-&gt;metaspace_non_null()-&gt;allocate(size, mdtype);
 909   if (result != NULL) {
 910     return result;
 911   }
 912 
 913   // Expand and retry allocation
 914   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
 915   if (result != NULL) {
 916     return result;
 917   }
 918 
 919   // Out of memory
 920   return NULL;
 921 }
 922 
 923 class ShenandoahConcurrentEvacuateRegionObjectClosure : public ObjectClosure {
 924 private:
 925   ShenandoahHeap* const _heap;
 926   Thread* const _thread;
 927 public:
 928   ShenandoahConcurrentEvacuateRegionObjectClosure(ShenandoahHeap* heap) :
 929     _heap(heap), _thread(Thread::current()) {}
 930 
 931   void do_object(oop p) {
 932     shenandoah_assert_marked(NULL, p);
 933     if (!p-&gt;is_forwarded()) {
 934       _heap-&gt;evacuate_object(p, _thread);
 935     }
 936   }
 937 };
 938 
 939 class ShenandoahEvacuationTask : public AbstractGangTask {
 940 private:
 941   ShenandoahHeap* const _sh;
 942   ShenandoahCollectionSet* const _cs;
 943   bool _concurrent;
 944 public:
 945   ShenandoahEvacuationTask(ShenandoahHeap* sh,
 946                            ShenandoahCollectionSet* cs,
 947                            bool concurrent) :
 948     AbstractGangTask(&quot;Parallel Evacuation Task&quot;),
 949     _sh(sh),
 950     _cs(cs),
 951     _concurrent(concurrent)
 952   {}
 953 
 954   void work(uint worker_id) {
 955     if (_concurrent) {
 956       ShenandoahConcurrentWorkerSession worker_session(worker_id);
 957       ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
 958       ShenandoahEvacOOMScope oom_evac_scope;
 959       do_work();
 960     } else {
 961       ShenandoahParallelWorkerSession worker_session(worker_id);
 962       ShenandoahEvacOOMScope oom_evac_scope;
 963       do_work();
 964     }
 965   }
 966 
 967 private:
 968   void do_work() {
 969     ShenandoahConcurrentEvacuateRegionObjectClosure cl(_sh);
 970     ShenandoahHeapRegion* r;
 971     while ((r =_cs-&gt;claim_next()) != NULL) {
 972       assert(r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have been reclaimed early&quot;, r-&gt;region_number());
 973       _sh-&gt;marked_object_iterate(r, &amp;cl);
 974 
 975       if (ShenandoahPacing) {
 976         _sh-&gt;pacer()-&gt;report_evac(r-&gt;used() &gt;&gt; LogHeapWordSize);
 977       }
 978 
 979       if (_sh-&gt;check_cancelled_gc_and_yield(_concurrent)) {
 980         break;
 981       }
 982     }
 983   }
 984 };
 985 
 986 void ShenandoahHeap::trash_cset_regions() {
 987   ShenandoahHeapLocker locker(lock());
 988 
 989   ShenandoahCollectionSet* set = collection_set();
 990   ShenandoahHeapRegion* r;
 991   set-&gt;clear_current_index();
 992   while ((r = set-&gt;next()) != NULL) {
 993     r-&gt;make_trash();
 994   }
 995   collection_set()-&gt;clear();
 996 }
 997 
 998 void ShenandoahHeap::print_heap_regions_on(outputStream* st) const {
 999   st-&gt;print_cr(&quot;Heap Regions:&quot;);
1000   st-&gt;print_cr(&quot;EU=empty-uncommitted, EC=empty-committed, R=regular, H=humongous start, HC=humongous continuation, CS=collection set, T=trash, P=pinned&quot;);
1001   st-&gt;print_cr(&quot;BTE=bottom/top/end, U=used, T=TLAB allocs, G=GCLAB allocs, S=shared allocs, L=live data&quot;);
<a name="17" id="anc17"></a><span class="line-modified">1002   st-&gt;print_cr(&quot;R=root, CP=critical pins, TAMS=top-at-mark-start (previous, next)&quot;);</span>
<span class="line-modified">1003   st-&gt;print_cr(&quot;SN=alloc sequence numbers (first mutator, last mutator, first gc, last gc)&quot;);</span>
1004 
1005   for (size_t i = 0; i &lt; num_regions(); i++) {
1006     get_region(i)-&gt;print_on(st);
1007   }
1008 }
1009 
1010 void ShenandoahHeap::trash_humongous_region_at(ShenandoahHeapRegion* start) {
1011   assert(start-&gt;is_humongous_start(), &quot;reclaim regions starting with the first one&quot;);
1012 
1013   oop humongous_obj = oop(start-&gt;bottom());
1014   size_t size = humongous_obj-&gt;size();
1015   size_t required_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);
1016   size_t index = start-&gt;region_number() + required_regions - 1;
1017 
1018   assert(!start-&gt;has_live(), &quot;liveness must be zero&quot;);
1019 
1020   for(size_t i = 0; i &lt; required_regions; i++) {
1021     // Reclaim from tail. Otherwise, assertion fails when printing region to trace log,
1022     // as it expects that every region belongs to a humongous region starting with a humongous start region.
1023     ShenandoahHeapRegion* region = get_region(index --);
1024 
1025     assert(region-&gt;is_humongous(), &quot;expect correct humongous start or continuation&quot;);
1026     assert(!region-&gt;is_cset(), &quot;Humongous region should not be in collection set&quot;);
1027 
1028     region-&gt;make_trash_immediate();
1029   }
1030 }
1031 
1032 class ShenandoahRetireGCLABClosure : public ThreadClosure {
1033 public:
1034   void do_thread(Thread* thread) {
1035     PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);
1036     assert(gclab != NULL, &quot;GCLAB should be initialized for %s&quot;, thread-&gt;name());
1037     gclab-&gt;retire();
1038   }
1039 };
1040 
1041 void ShenandoahHeap::make_parsable(bool retire_tlabs) {
1042   if (UseTLAB) {
1043     CollectedHeap::ensure_parsability(retire_tlabs);
1044   }
1045   ShenandoahRetireGCLABClosure cl;
1046   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
1047     cl.do_thread(t);
1048   }
1049   workers()-&gt;threads_do(&amp;cl);
1050 }
1051 
1052 void ShenandoahHeap::resize_tlabs() {
1053   CollectedHeap::resize_all_tlabs();
1054 }
1055 
1056 class ShenandoahEvacuateUpdateRootsTask : public AbstractGangTask {
1057 private:
1058   ShenandoahRootEvacuator* _rp;
1059 
1060 public:
1061   ShenandoahEvacuateUpdateRootsTask(ShenandoahRootEvacuator* rp) :
1062     AbstractGangTask(&quot;Shenandoah evacuate and update roots&quot;),
1063     _rp(rp) {}
1064 
1065   void work(uint worker_id) {
1066     ShenandoahParallelWorkerSession worker_session(worker_id);
1067     ShenandoahEvacOOMScope oom_evac_scope;
1068     ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;
1069     MarkingCodeBlobClosure blobsCl(&amp;cl, CodeBlobToOopClosure::FixRelocations);
1070     _rp-&gt;roots_do(worker_id, &amp;cl);
1071   }
1072 };
1073 
1074 void ShenandoahHeap::evacuate_and_update_roots() {
1075 #if COMPILER2_OR_JVMCI
1076   DerivedPointerTable::clear();
1077 #endif
1078   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only iterate roots while world is stopped&quot;);
1079   {
1080     // Include concurrent roots if current cycle can not process those roots concurrently
1081     ShenandoahRootEvacuator rp(workers()-&gt;active_workers(),
1082                                ShenandoahPhaseTimings::init_evac,
1083                                !ShenandoahConcurrentRoots::should_do_concurrent_roots(),
1084                                !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
1085     ShenandoahEvacuateUpdateRootsTask roots_task(&amp;rp);
1086     workers()-&gt;run_task(&amp;roots_task);
1087   }
1088 
1089 #if COMPILER2_OR_JVMCI
1090   DerivedPointerTable::update_pointers();
1091 #endif
1092 }
1093 
1094 // Returns size in bytes
1095 size_t ShenandoahHeap::unsafe_max_tlab_alloc(Thread *thread) const {
1096   if (ShenandoahElasticTLAB) {
1097     // With Elastic TLABs, return the max allowed size, and let the allocation path
1098     // figure out the safe size for current allocation.
1099     return ShenandoahHeapRegion::max_tlab_size_bytes();
1100   } else {
1101     return MIN2(_free_set-&gt;unsafe_peek_free(), ShenandoahHeapRegion::max_tlab_size_bytes());
1102   }
1103 }
1104 
1105 size_t ShenandoahHeap::max_tlab_size() const {
1106   // Returns size in words
1107   return ShenandoahHeapRegion::max_tlab_size_words();
1108 }
1109 
1110 class ShenandoahRetireAndResetGCLABClosure : public ThreadClosure {
1111 public:
1112   void do_thread(Thread* thread) {
1113     PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);
1114     gclab-&gt;retire();
1115     if (ShenandoahThreadLocalData::gclab_size(thread) &gt; 0) {
1116       ShenandoahThreadLocalData::set_gclab_size(thread, 0);
1117     }
1118   }
1119 };
1120 
1121 void ShenandoahHeap::retire_and_reset_gclabs() {
1122   ShenandoahRetireAndResetGCLABClosure cl;
1123   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
1124     cl.do_thread(t);
1125   }
1126   workers()-&gt;threads_do(&amp;cl);
1127 }
1128 
1129 void ShenandoahHeap::collect(GCCause::Cause cause) {
1130   control_thread()-&gt;request_gc(cause);
1131 }
1132 
1133 void ShenandoahHeap::do_full_collection(bool clear_all_soft_refs) {
1134   //assert(false, &quot;Shouldn&#39;t need to do full collections&quot;);
1135 }
1136 
1137 HeapWord* ShenandoahHeap::block_start(const void* addr) const {
<a name="18" id="anc18"></a><span class="line-modified">1138   Space* sp = heap_region_containing(addr);</span>
<span class="line-modified">1139   if (sp != NULL) {</span>
<span class="line-modified">1140     return sp-&gt;block_start(addr);</span>
1141   }
1142   return NULL;
1143 }
1144 
1145 bool ShenandoahHeap::block_is_obj(const HeapWord* addr) const {
<a name="19" id="anc19"></a><span class="line-modified">1146   Space* sp = heap_region_containing(addr);</span>
<span class="line-modified">1147   return sp-&gt;block_is_obj(addr);</span>
1148 }
1149 
1150 bool ShenandoahHeap::print_location(outputStream* st, void* addr) const {
1151   return BlockLocationPrinter&lt;ShenandoahHeap&gt;::print_location(st, addr);
1152 }
1153 
1154 jlong ShenandoahHeap::millis_since_last_gc() {
1155   double v = heuristics()-&gt;time_since_last_gc() * 1000;
1156   assert(0 &lt;= v &amp;&amp; v &lt;= max_jlong, &quot;value should fit: %f&quot;, v);
1157   return (jlong)v;
1158 }
1159 
1160 void ShenandoahHeap::prepare_for_verify() {
1161   if (SafepointSynchronize::is_at_safepoint() || ! UseTLAB) {
1162     make_parsable(false);
1163   }
1164 }
1165 
1166 void ShenandoahHeap::print_gc_threads_on(outputStream* st) const {
1167   workers()-&gt;print_worker_threads_on(st);
1168   if (ShenandoahStringDedup::is_enabled()) {
1169     ShenandoahStringDedup::print_worker_threads_on(st);
1170   }
1171 }
1172 
1173 void ShenandoahHeap::gc_threads_do(ThreadClosure* tcl) const {
1174   workers()-&gt;threads_do(tcl);
1175   if (_safepoint_workers != NULL) {
1176     _safepoint_workers-&gt;threads_do(tcl);
1177   }
1178   if (ShenandoahStringDedup::is_enabled()) {
1179     ShenandoahStringDedup::threads_do(tcl);
1180   }
1181 }
1182 
1183 void ShenandoahHeap::print_tracing_info() const {
1184   LogTarget(Info, gc, stats) lt;
1185   if (lt.is_enabled()) {
1186     ResourceMark rm;
1187     LogStream ls(lt);
1188 
1189     phase_timings()-&gt;print_on(&amp;ls);
1190 
1191     ls.cr();
1192     ls.cr();
1193 
1194     shenandoah_policy()-&gt;print_gc_stats(&amp;ls);
1195 
1196     ls.cr();
1197     ls.cr();
1198 
1199     if (ShenandoahPacing) {
1200       pacer()-&gt;print_on(&amp;ls);
1201     }
1202 
1203     ls.cr();
1204     ls.cr();
<a name="20" id="anc20"></a><span class="line-removed">1205 </span>
<span class="line-removed">1206     if (ShenandoahAllocationTrace) {</span>
<span class="line-removed">1207       assert(alloc_tracker() != NULL, &quot;Must be&quot;);</span>
<span class="line-removed">1208       alloc_tracker()-&gt;print_on(&amp;ls);</span>
<span class="line-removed">1209     } else {</span>
<span class="line-removed">1210       ls.print_cr(&quot;  Allocation tracing is disabled, use -XX:+ShenandoahAllocationTrace to enable.&quot;);</span>
<span class="line-removed">1211     }</span>
1212   }
1213 }
1214 
1215 void ShenandoahHeap::verify(VerifyOption vo) {
1216   if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {
1217     if (ShenandoahVerify) {
1218       verifier()-&gt;verify_generic(vo);
1219     } else {
1220       // TODO: Consider allocating verification bitmaps on demand,
1221       // and turn this on unconditionally.
1222     }
1223   }
1224 }
1225 size_t ShenandoahHeap::tlab_capacity(Thread *thr) const {
1226   return _free_set-&gt;capacity();
1227 }
1228 
1229 class ObjectIterateScanRootClosure : public BasicOopIterateClosure {
1230 private:
1231   MarkBitMap* _bitmap;
1232   Stack&lt;oop,mtGC&gt;* _oop_stack;
<a name="21" id="anc21"></a>

1233 
1234   template &lt;class T&gt;
1235   void do_oop_work(T* p) {
1236     T o = RawAccess&lt;&gt;::oop_load(p);
1237     if (!CompressedOops::is_null(o)) {
1238       oop obj = CompressedOops::decode_not_null(o);
<a name="22" id="anc22"></a><span class="line-modified">1239       oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);</span>
<span class="line-modified">1240       if (fwd == NULL) {</span>
<span class="line-modified">1241         // There is an odd interaction with VM_HeapWalkOperation, see jvmtiTagMap.cpp.</span>
<span class="line-removed">1242         //</span>
<span class="line-removed">1243         // That operation walks the reachable objects on its own, storing the marking</span>
<span class="line-removed">1244         // wavefront in the object marks. When it is done, it calls the CollectedHeap</span>
<span class="line-removed">1245         // to iterate over all objects to clean up the mess. When it reaches here,</span>
<span class="line-removed">1246         // the Shenandoah fwdptr resolution code encounters the marked objects with</span>
<span class="line-removed">1247         // NULL forwardee. Trying to act on that would crash the VM. Or fail the</span>
<span class="line-removed">1248         // asserts, should we go for resolve_forwarded_pointer(obj).</span>
<span class="line-removed">1249         //</span>
<span class="line-removed">1250         // Therefore, we have to dodge it by doing the raw access to forwardee, and</span>
<span class="line-removed">1251         // assuming the object had no forwardee, if that thing is NULL.</span>
<span class="line-removed">1252       } else {</span>
<span class="line-removed">1253         obj = fwd;</span>
1254       }
<a name="23" id="anc23"></a>

1255       assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
1256       if (!_bitmap-&gt;is_marked(obj)) {
1257         _bitmap-&gt;mark(obj);
1258         _oop_stack-&gt;push(obj);
1259       }
1260     }
1261   }
1262 public:
1263   ObjectIterateScanRootClosure(MarkBitMap* bitmap, Stack&lt;oop,mtGC&gt;* oop_stack) :
<a name="24" id="anc24"></a><span class="line-modified">1264     _bitmap(bitmap), _oop_stack(oop_stack) {}</span>

1265   void do_oop(oop* p)       { do_oop_work(p); }
1266   void do_oop(narrowOop* p) { do_oop_work(p); }
1267 };
1268 
1269 /*
1270  * This is public API, used in preparation of object_iterate().
1271  * Since we don&#39;t do linear scan of heap in object_iterate() (see comment below), we don&#39;t
1272  * need to make the heap parsable. For Shenandoah-internal linear heap scans that we can
1273  * control, we call SH::make_tlabs_parsable().
1274  */
1275 void ShenandoahHeap::ensure_parsability(bool retire_tlabs) {
1276   // No-op.
1277 }
1278 
1279 /*
1280  * Iterates objects in the heap. This is public API, used for, e.g., heap dumping.
1281  *
1282  * We cannot safely iterate objects by doing a linear scan at random points in time. Linear
1283  * scanning needs to deal with dead objects, which may have dead Klass* pointers (e.g.
1284  * calling oopDesc::size() would crash) or dangling reference fields (crashes) etc. Linear
1285  * scanning therefore depends on having a valid marking bitmap to support it. However, we only
1286  * have a valid marking bitmap after successful marking. In particular, we *don&#39;t* have a valid
1287  * marking bitmap during marking, after aborted marking or during/after cleanup (when we just
1288  * wiped the bitmap in preparation for next marking).
1289  *
1290  * For all those reasons, we implement object iteration as a single marking traversal, reporting
1291  * objects as we mark+traverse through the heap, starting from GC roots. JVMTI IterateThroughHeap
1292  * is allowed to report dead objects, but is not required to do so.
1293  */
1294 void ShenandoahHeap::object_iterate(ObjectClosure* cl) {
1295   assert(SafepointSynchronize::is_at_safepoint(), &quot;safe iteration is only available during safepoints&quot;);
1296   if (!_aux_bitmap_region_special &amp;&amp; !os::commit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size(), false)) {
1297     log_warning(gc)(&quot;Could not commit native memory for auxiliary marking bitmap for heap iteration&quot;);
1298     return;
1299   }
1300 
1301   // Reset bitmap
1302   _aux_bit_map.clear();
1303 
1304   Stack&lt;oop,mtGC&gt; oop_stack;
1305 
1306   // First, we process GC roots according to current GC cycle. This populates the work stack with initial objects.
1307   ShenandoahHeapIterationRootScanner rp;
1308   ObjectIterateScanRootClosure oops(&amp;_aux_bit_map, &amp;oop_stack);
1309 
<a name="25" id="anc25"></a><span class="line-modified">1310   // When concurrent root is in progress, weak roots may contain dead oops, they should not be used</span>
<span class="line-removed">1311   // for root scanning.</span>
<span class="line-removed">1312   if (is_concurrent_root_in_progress()) {</span>
<span class="line-removed">1313     rp.strong_roots_do(&amp;oops);</span>
<span class="line-removed">1314   } else {</span>
<span class="line-removed">1315     rp.roots_do(&amp;oops);</span>
<span class="line-removed">1316   }</span>
1317 
1318   // Work through the oop stack to traverse heap.
1319   while (! oop_stack.is_empty()) {
1320     oop obj = oop_stack.pop();
1321     assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
1322     cl-&gt;do_object(obj);
1323     obj-&gt;oop_iterate(&amp;oops);
1324   }
1325 
1326   assert(oop_stack.is_empty(), &quot;should be empty&quot;);
1327 
1328   if (!_aux_bitmap_region_special &amp;&amp; !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {
1329     log_warning(gc)(&quot;Could not uncommit native memory for auxiliary marking bitmap for heap iteration&quot;);
1330   }
1331 }
1332 
1333 // Keep alive an object that was loaded with AS_NO_KEEPALIVE.
1334 void ShenandoahHeap::keep_alive(oop obj) {
1335   if (is_concurrent_mark_in_progress()) {
1336     ShenandoahBarrierSet::barrier_set()-&gt;enqueue(obj);
1337   }
1338 }
1339 
1340 void ShenandoahHeap::heap_region_iterate(ShenandoahHeapRegionClosure* blk) const {
1341   for (size_t i = 0; i &lt; num_regions(); i++) {
1342     ShenandoahHeapRegion* current = get_region(i);
1343     blk-&gt;heap_region_do(current);
1344   }
1345 }
1346 
1347 class ShenandoahParallelHeapRegionTask : public AbstractGangTask {
1348 private:
1349   ShenandoahHeap* const _heap;
1350   ShenandoahHeapRegionClosure* const _blk;
1351 
<a name="26" id="anc26"></a><span class="line-modified">1352   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));</span>
1353   volatile size_t _index;
<a name="27" id="anc27"></a><span class="line-modified">1354   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);</span>
1355 
1356 public:
1357   ShenandoahParallelHeapRegionTask(ShenandoahHeapRegionClosure* blk) :
1358           AbstractGangTask(&quot;Parallel Region Task&quot;),
1359           _heap(ShenandoahHeap::heap()), _blk(blk), _index(0) {}
1360 
1361   void work(uint worker_id) {
1362     size_t stride = ShenandoahParallelRegionStride;
1363 
1364     size_t max = _heap-&gt;num_regions();
1365     while (_index &lt; max) {
1366       size_t cur = Atomic::fetch_and_add(&amp;_index, stride);
1367       size_t start = cur;
1368       size_t end = MIN2(cur + stride, max);
1369       if (start &gt;= max) break;
1370 
1371       for (size_t i = cur; i &lt; end; i++) {
1372         ShenandoahHeapRegion* current = _heap-&gt;get_region(i);
1373         _blk-&gt;heap_region_do(current);
1374       }
1375     }
1376   }
1377 };
1378 
1379 void ShenandoahHeap::parallel_heap_region_iterate(ShenandoahHeapRegionClosure* blk) const {
1380   assert(blk-&gt;is_thread_safe(), &quot;Only thread-safe closures here&quot;);
1381   if (num_regions() &gt; ShenandoahParallelRegionStride) {
1382     ShenandoahParallelHeapRegionTask task(blk);
1383     workers()-&gt;run_task(&amp;task);
1384   } else {
1385     heap_region_iterate(blk);
1386   }
1387 }
1388 
1389 class ShenandoahClearLivenessClosure : public ShenandoahHeapRegionClosure {
1390 private:
1391   ShenandoahMarkingContext* const _ctx;
1392 public:
1393   ShenandoahClearLivenessClosure() : _ctx(ShenandoahHeap::heap()-&gt;marking_context()) {}
1394 
1395   void heap_region_do(ShenandoahHeapRegion* r) {
1396     if (r-&gt;is_active()) {
1397       r-&gt;clear_live_data();
1398       _ctx-&gt;capture_top_at_mark_start(r);
1399     } else {
1400       assert(!r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have no live data&quot;, r-&gt;region_number());
1401       assert(_ctx-&gt;top_at_mark_start(r) == r-&gt;top(),
1402              &quot;Region &quot; SIZE_FORMAT &quot; should already have correct TAMS&quot;, r-&gt;region_number());
1403     }
1404   }
1405 
1406   bool is_thread_safe() { return true; }
1407 };
1408 
1409 void ShenandoahHeap::op_init_mark() {
1410   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
1411   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
1412 
1413   assert(marking_context()-&gt;is_bitmap_clear(), &quot;need clear marking bitmap&quot;);
1414   assert(!marking_context()-&gt;is_complete(), &quot;should not be complete&quot;);
<a name="28" id="anc28"></a>
1415 
1416   if (ShenandoahVerify) {
1417     verifier()-&gt;verify_before_concmark();
1418   }
1419 
1420   if (VerifyBeforeGC) {
1421     Universe::verify();
1422   }
1423 
1424   set_concurrent_mark_in_progress(true);
1425   // We need to reset all TLABs because we&#39;d lose marks on all objects allocated in them.
1426   {
1427     ShenandoahGCPhase phase(ShenandoahPhaseTimings::make_parsable);
1428     make_parsable(true);
1429   }
1430 
1431   {
1432     ShenandoahGCPhase phase(ShenandoahPhaseTimings::clear_liveness);
1433     ShenandoahClearLivenessClosure clc;
1434     parallel_heap_region_iterate(&amp;clc);
1435   }
1436 
1437   // Make above changes visible to worker threads
1438   OrderAccess::fence();
1439 
1440   concurrent_mark()-&gt;mark_roots(ShenandoahPhaseTimings::scan_roots);
1441 
1442   if (UseTLAB) {
1443     ShenandoahGCPhase phase(ShenandoahPhaseTimings::resize_tlabs);
1444     resize_tlabs();
1445   }
1446 
1447   if (ShenandoahPacing) {
1448     pacer()-&gt;setup_for_mark();
1449   }
<a name="29" id="anc29"></a>






1450 }
1451 
1452 void ShenandoahHeap::op_mark() {
1453   concurrent_mark()-&gt;mark_from_roots();
1454 }
1455 
1456 class ShenandoahCompleteLivenessClosure : public ShenandoahHeapRegionClosure {
1457 private:
1458   ShenandoahMarkingContext* const _ctx;
1459 public:
1460   ShenandoahCompleteLivenessClosure() : _ctx(ShenandoahHeap::heap()-&gt;complete_marking_context()) {}
1461 
1462   void heap_region_do(ShenandoahHeapRegion* r) {
1463     if (r-&gt;is_active()) {
1464       HeapWord *tams = _ctx-&gt;top_at_mark_start(r);
1465       HeapWord *top = r-&gt;top();
1466       if (top &gt; tams) {
1467         r-&gt;increase_live_data_alloc_words(pointer_delta(top, tams));
1468       }
1469     } else {
1470       assert(!r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have no live data&quot;, r-&gt;region_number());
1471       assert(_ctx-&gt;top_at_mark_start(r) == r-&gt;top(),
1472              &quot;Region &quot; SIZE_FORMAT &quot; should have correct TAMS&quot;, r-&gt;region_number());
1473     }
1474   }
1475 
1476   bool is_thread_safe() { return true; }
1477 };
1478 
1479 void ShenandoahHeap::op_final_mark() {
1480   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
<a name="30" id="anc30"></a>
1481 
1482   // It is critical that we
1483   // evacuate roots right after finishing marking, so that we don&#39;t
1484   // get unmarked objects in the roots.
1485 
1486   if (!cancelled_gc()) {
1487     concurrent_mark()-&gt;finish_mark_from_roots(/* full_gc = */ false);
1488 
1489     // Marking is completed, deactivate SATB barrier
1490     set_concurrent_mark_in_progress(false);
1491     mark_complete_marking_context();
1492 
1493     parallel_cleaning(false /* full gc*/);
1494 
<a name="31" id="anc31"></a><span class="line-removed">1495     if (has_forwarded_objects()) {</span>
<span class="line-removed">1496       // Degen may be caused by failed evacuation of roots</span>
<span class="line-removed">1497       if (is_degenerated_gc_in_progress()) {</span>
<span class="line-removed">1498         concurrent_mark()-&gt;update_roots(ShenandoahPhaseTimings::degen_gc_update_roots);</span>
<span class="line-removed">1499       } else {</span>
<span class="line-removed">1500         concurrent_mark()-&gt;update_thread_roots(ShenandoahPhaseTimings::update_roots);</span>
<span class="line-removed">1501       }</span>
<span class="line-removed">1502       set_has_forwarded_objects(false);</span>
<span class="line-removed">1503    }</span>
<span class="line-removed">1504 </span>
1505     if (ShenandoahVerify) {
1506       verifier()-&gt;verify_roots_no_forwarded();
1507     }
1508     // All allocations past TAMS are implicitly live, adjust the region data.
1509     // Bitmaps/TAMS are swapped at this point, so we need to poll complete bitmap.
1510     {
1511       ShenandoahGCPhase phase(ShenandoahPhaseTimings::complete_liveness);
1512       ShenandoahCompleteLivenessClosure cl;
1513       parallel_heap_region_iterate(&amp;cl);
1514     }
1515 
1516     // Force the threads to reacquire their TLABs outside the collection set.
1517     {
1518       ShenandoahGCPhase phase(ShenandoahPhaseTimings::retire_tlabs);
1519       make_parsable(true);
1520     }
1521 
1522     // We are about to select the collection set, make sure it knows about
1523     // current pinning status. Also, this allows trashing more regions that
1524     // now have their pinning status dropped.
1525     {
1526       ShenandoahGCPhase phase(ShenandoahPhaseTimings::sync_pinned);
1527       sync_pinned_region_status();
1528     }
1529 
1530     // Trash the collection set left over from previous cycle, if any.
1531     {
1532       ShenandoahGCPhase phase(ShenandoahPhaseTimings::trash_cset);
1533       trash_cset_regions();
1534     }
1535 
1536     {
1537       ShenandoahGCPhase phase(ShenandoahPhaseTimings::prepare_evac);
1538 
1539       ShenandoahHeapLocker locker(lock());
1540       _collection_set-&gt;clear();
1541       _free_set-&gt;clear();
1542 
1543       heuristics()-&gt;choose_collection_set(_collection_set);
1544 
1545       _free_set-&gt;rebuild();
1546     }
1547 
1548     if (!is_degenerated_gc_in_progress()) {
1549       prepare_concurrent_roots();
1550       prepare_concurrent_unloading();
1551     }
1552 
1553     // If collection set has candidates, start evacuation.
1554     // Otherwise, bypass the rest of the cycle.
1555     if (!collection_set()-&gt;is_empty()) {
1556       ShenandoahGCPhase init_evac(ShenandoahPhaseTimings::init_evac);
1557 
1558       if (ShenandoahVerify) {
1559         verifier()-&gt;verify_before_evacuation();
1560       }
1561 
<a name="32" id="anc32"></a>






1562       set_evacuation_in_progress(true);
1563       // From here on, we need to update references.
1564       set_has_forwarded_objects(true);
1565 
1566       if (!is_degenerated_gc_in_progress()) {
1567         if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1568           ShenandoahCodeRoots::arm_nmethods();
1569         }
1570         evacuate_and_update_roots();
1571       }
1572 
1573       if (ShenandoahPacing) {
1574         pacer()-&gt;setup_for_evac();
1575       }
1576 
1577       if (ShenandoahVerify) {
1578         ShenandoahRootVerifier::RootTypes types = ShenandoahRootVerifier::None;
1579         if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {
1580           types = ShenandoahRootVerifier::combine(ShenandoahRootVerifier::JNIHandleRoots, ShenandoahRootVerifier::WeakRoots);
1581           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CLDGRoots);
1582           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::StringDedupRoots);
1583         }
1584 
1585         if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1586           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CodeRoots);
1587         }
1588         verifier()-&gt;verify_roots_no_forwarded_except(types);
1589         verifier()-&gt;verify_during_evacuation();
1590       }
1591     } else {
1592       if (ShenandoahVerify) {
1593         verifier()-&gt;verify_after_concmark();
1594       }
1595 
1596       if (VerifyAfterGC) {
1597         Universe::verify();
1598       }
1599     }
1600 
1601   } else {
1602     // If this cycle was updating references, we need to keep the has_forwarded_objects
1603     // flag on, for subsequent phases to deal with it.
1604     concurrent_mark()-&gt;cancel();
1605     set_concurrent_mark_in_progress(false);
1606 
1607     if (process_references()) {
1608       // Abandon reference processing right away: pre-cleaning must have failed.
1609       ReferenceProcessor *rp = ref_processor();
1610       rp-&gt;disable_discovery();
1611       rp-&gt;abandon_partial_discovery();
1612       rp-&gt;verify_no_references_recorded();
1613     }
1614   }
1615 }
1616 
<a name="33" id="anc33"></a><span class="line-removed">1617 void ShenandoahHeap::op_final_evac() {</span>
<span class="line-removed">1618   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);</span>
<span class="line-removed">1619 </span>
<span class="line-removed">1620   set_evacuation_in_progress(false);</span>
<span class="line-removed">1621 </span>
<span class="line-removed">1622   {</span>
<span class="line-removed">1623     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_evac_retire_gclabs);</span>
<span class="line-removed">1624     retire_and_reset_gclabs();</span>
<span class="line-removed">1625   }</span>
<span class="line-removed">1626 </span>
<span class="line-removed">1627   if (ShenandoahVerify) {</span>
<span class="line-removed">1628     verifier()-&gt;verify_after_evacuation();</span>
<span class="line-removed">1629   }</span>
<span class="line-removed">1630 </span>
<span class="line-removed">1631   if (VerifyAfterGC) {</span>
<span class="line-removed">1632     Universe::verify();</span>
<span class="line-removed">1633   }</span>
<span class="line-removed">1634 }</span>
<span class="line-removed">1635 </span>
1636 void ShenandoahHeap::op_conc_evac() {
1637   ShenandoahEvacuationTask task(this, _collection_set, true);
1638   workers()-&gt;run_task(&amp;task);
1639 }
1640 
1641 void ShenandoahHeap::op_stw_evac() {
1642   ShenandoahEvacuationTask task(this, _collection_set, false);
1643   workers()-&gt;run_task(&amp;task);
1644 }
1645 
1646 void ShenandoahHeap::op_updaterefs() {
1647   update_heap_references(true);
1648 }
1649 
1650 void ShenandoahHeap::op_cleanup() {
1651   free_set()-&gt;recycle_trash();
1652 }
1653 
1654 class ShenandoahConcurrentRootsEvacUpdateTask : public AbstractGangTask {
1655 private:
1656   ShenandoahVMRoots&lt;true /*concurrent*/&gt;        _vm_roots;
1657   ShenandoahWeakRoots&lt;true /*concurrent*/&gt;      _weak_roots;
1658   ShenandoahClassLoaderDataRoots&lt;true /*concurrent*/, false /*single threaded*/&gt; _cld_roots;
1659   ShenandoahConcurrentStringDedupRoots          _dedup_roots;
1660   bool                                          _include_weak_roots;
1661 
1662 public:
1663   ShenandoahConcurrentRootsEvacUpdateTask(bool include_weak_roots) :
1664     AbstractGangTask(&quot;Shenandoah Evacuate/Update Concurrent Roots Task&quot;),
1665     _include_weak_roots(include_weak_roots) {
1666   }
1667 
1668   void work(uint worker_id) {
1669     ShenandoahEvacOOMScope oom;
1670     {
1671       // vm_roots and weak_roots are OopStorage backed roots, concurrent iteration
1672       // may race against OopStorage::release() calls.
1673       ShenandoahEvacUpdateOopStorageRootsClosure cl;
1674       _vm_roots.oops_do&lt;ShenandoahEvacUpdateOopStorageRootsClosure&gt;(&amp;cl);
1675 
1676       if (_include_weak_roots) {
1677         _weak_roots.oops_do&lt;ShenandoahEvacUpdateOopStorageRootsClosure&gt;(&amp;cl);
1678       }
1679     }
1680 
1681     {
1682       ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;
1683       CLDToOopClosure clds(&amp;cl, ClassLoaderData::_claim_strong);
1684       _cld_roots.cld_do(&amp;clds);
1685     }
1686 
1687     {
1688       ShenandoahForwardedIsAliveClosure is_alive;
1689       ShenandoahEvacuateUpdateRootsClosure&lt;MO_RELEASE&gt; keep_alive;
1690       _dedup_roots.oops_do(&amp;is_alive, &amp;keep_alive, worker_id);
1691     }
1692   }
1693 };
1694 
1695 class ShenandoahEvacUpdateCleanupOopStorageRootsClosure : public BasicOopIterateClosure {
1696 private:
1697   ShenandoahHeap* const _heap;
1698   ShenandoahMarkingContext* const _mark_context;
1699   bool  _evac_in_progress;
1700   Thread* const _thread;
1701   size_t  _dead_counter;
1702 
1703 public:
1704   ShenandoahEvacUpdateCleanupOopStorageRootsClosure();
1705   void do_oop(oop* p);
1706   void do_oop(narrowOop* p);
1707 
1708   size_t dead_counter() const;
1709   void reset_dead_counter();
1710 };
1711 
1712 ShenandoahEvacUpdateCleanupOopStorageRootsClosure::ShenandoahEvacUpdateCleanupOopStorageRootsClosure() :
1713   _heap(ShenandoahHeap::heap()),
1714   _mark_context(ShenandoahHeap::heap()-&gt;marking_context()),
1715   _evac_in_progress(ShenandoahHeap::heap()-&gt;is_evacuation_in_progress()),
1716   _thread(Thread::current()),
1717   _dead_counter(0) {
1718 }
1719 
1720 void ShenandoahEvacUpdateCleanupOopStorageRootsClosure::do_oop(oop* p) {
1721   const oop obj = RawAccess&lt;&gt;::oop_load(p);
1722   if (!CompressedOops::is_null(obj)) {
1723     if (!_mark_context-&gt;is_marked(obj)) {
1724       shenandoah_assert_correct(p, obj);
1725       oop old = Atomic::cmpxchg(p, obj, oop(NULL));
1726       if (obj == old) {
1727         _dead_counter ++;
1728       }
1729     } else if (_evac_in_progress &amp;&amp; _heap-&gt;in_collection_set(obj)) {
1730       oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
1731       if (resolved == obj) {
1732         resolved = _heap-&gt;evacuate_object(obj, _thread);
1733       }
1734       Atomic::cmpxchg(p, obj, resolved);
1735       assert(_heap-&gt;cancelled_gc() ||
1736              _mark_context-&gt;is_marked(resolved) &amp;&amp; !_heap-&gt;in_collection_set(resolved),
1737              &quot;Sanity&quot;);
1738     }
1739   }
1740 }
1741 
1742 void ShenandoahEvacUpdateCleanupOopStorageRootsClosure::do_oop(narrowOop* p) {
1743   ShouldNotReachHere();
1744 }
1745 
1746 size_t ShenandoahEvacUpdateCleanupOopStorageRootsClosure::dead_counter() const {
1747   return _dead_counter;
1748 }
1749 
1750 void ShenandoahEvacUpdateCleanupOopStorageRootsClosure::reset_dead_counter() {
1751   _dead_counter = 0;
1752 }
1753 
1754 // This task not only evacuates/updates marked weak roots, but also &quot;NULL&quot;
1755 // dead weak roots.
1756 class ShenandoahConcurrentWeakRootsEvacUpdateTask : public AbstractGangTask {
1757 private:
1758   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _jni_roots;
1759   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _string_table_roots;
1760   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _resolved_method_table_roots;
1761   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _vm_roots;
1762 
1763 public:
1764   ShenandoahConcurrentWeakRootsEvacUpdateTask() :
1765     AbstractGangTask(&quot;Shenandoah Concurrent Weak Root Task&quot;),
1766     _jni_roots(OopStorageSet::jni_weak(), ShenandoahPhaseTimings::JNIWeakRoots),
1767     _string_table_roots(OopStorageSet::string_table_weak(), ShenandoahPhaseTimings::StringTableRoots),
1768     _resolved_method_table_roots(OopStorageSet::resolved_method_table_weak(), ShenandoahPhaseTimings::ResolvedMethodTableRoots),
1769     _vm_roots(OopStorageSet::vm_weak(), ShenandoahPhaseTimings::VMWeakRoots) {
1770     StringTable::reset_dead_counter();
1771     ResolvedMethodTable::reset_dead_counter();
1772   }
1773 
1774   ~ShenandoahConcurrentWeakRootsEvacUpdateTask() {
1775     StringTable::finish_dead_counter();
1776     ResolvedMethodTable::finish_dead_counter();
1777   }
1778 
1779   void work(uint worker_id) {
1780     ShenandoahEvacOOMScope oom;
1781     // jni_roots and weak_roots are OopStorage backed roots, concurrent iteration
1782     // may race against OopStorage::release() calls.
1783     ShenandoahEvacUpdateCleanupOopStorageRootsClosure cl;
1784     _jni_roots.oops_do(&amp;cl, worker_id);
1785     _vm_roots.oops_do(&amp;cl, worker_id);
1786 
1787     cl.reset_dead_counter();
1788     _string_table_roots.oops_do(&amp;cl, worker_id);
1789     StringTable::inc_dead_counter(cl.dead_counter());
1790 
1791     cl.reset_dead_counter();
1792     _resolved_method_table_roots.oops_do(&amp;cl, worker_id);
1793     ResolvedMethodTable::inc_dead_counter(cl.dead_counter());
1794   }
1795 };
1796 
1797 void ShenandoahHeap::op_roots() {
1798   if (is_concurrent_root_in_progress()) {
1799     if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1800       // Concurrent weak root processing
1801       ShenandoahConcurrentWeakRootsEvacUpdateTask task;
1802       workers()-&gt;run_task(&amp;task);
1803 
1804       _unloader.unload();
1805     }
1806 
1807     if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {
1808       ShenandoahConcurrentRootsEvacUpdateTask task(!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
1809       workers()-&gt;run_task(&amp;task);
1810     }
1811   }
1812 
1813   set_concurrent_root_in_progress(false);
1814 }
1815 
1816 void ShenandoahHeap::op_reset() {
1817   if (ShenandoahPacing) {
1818     pacer()-&gt;setup_for_reset();
1819   }
1820   reset_mark_bitmap();
1821 }
1822 
1823 void ShenandoahHeap::op_preclean() {
1824   if (ShenandoahPacing) {
1825     pacer()-&gt;setup_for_preclean();
1826   }
1827   concurrent_mark()-&gt;preclean_weak_refs();
1828 }
1829 
1830 void ShenandoahHeap::op_init_traversal() {
1831   traversal_gc()-&gt;init_traversal_collection();
1832 }
1833 
1834 void ShenandoahHeap::op_traversal() {
1835   traversal_gc()-&gt;concurrent_traversal_collection();
1836 }
1837 
1838 void ShenandoahHeap::op_final_traversal() {
1839   traversal_gc()-&gt;final_traversal_collection();
1840 }
1841 
1842 void ShenandoahHeap::op_full(GCCause::Cause cause) {
1843   ShenandoahMetricsSnapshot metrics;
1844   metrics.snap_before();
1845 
1846   full_gc()-&gt;do_it(cause);
1847   if (UseTLAB) {
1848     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_resize_tlabs);
1849     resize_all_tlabs();
1850   }
1851 
1852   metrics.snap_after();
1853 
1854   if (metrics.is_good_progress()) {
1855     _progress_last_gc.set();
1856   } else {
1857     // Nothing to do. Tell the allocation path that we have failed to make
1858     // progress, and it can finally fail.
1859     _progress_last_gc.unset();
1860   }
1861 }
1862 
1863 void ShenandoahHeap::op_degenerated(ShenandoahDegenPoint point) {
1864   // Degenerated GC is STW, but it can also fail. Current mechanics communicates
1865   // GC failure via cancelled_concgc() flag. So, if we detect the failure after
1866   // some phase, we have to upgrade the Degenerate GC to Full GC.
1867 
1868   clear_cancelled_gc();
1869 
1870   ShenandoahMetricsSnapshot metrics;
1871   metrics.snap_before();
1872 
1873   switch (point) {
1874     case _degenerated_traversal:
1875       {
1876         // Drop the collection set. Note: this leaves some already forwarded objects
1877         // behind, which may be problematic, see comments for ShenandoahEvacAssist
1878         // workarounds in ShenandoahTraversalHeuristics.
1879 
1880         ShenandoahHeapLocker locker(lock());
1881         collection_set()-&gt;clear_current_index();
1882         for (size_t i = 0; i &lt; collection_set()-&gt;count(); i++) {
1883           ShenandoahHeapRegion* r = collection_set()-&gt;next();
1884           r-&gt;make_regular_bypass();
1885         }
1886         collection_set()-&gt;clear();
1887       }
1888       op_final_traversal();
1889       op_cleanup();
1890       return;
1891 
1892     // The cases below form the Duff&#39;s-like device: it describes the actual GC cycle,
1893     // but enters it at different points, depending on which concurrent phase had
1894     // degenerated.
1895 
1896     case _degenerated_outside_cycle:
1897       // We have degenerated from outside the cycle, which means something is bad with
1898       // the heap, most probably heavy humongous fragmentation, or we are very low on free
1899       // space. It makes little sense to wait for Full GC to reclaim as much as it can, when
1900       // we can do the most aggressive degen cycle, which includes processing references and
1901       // class unloading, unless those features are explicitly disabled.
1902       //
1903       // Note that we can only do this for &quot;outside-cycle&quot; degens, otherwise we would risk
1904       // changing the cycle parameters mid-cycle during concurrent -&gt; degenerated handover.
1905       set_process_references(heuristics()-&gt;can_process_references());
1906       set_unload_classes(heuristics()-&gt;can_unload_classes());
1907 
1908       if (is_traversal_mode()) {
1909         // Not possible to degenerate from here, upgrade to Full GC right away.
1910         cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
1911         op_degenerated_fail();
1912         return;
1913       }
1914 
1915       op_reset();
1916 
1917       op_init_mark();
1918       if (cancelled_gc()) {
1919         op_degenerated_fail();
1920         return;
1921       }
1922 
1923     case _degenerated_mark:
1924       op_final_mark();
1925       if (cancelled_gc()) {
1926         op_degenerated_fail();
1927         return;
1928       }
1929 
<a name="34" id="anc34"></a>






1930       op_cleanup();
1931 
1932     case _degenerated_evac:
1933       // If heuristics thinks we should do the cycle, this flag would be set,
1934       // and we can do evacuation. Otherwise, it would be the shortcut cycle.
1935       if (is_evacuation_in_progress()) {
1936 
1937         // Degeneration under oom-evac protocol might have left some objects in
1938         // collection set un-evacuated. Restart evacuation from the beginning to
1939         // capture all objects. For all the objects that are already evacuated,
1940         // it would be a simple check, which is supposed to be fast. This is also
1941         // safe to do even without degeneration, as CSet iterator is at beginning
1942         // in preparation for evacuation anyway.
1943         //
1944         // Before doing that, we need to make sure we never had any cset-pinned
1945         // regions. This may happen if allocation failure happened when evacuating
1946         // the about-to-be-pinned object, oom-evac protocol left the object in
1947         // the collection set, and then the pin reached the cset region. If we continue
1948         // the cycle here, we would trash the cset and alive objects in it. To avoid
1949         // it, we fail degeneration right away and slide into Full GC to recover.
1950 
1951         {
1952           sync_pinned_region_status();
1953           collection_set()-&gt;clear_current_index();
1954 
1955           ShenandoahHeapRegion* r;
1956           while ((r = collection_set()-&gt;next()) != NULL) {
1957             if (r-&gt;is_pinned()) {
1958               cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
1959               op_degenerated_fail();
1960               return;
1961             }
1962           }
1963 
1964           collection_set()-&gt;clear_current_index();
1965         }
1966 
1967         op_stw_evac();
1968         if (cancelled_gc()) {
1969           op_degenerated_fail();
1970           return;
1971         }
1972       }
1973 
1974       // If heuristics thinks we should do the cycle, this flag would be set,
1975       // and we need to do update-refs. Otherwise, it would be the shortcut cycle.
1976       if (has_forwarded_objects()) {
1977         op_init_updaterefs();
1978         if (cancelled_gc()) {
1979           op_degenerated_fail();
1980           return;
1981         }
1982       }
1983 
1984     case _degenerated_updaterefs:
1985       if (has_forwarded_objects()) {
1986         op_final_updaterefs();
1987         if (cancelled_gc()) {
1988           op_degenerated_fail();
1989           return;
1990         }
1991       }
1992 
1993       op_cleanup();
1994       break;
1995 
1996     default:
1997       ShouldNotReachHere();
1998   }
1999 
2000   if (ShenandoahVerify) {
2001     verifier()-&gt;verify_after_degenerated();
2002   }
2003 
2004   if (VerifyAfterGC) {
2005     Universe::verify();
2006   }
2007 
2008   metrics.snap_after();
2009 
2010   // Check for futility and fail. There is no reason to do several back-to-back Degenerated cycles,
2011   // because that probably means the heap is overloaded and/or fragmented.
2012   if (!metrics.is_good_progress()) {
2013     _progress_last_gc.unset();
2014     cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
2015     op_degenerated_futile();
2016   } else {
2017     _progress_last_gc.set();
2018   }
2019 }
2020 
2021 void ShenandoahHeap::op_degenerated_fail() {
2022   log_info(gc)(&quot;Cannot finish degeneration, upgrading to Full GC&quot;);
2023   shenandoah_policy()-&gt;record_degenerated_upgrade_to_full();
2024   op_full(GCCause::_shenandoah_upgrade_to_full_gc);
2025 }
2026 
2027 void ShenandoahHeap::op_degenerated_futile() {
2028   shenandoah_policy()-&gt;record_degenerated_upgrade_to_full();
2029   op_full(GCCause::_shenandoah_upgrade_to_full_gc);
2030 }
2031 
2032 void ShenandoahHeap::force_satb_flush_all_threads() {
2033   if (!is_concurrent_mark_in_progress() &amp;&amp; !is_concurrent_traversal_in_progress()) {
2034     // No need to flush SATBs
2035     return;
2036   }
2037 
2038   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
2039     ShenandoahThreadLocalData::set_force_satb_flush(t, true);
2040   }
2041   // The threads are not &quot;acquiring&quot; their thread-local data, but it does not
2042   // hurt to &quot;release&quot; the updates here anyway.
2043   OrderAccess::fence();
2044 }
2045 
2046 void ShenandoahHeap::set_gc_state_all_threads(char state) {
2047   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
2048     ShenandoahThreadLocalData::set_gc_state(t, state);
2049   }
2050 }
2051 
2052 void ShenandoahHeap::set_gc_state_mask(uint mask, bool value) {
2053   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should really be Shenandoah safepoint&quot;);
2054   _gc_state.set_cond(mask, value);
2055   set_gc_state_all_threads(_gc_state.raw_value());
2056 }
2057 
2058 void ShenandoahHeap::set_concurrent_mark_in_progress(bool in_progress) {
2059   if (has_forwarded_objects()) {
2060     set_gc_state_mask(MARKING | UPDATEREFS, in_progress);
2061   } else {
2062     set_gc_state_mask(MARKING, in_progress);
2063   }
2064   ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);
2065 }
2066 
2067 void ShenandoahHeap::set_concurrent_traversal_in_progress(bool in_progress) {
2068    set_gc_state_mask(TRAVERSAL, in_progress);
2069    ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);
2070 }
2071 
2072 void ShenandoahHeap::set_evacuation_in_progress(bool in_progress) {
2073   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only call this at safepoint&quot;);
2074   set_gc_state_mask(EVACUATION, in_progress);
2075 }
2076 
2077 void ShenandoahHeap::set_concurrent_root_in_progress(bool in_progress) {
2078   assert(ShenandoahConcurrentRoots::can_do_concurrent_roots(), &quot;Why set the flag?&quot;);
2079   if (in_progress) {
2080     _concurrent_root_in_progress.set();
2081   } else {
2082     _concurrent_root_in_progress.unset();
2083   }
2084 }
2085 
2086 void ShenandoahHeap::ref_processing_init() {
2087   assert(_max_workers &gt; 0, &quot;Sanity&quot;);
2088 
2089   _ref_processor =
2090     new ReferenceProcessor(&amp;_subject_to_discovery,  // is_subject_to_discovery
2091                            ParallelRefProcEnabled,  // MT processing
2092                            _max_workers,            // Degree of MT processing
2093                            true,                    // MT discovery
2094                            _max_workers,            // Degree of MT discovery
2095                            false,                   // Reference discovery is not atomic
2096                            NULL,                    // No closure, should be installed before use
2097                            true);                   // Scale worker threads
2098 
2099   shenandoah_assert_rp_isalive_not_installed();
2100 }
2101 
2102 GCTracer* ShenandoahHeap::tracer() {
2103   return shenandoah_policy()-&gt;tracer();
2104 }
2105 
2106 size_t ShenandoahHeap::tlab_used(Thread* thread) const {
2107   return _free_set-&gt;used();
2108 }
2109 
2110 bool ShenandoahHeap::try_cancel_gc() {
2111   while (true) {
2112     jbyte prev = _cancelled_gc.cmpxchg(CANCELLED, CANCELLABLE);
2113     if (prev == CANCELLABLE) return true;
2114     else if (prev == CANCELLED) return false;
2115     assert(ShenandoahSuspendibleWorkers, &quot;should not get here when not using suspendible workers&quot;);
2116     assert(prev == NOT_CANCELLED, &quot;must be NOT_CANCELLED&quot;);
2117     if (Thread::current()-&gt;is_Java_thread()) {
2118       // We need to provide a safepoint here, otherwise we might
2119       // spin forever if a SP is pending.
2120       ThreadBlockInVM sp(JavaThread::current());
2121       SpinPause();
2122     }
2123   }
2124 }
2125 
2126 void ShenandoahHeap::cancel_gc(GCCause::Cause cause) {
2127   if (try_cancel_gc()) {
2128     FormatBuffer&lt;&gt; msg(&quot;Cancelling GC: %s&quot;, GCCause::to_string(cause));
2129     log_info(gc)(&quot;%s&quot;, msg.buffer());
2130     Events::log(Thread::current(), &quot;%s&quot;, msg.buffer());
2131   }
2132 }
2133 
2134 uint ShenandoahHeap::max_workers() {
2135   return _max_workers;
2136 }
2137 
2138 void ShenandoahHeap::stop() {
2139   // The shutdown sequence should be able to terminate when GC is running.
2140 
2141   // Step 0. Notify policy to disable event recording.
2142   _shenandoah_policy-&gt;record_shutdown();
2143 
2144   // Step 1. Notify control thread that we are in shutdown.
2145   // Note that we cannot do that with stop(), because stop() is blocking and waits for the actual shutdown.
2146   // Doing stop() here would wait for the normal GC cycle to complete, never falling through to cancel below.
2147   control_thread()-&gt;prepare_for_graceful_shutdown();
2148 
2149   // Step 2. Notify GC workers that we are cancelling GC.
2150   cancel_gc(GCCause::_shenandoah_stop_vm);
2151 
2152   // Step 3. Wait until GC worker exits normally.
2153   control_thread()-&gt;stop();
2154 
2155   // Step 4. Stop String Dedup thread if it is active
2156   if (ShenandoahStringDedup::is_enabled()) {
2157     ShenandoahStringDedup::stop();
2158   }
2159 }
2160 
2161 void ShenandoahHeap::stw_unload_classes(bool full_gc) {
2162   if (!unload_classes()) return;
2163   bool purged_class;
2164 
2165   // Unload classes and purge SystemDictionary.
2166   {
2167     ShenandoahGCPhase phase(full_gc ?
2168                             ShenandoahPhaseTimings::full_gc_purge_class_unload :
2169                             ShenandoahPhaseTimings::purge_class_unload);
2170     purged_class = SystemDictionary::do_unloading(gc_timer());
2171   }
2172 
2173   {
2174     ShenandoahGCPhase phase(full_gc ?
2175                             ShenandoahPhaseTimings::full_gc_purge_par :
2176                             ShenandoahPhaseTimings::purge_par);
2177     ShenandoahIsAliveSelector is_alive;
2178     uint num_workers = _workers-&gt;active_workers();
2179     ShenandoahClassUnloadingTask unlink_task(is_alive.is_alive_closure(), num_workers, purged_class);
2180     _workers-&gt;run_task(&amp;unlink_task);
2181   }
2182 
2183   {
2184     ShenandoahGCPhase phase(full_gc ?
2185                             ShenandoahPhaseTimings::full_gc_purge_cldg :
2186                             ShenandoahPhaseTimings::purge_cldg);
2187     ClassLoaderDataGraph::purge();
2188   }
2189   // Resize and verify metaspace
2190   MetaspaceGC::compute_new_size();
2191   MetaspaceUtils::verify_metrics();
2192 }
2193 
2194 // Weak roots are either pre-evacuated (final mark) or updated (final updaterefs),
2195 // so they should not have forwarded oops.
2196 // However, we do need to &quot;null&quot; dead oops in the roots, if can not be done
2197 // in concurrent cycles.
2198 void ShenandoahHeap::stw_process_weak_roots(bool full_gc) {
2199   ShenandoahGCPhase root_phase(full_gc ?
2200                                ShenandoahPhaseTimings::full_gc_purge :
2201                                ShenandoahPhaseTimings::purge);
2202   uint num_workers = _workers-&gt;active_workers();
2203   ShenandoahPhaseTimings::Phase timing_phase = full_gc ?
2204                                                ShenandoahPhaseTimings::full_gc_purge_par :
2205                                                ShenandoahPhaseTimings::purge_par;
<a name="35" id="anc35"></a><span class="line-removed">2206   // Cleanup weak roots</span>
2207   ShenandoahGCPhase phase(timing_phase);
<a name="36" id="anc36"></a><span class="line-modified">2208   phase_timings()-&gt;record_workers_start(timing_phase);</span>


2209   if (has_forwarded_objects()) {
<a name="37" id="anc37"></a><span class="line-modified">2210     if (is_traversal_mode()) {</span>
<span class="line-modified">2211       ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-modified">2212       ShenandoahTraversalUpdateRefsClosure keep_alive;</span>
<span class="line-modified">2213       ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahForwardedIsAliveClosure, ShenandoahTraversalUpdateRefsClosure&gt;</span>
<span class="line-modified">2214         cleaning_task(&amp;is_alive, &amp;keep_alive, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
<span class="line-removed">2215       _workers-&gt;run_task(&amp;cleaning_task);</span>
<span class="line-removed">2216     } else {</span>
<span class="line-removed">2217       ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-removed">2218       ShenandoahUpdateRefsClosure keep_alive;</span>
<span class="line-removed">2219       ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahForwardedIsAliveClosure, ShenandoahUpdateRefsClosure&gt;</span>
<span class="line-removed">2220         cleaning_task(&amp;is_alive, &amp;keep_alive, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
<span class="line-removed">2221       _workers-&gt;run_task(&amp;cleaning_task);</span>
<span class="line-removed">2222     }</span>
2223   } else {
2224     ShenandoahIsAliveClosure is_alive;
2225 #ifdef ASSERT
2226     ShenandoahAssertNotForwardedClosure verify_cl;
2227     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, ShenandoahAssertNotForwardedClosure&gt;
2228       cleaning_task(&amp;is_alive, &amp;verify_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
2229 #else
2230     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, DoNothingClosure&gt;
2231       cleaning_task(&amp;is_alive, &amp;do_nothing_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
2232 #endif
2233     _workers-&gt;run_task(&amp;cleaning_task);
2234   }
<a name="38" id="anc38"></a><span class="line-removed">2235   phase_timings()-&gt;record_workers_end(timing_phase);</span>
2236 }
2237 
2238 void ShenandoahHeap::parallel_cleaning(bool full_gc) {
2239   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2240   stw_process_weak_roots(full_gc);
2241   if (!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
2242     stw_unload_classes(full_gc);
2243   }
2244 }
2245 
2246 void ShenandoahHeap::set_has_forwarded_objects(bool cond) {
2247   if (is_traversal_mode()) {
2248     set_gc_state_mask(HAS_FORWARDED | UPDATEREFS, cond);
2249   } else {
2250     set_gc_state_mask(HAS_FORWARDED, cond);
2251   }
2252 
2253 }
2254 
2255 void ShenandoahHeap::set_process_references(bool pr) {
2256   _process_references.set_cond(pr);
2257 }
2258 
2259 void ShenandoahHeap::set_unload_classes(bool uc) {
2260   _unload_classes.set_cond(uc);
2261 }
2262 
2263 bool ShenandoahHeap::process_references() const {
2264   return _process_references.is_set();
2265 }
2266 
2267 bool ShenandoahHeap::unload_classes() const {
2268   return _unload_classes.is_set();
2269 }
2270 
2271 address ShenandoahHeap::in_cset_fast_test_addr() {
2272   ShenandoahHeap* heap = ShenandoahHeap::heap();
2273   assert(heap-&gt;collection_set() != NULL, &quot;Sanity&quot;);
2274   return (address) heap-&gt;collection_set()-&gt;biased_map_address();
2275 }
2276 
2277 address ShenandoahHeap::cancelled_gc_addr() {
2278   return (address) ShenandoahHeap::heap()-&gt;_cancelled_gc.addr_of();
2279 }
2280 
2281 address ShenandoahHeap::gc_state_addr() {
2282   return (address) ShenandoahHeap::heap()-&gt;_gc_state.addr_of();
2283 }
2284 
2285 size_t ShenandoahHeap::bytes_allocated_since_gc_start() {
2286   return Atomic::load_acquire(&amp;_bytes_allocated_since_gc_start);
2287 }
2288 
2289 void ShenandoahHeap::reset_bytes_allocated_since_gc_start() {
2290   Atomic::release_store_fence(&amp;_bytes_allocated_since_gc_start, (size_t)0);
2291 }
2292 
2293 void ShenandoahHeap::set_degenerated_gc_in_progress(bool in_progress) {
2294   _degenerated_gc_in_progress.set_cond(in_progress);
2295 }
2296 
2297 void ShenandoahHeap::set_full_gc_in_progress(bool in_progress) {
2298   _full_gc_in_progress.set_cond(in_progress);
2299 }
2300 
2301 void ShenandoahHeap::set_full_gc_move_in_progress(bool in_progress) {
2302   assert (is_full_gc_in_progress(), &quot;should be&quot;);
2303   _full_gc_move_in_progress.set_cond(in_progress);
2304 }
2305 
2306 void ShenandoahHeap::set_update_refs_in_progress(bool in_progress) {
2307   set_gc_state_mask(UPDATEREFS, in_progress);
2308 }
2309 
2310 void ShenandoahHeap::register_nmethod(nmethod* nm) {
2311   ShenandoahCodeRoots::register_nmethod(nm);
2312 }
2313 
2314 void ShenandoahHeap::unregister_nmethod(nmethod* nm) {
2315   ShenandoahCodeRoots::unregister_nmethod(nm);
2316 }
2317 
2318 void ShenandoahHeap::flush_nmethod(nmethod* nm) {
2319   ShenandoahCodeRoots::flush_nmethod(nm);
2320 }
2321 
2322 oop ShenandoahHeap::pin_object(JavaThread* thr, oop o) {
2323   heap_region_containing(o)-&gt;record_pin();
2324   return o;
2325 }
2326 
2327 void ShenandoahHeap::unpin_object(JavaThread* thr, oop o) {
2328   heap_region_containing(o)-&gt;record_unpin();
2329 }
2330 
2331 void ShenandoahHeap::sync_pinned_region_status() {
2332   ShenandoahHeapLocker locker(lock());
2333 
2334   for (size_t i = 0; i &lt; num_regions(); i++) {
2335     ShenandoahHeapRegion *r = get_region(i);
2336     if (r-&gt;is_active()) {
2337       if (r-&gt;is_pinned()) {
2338         if (r-&gt;pin_count() == 0) {
2339           r-&gt;make_unpinned();
2340         }
2341       } else {
2342         if (r-&gt;pin_count() &gt; 0) {
2343           r-&gt;make_pinned();
2344         }
2345       }
2346     }
2347   }
2348 
2349   assert_pinned_region_status();
2350 }
2351 
2352 #ifdef ASSERT
2353 void ShenandoahHeap::assert_pinned_region_status() {
2354   for (size_t i = 0; i &lt; num_regions(); i++) {
2355     ShenandoahHeapRegion* r = get_region(i);
2356     assert((r-&gt;is_pinned() &amp;&amp; r-&gt;pin_count() &gt; 0) || (!r-&gt;is_pinned() &amp;&amp; r-&gt;pin_count() == 0),
2357            &quot;Region &quot; SIZE_FORMAT &quot; pinning status is inconsistent&quot;, i);
2358   }
2359 }
2360 #endif
2361 
2362 GCTimer* ShenandoahHeap::gc_timer() const {
2363   return _gc_timer;
2364 }
2365 
2366 void ShenandoahHeap::prepare_concurrent_roots() {
2367   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2368   if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {
2369     set_concurrent_root_in_progress(true);
2370   }
2371 }
2372 
2373 void ShenandoahHeap::prepare_concurrent_unloading() {
2374   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2375   if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
2376     _unloader.prepare();
2377   }
2378 }
2379 
2380 void ShenandoahHeap::finish_concurrent_unloading() {
2381   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2382   if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
2383     _unloader.finish();
2384   }
2385 }
2386 
2387 #ifdef ASSERT
2388 void ShenandoahHeap::assert_gc_workers(uint nworkers) {
2389   assert(nworkers &gt; 0 &amp;&amp; nworkers &lt;= max_workers(), &quot;Sanity&quot;);
2390 
2391   if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {
<a name="39" id="anc39"></a><span class="line-modified">2392     if (UseDynamicNumberOfGCThreads ||</span>
<span class="line-removed">2393         (FLAG_IS_DEFAULT(ParallelGCThreads) &amp;&amp; ForceDynamicNumberOfGCThreads)) {</span>
2394       assert(nworkers &lt;= ParallelGCThreads, &quot;Cannot use more than it has&quot;);
2395     } else {
2396       // Use ParallelGCThreads inside safepoints
<a name="40" id="anc40"></a><span class="line-modified">2397       assert(nworkers == ParallelGCThreads, &quot;Use ParalleGCThreads within safepoints&quot;);</span>
2398     }
2399   } else {
<a name="41" id="anc41"></a><span class="line-modified">2400     if (UseDynamicNumberOfGCThreads ||</span>
<span class="line-removed">2401         (FLAG_IS_DEFAULT(ConcGCThreads) &amp;&amp; ForceDynamicNumberOfGCThreads)) {</span>
2402       assert(nworkers &lt;= ConcGCThreads, &quot;Cannot use more than it has&quot;);
2403     } else {
2404       // Use ConcGCThreads outside safepoints
2405       assert(nworkers == ConcGCThreads, &quot;Use ConcGCThreads outside safepoints&quot;);
2406     }
2407   }
2408 }
2409 #endif
2410 
2411 ShenandoahVerifier* ShenandoahHeap::verifier() {
2412   guarantee(ShenandoahVerify, &quot;Should be enabled&quot;);
2413   assert (_verifier != NULL, &quot;sanity&quot;);
2414   return _verifier;
2415 }
2416 
2417 template&lt;class T&gt;
2418 class ShenandoahUpdateHeapRefsTask : public AbstractGangTask {
2419 private:
2420   T cl;
2421   ShenandoahHeap* _heap;
2422   ShenandoahRegionIterator* _regions;
2423   bool _concurrent;
2424 public:
2425   ShenandoahUpdateHeapRefsTask(ShenandoahRegionIterator* regions, bool concurrent) :
2426     AbstractGangTask(&quot;Concurrent Update References Task&quot;),
2427     cl(T()),
2428     _heap(ShenandoahHeap::heap()),
2429     _regions(regions),
2430     _concurrent(concurrent) {
2431   }
2432 
2433   void work(uint worker_id) {
2434     if (_concurrent) {
2435       ShenandoahConcurrentWorkerSession worker_session(worker_id);
2436       ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
2437       do_work();
2438     } else {
2439       ShenandoahParallelWorkerSession worker_session(worker_id);
2440       do_work();
2441     }
2442   }
2443 
2444 private:
2445   void do_work() {
2446     ShenandoahHeapRegion* r = _regions-&gt;next();
2447     ShenandoahMarkingContext* const ctx = _heap-&gt;complete_marking_context();
2448     while (r != NULL) {
<a name="42" id="anc42"></a><span class="line-modified">2449       HeapWord* top_at_start_ur = r-&gt;concurrent_iteration_safe_limit();</span>
<span class="line-modified">2450       assert (top_at_start_ur &gt;= r-&gt;bottom(), &quot;sanity&quot;);</span>
2451       if (r-&gt;is_active() &amp;&amp; !r-&gt;is_cset()) {
<a name="43" id="anc43"></a><span class="line-modified">2452         _heap-&gt;marked_object_oop_iterate(r, &amp;cl, top_at_start_ur);</span>
2453       }
2454       if (ShenandoahPacing) {
<a name="44" id="anc44"></a><span class="line-modified">2455         _heap-&gt;pacer()-&gt;report_updaterefs(pointer_delta(top_at_start_ur, r-&gt;bottom()));</span>
2456       }
2457       if (_heap-&gt;check_cancelled_gc_and_yield(_concurrent)) {
2458         return;
2459       }
2460       r = _regions-&gt;next();
2461     }
2462   }
2463 };
2464 
2465 void ShenandoahHeap::update_heap_references(bool concurrent) {
2466   ShenandoahUpdateHeapRefsTask&lt;ShenandoahUpdateHeapRefsClosure&gt; task(&amp;_update_refs_iterator, concurrent);
2467   workers()-&gt;run_task(&amp;task);
2468 }
2469 
2470 void ShenandoahHeap::op_init_updaterefs() {
2471   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
2472 
2473   set_evacuation_in_progress(false);
2474 
2475   {
2476     ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_retire_gclabs);
2477     retire_and_reset_gclabs();
2478   }
2479 
2480   if (ShenandoahVerify) {
2481     if (!is_degenerated_gc_in_progress()) {
2482       verifier()-&gt;verify_roots_in_to_space_except(ShenandoahRootVerifier::ThreadRoots);
2483     }
2484     verifier()-&gt;verify_before_updaterefs();
2485   }
2486 
2487   set_update_refs_in_progress(true);
2488 
2489   {
2490     ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_prepare);
2491 
2492     make_parsable(true);
<a name="45" id="anc45"></a><span class="line-removed">2493     for (uint i = 0; i &lt; num_regions(); i++) {</span>
<span class="line-removed">2494       ShenandoahHeapRegion* r = get_region(i);</span>
<span class="line-removed">2495       r-&gt;set_concurrent_iteration_safe_limit(r-&gt;top());</span>
<span class="line-removed">2496     }</span>
2497 
2498     // Reset iterator.
2499     _update_refs_iterator.reset();
2500   }
2501 
2502   if (ShenandoahPacing) {
2503     pacer()-&gt;setup_for_updaterefs();
2504   }
2505 }
2506 
2507 void ShenandoahHeap::op_final_updaterefs() {
2508   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
2509 
2510   finish_concurrent_unloading();
2511 
2512   // Check if there is left-over work, and finish it
2513   if (_update_refs_iterator.has_next()) {
2514     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_finish_work);
2515 
2516     // Finish updating references where we left off.
2517     clear_cancelled_gc();
2518     update_heap_references(false);
2519   }
2520 
2521   // Clear cancelled GC, if set. On cancellation path, the block before would handle
2522   // everything. On degenerated paths, cancelled gc would not be set anyway.
2523   if (cancelled_gc()) {
2524     clear_cancelled_gc();
2525   }
2526   assert(!cancelled_gc(), &quot;Should have been done right before&quot;);
2527 
2528   if (ShenandoahVerify &amp;&amp; !is_degenerated_gc_in_progress()) {
2529     verifier()-&gt;verify_roots_in_to_space_except(ShenandoahRootVerifier::ThreadRoots);
2530   }
2531 
2532   if (is_degenerated_gc_in_progress()) {
2533     concurrent_mark()-&gt;update_roots(ShenandoahPhaseTimings::degen_gc_update_roots);
2534   } else {
2535     concurrent_mark()-&gt;update_thread_roots(ShenandoahPhaseTimings::final_update_refs_roots);
2536   }
2537 
2538   // Has to be done before cset is clear
2539   if (ShenandoahVerify) {
2540     verifier()-&gt;verify_roots_in_to_space();
2541   }
2542 
2543   // Drop unnecessary &quot;pinned&quot; state from regions that does not have CP marks
2544   // anymore, as this would allow trashing them below.
2545   {
2546     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_sync_pinned);
2547     sync_pinned_region_status();
2548   }
2549 
2550   {
2551     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_trash_cset);
2552     trash_cset_regions();
2553   }
2554 
2555   set_has_forwarded_objects(false);
2556   set_update_refs_in_progress(false);
2557 
2558   if (ShenandoahVerify) {
2559     verifier()-&gt;verify_after_updaterefs();
2560   }
2561 
2562   if (VerifyAfterGC) {
2563     Universe::verify();
2564   }
2565 
2566   {
2567     ShenandoahHeapLocker locker(lock());
2568     _free_set-&gt;rebuild();
2569   }
2570 }
2571 
<a name="46" id="anc46"></a><span class="line-removed">2572 #ifdef ASSERT</span>
<span class="line-removed">2573 void ShenandoahHeap::assert_heaplock_owned_by_current_thread() {</span>
<span class="line-removed">2574   _lock.assert_owned_by_current_thread();</span>
<span class="line-removed">2575 }</span>
<span class="line-removed">2576 </span>
<span class="line-removed">2577 void ShenandoahHeap::assert_heaplock_not_owned_by_current_thread() {</span>
<span class="line-removed">2578   _lock.assert_not_owned_by_current_thread();</span>
<span class="line-removed">2579 }</span>
<span class="line-removed">2580 </span>
<span class="line-removed">2581 void ShenandoahHeap::assert_heaplock_or_safepoint() {</span>
<span class="line-removed">2582   _lock.assert_owned_by_current_thread_or_safepoint();</span>
<span class="line-removed">2583 }</span>
<span class="line-removed">2584 #endif</span>
<span class="line-removed">2585 </span>
2586 void ShenandoahHeap::print_extended_on(outputStream *st) const {
2587   print_on(st);
2588   print_heap_regions_on(st);
2589 }
2590 
2591 bool ShenandoahHeap::is_bitmap_slice_committed(ShenandoahHeapRegion* r, bool skip_self) {
2592   size_t slice = r-&gt;region_number() / _bitmap_regions_per_slice;
2593 
2594   size_t regions_from = _bitmap_regions_per_slice * slice;
2595   size_t regions_to   = MIN2(num_regions(), _bitmap_regions_per_slice * (slice + 1));
2596   for (size_t g = regions_from; g &lt; regions_to; g++) {
2597     assert (g / _bitmap_regions_per_slice == slice, &quot;same slice&quot;);
2598     if (skip_self &amp;&amp; g == r-&gt;region_number()) continue;
2599     if (get_region(g)-&gt;is_committed()) {
2600       return true;
2601     }
2602   }
2603   return false;
2604 }
2605 
2606 bool ShenandoahHeap::commit_bitmap_slice(ShenandoahHeapRegion* r) {
<a name="47" id="anc47"></a><span class="line-modified">2607   assert_heaplock_owned_by_current_thread();</span>
2608 
2609   // Bitmaps in special regions do not need commits
2610   if (_bitmap_region_special) {
2611     return true;
2612   }
2613 
2614   if (is_bitmap_slice_committed(r, true)) {
2615     // Some other region from the group is already committed, meaning the bitmap
2616     // slice is already committed, we exit right away.
2617     return true;
2618   }
2619 
2620   // Commit the bitmap slice:
2621   size_t slice = r-&gt;region_number() / _bitmap_regions_per_slice;
2622   size_t off = _bitmap_bytes_per_slice * slice;
2623   size_t len = _bitmap_bytes_per_slice;
2624   if (!os::commit_memory((char*)_bitmap_region.start() + off, len, false)) {
2625     return false;
2626   }
2627   return true;
2628 }
2629 
2630 bool ShenandoahHeap::uncommit_bitmap_slice(ShenandoahHeapRegion *r) {
<a name="48" id="anc48"></a><span class="line-modified">2631   assert_heaplock_owned_by_current_thread();</span>
2632 
2633   // Bitmaps in special regions do not need uncommits
2634   if (_bitmap_region_special) {
2635     return true;
2636   }
2637 
2638   if (is_bitmap_slice_committed(r, true)) {
2639     // Some other region from the group is still committed, meaning the bitmap
2640     // slice is should stay committed, exit right away.
2641     return true;
2642   }
2643 
2644   // Uncommit the bitmap slice:
2645   size_t slice = r-&gt;region_number() / _bitmap_regions_per_slice;
2646   size_t off = _bitmap_bytes_per_slice * slice;
2647   size_t len = _bitmap_bytes_per_slice;
2648   if (!os::uncommit_memory((char*)_bitmap_region.start() + off, len)) {
2649     return false;
2650   }
2651   return true;
2652 }
2653 
2654 void ShenandoahHeap::safepoint_synchronize_begin() {
2655   if (ShenandoahSuspendibleWorkers || UseStringDeduplication) {
2656     SuspendibleThreadSet::synchronize();
2657   }
2658 }
2659 
2660 void ShenandoahHeap::safepoint_synchronize_end() {
2661   if (ShenandoahSuspendibleWorkers || UseStringDeduplication) {
2662     SuspendibleThreadSet::desynchronize();
2663   }
2664 }
2665 
2666 void ShenandoahHeap::vmop_entry_init_mark() {
2667   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2668   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2669   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_mark_gross);
2670 
2671   try_inject_alloc_failure();
2672   VM_ShenandoahInitMark op;
2673   VMThread::execute(&amp;op); // jump to entry_init_mark() under safepoint
2674 }
2675 
2676 void ShenandoahHeap::vmop_entry_final_mark() {
2677   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2678   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2679   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_mark_gross);
2680 
2681   try_inject_alloc_failure();
2682   VM_ShenandoahFinalMarkStartEvac op;
2683   VMThread::execute(&amp;op); // jump to entry_final_mark under safepoint
2684 }
2685 
<a name="49" id="anc49"></a><span class="line-removed">2686 void ShenandoahHeap::vmop_entry_final_evac() {</span>
<span class="line-removed">2687   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());</span>
<span class="line-removed">2688   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);</span>
<span class="line-removed">2689   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_evac_gross);</span>
<span class="line-removed">2690 </span>
<span class="line-removed">2691   VM_ShenandoahFinalEvac op;</span>
<span class="line-removed">2692   VMThread::execute(&amp;op); // jump to entry_final_evac under safepoint</span>
<span class="line-removed">2693 }</span>
<span class="line-removed">2694 </span>
2695 void ShenandoahHeap::vmop_entry_init_updaterefs() {
2696   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2697   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2698   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_gross);
2699 
2700   try_inject_alloc_failure();
2701   VM_ShenandoahInitUpdateRefs op;
2702   VMThread::execute(&amp;op);
2703 }
2704 
2705 void ShenandoahHeap::vmop_entry_final_updaterefs() {
2706   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2707   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2708   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_gross);
2709 
2710   try_inject_alloc_failure();
2711   VM_ShenandoahFinalUpdateRefs op;
2712   VMThread::execute(&amp;op);
2713 }
2714 
2715 void ShenandoahHeap::vmop_entry_init_traversal() {
2716   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2717   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2718   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_traversal_gc_gross);
2719 
2720   try_inject_alloc_failure();
2721   VM_ShenandoahInitTraversalGC op;
2722   VMThread::execute(&amp;op);
2723 }
2724 
2725 void ShenandoahHeap::vmop_entry_final_traversal() {
2726   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2727   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2728   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_traversal_gc_gross);
2729 
2730   try_inject_alloc_failure();
2731   VM_ShenandoahFinalTraversalGC op;
2732   VMThread::execute(&amp;op);
2733 }
2734 
2735 void ShenandoahHeap::vmop_entry_full(GCCause::Cause cause) {
2736   TraceCollectorStats tcs(monitoring_support()-&gt;full_stw_collection_counters());
2737   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2738   ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_gross);
2739 
2740   try_inject_alloc_failure();
2741   VM_ShenandoahFullGC op(cause);
2742   VMThread::execute(&amp;op);
2743 }
2744 
2745 void ShenandoahHeap::vmop_degenerated(ShenandoahDegenPoint point) {
2746   TraceCollectorStats tcs(monitoring_support()-&gt;full_stw_collection_counters());
2747   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2748   ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc_gross);
2749 
2750   VM_ShenandoahDegeneratedGC degenerated_gc((int)point);
2751   VMThread::execute(&amp;degenerated_gc);
2752 }
2753 
2754 void ShenandoahHeap::entry_init_mark() {
2755   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2756   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_mark);
2757   const char* msg = init_mark_event_message();
2758   GCTraceTime(Info, gc) time(msg, gc_timer());
2759   EventMark em(&quot;%s&quot;, msg);
2760 
2761   ShenandoahWorkerScope scope(workers(),
2762                               ShenandoahWorkerPolicy::calc_workers_for_init_marking(),
2763                               &quot;init marking&quot;);
2764 
2765   op_init_mark();
2766 }
2767 
2768 void ShenandoahHeap::entry_final_mark() {
2769   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2770   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_mark);
2771   const char* msg = final_mark_event_message();
2772   GCTraceTime(Info, gc) time(msg, gc_timer());
2773   EventMark em(&quot;%s&quot;, msg);
2774 
2775   ShenandoahWorkerScope scope(workers(),
2776                               ShenandoahWorkerPolicy::calc_workers_for_final_marking(),
2777                               &quot;final marking&quot;);
2778 
2779   op_final_mark();
2780 }
2781 
<a name="50" id="anc50"></a><span class="line-removed">2782 void ShenandoahHeap::entry_final_evac() {</span>
<span class="line-removed">2783   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);</span>
<span class="line-removed">2784   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_evac);</span>
<span class="line-removed">2785   static const char* msg = &quot;Pause Final Evac&quot;;</span>
<span class="line-removed">2786   GCTraceTime(Info, gc) time(msg, gc_timer());</span>
<span class="line-removed">2787   EventMark em(&quot;%s&quot;, msg);</span>
<span class="line-removed">2788 </span>
<span class="line-removed">2789   op_final_evac();</span>
<span class="line-removed">2790 }</span>
<span class="line-removed">2791 </span>
2792 void ShenandoahHeap::entry_init_updaterefs() {
2793   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2794   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs);
2795 
2796   static const char* msg = &quot;Pause Init Update Refs&quot;;
2797   GCTraceTime(Info, gc) time(msg, gc_timer());
2798   EventMark em(&quot;%s&quot;, msg);
2799 
2800   // No workers used in this phase, no setup required
2801 
2802   op_init_updaterefs();
2803 }
2804 
2805 void ShenandoahHeap::entry_final_updaterefs() {
2806   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2807   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs);
2808 
2809   static const char* msg = &quot;Pause Final Update Refs&quot;;
2810   GCTraceTime(Info, gc) time(msg, gc_timer());
2811   EventMark em(&quot;%s&quot;, msg);
2812 
2813   ShenandoahWorkerScope scope(workers(),
2814                               ShenandoahWorkerPolicy::calc_workers_for_final_update_ref(),
2815                               &quot;final reference update&quot;);
2816 
2817   op_final_updaterefs();
2818 }
2819 
2820 void ShenandoahHeap::entry_init_traversal() {
2821   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2822   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_traversal_gc);
2823 
2824   static const char* msg = init_traversal_event_message();
2825   GCTraceTime(Info, gc) time(msg, gc_timer());
2826   EventMark em(&quot;%s&quot;, msg);
2827 
2828   ShenandoahWorkerScope scope(workers(),
2829                               ShenandoahWorkerPolicy::calc_workers_for_stw_traversal(),
2830                               &quot;init traversal&quot;);
2831 
2832   op_init_traversal();
2833 }
2834 
2835 void ShenandoahHeap::entry_final_traversal() {
2836   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2837   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_traversal_gc);
2838 
2839   static const char* msg = final_traversal_event_message();
2840   GCTraceTime(Info, gc) time(msg, gc_timer());
2841   EventMark em(&quot;%s&quot;, msg);
2842 
2843   ShenandoahWorkerScope scope(workers(),
2844                               ShenandoahWorkerPolicy::calc_workers_for_stw_traversal(),
2845                               &quot;final traversal&quot;);
2846 
2847   op_final_traversal();
2848 }
2849 
2850 void ShenandoahHeap::entry_full(GCCause::Cause cause) {
2851   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2852   ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc);
2853 
2854   static const char* msg = &quot;Pause Full&quot;;
2855   GCTraceTime(Info, gc) time(msg, gc_timer(), cause, true);
2856   EventMark em(&quot;%s&quot;, msg);
2857 
2858   ShenandoahWorkerScope scope(workers(),
2859                               ShenandoahWorkerPolicy::calc_workers_for_fullgc(),
2860                               &quot;full gc&quot;);
2861 
2862   op_full(cause);
2863 }
2864 
2865 void ShenandoahHeap::entry_degenerated(int point) {
2866   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2867   ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc);
2868 
2869   ShenandoahDegenPoint dpoint = (ShenandoahDegenPoint)point;
2870   const char* msg = degen_event_message(dpoint);
2871   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2872   EventMark em(&quot;%s&quot;, msg);
2873 
2874   ShenandoahWorkerScope scope(workers(),
2875                               ShenandoahWorkerPolicy::calc_workers_for_stw_degenerated(),
2876                               &quot;stw degenerated gc&quot;);
2877 
2878   set_degenerated_gc_in_progress(true);
2879   op_degenerated(dpoint);
2880   set_degenerated_gc_in_progress(false);
2881 }
2882 
2883 void ShenandoahHeap::entry_mark() {
2884   TraceCollectorStats tcs(monitoring_support()-&gt;concurrent_collection_counters());
2885 
2886   const char* msg = conc_mark_event_message();
2887   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2888   EventMark em(&quot;%s&quot;, msg);
2889 
2890   ShenandoahWorkerScope scope(workers(),
2891                               ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),
2892                               &quot;concurrent marking&quot;);
2893 
2894   try_inject_alloc_failure();
2895   op_mark();
2896 }
2897 
2898 void ShenandoahHeap::entry_evac() {
2899   ShenandoahGCPhase conc_evac_phase(ShenandoahPhaseTimings::conc_evac);
2900   TraceCollectorStats tcs(monitoring_support()-&gt;concurrent_collection_counters());
2901 
2902   static const char* msg = &quot;Concurrent evacuation&quot;;
2903   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2904   EventMark em(&quot;%s&quot;, msg);
2905 
2906   ShenandoahWorkerScope scope(workers(),
2907                               ShenandoahWorkerPolicy::calc_workers_for_conc_evac(),
2908                               &quot;concurrent evacuation&quot;);
2909 
2910   try_inject_alloc_failure();
2911   op_conc_evac();
2912 }
2913 
2914 void ShenandoahHeap::entry_updaterefs() {
2915   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_update_refs);
2916 
2917   static const char* msg = &quot;Concurrent update references&quot;;
2918   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2919   EventMark em(&quot;%s&quot;, msg);
2920 
2921   ShenandoahWorkerScope scope(workers(),
2922                               ShenandoahWorkerPolicy::calc_workers_for_conc_update_ref(),
2923                               &quot;concurrent reference update&quot;);
2924 
2925   try_inject_alloc_failure();
2926   op_updaterefs();
2927 }
2928 
2929 void ShenandoahHeap::entry_roots() {
2930   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_roots);
2931 
2932   static const char* msg = &quot;Concurrent roots processing&quot;;
2933   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2934   EventMark em(&quot;%s&quot;, msg);
2935 
2936   ShenandoahWorkerScope scope(workers(),
2937                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),
2938                               &quot;concurrent root processing&quot;);
2939 
2940   try_inject_alloc_failure();
2941   op_roots();
2942 }
2943 
2944 void ShenandoahHeap::entry_cleanup() {
2945   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_cleanup);
2946 
2947   static const char* msg = &quot;Concurrent cleanup&quot;;
2948   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2949   EventMark em(&quot;%s&quot;, msg);
2950 
2951   // This phase does not use workers, no need for setup
2952 
2953   try_inject_alloc_failure();
2954   op_cleanup();
2955 }
2956 
2957 void ShenandoahHeap::entry_reset() {
2958   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_reset);
2959 
2960   static const char* msg = &quot;Concurrent reset&quot;;
2961   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2962   EventMark em(&quot;%s&quot;, msg);
2963 
2964   ShenandoahWorkerScope scope(workers(),
2965                               ShenandoahWorkerPolicy::calc_workers_for_conc_reset(),
2966                               &quot;concurrent reset&quot;);
2967 
2968   try_inject_alloc_failure();
2969   op_reset();
2970 }
2971 
2972 void ShenandoahHeap::entry_preclean() {
2973   if (ShenandoahPreclean &amp;&amp; process_references()) {
2974     static const char* msg = &quot;Concurrent precleaning&quot;;
2975     GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2976     EventMark em(&quot;%s&quot;, msg);
2977 
2978     ShenandoahGCPhase conc_preclean(ShenandoahPhaseTimings::conc_preclean);
2979 
2980     ShenandoahWorkerScope scope(workers(),
2981                                 ShenandoahWorkerPolicy::calc_workers_for_conc_preclean(),
2982                                 &quot;concurrent preclean&quot;,
2983                                 /* check_workers = */ false);
2984 
2985     try_inject_alloc_failure();
2986     op_preclean();
2987   }
2988 }
2989 
2990 void ShenandoahHeap::entry_traversal() {
2991   static const char* msg = conc_traversal_event_message();
2992   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2993   EventMark em(&quot;%s&quot;, msg);
2994 
2995   TraceCollectorStats tcs(monitoring_support()-&gt;concurrent_collection_counters());
2996 
2997   ShenandoahWorkerScope scope(workers(),
2998                               ShenandoahWorkerPolicy::calc_workers_for_conc_traversal(),
2999                               &quot;concurrent traversal&quot;);
3000 
3001   try_inject_alloc_failure();
3002   op_traversal();
3003 }
3004 
3005 void ShenandoahHeap::entry_uncommit(double shrink_before) {
3006   static const char *msg = &quot;Concurrent uncommit&quot;;
3007   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
3008   EventMark em(&quot;%s&quot;, msg);
3009 
3010   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_uncommit);
3011 
3012   op_uncommit(shrink_before);
3013 }
3014 
3015 void ShenandoahHeap::try_inject_alloc_failure() {
3016   if (ShenandoahAllocFailureALot &amp;&amp; !cancelled_gc() &amp;&amp; ((os::random() % 1000) &gt; 950)) {
3017     _inject_alloc_failure.set();
3018     os::naked_short_sleep(1);
3019     if (cancelled_gc()) {
3020       log_info(gc)(&quot;Allocation failure was successfully injected&quot;);
3021     }
3022   }
3023 }
3024 
3025 bool ShenandoahHeap::should_inject_alloc_failure() {
3026   return _inject_alloc_failure.is_set() &amp;&amp; _inject_alloc_failure.try_unset();
3027 }
3028 
3029 void ShenandoahHeap::initialize_serviceability() {
3030   _memory_pool = new ShenandoahMemoryPool(this);
3031   _cycle_memory_manager.add_pool(_memory_pool);
3032   _stw_memory_manager.add_pool(_memory_pool);
3033 }
3034 
3035 GrowableArray&lt;GCMemoryManager*&gt; ShenandoahHeap::memory_managers() {
3036   GrowableArray&lt;GCMemoryManager*&gt; memory_managers(2);
3037   memory_managers.append(&amp;_cycle_memory_manager);
3038   memory_managers.append(&amp;_stw_memory_manager);
3039   return memory_managers;
3040 }
3041 
3042 GrowableArray&lt;MemoryPool*&gt; ShenandoahHeap::memory_pools() {
3043   GrowableArray&lt;MemoryPool*&gt; memory_pools(1);
3044   memory_pools.append(_memory_pool);
3045   return memory_pools;
3046 }
3047 
3048 MemoryUsage ShenandoahHeap::memory_usage() {
3049   return _memory_pool-&gt;get_memory_usage();
3050 }
3051 
3052 void ShenandoahHeap::enter_evacuation() {
3053   _oom_evac_handler.enter_evacuation();
3054 }
3055 
3056 void ShenandoahHeap::leave_evacuation() {
3057   _oom_evac_handler.leave_evacuation();
3058 }
3059 
3060 ShenandoahRegionIterator::ShenandoahRegionIterator() :
3061   _heap(ShenandoahHeap::heap()),
3062   _index(0) {}
3063 
3064 ShenandoahRegionIterator::ShenandoahRegionIterator(ShenandoahHeap* heap) :
3065   _heap(heap),
3066   _index(0) {}
3067 
3068 void ShenandoahRegionIterator::reset() {
3069   _index = 0;
3070 }
3071 
3072 bool ShenandoahRegionIterator::has_next() const {
3073   return _index &lt; _heap-&gt;num_regions();
3074 }
3075 
3076 char ShenandoahHeap::gc_state() const {
3077   return _gc_state.raw_value();
3078 }
3079 
3080 void ShenandoahHeap::deduplicate_string(oop str) {
3081   assert(java_lang_String::is_instance(str), &quot;invariant&quot;);
3082 
3083   if (ShenandoahStringDedup::is_enabled()) {
3084     ShenandoahStringDedup::deduplicate(str);
3085   }
3086 }
3087 
3088 const char* ShenandoahHeap::init_mark_event_message() const {
<a name="51" id="anc51"></a><span class="line-modified">3089   bool update_refs = has_forwarded_objects();</span>

3090   bool proc_refs = process_references();
3091   bool unload_cls = unload_classes();
3092 
<a name="52" id="anc52"></a><span class="line-modified">3093   if (update_refs &amp;&amp; proc_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3094     return &quot;Pause Init Mark (update refs) (process weakrefs) (unload classes)&quot;;</span>
<span class="line-removed">3095   } else if (update_refs &amp;&amp; proc_refs) {</span>
<span class="line-removed">3096     return &quot;Pause Init Mark (update refs) (process weakrefs)&quot;;</span>
<span class="line-removed">3097   } else if (update_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3098     return &quot;Pause Init Mark (update refs) (unload classes)&quot;;</span>
<span class="line-removed">3099   } else if (proc_refs &amp;&amp; unload_cls) {</span>
3100     return &quot;Pause Init Mark (process weakrefs) (unload classes)&quot;;
<a name="53" id="anc53"></a><span class="line-removed">3101   } else if (update_refs) {</span>
<span class="line-removed">3102     return &quot;Pause Init Mark (update refs)&quot;;</span>
3103   } else if (proc_refs) {
3104     return &quot;Pause Init Mark (process weakrefs)&quot;;
3105   } else if (unload_cls) {
3106     return &quot;Pause Init Mark (unload classes)&quot;;
3107   } else {
3108     return &quot;Pause Init Mark&quot;;
3109   }
3110 }
3111 
3112 const char* ShenandoahHeap::final_mark_event_message() const {
<a name="54" id="anc54"></a><span class="line-modified">3113   bool update_refs = has_forwarded_objects();</span>

3114   bool proc_refs = process_references();
3115   bool unload_cls = unload_classes();
3116 
<a name="55" id="anc55"></a><span class="line-modified">3117   if (update_refs &amp;&amp; proc_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3118     return &quot;Pause Final Mark (update refs) (process weakrefs) (unload classes)&quot;;</span>
<span class="line-removed">3119   } else if (update_refs &amp;&amp; proc_refs) {</span>
<span class="line-removed">3120     return &quot;Pause Final Mark (update refs) (process weakrefs)&quot;;</span>
<span class="line-removed">3121   } else if (update_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3122     return &quot;Pause Final Mark (update refs) (unload classes)&quot;;</span>
<span class="line-removed">3123   } else if (proc_refs &amp;&amp; unload_cls) {</span>
3124     return &quot;Pause Final Mark (process weakrefs) (unload classes)&quot;;
<a name="56" id="anc56"></a><span class="line-removed">3125   } else if (update_refs) {</span>
<span class="line-removed">3126     return &quot;Pause Final Mark (update refs)&quot;;</span>
3127   } else if (proc_refs) {
3128     return &quot;Pause Final Mark (process weakrefs)&quot;;
3129   } else if (unload_cls) {
3130     return &quot;Pause Final Mark (unload classes)&quot;;
3131   } else {
3132     return &quot;Pause Final Mark&quot;;
3133   }
3134 }
3135 
3136 const char* ShenandoahHeap::conc_mark_event_message() const {
<a name="57" id="anc57"></a><span class="line-modified">3137   bool update_refs = has_forwarded_objects();</span>

3138   bool proc_refs = process_references();
3139   bool unload_cls = unload_classes();
3140 
<a name="58" id="anc58"></a><span class="line-modified">3141   if (update_refs &amp;&amp; proc_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3142     return &quot;Concurrent marking (update refs) (process weakrefs) (unload classes)&quot;;</span>
<span class="line-removed">3143   } else if (update_refs &amp;&amp; proc_refs) {</span>
<span class="line-removed">3144     return &quot;Concurrent marking (update refs) (process weakrefs)&quot;;</span>
<span class="line-removed">3145   } else if (update_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3146     return &quot;Concurrent marking (update refs) (unload classes)&quot;;</span>
<span class="line-removed">3147   } else if (proc_refs &amp;&amp; unload_cls) {</span>
3148     return &quot;Concurrent marking (process weakrefs) (unload classes)&quot;;
<a name="59" id="anc59"></a><span class="line-removed">3149   } else if (update_refs) {</span>
<span class="line-removed">3150     return &quot;Concurrent marking (update refs)&quot;;</span>
3151   } else if (proc_refs) {
3152     return &quot;Concurrent marking (process weakrefs)&quot;;
3153   } else if (unload_cls) {
3154     return &quot;Concurrent marking (unload classes)&quot;;
3155   } else {
3156     return &quot;Concurrent marking&quot;;
3157   }
3158 }
3159 
3160 const char* ShenandoahHeap::init_traversal_event_message() const {
3161   bool proc_refs = process_references();
3162   bool unload_cls = unload_classes();
3163 
3164   if (proc_refs &amp;&amp; unload_cls) {
3165     return &quot;Pause Init Traversal (process weakrefs) (unload classes)&quot;;
3166   } else if (proc_refs) {
3167     return &quot;Pause Init Traversal (process weakrefs)&quot;;
3168   } else if (unload_cls) {
3169     return &quot;Pause Init Traversal (unload classes)&quot;;
3170   } else {
3171     return &quot;Pause Init Traversal&quot;;
3172   }
3173 }
3174 
3175 const char* ShenandoahHeap::final_traversal_event_message() const {
3176   bool proc_refs = process_references();
3177   bool unload_cls = unload_classes();
3178 
3179   if (proc_refs &amp;&amp; unload_cls) {
3180     return &quot;Pause Final Traversal (process weakrefs) (unload classes)&quot;;
3181   } else if (proc_refs) {
3182     return &quot;Pause Final Traversal (process weakrefs)&quot;;
3183   } else if (unload_cls) {
3184     return &quot;Pause Final Traversal (unload classes)&quot;;
3185   } else {
3186     return &quot;Pause Final Traversal&quot;;
3187   }
3188 }
3189 
3190 const char* ShenandoahHeap::conc_traversal_event_message() const {
3191   bool proc_refs = process_references();
3192   bool unload_cls = unload_classes();
3193 
3194   if (proc_refs &amp;&amp; unload_cls) {
3195     return &quot;Concurrent Traversal (process weakrefs) (unload classes)&quot;;
3196   } else if (proc_refs) {
3197     return &quot;Concurrent Traversal (process weakrefs)&quot;;
3198   } else if (unload_cls) {
3199     return &quot;Concurrent Traversal (unload classes)&quot;;
3200   } else {
3201     return &quot;Concurrent Traversal&quot;;
3202   }
3203 }
3204 
3205 const char* ShenandoahHeap::degen_event_message(ShenandoahDegenPoint point) const {
3206   switch (point) {
3207     case _degenerated_unset:
3208       return &quot;Pause Degenerated GC (&lt;UNSET&gt;)&quot;;
3209     case _degenerated_traversal:
3210       return &quot;Pause Degenerated GC (Traversal)&quot;;
3211     case _degenerated_outside_cycle:
3212       return &quot;Pause Degenerated GC (Outside of Cycle)&quot;;
3213     case _degenerated_mark:
3214       return &quot;Pause Degenerated GC (Mark)&quot;;
3215     case _degenerated_evac:
3216       return &quot;Pause Degenerated GC (Evacuation)&quot;;
3217     case _degenerated_updaterefs:
3218       return &quot;Pause Degenerated GC (Update Refs)&quot;;
3219     default:
3220       ShouldNotReachHere();
3221       return &quot;ERROR&quot;;
3222   }
3223 }
3224 
3225 jushort* ShenandoahHeap::get_liveness_cache(uint worker_id) {
3226 #ifdef ASSERT
3227   assert(_liveness_cache != NULL, &quot;sanity&quot;);
3228   assert(worker_id &lt; _max_workers, &quot;sanity&quot;);
3229   for (uint i = 0; i &lt; num_regions(); i++) {
3230     assert(_liveness_cache[worker_id][i] == 0, &quot;liveness cache should be empty&quot;);
3231   }
3232 #endif
3233   return _liveness_cache[worker_id];
3234 }
3235 
3236 void ShenandoahHeap::flush_liveness_cache(uint worker_id) {
3237   assert(worker_id &lt; _max_workers, &quot;sanity&quot;);
3238   assert(_liveness_cache != NULL, &quot;sanity&quot;);
3239   jushort* ld = _liveness_cache[worker_id];
3240   for (uint i = 0; i &lt; num_regions(); i++) {
3241     ShenandoahHeapRegion* r = get_region(i);
3242     jushort live = ld[i];
3243     if (live &gt; 0) {
3244       r-&gt;increase_live_data_gc_words(live);
3245       ld[i] = 0;
3246     }
3247   }
3248 }
<a name="60" id="anc60"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="60" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2013, 2019, Red Hat, Inc. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.hpp&quot;
 27 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;
 32 #include &quot;gc/shared/space.inline.hpp&quot;
 33 #include &quot;jfr/jfrEvents.hpp&quot;
 34 #include &quot;memory/iterator.inline.hpp&quot;
 35 #include &quot;memory/resourceArea.hpp&quot;
 36 #include &quot;memory/universe.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;runtime/atomic.hpp&quot;
 39 #include &quot;runtime/java.hpp&quot;
 40 #include &quot;runtime/mutexLocker.hpp&quot;
 41 #include &quot;runtime/os.hpp&quot;
 42 #include &quot;runtime/safepoint.hpp&quot;
 43 
 44 size_t ShenandoahHeapRegion::RegionCount = 0;
 45 size_t ShenandoahHeapRegion::RegionSizeBytes = 0;
 46 size_t ShenandoahHeapRegion::RegionSizeWords = 0;
 47 size_t ShenandoahHeapRegion::RegionSizeBytesShift = 0;
 48 size_t ShenandoahHeapRegion::RegionSizeWordsShift = 0;
 49 size_t ShenandoahHeapRegion::RegionSizeBytesMask = 0;
 50 size_t ShenandoahHeapRegion::RegionSizeWordsMask = 0;
 51 size_t ShenandoahHeapRegion::HumongousThresholdBytes = 0;
 52 size_t ShenandoahHeapRegion::HumongousThresholdWords = 0;
 53 size_t ShenandoahHeapRegion::MaxTLABSizeBytes = 0;
 54 size_t ShenandoahHeapRegion::MaxTLABSizeWords = 0;
 55 
 56 ShenandoahHeapRegion::PaddedAllocSeqNum ShenandoahHeapRegion::_alloc_seq_num;
 57 
<a name="1" id="anc1"></a><span class="line-modified"> 58 ShenandoahHeapRegion::ShenandoahHeapRegion(HeapWord* start, size_t index, bool committed) :</span>



 59   _region_number(index),
<a name="2" id="anc2"></a><span class="line-added"> 60   _bottom(start),</span>
<span class="line-added"> 61   _end(start + RegionSizeWords),</span>
 62   _new_top(NULL),
 63   _empty_time(os::elapsedTime()),
 64   _state(committed ? _empty_committed : _empty_uncommitted),
<a name="3" id="anc3"></a><span class="line-added"> 65   _top(start),</span>
 66   _tlab_allocs(0),
 67   _gclab_allocs(0),
 68   _shared_allocs(0),
<a name="4" id="anc4"></a>

 69   _seqnum_last_alloc_mutator(0),
<a name="5" id="anc5"></a>
 70   _live_data(0),
<a name="6" id="anc6"></a><span class="line-modified"> 71   _critical_pins(0),</span>
<span class="line-added"> 72   _update_watermark(start) {</span>
 73 
<a name="7" id="anc7"></a><span class="line-modified"> 74   assert(Universe::on_page_boundary(_bottom) &amp;&amp; Universe::on_page_boundary(_end),</span>
<span class="line-added"> 75          &quot;invalid space boundaries&quot;);</span>
<span class="line-added"> 76   if (ZapUnusedHeapArea &amp;&amp; committed) {</span>
<span class="line-added"> 77     SpaceMangler::mangle_region(MemRegion(_bottom, _end));</span>
<span class="line-added"> 78   }</span>
 79 }
 80 
 81 size_t ShenandoahHeapRegion::region_number() const {
 82   return _region_number;
 83 }
 84 
 85 void ShenandoahHeapRegion::report_illegal_transition(const char *method) {
 86   ResourceMark rm;
 87   stringStream ss;
 88   ss.print(&quot;Illegal region state transition from \&quot;%s\&quot;, at %s\n  &quot;, region_state_to_string(_state), method);
 89   print_on(&amp;ss);
 90   fatal(&quot;%s&quot;, ss.as_string());
 91 }
 92 
 93 void ShenandoahHeapRegion::make_regular_allocation() {
<a name="8" id="anc8"></a><span class="line-modified"> 94   shenandoah_assert_heaplocked();</span>
 95 
 96   switch (_state) {
 97     case _empty_uncommitted:
 98       do_commit();
 99     case _empty_committed:
100       set_state(_regular);
101     case _regular:
102     case _pinned:
103       return;
104     default:
105       report_illegal_transition(&quot;regular allocation&quot;);
106   }
107 }
108 
109 void ShenandoahHeapRegion::make_regular_bypass() {
<a name="9" id="anc9"></a><span class="line-modified">110   shenandoah_assert_heaplocked();</span>
<span class="line-modified">111   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress() || ShenandoahHeap::heap()-&gt;is_degenerated_gc_in_progress(),</span>
112           &quot;only for full or degen GC&quot;);
113 
114   switch (_state) {
115     case _empty_uncommitted:
116       do_commit();
117     case _empty_committed:
118     case _cset:
119     case _humongous_start:
120     case _humongous_cont:
121       set_state(_regular);
122       return;
123     case _pinned_cset:
124       set_state(_pinned);
125       return;
126     case _regular:
127     case _pinned:
128       return;
129     default:
130       report_illegal_transition(&quot;regular bypass&quot;);
131   }
132 }
133 
134 void ShenandoahHeapRegion::make_humongous_start() {
<a name="10" id="anc10"></a><span class="line-modified">135   shenandoah_assert_heaplocked();</span>
136   switch (_state) {
137     case _empty_uncommitted:
138       do_commit();
139     case _empty_committed:
140       set_state(_humongous_start);
141       return;
142     default:
143       report_illegal_transition(&quot;humongous start allocation&quot;);
144   }
145 }
146 
147 void ShenandoahHeapRegion::make_humongous_start_bypass() {
<a name="11" id="anc11"></a><span class="line-modified">148   shenandoah_assert_heaplocked();</span>
<span class="line-modified">149   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
150 
151   switch (_state) {
152     case _empty_committed:
153     case _regular:
154     case _humongous_start:
155     case _humongous_cont:
156       set_state(_humongous_start);
157       return;
158     default:
159       report_illegal_transition(&quot;humongous start bypass&quot;);
160   }
161 }
162 
163 void ShenandoahHeapRegion::make_humongous_cont() {
<a name="12" id="anc12"></a><span class="line-modified">164   shenandoah_assert_heaplocked();</span>
165   switch (_state) {
166     case _empty_uncommitted:
167       do_commit();
168     case _empty_committed:
169      set_state(_humongous_cont);
170       return;
171     default:
172       report_illegal_transition(&quot;humongous continuation allocation&quot;);
173   }
174 }
175 
176 void ShenandoahHeapRegion::make_humongous_cont_bypass() {
<a name="13" id="anc13"></a><span class="line-modified">177   shenandoah_assert_heaplocked();</span>
<span class="line-modified">178   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
179 
180   switch (_state) {
181     case _empty_committed:
182     case _regular:
183     case _humongous_start:
184     case _humongous_cont:
185       set_state(_humongous_cont);
186       return;
187     default:
188       report_illegal_transition(&quot;humongous continuation bypass&quot;);
189   }
190 }
191 
192 void ShenandoahHeapRegion::make_pinned() {
<a name="14" id="anc14"></a><span class="line-modified">193   shenandoah_assert_heaplocked();</span>
194   assert(pin_count() &gt; 0, &quot;Should have pins: &quot; SIZE_FORMAT, pin_count());
195 
196   switch (_state) {
197     case _regular:
198       set_state(_pinned);
199     case _pinned_cset:
200     case _pinned:
201       return;
202     case _humongous_start:
203       set_state(_pinned_humongous_start);
204     case _pinned_humongous_start:
205       return;
206     case _cset:
207       _state = _pinned_cset;
208       return;
209     default:
210       report_illegal_transition(&quot;pinning&quot;);
211   }
212 }
213 
214 void ShenandoahHeapRegion::make_unpinned() {
<a name="15" id="anc15"></a><span class="line-modified">215   shenandoah_assert_heaplocked();</span>
216   assert(pin_count() == 0, &quot;Should not have pins: &quot; SIZE_FORMAT, pin_count());
217 
218   switch (_state) {
219     case _pinned:
220       set_state(_regular);
221       return;
222     case _regular:
223     case _humongous_start:
224       return;
225     case _pinned_cset:
226       set_state(_cset);
227       return;
228     case _pinned_humongous_start:
229       set_state(_humongous_start);
230       return;
231     default:
232       report_illegal_transition(&quot;unpinning&quot;);
233   }
234 }
235 
236 void ShenandoahHeapRegion::make_cset() {
<a name="16" id="anc16"></a><span class="line-modified">237   shenandoah_assert_heaplocked();</span>
238   switch (_state) {
239     case _regular:
240       set_state(_cset);
241     case _cset:
242       return;
243     default:
244       report_illegal_transition(&quot;cset&quot;);
245   }
246 }
247 
248 void ShenandoahHeapRegion::make_trash() {
<a name="17" id="anc17"></a><span class="line-modified">249   shenandoah_assert_heaplocked();</span>
250   switch (_state) {
251     case _cset:
252       // Reclaiming cset regions
253     case _humongous_start:
254     case _humongous_cont:
255       // Reclaiming humongous regions
256     case _regular:
257       // Immediate region reclaim
258       set_state(_trash);
259       return;
260     default:
261       report_illegal_transition(&quot;trashing&quot;);
262   }
263 }
264 
265 void ShenandoahHeapRegion::make_trash_immediate() {
266   make_trash();
267 
268   // On this path, we know there are no marked objects in the region,
269   // tell marking context about it to bypass bitmap resets.
<a name="18" id="anc18"></a><span class="line-modified">270   ShenandoahHeap::heap()-&gt;complete_marking_context()-&gt;reset_top_bitmap(this);</span>
271 }
272 
273 void ShenandoahHeapRegion::make_empty() {
<a name="19" id="anc19"></a><span class="line-modified">274   shenandoah_assert_heaplocked();</span>
275   switch (_state) {
276     case _trash:
277       set_state(_empty_committed);
278       _empty_time = os::elapsedTime();
279       return;
280     default:
281       report_illegal_transition(&quot;emptying&quot;);
282   }
283 }
284 
285 void ShenandoahHeapRegion::make_uncommitted() {
<a name="20" id="anc20"></a><span class="line-modified">286   shenandoah_assert_heaplocked();</span>
287   switch (_state) {
288     case _empty_committed:
289       do_uncommit();
290       set_state(_empty_uncommitted);
291       return;
292     default:
293       report_illegal_transition(&quot;uncommiting&quot;);
294   }
295 }
296 
297 void ShenandoahHeapRegion::make_committed_bypass() {
<a name="21" id="anc21"></a><span class="line-modified">298   shenandoah_assert_heaplocked();</span>
<span class="line-modified">299   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
300 
301   switch (_state) {
302     case _empty_uncommitted:
303       do_commit();
304       set_state(_empty_committed);
305       return;
306     default:
307       report_illegal_transition(&quot;commit bypass&quot;);
308   }
309 }
310 
311 void ShenandoahHeapRegion::clear_live_data() {
312   Atomic::release_store_fence(&amp;_live_data, (size_t)0);
313 }
314 
315 void ShenandoahHeapRegion::reset_alloc_metadata() {
316   _tlab_allocs = 0;
317   _gclab_allocs = 0;
318   _shared_allocs = 0;
<a name="22" id="anc22"></a>
319   _seqnum_last_alloc_mutator = 0;
<a name="23" id="anc23"></a>

320 }
321 
322 void ShenandoahHeapRegion::reset_alloc_metadata_to_shared() {
323   if (used() &gt; 0) {
324     _tlab_allocs = 0;
325     _gclab_allocs = 0;
326     _shared_allocs = used() &gt;&gt; LogHeapWordSize;
<a name="24" id="anc24"></a><span class="line-modified">327     if (ShenandoahHeap::heap()-&gt;is_traversal_mode()) {</span>
<span class="line-modified">328       update_seqnum_last_alloc_mutator();</span>
<span class="line-modified">329     }</span>


330   } else {
331     reset_alloc_metadata();
332   }
333 }
334 
<a name="25" id="anc25"></a><span class="line-added">335 void ShenandoahHeapRegion::update_seqnum_last_alloc_mutator() {</span>
<span class="line-added">336   assert(ShenandoahHeap::heap()-&gt;is_traversal_mode(), &quot;Sanity&quot;);</span>
<span class="line-added">337   shenandoah_assert_heaplocked_or_safepoint();</span>
<span class="line-added">338   _seqnum_last_alloc_mutator = _alloc_seq_num.value++;</span>
<span class="line-added">339 }</span>
<span class="line-added">340 </span>
341 size_t ShenandoahHeapRegion::get_shared_allocs() const {
342   return _shared_allocs * HeapWordSize;
343 }
344 
345 size_t ShenandoahHeapRegion::get_tlab_allocs() const {
346   return _tlab_allocs * HeapWordSize;
347 }
348 
349 size_t ShenandoahHeapRegion::get_gclab_allocs() const {
350   return _gclab_allocs * HeapWordSize;
351 }
352 
353 void ShenandoahHeapRegion::set_live_data(size_t s) {
354   assert(Thread::current()-&gt;is_VM_thread(), &quot;by VM thread&quot;);
355   _live_data = (s &gt;&gt; LogHeapWordSize);
356 }
357 
358 size_t ShenandoahHeapRegion::get_live_data_words() const {
359   return Atomic::load_acquire(&amp;_live_data);
360 }
361 
362 size_t ShenandoahHeapRegion::get_live_data_bytes() const {
363   return get_live_data_words() * HeapWordSize;
364 }
365 
366 bool ShenandoahHeapRegion::has_live() const {
367   return get_live_data_words() != 0;
368 }
369 
370 size_t ShenandoahHeapRegion::garbage() const {
371   assert(used() &gt;= get_live_data_bytes(), &quot;Live Data must be a subset of used() live: &quot; SIZE_FORMAT &quot; used: &quot; SIZE_FORMAT,
372          get_live_data_bytes(), used());
373 
374   size_t result = used() - get_live_data_bytes();
375   return result;
376 }
377 
378 void ShenandoahHeapRegion::print_on(outputStream* st) const {
379   st-&gt;print(&quot;|&quot;);
380   st-&gt;print(SIZE_FORMAT_W(5), this-&gt;_region_number);
381 
382   switch (_state) {
383     case _empty_uncommitted:
384       st-&gt;print(&quot;|EU &quot;);
385       break;
386     case _empty_committed:
387       st-&gt;print(&quot;|EC &quot;);
388       break;
389     case _regular:
390       st-&gt;print(&quot;|R  &quot;);
391       break;
392     case _humongous_start:
393       st-&gt;print(&quot;|H  &quot;);
394       break;
395     case _pinned_humongous_start:
396       st-&gt;print(&quot;|HP &quot;);
397       break;
398     case _humongous_cont:
399       st-&gt;print(&quot;|HC &quot;);
400       break;
401     case _cset:
402       st-&gt;print(&quot;|CS &quot;);
403       break;
404     case _trash:
405       st-&gt;print(&quot;|T  &quot;);
406       break;
407     case _pinned:
408       st-&gt;print(&quot;|P  &quot;);
409       break;
410     case _pinned_cset:
411       st-&gt;print(&quot;|CSP&quot;);
412       break;
413     default:
414       ShouldNotReachHere();
415   }
416   st-&gt;print(&quot;|BTE &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12),
417             p2i(bottom()), p2i(top()), p2i(end()));
418   st-&gt;print(&quot;|TAMS &quot; INTPTR_FORMAT_W(12),
<a name="26" id="anc26"></a><span class="line-modified">419             p2i(ShenandoahHeap::heap()-&gt;marking_context()-&gt;top_at_mark_start(const_cast&lt;ShenandoahHeapRegion*&gt;(this))));</span>
<span class="line-added">420   st-&gt;print(&quot;|UWM &quot; INTPTR_FORMAT_W(12),</span>
<span class="line-added">421             p2i(_update_watermark));</span>
422   st-&gt;print(&quot;|U &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(used()),                proper_unit_for_byte_size(used()));
423   st-&gt;print(&quot;|T &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_tlab_allocs()),     proper_unit_for_byte_size(get_tlab_allocs()));
424   st-&gt;print(&quot;|G &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_gclab_allocs()),    proper_unit_for_byte_size(get_gclab_allocs()));
425   st-&gt;print(&quot;|S &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_shared_allocs()),   proper_unit_for_byte_size(get_shared_allocs()));
426   st-&gt;print(&quot;|L &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_live_data_bytes()), proper_unit_for_byte_size(get_live_data_bytes()));
427   st-&gt;print(&quot;|CP &quot; SIZE_FORMAT_W(3), pin_count());
<a name="27" id="anc27"></a><span class="line-modified">428   st-&gt;print(&quot;|SN &quot; UINT64_FORMAT_X_W(12), _seqnum_last_alloc_mutator);</span>


429   st-&gt;cr();
430 }
431 
432 void ShenandoahHeapRegion::oop_iterate(OopIterateClosure* blk) {
433   if (!is_active()) return;
434   if (is_humongous()) {
435     oop_iterate_humongous(blk);
436   } else {
437     oop_iterate_objects(blk);
438   }
439 }
440 
441 void ShenandoahHeapRegion::oop_iterate_objects(OopIterateClosure* blk) {
442   assert(! is_humongous(), &quot;no humongous region here&quot;);
443   HeapWord* obj_addr = bottom();
444   HeapWord* t = top();
445   // Could call objects iterate, but this is easier.
446   while (obj_addr &lt; t) {
447     oop obj = oop(obj_addr);
448     obj_addr += obj-&gt;oop_iterate_size(blk);
449   }
450 }
451 
452 void ShenandoahHeapRegion::oop_iterate_humongous(OopIterateClosure* blk) {
453   assert(is_humongous(), &quot;only humongous region here&quot;);
454   // Find head.
455   ShenandoahHeapRegion* r = humongous_start_region();
456   assert(r-&gt;is_humongous_start(), &quot;need humongous head here&quot;);
457   oop obj = oop(r-&gt;bottom());
458   obj-&gt;oop_iterate(blk, MemRegion(bottom(), top()));
459 }
460 
461 ShenandoahHeapRegion* ShenandoahHeapRegion::humongous_start_region() const {
<a name="28" id="anc28"></a><span class="line-added">462   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
463   assert(is_humongous(), &quot;Must be a part of the humongous region&quot;);
464   size_t reg_num = region_number();
465   ShenandoahHeapRegion* r = const_cast&lt;ShenandoahHeapRegion*&gt;(this);
466   while (!r-&gt;is_humongous_start()) {
467     assert(reg_num &gt; 0, &quot;Sanity&quot;);
468     reg_num --;
<a name="29" id="anc29"></a><span class="line-modified">469     r = heap-&gt;get_region(reg_num);</span>
470     assert(r-&gt;is_humongous(), &quot;Must be a part of the humongous region&quot;);
471   }
472   assert(r-&gt;is_humongous_start(), &quot;Must be&quot;);
473   return r;
474 }
475 
476 void ShenandoahHeapRegion::recycle() {
<a name="30" id="anc30"></a><span class="line-modified">477   set_top(bottom());</span>



478   clear_live_data();
479 
480   reset_alloc_metadata();
481 
<a name="31" id="anc31"></a><span class="line-modified">482   ShenandoahHeap::heap()-&gt;marking_context()-&gt;reset_top_at_mark_start(this);</span>
<span class="line-added">483   set_update_watermark(bottom());</span>
484 
485   make_empty();
<a name="32" id="anc32"></a><span class="line-added">486 </span>
<span class="line-added">487   if (ZapUnusedHeapArea) {</span>
<span class="line-added">488     SpaceMangler::mangle_region(MemRegion(bottom(), end()));</span>
<span class="line-added">489   }</span>
490 }
491 
<a name="33" id="anc33"></a><span class="line-modified">492 HeapWord* ShenandoahHeapRegion::block_start(const void* p) const {</span>
493   assert(MemRegion(bottom(), end()).contains(p),
494          &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
495          p2i(p), p2i(bottom()), p2i(end()));
496   if (p &gt;= top()) {
497     return top();
498   } else {
499     HeapWord* last = bottom();
500     HeapWord* cur = last;
501     while (cur &lt;= p) {
502       last = cur;
503       cur += oop(cur)-&gt;size();
504     }
505     shenandoah_assert_correct(NULL, oop(last));
506     return last;
507   }
508 }
509 
<a name="34" id="anc34"></a><span class="line-added">510 size_t ShenandoahHeapRegion::block_size(const HeapWord* p) const {</span>
<span class="line-added">511   assert(MemRegion(bottom(), end()).contains(p),</span>
<span class="line-added">512          &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,</span>
<span class="line-added">513          p2i(p), p2i(bottom()), p2i(end()));</span>
<span class="line-added">514   if (p &lt; top()) {</span>
<span class="line-added">515     return oop(p)-&gt;size();</span>
<span class="line-added">516   } else {</span>
<span class="line-added">517     assert(p == top(), &quot;just checking&quot;);</span>
<span class="line-added">518     return pointer_delta(end(), (HeapWord*) p);</span>
<span class="line-added">519   }</span>
<span class="line-added">520 }</span>
<span class="line-added">521 </span>
522 void ShenandoahHeapRegion::setup_sizes(size_t max_heap_size) {
523   // Absolute minimums we should not ever break.
524   static const size_t MIN_REGION_SIZE = 256*K;
525 
526   if (FLAG_IS_DEFAULT(ShenandoahMinRegionSize)) {
527     FLAG_SET_DEFAULT(ShenandoahMinRegionSize, MIN_REGION_SIZE);
528   }
529 
530   size_t region_size;
531   if (FLAG_IS_DEFAULT(ShenandoahHeapRegionSize)) {
532     if (ShenandoahMinRegionSize &gt; max_heap_size / MIN_NUM_REGIONS) {
533       err_msg message(&quot;Max heap size (&quot; SIZE_FORMAT &quot;%s) is too low to afford the minimum number &quot;
534                       &quot;of regions (&quot; SIZE_FORMAT &quot;) of minimum region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
535                       byte_size_in_proper_unit(max_heap_size), proper_unit_for_byte_size(max_heap_size),
536                       MIN_NUM_REGIONS,
537                       byte_size_in_proper_unit(ShenandoahMinRegionSize), proper_unit_for_byte_size(ShenandoahMinRegionSize));
538       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
539     }
540     if (ShenandoahMinRegionSize &lt; MIN_REGION_SIZE) {
541       err_msg message(&quot;&quot; SIZE_FORMAT &quot;%s should not be lower than minimum region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
542                       byte_size_in_proper_unit(ShenandoahMinRegionSize), proper_unit_for_byte_size(ShenandoahMinRegionSize),
543                       byte_size_in_proper_unit(MIN_REGION_SIZE),         proper_unit_for_byte_size(MIN_REGION_SIZE));
544       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
545     }
546     if (ShenandoahMinRegionSize &lt; MinTLABSize) {
547       err_msg message(&quot;&quot; SIZE_FORMAT &quot;%s should not be lower than TLAB size size (&quot; SIZE_FORMAT &quot;%s).&quot;,
548                       byte_size_in_proper_unit(ShenandoahMinRegionSize), proper_unit_for_byte_size(ShenandoahMinRegionSize),
549                       byte_size_in_proper_unit(MinTLABSize),             proper_unit_for_byte_size(MinTLABSize));
550       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
551     }
552     if (ShenandoahMaxRegionSize &lt; MIN_REGION_SIZE) {
553       err_msg message(&quot;&quot; SIZE_FORMAT &quot;%s should not be lower than min region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
554                       byte_size_in_proper_unit(ShenandoahMaxRegionSize), proper_unit_for_byte_size(ShenandoahMaxRegionSize),
555                       byte_size_in_proper_unit(MIN_REGION_SIZE),         proper_unit_for_byte_size(MIN_REGION_SIZE));
556       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMaxRegionSize option&quot;, message);
557     }
558     if (ShenandoahMinRegionSize &gt; ShenandoahMaxRegionSize) {
559       err_msg message(&quot;Minimum (&quot; SIZE_FORMAT &quot;%s) should be larger than maximum (&quot; SIZE_FORMAT &quot;%s).&quot;,
560                       byte_size_in_proper_unit(ShenandoahMinRegionSize), proper_unit_for_byte_size(ShenandoahMinRegionSize),
561                       byte_size_in_proper_unit(ShenandoahMaxRegionSize), proper_unit_for_byte_size(ShenandoahMaxRegionSize));
562       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize or -XX:ShenandoahMaxRegionSize&quot;, message);
563     }
564 
565     // We rapidly expand to max_heap_size in most scenarios, so that is the measure
566     // for usual heap sizes. Do not depend on initial_heap_size here.
567     region_size = max_heap_size / ShenandoahTargetNumRegions;
568 
569     // Now make sure that we don&#39;t go over or under our limits.
570     region_size = MAX2(ShenandoahMinRegionSize, region_size);
571     region_size = MIN2(ShenandoahMaxRegionSize, region_size);
572 
573   } else {
574     if (ShenandoahHeapRegionSize &gt; max_heap_size / MIN_NUM_REGIONS) {
575       err_msg message(&quot;Max heap size (&quot; SIZE_FORMAT &quot;%s) is too low to afford the minimum number &quot;
576                               &quot;of regions (&quot; SIZE_FORMAT &quot;) of requested size (&quot; SIZE_FORMAT &quot;%s).&quot;,
577                       byte_size_in_proper_unit(max_heap_size), proper_unit_for_byte_size(max_heap_size),
578                       MIN_NUM_REGIONS,
579                       byte_size_in_proper_unit(ShenandoahHeapRegionSize), proper_unit_for_byte_size(ShenandoahHeapRegionSize));
580       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahHeapRegionSize option&quot;, message);
581     }
582     if (ShenandoahHeapRegionSize &lt; ShenandoahMinRegionSize) {
583       err_msg message(&quot;Heap region size (&quot; SIZE_FORMAT &quot;%s) should be larger than min region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
584                       byte_size_in_proper_unit(ShenandoahHeapRegionSize), proper_unit_for_byte_size(ShenandoahHeapRegionSize),
585                       byte_size_in_proper_unit(ShenandoahMinRegionSize),  proper_unit_for_byte_size(ShenandoahMinRegionSize));
586       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahHeapRegionSize option&quot;, message);
587     }
588     if (ShenandoahHeapRegionSize &gt; ShenandoahMaxRegionSize) {
589       err_msg message(&quot;Heap region size (&quot; SIZE_FORMAT &quot;%s) should be lower than max region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
590                       byte_size_in_proper_unit(ShenandoahHeapRegionSize), proper_unit_for_byte_size(ShenandoahHeapRegionSize),
591                       byte_size_in_proper_unit(ShenandoahMaxRegionSize),  proper_unit_for_byte_size(ShenandoahMaxRegionSize));
592       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahHeapRegionSize option&quot;, message);
593     }
594     region_size = ShenandoahHeapRegionSize;
595   }
596 
597   // Make sure region size is at least one large page, if enabled.
598   // Otherwise, uncommitting one region may falsely uncommit the adjacent
599   // regions too.
600   // Also see shenandoahArguments.cpp, where it handles UseLargePages.
601   if (UseLargePages &amp;&amp; ShenandoahUncommit) {
602     region_size = MAX2(region_size, os::large_page_size());
603   }
604 
605   int region_size_log = log2_long((jlong) region_size);
606   // Recalculate the region size to make sure it&#39;s a power of
607   // 2. This means that region_size is the largest power of 2 that&#39;s
608   // &lt;= what we&#39;ve calculated so far.
609   region_size = size_t(1) &lt;&lt; region_size_log;
610 
611   // Now, set up the globals.
612   guarantee(RegionSizeBytesShift == 0, &quot;we should only set it once&quot;);
613   RegionSizeBytesShift = (size_t)region_size_log;
614 
615   guarantee(RegionSizeWordsShift == 0, &quot;we should only set it once&quot;);
616   RegionSizeWordsShift = RegionSizeBytesShift - LogHeapWordSize;
617 
618   guarantee(RegionSizeBytes == 0, &quot;we should only set it once&quot;);
619   RegionSizeBytes = region_size;
620   RegionSizeWords = RegionSizeBytes &gt;&gt; LogHeapWordSize;
621   assert (RegionSizeWords*HeapWordSize == RegionSizeBytes, &quot;sanity&quot;);
622 
623   guarantee(RegionSizeWordsMask == 0, &quot;we should only set it once&quot;);
624   RegionSizeWordsMask = RegionSizeWords - 1;
625 
626   guarantee(RegionSizeBytesMask == 0, &quot;we should only set it once&quot;);
627   RegionSizeBytesMask = RegionSizeBytes - 1;
628 
629   guarantee(RegionCount == 0, &quot;we should only set it once&quot;);
630   RegionCount = max_heap_size / RegionSizeBytes;
631   guarantee(RegionCount &gt;= MIN_NUM_REGIONS, &quot;Should have at least minimum regions&quot;);
632 
633   guarantee(HumongousThresholdWords == 0, &quot;we should only set it once&quot;);
634   HumongousThresholdWords = RegionSizeWords * ShenandoahHumongousThreshold / 100;
635   HumongousThresholdWords = align_down(HumongousThresholdWords, MinObjAlignment);
636   assert (HumongousThresholdWords &lt;= RegionSizeWords, &quot;sanity&quot;);
637 
638   guarantee(HumongousThresholdBytes == 0, &quot;we should only set it once&quot;);
639   HumongousThresholdBytes = HumongousThresholdWords * HeapWordSize;
640   assert (HumongousThresholdBytes &lt;= RegionSizeBytes, &quot;sanity&quot;);
641 
642   // The rationale for trimming the TLAB sizes has to do with the raciness in
643   // TLAB allocation machinery. It may happen that TLAB sizing policy polls Shenandoah
644   // about next free size, gets the answer for region #N, goes away for a while, then
645   // tries to allocate in region #N, and fail because some other thread have claimed part
646   // of the region #N, and then the freeset allocation code has to retire the region #N,
647   // before moving the allocation to region #N+1.
648   //
649   // The worst case realizes when &quot;answer&quot; is &quot;region size&quot;, which means it could
650   // prematurely retire an entire region. Having smaller TLABs does not fix that
651   // completely, but reduces the probability of too wasteful region retirement.
652   // With current divisor, we will waste no more than 1/8 of region size in the worst
653   // case. This also has a secondary effect on collection set selection: even under
654   // the race, the regions would be at least 7/8 used, which allows relying on
655   // &quot;used&quot; - &quot;live&quot; for cset selection. Otherwise, we can get the fragmented region
656   // below the garbage threshold that would never be considered for collection.
657   //
658   // The whole thing is mitigated if Elastic TLABs are enabled.
659   //
660   guarantee(MaxTLABSizeWords == 0, &quot;we should only set it once&quot;);
661   MaxTLABSizeWords = MIN2(ShenandoahElasticTLAB ? RegionSizeWords : (RegionSizeWords / 8), HumongousThresholdWords);
662   MaxTLABSizeWords = align_down(MaxTLABSizeWords, MinObjAlignment);
663 
664   guarantee(MaxTLABSizeBytes == 0, &quot;we should only set it once&quot;);
665   MaxTLABSizeBytes = MaxTLABSizeWords * HeapWordSize;
666   assert (MaxTLABSizeBytes &gt; MinTLABSize, &quot;should be larger&quot;);
667 
668   log_info(gc, init)(&quot;Regions: &quot; SIZE_FORMAT &quot; x &quot; SIZE_FORMAT &quot;%s&quot;,
669                      RegionCount, byte_size_in_proper_unit(RegionSizeBytes), proper_unit_for_byte_size(RegionSizeBytes));
670   log_info(gc, init)(&quot;Humongous object threshold: &quot; SIZE_FORMAT &quot;%s&quot;,
671                      byte_size_in_proper_unit(HumongousThresholdBytes), proper_unit_for_byte_size(HumongousThresholdBytes));
672   log_info(gc, init)(&quot;Max TLAB size: &quot; SIZE_FORMAT &quot;%s&quot;,
673                      byte_size_in_proper_unit(MaxTLABSizeBytes), proper_unit_for_byte_size(MaxTLABSizeBytes));
674 }
675 
676 void ShenandoahHeapRegion::do_commit() {
<a name="35" id="anc35"></a><span class="line-modified">677   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-added">678   if (!heap-&gt;is_heap_region_special() &amp;&amp; !os::commit_memory((char *) bottom(), RegionSizeBytes, false)) {</span>
679     report_java_out_of_memory(&quot;Unable to commit region&quot;);
680   }
<a name="36" id="anc36"></a><span class="line-modified">681   if (!heap-&gt;commit_bitmap_slice(this)) {</span>
682     report_java_out_of_memory(&quot;Unable to commit bitmaps for region&quot;);
683   }
<a name="37" id="anc37"></a><span class="line-modified">684   heap-&gt;increase_committed(ShenandoahHeapRegion::region_size_bytes());</span>
685 }
686 
687 void ShenandoahHeapRegion::do_uncommit() {
<a name="38" id="anc38"></a><span class="line-modified">688   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-added">689   if (!heap-&gt;is_heap_region_special() &amp;&amp; !os::uncommit_memory((char *) bottom(), RegionSizeBytes)) {</span>
690     report_java_out_of_memory(&quot;Unable to uncommit region&quot;);
691   }
<a name="39" id="anc39"></a><span class="line-modified">692   if (!heap-&gt;uncommit_bitmap_slice(this)) {</span>
693     report_java_out_of_memory(&quot;Unable to uncommit bitmaps for region&quot;);
694   }
<a name="40" id="anc40"></a><span class="line-modified">695   heap-&gt;decrease_committed(ShenandoahHeapRegion::region_size_bytes());</span>
696 }
697 
698 void ShenandoahHeapRegion::set_state(RegionState to) {
699   EventShenandoahHeapRegionStateChange evt;
700   if (evt.should_commit()){
701     evt.set_index((unsigned)region_number());
702     evt.set_start((uintptr_t)bottom());
703     evt.set_used(used());
704     evt.set_from(_state);
705     evt.set_to(to);
706     evt.commit();
707   }
708   _state = to;
709 }
710 
711 void ShenandoahHeapRegion::record_pin() {
712   Atomic::add(&amp;_critical_pins, (size_t)1);
713 }
714 
715 void ShenandoahHeapRegion::record_unpin() {
716   assert(pin_count() &gt; 0, &quot;Region &quot; SIZE_FORMAT &quot; should have non-zero pins&quot;, region_number());
717   Atomic::sub(&amp;_critical_pins, (size_t)1);
718 }
719 
720 size_t ShenandoahHeapRegion::pin_count() const {
721   return Atomic::load(&amp;_critical_pins);
722 }
<a name="41" id="anc41"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="41" type="hidden" />
</body>
</html>
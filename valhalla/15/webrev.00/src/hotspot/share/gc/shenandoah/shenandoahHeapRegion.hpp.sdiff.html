<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeapRegion.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGION_HPP
 26 #define SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGION_HPP
 27 
<span class="line-modified"> 28 #include &quot;gc/shared/space.hpp&quot;</span>
 29 #include &quot;gc/shenandoah/shenandoahAllocRequest.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahPacer.hpp&quot;

 33 #include &quot;utilities/sizes.hpp&quot;
 34 
 35 class VMStructs;
 36 class ShenandoahHeapRegionStateConstant;
 37 
<span class="line-modified"> 38 class ShenandoahHeapRegion : public ContiguousSpace {</span>
 39   friend class VMStructs;
 40   friend class ShenandoahHeapRegionStateConstant;
 41 private:
 42   /*
 43     Region state is described by a state machine. Transitions are guarded by
 44     heap lock, which allows changing the state of several regions atomically.
 45     Region states can be logically aggregated in groups.
 46 
 47       &quot;Empty&quot;:
 48       .................................................................
 49       .                                                               .
 50       .                                                               .
 51       .         Uncommitted  &lt;-------  Committed &lt;------------------------\
 52       .              |                     |                          .   |
 53       .              \---------v-----------/                          .   |
 54       .                        |                                      .   |
 55       .........................|.......................................   |
 56                                |                                          |
 57       &quot;Active&quot;:                |                                          |
 58       .........................|.......................................   |
</pre>
<hr />
<pre>
207   void record_pin();
208   void record_unpin();
209   size_t pin_count() const;
210 
211 private:
212   static size_t RegionCount;
213   static size_t RegionSizeBytes;
214   static size_t RegionSizeWords;
215   static size_t RegionSizeBytesShift;
216   static size_t RegionSizeWordsShift;
217   static size_t RegionSizeBytesMask;
218   static size_t RegionSizeWordsMask;
219   static size_t HumongousThresholdBytes;
220   static size_t HumongousThresholdWords;
221   static size_t MaxTLABSizeBytes;
222   static size_t MaxTLABSizeWords;
223 
224   // Global allocation counter, increased for each allocation under Shenandoah heap lock.
225   // Padded to avoid false sharing with the read-only fields above.
226   struct PaddedAllocSeqNum {
<span class="line-modified">227     DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(uint64_t));</span>
228     uint64_t value;
<span class="line-modified">229     DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);</span>
230 
231     PaddedAllocSeqNum() {
232       // start with 1, reserve 0 for uninitialized value
233       value = 1;
234     }
235   };
236 
237   static PaddedAllocSeqNum _alloc_seq_num;
238 
239   // Never updated fields
<span class="line-modified">240   ShenandoahHeap* _heap;</span>
<span class="line-modified">241   MemRegion _reserved;</span>
<span class="line-modified">242   size_t _region_number;</span>
243 
244   // Rarely updated fields
245   HeapWord* _new_top;
246   double _empty_time;
247 
248   // Seldom updated fields
249   RegionState _state;
250 
251   // Frequently updated fields


252   size_t _tlab_allocs;
253   size_t _gclab_allocs;
254   size_t _shared_allocs;
255 
<span class="line-removed">256   uint64_t _seqnum_first_alloc_mutator;</span>
<span class="line-removed">257   uint64_t _seqnum_first_alloc_gc;</span>
258   uint64_t _seqnum_last_alloc_mutator;
<span class="line-removed">259   uint64_t _seqnum_last_alloc_gc;</span>
260 
261   volatile size_t _live_data;
262   volatile size_t _critical_pins;
263 


264   // Claim some space at the end to protect next region
<span class="line-modified">265   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);</span>
266 
267 public:
<span class="line-modified">268   ShenandoahHeapRegion(ShenandoahHeap* heap, HeapWord* start, size_t size_words, size_t index, bool committed);</span>
269 
270   static const size_t MIN_NUM_REGIONS = 10;
271 
272   static void setup_sizes(size_t max_heap_size);
273 
274   double empty_time() {
275     return _empty_time;
276   }
277 
278   inline static size_t required_regions(size_t bytes) {
279     return (bytes + ShenandoahHeapRegion::region_size_bytes() - 1) &gt;&gt; ShenandoahHeapRegion::region_size_bytes_shift();
280   }
281 
282   inline static size_t region_count() {
283     return ShenandoahHeapRegion::RegionCount;
284   }
285 
286   inline static size_t region_size_bytes() {
287     return ShenandoahHeapRegion::RegionSizeBytes;
288   }
</pre>
<hr />
<pre>
340   }
341 
342   inline static size_t max_tlab_size_bytes() {
343     return ShenandoahHeapRegion::MaxTLABSizeBytes;
344   }
345 
346   inline static size_t max_tlab_size_words() {
347     return ShenandoahHeapRegion::MaxTLABSizeWords;
348   }
349 
350   static uint64_t seqnum_current_alloc() {
351     // Last used seq number
352     return _alloc_seq_num.value - 1;
353   }
354 
355   size_t region_number() const;
356 
357   // Allocation (return NULL if full)
358   inline HeapWord* allocate(size_t word_size, ShenandoahAllocRequest::Type type);
359 
<span class="line-removed">360   HeapWord* allocate(size_t word_size) shenandoah_not_implemented_return(NULL)</span>
<span class="line-removed">361 </span>
362   void clear_live_data();
363   void set_live_data(size_t s);
364 
365   // Increase live data for newly allocated region
366   inline void increase_live_data_alloc_words(size_t s);
367 
368   // Increase live data for region scanned with GC
369   inline void increase_live_data_gc_words(size_t s);
370 
371   bool has_live() const;
372   size_t get_live_data_bytes() const;
373   size_t get_live_data_words() const;
374 
375   void print_on(outputStream* st) const;
376 
377   size_t garbage() const;
378 
379   void recycle();
380 
381   void oop_iterate(OopIterateClosure* cl);
382 
<span class="line-modified">383   HeapWord* block_start_const(const void* p) const;</span>
<span class="line-modified">384 </span>
<span class="line-modified">385   bool in_collection_set() const;</span>
386 
387   // Find humongous start region that this region belongs to
388   ShenandoahHeapRegion* humongous_start_region() const;
389 
<span class="line-modified">390   CompactibleSpace* next_compaction_space() const shenandoah_not_implemented_return(NULL);</span>
<span class="line-modified">391   void prepare_for_compaction(CompactPoint* cp)   shenandoah_not_implemented;</span>
<span class="line-removed">392   void adjust_pointers()                          shenandoah_not_implemented;</span>
<span class="line-removed">393   void compact()                                  shenandoah_not_implemented;</span>
394 
<span class="line-modified">395   void set_new_top(HeapWord* new_top) { _new_top = new_top; }</span>
<span class="line-modified">396   HeapWord* new_top() const { return _new_top; }</span>







397 
398   inline void adjust_alloc_metadata(ShenandoahAllocRequest::Type type, size_t);
399   void reset_alloc_metadata_to_shared();
400   void reset_alloc_metadata();
401   size_t get_shared_allocs() const;
402   size_t get_tlab_allocs() const;
403   size_t get_gclab_allocs() const;
404 
<span class="line-modified">405   uint64_t seqnum_first_alloc() const {</span>
<span class="line-modified">406     if (_seqnum_first_alloc_mutator == 0) return _seqnum_first_alloc_gc;</span>
<span class="line-modified">407     if (_seqnum_first_alloc_gc == 0)      return _seqnum_first_alloc_mutator;</span>
<span class="line-modified">408     return MIN2(_seqnum_first_alloc_mutator, _seqnum_first_alloc_gc);</span>
<span class="line-modified">409   }</span>
<span class="line-modified">410 </span>
<span class="line-modified">411   uint64_t seqnum_last_alloc() const {</span>
<span class="line-modified">412     return MAX2(_seqnum_last_alloc_mutator, _seqnum_last_alloc_gc);</span>
<span class="line-modified">413   }</span>
<span class="line-modified">414 </span>
<span class="line-modified">415   uint64_t seqnum_first_alloc_mutator() const {</span>
<span class="line-modified">416     return _seqnum_first_alloc_mutator;</span>
<span class="line-removed">417   }</span>
<span class="line-removed">418 </span>
<span class="line-removed">419   uint64_t seqnum_last_alloc_mutator()  const {</span>
<span class="line-removed">420     return _seqnum_last_alloc_mutator;</span>
<span class="line-removed">421   }</span>
<span class="line-removed">422 </span>
<span class="line-removed">423   uint64_t seqnum_first_alloc_gc() const {</span>
<span class="line-removed">424     return _seqnum_first_alloc_gc;</span>
425   }
426 
<span class="line-modified">427   uint64_t seqnum_last_alloc_gc()  const {</span>
<span class="line-modified">428     return _seqnum_last_alloc_gc;</span>


429   }
430 
431 private:
432   void do_commit();
433   void do_uncommit();
434 
435   void oop_iterate_objects(OopIterateClosure* cl);
436   void oop_iterate_humongous(OopIterateClosure* cl);
437 
438   inline void internal_increase_live_data(size_t s);
439 
440   void set_state(RegionState to);
441 };
442 
443 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGION_HPP
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGION_HPP
 26 #define SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGION_HPP
 27 
<span class="line-modified"> 28 #include &quot;gc/shared/spaceDecorator.hpp&quot;</span>
 29 #include &quot;gc/shenandoah/shenandoahAllocRequest.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahPacer.hpp&quot;
<span class="line-added"> 33 #include &quot;gc/shenandoah/shenandoahPadding.hpp&quot;</span>
 34 #include &quot;utilities/sizes.hpp&quot;
 35 
 36 class VMStructs;
 37 class ShenandoahHeapRegionStateConstant;
 38 
<span class="line-modified"> 39 class ShenandoahHeapRegion : public CHeapObj&lt;mtGC&gt; {</span>
 40   friend class VMStructs;
 41   friend class ShenandoahHeapRegionStateConstant;
 42 private:
 43   /*
 44     Region state is described by a state machine. Transitions are guarded by
 45     heap lock, which allows changing the state of several regions atomically.
 46     Region states can be logically aggregated in groups.
 47 
 48       &quot;Empty&quot;:
 49       .................................................................
 50       .                                                               .
 51       .                                                               .
 52       .         Uncommitted  &lt;-------  Committed &lt;------------------------\
 53       .              |                     |                          .   |
 54       .              \---------v-----------/                          .   |
 55       .                        |                                      .   |
 56       .........................|.......................................   |
 57                                |                                          |
 58       &quot;Active&quot;:                |                                          |
 59       .........................|.......................................   |
</pre>
<hr />
<pre>
208   void record_pin();
209   void record_unpin();
210   size_t pin_count() const;
211 
212 private:
213   static size_t RegionCount;
214   static size_t RegionSizeBytes;
215   static size_t RegionSizeWords;
216   static size_t RegionSizeBytesShift;
217   static size_t RegionSizeWordsShift;
218   static size_t RegionSizeBytesMask;
219   static size_t RegionSizeWordsMask;
220   static size_t HumongousThresholdBytes;
221   static size_t HumongousThresholdWords;
222   static size_t MaxTLABSizeBytes;
223   static size_t MaxTLABSizeWords;
224 
225   // Global allocation counter, increased for each allocation under Shenandoah heap lock.
226   // Padded to avoid false sharing with the read-only fields above.
227   struct PaddedAllocSeqNum {
<span class="line-modified">228     shenandoah_padding(0);</span>
229     uint64_t value;
<span class="line-modified">230     shenandoah_padding(1);</span>
231 
232     PaddedAllocSeqNum() {
233       // start with 1, reserve 0 for uninitialized value
234       value = 1;
235     }
236   };
237 
238   static PaddedAllocSeqNum _alloc_seq_num;
239 
240   // Never updated fields
<span class="line-modified">241   size_t const _region_number;</span>
<span class="line-modified">242   HeapWord* const _bottom;</span>
<span class="line-modified">243   HeapWord* const _end;</span>
244 
245   // Rarely updated fields
246   HeapWord* _new_top;
247   double _empty_time;
248 
249   // Seldom updated fields
250   RegionState _state;
251 
252   // Frequently updated fields
<span class="line-added">253   HeapWord* _top;</span>
<span class="line-added">254 </span>
255   size_t _tlab_allocs;
256   size_t _gclab_allocs;
257   size_t _shared_allocs;
258 


259   uint64_t _seqnum_last_alloc_mutator;

260 
261   volatile size_t _live_data;
262   volatile size_t _critical_pins;
263 
<span class="line-added">264   HeapWord* _update_watermark;</span>
<span class="line-added">265 </span>
266   // Claim some space at the end to protect next region
<span class="line-modified">267   shenandoah_padding(0);</span>
268 
269 public:
<span class="line-modified">270   ShenandoahHeapRegion(HeapWord* start, size_t index, bool committed);</span>
271 
272   static const size_t MIN_NUM_REGIONS = 10;
273 
274   static void setup_sizes(size_t max_heap_size);
275 
276   double empty_time() {
277     return _empty_time;
278   }
279 
280   inline static size_t required_regions(size_t bytes) {
281     return (bytes + ShenandoahHeapRegion::region_size_bytes() - 1) &gt;&gt; ShenandoahHeapRegion::region_size_bytes_shift();
282   }
283 
284   inline static size_t region_count() {
285     return ShenandoahHeapRegion::RegionCount;
286   }
287 
288   inline static size_t region_size_bytes() {
289     return ShenandoahHeapRegion::RegionSizeBytes;
290   }
</pre>
<hr />
<pre>
342   }
343 
344   inline static size_t max_tlab_size_bytes() {
345     return ShenandoahHeapRegion::MaxTLABSizeBytes;
346   }
347 
348   inline static size_t max_tlab_size_words() {
349     return ShenandoahHeapRegion::MaxTLABSizeWords;
350   }
351 
352   static uint64_t seqnum_current_alloc() {
353     // Last used seq number
354     return _alloc_seq_num.value - 1;
355   }
356 
357   size_t region_number() const;
358 
359   // Allocation (return NULL if full)
360   inline HeapWord* allocate(size_t word_size, ShenandoahAllocRequest::Type type);
361 


362   void clear_live_data();
363   void set_live_data(size_t s);
364 
365   // Increase live data for newly allocated region
366   inline void increase_live_data_alloc_words(size_t s);
367 
368   // Increase live data for region scanned with GC
369   inline void increase_live_data_gc_words(size_t s);
370 
371   bool has_live() const;
372   size_t get_live_data_bytes() const;
373   size_t get_live_data_words() const;
374 
375   void print_on(outputStream* st) const;
376 
377   size_t garbage() const;
378 
379   void recycle();
380 
381   void oop_iterate(OopIterateClosure* cl);
382 
<span class="line-modified">383   HeapWord* block_start(const void* p) const;</span>
<span class="line-modified">384   size_t block_size(const HeapWord* p) const;</span>
<span class="line-modified">385   bool block_is_obj(const HeapWord* p) const { return p &lt; top(); }</span>
386 
387   // Find humongous start region that this region belongs to
388   ShenandoahHeapRegion* humongous_start_region() const;
389 
<span class="line-modified">390   HeapWord* top() const         { return _top;     }</span>
<span class="line-modified">391   void set_top(HeapWord* v)     { _top = v;        }</span>


392 
<span class="line-modified">393   HeapWord* new_top() const     { return _new_top; }</span>
<span class="line-modified">394   void set_new_top(HeapWord* v) { _new_top = v;    }</span>
<span class="line-added">395 </span>
<span class="line-added">396   HeapWord* bottom() const      { return _bottom;  }</span>
<span class="line-added">397   HeapWord* end() const         { return _end;     }</span>
<span class="line-added">398 </span>
<span class="line-added">399   size_t capacity() const       { return byte_size(bottom(), end()); }</span>
<span class="line-added">400   size_t used() const           { return byte_size(bottom(), top()); }</span>
<span class="line-added">401   size_t free() const           { return byte_size(top(),    end()); }</span>
402 
403   inline void adjust_alloc_metadata(ShenandoahAllocRequest::Type type, size_t);
404   void reset_alloc_metadata_to_shared();
405   void reset_alloc_metadata();
406   size_t get_shared_allocs() const;
407   size_t get_tlab_allocs() const;
408   size_t get_gclab_allocs() const;
409 
<span class="line-modified">410   inline uint64_t seqnum_last_alloc_mutator() const;</span>
<span class="line-modified">411   void update_seqnum_last_alloc_mutator();</span>
<span class="line-modified">412 </span>
<span class="line-modified">413   HeapWord* get_update_watermark() const {</span>
<span class="line-modified">414     // Updates to the update-watermark only happen at safepoints or, when pushing</span>
<span class="line-modified">415     // back the watermark for evacuation regions, under the Shenandoah heap-lock.</span>
<span class="line-modified">416     // Consequently, we should access the field under the same lock. However, since</span>
<span class="line-modified">417     // those updates are only monotonically increasing, possibly reading a stale value</span>
<span class="line-modified">418     // is only conservative - we would not miss to update any fields.</span>
<span class="line-modified">419     HeapWord* watermark = _update_watermark;</span>
<span class="line-modified">420     assert(bottom() &lt;= watermark &amp;&amp; watermark &lt;= top(), &quot;within bounds&quot;);</span>
<span class="line-modified">421     return watermark;</span>








422   }
423 
<span class="line-modified">424   void set_update_watermark(HeapWord* w) {</span>
<span class="line-modified">425     shenandoah_assert_heaplocked_or_safepoint();</span>
<span class="line-added">426     assert(bottom() &lt;= w &amp;&amp; w &lt;= top(), &quot;within bounds&quot;);</span>
<span class="line-added">427     _update_watermark = w;</span>
428   }
429 
430 private:
431   void do_commit();
432   void do_uncommit();
433 
434   void oop_iterate_objects(OopIterateClosure* cl);
435   void oop_iterate_humongous(OopIterateClosure* cl);
436 
437   inline void internal_increase_live_data(size_t s);
438 
439   void set_state(RegionState to);
440 };
441 
442 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGION_HPP
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahHeapRegion.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
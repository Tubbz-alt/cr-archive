<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_HPP
 26 #define SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_HPP
 27 
 28 #include &quot;gc/shared/markBitMap.hpp&quot;
 29 #include &quot;gc/shared/softRefPolicy.hpp&quot;
 30 #include &quot;gc/shared/collectedHeap.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahAllocRequest.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahLock.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahEvacOOMHandler.hpp&quot;

 35 #include &quot;gc/shenandoah/shenandoahSharedVariables.hpp&quot;
 36 #include &quot;gc/shenandoah/shenandoahUnload.hpp&quot;
 37 #include &quot;services/memoryManager.hpp&quot;
 38 #include &quot;utilities/globalDefinitions.hpp&quot;
 39 
 40 class ConcurrentGCTimer;
 41 class ReferenceProcessor;
<span class="line-removed"> 42 class ShenandoahAllocTracker;</span>
 43 class ShenandoahCollectorPolicy;
 44 class ShenandoahControlThread;
 45 class ShenandoahGCSession;
 46 class ShenandoahGCStateResetter;
 47 class ShenandoahHeuristics;
 48 class ShenandoahMarkingContext;
 49 class ShenandoahMarkCompact;
 50 class ShenandoahMode;
 51 class ShenandoahPhaseTimings;
 52 class ShenandoahHeap;
 53 class ShenandoahHeapRegion;
 54 class ShenandoahHeapRegionClosure;
 55 class ShenandoahCollectionSet;
 56 class ShenandoahFreeSet;
 57 class ShenandoahConcurrentMark;
 58 class ShenandoahMarkCompact;
 59 class ShenandoahMonitoringSupport;
 60 class ShenandoahPacer;
 61 class ShenandoahTraversalGC;
 62 class ShenandoahVerifier;
 63 class ShenandoahWorkGang;
 64 class VMStructs;
 65 
 66 class ShenandoahRegionIterator : public StackObj {
 67 private:
 68   ShenandoahHeap* _heap;
 69 
<span class="line-modified"> 70   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));</span>
 71   volatile size_t _index;
<span class="line-modified"> 72   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);</span>
 73 
 74   // No implicit copying: iterators should be passed by reference to capture the state
 75   NONCOPYABLE(ShenandoahRegionIterator);
 76 
 77 public:
 78   ShenandoahRegionIterator();
 79   ShenandoahRegionIterator(ShenandoahHeap* heap);
 80 
 81   // Reset iterator to default state
 82   void reset();
 83 
 84   // Returns next region, or NULL if there are no more regions.
 85   // This is multi-thread-safe.
 86   inline ShenandoahHeapRegion* next();
 87 
 88   // This is *not* MT safe. However, in the absence of multithreaded access, it
 89   // can be used to determine if there is more work to do.
 90   bool has_next() const;
 91 };
 92 
</pre>
<hr />
<pre>
113 // Shenandoah GC is low-pause concurrent GC that uses Brooks forwarding pointers
114 // to encode forwarding data. See BrooksPointer for details on forwarding data encoding.
115 // See ShenandoahControlThread for GC cycle structure.
116 //
117 class ShenandoahHeap : public CollectedHeap {
118   friend class ShenandoahAsserts;
119   friend class VMStructs;
120   friend class ShenandoahGCSession;
121   friend class ShenandoahGCStateResetter;
122 
123 // ---------- Locks that guard important data structures in Heap
124 //
125 private:
126   ShenandoahHeapLock _lock;
127 
128 public:
129   ShenandoahHeapLock* lock() {
130     return &amp;_lock;
131   }
132 
<span class="line-removed">133   void assert_heaplock_owned_by_current_thread()     NOT_DEBUG_RETURN;</span>
<span class="line-removed">134   void assert_heaplock_not_owned_by_current_thread() NOT_DEBUG_RETURN;</span>
<span class="line-removed">135   void assert_heaplock_or_safepoint()                NOT_DEBUG_RETURN;</span>
<span class="line-removed">136 </span>
137 // ---------- Initialization, termination, identification, printing routines
138 //



139 public:
140   static ShenandoahHeap* heap();
<span class="line-removed">141   static ShenandoahHeap* heap_no_check();</span>
142 
143   const char* name()          const { return &quot;Shenandoah&quot;; }
144   ShenandoahHeap::Name kind() const { return CollectedHeap::Shenandoah; }
145 
146   ShenandoahHeap(ShenandoahCollectorPolicy* policy);
147   jint initialize();
148   void post_initialize();
149   void initialize_heuristics();
150 
151   void initialize_serviceability();
152 
153   void print_on(outputStream* st)              const;
154   void print_extended_on(outputStream *st)     const;
155   void print_tracing_info()                    const;
156   void print_gc_threads_on(outputStream* st)   const;
157   void print_heap_regions_on(outputStream* st) const;
158 
159   void stop();
160 
161   void prepare_for_verify();
162   void verify(VerifyOption vo);
163 
164 // ---------- Heap counters and metrics
165 //
166 private:
167            size_t _initial_size;
168            size_t _minimum_size;
<span class="line-modified">169   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));</span>
170   volatile size_t _used;
171   volatile size_t _committed;
172   volatile size_t _bytes_allocated_since_gc_start;
<span class="line-modified">173   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);</span>
174 
175 public:
176   void increase_used(size_t bytes);
177   void decrease_used(size_t bytes);
178   void set_used(size_t bytes);
179 
180   void increase_committed(size_t bytes);
181   void decrease_committed(size_t bytes);
182   void increase_allocated(size_t bytes);
183 
184   size_t bytes_allocated_since_gc_start();
185   void reset_bytes_allocated_since_gc_start();
186 
187   size_t min_capacity()     const;
188   size_t max_capacity()     const;
189   size_t initial_capacity() const;
190   size_t capacity()         const;
191   size_t used()             const;
192   size_t committed()        const;
193 
</pre>
<hr />
<pre>
360   ShenandoahSharedEnumFlag&lt;CancelState&gt; _cancelled_gc;
361   bool try_cancel_gc();
362 
363 public:
364   static address cancelled_gc_addr();
365 
366   inline bool cancelled_gc() const;
367   inline bool check_cancelled_gc_and_yield(bool sts_active = true);
368 
369   inline void clear_cancelled_gc();
370 
371   void cancel_gc(GCCause::Cause cause);
372 
373 // ---------- GC operations entry points
374 //
375 public:
376   // Entry points to STW GC operations, these cause a related safepoint, that then
377   // call the entry method below
378   void vmop_entry_init_mark();
379   void vmop_entry_final_mark();
<span class="line-removed">380   void vmop_entry_final_evac();</span>
381   void vmop_entry_init_updaterefs();
382   void vmop_entry_final_updaterefs();
383   void vmop_entry_init_traversal();
384   void vmop_entry_final_traversal();
385   void vmop_entry_full(GCCause::Cause cause);
386   void vmop_degenerated(ShenandoahDegenPoint point);
387 
388   // Entry methods to normally STW GC operations. These set up logging, monitoring
389   // and workers for net VM operation
390   void entry_init_mark();
391   void entry_final_mark();
<span class="line-removed">392   void entry_final_evac();</span>
393   void entry_init_updaterefs();
394   void entry_final_updaterefs();
395   void entry_init_traversal();
396   void entry_final_traversal();
397   void entry_full(GCCause::Cause cause);
398   void entry_degenerated(int point);
399 
400   // Entry methods to normally concurrent GC operations. These set up logging, monitoring
401   // for concurrent operation.
402   void entry_reset();
403   void entry_mark();
404   void entry_preclean();
405   void entry_roots();
406   void entry_cleanup();
407   void entry_evac();
408   void entry_updaterefs();
409   void entry_traversal();
410   void entry_uncommit(double shrink_before);
411 
412 private:
413   // Actual work for the phases
414   void op_init_mark();
415   void op_final_mark();
<span class="line-removed">416   void op_final_evac();</span>
417   void op_init_updaterefs();
418   void op_final_updaterefs();
419   void op_init_traversal();
420   void op_final_traversal();
421   void op_full(GCCause::Cause cause);
422   void op_degenerated(ShenandoahDegenPoint point);
423   void op_degenerated_fail();
424   void op_degenerated_futile();
425 
426   void op_reset();
427   void op_mark();
428   void op_preclean();
429   void op_roots();
430   void op_cleanup();
431   void op_conc_evac();
432   void op_stw_evac();
433   void op_updaterefs();
434   void op_traversal();
435   void op_uncommit(double shrink_before);
436 
</pre>
<hr />
<pre>
441   const char* conc_mark_event_message() const;
442   const char* init_traversal_event_message() const;
443   const char* final_traversal_event_message() const;
444   const char* conc_traversal_event_message() const;
445   const char* degen_event_message(ShenandoahDegenPoint point) const;
446 
447 // ---------- GC subsystems
448 //
449 private:
450   ShenandoahControlThread*   _control_thread;
451   ShenandoahCollectorPolicy* _shenandoah_policy;
452   ShenandoahMode*            _gc_mode;
453   ShenandoahHeuristics*      _heuristics;
454   ShenandoahFreeSet*         _free_set;
455   ShenandoahConcurrentMark*  _scm;
456   ShenandoahTraversalGC*     _traversal_gc;
457   ShenandoahMarkCompact*     _full_gc;
458   ShenandoahPacer*           _pacer;
459   ShenandoahVerifier*        _verifier;
460 
<span class="line-removed">461   ShenandoahAllocTracker*    _alloc_tracker;</span>
462   ShenandoahPhaseTimings*    _phase_timings;
463 
464   ShenandoahControlThread*   control_thread()          { return _control_thread;    }
465   ShenandoahMarkCompact*     full_gc()                 { return _full_gc;           }
466 
467 public:
468   ShenandoahCollectorPolicy* shenandoah_policy() const { return _shenandoah_policy; }
469   ShenandoahHeuristics*      heuristics()        const { return _heuristics;        }
470   ShenandoahFreeSet*         free_set()          const { return _free_set;          }
471   ShenandoahConcurrentMark*  concurrent_mark()         { return _scm;               }
472   ShenandoahTraversalGC*     traversal_gc()      const { return _traversal_gc;      }
473   bool                       is_traversal_mode() const { return _traversal_gc != NULL; }
474   ShenandoahPacer*           pacer()             const { return _pacer;             }
475 
476   ShenandoahPhaseTimings*    phase_timings()     const { return _phase_timings;     }
<span class="line-removed">477   ShenandoahAllocTracker*    alloc_tracker()     const { return _alloc_tracker;     }</span>
478 
479   ShenandoahVerifier*        verifier();
480 
481 // ---------- VM subsystem bindings
482 //
483 private:
484   ShenandoahMonitoringSupport* _monitoring_support;
485   MemoryPool*                  _memory_pool;
486   GCMemoryManager              _stw_memory_manager;
487   GCMemoryManager              _cycle_memory_manager;
488   ConcurrentGCTimer*           _gc_timer;
489   SoftRefPolicy                _soft_ref_policy;
490 
491   // For exporting to SA
492   int                          _log_min_obj_alignment_in_bytes;
493 public:
494   ShenandoahMonitoringSupport* monitoring_support() { return _monitoring_support;    }
495   GCMemoryManager* cycle_memory_manager()           { return &amp;_cycle_memory_manager; }
496   GCMemoryManager* stw_memory_manager()             { return &amp;_stw_memory_manager;   }
497   SoftRefPolicy* soft_ref_policy()                  { return &amp;_soft_ref_policy;      }
</pre>
</td>
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_HPP
 26 #define SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_HPP
 27 
 28 #include &quot;gc/shared/markBitMap.hpp&quot;
 29 #include &quot;gc/shared/softRefPolicy.hpp&quot;
 30 #include &quot;gc/shared/collectedHeap.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahAllocRequest.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahLock.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahEvacOOMHandler.hpp&quot;
<span class="line-added"> 35 #include &quot;gc/shenandoah/shenandoahPadding.hpp&quot;</span>
 36 #include &quot;gc/shenandoah/shenandoahSharedVariables.hpp&quot;
 37 #include &quot;gc/shenandoah/shenandoahUnload.hpp&quot;
 38 #include &quot;services/memoryManager.hpp&quot;
 39 #include &quot;utilities/globalDefinitions.hpp&quot;
 40 
 41 class ConcurrentGCTimer;
 42 class ReferenceProcessor;

 43 class ShenandoahCollectorPolicy;
 44 class ShenandoahControlThread;
 45 class ShenandoahGCSession;
 46 class ShenandoahGCStateResetter;
 47 class ShenandoahHeuristics;
 48 class ShenandoahMarkingContext;
 49 class ShenandoahMarkCompact;
 50 class ShenandoahMode;
 51 class ShenandoahPhaseTimings;
 52 class ShenandoahHeap;
 53 class ShenandoahHeapRegion;
 54 class ShenandoahHeapRegionClosure;
 55 class ShenandoahCollectionSet;
 56 class ShenandoahFreeSet;
 57 class ShenandoahConcurrentMark;
 58 class ShenandoahMarkCompact;
 59 class ShenandoahMonitoringSupport;
 60 class ShenandoahPacer;
 61 class ShenandoahTraversalGC;
 62 class ShenandoahVerifier;
 63 class ShenandoahWorkGang;
 64 class VMStructs;
 65 
 66 class ShenandoahRegionIterator : public StackObj {
 67 private:
 68   ShenandoahHeap* _heap;
 69 
<span class="line-modified"> 70   shenandoah_padding(0);</span>
 71   volatile size_t _index;
<span class="line-modified"> 72   shenandoah_padding(1);</span>
 73 
 74   // No implicit copying: iterators should be passed by reference to capture the state
 75   NONCOPYABLE(ShenandoahRegionIterator);
 76 
 77 public:
 78   ShenandoahRegionIterator();
 79   ShenandoahRegionIterator(ShenandoahHeap* heap);
 80 
 81   // Reset iterator to default state
 82   void reset();
 83 
 84   // Returns next region, or NULL if there are no more regions.
 85   // This is multi-thread-safe.
 86   inline ShenandoahHeapRegion* next();
 87 
 88   // This is *not* MT safe. However, in the absence of multithreaded access, it
 89   // can be used to determine if there is more work to do.
 90   bool has_next() const;
 91 };
 92 
</pre>
<hr />
<pre>
113 // Shenandoah GC is low-pause concurrent GC that uses Brooks forwarding pointers
114 // to encode forwarding data. See BrooksPointer for details on forwarding data encoding.
115 // See ShenandoahControlThread for GC cycle structure.
116 //
117 class ShenandoahHeap : public CollectedHeap {
118   friend class ShenandoahAsserts;
119   friend class VMStructs;
120   friend class ShenandoahGCSession;
121   friend class ShenandoahGCStateResetter;
122 
123 // ---------- Locks that guard important data structures in Heap
124 //
125 private:
126   ShenandoahHeapLock _lock;
127 
128 public:
129   ShenandoahHeapLock* lock() {
130     return &amp;_lock;
131   }
132 




133 // ---------- Initialization, termination, identification, printing routines
134 //
<span class="line-added">135 private:</span>
<span class="line-added">136   static ShenandoahHeap* _heap;</span>
<span class="line-added">137 </span>
138 public:
139   static ShenandoahHeap* heap();

140 
141   const char* name()          const { return &quot;Shenandoah&quot;; }
142   ShenandoahHeap::Name kind() const { return CollectedHeap::Shenandoah; }
143 
144   ShenandoahHeap(ShenandoahCollectorPolicy* policy);
145   jint initialize();
146   void post_initialize();
147   void initialize_heuristics();
148 
149   void initialize_serviceability();
150 
151   void print_on(outputStream* st)              const;
152   void print_extended_on(outputStream *st)     const;
153   void print_tracing_info()                    const;
154   void print_gc_threads_on(outputStream* st)   const;
155   void print_heap_regions_on(outputStream* st) const;
156 
157   void stop();
158 
159   void prepare_for_verify();
160   void verify(VerifyOption vo);
161 
162 // ---------- Heap counters and metrics
163 //
164 private:
165            size_t _initial_size;
166            size_t _minimum_size;
<span class="line-modified">167   shenandoah_padding(0);</span>
168   volatile size_t _used;
169   volatile size_t _committed;
170   volatile size_t _bytes_allocated_since_gc_start;
<span class="line-modified">171   shenandoah_padding(1);</span>
172 
173 public:
174   void increase_used(size_t bytes);
175   void decrease_used(size_t bytes);
176   void set_used(size_t bytes);
177 
178   void increase_committed(size_t bytes);
179   void decrease_committed(size_t bytes);
180   void increase_allocated(size_t bytes);
181 
182   size_t bytes_allocated_since_gc_start();
183   void reset_bytes_allocated_since_gc_start();
184 
185   size_t min_capacity()     const;
186   size_t max_capacity()     const;
187   size_t initial_capacity() const;
188   size_t capacity()         const;
189   size_t used()             const;
190   size_t committed()        const;
191 
</pre>
<hr />
<pre>
358   ShenandoahSharedEnumFlag&lt;CancelState&gt; _cancelled_gc;
359   bool try_cancel_gc();
360 
361 public:
362   static address cancelled_gc_addr();
363 
364   inline bool cancelled_gc() const;
365   inline bool check_cancelled_gc_and_yield(bool sts_active = true);
366 
367   inline void clear_cancelled_gc();
368 
369   void cancel_gc(GCCause::Cause cause);
370 
371 // ---------- GC operations entry points
372 //
373 public:
374   // Entry points to STW GC operations, these cause a related safepoint, that then
375   // call the entry method below
376   void vmop_entry_init_mark();
377   void vmop_entry_final_mark();

378   void vmop_entry_init_updaterefs();
379   void vmop_entry_final_updaterefs();
380   void vmop_entry_init_traversal();
381   void vmop_entry_final_traversal();
382   void vmop_entry_full(GCCause::Cause cause);
383   void vmop_degenerated(ShenandoahDegenPoint point);
384 
385   // Entry methods to normally STW GC operations. These set up logging, monitoring
386   // and workers for net VM operation
387   void entry_init_mark();
388   void entry_final_mark();

389   void entry_init_updaterefs();
390   void entry_final_updaterefs();
391   void entry_init_traversal();
392   void entry_final_traversal();
393   void entry_full(GCCause::Cause cause);
394   void entry_degenerated(int point);
395 
396   // Entry methods to normally concurrent GC operations. These set up logging, monitoring
397   // for concurrent operation.
398   void entry_reset();
399   void entry_mark();
400   void entry_preclean();
401   void entry_roots();
402   void entry_cleanup();
403   void entry_evac();
404   void entry_updaterefs();
405   void entry_traversal();
406   void entry_uncommit(double shrink_before);
407 
408 private:
409   // Actual work for the phases
410   void op_init_mark();
411   void op_final_mark();

412   void op_init_updaterefs();
413   void op_final_updaterefs();
414   void op_init_traversal();
415   void op_final_traversal();
416   void op_full(GCCause::Cause cause);
417   void op_degenerated(ShenandoahDegenPoint point);
418   void op_degenerated_fail();
419   void op_degenerated_futile();
420 
421   void op_reset();
422   void op_mark();
423   void op_preclean();
424   void op_roots();
425   void op_cleanup();
426   void op_conc_evac();
427   void op_stw_evac();
428   void op_updaterefs();
429   void op_traversal();
430   void op_uncommit(double shrink_before);
431 
</pre>
<hr />
<pre>
436   const char* conc_mark_event_message() const;
437   const char* init_traversal_event_message() const;
438   const char* final_traversal_event_message() const;
439   const char* conc_traversal_event_message() const;
440   const char* degen_event_message(ShenandoahDegenPoint point) const;
441 
442 // ---------- GC subsystems
443 //
444 private:
445   ShenandoahControlThread*   _control_thread;
446   ShenandoahCollectorPolicy* _shenandoah_policy;
447   ShenandoahMode*            _gc_mode;
448   ShenandoahHeuristics*      _heuristics;
449   ShenandoahFreeSet*         _free_set;
450   ShenandoahConcurrentMark*  _scm;
451   ShenandoahTraversalGC*     _traversal_gc;
452   ShenandoahMarkCompact*     _full_gc;
453   ShenandoahPacer*           _pacer;
454   ShenandoahVerifier*        _verifier;
455 

456   ShenandoahPhaseTimings*    _phase_timings;
457 
458   ShenandoahControlThread*   control_thread()          { return _control_thread;    }
459   ShenandoahMarkCompact*     full_gc()                 { return _full_gc;           }
460 
461 public:
462   ShenandoahCollectorPolicy* shenandoah_policy() const { return _shenandoah_policy; }
463   ShenandoahHeuristics*      heuristics()        const { return _heuristics;        }
464   ShenandoahFreeSet*         free_set()          const { return _free_set;          }
465   ShenandoahConcurrentMark*  concurrent_mark()         { return _scm;               }
466   ShenandoahTraversalGC*     traversal_gc()      const { return _traversal_gc;      }
467   bool                       is_traversal_mode() const { return _traversal_gc != NULL; }
468   ShenandoahPacer*           pacer()             const { return _pacer;             }
469 
470   ShenandoahPhaseTimings*    phase_timings()     const { return _phase_timings;     }

471 
472   ShenandoahVerifier*        verifier();
473 
474 // ---------- VM subsystem bindings
475 //
476 private:
477   ShenandoahMonitoringSupport* _monitoring_support;
478   MemoryPool*                  _memory_pool;
479   GCMemoryManager              _stw_memory_manager;
480   GCMemoryManager              _cycle_memory_manager;
481   ConcurrentGCTimer*           _gc_timer;
482   SoftRefPolicy                _soft_ref_policy;
483 
484   // For exporting to SA
485   int                          _log_min_obj_alignment_in_bytes;
486 public:
487   ShenandoahMonitoringSupport* monitoring_support() { return _monitoring_support;    }
488   GCMemoryManager* cycle_memory_manager()           { return &amp;_cycle_memory_manager; }
489   GCMemoryManager* stw_memory_manager()             { return &amp;_stw_memory_manager;   }
490   SoftRefPolicy* soft_ref_policy()                  { return &amp;_soft_ref_policy;      }
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
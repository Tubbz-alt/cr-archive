<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeap.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 53,29 ***</span>
  size_t ShenandoahHeapRegion::MaxTLABSizeBytes = 0;
  size_t ShenandoahHeapRegion::MaxTLABSizeWords = 0;
  
  ShenandoahHeapRegion::PaddedAllocSeqNum ShenandoahHeapRegion::_alloc_seq_num;
  
<span class="line-modified">! ShenandoahHeapRegion::ShenandoahHeapRegion(ShenandoahHeap* heap, HeapWord* start,</span>
<span class="line-removed">-                                            size_t size_words, size_t index, bool committed) :</span>
<span class="line-removed">-   _heap(heap),</span>
<span class="line-removed">-   _reserved(MemRegion(start, size_words)),</span>
    _region_number(index),
    _new_top(NULL),
    _empty_time(os::elapsedTime()),
    _state(committed ? _empty_committed : _empty_uncommitted),
    _tlab_allocs(0),
    _gclab_allocs(0),
    _shared_allocs(0),
<span class="line-removed">-   _seqnum_first_alloc_mutator(0),</span>
<span class="line-removed">-   _seqnum_first_alloc_gc(0),</span>
    _seqnum_last_alloc_mutator(0),
<span class="line-removed">-   _seqnum_last_alloc_gc(0),</span>
    _live_data(0),
<span class="line-modified">!   _critical_pins(0) {</span>
  
<span class="line-modified">!   ContiguousSpace::initialize(_reserved, true, committed);</span>
  }
  
  size_t ShenandoahHeapRegion::region_number() const {
    return _region_number;
  }
<span class="line-new-header">--- 53,31 ---</span>
  size_t ShenandoahHeapRegion::MaxTLABSizeBytes = 0;
  size_t ShenandoahHeapRegion::MaxTLABSizeWords = 0;
  
  ShenandoahHeapRegion::PaddedAllocSeqNum ShenandoahHeapRegion::_alloc_seq_num;
  
<span class="line-modified">! ShenandoahHeapRegion::ShenandoahHeapRegion(HeapWord* start, size_t index, bool committed) :</span>
    _region_number(index),
<span class="line-added">+   _bottom(start),</span>
<span class="line-added">+   _end(start + RegionSizeWords),</span>
    _new_top(NULL),
    _empty_time(os::elapsedTime()),
    _state(committed ? _empty_committed : _empty_uncommitted),
<span class="line-added">+   _top(start),</span>
    _tlab_allocs(0),
    _gclab_allocs(0),
    _shared_allocs(0),
    _seqnum_last_alloc_mutator(0),
    _live_data(0),
<span class="line-modified">!   _critical_pins(0),</span>
<span class="line-added">+   _update_watermark(start) {</span>
  
<span class="line-modified">!   assert(Universe::on_page_boundary(_bottom) &amp;&amp; Universe::on_page_boundary(_end),</span>
<span class="line-added">+          &quot;invalid space boundaries&quot;);</span>
<span class="line-added">+   if (ZapUnusedHeapArea &amp;&amp; committed) {</span>
<span class="line-added">+     SpaceMangler::mangle_region(MemRegion(_bottom, _end));</span>
<span class="line-added">+   }</span>
  }
  
  size_t ShenandoahHeapRegion::region_number() const {
    return _region_number;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 87,11 ***</span>
    print_on(&amp;ss);
    fatal(&quot;%s&quot;, ss.as_string());
  }
  
  void ShenandoahHeapRegion::make_regular_allocation() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
  
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
      case _empty_committed:
<span class="line-new-header">--- 89,11 ---</span>
    print_on(&amp;ss);
    fatal(&quot;%s&quot;, ss.as_string());
  }
  
  void ShenandoahHeapRegion::make_regular_allocation() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
  
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
      case _empty_committed:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 103,12 ***</span>
        report_illegal_transition(&quot;regular allocation&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_regular_bypass() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
<span class="line-modified">!   assert (_heap-&gt;is_full_gc_in_progress() || _heap-&gt;is_degenerated_gc_in_progress(),</span>
            &quot;only for full or degen GC&quot;);
  
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
<span class="line-new-header">--- 105,12 ---</span>
        report_illegal_transition(&quot;regular allocation&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_regular_bypass() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
<span class="line-modified">!   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress() || ShenandoahHeap::heap()-&gt;is_degenerated_gc_in_progress(),</span>
            &quot;only for full or degen GC&quot;);
  
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 128,11 ***</span>
        report_illegal_transition(&quot;regular bypass&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_humongous_start() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
      case _empty_committed:
        set_state(_humongous_start);
<span class="line-new-header">--- 130,11 ---</span>
        report_illegal_transition(&quot;regular bypass&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_humongous_start() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
      case _empty_committed:
        set_state(_humongous_start);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,12 ***</span>
        report_illegal_transition(&quot;humongous start allocation&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_humongous_start_bypass() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
<span class="line-modified">!   assert (_heap-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
  
    switch (_state) {
      case _empty_committed:
      case _regular:
      case _humongous_start:
<span class="line-new-header">--- 143,12 ---</span>
        report_illegal_transition(&quot;humongous start allocation&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_humongous_start_bypass() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
<span class="line-modified">!   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
  
    switch (_state) {
      case _empty_committed:
      case _regular:
      case _humongous_start:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,11 ***</span>
        report_illegal_transition(&quot;humongous start bypass&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_humongous_cont() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
      case _empty_committed:
       set_state(_humongous_cont);
<span class="line-new-header">--- 159,11 ---</span>
        report_illegal_transition(&quot;humongous start bypass&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_humongous_cont() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
      case _empty_committed:
       set_state(_humongous_cont);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 170,12 ***</span>
        report_illegal_transition(&quot;humongous continuation allocation&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_humongous_cont_bypass() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
<span class="line-modified">!   assert (_heap-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
  
    switch (_state) {
      case _empty_committed:
      case _regular:
      case _humongous_start:
<span class="line-new-header">--- 172,12 ---</span>
        report_illegal_transition(&quot;humongous continuation allocation&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_humongous_cont_bypass() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
<span class="line-modified">!   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
  
    switch (_state) {
      case _empty_committed:
      case _regular:
      case _humongous_start:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 186,11 ***</span>
        report_illegal_transition(&quot;humongous continuation bypass&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_pinned() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
    assert(pin_count() &gt; 0, &quot;Should have pins: &quot; SIZE_FORMAT, pin_count());
  
    switch (_state) {
      case _regular:
        set_state(_pinned);
<span class="line-new-header">--- 188,11 ---</span>
        report_illegal_transition(&quot;humongous continuation bypass&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_pinned() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
    assert(pin_count() &gt; 0, &quot;Should have pins: &quot; SIZE_FORMAT, pin_count());
  
    switch (_state) {
      case _regular:
        set_state(_pinned);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 208,11 ***</span>
        report_illegal_transition(&quot;pinning&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_unpinned() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
    assert(pin_count() == 0, &quot;Should not have pins: &quot; SIZE_FORMAT, pin_count());
  
    switch (_state) {
      case _pinned:
        set_state(_regular);
<span class="line-new-header">--- 210,11 ---</span>
        report_illegal_transition(&quot;pinning&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_unpinned() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
    assert(pin_count() == 0, &quot;Should not have pins: &quot; SIZE_FORMAT, pin_count());
  
    switch (_state) {
      case _pinned:
        set_state(_regular);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 230,11 ***</span>
        report_illegal_transition(&quot;unpinning&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_cset() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
    switch (_state) {
      case _regular:
        set_state(_cset);
      case _cset:
        return;
<span class="line-new-header">--- 232,11 ---</span>
        report_illegal_transition(&quot;unpinning&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_cset() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
    switch (_state) {
      case _regular:
        set_state(_cset);
      case _cset:
        return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 242,11 ***</span>
        report_illegal_transition(&quot;cset&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_trash() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
    switch (_state) {
      case _cset:
        // Reclaiming cset regions
      case _humongous_start:
      case _humongous_cont:
<span class="line-new-header">--- 244,11 ---</span>
        report_illegal_transition(&quot;cset&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_trash() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
    switch (_state) {
      case _cset:
        // Reclaiming cset regions
      case _humongous_start:
      case _humongous_cont:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 263,15 ***</span>
  void ShenandoahHeapRegion::make_trash_immediate() {
    make_trash();
  
    // On this path, we know there are no marked objects in the region,
    // tell marking context about it to bypass bitmap resets.
<span class="line-modified">!   _heap-&gt;complete_marking_context()-&gt;reset_top_bitmap(this);</span>
  }
  
  void ShenandoahHeapRegion::make_empty() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
    switch (_state) {
      case _trash:
        set_state(_empty_committed);
        _empty_time = os::elapsedTime();
        return;
<span class="line-new-header">--- 265,15 ---</span>
  void ShenandoahHeapRegion::make_trash_immediate() {
    make_trash();
  
    // On this path, we know there are no marked objects in the region,
    // tell marking context about it to bypass bitmap resets.
<span class="line-modified">!   ShenandoahHeap::heap()-&gt;complete_marking_context()-&gt;reset_top_bitmap(this);</span>
  }
  
  void ShenandoahHeapRegion::make_empty() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
    switch (_state) {
      case _trash:
        set_state(_empty_committed);
        _empty_time = os::elapsedTime();
        return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 279,11 ***</span>
        report_illegal_transition(&quot;emptying&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_uncommitted() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
    switch (_state) {
      case _empty_committed:
        do_uncommit();
        set_state(_empty_uncommitted);
        return;
<span class="line-new-header">--- 281,11 ---</span>
        report_illegal_transition(&quot;emptying&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_uncommitted() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
    switch (_state) {
      case _empty_committed:
        do_uncommit();
        set_state(_empty_uncommitted);
        return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 291,12 ***</span>
        report_illegal_transition(&quot;uncommiting&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_committed_bypass() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
<span class="line-modified">!   assert (_heap-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
  
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
        set_state(_empty_committed);
<span class="line-new-header">--- 293,12 ---</span>
        report_illegal_transition(&quot;uncommiting&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_committed_bypass() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
<span class="line-modified">!   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
  
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
        set_state(_empty_committed);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 312,31 ***</span>
  
  void ShenandoahHeapRegion::reset_alloc_metadata() {
    _tlab_allocs = 0;
    _gclab_allocs = 0;
    _shared_allocs = 0;
<span class="line-removed">-   _seqnum_first_alloc_mutator = 0;</span>
    _seqnum_last_alloc_mutator = 0;
<span class="line-removed">-   _seqnum_first_alloc_gc = 0;</span>
<span class="line-removed">-   _seqnum_last_alloc_gc = 0;</span>
  }
  
  void ShenandoahHeapRegion::reset_alloc_metadata_to_shared() {
    if (used() &gt; 0) {
      _tlab_allocs = 0;
      _gclab_allocs = 0;
      _shared_allocs = used() &gt;&gt; LogHeapWordSize;
<span class="line-modified">!     uint64_t next = _alloc_seq_num.value++;</span>
<span class="line-modified">!     _seqnum_first_alloc_mutator = next;</span>
<span class="line-modified">!     _seqnum_last_alloc_mutator = next;</span>
<span class="line-removed">-     _seqnum_first_alloc_gc = 0;</span>
<span class="line-removed">-     _seqnum_last_alloc_gc = 0;</span>
    } else {
      reset_alloc_metadata();
    }
  }
  
  size_t ShenandoahHeapRegion::get_shared_allocs() const {
    return _shared_allocs * HeapWordSize;
  }
  
  size_t ShenandoahHeapRegion::get_tlab_allocs() const {
<span class="line-new-header">--- 314,32 ---</span>
  
  void ShenandoahHeapRegion::reset_alloc_metadata() {
    _tlab_allocs = 0;
    _gclab_allocs = 0;
    _shared_allocs = 0;
    _seqnum_last_alloc_mutator = 0;
  }
  
  void ShenandoahHeapRegion::reset_alloc_metadata_to_shared() {
    if (used() &gt; 0) {
      _tlab_allocs = 0;
      _gclab_allocs = 0;
      _shared_allocs = used() &gt;&gt; LogHeapWordSize;
<span class="line-modified">!     if (ShenandoahHeap::heap()-&gt;is_traversal_mode()) {</span>
<span class="line-modified">!       update_seqnum_last_alloc_mutator();</span>
<span class="line-modified">!     }</span>
    } else {
      reset_alloc_metadata();
    }
  }
  
<span class="line-added">+ void ShenandoahHeapRegion::update_seqnum_last_alloc_mutator() {</span>
<span class="line-added">+   assert(ShenandoahHeap::heap()-&gt;is_traversal_mode(), &quot;Sanity&quot;);</span>
<span class="line-added">+   shenandoah_assert_heaplocked_or_safepoint();</span>
<span class="line-added">+   _seqnum_last_alloc_mutator = _alloc_seq_num.value++;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  size_t ShenandoahHeapRegion::get_shared_allocs() const {
    return _shared_allocs * HeapWordSize;
  }
  
  size_t ShenandoahHeapRegion::get_tlab_allocs() const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 411,20 ***</span>
        ShouldNotReachHere();
    }
    st-&gt;print(&quot;|BTE &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12),
              p2i(bottom()), p2i(top()), p2i(end()));
    st-&gt;print(&quot;|TAMS &quot; INTPTR_FORMAT_W(12),
<span class="line-modified">!             p2i(_heap-&gt;marking_context()-&gt;top_at_mark_start(const_cast&lt;ShenandoahHeapRegion*&gt;(this))));</span>
    st-&gt;print(&quot;|U &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(used()),                proper_unit_for_byte_size(used()));
    st-&gt;print(&quot;|T &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_tlab_allocs()),     proper_unit_for_byte_size(get_tlab_allocs()));
    st-&gt;print(&quot;|G &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_gclab_allocs()),    proper_unit_for_byte_size(get_gclab_allocs()));
    st-&gt;print(&quot;|S &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_shared_allocs()),   proper_unit_for_byte_size(get_shared_allocs()));
    st-&gt;print(&quot;|L &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_live_data_bytes()), proper_unit_for_byte_size(get_live_data_bytes()));
    st-&gt;print(&quot;|CP &quot; SIZE_FORMAT_W(3), pin_count());
<span class="line-modified">!   st-&gt;print(&quot;|SN &quot; UINT64_FORMAT_X_W(12) &quot;, &quot; UINT64_FORMAT_X_W(8) &quot;, &quot; UINT64_FORMAT_X_W(8) &quot;, &quot; UINT64_FORMAT_X_W(8),</span>
<span class="line-removed">-             seqnum_first_alloc_mutator(), seqnum_last_alloc_mutator(),</span>
<span class="line-removed">-             seqnum_first_alloc_gc(), seqnum_last_alloc_gc());</span>
    st-&gt;cr();
  }
  
  void ShenandoahHeapRegion::oop_iterate(OopIterateClosure* blk) {
    if (!is_active()) return;
<span class="line-new-header">--- 414,20 ---</span>
        ShouldNotReachHere();
    }
    st-&gt;print(&quot;|BTE &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12),
              p2i(bottom()), p2i(top()), p2i(end()));
    st-&gt;print(&quot;|TAMS &quot; INTPTR_FORMAT_W(12),
<span class="line-modified">!             p2i(ShenandoahHeap::heap()-&gt;marking_context()-&gt;top_at_mark_start(const_cast&lt;ShenandoahHeapRegion*&gt;(this))));</span>
<span class="line-added">+   st-&gt;print(&quot;|UWM &quot; INTPTR_FORMAT_W(12),</span>
<span class="line-added">+             p2i(_update_watermark));</span>
    st-&gt;print(&quot;|U &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(used()),                proper_unit_for_byte_size(used()));
    st-&gt;print(&quot;|T &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_tlab_allocs()),     proper_unit_for_byte_size(get_tlab_allocs()));
    st-&gt;print(&quot;|G &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_gclab_allocs()),    proper_unit_for_byte_size(get_gclab_allocs()));
    st-&gt;print(&quot;|S &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_shared_allocs()),   proper_unit_for_byte_size(get_shared_allocs()));
    st-&gt;print(&quot;|L &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_live_data_bytes()), proper_unit_for_byte_size(get_live_data_bytes()));
    st-&gt;print(&quot;|CP &quot; SIZE_FORMAT_W(3), pin_count());
<span class="line-modified">!   st-&gt;print(&quot;|SN &quot; UINT64_FORMAT_X_W(12), _seqnum_last_alloc_mutator);</span>
    st-&gt;cr();
  }
  
  void ShenandoahHeapRegion::oop_iterate(OopIterateClosure* blk) {
    if (!is_active()) return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 454,38 ***</span>
    oop obj = oop(r-&gt;bottom());
    obj-&gt;oop_iterate(blk, MemRegion(bottom(), top()));
  }
  
  ShenandoahHeapRegion* ShenandoahHeapRegion::humongous_start_region() const {
    assert(is_humongous(), &quot;Must be a part of the humongous region&quot;);
    size_t reg_num = region_number();
    ShenandoahHeapRegion* r = const_cast&lt;ShenandoahHeapRegion*&gt;(this);
    while (!r-&gt;is_humongous_start()) {
      assert(reg_num &gt; 0, &quot;Sanity&quot;);
      reg_num --;
<span class="line-modified">!     r = _heap-&gt;get_region(reg_num);</span>
      assert(r-&gt;is_humongous(), &quot;Must be a part of the humongous region&quot;);
    }
    assert(r-&gt;is_humongous_start(), &quot;Must be&quot;);
    return r;
  }
  
  void ShenandoahHeapRegion::recycle() {
<span class="line-modified">!   ContiguousSpace::clear(false);</span>
<span class="line-removed">-   if (ZapUnusedHeapArea) {</span>
<span class="line-removed">-     ContiguousSpace::mangle_unused_area_complete();</span>
<span class="line-removed">-   }</span>
    clear_live_data();
  
    reset_alloc_metadata();
  
<span class="line-modified">!   _heap-&gt;marking_context()-&gt;reset_top_at_mark_start(this);</span>
  
    make_empty();
  }
  
<span class="line-modified">! HeapWord* ShenandoahHeapRegion::block_start_const(const void* p) const {</span>
    assert(MemRegion(bottom(), end()).contains(p),
           &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
           p2i(p), p2i(bottom()), p2i(end()));
    if (p &gt;= top()) {
      return top();
<span class="line-new-header">--- 457,41 ---</span>
    oop obj = oop(r-&gt;bottom());
    obj-&gt;oop_iterate(blk, MemRegion(bottom(), top()));
  }
  
  ShenandoahHeapRegion* ShenandoahHeapRegion::humongous_start_region() const {
<span class="line-added">+   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
    assert(is_humongous(), &quot;Must be a part of the humongous region&quot;);
    size_t reg_num = region_number();
    ShenandoahHeapRegion* r = const_cast&lt;ShenandoahHeapRegion*&gt;(this);
    while (!r-&gt;is_humongous_start()) {
      assert(reg_num &gt; 0, &quot;Sanity&quot;);
      reg_num --;
<span class="line-modified">!     r = heap-&gt;get_region(reg_num);</span>
      assert(r-&gt;is_humongous(), &quot;Must be a part of the humongous region&quot;);
    }
    assert(r-&gt;is_humongous_start(), &quot;Must be&quot;);
    return r;
  }
  
  void ShenandoahHeapRegion::recycle() {
<span class="line-modified">!   set_top(bottom());</span>
    clear_live_data();
  
    reset_alloc_metadata();
  
<span class="line-modified">!   ShenandoahHeap::heap()-&gt;marking_context()-&gt;reset_top_at_mark_start(this);</span>
<span class="line-added">+   set_update_watermark(bottom());</span>
  
    make_empty();
<span class="line-added">+ </span>
<span class="line-added">+   if (ZapUnusedHeapArea) {</span>
<span class="line-added">+     SpaceMangler::mangle_region(MemRegion(bottom(), end()));</span>
<span class="line-added">+   }</span>
  }
  
<span class="line-modified">! HeapWord* ShenandoahHeapRegion::block_start(const void* p) const {</span>
    assert(MemRegion(bottom(), end()).contains(p),
           &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
           p2i(p), p2i(bottom()), p2i(end()));
    if (p &gt;= top()) {
      return top();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 499,10 ***</span>
<span class="line-new-header">--- 505,22 ---</span>
      shenandoah_assert_correct(NULL, oop(last));
      return last;
    }
  }
  
<span class="line-added">+ size_t ShenandoahHeapRegion::block_size(const HeapWord* p) const {</span>
<span class="line-added">+   assert(MemRegion(bottom(), end()).contains(p),</span>
<span class="line-added">+          &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,</span>
<span class="line-added">+          p2i(p), p2i(bottom()), p2i(end()));</span>
<span class="line-added">+   if (p &lt; top()) {</span>
<span class="line-added">+     return oop(p)-&gt;size();</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     assert(p == top(), &quot;just checking&quot;);</span>
<span class="line-added">+     return pointer_delta(end(), (HeapWord*) p);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void ShenandoahHeapRegion::setup_sizes(size_t max_heap_size) {
    // Absolute minimums we should not ever break.
    static const size_t MIN_REGION_SIZE = 256*K;
  
    if (FLAG_IS_DEFAULT(ShenandoahMinRegionSize)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 654,27 ***</span>
    log_info(gc, init)(&quot;Max TLAB size: &quot; SIZE_FORMAT &quot;%s&quot;,
                       byte_size_in_proper_unit(MaxTLABSizeBytes), proper_unit_for_byte_size(MaxTLABSizeBytes));
  }
  
  void ShenandoahHeapRegion::do_commit() {
<span class="line-modified">!   if (!_heap-&gt;is_heap_region_special() &amp;&amp; !os::commit_memory((char *) _reserved.start(), _reserved.byte_size(), false)) {</span>
      report_java_out_of_memory(&quot;Unable to commit region&quot;);
    }
<span class="line-modified">!   if (!_heap-&gt;commit_bitmap_slice(this)) {</span>
      report_java_out_of_memory(&quot;Unable to commit bitmaps for region&quot;);
    }
<span class="line-modified">!   _heap-&gt;increase_committed(ShenandoahHeapRegion::region_size_bytes());</span>
  }
  
  void ShenandoahHeapRegion::do_uncommit() {
<span class="line-modified">!   if (!_heap-&gt;is_heap_region_special() &amp;&amp; !os::uncommit_memory((char *) _reserved.start(), _reserved.byte_size())) {</span>
      report_java_out_of_memory(&quot;Unable to uncommit region&quot;);
    }
<span class="line-modified">!   if (!_heap-&gt;uncommit_bitmap_slice(this)) {</span>
      report_java_out_of_memory(&quot;Unable to uncommit bitmaps for region&quot;);
    }
<span class="line-modified">!   _heap-&gt;decrease_committed(ShenandoahHeapRegion::region_size_bytes());</span>
  }
  
  void ShenandoahHeapRegion::set_state(RegionState to) {
    EventShenandoahHeapRegionStateChange evt;
    if (evt.should_commit()){
<span class="line-new-header">--- 672,29 ---</span>
    log_info(gc, init)(&quot;Max TLAB size: &quot; SIZE_FORMAT &quot;%s&quot;,
                       byte_size_in_proper_unit(MaxTLABSizeBytes), proper_unit_for_byte_size(MaxTLABSizeBytes));
  }
  
  void ShenandoahHeapRegion::do_commit() {
<span class="line-modified">!   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-added">+   if (!heap-&gt;is_heap_region_special() &amp;&amp; !os::commit_memory((char *) bottom(), RegionSizeBytes, false)) {</span>
      report_java_out_of_memory(&quot;Unable to commit region&quot;);
    }
<span class="line-modified">!   if (!heap-&gt;commit_bitmap_slice(this)) {</span>
      report_java_out_of_memory(&quot;Unable to commit bitmaps for region&quot;);
    }
<span class="line-modified">!   heap-&gt;increase_committed(ShenandoahHeapRegion::region_size_bytes());</span>
  }
  
  void ShenandoahHeapRegion::do_uncommit() {
<span class="line-modified">!   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-added">+   if (!heap-&gt;is_heap_region_special() &amp;&amp; !os::uncommit_memory((char *) bottom(), RegionSizeBytes)) {</span>
      report_java_out_of_memory(&quot;Unable to uncommit region&quot;);
    }
<span class="line-modified">!   if (!heap-&gt;uncommit_bitmap_slice(this)) {</span>
      report_java_out_of_memory(&quot;Unable to uncommit bitmaps for region&quot;);
    }
<span class="line-modified">!   heap-&gt;decrease_committed(ShenandoahHeapRegion::region_size_bytes());</span>
  }
  
  void ShenandoahHeapRegion::set_state(RegionState to) {
    EventShenandoahHeapRegionStateChange evt;
    if (evt.should_commit()){
</pre>
<center><a href="shenandoahHeap.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
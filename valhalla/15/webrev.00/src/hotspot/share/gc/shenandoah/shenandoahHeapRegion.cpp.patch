diff a/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp b/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
@@ -53,29 +53,31 @@
 size_t ShenandoahHeapRegion::MaxTLABSizeBytes = 0;
 size_t ShenandoahHeapRegion::MaxTLABSizeWords = 0;
 
 ShenandoahHeapRegion::PaddedAllocSeqNum ShenandoahHeapRegion::_alloc_seq_num;
 
-ShenandoahHeapRegion::ShenandoahHeapRegion(ShenandoahHeap* heap, HeapWord* start,
-                                           size_t size_words, size_t index, bool committed) :
-  _heap(heap),
-  _reserved(MemRegion(start, size_words)),
+ShenandoahHeapRegion::ShenandoahHeapRegion(HeapWord* start, size_t index, bool committed) :
   _region_number(index),
+  _bottom(start),
+  _end(start + RegionSizeWords),
   _new_top(NULL),
   _empty_time(os::elapsedTime()),
   _state(committed ? _empty_committed : _empty_uncommitted),
+  _top(start),
   _tlab_allocs(0),
   _gclab_allocs(0),
   _shared_allocs(0),
-  _seqnum_first_alloc_mutator(0),
-  _seqnum_first_alloc_gc(0),
   _seqnum_last_alloc_mutator(0),
-  _seqnum_last_alloc_gc(0),
   _live_data(0),
-  _critical_pins(0) {
+  _critical_pins(0),
+  _update_watermark(start) {
 
-  ContiguousSpace::initialize(_reserved, true, committed);
+  assert(Universe::on_page_boundary(_bottom) && Universe::on_page_boundary(_end),
+         "invalid space boundaries");
+  if (ZapUnusedHeapArea && committed) {
+    SpaceMangler::mangle_region(MemRegion(_bottom, _end));
+  }
 }
 
 size_t ShenandoahHeapRegion::region_number() const {
   return _region_number;
 }
@@ -87,11 +89,11 @@
   print_on(&ss);
   fatal("%s", ss.as_string());
 }
 
 void ShenandoahHeapRegion::make_regular_allocation() {
-  _heap->assert_heaplock_owned_by_current_thread();
+  shenandoah_assert_heaplocked();
 
   switch (_state) {
     case _empty_uncommitted:
       do_commit();
     case _empty_committed:
@@ -103,12 +105,12 @@
       report_illegal_transition("regular allocation");
   }
 }
 
 void ShenandoahHeapRegion::make_regular_bypass() {
-  _heap->assert_heaplock_owned_by_current_thread();
-  assert (_heap->is_full_gc_in_progress() || _heap->is_degenerated_gc_in_progress(),
+  shenandoah_assert_heaplocked();
+  assert (ShenandoahHeap::heap()->is_full_gc_in_progress() || ShenandoahHeap::heap()->is_degenerated_gc_in_progress(),
           "only for full or degen GC");
 
   switch (_state) {
     case _empty_uncommitted:
       do_commit();
@@ -128,11 +130,11 @@
       report_illegal_transition("regular bypass");
   }
 }
 
 void ShenandoahHeapRegion::make_humongous_start() {
-  _heap->assert_heaplock_owned_by_current_thread();
+  shenandoah_assert_heaplocked();
   switch (_state) {
     case _empty_uncommitted:
       do_commit();
     case _empty_committed:
       set_state(_humongous_start);
@@ -141,12 +143,12 @@
       report_illegal_transition("humongous start allocation");
   }
 }
 
 void ShenandoahHeapRegion::make_humongous_start_bypass() {
-  _heap->assert_heaplock_owned_by_current_thread();
-  assert (_heap->is_full_gc_in_progress(), "only for full GC");
+  shenandoah_assert_heaplocked();
+  assert (ShenandoahHeap::heap()->is_full_gc_in_progress(), "only for full GC");
 
   switch (_state) {
     case _empty_committed:
     case _regular:
     case _humongous_start:
@@ -157,11 +159,11 @@
       report_illegal_transition("humongous start bypass");
   }
 }
 
 void ShenandoahHeapRegion::make_humongous_cont() {
-  _heap->assert_heaplock_owned_by_current_thread();
+  shenandoah_assert_heaplocked();
   switch (_state) {
     case _empty_uncommitted:
       do_commit();
     case _empty_committed:
      set_state(_humongous_cont);
@@ -170,12 +172,12 @@
       report_illegal_transition("humongous continuation allocation");
   }
 }
 
 void ShenandoahHeapRegion::make_humongous_cont_bypass() {
-  _heap->assert_heaplock_owned_by_current_thread();
-  assert (_heap->is_full_gc_in_progress(), "only for full GC");
+  shenandoah_assert_heaplocked();
+  assert (ShenandoahHeap::heap()->is_full_gc_in_progress(), "only for full GC");
 
   switch (_state) {
     case _empty_committed:
     case _regular:
     case _humongous_start:
@@ -186,11 +188,11 @@
       report_illegal_transition("humongous continuation bypass");
   }
 }
 
 void ShenandoahHeapRegion::make_pinned() {
-  _heap->assert_heaplock_owned_by_current_thread();
+  shenandoah_assert_heaplocked();
   assert(pin_count() > 0, "Should have pins: " SIZE_FORMAT, pin_count());
 
   switch (_state) {
     case _regular:
       set_state(_pinned);
@@ -208,11 +210,11 @@
       report_illegal_transition("pinning");
   }
 }
 
 void ShenandoahHeapRegion::make_unpinned() {
-  _heap->assert_heaplock_owned_by_current_thread();
+  shenandoah_assert_heaplocked();
   assert(pin_count() == 0, "Should not have pins: " SIZE_FORMAT, pin_count());
 
   switch (_state) {
     case _pinned:
       set_state(_regular);
@@ -230,11 +232,11 @@
       report_illegal_transition("unpinning");
   }
 }
 
 void ShenandoahHeapRegion::make_cset() {
-  _heap->assert_heaplock_owned_by_current_thread();
+  shenandoah_assert_heaplocked();
   switch (_state) {
     case _regular:
       set_state(_cset);
     case _cset:
       return;
@@ -242,11 +244,11 @@
       report_illegal_transition("cset");
   }
 }
 
 void ShenandoahHeapRegion::make_trash() {
-  _heap->assert_heaplock_owned_by_current_thread();
+  shenandoah_assert_heaplocked();
   switch (_state) {
     case _cset:
       // Reclaiming cset regions
     case _humongous_start:
     case _humongous_cont:
@@ -263,15 +265,15 @@
 void ShenandoahHeapRegion::make_trash_immediate() {
   make_trash();
 
   // On this path, we know there are no marked objects in the region,
   // tell marking context about it to bypass bitmap resets.
-  _heap->complete_marking_context()->reset_top_bitmap(this);
+  ShenandoahHeap::heap()->complete_marking_context()->reset_top_bitmap(this);
 }
 
 void ShenandoahHeapRegion::make_empty() {
-  _heap->assert_heaplock_owned_by_current_thread();
+  shenandoah_assert_heaplocked();
   switch (_state) {
     case _trash:
       set_state(_empty_committed);
       _empty_time = os::elapsedTime();
       return;
@@ -279,11 +281,11 @@
       report_illegal_transition("emptying");
   }
 }
 
 void ShenandoahHeapRegion::make_uncommitted() {
-  _heap->assert_heaplock_owned_by_current_thread();
+  shenandoah_assert_heaplocked();
   switch (_state) {
     case _empty_committed:
       do_uncommit();
       set_state(_empty_uncommitted);
       return;
@@ -291,12 +293,12 @@
       report_illegal_transition("uncommiting");
   }
 }
 
 void ShenandoahHeapRegion::make_committed_bypass() {
-  _heap->assert_heaplock_owned_by_current_thread();
-  assert (_heap->is_full_gc_in_progress(), "only for full GC");
+  shenandoah_assert_heaplocked();
+  assert (ShenandoahHeap::heap()->is_full_gc_in_progress(), "only for full GC");
 
   switch (_state) {
     case _empty_uncommitted:
       do_commit();
       set_state(_empty_committed);
@@ -312,31 +314,32 @@
 
 void ShenandoahHeapRegion::reset_alloc_metadata() {
   _tlab_allocs = 0;
   _gclab_allocs = 0;
   _shared_allocs = 0;
-  _seqnum_first_alloc_mutator = 0;
   _seqnum_last_alloc_mutator = 0;
-  _seqnum_first_alloc_gc = 0;
-  _seqnum_last_alloc_gc = 0;
 }
 
 void ShenandoahHeapRegion::reset_alloc_metadata_to_shared() {
   if (used() > 0) {
     _tlab_allocs = 0;
     _gclab_allocs = 0;
     _shared_allocs = used() >> LogHeapWordSize;
-    uint64_t next = _alloc_seq_num.value++;
-    _seqnum_first_alloc_mutator = next;
-    _seqnum_last_alloc_mutator = next;
-    _seqnum_first_alloc_gc = 0;
-    _seqnum_last_alloc_gc = 0;
+    if (ShenandoahHeap::heap()->is_traversal_mode()) {
+      update_seqnum_last_alloc_mutator();
+    }
   } else {
     reset_alloc_metadata();
   }
 }
 
+void ShenandoahHeapRegion::update_seqnum_last_alloc_mutator() {
+  assert(ShenandoahHeap::heap()->is_traversal_mode(), "Sanity");
+  shenandoah_assert_heaplocked_or_safepoint();
+  _seqnum_last_alloc_mutator = _alloc_seq_num.value++;
+}
+
 size_t ShenandoahHeapRegion::get_shared_allocs() const {
   return _shared_allocs * HeapWordSize;
 }
 
 size_t ShenandoahHeapRegion::get_tlab_allocs() const {
@@ -411,20 +414,20 @@
       ShouldNotReachHere();
   }
   st->print("|BTE " INTPTR_FORMAT_W(12) ", " INTPTR_FORMAT_W(12) ", " INTPTR_FORMAT_W(12),
             p2i(bottom()), p2i(top()), p2i(end()));
   st->print("|TAMS " INTPTR_FORMAT_W(12),
-            p2i(_heap->marking_context()->top_at_mark_start(const_cast<ShenandoahHeapRegion*>(this))));
+            p2i(ShenandoahHeap::heap()->marking_context()->top_at_mark_start(const_cast<ShenandoahHeapRegion*>(this))));
+  st->print("|UWM " INTPTR_FORMAT_W(12),
+            p2i(_update_watermark));
   st->print("|U " SIZE_FORMAT_W(5) "%1s", byte_size_in_proper_unit(used()),                proper_unit_for_byte_size(used()));
   st->print("|T " SIZE_FORMAT_W(5) "%1s", byte_size_in_proper_unit(get_tlab_allocs()),     proper_unit_for_byte_size(get_tlab_allocs()));
   st->print("|G " SIZE_FORMAT_W(5) "%1s", byte_size_in_proper_unit(get_gclab_allocs()),    proper_unit_for_byte_size(get_gclab_allocs()));
   st->print("|S " SIZE_FORMAT_W(5) "%1s", byte_size_in_proper_unit(get_shared_allocs()),   proper_unit_for_byte_size(get_shared_allocs()));
   st->print("|L " SIZE_FORMAT_W(5) "%1s", byte_size_in_proper_unit(get_live_data_bytes()), proper_unit_for_byte_size(get_live_data_bytes()));
   st->print("|CP " SIZE_FORMAT_W(3), pin_count());
-  st->print("|SN " UINT64_FORMAT_X_W(12) ", " UINT64_FORMAT_X_W(8) ", " UINT64_FORMAT_X_W(8) ", " UINT64_FORMAT_X_W(8),
-            seqnum_first_alloc_mutator(), seqnum_last_alloc_mutator(),
-            seqnum_first_alloc_gc(), seqnum_last_alloc_gc());
+  st->print("|SN " UINT64_FORMAT_X_W(12), _seqnum_last_alloc_mutator);
   st->cr();
 }
 
 void ShenandoahHeapRegion::oop_iterate(OopIterateClosure* blk) {
   if (!is_active()) return;
@@ -454,38 +457,41 @@
   oop obj = oop(r->bottom());
   obj->oop_iterate(blk, MemRegion(bottom(), top()));
 }
 
 ShenandoahHeapRegion* ShenandoahHeapRegion::humongous_start_region() const {
+  ShenandoahHeap* heap = ShenandoahHeap::heap();
   assert(is_humongous(), "Must be a part of the humongous region");
   size_t reg_num = region_number();
   ShenandoahHeapRegion* r = const_cast<ShenandoahHeapRegion*>(this);
   while (!r->is_humongous_start()) {
     assert(reg_num > 0, "Sanity");
     reg_num --;
-    r = _heap->get_region(reg_num);
+    r = heap->get_region(reg_num);
     assert(r->is_humongous(), "Must be a part of the humongous region");
   }
   assert(r->is_humongous_start(), "Must be");
   return r;
 }
 
 void ShenandoahHeapRegion::recycle() {
-  ContiguousSpace::clear(false);
-  if (ZapUnusedHeapArea) {
-    ContiguousSpace::mangle_unused_area_complete();
-  }
+  set_top(bottom());
   clear_live_data();
 
   reset_alloc_metadata();
 
-  _heap->marking_context()->reset_top_at_mark_start(this);
+  ShenandoahHeap::heap()->marking_context()->reset_top_at_mark_start(this);
+  set_update_watermark(bottom());
 
   make_empty();
+
+  if (ZapUnusedHeapArea) {
+    SpaceMangler::mangle_region(MemRegion(bottom(), end()));
+  }
 }
 
-HeapWord* ShenandoahHeapRegion::block_start_const(const void* p) const {
+HeapWord* ShenandoahHeapRegion::block_start(const void* p) const {
   assert(MemRegion(bottom(), end()).contains(p),
          "p (" PTR_FORMAT ") not in space [" PTR_FORMAT ", " PTR_FORMAT ")",
          p2i(p), p2i(bottom()), p2i(end()));
   if (p >= top()) {
     return top();
@@ -499,10 +505,22 @@
     shenandoah_assert_correct(NULL, oop(last));
     return last;
   }
 }
 
+size_t ShenandoahHeapRegion::block_size(const HeapWord* p) const {
+  assert(MemRegion(bottom(), end()).contains(p),
+         "p (" PTR_FORMAT ") not in space [" PTR_FORMAT ", " PTR_FORMAT ")",
+         p2i(p), p2i(bottom()), p2i(end()));
+  if (p < top()) {
+    return oop(p)->size();
+  } else {
+    assert(p == top(), "just checking");
+    return pointer_delta(end(), (HeapWord*) p);
+  }
+}
+
 void ShenandoahHeapRegion::setup_sizes(size_t max_heap_size) {
   // Absolute minimums we should not ever break.
   static const size_t MIN_REGION_SIZE = 256*K;
 
   if (FLAG_IS_DEFAULT(ShenandoahMinRegionSize)) {
@@ -654,27 +672,29 @@
   log_info(gc, init)("Max TLAB size: " SIZE_FORMAT "%s",
                      byte_size_in_proper_unit(MaxTLABSizeBytes), proper_unit_for_byte_size(MaxTLABSizeBytes));
 }
 
 void ShenandoahHeapRegion::do_commit() {
-  if (!_heap->is_heap_region_special() && !os::commit_memory((char *) _reserved.start(), _reserved.byte_size(), false)) {
+  ShenandoahHeap* heap = ShenandoahHeap::heap();
+  if (!heap->is_heap_region_special() && !os::commit_memory((char *) bottom(), RegionSizeBytes, false)) {
     report_java_out_of_memory("Unable to commit region");
   }
-  if (!_heap->commit_bitmap_slice(this)) {
+  if (!heap->commit_bitmap_slice(this)) {
     report_java_out_of_memory("Unable to commit bitmaps for region");
   }
-  _heap->increase_committed(ShenandoahHeapRegion::region_size_bytes());
+  heap->increase_committed(ShenandoahHeapRegion::region_size_bytes());
 }
 
 void ShenandoahHeapRegion::do_uncommit() {
-  if (!_heap->is_heap_region_special() && !os::uncommit_memory((char *) _reserved.start(), _reserved.byte_size())) {
+  ShenandoahHeap* heap = ShenandoahHeap::heap();
+  if (!heap->is_heap_region_special() && !os::uncommit_memory((char *) bottom(), RegionSizeBytes)) {
     report_java_out_of_memory("Unable to uncommit region");
   }
-  if (!_heap->uncommit_bitmap_slice(this)) {
+  if (!heap->uncommit_bitmap_slice(this)) {
     report_java_out_of_memory("Unable to uncommit bitmaps for region");
   }
-  _heap->decrease_committed(ShenandoahHeapRegion::region_size_bytes());
+  heap->decrease_committed(ShenandoahHeapRegion::region_size_bytes());
 }
 
 void ShenandoahHeapRegion::set_state(RegionState to) {
   EventShenandoahHeapRegionStateChange evt;
   if (evt.should_commit()){

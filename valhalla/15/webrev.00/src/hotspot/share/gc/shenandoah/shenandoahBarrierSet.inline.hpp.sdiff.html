<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahBarrierSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetClone.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 32 #include &quot;gc/shenandoah/shenandoahForwarding.inline.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
 35 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 36 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
 37 #include &quot;memory/iterator.inline.hpp&quot;
 38 #include &quot;oops/oop.inline.hpp&quot;
 39 
 40 inline oop ShenandoahBarrierSet::resolve_forwarded_not_null(oop p) {
 41   return ShenandoahForwarding::get_forwardee(p);
 42 }
 43 
 44 inline oop ShenandoahBarrierSet::resolve_forwarded(oop p) {
 45   if (p != NULL) {
 46     return resolve_forwarded_not_null(p);
 47   } else {
 48     return p;
 49   }
 50 }
 51 




 52 inline void ShenandoahBarrierSet::enqueue(oop obj) {
 53   shenandoah_assert_not_forwarded_if(NULL, obj, _heap-&gt;is_concurrent_traversal_in_progress());
 54   assert(_satb_mark_queue_set.is_active(), &quot;only get here when SATB active&quot;);
 55 
 56   // Filter marked objects before hitting the SATB queues. The same predicate would
 57   // be used by SATBMQ::filter to eliminate already marked objects downstream, but
 58   // filtering here helps to avoid wasteful SATB queueing work to begin with.
 59   if (!_heap-&gt;requires_marking&lt;false&gt;(obj)) return;
 60 
 61   ShenandoahThreadLocalData::satb_mark_queue(Thread::current()).enqueue_known_active(obj);
 62 }
 63 
 64 template &lt;DecoratorSet decorators, typename T&gt;
 65 inline void ShenandoahBarrierSet::satb_barrier(T *field) {
 66   if (HasDecorator&lt;decorators, IS_DEST_UNINITIALIZED&gt;::value ||
 67       HasDecorator&lt;decorators, AS_NO_KEEPALIVE&gt;::value) {
 68     return;
 69   }
 70   if (ShenandoahSATBBarrier &amp;&amp; _heap-&gt;is_concurrent_mark_in_progress()) {
 71     T heap_oop = RawAccess&lt;&gt;::oop_load(field);
 72     if (!CompressedOops::is_null(heap_oop)) {
 73       enqueue(CompressedOops::decode(heap_oop));
 74     }
 75   }
 76 }
 77 
 78 inline void ShenandoahBarrierSet::satb_enqueue(oop value) {
 79   assert(value != NULL, &quot;checked before&quot;);
 80   if (ShenandoahSATBBarrier &amp;&amp; _heap-&gt;is_concurrent_mark_in_progress()) {
 81     enqueue(value);
 82   }
 83 }
 84 
 85 inline void ShenandoahBarrierSet::storeval_barrier(oop obj) {
 86   if (obj != NULL &amp;&amp; ShenandoahStoreValEnqueueBarrier &amp;&amp; _heap-&gt;is_concurrent_traversal_in_progress()) {
 87     enqueue(obj);
 88   }
 89 }
 90 
<span class="line-removed"> 91 inline void ShenandoahBarrierSet::keep_alive_barrier(oop value) {</span>
<span class="line-removed"> 92   assert(value != NULL, &quot;checked before&quot;);</span>
<span class="line-removed"> 93   if (ShenandoahKeepAliveBarrier &amp;&amp; _heap-&gt;is_concurrent_mark_in_progress()) {</span>
<span class="line-removed"> 94     enqueue(value);</span>
<span class="line-removed"> 95   }</span>
<span class="line-removed"> 96 }</span>
<span class="line-removed"> 97 </span>
 98 inline void ShenandoahBarrierSet::keep_alive_if_weak(DecoratorSet decorators, oop value) {
 99   assert((decorators &amp; ON_UNKNOWN_OOP_REF) == 0, &quot;Reference strength must be known&quot;);
100   const bool on_strong_oop_ref = (decorators &amp; ON_STRONG_OOP_REF) != 0;
101   const bool peek              = (decorators &amp; AS_NO_KEEPALIVE) != 0;
102   if (!peek &amp;&amp; !on_strong_oop_ref) {
<span class="line-modified">103     keep_alive_barrier(value);</span>
104   }
105 }
106 
107 template &lt;DecoratorSet decorators&gt;
108 inline void ShenandoahBarrierSet::keep_alive_if_weak(oop value) {
109   assert((decorators &amp; ON_UNKNOWN_OOP_REF) == 0, &quot;Reference strength must be known&quot;);
110   if (!HasDecorator&lt;decorators, ON_STRONG_OOP_REF&gt;::value &amp;&amp;
111       !HasDecorator&lt;decorators, AS_NO_KEEPALIVE&gt;::value) {
<span class="line-modified">112     keep_alive_barrier(value);</span>
113   }
114 }
115 
116 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
117 template &lt;typename T&gt;
118 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_not_in_heap(T* addr) {
119   oop value = Raw::oop_load_not_in_heap(addr);
120   if (value != NULL) {
121     ShenandoahBarrierSet *const bs = ShenandoahBarrierSet::barrier_set();
122     value = bs-&gt;load_reference_barrier_native(value, addr);
123     if (value != NULL) {
124       bs-&gt;keep_alive_if_weak&lt;decorators&gt;(value);
125     }
126   }
127   return value;
128 }
129 
130 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
131 template &lt;typename T&gt;
132 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_in_heap(T* addr) {
</pre>
<hr />
<pre>
244   if (ShenandoahCloneBarrier) {
245     ShenandoahBarrierSet::barrier_set()-&gt;clone_barrier_runtime(src);
246   }
247   Raw::clone(src, dst, size);
248 }
249 
250 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
251 template &lt;typename T&gt;
252 void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
253                                                                                          arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
254                                                                                          size_t length) {
255   ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();
256   bs-&gt;arraycopy_pre(arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw),
257                     arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw),
258                     length);
259   Raw::oop_arraycopy_in_heap(src_obj, src_offset_in_bytes, src_raw, dst_obj, dst_offset_in_bytes, dst_raw, length);
260 }
261 
262 template &lt;class T, bool HAS_FWD, bool EVAC, bool ENQUEUE&gt;
263 void ShenandoahBarrierSet::arraycopy_work(T* src, size_t count) {


264   Thread* thread = Thread::current();
265   SATBMarkQueue&amp; queue = ShenandoahThreadLocalData::satb_mark_queue(thread);
266   ShenandoahMarkingContext* ctx = _heap-&gt;marking_context();
267   const ShenandoahCollectionSet* const cset = _heap-&gt;collection_set();
268   T* end = src + count;
269   for (T* elem_ptr = src; elem_ptr &lt; end; elem_ptr++) {
270     T o = RawAccess&lt;&gt;::oop_load(elem_ptr);
271     if (!CompressedOops::is_null(o)) {
272       oop obj = CompressedOops::decode_not_null(o);
273       if (HAS_FWD &amp;&amp; cset-&gt;is_in(obj)) {
<span class="line-removed">274         assert(_heap-&gt;has_forwarded_objects(), &quot;only get here with forwarded objects&quot;);</span>
275         oop fwd = resolve_forwarded_not_null(obj);
276         if (EVAC &amp;&amp; obj == fwd) {
277           fwd = _heap-&gt;evacuate_object(obj, thread);
278         }
279         assert(obj != fwd || _heap-&gt;cancelled_gc(), &quot;must be forwarded&quot;);
280         oop witness = ShenandoahHeap::cas_oop(fwd, elem_ptr, o);
281         obj = fwd;
282       }
283       if (ENQUEUE &amp;&amp; !ctx-&gt;is_marked(obj)) {
284         queue.enqueue_known_active(obj);
285       }
286     }
287   }
288 }
289 
290 template &lt;class T&gt;
291 void ShenandoahBarrierSet::arraycopy_pre_work(T* src, T* dst, size_t count) {
<span class="line-modified">292   if (_heap-&gt;is_concurrent_mark_in_progress()) {</span>
<span class="line-modified">293     if (_heap-&gt;has_forwarded_objects()) {</span>
<span class="line-modified">294       arraycopy_work&lt;T, true, false, true&gt;(dst, count);</span>
<span class="line-removed">295     } else {</span>
<span class="line-removed">296       arraycopy_work&lt;T, false, false, true&gt;(dst, count);</span>
<span class="line-removed">297     }</span>
298   }
299 
<span class="line-modified">300   arraycopy_update_impl(src, count);</span>


301 }
302 
303 void ShenandoahBarrierSet::arraycopy_pre(oop* src, oop* dst, size_t count) {
304   arraycopy_pre_work(src, dst, count);
305 }
306 
307 void ShenandoahBarrierSet::arraycopy_pre(narrowOop* src, narrowOop* dst, size_t count) {
308   arraycopy_pre_work(src, dst, count);
309 }
310 




311 template &lt;class T&gt;
312 void ShenandoahBarrierSet::arraycopy_update_impl(T* src, size_t count) {

313   if (_heap-&gt;is_evacuation_in_progress()) {
314     ShenandoahEvacOOMScope oom_evac;
315     arraycopy_work&lt;T, true, true, false&gt;(src, count);
316   } else if (_heap-&gt;is_concurrent_traversal_in_progress()){
317     ShenandoahEvacOOMScope oom_evac;
318     arraycopy_work&lt;T, true, true, true&gt;(src, count);
319   } else if (_heap-&gt;has_forwarded_objects()) {
320     arraycopy_work&lt;T, true, false, false&gt;(src, count);
321   }
322 }
323 
324 void ShenandoahBarrierSet::arraycopy_update(oop* src, size_t count) {
325   arraycopy_update_impl(src, count);
326 }
327 
328 void ShenandoahBarrierSet::arraycopy_update(narrowOop* src, size_t count) {
329   arraycopy_update_impl(src, count);
330 }
331 
332 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSET_INLINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 32 #include &quot;gc/shenandoah/shenandoahForwarding.inline.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
 35 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 36 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
 37 #include &quot;memory/iterator.inline.hpp&quot;
 38 #include &quot;oops/oop.inline.hpp&quot;
 39 
 40 inline oop ShenandoahBarrierSet::resolve_forwarded_not_null(oop p) {
 41   return ShenandoahForwarding::get_forwardee(p);
 42 }
 43 
 44 inline oop ShenandoahBarrierSet::resolve_forwarded(oop p) {
 45   if (p != NULL) {
 46     return resolve_forwarded_not_null(p);
 47   } else {
 48     return p;
 49   }
 50 }
 51 
<span class="line-added"> 52 inline oop ShenandoahBarrierSet::resolve_forwarded_not_null_mutator(oop p) {</span>
<span class="line-added"> 53   return ShenandoahForwarding::get_forwardee_mutator(p);</span>
<span class="line-added"> 54 }</span>
<span class="line-added"> 55 </span>
 56 inline void ShenandoahBarrierSet::enqueue(oop obj) {
 57   shenandoah_assert_not_forwarded_if(NULL, obj, _heap-&gt;is_concurrent_traversal_in_progress());
 58   assert(_satb_mark_queue_set.is_active(), &quot;only get here when SATB active&quot;);
 59 
 60   // Filter marked objects before hitting the SATB queues. The same predicate would
 61   // be used by SATBMQ::filter to eliminate already marked objects downstream, but
 62   // filtering here helps to avoid wasteful SATB queueing work to begin with.
 63   if (!_heap-&gt;requires_marking&lt;false&gt;(obj)) return;
 64 
 65   ShenandoahThreadLocalData::satb_mark_queue(Thread::current()).enqueue_known_active(obj);
 66 }
 67 
 68 template &lt;DecoratorSet decorators, typename T&gt;
 69 inline void ShenandoahBarrierSet::satb_barrier(T *field) {
 70   if (HasDecorator&lt;decorators, IS_DEST_UNINITIALIZED&gt;::value ||
 71       HasDecorator&lt;decorators, AS_NO_KEEPALIVE&gt;::value) {
 72     return;
 73   }
 74   if (ShenandoahSATBBarrier &amp;&amp; _heap-&gt;is_concurrent_mark_in_progress()) {
 75     T heap_oop = RawAccess&lt;&gt;::oop_load(field);
 76     if (!CompressedOops::is_null(heap_oop)) {
 77       enqueue(CompressedOops::decode(heap_oop));
 78     }
 79   }
 80 }
 81 
 82 inline void ShenandoahBarrierSet::satb_enqueue(oop value) {
 83   assert(value != NULL, &quot;checked before&quot;);
 84   if (ShenandoahSATBBarrier &amp;&amp; _heap-&gt;is_concurrent_mark_in_progress()) {
 85     enqueue(value);
 86   }
 87 }
 88 
 89 inline void ShenandoahBarrierSet::storeval_barrier(oop obj) {
 90   if (obj != NULL &amp;&amp; ShenandoahStoreValEnqueueBarrier &amp;&amp; _heap-&gt;is_concurrent_traversal_in_progress()) {
 91     enqueue(obj);
 92   }
 93 }
 94 







 95 inline void ShenandoahBarrierSet::keep_alive_if_weak(DecoratorSet decorators, oop value) {
 96   assert((decorators &amp; ON_UNKNOWN_OOP_REF) == 0, &quot;Reference strength must be known&quot;);
 97   const bool on_strong_oop_ref = (decorators &amp; ON_STRONG_OOP_REF) != 0;
 98   const bool peek              = (decorators &amp; AS_NO_KEEPALIVE) != 0;
 99   if (!peek &amp;&amp; !on_strong_oop_ref) {
<span class="line-modified">100     satb_enqueue(value);</span>
101   }
102 }
103 
104 template &lt;DecoratorSet decorators&gt;
105 inline void ShenandoahBarrierSet::keep_alive_if_weak(oop value) {
106   assert((decorators &amp; ON_UNKNOWN_OOP_REF) == 0, &quot;Reference strength must be known&quot;);
107   if (!HasDecorator&lt;decorators, ON_STRONG_OOP_REF&gt;::value &amp;&amp;
108       !HasDecorator&lt;decorators, AS_NO_KEEPALIVE&gt;::value) {
<span class="line-modified">109     satb_enqueue(value);</span>
110   }
111 }
112 
113 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
114 template &lt;typename T&gt;
115 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_not_in_heap(T* addr) {
116   oop value = Raw::oop_load_not_in_heap(addr);
117   if (value != NULL) {
118     ShenandoahBarrierSet *const bs = ShenandoahBarrierSet::barrier_set();
119     value = bs-&gt;load_reference_barrier_native(value, addr);
120     if (value != NULL) {
121       bs-&gt;keep_alive_if_weak&lt;decorators&gt;(value);
122     }
123   }
124   return value;
125 }
126 
127 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
128 template &lt;typename T&gt;
129 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_in_heap(T* addr) {
</pre>
<hr />
<pre>
241   if (ShenandoahCloneBarrier) {
242     ShenandoahBarrierSet::barrier_set()-&gt;clone_barrier_runtime(src);
243   }
244   Raw::clone(src, dst, size);
245 }
246 
247 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
248 template &lt;typename T&gt;
249 void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
250                                                                                          arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
251                                                                                          size_t length) {
252   ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();
253   bs-&gt;arraycopy_pre(arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw),
254                     arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw),
255                     length);
256   Raw::oop_arraycopy_in_heap(src_obj, src_offset_in_bytes, src_raw, dst_obj, dst_offset_in_bytes, dst_raw, length);
257 }
258 
259 template &lt;class T, bool HAS_FWD, bool EVAC, bool ENQUEUE&gt;
260 void ShenandoahBarrierSet::arraycopy_work(T* src, size_t count) {
<span class="line-added">261   assert(HAS_FWD == _heap-&gt;has_forwarded_objects(), &quot;Forwarded object status is sane&quot;);</span>
<span class="line-added">262 </span>
263   Thread* thread = Thread::current();
264   SATBMarkQueue&amp; queue = ShenandoahThreadLocalData::satb_mark_queue(thread);
265   ShenandoahMarkingContext* ctx = _heap-&gt;marking_context();
266   const ShenandoahCollectionSet* const cset = _heap-&gt;collection_set();
267   T* end = src + count;
268   for (T* elem_ptr = src; elem_ptr &lt; end; elem_ptr++) {
269     T o = RawAccess&lt;&gt;::oop_load(elem_ptr);
270     if (!CompressedOops::is_null(o)) {
271       oop obj = CompressedOops::decode_not_null(o);
272       if (HAS_FWD &amp;&amp; cset-&gt;is_in(obj)) {

273         oop fwd = resolve_forwarded_not_null(obj);
274         if (EVAC &amp;&amp; obj == fwd) {
275           fwd = _heap-&gt;evacuate_object(obj, thread);
276         }
277         assert(obj != fwd || _heap-&gt;cancelled_gc(), &quot;must be forwarded&quot;);
278         oop witness = ShenandoahHeap::cas_oop(fwd, elem_ptr, o);
279         obj = fwd;
280       }
281       if (ENQUEUE &amp;&amp; !ctx-&gt;is_marked(obj)) {
282         queue.enqueue_known_active(obj);
283       }
284     }
285   }
286 }
287 
288 template &lt;class T&gt;
289 void ShenandoahBarrierSet::arraycopy_pre_work(T* src, T* dst, size_t count) {
<span class="line-modified">290   if (_heap-&gt;is_concurrent_mark_in_progress() &amp;&amp;</span>
<span class="line-modified">291       !_heap-&gt;marking_context()-&gt;allocated_after_mark_start(reinterpret_cast&lt;HeapWord*&gt;(dst))) {</span>
<span class="line-modified">292     arraycopy_work&lt;T, false, false, true&gt;(dst, count);</span>



293   }
294 
<span class="line-modified">295   if (_heap-&gt;has_forwarded_objects()) {</span>
<span class="line-added">296     arraycopy_update_impl(src, count);</span>
<span class="line-added">297   }</span>
298 }
299 
300 void ShenandoahBarrierSet::arraycopy_pre(oop* src, oop* dst, size_t count) {
301   arraycopy_pre_work(src, dst, count);
302 }
303 
304 void ShenandoahBarrierSet::arraycopy_pre(narrowOop* src, narrowOop* dst, size_t count) {
305   arraycopy_pre_work(src, dst, count);
306 }
307 
<span class="line-added">308 inline bool ShenandoahBarrierSet::skip_bulk_update(HeapWord* dst) {</span>
<span class="line-added">309   return dst &gt;= _heap-&gt;heap_region_containing(dst)-&gt;get_update_watermark();</span>
<span class="line-added">310 }</span>
<span class="line-added">311 </span>
312 template &lt;class T&gt;
313 void ShenandoahBarrierSet::arraycopy_update_impl(T* src, size_t count) {
<span class="line-added">314   if (skip_bulk_update(reinterpret_cast&lt;HeapWord*&gt;(src))) return;</span>
315   if (_heap-&gt;is_evacuation_in_progress()) {
316     ShenandoahEvacOOMScope oom_evac;
317     arraycopy_work&lt;T, true, true, false&gt;(src, count);
318   } else if (_heap-&gt;is_concurrent_traversal_in_progress()){
319     ShenandoahEvacOOMScope oom_evac;
320     arraycopy_work&lt;T, true, true, true&gt;(src, count);
321   } else if (_heap-&gt;has_forwarded_objects()) {
322     arraycopy_work&lt;T, true, false, false&gt;(src, count);
323   }
324 }
325 
326 void ShenandoahBarrierSet::arraycopy_update(oop* src, size_t count) {
327   arraycopy_update_impl(src, count);
328 }
329 
330 void ShenandoahBarrierSet::arraycopy_update(narrowOop* src, size_t count) {
331   arraycopy_update_impl(src, count);
332 }
333 
334 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSET_INLINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahBarrierSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetClone.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
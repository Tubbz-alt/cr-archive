<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahBarrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahSupport.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1126   ShenandoahBarrierSetC2State* state = ShenandoahBarrierSetC2::bsc2()-&gt;state();
1127 
1128   Unique_Node_List uses;
1129   for (int i = 0; i &lt; state-&gt;enqueue_barriers_count(); i++) {
1130     Node* barrier = state-&gt;enqueue_barrier(i);
1131     Node* ctrl = phase-&gt;get_ctrl(barrier);
1132     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1133     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1134       // Expanding a barrier here will break loop strip mining
1135       // verification. Transform the loop so the loop nest doesn&#39;t
1136       // appear as strip mined.
1137       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1138       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1139     }
1140   }
1141 
1142   Node_Stack stack(0);
1143   Node_List clones;
1144   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1145     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
<span class="line-modified">1146     if (lrb-&gt;get_barrier_strength() == ShenandoahLoadReferenceBarrierNode::NONE) {</span>
1147       continue;
1148     }
1149 
1150     Node* ctrl = phase-&gt;get_ctrl(lrb);
1151     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
1152 
1153     CallStaticJavaNode* unc = NULL;
1154     Node* unc_ctrl = NULL;
1155     Node* uncasted_val = val;
1156 
1157     for (DUIterator_Fast imax, i = lrb-&gt;fast_outs(imax); i &lt; imax; i++) {
1158       Node* u = lrb-&gt;fast_out(i);
1159       if (u-&gt;Opcode() == Op_CastPP &amp;&amp;
1160           u-&gt;in(0) != NULL &amp;&amp;
1161           phase-&gt;is_dominator(u-&gt;in(0), ctrl)) {
1162         const Type* u_t = phase-&gt;igvn().type(u);
1163 
1164         if (u_t-&gt;meet(TypePtr::NULL_PTR) != u_t &amp;&amp;
1165             u-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;
1166             u-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
</pre>
<hr />
<pre>
1355                 int nb = u-&gt;replace_edge(n, create_phis_on_call_return(ctrl, c, n, n_clone, projs, phase));
1356                 assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
1357                 replaced = true;
1358               }
1359             }
1360             if (!replaced) {
1361               stack.set_index(idx+1);
1362             }
1363           }
1364         } else {
1365           stack.pop();
1366           clones.pop();
1367         }
1368       } while (stack.size() &gt; 0);
1369       assert(stack.size() == 0 &amp;&amp; clones.size() == 0, &quot;&quot;);
1370     }
1371   }
1372 
1373   for (int i = 0; i &lt; state-&gt;load_reference_barriers_count(); i++) {
1374     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
<span class="line-modified">1375     if (lrb-&gt;get_barrier_strength() == ShenandoahLoadReferenceBarrierNode::NONE) {</span>
1376       continue;
1377     }
1378     Node* ctrl = phase-&gt;get_ctrl(lrb);
1379     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1380     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1381       // Expanding a barrier here will break loop strip mining
1382       // verification. Transform the loop so the loop nest doesn&#39;t
1383       // appear as strip mined.
1384       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1385       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1386     }
1387   }
1388 
1389   // Expand load-reference-barriers
1390   MemoryGraphFixer fixer(Compile::AliasIdxRaw, true, phase);
1391   Unique_Node_List uses_to_ignore;
1392   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1393     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
<span class="line-modified">1394     if (lrb-&gt;get_barrier_strength() == ShenandoahLoadReferenceBarrierNode::NONE) {</span>
1395       phase-&gt;igvn().replace_node(lrb, lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn));
1396       continue;
1397     }
1398     uint last = phase-&gt;C-&gt;unique();
1399     Node* ctrl = phase-&gt;get_ctrl(lrb);
1400     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
1401 
1402 
1403     Node* orig_ctrl = ctrl;
1404 
1405     Node* raw_mem = fixer.find_mem(ctrl, lrb);
1406     Node* init_raw_mem = raw_mem;
1407     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);
1408 
1409     IdealLoopTree *loop = phase-&gt;get_loop(ctrl);
1410     CallStaticJavaNode* unc = lrb-&gt;pin_and_expand_null_check(phase-&gt;igvn());
1411     Node* unc_ctrl = NULL;
1412     if (unc != NULL) {
1413       if (val-&gt;in(ShenandoahLoadReferenceBarrierNode::Control) != ctrl) {
1414         unc = NULL;
</pre>
<hr />
<pre>
2623     uses.push(new_ctrl);
2624     for(uint next = 0; next &lt; uses.size(); next++ ) {
2625       Node *n = uses.at(next);
2626       assert(n-&gt;is_CFG(), &quot;&quot;);
2627       DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ ctrl&quot;); n-&gt;dump(); });
2628       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2629         Node* u = n-&gt;fast_out(i);
2630         if (!u-&gt;is_Root() &amp;&amp; u-&gt;is_CFG() &amp;&amp; u != n) {
2631           Node* m = _memory_nodes[u-&gt;_idx];
2632           if (u-&gt;is_Region() &amp;&amp; (!u-&gt;is_OuterStripMinedLoop() || _include_lsm) &amp;&amp;
2633               !has_mem_phi(u) &amp;&amp;
2634               u-&gt;unique_ctrl_out()-&gt;Opcode() != Op_Halt) {
2635             DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ region&quot;); u-&gt;dump(); });
2636             DEBUG_ONLY(if (trace &amp;&amp; m != NULL) { tty-&gt;print(&quot;ZZZ mem&quot;); m-&gt;dump(); });
2637 
2638             if (!mem_is_valid(m, u) || !m-&gt;is_Phi()) {
2639               bool push = true;
2640               bool create_phi = true;
2641               if (_phase-&gt;is_dominator(new_ctrl, u)) {
2642                 create_phi = false;
<span class="line-removed">2643               } else if (!_phase-&gt;C-&gt;has_irreducible_loop()) {</span>
<span class="line-removed">2644                 IdealLoopTree* loop = _phase-&gt;get_loop(ctrl);</span>
<span class="line-removed">2645                 bool do_check = true;</span>
<span class="line-removed">2646                 IdealLoopTree* l = loop;</span>
<span class="line-removed">2647                 create_phi = false;</span>
<span class="line-removed">2648                 while (l != _phase-&gt;ltree_root()) {</span>
<span class="line-removed">2649                   Node* head = l-&gt;_head;</span>
<span class="line-removed">2650                   if (head-&gt;in(0) == NULL) {</span>
<span class="line-removed">2651                     head = _phase-&gt;get_ctrl(head);</span>
<span class="line-removed">2652                   }</span>
<span class="line-removed">2653                   if (_phase-&gt;is_dominator(head, u) &amp;&amp; _phase-&gt;is_dominator(_phase-&gt;idom(u), head)) {</span>
<span class="line-removed">2654                     create_phi = true;</span>
<span class="line-removed">2655                     do_check = false;</span>
<span class="line-removed">2656                     break;</span>
<span class="line-removed">2657                   }</span>
<span class="line-removed">2658                   l = l-&gt;_parent;</span>
<span class="line-removed">2659                 }</span>
<span class="line-removed">2660 </span>
<span class="line-removed">2661                 if (do_check) {</span>
<span class="line-removed">2662                   assert(!create_phi, &quot;&quot;);</span>
<span class="line-removed">2663                   IdealLoopTree* u_loop = _phase-&gt;get_loop(u);</span>
<span class="line-removed">2664                   if (u_loop != _phase-&gt;ltree_root() &amp;&amp; u_loop-&gt;is_member(loop)) {</span>
<span class="line-removed">2665                     Node* c = ctrl;</span>
<span class="line-removed">2666                     while (!_phase-&gt;is_dominator(c, u_loop-&gt;tail())) {</span>
<span class="line-removed">2667                       c = _phase-&gt;idom(c);</span>
<span class="line-removed">2668                     }</span>
<span class="line-removed">2669                     if (!_phase-&gt;is_dominator(c, u)) {</span>
<span class="line-removed">2670                       do_check = false;</span>
<span class="line-removed">2671                     }</span>
<span class="line-removed">2672                   }</span>
<span class="line-removed">2673                 }</span>
<span class="line-removed">2674 </span>
<span class="line-removed">2675                 if (do_check &amp;&amp; _phase-&gt;is_dominator(_phase-&gt;idom(u), new_ctrl)) {</span>
<span class="line-removed">2676                   create_phi = true;</span>
<span class="line-removed">2677                 }</span>
2678               }
2679               if (create_phi) {
2680                 Node* phi = new PhiNode(u, Type::MEMORY, _phase-&gt;C-&gt;get_adr_type(_alias));
2681                 _phase-&gt;register_new_node(phi, u);
2682                 phis.push(phi);
2683                 DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ new phi&quot;); phi-&gt;dump(); });
2684                 if (!mem_is_valid(m, u)) {
2685                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting mem&quot;); phi-&gt;dump(); });
2686                   _memory_nodes.map(u-&gt;_idx, phi);
2687                 } else {
2688                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ NOT setting mem&quot;); m-&gt;dump(); });
2689                   for (;;) {
2690                     assert(m-&gt;is_Mem() || m-&gt;is_LoadStore() || m-&gt;is_Proj(), &quot;&quot;);
2691                     Node* next = NULL;
2692                     if (m-&gt;is_Proj()) {
2693                       next = m-&gt;in(0);
2694                     } else {
2695                       assert(m-&gt;is_Mem() || m-&gt;is_LoadStore(), &quot;&quot;);
2696                       assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
2697                       next = m-&gt;in(MemNode::Memory);
</pre>
<hr />
<pre>
3169       return needs_barrier_impl(phase, n-&gt;in(2), visited) ||
3170              needs_barrier_impl(phase, n-&gt;in(3), visited);
3171     case Op_ShenandoahEnqueueBarrier:
3172       return needs_barrier_impl(phase, n-&gt;in(1), visited);
3173     case Op_CreateEx:
3174       return false;
3175     default:
3176       break;
3177   }
3178 #ifdef ASSERT
3179   tty-&gt;print(&quot;need barrier on?: &quot;);
3180   tty-&gt;print_cr(&quot;ins:&quot;);
3181   n-&gt;dump(2);
3182   tty-&gt;print_cr(&quot;outs:&quot;);
3183   n-&gt;dump(-2);
3184   ShouldNotReachHere();
3185 #endif
3186   return true;
3187 }
3188 
<span class="line-modified">3189 ShenandoahLoadReferenceBarrierNode::Strength ShenandoahLoadReferenceBarrierNode::get_barrier_strength() {</span>
3190   Unique_Node_List visited;
3191   Node_Stack stack(0);
3192   stack.push(this, 0);
3193 
<span class="line-modified">3194   // Look for strongest strength: go over nodes looking for STRONG ones.</span>
<span class="line-modified">3195   // Stop once we encountered STRONG. Otherwise, walk until we ran out of nodes,</span>
<span class="line-modified">3196   // and then the overall strength is NONE.</span>
<span class="line-modified">3197   Strength strength = NONE;</span>
<span class="line-removed">3198   while (strength != STRONG &amp;&amp; stack.size() &gt; 0) {</span>
3199     Node* n = stack.node();
3200     if (visited.member(n)) {
3201       stack.pop();
3202       continue;
3203     }
3204     visited.push(n);
3205     bool visit_users = false;
3206     switch (n-&gt;Opcode()) {
3207       case Op_CallStaticJava:
3208       case Op_CallDynamicJava:
3209       case Op_CallLeaf:
3210       case Op_CallLeafNoFP:
3211       case Op_CompareAndSwapL:
3212       case Op_CompareAndSwapI:
3213       case Op_CompareAndSwapB:
3214       case Op_CompareAndSwapS:
3215       case Op_CompareAndSwapN:
3216       case Op_CompareAndSwapP:
3217       case Op_CompareAndExchangeL:
3218       case Op_CompareAndExchangeI:
</pre>
<hr />
<pre>
3254       case Op_StoreL:
3255       case Op_StoreLConditional:
3256       case Op_StoreI:
3257       case Op_StoreIConditional:
3258       case Op_StoreN:
3259       case Op_StoreP:
3260       case Op_StoreVector:
3261       case Op_StrInflatedCopy:
3262       case Op_StrCompressedCopy:
3263       case Op_EncodeP:
3264       case Op_CastP2X:
3265       case Op_SafePoint:
3266       case Op_EncodeISOArray:
3267       case Op_AryEq:
3268       case Op_StrEquals:
3269       case Op_StrComp:
3270       case Op_StrIndexOf:
3271       case Op_StrIndexOfChar:
3272       case Op_HasNegatives:
3273         // Known to require barriers
<span class="line-modified">3274         strength = STRONG;</span>
<span class="line-removed">3275         break;</span>
3276       case Op_CmpP: {
3277         if (n-&gt;in(1)-&gt;bottom_type()-&gt;higher_equal(TypePtr::NULL_PTR) ||
3278             n-&gt;in(2)-&gt;bottom_type()-&gt;higher_equal(TypePtr::NULL_PTR)) {
3279           // One of the sides is known null, no need for barrier.
3280         } else {
<span class="line-modified">3281           strength = STRONG;</span>
3282         }
3283         break;
3284       }
3285       case Op_LoadB:
3286       case Op_LoadUB:
3287       case Op_LoadUS:
3288       case Op_LoadD:
3289       case Op_LoadF:
3290       case Op_LoadL:
3291       case Op_LoadI:
3292       case Op_LoadS:
3293       case Op_LoadN:
3294       case Op_LoadP:
3295       case Op_LoadVector: {
3296         const TypePtr* adr_type = n-&gt;adr_type();
3297         int alias_idx = Compile::current()-&gt;get_alias_index(adr_type);
3298         Compile::AliasType* alias_type = Compile::current()-&gt;alias_type(alias_idx);
3299         ciField* field = alias_type-&gt;field();
3300         bool is_static = field != NULL &amp;&amp; field-&gt;is_static();
3301         bool is_final = field != NULL &amp;&amp; field-&gt;is_final();
3302 
3303         if (ShenandoahOptimizeStaticFinals &amp;&amp; is_static &amp;&amp; is_final) {
3304           // Loading the constant does not require barriers: it should be handled
3305           // as part of GC roots already.
3306         } else {
<span class="line-modified">3307           strength = STRONG;</span>
3308         }
3309         break;
3310       }
3311       case Op_Conv2B:
3312       case Op_LoadRange:
3313       case Op_LoadKlass:
3314       case Op_LoadNKlass:
3315         // Do not require barriers
3316         break;
3317       case Op_AddP:
3318       case Op_CheckCastPP:
3319       case Op_CastPP:
3320       case Op_CMoveP:
3321       case Op_Phi:
3322       case Op_ShenandoahLoadReferenceBarrier:
3323         // Whether or not these need the barriers depends on their users
3324         visit_users = true;
3325         break;
3326       default: {
3327 #ifdef ASSERT
<span class="line-modified">3328         fatal(&quot;Unknown node in get_barrier_strength: %s&quot;, NodeClassNames[n-&gt;Opcode()]);</span>
3329 #else
<span class="line-modified">3330         // Default to strong: better to have excess barriers, rather than miss some.</span>
<span class="line-modified">3331         strength = STRONG;</span>
3332 #endif
3333       }
3334     }
3335 
3336     stack.pop();
3337     if (visit_users) {
3338       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3339         Node* user = n-&gt;fast_out(i);
3340         if (user != NULL) {
3341           stack.push(user, 0);
3342         }
3343       }
3344     }
3345   }
<span class="line-modified">3346   return strength;</span>


3347 }
3348 
3349 CallStaticJavaNode* ShenandoahLoadReferenceBarrierNode::pin_and_expand_null_check(PhaseIterGVN&amp; igvn) {
3350   Node* val = in(ValueIn);
3351 
3352   const Type* val_t = igvn.type(val);
3353 
3354   if (val_t-&gt;meet(TypePtr::NULL_PTR) != val_t &amp;&amp;
3355       val-&gt;Opcode() == Op_CastPP &amp;&amp;
3356       val-&gt;in(0) != NULL &amp;&amp;
3357       val-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;
3358       val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
3359       val-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;
3360       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;
3361       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
3362       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;
3363       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1) &amp;&amp;
3364       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {
3365     assert(val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1), &quot;&quot;);
3366     CallStaticJavaNode* unc = val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
</pre>
</td>
<td>
<hr />
<pre>
1126   ShenandoahBarrierSetC2State* state = ShenandoahBarrierSetC2::bsc2()-&gt;state();
1127 
1128   Unique_Node_List uses;
1129   for (int i = 0; i &lt; state-&gt;enqueue_barriers_count(); i++) {
1130     Node* barrier = state-&gt;enqueue_barrier(i);
1131     Node* ctrl = phase-&gt;get_ctrl(barrier);
1132     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1133     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1134       // Expanding a barrier here will break loop strip mining
1135       // verification. Transform the loop so the loop nest doesn&#39;t
1136       // appear as strip mined.
1137       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1138       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1139     }
1140   }
1141 
1142   Node_Stack stack(0);
1143   Node_List clones;
1144   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1145     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
<span class="line-modified">1146     if (lrb-&gt;is_redundant()) {</span>
1147       continue;
1148     }
1149 
1150     Node* ctrl = phase-&gt;get_ctrl(lrb);
1151     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
1152 
1153     CallStaticJavaNode* unc = NULL;
1154     Node* unc_ctrl = NULL;
1155     Node* uncasted_val = val;
1156 
1157     for (DUIterator_Fast imax, i = lrb-&gt;fast_outs(imax); i &lt; imax; i++) {
1158       Node* u = lrb-&gt;fast_out(i);
1159       if (u-&gt;Opcode() == Op_CastPP &amp;&amp;
1160           u-&gt;in(0) != NULL &amp;&amp;
1161           phase-&gt;is_dominator(u-&gt;in(0), ctrl)) {
1162         const Type* u_t = phase-&gt;igvn().type(u);
1163 
1164         if (u_t-&gt;meet(TypePtr::NULL_PTR) != u_t &amp;&amp;
1165             u-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;
1166             u-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
</pre>
<hr />
<pre>
1355                 int nb = u-&gt;replace_edge(n, create_phis_on_call_return(ctrl, c, n, n_clone, projs, phase));
1356                 assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
1357                 replaced = true;
1358               }
1359             }
1360             if (!replaced) {
1361               stack.set_index(idx+1);
1362             }
1363           }
1364         } else {
1365           stack.pop();
1366           clones.pop();
1367         }
1368       } while (stack.size() &gt; 0);
1369       assert(stack.size() == 0 &amp;&amp; clones.size() == 0, &quot;&quot;);
1370     }
1371   }
1372 
1373   for (int i = 0; i &lt; state-&gt;load_reference_barriers_count(); i++) {
1374     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
<span class="line-modified">1375     if (lrb-&gt;is_redundant()) {</span>
1376       continue;
1377     }
1378     Node* ctrl = phase-&gt;get_ctrl(lrb);
1379     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1380     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1381       // Expanding a barrier here will break loop strip mining
1382       // verification. Transform the loop so the loop nest doesn&#39;t
1383       // appear as strip mined.
1384       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1385       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1386     }
1387   }
1388 
1389   // Expand load-reference-barriers
1390   MemoryGraphFixer fixer(Compile::AliasIdxRaw, true, phase);
1391   Unique_Node_List uses_to_ignore;
1392   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1393     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
<span class="line-modified">1394     if (lrb-&gt;is_redundant()) {</span>
1395       phase-&gt;igvn().replace_node(lrb, lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn));
1396       continue;
1397     }
1398     uint last = phase-&gt;C-&gt;unique();
1399     Node* ctrl = phase-&gt;get_ctrl(lrb);
1400     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
1401 
1402 
1403     Node* orig_ctrl = ctrl;
1404 
1405     Node* raw_mem = fixer.find_mem(ctrl, lrb);
1406     Node* init_raw_mem = raw_mem;
1407     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);
1408 
1409     IdealLoopTree *loop = phase-&gt;get_loop(ctrl);
1410     CallStaticJavaNode* unc = lrb-&gt;pin_and_expand_null_check(phase-&gt;igvn());
1411     Node* unc_ctrl = NULL;
1412     if (unc != NULL) {
1413       if (val-&gt;in(ShenandoahLoadReferenceBarrierNode::Control) != ctrl) {
1414         unc = NULL;
</pre>
<hr />
<pre>
2623     uses.push(new_ctrl);
2624     for(uint next = 0; next &lt; uses.size(); next++ ) {
2625       Node *n = uses.at(next);
2626       assert(n-&gt;is_CFG(), &quot;&quot;);
2627       DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ ctrl&quot;); n-&gt;dump(); });
2628       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2629         Node* u = n-&gt;fast_out(i);
2630         if (!u-&gt;is_Root() &amp;&amp; u-&gt;is_CFG() &amp;&amp; u != n) {
2631           Node* m = _memory_nodes[u-&gt;_idx];
2632           if (u-&gt;is_Region() &amp;&amp; (!u-&gt;is_OuterStripMinedLoop() || _include_lsm) &amp;&amp;
2633               !has_mem_phi(u) &amp;&amp;
2634               u-&gt;unique_ctrl_out()-&gt;Opcode() != Op_Halt) {
2635             DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ region&quot;); u-&gt;dump(); });
2636             DEBUG_ONLY(if (trace &amp;&amp; m != NULL) { tty-&gt;print(&quot;ZZZ mem&quot;); m-&gt;dump(); });
2637 
2638             if (!mem_is_valid(m, u) || !m-&gt;is_Phi()) {
2639               bool push = true;
2640               bool create_phi = true;
2641               if (_phase-&gt;is_dominator(new_ctrl, u)) {
2642                 create_phi = false;



































2643               }
2644               if (create_phi) {
2645                 Node* phi = new PhiNode(u, Type::MEMORY, _phase-&gt;C-&gt;get_adr_type(_alias));
2646                 _phase-&gt;register_new_node(phi, u);
2647                 phis.push(phi);
2648                 DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ new phi&quot;); phi-&gt;dump(); });
2649                 if (!mem_is_valid(m, u)) {
2650                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting mem&quot;); phi-&gt;dump(); });
2651                   _memory_nodes.map(u-&gt;_idx, phi);
2652                 } else {
2653                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ NOT setting mem&quot;); m-&gt;dump(); });
2654                   for (;;) {
2655                     assert(m-&gt;is_Mem() || m-&gt;is_LoadStore() || m-&gt;is_Proj(), &quot;&quot;);
2656                     Node* next = NULL;
2657                     if (m-&gt;is_Proj()) {
2658                       next = m-&gt;in(0);
2659                     } else {
2660                       assert(m-&gt;is_Mem() || m-&gt;is_LoadStore(), &quot;&quot;);
2661                       assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
2662                       next = m-&gt;in(MemNode::Memory);
</pre>
<hr />
<pre>
3134       return needs_barrier_impl(phase, n-&gt;in(2), visited) ||
3135              needs_barrier_impl(phase, n-&gt;in(3), visited);
3136     case Op_ShenandoahEnqueueBarrier:
3137       return needs_barrier_impl(phase, n-&gt;in(1), visited);
3138     case Op_CreateEx:
3139       return false;
3140     default:
3141       break;
3142   }
3143 #ifdef ASSERT
3144   tty-&gt;print(&quot;need barrier on?: &quot;);
3145   tty-&gt;print_cr(&quot;ins:&quot;);
3146   n-&gt;dump(2);
3147   tty-&gt;print_cr(&quot;outs:&quot;);
3148   n-&gt;dump(-2);
3149   ShouldNotReachHere();
3150 #endif
3151   return true;
3152 }
3153 
<span class="line-modified">3154 bool ShenandoahLoadReferenceBarrierNode::is_redundant() {</span>
3155   Unique_Node_List visited;
3156   Node_Stack stack(0);
3157   stack.push(this, 0);
3158 
<span class="line-modified">3159   // Check if the barrier is actually useful: go over nodes looking for useful uses</span>
<span class="line-modified">3160   // (e.g. memory accesses). Stop once we detected a required use. Otherwise, walk</span>
<span class="line-modified">3161   // until we ran out of nodes, and then declare the barrier redundant.</span>
<span class="line-modified">3162   while (stack.size() &gt; 0) {</span>

3163     Node* n = stack.node();
3164     if (visited.member(n)) {
3165       stack.pop();
3166       continue;
3167     }
3168     visited.push(n);
3169     bool visit_users = false;
3170     switch (n-&gt;Opcode()) {
3171       case Op_CallStaticJava:
3172       case Op_CallDynamicJava:
3173       case Op_CallLeaf:
3174       case Op_CallLeafNoFP:
3175       case Op_CompareAndSwapL:
3176       case Op_CompareAndSwapI:
3177       case Op_CompareAndSwapB:
3178       case Op_CompareAndSwapS:
3179       case Op_CompareAndSwapN:
3180       case Op_CompareAndSwapP:
3181       case Op_CompareAndExchangeL:
3182       case Op_CompareAndExchangeI:
</pre>
<hr />
<pre>
3218       case Op_StoreL:
3219       case Op_StoreLConditional:
3220       case Op_StoreI:
3221       case Op_StoreIConditional:
3222       case Op_StoreN:
3223       case Op_StoreP:
3224       case Op_StoreVector:
3225       case Op_StrInflatedCopy:
3226       case Op_StrCompressedCopy:
3227       case Op_EncodeP:
3228       case Op_CastP2X:
3229       case Op_SafePoint:
3230       case Op_EncodeISOArray:
3231       case Op_AryEq:
3232       case Op_StrEquals:
3233       case Op_StrComp:
3234       case Op_StrIndexOf:
3235       case Op_StrIndexOfChar:
3236       case Op_HasNegatives:
3237         // Known to require barriers
<span class="line-modified">3238         return false;</span>

3239       case Op_CmpP: {
3240         if (n-&gt;in(1)-&gt;bottom_type()-&gt;higher_equal(TypePtr::NULL_PTR) ||
3241             n-&gt;in(2)-&gt;bottom_type()-&gt;higher_equal(TypePtr::NULL_PTR)) {
3242           // One of the sides is known null, no need for barrier.
3243         } else {
<span class="line-modified">3244           return false;</span>
3245         }
3246         break;
3247       }
3248       case Op_LoadB:
3249       case Op_LoadUB:
3250       case Op_LoadUS:
3251       case Op_LoadD:
3252       case Op_LoadF:
3253       case Op_LoadL:
3254       case Op_LoadI:
3255       case Op_LoadS:
3256       case Op_LoadN:
3257       case Op_LoadP:
3258       case Op_LoadVector: {
3259         const TypePtr* adr_type = n-&gt;adr_type();
3260         int alias_idx = Compile::current()-&gt;get_alias_index(adr_type);
3261         Compile::AliasType* alias_type = Compile::current()-&gt;alias_type(alias_idx);
3262         ciField* field = alias_type-&gt;field();
3263         bool is_static = field != NULL &amp;&amp; field-&gt;is_static();
3264         bool is_final = field != NULL &amp;&amp; field-&gt;is_final();
3265 
3266         if (ShenandoahOptimizeStaticFinals &amp;&amp; is_static &amp;&amp; is_final) {
3267           // Loading the constant does not require barriers: it should be handled
3268           // as part of GC roots already.
3269         } else {
<span class="line-modified">3270           return false;</span>
3271         }
3272         break;
3273       }
3274       case Op_Conv2B:
3275       case Op_LoadRange:
3276       case Op_LoadKlass:
3277       case Op_LoadNKlass:
3278         // Do not require barriers
3279         break;
3280       case Op_AddP:
3281       case Op_CheckCastPP:
3282       case Op_CastPP:
3283       case Op_CMoveP:
3284       case Op_Phi:
3285       case Op_ShenandoahLoadReferenceBarrier:
3286         // Whether or not these need the barriers depends on their users
3287         visit_users = true;
3288         break;
3289       default: {
3290 #ifdef ASSERT
<span class="line-modified">3291         fatal(&quot;Unknown node in is_redundant: %s&quot;, NodeClassNames[n-&gt;Opcode()]);</span>
3292 #else
<span class="line-modified">3293         // Default to have excess barriers, rather than miss some.</span>
<span class="line-modified">3294         return false;</span>
3295 #endif
3296       }
3297     }
3298 
3299     stack.pop();
3300     if (visit_users) {
3301       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3302         Node* user = n-&gt;fast_out(i);
3303         if (user != NULL) {
3304           stack.push(user, 0);
3305         }
3306       }
3307     }
3308   }
<span class="line-modified">3309 </span>
<span class="line-added">3310   // No need for barrier found.</span>
<span class="line-added">3311   return true;</span>
3312 }
3313 
3314 CallStaticJavaNode* ShenandoahLoadReferenceBarrierNode::pin_and_expand_null_check(PhaseIterGVN&amp; igvn) {
3315   Node* val = in(ValueIn);
3316 
3317   const Type* val_t = igvn.type(val);
3318 
3319   if (val_t-&gt;meet(TypePtr::NULL_PTR) != val_t &amp;&amp;
3320       val-&gt;Opcode() == Op_CastPP &amp;&amp;
3321       val-&gt;in(0) != NULL &amp;&amp;
3322       val-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;
3323       val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
3324       val-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;
3325       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;
3326       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
3327       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;
3328       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1) &amp;&amp;
3329       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {
3330     assert(val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1), &quot;&quot;);
3331     CallStaticJavaNode* unc = val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahBarrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahSupport.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
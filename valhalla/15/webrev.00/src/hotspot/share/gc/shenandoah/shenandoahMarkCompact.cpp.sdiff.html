<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahMarkCompact.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahLock.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahMarkCompact.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahMarkCompact.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 207   if (VerifyAfterGC) {
 208     Universe::verify();
 209   }
 210 
 211   {
 212     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_heapdumps);
 213     heap-&gt;post_full_gc_dump(_gc_timer);
 214   }
 215 }
 216 
 217 class ShenandoahPrepareForMarkClosure: public ShenandoahHeapRegionClosure {
 218 private:
 219   ShenandoahMarkingContext* const _ctx;
 220 
 221 public:
 222   ShenandoahPrepareForMarkClosure() : _ctx(ShenandoahHeap::heap()-&gt;marking_context()) {}
 223 
 224   void heap_region_do(ShenandoahHeapRegion *r) {
 225     _ctx-&gt;capture_top_at_mark_start(r);
 226     r-&gt;clear_live_data();
<span class="line-removed"> 227     r-&gt;set_concurrent_iteration_safe_limit(r-&gt;top());</span>
 228   }
 229 };
 230 
 231 void ShenandoahMarkCompact::phase1_mark_heap() {
 232   GCTraceTime(Info, gc, phases) time(&quot;Phase 1: Mark live objects&quot;, _gc_timer);
 233   ShenandoahGCPhase mark_phase(ShenandoahPhaseTimings::full_gc_mark);
 234 
 235   ShenandoahHeap* heap = ShenandoahHeap::heap();
 236 
 237   ShenandoahPrepareForMarkClosure cl;
 238   heap-&gt;heap_region_iterate(&amp;cl);
 239 
 240   ShenandoahConcurrentMark* cm = heap-&gt;concurrent_mark();
 241 
 242   heap-&gt;set_process_references(heap-&gt;heuristics()-&gt;can_process_references());
 243   heap-&gt;set_unload_classes(heap-&gt;heuristics()-&gt;can_unload_classes());
 244 
 245   ReferenceProcessor* rp = heap-&gt;ref_processor();
 246   // enable (&quot;weak&quot;) refs discovery
 247   rp-&gt;enable_discovery(true /*verify_no_refs*/);
</pre>
<hr />
<pre>
 316       assert(new_to_region != _to_region, &quot;must not reuse same to-region&quot;);
 317       assert(new_to_region != NULL, &quot;must not be NULL&quot;);
 318       _to_region = new_to_region;
 319       _compact_point = _to_region-&gt;bottom();
 320     }
 321 
 322     // Object fits into current region, record new location:
 323     assert(_compact_point + obj_size &lt;= _to_region-&gt;end(), &quot;must fit&quot;);
 324     shenandoah_assert_not_forwarded(NULL, p);
 325     _preserved_marks-&gt;push_if_necessary(p, p-&gt;mark_raw());
 326     p-&gt;forward_to(oop(_compact_point));
 327     _compact_point += obj_size;
 328   }
 329 };
 330 
 331 class ShenandoahPrepareForCompactionTask : public AbstractGangTask {
 332 private:
 333   PreservedMarksSet*        const _preserved_marks;
 334   ShenandoahHeap*           const _heap;
 335   ShenandoahHeapRegionSet** const _worker_slices;
<span class="line-removed"> 336   ShenandoahRegionIterator        _heap_regions;</span>
<span class="line-removed"> 337 </span>
<span class="line-removed"> 338   ShenandoahHeapRegion* next_from_region(ShenandoahHeapRegionSet* slice) {</span>
<span class="line-removed"> 339     ShenandoahHeapRegion* from_region = _heap_regions.next();</span>
<span class="line-removed"> 340 </span>
<span class="line-removed"> 341     // Look for next candidate for this slice:</span>
<span class="line-removed"> 342     while (from_region != NULL) {</span>
<span class="line-removed"> 343       // Empty region: get it into the slice to defragment the slice itself.</span>
<span class="line-removed"> 344       // We could have skipped this without violating correctness, but we really</span>
<span class="line-removed"> 345       // want to compact all live regions to the start of the heap, which sometimes</span>
<span class="line-removed"> 346       // means moving them into the fully empty regions.</span>
<span class="line-removed"> 347       if (from_region-&gt;is_empty()) break;</span>
<span class="line-removed"> 348 </span>
<span class="line-removed"> 349       // Can move the region, and this is not the humongous region. Humongous</span>
<span class="line-removed"> 350       // moves are special cased here, because their moves are handled separately.</span>
<span class="line-removed"> 351       if (from_region-&gt;is_stw_move_allowed() &amp;&amp; !from_region-&gt;is_humongous()) break;</span>
<span class="line-removed"> 352 </span>
<span class="line-removed"> 353       from_region = _heap_regions.next();</span>
<span class="line-removed"> 354     }</span>
<span class="line-removed"> 355 </span>
<span class="line-removed"> 356     if (from_region != NULL) {</span>
<span class="line-removed"> 357       assert(slice != NULL, &quot;sanity&quot;);</span>
<span class="line-removed"> 358       assert(!from_region-&gt;is_humongous(), &quot;this path cannot handle humongous regions&quot;);</span>
<span class="line-removed"> 359       assert(from_region-&gt;is_empty() || from_region-&gt;is_stw_move_allowed(), &quot;only regions that can be moved in mark-compact&quot;);</span>
<span class="line-removed"> 360       slice-&gt;add_region(from_region);</span>
<span class="line-removed"> 361     }</span>
<span class="line-removed"> 362 </span>
<span class="line-removed"> 363     return from_region;</span>
<span class="line-removed"> 364   }</span>
 365 
 366 public:
<span class="line-modified"> 367   ShenandoahPrepareForCompactionTask(PreservedMarksSet* preserved_marks, ShenandoahHeapRegionSet** worker_slices) :</span>
 368     AbstractGangTask(&quot;Shenandoah Prepare For Compaction Task&quot;),
 369     _preserved_marks(preserved_marks),
 370     _heap(ShenandoahHeap::heap()), _worker_slices(worker_slices) {
 371   }
 372 












 373   void work(uint worker_id) {
 374     ShenandoahHeapRegionSet* slice = _worker_slices[worker_id];
<span class="line-modified"> 375     ShenandoahHeapRegion* from_region = next_from_region(slice);</span>

 376     // No work?
 377     if (from_region == NULL) {
<span class="line-modified"> 378       return;</span>
 379     }
 380 
 381     // Sliding compaction. Walk all regions in the slice, and compact them.
 382     // Remember empty regions and reuse them as needed.
 383     ResourceMark rm;

 384     GrowableArray&lt;ShenandoahHeapRegion*&gt; empty_regions((int)_heap-&gt;num_regions());

 385     ShenandoahPrepareForCompactionObjectClosure cl(_preserved_marks-&gt;get(worker_id), empty_regions, from_region);

 386     while (from_region != NULL) {


 387       cl.set_from_region(from_region);
 388       if (from_region-&gt;has_live()) {
 389         _heap-&gt;marked_object_iterate(from_region, &amp;cl);
 390       }
 391 
 392       // Compacted the region to somewhere else? From-region is empty then.
 393       if (!cl.is_compact_same_region()) {
 394         empty_regions.append(from_region);
 395       }
<span class="line-modified"> 396       from_region = next_from_region(slice);</span>
 397     }
 398     cl.finish_region();
 399 
 400     // Mark all remaining regions as empty
 401     for (int pos = cl.empty_regions_pos(); pos &lt; empty_regions.length(); ++pos) {
 402       ShenandoahHeapRegion* r = empty_regions.at(pos);
 403       r-&gt;set_new_top(r-&gt;bottom());
 404     }
 405   }
 406 };
 407 
 408 void ShenandoahMarkCompact::calculate_target_humongous_objects() {
 409   ShenandoahHeap* heap = ShenandoahHeap::heap();
 410 
 411   // Compute the new addresses for humongous objects. We need to do this after addresses
 412   // for regular objects are calculated, and we know what regions in heap suffix are
 413   // available for humongous moves.
 414   //
 415   // Scan the heap backwards, because we are compacting humongous regions towards the end.
 416   // Maintain the contiguous compaction window in [to_begin; to_end), so that we can slide
</pre>
<hr />
<pre>
 493       if (!_ctx-&gt;is_marked(humongous_obj)) {
 494         assert(!r-&gt;has_live(),
 495                &quot;Region &quot; SIZE_FORMAT &quot; is not marked, should not have live&quot;, r-&gt;region_number());
 496         _heap-&gt;trash_humongous_region_at(r);
 497       } else {
 498         assert(r-&gt;has_live(),
 499                &quot;Region &quot; SIZE_FORMAT &quot; should have live&quot;, r-&gt;region_number());
 500       }
 501     } else if (r-&gt;is_humongous_continuation()) {
 502       // If we hit continuation, the non-live humongous starts should have been trashed already
 503       assert(r-&gt;humongous_start_region()-&gt;has_live(),
 504              &quot;Region &quot; SIZE_FORMAT &quot; should have live&quot;, r-&gt;region_number());
 505     } else if (r-&gt;is_regular()) {
 506       if (!r-&gt;has_live()) {
 507         r-&gt;make_trash_immediate();
 508       }
 509     }
 510   }
 511 };
 512 














































































































































 513 void ShenandoahMarkCompact::phase2_calculate_target_addresses(ShenandoahHeapRegionSet** worker_slices) {
 514   GCTraceTime(Info, gc, phases) time(&quot;Phase 2: Compute new object addresses&quot;, _gc_timer);
 515   ShenandoahGCPhase calculate_address_phase(ShenandoahPhaseTimings::full_gc_calculate_addresses);
 516 
 517   ShenandoahHeap* heap = ShenandoahHeap::heap();
 518 
 519   // About to figure out which regions can be compacted, make sure pinning status
 520   // had been updated in GC prologue.
 521   heap-&gt;assert_pinned_region_status();
 522 
 523   {
 524     // Trash the immediately collectible regions before computing addresses
 525     ShenandoahTrashImmediateGarbageClosure tigcl;
 526     heap-&gt;heap_region_iterate(&amp;tigcl);
 527 
 528     // Make sure regions are in good state: committed, active, clean.
 529     // This is needed because we are potentially sliding the data through them.
 530     ShenandoahEnsureHeapActiveClosure ecl;
 531     heap-&gt;heap_region_iterate(&amp;ecl);
 532   }
 533 
 534   // Compute the new addresses for regular objects
 535   {
 536     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_calculate_addresses_regular);
<span class="line-modified"> 537     ShenandoahPrepareForCompactionTask prepare_task(_preserved_marks, worker_slices);</span>
<span class="line-modified"> 538     heap-&gt;workers()-&gt;run_task(&amp;prepare_task);</span>



 539   }
 540 
 541   // Compute the new addresses for humongous objects
 542   {
 543     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_calculate_addresses_humong);
 544     calculate_target_humongous_objects();
 545   }
 546 }
 547 
 548 class ShenandoahAdjustPointersClosure : public MetadataVisitingOopIterateClosure {
 549 private:
 550   ShenandoahHeap* const _heap;
 551   ShenandoahMarkingContext* const _ctx;
 552 
 553   template &lt;class T&gt;
 554   inline void do_oop_work(T* p) {
 555     T o = RawAccess&lt;&gt;::oop_load(p);
 556     if (!CompressedOops::is_null(o)) {
 557       oop obj = CompressedOops::decode_not_null(o);
 558       assert(_ctx-&gt;is_marked(obj), &quot;must be marked&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 207   if (VerifyAfterGC) {
 208     Universe::verify();
 209   }
 210 
 211   {
 212     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_heapdumps);
 213     heap-&gt;post_full_gc_dump(_gc_timer);
 214   }
 215 }
 216 
 217 class ShenandoahPrepareForMarkClosure: public ShenandoahHeapRegionClosure {
 218 private:
 219   ShenandoahMarkingContext* const _ctx;
 220 
 221 public:
 222   ShenandoahPrepareForMarkClosure() : _ctx(ShenandoahHeap::heap()-&gt;marking_context()) {}
 223 
 224   void heap_region_do(ShenandoahHeapRegion *r) {
 225     _ctx-&gt;capture_top_at_mark_start(r);
 226     r-&gt;clear_live_data();

 227   }
 228 };
 229 
 230 void ShenandoahMarkCompact::phase1_mark_heap() {
 231   GCTraceTime(Info, gc, phases) time(&quot;Phase 1: Mark live objects&quot;, _gc_timer);
 232   ShenandoahGCPhase mark_phase(ShenandoahPhaseTimings::full_gc_mark);
 233 
 234   ShenandoahHeap* heap = ShenandoahHeap::heap();
 235 
 236   ShenandoahPrepareForMarkClosure cl;
 237   heap-&gt;heap_region_iterate(&amp;cl);
 238 
 239   ShenandoahConcurrentMark* cm = heap-&gt;concurrent_mark();
 240 
 241   heap-&gt;set_process_references(heap-&gt;heuristics()-&gt;can_process_references());
 242   heap-&gt;set_unload_classes(heap-&gt;heuristics()-&gt;can_unload_classes());
 243 
 244   ReferenceProcessor* rp = heap-&gt;ref_processor();
 245   // enable (&quot;weak&quot;) refs discovery
 246   rp-&gt;enable_discovery(true /*verify_no_refs*/);
</pre>
<hr />
<pre>
 315       assert(new_to_region != _to_region, &quot;must not reuse same to-region&quot;);
 316       assert(new_to_region != NULL, &quot;must not be NULL&quot;);
 317       _to_region = new_to_region;
 318       _compact_point = _to_region-&gt;bottom();
 319     }
 320 
 321     // Object fits into current region, record new location:
 322     assert(_compact_point + obj_size &lt;= _to_region-&gt;end(), &quot;must fit&quot;);
 323     shenandoah_assert_not_forwarded(NULL, p);
 324     _preserved_marks-&gt;push_if_necessary(p, p-&gt;mark_raw());
 325     p-&gt;forward_to(oop(_compact_point));
 326     _compact_point += obj_size;
 327   }
 328 };
 329 
 330 class ShenandoahPrepareForCompactionTask : public AbstractGangTask {
 331 private:
 332   PreservedMarksSet*        const _preserved_marks;
 333   ShenandoahHeap*           const _heap;
 334   ShenandoahHeapRegionSet** const _worker_slices;





























 335 
 336 public:
<span class="line-modified"> 337   ShenandoahPrepareForCompactionTask(PreservedMarksSet *preserved_marks, ShenandoahHeapRegionSet **worker_slices) :</span>
 338     AbstractGangTask(&quot;Shenandoah Prepare For Compaction Task&quot;),
 339     _preserved_marks(preserved_marks),
 340     _heap(ShenandoahHeap::heap()), _worker_slices(worker_slices) {
 341   }
 342 
<span class="line-added"> 343   static bool is_candidate_region(ShenandoahHeapRegion* r) {</span>
<span class="line-added"> 344     // Empty region: get it into the slice to defragment the slice itself.</span>
<span class="line-added"> 345     // We could have skipped this without violating correctness, but we really</span>
<span class="line-added"> 346     // want to compact all live regions to the start of the heap, which sometimes</span>
<span class="line-added"> 347     // means moving them into the fully empty regions.</span>
<span class="line-added"> 348     if (r-&gt;is_empty()) return true;</span>
<span class="line-added"> 349 </span>
<span class="line-added"> 350     // Can move the region, and this is not the humongous region. Humongous</span>
<span class="line-added"> 351     // moves are special cased here, because their moves are handled separately.</span>
<span class="line-added"> 352     return r-&gt;is_stw_move_allowed() &amp;&amp; !r-&gt;is_humongous();</span>
<span class="line-added"> 353   }</span>
<span class="line-added"> 354 </span>
 355   void work(uint worker_id) {
 356     ShenandoahHeapRegionSet* slice = _worker_slices[worker_id];
<span class="line-modified"> 357     ShenandoahHeapRegionSetIterator it(slice);</span>
<span class="line-added"> 358     ShenandoahHeapRegion* from_region = it.next();</span>
 359     // No work?
 360     if (from_region == NULL) {
<span class="line-modified"> 361        return;</span>
 362     }
 363 
 364     // Sliding compaction. Walk all regions in the slice, and compact them.
 365     // Remember empty regions and reuse them as needed.
 366     ResourceMark rm;
<span class="line-added"> 367 </span>
 368     GrowableArray&lt;ShenandoahHeapRegion*&gt; empty_regions((int)_heap-&gt;num_regions());
<span class="line-added"> 369 </span>
 370     ShenandoahPrepareForCompactionObjectClosure cl(_preserved_marks-&gt;get(worker_id), empty_regions, from_region);
<span class="line-added"> 371 </span>
 372     while (from_region != NULL) {
<span class="line-added"> 373       assert(is_candidate_region(from_region), &quot;Sanity&quot;);</span>
<span class="line-added"> 374 </span>
 375       cl.set_from_region(from_region);
 376       if (from_region-&gt;has_live()) {
 377         _heap-&gt;marked_object_iterate(from_region, &amp;cl);
 378       }
 379 
 380       // Compacted the region to somewhere else? From-region is empty then.
 381       if (!cl.is_compact_same_region()) {
 382         empty_regions.append(from_region);
 383       }
<span class="line-modified"> 384       from_region = it.next();</span>
 385     }
 386     cl.finish_region();
 387 
 388     // Mark all remaining regions as empty
 389     for (int pos = cl.empty_regions_pos(); pos &lt; empty_regions.length(); ++pos) {
 390       ShenandoahHeapRegion* r = empty_regions.at(pos);
 391       r-&gt;set_new_top(r-&gt;bottom());
 392     }
 393   }
 394 };
 395 
 396 void ShenandoahMarkCompact::calculate_target_humongous_objects() {
 397   ShenandoahHeap* heap = ShenandoahHeap::heap();
 398 
 399   // Compute the new addresses for humongous objects. We need to do this after addresses
 400   // for regular objects are calculated, and we know what regions in heap suffix are
 401   // available for humongous moves.
 402   //
 403   // Scan the heap backwards, because we are compacting humongous regions towards the end.
 404   // Maintain the contiguous compaction window in [to_begin; to_end), so that we can slide
</pre>
<hr />
<pre>
 481       if (!_ctx-&gt;is_marked(humongous_obj)) {
 482         assert(!r-&gt;has_live(),
 483                &quot;Region &quot; SIZE_FORMAT &quot; is not marked, should not have live&quot;, r-&gt;region_number());
 484         _heap-&gt;trash_humongous_region_at(r);
 485       } else {
 486         assert(r-&gt;has_live(),
 487                &quot;Region &quot; SIZE_FORMAT &quot; should have live&quot;, r-&gt;region_number());
 488       }
 489     } else if (r-&gt;is_humongous_continuation()) {
 490       // If we hit continuation, the non-live humongous starts should have been trashed already
 491       assert(r-&gt;humongous_start_region()-&gt;has_live(),
 492              &quot;Region &quot; SIZE_FORMAT &quot; should have live&quot;, r-&gt;region_number());
 493     } else if (r-&gt;is_regular()) {
 494       if (!r-&gt;has_live()) {
 495         r-&gt;make_trash_immediate();
 496       }
 497     }
 498   }
 499 };
 500 
<span class="line-added"> 501 void ShenandoahMarkCompact::distribute_slices(ShenandoahHeapRegionSet** worker_slices) {</span>
<span class="line-added"> 502   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-added"> 503 </span>
<span class="line-added"> 504   uint n_workers = heap-&gt;workers()-&gt;active_workers();</span>
<span class="line-added"> 505   size_t n_regions = heap-&gt;num_regions();</span>
<span class="line-added"> 506 </span>
<span class="line-added"> 507   // What we want to accomplish: have the dense prefix of data, while still balancing</span>
<span class="line-added"> 508   // out the parallel work.</span>
<span class="line-added"> 509   //</span>
<span class="line-added"> 510   // Assuming the amount of work is driven by the live data that needs moving, we can slice</span>
<span class="line-added"> 511   // the entire heap into equal-live-sized prefix slices, and compact into them. So, each</span>
<span class="line-added"> 512   // thread takes all regions in its prefix subset, and then it takes some regions from</span>
<span class="line-added"> 513   // the tail.</span>
<span class="line-added"> 514   //</span>
<span class="line-added"> 515   // Tail region selection becomes interesting.</span>
<span class="line-added"> 516   //</span>
<span class="line-added"> 517   // First, we want to distribute the regions fairly between the workers, and those regions</span>
<span class="line-added"> 518   // might have different amount of live data. So, until we sure no workers need live data,</span>
<span class="line-added"> 519   // we need to only take what the worker needs.</span>
<span class="line-added"> 520   //</span>
<span class="line-added"> 521   // Second, since we slide everything to the left in each slice, the most busy regions</span>
<span class="line-added"> 522   // would be the ones on the left. Which means we want to have all workers have their after-tail</span>
<span class="line-added"> 523   // regions as close to the left as possible.</span>
<span class="line-added"> 524   //</span>
<span class="line-added"> 525   // The easiest way to do this is to distribute after-tail regions in round-robin between</span>
<span class="line-added"> 526   // workers that still need live data.</span>
<span class="line-added"> 527   //</span>
<span class="line-added"> 528   // Consider parallel workers A, B, C, then the target slice layout would be:</span>
<span class="line-added"> 529   //</span>
<span class="line-added"> 530   //  AAAAAAAABBBBBBBBCCCCCCCC|ABCABCABCABCABCABCABCABABABABABABABABABABAAAAA</span>
<span class="line-added"> 531   //</span>
<span class="line-added"> 532   //  (.....dense-prefix.....) (.....................tail...................)</span>
<span class="line-added"> 533   //  [all regions fully live] [left-most regions are fuller that right-most]</span>
<span class="line-added"> 534   //</span>
<span class="line-added"> 535 </span>
<span class="line-added"> 536   // Compute how much live data is there. This would approximate the size of dense prefix</span>
<span class="line-added"> 537   // we target to create.</span>
<span class="line-added"> 538   size_t total_live = 0;</span>
<span class="line-added"> 539   for (size_t idx = 0; idx &lt; n_regions; idx++) {</span>
<span class="line-added"> 540     ShenandoahHeapRegion *r = heap-&gt;get_region(idx);</span>
<span class="line-added"> 541     if (ShenandoahPrepareForCompactionTask::is_candidate_region(r)) {</span>
<span class="line-added"> 542       total_live += r-&gt;get_live_data_words();</span>
<span class="line-added"> 543     }</span>
<span class="line-added"> 544   }</span>
<span class="line-added"> 545 </span>
<span class="line-added"> 546   // Estimate the size for the dense prefix. Note that we specifically count only the</span>
<span class="line-added"> 547   // &quot;full&quot; regions, so there would be some non-full regions in the slice tail.</span>
<span class="line-added"> 548   size_t live_per_worker = total_live / n_workers;</span>
<span class="line-added"> 549   size_t prefix_regions_per_worker = live_per_worker / ShenandoahHeapRegion::region_size_words();</span>
<span class="line-added"> 550   size_t prefix_regions_total = prefix_regions_per_worker * n_workers;</span>
<span class="line-added"> 551   prefix_regions_total = MIN2(prefix_regions_total, n_regions);</span>
<span class="line-added"> 552   assert(prefix_regions_total &lt;= n_regions, &quot;Sanity&quot;);</span>
<span class="line-added"> 553 </span>
<span class="line-added"> 554   // There might be non-candidate regions in the prefix. To compute where the tail actually</span>
<span class="line-added"> 555   // ends up being, we need to account those as well.</span>
<span class="line-added"> 556   size_t prefix_end = prefix_regions_total;</span>
<span class="line-added"> 557   for (size_t idx = 0; idx &lt; prefix_regions_total; idx++) {</span>
<span class="line-added"> 558     ShenandoahHeapRegion *r = heap-&gt;get_region(idx);</span>
<span class="line-added"> 559     if (!ShenandoahPrepareForCompactionTask::is_candidate_region(r)) {</span>
<span class="line-added"> 560       prefix_end++;</span>
<span class="line-added"> 561     }</span>
<span class="line-added"> 562   }</span>
<span class="line-added"> 563   prefix_end = MIN2(prefix_end, n_regions);</span>
<span class="line-added"> 564   assert(prefix_end &lt;= n_regions, &quot;Sanity&quot;);</span>
<span class="line-added"> 565 </span>
<span class="line-added"> 566   // Distribute prefix regions per worker: each thread definitely gets its own same-sized</span>
<span class="line-added"> 567   // subset of dense prefix.</span>
<span class="line-added"> 568   size_t prefix_idx = 0;</span>
<span class="line-added"> 569 </span>
<span class="line-added"> 570   size_t* live = NEW_C_HEAP_ARRAY(size_t, n_workers, mtGC);</span>
<span class="line-added"> 571 </span>
<span class="line-added"> 572   for (size_t wid = 0; wid &lt; n_workers; wid++) {</span>
<span class="line-added"> 573     ShenandoahHeapRegionSet* slice = worker_slices[wid];</span>
<span class="line-added"> 574 </span>
<span class="line-added"> 575     live[wid] = 0;</span>
<span class="line-added"> 576     size_t regs = 0;</span>
<span class="line-added"> 577 </span>
<span class="line-added"> 578     // Add all prefix regions for this worker</span>
<span class="line-added"> 579     while (prefix_idx &lt; prefix_end &amp;&amp; regs &lt; prefix_regions_per_worker) {</span>
<span class="line-added"> 580       ShenandoahHeapRegion *r = heap-&gt;get_region(prefix_idx);</span>
<span class="line-added"> 581       if (ShenandoahPrepareForCompactionTask::is_candidate_region(r)) {</span>
<span class="line-added"> 582         slice-&gt;add_region(r);</span>
<span class="line-added"> 583         live[wid] += r-&gt;get_live_data_words();</span>
<span class="line-added"> 584         regs++;</span>
<span class="line-added"> 585       }</span>
<span class="line-added"> 586       prefix_idx++;</span>
<span class="line-added"> 587     }</span>
<span class="line-added"> 588   }</span>
<span class="line-added"> 589 </span>
<span class="line-added"> 590   // Distribute the tail among workers in round-robin fashion.</span>
<span class="line-added"> 591   size_t wid = n_workers - 1;</span>
<span class="line-added"> 592 </span>
<span class="line-added"> 593   for (size_t tail_idx = prefix_end; tail_idx &lt; n_regions; tail_idx++) {</span>
<span class="line-added"> 594     ShenandoahHeapRegion *r = heap-&gt;get_region(tail_idx);</span>
<span class="line-added"> 595     if (ShenandoahPrepareForCompactionTask::is_candidate_region(r)) {</span>
<span class="line-added"> 596       assert(wid &lt; n_workers, &quot;Sanity&quot;);</span>
<span class="line-added"> 597 </span>
<span class="line-added"> 598       size_t live_region = r-&gt;get_live_data_words();</span>
<span class="line-added"> 599 </span>
<span class="line-added"> 600       // Select next worker that still needs live data.</span>
<span class="line-added"> 601       size_t old_wid = wid;</span>
<span class="line-added"> 602       do {</span>
<span class="line-added"> 603         wid++;</span>
<span class="line-added"> 604         if (wid == n_workers) wid = 0;</span>
<span class="line-added"> 605       } while (live[wid] + live_region &gt;= live_per_worker &amp;&amp; old_wid != wid);</span>
<span class="line-added"> 606 </span>
<span class="line-added"> 607       if (old_wid == wid) {</span>
<span class="line-added"> 608         // Circled back to the same worker? This means liveness data was</span>
<span class="line-added"> 609         // miscalculated. Bump the live_per_worker limit so that</span>
<span class="line-added"> 610         // everyone gets a piece of the leftover work.</span>
<span class="line-added"> 611         live_per_worker += ShenandoahHeapRegion::region_size_words();</span>
<span class="line-added"> 612       }</span>
<span class="line-added"> 613 </span>
<span class="line-added"> 614       worker_slices[wid]-&gt;add_region(r);</span>
<span class="line-added"> 615       live[wid] += live_region;</span>
<span class="line-added"> 616     }</span>
<span class="line-added"> 617   }</span>
<span class="line-added"> 618 </span>
<span class="line-added"> 619   FREE_C_HEAP_ARRAY(size_t, live);</span>
<span class="line-added"> 620 </span>
<span class="line-added"> 621 #ifdef ASSERT</span>
<span class="line-added"> 622   ResourceBitMap map(n_regions);</span>
<span class="line-added"> 623   for (size_t wid = 0; wid &lt; n_workers; wid++) {</span>
<span class="line-added"> 624     ShenandoahHeapRegionSetIterator it(worker_slices[wid]);</span>
<span class="line-added"> 625     ShenandoahHeapRegion* r = it.next();</span>
<span class="line-added"> 626     while (r != NULL) {</span>
<span class="line-added"> 627       size_t num = r-&gt;region_number();</span>
<span class="line-added"> 628       assert(ShenandoahPrepareForCompactionTask::is_candidate_region(r), &quot;Sanity: &quot; SIZE_FORMAT, num);</span>
<span class="line-added"> 629       assert(!map.at(num), &quot;No region distributed twice: &quot; SIZE_FORMAT, num);</span>
<span class="line-added"> 630       map.at_put(num, true);</span>
<span class="line-added"> 631       r = it.next();</span>
<span class="line-added"> 632     }</span>
<span class="line-added"> 633   }</span>
<span class="line-added"> 634 </span>
<span class="line-added"> 635   for (size_t rid = 0; rid &lt; n_regions; rid++) {</span>
<span class="line-added"> 636     bool is_candidate = ShenandoahPrepareForCompactionTask::is_candidate_region(heap-&gt;get_region(rid));</span>
<span class="line-added"> 637     bool is_distributed = map.at(rid);</span>
<span class="line-added"> 638     assert(is_distributed || !is_candidate, &quot;All candidates are distributed: &quot; SIZE_FORMAT, rid);</span>
<span class="line-added"> 639   }</span>
<span class="line-added"> 640 #endif</span>
<span class="line-added"> 641 }</span>
<span class="line-added"> 642 </span>
 643 void ShenandoahMarkCompact::phase2_calculate_target_addresses(ShenandoahHeapRegionSet** worker_slices) {
 644   GCTraceTime(Info, gc, phases) time(&quot;Phase 2: Compute new object addresses&quot;, _gc_timer);
 645   ShenandoahGCPhase calculate_address_phase(ShenandoahPhaseTimings::full_gc_calculate_addresses);
 646 
 647   ShenandoahHeap* heap = ShenandoahHeap::heap();
 648 
 649   // About to figure out which regions can be compacted, make sure pinning status
 650   // had been updated in GC prologue.
 651   heap-&gt;assert_pinned_region_status();
 652 
 653   {
 654     // Trash the immediately collectible regions before computing addresses
 655     ShenandoahTrashImmediateGarbageClosure tigcl;
 656     heap-&gt;heap_region_iterate(&amp;tigcl);
 657 
 658     // Make sure regions are in good state: committed, active, clean.
 659     // This is needed because we are potentially sliding the data through them.
 660     ShenandoahEnsureHeapActiveClosure ecl;
 661     heap-&gt;heap_region_iterate(&amp;ecl);
 662   }
 663 
 664   // Compute the new addresses for regular objects
 665   {
 666     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_calculate_addresses_regular);
<span class="line-modified"> 667 </span>
<span class="line-modified"> 668     distribute_slices(worker_slices);</span>
<span class="line-added"> 669 </span>
<span class="line-added"> 670     ShenandoahPrepareForCompactionTask task(_preserved_marks, worker_slices);</span>
<span class="line-added"> 671     heap-&gt;workers()-&gt;run_task(&amp;task);</span>
 672   }
 673 
 674   // Compute the new addresses for humongous objects
 675   {
 676     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_calculate_addresses_humong);
 677     calculate_target_humongous_objects();
 678   }
 679 }
 680 
 681 class ShenandoahAdjustPointersClosure : public MetadataVisitingOopIterateClosure {
 682 private:
 683   ShenandoahHeap* const _heap;
 684   ShenandoahMarkingContext* const _ctx;
 685 
 686   template &lt;class T&gt;
 687   inline void do_oop_work(T* p) {
 688     T o = RawAccess&lt;&gt;::oop_load(p);
 689     if (!CompressedOops::is_null(o)) {
 690       oop obj = CompressedOops::decode_not_null(o);
 691       assert(_ctx-&gt;is_marked(obj), &quot;must be marked&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahLock.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahMarkCompact.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
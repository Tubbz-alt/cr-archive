<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeap.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 38 #include &quot;runtime/atomic.hpp&quot;
 39 #include &quot;runtime/java.hpp&quot;
 40 #include &quot;runtime/mutexLocker.hpp&quot;
 41 #include &quot;runtime/os.hpp&quot;
 42 #include &quot;runtime/safepoint.hpp&quot;
 43 
 44 size_t ShenandoahHeapRegion::RegionCount = 0;
 45 size_t ShenandoahHeapRegion::RegionSizeBytes = 0;
 46 size_t ShenandoahHeapRegion::RegionSizeWords = 0;
 47 size_t ShenandoahHeapRegion::RegionSizeBytesShift = 0;
 48 size_t ShenandoahHeapRegion::RegionSizeWordsShift = 0;
 49 size_t ShenandoahHeapRegion::RegionSizeBytesMask = 0;
 50 size_t ShenandoahHeapRegion::RegionSizeWordsMask = 0;
 51 size_t ShenandoahHeapRegion::HumongousThresholdBytes = 0;
 52 size_t ShenandoahHeapRegion::HumongousThresholdWords = 0;
 53 size_t ShenandoahHeapRegion::MaxTLABSizeBytes = 0;
 54 size_t ShenandoahHeapRegion::MaxTLABSizeWords = 0;
 55 
 56 ShenandoahHeapRegion::PaddedAllocSeqNum ShenandoahHeapRegion::_alloc_seq_num;
 57 
<span class="line-modified"> 58 ShenandoahHeapRegion::ShenandoahHeapRegion(ShenandoahHeap* heap, HeapWord* start,</span>
<span class="line-removed"> 59                                            size_t size_words, size_t index, bool committed) :</span>
<span class="line-removed"> 60   _heap(heap),</span>
<span class="line-removed"> 61   _reserved(MemRegion(start, size_words)),</span>
 62   _region_number(index),


 63   _new_top(NULL),
 64   _empty_time(os::elapsedTime()),
 65   _state(committed ? _empty_committed : _empty_uncommitted),

 66   _tlab_allocs(0),
 67   _gclab_allocs(0),
 68   _shared_allocs(0),
<span class="line-removed"> 69   _seqnum_first_alloc_mutator(0),</span>
<span class="line-removed"> 70   _seqnum_first_alloc_gc(0),</span>
 71   _seqnum_last_alloc_mutator(0),
<span class="line-removed"> 72   _seqnum_last_alloc_gc(0),</span>
 73   _live_data(0),
<span class="line-modified"> 74   _critical_pins(0) {</span>

 75 
<span class="line-modified"> 76   ContiguousSpace::initialize(_reserved, true, committed);</span>




 77 }
 78 
 79 size_t ShenandoahHeapRegion::region_number() const {
 80   return _region_number;
 81 }
 82 
 83 void ShenandoahHeapRegion::report_illegal_transition(const char *method) {
 84   ResourceMark rm;
 85   stringStream ss;
 86   ss.print(&quot;Illegal region state transition from \&quot;%s\&quot;, at %s\n  &quot;, region_state_to_string(_state), method);
 87   print_on(&amp;ss);
 88   fatal(&quot;%s&quot;, ss.as_string());
 89 }
 90 
 91 void ShenandoahHeapRegion::make_regular_allocation() {
<span class="line-modified"> 92   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
 93 
 94   switch (_state) {
 95     case _empty_uncommitted:
 96       do_commit();
 97     case _empty_committed:
 98       set_state(_regular);
 99     case _regular:
100     case _pinned:
101       return;
102     default:
103       report_illegal_transition(&quot;regular allocation&quot;);
104   }
105 }
106 
107 void ShenandoahHeapRegion::make_regular_bypass() {
<span class="line-modified">108   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
<span class="line-modified">109   assert (_heap-&gt;is_full_gc_in_progress() || _heap-&gt;is_degenerated_gc_in_progress(),</span>
110           &quot;only for full or degen GC&quot;);
111 
112   switch (_state) {
113     case _empty_uncommitted:
114       do_commit();
115     case _empty_committed:
116     case _cset:
117     case _humongous_start:
118     case _humongous_cont:
119       set_state(_regular);
120       return;
121     case _pinned_cset:
122       set_state(_pinned);
123       return;
124     case _regular:
125     case _pinned:
126       return;
127     default:
128       report_illegal_transition(&quot;regular bypass&quot;);
129   }
130 }
131 
132 void ShenandoahHeapRegion::make_humongous_start() {
<span class="line-modified">133   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
134   switch (_state) {
135     case _empty_uncommitted:
136       do_commit();
137     case _empty_committed:
138       set_state(_humongous_start);
139       return;
140     default:
141       report_illegal_transition(&quot;humongous start allocation&quot;);
142   }
143 }
144 
145 void ShenandoahHeapRegion::make_humongous_start_bypass() {
<span class="line-modified">146   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
<span class="line-modified">147   assert (_heap-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
148 
149   switch (_state) {
150     case _empty_committed:
151     case _regular:
152     case _humongous_start:
153     case _humongous_cont:
154       set_state(_humongous_start);
155       return;
156     default:
157       report_illegal_transition(&quot;humongous start bypass&quot;);
158   }
159 }
160 
161 void ShenandoahHeapRegion::make_humongous_cont() {
<span class="line-modified">162   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
163   switch (_state) {
164     case _empty_uncommitted:
165       do_commit();
166     case _empty_committed:
167      set_state(_humongous_cont);
168       return;
169     default:
170       report_illegal_transition(&quot;humongous continuation allocation&quot;);
171   }
172 }
173 
174 void ShenandoahHeapRegion::make_humongous_cont_bypass() {
<span class="line-modified">175   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
<span class="line-modified">176   assert (_heap-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
177 
178   switch (_state) {
179     case _empty_committed:
180     case _regular:
181     case _humongous_start:
182     case _humongous_cont:
183       set_state(_humongous_cont);
184       return;
185     default:
186       report_illegal_transition(&quot;humongous continuation bypass&quot;);
187   }
188 }
189 
190 void ShenandoahHeapRegion::make_pinned() {
<span class="line-modified">191   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
192   assert(pin_count() &gt; 0, &quot;Should have pins: &quot; SIZE_FORMAT, pin_count());
193 
194   switch (_state) {
195     case _regular:
196       set_state(_pinned);
197     case _pinned_cset:
198     case _pinned:
199       return;
200     case _humongous_start:
201       set_state(_pinned_humongous_start);
202     case _pinned_humongous_start:
203       return;
204     case _cset:
205       _state = _pinned_cset;
206       return;
207     default:
208       report_illegal_transition(&quot;pinning&quot;);
209   }
210 }
211 
212 void ShenandoahHeapRegion::make_unpinned() {
<span class="line-modified">213   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
214   assert(pin_count() == 0, &quot;Should not have pins: &quot; SIZE_FORMAT, pin_count());
215 
216   switch (_state) {
217     case _pinned:
218       set_state(_regular);
219       return;
220     case _regular:
221     case _humongous_start:
222       return;
223     case _pinned_cset:
224       set_state(_cset);
225       return;
226     case _pinned_humongous_start:
227       set_state(_humongous_start);
228       return;
229     default:
230       report_illegal_transition(&quot;unpinning&quot;);
231   }
232 }
233 
234 void ShenandoahHeapRegion::make_cset() {
<span class="line-modified">235   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
236   switch (_state) {
237     case _regular:
238       set_state(_cset);
239     case _cset:
240       return;
241     default:
242       report_illegal_transition(&quot;cset&quot;);
243   }
244 }
245 
246 void ShenandoahHeapRegion::make_trash() {
<span class="line-modified">247   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
248   switch (_state) {
249     case _cset:
250       // Reclaiming cset regions
251     case _humongous_start:
252     case _humongous_cont:
253       // Reclaiming humongous regions
254     case _regular:
255       // Immediate region reclaim
256       set_state(_trash);
257       return;
258     default:
259       report_illegal_transition(&quot;trashing&quot;);
260   }
261 }
262 
263 void ShenandoahHeapRegion::make_trash_immediate() {
264   make_trash();
265 
266   // On this path, we know there are no marked objects in the region,
267   // tell marking context about it to bypass bitmap resets.
<span class="line-modified">268   _heap-&gt;complete_marking_context()-&gt;reset_top_bitmap(this);</span>
269 }
270 
271 void ShenandoahHeapRegion::make_empty() {
<span class="line-modified">272   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
273   switch (_state) {
274     case _trash:
275       set_state(_empty_committed);
276       _empty_time = os::elapsedTime();
277       return;
278     default:
279       report_illegal_transition(&quot;emptying&quot;);
280   }
281 }
282 
283 void ShenandoahHeapRegion::make_uncommitted() {
<span class="line-modified">284   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
285   switch (_state) {
286     case _empty_committed:
287       do_uncommit();
288       set_state(_empty_uncommitted);
289       return;
290     default:
291       report_illegal_transition(&quot;uncommiting&quot;);
292   }
293 }
294 
295 void ShenandoahHeapRegion::make_committed_bypass() {
<span class="line-modified">296   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
<span class="line-modified">297   assert (_heap-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
298 
299   switch (_state) {
300     case _empty_uncommitted:
301       do_commit();
302       set_state(_empty_committed);
303       return;
304     default:
305       report_illegal_transition(&quot;commit bypass&quot;);
306   }
307 }
308 
309 void ShenandoahHeapRegion::clear_live_data() {
310   Atomic::release_store_fence(&amp;_live_data, (size_t)0);
311 }
312 
313 void ShenandoahHeapRegion::reset_alloc_metadata() {
314   _tlab_allocs = 0;
315   _gclab_allocs = 0;
316   _shared_allocs = 0;
<span class="line-removed">317   _seqnum_first_alloc_mutator = 0;</span>
318   _seqnum_last_alloc_mutator = 0;
<span class="line-removed">319   _seqnum_first_alloc_gc = 0;</span>
<span class="line-removed">320   _seqnum_last_alloc_gc = 0;</span>
321 }
322 
323 void ShenandoahHeapRegion::reset_alloc_metadata_to_shared() {
324   if (used() &gt; 0) {
325     _tlab_allocs = 0;
326     _gclab_allocs = 0;
327     _shared_allocs = used() &gt;&gt; LogHeapWordSize;
<span class="line-modified">328     uint64_t next = _alloc_seq_num.value++;</span>
<span class="line-modified">329     _seqnum_first_alloc_mutator = next;</span>
<span class="line-modified">330     _seqnum_last_alloc_mutator = next;</span>
<span class="line-removed">331     _seqnum_first_alloc_gc = 0;</span>
<span class="line-removed">332     _seqnum_last_alloc_gc = 0;</span>
333   } else {
334     reset_alloc_metadata();
335   }
336 }
337 






338 size_t ShenandoahHeapRegion::get_shared_allocs() const {
339   return _shared_allocs * HeapWordSize;
340 }
341 
342 size_t ShenandoahHeapRegion::get_tlab_allocs() const {
343   return _tlab_allocs * HeapWordSize;
344 }
345 
346 size_t ShenandoahHeapRegion::get_gclab_allocs() const {
347   return _gclab_allocs * HeapWordSize;
348 }
349 
350 void ShenandoahHeapRegion::set_live_data(size_t s) {
351   assert(Thread::current()-&gt;is_VM_thread(), &quot;by VM thread&quot;);
352   _live_data = (s &gt;&gt; LogHeapWordSize);
353 }
354 
355 size_t ShenandoahHeapRegion::get_live_data_words() const {
356   return Atomic::load_acquire(&amp;_live_data);
357 }
</pre>
<hr />
<pre>
396       st-&gt;print(&quot;|HC &quot;);
397       break;
398     case _cset:
399       st-&gt;print(&quot;|CS &quot;);
400       break;
401     case _trash:
402       st-&gt;print(&quot;|T  &quot;);
403       break;
404     case _pinned:
405       st-&gt;print(&quot;|P  &quot;);
406       break;
407     case _pinned_cset:
408       st-&gt;print(&quot;|CSP&quot;);
409       break;
410     default:
411       ShouldNotReachHere();
412   }
413   st-&gt;print(&quot;|BTE &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12),
414             p2i(bottom()), p2i(top()), p2i(end()));
415   st-&gt;print(&quot;|TAMS &quot; INTPTR_FORMAT_W(12),
<span class="line-modified">416             p2i(_heap-&gt;marking_context()-&gt;top_at_mark_start(const_cast&lt;ShenandoahHeapRegion*&gt;(this))));</span>


417   st-&gt;print(&quot;|U &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(used()),                proper_unit_for_byte_size(used()));
418   st-&gt;print(&quot;|T &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_tlab_allocs()),     proper_unit_for_byte_size(get_tlab_allocs()));
419   st-&gt;print(&quot;|G &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_gclab_allocs()),    proper_unit_for_byte_size(get_gclab_allocs()));
420   st-&gt;print(&quot;|S &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_shared_allocs()),   proper_unit_for_byte_size(get_shared_allocs()));
421   st-&gt;print(&quot;|L &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_live_data_bytes()), proper_unit_for_byte_size(get_live_data_bytes()));
422   st-&gt;print(&quot;|CP &quot; SIZE_FORMAT_W(3), pin_count());
<span class="line-modified">423   st-&gt;print(&quot;|SN &quot; UINT64_FORMAT_X_W(12) &quot;, &quot; UINT64_FORMAT_X_W(8) &quot;, &quot; UINT64_FORMAT_X_W(8) &quot;, &quot; UINT64_FORMAT_X_W(8),</span>
<span class="line-removed">424             seqnum_first_alloc_mutator(), seqnum_last_alloc_mutator(),</span>
<span class="line-removed">425             seqnum_first_alloc_gc(), seqnum_last_alloc_gc());</span>
426   st-&gt;cr();
427 }
428 
429 void ShenandoahHeapRegion::oop_iterate(OopIterateClosure* blk) {
430   if (!is_active()) return;
431   if (is_humongous()) {
432     oop_iterate_humongous(blk);
433   } else {
434     oop_iterate_objects(blk);
435   }
436 }
437 
438 void ShenandoahHeapRegion::oop_iterate_objects(OopIterateClosure* blk) {
439   assert(! is_humongous(), &quot;no humongous region here&quot;);
440   HeapWord* obj_addr = bottom();
441   HeapWord* t = top();
442   // Could call objects iterate, but this is easier.
443   while (obj_addr &lt; t) {
444     oop obj = oop(obj_addr);
445     obj_addr += obj-&gt;oop_iterate_size(blk);
446   }
447 }
448 
449 void ShenandoahHeapRegion::oop_iterate_humongous(OopIterateClosure* blk) {
450   assert(is_humongous(), &quot;only humongous region here&quot;);
451   // Find head.
452   ShenandoahHeapRegion* r = humongous_start_region();
453   assert(r-&gt;is_humongous_start(), &quot;need humongous head here&quot;);
454   oop obj = oop(r-&gt;bottom());
455   obj-&gt;oop_iterate(blk, MemRegion(bottom(), top()));
456 }
457 
458 ShenandoahHeapRegion* ShenandoahHeapRegion::humongous_start_region() const {

459   assert(is_humongous(), &quot;Must be a part of the humongous region&quot;);
460   size_t reg_num = region_number();
461   ShenandoahHeapRegion* r = const_cast&lt;ShenandoahHeapRegion*&gt;(this);
462   while (!r-&gt;is_humongous_start()) {
463     assert(reg_num &gt; 0, &quot;Sanity&quot;);
464     reg_num --;
<span class="line-modified">465     r = _heap-&gt;get_region(reg_num);</span>
466     assert(r-&gt;is_humongous(), &quot;Must be a part of the humongous region&quot;);
467   }
468   assert(r-&gt;is_humongous_start(), &quot;Must be&quot;);
469   return r;
470 }
471 
472 void ShenandoahHeapRegion::recycle() {
<span class="line-modified">473   ContiguousSpace::clear(false);</span>
<span class="line-removed">474   if (ZapUnusedHeapArea) {</span>
<span class="line-removed">475     ContiguousSpace::mangle_unused_area_complete();</span>
<span class="line-removed">476   }</span>
477   clear_live_data();
478 
479   reset_alloc_metadata();
480 
<span class="line-modified">481   _heap-&gt;marking_context()-&gt;reset_top_at_mark_start(this);</span>

482 
483   make_empty();




484 }
485 
<span class="line-modified">486 HeapWord* ShenandoahHeapRegion::block_start_const(const void* p) const {</span>
487   assert(MemRegion(bottom(), end()).contains(p),
488          &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
489          p2i(p), p2i(bottom()), p2i(end()));
490   if (p &gt;= top()) {
491     return top();
492   } else {
493     HeapWord* last = bottom();
494     HeapWord* cur = last;
495     while (cur &lt;= p) {
496       last = cur;
497       cur += oop(cur)-&gt;size();
498     }
499     shenandoah_assert_correct(NULL, oop(last));
500     return last;
501   }
502 }
503 












504 void ShenandoahHeapRegion::setup_sizes(size_t max_heap_size) {
505   // Absolute minimums we should not ever break.
506   static const size_t MIN_REGION_SIZE = 256*K;
507 
508   if (FLAG_IS_DEFAULT(ShenandoahMinRegionSize)) {
509     FLAG_SET_DEFAULT(ShenandoahMinRegionSize, MIN_REGION_SIZE);
510   }
511 
512   size_t region_size;
513   if (FLAG_IS_DEFAULT(ShenandoahHeapRegionSize)) {
514     if (ShenandoahMinRegionSize &gt; max_heap_size / MIN_NUM_REGIONS) {
515       err_msg message(&quot;Max heap size (&quot; SIZE_FORMAT &quot;%s) is too low to afford the minimum number &quot;
516                       &quot;of regions (&quot; SIZE_FORMAT &quot;) of minimum region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
517                       byte_size_in_proper_unit(max_heap_size), proper_unit_for_byte_size(max_heap_size),
518                       MIN_NUM_REGIONS,
519                       byte_size_in_proper_unit(ShenandoahMinRegionSize), proper_unit_for_byte_size(ShenandoahMinRegionSize));
520       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
521     }
522     if (ShenandoahMinRegionSize &lt; MIN_REGION_SIZE) {
523       err_msg message(&quot;&quot; SIZE_FORMAT &quot;%s should not be lower than minimum region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
</pre>
<hr />
<pre>
639   //
640   // The whole thing is mitigated if Elastic TLABs are enabled.
641   //
642   guarantee(MaxTLABSizeWords == 0, &quot;we should only set it once&quot;);
643   MaxTLABSizeWords = MIN2(ShenandoahElasticTLAB ? RegionSizeWords : (RegionSizeWords / 8), HumongousThresholdWords);
644   MaxTLABSizeWords = align_down(MaxTLABSizeWords, MinObjAlignment);
645 
646   guarantee(MaxTLABSizeBytes == 0, &quot;we should only set it once&quot;);
647   MaxTLABSizeBytes = MaxTLABSizeWords * HeapWordSize;
648   assert (MaxTLABSizeBytes &gt; MinTLABSize, &quot;should be larger&quot;);
649 
650   log_info(gc, init)(&quot;Regions: &quot; SIZE_FORMAT &quot; x &quot; SIZE_FORMAT &quot;%s&quot;,
651                      RegionCount, byte_size_in_proper_unit(RegionSizeBytes), proper_unit_for_byte_size(RegionSizeBytes));
652   log_info(gc, init)(&quot;Humongous object threshold: &quot; SIZE_FORMAT &quot;%s&quot;,
653                      byte_size_in_proper_unit(HumongousThresholdBytes), proper_unit_for_byte_size(HumongousThresholdBytes));
654   log_info(gc, init)(&quot;Max TLAB size: &quot; SIZE_FORMAT &quot;%s&quot;,
655                      byte_size_in_proper_unit(MaxTLABSizeBytes), proper_unit_for_byte_size(MaxTLABSizeBytes));
656 }
657 
658 void ShenandoahHeapRegion::do_commit() {
<span class="line-modified">659   if (!_heap-&gt;is_heap_region_special() &amp;&amp; !os::commit_memory((char *) _reserved.start(), _reserved.byte_size(), false)) {</span>

660     report_java_out_of_memory(&quot;Unable to commit region&quot;);
661   }
<span class="line-modified">662   if (!_heap-&gt;commit_bitmap_slice(this)) {</span>
663     report_java_out_of_memory(&quot;Unable to commit bitmaps for region&quot;);
664   }
<span class="line-modified">665   _heap-&gt;increase_committed(ShenandoahHeapRegion::region_size_bytes());</span>
666 }
667 
668 void ShenandoahHeapRegion::do_uncommit() {
<span class="line-modified">669   if (!_heap-&gt;is_heap_region_special() &amp;&amp; !os::uncommit_memory((char *) _reserved.start(), _reserved.byte_size())) {</span>

670     report_java_out_of_memory(&quot;Unable to uncommit region&quot;);
671   }
<span class="line-modified">672   if (!_heap-&gt;uncommit_bitmap_slice(this)) {</span>
673     report_java_out_of_memory(&quot;Unable to uncommit bitmaps for region&quot;);
674   }
<span class="line-modified">675   _heap-&gt;decrease_committed(ShenandoahHeapRegion::region_size_bytes());</span>
676 }
677 
678 void ShenandoahHeapRegion::set_state(RegionState to) {
679   EventShenandoahHeapRegionStateChange evt;
680   if (evt.should_commit()){
681     evt.set_index((unsigned)region_number());
682     evt.set_start((uintptr_t)bottom());
683     evt.set_used(used());
684     evt.set_from(_state);
685     evt.set_to(to);
686     evt.commit();
687   }
688   _state = to;
689 }
690 
691 void ShenandoahHeapRegion::record_pin() {
692   Atomic::add(&amp;_critical_pins, (size_t)1);
693 }
694 
695 void ShenandoahHeapRegion::record_unpin() {
</pre>
</td>
<td>
<hr />
<pre>
 38 #include &quot;runtime/atomic.hpp&quot;
 39 #include &quot;runtime/java.hpp&quot;
 40 #include &quot;runtime/mutexLocker.hpp&quot;
 41 #include &quot;runtime/os.hpp&quot;
 42 #include &quot;runtime/safepoint.hpp&quot;
 43 
 44 size_t ShenandoahHeapRegion::RegionCount = 0;
 45 size_t ShenandoahHeapRegion::RegionSizeBytes = 0;
 46 size_t ShenandoahHeapRegion::RegionSizeWords = 0;
 47 size_t ShenandoahHeapRegion::RegionSizeBytesShift = 0;
 48 size_t ShenandoahHeapRegion::RegionSizeWordsShift = 0;
 49 size_t ShenandoahHeapRegion::RegionSizeBytesMask = 0;
 50 size_t ShenandoahHeapRegion::RegionSizeWordsMask = 0;
 51 size_t ShenandoahHeapRegion::HumongousThresholdBytes = 0;
 52 size_t ShenandoahHeapRegion::HumongousThresholdWords = 0;
 53 size_t ShenandoahHeapRegion::MaxTLABSizeBytes = 0;
 54 size_t ShenandoahHeapRegion::MaxTLABSizeWords = 0;
 55 
 56 ShenandoahHeapRegion::PaddedAllocSeqNum ShenandoahHeapRegion::_alloc_seq_num;
 57 
<span class="line-modified"> 58 ShenandoahHeapRegion::ShenandoahHeapRegion(HeapWord* start, size_t index, bool committed) :</span>



 59   _region_number(index),
<span class="line-added"> 60   _bottom(start),</span>
<span class="line-added"> 61   _end(start + RegionSizeWords),</span>
 62   _new_top(NULL),
 63   _empty_time(os::elapsedTime()),
 64   _state(committed ? _empty_committed : _empty_uncommitted),
<span class="line-added"> 65   _top(start),</span>
 66   _tlab_allocs(0),
 67   _gclab_allocs(0),
 68   _shared_allocs(0),


 69   _seqnum_last_alloc_mutator(0),

 70   _live_data(0),
<span class="line-modified"> 71   _critical_pins(0),</span>
<span class="line-added"> 72   _update_watermark(start) {</span>
 73 
<span class="line-modified"> 74   assert(Universe::on_page_boundary(_bottom) &amp;&amp; Universe::on_page_boundary(_end),</span>
<span class="line-added"> 75          &quot;invalid space boundaries&quot;);</span>
<span class="line-added"> 76   if (ZapUnusedHeapArea &amp;&amp; committed) {</span>
<span class="line-added"> 77     SpaceMangler::mangle_region(MemRegion(_bottom, _end));</span>
<span class="line-added"> 78   }</span>
 79 }
 80 
 81 size_t ShenandoahHeapRegion::region_number() const {
 82   return _region_number;
 83 }
 84 
 85 void ShenandoahHeapRegion::report_illegal_transition(const char *method) {
 86   ResourceMark rm;
 87   stringStream ss;
 88   ss.print(&quot;Illegal region state transition from \&quot;%s\&quot;, at %s\n  &quot;, region_state_to_string(_state), method);
 89   print_on(&amp;ss);
 90   fatal(&quot;%s&quot;, ss.as_string());
 91 }
 92 
 93 void ShenandoahHeapRegion::make_regular_allocation() {
<span class="line-modified"> 94   shenandoah_assert_heaplocked();</span>
 95 
 96   switch (_state) {
 97     case _empty_uncommitted:
 98       do_commit();
 99     case _empty_committed:
100       set_state(_regular);
101     case _regular:
102     case _pinned:
103       return;
104     default:
105       report_illegal_transition(&quot;regular allocation&quot;);
106   }
107 }
108 
109 void ShenandoahHeapRegion::make_regular_bypass() {
<span class="line-modified">110   shenandoah_assert_heaplocked();</span>
<span class="line-modified">111   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress() || ShenandoahHeap::heap()-&gt;is_degenerated_gc_in_progress(),</span>
112           &quot;only for full or degen GC&quot;);
113 
114   switch (_state) {
115     case _empty_uncommitted:
116       do_commit();
117     case _empty_committed:
118     case _cset:
119     case _humongous_start:
120     case _humongous_cont:
121       set_state(_regular);
122       return;
123     case _pinned_cset:
124       set_state(_pinned);
125       return;
126     case _regular:
127     case _pinned:
128       return;
129     default:
130       report_illegal_transition(&quot;regular bypass&quot;);
131   }
132 }
133 
134 void ShenandoahHeapRegion::make_humongous_start() {
<span class="line-modified">135   shenandoah_assert_heaplocked();</span>
136   switch (_state) {
137     case _empty_uncommitted:
138       do_commit();
139     case _empty_committed:
140       set_state(_humongous_start);
141       return;
142     default:
143       report_illegal_transition(&quot;humongous start allocation&quot;);
144   }
145 }
146 
147 void ShenandoahHeapRegion::make_humongous_start_bypass() {
<span class="line-modified">148   shenandoah_assert_heaplocked();</span>
<span class="line-modified">149   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
150 
151   switch (_state) {
152     case _empty_committed:
153     case _regular:
154     case _humongous_start:
155     case _humongous_cont:
156       set_state(_humongous_start);
157       return;
158     default:
159       report_illegal_transition(&quot;humongous start bypass&quot;);
160   }
161 }
162 
163 void ShenandoahHeapRegion::make_humongous_cont() {
<span class="line-modified">164   shenandoah_assert_heaplocked();</span>
165   switch (_state) {
166     case _empty_uncommitted:
167       do_commit();
168     case _empty_committed:
169      set_state(_humongous_cont);
170       return;
171     default:
172       report_illegal_transition(&quot;humongous continuation allocation&quot;);
173   }
174 }
175 
176 void ShenandoahHeapRegion::make_humongous_cont_bypass() {
<span class="line-modified">177   shenandoah_assert_heaplocked();</span>
<span class="line-modified">178   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
179 
180   switch (_state) {
181     case _empty_committed:
182     case _regular:
183     case _humongous_start:
184     case _humongous_cont:
185       set_state(_humongous_cont);
186       return;
187     default:
188       report_illegal_transition(&quot;humongous continuation bypass&quot;);
189   }
190 }
191 
192 void ShenandoahHeapRegion::make_pinned() {
<span class="line-modified">193   shenandoah_assert_heaplocked();</span>
194   assert(pin_count() &gt; 0, &quot;Should have pins: &quot; SIZE_FORMAT, pin_count());
195 
196   switch (_state) {
197     case _regular:
198       set_state(_pinned);
199     case _pinned_cset:
200     case _pinned:
201       return;
202     case _humongous_start:
203       set_state(_pinned_humongous_start);
204     case _pinned_humongous_start:
205       return;
206     case _cset:
207       _state = _pinned_cset;
208       return;
209     default:
210       report_illegal_transition(&quot;pinning&quot;);
211   }
212 }
213 
214 void ShenandoahHeapRegion::make_unpinned() {
<span class="line-modified">215   shenandoah_assert_heaplocked();</span>
216   assert(pin_count() == 0, &quot;Should not have pins: &quot; SIZE_FORMAT, pin_count());
217 
218   switch (_state) {
219     case _pinned:
220       set_state(_regular);
221       return;
222     case _regular:
223     case _humongous_start:
224       return;
225     case _pinned_cset:
226       set_state(_cset);
227       return;
228     case _pinned_humongous_start:
229       set_state(_humongous_start);
230       return;
231     default:
232       report_illegal_transition(&quot;unpinning&quot;);
233   }
234 }
235 
236 void ShenandoahHeapRegion::make_cset() {
<span class="line-modified">237   shenandoah_assert_heaplocked();</span>
238   switch (_state) {
239     case _regular:
240       set_state(_cset);
241     case _cset:
242       return;
243     default:
244       report_illegal_transition(&quot;cset&quot;);
245   }
246 }
247 
248 void ShenandoahHeapRegion::make_trash() {
<span class="line-modified">249   shenandoah_assert_heaplocked();</span>
250   switch (_state) {
251     case _cset:
252       // Reclaiming cset regions
253     case _humongous_start:
254     case _humongous_cont:
255       // Reclaiming humongous regions
256     case _regular:
257       // Immediate region reclaim
258       set_state(_trash);
259       return;
260     default:
261       report_illegal_transition(&quot;trashing&quot;);
262   }
263 }
264 
265 void ShenandoahHeapRegion::make_trash_immediate() {
266   make_trash();
267 
268   // On this path, we know there are no marked objects in the region,
269   // tell marking context about it to bypass bitmap resets.
<span class="line-modified">270   ShenandoahHeap::heap()-&gt;complete_marking_context()-&gt;reset_top_bitmap(this);</span>
271 }
272 
273 void ShenandoahHeapRegion::make_empty() {
<span class="line-modified">274   shenandoah_assert_heaplocked();</span>
275   switch (_state) {
276     case _trash:
277       set_state(_empty_committed);
278       _empty_time = os::elapsedTime();
279       return;
280     default:
281       report_illegal_transition(&quot;emptying&quot;);
282   }
283 }
284 
285 void ShenandoahHeapRegion::make_uncommitted() {
<span class="line-modified">286   shenandoah_assert_heaplocked();</span>
287   switch (_state) {
288     case _empty_committed:
289       do_uncommit();
290       set_state(_empty_uncommitted);
291       return;
292     default:
293       report_illegal_transition(&quot;uncommiting&quot;);
294   }
295 }
296 
297 void ShenandoahHeapRegion::make_committed_bypass() {
<span class="line-modified">298   shenandoah_assert_heaplocked();</span>
<span class="line-modified">299   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
300 
301   switch (_state) {
302     case _empty_uncommitted:
303       do_commit();
304       set_state(_empty_committed);
305       return;
306     default:
307       report_illegal_transition(&quot;commit bypass&quot;);
308   }
309 }
310 
311 void ShenandoahHeapRegion::clear_live_data() {
312   Atomic::release_store_fence(&amp;_live_data, (size_t)0);
313 }
314 
315 void ShenandoahHeapRegion::reset_alloc_metadata() {
316   _tlab_allocs = 0;
317   _gclab_allocs = 0;
318   _shared_allocs = 0;

319   _seqnum_last_alloc_mutator = 0;


320 }
321 
322 void ShenandoahHeapRegion::reset_alloc_metadata_to_shared() {
323   if (used() &gt; 0) {
324     _tlab_allocs = 0;
325     _gclab_allocs = 0;
326     _shared_allocs = used() &gt;&gt; LogHeapWordSize;
<span class="line-modified">327     if (ShenandoahHeap::heap()-&gt;is_traversal_mode()) {</span>
<span class="line-modified">328       update_seqnum_last_alloc_mutator();</span>
<span class="line-modified">329     }</span>


330   } else {
331     reset_alloc_metadata();
332   }
333 }
334 
<span class="line-added">335 void ShenandoahHeapRegion::update_seqnum_last_alloc_mutator() {</span>
<span class="line-added">336   assert(ShenandoahHeap::heap()-&gt;is_traversal_mode(), &quot;Sanity&quot;);</span>
<span class="line-added">337   shenandoah_assert_heaplocked_or_safepoint();</span>
<span class="line-added">338   _seqnum_last_alloc_mutator = _alloc_seq_num.value++;</span>
<span class="line-added">339 }</span>
<span class="line-added">340 </span>
341 size_t ShenandoahHeapRegion::get_shared_allocs() const {
342   return _shared_allocs * HeapWordSize;
343 }
344 
345 size_t ShenandoahHeapRegion::get_tlab_allocs() const {
346   return _tlab_allocs * HeapWordSize;
347 }
348 
349 size_t ShenandoahHeapRegion::get_gclab_allocs() const {
350   return _gclab_allocs * HeapWordSize;
351 }
352 
353 void ShenandoahHeapRegion::set_live_data(size_t s) {
354   assert(Thread::current()-&gt;is_VM_thread(), &quot;by VM thread&quot;);
355   _live_data = (s &gt;&gt; LogHeapWordSize);
356 }
357 
358 size_t ShenandoahHeapRegion::get_live_data_words() const {
359   return Atomic::load_acquire(&amp;_live_data);
360 }
</pre>
<hr />
<pre>
399       st-&gt;print(&quot;|HC &quot;);
400       break;
401     case _cset:
402       st-&gt;print(&quot;|CS &quot;);
403       break;
404     case _trash:
405       st-&gt;print(&quot;|T  &quot;);
406       break;
407     case _pinned:
408       st-&gt;print(&quot;|P  &quot;);
409       break;
410     case _pinned_cset:
411       st-&gt;print(&quot;|CSP&quot;);
412       break;
413     default:
414       ShouldNotReachHere();
415   }
416   st-&gt;print(&quot;|BTE &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12),
417             p2i(bottom()), p2i(top()), p2i(end()));
418   st-&gt;print(&quot;|TAMS &quot; INTPTR_FORMAT_W(12),
<span class="line-modified">419             p2i(ShenandoahHeap::heap()-&gt;marking_context()-&gt;top_at_mark_start(const_cast&lt;ShenandoahHeapRegion*&gt;(this))));</span>
<span class="line-added">420   st-&gt;print(&quot;|UWM &quot; INTPTR_FORMAT_W(12),</span>
<span class="line-added">421             p2i(_update_watermark));</span>
422   st-&gt;print(&quot;|U &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(used()),                proper_unit_for_byte_size(used()));
423   st-&gt;print(&quot;|T &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_tlab_allocs()),     proper_unit_for_byte_size(get_tlab_allocs()));
424   st-&gt;print(&quot;|G &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_gclab_allocs()),    proper_unit_for_byte_size(get_gclab_allocs()));
425   st-&gt;print(&quot;|S &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_shared_allocs()),   proper_unit_for_byte_size(get_shared_allocs()));
426   st-&gt;print(&quot;|L &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_live_data_bytes()), proper_unit_for_byte_size(get_live_data_bytes()));
427   st-&gt;print(&quot;|CP &quot; SIZE_FORMAT_W(3), pin_count());
<span class="line-modified">428   st-&gt;print(&quot;|SN &quot; UINT64_FORMAT_X_W(12), _seqnum_last_alloc_mutator);</span>


429   st-&gt;cr();
430 }
431 
432 void ShenandoahHeapRegion::oop_iterate(OopIterateClosure* blk) {
433   if (!is_active()) return;
434   if (is_humongous()) {
435     oop_iterate_humongous(blk);
436   } else {
437     oop_iterate_objects(blk);
438   }
439 }
440 
441 void ShenandoahHeapRegion::oop_iterate_objects(OopIterateClosure* blk) {
442   assert(! is_humongous(), &quot;no humongous region here&quot;);
443   HeapWord* obj_addr = bottom();
444   HeapWord* t = top();
445   // Could call objects iterate, but this is easier.
446   while (obj_addr &lt; t) {
447     oop obj = oop(obj_addr);
448     obj_addr += obj-&gt;oop_iterate_size(blk);
449   }
450 }
451 
452 void ShenandoahHeapRegion::oop_iterate_humongous(OopIterateClosure* blk) {
453   assert(is_humongous(), &quot;only humongous region here&quot;);
454   // Find head.
455   ShenandoahHeapRegion* r = humongous_start_region();
456   assert(r-&gt;is_humongous_start(), &quot;need humongous head here&quot;);
457   oop obj = oop(r-&gt;bottom());
458   obj-&gt;oop_iterate(blk, MemRegion(bottom(), top()));
459 }
460 
461 ShenandoahHeapRegion* ShenandoahHeapRegion::humongous_start_region() const {
<span class="line-added">462   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
463   assert(is_humongous(), &quot;Must be a part of the humongous region&quot;);
464   size_t reg_num = region_number();
465   ShenandoahHeapRegion* r = const_cast&lt;ShenandoahHeapRegion*&gt;(this);
466   while (!r-&gt;is_humongous_start()) {
467     assert(reg_num &gt; 0, &quot;Sanity&quot;);
468     reg_num --;
<span class="line-modified">469     r = heap-&gt;get_region(reg_num);</span>
470     assert(r-&gt;is_humongous(), &quot;Must be a part of the humongous region&quot;);
471   }
472   assert(r-&gt;is_humongous_start(), &quot;Must be&quot;);
473   return r;
474 }
475 
476 void ShenandoahHeapRegion::recycle() {
<span class="line-modified">477   set_top(bottom());</span>



478   clear_live_data();
479 
480   reset_alloc_metadata();
481 
<span class="line-modified">482   ShenandoahHeap::heap()-&gt;marking_context()-&gt;reset_top_at_mark_start(this);</span>
<span class="line-added">483   set_update_watermark(bottom());</span>
484 
485   make_empty();
<span class="line-added">486 </span>
<span class="line-added">487   if (ZapUnusedHeapArea) {</span>
<span class="line-added">488     SpaceMangler::mangle_region(MemRegion(bottom(), end()));</span>
<span class="line-added">489   }</span>
490 }
491 
<span class="line-modified">492 HeapWord* ShenandoahHeapRegion::block_start(const void* p) const {</span>
493   assert(MemRegion(bottom(), end()).contains(p),
494          &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
495          p2i(p), p2i(bottom()), p2i(end()));
496   if (p &gt;= top()) {
497     return top();
498   } else {
499     HeapWord* last = bottom();
500     HeapWord* cur = last;
501     while (cur &lt;= p) {
502       last = cur;
503       cur += oop(cur)-&gt;size();
504     }
505     shenandoah_assert_correct(NULL, oop(last));
506     return last;
507   }
508 }
509 
<span class="line-added">510 size_t ShenandoahHeapRegion::block_size(const HeapWord* p) const {</span>
<span class="line-added">511   assert(MemRegion(bottom(), end()).contains(p),</span>
<span class="line-added">512          &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,</span>
<span class="line-added">513          p2i(p), p2i(bottom()), p2i(end()));</span>
<span class="line-added">514   if (p &lt; top()) {</span>
<span class="line-added">515     return oop(p)-&gt;size();</span>
<span class="line-added">516   } else {</span>
<span class="line-added">517     assert(p == top(), &quot;just checking&quot;);</span>
<span class="line-added">518     return pointer_delta(end(), (HeapWord*) p);</span>
<span class="line-added">519   }</span>
<span class="line-added">520 }</span>
<span class="line-added">521 </span>
522 void ShenandoahHeapRegion::setup_sizes(size_t max_heap_size) {
523   // Absolute minimums we should not ever break.
524   static const size_t MIN_REGION_SIZE = 256*K;
525 
526   if (FLAG_IS_DEFAULT(ShenandoahMinRegionSize)) {
527     FLAG_SET_DEFAULT(ShenandoahMinRegionSize, MIN_REGION_SIZE);
528   }
529 
530   size_t region_size;
531   if (FLAG_IS_DEFAULT(ShenandoahHeapRegionSize)) {
532     if (ShenandoahMinRegionSize &gt; max_heap_size / MIN_NUM_REGIONS) {
533       err_msg message(&quot;Max heap size (&quot; SIZE_FORMAT &quot;%s) is too low to afford the minimum number &quot;
534                       &quot;of regions (&quot; SIZE_FORMAT &quot;) of minimum region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
535                       byte_size_in_proper_unit(max_heap_size), proper_unit_for_byte_size(max_heap_size),
536                       MIN_NUM_REGIONS,
537                       byte_size_in_proper_unit(ShenandoahMinRegionSize), proper_unit_for_byte_size(ShenandoahMinRegionSize));
538       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
539     }
540     if (ShenandoahMinRegionSize &lt; MIN_REGION_SIZE) {
541       err_msg message(&quot;&quot; SIZE_FORMAT &quot;%s should not be lower than minimum region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
</pre>
<hr />
<pre>
657   //
658   // The whole thing is mitigated if Elastic TLABs are enabled.
659   //
660   guarantee(MaxTLABSizeWords == 0, &quot;we should only set it once&quot;);
661   MaxTLABSizeWords = MIN2(ShenandoahElasticTLAB ? RegionSizeWords : (RegionSizeWords / 8), HumongousThresholdWords);
662   MaxTLABSizeWords = align_down(MaxTLABSizeWords, MinObjAlignment);
663 
664   guarantee(MaxTLABSizeBytes == 0, &quot;we should only set it once&quot;);
665   MaxTLABSizeBytes = MaxTLABSizeWords * HeapWordSize;
666   assert (MaxTLABSizeBytes &gt; MinTLABSize, &quot;should be larger&quot;);
667 
668   log_info(gc, init)(&quot;Regions: &quot; SIZE_FORMAT &quot; x &quot; SIZE_FORMAT &quot;%s&quot;,
669                      RegionCount, byte_size_in_proper_unit(RegionSizeBytes), proper_unit_for_byte_size(RegionSizeBytes));
670   log_info(gc, init)(&quot;Humongous object threshold: &quot; SIZE_FORMAT &quot;%s&quot;,
671                      byte_size_in_proper_unit(HumongousThresholdBytes), proper_unit_for_byte_size(HumongousThresholdBytes));
672   log_info(gc, init)(&quot;Max TLAB size: &quot; SIZE_FORMAT &quot;%s&quot;,
673                      byte_size_in_proper_unit(MaxTLABSizeBytes), proper_unit_for_byte_size(MaxTLABSizeBytes));
674 }
675 
676 void ShenandoahHeapRegion::do_commit() {
<span class="line-modified">677   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-added">678   if (!heap-&gt;is_heap_region_special() &amp;&amp; !os::commit_memory((char *) bottom(), RegionSizeBytes, false)) {</span>
679     report_java_out_of_memory(&quot;Unable to commit region&quot;);
680   }
<span class="line-modified">681   if (!heap-&gt;commit_bitmap_slice(this)) {</span>
682     report_java_out_of_memory(&quot;Unable to commit bitmaps for region&quot;);
683   }
<span class="line-modified">684   heap-&gt;increase_committed(ShenandoahHeapRegion::region_size_bytes());</span>
685 }
686 
687 void ShenandoahHeapRegion::do_uncommit() {
<span class="line-modified">688   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-added">689   if (!heap-&gt;is_heap_region_special() &amp;&amp; !os::uncommit_memory((char *) bottom(), RegionSizeBytes)) {</span>
690     report_java_out_of_memory(&quot;Unable to uncommit region&quot;);
691   }
<span class="line-modified">692   if (!heap-&gt;uncommit_bitmap_slice(this)) {</span>
693     report_java_out_of_memory(&quot;Unable to uncommit bitmaps for region&quot;);
694   }
<span class="line-modified">695   heap-&gt;decrease_committed(ShenandoahHeapRegion::region_size_bytes());</span>
696 }
697 
698 void ShenandoahHeapRegion::set_state(RegionState to) {
699   EventShenandoahHeapRegionStateChange evt;
700   if (evt.should_commit()){
701     evt.set_index((unsigned)region_number());
702     evt.set_start((uintptr_t)bottom());
703     evt.set_used(used());
704     evt.set_from(_state);
705     evt.set_to(to);
706     evt.commit();
707   }
708   _state = to;
709 }
710 
711 void ShenandoahHeapRegion::record_pin() {
712   Atomic::add(&amp;_critical_pins, (size_t)1);
713 }
714 
715 void ShenandoahHeapRegion::record_unpin() {
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahHeap.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/c2/cardTableBarrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="barrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../cardTable.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/c2/cardTableBarrierSetC2.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
132   }
133 
134   // Final sync IdealKit and GraphKit.
135   kit-&gt;final_sync(ideal);
136 }
137 
138 void CardTableBarrierSetC2::clone(GraphKit* kit, Node* src_base, Node* dst_base, Node* countx, bool is_array) const {
139   BarrierSetC2::clone(kit, src_base, dst_base, countx, is_array);
140   const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;
141 
142   // If necessary, emit some card marks afterwards.  (Non-arrays only.)
143   bool card_mark = !is_array &amp;&amp; !use_ReduceInitialCardMarks();
144   if (card_mark) {
145     assert(!is_array, &quot;&quot;);
146     // Put in store barrier for any and all oops we are sticking
147     // into this object.  (We could avoid this if we could prove
148     // that the object type contains no oop fields at all.)
149     Node* no_particular_value = NULL;
150     Node* no_particular_field = NULL;
151     int raw_adr_idx = Compile::AliasIdxRaw;
<span class="line-removed">152     intptr_t unused_offset;</span>
<span class="line-removed">153     Node* dst = AddPNode::Ideal_base_and_offset(dst_base, &amp;kit-&gt;gvn(), unused_offset);</span>
<span class="line-removed">154     assert(dst != NULL, &quot;dst_base not an Addp&quot;);</span>
155     post_barrier(kit, kit-&gt;control(),
156                  kit-&gt;memory(raw_adr_type),
<span class="line-modified">157                  dst,</span>
158                  no_particular_field,
159                  raw_adr_idx,
160                  no_particular_value,
161                  T_OBJECT,
162                  false);
163   }
164 }
165 
166 bool CardTableBarrierSetC2::use_ReduceInitialCardMarks() const {
167   return ReduceInitialCardMarks;
168 }
169 
170 bool CardTableBarrierSetC2::is_gc_barrier_node(Node* node) const {
171   return ModRefBarrierSetC2::is_gc_barrier_node(node) || node-&gt;Opcode() == Op_StoreCM;
172 }
173 
174 void CardTableBarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const {
175   assert(node-&gt;Opcode() == Op_CastP2X, &quot;ConvP2XNode required&quot;);
176   Node *shift = node-&gt;unique_out();
177   Node *addp = shift-&gt;unique_out();
</pre>
</td>
<td>
<hr />
<pre>
132   }
133 
134   // Final sync IdealKit and GraphKit.
135   kit-&gt;final_sync(ideal);
136 }
137 
138 void CardTableBarrierSetC2::clone(GraphKit* kit, Node* src_base, Node* dst_base, Node* countx, bool is_array) const {
139   BarrierSetC2::clone(kit, src_base, dst_base, countx, is_array);
140   const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;
141 
142   // If necessary, emit some card marks afterwards.  (Non-arrays only.)
143   bool card_mark = !is_array &amp;&amp; !use_ReduceInitialCardMarks();
144   if (card_mark) {
145     assert(!is_array, &quot;&quot;);
146     // Put in store barrier for any and all oops we are sticking
147     // into this object.  (We could avoid this if we could prove
148     // that the object type contains no oop fields at all.)
149     Node* no_particular_value = NULL;
150     Node* no_particular_field = NULL;
151     int raw_adr_idx = Compile::AliasIdxRaw;



152     post_barrier(kit, kit-&gt;control(),
153                  kit-&gt;memory(raw_adr_type),
<span class="line-modified">154                  dst_base,</span>
155                  no_particular_field,
156                  raw_adr_idx,
157                  no_particular_value,
158                  T_OBJECT,
159                  false);
160   }
161 }
162 
163 bool CardTableBarrierSetC2::use_ReduceInitialCardMarks() const {
164   return ReduceInitialCardMarks;
165 }
166 
167 bool CardTableBarrierSetC2::is_gc_barrier_node(Node* node) const {
168   return ModRefBarrierSetC2::is_gc_barrier_node(node) || node-&gt;Opcode() == Op_StoreCM;
169 }
170 
171 void CardTableBarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const {
172   assert(node-&gt;Opcode() == Op_CastP2X, &quot;ConvP2XNode required&quot;);
173   Node *shift = node-&gt;unique_out();
174   Node *addp = shift-&gt;unique_out();
</pre>
</td>
</tr>
</table>
<center><a href="barrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../cardTable.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
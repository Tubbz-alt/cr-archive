<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/c2/barrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../parallel/parallelScavengeHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="cardTableBarrierSetC2.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/c2/barrierSetC2.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
640   resolve_address(access);
641   return atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);
642 }
643 
644 Node* BarrierSetC2::atomic_xchg_at(C2AtomicParseAccess&amp; access, Node* new_val, const Type* value_type) const {
645   C2AccessFence fence(access);
646   resolve_address(access);
647   return atomic_xchg_at_resolved(access, new_val, value_type);
648 }
649 
650 Node* BarrierSetC2::atomic_add_at(C2AtomicParseAccess&amp; access, Node* new_val, const Type* value_type) const {
651   C2AccessFence fence(access);
652   resolve_address(access);
653   return atomic_add_at_resolved(access, new_val, value_type);
654 }
655 
656 int BarrierSetC2::arraycopy_payload_base_offset(bool is_array) {
657   // Exclude the header but include array length to copy by 8 bytes words.
658   // Can&#39;t use base_offset_in_bytes(bt) since basic type is unknown.
659   int base_off = is_array ? arrayOopDesc::length_offset_in_bytes() :
<span class="line-modified">660                  instanceOopDesc::base_offset_in_bytes();</span>
661   // base_off:
662   // 8  - 32-bit VM
663   // 12 - 64-bit VM, compressed klass
664   // 16 - 64-bit VM, normal klass
665   if (base_off % BytesPerLong != 0) {
666     assert(UseCompressedClassPointers, &quot;&quot;);
667     if (is_array) {
668       // Exclude length to copy by 8 bytes words.
669       base_off += sizeof(int);
670     } else {
671       // Include klass to copy by 8 bytes words.
672       base_off = instanceOopDesc::klass_offset_in_bytes();
673     }
674     assert(base_off % BytesPerLong == 0, &quot;expect 8 bytes alignment&quot;);
675   }
676   return base_off;
677 }
678 
679 void BarrierSetC2::clone(GraphKit* kit, Node* src_base, Node* dst_base, Node* countx, bool is_array) const {
680 #ifdef ASSERT
681   intptr_t src_offset;
682   Node* src = AddPNode::Ideal_base_and_offset(src_base, &amp;kit-&gt;gvn(), src_offset);
683   intptr_t dst_offset;
684   Node* dst = AddPNode::Ideal_base_and_offset(dst_base, &amp;kit-&gt;gvn(), dst_offset);
685   assert(src == NULL || (src_offset % BytesPerLong == 0), &quot;expect 8 bytes alignment&quot;);
686   assert(dst == NULL || (dst_offset % BytesPerLong == 0), &quot;expect 8 bytes alignment&quot;);
687 #endif
<span class="line-modified">688 </span>
<span class="line-modified">689   const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;</span>
<span class="line-modified">690 </span>
<span class="line-removed">691   ArrayCopyNode* ac = ArrayCopyNode::make(kit, false, src_base, NULL, dst_base, NULL, countx, true, false);</span>
692   if (is_array) {
693     ac-&gt;set_clone_array();
694   } else {
695     ac-&gt;set_clone_inst();
696   }
697   Node* n = kit-&gt;gvn().transform(ac);
698   if (n == ac) {

699     ac-&gt;_adr_type = TypeRawPtr::BOTTOM;
700     kit-&gt;set_predefined_output_for_runtime_call(ac, ac-&gt;in(TypeFunc::Memory), raw_adr_type);
701   } else {
702     kit-&gt;set_all_memory(n);
703   }
704 }
705 
706 Node* BarrierSetC2::obj_allocate(PhaseMacroExpand* macro, Node* ctrl, Node* mem, Node* toobig_false, Node* size_in_bytes,
707                                  Node*&amp; i_o, Node*&amp; needgc_ctrl,
708                                  Node*&amp; fast_oop_ctrl, Node*&amp; fast_oop_rawmem,
709                                  intx prefetch_lines) const {
710 
711   Node* eden_top_adr;
712   Node* eden_end_adr;
713 
714   macro-&gt;set_eden_pointers(eden_top_adr, eden_end_adr);
715 
716   // Load Eden::end.  Loop invariant and hoisted.
717   //
718   // Note: We set the control input on &quot;eden_end&quot; and &quot;old_eden_top&quot; when using
</pre>
<hr />
<pre>
824 #endif
825     Node* new_alloc_bytes = new AddLNode(alloc_bytes, alloc_size);
826     macro-&gt;transform_later(new_alloc_bytes);
827     fast_oop_rawmem = macro-&gt;make_store(fast_oop_ctrl, store_eden_top, alloc_bytes_adr,
828                                         0, new_alloc_bytes, T_LONG);
829   }
830   return fast_oop;
831 }
832 
833 #define XTOP LP64_ONLY(COMMA phase-&gt;top())
834 
835 void BarrierSetC2::clone_at_expansion(PhaseMacroExpand* phase, ArrayCopyNode* ac) const {
836   Node* ctrl = ac-&gt;in(TypeFunc::Control);
837   Node* mem = ac-&gt;in(TypeFunc::Memory);
838   Node* src = ac-&gt;in(ArrayCopyNode::Src);
839   Node* src_offset = ac-&gt;in(ArrayCopyNode::SrcPos);
840   Node* dest = ac-&gt;in(ArrayCopyNode::Dest);
841   Node* dest_offset = ac-&gt;in(ArrayCopyNode::DestPos);
842   Node* length = ac-&gt;in(ArrayCopyNode::Length);
843 
<span class="line-modified">844   assert (src_offset == NULL,  &quot;for clone offsets should be null&quot;);</span>
<span class="line-modified">845   assert (dest_offset == NULL, &quot;for clone offsets should be null&quot;);</span>
846 
847   const char* copyfunc_name = &quot;arraycopy&quot;;
<span class="line-modified">848   address     copyfunc_addr =</span>
<span class="line-removed">849           phase-&gt;basictype2arraycopy(T_LONG, NULL, NULL,</span>
<span class="line-removed">850                               true, copyfunc_name, true);</span>
851 
852   const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;
853   const TypeFunc* call_type = OptoRuntime::fast_arraycopy_Type();
854 
<span class="line-modified">855   Node* call = phase-&gt;make_leaf_call(ctrl, mem, call_type, copyfunc_addr, copyfunc_name, raw_adr_type, src, dest, length XTOP);</span>
856   phase-&gt;transform_later(call);
857 
858   phase-&gt;igvn().replace_node(ac, call);
859 }
</pre>
</td>
<td>
<hr />
<pre>
640   resolve_address(access);
641   return atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);
642 }
643 
644 Node* BarrierSetC2::atomic_xchg_at(C2AtomicParseAccess&amp; access, Node* new_val, const Type* value_type) const {
645   C2AccessFence fence(access);
646   resolve_address(access);
647   return atomic_xchg_at_resolved(access, new_val, value_type);
648 }
649 
650 Node* BarrierSetC2::atomic_add_at(C2AtomicParseAccess&amp; access, Node* new_val, const Type* value_type) const {
651   C2AccessFence fence(access);
652   resolve_address(access);
653   return atomic_add_at_resolved(access, new_val, value_type);
654 }
655 
656 int BarrierSetC2::arraycopy_payload_base_offset(bool is_array) {
657   // Exclude the header but include array length to copy by 8 bytes words.
658   // Can&#39;t use base_offset_in_bytes(bt) since basic type is unknown.
659   int base_off = is_array ? arrayOopDesc::length_offset_in_bytes() :
<span class="line-modified">660                             instanceOopDesc::base_offset_in_bytes();</span>
661   // base_off:
662   // 8  - 32-bit VM
663   // 12 - 64-bit VM, compressed klass
664   // 16 - 64-bit VM, normal klass
665   if (base_off % BytesPerLong != 0) {
666     assert(UseCompressedClassPointers, &quot;&quot;);
667     if (is_array) {
668       // Exclude length to copy by 8 bytes words.
669       base_off += sizeof(int);
670     } else {
671       // Include klass to copy by 8 bytes words.
672       base_off = instanceOopDesc::klass_offset_in_bytes();
673     }
674     assert(base_off % BytesPerLong == 0, &quot;expect 8 bytes alignment&quot;);
675   }
676   return base_off;
677 }
678 
679 void BarrierSetC2::clone(GraphKit* kit, Node* src_base, Node* dst_base, Node* countx, bool is_array) const {
680 #ifdef ASSERT
681   intptr_t src_offset;
682   Node* src = AddPNode::Ideal_base_and_offset(src_base, &amp;kit-&gt;gvn(), src_offset);
683   intptr_t dst_offset;
684   Node* dst = AddPNode::Ideal_base_and_offset(dst_base, &amp;kit-&gt;gvn(), dst_offset);
685   assert(src == NULL || (src_offset % BytesPerLong == 0), &quot;expect 8 bytes alignment&quot;);
686   assert(dst == NULL || (dst_offset % BytesPerLong == 0), &quot;expect 8 bytes alignment&quot;);
687 #endif
<span class="line-modified">688   int base_off = arraycopy_payload_base_offset(is_array);</span>
<span class="line-modified">689   Node* offset = kit-&gt;MakeConX(base_off);</span>
<span class="line-modified">690   ArrayCopyNode* ac = ArrayCopyNode::make(kit, false, src_base, offset, dst_base, offset, countx, true, false);</span>

691   if (is_array) {
692     ac-&gt;set_clone_array();
693   } else {
694     ac-&gt;set_clone_inst();
695   }
696   Node* n = kit-&gt;gvn().transform(ac);
697   if (n == ac) {
<span class="line-added">698     const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;</span>
699     ac-&gt;_adr_type = TypeRawPtr::BOTTOM;
700     kit-&gt;set_predefined_output_for_runtime_call(ac, ac-&gt;in(TypeFunc::Memory), raw_adr_type);
701   } else {
702     kit-&gt;set_all_memory(n);
703   }
704 }
705 
706 Node* BarrierSetC2::obj_allocate(PhaseMacroExpand* macro, Node* ctrl, Node* mem, Node* toobig_false, Node* size_in_bytes,
707                                  Node*&amp; i_o, Node*&amp; needgc_ctrl,
708                                  Node*&amp; fast_oop_ctrl, Node*&amp; fast_oop_rawmem,
709                                  intx prefetch_lines) const {
710 
711   Node* eden_top_adr;
712   Node* eden_end_adr;
713 
714   macro-&gt;set_eden_pointers(eden_top_adr, eden_end_adr);
715 
716   // Load Eden::end.  Loop invariant and hoisted.
717   //
718   // Note: We set the control input on &quot;eden_end&quot; and &quot;old_eden_top&quot; when using
</pre>
<hr />
<pre>
824 #endif
825     Node* new_alloc_bytes = new AddLNode(alloc_bytes, alloc_size);
826     macro-&gt;transform_later(new_alloc_bytes);
827     fast_oop_rawmem = macro-&gt;make_store(fast_oop_ctrl, store_eden_top, alloc_bytes_adr,
828                                         0, new_alloc_bytes, T_LONG);
829   }
830   return fast_oop;
831 }
832 
833 #define XTOP LP64_ONLY(COMMA phase-&gt;top())
834 
835 void BarrierSetC2::clone_at_expansion(PhaseMacroExpand* phase, ArrayCopyNode* ac) const {
836   Node* ctrl = ac-&gt;in(TypeFunc::Control);
837   Node* mem = ac-&gt;in(TypeFunc::Memory);
838   Node* src = ac-&gt;in(ArrayCopyNode::Src);
839   Node* src_offset = ac-&gt;in(ArrayCopyNode::SrcPos);
840   Node* dest = ac-&gt;in(ArrayCopyNode::Dest);
841   Node* dest_offset = ac-&gt;in(ArrayCopyNode::DestPos);
842   Node* length = ac-&gt;in(ArrayCopyNode::Length);
843 
<span class="line-modified">844   Node* payload_src = phase-&gt;basic_plus_adr(src, src_offset);</span>
<span class="line-modified">845   Node* payload_dst = phase-&gt;basic_plus_adr(dest, dest_offset);</span>
846 
847   const char* copyfunc_name = &quot;arraycopy&quot;;
<span class="line-modified">848   address     copyfunc_addr = phase-&gt;basictype2arraycopy(T_LONG, NULL, NULL, true, copyfunc_name, true);</span>


849 
850   const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;
851   const TypeFunc* call_type = OptoRuntime::fast_arraycopy_Type();
852 
<span class="line-modified">853   Node* call = phase-&gt;make_leaf_call(ctrl, mem, call_type, copyfunc_addr, copyfunc_name, raw_adr_type, payload_src, payload_dst, length XTOP);</span>
854   phase-&gt;transform_later(call);
855 
856   phase-&gt;igvn().replace_node(ac, call);
857 }
</pre>
</td>
</tr>
</table>
<center><a href="../../parallel/parallelScavengeHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="cardTableBarrierSetC2.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
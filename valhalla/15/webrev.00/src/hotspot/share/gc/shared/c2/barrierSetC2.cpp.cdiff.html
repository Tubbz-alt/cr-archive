<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shared/c2/barrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../parallel/parallelScavengeHeap.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="cardTableBarrierSetC2.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/c2/barrierSetC2.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 655,11 ***</span>
  
  int BarrierSetC2::arraycopy_payload_base_offset(bool is_array) {
    // Exclude the header but include array length to copy by 8 bytes words.
    // Can&#39;t use base_offset_in_bytes(bt) since basic type is unknown.
    int base_off = is_array ? arrayOopDesc::length_offset_in_bytes() :
<span class="line-modified">!                  instanceOopDesc::base_offset_in_bytes();</span>
    // base_off:
    // 8  - 32-bit VM
    // 12 - 64-bit VM, compressed klass
    // 16 - 64-bit VM, normal klass
    if (base_off % BytesPerLong != 0) {
<span class="line-new-header">--- 655,11 ---</span>
  
  int BarrierSetC2::arraycopy_payload_base_offset(bool is_array) {
    // Exclude the header but include array length to copy by 8 bytes words.
    // Can&#39;t use base_offset_in_bytes(bt) since basic type is unknown.
    int base_off = is_array ? arrayOopDesc::length_offset_in_bytes() :
<span class="line-modified">!                             instanceOopDesc::base_offset_in_bytes();</span>
    // base_off:
    // 8  - 32-bit VM
    // 12 - 64-bit VM, compressed klass
    // 16 - 64-bit VM, normal klass
    if (base_off % BytesPerLong != 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 683,21 ***</span>
    intptr_t dst_offset;
    Node* dst = AddPNode::Ideal_base_and_offset(dst_base, &amp;kit-&gt;gvn(), dst_offset);
    assert(src == NULL || (src_offset % BytesPerLong == 0), &quot;expect 8 bytes alignment&quot;);
    assert(dst == NULL || (dst_offset % BytesPerLong == 0), &quot;expect 8 bytes alignment&quot;);
  #endif
<span class="line-modified">! </span>
<span class="line-modified">!   const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;</span>
<span class="line-modified">! </span>
<span class="line-removed">-   ArrayCopyNode* ac = ArrayCopyNode::make(kit, false, src_base, NULL, dst_base, NULL, countx, true, false);</span>
    if (is_array) {
      ac-&gt;set_clone_array();
    } else {
      ac-&gt;set_clone_inst();
    }
    Node* n = kit-&gt;gvn().transform(ac);
    if (n == ac) {
      ac-&gt;_adr_type = TypeRawPtr::BOTTOM;
      kit-&gt;set_predefined_output_for_runtime_call(ac, ac-&gt;in(TypeFunc::Memory), raw_adr_type);
    } else {
      kit-&gt;set_all_memory(n);
    }
<span class="line-new-header">--- 683,21 ---</span>
    intptr_t dst_offset;
    Node* dst = AddPNode::Ideal_base_and_offset(dst_base, &amp;kit-&gt;gvn(), dst_offset);
    assert(src == NULL || (src_offset % BytesPerLong == 0), &quot;expect 8 bytes alignment&quot;);
    assert(dst == NULL || (dst_offset % BytesPerLong == 0), &quot;expect 8 bytes alignment&quot;);
  #endif
<span class="line-modified">!   int base_off = arraycopy_payload_base_offset(is_array);</span>
<span class="line-modified">!   Node* offset = kit-&gt;MakeConX(base_off);</span>
<span class="line-modified">!   ArrayCopyNode* ac = ArrayCopyNode::make(kit, false, src_base, offset, dst_base, offset, countx, true, false);</span>
    if (is_array) {
      ac-&gt;set_clone_array();
    } else {
      ac-&gt;set_clone_inst();
    }
    Node* n = kit-&gt;gvn().transform(ac);
    if (n == ac) {
<span class="line-added">+     const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;</span>
      ac-&gt;_adr_type = TypeRawPtr::BOTTOM;
      kit-&gt;set_predefined_output_for_runtime_call(ac, ac-&gt;in(TypeFunc::Memory), raw_adr_type);
    } else {
      kit-&gt;set_all_memory(n);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 839,21 ***</span>
    Node* src_offset = ac-&gt;in(ArrayCopyNode::SrcPos);
    Node* dest = ac-&gt;in(ArrayCopyNode::Dest);
    Node* dest_offset = ac-&gt;in(ArrayCopyNode::DestPos);
    Node* length = ac-&gt;in(ArrayCopyNode::Length);
  
<span class="line-modified">!   assert (src_offset == NULL,  &quot;for clone offsets should be null&quot;);</span>
<span class="line-modified">!   assert (dest_offset == NULL, &quot;for clone offsets should be null&quot;);</span>
  
    const char* copyfunc_name = &quot;arraycopy&quot;;
<span class="line-modified">!   address     copyfunc_addr =</span>
<span class="line-removed">-           phase-&gt;basictype2arraycopy(T_LONG, NULL, NULL,</span>
<span class="line-removed">-                               true, copyfunc_name, true);</span>
  
    const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;
    const TypeFunc* call_type = OptoRuntime::fast_arraycopy_Type();
  
<span class="line-modified">!   Node* call = phase-&gt;make_leaf_call(ctrl, mem, call_type, copyfunc_addr, copyfunc_name, raw_adr_type, src, dest, length XTOP);</span>
    phase-&gt;transform_later(call);
  
    phase-&gt;igvn().replace_node(ac, call);
  }
<span class="line-new-header">--- 839,19 ---</span>
    Node* src_offset = ac-&gt;in(ArrayCopyNode::SrcPos);
    Node* dest = ac-&gt;in(ArrayCopyNode::Dest);
    Node* dest_offset = ac-&gt;in(ArrayCopyNode::DestPos);
    Node* length = ac-&gt;in(ArrayCopyNode::Length);
  
<span class="line-modified">!   Node* payload_src = phase-&gt;basic_plus_adr(src, src_offset);</span>
<span class="line-modified">!   Node* payload_dst = phase-&gt;basic_plus_adr(dest, dest_offset);</span>
  
    const char* copyfunc_name = &quot;arraycopy&quot;;
<span class="line-modified">!   address     copyfunc_addr = phase-&gt;basictype2arraycopy(T_LONG, NULL, NULL, true, copyfunc_name, true);</span>
  
    const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;
    const TypeFunc* call_type = OptoRuntime::fast_arraycopy_Type();
  
<span class="line-modified">!   Node* call = phase-&gt;make_leaf_call(ctrl, mem, call_type, copyfunc_addr, copyfunc_name, raw_adr_type, payload_src, payload_dst, length XTOP);</span>
    phase-&gt;transform_later(call);
  
    phase-&gt;igvn().replace_node(ac, call);
  }
</pre>
<center><a href="../../parallel/parallelScavengeHeap.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="cardTableBarrierSetC2.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classListParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classListParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
328       // Backwards compatibility -- older classlists do not know about
329       // java.lang.IdentityObject.
330       expected_num_interfaces--;
331     }
332 
333     if (specified_num_interfaces != expected_num_interfaces) {
334       print_specified_interfaces();
335       print_actual_interfaces(k);
336       error(&quot;The number of interfaces (%d) specified in class list does not match the class file (%d)&quot;,
337             specified_num_interfaces, expected_num_interfaces);
338     }
339 
340     bool added = SystemDictionaryShared::add_unregistered_class(k, CHECK_NULL);
341     if (!added) {
342       // We allow only a single unregistered class for each unique name.
343       error(&quot;Duplicated class %s&quot;, _class_name);
344     }
345 
346     // This tells JVM_FindLoadedClass to not find this class.
347     k-&gt;set_shared_classpath_index(UNREGISTERED_INDEX);
<span class="line-modified">348     k-&gt;clear_class_loader_type();</span>
349   }
350 
351   return k;
352 }
353 
354 Klass* ClassListParser::load_current_class(TRAPS) {
355   TempNewSymbol class_name_symbol = SymbolTable::new_symbol(_class_name);
356 
357   Klass* klass = NULL;
358   if (!is_loading_from_source()) {
359     // Load classes for the boot/platform/app loaders only.
360     if (is_super_specified()) {
361       error(&quot;If source location is not specified, super class must not be specified&quot;);
362     }
363     if (are_interfaces_specified()) {
364       error(&quot;If source location is not specified, interface(s) must not be specified&quot;);
365     }
366 
367     bool non_array = !Signature::is_array(class_name_symbol);
368 
369     JavaValue result(T_OBJECT);
370     if (non_array) {
371       // At this point, we are executing in the context of the boot loader. We
372       // cannot call Class.forName because that is context dependent and
373       // would load only classes for the boot loader.
374       //
375       // Instead, let&#39;s call java_system_loader().loadClass() directly, which will
376       // delegate to the correct loader (boot, platform or app) depending on
377       // the class name.
378 
<span class="line-modified">379       Handle s = java_lang_String::create_from_symbol(class_name_symbol, CHECK_0);</span>
380       // ClassLoader.loadClass() wants external class name format, i.e., convert &#39;/&#39; chars to &#39;.&#39;
<span class="line-modified">381       Handle ext_class_name = java_lang_String::externalize_classname(s, CHECK_0);</span>
382       Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
383 
384       JavaCalls::call_virtual(&amp;result,
385                               loader, //SystemDictionary::java_system_loader(),
386                               SystemDictionary::ClassLoader_klass(),
387                               vmSymbols::loadClass_name(),
388                               vmSymbols::string_class_signature(),
389                               ext_class_name,
390                               THREAD); // &lt;-- failure is handled below
391     } else {
392       // array classes are not supported in class list.
393       THROW_NULL(vmSymbols::java_lang_ClassNotFoundException());
394     }
395     assert(result.get_type() == T_OBJECT, &quot;just checking&quot;);
396     oop obj = (oop) result.get_jobject();
397     if (!HAS_PENDING_EXCEPTION &amp;&amp; (obj != NULL)) {
398       klass = java_lang_Class::as_Klass(obj);
399     } else { // load classes in bootclasspath/a
400       if (HAS_PENDING_EXCEPTION) {
401         CLEAR_PENDING_EXCEPTION;
</pre>
</td>
<td>
<hr />
<pre>
328       // Backwards compatibility -- older classlists do not know about
329       // java.lang.IdentityObject.
330       expected_num_interfaces--;
331     }
332 
333     if (specified_num_interfaces != expected_num_interfaces) {
334       print_specified_interfaces();
335       print_actual_interfaces(k);
336       error(&quot;The number of interfaces (%d) specified in class list does not match the class file (%d)&quot;,
337             specified_num_interfaces, expected_num_interfaces);
338     }
339 
340     bool added = SystemDictionaryShared::add_unregistered_class(k, CHECK_NULL);
341     if (!added) {
342       // We allow only a single unregistered class for each unique name.
343       error(&quot;Duplicated class %s&quot;, _class_name);
344     }
345 
346     // This tells JVM_FindLoadedClass to not find this class.
347     k-&gt;set_shared_classpath_index(UNREGISTERED_INDEX);
<span class="line-modified">348     k-&gt;clear_shared_class_loader_type();</span>
349   }
350 
351   return k;
352 }
353 
354 Klass* ClassListParser::load_current_class(TRAPS) {
355   TempNewSymbol class_name_symbol = SymbolTable::new_symbol(_class_name);
356 
357   Klass* klass = NULL;
358   if (!is_loading_from_source()) {
359     // Load classes for the boot/platform/app loaders only.
360     if (is_super_specified()) {
361       error(&quot;If source location is not specified, super class must not be specified&quot;);
362     }
363     if (are_interfaces_specified()) {
364       error(&quot;If source location is not specified, interface(s) must not be specified&quot;);
365     }
366 
367     bool non_array = !Signature::is_array(class_name_symbol);
368 
369     JavaValue result(T_OBJECT);
370     if (non_array) {
371       // At this point, we are executing in the context of the boot loader. We
372       // cannot call Class.forName because that is context dependent and
373       // would load only classes for the boot loader.
374       //
375       // Instead, let&#39;s call java_system_loader().loadClass() directly, which will
376       // delegate to the correct loader (boot, platform or app) depending on
377       // the class name.
378 
<span class="line-modified">379       Handle s = java_lang_String::create_from_symbol(class_name_symbol, CHECK_NULL);</span>
380       // ClassLoader.loadClass() wants external class name format, i.e., convert &#39;/&#39; chars to &#39;.&#39;
<span class="line-modified">381       Handle ext_class_name = java_lang_String::externalize_classname(s, CHECK_NULL);</span>
382       Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
383 
384       JavaCalls::call_virtual(&amp;result,
385                               loader, //SystemDictionary::java_system_loader(),
386                               SystemDictionary::ClassLoader_klass(),
387                               vmSymbols::loadClass_name(),
388                               vmSymbols::string_class_signature(),
389                               ext_class_name,
390                               THREAD); // &lt;-- failure is handled below
391     } else {
392       // array classes are not supported in class list.
393       THROW_NULL(vmSymbols::java_lang_ClassNotFoundException());
394     }
395     assert(result.get_type() == T_OBJECT, &quot;just checking&quot;);
396     oop obj = (oop) result.get_jobject();
397     if (!HAS_PENDING_EXCEPTION &amp;&amp; (obj != NULL)) {
398       klass = java_lang_Class::as_Klass(obj);
399     } else { // load classes in bootclasspath/a
400       if (HAS_PENDING_EXCEPTION) {
401         CLEAR_PENDING_EXCEPTION;
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
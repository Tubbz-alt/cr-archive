<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="packageEntry.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -144,11 +144,11 @@</span>
  
    _java_platform_loader = (oop)result.get_jobject();
  }
  
  ClassLoaderData* SystemDictionary::register_loader(Handle class_loader) {
<span class="udiff-line-modified-removed">-   if (class_loader() == NULL) return ClassLoaderData::the_null_class_loader_data();</span>
<span class="udiff-line-modified-added">+   if (class_loader.is_null()) return ClassLoaderData::the_null_class_loader_data();</span>
    return ClassLoaderDataGraph::find_or_create(class_loader);
  }
  
  // ----------------------------------------------------------------------------
  // Parallel class loading check
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1014,12 +1014,11 @@</span>
      int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
      BasicType t = ss.type();
      if (t != T_OBJECT &amp;&amp; t != T_VALUETYPE) {
        k = Universe::typeArrayKlassObj(t);
      } else {
<span class="udiff-line-modified-removed">-       Symbol* obj_class = ss.as_symbol();</span>
<span class="udiff-line-removed">-       k = SystemDictionary::find(obj_class, class_loader, protection_domain, THREAD);</span>
<span class="udiff-line-modified-added">+       k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);</span>
      }
      if (k != NULL) {
        k = k-&gt;array_klass_or_null(ArrayStorageProperties::for_signature(class_name), ndims);
      }
    } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1243,27 +1242,25 @@</span>
             &quot;Loading non-bootstrap classes before the module system is initialized&quot;);
      assert(class_loader.is_null(), &quot;sanity&quot;);
      return true;
    }
    // Get the pkg_entry from the classloader
<span class="udiff-line-removed">-   TempNewSymbol pkg_name = NULL;</span>
    PackageEntry* pkg_entry = NULL;
    ModuleEntry* mod_entry = NULL;
<span class="udiff-line-modified-removed">-   pkg_name = InstanceKlass::package_from_name(class_name, CHECK_false);</span>
<span class="udiff-line-modified-added">+   TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);</span>
    if (pkg_name != NULL) {
      if (loader_data != NULL) {
        pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
<span class="udiff-line-added">+       if (pkg_entry != NULL) {</span>
<span class="udiff-line-added">+         mod_entry = pkg_entry-&gt;module();</span>
<span class="udiff-line-added">+         // If the archived class is from a module that has been patched at runtime,</span>
<span class="udiff-line-added">+         // the class cannot be loaded from the archive.</span>
<span class="udiff-line-added">+         if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_patched()) {</span>
<span class="udiff-line-added">+           return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
      }
<span class="udiff-line-removed">-     if (pkg_entry != NULL) {</span>
<span class="udiff-line-removed">-       mod_entry = pkg_entry-&gt;module();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // If the archived class is from a module that has been patched at runtime,</span>
<span class="udiff-line-removed">-   // the class cannot be loaded from the archive.</span>
<span class="udiff-line-removed">-   if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_patched()) {</span>
<span class="udiff-line-removed">-     return false;</span>
    }
  
    if (class_loader.is_null()) {
      assert(ent != NULL, &quot;Shared class for NULL classloader must have valid SharedClassPathEntry&quot;);
      // The NULL classloader can load archived class originated from the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1301,60 +1298,71 @@</span>
                ik, class_loader, pkg_name, pkg_entry, mod_entry, CHECK_(false));
      return res;
    }
  }
  
<span class="udiff-line-modified-removed">- InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,</span>
<span class="udiff-line-modified-removed">-                                                    Handle class_loader,</span>
<span class="udiff-line-modified-removed">-                                                    Handle protection_domain,</span>
<span class="udiff-line-modified-removed">-                                                    const ClassFileStream *cfs,</span>
<span class="udiff-line-removed">-                                                    TRAPS) {</span>
<span class="udiff-line-removed">-   assert(ik != NULL, &quot;sanity&quot;);</span>
<span class="udiff-line-removed">-   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);</span>
<span class="udiff-line-removed">-   Symbol* class_name = ik-&gt;name();</span>
<span class="udiff-line-modified-added">+ bool SystemDictionary::check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super_type,</span>
<span class="udiff-line-modified-added">+                                                      Handle class_loader,  Handle protection_domain,</span>
<span class="udiff-line-modified-added">+                                                      bool is_superclass, TRAPS) {</span>
<span class="udiff-line-modified-added">+   assert(super_type-&gt;is_shared(), &quot;must be&quot;);</span>
  
<span class="udiff-line-modified-removed">-   bool visible = is_shared_class_visible(</span>
<span class="udiff-line-modified-removed">-                           class_name, ik, class_loader, CHECK_NULL);</span>
<span class="udiff-line-modified-removed">-   if (!visible) {</span>
<span class="udiff-line-modified-removed">-     return NULL;</span>
<span class="udiff-line-modified-added">+   Klass *found = resolve_super_or_fail(child-&gt;name(), super_type-&gt;name(),</span>
<span class="udiff-line-modified-added">+                                        class_loader, protection_domain, is_superclass, CHECK_0);</span>
<span class="udiff-line-modified-added">+   if (found == super_type) {</span>
<span class="udiff-line-modified-added">+     return true;</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     // The dynamically resolved super type is not the same as the one we used during dump time,</span>
<span class="udiff-line-added">+     // so we cannot use the child class.</span>
<span class="udiff-line-added">+     return false;</span>
    }
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   // Resolve the superclass and interfaces. They must be the same</span>
<span class="udiff-line-modified-added">+ bool SystemDictionary::check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,</span>
<span class="udiff-line-added">+                                                       Handle protection_domain, TRAPS) {</span>
<span class="udiff-line-added">+   // Check the superclass and interfaces. They must be the same</span>
    // as in dump time, because the layout of &lt;ik&gt; depends on
    // the specific layout of ik-&gt;super() and ik-&gt;local_interfaces().
    //
    // If unexpected superclass or interfaces are found, we cannot
    // load &lt;ik&gt; from the shared archive.
  
<span class="udiff-line-modified-removed">-   if (ik-&gt;super() != NULL) {</span>
<span class="udiff-line-modified-removed">-     Symbol*  cn = ik-&gt;super()-&gt;name();</span>
<span class="udiff-line-modified-removed">-     Klass *s = resolve_super_or_fail(class_name, cn,</span>
<span class="udiff-line-modified-removed">-                                      class_loader, protection_domain, true, CHECK_NULL);</span>
<span class="udiff-line-removed">-     if (s != ik-&gt;super()) {</span>
<span class="udiff-line-removed">-       // The dynamically resolved super class is not the same as the one we used during dump time,</span>
<span class="udiff-line-removed">-       // so we cannot use ik.</span>
<span class="udiff-line-removed">-       return NULL;</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       assert(s-&gt;is_shared(), &quot;must be&quot;);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   if (ik-&gt;super() != NULL &amp;&amp;</span>
<span class="udiff-line-modified-added">+       !check_shared_class_super_type(ik, InstanceKlass::cast(ik-&gt;super()),</span>
<span class="udiff-line-modified-added">+                                      class_loader, protection_domain, true, THREAD)) {</span>
<span class="udiff-line-modified-added">+     return false;</span>
    }
  
    Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
    int num_interfaces = interfaces-&gt;length();
    for (int index = 0; index &lt; num_interfaces; index++) {
<span class="udiff-line-modified-removed">-     InstanceKlass* k = interfaces-&gt;at(index);</span>
<span class="udiff-line-modified-removed">-     Symbol* name  = k-&gt;name();</span>
<span class="udiff-line-removed">-     Klass* i = resolve_super_or_fail(class_name, name, class_loader, protection_domain, false, CHECK_NULL);</span>
<span class="udiff-line-removed">-     if (k != i) {</span>
<span class="udiff-line-removed">-       // The dynamically resolved interface class is not the same as the one we used during dump time,</span>
<span class="udiff-line-removed">-       // so we cannot use ik.</span>
<span class="udiff-line-removed">-       return NULL;</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       assert(i-&gt;is_shared(), &quot;must be&quot;);</span>
<span class="udiff-line-modified-added">+     if (!check_shared_class_super_type(ik, interfaces-&gt;at(index), class_loader, protection_domain, false, THREAD)) {</span>
<span class="udiff-line-modified-added">+       return false;</span>
      }
    }
  
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,</span>
<span class="udiff-line-added">+                                                    Handle class_loader,</span>
<span class="udiff-line-added">+                                                    Handle protection_domain,</span>
<span class="udiff-line-added">+                                                    const ClassFileStream *cfs,</span>
<span class="udiff-line-added">+                                                    TRAPS) {</span>
<span class="udiff-line-added">+   assert(ik != NULL, &quot;sanity&quot;);</span>
<span class="udiff-line-added">+   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);</span>
<span class="udiff-line-added">+   Symbol* class_name = ik-&gt;name();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool visible = is_shared_class_visible(</span>
<span class="udiff-line-added">+                           class_name, ik, class_loader, CHECK_NULL);</span>
<span class="udiff-line-added">+   if (!visible) {</span>
<span class="udiff-line-added">+     return NULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {</span>
<span class="udiff-line-added">+     return NULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    InstanceKlass* new_ik = KlassFactory::check_shared_class_file_load_hook(
        ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
    if (new_ik != NULL) {
      // The class is changed by CFLH. Return the new class. The shared class is
      // not used.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1381,18 +1389,22 @@</span>
      // prohibited package check assumes all classes loaded from archive call
      // restore_unshareable_info which calls ik-&gt;set_package()
      ik-&gt;restore_unshareable_info(loader_data, protection_domain, CHECK_NULL);
    }
  
<span class="udiff-line-added">+   load_shared_class_misc(ik, loader_data, CHECK_NULL);</span>
<span class="udiff-line-added">+   return ik;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {</span>
    ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
  
    // For boot loader, ensure that GetSystemPackage knows that a class in this
    // package was loaded.
<span class="udiff-line-modified-removed">-   if (class_loader.is_null()) {</span>
<span class="udiff-line-modified-added">+   if (loader_data-&gt;is_the_null_class_loader_data()) {</span>
      int path_index = ik-&gt;shared_classpath_index();
<span class="udiff-line-modified-removed">-     ResourceMark rm(THREAD);</span>
<span class="udiff-line-removed">-     ClassLoader::add_package(ik-&gt;name()-&gt;as_C_string(), path_index, THREAD);</span>
<span class="udiff-line-modified-added">+     ClassLoader::add_package(ik, path_index, THREAD);</span>
    }
  
    if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
      // Only dump the classes that can be stored into CDS archive
      if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1417,12 +1429,41 @@</span>
          ResourceMark rm(THREAD);
          log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT, ik-&gt;external_name(), aot_fp, cds_fp);
        }
      }
    }
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SystemDictionary::quick_resolve(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) {</span>
<span class="udiff-line-added">+   assert(!Universe::is_fully_initialized(), &quot;We can make short cuts only during VM initialization&quot;);</span>
<span class="udiff-line-added">+   assert(klass-&gt;is_shared(), &quot;Must be shared class&quot;);</span>
<span class="udiff-line-added">+   if (klass-&gt;class_loader_data() != NULL) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // add super and interfaces first</span>
<span class="udiff-line-added">+   Klass* super = klass-&gt;super();</span>
<span class="udiff-line-added">+   if (super != NULL &amp;&amp; super-&gt;class_loader_data() == NULL) {</span>
<span class="udiff-line-added">+     assert(super-&gt;is_instance_klass(), &quot;Super should be instance klass&quot;);</span>
<span class="udiff-line-added">+     quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Array&lt;InstanceKlass*&gt;* ifs = klass-&gt;local_interfaces();</span>
<span class="udiff-line-added">+   for (int i = 0; i &lt; ifs-&gt;length(); i++) {</span>
<span class="udiff-line-added">+     InstanceKlass* ik = ifs-&gt;at(i);</span>
<span class="udiff-line-added">+     if (ik-&gt;class_loader_data()  == NULL) {</span>
<span class="udiff-line-added">+       quick_resolve(ik, loader_data, domain, CHECK);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-   return ik;</span>
<span class="udiff-line-modified-added">+   klass-&gt;restore_unshareable_info(loader_data, domain, THREAD);</span>
<span class="udiff-line-added">+   load_shared_class_misc(klass, loader_data, CHECK);</span>
<span class="udiff-line-added">+   Dictionary* dictionary = loader_data-&gt;dictionary();</span>
<span class="udiff-line-added">+   unsigned int hash = dictionary-&gt;compute_hash(klass-&gt;name());</span>
<span class="udiff-line-added">+   dictionary-&gt;add_klass(hash, klass-&gt;name(), klass);</span>
<span class="udiff-line-added">+   add_to_hierarchy(klass, CHECK);</span>
<span class="udiff-line-added">+   assert(klass-&gt;is_loaded(), &quot;Must be in at least loaded state&quot;);</span>
  }
  #endif // INCLUDE_CDS
  
  InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1431,11 +1472,11 @@</span>
      PackageEntry* pkg_entry = NULL;
      bool search_only_bootloader_append = false;
      ClassLoaderData *loader_data = class_loader_data(class_loader);
  
      // Find the package in the boot loader&#39;s package entry table.
<span class="udiff-line-modified-removed">-     TempNewSymbol pkg_name = InstanceKlass::package_from_name(class_name, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);</span>
      if (pkg_name != NULL) {
        pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
      }
  
      // Prior to attempting to load the class, enforce the boot loader&#39;s
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1830,11 +1871,13 @@</span>
  // is held, to ensure that the compiler is not using the class hierachy, and that deoptimization will kick in
  // before a new class is used.
  
  void SystemDictionary::add_to_hierarchy(InstanceKlass* k, TRAPS) {
    assert(k != NULL, &quot;just checking&quot;);
<span class="udiff-line-modified-removed">-   assert_locked_or_safepoint(Compile_lock);</span>
<span class="udiff-line-modified-added">+   if (Universe::is_fully_initialized()) {</span>
<span class="udiff-line-added">+     assert_locked_or_safepoint(Compile_lock);</span>
<span class="udiff-line-added">+   }</span>
  
    k-&gt;set_init_state(InstanceKlass::loaded);
    // make sure init_state store is already done.
    // The compiler reads the hierarchy outside of the Compile_lock.
    // Access ordering is used to add to hierarchy.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1843,11 +1886,13 @@</span>
    k-&gt;append_to_sibling_list();                    // add to superklass/sibling list
    k-&gt;process_interfaces(THREAD);                  // handle all &quot;implements&quot; declarations
  
    // Now flush all code that depended on old class hierarchy.
    // Note: must be done *after* linking k into the hierarchy (was bug 12/9/97)
<span class="udiff-line-modified-removed">-   CodeCache::flush_dependents_on(k);</span>
<span class="udiff-line-modified-added">+   if (Universe::is_fully_initialized()) {</span>
<span class="udiff-line-added">+     CodeCache::flush_dependents_on(k);</span>
<span class="udiff-line-added">+   }</span>
  }
  
  // ----------------------------------------------------------------------------
  // GC support
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1962,12 +2007,23 @@</span>
    assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
    int sid = wk_init_info[id - FIRST_WKID];
    Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
    InstanceKlass** klassp = &amp;_well_known_klasses[id];
  
<span class="udiff-line-modified-removed">-   if ((*klassp) == NULL) {</span>
<span class="udiff-line-modified-removed">-     Klass* k = resolve_or_fail(symbol, true, CHECK_0);</span>
<span class="udiff-line-modified-added">+ #if INCLUDE_CDS</span>
<span class="udiff-line-modified-added">+   if (UseSharedSpaces &amp;&amp; !JvmtiExport::should_post_class_prepare()) {</span>
<span class="udiff-line-added">+     InstanceKlass* k = *klassp;</span>
<span class="udiff-line-added">+     assert(k-&gt;is_shared_boot_class(), &quot;must be&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();</span>
<span class="udiff-line-added">+     quick_resolve(k, loader_data, Handle(), CHECK_false);</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif // INCLUDE_CDS</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!is_wk_klass_loaded(*klassp)) {</span>
<span class="udiff-line-added">+     Klass* k = resolve_or_fail(symbol, true, CHECK_false);</span>
      (*klassp) = InstanceKlass::cast(k);
    }
    return ((*klassp) != NULL);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1981,11 +2037,11 @@</span>
    // move the starting value forward to the limit:
    start_id = limit_id;
  }
  
  void SystemDictionary::resolve_well_known_classes(TRAPS) {
<span class="udiff-line-modified-removed">-   assert(WK_KLASS(Object_klass) == NULL, &quot;well-known classes should only be initialized once&quot;);</span>
<span class="udiff-line-modified-added">+   assert(!Object_klass_loaded(), &quot;well-known classes should only be initialized once&quot;);</span>
  
    // Create the ModuleEntry for java.base.  This call needs to be done here,
    // after vmSymbols::initialize() is called but before any classes are pre-loaded.
    ClassLoader::classLoader_init2(CHECK);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2029,14 +2085,10 @@</span>
    // can be used after this point.
    java_lang_String::compute_offsets();
    java_lang_Class::compute_offsets();
  
    // Fixup mirrors for classes loaded before java.lang.Class.
<span class="udiff-line-removed">-   // These calls iterate over the objects currently in the perm gen</span>
<span class="udiff-line-removed">-   // so calling them at this point is matters (not before when there</span>
<span class="udiff-line-removed">-   // are fewer objects and not later after there are more objects</span>
<span class="udiff-line-removed">-   // in the perm gen.</span>
    Universe::initialize_basic_type_mirrors(CHECK);
    Universe::fixup_mirrors(CHECK);
  
    // do a bunch more:
    resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Reference_klass), scan, CHECK);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2070,12 +2122,12 @@</span>
    //_box_klasses[T_OBJECT]  = WK_KLASS(object_klass);
    //_box_klasses[T_ARRAY]   = WK_KLASS(object_klass);
  
  #ifdef ASSERT
    if (UseSharedSpaces) {
<span class="udiff-line-modified-removed">-     assert(JvmtiExport::is_early_phase(),</span>
<span class="udiff-line-modified-removed">-            &quot;All well known classes must be resolved in JVMTI early phase&quot;);</span>
<span class="udiff-line-modified-added">+     JVMTI_ONLY(assert(JvmtiExport::is_early_phase(),</span>
<span class="udiff-line-modified-added">+                       &quot;All well known classes must be resolved in JVMTI early phase&quot;));</span>
      for (int i = FIRST_WKID; i &lt; last; i++) {
        InstanceKlass* k = _well_known_klasses[i];
        assert(k-&gt;is_shared(), &quot;must not be replaced by JVMTI class file load hook&quot;);
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2527,72 +2579,48 @@</span>
    return klass-&gt;is_public() &amp;&amp;
           (InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::Object_klass()) ||       // java.lang
            InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::MethodHandle_klass()));  // java.lang.invoke
  }
  
<span class="udiff-line-modified-removed">- // Find or construct the Java mirror (java.lang.Class instance) for a</span>
<span class="udiff-line-modified-removed">- // for the given field type signature, as interpreted relative to the</span>
<span class="udiff-line-modified-added">+ // Find or construct the Java mirror (java.lang.Class instance) for</span>
<span class="udiff-line-modified-added">+ // the given field type signature, as interpreted relative to the</span>
  // given class loader.  Handles primitives, void, references, arrays,
  // and all other reflectable types, except method types.
  // N.B.  Code in reflection should use this entry point.
  Handle SystemDictionary::find_java_mirror_for_type(Symbol* signature,
                                                     Klass* accessing_klass,
                                                     Handle class_loader,
                                                     Handle protection_domain,
                                                     SignatureStream::FailureMode failure_mode,
                                                     TRAPS) {
<span class="udiff-line-removed">-   Handle empty;</span>
<span class="udiff-line-removed">- </span>
    assert(accessing_klass == NULL || (class_loader.is_null() &amp;&amp; protection_domain.is_null()),
           &quot;one or the other, or perhaps neither&quot;);
  
<span class="udiff-line-removed">-   SignatureStream ss(signature, false);</span>
<span class="udiff-line-removed">- </span>
    // What we have here must be a valid field descriptor,
    // and all valid field descriptors are supported.
    // Produce the same java.lang.Class that reflection reports.
<span class="udiff-line-modified-removed">-   if (ss.is_primitive() || (ss.type() == T_VOID)) {</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // It&#39;s a primitive.  (Void has a primitive mirror too.)</span>
<span class="udiff-line-modified-removed">-     return Handle(THREAD, java_lang_Class::primitive_mirror(ss.type()));</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   } else if (ss.is_reference()) {</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // It&#39;s a reference type.</span>
<span class="udiff-line-modified-removed">-     if (accessing_klass != NULL) {</span>
<span class="udiff-line-modified-removed">-       class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());</span>
<span class="udiff-line-removed">-       protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     Klass* constant_type_klass;</span>
<span class="udiff-line-removed">-     if (failure_mode == SignatureStream::ReturnNull) {</span>
<span class="udiff-line-removed">-       constant_type_klass = resolve_or_null(signature, class_loader, protection_domain,</span>
<span class="udiff-line-removed">-                                             CHECK_(empty));</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       bool throw_error = (failure_mode == SignatureStream::NCDFError);</span>
<span class="udiff-line-removed">-       constant_type_klass = resolve_or_fail(signature, class_loader, protection_domain,</span>
<span class="udiff-line-removed">-                                             throw_error, CHECK_(empty));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     if (constant_type_klass == NULL) {</span>
<span class="udiff-line-removed">-       return Handle();  // report failure this way</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     Handle mirror(THREAD, constant_type_klass-&gt;java_mirror());</span>
<span class="udiff-line-modified-added">+   if (accessing_klass != NULL) {</span>
<span class="udiff-line-modified-added">+     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());</span>
<span class="udiff-line-modified-added">+     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   ResolvingSignatureStream ss(signature, class_loader, protection_domain, false);</span>
<span class="udiff-line-modified-added">+   oop mirror_oop = ss.as_java_mirror(failure_mode, CHECK_NH);</span>
<span class="udiff-line-modified-added">+   if (mirror_oop == NULL) {</span>
<span class="udiff-line-modified-added">+     return Handle();  // report failure this way</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   Handle mirror(THREAD, mirror_oop);</span>
  
<span class="udiff-line-added">+   if (accessing_klass != NULL) {</span>
      // Check accessibility, emulating ConstantPool::verify_constant_pool_resolve.
<span class="udiff-line-modified-removed">-     if (accessing_klass != NULL) {</span>
<span class="udiff-line-modified-removed">-       Klass* sel_klass = constant_type_klass;</span>
<span class="udiff-line-modified-added">+     Klass* sel_klass = java_lang_Class::as_Klass(mirror());</span>
<span class="udiff-line-modified-added">+     if (sel_klass != NULL) {</span>
        bool fold_type_to_class = true;
        LinkResolver::check_klass_accessability(accessing_klass, sel_klass,
<span class="udiff-line-modified-removed">-                                               fold_type_to_class, CHECK_(empty));</span>
<span class="udiff-line-modified-added">+                                               fold_type_to_class, CHECK_NH);</span>
      }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     return mirror;</span>
<span class="udiff-line-removed">- </span>
    }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-   // Fall through to an error.</span>
<span class="udiff-line-removed">-   assert(false, &quot;unsupported mirror syntax&quot;);</span>
<span class="udiff-line-removed">-   THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;unsupported mirror syntax&quot;, empty);</span>
<span class="udiff-line-modified-added">+   return mirror;</span>
  }
  
  
  // Ask Java code to find or construct a java.lang.invoke.MethodType for the given
  // signature, as interpreted relative to the given class loader.
</pre>
<center><a href="packageEntry.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionaryShared.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
213   do_klass(Character_klass,                             java_lang_Character                                   ) \
214   do_klass(Float_klass,                                 java_lang_Float                                       ) \
215   do_klass(Double_klass,                                java_lang_Double                                      ) \
216   do_klass(Byte_klass,                                  java_lang_Byte                                        ) \
217   do_klass(Short_klass,                                 java_lang_Short                                       ) \
218   do_klass(Integer_klass,                               java_lang_Integer                                     ) \
219   do_klass(Long_klass,                                  java_lang_Long                                        ) \
220                                                                                                                 \
221   /* force inline of iterators */                                                                               \
222   do_klass(Iterator_klass,                              java_util_Iterator                                    ) \
223                                                                                                                 \
224   do_klass(jdk_internal_vm_jni_SubElementSelector_klass, jdk_internal_vm_jni_SubElementSelector               ) \
225   /* support for records */                                                                                     \
226   do_klass(RecordComponent_klass,                       java_lang_reflect_RecordComponent                     ) \
227                                                                                                                 \
228   /*end*/
229 
230 class SystemDictionary : AllStatic {
231   friend class BootstrapInfo;
232   friend class VMStructs;
<span class="line-removed">233   friend class SystemDictionaryHandles;</span>
234 
235  public:
236   enum WKID {
237     NO_WKID = 0,
238 
239     #define WK_KLASS_ENUM(name, symbol) WK_KLASS_ENUM_NAME(name), WK_KLASS_ENUM_NAME(symbol) = WK_KLASS_ENUM_NAME(name),
240     WK_KLASSES_DO(WK_KLASS_ENUM)
241     #undef WK_KLASS_ENUM
242 
243     WKID_LIMIT,
244 
245     FIRST_WKID = NO_WKID + 1
246   };
247 
248   // Returns a class with a given class name and class loader.  Loads the
249   // class if needed. If not found a NoClassDefFoundError or a
250   // ClassNotFoundException is thrown, depending on the value on the
251   // throw_error flag.  For most uses the throw_error argument should be set
252   // to true.
253 
</pre>
<hr />
<pre>
381   static void verify();
382 
383   // Initialization
384   static void initialize(TRAPS);
385 
386   // Checked fast access to the well-known classes -- so that you don&#39;t try to use them
387   // before they are resolved.
388   static InstanceKlass* check_klass(InstanceKlass* k) {
389     assert(k != NULL, &quot;klass not loaded&quot;);
390     return k;
391   }
392 
393   static bool resolve_wk_klass(WKID id, TRAPS);
394   static InstanceKlass* check_klass_ValhallaClasses(InstanceKlass* k) { return k; }
395   static void resolve_wk_klasses_until(WKID limit_id, WKID &amp;start_id, TRAPS);
396   static void resolve_wk_klasses_through(WKID end_id, WKID &amp;start_id, TRAPS) {
397     int limit = (int)end_id + 1;
398     resolve_wk_klasses_until((WKID) limit, start_id, THREAD);
399   }
400 public:


401   #define WK_KLASS_DECLARE(name, symbol) \
402     static InstanceKlass* name() { return check_klass(_well_known_klasses[WK_KLASS_ENUM_NAME(name)]); } \
403     static InstanceKlass** name##_addr() {                                                              \
404       return &amp;_well_known_klasses[SystemDictionary::WK_KLASS_ENUM_NAME(name)];                          \
405     }                                                                                                   \
406     static bool name##_is_loaded() {                                                                    \
<span class="line-modified">407       return _well_known_klasses[SystemDictionary::WK_KLASS_ENUM_NAME(name)] != NULL;                   \</span>
408     }
409   WK_KLASSES_DO(WK_KLASS_DECLARE);
410   #undef WK_KLASS_DECLARE
411 
412   static InstanceKlass* well_known_klass(WKID id) {
413     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
414     return _well_known_klasses[id];
415   }
416 
417   static InstanceKlass** well_known_klass_addr(WKID id) {
418     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
419     return &amp;_well_known_klasses[id];
420   }
421   static void well_known_klasses_do(MetaspaceClosure* it);
422 
<span class="line-removed">423   // Local definition for direct access to the private array:</span>
<span class="line-removed">424   #define WK_KLASS(name) _well_known_klasses[SystemDictionary::WK_KLASS_ENUM_NAME(name)]</span>
<span class="line-removed">425 </span>
426   static InstanceKlass* box_klass(BasicType t) {
427     assert((uint)t &lt; T_VOID+1, &quot;range check&quot;);
428     return check_klass(_box_klasses[t]);
429   }
430   static BasicType box_klass_type(Klass* k);  // inverse of box_klass
431 #ifdef ASSERT
432   static bool is_well_known_klass(Klass* k) {
433     return is_well_known_klass(k-&gt;name());
434   }
435   static bool is_well_known_klass(Symbol* class_name);
436 #endif
437 
438 protected:
439   // Returns the class loader data to be used when looking up/updating the
440   // system dictionary.
441   static ClassLoaderData *class_loader_data(Handle class_loader) {
442     return ClassLoaderData::class_loader_data(class_loader());
443   }
444 




445 public:
<span class="line-modified">446   static bool Parameter_klass_loaded()      { return WK_KLASS(reflect_Parameter_klass) != NULL; }</span>
<span class="line-modified">447   static bool Class_klass_loaded()          { return WK_KLASS(Class_klass) != NULL; }</span>
<span class="line-modified">448   static bool Cloneable_klass_loaded()      { return WK_KLASS(Cloneable_klass) != NULL; }</span>
<span class="line-modified">449   static bool Object_klass_loaded()         { return WK_KLASS(Object_klass) != NULL; }</span>
<span class="line-modified">450   static bool ClassLoader_klass_loaded()    { return WK_KLASS(ClassLoader_klass) != NULL; }</span>
451 
452   // Returns java system loader
453   static oop java_system_loader();
454 
455   // Returns java platform loader
456   static oop java_platform_loader();
457 
458   // Compute the java system and platform loaders
459   static void compute_java_loaders(TRAPS);
460 
461   // Register a new class loader
462   static ClassLoaderData* register_loader(Handle class_loader);
463 protected:
464   // Mirrors for primitive classes (created eagerly)
465   static oop check_mirror(oop m) {
466     assert(m != NULL, &quot;mirror not initialized&quot;);
467     return m;
468   }
469 
470 public:
</pre>
<hr />
<pre>
585 
586   // Basic loading operations
587   static InstanceKlass* resolve_instance_class_or_null_helper(Symbol* name,
588                                                               Handle class_loader,
589                                                               Handle protection_domain,
590                                                               TRAPS);
591   static InstanceKlass* resolve_instance_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
592   static Klass* resolve_array_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
593   static InstanceKlass* handle_parallel_super_load(Symbol* class_name, Symbol* supername, Handle class_loader, Handle protection_domain, Handle lockObject, TRAPS);
594   // Wait on SystemDictionary_lock; unlocks lockObject before
595   // waiting; relocks lockObject with correct recursion count
596   // after waiting, but before reentering SystemDictionary_lock
597   // to preserve lock order semantics.
598   static void double_lock_wait(Handle lockObject, TRAPS);
599   static void define_instance_class(InstanceKlass* k, TRAPS);
600   static InstanceKlass* find_or_define_instance_class(Symbol* class_name,
601                                                 Handle class_loader,
602                                                 InstanceKlass* k, TRAPS);
603   static bool is_shared_class_visible(Symbol* class_name, InstanceKlass* ik,
604                                       Handle class_loader, TRAPS);





605   static InstanceKlass* load_shared_class(InstanceKlass* ik,
606                                           Handle class_loader,
607                                           Handle protection_domain,
608                                           const ClassFileStream *cfs,
609                                           TRAPS);


610   static InstanceKlass* load_shared_boot_class(Symbol* class_name,
611                                                TRAPS);
612   static InstanceKlass* load_instance_class(Symbol* class_name, Handle class_loader, TRAPS);
613   static Handle compute_loader_lock_object(Handle class_loader, TRAPS);
614   static void check_loader_lock_contention(Handle loader_lock, TRAPS);
615   static bool is_parallelCapable(Handle class_loader);
616   static bool is_parallelDefine(Handle class_loader);
617 
618 public:
619   static bool is_system_class_loader(oop class_loader);
620   static bool is_platform_class_loader(oop class_loader);
621 
622   // Returns TRUE if the method is a non-public member of class java.lang.Object.
623   static bool is_nonpublic_Object_method(Method* m) {
624     assert(m != NULL, &quot;Unexpected NULL Method*&quot;);
625     return !m-&gt;is_public() &amp;&amp; m-&gt;method_holder() == SystemDictionary::Object_klass();
626   }
627 
628 protected:
629   // Setup link to hierarchy
630   static void add_to_hierarchy(InstanceKlass* k, TRAPS);
631 
632   // Basic find on loaded classes
633   static InstanceKlass* find_class(unsigned int hash,
634                                    Symbol* name, Dictionary* dictionary);
635   static InstanceKlass* find_class(Symbol* class_name, ClassLoaderData* loader_data);
636 
637   // Basic find on classes in the midst of being loaded
638   static Symbol* find_placeholder(Symbol* name, ClassLoaderData* loader_data);
639 
640   // Resolve well-known classes so they can be used like SystemDictionary::String_klass()
641   static void resolve_well_known_classes(TRAPS);


642 
643   // Class loader constraints
644   static void check_constraints(unsigned int hash,
645                                 InstanceKlass* k, Handle loader,
646                                 bool defining, TRAPS);
647   static void update_dictionary(unsigned int d_hash,
648                                 int p_index, unsigned int p_hash,
649                                 InstanceKlass* k, Handle loader,
650                                 TRAPS);
651 
652   static InstanceKlass* _well_known_klasses[];
653 
654   // table of box klasses (int_klass, etc.)
655   static InstanceKlass* _box_klasses[T_VOID+1];
656 
657 private:
658   static oop  _java_system_loader;
659   static oop  _java_platform_loader;
660 
661 public:
</pre>
</td>
<td>
<hr />
<pre>
213   do_klass(Character_klass,                             java_lang_Character                                   ) \
214   do_klass(Float_klass,                                 java_lang_Float                                       ) \
215   do_klass(Double_klass,                                java_lang_Double                                      ) \
216   do_klass(Byte_klass,                                  java_lang_Byte                                        ) \
217   do_klass(Short_klass,                                 java_lang_Short                                       ) \
218   do_klass(Integer_klass,                               java_lang_Integer                                     ) \
219   do_klass(Long_klass,                                  java_lang_Long                                        ) \
220                                                                                                                 \
221   /* force inline of iterators */                                                                               \
222   do_klass(Iterator_klass,                              java_util_Iterator                                    ) \
223                                                                                                                 \
224   do_klass(jdk_internal_vm_jni_SubElementSelector_klass, jdk_internal_vm_jni_SubElementSelector               ) \
225   /* support for records */                                                                                     \
226   do_klass(RecordComponent_klass,                       java_lang_reflect_RecordComponent                     ) \
227                                                                                                                 \
228   /*end*/
229 
230 class SystemDictionary : AllStatic {
231   friend class BootstrapInfo;
232   friend class VMStructs;

233 
234  public:
235   enum WKID {
236     NO_WKID = 0,
237 
238     #define WK_KLASS_ENUM(name, symbol) WK_KLASS_ENUM_NAME(name), WK_KLASS_ENUM_NAME(symbol) = WK_KLASS_ENUM_NAME(name),
239     WK_KLASSES_DO(WK_KLASS_ENUM)
240     #undef WK_KLASS_ENUM
241 
242     WKID_LIMIT,
243 
244     FIRST_WKID = NO_WKID + 1
245   };
246 
247   // Returns a class with a given class name and class loader.  Loads the
248   // class if needed. If not found a NoClassDefFoundError or a
249   // ClassNotFoundException is thrown, depending on the value on the
250   // throw_error flag.  For most uses the throw_error argument should be set
251   // to true.
252 
</pre>
<hr />
<pre>
380   static void verify();
381 
382   // Initialization
383   static void initialize(TRAPS);
384 
385   // Checked fast access to the well-known classes -- so that you don&#39;t try to use them
386   // before they are resolved.
387   static InstanceKlass* check_klass(InstanceKlass* k) {
388     assert(k != NULL, &quot;klass not loaded&quot;);
389     return k;
390   }
391 
392   static bool resolve_wk_klass(WKID id, TRAPS);
393   static InstanceKlass* check_klass_ValhallaClasses(InstanceKlass* k) { return k; }
394   static void resolve_wk_klasses_until(WKID limit_id, WKID &amp;start_id, TRAPS);
395   static void resolve_wk_klasses_through(WKID end_id, WKID &amp;start_id, TRAPS) {
396     int limit = (int)end_id + 1;
397     resolve_wk_klasses_until((WKID) limit, start_id, THREAD);
398   }
399 public:
<span class="line-added">400   #define WK_KLASS(name) _well_known_klasses[SystemDictionary::WK_KLASS_ENUM_NAME(name)]</span>
<span class="line-added">401 </span>
402   #define WK_KLASS_DECLARE(name, symbol) \
403     static InstanceKlass* name() { return check_klass(_well_known_klasses[WK_KLASS_ENUM_NAME(name)]); } \
404     static InstanceKlass** name##_addr() {                                                              \
405       return &amp;_well_known_klasses[SystemDictionary::WK_KLASS_ENUM_NAME(name)];                          \
406     }                                                                                                   \
407     static bool name##_is_loaded() {                                                                    \
<span class="line-modified">408       return is_wk_klass_loaded(WK_KLASS(name));                                                        \</span>
409     }
410   WK_KLASSES_DO(WK_KLASS_DECLARE);
411   #undef WK_KLASS_DECLARE
412 
413   static InstanceKlass* well_known_klass(WKID id) {
414     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
415     return _well_known_klasses[id];
416   }
417 
418   static InstanceKlass** well_known_klass_addr(WKID id) {
419     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
420     return &amp;_well_known_klasses[id];
421   }
422   static void well_known_klasses_do(MetaspaceClosure* it);
423 



424   static InstanceKlass* box_klass(BasicType t) {
425     assert((uint)t &lt; T_VOID+1, &quot;range check&quot;);
426     return check_klass(_box_klasses[t]);
427   }
428   static BasicType box_klass_type(Klass* k);  // inverse of box_klass
429 #ifdef ASSERT
430   static bool is_well_known_klass(Klass* k) {
431     return is_well_known_klass(k-&gt;name());
432   }
433   static bool is_well_known_klass(Symbol* class_name);
434 #endif
435 
436 protected:
437   // Returns the class loader data to be used when looking up/updating the
438   // system dictionary.
439   static ClassLoaderData *class_loader_data(Handle class_loader) {
440     return ClassLoaderData::class_loader_data(class_loader());
441   }
442 
<span class="line-added">443   static bool is_wk_klass_loaded(InstanceKlass* klass) {</span>
<span class="line-added">444     return !(klass == NULL || !klass-&gt;is_loaded());</span>
<span class="line-added">445   }</span>
<span class="line-added">446 </span>
447 public:
<span class="line-modified">448   static bool Object_klass_loaded()         { return is_wk_klass_loaded(WK_KLASS(Object_klass));             }</span>
<span class="line-modified">449   static bool Class_klass_loaded()          { return is_wk_klass_loaded(WK_KLASS(Class_klass));              }</span>
<span class="line-modified">450   static bool Cloneable_klass_loaded()      { return is_wk_klass_loaded(WK_KLASS(Cloneable_klass));          }</span>
<span class="line-modified">451   static bool Parameter_klass_loaded()      { return is_wk_klass_loaded(WK_KLASS(reflect_Parameter_klass));  }</span>
<span class="line-modified">452   static bool ClassLoader_klass_loaded()    { return is_wk_klass_loaded(WK_KLASS(ClassLoader_klass));        }</span>
453 
454   // Returns java system loader
455   static oop java_system_loader();
456 
457   // Returns java platform loader
458   static oop java_platform_loader();
459 
460   // Compute the java system and platform loaders
461   static void compute_java_loaders(TRAPS);
462 
463   // Register a new class loader
464   static ClassLoaderData* register_loader(Handle class_loader);
465 protected:
466   // Mirrors for primitive classes (created eagerly)
467   static oop check_mirror(oop m) {
468     assert(m != NULL, &quot;mirror not initialized&quot;);
469     return m;
470   }
471 
472 public:
</pre>
<hr />
<pre>
587 
588   // Basic loading operations
589   static InstanceKlass* resolve_instance_class_or_null_helper(Symbol* name,
590                                                               Handle class_loader,
591                                                               Handle protection_domain,
592                                                               TRAPS);
593   static InstanceKlass* resolve_instance_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
594   static Klass* resolve_array_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
595   static InstanceKlass* handle_parallel_super_load(Symbol* class_name, Symbol* supername, Handle class_loader, Handle protection_domain, Handle lockObject, TRAPS);
596   // Wait on SystemDictionary_lock; unlocks lockObject before
597   // waiting; relocks lockObject with correct recursion count
598   // after waiting, but before reentering SystemDictionary_lock
599   // to preserve lock order semantics.
600   static void double_lock_wait(Handle lockObject, TRAPS);
601   static void define_instance_class(InstanceKlass* k, TRAPS);
602   static InstanceKlass* find_or_define_instance_class(Symbol* class_name,
603                                                 Handle class_loader,
604                                                 InstanceKlass* k, TRAPS);
605   static bool is_shared_class_visible(Symbol* class_name, InstanceKlass* ik,
606                                       Handle class_loader, TRAPS);
<span class="line-added">607   static bool check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super,</span>
<span class="line-added">608                                             Handle class_loader,  Handle protection_domain,</span>
<span class="line-added">609                                             bool is_superclass, TRAPS);</span>
<span class="line-added">610   static bool check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,</span>
<span class="line-added">611                                                Handle protection_domain, TRAPS);</span>
612   static InstanceKlass* load_shared_class(InstanceKlass* ik,
613                                           Handle class_loader,
614                                           Handle protection_domain,
615                                           const ClassFileStream *cfs,
616                                           TRAPS);
<span class="line-added">617   // Second part of load_shared_class</span>
<span class="line-added">618   static void load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) NOT_CDS_RETURN;</span>
619   static InstanceKlass* load_shared_boot_class(Symbol* class_name,
620                                                TRAPS);
621   static InstanceKlass* load_instance_class(Symbol* class_name, Handle class_loader, TRAPS);
622   static Handle compute_loader_lock_object(Handle class_loader, TRAPS);
623   static void check_loader_lock_contention(Handle loader_lock, TRAPS);
624   static bool is_parallelCapable(Handle class_loader);
625   static bool is_parallelDefine(Handle class_loader);
626 
627 public:
628   static bool is_system_class_loader(oop class_loader);
629   static bool is_platform_class_loader(oop class_loader);
630 
631   // Returns TRUE if the method is a non-public member of class java.lang.Object.
632   static bool is_nonpublic_Object_method(Method* m) {
633     assert(m != NULL, &quot;Unexpected NULL Method*&quot;);
634     return !m-&gt;is_public() &amp;&amp; m-&gt;method_holder() == SystemDictionary::Object_klass();
635   }
636 
637 protected:
638   // Setup link to hierarchy
639   static void add_to_hierarchy(InstanceKlass* k, TRAPS);
640 
641   // Basic find on loaded classes
642   static InstanceKlass* find_class(unsigned int hash,
643                                    Symbol* name, Dictionary* dictionary);
644   static InstanceKlass* find_class(Symbol* class_name, ClassLoaderData* loader_data);
645 
646   // Basic find on classes in the midst of being loaded
647   static Symbol* find_placeholder(Symbol* name, ClassLoaderData* loader_data);
648 
649   // Resolve well-known classes so they can be used like SystemDictionary::String_klass()
650   static void resolve_well_known_classes(TRAPS);
<span class="line-added">651   // quick resolve using CDS for well-known classes only.</span>
<span class="line-added">652   static void quick_resolve(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) NOT_CDS_RETURN;</span>
653 
654   // Class loader constraints
655   static void check_constraints(unsigned int hash,
656                                 InstanceKlass* k, Handle loader,
657                                 bool defining, TRAPS);
658   static void update_dictionary(unsigned int d_hash,
659                                 int p_index, unsigned int p_hash,
660                                 InstanceKlass* k, Handle loader,
661                                 TRAPS);
662 
663   static InstanceKlass* _well_known_klasses[];
664 
665   // table of box klasses (int_klass, etc.)
666   static InstanceKlass* _box_klasses[T_VOID+1];
667 
668 private:
669   static oop  _java_system_loader;
670   static oop  _java_platform_loader;
671 
672 public:
</pre>
</td>
</tr>
</table>
<center><a href="systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionaryShared.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../ci/ciEnv.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classListParser.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
5667       if (_major_version &lt; JAVA_1_5_VERSION) {
5668         // Skip over the class name if one is there
5669         const char* const p = skip_over_field_name(signature + 1, true, --length);
5670 
5671         // The next character better be a semicolon
5672         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5673           return p + 1;
5674         }
5675       }
5676       else {
5677         // Skip leading &#39;L&#39; or &#39;Q&#39; and ignore first appearance of &#39;;&#39;
5678         signature++;
5679         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5680         // Format check signature
5681         if (c != NULL) {
5682           int newlen = c - (char*) signature;
5683           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5684           if (!legal) {
5685             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5686                                   &quot;in descriptor in class file %s&quot;,
<span class="line-modified">5687                                   CHECK_0);</span>
5688             return NULL;
5689           }
5690           return signature + newlen + 1;
5691         }
5692       }
5693       return NULL;
5694     }
5695     case JVM_SIGNATURE_ARRAY:
5696       array_dim++;
5697       if (array_dim &gt; 255) {
5698         // 4277370: array descriptor is valid only if it represents 255 or fewer dimensions.
<span class="line-modified">5699         classfile_parse_error(&quot;Array type descriptor has more than 255 dimensions in class file %s&quot;, CHECK_0);</span>
5700       }
5701       // The rest of what&#39;s there better be a legal signature
5702       signature++;
5703       length--;
5704       void_ok = false;
5705       break;
5706     default:
5707       return NULL;
5708     }
5709   }
5710   return NULL;
5711 }
5712 
5713 // Checks if name is a legal class name.
5714 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5715   if (!_need_verify || _relax_verify) { return; }
5716 
5717   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5718   char* bytes = (char*)name-&gt;bytes();
5719   unsigned int length = name-&gt;utf8_length();
</pre>
<hr />
<pre>
6339 
6340 void ClassFileParser::update_class_name(Symbol* new_class_name) {
6341   // Decrement the refcount in the old name, since we&#39;re clobbering it.
6342   _class_name-&gt;decrement_refcount();
6343 
6344   _class_name = new_class_name;
6345   // Increment the refcount of the new name.
6346   // Now the ClassFileParser owns this name and will decrement in
6347   // the destructor.
6348   _class_name-&gt;increment_refcount();
6349 }
6350 
6351 
6352 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
6353 // package by prepending its host class&#39;s package name to its class name and setting
6354 // its _class_name field.
6355 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
6356   ResourceMark rm(THREAD);
6357   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
6358          &quot;Unsafe anonymous class should not be in a package&quot;);
<span class="line-modified">6359   const char* host_pkg_name =</span>
<span class="line-modified">6360     ClassLoader::package_from_name(unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), NULL);</span>
6361 
6362   if (host_pkg_name != NULL) {
<span class="line-modified">6363     int host_pkg_len = (int)strlen(host_pkg_name);</span>
6364     int class_name_len = _class_name-&gt;utf8_length();
6365     int symbol_len = host_pkg_len + 1 + class_name_len;
6366     char* new_anon_name = NEW_RESOURCE_ARRAY(char, symbol_len + 1);
<span class="line-modified">6367     int n = os::snprintf(new_anon_name, symbol_len + 1, &quot;%s/%.*s&quot;,</span>
<span class="line-modified">6368                          host_pkg_name, class_name_len, _class_name-&gt;base());</span>
6369     assert(n == symbol_len, &quot;Unexpected number of characters in string&quot;);
6370 
6371     // Decrement old _class_name to avoid leaking.
6372     _class_name-&gt;decrement_refcount();
6373 
6374     // Create a symbol and update the anonymous class name.
6375     // The new class name is created with a refcount of one. When installed into the InstanceKlass,
6376     // it&#39;ll be two and when the ClassFileParser destructor runs, it&#39;ll go back to one and get deleted
6377     // when the class is unloaded.
6378     _class_name = SymbolTable::new_symbol(new_anon_name, symbol_len);
6379   }
6380 }
6381 
6382 // If the host class and the anonymous class are in the same package then do
6383 // nothing.  If the anonymous class is in the unnamed package then move it to its
6384 // host&#39;s package.  If the classes are in different packages then throw an IAE
6385 // exception.
6386 void ClassFileParser::fix_unsafe_anonymous_class_name(TRAPS) {
6387   assert(_unsafe_anonymous_host != NULL, &quot;Expected an unsafe anonymous class&quot;);
6388 
</pre>
</td>
<td>
<hr />
<pre>
5667       if (_major_version &lt; JAVA_1_5_VERSION) {
5668         // Skip over the class name if one is there
5669         const char* const p = skip_over_field_name(signature + 1, true, --length);
5670 
5671         // The next character better be a semicolon
5672         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5673           return p + 1;
5674         }
5675       }
5676       else {
5677         // Skip leading &#39;L&#39; or &#39;Q&#39; and ignore first appearance of &#39;;&#39;
5678         signature++;
5679         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5680         // Format check signature
5681         if (c != NULL) {
5682           int newlen = c - (char*) signature;
5683           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5684           if (!legal) {
5685             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5686                                   &quot;in descriptor in class file %s&quot;,
<span class="line-modified">5687                                   CHECK_NULL);</span>
5688             return NULL;
5689           }
5690           return signature + newlen + 1;
5691         }
5692       }
5693       return NULL;
5694     }
5695     case JVM_SIGNATURE_ARRAY:
5696       array_dim++;
5697       if (array_dim &gt; 255) {
5698         // 4277370: array descriptor is valid only if it represents 255 or fewer dimensions.
<span class="line-modified">5699         classfile_parse_error(&quot;Array type descriptor has more than 255 dimensions in class file %s&quot;, CHECK_NULL);</span>
5700       }
5701       // The rest of what&#39;s there better be a legal signature
5702       signature++;
5703       length--;
5704       void_ok = false;
5705       break;
5706     default:
5707       return NULL;
5708     }
5709   }
5710   return NULL;
5711 }
5712 
5713 // Checks if name is a legal class name.
5714 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5715   if (!_need_verify || _relax_verify) { return; }
5716 
5717   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5718   char* bytes = (char*)name-&gt;bytes();
5719   unsigned int length = name-&gt;utf8_length();
</pre>
<hr />
<pre>
6339 
6340 void ClassFileParser::update_class_name(Symbol* new_class_name) {
6341   // Decrement the refcount in the old name, since we&#39;re clobbering it.
6342   _class_name-&gt;decrement_refcount();
6343 
6344   _class_name = new_class_name;
6345   // Increment the refcount of the new name.
6346   // Now the ClassFileParser owns this name and will decrement in
6347   // the destructor.
6348   _class_name-&gt;increment_refcount();
6349 }
6350 
6351 
6352 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
6353 // package by prepending its host class&#39;s package name to its class name and setting
6354 // its _class_name field.
6355 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
6356   ResourceMark rm(THREAD);
6357   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
6358          &quot;Unsafe anonymous class should not be in a package&quot;);
<span class="line-modified">6359   TempNewSymbol host_pkg_name =</span>
<span class="line-modified">6360     ClassLoader::package_from_class_name(unsafe_anonymous_host-&gt;name());</span>
6361 
6362   if (host_pkg_name != NULL) {
<span class="line-modified">6363     int host_pkg_len = host_pkg_name-&gt;utf8_length();</span>
6364     int class_name_len = _class_name-&gt;utf8_length();
6365     int symbol_len = host_pkg_len + 1 + class_name_len;
6366     char* new_anon_name = NEW_RESOURCE_ARRAY(char, symbol_len + 1);
<span class="line-modified">6367     int n = os::snprintf(new_anon_name, symbol_len + 1, &quot;%.*s/%.*s&quot;,</span>
<span class="line-modified">6368                          host_pkg_len, host_pkg_name-&gt;base(), class_name_len, _class_name-&gt;base());</span>
6369     assert(n == symbol_len, &quot;Unexpected number of characters in string&quot;);
6370 
6371     // Decrement old _class_name to avoid leaking.
6372     _class_name-&gt;decrement_refcount();
6373 
6374     // Create a symbol and update the anonymous class name.
6375     // The new class name is created with a refcount of one. When installed into the InstanceKlass,
6376     // it&#39;ll be two and when the ClassFileParser destructor runs, it&#39;ll go back to one and get deleted
6377     // when the class is unloaded.
6378     _class_name = SymbolTable::new_symbol(new_anon_name, symbol_len);
6379   }
6380 }
6381 
6382 // If the host class and the anonymous class are in the same package then do
6383 // nothing.  If the anonymous class is in the unnamed package then move it to its
6384 // host&#39;s package.  If the classes are in different packages then throw an IAE
6385 // exception.
6386 void ClassFileParser::fix_unsafe_anonymous_class_name(TRAPS) {
6387   assert(_unsafe_anonymous_host != NULL, &quot;Expected an unsafe anonymous class&quot;);
6388 
</pre>
</td>
</tr>
</table>
<center><a href="../ci/ciEnv.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classListParser.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
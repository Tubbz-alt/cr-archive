<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoaderExt.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klassFactory.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 281       buffer-&gt;char_at_put(index, unicode[index]);
 282     }
 283   }
 284 
 285 #ifdef ASSERT
 286   {
 287     ResourceMark rm;
 288     char* expected = UNICODE::as_utf8(unicode, length);
 289     char* actual = as_utf8_string(h_obj());
 290     if (strcmp(expected, actual) != 0) {
 291       tty-&gt;print_cr(&quot;Unicode conversion failure: %s --&gt; %s&quot;, expected, actual);
 292       ShouldNotReachHere();
 293     }
 294   }
 295 #endif
 296 
 297   return h_obj;
 298 }
 299 
 300 oop java_lang_String::create_oop_from_unicode(const jchar* unicode, int length, TRAPS) {
<span class="line-modified"> 301   Handle h_obj = create_from_unicode(unicode, length, CHECK_0);</span>
 302   return h_obj();
 303 }
 304 
 305 Handle java_lang_String::create_from_str(const char* utf8_str, TRAPS) {
 306   if (utf8_str == NULL) {
 307     return Handle();
 308   }
 309   bool has_multibyte, is_latin1;
 310   int length = UTF8::unicode_length(utf8_str, is_latin1, has_multibyte);
 311   if (!CompactStrings) {
 312     has_multibyte = true;
 313     is_latin1 = false;
 314   }
 315 
 316   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 317   if (length &gt; 0) {
 318     if (!has_multibyte) {
 319       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 320       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 321     } else if (is_latin1) {
</pre>
<hr />
<pre>
 328 #ifdef ASSERT
 329   // This check is too strict because the input string is not necessarily valid UTF8.
 330   // For example, it may be created with arbitrary content via jni_NewStringUTF.
 331   /*
 332   {
 333     ResourceMark rm;
 334     const char* expected = utf8_str;
 335     char* actual = as_utf8_string(h_obj());
 336     if (strcmp(expected, actual) != 0) {
 337       tty-&gt;print_cr(&quot;String conversion failure: %s --&gt; %s&quot;, expected, actual);
 338       ShouldNotReachHere();
 339     }
 340   }
 341   */
 342 #endif
 343 
 344   return h_obj;
 345 }
 346 
 347 oop java_lang_String::create_oop_from_str(const char* utf8_str, TRAPS) {
<span class="line-modified"> 348   Handle h_obj = create_from_str(utf8_str, CHECK_0);</span>
 349   return h_obj();
 350 }
 351 
 352 Handle java_lang_String::create_from_symbol(Symbol* symbol, TRAPS) {
 353   const char* utf8_str = (char*)symbol-&gt;bytes();
 354   int utf8_len = symbol-&gt;utf8_length();
 355 
 356   bool has_multibyte, is_latin1;
 357   int length = UTF8::unicode_length(utf8_str, utf8_len, is_latin1, has_multibyte);
 358   if (!CompactStrings) {
 359     has_multibyte = true;
 360     is_latin1 = false;
 361   }
 362 
 363   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 364   if (length &gt; 0) {
 365     if (!has_multibyte) {
 366       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 367       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 368     } else if (is_latin1) {
</pre>
<hr />
<pre>
1494 }
1495 
1496 void java_lang_Class::set_inline_type_mirror(oop java_class, oop mirror) {
1497   assert(_inline_mirror_offset != 0, &quot;must be set&quot;);
1498   java_class-&gt;obj_field_put(_inline_mirror_offset, mirror);
1499 }
1500 
1501 oop java_lang_Class::indirect_type_mirror(oop java_class) {
1502   assert(_indirect_mirror_offset != 0, &quot;must be set&quot;);
1503   return java_class-&gt;obj_field(_indirect_mirror_offset);
1504 }
1505 
1506 void java_lang_Class::set_indirect_type_mirror(oop java_class, oop mirror) {
1507   assert(_indirect_mirror_offset != 0, &quot;must be set&quot;);
1508   java_class-&gt;obj_field_put(_indirect_mirror_offset, mirror);
1509 }
1510 
1511 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1512   // This should be improved by adding a field at the Java level or by
1513   // introducing a new VM klass (see comment in ClassFileParser)
<span class="line-modified">1514   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_0);</span>
1515   if (type != T_VOID) {
1516     Klass* aklass = Universe::typeArrayKlassObj(type);
1517     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1518     release_set_array_klass(java_class, aklass);
1519   }
1520 #ifdef ASSERT
1521   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1522   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1523 #endif
1524   return java_class;
1525 }
1526 
1527 
1528 Klass* java_lang_Class::as_Klass(oop java_class) {
1529   //%note memory_2
1530   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1531   Klass* k = ((Klass*)java_class-&gt;metadata_field(_klass_offset));
1532   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1533   return k;
1534 }
</pre>
<hr />
<pre>
2084 
2085 static inline bool version_matches(Method* method, int version) {
2086   assert(version &lt; MAX_VERSION, &quot;version is too big&quot;);
2087   return method != NULL &amp;&amp; (method-&gt;constants()-&gt;version() == version);
2088 }
2089 
2090 // This class provides a simple wrapper over the internal structure of
2091 // exception backtrace to insulate users of the backtrace from needing
2092 // to know what it looks like.
2093 // The code of this class is not GC safe. Allocations can only happen
2094 // in expand().
2095 class BacktraceBuilder: public StackObj {
2096  friend class BacktraceIterator;
2097  private:
2098   Handle          _backtrace;
2099   objArrayOop     _head;
2100   typeArrayOop    _methods;
2101   typeArrayOop    _bcis;
2102   objArrayOop     _mirrors;
2103   typeArrayOop    _names; // Needed to insulate method name against redefinition.
<span class="line-modified">2104   // This is set to a java.lang.Boolean(true) if the top frame</span>
<span class="line-modified">2105   // of the backtrace is omitted because it shall be hidden.</span>
<span class="line-removed">2106   // Else it is null.</span>
<span class="line-removed">2107   oop             _has_hidden_top_frame;</span>
2108   int             _index;
2109   NoSafepointVerifier _nsv;
2110 
2111   enum {
2112     trace_methods_offset = java_lang_Throwable::trace_methods_offset,
2113     trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,
2114     trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,
2115     trace_names_offset   = java_lang_Throwable::trace_names_offset,
2116     trace_next_offset    = java_lang_Throwable::trace_next_offset,
2117     trace_hidden_offset  = java_lang_Throwable::trace_hidden_offset,
2118     trace_size           = java_lang_Throwable::trace_size,
2119     trace_chunk_size     = java_lang_Throwable::trace_chunk_size
2120   };
2121 
2122   // get info out of chunks
2123   static typeArrayOop get_methods(objArrayHandle chunk) {
2124     typeArrayOop methods = typeArrayOop(chunk-&gt;obj_at(trace_methods_offset));
2125     assert(methods != NULL, &quot;method array should be initialized in backtrace&quot;);
2126     return methods;
2127   }
2128   static typeArrayOop get_bcis(objArrayHandle chunk) {
2129     typeArrayOop bcis = typeArrayOop(chunk-&gt;obj_at(trace_bcis_offset));
2130     assert(bcis != NULL, &quot;bci array should be initialized in backtrace&quot;);
2131     return bcis;
2132   }
2133   static objArrayOop get_mirrors(objArrayHandle chunk) {
2134     objArrayOop mirrors = objArrayOop(chunk-&gt;obj_at(trace_mirrors_offset));
2135     assert(mirrors != NULL, &quot;mirror array should be initialized in backtrace&quot;);
2136     return mirrors;
2137   }
2138   static typeArrayOop get_names(objArrayHandle chunk) {
2139     typeArrayOop names = typeArrayOop(chunk-&gt;obj_at(trace_names_offset));
2140     assert(names != NULL, &quot;names array should be initialized in backtrace&quot;);
2141     return names;
2142   }
<span class="line-modified">2143   static oop get_has_hidden_top_frame(objArrayHandle chunk) {</span>
2144     oop hidden = chunk-&gt;obj_at(trace_hidden_offset);
<span class="line-modified">2145     return hidden;</span>
2146   }
2147 
2148  public:
2149 
2150   // constructor for new backtrace
<span class="line-modified">2151   BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _has_hidden_top_frame(NULL) {</span>
2152     expand(CHECK);
2153     _backtrace = Handle(THREAD, _head);
2154     _index = 0;
2155   }
2156 
2157   BacktraceBuilder(Thread* thread, objArrayHandle backtrace) {
2158     _methods = get_methods(backtrace);
2159     _bcis = get_bcis(backtrace);
2160     _mirrors = get_mirrors(backtrace);
2161     _names = get_names(backtrace);
<span class="line-modified">2162     _has_hidden_top_frame = get_has_hidden_top_frame(backtrace);</span>
2163     assert(_methods-&gt;length() == _bcis-&gt;length() &amp;&amp;
2164            _methods-&gt;length() == _mirrors-&gt;length() &amp;&amp;
2165            _mirrors-&gt;length() == _names-&gt;length(),
2166            &quot;method and source information arrays should match&quot;);
2167 
2168     // head is the preallocated backtrace
2169     _head = backtrace();
2170     _backtrace = Handle(thread, _head);
2171     _index = 0;
2172   }
2173 
2174   void expand(TRAPS) {
2175     objArrayHandle old_head(THREAD, _head);
2176     PauseNoSafepointVerifier pnsv(&amp;_nsv);
2177 
2178     objArrayOop head = oopFactory::new_objectArray(trace_size, CHECK);
2179     objArrayHandle new_head(THREAD, head);
2180 
2181     typeArrayOop methods = oopFactory::new_shortArray(trace_chunk_size, CHECK);
2182     typeArrayHandle new_methods(THREAD, methods);
</pre>
<hr />
<pre>
2222       expand(CHECK);
2223       method = mhandle();
2224     }
2225 
2226     _methods-&gt;ushort_at_put(_index, method-&gt;orig_method_idnum());
2227     _bcis-&gt;int_at_put(_index, Backtrace::merge_bci_and_version(bci, method-&gt;constants()-&gt;version()));
2228 
2229     // Note:this doesn&#39;t leak symbols because the mirror in the backtrace keeps the
2230     // klass owning the symbols alive so their refcounts aren&#39;t decremented.
2231     Symbol* name = method-&gt;name();
2232     _names-&gt;symbol_at_put(_index, name);
2233 
2234     // We need to save the mirrors in the backtrace to keep the class
2235     // from being unloaded while we still have this stack trace.
2236     assert(method-&gt;method_holder()-&gt;java_mirror() != NULL, &quot;never push null for mirror&quot;);
2237     _mirrors-&gt;obj_at_put(_index, method-&gt;method_holder()-&gt;java_mirror());
2238     _index++;
2239   }
2240 
2241   void set_has_hidden_top_frame(TRAPS) {
<span class="line-modified">2242     if (_has_hidden_top_frame == NULL) {</span>
2243       // It would be nice to add java/lang/Boolean::TRUE here
2244       // to indicate that this backtrace has a hidden top frame.
2245       // But this code is used before TRUE is allocated.
<span class="line-modified">2246       // Therefor let&#39;s just use an arbitrary legal oop</span>
<span class="line-modified">2247       // available right here. We only test for != null</span>
<span class="line-removed">2248       // anyways. _methods is a short[].</span>
2249       assert(_methods != NULL, &quot;we need a legal oop&quot;);
<span class="line-modified">2250       _has_hidden_top_frame = _methods;</span>
<span class="line-modified">2251       _head-&gt;obj_at_put(trace_hidden_offset, _has_hidden_top_frame);</span>
2252     }
2253   }
<span class="line-removed">2254 </span>
2255 };
2256 
2257 struct BacktraceElement : public StackObj {
2258   int _method_id;
2259   int _bci;
2260   int _version;
2261   Symbol* _name;
2262   Handle _mirror;
2263   BacktraceElement(Handle mirror, int mid, int version, int bci, Symbol* name) :
2264                    _method_id(mid), _bci(bci), _version(version), _name(name), _mirror(mirror) {}
2265 };
2266 
2267 class BacktraceIterator : public StackObj {
2268   int _index;
2269   objArrayHandle  _result;
2270   objArrayHandle  _mirrors;
2271   typeArrayHandle _methods;
2272   typeArrayHandle _bcis;
2273   typeArrayHandle _names;
2274 
</pre>
<hr />
<pre>
2717 
2718   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2719   assert(holder != NULL, &quot;first element should be non-null&quot;);
2720   Method* m = holder-&gt;method_with_orig_idnum(bte._method_id, bte._version);
2721 
2722   // Original version is no longer available.
2723   if (m == NULL || !version_matches(m, bte._version)) {
2724     return false;
2725   }
2726 
2727   *method = m;
2728   *bci = bte._bci;
2729   return true;
2730 }
2731 
2732 oop java_lang_StackTraceElement::create(const methodHandle&amp; method, int bci, TRAPS) {
2733   // Allocate java.lang.StackTraceElement instance
2734   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
2735   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
2736   if (k-&gt;should_be_initialized()) {
<span class="line-modified">2737     k-&gt;initialize(CHECK_0);</span>
2738   }
2739 
<span class="line-modified">2740   Handle element = k-&gt;allocate_instance_handle(CHECK_0);</span>
2741 
2742   int version = method-&gt;constants()-&gt;version();
<span class="line-modified">2743   fill_in(element, method-&gt;method_holder(), method, version, bci, method-&gt;name(), CHECK_0);</span>
2744   return element();
2745 }
2746 
2747 void java_lang_StackTraceElement::fill_in(Handle element,
2748                                           InstanceKlass* holder, const methodHandle&amp; method,
2749                                           int version, int bci, Symbol* name, TRAPS) {
2750   assert(element-&gt;is_a(SystemDictionary::StackTraceElement_klass()), &quot;sanity check&quot;);
2751 
2752   ResourceMark rm(THREAD);
2753   HandleMark hm(THREAD);
2754 
2755   // Fill in class name
2756   Handle java_class(THREAD, holder-&gt;java_mirror());
2757   oop classname = java_lang_Class::name(java_class, CHECK);
2758   java_lang_StackTraceElement::set_declaringClass(element(), classname);
2759   java_lang_StackTraceElement::set_declaringClassObject(element(), java_class());
2760 
2761   oop loader = holder-&gt;class_loader();
2762   if (loader != NULL) {
2763     oop loader_name = java_lang_ClassLoader::name(loader);
</pre>
<hr />
<pre>
3469 }
3470 
3471 #define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \
3472   macro(_base_offset, k, &quot;base&quot;, object_signature, false)
3473 
3474 void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
3475   InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
3476   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3477 }
3478 
3479 #if INCLUDE_CDS
3480 void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {
3481   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3482 }
3483 #endif
3484 
3485 oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
3486   Klass* k = SystemDictionary::box_klass(type);
3487   if (k == NULL)  return NULL;
3488   InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">3489   if (!ik-&gt;is_initialized())  ik-&gt;initialize(CHECK_0);</span>
3490   return ik-&gt;allocate_instance(THREAD);
3491 }
3492 
3493 
3494 oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
<span class="line-modified">3495   oop box = initialize_and_allocate(type, CHECK_0);</span>
3496   if (box == NULL)  return NULL;
3497   switch (type) {
3498     case T_BOOLEAN:
3499       box-&gt;bool_field_put(value_offset, value-&gt;z);
3500       break;
3501     case T_CHAR:
3502       box-&gt;char_field_put(value_offset, value-&gt;c);
3503       break;
3504     case T_FLOAT:
3505       box-&gt;float_field_put(value_offset, value-&gt;f);
3506       break;
3507     case T_DOUBLE:
3508       box-&gt;double_field_put(long_value_offset, value-&gt;d);
3509       break;
3510     case T_BYTE:
3511       box-&gt;byte_field_put(value_offset, value-&gt;b);
3512       break;
3513     case T_SHORT:
3514       box-&gt;short_field_put(value_offset, value-&gt;s);
3515       break;
</pre>
<hr />
<pre>
4106   macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
4107   macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
4108   macro(_isAuthorized_offset,      k, &quot;isAuthorized&quot;, bool_signature, false)
4109 
4110 void java_security_AccessControlContext::compute_offsets() {
4111   assert(_isPrivileged_offset == 0, &quot;offsets should be initialized only once&quot;);
4112   InstanceKlass* k = SystemDictionary::AccessControlContext_klass();
4113   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4114 }
4115 
4116 #if INCLUDE_CDS
4117 void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {
4118   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4119 }
4120 #endif
4121 
4122 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
4123   assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
4124   assert(_isAuthorized_offset != -1, &quot;offsets should have been initialized&quot;);
4125   // Ensure klass is initialized
<span class="line-modified">4126   SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_0);</span>
4127   // Allocate result
<span class="line-modified">4128   oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_0);</span>
4129   // Fill in values
4130   result-&gt;obj_field_put(_context_offset, context());
4131   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
4132   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
4133   // whitelist AccessControlContexts created by the JVM
4134   result-&gt;bool_field_put(_isAuthorized_offset, true);
4135   return result;
4136 }
4137 
4138 
4139 // Support for java_lang_ClassLoader
4140 
4141 bool java_lang_ClassLoader::offsets_computed = false;
4142 int  java_lang_ClassLoader::_loader_data_offset = -1;
4143 int  java_lang_ClassLoader::parallelCapable_offset = -1;
4144 int  java_lang_ClassLoader::name_offset = -1;
4145 int  java_lang_ClassLoader::nameAndId_offset = -1;
4146 int  java_lang_ClassLoader::unnamedModule_offset = -1;
4147 
4148 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
</pre>
<hr />
<pre>
4922 // Invoked before SystemDictionary::initialize, so pre-loaded classes
4923 // are not available to determine the offset_of_static_fields.
4924 void JavaClasses::compute_hard_coded_offsets() {
4925 
4926   // java_lang_boxing_object
4927   java_lang_boxing_object::value_offset      = member_offset(java_lang_boxing_object::hc_value_offset);
4928   java_lang_boxing_object::long_value_offset = align_up(member_offset(java_lang_boxing_object::hc_value_offset), BytesPerLong);
4929 
4930   // java_lang_ref_Reference
4931   java_lang_ref_Reference::referent_offset    = member_offset(java_lang_ref_Reference::hc_referent_offset);
4932   java_lang_ref_Reference::queue_offset       = member_offset(java_lang_ref_Reference::hc_queue_offset);
4933   java_lang_ref_Reference::next_offset        = member_offset(java_lang_ref_Reference::hc_next_offset);
4934   java_lang_ref_Reference::discovered_offset  = member_offset(java_lang_ref_Reference::hc_discovered_offset);
4935 }
4936 
4937 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4938 
4939 // Compute non-hard-coded field offsets of all the classes in this file
4940 void JavaClasses::compute_offsets() {
4941   if (UseSharedSpaces) {
<span class="line-modified">4942     assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;</span>
<span class="line-modified">4943                                               JvmtiExport::has_early_class_hook_env()),</span>
<span class="line-modified">4944            &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;);</span>
4945     // None of the classes used by the rest of this function can be replaced by
4946     // JMVTI ClassFileLoadHook.
4947     // We are safe to use the archived offsets, which have already been restored
4948     // by JavaClasses::serialize_offsets, without computing the offsets again.
4949     return;
4950   }
4951 
4952   // We have already called the compute_offsets() of the
4953   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String and java_lang_Class)
4954   // earlier inside SystemDictionary::resolve_well_known_classes()
4955   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
4956 }
4957 
4958 #if INCLUDE_CDS
4959 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4960 
4961 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4962   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4963 }
4964 #endif
</pre>
</td>
<td>
<hr />
<pre>
 281       buffer-&gt;char_at_put(index, unicode[index]);
 282     }
 283   }
 284 
 285 #ifdef ASSERT
 286   {
 287     ResourceMark rm;
 288     char* expected = UNICODE::as_utf8(unicode, length);
 289     char* actual = as_utf8_string(h_obj());
 290     if (strcmp(expected, actual) != 0) {
 291       tty-&gt;print_cr(&quot;Unicode conversion failure: %s --&gt; %s&quot;, expected, actual);
 292       ShouldNotReachHere();
 293     }
 294   }
 295 #endif
 296 
 297   return h_obj;
 298 }
 299 
 300 oop java_lang_String::create_oop_from_unicode(const jchar* unicode, int length, TRAPS) {
<span class="line-modified"> 301   Handle h_obj = create_from_unicode(unicode, length, CHECK_NULL);</span>
 302   return h_obj();
 303 }
 304 
 305 Handle java_lang_String::create_from_str(const char* utf8_str, TRAPS) {
 306   if (utf8_str == NULL) {
 307     return Handle();
 308   }
 309   bool has_multibyte, is_latin1;
 310   int length = UTF8::unicode_length(utf8_str, is_latin1, has_multibyte);
 311   if (!CompactStrings) {
 312     has_multibyte = true;
 313     is_latin1 = false;
 314   }
 315 
 316   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 317   if (length &gt; 0) {
 318     if (!has_multibyte) {
 319       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 320       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 321     } else if (is_latin1) {
</pre>
<hr />
<pre>
 328 #ifdef ASSERT
 329   // This check is too strict because the input string is not necessarily valid UTF8.
 330   // For example, it may be created with arbitrary content via jni_NewStringUTF.
 331   /*
 332   {
 333     ResourceMark rm;
 334     const char* expected = utf8_str;
 335     char* actual = as_utf8_string(h_obj());
 336     if (strcmp(expected, actual) != 0) {
 337       tty-&gt;print_cr(&quot;String conversion failure: %s --&gt; %s&quot;, expected, actual);
 338       ShouldNotReachHere();
 339     }
 340   }
 341   */
 342 #endif
 343 
 344   return h_obj;
 345 }
 346 
 347 oop java_lang_String::create_oop_from_str(const char* utf8_str, TRAPS) {
<span class="line-modified"> 348   Handle h_obj = create_from_str(utf8_str, CHECK_NULL);</span>
 349   return h_obj();
 350 }
 351 
 352 Handle java_lang_String::create_from_symbol(Symbol* symbol, TRAPS) {
 353   const char* utf8_str = (char*)symbol-&gt;bytes();
 354   int utf8_len = symbol-&gt;utf8_length();
 355 
 356   bool has_multibyte, is_latin1;
 357   int length = UTF8::unicode_length(utf8_str, utf8_len, is_latin1, has_multibyte);
 358   if (!CompactStrings) {
 359     has_multibyte = true;
 360     is_latin1 = false;
 361   }
 362 
 363   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 364   if (length &gt; 0) {
 365     if (!has_multibyte) {
 366       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 367       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 368     } else if (is_latin1) {
</pre>
<hr />
<pre>
1494 }
1495 
1496 void java_lang_Class::set_inline_type_mirror(oop java_class, oop mirror) {
1497   assert(_inline_mirror_offset != 0, &quot;must be set&quot;);
1498   java_class-&gt;obj_field_put(_inline_mirror_offset, mirror);
1499 }
1500 
1501 oop java_lang_Class::indirect_type_mirror(oop java_class) {
1502   assert(_indirect_mirror_offset != 0, &quot;must be set&quot;);
1503   return java_class-&gt;obj_field(_indirect_mirror_offset);
1504 }
1505 
1506 void java_lang_Class::set_indirect_type_mirror(oop java_class, oop mirror) {
1507   assert(_indirect_mirror_offset != 0, &quot;must be set&quot;);
1508   java_class-&gt;obj_field_put(_indirect_mirror_offset, mirror);
1509 }
1510 
1511 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1512   // This should be improved by adding a field at the Java level or by
1513   // introducing a new VM klass (see comment in ClassFileParser)
<span class="line-modified">1514   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);</span>
1515   if (type != T_VOID) {
1516     Klass* aklass = Universe::typeArrayKlassObj(type);
1517     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1518     release_set_array_klass(java_class, aklass);
1519   }
1520 #ifdef ASSERT
1521   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1522   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1523 #endif
1524   return java_class;
1525 }
1526 
1527 
1528 Klass* java_lang_Class::as_Klass(oop java_class) {
1529   //%note memory_2
1530   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1531   Klass* k = ((Klass*)java_class-&gt;metadata_field(_klass_offset));
1532   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1533   return k;
1534 }
</pre>
<hr />
<pre>
2084 
2085 static inline bool version_matches(Method* method, int version) {
2086   assert(version &lt; MAX_VERSION, &quot;version is too big&quot;);
2087   return method != NULL &amp;&amp; (method-&gt;constants()-&gt;version() == version);
2088 }
2089 
2090 // This class provides a simple wrapper over the internal structure of
2091 // exception backtrace to insulate users of the backtrace from needing
2092 // to know what it looks like.
2093 // The code of this class is not GC safe. Allocations can only happen
2094 // in expand().
2095 class BacktraceBuilder: public StackObj {
2096  friend class BacktraceIterator;
2097  private:
2098   Handle          _backtrace;
2099   objArrayOop     _head;
2100   typeArrayOop    _methods;
2101   typeArrayOop    _bcis;
2102   objArrayOop     _mirrors;
2103   typeArrayOop    _names; // Needed to insulate method name against redefinition.
<span class="line-modified">2104   // True if the top frame of the backtrace is omitted because it shall be hidden.</span>
<span class="line-modified">2105   bool            _has_hidden_top_frame;</span>


2106   int             _index;
2107   NoSafepointVerifier _nsv;
2108 
2109   enum {
2110     trace_methods_offset = java_lang_Throwable::trace_methods_offset,
2111     trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,
2112     trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,
2113     trace_names_offset   = java_lang_Throwable::trace_names_offset,
2114     trace_next_offset    = java_lang_Throwable::trace_next_offset,
2115     trace_hidden_offset  = java_lang_Throwable::trace_hidden_offset,
2116     trace_size           = java_lang_Throwable::trace_size,
2117     trace_chunk_size     = java_lang_Throwable::trace_chunk_size
2118   };
2119 
2120   // get info out of chunks
2121   static typeArrayOop get_methods(objArrayHandle chunk) {
2122     typeArrayOop methods = typeArrayOop(chunk-&gt;obj_at(trace_methods_offset));
2123     assert(methods != NULL, &quot;method array should be initialized in backtrace&quot;);
2124     return methods;
2125   }
2126   static typeArrayOop get_bcis(objArrayHandle chunk) {
2127     typeArrayOop bcis = typeArrayOop(chunk-&gt;obj_at(trace_bcis_offset));
2128     assert(bcis != NULL, &quot;bci array should be initialized in backtrace&quot;);
2129     return bcis;
2130   }
2131   static objArrayOop get_mirrors(objArrayHandle chunk) {
2132     objArrayOop mirrors = objArrayOop(chunk-&gt;obj_at(trace_mirrors_offset));
2133     assert(mirrors != NULL, &quot;mirror array should be initialized in backtrace&quot;);
2134     return mirrors;
2135   }
2136   static typeArrayOop get_names(objArrayHandle chunk) {
2137     typeArrayOop names = typeArrayOop(chunk-&gt;obj_at(trace_names_offset));
2138     assert(names != NULL, &quot;names array should be initialized in backtrace&quot;);
2139     return names;
2140   }
<span class="line-modified">2141   static bool has_hidden_top_frame(objArrayHandle chunk) {</span>
2142     oop hidden = chunk-&gt;obj_at(trace_hidden_offset);
<span class="line-modified">2143     return hidden != NULL;</span>
2144   }
2145 
2146  public:
2147 
2148   // constructor for new backtrace
<span class="line-modified">2149   BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _has_hidden_top_frame(false) {</span>
2150     expand(CHECK);
2151     _backtrace = Handle(THREAD, _head);
2152     _index = 0;
2153   }
2154 
2155   BacktraceBuilder(Thread* thread, objArrayHandle backtrace) {
2156     _methods = get_methods(backtrace);
2157     _bcis = get_bcis(backtrace);
2158     _mirrors = get_mirrors(backtrace);
2159     _names = get_names(backtrace);
<span class="line-modified">2160     _has_hidden_top_frame = has_hidden_top_frame(backtrace);</span>
2161     assert(_methods-&gt;length() == _bcis-&gt;length() &amp;&amp;
2162            _methods-&gt;length() == _mirrors-&gt;length() &amp;&amp;
2163            _mirrors-&gt;length() == _names-&gt;length(),
2164            &quot;method and source information arrays should match&quot;);
2165 
2166     // head is the preallocated backtrace
2167     _head = backtrace();
2168     _backtrace = Handle(thread, _head);
2169     _index = 0;
2170   }
2171 
2172   void expand(TRAPS) {
2173     objArrayHandle old_head(THREAD, _head);
2174     PauseNoSafepointVerifier pnsv(&amp;_nsv);
2175 
2176     objArrayOop head = oopFactory::new_objectArray(trace_size, CHECK);
2177     objArrayHandle new_head(THREAD, head);
2178 
2179     typeArrayOop methods = oopFactory::new_shortArray(trace_chunk_size, CHECK);
2180     typeArrayHandle new_methods(THREAD, methods);
</pre>
<hr />
<pre>
2220       expand(CHECK);
2221       method = mhandle();
2222     }
2223 
2224     _methods-&gt;ushort_at_put(_index, method-&gt;orig_method_idnum());
2225     _bcis-&gt;int_at_put(_index, Backtrace::merge_bci_and_version(bci, method-&gt;constants()-&gt;version()));
2226 
2227     // Note:this doesn&#39;t leak symbols because the mirror in the backtrace keeps the
2228     // klass owning the symbols alive so their refcounts aren&#39;t decremented.
2229     Symbol* name = method-&gt;name();
2230     _names-&gt;symbol_at_put(_index, name);
2231 
2232     // We need to save the mirrors in the backtrace to keep the class
2233     // from being unloaded while we still have this stack trace.
2234     assert(method-&gt;method_holder()-&gt;java_mirror() != NULL, &quot;never push null for mirror&quot;);
2235     _mirrors-&gt;obj_at_put(_index, method-&gt;method_holder()-&gt;java_mirror());
2236     _index++;
2237   }
2238 
2239   void set_has_hidden_top_frame(TRAPS) {
<span class="line-modified">2240     if (!_has_hidden_top_frame) {</span>
2241       // It would be nice to add java/lang/Boolean::TRUE here
2242       // to indicate that this backtrace has a hidden top frame.
2243       // But this code is used before TRUE is allocated.
<span class="line-modified">2244       // Therefore let&#39;s just use an arbitrary legal oop</span>
<span class="line-modified">2245       // available right here. _methods is a short[].</span>

2246       assert(_methods != NULL, &quot;we need a legal oop&quot;);
<span class="line-modified">2247       _has_hidden_top_frame = true;</span>
<span class="line-modified">2248       _head-&gt;obj_at_put(trace_hidden_offset, _methods);</span>
2249     }
2250   }

2251 };
2252 
2253 struct BacktraceElement : public StackObj {
2254   int _method_id;
2255   int _bci;
2256   int _version;
2257   Symbol* _name;
2258   Handle _mirror;
2259   BacktraceElement(Handle mirror, int mid, int version, int bci, Symbol* name) :
2260                    _method_id(mid), _bci(bci), _version(version), _name(name), _mirror(mirror) {}
2261 };
2262 
2263 class BacktraceIterator : public StackObj {
2264   int _index;
2265   objArrayHandle  _result;
2266   objArrayHandle  _mirrors;
2267   typeArrayHandle _methods;
2268   typeArrayHandle _bcis;
2269   typeArrayHandle _names;
2270 
</pre>
<hr />
<pre>
2713 
2714   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2715   assert(holder != NULL, &quot;first element should be non-null&quot;);
2716   Method* m = holder-&gt;method_with_orig_idnum(bte._method_id, bte._version);
2717 
2718   // Original version is no longer available.
2719   if (m == NULL || !version_matches(m, bte._version)) {
2720     return false;
2721   }
2722 
2723   *method = m;
2724   *bci = bte._bci;
2725   return true;
2726 }
2727 
2728 oop java_lang_StackTraceElement::create(const methodHandle&amp; method, int bci, TRAPS) {
2729   // Allocate java.lang.StackTraceElement instance
2730   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
2731   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
2732   if (k-&gt;should_be_initialized()) {
<span class="line-modified">2733     k-&gt;initialize(CHECK_NULL);</span>
2734   }
2735 
<span class="line-modified">2736   Handle element = k-&gt;allocate_instance_handle(CHECK_NULL);</span>
2737 
2738   int version = method-&gt;constants()-&gt;version();
<span class="line-modified">2739   fill_in(element, method-&gt;method_holder(), method, version, bci, method-&gt;name(), CHECK_NULL);</span>
2740   return element();
2741 }
2742 
2743 void java_lang_StackTraceElement::fill_in(Handle element,
2744                                           InstanceKlass* holder, const methodHandle&amp; method,
2745                                           int version, int bci, Symbol* name, TRAPS) {
2746   assert(element-&gt;is_a(SystemDictionary::StackTraceElement_klass()), &quot;sanity check&quot;);
2747 
2748   ResourceMark rm(THREAD);
2749   HandleMark hm(THREAD);
2750 
2751   // Fill in class name
2752   Handle java_class(THREAD, holder-&gt;java_mirror());
2753   oop classname = java_lang_Class::name(java_class, CHECK);
2754   java_lang_StackTraceElement::set_declaringClass(element(), classname);
2755   java_lang_StackTraceElement::set_declaringClassObject(element(), java_class());
2756 
2757   oop loader = holder-&gt;class_loader();
2758   if (loader != NULL) {
2759     oop loader_name = java_lang_ClassLoader::name(loader);
</pre>
<hr />
<pre>
3465 }
3466 
3467 #define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \
3468   macro(_base_offset, k, &quot;base&quot;, object_signature, false)
3469 
3470 void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
3471   InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
3472   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3473 }
3474 
3475 #if INCLUDE_CDS
3476 void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {
3477   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3478 }
3479 #endif
3480 
3481 oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
3482   Klass* k = SystemDictionary::box_klass(type);
3483   if (k == NULL)  return NULL;
3484   InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">3485   if (!ik-&gt;is_initialized())  ik-&gt;initialize(CHECK_NULL);</span>
3486   return ik-&gt;allocate_instance(THREAD);
3487 }
3488 
3489 
3490 oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
<span class="line-modified">3491   oop box = initialize_and_allocate(type, CHECK_NULL);</span>
3492   if (box == NULL)  return NULL;
3493   switch (type) {
3494     case T_BOOLEAN:
3495       box-&gt;bool_field_put(value_offset, value-&gt;z);
3496       break;
3497     case T_CHAR:
3498       box-&gt;char_field_put(value_offset, value-&gt;c);
3499       break;
3500     case T_FLOAT:
3501       box-&gt;float_field_put(value_offset, value-&gt;f);
3502       break;
3503     case T_DOUBLE:
3504       box-&gt;double_field_put(long_value_offset, value-&gt;d);
3505       break;
3506     case T_BYTE:
3507       box-&gt;byte_field_put(value_offset, value-&gt;b);
3508       break;
3509     case T_SHORT:
3510       box-&gt;short_field_put(value_offset, value-&gt;s);
3511       break;
</pre>
<hr />
<pre>
4102   macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
4103   macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
4104   macro(_isAuthorized_offset,      k, &quot;isAuthorized&quot;, bool_signature, false)
4105 
4106 void java_security_AccessControlContext::compute_offsets() {
4107   assert(_isPrivileged_offset == 0, &quot;offsets should be initialized only once&quot;);
4108   InstanceKlass* k = SystemDictionary::AccessControlContext_klass();
4109   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4110 }
4111 
4112 #if INCLUDE_CDS
4113 void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {
4114   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4115 }
4116 #endif
4117 
4118 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
4119   assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
4120   assert(_isAuthorized_offset != -1, &quot;offsets should have been initialized&quot;);
4121   // Ensure klass is initialized
<span class="line-modified">4122   SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_NULL);</span>
4123   // Allocate result
<span class="line-modified">4124   oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_NULL);</span>
4125   // Fill in values
4126   result-&gt;obj_field_put(_context_offset, context());
4127   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
4128   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
4129   // whitelist AccessControlContexts created by the JVM
4130   result-&gt;bool_field_put(_isAuthorized_offset, true);
4131   return result;
4132 }
4133 
4134 
4135 // Support for java_lang_ClassLoader
4136 
4137 bool java_lang_ClassLoader::offsets_computed = false;
4138 int  java_lang_ClassLoader::_loader_data_offset = -1;
4139 int  java_lang_ClassLoader::parallelCapable_offset = -1;
4140 int  java_lang_ClassLoader::name_offset = -1;
4141 int  java_lang_ClassLoader::nameAndId_offset = -1;
4142 int  java_lang_ClassLoader::unnamedModule_offset = -1;
4143 
4144 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
</pre>
<hr />
<pre>
4918 // Invoked before SystemDictionary::initialize, so pre-loaded classes
4919 // are not available to determine the offset_of_static_fields.
4920 void JavaClasses::compute_hard_coded_offsets() {
4921 
4922   // java_lang_boxing_object
4923   java_lang_boxing_object::value_offset      = member_offset(java_lang_boxing_object::hc_value_offset);
4924   java_lang_boxing_object::long_value_offset = align_up(member_offset(java_lang_boxing_object::hc_value_offset), BytesPerLong);
4925 
4926   // java_lang_ref_Reference
4927   java_lang_ref_Reference::referent_offset    = member_offset(java_lang_ref_Reference::hc_referent_offset);
4928   java_lang_ref_Reference::queue_offset       = member_offset(java_lang_ref_Reference::hc_queue_offset);
4929   java_lang_ref_Reference::next_offset        = member_offset(java_lang_ref_Reference::hc_next_offset);
4930   java_lang_ref_Reference::discovered_offset  = member_offset(java_lang_ref_Reference::hc_discovered_offset);
4931 }
4932 
4933 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4934 
4935 // Compute non-hard-coded field offsets of all the classes in this file
4936 void JavaClasses::compute_offsets() {
4937   if (UseSharedSpaces) {
<span class="line-modified">4938     JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;</span>
<span class="line-modified">4939                                                          JvmtiExport::has_early_class_hook_env()),</span>
<span class="line-modified">4940                       &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));</span>
4941     // None of the classes used by the rest of this function can be replaced by
4942     // JMVTI ClassFileLoadHook.
4943     // We are safe to use the archived offsets, which have already been restored
4944     // by JavaClasses::serialize_offsets, without computing the offsets again.
4945     return;
4946   }
4947 
4948   // We have already called the compute_offsets() of the
4949   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String and java_lang_Class)
4950   // earlier inside SystemDictionary::resolve_well_known_classes()
4951   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
4952 }
4953 
4954 #if INCLUDE_CDS
4955 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4956 
4957 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4958   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4959 }
4960 #endif
</pre>
</td>
</tr>
</table>
<center><a href="classLoaderExt.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klassFactory.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
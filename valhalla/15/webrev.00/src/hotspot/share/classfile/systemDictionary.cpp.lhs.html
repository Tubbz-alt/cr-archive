<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
  33 #include &quot;classfile/classLoaderExt.hpp&quot;
  34 #include &quot;classfile/dictionary.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/klassFactory.hpp&quot;
  37 #include &quot;classfile/loaderConstraints.hpp&quot;
  38 #include &quot;classfile/packageEntry.hpp&quot;
  39 #include &quot;classfile/placeholders.hpp&quot;
  40 #include &quot;classfile/protectionDomainCache.hpp&quot;
  41 #include &quot;classfile/resolutionErrors.hpp&quot;
  42 #include &quot;classfile/stringTable.hpp&quot;
  43 #include &quot;classfile/symbolTable.hpp&quot;
  44 #include &quot;classfile/systemDictionary.hpp&quot;
  45 #include &quot;classfile/vmSymbols.hpp&quot;
  46 #include &quot;code/codeCache.hpp&quot;
  47 #include &quot;compiler/compileBroker.hpp&quot;
  48 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  49 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
  50 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  51 #include &quot;interpreter/bytecodeStream.hpp&quot;
  52 #include &quot;interpreter/interpreter.hpp&quot;
  53 #include &quot;jfr/jfrEvents.hpp&quot;
  54 #include &quot;logging/log.hpp&quot;
  55 #include &quot;logging/logStream.hpp&quot;
  56 #include &quot;memory/filemap.hpp&quot;
  57 #include &quot;memory/heapShared.hpp&quot;
  58 #include &quot;memory/metaspaceClosure.hpp&quot;
  59 #include &quot;memory/oopFactory.hpp&quot;
  60 #include &quot;memory/resourceArea.hpp&quot;
  61 #include &quot;memory/universe.hpp&quot;
  62 #include &quot;oops/access.inline.hpp&quot;
  63 #include &quot;oops/fieldStreams.inline.hpp&quot;
  64 #include &quot;oops/instanceKlass.hpp&quot;
  65 #include &quot;oops/instanceRefKlass.hpp&quot;
  66 #include &quot;oops/klass.inline.hpp&quot;
  67 #include &quot;oops/method.inline.hpp&quot;
  68 #include &quot;oops/methodData.hpp&quot;
  69 #include &quot;oops/objArrayKlass.hpp&quot;
  70 #include &quot;oops/objArrayOop.inline.hpp&quot;
  71 #include &quot;oops/oop.inline.hpp&quot;
  72 #include &quot;oops/symbol.hpp&quot;
  73 #include &quot;oops/typeArrayKlass.hpp&quot;
  74 #include &quot;oops/valueKlass.hpp&quot;
  75 #include &quot;prims/jvmtiExport.hpp&quot;
  76 #include &quot;prims/methodHandles.hpp&quot;
  77 #include &quot;runtime/arguments.hpp&quot;
  78 #include &quot;runtime/biasedLocking.hpp&quot;
  79 #include &quot;runtime/handles.inline.hpp&quot;
  80 #include &quot;runtime/java.hpp&quot;
  81 #include &quot;runtime/javaCalls.hpp&quot;
  82 #include &quot;runtime/mutexLocker.hpp&quot;
  83 #include &quot;runtime/os.hpp&quot;
  84 #include &quot;runtime/sharedRuntime.hpp&quot;
  85 #include &quot;runtime/signature.hpp&quot;
  86 #include &quot;services/classLoadingService.hpp&quot;
  87 #include &quot;services/diagnosticCommand.hpp&quot;
  88 #include &quot;services/threadService.hpp&quot;
  89 #include &quot;utilities/macros.hpp&quot;
  90 #if INCLUDE_CDS
  91 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  92 #endif
  93 #if INCLUDE_JFR
  94 #include &quot;jfr/jfr.hpp&quot;
  95 #endif
  96 
  97 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  98 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
  99 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
 100 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
 101 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
 102 
 103 oop         SystemDictionary::_system_loader_lock_obj     =  NULL;
 104 
 105 InstanceKlass*      SystemDictionary::_well_known_klasses[SystemDictionary::WKID_LIMIT]
 106                                                           =  { NULL /*, NULL...*/ };
 107 
 108 InstanceKlass*      SystemDictionary::_box_klasses[T_VOID+1]      =  { NULL /*, NULL...*/ };
 109 
 110 oop         SystemDictionary::_java_system_loader         =  NULL;
 111 oop         SystemDictionary::_java_platform_loader       =  NULL;
 112 
 113 // Default ProtectionDomainCacheSize value
 114 
 115 const int defaultProtectionDomainCacheSize = 1009;
 116 
 117 // ----------------------------------------------------------------------------
 118 // Java-level SystemLoader and PlatformLoader
 119 
 120 oop SystemDictionary::java_system_loader() {
 121   return _java_system_loader;
 122 }
 123 
 124 oop SystemDictionary::java_platform_loader() {
 125   return _java_platform_loader;
 126 }
 127 
 128 void SystemDictionary::compute_java_loaders(TRAPS) {
 129   JavaValue result(T_OBJECT);
 130   InstanceKlass* class_loader_klass = SystemDictionary::ClassLoader_klass();
 131   JavaCalls::call_static(&amp;result,
 132                          class_loader_klass,
 133                          vmSymbols::getSystemClassLoader_name(),
 134                          vmSymbols::void_classloader_signature(),
 135                          CHECK);
 136 
 137   _java_system_loader = (oop)result.get_jobject();
 138 
 139   JavaCalls::call_static(&amp;result,
 140                          class_loader_klass,
 141                          vmSymbols::getPlatformClassLoader_name(),
 142                          vmSymbols::void_classloader_signature(),
 143                          CHECK);
 144 
 145   _java_platform_loader = (oop)result.get_jobject();
 146 }
 147 
 148 ClassLoaderData* SystemDictionary::register_loader(Handle class_loader) {
<a name="1" id="anc1"></a><span class="line-modified"> 149   if (class_loader() == NULL) return ClassLoaderData::the_null_class_loader_data();</span>
 150   return ClassLoaderDataGraph::find_or_create(class_loader);
 151 }
 152 
 153 // ----------------------------------------------------------------------------
 154 // Parallel class loading check
 155 
 156 bool SystemDictionary::is_parallelCapable(Handle class_loader) {
 157   if (class_loader.is_null()) return true;
 158   if (AlwaysLockClassLoader) return false;
 159   return java_lang_ClassLoader::parallelCapable(class_loader());
 160 }
 161 // ----------------------------------------------------------------------------
 162 // ParallelDefineClass flag does not apply to bootclass loader
 163 bool SystemDictionary::is_parallelDefine(Handle class_loader) {
 164    if (class_loader.is_null()) return false;
 165    if (AllowParallelDefineClass &amp;&amp; java_lang_ClassLoader::parallelCapable(class_loader())) {
 166      return true;
 167    }
 168    return false;
 169 }
 170 
 171 // Returns true if the passed class loader is the builtin application class loader
 172 // or a custom system class loader. A customer system class loader can be
 173 // specified via -Djava.system.class.loader.
 174 bool SystemDictionary::is_system_class_loader(oop class_loader) {
 175   if (class_loader == NULL) {
 176     return false;
 177   }
 178   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass() ||
 179          class_loader == _java_system_loader);
 180 }
 181 
 182 // Returns true if the passed class loader is the platform class loader.
 183 bool SystemDictionary::is_platform_class_loader(oop class_loader) {
 184   if (class_loader == NULL) {
 185     return false;
 186   }
 187   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_PlatformClassLoader_klass());
 188 }
 189 
 190 // ----------------------------------------------------------------------------
 191 // Resolving of classes
 192 
 193 // Forwards to resolve_or_null
 194 
 195 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain, bool throw_error, TRAPS) {
 196   Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);
 197   if (HAS_PENDING_EXCEPTION || klass == NULL) {
 198     // can return a null klass
 199     klass = handle_resolution_exception(class_name, throw_error, klass, THREAD);
 200   }
 201   return klass;
 202 }
 203 
 204 Klass* SystemDictionary::handle_resolution_exception(Symbol* class_name,
 205                                                      bool throw_error,
 206                                                      Klass* klass, TRAPS) {
 207   if (HAS_PENDING_EXCEPTION) {
 208     // If we have a pending exception we forward it to the caller, unless throw_error is true,
 209     // in which case we have to check whether the pending exception is a ClassNotFoundException,
 210     // and if so convert it to a NoClassDefFoundError
 211     // And chain the original ClassNotFoundException
 212     if (throw_error &amp;&amp; PENDING_EXCEPTION-&gt;is_a(SystemDictionary::ClassNotFoundException_klass())) {
 213       ResourceMark rm(THREAD);
 214       assert(klass == NULL, &quot;Should not have result with exception pending&quot;);
 215       Handle e(THREAD, PENDING_EXCEPTION);
 216       CLEAR_PENDING_EXCEPTION;
 217       THROW_MSG_CAUSE_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name-&gt;as_C_string(), e);
 218     } else {
 219       return NULL;
 220     }
 221   }
 222   // Class not found, throw appropriate error or exception depending on value of throw_error
 223   if (klass == NULL) {
 224     ResourceMark rm(THREAD);
 225     if (throw_error) {
 226       THROW_MSG_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name-&gt;as_C_string());
 227     } else {
 228       THROW_MSG_NULL(vmSymbols::java_lang_ClassNotFoundException(), class_name-&gt;as_C_string());
 229     }
 230   }
 231   return klass;
 232 }
 233 
 234 
 235 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name,
 236                                            bool throw_error, TRAPS)
 237 {
 238   return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);
 239 }
 240 
 241 
 242 // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
 243 
 244 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
 245   if (Signature::is_array(class_name)) {
 246     return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
 247   } else {
 248     return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
 249   }
 250 }
 251 
 252 // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
 253 InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
 254                                                                        Handle class_loader,
 255                                                                        Handle protection_domain,
 256                                                                        TRAPS) {
 257   assert(class_name != NULL &amp;&amp; !Signature::is_array(class_name), &quot;must be&quot;);
 258   if (Signature::has_envelope(class_name)) {
 259     ResourceMark rm(THREAD);
 260     // Ignore wrapping L and ;. (and Q and ; for value types);
 261     TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
 262                                                  class_name-&gt;utf8_length() - 2);
 263     return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
 264   } else {
 265     return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
 266   }
 267 }
 268 
 269 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {
 270   return resolve_or_null(class_name, Handle(), Handle(), THREAD);
 271 }
 272 
 273 // Forwards to resolve_instance_class_or_null
 274 
 275 Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
 276                                                      Handle class_loader,
 277                                                      Handle protection_domain,
 278                                                      TRAPS) {
 279   assert(Signature::is_array(class_name), &quot;must be array&quot;);
 280   ResourceMark rm(THREAD);
 281   SignatureStream ss(class_name, false);
 282   int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
 283   Klass* k = NULL;
 284   BasicType t = ss.type();
 285   if (ss.has_envelope()) {
 286     Symbol* obj_class = ss.as_symbol();
 287     k = SystemDictionary::resolve_instance_class_or_null(obj_class,
 288                                                          class_loader,
 289                                                          protection_domain,
 290                                                          CHECK_NULL);
 291     if (k != NULL) {
 292       k = k-&gt;array_klass(ArrayStorageProperties::for_signature(class_name), ndims, CHECK_NULL);
 293     }
 294   } else {
 295     k = Universe::typeArrayKlassObj(t);
 296     k = TypeArrayKlass::cast(k)-&gt;array_klass(ArrayStorageProperties::empty, ndims, CHECK_NULL);
 297   }
 298   return k;
 299 }
 300 
 301 // Must be called for any super-class or super-interface resolution
 302 // during class definition to allow class circularity checking
 303 // super-interface callers:
 304 //    parse_interfaces - for defineClass &amp; jvmtiRedefineClasses
 305 // super-class callers:
 306 //   ClassFileParser - for defineClass &amp; jvmtiRedefineClasses
 307 //   load_shared_class - while loading a class from shared archive
 308 //   resolve_instance_class_or_null:
 309 //     via: handle_parallel_super_load
 310 //      when resolving a class that has an existing placeholder with
 311 //      a saved superclass [i.e. a defineClass is currently in progress]
 312 //      if another thread is trying to resolve the class, it must do
 313 //      super-class checks on its own thread to catch class circularity
 314 // This last call is critical in class circularity checking for cases
 315 // where classloading is delegated to different threads and the
 316 // classloader lock is released.
 317 // Take the case: Base-&gt;Super-&gt;Base
 318 //   1. If thread T1 tries to do a defineClass of class Base
 319 //    resolve_super_or_fail creates placeholder: T1, Base (super Super)
 320 //   2. resolve_instance_class_or_null does not find SD or placeholder for Super
 321 //    so it tries to load Super
 322 //   3. If we load the class internally, or user classloader uses same thread
 323 //      loadClassFromxxx or defineClass via parseClassFile Super ...
 324 //      3.1 resolve_super_or_fail creates placeholder: T1, Super (super Base)
 325 //      3.3 resolve_instance_class_or_null Base, finds placeholder for Base
 326 //      3.4 calls resolve_super_or_fail Base
 327 //      3.5 finds T1,Base -&gt; throws class circularity
 328 //OR 4. If T2 tries to resolve Super via defineClass Super ...
 329 //      4.1 resolve_super_or_fail creates placeholder: T2, Super (super Base)
 330 //      4.2 resolve_instance_class_or_null Base, finds placeholder for Base (super Super)
 331 //      4.3 calls resolve_super_or_fail Super in parallel on own thread T2
 332 //      4.4 finds T2, Super -&gt; throws class circularity
 333 // Must be called, even if superclass is null, since this is
 334 // where the placeholder entry is created which claims this
 335 // thread is loading this class/classloader.
 336 // Be careful when modifying this code: once you have run
 337 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_SUPER),
 338 // you need to find_and_remove it before returning.
 339 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 340 InstanceKlass* SystemDictionary::resolve_super_or_fail(Symbol* child_name,
 341                                                        Symbol* super_name,
 342                                                        Handle class_loader,
 343                                                        Handle protection_domain,
 344                                                        bool is_superclass,
 345                                                        TRAPS) {
 346   assert(!Signature::is_array(super_name), &quot;invalid super class name&quot;);
 347 #if INCLUDE_CDS
 348   if (DumpSharedSpaces) {
 349     // Special processing for handling UNREGISTERED shared classes.
 350     InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(child_name,
 351         super_name, class_loader, protection_domain, is_superclass, CHECK_NULL);
 352     if (k) {
 353       return k;
 354     }
 355   }
 356 #endif // INCLUDE_CDS
 357 
 358   // Double-check, if child class is already loaded, just return super-class,interface
 359   // Don&#39;t add a placedholder if already loaded, i.e. already in appropriate class loader
 360   // dictionary.
 361   // Make sure there&#39;s a placeholder for the *child* before resolving.
 362   // Used as a claim that this thread is currently loading superclass/classloader
 363   // Used here for ClassCircularity checks and also for heap verification
 364   // (every InstanceKlass needs to be in its class loader dictionary or have a placeholder).
 365   // Must check ClassCircularity before checking if super class is already loaded.
 366   //
 367   // We might not already have a placeholder if this child_name was
 368   // first seen via resolve_from_stream (jni_DefineClass or JVM_DefineClass);
 369   // the name of the class might not be known until the stream is actually
 370   // parsed.
 371   // Bugs 4643874, 4715493
 372 
 373   ClassLoaderData* loader_data = class_loader_data(class_loader);
 374   Dictionary* dictionary = loader_data-&gt;dictionary();
 375   unsigned int d_hash = dictionary-&gt;compute_hash(child_name);
 376   unsigned int p_hash = placeholders()-&gt;compute_hash(child_name);
 377   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 378   // can&#39;t throw error holding a lock
 379   bool child_already_loaded = false;
 380   bool throw_circularity_error = false;
 381   {
 382     MutexLocker mu(THREAD, SystemDictionary_lock);
 383     InstanceKlass* childk = find_class(d_hash, child_name, dictionary);
 384     InstanceKlass* quicksuperk;
 385     // to support // loading: if child done loading, just return superclass
 386     // if super_name, &amp; class_loader don&#39;t match:
 387     // if initial define, SD update will give LinkageError
 388     // if redefine: compare_class_versions will give HIERARCHY_CHANGED
 389     // so we don&#39;t throw an exception here.
 390     // see: nsk redefclass014 &amp; java.lang.instrument Instrument032
 391     if ((childk != NULL ) &amp;&amp; (is_superclass) &amp;&amp;
 392         ((quicksuperk = childk-&gt;java_super()) != NULL) &amp;&amp;
 393          ((quicksuperk-&gt;name() == super_name) &amp;&amp;
 394             (quicksuperk-&gt;class_loader() == class_loader()))) {
 395            return quicksuperk;
 396     } else {
 397       PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, child_name, loader_data);
 398       if (probe &amp;&amp; probe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_SUPER)) {
 399           throw_circularity_error = true;
 400       }
 401     }
 402     if (!throw_circularity_error) {
 403       // Be careful not to exit resolve_super
 404       PlaceholderEntry* newprobe = placeholders()-&gt;find_and_add(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, super_name, THREAD);
 405     }
 406   }
 407   if (throw_circularity_error) {
 408       ResourceMark rm(THREAD);
 409       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), child_name-&gt;as_C_string());
 410   }
 411 
 412 // java.lang.Object should have been found above
 413   assert(super_name != NULL, &quot;null super class for resolving&quot;);
 414   // Resolve the super class or interface, check results on return
 415   InstanceKlass* superk =
 416     SystemDictionary::resolve_instance_class_or_null_helper(super_name,
 417                                                             class_loader,
 418                                                             protection_domain,
 419                                                             THREAD);
 420 
 421   // Clean up of placeholders moved so that each classloadAction registrar self-cleans up
 422   // It is no longer necessary to keep the placeholder table alive until update_dictionary
 423   // or error. GC used to walk the placeholder table as strong roots.
 424   // The instanceKlass is kept alive because the class loader is on the stack,
 425   // which keeps the loader_data alive, as well as all instanceKlasses in
 426   // the loader_data. parseClassFile adds the instanceKlass to loader_data.
 427   {
 428     MutexLocker mu(THREAD, SystemDictionary_lock);
 429     placeholders()-&gt;find_and_remove(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);
 430     SystemDictionary_lock-&gt;notify_all();
 431   }
 432   if (HAS_PENDING_EXCEPTION || superk == NULL) {
 433     // can null superk
 434     Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);
 435     assert(k == NULL || k == superk, &quot;must be&quot;);
 436     if (k == NULL) {
 437       superk = NULL;
 438     }
 439   }
 440 
 441   return superk;
 442 }
 443 
 444 Klass* SystemDictionary::resolve_flattenable_field_or_fail(AllFieldStream* fs,
 445                                                            Handle class_loader,
 446                                                            Handle protection_domain,
 447                                                            bool throw_error,
 448                                                            TRAPS) {
 449   Symbol* class_name = fs-&gt;signature()-&gt;fundamental_name(THREAD);
 450   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 451   ClassLoaderData* loader_data = class_loader_data(class_loader);
 452   unsigned int p_hash = placeholders()-&gt;compute_hash(class_name);
 453   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 454   bool throw_circularity_error = false;
 455   PlaceholderEntry* oldprobe;
 456 
 457   {
 458     MutexLocker mu(THREAD, SystemDictionary_lock);
 459     oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, class_name, loader_data);
 460     if (oldprobe != NULL &amp;&amp;
 461       oldprobe-&gt;check_seen_thread(THREAD, PlaceholderTable::FLATTENABLE_FIELD)) {
 462       throw_circularity_error = true;
 463 
 464     } else {
 465       placeholders()-&gt;find_and_add(p_index, p_hash, class_name, loader_data,
 466                                    PlaceholderTable::FLATTENABLE_FIELD, NULL, THREAD);
 467     }
 468   }
 469 
 470   Klass* klass = NULL;
 471   if (!throw_circularity_error) {
 472     klass = SystemDictionary::resolve_or_fail(class_name, class_loader,
 473                                                protection_domain, true, THREAD);
 474   } else {
 475     ResourceMark rm(THREAD);
 476     THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), class_name-&gt;as_C_string());
 477   }
 478 
 479   {
 480     MutexLocker mu(THREAD, SystemDictionary_lock);
 481     placeholders()-&gt;find_and_remove(p_index, p_hash, class_name, loader_data,
 482                                     PlaceholderTable::FLATTENABLE_FIELD, THREAD);
 483   }
 484 
 485   class_name-&gt;decrement_refcount();
 486   return klass;
 487 }
 488 
 489 void SystemDictionary::validate_protection_domain(InstanceKlass* klass,
 490                                                   Handle class_loader,
 491                                                   Handle protection_domain,
 492                                                   TRAPS) {
 493   // Now we have to call back to java to check if the initating class has access
 494   JavaValue result(T_VOID);
 495   LogTarget(Debug, protectiondomain) lt;
 496   if (lt.is_enabled()) {
 497     ResourceMark rm(THREAD);
 498     // Print out trace information
 499     LogStream ls(lt);
 500     ls.print_cr(&quot;Checking package access&quot;);
 501     if (class_loader() != NULL) {
 502       ls.print(&quot;class loader: &quot;);
 503       class_loader()-&gt;print_value_on(&amp;ls);
 504     } else {
 505       ls.print_cr(&quot;class loader: NULL&quot;);
 506     }
 507     if (protection_domain() != NULL) {
 508       ls.print(&quot; protection domain: &quot;);
 509       protection_domain()-&gt;print_value_on(&amp;ls);
 510     } else {
 511       ls.print_cr(&quot; protection domain: NULL&quot;);
 512     }
 513     ls.print(&quot; loading: &quot;); klass-&gt;print_value_on(&amp;ls);
 514     ls.cr();
 515   }
 516 
 517   // This handle and the class_loader handle passed in keeps this class from
 518   // being unloaded through several GC points.
 519   // The class_loader handle passed in is the initiating loader.
 520   Handle mirror(THREAD, klass-&gt;java_mirror());
 521 
 522   InstanceKlass* system_loader = SystemDictionary::ClassLoader_klass();
 523   JavaCalls::call_special(&amp;result,
 524                          class_loader,
 525                          system_loader,
 526                          vmSymbols::checkPackageAccess_name(),
 527                          vmSymbols::class_protectiondomain_signature(),
 528                          mirror,
 529                          protection_domain,
 530                          THREAD);
 531 
 532   if (HAS_PENDING_EXCEPTION) {
 533     log_debug(protectiondomain)(&quot;DENIED !!!!!!!!!!!!!!!!!!!!!&quot;);
 534   } else {
 535    log_debug(protectiondomain)(&quot;granted&quot;);
 536   }
 537 
 538   if (HAS_PENDING_EXCEPTION) return;
 539 
 540   // If no exception has been thrown, we have validated the protection domain
 541   // Insert the protection domain of the initiating class into the set.
 542   {
 543     ClassLoaderData* loader_data = class_loader_data(class_loader);
 544     Dictionary* dictionary = loader_data-&gt;dictionary();
 545 
 546     Symbol*  kn = klass-&gt;name();
 547     unsigned int d_hash = dictionary-&gt;compute_hash(kn);
 548 
 549     MutexLocker mu(THREAD, SystemDictionary_lock);
 550     int d_index = dictionary-&gt;hash_to_index(d_hash);
 551     dictionary-&gt;add_protection_domain(d_index, d_hash, klass,
 552                                       protection_domain, THREAD);
 553   }
 554 }
 555 
 556 // We only get here if this thread finds that another thread
 557 // has already claimed the placeholder token for the current operation,
 558 // but that other thread either never owned or gave up the
 559 // object lock
 560 // Waits on SystemDictionary_lock to indicate placeholder table updated
 561 // On return, caller must recheck placeholder table state
 562 //
 563 // We only get here if
 564 //  1) custom classLoader, i.e. not bootstrap classloader
 565 //  2) custom classLoader has broken the class loader objectLock
 566 //     so another thread got here in parallel
 567 //
 568 // lockObject must be held.
 569 // Complicated dance due to lock ordering:
 570 // Must first release the classloader object lock to
 571 // allow initial definer to complete the class definition
 572 // and to avoid deadlock
 573 // Reclaim classloader lock object with same original recursion count
 574 // Must release SystemDictionary_lock after notify, since
 575 // class loader lock must be claimed before SystemDictionary_lock
 576 // to prevent deadlocks
 577 //
 578 // The notify allows applications that did an untimed wait() on
 579 // the classloader object lock to not hang.
 580 void SystemDictionary::double_lock_wait(Handle lockObject, TRAPS) {
 581   assert_lock_strong(SystemDictionary_lock);
 582 
 583   bool calledholdinglock
 584       = ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, lockObject);
 585   assert(calledholdinglock,&quot;must hold lock for notify&quot;);
 586   assert((lockObject() != _system_loader_lock_obj &amp;&amp; !is_parallelCapable(lockObject)), &quot;unexpected double_lock_wait&quot;);
 587   ObjectSynchronizer::notifyall(lockObject, THREAD);
 588   intx recursions =  ObjectSynchronizer::complete_exit(lockObject, THREAD);
 589   SystemDictionary_lock-&gt;wait();
 590   SystemDictionary_lock-&gt;unlock();
 591   ObjectSynchronizer::reenter(lockObject, recursions, THREAD);
 592   SystemDictionary_lock-&gt;lock();
 593 }
 594 
 595 // If the class in is in the placeholder table, class loading is in progress
 596 // For cases where the application changes threads to load classes, it
 597 // is critical to ClassCircularity detection that we try loading
 598 // the superclass on the same thread internally, so we do parallel
 599 // super class loading here.
 600 // This also is critical in cases where the original thread gets stalled
 601 // even in non-circularity situations.
 602 // Note: must call resolve_super_or_fail even if null super -
 603 // to force placeholder entry creation for this class for circularity detection
 604 // Caller must check for pending exception
 605 // Returns non-null Klass* if other thread has completed load
 606 // and we are done,
 607 // If return null Klass* and no pending exception, the caller must load the class
 608 InstanceKlass* SystemDictionary::handle_parallel_super_load(
 609     Symbol* name, Symbol* superclassname, Handle class_loader,
 610     Handle protection_domain, Handle lockObject, TRAPS) {
 611 
 612   ClassLoaderData* loader_data = class_loader_data(class_loader);
 613   Dictionary* dictionary = loader_data-&gt;dictionary();
 614   unsigned int d_hash = dictionary-&gt;compute_hash(name);
 615   unsigned int p_hash = placeholders()-&gt;compute_hash(name);
 616   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 617 
 618   // superk is not used, resolve_super called for circularity check only
 619   // This code is reached in two situations. One if this thread
 620   // is loading the same class twice (e.g. ClassCircularity, or
 621   // java.lang.instrument).
 622   // The second is if another thread started the resolve_super first
 623   // and has not yet finished.
 624   // In both cases the original caller will clean up the placeholder
 625   // entry on error.
 626   Klass* superk = SystemDictionary::resolve_super_or_fail(name,
 627                                                           superclassname,
 628                                                           class_loader,
 629                                                           protection_domain,
 630                                                           true,
 631                                                           CHECK_NULL);
 632 
 633   // parallelCapable class loaders do NOT wait for parallel superclass loads to complete
 634   // Serial class loaders and bootstrap classloader do wait for superclass loads
 635  if (!class_loader.is_null() &amp;&amp; is_parallelCapable(class_loader)) {
 636     MutexLocker mu(THREAD, SystemDictionary_lock);
 637     // Check if classloading completed while we were loading superclass or waiting
 638     return find_class(d_hash, name, dictionary);
 639   }
 640 
 641   // must loop to both handle other placeholder updates
 642   // and spurious notifications
 643   bool super_load_in_progress = true;
 644   PlaceholderEntry* placeholder;
 645   while (super_load_in_progress) {
 646     MutexLocker mu(THREAD, SystemDictionary_lock);
 647     // Check if classloading completed while we were loading superclass or waiting
 648     InstanceKlass* check = find_class(d_hash, name, dictionary);
 649     if (check != NULL) {
 650       // Klass is already loaded, so just return it
 651       return check;
 652     } else {
 653       placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 654       if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress() ){
 655         // We only get here if the application has released the
 656         // classloader lock when another thread was in the middle of loading a
 657         // superclass/superinterface for this class, and now
 658         // this thread is also trying to load this class.
 659         // To minimize surprises, the first thread that started to
 660         // load a class should be the one to complete the loading
 661         // with the classfile it initially expected.
 662         // This logic has the current thread wait once it has done
 663         // all the superclass/superinterface loading it can, until
 664         // the original thread completes the class loading or fails
 665         // If it completes we will use the resulting InstanceKlass
 666         // which we will find below in the systemDictionary.
 667         // We also get here for parallel bootstrap classloader
 668         if (class_loader.is_null()) {
 669           SystemDictionary_lock-&gt;wait();
 670         } else {
 671           double_lock_wait(lockObject, THREAD);
 672         }
 673       } else {
 674         // If not in SD and not in PH, other thread&#39;s load must have failed
 675         super_load_in_progress = false;
 676       }
 677     }
 678   }
 679   return NULL;
 680 }
 681 
 682 static void post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld) {
 683   assert(event != NULL, &quot;invariant&quot;);
 684   assert(k != NULL, &quot;invariant&quot;);
 685   assert(event-&gt;should_commit(), &quot;invariant&quot;);
 686   event-&gt;set_loadedClass(k);
 687   event-&gt;set_definingClassLoader(k-&gt;class_loader_data());
 688   event-&gt;set_initiatingClassLoader(init_cld);
 689   event-&gt;commit();
 690 }
 691 
 692 
 693 // Be careful when modifying this code: once you have run
 694 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_INSTANCE),
 695 // you need to find_and_remove it before returning.
 696 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 697 //
 698 // name must be in the form of &quot;java/lang/Object&quot; -- cannot be &quot;Ljava/lang/Object;&quot;
 699 InstanceKlass* SystemDictionary::resolve_instance_class_or_null(Symbol* name,
 700                                                                 Handle class_loader,
 701                                                                 Handle protection_domain,
 702                                                                 TRAPS) {
 703   assert(name != NULL &amp;&amp; !Signature::is_array(name) &amp;&amp;
 704          !Signature::has_envelope(name), &quot;invalid class name&quot;);
 705 
 706   EventClassLoad class_load_start_event;
 707 
 708   HandleMark hm(THREAD);
 709 
 710   // Fix for 4474172; see evaluation for more details
 711   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 712   ClassLoaderData* loader_data = register_loader(class_loader);
 713   Dictionary* dictionary = loader_data-&gt;dictionary();
 714   unsigned int d_hash = dictionary-&gt;compute_hash(name);
 715 
 716   // Do lookup to see if class already exist and the protection domain
 717   // has the right access
 718   // This call uses find which checks protection domain already matches
 719   // All subsequent calls use find_class, and set has_loaded_class so that
 720   // before we return a result we call out to java to check for valid protection domain
 721   // to allow returning the Klass* and add it to the pd_set if it is valid
 722   {
 723     InstanceKlass* probe = dictionary-&gt;find(d_hash, name, protection_domain);
 724     if (probe != NULL) return probe;
 725   }
 726 
 727   // Non-bootstrap class loaders will call out to class loader and
 728   // define via jvm/jni_DefineClass which will acquire the
 729   // class loader object lock to protect against multiple threads
 730   // defining the class in parallel by accident.
 731   // This lock must be acquired here so the waiter will find
 732   // any successful result in the SystemDictionary and not attempt
 733   // the define.
 734   // ParallelCapable Classloaders and the bootstrap classloader
 735   // do not acquire lock here.
 736   bool DoObjectLock = true;
 737   if (is_parallelCapable(class_loader)) {
 738     DoObjectLock = false;
 739   }
 740 
 741   unsigned int p_hash = placeholders()-&gt;compute_hash(name);
 742   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 743 
 744   // Class is not in SystemDictionary so we have to do loading.
 745   // Make sure we are synchronized on the class loader before we proceed
 746   Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
 747   check_loader_lock_contention(lockObject, THREAD);
 748   ObjectLocker ol(lockObject, THREAD, DoObjectLock);
 749 
 750   // Check again (after locking) if class already exist in SystemDictionary
 751   bool class_has_been_loaded   = false;
 752   bool super_load_in_progress  = false;
 753   bool havesupername = false;
 754   InstanceKlass* k = NULL;
 755   PlaceholderEntry* placeholder;
 756   Symbol* superclassname = NULL;
 757 
 758   assert(THREAD-&gt;can_call_java(),
 759          &quot;can not load classes with compiler thread: class=%s, classloader=%s&quot;,
 760          name-&gt;as_C_string(),
 761          class_loader.is_null() ? &quot;null&quot; : class_loader-&gt;klass()-&gt;name()-&gt;as_C_string());
 762   {
 763     MutexLocker mu(THREAD, SystemDictionary_lock);
 764     InstanceKlass* check = find_class(d_hash, name, dictionary);
 765     if (check != NULL) {
 766       // InstanceKlass is already loaded, so just return it
 767       class_has_been_loaded = true;
 768       k = check;
 769     } else {
 770       placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 771       if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress()) {
 772          super_load_in_progress = true;
 773          if (placeholder-&gt;havesupername() == true) {
 774            superclassname = placeholder-&gt;supername();
 775            havesupername = true;
 776          }
 777       }
 778     }
 779   }
 780 
 781   // If the class is in the placeholder table, class loading is in progress
 782   if (super_load_in_progress &amp;&amp; havesupername==true) {
 783     k = handle_parallel_super_load(name,
 784                                    superclassname,
 785                                    class_loader,
 786                                    protection_domain,
 787                                    lockObject, THREAD);
 788     if (HAS_PENDING_EXCEPTION) {
 789       return NULL;
 790     }
 791     if (k != NULL) {
 792       class_has_been_loaded = true;
 793     }
 794   }
 795 
 796   bool throw_circularity_error = false;
 797   if (!class_has_been_loaded) {
 798     bool load_instance_added = false;
 799 
 800     // add placeholder entry to record loading instance class
 801     // Five cases:
 802     // All cases need to prevent modifying bootclasssearchpath
 803     // in parallel with a classload of same classname
 804     // Redefineclasses uses existence of the placeholder for the duration
 805     // of the class load to prevent concurrent redefinition of not completely
 806     // defined classes.
 807     // case 1. traditional classloaders that rely on the classloader object lock
 808     //   - no other need for LOAD_INSTANCE
 809     // case 2. traditional classloaders that break the classloader object lock
 810     //    as a deadlock workaround. Detection of this case requires that
 811     //    this check is done while holding the classloader object lock,
 812     //    and that lock is still held when calling classloader&#39;s loadClass.
 813     //    For these classloaders, we ensure that the first requestor
 814     //    completes the load and other requestors wait for completion.
 815     // case 3. Bootstrap classloader - don&#39;t own objectLocker
 816     //    This classloader supports parallelism at the classloader level,
 817     //    but only allows a single load of a class/classloader pair.
 818     //    No performance benefit and no deadlock issues.
 819     // case 4. parallelCapable user level classloaders - without objectLocker
 820     //    Allow parallel classloading of a class/classloader pair
 821 
 822     {
 823       MutexLocker mu(THREAD, SystemDictionary_lock);
 824       if (class_loader.is_null() || !is_parallelCapable(class_loader)) {
 825         PlaceholderEntry* oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 826         if (oldprobe) {
 827           // only need check_seen_thread once, not on each loop
 828           // 6341374 java/lang/Instrument with -Xcomp
 829           if (oldprobe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_INSTANCE)) {
 830             throw_circularity_error = true;
 831           } else {
 832             // case 1: traditional: should never see load_in_progress.
 833             while (!class_has_been_loaded &amp;&amp; oldprobe &amp;&amp; oldprobe-&gt;instance_load_in_progress()) {
 834 
 835               // case 3: bootstrap classloader: prevent futile classloading,
 836               // wait on first requestor
 837               if (class_loader.is_null()) {
 838                 SystemDictionary_lock-&gt;wait();
 839               } else {
 840               // case 2: traditional with broken classloader lock. wait on first
 841               // requestor.
 842                 double_lock_wait(lockObject, THREAD);
 843               }
 844               // Check if classloading completed while we were waiting
 845               InstanceKlass* check = find_class(d_hash, name, dictionary);
 846               if (check != NULL) {
 847                 // Klass is already loaded, so just return it
 848                 k = check;
 849                 class_has_been_loaded = true;
 850               }
 851               // check if other thread failed to load and cleaned up
 852               oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 853             }
 854           }
 855         }
 856       }
 857       // All cases: add LOAD_INSTANCE holding SystemDictionary_lock
 858       // case 4: parallelCapable: allow competing threads to try
 859       // LOAD_INSTANCE in parallel
 860 
 861       if (!throw_circularity_error &amp;&amp; !class_has_been_loaded) {
 862         PlaceholderEntry* newprobe = placeholders()-&gt;find_and_add(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, NULL, THREAD);
 863         load_instance_added = true;
 864         // For class loaders that do not acquire the classloader object lock,
 865         // if they did not catch another thread holding LOAD_INSTANCE,
 866         // need a check analogous to the acquire ObjectLocker/find_class
 867         // i.e. now that we hold the LOAD_INSTANCE token on loading this class/CL
 868         // one final check if the load has already completed
 869         // class loaders holding the ObjectLock shouldn&#39;t find the class here
 870         InstanceKlass* check = find_class(d_hash, name, dictionary);
 871         if (check != NULL) {
 872         // Klass is already loaded, so return it after checking/adding protection domain
 873           k = check;
 874           class_has_been_loaded = true;
 875         }
 876       }
 877     }
 878 
 879     // must throw error outside of owning lock
 880     if (throw_circularity_error) {
 881       assert(!HAS_PENDING_EXCEPTION &amp;&amp; load_instance_added == false,&quot;circularity error cleanup&quot;);
 882       ResourceMark rm(THREAD);
 883       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), name-&gt;as_C_string());
 884     }
 885 
 886     if (!class_has_been_loaded) {
 887 
 888       // Do actual loading
 889       k = load_instance_class(name, class_loader, THREAD);
 890 
 891       // If everything was OK (no exceptions, no null return value), and
 892       // class_loader is NOT the defining loader, do a little more bookkeeping.
 893       if (!HAS_PENDING_EXCEPTION &amp;&amp; k != NULL &amp;&amp;
 894         k-&gt;class_loader() != class_loader()) {
 895 
 896         check_constraints(d_hash, k, class_loader, false, THREAD);
 897 
 898         // Need to check for a PENDING_EXCEPTION again; check_constraints
 899         // can throw but we may have to remove entry from the placeholder table below.
 900         if (!HAS_PENDING_EXCEPTION) {
 901           // Record dependency for non-parent delegation.
 902           // This recording keeps the defining class loader of the klass (k) found
 903           // from being unloaded while the initiating class loader is loaded
 904           // even if the reference to the defining class loader is dropped
 905           // before references to the initiating class loader.
 906           loader_data-&gt;record_dependency(k);
 907 
 908           { // Grabbing the Compile_lock prevents systemDictionary updates
 909             // during compilations.
 910             MutexLocker mu(THREAD, Compile_lock);
 911             update_dictionary(d_hash, p_index, p_hash,
 912               k, class_loader, THREAD);
 913           }
 914 
 915           if (JvmtiExport::should_post_class_load()) {
 916             Thread *thread = THREAD;
 917             assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
 918             JvmtiExport::post_class_load((JavaThread *) thread, k);
 919           }
 920         }
 921       }
 922     } // load_instance_class
 923 
 924     if (load_instance_added == true) {
 925       // clean up placeholder entries for LOAD_INSTANCE success or error
 926       // This brackets the SystemDictionary updates for both defining
 927       // and initiating loaders
 928       MutexLocker mu(THREAD, SystemDictionary_lock);
 929       placeholders()-&gt;find_and_remove(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, THREAD);
 930       SystemDictionary_lock-&gt;notify_all();
 931     }
 932   }
 933 
 934   if (HAS_PENDING_EXCEPTION || k == NULL) {
 935     return NULL;
 936   }
 937   if (class_load_start_event.should_commit()) {
 938     post_class_load_event(&amp;class_load_start_event, k, loader_data);
 939   }
 940 #ifdef ASSERT
 941   {
 942     ClassLoaderData* loader_data = k-&gt;class_loader_data();
 943     MutexLocker mu(THREAD, SystemDictionary_lock);
 944     InstanceKlass* kk = find_class(name, loader_data);
 945     assert(kk == k, &quot;should be present in dictionary&quot;);
 946   }
 947 #endif
 948 
 949   // return if the protection domain in NULL
 950   if (protection_domain() == NULL) return k;
 951 
 952   // Check the protection domain has the right access
 953   if (dictionary-&gt;is_valid_protection_domain(d_hash, name,
 954                                              protection_domain)) {
 955     return k;
 956   }
 957 
 958   // Verify protection domain. If it fails an exception is thrown
 959   validate_protection_domain(k, class_loader, protection_domain, CHECK_NULL);
 960 
 961   return k;
 962 }
 963 
 964 
 965 // This routine does not lock the system dictionary.
 966 //
 967 // Since readers don&#39;t hold a lock, we must make sure that system
 968 // dictionary entries are only removed at a safepoint (when only one
 969 // thread is running), and are added to in a safe way (all links must
 970 // be updated in an MT-safe manner).
 971 //
 972 // Callers should be aware that an entry could be added just after
 973 // _dictionary-&gt;bucket(index) is read here, so the caller will not see
 974 // the new entry.
 975 
 976 Klass* SystemDictionary::find(Symbol* class_name,
 977                               Handle class_loader,
 978                               Handle protection_domain,
 979                               TRAPS) {
 980 
 981   // The result of this call should be consistent with the result
 982   // of the call to resolve_instance_class_or_null().
 983   // See evaluation 6790209 and 4474172 for more details.
 984   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 985   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data_or_null(class_loader());
 986 
 987   if (loader_data == NULL) {
 988     // If the ClassLoaderData has not been setup,
 989     // then the class loader has no entries in the dictionary.
 990     return NULL;
 991   }
 992 
 993   Dictionary* dictionary = loader_data-&gt;dictionary();
 994   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
 995   return dictionary-&gt;find(d_hash, class_name,
 996                           protection_domain);
 997 }
 998 
 999 
1000 // Look for a loaded instance or array klass by name.  Do not do any loading.
1001 // return NULL in case of error.
1002 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
1003                                                       Handle class_loader,
1004                                                       Handle protection_domain,
1005                                                       TRAPS) {
1006   Klass* k = NULL;
1007   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
1008 
1009   if (Signature::is_array(class_name)) {
1010     // The name refers to an array.  Parse the name.
1011     // dimension and object_key in FieldArrayInfo are assigned as a
1012     // side-effect of this call
1013     SignatureStream ss(class_name, false);
1014     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
1015     BasicType t = ss.type();
1016     if (t != T_OBJECT &amp;&amp; t != T_VALUETYPE) {
1017       k = Universe::typeArrayKlassObj(t);
1018     } else {
<a name="2" id="anc2"></a><span class="line-modified">1019       Symbol* obj_class = ss.as_symbol();</span>
<span class="line-removed">1020       k = SystemDictionary::find(obj_class, class_loader, protection_domain, THREAD);</span>
1021     }
1022     if (k != NULL) {
1023       k = k-&gt;array_klass_or_null(ArrayStorageProperties::for_signature(class_name), ndims);
1024     }
1025   } else {
1026     k = find(class_name, class_loader, protection_domain, THREAD);
1027   }
1028   return k;
1029 }
1030 
1031 // Note: this method is much like resolve_from_stream, but
1032 // does not publish the classes via the SystemDictionary.
1033 // Handles unsafe_DefineAnonymousClass and redefineclasses
1034 // RedefinedClasses do not add to the class hierarchy
1035 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
1036                                               Handle class_loader,
1037                                               Handle protection_domain,
1038                                               ClassFileStream* st,
1039                                               const InstanceKlass* unsafe_anonymous_host,
1040                                               GrowableArray&lt;Handle&gt;* cp_patches,
1041                                               TRAPS) {
1042 
1043   EventClassLoad class_load_start_event;
1044 
1045   ClassLoaderData* loader_data;
1046   if (unsafe_anonymous_host != NULL) {
1047     // Create a new CLD for an unsafe anonymous class, that uses the same class loader
1048     // as the unsafe_anonymous_host
1049     guarantee(unsafe_anonymous_host-&gt;class_loader() == class_loader(), &quot;should be the same&quot;);
1050     loader_data = ClassLoaderData::unsafe_anonymous_class_loader_data(class_loader);
1051   } else {
1052     loader_data = ClassLoaderData::class_loader_data(class_loader());
1053   }
1054 
1055   assert(st != NULL, &quot;invariant&quot;);
1056   assert(st-&gt;need_verify(), &quot;invariant&quot;);
1057 
1058   // Parse stream and create a klass.
1059   // Note that we do this even though this klass might
1060   // already be present in the SystemDictionary, otherwise we would not
1061   // throw potential ClassFormatErrors.
1062 
1063   InstanceKlass* k = KlassFactory::create_from_stream(st,
1064                                                       class_name,
1065                                                       loader_data,
1066                                                       protection_domain,
1067                                                       unsafe_anonymous_host,
1068                                                       cp_patches,
1069                                                       CHECK_NULL);
1070 
1071   if (unsafe_anonymous_host != NULL &amp;&amp; k != NULL) {
1072     // Unsafe anonymous classes must update ClassLoaderData holder (was unsafe_anonymous_host loader)
1073     // so that they can be unloaded when the mirror is no longer referenced.
1074     k-&gt;class_loader_data()-&gt;initialize_holder(Handle(THREAD, k-&gt;java_mirror()));
1075 
1076     {
1077       MutexLocker mu_r(THREAD, Compile_lock);
1078 
1079       // Add to class hierarchy, initialize vtables, and do possible
1080       // deoptimizations.
1081       add_to_hierarchy(k, CHECK_NULL); // No exception, but can block
1082       // But, do not add to dictionary.
1083     }
1084 
1085     // Rewrite and patch constant pool here.
1086     k-&gt;link_class(CHECK_NULL);
1087     if (cp_patches != NULL) {
1088       k-&gt;constants()-&gt;patch_resolved_references(cp_patches);
1089     }
1090 
1091     // If it&#39;s anonymous, initialize it now, since nobody else will.
1092     k-&gt;eager_initialize(CHECK_NULL);
1093 
1094     // notify jvmti
1095     if (JvmtiExport::should_post_class_load()) {
1096         assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1097         JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1098     }
1099     if (class_load_start_event.should_commit()) {
1100       post_class_load_event(&amp;class_load_start_event, k, loader_data);
1101     }
1102   }
1103   assert(unsafe_anonymous_host != NULL || NULL == cp_patches,
1104          &quot;cp_patches only found with unsafe_anonymous_host&quot;);
1105 
1106   return k;
1107 }
1108 
1109 // Add a klass to the system from a stream (called by jni_DefineClass and
1110 // JVM_DefineClass).
1111 // Note: class_name can be NULL. In that case we do not know the name of
1112 // the class until we have parsed the stream.
1113 
1114 InstanceKlass* SystemDictionary::resolve_from_stream(Symbol* class_name,
1115                                                      Handle class_loader,
1116                                                      Handle protection_domain,
1117                                                      ClassFileStream* st,
1118                                                      TRAPS) {
1119 
1120   HandleMark hm(THREAD);
1121 
1122   // Classloaders that support parallelism, e.g. bootstrap classloader,
1123   // do not acquire lock here
1124   bool DoObjectLock = true;
1125   if (is_parallelCapable(class_loader)) {
1126     DoObjectLock = false;
1127   }
1128 
1129   ClassLoaderData* loader_data = register_loader(class_loader);
1130 
1131   // Make sure we are synchronized on the class loader before we proceed
1132   Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1133   check_loader_lock_contention(lockObject, THREAD);
1134   ObjectLocker ol(lockObject, THREAD, DoObjectLock);
1135 
1136   assert(st != NULL, &quot;invariant&quot;);
1137 
1138   // Parse the stream and create a klass.
1139   // Note that we do this even though this klass might
1140   // already be present in the SystemDictionary, otherwise we would not
1141   // throw potential ClassFormatErrors.
1142  InstanceKlass* k = NULL;
1143 
1144 #if INCLUDE_CDS
1145   if (!DumpSharedSpaces) {
1146     k = SystemDictionaryShared::lookup_from_stream(class_name,
1147                                                    class_loader,
1148                                                    protection_domain,
1149                                                    st,
1150                                                    CHECK_NULL);
1151   }
1152 #endif
1153 
1154   if (k == NULL) {
1155     if (st-&gt;buffer() == NULL) {
1156       return NULL;
1157     }
1158     k = KlassFactory::create_from_stream(st,
1159                                          class_name,
1160                                          loader_data,
1161                                          protection_domain,
1162                                          NULL, // unsafe_anonymous_host
1163                                          NULL, // cp_patches
1164                                          CHECK_NULL);
1165   }
1166 
1167   assert(k != NULL, &quot;no klass created&quot;);
1168   Symbol* h_name = k-&gt;name();
1169   assert(class_name == NULL || class_name == h_name, &quot;name mismatch&quot;);
1170 
1171   // Add class just loaded
1172   // If a class loader supports parallel classloading handle parallel define requests
1173   // find_or_define_instance_class may return a different InstanceKlass
1174   if (is_parallelCapable(class_loader)) {
1175     InstanceKlass* defined_k = find_or_define_instance_class(h_name, class_loader, k, THREAD);
1176     if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1177       // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1178       assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1179       loader_data-&gt;add_to_deallocate_list(k);
1180       k = defined_k;
1181     }
1182   } else {
1183     define_instance_class(k, THREAD);
1184   }
1185 
1186   // If defining the class throws an exception register &#39;k&#39; for cleanup.
1187   if (HAS_PENDING_EXCEPTION) {
1188     assert(k != NULL, &quot;Must have an instance klass here!&quot;);
1189     loader_data-&gt;add_to_deallocate_list(k);
1190     return NULL;
1191   }
1192 
1193   // Make sure we have an entry in the SystemDictionary on success
1194   debug_only( {
1195     MutexLocker mu(THREAD, SystemDictionary_lock);
1196 
1197     Klass* check = find_class(h_name, k-&gt;class_loader_data());
1198     assert(check == k, &quot;should be present in the dictionary&quot;);
1199   } );
1200 
1201   return k;
1202 }
1203 
1204 #if INCLUDE_CDS
1205 // Load a class for boot loader from the shared spaces. This also
1206 // forces the super class and all interfaces to be loaded.
1207 InstanceKlass* SystemDictionary::load_shared_boot_class(Symbol* class_name,
1208                                                         TRAPS) {
1209   InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);
1210   if (ik != NULL &amp;&amp; ik-&gt;is_shared_boot_class()) {
1211     return load_shared_class(ik, Handle(), Handle(), NULL, THREAD);
1212   }
1213   return NULL;
1214 }
1215 
1216 // Check if a shared class can be loaded by the specific classloader:
1217 //
1218 // NULL classloader:
1219 //   - Module class from &quot;modules&quot; jimage. ModuleEntry must be defined in the classloader.
1220 //   - Class from -Xbootclasspath/a. The class has no defined PackageEntry, or must
1221 //     be defined in an unnamed module.
1222 bool SystemDictionary::is_shared_class_visible(Symbol* class_name,
1223                                                InstanceKlass* ik,
1224                                                Handle class_loader, TRAPS) {
1225   assert(!ModuleEntryTable::javabase_moduleEntry()-&gt;is_patched(),
1226          &quot;Cannot use sharing if java.base is patched&quot;);
1227   ResourceMark rm(THREAD);
1228   int path_index = ik-&gt;shared_classpath_index();
1229   ClassLoaderData* loader_data = class_loader_data(class_loader);
1230   if (path_index &lt; 0) {
1231     // path_index &lt; 0 indicates that the class is intended for a custom loader
1232     // and should not be loaded by boot/platform/app loaders
1233     if (loader_data-&gt;is_builtin_class_loader_data()) {
1234       return false;
1235     } else {
1236       return true;
1237     }
1238   }
1239   SharedClassPathEntry* ent =
1240             (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);
1241   if (!Universe::is_module_initialized()) {
1242     assert(ent != NULL &amp;&amp; ent-&gt;is_modules_image(),
1243            &quot;Loading non-bootstrap classes before the module system is initialized&quot;);
1244     assert(class_loader.is_null(), &quot;sanity&quot;);
1245     return true;
1246   }
1247   // Get the pkg_entry from the classloader
<a name="3" id="anc3"></a><span class="line-removed">1248   TempNewSymbol pkg_name = NULL;</span>
1249   PackageEntry* pkg_entry = NULL;
1250   ModuleEntry* mod_entry = NULL;
<a name="4" id="anc4"></a><span class="line-modified">1251   pkg_name = InstanceKlass::package_from_name(class_name, CHECK_false);</span>
1252   if (pkg_name != NULL) {
1253     if (loader_data != NULL) {
1254       pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
<a name="5" id="anc5"></a>







1255     }
<a name="6" id="anc6"></a><span class="line-removed">1256     if (pkg_entry != NULL) {</span>
<span class="line-removed">1257       mod_entry = pkg_entry-&gt;module();</span>
<span class="line-removed">1258     }</span>
<span class="line-removed">1259   }</span>
<span class="line-removed">1260 </span>
<span class="line-removed">1261   // If the archived class is from a module that has been patched at runtime,</span>
<span class="line-removed">1262   // the class cannot be loaded from the archive.</span>
<span class="line-removed">1263   if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_patched()) {</span>
<span class="line-removed">1264     return false;</span>
1265   }
1266 
1267   if (class_loader.is_null()) {
1268     assert(ent != NULL, &quot;Shared class for NULL classloader must have valid SharedClassPathEntry&quot;);
1269     // The NULL classloader can load archived class originated from the
1270     // &quot;modules&quot; jimage and the -Xbootclasspath/a. For class from the
1271     // &quot;modules&quot; jimage, the PackageEntry/ModuleEntry must be defined
1272     // by the NULL classloader.
1273     if (mod_entry != NULL) {
1274       // PackageEntry/ModuleEntry is found in the classloader. Check if the
1275       // ModuleEntry&#39;s location agrees with the archived class&#39; origination.
1276       if (ent-&gt;is_modules_image() &amp;&amp; mod_entry-&gt;location()-&gt;starts_with(&quot;jrt:&quot;)) {
1277         return true; // Module class from the &quot;module&quot; jimage
1278       }
1279     }
1280 
1281     // If the archived class is not from the &quot;module&quot; jimage, the class can be
1282     // loaded by the NULL classloader if
1283     //
1284     // 1. the class is from the unamed package
1285     // 2. or, the class is not from a module defined in the NULL classloader
1286     // 3. or, the class is from an unamed module
1287     if (!ent-&gt;is_modules_image() &amp;&amp; ik-&gt;is_shared_boot_class()) {
1288       // the class is from the -Xbootclasspath/a
1289       if (pkg_name == NULL ||
1290           pkg_entry == NULL ||
1291           pkg_entry-&gt;in_unnamed_module()) {
1292         assert(mod_entry == NULL ||
1293                mod_entry == loader_data-&gt;unnamed_module(),
1294                &quot;the unnamed module is not defined in the classloader&quot;);
1295         return true;
1296       }
1297     }
1298     return false;
1299   } else {
1300     bool res = SystemDictionaryShared::is_shared_class_visible_for_classloader(
1301               ik, class_loader, pkg_name, pkg_entry, mod_entry, CHECK_(false));
1302     return res;
1303   }
1304 }
1305 
<a name="7" id="anc7"></a><span class="line-modified">1306 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,</span>
<span class="line-modified">1307                                                    Handle class_loader,</span>
<span class="line-modified">1308                                                    Handle protection_domain,</span>
<span class="line-modified">1309                                                    const ClassFileStream *cfs,</span>
<span class="line-removed">1310                                                    TRAPS) {</span>
<span class="line-removed">1311   assert(ik != NULL, &quot;sanity&quot;);</span>
<span class="line-removed">1312   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);</span>
<span class="line-removed">1313   Symbol* class_name = ik-&gt;name();</span>
1314 
<a name="8" id="anc8"></a><span class="line-modified">1315   bool visible = is_shared_class_visible(</span>
<span class="line-modified">1316                           class_name, ik, class_loader, CHECK_NULL);</span>
<span class="line-modified">1317   if (!visible) {</span>
<span class="line-modified">1318     return NULL;</span>




1319   }
<a name="9" id="anc9"></a>
1320 
<a name="10" id="anc10"></a><span class="line-modified">1321   // Resolve the superclass and interfaces. They must be the same</span>


1322   // as in dump time, because the layout of &lt;ik&gt; depends on
1323   // the specific layout of ik-&gt;super() and ik-&gt;local_interfaces().
1324   //
1325   // If unexpected superclass or interfaces are found, we cannot
1326   // load &lt;ik&gt; from the shared archive.
1327 
<a name="11" id="anc11"></a><span class="line-modified">1328   if (ik-&gt;super() != NULL) {</span>
<span class="line-modified">1329     Symbol*  cn = ik-&gt;super()-&gt;name();</span>
<span class="line-modified">1330     Klass *s = resolve_super_or_fail(class_name, cn,</span>
<span class="line-modified">1331                                      class_loader, protection_domain, true, CHECK_NULL);</span>
<span class="line-removed">1332     if (s != ik-&gt;super()) {</span>
<span class="line-removed">1333       // The dynamically resolved super class is not the same as the one we used during dump time,</span>
<span class="line-removed">1334       // so we cannot use ik.</span>
<span class="line-removed">1335       return NULL;</span>
<span class="line-removed">1336     } else {</span>
<span class="line-removed">1337       assert(s-&gt;is_shared(), &quot;must be&quot;);</span>
<span class="line-removed">1338     }</span>
1339   }
1340 
1341   Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
1342   int num_interfaces = interfaces-&gt;length();
1343   for (int index = 0; index &lt; num_interfaces; index++) {
<a name="12" id="anc12"></a><span class="line-modified">1344     InstanceKlass* k = interfaces-&gt;at(index);</span>
<span class="line-modified">1345     Symbol* name  = k-&gt;name();</span>
<span class="line-removed">1346     Klass* i = resolve_super_or_fail(class_name, name, class_loader, protection_domain, false, CHECK_NULL);</span>
<span class="line-removed">1347     if (k != i) {</span>
<span class="line-removed">1348       // The dynamically resolved interface class is not the same as the one we used during dump time,</span>
<span class="line-removed">1349       // so we cannot use ik.</span>
<span class="line-removed">1350       return NULL;</span>
<span class="line-removed">1351     } else {</span>
<span class="line-removed">1352       assert(i-&gt;is_shared(), &quot;must be&quot;);</span>
1353     }
1354   }
1355 
<a name="13" id="anc13"></a>





















1356   InstanceKlass* new_ik = KlassFactory::check_shared_class_file_load_hook(
1357       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1358   if (new_ik != NULL) {
1359     // The class is changed by CFLH. Return the new class. The shared class is
1360     // not used.
1361     return new_ik;
1362   }
1363 
1364   // Adjust methods to recover missing data.  They need addresses for
1365   // interpreter entry points and their default native method address
1366   // must be reset.
1367 
1368   // Updating methods must be done under a lock so multiple
1369   // threads don&#39;t update these in parallel
1370   //
1371   // Shared classes are all currently loaded by either the bootstrap or
1372   // internal parallel class loaders, so this will never cause a deadlock
1373   // on a custom class loader lock.
1374 
1375   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1376   {
1377     HandleMark hm(THREAD);
1378     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1379     check_loader_lock_contention(lockObject, THREAD);
1380     ObjectLocker ol(lockObject, THREAD, true);
1381     // prohibited package check assumes all classes loaded from archive call
1382     // restore_unshareable_info which calls ik-&gt;set_package()
1383     ik-&gt;restore_unshareable_info(loader_data, protection_domain, CHECK_NULL);
1384   }
1385 
<a name="14" id="anc14"></a>




1386   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1387 
1388   // For boot loader, ensure that GetSystemPackage knows that a class in this
1389   // package was loaded.
<a name="15" id="anc15"></a><span class="line-modified">1390   if (class_loader.is_null()) {</span>
1391     int path_index = ik-&gt;shared_classpath_index();
<a name="16" id="anc16"></a><span class="line-modified">1392     ResourceMark rm(THREAD);</span>
<span class="line-removed">1393     ClassLoader::add_package(ik-&gt;name()-&gt;as_C_string(), path_index, THREAD);</span>
1394   }
1395 
1396   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1397     // Only dump the classes that can be stored into CDS archive
1398     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1399       ResourceMark rm(THREAD);
1400       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1401       classlist_file-&gt;flush();
1402     }
1403   }
1404 
1405   // notify a class loaded from shared object
1406   ClassLoadingService::notify_class_loaded(ik, true /* shared class */);
1407 
1408   ik-&gt;set_has_passed_fingerprint_check(false);
1409   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
1410     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
1411     uint64_t cds_fp = ik-&gt;get_stored_fingerprint();
1412     if (aot_fp != 0 &amp;&amp; aot_fp == cds_fp) {
1413       // This class matches with a class saved in an AOT library
1414       ik-&gt;set_has_passed_fingerprint_check(true);
1415     } else {
1416       if (log_is_enabled(Info, class, fingerprint)) {
1417         ResourceMark rm(THREAD);
1418         log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT, ik-&gt;external_name(), aot_fp, cds_fp);
1419       }
1420     }
1421   }
<a name="17" id="anc17"></a>






















1422 
<a name="18" id="anc18"></a><span class="line-modified">1423   return ik;</span>






1424 }
1425 #endif // INCLUDE_CDS
1426 
1427 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1428 
1429   if (class_loader.is_null()) {
1430     ResourceMark rm(THREAD);
1431     PackageEntry* pkg_entry = NULL;
1432     bool search_only_bootloader_append = false;
1433     ClassLoaderData *loader_data = class_loader_data(class_loader);
1434 
1435     // Find the package in the boot loader&#39;s package entry table.
<a name="19" id="anc19"></a><span class="line-modified">1436     TempNewSymbol pkg_name = InstanceKlass::package_from_name(class_name, CHECK_NULL);</span>
1437     if (pkg_name != NULL) {
1438       pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
1439     }
1440 
1441     // Prior to attempting to load the class, enforce the boot loader&#39;s
1442     // visibility boundaries.
1443     if (!Universe::is_module_initialized()) {
1444       // During bootstrapping, prior to module initialization, any
1445       // class attempting to be loaded must be checked against the
1446       // java.base packages in the boot loader&#39;s PackageEntryTable.
1447       // No class outside of java.base is allowed to be loaded during
1448       // this bootstrapping window.
1449       if (pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1450         // Class is either in the unnamed package or in
1451         // a named package within the unnamed module.  Either
1452         // case is outside of java.base, do not attempt to
1453         // load the class post java.base definition.  If
1454         // java.base has not been defined, let the class load
1455         // and its package will be checked later by
1456         // ModuleEntryTable::verify_javabase_packages.
1457         if (ModuleEntryTable::javabase_defined()) {
1458           return NULL;
1459         }
1460       } else {
1461         // Check that the class&#39; package is defined within java.base.
1462         ModuleEntry* mod_entry = pkg_entry-&gt;module();
1463         Symbol* mod_entry_name = mod_entry-&gt;name();
1464         if (mod_entry_name-&gt;fast_compare(vmSymbols::java_base()) != 0) {
1465           return NULL;
1466         }
1467       }
1468     } else {
1469       // After the module system has been initialized, check if the class&#39;
1470       // package is in a module defined to the boot loader.
1471       if (pkg_name == NULL || pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1472         // Class is either in the unnamed package, in a named package
1473         // within a module not defined to the boot loader or in a
1474         // a named package within the unnamed module.  In all cases,
1475         // limit visibility to search for the class only in the boot
1476         // loader&#39;s append path.
1477         if (!ClassLoader::has_bootclasspath_append()) {
1478            // If there is no bootclasspath append entry, no need to continue
1479            // searching.
1480            return NULL;
1481         }
1482         search_only_bootloader_append = true;
1483       }
1484     }
1485 
1486     // Prior to bootstrapping&#39;s module initialization, never load a class outside
1487     // of the boot loader&#39;s module path
1488     assert(Universe::is_module_initialized() ||
1489            !search_only_bootloader_append,
1490            &quot;Attempt to load a class outside of boot loader&#39;s module path&quot;);
1491 
1492     // Search for classes in the CDS archive.
1493     InstanceKlass* k = NULL;
1494     {
1495 #if INCLUDE_CDS
1496       PerfTraceTime vmtimer(ClassLoader::perf_shared_classload_time());
1497       k = load_shared_boot_class(class_name, THREAD);
1498 #endif
1499     }
1500 
1501     if (k == NULL) {
1502       // Use VM class loader
1503       PerfTraceTime vmtimer(ClassLoader::perf_sys_classload_time());
1504       k = ClassLoader::load_class(class_name, search_only_bootloader_append, CHECK_NULL);
1505     }
1506 
1507     // find_or_define_instance_class may return a different InstanceKlass
1508     if (k != NULL) {
1509       InstanceKlass* defined_k =
1510         find_or_define_instance_class(class_name, class_loader, k, THREAD);
1511       if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1512         // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1513         assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1514         loader_data-&gt;add_to_deallocate_list(k);
1515         k = defined_k;
1516       } else if (HAS_PENDING_EXCEPTION) {
1517         loader_data-&gt;add_to_deallocate_list(k);
1518         return NULL;
1519       }
1520     }
1521     return k;
1522   } else {
1523     // Use user specified class loader to load class. Call loadClass operation on class_loader.
1524     ResourceMark rm(THREAD);
1525 
1526     assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
1527     JavaThread* jt = (JavaThread*) THREAD;
1528 
1529     PerfClassTraceTime vmtimer(ClassLoader::perf_app_classload_time(),
1530                                ClassLoader::perf_app_classload_selftime(),
1531                                ClassLoader::perf_app_classload_count(),
1532                                jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1533                                jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1534                                PerfClassTraceTime::CLASS_LOAD);
1535 
1536     Handle s = java_lang_String::create_from_symbol(class_name, CHECK_NULL);
1537     // Translate to external class name format, i.e., convert &#39;/&#39; chars to &#39;.&#39;
1538     Handle string = java_lang_String::externalize_classname(s, CHECK_NULL);
1539 
1540     JavaValue result(T_OBJECT);
1541 
1542     InstanceKlass* spec_klass = SystemDictionary::ClassLoader_klass();
1543 
1544     // Call public unsynchronized loadClass(String) directly for all class loaders.
1545     // For parallelCapable class loaders, JDK &gt;=7, loadClass(String, boolean) will
1546     // acquire a class-name based lock rather than the class loader object lock.
1547     // JDK &lt; 7 already acquire the class loader lock in loadClass(String, boolean).
1548     JavaCalls::call_virtual(&amp;result,
1549                             class_loader,
1550                             spec_klass,
1551                             vmSymbols::loadClass_name(),
1552                             vmSymbols::string_class_signature(),
1553                             string,
1554                             CHECK_NULL);
1555 
1556     assert(result.get_type() == T_OBJECT, &quot;just checking&quot;);
1557     oop obj = (oop) result.get_jobject();
1558 
1559     // Primitive classes return null since forName() can not be
1560     // used to obtain any of the Class objects representing primitives or void
1561     if ((obj != NULL) &amp;&amp; !(java_lang_Class::is_primitive(obj))) {
1562       InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(obj));
1563       // For user defined Java class loaders, check that the name returned is
1564       // the same as that requested.  This check is done for the bootstrap
1565       // loader when parsing the class file.
1566       if (class_name == k-&gt;name()) {
1567         return k;
1568       }
1569     }
1570     // Class is not found or has the wrong name, return NULL
1571     return NULL;
1572   }
1573 }
1574 
1575 static void post_class_define_event(InstanceKlass* k, const ClassLoaderData* def_cld) {
1576   EventClassDefine event;
1577   if (event.should_commit()) {
1578     event.set_definedClass(k);
1579     event.set_definingClassLoader(def_cld);
1580     event.commit();
1581   }
1582 }
1583 
1584 void SystemDictionary::define_instance_class(InstanceKlass* k, TRAPS) {
1585 
1586   HandleMark hm(THREAD);
1587   ClassLoaderData* loader_data = k-&gt;class_loader_data();
1588   Handle class_loader_h(THREAD, loader_data-&gt;class_loader());
1589 
1590  // for bootstrap and other parallel classloaders don&#39;t acquire lock,
1591  // use placeholder token
1592  // If a parallelCapable class loader calls define_instance_class instead of
1593  // find_or_define_instance_class to get here, we have a timing
1594  // hole with systemDictionary updates and check_constraints
1595  if (!class_loader_h.is_null() &amp;&amp; !is_parallelCapable(class_loader_h)) {
1596     assert(ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD,
1597          compute_loader_lock_object(class_loader_h, THREAD)),
1598          &quot;define called without lock&quot;);
1599   }
1600 
1601   // Check class-loading constraints. Throw exception if violation is detected.
1602   // Grabs and releases SystemDictionary_lock
1603   // The check_constraints/find_class call and update_dictionary sequence
1604   // must be &quot;atomic&quot; for a specific class/classloader pair so we never
1605   // define two different instanceKlasses for that class/classloader pair.
1606   // Existing classloaders will call define_instance_class with the
1607   // classloader lock held
1608   // Parallel classloaders will call find_or_define_instance_class
1609   // which will require a token to perform the define class
1610   Symbol*  name_h = k-&gt;name();
1611   Dictionary* dictionary = loader_data-&gt;dictionary();
1612   unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
1613   check_constraints(d_hash, k, class_loader_h, true, CHECK);
1614 
1615   // Register class just loaded with class loader (placed in ArrayList)
1616   // Note we do this before updating the dictionary, as this can
1617   // fail with an OutOfMemoryError (if it does, we will *not* put this
1618   // class in the dictionary and will not update the class hierarchy).
1619   // JVMTI FollowReferences needs to find the classes this way.
1620   if (k-&gt;class_loader() != NULL) {
1621     methodHandle m(THREAD, Universe::loader_addClass_method());
1622     JavaValue result(T_VOID);
1623     JavaCallArguments args(class_loader_h);
1624     args.push_oop(Handle(THREAD, k-&gt;java_mirror()));
1625     JavaCalls::call(&amp;result, m, &amp;args, CHECK);
1626   }
1627 
1628   // Add the new class. We need recompile lock during update of CHA.
1629   {
1630     unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
1631     int p_index = placeholders()-&gt;hash_to_index(p_hash);
1632 
1633     MutexLocker mu_r(THREAD, Compile_lock);
1634 
1635     // Add to class hierarchy, initialize vtables, and do possible
1636     // deoptimizations.
1637     add_to_hierarchy(k, CHECK); // No exception, but can block
1638 
1639     // Add to systemDictionary - so other classes can see it.
1640     // Grabs and releases SystemDictionary_lock
1641     update_dictionary(d_hash, p_index, p_hash,
1642                       k, class_loader_h, THREAD);
1643   }
1644   k-&gt;eager_initialize(THREAD);
1645 
1646   // notify jvmti
1647   if (JvmtiExport::should_post_class_load()) {
1648       assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1649       JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1650 
1651   }
1652   post_class_define_event(k, loader_data);
1653 }
1654 
1655 // Support parallel classloading
1656 // All parallel class loaders, including bootstrap classloader
1657 // lock a placeholder entry for this class/class_loader pair
1658 // to allow parallel defines of different classes for this class loader
1659 // With AllowParallelDefine flag==true, in case they do not synchronize around
1660 // FindLoadedClass/DefineClass, calls, we check for parallel
1661 // loading for them, wait if a defineClass is in progress
1662 // and return the initial requestor&#39;s results
1663 // This flag does not apply to the bootstrap classloader.
1664 // With AllowParallelDefine flag==false, call through to define_instance_class
1665 // which will throw LinkageError: duplicate class definition.
1666 // False is the requested default.
1667 // For better performance, the class loaders should synchronize
1668 // findClass(), i.e. FindLoadedClass/DefineClassIfAbsent or they
1669 // potentially waste time reading and parsing the bytestream.
1670 // Note: VM callers should ensure consistency of k/class_name,class_loader
1671 // Be careful when modifying this code: once you have run
1672 // placeholders()-&gt;find_and_add(PlaceholderTable::DEFINE_CLASS),
1673 // you need to find_and_remove it before returning.
1674 // So be careful to not exit with a CHECK_ macro betweeen these calls.
1675 InstanceKlass* SystemDictionary::find_or_define_instance_class(Symbol* class_name, Handle class_loader,
1676                                                                InstanceKlass* k, TRAPS) {
1677 
1678   Symbol*  name_h = k-&gt;name(); // passed in class_name may be null
1679   ClassLoaderData* loader_data = class_loader_data(class_loader);
1680   Dictionary* dictionary = loader_data-&gt;dictionary();
1681 
1682   unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
1683 
1684   // Hold SD lock around find_class and placeholder creation for DEFINE_CLASS
1685   unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
1686   int p_index = placeholders()-&gt;hash_to_index(p_hash);
1687   PlaceholderEntry* probe;
1688 
1689   {
1690     MutexLocker mu(THREAD, SystemDictionary_lock);
1691     // First check if class already defined
1692     if (is_parallelDefine(class_loader)) {
1693       InstanceKlass* check = find_class(d_hash, name_h, dictionary);
1694       if (check != NULL) {
1695         return check;
1696       }
1697     }
1698 
1699     // Acquire define token for this class/classloader
1700     probe = placeholders()-&gt;find_and_add(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, NULL, THREAD);
1701     // Wait if another thread defining in parallel
1702     // All threads wait - even those that will throw duplicate class: otherwise
1703     // caller is surprised by LinkageError: duplicate, but findLoadedClass fails
1704     // if other thread has not finished updating dictionary
1705     while (probe-&gt;definer() != NULL) {
1706       SystemDictionary_lock-&gt;wait();
1707     }
1708     // Only special cases allow parallel defines and can use other thread&#39;s results
1709     // Other cases fall through, and may run into duplicate defines
1710     // caught by finding an entry in the SystemDictionary
1711     if (is_parallelDefine(class_loader) &amp;&amp; (probe-&gt;instance_klass() != NULL)) {
1712         placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1713         SystemDictionary_lock-&gt;notify_all();
1714 #ifdef ASSERT
1715         InstanceKlass* check = find_class(d_hash, name_h, dictionary);
1716         assert(check != NULL, &quot;definer missed recording success&quot;);
1717 #endif
1718         return probe-&gt;instance_klass();
1719     } else {
1720       // This thread will define the class (even if earlier thread tried and had an error)
1721       probe-&gt;set_definer(THREAD);
1722     }
1723   }
1724 
1725   define_instance_class(k, THREAD);
1726 
1727   Handle linkage_exception = Handle(); // null handle
1728 
1729   // definer must notify any waiting threads
1730   {
1731     MutexLocker mu(THREAD, SystemDictionary_lock);
1732     PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, name_h, loader_data);
1733     assert(probe != NULL, &quot;DEFINE_CLASS placeholder lost?&quot;);
1734     if (probe != NULL) {
1735       if (HAS_PENDING_EXCEPTION) {
1736         linkage_exception = Handle(THREAD,PENDING_EXCEPTION);
1737         CLEAR_PENDING_EXCEPTION;
1738       } else {
1739         probe-&gt;set_instance_klass(k);
1740       }
1741       probe-&gt;set_definer(NULL);
1742       placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1743       SystemDictionary_lock-&gt;notify_all();
1744     }
1745   }
1746 
1747   // Can&#39;t throw exception while holding lock due to rank ordering
1748   if (linkage_exception() != NULL) {
1749     THROW_OOP_(linkage_exception(), NULL); // throws exception and returns
1750   }
1751 
1752   return k;
1753 }
1754 
1755 Handle SystemDictionary::compute_loader_lock_object(Handle class_loader, TRAPS) {
1756   // If class_loader is NULL we synchronize on _system_loader_lock_obj
1757   if (class_loader.is_null()) {
1758     return Handle(THREAD, _system_loader_lock_obj);
1759   } else {
1760     return class_loader;
1761   }
1762 }
1763 
1764 // This method is added to check how often we have to wait to grab loader
1765 // lock. The results are being recorded in the performance counters defined in
1766 // ClassLoader::_sync_systemLoaderLockContentionRate and
1767 // ClassLoader::_sync_nonSystemLoaderLockConteionRate.
1768 void SystemDictionary::check_loader_lock_contention(Handle loader_lock, TRAPS) {
1769   if (!UsePerfData) {
1770     return;
1771   }
1772 
1773   assert(!loader_lock.is_null(), &quot;NULL lock object&quot;);
1774 
1775   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader_lock)
1776       == ObjectSynchronizer::owner_other) {
1777     // contention will likely happen, so increment the corresponding
1778     // contention counter.
1779     if (loader_lock() == _system_loader_lock_obj) {
1780       ClassLoader::sync_systemLoaderLockContentionRate()-&gt;inc();
1781     } else {
1782       ClassLoader::sync_nonSystemLoaderLockContentionRate()-&gt;inc();
1783     }
1784   }
1785 }
1786 
1787 // ----------------------------------------------------------------------------
1788 // Lookup
1789 
1790 InstanceKlass* SystemDictionary::find_class(unsigned int hash,
1791                                             Symbol* class_name,
1792                                             Dictionary* dictionary) {
1793   assert_locked_or_safepoint(SystemDictionary_lock);
1794   int index = dictionary-&gt;hash_to_index(hash);
1795   return dictionary-&gt;find_class(index, hash, class_name);
1796 }
1797 
1798 
1799 // Basic find on classes in the midst of being loaded
1800 Symbol* SystemDictionary::find_placeholder(Symbol* class_name,
1801                                            ClassLoaderData* loader_data) {
1802   assert_locked_or_safepoint(SystemDictionary_lock);
1803   unsigned int p_hash = placeholders()-&gt;compute_hash(class_name);
1804   int p_index = placeholders()-&gt;hash_to_index(p_hash);
1805   return placeholders()-&gt;find_entry(p_index, p_hash, class_name, loader_data);
1806 }
1807 
1808 
1809 // Used for assertions and verification only
1810 // Precalculating the hash and index is an optimization because there are many lookups
1811 // before adding the class.
1812 InstanceKlass* SystemDictionary::find_class(Symbol* class_name, ClassLoaderData* loader_data) {
1813   assert_locked_or_safepoint(SystemDictionary_lock);
1814   #ifndef ASSERT
1815   guarantee(VerifyBeforeGC      ||
1816             VerifyDuringGC      ||
1817             VerifyBeforeExit    ||
1818             VerifyDuringStartup ||
1819             VerifyAfterGC, &quot;too expensive&quot;);
1820   #endif
1821 
1822   Dictionary* dictionary = loader_data-&gt;dictionary();
1823   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
1824   return find_class(d_hash, class_name, dictionary);
1825 }
1826 
1827 
1828 // ----------------------------------------------------------------------------
1829 // Update hierachy. This is done before the new klass has been added to the SystemDictionary. The Recompile_lock
1830 // is held, to ensure that the compiler is not using the class hierachy, and that deoptimization will kick in
1831 // before a new class is used.
1832 
1833 void SystemDictionary::add_to_hierarchy(InstanceKlass* k, TRAPS) {
1834   assert(k != NULL, &quot;just checking&quot;);
<a name="20" id="anc20"></a><span class="line-modified">1835   assert_locked_or_safepoint(Compile_lock);</span>


1836 
1837   k-&gt;set_init_state(InstanceKlass::loaded);
1838   // make sure init_state store is already done.
1839   // The compiler reads the hierarchy outside of the Compile_lock.
1840   // Access ordering is used to add to hierarchy.
1841 
1842   // Link into hierachy.
1843   k-&gt;append_to_sibling_list();                    // add to superklass/sibling list
1844   k-&gt;process_interfaces(THREAD);                  // handle all &quot;implements&quot; declarations
1845 
1846   // Now flush all code that depended on old class hierarchy.
1847   // Note: must be done *after* linking k into the hierarchy (was bug 12/9/97)
<a name="21" id="anc21"></a><span class="line-modified">1848   CodeCache::flush_dependents_on(k);</span>


1849 }
1850 
1851 // ----------------------------------------------------------------------------
1852 // GC support
1853 
1854 // Assumes classes in the SystemDictionary are only unloaded at a safepoint
1855 // Note: anonymous classes are not in the SD.
1856 bool SystemDictionary::do_unloading(GCTimer* gc_timer) {
1857 
1858   bool unloading_occurred;
1859   bool is_concurrent = !SafepointSynchronize::is_at_safepoint();
1860   {
1861     GCTraceTime(Debug, gc, phases) t(&quot;ClassLoaderData&quot;, gc_timer);
1862     assert_locked_or_safepoint(ClassLoaderDataGraph_lock);  // caller locks.
1863     // First, mark for unload all ClassLoaderData referencing a dead class loader.
1864     unloading_occurred = ClassLoaderDataGraph::do_unloading();
1865     if (unloading_occurred) {
1866       MutexLocker ml2(is_concurrent ? Module_lock : NULL);
1867       JFR_ONLY(Jfr::on_unloading_classes();)
1868 
1869       MutexLocker ml1(is_concurrent ? SystemDictionary_lock : NULL);
1870       ClassLoaderDataGraph::clean_module_and_package_info();
1871       constraints()-&gt;purge_loader_constraints();
1872       resolution_errors()-&gt;purge_resolution_errors();
1873     }
1874   }
1875 
1876   GCTraceTime(Debug, gc, phases) t(&quot;Trigger cleanups&quot;, gc_timer);
1877 
1878   if (unloading_occurred) {
1879     SymbolTable::trigger_cleanup();
1880 
1881     // Oops referenced by the protection domain cache table may get unreachable independently
1882     // of the class loader (eg. cached protection domain oops). So we need to
1883     // explicitly unlink them here.
1884     // All protection domain oops are linked to the caller class, so if nothing
1885     // unloads, this is not needed.
1886     _pd_cache_table-&gt;trigger_cleanup();
1887   }
1888 
1889   return unloading_occurred;
1890 }
1891 
1892 void SystemDictionary::oops_do(OopClosure* f, bool include_handles) {
1893   f-&gt;do_oop(&amp;_java_system_loader);
1894   f-&gt;do_oop(&amp;_java_platform_loader);
1895   f-&gt;do_oop(&amp;_system_loader_lock_obj);
1896   CDS_ONLY(SystemDictionaryShared::oops_do(f);)
1897 
1898   // Visit extra methods
1899   invoke_method_table()-&gt;oops_do(f);
1900 
1901   if (include_handles) {
1902     OopStorageSet::vm_global()-&gt;oops_do(f);
1903   }
1904 }
1905 
1906 // CDS: scan and relocate all classes referenced by _well_known_klasses[].
1907 void SystemDictionary::well_known_klasses_do(MetaspaceClosure* it) {
1908   for (int id = FIRST_WKID; id &lt; WKID_LIMIT; id++) {
1909     it-&gt;push(well_known_klass_addr((WKID)id));
1910   }
1911 }
1912 
1913 void SystemDictionary::methods_do(void f(Method*)) {
1914   // Walk methods in loaded classes
1915   MutexLocker ml(ClassLoaderDataGraph_lock);
1916   ClassLoaderDataGraph::methods_do(f);
1917   // Walk method handle intrinsics
1918   invoke_method_table()-&gt;methods_do(f);
1919 }
1920 
1921 // ----------------------------------------------------------------------------
1922 // Initialization
1923 
1924 void SystemDictionary::initialize(TRAPS) {
1925   // Allocate arrays
1926   _placeholders        = new PlaceholderTable(_placeholder_table_size);
1927   _loader_constraints  = new LoaderConstraintTable(_loader_constraint_size);
1928   _resolution_errors   = new ResolutionErrorTable(_resolution_error_size);
1929   _invoke_method_table = new SymbolPropertyTable(_invoke_method_size);
1930   _pd_cache_table = new ProtectionDomainCacheTable(defaultProtectionDomainCacheSize);
1931 
1932   // Allocate private object used as system class loader lock
1933   _system_loader_lock_obj = oopFactory::new_intArray(0, CHECK);
1934   // Initialize basic classes
1935   resolve_well_known_classes(CHECK);
1936 }
1937 
1938 // Compact table of directions on the initialization of klasses:
1939 static const short wk_init_info[] = {
1940   #define WK_KLASS_INIT_INFO(name, symbol) \
1941     ((short)vmSymbols::VM_SYMBOL_ENUM_NAME(symbol)),
1942 
1943   WK_KLASSES_DO(WK_KLASS_INIT_INFO)
1944   #undef WK_KLASS_INIT_INFO
1945   0
1946 };
1947 
1948 #ifdef ASSERT
1949 bool SystemDictionary::is_well_known_klass(Symbol* class_name) {
1950   int sid;
1951   for (int i = 0; (sid = wk_init_info[i]) != 0; i++) {
1952     Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
1953     if (class_name == symbol) {
1954       return true;
1955     }
1956   }
1957   return false;
1958 }
1959 #endif
1960 
1961 bool SystemDictionary::resolve_wk_klass(WKID id, TRAPS) {
1962   assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
1963   int sid = wk_init_info[id - FIRST_WKID];
1964   Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
1965   InstanceKlass** klassp = &amp;_well_known_klasses[id];
1966 
<a name="22" id="anc22"></a><span class="line-modified">1967   if ((*klassp) == NULL) {</span>
<span class="line-modified">1968     Klass* k = resolve_or_fail(symbol, true, CHECK_0);</span>











1969     (*klassp) = InstanceKlass::cast(k);
1970   }
1971   return ((*klassp) != NULL);
1972 }
1973 
1974 void SystemDictionary::resolve_wk_klasses_until(WKID limit_id, WKID &amp;start_id, TRAPS) {
1975   assert((int)start_id &lt;= (int)limit_id, &quot;IDs are out of order!&quot;);
1976   for (int id = (int)start_id; id &lt; (int)limit_id; id++) {
1977     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
1978     resolve_wk_klass((WKID)id, CHECK);
1979   }
1980 
1981   // move the starting value forward to the limit:
1982   start_id = limit_id;
1983 }
1984 
1985 void SystemDictionary::resolve_well_known_classes(TRAPS) {
<a name="23" id="anc23"></a><span class="line-modified">1986   assert(WK_KLASS(Object_klass) == NULL, &quot;well-known classes should only be initialized once&quot;);</span>
1987 
1988   // Create the ModuleEntry for java.base.  This call needs to be done here,
1989   // after vmSymbols::initialize() is called but before any classes are pre-loaded.
1990   ClassLoader::classLoader_init2(CHECK);
1991 
1992   // Preload commonly used klasses
1993   WKID scan = FIRST_WKID;
1994   // first do Object, then String, Class
1995 #if INCLUDE_CDS
1996   if (UseSharedSpaces) {
1997     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Object_klass), scan, CHECK);
1998 
1999     // It&#39;s unsafe to access the archived heap regions before they
2000     // are fixed up, so we must do the fixup as early as possible
2001     // before the archived java objects are accessed by functions
2002     // such as java_lang_Class::restore_archived_mirror and
2003     // ConstantPool::restore_unshareable_info (restores the archived
2004     // resolved_references array object).
2005     //
2006     // HeapShared::fixup_mapped_heap_regions() fills the empty
2007     // spaces in the archived heap regions and may use
2008     // SystemDictionary::Object_klass(), so we can do this only after
2009     // Object_klass is resolved. See the above resolve_wk_klasses_through()
2010     // call. No mirror objects are accessed/restored in the above call.
2011     // Mirrors are restored after java.lang.Class is loaded.
2012     HeapShared::fixup_mapped_heap_regions();
2013 
2014     // Initialize the constant pool for the Object_class
2015     assert(Object_klass()-&gt;is_shared(), &quot;must be&quot;);
2016     Object_klass()-&gt;constants()-&gt;restore_unshareable_info(CHECK);
2017     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
2018   } else
2019 #endif
2020   {
2021     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
2022   }
2023 
2024   assert(WK_KLASS(Object_klass) != NULL, &quot;well-known classes should now be initialized&quot;);
2025 
2026   java_lang_Object::register_natives(CHECK);
2027 
2028   // Calculate offsets for String and Class classes since they are loaded and
2029   // can be used after this point.
2030   java_lang_String::compute_offsets();
2031   java_lang_Class::compute_offsets();
2032 
2033   // Fixup mirrors for classes loaded before java.lang.Class.
<a name="24" id="anc24"></a><span class="line-removed">2034   // These calls iterate over the objects currently in the perm gen</span>
<span class="line-removed">2035   // so calling them at this point is matters (not before when there</span>
<span class="line-removed">2036   // are fewer objects and not later after there are more objects</span>
<span class="line-removed">2037   // in the perm gen.</span>
2038   Universe::initialize_basic_type_mirrors(CHECK);
2039   Universe::fixup_mirrors(CHECK);
2040 
2041   // do a bunch more:
2042   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Reference_klass), scan, CHECK);
2043 
2044   // Preload ref klasses and set reference types
2045   WK_KLASS(Reference_klass)-&gt;set_reference_type(REF_OTHER);
2046   InstanceRefKlass::update_nonstatic_oop_maps(WK_KLASS(Reference_klass));
2047 
2048   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(PhantomReference_klass), scan, CHECK);
2049   WK_KLASS(SoftReference_klass)-&gt;set_reference_type(REF_SOFT);
2050   WK_KLASS(WeakReference_klass)-&gt;set_reference_type(REF_WEAK);
2051   WK_KLASS(FinalReference_klass)-&gt;set_reference_type(REF_FINAL);
2052   WK_KLASS(PhantomReference_klass)-&gt;set_reference_type(REF_PHANTOM);
2053 
2054   // JSR 292 classes
2055   WKID jsr292_group_start = WK_KLASS_ENUM_NAME(MethodHandle_klass);
2056   WKID jsr292_group_end   = WK_KLASS_ENUM_NAME(VolatileCallSite_klass);
2057   resolve_wk_klasses_until(jsr292_group_start, scan, CHECK);
2058   resolve_wk_klasses_through(jsr292_group_end, scan, CHECK);
2059   WKID last = WKID_LIMIT;
2060   resolve_wk_klasses_until(last, scan, CHECK);
2061 
2062   _box_klasses[T_BOOLEAN] = WK_KLASS(Boolean_klass);
2063   _box_klasses[T_CHAR]    = WK_KLASS(Character_klass);
2064   _box_klasses[T_FLOAT]   = WK_KLASS(Float_klass);
2065   _box_klasses[T_DOUBLE]  = WK_KLASS(Double_klass);
2066   _box_klasses[T_BYTE]    = WK_KLASS(Byte_klass);
2067   _box_klasses[T_SHORT]   = WK_KLASS(Short_klass);
2068   _box_klasses[T_INT]     = WK_KLASS(Integer_klass);
2069   _box_klasses[T_LONG]    = WK_KLASS(Long_klass);
2070   //_box_klasses[T_OBJECT]  = WK_KLASS(object_klass);
2071   //_box_klasses[T_ARRAY]   = WK_KLASS(object_klass);
2072 
2073 #ifdef ASSERT
2074   if (UseSharedSpaces) {
<a name="25" id="anc25"></a><span class="line-modified">2075     assert(JvmtiExport::is_early_phase(),</span>
<span class="line-modified">2076            &quot;All well known classes must be resolved in JVMTI early phase&quot;);</span>
2077     for (int i = FIRST_WKID; i &lt; last; i++) {
2078       InstanceKlass* k = _well_known_klasses[i];
2079       assert(k-&gt;is_shared(), &quot;must not be replaced by JVMTI class file load hook&quot;);
2080     }
2081   }
2082 #endif
2083 }
2084 
2085 // Tells if a given klass is a box (wrapper class, such as java.lang.Integer).
2086 // If so, returns the basic type it holds.  If not, returns T_OBJECT.
2087 BasicType SystemDictionary::box_klass_type(Klass* k) {
2088   assert(k != NULL, &quot;&quot;);
2089   for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
2090     if (_box_klasses[i] == k)
2091       return (BasicType)i;
2092   }
2093   return T_OBJECT;
2094 }
2095 
2096 // Constraints on class loaders. The details of the algorithm can be
2097 // found in the OOPSLA&#39;98 paper &quot;Dynamic Class Loading in the Java
2098 // Virtual Machine&quot; by Sheng Liang and Gilad Bracha.  The basic idea is
2099 // that the dictionary needs to maintain a set of contraints that
2100 // must be satisfied by all classes in the dictionary.
2101 // if defining is true, then LinkageError if already in dictionary
2102 // if initiating loader, then ok if InstanceKlass matches existing entry
2103 
2104 void SystemDictionary::check_constraints(unsigned int d_hash,
2105                                          InstanceKlass* k,
2106                                          Handle class_loader,
2107                                          bool defining,
2108                                          TRAPS) {
2109   ResourceMark rm(THREAD);
2110   stringStream ss;
2111   bool throwException = false;
2112 
2113   {
2114     Symbol *name = k-&gt;name();
2115     ClassLoaderData *loader_data = class_loader_data(class_loader);
2116 
2117     MutexLocker mu(THREAD, SystemDictionary_lock);
2118 
2119     InstanceKlass* check = find_class(d_hash, name, loader_data-&gt;dictionary());
2120     if (check != NULL) {
2121       // If different InstanceKlass - duplicate class definition,
2122       // else - ok, class loaded by a different thread in parallel.
2123       // We should only have found it if it was done loading and ok to use.
2124       // The dictionary only holds instance classes, placeholders
2125       // also hold array classes.
2126 
2127       assert(check-&gt;is_instance_klass(), &quot;noninstance in systemdictionary&quot;);
2128       if ((defining == true) || (k != check)) {
2129         throwException = true;
2130         ss.print(&quot;loader %s&quot;, loader_data-&gt;loader_name_and_id());
2131         ss.print(&quot; attempted duplicate %s definition for %s. (%s)&quot;,
2132                  k-&gt;external_kind(), k-&gt;external_name(), k-&gt;class_in_module_of_loader(false, true));
2133       } else {
2134         return;
2135       }
2136     }
2137 
2138 #ifdef ASSERT
2139     Symbol* ph_check = find_placeholder(name, loader_data);
2140     assert(ph_check == NULL || ph_check == name, &quot;invalid symbol&quot;);
2141 #endif
2142 
2143     if (throwException == false) {
2144       if (constraints()-&gt;check_or_update(k, class_loader, name) == false) {
2145         throwException = true;
2146         ss.print(&quot;loader constraint violation: loader %s&quot;, loader_data-&gt;loader_name_and_id());
2147         ss.print(&quot; wants to load %s %s.&quot;,
2148                  k-&gt;external_kind(), k-&gt;external_name());
2149         Klass *existing_klass = constraints()-&gt;find_constrained_klass(name, class_loader);
2150         if (existing_klass != NULL &amp;&amp; existing_klass-&gt;class_loader() != class_loader()) {
2151           ss.print(&quot; A different %s with the same name was previously loaded by %s. (%s)&quot;,
2152                    existing_klass-&gt;external_kind(),
2153                    existing_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
2154                    existing_klass-&gt;class_in_module_of_loader(false, true));
2155         } else {
2156           ss.print(&quot; (%s)&quot;, k-&gt;class_in_module_of_loader(false, true));
2157         }
2158       }
2159     }
2160   }
2161 
2162   // Throw error now if needed (cannot throw while holding
2163   // SystemDictionary_lock because of rank ordering)
2164   if (throwException == true) {
2165     THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
2166   }
2167 }
2168 
2169 // Update class loader data dictionary - done after check_constraint and add_to_hierachy
2170 // have been called.
2171 void SystemDictionary::update_dictionary(unsigned int d_hash,
2172                                          int p_index, unsigned int p_hash,
2173                                          InstanceKlass* k,
2174                                          Handle class_loader,
2175                                          TRAPS) {
2176   // Compile_lock prevents systemDictionary updates during compilations
2177   assert_locked_or_safepoint(Compile_lock);
2178   Symbol*  name  = k-&gt;name();
2179   ClassLoaderData *loader_data = class_loader_data(class_loader);
2180 
2181   {
2182     MutexLocker mu1(THREAD, SystemDictionary_lock);
2183 
2184     // Make a new dictionary entry.
2185     Dictionary* dictionary = loader_data-&gt;dictionary();
2186     InstanceKlass* sd_check = find_class(d_hash, name, dictionary);
2187     if (sd_check == NULL) {
2188       dictionary-&gt;add_klass(d_hash, name, k);
2189     }
2190   #ifdef ASSERT
2191     sd_check = find_class(d_hash, name, dictionary);
2192     assert (sd_check != NULL, &quot;should have entry in dictionary&quot;);
2193     // Note: there may be a placeholder entry: for circularity testing
2194     // or for parallel defines
2195   #endif
2196     SystemDictionary_lock-&gt;notify_all();
2197   }
2198 }
2199 
2200 
2201 // Try to find a class name using the loader constraints.  The
2202 // loader constraints might know about a class that isn&#39;t fully loaded
2203 // yet and these will be ignored.
2204 Klass* SystemDictionary::find_constrained_instance_or_array_klass(
2205                     Symbol* class_name, Handle class_loader, TRAPS) {
2206 
2207   // First see if it has been loaded directly.
2208   // Force the protection domain to be null.  (This removes protection checks.)
2209   Handle no_protection_domain;
2210   Klass* klass = find_instance_or_array_klass(class_name, class_loader,
2211                                               no_protection_domain, CHECK_NULL);
2212   if (klass != NULL)
2213     return klass;
2214 
2215   // Now look to see if it has been loaded elsewhere, and is subject to
2216   // a loader constraint that would require this loader to return the
2217   // klass that is already loaded.
2218   if (Signature::is_array(class_name)) {
2219     // For array classes, their Klass*s are not kept in the
2220     // constraint table. The element Klass*s are.
2221     SignatureStream ss(class_name, false);
2222     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
2223     BasicType t = ss.type();
2224     if (t != T_OBJECT &amp;&amp; t != T_VALUETYPE) {
2225       klass = Universe::typeArrayKlassObj(t);
2226     } else {
2227       MutexLocker mu(THREAD, SystemDictionary_lock);
2228       klass = constraints()-&gt;find_constrained_klass(ss.as_symbol(), class_loader);
2229     }
2230     // If element class already loaded, allocate array klass
2231     if (klass != NULL) {
2232       klass = klass-&gt;array_klass_or_null(ArrayStorageProperties::for_signature(class_name), ndims);
2233     }
2234   } else {
2235     MutexLocker mu(THREAD, SystemDictionary_lock);
2236     // Non-array classes are easy: simply check the constraint table.
2237     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2238   }
2239 
2240   return klass;
2241 }
2242 
2243 
2244 bool SystemDictionary::add_loader_constraint(Symbol* class_name,
2245                                              Handle class_loader1,
2246                                              Handle class_loader2,
2247                                              Thread* THREAD) {
2248   ClassLoaderData* loader_data1 = class_loader_data(class_loader1);
2249   ClassLoaderData* loader_data2 = class_loader_data(class_loader2);
2250 
2251   Symbol* constraint_name = NULL;
2252 
2253   if (!Signature::is_array(class_name)) {
2254     constraint_name = class_name;
2255   } else {
2256     // For array classes, their Klass*s are not kept in the
2257     // constraint table. The element classes are.
2258     SignatureStream ss(class_name, false);
2259     ss.skip_array_prefix();  // skip all &#39;[&#39;s
2260     if (!ss.has_envelope()) {
2261       return true;     // primitive types always pass
2262     }
2263     constraint_name = ss.as_symbol();
2264     // Increment refcount to keep constraint_name alive after
2265     // SignatureStream is destructed. It will be decremented below
2266     // before returning.
2267     constraint_name-&gt;increment_refcount();
2268   }
2269 
2270   Dictionary* dictionary1 = loader_data1-&gt;dictionary();
2271   unsigned int d_hash1 = dictionary1-&gt;compute_hash(constraint_name);
2272 
2273   Dictionary* dictionary2 = loader_data2-&gt;dictionary();
2274   unsigned int d_hash2 = dictionary2-&gt;compute_hash(constraint_name);
2275 
2276   {
2277     MutexLocker mu_s(THREAD, SystemDictionary_lock);
2278     InstanceKlass* klass1 = find_class(d_hash1, constraint_name, dictionary1);
2279     InstanceKlass* klass2 = find_class(d_hash2, constraint_name, dictionary2);
2280     bool result = constraints()-&gt;add_entry(constraint_name, klass1, class_loader1,
2281                                            klass2, class_loader2);
2282     if (Signature::is_array(class_name)) {
2283       constraint_name-&gt;decrement_refcount();
2284     }
2285     return result;
2286   }
2287 }
2288 
2289 // Add entry to resolution error table to record the error when the first
2290 // attempt to resolve a reference to a class has failed.
2291 void SystemDictionary::add_resolution_error(const constantPoolHandle&amp; pool, int which,
2292                                             Symbol* error, Symbol* message) {
2293   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2294   int index = resolution_errors()-&gt;hash_to_index(hash);
2295   {
2296     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2297     resolution_errors()-&gt;add_entry(index, hash, pool, which, error, message);
2298   }
2299 }
2300 
2301 // Delete a resolution error for RedefineClasses for a constant pool is going away
2302 void SystemDictionary::delete_resolution_error(ConstantPool* pool) {
2303   resolution_errors()-&gt;delete_entry(pool);
2304 }
2305 
2306 // Lookup resolution error table. Returns error if found, otherwise NULL.
2307 Symbol* SystemDictionary::find_resolution_error(const constantPoolHandle&amp; pool, int which,
2308                                                 Symbol** message) {
2309   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2310   int index = resolution_errors()-&gt;hash_to_index(hash);
2311   {
2312     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2313     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2314     if (entry != NULL) {
2315       *message = entry-&gt;message();
2316       return entry-&gt;error();
2317     } else {
2318       return NULL;
2319     }
2320   }
2321 }
2322 
2323 
2324 // Signature constraints ensure that callers and callees agree about
2325 // the meaning of type names in their signatures.  This routine is the
2326 // intake for constraints.  It collects them from several places:
2327 //
2328 //  * LinkResolver::resolve_method (if check_access is true) requires
2329 //    that the resolving class (the caller) and the defining class of
2330 //    the resolved method (the callee) agree on each type in the
2331 //    method&#39;s signature.
2332 //
2333 //  * LinkResolver::resolve_interface_method performs exactly the same
2334 //    checks.
2335 //
2336 //  * LinkResolver::resolve_field requires that the constant pool
2337 //    attempting to link to a field agree with the field&#39;s defining
2338 //    class about the type of the field signature.
2339 //
2340 //  * klassVtable::initialize_vtable requires that, when a class
2341 //    overrides a vtable entry allocated by a superclass, that the
2342 //    overriding method (i.e., the callee) agree with the superclass
2343 //    on each type in the method&#39;s signature.
2344 //
2345 //  * klassItable::initialize_itable requires that, when a class fills
2346 //    in its itables, for each non-abstract method installed in an
2347 //    itable, the method (i.e., the callee) agree with the interface
2348 //    on each type in the method&#39;s signature.
2349 //
2350 // All those methods have a boolean (check_access, checkconstraints)
2351 // which turns off the checks.  This is used from specialized contexts
2352 // such as bootstrapping, dumping, and debugging.
2353 //
2354 // No direct constraint is placed between the class and its
2355 // supertypes.  Constraints are only placed along linked relations
2356 // between callers and callees.  When a method overrides or implements
2357 // an abstract method in a supertype (superclass or interface), the
2358 // constraints are placed as if the supertype were the caller to the
2359 // overriding method.  (This works well, since callers to the
2360 // supertype have already established agreement between themselves and
2361 // the supertype.)  As a result of all this, a class can disagree with
2362 // its supertype about the meaning of a type name, as long as that
2363 // class neither calls a relevant method of the supertype, nor is
2364 // called (perhaps via an override) from the supertype.
2365 //
2366 //
2367 // SystemDictionary::check_signature_loaders(sig, l1, l2)
2368 //
2369 // Make sure all class components (including arrays) in the given
2370 // signature will be resolved to the same class in both loaders.
2371 // Returns the name of the type that failed a loader constraint check, or
2372 // NULL if no constraint failed.  No exception except OOME is thrown.
2373 // Arrays are not added to the loader constraint table, their elements are.
2374 Symbol* SystemDictionary::check_signature_loaders(Symbol* signature,
2375                                                Handle loader1, Handle loader2,
2376                                                bool is_method, TRAPS)  {
2377   // Nothing to do if loaders are the same.
2378   if (loader1() == loader2()) {
2379     return NULL;
2380   }
2381 
2382   for (SignatureStream ss(signature, is_method); !ss.is_done(); ss.next()) {
2383     if (ss.is_reference()) {
2384       Symbol* sig = ss.as_symbol();
2385       // Note: In the future, if template-like types can take
2386       // arguments, we will want to recognize them and dig out class
2387       // names hiding inside the argument lists.
2388       if (!add_loader_constraint(sig, loader1, loader2, THREAD)) {
2389         return sig;
2390       }
2391     }
2392   }
2393   return NULL;
2394 }
2395 
2396 
2397 Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsics::ID iid,
2398                                                        Symbol* signature,
2399                                                        TRAPS) {
2400   methodHandle empty;
2401   assert(MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
2402          MethodHandles::is_signature_polymorphic_intrinsic(iid) &amp;&amp;
2403          iid != vmIntrinsics::_invokeGeneric,
2404          &quot;must be a known MH intrinsic iid=%d: %s&quot;, iid, vmIntrinsics::name_at(iid));
2405 
2406   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, iid);
2407   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2408   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2409   methodHandle m;
2410   if (spe == NULL || spe-&gt;method() == NULL) {
2411     spe = NULL;
2412     // Must create lots of stuff here, but outside of the SystemDictionary lock.
2413     m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);
2414     if (!Arguments::is_interpreter_only()) {
2415       // Generate a compiled form of the MH intrinsic.
2416       AdapterHandlerLibrary::create_native_wrapper(m);
2417       // Check if have the compiled code.
2418       if (!m-&gt;has_compiled_code()) {
2419         THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),
2420                        &quot;Out of space in CodeCache for method handle intrinsic&quot;);
2421       }
2422     }
2423     // Now grab the lock.  We might have to throw away the new method,
2424     // if a racing thread has managed to install one at the same time.
2425     {
2426       MutexLocker ml(THREAD, SystemDictionary_lock);
2427       spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2428       if (spe == NULL)
2429         spe = invoke_method_table()-&gt;add_entry(index, hash, signature, iid);
2430       if (spe-&gt;method() == NULL)
2431         spe-&gt;set_method(m());
2432     }
2433   }
2434 
2435   assert(spe != NULL &amp;&amp; spe-&gt;method() != NULL, &quot;&quot;);
2436   assert(Arguments::is_interpreter_only() || (spe-&gt;method()-&gt;has_compiled_code() &amp;&amp;
2437          spe-&gt;method()-&gt;code()-&gt;entry_point() == spe-&gt;method()-&gt;from_compiled_entry()),
2438          &quot;MH intrinsic invariant&quot;);
2439   return spe-&gt;method();
2440 }
2441 
2442 // Helper for unpacking the return value from linkMethod and linkCallSite.
2443 static Method* unpack_method_and_appendix(Handle mname,
2444                                           Klass* accessing_klass,
2445                                           objArrayHandle appendix_box,
2446                                           Handle* appendix_result,
2447                                           TRAPS) {
2448   if (mname.not_null()) {
2449     Method* m = java_lang_invoke_MemberName::vmtarget(mname());
2450     if (m != NULL) {
2451       oop appendix = appendix_box-&gt;obj_at(0);
2452       if (TraceMethodHandles) {
2453     #ifndef PRODUCT
2454         ttyLocker ttyl;
2455         tty-&gt;print(&quot;Linked method=&quot; INTPTR_FORMAT &quot;: &quot;, p2i(m));
2456         m-&gt;print();
2457         if (appendix != NULL) { tty-&gt;print(&quot;appendix = &quot;); appendix-&gt;print(); }
2458         tty-&gt;cr();
2459     #endif //PRODUCT
2460       }
2461       (*appendix_result) = Handle(THREAD, appendix);
2462       // the target is stored in the cpCache and if a reference to this
2463       // MemberName is dropped we need a way to make sure the
2464       // class_loader containing this method is kept alive.
2465       methodHandle mh(THREAD, m); // record_dependency can safepoint.
2466       ClassLoaderData* this_key = accessing_klass-&gt;class_loader_data();
2467       this_key-&gt;record_dependency(m-&gt;method_holder());
2468       return mh();
2469     }
2470   }
2471   THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;bad value from MethodHandleNatives&quot;);
2472 }
2473 
2474 Method* SystemDictionary::find_method_handle_invoker(Klass* klass,
2475                                                      Symbol* name,
2476                                                      Symbol* signature,
2477                                                           Klass* accessing_klass,
2478                                                           Handle *appendix_result,
2479                                                           TRAPS) {
2480   assert(THREAD-&gt;can_call_java() ,&quot;&quot;);
2481   Handle method_type =
2482     SystemDictionary::find_method_handle_type(signature, accessing_klass, CHECK_NULL);
2483 
2484   int ref_kind = JVM_REF_invokeVirtual;
2485   oop name_oop = StringTable::intern(name, CHECK_NULL);
2486   Handle name_str (THREAD, name_oop);
2487   objArrayHandle appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK_NULL);
2488   assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
2489 
2490   // This should not happen.  JDK code should take care of that.
2491   if (accessing_klass == NULL || method_type.is_null()) {
2492     THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;bad invokehandle&quot;);
2493   }
2494 
2495   // call java.lang.invoke.MethodHandleNatives::linkMethod(... String, MethodType) -&gt; MemberName
2496   JavaCallArguments args;
2497   args.push_oop(Handle(THREAD, accessing_klass-&gt;java_mirror()));
2498   args.push_int(ref_kind);
2499   args.push_oop(Handle(THREAD, klass-&gt;java_mirror()));
2500   args.push_oop(name_str);
2501   args.push_oop(method_type);
2502   args.push_oop(appendix_box);
2503   JavaValue result(T_OBJECT);
2504   JavaCalls::call_static(&amp;result,
2505                          SystemDictionary::MethodHandleNatives_klass(),
2506                          vmSymbols::linkMethod_name(),
2507                          vmSymbols::linkMethod_signature(),
2508                          &amp;args, CHECK_NULL);
2509   Handle mname(THREAD, (oop) result.get_jobject());
2510   return unpack_method_and_appendix(mname, accessing_klass, appendix_box, appendix_result, THREAD);
2511 }
2512 
2513 // Decide if we can globally cache a lookup of this class, to be returned to any client that asks.
2514 // We must ensure that all class loaders everywhere will reach this class, for any client.
2515 // This is a safe bet for public classes in java.lang, such as Object and String.
2516 // We also include public classes in java.lang.invoke, because they appear frequently in system-level method types.
2517 // Out of an abundance of caution, we do not include any other classes, not even for packages like java.util.
2518 static bool is_always_visible_class(oop mirror) {
2519   Klass* klass = java_lang_Class::as_Klass(mirror);
2520   if (klass-&gt;is_objArray_klass()) {
2521     klass = ObjArrayKlass::cast(klass)-&gt;bottom_klass(); // check element type
2522   }
2523   if (klass-&gt;is_typeArray_klass()) {
2524     return true; // primitive array
2525   }
2526   assert(klass-&gt;is_instance_klass(), &quot;%s&quot;, klass-&gt;external_name());
2527   return klass-&gt;is_public() &amp;&amp;
2528          (InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::Object_klass()) ||       // java.lang
2529           InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::MethodHandle_klass()));  // java.lang.invoke
2530 }
2531 
<a name="26" id="anc26"></a><span class="line-modified">2532 // Find or construct the Java mirror (java.lang.Class instance) for a</span>
<span class="line-modified">2533 // for the given field type signature, as interpreted relative to the</span>
2534 // given class loader.  Handles primitives, void, references, arrays,
2535 // and all other reflectable types, except method types.
2536 // N.B.  Code in reflection should use this entry point.
2537 Handle SystemDictionary::find_java_mirror_for_type(Symbol* signature,
2538                                                    Klass* accessing_klass,
2539                                                    Handle class_loader,
2540                                                    Handle protection_domain,
2541                                                    SignatureStream::FailureMode failure_mode,
2542                                                    TRAPS) {
<a name="27" id="anc27"></a><span class="line-removed">2543   Handle empty;</span>
<span class="line-removed">2544 </span>
2545   assert(accessing_klass == NULL || (class_loader.is_null() &amp;&amp; protection_domain.is_null()),
2546          &quot;one or the other, or perhaps neither&quot;);
2547 
<a name="28" id="anc28"></a><span class="line-removed">2548   SignatureStream ss(signature, false);</span>
<span class="line-removed">2549 </span>
2550   // What we have here must be a valid field descriptor,
2551   // and all valid field descriptors are supported.
2552   // Produce the same java.lang.Class that reflection reports.
<a name="29" id="anc29"></a><span class="line-modified">2553   if (ss.is_primitive() || (ss.type() == T_VOID)) {</span>
<span class="line-modified">2554 </span>
<span class="line-modified">2555     // It&#39;s a primitive.  (Void has a primitive mirror too.)</span>
<span class="line-modified">2556     return Handle(THREAD, java_lang_Class::primitive_mirror(ss.type()));</span>
<span class="line-modified">2557 </span>
<span class="line-modified">2558   } else if (ss.is_reference()) {</span>
<span class="line-modified">2559 </span>
<span class="line-modified">2560     // It&#39;s a reference type.</span>
<span class="line-modified">2561     if (accessing_klass != NULL) {</span>
<span class="line-modified">2562       class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());</span>
<span class="line-removed">2563       protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());</span>
<span class="line-removed">2564     }</span>
<span class="line-removed">2565     Klass* constant_type_klass;</span>
<span class="line-removed">2566     if (failure_mode == SignatureStream::ReturnNull) {</span>
<span class="line-removed">2567       constant_type_klass = resolve_or_null(signature, class_loader, protection_domain,</span>
<span class="line-removed">2568                                             CHECK_(empty));</span>
<span class="line-removed">2569     } else {</span>
<span class="line-removed">2570       bool throw_error = (failure_mode == SignatureStream::NCDFError);</span>
<span class="line-removed">2571       constant_type_klass = resolve_or_fail(signature, class_loader, protection_domain,</span>
<span class="line-removed">2572                                             throw_error, CHECK_(empty));</span>
<span class="line-removed">2573     }</span>
<span class="line-removed">2574     if (constant_type_klass == NULL) {</span>
<span class="line-removed">2575       return Handle();  // report failure this way</span>
<span class="line-removed">2576     }</span>
<span class="line-removed">2577     Handle mirror(THREAD, constant_type_klass-&gt;java_mirror());</span>
2578 
<a name="30" id="anc30"></a>
2579     // Check accessibility, emulating ConstantPool::verify_constant_pool_resolve.
<a name="31" id="anc31"></a><span class="line-modified">2580     if (accessing_klass != NULL) {</span>
<span class="line-modified">2581       Klass* sel_klass = constant_type_klass;</span>
2582       bool fold_type_to_class = true;
2583       LinkResolver::check_klass_accessability(accessing_klass, sel_klass,
<a name="32" id="anc32"></a><span class="line-modified">2584                                               fold_type_to_class, CHECK_(empty));</span>
2585     }
<a name="33" id="anc33"></a><span class="line-removed">2586 </span>
<span class="line-removed">2587     return mirror;</span>
<span class="line-removed">2588 </span>
2589   }
<a name="34" id="anc34"></a><span class="line-modified">2590 </span>
<span class="line-removed">2591   // Fall through to an error.</span>
<span class="line-removed">2592   assert(false, &quot;unsupported mirror syntax&quot;);</span>
<span class="line-removed">2593   THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;unsupported mirror syntax&quot;, empty);</span>
2594 }
2595 
2596 
2597 // Ask Java code to find or construct a java.lang.invoke.MethodType for the given
2598 // signature, as interpreted relative to the given class loader.
2599 // Because of class loader constraints, all method handle usage must be
2600 // consistent with this loader.
2601 Handle SystemDictionary::find_method_handle_type(Symbol* signature,
2602                                                  Klass* accessing_klass,
2603                                                  TRAPS) {
2604   Handle empty;
2605   vmIntrinsics::ID null_iid = vmIntrinsics::_none;  // distinct from all method handle invoker intrinsics
2606   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, null_iid);
2607   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2608   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2609   if (spe != NULL &amp;&amp; spe-&gt;method_type() != NULL) {
2610     assert(java_lang_invoke_MethodType::is_instance(spe-&gt;method_type()), &quot;&quot;);
2611     return Handle(THREAD, spe-&gt;method_type());
2612   } else if (!THREAD-&gt;can_call_java()) {
2613     warning(&quot;SystemDictionary::find_method_handle_type called from compiler thread&quot;);  // FIXME
2614     return Handle();  // do not attempt from within compiler, unless it was cached
2615   }
2616 
2617   Handle class_loader, protection_domain;
2618   if (accessing_klass != NULL) {
2619     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2620     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2621   }
2622   bool can_be_cached = true;
2623   int npts = ArgumentCount(signature).size();
2624   objArrayHandle pts = oopFactory::new_objArray_handle(SystemDictionary::Class_klass(), npts, CHECK_(empty));
2625   int arg = 0;
2626   Handle rt; // the return type from the signature
2627   ResourceMark rm(THREAD);
2628   for (SignatureStream ss(signature); !ss.is_done(); ss.next()) {
2629     oop mirror = NULL;
2630     if (can_be_cached) {
2631       // Use neutral class loader to lookup candidate classes to be placed in the cache.
2632       mirror = ss.as_java_mirror(Handle(), Handle(),
2633                                  SignatureStream::ReturnNull, CHECK_(empty));
2634       if (mirror == NULL || (ss.is_reference() &amp;&amp; !is_always_visible_class(mirror))) {
2635         // Fall back to accessing_klass context.
2636         can_be_cached = false;
2637       }
2638     }
2639     if (!can_be_cached) {
2640       // Resolve, throwing a real error if it doesn&#39;t work.
2641       mirror = ss.as_java_mirror(class_loader, protection_domain,
2642                                  SignatureStream::NCDFError, CHECK_(empty));
2643     }
2644     assert(mirror != NULL, &quot;%s&quot;, ss.as_symbol()-&gt;as_C_string());
2645     if (ss.at_return_type())
2646       rt = Handle(THREAD, mirror);
2647     else
2648       pts-&gt;obj_at_put(arg++, mirror);
2649 
2650     // Check accessibility.
2651     if (!java_lang_Class::is_primitive(mirror) &amp;&amp; accessing_klass != NULL) {
2652       Klass* sel_klass = java_lang_Class::as_Klass(mirror);
2653       mirror = NULL;  // safety
2654       // Emulate ConstantPool::verify_constant_pool_resolve.
2655       bool fold_type_to_class = true;
2656       LinkResolver::check_klass_accessability(accessing_klass, sel_klass,
2657                                               fold_type_to_class, CHECK_(empty));
2658     }
2659   }
2660   assert(arg == npts, &quot;&quot;);
2661 
2662   // call java.lang.invoke.MethodHandleNatives::findMethodHandleType(Class rt, Class[] pts) -&gt; MethodType
2663   JavaCallArguments args(Handle(THREAD, rt()));
2664   args.push_oop(pts);
2665   JavaValue result(T_OBJECT);
2666   JavaCalls::call_static(&amp;result,
2667                          SystemDictionary::MethodHandleNatives_klass(),
2668                          vmSymbols::findMethodHandleType_name(),
2669                          vmSymbols::findMethodHandleType_signature(),
2670                          &amp;args, CHECK_(empty));
2671   Handle method_type(THREAD, (oop) result.get_jobject());
2672 
2673   if (can_be_cached) {
2674     // We can cache this MethodType inside the JVM.
2675     MutexLocker ml(THREAD, SystemDictionary_lock);
2676     spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2677     if (spe == NULL)
2678       spe = invoke_method_table()-&gt;add_entry(index, hash, signature, null_iid);
2679     if (spe-&gt;method_type() == NULL) {
2680       spe-&gt;set_method_type(method_type());
2681     }
2682   }
2683 
2684   // report back to the caller with the MethodType
2685   return method_type;
2686 }
2687 
2688 Handle SystemDictionary::find_field_handle_type(Symbol* signature,
2689                                                 Klass* accessing_klass,
2690                                                 TRAPS) {
2691   Handle empty;
2692   ResourceMark rm(THREAD);
2693   SignatureStream ss(signature, /*is_method=*/ false);
2694   if (!ss.is_done()) {
2695     Handle class_loader, protection_domain;
2696     if (accessing_klass != NULL) {
2697       class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2698       protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2699     }
2700     oop mirror = ss.as_java_mirror(class_loader, protection_domain, SignatureStream::NCDFError, CHECK_(empty));
2701     ss.next();
2702     if (ss.is_done()) {
2703       return Handle(THREAD, mirror);
2704     }
2705   }
2706   return empty;
2707 }
2708 
2709 // Ask Java code to find or construct a method handle constant.
2710 Handle SystemDictionary::link_method_handle_constant(Klass* caller,
2711                                                      int ref_kind, //e.g., JVM_REF_invokeVirtual
2712                                                      Klass* callee,
2713                                                      Symbol* name,
2714                                                      Symbol* signature,
2715                                                      TRAPS) {
2716   Handle empty;
2717   if (caller == NULL) {
2718     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;bad MH constant&quot;, empty);
2719   }
2720   Handle name_str      = java_lang_String::create_from_symbol(name,      CHECK_(empty));
2721   Handle signature_str = java_lang_String::create_from_symbol(signature, CHECK_(empty));
2722 
2723   // Put symbolic info from the MH constant into freshly created MemberName and resolve it.
2724   Handle mname = MemberName_klass()-&gt;allocate_instance_handle(CHECK_(empty));
2725   java_lang_invoke_MemberName::set_clazz(mname(), callee-&gt;java_mirror());
2726   java_lang_invoke_MemberName::set_name (mname(), name_str());
2727   java_lang_invoke_MemberName::set_type (mname(), signature_str());
2728   java_lang_invoke_MemberName::set_flags(mname(), MethodHandles::ref_kind_to_flags(ref_kind));
2729 
2730   if (ref_kind == JVM_REF_invokeVirtual &amp;&amp;
2731       MethodHandles::is_signature_polymorphic_public_name(callee, name)) {
2732     // Skip resolution for public signature polymorphic methods such as
2733     // j.l.i.MethodHandle.invoke()/invokeExact() and those on VarHandle
2734     // They require appendix argument which MemberName resolution doesn&#39;t handle.
2735     // There&#39;s special logic on JDK side to handle them
2736     // (see MethodHandles.linkMethodHandleConstant() and MethodHandles.findVirtualForMH()).
2737   } else {
2738     MethodHandles::resolve_MemberName(mname, caller, /*speculative_resolve*/false, CHECK_(empty));
2739   }
2740 
2741   // After method/field resolution succeeded, it&#39;s safe to resolve MH signature as well.
2742   Handle type = MethodHandles::resolve_MemberName_type(mname, caller, CHECK_(empty));
2743 
2744   // call java.lang.invoke.MethodHandleNatives::linkMethodHandleConstant(Class caller, int refKind, Class callee, String name, Object type) -&gt; MethodHandle
2745   JavaCallArguments args;
2746   args.push_oop(Handle(THREAD, caller-&gt;java_mirror()));  // the referring class
2747   args.push_int(ref_kind);
2748   args.push_oop(Handle(THREAD, callee-&gt;java_mirror()));  // the target class
2749   args.push_oop(name_str);
2750   args.push_oop(type);
2751   JavaValue result(T_OBJECT);
2752   JavaCalls::call_static(&amp;result,
2753                          SystemDictionary::MethodHandleNatives_klass(),
2754                          vmSymbols::linkMethodHandleConstant_name(),
2755                          vmSymbols::linkMethodHandleConstant_signature(),
2756                          &amp;args, CHECK_(empty));
2757   return Handle(THREAD, (oop) result.get_jobject());
2758 }
2759 
2760 // Ask Java to run a bootstrap method, in order to create a dynamic call site
2761 // while linking an invokedynamic op, or compute a constant for Dynamic_info CP entry
2762 // with linkage results being stored back into the bootstrap specifier.
2763 void SystemDictionary::invoke_bootstrap_method(BootstrapInfo&amp; bootstrap_specifier, TRAPS) {
2764   // Resolve the bootstrap specifier, its name, type, and static arguments
2765   bootstrap_specifier.resolve_bsm(CHECK);
2766 
2767   // This should not happen.  JDK code should take care of that.
2768   if (bootstrap_specifier.caller() == NULL || bootstrap_specifier.type_arg().is_null()) {
2769     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;Invalid bootstrap method invocation with no caller or type argument&quot;);
2770   }
2771 
2772   bool is_indy = bootstrap_specifier.is_method_call();
2773   objArrayHandle appendix_box;
2774   if (is_indy) {
2775     // Some method calls may require an appendix argument.  Arrange to receive it.
2776     appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK);
2777     assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
2778   }
2779 
2780   // call condy: java.lang.invoke.MethodHandleNatives::linkDynamicConstant(caller, condy_index, bsm, type, info)
2781   //       indy: java.lang.invoke.MethodHandleNatives::linkCallSite(caller, indy_index, bsm, name, mtype, info, &amp;appendix)
2782   JavaCallArguments args;
2783   args.push_oop(Handle(THREAD, bootstrap_specifier.caller_mirror()));
2784   args.push_int(bootstrap_specifier.bss_index());
2785   args.push_oop(bootstrap_specifier.bsm());
2786   args.push_oop(bootstrap_specifier.name_arg());
2787   args.push_oop(bootstrap_specifier.type_arg());
2788   args.push_oop(bootstrap_specifier.arg_values());
2789   if (is_indy) {
2790     args.push_oop(appendix_box);
2791   }
2792   JavaValue result(T_OBJECT);
2793   JavaCalls::call_static(&amp;result,
2794                          SystemDictionary::MethodHandleNatives_klass(),
2795                          is_indy ? vmSymbols::linkCallSite_name() : vmSymbols::linkDynamicConstant_name(),
2796                          is_indy ? vmSymbols::linkCallSite_signature() : vmSymbols::linkDynamicConstant_signature(),
2797                          &amp;args, CHECK);
2798 
2799   Handle value(THREAD, (oop) result.get_jobject());
2800   if (is_indy) {
2801     Handle appendix;
2802     Method* method = unpack_method_and_appendix(value,
2803                                                 bootstrap_specifier.caller(),
2804                                                 appendix_box,
2805                                                 &amp;appendix, CHECK);
2806     methodHandle mh(THREAD, method);
2807     bootstrap_specifier.set_resolved_method(mh, appendix);
2808   } else {
2809     bootstrap_specifier.set_resolved_value(value);
2810   }
2811 
2812   // sanity check
2813   assert(bootstrap_specifier.is_resolved() ||
2814          (bootstrap_specifier.is_method_call() &amp;&amp;
2815           bootstrap_specifier.resolved_method().not_null()), &quot;bootstrap method call failed&quot;);
2816 }
2817 
2818 // Protection domain cache table handling
2819 
2820 ProtectionDomainCacheEntry* SystemDictionary::cache_get(Handle protection_domain) {
2821   return _pd_cache_table-&gt;get(protection_domain);
2822 }
2823 
2824 // ----------------------------------------------------------------------------
2825 
2826 void SystemDictionary::print_on(outputStream *st) {
2827   CDS_ONLY(SystemDictionaryShared::print_on(st));
2828   GCMutexLocker mu(SystemDictionary_lock);
2829 
2830   ClassLoaderDataGraph::print_dictionary(st);
2831 
2832   // Placeholders
2833   placeholders()-&gt;print_on(st);
2834   st-&gt;cr();
2835 
2836   // loader constraints - print under SD_lock
2837   constraints()-&gt;print_on(st);
2838   st-&gt;cr();
2839 
2840   _pd_cache_table-&gt;print_on(st);
2841   st-&gt;cr();
2842 }
2843 
2844 void SystemDictionary::print() { print_on(tty); }
2845 
2846 void SystemDictionary::verify() {
2847   guarantee(constraints() != NULL,
2848             &quot;Verify of loader constraints failed&quot;);
2849   guarantee(placeholders()-&gt;number_of_entries() &gt;= 0,
2850             &quot;Verify of placeholders failed&quot;);
2851 
2852   GCMutexLocker mu(SystemDictionary_lock);
2853 
2854   // Verify dictionary
2855   ClassLoaderDataGraph::verify_dictionary();
2856 
2857   placeholders()-&gt;verify();
2858 
2859   // Verify constraint table
2860   guarantee(constraints() != NULL, &quot;Verify of loader constraints failed&quot;);
2861   constraints()-&gt;verify(placeholders());
2862 
2863   _pd_cache_table-&gt;verify();
2864 }
2865 
2866 void SystemDictionary::dump(outputStream *st, bool verbose) {
2867   assert_locked_or_safepoint(SystemDictionary_lock);
2868   if (verbose) {
2869     print_on(st);
2870   } else {
2871     CDS_ONLY(SystemDictionaryShared::print_table_statistics(st));
2872     ClassLoaderDataGraph::print_table_statistics(st);
2873     placeholders()-&gt;print_table_statistics(st, &quot;Placeholder Table&quot;);
2874     constraints()-&gt;print_table_statistics(st, &quot;LoaderConstraints Table&quot;);
2875     pd_cache_table()-&gt;print_table_statistics(st, &quot;ProtectionDomainCache Table&quot;);
2876   }
2877 }
2878 
2879 TableStatistics SystemDictionary::placeholders_statistics() {
2880   MutexLocker ml(SystemDictionary_lock);
2881   return placeholders()-&gt;statistics_calculate();
2882 }
2883 
2884 TableStatistics SystemDictionary::loader_constraints_statistics() {
2885   MutexLocker ml(SystemDictionary_lock);
2886   return constraints()-&gt;statistics_calculate();
2887 }
2888 
2889 TableStatistics SystemDictionary::protection_domain_cache_statistics() {
2890   MutexLocker ml(SystemDictionary_lock);
2891   return pd_cache_table()-&gt;statistics_calculate();
2892 }
2893 
2894 // Utility for dumping dictionaries.
2895 SystemDictionaryDCmd::SystemDictionaryDCmd(outputStream* output, bool heap) :
2896                                  DCmdWithParser(output, heap),
2897   _verbose(&quot;-verbose&quot;, &quot;Dump the content of each dictionary entry for all class loaders&quot;,
2898            &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
2899   _dcmdparser.add_dcmd_option(&amp;_verbose);
2900 }
2901 
2902 void SystemDictionaryDCmd::execute(DCmdSource source, TRAPS) {
2903   VM_DumpHashtable dumper(output(), VM_DumpHashtable::DumpSysDict,
2904                          _verbose.value());
2905   VMThread::execute(&amp;dumper);
2906 }
2907 
2908 int SystemDictionaryDCmd::num_arguments() {
2909   ResourceMark rm;
2910   SystemDictionaryDCmd* dcmd = new SystemDictionaryDCmd(NULL, false);
2911   if (dcmd != NULL) {
2912     DCmdMark mark(dcmd);
2913     return dcmd-&gt;_dcmdparser.num_arguments();
2914   } else {
2915     return 0;
2916   }
2917 }
<a name="35" id="anc35"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="35" type="hidden" />
</body>
</html>
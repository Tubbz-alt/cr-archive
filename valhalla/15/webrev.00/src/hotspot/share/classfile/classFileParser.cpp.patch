diff a/src/hotspot/share/classfile/classFileParser.cpp b/src/hotspot/share/classfile/classFileParser.cpp
--- a/src/hotspot/share/classfile/classFileParser.cpp
+++ b/src/hotspot/share/classfile/classFileParser.cpp
@@ -5682,11 +5682,11 @@
           int newlen = c - (char*) signature;
           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
           if (!legal) {
             classfile_parse_error("Class name is empty or contains illegal character "
                                   "in descriptor in class file %s",
-                                  CHECK_0);
+                                  CHECK_NULL);
             return NULL;
           }
           return signature + newlen + 1;
         }
       }
@@ -5694,11 +5694,11 @@
     }
     case JVM_SIGNATURE_ARRAY:
       array_dim++;
       if (array_dim > 255) {
         // 4277370: array descriptor is valid only if it represents 255 or fewer dimensions.
-        classfile_parse_error("Array type descriptor has more than 255 dimensions in class file %s", CHECK_0);
+        classfile_parse_error("Array type descriptor has more than 255 dimensions in class file %s", CHECK_NULL);
       }
       // The rest of what's there better be a legal signature
       signature++;
       length--;
       void_ok = false;
@@ -6354,20 +6354,20 @@
 // its _class_name field.
 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
   ResourceMark rm(THREAD);
   assert(strrchr(_class_name->as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
          "Unsafe anonymous class should not be in a package");
-  const char* host_pkg_name =
-    ClassLoader::package_from_name(unsafe_anonymous_host->name()->as_C_string(), NULL);
+  TempNewSymbol host_pkg_name =
+    ClassLoader::package_from_class_name(unsafe_anonymous_host->name());
 
   if (host_pkg_name != NULL) {
-    int host_pkg_len = (int)strlen(host_pkg_name);
+    int host_pkg_len = host_pkg_name->utf8_length();
     int class_name_len = _class_name->utf8_length();
     int symbol_len = host_pkg_len + 1 + class_name_len;
     char* new_anon_name = NEW_RESOURCE_ARRAY(char, symbol_len + 1);
-    int n = os::snprintf(new_anon_name, symbol_len + 1, "%s/%.*s",
-                         host_pkg_name, class_name_len, _class_name->base());
+    int n = os::snprintf(new_anon_name, symbol_len + 1, "%.*s/%.*s",
+                         host_pkg_len, host_pkg_name->base(), class_name_len, _class_name->base());
     assert(n == symbol_len, "Unexpected number of characters in string");
 
     // Decrement old _class_name to avoid leaking.
     _class_name->decrement_refcount();
 

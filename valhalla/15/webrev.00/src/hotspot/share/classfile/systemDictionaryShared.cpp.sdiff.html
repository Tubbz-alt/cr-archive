<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionaryShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="systemDictionary.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionaryShared.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionaryShared.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  59 #include &quot;utilities/resourceHash.hpp&quot;
  60 #include &quot;utilities/stringUtils.hpp&quot;
  61 
  62 
  63 objArrayOop SystemDictionaryShared::_shared_protection_domains  =  NULL;
  64 objArrayOop SystemDictionaryShared::_shared_jar_urls            =  NULL;
  65 objArrayOop SystemDictionaryShared::_shared_jar_manifests       =  NULL;
  66 DEBUG_ONLY(bool SystemDictionaryShared::_no_class_loading_should_happen = false;)
  67 
  68 class DumpTimeSharedClassInfo: public CHeapObj&lt;mtClass&gt; {
  69   bool                         _excluded;
  70 public:
  71   struct DTConstraint {
  72     Symbol* _name;
  73     Symbol* _from_name;
  74     DTConstraint() : _name(NULL), _from_name(NULL) {}
  75     DTConstraint(Symbol* n, Symbol* fn) : _name(n), _from_name(fn) {}
  76   };
  77 
  78   InstanceKlass*               _klass;

  79   int                          _id;
  80   int                          _clsfile_size;
  81   int                          _clsfile_crc32;
  82   GrowableArray&lt;DTConstraint&gt;* _verifier_constraints;
  83   GrowableArray&lt;char&gt;*         _verifier_constraint_flags;
  84 
  85   DumpTimeSharedClassInfo() {
  86     _klass = NULL;

  87     _id = -1;
  88     _clsfile_size = -1;
  89     _clsfile_crc32 = -1;
  90     _excluded = false;
  91     _verifier_constraints = NULL;
  92     _verifier_constraint_flags = NULL;
  93   }
  94 
  95   void add_verification_constraint(InstanceKlass* k, Symbol* name,
  96          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object);
  97 
  98   bool is_builtin() {
  99     return SystemDictionaryShared::is_builtin(_klass);
 100   }
 101 
 102   int num_constraints() {
 103     if (_verifier_constraint_flags != NULL) {
 104       return _verifier_constraint_flags-&gt;length();
 105     } else {
 106       return 0;
 107     }
 108   }
 109 
 110   void metaspace_pointers_do(MetaspaceClosure* it) {
 111     it-&gt;push(&amp;_klass);
 112     if (_verifier_constraints != NULL) {
 113       for (int i = 0; i &lt; _verifier_constraints-&gt;length(); i++) {
 114         DTConstraint* cons = _verifier_constraints-&gt;adr_at(i);
 115         it-&gt;push(&amp;cons-&gt;_name);
 116         it-&gt;push(&amp;cons-&gt;_from_name);
 117       }
 118     }
 119   }
 120 
 121   void set_excluded() {
 122     _excluded = true;
 123   }
 124 
 125   bool is_excluded() {
 126     // _klass may become NULL due to DynamicArchiveBuilder::set_to_null
<span class="line-modified"> 127     return _excluded || _klass == NULL;</span>








 128   }
 129 };
 130 
 131 class DumpTimeSharedClassTable: public ResourceHashtable&lt;
 132   InstanceKlass*,
 133   DumpTimeSharedClassInfo,
 134   primitive_hash&lt;InstanceKlass*&gt;,
 135   primitive_equals&lt;InstanceKlass*&gt;,
 136   15889, // prime number
 137   ResourceObj::C_HEAP&gt;
 138 {
 139   int _builtin_count;
 140   int _unregistered_count;
 141 public:
 142   DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k) {
 143     DumpTimeSharedClassInfo* p = get(k);
 144     if (p == NULL) {
 145       assert(!SystemDictionaryShared::no_class_loading_should_happen(),
 146              &quot;no new classes can be loaded while dumping archive&quot;);
 147       put(k, DumpTimeSharedClassInfo());
</pre>
<hr />
<pre>
 416     const char* path = FileMapInfo::shared_path_name(shared_path_index);
 417     Handle path_string = java_lang_String::create_from_str(path, CHECK_(url_h));
 418     Klass* classLoaders_klass =
 419         SystemDictionary::jdk_internal_loader_ClassLoaders_klass();
 420     JavaCalls::call_static(&amp;result, classLoaders_klass,
 421                            vmSymbols::toFileURL_name(),
 422                            vmSymbols::toFileURL_signature(),
 423                            path_string, CHECK_(url_h));
 424 
 425     atomic_set_shared_jar_url(shared_path_index, (oop)result.get_jobject());
 426   }
 427 
 428   url_h = Handle(THREAD, shared_jar_url(shared_path_index));
 429   assert(url_h.not_null(), &quot;sanity&quot;);
 430   return url_h;
 431 }
 432 
 433 Handle SystemDictionaryShared::get_package_name(Symbol* class_name, TRAPS) {
 434   ResourceMark rm(THREAD);
 435   Handle pkgname_string;
<span class="line-modified"> 436   char* pkgname = (char*) ClassLoader::package_from_name((const char*) class_name-&gt;as_C_string());</span>
<span class="line-modified"> 437   if (pkgname != NULL) { // Package prefix found</span>
<span class="line-modified"> 438     StringUtils::replace_no_expand(pkgname, &quot;/&quot;, &quot;.&quot;);</span>
 439     pkgname_string = java_lang_String::create_from_str(pkgname,
 440                                                        CHECK_(pkgname_string));
 441   }
 442   return pkgname_string;
 443 }
 444 
 445 // Define Package for shared app classes from JAR file and also checks for
 446 // package sealing (all done in Java code)
 447 // See http://docs.oracle.com/javase/tutorial/deployment/jar/sealman.html
 448 void SystemDictionaryShared::define_shared_package(Symbol*  class_name,
 449                                                    Handle class_loader,
 450                                                    Handle manifest,
 451                                                    Handle url,
 452                                                    TRAPS) {
 453   assert(SystemDictionary::is_system_class_loader(class_loader()), &quot;unexpected class loader&quot;);
 454   // get_package_name() returns a NULL handle if the class is in unnamed package
 455   Handle pkgname_string = get_package_name(class_name, CHECK);
 456   if (pkgname_string.not_null()) {
 457     Klass* app_classLoader_klass = SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass();
 458     JavaValue result(T_OBJECT);
</pre>
<hr />
<pre>
 575 // Initializes the java.lang.Package and java.security.ProtectionDomain objects associated with
 576 // the given InstanceKlass.
 577 // Returns the ProtectionDomain for the InstanceKlass.
 578 Handle SystemDictionaryShared::init_security_info(Handle class_loader, InstanceKlass* ik, TRAPS) {
 579   Handle pd;
 580 
 581   if (ik != NULL) {
 582     int index = ik-&gt;shared_classpath_index();
 583     assert(index &gt;= 0, &quot;Sanity&quot;);
 584     SharedClassPathEntry* ent = FileMapInfo::shared_path(index);
 585     Symbol* class_name = ik-&gt;name();
 586 
 587     if (ent-&gt;is_modules_image()) {
 588       // For shared app/platform classes originated from the run-time image:
 589       //   The ProtectionDomains are cached in the corresponding ModuleEntries
 590       //   for fast access by the VM.
 591       ResourceMark rm;
 592       ClassLoaderData *loader_data =
 593                 ClassLoaderData::class_loader_data(class_loader());
 594       PackageEntryTable* pkgEntryTable = loader_data-&gt;packages();
<span class="line-modified"> 595       TempNewSymbol pkg_name = InstanceKlass::package_from_name(class_name, CHECK_(pd));</span>
 596       if (pkg_name != NULL) {
 597         PackageEntry* pkg_entry = pkgEntryTable-&gt;lookup_only(pkg_name);
 598         if (pkg_entry != NULL) {
 599           ModuleEntry* mod_entry = pkg_entry-&gt;module();
 600           pd = get_shared_protection_domain(class_loader, mod_entry, THREAD);
 601           define_shared_package(class_name, class_loader, mod_entry, CHECK_(pd));
 602         }
 603       }
 604     } else {
 605       // For shared app/platform classes originated from JAR files on the class path:
 606       //   Each of the 3 SystemDictionaryShared::_shared_xxx arrays has the same length
 607       //   as the shared classpath table in the shared archive (see
 608       //   FileMap::_shared_path_table in filemap.hpp for details).
 609       //
 610       //   If a shared InstanceKlass k is loaded from the class path, let
 611       //
 612       //     index = k-&gt;shared_classpath_index():
 613       //
 614       //   FileMap::_shared_path_table[index] identifies the JAR file that contains k.
 615       //
</pre>
<hr />
<pre>
 962 }
 963 
 964 static ResourceHashtable&lt;
 965   Symbol*, bool,
 966   primitive_hash&lt;Symbol*&gt;,
 967   primitive_equals&lt;Symbol*&gt;,
 968   6661,                             // prime number
 969   ResourceObj::C_HEAP&gt; _loaded_unregistered_classes;
 970 
 971 bool SystemDictionaryShared::add_unregistered_class(InstanceKlass* k, TRAPS) {
 972   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
 973 
 974   Symbol* name = k-&gt;name();
 975   if (_loaded_unregistered_classes.get(name) != NULL) {
 976     // We don&#39;t allow duplicated unregistered classes of the same name.
 977     return false;
 978   } else {
 979     bool isnew = _loaded_unregistered_classes.put(name, true);
 980     assert(isnew, &quot;sanity&quot;);
 981     MutexLocker mu_r(THREAD, Compile_lock); // add_to_hierarchy asserts this.
<span class="line-modified"> 982     SystemDictionary::add_to_hierarchy(k, CHECK_0);</span>
 983     return true;
 984   }
 985 }
 986 
 987 // This function is called to resolve the super/interfaces of shared classes for
 988 // non-built-in loaders. E.g., ChildClass in the below example
 989 // where &quot;super:&quot; (and optionally &quot;interface:&quot;) have been specified.
 990 //
 991 // java/lang/Object id: 0
 992 // Interface   id: 2 super: 0 source: cust.jar
 993 // ChildClass  id: 4 super: 0 interfaces: 2 source: cust.jar
 994 InstanceKlass* SystemDictionaryShared::dump_time_resolve_super_or_fail(
 995     Symbol* child_name, Symbol* class_name, Handle class_loader,
 996     Handle protection_domain, bool is_superclass, TRAPS) {
 997 
 998   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
 999 
1000   ClassListParser* parser = ClassListParser::instance();
1001   if (parser == NULL) {
1002     // We&#39;re still loading the well-known classes, before the ClassListParser is created.
</pre>
<hr />
<pre>
1069     }
1070     k = k-&gt;java_super();
1071   }
1072   return false;
1073 }
1074 
1075 void SystemDictionaryShared::warn_excluded(InstanceKlass* k, const char* reason) {
1076   ResourceMark rm;
1077   log_warning(cds)(&quot;Skipping %s: %s&quot;, k-&gt;name()-&gt;as_C_string(), reason);
1078 }
1079 
1080 bool SystemDictionaryShared::should_be_excluded(InstanceKlass* k) {
1081   if (k-&gt;class_loader_data()-&gt;is_unsafe_anonymous()) {
1082     warn_excluded(k, &quot;Unsafe anonymous class&quot;);
1083     return true; // unsafe anonymous classes are not archived, skip
1084   }
1085   if (k-&gt;is_in_error_state()) {
1086     warn_excluded(k, &quot;In error state&quot;);
1087     return true;
1088   }




1089   if (k-&gt;shared_classpath_index() &lt; 0 &amp;&amp; is_builtin(k)) {
1090     // These are classes loaded from unsupported locations (such as those loaded by JVMTI native
1091     // agent during dump time).
1092     warn_excluded(k, &quot;Unsupported location&quot;);
1093     return true;
1094   }
1095   if (k-&gt;signers() != NULL) {
1096     // We cannot include signed classes in the archive because the certificates
1097     // used during dump time may be different than those used during
1098     // runtime (due to expiration, etc).
1099     warn_excluded(k, &quot;Signed JAR&quot;);
1100     return true;
1101   }
1102   if (is_jfr_event_class(k)) {
1103     // We cannot include JFR event classes because they need runtime-specific
1104     // instrumentation in order to work with -XX:FlightRecorderOptions=retransform=false.
1105     // There are only a small number of these classes, so it&#39;s not worthwhile to
1106     // support them and make CDS more complicated.
1107     warn_excluded(k, &quot;JFR event class&quot;);
1108     return true;
1109   }
1110   if (k-&gt;init_state() &lt; InstanceKlass::linked) {
<span class="line-modified">1111     // In static dumping, we will attempt to link all classes. Those that fail to link will</span>
<span class="line-modified">1112     // be marked as in error state.</span>
<span class="line-modified">1113     assert(DynamicDumpSharedSpaces, &quot;must be&quot;);</span>
1114 
1115     // TODO -- rethink how this can be handled.
1116     // We should try to link ik, however, we can&#39;t do it here because
1117     // 1. We are at VM exit
1118     // 2. linking a class may cause other classes to be loaded, which means
1119     //    a custom ClassLoader.loadClass() may be called, at a point where the
1120     //    class loader doesn&#39;t expect it.
<span class="line-modified">1121     warn_excluded(k, &quot;Not linked&quot;);</span>




1122     return true;
1123   }
1124   if (k-&gt;major_version() &lt; 50 /*JAVA_6_VERSION*/) {
1125     ResourceMark rm;
1126     log_warning(cds)(&quot;Pre JDK 6 class not supported by CDS: %u.%u %s&quot;,
1127                      k-&gt;major_version(),  k-&gt;minor_version(), k-&gt;name()-&gt;as_C_string());
1128     return true;
1129   }
1130 
1131   InstanceKlass* super = k-&gt;java_super();
1132   if (super != NULL &amp;&amp; should_be_excluded(super)) {
1133     ResourceMark rm;
1134     log_warning(cds)(&quot;Skipping %s: super class %s is excluded&quot;, k-&gt;name()-&gt;as_C_string(), super-&gt;name()-&gt;as_C_string());
1135     return true;
1136   }
1137 
1138   Array&lt;InstanceKlass*&gt;* interfaces = k-&gt;local_interfaces();
1139   int len = interfaces-&gt;length();
1140   for (int i = 0; i &lt; len; i++) {
1141     InstanceKlass* intf = interfaces-&gt;at(i);
1142     if (should_be_excluded(intf)) {
1143       log_warning(cds)(&quot;Skipping %s: interface %s is excluded&quot;, k-&gt;name()-&gt;as_C_string(), intf-&gt;name()-&gt;as_C_string());
1144       return true;
1145     }
1146   }
1147 
1148   return false;
1149 }
1150 
1151 // k is a class before relocating by ArchiveCompactor
1152 void SystemDictionaryShared::validate_before_archiving(InstanceKlass* k) {
1153   ResourceMark rm;
1154   const char* name = k-&gt;name()-&gt;as_C_string();
1155   DumpTimeSharedClassInfo* info = _dumptime_table-&gt;get(k);
1156   assert(_no_class_loading_should_happen, &quot;class loading must be disabled&quot;);
1157   guarantee(info != NULL, &quot;Class %s must be entered into _dumptime_table&quot;, name);
1158   guarantee(!info-&gt;is_excluded(), &quot;Should not attempt to archive excluded class %s&quot;, name);
1159   if (is_builtin(k)) {
<span class="line-modified">1160     guarantee(k-&gt;loader_type() != 0,</span>
1161               &quot;Class loader type must be set for BUILTIN class %s&quot;, name);
1162   } else {
<span class="line-modified">1163     guarantee(k-&gt;loader_type() == 0,</span>
1164               &quot;Class loader type must not be set for UNREGISTERED class %s&quot;, name);
1165   }
1166 }
1167 
1168 class ExcludeDumpTimeSharedClasses : StackObj {
1169 public:
1170   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1171     if (SystemDictionaryShared::should_be_excluded(k)) {
1172       info.set_excluded();
1173     }
1174     return true; // keep on iterating
1175   }
1176 };
1177 
1178 void SystemDictionaryShared::check_excluded_classes() {
1179   ExcludeDumpTimeSharedClasses excl;
1180   _dumptime_table-&gt;iterate(&amp;excl);
1181   _dumptime_table-&gt;update_counts();
1182 }
1183 
1184 bool SystemDictionaryShared::is_excluded_class(InstanceKlass* k) {
1185   assert(_no_class_loading_should_happen, &quot;sanity&quot;);
1186   Arguments::assert_is_dumping_archive();
1187   return find_or_allocate_info_for(k)-&gt;is_excluded();
1188 }
1189 
















1190 class IterateDumpTimeSharedClassTable : StackObj {
1191   MetaspaceClosure *_it;
1192 public:
1193   IterateDumpTimeSharedClassTable(MetaspaceClosure* it) : _it(it) {}
1194 
1195   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1196     if (!info.is_excluded()) {
1197       info.metaspace_pointers_do(_it);
1198     }
1199     return true; // keep on iterating
1200   }
1201 };
1202 
1203 void SystemDictionaryShared::dumptime_classes_do(class MetaspaceClosure* it) {
1204   IterateDumpTimeSharedClassTable iter(it);
1205   _dumptime_table-&gt;iterate(&amp;iter);
1206 }
1207 
1208 bool SystemDictionaryShared::add_verification_constraint(InstanceKlass* k, Symbol* name,
1209          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {
</pre>
<hr />
<pre>
1393   if (is_static_archive) {
1394     write_dictionary(&amp;_builtin_dictionary, true);
1395     write_dictionary(&amp;_unregistered_dictionary, false);
1396   } else {
1397     write_dictionary(&amp;_dynamic_builtin_dictionary, true);
1398     write_dictionary(&amp;_dynamic_unregistered_dictionary, false);
1399   }
1400 }
1401 
1402 void SystemDictionaryShared::serialize_dictionary_headers(SerializeClosure* soc,
1403                                                           bool is_static_archive) {
1404   if (is_static_archive) {
1405     _builtin_dictionary.serialize_header(soc);
1406     _unregistered_dictionary.serialize_header(soc);
1407   } else {
1408     _dynamic_builtin_dictionary.serialize_header(soc);
1409     _dynamic_unregistered_dictionary.serialize_header(soc);
1410   }
1411 }
1412 






1413 const RunTimeSharedClassInfo*
1414 SystemDictionaryShared::find_record(RunTimeSharedDictionary* static_dict, RunTimeSharedDictionary* dynamic_dict, Symbol* name) {
1415   if (!UseSharedSpaces || !name-&gt;is_shared()) {
1416     // The names of all shared classes must also be a shared Symbol.
1417     return NULL;
1418   }
1419 
1420   unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(name);
1421   const RunTimeSharedClassInfo* record = NULL;
1422   if (!MetaspaceShared::is_shared_dynamic(name)) {
1423     // The names of all shared classes in the static dict must also be in the
1424     // static archive
1425     record = static_dict-&gt;lookup(name, hash, 0);
1426   }
1427 
1428   if (record == NULL &amp;&amp; DynamicArchive::is_mapped()) {
1429     record = dynamic_dict-&gt;lookup(name, hash, 0);
1430   }
1431 
1432   return record;
</pre>
</td>
<td>
<hr />
<pre>
  59 #include &quot;utilities/resourceHash.hpp&quot;
  60 #include &quot;utilities/stringUtils.hpp&quot;
  61 
  62 
  63 objArrayOop SystemDictionaryShared::_shared_protection_domains  =  NULL;
  64 objArrayOop SystemDictionaryShared::_shared_jar_urls            =  NULL;
  65 objArrayOop SystemDictionaryShared::_shared_jar_manifests       =  NULL;
  66 DEBUG_ONLY(bool SystemDictionaryShared::_no_class_loading_should_happen = false;)
  67 
  68 class DumpTimeSharedClassInfo: public CHeapObj&lt;mtClass&gt; {
  69   bool                         _excluded;
  70 public:
  71   struct DTConstraint {
  72     Symbol* _name;
  73     Symbol* _from_name;
  74     DTConstraint() : _name(NULL), _from_name(NULL) {}
  75     DTConstraint(Symbol* n, Symbol* fn) : _name(n), _from_name(fn) {}
  76   };
  77 
  78   InstanceKlass*               _klass;
<span class="line-added">  79   bool                         _failed_verification;</span>
  80   int                          _id;
  81   int                          _clsfile_size;
  82   int                          _clsfile_crc32;
  83   GrowableArray&lt;DTConstraint&gt;* _verifier_constraints;
  84   GrowableArray&lt;char&gt;*         _verifier_constraint_flags;
  85 
  86   DumpTimeSharedClassInfo() {
  87     _klass = NULL;
<span class="line-added">  88     _failed_verification = false;</span>
  89     _id = -1;
  90     _clsfile_size = -1;
  91     _clsfile_crc32 = -1;
  92     _excluded = false;
  93     _verifier_constraints = NULL;
  94     _verifier_constraint_flags = NULL;
  95   }
  96 
  97   void add_verification_constraint(InstanceKlass* k, Symbol* name,
  98          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object);
  99 
 100   bool is_builtin() {
 101     return SystemDictionaryShared::is_builtin(_klass);
 102   }
 103 
 104   int num_constraints() {
 105     if (_verifier_constraint_flags != NULL) {
 106       return _verifier_constraint_flags-&gt;length();
 107     } else {
 108       return 0;
 109     }
 110   }
 111 
 112   void metaspace_pointers_do(MetaspaceClosure* it) {
 113     it-&gt;push(&amp;_klass);
 114     if (_verifier_constraints != NULL) {
 115       for (int i = 0; i &lt; _verifier_constraints-&gt;length(); i++) {
 116         DTConstraint* cons = _verifier_constraints-&gt;adr_at(i);
 117         it-&gt;push(&amp;cons-&gt;_name);
 118         it-&gt;push(&amp;cons-&gt;_from_name);
 119       }
 120     }
 121   }
 122 
 123   void set_excluded() {
 124     _excluded = true;
 125   }
 126 
 127   bool is_excluded() {
 128     // _klass may become NULL due to DynamicArchiveBuilder::set_to_null
<span class="line-modified"> 129     return _excluded || _failed_verification || _klass == NULL;</span>
<span class="line-added"> 130   }</span>
<span class="line-added"> 131 </span>
<span class="line-added"> 132   void set_failed_verification() {</span>
<span class="line-added"> 133     _failed_verification = true;</span>
<span class="line-added"> 134   }</span>
<span class="line-added"> 135 </span>
<span class="line-added"> 136   bool failed_verification() {</span>
<span class="line-added"> 137     return _failed_verification;</span>
 138   }
 139 };
 140 
 141 class DumpTimeSharedClassTable: public ResourceHashtable&lt;
 142   InstanceKlass*,
 143   DumpTimeSharedClassInfo,
 144   primitive_hash&lt;InstanceKlass*&gt;,
 145   primitive_equals&lt;InstanceKlass*&gt;,
 146   15889, // prime number
 147   ResourceObj::C_HEAP&gt;
 148 {
 149   int _builtin_count;
 150   int _unregistered_count;
 151 public:
 152   DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k) {
 153     DumpTimeSharedClassInfo* p = get(k);
 154     if (p == NULL) {
 155       assert(!SystemDictionaryShared::no_class_loading_should_happen(),
 156              &quot;no new classes can be loaded while dumping archive&quot;);
 157       put(k, DumpTimeSharedClassInfo());
</pre>
<hr />
<pre>
 426     const char* path = FileMapInfo::shared_path_name(shared_path_index);
 427     Handle path_string = java_lang_String::create_from_str(path, CHECK_(url_h));
 428     Klass* classLoaders_klass =
 429         SystemDictionary::jdk_internal_loader_ClassLoaders_klass();
 430     JavaCalls::call_static(&amp;result, classLoaders_klass,
 431                            vmSymbols::toFileURL_name(),
 432                            vmSymbols::toFileURL_signature(),
 433                            path_string, CHECK_(url_h));
 434 
 435     atomic_set_shared_jar_url(shared_path_index, (oop)result.get_jobject());
 436   }
 437 
 438   url_h = Handle(THREAD, shared_jar_url(shared_path_index));
 439   assert(url_h.not_null(), &quot;sanity&quot;);
 440   return url_h;
 441 }
 442 
 443 Handle SystemDictionaryShared::get_package_name(Symbol* class_name, TRAPS) {
 444   ResourceMark rm(THREAD);
 445   Handle pkgname_string;
<span class="line-modified"> 446   Symbol* pkg = ClassLoader::package_from_class_name(class_name);</span>
<span class="line-modified"> 447   if (pkg != NULL) { // Package prefix found</span>
<span class="line-modified"> 448     const char* pkgname = pkg-&gt;as_klass_external_name();</span>
 449     pkgname_string = java_lang_String::create_from_str(pkgname,
 450                                                        CHECK_(pkgname_string));
 451   }
 452   return pkgname_string;
 453 }
 454 
 455 // Define Package for shared app classes from JAR file and also checks for
 456 // package sealing (all done in Java code)
 457 // See http://docs.oracle.com/javase/tutorial/deployment/jar/sealman.html
 458 void SystemDictionaryShared::define_shared_package(Symbol*  class_name,
 459                                                    Handle class_loader,
 460                                                    Handle manifest,
 461                                                    Handle url,
 462                                                    TRAPS) {
 463   assert(SystemDictionary::is_system_class_loader(class_loader()), &quot;unexpected class loader&quot;);
 464   // get_package_name() returns a NULL handle if the class is in unnamed package
 465   Handle pkgname_string = get_package_name(class_name, CHECK);
 466   if (pkgname_string.not_null()) {
 467     Klass* app_classLoader_klass = SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass();
 468     JavaValue result(T_OBJECT);
</pre>
<hr />
<pre>
 585 // Initializes the java.lang.Package and java.security.ProtectionDomain objects associated with
 586 // the given InstanceKlass.
 587 // Returns the ProtectionDomain for the InstanceKlass.
 588 Handle SystemDictionaryShared::init_security_info(Handle class_loader, InstanceKlass* ik, TRAPS) {
 589   Handle pd;
 590 
 591   if (ik != NULL) {
 592     int index = ik-&gt;shared_classpath_index();
 593     assert(index &gt;= 0, &quot;Sanity&quot;);
 594     SharedClassPathEntry* ent = FileMapInfo::shared_path(index);
 595     Symbol* class_name = ik-&gt;name();
 596 
 597     if (ent-&gt;is_modules_image()) {
 598       // For shared app/platform classes originated from the run-time image:
 599       //   The ProtectionDomains are cached in the corresponding ModuleEntries
 600       //   for fast access by the VM.
 601       ResourceMark rm;
 602       ClassLoaderData *loader_data =
 603                 ClassLoaderData::class_loader_data(class_loader());
 604       PackageEntryTable* pkgEntryTable = loader_data-&gt;packages();
<span class="line-modified"> 605       TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);</span>
 606       if (pkg_name != NULL) {
 607         PackageEntry* pkg_entry = pkgEntryTable-&gt;lookup_only(pkg_name);
 608         if (pkg_entry != NULL) {
 609           ModuleEntry* mod_entry = pkg_entry-&gt;module();
 610           pd = get_shared_protection_domain(class_loader, mod_entry, THREAD);
 611           define_shared_package(class_name, class_loader, mod_entry, CHECK_(pd));
 612         }
 613       }
 614     } else {
 615       // For shared app/platform classes originated from JAR files on the class path:
 616       //   Each of the 3 SystemDictionaryShared::_shared_xxx arrays has the same length
 617       //   as the shared classpath table in the shared archive (see
 618       //   FileMap::_shared_path_table in filemap.hpp for details).
 619       //
 620       //   If a shared InstanceKlass k is loaded from the class path, let
 621       //
 622       //     index = k-&gt;shared_classpath_index():
 623       //
 624       //   FileMap::_shared_path_table[index] identifies the JAR file that contains k.
 625       //
</pre>
<hr />
<pre>
 972 }
 973 
 974 static ResourceHashtable&lt;
 975   Symbol*, bool,
 976   primitive_hash&lt;Symbol*&gt;,
 977   primitive_equals&lt;Symbol*&gt;,
 978   6661,                             // prime number
 979   ResourceObj::C_HEAP&gt; _loaded_unregistered_classes;
 980 
 981 bool SystemDictionaryShared::add_unregistered_class(InstanceKlass* k, TRAPS) {
 982   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
 983 
 984   Symbol* name = k-&gt;name();
 985   if (_loaded_unregistered_classes.get(name) != NULL) {
 986     // We don&#39;t allow duplicated unregistered classes of the same name.
 987     return false;
 988   } else {
 989     bool isnew = _loaded_unregistered_classes.put(name, true);
 990     assert(isnew, &quot;sanity&quot;);
 991     MutexLocker mu_r(THREAD, Compile_lock); // add_to_hierarchy asserts this.
<span class="line-modified"> 992     SystemDictionary::add_to_hierarchy(k, CHECK_false);</span>
 993     return true;
 994   }
 995 }
 996 
 997 // This function is called to resolve the super/interfaces of shared classes for
 998 // non-built-in loaders. E.g., ChildClass in the below example
 999 // where &quot;super:&quot; (and optionally &quot;interface:&quot;) have been specified.
1000 //
1001 // java/lang/Object id: 0
1002 // Interface   id: 2 super: 0 source: cust.jar
1003 // ChildClass  id: 4 super: 0 interfaces: 2 source: cust.jar
1004 InstanceKlass* SystemDictionaryShared::dump_time_resolve_super_or_fail(
1005     Symbol* child_name, Symbol* class_name, Handle class_loader,
1006     Handle protection_domain, bool is_superclass, TRAPS) {
1007 
1008   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
1009 
1010   ClassListParser* parser = ClassListParser::instance();
1011   if (parser == NULL) {
1012     // We&#39;re still loading the well-known classes, before the ClassListParser is created.
</pre>
<hr />
<pre>
1079     }
1080     k = k-&gt;java_super();
1081   }
1082   return false;
1083 }
1084 
1085 void SystemDictionaryShared::warn_excluded(InstanceKlass* k, const char* reason) {
1086   ResourceMark rm;
1087   log_warning(cds)(&quot;Skipping %s: %s&quot;, k-&gt;name()-&gt;as_C_string(), reason);
1088 }
1089 
1090 bool SystemDictionaryShared::should_be_excluded(InstanceKlass* k) {
1091   if (k-&gt;class_loader_data()-&gt;is_unsafe_anonymous()) {
1092     warn_excluded(k, &quot;Unsafe anonymous class&quot;);
1093     return true; // unsafe anonymous classes are not archived, skip
1094   }
1095   if (k-&gt;is_in_error_state()) {
1096     warn_excluded(k, &quot;In error state&quot;);
1097     return true;
1098   }
<span class="line-added">1099   if (k-&gt;has_been_redefined()) {</span>
<span class="line-added">1100     warn_excluded(k, &quot;Has been redefined&quot;);</span>
<span class="line-added">1101     return true;</span>
<span class="line-added">1102   }</span>
1103   if (k-&gt;shared_classpath_index() &lt; 0 &amp;&amp; is_builtin(k)) {
1104     // These are classes loaded from unsupported locations (such as those loaded by JVMTI native
1105     // agent during dump time).
1106     warn_excluded(k, &quot;Unsupported location&quot;);
1107     return true;
1108   }
1109   if (k-&gt;signers() != NULL) {
1110     // We cannot include signed classes in the archive because the certificates
1111     // used during dump time may be different than those used during
1112     // runtime (due to expiration, etc).
1113     warn_excluded(k, &quot;Signed JAR&quot;);
1114     return true;
1115   }
1116   if (is_jfr_event_class(k)) {
1117     // We cannot include JFR event classes because they need runtime-specific
1118     // instrumentation in order to work with -XX:FlightRecorderOptions=retransform=false.
1119     // There are only a small number of these classes, so it&#39;s not worthwhile to
1120     // support them and make CDS more complicated.
1121     warn_excluded(k, &quot;JFR event class&quot;);
1122     return true;
1123   }
1124   if (k-&gt;init_state() &lt; InstanceKlass::linked) {
<span class="line-modified">1125     // In CDS dumping, we will attempt to link all classes. Those that fail to link will</span>
<span class="line-modified">1126     // be recorded in DumpTimeSharedClassInfo.</span>
<span class="line-modified">1127     Arguments::assert_is_dumping_archive();</span>
1128 
1129     // TODO -- rethink how this can be handled.
1130     // We should try to link ik, however, we can&#39;t do it here because
1131     // 1. We are at VM exit
1132     // 2. linking a class may cause other classes to be loaded, which means
1133     //    a custom ClassLoader.loadClass() may be called, at a point where the
1134     //    class loader doesn&#39;t expect it.
<span class="line-modified">1135     if (has_class_failed_verification(k)) {</span>
<span class="line-added">1136       warn_excluded(k, &quot;Failed verification&quot;);</span>
<span class="line-added">1137     } else {</span>
<span class="line-added">1138       warn_excluded(k, &quot;Not linked&quot;);</span>
<span class="line-added">1139     }</span>
1140     return true;
1141   }
1142   if (k-&gt;major_version() &lt; 50 /*JAVA_6_VERSION*/) {
1143     ResourceMark rm;
1144     log_warning(cds)(&quot;Pre JDK 6 class not supported by CDS: %u.%u %s&quot;,
1145                      k-&gt;major_version(),  k-&gt;minor_version(), k-&gt;name()-&gt;as_C_string());
1146     return true;
1147   }
1148 
1149   InstanceKlass* super = k-&gt;java_super();
1150   if (super != NULL &amp;&amp; should_be_excluded(super)) {
1151     ResourceMark rm;
1152     log_warning(cds)(&quot;Skipping %s: super class %s is excluded&quot;, k-&gt;name()-&gt;as_C_string(), super-&gt;name()-&gt;as_C_string());
1153     return true;
1154   }
1155 
1156   Array&lt;InstanceKlass*&gt;* interfaces = k-&gt;local_interfaces();
1157   int len = interfaces-&gt;length();
1158   for (int i = 0; i &lt; len; i++) {
1159     InstanceKlass* intf = interfaces-&gt;at(i);
1160     if (should_be_excluded(intf)) {
1161       log_warning(cds)(&quot;Skipping %s: interface %s is excluded&quot;, k-&gt;name()-&gt;as_C_string(), intf-&gt;name()-&gt;as_C_string());
1162       return true;
1163     }
1164   }
1165 
1166   return false;
1167 }
1168 
1169 // k is a class before relocating by ArchiveCompactor
1170 void SystemDictionaryShared::validate_before_archiving(InstanceKlass* k) {
1171   ResourceMark rm;
1172   const char* name = k-&gt;name()-&gt;as_C_string();
1173   DumpTimeSharedClassInfo* info = _dumptime_table-&gt;get(k);
1174   assert(_no_class_loading_should_happen, &quot;class loading must be disabled&quot;);
1175   guarantee(info != NULL, &quot;Class %s must be entered into _dumptime_table&quot;, name);
1176   guarantee(!info-&gt;is_excluded(), &quot;Should not attempt to archive excluded class %s&quot;, name);
1177   if (is_builtin(k)) {
<span class="line-modified">1178     guarantee(!k-&gt;is_shared_unregistered_class(),</span>
1179               &quot;Class loader type must be set for BUILTIN class %s&quot;, name);
1180   } else {
<span class="line-modified">1181     guarantee(k-&gt;is_shared_unregistered_class(),</span>
1182               &quot;Class loader type must not be set for UNREGISTERED class %s&quot;, name);
1183   }
1184 }
1185 
1186 class ExcludeDumpTimeSharedClasses : StackObj {
1187 public:
1188   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1189     if (SystemDictionaryShared::should_be_excluded(k)) {
1190       info.set_excluded();
1191     }
1192     return true; // keep on iterating
1193   }
1194 };
1195 
1196 void SystemDictionaryShared::check_excluded_classes() {
1197   ExcludeDumpTimeSharedClasses excl;
1198   _dumptime_table-&gt;iterate(&amp;excl);
1199   _dumptime_table-&gt;update_counts();
1200 }
1201 
1202 bool SystemDictionaryShared::is_excluded_class(InstanceKlass* k) {
1203   assert(_no_class_loading_should_happen, &quot;sanity&quot;);
1204   Arguments::assert_is_dumping_archive();
1205   return find_or_allocate_info_for(k)-&gt;is_excluded();
1206 }
1207 
<span class="line-added">1208 void SystemDictionaryShared::set_class_has_failed_verification(InstanceKlass* ik) {</span>
<span class="line-added">1209   Arguments::assert_is_dumping_archive();</span>
<span class="line-added">1210   find_or_allocate_info_for(ik)-&gt;set_failed_verification();</span>
<span class="line-added">1211 }</span>
<span class="line-added">1212 </span>
<span class="line-added">1213 bool SystemDictionaryShared::has_class_failed_verification(InstanceKlass* ik) {</span>
<span class="line-added">1214   Arguments::assert_is_dumping_archive();</span>
<span class="line-added">1215   if (_dumptime_table == NULL) {</span>
<span class="line-added">1216     assert(DynamicDumpSharedSpaces, &quot;sanity&quot;);</span>
<span class="line-added">1217     assert(ik-&gt;is_shared(), &quot;must be a shared class in the static archive&quot;);</span>
<span class="line-added">1218     return false;</span>
<span class="line-added">1219   }</span>
<span class="line-added">1220   DumpTimeSharedClassInfo* p = _dumptime_table-&gt;get(ik);</span>
<span class="line-added">1221   return (p == NULL) ? false : p-&gt;failed_verification();</span>
<span class="line-added">1222 }</span>
<span class="line-added">1223 </span>
1224 class IterateDumpTimeSharedClassTable : StackObj {
1225   MetaspaceClosure *_it;
1226 public:
1227   IterateDumpTimeSharedClassTable(MetaspaceClosure* it) : _it(it) {}
1228 
1229   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1230     if (!info.is_excluded()) {
1231       info.metaspace_pointers_do(_it);
1232     }
1233     return true; // keep on iterating
1234   }
1235 };
1236 
1237 void SystemDictionaryShared::dumptime_classes_do(class MetaspaceClosure* it) {
1238   IterateDumpTimeSharedClassTable iter(it);
1239   _dumptime_table-&gt;iterate(&amp;iter);
1240 }
1241 
1242 bool SystemDictionaryShared::add_verification_constraint(InstanceKlass* k, Symbol* name,
1243          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {
</pre>
<hr />
<pre>
1427   if (is_static_archive) {
1428     write_dictionary(&amp;_builtin_dictionary, true);
1429     write_dictionary(&amp;_unregistered_dictionary, false);
1430   } else {
1431     write_dictionary(&amp;_dynamic_builtin_dictionary, true);
1432     write_dictionary(&amp;_dynamic_unregistered_dictionary, false);
1433   }
1434 }
1435 
1436 void SystemDictionaryShared::serialize_dictionary_headers(SerializeClosure* soc,
1437                                                           bool is_static_archive) {
1438   if (is_static_archive) {
1439     _builtin_dictionary.serialize_header(soc);
1440     _unregistered_dictionary.serialize_header(soc);
1441   } else {
1442     _dynamic_builtin_dictionary.serialize_header(soc);
1443     _dynamic_unregistered_dictionary.serialize_header(soc);
1444   }
1445 }
1446 
<span class="line-added">1447 void SystemDictionaryShared::serialize_well_known_klasses(SerializeClosure* soc) {</span>
<span class="line-added">1448   for (int i = FIRST_WKID; i &lt; WKID_LIMIT; i++) {</span>
<span class="line-added">1449     soc-&gt;do_ptr((void**)&amp;_well_known_klasses[i]);</span>
<span class="line-added">1450   }</span>
<span class="line-added">1451 }</span>
<span class="line-added">1452 </span>
1453 const RunTimeSharedClassInfo*
1454 SystemDictionaryShared::find_record(RunTimeSharedDictionary* static_dict, RunTimeSharedDictionary* dynamic_dict, Symbol* name) {
1455   if (!UseSharedSpaces || !name-&gt;is_shared()) {
1456     // The names of all shared classes must also be a shared Symbol.
1457     return NULL;
1458   }
1459 
1460   unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(name);
1461   const RunTimeSharedClassInfo* record = NULL;
1462   if (!MetaspaceShared::is_shared_dynamic(name)) {
1463     // The names of all shared classes in the static dict must also be in the
1464     // static archive
1465     record = static_dict-&gt;lookup(name, hash, 0);
1466   }
1467 
1468   if (record == NULL &amp;&amp; DynamicArchive::is_mapped()) {
1469     record = dynamic_dict-&gt;lookup(name, hash, 0);
1470   }
1471 
1472   return record;
</pre>
</td>
</tr>
</table>
<center><a href="systemDictionary.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionaryShared.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
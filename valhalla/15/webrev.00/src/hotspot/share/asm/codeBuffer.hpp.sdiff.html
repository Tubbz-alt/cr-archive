<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/asm/codeBuffer.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="assembler.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../c1/c1_GraphBuilder.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/asm/codeBuffer.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
190 
191   void    set_end(address pc)       { assert(allocates2(pc), &quot;not in CodeBuffer memory: &quot; INTPTR_FORMAT &quot; &lt;= &quot; INTPTR_FORMAT &quot; &lt;= &quot; INTPTR_FORMAT, p2i(_start), p2i(pc), p2i(_limit)); _end = pc; }
192   void    set_mark(address pc)      { assert(contains2(pc), &quot;not in codeBuffer&quot;);
193                                       _mark = pc; }
194   void    set_mark_off(int offset)  { assert(contains2(offset+_start),&quot;not in codeBuffer&quot;);
195                                       _mark = offset + _start; }
196   void    set_mark()                { _mark = _end; }
197   void    clear_mark()              { _mark = NULL; }
198 
199   void    set_locs_end(relocInfo* p) {
200     assert(p &lt;= locs_limit(), &quot;locs data fits in allocated buffer&quot;);
201     _locs_end = p;
202   }
203   void    set_locs_point(address pc) {
204     assert(pc &gt;= locs_point(), &quot;relocation addr may not decrease&quot;);
205     assert(allocates2(pc),     &quot;relocation addr must be in this section&quot;);
206     _locs_point = pc;
207   }
208 
209   // Code emission
<span class="line-modified">210   void emit_int8 ( int8_t  x)  { *((int8_t*)  end()) = x; set_end(end() + sizeof(int8_t)); }</span>
<span class="line-modified">211   void emit_int16( int16_t x)  { *((int16_t*) end()) = x; set_end(end() + sizeof(int16_t)); }</span>
<span class="line-modified">212   void emit_int32( int32_t x)  { *((int32_t*) end()) = x; set_end(end() + sizeof(int32_t)); }</span>





























213   void emit_int64( int64_t x)  { *((int64_t*) end()) = x; set_end(end() + sizeof(int64_t)); }
214 
215   void emit_float( jfloat  x)  { *((jfloat*)  end()) = x; set_end(end() + sizeof(jfloat)); }
216   void emit_double(jdouble x)  { *((jdouble*) end()) = x; set_end(end() + sizeof(jdouble)); }
217   void emit_address(address x) { *((address*) end()) = x; set_end(end() + sizeof(address)); }
218 
219   // Share a scratch buffer for relocinfo.  (Hacky; saves a resource allocation.)
220   void initialize_shared_locs(relocInfo* buf, int length);
221 
222   // Manage labels and their addresses.
223   address target(Label&amp; L, address branch_pc);
224 
225   // Emit a relocation.
226   void relocate(address at, RelocationHolder const&amp; rspec, int format = 0);
227   void relocate(address at,    relocInfo::relocType rtype, int format = 0, jint method_index = 0);
228 
229   // alignment requirement for starting offset
230   // Requirements are that the instruction area and the
231   // stubs area must start on CodeEntryAlignment, and
232   // the ctable on sizeof(jdouble)
</pre>
</td>
<td>
<hr />
<pre>
190 
191   void    set_end(address pc)       { assert(allocates2(pc), &quot;not in CodeBuffer memory: &quot; INTPTR_FORMAT &quot; &lt;= &quot; INTPTR_FORMAT &quot; &lt;= &quot; INTPTR_FORMAT, p2i(_start), p2i(pc), p2i(_limit)); _end = pc; }
192   void    set_mark(address pc)      { assert(contains2(pc), &quot;not in codeBuffer&quot;);
193                                       _mark = pc; }
194   void    set_mark_off(int offset)  { assert(contains2(offset+_start),&quot;not in codeBuffer&quot;);
195                                       _mark = offset + _start; }
196   void    set_mark()                { _mark = _end; }
197   void    clear_mark()              { _mark = NULL; }
198 
199   void    set_locs_end(relocInfo* p) {
200     assert(p &lt;= locs_limit(), &quot;locs data fits in allocated buffer&quot;);
201     _locs_end = p;
202   }
203   void    set_locs_point(address pc) {
204     assert(pc &gt;= locs_point(), &quot;relocation addr may not decrease&quot;);
205     assert(allocates2(pc),     &quot;relocation addr must be in this section&quot;);
206     _locs_point = pc;
207   }
208 
209   // Code emission
<span class="line-modified">210   void emit_int8(int8_t x1) {</span>
<span class="line-modified">211     address curr = end();</span>
<span class="line-modified">212     *((int8_t*)  curr++) = x1;</span>
<span class="line-added">213     set_end(curr);</span>
<span class="line-added">214   }</span>
<span class="line-added">215 </span>
<span class="line-added">216   void emit_int16(int16_t x) { *((int16_t*) end()) = x; set_end(end() + sizeof(int16_t)); }</span>
<span class="line-added">217   void emit_int16(int8_t x1, int8_t x2) {</span>
<span class="line-added">218     address curr = end();</span>
<span class="line-added">219     *((int8_t*)  curr++) = x1;</span>
<span class="line-added">220     *((int8_t*)  curr++) = x2;</span>
<span class="line-added">221     set_end(curr);</span>
<span class="line-added">222   }</span>
<span class="line-added">223 </span>
<span class="line-added">224   void emit_int24(int8_t x1, int8_t x2, int8_t x3)  {</span>
<span class="line-added">225     address curr = end();</span>
<span class="line-added">226     *((int8_t*)  curr++) = x1;</span>
<span class="line-added">227     *((int8_t*)  curr++) = x2;</span>
<span class="line-added">228     *((int8_t*)  curr++) = x3;</span>
<span class="line-added">229     set_end(curr);</span>
<span class="line-added">230   }</span>
<span class="line-added">231 </span>
<span class="line-added">232   void emit_int32(int32_t x) { *((int32_t*) end()) = x; set_end(end() + sizeof(int32_t)); }</span>
<span class="line-added">233   void emit_int32(int8_t x1, int8_t x2, int8_t x3, int8_t x4)  {</span>
<span class="line-added">234     address curr = end();</span>
<span class="line-added">235     *((int8_t*)  curr++) = x1;</span>
<span class="line-added">236     *((int8_t*)  curr++) = x2;</span>
<span class="line-added">237     *((int8_t*)  curr++) = x3;</span>
<span class="line-added">238     *((int8_t*)  curr++) = x4;</span>
<span class="line-added">239     set_end(curr);</span>
<span class="line-added">240   }</span>
<span class="line-added">241 </span>
242   void emit_int64( int64_t x)  { *((int64_t*) end()) = x; set_end(end() + sizeof(int64_t)); }
243 
244   void emit_float( jfloat  x)  { *((jfloat*)  end()) = x; set_end(end() + sizeof(jfloat)); }
245   void emit_double(jdouble x)  { *((jdouble*) end()) = x; set_end(end() + sizeof(jdouble)); }
246   void emit_address(address x) { *((address*) end()) = x; set_end(end() + sizeof(address)); }
247 
248   // Share a scratch buffer for relocinfo.  (Hacky; saves a resource allocation.)
249   void initialize_shared_locs(relocInfo* buf, int length);
250 
251   // Manage labels and their addresses.
252   address target(Label&amp; L, address branch_pc);
253 
254   // Emit a relocation.
255   void relocate(address at, RelocationHolder const&amp; rspec, int format = 0);
256   void relocate(address at,    relocInfo::relocType rtype, int format = 0, jint method_index = 0);
257 
258   // alignment requirement for starting offset
259   // Requirements are that the instruction area and the
260   // stubs area must start on CodeEntryAlignment, and
261   // the ctable on sizeof(jdouble)
</pre>
</td>
</tr>
</table>
<center><a href="assembler.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../c1/c1_GraphBuilder.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
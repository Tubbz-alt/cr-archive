<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/asm/codeBuffer.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_ASM_CODEBUFFER_HPP
 26 #define SHARE_ASM_CODEBUFFER_HPP
 27 
 28 #include &quot;code/oopRecorder.hpp&quot;
 29 #include &quot;code/relocInfo.hpp&quot;
 30 #include &quot;utilities/align.hpp&quot;
 31 #include &quot;utilities/debug.hpp&quot;
 32 #include &quot;utilities/macros.hpp&quot;
 33 
 34 class CodeStrings;
 35 class PhaseCFG;
 36 class Compile;
 37 class BufferBlob;
 38 class CodeBuffer;
 39 class Label;
 40 
 41 class CodeOffsets: public StackObj {
 42 public:
 43   enum Entries { Entry,
 44                  Verified_Entry,
 45                  Value_Entry,
 46                  Verified_Value_Entry,
 47                  Verified_Value_Entry_RO,
 48                  Frame_Complete, // Offset in the code where the frame setup is (for forte stackwalks) is complete
 49                  OSR_Entry,
 50                  Exceptions,     // Offset where exception handler lives
 51                  Deopt,          // Offset where deopt handler lives
 52                  DeoptMH,        // Offset where MethodHandle deopt handler lives
 53                  UnwindHandler,  // Offset to default unwind handler
 54                  max_Entries };
 55 
 56   // special value to note codeBlobs where profile (forte) stack walking is
 57   // always dangerous and suspect.
 58 
 59   enum { frame_never_safe = -1 };
 60 
 61 private:
 62   int _values[max_Entries];
 63   void check(int e) const { assert(0 &lt;= e &amp;&amp; e &lt; max_Entries, &quot;must be&quot;); }
 64 
 65 public:
 66   CodeOffsets() {
 67     _values[Entry         ] = 0;
 68     _values[Verified_Entry] = 0;
 69     _values[Value_Entry   ] = 0;
 70     _values[Verified_Value_Entry] = -1;
 71     _values[Verified_Value_Entry_RO] = -1;
 72     _values[Frame_Complete] = frame_never_safe;
 73     _values[OSR_Entry     ] = 0;
 74     _values[Exceptions    ] = -1;
 75     _values[Deopt         ] = -1;
 76     _values[DeoptMH       ] = -1;
 77     _values[UnwindHandler ] = -1;
 78   }
 79 
 80   int value(Entries e) const { check(e); return _values[e]; }
 81   void set_value(Entries e, int val) { check(e); _values[e] = val; }
 82 };
 83 
 84 // This class represents a stream of code and associated relocations.
 85 // There are a few in each CodeBuffer.
 86 // They are filled concurrently, and concatenated at the end.
 87 class CodeSection {
 88   friend class CodeBuffer;
 89  public:
 90   typedef int csize_t;  // code size type; would be size_t except for history
 91 
 92  private:
 93   address     _start;           // first byte of contents (instructions)
 94   address     _mark;            // user mark, usually an instruction beginning
 95   address     _end;             // current end address
 96   address     _limit;           // last possible (allocated) end address
 97   relocInfo*  _locs_start;      // first byte of relocation information
 98   relocInfo*  _locs_end;        // first byte after relocation information
 99   relocInfo*  _locs_limit;      // first byte after relocation information buf
100   address     _locs_point;      // last relocated position (grows upward)
101   bool        _locs_own;        // did I allocate the locs myself?
102   bool        _frozen;          // no more expansion of this section
103   bool        _scratch_emit;    // Buffer is used for scratch emit, don&#39;t relocate.
104   char        _index;           // my section number (SECT_INST, etc.)
105   CodeBuffer* _outer;           // enclosing CodeBuffer
106 
107   // (Note:  _locs_point used to be called _last_reloc_offset.)
108 
109   CodeSection() {
110     _start         = NULL;
111     _mark          = NULL;
112     _end           = NULL;
113     _limit         = NULL;
114     _locs_start    = NULL;
115     _locs_end      = NULL;
116     _locs_limit    = NULL;
117     _locs_point    = NULL;
118     _locs_own      = false;
119     _frozen        = false;
120     _scratch_emit  = false;
121     debug_only(_index = (char)-1);
122     debug_only(_outer = (CodeBuffer*)badAddress);
123   }
124 
125   void initialize_outer(CodeBuffer* outer, int index) {
126     _outer = outer;
127     _index = index;
128   }
129 
130   void initialize(address start, csize_t size = 0) {
131     assert(_start == NULL, &quot;only one init step, please&quot;);
132     _start         = start;
133     _mark          = NULL;
134     _end           = start;
135 
136     _limit         = start + size;
137     _locs_point    = start;
138   }
139 
140   void initialize_locs(int locs_capacity);
141   void expand_locs(int new_capacity);
142   void initialize_locs_from(const CodeSection* source_cs);
143 
144   // helper for CodeBuffer::expand()
145   void take_over_code_from(CodeSection* cs) {
146     _start      = cs-&gt;_start;
147     _mark       = cs-&gt;_mark;
148     _end        = cs-&gt;_end;
149     _limit      = cs-&gt;_limit;
150     _locs_point = cs-&gt;_locs_point;
151   }
152 
153  public:
154   address     start() const         { return _start; }
155   address     mark() const          { return _mark; }
156   address     end() const           { return _end; }
157   address     limit() const         { return _limit; }
158   csize_t     size() const          { return (csize_t)(_end - _start); }
159   csize_t     mark_off() const      { assert(_mark != NULL, &quot;not an offset&quot;);
160                                       return (csize_t)(_mark - _start); }
161   csize_t     capacity() const      { return (csize_t)(_limit - _start); }
162   csize_t     remaining() const     { return (csize_t)(_limit - _end); }
163 
164   relocInfo*  locs_start() const    { return _locs_start; }
165   relocInfo*  locs_end() const      { return _locs_end; }
166   int         locs_count() const    { return (int)(_locs_end - _locs_start); }
167   relocInfo*  locs_limit() const    { return _locs_limit; }
168   address     locs_point() const    { return _locs_point; }
169   csize_t     locs_point_off() const{ return (csize_t)(_locs_point - _start); }
170   csize_t     locs_capacity() const { return (csize_t)(_locs_limit - _locs_start); }
171   csize_t     locs_remaining()const { return (csize_t)(_locs_limit - _locs_end); }
172 
173   int         index() const         { return _index; }
174   bool        is_allocated() const  { return _start != NULL; }
175   bool        is_empty() const      { return _start == _end; }
176   bool        is_frozen() const     { return _frozen; }
177   bool        has_locs() const      { return _locs_end != NULL; }
178 
179   // Mark scratch buffer.
180   void        set_scratch_emit()    { _scratch_emit = true; }
181   bool        scratch_emit()        { return _scratch_emit; }
182 
183   CodeBuffer* outer() const         { return _outer; }
184 
185   // is a given address in this section?  (2nd version is end-inclusive)
186   bool contains(address pc) const   { return pc &gt;= _start &amp;&amp; pc &lt;  _end; }
187   bool contains2(address pc) const  { return pc &gt;= _start &amp;&amp; pc &lt;= _end; }
188   bool allocates(address pc) const  { return pc &gt;= _start &amp;&amp; pc &lt;  _limit; }
189   bool allocates2(address pc) const { return pc &gt;= _start &amp;&amp; pc &lt;= _limit; }
190 
191   void    set_end(address pc)       { assert(allocates2(pc), &quot;not in CodeBuffer memory: &quot; INTPTR_FORMAT &quot; &lt;= &quot; INTPTR_FORMAT &quot; &lt;= &quot; INTPTR_FORMAT, p2i(_start), p2i(pc), p2i(_limit)); _end = pc; }
192   void    set_mark(address pc)      { assert(contains2(pc), &quot;not in codeBuffer&quot;);
193                                       _mark = pc; }
194   void    set_mark_off(int offset)  { assert(contains2(offset+_start),&quot;not in codeBuffer&quot;);
195                                       _mark = offset + _start; }
196   void    set_mark()                { _mark = _end; }
197   void    clear_mark()              { _mark = NULL; }
198 
199   void    set_locs_end(relocInfo* p) {
200     assert(p &lt;= locs_limit(), &quot;locs data fits in allocated buffer&quot;);
201     _locs_end = p;
202   }
203   void    set_locs_point(address pc) {
204     assert(pc &gt;= locs_point(), &quot;relocation addr may not decrease&quot;);
205     assert(allocates2(pc),     &quot;relocation addr must be in this section&quot;);
206     _locs_point = pc;
207   }
208 
209   // Code emission
<a name="1" id="anc1"></a><span class="line-modified">210   void emit_int8 ( int8_t  x)  { *((int8_t*)  end()) = x; set_end(end() + sizeof(int8_t)); }</span>
<span class="line-modified">211   void emit_int16( int16_t x)  { *((int16_t*) end()) = x; set_end(end() + sizeof(int16_t)); }</span>
<span class="line-modified">212   void emit_int32( int32_t x)  { *((int32_t*) end()) = x; set_end(end() + sizeof(int32_t)); }</span>





























213   void emit_int64( int64_t x)  { *((int64_t*) end()) = x; set_end(end() + sizeof(int64_t)); }
214 
215   void emit_float( jfloat  x)  { *((jfloat*)  end()) = x; set_end(end() + sizeof(jfloat)); }
216   void emit_double(jdouble x)  { *((jdouble*) end()) = x; set_end(end() + sizeof(jdouble)); }
217   void emit_address(address x) { *((address*) end()) = x; set_end(end() + sizeof(address)); }
218 
219   // Share a scratch buffer for relocinfo.  (Hacky; saves a resource allocation.)
220   void initialize_shared_locs(relocInfo* buf, int length);
221 
222   // Manage labels and their addresses.
223   address target(Label&amp; L, address branch_pc);
224 
225   // Emit a relocation.
226   void relocate(address at, RelocationHolder const&amp; rspec, int format = 0);
227   void relocate(address at,    relocInfo::relocType rtype, int format = 0, jint method_index = 0);
228 
229   // alignment requirement for starting offset
230   // Requirements are that the instruction area and the
231   // stubs area must start on CodeEntryAlignment, and
232   // the ctable on sizeof(jdouble)
233   int alignment() const             { return MAX2((int)sizeof(jdouble), (int)CodeEntryAlignment); }
234 
235   // Slop between sections, used only when allocating temporary BufferBlob buffers.
236   static csize_t end_slop()         { return MAX2((int)sizeof(jdouble), (int)CodeEntryAlignment); }
237 
238   csize_t align_at_start(csize_t off) const { return (csize_t) align_up(off, alignment()); }
239 
240   // Mark a section frozen.  Assign its remaining space to
241   // the following section.  It will never expand after this point.
242   inline void freeze();         //  { _outer-&gt;freeze_section(this); }
243 
244   // Ensure there&#39;s enough space left in the current section.
245   // Return true if there was an expansion.
246   bool maybe_expand_to_ensure_remaining(csize_t amount);
247 
248 #ifndef PRODUCT
249   void decode();
250   void print(const char* name);
251 #endif //PRODUCT
252 };
253 
254 class CodeString;
255 class CodeStrings {
256 private:
257 #ifndef PRODUCT
258   CodeString* _strings;
259   CodeString* _strings_last;
260 #ifdef ASSERT
261   // Becomes true after copy-out, forbids further use.
262   bool _defunct; // Zero bit pattern is &quot;valid&quot;, see memset call in decode_env::decode_env
263 #endif
264   static const char* _prefix; // defaults to &quot; ;; &quot;
265 #endif
266 
267   CodeString* find(intptr_t offset) const;
268   CodeString* find_last(intptr_t offset) const;
269 
270   void set_null_and_invalidate() {
271 #ifndef PRODUCT
272     _strings = NULL;
273     _strings_last = NULL;
274 #ifdef ASSERT
275     _defunct = true;
276 #endif
277 #endif
278   }
279 
280 public:
281   CodeStrings() {
282 #ifndef PRODUCT
283     _strings = NULL;
284     _strings_last = NULL;
285 #ifdef ASSERT
286     _defunct = false;
287 #endif
288 #endif
289   }
290 
291   bool is_null() {
292 #ifdef ASSERT
293     return _strings == NULL;
294 #else
295     return true;
296 #endif
297   }
298 
299   const char* add_string(const char * string) PRODUCT_RETURN_(return NULL;);
300 
301   void add_comment(intptr_t offset, const char * comment) PRODUCT_RETURN;
302   bool has_block_comment(intptr_t offset) const;
303   void print_block_comment(outputStream* stream, intptr_t offset) const PRODUCT_RETURN;
304   // MOVE strings from other to this; invalidate other.
305   void assign(CodeStrings&amp; other)  PRODUCT_RETURN;
306   // COPY strings from other to this; leave other valid.
307   void copy(CodeStrings&amp; other)  PRODUCT_RETURN;
308   // FREE strings; invalidate this.
309   void free() PRODUCT_RETURN;
310 
311   // Guarantee that _strings are used at most once; assign and free invalidate a buffer.
312   inline void check_valid() const {
313 #ifdef ASSERT
314     assert(!_defunct, &quot;Use of invalid CodeStrings&quot;);
315 #endif
316   }
317 
318   static void set_prefix(const char *prefix) {
319 #ifndef PRODUCT
320     _prefix = prefix;
321 #endif
322   }
323 };
324 
325 // A CodeBuffer describes a memory space into which assembly
326 // code is generated.  This memory space usually occupies the
327 // interior of a single BufferBlob, but in some cases it may be
328 // an arbitrary span of memory, even outside the code cache.
329 //
330 // A code buffer comes in two variants:
331 //
332 // (1) A CodeBuffer referring to an already allocated piece of memory:
333 //     This is used to direct &#39;static&#39; code generation (e.g. for interpreter
334 //     or stubroutine generation, etc.).  This code comes with NO relocation
335 //     information.
336 //
337 // (2) A CodeBuffer referring to a piece of memory allocated when the
338 //     CodeBuffer is allocated.  This is used for nmethod generation.
339 //
340 // The memory can be divided up into several parts called sections.
341 // Each section independently accumulates code (or data) an relocations.
342 // Sections can grow (at the expense of a reallocation of the BufferBlob
343 // and recopying of all active sections).  When the buffered code is finally
344 // written to an nmethod (or other CodeBlob), the contents (code, data,
345 // and relocations) of the sections are padded to an alignment and concatenated.
346 // Instructions and data in one section can contain relocatable references to
347 // addresses in a sibling section.
348 
349 class CodeBuffer: public StackObj {
350   friend class CodeSection;
351   friend class StubCodeGenerator;
352 
353  private:
354   // CodeBuffers must be allocated on the stack except for a single
355   // special case during expansion which is handled internally.  This
356   // is done to guarantee proper cleanup of resources.
357   void* operator new(size_t size) throw() { return ResourceObj::operator new(size); }
358   void  operator delete(void* p)          { ShouldNotCallThis(); }
359 
360  public:
361   typedef int csize_t;  // code size type; would be size_t except for history
362   enum {
363     // Here is the list of all possible sections.  The order reflects
364     // the final layout.
365     SECT_FIRST = 0,
366     SECT_CONSTS = SECT_FIRST, // Non-instruction data:  Floats, jump tables, etc.
367     SECT_INSTS,               // Executable instructions.
368     SECT_STUBS,               // Outbound trampolines for supporting call sites.
369     SECT_LIMIT, SECT_NONE = -1
370   };
371 
372  private:
373   enum {
374     sect_bits = 2,      // assert (SECT_LIMIT &lt;= (1&lt;&lt;sect_bits))
375     sect_mask = (1&lt;&lt;sect_bits)-1
376   };
377 
378   const char*  _name;
379 
380   CodeSection  _consts;             // constants, jump tables
381   CodeSection  _insts;              // instructions (the main section)
382   CodeSection  _stubs;              // stubs (call site support), deopt, exception handling
383 
384   CodeBuffer*  _before_expand;  // dead buffer, from before the last expansion
385 
386   BufferBlob*  _blob;           // optional buffer in CodeCache for generated code
387   address      _total_start;    // first address of combined memory buffer
388   csize_t      _total_size;     // size in bytes of combined memory buffer
389 
390   OopRecorder* _oop_recorder;
391   CodeStrings  _code_strings;
392   bool         _collect_comments;      // Indicate if we need to collect block comments at all.
393   OopRecorder  _default_oop_recorder;  // override with initialize_oop_recorder
394   Arena*       _overflow_arena;
395 
396   address      _last_insn;      // used to merge consecutive memory barriers, loads or stores.
397 
398 #if INCLUDE_AOT
399   bool         _immutable_PIC;
400 #endif
401 
402   address      _decode_begin;   // start address for decode
403   address      decode_begin();
404 
405   void initialize_misc(const char * name) {
406     // all pointers other than code_start/end and those inside the sections
407     assert(name != NULL, &quot;must have a name&quot;);
408     _name            = name;
409     _before_expand   = NULL;
410     _blob            = NULL;
411     _oop_recorder    = NULL;
412     _decode_begin    = NULL;
413     _overflow_arena  = NULL;
414     _code_strings    = CodeStrings();
415     _last_insn       = NULL;
416 #if INCLUDE_AOT
417     _immutable_PIC   = false;
418 #endif
419 
420     // Collect block comments, but restrict collection to cases where a disassembly is output.
421     _collect_comments = ( PrintAssembly
422                        || PrintStubCode
423                        || PrintMethodHandleStubs
424                        || PrintInterpreter
425                        || PrintSignatureHandlers
426                        || UnlockDiagnosticVMOptions
427                         );
428   }
429 
430   void initialize(address code_start, csize_t code_size) {
431     _consts.initialize_outer(this,  SECT_CONSTS);
432     _insts.initialize_outer(this,   SECT_INSTS);
433     _stubs.initialize_outer(this,   SECT_STUBS);
434     _total_start = code_start;
435     _total_size  = code_size;
436     // Initialize the main section:
437     _insts.initialize(code_start, code_size);
438     assert(!_stubs.is_allocated(),  &quot;no garbage here&quot;);
439     assert(!_consts.is_allocated(), &quot;no garbage here&quot;);
440     _oop_recorder = &amp;_default_oop_recorder;
441   }
442 
443   void initialize_section_size(CodeSection* cs, csize_t size);
444 
445   void freeze_section(CodeSection* cs);
446 
447   // helper for CodeBuffer::expand()
448   void take_over_code_from(CodeBuffer* cs);
449 
450   // ensure sections are disjoint, ordered, and contained in the blob
451   void verify_section_allocation();
452 
453   // copies combined relocations to the blob, returns bytes copied
454   // (if target is null, it is a dry run only, just for sizing)
455   csize_t copy_relocations_to(CodeBlob* blob) const;
456 
457   // copies combined code to the blob (assumes relocs are already in there)
458   void copy_code_to(CodeBlob* blob);
459 
460   // moves code sections to new buffer (assumes relocs are already in there)
461   void relocate_code_to(CodeBuffer* cb) const;
462 
463   // set up a model of the final layout of my contents
464   void compute_final_layout(CodeBuffer* dest) const;
465 
466   // Expand the given section so at least &#39;amount&#39; is remaining.
467   // Creates a new, larger BufferBlob, and rewrites the code &amp; relocs.
468   void expand(CodeSection* which_cs, csize_t amount);
469 
470   // Helper for expand.
471   csize_t figure_expanded_capacities(CodeSection* which_cs, csize_t amount, csize_t* new_capacity);
472 
473  public:
474   // (1) code buffer referring to pre-allocated instruction memory
475   CodeBuffer(address code_start, csize_t code_size) {
476     assert(code_start != NULL, &quot;sanity&quot;);
477     initialize_misc(&quot;static buffer&quot;);
478     initialize(code_start, code_size);
479     verify_section_allocation();
480   }
481 
482   // (2) CodeBuffer referring to pre-allocated CodeBlob.
483   CodeBuffer(CodeBlob* blob);
484 
485   // (3) code buffer allocating codeBlob memory for code &amp; relocation
486   // info but with lazy initialization.  The name must be something
487   // informative.
488   CodeBuffer(const char* name) {
489     initialize_misc(name);
490   }
491 
492   // (4) code buffer allocating codeBlob memory for code &amp; relocation
493   // info.  The name must be something informative and code_size must
494   // include both code and stubs sizes.
495   CodeBuffer(const char* name, csize_t code_size, csize_t locs_size) {
496     initialize_misc(name);
497     initialize(code_size, locs_size);
498   }
499 
500   ~CodeBuffer();
501 
502   // Initialize a CodeBuffer constructed using constructor 3.  Using
503   // constructor 4 is equivalent to calling constructor 3 and then
504   // calling this method.  It&#39;s been factored out for convenience of
505   // construction.
506   void initialize(csize_t code_size, csize_t locs_size);
507 
508   CodeSection* consts() { return &amp;_consts; }
509   CodeSection* insts() { return &amp;_insts; }
510   CodeSection* stubs() { return &amp;_stubs; }
511 
512   const CodeSection* insts() const { return &amp;_insts; }
513 
514   // present sections in order; return NULL at end; consts is #0, etc.
515   CodeSection* code_section(int n) {
516     // This makes the slightly questionable but portable assumption
517     // that the various members (_consts, _insts, _stubs, etc.) are
518     // adjacent in the layout of CodeBuffer.
519     CodeSection* cs = &amp;_consts + n;
520     assert(cs-&gt;index() == n || !cs-&gt;is_allocated(), &quot;sanity&quot;);
521     return cs;
522   }
523   const CodeSection* code_section(int n) const {  // yucky const stuff
524     return ((CodeBuffer*)this)-&gt;code_section(n);
525   }
526   static const char* code_section_name(int n);
527   int section_index_of(address addr) const;
528   bool contains(address addr) const {
529     // handy for debugging
530     return section_index_of(addr) &gt; SECT_NONE;
531   }
532 
533   // A stable mapping between &#39;locators&#39; (small ints) and addresses.
534   static int locator_pos(int locator)   { return locator &gt;&gt; sect_bits; }
535   static int locator_sect(int locator)  { return locator &amp;  sect_mask; }
536   static int locator(int pos, int sect) { return (pos &lt;&lt; sect_bits) | sect; }
537   int        locator(address addr) const;
538   address    locator_address(int locator) const;
539 
540   // Heuristic for pre-packing the taken/not-taken bit of a predicted branch.
541   bool is_backward_branch(Label&amp; L);
542 
543   // Properties
544   const char* name() const                  { return _name; }
545   void set_name(const char* name)           { _name = name; }
546   CodeBuffer* before_expand() const         { return _before_expand; }
547   BufferBlob* blob() const                  { return _blob; }
548   void    set_blob(BufferBlob* blob);
549   void   free_blob();                       // Free the blob, if we own one.
550 
551   // Properties relative to the insts section:
552   address       insts_begin() const      { return _insts.start();      }
553   address       insts_end() const        { return _insts.end();        }
554   void      set_insts_end(address end)   {        _insts.set_end(end); }
555   address       insts_limit() const      { return _insts.limit();      }
556   address       insts_mark() const       { return _insts.mark();       }
557   void      set_insts_mark()             {        _insts.set_mark();   }
558   void    clear_insts_mark()             {        _insts.clear_mark(); }
559 
560   // is there anything in the buffer other than the current section?
561   bool    is_pure() const                { return insts_size() == total_content_size(); }
562 
563   // size in bytes of output so far in the insts sections
564   csize_t insts_size() const             { return _insts.size(); }
565 
566   // same as insts_size(), except that it asserts there is no non-code here
567   csize_t pure_insts_size() const        { assert(is_pure(), &quot;no non-code&quot;);
568                                            return insts_size(); }
569   // capacity in bytes of the insts sections
570   csize_t insts_capacity() const         { return _insts.capacity(); }
571 
572   // number of bytes remaining in the insts section
573   csize_t insts_remaining() const        { return _insts.remaining(); }
574 
575   // is a given address in the insts section?  (2nd version is end-inclusive)
576   bool insts_contains(address pc) const  { return _insts.contains(pc); }
577   bool insts_contains2(address pc) const { return _insts.contains2(pc); }
578 
579   // Record any extra oops required to keep embedded metadata alive
580   void finalize_oop_references(const methodHandle&amp; method);
581 
582   // Allocated size in all sections, when aligned and concatenated
583   // (this is the eventual state of the content in its final
584   // CodeBlob).
585   csize_t total_content_size() const;
586 
587   // Combined offset (relative to start of first section) of given
588   // section, as eventually found in the final CodeBlob.
589   csize_t total_offset_of(const CodeSection* cs) const;
590 
591   // allocated size of all relocation data, including index, rounded up
592   csize_t total_relocation_size() const;
593 
594   csize_t copy_relocations_to(address buf, csize_t buf_limit, bool only_inst) const;
595 
596   // allocated size of any and all recorded oops
597   csize_t total_oop_size() const {
598     OopRecorder* recorder = oop_recorder();
599     return (recorder == NULL)? 0: recorder-&gt;oop_size();
600   }
601 
602   // allocated size of any and all recorded metadata
603   csize_t total_metadata_size() const {
604     OopRecorder* recorder = oop_recorder();
605     return (recorder == NULL)? 0: recorder-&gt;metadata_size();
606   }
607 
608   // Configuration functions, called immediately after the CB is constructed.
609   // The section sizes are subtracted from the original insts section.
610   // Note:  Call them in reverse section order, because each steals from insts.
611   void initialize_consts_size(csize_t size)            { initialize_section_size(&amp;_consts,  size); }
612   void initialize_stubs_size(csize_t size)             { initialize_section_size(&amp;_stubs,   size); }
613   // Override default oop recorder.
614   void initialize_oop_recorder(OopRecorder* r);
615 
616   OopRecorder* oop_recorder() const   { return _oop_recorder; }
617   CodeStrings&amp; strings()              { return _code_strings; }
618 
619   address last_insn() const { return _last_insn; }
620   void set_last_insn(address a) { _last_insn = a; }
621   void clear_last_insn() { set_last_insn(NULL); }
622 
623   void free_strings() {
624     if (!_code_strings.is_null()) {
625       _code_strings.free(); // sets _strings Null as a side-effect.
626     }
627   }
628 
629   // Directly disassemble code buffer.
630   // Print the comment associated with offset on stream, if there is one.
631   virtual void print_block_comment(outputStream* stream, address block_begin) {
632 #ifndef PRODUCT
633     intptr_t offset = (intptr_t)(block_begin - _total_start);  // I assume total_start is not correct for all code sections.
634     _code_strings.print_block_comment(stream, offset);
635 #endif
636   }
637   bool has_block_comment(address block_begin) {
638 #ifndef PRODUCT
639     intptr_t offset = (intptr_t)(block_begin - _total_start);  // I assume total_start is not correct for all code sections.
640     return _code_strings.has_block_comment(offset);
641 #else
642     return false;
643 #endif
644   }
645 
646   // Code generation
647   void relocate(address at, RelocationHolder const&amp; rspec, int format = 0) {
648     _insts.relocate(at, rspec, format);
649   }
650   void relocate(address at,    relocInfo::relocType rtype, int format = 0) {
651     _insts.relocate(at, rtype, format);
652   }
653 
654   // Management of overflow storage for binding of Labels.
655   GrowableArray&lt;int&gt;* create_patch_overflow();
656 
657   // NMethod generation
658   void copy_code_and_locs_to(CodeBlob* blob) {
659     assert(blob != NULL, &quot;sane&quot;);
660     copy_relocations_to(blob);
661     copy_code_to(blob);
662   }
663   void copy_values_to(nmethod* nm) {
664     if (!oop_recorder()-&gt;is_unused()) {
665       oop_recorder()-&gt;copy_values_to(nm);
666     }
667   }
668 
669   // Transform an address from the code in this code buffer to a specified code buffer
670   address transform_address(const CodeBuffer &amp;cb, address addr) const;
671 
672   void block_comment(intptr_t offset, const char * comment) PRODUCT_RETURN;
673   const char* code_string(const char* str) PRODUCT_RETURN_(return NULL;);
674 
675   // Log a little info about section usage in the CodeBuffer
676   void log_section_sizes(const char* name);
677 
678 #if INCLUDE_AOT
679   // True if this is a code buffer used for immutable PIC, i.e. AOT
680   // compilation.
681   bool immutable_PIC() { return _immutable_PIC; }
682   void set_immutable_PIC(bool pic) { _immutable_PIC = pic; }
683 #endif
684 
685 #ifndef PRODUCT
686  public:
687   // Printing / Decoding
688   // decodes from decode_begin() to code_end() and sets decode_begin to end
689   void    decode();
690   void    print();
691 #endif
692   // Directly disassemble code buffer.
693   void    decode(address start, address end);
694 
695   // The following header contains architecture-specific implementations
696 #include CPU_HEADER(codeBuffer)
697 
698 };
699 
700 
701 inline void CodeSection::freeze() {
702   _outer-&gt;freeze_section(this);
703 }
704 
705 inline bool CodeSection::maybe_expand_to_ensure_remaining(csize_t amount) {
706   if (remaining() &lt; amount) { _outer-&gt;expand(this, amount); return true; }
707   return false;
708 }
709 
710 #endif // SHARE_ASM_CODEBUFFER_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
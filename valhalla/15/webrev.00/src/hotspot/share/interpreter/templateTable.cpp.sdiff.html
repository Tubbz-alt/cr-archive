<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/templateTable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="templateInterpreter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/templateTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/barrierSet.hpp&quot;
 27 #include &quot;interpreter/interp_masm.hpp&quot;
 28 #include &quot;interpreter/templateTable.hpp&quot;
<span class="line-removed"> 29 #include &quot;runtime/timerTrace.hpp&quot;</span>
 30 
 31 #ifdef CC_INTERP
 32 
 33 void templateTable_init() {
 34 }
 35 
 36 #else
 37 
 38 //----------------------------------------------------------------------------------------------------
 39 // Implementation of Template
 40 
 41 
 42 void Template::initialize(int flags, TosState tos_in, TosState tos_out, generator gen, int arg) {
 43   _flags   = flags;
 44   _tos_in  = tos_in;
 45   _tos_out = tos_out;
 46   _gen     = gen;
 47   _arg     = arg;
 48 }
 49 
</pre>
<hr />
<pre>
152 void TemplateTable::jsr() {
153   transition(vtos, vtos);       // result is not an oop, so do not transition to atos
154   branch(true, false);
155 }
156 
157 
158 
159 //----------------------------------------------------------------------------------------------------
160 // Implementation of TemplateTable: Debugging
161 
162 void TemplateTable::transition(TosState tos_in, TosState tos_out) {
163   assert(_desc-&gt;tos_in()  == tos_in,
164          &quot;inconsistent tos_in  information&quot;);
165   assert(_desc-&gt;tos_out() == tos_out, &quot;inconsistent tos_out information&quot;);
166 }
167 
168 
169 //----------------------------------------------------------------------------------------------------
170 // Implementation of TemplateTable: Initialization
171 
<span class="line-removed">172 bool                       TemplateTable::_is_initialized = false;</span>
173 Template                   TemplateTable::_template_table     [Bytecodes::number_of_codes];
174 Template                   TemplateTable::_template_table_wide[Bytecodes::number_of_codes];
175 
176 Template*                  TemplateTable::_desc;
177 InterpreterMacroAssembler* TemplateTable::_masm;
<span class="line-removed">178 BarrierSet*                TemplateTable::_bs;</span>
179 
180 
181 void TemplateTable::def(Bytecodes::Code code, int flags, TosState in, TosState out, void (*gen)(), char filler) {
182   assert(filler == &#39; &#39;, &quot;just checkin&#39;&quot;);
183   def(code, flags, in, out, (Template::generator)gen, 0);
184 }
185 
186 
187 void TemplateTable::def(Bytecodes::Code code, int flags, TosState in, TosState out, void (*gen)(int arg), int arg) {
188   // should factor out these constants
<span class="line-removed">189   const int ubcp = 1 &lt;&lt; Template::uses_bcp_bit;</span>
<span class="line-removed">190   const int disp = 1 &lt;&lt; Template::does_dispatch_bit;</span>
<span class="line-removed">191   const int clvm = 1 &lt;&lt; Template::calls_vm_bit;</span>
192   const int iswd = 1 &lt;&lt; Template::wide_bit;
193   // determine which table to use
194   bool is_wide = (flags &amp; iswd) != 0;
195   // make sure that wide instructions have a vtos entry point
196   // (since they are executed extremely rarely, it doesn&#39;t pay out to have an
197   // extra set of 5 dispatch tables for the wide instructions - for simplicity
198   // they all go with one table)
199   assert(in == vtos || !is_wide, &quot;wide instructions have vtos entry point only&quot;);
200   Template* t = is_wide ? template_for_wide(code) : template_for(code);
201   // setup entry
202   t-&gt;initialize(flags, in, out, gen, arg);
203   assert(t-&gt;bytecode() == code, &quot;just checkin&#39;&quot;);
204 }
205 
206 
207 void TemplateTable::def(Bytecodes::Code code, int flags, TosState in, TosState out, void (*gen)(Operation op), Operation op) {
208   def(code, flags, in, out, (Template::generator)gen, (int)op);
209 }
210 
211 
212 void TemplateTable::def(Bytecodes::Code code, int flags, TosState in, TosState out, void (*gen)(bool arg    ), bool arg) {
213   def(code, flags, in, out, (Template::generator)gen, (int)arg);
214 }
215 
216 
217 void TemplateTable::def(Bytecodes::Code code, int flags, TosState in, TosState out, void (*gen)(TosState tos), TosState tos) {
218   def(code, flags, in, out, (Template::generator)gen, (int)tos);
219 }
220 
221 
222 void TemplateTable::def(Bytecodes::Code code, int flags, TosState in, TosState out, void (*gen)(Condition cc), Condition cc) {
223   def(code, flags, in, out, (Template::generator)gen, (int)cc);
224 }
225 
226 void TemplateTable::initialize() {
<span class="line-modified">227   if (_is_initialized) return;</span>
<span class="line-modified">228 </span>
<span class="line-modified">229   // Initialize table</span>
<span class="line-modified">230   TraceTime timer(&quot;TemplateTable initialization&quot;, TRACETIME_LOG(Info, startuptime));</span>
<span class="line-modified">231 </span>
<span class="line-removed">232   _bs = BarrierSet::barrier_set();</span>
233 
234   // For better readability
235   const char _    = &#39; &#39;;
236   const int  ____ = 0;
237   const int  ubcp = 1 &lt;&lt; Template::uses_bcp_bit;
238   const int  disp = 1 &lt;&lt; Template::does_dispatch_bit;
239   const int  clvm = 1 &lt;&lt; Template::calls_vm_bit;
240   const int  iswd = 1 &lt;&lt; Template::wide_bit;
241 
242   //                                    interpr. templates
243   // Java spec bytecodes                ubcp|disp|clvm|iswd  in    out   generator             argument
244   def(Bytecodes::_nop                 , ____|____|____|____, vtos, vtos, nop                 ,  _           );
245   def(Bytecodes::_aconst_null         , ____|____|____|____, vtos, atos, aconst_null         ,  _           );
246   def(Bytecodes::_iconst_m1           , ____|____|____|____, vtos, itos, iconst              , -1           );
247   def(Bytecodes::_iconst_0            , ____|____|____|____, vtos, itos, iconst              ,  0           );
248   def(Bytecodes::_iconst_1            , ____|____|____|____, vtos, itos, iconst              ,  1           );
249   def(Bytecodes::_iconst_2            , ____|____|____|____, vtos, itos, iconst              ,  2           );
250   def(Bytecodes::_iconst_3            , ____|____|____|____, vtos, itos, iconst              ,  3           );
251   def(Bytecodes::_iconst_4            , ____|____|____|____, vtos, itos, iconst              ,  4           );
252   def(Bytecodes::_iconst_5            , ____|____|____|____, vtos, itos, iconst              ,  5           );
</pre>
<hr />
<pre>
498   def(Bytecodes::_fast_linearswitch   , ubcp|disp|____|____, itos, vtos, fast_linearswitch   ,  _           );
499   def(Bytecodes::_fast_binaryswitch   , ubcp|disp|____|____, itos, vtos, fast_binaryswitch   ,  _           );
500 
501   def(Bytecodes::_fast_aldc           , ubcp|____|clvm|____, vtos, atos, fast_aldc           ,  false       );
502   def(Bytecodes::_fast_aldc_w         , ubcp|____|clvm|____, vtos, atos, fast_aldc           ,  true        );
503 
504   def(Bytecodes::_return_register_finalizer , ____|disp|clvm|____, vtos, vtos, _return       ,  vtos        );
505 
506   def(Bytecodes::_invokehandle        , ubcp|disp|clvm|____, vtos, vtos, invokehandle        , f1_byte      );
507 
508   def(Bytecodes::_nofast_getfield     , ubcp|____|clvm|____, vtos, vtos, nofast_getfield     , f1_byte      );
509   def(Bytecodes::_nofast_putfield     , ubcp|____|clvm|____, vtos, vtos, nofast_putfield     , f2_byte      );
510 
511   def(Bytecodes::_nofast_aload_0      , ____|____|clvm|____, vtos, atos, nofast_aload_0      ,  _           );
512   def(Bytecodes::_nofast_iload        , ubcp|____|clvm|____, vtos, itos, nofast_iload        ,  _           );
513 
514 
515   def(Bytecodes::_shouldnotreachhere   , ____|____|____|____, vtos, vtos, shouldnotreachhere ,  _           );
516   // platform specific bytecodes
517   pd_initialize();
<span class="line-removed">518 </span>
<span class="line-removed">519   _is_initialized = true;</span>
520 }
521 
<span class="line-removed">522 void templateTable_init() {</span>
<span class="line-removed">523   TemplateTable::initialize();</span>
<span class="line-removed">524 }</span>
<span class="line-removed">525 </span>
<span class="line-removed">526 </span>
527 void TemplateTable::unimplemented_bc() {
528   _masm-&gt;unimplemented( Bytecodes::name(_desc-&gt;bytecode()));
529 }
530 #endif /* !CC_INTERP */
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/barrierSet.hpp&quot;
 27 #include &quot;interpreter/interp_masm.hpp&quot;
 28 #include &quot;interpreter/templateTable.hpp&quot;

 29 
 30 #ifdef CC_INTERP
 31 
 32 void templateTable_init() {
 33 }
 34 
 35 #else
 36 
 37 //----------------------------------------------------------------------------------------------------
 38 // Implementation of Template
 39 
 40 
 41 void Template::initialize(int flags, TosState tos_in, TosState tos_out, generator gen, int arg) {
 42   _flags   = flags;
 43   _tos_in  = tos_in;
 44   _tos_out = tos_out;
 45   _gen     = gen;
 46   _arg     = arg;
 47 }
 48 
</pre>
<hr />
<pre>
151 void TemplateTable::jsr() {
152   transition(vtos, vtos);       // result is not an oop, so do not transition to atos
153   branch(true, false);
154 }
155 
156 
157 
158 //----------------------------------------------------------------------------------------------------
159 // Implementation of TemplateTable: Debugging
160 
161 void TemplateTable::transition(TosState tos_in, TosState tos_out) {
162   assert(_desc-&gt;tos_in()  == tos_in,
163          &quot;inconsistent tos_in  information&quot;);
164   assert(_desc-&gt;tos_out() == tos_out, &quot;inconsistent tos_out information&quot;);
165 }
166 
167 
168 //----------------------------------------------------------------------------------------------------
169 // Implementation of TemplateTable: Initialization
170 

171 Template                   TemplateTable::_template_table     [Bytecodes::number_of_codes];
172 Template                   TemplateTable::_template_table_wide[Bytecodes::number_of_codes];
173 
174 Template*                  TemplateTable::_desc;
175 InterpreterMacroAssembler* TemplateTable::_masm;

176 
177 
178 void TemplateTable::def(Bytecodes::Code code, int flags, TosState in, TosState out, void (*gen)(), char filler) {
179   assert(filler == &#39; &#39;, &quot;just checkin&#39;&quot;);
180   def(code, flags, in, out, (Template::generator)gen, 0);
181 }
182 
183 
184 void TemplateTable::def(Bytecodes::Code code, int flags, TosState in, TosState out, void (*gen)(int arg), int arg) {
185   // should factor out these constants



186   const int iswd = 1 &lt;&lt; Template::wide_bit;
187   // determine which table to use
188   bool is_wide = (flags &amp; iswd) != 0;
189   // make sure that wide instructions have a vtos entry point
190   // (since they are executed extremely rarely, it doesn&#39;t pay out to have an
191   // extra set of 5 dispatch tables for the wide instructions - for simplicity
192   // they all go with one table)
193   assert(in == vtos || !is_wide, &quot;wide instructions have vtos entry point only&quot;);
194   Template* t = is_wide ? template_for_wide(code) : template_for(code);
195   // setup entry
196   t-&gt;initialize(flags, in, out, gen, arg);
197   assert(t-&gt;bytecode() == code, &quot;just checkin&#39;&quot;);
198 }
199 
200 
201 void TemplateTable::def(Bytecodes::Code code, int flags, TosState in, TosState out, void (*gen)(Operation op), Operation op) {
202   def(code, flags, in, out, (Template::generator)gen, (int)op);
203 }
204 
205 
206 void TemplateTable::def(Bytecodes::Code code, int flags, TosState in, TosState out, void (*gen)(bool arg    ), bool arg) {
207   def(code, flags, in, out, (Template::generator)gen, (int)arg);
208 }
209 
210 
211 void TemplateTable::def(Bytecodes::Code code, int flags, TosState in, TosState out, void (*gen)(TosState tos), TosState tos) {
212   def(code, flags, in, out, (Template::generator)gen, (int)tos);
213 }
214 
215 
216 void TemplateTable::def(Bytecodes::Code code, int flags, TosState in, TosState out, void (*gen)(Condition cc), Condition cc) {
217   def(code, flags, in, out, (Template::generator)gen, (int)cc);
218 }
219 
220 void TemplateTable::initialize() {
<span class="line-modified">221 #ifdef ASSERT</span>
<span class="line-modified">222   static bool is_initialized = false;</span>
<span class="line-modified">223   assert(!is_initialized, &quot;must only initialize once&quot;);</span>
<span class="line-modified">224   is_initialized = true;</span>
<span class="line-modified">225 #endif</span>

226 
227   // For better readability
228   const char _    = &#39; &#39;;
229   const int  ____ = 0;
230   const int  ubcp = 1 &lt;&lt; Template::uses_bcp_bit;
231   const int  disp = 1 &lt;&lt; Template::does_dispatch_bit;
232   const int  clvm = 1 &lt;&lt; Template::calls_vm_bit;
233   const int  iswd = 1 &lt;&lt; Template::wide_bit;
234 
235   //                                    interpr. templates
236   // Java spec bytecodes                ubcp|disp|clvm|iswd  in    out   generator             argument
237   def(Bytecodes::_nop                 , ____|____|____|____, vtos, vtos, nop                 ,  _           );
238   def(Bytecodes::_aconst_null         , ____|____|____|____, vtos, atos, aconst_null         ,  _           );
239   def(Bytecodes::_iconst_m1           , ____|____|____|____, vtos, itos, iconst              , -1           );
240   def(Bytecodes::_iconst_0            , ____|____|____|____, vtos, itos, iconst              ,  0           );
241   def(Bytecodes::_iconst_1            , ____|____|____|____, vtos, itos, iconst              ,  1           );
242   def(Bytecodes::_iconst_2            , ____|____|____|____, vtos, itos, iconst              ,  2           );
243   def(Bytecodes::_iconst_3            , ____|____|____|____, vtos, itos, iconst              ,  3           );
244   def(Bytecodes::_iconst_4            , ____|____|____|____, vtos, itos, iconst              ,  4           );
245   def(Bytecodes::_iconst_5            , ____|____|____|____, vtos, itos, iconst              ,  5           );
</pre>
<hr />
<pre>
491   def(Bytecodes::_fast_linearswitch   , ubcp|disp|____|____, itos, vtos, fast_linearswitch   ,  _           );
492   def(Bytecodes::_fast_binaryswitch   , ubcp|disp|____|____, itos, vtos, fast_binaryswitch   ,  _           );
493 
494   def(Bytecodes::_fast_aldc           , ubcp|____|clvm|____, vtos, atos, fast_aldc           ,  false       );
495   def(Bytecodes::_fast_aldc_w         , ubcp|____|clvm|____, vtos, atos, fast_aldc           ,  true        );
496 
497   def(Bytecodes::_return_register_finalizer , ____|disp|clvm|____, vtos, vtos, _return       ,  vtos        );
498 
499   def(Bytecodes::_invokehandle        , ubcp|disp|clvm|____, vtos, vtos, invokehandle        , f1_byte      );
500 
501   def(Bytecodes::_nofast_getfield     , ubcp|____|clvm|____, vtos, vtos, nofast_getfield     , f1_byte      );
502   def(Bytecodes::_nofast_putfield     , ubcp|____|clvm|____, vtos, vtos, nofast_putfield     , f2_byte      );
503 
504   def(Bytecodes::_nofast_aload_0      , ____|____|clvm|____, vtos, atos, nofast_aload_0      ,  _           );
505   def(Bytecodes::_nofast_iload        , ubcp|____|clvm|____, vtos, itos, nofast_iload        ,  _           );
506 
507 
508   def(Bytecodes::_shouldnotreachhere   , ____|____|____|____, vtos, vtos, shouldnotreachhere ,  _           );
509   // platform specific bytecodes
510   pd_initialize();


511 }
512 





513 void TemplateTable::unimplemented_bc() {
514   _masm-&gt;unimplemented( Bytecodes::name(_desc-&gt;bytecode()));
515 }
516 #endif /* !CC_INTERP */
</pre>
</td>
</tr>
</table>
<center><a href="templateInterpreter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
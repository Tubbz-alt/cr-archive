<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/c1/c1_LinearScan.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_CFGPrinter.hpp&quot;
  27 #include &quot;c1/c1_CodeStubs.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_FrameMap.hpp&quot;
  30 #include &quot;c1/c1_IR.hpp&quot;
  31 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  32 #include &quot;c1/c1_LinearScan.hpp&quot;
  33 #include &quot;c1/c1_ValueStack.hpp&quot;
  34 #include &quot;code/vmreg.inline.hpp&quot;
  35 #include &quot;runtime/timerTrace.hpp&quot;
  36 #include &quot;utilities/bitMap.inline.hpp&quot;
  37 
  38 #ifndef PRODUCT
  39 
  40   static LinearScanStatistic _stat_before_alloc;
  41   static LinearScanStatistic _stat_after_asign;
  42   static LinearScanStatistic _stat_final;
  43 
  44   static LinearScanTimers _total_timer;
  45 
  46   // helper macro for short definition of timer
  47   #define TIME_LINEAR_SCAN(timer_name)  TraceTime _block_timer(&quot;&quot;, _total_timer.timer(LinearScanTimers::timer_name), TimeLinearScan || TimeEachLinearScan, Verbose);
  48 
  49   // helper macro for short definition of trace-output inside code
  50   #define TRACE_LINEAR_SCAN(level, code)       \
  51     if (TraceLinearScanLevel &gt;= level) {       \
  52       code;                                    \
  53     }
  54 
  55 #else
  56 
  57   #define TIME_LINEAR_SCAN(timer_name)
  58   #define TRACE_LINEAR_SCAN(level, code)
  59 
  60 #endif
  61 
  62 // Map BasicType to spill size in 32-bit words, matching VMReg&#39;s notion of words
  63 #ifdef _LP64
  64 static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 0, 2,  1, 2, 1, 2, -1};
  65 #else
  66 static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 0, 1, -1, 1, 1, 1, -1};
  67 #endif
  68 
  69 
  70 // Implementation of LinearScan
  71 
  72 LinearScan::LinearScan(IR* ir, LIRGenerator* gen, FrameMap* frame_map)
  73  : _compilation(ir-&gt;compilation())
  74  , _ir(ir)
  75  , _gen(gen)
  76  , _frame_map(frame_map)
  77  , _cached_blocks(*ir-&gt;linear_scan_order())
  78  , _num_virtual_regs(gen-&gt;max_virtual_register_number())
  79  , _has_fpu_registers(false)
  80  , _num_calls(-1)
  81  , _max_spills(0)
  82  , _unused_spill_slot(-1)
  83  , _intervals(0)   // initialized later with correct length
  84  , _new_intervals_from_allocation(NULL)
  85  , _sorted_intervals(NULL)
  86  , _needs_full_resort(false)
  87  , _lir_ops(0)     // initialized later with correct length
  88  , _block_of_op(0) // initialized later with correct length
  89  , _has_info(0)
  90  , _has_call(0)
  91  , _interval_in_loop(0)  // initialized later with correct length
  92  , _scope_value_cache(0) // initialized later with correct length
  93 #ifdef IA32
  94  , _fpu_stack_allocator(NULL)
  95 #endif
  96 {
  97   assert(this-&gt;ir() != NULL,          &quot;check if valid&quot;);
  98   assert(this-&gt;compilation() != NULL, &quot;check if valid&quot;);
  99   assert(this-&gt;gen() != NULL,         &quot;check if valid&quot;);
 100   assert(this-&gt;frame_map() != NULL,   &quot;check if valid&quot;);
 101 }
 102 
 103 
 104 // ********** functions for converting LIR-Operands to register numbers
 105 //
 106 // Emulate a flat register file comprising physical integer registers,
 107 // physical floating-point registers and virtual registers, in that order.
 108 // Virtual registers already have appropriate numbers, since V0 is
 109 // the number of physical registers.
 110 // Returns -1 for hi word if opr is a single word operand.
 111 //
 112 // Note: the inverse operation (calculating an operand for register numbers)
 113 //       is done in calc_operand_for_interval()
 114 
 115 int LinearScan::reg_num(LIR_Opr opr) {
 116   assert(opr-&gt;is_register(), &quot;should not call this otherwise&quot;);
 117 
 118   if (opr-&gt;is_virtual_register()) {
 119     assert(opr-&gt;vreg_number() &gt;= nof_regs, &quot;found a virtual register with a fixed-register number&quot;);
 120     return opr-&gt;vreg_number();
 121   } else if (opr-&gt;is_single_cpu()) {
 122     return opr-&gt;cpu_regnr();
 123   } else if (opr-&gt;is_double_cpu()) {
 124     return opr-&gt;cpu_regnrLo();
 125 #ifdef X86
 126   } else if (opr-&gt;is_single_xmm()) {
 127     return opr-&gt;fpu_regnr() + pd_first_xmm_reg;
 128   } else if (opr-&gt;is_double_xmm()) {
 129     return opr-&gt;fpu_regnrLo() + pd_first_xmm_reg;
 130 #endif
 131   } else if (opr-&gt;is_single_fpu()) {
 132     return opr-&gt;fpu_regnr() + pd_first_fpu_reg;
 133   } else if (opr-&gt;is_double_fpu()) {
 134     return opr-&gt;fpu_regnrLo() + pd_first_fpu_reg;
 135   } else {
 136     ShouldNotReachHere();
 137     return -1;
 138   }
 139 }
 140 
 141 int LinearScan::reg_numHi(LIR_Opr opr) {
 142   assert(opr-&gt;is_register(), &quot;should not call this otherwise&quot;);
 143 
 144   if (opr-&gt;is_virtual_register()) {
 145     return -1;
 146   } else if (opr-&gt;is_single_cpu()) {
 147     return -1;
 148   } else if (opr-&gt;is_double_cpu()) {
 149     return opr-&gt;cpu_regnrHi();
 150 #ifdef X86
 151   } else if (opr-&gt;is_single_xmm()) {
 152     return -1;
 153   } else if (opr-&gt;is_double_xmm()) {
 154     return -1;
 155 #endif
 156   } else if (opr-&gt;is_single_fpu()) {
 157     return -1;
 158   } else if (opr-&gt;is_double_fpu()) {
 159     return opr-&gt;fpu_regnrHi() + pd_first_fpu_reg;
 160   } else {
 161     ShouldNotReachHere();
 162     return -1;
 163   }
 164 }
 165 
 166 
 167 // ********** functions for classification of intervals
 168 
 169 bool LinearScan::is_precolored_interval(const Interval* i) {
 170   return i-&gt;reg_num() &lt; LinearScan::nof_regs;
 171 }
 172 
 173 bool LinearScan::is_virtual_interval(const Interval* i) {
 174   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base;
 175 }
 176 
 177 bool LinearScan::is_precolored_cpu_interval(const Interval* i) {
 178   return i-&gt;reg_num() &lt; LinearScan::nof_cpu_regs;
 179 }
 180 
 181 bool LinearScan::is_virtual_cpu_interval(const Interval* i) {
 182 #if defined(__SOFTFP__) || defined(E500V2)
 183   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base;
 184 #else
 185   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base &amp;&amp; (i-&gt;type() != T_FLOAT &amp;&amp; i-&gt;type() != T_DOUBLE);
 186 #endif // __SOFTFP__ or E500V2
 187 }
 188 
 189 bool LinearScan::is_precolored_fpu_interval(const Interval* i) {
 190   return i-&gt;reg_num() &gt;= LinearScan::nof_cpu_regs &amp;&amp; i-&gt;reg_num() &lt; LinearScan::nof_regs;
 191 }
 192 
 193 bool LinearScan::is_virtual_fpu_interval(const Interval* i) {
 194 #if defined(__SOFTFP__) || defined(E500V2)
 195   return false;
 196 #else
 197   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base &amp;&amp; (i-&gt;type() == T_FLOAT || i-&gt;type() == T_DOUBLE);
 198 #endif // __SOFTFP__ or E500V2
 199 }
 200 
 201 bool LinearScan::is_in_fpu_register(const Interval* i) {
 202   // fixed intervals not needed for FPU stack allocation
 203   return i-&gt;reg_num() &gt;= nof_regs &amp;&amp; pd_first_fpu_reg &lt;= i-&gt;assigned_reg() &amp;&amp; i-&gt;assigned_reg() &lt;= pd_last_fpu_reg;
 204 }
 205 
 206 bool LinearScan::is_oop_interval(const Interval* i) {
 207   // fixed intervals never contain oops
 208   return i-&gt;reg_num() &gt;= nof_regs &amp;&amp; i-&gt;type() == T_OBJECT;
 209 }
 210 
 211 
 212 // ********** General helper functions
 213 
 214 // compute next unused stack index that can be used for spilling
 215 int LinearScan::allocate_spill_slot(bool double_word) {
 216   int spill_slot;
 217   if (double_word) {
 218     if ((_max_spills &amp; 1) == 1) {
 219       // alignment of double-word values
 220       // the hole because of the alignment is filled with the next single-word value
 221       assert(_unused_spill_slot == -1, &quot;wasting a spill slot&quot;);
 222       _unused_spill_slot = _max_spills;
 223       _max_spills++;
 224     }
 225     spill_slot = _max_spills;
 226     _max_spills += 2;
 227 
 228   } else if (_unused_spill_slot != -1) {
 229     // re-use hole that was the result of a previous double-word alignment
 230     spill_slot = _unused_spill_slot;
 231     _unused_spill_slot = -1;
 232 
 233   } else {
 234     spill_slot = _max_spills;
 235     _max_spills++;
 236   }
 237 
 238   int result = spill_slot + LinearScan::nof_regs + frame_map()-&gt;argcount();
 239 
 240   // the class OopMapValue uses only 11 bits for storing the name of the
 241   // oop location. So a stack slot bigger than 2^11 leads to an overflow
 242   // that is not reported in product builds. Prevent this by checking the
 243   // spill slot here (altough this value and the later used location name
 244   // are slightly different)
 245   if (result &gt; 2000) {
 246     bailout(&quot;too many stack slots used&quot;);
 247   }
 248 
 249   return result;
 250 }
 251 
 252 void LinearScan::assign_spill_slot(Interval* it) {
 253   // assign the canonical spill slot of the parent (if a part of the interval
 254   // is already spilled) or allocate a new spill slot
 255   if (it-&gt;canonical_spill_slot() &gt;= 0) {
 256     it-&gt;assign_reg(it-&gt;canonical_spill_slot());
 257   } else {
 258     int spill = allocate_spill_slot(type2spill_size[it-&gt;type()] == 2);
 259     it-&gt;set_canonical_spill_slot(spill);
 260     it-&gt;assign_reg(spill);
 261   }
 262 }
 263 
 264 void LinearScan::propagate_spill_slots() {
 265   if (!frame_map()-&gt;finalize_frame(max_spills(), compilation()-&gt;needs_stack_repair())) {
 266     bailout(&quot;frame too large&quot;);
 267   }
 268 }
 269 
 270 // create a new interval with a predefined reg_num
 271 // (only used for parent intervals that are created during the building phase)
 272 Interval* LinearScan::create_interval(int reg_num) {
 273   assert(_intervals.at(reg_num) == NULL, &quot;overwriting exisiting interval&quot;);
 274 
 275   Interval* interval = new Interval(reg_num);
 276   _intervals.at_put(reg_num, interval);
 277 
 278   // assign register number for precolored intervals
 279   if (reg_num &lt; LIR_OprDesc::vreg_base) {
 280     interval-&gt;assign_reg(reg_num);
 281   }
 282   return interval;
 283 }
 284 
 285 // assign a new reg_num to the interval and append it to the list of intervals
 286 // (only used for child intervals that are created during register allocation)
 287 void LinearScan::append_interval(Interval* it) {
 288   it-&gt;set_reg_num(_intervals.length());
 289   _intervals.append(it);
 290   IntervalList* new_intervals = _new_intervals_from_allocation;
 291   if (new_intervals == NULL) {
 292     new_intervals = _new_intervals_from_allocation = new IntervalList();
 293   }
 294   new_intervals-&gt;append(it);
 295 }
 296 
 297 // copy the vreg-flags if an interval is split
 298 void LinearScan::copy_register_flags(Interval* from, Interval* to) {
 299   if (gen()-&gt;is_vreg_flag_set(from-&gt;reg_num(), LIRGenerator::byte_reg)) {
 300     gen()-&gt;set_vreg_flag(to-&gt;reg_num(), LIRGenerator::byte_reg);
 301   }
 302   if (gen()-&gt;is_vreg_flag_set(from-&gt;reg_num(), LIRGenerator::callee_saved)) {
 303     gen()-&gt;set_vreg_flag(to-&gt;reg_num(), LIRGenerator::callee_saved);
 304   }
 305 
 306   // Note: do not copy the must_start_in_memory flag because it is not necessary for child
 307   //       intervals (only the very beginning of the interval must be in memory)
 308 }
 309 
 310 
 311 // ********** spill move optimization
 312 // eliminate moves from register to stack if stack slot is known to be correct
 313 
 314 // called during building of intervals
 315 void LinearScan::change_spill_definition_pos(Interval* interval, int def_pos) {
 316   assert(interval-&gt;is_split_parent(), &quot;can only be called for split parents&quot;);
 317 
 318   switch (interval-&gt;spill_state()) {
 319     case noDefinitionFound:
 320       assert(interval-&gt;spill_definition_pos() == -1, &quot;must no be set before&quot;);
 321       interval-&gt;set_spill_definition_pos(def_pos);
 322       interval-&gt;set_spill_state(oneDefinitionFound);
 323       break;
 324 
 325     case oneDefinitionFound:
 326       assert(def_pos &lt;= interval-&gt;spill_definition_pos(), &quot;positions are processed in reverse order when intervals are created&quot;);
 327       if (def_pos &lt; interval-&gt;spill_definition_pos() - 2) {
 328         // second definition found, so no spill optimization possible for this interval
 329         interval-&gt;set_spill_state(noOptimization);
 330       } else {
 331         // two consecutive definitions (because of two-operand LIR form)
 332         assert(block_of_op_with_id(def_pos) == block_of_op_with_id(interval-&gt;spill_definition_pos()), &quot;block must be equal&quot;);
 333       }
 334       break;
 335 
 336     case noOptimization:
 337       // nothing to do
 338       break;
 339 
 340     default:
 341       assert(false, &quot;other states not allowed at this time&quot;);
 342   }
 343 }
 344 
 345 // called during register allocation
 346 void LinearScan::change_spill_state(Interval* interval, int spill_pos) {
 347   switch (interval-&gt;spill_state()) {
 348     case oneDefinitionFound: {
 349       int def_loop_depth = block_of_op_with_id(interval-&gt;spill_definition_pos())-&gt;loop_depth();
 350       int spill_loop_depth = block_of_op_with_id(spill_pos)-&gt;loop_depth();
 351 
 352       if (def_loop_depth &lt; spill_loop_depth) {
 353         // the loop depth of the spilling position is higher then the loop depth
 354         // at the definition of the interval -&gt; move write to memory out of loop
 355         // by storing at definitin of the interval
 356         interval-&gt;set_spill_state(storeAtDefinition);
 357       } else {
 358         // the interval is currently spilled only once, so for now there is no
 359         // reason to store the interval at the definition
 360         interval-&gt;set_spill_state(oneMoveInserted);
 361       }
 362       break;
 363     }
 364 
 365     case oneMoveInserted: {
 366       // the interval is spilled more then once, so it is better to store it to
 367       // memory at the definition
 368       interval-&gt;set_spill_state(storeAtDefinition);
 369       break;
 370     }
 371 
 372     case storeAtDefinition:
 373     case startInMemory:
 374     case noOptimization:
 375     case noDefinitionFound:
 376       // nothing to do
 377       break;
 378 
 379     default:
 380       assert(false, &quot;other states not allowed at this time&quot;);
 381   }
 382 }
 383 
 384 
 385 bool LinearScan::must_store_at_definition(const Interval* i) {
 386   return i-&gt;is_split_parent() &amp;&amp; i-&gt;spill_state() == storeAtDefinition;
 387 }
 388 
 389 // called once before asignment of register numbers
 390 void LinearScan::eliminate_spill_moves() {
 391   TIME_LINEAR_SCAN(timer_eliminate_spill_moves);
 392   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;***** Eliminating unnecessary spill moves&quot;));
 393 
 394   // collect all intervals that must be stored after their definion.
 395   // the list is sorted by Interval::spill_definition_pos
 396   Interval* interval;
 397   Interval* temp_list;
 398   create_unhandled_lists(&amp;interval, &amp;temp_list, must_store_at_definition, NULL);
 399 
 400 #ifdef ASSERT
 401   Interval* prev = NULL;
 402   Interval* temp = interval;
 403   while (temp != Interval::end()) {
 404     assert(temp-&gt;spill_definition_pos() &gt; 0, &quot;invalid spill definition pos&quot;);
 405     if (prev != NULL) {
 406       assert(temp-&gt;from() &gt;= prev-&gt;from(), &quot;intervals not sorted&quot;);
 407       assert(temp-&gt;spill_definition_pos() &gt;= prev-&gt;spill_definition_pos(), &quot;when intervals are sorted by from, then they must also be sorted by spill_definition_pos&quot;);
 408     }
 409 
 410     assert(temp-&gt;canonical_spill_slot() &gt;= LinearScan::nof_regs, &quot;interval has no spill slot assigned&quot;);
 411     assert(temp-&gt;spill_definition_pos() &gt;= temp-&gt;from(), &quot;invalid order&quot;);
 412     assert(temp-&gt;spill_definition_pos() &lt;= temp-&gt;from() + 2, &quot;only intervals defined once at their start-pos can be optimized&quot;);
 413 
 414     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;interval %d (from %d to %d) must be stored at %d&quot;, temp-&gt;reg_num(), temp-&gt;from(), temp-&gt;to(), temp-&gt;spill_definition_pos()));
 415 
 416     temp = temp-&gt;next();
 417   }
 418 #endif
 419 
 420   LIR_InsertionBuffer insertion_buffer;
 421   int num_blocks = block_count();
 422   for (int i = 0; i &lt; num_blocks; i++) {
 423     BlockBegin* block = block_at(i);
 424     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
 425     int         num_inst = instructions-&gt;length();
 426     bool        has_new = false;
 427 
 428     // iterate all instructions of the block. skip the first because it is always a label
 429     for (int j = 1; j &lt; num_inst; j++) {
 430       LIR_Op* op = instructions-&gt;at(j);
 431       int op_id = op-&gt;id();
 432 
 433       if (op_id == -1) {
 434         // remove move from register to stack if the stack slot is guaranteed to be correct.
 435         // only moves that have been inserted by LinearScan can be removed.
 436         assert(op-&gt;code() == lir_move, &quot;only moves can have a op_id of -1&quot;);
 437         assert(op-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
 438         assert(op-&gt;as_Op1()-&gt;result_opr()-&gt;is_virtual(), &quot;LinearScan inserts only moves to virtual registers&quot;);
 439 
 440         LIR_Op1* op1 = (LIR_Op1*)op;
 441         Interval* interval = interval_at(op1-&gt;result_opr()-&gt;vreg_number());
 442 
 443         if (interval-&gt;assigned_reg() &gt;= LinearScan::nof_regs &amp;&amp; interval-&gt;always_in_memory()) {
 444           // move target is a stack slot that is always correct, so eliminate instruction
 445           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;eliminating move from interval %d to %d&quot;, op1-&gt;in_opr()-&gt;vreg_number(), op1-&gt;result_opr()-&gt;vreg_number()));
 446           instructions-&gt;at_put(j, NULL); // NULL-instructions are deleted by assign_reg_num
 447         }
 448 
 449       } else {
 450         // insert move from register to stack just after the beginning of the interval
 451         assert(interval == Interval::end() || interval-&gt;spill_definition_pos() &gt;= op_id, &quot;invalid order&quot;);
 452         assert(interval == Interval::end() || (interval-&gt;is_split_parent() &amp;&amp; interval-&gt;spill_state() == storeAtDefinition), &quot;invalid interval&quot;);
 453 
 454         while (interval != Interval::end() &amp;&amp; interval-&gt;spill_definition_pos() == op_id) {
 455           if (!has_new) {
 456             // prepare insertion buffer (appended when all instructions of the block are processed)
 457             insertion_buffer.init(block-&gt;lir());
 458             has_new = true;
 459           }
 460 
 461           LIR_Opr from_opr = operand_for_interval(interval);
 462           LIR_Opr to_opr = canonical_spill_opr(interval);
 463           assert(from_opr-&gt;is_fixed_cpu() || from_opr-&gt;is_fixed_fpu(), &quot;from operand must be a register&quot;);
 464           assert(to_opr-&gt;is_stack(), &quot;to operand must be a stack slot&quot;);
 465 
 466           insertion_buffer.move(j, from_opr, to_opr);
 467           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;inserting move after definition of interval %d to stack slot %d at op_id %d&quot;, interval-&gt;reg_num(), interval-&gt;canonical_spill_slot() - LinearScan::nof_regs, op_id));
 468 
 469           interval = interval-&gt;next();
 470         }
 471       }
 472     } // end of instruction iteration
 473 
 474     if (has_new) {
 475       block-&gt;lir()-&gt;append(&amp;insertion_buffer);
 476     }
 477   } // end of block iteration
 478 
 479   assert(interval == Interval::end(), &quot;missed an interval&quot;);
 480 }
 481 
 482 
 483 // ********** Phase 1: number all instructions in all blocks
 484 // Compute depth-first and linear scan block orders, and number LIR_Op nodes for linear scan.
 485 
 486 void LinearScan::number_instructions() {
 487   {
 488     // dummy-timer to measure the cost of the timer itself
 489     // (this time is then subtracted from all other timers to get the real value)
 490     TIME_LINEAR_SCAN(timer_do_nothing);
 491   }
 492   TIME_LINEAR_SCAN(timer_number_instructions);
 493 
 494   // Assign IDs to LIR nodes and build a mapping, lir_ops, from ID to LIR_Op node.
 495   int num_blocks = block_count();
 496   int num_instructions = 0;
 497   int i;
 498   for (i = 0; i &lt; num_blocks; i++) {
 499     num_instructions += block_at(i)-&gt;lir()-&gt;instructions_list()-&gt;length();
 500   }
 501 
 502   // initialize with correct length
 503   _lir_ops = LIR_OpArray(num_instructions, num_instructions, NULL);
 504   _block_of_op = BlockBeginArray(num_instructions, num_instructions, NULL);
 505 
 506   int op_id = 0;
 507   int idx = 0;
 508 
 509   for (i = 0; i &lt; num_blocks; i++) {
 510     BlockBegin* block = block_at(i);
 511     block-&gt;set_first_lir_instruction_id(op_id);
 512     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
 513 
 514     int num_inst = instructions-&gt;length();
 515     for (int j = 0; j &lt; num_inst; j++) {
 516       LIR_Op* op = instructions-&gt;at(j);
 517       op-&gt;set_id(op_id);
 518 
 519       _lir_ops.at_put(idx, op);
 520       _block_of_op.at_put(idx, block);
 521       assert(lir_op_with_id(op_id) == op, &quot;must match&quot;);
 522 
 523       idx++;
 524       op_id += 2; // numbering of lir_ops by two
 525     }
 526     block-&gt;set_last_lir_instruction_id(op_id - 2);
 527   }
 528   assert(idx == num_instructions, &quot;must match&quot;);
 529   assert(idx * 2 == op_id, &quot;must match&quot;);
 530 
 531   _has_call.initialize(num_instructions);
 532   _has_info.initialize(num_instructions);
 533 }
 534 
 535 
 536 // ********** Phase 2: compute local live sets separately for each block
 537 // (sets live_gen and live_kill for each block)
 538 
 539 void LinearScan::set_live_gen_kill(Value value, LIR_Op* op, BitMap&amp; live_gen, BitMap&amp; live_kill) {
 540   LIR_Opr opr = value-&gt;operand();
 541   Constant* con = value-&gt;as_Constant();
 542 
 543   // check some asumptions about debug information
 544   assert(!value-&gt;type()-&gt;is_illegal(), &quot;if this local is used by the interpreter it shouldn&#39;t be of indeterminate type&quot;);
 545   assert(con == NULL || opr-&gt;is_virtual() || opr-&gt;is_constant() || opr-&gt;is_illegal(), &quot;asumption: Constant instructions have only constant operands&quot;);
 546   assert(con != NULL || opr-&gt;is_virtual(), &quot;asumption: non-Constant instructions have only virtual operands&quot;);
 547 
 548   if ((con == NULL || con-&gt;is_pinned()) &amp;&amp; opr-&gt;is_register()) {
 549     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 550     int reg = opr-&gt;vreg_number();
 551     if (!live_kill.at(reg)) {
 552       live_gen.set_bit(reg);
 553       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;  Setting live_gen for value %c%d, LIR op_id %d, register number %d&quot;, value-&gt;type()-&gt;tchar(), value-&gt;id(), op-&gt;id(), reg));
 554     }
 555   }
 556 }
 557 
 558 
 559 void LinearScan::compute_local_live_sets() {
 560   TIME_LINEAR_SCAN(timer_compute_local_live_sets);
 561 
 562   int  num_blocks = block_count();
 563   int  live_size = live_set_size();
 564   bool local_has_fpu_registers = false;
 565   int  local_num_calls = 0;
 566   LIR_OpVisitState visitor;
 567 
 568   BitMap2D local_interval_in_loop = BitMap2D(_num_virtual_regs, num_loops());
 569 
 570   // iterate all blocks
 571   for (int i = 0; i &lt; num_blocks; i++) {
 572     BlockBegin* block = block_at(i);
 573 
 574     ResourceBitMap live_gen(live_size);
 575     ResourceBitMap live_kill(live_size);
 576 
 577     if (block-&gt;is_set(BlockBegin::exception_entry_flag)) {
 578       // Phi functions at the begin of an exception handler are
 579       // implicitly defined (= killed) at the beginning of the block.
 580       for_each_phi_fun(block, phi,
 581         if (!phi-&gt;is_illegal()) { live_kill.set_bit(phi-&gt;operand()-&gt;vreg_number()); }
 582       );
 583     }
 584 
 585     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
 586     int num_inst = instructions-&gt;length();
 587 
 588     // iterate all instructions of the block. skip the first because it is always a label
 589     assert(visitor.no_operands(instructions-&gt;at(0)), &quot;first operation must always be a label&quot;);
 590     for (int j = 1; j &lt; num_inst; j++) {
 591       LIR_Op* op = instructions-&gt;at(j);
 592 
 593       // visit operation to collect all operands
 594       visitor.visit(op);
 595 
 596       if (visitor.has_call()) {
 597         _has_call.set_bit(op-&gt;id() &gt;&gt; 1);
 598         local_num_calls++;
 599       }
 600       if (visitor.info_count() &gt; 0) {
 601         _has_info.set_bit(op-&gt;id() &gt;&gt; 1);
 602       }
 603 
 604       // iterate input operands of instruction
 605       int k, n, reg;
 606       n = visitor.opr_count(LIR_OpVisitState::inputMode);
 607       for (k = 0; k &lt; n; k++) {
 608         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::inputMode, k);
 609         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
 610 
 611         if (opr-&gt;is_virtual_register()) {
 612           assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 613           reg = opr-&gt;vreg_number();
 614           if (!live_kill.at(reg)) {
 615             live_gen.set_bit(reg);
 616             TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;  Setting live_gen for register %d at instruction %d&quot;, reg, op-&gt;id()));
 617           }
 618           if (block-&gt;loop_index() &gt;= 0) {
 619             local_interval_in_loop.set_bit(reg, block-&gt;loop_index());
 620           }
 621           local_has_fpu_registers = local_has_fpu_registers || opr-&gt;is_virtual_fpu();
 622         }
 623 
 624 #ifdef ASSERT
 625         // fixed intervals are never live at block boundaries, so
 626         // they need not be processed in live sets.
 627         // this is checked by these assertions to be sure about it.
 628         // the entry block may have incoming values in registers, which is ok.
 629         if (!opr-&gt;is_virtual_register() &amp;&amp; block != ir()-&gt;start()) {
 630           reg = reg_num(opr);
 631           if (is_processed_reg_num(reg)) {
 632             assert(live_kill.at(reg), &quot;using fixed register that is not defined in this block&quot;);
 633           }
 634           reg = reg_numHi(opr);
 635           if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 636             assert(live_kill.at(reg), &quot;using fixed register that is not defined in this block&quot;);
 637           }
 638         }
 639 #endif
 640       }
 641 
 642       // Add uses of live locals from interpreter&#39;s point of view for proper debug information generation
 643       n = visitor.info_count();
 644       for (k = 0; k &lt; n; k++) {
 645         CodeEmitInfo* info = visitor.info_at(k);
 646         ValueStack* stack = info-&gt;stack();
 647         for_each_state_value(stack, value,
 648           set_live_gen_kill(value, op, live_gen, live_kill)
 649         );
 650       }
 651 
 652       // iterate temp operands of instruction
 653       n = visitor.opr_count(LIR_OpVisitState::tempMode);
 654       for (k = 0; k &lt; n; k++) {
 655         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::tempMode, k);
 656         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
 657 
 658         if (opr-&gt;is_virtual_register()) {
 659           assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 660           reg = opr-&gt;vreg_number();
 661           live_kill.set_bit(reg);
 662           if (block-&gt;loop_index() &gt;= 0) {
 663             local_interval_in_loop.set_bit(reg, block-&gt;loop_index());
 664           }
 665           local_has_fpu_registers = local_has_fpu_registers || opr-&gt;is_virtual_fpu();
 666         }
 667 
 668 #ifdef ASSERT
 669         // fixed intervals are never live at block boundaries, so
 670         // they need not be processed in live sets
 671         // process them only in debug mode so that this can be checked
 672         if (!opr-&gt;is_virtual_register()) {
 673           reg = reg_num(opr);
 674           if (is_processed_reg_num(reg)) {
 675             live_kill.set_bit(reg_num(opr));
 676           }
 677           reg = reg_numHi(opr);
 678           if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 679             live_kill.set_bit(reg);
 680           }
 681         }
 682 #endif
 683       }
 684 
 685       // iterate output operands of instruction
 686       n = visitor.opr_count(LIR_OpVisitState::outputMode);
 687       for (k = 0; k &lt; n; k++) {
 688         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::outputMode, k);
 689         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
 690 
 691         if (opr-&gt;is_virtual_register()) {
 692           assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 693           reg = opr-&gt;vreg_number();
 694           live_kill.set_bit(reg);
 695           if (block-&gt;loop_index() &gt;= 0) {
 696             local_interval_in_loop.set_bit(reg, block-&gt;loop_index());
 697           }
 698           local_has_fpu_registers = local_has_fpu_registers || opr-&gt;is_virtual_fpu();
 699         }
 700 
 701 #ifdef ASSERT
 702         // fixed intervals are never live at block boundaries, so
 703         // they need not be processed in live sets
 704         // process them only in debug mode so that this can be checked
 705         if (!opr-&gt;is_virtual_register()) {
 706           reg = reg_num(opr);
 707           if (is_processed_reg_num(reg)) {
 708             live_kill.set_bit(reg_num(opr));
 709           }
 710           reg = reg_numHi(opr);
 711           if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 712             live_kill.set_bit(reg);
 713           }
 714         }
 715 #endif
 716       }
 717     } // end of instruction iteration
 718 
 719     block-&gt;set_live_gen (live_gen);
 720     block-&gt;set_live_kill(live_kill);
 721     block-&gt;set_live_in  (ResourceBitMap(live_size));
 722     block-&gt;set_live_out (ResourceBitMap(live_size));
 723 
 724     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;live_gen  B%d &quot;, block-&gt;block_id()); print_bitmap(block-&gt;live_gen()));
 725     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;live_kill B%d &quot;, block-&gt;block_id()); print_bitmap(block-&gt;live_kill()));
 726   } // end of block iteration
 727 
 728   // propagate local calculated information into LinearScan object
 729   _has_fpu_registers = local_has_fpu_registers;
 730   compilation()-&gt;set_has_fpu_code(local_has_fpu_registers);
 731 
 732   _num_calls = local_num_calls;
 733   _interval_in_loop = local_interval_in_loop;
 734 }
 735 
 736 
 737 // ********** Phase 3: perform a backward dataflow analysis to compute global live sets
 738 // (sets live_in and live_out for each block)
 739 
 740 void LinearScan::compute_global_live_sets() {
 741   TIME_LINEAR_SCAN(timer_compute_global_live_sets);
 742 
 743   int  num_blocks = block_count();
 744   bool change_occurred;
 745   bool change_occurred_in_block;
 746   int  iteration_count = 0;
 747   ResourceBitMap live_out(live_set_size()); // scratch set for calculations
 748 
 749   // Perform a backward dataflow analysis to compute live_out and live_in for each block.
 750   // The loop is executed until a fixpoint is reached (no changes in an iteration)
 751   // Exception handlers must be processed because not all live values are
 752   // present in the state array, e.g. because of global value numbering
 753   do {
 754     change_occurred = false;
 755 
 756     // iterate all blocks in reverse order
 757     for (int i = num_blocks - 1; i &gt;= 0; i--) {
 758       BlockBegin* block = block_at(i);
 759 
 760       change_occurred_in_block = false;
 761 
 762       // live_out(block) is the union of live_in(sux), for successors sux of block
 763       int n = block-&gt;number_of_sux();
 764       int e = block-&gt;number_of_exception_handlers();
 765       if (n + e &gt; 0) {
 766         // block has successors
 767         if (n &gt; 0) {
 768           live_out.set_from(block-&gt;sux_at(0)-&gt;live_in());
 769           for (int j = 1; j &lt; n; j++) {
 770             live_out.set_union(block-&gt;sux_at(j)-&gt;live_in());
 771           }
 772         } else {
 773           live_out.clear();
 774         }
 775         for (int j = 0; j &lt; e; j++) {
 776           live_out.set_union(block-&gt;exception_handler_at(j)-&gt;live_in());
 777         }
 778 
 779         if (!block-&gt;live_out().is_same(live_out)) {
 780           // A change occurred.  Swap the old and new live out sets to avoid copying.
 781           ResourceBitMap temp = block-&gt;live_out();
 782           block-&gt;set_live_out(live_out);
 783           live_out = temp;
 784 
 785           change_occurred = true;
 786           change_occurred_in_block = true;
 787         }
 788       }
 789 
 790       if (iteration_count == 0 || change_occurred_in_block) {
 791         // live_in(block) is the union of live_gen(block) with (live_out(block) &amp; !live_kill(block))
 792         // note: live_in has to be computed only in first iteration or if live_out has changed!
 793         ResourceBitMap live_in = block-&gt;live_in();
 794         live_in.set_from(block-&gt;live_out());
 795         live_in.set_difference(block-&gt;live_kill());
 796         live_in.set_union(block-&gt;live_gen());
 797       }
 798 
 799 #ifndef PRODUCT
 800       if (TraceLinearScanLevel &gt;= 4) {
 801         char c = &#39; &#39;;
 802         if (iteration_count == 0 || change_occurred_in_block) {
 803           c = &#39;*&#39;;
 804         }
 805         tty-&gt;print(&quot;(%d) live_in%c  B%d &quot;, iteration_count, c, block-&gt;block_id()); print_bitmap(block-&gt;live_in());
 806         tty-&gt;print(&quot;(%d) live_out%c B%d &quot;, iteration_count, c, block-&gt;block_id()); print_bitmap(block-&gt;live_out());
 807       }
 808 #endif
 809     }
 810     iteration_count++;
 811 
 812     if (change_occurred &amp;&amp; iteration_count &gt; 50) {
 813       BAILOUT(&quot;too many iterations in compute_global_live_sets&quot;);
 814     }
 815   } while (change_occurred);
 816 
 817 
 818 #ifdef ASSERT
 819   // check that fixed intervals are not live at block boundaries
 820   // (live set must be empty at fixed intervals)
 821   for (int i = 0; i &lt; num_blocks; i++) {
 822     BlockBegin* block = block_at(i);
 823     for (int j = 0; j &lt; LIR_OprDesc::vreg_base; j++) {
 824       assert(block-&gt;live_in().at(j)  == false, &quot;live_in  set of fixed register must be empty&quot;);
 825       assert(block-&gt;live_out().at(j) == false, &quot;live_out set of fixed register must be empty&quot;);
 826       assert(block-&gt;live_gen().at(j) == false, &quot;live_gen set of fixed register must be empty&quot;);
 827     }
 828   }
 829 #endif
 830 
 831   // check that the live_in set of the first block is empty
 832   ResourceBitMap live_in_args(ir()-&gt;start()-&gt;live_in().size());
 833   if (!ir()-&gt;start()-&gt;live_in().is_same(live_in_args)) {
 834 #ifdef ASSERT
 835     tty-&gt;print_cr(&quot;Error: live_in set of first block must be empty (when this fails, virtual registers are used before they are defined)&quot;);
 836     tty-&gt;print_cr(&quot;affected registers:&quot;);
 837     print_bitmap(ir()-&gt;start()-&gt;live_in());
 838 
 839     // print some additional information to simplify debugging
 840     for (unsigned int i = 0; i &lt; ir()-&gt;start()-&gt;live_in().size(); i++) {
 841       if (ir()-&gt;start()-&gt;live_in().at(i)) {
 842         Instruction* instr = gen()-&gt;instruction_for_vreg(i);
 843         tty-&gt;print_cr(&quot;* vreg %d (HIR instruction %c%d)&quot;, i, instr == NULL ? &#39; &#39; : instr-&gt;type()-&gt;tchar(), instr == NULL ? 0 : instr-&gt;id());
 844 
 845         for (int j = 0; j &lt; num_blocks; j++) {
 846           BlockBegin* block = block_at(j);
 847           if (block-&gt;live_gen().at(i)) {
 848             tty-&gt;print_cr(&quot;  used in block B%d&quot;, block-&gt;block_id());
 849           }
 850           if (block-&gt;live_kill().at(i)) {
 851             tty-&gt;print_cr(&quot;  defined in block B%d&quot;, block-&gt;block_id());
 852           }
 853         }
 854       }
 855     }
 856 
 857 #endif
 858     // when this fails, virtual registers are used before they are defined.
 859     assert(false, &quot;live_in set of first block must be empty&quot;);
 860     // bailout of if this occurs in product mode.
 861     bailout(&quot;live_in set of first block not empty&quot;);
 862   }
 863 }
 864 
 865 
 866 // ********** Phase 4: build intervals
 867 // (fills the list _intervals)
 868 
 869 void LinearScan::add_use(Value value, int from, int to, IntervalUseKind use_kind) {
 870   assert(!value-&gt;type()-&gt;is_illegal(), &quot;if this value is used by the interpreter it shouldn&#39;t be of indeterminate type&quot;);
 871   LIR_Opr opr = value-&gt;operand();
 872   Constant* con = value-&gt;as_Constant();
 873 
 874   if ((con == NULL || con-&gt;is_pinned()) &amp;&amp; opr-&gt;is_register()) {
 875     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 876     add_use(opr, from, to, use_kind);
 877   }
 878 }
 879 
 880 
 881 void LinearScan::add_def(LIR_Opr opr, int def_pos, IntervalUseKind use_kind) {
 882   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot; def &quot;); opr-&gt;print(tty); tty-&gt;print_cr(&quot; def_pos %d (%d)&quot;, def_pos, use_kind));
 883   assert(opr-&gt;is_register(), &quot;should not be called otherwise&quot;);
 884 
 885   if (opr-&gt;is_virtual_register()) {
 886     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 887     add_def(opr-&gt;vreg_number(), def_pos, use_kind, opr-&gt;type_register());
 888 
 889   } else {
 890     int reg = reg_num(opr);
 891     if (is_processed_reg_num(reg)) {
 892       add_def(reg, def_pos, use_kind, opr-&gt;type_register());
 893     }
 894     reg = reg_numHi(opr);
 895     if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 896       add_def(reg, def_pos, use_kind, opr-&gt;type_register());
 897     }
 898   }
 899 }
 900 
 901 void LinearScan::add_use(LIR_Opr opr, int from, int to, IntervalUseKind use_kind) {
 902   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot; use &quot;); opr-&gt;print(tty); tty-&gt;print_cr(&quot; from %d to %d (%d)&quot;, from, to, use_kind));
 903   assert(opr-&gt;is_register(), &quot;should not be called otherwise&quot;);
 904 
 905   if (opr-&gt;is_virtual_register()) {
 906     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 907     add_use(opr-&gt;vreg_number(), from, to, use_kind, opr-&gt;type_register());
 908 
 909   } else {
 910     int reg = reg_num(opr);
 911     if (is_processed_reg_num(reg)) {
 912       add_use(reg, from, to, use_kind, opr-&gt;type_register());
 913     }
 914     reg = reg_numHi(opr);
 915     if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 916       add_use(reg, from, to, use_kind, opr-&gt;type_register());
 917     }
 918   }
 919 }
 920 
 921 void LinearScan::add_temp(LIR_Opr opr, int temp_pos, IntervalUseKind use_kind) {
 922   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot; temp &quot;); opr-&gt;print(tty); tty-&gt;print_cr(&quot; temp_pos %d (%d)&quot;, temp_pos, use_kind));
 923   assert(opr-&gt;is_register(), &quot;should not be called otherwise&quot;);
 924 
 925   if (opr-&gt;is_virtual_register()) {
 926     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 927     add_temp(opr-&gt;vreg_number(), temp_pos, use_kind, opr-&gt;type_register());
 928 
 929   } else {
 930     int reg = reg_num(opr);
 931     if (is_processed_reg_num(reg)) {
 932       add_temp(reg, temp_pos, use_kind, opr-&gt;type_register());
 933     }
 934     reg = reg_numHi(opr);
 935     if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 936       add_temp(reg, temp_pos, use_kind, opr-&gt;type_register());
 937     }
 938   }
 939 }
 940 
 941 
 942 void LinearScan::add_def(int reg_num, int def_pos, IntervalUseKind use_kind, BasicType type) {
 943   Interval* interval = interval_at(reg_num);
 944   if (interval != NULL) {
 945     assert(interval-&gt;reg_num() == reg_num, &quot;wrong interval&quot;);
 946 
 947     if (type != T_ILLEGAL) {
 948       interval-&gt;set_type(type);
 949     }
 950 
 951     Range* r = interval-&gt;first();
 952     if (r-&gt;from() &lt;= def_pos) {
 953       // Update the starting point (when a range is first created for a use, its
 954       // start is the beginning of the current block until a def is encountered.)
 955       r-&gt;set_from(def_pos);
 956       interval-&gt;add_use_pos(def_pos, use_kind);
 957 
 958     } else {
 959       // Dead value - make vacuous interval
 960       // also add use_kind for dead intervals
 961       interval-&gt;add_range(def_pos, def_pos + 1);
 962       interval-&gt;add_use_pos(def_pos, use_kind);
 963       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;Warning: def of reg %d at %d occurs without use&quot;, reg_num, def_pos));
 964     }
 965 
 966   } else {
 967     // Dead value - make vacuous interval
 968     // also add use_kind for dead intervals
 969     interval = create_interval(reg_num);
 970     if (type != T_ILLEGAL) {
 971       interval-&gt;set_type(type);
 972     }
 973 
 974     interval-&gt;add_range(def_pos, def_pos + 1);
 975     interval-&gt;add_use_pos(def_pos, use_kind);
 976     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;Warning: dead value %d at %d in live intervals&quot;, reg_num, def_pos));
 977   }
 978 
 979   change_spill_definition_pos(interval, def_pos);
 980   if (use_kind == noUse &amp;&amp; interval-&gt;spill_state() &lt;= startInMemory) {
 981         // detection of method-parameters and roundfp-results
 982         // TODO: move this directly to position where use-kind is computed
 983     interval-&gt;set_spill_state(startInMemory);
 984   }
 985 }
 986 
 987 void LinearScan::add_use(int reg_num, int from, int to, IntervalUseKind use_kind, BasicType type) {
 988   Interval* interval = interval_at(reg_num);
 989   if (interval == NULL) {
 990     interval = create_interval(reg_num);
 991   }
 992   assert(interval-&gt;reg_num() == reg_num, &quot;wrong interval&quot;);
 993 
 994   if (type != T_ILLEGAL) {
 995     interval-&gt;set_type(type);
 996   }
 997 
 998   interval-&gt;add_range(from, to);
 999   interval-&gt;add_use_pos(to, use_kind);
1000 }
1001 
1002 void LinearScan::add_temp(int reg_num, int temp_pos, IntervalUseKind use_kind, BasicType type) {
1003   Interval* interval = interval_at(reg_num);
1004   if (interval == NULL) {
1005     interval = create_interval(reg_num);
1006   }
1007   assert(interval-&gt;reg_num() == reg_num, &quot;wrong interval&quot;);
1008 
1009   if (type != T_ILLEGAL) {
1010     interval-&gt;set_type(type);
1011   }
1012 
1013   interval-&gt;add_range(temp_pos, temp_pos + 1);
1014   interval-&gt;add_use_pos(temp_pos, use_kind);
1015 }
1016 
1017 
1018 // the results of this functions are used for optimizing spilling and reloading
1019 // if the functions return shouldHaveRegister and the interval is spilled,
1020 // it is not reloaded to a register.
1021 IntervalUseKind LinearScan::use_kind_of_output_operand(LIR_Op* op, LIR_Opr opr) {
1022   if (op-&gt;code() == lir_move) {
1023     assert(op-&gt;as_Op1() != NULL, &quot;lir_move must be LIR_Op1&quot;);
1024     LIR_Op1* move = (LIR_Op1*)op;
1025     LIR_Opr res = move-&gt;result_opr();
1026     bool result_in_memory = res-&gt;is_virtual() &amp;&amp; gen()-&gt;is_vreg_flag_set(res-&gt;vreg_number(), LIRGenerator::must_start_in_memory);
1027 
1028     if (result_in_memory) {
1029       // Begin of an interval with must_start_in_memory set.
1030       // This interval will always get a stack slot first, so return noUse.
1031       return noUse;
1032 
1033     } else if (move-&gt;in_opr()-&gt;is_stack()) {
1034       // method argument (condition must be equal to handle_method_arguments)
1035       return noUse;
1036 
1037     } else if (move-&gt;in_opr()-&gt;is_register() &amp;&amp; move-&gt;result_opr()-&gt;is_register()) {
1038       // Move from register to register
1039       if (block_of_op_with_id(op-&gt;id())-&gt;is_set(BlockBegin::osr_entry_flag)) {
1040         // special handling of phi-function moves inside osr-entry blocks
1041         // input operand must have a register instead of output operand (leads to better register allocation)
1042         return shouldHaveRegister;
1043       }
1044     }
1045   }
1046 
1047   if (opr-&gt;is_virtual() &amp;&amp;
1048       gen()-&gt;is_vreg_flag_set(opr-&gt;vreg_number(), LIRGenerator::must_start_in_memory)) {
1049     // result is a stack-slot, so prevent immediate reloading
1050     return noUse;
1051   }
1052 
1053   // all other operands require a register
1054   return mustHaveRegister;
1055 }
1056 
1057 IntervalUseKind LinearScan::use_kind_of_input_operand(LIR_Op* op, LIR_Opr opr) {
1058   if (op-&gt;code() == lir_move) {
1059     assert(op-&gt;as_Op1() != NULL, &quot;lir_move must be LIR_Op1&quot;);
1060     LIR_Op1* move = (LIR_Op1*)op;
1061     LIR_Opr res = move-&gt;result_opr();
1062     bool result_in_memory = res-&gt;is_virtual() &amp;&amp; gen()-&gt;is_vreg_flag_set(res-&gt;vreg_number(), LIRGenerator::must_start_in_memory);
1063 
1064     if (result_in_memory) {
1065       // Move to an interval with must_start_in_memory set.
1066       // To avoid moves from stack to stack (not allowed) force the input operand to a register
1067       return mustHaveRegister;
1068 
1069     } else if (move-&gt;in_opr()-&gt;is_register() &amp;&amp; move-&gt;result_opr()-&gt;is_register()) {
1070       // Move from register to register
1071       if (block_of_op_with_id(op-&gt;id())-&gt;is_set(BlockBegin::osr_entry_flag)) {
1072         // special handling of phi-function moves inside osr-entry blocks
1073         // input operand must have a register instead of output operand (leads to better register allocation)
1074         return mustHaveRegister;
1075       }
1076 
1077       // The input operand is not forced to a register (moves from stack to register are allowed),
1078       // but it is faster if the input operand is in a register
1079       return shouldHaveRegister;
1080     }
1081   }
1082 
1083 
1084 #if defined(X86) || defined(S390)
1085   if (op-&gt;code() == lir_cmove) {
1086     // conditional moves can handle stack operands
1087     assert(op-&gt;result_opr()-&gt;is_register(), &quot;result must always be in a register&quot;);
1088     return shouldHaveRegister;
1089   }
1090 
1091   // optimizations for second input operand of arithmehtic operations on Intel
1092   // this operand is allowed to be on the stack in some cases
1093   BasicType opr_type = opr-&gt;type_register();
1094   if (opr_type == T_FLOAT || opr_type == T_DOUBLE) {
1095     if (IA32_ONLY( (UseSSE == 1 &amp;&amp; opr_type == T_FLOAT) || UseSSE &gt;= 2 ) NOT_IA32( true )) {
1096       // SSE float instruction (T_DOUBLE only supported with SSE2)
1097       switch (op-&gt;code()) {
1098         case lir_cmp:
1099         case lir_add:
1100         case lir_sub:
1101         case lir_mul:
1102         case lir_div:
1103         {
1104           assert(op-&gt;as_Op2() != NULL, &quot;must be LIR_Op2&quot;);
1105           LIR_Op2* op2 = (LIR_Op2*)op;
1106           if (op2-&gt;in_opr1() != op2-&gt;in_opr2() &amp;&amp; op2-&gt;in_opr2() == opr) {
1107             assert((op2-&gt;result_opr()-&gt;is_register() || op-&gt;code() == lir_cmp) &amp;&amp; op2-&gt;in_opr1()-&gt;is_register(), &quot;cannot mark second operand as stack if others are not in register&quot;);
1108             return shouldHaveRegister;
1109           }
1110         }
1111         default:
1112           break;
1113       }
1114     } else {
1115       // FPU stack float instruction
1116       switch (op-&gt;code()) {
1117         case lir_add:
1118         case lir_sub:
1119         case lir_mul:
1120         case lir_div:
1121         {
1122           assert(op-&gt;as_Op2() != NULL, &quot;must be LIR_Op2&quot;);
1123           LIR_Op2* op2 = (LIR_Op2*)op;
1124           if (op2-&gt;in_opr1() != op2-&gt;in_opr2() &amp;&amp; op2-&gt;in_opr2() == opr) {
1125             assert((op2-&gt;result_opr()-&gt;is_register() || op-&gt;code() == lir_cmp) &amp;&amp; op2-&gt;in_opr1()-&gt;is_register(), &quot;cannot mark second operand as stack if others are not in register&quot;);
1126             return shouldHaveRegister;
1127           }
1128         }
1129         default:
1130           break;
1131       }
1132     }
1133     // We want to sometimes use logical operations on pointers, in particular in GC barriers.
1134     // Since 64bit logical operations do not current support operands on stack, we have to make sure
1135     // T_OBJECT doesn&#39;t get spilled along with T_LONG.
1136   } else if (opr_type != T_LONG LP64_ONLY(&amp;&amp; opr_type != T_OBJECT)) {
1137     // integer instruction (note: long operands must always be in register)
1138     switch (op-&gt;code()) {
1139       case lir_cmp:
1140       case lir_add:
1141       case lir_sub:
1142       case lir_logic_and:
1143       case lir_logic_or:
1144       case lir_logic_xor:
1145       {
1146         assert(op-&gt;as_Op2() != NULL, &quot;must be LIR_Op2&quot;);
1147         LIR_Op2* op2 = (LIR_Op2*)op;
1148         if (op2-&gt;in_opr1() != op2-&gt;in_opr2() &amp;&amp; op2-&gt;in_opr2() == opr) {
1149           assert((op2-&gt;result_opr()-&gt;is_register() || op-&gt;code() == lir_cmp) &amp;&amp; op2-&gt;in_opr1()-&gt;is_register(), &quot;cannot mark second operand as stack if others are not in register&quot;);
1150           return shouldHaveRegister;
1151         }
1152       }
1153       default:
1154         break;
1155     }
1156   }
1157 #endif // X86 || S390
1158 
1159   // all other operands require a register
1160   return mustHaveRegister;
1161 }
1162 
1163 
1164 void LinearScan::handle_method_arguments(LIR_Op* op) {
1165   // special handling for method arguments (moves from stack to virtual register):
1166   // the interval gets no register assigned, but the stack slot.
1167   // it is split before the first use by the register allocator.
1168 
1169   if (op-&gt;code() == lir_move) {
1170     assert(op-&gt;as_Op1() != NULL, &quot;must be LIR_Op1&quot;);
1171     LIR_Op1* move = (LIR_Op1*)op;
1172 
1173     if (move-&gt;in_opr()-&gt;is_stack()) {
1174 #ifdef ASSERT
1175       int arg_size = compilation()-&gt;method()-&gt;arg_size();
1176       LIR_Opr o = move-&gt;in_opr();
1177       if (o-&gt;is_single_stack()) {
1178         assert(o-&gt;single_stack_ix() &gt;= 0 &amp;&amp; o-&gt;single_stack_ix() &lt; arg_size, &quot;out of range&quot;);
1179       } else if (o-&gt;is_double_stack()) {
1180         assert(o-&gt;double_stack_ix() &gt;= 0 &amp;&amp; o-&gt;double_stack_ix() &lt; arg_size, &quot;out of range&quot;);
1181       } else {
1182         ShouldNotReachHere();
1183       }
1184 
1185       assert(move-&gt;id() &gt; 0, &quot;invalid id&quot;);
1186       assert(block_of_op_with_id(move-&gt;id())-&gt;number_of_preds() == 0, &quot;move from stack must be in first block&quot;);
1187       assert(move-&gt;result_opr()-&gt;is_virtual(), &quot;result of move must be a virtual register&quot;);
1188 
1189       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;found move from stack slot %d to vreg %d&quot;, o-&gt;is_single_stack() ? o-&gt;single_stack_ix() : o-&gt;double_stack_ix(), reg_num(move-&gt;result_opr())));
1190 #endif
1191 
1192       Interval* interval = interval_at(reg_num(move-&gt;result_opr()));
1193 
1194       int stack_slot = LinearScan::nof_regs + (move-&gt;in_opr()-&gt;is_single_stack() ? move-&gt;in_opr()-&gt;single_stack_ix() : move-&gt;in_opr()-&gt;double_stack_ix());
1195       interval-&gt;set_canonical_spill_slot(stack_slot);
1196       interval-&gt;assign_reg(stack_slot);
1197     }
1198   }
1199 }
1200 
1201 void LinearScan::handle_doubleword_moves(LIR_Op* op) {
1202   // special handling for doubleword move from memory to register:
1203   // in this case the registers of the input address and the result
1204   // registers must not overlap -&gt; add a temp range for the input registers
1205   if (op-&gt;code() == lir_move) {
1206     assert(op-&gt;as_Op1() != NULL, &quot;must be LIR_Op1&quot;);
1207     LIR_Op1* move = (LIR_Op1*)op;
1208 
1209     if (move-&gt;result_opr()-&gt;is_double_cpu() &amp;&amp; move-&gt;in_opr()-&gt;is_pointer()) {
1210       LIR_Address* address = move-&gt;in_opr()-&gt;as_address_ptr();
1211       if (address != NULL) {
1212         if (address-&gt;base()-&gt;is_valid()) {
1213           add_temp(address-&gt;base(), op-&gt;id(), noUse);
1214         }
1215         if (address-&gt;index()-&gt;is_valid()) {
1216           add_temp(address-&gt;index(), op-&gt;id(), noUse);
1217         }
1218       }
1219     }
1220   }
1221 }
1222 
1223 void LinearScan::add_register_hints(LIR_Op* op) {
1224   switch (op-&gt;code()) {
1225     case lir_move:      // fall through
1226     case lir_convert: {
1227       assert(op-&gt;as_Op1() != NULL, &quot;lir_move, lir_convert must be LIR_Op1&quot;);
1228       LIR_Op1* move = (LIR_Op1*)op;
1229 
1230       LIR_Opr move_from = move-&gt;in_opr();
1231       LIR_Opr move_to = move-&gt;result_opr();
1232 
1233       if (move_to-&gt;is_register() &amp;&amp; move_from-&gt;is_register()) {
1234         Interval* from = interval_at(reg_num(move_from));
1235         Interval* to = interval_at(reg_num(move_to));
1236         if (from != NULL &amp;&amp; to != NULL) {
1237           to-&gt;set_register_hint(from);
1238           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;operation at op_id %d: added hint from interval %d to %d&quot;, move-&gt;id(), from-&gt;reg_num(), to-&gt;reg_num()));
1239         }
1240       }
1241       break;
1242     }
1243     case lir_cmove: {
1244       assert(op-&gt;as_Op2() != NULL, &quot;lir_cmove must be LIR_Op2&quot;);
1245       LIR_Op2* cmove = (LIR_Op2*)op;
1246 
1247       LIR_Opr move_from = cmove-&gt;in_opr1();
1248       LIR_Opr move_to = cmove-&gt;result_opr();
1249 
1250       if (move_to-&gt;is_register() &amp;&amp; move_from-&gt;is_register()) {
1251         Interval* from = interval_at(reg_num(move_from));
1252         Interval* to = interval_at(reg_num(move_to));
1253         if (from != NULL &amp;&amp; to != NULL) {
1254           to-&gt;set_register_hint(from);
1255           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;operation at op_id %d: added hint from interval %d to %d&quot;, cmove-&gt;id(), from-&gt;reg_num(), to-&gt;reg_num()));
1256         }
1257       }
1258       break;
1259     }
1260     default:
1261       break;
1262   }
1263 }
1264 
1265 
1266 void LinearScan::build_intervals() {
1267   TIME_LINEAR_SCAN(timer_build_intervals);
1268 
1269   // initialize interval list with expected number of intervals
1270   // (32 is added to have some space for split children without having to resize the list)
1271   _intervals = IntervalList(num_virtual_regs() + 32);
1272   // initialize all slots that are used by build_intervals
1273   _intervals.at_put_grow(num_virtual_regs() - 1, NULL, NULL);
1274 
1275   // create a list with all caller-save registers (cpu, fpu, xmm)
1276   // when an instruction is a call, a temp range is created for all these registers
1277   int num_caller_save_registers = 0;
1278   int caller_save_registers[LinearScan::nof_regs];
1279 
1280   int i;
1281   for (i = 0; i &lt; FrameMap::nof_caller_save_cpu_regs(); i++) {
1282     LIR_Opr opr = FrameMap::caller_save_cpu_reg_at(i);
1283     assert(opr-&gt;is_valid() &amp;&amp; opr-&gt;is_register(), &quot;FrameMap should not return invalid operands&quot;);
1284     assert(reg_numHi(opr) == -1, &quot;missing addition of range for hi-register&quot;);
1285     caller_save_registers[num_caller_save_registers++] = reg_num(opr);
1286   }
1287 
1288   // temp ranges for fpu registers are only created when the method has
1289   // virtual fpu operands. Otherwise no allocation for fpu registers is
1290   // performed and so the temp ranges would be useless
1291   if (has_fpu_registers()) {
1292 #ifdef X86
1293     if (UseSSE &lt; 2) {
1294 #endif // X86
1295       for (i = 0; i &lt; FrameMap::nof_caller_save_fpu_regs; i++) {
1296         LIR_Opr opr = FrameMap::caller_save_fpu_reg_at(i);
1297         assert(opr-&gt;is_valid() &amp;&amp; opr-&gt;is_register(), &quot;FrameMap should not return invalid operands&quot;);
1298         assert(reg_numHi(opr) == -1, &quot;missing addition of range for hi-register&quot;);
1299         caller_save_registers[num_caller_save_registers++] = reg_num(opr);
1300       }
1301 #ifdef X86
1302     }
1303 #endif // X86
1304 
1305 #ifdef X86
1306     if (UseSSE &gt; 0) {
1307       int num_caller_save_xmm_regs = FrameMap::get_num_caller_save_xmms();
1308       for (i = 0; i &lt; num_caller_save_xmm_regs; i ++) {
1309         LIR_Opr opr = FrameMap::caller_save_xmm_reg_at(i);
1310         assert(opr-&gt;is_valid() &amp;&amp; opr-&gt;is_register(), &quot;FrameMap should not return invalid operands&quot;);
1311         assert(reg_numHi(opr) == -1, &quot;missing addition of range for hi-register&quot;);
1312         caller_save_registers[num_caller_save_registers++] = reg_num(opr);
1313       }
1314     }
1315 #endif // X86
1316   }
1317   assert(num_caller_save_registers &lt;= LinearScan::nof_regs, &quot;out of bounds&quot;);
1318 
1319 
1320   LIR_OpVisitState visitor;
1321 
1322   // iterate all blocks in reverse order
1323   for (i = block_count() - 1; i &gt;= 0; i--) {
1324     BlockBegin* block = block_at(i);
1325     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
1326     int         block_from =   block-&gt;first_lir_instruction_id();
1327     int         block_to =     block-&gt;last_lir_instruction_id();
1328 
1329     assert(block_from == instructions-&gt;at(0)-&gt;id(), &quot;must be&quot;);
1330     assert(block_to   == instructions-&gt;at(instructions-&gt;length() - 1)-&gt;id(), &quot;must be&quot;);
1331 
1332     // Update intervals for registers live at the end of this block;
1333     ResourceBitMap live = block-&gt;live_out();
1334     int size = (int)live.size();
1335     for (int number = (int)live.get_next_one_offset(0, size); number &lt; size; number = (int)live.get_next_one_offset(number + 1, size)) {
1336       assert(live.at(number), &quot;should not stop here otherwise&quot;);
1337       assert(number &gt;= LIR_OprDesc::vreg_base, &quot;fixed intervals must not be live on block bounds&quot;);
1338       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;live in %d to %d&quot;, number, block_to + 2));
1339 
1340       add_use(number, block_from, block_to + 2, noUse, T_ILLEGAL);
1341 
1342       // add special use positions for loop-end blocks when the
1343       // interval is used anywhere inside this loop.  It&#39;s possible
1344       // that the block was part of a non-natural loop, so it might
1345       // have an invalid loop index.
1346       if (block-&gt;is_set(BlockBegin::linear_scan_loop_end_flag) &amp;&amp;
1347           block-&gt;loop_index() != -1 &amp;&amp;
1348           is_interval_in_loop(number, block-&gt;loop_index())) {
1349         interval_at(number)-&gt;add_use_pos(block_to + 1, loopEndMarker);
1350       }
1351     }
1352 
1353     // iterate all instructions of the block in reverse order.
1354     // skip the first instruction because it is always a label
1355     // definitions of intervals are processed before uses
1356     assert(visitor.no_operands(instructions-&gt;at(0)), &quot;first operation must always be a label&quot;);
1357     for (int j = instructions-&gt;length() - 1; j &gt;= 1; j--) {
1358       LIR_Op* op = instructions-&gt;at(j);
1359       int op_id = op-&gt;id();
1360 
1361       // visit operation to collect all operands
1362       visitor.visit(op);
1363 
1364       // add a temp range for each register if operation destroys caller-save registers
1365       if (visitor.has_call()) {
1366         for (int k = 0; k &lt; num_caller_save_registers; k++) {
1367           add_temp(caller_save_registers[k], op_id, noUse, T_ILLEGAL);
1368         }
1369         TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;operation destroys all caller-save registers&quot;));
1370       }
1371 
1372       // Add any platform dependent temps
1373       pd_add_temps(op);
1374 
1375       // visit definitions (output and temp operands)
1376       int k, n;
1377       n = visitor.opr_count(LIR_OpVisitState::outputMode);
1378       for (k = 0; k &lt; n; k++) {
1379         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::outputMode, k);
1380         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
1381         add_def(opr, op_id, use_kind_of_output_operand(op, opr));
1382       }
1383 
1384       n = visitor.opr_count(LIR_OpVisitState::tempMode);
1385       for (k = 0; k &lt; n; k++) {
1386         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::tempMode, k);
1387         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
1388         add_temp(opr, op_id, mustHaveRegister);
1389       }
1390 
1391       // visit uses (input operands)
1392       n = visitor.opr_count(LIR_OpVisitState::inputMode);
1393       for (k = 0; k &lt; n; k++) {
1394         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::inputMode, k);
1395         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
1396         add_use(opr, block_from, op_id, use_kind_of_input_operand(op, opr));
1397       }
1398 
1399       // Add uses of live locals from interpreter&#39;s point of view for proper
1400       // debug information generation
1401       // Treat these operands as temp values (if the life range is extended
1402       // to a call site, the value would be in a register at the call otherwise)
1403       n = visitor.info_count();
1404       for (k = 0; k &lt; n; k++) {
1405         CodeEmitInfo* info = visitor.info_at(k);
1406         ValueStack* stack = info-&gt;stack();
1407         for_each_state_value(stack, value,
1408           add_use(value, block_from, op_id + 1, noUse);
1409         );
1410       }
1411 
1412       // special steps for some instructions (especially moves)
1413       handle_method_arguments(op);
1414       handle_doubleword_moves(op);
1415       add_register_hints(op);
1416 
1417     } // end of instruction iteration
1418   } // end of block iteration
1419 
1420 
1421   // add the range [0, 1[ to all fixed intervals
1422   // -&gt; the register allocator need not handle unhandled fixed intervals
1423   for (int n = 0; n &lt; LinearScan::nof_regs; n++) {
1424     Interval* interval = interval_at(n);
1425     if (interval != NULL) {
1426       interval-&gt;add_range(0, 1);
1427     }
1428   }
1429 }
1430 
1431 
1432 // ********** Phase 5: actual register allocation
1433 
1434 int LinearScan::interval_cmp(Interval** a, Interval** b) {
1435   if (*a != NULL) {
1436     if (*b != NULL) {
1437       return (*a)-&gt;from() - (*b)-&gt;from();
1438     } else {
1439       return -1;
1440     }
1441   } else {
1442     if (*b != NULL) {
1443       return 1;
1444     } else {
1445       return 0;
1446     }
1447   }
1448 }
1449 
1450 #ifndef PRODUCT
1451 int interval_cmp(Interval* const&amp; l, Interval* const&amp; r) {
1452   return l-&gt;from() - r-&gt;from();
1453 }
1454 
1455 bool find_interval(Interval* interval, IntervalArray* intervals) {
1456   bool found;
1457   int idx = intervals-&gt;find_sorted&lt;Interval*, interval_cmp&gt;(interval, found);
1458 
1459   if (!found) {
1460     return false;
1461   }
1462 
1463   int from = interval-&gt;from();
1464 
1465   // The index we&#39;ve found using binary search is pointing to an interval
1466   // that is defined in the same place as the interval we were looking for.
1467   // So now we have to look around that index and find exact interval.
1468   for (int i = idx; i &gt;= 0; i--) {
1469     if (intervals-&gt;at(i) == interval) {
1470       return true;
1471     }
1472     if (intervals-&gt;at(i)-&gt;from() != from) {
1473       break;
1474     }
1475   }
1476 
1477   for (int i = idx + 1; i &lt; intervals-&gt;length(); i++) {
1478     if (intervals-&gt;at(i) == interval) {
1479       return true;
1480     }
1481     if (intervals-&gt;at(i)-&gt;from() != from) {
1482       break;
1483     }
1484   }
1485 
1486   return false;
1487 }
1488 
1489 bool LinearScan::is_sorted(IntervalArray* intervals) {
1490   int from = -1;
1491   int null_count = 0;
1492 
1493   for (int i = 0; i &lt; intervals-&gt;length(); i++) {
1494     Interval* it = intervals-&gt;at(i);
1495     if (it != NULL) {
1496       assert(from &lt;= it-&gt;from(), &quot;Intervals are unordered&quot;);
1497       from = it-&gt;from();
1498     } else {
1499       null_count++;
1500     }
1501   }
1502 
1503   assert(null_count == 0, &quot;Sorted intervals should not contain nulls&quot;);
1504 
1505   null_count = 0;
1506 
1507   for (int i = 0; i &lt; interval_count(); i++) {
1508     Interval* interval = interval_at(i);
1509     if (interval != NULL) {
1510       assert(find_interval(interval, intervals), &quot;Lists do not contain same intervals&quot;);
1511     } else {
1512       null_count++;
1513     }
1514   }
1515 
1516   assert(interval_count() - null_count == intervals-&gt;length(),
1517       &quot;Sorted list should contain the same amount of non-NULL intervals as unsorted list&quot;);
1518 
1519   return true;
1520 }
1521 #endif
1522 
1523 void LinearScan::add_to_list(Interval** first, Interval** prev, Interval* interval) {
1524   if (*prev != NULL) {
1525     (*prev)-&gt;set_next(interval);
1526   } else {
1527     *first = interval;
1528   }
1529   *prev = interval;
1530 }
1531 
1532 void LinearScan::create_unhandled_lists(Interval** list1, Interval** list2, bool (is_list1)(const Interval* i), bool (is_list2)(const Interval* i)) {
1533   assert(is_sorted(_sorted_intervals), &quot;interval list is not sorted&quot;);
1534 
1535   *list1 = *list2 = Interval::end();
1536 
1537   Interval* list1_prev = NULL;
1538   Interval* list2_prev = NULL;
1539   Interval* v;
1540 
1541   const int n = _sorted_intervals-&gt;length();
1542   for (int i = 0; i &lt; n; i++) {
1543     v = _sorted_intervals-&gt;at(i);
1544     if (v == NULL) continue;
1545 
1546     if (is_list1(v)) {
1547       add_to_list(list1, &amp;list1_prev, v);
1548     } else if (is_list2 == NULL || is_list2(v)) {
1549       add_to_list(list2, &amp;list2_prev, v);
1550     }
1551   }
1552 
1553   if (list1_prev != NULL) list1_prev-&gt;set_next(Interval::end());
1554   if (list2_prev != NULL) list2_prev-&gt;set_next(Interval::end());
1555 
1556   assert(list1_prev == NULL || list1_prev-&gt;next() == Interval::end(), &quot;linear list ends not with sentinel&quot;);
1557   assert(list2_prev == NULL || list2_prev-&gt;next() == Interval::end(), &quot;linear list ends not with sentinel&quot;);
1558 }
1559 
1560 
1561 void LinearScan::sort_intervals_before_allocation() {
1562   TIME_LINEAR_SCAN(timer_sort_intervals_before);
1563 
1564   if (_needs_full_resort) {
1565     // There is no known reason why this should occur but just in case...
1566     assert(false, &quot;should never occur&quot;);
1567     // Re-sort existing interval list because an Interval::from() has changed
1568     _sorted_intervals-&gt;sort(interval_cmp);
1569     _needs_full_resort = false;
1570   }
1571 
1572   IntervalList* unsorted_list = &amp;_intervals;
1573   int unsorted_len = unsorted_list-&gt;length();
1574   int sorted_len = 0;
1575   int unsorted_idx;
1576   int sorted_idx = 0;
1577   int sorted_from_max = -1;
1578 
1579   // calc number of items for sorted list (sorted list must not contain NULL values)
1580   for (unsorted_idx = 0; unsorted_idx &lt; unsorted_len; unsorted_idx++) {
1581     if (unsorted_list-&gt;at(unsorted_idx) != NULL) {
1582       sorted_len++;
1583     }
1584   }
1585   IntervalArray* sorted_list = new IntervalArray(sorted_len, sorted_len, NULL);
1586 
1587   // special sorting algorithm: the original interval-list is almost sorted,
1588   // only some intervals are swapped. So this is much faster than a complete QuickSort
1589   for (unsorted_idx = 0; unsorted_idx &lt; unsorted_len; unsorted_idx++) {
1590     Interval* cur_interval = unsorted_list-&gt;at(unsorted_idx);
1591 
1592     if (cur_interval != NULL) {
1593       int cur_from = cur_interval-&gt;from();
1594 
1595       if (sorted_from_max &lt;= cur_from) {
1596         sorted_list-&gt;at_put(sorted_idx++, cur_interval);
1597         sorted_from_max = cur_interval-&gt;from();
1598       } else {
1599         // the asumption that the intervals are already sorted failed,
1600         // so this interval must be sorted in manually
1601         int j;
1602         for (j = sorted_idx - 1; j &gt;= 0 &amp;&amp; cur_from &lt; sorted_list-&gt;at(j)-&gt;from(); j--) {
1603           sorted_list-&gt;at_put(j + 1, sorted_list-&gt;at(j));
1604         }
1605         sorted_list-&gt;at_put(j + 1, cur_interval);
1606         sorted_idx++;
1607       }
1608     }
1609   }
1610   _sorted_intervals = sorted_list;
1611   assert(is_sorted(_sorted_intervals), &quot;intervals unsorted&quot;);
1612 }
1613 
1614 void LinearScan::sort_intervals_after_allocation() {
1615   TIME_LINEAR_SCAN(timer_sort_intervals_after);
1616 
1617   if (_needs_full_resort) {
1618     // Re-sort existing interval list because an Interval::from() has changed
1619     _sorted_intervals-&gt;sort(interval_cmp);
1620     _needs_full_resort = false;
1621   }
1622 
1623   IntervalArray* old_list = _sorted_intervals;
1624   IntervalList* new_list = _new_intervals_from_allocation;
1625   int old_len = old_list-&gt;length();
1626   int new_len = new_list == NULL ? 0 : new_list-&gt;length();
1627 
1628   if (new_len == 0) {
1629     // no intervals have been added during allocation, so sorted list is already up to date
1630     assert(is_sorted(_sorted_intervals), &quot;intervals unsorted&quot;);
1631     return;
1632   }
1633 
1634   // conventional sort-algorithm for new intervals
1635   new_list-&gt;sort(interval_cmp);
1636 
1637   // merge old and new list (both already sorted) into one combined list
1638   int combined_list_len = old_len + new_len;
1639   IntervalArray* combined_list = new IntervalArray(combined_list_len, combined_list_len, NULL);
1640   int old_idx = 0;
1641   int new_idx = 0;
1642 
1643   while (old_idx + new_idx &lt; old_len + new_len) {
1644     if (new_idx &gt;= new_len || (old_idx &lt; old_len &amp;&amp; old_list-&gt;at(old_idx)-&gt;from() &lt;= new_list-&gt;at(new_idx)-&gt;from())) {
1645       combined_list-&gt;at_put(old_idx + new_idx, old_list-&gt;at(old_idx));
1646       old_idx++;
1647     } else {
1648       combined_list-&gt;at_put(old_idx + new_idx, new_list-&gt;at(new_idx));
1649       new_idx++;
1650     }
1651   }
1652 
1653   _sorted_intervals = combined_list;
1654   assert(is_sorted(_sorted_intervals), &quot;intervals unsorted&quot;);
1655 }
1656 
1657 
1658 void LinearScan::allocate_registers() {
1659   TIME_LINEAR_SCAN(timer_allocate_registers);
1660 
1661   Interval* precolored_cpu_intervals, *not_precolored_cpu_intervals;
1662   Interval* precolored_fpu_intervals, *not_precolored_fpu_intervals;
1663 
1664   // allocate cpu registers
1665   create_unhandled_lists(&amp;precolored_cpu_intervals, &amp;not_precolored_cpu_intervals,
1666                          is_precolored_cpu_interval, is_virtual_cpu_interval);
1667 
1668   // allocate fpu registers
1669   create_unhandled_lists(&amp;precolored_fpu_intervals, &amp;not_precolored_fpu_intervals,
1670                          is_precolored_fpu_interval, is_virtual_fpu_interval);
1671 
1672   // the fpu interval allocation cannot be moved down below with the fpu section as
1673   // the cpu_lsw.walk() changes interval positions.
1674 
1675   LinearScanWalker cpu_lsw(this, precolored_cpu_intervals, not_precolored_cpu_intervals);
1676   cpu_lsw.walk();
1677   cpu_lsw.finish_allocation();
1678 
1679   if (has_fpu_registers()) {
1680     LinearScanWalker fpu_lsw(this, precolored_fpu_intervals, not_precolored_fpu_intervals);
1681     fpu_lsw.walk();
1682     fpu_lsw.finish_allocation();
1683   }
1684 }
1685 
1686 
1687 // ********** Phase 6: resolve data flow
1688 // (insert moves at edges between blocks if intervals have been split)
1689 
1690 // wrapper for Interval::split_child_at_op_id that performs a bailout in product mode
1691 // instead of returning NULL
1692 Interval* LinearScan::split_child_at_op_id(Interval* interval, int op_id, LIR_OpVisitState::OprMode mode) {
1693   Interval* result = interval-&gt;split_child_at_op_id(op_id, mode);
1694   if (result != NULL) {
1695     return result;
1696   }
1697 
1698   assert(false, &quot;must find an interval, but do a clean bailout in product mode&quot;);
1699   result = new Interval(LIR_OprDesc::vreg_base);
1700   result-&gt;assign_reg(0);
1701   result-&gt;set_type(T_INT);
1702   BAILOUT_(&quot;LinearScan: interval is NULL&quot;, result);
1703 }
1704 
1705 
1706 Interval* LinearScan::interval_at_block_begin(BlockBegin* block, int reg_num) {
1707   assert(LinearScan::nof_regs &lt;= reg_num &amp;&amp; reg_num &lt; num_virtual_regs(), &quot;register number out of bounds&quot;);
1708   assert(interval_at(reg_num) != NULL, &quot;no interval found&quot;);
1709 
1710   return split_child_at_op_id(interval_at(reg_num), block-&gt;first_lir_instruction_id(), LIR_OpVisitState::outputMode);
1711 }
1712 
1713 Interval* LinearScan::interval_at_block_end(BlockBegin* block, int reg_num) {
1714   assert(LinearScan::nof_regs &lt;= reg_num &amp;&amp; reg_num &lt; num_virtual_regs(), &quot;register number out of bounds&quot;);
1715   assert(interval_at(reg_num) != NULL, &quot;no interval found&quot;);
1716 
1717   return split_child_at_op_id(interval_at(reg_num), block-&gt;last_lir_instruction_id() + 1, LIR_OpVisitState::outputMode);
1718 }
1719 
1720 Interval* LinearScan::interval_at_op_id(int reg_num, int op_id) {
1721   assert(LinearScan::nof_regs &lt;= reg_num &amp;&amp; reg_num &lt; num_virtual_regs(), &quot;register number out of bounds&quot;);
1722   assert(interval_at(reg_num) != NULL, &quot;no interval found&quot;);
1723 
1724   return split_child_at_op_id(interval_at(reg_num), op_id, LIR_OpVisitState::inputMode);
1725 }
1726 
1727 
1728 void LinearScan::resolve_collect_mappings(BlockBegin* from_block, BlockBegin* to_block, MoveResolver &amp;move_resolver) {
1729   DEBUG_ONLY(move_resolver.check_empty());
1730 
1731   const int size = live_set_size();
1732   const ResourceBitMap live_at_edge = to_block-&gt;live_in();
1733 
1734   // visit all registers where the live_at_edge bit is set
1735   for (int r = (int)live_at_edge.get_next_one_offset(0, size); r &lt; size; r = (int)live_at_edge.get_next_one_offset(r + 1, size)) {
1736     assert(r &lt; num_virtual_regs(), &quot;live information set for not exisiting interval&quot;);
1737     assert(from_block-&gt;live_out().at(r) &amp;&amp; to_block-&gt;live_in().at(r), &quot;interval not live at this edge&quot;);
1738 
1739     Interval* from_interval = interval_at_block_end(from_block, r);
1740     Interval* to_interval = interval_at_block_begin(to_block, r);
1741 
1742     if (from_interval != to_interval &amp;&amp; (from_interval-&gt;assigned_reg() != to_interval-&gt;assigned_reg() || from_interval-&gt;assigned_regHi() != to_interval-&gt;assigned_regHi())) {
1743       // need to insert move instruction
1744       move_resolver.add_mapping(from_interval, to_interval);
1745     }
1746   }
1747 }
1748 
1749 
1750 void LinearScan::resolve_find_insert_pos(BlockBegin* from_block, BlockBegin* to_block, MoveResolver &amp;move_resolver) {
1751   if (from_block-&gt;number_of_sux() &lt;= 1) {
1752     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;inserting moves at end of from_block B%d&quot;, from_block-&gt;block_id()));
1753 
1754     LIR_OpList* instructions = from_block-&gt;lir()-&gt;instructions_list();
1755     LIR_OpBranch* branch = instructions-&gt;last()-&gt;as_OpBranch();
1756     if (branch != NULL) {
1757       // insert moves before branch
1758       assert(branch-&gt;cond() == lir_cond_always, &quot;block does not end with an unconditional jump&quot;);
1759       move_resolver.set_insert_position(from_block-&gt;lir(), instructions-&gt;length() - 2);
1760     } else {
1761       move_resolver.set_insert_position(from_block-&gt;lir(), instructions-&gt;length() - 1);
1762     }
1763 
1764   } else {
1765     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;inserting moves at beginning of to_block B%d&quot;, to_block-&gt;block_id()));
1766 #ifdef ASSERT
1767     assert(from_block-&gt;lir()-&gt;instructions_list()-&gt;at(0)-&gt;as_OpLabel() != NULL, &quot;block does not start with a label&quot;);
1768 
1769     // because the number of predecessor edges matches the number of
1770     // successor edges, blocks which are reached by switch statements
1771     // may have be more than one predecessor but it will be guaranteed
1772     // that all predecessors will be the same.
1773     for (int i = 0; i &lt; to_block-&gt;number_of_preds(); i++) {
1774       assert(from_block == to_block-&gt;pred_at(i), &quot;all critical edges must be broken&quot;);
1775     }
1776 #endif
1777 
1778     move_resolver.set_insert_position(to_block-&gt;lir(), 0);
1779   }
1780 }
1781 
1782 
1783 // insert necessary moves (spilling or reloading) at edges between blocks if interval has been split
1784 void LinearScan::resolve_data_flow() {
1785   TIME_LINEAR_SCAN(timer_resolve_data_flow);
1786 
1787   int num_blocks = block_count();
1788   MoveResolver move_resolver(this);
1789   ResourceBitMap block_completed(num_blocks);
1790   ResourceBitMap already_resolved(num_blocks);
1791 
1792   int i;
1793   for (i = 0; i &lt; num_blocks; i++) {
1794     BlockBegin* block = block_at(i);
1795 
1796     // check if block has only one predecessor and only one successor
1797     if (block-&gt;number_of_preds() == 1 &amp;&amp; block-&gt;number_of_sux() == 1 &amp;&amp; block-&gt;number_of_exception_handlers() == 0) {
1798       LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
1799       assert(instructions-&gt;at(0)-&gt;code() == lir_label, &quot;block must start with label&quot;);
1800       assert(instructions-&gt;last()-&gt;code() == lir_branch, &quot;block with successors must end with branch&quot;);
1801       assert(instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;block with successor must end with unconditional branch&quot;);
1802 
1803       // check if block is empty (only label and branch)
1804       if (instructions-&gt;length() == 2) {
1805         BlockBegin* pred = block-&gt;pred_at(0);
1806         BlockBegin* sux = block-&gt;sux_at(0);
1807 
1808         // prevent optimization of two consecutive blocks
1809         if (!block_completed.at(pred-&gt;linear_scan_number()) &amp;&amp; !block_completed.at(sux-&gt;linear_scan_number())) {
1810           TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;**** optimizing empty block B%d (pred: B%d, sux: B%d)&quot;, block-&gt;block_id(), pred-&gt;block_id(), sux-&gt;block_id()));
1811           block_completed.set_bit(block-&gt;linear_scan_number());
1812 
1813           // directly resolve between pred and sux (without looking at the empty block between)
1814           resolve_collect_mappings(pred, sux, move_resolver);
1815           if (move_resolver.has_mappings()) {
1816             move_resolver.set_insert_position(block-&gt;lir(), 0);
1817             move_resolver.resolve_and_append_moves();
1818           }
1819         }
1820       }
1821     }
1822   }
1823 
1824 
1825   for (i = 0; i &lt; num_blocks; i++) {
1826     if (!block_completed.at(i)) {
1827       BlockBegin* from_block = block_at(i);
1828       already_resolved.set_from(block_completed);
1829 
1830       int num_sux = from_block-&gt;number_of_sux();
1831       for (int s = 0; s &lt; num_sux; s++) {
1832         BlockBegin* to_block = from_block-&gt;sux_at(s);
1833 
1834         // check for duplicate edges between the same blocks (can happen with switch blocks)
1835         if (!already_resolved.at(to_block-&gt;linear_scan_number())) {
1836           TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;**** processing edge between B%d and B%d&quot;, from_block-&gt;block_id(), to_block-&gt;block_id()));
1837           already_resolved.set_bit(to_block-&gt;linear_scan_number());
1838 
1839           // collect all intervals that have been split between from_block and to_block
1840           resolve_collect_mappings(from_block, to_block, move_resolver);
1841           if (move_resolver.has_mappings()) {
1842             resolve_find_insert_pos(from_block, to_block, move_resolver);
1843             move_resolver.resolve_and_append_moves();
1844           }
1845         }
1846       }
1847     }
1848   }
1849 }
1850 
1851 
1852 void LinearScan::resolve_exception_entry(BlockBegin* block, int reg_num, MoveResolver &amp;move_resolver) {
1853   if (interval_at(reg_num) == NULL) {
1854     // if a phi function is never used, no interval is created -&gt; ignore this
1855     return;
1856   }
1857 
1858   Interval* interval = interval_at_block_begin(block, reg_num);
1859   int reg = interval-&gt;assigned_reg();
1860   int regHi = interval-&gt;assigned_regHi();
1861 
1862   if ((reg &lt; nof_regs &amp;&amp; interval-&gt;always_in_memory()) ||
1863       (use_fpu_stack_allocation() &amp;&amp; reg &gt;= pd_first_fpu_reg &amp;&amp; reg &lt;= pd_last_fpu_reg)) {
1864     // the interval is split to get a short range that is located on the stack
1865     // in the following two cases:
1866     // * the interval started in memory (e.g. method parameter), but is currently in a register
1867     //   this is an optimization for exception handling that reduces the number of moves that
1868     //   are necessary for resolving the states when an exception uses this exception handler
1869     // * the interval would be on the fpu stack at the begin of the exception handler
1870     //   this is not allowed because of the complicated fpu stack handling on Intel
1871 
1872     // range that will be spilled to memory
1873     int from_op_id = block-&gt;first_lir_instruction_id();
1874     int to_op_id = from_op_id + 1;  // short live range of length 1
1875     assert(interval-&gt;from() &lt;= from_op_id &amp;&amp; interval-&gt;to() &gt;= to_op_id,
1876            &quot;no split allowed between exception entry and first instruction&quot;);
1877 
1878     if (interval-&gt;from() != from_op_id) {
1879       // the part before from_op_id is unchanged
1880       interval = interval-&gt;split(from_op_id);
1881       interval-&gt;assign_reg(reg, regHi);
1882       append_interval(interval);
1883     } else {
1884       _needs_full_resort = true;
1885     }
1886     assert(interval-&gt;from() == from_op_id, &quot;must be true now&quot;);
1887 
1888     Interval* spilled_part = interval;
1889     if (interval-&gt;to() != to_op_id) {
1890       // the part after to_op_id is unchanged
1891       spilled_part = interval-&gt;split_from_start(to_op_id);
1892       append_interval(spilled_part);
1893       move_resolver.add_mapping(spilled_part, interval);
1894     }
1895     assign_spill_slot(spilled_part);
1896 
1897     assert(spilled_part-&gt;from() == from_op_id &amp;&amp; spilled_part-&gt;to() == to_op_id, &quot;just checking&quot;);
1898   }
1899 }
1900 
1901 void LinearScan::resolve_exception_entry(BlockBegin* block, MoveResolver &amp;move_resolver) {
1902   assert(block-&gt;is_set(BlockBegin::exception_entry_flag), &quot;should not call otherwise&quot;);
1903   DEBUG_ONLY(move_resolver.check_empty());
1904 
1905   // visit all registers where the live_in bit is set
1906   int size = live_set_size();
1907   for (int r = (int)block-&gt;live_in().get_next_one_offset(0, size); r &lt; size; r = (int)block-&gt;live_in().get_next_one_offset(r + 1, size)) {
1908     resolve_exception_entry(block, r, move_resolver);
1909   }
1910 
1911   // the live_in bits are not set for phi functions of the xhandler entry, so iterate them separately
1912   for_each_phi_fun(block, phi,
1913     if (!phi-&gt;is_illegal()) { resolve_exception_entry(block, phi-&gt;operand()-&gt;vreg_number(), move_resolver); }
1914   );
1915 
1916   if (move_resolver.has_mappings()) {
1917     // insert moves after first instruction
1918     move_resolver.set_insert_position(block-&gt;lir(), 0);
1919     move_resolver.resolve_and_append_moves();
1920   }
1921 }
1922 
1923 
1924 void LinearScan::resolve_exception_edge(XHandler* handler, int throwing_op_id, int reg_num, Phi* phi, MoveResolver &amp;move_resolver) {
1925   if (interval_at(reg_num) == NULL) {
1926     // if a phi function is never used, no interval is created -&gt; ignore this
1927     return;
1928   }
1929 
1930   // the computation of to_interval is equal to resolve_collect_mappings,
1931   // but from_interval is more complicated because of phi functions
1932   BlockBegin* to_block = handler-&gt;entry_block();
1933   Interval* to_interval = interval_at_block_begin(to_block, reg_num);
1934 
1935   if (phi != NULL) {
1936     // phi function of the exception entry block
1937     // no moves are created for this phi function in the LIR_Generator, so the
1938     // interval at the throwing instruction must be searched using the operands
1939     // of the phi function
1940     Value from_value = phi-&gt;operand_at(handler-&gt;phi_operand());
1941 
1942     // with phi functions it can happen that the same from_value is used in
1943     // multiple mappings, so notify move-resolver that this is allowed
1944     move_resolver.set_multiple_reads_allowed();
1945 
1946     Constant* con = from_value-&gt;as_Constant();
1947     if (con != NULL &amp;&amp; !con-&gt;is_pinned()) {
1948       // unpinned constants may have no register, so add mapping from constant to interval
1949       move_resolver.add_mapping(LIR_OprFact::value_type(con-&gt;type()), to_interval);
1950     } else {
1951       // search split child at the throwing op_id
1952       Interval* from_interval = interval_at_op_id(from_value-&gt;operand()-&gt;vreg_number(), throwing_op_id);
1953       move_resolver.add_mapping(from_interval, to_interval);
1954     }
1955 
1956   } else {
1957     // no phi function, so use reg_num also for from_interval
1958     // search split child at the throwing op_id
1959     Interval* from_interval = interval_at_op_id(reg_num, throwing_op_id);
1960     if (from_interval != to_interval) {
1961       // optimization to reduce number of moves: when to_interval is on stack and
1962       // the stack slot is known to be always correct, then no move is necessary
1963       if (!from_interval-&gt;always_in_memory() || from_interval-&gt;canonical_spill_slot() != to_interval-&gt;assigned_reg()) {
1964         move_resolver.add_mapping(from_interval, to_interval);
1965       }
1966     }
1967   }
1968 }
1969 
1970 void LinearScan::resolve_exception_edge(XHandler* handler, int throwing_op_id, MoveResolver &amp;move_resolver) {
1971   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;resolving exception handler B%d: throwing_op_id=%d&quot;, handler-&gt;entry_block()-&gt;block_id(), throwing_op_id));
1972 
1973   DEBUG_ONLY(move_resolver.check_empty());
1974   assert(handler-&gt;lir_op_id() == -1, &quot;already processed this xhandler&quot;);
1975   DEBUG_ONLY(handler-&gt;set_lir_op_id(throwing_op_id));
1976   assert(handler-&gt;entry_code() == NULL, &quot;code already present&quot;);
1977 
1978   // visit all registers where the live_in bit is set
1979   BlockBegin* block = handler-&gt;entry_block();
1980   int size = live_set_size();
1981   for (int r = (int)block-&gt;live_in().get_next_one_offset(0, size); r &lt; size; r = (int)block-&gt;live_in().get_next_one_offset(r + 1, size)) {
1982     resolve_exception_edge(handler, throwing_op_id, r, NULL, move_resolver);
1983   }
1984 
1985   // the live_in bits are not set for phi functions of the xhandler entry, so iterate them separately
1986   for_each_phi_fun(block, phi,
1987     if (!phi-&gt;is_illegal()) { resolve_exception_edge(handler, throwing_op_id, phi-&gt;operand()-&gt;vreg_number(), phi, move_resolver); }
1988   );
1989 
1990   if (move_resolver.has_mappings()) {
1991     LIR_List* entry_code = new LIR_List(compilation());
1992     move_resolver.set_insert_position(entry_code, 0);
1993     move_resolver.resolve_and_append_moves();
1994 
1995     entry_code-&gt;jump(handler-&gt;entry_block());
1996     handler-&gt;set_entry_code(entry_code);
1997   }
1998 }
1999 
2000 
2001 void LinearScan::resolve_exception_handlers() {
2002   MoveResolver move_resolver(this);
2003   LIR_OpVisitState visitor;
2004   int num_blocks = block_count();
2005 
2006   int i;
2007   for (i = 0; i &lt; num_blocks; i++) {
2008     BlockBegin* block = block_at(i);
2009     if (block-&gt;is_set(BlockBegin::exception_entry_flag)) {
2010       resolve_exception_entry(block, move_resolver);
2011     }
2012   }
2013 
2014   for (i = 0; i &lt; num_blocks; i++) {
2015     BlockBegin* block = block_at(i);
2016     LIR_List* ops = block-&gt;lir();
2017     int num_ops = ops-&gt;length();
2018 
2019     // iterate all instructions of the block. skip the first because it is always a label
2020     assert(visitor.no_operands(ops-&gt;at(0)), &quot;first operation must always be a label&quot;);
2021     for (int j = 1; j &lt; num_ops; j++) {
2022       LIR_Op* op = ops-&gt;at(j);
2023       int op_id = op-&gt;id();
2024 
2025       if (op_id != -1 &amp;&amp; has_info(op_id)) {
2026         // visit operation to collect all operands
2027         visitor.visit(op);
2028         assert(visitor.info_count() &gt; 0, &quot;should not visit otherwise&quot;);
2029 
2030         XHandlers* xhandlers = visitor.all_xhandler();
2031         int n = xhandlers-&gt;length();
2032         for (int k = 0; k &lt; n; k++) {
2033           resolve_exception_edge(xhandlers-&gt;handler_at(k), op_id, move_resolver);
2034         }
2035 
2036 #ifdef ASSERT
2037       } else {
2038         visitor.visit(op);
2039         assert(visitor.all_xhandler()-&gt;length() == 0, &quot;missed exception handler&quot;);
2040 #endif
2041       }
2042     }
2043   }
2044 }
2045 
2046 
2047 // ********** Phase 7: assign register numbers back to LIR
2048 // (includes computation of debug information and oop maps)
2049 
2050 VMReg LinearScan::vm_reg_for_interval(Interval* interval) {
2051   VMReg reg = interval-&gt;cached_vm_reg();
2052   if (!reg-&gt;is_valid() ) {
2053     reg = vm_reg_for_operand(operand_for_interval(interval));
2054     interval-&gt;set_cached_vm_reg(reg);
2055   }
2056   assert(reg == vm_reg_for_operand(operand_for_interval(interval)), &quot;wrong cached value&quot;);
2057   return reg;
2058 }
2059 
2060 VMReg LinearScan::vm_reg_for_operand(LIR_Opr opr) {
2061   assert(opr-&gt;is_oop(), &quot;currently only implemented for oop operands&quot;);
2062   return frame_map()-&gt;regname(opr);
2063 }
2064 
2065 
2066 LIR_Opr LinearScan::operand_for_interval(Interval* interval) {
2067   LIR_Opr opr = interval-&gt;cached_opr();
2068   if (opr-&gt;is_illegal()) {
2069     opr = calc_operand_for_interval(interval);
2070     interval-&gt;set_cached_opr(opr);
2071   }
2072 
2073   assert(opr == calc_operand_for_interval(interval), &quot;wrong cached value&quot;);
2074   return opr;
2075 }
2076 
2077 LIR_Opr LinearScan::calc_operand_for_interval(const Interval* interval) {
2078   int assigned_reg = interval-&gt;assigned_reg();
2079   BasicType type = interval-&gt;type();
2080 
2081   if (assigned_reg &gt;= nof_regs) {
2082     // stack slot
2083     assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2084     return LIR_OprFact::stack(assigned_reg - nof_regs, type);
2085 
2086   } else {
2087     // register
2088     switch (type) {
2089       case T_OBJECT: {
2090         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2091         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2092         return LIR_OprFact::single_cpu_oop(assigned_reg);
2093       }
2094 
2095       case T_ADDRESS: {
2096         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2097         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2098         return LIR_OprFact::single_cpu_address(assigned_reg);
2099       }
2100 
2101       case T_METADATA: {
2102         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2103         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2104         return LIR_OprFact::single_cpu_metadata(assigned_reg);
2105       }
2106 
2107 #ifdef __SOFTFP__
2108       case T_FLOAT:  // fall through
2109 #endif // __SOFTFP__
2110       case T_INT: {
2111         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2112         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2113         return LIR_OprFact::single_cpu(assigned_reg);
2114       }
2115 
2116 #ifdef __SOFTFP__
2117       case T_DOUBLE:  // fall through
2118 #endif // __SOFTFP__
2119       case T_LONG: {
2120         int assigned_regHi = interval-&gt;assigned_regHi();
2121         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2122         assert(num_physical_regs(T_LONG) == 1 ||
2123                (assigned_regHi &gt;= pd_first_cpu_reg &amp;&amp; assigned_regHi &lt;= pd_last_cpu_reg), &quot;no cpu register&quot;);
2124 
2125         assert(assigned_reg != assigned_regHi, &quot;invalid allocation&quot;);
2126         assert(num_physical_regs(T_LONG) == 1 || assigned_reg &lt; assigned_regHi,
2127                &quot;register numbers must be sorted (ensure that e.g. a move from eax,ebx to ebx,eax can not occur)&quot;);
2128         assert((assigned_regHi != any_reg) ^ (num_physical_regs(T_LONG) == 1), &quot;must be match&quot;);
2129         if (requires_adjacent_regs(T_LONG)) {
2130           assert(assigned_reg % 2 == 0 &amp;&amp; assigned_reg + 1 == assigned_regHi, &quot;must be sequential and even&quot;);
2131         }
2132 
2133 #ifdef _LP64
2134         return LIR_OprFact::double_cpu(assigned_reg, assigned_reg);
2135 #else
2136 #if defined(SPARC) || defined(PPC32)
2137         return LIR_OprFact::double_cpu(assigned_regHi, assigned_reg);
2138 #else
2139         return LIR_OprFact::double_cpu(assigned_reg, assigned_regHi);
2140 #endif // SPARC
2141 #endif // LP64
2142       }
2143 
2144 #ifndef __SOFTFP__
2145       case T_FLOAT: {
2146 #ifdef X86
2147         if (UseSSE &gt;= 1) {
2148           int last_xmm_reg = pd_last_xmm_reg;
2149 #ifdef _LP64
2150           if (UseAVX &lt; 3) {
2151             last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map / 2) - 1;
2152           }
2153 #endif // LP64
2154           assert(assigned_reg &gt;= pd_first_xmm_reg &amp;&amp; assigned_reg &lt;= last_xmm_reg, &quot;no xmm register&quot;);
2155           assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2156           return LIR_OprFact::single_xmm(assigned_reg - pd_first_xmm_reg);
2157         }
2158 #endif // X86
2159 
2160         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2161         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2162         return LIR_OprFact::single_fpu(assigned_reg - pd_first_fpu_reg);
2163       }
2164 
2165       case T_DOUBLE: {
2166 #ifdef X86
2167         if (UseSSE &gt;= 2) {
2168           int last_xmm_reg = pd_last_xmm_reg;
2169 #ifdef _LP64
2170           if (UseAVX &lt; 3) {
2171             last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map / 2) - 1;
2172           }
2173 #endif // LP64
2174           assert(assigned_reg &gt;= pd_first_xmm_reg &amp;&amp; assigned_reg &lt;= last_xmm_reg, &quot;no xmm register&quot;);
2175           assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register (double xmm values are stored in one register)&quot;);
2176           return LIR_OprFact::double_xmm(assigned_reg - pd_first_xmm_reg);
2177         }
2178 #endif // X86
2179 
2180 #ifdef SPARC
2181         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2182         assert(interval-&gt;assigned_regHi() &gt;= pd_first_fpu_reg &amp;&amp; interval-&gt;assigned_regHi() &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2183         assert(assigned_reg % 2 == 0 &amp;&amp; assigned_reg + 1 == interval-&gt;assigned_regHi(), &quot;must be sequential and even&quot;);
2184         LIR_Opr result = LIR_OprFact::double_fpu(interval-&gt;assigned_regHi() - pd_first_fpu_reg, assigned_reg - pd_first_fpu_reg);
2185 #elif defined(ARM32)
2186         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2187         assert(interval-&gt;assigned_regHi() &gt;= pd_first_fpu_reg &amp;&amp; interval-&gt;assigned_regHi() &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2188         assert(assigned_reg % 2 == 0 &amp;&amp; assigned_reg + 1 == interval-&gt;assigned_regHi(), &quot;must be sequential and even&quot;);
2189         LIR_Opr result = LIR_OprFact::double_fpu(assigned_reg - pd_first_fpu_reg, interval-&gt;assigned_regHi() - pd_first_fpu_reg);
2190 #else
2191         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2192         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register (double fpu values are stored in one register on Intel)&quot;);
2193         LIR_Opr result = LIR_OprFact::double_fpu(assigned_reg - pd_first_fpu_reg);
2194 #endif
2195         return result;
2196       }
2197 #endif // __SOFTFP__
2198 
2199       default: {
2200         ShouldNotReachHere();
2201         return LIR_OprFact::illegalOpr;
2202       }
2203     }
2204   }
2205 }
2206 
2207 LIR_Opr LinearScan::canonical_spill_opr(Interval* interval) {
2208   assert(interval-&gt;canonical_spill_slot() &gt;= nof_regs, &quot;canonical spill slot not set&quot;);
2209   return LIR_OprFact::stack(interval-&gt;canonical_spill_slot() - nof_regs, interval-&gt;type());
2210 }
2211 
2212 LIR_Opr LinearScan::color_lir_opr(LIR_Opr opr, int op_id, LIR_OpVisitState::OprMode mode) {
2213   assert(opr-&gt;is_virtual(), &quot;should not call this otherwise&quot;);
2214 
2215   Interval* interval = interval_at(opr-&gt;vreg_number());
2216   assert(interval != NULL, &quot;interval must exist&quot;);
2217 
2218   if (op_id != -1) {
2219 #ifdef ASSERT
2220     BlockBegin* block = block_of_op_with_id(op_id);
2221     if (block-&gt;number_of_sux() &lt;= 1 &amp;&amp; op_id == block-&gt;last_lir_instruction_id()) {
2222       // check if spill moves could have been appended at the end of this block, but
2223       // before the branch instruction. So the split child information for this branch would
2224       // be incorrect.
2225       LIR_OpBranch* branch = block-&gt;lir()-&gt;instructions_list()-&gt;last()-&gt;as_OpBranch();
2226       if (branch != NULL) {
2227         if (block-&gt;live_out().at(opr-&gt;vreg_number())) {
2228           assert(branch-&gt;cond() == lir_cond_always, &quot;block does not end with an unconditional jump&quot;);
2229           assert(false, &quot;can&#39;t get split child for the last branch of a block because the information would be incorrect (moves are inserted before the branch in resolve_data_flow)&quot;);
2230         }
2231       }
2232     }
2233 #endif
2234 
2235     // operands are not changed when an interval is split during allocation,
2236     // so search the right interval here
2237     interval = split_child_at_op_id(interval, op_id, mode);
2238   }
2239 
2240   LIR_Opr res = operand_for_interval(interval);
2241 
2242 #ifdef X86
2243   // new semantic for is_last_use: not only set on definite end of interval,
2244   // but also before hole
2245   // This may still miss some cases (e.g. for dead values), but it is not necessary that the
2246   // last use information is completely correct
2247   // information is only needed for fpu stack allocation
2248   if (res-&gt;is_fpu_register()) {
2249     if (opr-&gt;is_last_use() || op_id == interval-&gt;to() || (op_id != -1 &amp;&amp; interval-&gt;has_hole_between(op_id, op_id + 1))) {
2250       assert(op_id == -1 || !is_block_begin(op_id), &quot;holes at begin of block may also result from control flow&quot;);
2251       res = res-&gt;make_last_use();
2252     }
2253   }
2254 #endif
2255 
2256   assert(!gen()-&gt;is_vreg_flag_set(opr-&gt;vreg_number(), LIRGenerator::callee_saved) || !FrameMap::is_caller_save_register(res), &quot;bad allocation&quot;);
2257 
2258   return res;
2259 }
2260 
2261 
2262 #ifdef ASSERT
2263 // some methods used to check correctness of debug information
2264 
2265 void assert_no_register_values(GrowableArray&lt;ScopeValue*&gt;* values) {
2266   if (values == NULL) {
2267     return;
2268   }
2269 
2270   for (int i = 0; i &lt; values-&gt;length(); i++) {
2271     ScopeValue* value = values-&gt;at(i);
2272 
2273     if (value-&gt;is_location()) {
2274       Location location = ((LocationValue*)value)-&gt;location();
2275       assert(location.where() == Location::on_stack, &quot;value is in register&quot;);
2276     }
2277   }
2278 }
2279 
2280 void assert_no_register_values(GrowableArray&lt;MonitorValue*&gt;* values) {
2281   if (values == NULL) {
2282     return;
2283   }
2284 
2285   for (int i = 0; i &lt; values-&gt;length(); i++) {
2286     MonitorValue* value = values-&gt;at(i);
2287 
2288     if (value-&gt;owner()-&gt;is_location()) {
2289       Location location = ((LocationValue*)value-&gt;owner())-&gt;location();
2290       assert(location.where() == Location::on_stack, &quot;owner is in register&quot;);
2291     }
2292     assert(value-&gt;basic_lock().where() == Location::on_stack, &quot;basic_lock is in register&quot;);
2293   }
2294 }
2295 
2296 void assert_equal(Location l1, Location l2) {
2297   assert(l1.where() == l2.where() &amp;&amp; l1.type() == l2.type() &amp;&amp; l1.offset() == l2.offset(), &quot;&quot;);
2298 }
2299 
2300 void assert_equal(ScopeValue* v1, ScopeValue* v2) {
2301   if (v1-&gt;is_location()) {
2302     assert(v2-&gt;is_location(), &quot;&quot;);
2303     assert_equal(((LocationValue*)v1)-&gt;location(), ((LocationValue*)v2)-&gt;location());
2304   } else if (v1-&gt;is_constant_int()) {
2305     assert(v2-&gt;is_constant_int(), &quot;&quot;);
2306     assert(((ConstantIntValue*)v1)-&gt;value() == ((ConstantIntValue*)v2)-&gt;value(), &quot;&quot;);
2307   } else if (v1-&gt;is_constant_double()) {
2308     assert(v2-&gt;is_constant_double(), &quot;&quot;);
2309     assert(((ConstantDoubleValue*)v1)-&gt;value() == ((ConstantDoubleValue*)v2)-&gt;value(), &quot;&quot;);
2310   } else if (v1-&gt;is_constant_long()) {
2311     assert(v2-&gt;is_constant_long(), &quot;&quot;);
2312     assert(((ConstantLongValue*)v1)-&gt;value() == ((ConstantLongValue*)v2)-&gt;value(), &quot;&quot;);
2313   } else if (v1-&gt;is_constant_oop()) {
2314     assert(v2-&gt;is_constant_oop(), &quot;&quot;);
2315     assert(((ConstantOopWriteValue*)v1)-&gt;value() == ((ConstantOopWriteValue*)v2)-&gt;value(), &quot;&quot;);
2316   } else {
2317     ShouldNotReachHere();
2318   }
2319 }
2320 
2321 void assert_equal(MonitorValue* m1, MonitorValue* m2) {
2322   assert_equal(m1-&gt;owner(), m2-&gt;owner());
2323   assert_equal(m1-&gt;basic_lock(), m2-&gt;basic_lock());
2324 }
2325 
2326 void assert_equal(IRScopeDebugInfo* d1, IRScopeDebugInfo* d2) {
2327   assert(d1-&gt;scope() == d2-&gt;scope(), &quot;not equal&quot;);
2328   assert(d1-&gt;bci() == d2-&gt;bci(), &quot;not equal&quot;);
2329 
2330   if (d1-&gt;locals() != NULL) {
2331     assert(d1-&gt;locals() != NULL &amp;&amp; d2-&gt;locals() != NULL, &quot;not equal&quot;);
2332     assert(d1-&gt;locals()-&gt;length() == d2-&gt;locals()-&gt;length(), &quot;not equal&quot;);
2333     for (int i = 0; i &lt; d1-&gt;locals()-&gt;length(); i++) {
2334       assert_equal(d1-&gt;locals()-&gt;at(i), d2-&gt;locals()-&gt;at(i));
2335     }
2336   } else {
2337     assert(d1-&gt;locals() == NULL &amp;&amp; d2-&gt;locals() == NULL, &quot;not equal&quot;);
2338   }
2339 
2340   if (d1-&gt;expressions() != NULL) {
2341     assert(d1-&gt;expressions() != NULL &amp;&amp; d2-&gt;expressions() != NULL, &quot;not equal&quot;);
2342     assert(d1-&gt;expressions()-&gt;length() == d2-&gt;expressions()-&gt;length(), &quot;not equal&quot;);
2343     for (int i = 0; i &lt; d1-&gt;expressions()-&gt;length(); i++) {
2344       assert_equal(d1-&gt;expressions()-&gt;at(i), d2-&gt;expressions()-&gt;at(i));
2345     }
2346   } else {
2347     assert(d1-&gt;expressions() == NULL &amp;&amp; d2-&gt;expressions() == NULL, &quot;not equal&quot;);
2348   }
2349 
2350   if (d1-&gt;monitors() != NULL) {
2351     assert(d1-&gt;monitors() != NULL &amp;&amp; d2-&gt;monitors() != NULL, &quot;not equal&quot;);
2352     assert(d1-&gt;monitors()-&gt;length() == d2-&gt;monitors()-&gt;length(), &quot;not equal&quot;);
2353     for (int i = 0; i &lt; d1-&gt;monitors()-&gt;length(); i++) {
2354       assert_equal(d1-&gt;monitors()-&gt;at(i), d2-&gt;monitors()-&gt;at(i));
2355     }
2356   } else {
2357     assert(d1-&gt;monitors() == NULL &amp;&amp; d2-&gt;monitors() == NULL, &quot;not equal&quot;);
2358   }
2359 
2360   if (d1-&gt;caller() != NULL) {
2361     assert(d1-&gt;caller() != NULL &amp;&amp; d2-&gt;caller() != NULL, &quot;not equal&quot;);
2362     assert_equal(d1-&gt;caller(), d2-&gt;caller());
2363   } else {
2364     assert(d1-&gt;caller() == NULL &amp;&amp; d2-&gt;caller() == NULL, &quot;not equal&quot;);
2365   }
2366 }
2367 
2368 void check_stack_depth(CodeEmitInfo* info, int stack_end) {
2369   if (info-&gt;stack()-&gt;bci() != SynchronizationEntryBCI &amp;&amp; !info-&gt;scope()-&gt;method()-&gt;is_native()) {
2370     Bytecodes::Code code = info-&gt;scope()-&gt;method()-&gt;java_code_at_bci(info-&gt;stack()-&gt;bci());
2371     switch (code) {
2372       case Bytecodes::_ifnull    : // fall through
2373       case Bytecodes::_ifnonnull : // fall through
2374       case Bytecodes::_ifeq      : // fall through
2375       case Bytecodes::_ifne      : // fall through
2376       case Bytecodes::_iflt      : // fall through
2377       case Bytecodes::_ifge      : // fall through
2378       case Bytecodes::_ifgt      : // fall through
2379       case Bytecodes::_ifle      : // fall through
2380       case Bytecodes::_if_icmpeq : // fall through
2381       case Bytecodes::_if_icmpne : // fall through
2382       case Bytecodes::_if_icmplt : // fall through
2383       case Bytecodes::_if_icmpge : // fall through
2384       case Bytecodes::_if_icmpgt : // fall through
2385       case Bytecodes::_if_icmple : // fall through
2386       case Bytecodes::_if_acmpeq : // fall through
2387       case Bytecodes::_if_acmpne :
2388         assert(stack_end &gt;= -Bytecodes::depth(code), &quot;must have non-empty expression stack at if bytecode&quot;);
2389         break;
2390       default:
2391         break;
2392     }
2393   }
2394 }
2395 
2396 #endif // ASSERT
2397 
2398 
2399 IntervalWalker* LinearScan::init_compute_oop_maps() {
2400   // setup lists of potential oops for walking
2401   Interval* oop_intervals;
2402   Interval* non_oop_intervals;
2403 
2404   create_unhandled_lists(&amp;oop_intervals, &amp;non_oop_intervals, is_oop_interval, NULL);
2405 
2406   // intervals that have no oops inside need not to be processed
2407   // to ensure a walking until the last instruction id, add a dummy interval
2408   // with a high operation id
2409   non_oop_intervals = new Interval(any_reg);
2410   non_oop_intervals-&gt;add_range(max_jint - 2, max_jint - 1);
2411 
2412   return new IntervalWalker(this, oop_intervals, non_oop_intervals);
2413 }
2414 
2415 
2416 OopMap* LinearScan::compute_oop_map(IntervalWalker* iw, LIR_Op* op, CodeEmitInfo* info, bool is_call_site) {
2417   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;creating oop map at op_id %d&quot;, op-&gt;id()));
2418 
2419   // walk before the current operation -&gt; intervals that start at
2420   // the operation (= output operands of the operation) are not
2421   // included in the oop map
2422   iw-&gt;walk_before(op-&gt;id());
2423 
2424   int frame_size = frame_map()-&gt;framesize();
2425   int arg_count = frame_map()-&gt;oop_map_arg_count();
2426   OopMap* map = new OopMap(frame_size, arg_count);
2427 
2428   // Iterate through active intervals
2429   for (Interval* interval = iw-&gt;active_first(fixedKind); interval != Interval::end(); interval = interval-&gt;next()) {
2430     int assigned_reg = interval-&gt;assigned_reg();
2431 
2432     assert(interval-&gt;current_from() &lt;= op-&gt;id() &amp;&amp; op-&gt;id() &lt;= interval-&gt;current_to(), &quot;interval should not be active otherwise&quot;);
2433     assert(interval-&gt;assigned_regHi() == any_reg, &quot;oop must be single word&quot;);
2434     assert(interval-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base, &quot;fixed interval found&quot;);
2435 
2436     // Check if this range covers the instruction. Intervals that
2437     // start or end at the current operation are not included in the
2438     // oop map, except in the case of patching moves.  For patching
2439     // moves, any intervals which end at this instruction are included
2440     // in the oop map since we may safepoint while doing the patch
2441     // before we&#39;ve consumed the inputs.
2442     if (op-&gt;is_patching() || op-&gt;id() &lt; interval-&gt;current_to()) {
2443 
2444       // caller-save registers must not be included into oop-maps at calls
2445       assert(!is_call_site || assigned_reg &gt;= nof_regs || !is_caller_save(assigned_reg), &quot;interval is in a caller-save register at a call -&gt; register will be overwritten&quot;);
2446 
2447       VMReg name = vm_reg_for_interval(interval);
2448       set_oop(map, name);
2449 
2450       // Spill optimization: when the stack value is guaranteed to be always correct,
2451       // then it must be added to the oop map even if the interval is currently in a register
2452       if (interval-&gt;always_in_memory() &amp;&amp;
2453           op-&gt;id() &gt; interval-&gt;spill_definition_pos() &amp;&amp;
2454           interval-&gt;assigned_reg() != interval-&gt;canonical_spill_slot()) {
2455         assert(interval-&gt;spill_definition_pos() &gt; 0, &quot;position not set correctly&quot;);
2456         assert(interval-&gt;canonical_spill_slot() &gt;= LinearScan::nof_regs, &quot;no spill slot assigned&quot;);
2457         assert(interval-&gt;assigned_reg() &lt; LinearScan::nof_regs, &quot;interval is on stack, so stack slot is registered twice&quot;);
2458 
2459         set_oop(map, frame_map()-&gt;slot_regname(interval-&gt;canonical_spill_slot() - LinearScan::nof_regs));
2460       }
2461     }
2462   }
2463 
2464   // add oops from lock stack
2465   assert(info-&gt;stack() != NULL, &quot;CodeEmitInfo must always have a stack&quot;);
2466   int locks_count = info-&gt;stack()-&gt;total_locks_size();
2467   for (int i = 0; i &lt; locks_count; i++) {
2468     set_oop(map, frame_map()-&gt;monitor_object_regname(i));
2469   }
2470 
2471   return map;
2472 }
2473 
2474 
2475 void LinearScan::compute_oop_map(IntervalWalker* iw, const LIR_OpVisitState &amp;visitor, LIR_Op* op) {
2476   assert(visitor.info_count() &gt; 0, &quot;no oop map needed&quot;);
2477 
2478   // compute oop_map only for first CodeEmitInfo
2479   // because it is (in most cases) equal for all other infos of the same operation
2480   CodeEmitInfo* first_info = visitor.info_at(0);
2481   OopMap* first_oop_map = compute_oop_map(iw, op, first_info, visitor.has_call());
2482 
2483   for (int i = 0; i &lt; visitor.info_count(); i++) {
2484     CodeEmitInfo* info = visitor.info_at(i);
2485     OopMap* oop_map = first_oop_map;
2486 
2487     // compute worst case interpreter size in case of a deoptimization
2488     _compilation-&gt;update_interpreter_frame_size(info-&gt;interpreter_frame_size());
2489 
2490     if (info-&gt;stack()-&gt;locks_size() != first_info-&gt;stack()-&gt;locks_size()) {
2491       // this info has a different number of locks then the precomputed oop map
2492       // (possible for lock and unlock instructions) -&gt; compute oop map with
2493       // correct lock information
2494       oop_map = compute_oop_map(iw, op, info, visitor.has_call());
2495     }
2496 
2497     if (info-&gt;_oop_map == NULL) {
2498       info-&gt;_oop_map = oop_map;
2499     } else {
2500       // a CodeEmitInfo can not be shared between different LIR-instructions
2501       // because interval splitting can occur anywhere between two instructions
2502       // and so the oop maps must be different
2503       // -&gt; check if the already set oop_map is exactly the one calculated for this operation
2504       assert(info-&gt;_oop_map == oop_map, &quot;same CodeEmitInfo used for multiple LIR instructions&quot;);
2505     }
2506   }
2507 }
2508 
2509 
2510 // frequently used constants
2511 // Allocate them with new so they are never destroyed (otherwise, a
2512 // forced exit could destroy these objects while they are still in
2513 // use).
2514 ConstantOopWriteValue* LinearScan::_oop_null_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantOopWriteValue(NULL);
2515 ConstantIntValue*      LinearScan::_int_m1_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(-1);
2516 ConstantIntValue*      LinearScan::_int_0_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue((jint)0);
2517 ConstantIntValue*      LinearScan::_int_1_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(1);
2518 ConstantIntValue*      LinearScan::_int_2_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(2);
2519 LocationValue*         _illegal_value = new (ResourceObj::C_HEAP, mtCompiler) LocationValue(Location());
2520 
2521 void LinearScan::init_compute_debug_info() {
2522   // cache for frequently used scope values
2523   // (cpu registers and stack slots)
2524   int cache_size = (LinearScan::nof_cpu_regs + frame_map()-&gt;argcount() + max_spills()) * 2;
2525   _scope_value_cache = ScopeValueArray(cache_size, cache_size, NULL);
2526 }
2527 
2528 MonitorValue* LinearScan::location_for_monitor_index(int monitor_index) {
2529   Location loc;
2530   if (!frame_map()-&gt;location_for_monitor_object(monitor_index, &amp;loc)) {
2531     bailout(&quot;too large frame&quot;);
2532   }
2533   ScopeValue* object_scope_value = new LocationValue(loc);
2534 
2535   if (!frame_map()-&gt;location_for_monitor_lock(monitor_index, &amp;loc)) {
2536     bailout(&quot;too large frame&quot;);
2537   }
2538   return new MonitorValue(object_scope_value, loc);
2539 }
2540 
2541 LocationValue* LinearScan::location_for_name(int name, Location::Type loc_type) {
2542   Location loc;
2543   if (!frame_map()-&gt;locations_for_slot(name, loc_type, &amp;loc)) {
2544     bailout(&quot;too large frame&quot;);
2545   }
2546   return new LocationValue(loc);
2547 }
2548 
2549 
2550 int LinearScan::append_scope_value_for_constant(LIR_Opr opr, GrowableArray&lt;ScopeValue*&gt;* scope_values) {
2551   assert(opr-&gt;is_constant(), &quot;should not be called otherwise&quot;);
2552 
2553   LIR_Const* c = opr-&gt;as_constant_ptr();
2554   BasicType t = c-&gt;type();
2555   switch (t) {
2556     case T_OBJECT: {
2557       jobject value = c-&gt;as_jobject();
2558       if (value == NULL) {
2559         scope_values-&gt;append(_oop_null_scope_value);
2560       } else {
2561         scope_values-&gt;append(new ConstantOopWriteValue(c-&gt;as_jobject()));
2562       }
2563       return 1;
2564     }
2565 
2566     case T_INT: // fall through
2567     case T_FLOAT: {
2568       int value = c-&gt;as_jint_bits();
2569       switch (value) {
2570         case -1: scope_values-&gt;append(_int_m1_scope_value); break;
2571         case 0:  scope_values-&gt;append(_int_0_scope_value); break;
2572         case 1:  scope_values-&gt;append(_int_1_scope_value); break;
2573         case 2:  scope_values-&gt;append(_int_2_scope_value); break;
2574         default: scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_bits())); break;
2575       }
2576       return 1;
2577     }
2578 
2579     case T_LONG: // fall through
2580     case T_DOUBLE: {
2581 #ifdef _LP64
2582       scope_values-&gt;append(_int_0_scope_value);
2583       scope_values-&gt;append(new ConstantLongValue(c-&gt;as_jlong_bits()));
2584 #else
2585       if (hi_word_offset_in_bytes &gt; lo_word_offset_in_bytes) {
2586         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_hi_bits()));
2587         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_lo_bits()));
2588       } else {
2589         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_lo_bits()));
2590         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_hi_bits()));
2591       }
2592 #endif
2593       return 2;
2594     }
2595 
2596     case T_ADDRESS: {
2597 #ifdef _LP64
2598       scope_values-&gt;append(new ConstantLongValue(c-&gt;as_jint()));
2599 #else
2600       scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint()));
2601 #endif
2602       return 1;
2603     }
2604 
2605     default:
2606       ShouldNotReachHere();
2607       return -1;
2608   }
2609 }
2610 
2611 int LinearScan::append_scope_value_for_operand(LIR_Opr opr, GrowableArray&lt;ScopeValue*&gt;* scope_values) {
2612   if (opr-&gt;is_single_stack()) {
2613     int stack_idx = opr-&gt;single_stack_ix();
2614     bool is_oop = opr-&gt;is_oop_register();
2615     int cache_idx = (stack_idx + LinearScan::nof_cpu_regs) * 2 + (is_oop ? 1 : 0);
2616 
2617     ScopeValue* sv = _scope_value_cache.at(cache_idx);
2618     if (sv == NULL) {
2619       Location::Type loc_type = is_oop ? Location::oop : Location::normal;
2620       sv = location_for_name(stack_idx, loc_type);
2621       _scope_value_cache.at_put(cache_idx, sv);
2622     }
2623 
2624     // check if cached value is correct
2625     DEBUG_ONLY(assert_equal(sv, location_for_name(stack_idx, is_oop ? Location::oop : Location::normal)));
2626 
2627     scope_values-&gt;append(sv);
2628     return 1;
2629 
2630   } else if (opr-&gt;is_single_cpu()) {
2631     bool is_oop = opr-&gt;is_oop_register();
2632     int cache_idx = opr-&gt;cpu_regnr() * 2 + (is_oop ? 1 : 0);
2633     Location::Type int_loc_type = NOT_LP64(Location::normal) LP64_ONLY(Location::int_in_long);
2634 
2635     ScopeValue* sv = _scope_value_cache.at(cache_idx);
2636     if (sv == NULL) {
2637       Location::Type loc_type = is_oop ? Location::oop : int_loc_type;
2638       VMReg rname = frame_map()-&gt;regname(opr);
2639       sv = new LocationValue(Location::new_reg_loc(loc_type, rname));
2640       _scope_value_cache.at_put(cache_idx, sv);
2641     }
2642 
2643     // check if cached value is correct
2644     DEBUG_ONLY(assert_equal(sv, new LocationValue(Location::new_reg_loc(is_oop ? Location::oop : int_loc_type, frame_map()-&gt;regname(opr)))));
2645 
2646     scope_values-&gt;append(sv);
2647     return 1;
2648 
2649 #ifdef X86
2650   } else if (opr-&gt;is_single_xmm()) {
2651     VMReg rname = opr-&gt;as_xmm_float_reg()-&gt;as_VMReg();
2652     LocationValue* sv = new LocationValue(Location::new_reg_loc(Location::normal, rname));
2653 
2654     scope_values-&gt;append(sv);
2655     return 1;
2656 #endif
2657 
2658   } else if (opr-&gt;is_single_fpu()) {
2659 #ifdef IA32
2660     // the exact location of fpu stack values is only known
2661     // during fpu stack allocation, so the stack allocator object
2662     // must be present
2663     assert(use_fpu_stack_allocation(), &quot;should not have float stack values without fpu stack allocation (all floats must be SSE2)&quot;);
2664     assert(_fpu_stack_allocator != NULL, &quot;must be present&quot;);
2665     opr = _fpu_stack_allocator-&gt;to_fpu_stack(opr);
2666 #elif defined(AMD64)
2667     assert(false, &quot;FPU not used on x86-64&quot;);
2668 #endif
2669 
2670     Location::Type loc_type = float_saved_as_double ? Location::float_in_dbl : Location::normal;
2671     VMReg rname = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnr());
2672 #ifndef __SOFTFP__
2673 #ifndef VM_LITTLE_ENDIAN
2674     // On S390 a (single precision) float value occupies only the high
2675     // word of the full double register. So when the double register is
2676     // stored to memory (e.g. by the RegisterSaver), then the float value
2677     // is found at offset 0. I.e. the code below is not needed on S390.
2678 #ifndef S390
2679     if (! float_saved_as_double) {
2680       // On big endian system, we may have an issue if float registers use only
2681       // the low half of the (same) double registers.
2682       // Both the float and the double could have the same regnr but would correspond
2683       // to two different addresses once saved.
2684 
2685       // get next safely (no assertion checks)
2686       VMReg next = VMRegImpl::as_VMReg(1+rname-&gt;value());
2687       if (next-&gt;is_reg() &amp;&amp;
2688           (next-&gt;as_FloatRegister() == rname-&gt;as_FloatRegister())) {
2689         // the back-end does use the same numbering for the double and the float
2690         rname = next; // VMReg for the low bits, e.g. the real VMReg for the float
2691       }
2692     }
2693 #endif // !S390
2694 #endif
2695 #endif
2696     LocationValue* sv = new LocationValue(Location::new_reg_loc(loc_type, rname));
2697 
2698     scope_values-&gt;append(sv);
2699     return 1;
2700 
2701   } else {
2702     // double-size operands
2703 
2704     ScopeValue* first;
2705     ScopeValue* second;
2706 
2707     if (opr-&gt;is_double_stack()) {
2708 #ifdef _LP64
2709       Location loc1;
2710       Location::Type loc_type = opr-&gt;type() == T_LONG ? Location::lng : Location::dbl;
2711       if (!frame_map()-&gt;locations_for_slot(opr-&gt;double_stack_ix(), loc_type, &amp;loc1, NULL)) {
2712         bailout(&quot;too large frame&quot;);
2713       }
2714       // Does this reverse on x86 vs. sparc?
2715       first =  new LocationValue(loc1);
2716       second = _int_0_scope_value;
2717 #else
2718       Location loc1, loc2;
2719       if (!frame_map()-&gt;locations_for_slot(opr-&gt;double_stack_ix(), Location::normal, &amp;loc1, &amp;loc2)) {
2720         bailout(&quot;too large frame&quot;);
2721       }
2722       first =  new LocationValue(loc1);
2723       second = new LocationValue(loc2);
2724 #endif // _LP64
2725 
2726     } else if (opr-&gt;is_double_cpu()) {
2727 #ifdef _LP64
2728       VMReg rname_first = opr-&gt;as_register_lo()-&gt;as_VMReg();
2729       first = new LocationValue(Location::new_reg_loc(Location::lng, rname_first));
2730       second = _int_0_scope_value;
2731 #else
2732       VMReg rname_first = opr-&gt;as_register_lo()-&gt;as_VMReg();
2733       VMReg rname_second = opr-&gt;as_register_hi()-&gt;as_VMReg();
2734 
2735       if (hi_word_offset_in_bytes &lt; lo_word_offset_in_bytes) {
2736         // lo/hi and swapped relative to first and second, so swap them
2737         VMReg tmp = rname_first;
2738         rname_first = rname_second;
2739         rname_second = tmp;
2740       }
2741 
2742       first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
2743       second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
2744 #endif //_LP64
2745 
2746 
2747 #ifdef X86
2748     } else if (opr-&gt;is_double_xmm()) {
2749       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation&quot;);
2750       VMReg rname_first  = opr-&gt;as_xmm_double_reg()-&gt;as_VMReg();
2751 #  ifdef _LP64
2752       first = new LocationValue(Location::new_reg_loc(Location::dbl, rname_first));
2753       second = _int_0_scope_value;
2754 #  else
2755       first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
2756       // %%% This is probably a waste but we&#39;ll keep things as they were for now
2757       if (true) {
2758         VMReg rname_second = rname_first-&gt;next();
2759         second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
2760       }
2761 #  endif
2762 #endif
2763 
2764     } else if (opr-&gt;is_double_fpu()) {
2765       // On SPARC, fpu_regnrLo/fpu_regnrHi represents the two halves of
2766       // the double as float registers in the native ordering. On X86,
2767       // fpu_regnrLo is a FPU stack slot whose VMReg represents
2768       // the low-order word of the double and fpu_regnrLo + 1 is the
2769       // name for the other half.  *first and *second must represent the
2770       // least and most significant words, respectively.
2771 
2772 #ifdef IA32
2773       // the exact location of fpu stack values is only known
2774       // during fpu stack allocation, so the stack allocator object
2775       // must be present
2776       assert(use_fpu_stack_allocation(), &quot;should not have float stack values without fpu stack allocation (all floats must be SSE2)&quot;);
2777       assert(_fpu_stack_allocator != NULL, &quot;must be present&quot;);
2778       opr = _fpu_stack_allocator-&gt;to_fpu_stack(opr);
2779 
2780       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation (only fpu_regnrLo is used)&quot;);
2781 #endif
2782 #ifdef AMD64
2783       assert(false, &quot;FPU not used on x86-64&quot;);
2784 #endif
2785 #ifdef SPARC
2786       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi() + 1, &quot;assumed in calculation (only fpu_regnrHi is used)&quot;);
2787 #endif
2788 #ifdef ARM32
2789       assert(opr-&gt;fpu_regnrHi() == opr-&gt;fpu_regnrLo() + 1, &quot;assumed in calculation (only fpu_regnrLo is used)&quot;);
2790 #endif
2791 #ifdef PPC32
2792       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation (only fpu_regnrHi is used)&quot;);
2793 #endif
2794 
2795 #ifdef VM_LITTLE_ENDIAN
2796       VMReg rname_first = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnrLo());
2797 #else
2798       VMReg rname_first = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnrHi());
2799 #endif
2800 
2801 #ifdef _LP64
2802       first = new LocationValue(Location::new_reg_loc(Location::dbl, rname_first));
2803       second = _int_0_scope_value;
2804 #else
2805       first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
2806       // %%% This is probably a waste but we&#39;ll keep things as they were for now
2807       if (true) {
2808         VMReg rname_second = rname_first-&gt;next();
2809         second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
2810       }
2811 #endif
2812 
2813     } else {
2814       ShouldNotReachHere();
2815       first = NULL;
2816       second = NULL;
2817     }
2818 
2819     assert(first != NULL &amp;&amp; second != NULL, &quot;must be set&quot;);
2820     // The convention the interpreter uses is that the second local
2821     // holds the first raw word of the native double representation.
2822     // This is actually reasonable, since locals and stack arrays
2823     // grow downwards in all implementations.
2824     // (If, on some machine, the interpreter&#39;s Java locals or stack
2825     // were to grow upwards, the embedded doubles would be word-swapped.)
2826     scope_values-&gt;append(second);
2827     scope_values-&gt;append(first);
2828     return 2;
2829   }
2830 }
2831 
2832 
2833 int LinearScan::append_scope_value(int op_id, Value value, GrowableArray&lt;ScopeValue*&gt;* scope_values) {
2834   if (value != NULL) {
2835     LIR_Opr opr = value-&gt;operand();
2836     Constant* con = value-&gt;as_Constant();
2837 
2838     assert(con == NULL || opr-&gt;is_virtual() || opr-&gt;is_constant() || opr-&gt;is_illegal(), &quot;asumption: Constant instructions have only constant operands (or illegal if constant is optimized away)&quot;);
2839     assert(con != NULL || opr-&gt;is_virtual(), &quot;asumption: non-Constant instructions have only virtual operands&quot;);
2840 
2841     if (con != NULL &amp;&amp; !con-&gt;is_pinned() &amp;&amp; !opr-&gt;is_constant()) {
2842       // Unpinned constants may have a virtual operand for a part of the lifetime
2843       // or may be illegal when it was optimized away,
2844       // so always use a constant operand
2845       opr = LIR_OprFact::value_type(con-&gt;type());
2846     }
2847     assert(opr-&gt;is_virtual() || opr-&gt;is_constant(), &quot;other cases not allowed here&quot;);
2848 
2849     if (opr-&gt;is_virtual()) {
2850       LIR_OpVisitState::OprMode mode = LIR_OpVisitState::inputMode;
2851 
2852       BlockBegin* block = block_of_op_with_id(op_id);
2853       if (block-&gt;number_of_sux() == 1 &amp;&amp; op_id == block-&gt;last_lir_instruction_id()) {
2854         // generating debug information for the last instruction of a block.
2855         // if this instruction is a branch, spill moves are inserted before this branch
2856         // and so the wrong operand would be returned (spill moves at block boundaries are not
2857         // considered in the live ranges of intervals)
2858         // Solution: use the first op_id of the branch target block instead.
2859         if (block-&gt;lir()-&gt;instructions_list()-&gt;last()-&gt;as_OpBranch() != NULL) {
2860           if (block-&gt;live_out().at(opr-&gt;vreg_number())) {
2861             op_id = block-&gt;sux_at(0)-&gt;first_lir_instruction_id();
2862             mode = LIR_OpVisitState::outputMode;
2863           }
2864         }
2865       }
2866 
2867       // Get current location of operand
2868       // The operand must be live because debug information is considered when building the intervals
2869       // if the interval is not live, color_lir_opr will cause an assertion failure
2870       opr = color_lir_opr(opr, op_id, mode);
2871       assert(!has_call(op_id) || opr-&gt;is_stack() || !is_caller_save(reg_num(opr)), &quot;can not have caller-save register operands at calls&quot;);
2872 
2873       // Append to ScopeValue array
2874       return append_scope_value_for_operand(opr, scope_values);
2875 
2876     } else {
2877       assert(value-&gt;as_Constant() != NULL, &quot;all other instructions have only virtual operands&quot;);
2878       assert(opr-&gt;is_constant(), &quot;operand must be constant&quot;);
2879 
2880       return append_scope_value_for_constant(opr, scope_values);
2881     }
2882   } else {
2883     // append a dummy value because real value not needed
2884     scope_values-&gt;append(_illegal_value);
2885     return 1;
2886   }
2887 }
2888 
2889 
2890 IRScopeDebugInfo* LinearScan::compute_debug_info_for_scope(int op_id, IRScope* cur_scope, ValueStack* cur_state, ValueStack* innermost_state) {
2891   IRScopeDebugInfo* caller_debug_info = NULL;
2892 
2893   ValueStack* caller_state = cur_state-&gt;caller_state();
2894   if (caller_state != NULL) {
2895     // process recursively to compute outermost scope first
2896     caller_debug_info = compute_debug_info_for_scope(op_id, cur_scope-&gt;caller(), caller_state, innermost_state);
2897   }
2898 
2899   // initialize these to null.
2900   // If we don&#39;t need deopt info or there are no locals, expressions or monitors,
2901   // then these get recorded as no information and avoids the allocation of 0 length arrays.
2902   GrowableArray&lt;ScopeValue*&gt;*   locals      = NULL;
2903   GrowableArray&lt;ScopeValue*&gt;*   expressions = NULL;
2904   GrowableArray&lt;MonitorValue*&gt;* monitors    = NULL;
2905 
2906   // describe local variable values
2907   int nof_locals = cur_state-&gt;locals_size();
2908   if (nof_locals &gt; 0) {
2909     locals = new GrowableArray&lt;ScopeValue*&gt;(nof_locals);
2910 
2911     int pos = 0;
2912     while (pos &lt; nof_locals) {
2913       assert(pos &lt; cur_state-&gt;locals_size(), &quot;why not?&quot;);
2914 
2915       Value local = cur_state-&gt;local_at(pos);
2916       pos += append_scope_value(op_id, local, locals);
2917 
2918       assert(locals-&gt;length() == pos, &quot;must match&quot;);
2919     }
2920     assert(locals-&gt;length() == cur_scope-&gt;method()-&gt;max_locals(), &quot;wrong number of locals&quot;);
2921     assert(locals-&gt;length() == cur_state-&gt;locals_size(), &quot;wrong number of locals&quot;);
2922   } else if (cur_scope-&gt;method()-&gt;max_locals() &gt; 0) {
2923     assert(cur_state-&gt;kind() == ValueStack::EmptyExceptionState, &quot;should be&quot;);
2924     nof_locals = cur_scope-&gt;method()-&gt;max_locals();
2925     locals = new GrowableArray&lt;ScopeValue*&gt;(nof_locals);
2926     for(int i = 0; i &lt; nof_locals; i++) {
2927       locals-&gt;append(_illegal_value);
2928     }
2929   }
2930 
2931   // describe expression stack
2932   int nof_stack = cur_state-&gt;stack_size();
2933   if (nof_stack &gt; 0) {
2934     expressions = new GrowableArray&lt;ScopeValue*&gt;(nof_stack);
2935 
2936     int pos = 0;
2937     while (pos &lt; nof_stack) {
2938       Value expression = cur_state-&gt;stack_at_inc(pos);
2939       append_scope_value(op_id, expression, expressions);
2940 
2941       assert(expressions-&gt;length() == pos, &quot;must match&quot;);
2942     }
2943     assert(expressions-&gt;length() == cur_state-&gt;stack_size(), &quot;wrong number of stack entries&quot;);
2944   }
2945 
2946   // describe monitors
2947   int nof_locks = cur_state-&gt;locks_size();
2948   if (nof_locks &gt; 0) {
2949     int lock_offset = cur_state-&gt;caller_state() != NULL ? cur_state-&gt;caller_state()-&gt;total_locks_size() : 0;
2950     monitors = new GrowableArray&lt;MonitorValue*&gt;(nof_locks);
2951     for (int i = 0; i &lt; nof_locks; i++) {
2952       monitors-&gt;append(location_for_monitor_index(lock_offset + i));
2953     }
2954   }
2955 
2956   return new IRScopeDebugInfo(cur_scope, cur_state-&gt;bci(), locals, expressions, monitors, caller_debug_info, cur_state-&gt;should_reexecute());
2957 }
2958 
2959 
2960 void LinearScan::compute_debug_info(CodeEmitInfo* info, int op_id) {
2961   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;creating debug information at op_id %d&quot;, op_id));
2962 
2963   IRScope* innermost_scope = info-&gt;scope();
2964   ValueStack* innermost_state = info-&gt;stack();
2965 
2966   assert(innermost_scope != NULL &amp;&amp; innermost_state != NULL, &quot;why is it missing?&quot;);
2967 
2968   DEBUG_ONLY(check_stack_depth(info, innermost_state-&gt;stack_size()));
2969 
2970   if (info-&gt;_scope_debug_info == NULL) {
2971     // compute debug information
2972     info-&gt;_scope_debug_info = compute_debug_info_for_scope(op_id, innermost_scope, innermost_state, innermost_state);
2973   } else {
2974     // debug information already set. Check that it is correct from the current point of view
2975     DEBUG_ONLY(assert_equal(info-&gt;_scope_debug_info, compute_debug_info_for_scope(op_id, innermost_scope, innermost_state, innermost_state)));
2976   }
2977 }
2978 
2979 
2980 void LinearScan::assign_reg_num(LIR_OpList* instructions, IntervalWalker* iw) {
2981   LIR_OpVisitState visitor;
2982   int num_inst = instructions-&gt;length();
2983   bool has_dead = false;
2984 
2985   for (int j = 0; j &lt; num_inst; j++) {
2986     LIR_Op* op = instructions-&gt;at(j);
2987     if (op == NULL) {  // this can happen when spill-moves are removed in eliminate_spill_moves
2988       has_dead = true;
2989       continue;
2990     }
2991     int op_id = op-&gt;id();
2992 
2993     // visit instruction to get list of operands
2994     visitor.visit(op);
2995 
2996     // iterate all modes of the visitor and process all virtual operands
2997     for_each_visitor_mode(mode) {
2998       int n = visitor.opr_count(mode);
2999       for (int k = 0; k &lt; n; k++) {
3000         LIR_Opr opr = visitor.opr_at(mode, k);
3001         if (opr-&gt;is_virtual_register()) {
3002           visitor.set_opr_at(mode, k, color_lir_opr(opr, op_id, mode));
3003         }
3004       }
3005     }
3006 
3007     if (visitor.info_count() &gt; 0) {
3008       // exception handling
3009       if (compilation()-&gt;has_exception_handlers()) {
3010         XHandlers* xhandlers = visitor.all_xhandler();
3011         int n = xhandlers-&gt;length();
3012         for (int k = 0; k &lt; n; k++) {
3013           XHandler* handler = xhandlers-&gt;handler_at(k);
3014           if (handler-&gt;entry_code() != NULL) {
3015             assign_reg_num(handler-&gt;entry_code()-&gt;instructions_list(), NULL);
3016           }
3017         }
3018       } else {
3019         assert(visitor.all_xhandler()-&gt;length() == 0, &quot;missed exception handler&quot;);
3020       }
3021 
3022       // compute oop map
3023       assert(iw != NULL, &quot;needed for compute_oop_map&quot;);
3024       compute_oop_map(iw, visitor, op);
3025 
3026       // compute debug information
3027       if (!use_fpu_stack_allocation()) {
3028         // compute debug information if fpu stack allocation is not needed.
3029         // when fpu stack allocation is needed, the debug information can not
3030         // be computed here because the exact location of fpu operands is not known
3031         // -&gt; debug information is created inside the fpu stack allocator
3032         int n = visitor.info_count();
3033         for (int k = 0; k &lt; n; k++) {
3034           compute_debug_info(visitor.info_at(k), op_id);
3035         }
3036       }
3037     }
3038 
3039 #ifdef ASSERT
3040     // make sure we haven&#39;t made the op invalid.
3041     op-&gt;verify();
3042 #endif
3043 
3044     // remove useless moves
3045     if (op-&gt;code() == lir_move) {
3046       assert(op-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
3047       LIR_Op1* move = (LIR_Op1*)op;
3048       LIR_Opr src = move-&gt;in_opr();
3049       LIR_Opr dst = move-&gt;result_opr();
3050       if (dst == src ||
3051           (!dst-&gt;is_pointer() &amp;&amp; !src-&gt;is_pointer() &amp;&amp;
3052            src-&gt;is_same_register(dst))) {
3053         instructions-&gt;at_put(j, NULL);
3054         has_dead = true;
3055       }
3056     }
3057   }
3058 
3059   if (has_dead) {
3060     // iterate all instructions of the block and remove all null-values.
3061     int insert_point = 0;
3062     for (int j = 0; j &lt; num_inst; j++) {
3063       LIR_Op* op = instructions-&gt;at(j);
3064       if (op != NULL) {
3065         if (insert_point != j) {
3066           instructions-&gt;at_put(insert_point, op);
3067         }
3068         insert_point++;
3069       }
3070     }
3071     instructions-&gt;trunc_to(insert_point);
3072   }
3073 }
3074 
3075 void LinearScan::assign_reg_num() {
3076   TIME_LINEAR_SCAN(timer_assign_reg_num);
3077 
3078   init_compute_debug_info();
3079   IntervalWalker* iw = init_compute_oop_maps();
3080 
3081   int num_blocks = block_count();
3082   for (int i = 0; i &lt; num_blocks; i++) {
3083     BlockBegin* block = block_at(i);
3084     assign_reg_num(block-&gt;lir()-&gt;instructions_list(), iw);
3085   }
3086 }
3087 
3088 
3089 void LinearScan::do_linear_scan() {
3090   NOT_PRODUCT(_total_timer.begin_method());
3091 
3092   number_instructions();
3093 
3094   NOT_PRODUCT(print_lir(1, &quot;Before Register Allocation&quot;));
3095 
3096   compute_local_live_sets();
3097   compute_global_live_sets();
3098   CHECK_BAILOUT();
3099 
3100   build_intervals();
3101   CHECK_BAILOUT();
3102   sort_intervals_before_allocation();
3103 
3104   NOT_PRODUCT(print_intervals(&quot;Before Register Allocation&quot;));
3105   NOT_PRODUCT(LinearScanStatistic::compute(this, _stat_before_alloc));
3106 
3107   allocate_registers();
3108   CHECK_BAILOUT();
3109 
3110   resolve_data_flow();
3111   if (compilation()-&gt;has_exception_handlers()) {
3112     resolve_exception_handlers();
3113   }
3114   // fill in number of spill slots into frame_map
3115   propagate_spill_slots();
3116   CHECK_BAILOUT();
3117 
3118   NOT_PRODUCT(print_intervals(&quot;After Register Allocation&quot;));
3119   NOT_PRODUCT(print_lir(2, &quot;LIR after register allocation:&quot;));
3120 
3121   sort_intervals_after_allocation();
3122 
3123   DEBUG_ONLY(verify());
3124 
3125   eliminate_spill_moves();
3126   assign_reg_num();
3127   CHECK_BAILOUT();
3128 
3129   NOT_PRODUCT(print_lir(2, &quot;LIR after assignment of register numbers:&quot;));
3130   NOT_PRODUCT(LinearScanStatistic::compute(this, _stat_after_asign));
3131 
3132   { TIME_LINEAR_SCAN(timer_allocate_fpu_stack);
3133 
3134     if (use_fpu_stack_allocation()) {
3135       allocate_fpu_stack(); // Only has effect on Intel
3136       NOT_PRODUCT(print_lir(2, &quot;LIR after FPU stack allocation:&quot;));
3137     }
3138   }
3139 
3140   { TIME_LINEAR_SCAN(timer_optimize_lir);
3141 
3142     EdgeMoveOptimizer::optimize(ir()-&gt;code());
3143     ControlFlowOptimizer::optimize(ir()-&gt;code());
3144     // check that cfg is still correct after optimizations
3145     ir()-&gt;verify();
3146   }
3147 
3148   NOT_PRODUCT(print_lir(1, &quot;Before Code Generation&quot;, false));
3149   NOT_PRODUCT(LinearScanStatistic::compute(this, _stat_final));
3150   NOT_PRODUCT(_total_timer.end_method(this));
3151 }
3152 
3153 
3154 // ********** Printing functions
3155 
3156 #ifndef PRODUCT
3157 
3158 void LinearScan::print_timers(double total) {
3159   _total_timer.print(total);
3160 }
3161 
3162 void LinearScan::print_statistics() {
3163   _stat_before_alloc.print(&quot;before allocation&quot;);
3164   _stat_after_asign.print(&quot;after assignment of register&quot;);
3165   _stat_final.print(&quot;after optimization&quot;);
3166 }
3167 
3168 void LinearScan::print_bitmap(BitMap&amp; b) {
3169   for (unsigned int i = 0; i &lt; b.size(); i++) {
3170     if (b.at(i)) tty-&gt;print(&quot;%d &quot;, i);
3171   }
3172   tty-&gt;cr();
3173 }
3174 
3175 void LinearScan::print_intervals(const char* label) {
3176   if (TraceLinearScanLevel &gt;= 1) {
3177     int i;
3178     tty-&gt;cr();
3179     tty-&gt;print_cr(&quot;%s&quot;, label);
3180 
3181     for (i = 0; i &lt; interval_count(); i++) {
3182       Interval* interval = interval_at(i);
3183       if (interval != NULL) {
3184         interval-&gt;print();
3185       }
3186     }
3187 
3188     tty-&gt;cr();
3189     tty-&gt;print_cr(&quot;--- Basic Blocks ---&quot;);
3190     for (i = 0; i &lt; block_count(); i++) {
3191       BlockBegin* block = block_at(i);
3192       tty-&gt;print(&quot;B%d [%d, %d, %d, %d] &quot;, block-&gt;block_id(), block-&gt;first_lir_instruction_id(), block-&gt;last_lir_instruction_id(), block-&gt;loop_index(), block-&gt;loop_depth());
3193     }
3194     tty-&gt;cr();
3195     tty-&gt;cr();
3196   }
3197 
3198   if (PrintCFGToFile) {
3199     CFGPrinter::print_intervals(&amp;_intervals, label);
3200   }
3201 }
3202 
3203 void LinearScan::print_lir(int level, const char* label, bool hir_valid) {
3204   if (TraceLinearScanLevel &gt;= level) {
3205     tty-&gt;cr();
3206     tty-&gt;print_cr(&quot;%s&quot;, label);
3207     print_LIR(ir()-&gt;linear_scan_order());
3208     tty-&gt;cr();
3209   }
3210 
3211   if (level == 1 &amp;&amp; PrintCFGToFile) {
3212     CFGPrinter::print_cfg(ir()-&gt;linear_scan_order(), label, hir_valid, true);
3213   }
3214 }
3215 
3216 #endif //PRODUCT
3217 
3218 
3219 // ********** verification functions for allocation
3220 // (check that all intervals have a correct register and that no registers are overwritten)
3221 #ifdef ASSERT
3222 
3223 void LinearScan::verify() {
3224   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying intervals ******************************************&quot;));
3225   verify_intervals();
3226 
3227   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying that no oops are in fixed intervals ****************&quot;));
3228   verify_no_oops_in_fixed_intervals();
3229 
3230   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying that unpinned constants are not alive across block boundaries&quot;));
3231   verify_constants();
3232 
3233   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying register allocation ********************************&quot;));
3234   verify_registers();
3235 
3236   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* no errors found **********************************************&quot;));
3237 }
3238 
3239 void LinearScan::verify_intervals() {
3240   int len = interval_count();
3241   bool has_error = false;
3242 
3243   for (int i = 0; i &lt; len; i++) {
3244     Interval* i1 = interval_at(i);
3245     if (i1 == NULL) continue;
3246 
3247     i1-&gt;check_split_children();
3248 
3249     if (i1-&gt;reg_num() != i) {
3250       tty-&gt;print_cr(&quot;Interval %d is on position %d in list&quot;, i1-&gt;reg_num(), i); i1-&gt;print(); tty-&gt;cr();
3251       has_error = true;
3252     }
3253 
3254     if (i1-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base &amp;&amp; i1-&gt;type() == T_ILLEGAL) {
3255       tty-&gt;print_cr(&quot;Interval %d has no type assigned&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3256       has_error = true;
3257     }
3258 
3259     if (i1-&gt;assigned_reg() == any_reg) {
3260       tty-&gt;print_cr(&quot;Interval %d has no register assigned&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3261       has_error = true;
3262     }
3263 
3264     if (i1-&gt;assigned_reg() == i1-&gt;assigned_regHi()) {
3265       tty-&gt;print_cr(&quot;Interval %d: low and high register equal&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3266       has_error = true;
3267     }
3268 
3269     if (!is_processed_reg_num(i1-&gt;assigned_reg())) {
3270       tty-&gt;print_cr(&quot;Can not have an Interval for an ignored register&quot;); i1-&gt;print(); tty-&gt;cr();
3271       has_error = true;
3272     }
3273 
3274     // special intervals that are created in MoveResolver
3275     // -&gt; ignore them because the range information has no meaning there
3276     if (i1-&gt;from() == 1 &amp;&amp; i1-&gt;to() == 2) continue;
3277 
3278     if (i1-&gt;first() == Range::end()) {
3279       tty-&gt;print_cr(&quot;Interval %d has no Range&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3280       has_error = true;
3281     }
3282 
3283     for (Range* r = i1-&gt;first(); r != Range::end(); r = r-&gt;next()) {
3284       if (r-&gt;from() &gt;= r-&gt;to()) {
3285         tty-&gt;print_cr(&quot;Interval %d has zero length range&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3286         has_error = true;
3287       }
3288     }
3289 
3290     for (int j = i + 1; j &lt; len; j++) {
3291       Interval* i2 = interval_at(j);
3292       if (i2 == NULL || (i2-&gt;from() == 1 &amp;&amp; i2-&gt;to() == 2)) continue;
3293 
3294       int r1 = i1-&gt;assigned_reg();
3295       int r1Hi = i1-&gt;assigned_regHi();
3296       int r2 = i2-&gt;assigned_reg();
3297       int r2Hi = i2-&gt;assigned_regHi();
3298       if ((r1 == r2 || r1 == r2Hi || (r1Hi != any_reg &amp;&amp; (r1Hi == r2 || r1Hi == r2Hi))) &amp;&amp; i1-&gt;intersects(i2)) {
3299         tty-&gt;print_cr(&quot;Intervals %d and %d overlap and have the same register assigned&quot;, i1-&gt;reg_num(), i2-&gt;reg_num());
3300         i1-&gt;print(); tty-&gt;cr();
3301         i2-&gt;print(); tty-&gt;cr();
3302         has_error = true;
3303       }
3304     }
3305   }
3306 
3307   assert(has_error == false, &quot;register allocation invalid&quot;);
3308 }
3309 
3310 
3311 void LinearScan::verify_no_oops_in_fixed_intervals() {
3312   Interval* fixed_intervals;
3313   Interval* other_intervals;
3314   create_unhandled_lists(&amp;fixed_intervals, &amp;other_intervals, is_precolored_cpu_interval, NULL);
3315 
3316   // to ensure a walking until the last instruction id, add a dummy interval
3317   // with a high operation id
3318   other_intervals = new Interval(any_reg);
3319   other_intervals-&gt;add_range(max_jint - 2, max_jint - 1);
3320   IntervalWalker* iw = new IntervalWalker(this, fixed_intervals, other_intervals);
3321 
3322   LIR_OpVisitState visitor;
3323   for (int i = 0; i &lt; block_count(); i++) {
3324     BlockBegin* block = block_at(i);
3325 
3326     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
3327 
3328     for (int j = 0; j &lt; instructions-&gt;length(); j++) {
3329       LIR_Op* op = instructions-&gt;at(j);
3330       int op_id = op-&gt;id();
3331 
3332       visitor.visit(op);
3333 
3334       if (visitor.info_count() &gt; 0) {
3335         iw-&gt;walk_before(op-&gt;id());
3336         bool check_live = true;
3337         if (op-&gt;code() == lir_move) {
3338           LIR_Op1* move = (LIR_Op1*)op;
3339           check_live = (move-&gt;patch_code() == lir_patch_none);
3340         }
3341         LIR_OpBranch* branch = op-&gt;as_OpBranch();
3342         if (branch != NULL &amp;&amp; branch-&gt;stub() != NULL &amp;&amp; branch-&gt;stub()-&gt;is_exception_throw_stub()) {
3343           // Don&#39;t bother checking the stub in this case since the
3344           // exception stub will never return to normal control flow.
3345           check_live = false;
3346         }
3347 
3348         // Make sure none of the fixed registers is live across an
3349         // oopmap since we can&#39;t handle that correctly.
3350         if (check_live) {
3351           for (Interval* interval = iw-&gt;active_first(fixedKind);
3352                interval != Interval::end();
3353                interval = interval-&gt;next()) {
3354             if (interval-&gt;current_to() &gt; op-&gt;id() + 1) {
3355               // This interval is live out of this op so make sure
3356               // that this interval represents some value that&#39;s
3357               // referenced by this op either as an input or output.
3358               bool ok = false;
3359               for_each_visitor_mode(mode) {
3360                 int n = visitor.opr_count(mode);
3361                 for (int k = 0; k &lt; n; k++) {
3362                   LIR_Opr opr = visitor.opr_at(mode, k);
3363                   if (opr-&gt;is_fixed_cpu()) {
3364                     if (interval_at(reg_num(opr)) == interval) {
3365                       ok = true;
3366                       break;
3367                     }
3368                     int hi = reg_numHi(opr);
3369                     if (hi != -1 &amp;&amp; interval_at(hi) == interval) {
3370                       ok = true;
3371                       break;
3372                     }
3373                   }
3374                 }
3375               }
3376               assert(ok, &quot;fixed intervals should never be live across an oopmap point&quot;);
3377             }
3378           }
3379         }
3380       }
3381 
3382       // oop-maps at calls do not contain registers, so check is not needed
3383       if (!visitor.has_call()) {
3384 
3385         for_each_visitor_mode(mode) {
3386           int n = visitor.opr_count(mode);
3387           for (int k = 0; k &lt; n; k++) {
3388             LIR_Opr opr = visitor.opr_at(mode, k);
3389 
3390             if (opr-&gt;is_fixed_cpu() &amp;&amp; opr-&gt;is_oop()) {
3391               // operand is a non-virtual cpu register and contains an oop
3392               TRACE_LINEAR_SCAN(4, op-&gt;print_on(tty); tty-&gt;print(&quot;checking operand &quot;); opr-&gt;print(); tty-&gt;cr());
3393 
3394               Interval* interval = interval_at(reg_num(opr));
3395               assert(interval != NULL, &quot;no interval&quot;);
3396 
3397               if (mode == LIR_OpVisitState::inputMode) {
3398                 if (interval-&gt;to() &gt;= op_id + 1) {
3399                   assert(interval-&gt;to() &lt; op_id + 2 ||
3400                          interval-&gt;has_hole_between(op_id, op_id + 2),
3401                          &quot;oop input operand live after instruction&quot;);
3402                 }
3403               } else if (mode == LIR_OpVisitState::outputMode) {
3404                 if (interval-&gt;from() &lt;= op_id - 1) {
3405                   assert(interval-&gt;has_hole_between(op_id - 1, op_id),
3406                          &quot;oop input operand live after instruction&quot;);
3407                 }
3408               }
3409             }
3410           }
3411         }
3412       }
3413     }
3414   }
3415 }
3416 
3417 
3418 void LinearScan::verify_constants() {
3419   int num_regs = num_virtual_regs();
3420   int size = live_set_size();
3421   int num_blocks = block_count();
3422 
3423   for (int i = 0; i &lt; num_blocks; i++) {
3424     BlockBegin* block = block_at(i);
3425     ResourceBitMap live_at_edge = block-&gt;live_in();
3426 
3427     // visit all registers where the live_at_edge bit is set
3428     for (int r = (int)live_at_edge.get_next_one_offset(0, size); r &lt; size; r = (int)live_at_edge.get_next_one_offset(r + 1, size)) {
3429       TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;checking interval %d of block B%d&quot;, r, block-&gt;block_id()));
3430 
3431       Value value = gen()-&gt;instruction_for_vreg(r);
3432 
3433       assert(value != NULL, &quot;all intervals live across block boundaries must have Value&quot;);
3434       assert(value-&gt;operand()-&gt;is_register() &amp;&amp; value-&gt;operand()-&gt;is_virtual(), &quot;value must have virtual operand&quot;);
3435       assert(value-&gt;operand()-&gt;vreg_number() == r, &quot;register number must match&quot;);
3436       // TKR assert(value-&gt;as_Constant() == NULL || value-&gt;is_pinned(), &quot;only pinned constants can be alive accross block boundaries&quot;);
3437     }
3438   }
3439 }
3440 
3441 
3442 class RegisterVerifier: public StackObj {
3443  private:
3444   LinearScan*   _allocator;
3445   BlockList     _work_list;      // all blocks that must be processed
3446   IntervalsList _saved_states;   // saved information of previous check
3447 
3448   // simplified access to methods of LinearScan
3449   Compilation*  compilation() const              { return _allocator-&gt;compilation(); }
3450   Interval*     interval_at(int reg_num) const   { return _allocator-&gt;interval_at(reg_num); }
3451   int           reg_num(LIR_Opr opr) const       { return _allocator-&gt;reg_num(opr); }
3452 
3453   // currently, only registers are processed
3454   int           state_size()                     { return LinearScan::nof_regs; }
3455 
3456   // accessors
3457   IntervalList* state_for_block(BlockBegin* block) { return _saved_states.at(block-&gt;block_id()); }
3458   void          set_state_for_block(BlockBegin* block, IntervalList* saved_state) { _saved_states.at_put(block-&gt;block_id(), saved_state); }
3459   void          add_to_work_list(BlockBegin* block) { if (!_work_list.contains(block)) _work_list.append(block); }
3460 
3461   // helper functions
3462   IntervalList* copy(IntervalList* input_state);
3463   void          state_put(IntervalList* input_state, int reg, Interval* interval);
3464   bool          check_state(IntervalList* input_state, int reg, Interval* interval);
3465 
3466   void process_block(BlockBegin* block);
3467   void process_xhandler(XHandler* xhandler, IntervalList* input_state);
3468   void process_successor(BlockBegin* block, IntervalList* input_state);
3469   void process_operations(LIR_List* ops, IntervalList* input_state);
3470 
3471  public:
3472   RegisterVerifier(LinearScan* allocator)
3473     : _allocator(allocator)
3474     , _work_list(16)
3475     , _saved_states(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), NULL)
3476   { }
3477 
3478   void verify(BlockBegin* start);
3479 };
3480 
3481 
3482 // entry function from LinearScan that starts the verification
3483 void LinearScan::verify_registers() {
3484   RegisterVerifier verifier(this);
3485   verifier.verify(block_at(0));
3486 }
3487 
3488 
3489 void RegisterVerifier::verify(BlockBegin* start) {
3490   // setup input registers (method arguments) for first block
3491   int input_state_len = state_size();
3492   IntervalList* input_state = new IntervalList(input_state_len, input_state_len, NULL);
3493   CallingConvention* args = compilation()-&gt;frame_map()-&gt;incoming_arguments();
3494   for (int n = 0; n &lt; args-&gt;length(); n++) {
3495     LIR_Opr opr = args-&gt;at(n);
3496     if (opr-&gt;is_register()) {
3497       Interval* interval = interval_at(reg_num(opr));
3498 
3499       if (interval-&gt;assigned_reg() &lt; state_size()) {
3500         input_state-&gt;at_put(interval-&gt;assigned_reg(), interval);
3501       }
3502       if (interval-&gt;assigned_regHi() != LinearScan::any_reg &amp;&amp; interval-&gt;assigned_regHi() &lt; state_size()) {
3503         input_state-&gt;at_put(interval-&gt;assigned_regHi(), interval);
3504       }
3505     }
3506   }
3507 
3508   set_state_for_block(start, input_state);
3509   add_to_work_list(start);
3510 
3511   // main loop for verification
3512   do {
3513     BlockBegin* block = _work_list.at(0);
3514     _work_list.remove_at(0);
3515 
3516     process_block(block);
3517   } while (!_work_list.is_empty());
3518 }
3519 
3520 void RegisterVerifier::process_block(BlockBegin* block) {
3521   TRACE_LINEAR_SCAN(2, tty-&gt;cr(); tty-&gt;print_cr(&quot;process_block B%d&quot;, block-&gt;block_id()));
3522 
3523   // must copy state because it is modified
3524   IntervalList* input_state = copy(state_for_block(block));
3525 
3526   if (TraceLinearScanLevel &gt;= 4) {
3527     tty-&gt;print_cr(&quot;Input-State of intervals:&quot;);
3528     tty-&gt;print(&quot;    &quot;);
3529     for (int i = 0; i &lt; state_size(); i++) {
3530       if (input_state-&gt;at(i) != NULL) {
3531         tty-&gt;print(&quot; %4d&quot;, input_state-&gt;at(i)-&gt;reg_num());
3532       } else {
3533         tty-&gt;print(&quot;   __&quot;);
3534       }
3535     }
3536     tty-&gt;cr();
3537     tty-&gt;cr();
3538   }
3539 
3540   // process all operations of the block
3541   process_operations(block-&gt;lir(), input_state);
3542 
3543   // iterate all successors
3544   for (int i = 0; i &lt; block-&gt;number_of_sux(); i++) {
3545     process_successor(block-&gt;sux_at(i), input_state);
3546   }
3547 }
3548 
3549 void RegisterVerifier::process_xhandler(XHandler* xhandler, IntervalList* input_state) {
3550   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_xhandler B%d&quot;, xhandler-&gt;entry_block()-&gt;block_id()));
3551 
3552   // must copy state because it is modified
3553   input_state = copy(input_state);
3554 
3555   if (xhandler-&gt;entry_code() != NULL) {
3556     process_operations(xhandler-&gt;entry_code(), input_state);
3557   }
3558   process_successor(xhandler-&gt;entry_block(), input_state);
3559 }
3560 
3561 void RegisterVerifier::process_successor(BlockBegin* block, IntervalList* input_state) {
3562   IntervalList* saved_state = state_for_block(block);
3563 
3564   if (saved_state != NULL) {
3565     // this block was already processed before.
3566     // check if new input_state is consistent with saved_state
3567 
3568     bool saved_state_correct = true;
3569     for (int i = 0; i &lt; state_size(); i++) {
3570       if (input_state-&gt;at(i) != saved_state-&gt;at(i)) {
3571         // current input_state and previous saved_state assume a different
3572         // interval in this register -&gt; assume that this register is invalid
3573         if (saved_state-&gt;at(i) != NULL) {
3574           // invalidate old calculation only if it assumed that
3575           // register was valid. when the register was already invalid,
3576           // then the old calculation was correct.
3577           saved_state_correct = false;
3578           saved_state-&gt;at_put(i, NULL);
3579 
3580           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;process_successor B%d: invalidating slot %d&quot;, block-&gt;block_id(), i));
3581         }
3582       }
3583     }
3584 
3585     if (saved_state_correct) {
3586       // already processed block with correct input_state
3587       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_successor B%d: previous visit already correct&quot;, block-&gt;block_id()));
3588     } else {
3589       // must re-visit this block
3590       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_successor B%d: must re-visit because input state changed&quot;, block-&gt;block_id()));
3591       add_to_work_list(block);
3592     }
3593 
3594   } else {
3595     // block was not processed before, so set initial input_state
3596     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_successor B%d: initial visit&quot;, block-&gt;block_id()));
3597 
3598     set_state_for_block(block, copy(input_state));
3599     add_to_work_list(block);
3600   }
3601 }
3602 
3603 
3604 IntervalList* RegisterVerifier::copy(IntervalList* input_state) {
3605   IntervalList* copy_state = new IntervalList(input_state-&gt;length());
3606   copy_state-&gt;appendAll(input_state);
3607   return copy_state;
3608 }
3609 
3610 void RegisterVerifier::state_put(IntervalList* input_state, int reg, Interval* interval) {
3611   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; state_size()) {
3612     if (interval != NULL) {
3613       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;        reg[%d] = %d&quot;, reg, interval-&gt;reg_num()));
3614     } else if (input_state-&gt;at(reg) != NULL) {
3615       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;        reg[%d] = NULL&quot;, reg));
3616     }
3617 
3618     input_state-&gt;at_put(reg, interval);
3619   }
3620 }
3621 
3622 bool RegisterVerifier::check_state(IntervalList* input_state, int reg, Interval* interval) {
3623   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; state_size()) {
3624     if (input_state-&gt;at(reg) != interval) {
3625       tty-&gt;print_cr(&quot;!! Error in register allocation: register %d does not contain interval %d&quot;, reg, interval-&gt;reg_num());
3626       return true;
3627     }
3628   }
3629   return false;
3630 }
3631 
3632 void RegisterVerifier::process_operations(LIR_List* ops, IntervalList* input_state) {
3633   // visit all instructions of the block
3634   LIR_OpVisitState visitor;
3635   bool has_error = false;
3636 
3637   for (int i = 0; i &lt; ops-&gt;length(); i++) {
3638     LIR_Op* op = ops-&gt;at(i);
3639     visitor.visit(op);
3640 
3641     TRACE_LINEAR_SCAN(4, op-&gt;print_on(tty));
3642 
3643     // check if input operands are correct
3644     int j;
3645     int n = visitor.opr_count(LIR_OpVisitState::inputMode);
3646     for (j = 0; j &lt; n; j++) {
3647       LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::inputMode, j);
3648       if (opr-&gt;is_register() &amp;&amp; LinearScan::is_processed_reg_num(reg_num(opr))) {
3649         Interval* interval = interval_at(reg_num(opr));
3650         if (op-&gt;id() != -1) {
3651           interval = interval-&gt;split_child_at_op_id(op-&gt;id(), LIR_OpVisitState::inputMode);
3652         }
3653 
3654         has_error |= check_state(input_state, interval-&gt;assigned_reg(),   interval-&gt;split_parent());
3655         has_error |= check_state(input_state, interval-&gt;assigned_regHi(), interval-&gt;split_parent());
3656 
3657         // When an operand is marked with is_last_use, then the fpu stack allocator
3658         // removes the register from the fpu stack -&gt; the register contains no value
3659         if (opr-&gt;is_last_use()) {
3660           state_put(input_state, interval-&gt;assigned_reg(),   NULL);
3661           state_put(input_state, interval-&gt;assigned_regHi(), NULL);
3662         }
3663       }
3664     }
3665 
3666     // invalidate all caller save registers at calls
3667     if (visitor.has_call()) {
3668       for (j = 0; j &lt; FrameMap::nof_caller_save_cpu_regs(); j++) {
3669         state_put(input_state, reg_num(FrameMap::caller_save_cpu_reg_at(j)), NULL);
3670       }
3671       for (j = 0; j &lt; FrameMap::nof_caller_save_fpu_regs; j++) {
3672         state_put(input_state, reg_num(FrameMap::caller_save_fpu_reg_at(j)), NULL);
3673       }
3674 
3675 #ifdef X86
3676       int num_caller_save_xmm_regs = FrameMap::get_num_caller_save_xmms();
3677       for (j = 0; j &lt; num_caller_save_xmm_regs; j++) {
3678         state_put(input_state, reg_num(FrameMap::caller_save_xmm_reg_at(j)), NULL);
3679       }
3680 #endif
3681     }
3682 
3683     // process xhandler before output and temp operands
3684     XHandlers* xhandlers = visitor.all_xhandler();
3685     n = xhandlers-&gt;length();
3686     for (int k = 0; k &lt; n; k++) {
3687       process_xhandler(xhandlers-&gt;handler_at(k), input_state);
3688     }
3689 
3690     // set temp operands (some operations use temp operands also as output operands, so can&#39;t set them NULL)
3691     n = visitor.opr_count(LIR_OpVisitState::tempMode);
3692     for (j = 0; j &lt; n; j++) {
3693       LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::tempMode, j);
3694       if (opr-&gt;is_register() &amp;&amp; LinearScan::is_processed_reg_num(reg_num(opr))) {
3695         Interval* interval = interval_at(reg_num(opr));
3696         if (op-&gt;id() != -1) {
3697           interval = interval-&gt;split_child_at_op_id(op-&gt;id(), LIR_OpVisitState::tempMode);
3698         }
3699 
3700         state_put(input_state, interval-&gt;assigned_reg(),   interval-&gt;split_parent());
3701         state_put(input_state, interval-&gt;assigned_regHi(), interval-&gt;split_parent());
3702       }
3703     }
3704 
3705     // set output operands
3706     n = visitor.opr_count(LIR_OpVisitState::outputMode);
3707     for (j = 0; j &lt; n; j++) {
3708       LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::outputMode, j);
3709       if (opr-&gt;is_register() &amp;&amp; LinearScan::is_processed_reg_num(reg_num(opr))) {
3710         Interval* interval = interval_at(reg_num(opr));
3711         if (op-&gt;id() != -1) {
3712           interval = interval-&gt;split_child_at_op_id(op-&gt;id(), LIR_OpVisitState::outputMode);
3713         }
3714 
3715         state_put(input_state, interval-&gt;assigned_reg(),   interval-&gt;split_parent());
3716         state_put(input_state, interval-&gt;assigned_regHi(), interval-&gt;split_parent());
3717       }
3718     }
3719   }
3720   assert(has_error == false, &quot;Error in register allocation&quot;);
3721 }
3722 
3723 #endif // ASSERT
3724 
3725 
3726 
3727 // **** Implementation of MoveResolver ******************************
3728 
3729 MoveResolver::MoveResolver(LinearScan* allocator) :
3730   _allocator(allocator),
3731   _insert_list(NULL),
3732   _insert_idx(-1),
3733   _insertion_buffer(),
3734   _mapping_from(8),
3735   _mapping_from_opr(8),
3736   _mapping_to(8),
3737   _multiple_reads_allowed(false)
3738 {
3739   for (int i = 0; i &lt; LinearScan::nof_regs; i++) {
3740     _register_blocked[i] = 0;
3741   }
3742   DEBUG_ONLY(check_empty());
3743 }
3744 
3745 
3746 #ifdef ASSERT
3747 
3748 void MoveResolver::check_empty() {
3749   assert(_mapping_from.length() == 0 &amp;&amp; _mapping_from_opr.length() == 0 &amp;&amp; _mapping_to.length() == 0, &quot;list must be empty before and after processing&quot;);
3750   for (int i = 0; i &lt; LinearScan::nof_regs; i++) {
3751     assert(register_blocked(i) == 0, &quot;register map must be empty before and after processing&quot;);
3752   }
3753   assert(_multiple_reads_allowed == false, &quot;must have default value&quot;);
3754 }
3755 
3756 void MoveResolver::verify_before_resolve() {
3757   assert(_mapping_from.length() == _mapping_from_opr.length(), &quot;length must be equal&quot;);
3758   assert(_mapping_from.length() == _mapping_to.length(), &quot;length must be equal&quot;);
3759   assert(_insert_list != NULL &amp;&amp; _insert_idx != -1, &quot;insert position not set&quot;);
3760 
3761   int i, j;
3762   if (!_multiple_reads_allowed) {
3763     for (i = 0; i &lt; _mapping_from.length(); i++) {
3764       for (j = i + 1; j &lt; _mapping_from.length(); j++) {
3765         assert(_mapping_from.at(i) == NULL || _mapping_from.at(i) != _mapping_from.at(j), &quot;cannot read from same interval twice&quot;);
3766       }
3767     }
3768   }
3769 
3770   for (i = 0; i &lt; _mapping_to.length(); i++) {
3771     for (j = i + 1; j &lt; _mapping_to.length(); j++) {
3772       assert(_mapping_to.at(i) != _mapping_to.at(j), &quot;cannot write to same interval twice&quot;);
3773     }
3774   }
3775 
3776 
3777   ResourceBitMap used_regs(LinearScan::nof_regs + allocator()-&gt;frame_map()-&gt;argcount() + allocator()-&gt;max_spills());
3778   if (!_multiple_reads_allowed) {
3779     for (i = 0; i &lt; _mapping_from.length(); i++) {
3780       Interval* it = _mapping_from.at(i);
3781       if (it != NULL) {
3782         assert(!used_regs.at(it-&gt;assigned_reg()), &quot;cannot read from same register twice&quot;);
3783         used_regs.set_bit(it-&gt;assigned_reg());
3784 
3785         if (it-&gt;assigned_regHi() != LinearScan::any_reg) {
3786           assert(!used_regs.at(it-&gt;assigned_regHi()), &quot;cannot read from same register twice&quot;);
3787           used_regs.set_bit(it-&gt;assigned_regHi());
3788         }
3789       }
3790     }
3791   }
3792 
3793   used_regs.clear();
3794   for (i = 0; i &lt; _mapping_to.length(); i++) {
3795     Interval* it = _mapping_to.at(i);
3796     assert(!used_regs.at(it-&gt;assigned_reg()), &quot;cannot write to same register twice&quot;);
3797     used_regs.set_bit(it-&gt;assigned_reg());
3798 
3799     if (it-&gt;assigned_regHi() != LinearScan::any_reg) {
3800       assert(!used_regs.at(it-&gt;assigned_regHi()), &quot;cannot write to same register twice&quot;);
3801       used_regs.set_bit(it-&gt;assigned_regHi());
3802     }
3803   }
3804 
3805   used_regs.clear();
3806   for (i = 0; i &lt; _mapping_from.length(); i++) {
3807     Interval* it = _mapping_from.at(i);
3808     if (it != NULL &amp;&amp; it-&gt;assigned_reg() &gt;= LinearScan::nof_regs) {
3809       used_regs.set_bit(it-&gt;assigned_reg());
3810     }
3811   }
3812   for (i = 0; i &lt; _mapping_to.length(); i++) {
3813     Interval* it = _mapping_to.at(i);
3814     assert(!used_regs.at(it-&gt;assigned_reg()) || it-&gt;assigned_reg() == _mapping_from.at(i)-&gt;assigned_reg(), &quot;stack slots used in _mapping_from must be disjoint to _mapping_to&quot;);
3815   }
3816 }
3817 
3818 #endif // ASSERT
3819 
3820 
3821 // mark assigned_reg and assigned_regHi of the interval as blocked
3822 void MoveResolver::block_registers(Interval* it) {
3823   int reg = it-&gt;assigned_reg();
3824   if (reg &lt; LinearScan::nof_regs) {
3825     assert(_multiple_reads_allowed || register_blocked(reg) == 0, &quot;register already marked as used&quot;);
3826     set_register_blocked(reg, 1);
3827   }
3828   reg = it-&gt;assigned_regHi();
3829   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; LinearScan::nof_regs) {
3830     assert(_multiple_reads_allowed || register_blocked(reg) == 0, &quot;register already marked as used&quot;);
3831     set_register_blocked(reg, 1);
3832   }
3833 }
3834 
3835 // mark assigned_reg and assigned_regHi of the interval as unblocked
3836 void MoveResolver::unblock_registers(Interval* it) {
3837   int reg = it-&gt;assigned_reg();
3838   if (reg &lt; LinearScan::nof_regs) {
3839     assert(register_blocked(reg) &gt; 0, &quot;register already marked as unused&quot;);
3840     set_register_blocked(reg, -1);
3841   }
3842   reg = it-&gt;assigned_regHi();
3843   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; LinearScan::nof_regs) {
3844     assert(register_blocked(reg) &gt; 0, &quot;register already marked as unused&quot;);
3845     set_register_blocked(reg, -1);
3846   }
3847 }
3848 
3849 // check if assigned_reg and assigned_regHi of the to-interval are not blocked (or only blocked by from)
3850 bool MoveResolver::save_to_process_move(Interval* from, Interval* to) {
3851   int from_reg = -1;
3852   int from_regHi = -1;
3853   if (from != NULL) {
3854     from_reg = from-&gt;assigned_reg();
3855     from_regHi = from-&gt;assigned_regHi();
3856   }
3857 
3858   int reg = to-&gt;assigned_reg();
3859   if (reg &lt; LinearScan::nof_regs) {
3860     if (register_blocked(reg) &gt; 1 || (register_blocked(reg) == 1 &amp;&amp; reg != from_reg &amp;&amp; reg != from_regHi)) {
3861       return false;
3862     }
3863   }
3864   reg = to-&gt;assigned_regHi();
3865   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; LinearScan::nof_regs) {
3866     if (register_blocked(reg) &gt; 1 || (register_blocked(reg) == 1 &amp;&amp; reg != from_reg &amp;&amp; reg != from_regHi)) {
3867       return false;
3868     }
3869   }
3870 
3871   return true;
3872 }
3873 
3874 
3875 void MoveResolver::create_insertion_buffer(LIR_List* list) {
3876   assert(!_insertion_buffer.initialized(), &quot;overwriting existing buffer&quot;);
3877   _insertion_buffer.init(list);
3878 }
3879 
3880 void MoveResolver::append_insertion_buffer() {
3881   if (_insertion_buffer.initialized()) {
3882     _insertion_buffer.lir_list()-&gt;append(&amp;_insertion_buffer);
3883   }
3884   assert(!_insertion_buffer.initialized(), &quot;must be uninitialized now&quot;);
3885 
3886   _insert_list = NULL;
3887   _insert_idx = -1;
3888 }
3889 
3890 void MoveResolver::insert_move(Interval* from_interval, Interval* to_interval) {
3891   assert(from_interval-&gt;reg_num() != to_interval-&gt;reg_num(), &quot;from and to interval equal&quot;);
3892   assert(from_interval-&gt;type() == to_interval-&gt;type(), &quot;move between different types&quot;);
3893   assert(_insert_list != NULL &amp;&amp; _insert_idx != -1, &quot;must setup insert position first&quot;);
3894   assert(_insertion_buffer.lir_list() == _insert_list, &quot;wrong insertion buffer&quot;);
3895 
3896   LIR_Opr from_opr = LIR_OprFact::virtual_register(from_interval-&gt;reg_num(), from_interval-&gt;type());
3897   LIR_Opr to_opr = LIR_OprFact::virtual_register(to_interval-&gt;reg_num(), to_interval-&gt;type());
3898 
3899   if (!_multiple_reads_allowed) {
3900     // the last_use flag is an optimization for FPU stack allocation. When the same
3901     // input interval is used in more than one move, then it is too difficult to determine
3902     // if this move is really the last use.
3903     from_opr = from_opr-&gt;make_last_use();
3904   }
3905   _insertion_buffer.move(_insert_idx, from_opr, to_opr);
3906 
3907   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: inserted move from register %d (%d, %d) to %d (%d, %d)&quot;, from_interval-&gt;reg_num(), from_interval-&gt;assigned_reg(), from_interval-&gt;assigned_regHi(), to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
3908 }
3909 
3910 void MoveResolver::insert_move(LIR_Opr from_opr, Interval* to_interval) {
3911   assert(from_opr-&gt;type() == to_interval-&gt;type(), &quot;move between different types&quot;);
3912   assert(_insert_list != NULL &amp;&amp; _insert_idx != -1, &quot;must setup insert position first&quot;);
3913   assert(_insertion_buffer.lir_list() == _insert_list, &quot;wrong insertion buffer&quot;);
3914 
3915   LIR_Opr to_opr = LIR_OprFact::virtual_register(to_interval-&gt;reg_num(), to_interval-&gt;type());
3916   _insertion_buffer.move(_insert_idx, from_opr, to_opr);
3917 
3918   TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;MoveResolver: inserted move from constant &quot;); from_opr-&gt;print(); tty-&gt;print_cr(&quot;  to %d (%d, %d)&quot;, to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
3919 }
3920 
3921 
3922 void MoveResolver::resolve_mappings() {
3923   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: resolving mappings for Block B%d, index %d&quot;, _insert_list-&gt;block() != NULL ? _insert_list-&gt;block()-&gt;block_id() : -1, _insert_idx));
3924   DEBUG_ONLY(verify_before_resolve());
3925 
3926   // Block all registers that are used as input operands of a move.
3927   // When a register is blocked, no move to this register is emitted.
3928   // This is necessary for detecting cycles in moves.
3929   int i;
3930   for (i = _mapping_from.length() - 1; i &gt;= 0; i--) {
3931     Interval* from_interval = _mapping_from.at(i);
3932     if (from_interval != NULL) {
3933       block_registers(from_interval);
3934     }
3935   }
3936 
3937   int spill_candidate = -1;
3938   while (_mapping_from.length() &gt; 0) {
3939     bool processed_interval = false;
3940 
3941     for (i = _mapping_from.length() - 1; i &gt;= 0; i--) {
3942       Interval* from_interval = _mapping_from.at(i);
3943       Interval* to_interval = _mapping_to.at(i);
3944 
3945       if (save_to_process_move(from_interval, to_interval)) {
3946         // this inverval can be processed because target is free
3947         if (from_interval != NULL) {
3948           insert_move(from_interval, to_interval);
3949           unblock_registers(from_interval);
3950         } else {
3951           insert_move(_mapping_from_opr.at(i), to_interval);
3952         }
3953         _mapping_from.remove_at(i);
3954         _mapping_from_opr.remove_at(i);
3955         _mapping_to.remove_at(i);
3956 
3957         processed_interval = true;
3958       } else if (from_interval != NULL &amp;&amp; from_interval-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
3959         // this interval cannot be processed now because target is not free
3960         // it starts in a register, so it is a possible candidate for spilling
3961         spill_candidate = i;
3962       }
3963     }
3964 
3965     if (!processed_interval) {
3966       // no move could be processed because there is a cycle in the move list
3967       // (e.g. r1 -&gt; r2, r2 -&gt; r1), so one interval must be spilled to memory
3968       guarantee(spill_candidate != -1, &quot;no interval in register for spilling found&quot;);
3969 
3970       // create a new spill interval and assign a stack slot to it
3971       Interval* from_interval = _mapping_from.at(spill_candidate);
3972       Interval* spill_interval = new Interval(-1);
3973       spill_interval-&gt;set_type(from_interval-&gt;type());
3974 
3975       // add a dummy range because real position is difficult to calculate
3976       // Note: this range is a special case when the integrity of the allocation is checked
3977       spill_interval-&gt;add_range(1, 2);
3978 
3979       //       do not allocate a new spill slot for temporary interval, but
3980       //       use spill slot assigned to from_interval. Otherwise moves from
3981       //       one stack slot to another can happen (not allowed by LIR_Assembler
3982       int spill_slot = from_interval-&gt;canonical_spill_slot();
3983       if (spill_slot &lt; 0) {
3984         spill_slot = allocator()-&gt;allocate_spill_slot(type2spill_size[spill_interval-&gt;type()] == 2);
3985         from_interval-&gt;set_canonical_spill_slot(spill_slot);
3986       }
3987       spill_interval-&gt;assign_reg(spill_slot);
3988       allocator()-&gt;append_interval(spill_interval);
3989 
3990       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;created new Interval %d for spilling&quot;, spill_interval-&gt;reg_num()));
3991 
3992       // insert a move from register to stack and update the mapping
3993       insert_move(from_interval, spill_interval);
3994       _mapping_from.at_put(spill_candidate, spill_interval);
3995       unblock_registers(from_interval);
3996     }
3997   }
3998 
3999   // reset to default value
4000   _multiple_reads_allowed = false;
4001 
4002   // check that all intervals have been processed
4003   DEBUG_ONLY(check_empty());
4004 }
4005 
4006 
4007 void MoveResolver::set_insert_position(LIR_List* insert_list, int insert_idx) {
4008   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: setting insert position to Block B%d, index %d&quot;, insert_list-&gt;block() != NULL ? insert_list-&gt;block()-&gt;block_id() : -1, insert_idx));
4009   assert(_insert_list == NULL &amp;&amp; _insert_idx == -1, &quot;use move_insert_position instead of set_insert_position when data already set&quot;);
4010 
4011   create_insertion_buffer(insert_list);
4012   _insert_list = insert_list;
4013   _insert_idx = insert_idx;
4014 }
4015 
4016 void MoveResolver::move_insert_position(LIR_List* insert_list, int insert_idx) {
4017   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: moving insert position to Block B%d, index %d&quot;, insert_list-&gt;block() != NULL ? insert_list-&gt;block()-&gt;block_id() : -1, insert_idx));
4018 
4019   if (_insert_list != NULL &amp;&amp; (insert_list != _insert_list || insert_idx != _insert_idx)) {
4020     // insert position changed -&gt; resolve current mappings
4021     resolve_mappings();
4022   }
4023 
4024   if (insert_list != _insert_list) {
4025     // block changed -&gt; append insertion_buffer because it is
4026     // bound to a specific block and create a new insertion_buffer
4027     append_insertion_buffer();
4028     create_insertion_buffer(insert_list);
4029   }
4030 
4031   _insert_list = insert_list;
4032   _insert_idx = insert_idx;
4033 }
4034 
4035 void MoveResolver::add_mapping(Interval* from_interval, Interval* to_interval) {
4036   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: adding mapping from %d (%d, %d) to %d (%d, %d)&quot;, from_interval-&gt;reg_num(), from_interval-&gt;assigned_reg(), from_interval-&gt;assigned_regHi(), to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
4037 
4038   _mapping_from.append(from_interval);
4039   _mapping_from_opr.append(LIR_OprFact::illegalOpr);
4040   _mapping_to.append(to_interval);
4041 }
4042 
4043 
4044 void MoveResolver::add_mapping(LIR_Opr from_opr, Interval* to_interval) {
4045   TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;MoveResolver: adding mapping from &quot;); from_opr-&gt;print(); tty-&gt;print_cr(&quot; to %d (%d, %d)&quot;, to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
4046   assert(from_opr-&gt;is_constant(), &quot;only for constants&quot;);
4047 
4048   _mapping_from.append(NULL);
4049   _mapping_from_opr.append(from_opr);
4050   _mapping_to.append(to_interval);
4051 }
4052 
4053 void MoveResolver::resolve_and_append_moves() {
4054   if (has_mappings()) {
4055     resolve_mappings();
4056   }
4057   append_insertion_buffer();
4058 }
4059 
4060 
4061 
4062 // **** Implementation of Range *************************************
4063 
4064 Range::Range(int from, int to, Range* next) :
4065   _from(from),
4066   _to(to),
4067   _next(next)
4068 {
4069 }
4070 
4071 // initialize sentinel
4072 Range* Range::_end = NULL;
4073 void Range::initialize(Arena* arena) {
4074   _end = new (arena) Range(max_jint, max_jint, NULL);
4075 }
4076 
4077 int Range::intersects_at(Range* r2) const {
4078   const Range* r1 = this;
4079 
4080   assert(r1 != NULL &amp;&amp; r2 != NULL, &quot;null ranges not allowed&quot;);
4081   assert(r1 != _end &amp;&amp; r2 != _end, &quot;empty ranges not allowed&quot;);
4082 
4083   do {
4084     if (r1-&gt;from() &lt; r2-&gt;from()) {
4085       if (r1-&gt;to() &lt;= r2-&gt;from()) {
4086         r1 = r1-&gt;next(); if (r1 == _end) return -1;
4087       } else {
4088         return r2-&gt;from();
4089       }
4090     } else if (r2-&gt;from() &lt; r1-&gt;from()) {
4091       if (r2-&gt;to() &lt;= r1-&gt;from()) {
4092         r2 = r2-&gt;next(); if (r2 == _end) return -1;
4093       } else {
4094         return r1-&gt;from();
4095       }
4096     } else { // r1-&gt;from() == r2-&gt;from()
4097       if (r1-&gt;from() == r1-&gt;to()) {
4098         r1 = r1-&gt;next(); if (r1 == _end) return -1;
4099       } else if (r2-&gt;from() == r2-&gt;to()) {
4100         r2 = r2-&gt;next(); if (r2 == _end) return -1;
4101       } else {
4102         return r1-&gt;from();
4103       }
4104     }
4105   } while (true);
4106 }
4107 
4108 #ifndef PRODUCT
4109 void Range::print(outputStream* out) const {
4110   out-&gt;print(&quot;[%d, %d[ &quot;, _from, _to);
4111 }
4112 #endif
4113 
4114 
4115 
4116 // **** Implementation of Interval **********************************
4117 
4118 // initialize sentinel
4119 Interval* Interval::_end = NULL;
4120 void Interval::initialize(Arena* arena) {
4121   Range::initialize(arena);
4122   _end = new (arena) Interval(-1);
4123 }
4124 
4125 Interval::Interval(int reg_num) :
4126   _reg_num(reg_num),
4127   _type(T_ILLEGAL),
4128   _first(Range::end()),
4129   _use_pos_and_kinds(12),
4130   _current(Range::end()),
4131   _next(_end),
4132   _state(invalidState),
4133   _assigned_reg(LinearScan::any_reg),
4134   _assigned_regHi(LinearScan::any_reg),
4135   _cached_to(-1),
4136   _cached_opr(LIR_OprFact::illegalOpr),
4137   _cached_vm_reg(VMRegImpl::Bad()),
4138   _split_children(NULL),
4139   _canonical_spill_slot(-1),
4140   _insert_move_when_activated(false),
4141   _spill_state(noDefinitionFound),
4142   _spill_definition_pos(-1),
4143   _register_hint(NULL)
4144 {
4145   _split_parent = this;
4146   _current_split_child = this;
4147 }
4148 
4149 int Interval::calc_to() {
4150   assert(_first != Range::end(), &quot;interval has no range&quot;);
4151 
4152   Range* r = _first;
4153   while (r-&gt;next() != Range::end()) {
4154     r = r-&gt;next();
4155   }
4156   return r-&gt;to();
4157 }
4158 
4159 
4160 #ifdef ASSERT
4161 // consistency check of split-children
4162 void Interval::check_split_children() {
4163   if (_split_children != NULL &amp;&amp; _split_children-&gt;length() &gt; 0) {
4164     assert(is_split_parent(), &quot;only split parents can have children&quot;);
4165 
4166     for (int i = 0; i &lt; _split_children-&gt;length(); i++) {
4167       Interval* i1 = _split_children-&gt;at(i);
4168 
4169       assert(i1-&gt;split_parent() == this, &quot;not a split child of this interval&quot;);
4170       assert(i1-&gt;type() == type(), &quot;must be equal for all split children&quot;);
4171       assert(i1-&gt;canonical_spill_slot() == canonical_spill_slot(), &quot;must be equal for all split children&quot;);
4172 
4173       for (int j = i + 1; j &lt; _split_children-&gt;length(); j++) {
4174         Interval* i2 = _split_children-&gt;at(j);
4175 
4176         assert(i1-&gt;reg_num() != i2-&gt;reg_num(), &quot;same register number&quot;);
4177 
4178         if (i1-&gt;from() &lt; i2-&gt;from()) {
4179           assert(i1-&gt;to() &lt;= i2-&gt;from() &amp;&amp; i1-&gt;to() &lt; i2-&gt;to(), &quot;intervals overlapping&quot;);
4180         } else {
4181           assert(i2-&gt;from() &lt; i1-&gt;from(), &quot;intervals start at same op_id&quot;);
4182           assert(i2-&gt;to() &lt;= i1-&gt;from() &amp;&amp; i2-&gt;to() &lt; i1-&gt;to(), &quot;intervals overlapping&quot;);
4183         }
4184       }
4185     }
4186   }
4187 }
4188 #endif // ASSERT
4189 
4190 Interval* Interval::register_hint(bool search_split_child) const {
4191   if (!search_split_child) {
4192     return _register_hint;
4193   }
4194 
4195   if (_register_hint != NULL) {
4196     assert(_register_hint-&gt;is_split_parent(), &quot;ony split parents are valid hint registers&quot;);
4197 
4198     if (_register_hint-&gt;assigned_reg() &gt;= 0 &amp;&amp; _register_hint-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
4199       return _register_hint;
4200 
4201     } else if (_register_hint-&gt;_split_children != NULL &amp;&amp; _register_hint-&gt;_split_children-&gt;length() &gt; 0) {
4202       // search the first split child that has a register assigned
4203       int len = _register_hint-&gt;_split_children-&gt;length();
4204       for (int i = 0; i &lt; len; i++) {
4205         Interval* cur = _register_hint-&gt;_split_children-&gt;at(i);
4206 
4207         if (cur-&gt;assigned_reg() &gt;= 0 &amp;&amp; cur-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
4208           return cur;
4209         }
4210       }
4211     }
4212   }
4213 
4214   // no hint interval found that has a register assigned
4215   return NULL;
4216 }
4217 
4218 
4219 Interval* Interval::split_child_at_op_id(int op_id, LIR_OpVisitState::OprMode mode) {
4220   assert(is_split_parent(), &quot;can only be called for split parents&quot;);
4221   assert(op_id &gt;= 0, &quot;invalid op_id (method can not be called for spill moves)&quot;);
4222 
4223   Interval* result;
4224   if (_split_children == NULL || _split_children-&gt;length() == 0) {
4225     result = this;
4226   } else {
4227     result = NULL;
4228     int len = _split_children-&gt;length();
4229 
4230     // in outputMode, the end of the interval (op_id == cur-&gt;to()) is not valid
4231     int to_offset = (mode == LIR_OpVisitState::outputMode ? 0 : 1);
4232 
4233     int i;
4234     for (i = 0; i &lt; len; i++) {
4235       Interval* cur = _split_children-&gt;at(i);
4236       if (cur-&gt;from() &lt;= op_id &amp;&amp; op_id &lt; cur-&gt;to() + to_offset) {
4237         if (i &gt; 0) {
4238           // exchange current split child to start of list (faster access for next call)
4239           _split_children-&gt;at_put(i, _split_children-&gt;at(0));
4240           _split_children-&gt;at_put(0, cur);
4241         }
4242 
4243         // interval found
4244         result = cur;
4245         break;
4246       }
4247     }
4248 
4249 #ifdef ASSERT
4250     for (i = 0; i &lt; len; i++) {
4251       Interval* tmp = _split_children-&gt;at(i);
4252       if (tmp != result &amp;&amp; tmp-&gt;from() &lt;= op_id &amp;&amp; op_id &lt; tmp-&gt;to() + to_offset) {
4253         tty-&gt;print_cr(&quot;two valid result intervals found for op_id %d: %d and %d&quot;, op_id, result-&gt;reg_num(), tmp-&gt;reg_num());
4254         result-&gt;print();
4255         tmp-&gt;print();
4256         assert(false, &quot;two valid result intervals found&quot;);
4257       }
4258     }
4259 #endif
4260   }
4261 
4262   assert(result != NULL, &quot;no matching interval found&quot;);
4263   assert(result-&gt;covers(op_id, mode), &quot;op_id not covered by interval&quot;);
4264 
4265   return result;
4266 }
4267 
4268 
4269 // returns the last split child that ends before the given op_id
4270 Interval* Interval::split_child_before_op_id(int op_id) {
4271   assert(op_id &gt;= 0, &quot;invalid op_id&quot;);
4272 
4273   Interval* parent = split_parent();
4274   Interval* result = NULL;
4275 
4276   assert(parent-&gt;_split_children != NULL, &quot;no split children available&quot;);
4277   int len = parent-&gt;_split_children-&gt;length();
4278   assert(len &gt; 0, &quot;no split children available&quot;);
4279 
4280   for (int i = len - 1; i &gt;= 0; i--) {
4281     Interval* cur = parent-&gt;_split_children-&gt;at(i);
4282     if (cur-&gt;to() &lt;= op_id &amp;&amp; (result == NULL || result-&gt;to() &lt; cur-&gt;to())) {
4283       result = cur;
4284     }
4285   }
4286 
4287   assert(result != NULL, &quot;no split child found&quot;);
4288   return result;
4289 }
4290 
4291 
4292 // Note: use positions are sorted descending -&gt; first use has highest index
4293 int Interval::first_usage(IntervalUseKind min_use_kind) const {
4294   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4295 
4296   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4297     if (_use_pos_and_kinds.at(i + 1) &gt;= min_use_kind) {
4298       return _use_pos_and_kinds.at(i);
4299     }
4300   }
4301   return max_jint;
4302 }
4303 
4304 int Interval::next_usage(IntervalUseKind min_use_kind, int from) const {
4305   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4306 
4307   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4308     if (_use_pos_and_kinds.at(i) &gt;= from &amp;&amp; _use_pos_and_kinds.at(i + 1) &gt;= min_use_kind) {
4309       return _use_pos_and_kinds.at(i);
4310     }
4311   }
4312   return max_jint;
4313 }
4314 
4315 int Interval::next_usage_exact(IntervalUseKind exact_use_kind, int from) const {
4316   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4317 
4318   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4319     if (_use_pos_and_kinds.at(i) &gt;= from &amp;&amp; _use_pos_and_kinds.at(i + 1) == exact_use_kind) {
4320       return _use_pos_and_kinds.at(i);
4321     }
4322   }
4323   return max_jint;
4324 }
4325 
4326 int Interval::previous_usage(IntervalUseKind min_use_kind, int from) const {
4327   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4328 
4329   int prev = 0;
4330   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4331     if (_use_pos_and_kinds.at(i) &gt; from) {
4332       return prev;
4333     }
4334     if (_use_pos_and_kinds.at(i + 1) &gt;= min_use_kind) {
4335       prev = _use_pos_and_kinds.at(i);
4336     }
4337   }
4338   return prev;
4339 }
4340 
4341 void Interval::add_use_pos(int pos, IntervalUseKind use_kind) {
4342   assert(covers(pos, LIR_OpVisitState::inputMode), &quot;use position not covered by live range&quot;);
4343 
4344   // do not add use positions for precolored intervals because
4345   // they are never used
4346   if (use_kind != noUse &amp;&amp; reg_num() &gt;= LIR_OprDesc::vreg_base) {
4347 #ifdef ASSERT
4348     assert(_use_pos_and_kinds.length() % 2 == 0, &quot;must be&quot;);
4349     for (int i = 0; i &lt; _use_pos_and_kinds.length(); i += 2) {
4350       assert(pos &lt;= _use_pos_and_kinds.at(i), &quot;already added a use-position with lower position&quot;);
4351       assert(_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; _use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4352       if (i &gt; 0) {
4353         assert(_use_pos_and_kinds.at(i) &lt; _use_pos_and_kinds.at(i - 2), &quot;not sorted descending&quot;);
4354       }
4355     }
4356 #endif
4357 
4358     // Note: add_use is called in descending order, so list gets sorted
4359     //       automatically by just appending new use positions
4360     int len = _use_pos_and_kinds.length();
4361     if (len == 0 || _use_pos_and_kinds.at(len - 2) &gt; pos) {
4362       _use_pos_and_kinds.append(pos);
4363       _use_pos_and_kinds.append(use_kind);
4364     } else if (_use_pos_and_kinds.at(len - 1) &lt; use_kind) {
4365       assert(_use_pos_and_kinds.at(len - 2) == pos, &quot;list not sorted correctly&quot;);
4366       _use_pos_and_kinds.at_put(len - 1, use_kind);
4367     }
4368   }
4369 }
4370 
4371 void Interval::add_range(int from, int to) {
4372   assert(from &lt; to, &quot;invalid range&quot;);
4373   assert(first() == Range::end() || to &lt; first()-&gt;next()-&gt;from(), &quot;not inserting at begin of interval&quot;);
4374   assert(from &lt;= first()-&gt;to(), &quot;not inserting at begin of interval&quot;);
4375 
4376   if (first()-&gt;from() &lt;= to) {
4377     // join intersecting ranges
4378     first()-&gt;set_from(MIN2(from, first()-&gt;from()));
4379     first()-&gt;set_to  (MAX2(to,   first()-&gt;to()));
4380   } else {
4381     // insert new range
4382     _first = new Range(from, to, first());
4383   }
4384 }
4385 
4386 Interval* Interval::new_split_child() {
4387   // allocate new interval
4388   Interval* result = new Interval(-1);
4389   result-&gt;set_type(type());
4390 
4391   Interval* parent = split_parent();
4392   result-&gt;_split_parent = parent;
4393   result-&gt;set_register_hint(parent);
4394 
4395   // insert new interval in children-list of parent
4396   if (parent-&gt;_split_children == NULL) {
4397     assert(is_split_parent(), &quot;list must be initialized at first split&quot;);
4398 
4399     parent-&gt;_split_children = new IntervalList(4);
4400     parent-&gt;_split_children-&gt;append(this);
4401   }
4402   parent-&gt;_split_children-&gt;append(result);
4403 
4404   return result;
4405 }
4406 
4407 // split this interval at the specified position and return
4408 // the remainder as a new interval.
4409 //
4410 // when an interval is split, a bi-directional link is established between the original interval
4411 // (the split parent) and the intervals that are split off this interval (the split children)
4412 // When a split child is split again, the new created interval is also a direct child
4413 // of the original parent (there is no tree of split children stored, but a flat list)
4414 // All split children are spilled to the same stack slot (stored in _canonical_spill_slot)
4415 //
4416 // Note: The new interval has no valid reg_num
4417 Interval* Interval::split(int split_pos) {
4418   assert(LinearScan::is_virtual_interval(this), &quot;cannot split fixed intervals&quot;);
4419 
4420   // allocate new interval
4421   Interval* result = new_split_child();
4422 
4423   // split the ranges
4424   Range* prev = NULL;
4425   Range* cur = _first;
4426   while (cur != Range::end() &amp;&amp; cur-&gt;to() &lt;= split_pos) {
4427     prev = cur;
4428     cur = cur-&gt;next();
4429   }
4430   assert(cur != Range::end(), &quot;split interval after end of last range&quot;);
4431 
4432   if (cur-&gt;from() &lt; split_pos) {
4433     result-&gt;_first = new Range(split_pos, cur-&gt;to(), cur-&gt;next());
4434     cur-&gt;set_to(split_pos);
4435     cur-&gt;set_next(Range::end());
4436 
4437   } else {
4438     assert(prev != NULL, &quot;split before start of first range&quot;);
4439     result-&gt;_first = cur;
4440     prev-&gt;set_next(Range::end());
4441   }
4442   result-&gt;_current = result-&gt;_first;
4443   _cached_to = -1; // clear cached value
4444 
4445   // split list of use positions
4446   int total_len = _use_pos_and_kinds.length();
4447   int start_idx = total_len - 2;
4448   while (start_idx &gt;= 0 &amp;&amp; _use_pos_and_kinds.at(start_idx) &lt; split_pos) {
4449     start_idx -= 2;
4450   }
4451 
4452   intStack new_use_pos_and_kinds(total_len - start_idx);
4453   int i;
4454   for (i = start_idx + 2; i &lt; total_len; i++) {
4455     new_use_pos_and_kinds.append(_use_pos_and_kinds.at(i));
4456   }
4457 
4458   _use_pos_and_kinds.trunc_to(start_idx + 2);
4459   result-&gt;_use_pos_and_kinds = _use_pos_and_kinds;
4460   _use_pos_and_kinds = new_use_pos_and_kinds;
4461 
4462 #ifdef ASSERT
4463   assert(_use_pos_and_kinds.length() % 2 == 0, &quot;must have use kind for each use pos&quot;);
4464   assert(result-&gt;_use_pos_and_kinds.length() % 2 == 0, &quot;must have use kind for each use pos&quot;);
4465   assert(_use_pos_and_kinds.length() + result-&gt;_use_pos_and_kinds.length() == total_len, &quot;missed some entries&quot;);
4466 
4467   for (i = 0; i &lt; _use_pos_and_kinds.length(); i += 2) {
4468     assert(_use_pos_and_kinds.at(i) &lt; split_pos, &quot;must be&quot;);
4469     assert(_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; _use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4470   }
4471   for (i = 0; i &lt; result-&gt;_use_pos_and_kinds.length(); i += 2) {
4472     assert(result-&gt;_use_pos_and_kinds.at(i) &gt;= split_pos, &quot;must be&quot;);
4473     assert(result-&gt;_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; result-&gt;_use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4474   }
4475 #endif
4476 
4477   return result;
4478 }
4479 
4480 // split this interval at the specified position and return
4481 // the head as a new interval (the original interval is the tail)
4482 //
4483 // Currently, only the first range can be split, and the new interval
4484 // must not have split positions
4485 Interval* Interval::split_from_start(int split_pos) {
4486   assert(LinearScan::is_virtual_interval(this), &quot;cannot split fixed intervals&quot;);
4487   assert(split_pos &gt; from() &amp;&amp; split_pos &lt; to(), &quot;can only split inside interval&quot;);
4488   assert(split_pos &gt; _first-&gt;from() &amp;&amp; split_pos &lt;= _first-&gt;to(), &quot;can only split inside first range&quot;);
4489   assert(first_usage(noUse) &gt; split_pos, &quot;can not split when use positions are present&quot;);
4490 
4491   // allocate new interval
4492   Interval* result = new_split_child();
4493 
4494   // the new created interval has only one range (checked by assertion above),
4495   // so the splitting of the ranges is very simple
4496   result-&gt;add_range(_first-&gt;from(), split_pos);
4497 
4498   if (split_pos == _first-&gt;to()) {
4499     assert(_first-&gt;next() != Range::end(), &quot;must not be at end&quot;);
4500     _first = _first-&gt;next();
4501   } else {
4502     _first-&gt;set_from(split_pos);
4503   }
4504 
4505   return result;
4506 }
4507 
4508 
4509 // returns true if the op_id is inside the interval
4510 bool Interval::covers(int op_id, LIR_OpVisitState::OprMode mode) const {
4511   Range* cur  = _first;
4512 
4513   while (cur != Range::end() &amp;&amp; cur-&gt;to() &lt; op_id) {
4514     cur = cur-&gt;next();
4515   }
4516   if (cur != Range::end()) {
4517     assert(cur-&gt;to() != cur-&gt;next()-&gt;from(), &quot;ranges not separated&quot;);
4518 
4519     if (mode == LIR_OpVisitState::outputMode) {
4520       return cur-&gt;from() &lt;= op_id &amp;&amp; op_id &lt; cur-&gt;to();
4521     } else {
4522       return cur-&gt;from() &lt;= op_id &amp;&amp; op_id &lt;= cur-&gt;to();
4523     }
4524   }
4525   return false;
4526 }
4527 
4528 // returns true if the interval has any hole between hole_from and hole_to
4529 // (even if the hole has only the length 1)
4530 bool Interval::has_hole_between(int hole_from, int hole_to) {
4531   assert(hole_from &lt; hole_to, &quot;check&quot;);
4532   assert(from() &lt;= hole_from &amp;&amp; hole_to &lt;= to(), &quot;index out of interval&quot;);
4533 
4534   Range* cur  = _first;
4535   while (cur != Range::end()) {
4536     assert(cur-&gt;to() &lt; cur-&gt;next()-&gt;from(), &quot;no space between ranges&quot;);
4537 
4538     // hole-range starts before this range -&gt; hole
4539     if (hole_from &lt; cur-&gt;from()) {
4540       return true;
4541 
4542     // hole-range completely inside this range -&gt; no hole
4543     } else if (hole_to &lt;= cur-&gt;to()) {
4544       return false;
4545 
4546     // overlapping of hole-range with this range -&gt; hole
4547     } else if (hole_from &lt;= cur-&gt;to()) {
4548       return true;
4549     }
4550 
4551     cur = cur-&gt;next();
4552   }
4553 
4554   return false;
4555 }
4556 
4557 
4558 #ifndef PRODUCT
4559 void Interval::print(outputStream* out) const {
4560   const char* SpillState2Name[] = { &quot;no definition&quot;, &quot;no spill store&quot;, &quot;one spill store&quot;, &quot;store at definition&quot;, &quot;start in memory&quot;, &quot;no optimization&quot; };
4561   const char* UseKind2Name[] = { &quot;N&quot;, &quot;L&quot;, &quot;S&quot;, &quot;M&quot; };
4562 
4563   const char* type_name;
4564   LIR_Opr opr = LIR_OprFact::illegal();
4565   if (reg_num() &lt; LIR_OprDesc::vreg_base) {
4566     type_name = &quot;fixed&quot;;
4567     // need a temporary operand for fixed intervals because type() cannot be called
4568 #ifdef X86
4569     int last_xmm_reg = pd_last_xmm_reg;
4570 #ifdef _LP64
4571     if (UseAVX &lt; 3) {
4572       last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map / 2) - 1;
4573     }
4574 #endif
4575 #endif
4576     if (assigned_reg() &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg() &lt;= pd_last_cpu_reg) {
4577       opr = LIR_OprFact::single_cpu(assigned_reg());
4578     } else if (assigned_reg() &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg() &lt;= pd_last_fpu_reg) {
4579       opr = LIR_OprFact::single_fpu(assigned_reg() - pd_first_fpu_reg);
4580 #ifdef X86
4581     } else if (assigned_reg() &gt;= pd_first_xmm_reg &amp;&amp; assigned_reg() &lt;= last_xmm_reg) {
4582       opr = LIR_OprFact::single_xmm(assigned_reg() - pd_first_xmm_reg);
4583 #endif
4584     } else {
4585       ShouldNotReachHere();
4586     }
4587   } else {
4588     type_name = type2name(type());
4589     if (assigned_reg() != -1 &amp;&amp;
4590         (LinearScan::num_physical_regs(type()) == 1 || assigned_regHi() != -1)) {
4591       opr = LinearScan::calc_operand_for_interval(this);
4592     }
4593   }
4594 
4595   out-&gt;print(&quot;%d %s &quot;, reg_num(), type_name);
4596   if (opr-&gt;is_valid()) {
4597     out-&gt;print(&quot;\&quot;&quot;);
4598     opr-&gt;print(out);
4599     out-&gt;print(&quot;\&quot; &quot;);
4600   }
4601   out-&gt;print(&quot;%d %d &quot;, split_parent()-&gt;reg_num(), (register_hint(false) != NULL ? register_hint(false)-&gt;reg_num() : -1));
4602 
4603   // print ranges
4604   Range* cur = _first;
4605   while (cur != Range::end()) {
4606     cur-&gt;print(out);
4607     cur = cur-&gt;next();
4608     assert(cur != NULL, &quot;range list not closed with range sentinel&quot;);
4609   }
4610 
4611   // print use positions
4612   int prev = 0;
4613   assert(_use_pos_and_kinds.length() % 2 == 0, &quot;must be&quot;);
4614   for (int i =_use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4615     assert(_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; _use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4616     assert(prev &lt; _use_pos_and_kinds.at(i), &quot;use positions not sorted&quot;);
4617 
4618     out-&gt;print(&quot;%d %s &quot;, _use_pos_and_kinds.at(i), UseKind2Name[_use_pos_and_kinds.at(i + 1)]);
4619     prev = _use_pos_and_kinds.at(i);
4620   }
4621 
4622   out-&gt;print(&quot; \&quot;%s\&quot;&quot;, SpillState2Name[spill_state()]);
4623   out-&gt;cr();
4624 }
4625 #endif
4626 
4627 
4628 
4629 // **** Implementation of IntervalWalker ****************************
4630 
4631 IntervalWalker::IntervalWalker(LinearScan* allocator, Interval* unhandled_fixed_first, Interval* unhandled_any_first)
4632  : _compilation(allocator-&gt;compilation())
4633  , _allocator(allocator)
4634 {
4635   _unhandled_first[fixedKind] = unhandled_fixed_first;
4636   _unhandled_first[anyKind]   = unhandled_any_first;
4637   _active_first[fixedKind]    = Interval::end();
4638   _inactive_first[fixedKind]  = Interval::end();
4639   _active_first[anyKind]      = Interval::end();
4640   _inactive_first[anyKind]    = Interval::end();
4641   _current_position = -1;
4642   _current = NULL;
4643   next_interval();
4644 }
4645 
4646 
4647 // append interval in order of current range from()
4648 void IntervalWalker::append_sorted(Interval** list, Interval* interval) {
4649   Interval* prev = NULL;
4650   Interval* cur  = *list;
4651   while (cur-&gt;current_from() &lt; interval-&gt;current_from()) {
4652     prev = cur; cur = cur-&gt;next();
4653   }
4654   if (prev == NULL) {
4655     *list = interval;
4656   } else {
4657     prev-&gt;set_next(interval);
4658   }
4659   interval-&gt;set_next(cur);
4660 }
4661 
4662 void IntervalWalker::append_to_unhandled(Interval** list, Interval* interval) {
4663   assert(interval-&gt;from() &gt;= current()-&gt;current_from(), &quot;cannot append new interval before current walk position&quot;);
4664 
4665   Interval* prev = NULL;
4666   Interval* cur  = *list;
4667   while (cur-&gt;from() &lt; interval-&gt;from() || (cur-&gt;from() == interval-&gt;from() &amp;&amp; cur-&gt;first_usage(noUse) &lt; interval-&gt;first_usage(noUse))) {
4668     prev = cur; cur = cur-&gt;next();
4669   }
4670   if (prev == NULL) {
4671     *list = interval;
4672   } else {
4673     prev-&gt;set_next(interval);
4674   }
4675   interval-&gt;set_next(cur);
4676 }
4677 
4678 
4679 inline bool IntervalWalker::remove_from_list(Interval** list, Interval* i) {
4680   while (*list != Interval::end() &amp;&amp; *list != i) {
4681     list = (*list)-&gt;next_addr();
4682   }
4683   if (*list != Interval::end()) {
4684     assert(*list == i, &quot;check&quot;);
4685     *list = (*list)-&gt;next();
4686     return true;
4687   } else {
4688     return false;
4689   }
4690 }
4691 
4692 void IntervalWalker::remove_from_list(Interval* i) {
4693   bool deleted;
4694 
4695   if (i-&gt;state() == activeState) {
4696     deleted = remove_from_list(active_first_addr(anyKind), i);
4697   } else {
4698     assert(i-&gt;state() == inactiveState, &quot;invalid state&quot;);
4699     deleted = remove_from_list(inactive_first_addr(anyKind), i);
4700   }
4701 
4702   assert(deleted, &quot;interval has not been found in list&quot;);
4703 }
4704 
4705 
4706 void IntervalWalker::walk_to(IntervalState state, int from) {
4707   assert (state == activeState || state == inactiveState, &quot;wrong state&quot;);
4708   for_each_interval_kind(kind) {
4709     Interval** prev = state == activeState ? active_first_addr(kind) : inactive_first_addr(kind);
4710     Interval* next   = *prev;
4711     while (next-&gt;current_from() &lt;= from) {
4712       Interval* cur = next;
4713       next = cur-&gt;next();
4714 
4715       bool range_has_changed = false;
4716       while (cur-&gt;current_to() &lt;= from) {
4717         cur-&gt;next_range();
4718         range_has_changed = true;
4719       }
4720 
4721       // also handle move from inactive list to active list
4722       range_has_changed = range_has_changed || (state == inactiveState &amp;&amp; cur-&gt;current_from() &lt;= from);
4723 
4724       if (range_has_changed) {
4725         // remove cur from list
4726         *prev = next;
4727         if (cur-&gt;current_at_end()) {
4728           // move to handled state (not maintained as a list)
4729           cur-&gt;set_state(handledState);
4730           interval_moved(cur, kind, state, handledState);
4731         } else if (cur-&gt;current_from() &lt;= from){
4732           // sort into active list
4733           append_sorted(active_first_addr(kind), cur);
4734           cur-&gt;set_state(activeState);
4735           if (*prev == cur) {
4736             assert(state == activeState, &quot;check&quot;);
4737             prev = cur-&gt;next_addr();
4738           }
4739           interval_moved(cur, kind, state, activeState);
4740         } else {
4741           // sort into inactive list
4742           append_sorted(inactive_first_addr(kind), cur);
4743           cur-&gt;set_state(inactiveState);
4744           if (*prev == cur) {
4745             assert(state == inactiveState, &quot;check&quot;);
4746             prev = cur-&gt;next_addr();
4747           }
4748           interval_moved(cur, kind, state, inactiveState);
4749         }
4750       } else {
4751         prev = cur-&gt;next_addr();
4752         continue;
4753       }
4754     }
4755   }
4756 }
4757 
4758 
4759 void IntervalWalker::next_interval() {
4760   IntervalKind kind;
4761   Interval* any   = _unhandled_first[anyKind];
4762   Interval* fixed = _unhandled_first[fixedKind];
4763 
4764   if (any != Interval::end()) {
4765     // intervals may start at same position -&gt; prefer fixed interval
4766     kind = fixed != Interval::end() &amp;&amp; fixed-&gt;from() &lt;= any-&gt;from() ? fixedKind : anyKind;
4767 
4768     assert (kind == fixedKind &amp;&amp; fixed-&gt;from() &lt;= any-&gt;from() ||
4769             kind == anyKind   &amp;&amp; any-&gt;from() &lt;= fixed-&gt;from(), &quot;wrong interval!!!&quot;);
4770     assert(any == Interval::end() || fixed == Interval::end() || any-&gt;from() != fixed-&gt;from() || kind == fixedKind, &quot;if fixed and any-Interval start at same position, fixed must be processed first&quot;);
4771 
4772   } else if (fixed != Interval::end()) {
4773     kind = fixedKind;
4774   } else {
4775     _current = NULL; return;
4776   }
4777   _current_kind = kind;
4778   _current = _unhandled_first[kind];
4779   _unhandled_first[kind] = _current-&gt;next();
4780   _current-&gt;set_next(Interval::end());
4781   _current-&gt;rewind_range();
4782 }
4783 
4784 
4785 void IntervalWalker::walk_to(int lir_op_id) {
4786   assert(_current_position &lt;= lir_op_id, &quot;can not walk backwards&quot;);
4787   while (current() != NULL) {
4788     bool is_active = current()-&gt;from() &lt;= lir_op_id;
4789     int id = is_active ? current()-&gt;from() : lir_op_id;
4790 
4791     TRACE_LINEAR_SCAN(2, if (_current_position &lt; id) { tty-&gt;cr(); tty-&gt;print_cr(&quot;walk_to(%d) **************************************************************&quot;, id); })
4792 
4793     // set _current_position prior to call of walk_to
4794     _current_position = id;
4795 
4796     // call walk_to even if _current_position == id
4797     walk_to(activeState, id);
4798     walk_to(inactiveState, id);
4799 
4800     if (is_active) {
4801       current()-&gt;set_state(activeState);
4802       if (activate_current()) {
4803         append_sorted(active_first_addr(current_kind()), current());
4804         interval_moved(current(), current_kind(), unhandledState, activeState);
4805       }
4806 
4807       next_interval();
4808     } else {
4809       return;
4810     }
4811   }
4812 }
4813 
4814 void IntervalWalker::interval_moved(Interval* interval, IntervalKind kind, IntervalState from, IntervalState to) {
4815 #ifndef PRODUCT
4816   if (TraceLinearScanLevel &gt;= 4) {
4817     #define print_state(state) \
4818     switch(state) {\
4819       case unhandledState: tty-&gt;print(&quot;unhandled&quot;); break;\
4820       case activeState: tty-&gt;print(&quot;active&quot;); break;\
4821       case inactiveState: tty-&gt;print(&quot;inactive&quot;); break;\
4822       case handledState: tty-&gt;print(&quot;handled&quot;); break;\
4823       default: ShouldNotReachHere(); \
4824     }
4825 
4826     print_state(from); tty-&gt;print(&quot; to &quot;); print_state(to);
4827     tty-&gt;fill_to(23);
4828     interval-&gt;print();
4829 
4830     #undef print_state
4831   }
4832 #endif
4833 }
4834 
4835 
4836 
4837 // **** Implementation of LinearScanWalker **************************
4838 
4839 LinearScanWalker::LinearScanWalker(LinearScan* allocator, Interval* unhandled_fixed_first, Interval* unhandled_any_first)
4840   : IntervalWalker(allocator, unhandled_fixed_first, unhandled_any_first)
4841   , _move_resolver(allocator)
4842 {
4843   for (int i = 0; i &lt; LinearScan::nof_regs; i++) {
4844     _spill_intervals[i] = new IntervalList(2);
4845   }
4846 }
4847 
4848 
4849 inline void LinearScanWalker::init_use_lists(bool only_process_use_pos) {
4850   for (int i = _first_reg; i &lt;= _last_reg; i++) {
4851     _use_pos[i] = max_jint;
4852 
4853     if (!only_process_use_pos) {
4854       _block_pos[i] = max_jint;
4855       _spill_intervals[i]-&gt;clear();
4856     }
4857   }
4858 }
4859 
4860 inline void LinearScanWalker::exclude_from_use(int reg) {
4861   assert(reg &lt; LinearScan::nof_regs, &quot;interval must have a register assigned (stack slots not allowed)&quot;);
4862   if (reg &gt;= _first_reg &amp;&amp; reg &lt;= _last_reg) {
4863     _use_pos[reg] = 0;
4864   }
4865 }
4866 inline void LinearScanWalker::exclude_from_use(Interval* i) {
4867   assert(i-&gt;assigned_reg() != any_reg, &quot;interval has no register assigned&quot;);
4868 
4869   exclude_from_use(i-&gt;assigned_reg());
4870   exclude_from_use(i-&gt;assigned_regHi());
4871 }
4872 
4873 inline void LinearScanWalker::set_use_pos(int reg, Interval* i, int use_pos, bool only_process_use_pos) {
4874   assert(use_pos != 0, &quot;must use exclude_from_use to set use_pos to 0&quot;);
4875 
4876   if (reg &gt;= _first_reg &amp;&amp; reg &lt;= _last_reg) {
4877     if (_use_pos[reg] &gt; use_pos) {
4878       _use_pos[reg] = use_pos;
4879     }
4880     if (!only_process_use_pos) {
4881       _spill_intervals[reg]-&gt;append(i);
4882     }
4883   }
4884 }
4885 inline void LinearScanWalker::set_use_pos(Interval* i, int use_pos, bool only_process_use_pos) {
4886   assert(i-&gt;assigned_reg() != any_reg, &quot;interval has no register assigned&quot;);
4887   if (use_pos != -1) {
4888     set_use_pos(i-&gt;assigned_reg(), i, use_pos, only_process_use_pos);
4889     set_use_pos(i-&gt;assigned_regHi(), i, use_pos, only_process_use_pos);
4890   }
4891 }
4892 
4893 inline void LinearScanWalker::set_block_pos(int reg, Interval* i, int block_pos) {
4894   if (reg &gt;= _first_reg &amp;&amp; reg &lt;= _last_reg) {
4895     if (_block_pos[reg] &gt; block_pos) {
4896       _block_pos[reg] = block_pos;
4897     }
4898     if (_use_pos[reg] &gt; block_pos) {
4899       _use_pos[reg] = block_pos;
4900     }
4901   }
4902 }
4903 inline void LinearScanWalker::set_block_pos(Interval* i, int block_pos) {
4904   assert(i-&gt;assigned_reg() != any_reg, &quot;interval has no register assigned&quot;);
4905   if (block_pos != -1) {
4906     set_block_pos(i-&gt;assigned_reg(), i, block_pos);
4907     set_block_pos(i-&gt;assigned_regHi(), i, block_pos);
4908   }
4909 }
4910 
4911 
4912 void LinearScanWalker::free_exclude_active_fixed() {
4913   Interval* list = active_first(fixedKind);
4914   while (list != Interval::end()) {
4915     assert(list-&gt;assigned_reg() &lt; LinearScan::nof_regs, &quot;active interval must have a register assigned&quot;);
4916     exclude_from_use(list);
4917     list = list-&gt;next();
4918   }
4919 }
4920 
4921 void LinearScanWalker::free_exclude_active_any() {
4922   Interval* list = active_first(anyKind);
4923   while (list != Interval::end()) {
4924     exclude_from_use(list);
4925     list = list-&gt;next();
4926   }
4927 }
4928 
4929 void LinearScanWalker::free_collect_inactive_fixed(Interval* cur) {
4930   Interval* list = inactive_first(fixedKind);
4931   while (list != Interval::end()) {
4932     if (cur-&gt;to() &lt;= list-&gt;current_from()) {
4933       assert(list-&gt;current_intersects_at(cur) == -1, &quot;must not intersect&quot;);
4934       set_use_pos(list, list-&gt;current_from(), true);
4935     } else {
4936       set_use_pos(list, list-&gt;current_intersects_at(cur), true);
4937     }
4938     list = list-&gt;next();
4939   }
4940 }
4941 
4942 void LinearScanWalker::free_collect_inactive_any(Interval* cur) {
4943   Interval* list = inactive_first(anyKind);
4944   while (list != Interval::end()) {
4945     set_use_pos(list, list-&gt;current_intersects_at(cur), true);
4946     list = list-&gt;next();
4947   }
4948 }
4949 
4950 void LinearScanWalker::spill_exclude_active_fixed() {
4951   Interval* list = active_first(fixedKind);
4952   while (list != Interval::end()) {
4953     exclude_from_use(list);
4954     list = list-&gt;next();
4955   }
4956 }
4957 
4958 void LinearScanWalker::spill_block_inactive_fixed(Interval* cur) {
4959   Interval* list = inactive_first(fixedKind);
4960   while (list != Interval::end()) {
4961     if (cur-&gt;to() &gt; list-&gt;current_from()) {
4962       set_block_pos(list, list-&gt;current_intersects_at(cur));
4963     } else {
4964       assert(list-&gt;current_intersects_at(cur) == -1, &quot;invalid optimization: intervals intersect&quot;);
4965     }
4966 
4967     list = list-&gt;next();
4968   }
4969 }
4970 
4971 void LinearScanWalker::spill_collect_active_any() {
4972   Interval* list = active_first(anyKind);
4973   while (list != Interval::end()) {
4974     set_use_pos(list, MIN2(list-&gt;next_usage(loopEndMarker, _current_position), list-&gt;to()), false);
4975     list = list-&gt;next();
4976   }
4977 }
4978 
4979 void LinearScanWalker::spill_collect_inactive_any(Interval* cur) {
4980   Interval* list = inactive_first(anyKind);
4981   while (list != Interval::end()) {
4982     if (list-&gt;current_intersects(cur)) {
4983       set_use_pos(list, MIN2(list-&gt;next_usage(loopEndMarker, _current_position), list-&gt;to()), false);
4984     }
4985     list = list-&gt;next();
4986   }
4987 }
4988 
4989 
4990 void LinearScanWalker::insert_move(int op_id, Interval* src_it, Interval* dst_it) {
4991   // output all moves here. When source and target are equal, the move is
4992   // optimized away later in assign_reg_nums
4993 
4994   op_id = (op_id + 1) &amp; ~1;
4995   BlockBegin* op_block = allocator()-&gt;block_of_op_with_id(op_id);
4996   assert(op_id &gt; 0 &amp;&amp; allocator()-&gt;block_of_op_with_id(op_id - 2) == op_block, &quot;cannot insert move at block boundary&quot;);
4997 
4998   // calculate index of instruction inside instruction list of current block
4999   // the minimal index (for a block with no spill moves) can be calculated because the
5000   // numbering of instructions is known.
5001   // When the block already contains spill moves, the index must be increased until the
5002   // correct index is reached.
5003   LIR_OpList* list = op_block-&gt;lir()-&gt;instructions_list();
5004   int index = (op_id - list-&gt;at(0)-&gt;id()) / 2;
5005   assert(list-&gt;at(index)-&gt;id() &lt;= op_id, &quot;error in calculation&quot;);
5006 
5007   while (list-&gt;at(index)-&gt;id() != op_id) {
5008     index++;
5009     assert(0 &lt;= index &amp;&amp; index &lt; list-&gt;length(), &quot;index out of bounds&quot;);
5010   }
5011   assert(1 &lt;= index &amp;&amp; index &lt; list-&gt;length(), &quot;index out of bounds&quot;);
5012   assert(list-&gt;at(index)-&gt;id() == op_id, &quot;error in calculation&quot;);
5013 
5014   // insert new instruction before instruction at position index
5015   _move_resolver.move_insert_position(op_block-&gt;lir(), index - 1);
5016   _move_resolver.add_mapping(src_it, dst_it);
5017 }
5018 
5019 
5020 int LinearScanWalker::find_optimal_split_pos(BlockBegin* min_block, BlockBegin* max_block, int max_split_pos) {
5021   int from_block_nr = min_block-&gt;linear_scan_number();
5022   int to_block_nr = max_block-&gt;linear_scan_number();
5023 
5024   assert(0 &lt;= from_block_nr &amp;&amp; from_block_nr &lt; block_count(), &quot;out of range&quot;);
5025   assert(0 &lt;= to_block_nr &amp;&amp; to_block_nr &lt; block_count(), &quot;out of range&quot;);
5026   assert(from_block_nr &lt; to_block_nr, &quot;must cross block boundary&quot;);
5027 
5028   // Try to split at end of max_block. If this would be after
5029   // max_split_pos, then use the begin of max_block
5030   int optimal_split_pos = max_block-&gt;last_lir_instruction_id() + 2;
5031   if (optimal_split_pos &gt; max_split_pos) {
5032     optimal_split_pos = max_block-&gt;first_lir_instruction_id();
5033   }
5034 
5035   int min_loop_depth = max_block-&gt;loop_depth();
5036   for (int i = to_block_nr - 1; i &gt;= from_block_nr; i--) {
5037     BlockBegin* cur = block_at(i);
5038 
5039     if (cur-&gt;loop_depth() &lt; min_loop_depth) {
5040       // block with lower loop-depth found -&gt; split at the end of this block
5041       min_loop_depth = cur-&gt;loop_depth();
5042       optimal_split_pos = cur-&gt;last_lir_instruction_id() + 2;
5043     }
5044   }
5045   assert(optimal_split_pos &gt; allocator()-&gt;max_lir_op_id() || allocator()-&gt;is_block_begin(optimal_split_pos), &quot;algorithm must move split pos to block boundary&quot;);
5046 
5047   return optimal_split_pos;
5048 }
5049 
5050 
5051 int LinearScanWalker::find_optimal_split_pos(Interval* it, int min_split_pos, int max_split_pos, bool do_loop_optimization) {
5052   int optimal_split_pos = -1;
5053   if (min_split_pos == max_split_pos) {
5054     // trivial case, no optimization of split position possible
5055     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      min-pos and max-pos are equal, no optimization possible&quot;));
5056     optimal_split_pos = min_split_pos;
5057 
5058   } else {
5059     assert(min_split_pos &lt; max_split_pos, &quot;must be true then&quot;);
5060     assert(min_split_pos &gt; 0, &quot;cannot access min_split_pos - 1 otherwise&quot;);
5061 
5062     // reason for using min_split_pos - 1: when the minimal split pos is exactly at the
5063     // beginning of a block, then min_split_pos is also a possible split position.
5064     // Use the block before as min_block, because then min_block-&gt;last_lir_instruction_id() + 2 == min_split_pos
5065     BlockBegin* min_block = allocator()-&gt;block_of_op_with_id(min_split_pos - 1);
5066 
5067     // reason for using max_split_pos - 1: otherwise there would be an assertion failure
5068     // when an interval ends at the end of the last block of the method
5069     // (in this case, max_split_pos == allocator()-&gt;max_lir_op_id() + 2, and there is no
5070     // block at this op_id)
5071     BlockBegin* max_block = allocator()-&gt;block_of_op_with_id(max_split_pos - 1);
5072 
5073     assert(min_block-&gt;linear_scan_number() &lt;= max_block-&gt;linear_scan_number(), &quot;invalid order&quot;);
5074     if (min_block == max_block) {
5075       // split position cannot be moved to block boundary, so split as late as possible
5076       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      cannot move split pos to block boundary because min_pos and max_pos are in same block&quot;));
5077       optimal_split_pos = max_split_pos;
5078 
5079     } else if (it-&gt;has_hole_between(max_split_pos - 1, max_split_pos) &amp;&amp; !allocator()-&gt;is_block_begin(max_split_pos)) {
5080       // Do not move split position if the interval has a hole before max_split_pos.
5081       // Intervals resulting from Phi-Functions have more than one definition (marked
5082       // as mustHaveRegister) with a hole before each definition. When the register is needed
5083       // for the second definition, an earlier reloading is unnecessary.
5084       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval has hole just before max_split_pos, so splitting at max_split_pos&quot;));
5085       optimal_split_pos = max_split_pos;
5086 
5087     } else {
5088       // seach optimal block boundary between min_split_pos and max_split_pos
5089       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      moving split pos to optimal block boundary between block B%d and B%d&quot;, min_block-&gt;block_id(), max_block-&gt;block_id()));
5090 
5091       if (do_loop_optimization) {
5092         // Loop optimization: if a loop-end marker is found between min- and max-position,
5093         // then split before this loop
5094         int loop_end_pos = it-&gt;next_usage_exact(loopEndMarker, min_block-&gt;last_lir_instruction_id() + 2);
5095         TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      loop optimization: loop end found at pos %d&quot;, loop_end_pos));
5096 
5097         assert(loop_end_pos &gt; min_split_pos, &quot;invalid order&quot;);
5098         if (loop_end_pos &lt; max_split_pos) {
5099           // loop-end marker found between min- and max-position
5100           // if it is not the end marker for the same loop as the min-position, then move
5101           // the max-position to this loop block.
5102           // Desired result: uses tagged as shouldHaveRegister inside a loop cause a reloading
5103           // of the interval (normally, only mustHaveRegister causes a reloading)
5104           BlockBegin* loop_block = allocator()-&gt;block_of_op_with_id(loop_end_pos);
5105 
5106           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval is used in loop that ends in block B%d, so trying to move max_block back from B%d to B%d&quot;, loop_block-&gt;block_id(), max_block-&gt;block_id(), loop_block-&gt;block_id()));
5107           assert(loop_block != min_block, &quot;loop_block and min_block must be different because block boundary is needed between&quot;);
5108 
5109           optimal_split_pos = find_optimal_split_pos(min_block, loop_block, loop_block-&gt;last_lir_instruction_id() + 2);
5110           if (optimal_split_pos == loop_block-&gt;last_lir_instruction_id() + 2) {
5111             optimal_split_pos = -1;
5112             TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      loop optimization not necessary&quot;));
5113           } else {
5114             TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      loop optimization successful&quot;));
5115           }
5116         }
5117       }
5118 
5119       if (optimal_split_pos == -1) {
5120         // not calculated by loop optimization
5121         optimal_split_pos = find_optimal_split_pos(min_block, max_block, max_split_pos);
5122       }
5123     }
5124   }
5125   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      optimal split position: %d&quot;, optimal_split_pos));
5126 
5127   return optimal_split_pos;
5128 }
5129 
5130 
5131 /*
5132   split an interval at the optimal position between min_split_pos and
5133   max_split_pos in two parts:
5134   1) the left part has already a location assigned
5135   2) the right part is sorted into to the unhandled-list
5136 */
5137 void LinearScanWalker::split_before_usage(Interval* it, int min_split_pos, int max_split_pos) {
5138   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;----- splitting interval: &quot;); it-&gt;print());
5139   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      between %d and %d&quot;, min_split_pos, max_split_pos));
5140 
5141   assert(it-&gt;from() &lt; min_split_pos,         &quot;cannot split at start of interval&quot;);
5142   assert(current_position() &lt; min_split_pos, &quot;cannot split before current position&quot;);
5143   assert(min_split_pos &lt;= max_split_pos,     &quot;invalid order&quot;);
5144   assert(max_split_pos &lt;= it-&gt;to(),          &quot;cannot split after end of interval&quot;);
5145 
5146   int optimal_split_pos = find_optimal_split_pos(it, min_split_pos, max_split_pos, true);
5147 
5148   assert(min_split_pos &lt;= optimal_split_pos &amp;&amp; optimal_split_pos &lt;= max_split_pos, &quot;out of range&quot;);
5149   assert(optimal_split_pos &lt;= it-&gt;to(),  &quot;cannot split after end of interval&quot;);
5150   assert(optimal_split_pos &gt; it-&gt;from(), &quot;cannot split at start of interval&quot;);
5151 
5152   if (optimal_split_pos == it-&gt;to() &amp;&amp; it-&gt;next_usage(mustHaveRegister, min_split_pos) == max_jint) {
5153     // the split position would be just before the end of the interval
5154     // -&gt; no split at all necessary
5155     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      no split necessary because optimal split position is at end of interval&quot;));
5156     return;
5157   }
5158 
5159   // must calculate this before the actual split is performed and before split position is moved to odd op_id
5160   bool move_necessary = !allocator()-&gt;is_block_begin(optimal_split_pos) &amp;&amp; !it-&gt;has_hole_between(optimal_split_pos - 1, optimal_split_pos);
5161 
5162   if (!allocator()-&gt;is_block_begin(optimal_split_pos)) {
5163     // move position before actual instruction (odd op_id)
5164     optimal_split_pos = (optimal_split_pos - 1) | 1;
5165   }
5166 
5167   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      splitting at position %d&quot;, optimal_split_pos));
5168   assert(allocator()-&gt;is_block_begin(optimal_split_pos) || (optimal_split_pos % 2 == 1), &quot;split pos must be odd when not on block boundary&quot;);
5169   assert(!allocator()-&gt;is_block_begin(optimal_split_pos) || (optimal_split_pos % 2 == 0), &quot;split pos must be even on block boundary&quot;);
5170 
5171   Interval* split_part = it-&gt;split(optimal_split_pos);
5172 
5173   allocator()-&gt;append_interval(split_part);
5174   allocator()-&gt;copy_register_flags(it, split_part);
5175   split_part-&gt;set_insert_move_when_activated(move_necessary);
5176   append_to_unhandled(unhandled_first_addr(anyKind), split_part);
5177 
5178   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      split interval in two parts (insert_move_when_activated: %d)&quot;, move_necessary));
5179   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); it-&gt;print());
5180   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); split_part-&gt;print());
5181 }
5182 
5183 /*
5184   split an interval at the optimal position between min_split_pos and
5185   max_split_pos in two parts:
5186   1) the left part has already a location assigned
5187   2) the right part is always on the stack and therefore ignored in further processing
5188 */
5189 void LinearScanWalker::split_for_spilling(Interval* it) {
5190   // calculate allowed range of splitting position
5191   int max_split_pos = current_position();
5192   int min_split_pos = MAX2(it-&gt;previous_usage(shouldHaveRegister, max_split_pos) + 1, it-&gt;from());
5193 
5194   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;----- splitting and spilling interval: &quot;); it-&gt;print());
5195   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      between %d and %d&quot;, min_split_pos, max_split_pos));
5196 
5197   assert(it-&gt;state() == activeState,     &quot;why spill interval that is not active?&quot;);
5198   assert(it-&gt;from() &lt;= min_split_pos,    &quot;cannot split before start of interval&quot;);
5199   assert(min_split_pos &lt;= max_split_pos, &quot;invalid order&quot;);
5200   assert(max_split_pos &lt; it-&gt;to(),       &quot;cannot split at end end of interval&quot;);
5201   assert(current_position() &lt; it-&gt;to(),  &quot;interval must not end before current position&quot;);
5202 
5203   if (min_split_pos == it-&gt;from()) {
5204     // the whole interval is never used, so spill it entirely to memory
5205     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      spilling entire interval because split pos is at beginning of interval&quot;));
5206     assert(it-&gt;first_usage(shouldHaveRegister) &gt; current_position(), &quot;interval must not have use position before current_position&quot;);
5207 
5208     allocator()-&gt;assign_spill_slot(it);
5209     allocator()-&gt;change_spill_state(it, min_split_pos);
5210 
5211     // Also kick parent intervals out of register to memory when they have no use
5212     // position. This avoids short interval in register surrounded by intervals in
5213     // memory -&gt; avoid useless moves from memory to register and back
5214     Interval* parent = it;
5215     while (parent != NULL &amp;&amp; parent-&gt;is_split_child()) {
5216       parent = parent-&gt;split_child_before_op_id(parent-&gt;from());
5217 
5218       if (parent-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
5219         if (parent-&gt;first_usage(shouldHaveRegister) == max_jint) {
5220           // parent is never used, so kick it out of its assigned register
5221           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      kicking out interval %d out of its register because it is never used&quot;, parent-&gt;reg_num()));
5222           allocator()-&gt;assign_spill_slot(parent);
5223         } else {
5224           // do not go further back because the register is actually used by the interval
5225           parent = NULL;
5226         }
5227       }
5228     }
5229 
5230   } else {
5231     // search optimal split pos, split interval and spill only the right hand part
5232     int optimal_split_pos = find_optimal_split_pos(it, min_split_pos, max_split_pos, false);
5233 
5234     assert(min_split_pos &lt;= optimal_split_pos &amp;&amp; optimal_split_pos &lt;= max_split_pos, &quot;out of range&quot;);
5235     assert(optimal_split_pos &lt; it-&gt;to(), &quot;cannot split at end of interval&quot;);
5236     assert(optimal_split_pos &gt;= it-&gt;from(), &quot;cannot split before start of interval&quot;);
5237 
5238     if (!allocator()-&gt;is_block_begin(optimal_split_pos)) {
5239       // move position before actual instruction (odd op_id)
5240       optimal_split_pos = (optimal_split_pos - 1) | 1;
5241     }
5242 
5243     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      splitting at position %d&quot;, optimal_split_pos));
5244     assert(allocator()-&gt;is_block_begin(optimal_split_pos)  || (optimal_split_pos % 2 == 1), &quot;split pos must be odd when not on block boundary&quot;);
5245     assert(!allocator()-&gt;is_block_begin(optimal_split_pos) || (optimal_split_pos % 2 == 0), &quot;split pos must be even on block boundary&quot;);
5246 
5247     Interval* spilled_part = it-&gt;split(optimal_split_pos);
5248     allocator()-&gt;append_interval(spilled_part);
5249     allocator()-&gt;assign_spill_slot(spilled_part);
5250     allocator()-&gt;change_spill_state(spilled_part, optimal_split_pos);
5251 
5252     if (!allocator()-&gt;is_block_begin(optimal_split_pos)) {
5253       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      inserting move from interval %d to %d&quot;, it-&gt;reg_num(), spilled_part-&gt;reg_num()));
5254       insert_move(optimal_split_pos, it, spilled_part);
5255     }
5256 
5257     // the current_split_child is needed later when moves are inserted for reloading
5258     assert(spilled_part-&gt;current_split_child() == it, &quot;overwriting wrong current_split_child&quot;);
5259     spilled_part-&gt;make_current_split_child();
5260 
5261     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      split interval in two parts&quot;));
5262     TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); it-&gt;print());
5263     TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); spilled_part-&gt;print());
5264   }
5265 }
5266 
5267 
5268 void LinearScanWalker::split_stack_interval(Interval* it) {
5269   int min_split_pos = current_position() + 1;
5270   int max_split_pos = MIN2(it-&gt;first_usage(shouldHaveRegister), it-&gt;to());
5271 
5272   split_before_usage(it, min_split_pos, max_split_pos);
5273 }
5274 
5275 void LinearScanWalker::split_when_partial_register_available(Interval* it, int register_available_until) {
5276   int min_split_pos = MAX2(it-&gt;previous_usage(shouldHaveRegister, register_available_until), it-&gt;from() + 1);
5277   int max_split_pos = register_available_until;
5278 
5279   split_before_usage(it, min_split_pos, max_split_pos);
5280 }
5281 
5282 void LinearScanWalker::split_and_spill_interval(Interval* it) {
5283   assert(it-&gt;state() == activeState || it-&gt;state() == inactiveState, &quot;other states not allowed&quot;);
5284 
5285   int current_pos = current_position();
5286   if (it-&gt;state() == inactiveState) {
5287     // the interval is currently inactive, so no spill slot is needed for now.
5288     // when the split part is activated, the interval has a new chance to get a register,
5289     // so in the best case no stack slot is necessary
5290     assert(it-&gt;has_hole_between(current_pos - 1, current_pos + 1), &quot;interval can not be inactive otherwise&quot;);
5291     split_before_usage(it, current_pos + 1, current_pos + 1);
5292 
5293   } else {
5294     // search the position where the interval must have a register and split
5295     // at the optimal position before.
5296     // The new created part is added to the unhandled list and will get a register
5297     // when it is activated
5298     int min_split_pos = current_pos + 1;
5299     int max_split_pos = MIN2(it-&gt;next_usage(mustHaveRegister, min_split_pos), it-&gt;to());
5300 
5301     split_before_usage(it, min_split_pos, max_split_pos);
5302 
5303     assert(it-&gt;next_usage(mustHaveRegister, current_pos) == max_jint, &quot;the remaining part is spilled to stack and therefore has no register&quot;);
5304     split_for_spilling(it);
5305   }
5306 }
5307 
5308 
5309 int LinearScanWalker::find_free_reg(int reg_needed_until, int interval_to, int hint_reg, int ignore_reg, bool* need_split) {
5310   int min_full_reg = any_reg;
5311   int max_partial_reg = any_reg;
5312 
5313   for (int i = _first_reg; i &lt;= _last_reg; i++) {
5314     if (i == ignore_reg) {
5315       // this register must be ignored
5316 
5317     } else if (_use_pos[i] &gt;= interval_to) {
5318       // this register is free for the full interval
5319       if (min_full_reg == any_reg || i == hint_reg || (_use_pos[i] &lt; _use_pos[min_full_reg] &amp;&amp; min_full_reg != hint_reg)) {
5320         min_full_reg = i;
5321       }
5322     } else if (_use_pos[i] &gt; reg_needed_until) {
5323       // this register is at least free until reg_needed_until
5324       if (max_partial_reg == any_reg || i == hint_reg || (_use_pos[i] &gt; _use_pos[max_partial_reg] &amp;&amp; max_partial_reg != hint_reg)) {
5325         max_partial_reg = i;
5326       }
5327     }
5328   }
5329 
5330   if (min_full_reg != any_reg) {
5331     return min_full_reg;
5332   } else if (max_partial_reg != any_reg) {
5333     *need_split = true;
5334     return max_partial_reg;
5335   } else {
5336     return any_reg;
5337   }
5338 }
5339 
5340 int LinearScanWalker::find_free_double_reg(int reg_needed_until, int interval_to, int hint_reg, bool* need_split) {
5341   assert((_last_reg - _first_reg + 1) % 2 == 0, &quot;adjust algorithm&quot;);
5342 
5343   int min_full_reg = any_reg;
5344   int max_partial_reg = any_reg;
5345 
5346   for (int i = _first_reg; i &lt; _last_reg; i+=2) {
5347     if (_use_pos[i] &gt;= interval_to &amp;&amp; _use_pos[i + 1] &gt;= interval_to) {
5348       // this register is free for the full interval
5349       if (min_full_reg == any_reg || i == hint_reg || (_use_pos[i] &lt; _use_pos[min_full_reg] &amp;&amp; min_full_reg != hint_reg)) {
5350         min_full_reg = i;
5351       }
5352     } else if (_use_pos[i] &gt; reg_needed_until &amp;&amp; _use_pos[i + 1] &gt; reg_needed_until) {
5353       // this register is at least free until reg_needed_until
5354       if (max_partial_reg == any_reg || i == hint_reg || (_use_pos[i] &gt; _use_pos[max_partial_reg] &amp;&amp; max_partial_reg != hint_reg)) {
5355         max_partial_reg = i;
5356       }
5357     }
5358   }
5359 
5360   if (min_full_reg != any_reg) {
5361     return min_full_reg;
5362   } else if (max_partial_reg != any_reg) {
5363     *need_split = true;
5364     return max_partial_reg;
5365   } else {
5366     return any_reg;
5367   }
5368 }
5369 
5370 
5371 bool LinearScanWalker::alloc_free_reg(Interval* cur) {
5372   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot;trying to find free register for &quot;); cur-&gt;print());
5373 
5374   init_use_lists(true);
5375   free_exclude_active_fixed();
5376   free_exclude_active_any();
5377   free_collect_inactive_fixed(cur);
5378   free_collect_inactive_any(cur);
5379   assert(unhandled_first(fixedKind) == Interval::end(), &quot;must not have unhandled fixed intervals because all fixed intervals have a use at position 0&quot;);
5380 
5381   // _use_pos contains the start of the next interval that has this register assigned
5382   // (either as a fixed register or a normal allocated register in the past)
5383   // only intervals overlapping with cur are processed, non-overlapping invervals can be ignored safely
5384   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      state of registers:&quot;));
5385   TRACE_LINEAR_SCAN(4, for (int i = _first_reg; i &lt;= _last_reg; i++) tty-&gt;print_cr(&quot;      reg %d: use_pos: %d&quot;, i, _use_pos[i]));
5386 
5387   int hint_reg, hint_regHi;
5388   Interval* register_hint = cur-&gt;register_hint();
5389   if (register_hint != NULL) {
5390     hint_reg = register_hint-&gt;assigned_reg();
5391     hint_regHi = register_hint-&gt;assigned_regHi();
5392 
5393     if (allocator()-&gt;is_precolored_cpu_interval(register_hint)) {
5394       assert(hint_reg != any_reg &amp;&amp; hint_regHi == any_reg, &quot;must be for fixed intervals&quot;);
5395       hint_regHi = hint_reg + 1;  // connect e.g. eax-edx
5396     }
5397     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;      hint registers %d, %d from interval &quot;, hint_reg, hint_regHi); register_hint-&gt;print());
5398 
5399   } else {
5400     hint_reg = any_reg;
5401     hint_regHi = any_reg;
5402   }
5403   assert(hint_reg == any_reg || hint_reg != hint_regHi, &quot;hint reg and regHi equal&quot;);
5404   assert(cur-&gt;assigned_reg() == any_reg &amp;&amp; cur-&gt;assigned_regHi() == any_reg, &quot;register already assigned to interval&quot;);
5405 
5406   // the register must be free at least until this position
5407   int reg_needed_until = cur-&gt;from() + 1;
5408   int interval_to = cur-&gt;to();
5409 
5410   bool need_split = false;
5411   int split_pos;
5412   int reg;
5413   int regHi = any_reg;
5414 
5415   if (_adjacent_regs) {
5416     reg = find_free_double_reg(reg_needed_until, interval_to, hint_reg, &amp;need_split);
5417     regHi = reg + 1;
5418     if (reg == any_reg) {
5419       return false;
5420     }
5421     split_pos = MIN2(_use_pos[reg], _use_pos[regHi]);
5422 
5423   } else {
5424     reg = find_free_reg(reg_needed_until, interval_to, hint_reg, any_reg, &amp;need_split);
5425     if (reg == any_reg) {
5426       return false;
5427     }
5428     split_pos = _use_pos[reg];
5429 
5430     if (_num_phys_regs == 2) {
5431       regHi = find_free_reg(reg_needed_until, interval_to, hint_regHi, reg, &amp;need_split);
5432 
5433       if (_use_pos[reg] &lt; interval_to &amp;&amp; regHi == any_reg) {
5434         // do not split interval if only one register can be assigned until the split pos
5435         // (when one register is found for the whole interval, split&amp;spill is only
5436         // performed for the hi register)
5437         return false;
5438 
5439       } else if (regHi != any_reg) {
5440         split_pos = MIN2(split_pos, _use_pos[regHi]);
5441 
5442         // sort register numbers to prevent e.g. a move from eax,ebx to ebx,eax
5443         if (reg &gt; regHi) {
5444           int temp = reg;
5445           reg = regHi;
5446           regHi = temp;
5447         }
5448       }
5449     }
5450   }
5451 
5452   cur-&gt;assign_reg(reg, regHi);
5453   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;selected register %d, %d&quot;, reg, regHi));
5454 
5455   assert(split_pos &gt; 0, &quot;invalid split_pos&quot;);
5456   if (need_split) {
5457     // register not available for full interval, so split it
5458     split_when_partial_register_available(cur, split_pos);
5459   }
5460 
5461   // only return true if interval is completely assigned
5462   return _num_phys_regs == 1 || regHi != any_reg;
5463 }
5464 
5465 
5466 int LinearScanWalker::find_locked_reg(int reg_needed_until, int interval_to, int ignore_reg, bool* need_split) {
5467   int max_reg = any_reg;
5468 
5469   for (int i = _first_reg; i &lt;= _last_reg; i++) {
5470     if (i == ignore_reg) {
5471       // this register must be ignored
5472 
5473     } else if (_use_pos[i] &gt; reg_needed_until) {
5474       if (max_reg == any_reg || _use_pos[i] &gt; _use_pos[max_reg]) {
5475         max_reg = i;
5476       }
5477     }
5478   }
5479 
5480   if (max_reg != any_reg &amp;&amp; _block_pos[max_reg] &lt;= interval_to) {
5481     *need_split = true;
5482   }
5483 
5484   return max_reg;
5485 }
5486 
5487 int LinearScanWalker::find_locked_double_reg(int reg_needed_until, int interval_to, bool* need_split) {
5488   assert((_last_reg - _first_reg + 1) % 2 == 0, &quot;adjust algorithm&quot;);
5489 
5490   int max_reg = any_reg;
5491 
5492   for (int i = _first_reg; i &lt; _last_reg; i+=2) {
5493     if (_use_pos[i] &gt; reg_needed_until &amp;&amp; _use_pos[i + 1] &gt; reg_needed_until) {
5494       if (max_reg == any_reg || _use_pos[i] &gt; _use_pos[max_reg]) {
5495         max_reg = i;
5496       }
5497     }
5498   }
5499 
5500   if (max_reg != any_reg &amp;&amp;
5501       (_block_pos[max_reg] &lt;= interval_to || _block_pos[max_reg + 1] &lt;= interval_to)) {
5502     *need_split = true;
5503   }
5504 
5505   return max_reg;
5506 }
5507 
5508 void LinearScanWalker::split_and_spill_intersecting_intervals(int reg, int regHi) {
5509   assert(reg != any_reg, &quot;no register assigned&quot;);
5510 
5511   for (int i = 0; i &lt; _spill_intervals[reg]-&gt;length(); i++) {
5512     Interval* it = _spill_intervals[reg]-&gt;at(i);
5513     remove_from_list(it);
5514     split_and_spill_interval(it);
5515   }
5516 
5517   if (regHi != any_reg) {
5518     IntervalList* processed = _spill_intervals[reg];
5519     for (int i = 0; i &lt; _spill_intervals[regHi]-&gt;length(); i++) {
5520       Interval* it = _spill_intervals[regHi]-&gt;at(i);
5521       if (processed-&gt;find(it) == -1) {
5522         remove_from_list(it);
5523         split_and_spill_interval(it);
5524       }
5525     }
5526   }
5527 }
5528 
5529 
5530 // Split an Interval and spill it to memory so that cur can be placed in a register
5531 void LinearScanWalker::alloc_locked_reg(Interval* cur) {
5532   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot;need to split and spill to get register for &quot;); cur-&gt;print());
5533 
5534   // collect current usage of registers
5535   init_use_lists(false);
5536   spill_exclude_active_fixed();
5537   assert(unhandled_first(fixedKind) == Interval::end(), &quot;must not have unhandled fixed intervals because all fixed intervals have a use at position 0&quot;);
5538   spill_block_inactive_fixed(cur);
5539   spill_collect_active_any();
5540   spill_collect_inactive_any(cur);
5541 
5542 #ifndef PRODUCT
5543   if (TraceLinearScanLevel &gt;= 4) {
5544     tty-&gt;print_cr(&quot;      state of registers:&quot;);
5545     for (int i = _first_reg; i &lt;= _last_reg; i++) {
5546       tty-&gt;print(&quot;      reg %d: use_pos: %d, block_pos: %d, intervals: &quot;, i, _use_pos[i], _block_pos[i]);
5547       for (int j = 0; j &lt; _spill_intervals[i]-&gt;length(); j++) {
5548         tty-&gt;print(&quot;%d &quot;, _spill_intervals[i]-&gt;at(j)-&gt;reg_num());
5549       }
5550       tty-&gt;cr();
5551     }
5552   }
5553 #endif
5554 
5555   // the register must be free at least until this position
5556   int reg_needed_until = MIN2(cur-&gt;first_usage(mustHaveRegister), cur-&gt;from() + 1);
5557   int interval_to = cur-&gt;to();
5558   assert (reg_needed_until &gt; 0 &amp;&amp; reg_needed_until &lt; max_jint, &quot;interval has no use&quot;);
5559 
5560   int split_pos = 0;
5561   int use_pos = 0;
5562   bool need_split = false;
5563   int reg, regHi;
5564 
5565   if (_adjacent_regs) {
5566     reg = find_locked_double_reg(reg_needed_until, interval_to, &amp;need_split);
5567     regHi = reg + 1;
5568 
5569     if (reg != any_reg) {
5570       use_pos = MIN2(_use_pos[reg], _use_pos[regHi]);
5571       split_pos = MIN2(_block_pos[reg], _block_pos[regHi]);
5572     }
5573   } else {
5574     reg = find_locked_reg(reg_needed_until, interval_to, cur-&gt;assigned_reg(), &amp;need_split);
5575     regHi = any_reg;
5576 
5577     if (reg != any_reg) {
5578       use_pos = _use_pos[reg];
5579       split_pos = _block_pos[reg];
5580 
5581       if (_num_phys_regs == 2) {
5582         if (cur-&gt;assigned_reg() != any_reg) {
5583           regHi = reg;
5584           reg = cur-&gt;assigned_reg();
5585         } else {
5586           regHi = find_locked_reg(reg_needed_until, interval_to, reg, &amp;need_split);
5587           if (regHi != any_reg) {
5588             use_pos = MIN2(use_pos, _use_pos[regHi]);
5589             split_pos = MIN2(split_pos, _block_pos[regHi]);
5590           }
5591         }
5592 
5593         if (regHi != any_reg &amp;&amp; reg &gt; regHi) {
5594           // sort register numbers to prevent e.g. a move from eax,ebx to ebx,eax
5595           int temp = reg;
5596           reg = regHi;
5597           regHi = temp;
5598         }
5599       }
5600     }
5601   }
5602 
5603   if (reg == any_reg || (_num_phys_regs == 2 &amp;&amp; regHi == any_reg) || use_pos &lt;= cur-&gt;first_usage(mustHaveRegister)) {
5604     // the first use of cur is later than the spilling position -&gt; spill cur
5605     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;able to spill current interval. first_usage(register): %d, use_pos: %d&quot;, cur-&gt;first_usage(mustHaveRegister), use_pos));
5606 
5607     if (cur-&gt;first_usage(mustHaveRegister) &lt;= cur-&gt;from() + 1) {
5608       assert(false, &quot;cannot spill interval that is used in first instruction (possible reason: no register found)&quot;);
5609       // assign a reasonable register and do a bailout in product mode to avoid errors
5610       allocator()-&gt;assign_spill_slot(cur);
5611       BAILOUT(&quot;LinearScan: no register found&quot;);
5612     }
5613 
5614     split_and_spill_interval(cur);
5615   } else {
5616     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;decided to use register %d, %d&quot;, reg, regHi));
5617     assert(reg != any_reg &amp;&amp; (_num_phys_regs == 1 || regHi != any_reg), &quot;no register found&quot;);
5618     assert(split_pos &gt; 0, &quot;invalid split_pos&quot;);
5619     assert(need_split == false || split_pos &gt; cur-&gt;from(), &quot;splitting interval at from&quot;);
5620 
5621     cur-&gt;assign_reg(reg, regHi);
5622     if (need_split) {
5623       // register not available for full interval, so split it
5624       split_when_partial_register_available(cur, split_pos);
5625     }
5626 
5627     // perform splitting and spilling for all affected intervalls
5628     split_and_spill_intersecting_intervals(reg, regHi);
5629   }
5630 }
5631 
5632 bool LinearScanWalker::no_allocation_possible(Interval* cur) {
5633 #ifdef X86
5634   // fast calculation of intervals that can never get a register because the
5635   // the next instruction is a call that blocks all registers
5636   // Note: this does not work if callee-saved registers are available (e.g. on Sparc)
5637 
5638   // check if this interval is the result of a split operation
5639   // (an interval got a register until this position)
5640   int pos = cur-&gt;from();
5641   if ((pos &amp; 1) == 1) {
5642     // the current instruction is a call that blocks all registers
5643     if (pos &lt; allocator()-&gt;max_lir_op_id() &amp;&amp; allocator()-&gt;has_call(pos + 1)) {
5644       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      free register cannot be available because all registers blocked by following call&quot;));
5645 
5646       // safety check that there is really no register available
5647       assert(alloc_free_reg(cur) == false, &quot;found a register for this interval&quot;);
5648       return true;
5649     }
5650 
5651   }
5652 #endif
5653   return false;
5654 }
5655 
5656 void LinearScanWalker::init_vars_for_alloc(Interval* cur) {
5657   BasicType type = cur-&gt;type();
5658   _num_phys_regs = LinearScan::num_physical_regs(type);
5659   _adjacent_regs = LinearScan::requires_adjacent_regs(type);
5660 
5661   if (pd_init_regs_for_alloc(cur)) {
5662     // the appropriate register range was selected.
5663   } else if (type == T_FLOAT || type == T_DOUBLE) {
5664     _first_reg = pd_first_fpu_reg;
5665     _last_reg = pd_last_fpu_reg;
5666   } else {
5667     _first_reg = pd_first_cpu_reg;
5668     _last_reg = FrameMap::last_cpu_reg();
5669   }
5670 
5671   assert(0 &lt;= _first_reg &amp;&amp; _first_reg &lt; LinearScan::nof_regs, &quot;out of range&quot;);
5672   assert(0 &lt;= _last_reg &amp;&amp; _last_reg &lt; LinearScan::nof_regs, &quot;out of range&quot;);
5673 }
5674 
5675 
5676 bool LinearScanWalker::is_move(LIR_Op* op, Interval* from, Interval* to) {
5677   if (op-&gt;code() != lir_move) {
5678     return false;
5679   }
5680   assert(op-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
5681 
5682   LIR_Opr in = ((LIR_Op1*)op)-&gt;in_opr();
5683   LIR_Opr res = ((LIR_Op1*)op)-&gt;result_opr();
5684   return in-&gt;is_virtual() &amp;&amp; res-&gt;is_virtual() &amp;&amp; in-&gt;vreg_number() == from-&gt;reg_num() &amp;&amp; res-&gt;vreg_number() == to-&gt;reg_num();
5685 }
5686 
5687 // optimization (especially for phi functions of nested loops):
5688 // assign same spill slot to non-intersecting intervals
5689 void LinearScanWalker::combine_spilled_intervals(Interval* cur) {
5690   if (cur-&gt;is_split_child()) {
5691     // optimization is only suitable for split parents
5692     return;
5693   }
5694 
5695   Interval* register_hint = cur-&gt;register_hint(false);
5696   if (register_hint == NULL) {
5697     // cur is not the target of a move, otherwise register_hint would be set
5698     return;
5699   }
5700   assert(register_hint-&gt;is_split_parent(), &quot;register hint must be split parent&quot;);
5701 
5702   if (cur-&gt;spill_state() != noOptimization || register_hint-&gt;spill_state() != noOptimization) {
5703     // combining the stack slots for intervals where spill move optimization is applied
5704     // is not benefitial and would cause problems
5705     return;
5706   }
5707 
5708   int begin_pos = cur-&gt;from();
5709   int end_pos = cur-&gt;to();
5710   if (end_pos &gt; allocator()-&gt;max_lir_op_id() || (begin_pos &amp; 1) != 0 || (end_pos &amp; 1) != 0) {
5711     // safety check that lir_op_with_id is allowed
5712     return;
5713   }
5714 
5715   if (!is_move(allocator()-&gt;lir_op_with_id(begin_pos), register_hint, cur) || !is_move(allocator()-&gt;lir_op_with_id(end_pos), cur, register_hint)) {
5716     // cur and register_hint are not connected with two moves
5717     return;
5718   }
5719 
5720   Interval* begin_hint = register_hint-&gt;split_child_at_op_id(begin_pos, LIR_OpVisitState::inputMode);
5721   Interval* end_hint = register_hint-&gt;split_child_at_op_id(end_pos, LIR_OpVisitState::outputMode);
5722   if (begin_hint == end_hint || begin_hint-&gt;to() != begin_pos || end_hint-&gt;from() != end_pos) {
5723     // register_hint must be split, otherwise the re-writing of use positions does not work
5724     return;
5725   }
5726 
5727   assert(begin_hint-&gt;assigned_reg() != any_reg, &quot;must have register assigned&quot;);
5728   assert(end_hint-&gt;assigned_reg() == any_reg, &quot;must not have register assigned&quot;);
5729   assert(cur-&gt;first_usage(mustHaveRegister) == begin_pos, &quot;must have use position at begin of interval because of move&quot;);
5730   assert(end_hint-&gt;first_usage(mustHaveRegister) == end_pos, &quot;must have use position at begin of interval because of move&quot;);
5731 
5732   if (begin_hint-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
5733     // register_hint is not spilled at begin_pos, so it would not be benefitial to immediately spill cur
5734     return;
5735   }
5736   assert(register_hint-&gt;canonical_spill_slot() != -1, &quot;must be set when part of interval was spilled&quot;);
5737 
5738   // modify intervals such that cur gets the same stack slot as register_hint
5739   // delete use positions to prevent the intervals to get a register at beginning
5740   cur-&gt;set_canonical_spill_slot(register_hint-&gt;canonical_spill_slot());
5741   cur-&gt;remove_first_use_pos();
5742   end_hint-&gt;remove_first_use_pos();
5743 }
5744 
5745 
5746 // allocate a physical register or memory location to an interval
5747 bool LinearScanWalker::activate_current() {
5748   Interval* cur = current();
5749   bool result = true;
5750 
5751   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;+++++ activating interval &quot;); cur-&gt;print());
5752   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      split_parent: %d, insert_move_when_activated: %d&quot;, cur-&gt;split_parent()-&gt;reg_num(), cur-&gt;insert_move_when_activated()));
5753 
5754   if (cur-&gt;assigned_reg() &gt;= LinearScan::nof_regs) {
5755     // activating an interval that has a stack slot assigned -&gt; split it at first use position
5756     // used for method parameters
5757     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval has spill slot assigned (method parameter) -&gt; split it before first use&quot;));
5758 
5759     split_stack_interval(cur);
5760     result = false;
5761 
5762   } else if (allocator()-&gt;gen()-&gt;is_vreg_flag_set(cur-&gt;reg_num(), LIRGenerator::must_start_in_memory)) {
5763     // activating an interval that must start in a stack slot, but may get a register later
5764     // used for lir_roundfp: rounding is done by store to stack and reload later
5765     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval must start in stack slot -&gt; split it before first use&quot;));
5766     assert(cur-&gt;assigned_reg() == any_reg &amp;&amp; cur-&gt;assigned_regHi() == any_reg, &quot;register already assigned&quot;);
5767 
5768     allocator()-&gt;assign_spill_slot(cur);
5769     split_stack_interval(cur);
5770     result = false;
5771 
5772   } else if (cur-&gt;assigned_reg() == any_reg) {
5773     // interval has not assigned register -&gt; normal allocation
5774     // (this is the normal case for most intervals)
5775     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      normal allocation of register&quot;));
5776 
5777     // assign same spill slot to non-intersecting intervals
5778     combine_spilled_intervals(cur);
5779 
5780     init_vars_for_alloc(cur);
5781     if (no_allocation_possible(cur) || !alloc_free_reg(cur)) {
5782       // no empty register available.
5783       // split and spill another interval so that this interval gets a register
5784       alloc_locked_reg(cur);
5785     }
5786 
5787     // spilled intervals need not be move to active-list
5788     if (cur-&gt;assigned_reg() &gt;= LinearScan::nof_regs) {
5789       result = false;
5790     }
5791   }
5792 
5793   // load spilled values that become active from stack slot to register
5794   if (cur-&gt;insert_move_when_activated()) {
5795     assert(cur-&gt;is_split_child(), &quot;must be&quot;);
5796     assert(cur-&gt;current_split_child() != NULL, &quot;must be&quot;);
5797     assert(cur-&gt;current_split_child()-&gt;reg_num() != cur-&gt;reg_num(), &quot;cannot insert move between same interval&quot;);
5798     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;Inserting move from interval %d to %d because insert_move_when_activated is set&quot;, cur-&gt;current_split_child()-&gt;reg_num(), cur-&gt;reg_num()));
5799 
5800     insert_move(cur-&gt;from(), cur-&gt;current_split_child(), cur);
5801   }
5802   cur-&gt;make_current_split_child();
5803 
5804   return result; // true = interval is moved to active list
5805 }
5806 
5807 
5808 // Implementation of EdgeMoveOptimizer
5809 
5810 EdgeMoveOptimizer::EdgeMoveOptimizer() :
5811   _edge_instructions(4),
5812   _edge_instructions_idx(4)
5813 {
5814 }
5815 
5816 void EdgeMoveOptimizer::optimize(BlockList* code) {
5817   EdgeMoveOptimizer optimizer = EdgeMoveOptimizer();
5818 
5819   // ignore the first block in the list (index 0 is not processed)
5820   for (int i = code-&gt;length() - 1; i &gt;= 1; i--) {
5821     BlockBegin* block = code-&gt;at(i);
5822 
5823     if (block-&gt;number_of_preds() &gt; 1 &amp;&amp; !block-&gt;is_set(BlockBegin::exception_entry_flag)) {
5824       optimizer.optimize_moves_at_block_end(block);
5825     }
5826     if (block-&gt;number_of_sux() == 2) {
5827       optimizer.optimize_moves_at_block_begin(block);
5828     }
5829   }
5830 }
5831 
5832 
5833 // clear all internal data structures
5834 void EdgeMoveOptimizer::init_instructions() {
5835   _edge_instructions.clear();
5836   _edge_instructions_idx.clear();
5837 }
5838 
5839 // append a lir-instruction-list and the index of the current operation in to the list
5840 void EdgeMoveOptimizer::append_instructions(LIR_OpList* instructions, int instructions_idx) {
5841   _edge_instructions.append(instructions);
5842   _edge_instructions_idx.append(instructions_idx);
5843 }
5844 
5845 // return the current operation of the given edge (predecessor or successor)
5846 LIR_Op* EdgeMoveOptimizer::instruction_at(int edge) {
5847   LIR_OpList* instructions = _edge_instructions.at(edge);
5848   int idx = _edge_instructions_idx.at(edge);
5849 
5850   if (idx &lt; instructions-&gt;length()) {
5851     return instructions-&gt;at(idx);
5852   } else {
5853     return NULL;
5854   }
5855 }
5856 
5857 // removes the current operation of the given edge (predecessor or successor)
5858 void EdgeMoveOptimizer::remove_cur_instruction(int edge, bool decrement_index) {
5859   LIR_OpList* instructions = _edge_instructions.at(edge);
5860   int idx = _edge_instructions_idx.at(edge);
5861   instructions-&gt;remove_at(idx);
5862 
5863   if (decrement_index) {
5864     _edge_instructions_idx.at_put(edge, idx - 1);
5865   }
5866 }
5867 
5868 
5869 bool EdgeMoveOptimizer::operations_different(LIR_Op* op1, LIR_Op* op2) {
5870   if (op1 == NULL || op2 == NULL) {
5871     // at least one block is already empty -&gt; no optimization possible
5872     return true;
5873   }
5874 
5875   if (op1-&gt;code() == lir_move &amp;&amp; op2-&gt;code() == lir_move) {
5876     assert(op1-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
5877     assert(op2-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
5878     LIR_Op1* move1 = (LIR_Op1*)op1;
5879     LIR_Op1* move2 = (LIR_Op1*)op2;
5880     if (move1-&gt;info() == move2-&gt;info() &amp;&amp; move1-&gt;in_opr() == move2-&gt;in_opr() &amp;&amp; move1-&gt;result_opr() == move2-&gt;result_opr()) {
5881       // these moves are exactly equal and can be optimized
5882       return false;
5883     }
5884 
5885   } else if (op1-&gt;code() == lir_fxch &amp;&amp; op2-&gt;code() == lir_fxch) {
5886     assert(op1-&gt;as_Op1() != NULL, &quot;fxch must be LIR_Op1&quot;);
5887     assert(op2-&gt;as_Op1() != NULL, &quot;fxch must be LIR_Op1&quot;);
5888     LIR_Op1* fxch1 = (LIR_Op1*)op1;
5889     LIR_Op1* fxch2 = (LIR_Op1*)op2;
5890     if (fxch1-&gt;in_opr()-&gt;as_jint() == fxch2-&gt;in_opr()-&gt;as_jint()) {
5891       // equal FPU stack operations can be optimized
5892       return false;
5893     }
5894 
5895   } else if (op1-&gt;code() == lir_fpop_raw &amp;&amp; op2-&gt;code() == lir_fpop_raw) {
5896     // equal FPU stack operations can be optimized
5897     return false;
5898   }
5899 
5900   // no optimization possible
5901   return true;
5902 }
5903 
5904 void EdgeMoveOptimizer::optimize_moves_at_block_end(BlockBegin* block) {
5905   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;optimizing moves at end of block B%d&quot;, block-&gt;block_id()));
5906 
5907   if (block-&gt;is_predecessor(block)) {
5908     // currently we can&#39;t handle this correctly.
5909     return;
5910   }
5911 
5912   init_instructions();
5913   int num_preds = block-&gt;number_of_preds();
5914   assert(num_preds &gt; 1, &quot;do not call otherwise&quot;);
5915   assert(!block-&gt;is_set(BlockBegin::exception_entry_flag), &quot;exception handlers not allowed&quot;);
5916 
5917   // setup a list with the lir-instructions of all predecessors
5918   int i;
5919   for (i = 0; i &lt; num_preds; i++) {
5920     BlockBegin* pred = block-&gt;pred_at(i);
5921     LIR_OpList* pred_instructions = pred-&gt;lir()-&gt;instructions_list();
5922 
5923     if (pred-&gt;number_of_sux() != 1) {
5924       // this can happen with switch-statements where multiple edges are between
5925       // the same blocks.
5926       return;
5927     }
5928 
5929     assert(pred-&gt;number_of_sux() == 1, &quot;can handle only one successor&quot;);
5930     assert(pred-&gt;sux_at(0) == block, &quot;invalid control flow&quot;);
5931     assert(pred_instructions-&gt;last()-&gt;code() == lir_branch, &quot;block with successor must end with branch&quot;);
5932     assert(pred_instructions-&gt;last()-&gt;as_OpBranch() != NULL, &quot;branch must be LIR_OpBranch&quot;);
5933     assert(pred_instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;block must end with unconditional branch&quot;);
5934 
5935     if (pred_instructions-&gt;last()-&gt;info() != NULL) {
5936       // can not optimize instructions when debug info is needed
5937       return;
5938     }
5939 
5940     // ignore the unconditional branch at the end of the block
5941     append_instructions(pred_instructions, pred_instructions-&gt;length() - 2);
5942   }
5943 
5944 
5945   // process lir-instructions while all predecessors end with the same instruction
5946   while (true) {
5947     LIR_Op* op = instruction_at(0);
5948     for (i = 1; i &lt; num_preds; i++) {
5949       if (operations_different(op, instruction_at(i))) {
5950         // these instructions are different and cannot be optimized -&gt;
5951         // no further optimization possible
5952         return;
5953       }
5954     }
5955 
5956     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;found instruction that is equal in all %d predecessors: &quot;, num_preds); op-&gt;print());
5957 
5958     // insert the instruction at the beginning of the current block
5959     block-&gt;lir()-&gt;insert_before(1, op);
5960 
5961     // delete the instruction at the end of all predecessors
5962     for (i = 0; i &lt; num_preds; i++) {
5963       remove_cur_instruction(i, true);
5964     }
5965   }
5966 }
5967 
5968 
5969 void EdgeMoveOptimizer::optimize_moves_at_block_begin(BlockBegin* block) {
5970   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;optimization moves at begin of block B%d&quot;, block-&gt;block_id()));
5971 
5972   init_instructions();
5973   int num_sux = block-&gt;number_of_sux();
5974 
5975   LIR_OpList* cur_instructions = block-&gt;lir()-&gt;instructions_list();
5976 
5977   assert(num_sux == 2, &quot;method should not be called otherwise&quot;);
5978   assert(cur_instructions-&gt;last()-&gt;code() == lir_branch, &quot;block with successor must end with branch&quot;);
5979   assert(cur_instructions-&gt;last()-&gt;as_OpBranch() != NULL, &quot;branch must be LIR_OpBranch&quot;);
5980   assert(cur_instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;block must end with unconditional branch&quot;);
5981 
5982   if (cur_instructions-&gt;last()-&gt;info() != NULL) {
5983     // can no optimize instructions when debug info is needed
5984     return;
5985   }
5986 
5987   LIR_Op* branch = cur_instructions-&gt;at(cur_instructions-&gt;length() - 2);
5988   if (branch-&gt;info() != NULL || (branch-&gt;code() != lir_branch &amp;&amp; branch-&gt;code() != lir_cond_float_branch)) {
5989     // not a valid case for optimization
5990     // currently, only blocks that end with two branches (conditional branch followed
5991     // by unconditional branch) are optimized
5992     return;
5993   }
5994 
5995   // now it is guaranteed that the block ends with two branch instructions.
5996   // the instructions are inserted at the end of the block before these two branches
5997   int insert_idx = cur_instructions-&gt;length() - 2;
5998 
5999   int i;
6000 #ifdef ASSERT
6001   for (i = insert_idx - 1; i &gt;= 0; i--) {
6002     LIR_Op* op = cur_instructions-&gt;at(i);
6003     if ((op-&gt;code() == lir_branch || op-&gt;code() == lir_cond_float_branch) &amp;&amp; ((LIR_OpBranch*)op)-&gt;block() != NULL) {
6004       assert(false, &quot;block with two successors can have only two branch instructions&quot;);
6005     }
6006   }
6007 #endif
6008 
6009   // setup a list with the lir-instructions of all successors
6010   for (i = 0; i &lt; num_sux; i++) {
6011     BlockBegin* sux = block-&gt;sux_at(i);
6012     LIR_OpList* sux_instructions = sux-&gt;lir()-&gt;instructions_list();
6013 
6014     assert(sux_instructions-&gt;at(0)-&gt;code() == lir_label, &quot;block must start with label&quot;);
6015 
6016     if (sux-&gt;number_of_preds() != 1) {
6017       // this can happen with switch-statements where multiple edges are between
6018       // the same blocks.
6019       return;
6020     }
6021     assert(sux-&gt;pred_at(0) == block, &quot;invalid control flow&quot;);
6022     assert(!sux-&gt;is_set(BlockBegin::exception_entry_flag), &quot;exception handlers not allowed&quot;);
6023 
6024     // ignore the label at the beginning of the block
6025     append_instructions(sux_instructions, 1);
6026   }
6027 
6028   // process lir-instructions while all successors begin with the same instruction
6029   while (true) {
6030     LIR_Op* op = instruction_at(0);
6031     for (i = 1; i &lt; num_sux; i++) {
6032       if (operations_different(op, instruction_at(i))) {
6033         // these instructions are different and cannot be optimized -&gt;
6034         // no further optimization possible
6035         return;
6036       }
6037     }
6038 
6039     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;----- found instruction that is equal in all %d successors: &quot;, num_sux); op-&gt;print());
6040 
6041     // insert instruction at end of current block
6042     block-&gt;lir()-&gt;insert_before(insert_idx, op);
6043     insert_idx++;
6044 
6045     // delete the instructions at the beginning of all successors
6046     for (i = 0; i &lt; num_sux; i++) {
6047       remove_cur_instruction(i, false);
6048     }
6049   }
6050 }
6051 
6052 
6053 // Implementation of ControlFlowOptimizer
6054 
6055 ControlFlowOptimizer::ControlFlowOptimizer() :
6056   _original_preds(4)
6057 {
6058 }
6059 
6060 void ControlFlowOptimizer::optimize(BlockList* code) {
6061   ControlFlowOptimizer optimizer = ControlFlowOptimizer();
6062 
6063   // push the OSR entry block to the end so that we&#39;re not jumping over it.
6064   BlockBegin* osr_entry = code-&gt;at(0)-&gt;end()-&gt;as_Base()-&gt;osr_entry();
6065   if (osr_entry) {
6066     int index = osr_entry-&gt;linear_scan_number();
6067     assert(code-&gt;at(index) == osr_entry, &quot;wrong index&quot;);
6068     code-&gt;remove_at(index);
6069     code-&gt;append(osr_entry);
6070   }
6071 
6072   optimizer.reorder_short_loops(code);
6073   optimizer.delete_empty_blocks(code);
6074   optimizer.delete_unnecessary_jumps(code);
6075   optimizer.delete_jumps_to_return(code);
6076 }
6077 
6078 void ControlFlowOptimizer::reorder_short_loop(BlockList* code, BlockBegin* header_block, int header_idx) {
6079   int i = header_idx + 1;
6080   int max_end = MIN2(header_idx + ShortLoopSize, code-&gt;length());
6081   while (i &lt; max_end &amp;&amp; code-&gt;at(i)-&gt;loop_depth() &gt;= header_block-&gt;loop_depth()) {
6082     i++;
6083   }
6084 
6085   if (i == code-&gt;length() || code-&gt;at(i)-&gt;loop_depth() &lt; header_block-&gt;loop_depth()) {
6086     int end_idx = i - 1;
6087     BlockBegin* end_block = code-&gt;at(end_idx);
6088 
6089     if (end_block-&gt;number_of_sux() == 1 &amp;&amp; end_block-&gt;sux_at(0) == header_block) {
6090       // short loop from header_idx to end_idx found -&gt; reorder blocks such that
6091       // the header_block is the last block instead of the first block of the loop
6092       TRACE_LINEAR_SCAN(1, tty-&gt;print_cr(&quot;Reordering short loop: length %d, header B%d, end B%d&quot;,
6093                                          end_idx - header_idx + 1,
6094                                          header_block-&gt;block_id(), end_block-&gt;block_id()));
6095 
6096       for (int j = header_idx; j &lt; end_idx; j++) {
6097         code-&gt;at_put(j, code-&gt;at(j + 1));
6098       }
6099       code-&gt;at_put(end_idx, header_block);
6100 
6101       // correct the flags so that any loop alignment occurs in the right place.
6102       assert(code-&gt;at(end_idx)-&gt;is_set(BlockBegin::backward_branch_target_flag), &quot;must be backward branch target&quot;);
6103       code-&gt;at(end_idx)-&gt;clear(BlockBegin::backward_branch_target_flag);
6104       code-&gt;at(header_idx)-&gt;set(BlockBegin::backward_branch_target_flag);
6105     }
6106   }
6107 }
6108 
6109 void ControlFlowOptimizer::reorder_short_loops(BlockList* code) {
6110   for (int i = code-&gt;length() - 1; i &gt;= 0; i--) {
6111     BlockBegin* block = code-&gt;at(i);
6112 
6113     if (block-&gt;is_set(BlockBegin::linear_scan_loop_header_flag)) {
6114       reorder_short_loop(code, block, i);
6115     }
6116   }
6117 
6118   DEBUG_ONLY(verify(code));
6119 }
6120 
6121 // only blocks with exactly one successor can be deleted. Such blocks
6122 // must always end with an unconditional branch to this successor
6123 bool ControlFlowOptimizer::can_delete_block(BlockBegin* block) {
6124   if (block-&gt;number_of_sux() != 1 || block-&gt;number_of_exception_handlers() != 0 || block-&gt;is_entry_block()) {
6125     return false;
6126   }
6127 
6128   LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6129 
6130   assert(instructions-&gt;length() &gt;= 2, &quot;block must have label and branch&quot;);
6131   assert(instructions-&gt;at(0)-&gt;code() == lir_label, &quot;first instruction must always be a label&quot;);
6132   assert(instructions-&gt;last()-&gt;as_OpBranch() != NULL, &quot;last instrcution must always be a branch&quot;);
6133   assert(instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;branch must be unconditional&quot;);
6134   assert(instructions-&gt;last()-&gt;as_OpBranch()-&gt;block() == block-&gt;sux_at(0), &quot;branch target must be the successor&quot;);
6135 
6136   // block must have exactly one successor
6137 
6138   if (instructions-&gt;length() == 2 &amp;&amp; instructions-&gt;last()-&gt;info() == NULL) {
6139     return true;
6140   }
6141   return false;
6142 }
6143 
6144 // substitute branch targets in all branch-instructions of this blocks
6145 void ControlFlowOptimizer::substitute_branch_target(BlockBegin* block, BlockBegin* target_from, BlockBegin* target_to) {
6146   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;Deleting empty block: substituting from B%d to B%d inside B%d&quot;, target_from-&gt;block_id(), target_to-&gt;block_id(), block-&gt;block_id()));
6147 
6148   LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6149 
6150   assert(instructions-&gt;at(0)-&gt;code() == lir_label, &quot;first instruction must always be a label&quot;);
6151   for (int i = instructions-&gt;length() - 1; i &gt;= 1; i--) {
6152     LIR_Op* op = instructions-&gt;at(i);
6153 
6154     if (op-&gt;code() == lir_branch || op-&gt;code() == lir_cond_float_branch) {
6155       assert(op-&gt;as_OpBranch() != NULL, &quot;branch must be of type LIR_OpBranch&quot;);
6156       LIR_OpBranch* branch = (LIR_OpBranch*)op;
6157 
6158       if (branch-&gt;block() == target_from) {
6159         branch-&gt;change_block(target_to);
6160       }
6161       if (branch-&gt;ublock() == target_from) {
6162         branch-&gt;change_ublock(target_to);
6163       }
6164     }
6165   }
6166 }
6167 
6168 void ControlFlowOptimizer::delete_empty_blocks(BlockList* code) {
6169   int old_pos = 0;
6170   int new_pos = 0;
6171   int num_blocks = code-&gt;length();
6172 
6173   while (old_pos &lt; num_blocks) {
6174     BlockBegin* block = code-&gt;at(old_pos);
6175 
6176     if (can_delete_block(block)) {
6177       BlockBegin* new_target = block-&gt;sux_at(0);
6178 
6179       // propagate backward branch target flag for correct code alignment
6180       if (block-&gt;is_set(BlockBegin::backward_branch_target_flag)) {
6181         new_target-&gt;set(BlockBegin::backward_branch_target_flag);
6182       }
6183 
6184       // collect a list with all predecessors that contains each predecessor only once
6185       // the predecessors of cur are changed during the substitution, so a copy of the
6186       // predecessor list is necessary
6187       int j;
6188       _original_preds.clear();
6189       for (j = block-&gt;number_of_preds() - 1; j &gt;= 0; j--) {
6190         BlockBegin* pred = block-&gt;pred_at(j);
6191         if (_original_preds.find(pred) == -1) {
6192           _original_preds.append(pred);
6193         }
6194       }
6195 
6196       for (j = _original_preds.length() - 1; j &gt;= 0; j--) {
6197         BlockBegin* pred = _original_preds.at(j);
6198         substitute_branch_target(pred, block, new_target);
6199         pred-&gt;substitute_sux(block, new_target);
6200       }
6201     } else {
6202       // adjust position of this block in the block list if blocks before
6203       // have been deleted
6204       if (new_pos != old_pos) {
6205         code-&gt;at_put(new_pos, code-&gt;at(old_pos));
6206       }
6207       new_pos++;
6208     }
6209     old_pos++;
6210   }
6211   code-&gt;trunc_to(new_pos);
6212 
6213   DEBUG_ONLY(verify(code));
6214 }
6215 
6216 void ControlFlowOptimizer::delete_unnecessary_jumps(BlockList* code) {
6217   // skip the last block because there a branch is always necessary
6218   for (int i = code-&gt;length() - 2; i &gt;= 0; i--) {
6219     BlockBegin* block = code-&gt;at(i);
6220     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6221 
6222     LIR_Op* last_op = instructions-&gt;last();
6223     if (last_op-&gt;code() == lir_branch) {
6224       assert(last_op-&gt;as_OpBranch() != NULL, &quot;branch must be of type LIR_OpBranch&quot;);
6225       LIR_OpBranch* last_branch = (LIR_OpBranch*)last_op;
6226 
6227       assert(last_branch-&gt;block() != NULL, &quot;last branch must always have a block as target&quot;);
6228       assert(last_branch-&gt;label() == last_branch-&gt;block()-&gt;label(), &quot;must be equal&quot;);
6229 
6230       if (last_branch-&gt;info() == NULL) {
6231         if (last_branch-&gt;block() == code-&gt;at(i + 1)) {
6232 
6233           TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;Deleting unconditional branch at end of block B%d&quot;, block-&gt;block_id()));
6234 
6235           // delete last branch instruction
6236           instructions-&gt;trunc_to(instructions-&gt;length() - 1);
6237 
6238         } else {
6239           LIR_Op* prev_op = instructions-&gt;at(instructions-&gt;length() - 2);
6240           if (prev_op-&gt;code() == lir_branch || prev_op-&gt;code() == lir_cond_float_branch) {
6241             assert(prev_op-&gt;as_OpBranch() != NULL, &quot;branch must be of type LIR_OpBranch&quot;);
6242             LIR_OpBranch* prev_branch = (LIR_OpBranch*)prev_op;
6243 
6244             if (prev_branch-&gt;stub() == NULL) {
6245 
6246               LIR_Op2* prev_cmp = NULL;
6247               // There might be a cmove inserted for profiling which depends on the same
6248               // compare. If we change the condition of the respective compare, we have
6249               // to take care of this cmove as well.
6250               LIR_Op2* prev_cmove = NULL;
6251 
6252               for(int j = instructions-&gt;length() - 3; j &gt;= 0 &amp;&amp; prev_cmp == NULL; j--) {
6253                 prev_op = instructions-&gt;at(j);
6254                 // check for the cmove
6255                 if (prev_op-&gt;code() == lir_cmove) {
6256                   assert(prev_op-&gt;as_Op2() != NULL, &quot;cmove must be of type LIR_Op2&quot;);
6257                   prev_cmove = (LIR_Op2*)prev_op;
6258                   assert(prev_branch-&gt;cond() == prev_cmove-&gt;condition(), &quot;should be the same&quot;);
6259                 }
6260                 if (prev_op-&gt;code() == lir_cmp) {
6261                   assert(prev_op-&gt;as_Op2() != NULL, &quot;branch must be of type LIR_Op2&quot;);
6262                   prev_cmp = (LIR_Op2*)prev_op;
6263                   assert(prev_branch-&gt;cond() == prev_cmp-&gt;condition(), &quot;should be the same&quot;);
6264                 }
6265               }
6266               // Guarantee because it is dereferenced below.
6267               guarantee(prev_cmp != NULL, &quot;should have found comp instruction for branch&quot;);
6268               if (prev_branch-&gt;block() == code-&gt;at(i + 1) &amp;&amp; prev_branch-&gt;info() == NULL) {
6269 
6270                 TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;Negating conditional branch and deleting unconditional branch at end of block B%d&quot;, block-&gt;block_id()));
6271 
6272                 // eliminate a conditional branch to the immediate successor
6273                 prev_branch-&gt;change_block(last_branch-&gt;block());
6274                 prev_branch-&gt;negate_cond();
6275                 prev_cmp-&gt;set_condition(prev_branch-&gt;cond());
6276                 instructions-&gt;trunc_to(instructions-&gt;length() - 1);
6277                 // if we do change the condition, we have to change the cmove as well
6278                 if (prev_cmove != NULL) {
6279                   prev_cmove-&gt;set_condition(prev_branch-&gt;cond());
6280                   LIR_Opr t = prev_cmove-&gt;in_opr1();
6281                   prev_cmove-&gt;set_in_opr1(prev_cmove-&gt;in_opr2());
6282                   prev_cmove-&gt;set_in_opr2(t);
6283                 }
6284               }
6285             }
6286           }
6287         }
6288       }
6289     }
6290   }
6291 
6292   DEBUG_ONLY(verify(code));
6293 }
6294 
6295 void ControlFlowOptimizer::delete_jumps_to_return(BlockList* code) {
6296 #ifdef ASSERT
6297   ResourceBitMap return_converted(BlockBegin::number_of_blocks());
6298 #endif
6299 
6300   for (int i = code-&gt;length() - 1; i &gt;= 0; i--) {
6301     BlockBegin* block = code-&gt;at(i);
6302     LIR_OpList* cur_instructions = block-&gt;lir()-&gt;instructions_list();
6303     LIR_Op*     cur_last_op = cur_instructions-&gt;last();
6304 
6305     assert(cur_instructions-&gt;at(0)-&gt;code() == lir_label, &quot;first instruction must always be a label&quot;);
6306     if (cur_instructions-&gt;length() == 2 &amp;&amp; cur_last_op-&gt;code() == lir_return) {
6307       // the block contains only a label and a return
6308       // if a predecessor ends with an unconditional jump to this block, then the jump
6309       // can be replaced with a return instruction
6310       //
6311       // Note: the original block with only a return statement cannot be deleted completely
6312       //       because the predecessors might have other (conditional) jumps to this block
6313       //       -&gt; this may lead to unnecesary return instructions in the final code
6314 
6315       assert(cur_last_op-&gt;info() == NULL, &quot;return instructions do not have debug information&quot;);
6316       assert(block-&gt;number_of_sux() == 0 ||
6317              (return_converted.at(block-&gt;block_id()) &amp;&amp; block-&gt;number_of_sux() == 1),
6318              &quot;blocks that end with return must not have successors&quot;);
6319 
6320       assert(cur_last_op-&gt;as_Op1() != NULL, &quot;return must be LIR_Op1&quot;);
6321       LIR_Opr return_opr = ((LIR_Op1*)cur_last_op)-&gt;in_opr();
6322 
6323       for (int j = block-&gt;number_of_preds() - 1; j &gt;= 0; j--) {
6324         BlockBegin* pred = block-&gt;pred_at(j);
6325         LIR_OpList* pred_instructions = pred-&gt;lir()-&gt;instructions_list();
6326         LIR_Op*     pred_last_op = pred_instructions-&gt;last();
6327 
6328         if (pred_last_op-&gt;code() == lir_branch) {
6329           assert(pred_last_op-&gt;as_OpBranch() != NULL, &quot;branch must be LIR_OpBranch&quot;);
6330           LIR_OpBranch* pred_last_branch = (LIR_OpBranch*)pred_last_op;
6331 
6332           if (pred_last_branch-&gt;block() == block &amp;&amp; pred_last_branch-&gt;cond() == lir_cond_always &amp;&amp; pred_last_branch-&gt;info() == NULL) {
6333             // replace the jump to a return with a direct return
6334             // Note: currently the edge between the blocks is not deleted
6335             pred_instructions-&gt;at_put(pred_instructions-&gt;length() - 1, new LIR_Op1(lir_return, return_opr));
6336 #ifdef ASSERT
6337             return_converted.set_bit(pred-&gt;block_id());
6338 #endif
6339           }
6340         }
6341       }
6342     }
6343   }
6344 }
6345 
6346 
6347 #ifdef ASSERT
6348 void ControlFlowOptimizer::verify(BlockList* code) {
6349   for (int i = 0; i &lt; code-&gt;length(); i++) {
6350     BlockBegin* block = code-&gt;at(i);
6351     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6352 
6353     int j;
6354     for (j = 0; j &lt; instructions-&gt;length(); j++) {
6355       LIR_OpBranch* op_branch = instructions-&gt;at(j)-&gt;as_OpBranch();
6356 
6357       if (op_branch != NULL) {
6358         assert(op_branch-&gt;block() == NULL || code-&gt;find(op_branch-&gt;block()) != -1, &quot;branch target not valid&quot;);
6359         assert(op_branch-&gt;ublock() == NULL || code-&gt;find(op_branch-&gt;ublock()) != -1, &quot;branch target not valid&quot;);
6360       }
6361     }
6362 
6363     for (j = 0; j &lt; block-&gt;number_of_sux() - 1; j++) {
6364       BlockBegin* sux = block-&gt;sux_at(j);
6365       assert(code-&gt;find(sux) != -1, &quot;successor not valid&quot;);
6366     }
6367 
6368     for (j = 0; j &lt; block-&gt;number_of_preds() - 1; j++) {
6369       BlockBegin* pred = block-&gt;pred_at(j);
6370       assert(code-&gt;find(pred) != -1, &quot;successor not valid&quot;);
6371     }
6372   }
6373 }
6374 #endif
6375 
6376 
6377 #ifndef PRODUCT
6378 
6379 // Implementation of LinearStatistic
6380 
6381 const char* LinearScanStatistic::counter_name(int counter_idx) {
6382   switch (counter_idx) {
6383     case counter_method:          return &quot;compiled methods&quot;;
6384     case counter_fpu_method:      return &quot;methods using fpu&quot;;
6385     case counter_loop_method:     return &quot;methods with loops&quot;;
6386     case counter_exception_method:return &quot;methods with xhandler&quot;;
6387 
6388     case counter_loop:            return &quot;loops&quot;;
6389     case counter_block:           return &quot;blocks&quot;;
6390     case counter_loop_block:      return &quot;blocks inside loop&quot;;
6391     case counter_exception_block: return &quot;exception handler entries&quot;;
6392     case counter_interval:        return &quot;intervals&quot;;
6393     case counter_fixed_interval:  return &quot;fixed intervals&quot;;
6394     case counter_range:           return &quot;ranges&quot;;
6395     case counter_fixed_range:     return &quot;fixed ranges&quot;;
6396     case counter_use_pos:         return &quot;use positions&quot;;
6397     case counter_fixed_use_pos:   return &quot;fixed use positions&quot;;
6398     case counter_spill_slots:     return &quot;spill slots&quot;;
6399 
6400     // counter for classes of lir instructions
6401     case counter_instruction:     return &quot;total instructions&quot;;
6402     case counter_label:           return &quot;labels&quot;;
6403     case counter_entry:           return &quot;method entries&quot;;
6404     case counter_return:          return &quot;method returns&quot;;
6405     case counter_call:            return &quot;method calls&quot;;
6406     case counter_move:            return &quot;moves&quot;;
6407     case counter_cmp:             return &quot;compare&quot;;
6408     case counter_cond_branch:     return &quot;conditional branches&quot;;
6409     case counter_uncond_branch:   return &quot;unconditional branches&quot;;
6410     case counter_stub_branch:     return &quot;branches to stub&quot;;
6411     case counter_alu:             return &quot;artithmetic + logic&quot;;
6412     case counter_alloc:           return &quot;allocations&quot;;
6413     case counter_sync:            return &quot;synchronisation&quot;;
6414     case counter_throw:           return &quot;throw&quot;;
6415     case counter_unwind:          return &quot;unwind&quot;;
6416     case counter_typecheck:       return &quot;type+null-checks&quot;;
6417     case counter_fpu_stack:       return &quot;fpu-stack&quot;;
6418     case counter_misc_inst:       return &quot;other instructions&quot;;
6419     case counter_other_inst:      return &quot;misc. instructions&quot;;
6420 
6421     // counter for different types of moves
6422     case counter_move_total:      return &quot;total moves&quot;;
6423     case counter_move_reg_reg:    return &quot;register-&gt;register&quot;;
6424     case counter_move_reg_stack:  return &quot;register-&gt;stack&quot;;
6425     case counter_move_stack_reg:  return &quot;stack-&gt;register&quot;;
6426     case counter_move_stack_stack:return &quot;stack-&gt;stack&quot;;
6427     case counter_move_reg_mem:    return &quot;register-&gt;memory&quot;;
6428     case counter_move_mem_reg:    return &quot;memory-&gt;register&quot;;
6429     case counter_move_const_any:  return &quot;constant-&gt;any&quot;;
6430 
6431     case blank_line_1:            return &quot;&quot;;
6432     case blank_line_2:            return &quot;&quot;;
6433 
6434     default: ShouldNotReachHere(); return &quot;&quot;;
6435   }
6436 }
6437 
6438 LinearScanStatistic::Counter LinearScanStatistic::base_counter(int counter_idx) {
6439   if (counter_idx == counter_fpu_method || counter_idx == counter_loop_method || counter_idx == counter_exception_method) {
6440     return counter_method;
6441   } else if (counter_idx == counter_loop_block || counter_idx == counter_exception_block) {
6442     return counter_block;
6443   } else if (counter_idx &gt;= counter_instruction &amp;&amp; counter_idx &lt;= counter_other_inst) {
6444     return counter_instruction;
6445   } else if (counter_idx &gt;= counter_move_total &amp;&amp; counter_idx &lt;= counter_move_const_any) {
6446     return counter_move_total;
6447   }
6448   return invalid_counter;
6449 }
6450 
6451 LinearScanStatistic::LinearScanStatistic() {
6452   for (int i = 0; i &lt; number_of_counters; i++) {
6453     _counters_sum[i] = 0;
6454     _counters_max[i] = -1;
6455   }
6456 
6457 }
6458 
6459 // add the method-local numbers to the total sum
6460 void LinearScanStatistic::sum_up(LinearScanStatistic &amp;method_statistic) {
6461   for (int i = 0; i &lt; number_of_counters; i++) {
6462     _counters_sum[i] += method_statistic._counters_sum[i];
6463     _counters_max[i] = MAX2(_counters_max[i], method_statistic._counters_sum[i]);
6464   }
6465 }
6466 
6467 void LinearScanStatistic::print(const char* title) {
6468   if (CountLinearScan || TraceLinearScanLevel &gt; 0) {
6469     tty-&gt;cr();
6470     tty-&gt;print_cr(&quot;***** LinearScan statistic - %s *****&quot;, title);
6471 
6472     for (int i = 0; i &lt; number_of_counters; i++) {
6473       if (_counters_sum[i] &gt; 0 || _counters_max[i] &gt;= 0) {
6474         tty-&gt;print(&quot;%25s: %8d&quot;, counter_name(i), _counters_sum[i]);
6475 
6476         LinearScanStatistic::Counter cntr = base_counter(i);
6477         if (cntr != invalid_counter) {
6478           tty-&gt;print(&quot;  (%5.1f%%) &quot;, _counters_sum[i] * 100.0 / _counters_sum[cntr]);
6479         } else {
6480           tty-&gt;print(&quot;           &quot;);
6481         }
6482 
6483         if (_counters_max[i] &gt;= 0) {
6484           tty-&gt;print(&quot;%8d&quot;, _counters_max[i]);
6485         }
6486       }
6487       tty-&gt;cr();
6488     }
6489   }
6490 }
6491 
6492 void LinearScanStatistic::collect(LinearScan* allocator) {
6493   inc_counter(counter_method);
6494   if (allocator-&gt;has_fpu_registers()) {
6495     inc_counter(counter_fpu_method);
6496   }
6497   if (allocator-&gt;num_loops() &gt; 0) {
6498     inc_counter(counter_loop_method);
6499   }
6500   inc_counter(counter_loop, allocator-&gt;num_loops());
6501   inc_counter(counter_spill_slots, allocator-&gt;max_spills());
6502 
6503   int i;
6504   for (i = 0; i &lt; allocator-&gt;interval_count(); i++) {
6505     Interval* cur = allocator-&gt;interval_at(i);
6506 
6507     if (cur != NULL) {
6508       inc_counter(counter_interval);
6509       inc_counter(counter_use_pos, cur-&gt;num_use_positions());
6510       if (LinearScan::is_precolored_interval(cur)) {
6511         inc_counter(counter_fixed_interval);
6512         inc_counter(counter_fixed_use_pos, cur-&gt;num_use_positions());
6513       }
6514 
6515       Range* range = cur-&gt;first();
6516       while (range != Range::end()) {
6517         inc_counter(counter_range);
6518         if (LinearScan::is_precolored_interval(cur)) {
6519           inc_counter(counter_fixed_range);
6520         }
6521         range = range-&gt;next();
6522       }
6523     }
6524   }
6525 
6526   bool has_xhandlers = false;
6527   // Note: only count blocks that are in code-emit order
6528   for (i = 0; i &lt; allocator-&gt;ir()-&gt;code()-&gt;length(); i++) {
6529     BlockBegin* cur = allocator-&gt;ir()-&gt;code()-&gt;at(i);
6530 
6531     inc_counter(counter_block);
6532     if (cur-&gt;loop_depth() &gt; 0) {
6533       inc_counter(counter_loop_block);
6534     }
6535     if (cur-&gt;is_set(BlockBegin::exception_entry_flag)) {
6536       inc_counter(counter_exception_block);
6537       has_xhandlers = true;
6538     }
6539 
6540     LIR_OpList* instructions = cur-&gt;lir()-&gt;instructions_list();
6541     for (int j = 0; j &lt; instructions-&gt;length(); j++) {
6542       LIR_Op* op = instructions-&gt;at(j);
6543 
6544       inc_counter(counter_instruction);
6545 
6546       switch (op-&gt;code()) {
6547         case lir_label:           inc_counter(counter_label); break;
6548         case lir_std_entry:
6549         case lir_osr_entry:       inc_counter(counter_entry); break;
6550         case lir_return:          inc_counter(counter_return); break;
6551 
6552         case lir_rtcall:
6553         case lir_static_call:
6554         case lir_optvirtual_call:
6555         case lir_virtual_call:    inc_counter(counter_call); break;
6556 
6557         case lir_move: {
6558           inc_counter(counter_move);
6559           inc_counter(counter_move_total);
6560 
6561           LIR_Opr in = op-&gt;as_Op1()-&gt;in_opr();
6562           LIR_Opr res = op-&gt;as_Op1()-&gt;result_opr();
6563           if (in-&gt;is_register()) {
6564             if (res-&gt;is_register()) {
6565               inc_counter(counter_move_reg_reg);
6566             } else if (res-&gt;is_stack()) {
6567               inc_counter(counter_move_reg_stack);
6568             } else if (res-&gt;is_address()) {
6569               inc_counter(counter_move_reg_mem);
6570             } else {
6571               ShouldNotReachHere();
6572             }
6573           } else if (in-&gt;is_stack()) {
6574             if (res-&gt;is_register()) {
6575               inc_counter(counter_move_stack_reg);
6576             } else {
6577               inc_counter(counter_move_stack_stack);
6578             }
6579           } else if (in-&gt;is_address()) {
6580             assert(res-&gt;is_register(), &quot;must be&quot;);
6581             inc_counter(counter_move_mem_reg);
6582           } else if (in-&gt;is_constant()) {
6583             inc_counter(counter_move_const_any);
6584           } else {
6585             ShouldNotReachHere();
6586           }
6587           break;
6588         }
6589 
6590         case lir_cmp:             inc_counter(counter_cmp); break;
6591 
6592         case lir_branch:
6593         case lir_cond_float_branch: {
6594           LIR_OpBranch* branch = op-&gt;as_OpBranch();
6595           if (branch-&gt;block() == NULL) {
6596             inc_counter(counter_stub_branch);
6597           } else if (branch-&gt;cond() == lir_cond_always) {
6598             inc_counter(counter_uncond_branch);
6599           } else {
6600             inc_counter(counter_cond_branch);
6601           }
6602           break;
6603         }
6604 
6605         case lir_neg:
6606         case lir_add:
6607         case lir_sub:
6608         case lir_mul:
6609         case lir_mul_strictfp:
6610         case lir_div:
6611         case lir_div_strictfp:
6612         case lir_rem:
6613         case lir_sqrt:
6614         case lir_abs:
6615         case lir_log10:
6616         case lir_logic_and:
6617         case lir_logic_or:
6618         case lir_logic_xor:
6619         case lir_shl:
6620         case lir_shr:
6621         case lir_ushr:            inc_counter(counter_alu); break;
6622 
6623         case lir_alloc_object:
6624         case lir_alloc_array:     inc_counter(counter_alloc); break;
6625 
6626         case lir_monaddr:
6627         case lir_lock:
6628         case lir_unlock:          inc_counter(counter_sync); break;
6629 
6630         case lir_throw:           inc_counter(counter_throw); break;
6631 
6632         case lir_unwind:          inc_counter(counter_unwind); break;
6633 
6634         case lir_null_check:
6635         case lir_leal:
6636         case lir_instanceof:
6637         case lir_checkcast:
6638         case lir_store_check:     inc_counter(counter_typecheck); break;
6639 
6640         case lir_fpop_raw:
6641         case lir_fxch:
6642         case lir_fld:             inc_counter(counter_fpu_stack); break;
6643 
6644         case lir_nop:
6645         case lir_push:
6646         case lir_pop:
6647         case lir_convert:
6648         case lir_roundfp:
6649         case lir_cmove:           inc_counter(counter_misc_inst); break;
6650 
6651         default:                  inc_counter(counter_other_inst); break;
6652       }
6653     }
6654   }
6655 
6656   if (has_xhandlers) {
6657     inc_counter(counter_exception_method);
6658   }
6659 }
6660 
6661 void LinearScanStatistic::compute(LinearScan* allocator, LinearScanStatistic &amp;global_statistic) {
6662   if (CountLinearScan || TraceLinearScanLevel &gt; 0) {
6663 
6664     LinearScanStatistic local_statistic = LinearScanStatistic();
6665 
6666     local_statistic.collect(allocator);
6667     global_statistic.sum_up(local_statistic);
6668 
6669     if (TraceLinearScanLevel &gt; 2) {
6670       local_statistic.print(&quot;current local statistic&quot;);
6671     }
6672   }
6673 }
6674 
6675 
6676 // Implementation of LinearTimers
6677 
6678 LinearScanTimers::LinearScanTimers() {
6679   for (int i = 0; i &lt; number_of_timers; i++) {
6680     timer(i)-&gt;reset();
6681   }
6682 }
6683 
6684 const char* LinearScanTimers::timer_name(int idx) {
6685   switch (idx) {
6686     case timer_do_nothing:               return &quot;Nothing (Time Check)&quot;;
6687     case timer_number_instructions:      return &quot;Number Instructions&quot;;
6688     case timer_compute_local_live_sets:  return &quot;Local Live Sets&quot;;
6689     case timer_compute_global_live_sets: return &quot;Global Live Sets&quot;;
6690     case timer_build_intervals:          return &quot;Build Intervals&quot;;
6691     case timer_sort_intervals_before:    return &quot;Sort Intervals Before&quot;;
6692     case timer_allocate_registers:       return &quot;Allocate Registers&quot;;
6693     case timer_resolve_data_flow:        return &quot;Resolve Data Flow&quot;;
6694     case timer_sort_intervals_after:     return &quot;Sort Intervals After&quot;;
6695     case timer_eliminate_spill_moves:    return &quot;Spill optimization&quot;;
6696     case timer_assign_reg_num:           return &quot;Assign Reg Num&quot;;
6697     case timer_allocate_fpu_stack:       return &quot;Allocate FPU Stack&quot;;
6698     case timer_optimize_lir:             return &quot;Optimize LIR&quot;;
6699     default: ShouldNotReachHere();       return &quot;&quot;;
6700   }
6701 }
6702 
6703 void LinearScanTimers::begin_method() {
6704   if (TimeEachLinearScan) {
6705     // reset all timers to measure only current method
6706     for (int i = 0; i &lt; number_of_timers; i++) {
6707       timer(i)-&gt;reset();
6708     }
6709   }
6710 }
6711 
6712 void LinearScanTimers::end_method(LinearScan* allocator) {
6713   if (TimeEachLinearScan) {
6714 
6715     double c = timer(timer_do_nothing)-&gt;seconds();
6716     double total = 0;
6717     for (int i = 1; i &lt; number_of_timers; i++) {
6718       total += timer(i)-&gt;seconds() - c;
6719     }
6720 
6721     if (total &gt;= 0.0005) {
6722       // print all information in one line for automatic processing
6723       tty-&gt;print(&quot;@&quot;); allocator-&gt;compilation()-&gt;method()-&gt;print_name();
6724 
6725       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;compilation()-&gt;method()-&gt;code_size());
6726       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;block_at(allocator-&gt;block_count() - 1)-&gt;last_lir_instruction_id() / 2);
6727       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;block_count());
6728       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;num_virtual_regs());
6729       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;interval_count());
6730       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;_num_calls);
6731       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;num_loops());
6732 
6733       tty-&gt;print(&quot;@ %6.6f &quot;, total);
6734       for (int i = 1; i &lt; number_of_timers; i++) {
6735         tty-&gt;print(&quot;@ %4.1f &quot;, ((timer(i)-&gt;seconds() - c) / total) * 100);
6736       }
6737       tty-&gt;cr();
6738     }
6739   }
6740 }
6741 
6742 void LinearScanTimers::print(double total_time) {
6743   if (TimeLinearScan) {
6744     // correction value: sum of dummy-timer that only measures the time that
6745     // is necesary to start and stop itself
6746     double c = timer(timer_do_nothing)-&gt;seconds();
6747 
6748     for (int i = 0; i &lt; number_of_timers; i++) {
6749       double t = timer(i)-&gt;seconds();
6750       tty-&gt;print_cr(&quot;    %25s: %6.3f s (%4.1f%%)  corrected: %6.3f s (%4.1f%%)&quot;, timer_name(i), t, (t / total_time) * 100.0, t - c, (t - c) / (total_time - 2 * number_of_timers * c) * 100);
6751     }
6752   }
6753 }
6754 
6755 #endif // #ifndef PRODUCT
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_GraphBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../asm/codeBuffer.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Instruction.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_GraphBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_CFGPrinter.hpp&quot;
  27 #include &quot;c1/c1_Canonicalizer.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_GraphBuilder.hpp&quot;
  30 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  31 #include &quot;ci/ciCallSite.hpp&quot;
  32 #include &quot;ci/ciField.hpp&quot;
  33 #include &quot;ci/ciKlass.hpp&quot;
  34 #include &quot;ci/ciMemberName.hpp&quot;
  35 #include &quot;ci/ciUtilities.inline.hpp&quot;
  36 #include &quot;ci/ciValueKlass.hpp&quot;
  37 #include &quot;compiler/compilationPolicy.hpp&quot;
  38 #include &quot;compiler/compileBroker.hpp&quot;

  39 #include &quot;interpreter/bytecode.hpp&quot;
<span class="line-removed">  40 #include &quot;jfr/jfrEvents.hpp&quot;</span>
  41 #include &quot;memory/resourceArea.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;runtime/sharedRuntime.hpp&quot;
  44 #include &quot;runtime/vm_version.hpp&quot;
  45 #include &quot;utilities/bitMap.inline.hpp&quot;
  46 #include &quot;utilities/powerOfTwo.hpp&quot;
  47 
  48 class BlockListBuilder {
  49  private:
  50   Compilation* _compilation;
  51   IRScope*     _scope;
  52 
  53   BlockList    _blocks;                // internal list of all blocks
  54   BlockList*   _bci2block;             // mapping from bci to blocks for GraphBuilder
  55 
  56   // fields used by mark_loops
  57   ResourceBitMap _active;              // for iteration of control flow graph
  58   ResourceBitMap _visited;             // for iteration of control flow graph
  59   intArray       _loop_map;            // caches the information if a block is contained in a loop
  60   int            _next_loop_index;     // next free loop number
</pre>
<hr />
<pre>
4064   // Proper inlining of methods with jsrs requires a little more work.
4065   if (callee-&gt;has_jsrs()                 ) INLINE_BAILOUT(&quot;jsrs not handled properly by inliner yet&quot;);
4066 
4067   if (strict_fp_requires_explicit_rounding &amp;&amp;
4068       method()-&gt;is_strict() != callee-&gt;is_strict()) {
4069 #ifdef IA32
4070     // If explicit rounding is required, do not inline strict code into non-strict code (or the reverse).
4071     // When SSE2 is present, no special handling is needed.
4072     if (UseSSE &lt; 2) {
4073       INLINE_BAILOUT(&quot;caller and callee have different strict fp requirements&quot;);
4074     }
4075 #else
4076     Unimplemented();
4077 #endif // IA32
4078   }
4079 
4080   if (is_profiling() &amp;&amp; !callee-&gt;ensure_method_data()) {
4081     INLINE_BAILOUT(&quot;mdo allocation failed&quot;);
4082   }
4083 

















4084   // now perform tests that are based on flag settings
4085   bool inlinee_by_directive = compilation()-&gt;directive()-&gt;should_inline(callee);
4086   if (callee-&gt;force_inline() || inlinee_by_directive) {
4087     if (inline_level() &gt; MaxForceInlineLevel                    ) INLINE_BAILOUT(&quot;MaxForceInlineLevel&quot;);
4088     if (recursive_inline_level(callee) &gt; MaxRecursiveInlineLevel) INLINE_BAILOUT(&quot;recursive inlining too deep&quot;);
4089 
4090     const char* msg = &quot;&quot;;
4091     if (callee-&gt;force_inline())  msg = &quot;force inline by annotation&quot;;
4092     if (inlinee_by_directive)    msg = &quot;force inline by CompileCommand&quot;;
4093     print_inlining(callee, msg);
4094   } else {
4095     // use heuristic controls on inlining
4096     if (inline_level() &gt; MaxInlineLevel                         ) INLINE_BAILOUT(&quot;inlining too deep&quot;);
4097     if (recursive_inline_level(callee) &gt; MaxRecursiveInlineLevel) INLINE_BAILOUT(&quot;recursive inlining too deep&quot;);
4098     if (callee-&gt;code_size_for_inlining() &gt; max_inline_size()    ) INLINE_BAILOUT(&quot;callee is too large&quot;);
4099 
4100     // don&#39;t inline throwable methods unless the inlining tree is rooted in a throwable class
4101     if (callee-&gt;name() == ciSymbol::object_initializer_name() &amp;&amp;
4102         callee-&gt;holder()-&gt;is_subclass_of(ciEnv::current()-&gt;Throwable_klass())) {
4103       // Throwable constructor call
</pre>
<hr />
<pre>
4106         top = top-&gt;caller();
4107       }
4108       if (!top-&gt;method()-&gt;holder()-&gt;is_subclass_of(ciEnv::current()-&gt;Throwable_klass())) {
4109         INLINE_BAILOUT(&quot;don&#39;t inline Throwable constructors&quot;);
4110       }
4111     }
4112 
4113     if (compilation()-&gt;env()-&gt;num_inlined_bytecodes() &gt; DesiredMethodLimit) {
4114       INLINE_BAILOUT(&quot;total inlining greater than DesiredMethodLimit&quot;);
4115     }
4116     // printing
4117     print_inlining(callee, &quot;inline&quot;, /*success*/ true);
4118   }
4119 
4120   // NOTE: Bailouts from this point on, which occur at the
4121   // GraphBuilder level, do not cause bailout just of the inlining but
4122   // in fact of the entire compilation.
4123 
4124   BlockBegin* orig_block = block();
4125 
<span class="line-removed">4126   const bool is_invokedynamic = bc == Bytecodes::_invokedynamic;</span>
<span class="line-removed">4127   const bool has_receiver = (bc != Bytecodes::_invokestatic &amp;&amp; !is_invokedynamic);</span>
<span class="line-removed">4128 </span>
<span class="line-removed">4129   const int args_base = state()-&gt;stack_size() - callee-&gt;arg_size();</span>
<span class="line-removed">4130   assert(args_base &gt;= 0, &quot;stack underflow during inlining&quot;);</span>
<span class="line-removed">4131 </span>
4132   // Insert null check if necessary
<span class="line-removed">4133   Value recv = NULL;</span>
4134   if (has_receiver) {
4135     // note: null check must happen even if first instruction of callee does
4136     //       an implicit null check since the callee is in a different scope
4137     //       and we must make sure exception handling does the right thing
<span class="line-removed">4138     assert(!callee-&gt;is_static(), &quot;callee must not be static&quot;);</span>
<span class="line-removed">4139     assert(callee-&gt;arg_size() &gt; 0, &quot;must have at least a receiver&quot;);</span>
<span class="line-removed">4140     recv = state()-&gt;stack_at(args_base);</span>
4141     null_check(recv);
4142   }
4143 
4144   if (is_profiling()) {
4145     // Note that we&#39;d collect profile data in this method if we wanted it.
4146     // this may be redundant here...
4147     compilation()-&gt;set_would_profile(true);
4148 
4149     if (profile_calls()) {
4150       int start = 0;
4151       Values* obj_args = args_list_for_profiling(callee, start, has_receiver);
4152       if (obj_args != NULL) {
4153         int s = obj_args-&gt;max_length();
4154         // if called through method handle invoke, some arguments may have been popped
4155         for (int i = args_base+start, j = 0; j &lt; obj_args-&gt;max_length() &amp;&amp; i &lt; state()-&gt;stack_size(); ) {
4156           Value v = state()-&gt;stack_at_inc(i);
4157           if (v-&gt;type()-&gt;is_object_kind()) {
4158             obj_args-&gt;push(v);
4159             j++;
4160           }
</pre>
<hr />
<pre>
4592   assert (type2aelembytes(T_CHAR) == type2aelembytes(T_BYTE)*2,
4593           &quot;sanity: byte[] and char[] scales agree&quot;);
4594 
4595   ValueStack* state_before = copy_state_indexed_access();
4596   compilation()-&gt;set_has_access_indexed(true);
4597   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4598   Value array = args-&gt;at(0);
4599   Value index = args-&gt;at(1);
4600   if (is_store) {
4601     Value value = args-&gt;at(2);
4602     Instruction* store = append(new StoreIndexed(array, index, NULL, T_CHAR, value, state_before, false, true));
4603     store-&gt;set_flag(Instruction::NeedsRangeCheckFlag, false);
4604     _memory-&gt;store_value(value);
4605   } else {
4606     Instruction* load = append(new LoadIndexed(array, index, NULL, T_CHAR, state_before, true));
4607     load-&gt;set_flag(Instruction::NeedsRangeCheckFlag, false);
4608     push(load-&gt;type(), load);
4609   }
4610 }
4611 
<span class="line-removed">4612 static void post_inlining_event(EventCompilerInlining* event,</span>
<span class="line-removed">4613                                 int compile_id,</span>
<span class="line-removed">4614                                 const char* msg,</span>
<span class="line-removed">4615                                 bool success,</span>
<span class="line-removed">4616                                 int bci,</span>
<span class="line-removed">4617                                 ciMethod* caller,</span>
<span class="line-removed">4618                                 ciMethod* callee) {</span>
<span class="line-removed">4619   assert(caller != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">4620   assert(callee != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">4621   assert(event != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">4622   assert(event-&gt;should_commit(), &quot;invariant&quot;);</span>
<span class="line-removed">4623   JfrStructCalleeMethod callee_struct;</span>
<span class="line-removed">4624   callee_struct.set_type(callee-&gt;holder()-&gt;name()-&gt;as_utf8());</span>
<span class="line-removed">4625   callee_struct.set_name(callee-&gt;name()-&gt;as_utf8());</span>
<span class="line-removed">4626   callee_struct.set_descriptor(callee-&gt;signature()-&gt;as_symbol()-&gt;as_utf8());</span>
<span class="line-removed">4627   event-&gt;set_compileId(compile_id);</span>
<span class="line-removed">4628   event-&gt;set_message(msg);</span>
<span class="line-removed">4629   event-&gt;set_succeeded(success);</span>
<span class="line-removed">4630   event-&gt;set_bci(bci);</span>
<span class="line-removed">4631   event-&gt;set_caller(caller-&gt;get_Method());</span>
<span class="line-removed">4632   event-&gt;set_callee(callee_struct);</span>
<span class="line-removed">4633   event-&gt;commit();</span>
<span class="line-removed">4634 }</span>
<span class="line-removed">4635 </span>
4636 void GraphBuilder::print_inlining(ciMethod* callee, const char* msg, bool success) {
4637   CompileLog* log = compilation()-&gt;log();
4638   if (log != NULL) {
4639     assert(msg != NULL, &quot;inlining msg should not be null!&quot;);
4640     if (success) {
4641       log-&gt;inline_success(msg);
4642     } else {
4643       log-&gt;inline_fail(msg);
4644     }
4645   }
4646   EventCompilerInlining event;
4647   if (event.should_commit()) {
<span class="line-modified">4648     post_inlining_event(&amp;event, compilation()-&gt;env()-&gt;task()-&gt;compile_id(), msg, success, bci(), method(), callee);</span>
4649   }
4650 
4651   CompileTask::print_inlining_ul(callee, scope()-&gt;level(), bci(), msg);
4652 
4653   if (!compilation()-&gt;directive()-&gt;PrintInliningOption) {
4654     return;
4655   }
4656   CompileTask::print_inlining_tty(callee, scope()-&gt;level(), bci(), msg);
4657   if (success &amp;&amp; CIPrintMethodCodes) {
4658     callee-&gt;print_codes();
4659   }
4660 }
4661 
4662 void GraphBuilder::append_unsafe_get_and_set_obj(ciMethod* callee, bool is_add) {
4663   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4664   BasicType t = callee-&gt;return_type()-&gt;basic_type();
4665   null_check(args-&gt;at(0));
4666   Instruction* offset = args-&gt;at(2);
4667 #ifndef _LP64
4668   offset = append(new Convert(Bytecodes::_l2i, offset, as_ValueType(T_INT)));
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_CFGPrinter.hpp&quot;
  27 #include &quot;c1/c1_Canonicalizer.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_GraphBuilder.hpp&quot;
  30 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  31 #include &quot;ci/ciCallSite.hpp&quot;
  32 #include &quot;ci/ciField.hpp&quot;
  33 #include &quot;ci/ciKlass.hpp&quot;
  34 #include &quot;ci/ciMemberName.hpp&quot;
  35 #include &quot;ci/ciUtilities.inline.hpp&quot;
  36 #include &quot;ci/ciValueKlass.hpp&quot;
  37 #include &quot;compiler/compilationPolicy.hpp&quot;
  38 #include &quot;compiler/compileBroker.hpp&quot;
<span class="line-added">  39 #include &quot;compiler/compilerEvent.hpp&quot;</span>
  40 #include &quot;interpreter/bytecode.hpp&quot;

  41 #include &quot;memory/resourceArea.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;runtime/sharedRuntime.hpp&quot;
  44 #include &quot;runtime/vm_version.hpp&quot;
  45 #include &quot;utilities/bitMap.inline.hpp&quot;
  46 #include &quot;utilities/powerOfTwo.hpp&quot;
  47 
  48 class BlockListBuilder {
  49  private:
  50   Compilation* _compilation;
  51   IRScope*     _scope;
  52 
  53   BlockList    _blocks;                // internal list of all blocks
  54   BlockList*   _bci2block;             // mapping from bci to blocks for GraphBuilder
  55 
  56   // fields used by mark_loops
  57   ResourceBitMap _active;              // for iteration of control flow graph
  58   ResourceBitMap _visited;             // for iteration of control flow graph
  59   intArray       _loop_map;            // caches the information if a block is contained in a loop
  60   int            _next_loop_index;     // next free loop number
</pre>
<hr />
<pre>
4064   // Proper inlining of methods with jsrs requires a little more work.
4065   if (callee-&gt;has_jsrs()                 ) INLINE_BAILOUT(&quot;jsrs not handled properly by inliner yet&quot;);
4066 
4067   if (strict_fp_requires_explicit_rounding &amp;&amp;
4068       method()-&gt;is_strict() != callee-&gt;is_strict()) {
4069 #ifdef IA32
4070     // If explicit rounding is required, do not inline strict code into non-strict code (or the reverse).
4071     // When SSE2 is present, no special handling is needed.
4072     if (UseSSE &lt; 2) {
4073       INLINE_BAILOUT(&quot;caller and callee have different strict fp requirements&quot;);
4074     }
4075 #else
4076     Unimplemented();
4077 #endif // IA32
4078   }
4079 
4080   if (is_profiling() &amp;&amp; !callee-&gt;ensure_method_data()) {
4081     INLINE_BAILOUT(&quot;mdo allocation failed&quot;);
4082   }
4083 
<span class="line-added">4084   const bool is_invokedynamic = (bc == Bytecodes::_invokedynamic);</span>
<span class="line-added">4085   const bool has_receiver = (bc != Bytecodes::_invokestatic &amp;&amp; !is_invokedynamic);</span>
<span class="line-added">4086 </span>
<span class="line-added">4087   const int args_base = state()-&gt;stack_size() - callee-&gt;arg_size();</span>
<span class="line-added">4088   assert(args_base &gt;= 0, &quot;stack underflow during inlining&quot;);</span>
<span class="line-added">4089 </span>
<span class="line-added">4090   Value recv = NULL;</span>
<span class="line-added">4091   if (has_receiver) {</span>
<span class="line-added">4092     assert(!callee-&gt;is_static(), &quot;callee must not be static&quot;);</span>
<span class="line-added">4093     assert(callee-&gt;arg_size() &gt; 0, &quot;must have at least a receiver&quot;);</span>
<span class="line-added">4094 </span>
<span class="line-added">4095     recv = state()-&gt;stack_at(args_base);</span>
<span class="line-added">4096     if (recv-&gt;is_null_obj()) {</span>
<span class="line-added">4097       INLINE_BAILOUT(&quot;receiver is always null&quot;);</span>
<span class="line-added">4098     }</span>
<span class="line-added">4099   }</span>
<span class="line-added">4100 </span>
4101   // now perform tests that are based on flag settings
4102   bool inlinee_by_directive = compilation()-&gt;directive()-&gt;should_inline(callee);
4103   if (callee-&gt;force_inline() || inlinee_by_directive) {
4104     if (inline_level() &gt; MaxForceInlineLevel                    ) INLINE_BAILOUT(&quot;MaxForceInlineLevel&quot;);
4105     if (recursive_inline_level(callee) &gt; MaxRecursiveInlineLevel) INLINE_BAILOUT(&quot;recursive inlining too deep&quot;);
4106 
4107     const char* msg = &quot;&quot;;
4108     if (callee-&gt;force_inline())  msg = &quot;force inline by annotation&quot;;
4109     if (inlinee_by_directive)    msg = &quot;force inline by CompileCommand&quot;;
4110     print_inlining(callee, msg);
4111   } else {
4112     // use heuristic controls on inlining
4113     if (inline_level() &gt; MaxInlineLevel                         ) INLINE_BAILOUT(&quot;inlining too deep&quot;);
4114     if (recursive_inline_level(callee) &gt; MaxRecursiveInlineLevel) INLINE_BAILOUT(&quot;recursive inlining too deep&quot;);
4115     if (callee-&gt;code_size_for_inlining() &gt; max_inline_size()    ) INLINE_BAILOUT(&quot;callee is too large&quot;);
4116 
4117     // don&#39;t inline throwable methods unless the inlining tree is rooted in a throwable class
4118     if (callee-&gt;name() == ciSymbol::object_initializer_name() &amp;&amp;
4119         callee-&gt;holder()-&gt;is_subclass_of(ciEnv::current()-&gt;Throwable_klass())) {
4120       // Throwable constructor call
</pre>
<hr />
<pre>
4123         top = top-&gt;caller();
4124       }
4125       if (!top-&gt;method()-&gt;holder()-&gt;is_subclass_of(ciEnv::current()-&gt;Throwable_klass())) {
4126         INLINE_BAILOUT(&quot;don&#39;t inline Throwable constructors&quot;);
4127       }
4128     }
4129 
4130     if (compilation()-&gt;env()-&gt;num_inlined_bytecodes() &gt; DesiredMethodLimit) {
4131       INLINE_BAILOUT(&quot;total inlining greater than DesiredMethodLimit&quot;);
4132     }
4133     // printing
4134     print_inlining(callee, &quot;inline&quot;, /*success*/ true);
4135   }
4136 
4137   // NOTE: Bailouts from this point on, which occur at the
4138   // GraphBuilder level, do not cause bailout just of the inlining but
4139   // in fact of the entire compilation.
4140 
4141   BlockBegin* orig_block = block();
4142 






4143   // Insert null check if necessary

4144   if (has_receiver) {
4145     // note: null check must happen even if first instruction of callee does
4146     //       an implicit null check since the callee is in a different scope
4147     //       and we must make sure exception handling does the right thing



4148     null_check(recv);
4149   }
4150 
4151   if (is_profiling()) {
4152     // Note that we&#39;d collect profile data in this method if we wanted it.
4153     // this may be redundant here...
4154     compilation()-&gt;set_would_profile(true);
4155 
4156     if (profile_calls()) {
4157       int start = 0;
4158       Values* obj_args = args_list_for_profiling(callee, start, has_receiver);
4159       if (obj_args != NULL) {
4160         int s = obj_args-&gt;max_length();
4161         // if called through method handle invoke, some arguments may have been popped
4162         for (int i = args_base+start, j = 0; j &lt; obj_args-&gt;max_length() &amp;&amp; i &lt; state()-&gt;stack_size(); ) {
4163           Value v = state()-&gt;stack_at_inc(i);
4164           if (v-&gt;type()-&gt;is_object_kind()) {
4165             obj_args-&gt;push(v);
4166             j++;
4167           }
</pre>
<hr />
<pre>
4599   assert (type2aelembytes(T_CHAR) == type2aelembytes(T_BYTE)*2,
4600           &quot;sanity: byte[] and char[] scales agree&quot;);
4601 
4602   ValueStack* state_before = copy_state_indexed_access();
4603   compilation()-&gt;set_has_access_indexed(true);
4604   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4605   Value array = args-&gt;at(0);
4606   Value index = args-&gt;at(1);
4607   if (is_store) {
4608     Value value = args-&gt;at(2);
4609     Instruction* store = append(new StoreIndexed(array, index, NULL, T_CHAR, value, state_before, false, true));
4610     store-&gt;set_flag(Instruction::NeedsRangeCheckFlag, false);
4611     _memory-&gt;store_value(value);
4612   } else {
4613     Instruction* load = append(new LoadIndexed(array, index, NULL, T_CHAR, state_before, true));
4614     load-&gt;set_flag(Instruction::NeedsRangeCheckFlag, false);
4615     push(load-&gt;type(), load);
4616   }
4617 }
4618 
























4619 void GraphBuilder::print_inlining(ciMethod* callee, const char* msg, bool success) {
4620   CompileLog* log = compilation()-&gt;log();
4621   if (log != NULL) {
4622     assert(msg != NULL, &quot;inlining msg should not be null!&quot;);
4623     if (success) {
4624       log-&gt;inline_success(msg);
4625     } else {
4626       log-&gt;inline_fail(msg);
4627     }
4628   }
4629   EventCompilerInlining event;
4630   if (event.should_commit()) {
<span class="line-modified">4631     CompilerEvent::InlineEvent::post(event, compilation()-&gt;env()-&gt;task()-&gt;compile_id(), method()-&gt;get_Method(), callee, success, msg, bci());</span>
4632   }
4633 
4634   CompileTask::print_inlining_ul(callee, scope()-&gt;level(), bci(), msg);
4635 
4636   if (!compilation()-&gt;directive()-&gt;PrintInliningOption) {
4637     return;
4638   }
4639   CompileTask::print_inlining_tty(callee, scope()-&gt;level(), bci(), msg);
4640   if (success &amp;&amp; CIPrintMethodCodes) {
4641     callee-&gt;print_codes();
4642   }
4643 }
4644 
4645 void GraphBuilder::append_unsafe_get_and_set_obj(ciMethod* callee, bool is_add) {
4646   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4647   BasicType t = callee-&gt;return_type()-&gt;basic_type();
4648   null_check(args-&gt;at(0));
4649   Instruction* offset = args-&gt;at(2);
4650 #ifndef _LP64
4651   offset = append(new Convert(Bytecodes::_l2i, offset, as_ValueType(T_INT)));
</pre>
</td>
</tr>
</table>
<center><a href="../asm/codeBuffer.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Instruction.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
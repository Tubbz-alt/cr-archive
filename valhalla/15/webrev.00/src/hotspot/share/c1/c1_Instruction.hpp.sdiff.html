<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_Instruction.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LinearScan.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_Instruction.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 257     if (f1 != _v-&gt;f1) return false;                   \
 258     return true;                                      \
 259   }                                                   \
 260 
 261 
 262 #define HASHING2(class_name, enabled, f1, f2)         \
 263   virtual intx hash() const {                         \
 264     return (enabled) ? HASH3(name(), f1, f2) : 0;     \
 265   }                                                   \
 266   virtual bool is_equal(Value v) const {              \
 267     if (!(enabled)  ) return false;                   \
 268     class_name* _v = v-&gt;as_##class_name();            \
 269     if (_v == NULL  ) return false;                   \
 270     if (f1 != _v-&gt;f1) return false;                   \
 271     if (f2 != _v-&gt;f2) return false;                   \
 272     return true;                                      \
 273   }                                                   \
 274 
 275 
 276 #define HASHING3(class_name, enabled, f1, f2, f3)     \
<span class="line-modified"> 277   virtual intx hash() const {                          \</span>
 278     return (enabled) ? HASH4(name(), f1, f2, f3) : 0; \
 279   }                                                   \
 280   virtual bool is_equal(Value v) const {              \
 281     if (!(enabled)  ) return false;                   \
 282     class_name* _v = v-&gt;as_##class_name();            \
 283     if (_v == NULL  ) return false;                   \
 284     if (f1 != _v-&gt;f1) return false;                   \
 285     if (f2 != _v-&gt;f2) return false;                   \
 286     if (f3 != _v-&gt;f3) return false;                   \
 287     return true;                                      \
 288   }                                                   \
 289 
 290 
 291 // The mother of all instructions...
 292 
 293 class Instruction: public CompilationResourceObj {
 294  private:
 295   int          _id;                              // the unique instruction id
 296 #ifndef PRODUCT
 297   int          _printable_bci;                   // the bci of the instruction for printing
</pre>
<hr />
<pre>
 446 #endif
 447   int dominator_depth();
 448   int use_count() const                          { return _use_count; }
 449   int pin_state() const                          { return _pin_state; }
 450   bool is_pinned() const                         { return _pin_state != 0 || PinAllInstructions; }
 451   ValueType* type() const                        { return _type; }
 452   BlockBegin *block() const                      { return _block; }
 453   Instruction* prev();                           // use carefully, expensive operation
 454   Instruction* next() const                      { return _next; }
 455   bool has_subst() const                         { return _subst != NULL; }
 456   Instruction* subst()                           { return _subst == NULL ? this : _subst-&gt;subst(); }
 457   LIR_Opr operand() const                        { return _operand; }
 458 
 459   void set_needs_null_check(bool f)              { set_flag(NeedsNullCheckFlag, f); }
 460   bool needs_null_check() const                  { return check_flag(NeedsNullCheckFlag); }
 461   void set_never_null(bool f)                    { set_flag(NeverNullFlag, f); }
 462   bool is_never_null() const                     { return check_flag(NeverNullFlag); }
 463   bool is_linked() const                         { return check_flag(IsLinkedInBlockFlag); }
 464   bool can_be_linked()                           { return as_Local() == NULL &amp;&amp; as_Phi() == NULL; }
 465 


 466   bool has_uses() const                          { return use_count() &gt; 0; }
 467   ValueStack* state_before() const               { return _state_before; }
 468   ValueStack* exception_state() const            { return _exception_state; }
 469   virtual bool needs_exception_state() const     { return true; }
 470   XHandlers* exception_handlers() const          { return _exception_handlers; }
 471   ciKlass* as_loaded_klass_or_null() const;
 472 
 473   // withfield optimization
 474   virtual void set_escaped()                     { }
 475   virtual void set_local_index(int index)        { }
 476   virtual bool is_optimizable_for_withfield() const { return false; }
 477 
 478 
 479   // manipulation
 480   void pin(PinReason reason)                     { _pin_state |= reason; }
 481   void pin()                                     { _pin_state |= PinUnknown; }
 482   // DANGEROUS: only used by EliminateStores
 483   void unpin(PinReason reason)                   { assert((reason &amp; PinUnknown) == 0, &quot;can&#39;t unpin unknown state&quot;); _pin_state &amp;= ~reason; }
 484 
 485   Instruction* set_next(Instruction* next) {
</pre>
<hr />
<pre>
 842   // if needs_null_check() is true.
 843   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 844 
 845   // generic
 846   virtual bool can_trap() const                  { return needs_null_check() || needs_patching(); }
 847   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
 848 };
 849 
 850 
 851 LEAF(LoadField, AccessField)
 852  public:
 853   // creation
 854   LoadField(Value obj, int offset, ciField* field, bool is_static,
 855             ValueStack* state_before, bool needs_patching,
 856             ciValueKlass* value_klass = NULL, Value default_value = NULL )
 857   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 858   {}
 859 
 860   ciType* declared_type() const;
 861 
<span class="line-modified"> 862   // generic</span>
<span class="line-modified"> 863   HASHING2(LoadField, !needs_patching() &amp;&amp; !field()-&gt;is_volatile(), obj()-&gt;subst(), offset())  // cannot be eliminated if needs patching or if volatile</span>
 864 };
 865 
 866 
 867 LEAF(StoreField, AccessField)
 868  private:
 869   Value _value;
 870 
 871  public:
 872   // creation
 873   StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,
 874              ValueStack* state_before, bool needs_patching)
 875   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 876   , _value(value)
 877   {
 878     set_flag(NeedsWriteBarrierFlag, as_ValueType(field_type())-&gt;is_object());
 879     ASSERT_VALUES
 880     pin();
 881   }
 882 
 883   // accessors
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 257     if (f1 != _v-&gt;f1) return false;                   \
 258     return true;                                      \
 259   }                                                   \
 260 
 261 
 262 #define HASHING2(class_name, enabled, f1, f2)         \
 263   virtual intx hash() const {                         \
 264     return (enabled) ? HASH3(name(), f1, f2) : 0;     \
 265   }                                                   \
 266   virtual bool is_equal(Value v) const {              \
 267     if (!(enabled)  ) return false;                   \
 268     class_name* _v = v-&gt;as_##class_name();            \
 269     if (_v == NULL  ) return false;                   \
 270     if (f1 != _v-&gt;f1) return false;                   \
 271     if (f2 != _v-&gt;f2) return false;                   \
 272     return true;                                      \
 273   }                                                   \
 274 
 275 
 276 #define HASHING3(class_name, enabled, f1, f2, f3)     \
<span class="line-modified"> 277   virtual intx hash() const {                         \</span>
 278     return (enabled) ? HASH4(name(), f1, f2, f3) : 0; \
 279   }                                                   \
 280   virtual bool is_equal(Value v) const {              \
 281     if (!(enabled)  ) return false;                   \
 282     class_name* _v = v-&gt;as_##class_name();            \
 283     if (_v == NULL  ) return false;                   \
 284     if (f1 != _v-&gt;f1) return false;                   \
 285     if (f2 != _v-&gt;f2) return false;                   \
 286     if (f3 != _v-&gt;f3) return false;                   \
 287     return true;                                      \
 288   }                                                   \
 289 
 290 
 291 // The mother of all instructions...
 292 
 293 class Instruction: public CompilationResourceObj {
 294  private:
 295   int          _id;                              // the unique instruction id
 296 #ifndef PRODUCT
 297   int          _printable_bci;                   // the bci of the instruction for printing
</pre>
<hr />
<pre>
 446 #endif
 447   int dominator_depth();
 448   int use_count() const                          { return _use_count; }
 449   int pin_state() const                          { return _pin_state; }
 450   bool is_pinned() const                         { return _pin_state != 0 || PinAllInstructions; }
 451   ValueType* type() const                        { return _type; }
 452   BlockBegin *block() const                      { return _block; }
 453   Instruction* prev();                           // use carefully, expensive operation
 454   Instruction* next() const                      { return _next; }
 455   bool has_subst() const                         { return _subst != NULL; }
 456   Instruction* subst()                           { return _subst == NULL ? this : _subst-&gt;subst(); }
 457   LIR_Opr operand() const                        { return _operand; }
 458 
 459   void set_needs_null_check(bool f)              { set_flag(NeedsNullCheckFlag, f); }
 460   bool needs_null_check() const                  { return check_flag(NeedsNullCheckFlag); }
 461   void set_never_null(bool f)                    { set_flag(NeverNullFlag, f); }
 462   bool is_never_null() const                     { return check_flag(NeverNullFlag); }
 463   bool is_linked() const                         { return check_flag(IsLinkedInBlockFlag); }
 464   bool can_be_linked()                           { return as_Local() == NULL &amp;&amp; as_Phi() == NULL; }
 465 
<span class="line-added"> 466   bool is_null_obj()                             { return as_Constant() != NULL &amp;&amp; type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object(); }</span>
<span class="line-added"> 467 </span>
 468   bool has_uses() const                          { return use_count() &gt; 0; }
 469   ValueStack* state_before() const               { return _state_before; }
 470   ValueStack* exception_state() const            { return _exception_state; }
 471   virtual bool needs_exception_state() const     { return true; }
 472   XHandlers* exception_handlers() const          { return _exception_handlers; }
 473   ciKlass* as_loaded_klass_or_null() const;
 474 
 475   // withfield optimization
 476   virtual void set_escaped()                     { }
 477   virtual void set_local_index(int index)        { }
 478   virtual bool is_optimizable_for_withfield() const { return false; }
 479 
 480 
 481   // manipulation
 482   void pin(PinReason reason)                     { _pin_state |= reason; }
 483   void pin()                                     { _pin_state |= PinUnknown; }
 484   // DANGEROUS: only used by EliminateStores
 485   void unpin(PinReason reason)                   { assert((reason &amp; PinUnknown) == 0, &quot;can&#39;t unpin unknown state&quot;); _pin_state &amp;= ~reason; }
 486 
 487   Instruction* set_next(Instruction* next) {
</pre>
<hr />
<pre>
 844   // if needs_null_check() is true.
 845   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 846 
 847   // generic
 848   virtual bool can_trap() const                  { return needs_null_check() || needs_patching(); }
 849   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
 850 };
 851 
 852 
 853 LEAF(LoadField, AccessField)
 854  public:
 855   // creation
 856   LoadField(Value obj, int offset, ciField* field, bool is_static,
 857             ValueStack* state_before, bool needs_patching,
 858             ciValueKlass* value_klass = NULL, Value default_value = NULL )
 859   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 860   {}
 861 
 862   ciType* declared_type() const;
 863 
<span class="line-modified"> 864   // generic; cannot be eliminated if needs patching or if volatile.</span>
<span class="line-modified"> 865   HASHING3(LoadField, !needs_patching() &amp;&amp; !field()-&gt;is_volatile(), obj()-&gt;subst(), offset(), declared_type())</span>
 866 };
 867 
 868 
 869 LEAF(StoreField, AccessField)
 870  private:
 871   Value _value;
 872 
 873  public:
 874   // creation
 875   StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,
 876              ValueStack* state_before, bool needs_patching)
 877   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 878   , _value(value)
 879   {
 880     set_flag(NeedsWriteBarrierFlag, as_ValueType(field_type())-&gt;is_object());
 881     ASSERT_VALUES
 882     pin();
 883   }
 884 
 885   // accessors
</pre>
</td>
</tr>
</table>
<center><a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LinearScan.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
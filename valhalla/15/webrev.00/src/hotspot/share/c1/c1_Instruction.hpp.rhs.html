<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_Instruction.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_C1_C1_INSTRUCTION_HPP
  26 #define SHARE_C1_C1_INSTRUCTION_HPP
  27 
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIR.hpp&quot;
  30 #include &quot;c1/c1_ValueType.hpp&quot;
  31 #include &quot;ci/ciField.hpp&quot;
  32 
  33 // Predefined classes
  34 class ciField;
  35 class ValueStack;
  36 class InstructionPrinter;
  37 class IRScope;
  38 class LIR_OprDesc;
  39 typedef LIR_OprDesc* LIR_Opr;
  40 
  41 
  42 // Instruction class hierarchy
  43 //
  44 // All leaf classes in the class hierarchy are concrete classes
  45 // (i.e., are instantiated). All other classes are abstract and
  46 // serve factoring.
  47 
  48 class Instruction;
  49 class   Phi;
  50 class   Local;
  51 class   Constant;
  52 class   AccessField;
  53 class     LoadField;
  54 class     StoreField;
  55 class   AccessArray;
  56 class     ArrayLength;
  57 class     AccessIndexed;
  58 class       LoadIndexed;
  59 class       StoreIndexed;
  60 class   NegateOp;
  61 class   Op2;
  62 class     ArithmeticOp;
  63 class     ShiftOp;
  64 class     LogicOp;
  65 class     CompareOp;
  66 class     IfOp;
  67 class   Convert;
  68 class   NullCheck;
  69 class   TypeCast;
  70 class   OsrEntry;
  71 class   ExceptionObject;
  72 class   StateSplit;
  73 class     Invoke;
  74 class     NewInstance;
  75 class     NewValueTypeInstance;
  76 class     NewArray;
  77 class       NewTypeArray;
  78 class       NewObjectArray;
  79 class       NewMultiArray;
  80 class     WithField;
  81 class     DefaultValue;
  82 class     TypeCheck;
  83 class       CheckCast;
  84 class       InstanceOf;
  85 class     AccessMonitor;
  86 class       MonitorEnter;
  87 class       MonitorExit;
  88 class     Intrinsic;
  89 class     BlockBegin;
  90 class     BlockEnd;
  91 class       Goto;
  92 class       If;
  93 class       IfInstanceOf;
  94 class       Switch;
  95 class         TableSwitch;
  96 class         LookupSwitch;
  97 class       Return;
  98 class       Throw;
  99 class       Base;
 100 class   RoundFP;
 101 class   UnsafeOp;
 102 class     UnsafeRawOp;
 103 class       UnsafeGetRaw;
 104 class       UnsafePutRaw;
 105 class     UnsafeObjectOp;
 106 class       UnsafeGetObject;
 107 class       UnsafePutObject;
 108 class         UnsafeGetAndSetObject;
 109 class   ProfileCall;
 110 class   ProfileReturnType;
 111 class   ProfileInvoke;
 112 class   RuntimeCall;
 113 class   MemBar;
 114 class   RangeCheckPredicate;
 115 #ifdef ASSERT
 116 class   Assert;
 117 #endif
 118 
 119 // A Value is a reference to the instruction creating the value
 120 typedef Instruction* Value;
 121 typedef GrowableArray&lt;Value&gt; Values;
 122 typedef GrowableArray&lt;ValueStack*&gt; ValueStackStack;
 123 
 124 // BlockClosure is the base class for block traversal/iteration.
 125 
 126 class BlockClosure: public CompilationResourceObj {
 127  public:
 128   virtual void block_do(BlockBegin* block)       = 0;
 129 };
 130 
 131 
 132 // A simple closure class for visiting the values of an Instruction
 133 class ValueVisitor: public StackObj {
 134  public:
 135   virtual void visit(Value* v) = 0;
 136 };
 137 
 138 
 139 // Some array and list classes
 140 typedef GrowableArray&lt;BlockBegin*&gt; BlockBeginArray;
 141 
 142 class BlockList: public GrowableArray&lt;BlockBegin*&gt; {
 143  public:
 144   BlockList(): GrowableArray&lt;BlockBegin*&gt;() {}
 145   BlockList(const int size): GrowableArray&lt;BlockBegin*&gt;(size) {}
 146   BlockList(const int size, BlockBegin* init): GrowableArray&lt;BlockBegin*&gt;(size, size, init) {}
 147 
 148   void iterate_forward(BlockClosure* closure);
 149   void iterate_backward(BlockClosure* closure);
 150   void blocks_do(void f(BlockBegin*));
 151   void values_do(ValueVisitor* f);
 152   void print(bool cfg_only = false, bool live_only = false) PRODUCT_RETURN;
 153 };
 154 
 155 
 156 // InstructionVisitors provide type-based dispatch for instructions.
 157 // For each concrete Instruction class X, a virtual function do_X is
 158 // provided. Functionality that needs to be implemented for all classes
 159 // (e.g., printing, code generation) is factored out into a specialised
 160 // visitor instead of added to the Instruction classes itself.
 161 
 162 class InstructionVisitor: public StackObj {
 163  public:
 164   virtual void do_Phi            (Phi*             x) = 0;
 165   virtual void do_Local          (Local*           x) = 0;
 166   virtual void do_Constant       (Constant*        x) = 0;
 167   virtual void do_LoadField      (LoadField*       x) = 0;
 168   virtual void do_StoreField     (StoreField*      x) = 0;
 169   virtual void do_ArrayLength    (ArrayLength*     x) = 0;
 170   virtual void do_LoadIndexed    (LoadIndexed*     x) = 0;
 171   virtual void do_StoreIndexed   (StoreIndexed*    x) = 0;
 172   virtual void do_NegateOp       (NegateOp*        x) = 0;
 173   virtual void do_ArithmeticOp   (ArithmeticOp*    x) = 0;
 174   virtual void do_ShiftOp        (ShiftOp*         x) = 0;
 175   virtual void do_LogicOp        (LogicOp*         x) = 0;
 176   virtual void do_CompareOp      (CompareOp*       x) = 0;
 177   virtual void do_IfOp           (IfOp*            x) = 0;
 178   virtual void do_Convert        (Convert*         x) = 0;
 179   virtual void do_NullCheck      (NullCheck*       x) = 0;
 180   virtual void do_TypeCast       (TypeCast*        x) = 0;
 181   virtual void do_Invoke         (Invoke*          x) = 0;
 182   virtual void do_NewInstance    (NewInstance*     x) = 0;
 183   virtual void do_NewValueTypeInstance(NewValueTypeInstance* x) = 0;
 184   virtual void do_NewTypeArray   (NewTypeArray*    x) = 0;
 185   virtual void do_NewObjectArray (NewObjectArray*  x) = 0;
 186   virtual void do_NewMultiArray  (NewMultiArray*   x) = 0;
 187   virtual void do_WithField      (WithField*       x) = 0;
 188   virtual void do_DefaultValue   (DefaultValue*    x) = 0;
 189   virtual void do_CheckCast      (CheckCast*       x) = 0;
 190   virtual void do_InstanceOf     (InstanceOf*      x) = 0;
 191   virtual void do_MonitorEnter   (MonitorEnter*    x) = 0;
 192   virtual void do_MonitorExit    (MonitorExit*     x) = 0;
 193   virtual void do_Intrinsic      (Intrinsic*       x) = 0;
 194   virtual void do_BlockBegin     (BlockBegin*      x) = 0;
 195   virtual void do_Goto           (Goto*            x) = 0;
 196   virtual void do_If             (If*              x) = 0;
 197   virtual void do_IfInstanceOf   (IfInstanceOf*    x) = 0;
 198   virtual void do_TableSwitch    (TableSwitch*     x) = 0;
 199   virtual void do_LookupSwitch   (LookupSwitch*    x) = 0;
 200   virtual void do_Return         (Return*          x) = 0;
 201   virtual void do_Throw          (Throw*           x) = 0;
 202   virtual void do_Base           (Base*            x) = 0;
 203   virtual void do_OsrEntry       (OsrEntry*        x) = 0;
 204   virtual void do_ExceptionObject(ExceptionObject* x) = 0;
 205   virtual void do_RoundFP        (RoundFP*         x) = 0;
 206   virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x) = 0;
 207   virtual void do_UnsafePutRaw   (UnsafePutRaw*    x) = 0;
 208   virtual void do_UnsafeGetObject(UnsafeGetObject* x) = 0;
 209   virtual void do_UnsafePutObject(UnsafePutObject* x) = 0;
 210   virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) = 0;
 211   virtual void do_ProfileCall    (ProfileCall*     x) = 0;
 212   virtual void do_ProfileReturnType (ProfileReturnType*  x) = 0;
 213   virtual void do_ProfileInvoke  (ProfileInvoke*   x) = 0;
 214   virtual void do_RuntimeCall    (RuntimeCall*     x) = 0;
 215   virtual void do_MemBar         (MemBar*          x) = 0;
 216   virtual void do_RangeCheckPredicate(RangeCheckPredicate* x) = 0;
 217 #ifdef ASSERT
 218   virtual void do_Assert         (Assert*          x) = 0;
 219 #endif
 220 };
 221 
 222 
 223 // Hashing support
 224 //
 225 // Note: This hash functions affect the performance
 226 //       of ValueMap - make changes carefully!
 227 
 228 #define HASH1(x1            )                    ((intx)(x1))
 229 #define HASH2(x1, x2        )                    ((HASH1(x1        ) &lt;&lt; 7) ^ HASH1(x2))
 230 #define HASH3(x1, x2, x3    )                    ((HASH2(x1, x2    ) &lt;&lt; 7) ^ HASH1(x3))
 231 #define HASH4(x1, x2, x3, x4)                    ((HASH3(x1, x2, x3) &lt;&lt; 7) ^ HASH1(x4))
 232 
 233 
 234 // The following macros are used to implement instruction-specific hashing.
 235 // By default, each instruction implements hash() and is_equal(Value), used
 236 // for value numbering/common subexpression elimination. The default imple-
 237 // mentation disables value numbering. Each instruction which can be value-
 238 // numbered, should define corresponding hash() and is_equal(Value) functions
 239 // via the macros below. The f arguments specify all the values/op codes, etc.
 240 // that need to be identical for two instructions to be identical.
 241 //
 242 // Note: The default implementation of hash() returns 0 in order to indicate
 243 //       that the instruction should not be considered for value numbering.
 244 //       The currently used hash functions do not guarantee that never a 0
 245 //       is produced. While this is still correct, it may be a performance
 246 //       bug (no value numbering for that node). However, this situation is
 247 //       so unlikely, that we are not going to handle it specially.
 248 
 249 #define HASHING1(class_name, enabled, f1)             \
 250   virtual intx hash() const {                         \
 251     return (enabled) ? HASH2(name(), f1) : 0;         \
 252   }                                                   \
 253   virtual bool is_equal(Value v) const {              \
 254     if (!(enabled)  ) return false;                   \
 255     class_name* _v = v-&gt;as_##class_name();            \
 256     if (_v == NULL  ) return false;                   \
 257     if (f1 != _v-&gt;f1) return false;                   \
 258     return true;                                      \
 259   }                                                   \
 260 
 261 
 262 #define HASHING2(class_name, enabled, f1, f2)         \
 263   virtual intx hash() const {                         \
 264     return (enabled) ? HASH3(name(), f1, f2) : 0;     \
 265   }                                                   \
 266   virtual bool is_equal(Value v) const {              \
 267     if (!(enabled)  ) return false;                   \
 268     class_name* _v = v-&gt;as_##class_name();            \
 269     if (_v == NULL  ) return false;                   \
 270     if (f1 != _v-&gt;f1) return false;                   \
 271     if (f2 != _v-&gt;f2) return false;                   \
 272     return true;                                      \
 273   }                                                   \
 274 
 275 
 276 #define HASHING3(class_name, enabled, f1, f2, f3)     \
<a name="2" id="anc2"></a><span class="line-modified"> 277   virtual intx hash() const {                         \</span>
 278     return (enabled) ? HASH4(name(), f1, f2, f3) : 0; \
 279   }                                                   \
 280   virtual bool is_equal(Value v) const {              \
 281     if (!(enabled)  ) return false;                   \
 282     class_name* _v = v-&gt;as_##class_name();            \
 283     if (_v == NULL  ) return false;                   \
 284     if (f1 != _v-&gt;f1) return false;                   \
 285     if (f2 != _v-&gt;f2) return false;                   \
 286     if (f3 != _v-&gt;f3) return false;                   \
 287     return true;                                      \
 288   }                                                   \
 289 
 290 
 291 // The mother of all instructions...
 292 
 293 class Instruction: public CompilationResourceObj {
 294  private:
 295   int          _id;                              // the unique instruction id
 296 #ifndef PRODUCT
 297   int          _printable_bci;                   // the bci of the instruction for printing
 298 #endif
 299   int          _use_count;                       // the number of instructions refering to this value (w/o prev/next); only roots can have use count = 0 or &gt; 1
 300   int          _pin_state;                       // set of PinReason describing the reason for pinning
 301   ValueType*   _type;                            // the instruction value type
 302   Instruction* _next;                            // the next instruction if any (NULL for BlockEnd instructions)
 303   Instruction* _subst;                           // the substitution instruction if any
 304   LIR_Opr      _operand;                         // LIR specific information
 305   unsigned int _flags;                           // Flag bits
 306 
 307   ValueStack*  _state_before;                    // Copy of state with input operands still on stack (or NULL)
 308   ValueStack*  _exception_state;                 // Copy of state for exception handling
 309   XHandlers*   _exception_handlers;              // Flat list of exception handlers covering this instruction
 310 
 311   friend class UseCountComputer;
 312   friend class BlockBegin;
 313 
 314   void update_exception_state(ValueStack* state);
 315 
 316  protected:
 317   BlockBegin*  _block;                           // Block that contains this instruction
 318 
 319   void set_type(ValueType* type) {
 320     assert(type != NULL, &quot;type must exist&quot;);
 321     _type = type;
 322   }
 323 
 324   // Helper class to keep track of which arguments need a null check
 325   class ArgsNonNullState {
 326   private:
 327     int _nonnull_state; // mask identifying which args are nonnull
 328   public:
 329     ArgsNonNullState()
 330       : _nonnull_state(AllBits) {}
 331 
 332     // Does argument number i needs a null check?
 333     bool arg_needs_null_check(int i) const {
 334       // No data is kept for arguments starting at position 33 so
 335       // conservatively assume that they need a null check.
 336       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 337         return is_set_nth_bit(_nonnull_state, i);
 338       }
 339       return true;
 340     }
 341 
 342     // Set whether argument number i needs a null check or not
 343     void set_arg_needs_null_check(int i, bool check) {
 344       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 345         if (check) {
 346           _nonnull_state |= nth_bit(i);
 347         } else {
 348           _nonnull_state &amp;= ~(nth_bit(i));
 349         }
 350       }
 351     }
 352   };
 353 
 354  public:
 355   void* operator new(size_t size) throw() {
 356     Compilation* c = Compilation::current();
 357     void* res = c-&gt;arena()-&gt;Amalloc(size);
 358     ((Instruction*)res)-&gt;_id = c-&gt;get_next_id();
 359     return res;
 360   }
 361 
 362   static const int no_bci = -99;
 363 
 364   enum InstructionFlag {
 365     NeedsNullCheckFlag = 0,
 366     NeverNullFlag,          // For &quot;Q&quot; signatures
 367     CanTrapFlag,
 368     DirectCompareFlag,
 369     IsEliminatedFlag,
 370     IsSafepointFlag,
 371     IsStaticFlag,
 372     IsStrictfpFlag,
 373     NeedsStoreCheckFlag,
 374     NeedsWriteBarrierFlag,
 375     PreservesStateFlag,
 376     TargetIsFinalFlag,
 377     TargetIsLoadedFlag,
 378     TargetIsStrictfpFlag,
 379     UnorderedIsTrueFlag,
 380     NeedsPatchingFlag,
 381     ThrowIncompatibleClassChangeErrorFlag,
 382     InvokeSpecialReceiverCheckFlag,
 383     ProfileMDOFlag,
 384     IsLinkedInBlockFlag,
 385     NeedsRangeCheckFlag,
 386     InWorkListFlag,
 387     DeoptimizeOnException,
 388     InstructionLastFlag
 389   };
 390 
 391  public:
 392   bool check_flag(InstructionFlag id) const      { return (_flags &amp; (1 &lt;&lt; id)) != 0;    }
 393   void set_flag(InstructionFlag id, bool f)      { _flags = f ? (_flags | (1 &lt;&lt; id)) : (_flags &amp; ~(1 &lt;&lt; id)); };
 394 
 395   // &#39;globally&#39; used condition values
 396   enum Condition {
 397     eql, neq, lss, leq, gtr, geq, aeq, beq
 398   };
 399 
 400   // Instructions may be pinned for many reasons and under certain conditions
 401   // with enough knowledge it&#39;s possible to safely unpin them.
 402   enum PinReason {
 403       PinUnknown           = 1 &lt;&lt; 0
 404     , PinExplicitNullCheck = 1 &lt;&lt; 3
 405     , PinStackForStateSplit= 1 &lt;&lt; 12
 406     , PinStateSplitConstructor= 1 &lt;&lt; 13
 407     , PinGlobalValueNumbering= 1 &lt;&lt; 14
 408   };
 409 
 410   static Condition mirror(Condition cond);
 411   static Condition negate(Condition cond);
 412 
 413   // initialization
 414   static int number_of_instructions() {
 415     return Compilation::current()-&gt;number_of_instructions();
 416   }
 417 
 418   // creation
 419   Instruction(ValueType* type, ValueStack* state_before = NULL, bool type_is_constant = false)
 420   :
 421 #ifndef PRODUCT
 422   _printable_bci(-99),
 423 #endif
 424     _use_count(0)
 425   , _pin_state(0)
 426   , _type(type)
 427   , _next(NULL)
 428   , _subst(NULL)
 429   , _operand(LIR_OprFact::illegalOpr)
 430   , _flags(0)
 431   , _state_before(state_before)
 432   , _exception_handlers(NULL)
 433   , _block(NULL)
 434   {
 435     check_state(state_before);
 436     assert(type != NULL &amp;&amp; (!type-&gt;is_constant() || type_is_constant), &quot;type must exist&quot;);
 437     update_exception_state(_state_before);
 438   }
 439 
 440   // accessors
 441   int id() const                                 { return _id; }
 442 #ifndef PRODUCT
 443   bool has_printable_bci() const                 { return _printable_bci != -99; }
 444   int printable_bci() const                      { assert(has_printable_bci(), &quot;_printable_bci should have been set&quot;); return _printable_bci; }
 445   void set_printable_bci(int bci)                { _printable_bci = bci; }
 446 #endif
 447   int dominator_depth();
 448   int use_count() const                          { return _use_count; }
 449   int pin_state() const                          { return _pin_state; }
 450   bool is_pinned() const                         { return _pin_state != 0 || PinAllInstructions; }
 451   ValueType* type() const                        { return _type; }
 452   BlockBegin *block() const                      { return _block; }
 453   Instruction* prev();                           // use carefully, expensive operation
 454   Instruction* next() const                      { return _next; }
 455   bool has_subst() const                         { return _subst != NULL; }
 456   Instruction* subst()                           { return _subst == NULL ? this : _subst-&gt;subst(); }
 457   LIR_Opr operand() const                        { return _operand; }
 458 
 459   void set_needs_null_check(bool f)              { set_flag(NeedsNullCheckFlag, f); }
 460   bool needs_null_check() const                  { return check_flag(NeedsNullCheckFlag); }
 461   void set_never_null(bool f)                    { set_flag(NeverNullFlag, f); }
 462   bool is_never_null() const                     { return check_flag(NeverNullFlag); }
 463   bool is_linked() const                         { return check_flag(IsLinkedInBlockFlag); }
 464   bool can_be_linked()                           { return as_Local() == NULL &amp;&amp; as_Phi() == NULL; }
 465 
<a name="3" id="anc3"></a><span class="line-added"> 466   bool is_null_obj()                             { return as_Constant() != NULL &amp;&amp; type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object(); }</span>
<span class="line-added"> 467 </span>
 468   bool has_uses() const                          { return use_count() &gt; 0; }
 469   ValueStack* state_before() const               { return _state_before; }
 470   ValueStack* exception_state() const            { return _exception_state; }
 471   virtual bool needs_exception_state() const     { return true; }
 472   XHandlers* exception_handlers() const          { return _exception_handlers; }
 473   ciKlass* as_loaded_klass_or_null() const;
 474 
 475   // withfield optimization
 476   virtual void set_escaped()                     { }
 477   virtual void set_local_index(int index)        { }
 478   virtual bool is_optimizable_for_withfield() const { return false; }
 479 
 480 
 481   // manipulation
 482   void pin(PinReason reason)                     { _pin_state |= reason; }
 483   void pin()                                     { _pin_state |= PinUnknown; }
 484   // DANGEROUS: only used by EliminateStores
 485   void unpin(PinReason reason)                   { assert((reason &amp; PinUnknown) == 0, &quot;can&#39;t unpin unknown state&quot;); _pin_state &amp;= ~reason; }
 486 
 487   Instruction* set_next(Instruction* next) {
 488     assert(next-&gt;has_printable_bci(), &quot;_printable_bci should have been set&quot;);
 489     assert(next != NULL, &quot;must not be NULL&quot;);
 490     assert(as_BlockEnd() == NULL, &quot;BlockEnd instructions must have no next&quot;);
 491     assert(next-&gt;can_be_linked(), &quot;shouldn&#39;t link these instructions into list&quot;);
 492 
 493     BlockBegin *block = this-&gt;block();
 494     next-&gt;_block = block;
 495 
 496     next-&gt;set_flag(Instruction::IsLinkedInBlockFlag, true);
 497     _next = next;
 498     return next;
 499   }
 500 
 501   Instruction* set_next(Instruction* next, int bci) {
 502 #ifndef PRODUCT
 503     next-&gt;set_printable_bci(bci);
 504 #endif
 505     return set_next(next);
 506   }
 507 
 508   // when blocks are merged
 509   void fixup_block_pointers() {
 510     Instruction *cur = next()-&gt;next(); // next()&#39;s block is set in set_next
 511     while (cur &amp;&amp; cur-&gt;_block != block()) {
 512       cur-&gt;_block = block();
 513       cur = cur-&gt;next();
 514     }
 515   }
 516 
 517   Instruction *insert_after(Instruction *i) {
 518     Instruction* n = _next;
 519     set_next(i);
 520     i-&gt;set_next(n);
 521     return _next;
 522   }
 523 
 524   bool is_loaded_flattened_array() const;
 525   bool maybe_flattened_array();
 526   bool maybe_null_free_array();
 527 
 528   Instruction *insert_after_same_bci(Instruction *i) {
 529 #ifndef PRODUCT
 530     i-&gt;set_printable_bci(printable_bci());
 531 #endif
 532     return insert_after(i);
 533   }
 534 
 535   void set_subst(Instruction* subst)             {
 536     assert(subst == NULL ||
 537            type()-&gt;base() == subst-&gt;type()-&gt;base() ||
 538            subst-&gt;type()-&gt;base() == illegalType, &quot;type can&#39;t change&quot;);
 539     _subst = subst;
 540   }
 541   void set_exception_handlers(XHandlers *xhandlers) { _exception_handlers = xhandlers; }
 542   void set_exception_state(ValueStack* s)        { check_state(s); _exception_state = s; }
 543   void set_state_before(ValueStack* s)           { check_state(s); _state_before = s; }
 544 
 545   // machine-specifics
 546   void set_operand(LIR_Opr operand)              { assert(operand != LIR_OprFact::illegalOpr, &quot;operand must exist&quot;); _operand = operand; }
 547   void clear_operand()                           { _operand = LIR_OprFact::illegalOpr; }
 548 
 549   // generic
 550   virtual Instruction*      as_Instruction()     { return this; } // to satisfy HASHING1 macro
 551   virtual Phi*              as_Phi()             { return NULL; }
 552   virtual Local*            as_Local()           { return NULL; }
 553   virtual Constant*         as_Constant()        { return NULL; }
 554   virtual AccessField*      as_AccessField()     { return NULL; }
 555   virtual LoadField*        as_LoadField()       { return NULL; }
 556   virtual StoreField*       as_StoreField()      { return NULL; }
 557   virtual AccessArray*      as_AccessArray()     { return NULL; }
 558   virtual ArrayLength*      as_ArrayLength()     { return NULL; }
 559   virtual AccessIndexed*    as_AccessIndexed()   { return NULL; }
 560   virtual LoadIndexed*      as_LoadIndexed()     { return NULL; }
 561   virtual StoreIndexed*     as_StoreIndexed()    { return NULL; }
 562   virtual NegateOp*         as_NegateOp()        { return NULL; }
 563   virtual Op2*              as_Op2()             { return NULL; }
 564   virtual ArithmeticOp*     as_ArithmeticOp()    { return NULL; }
 565   virtual ShiftOp*          as_ShiftOp()         { return NULL; }
 566   virtual LogicOp*          as_LogicOp()         { return NULL; }
 567   virtual CompareOp*        as_CompareOp()       { return NULL; }
 568   virtual IfOp*             as_IfOp()            { return NULL; }
 569   virtual Convert*          as_Convert()         { return NULL; }
 570   virtual NullCheck*        as_NullCheck()       { return NULL; }
 571   virtual OsrEntry*         as_OsrEntry()        { return NULL; }
 572   virtual StateSplit*       as_StateSplit()      { return NULL; }
 573   virtual Invoke*           as_Invoke()          { return NULL; }
 574   virtual NewInstance*      as_NewInstance()     { return NULL; }
 575   virtual NewValueTypeInstance* as_NewValueTypeInstance() { return NULL; }
 576   virtual NewArray*         as_NewArray()        { return NULL; }
 577   virtual NewTypeArray*     as_NewTypeArray()    { return NULL; }
 578   virtual NewObjectArray*   as_NewObjectArray()  { return NULL; }
 579   virtual NewMultiArray*    as_NewMultiArray()   { return NULL; }
 580   virtual WithField*        as_WithField()       { return NULL; }
 581   virtual DefaultValue*     as_DefaultValue()    { return NULL; }
 582   virtual TypeCheck*        as_TypeCheck()       { return NULL; }
 583   virtual CheckCast*        as_CheckCast()       { return NULL; }
 584   virtual InstanceOf*       as_InstanceOf()      { return NULL; }
 585   virtual TypeCast*         as_TypeCast()        { return NULL; }
 586   virtual AccessMonitor*    as_AccessMonitor()   { return NULL; }
 587   virtual MonitorEnter*     as_MonitorEnter()    { return NULL; }
 588   virtual MonitorExit*      as_MonitorExit()     { return NULL; }
 589   virtual Intrinsic*        as_Intrinsic()       { return NULL; }
 590   virtual BlockBegin*       as_BlockBegin()      { return NULL; }
 591   virtual BlockEnd*         as_BlockEnd()        { return NULL; }
 592   virtual Goto*             as_Goto()            { return NULL; }
 593   virtual If*               as_If()              { return NULL; }
 594   virtual IfInstanceOf*     as_IfInstanceOf()    { return NULL; }
 595   virtual TableSwitch*      as_TableSwitch()     { return NULL; }
 596   virtual LookupSwitch*     as_LookupSwitch()    { return NULL; }
 597   virtual Return*           as_Return()          { return NULL; }
 598   virtual Throw*            as_Throw()           { return NULL; }
 599   virtual Base*             as_Base()            { return NULL; }
 600   virtual RoundFP*          as_RoundFP()         { return NULL; }
 601   virtual ExceptionObject*  as_ExceptionObject() { return NULL; }
 602   virtual UnsafeOp*         as_UnsafeOp()        { return NULL; }
 603   virtual ProfileInvoke*    as_ProfileInvoke()   { return NULL; }
 604   virtual RangeCheckPredicate* as_RangeCheckPredicate() { return NULL; }
 605 
 606 #ifdef ASSERT
 607   virtual Assert*           as_Assert()          { return NULL; }
 608 #endif
 609 
 610   virtual void visit(InstructionVisitor* v)      = 0;
 611 
 612   virtual bool can_trap() const                  { return false; }
 613 
 614   virtual void input_values_do(ValueVisitor* f)   = 0;
 615   virtual void state_values_do(ValueVisitor* f);
 616   virtual void other_values_do(ValueVisitor* f)   { /* usually no other - override on demand */ }
 617           void       values_do(ValueVisitor* f)   { input_values_do(f); state_values_do(f); other_values_do(f); }
 618 
 619   virtual ciType* exact_type() const;
 620   virtual ciType* declared_type() const          { return NULL; }
 621 
 622   // hashing
 623   virtual const char* name() const               = 0;
 624   HASHING1(Instruction, false, id())             // hashing disabled by default
 625 
 626   // debugging
 627   static void check_state(ValueStack* state)     PRODUCT_RETURN;
 628   void print()                                   PRODUCT_RETURN;
 629   void print_line()                              PRODUCT_RETURN;
 630   void print(InstructionPrinter&amp; ip)             PRODUCT_RETURN;
 631 };
 632 
 633 
 634 // The following macros are used to define base (i.e., non-leaf)
 635 // and leaf instruction classes. They define class-name related
 636 // generic functionality in one place.
 637 
 638 #define BASE(class_name, super_class_name)       \
 639   class class_name: public super_class_name {    \
 640    public:                                       \
 641     virtual class_name* as_##class_name()        { return this; }              \
 642 
 643 
 644 #define LEAF(class_name, super_class_name)       \
 645   BASE(class_name, super_class_name)             \
 646    public:                                       \
 647     virtual const char* name() const             { return #class_name; }       \
 648     virtual void visit(InstructionVisitor* v)    { v-&gt;do_##class_name(this); } \
 649 
 650 
 651 // Debugging support
 652 
 653 
 654 #ifdef ASSERT
 655 class AssertValues: public ValueVisitor {
 656   void visit(Value* x)             { assert((*x) != NULL, &quot;value must exist&quot;); }
 657 };
 658   #define ASSERT_VALUES                          { AssertValues assert_value; values_do(&amp;assert_value); }
 659 #else
 660   #define ASSERT_VALUES
 661 #endif // ASSERT
 662 
 663 
 664 // A Phi is a phi function in the sense of SSA form. It stands for
 665 // the value of a local variable at the beginning of a join block.
 666 // A Phi consists of n operands, one for every incoming branch.
 667 
 668 LEAF(Phi, Instruction)
 669  private:
 670   int         _pf_flags; // the flags of the phi function
 671   int         _index;    // to value on operand stack (index &lt; 0) or to local
 672  public:
 673   // creation
 674   Phi(ValueType* type, BlockBegin* b, int index)
 675   : Instruction(type-&gt;base())
 676   , _pf_flags(0)
 677   , _index(index)
 678   {
 679     _block = b;
 680     NOT_PRODUCT(set_printable_bci(Value(b)-&gt;printable_bci()));
 681     if (type-&gt;is_illegal()) {
 682       make_illegal();
 683     }
 684   }
 685 
 686   // flags
 687   enum Flag {
 688     no_flag         = 0,
 689     visited         = 1 &lt;&lt; 0,
 690     cannot_simplify = 1 &lt;&lt; 1
 691   };
 692 
 693   // accessors
 694   bool  is_local() const          { return _index &gt;= 0; }
 695   bool  is_on_stack() const       { return !is_local(); }
 696   int   local_index() const       { assert(is_local(), &quot;&quot;); return _index; }
 697   int   stack_index() const       { assert(is_on_stack(), &quot;&quot;); return -(_index+1); }
 698 
 699   Value operand_at(int i) const;
 700   int   operand_count() const;
 701 
 702   void   set(Flag f)              { _pf_flags |=  f; }
 703   void   clear(Flag f)            { _pf_flags &amp;= ~f; }
 704   bool   is_set(Flag f) const     { return (_pf_flags &amp; f) != 0; }
 705 
 706   // Invalidates phis corresponding to merges of locals of two different types
 707   // (these should never be referenced, otherwise the bytecodes are illegal)
 708   void   make_illegal() {
 709     set(cannot_simplify);
 710     set_type(illegalType);
 711   }
 712 
 713   bool is_illegal() const {
 714     return type()-&gt;is_illegal();
 715   }
 716 
 717   // generic
 718   virtual void input_values_do(ValueVisitor* f) {
 719   }
 720 };
 721 
 722 
 723 // A local is a placeholder for an incoming argument to a function call.
 724 LEAF(Local, Instruction)
 725  private:
 726   int      _java_index;                          // the local index within the method to which the local belongs
 727   bool     _is_receiver;                         // if local variable holds the receiver: &quot;this&quot; for non-static methods
 728   ciType*  _declared_type;
 729  public:
 730   // creation
 731   Local(ciType* declared, ValueType* type, int index, bool receiver, bool never_null)
 732     : Instruction(type)
 733     , _java_index(index)
 734     , _is_receiver(receiver)
 735     , _declared_type(declared)
 736   {
 737     set_never_null(never_null);
 738     NOT_PRODUCT(set_printable_bci(-1));
 739   }
 740 
 741   // accessors
 742   int java_index() const                         { return _java_index; }
 743   bool is_receiver() const                       { return _is_receiver; }
 744 
 745   virtual ciType* declared_type() const          { return _declared_type; }
 746 
 747   // generic
 748   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 749 };
 750 
 751 
 752 LEAF(Constant, Instruction)
 753  public:
 754   // creation
 755   Constant(ValueType* type):
 756       Instruction(type, NULL, /*type_is_constant*/ true)
 757   {
 758     assert(type-&gt;is_constant(), &quot;must be a constant&quot;);
 759   }
 760 
 761   Constant(ValueType* type, ValueStack* state_before):
 762     Instruction(type, state_before, /*type_is_constant*/ true)
 763   {
 764     assert(state_before != NULL, &quot;only used for constants which need patching&quot;);
 765     assert(type-&gt;is_constant(), &quot;must be a constant&quot;);
 766     // since it&#39;s patching it needs to be pinned
 767     pin();
 768   }
 769 
 770   // generic
 771   virtual bool can_trap() const                  { return state_before() != NULL; }
 772   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 773 
 774   virtual intx hash() const;
 775   virtual bool is_equal(Value v) const;
 776 
 777   virtual ciType* exact_type() const;
 778 
 779   enum CompareResult { not_comparable = -1, cond_false, cond_true };
 780 
 781   virtual CompareResult compare(Instruction::Condition condition, Value right) const;
 782   BlockBegin* compare(Instruction::Condition cond, Value right,
 783                       BlockBegin* true_sux, BlockBegin* false_sux) const {
 784     switch (compare(cond, right)) {
 785     case not_comparable:
 786       return NULL;
 787     case cond_false:
 788       return false_sux;
 789     case cond_true:
 790       return true_sux;
 791     default:
 792       ShouldNotReachHere();
 793       return NULL;
 794     }
 795   }
 796 };
 797 
 798 
 799 BASE(AccessField, Instruction)
 800  private:
 801   Value       _obj;
 802   int         _offset;
 803   ciField*    _field;
 804   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 805 
 806  public:
 807   // creation
 808   AccessField(Value obj, int offset, ciField* field, bool is_static,
 809               ValueStack* state_before, bool needs_patching)
 810   : Instruction(as_ValueType(field-&gt;type()-&gt;basic_type()), state_before)
 811   , _obj(obj)
 812   , _offset(offset)
 813   , _field(field)
 814   , _explicit_null_check(NULL)
 815   {
 816     set_needs_null_check(!is_static);
 817     set_flag(IsStaticFlag, is_static);
 818     set_flag(NeedsPatchingFlag, needs_patching);
 819     ASSERT_VALUES
 820     // pin of all instructions with memory access
 821     pin();
 822   }
 823 
 824   // accessors
 825   Value obj() const                              { return _obj; }
 826   int offset() const                             { return _offset; }
 827   ciField* field() const                         { return _field; }
 828   BasicType field_type() const                   { return _field-&gt;type()-&gt;basic_type(); }
 829   bool is_static() const                         { return check_flag(IsStaticFlag); }
 830   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 831   bool needs_patching() const                    { return check_flag(NeedsPatchingFlag); }
 832 
 833   // Unresolved getstatic and putstatic can cause initialization.
 834   // Technically it occurs at the Constant that materializes the base
 835   // of the static fields but it&#39;s simpler to model it here.
 836   bool is_init_point() const                     { return is_static() &amp;&amp; (needs_patching() || !_field-&gt;holder()-&gt;is_initialized()); }
 837 
 838   // manipulation
 839 
 840   // Under certain circumstances, if a previous NullCheck instruction
 841   // proved the target object non-null, we can eliminate the explicit
 842   // null check and do an implicit one, simply specifying the debug
 843   // information from the NullCheck. This field should only be consulted
 844   // if needs_null_check() is true.
 845   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 846 
 847   // generic
 848   virtual bool can_trap() const                  { return needs_null_check() || needs_patching(); }
 849   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
 850 };
 851 
 852 
 853 LEAF(LoadField, AccessField)
 854  public:
 855   // creation
 856   LoadField(Value obj, int offset, ciField* field, bool is_static,
 857             ValueStack* state_before, bool needs_patching,
 858             ciValueKlass* value_klass = NULL, Value default_value = NULL )
 859   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 860   {}
 861 
 862   ciType* declared_type() const;
 863 
<a name="4" id="anc4"></a><span class="line-modified"> 864   // generic; cannot be eliminated if needs patching or if volatile.</span>
<span class="line-modified"> 865   HASHING3(LoadField, !needs_patching() &amp;&amp; !field()-&gt;is_volatile(), obj()-&gt;subst(), offset(), declared_type())</span>
 866 };
 867 
 868 
 869 LEAF(StoreField, AccessField)
 870  private:
 871   Value _value;
 872 
 873  public:
 874   // creation
 875   StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,
 876              ValueStack* state_before, bool needs_patching)
 877   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 878   , _value(value)
 879   {
 880     set_flag(NeedsWriteBarrierFlag, as_ValueType(field_type())-&gt;is_object());
 881     ASSERT_VALUES
 882     pin();
 883   }
 884 
 885   // accessors
 886   Value value() const                            { return _value; }
 887   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
 888 
 889   // generic
 890   virtual void input_values_do(ValueVisitor* f)   { AccessField::input_values_do(f); f-&gt;visit(&amp;_value); }
 891 };
 892 
 893 
 894 BASE(AccessArray, Instruction)
 895  private:
 896   Value       _array;
 897 
 898  public:
 899   // creation
 900   AccessArray(ValueType* type, Value array, ValueStack* state_before)
 901   : Instruction(type, state_before)
 902   , _array(array)
 903   {
 904     set_needs_null_check(true);
 905     ASSERT_VALUES
 906     pin(); // instruction with side effect (null exception or range check throwing)
 907   }
 908 
 909   Value array() const                            { return _array; }
 910 
 911   // generic
 912   virtual bool can_trap() const                  { return needs_null_check(); }
 913   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_array); }
 914 };
 915 
 916 
 917 LEAF(ArrayLength, AccessArray)
 918  private:
 919   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 920 
 921  public:
 922   // creation
 923   ArrayLength(Value array, ValueStack* state_before)
 924   : AccessArray(intType, array, state_before)
 925   , _explicit_null_check(NULL) {}
 926 
 927   // accessors
 928   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 929 
 930   // setters
 931   // See LoadField::set_explicit_null_check for documentation
 932   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 933 
 934   // generic
 935   HASHING1(ArrayLength, true, array()-&gt;subst())
 936 };
 937 
 938 
 939 BASE(AccessIndexed, AccessArray)
 940  private:
 941   Value     _index;
 942   Value     _length;
 943   BasicType _elt_type;
 944   bool      _mismatched;
 945   ciMethod* _profiled_method;
 946   int       _profiled_bci;
 947 
 948  public:
 949   // creation
 950   AccessIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched)
 951   : AccessArray(as_ValueType(elt_type), array, state_before)
 952   , _index(index)
 953   , _length(length)
 954   , _elt_type(elt_type)
 955   , _mismatched(mismatched)
 956   , _profiled_method(NULL), _profiled_bci(0)
 957   {
 958     set_flag(Instruction::NeedsRangeCheckFlag, true);
 959     ASSERT_VALUES
 960   }
 961 
 962   // accessors
 963   Value index() const                            { return _index; }
 964   Value length() const                           { return _length; }
 965   BasicType elt_type() const                     { return _elt_type; }
 966   bool mismatched() const                        { return _mismatched; }
 967 
 968   void clear_length()                            { _length = NULL; }
 969   // perform elimination of range checks involving constants
 970   bool compute_needs_range_check();
 971 
 972   // Helpers for MethodData* profiling
 973   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
 974   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
 975   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
 976   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
 977   ciMethod* profiled_method() const                  { return _profiled_method;     }
 978   int       profiled_bci() const                     { return _profiled_bci;        }
 979 
 980 
 981 // generic
 982   virtual void input_values_do(ValueVisitor* f)   { AccessArray::input_values_do(f); f-&gt;visit(&amp;_index); if (_length != NULL) f-&gt;visit(&amp;_length); }
 983 };
 984 
 985 
 986 LEAF(LoadIndexed, AccessIndexed)
 987  private:
 988   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 989   NewValueTypeInstance* _vt;
 990 
 991  public:
 992   // creation
 993   LoadIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched = false)
 994   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
 995   , _explicit_null_check(NULL), _vt(NULL) {}
 996 
 997   // accessors
 998   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 999 
1000   // setters
1001   // See LoadField::set_explicit_null_check for documentation
1002   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
1003 
1004   ciType* exact_type() const;
1005   ciType* declared_type() const;
1006 
1007   NewValueTypeInstance* vt() const { return _vt; }
1008   void set_vt(NewValueTypeInstance* vt) { _vt = vt; }
1009 
1010   // generic
1011   HASHING3(LoadIndexed, !should_profile(), array()-&gt;subst(), index()-&gt;subst(), vt())
1012 };
1013 
1014 
1015 LEAF(StoreIndexed, AccessIndexed)
1016  private:
1017   Value       _value;
1018 
1019   bool      _check_boolean;
1020 
1021  public:
1022   // creation
1023   StoreIndexed(Value array, Value index, Value length, BasicType elt_type, Value value, ValueStack* state_before,
1024                bool check_boolean, bool mismatched = false)
1025   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
1026   , _value(value), _check_boolean(check_boolean)
1027   {
1028     set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)-&gt;is_object()));
1029     set_flag(NeedsStoreCheckFlag, (as_ValueType(elt_type)-&gt;is_object()));
1030     ASSERT_VALUES
1031     pin();
1032   }
1033 
1034   // accessors
1035   Value value() const                            { return _value; }
1036   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
1037   bool needs_store_check() const                 { return check_flag(NeedsStoreCheckFlag); }
1038   bool check_boolean() const                     { return _check_boolean; }
1039 
1040   // Flattened array support
1041   bool is_exact_flattened_array_store() const;
1042   // generic
1043   virtual void input_values_do(ValueVisitor* f)   { AccessIndexed::input_values_do(f); f-&gt;visit(&amp;_value); }
1044 };
1045 
1046 
1047 LEAF(NegateOp, Instruction)
1048  private:
1049   Value _x;
1050 
1051  public:
1052   // creation
1053   NegateOp(Value x) : Instruction(x-&gt;type()-&gt;base()), _x(x) {
1054     ASSERT_VALUES
1055   }
1056 
1057   // accessors
1058   Value x() const                                { return _x; }
1059 
1060   // generic
1061   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); }
1062 };
1063 
1064 
1065 BASE(Op2, Instruction)
1066  private:
1067   Bytecodes::Code _op;
1068   Value           _x;
1069   Value           _y;
1070 
1071  public:
1072   // creation
1073   Op2(ValueType* type, Bytecodes::Code op, Value x, Value y, ValueStack* state_before = NULL)
1074   : Instruction(type, state_before)
1075   , _op(op)
1076   , _x(x)
1077   , _y(y)
1078   {
1079     ASSERT_VALUES
1080   }
1081 
1082   // accessors
1083   Bytecodes::Code op() const                     { return _op; }
1084   Value x() const                                { return _x; }
1085   Value y() const                                { return _y; }
1086 
1087   // manipulators
1088   void swap_operands() {
1089     assert(is_commutative(), &quot;operation must be commutative&quot;);
1090     Value t = _x; _x = _y; _y = t;
1091   }
1092 
1093   // generic
1094   virtual bool is_commutative() const            { return false; }
1095   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
1096 };
1097 
1098 
1099 LEAF(ArithmeticOp, Op2)
1100  public:
1101   // creation
1102   ArithmeticOp(Bytecodes::Code op, Value x, Value y, bool is_strictfp, ValueStack* state_before)
1103   : Op2(x-&gt;type()-&gt;meet(y-&gt;type()), op, x, y, state_before)
1104   {
1105     set_flag(IsStrictfpFlag, is_strictfp);
1106     if (can_trap()) pin();
1107   }
1108 
1109   // accessors
1110   bool        is_strictfp() const                { return check_flag(IsStrictfpFlag); }
1111 
1112   // generic
1113   virtual bool is_commutative() const;
1114   virtual bool can_trap() const;
1115   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1116 };
1117 
1118 
1119 LEAF(ShiftOp, Op2)
1120  public:
1121   // creation
1122   ShiftOp(Bytecodes::Code op, Value x, Value s) : Op2(x-&gt;type()-&gt;base(), op, x, s) {}
1123 
1124   // generic
1125   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1126 };
1127 
1128 
1129 LEAF(LogicOp, Op2)
1130  public:
1131   // creation
1132   LogicOp(Bytecodes::Code op, Value x, Value y) : Op2(x-&gt;type()-&gt;meet(y-&gt;type()), op, x, y) {}
1133 
1134   // generic
1135   virtual bool is_commutative() const;
1136   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1137 };
1138 
1139 
1140 LEAF(CompareOp, Op2)
1141  public:
1142   // creation
1143   CompareOp(Bytecodes::Code op, Value x, Value y, ValueStack* state_before)
1144   : Op2(intType, op, x, y, state_before)
1145   {}
1146 
1147   // generic
1148   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1149 };
1150 
1151 
1152 LEAF(IfOp, Op2)
1153  private:
1154   Value _tval;
1155   Value _fval;
1156   bool _substitutability_check;
1157 
1158  public:
1159   // creation
1160   IfOp(Value x, Condition cond, Value y, Value tval, Value fval, ValueStack* state_before, bool substitutability_check)
1161   : Op2(tval-&gt;type()-&gt;meet(fval-&gt;type()), (Bytecodes::Code)cond, x, y)
1162   , _tval(tval)
1163   , _fval(fval)
1164   , _substitutability_check(substitutability_check)
1165   {
1166     ASSERT_VALUES
1167     assert(tval-&gt;type()-&gt;tag() == fval-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1168     set_state_before(state_before);
1169   }
1170 
1171   // accessors
1172   virtual bool is_commutative() const;
1173   Bytecodes::Code op() const                     { ShouldNotCallThis(); return Bytecodes::_illegal; }
1174   Condition cond() const                         { return (Condition)Op2::op(); }
1175   Value tval() const                             { return _tval; }
1176   Value fval() const                             { return _fval; }
1177   bool substitutability_check() const             { return _substitutability_check; }
1178   // generic
1179   virtual void input_values_do(ValueVisitor* f)   { Op2::input_values_do(f); f-&gt;visit(&amp;_tval); f-&gt;visit(&amp;_fval); }
1180 };
1181 
1182 
1183 LEAF(Convert, Instruction)
1184  private:
1185   Bytecodes::Code _op;
1186   Value           _value;
1187 
1188  public:
1189   // creation
1190   Convert(Bytecodes::Code op, Value value, ValueType* to_type) : Instruction(to_type), _op(op), _value(value) {
1191     ASSERT_VALUES
1192   }
1193 
1194   // accessors
1195   Bytecodes::Code op() const                     { return _op; }
1196   Value value() const                            { return _value; }
1197 
1198   // generic
1199   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_value); }
1200   HASHING2(Convert, true, op(), value()-&gt;subst())
1201 };
1202 
1203 
1204 LEAF(NullCheck, Instruction)
1205  private:
1206   Value       _obj;
1207 
1208  public:
1209   // creation
1210   NullCheck(Value obj, ValueStack* state_before)
1211   : Instruction(obj-&gt;type()-&gt;base(), state_before)
1212   , _obj(obj)
1213   {
1214     ASSERT_VALUES
1215     set_can_trap(true);
1216     assert(_obj-&gt;type()-&gt;is_object(), &quot;null check must be applied to objects only&quot;);
1217     pin(Instruction::PinExplicitNullCheck);
1218   }
1219 
1220   // accessors
1221   Value obj() const                              { return _obj; }
1222 
1223   // setters
1224   void set_can_trap(bool can_trap)               { set_flag(CanTrapFlag, can_trap); }
1225 
1226   // generic
1227   virtual bool can_trap() const                  { return check_flag(CanTrapFlag); /* null-check elimination sets to false */ }
1228   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
1229   HASHING1(NullCheck, true, obj()-&gt;subst())
1230 };
1231 
1232 
1233 // This node is supposed to cast the type of another node to a more precise
1234 // declared type.
1235 LEAF(TypeCast, Instruction)
1236  private:
1237   ciType* _declared_type;
1238   Value   _obj;
1239 
1240  public:
1241   // The type of this node is the same type as the object type (and it might be constant).
1242   TypeCast(ciType* type, Value obj, ValueStack* state_before)
1243   : Instruction(obj-&gt;type(), state_before, obj-&gt;type()-&gt;is_constant()),
1244     _declared_type(type),
1245     _obj(obj) {}
1246 
1247   // accessors
1248   ciType* declared_type() const                  { return _declared_type; }
1249   Value   obj() const                            { return _obj; }
1250 
1251   // generic
1252   virtual void input_values_do(ValueVisitor* f)  { f-&gt;visit(&amp;_obj); }
1253 };
1254 
1255 
1256 BASE(StateSplit, Instruction)
1257  private:
1258   ValueStack* _state;
1259 
1260  protected:
1261   static void substitute(BlockList&amp; list, BlockBegin* old_block, BlockBegin* new_block);
1262 
1263  public:
1264   // creation
1265   StateSplit(ValueType* type, ValueStack* state_before = NULL)
1266   : Instruction(type, state_before)
1267   , _state(NULL)
1268   {
1269     pin(PinStateSplitConstructor);
1270   }
1271 
1272   // accessors
1273   ValueStack* state() const                      { return _state; }
1274   IRScope* scope() const;                        // the state&#39;s scope
1275 
1276   // manipulation
1277   void set_state(ValueStack* state)              { assert(_state == NULL, &quot;overwriting existing state&quot;); check_state(state); _state = state; }
1278 
1279   // generic
1280   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
1281   virtual void state_values_do(ValueVisitor* f);
1282 };
1283 
1284 
1285 LEAF(Invoke, StateSplit)
1286  private:
1287   Bytecodes::Code _code;
1288   Value           _recv;
1289   Values*         _args;
1290   BasicTypeList*  _signature;
1291   int             _vtable_index;
1292   ciMethod*       _target;
1293 
1294  public:
1295   // creation
1296   Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
1297          int vtable_index, ciMethod* target, ValueStack* state_before, bool never_null);
1298 
1299   // accessors
1300   Bytecodes::Code code() const                   { return _code; }
1301   Value receiver() const                         { return _recv; }
1302   bool has_receiver() const                      { return receiver() != NULL; }
1303   int number_of_arguments() const                { return _args-&gt;length(); }
1304   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1305   int vtable_index() const                       { return _vtable_index; }
1306   BasicTypeList* signature() const               { return _signature; }
1307   ciMethod* target() const                       { return _target; }
1308 
1309   ciType* declared_type() const;
1310 
1311   // Returns false if target is not loaded
1312   bool target_is_final() const                   { return check_flag(TargetIsFinalFlag); }
1313   bool target_is_loaded() const                  { return check_flag(TargetIsLoadedFlag); }
1314   // Returns false if target is not loaded
1315   bool target_is_strictfp() const                { return check_flag(TargetIsStrictfpFlag); }
1316 
1317   // JSR 292 support
1318   bool is_invokedynamic() const                  { return code() == Bytecodes::_invokedynamic; }
1319   bool is_method_handle_intrinsic() const        { return target()-&gt;is_method_handle_intrinsic(); }
1320 
1321   virtual bool needs_exception_state() const     { return false; }
1322 
1323   // generic
1324   virtual bool can_trap() const                  { return true; }
1325   virtual void input_values_do(ValueVisitor* f) {
1326     StateSplit::input_values_do(f);
1327     if (has_receiver()) f-&gt;visit(&amp;_recv);
1328     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
1329   }
1330   virtual void state_values_do(ValueVisitor *f);
1331 };
1332 
1333 
1334 LEAF(NewInstance, StateSplit)
1335  private:
1336   ciInstanceKlass* _klass;
1337   bool _is_unresolved;
1338 
1339  public:
1340   // creation
1341   NewInstance(ciInstanceKlass* klass, ValueStack* state_before, bool is_unresolved)
1342   : StateSplit(instanceType, state_before)
1343   , _klass(klass), _is_unresolved(is_unresolved)
1344   {}
1345 
1346   // accessors
1347   ciInstanceKlass* klass() const                 { return _klass; }
1348   bool is_unresolved() const                     { return _is_unresolved; }
1349 
1350   virtual bool needs_exception_state() const     { return false; }
1351 
1352   // generic
1353   virtual bool can_trap() const                  { return true; }
1354   ciType* exact_type() const;
1355   ciType* declared_type() const;
1356 };
1357 
1358 LEAF(NewValueTypeInstance, StateSplit)
1359   bool _is_unresolved;
1360   ciValueKlass* _klass;
1361   Value _depends_on;      // Link to instance on with withfield was called on
1362   bool _is_optimizable_for_withfield;
1363   int _first_local_index;
1364 public:
1365 
1366   // Default creation, always allocated for now
1367   NewValueTypeInstance(ciValueKlass* klass, ValueStack* state_before, bool is_unresolved, Value depends_on = NULL, bool from_default_value = false)
1368   : StateSplit(instanceType, state_before)
1369    , _is_unresolved(is_unresolved)
1370    , _klass(klass)
1371    , _is_optimizable_for_withfield(from_default_value)
1372    , _first_local_index(-1)
1373   {
1374     if (depends_on == NULL) {
1375       _depends_on = this;
1376     } else {
1377       _depends_on = depends_on;
1378     }
1379     set_never_null(true);
1380   }
1381 
1382   // accessors
1383   bool is_unresolved() const                     { return _is_unresolved; }
1384   Value depends_on();
1385 
1386   ciValueKlass* klass() const { return _klass; }
1387 
1388   virtual bool needs_exception_state() const     { return false; }
1389 
1390   // generic
1391   virtual bool can_trap() const                  { return true; }
1392   ciType* exact_type() const;
1393   ciType* declared_type() const;
1394 
1395   // Only done in LIR Generator -&gt; map everything to object
1396   void set_to_object_type() { set_type(instanceType); }
1397 
1398   // withfield optimization
1399   virtual void set_escaped() {
1400     _is_optimizable_for_withfield = false;
1401   }
1402   virtual void set_local_index(int index) {
1403     if (_first_local_index != index) {
1404       if (_first_local_index == -1) {
1405         _first_local_index = index;
1406       } else {
1407         _is_optimizable_for_withfield = false;
1408       }
1409     }
1410   }
1411   virtual bool is_optimizable_for_withfield() const {  return _is_optimizable_for_withfield; }
1412 };
1413 
1414 BASE(NewArray, StateSplit)
1415  private:
1416   Value       _length;
1417 
1418  public:
1419   // creation
1420   NewArray(Value length, ValueStack* state_before)
1421   : StateSplit(objectType, state_before)
1422   , _length(length)
1423   {
1424     // Do not ASSERT_VALUES since length is NULL for NewMultiArray
1425   }
1426 
1427   // accessors
1428   Value length() const                           { return _length; }
1429 
1430   virtual bool needs_exception_state() const     { return false; }
1431 
1432   ciType* exact_type() const                     { return NULL; }
1433   ciType* declared_type() const;
1434 
1435   // generic
1436   virtual bool can_trap() const                  { return true; }
1437   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_length); }
1438 };
1439 
1440 
1441 LEAF(NewTypeArray, NewArray)
1442  private:
1443   BasicType _elt_type;
1444 
1445  public:
1446   // creation
1447   NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before)
1448   : NewArray(length, state_before)
1449   , _elt_type(elt_type)
1450   {}
1451 
1452   // accessors
1453   BasicType elt_type() const                     { return _elt_type; }
1454   ciType* exact_type() const;
1455 };
1456 
1457 
1458 LEAF(NewObjectArray, NewArray)
1459  private:
1460   ciKlass* _klass;
1461 
1462  public:
1463   // creation
1464   NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before, bool never_null)
1465   : NewArray(length, state_before), _klass(klass) {
1466     set_never_null(never_null);
1467   }
1468 
1469   // accessors
1470   ciKlass* klass() const                         { return _klass; }
1471   ciType* exact_type() const;
1472 };
1473 
1474 
1475 LEAF(NewMultiArray, NewArray)
1476  private:
1477   ciKlass* _klass;
1478   Values*  _dims;
1479 
1480  public:
1481   // creation
1482   NewMultiArray(ciKlass* klass, Values* dims, ValueStack* state_before) : NewArray(NULL, state_before), _klass(klass), _dims(dims) {
1483     ASSERT_VALUES
1484   }
1485 
1486   // accessors
1487   ciKlass* klass() const                         { return _klass; }
1488   Values* dims() const                           { return _dims; }
1489   int rank() const                               { return dims()-&gt;length(); }
1490 
1491   // generic
1492   virtual void input_values_do(ValueVisitor* f) {
1493     // NOTE: we do not call NewArray::input_values_do since &quot;length&quot;
1494     // is meaningless for a multi-dimensional array; passing the
1495     // zeroth element down to NewArray as its length is a bad idea
1496     // since there will be a copy in the &quot;dims&quot; array which doesn&#39;t
1497     // get updated, and the value must not be traversed twice. Was bug
1498     // - kbr 4/10/2001
1499     StateSplit::input_values_do(f);
1500     for (int i = 0; i &lt; _dims-&gt;length(); i++) f-&gt;visit(_dims-&gt;adr_at(i));
1501   }
1502 
1503   ciType* exact_type() const;
1504 };
1505 
1506 LEAF(WithField, StateSplit)
1507  public:
1508   // creation
1509   WithField(ValueStack* state_before)
1510   : StateSplit(objectType, state_before) {}
1511 };
1512 
1513 LEAF(DefaultValue, StateSplit)
1514  public:
1515   // creation
1516   DefaultValue(ValueStack* state_before)
1517   : StateSplit(objectType, state_before) {}
1518 };
1519 
1520 BASE(TypeCheck, StateSplit)
1521  private:
1522   ciKlass*    _klass;
1523   Value       _obj;
1524 
1525   ciMethod* _profiled_method;
1526   int       _profiled_bci;
1527 
1528  public:
1529   // creation
1530   TypeCheck(ciKlass* klass, Value obj, ValueType* type, ValueStack* state_before)
1531   : StateSplit(type, state_before), _klass(klass), _obj(obj),
1532     _profiled_method(NULL), _profiled_bci(0) {
1533     ASSERT_VALUES
1534     set_direct_compare(false);
1535   }
1536 
1537   // accessors
1538   ciKlass* klass() const                         { return _klass; }
1539   Value obj() const                              { return _obj; }
1540   bool is_loaded() const                         { return klass() != NULL; }
1541   bool direct_compare() const                    { return check_flag(DirectCompareFlag); }
1542 
1543   // manipulation
1544   void set_direct_compare(bool flag)             { set_flag(DirectCompareFlag, flag); }
1545 
1546   // generic
1547   virtual bool can_trap() const                  { return true; }
1548   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1549 
1550   // Helpers for MethodData* profiling
1551   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
1552   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
1553   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
1554   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
1555   ciMethod* profiled_method() const                  { return _profiled_method;     }
1556   int       profiled_bci() const                     { return _profiled_bci;        }
1557 };
1558 
1559 
1560 LEAF(CheckCast, TypeCheck)
1561  public:
1562   // creation
1563   CheckCast(ciKlass* klass, Value obj, ValueStack* state_before, bool never_null = false)
1564   : TypeCheck(klass, obj, objectType, state_before) {
1565     set_never_null(never_null);
1566   }
1567 
1568   void set_incompatible_class_change_check() {
1569     set_flag(ThrowIncompatibleClassChangeErrorFlag, true);
1570   }
1571   bool is_incompatible_class_change_check() const {
1572     return check_flag(ThrowIncompatibleClassChangeErrorFlag);
1573   }
1574   void set_invokespecial_receiver_check() {
1575     set_flag(InvokeSpecialReceiverCheckFlag, true);
1576   }
1577   bool is_invokespecial_receiver_check() const {
1578     return check_flag(InvokeSpecialReceiverCheckFlag);
1579   }
1580 
1581   virtual bool needs_exception_state() const {
1582     return !is_invokespecial_receiver_check();
1583   }
1584 
1585   ciType* declared_type() const;
1586 };
1587 
1588 
1589 LEAF(InstanceOf, TypeCheck)
1590  public:
1591   // creation
1592   InstanceOf(ciKlass* klass, Value obj, ValueStack* state_before) : TypeCheck(klass, obj, intType, state_before) {}
1593 
1594   virtual bool needs_exception_state() const     { return false; }
1595 };
1596 
1597 
1598 BASE(AccessMonitor, StateSplit)
1599  private:
1600   Value       _obj;
1601   int         _monitor_no;
1602 
1603  public:
1604   // creation
1605   AccessMonitor(Value obj, int monitor_no, ValueStack* state_before = NULL)
1606   : StateSplit(illegalType, state_before)
1607   , _obj(obj)
1608   , _monitor_no(monitor_no)
1609   {
1610     set_needs_null_check(true);
1611     ASSERT_VALUES
1612   }
1613 
1614   // accessors
1615   Value obj() const                              { return _obj; }
1616   int monitor_no() const                         { return _monitor_no; }
1617 
1618   // generic
1619   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1620 };
1621 
1622 
1623 LEAF(MonitorEnter, AccessMonitor)
1624   bool _maybe_valuetype;
1625  public:
1626   // creation
1627   MonitorEnter(Value obj, int monitor_no, ValueStack* state_before, bool maybe_valuetype)
1628   : AccessMonitor(obj, monitor_no, state_before)
1629   , _maybe_valuetype(maybe_valuetype)
1630   {
1631     ASSERT_VALUES
1632   }
1633 
1634   // accessors
1635   bool maybe_valuetype() const                   { return _maybe_valuetype; }
1636 
1637   // generic
1638   virtual bool can_trap() const                  { return true; }
1639 };
1640 
1641 
1642 LEAF(MonitorExit, AccessMonitor)
1643  public:
1644   // creation
1645   MonitorExit(Value obj, int monitor_no)
1646   : AccessMonitor(obj, monitor_no, NULL)
1647   {
1648     ASSERT_VALUES
1649   }
1650 };
1651 
1652 
1653 LEAF(Intrinsic, StateSplit)
1654  private:
1655   vmIntrinsics::ID _id;
1656   Values*          _args;
1657   Value            _recv;
1658   ArgsNonNullState _nonnull_state;
1659 
1660  public:
1661   // preserves_state can be set to true for Intrinsics
1662   // which are guaranteed to preserve register state across any slow
1663   // cases; setting it to true does not mean that the Intrinsic can
1664   // not trap, only that if we continue execution in the same basic
1665   // block after the Intrinsic, all of the registers are intact. This
1666   // allows load elimination and common expression elimination to be
1667   // performed across the Intrinsic.  The default value is false.
1668   Intrinsic(ValueType* type,
1669             vmIntrinsics::ID id,
1670             Values* args,
1671             bool has_receiver,
1672             ValueStack* state_before,
1673             bool preserves_state,
1674             bool cantrap = true)
1675   : StateSplit(type, state_before)
1676   , _id(id)
1677   , _args(args)
1678   , _recv(NULL)
1679   {
1680     assert(args != NULL, &quot;args must exist&quot;);
1681     ASSERT_VALUES
1682     set_flag(PreservesStateFlag, preserves_state);
1683     set_flag(CanTrapFlag,        cantrap);
1684     if (has_receiver) {
1685       _recv = argument_at(0);
1686     }
1687     set_needs_null_check(has_receiver);
1688 
1689     // some intrinsics can&#39;t trap, so don&#39;t force them to be pinned
1690     if (!can_trap() &amp;&amp; !vmIntrinsics::should_be_pinned(_id)) {
1691       unpin(PinStateSplitConstructor);
1692     }
1693   }
1694 
1695   // accessors
1696   vmIntrinsics::ID id() const                    { return _id; }
1697   int number_of_arguments() const                { return _args-&gt;length(); }
1698   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1699 
1700   bool has_receiver() const                      { return (_recv != NULL); }
1701   Value receiver() const                         { assert(has_receiver(), &quot;must have receiver&quot;); return _recv; }
1702   bool preserves_state() const                   { return check_flag(PreservesStateFlag); }
1703 
1704   bool arg_needs_null_check(int i) const {
1705     return _nonnull_state.arg_needs_null_check(i);
1706   }
1707 
1708   void set_arg_needs_null_check(int i, bool check) {
1709     _nonnull_state.set_arg_needs_null_check(i, check);
1710   }
1711 
1712   // generic
1713   virtual bool can_trap() const                  { return check_flag(CanTrapFlag); }
1714   virtual void input_values_do(ValueVisitor* f) {
1715     StateSplit::input_values_do(f);
1716     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
1717   }
1718 };
1719 
1720 
1721 class LIR_List;
1722 
1723 LEAF(BlockBegin, StateSplit)
1724  private:
1725   int        _block_id;                          // the unique block id
1726   int        _bci;                               // start-bci of block
1727   int        _depth_first_number;                // number of this block in a depth-first ordering
1728   int        _linear_scan_number;                // number of this block in linear-scan ordering
1729   int        _dominator_depth;
1730   int        _loop_depth;                        // the loop nesting level of this block
1731   int        _loop_index;                        // number of the innermost loop of this block
1732   int        _flags;                             // the flags associated with this block
1733 
1734   // fields used by BlockListBuilder
1735   int            _total_preds;                   // number of predecessors found by BlockListBuilder
1736   ResourceBitMap _stores_to_locals;              // bit is set when a local variable is stored in the block
1737 
1738   // SSA specific fields: (factor out later)
1739   BlockList   _successors;                       // the successors of this block
1740   BlockList   _predecessors;                     // the predecessors of this block
1741   BlockList   _dominates;                        // list of blocks that are dominated by this block
1742   BlockBegin* _dominator;                        // the dominator of this block
1743   // SSA specific ends
1744   BlockEnd*  _end;                               // the last instruction of this block
1745   BlockList  _exception_handlers;                // the exception handlers potentially invoked by this block
1746   ValueStackStack* _exception_states;            // only for xhandler entries: states of all instructions that have an edge to this xhandler
1747   int        _exception_handler_pco;             // if this block is the start of an exception handler,
1748                                                  // this records the PC offset in the assembly code of the
1749                                                  // first instruction in this block
1750   Label      _label;                             // the label associated with this block
1751   LIR_List*  _lir;                               // the low level intermediate representation for this block
1752 
1753   ResourceBitMap _live_in;                       // set of live LIR_Opr registers at entry to this block
1754   ResourceBitMap _live_out;                      // set of live LIR_Opr registers at exit from this block
1755   ResourceBitMap _live_gen;                      // set of registers used before any redefinition in this block
1756   ResourceBitMap _live_kill;                     // set of registers defined in this block
1757 
1758   ResourceBitMap _fpu_register_usage;
1759   intArray*      _fpu_stack_state;               // For x86 FPU code generation with UseLinearScan
1760   int            _first_lir_instruction_id;      // ID of first LIR instruction in this block
1761   int            _last_lir_instruction_id;       // ID of last LIR instruction in this block
1762 
1763   void iterate_preorder (boolArray&amp; mark, BlockClosure* closure);
1764   void iterate_postorder(boolArray&amp; mark, BlockClosure* closure);
1765 
1766   friend class SuxAndWeightAdjuster;
1767 
1768  public:
1769    void* operator new(size_t size) throw() {
1770     Compilation* c = Compilation::current();
1771     void* res = c-&gt;arena()-&gt;Amalloc(size);
1772     ((BlockBegin*)res)-&gt;_id = c-&gt;get_next_id();
1773     ((BlockBegin*)res)-&gt;_block_id = c-&gt;get_next_block_id();
1774     return res;
1775   }
1776 
1777   // initialization/counting
1778   static int  number_of_blocks() {
1779     return Compilation::current()-&gt;number_of_blocks();
1780   }
1781 
1782   // creation
1783   BlockBegin(int bci)
1784   : StateSplit(illegalType)
1785   , _bci(bci)
1786   , _depth_first_number(-1)
1787   , _linear_scan_number(-1)
1788   , _dominator_depth(-1)
1789   , _loop_depth(0)
1790   , _loop_index(-1)
1791   , _flags(0)
1792   , _total_preds(0)
1793   , _stores_to_locals()
1794   , _successors(2)
1795   , _predecessors(2)
1796   , _dominates(2)
1797   , _dominator(NULL)
1798   , _end(NULL)
1799   , _exception_handlers(1)
1800   , _exception_states(NULL)
1801   , _exception_handler_pco(-1)
1802   , _lir(NULL)
1803   , _live_in()
1804   , _live_out()
1805   , _live_gen()
1806   , _live_kill()
1807   , _fpu_register_usage()
1808   , _fpu_stack_state(NULL)
1809   , _first_lir_instruction_id(-1)
1810   , _last_lir_instruction_id(-1)
1811   {
1812     _block = this;
1813 #ifndef PRODUCT
1814     set_printable_bci(bci);
1815 #endif
1816   }
1817 
1818   // accessors
1819   int block_id() const                           { return _block_id; }
1820   int bci() const                                { return _bci; }
1821   BlockList* successors()                        { return &amp;_successors; }
1822   BlockList* dominates()                         { return &amp;_dominates; }
1823   BlockBegin* dominator() const                  { return _dominator; }
1824   int loop_depth() const                         { return _loop_depth; }
1825   int dominator_depth() const                    { return _dominator_depth; }
1826   int depth_first_number() const                 { return _depth_first_number; }
1827   int linear_scan_number() const                 { return _linear_scan_number; }
1828   BlockEnd* end() const                          { return _end; }
1829   Label* label()                                 { return &amp;_label; }
1830   LIR_List* lir() const                          { return _lir; }
1831   int exception_handler_pco() const              { return _exception_handler_pco; }
1832   ResourceBitMap&amp; live_in()                      { return _live_in;        }
1833   ResourceBitMap&amp; live_out()                     { return _live_out;       }
1834   ResourceBitMap&amp; live_gen()                     { return _live_gen;       }
1835   ResourceBitMap&amp; live_kill()                    { return _live_kill;      }
1836   ResourceBitMap&amp; fpu_register_usage()           { return _fpu_register_usage; }
1837   intArray* fpu_stack_state() const              { return _fpu_stack_state;    }
1838   int first_lir_instruction_id() const           { return _first_lir_instruction_id; }
1839   int last_lir_instruction_id() const            { return _last_lir_instruction_id; }
1840   int total_preds() const                        { return _total_preds; }
1841   BitMap&amp; stores_to_locals()                     { return _stores_to_locals; }
1842 
1843   // manipulation
1844   void set_dominator(BlockBegin* dom)            { _dominator = dom; }
1845   void set_loop_depth(int d)                     { _loop_depth = d; }
1846   void set_dominator_depth(int d)                { _dominator_depth = d; }
1847   void set_depth_first_number(int dfn)           { _depth_first_number = dfn; }
1848   void set_linear_scan_number(int lsn)           { _linear_scan_number = lsn; }
1849   void set_end(BlockEnd* end);
1850   void clear_end();
1851   void disconnect_from_graph();
1852   static void disconnect_edge(BlockBegin* from, BlockBegin* to);
1853   BlockBegin* insert_block_between(BlockBegin* sux);
1854   void substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux);
1855   void set_lir(LIR_List* lir)                    { _lir = lir; }
1856   void set_exception_handler_pco(int pco)        { _exception_handler_pco = pco; }
1857   void set_live_in  (const ResourceBitMap&amp; map)  { _live_in = map;   }
1858   void set_live_out (const ResourceBitMap&amp; map)  { _live_out = map;  }
1859   void set_live_gen (const ResourceBitMap&amp; map)  { _live_gen = map;  }
1860   void set_live_kill(const ResourceBitMap&amp; map)  { _live_kill = map; }
1861   void set_fpu_register_usage(const ResourceBitMap&amp; map) { _fpu_register_usage = map; }
1862   void set_fpu_stack_state(intArray* state)      { _fpu_stack_state = state;  }
1863   void set_first_lir_instruction_id(int id)      { _first_lir_instruction_id = id;  }
1864   void set_last_lir_instruction_id(int id)       { _last_lir_instruction_id = id;  }
1865   void increment_total_preds(int n = 1)          { _total_preds += n; }
1866   void init_stores_to_locals(int locals_count)   { _stores_to_locals.initialize(locals_count); }
1867 
1868   // generic
1869   virtual void state_values_do(ValueVisitor* f);
1870 
1871   // successors and predecessors
1872   int number_of_sux() const;
1873   BlockBegin* sux_at(int i) const;
1874   void add_successor(BlockBegin* sux);
1875   void remove_successor(BlockBegin* pred);
1876   bool is_successor(BlockBegin* sux) const       { return _successors.contains(sux); }
1877 
1878   void add_predecessor(BlockBegin* pred);
1879   void remove_predecessor(BlockBegin* pred);
1880   bool is_predecessor(BlockBegin* pred) const    { return _predecessors.contains(pred); }
1881   int number_of_preds() const                    { return _predecessors.length(); }
1882   BlockBegin* pred_at(int i) const               { return _predecessors.at(i); }
1883 
1884   // exception handlers potentially invoked by this block
1885   void add_exception_handler(BlockBegin* b);
1886   bool is_exception_handler(BlockBegin* b) const { return _exception_handlers.contains(b); }
1887   int  number_of_exception_handlers() const      { return _exception_handlers.length(); }
1888   BlockBegin* exception_handler_at(int i) const  { return _exception_handlers.at(i); }
1889 
1890   // states of the instructions that have an edge to this exception handler
1891   int number_of_exception_states()               { assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;); return _exception_states == NULL ? 0 : _exception_states-&gt;length(); }
1892   ValueStack* exception_state_at(int idx) const  { assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;); return _exception_states-&gt;at(idx); }
1893   int add_exception_state(ValueStack* state);
1894 
1895   // flags
1896   enum Flag {
1897     no_flag                       = 0,
1898     std_entry_flag                = 1 &lt;&lt; 0,
1899     osr_entry_flag                = 1 &lt;&lt; 1,
1900     exception_entry_flag          = 1 &lt;&lt; 2,
1901     subroutine_entry_flag         = 1 &lt;&lt; 3,
1902     backward_branch_target_flag   = 1 &lt;&lt; 4,
1903     is_on_work_list_flag          = 1 &lt;&lt; 5,
1904     was_visited_flag              = 1 &lt;&lt; 6,
1905     parser_loop_header_flag       = 1 &lt;&lt; 7,  // set by parser to identify blocks where phi functions can not be created on demand
1906     critical_edge_split_flag      = 1 &lt;&lt; 8, // set for all blocks that are introduced when critical edges are split
1907     linear_scan_loop_header_flag  = 1 &lt;&lt; 9, // set during loop-detection for LinearScan
1908     linear_scan_loop_end_flag     = 1 &lt;&lt; 10, // set during loop-detection for LinearScan
1909     donot_eliminate_range_checks  = 1 &lt;&lt; 11  // Should be try to eliminate range checks in this block
1910   };
1911 
1912   void set(Flag f)                               { _flags |= f; }
1913   void clear(Flag f)                             { _flags &amp;= ~f; }
1914   bool is_set(Flag f) const                      { return (_flags &amp; f) != 0; }
1915   bool is_entry_block() const {
1916     const int entry_mask = std_entry_flag | osr_entry_flag | exception_entry_flag;
1917     return (_flags &amp; entry_mask) != 0;
1918   }
1919 
1920   // iteration
1921   void iterate_preorder   (BlockClosure* closure);
1922   void iterate_postorder  (BlockClosure* closure);
1923 
1924   void block_values_do(ValueVisitor* f);
1925 
1926   // loops
1927   void set_loop_index(int ix)                    { _loop_index = ix;        }
1928   int  loop_index() const                        { return _loop_index;      }
1929 
1930   // merging
1931   bool try_merge(ValueStack* state);             // try to merge states at block begin
1932   void merge(ValueStack* state)                  { bool b = try_merge(state); assert(b, &quot;merge failed&quot;); }
1933 
1934   // debugging
1935   void print_block()                             PRODUCT_RETURN;
1936   void print_block(InstructionPrinter&amp; ip, bool live_only = false) PRODUCT_RETURN;
1937 };
1938 
1939 
1940 BASE(BlockEnd, StateSplit)
1941  private:
1942   BlockList*  _sux;
1943 
1944  protected:
1945   BlockList* sux() const                         { return _sux; }
1946 
1947   void set_sux(BlockList* sux) {
1948 #ifdef ASSERT
1949     assert(sux != NULL, &quot;sux must exist&quot;);
1950     for (int i = sux-&gt;length() - 1; i &gt;= 0; i--) assert(sux-&gt;at(i) != NULL, &quot;sux must exist&quot;);
1951 #endif
1952     _sux = sux;
1953   }
1954 
1955  public:
1956   // creation
1957   BlockEnd(ValueType* type, ValueStack* state_before, bool is_safepoint)
1958   : StateSplit(type, state_before)
1959   , _sux(NULL)
1960   {
1961     set_flag(IsSafepointFlag, is_safepoint);
1962   }
1963 
1964   // accessors
1965   bool is_safepoint() const                      { return check_flag(IsSafepointFlag); }
1966   // For compatibility with old code, for new code use block()
1967   BlockBegin* begin() const                      { return _block; }
1968 
1969   // manipulation
1970   void set_begin(BlockBegin* begin);
1971 
1972   // successors
1973   int number_of_sux() const                      { return _sux != NULL ? _sux-&gt;length() : 0; }
1974   BlockBegin* sux_at(int i) const                { return _sux-&gt;at(i); }
1975   BlockBegin* default_sux() const                { return sux_at(number_of_sux() - 1); }
1976   BlockBegin** addr_sux_at(int i) const          { return _sux-&gt;adr_at(i); }
1977   int sux_index(BlockBegin* sux) const           { return _sux-&gt;find(sux); }
1978   void substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux);
1979 };
1980 
1981 
1982 LEAF(Goto, BlockEnd)
1983  public:
1984   enum Direction {
1985     none,            // Just a regular goto
1986     taken, not_taken // Goto produced from If
1987   };
1988  private:
1989   ciMethod*   _profiled_method;
1990   int         _profiled_bci;
1991   Direction   _direction;
1992  public:
1993   // creation
1994   Goto(BlockBegin* sux, ValueStack* state_before, bool is_safepoint = false)
1995     : BlockEnd(illegalType, state_before, is_safepoint)
1996     , _profiled_method(NULL)
1997     , _profiled_bci(0)
1998     , _direction(none) {
1999     BlockList* s = new BlockList(1);
2000     s-&gt;append(sux);
2001     set_sux(s);
2002   }
2003 
2004   Goto(BlockBegin* sux, bool is_safepoint) : BlockEnd(illegalType, NULL, is_safepoint)
2005                                            , _profiled_method(NULL)
2006                                            , _profiled_bci(0)
2007                                            , _direction(none) {
2008     BlockList* s = new BlockList(1);
2009     s-&gt;append(sux);
2010     set_sux(s);
2011   }
2012 
2013   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
2014   ciMethod* profiled_method() const              { return _profiled_method; } // set only for profiled branches
2015   int profiled_bci() const                       { return _profiled_bci; }
2016   Direction direction() const                    { return _direction; }
2017 
2018   void set_should_profile(bool value)            { set_flag(ProfileMDOFlag, value); }
2019   void set_profiled_method(ciMethod* method)     { _profiled_method = method; }
2020   void set_profiled_bci(int bci)                 { _profiled_bci = bci; }
2021   void set_direction(Direction d)                { _direction = d; }
2022 };
2023 
2024 #ifdef ASSERT
2025 LEAF(Assert, Instruction)
2026   private:
2027   Value       _x;
2028   Condition   _cond;
2029   Value       _y;
2030   char        *_message;
2031 
2032  public:
2033   // creation
2034   // unordered_is_true is valid for float/double compares only
2035    Assert(Value x, Condition cond, bool unordered_is_true, Value y);
2036 
2037   // accessors
2038   Value x() const                                { return _x; }
2039   Condition cond() const                         { return _cond; }
2040   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2041   Value y() const                                { return _y; }
2042   const char *message() const                    { return _message; }
2043 
2044   // generic
2045   virtual void input_values_do(ValueVisitor* f)  { f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2046 };
2047 #endif
2048 
2049 LEAF(RangeCheckPredicate, StateSplit)
2050  private:
2051   Value       _x;
2052   Condition   _cond;
2053   Value       _y;
2054 
2055   void check_state();
2056 
2057  public:
2058   // creation
2059   // unordered_is_true is valid for float/double compares only
2060    RangeCheckPredicate(Value x, Condition cond, bool unordered_is_true, Value y, ValueStack* state) : StateSplit(illegalType)
2061   , _x(x)
2062   , _cond(cond)
2063   , _y(y)
2064   {
2065     ASSERT_VALUES
2066     set_flag(UnorderedIsTrueFlag, unordered_is_true);
2067     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
2068     this-&gt;set_state(state);
2069     check_state();
2070   }
2071 
2072   // Always deoptimize
2073   RangeCheckPredicate(ValueStack* state) : StateSplit(illegalType)
2074   {
2075     this-&gt;set_state(state);
2076     _x = _y = NULL;
2077     check_state();
2078   }
2079 
2080   // accessors
2081   Value x() const                                { return _x; }
2082   Condition cond() const                         { return _cond; }
2083   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2084   Value y() const                                { return _y; }
2085 
2086   void always_fail()                             { _x = _y = NULL; }
2087 
2088   // generic
2089   virtual void input_values_do(ValueVisitor* f)  { StateSplit::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2090   HASHING3(RangeCheckPredicate, true, x()-&gt;subst(), y()-&gt;subst(), cond())
2091 };
2092 
2093 LEAF(If, BlockEnd)
2094  private:
2095   Value       _x;
2096   Condition   _cond;
2097   Value       _y;
2098   ciMethod*   _profiled_method;
2099   int         _profiled_bci; // Canonicalizer may alter bci of If node
2100   bool        _swapped;      // Is the order reversed with respect to the original If in the
2101                              // bytecode stream?
2102   bool        _substitutability_check;
2103  public:
2104   // creation
2105   // unordered_is_true is valid for float/double compares only
2106   If(Value x, Condition cond, bool unordered_is_true, Value y, BlockBegin* tsux, BlockBegin* fsux, ValueStack* state_before, bool is_safepoint, bool substitutability_check=false)
2107     : BlockEnd(illegalType, state_before, is_safepoint)
2108   , _x(x)
2109   , _cond(cond)
2110   , _y(y)
2111   , _profiled_method(NULL)
2112   , _profiled_bci(0)
2113   , _swapped(false)
2114   , _substitutability_check(substitutability_check)
2115   {
2116     ASSERT_VALUES
2117     set_flag(UnorderedIsTrueFlag, unordered_is_true);
2118     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
2119     BlockList* s = new BlockList(2);
2120     s-&gt;append(tsux);
2121     s-&gt;append(fsux);
2122     set_sux(s);
2123   }
2124 
2125   // accessors
2126   Value x() const                                { return _x; }
2127   Condition cond() const                         { return _cond; }
2128   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2129   Value y() const                                { return _y; }
2130   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2131   BlockBegin* tsux() const                       { return sux_for(true); }
2132   BlockBegin* fsux() const                       { return sux_for(false); }
2133   BlockBegin* usux() const                       { return sux_for(unordered_is_true()); }
2134   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
2135   ciMethod* profiled_method() const              { return _profiled_method; } // set only for profiled branches
2136   int profiled_bci() const                       { return _profiled_bci; }    // set for profiled branches and tiered
2137   bool is_swapped() const                        { return _swapped; }
2138 
2139   // manipulation
2140   void swap_operands() {
2141     Value t = _x; _x = _y; _y = t;
2142     _cond = mirror(_cond);
2143   }
2144 
2145   void swap_sux() {
2146     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2147     BlockList* s = sux();
2148     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2149     _cond = negate(_cond);
2150     set_flag(UnorderedIsTrueFlag, !check_flag(UnorderedIsTrueFlag));
2151   }
2152 
2153   void set_should_profile(bool value)             { set_flag(ProfileMDOFlag, value); }
2154   void set_profiled_method(ciMethod* method)      { _profiled_method = method; }
2155   void set_profiled_bci(int bci)                  { _profiled_bci = bci;       }
2156   void set_swapped(bool value)                    { _swapped = value;         }
2157   bool substitutability_check() const              { return _substitutability_check; }
2158   // generic
2159   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2160 };
2161 
2162 
2163 LEAF(IfInstanceOf, BlockEnd)
2164  private:
2165   ciKlass* _klass;
2166   Value    _obj;
2167   bool     _test_is_instance;                    // jump if instance
2168   int      _instanceof_bci;
2169 
2170  public:
2171   IfInstanceOf(ciKlass* klass, Value obj, bool test_is_instance, int instanceof_bci, BlockBegin* tsux, BlockBegin* fsux)
2172   : BlockEnd(illegalType, NULL, false) // temporary set to false
2173   , _klass(klass)
2174   , _obj(obj)
2175   , _test_is_instance(test_is_instance)
2176   , _instanceof_bci(instanceof_bci)
2177   {
2178     ASSERT_VALUES
2179     assert(instanceof_bci &gt;= 0, &quot;illegal bci&quot;);
2180     BlockList* s = new BlockList(2);
2181     s-&gt;append(tsux);
2182     s-&gt;append(fsux);
2183     set_sux(s);
2184   }
2185 
2186   // accessors
2187   //
2188   // Note 1: If test_is_instance() is true, IfInstanceOf tests if obj *is* an
2189   //         instance of klass; otherwise it tests if it is *not* and instance
2190   //         of klass.
2191   //
2192   // Note 2: IfInstanceOf instructions are created by combining an InstanceOf
2193   //         and an If instruction. The IfInstanceOf bci() corresponds to the
2194   //         bci that the If would have had; the (this-&gt;) instanceof_bci() is
2195   //         the bci of the original InstanceOf instruction.
2196   ciKlass* klass() const                         { return _klass; }
2197   Value obj() const                              { return _obj; }
2198   int instanceof_bci() const                     { return _instanceof_bci; }
2199   bool test_is_instance() const                  { return _test_is_instance; }
2200   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2201   BlockBegin* tsux() const                       { return sux_for(true); }
2202   BlockBegin* fsux() const                       { return sux_for(false); }
2203 
2204   // manipulation
2205   void swap_sux() {
2206     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2207     BlockList* s = sux();
2208     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2209     _test_is_instance = !_test_is_instance;
2210   }
2211 
2212   // generic
2213   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_obj); }
2214 };
2215 
2216 
2217 BASE(Switch, BlockEnd)
2218  private:
2219   Value       _tag;
2220 
2221  public:
2222   // creation
2223   Switch(Value tag, BlockList* sux, ValueStack* state_before, bool is_safepoint)
2224   : BlockEnd(illegalType, state_before, is_safepoint)
2225   , _tag(tag) {
2226     ASSERT_VALUES
2227     set_sux(sux);
2228   }
2229 
2230   // accessors
2231   Value tag() const                              { return _tag; }
2232   int length() const                             { return number_of_sux() - 1; }
2233 
2234   virtual bool needs_exception_state() const     { return false; }
2235 
2236   // generic
2237   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_tag); }
2238 };
2239 
2240 
2241 LEAF(TableSwitch, Switch)
2242  private:
2243   int _lo_key;
2244 
2245  public:
2246   // creation
2247   TableSwitch(Value tag, BlockList* sux, int lo_key, ValueStack* state_before, bool is_safepoint)
2248     : Switch(tag, sux, state_before, is_safepoint)
2249   , _lo_key(lo_key) { assert(_lo_key &lt;= hi_key(), &quot;integer overflow&quot;); }
2250 
2251   // accessors
2252   int lo_key() const                             { return _lo_key; }
2253   int hi_key() const                             { return _lo_key + (length() - 1); }
2254 };
2255 
2256 
2257 LEAF(LookupSwitch, Switch)
2258  private:
2259   intArray* _keys;
2260 
2261  public:
2262   // creation
2263   LookupSwitch(Value tag, BlockList* sux, intArray* keys, ValueStack* state_before, bool is_safepoint)
2264   : Switch(tag, sux, state_before, is_safepoint)
2265   , _keys(keys) {
2266     assert(keys != NULL, &quot;keys must exist&quot;);
2267     assert(keys-&gt;length() == length(), &quot;sux &amp; keys have incompatible lengths&quot;);
2268   }
2269 
2270   // accessors
2271   int key_at(int i) const                        { return _keys-&gt;at(i); }
2272 };
2273 
2274 
2275 LEAF(Return, BlockEnd)
2276  private:
2277   Value _result;
2278 
2279  public:
2280   // creation
2281   Return(Value result) :
2282     BlockEnd(result == NULL ? voidType : result-&gt;type()-&gt;base(), NULL, true),
2283     _result(result) {}
2284 
2285   // accessors
2286   Value result() const                           { return _result; }
2287   bool has_result() const                        { return result() != NULL; }
2288 
2289   // generic
2290   virtual void input_values_do(ValueVisitor* f) {
2291     BlockEnd::input_values_do(f);
2292     if (has_result()) f-&gt;visit(&amp;_result);
2293   }
2294 };
2295 
2296 
2297 LEAF(Throw, BlockEnd)
2298  private:
2299   Value _exception;
2300 
2301  public:
2302   // creation
2303   Throw(Value exception, ValueStack* state_before) : BlockEnd(illegalType, state_before, true), _exception(exception) {
2304     ASSERT_VALUES
2305   }
2306 
2307   // accessors
2308   Value exception() const                        { return _exception; }
2309 
2310   // generic
2311   virtual bool can_trap() const                  { return true; }
2312   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_exception); }
2313 };
2314 
2315 
2316 LEAF(Base, BlockEnd)
2317  public:
2318   // creation
2319   Base(BlockBegin* std_entry, BlockBegin* osr_entry) : BlockEnd(illegalType, NULL, false) {
2320     assert(std_entry-&gt;is_set(BlockBegin::std_entry_flag), &quot;std entry must be flagged&quot;);
2321     assert(osr_entry == NULL || osr_entry-&gt;is_set(BlockBegin::osr_entry_flag), &quot;osr entry must be flagged&quot;);
2322     BlockList* s = new BlockList(2);
2323     if (osr_entry != NULL) s-&gt;append(osr_entry);
2324     s-&gt;append(std_entry); // must be default sux!
2325     set_sux(s);
2326   }
2327 
2328   // accessors
2329   BlockBegin* std_entry() const                  { return default_sux(); }
2330   BlockBegin* osr_entry() const                  { return number_of_sux() &lt; 2 ? NULL : sux_at(0); }
2331 };
2332 
2333 
2334 LEAF(OsrEntry, Instruction)
2335  public:
2336   // creation
2337 #ifdef _LP64
2338   OsrEntry() : Instruction(longType) { pin(); }
2339 #else
2340   OsrEntry() : Instruction(intType)  { pin(); }
2341 #endif
2342 
2343   // generic
2344   virtual void input_values_do(ValueVisitor* f)   { }
2345 };
2346 
2347 
2348 // Models the incoming exception at a catch site
2349 LEAF(ExceptionObject, Instruction)
2350  public:
2351   // creation
2352   ExceptionObject() : Instruction(objectType) {
2353     pin();
2354   }
2355 
2356   // generic
2357   virtual void input_values_do(ValueVisitor* f)   { }
2358 };
2359 
2360 
2361 // Models needed rounding for floating-point values on Intel.
2362 // Currently only used to represent rounding of double-precision
2363 // values stored into local variables, but could be used to model
2364 // intermediate rounding of single-precision values as well.
2365 LEAF(RoundFP, Instruction)
2366  private:
2367   Value _input;             // floating-point value to be rounded
2368 
2369  public:
2370   RoundFP(Value input)
2371   : Instruction(input-&gt;type()) // Note: should not be used for constants
2372   , _input(input)
2373   {
2374     ASSERT_VALUES
2375   }
2376 
2377   // accessors
2378   Value input() const                            { return _input; }
2379 
2380   // generic
2381   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_input); }
2382 };
2383 
2384 
2385 BASE(UnsafeOp, Instruction)
2386  private:
2387   BasicType _basic_type;    // ValueType can not express byte-sized integers
2388 
2389  protected:
2390   // creation
2391   UnsafeOp(BasicType basic_type, bool is_put)
2392   : Instruction(is_put ? voidType : as_ValueType(basic_type))
2393   , _basic_type(basic_type)
2394   {
2395     //Note:  Unsafe ops are not not guaranteed to throw NPE.
2396     // Convservatively, Unsafe operations must be pinned though we could be
2397     // looser about this if we wanted to..
2398     pin();
2399   }
2400 
2401  public:
2402   // accessors
2403   BasicType basic_type()                         { return _basic_type; }
2404 
2405   // generic
2406   virtual void input_values_do(ValueVisitor* f)   { }
2407 };
2408 
2409 
2410 BASE(UnsafeRawOp, UnsafeOp)
2411  private:
2412   Value _base;                                   // Base address (a Java long)
2413   Value _index;                                  // Index if computed by optimizer; initialized to NULL
2414   int   _log2_scale;                             // Scale factor: 0, 1, 2, or 3.
2415                                                  // Indicates log2 of number of bytes (1, 2, 4, or 8)
2416                                                  // to scale index by.
2417 
2418  protected:
2419   UnsafeRawOp(BasicType basic_type, Value addr, bool is_put)
2420   : UnsafeOp(basic_type, is_put)
2421   , _base(addr)
2422   , _index(NULL)
2423   , _log2_scale(0)
2424   {
2425     // Can not use ASSERT_VALUES because index may be NULL
2426     assert(addr != NULL &amp;&amp; addr-&gt;type()-&gt;is_long(), &quot;just checking&quot;);
2427   }
2428 
2429   UnsafeRawOp(BasicType basic_type, Value base, Value index, int log2_scale, bool is_put)
2430   : UnsafeOp(basic_type, is_put)
2431   , _base(base)
2432   , _index(index)
2433   , _log2_scale(log2_scale)
2434   {
2435   }
2436 
2437  public:
2438   // accessors
2439   Value base()                                   { return _base; }
2440   Value index()                                  { return _index; }
2441   bool  has_index()                              { return (_index != NULL); }
2442   int   log2_scale()                             { return _log2_scale; }
2443 
2444   // setters
2445   void set_base (Value base)                     { _base  = base; }
2446   void set_index(Value index)                    { _index = index; }
2447   void set_log2_scale(int log2_scale)            { _log2_scale = log2_scale; }
2448 
2449   // generic
2450   virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);
2451                                                    f-&gt;visit(&amp;_base);
2452                                                    if (has_index()) f-&gt;visit(&amp;_index); }
2453 };
2454 
2455 
2456 LEAF(UnsafeGetRaw, UnsafeRawOp)
2457  private:
2458  bool _may_be_unaligned, _is_wide;  // For OSREntry
2459 
2460  public:
2461  UnsafeGetRaw(BasicType basic_type, Value addr, bool may_be_unaligned, bool is_wide = false)
2462   : UnsafeRawOp(basic_type, addr, false) {
2463     _may_be_unaligned = may_be_unaligned;
2464     _is_wide = is_wide;
2465   }
2466 
2467  UnsafeGetRaw(BasicType basic_type, Value base, Value index, int log2_scale, bool may_be_unaligned, bool is_wide = false)
2468   : UnsafeRawOp(basic_type, base, index, log2_scale, false) {
2469     _may_be_unaligned = may_be_unaligned;
2470     _is_wide = is_wide;
2471   }
2472 
2473   bool may_be_unaligned()                         { return _may_be_unaligned; }
2474   bool is_wide()                                  { return _is_wide; }
2475 };
2476 
2477 
2478 LEAF(UnsafePutRaw, UnsafeRawOp)
2479  private:
2480   Value _value;                                  // Value to be stored
2481 
2482  public:
2483   UnsafePutRaw(BasicType basic_type, Value addr, Value value)
2484   : UnsafeRawOp(basic_type, addr, true)
2485   , _value(value)
2486   {
2487     assert(value != NULL, &quot;just checking&quot;);
2488     ASSERT_VALUES
2489   }
2490 
2491   UnsafePutRaw(BasicType basic_type, Value base, Value index, int log2_scale, Value value)
2492   : UnsafeRawOp(basic_type, base, index, log2_scale, true)
2493   , _value(value)
2494   {
2495     assert(value != NULL, &quot;just checking&quot;);
2496     ASSERT_VALUES
2497   }
2498 
2499   // accessors
2500   Value value()                                  { return _value; }
2501 
2502   // generic
2503   virtual void input_values_do(ValueVisitor* f)   { UnsafeRawOp::input_values_do(f);
2504                                                    f-&gt;visit(&amp;_value); }
2505 };
2506 
2507 
2508 BASE(UnsafeObjectOp, UnsafeOp)
2509  private:
2510   Value _object;                                 // Object to be fetched from or mutated
2511   Value _offset;                                 // Offset within object
2512   bool  _is_volatile;                            // true if volatile - dl/JSR166
2513  public:
2514   UnsafeObjectOp(BasicType basic_type, Value object, Value offset, bool is_put, bool is_volatile)
2515     : UnsafeOp(basic_type, is_put), _object(object), _offset(offset), _is_volatile(is_volatile)
2516   {
2517   }
2518 
2519   // accessors
2520   Value object()                                 { return _object; }
2521   Value offset()                                 { return _offset; }
2522   bool  is_volatile()                            { return _is_volatile; }
2523   // generic
2524   virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);
2525                                                    f-&gt;visit(&amp;_object);
2526                                                    f-&gt;visit(&amp;_offset); }
2527 };
2528 
2529 
2530 LEAF(UnsafeGetObject, UnsafeObjectOp)
2531  public:
2532   UnsafeGetObject(BasicType basic_type, Value object, Value offset, bool is_volatile)
2533   : UnsafeObjectOp(basic_type, object, offset, false, is_volatile)
2534   {
2535     ASSERT_VALUES
2536   }
2537 };
2538 
2539 
2540 LEAF(UnsafePutObject, UnsafeObjectOp)
2541  private:
2542   Value _value;                                  // Value to be stored
2543  public:
2544   UnsafePutObject(BasicType basic_type, Value object, Value offset, Value value, bool is_volatile)
2545   : UnsafeObjectOp(basic_type, object, offset, true, is_volatile)
2546     , _value(value)
2547   {
2548     ASSERT_VALUES
2549   }
2550 
2551   // accessors
2552   Value value()                                  { return _value; }
2553 
2554   // generic
2555   virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);
2556                                                    f-&gt;visit(&amp;_value); }
2557 };
2558 
2559 LEAF(UnsafeGetAndSetObject, UnsafeObjectOp)
2560  private:
2561   Value _value;                                  // Value to be stored
2562   bool  _is_add;
2563  public:
2564   UnsafeGetAndSetObject(BasicType basic_type, Value object, Value offset, Value value, bool is_add)
2565   : UnsafeObjectOp(basic_type, object, offset, false, false)
2566     , _value(value)
2567     , _is_add(is_add)
2568   {
2569     ASSERT_VALUES
2570   }
2571 
2572   // accessors
2573   bool is_add() const                            { return _is_add; }
2574   Value value()                                  { return _value; }
2575 
2576   // generic
2577   virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);
2578                                                    f-&gt;visit(&amp;_value); }
2579 };
2580 
2581 LEAF(ProfileCall, Instruction)
2582  private:
2583   ciMethod*        _method;
2584   int              _bci_of_invoke;
2585   ciMethod*        _callee;         // the method that is called at the given bci
2586   Value            _recv;
2587   ciKlass*         _known_holder;
2588   Values*          _obj_args;       // arguments for type profiling
2589   ArgsNonNullState _nonnull_state;  // Do we know whether some arguments are never null?
2590   bool             _inlined;        // Are we profiling a call that is inlined
2591 
2592  public:
2593   ProfileCall(ciMethod* method, int bci, ciMethod* callee, Value recv, ciKlass* known_holder, Values* obj_args, bool inlined)
2594     : Instruction(voidType)
2595     , _method(method)
2596     , _bci_of_invoke(bci)
2597     , _callee(callee)
2598     , _recv(recv)
2599     , _known_holder(known_holder)
2600     , _obj_args(obj_args)
2601     , _inlined(inlined)
2602   {
2603     // The ProfileCall has side-effects and must occur precisely where located
2604     pin();
2605   }
2606 
2607   ciMethod* method()             const { return _method; }
2608   int bci_of_invoke()            const { return _bci_of_invoke; }
2609   ciMethod* callee()             const { return _callee; }
2610   Value recv()                   const { return _recv; }
2611   ciKlass* known_holder()        const { return _known_holder; }
2612   int nb_profiled_args()         const { return _obj_args == NULL ? 0 : _obj_args-&gt;length(); }
2613   Value profiled_arg_at(int i)   const { return _obj_args-&gt;at(i); }
2614   bool arg_needs_null_check(int i) const {
2615     return _nonnull_state.arg_needs_null_check(i);
2616   }
2617   bool inlined()                 const { return _inlined; }
2618 
2619   void set_arg_needs_null_check(int i, bool check) {
2620     _nonnull_state.set_arg_needs_null_check(i, check);
2621   }
2622 
2623   virtual void input_values_do(ValueVisitor* f)   {
2624     if (_recv != NULL) {
2625       f-&gt;visit(&amp;_recv);
2626     }
2627     for (int i = 0; i &lt; nb_profiled_args(); i++) {
2628       f-&gt;visit(_obj_args-&gt;adr_at(i));
2629     }
2630   }
2631 };
2632 
2633 LEAF(ProfileReturnType, Instruction)
2634  private:
2635   ciMethod*        _method;
2636   ciMethod*        _callee;
2637   int              _bci_of_invoke;
2638   Value            _ret;
2639 
2640  public:
2641   ProfileReturnType(ciMethod* method, int bci, ciMethod* callee, Value ret)
2642     : Instruction(voidType)
2643     , _method(method)
2644     , _callee(callee)
2645     , _bci_of_invoke(bci)
2646     , _ret(ret)
2647   {
2648     set_needs_null_check(true);
2649     // The ProfileType has side-effects and must occur precisely where located
2650     pin();
2651   }
2652 
2653   ciMethod* method()             const { return _method; }
2654   ciMethod* callee()             const { return _callee; }
2655   int bci_of_invoke()            const { return _bci_of_invoke; }
2656   Value ret()                    const { return _ret; }
2657 
2658   virtual void input_values_do(ValueVisitor* f)   {
2659     if (_ret != NULL) {
2660       f-&gt;visit(&amp;_ret);
2661     }
2662   }
2663 };
2664 
2665 // Call some C runtime function that doesn&#39;t safepoint,
2666 // optionally passing the current thread as the first argument.
2667 LEAF(RuntimeCall, Instruction)
2668  private:
2669   const char* _entry_name;
2670   address     _entry;
2671   Values*     _args;
2672   bool        _pass_thread;  // Pass the JavaThread* as an implicit first argument
2673 
2674  public:
2675   RuntimeCall(ValueType* type, const char* entry_name, address entry, Values* args, bool pass_thread = true)
2676     : Instruction(type)
2677     , _entry_name(entry_name)
2678     , _entry(entry)
2679     , _args(args)
2680     , _pass_thread(pass_thread) {
2681     ASSERT_VALUES
2682     pin();
2683   }
2684 
2685   const char* entry_name() const  { return _entry_name; }
2686   address entry() const           { return _entry; }
2687   int number_of_arguments() const { return _args-&gt;length(); }
2688   Value argument_at(int i) const  { return _args-&gt;at(i); }
2689   bool pass_thread() const        { return _pass_thread; }
2690 
2691   virtual void input_values_do(ValueVisitor* f)   {
2692     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
2693   }
2694 };
2695 
2696 // Use to trip invocation counter of an inlined method
2697 
2698 LEAF(ProfileInvoke, Instruction)
2699  private:
2700   ciMethod*   _inlinee;
2701   ValueStack* _state;
2702 
2703  public:
2704   ProfileInvoke(ciMethod* inlinee,  ValueStack* state)
2705     : Instruction(voidType)
2706     , _inlinee(inlinee)
2707     , _state(state)
2708   {
2709     // The ProfileInvoke has side-effects and must occur precisely where located QQQ???
2710     pin();
2711   }
2712 
2713   ciMethod* inlinee()      { return _inlinee; }
2714   ValueStack* state()      { return _state; }
2715   virtual void input_values_do(ValueVisitor*)   {}
2716   virtual void state_values_do(ValueVisitor*);
2717 };
2718 
2719 LEAF(MemBar, Instruction)
2720  private:
2721   LIR_Code _code;
2722 
2723  public:
2724   MemBar(LIR_Code code)
2725     : Instruction(voidType)
2726     , _code(code)
2727   {
2728     pin();
2729   }
2730 
2731   LIR_Code code()           { return _code; }
2732 
2733   virtual void input_values_do(ValueVisitor*)   {}
2734 };
2735 
2736 class BlockPair: public CompilationResourceObj {
2737  private:
2738   BlockBegin* _from;
2739   BlockBegin* _to;
2740  public:
2741   BlockPair(BlockBegin* from, BlockBegin* to): _from(from), _to(to) {}
2742   BlockBegin* from() const { return _from; }
2743   BlockBegin* to() const   { return _to;   }
2744   bool is_same(BlockBegin* from, BlockBegin* to) const { return  _from == from &amp;&amp; _to == to; }
2745   bool is_same(BlockPair* p) const { return  _from == p-&gt;from() &amp;&amp; _to == p-&gt;to(); }
2746   void set_to(BlockBegin* b)   { _to = b; }
2747   void set_from(BlockBegin* b) { _from = b; }
2748 };
2749 
2750 typedef GrowableArray&lt;BlockPair*&gt; BlockPairList;
2751 
2752 inline int         BlockBegin::number_of_sux() const            { assert(_end == NULL || _end-&gt;number_of_sux() == _successors.length(), &quot;mismatch&quot;); return _successors.length(); }
2753 inline BlockBegin* BlockBegin::sux_at(int i) const              { assert(_end == NULL || _end-&gt;sux_at(i) == _successors.at(i), &quot;mismatch&quot;);          return _successors.at(i); }
2754 inline void        BlockBegin::add_successor(BlockBegin* sux)   { assert(_end == NULL, &quot;Would create mismatch with successors of BlockEnd&quot;);         _successors.append(sux); }
2755 
2756 #undef ASSERT_VALUES
2757 
2758 #endif // SHARE_C1_C1_INSTRUCTION_HPP
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/c1/c1_Instruction.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_C1_C1_INSTRUCTION_HPP
  26 #define SHARE_C1_C1_INSTRUCTION_HPP
  27 
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIR.hpp&quot;
  30 #include &quot;c1/c1_ValueType.hpp&quot;
  31 #include &quot;ci/ciField.hpp&quot;
  32 
  33 // Predefined classes
  34 class ciField;
  35 class ValueStack;
  36 class InstructionPrinter;
  37 class IRScope;
  38 class LIR_OprDesc;
  39 typedef LIR_OprDesc* LIR_Opr;
  40 
  41 
  42 // Instruction class hierarchy
  43 //
  44 // All leaf classes in the class hierarchy are concrete classes
  45 // (i.e., are instantiated). All other classes are abstract and
  46 // serve factoring.
  47 
  48 class Instruction;
  49 class   Phi;
  50 class   Local;
  51 class   Constant;
  52 class   AccessField;
  53 class     LoadField;
  54 class     StoreField;
  55 class   AccessArray;
  56 class     ArrayLength;
  57 class     AccessIndexed;
  58 class       LoadIndexed;
  59 class       StoreIndexed;
  60 class   NegateOp;
  61 class   Op2;
  62 class     ArithmeticOp;
  63 class     ShiftOp;
  64 class     LogicOp;
  65 class     CompareOp;
  66 class     IfOp;
  67 class   Convert;
  68 class   NullCheck;
  69 class   TypeCast;
  70 class   OsrEntry;
  71 class   ExceptionObject;
  72 class   StateSplit;
  73 class     Invoke;
  74 class     NewInstance;
  75 class     NewValueTypeInstance;
  76 class     NewArray;
  77 class       NewTypeArray;
  78 class       NewObjectArray;
  79 class       NewMultiArray;
  80 class     WithField;
  81 class     DefaultValue;
  82 class     TypeCheck;
  83 class       CheckCast;
  84 class       InstanceOf;
  85 class     AccessMonitor;
  86 class       MonitorEnter;
  87 class       MonitorExit;
  88 class     Intrinsic;
  89 class     BlockBegin;
  90 class     BlockEnd;
  91 class       Goto;
  92 class       If;
  93 class       IfInstanceOf;
  94 class       Switch;
  95 class         TableSwitch;
  96 class         LookupSwitch;
  97 class       Return;
  98 class       Throw;
  99 class       Base;
 100 class   RoundFP;
 101 class   UnsafeOp;
 102 class     UnsafeRawOp;
 103 class       UnsafeGetRaw;
 104 class       UnsafePutRaw;
 105 class     UnsafeObjectOp;
 106 class       UnsafeGetObject;
 107 class       UnsafePutObject;
 108 class         UnsafeGetAndSetObject;
 109 class   ProfileCall;
 110 class   ProfileReturnType;
 111 class   ProfileInvoke;
 112 class   RuntimeCall;
 113 class   MemBar;
 114 class   RangeCheckPredicate;
 115 #ifdef ASSERT
 116 class   Assert;
 117 #endif
 118 
 119 // A Value is a reference to the instruction creating the value
 120 typedef Instruction* Value;
 121 typedef GrowableArray&lt;Value&gt; Values;
 122 typedef GrowableArray&lt;ValueStack*&gt; ValueStackStack;
 123 
 124 // BlockClosure is the base class for block traversal/iteration.
 125 
 126 class BlockClosure: public CompilationResourceObj {
 127  public:
 128   virtual void block_do(BlockBegin* block)       = 0;
 129 };
 130 
 131 
 132 // A simple closure class for visiting the values of an Instruction
 133 class ValueVisitor: public StackObj {
 134  public:
 135   virtual void visit(Value* v) = 0;
 136 };
 137 
 138 
 139 // Some array and list classes
 140 typedef GrowableArray&lt;BlockBegin*&gt; BlockBeginArray;
 141 
 142 class BlockList: public GrowableArray&lt;BlockBegin*&gt; {
 143  public:
 144   BlockList(): GrowableArray&lt;BlockBegin*&gt;() {}
 145   BlockList(const int size): GrowableArray&lt;BlockBegin*&gt;(size) {}
 146   BlockList(const int size, BlockBegin* init): GrowableArray&lt;BlockBegin*&gt;(size, size, init) {}
 147 
 148   void iterate_forward(BlockClosure* closure);
 149   void iterate_backward(BlockClosure* closure);
 150   void blocks_do(void f(BlockBegin*));
 151   void values_do(ValueVisitor* f);
 152   void print(bool cfg_only = false, bool live_only = false) PRODUCT_RETURN;
 153 };
 154 
 155 
 156 // InstructionVisitors provide type-based dispatch for instructions.
 157 // For each concrete Instruction class X, a virtual function do_X is
 158 // provided. Functionality that needs to be implemented for all classes
 159 // (e.g., printing, code generation) is factored out into a specialised
 160 // visitor instead of added to the Instruction classes itself.
 161 
 162 class InstructionVisitor: public StackObj {
 163  public:
 164   virtual void do_Phi            (Phi*             x) = 0;
 165   virtual void do_Local          (Local*           x) = 0;
 166   virtual void do_Constant       (Constant*        x) = 0;
 167   virtual void do_LoadField      (LoadField*       x) = 0;
 168   virtual void do_StoreField     (StoreField*      x) = 0;
 169   virtual void do_ArrayLength    (ArrayLength*     x) = 0;
 170   virtual void do_LoadIndexed    (LoadIndexed*     x) = 0;
 171   virtual void do_StoreIndexed   (StoreIndexed*    x) = 0;
 172   virtual void do_NegateOp       (NegateOp*        x) = 0;
 173   virtual void do_ArithmeticOp   (ArithmeticOp*    x) = 0;
 174   virtual void do_ShiftOp        (ShiftOp*         x) = 0;
 175   virtual void do_LogicOp        (LogicOp*         x) = 0;
 176   virtual void do_CompareOp      (CompareOp*       x) = 0;
 177   virtual void do_IfOp           (IfOp*            x) = 0;
 178   virtual void do_Convert        (Convert*         x) = 0;
 179   virtual void do_NullCheck      (NullCheck*       x) = 0;
 180   virtual void do_TypeCast       (TypeCast*        x) = 0;
 181   virtual void do_Invoke         (Invoke*          x) = 0;
 182   virtual void do_NewInstance    (NewInstance*     x) = 0;
 183   virtual void do_NewValueTypeInstance(NewValueTypeInstance* x) = 0;
 184   virtual void do_NewTypeArray   (NewTypeArray*    x) = 0;
 185   virtual void do_NewObjectArray (NewObjectArray*  x) = 0;
 186   virtual void do_NewMultiArray  (NewMultiArray*   x) = 0;
 187   virtual void do_WithField      (WithField*       x) = 0;
 188   virtual void do_DefaultValue   (DefaultValue*    x) = 0;
 189   virtual void do_CheckCast      (CheckCast*       x) = 0;
 190   virtual void do_InstanceOf     (InstanceOf*      x) = 0;
 191   virtual void do_MonitorEnter   (MonitorEnter*    x) = 0;
 192   virtual void do_MonitorExit    (MonitorExit*     x) = 0;
 193   virtual void do_Intrinsic      (Intrinsic*       x) = 0;
 194   virtual void do_BlockBegin     (BlockBegin*      x) = 0;
 195   virtual void do_Goto           (Goto*            x) = 0;
 196   virtual void do_If             (If*              x) = 0;
 197   virtual void do_IfInstanceOf   (IfInstanceOf*    x) = 0;
 198   virtual void do_TableSwitch    (TableSwitch*     x) = 0;
 199   virtual void do_LookupSwitch   (LookupSwitch*    x) = 0;
 200   virtual void do_Return         (Return*          x) = 0;
 201   virtual void do_Throw          (Throw*           x) = 0;
 202   virtual void do_Base           (Base*            x) = 0;
 203   virtual void do_OsrEntry       (OsrEntry*        x) = 0;
 204   virtual void do_ExceptionObject(ExceptionObject* x) = 0;
 205   virtual void do_RoundFP        (RoundFP*         x) = 0;
 206   virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x) = 0;
 207   virtual void do_UnsafePutRaw   (UnsafePutRaw*    x) = 0;
 208   virtual void do_UnsafeGetObject(UnsafeGetObject* x) = 0;
 209   virtual void do_UnsafePutObject(UnsafePutObject* x) = 0;
 210   virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) = 0;
 211   virtual void do_ProfileCall    (ProfileCall*     x) = 0;
 212   virtual void do_ProfileReturnType (ProfileReturnType*  x) = 0;
 213   virtual void do_ProfileInvoke  (ProfileInvoke*   x) = 0;
 214   virtual void do_RuntimeCall    (RuntimeCall*     x) = 0;
 215   virtual void do_MemBar         (MemBar*          x) = 0;
 216   virtual void do_RangeCheckPredicate(RangeCheckPredicate* x) = 0;
 217 #ifdef ASSERT
 218   virtual void do_Assert         (Assert*          x) = 0;
 219 #endif
 220 };
 221 
 222 
 223 // Hashing support
 224 //
 225 // Note: This hash functions affect the performance
 226 //       of ValueMap - make changes carefully!
 227 
 228 #define HASH1(x1            )                    ((intx)(x1))
 229 #define HASH2(x1, x2        )                    ((HASH1(x1        ) &lt;&lt; 7) ^ HASH1(x2))
 230 #define HASH3(x1, x2, x3    )                    ((HASH2(x1, x2    ) &lt;&lt; 7) ^ HASH1(x3))
 231 #define HASH4(x1, x2, x3, x4)                    ((HASH3(x1, x2, x3) &lt;&lt; 7) ^ HASH1(x4))
 232 
 233 
 234 // The following macros are used to implement instruction-specific hashing.
 235 // By default, each instruction implements hash() and is_equal(Value), used
 236 // for value numbering/common subexpression elimination. The default imple-
 237 // mentation disables value numbering. Each instruction which can be value-
 238 // numbered, should define corresponding hash() and is_equal(Value) functions
 239 // via the macros below. The f arguments specify all the values/op codes, etc.
 240 // that need to be identical for two instructions to be identical.
 241 //
 242 // Note: The default implementation of hash() returns 0 in order to indicate
 243 //       that the instruction should not be considered for value numbering.
 244 //       The currently used hash functions do not guarantee that never a 0
 245 //       is produced. While this is still correct, it may be a performance
 246 //       bug (no value numbering for that node). However, this situation is
 247 //       so unlikely, that we are not going to handle it specially.
 248 
 249 #define HASHING1(class_name, enabled, f1)             \
 250   virtual intx hash() const {                         \
 251     return (enabled) ? HASH2(name(), f1) : 0;         \
 252   }                                                   \
 253   virtual bool is_equal(Value v) const {              \
 254     if (!(enabled)  ) return false;                   \
 255     class_name* _v = v-&gt;as_##class_name();            \
 256     if (_v == NULL  ) return false;                   \
 257     if (f1 != _v-&gt;f1) return false;                   \
 258     return true;                                      \
 259   }                                                   \
 260 
 261 
 262 #define HASHING2(class_name, enabled, f1, f2)         \
 263   virtual intx hash() const {                         \
 264     return (enabled) ? HASH3(name(), f1, f2) : 0;     \
 265   }                                                   \
 266   virtual bool is_equal(Value v) const {              \
 267     if (!(enabled)  ) return false;                   \
 268     class_name* _v = v-&gt;as_##class_name();            \
 269     if (_v == NULL  ) return false;                   \
 270     if (f1 != _v-&gt;f1) return false;                   \
 271     if (f2 != _v-&gt;f2) return false;                   \
 272     return true;                                      \
 273   }                                                   \
 274 
 275 
 276 #define HASHING3(class_name, enabled, f1, f2, f3)     \
 277   virtual intx hash() const {                          \
 278     return (enabled) ? HASH4(name(), f1, f2, f3) : 0; \
 279   }                                                   \
 280   virtual bool is_equal(Value v) const {              \
 281     if (!(enabled)  ) return false;                   \
 282     class_name* _v = v-&gt;as_##class_name();            \
 283     if (_v == NULL  ) return false;                   \
 284     if (f1 != _v-&gt;f1) return false;                   \
 285     if (f2 != _v-&gt;f2) return false;                   \
 286     if (f3 != _v-&gt;f3) return false;                   \
 287     return true;                                      \
 288   }                                                   \
 289 
 290 
 291 // The mother of all instructions...
 292 
 293 class Instruction: public CompilationResourceObj {
 294  private:
 295   int          _id;                              // the unique instruction id
 296 #ifndef PRODUCT
 297   int          _printable_bci;                   // the bci of the instruction for printing
 298 #endif
 299   int          _use_count;                       // the number of instructions refering to this value (w/o prev/next); only roots can have use count = 0 or &gt; 1
 300   int          _pin_state;                       // set of PinReason describing the reason for pinning
 301   ValueType*   _type;                            // the instruction value type
 302   Instruction* _next;                            // the next instruction if any (NULL for BlockEnd instructions)
 303   Instruction* _subst;                           // the substitution instruction if any
 304   LIR_Opr      _operand;                         // LIR specific information
 305   unsigned int _flags;                           // Flag bits
 306 
 307   ValueStack*  _state_before;                    // Copy of state with input operands still on stack (or NULL)
 308   ValueStack*  _exception_state;                 // Copy of state for exception handling
 309   XHandlers*   _exception_handlers;              // Flat list of exception handlers covering this instruction
 310 
 311   friend class UseCountComputer;
 312   friend class BlockBegin;
 313 
 314   void update_exception_state(ValueStack* state);
 315 
 316  protected:
 317   BlockBegin*  _block;                           // Block that contains this instruction
 318 
 319   void set_type(ValueType* type) {
 320     assert(type != NULL, &quot;type must exist&quot;);
 321     _type = type;
 322   }
 323 
 324   // Helper class to keep track of which arguments need a null check
 325   class ArgsNonNullState {
 326   private:
 327     int _nonnull_state; // mask identifying which args are nonnull
 328   public:
 329     ArgsNonNullState()
 330       : _nonnull_state(AllBits) {}
 331 
 332     // Does argument number i needs a null check?
 333     bool arg_needs_null_check(int i) const {
 334       // No data is kept for arguments starting at position 33 so
 335       // conservatively assume that they need a null check.
 336       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 337         return is_set_nth_bit(_nonnull_state, i);
 338       }
 339       return true;
 340     }
 341 
 342     // Set whether argument number i needs a null check or not
 343     void set_arg_needs_null_check(int i, bool check) {
 344       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 345         if (check) {
 346           _nonnull_state |= nth_bit(i);
 347         } else {
 348           _nonnull_state &amp;= ~(nth_bit(i));
 349         }
 350       }
 351     }
 352   };
 353 
 354  public:
 355   void* operator new(size_t size) throw() {
 356     Compilation* c = Compilation::current();
 357     void* res = c-&gt;arena()-&gt;Amalloc(size);
 358     ((Instruction*)res)-&gt;_id = c-&gt;get_next_id();
 359     return res;
 360   }
 361 
 362   static const int no_bci = -99;
 363 
 364   enum InstructionFlag {
 365     NeedsNullCheckFlag = 0,
 366     NeverNullFlag,          // For &quot;Q&quot; signatures
 367     CanTrapFlag,
 368     DirectCompareFlag,
 369     IsEliminatedFlag,
 370     IsSafepointFlag,
 371     IsStaticFlag,
 372     IsStrictfpFlag,
 373     NeedsStoreCheckFlag,
 374     NeedsWriteBarrierFlag,
 375     PreservesStateFlag,
 376     TargetIsFinalFlag,
 377     TargetIsLoadedFlag,
 378     TargetIsStrictfpFlag,
 379     UnorderedIsTrueFlag,
 380     NeedsPatchingFlag,
 381     ThrowIncompatibleClassChangeErrorFlag,
 382     InvokeSpecialReceiverCheckFlag,
 383     ProfileMDOFlag,
 384     IsLinkedInBlockFlag,
 385     NeedsRangeCheckFlag,
 386     InWorkListFlag,
 387     DeoptimizeOnException,
 388     InstructionLastFlag
 389   };
 390 
 391  public:
 392   bool check_flag(InstructionFlag id) const      { return (_flags &amp; (1 &lt;&lt; id)) != 0;    }
 393   void set_flag(InstructionFlag id, bool f)      { _flags = f ? (_flags | (1 &lt;&lt; id)) : (_flags &amp; ~(1 &lt;&lt; id)); };
 394 
 395   // &#39;globally&#39; used condition values
 396   enum Condition {
 397     eql, neq, lss, leq, gtr, geq, aeq, beq
 398   };
 399 
 400   // Instructions may be pinned for many reasons and under certain conditions
 401   // with enough knowledge it&#39;s possible to safely unpin them.
 402   enum PinReason {
 403       PinUnknown           = 1 &lt;&lt; 0
 404     , PinExplicitNullCheck = 1 &lt;&lt; 3
 405     , PinStackForStateSplit= 1 &lt;&lt; 12
 406     , PinStateSplitConstructor= 1 &lt;&lt; 13
 407     , PinGlobalValueNumbering= 1 &lt;&lt; 14
 408   };
 409 
 410   static Condition mirror(Condition cond);
 411   static Condition negate(Condition cond);
 412 
 413   // initialization
 414   static int number_of_instructions() {
 415     return Compilation::current()-&gt;number_of_instructions();
 416   }
 417 
 418   // creation
 419   Instruction(ValueType* type, ValueStack* state_before = NULL, bool type_is_constant = false)
 420   :
 421 #ifndef PRODUCT
 422   _printable_bci(-99),
 423 #endif
 424     _use_count(0)
 425   , _pin_state(0)
 426   , _type(type)
 427   , _next(NULL)
 428   , _subst(NULL)
 429   , _operand(LIR_OprFact::illegalOpr)
 430   , _flags(0)
 431   , _state_before(state_before)
 432   , _exception_handlers(NULL)
 433   , _block(NULL)
 434   {
 435     check_state(state_before);
 436     assert(type != NULL &amp;&amp; (!type-&gt;is_constant() || type_is_constant), &quot;type must exist&quot;);
 437     update_exception_state(_state_before);
 438   }
 439 
 440   // accessors
 441   int id() const                                 { return _id; }
 442 #ifndef PRODUCT
 443   bool has_printable_bci() const                 { return _printable_bci != -99; }
 444   int printable_bci() const                      { assert(has_printable_bci(), &quot;_printable_bci should have been set&quot;); return _printable_bci; }
 445   void set_printable_bci(int bci)                { _printable_bci = bci; }
 446 #endif
 447   int dominator_depth();
 448   int use_count() const                          { return _use_count; }
 449   int pin_state() const                          { return _pin_state; }
 450   bool is_pinned() const                         { return _pin_state != 0 || PinAllInstructions; }
 451   ValueType* type() const                        { return _type; }
 452   BlockBegin *block() const                      { return _block; }
 453   Instruction* prev();                           // use carefully, expensive operation
 454   Instruction* next() const                      { return _next; }
 455   bool has_subst() const                         { return _subst != NULL; }
 456   Instruction* subst()                           { return _subst == NULL ? this : _subst-&gt;subst(); }
 457   LIR_Opr operand() const                        { return _operand; }
 458 
 459   void set_needs_null_check(bool f)              { set_flag(NeedsNullCheckFlag, f); }
 460   bool needs_null_check() const                  { return check_flag(NeedsNullCheckFlag); }
 461   void set_never_null(bool f)                    { set_flag(NeverNullFlag, f); }
 462   bool is_never_null() const                     { return check_flag(NeverNullFlag); }
 463   bool is_linked() const                         { return check_flag(IsLinkedInBlockFlag); }
 464   bool can_be_linked()                           { return as_Local() == NULL &amp;&amp; as_Phi() == NULL; }
 465 
 466   bool has_uses() const                          { return use_count() &gt; 0; }
 467   ValueStack* state_before() const               { return _state_before; }
 468   ValueStack* exception_state() const            { return _exception_state; }
 469   virtual bool needs_exception_state() const     { return true; }
 470   XHandlers* exception_handlers() const          { return _exception_handlers; }
 471   ciKlass* as_loaded_klass_or_null() const;
 472 
 473   // withfield optimization
 474   virtual void set_escaped()                     { }
 475   virtual void set_local_index(int index)        { }
 476   virtual bool is_optimizable_for_withfield() const { return false; }
 477 
 478 
 479   // manipulation
 480   void pin(PinReason reason)                     { _pin_state |= reason; }
 481   void pin()                                     { _pin_state |= PinUnknown; }
 482   // DANGEROUS: only used by EliminateStores
 483   void unpin(PinReason reason)                   { assert((reason &amp; PinUnknown) == 0, &quot;can&#39;t unpin unknown state&quot;); _pin_state &amp;= ~reason; }
 484 
 485   Instruction* set_next(Instruction* next) {
 486     assert(next-&gt;has_printable_bci(), &quot;_printable_bci should have been set&quot;);
 487     assert(next != NULL, &quot;must not be NULL&quot;);
 488     assert(as_BlockEnd() == NULL, &quot;BlockEnd instructions must have no next&quot;);
 489     assert(next-&gt;can_be_linked(), &quot;shouldn&#39;t link these instructions into list&quot;);
 490 
 491     BlockBegin *block = this-&gt;block();
 492     next-&gt;_block = block;
 493 
 494     next-&gt;set_flag(Instruction::IsLinkedInBlockFlag, true);
 495     _next = next;
 496     return next;
 497   }
 498 
 499   Instruction* set_next(Instruction* next, int bci) {
 500 #ifndef PRODUCT
 501     next-&gt;set_printable_bci(bci);
 502 #endif
 503     return set_next(next);
 504   }
 505 
 506   // when blocks are merged
 507   void fixup_block_pointers() {
 508     Instruction *cur = next()-&gt;next(); // next()&#39;s block is set in set_next
 509     while (cur &amp;&amp; cur-&gt;_block != block()) {
 510       cur-&gt;_block = block();
 511       cur = cur-&gt;next();
 512     }
 513   }
 514 
 515   Instruction *insert_after(Instruction *i) {
 516     Instruction* n = _next;
 517     set_next(i);
 518     i-&gt;set_next(n);
 519     return _next;
 520   }
 521 
 522   bool is_loaded_flattened_array() const;
 523   bool maybe_flattened_array();
 524   bool maybe_null_free_array();
 525 
 526   Instruction *insert_after_same_bci(Instruction *i) {
 527 #ifndef PRODUCT
 528     i-&gt;set_printable_bci(printable_bci());
 529 #endif
 530     return insert_after(i);
 531   }
 532 
 533   void set_subst(Instruction* subst)             {
 534     assert(subst == NULL ||
 535            type()-&gt;base() == subst-&gt;type()-&gt;base() ||
 536            subst-&gt;type()-&gt;base() == illegalType, &quot;type can&#39;t change&quot;);
 537     _subst = subst;
 538   }
 539   void set_exception_handlers(XHandlers *xhandlers) { _exception_handlers = xhandlers; }
 540   void set_exception_state(ValueStack* s)        { check_state(s); _exception_state = s; }
 541   void set_state_before(ValueStack* s)           { check_state(s); _state_before = s; }
 542 
 543   // machine-specifics
 544   void set_operand(LIR_Opr operand)              { assert(operand != LIR_OprFact::illegalOpr, &quot;operand must exist&quot;); _operand = operand; }
 545   void clear_operand()                           { _operand = LIR_OprFact::illegalOpr; }
 546 
 547   // generic
 548   virtual Instruction*      as_Instruction()     { return this; } // to satisfy HASHING1 macro
 549   virtual Phi*              as_Phi()             { return NULL; }
 550   virtual Local*            as_Local()           { return NULL; }
 551   virtual Constant*         as_Constant()        { return NULL; }
 552   virtual AccessField*      as_AccessField()     { return NULL; }
 553   virtual LoadField*        as_LoadField()       { return NULL; }
 554   virtual StoreField*       as_StoreField()      { return NULL; }
 555   virtual AccessArray*      as_AccessArray()     { return NULL; }
 556   virtual ArrayLength*      as_ArrayLength()     { return NULL; }
 557   virtual AccessIndexed*    as_AccessIndexed()   { return NULL; }
 558   virtual LoadIndexed*      as_LoadIndexed()     { return NULL; }
 559   virtual StoreIndexed*     as_StoreIndexed()    { return NULL; }
 560   virtual NegateOp*         as_NegateOp()        { return NULL; }
 561   virtual Op2*              as_Op2()             { return NULL; }
 562   virtual ArithmeticOp*     as_ArithmeticOp()    { return NULL; }
 563   virtual ShiftOp*          as_ShiftOp()         { return NULL; }
 564   virtual LogicOp*          as_LogicOp()         { return NULL; }
 565   virtual CompareOp*        as_CompareOp()       { return NULL; }
 566   virtual IfOp*             as_IfOp()            { return NULL; }
 567   virtual Convert*          as_Convert()         { return NULL; }
 568   virtual NullCheck*        as_NullCheck()       { return NULL; }
 569   virtual OsrEntry*         as_OsrEntry()        { return NULL; }
 570   virtual StateSplit*       as_StateSplit()      { return NULL; }
 571   virtual Invoke*           as_Invoke()          { return NULL; }
 572   virtual NewInstance*      as_NewInstance()     { return NULL; }
 573   virtual NewValueTypeInstance* as_NewValueTypeInstance() { return NULL; }
 574   virtual NewArray*         as_NewArray()        { return NULL; }
 575   virtual NewTypeArray*     as_NewTypeArray()    { return NULL; }
 576   virtual NewObjectArray*   as_NewObjectArray()  { return NULL; }
 577   virtual NewMultiArray*    as_NewMultiArray()   { return NULL; }
 578   virtual WithField*        as_WithField()       { return NULL; }
 579   virtual DefaultValue*     as_DefaultValue()    { return NULL; }
 580   virtual TypeCheck*        as_TypeCheck()       { return NULL; }
 581   virtual CheckCast*        as_CheckCast()       { return NULL; }
 582   virtual InstanceOf*       as_InstanceOf()      { return NULL; }
 583   virtual TypeCast*         as_TypeCast()        { return NULL; }
 584   virtual AccessMonitor*    as_AccessMonitor()   { return NULL; }
 585   virtual MonitorEnter*     as_MonitorEnter()    { return NULL; }
 586   virtual MonitorExit*      as_MonitorExit()     { return NULL; }
 587   virtual Intrinsic*        as_Intrinsic()       { return NULL; }
 588   virtual BlockBegin*       as_BlockBegin()      { return NULL; }
 589   virtual BlockEnd*         as_BlockEnd()        { return NULL; }
 590   virtual Goto*             as_Goto()            { return NULL; }
 591   virtual If*               as_If()              { return NULL; }
 592   virtual IfInstanceOf*     as_IfInstanceOf()    { return NULL; }
 593   virtual TableSwitch*      as_TableSwitch()     { return NULL; }
 594   virtual LookupSwitch*     as_LookupSwitch()    { return NULL; }
 595   virtual Return*           as_Return()          { return NULL; }
 596   virtual Throw*            as_Throw()           { return NULL; }
 597   virtual Base*             as_Base()            { return NULL; }
 598   virtual RoundFP*          as_RoundFP()         { return NULL; }
 599   virtual ExceptionObject*  as_ExceptionObject() { return NULL; }
 600   virtual UnsafeOp*         as_UnsafeOp()        { return NULL; }
 601   virtual ProfileInvoke*    as_ProfileInvoke()   { return NULL; }
 602   virtual RangeCheckPredicate* as_RangeCheckPredicate() { return NULL; }
 603 
 604 #ifdef ASSERT
 605   virtual Assert*           as_Assert()          { return NULL; }
 606 #endif
 607 
 608   virtual void visit(InstructionVisitor* v)      = 0;
 609 
 610   virtual bool can_trap() const                  { return false; }
 611 
 612   virtual void input_values_do(ValueVisitor* f)   = 0;
 613   virtual void state_values_do(ValueVisitor* f);
 614   virtual void other_values_do(ValueVisitor* f)   { /* usually no other - override on demand */ }
 615           void       values_do(ValueVisitor* f)   { input_values_do(f); state_values_do(f); other_values_do(f); }
 616 
 617   virtual ciType* exact_type() const;
 618   virtual ciType* declared_type() const          { return NULL; }
 619 
 620   // hashing
 621   virtual const char* name() const               = 0;
 622   HASHING1(Instruction, false, id())             // hashing disabled by default
 623 
 624   // debugging
 625   static void check_state(ValueStack* state)     PRODUCT_RETURN;
 626   void print()                                   PRODUCT_RETURN;
 627   void print_line()                              PRODUCT_RETURN;
 628   void print(InstructionPrinter&amp; ip)             PRODUCT_RETURN;
 629 };
 630 
 631 
 632 // The following macros are used to define base (i.e., non-leaf)
 633 // and leaf instruction classes. They define class-name related
 634 // generic functionality in one place.
 635 
 636 #define BASE(class_name, super_class_name)       \
 637   class class_name: public super_class_name {    \
 638    public:                                       \
 639     virtual class_name* as_##class_name()        { return this; }              \
 640 
 641 
 642 #define LEAF(class_name, super_class_name)       \
 643   BASE(class_name, super_class_name)             \
 644    public:                                       \
 645     virtual const char* name() const             { return #class_name; }       \
 646     virtual void visit(InstructionVisitor* v)    { v-&gt;do_##class_name(this); } \
 647 
 648 
 649 // Debugging support
 650 
 651 
 652 #ifdef ASSERT
 653 class AssertValues: public ValueVisitor {
 654   void visit(Value* x)             { assert((*x) != NULL, &quot;value must exist&quot;); }
 655 };
 656   #define ASSERT_VALUES                          { AssertValues assert_value; values_do(&amp;assert_value); }
 657 #else
 658   #define ASSERT_VALUES
 659 #endif // ASSERT
 660 
 661 
 662 // A Phi is a phi function in the sense of SSA form. It stands for
 663 // the value of a local variable at the beginning of a join block.
 664 // A Phi consists of n operands, one for every incoming branch.
 665 
 666 LEAF(Phi, Instruction)
 667  private:
 668   int         _pf_flags; // the flags of the phi function
 669   int         _index;    // to value on operand stack (index &lt; 0) or to local
 670  public:
 671   // creation
 672   Phi(ValueType* type, BlockBegin* b, int index)
 673   : Instruction(type-&gt;base())
 674   , _pf_flags(0)
 675   , _index(index)
 676   {
 677     _block = b;
 678     NOT_PRODUCT(set_printable_bci(Value(b)-&gt;printable_bci()));
 679     if (type-&gt;is_illegal()) {
 680       make_illegal();
 681     }
 682   }
 683 
 684   // flags
 685   enum Flag {
 686     no_flag         = 0,
 687     visited         = 1 &lt;&lt; 0,
 688     cannot_simplify = 1 &lt;&lt; 1
 689   };
 690 
 691   // accessors
 692   bool  is_local() const          { return _index &gt;= 0; }
 693   bool  is_on_stack() const       { return !is_local(); }
 694   int   local_index() const       { assert(is_local(), &quot;&quot;); return _index; }
 695   int   stack_index() const       { assert(is_on_stack(), &quot;&quot;); return -(_index+1); }
 696 
 697   Value operand_at(int i) const;
 698   int   operand_count() const;
 699 
 700   void   set(Flag f)              { _pf_flags |=  f; }
 701   void   clear(Flag f)            { _pf_flags &amp;= ~f; }
 702   bool   is_set(Flag f) const     { return (_pf_flags &amp; f) != 0; }
 703 
 704   // Invalidates phis corresponding to merges of locals of two different types
 705   // (these should never be referenced, otherwise the bytecodes are illegal)
 706   void   make_illegal() {
 707     set(cannot_simplify);
 708     set_type(illegalType);
 709   }
 710 
 711   bool is_illegal() const {
 712     return type()-&gt;is_illegal();
 713   }
 714 
 715   // generic
 716   virtual void input_values_do(ValueVisitor* f) {
 717   }
 718 };
 719 
 720 
 721 // A local is a placeholder for an incoming argument to a function call.
 722 LEAF(Local, Instruction)
 723  private:
 724   int      _java_index;                          // the local index within the method to which the local belongs
 725   bool     _is_receiver;                         // if local variable holds the receiver: &quot;this&quot; for non-static methods
 726   ciType*  _declared_type;
 727  public:
 728   // creation
 729   Local(ciType* declared, ValueType* type, int index, bool receiver, bool never_null)
 730     : Instruction(type)
 731     , _java_index(index)
 732     , _is_receiver(receiver)
 733     , _declared_type(declared)
 734   {
 735     set_never_null(never_null);
 736     NOT_PRODUCT(set_printable_bci(-1));
 737   }
 738 
 739   // accessors
 740   int java_index() const                         { return _java_index; }
 741   bool is_receiver() const                       { return _is_receiver; }
 742 
 743   virtual ciType* declared_type() const          { return _declared_type; }
 744 
 745   // generic
 746   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 747 };
 748 
 749 
 750 LEAF(Constant, Instruction)
 751  public:
 752   // creation
 753   Constant(ValueType* type):
 754       Instruction(type, NULL, /*type_is_constant*/ true)
 755   {
 756     assert(type-&gt;is_constant(), &quot;must be a constant&quot;);
 757   }
 758 
 759   Constant(ValueType* type, ValueStack* state_before):
 760     Instruction(type, state_before, /*type_is_constant*/ true)
 761   {
 762     assert(state_before != NULL, &quot;only used for constants which need patching&quot;);
 763     assert(type-&gt;is_constant(), &quot;must be a constant&quot;);
 764     // since it&#39;s patching it needs to be pinned
 765     pin();
 766   }
 767 
 768   // generic
 769   virtual bool can_trap() const                  { return state_before() != NULL; }
 770   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 771 
 772   virtual intx hash() const;
 773   virtual bool is_equal(Value v) const;
 774 
 775   virtual ciType* exact_type() const;
 776 
 777   enum CompareResult { not_comparable = -1, cond_false, cond_true };
 778 
 779   virtual CompareResult compare(Instruction::Condition condition, Value right) const;
 780   BlockBegin* compare(Instruction::Condition cond, Value right,
 781                       BlockBegin* true_sux, BlockBegin* false_sux) const {
 782     switch (compare(cond, right)) {
 783     case not_comparable:
 784       return NULL;
 785     case cond_false:
 786       return false_sux;
 787     case cond_true:
 788       return true_sux;
 789     default:
 790       ShouldNotReachHere();
 791       return NULL;
 792     }
 793   }
 794 };
 795 
 796 
 797 BASE(AccessField, Instruction)
 798  private:
 799   Value       _obj;
 800   int         _offset;
 801   ciField*    _field;
 802   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 803 
 804  public:
 805   // creation
 806   AccessField(Value obj, int offset, ciField* field, bool is_static,
 807               ValueStack* state_before, bool needs_patching)
 808   : Instruction(as_ValueType(field-&gt;type()-&gt;basic_type()), state_before)
 809   , _obj(obj)
 810   , _offset(offset)
 811   , _field(field)
 812   , _explicit_null_check(NULL)
 813   {
 814     set_needs_null_check(!is_static);
 815     set_flag(IsStaticFlag, is_static);
 816     set_flag(NeedsPatchingFlag, needs_patching);
 817     ASSERT_VALUES
 818     // pin of all instructions with memory access
 819     pin();
 820   }
 821 
 822   // accessors
 823   Value obj() const                              { return _obj; }
 824   int offset() const                             { return _offset; }
 825   ciField* field() const                         { return _field; }
 826   BasicType field_type() const                   { return _field-&gt;type()-&gt;basic_type(); }
 827   bool is_static() const                         { return check_flag(IsStaticFlag); }
 828   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 829   bool needs_patching() const                    { return check_flag(NeedsPatchingFlag); }
 830 
 831   // Unresolved getstatic and putstatic can cause initialization.
 832   // Technically it occurs at the Constant that materializes the base
 833   // of the static fields but it&#39;s simpler to model it here.
 834   bool is_init_point() const                     { return is_static() &amp;&amp; (needs_patching() || !_field-&gt;holder()-&gt;is_initialized()); }
 835 
 836   // manipulation
 837 
 838   // Under certain circumstances, if a previous NullCheck instruction
 839   // proved the target object non-null, we can eliminate the explicit
 840   // null check and do an implicit one, simply specifying the debug
 841   // information from the NullCheck. This field should only be consulted
 842   // if needs_null_check() is true.
 843   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 844 
 845   // generic
 846   virtual bool can_trap() const                  { return needs_null_check() || needs_patching(); }
 847   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
 848 };
 849 
 850 
 851 LEAF(LoadField, AccessField)
 852  public:
 853   // creation
 854   LoadField(Value obj, int offset, ciField* field, bool is_static,
 855             ValueStack* state_before, bool needs_patching,
 856             ciValueKlass* value_klass = NULL, Value default_value = NULL )
 857   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 858   {}
 859 
 860   ciType* declared_type() const;
 861 
 862   // generic
 863   HASHING2(LoadField, !needs_patching() &amp;&amp; !field()-&gt;is_volatile(), obj()-&gt;subst(), offset())  // cannot be eliminated if needs patching or if volatile
 864 };
 865 
 866 
 867 LEAF(StoreField, AccessField)
 868  private:
 869   Value _value;
 870 
 871  public:
 872   // creation
 873   StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,
 874              ValueStack* state_before, bool needs_patching)
 875   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 876   , _value(value)
 877   {
 878     set_flag(NeedsWriteBarrierFlag, as_ValueType(field_type())-&gt;is_object());
 879     ASSERT_VALUES
 880     pin();
 881   }
 882 
 883   // accessors
 884   Value value() const                            { return _value; }
 885   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
 886 
 887   // generic
 888   virtual void input_values_do(ValueVisitor* f)   { AccessField::input_values_do(f); f-&gt;visit(&amp;_value); }
 889 };
 890 
 891 
 892 BASE(AccessArray, Instruction)
 893  private:
 894   Value       _array;
 895 
 896  public:
 897   // creation
 898   AccessArray(ValueType* type, Value array, ValueStack* state_before)
 899   : Instruction(type, state_before)
 900   , _array(array)
 901   {
 902     set_needs_null_check(true);
 903     ASSERT_VALUES
 904     pin(); // instruction with side effect (null exception or range check throwing)
 905   }
 906 
 907   Value array() const                            { return _array; }
 908 
 909   // generic
 910   virtual bool can_trap() const                  { return needs_null_check(); }
 911   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_array); }
 912 };
 913 
 914 
 915 LEAF(ArrayLength, AccessArray)
 916  private:
 917   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 918 
 919  public:
 920   // creation
 921   ArrayLength(Value array, ValueStack* state_before)
 922   : AccessArray(intType, array, state_before)
 923   , _explicit_null_check(NULL) {}
 924 
 925   // accessors
 926   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 927 
 928   // setters
 929   // See LoadField::set_explicit_null_check for documentation
 930   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 931 
 932   // generic
 933   HASHING1(ArrayLength, true, array()-&gt;subst())
 934 };
 935 
 936 
 937 BASE(AccessIndexed, AccessArray)
 938  private:
 939   Value     _index;
 940   Value     _length;
 941   BasicType _elt_type;
 942   bool      _mismatched;
 943   ciMethod* _profiled_method;
 944   int       _profiled_bci;
 945 
 946  public:
 947   // creation
 948   AccessIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched)
 949   : AccessArray(as_ValueType(elt_type), array, state_before)
 950   , _index(index)
 951   , _length(length)
 952   , _elt_type(elt_type)
 953   , _mismatched(mismatched)
 954   , _profiled_method(NULL), _profiled_bci(0)
 955   {
 956     set_flag(Instruction::NeedsRangeCheckFlag, true);
 957     ASSERT_VALUES
 958   }
 959 
 960   // accessors
 961   Value index() const                            { return _index; }
 962   Value length() const                           { return _length; }
 963   BasicType elt_type() const                     { return _elt_type; }
 964   bool mismatched() const                        { return _mismatched; }
 965 
 966   void clear_length()                            { _length = NULL; }
 967   // perform elimination of range checks involving constants
 968   bool compute_needs_range_check();
 969 
 970   // Helpers for MethodData* profiling
 971   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
 972   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
 973   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
 974   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
 975   ciMethod* profiled_method() const                  { return _profiled_method;     }
 976   int       profiled_bci() const                     { return _profiled_bci;        }
 977 
 978 
 979 // generic
 980   virtual void input_values_do(ValueVisitor* f)   { AccessArray::input_values_do(f); f-&gt;visit(&amp;_index); if (_length != NULL) f-&gt;visit(&amp;_length); }
 981 };
 982 
 983 
 984 LEAF(LoadIndexed, AccessIndexed)
 985  private:
 986   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 987   NewValueTypeInstance* _vt;
 988 
 989  public:
 990   // creation
 991   LoadIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched = false)
 992   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
 993   , _explicit_null_check(NULL), _vt(NULL) {}
 994 
 995   // accessors
 996   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 997 
 998   // setters
 999   // See LoadField::set_explicit_null_check for documentation
1000   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
1001 
1002   ciType* exact_type() const;
1003   ciType* declared_type() const;
1004 
1005   NewValueTypeInstance* vt() const { return _vt; }
1006   void set_vt(NewValueTypeInstance* vt) { _vt = vt; }
1007 
1008   // generic
1009   HASHING3(LoadIndexed, !should_profile(), array()-&gt;subst(), index()-&gt;subst(), vt())
1010 };
1011 
1012 
1013 LEAF(StoreIndexed, AccessIndexed)
1014  private:
1015   Value       _value;
1016 
1017   bool      _check_boolean;
1018 
1019  public:
1020   // creation
1021   StoreIndexed(Value array, Value index, Value length, BasicType elt_type, Value value, ValueStack* state_before,
1022                bool check_boolean, bool mismatched = false)
1023   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
1024   , _value(value), _check_boolean(check_boolean)
1025   {
1026     set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)-&gt;is_object()));
1027     set_flag(NeedsStoreCheckFlag, (as_ValueType(elt_type)-&gt;is_object()));
1028     ASSERT_VALUES
1029     pin();
1030   }
1031 
1032   // accessors
1033   Value value() const                            { return _value; }
1034   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
1035   bool needs_store_check() const                 { return check_flag(NeedsStoreCheckFlag); }
1036   bool check_boolean() const                     { return _check_boolean; }
1037 
1038   // Flattened array support
1039   bool is_exact_flattened_array_store() const;
1040   // generic
1041   virtual void input_values_do(ValueVisitor* f)   { AccessIndexed::input_values_do(f); f-&gt;visit(&amp;_value); }
1042 };
1043 
1044 
1045 LEAF(NegateOp, Instruction)
1046  private:
1047   Value _x;
1048 
1049  public:
1050   // creation
1051   NegateOp(Value x) : Instruction(x-&gt;type()-&gt;base()), _x(x) {
1052     ASSERT_VALUES
1053   }
1054 
1055   // accessors
1056   Value x() const                                { return _x; }
1057 
1058   // generic
1059   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); }
1060 };
1061 
1062 
1063 BASE(Op2, Instruction)
1064  private:
1065   Bytecodes::Code _op;
1066   Value           _x;
1067   Value           _y;
1068 
1069  public:
1070   // creation
1071   Op2(ValueType* type, Bytecodes::Code op, Value x, Value y, ValueStack* state_before = NULL)
1072   : Instruction(type, state_before)
1073   , _op(op)
1074   , _x(x)
1075   , _y(y)
1076   {
1077     ASSERT_VALUES
1078   }
1079 
1080   // accessors
1081   Bytecodes::Code op() const                     { return _op; }
1082   Value x() const                                { return _x; }
1083   Value y() const                                { return _y; }
1084 
1085   // manipulators
1086   void swap_operands() {
1087     assert(is_commutative(), &quot;operation must be commutative&quot;);
1088     Value t = _x; _x = _y; _y = t;
1089   }
1090 
1091   // generic
1092   virtual bool is_commutative() const            { return false; }
1093   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
1094 };
1095 
1096 
1097 LEAF(ArithmeticOp, Op2)
1098  public:
1099   // creation
1100   ArithmeticOp(Bytecodes::Code op, Value x, Value y, bool is_strictfp, ValueStack* state_before)
1101   : Op2(x-&gt;type()-&gt;meet(y-&gt;type()), op, x, y, state_before)
1102   {
1103     set_flag(IsStrictfpFlag, is_strictfp);
1104     if (can_trap()) pin();
1105   }
1106 
1107   // accessors
1108   bool        is_strictfp() const                { return check_flag(IsStrictfpFlag); }
1109 
1110   // generic
1111   virtual bool is_commutative() const;
1112   virtual bool can_trap() const;
1113   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1114 };
1115 
1116 
1117 LEAF(ShiftOp, Op2)
1118  public:
1119   // creation
1120   ShiftOp(Bytecodes::Code op, Value x, Value s) : Op2(x-&gt;type()-&gt;base(), op, x, s) {}
1121 
1122   // generic
1123   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1124 };
1125 
1126 
1127 LEAF(LogicOp, Op2)
1128  public:
1129   // creation
1130   LogicOp(Bytecodes::Code op, Value x, Value y) : Op2(x-&gt;type()-&gt;meet(y-&gt;type()), op, x, y) {}
1131 
1132   // generic
1133   virtual bool is_commutative() const;
1134   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1135 };
1136 
1137 
1138 LEAF(CompareOp, Op2)
1139  public:
1140   // creation
1141   CompareOp(Bytecodes::Code op, Value x, Value y, ValueStack* state_before)
1142   : Op2(intType, op, x, y, state_before)
1143   {}
1144 
1145   // generic
1146   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1147 };
1148 
1149 
1150 LEAF(IfOp, Op2)
1151  private:
1152   Value _tval;
1153   Value _fval;
1154   bool _substitutability_check;
1155 
1156  public:
1157   // creation
1158   IfOp(Value x, Condition cond, Value y, Value tval, Value fval, ValueStack* state_before, bool substitutability_check)
1159   : Op2(tval-&gt;type()-&gt;meet(fval-&gt;type()), (Bytecodes::Code)cond, x, y)
1160   , _tval(tval)
1161   , _fval(fval)
1162   , _substitutability_check(substitutability_check)
1163   {
1164     ASSERT_VALUES
1165     assert(tval-&gt;type()-&gt;tag() == fval-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1166     set_state_before(state_before);
1167   }
1168 
1169   // accessors
1170   virtual bool is_commutative() const;
1171   Bytecodes::Code op() const                     { ShouldNotCallThis(); return Bytecodes::_illegal; }
1172   Condition cond() const                         { return (Condition)Op2::op(); }
1173   Value tval() const                             { return _tval; }
1174   Value fval() const                             { return _fval; }
1175   bool substitutability_check() const             { return _substitutability_check; }
1176   // generic
1177   virtual void input_values_do(ValueVisitor* f)   { Op2::input_values_do(f); f-&gt;visit(&amp;_tval); f-&gt;visit(&amp;_fval); }
1178 };
1179 
1180 
1181 LEAF(Convert, Instruction)
1182  private:
1183   Bytecodes::Code _op;
1184   Value           _value;
1185 
1186  public:
1187   // creation
1188   Convert(Bytecodes::Code op, Value value, ValueType* to_type) : Instruction(to_type), _op(op), _value(value) {
1189     ASSERT_VALUES
1190   }
1191 
1192   // accessors
1193   Bytecodes::Code op() const                     { return _op; }
1194   Value value() const                            { return _value; }
1195 
1196   // generic
1197   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_value); }
1198   HASHING2(Convert, true, op(), value()-&gt;subst())
1199 };
1200 
1201 
1202 LEAF(NullCheck, Instruction)
1203  private:
1204   Value       _obj;
1205 
1206  public:
1207   // creation
1208   NullCheck(Value obj, ValueStack* state_before)
1209   : Instruction(obj-&gt;type()-&gt;base(), state_before)
1210   , _obj(obj)
1211   {
1212     ASSERT_VALUES
1213     set_can_trap(true);
1214     assert(_obj-&gt;type()-&gt;is_object(), &quot;null check must be applied to objects only&quot;);
1215     pin(Instruction::PinExplicitNullCheck);
1216   }
1217 
1218   // accessors
1219   Value obj() const                              { return _obj; }
1220 
1221   // setters
1222   void set_can_trap(bool can_trap)               { set_flag(CanTrapFlag, can_trap); }
1223 
1224   // generic
1225   virtual bool can_trap() const                  { return check_flag(CanTrapFlag); /* null-check elimination sets to false */ }
1226   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
1227   HASHING1(NullCheck, true, obj()-&gt;subst())
1228 };
1229 
1230 
1231 // This node is supposed to cast the type of another node to a more precise
1232 // declared type.
1233 LEAF(TypeCast, Instruction)
1234  private:
1235   ciType* _declared_type;
1236   Value   _obj;
1237 
1238  public:
1239   // The type of this node is the same type as the object type (and it might be constant).
1240   TypeCast(ciType* type, Value obj, ValueStack* state_before)
1241   : Instruction(obj-&gt;type(), state_before, obj-&gt;type()-&gt;is_constant()),
1242     _declared_type(type),
1243     _obj(obj) {}
1244 
1245   // accessors
1246   ciType* declared_type() const                  { return _declared_type; }
1247   Value   obj() const                            { return _obj; }
1248 
1249   // generic
1250   virtual void input_values_do(ValueVisitor* f)  { f-&gt;visit(&amp;_obj); }
1251 };
1252 
1253 
1254 BASE(StateSplit, Instruction)
1255  private:
1256   ValueStack* _state;
1257 
1258  protected:
1259   static void substitute(BlockList&amp; list, BlockBegin* old_block, BlockBegin* new_block);
1260 
1261  public:
1262   // creation
1263   StateSplit(ValueType* type, ValueStack* state_before = NULL)
1264   : Instruction(type, state_before)
1265   , _state(NULL)
1266   {
1267     pin(PinStateSplitConstructor);
1268   }
1269 
1270   // accessors
1271   ValueStack* state() const                      { return _state; }
1272   IRScope* scope() const;                        // the state&#39;s scope
1273 
1274   // manipulation
1275   void set_state(ValueStack* state)              { assert(_state == NULL, &quot;overwriting existing state&quot;); check_state(state); _state = state; }
1276 
1277   // generic
1278   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
1279   virtual void state_values_do(ValueVisitor* f);
1280 };
1281 
1282 
1283 LEAF(Invoke, StateSplit)
1284  private:
1285   Bytecodes::Code _code;
1286   Value           _recv;
1287   Values*         _args;
1288   BasicTypeList*  _signature;
1289   int             _vtable_index;
1290   ciMethod*       _target;
1291 
1292  public:
1293   // creation
1294   Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
1295          int vtable_index, ciMethod* target, ValueStack* state_before, bool never_null);
1296 
1297   // accessors
1298   Bytecodes::Code code() const                   { return _code; }
1299   Value receiver() const                         { return _recv; }
1300   bool has_receiver() const                      { return receiver() != NULL; }
1301   int number_of_arguments() const                { return _args-&gt;length(); }
1302   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1303   int vtable_index() const                       { return _vtable_index; }
1304   BasicTypeList* signature() const               { return _signature; }
1305   ciMethod* target() const                       { return _target; }
1306 
1307   ciType* declared_type() const;
1308 
1309   // Returns false if target is not loaded
1310   bool target_is_final() const                   { return check_flag(TargetIsFinalFlag); }
1311   bool target_is_loaded() const                  { return check_flag(TargetIsLoadedFlag); }
1312   // Returns false if target is not loaded
1313   bool target_is_strictfp() const                { return check_flag(TargetIsStrictfpFlag); }
1314 
1315   // JSR 292 support
1316   bool is_invokedynamic() const                  { return code() == Bytecodes::_invokedynamic; }
1317   bool is_method_handle_intrinsic() const        { return target()-&gt;is_method_handle_intrinsic(); }
1318 
1319   virtual bool needs_exception_state() const     { return false; }
1320 
1321   // generic
1322   virtual bool can_trap() const                  { return true; }
1323   virtual void input_values_do(ValueVisitor* f) {
1324     StateSplit::input_values_do(f);
1325     if (has_receiver()) f-&gt;visit(&amp;_recv);
1326     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
1327   }
1328   virtual void state_values_do(ValueVisitor *f);
1329 };
1330 
1331 
1332 LEAF(NewInstance, StateSplit)
1333  private:
1334   ciInstanceKlass* _klass;
1335   bool _is_unresolved;
1336 
1337  public:
1338   // creation
1339   NewInstance(ciInstanceKlass* klass, ValueStack* state_before, bool is_unresolved)
1340   : StateSplit(instanceType, state_before)
1341   , _klass(klass), _is_unresolved(is_unresolved)
1342   {}
1343 
1344   // accessors
1345   ciInstanceKlass* klass() const                 { return _klass; }
1346   bool is_unresolved() const                     { return _is_unresolved; }
1347 
1348   virtual bool needs_exception_state() const     { return false; }
1349 
1350   // generic
1351   virtual bool can_trap() const                  { return true; }
1352   ciType* exact_type() const;
1353   ciType* declared_type() const;
1354 };
1355 
1356 LEAF(NewValueTypeInstance, StateSplit)
1357   bool _is_unresolved;
1358   ciValueKlass* _klass;
1359   Value _depends_on;      // Link to instance on with withfield was called on
1360   bool _is_optimizable_for_withfield;
1361   int _first_local_index;
1362 public:
1363 
1364   // Default creation, always allocated for now
1365   NewValueTypeInstance(ciValueKlass* klass, ValueStack* state_before, bool is_unresolved, Value depends_on = NULL, bool from_default_value = false)
1366   : StateSplit(instanceType, state_before)
1367    , _is_unresolved(is_unresolved)
1368    , _klass(klass)
1369    , _is_optimizable_for_withfield(from_default_value)
1370    , _first_local_index(-1)
1371   {
1372     if (depends_on == NULL) {
1373       _depends_on = this;
1374     } else {
1375       _depends_on = depends_on;
1376     }
1377     set_never_null(true);
1378   }
1379 
1380   // accessors
1381   bool is_unresolved() const                     { return _is_unresolved; }
1382   Value depends_on();
1383 
1384   ciValueKlass* klass() const { return _klass; }
1385 
1386   virtual bool needs_exception_state() const     { return false; }
1387 
1388   // generic
1389   virtual bool can_trap() const                  { return true; }
1390   ciType* exact_type() const;
1391   ciType* declared_type() const;
1392 
1393   // Only done in LIR Generator -&gt; map everything to object
1394   void set_to_object_type() { set_type(instanceType); }
1395 
1396   // withfield optimization
1397   virtual void set_escaped() {
1398     _is_optimizable_for_withfield = false;
1399   }
1400   virtual void set_local_index(int index) {
1401     if (_first_local_index != index) {
1402       if (_first_local_index == -1) {
1403         _first_local_index = index;
1404       } else {
1405         _is_optimizable_for_withfield = false;
1406       }
1407     }
1408   }
1409   virtual bool is_optimizable_for_withfield() const {  return _is_optimizable_for_withfield; }
1410 };
1411 
1412 BASE(NewArray, StateSplit)
1413  private:
1414   Value       _length;
1415 
1416  public:
1417   // creation
1418   NewArray(Value length, ValueStack* state_before)
1419   : StateSplit(objectType, state_before)
1420   , _length(length)
1421   {
1422     // Do not ASSERT_VALUES since length is NULL for NewMultiArray
1423   }
1424 
1425   // accessors
1426   Value length() const                           { return _length; }
1427 
1428   virtual bool needs_exception_state() const     { return false; }
1429 
1430   ciType* exact_type() const                     { return NULL; }
1431   ciType* declared_type() const;
1432 
1433   // generic
1434   virtual bool can_trap() const                  { return true; }
1435   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_length); }
1436 };
1437 
1438 
1439 LEAF(NewTypeArray, NewArray)
1440  private:
1441   BasicType _elt_type;
1442 
1443  public:
1444   // creation
1445   NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before)
1446   : NewArray(length, state_before)
1447   , _elt_type(elt_type)
1448   {}
1449 
1450   // accessors
1451   BasicType elt_type() const                     { return _elt_type; }
1452   ciType* exact_type() const;
1453 };
1454 
1455 
1456 LEAF(NewObjectArray, NewArray)
1457  private:
1458   ciKlass* _klass;
1459 
1460  public:
1461   // creation
1462   NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before, bool never_null)
1463   : NewArray(length, state_before), _klass(klass) {
1464     set_never_null(never_null);
1465   }
1466 
1467   // accessors
1468   ciKlass* klass() const                         { return _klass; }
1469   ciType* exact_type() const;
1470 };
1471 
1472 
1473 LEAF(NewMultiArray, NewArray)
1474  private:
1475   ciKlass* _klass;
1476   Values*  _dims;
1477 
1478  public:
1479   // creation
1480   NewMultiArray(ciKlass* klass, Values* dims, ValueStack* state_before) : NewArray(NULL, state_before), _klass(klass), _dims(dims) {
1481     ASSERT_VALUES
1482   }
1483 
1484   // accessors
1485   ciKlass* klass() const                         { return _klass; }
1486   Values* dims() const                           { return _dims; }
1487   int rank() const                               { return dims()-&gt;length(); }
1488 
1489   // generic
1490   virtual void input_values_do(ValueVisitor* f) {
1491     // NOTE: we do not call NewArray::input_values_do since &quot;length&quot;
1492     // is meaningless for a multi-dimensional array; passing the
1493     // zeroth element down to NewArray as its length is a bad idea
1494     // since there will be a copy in the &quot;dims&quot; array which doesn&#39;t
1495     // get updated, and the value must not be traversed twice. Was bug
1496     // - kbr 4/10/2001
1497     StateSplit::input_values_do(f);
1498     for (int i = 0; i &lt; _dims-&gt;length(); i++) f-&gt;visit(_dims-&gt;adr_at(i));
1499   }
1500 
1501   ciType* exact_type() const;
1502 };
1503 
1504 LEAF(WithField, StateSplit)
1505  public:
1506   // creation
1507   WithField(ValueStack* state_before)
1508   : StateSplit(objectType, state_before) {}
1509 };
1510 
1511 LEAF(DefaultValue, StateSplit)
1512  public:
1513   // creation
1514   DefaultValue(ValueStack* state_before)
1515   : StateSplit(objectType, state_before) {}
1516 };
1517 
1518 BASE(TypeCheck, StateSplit)
1519  private:
1520   ciKlass*    _klass;
1521   Value       _obj;
1522 
1523   ciMethod* _profiled_method;
1524   int       _profiled_bci;
1525 
1526  public:
1527   // creation
1528   TypeCheck(ciKlass* klass, Value obj, ValueType* type, ValueStack* state_before)
1529   : StateSplit(type, state_before), _klass(klass), _obj(obj),
1530     _profiled_method(NULL), _profiled_bci(0) {
1531     ASSERT_VALUES
1532     set_direct_compare(false);
1533   }
1534 
1535   // accessors
1536   ciKlass* klass() const                         { return _klass; }
1537   Value obj() const                              { return _obj; }
1538   bool is_loaded() const                         { return klass() != NULL; }
1539   bool direct_compare() const                    { return check_flag(DirectCompareFlag); }
1540 
1541   // manipulation
1542   void set_direct_compare(bool flag)             { set_flag(DirectCompareFlag, flag); }
1543 
1544   // generic
1545   virtual bool can_trap() const                  { return true; }
1546   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1547 
1548   // Helpers for MethodData* profiling
1549   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
1550   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
1551   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
1552   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
1553   ciMethod* profiled_method() const                  { return _profiled_method;     }
1554   int       profiled_bci() const                     { return _profiled_bci;        }
1555 };
1556 
1557 
1558 LEAF(CheckCast, TypeCheck)
1559  public:
1560   // creation
1561   CheckCast(ciKlass* klass, Value obj, ValueStack* state_before, bool never_null = false)
1562   : TypeCheck(klass, obj, objectType, state_before) {
1563     set_never_null(never_null);
1564   }
1565 
1566   void set_incompatible_class_change_check() {
1567     set_flag(ThrowIncompatibleClassChangeErrorFlag, true);
1568   }
1569   bool is_incompatible_class_change_check() const {
1570     return check_flag(ThrowIncompatibleClassChangeErrorFlag);
1571   }
1572   void set_invokespecial_receiver_check() {
1573     set_flag(InvokeSpecialReceiverCheckFlag, true);
1574   }
1575   bool is_invokespecial_receiver_check() const {
1576     return check_flag(InvokeSpecialReceiverCheckFlag);
1577   }
1578 
1579   virtual bool needs_exception_state() const {
1580     return !is_invokespecial_receiver_check();
1581   }
1582 
1583   ciType* declared_type() const;
1584 };
1585 
1586 
1587 LEAF(InstanceOf, TypeCheck)
1588  public:
1589   // creation
1590   InstanceOf(ciKlass* klass, Value obj, ValueStack* state_before) : TypeCheck(klass, obj, intType, state_before) {}
1591 
1592   virtual bool needs_exception_state() const     { return false; }
1593 };
1594 
1595 
1596 BASE(AccessMonitor, StateSplit)
1597  private:
1598   Value       _obj;
1599   int         _monitor_no;
1600 
1601  public:
1602   // creation
1603   AccessMonitor(Value obj, int monitor_no, ValueStack* state_before = NULL)
1604   : StateSplit(illegalType, state_before)
1605   , _obj(obj)
1606   , _monitor_no(monitor_no)
1607   {
1608     set_needs_null_check(true);
1609     ASSERT_VALUES
1610   }
1611 
1612   // accessors
1613   Value obj() const                              { return _obj; }
1614   int monitor_no() const                         { return _monitor_no; }
1615 
1616   // generic
1617   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1618 };
1619 
1620 
1621 LEAF(MonitorEnter, AccessMonitor)
1622   bool _maybe_valuetype;
1623  public:
1624   // creation
1625   MonitorEnter(Value obj, int monitor_no, ValueStack* state_before, bool maybe_valuetype)
1626   : AccessMonitor(obj, monitor_no, state_before)
1627   , _maybe_valuetype(maybe_valuetype)
1628   {
1629     ASSERT_VALUES
1630   }
1631 
1632   // accessors
1633   bool maybe_valuetype() const                   { return _maybe_valuetype; }
1634 
1635   // generic
1636   virtual bool can_trap() const                  { return true; }
1637 };
1638 
1639 
1640 LEAF(MonitorExit, AccessMonitor)
1641  public:
1642   // creation
1643   MonitorExit(Value obj, int monitor_no)
1644   : AccessMonitor(obj, monitor_no, NULL)
1645   {
1646     ASSERT_VALUES
1647   }
1648 };
1649 
1650 
1651 LEAF(Intrinsic, StateSplit)
1652  private:
1653   vmIntrinsics::ID _id;
1654   Values*          _args;
1655   Value            _recv;
1656   ArgsNonNullState _nonnull_state;
1657 
1658  public:
1659   // preserves_state can be set to true for Intrinsics
1660   // which are guaranteed to preserve register state across any slow
1661   // cases; setting it to true does not mean that the Intrinsic can
1662   // not trap, only that if we continue execution in the same basic
1663   // block after the Intrinsic, all of the registers are intact. This
1664   // allows load elimination and common expression elimination to be
1665   // performed across the Intrinsic.  The default value is false.
1666   Intrinsic(ValueType* type,
1667             vmIntrinsics::ID id,
1668             Values* args,
1669             bool has_receiver,
1670             ValueStack* state_before,
1671             bool preserves_state,
1672             bool cantrap = true)
1673   : StateSplit(type, state_before)
1674   , _id(id)
1675   , _args(args)
1676   , _recv(NULL)
1677   {
1678     assert(args != NULL, &quot;args must exist&quot;);
1679     ASSERT_VALUES
1680     set_flag(PreservesStateFlag, preserves_state);
1681     set_flag(CanTrapFlag,        cantrap);
1682     if (has_receiver) {
1683       _recv = argument_at(0);
1684     }
1685     set_needs_null_check(has_receiver);
1686 
1687     // some intrinsics can&#39;t trap, so don&#39;t force them to be pinned
1688     if (!can_trap() &amp;&amp; !vmIntrinsics::should_be_pinned(_id)) {
1689       unpin(PinStateSplitConstructor);
1690     }
1691   }
1692 
1693   // accessors
1694   vmIntrinsics::ID id() const                    { return _id; }
1695   int number_of_arguments() const                { return _args-&gt;length(); }
1696   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1697 
1698   bool has_receiver() const                      { return (_recv != NULL); }
1699   Value receiver() const                         { assert(has_receiver(), &quot;must have receiver&quot;); return _recv; }
1700   bool preserves_state() const                   { return check_flag(PreservesStateFlag); }
1701 
1702   bool arg_needs_null_check(int i) const {
1703     return _nonnull_state.arg_needs_null_check(i);
1704   }
1705 
1706   void set_arg_needs_null_check(int i, bool check) {
1707     _nonnull_state.set_arg_needs_null_check(i, check);
1708   }
1709 
1710   // generic
1711   virtual bool can_trap() const                  { return check_flag(CanTrapFlag); }
1712   virtual void input_values_do(ValueVisitor* f) {
1713     StateSplit::input_values_do(f);
1714     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
1715   }
1716 };
1717 
1718 
1719 class LIR_List;
1720 
1721 LEAF(BlockBegin, StateSplit)
1722  private:
1723   int        _block_id;                          // the unique block id
1724   int        _bci;                               // start-bci of block
1725   int        _depth_first_number;                // number of this block in a depth-first ordering
1726   int        _linear_scan_number;                // number of this block in linear-scan ordering
1727   int        _dominator_depth;
1728   int        _loop_depth;                        // the loop nesting level of this block
1729   int        _loop_index;                        // number of the innermost loop of this block
1730   int        _flags;                             // the flags associated with this block
1731 
1732   // fields used by BlockListBuilder
1733   int            _total_preds;                   // number of predecessors found by BlockListBuilder
1734   ResourceBitMap _stores_to_locals;              // bit is set when a local variable is stored in the block
1735 
1736   // SSA specific fields: (factor out later)
1737   BlockList   _successors;                       // the successors of this block
1738   BlockList   _predecessors;                     // the predecessors of this block
1739   BlockList   _dominates;                        // list of blocks that are dominated by this block
1740   BlockBegin* _dominator;                        // the dominator of this block
1741   // SSA specific ends
1742   BlockEnd*  _end;                               // the last instruction of this block
1743   BlockList  _exception_handlers;                // the exception handlers potentially invoked by this block
1744   ValueStackStack* _exception_states;            // only for xhandler entries: states of all instructions that have an edge to this xhandler
1745   int        _exception_handler_pco;             // if this block is the start of an exception handler,
1746                                                  // this records the PC offset in the assembly code of the
1747                                                  // first instruction in this block
1748   Label      _label;                             // the label associated with this block
1749   LIR_List*  _lir;                               // the low level intermediate representation for this block
1750 
1751   ResourceBitMap _live_in;                       // set of live LIR_Opr registers at entry to this block
1752   ResourceBitMap _live_out;                      // set of live LIR_Opr registers at exit from this block
1753   ResourceBitMap _live_gen;                      // set of registers used before any redefinition in this block
1754   ResourceBitMap _live_kill;                     // set of registers defined in this block
1755 
1756   ResourceBitMap _fpu_register_usage;
1757   intArray*      _fpu_stack_state;               // For x86 FPU code generation with UseLinearScan
1758   int            _first_lir_instruction_id;      // ID of first LIR instruction in this block
1759   int            _last_lir_instruction_id;       // ID of last LIR instruction in this block
1760 
1761   void iterate_preorder (boolArray&amp; mark, BlockClosure* closure);
1762   void iterate_postorder(boolArray&amp; mark, BlockClosure* closure);
1763 
1764   friend class SuxAndWeightAdjuster;
1765 
1766  public:
1767    void* operator new(size_t size) throw() {
1768     Compilation* c = Compilation::current();
1769     void* res = c-&gt;arena()-&gt;Amalloc(size);
1770     ((BlockBegin*)res)-&gt;_id = c-&gt;get_next_id();
1771     ((BlockBegin*)res)-&gt;_block_id = c-&gt;get_next_block_id();
1772     return res;
1773   }
1774 
1775   // initialization/counting
1776   static int  number_of_blocks() {
1777     return Compilation::current()-&gt;number_of_blocks();
1778   }
1779 
1780   // creation
1781   BlockBegin(int bci)
1782   : StateSplit(illegalType)
1783   , _bci(bci)
1784   , _depth_first_number(-1)
1785   , _linear_scan_number(-1)
1786   , _dominator_depth(-1)
1787   , _loop_depth(0)
1788   , _loop_index(-1)
1789   , _flags(0)
1790   , _total_preds(0)
1791   , _stores_to_locals()
1792   , _successors(2)
1793   , _predecessors(2)
1794   , _dominates(2)
1795   , _dominator(NULL)
1796   , _end(NULL)
1797   , _exception_handlers(1)
1798   , _exception_states(NULL)
1799   , _exception_handler_pco(-1)
1800   , _lir(NULL)
1801   , _live_in()
1802   , _live_out()
1803   , _live_gen()
1804   , _live_kill()
1805   , _fpu_register_usage()
1806   , _fpu_stack_state(NULL)
1807   , _first_lir_instruction_id(-1)
1808   , _last_lir_instruction_id(-1)
1809   {
1810     _block = this;
1811 #ifndef PRODUCT
1812     set_printable_bci(bci);
1813 #endif
1814   }
1815 
1816   // accessors
1817   int block_id() const                           { return _block_id; }
1818   int bci() const                                { return _bci; }
1819   BlockList* successors()                        { return &amp;_successors; }
1820   BlockList* dominates()                         { return &amp;_dominates; }
1821   BlockBegin* dominator() const                  { return _dominator; }
1822   int loop_depth() const                         { return _loop_depth; }
1823   int dominator_depth() const                    { return _dominator_depth; }
1824   int depth_first_number() const                 { return _depth_first_number; }
1825   int linear_scan_number() const                 { return _linear_scan_number; }
1826   BlockEnd* end() const                          { return _end; }
1827   Label* label()                                 { return &amp;_label; }
1828   LIR_List* lir() const                          { return _lir; }
1829   int exception_handler_pco() const              { return _exception_handler_pco; }
1830   ResourceBitMap&amp; live_in()                      { return _live_in;        }
1831   ResourceBitMap&amp; live_out()                     { return _live_out;       }
1832   ResourceBitMap&amp; live_gen()                     { return _live_gen;       }
1833   ResourceBitMap&amp; live_kill()                    { return _live_kill;      }
1834   ResourceBitMap&amp; fpu_register_usage()           { return _fpu_register_usage; }
1835   intArray* fpu_stack_state() const              { return _fpu_stack_state;    }
1836   int first_lir_instruction_id() const           { return _first_lir_instruction_id; }
1837   int last_lir_instruction_id() const            { return _last_lir_instruction_id; }
1838   int total_preds() const                        { return _total_preds; }
1839   BitMap&amp; stores_to_locals()                     { return _stores_to_locals; }
1840 
1841   // manipulation
1842   void set_dominator(BlockBegin* dom)            { _dominator = dom; }
1843   void set_loop_depth(int d)                     { _loop_depth = d; }
1844   void set_dominator_depth(int d)                { _dominator_depth = d; }
1845   void set_depth_first_number(int dfn)           { _depth_first_number = dfn; }
1846   void set_linear_scan_number(int lsn)           { _linear_scan_number = lsn; }
1847   void set_end(BlockEnd* end);
1848   void clear_end();
1849   void disconnect_from_graph();
1850   static void disconnect_edge(BlockBegin* from, BlockBegin* to);
1851   BlockBegin* insert_block_between(BlockBegin* sux);
1852   void substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux);
1853   void set_lir(LIR_List* lir)                    { _lir = lir; }
1854   void set_exception_handler_pco(int pco)        { _exception_handler_pco = pco; }
1855   void set_live_in  (const ResourceBitMap&amp; map)  { _live_in = map;   }
1856   void set_live_out (const ResourceBitMap&amp; map)  { _live_out = map;  }
1857   void set_live_gen (const ResourceBitMap&amp; map)  { _live_gen = map;  }
1858   void set_live_kill(const ResourceBitMap&amp; map)  { _live_kill = map; }
1859   void set_fpu_register_usage(const ResourceBitMap&amp; map) { _fpu_register_usage = map; }
1860   void set_fpu_stack_state(intArray* state)      { _fpu_stack_state = state;  }
1861   void set_first_lir_instruction_id(int id)      { _first_lir_instruction_id = id;  }
1862   void set_last_lir_instruction_id(int id)       { _last_lir_instruction_id = id;  }
1863   void increment_total_preds(int n = 1)          { _total_preds += n; }
1864   void init_stores_to_locals(int locals_count)   { _stores_to_locals.initialize(locals_count); }
1865 
1866   // generic
1867   virtual void state_values_do(ValueVisitor* f);
1868 
1869   // successors and predecessors
1870   int number_of_sux() const;
1871   BlockBegin* sux_at(int i) const;
1872   void add_successor(BlockBegin* sux);
1873   void remove_successor(BlockBegin* pred);
1874   bool is_successor(BlockBegin* sux) const       { return _successors.contains(sux); }
1875 
1876   void add_predecessor(BlockBegin* pred);
1877   void remove_predecessor(BlockBegin* pred);
1878   bool is_predecessor(BlockBegin* pred) const    { return _predecessors.contains(pred); }
1879   int number_of_preds() const                    { return _predecessors.length(); }
1880   BlockBegin* pred_at(int i) const               { return _predecessors.at(i); }
1881 
1882   // exception handlers potentially invoked by this block
1883   void add_exception_handler(BlockBegin* b);
1884   bool is_exception_handler(BlockBegin* b) const { return _exception_handlers.contains(b); }
1885   int  number_of_exception_handlers() const      { return _exception_handlers.length(); }
1886   BlockBegin* exception_handler_at(int i) const  { return _exception_handlers.at(i); }
1887 
1888   // states of the instructions that have an edge to this exception handler
1889   int number_of_exception_states()               { assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;); return _exception_states == NULL ? 0 : _exception_states-&gt;length(); }
1890   ValueStack* exception_state_at(int idx) const  { assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;); return _exception_states-&gt;at(idx); }
1891   int add_exception_state(ValueStack* state);
1892 
1893   // flags
1894   enum Flag {
1895     no_flag                       = 0,
1896     std_entry_flag                = 1 &lt;&lt; 0,
1897     osr_entry_flag                = 1 &lt;&lt; 1,
1898     exception_entry_flag          = 1 &lt;&lt; 2,
1899     subroutine_entry_flag         = 1 &lt;&lt; 3,
1900     backward_branch_target_flag   = 1 &lt;&lt; 4,
1901     is_on_work_list_flag          = 1 &lt;&lt; 5,
1902     was_visited_flag              = 1 &lt;&lt; 6,
1903     parser_loop_header_flag       = 1 &lt;&lt; 7,  // set by parser to identify blocks where phi functions can not be created on demand
1904     critical_edge_split_flag      = 1 &lt;&lt; 8, // set for all blocks that are introduced when critical edges are split
1905     linear_scan_loop_header_flag  = 1 &lt;&lt; 9, // set during loop-detection for LinearScan
1906     linear_scan_loop_end_flag     = 1 &lt;&lt; 10, // set during loop-detection for LinearScan
1907     donot_eliminate_range_checks  = 1 &lt;&lt; 11  // Should be try to eliminate range checks in this block
1908   };
1909 
1910   void set(Flag f)                               { _flags |= f; }
1911   void clear(Flag f)                             { _flags &amp;= ~f; }
1912   bool is_set(Flag f) const                      { return (_flags &amp; f) != 0; }
1913   bool is_entry_block() const {
1914     const int entry_mask = std_entry_flag | osr_entry_flag | exception_entry_flag;
1915     return (_flags &amp; entry_mask) != 0;
1916   }
1917 
1918   // iteration
1919   void iterate_preorder   (BlockClosure* closure);
1920   void iterate_postorder  (BlockClosure* closure);
1921 
1922   void block_values_do(ValueVisitor* f);
1923 
1924   // loops
1925   void set_loop_index(int ix)                    { _loop_index = ix;        }
1926   int  loop_index() const                        { return _loop_index;      }
1927 
1928   // merging
1929   bool try_merge(ValueStack* state);             // try to merge states at block begin
1930   void merge(ValueStack* state)                  { bool b = try_merge(state); assert(b, &quot;merge failed&quot;); }
1931 
1932   // debugging
1933   void print_block()                             PRODUCT_RETURN;
1934   void print_block(InstructionPrinter&amp; ip, bool live_only = false) PRODUCT_RETURN;
1935 };
1936 
1937 
1938 BASE(BlockEnd, StateSplit)
1939  private:
1940   BlockList*  _sux;
1941 
1942  protected:
1943   BlockList* sux() const                         { return _sux; }
1944 
1945   void set_sux(BlockList* sux) {
1946 #ifdef ASSERT
1947     assert(sux != NULL, &quot;sux must exist&quot;);
1948     for (int i = sux-&gt;length() - 1; i &gt;= 0; i--) assert(sux-&gt;at(i) != NULL, &quot;sux must exist&quot;);
1949 #endif
1950     _sux = sux;
1951   }
1952 
1953  public:
1954   // creation
1955   BlockEnd(ValueType* type, ValueStack* state_before, bool is_safepoint)
1956   : StateSplit(type, state_before)
1957   , _sux(NULL)
1958   {
1959     set_flag(IsSafepointFlag, is_safepoint);
1960   }
1961 
1962   // accessors
1963   bool is_safepoint() const                      { return check_flag(IsSafepointFlag); }
1964   // For compatibility with old code, for new code use block()
1965   BlockBegin* begin() const                      { return _block; }
1966 
1967   // manipulation
1968   void set_begin(BlockBegin* begin);
1969 
1970   // successors
1971   int number_of_sux() const                      { return _sux != NULL ? _sux-&gt;length() : 0; }
1972   BlockBegin* sux_at(int i) const                { return _sux-&gt;at(i); }
1973   BlockBegin* default_sux() const                { return sux_at(number_of_sux() - 1); }
1974   BlockBegin** addr_sux_at(int i) const          { return _sux-&gt;adr_at(i); }
1975   int sux_index(BlockBegin* sux) const           { return _sux-&gt;find(sux); }
1976   void substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux);
1977 };
1978 
1979 
1980 LEAF(Goto, BlockEnd)
1981  public:
1982   enum Direction {
1983     none,            // Just a regular goto
1984     taken, not_taken // Goto produced from If
1985   };
1986  private:
1987   ciMethod*   _profiled_method;
1988   int         _profiled_bci;
1989   Direction   _direction;
1990  public:
1991   // creation
1992   Goto(BlockBegin* sux, ValueStack* state_before, bool is_safepoint = false)
1993     : BlockEnd(illegalType, state_before, is_safepoint)
1994     , _profiled_method(NULL)
1995     , _profiled_bci(0)
1996     , _direction(none) {
1997     BlockList* s = new BlockList(1);
1998     s-&gt;append(sux);
1999     set_sux(s);
2000   }
2001 
2002   Goto(BlockBegin* sux, bool is_safepoint) : BlockEnd(illegalType, NULL, is_safepoint)
2003                                            , _profiled_method(NULL)
2004                                            , _profiled_bci(0)
2005                                            , _direction(none) {
2006     BlockList* s = new BlockList(1);
2007     s-&gt;append(sux);
2008     set_sux(s);
2009   }
2010 
2011   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
2012   ciMethod* profiled_method() const              { return _profiled_method; } // set only for profiled branches
2013   int profiled_bci() const                       { return _profiled_bci; }
2014   Direction direction() const                    { return _direction; }
2015 
2016   void set_should_profile(bool value)            { set_flag(ProfileMDOFlag, value); }
2017   void set_profiled_method(ciMethod* method)     { _profiled_method = method; }
2018   void set_profiled_bci(int bci)                 { _profiled_bci = bci; }
2019   void set_direction(Direction d)                { _direction = d; }
2020 };
2021 
2022 #ifdef ASSERT
2023 LEAF(Assert, Instruction)
2024   private:
2025   Value       _x;
2026   Condition   _cond;
2027   Value       _y;
2028   char        *_message;
2029 
2030  public:
2031   // creation
2032   // unordered_is_true is valid for float/double compares only
2033    Assert(Value x, Condition cond, bool unordered_is_true, Value y);
2034 
2035   // accessors
2036   Value x() const                                { return _x; }
2037   Condition cond() const                         { return _cond; }
2038   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2039   Value y() const                                { return _y; }
2040   const char *message() const                    { return _message; }
2041 
2042   // generic
2043   virtual void input_values_do(ValueVisitor* f)  { f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2044 };
2045 #endif
2046 
2047 LEAF(RangeCheckPredicate, StateSplit)
2048  private:
2049   Value       _x;
2050   Condition   _cond;
2051   Value       _y;
2052 
2053   void check_state();
2054 
2055  public:
2056   // creation
2057   // unordered_is_true is valid for float/double compares only
2058    RangeCheckPredicate(Value x, Condition cond, bool unordered_is_true, Value y, ValueStack* state) : StateSplit(illegalType)
2059   , _x(x)
2060   , _cond(cond)
2061   , _y(y)
2062   {
2063     ASSERT_VALUES
2064     set_flag(UnorderedIsTrueFlag, unordered_is_true);
2065     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
2066     this-&gt;set_state(state);
2067     check_state();
2068   }
2069 
2070   // Always deoptimize
2071   RangeCheckPredicate(ValueStack* state) : StateSplit(illegalType)
2072   {
2073     this-&gt;set_state(state);
2074     _x = _y = NULL;
2075     check_state();
2076   }
2077 
2078   // accessors
2079   Value x() const                                { return _x; }
2080   Condition cond() const                         { return _cond; }
2081   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2082   Value y() const                                { return _y; }
2083 
2084   void always_fail()                             { _x = _y = NULL; }
2085 
2086   // generic
2087   virtual void input_values_do(ValueVisitor* f)  { StateSplit::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2088   HASHING3(RangeCheckPredicate, true, x()-&gt;subst(), y()-&gt;subst(), cond())
2089 };
2090 
2091 LEAF(If, BlockEnd)
2092  private:
2093   Value       _x;
2094   Condition   _cond;
2095   Value       _y;
2096   ciMethod*   _profiled_method;
2097   int         _profiled_bci; // Canonicalizer may alter bci of If node
2098   bool        _swapped;      // Is the order reversed with respect to the original If in the
2099                              // bytecode stream?
2100   bool        _substitutability_check;
2101  public:
2102   // creation
2103   // unordered_is_true is valid for float/double compares only
2104   If(Value x, Condition cond, bool unordered_is_true, Value y, BlockBegin* tsux, BlockBegin* fsux, ValueStack* state_before, bool is_safepoint, bool substitutability_check=false)
2105     : BlockEnd(illegalType, state_before, is_safepoint)
2106   , _x(x)
2107   , _cond(cond)
2108   , _y(y)
2109   , _profiled_method(NULL)
2110   , _profiled_bci(0)
2111   , _swapped(false)
2112   , _substitutability_check(substitutability_check)
2113   {
2114     ASSERT_VALUES
2115     set_flag(UnorderedIsTrueFlag, unordered_is_true);
2116     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
2117     BlockList* s = new BlockList(2);
2118     s-&gt;append(tsux);
2119     s-&gt;append(fsux);
2120     set_sux(s);
2121   }
2122 
2123   // accessors
2124   Value x() const                                { return _x; }
2125   Condition cond() const                         { return _cond; }
2126   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2127   Value y() const                                { return _y; }
2128   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2129   BlockBegin* tsux() const                       { return sux_for(true); }
2130   BlockBegin* fsux() const                       { return sux_for(false); }
2131   BlockBegin* usux() const                       { return sux_for(unordered_is_true()); }
2132   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
2133   ciMethod* profiled_method() const              { return _profiled_method; } // set only for profiled branches
2134   int profiled_bci() const                       { return _profiled_bci; }    // set for profiled branches and tiered
2135   bool is_swapped() const                        { return _swapped; }
2136 
2137   // manipulation
2138   void swap_operands() {
2139     Value t = _x; _x = _y; _y = t;
2140     _cond = mirror(_cond);
2141   }
2142 
2143   void swap_sux() {
2144     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2145     BlockList* s = sux();
2146     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2147     _cond = negate(_cond);
2148     set_flag(UnorderedIsTrueFlag, !check_flag(UnorderedIsTrueFlag));
2149   }
2150 
2151   void set_should_profile(bool value)             { set_flag(ProfileMDOFlag, value); }
2152   void set_profiled_method(ciMethod* method)      { _profiled_method = method; }
2153   void set_profiled_bci(int bci)                  { _profiled_bci = bci;       }
2154   void set_swapped(bool value)                    { _swapped = value;         }
2155   bool substitutability_check() const              { return _substitutability_check; }
2156   // generic
2157   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2158 };
2159 
2160 
2161 LEAF(IfInstanceOf, BlockEnd)
2162  private:
2163   ciKlass* _klass;
2164   Value    _obj;
2165   bool     _test_is_instance;                    // jump if instance
2166   int      _instanceof_bci;
2167 
2168  public:
2169   IfInstanceOf(ciKlass* klass, Value obj, bool test_is_instance, int instanceof_bci, BlockBegin* tsux, BlockBegin* fsux)
2170   : BlockEnd(illegalType, NULL, false) // temporary set to false
2171   , _klass(klass)
2172   , _obj(obj)
2173   , _test_is_instance(test_is_instance)
2174   , _instanceof_bci(instanceof_bci)
2175   {
2176     ASSERT_VALUES
2177     assert(instanceof_bci &gt;= 0, &quot;illegal bci&quot;);
2178     BlockList* s = new BlockList(2);
2179     s-&gt;append(tsux);
2180     s-&gt;append(fsux);
2181     set_sux(s);
2182   }
2183 
2184   // accessors
2185   //
2186   // Note 1: If test_is_instance() is true, IfInstanceOf tests if obj *is* an
2187   //         instance of klass; otherwise it tests if it is *not* and instance
2188   //         of klass.
2189   //
2190   // Note 2: IfInstanceOf instructions are created by combining an InstanceOf
2191   //         and an If instruction. The IfInstanceOf bci() corresponds to the
2192   //         bci that the If would have had; the (this-&gt;) instanceof_bci() is
2193   //         the bci of the original InstanceOf instruction.
2194   ciKlass* klass() const                         { return _klass; }
2195   Value obj() const                              { return _obj; }
2196   int instanceof_bci() const                     { return _instanceof_bci; }
2197   bool test_is_instance() const                  { return _test_is_instance; }
2198   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2199   BlockBegin* tsux() const                       { return sux_for(true); }
2200   BlockBegin* fsux() const                       { return sux_for(false); }
2201 
2202   // manipulation
2203   void swap_sux() {
2204     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2205     BlockList* s = sux();
2206     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2207     _test_is_instance = !_test_is_instance;
2208   }
2209 
2210   // generic
2211   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_obj); }
2212 };
2213 
2214 
2215 BASE(Switch, BlockEnd)
2216  private:
2217   Value       _tag;
2218 
2219  public:
2220   // creation
2221   Switch(Value tag, BlockList* sux, ValueStack* state_before, bool is_safepoint)
2222   : BlockEnd(illegalType, state_before, is_safepoint)
2223   , _tag(tag) {
2224     ASSERT_VALUES
2225     set_sux(sux);
2226   }
2227 
2228   // accessors
2229   Value tag() const                              { return _tag; }
2230   int length() const                             { return number_of_sux() - 1; }
2231 
2232   virtual bool needs_exception_state() const     { return false; }
2233 
2234   // generic
2235   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_tag); }
2236 };
2237 
2238 
2239 LEAF(TableSwitch, Switch)
2240  private:
2241   int _lo_key;
2242 
2243  public:
2244   // creation
2245   TableSwitch(Value tag, BlockList* sux, int lo_key, ValueStack* state_before, bool is_safepoint)
2246     : Switch(tag, sux, state_before, is_safepoint)
2247   , _lo_key(lo_key) { assert(_lo_key &lt;= hi_key(), &quot;integer overflow&quot;); }
2248 
2249   // accessors
2250   int lo_key() const                             { return _lo_key; }
2251   int hi_key() const                             { return _lo_key + (length() - 1); }
2252 };
2253 
2254 
2255 LEAF(LookupSwitch, Switch)
2256  private:
2257   intArray* _keys;
2258 
2259  public:
2260   // creation
2261   LookupSwitch(Value tag, BlockList* sux, intArray* keys, ValueStack* state_before, bool is_safepoint)
2262   : Switch(tag, sux, state_before, is_safepoint)
2263   , _keys(keys) {
2264     assert(keys != NULL, &quot;keys must exist&quot;);
2265     assert(keys-&gt;length() == length(), &quot;sux &amp; keys have incompatible lengths&quot;);
2266   }
2267 
2268   // accessors
2269   int key_at(int i) const                        { return _keys-&gt;at(i); }
2270 };
2271 
2272 
2273 LEAF(Return, BlockEnd)
2274  private:
2275   Value _result;
2276 
2277  public:
2278   // creation
2279   Return(Value result) :
2280     BlockEnd(result == NULL ? voidType : result-&gt;type()-&gt;base(), NULL, true),
2281     _result(result) {}
2282 
2283   // accessors
2284   Value result() const                           { return _result; }
2285   bool has_result() const                        { return result() != NULL; }
2286 
2287   // generic
2288   virtual void input_values_do(ValueVisitor* f) {
2289     BlockEnd::input_values_do(f);
2290     if (has_result()) f-&gt;visit(&amp;_result);
2291   }
2292 };
2293 
2294 
2295 LEAF(Throw, BlockEnd)
2296  private:
2297   Value _exception;
2298 
2299  public:
2300   // creation
2301   Throw(Value exception, ValueStack* state_before) : BlockEnd(illegalType, state_before, true), _exception(exception) {
2302     ASSERT_VALUES
2303   }
2304 
2305   // accessors
2306   Value exception() const                        { return _exception; }
2307 
2308   // generic
2309   virtual bool can_trap() const                  { return true; }
2310   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_exception); }
2311 };
2312 
2313 
2314 LEAF(Base, BlockEnd)
2315  public:
2316   // creation
2317   Base(BlockBegin* std_entry, BlockBegin* osr_entry) : BlockEnd(illegalType, NULL, false) {
2318     assert(std_entry-&gt;is_set(BlockBegin::std_entry_flag), &quot;std entry must be flagged&quot;);
2319     assert(osr_entry == NULL || osr_entry-&gt;is_set(BlockBegin::osr_entry_flag), &quot;osr entry must be flagged&quot;);
2320     BlockList* s = new BlockList(2);
2321     if (osr_entry != NULL) s-&gt;append(osr_entry);
2322     s-&gt;append(std_entry); // must be default sux!
2323     set_sux(s);
2324   }
2325 
2326   // accessors
2327   BlockBegin* std_entry() const                  { return default_sux(); }
2328   BlockBegin* osr_entry() const                  { return number_of_sux() &lt; 2 ? NULL : sux_at(0); }
2329 };
2330 
2331 
2332 LEAF(OsrEntry, Instruction)
2333  public:
2334   // creation
2335 #ifdef _LP64
2336   OsrEntry() : Instruction(longType) { pin(); }
2337 #else
2338   OsrEntry() : Instruction(intType)  { pin(); }
2339 #endif
2340 
2341   // generic
2342   virtual void input_values_do(ValueVisitor* f)   { }
2343 };
2344 
2345 
2346 // Models the incoming exception at a catch site
2347 LEAF(ExceptionObject, Instruction)
2348  public:
2349   // creation
2350   ExceptionObject() : Instruction(objectType) {
2351     pin();
2352   }
2353 
2354   // generic
2355   virtual void input_values_do(ValueVisitor* f)   { }
2356 };
2357 
2358 
2359 // Models needed rounding for floating-point values on Intel.
2360 // Currently only used to represent rounding of double-precision
2361 // values stored into local variables, but could be used to model
2362 // intermediate rounding of single-precision values as well.
2363 LEAF(RoundFP, Instruction)
2364  private:
2365   Value _input;             // floating-point value to be rounded
2366 
2367  public:
2368   RoundFP(Value input)
2369   : Instruction(input-&gt;type()) // Note: should not be used for constants
2370   , _input(input)
2371   {
2372     ASSERT_VALUES
2373   }
2374 
2375   // accessors
2376   Value input() const                            { return _input; }
2377 
2378   // generic
2379   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_input); }
2380 };
2381 
2382 
2383 BASE(UnsafeOp, Instruction)
2384  private:
2385   BasicType _basic_type;    // ValueType can not express byte-sized integers
2386 
2387  protected:
2388   // creation
2389   UnsafeOp(BasicType basic_type, bool is_put)
2390   : Instruction(is_put ? voidType : as_ValueType(basic_type))
2391   , _basic_type(basic_type)
2392   {
2393     //Note:  Unsafe ops are not not guaranteed to throw NPE.
2394     // Convservatively, Unsafe operations must be pinned though we could be
2395     // looser about this if we wanted to..
2396     pin();
2397   }
2398 
2399  public:
2400   // accessors
2401   BasicType basic_type()                         { return _basic_type; }
2402 
2403   // generic
2404   virtual void input_values_do(ValueVisitor* f)   { }
2405 };
2406 
2407 
2408 BASE(UnsafeRawOp, UnsafeOp)
2409  private:
2410   Value _base;                                   // Base address (a Java long)
2411   Value _index;                                  // Index if computed by optimizer; initialized to NULL
2412   int   _log2_scale;                             // Scale factor: 0, 1, 2, or 3.
2413                                                  // Indicates log2 of number of bytes (1, 2, 4, or 8)
2414                                                  // to scale index by.
2415 
2416  protected:
2417   UnsafeRawOp(BasicType basic_type, Value addr, bool is_put)
2418   : UnsafeOp(basic_type, is_put)
2419   , _base(addr)
2420   , _index(NULL)
2421   , _log2_scale(0)
2422   {
2423     // Can not use ASSERT_VALUES because index may be NULL
2424     assert(addr != NULL &amp;&amp; addr-&gt;type()-&gt;is_long(), &quot;just checking&quot;);
2425   }
2426 
2427   UnsafeRawOp(BasicType basic_type, Value base, Value index, int log2_scale, bool is_put)
2428   : UnsafeOp(basic_type, is_put)
2429   , _base(base)
2430   , _index(index)
2431   , _log2_scale(log2_scale)
2432   {
2433   }
2434 
2435  public:
2436   // accessors
2437   Value base()                                   { return _base; }
2438   Value index()                                  { return _index; }
2439   bool  has_index()                              { return (_index != NULL); }
2440   int   log2_scale()                             { return _log2_scale; }
2441 
2442   // setters
2443   void set_base (Value base)                     { _base  = base; }
2444   void set_index(Value index)                    { _index = index; }
2445   void set_log2_scale(int log2_scale)            { _log2_scale = log2_scale; }
2446 
2447   // generic
2448   virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);
2449                                                    f-&gt;visit(&amp;_base);
2450                                                    if (has_index()) f-&gt;visit(&amp;_index); }
2451 };
2452 
2453 
2454 LEAF(UnsafeGetRaw, UnsafeRawOp)
2455  private:
2456  bool _may_be_unaligned, _is_wide;  // For OSREntry
2457 
2458  public:
2459  UnsafeGetRaw(BasicType basic_type, Value addr, bool may_be_unaligned, bool is_wide = false)
2460   : UnsafeRawOp(basic_type, addr, false) {
2461     _may_be_unaligned = may_be_unaligned;
2462     _is_wide = is_wide;
2463   }
2464 
2465  UnsafeGetRaw(BasicType basic_type, Value base, Value index, int log2_scale, bool may_be_unaligned, bool is_wide = false)
2466   : UnsafeRawOp(basic_type, base, index, log2_scale, false) {
2467     _may_be_unaligned = may_be_unaligned;
2468     _is_wide = is_wide;
2469   }
2470 
2471   bool may_be_unaligned()                         { return _may_be_unaligned; }
2472   bool is_wide()                                  { return _is_wide; }
2473 };
2474 
2475 
2476 LEAF(UnsafePutRaw, UnsafeRawOp)
2477  private:
2478   Value _value;                                  // Value to be stored
2479 
2480  public:
2481   UnsafePutRaw(BasicType basic_type, Value addr, Value value)
2482   : UnsafeRawOp(basic_type, addr, true)
2483   , _value(value)
2484   {
2485     assert(value != NULL, &quot;just checking&quot;);
2486     ASSERT_VALUES
2487   }
2488 
2489   UnsafePutRaw(BasicType basic_type, Value base, Value index, int log2_scale, Value value)
2490   : UnsafeRawOp(basic_type, base, index, log2_scale, true)
2491   , _value(value)
2492   {
2493     assert(value != NULL, &quot;just checking&quot;);
2494     ASSERT_VALUES
2495   }
2496 
2497   // accessors
2498   Value value()                                  { return _value; }
2499 
2500   // generic
2501   virtual void input_values_do(ValueVisitor* f)   { UnsafeRawOp::input_values_do(f);
2502                                                    f-&gt;visit(&amp;_value); }
2503 };
2504 
2505 
2506 BASE(UnsafeObjectOp, UnsafeOp)
2507  private:
2508   Value _object;                                 // Object to be fetched from or mutated
2509   Value _offset;                                 // Offset within object
2510   bool  _is_volatile;                            // true if volatile - dl/JSR166
2511  public:
2512   UnsafeObjectOp(BasicType basic_type, Value object, Value offset, bool is_put, bool is_volatile)
2513     : UnsafeOp(basic_type, is_put), _object(object), _offset(offset), _is_volatile(is_volatile)
2514   {
2515   }
2516 
2517   // accessors
2518   Value object()                                 { return _object; }
2519   Value offset()                                 { return _offset; }
2520   bool  is_volatile()                            { return _is_volatile; }
2521   // generic
2522   virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);
2523                                                    f-&gt;visit(&amp;_object);
2524                                                    f-&gt;visit(&amp;_offset); }
2525 };
2526 
2527 
2528 LEAF(UnsafeGetObject, UnsafeObjectOp)
2529  public:
2530   UnsafeGetObject(BasicType basic_type, Value object, Value offset, bool is_volatile)
2531   : UnsafeObjectOp(basic_type, object, offset, false, is_volatile)
2532   {
2533     ASSERT_VALUES
2534   }
2535 };
2536 
2537 
2538 LEAF(UnsafePutObject, UnsafeObjectOp)
2539  private:
2540   Value _value;                                  // Value to be stored
2541  public:
2542   UnsafePutObject(BasicType basic_type, Value object, Value offset, Value value, bool is_volatile)
2543   : UnsafeObjectOp(basic_type, object, offset, true, is_volatile)
2544     , _value(value)
2545   {
2546     ASSERT_VALUES
2547   }
2548 
2549   // accessors
2550   Value value()                                  { return _value; }
2551 
2552   // generic
2553   virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);
2554                                                    f-&gt;visit(&amp;_value); }
2555 };
2556 
2557 LEAF(UnsafeGetAndSetObject, UnsafeObjectOp)
2558  private:
2559   Value _value;                                  // Value to be stored
2560   bool  _is_add;
2561  public:
2562   UnsafeGetAndSetObject(BasicType basic_type, Value object, Value offset, Value value, bool is_add)
2563   : UnsafeObjectOp(basic_type, object, offset, false, false)
2564     , _value(value)
2565     , _is_add(is_add)
2566   {
2567     ASSERT_VALUES
2568   }
2569 
2570   // accessors
2571   bool is_add() const                            { return _is_add; }
2572   Value value()                                  { return _value; }
2573 
2574   // generic
2575   virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);
2576                                                    f-&gt;visit(&amp;_value); }
2577 };
2578 
2579 LEAF(ProfileCall, Instruction)
2580  private:
2581   ciMethod*        _method;
2582   int              _bci_of_invoke;
2583   ciMethod*        _callee;         // the method that is called at the given bci
2584   Value            _recv;
2585   ciKlass*         _known_holder;
2586   Values*          _obj_args;       // arguments for type profiling
2587   ArgsNonNullState _nonnull_state;  // Do we know whether some arguments are never null?
2588   bool             _inlined;        // Are we profiling a call that is inlined
2589 
2590  public:
2591   ProfileCall(ciMethod* method, int bci, ciMethod* callee, Value recv, ciKlass* known_holder, Values* obj_args, bool inlined)
2592     : Instruction(voidType)
2593     , _method(method)
2594     , _bci_of_invoke(bci)
2595     , _callee(callee)
2596     , _recv(recv)
2597     , _known_holder(known_holder)
2598     , _obj_args(obj_args)
2599     , _inlined(inlined)
2600   {
2601     // The ProfileCall has side-effects and must occur precisely where located
2602     pin();
2603   }
2604 
2605   ciMethod* method()             const { return _method; }
2606   int bci_of_invoke()            const { return _bci_of_invoke; }
2607   ciMethod* callee()             const { return _callee; }
2608   Value recv()                   const { return _recv; }
2609   ciKlass* known_holder()        const { return _known_holder; }
2610   int nb_profiled_args()         const { return _obj_args == NULL ? 0 : _obj_args-&gt;length(); }
2611   Value profiled_arg_at(int i)   const { return _obj_args-&gt;at(i); }
2612   bool arg_needs_null_check(int i) const {
2613     return _nonnull_state.arg_needs_null_check(i);
2614   }
2615   bool inlined()                 const { return _inlined; }
2616 
2617   void set_arg_needs_null_check(int i, bool check) {
2618     _nonnull_state.set_arg_needs_null_check(i, check);
2619   }
2620 
2621   virtual void input_values_do(ValueVisitor* f)   {
2622     if (_recv != NULL) {
2623       f-&gt;visit(&amp;_recv);
2624     }
2625     for (int i = 0; i &lt; nb_profiled_args(); i++) {
2626       f-&gt;visit(_obj_args-&gt;adr_at(i));
2627     }
2628   }
2629 };
2630 
2631 LEAF(ProfileReturnType, Instruction)
2632  private:
2633   ciMethod*        _method;
2634   ciMethod*        _callee;
2635   int              _bci_of_invoke;
2636   Value            _ret;
2637 
2638  public:
2639   ProfileReturnType(ciMethod* method, int bci, ciMethod* callee, Value ret)
2640     : Instruction(voidType)
2641     , _method(method)
2642     , _callee(callee)
2643     , _bci_of_invoke(bci)
2644     , _ret(ret)
2645   {
2646     set_needs_null_check(true);
2647     // The ProfileType has side-effects and must occur precisely where located
2648     pin();
2649   }
2650 
2651   ciMethod* method()             const { return _method; }
2652   ciMethod* callee()             const { return _callee; }
2653   int bci_of_invoke()            const { return _bci_of_invoke; }
2654   Value ret()                    const { return _ret; }
2655 
2656   virtual void input_values_do(ValueVisitor* f)   {
2657     if (_ret != NULL) {
2658       f-&gt;visit(&amp;_ret);
2659     }
2660   }
2661 };
2662 
2663 // Call some C runtime function that doesn&#39;t safepoint,
2664 // optionally passing the current thread as the first argument.
2665 LEAF(RuntimeCall, Instruction)
2666  private:
2667   const char* _entry_name;
2668   address     _entry;
2669   Values*     _args;
2670   bool        _pass_thread;  // Pass the JavaThread* as an implicit first argument
2671 
2672  public:
2673   RuntimeCall(ValueType* type, const char* entry_name, address entry, Values* args, bool pass_thread = true)
2674     : Instruction(type)
2675     , _entry_name(entry_name)
2676     , _entry(entry)
2677     , _args(args)
2678     , _pass_thread(pass_thread) {
2679     ASSERT_VALUES
2680     pin();
2681   }
2682 
2683   const char* entry_name() const  { return _entry_name; }
2684   address entry() const           { return _entry; }
2685   int number_of_arguments() const { return _args-&gt;length(); }
2686   Value argument_at(int i) const  { return _args-&gt;at(i); }
2687   bool pass_thread() const        { return _pass_thread; }
2688 
2689   virtual void input_values_do(ValueVisitor* f)   {
2690     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
2691   }
2692 };
2693 
2694 // Use to trip invocation counter of an inlined method
2695 
2696 LEAF(ProfileInvoke, Instruction)
2697  private:
2698   ciMethod*   _inlinee;
2699   ValueStack* _state;
2700 
2701  public:
2702   ProfileInvoke(ciMethod* inlinee,  ValueStack* state)
2703     : Instruction(voidType)
2704     , _inlinee(inlinee)
2705     , _state(state)
2706   {
2707     // The ProfileInvoke has side-effects and must occur precisely where located QQQ???
2708     pin();
2709   }
2710 
2711   ciMethod* inlinee()      { return _inlinee; }
2712   ValueStack* state()      { return _state; }
2713   virtual void input_values_do(ValueVisitor*)   {}
2714   virtual void state_values_do(ValueVisitor*);
2715 };
2716 
2717 LEAF(MemBar, Instruction)
2718  private:
2719   LIR_Code _code;
2720 
2721  public:
2722   MemBar(LIR_Code code)
2723     : Instruction(voidType)
2724     , _code(code)
2725   {
2726     pin();
2727   }
2728 
2729   LIR_Code code()           { return _code; }
2730 
2731   virtual void input_values_do(ValueVisitor*)   {}
2732 };
2733 
2734 class BlockPair: public CompilationResourceObj {
2735  private:
2736   BlockBegin* _from;
2737   BlockBegin* _to;
2738  public:
2739   BlockPair(BlockBegin* from, BlockBegin* to): _from(from), _to(to) {}
2740   BlockBegin* from() const { return _from; }
2741   BlockBegin* to() const   { return _to;   }
2742   bool is_same(BlockBegin* from, BlockBegin* to) const { return  _from == from &amp;&amp; _to == to; }
2743   bool is_same(BlockPair* p) const { return  _from == p-&gt;from() &amp;&amp; _to == p-&gt;to(); }
2744   void set_to(BlockBegin* b)   { _to = b; }
2745   void set_from(BlockBegin* b) { _from = b; }
2746 };
2747 
2748 typedef GrowableArray&lt;BlockPair*&gt; BlockPairList;
2749 
2750 inline int         BlockBegin::number_of_sux() const            { assert(_end == NULL || _end-&gt;number_of_sux() == _successors.length(), &quot;mismatch&quot;); return _successors.length(); }
2751 inline BlockBegin* BlockBegin::sux_at(int i) const              { assert(_end == NULL || _end-&gt;sux_at(i) == _successors.at(i), &quot;mismatch&quot;);          return _successors.at(i); }
2752 inline void        BlockBegin::add_successor(BlockBegin* sux)   { assert(_end == NULL, &quot;Would create mismatch with successors of BlockEnd&quot;);         _successors.append(sux); }
2753 
2754 #undef ASSERT_VALUES
2755 
2756 #endif // SHARE_C1_C1_INSTRUCTION_HPP
    </pre>
  </body>
</html>
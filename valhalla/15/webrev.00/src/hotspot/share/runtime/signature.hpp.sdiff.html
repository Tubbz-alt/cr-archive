<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/signature.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="signature.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/signature.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
610       return -1;
611     }
612     ShouldNotReachHere();
613     return 0;
614   }
615   static void add_entry(GrowableArray&lt;SigEntry&gt;* sig, BasicType bt, int offset = -1);
616   static void insert_reserved_entry(GrowableArray&lt;SigEntry&gt;* sig, int i, BasicType bt);
617   static bool is_reserved_entry(const GrowableArray&lt;SigEntry&gt;* sig, int i);
618   static bool skip_value_delimiters(const GrowableArray&lt;SigEntry&gt;* sig, int i);
619   static int fill_sig_bt(const GrowableArray&lt;SigEntry&gt;* sig, BasicType* sig_bt);
620   static TempNewSymbol create_symbol(const GrowableArray&lt;SigEntry&gt;* sig);
621 
622   static bool next_is_reserved(ExtendedSignature&amp; sig, BasicType&amp; bt, bool can_be_void = false);
623 };
624 
625 class SigEntryFilter {
626 public:
627   bool operator()(const SigEntry&amp; entry) { return entry._bt != T_VALUETYPE &amp;&amp; entry._bt != T_VOID; }
628 };
629 














































630 // Here is how all the SignatureIterator classes invoke the
631 // SignatureStream engine to do their parsing.
632 template&lt;typename T&gt; inline
633 void SignatureIterator::do_parameters_on(T* callback) {
634   fingerprint_t unaccumulator = _fingerprint;
635 
636   // Check for too many arguments, or missing fingerprint:
637   if (!fp_is_valid(unaccumulator)) {
638     SignatureStream ss(_signature);
639     for (; !ss.at_return_type(); ss.next()) {
640       callback-&gt;do_type(ss.type());
641     }
642     // while we are here, capture the return type
643     _return_type = ss.type();
644   } else {
645     // Optimized version of do_parameters when fingerprint is known
646     assert(_return_type != T_ILLEGAL, &quot;return type already captured from fp&quot;);
647     unaccumulator = fp_start_parameters(unaccumulator);
648     for (BasicType type; (type = fp_next_parameter(unaccumulator)) != (BasicType)fp_parameters_done; ) {
649       assert(fp_is_valid_type(type), &quot;garbled fingerprint&quot;);
</pre>
</td>
<td>
<hr />
<pre>
610       return -1;
611     }
612     ShouldNotReachHere();
613     return 0;
614   }
615   static void add_entry(GrowableArray&lt;SigEntry&gt;* sig, BasicType bt, int offset = -1);
616   static void insert_reserved_entry(GrowableArray&lt;SigEntry&gt;* sig, int i, BasicType bt);
617   static bool is_reserved_entry(const GrowableArray&lt;SigEntry&gt;* sig, int i);
618   static bool skip_value_delimiters(const GrowableArray&lt;SigEntry&gt;* sig, int i);
619   static int fill_sig_bt(const GrowableArray&lt;SigEntry&gt;* sig, BasicType* sig_bt);
620   static TempNewSymbol create_symbol(const GrowableArray&lt;SigEntry&gt;* sig);
621 
622   static bool next_is_reserved(ExtendedSignature&amp; sig, BasicType&amp; bt, bool can_be_void = false);
623 };
624 
625 class SigEntryFilter {
626 public:
627   bool operator()(const SigEntry&amp; entry) { return entry._bt != T_VALUETYPE &amp;&amp; entry._bt != T_VOID; }
628 };
629 
<span class="line-added">630 // Specialized SignatureStream: used for invoking SystemDictionary to either find</span>
<span class="line-added">631 //                              or resolve the underlying type when iterating over a</span>
<span class="line-added">632 //                              Java descriptor (or parts of it).</span>
<span class="line-added">633 class ResolvingSignatureStream : public SignatureStream {</span>
<span class="line-added">634   Klass*       _load_origin;</span>
<span class="line-added">635   bool         _handles_cached;</span>
<span class="line-added">636   Handle       _class_loader;       // cached when needed</span>
<span class="line-added">637   Handle       _protection_domain;  // cached when needed</span>
<span class="line-added">638 </span>
<span class="line-added">639   void initialize_load_origin(Klass* load_origin) {</span>
<span class="line-added">640     _load_origin = load_origin;</span>
<span class="line-added">641     _handles_cached = (load_origin == NULL);</span>
<span class="line-added">642   }</span>
<span class="line-added">643   void need_handles(TRAPS) {</span>
<span class="line-added">644     if (!_handles_cached) {</span>
<span class="line-added">645       cache_handles(THREAD);</span>
<span class="line-added">646       _handles_cached = true;</span>
<span class="line-added">647     }</span>
<span class="line-added">648   }</span>
<span class="line-added">649   void cache_handles(TRAPS);</span>
<span class="line-added">650 </span>
<span class="line-added">651  public:</span>
<span class="line-added">652   ResolvingSignatureStream(Symbol* signature, Klass* load_origin, bool is_method = true);</span>
<span class="line-added">653   ResolvingSignatureStream(Symbol* signature, Handle class_loader, Handle protection_domain, bool is_method = true);</span>
<span class="line-added">654   ResolvingSignatureStream(const Method* method);</span>
<span class="line-added">655   ResolvingSignatureStream(fieldDescriptor&amp; field);</span>
<span class="line-added">656 </span>
<span class="line-added">657   Klass* load_origin()            { return _load_origin; }</span>
<span class="line-added">658   Handle class_loader(TRAPS)      { need_handles(THREAD); return _class_loader; }</span>
<span class="line-added">659   Handle protection_domain(TRAPS) { need_handles(THREAD); return _protection_domain; }</span>
<span class="line-added">660 </span>
<span class="line-added">661   Klass* as_klass_if_loaded(TRAPS);</span>
<span class="line-added">662   Klass* as_klass(FailureMode failure_mode, TRAPS) {</span>
<span class="line-added">663     need_handles(THREAD);</span>
<span class="line-added">664     return SignatureStream::as_klass(_class_loader, _protection_domain,</span>
<span class="line-added">665                                      failure_mode, THREAD);</span>
<span class="line-added">666   }</span>
<span class="line-added">667   oop as_java_mirror(FailureMode failure_mode, TRAPS) {</span>
<span class="line-added">668     if (is_reference()) {</span>
<span class="line-added">669       need_handles(THREAD);</span>
<span class="line-added">670     }</span>
<span class="line-added">671     return SignatureStream::as_java_mirror(_class_loader, _protection_domain,</span>
<span class="line-added">672                                            failure_mode, THREAD);</span>
<span class="line-added">673   }</span>
<span class="line-added">674 };</span>
<span class="line-added">675 </span>
676 // Here is how all the SignatureIterator classes invoke the
677 // SignatureStream engine to do their parsing.
678 template&lt;typename T&gt; inline
679 void SignatureIterator::do_parameters_on(T* callback) {
680   fingerprint_t unaccumulator = _fingerprint;
681 
682   // Check for too many arguments, or missing fingerprint:
683   if (!fp_is_valid(unaccumulator)) {
684     SignatureStream ss(_signature);
685     for (; !ss.at_return_type(); ss.next()) {
686       callback-&gt;do_type(ss.type());
687     }
688     // while we are here, capture the return type
689     _return_type = ss.type();
690   } else {
691     // Optimized version of do_parameters when fingerprint is known
692     assert(_return_type != T_ILLEGAL, &quot;return type already captured from fp&quot;);
693     unaccumulator = fp_start_parameters(unaccumulator);
694     for (BasicType type; (type = fp_next_parameter(unaccumulator)) != (BasicType)fp_parameters_done; ) {
695       assert(fp_is_valid_type(type), &quot;garbled fingerprint&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="signature.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
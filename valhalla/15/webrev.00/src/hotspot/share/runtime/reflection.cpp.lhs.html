<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/reflection.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/moduleEntry.hpp&quot;
  29 #include &quot;classfile/packageEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/verifier.hpp&quot;
  33 #include &quot;classfile/vmSymbols.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/oopFactory.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;memory/universe.hpp&quot;
  39 #include &quot;oops/instanceKlass.hpp&quot;
  40 #include &quot;oops/objArrayKlass.hpp&quot;
  41 #include &quot;oops/objArrayOop.inline.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;oops/valueKlass.inline.hpp&quot;
  44 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  45 #include &quot;prims/jvmtiExport.hpp&quot;
  46 #include &quot;runtime/arguments.hpp&quot;
  47 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  48 #include &quot;runtime/handles.inline.hpp&quot;
  49 #include &quot;runtime/javaCalls.hpp&quot;
  50 #include &quot;runtime/reflection.hpp&quot;
  51 #include &quot;runtime/reflectionUtils.hpp&quot;
  52 #include &quot;runtime/signature.hpp&quot;
  53 #include &quot;runtime/thread.inline.hpp&quot;
  54 #include &quot;runtime/vframe.inline.hpp&quot;
  55 #include &quot;utilities/globalDefinitions.hpp&quot;
  56 
<a name="1" id="anc1"></a><span class="line-modified">  57 static void trace_class_resolution(const Klass* to_class) {</span>




  58   ResourceMark rm;
  59   int line_number = -1;
  60   const char * source_file = NULL;
  61   Klass* caller = NULL;
  62   JavaThread* jthread = JavaThread::current();
  63   if (jthread-&gt;has_last_Java_frame()) {
  64     vframeStream vfst(jthread);
  65     // skip over any frames belonging to java.lang.Class
  66     while (!vfst.at_end() &amp;&amp;
  67            vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class()) {
  68       vfst.next();
  69     }
  70     if (!vfst.at_end()) {
  71       // this frame is a likely suspect
  72       caller = vfst.method()-&gt;method_holder();
  73       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
  74       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
  75       if (s != NULL) {
  76         source_file = s-&gt;as_C_string();
  77       }
  78     }
  79   }
  80   if (caller != NULL) {
  81     const char * from = caller-&gt;external_name();
  82     const char * to = to_class-&gt;external_name();
  83     // print in a single call to reduce interleaving between threads
  84     if (source_file != NULL) {
  85       log_debug(class, resolve)(&quot;%s %s %s:%d (reflection)&quot;, from, to, source_file, line_number);
  86     } else {
  87       log_debug(class, resolve)(&quot;%s %s (reflection)&quot;, from, to);
  88     }
  89   }
  90 }
  91 
  92 
  93 oop Reflection::box(jvalue* value, BasicType type, TRAPS) {
  94   if (type == T_VOID) {
  95     return NULL;
  96   }
  97   if (is_reference_type(type)) {
  98     // regular objects are not boxed
  99     return (oop) value-&gt;l;
 100   }
 101   oop result = java_lang_boxing_object::create(type, value, CHECK_NULL);
 102   if (result == NULL) {
 103     THROW_(vmSymbols::java_lang_IllegalArgumentException(), result);
 104   }
 105   return result;
 106 }
 107 
 108 
 109 BasicType Reflection::unbox_for_primitive(oop box, jvalue* value, TRAPS) {
 110   if (box == NULL) {
 111     THROW_(vmSymbols::java_lang_IllegalArgumentException(), T_ILLEGAL);
 112   }
 113   return java_lang_boxing_object::get_value(box, value);
 114 }
 115 
 116 BasicType Reflection::unbox_for_regular_object(oop box, jvalue* value) {
 117   // Note:  box is really the unboxed oop.  It might even be a Short, etc.!
 118   value-&gt;l = cast_from_oop&lt;jobject&gt;(box);
 119   return T_OBJECT;
 120 }
 121 
 122 
 123 void Reflection::widen(jvalue* value, BasicType current_type, BasicType wide_type, TRAPS) {
 124   assert(wide_type != current_type, &quot;widen should not be called with identical types&quot;);
 125   switch (wide_type) {
 126     case T_BOOLEAN:
 127     case T_BYTE:
 128     case T_CHAR:
 129       break;  // fail
 130     case T_SHORT:
 131       switch (current_type) {
 132         case T_BYTE:
 133           value-&gt;s = (jshort) value-&gt;b;
 134           return;
 135         default:
 136           break;
 137       }
 138       break;  // fail
 139     case T_INT:
 140       switch (current_type) {
 141         case T_BYTE:
 142           value-&gt;i = (jint) value-&gt;b;
 143           return;
 144         case T_CHAR:
 145           value-&gt;i = (jint) value-&gt;c;
 146           return;
 147         case T_SHORT:
 148           value-&gt;i = (jint) value-&gt;s;
 149           return;
 150         default:
 151           break;
 152       }
 153       break;  // fail
 154     case T_LONG:
 155       switch (current_type) {
 156         case T_BYTE:
 157           value-&gt;j = (jlong) value-&gt;b;
 158           return;
 159         case T_CHAR:
 160           value-&gt;j = (jlong) value-&gt;c;
 161           return;
 162         case T_SHORT:
 163           value-&gt;j = (jlong) value-&gt;s;
 164           return;
 165         case T_INT:
 166           value-&gt;j = (jlong) value-&gt;i;
 167           return;
 168         default:
 169           break;
 170       }
 171       break;  // fail
 172     case T_FLOAT:
 173       switch (current_type) {
 174         case T_BYTE:
 175           value-&gt;f = (jfloat) value-&gt;b;
 176           return;
 177         case T_CHAR:
 178           value-&gt;f = (jfloat) value-&gt;c;
 179           return;
 180         case T_SHORT:
 181           value-&gt;f = (jfloat) value-&gt;s;
 182           return;
 183         case T_INT:
 184           value-&gt;f = (jfloat) value-&gt;i;
 185           return;
 186         case T_LONG:
 187           value-&gt;f = (jfloat) value-&gt;j;
 188           return;
 189         default:
 190           break;
 191       }
 192       break;  // fail
 193     case T_DOUBLE:
 194       switch (current_type) {
 195         case T_BYTE:
 196           value-&gt;d = (jdouble) value-&gt;b;
 197           return;
 198         case T_CHAR:
 199           value-&gt;d = (jdouble) value-&gt;c;
 200           return;
 201         case T_SHORT:
 202           value-&gt;d = (jdouble) value-&gt;s;
 203           return;
 204         case T_INT:
 205           value-&gt;d = (jdouble) value-&gt;i;
 206           return;
 207         case T_FLOAT:
 208           value-&gt;d = (jdouble) value-&gt;f;
 209           return;
 210         case T_LONG:
 211           value-&gt;d = (jdouble) value-&gt;j;
 212           return;
 213         default:
 214           break;
 215       }
 216       break;  // fail
 217     default:
 218       break;  // fail
 219   }
 220   THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;argument type mismatch&quot;);
 221 }
 222 
 223 
 224 BasicType Reflection::array_get(jvalue* value, arrayOop a, int index, TRAPS) {
 225   if (!a-&gt;is_within_bounds(index)) {
 226     THROW_(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), T_ILLEGAL);
 227   }
 228   if (a-&gt;is_objArray()) {
 229     value-&gt;l = cast_from_oop&lt;jobject&gt;(objArrayOop(a)-&gt;obj_at(index));
 230     return T_OBJECT;
 231   } else {
 232     assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
 233     BasicType type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
 234     switch (type) {
 235       case T_BOOLEAN:
 236         value-&gt;z = typeArrayOop(a)-&gt;bool_at(index);
 237         break;
 238       case T_CHAR:
 239         value-&gt;c = typeArrayOop(a)-&gt;char_at(index);
 240         break;
 241       case T_FLOAT:
 242         value-&gt;f = typeArrayOop(a)-&gt;float_at(index);
 243         break;
 244       case T_DOUBLE:
 245         value-&gt;d = typeArrayOop(a)-&gt;double_at(index);
 246         break;
 247       case T_BYTE:
 248         value-&gt;b = typeArrayOop(a)-&gt;byte_at(index);
 249         break;
 250       case T_SHORT:
 251         value-&gt;s = typeArrayOop(a)-&gt;short_at(index);
 252         break;
 253       case T_INT:
 254         value-&gt;i = typeArrayOop(a)-&gt;int_at(index);
 255         break;
 256       case T_LONG:
 257         value-&gt;j = typeArrayOop(a)-&gt;long_at(index);
 258         break;
 259       default:
 260         return T_ILLEGAL;
 261     }
 262     return type;
 263   }
 264 }
 265 
 266 
 267 void Reflection::array_set(jvalue* value, arrayOop a, int index, BasicType value_type, TRAPS) {
 268   if (!a-&gt;is_within_bounds(index)) {
 269     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
 270   }
 271   if (a-&gt;is_objArray()) {
 272     if (value_type == T_OBJECT) {
 273       oop obj = (oop) value-&gt;l;
 274       if (obj != NULL) {
 275         Klass* element_klass = ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass();
 276         if (!obj-&gt;is_a(element_klass)) {
 277           THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;array element type mismatch&quot;);
 278         }
 279       }
 280       objArrayOop(a)-&gt;obj_at_put(index, obj);
 281     }
 282   } else {
 283     assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
 284     BasicType array_type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
 285     if (array_type != value_type) {
 286       // The widen operation can potentially throw an exception, but cannot block,
 287       // so typeArrayOop a is safe if the call succeeds.
 288       widen(value, value_type, array_type, CHECK);
 289     }
 290     switch (array_type) {
 291       case T_BOOLEAN:
 292         typeArrayOop(a)-&gt;bool_at_put(index, value-&gt;z);
 293         break;
 294       case T_CHAR:
 295         typeArrayOop(a)-&gt;char_at_put(index, value-&gt;c);
 296         break;
 297       case T_FLOAT:
 298         typeArrayOop(a)-&gt;float_at_put(index, value-&gt;f);
 299         break;
 300       case T_DOUBLE:
 301         typeArrayOop(a)-&gt;double_at_put(index, value-&gt;d);
 302         break;
 303       case T_BYTE:
 304         typeArrayOop(a)-&gt;byte_at_put(index, value-&gt;b);
 305         break;
 306       case T_SHORT:
 307         typeArrayOop(a)-&gt;short_at_put(index, value-&gt;s);
 308         break;
 309       case T_INT:
 310         typeArrayOop(a)-&gt;int_at_put(index, value-&gt;i);
 311         break;
 312       case T_LONG:
 313         typeArrayOop(a)-&gt;long_at_put(index, value-&gt;j);
 314         break;
 315       default:
 316         THROW(vmSymbols::java_lang_IllegalArgumentException());
 317     }
 318   }
 319 }
 320 
 321 static Klass* basic_type_mirror_to_arrayklass(oop basic_type_mirror, TRAPS) {
 322   assert(java_lang_Class::is_primitive(basic_type_mirror), &quot;just checking&quot;);
 323   BasicType type = java_lang_Class::primitive_type(basic_type_mirror);
 324   if (type == T_VOID) {
 325     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 326   }
 327   else {
 328     return Universe::typeArrayKlassObj(type);
 329   }
 330 }
 331 
 332 arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) {
 333   if (element_mirror == NULL) {
 334     THROW_0(vmSymbols::java_lang_NullPointerException());
 335   }
 336   if (length &lt; 0) {
 337     THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, length));
 338   }
 339   if (java_lang_Class::is_primitive(element_mirror)) {
 340     Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
 341     return TypeArrayKlass::cast(tak)-&gt;allocate(length, THREAD);
 342   } else {
 343     Klass* k = java_lang_Class::as_Klass(element_mirror);
 344     if (k-&gt;is_array_klass() &amp;&amp; ArrayKlass::cast(k)-&gt;dimension() &gt;= MAX_DIM) {
 345       THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 346     }
 347     if (java_lang_Class::is_indirect_type(element_mirror)) {
 348       return oopFactory::new_objArray(k, length, THREAD);
 349     } else {
 350       return oopFactory::new_valueArray(k, length, THREAD);
 351     }
 352   }
 353 }
 354 
 355 
 356 arrayOop Reflection::reflect_new_multi_array(oop element_mirror, typeArrayOop dim_array, TRAPS) {
 357   assert(dim_array-&gt;is_typeArray(), &quot;just checking&quot;);
 358   assert(TypeArrayKlass::cast(dim_array-&gt;klass())-&gt;element_type() == T_INT, &quot;just checking&quot;);
 359 
 360   if (element_mirror == NULL) {
 361     THROW_0(vmSymbols::java_lang_NullPointerException());
 362   }
 363 
 364   int len = dim_array-&gt;length();
 365   if (len &lt;= 0 || len &gt; MAX_DIM) {
 366     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 367   }
 368 
 369   jint dimensions[MAX_DIM];   // C array copy of intArrayOop
 370   for (int i = 0; i &lt; len; i++) {
 371     int d = dim_array-&gt;int_at(i);
 372     if (d &lt; 0) {
 373       THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, d));
 374     }
 375     dimensions[i] = d;
 376   }
 377 
 378   Klass* klass;
 379   int dim = len;
 380   if (java_lang_Class::is_primitive(element_mirror)) {
 381     klass = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
 382   } else {
 383     klass = java_lang_Class::as_Klass(element_mirror);
 384     if (klass-&gt;is_array_klass()) {
 385       int k_dim = ArrayKlass::cast(klass)-&gt;dimension();
 386       if (k_dim + len &gt; MAX_DIM) {
 387         THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 388       }
 389       dim += k_dim;
 390     }
 391   }
 392   ArrayStorageProperties storage_props = ArrayStorageProperties::for_signature(klass-&gt;name());
 393   klass = klass-&gt;array_klass(storage_props, dim, CHECK_NULL);
 394   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(len, dimensions, CHECK_NULL);
 395   assert(obj-&gt;is_array(), &quot;just checking&quot;);
 396   return arrayOop(obj);
 397 }
 398 
 399 
 400 static bool under_unsafe_anonymous_host(const InstanceKlass* ik, const InstanceKlass* unsafe_anonymous_host) {
 401   DEBUG_ONLY(int inf_loop_check = 1000 * 1000 * 1000);
 402   for (;;) {
 403     const InstanceKlass* hc = ik-&gt;unsafe_anonymous_host();
 404     if (hc == NULL)        return false;
 405     if (hc == unsafe_anonymous_host)  return true;
 406     ik = hc;
 407 
 408     // There&#39;s no way to make a host class loop short of patching memory.
 409     // Therefore there cannot be a loop here unless there&#39;s another bug.
 410     // Still, let&#39;s check for it.
 411     assert(--inf_loop_check &gt; 0, &quot;no unsafe_anonymous_host loop&quot;);
 412   }
 413 }
 414 
 415 static bool can_relax_access_check_for(const Klass* accessor,
 416                                        const Klass* accessee,
 417                                        bool classloader_only) {
 418 
 419   const InstanceKlass* accessor_ik = InstanceKlass::cast(accessor);
 420   const InstanceKlass* accessee_ik = InstanceKlass::cast(accessee);
 421 
 422   // If either is on the other&#39;s unsafe_anonymous_host chain, access is OK,
 423   // because one is inside the other.
 424   if (under_unsafe_anonymous_host(accessor_ik, accessee_ik) ||
 425     under_unsafe_anonymous_host(accessee_ik, accessor_ik))
 426     return true;
 427 
 428   if (RelaxAccessControlCheck &amp;&amp;
 429     accessor_ik-&gt;major_version() &lt; Verifier::NO_RELAX_ACCESS_CTRL_CHECK_VERSION &amp;&amp;
 430     accessee_ik-&gt;major_version() &lt; Verifier::NO_RELAX_ACCESS_CTRL_CHECK_VERSION) {
 431     return classloader_only &amp;&amp;
 432       Verifier::relax_access_for(accessor_ik-&gt;class_loader()) &amp;&amp;
 433       accessor_ik-&gt;protection_domain() == accessee_ik-&gt;protection_domain() &amp;&amp;
 434       accessor_ik-&gt;class_loader() == accessee_ik-&gt;class_loader();
 435   }
 436 
 437   return false;
 438 }
 439 
 440 /*
 441     Type Accessibility check for public types: Callee Type T is accessible to Caller Type S if:
 442 
 443                         Callee T in             Callee T in package PT,
 444                         unnamed module          runtime module MT
 445  ------------------------------------------------------------------------------------------------
 446 
 447  Caller S in package     If MS is loose: YES      If same classloader/package (PS == PT): YES
 448  PS, runtime module MS   If MS can read T&#39;s       If same runtime module: (MS == MT): YES
 449                          unnamed module: YES
 450                                                   Else if (MS can read MT (establish readability) &amp;&amp;
 451                                                     ((MT exports PT to MS or to all modules) ||
 452                                                      (MT is open))): YES
 453 
 454  ------------------------------------------------------------------------------------------------
 455  Caller S in unnamed         YES                  Readability exists because unnamed module
 456  module UM                                            &quot;reads&quot; all modules
 457                                                   if (MT exports PT to UM or to all modules): YES
 458 
 459  ------------------------------------------------------------------------------------------------
 460 
 461  Note: a loose module is a module that can read all current and future unnamed modules.
 462 */
 463 Reflection::VerifyClassAccessResults Reflection::verify_class_access(
 464   const Klass* current_class, const InstanceKlass* new_class, bool classloader_only) {
 465 
 466   // Verify that current_class can access new_class.  If the classloader_only
 467   // flag is set, we automatically allow any accesses in which current_class
 468   // doesn&#39;t have a classloader.
 469   if ((current_class == NULL) ||
 470       (current_class == new_class) ||
 471       is_same_class_package(current_class, new_class)) {
 472     return ACCESS_OK;
 473   }
 474   // Allow all accesses from jdk/internal/reflect/MagicAccessorImpl subclasses to
 475   // succeed trivially.
 476   if (SystemDictionary::reflect_MagicAccessorImpl_klass_is_loaded() &amp;&amp;
 477       current_class-&gt;is_subclass_of(SystemDictionary::reflect_MagicAccessorImpl_klass())) {
 478     return ACCESS_OK;
 479   }
 480 
 481   // module boundaries
 482   if (new_class-&gt;is_public()) {
 483     // Ignore modules for DumpSharedSpaces because we do not have any package
 484     // or module information for modules other than java.base.
 485     if (DumpSharedSpaces) {
 486       return ACCESS_OK;
 487     }
 488 
 489     // Find the module entry for current_class, the accessor
 490     ModuleEntry* module_from = current_class-&gt;module();
 491     // Find the module entry for new_class, the accessee
 492     ModuleEntry* module_to = new_class-&gt;module();
 493 
 494     // both in same (possibly unnamed) module
 495     if (module_from == module_to) {
 496       return ACCESS_OK;
 497     }
 498 
 499     // Acceptable access to a type in an unnamed module. Note that since
 500     // unnamed modules can read all unnamed modules, this also handles the
 501     // case where module_from is also unnamed but in a different class loader.
 502     if (!module_to-&gt;is_named() &amp;&amp;
 503         (module_from-&gt;can_read_all_unnamed() || module_from-&gt;can_read(module_to))) {
 504       return ACCESS_OK;
 505     }
 506 
 507     // Establish readability, check if module_from is allowed to read module_to.
 508     if (!module_from-&gt;can_read(module_to)) {
 509       return MODULE_NOT_READABLE;
 510     }
 511 
 512     // Access is allowed if module_to is open, i.e. all its packages are unqualifiedly exported
 513     if (module_to-&gt;is_open()) {
 514       return ACCESS_OK;
 515     }
 516 
 517     PackageEntry* package_to = new_class-&gt;package();
 518     assert(package_to != NULL, &quot;can not obtain new_class&#39; package&quot;);
 519 
 520     {
 521       MutexLocker m1(Module_lock);
 522 
 523       // Once readability is established, if module_to exports T unqualifiedly,
 524       // (to all modules), than whether module_from is in the unnamed module
 525       // or not does not matter, access is allowed.
 526       if (package_to-&gt;is_unqual_exported()) {
 527         return ACCESS_OK;
 528       }
 529 
 530       // Access is allowed if both 1 &amp; 2 hold:
 531       //   1. Readability, module_from can read module_to (established above).
 532       //   2. Either module_to exports T to module_from qualifiedly.
 533       //      or
 534       //      module_to exports T to all unnamed modules and module_from is unnamed.
 535       //      or
 536       //      module_to exports T unqualifiedly to all modules (checked above).
 537       if (!package_to-&gt;is_qexported_to(module_from)) {
 538         return TYPE_NOT_EXPORTED;
 539       }
 540     }
 541     return ACCESS_OK;
 542   }
 543 
 544   if (can_relax_access_check_for(current_class, new_class, classloader_only)) {
 545     return ACCESS_OK;
 546   }
 547   return OTHER_PROBLEM;
 548 }
 549 
 550 // Return an error message specific to the specified Klass*&#39;s and result.
 551 // This function must be called from within a block containing a ResourceMark.
 552 char* Reflection::verify_class_access_msg(const Klass* current_class,
 553                                           const InstanceKlass* new_class,
 554                                           const VerifyClassAccessResults result) {
 555   assert(result != ACCESS_OK, &quot;must be failure result&quot;);
 556   char * msg = NULL;
 557   if (result != OTHER_PROBLEM &amp;&amp; new_class != NULL &amp;&amp; current_class != NULL) {
 558     // Find the module entry for current_class, the accessor
 559     ModuleEntry* module_from = current_class-&gt;module();
 560     const char * module_from_name = module_from-&gt;is_named() ? module_from-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE;
 561     const char * current_class_name = current_class-&gt;external_name();
 562 
 563     // Find the module entry for new_class, the accessee
 564     ModuleEntry* module_to = NULL;
 565     module_to = new_class-&gt;module();
 566     const char * module_to_name = module_to-&gt;is_named() ? module_to-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE;
 567     const char * new_class_name = new_class-&gt;external_name();
 568 
 569     if (result == MODULE_NOT_READABLE) {
 570       assert(module_from-&gt;is_named(), &quot;Unnamed modules can read all modules&quot;);
 571       if (module_to-&gt;is_named()) {
 572         size_t len = 100 + strlen(current_class_name) + 2*strlen(module_from_name) +
 573           strlen(new_class_name) + 2*strlen(module_to_name);
 574         msg = NEW_RESOURCE_ARRAY(char, len);
 575         jio_snprintf(msg, len - 1,
 576           &quot;class %s (in module %s) cannot access class %s (in module %s) because module %s does not read module %s&quot;,
 577           current_class_name, module_from_name, new_class_name,
 578           module_to_name, module_from_name, module_to_name);
 579       } else {
 580         oop jlm = module_to-&gt;module();
 581         assert(jlm != NULL, &quot;Null jlm in module_to ModuleEntry&quot;);
 582         intptr_t identity_hash = jlm-&gt;identity_hash();
 583         size_t len = 160 + strlen(current_class_name) + 2*strlen(module_from_name) +
 584           strlen(new_class_name) + 2*sizeof(uintx);
 585         msg = NEW_RESOURCE_ARRAY(char, len);
 586         jio_snprintf(msg, len - 1,
 587           &quot;class %s (in module %s) cannot access class %s (in unnamed module @&quot; SIZE_FORMAT_HEX &quot;) because module %s does not read unnamed module @&quot; SIZE_FORMAT_HEX,
 588           current_class_name, module_from_name, new_class_name, uintx(identity_hash),
 589           module_from_name, uintx(identity_hash));
 590       }
 591 
 592     } else if (result == TYPE_NOT_EXPORTED) {
 593       assert(new_class-&gt;package() != NULL,
 594              &quot;Unnamed packages are always exported&quot;);
 595       const char * package_name =
 596         new_class-&gt;package()-&gt;name()-&gt;as_klass_external_name();
 597       assert(module_to-&gt;is_named(), &quot;Unnamed modules export all packages&quot;);
 598       if (module_from-&gt;is_named()) {
 599         size_t len = 118 + strlen(current_class_name) + 2*strlen(module_from_name) +
 600           strlen(new_class_name) + 2*strlen(module_to_name) + strlen(package_name);
 601         msg = NEW_RESOURCE_ARRAY(char, len);
 602         jio_snprintf(msg, len - 1,
 603           &quot;class %s (in module %s) cannot access class %s (in module %s) because module %s does not export %s to module %s&quot;,
 604           current_class_name, module_from_name, new_class_name,
 605           module_to_name, module_to_name, package_name, module_from_name);
 606       } else {
 607         oop jlm = module_from-&gt;module();
 608         assert(jlm != NULL, &quot;Null jlm in module_from ModuleEntry&quot;);
 609         intptr_t identity_hash = jlm-&gt;identity_hash();
 610         size_t len = 170 + strlen(current_class_name) + strlen(new_class_name) +
 611           2*strlen(module_to_name) + strlen(package_name) + 2*sizeof(uintx);
 612         msg = NEW_RESOURCE_ARRAY(char, len);
 613         jio_snprintf(msg, len - 1,
 614           &quot;class %s (in unnamed module @&quot; SIZE_FORMAT_HEX &quot;) cannot access class %s (in module %s) because module %s does not export %s to unnamed module @&quot; SIZE_FORMAT_HEX,
 615           current_class_name, uintx(identity_hash), new_class_name, module_to_name,
 616           module_to_name, package_name, uintx(identity_hash));
 617       }
 618     } else {
 619         ShouldNotReachHere();
 620     }
 621   }  // result != OTHER_PROBLEM...
 622   return msg;
 623 }
 624 
 625 bool Reflection::verify_member_access(const Klass* current_class,
 626                                       const Klass* resolved_class,
 627                                       const Klass* member_class,
 628                                       AccessFlags access,
 629                                       bool classloader_only,
 630                                       bool protected_restriction,
 631                                       TRAPS) {
 632   // Verify that current_class can access a member of member_class, where that
 633   // field&#39;s access bits are &quot;access&quot;.  We assume that we&#39;ve already verified
 634   // that current_class can access member_class.
 635   //
 636   // If the classloader_only flag is set, we automatically allow any accesses
 637   // in which current_class doesn&#39;t have a classloader.
 638   //
 639   // &quot;resolved_class&quot; is the runtime type of &quot;member_class&quot;. Sometimes we don&#39;t
 640   // need this distinction (e.g. if all we have is the runtime type, or during
 641   // class file parsing when we only care about the static type); in that case
 642   // callers should ensure that resolved_class == member_class.
 643   //
 644   if ((current_class == NULL) ||
 645       (current_class == member_class) ||
 646       access.is_public()) {
 647     return true;
 648   }
 649 
 650   const Klass* host_class = current_class;
 651   if (current_class-&gt;is_instance_klass() &amp;&amp;
 652       InstanceKlass::cast(current_class)-&gt;is_unsafe_anonymous()) {
 653     host_class = InstanceKlass::cast(current_class)-&gt;unsafe_anonymous_host();
 654     assert(host_class != NULL, &quot;Unsafe anonymous class has null host class&quot;);
 655     assert(!(host_class-&gt;is_instance_klass() &amp;&amp;
 656            InstanceKlass::cast(host_class)-&gt;is_unsafe_anonymous()),
 657            &quot;unsafe_anonymous_host should not be unsafe anonymous itself&quot;);
 658   }
 659   if (host_class == member_class) {
 660     return true;
 661   }
 662 
 663   if (access.is_protected()) {
 664     if (!protected_restriction) {
 665       // See if current_class (or outermost host class) is a subclass of member_class
 666       // An interface may not access protected members of j.l.Object
 667       if (!host_class-&gt;is_interface() &amp;&amp; host_class-&gt;is_subclass_of(member_class)) {
 668         if (access.is_static() || // static fields are ok, see 6622385
 669             current_class == resolved_class ||
 670             member_class == resolved_class ||
 671             host_class-&gt;is_subclass_of(resolved_class) ||
 672             resolved_class-&gt;is_subclass_of(host_class)) {
 673           return true;
 674         }
 675       }
 676     }
 677   }
 678 
 679   // package access
 680   if (!access.is_private() &amp;&amp; is_same_class_package(current_class, member_class)) {
 681     return true;
 682   }
 683 
 684   // private access between different classes needs a nestmate check, but
 685   // not for unsafe anonymous classes - so check host_class
 686   if (access.is_private() &amp;&amp; host_class == current_class) {
 687     if (current_class-&gt;is_instance_klass() &amp;&amp; member_class-&gt;is_instance_klass() ) {
 688       InstanceKlass* cur_ik = const_cast&lt;InstanceKlass*&gt;(InstanceKlass::cast(current_class));
 689       InstanceKlass* field_ik = const_cast&lt;InstanceKlass*&gt;(InstanceKlass::cast(member_class));
 690       // Nestmate access checks may require resolution and validation of the nest-host.
 691       // It is up to the caller to check for pending exceptions and handle appropriately.
 692       bool access = cur_ik-&gt;has_nestmate_access_to(field_ik, CHECK_false);
 693       if (access) {
 694         guarantee(resolved_class-&gt;is_subclass_of(member_class), &quot;must be!&quot;);
 695         return true;
 696       }
 697     }
 698   }
 699 
 700   // Allow all accesses from jdk/internal/reflect/MagicAccessorImpl subclasses to
 701   // succeed trivially.
 702   if (current_class-&gt;is_subclass_of(SystemDictionary::reflect_MagicAccessorImpl_klass())) {
 703     return true;
 704   }
 705 
 706   // Check for special relaxations
 707   return can_relax_access_check_for(current_class, member_class, classloader_only);
 708 }
 709 
 710 bool Reflection::is_same_class_package(const Klass* class1, const Klass* class2) {
 711   return InstanceKlass::cast(class1)-&gt;is_same_class_package(class2);
 712 }
 713 
 714 // Checks that the &#39;outer&#39; klass has declared &#39;inner&#39; as being an inner klass. If not,
 715 // throw an incompatible class change exception
 716 // If inner_is_member, require the inner to be a member of the outer.
 717 // If !inner_is_member, require the inner to be unsafe anonymous (a non-member).
 718 // Caller is responsible for figuring out in advance which case must be true.
 719 void Reflection::check_for_inner_class(const InstanceKlass* outer, const InstanceKlass* inner,
 720                                        bool inner_is_member, TRAPS) {
 721   InnerClassesIterator iter(outer);
 722   constantPoolHandle cp   (THREAD, outer-&gt;constants());
 723   for (; !iter.done(); iter.next()) {
 724     int ioff = iter.inner_class_info_index();
 725     int ooff = iter.outer_class_info_index();
 726 
 727     if (inner_is_member &amp;&amp; ioff != 0 &amp;&amp; ooff != 0) {
 728       if (cp-&gt;klass_name_at_matches(outer, ooff) &amp;&amp;
 729           cp-&gt;klass_name_at_matches(inner, ioff)) {
 730         Klass* o = cp-&gt;klass_at(ooff, CHECK);
 731         if (o == outer) {
 732           Klass* i = cp-&gt;klass_at(ioff, CHECK);
 733           if (i == inner) {
 734             return;
 735           }
 736         }
 737       }
 738     }
 739 
 740     if (!inner_is_member &amp;&amp; ioff != 0 &amp;&amp; ooff == 0 &amp;&amp;
 741         cp-&gt;klass_name_at_matches(inner, ioff)) {
 742       Klass* i = cp-&gt;klass_at(ioff, CHECK);
 743       if (i == inner) {
 744         return;
 745       }
 746     }
 747   }
 748 
 749   // &#39;inner&#39; not declared as an inner klass in outer
 750   ResourceMark rm(THREAD);
 751   Exceptions::fthrow(
 752     THREAD_AND_LOCATION,
 753     vmSymbols::java_lang_IncompatibleClassChangeError(),
 754     &quot;%s and %s disagree on InnerClasses attribute&quot;,
 755     outer-&gt;external_name(),
 756     inner-&gt;external_name()
 757   );
 758 }
 759 
<a name="2" id="anc2"></a><span class="line-removed"> 760 // Returns Q-mirror if qtype_if_value is true and k is a ValueKlass;</span>
<span class="line-removed"> 761 // otherwise returns java_mirror or L-mirror for ValueKlass</span>
<span class="line-removed"> 762 static oop java_mirror(Klass* k, jboolean qtype_if_value) {</span>
<span class="line-removed"> 763   if (k-&gt;is_value()) {</span>
<span class="line-removed"> 764     ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(k));</span>
<span class="line-removed"> 765     return qtype_if_value ? vk-&gt;value_mirror() : vk-&gt;indirect_mirror();</span>
<span class="line-removed"> 766   } else {</span>
<span class="line-removed"> 767     return k-&gt;java_mirror();</span>
<span class="line-removed"> 768   }</span>
<span class="line-removed"> 769 }</span>
<span class="line-removed"> 770 </span>
<span class="line-removed"> 771 // Utility method converting a single SignatureStream element into java.lang.Class instance</span>
<span class="line-removed"> 772 static oop get_mirror_from_signature(const methodHandle&amp; method,</span>
<span class="line-removed"> 773                                      SignatureStream* ss,</span>
<span class="line-removed"> 774                                      TRAPS) {</span>
<span class="line-removed"> 775 </span>
<span class="line-removed"> 776   BasicType bt = ss-&gt;type();</span>
<span class="line-removed"> 777   if (is_reference_type(ss-&gt;type())) {</span>
<span class="line-removed"> 778     Symbol* name = ss-&gt;as_symbol();</span>
<span class="line-removed"> 779     oop loader = method-&gt;method_holder()-&gt;class_loader();</span>
<span class="line-removed"> 780     oop protection_domain = method-&gt;method_holder()-&gt;protection_domain();</span>
<span class="line-removed"> 781     const Klass* k = SystemDictionary::resolve_or_fail(name,</span>
<span class="line-removed"> 782                                                        Handle(THREAD, loader),</span>
<span class="line-removed"> 783                                                        Handle(THREAD, protection_domain),</span>
<span class="line-removed"> 784                                                        true,</span>
<span class="line-removed"> 785                                                        CHECK_NULL);</span>
<span class="line-removed"> 786     if (log_is_enabled(Debug, class, resolve)) {</span>
<span class="line-removed"> 787       trace_class_resolution(k);</span>
<span class="line-removed"> 788     }</span>
<span class="line-removed"> 789     return java_mirror((Klass*)k, bt == T_VALUETYPE);</span>
<span class="line-removed"> 790   }</span>
<span class="line-removed"> 791 </span>
<span class="line-removed"> 792   assert(bt != T_VOID || ss-&gt;at_return_type(),</span>
<span class="line-removed"> 793     &quot;T_VOID should only appear as return type&quot;);</span>
<span class="line-removed"> 794 </span>
<span class="line-removed"> 795   return java_lang_Class::primitive_mirror(bt);</span>
<span class="line-removed"> 796 }</span>
<span class="line-removed"> 797 </span>
 798 static objArrayHandle get_parameter_types(const methodHandle&amp; method,
 799                                           int parameter_count,
 800                                           oop* return_type,
 801                                           TRAPS) {
 802   // Allocate array holding parameter types (java.lang.Class instances)
 803   objArrayOop m = oopFactory::new_objArray(SystemDictionary::Class_klass(), parameter_count, CHECK_(objArrayHandle()));
 804   objArrayHandle mirrors(THREAD, m);
 805   int index = 0;
 806   // Collect parameter types
 807   ResourceMark rm(THREAD);
<a name="3" id="anc3"></a><span class="line-modified"> 808   Symbol*  signature = method-&gt;signature();</span>
<span class="line-modified"> 809   SignatureStream ss(signature);</span>
<span class="line-modified"> 810   while (!ss.at_return_type()) {</span>
<span class="line-modified"> 811     oop mirror = get_mirror_from_signature(method, &amp;ss, CHECK_(objArrayHandle()));</span>
<span class="line-modified"> 812     mirrors-&gt;obj_at_put(index++, mirror);</span>
<span class="line-modified"> 813     ss.next();</span>






 814   }
 815   assert(index == parameter_count, &quot;invalid parameter count&quot;);
<a name="4" id="anc4"></a><span class="line-removed"> 816   if (return_type != NULL) {</span>
<span class="line-removed"> 817     // Collect return type as well</span>
<span class="line-removed"> 818     assert(ss.at_return_type(), &quot;return type should be present&quot;);</span>
<span class="line-removed"> 819     *return_type = get_mirror_from_signature(method, &amp;ss, CHECK_(objArrayHandle()));</span>
<span class="line-removed"> 820   }</span>
 821   return mirrors;
 822 }
 823 
 824 static objArrayHandle get_exception_types(const methodHandle&amp; method, TRAPS) {
 825   return method-&gt;resolved_checked_exceptions(THREAD);
 826 }
 827 
 828 static Handle new_type(Symbol* signature, Klass* k, TRAPS) {
<a name="5" id="anc5"></a><span class="line-modified"> 829   SignatureStream ss(signature, false);</span>
<span class="line-modified"> 830   // Basic types</span>
<span class="line-removed"> 831   BasicType type = ss.type();</span>
<span class="line-removed"> 832   if (!ss.is_reference()) {</span>
<span class="line-removed"> 833     return Handle(THREAD, Universe::java_mirror(type));</span>
<span class="line-removed"> 834   }</span>
<span class="line-removed"> 835 </span>
<span class="line-removed"> 836   Klass* result =</span>
<span class="line-removed"> 837     SystemDictionary::resolve_or_fail(signature,</span>
<span class="line-removed"> 838                                       Handle(THREAD, k-&gt;class_loader()),</span>
<span class="line-removed"> 839                                       Handle(THREAD, k-&gt;protection_domain()),</span>
<span class="line-removed"> 840                                       true, CHECK_(Handle()));</span>
<span class="line-removed"> 841 </span>
<span class="line-removed"> 842   if (log_is_enabled(Debug, class, resolve)) {</span>
<span class="line-removed"> 843     trace_class_resolution(result);</span>
<span class="line-removed"> 844   }</span>
<span class="line-removed"> 845   oop nt = java_mirror(result, type == T_VALUETYPE);</span>
 846   return Handle(THREAD, nt);
 847 }
 848 
 849 
 850 oop Reflection::new_method(const methodHandle&amp; method, bool for_constant_pool_access, TRAPS) {
 851   // Allow sun.reflect.ConstantPool to refer to &lt;clinit&gt; methods as java.lang.reflect.Methods.
 852   assert(!method()-&gt;name()-&gt;starts_with(&#39;&lt;&#39;) || for_constant_pool_access,
 853          &quot;should call new_constructor instead&quot;);
 854   InstanceKlass* holder = method-&gt;method_holder();
 855   int slot = method-&gt;method_idnum();
 856 
 857   Symbol*  signature  = method-&gt;signature();
 858   int parameter_count = ArgumentCount(signature).size();
 859   oop return_type_oop = NULL;
 860   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, &amp;return_type_oop, CHECK_NULL);
 861   if (parameter_types.is_null() || return_type_oop == NULL) return NULL;
 862 
 863   Handle return_type(THREAD, return_type_oop);
 864 
 865   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 866 
 867   if (exception_types.is_null()) return NULL;
 868 
 869   Symbol*  method_name = method-&gt;name();
 870   oop name_oop = StringTable::intern(method_name, CHECK_NULL);
 871   Handle name = Handle(THREAD, name_oop);
 872   if (name == NULL) return NULL;
 873 
 874   const int modifiers = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
 875 
 876   Handle mh = java_lang_reflect_Method::create(CHECK_NULL);
 877 
 878   java_lang_reflect_Method::set_clazz(mh(), holder-&gt;java_mirror());
 879   java_lang_reflect_Method::set_slot(mh(), slot);
 880   java_lang_reflect_Method::set_name(mh(), name());
 881   java_lang_reflect_Method::set_return_type(mh(), return_type());
 882   java_lang_reflect_Method::set_parameter_types(mh(), parameter_types());
 883   java_lang_reflect_Method::set_exception_types(mh(), exception_types());
 884   java_lang_reflect_Method::set_modifiers(mh(), modifiers);
 885   java_lang_reflect_Method::set_override(mh(), false);
 886   if (method-&gt;generic_signature() != NULL) {
 887     Symbol*  gs = method-&gt;generic_signature();
 888     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 889     java_lang_reflect_Method::set_signature(mh(), sig());
 890   }
 891   typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotations(), CHECK_NULL);
 892   java_lang_reflect_Method::set_annotations(mh(), an_oop);
 893   an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 894   java_lang_reflect_Method::set_parameter_annotations(mh(), an_oop);
 895   an_oop = Annotations::make_java_array(method-&gt;annotation_default(), CHECK_NULL);
 896   java_lang_reflect_Method::set_annotation_default(mh(), an_oop);
 897   return mh();
 898 }
 899 
 900 
 901 oop Reflection::new_constructor(const methodHandle&amp; method, TRAPS) {
 902   assert(method()-&gt;is_object_constructor() ||
 903          method()-&gt;is_static_init_factory(),
 904          &quot;should call new_method instead&quot;);
 905 
 906   InstanceKlass* holder = method-&gt;method_holder();
 907   int slot = method-&gt;method_idnum();
 908 
 909   Symbol*  signature  = method-&gt;signature();
 910   int parameter_count = ArgumentCount(signature).size();
 911   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, NULL, CHECK_NULL);
 912   if (parameter_types.is_null()) return NULL;
 913 
 914   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 915   if (exception_types.is_null()) return NULL;
 916 
 917   const int modifiers = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
 918 
 919   Handle ch = java_lang_reflect_Constructor::create(CHECK_NULL);
 920 
 921   java_lang_reflect_Constructor::set_clazz(ch(), holder-&gt;java_mirror());
 922   java_lang_reflect_Constructor::set_slot(ch(), slot);
 923   java_lang_reflect_Constructor::set_parameter_types(ch(), parameter_types());
 924   java_lang_reflect_Constructor::set_exception_types(ch(), exception_types());
 925   java_lang_reflect_Constructor::set_modifiers(ch(), modifiers);
 926   java_lang_reflect_Constructor::set_override(ch(), false);
 927   if (method-&gt;generic_signature() != NULL) {
 928     Symbol*  gs = method-&gt;generic_signature();
 929     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 930     java_lang_reflect_Constructor::set_signature(ch(), sig());
 931   }
 932   typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotations(), CHECK_NULL);
 933   java_lang_reflect_Constructor::set_annotations(ch(), an_oop);
 934   an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 935   java_lang_reflect_Constructor::set_parameter_annotations(ch(), an_oop);
 936   return ch();
 937 }
 938 
 939 
 940 oop Reflection::new_field(fieldDescriptor* fd, TRAPS) {
 941   Symbol*  field_name = fd-&gt;name();
 942   oop name_oop = StringTable::intern(field_name, CHECK_NULL);
 943   Handle name = Handle(THREAD, name_oop);
 944   Symbol*  signature  = fd-&gt;signature();
 945   InstanceKlass* holder = fd-&gt;field_holder();
 946   Handle type = new_type(signature, holder, CHECK_NULL);
 947   Handle rh  = java_lang_reflect_Field::create(CHECK_NULL);
 948 
 949   java_lang_reflect_Field::set_clazz(rh(), fd-&gt;field_holder()-&gt;java_mirror());
 950   java_lang_reflect_Field::set_slot(rh(), fd-&gt;index());
 951   java_lang_reflect_Field::set_name(rh(), name());
 952   java_lang_reflect_Field::set_type(rh(), type());
 953   // Note the ACC_ANNOTATION bit, which is a per-class access flag, is never set here.
 954   int modifiers = fd-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
 955   if (fd-&gt;is_flattenable()) {
 956     modifiers |= JVM_ACC_FIELD_FLATTENABLE;
 957     // JVM_ACC_FLATTENABLE should not be set in LWorld.  set_is_flattenable should be re-examined.
 958     modifiers &amp;= ~JVM_ACC_FLATTENABLE;
 959   }
 960   if (fd-&gt;is_flattened()) {
 961     modifiers |= JVM_ACC_FIELD_FLATTENED;
 962   }
 963   java_lang_reflect_Field::set_modifiers(rh(), modifiers);
 964   java_lang_reflect_Field::set_override(rh(), false);
 965   if (fd-&gt;has_generic_signature()) {
 966     Symbol*  gs = fd-&gt;generic_signature();
 967     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 968     java_lang_reflect_Field::set_signature(rh(), sig());
 969   }
 970   typeArrayOop an_oop = Annotations::make_java_array(fd-&gt;annotations(), CHECK_NULL);
 971   java_lang_reflect_Field::set_annotations(rh(), an_oop);
 972   return rh();
 973 }
 974 
 975 oop Reflection::new_parameter(Handle method, int index, Symbol* sym,
 976                               int flags, TRAPS) {
 977 
 978   Handle rh = java_lang_reflect_Parameter::create(CHECK_NULL);
 979 
 980   if(NULL != sym) {
 981     Handle name = java_lang_String::create_from_symbol(sym, CHECK_NULL);
 982     java_lang_reflect_Parameter::set_name(rh(), name());
 983   } else {
 984     java_lang_reflect_Parameter::set_name(rh(), NULL);
 985   }
 986 
 987   java_lang_reflect_Parameter::set_modifiers(rh(), flags);
 988   java_lang_reflect_Parameter::set_executable(rh(), method());
 989   java_lang_reflect_Parameter::set_index(rh(), index);
 990   return rh();
 991 }
 992 
 993 
 994 static methodHandle resolve_interface_call(InstanceKlass* klass,
 995                                            const methodHandle&amp; method,
 996                                            Klass* recv_klass,
 997                                            Handle receiver,
 998                                            TRAPS) {
 999 
1000   assert(!method.is_null() , &quot;method should not be null&quot;);
1001 
1002   CallInfo info;
1003   Symbol*  signature  = method-&gt;signature();
1004   Symbol*  name       = method-&gt;name();
1005   LinkResolver::resolve_interface_call(info, receiver, recv_klass,
1006                                        LinkInfo(klass, name, signature),
1007                                        true,
1008                                        CHECK_(methodHandle()));
1009   return methodHandle(THREAD, info.selected_method());
1010 }
1011 
1012 // Conversion
1013 static BasicType basic_type_mirror_to_basic_type(oop basic_type_mirror, TRAPS) {
1014   assert(java_lang_Class::is_primitive(basic_type_mirror),
1015     &quot;just checking&quot;);
1016   return java_lang_Class::primitive_type(basic_type_mirror);
1017 }
1018 
1019 // Narrowing of basic types. Used to create correct jvalues for
1020 // boolean, byte, char and short return return values from interpreter
1021 // which are returned as ints. Throws IllegalArgumentException.
1022 static void narrow(jvalue* value, BasicType narrow_type, TRAPS) {
1023   switch (narrow_type) {
1024   case T_BOOLEAN:
1025     value-&gt;z = (jboolean) (value-&gt;i &amp; 1);
1026     return;
1027   case T_BYTE:
1028     value-&gt;b = (jbyte)value-&gt;i;
1029     return;
1030   case T_CHAR:
1031     value-&gt;c = (jchar)value-&gt;i;
1032     return;
1033   case T_SHORT:
1034     value-&gt;s = (jshort)value-&gt;i;
1035     return;
1036   default:
1037     break; // fail
1038   }
1039   THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;argument type mismatch&quot;);
1040 }
1041 
1042 
1043 // Method call (shared by invoke_method and invoke_constructor)
1044 static oop invoke(InstanceKlass* klass,
1045                   const methodHandle&amp; reflected_method,
1046                   Handle receiver,
1047                   bool override,
1048                   objArrayHandle ptypes,
1049                   BasicType rtype,
1050                   objArrayHandle args,
1051                   bool is_method_invoke,
1052                   TRAPS) {
1053 
1054   ResourceMark rm(THREAD);
1055 
1056   methodHandle method;      // actual method to invoke
1057   Klass* target_klass;      // target klass, receiver&#39;s klass for non-static
1058 
1059   // Ensure klass is initialized
1060   klass-&gt;initialize(CHECK_NULL);
1061 
1062   bool is_static = reflected_method-&gt;is_static();
1063   if (is_static) {
1064     // ignore receiver argument
1065     method = reflected_method;
1066     target_klass = klass;
1067   } else {
1068     // check for null receiver
1069     if (receiver.is_null()) {
1070       THROW_0(vmSymbols::java_lang_NullPointerException());
1071     }
1072     // Check class of receiver against class declaring method
1073     if (!receiver-&gt;is_a(klass)) {
1074       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;object is not an instance of declaring class&quot;);
1075     }
1076     // target klass is receiver&#39;s klass
1077     target_klass = receiver-&gt;klass();
1078     // no need to resolve if method is private or &lt;init&gt;
1079     if (reflected_method-&gt;is_private() || reflected_method-&gt;name() == vmSymbols::object_initializer_name()) {
1080       method = reflected_method;
1081     } else {
1082       // resolve based on the receiver
1083       if (reflected_method-&gt;method_holder()-&gt;is_interface()) {
1084         // resolve interface call
1085         //
1086         // Match resolution errors with those thrown due to reflection inlining
1087         // Linktime resolution &amp; IllegalAccessCheck already done by Class.getMethod()
1088         method = resolve_interface_call(klass, reflected_method, target_klass, receiver, THREAD);
1089         if (HAS_PENDING_EXCEPTION) {
1090           // Method resolution threw an exception; wrap it in an InvocationTargetException
1091           oop resolution_exception = PENDING_EXCEPTION;
1092           CLEAR_PENDING_EXCEPTION;
1093           // JVMTI has already reported the pending exception
1094           // JVMTI internal flag reset is needed in order to report InvocationTargetException
1095           if (THREAD-&gt;is_Java_thread()) {
1096             JvmtiExport::clear_detected_exception((JavaThread*)THREAD);
1097           }
1098           JavaCallArguments args(Handle(THREAD, resolution_exception));
1099           THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1100                       vmSymbols::throwable_void_signature(),
1101                       &amp;args);
1102         }
1103       }  else {
1104         // if the method can be overridden, we resolve using the vtable index.
1105         assert(!reflected_method-&gt;has_itable_index(), &quot;&quot;);
1106         int index = reflected_method-&gt;vtable_index();
1107         method = reflected_method;
1108         if (index != Method::nonvirtual_vtable_index) {
1109           method = methodHandle(THREAD, target_klass-&gt;method_at_vtable(index));
1110         }
1111         if (!method.is_null()) {
1112           // Check for abstract methods as well
1113           if (method-&gt;is_abstract()) {
1114             // new default: 6531596
1115             ResourceMark rm(THREAD);
1116             stringStream ss;
1117             ss.print(&quot;&#39;&quot;);
1118             Method::print_external_name(&amp;ss, target_klass, method-&gt;name(), method-&gt;signature());
1119             ss.print(&quot;&#39;&quot;);
1120             Handle h_origexception = Exceptions::new_exception(THREAD,
1121               vmSymbols::java_lang_AbstractMethodError(), ss.as_string());
1122             JavaCallArguments args(h_origexception);
1123             THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1124               vmSymbols::throwable_void_signature(),
1125               &amp;args);
1126           }
1127         }
1128       }
1129     }
1130   }
1131 
1132   // I believe this is a ShouldNotGetHere case which requires
1133   // an internal vtable bug. If you ever get this please let Karen know.
1134   if (method.is_null()) {
1135     ResourceMark rm(THREAD);
1136     stringStream ss;
1137     ss.print(&quot;&#39;&quot;);
1138     Method::print_external_name(&amp;ss, klass,
1139                                      reflected_method-&gt;name(),
1140                                      reflected_method-&gt;signature());
1141     ss.print(&quot;&#39;&quot;);
1142     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), ss.as_string());
1143   }
1144 
1145   assert(ptypes-&gt;is_objArray(), &quot;just checking&quot;);
1146   int args_len = args.is_null() ? 0 : args-&gt;length();
1147   // Check number of arguments
1148   if (ptypes-&gt;length() != args_len) {
1149     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1150                 &quot;wrong number of arguments&quot;);
1151   }
1152 
1153   // Create object to contain parameters for the JavaCall
1154   JavaCallArguments java_args(method-&gt;size_of_parameters());
1155 
1156   if (!is_static) {
1157     java_args.push_oop(receiver);
1158   }
1159 
1160   for (int i = 0; i &lt; args_len; i++) {
1161     oop type_mirror = ptypes-&gt;obj_at(i);
1162     oop arg = args-&gt;obj_at(i);
1163     if (java_lang_Class::is_primitive(type_mirror)) {
1164       jvalue value;
1165       BasicType ptype = basic_type_mirror_to_basic_type(type_mirror, CHECK_NULL);
1166       BasicType atype = Reflection::unbox_for_primitive(arg, &amp;value, CHECK_NULL);
1167       if (ptype != atype) {
1168         Reflection::widen(&amp;value, atype, ptype, CHECK_NULL);
1169       }
1170       switch (ptype) {
1171         case T_BOOLEAN:     java_args.push_int(value.z);    break;
1172         case T_CHAR:        java_args.push_int(value.c);    break;
1173         case T_BYTE:        java_args.push_int(value.b);    break;
1174         case T_SHORT:       java_args.push_int(value.s);    break;
1175         case T_INT:         java_args.push_int(value.i);    break;
1176         case T_LONG:        java_args.push_long(value.j);   break;
1177         case T_FLOAT:       java_args.push_float(value.f);  break;
1178         case T_DOUBLE:      java_args.push_double(value.d); break;
1179         default:
1180           THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;argument type mismatch&quot;);
1181       }
1182     } else {
1183       if (arg != NULL) {
1184         Klass* k = java_lang_Class::as_Klass(type_mirror);
1185         if (!arg-&gt;is_a(k)) {
1186           THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1187                       &quot;argument type mismatch&quot;);
1188         }
1189       }
1190       Handle arg_handle(THREAD, arg);         // Create handle for argument
1191       java_args.push_oop(arg_handle); // Push handle
1192     }
1193   }
1194 
1195   assert(java_args.size_of_parameters() == method-&gt;size_of_parameters(),
1196     &quot;just checking&quot;);
1197 
1198   // All oops (including receiver) is passed in as Handles. An potential oop is returned as an
1199   // oop (i.e., NOT as an handle)
1200   JavaValue result(rtype);
1201   JavaCalls::call(&amp;result, method, &amp;java_args, THREAD);
1202 
1203   if (HAS_PENDING_EXCEPTION) {
1204     // Method threw an exception; wrap it in an InvocationTargetException
1205     oop target_exception = PENDING_EXCEPTION;
1206     CLEAR_PENDING_EXCEPTION;
1207     // JVMTI has already reported the pending exception
1208     // JVMTI internal flag reset is needed in order to report InvocationTargetException
1209     if (THREAD-&gt;is_Java_thread()) {
1210       JvmtiExport::clear_detected_exception((JavaThread*)THREAD);
1211     }
1212 
1213     JavaCallArguments args(Handle(THREAD, target_exception));
1214     THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1215                 vmSymbols::throwable_void_signature(),
1216                 &amp;args);
1217   } else {
1218     if (rtype == T_BOOLEAN || rtype == T_BYTE || rtype == T_CHAR || rtype == T_SHORT) {
1219       narrow((jvalue*)result.get_value_addr(), rtype, CHECK_NULL);
1220     }
1221     return Reflection::box((jvalue*)result.get_value_addr(), rtype, THREAD);
1222   }
1223 }
1224 
1225 // This would be nicer if, say, java.lang.reflect.Method was a subclass
1226 // of java.lang.reflect.Constructor
1227 
1228 oop Reflection::invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS) {
1229   oop mirror             = java_lang_reflect_Method::clazz(method_mirror);
1230   int slot               = java_lang_reflect_Method::slot(method_mirror);
1231   bool override          = java_lang_reflect_Method::override(method_mirror) != 0;
1232   objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)));
1233 
1234   oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);
1235   BasicType rtype;
1236   if (java_lang_Class::is_primitive(return_type_mirror)) {
1237     rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);
1238   } else if (java_lang_Class::inline_type_mirror(return_type_mirror) == return_type_mirror) {
1239     rtype = T_VALUETYPE;
1240   } else {
1241     rtype = T_OBJECT;
1242   }
1243 
1244   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1245   Method* m = klass-&gt;method_with_idnum(slot);
1246   if (m == NULL) {
1247     THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;invoke&quot;);
1248   }
1249   methodHandle method(THREAD, m);
1250 
1251   return invoke(klass, method, receiver, override, ptypes, rtype, args, true, THREAD);
1252 }
1253 
1254 
1255 oop Reflection::invoke_constructor(oop constructor_mirror, objArrayHandle args, TRAPS) {
1256   oop mirror             = java_lang_reflect_Constructor::clazz(constructor_mirror);
1257   int slot               = java_lang_reflect_Constructor::slot(constructor_mirror);
1258   bool override          = java_lang_reflect_Constructor::override(constructor_mirror) != 0;
1259   objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Constructor::parameter_types(constructor_mirror)));
1260 
1261   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1262   Method* m = klass-&gt;method_with_idnum(slot);
1263   if (m == NULL) {
1264     THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;invoke&quot;);
1265   }
1266   methodHandle method(THREAD, m);
1267   assert(method-&gt;name() == vmSymbols::object_initializer_name(), &quot;invalid constructor&quot;);
1268 
1269   // Make sure klass gets initialize
1270   klass-&gt;initialize(CHECK_NULL);
1271 
1272   // Create new instance (the receiver)
1273   klass-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1274 
1275   // Special case for factory methods
1276   if (!method-&gt;signature()-&gt;is_void_method_signature()) {
1277     assert(klass-&gt;is_value(), &quot;inline classes must use factory methods&quot;);
1278     Handle no_receiver; // null instead of receiver
1279     return invoke(klass, method, no_receiver, override, ptypes, T_VALUETYPE, args, false, CHECK_NULL);
1280   }
1281 
1282   // main branch of code creates a non-inline object:
1283   assert(!klass-&gt;is_value(), &quot;classic constructors are only for non-inline classes&quot;);
1284   Handle receiver = klass-&gt;allocate_instance_handle(CHECK_NULL);
1285 
1286   // Ignore result from call and return receiver
1287   invoke(klass, method, receiver, override, ptypes, T_VOID, args, false, CHECK_NULL);
1288   return receiver();
1289 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
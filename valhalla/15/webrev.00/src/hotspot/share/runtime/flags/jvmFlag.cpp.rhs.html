<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/flags/jvmFlag.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jfr/jfrEvents.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;runtime/arguments.hpp&quot;
  29 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  30 #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
  31 #include &quot;runtime/flags/jvmFlagRangeList.hpp&quot;
  32 #include &quot;runtime/globals_extension.hpp&quot;
  33 #include &quot;utilities/defaultStream.hpp&quot;
  34 #include &quot;utilities/stringUtils.hpp&quot;
  35 
  36 #define DEFAULT_RANGE_STR_CHUNK_SIZE 64
  37 static char* create_range_str(const char *fmt, ...) {
  38   static size_t string_length = DEFAULT_RANGE_STR_CHUNK_SIZE;
  39   static char* range_string = NEW_C_HEAP_ARRAY(char, string_length, mtLogging);
  40 
  41   int size_needed = 0;
  42   do {
  43     va_list args;
  44     va_start(args, fmt);
  45     size_needed = jio_vsnprintf(range_string, string_length, fmt, args);
  46     va_end(args);
  47 
  48     if (size_needed &lt; 0) {
  49       string_length += DEFAULT_RANGE_STR_CHUNK_SIZE;
  50       range_string = REALLOC_C_HEAP_ARRAY(char, range_string, string_length, mtLogging);
  51       guarantee(range_string != NULL, &quot;create_range_str string should not be NULL&quot;);
  52     }
  53   } while (size_needed &lt; 0);
  54 
  55   return range_string;
  56 }
  57 
  58 const char* JVMFlag::get_int_default_range_str() {
  59   return create_range_str(&quot;[ &quot; INT32_FORMAT_W(-25) &quot; ... &quot; INT32_FORMAT_W(25) &quot; ]&quot;, INT_MIN, INT_MAX);
  60 }
  61 
  62 const char* JVMFlag::get_uint_default_range_str() {
  63   return create_range_str(&quot;[ &quot; UINT32_FORMAT_W(-25) &quot; ... &quot; UINT32_FORMAT_W(25) &quot; ]&quot;, 0, UINT_MAX);
  64 }
  65 
  66 const char* JVMFlag::get_intx_default_range_str() {
  67   return create_range_str(&quot;[ &quot; INTX_FORMAT_W(-25) &quot; ... &quot; INTX_FORMAT_W(25) &quot; ]&quot;, min_intx, max_intx);
  68 }
  69 
  70 const char* JVMFlag::get_uintx_default_range_str() {
  71   return create_range_str(&quot;[ &quot; UINTX_FORMAT_W(-25) &quot; ... &quot; UINTX_FORMAT_W(25) &quot; ]&quot;, 0, max_uintx);
  72 }
  73 
  74 const char* JVMFlag::get_uint64_t_default_range_str() {
  75   return create_range_str(&quot;[ &quot; UINT64_FORMAT_W(-25) &quot; ... &quot; UINT64_FORMAT_W(25) &quot; ]&quot;, 0, uint64_t(max_juint));
  76 }
  77 
  78 const char* JVMFlag::get_size_t_default_range_str() {
  79   return create_range_str(&quot;[ &quot; SIZE_FORMAT_W(-25) &quot; ... &quot; SIZE_FORMAT_W(25) &quot; ]&quot;, 0, SIZE_MAX);
  80 }
  81 
  82 const char* JVMFlag::get_double_default_range_str() {
  83   return create_range_str(&quot;[ %-25.3f ... %25.3f ]&quot;, DBL_MIN, DBL_MAX);
  84 }
  85 
  86 static bool is_product_build() {
  87 #ifdef PRODUCT
  88   return true;
  89 #else
  90   return false;
  91 #endif
  92 }
  93 
  94 bool JVMFlag::is_bool() const {
  95   return strcmp(_type, &quot;bool&quot;) == 0;
  96 }
  97 
  98 bool JVMFlag::is_int() const {
  99   return strcmp(_type, &quot;int&quot;)  == 0;
 100 }
 101 
 102 bool JVMFlag::is_uint() const {
 103   return strcmp(_type, &quot;uint&quot;)  == 0;
 104 }
 105 
 106 bool JVMFlag::is_intx() const {
 107   return strcmp(_type, &quot;intx&quot;)  == 0;
 108 }
 109 
 110 bool JVMFlag::is_uintx() const {
 111   return strcmp(_type, &quot;uintx&quot;) == 0;
 112 }
 113 
 114 bool JVMFlag::is_uint64_t() const {
 115   return strcmp(_type, &quot;uint64_t&quot;) == 0;
 116 }
 117 
 118 bool JVMFlag::is_size_t() const {
 119   return strcmp(_type, &quot;size_t&quot;) == 0;
 120 }
 121 
 122 bool JVMFlag::is_double() const {
 123   return strcmp(_type, &quot;double&quot;) == 0;
 124 }
 125 
 126 bool JVMFlag::is_ccstr() const {
 127   return strcmp(_type, &quot;ccstr&quot;) == 0 || strcmp(_type, &quot;ccstrlist&quot;) == 0;
 128 }
 129 
 130 bool JVMFlag::ccstr_accumulates() const {
 131   return strcmp(_type, &quot;ccstrlist&quot;) == 0;
 132 }
 133 
 134 JVMFlag::Flags JVMFlag::get_origin() {
 135   return Flags(_flags &amp; VALUE_ORIGIN_MASK);
 136 }
 137 
 138 void JVMFlag::set_origin(Flags origin) {
 139   assert((origin &amp; VALUE_ORIGIN_MASK) == origin, &quot;sanity&quot;);
 140   Flags new_origin = Flags((origin == COMMAND_LINE) ? Flags(origin | ORIG_COMMAND_LINE) : origin);
 141   _flags = Flags((_flags &amp; ~VALUE_ORIGIN_MASK) | new_origin);
 142 }
 143 
 144 bool JVMFlag::is_default() {
 145   return (get_origin() == DEFAULT);
 146 }
 147 
 148 bool JVMFlag::is_ergonomic() {
 149   return (get_origin() == ERGONOMIC);
 150 }
 151 
 152 bool JVMFlag::is_command_line() {
 153   return (_flags &amp; ORIG_COMMAND_LINE) != 0;
 154 }
 155 
<a name="1" id="anc1"></a><span class="line-added"> 156 bool JVMFlag::is_jimage_resource() {</span>
<span class="line-added"> 157   return (get_origin() == JIMAGE_RESOURCE);</span>
<span class="line-added"> 158 }</span>
<span class="line-added"> 159 </span>
 160 void JVMFlag::set_command_line() {
 161   _flags = Flags(_flags | ORIG_COMMAND_LINE);
 162 }
 163 
 164 bool JVMFlag::is_product() const {
 165   return (_flags &amp; KIND_PRODUCT) != 0;
 166 }
 167 
 168 bool JVMFlag::is_manageable() const {
 169   return (_flags &amp; KIND_MANAGEABLE) != 0;
 170 }
 171 
 172 bool JVMFlag::is_diagnostic() const {
 173   return (_flags &amp; KIND_DIAGNOSTIC) != 0;
 174 }
 175 
 176 bool JVMFlag::is_experimental() const {
 177   return (_flags &amp; KIND_EXPERIMENTAL) != 0;
 178 }
 179 
 180 bool JVMFlag::is_notproduct() const {
 181   return (_flags &amp; KIND_NOT_PRODUCT) != 0;
 182 }
 183 
 184 bool JVMFlag::is_develop() const {
 185   return (_flags &amp; KIND_DEVELOP) != 0;
 186 }
 187 
 188 bool JVMFlag::is_read_write() const {
 189   return (_flags &amp; KIND_READ_WRITE) != 0;
 190 }
 191 
 192 /**
 193  * Returns if this flag is a constant in the binary.  Right now this is
 194  * true for notproduct and develop flags in product builds.
 195  */
 196 bool JVMFlag::is_constant_in_binary() const {
 197 #ifdef PRODUCT
 198   return is_notproduct() || is_develop();
 199 #else
 200   return false;
 201 #endif
 202 }
 203 
 204 bool JVMFlag::is_unlocker() const {
 205   return strcmp(_name, &quot;UnlockDiagnosticVMOptions&quot;) == 0 ||
 206          strcmp(_name, &quot;UnlockExperimentalVMOptions&quot;) == 0;
 207 }
 208 
 209 bool JVMFlag::is_unlocked() const {
 210   if (is_diagnostic()) {
 211     return UnlockDiagnosticVMOptions;
 212   }
 213   if (is_experimental()) {
 214     return UnlockExperimentalVMOptions;
 215   }
 216   return true;
 217 }
 218 
 219 void JVMFlag::clear_diagnostic() {
 220   assert(is_diagnostic(), &quot;sanity&quot;);
 221   _flags = Flags(_flags &amp; ~KIND_DIAGNOSTIC);
 222   assert(!is_diagnostic(), &quot;sanity&quot;);
 223 }
 224 
 225 void JVMFlag::clear_experimental() {
 226   assert(is_experimental(), &quot;sanity&quot;);
 227  _flags = Flags(_flags &amp; ~KIND_EXPERIMENTAL);
 228   assert(!is_experimental(), &quot;sanity&quot;);
 229 }
 230 
 231 void JVMFlag::set_product() {
 232   assert(!is_product(), &quot;sanity&quot;);
 233  _flags = Flags(_flags | KIND_PRODUCT);
 234   assert(is_product(), &quot;sanity&quot;);
 235 }
 236 
 237 // Get custom message for this locked flag, or NULL if
 238 // none is available. Returns message type produced.
 239 JVMFlag::MsgType JVMFlag::get_locked_message(char* buf, int buflen) const {
 240   buf[0] = &#39;\0&#39;;
 241   if (is_diagnostic() &amp;&amp; !is_unlocked()) {
 242     jio_snprintf(buf, buflen,
 243                  &quot;Error: VM option &#39;%s&#39; is diagnostic and must be enabled via -XX:+UnlockDiagnosticVMOptions.\n&quot;
 244                  &quot;Error: The unlock option must precede &#39;%s&#39;.\n&quot;,
 245                  _name, _name);
 246     return JVMFlag::DIAGNOSTIC_FLAG_BUT_LOCKED;
 247   }
 248   if (is_experimental() &amp;&amp; !is_unlocked()) {
 249     jio_snprintf(buf, buflen,
 250                  &quot;Error: VM option &#39;%s&#39; is experimental and must be enabled via -XX:+UnlockExperimentalVMOptions.\n&quot;
 251                  &quot;Error: The unlock option must precede &#39;%s&#39;.\n&quot;,
 252                  _name, _name);
 253     return JVMFlag::EXPERIMENTAL_FLAG_BUT_LOCKED;
 254   }
 255   if (is_develop() &amp;&amp; is_product_build()) {
 256     jio_snprintf(buf, buflen, &quot;Error: VM option &#39;%s&#39; is develop and is available only in debug version of VM.\n&quot;,
 257                  _name);
 258     return JVMFlag::DEVELOPER_FLAG_BUT_PRODUCT_BUILD;
 259   }
 260   if (is_notproduct() &amp;&amp; is_product_build()) {
 261     jio_snprintf(buf, buflen, &quot;Error: VM option &#39;%s&#39; is notproduct and is available only in debug version of VM.\n&quot;,
 262                  _name);
 263     return JVMFlag::NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD;
 264   }
 265   return JVMFlag::NONE;
 266 }
 267 
 268 bool JVMFlag::is_writeable() const {
 269   return is_manageable() || (is_product() &amp;&amp; is_read_write());
 270 }
 271 
 272 // All flags except &quot;manageable&quot; are assumed to be internal flags.
 273 // Long term, we need to define a mechanism to specify which flags
 274 // are external/stable and change this function accordingly.
 275 bool JVMFlag::is_external() const {
 276   return is_manageable();
 277 }
 278 
 279 // Helper function for JVMFlag::print_on().
 280 // Fills current line up to requested position.
 281 // Should the current position already be past the requested position,
 282 // one separator blank is enforced.
 283 void fill_to_pos(outputStream* st, unsigned int req_pos) {
 284   if ((unsigned int)st-&gt;position() &lt; req_pos) {
 285     st-&gt;fill_to(req_pos);  // need to fill with blanks to reach req_pos
 286   } else {
 287     st-&gt;print(&quot; &quot;);        // enforce blank separation. Previous field too long.
 288   }
 289 }
 290 
 291 void JVMFlag::print_on(outputStream* st, bool withComments, bool printRanges) {
 292   // Don&#39;t print notproduct and develop flags in a product build.
 293   if (is_constant_in_binary()) {
 294     return;
 295   }
 296 
 297   if (!printRanges) {
 298     // The command line options -XX:+PrintFlags* cause this function to be called
 299     // for each existing flag to print information pertinent to this flag. The data
 300     // is displayed in columnar form, with the following layout:
 301     //  col1 - data type, right-justified
 302     //  col2 - name,      left-justified
 303     //  col3 - &#39; =&#39;       double-char, leading space to align with possible &#39;+=&#39;
 304     //  col4 - value      left-justified
 305     //  col5 - kind       right-justified
 306     //  col6 - origin     left-justified
 307     //  col7 - comments   left-justified
 308     //
 309     //  The column widths are fixed. They are defined such that, for most cases,
 310     //  an eye-pleasing tabular output is created.
 311     //
 312     //  Sample output:
 313     //       bool ThreadPriorityVerbose                    = false                                     {product} {default}
 314     //      uintx ThresholdTolerance                       = 10                                        {product} {default}
 315     //     size_t TLABSize                                 = 0                                         {product} {default}
 316     //      uintx SurvivorRatio                            = 8                                         {product} {default}
 317     //     double InitialRAMPercentage                     = 1.562500                                  {product} {default}
 318     //      ccstr CompileCommandFile                       = MyFile.cmd                                {product} {command line}
 319     //  ccstrlist CompileOnly                              = Method1
 320     //            CompileOnly                             += Method2                                   {product} {command line}
 321     //  |         |                                       |  |                              |                    |               |
 322     //  |         |                                       |  |                              |                    |               +-- col7
 323     //  |         |                                       |  |                              |                    +-- col6
 324     //  |         |                                       |  |                              +-- col5
 325     //  |         |                                       |  +-- col4
 326     //  |         |                                       +-- col3
 327     //  |         +-- col2
 328     //  +-- col1
 329 
 330     const unsigned int col_spacing = 1;
 331     const unsigned int col1_pos    = 0;
 332     const unsigned int col1_width  = 9;
 333     const unsigned int col2_pos    = col1_pos + col1_width + col_spacing;
 334     const unsigned int col2_width  = 39;
 335     const unsigned int col3_pos    = col2_pos + col2_width + col_spacing;
 336     const unsigned int col3_width  = 2;
 337     const unsigned int col4_pos    = col3_pos + col3_width + col_spacing;
 338     const unsigned int col4_width  = 30;
 339     const unsigned int col5_pos    = col4_pos + col4_width + col_spacing;
 340     const unsigned int col5_width  = 20;
 341     const unsigned int col6_pos    = col5_pos + col5_width + col_spacing;
 342     const unsigned int col6_width  = 15;
 343     const unsigned int col7_pos    = col6_pos + col6_width + col_spacing;
 344     const unsigned int col7_width  = 1;
 345 
 346     st-&gt;fill_to(col1_pos);
 347     st-&gt;print(&quot;%*s&quot;, col1_width, _type);  // right-justified, therefore width is required.
 348 
 349     fill_to_pos(st, col2_pos);
 350     st-&gt;print(&quot;%s&quot;, _name);
 351 
 352     fill_to_pos(st, col3_pos);
 353     st-&gt;print(&quot; =&quot;);  // use &quot; =&quot; for proper alignment with multiline ccstr output.
 354 
 355     fill_to_pos(st, col4_pos);
 356     if (is_bool()) {
 357       st-&gt;print(&quot;%s&quot;, get_bool() ? &quot;true&quot; : &quot;false&quot;);
 358     } else if (is_int()) {
 359       st-&gt;print(&quot;%d&quot;, get_int());
 360     } else if (is_uint()) {
 361       st-&gt;print(&quot;%u&quot;, get_uint());
 362     } else if (is_intx()) {
 363       st-&gt;print(INTX_FORMAT, get_intx());
 364     } else if (is_uintx()) {
 365       st-&gt;print(UINTX_FORMAT, get_uintx());
 366     } else if (is_uint64_t()) {
 367       st-&gt;print(UINT64_FORMAT, get_uint64_t());
 368     } else if (is_size_t()) {
 369       st-&gt;print(SIZE_FORMAT, get_size_t());
 370     } else if (is_double()) {
 371       st-&gt;print(&quot;%f&quot;, get_double());
 372     } else if (is_ccstr()) {
 373       // Honor &lt;newline&gt; characters in ccstr: print multiple lines.
 374       const char* cp = get_ccstr();
 375       if (cp != NULL) {
 376         const char* eol;
 377         while ((eol = strchr(cp, &#39;\n&#39;)) != NULL) {
 378           size_t llen = pointer_delta(eol, cp, sizeof(char));
 379           st-&gt;print(&quot;%.*s&quot;, (int)llen, cp);
 380           st-&gt;cr();
 381           cp = eol+1;
 382           fill_to_pos(st, col2_pos);
 383           st-&gt;print(&quot;%s&quot;, _name);
 384           fill_to_pos(st, col3_pos);
 385           st-&gt;print(&quot;+=&quot;);
 386           fill_to_pos(st, col4_pos);
 387         }
 388         st-&gt;print(&quot;%s&quot;, cp);
 389       }
 390     } else {
 391       st-&gt;print(&quot;unhandled  type %s&quot;, _type);
 392       st-&gt;cr();
 393       return;
 394     }
 395 
 396     fill_to_pos(st, col5_pos);
 397     print_kind(st, col5_width);
 398 
 399     fill_to_pos(st, col6_pos);
 400     print_origin(st, col6_width);
 401 
 402 #ifndef PRODUCT
 403     if (withComments) {
 404       fill_to_pos(st, col7_pos);
 405       st-&gt;print(&quot;%s&quot;, _doc);
 406     }
 407 #endif
 408     st-&gt;cr();
 409   } else if (!is_bool() &amp;&amp; !is_ccstr()) {
 410     // The command line options -XX:+PrintFlags* cause this function to be called
 411     // for each existing flag to print information pertinent to this flag. The data
 412     // is displayed in columnar form, with the following layout:
 413     //  col1 - data type, right-justified
 414     //  col2 - name,      left-justified
 415     //  col4 - range      [ min ... max]
 416     //  col5 - kind       right-justified
 417     //  col6 - origin     left-justified
 418     //  col7 - comments   left-justified
 419     //
 420     //  The column widths are fixed. They are defined such that, for most cases,
 421     //  an eye-pleasing tabular output is created.
 422     //
 423     //  Sample output:
 424     //       intx MinPassesBeforeFlush                               [ 0                         ...       9223372036854775807 ]                         {diagnostic} {default}
 425     //      uintx MinRAMFraction                                     [ 1                         ...      18446744073709551615 ]                            {product} {default}
 426     //     double MinRAMPercentage                                   [ 0.000                     ...                   100.000 ]                            {product} {default}
 427     //      uintx MinSurvivorRatio                                   [ 3                         ...      18446744073709551615 ]                            {product} {default}
 428     //     size_t MinTLABSize                                        [ 1                         ...       9223372036854775807 ]                            {product} {default}
 429     //       intx MonitorBound                                       [ 0                         ...                2147483647 ]                            {product} {default}
 430     //  |         |                                                  |                                                           |                                    |               |
 431     //  |         |                                                  |                                                           |                                    |               +-- col7
 432     //  |         |                                                  |                                                           |                                    +-- col6
 433     //  |         |                                                  |                                                           +-- col5
 434     //  |         |                                                  +-- col4
 435     //  |         +-- col2
 436     //  +-- col1
 437 
 438     const unsigned int col_spacing = 1;
 439     const unsigned int col1_pos    = 0;
 440     const unsigned int col1_width  = 9;
 441     const unsigned int col2_pos    = col1_pos + col1_width + col_spacing;
 442     const unsigned int col2_width  = 49;
 443     const unsigned int col3_pos    = col2_pos + col2_width + col_spacing;
 444     const unsigned int col3_width  = 0;
 445     const unsigned int col4_pos    = col3_pos + col3_width + col_spacing;
 446     const unsigned int col4_width  = 60;
 447     const unsigned int col5_pos    = col4_pos + col4_width + col_spacing;
 448     const unsigned int col5_width  = 35;
 449     const unsigned int col6_pos    = col5_pos + col5_width + col_spacing;
 450     const unsigned int col6_width  = 15;
 451     const unsigned int col7_pos    = col6_pos + col6_width + col_spacing;
 452     const unsigned int col7_width  = 1;
 453 
 454     st-&gt;fill_to(col1_pos);
 455     st-&gt;print(&quot;%*s&quot;, col1_width, _type);  // right-justified, therefore width is required.
 456 
 457     fill_to_pos(st, col2_pos);
 458     st-&gt;print(&quot;%s&quot;, _name);
 459 
 460     fill_to_pos(st, col4_pos);
 461     RangeStrFunc func = NULL;
 462     if (is_int()) {
 463       func = JVMFlag::get_int_default_range_str;
 464     } else if (is_uint()) {
 465       func = JVMFlag::get_uint_default_range_str;
 466     } else if (is_intx()) {
 467       func = JVMFlag::get_intx_default_range_str;
 468     } else if (is_uintx()) {
 469       func = JVMFlag::get_uintx_default_range_str;
 470     } else if (is_uint64_t()) {
 471       func = JVMFlag::get_uint64_t_default_range_str;
 472     } else if (is_size_t()) {
 473       func = JVMFlag::get_size_t_default_range_str;
 474     } else if (is_double()) {
 475       func = JVMFlag::get_double_default_range_str;
 476     } else {
 477       st-&gt;print(&quot;unhandled  type %s&quot;, _type);
 478       st-&gt;cr();
 479       return;
 480     }
 481     JVMFlagRangeList::print(st, this, func);
 482 
 483     fill_to_pos(st, col5_pos);
 484     print_kind(st, col5_width);
 485 
 486     fill_to_pos(st, col6_pos);
 487     print_origin(st, col6_width);
 488 
 489 #ifndef PRODUCT
 490     if (withComments) {
 491       fill_to_pos(st, col7_pos);
 492       st-&gt;print(&quot;%s&quot;, _doc);
 493     }
 494 #endif
 495     st-&gt;cr();
 496   }
 497 }
 498 
 499 void JVMFlag::print_kind(outputStream* st, unsigned int width) {
 500   struct Data {
 501     int flag;
 502     const char* name;
 503   };
 504 
 505   Data data[] = {
 506     { KIND_JVMCI, &quot;JVMCI&quot; },
 507     { KIND_C1, &quot;C1&quot; },
 508     { KIND_C2, &quot;C2&quot; },
 509     { KIND_ARCH, &quot;ARCH&quot; },
 510     { KIND_PLATFORM_DEPENDENT, &quot;pd&quot; },
 511     { KIND_PRODUCT, &quot;product&quot; },
 512     { KIND_MANAGEABLE, &quot;manageable&quot; },
 513     { KIND_DIAGNOSTIC, &quot;diagnostic&quot; },
 514     { KIND_EXPERIMENTAL, &quot;experimental&quot; },
 515     { KIND_NOT_PRODUCT, &quot;notproduct&quot; },
 516     { KIND_DEVELOP, &quot;develop&quot; },
 517     { KIND_LP64_PRODUCT, &quot;lp64_product&quot; },
 518     { KIND_READ_WRITE, &quot;rw&quot; },
 519     { -1, &quot;&quot; }
 520   };
 521 
 522   if ((_flags &amp; KIND_MASK) != 0) {
 523     bool is_first = true;
 524     const size_t buffer_size = 64;
 525     size_t buffer_used = 0;
 526     char kind[buffer_size];
 527 
 528     jio_snprintf(kind, buffer_size, &quot;{&quot;);
 529     buffer_used++;
 530     for (int i = 0; data[i].flag != -1; i++) {
 531       Data d = data[i];
 532       if ((_flags &amp; d.flag) != 0) {
 533         if (is_first) {
 534           is_first = false;
 535         } else {
 536           assert(buffer_used + 1 &lt; buffer_size, &quot;Too small buffer&quot;);
 537           jio_snprintf(kind + buffer_used, buffer_size - buffer_used, &quot; &quot;);
 538           buffer_used++;
 539         }
 540         size_t length = strlen(d.name);
 541         assert(buffer_used + length &lt; buffer_size, &quot;Too small buffer&quot;);
 542         jio_snprintf(kind + buffer_used, buffer_size - buffer_used, &quot;%s&quot;, d.name);
 543         buffer_used += length;
 544       }
 545     }
 546     assert(buffer_used + 2 &lt;= buffer_size, &quot;Too small buffer&quot;);
 547     jio_snprintf(kind + buffer_used, buffer_size - buffer_used, &quot;}&quot;);
 548     st-&gt;print(&quot;%*s&quot;, width, kind);
 549   }
 550 }
 551 
 552 void JVMFlag::print_origin(outputStream* st, unsigned int width) {
 553   int origin = _flags &amp; VALUE_ORIGIN_MASK;
 554   st-&gt;print(&quot;{&quot;);
 555   switch(origin) {
 556     case DEFAULT:
 557       st-&gt;print(&quot;default&quot;); break;
 558     case COMMAND_LINE:
 559       st-&gt;print(&quot;command line&quot;); break;
 560     case ENVIRON_VAR:
 561       st-&gt;print(&quot;environment&quot;); break;
 562     case CONFIG_FILE:
 563       st-&gt;print(&quot;config file&quot;); break;
 564     case MANAGEMENT:
 565       st-&gt;print(&quot;management&quot;); break;
 566     case ERGONOMIC:
 567       if (_flags &amp; ORIG_COMMAND_LINE) {
 568         st-&gt;print(&quot;command line, &quot;);
 569       }
 570       st-&gt;print(&quot;ergonomic&quot;); break;
 571     case ATTACH_ON_DEMAND:
 572       st-&gt;print(&quot;attach&quot;); break;
 573     case INTERNAL:
 574       st-&gt;print(&quot;internal&quot;); break;
 575     case JIMAGE_RESOURCE:
 576       st-&gt;print(&quot;jimage&quot;); break;
 577   }
 578   st-&gt;print(&quot;}&quot;);
 579 }
 580 
 581 void JVMFlag::print_as_flag(outputStream* st) {
 582   if (is_bool()) {
 583     st-&gt;print(&quot;-XX:%s%s&quot;, get_bool() ? &quot;+&quot; : &quot;-&quot;, _name);
 584   } else if (is_int()) {
 585     st-&gt;print(&quot;-XX:%s=%d&quot;, _name, get_int());
 586   } else if (is_uint()) {
 587     st-&gt;print(&quot;-XX:%s=%u&quot;, _name, get_uint());
 588   } else if (is_intx()) {
 589     st-&gt;print(&quot;-XX:%s=&quot; INTX_FORMAT, _name, get_intx());
 590   } else if (is_uintx()) {
 591     st-&gt;print(&quot;-XX:%s=&quot; UINTX_FORMAT, _name, get_uintx());
 592   } else if (is_uint64_t()) {
 593     st-&gt;print(&quot;-XX:%s=&quot; UINT64_FORMAT, _name, get_uint64_t());
 594   } else if (is_size_t()) {
 595     st-&gt;print(&quot;-XX:%s=&quot; SIZE_FORMAT, _name, get_size_t());
 596   } else if (is_double()) {
 597     st-&gt;print(&quot;-XX:%s=%f&quot;, _name, get_double());
 598   } else if (is_ccstr()) {
 599     st-&gt;print(&quot;-XX:%s=&quot;, _name);
 600     const char* cp = get_ccstr();
 601     if (cp != NULL) {
 602       // Need to turn embedded &#39;\n&#39;s back into separate arguments
 603       // Not so efficient to print one character at a time,
 604       // but the choice is to do the transformation to a buffer
 605       // and print that.  And this need not be efficient.
 606       for (; *cp != &#39;\0&#39;; cp += 1) {
 607         switch (*cp) {
 608           default:
 609             st-&gt;print(&quot;%c&quot;, *cp);
 610             break;
 611           case &#39;\n&#39;:
 612             st-&gt;print(&quot; -XX:%s=&quot;, _name);
 613             break;
 614         }
 615       }
 616     }
 617   } else {
 618     ShouldNotReachHere();
 619   }
 620 }
 621 
 622 const char* JVMFlag::flag_error_str(JVMFlag::Error error) {
 623   switch (error) {
 624     case JVMFlag::MISSING_NAME: return &quot;MISSING_NAME&quot;;
 625     case JVMFlag::MISSING_VALUE: return &quot;MISSING_VALUE&quot;;
 626     case JVMFlag::NON_WRITABLE: return &quot;NON_WRITABLE&quot;;
 627     case JVMFlag::OUT_OF_BOUNDS: return &quot;OUT_OF_BOUNDS&quot;;
 628     case JVMFlag::VIOLATES_CONSTRAINT: return &quot;VIOLATES_CONSTRAINT&quot;;
 629     case JVMFlag::INVALID_FLAG: return &quot;INVALID_FLAG&quot;;
 630     case JVMFlag::ERR_OTHER: return &quot;ERR_OTHER&quot;;
 631     case JVMFlag::SUCCESS: return &quot;SUCCESS&quot;;
 632     default: ShouldNotReachHere(); return &quot;NULL&quot;;
 633   }
 634 }
 635 
 636 // 4991491 do not &quot;optimize out&quot; the was_set false values: omitting them
 637 // tickles a Microsoft compiler bug causing flagTable to be malformed
 638 
 639 #define RUNTIME_PRODUCT_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_PRODUCT) },
 640 #define RUNTIME_PD_PRODUCT_FLAG_STRUCT(  type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 641 #define RUNTIME_DIAGNOSTIC_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_DIAGNOSTIC) },
 642 #define RUNTIME_PD_DIAGNOSTIC_FLAG_STRUCT(type, name,       doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 643 #define RUNTIME_EXPERIMENTAL_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_EXPERIMENTAL) },
 644 #define RUNTIME_MANAGEABLE_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_MANAGEABLE) },
 645 #define RUNTIME_PRODUCT_RW_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_READ_WRITE) },
 646 #define RUNTIME_DEVELOP_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_DEVELOP) },
 647 #define RUNTIME_PD_DEVELOP_FLAG_STRUCT(  type, name,        doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_DEVELOP | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 648 #define RUNTIME_NOTPRODUCT_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_NOT_PRODUCT) },
 649 
 650 #define JVMCI_PRODUCT_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_PRODUCT) },
 651 #define JVMCI_PD_PRODUCT_FLAG_STRUCT(    type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 652 #define JVMCI_DIAGNOSTIC_FLAG_STRUCT(    type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_DIAGNOSTIC) },
 653 #define JVMCI_PD_DIAGNOSTIC_FLAG_STRUCT( type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 654 #define JVMCI_EXPERIMENTAL_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_EXPERIMENTAL) },
 655 #define JVMCI_DEVELOP_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_DEVELOP) },
 656 #define JVMCI_PD_DEVELOP_FLAG_STRUCT(    type, name,        doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_DEVELOP | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 657 #define JVMCI_NOTPRODUCT_FLAG_STRUCT(    type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_NOT_PRODUCT) },
 658 
 659 #ifdef _LP64
 660 #define RUNTIME_LP64_PRODUCT_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_LP64_PRODUCT) },
 661 #else
 662 #define RUNTIME_LP64_PRODUCT_FLAG_STRUCT(type, name, value, doc) /* flag is constant */
 663 #endif // _LP64
 664 
 665 #define C1_PRODUCT_FLAG_STRUCT(          type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_PRODUCT) },
 666 #define C1_PD_PRODUCT_FLAG_STRUCT(       type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 667 #define C1_DIAGNOSTIC_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_DIAGNOSTIC) },
 668 #define C1_PD_DIAGNOSTIC_FLAG_STRUCT(    type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 669 #define C1_DEVELOP_FLAG_STRUCT(          type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_DEVELOP) },
 670 #define C1_PD_DEVELOP_FLAG_STRUCT(       type, name,        doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_DEVELOP | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 671 #define C1_NOTPRODUCT_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_NOT_PRODUCT) },
 672 
 673 #define C2_PRODUCT_FLAG_STRUCT(          type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_PRODUCT) },
 674 #define C2_PD_PRODUCT_FLAG_STRUCT(       type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 675 #define C2_DIAGNOSTIC_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_DIAGNOSTIC) },
 676 #define C2_PD_DIAGNOSTIC_FLAG_STRUCT(    type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 677 #define C2_EXPERIMENTAL_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_EXPERIMENTAL) },
 678 #define C2_DEVELOP_FLAG_STRUCT(          type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_DEVELOP) },
 679 #define C2_PD_DEVELOP_FLAG_STRUCT(       type, name,        doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_DEVELOP | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 680 #define C2_NOTPRODUCT_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_NOT_PRODUCT) },
 681 
 682 #define ARCH_PRODUCT_FLAG_STRUCT(        type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_PRODUCT) },
 683 #define ARCH_DIAGNOSTIC_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_DIAGNOSTIC) },
 684 #define ARCH_EXPERIMENTAL_FLAG_STRUCT(   type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_EXPERIMENTAL) },
 685 #define ARCH_DEVELOP_FLAG_STRUCT(        type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_DEVELOP) },
 686 #define ARCH_NOTPRODUCT_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_NOT_PRODUCT) },
 687 
 688 static JVMFlag flagTable[] = {
 689   VM_FLAGS(RUNTIME_DEVELOP_FLAG_STRUCT, \
 690            RUNTIME_PD_DEVELOP_FLAG_STRUCT, \
 691            RUNTIME_PRODUCT_FLAG_STRUCT, \
 692            RUNTIME_PD_PRODUCT_FLAG_STRUCT, \
 693            RUNTIME_DIAGNOSTIC_FLAG_STRUCT, \
 694            RUNTIME_PD_DIAGNOSTIC_FLAG_STRUCT, \
 695            RUNTIME_EXPERIMENTAL_FLAG_STRUCT, \
 696            RUNTIME_NOTPRODUCT_FLAG_STRUCT, \
 697            RUNTIME_MANAGEABLE_FLAG_STRUCT, \
 698            RUNTIME_PRODUCT_RW_FLAG_STRUCT, \
 699            RUNTIME_LP64_PRODUCT_FLAG_STRUCT, \
 700            IGNORE_RANGE, \
 701            IGNORE_CONSTRAINT)
 702 
 703   RUNTIME_OS_FLAGS(RUNTIME_DEVELOP_FLAG_STRUCT, \
 704                    RUNTIME_PD_DEVELOP_FLAG_STRUCT, \
 705                    RUNTIME_PRODUCT_FLAG_STRUCT, \
 706                    RUNTIME_PD_PRODUCT_FLAG_STRUCT, \
 707                    RUNTIME_DIAGNOSTIC_FLAG_STRUCT, \
 708                    RUNTIME_PD_DIAGNOSTIC_FLAG_STRUCT, \
 709                    RUNTIME_NOTPRODUCT_FLAG_STRUCT, \
 710                    IGNORE_RANGE, \
 711                    IGNORE_CONSTRAINT)
 712 #if INCLUDE_JVMCI
 713   JVMCI_FLAGS(JVMCI_DEVELOP_FLAG_STRUCT, \
 714               JVMCI_PD_DEVELOP_FLAG_STRUCT, \
 715               JVMCI_PRODUCT_FLAG_STRUCT, \
 716               JVMCI_PD_PRODUCT_FLAG_STRUCT, \
 717               JVMCI_DIAGNOSTIC_FLAG_STRUCT, \
 718               JVMCI_PD_DIAGNOSTIC_FLAG_STRUCT, \
 719               JVMCI_EXPERIMENTAL_FLAG_STRUCT, \
 720               JVMCI_NOTPRODUCT_FLAG_STRUCT, \
 721               IGNORE_RANGE, \
 722               IGNORE_CONSTRAINT)
 723 #endif // INCLUDE_JVMCI
 724 #ifdef COMPILER1
 725   C1_FLAGS(C1_DEVELOP_FLAG_STRUCT, \
 726            C1_PD_DEVELOP_FLAG_STRUCT, \
 727            C1_PRODUCT_FLAG_STRUCT, \
 728            C1_PD_PRODUCT_FLAG_STRUCT, \
 729            C1_DIAGNOSTIC_FLAG_STRUCT, \
 730            C1_PD_DIAGNOSTIC_FLAG_STRUCT, \
 731            C1_NOTPRODUCT_FLAG_STRUCT, \
 732            IGNORE_RANGE, \
 733            IGNORE_CONSTRAINT)
 734 #endif // COMPILER1
 735 #ifdef COMPILER2
 736   C2_FLAGS(C2_DEVELOP_FLAG_STRUCT, \
 737            C2_PD_DEVELOP_FLAG_STRUCT, \
 738            C2_PRODUCT_FLAG_STRUCT, \
 739            C2_PD_PRODUCT_FLAG_STRUCT, \
 740            C2_DIAGNOSTIC_FLAG_STRUCT, \
 741            C2_PD_DIAGNOSTIC_FLAG_STRUCT, \
 742            C2_EXPERIMENTAL_FLAG_STRUCT, \
 743            C2_NOTPRODUCT_FLAG_STRUCT, \
 744            IGNORE_RANGE, \
 745            IGNORE_CONSTRAINT)
 746 #endif // COMPILER2
 747   ARCH_FLAGS(ARCH_DEVELOP_FLAG_STRUCT, \
 748              ARCH_PRODUCT_FLAG_STRUCT, \
 749              ARCH_DIAGNOSTIC_FLAG_STRUCT, \
 750              ARCH_EXPERIMENTAL_FLAG_STRUCT, \
 751              ARCH_NOTPRODUCT_FLAG_STRUCT, \
 752              IGNORE_RANGE, \
 753              IGNORE_CONSTRAINT)
 754   {0, NULL, NULL}
 755 };
 756 
 757 JVMFlag* JVMFlag::flags = flagTable;
 758 size_t JVMFlag::numFlags = (sizeof(flagTable) / sizeof(JVMFlag));
 759 
 760 inline bool str_equal(const char* s, size_t s_len, const char* q, size_t q_len) {
 761   if (s_len != q_len) return false;
 762   return memcmp(s, q, q_len) == 0;
 763 }
 764 
 765 // Search the flag table for a named flag
 766 JVMFlag* JVMFlag::find_flag(const char* name, size_t length, bool allow_locked, bool return_flag) {
 767   for (JVMFlag* current = &amp;flagTable[0]; current-&gt;_name != NULL; current++) {
 768     if (str_equal(current-&gt;_name, current-&gt;get_name_length(), name, length)) {
 769       // Found a matching entry.
 770       // Don&#39;t report notproduct and develop flags in product builds.
 771       if (current-&gt;is_constant_in_binary()) {
 772         return (return_flag ? current : NULL);
 773       }
 774       // Report locked flags only if allowed.
 775       if (!(current-&gt;is_unlocked() || current-&gt;is_unlocker())) {
 776         if (!allow_locked) {
 777           // disable use of locked flags, e.g. diagnostic, experimental,
 778           // etc. until they are explicitly unlocked
 779           return NULL;
 780         }
 781       }
 782       return current;
 783     }
 784   }
 785   // JVMFlag name is not in the flag table
 786   return NULL;
 787 }
 788 
 789 // Get or compute the flag name length
 790 size_t JVMFlag::get_name_length() {
 791   if (_name_len == 0) {
 792     _name_len = strlen(_name);
 793   }
 794   return _name_len;
 795 }
 796 
 797 JVMFlag* JVMFlag::fuzzy_match(const char* name, size_t length, bool allow_locked) {
 798   float VMOptionsFuzzyMatchSimilarity = 0.7f;
 799   JVMFlag* match = NULL;
 800   float score;
 801   float max_score = -1;
 802 
 803   for (JVMFlag* current = &amp;flagTable[0]; current-&gt;_name != NULL; current++) {
 804     score = StringUtils::similarity(current-&gt;_name, strlen(current-&gt;_name), name, length);
 805     if (score &gt; max_score) {
 806       max_score = score;
 807       match = current;
 808     }
 809   }
 810 
 811   if (match == NULL) {
 812     return NULL;
 813   }
 814 
 815   if (!(match-&gt;is_unlocked() || match-&gt;is_unlocker())) {
 816     if (!allow_locked) {
 817       return NULL;
 818     }
 819   }
 820 
 821   if (max_score &lt; VMOptionsFuzzyMatchSimilarity) {
 822     return NULL;
 823   }
 824 
 825   return match;
 826 }
 827 
 828 // Returns the address of the index&#39;th element
 829 JVMFlag* JVMFlagEx::flag_from_enum(JVMFlagsEnum flag) {
 830   assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);
 831   return &amp;JVMFlag::flags[flag];
 832 }
 833 
 834 bool JVMFlagEx::is_default(JVMFlagsEnum flag) {
 835   return flag_from_enum(flag)-&gt;is_default();
 836 }
 837 
 838 bool JVMFlagEx::is_ergo(JVMFlagsEnum flag) {
 839   return flag_from_enum(flag)-&gt;is_ergonomic();
 840 }
 841 
 842 bool JVMFlagEx::is_cmdline(JVMFlagsEnum flag) {
 843   return flag_from_enum(flag)-&gt;is_command_line();
 844 }
 845 
<a name="2" id="anc2"></a><span class="line-added"> 846 bool JVMFlagEx::is_jimage_resource(JVMFlagsEnum flag) {</span>
<span class="line-added"> 847   assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);</span>
<span class="line-added"> 848   JVMFlag* f = &amp;JVMFlag::flags[flag];</span>
<span class="line-added"> 849   return f-&gt;is_jimage_resource();</span>
<span class="line-added"> 850 }</span>
<span class="line-added"> 851 </span>
 852 void JVMFlagEx::setOnCmdLine(JVMFlagsEnum flag) {
 853   JVMFlag* faddr = flag_from_enum(flag);
 854   assert(faddr != NULL, &quot;Unknown flag&quot;);
 855   faddr-&gt;set_command_line();
 856 }
 857 
 858 template&lt;class E, class T&gt;
 859 static void trace_flag_changed(const JVMFlag* flag, const T old_value, const T new_value, const JVMFlag::Flags origin) {
 860   E e;
 861   e.set_name(flag-&gt;_name);
 862   e.set_oldValue(old_value);
 863   e.set_newValue(new_value);
 864   e.set_origin(origin);
 865   e.commit();
 866 }
 867 
 868 static JVMFlag::Error apply_constraint_and_check_range_bool(const JVMFlag* flag, bool new_value, bool verbose) {
 869   JVMFlag::Error status = JVMFlag::SUCCESS;
 870   JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);
 871   if (constraint != NULL) {
 872     status = constraint-&gt;apply_bool(new_value, verbose);
 873   }
 874   return status;
 875 }
 876 
 877 JVMFlag::Error JVMFlag::boolAt(const JVMFlag* flag, bool* value) {
 878   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 879   if (!flag-&gt;is_bool()) return JVMFlag::WRONG_FORMAT;
 880   *value = flag-&gt;get_bool();
 881   return JVMFlag::SUCCESS;
 882 }
 883 
 884 JVMFlag::Error JVMFlag::boolAtPut(JVMFlag* flag, bool* value, JVMFlag::Flags origin) {
 885   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 886   if (!flag-&gt;is_bool()) return JVMFlag::WRONG_FORMAT;
 887   JVMFlag::Error check = apply_constraint_and_check_range_bool(flag, *value, !JVMFlagConstraintList::validated_after_ergo());
 888   if (check != JVMFlag::SUCCESS) return check;
 889   bool old_value = flag-&gt;get_bool();
 890   trace_flag_changed&lt;EventBooleanFlagChanged, bool&gt;(flag, old_value, *value, origin);
 891   flag-&gt;set_bool(*value);
 892   *value = old_value;
 893   flag-&gt;set_origin(origin);
 894   return JVMFlag::SUCCESS;
 895 }
 896 
 897 JVMFlag::Error JVMFlagEx::boolAtPut(JVMFlagsEnum flag, bool value, JVMFlag::Flags origin) {
 898   JVMFlag* faddr = flag_from_enum(flag);
 899   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_bool(), &quot;wrong flag type&quot;);
 900   return JVMFlag::boolAtPut(faddr, &amp;value, origin);
 901 }
 902 
 903 static JVMFlag::Error apply_constraint_and_check_range_int(const JVMFlag* flag, int new_value, bool verbose) {
 904   JVMFlag::Error status = JVMFlag::SUCCESS;
 905   JVMFlagRange* range = JVMFlagRangeList::find(flag);
 906   if (range != NULL) {
 907     status = range-&gt;check_int(new_value, verbose);
 908   }
 909   if (status == JVMFlag::SUCCESS) {
 910     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);
 911     if (constraint != NULL) {
 912       status = constraint-&gt;apply_int(new_value, verbose);
 913     }
 914   }
 915   return status;
 916 }
 917 
 918 JVMFlag::Error JVMFlag::intAt(const JVMFlag* flag, int* value) {
 919   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 920   if (!flag-&gt;is_int()) return JVMFlag::WRONG_FORMAT;
 921   *value = flag-&gt;get_int();
 922   return JVMFlag::SUCCESS;
 923 }
 924 
 925 JVMFlag::Error JVMFlag::intAtPut(JVMFlag* flag, int* value, JVMFlag::Flags origin) {
 926   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 927   if (!flag-&gt;is_int()) return JVMFlag::WRONG_FORMAT;
 928   JVMFlag::Error check = apply_constraint_and_check_range_int(flag, *value, !JVMFlagConstraintList::validated_after_ergo());
 929   if (check != JVMFlag::SUCCESS) return check;
 930   int old_value = flag-&gt;get_int();
 931   trace_flag_changed&lt;EventIntFlagChanged, s4&gt;(flag, old_value, *value, origin);
 932   flag-&gt;set_int(*value);
 933   *value = old_value;
 934   flag-&gt;set_origin(origin);
 935   return JVMFlag::SUCCESS;
 936 }
 937 
 938 JVMFlag::Error JVMFlagEx::intAtPut(JVMFlagsEnum flag, int value, JVMFlag::Flags origin) {
 939   JVMFlag* faddr = flag_from_enum(flag);
 940   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_int(), &quot;wrong flag type&quot;);
 941   return JVMFlag::intAtPut(faddr, &amp;value, origin);
 942 }
 943 
 944 static JVMFlag::Error apply_constraint_and_check_range_uint(const JVMFlag* flag, uint new_value, bool verbose) {
 945   JVMFlag::Error status = JVMFlag::SUCCESS;
 946   JVMFlagRange* range = JVMFlagRangeList::find(flag);
 947   if (range != NULL) {
 948     status = range-&gt;check_uint(new_value, verbose);
 949   }
 950   if (status == JVMFlag::SUCCESS) {
 951     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);
 952     if (constraint != NULL) {
 953       status = constraint-&gt;apply_uint(new_value, verbose);
 954     }
 955   }
 956   return status;
 957 }
 958 
 959 JVMFlag::Error JVMFlag::uintAt(const JVMFlag* flag, uint* value) {
 960   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 961   if (!flag-&gt;is_uint()) return JVMFlag::WRONG_FORMAT;
 962   *value = flag-&gt;get_uint();
 963   return JVMFlag::SUCCESS;
 964 }
 965 
 966 JVMFlag::Error JVMFlag::uintAtPut(JVMFlag* flag, uint* value, JVMFlag::Flags origin) {
 967   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 968   if (!flag-&gt;is_uint()) return JVMFlag::WRONG_FORMAT;
 969   JVMFlag::Error check = apply_constraint_and_check_range_uint(flag, *value, !JVMFlagConstraintList::validated_after_ergo());
 970   if (check != JVMFlag::SUCCESS) return check;
 971   uint old_value = flag-&gt;get_uint();
 972   trace_flag_changed&lt;EventUnsignedIntFlagChanged, u4&gt;(flag, old_value, *value, origin);
 973   flag-&gt;set_uint(*value);
 974   *value = old_value;
 975   flag-&gt;set_origin(origin);
 976   return JVMFlag::SUCCESS;
 977 }
 978 
 979 JVMFlag::Error JVMFlagEx::uintAtPut(JVMFlagsEnum flag, uint value, JVMFlag::Flags origin) {
 980   JVMFlag* faddr = flag_from_enum(flag);
 981   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uint(), &quot;wrong flag type&quot;);
 982   return JVMFlag::uintAtPut(faddr, &amp;value, origin);
 983 }
 984 
 985 JVMFlag::Error JVMFlag::intxAt(const JVMFlag* flag, intx* value) {
 986   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 987   if (!flag-&gt;is_intx()) return JVMFlag::WRONG_FORMAT;
 988   *value = flag-&gt;get_intx();
 989   return JVMFlag::SUCCESS;
 990 }
 991 
 992 static JVMFlag::Error apply_constraint_and_check_range_intx(const JVMFlag* flag, intx new_value, bool verbose) {
 993   JVMFlag::Error status = JVMFlag::SUCCESS;
 994   JVMFlagRange* range = JVMFlagRangeList::find(flag);
 995   if (range != NULL) {
 996     status = range-&gt;check_intx(new_value, verbose);
 997   }
 998   if (status == JVMFlag::SUCCESS) {
 999     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);
1000     if (constraint != NULL) {
1001       status = constraint-&gt;apply_intx(new_value, verbose);
1002     }
1003   }
1004   return status;
1005 }
1006 
1007 JVMFlag::Error JVMFlag::intxAtPut(JVMFlag* flag, intx* value, JVMFlag::Flags origin) {
1008   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1009   if (!flag-&gt;is_intx()) return JVMFlag::WRONG_FORMAT;
1010   JVMFlag::Error check = apply_constraint_and_check_range_intx(flag, *value, !JVMFlagConstraintList::validated_after_ergo());
1011   if (check != JVMFlag::SUCCESS) return check;
1012   intx old_value = flag-&gt;get_intx();
1013   trace_flag_changed&lt;EventLongFlagChanged, intx&gt;(flag, old_value, *value, origin);
1014   flag-&gt;set_intx(*value);
1015   *value = old_value;
1016   flag-&gt;set_origin(origin);
1017   return JVMFlag::SUCCESS;
1018 }
1019 
1020 JVMFlag::Error JVMFlagEx::intxAtPut(JVMFlagsEnum flag, intx value, JVMFlag::Flags origin) {
1021   JVMFlag* faddr = flag_from_enum(flag);
1022   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_intx(), &quot;wrong flag type&quot;);
1023   return JVMFlag::intxAtPut(faddr, &amp;value, origin);
1024 }
1025 
1026 JVMFlag::Error JVMFlag::uintxAt(const JVMFlag* flag, uintx* value) {
1027   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1028   if (!flag-&gt;is_uintx()) return JVMFlag::WRONG_FORMAT;
1029   *value = flag-&gt;get_uintx();
1030   return JVMFlag::SUCCESS;
1031 }
1032 
1033 static JVMFlag::Error apply_constraint_and_check_range_uintx(const JVMFlag* flag, uintx new_value, bool verbose) {
1034   JVMFlag::Error status = JVMFlag::SUCCESS;
1035   JVMFlagRange* range = JVMFlagRangeList::find(flag);
1036   if (range != NULL) {
1037     status = range-&gt;check_uintx(new_value, verbose);
1038   }
1039   if (status == JVMFlag::SUCCESS) {
1040     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);
1041     if (constraint != NULL) {
1042       status = constraint-&gt;apply_uintx(new_value, verbose);
1043     }
1044   }
1045   return status;
1046 }
1047 
1048 JVMFlag::Error JVMFlag::uintxAtPut(JVMFlag* flag, uintx* value, JVMFlag::Flags origin) {
1049   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1050   if (!flag-&gt;is_uintx()) return JVMFlag::WRONG_FORMAT;
1051   JVMFlag::Error check = apply_constraint_and_check_range_uintx(flag, *value, !JVMFlagConstraintList::validated_after_ergo());
1052   if (check != JVMFlag::SUCCESS) return check;
1053   uintx old_value = flag-&gt;get_uintx();
1054   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(flag, old_value, *value, origin);
1055   flag-&gt;set_uintx(*value);
1056   *value = old_value;
1057   flag-&gt;set_origin(origin);
1058   return JVMFlag::SUCCESS;
1059 }
1060 
1061 JVMFlag::Error JVMFlagEx::uintxAtPut(JVMFlagsEnum flag, uintx value, JVMFlag::Flags origin) {
1062   JVMFlag* faddr = flag_from_enum(flag);
1063   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uintx(), &quot;wrong flag type&quot;);
1064   return JVMFlag::uintxAtPut(faddr, &amp;value, origin);
1065 }
1066 
1067 JVMFlag::Error JVMFlag::uint64_tAt(const JVMFlag* flag, uint64_t* value) {
1068   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1069   if (!flag-&gt;is_uint64_t()) return JVMFlag::WRONG_FORMAT;
1070   *value = flag-&gt;get_uint64_t();
1071   return JVMFlag::SUCCESS;
1072 }
1073 
1074 static JVMFlag::Error apply_constraint_and_check_range_uint64_t(const JVMFlag* flag, uint64_t new_value, bool verbose) {
1075   JVMFlag::Error status = JVMFlag::SUCCESS;
1076   JVMFlagRange* range = JVMFlagRangeList::find(flag);
1077   if (range != NULL) {
1078     status = range-&gt;check_uint64_t(new_value, verbose);
1079   }
1080   if (status == JVMFlag::SUCCESS) {
1081     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);
1082     if (constraint != NULL) {
1083       status = constraint-&gt;apply_uint64_t(new_value, verbose);
1084     }
1085   }
1086   return status;
1087 }
1088 
1089 JVMFlag::Error JVMFlag::uint64_tAtPut(JVMFlag* flag, uint64_t* value, JVMFlag::Flags origin) {
1090   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1091   if (!flag-&gt;is_uint64_t()) return JVMFlag::WRONG_FORMAT;
1092   JVMFlag::Error check = apply_constraint_and_check_range_uint64_t(flag, *value, !JVMFlagConstraintList::validated_after_ergo());
1093   if (check != JVMFlag::SUCCESS) return check;
1094   uint64_t old_value = flag-&gt;get_uint64_t();
1095   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(flag, old_value, *value, origin);
1096   flag-&gt;set_uint64_t(*value);
1097   *value = old_value;
1098   flag-&gt;set_origin(origin);
1099   return JVMFlag::SUCCESS;
1100 }
1101 
1102 JVMFlag::Error JVMFlagEx::uint64_tAtPut(JVMFlagsEnum flag, uint64_t value, JVMFlag::Flags origin) {
1103   JVMFlag* faddr = flag_from_enum(flag);
1104   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uint64_t(), &quot;wrong flag type&quot;);
1105   return JVMFlag::uint64_tAtPut(faddr, &amp;value, origin);
1106 }
1107 
1108 JVMFlag::Error JVMFlag::size_tAt(const JVMFlag* flag, size_t* value) {
1109   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1110   if (!flag-&gt;is_size_t()) return JVMFlag::WRONG_FORMAT;
1111   *value = flag-&gt;get_size_t();
1112   return JVMFlag::SUCCESS;
1113 }
1114 
1115 static JVMFlag::Error apply_constraint_and_check_range_size_t(const JVMFlag* flag, size_t new_value, bool verbose) {
1116   JVMFlag::Error status = JVMFlag::SUCCESS;
1117   JVMFlagRange* range = JVMFlagRangeList::find(flag);
1118   if (range != NULL) {
1119     status = range-&gt;check_size_t(new_value, verbose);
1120   }
1121   if (status == JVMFlag::SUCCESS) {
1122     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);
1123     if (constraint != NULL) {
1124       status = constraint-&gt;apply_size_t(new_value, verbose);
1125     }
1126   }
1127   return status;
1128 }
1129 
1130 
1131 JVMFlag::Error JVMFlag::size_tAtPut(JVMFlag* flag, size_t* value, JVMFlag::Flags origin) {
1132   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1133   if (!flag-&gt;is_size_t()) return JVMFlag::WRONG_FORMAT;
1134   JVMFlag::Error check = apply_constraint_and_check_range_size_t(flag, *value, !JVMFlagConstraintList::validated_after_ergo());
1135   if (check != JVMFlag::SUCCESS) return check;
1136   size_t old_value = flag-&gt;get_size_t();
1137   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(flag, old_value, *value, origin);
1138   flag-&gt;set_size_t(*value);
1139   *value = old_value;
1140   flag-&gt;set_origin(origin);
1141   return JVMFlag::SUCCESS;
1142 }
1143 
1144 JVMFlag::Error JVMFlagEx::size_tAtPut(JVMFlagsEnum flag, size_t value, JVMFlag::Flags origin) {
1145   JVMFlag* faddr = flag_from_enum(flag);
1146   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_size_t(), &quot;wrong flag type&quot;);
1147   return JVMFlag::size_tAtPut(faddr, &amp;value, origin);
1148 }
1149 
1150 JVMFlag::Error JVMFlag::doubleAt(const JVMFlag* flag, double* value) {
1151   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1152   if (!flag-&gt;is_double()) return JVMFlag::WRONG_FORMAT;
1153   *value = flag-&gt;get_double();
1154   return JVMFlag::SUCCESS;
1155 }
1156 
1157 static JVMFlag::Error apply_constraint_and_check_range_double(const JVMFlag* flag, double new_value, bool verbose) {
1158   JVMFlag::Error status = JVMFlag::SUCCESS;
1159   JVMFlagRange* range = JVMFlagRangeList::find(flag);
1160   if (range != NULL) {
1161     status = range-&gt;check_double(new_value, verbose);
1162   }
1163   if (status == JVMFlag::SUCCESS) {
1164     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);
1165     if (constraint != NULL) {
1166       status = constraint-&gt;apply_double(new_value, verbose);
1167     }
1168   }
1169   return status;
1170 }
1171 
1172 JVMFlag::Error JVMFlag::doubleAtPut(JVMFlag* flag, double* value, JVMFlag::Flags origin) {
1173   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1174   if (!flag-&gt;is_double()) return JVMFlag::WRONG_FORMAT;
1175   JVMFlag::Error check = apply_constraint_and_check_range_double(flag, *value, !JVMFlagConstraintList::validated_after_ergo());
1176   if (check != JVMFlag::SUCCESS) return check;
1177   double old_value = flag-&gt;get_double();
1178   trace_flag_changed&lt;EventDoubleFlagChanged, double&gt;(flag, old_value, *value, origin);
1179   flag-&gt;set_double(*value);
1180   *value = old_value;
1181   flag-&gt;set_origin(origin);
1182   return JVMFlag::SUCCESS;
1183 }
1184 
1185 JVMFlag::Error JVMFlagEx::doubleAtPut(JVMFlagsEnum flag, double value, JVMFlag::Flags origin) {
1186   JVMFlag* faddr = flag_from_enum(flag);
1187   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_double(), &quot;wrong flag type&quot;);
1188   return JVMFlag::doubleAtPut(faddr, &amp;value, origin);
1189 }
1190 
1191 JVMFlag::Error JVMFlag::ccstrAt(const JVMFlag* flag, ccstr* value) {
1192   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1193   if (!flag-&gt;is_ccstr()) return JVMFlag::WRONG_FORMAT;
1194   *value = flag-&gt;get_ccstr();
1195   return JVMFlag::SUCCESS;
1196 }
1197 
1198 JVMFlag::Error JVMFlag::ccstrAtPut(JVMFlag* flag, ccstr* value, JVMFlag::Flags origin) {
1199   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1200   if (!flag-&gt;is_ccstr()) return JVMFlag::WRONG_FORMAT;
1201   ccstr old_value = flag-&gt;get_ccstr();
1202   trace_flag_changed&lt;EventStringFlagChanged, const char*&gt;(flag, old_value, *value, origin);
1203   char* new_value = NULL;
1204   if (*value != NULL) {
1205     new_value = os::strdup_check_oom(*value);
1206   }
1207   flag-&gt;set_ccstr(new_value);
1208   if (flag-&gt;is_default() &amp;&amp; old_value != NULL) {
1209     // Prior value is NOT heap allocated, but was a literal constant.
1210     old_value = os::strdup_check_oom(old_value);
1211   }
1212   *value = old_value;
1213   flag-&gt;set_origin(origin);
1214   return JVMFlag::SUCCESS;
1215 }
1216 
1217 JVMFlag::Error JVMFlagEx::ccstrAtPut(JVMFlagsEnum flag, ccstr value, JVMFlag::Flags origin) {
1218   JVMFlag* faddr = flag_from_enum(flag);
1219   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_ccstr(), &quot;wrong flag type&quot;);
1220   ccstr old_value = faddr-&gt;get_ccstr();
1221   trace_flag_changed&lt;EventStringFlagChanged, const char*&gt;(faddr, old_value, value, origin);
1222   char* new_value = os::strdup_check_oom(value);
1223   faddr-&gt;set_ccstr(new_value);
1224   if (!faddr-&gt;is_default() &amp;&amp; old_value != NULL) {
1225     // Prior value is heap allocated so free it.
1226     FREE_C_HEAP_ARRAY(char, old_value);
1227   }
1228   faddr-&gt;set_origin(origin);
1229   return JVMFlag::SUCCESS;
1230 }
1231 
1232 extern &quot;C&quot; {
1233   static int compare_flags(const void* void_a, const void* void_b) {
1234     return strcmp((*((JVMFlag**) void_a))-&gt;_name, (*((JVMFlag**) void_b))-&gt;_name);
1235   }
1236 }
1237 
1238 void JVMFlag::printSetFlags(outputStream* out) {
1239   // Print which flags were set on the command line
1240   // note: this method is called before the thread structure is in place
1241   //       which means resource allocation cannot be used.
1242 
1243   // The last entry is the null entry.
1244   const size_t length = JVMFlag::numFlags - 1;
1245 
1246   // Sort
1247   JVMFlag** array = NEW_C_HEAP_ARRAY(JVMFlag*, length, mtArguments);
1248   for (size_t i = 0; i &lt; length; i++) {
1249     array[i] = &amp;flagTable[i];
1250   }
1251   qsort(array, length, sizeof(JVMFlag*), compare_flags);
1252 
1253   // Print
1254   for (size_t i = 0; i &lt; length; i++) {
1255     if (array[i]-&gt;get_origin() /* naked field! */) {
1256       array[i]-&gt;print_as_flag(out);
1257       out-&gt;print(&quot; &quot;);
1258     }
1259   }
1260   out-&gt;cr();
1261   FREE_C_HEAP_ARRAY(JVMFlag*, array);
1262 }
1263 
1264 #ifndef PRODUCT
1265 
1266 void JVMFlag::verify() {
1267   assert(Arguments::check_vm_args_consistency(), &quot;Some flag settings conflict&quot;);
1268 }
1269 
1270 #endif // PRODUCT
1271 
1272 void JVMFlag::printFlags(outputStream* out, bool withComments, bool printRanges, bool skipDefaults) {
1273   // Print the flags sorted by name
1274   // Note: This method may be called before the thread structure is in place
1275   //       which means resource allocation cannot be used. Also, it may be
1276   //       called as part of error reporting, so handle native OOMs gracefully.
1277 
1278   // The last entry is the null entry.
1279   const size_t length = JVMFlag::numFlags - 1;
1280 
1281   // Print
1282   if (!printRanges) {
1283     out-&gt;print_cr(&quot;[Global flags]&quot;);
1284   } else {
1285     out-&gt;print_cr(&quot;[Global flags ranges]&quot;);
1286   }
1287 
1288   // Sort
1289   JVMFlag** array = NEW_C_HEAP_ARRAY_RETURN_NULL(JVMFlag*, length, mtArguments);
1290   if (array != NULL) {
1291     for (size_t i = 0; i &lt; length; i++) {
1292       array[i] = &amp;flagTable[i];
1293     }
1294     qsort(array, length, sizeof(JVMFlag*), compare_flags);
1295 
1296     for (size_t i = 0; i &lt; length; i++) {
1297       if (array[i]-&gt;is_unlocked() &amp;&amp; !(skipDefaults &amp;&amp; array[i]-&gt;is_default())) {
1298         array[i]-&gt;print_on(out, withComments, printRanges);
1299       }
1300     }
1301     FREE_C_HEAP_ARRAY(JVMFlag*, array);
1302   } else {
1303     // OOM? Print unsorted.
1304     for (size_t i = 0; i &lt; length; i++) {
1305       if (flagTable[i].is_unlocked() &amp;&amp; !(skipDefaults &amp;&amp; flagTable[i].is_default())) {
1306         flagTable[i].print_on(out, withComments, printRanges);
1307       }
1308     }
1309   }
1310 }
1311 
1312 void JVMFlag::printError(bool verbose, const char* msg, ...) {
1313   if (verbose) {
1314     va_list listPointer;
1315     va_start(listPointer, msg);
1316     jio_vfprintf(defaultStream::error_stream(), msg, listPointer);
1317     va_end(listPointer);
1318   }
1319 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/thread.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="signature.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/thread.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 333 #endif
 334   assert(ThreadLocalStorage::thread() == NULL, &quot;ThreadLocalStorage::thread already initialized&quot;);
 335   ThreadLocalStorage::set_thread(this);
 336   assert(Thread::current() == ThreadLocalStorage::thread(), &quot;TLS mismatch!&quot;);
 337 }
 338 
 339 void Thread::clear_thread_current() {
 340   assert(Thread::current() == ThreadLocalStorage::thread(), &quot;TLS mismatch!&quot;);
 341 #ifndef USE_LIBRARY_BASED_TLS_ONLY
 342   _thr_current = NULL;
 343 #endif
 344   ThreadLocalStorage::set_thread(NULL);
 345 }
 346 
 347 void Thread::record_stack_base_and_size() {
 348   // Note: at this point, Thread object is not yet initialized. Do not rely on
 349   // any members being initialized. Do not rely on Thread::current() being set.
 350   // If possible, refrain from doing anything which may crash or assert since
 351   // quite probably those crash dumps will be useless.
 352   set_stack_base(os::current_stack_base());

 353   set_stack_size(os::current_stack_size());
 354 
 355 #ifdef SOLARIS
 356   if (os::is_primordial_thread()) {
 357     os::Solaris::correct_stack_boundaries_for_primordial_thread(this);
 358   }
 359 #endif
 360 
 361   // Set stack limits after thread is initialized.
 362   if (is_Java_thread()) {
 363     ((JavaThread*) this)-&gt;set_stack_overflow_limit();
 364     ((JavaThread*) this)-&gt;set_reserved_stack_activation(stack_base());
 365   }
 366 }
 367 
 368 #if INCLUDE_NMT
 369 void Thread::register_thread_stack_with_NMT() {
 370   MemTracker::record_thread_stack(stack_end(), stack_size());
 371 }
 372 #endif // INCLUDE_NMT
</pre>
<hr />
<pre>
 871     }
 872   }
 873 
 874   return true;
 875 }
 876 
 877 // GC Support
 878 bool Thread::claim_par_threads_do(uintx claim_token) {
 879   uintx token = _threads_do_token;
 880   if (token != claim_token) {
 881     uintx res = Atomic::cmpxchg(&amp;_threads_do_token, token, claim_token);
 882     if (res == token) {
 883       return true;
 884     }
 885     guarantee(res == claim_token, &quot;invariant&quot;);
 886   }
 887   return false;
 888 }
 889 
 890 void Thread::oops_do(OopClosure* f, CodeBlobClosure* cf) {
<span class="line-modified"> 891   active_handles()-&gt;oops_do(f);</span>


 892   // Do oop for ThreadShadow
 893   f-&gt;do_oop((oop*)&amp;_pending_exception);
 894   handle_area()-&gt;oops_do(f);
 895 
 896   // We scan thread local monitor lists here, and the remaining global
 897   // monitors in ObjectSynchronizer::oops_do().
 898   ObjectSynchronizer::thread_local_used_oops_do(this, f);
 899 }
 900 
 901 void Thread::metadata_handles_do(void f(Metadata*)) {
 902   // Only walk the Handles in Thread.
 903   if (metadata_handles() != NULL) {
 904     for (int i = 0; i&lt; metadata_handles()-&gt;length(); i++) {
 905       f(metadata_handles()-&gt;at(i));
 906     }
 907   }
 908 }
 909 
 910 void Thread::print_on(outputStream* st, bool print_extended_info) const {
 911   // get_priority assumes osthread initialized
</pre>
<hr />
<pre>
1225     // (java.lang.Thread doesn&#39;t have a constructor taking only a ThreadGroup argument)
1226     JavaCalls::call_special(&amp;result,
1227                             thread_oop,
1228                             ik,
1229                             vmSymbols::object_initializer_name(),
1230                             vmSymbols::threadgroup_runnable_void_signature(),
1231                             thread_group,
1232                             Handle(),
1233                             THREAD);
1234   }
1235 
1236 
1237   if (daemon) {
1238     java_lang_Thread::set_daemon(thread_oop());
1239   }
1240 
1241   if (HAS_PENDING_EXCEPTION) {
1242     return;
1243   }
1244 
<span class="line-modified">1245   Klass* group =  SystemDictionary::ThreadGroup_klass();</span>
1246   Handle threadObj(THREAD, this-&gt;threadObj());
1247 
1248   JavaCalls::call_special(&amp;result,
1249                           thread_group,
1250                           group,
1251                           vmSymbols::add_method_name(),
1252                           vmSymbols::thread_void_signature(),
1253                           threadObj,          // Arg 1
1254                           THREAD);
1255 }
1256 
1257 // List of all NonJavaThreads and safe iteration over that list.
1258 
1259 class NonJavaThread::List {
1260 public:
1261   NonJavaThread* volatile _head;
1262   SingleWriterSynchronizer _protect;
1263 
1264   List() : _head(NULL), _protect() {}
1265 };
</pre>
<hr />
<pre>
3601     }
3602   }
3603   VMThread* vmt = VMThread::vm_thread();
3604   if (vmt-&gt;claim_threads_do(is_par, claim_token)) {
3605     tc-&gt;do_thread(vmt);
3606   }
3607 }
3608 
3609 // The system initialization in the library has three phases.
3610 //
3611 // Phase 1: java.lang.System class initialization
3612 //     java.lang.System is a primordial class loaded and initialized
3613 //     by the VM early during startup.  java.lang.System.&lt;clinit&gt;
3614 //     only does registerNatives and keeps the rest of the class
3615 //     initialization work later until thread initialization completes.
3616 //
3617 //     System.initPhase1 initializes the system properties, the static
3618 //     fields in, out, and err. Set up java signal handlers, OS-specific
3619 //     system settings, and thread group of the main thread.
3620 static void call_initPhase1(TRAPS) {
<span class="line-modified">3621   Klass* klass =  SystemDictionary::resolve_or_fail(vmSymbols::java_lang_System(), true, CHECK);</span>
3622   JavaValue result(T_VOID);
3623   JavaCalls::call_static(&amp;result, klass, vmSymbols::initPhase1_name(),
3624                                          vmSymbols::void_method_signature(), CHECK);
3625 }
3626 
3627 // Phase 2. Module system initialization
3628 //     This will initialize the module system.  Only java.base classes
3629 //     can be loaded until phase 2 completes.
3630 //
3631 //     Call System.initPhase2 after the compiler initialization and jsr292
3632 //     classes get initialized because module initialization runs a lot of java
3633 //     code, that for performance reasons, should be compiled.  Also, this will
3634 //     enable the startup code to use lambda and other language features in this
3635 //     phase and onward.
3636 //
3637 //     After phase 2, The VM will begin search classes from -Xbootclasspath/a.
3638 static void call_initPhase2(TRAPS) {
3639   TraceTime timer(&quot;Initialize module system&quot;, TRACETIME_LOG(Info, startuptime));
3640 
<span class="line-modified">3641   Klass* klass = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_System(), true, CHECK);</span>
3642 
3643   JavaValue result(T_INT);
3644   JavaCallArguments args;
3645   args.push_int(DisplayVMOutputToStderr);
3646   args.push_int(log_is_enabled(Debug, init)); // print stack trace if exception thrown
3647   JavaCalls::call_static(&amp;result, klass, vmSymbols::initPhase2_name(),
3648                                          vmSymbols::boolean_boolean_int_signature(), &amp;args, CHECK);
3649   if (result.get_jint() != JNI_OK) {
3650     vm_exit_during_initialization(); // no message or exception
3651   }
3652 
3653   universe_post_module_init();
3654 }
3655 
3656 // Phase 3. final setup - set security manager, system class loader and TCCL
3657 //
3658 //     This will instantiate and set the security manager, set the system class
3659 //     loader as well as the thread context class loader.  The security manager
3660 //     and system class loader may be a custom class loaded from -Xbootclasspath/a,
3661 //     other modules or the application&#39;s classpath.
3662 static void call_initPhase3(TRAPS) {
<span class="line-modified">3663   Klass* klass = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_System(), true, CHECK);</span>
3664   JavaValue result(T_VOID);
3665   JavaCalls::call_static(&amp;result, klass, vmSymbols::initPhase3_name(),
3666                                          vmSymbols::void_method_signature(), CHECK);
3667 }
3668 
3669 void Threads::initialize_java_lang_classes(JavaThread* main_thread, TRAPS) {
3670   TraceTime timer(&quot;Initialize java.lang classes&quot;, TRACETIME_LOG(Info, startuptime));
3671 
3672   if (EagerXrunInit &amp;&amp; Arguments::init_libraries_at_startup()) {
3673     create_vm_init_libraries();
3674   }
3675 
3676   initialize_class(vmSymbols::java_lang_String(), CHECK);
3677 
3678   // Inject CompactStrings value after the static initializers for String ran.
3679   java_lang_String::set_compact_strings(CompactStrings);
3680 
3681   // Initialize java_lang.System (needed before creating the thread)
3682   initialize_class(vmSymbols::java_lang_System(), CHECK);
3683   // The VM creates &amp; returns objects of this class. Make sure it&#39;s initialized.
</pre>
<hr />
<pre>
4314     if (on_load_entry != NULL) {
4315       // Invoke the JVM_OnLoad function
4316       JavaThread* thread = JavaThread::current();
4317       ThreadToNativeFromVM ttn(thread);
4318       HandleMark hm(thread);
4319       jint err = (*on_load_entry)(&amp;main_vm, agent-&gt;options(), NULL);
4320       if (err != JNI_OK) {
4321         vm_exit_during_initialization(&quot;-Xrun library failed to init&quot;, agent-&gt;name());
4322       }
4323     } else {
4324       vm_exit_during_initialization(&quot;Could not find JVM_OnLoad function in -Xrun library&quot;, agent-&gt;name());
4325     }
4326   }
4327 }
4328 
4329 
4330 // Last thread running calls java.lang.Shutdown.shutdown()
4331 void JavaThread::invoke_shutdown_hooks() {
4332   HandleMark hm(this);
4333 







4334   // We could get here with a pending exception, if so clear it now.
4335   if (this-&gt;has_pending_exception()) {
4336     this-&gt;clear_pending_exception();
4337   }
4338 
4339   EXCEPTION_MARK;
4340   Klass* shutdown_klass =
4341     SystemDictionary::resolve_or_null(vmSymbols::java_lang_Shutdown(),
4342                                       THREAD);
4343   if (shutdown_klass != NULL) {
4344     // SystemDictionary::resolve_or_null will return null if there was
4345     // an exception.  If we cannot load the Shutdown class, just don&#39;t
4346     // call Shutdown.shutdown() at all.  This will mean the shutdown hooks
4347     // won&#39;t be run.  Note that if a shutdown hook was registered,
4348     // the Shutdown class would have already been loaded
4349     // (Runtime.addShutdownHook will load it).
4350     JavaValue result(T_VOID);
4351     JavaCalls::call_static(&amp;result,
4352                            shutdown_klass,
4353                            vmSymbols::shutdown_name(),
</pre>
</td>
<td>
<hr />
<pre>
 333 #endif
 334   assert(ThreadLocalStorage::thread() == NULL, &quot;ThreadLocalStorage::thread already initialized&quot;);
 335   ThreadLocalStorage::set_thread(this);
 336   assert(Thread::current() == ThreadLocalStorage::thread(), &quot;TLS mismatch!&quot;);
 337 }
 338 
 339 void Thread::clear_thread_current() {
 340   assert(Thread::current() == ThreadLocalStorage::thread(), &quot;TLS mismatch!&quot;);
 341 #ifndef USE_LIBRARY_BASED_TLS_ONLY
 342   _thr_current = NULL;
 343 #endif
 344   ThreadLocalStorage::set_thread(NULL);
 345 }
 346 
 347 void Thread::record_stack_base_and_size() {
 348   // Note: at this point, Thread object is not yet initialized. Do not rely on
 349   // any members being initialized. Do not rely on Thread::current() being set.
 350   // If possible, refrain from doing anything which may crash or assert since
 351   // quite probably those crash dumps will be useless.
 352   set_stack_base(os::current_stack_base());
<span class="line-added"> 353   assert(_stack_base != NULL, &quot;current_stack_base failed for %s&quot;, name());</span>
 354   set_stack_size(os::current_stack_size());
 355 
 356 #ifdef SOLARIS
 357   if (os::is_primordial_thread()) {
 358     os::Solaris::correct_stack_boundaries_for_primordial_thread(this);
 359   }
 360 #endif
 361 
 362   // Set stack limits after thread is initialized.
 363   if (is_Java_thread()) {
 364     ((JavaThread*) this)-&gt;set_stack_overflow_limit();
 365     ((JavaThread*) this)-&gt;set_reserved_stack_activation(stack_base());
 366   }
 367 }
 368 
 369 #if INCLUDE_NMT
 370 void Thread::register_thread_stack_with_NMT() {
 371   MemTracker::record_thread_stack(stack_end(), stack_size());
 372 }
 373 #endif // INCLUDE_NMT
</pre>
<hr />
<pre>
 872     }
 873   }
 874 
 875   return true;
 876 }
 877 
 878 // GC Support
 879 bool Thread::claim_par_threads_do(uintx claim_token) {
 880   uintx token = _threads_do_token;
 881   if (token != claim_token) {
 882     uintx res = Atomic::cmpxchg(&amp;_threads_do_token, token, claim_token);
 883     if (res == token) {
 884       return true;
 885     }
 886     guarantee(res == claim_token, &quot;invariant&quot;);
 887   }
 888   return false;
 889 }
 890 
 891 void Thread::oops_do(OopClosure* f, CodeBlobClosure* cf) {
<span class="line-modified"> 892   if (active_handles() != NULL) {</span>
<span class="line-added"> 893     active_handles()-&gt;oops_do(f);</span>
<span class="line-added"> 894   }</span>
 895   // Do oop for ThreadShadow
 896   f-&gt;do_oop((oop*)&amp;_pending_exception);
 897   handle_area()-&gt;oops_do(f);
 898 
 899   // We scan thread local monitor lists here, and the remaining global
 900   // monitors in ObjectSynchronizer::oops_do().
 901   ObjectSynchronizer::thread_local_used_oops_do(this, f);
 902 }
 903 
 904 void Thread::metadata_handles_do(void f(Metadata*)) {
 905   // Only walk the Handles in Thread.
 906   if (metadata_handles() != NULL) {
 907     for (int i = 0; i&lt; metadata_handles()-&gt;length(); i++) {
 908       f(metadata_handles()-&gt;at(i));
 909     }
 910   }
 911 }
 912 
 913 void Thread::print_on(outputStream* st, bool print_extended_info) const {
 914   // get_priority assumes osthread initialized
</pre>
<hr />
<pre>
1228     // (java.lang.Thread doesn&#39;t have a constructor taking only a ThreadGroup argument)
1229     JavaCalls::call_special(&amp;result,
1230                             thread_oop,
1231                             ik,
1232                             vmSymbols::object_initializer_name(),
1233                             vmSymbols::threadgroup_runnable_void_signature(),
1234                             thread_group,
1235                             Handle(),
1236                             THREAD);
1237   }
1238 
1239 
1240   if (daemon) {
1241     java_lang_Thread::set_daemon(thread_oop());
1242   }
1243 
1244   if (HAS_PENDING_EXCEPTION) {
1245     return;
1246   }
1247 
<span class="line-modified">1248   Klass* group = SystemDictionary::ThreadGroup_klass();</span>
1249   Handle threadObj(THREAD, this-&gt;threadObj());
1250 
1251   JavaCalls::call_special(&amp;result,
1252                           thread_group,
1253                           group,
1254                           vmSymbols::add_method_name(),
1255                           vmSymbols::thread_void_signature(),
1256                           threadObj,          // Arg 1
1257                           THREAD);
1258 }
1259 
1260 // List of all NonJavaThreads and safe iteration over that list.
1261 
1262 class NonJavaThread::List {
1263 public:
1264   NonJavaThread* volatile _head;
1265   SingleWriterSynchronizer _protect;
1266 
1267   List() : _head(NULL), _protect() {}
1268 };
</pre>
<hr />
<pre>
3604     }
3605   }
3606   VMThread* vmt = VMThread::vm_thread();
3607   if (vmt-&gt;claim_threads_do(is_par, claim_token)) {
3608     tc-&gt;do_thread(vmt);
3609   }
3610 }
3611 
3612 // The system initialization in the library has three phases.
3613 //
3614 // Phase 1: java.lang.System class initialization
3615 //     java.lang.System is a primordial class loaded and initialized
3616 //     by the VM early during startup.  java.lang.System.&lt;clinit&gt;
3617 //     only does registerNatives and keeps the rest of the class
3618 //     initialization work later until thread initialization completes.
3619 //
3620 //     System.initPhase1 initializes the system properties, the static
3621 //     fields in, out, and err. Set up java signal handlers, OS-specific
3622 //     system settings, and thread group of the main thread.
3623 static void call_initPhase1(TRAPS) {
<span class="line-modified">3624   Klass* klass = SystemDictionary::System_klass();</span>
3625   JavaValue result(T_VOID);
3626   JavaCalls::call_static(&amp;result, klass, vmSymbols::initPhase1_name(),
3627                                          vmSymbols::void_method_signature(), CHECK);
3628 }
3629 
3630 // Phase 2. Module system initialization
3631 //     This will initialize the module system.  Only java.base classes
3632 //     can be loaded until phase 2 completes.
3633 //
3634 //     Call System.initPhase2 after the compiler initialization and jsr292
3635 //     classes get initialized because module initialization runs a lot of java
3636 //     code, that for performance reasons, should be compiled.  Also, this will
3637 //     enable the startup code to use lambda and other language features in this
3638 //     phase and onward.
3639 //
3640 //     After phase 2, The VM will begin search classes from -Xbootclasspath/a.
3641 static void call_initPhase2(TRAPS) {
3642   TraceTime timer(&quot;Initialize module system&quot;, TRACETIME_LOG(Info, startuptime));
3643 
<span class="line-modified">3644   Klass* klass = SystemDictionary::System_klass();</span>
3645 
3646   JavaValue result(T_INT);
3647   JavaCallArguments args;
3648   args.push_int(DisplayVMOutputToStderr);
3649   args.push_int(log_is_enabled(Debug, init)); // print stack trace if exception thrown
3650   JavaCalls::call_static(&amp;result, klass, vmSymbols::initPhase2_name(),
3651                                          vmSymbols::boolean_boolean_int_signature(), &amp;args, CHECK);
3652   if (result.get_jint() != JNI_OK) {
3653     vm_exit_during_initialization(); // no message or exception
3654   }
3655 
3656   universe_post_module_init();
3657 }
3658 
3659 // Phase 3. final setup - set security manager, system class loader and TCCL
3660 //
3661 //     This will instantiate and set the security manager, set the system class
3662 //     loader as well as the thread context class loader.  The security manager
3663 //     and system class loader may be a custom class loaded from -Xbootclasspath/a,
3664 //     other modules or the application&#39;s classpath.
3665 static void call_initPhase3(TRAPS) {
<span class="line-modified">3666   Klass* klass = SystemDictionary::System_klass();</span>
3667   JavaValue result(T_VOID);
3668   JavaCalls::call_static(&amp;result, klass, vmSymbols::initPhase3_name(),
3669                                          vmSymbols::void_method_signature(), CHECK);
3670 }
3671 
3672 void Threads::initialize_java_lang_classes(JavaThread* main_thread, TRAPS) {
3673   TraceTime timer(&quot;Initialize java.lang classes&quot;, TRACETIME_LOG(Info, startuptime));
3674 
3675   if (EagerXrunInit &amp;&amp; Arguments::init_libraries_at_startup()) {
3676     create_vm_init_libraries();
3677   }
3678 
3679   initialize_class(vmSymbols::java_lang_String(), CHECK);
3680 
3681   // Inject CompactStrings value after the static initializers for String ran.
3682   java_lang_String::set_compact_strings(CompactStrings);
3683 
3684   // Initialize java_lang.System (needed before creating the thread)
3685   initialize_class(vmSymbols::java_lang_System(), CHECK);
3686   // The VM creates &amp; returns objects of this class. Make sure it&#39;s initialized.
</pre>
<hr />
<pre>
4317     if (on_load_entry != NULL) {
4318       // Invoke the JVM_OnLoad function
4319       JavaThread* thread = JavaThread::current();
4320       ThreadToNativeFromVM ttn(thread);
4321       HandleMark hm(thread);
4322       jint err = (*on_load_entry)(&amp;main_vm, agent-&gt;options(), NULL);
4323       if (err != JNI_OK) {
4324         vm_exit_during_initialization(&quot;-Xrun library failed to init&quot;, agent-&gt;name());
4325       }
4326     } else {
4327       vm_exit_during_initialization(&quot;Could not find JVM_OnLoad function in -Xrun library&quot;, agent-&gt;name());
4328     }
4329   }
4330 }
4331 
4332 
4333 // Last thread running calls java.lang.Shutdown.shutdown()
4334 void JavaThread::invoke_shutdown_hooks() {
4335   HandleMark hm(this);
4336 
<span class="line-added">4337   // Link all classes for dynamic CDS dumping before vm exit.</span>
<span class="line-added">4338   // Same operation is being done in JVM_BeforeHalt for handling the</span>
<span class="line-added">4339   // case where the application calls System.exit().</span>
<span class="line-added">4340   if (DynamicDumpSharedSpaces) {</span>
<span class="line-added">4341     MetaspaceShared::link_and_cleanup_shared_classes(this);</span>
<span class="line-added">4342   }</span>
<span class="line-added">4343 </span>
4344   // We could get here with a pending exception, if so clear it now.
4345   if (this-&gt;has_pending_exception()) {
4346     this-&gt;clear_pending_exception();
4347   }
4348 
4349   EXCEPTION_MARK;
4350   Klass* shutdown_klass =
4351     SystemDictionary::resolve_or_null(vmSymbols::java_lang_Shutdown(),
4352                                       THREAD);
4353   if (shutdown_klass != NULL) {
4354     // SystemDictionary::resolve_or_null will return null if there was
4355     // an exception.  If we cannot load the Shutdown class, just don&#39;t
4356     // call Shutdown.shutdown() at all.  This will mean the shutdown hooks
4357     // won&#39;t be run.  Note that if a shutdown hook was registered,
4358     // the Shutdown class would have already been loaded
4359     // (Runtime.addShutdownHook will load it).
4360     JavaValue result(T_VOID);
4361     JavaCalls::call_static(&amp;result,
4362                            shutdown_klass,
4363                            vmSymbols::shutdown_name(),
</pre>
</td>
</tr>
</table>
<center><a href="signature.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
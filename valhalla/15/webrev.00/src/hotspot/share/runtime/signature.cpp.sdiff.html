<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/signature.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="reflection.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="signature.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/signature.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
368     if (_names == NULL) {
369       _names = new GrowableArray&lt;Symbol*&gt;(10);
370     }
371     _names-&gt;push(_previous_name);
372   }
373   _previous_name = name;
374   return name;
375 }
376 
377 ValueKlass* SignatureStream::as_value_klass(InstanceKlass* holder) {
378   Thread* THREAD = Thread::current();
379   Handle class_loader(THREAD, holder-&gt;class_loader());
380   Handle protection_domain(THREAD, holder-&gt;protection_domain());
381   Klass* k = as_klass(class_loader, protection_domain, SignatureStream::ReturnNull, THREAD);
382   assert(k != NULL &amp;&amp; !HAS_PENDING_EXCEPTION, &quot;unresolved value klass&quot;);
383   return ValueKlass::cast(k);
384 }
385 
386 Klass* SignatureStream::as_klass(Handle class_loader, Handle protection_domain,
387                                  FailureMode failure_mode, TRAPS) {
<span class="line-modified">388   if (!is_reference())  return NULL;</span>


389   Symbol* name = as_symbol();
390   Klass* k = NULL;
391   if (failure_mode == ReturnNull) {
392     // Note:  SD::resolve_or_null returns NULL for most failure modes,
393     // but not all.  Circularity errors, invalid PDs, etc., throw.
394     k = SystemDictionary::resolve_or_null(name, class_loader, protection_domain, CHECK_NULL);
395   } else if (failure_mode == CachedOrNull) {
396     NoSafepointVerifier nsv;  // no loading, now, we mean it!
397     assert(!HAS_PENDING_EXCEPTION, &quot;&quot;);
398     k = SystemDictionary::find(name, class_loader, protection_domain, CHECK_NULL);
399     // SD::find does not trigger loading, so there should be no throws
400     // Still, bad things can happen, so we CHECK_NULL and ask callers
401     // to do likewise.
402     return k;
403   } else {
404     // The only remaining failure mode is NCDFError.
405     // The test here allows for an additional mode CNFException
406     // if callers need to request the reflective error instead.
407     bool throw_error = (failure_mode == NCDFError);
408     k = SystemDictionary::resolve_or_fail(name, class_loader, protection_domain, throw_error, CHECK_NULL);
409   }
410 
411   return k;
412 }
413 
414 oop SignatureStream::as_java_mirror(Handle class_loader, Handle protection_domain,
415                                     FailureMode failure_mode, TRAPS) {
<span class="line-modified">416   if (!is_reference())</span>
417     return Universe::java_mirror(type());
<span class="line-modified">418   Klass* klass = as_klass(class_loader, protection_domain, failure_mode, THREAD);</span>
<span class="line-modified">419   if (klass == NULL)  return NULL;</span>



420   if (klass-&gt;is_value()) {
421     ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(klass));
422     return _type == T_VALUETYPE ? vk-&gt;value_mirror() : vk-&gt;indirect_mirror();
423   } else {
424     assert(_type != T_VALUETYPE, &quot;must not be value type&quot;);
425     return klass-&gt;java_mirror();
426   }
427 }
428 
429 void SignatureStream::skip_to_return_type() {
430   while (!at_return_type()) {
431     next();
432   }
433 }
434 














































435 #ifdef ASSERT
436 extern bool signature_constants_sane(); // called from basic_types_init()
437 
438 bool signature_constants_sane() {
439   // for the lookup table, test every 8-bit code point, and then some:
440   for (int i = -256; i &lt;= 256; i++) {
441     int btcode = 0;
442     switch (i) {
443 #define EACH_SIG(ch, bt, ignore) \
444     case ch: { btcode = bt; break; }
445     SIGNATURE_TYPES_DO(EACH_SIG, ignore)
446 #undef EACH_SIG
447     }
448     int btc = decode_signature_char(i);
449     assert(btc == btcode, &quot;misconfigured table: %d =&gt; %d not %d&quot;, i, btc, btcode);
450   }
451   return true;
452 }
453 
454 bool SignatureVerifier::is_valid_method_signature(const Symbol* sig) {
</pre>
</td>
<td>
<hr />
<pre>
368     if (_names == NULL) {
369       _names = new GrowableArray&lt;Symbol*&gt;(10);
370     }
371     _names-&gt;push(_previous_name);
372   }
373   _previous_name = name;
374   return name;
375 }
376 
377 ValueKlass* SignatureStream::as_value_klass(InstanceKlass* holder) {
378   Thread* THREAD = Thread::current();
379   Handle class_loader(THREAD, holder-&gt;class_loader());
380   Handle protection_domain(THREAD, holder-&gt;protection_domain());
381   Klass* k = as_klass(class_loader, protection_domain, SignatureStream::ReturnNull, THREAD);
382   assert(k != NULL &amp;&amp; !HAS_PENDING_EXCEPTION, &quot;unresolved value klass&quot;);
383   return ValueKlass::cast(k);
384 }
385 
386 Klass* SignatureStream::as_klass(Handle class_loader, Handle protection_domain,
387                                  FailureMode failure_mode, TRAPS) {
<span class="line-modified">388   if (!is_reference()) {</span>
<span class="line-added">389     return NULL;</span>
<span class="line-added">390   }</span>
391   Symbol* name = as_symbol();
392   Klass* k = NULL;
393   if (failure_mode == ReturnNull) {
394     // Note:  SD::resolve_or_null returns NULL for most failure modes,
395     // but not all.  Circularity errors, invalid PDs, etc., throw.
396     k = SystemDictionary::resolve_or_null(name, class_loader, protection_domain, CHECK_NULL);
397   } else if (failure_mode == CachedOrNull) {
398     NoSafepointVerifier nsv;  // no loading, now, we mean it!
399     assert(!HAS_PENDING_EXCEPTION, &quot;&quot;);
400     k = SystemDictionary::find(name, class_loader, protection_domain, CHECK_NULL);
401     // SD::find does not trigger loading, so there should be no throws
402     // Still, bad things can happen, so we CHECK_NULL and ask callers
403     // to do likewise.
404     return k;
405   } else {
406     // The only remaining failure mode is NCDFError.
407     // The test here allows for an additional mode CNFException
408     // if callers need to request the reflective error instead.
409     bool throw_error = (failure_mode == NCDFError);
410     k = SystemDictionary::resolve_or_fail(name, class_loader, protection_domain, throw_error, CHECK_NULL);
411   }
412 
413   return k;
414 }
415 
416 oop SignatureStream::as_java_mirror(Handle class_loader, Handle protection_domain,
417                                     FailureMode failure_mode, TRAPS) {
<span class="line-modified">418   if (!is_reference()) {</span>
419     return Universe::java_mirror(type());
<span class="line-modified">420   }</span>
<span class="line-modified">421   Klass* klass = as_klass(class_loader, protection_domain, failure_mode, CHECK_NULL);</span>
<span class="line-added">422   if (klass == NULL) {</span>
<span class="line-added">423     return NULL;</span>
<span class="line-added">424   }</span>
425   if (klass-&gt;is_value()) {
426     ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(klass));
427     return _type == T_VALUETYPE ? vk-&gt;value_mirror() : vk-&gt;indirect_mirror();
428   } else {
429     assert(_type != T_VALUETYPE, &quot;must not be value type&quot;);
430     return klass-&gt;java_mirror();
431   }
432 }
433 
434 void SignatureStream::skip_to_return_type() {
435   while (!at_return_type()) {
436     next();
437   }
438 }
439 
<span class="line-added">440 ResolvingSignatureStream::ResolvingSignatureStream(Symbol* signature,</span>
<span class="line-added">441                                                    Handle class_loader,</span>
<span class="line-added">442                                                    Handle protection_domain,</span>
<span class="line-added">443                                                    bool is_method)</span>
<span class="line-added">444   : SignatureStream(signature, is_method),</span>
<span class="line-added">445     _class_loader(class_loader), _protection_domain(protection_domain)</span>
<span class="line-added">446 {</span>
<span class="line-added">447   initialize_load_origin(NULL);</span>
<span class="line-added">448 }</span>
<span class="line-added">449 </span>
<span class="line-added">450 ResolvingSignatureStream::ResolvingSignatureStream(Symbol* signature, Klass* load_origin, bool is_method)</span>
<span class="line-added">451   : SignatureStream(signature, is_method)</span>
<span class="line-added">452 {</span>
<span class="line-added">453   assert(load_origin != NULL, &quot;&quot;);</span>
<span class="line-added">454   initialize_load_origin(load_origin);</span>
<span class="line-added">455 }</span>
<span class="line-added">456 </span>
<span class="line-added">457 ResolvingSignatureStream::ResolvingSignatureStream(const Method* method)</span>
<span class="line-added">458   : SignatureStream(method-&gt;signature(), true)</span>
<span class="line-added">459 {</span>
<span class="line-added">460   initialize_load_origin(method-&gt;method_holder());</span>
<span class="line-added">461 }</span>
<span class="line-added">462 </span>
<span class="line-added">463 ResolvingSignatureStream::ResolvingSignatureStream(fieldDescriptor&amp; field)</span>
<span class="line-added">464   : SignatureStream(field.signature(), false)</span>
<span class="line-added">465 {</span>
<span class="line-added">466   initialize_load_origin(field.field_holder());</span>
<span class="line-added">467 }</span>
<span class="line-added">468 </span>
<span class="line-added">469 void ResolvingSignatureStream::cache_handles(TRAPS) {</span>
<span class="line-added">470   assert(_load_origin != NULL, &quot;&quot;);</span>
<span class="line-added">471   _class_loader = Handle(THREAD, _load_origin-&gt;class_loader());</span>
<span class="line-added">472   _protection_domain = Handle(THREAD, _load_origin-&gt;protection_domain());</span>
<span class="line-added">473 }</span>
<span class="line-added">474 </span>
<span class="line-added">475 Klass* ResolvingSignatureStream::as_klass_if_loaded(TRAPS) {</span>
<span class="line-added">476   Klass* klass = as_klass(CachedOrNull, THREAD);</span>
<span class="line-added">477   // SD::find does not trigger loading, so there should be no throws</span>
<span class="line-added">478   // Still, bad things can happen, so we CHECK_NULL and ask callers</span>
<span class="line-added">479   // to do likewise.</span>
<span class="line-added">480   if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-added">481     CLEAR_PENDING_EXCEPTION;</span>
<span class="line-added">482   }</span>
<span class="line-added">483   return klass;</span>
<span class="line-added">484 }</span>
<span class="line-added">485 </span>
486 #ifdef ASSERT
487 extern bool signature_constants_sane(); // called from basic_types_init()
488 
489 bool signature_constants_sane() {
490   // for the lookup table, test every 8-bit code point, and then some:
491   for (int i = -256; i &lt;= 256; i++) {
492     int btcode = 0;
493     switch (i) {
494 #define EACH_SIG(ch, bt, ignore) \
495     case ch: { btcode = bt; break; }
496     SIGNATURE_TYPES_DO(EACH_SIG, ignore)
497 #undef EACH_SIG
498     }
499     int btc = decode_signature_char(i);
500     assert(btc == btcode, &quot;misconfigured table: %d =&gt; %d not %d&quot;, i, btc, btcode);
501   }
502   return true;
503 }
504 
505 bool SignatureVerifier::is_valid_method_signature(const Symbol* sig) {
</pre>
</td>
</tr>
</table>
<center><a href="reflection.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="signature.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
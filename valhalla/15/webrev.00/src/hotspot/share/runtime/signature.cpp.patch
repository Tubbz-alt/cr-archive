diff a/src/hotspot/share/runtime/signature.cpp b/src/hotspot/share/runtime/signature.cpp
--- a/src/hotspot/share/runtime/signature.cpp
+++ b/src/hotspot/share/runtime/signature.cpp
@@ -383,11 +383,13 @@
   return ValueKlass::cast(k);
 }
 
 Klass* SignatureStream::as_klass(Handle class_loader, Handle protection_domain,
                                  FailureMode failure_mode, TRAPS) {
-  if (!is_reference())  return NULL;
+  if (!is_reference()) {
+    return NULL;
+  }
   Symbol* name = as_symbol();
   Klass* k = NULL;
   if (failure_mode == ReturnNull) {
     // Note:  SD::resolve_or_null returns NULL for most failure modes,
     // but not all.  Circularity errors, invalid PDs, etc., throw.
@@ -411,14 +413,17 @@
   return k;
 }
 
 oop SignatureStream::as_java_mirror(Handle class_loader, Handle protection_domain,
                                     FailureMode failure_mode, TRAPS) {
-  if (!is_reference())
+  if (!is_reference()) {
     return Universe::java_mirror(type());
-  Klass* klass = as_klass(class_loader, protection_domain, failure_mode, THREAD);
-  if (klass == NULL)  return NULL;
+  }
+  Klass* klass = as_klass(class_loader, protection_domain, failure_mode, CHECK_NULL);
+  if (klass == NULL) {
+    return NULL;
+  }
   if (klass->is_value()) {
     ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(klass));
     return _type == T_VALUETYPE ? vk->value_mirror() : vk->indirect_mirror();
   } else {
     assert(_type != T_VALUETYPE, "must not be value type");
@@ -430,10 +435,56 @@
   while (!at_return_type()) {
     next();
   }
 }
 
+ResolvingSignatureStream::ResolvingSignatureStream(Symbol* signature,
+                                                   Handle class_loader,
+                                                   Handle protection_domain,
+                                                   bool is_method)
+  : SignatureStream(signature, is_method),
+    _class_loader(class_loader), _protection_domain(protection_domain)
+{
+  initialize_load_origin(NULL);
+}
+
+ResolvingSignatureStream::ResolvingSignatureStream(Symbol* signature, Klass* load_origin, bool is_method)
+  : SignatureStream(signature, is_method)
+{
+  assert(load_origin != NULL, "");
+  initialize_load_origin(load_origin);
+}
+
+ResolvingSignatureStream::ResolvingSignatureStream(const Method* method)
+  : SignatureStream(method->signature(), true)
+{
+  initialize_load_origin(method->method_holder());
+}
+
+ResolvingSignatureStream::ResolvingSignatureStream(fieldDescriptor& field)
+  : SignatureStream(field.signature(), false)
+{
+  initialize_load_origin(field.field_holder());
+}
+
+void ResolvingSignatureStream::cache_handles(TRAPS) {
+  assert(_load_origin != NULL, "");
+  _class_loader = Handle(THREAD, _load_origin->class_loader());
+  _protection_domain = Handle(THREAD, _load_origin->protection_domain());
+}
+
+Klass* ResolvingSignatureStream::as_klass_if_loaded(TRAPS) {
+  Klass* klass = as_klass(CachedOrNull, THREAD);
+  // SD::find does not trigger loading, so there should be no throws
+  // Still, bad things can happen, so we CHECK_NULL and ask callers
+  // to do likewise.
+  if (HAS_PENDING_EXCEPTION) {
+    CLEAR_PENDING_EXCEPTION;
+  }
+  return klass;
+}
+
 #ifdef ASSERT
 extern bool signature_constants_sane(); // called from basic_types_init()
 
 bool signature_constants_sane() {
   // for the lookup table, test every 8-bit code point, and then some:

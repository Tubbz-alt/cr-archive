<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/reflection.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="signature.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/reflection.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;memory/universe.hpp&quot;
  39 #include &quot;oops/instanceKlass.hpp&quot;
  40 #include &quot;oops/objArrayKlass.hpp&quot;
  41 #include &quot;oops/objArrayOop.inline.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;oops/valueKlass.inline.hpp&quot;
  44 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  45 #include &quot;prims/jvmtiExport.hpp&quot;
  46 #include &quot;runtime/arguments.hpp&quot;
  47 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  48 #include &quot;runtime/handles.inline.hpp&quot;
  49 #include &quot;runtime/javaCalls.hpp&quot;
  50 #include &quot;runtime/reflection.hpp&quot;
  51 #include &quot;runtime/reflectionUtils.hpp&quot;
  52 #include &quot;runtime/signature.hpp&quot;
  53 #include &quot;runtime/thread.inline.hpp&quot;
  54 #include &quot;runtime/vframe.inline.hpp&quot;
  55 #include &quot;utilities/globalDefinitions.hpp&quot;
  56 
<span class="line-modified">  57 static void trace_class_resolution(const Klass* to_class) {</span>




  58   ResourceMark rm;
  59   int line_number = -1;
  60   const char * source_file = NULL;
  61   Klass* caller = NULL;
  62   JavaThread* jthread = JavaThread::current();
  63   if (jthread-&gt;has_last_Java_frame()) {
  64     vframeStream vfst(jthread);
  65     // skip over any frames belonging to java.lang.Class
  66     while (!vfst.at_end() &amp;&amp;
  67            vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class()) {
  68       vfst.next();
  69     }
  70     if (!vfst.at_end()) {
  71       // this frame is a likely suspect
  72       caller = vfst.method()-&gt;method_holder();
  73       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
  74       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
  75       if (s != NULL) {
  76         source_file = s-&gt;as_C_string();
  77       }
</pre>
<hr />
<pre>
 740     if (!inner_is_member &amp;&amp; ioff != 0 &amp;&amp; ooff == 0 &amp;&amp;
 741         cp-&gt;klass_name_at_matches(inner, ioff)) {
 742       Klass* i = cp-&gt;klass_at(ioff, CHECK);
 743       if (i == inner) {
 744         return;
 745       }
 746     }
 747   }
 748 
 749   // &#39;inner&#39; not declared as an inner klass in outer
 750   ResourceMark rm(THREAD);
 751   Exceptions::fthrow(
 752     THREAD_AND_LOCATION,
 753     vmSymbols::java_lang_IncompatibleClassChangeError(),
 754     &quot;%s and %s disagree on InnerClasses attribute&quot;,
 755     outer-&gt;external_name(),
 756     inner-&gt;external_name()
 757   );
 758 }
 759 
<span class="line-removed"> 760 // Returns Q-mirror if qtype_if_value is true and k is a ValueKlass;</span>
<span class="line-removed"> 761 // otherwise returns java_mirror or L-mirror for ValueKlass</span>
<span class="line-removed"> 762 static oop java_mirror(Klass* k, jboolean qtype_if_value) {</span>
<span class="line-removed"> 763   if (k-&gt;is_value()) {</span>
<span class="line-removed"> 764     ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(k));</span>
<span class="line-removed"> 765     return qtype_if_value ? vk-&gt;value_mirror() : vk-&gt;indirect_mirror();</span>
<span class="line-removed"> 766   } else {</span>
<span class="line-removed"> 767     return k-&gt;java_mirror();</span>
<span class="line-removed"> 768   }</span>
<span class="line-removed"> 769 }</span>
<span class="line-removed"> 770 </span>
<span class="line-removed"> 771 // Utility method converting a single SignatureStream element into java.lang.Class instance</span>
<span class="line-removed"> 772 static oop get_mirror_from_signature(const methodHandle&amp; method,</span>
<span class="line-removed"> 773                                      SignatureStream* ss,</span>
<span class="line-removed"> 774                                      TRAPS) {</span>
<span class="line-removed"> 775 </span>
<span class="line-removed"> 776   BasicType bt = ss-&gt;type();</span>
<span class="line-removed"> 777   if (is_reference_type(ss-&gt;type())) {</span>
<span class="line-removed"> 778     Symbol* name = ss-&gt;as_symbol();</span>
<span class="line-removed"> 779     oop loader = method-&gt;method_holder()-&gt;class_loader();</span>
<span class="line-removed"> 780     oop protection_domain = method-&gt;method_holder()-&gt;protection_domain();</span>
<span class="line-removed"> 781     const Klass* k = SystemDictionary::resolve_or_fail(name,</span>
<span class="line-removed"> 782                                                        Handle(THREAD, loader),</span>
<span class="line-removed"> 783                                                        Handle(THREAD, protection_domain),</span>
<span class="line-removed"> 784                                                        true,</span>
<span class="line-removed"> 785                                                        CHECK_NULL);</span>
<span class="line-removed"> 786     if (log_is_enabled(Debug, class, resolve)) {</span>
<span class="line-removed"> 787       trace_class_resolution(k);</span>
<span class="line-removed"> 788     }</span>
<span class="line-removed"> 789     return java_mirror((Klass*)k, bt == T_VALUETYPE);</span>
<span class="line-removed"> 790   }</span>
<span class="line-removed"> 791 </span>
<span class="line-removed"> 792   assert(bt != T_VOID || ss-&gt;at_return_type(),</span>
<span class="line-removed"> 793     &quot;T_VOID should only appear as return type&quot;);</span>
<span class="line-removed"> 794 </span>
<span class="line-removed"> 795   return java_lang_Class::primitive_mirror(bt);</span>
<span class="line-removed"> 796 }</span>
<span class="line-removed"> 797 </span>
 798 static objArrayHandle get_parameter_types(const methodHandle&amp; method,
 799                                           int parameter_count,
 800                                           oop* return_type,
 801                                           TRAPS) {
 802   // Allocate array holding parameter types (java.lang.Class instances)
 803   objArrayOop m = oopFactory::new_objArray(SystemDictionary::Class_klass(), parameter_count, CHECK_(objArrayHandle()));
 804   objArrayHandle mirrors(THREAD, m);
 805   int index = 0;
 806   // Collect parameter types
 807   ResourceMark rm(THREAD);
<span class="line-modified"> 808   Symbol*  signature = method-&gt;signature();</span>
<span class="line-modified"> 809   SignatureStream ss(signature);</span>
<span class="line-modified"> 810   while (!ss.at_return_type()) {</span>
<span class="line-modified"> 811     oop mirror = get_mirror_from_signature(method, &amp;ss, CHECK_(objArrayHandle()));</span>
<span class="line-modified"> 812     mirrors-&gt;obj_at_put(index++, mirror);</span>
<span class="line-modified"> 813     ss.next();</span>






 814   }
 815   assert(index == parameter_count, &quot;invalid parameter count&quot;);
<span class="line-removed"> 816   if (return_type != NULL) {</span>
<span class="line-removed"> 817     // Collect return type as well</span>
<span class="line-removed"> 818     assert(ss.at_return_type(), &quot;return type should be present&quot;);</span>
<span class="line-removed"> 819     *return_type = get_mirror_from_signature(method, &amp;ss, CHECK_(objArrayHandle()));</span>
<span class="line-removed"> 820   }</span>
 821   return mirrors;
 822 }
 823 
 824 static objArrayHandle get_exception_types(const methodHandle&amp; method, TRAPS) {
 825   return method-&gt;resolved_checked_exceptions(THREAD);
 826 }
 827 
 828 static Handle new_type(Symbol* signature, Klass* k, TRAPS) {
<span class="line-modified"> 829   SignatureStream ss(signature, false);</span>
<span class="line-modified"> 830   // Basic types</span>
<span class="line-removed"> 831   BasicType type = ss.type();</span>
<span class="line-removed"> 832   if (!ss.is_reference()) {</span>
<span class="line-removed"> 833     return Handle(THREAD, Universe::java_mirror(type));</span>
<span class="line-removed"> 834   }</span>
<span class="line-removed"> 835 </span>
<span class="line-removed"> 836   Klass* result =</span>
<span class="line-removed"> 837     SystemDictionary::resolve_or_fail(signature,</span>
<span class="line-removed"> 838                                       Handle(THREAD, k-&gt;class_loader()),</span>
<span class="line-removed"> 839                                       Handle(THREAD, k-&gt;protection_domain()),</span>
<span class="line-removed"> 840                                       true, CHECK_(Handle()));</span>
<span class="line-removed"> 841 </span>
<span class="line-removed"> 842   if (log_is_enabled(Debug, class, resolve)) {</span>
<span class="line-removed"> 843     trace_class_resolution(result);</span>
<span class="line-removed"> 844   }</span>
<span class="line-removed"> 845   oop nt = java_mirror(result, type == T_VALUETYPE);</span>
 846   return Handle(THREAD, nt);
 847 }
 848 
 849 
 850 oop Reflection::new_method(const methodHandle&amp; method, bool for_constant_pool_access, TRAPS) {
 851   // Allow sun.reflect.ConstantPool to refer to &lt;clinit&gt; methods as java.lang.reflect.Methods.
 852   assert(!method()-&gt;name()-&gt;starts_with(&#39;&lt;&#39;) || for_constant_pool_access,
 853          &quot;should call new_constructor instead&quot;);
 854   InstanceKlass* holder = method-&gt;method_holder();
 855   int slot = method-&gt;method_idnum();
 856 
 857   Symbol*  signature  = method-&gt;signature();
 858   int parameter_count = ArgumentCount(signature).size();
 859   oop return_type_oop = NULL;
 860   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, &amp;return_type_oop, CHECK_NULL);
 861   if (parameter_types.is_null() || return_type_oop == NULL) return NULL;
 862 
 863   Handle return_type(THREAD, return_type_oop);
 864 
 865   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
</pre>
</td>
<td>
<hr />
<pre>
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;memory/universe.hpp&quot;
  39 #include &quot;oops/instanceKlass.hpp&quot;
  40 #include &quot;oops/objArrayKlass.hpp&quot;
  41 #include &quot;oops/objArrayOop.inline.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;oops/valueKlass.inline.hpp&quot;
  44 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  45 #include &quot;prims/jvmtiExport.hpp&quot;
  46 #include &quot;runtime/arguments.hpp&quot;
  47 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  48 #include &quot;runtime/handles.inline.hpp&quot;
  49 #include &quot;runtime/javaCalls.hpp&quot;
  50 #include &quot;runtime/reflection.hpp&quot;
  51 #include &quot;runtime/reflectionUtils.hpp&quot;
  52 #include &quot;runtime/signature.hpp&quot;
  53 #include &quot;runtime/thread.inline.hpp&quot;
  54 #include &quot;runtime/vframe.inline.hpp&quot;
  55 #include &quot;utilities/globalDefinitions.hpp&quot;
  56 
<span class="line-modified">  57 static void trace_class_resolution(oop mirror) {</span>
<span class="line-added">  58   if (mirror == NULL || java_lang_Class::is_primitive(mirror)) {</span>
<span class="line-added">  59     return;</span>
<span class="line-added">  60   }</span>
<span class="line-added">  61   Klass* to_class = java_lang_Class::as_Klass(mirror);</span>
  62   ResourceMark rm;
  63   int line_number = -1;
  64   const char * source_file = NULL;
  65   Klass* caller = NULL;
  66   JavaThread* jthread = JavaThread::current();
  67   if (jthread-&gt;has_last_Java_frame()) {
  68     vframeStream vfst(jthread);
  69     // skip over any frames belonging to java.lang.Class
  70     while (!vfst.at_end() &amp;&amp;
  71            vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class()) {
  72       vfst.next();
  73     }
  74     if (!vfst.at_end()) {
  75       // this frame is a likely suspect
  76       caller = vfst.method()-&gt;method_holder();
  77       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
  78       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
  79       if (s != NULL) {
  80         source_file = s-&gt;as_C_string();
  81       }
</pre>
<hr />
<pre>
 744     if (!inner_is_member &amp;&amp; ioff != 0 &amp;&amp; ooff == 0 &amp;&amp;
 745         cp-&gt;klass_name_at_matches(inner, ioff)) {
 746       Klass* i = cp-&gt;klass_at(ioff, CHECK);
 747       if (i == inner) {
 748         return;
 749       }
 750     }
 751   }
 752 
 753   // &#39;inner&#39; not declared as an inner klass in outer
 754   ResourceMark rm(THREAD);
 755   Exceptions::fthrow(
 756     THREAD_AND_LOCATION,
 757     vmSymbols::java_lang_IncompatibleClassChangeError(),
 758     &quot;%s and %s disagree on InnerClasses attribute&quot;,
 759     outer-&gt;external_name(),
 760     inner-&gt;external_name()
 761   );
 762 }
 763 






































 764 static objArrayHandle get_parameter_types(const methodHandle&amp; method,
 765                                           int parameter_count,
 766                                           oop* return_type,
 767                                           TRAPS) {
 768   // Allocate array holding parameter types (java.lang.Class instances)
 769   objArrayOop m = oopFactory::new_objArray(SystemDictionary::Class_klass(), parameter_count, CHECK_(objArrayHandle()));
 770   objArrayHandle mirrors(THREAD, m);
 771   int index = 0;
 772   // Collect parameter types
 773   ResourceMark rm(THREAD);
<span class="line-modified"> 774   for (ResolvingSignatureStream ss(method()); !ss.is_done(); ss.next()) {</span>
<span class="line-modified"> 775     oop mirror = ss.as_java_mirror(SignatureStream::NCDFError, CHECK_(objArrayHandle()));</span>
<span class="line-modified"> 776     if (log_is_enabled(Debug, class, resolve)) {</span>
<span class="line-modified"> 777       trace_class_resolution(mirror);</span>
<span class="line-modified"> 778     }</span>
<span class="line-modified"> 779     if (!ss.at_return_type()) {</span>
<span class="line-added"> 780       mirrors-&gt;obj_at_put(index++, mirror);</span>
<span class="line-added"> 781     } else if (return_type != NULL) {</span>
<span class="line-added"> 782       // Collect return type as well</span>
<span class="line-added"> 783       assert(ss.at_return_type(), &quot;return type should be present&quot;);</span>
<span class="line-added"> 784       *return_type = mirror;</span>
<span class="line-added"> 785     }</span>
 786   }
 787   assert(index == parameter_count, &quot;invalid parameter count&quot;);





 788   return mirrors;
 789 }
 790 
 791 static objArrayHandle get_exception_types(const methodHandle&amp; method, TRAPS) {
 792   return method-&gt;resolved_checked_exceptions(THREAD);
 793 }
 794 
 795 static Handle new_type(Symbol* signature, Klass* k, TRAPS) {
<span class="line-modified"> 796   ResolvingSignatureStream ss(signature, k, false);</span>
<span class="line-modified"> 797   oop nt = ss.as_java_mirror(SignatureStream::NCDFError, CHECK_NH);</span>















 798   return Handle(THREAD, nt);
 799 }
 800 
 801 
 802 oop Reflection::new_method(const methodHandle&amp; method, bool for_constant_pool_access, TRAPS) {
 803   // Allow sun.reflect.ConstantPool to refer to &lt;clinit&gt; methods as java.lang.reflect.Methods.
 804   assert(!method()-&gt;name()-&gt;starts_with(&#39;&lt;&#39;) || for_constant_pool_access,
 805          &quot;should call new_constructor instead&quot;);
 806   InstanceKlass* holder = method-&gt;method_holder();
 807   int slot = method-&gt;method_idnum();
 808 
 809   Symbol*  signature  = method-&gt;signature();
 810   int parameter_count = ArgumentCount(signature).size();
 811   oop return_type_oop = NULL;
 812   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, &amp;return_type_oop, CHECK_NULL);
 813   if (parameter_types.is_null() || return_type_oop == NULL) return NULL;
 814 
 815   Handle return_type(THREAD, return_type_oop);
 816 
 817   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
</pre>
</td>
</tr>
</table>
<center><a href="os.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="signature.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
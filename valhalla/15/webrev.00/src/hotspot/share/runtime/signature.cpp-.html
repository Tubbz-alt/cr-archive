<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/signature.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/symbolTable.hpp&quot;
 27 #include &quot;classfile/systemDictionary.hpp&quot;
 28 #include &quot;memory/oopFactory.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;memory/universe.hpp&quot;
 31 #include &quot;oops/instanceKlass.hpp&quot;
 32 #include &quot;oops/oop.inline.hpp&quot;
 33 #include &quot;oops/symbol.hpp&quot;
 34 #include &quot;oops/typeArrayKlass.hpp&quot;
 35 #include &quot;oops/valueKlass.inline.hpp&quot;
 36 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/safepointVerifiers.hpp&quot;
 39 #include &quot;runtime/signature.hpp&quot;
 40 
 41 // Implementation of SignatureIterator
 42 
 43 // Signature syntax:
 44 //
 45 // Signature  = &quot;(&quot; {Parameter} &quot;)&quot; ReturnType.
 46 // Parameter  = FieldType.
 47 // ReturnType = FieldType | &quot;V&quot;.
 48 // FieldType  = &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;F&quot; | &quot;I&quot; | &quot;J&quot; | &quot;S&quot; | &quot;Z&quot; | &quot;L&quot; ClassName &quot;;&quot; | &quot;Q&quot; ValueClassName &quot;;&quot; | &quot;[&quot; FieldType.
 49 // ClassName  = string.
 50 
 51 // The ClassName string can be any JVM-style UTF8 string except:
 52 //  - an empty string (the empty string is never a name of any kind)
 53 //  - a string which begins or ends with slash &#39;/&#39; (the package separator)
 54 //  - a string which contains adjacent slashes &#39;//&#39; (no empty package names)
 55 //  - a string which contains a semicolon &#39;;&#39; (the end-delimiter)
 56 //  - a string which contains a left bracket &#39;[&#39; (the array marker)
 57 //  - a string which contains a dot &#39;.&#39; (the external package separator)
 58 //
 59 // Other &quot;meta-looking&quot; characters, such as &#39;(&#39; and &#39;&lt;&#39; and &#39;+&#39;,
 60 // are perfectly legitimate within a class name, for the JVM.
 61 // Class names which contain double slashes (&#39;a//b&#39;) and non-initial
 62 // brackets (&#39;a[b]&#39;) are reserved for possible enrichment of the
 63 // type language.
 64 
 65 void SignatureIterator::set_fingerprint(fingerprint_t fingerprint) {
 66   if (!fp_is_valid(fingerprint)) {
 67     _fingerprint = fingerprint;
 68     _return_type = T_ILLEGAL;
 69   } else if (fingerprint != _fingerprint) {
 70     assert(_fingerprint == zero_fingerprint(), &quot;consistent fingerprint values&quot;);
 71     _fingerprint = fingerprint;
 72     _return_type = fp_return_type(fingerprint);
 73   }
 74 }
 75 
 76 BasicType SignatureIterator::return_type() {
 77   if (_return_type == T_ILLEGAL) {
 78     SignatureStream ss(_signature);
 79     ss.skip_to_return_type();
 80     _return_type = ss.type();
 81     assert(_return_type != T_ILLEGAL, &quot;illegal return type&quot;);
 82   }
 83   return _return_type;
 84 }
 85 
 86 bool SignatureIterator::fp_is_valid_type(BasicType type, bool for_return_type) {
 87   assert(type != (BasicType)fp_parameters_done, &quot;fingerprint is incorrectly at done&quot;);
 88   assert(((int)type &amp; ~fp_parameter_feature_mask) == 0, &quot;fingerprint feature mask yielded non-zero value&quot;);
 89   return (is_java_primitive(type) ||
 90           is_reference_type(type) ||
 91           (for_return_type &amp;&amp; type == T_VOID));
 92 }
 93 
 94 ArgumentSizeComputer::ArgumentSizeComputer(Symbol* signature)
 95   : SignatureIterator(signature)
 96 {
 97   _size = 0;
 98   do_parameters_on(this);  // non-virtual template execution
 99 }
100 
101 ArgumentCount::ArgumentCount(Symbol* signature)
102   : SignatureIterator(signature)
103 {
104   _size = 0;
105   do_parameters_on(this);  // non-virtual template execution
106 }
107 
108 ReferenceArgumentCount::ReferenceArgumentCount(Symbol* signature)
109   : SignatureIterator(signature)
110 {
111   _refs = 0;
112   do_parameters_on(this);  // non-virtual template execution
113 }
114 
115 void Fingerprinter::compute_fingerprint_and_return_type(bool static_flag) {
116   // See if we fingerprinted this method already
117   if (_method != NULL) {
118     assert(!static_flag, &quot;must not be passed by caller&quot;);
119     static_flag = _method-&gt;is_static();
120     _fingerprint = _method-&gt;constMethod()-&gt;fingerprint();
121 
122     if (_fingerprint != zero_fingerprint()) {
123       _return_type = _method-&gt;result_type();
124       assert(is_java_type(_return_type), &quot;return type must be a java type&quot;);
125       return;
126     }
127 
128     if (_method-&gt;size_of_parameters() &gt; fp_max_size_of_parameters) {
129       _fingerprint = overflow_fingerprint();
130       _method-&gt;constMethod()-&gt;set_fingerprint(_fingerprint);
131       // as long as we are here compute the return type:
132       _return_type = ResultTypeFinder(_method-&gt;signature()).type();
133       assert(is_java_type(_return_type), &quot;return type must be a java type&quot;);
134       return;
135     }
136   }
137 
138   // Note:  This will always take the slow path, since _fp==zero_fp.
139   initialize_accumulator();
140   do_parameters_on(this);
141   assert(fp_is_valid_type(_return_type, true), &quot;bad result type&quot;);
142 
143   // Fill in the return type and static bits:
144   _accumulator |= _return_type &lt;&lt; fp_static_feature_size;
145   if (static_flag) {
146     _accumulator |= fp_is_static_bit;
147   } else {
148     _param_size += 1;  // this is the convention for Method::compute_size_of_parameters
149   }
150 
151   // Detect overflow.  (We counted _param_size correctly.)
152   if (_method == NULL &amp;&amp; _param_size &gt; fp_max_size_of_parameters) {
153     // We did a one-pass computation of argument size, return type,
154     // and fingerprint.
155     _fingerprint = overflow_fingerprint();
156     return;
157   }
158 
159   assert(_shift_count &lt; BitsPerLong,
160          &quot;shift count overflow %d (%d vs. %d): %s&quot;,
161          _shift_count, _param_size, fp_max_size_of_parameters,
162          _signature-&gt;as_C_string());
163   assert((_accumulator &gt;&gt; _shift_count) == fp_parameters_done, &quot;must be zero&quot;);
164 
165   // This is the result, along with _return_type:
166   _fingerprint = _accumulator;
167 
168   // Cache the result on the method itself:
169   if (_method != NULL) {
170     _method-&gt;constMethod()-&gt;set_fingerprint(_fingerprint);
171   }
172 }
173 
174 // Implementation of SignatureStream
175 
176 static inline BasicType decode_signature_char(int ch) {
177   switch (ch) {
178 #define EACH_SIG(ch, bt, ignore) \
179     case ch: return bt;
180     SIGNATURE_TYPES_DO(EACH_SIG, ignore)
181 #undef EACH_SIG
182   }
183   return (BasicType)0;
184 }
185 
186 SignatureStream::SignatureStream(const Symbol* signature,
187                                  bool is_method) {
188   assert(!is_method || signature-&gt;starts_with(JVM_SIGNATURE_FUNC),
189          &quot;method signature required&quot;);
190   _signature = signature;
191   _limit = signature-&gt;utf8_length();
192   int oz = (is_method ? _s_method : _s_field);
193   _state = oz;
194   _begin = _end = oz; // skip first &#39;(&#39; in method signatures
195   _array_prefix = 0;  // just for definiteness
196 
197   // assigning java/lang/Object to _previous_name means we can
198   // avoid a number of NULL checks in the parser
199   _previous_name = vmSymbols::java_lang_Object();
200   _names = NULL;
201   next();
202 }
203 
204 SignatureStream::~SignatureStream() {
205   // decrement refcount for names created during signature parsing
206   _previous_name-&gt;decrement_refcount();
207   if (_names != NULL) {
208     for (int i = 0; i &lt; _names-&gt;length(); i++) {
209       _names-&gt;at(i)-&gt;decrement_refcount();
210     }
211   }
212 }
213 
214 inline int SignatureStream::scan_type(BasicType type) {
215   const u1* base = _signature-&gt;bytes();
216   int end = _end;
217   int limit = _limit;
218   const u1* tem;
219   switch (type) {
220   case T_OBJECT:
221   case T_VALUETYPE:
222     tem = (const u1*) memchr(&amp;base[end], JVM_SIGNATURE_ENDCLASS, limit - end);
223     return (tem == NULL ? limit : tem + 1 - base);
224 
225   case T_ARRAY:
226     while ((end &lt; limit) &amp;&amp; ((char)base[end] == JVM_SIGNATURE_ARRAY)) { end++; }
227     _array_prefix = end - _end;  // number of &#39;[&#39; chars just skipped
228     if (Signature::has_envelope(base[end])) {
229       tem = (const u1 *) memchr(&amp;base[end], JVM_SIGNATURE_ENDCLASS, limit - end);
230       return (tem == NULL ? limit : tem + 1 - base);
231     }
232     // Skipping over a single character for a primitive type.
233     assert(is_java_primitive(decode_signature_char(base[end])), &quot;only primitives expected&quot;);
234     return end + 1;
235 
236   default:
237     // Skipping over a single character for a primitive type (or void).
238     assert(!is_reference_type(type), &quot;only primitives or void expected&quot;);
239     return end + 1;
240   }
241 }
242 
243 void SignatureStream::next() {
244   const Symbol* sig = _signature;
245   int len = _limit;
246   if (_end &gt;= len) { set_done(); return; }
247   _begin = _end;
248   int ch = sig-&gt;char_at(_begin);
249   if (ch == JVM_SIGNATURE_ENDFUNC) {
250     assert(_state == _s_method, &quot;must be in method&quot;);
251     _state = _s_method_return;
252     _begin = ++_end;
253     if (_end &gt;= len) { set_done(); return; }
254     ch = sig-&gt;char_at(_begin);
255   }
256   BasicType bt = decode_signature_char(ch);
257   assert(ch == type2char(bt), &quot;bad signature char %c/%d&quot;, ch, ch);
258   _type = bt;
259   _end = scan_type(bt);
260 }
261 
262 int SignatureStream::skip_whole_array_prefix() {
263   assert(_type == T_ARRAY, &quot;must be&quot;);
264 
265   // we are stripping all levels of T_ARRAY,
266   // so we must decode the next character
267   int whole_array_prefix = _array_prefix;
268   int new_begin = _begin + whole_array_prefix;
269   _begin = new_begin;
270   int ch = _signature-&gt;char_at(new_begin);
271   BasicType bt = decode_signature_char(ch);
272   assert(ch == type2char(bt), &quot;bad signature char %c/%d&quot;, ch, ch);
273   _type = bt;
274   assert(bt != T_VOID &amp;&amp; bt != T_ARRAY, &quot;bad signature type&quot;);
275   // Don&#39;t bother to re-scan, since it won&#39;t change the value of _end.
276   return whole_array_prefix;
277 }
278 
279 bool Signature::is_valid_array_signature(const Symbol* sig) {
280   assert(sig-&gt;utf8_length() &gt; 1, &quot;this should already have been checked&quot;);
281   assert(sig-&gt;char_at(0) == JVM_SIGNATURE_ARRAY, &quot;this should already have been checked&quot;);
282   // The first character is already checked
283   int i = 1;
284   int len = sig-&gt;utf8_length();
285   // First skip all &#39;[&#39;s
286   while(i &lt; len - 1 &amp;&amp; sig-&gt;char_at(i) == JVM_SIGNATURE_ARRAY) i++;
287 
288   // Check type
289   switch(sig-&gt;char_at(i)) {
290   case JVM_SIGNATURE_BYTE:
291   case JVM_SIGNATURE_CHAR:
292   case JVM_SIGNATURE_DOUBLE:
293   case JVM_SIGNATURE_FLOAT:
294   case JVM_SIGNATURE_INT:
295   case JVM_SIGNATURE_LONG:
296   case JVM_SIGNATURE_SHORT:
297   case JVM_SIGNATURE_BOOLEAN:
298     // If it is an array, the type is the last character
299     return (i + 1 == len);
300   case JVM_SIGNATURE_CLASS:
301   case JVM_SIGNATURE_VALUETYPE:
302     // If it is an object, the last character must be a &#39;;&#39;
303     return sig-&gt;char_at(len - 1) == JVM_SIGNATURE_ENDCLASS;
304   }
305   return false;
306 }
307 
308 BasicType Signature::basic_type(int ch) {
309   BasicType btcode = decode_signature_char(ch);
310   if (btcode == 0)  return T_ILLEGAL;
311   return btcode;
312 }
313 
314 static const int jl_len = 10, object_len = 6, jl_object_len = jl_len + object_len;
315 static const char jl_str[] = &quot;java/lang/&quot;;
316 
317 #ifdef ASSERT
318 static bool signature_symbols_sane() {
319   static bool done;
320   if (done)  return true;
321   done = true;
322   // test some tense code that looks for common symbol names:
323   assert(vmSymbols::java_lang_Object()-&gt;utf8_length() == jl_object_len &amp;&amp;
324          vmSymbols::java_lang_Object()-&gt;starts_with(jl_str, jl_len) &amp;&amp;
325          vmSymbols::java_lang_Object()-&gt;ends_with(&quot;Object&quot;, object_len) &amp;&amp;
326          vmSymbols::java_lang_Object()-&gt;is_permanent() &amp;&amp;
327          vmSymbols::java_lang_String()-&gt;utf8_length() == jl_object_len &amp;&amp;
328          vmSymbols::java_lang_String()-&gt;starts_with(jl_str, jl_len) &amp;&amp;
329          vmSymbols::java_lang_String()-&gt;ends_with(&quot;String&quot;, object_len) &amp;&amp;
330          vmSymbols::java_lang_String()-&gt;is_permanent(),
331          &quot;sanity&quot;);
332   return true;
333 }
334 #endif //ASSERT
335 
336 // returns a symbol; the caller is responsible for decrementing it
337 Symbol* SignatureStream::find_symbol() {
338   // Create a symbol from for string _begin _end
339   int begin = raw_symbol_begin();
340   int end   = raw_symbol_end();
341 
342   const char* symbol_chars = (const char*)_signature-&gt;base() + begin;
343   int len = end - begin;
344 
345   // Quick check for common symbols in signatures
346   assert(signature_symbols_sane(), &quot;incorrect signature sanity check&quot;);
347   if (len == jl_object_len &amp;&amp;
348       memcmp(symbol_chars, jl_str, jl_len) == 0) {
349     if (memcmp(&quot;String&quot;, symbol_chars + jl_len, object_len) == 0) {
350       return vmSymbols::java_lang_String();
351     } else if (memcmp(&quot;Object&quot;, symbol_chars + jl_len, object_len) == 0) {
352       return vmSymbols::java_lang_Object();
353     }
354   }
355 
356   Symbol* name = _previous_name;
357   if (name-&gt;equals(symbol_chars, len)) {
358     return name;
359   }
360 
361   // Save names for cleaning up reference count at the end of
362   // SignatureStream scope.
363   name = SymbolTable::new_symbol(symbol_chars, len);
364 
365   // Only allocate the GrowableArray for the _names buffer if more than
366   // one name is being processed in the signature.
367   if (!_previous_name-&gt;is_permanent()) {
368     if (_names == NULL) {
369       _names = new GrowableArray&lt;Symbol*&gt;(10);
370     }
371     _names-&gt;push(_previous_name);
372   }
373   _previous_name = name;
374   return name;
375 }
376 
377 ValueKlass* SignatureStream::as_value_klass(InstanceKlass* holder) {
378   Thread* THREAD = Thread::current();
379   Handle class_loader(THREAD, holder-&gt;class_loader());
380   Handle protection_domain(THREAD, holder-&gt;protection_domain());
381   Klass* k = as_klass(class_loader, protection_domain, SignatureStream::ReturnNull, THREAD);
382   assert(k != NULL &amp;&amp; !HAS_PENDING_EXCEPTION, &quot;unresolved value klass&quot;);
383   return ValueKlass::cast(k);
384 }
385 
386 Klass* SignatureStream::as_klass(Handle class_loader, Handle protection_domain,
387                                  FailureMode failure_mode, TRAPS) {
388   if (!is_reference())  return NULL;
389   Symbol* name = as_symbol();
390   Klass* k = NULL;
391   if (failure_mode == ReturnNull) {
392     // Note:  SD::resolve_or_null returns NULL for most failure modes,
393     // but not all.  Circularity errors, invalid PDs, etc., throw.
394     k = SystemDictionary::resolve_or_null(name, class_loader, protection_domain, CHECK_NULL);
395   } else if (failure_mode == CachedOrNull) {
396     NoSafepointVerifier nsv;  // no loading, now, we mean it!
397     assert(!HAS_PENDING_EXCEPTION, &quot;&quot;);
398     k = SystemDictionary::find(name, class_loader, protection_domain, CHECK_NULL);
399     // SD::find does not trigger loading, so there should be no throws
400     // Still, bad things can happen, so we CHECK_NULL and ask callers
401     // to do likewise.
402     return k;
403   } else {
404     // The only remaining failure mode is NCDFError.
405     // The test here allows for an additional mode CNFException
406     // if callers need to request the reflective error instead.
407     bool throw_error = (failure_mode == NCDFError);
408     k = SystemDictionary::resolve_or_fail(name, class_loader, protection_domain, throw_error, CHECK_NULL);
409   }
410 
411   return k;
412 }
413 
414 oop SignatureStream::as_java_mirror(Handle class_loader, Handle protection_domain,
415                                     FailureMode failure_mode, TRAPS) {
416   if (!is_reference())
417     return Universe::java_mirror(type());
418   Klass* klass = as_klass(class_loader, protection_domain, failure_mode, THREAD);
419   if (klass == NULL)  return NULL;
420   if (klass-&gt;is_value()) {
421     ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(klass));
422     return _type == T_VALUETYPE ? vk-&gt;value_mirror() : vk-&gt;indirect_mirror();
423   } else {
424     assert(_type != T_VALUETYPE, &quot;must not be value type&quot;);
425     return klass-&gt;java_mirror();
426   }
427 }
428 
429 void SignatureStream::skip_to_return_type() {
430   while (!at_return_type()) {
431     next();
432   }
433 }
434 
435 #ifdef ASSERT
436 extern bool signature_constants_sane(); // called from basic_types_init()
437 
438 bool signature_constants_sane() {
439   // for the lookup table, test every 8-bit code point, and then some:
440   for (int i = -256; i &lt;= 256; i++) {
441     int btcode = 0;
442     switch (i) {
443 #define EACH_SIG(ch, bt, ignore) \
444     case ch: { btcode = bt; break; }
445     SIGNATURE_TYPES_DO(EACH_SIG, ignore)
446 #undef EACH_SIG
447     }
448     int btc = decode_signature_char(i);
449     assert(btc == btcode, &quot;misconfigured table: %d =&gt; %d not %d&quot;, i, btc, btcode);
450   }
451   return true;
452 }
453 
454 bool SignatureVerifier::is_valid_method_signature(const Symbol* sig) {
455   const char* method_sig = (const char*)sig-&gt;bytes();
456   ssize_t len = sig-&gt;utf8_length();
457   ssize_t index = 0;
458   if (method_sig != NULL &amp;&amp; len &gt; 1 &amp;&amp; method_sig[index] == JVM_SIGNATURE_FUNC) {
459     ++index;
460     while (index &lt; len &amp;&amp; method_sig[index] != JVM_SIGNATURE_ENDFUNC) {
461       ssize_t res = is_valid_type(&amp;method_sig[index], len - index);
462       if (res == -1) {
463         return false;
464       } else {
465         index += res;
466       }
467     }
468     if (index &lt; len &amp;&amp; method_sig[index] == JVM_SIGNATURE_ENDFUNC) {
469       // check the return type
470       ++index;
471       return (is_valid_type(&amp;method_sig[index], len - index) == (len - index));
472     }
473   }
474   return false;
475 }
476 
477 bool SignatureVerifier::is_valid_type_signature(const Symbol* sig) {
478   const char* type_sig = (const char*)sig-&gt;bytes();
479   ssize_t len = sig-&gt;utf8_length();
480   return (type_sig != NULL &amp;&amp; len &gt;= 1 &amp;&amp;
481           (is_valid_type(type_sig, len) == len));
482 }
483 
484 // Checks to see if the type (not to go beyond &#39;limit&#39;) refers to a valid type.
485 // Returns -1 if it is not, or the index of the next character that is not part
486 // of the type.  The type encoding may end before &#39;limit&#39; and that&#39;s ok.
487 ssize_t SignatureVerifier::is_valid_type(const char* type, ssize_t limit) {
488   ssize_t index = 0;
489 
490   // Iterate over any number of array dimensions
491   while (index &lt; limit &amp;&amp; type[index] == JVM_SIGNATURE_ARRAY) ++index;
492   if (index &gt;= limit) {
493     return -1;
494   }
495   switch (type[index]) {
496     case JVM_SIGNATURE_BYTE:
497     case JVM_SIGNATURE_CHAR:
498     case JVM_SIGNATURE_FLOAT:
499     case JVM_SIGNATURE_DOUBLE:
500     case JVM_SIGNATURE_INT:
501     case JVM_SIGNATURE_LONG:
502     case JVM_SIGNATURE_SHORT:
503     case JVM_SIGNATURE_BOOLEAN:
504     case JVM_SIGNATURE_VOID:
505       return index + 1;
506     case JVM_SIGNATURE_VALUETYPE: // fall through
507     case JVM_SIGNATURE_CLASS:
508       for (index = index + 1; index &lt; limit; ++index) {
509         char c = type[index];
510         switch (c) {
511           case JVM_SIGNATURE_ENDCLASS:
512             return index + 1;
513           case &#39;\0&#39;: case JVM_SIGNATURE_DOT: case JVM_SIGNATURE_ARRAY:
514             return -1;
515           default: ; // fall through
516         }
517       }
518       // fall through
519     default: ; // fall through
520   }
521   return -1;
522 }
523 
524 #endif // ASSERT
525 
526 // Adds an argument to the signature
527 void SigEntry::add_entry(GrowableArray&lt;SigEntry&gt;* sig, BasicType bt, int offset) {
528   sig-&gt;append(SigEntry(bt, offset));
529   if (bt == T_LONG || bt == T_DOUBLE) {
530     sig-&gt;append(SigEntry(T_VOID, offset)); // Longs and doubles take two stack slots
531   }
532 }
533 
534 // Inserts a reserved argument at position &#39;i&#39;
535 void SigEntry::insert_reserved_entry(GrowableArray&lt;SigEntry&gt;* sig, int i, BasicType bt) {
536   if (bt == T_OBJECT || bt == T_ARRAY || bt == T_VALUETYPE) {
537     // Treat this as INT to not confuse the GC
538     bt = T_INT;
539   } else if (bt == T_LONG || bt == T_DOUBLE) {
540     // Longs and doubles take two stack slots
541     sig-&gt;insert_before(i, SigEntry(T_VOID, SigEntry::ReservedOffset));
542   }
543   sig-&gt;insert_before(i, SigEntry(bt, SigEntry::ReservedOffset));
544 }
545 
546 // Returns true if the argument at index &#39;i&#39; is a reserved argument
547 bool SigEntry::is_reserved_entry(const GrowableArray&lt;SigEntry&gt;* sig, int i) {
548   return sig-&gt;at(i)._offset == SigEntry::ReservedOffset;
549 }
550 
551 // Returns true if the argument at index &#39;i&#39; is not a value type delimiter
552 bool SigEntry::skip_value_delimiters(const GrowableArray&lt;SigEntry&gt;* sig, int i) {
553   return (sig-&gt;at(i)._bt != T_VALUETYPE &amp;&amp;
554           (sig-&gt;at(i)._bt != T_VOID || sig-&gt;at(i-1)._bt == T_LONG || sig-&gt;at(i-1)._bt == T_DOUBLE));
555 }
556 
557 // Fill basic type array from signature array
558 int SigEntry::fill_sig_bt(const GrowableArray&lt;SigEntry&gt;* sig, BasicType* sig_bt) {
559   int count = 0;
560   for (int i = 0; i &lt; sig-&gt;length(); i++) {
561     if (skip_value_delimiters(sig, i)) {
562       sig_bt[count++] = sig-&gt;at(i)._bt;
563     }
564   }
565   return count;
566 }
567 
568 // Create a temporary symbol from the signature array
569 TempNewSymbol SigEntry::create_symbol(const GrowableArray&lt;SigEntry&gt;* sig) {
570   ResourceMark rm;
571   int length = sig-&gt;length();
572   char* sig_str = NEW_RESOURCE_ARRAY(char, 2*length + 3);
573   int idx = 0;
574   sig_str[idx++] = &#39;(&#39;;
575   for (int i = 0; i &lt; length; i++) {
576     BasicType bt = sig-&gt;at(i)._bt;
577     if (bt == T_VALUETYPE || bt == T_VOID) {
578       // Ignore
579     } else {
580       if (bt == T_ARRAY) {
581         bt = T_OBJECT; // We don&#39;t know the element type, treat as Object
582       }
583       sig_str[idx++] = type2char(bt);
584       if (bt == T_OBJECT) {
585         sig_str[idx++] = &#39;;&#39;;
586       }
587     }
588   }
589   sig_str[idx++] = &#39;)&#39;;
590   // Add a dummy return type. It won&#39;t be used but SignatureStream needs it.
591   sig_str[idx++] = &#39;V&#39;;
592   sig_str[idx++] = &#39;\0&#39;;
593   return SymbolTable::new_symbol(sig_str);
594 }
595 
596 // Increment signature iterator (skips value type delimiters and T_VOID) and check if next entry is reserved
597 bool SigEntry::next_is_reserved(ExtendedSignature&amp; sig, BasicType&amp; bt, bool can_be_void) {
598   assert(can_be_void || bt != T_VOID, &quot;should never see void&quot;);
599   if (sig.at_end() || (can_be_void &amp;&amp; type2size[bt] == 2 &amp;&amp; (*sig)._offset != SigEntry::ReservedOffset)) {
600     // Don&#39;t increment at the end or at a T_LONG/T_DOUBLE which will be followed by a (skipped) T_VOID
601     return false;
602   }
603   assert(bt == T_VOID || type2wfield[bt] == type2wfield[(*sig)._bt], &quot;inconsistent signature&quot;);
604   ++sig;
605   if (!sig.at_end() &amp;&amp; (*sig)._offset == SigEntry::ReservedOffset) {
606     bt = (*sig)._bt;
607     return true;
608   }
609   return false;
610 }
    </pre>
  </body>
</html>
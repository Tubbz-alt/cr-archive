<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciCodeInstaller.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciCompilerToVMInit.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/stringTable.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;code/scopeDesc.hpp&quot;
  30 #include &quot;compiler/compileBroker.hpp&quot;

  31 #include &quot;compiler/disassembler.hpp&quot;
  32 #include &quot;interpreter/linkResolver.hpp&quot;
  33 #include &quot;interpreter/bytecodeStream.hpp&quot;
  34 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  35 #include &quot;jvmci/jvmciCodeInstaller.hpp&quot;
  36 #include &quot;jvmci/jvmciRuntime.hpp&quot;
  37 #include &quot;logging/log.hpp&quot;
  38 #include &quot;logging/logTag.hpp&quot;
  39 #include &quot;memory/oopFactory.hpp&quot;
  40 #include &quot;memory/universe.hpp&quot;
  41 #include &quot;oops/constantPool.inline.hpp&quot;
  42 #include &quot;oops/method.inline.hpp&quot;
  43 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  44 #include &quot;prims/nativeLookup.hpp&quot;
  45 #include &quot;runtime/atomic.hpp&quot;
  46 #include &quot;runtime/deoptimization.hpp&quot;
  47 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  48 #include &quot;runtime/frame.inline.hpp&quot;
  49 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  50 #include &quot;runtime/jniHandles.inline.hpp&quot;
</pre>
<hr />
<pre>
 517 
 518   if (class_name-&gt;utf8_length() &lt;= 1) {
 519     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Primitive type %s should be handled in Java code&quot;, class_name-&gt;as_C_string()));
 520   }
 521 
 522   JVMCIKlassHandle resolved_klass(THREAD);
 523   Klass* accessing_klass = NULL;
 524   Handle class_loader;
 525   Handle protection_domain;
 526   if (accessing_class != NULL) {
 527     accessing_klass = JVMCIENV-&gt;asKlass(accessing_class);
 528     class_loader = Handle(THREAD, accessing_klass-&gt;class_loader());
 529     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
 530   } else {
 531     // Use the System class loader
 532     class_loader = Handle(THREAD, SystemDictionary::java_system_loader());
 533     JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);
 534   }
 535 
 536   if (resolve) {
<span class="line-modified"> 537     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_0);</span>
 538     if (resolved_klass == NULL) {
 539       JVMCI_THROW_MSG_NULL(ClassNotFoundException, str);
 540     }
 541   } else {
 542     if (Signature::has_envelope(class_name)) {
 543       // This is a name from a signature.  Strip off the trimmings.
 544       // Call recursive to keep scope of strippedsym.
 545       TempNewSymbol strippedsym = Signature::strip_envelope(class_name);
<span class="line-modified"> 546       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_0);</span>
 547     } else if (Signature::is_array(class_name)) {
 548       SignatureStream ss(class_name, false);
 549       int ndim = ss.skip_array_prefix();
 550       if (ss.type() == T_OBJECT) {
 551         Symbol* strippedsym = ss.as_symbol();
 552         resolved_klass = SystemDictionary::find(strippedsym,
 553                                                 class_loader,
 554                                                 protection_domain,
<span class="line-modified"> 555                                                 CHECK_0);</span>
 556         if (!resolved_klass.is_null()) {
<span class="line-modified"> 557           resolved_klass = resolved_klass-&gt;array_klass(ndim, CHECK_0);</span>
 558         }
 559       } else {
<span class="line-modified"> 560         resolved_klass = TypeArrayKlass::cast(Universe::typeArrayKlassObj(ss.type()))-&gt;array_klass(ndim, CHECK_0);</span>
 561       }
 562     } else {
<span class="line-modified"> 563       resolved_klass = SystemDictionary::find(class_name, class_loader, protection_domain, CHECK_0);</span>
 564     }
 565   }
 566   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(resolved_klass, JVMCI_CHECK_NULL);
 567   return JVMCIENV-&gt;get_jobject(result);
 568 C2V_END
 569 
 570 C2V_VMENTRY_NULL(jobject, getArrayType, (JNIEnv* env, jobject, jobject jvmci_type))
 571   if (jvmci_type == NULL) {
 572     JVMCI_THROW_0(NullPointerException);
 573   }
 574 
 575   JVMCIObject jvmci_type_object = JVMCIENV-&gt;wrap(jvmci_type);
 576   JVMCIKlassHandle array_klass(THREAD);
 577   if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(jvmci_type_object)) {
 578     BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(jvmci_type_object), JVMCI_CHECK_0);
 579     if (type == T_VOID) {
 580       return NULL;
 581     }
 582     array_klass = Universe::typeArrayKlassObj(type);
 583     if (array_klass == NULL) {
</pre>
<hr />
<pre>
 687 
 688 C2V_VMENTRY_NULL(jobject, lookupMethodInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 689   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 690   InstanceKlass* pool_holder = cp-&gt;pool_holder();
 691   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 692   methodHandle method(THREAD, JVMCIRuntime::get_method_by_index(cp, index, bc, pool_holder));
 693   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(method, JVMCI_CHECK_NULL);
 694   return JVMCIENV-&gt;get_jobject(result);
 695 C2V_END
 696 
 697 C2V_VMENTRY_0(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 698   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 699   return cp-&gt;remap_instruction_operand_from_cache(index);
 700 C2V_END
 701 
 702 C2V_VMENTRY_NULL(jobject, resolveFieldInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))
 703   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 704   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 705   fieldDescriptor fd;
 706   methodHandle mh(THREAD, (jvmci_method != NULL) ? JVMCIENV-&gt;asMethod(jvmci_method) : NULL);
<span class="line-modified"> 707   LinkInfo link_info(cp, index, mh, CHECK_0);</span>
<span class="line-modified"> 708   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);</span>
 709   JVMCIPrimitiveArray info = JVMCIENV-&gt;wrap(info_handle);
 710   if (info.is_null() || JVMCIENV-&gt;get_length(info) != 3) {
 711     JVMCI_ERROR_NULL(&quot;info must not be null and have a length of 3&quot;);
 712   }
 713   JVMCIENV-&gt;put_int_at(info, 0, fd.access_flags().as_int());
 714   JVMCIENV-&gt;put_int_at(info, 1, fd.offset());
 715   JVMCIENV-&gt;put_int_at(info, 2, fd.index());
 716   JVMCIKlassHandle handle(THREAD, fd.field_holder());
 717   JVMCIObject field_holder = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);
 718   return JVMCIENV-&gt;get_jobject(field_holder);
 719 C2V_END
 720 
 721 C2V_VMENTRY_0(jint, getVtableIndexForInterfaceMethod, (JNIEnv* env, jobject, jobject jvmci_type, jobject jvmci_method))
 722   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 723   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 724   if (klass-&gt;is_interface()) {
 725     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Interface %s should be handled in Java code&quot;, klass-&gt;external_name()));
 726   }
 727   if (!method-&gt;method_holder()-&gt;is_interface()) {
 728     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Method %s is not held by an interface, this case should be handled in Java code&quot;, method-&gt;name_and_sig_as_C_string()));
</pre>
<hr />
<pre>
1808     TempNewSymbol compileToBytecode = SymbolTable::new_symbol(&quot;compileToBytecode&quot;);
1809     JavaValue result(T_VOID);
1810     JavaCalls::call_special(&amp;result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);
1811   } else {
1812     JVMCI_THROW_MSG(IllegalArgumentException,
1813                     err_msg(&quot;Unexpected type: %s&quot;, lambda_form-&gt;klass()-&gt;external_name()))
1814   }
1815 C2V_END
1816 
1817 C2V_VMENTRY_0(jint, getIdentityHashCode, (JNIEnv* env, jobject, jobject object))
1818   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);
1819   return obj-&gt;identity_hash();
1820 C2V_END
1821 
1822 C2V_VMENTRY_0(jboolean, isInternedString, (JNIEnv* env, jobject, jobject object))
1823   Handle str = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);
1824   if (!java_lang_String::is_instance(str())) {
1825     return false;
1826   }
1827   int len;
<span class="line-modified">1828   jchar* name = java_lang_String::as_unicode_string(str(), len, CHECK_0);</span>
1829   return (StringTable::lookup(name, len) != NULL);
1830 C2V_END
1831 
1832 
1833 C2V_VMENTRY_NULL(jobject, unboxPrimitive, (JNIEnv* env, jobject, jobject object))
1834   if (object == NULL) {
1835     JVMCI_THROW_0(NullPointerException);
1836   }
1837   Handle box = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);
1838   BasicType type = java_lang_boxing_object::basic_type(box());
1839   jvalue result;
1840   if (java_lang_boxing_object::get_value(box(), &amp;result) == T_ILLEGAL) {
1841     return NULL;
1842   }
1843   JVMCIObject boxResult = JVMCIENV-&gt;create_box(type, &amp;result, JVMCI_CHECK_NULL);
1844   return JVMCIENV-&gt;get_jobject(boxResult);
1845 C2V_END
1846 
1847 C2V_VMENTRY_NULL(jobject, boxPrimitive, (JNIEnv* env, jobject, jobject object))
1848   if (object == NULL) {
</pre>
<hr />
<pre>
2611 C2V_VMENTRY_0(jboolean, addFailedSpeculation, (JNIEnv* env, jobject, jlong failed_speculations_address, jbyteArray speculation_obj))
2612   JVMCIPrimitiveArray speculation_handle = JVMCIENV-&gt;wrap(speculation_obj);
2613   int speculation_len = JVMCIENV-&gt;get_length(speculation_handle);
2614   char* speculation = NEW_RESOURCE_ARRAY(char, speculation_len);
2615   JVMCIENV-&gt;copy_bytes_to(speculation_handle, (jbyte*) speculation, 0, speculation_len);
2616   return FailedSpeculation::add_failed_speculation(NULL, (FailedSpeculation**)(address) failed_speculations_address, (address) speculation, speculation_len);
2617 }
2618 
2619 C2V_VMENTRY(void, callSystemExit, (JNIEnv* env, jobject, jint status))
2620   JavaValue result(T_VOID);
2621   JavaCallArguments jargs(1);
2622   jargs.push_int(status);
2623   JavaCalls::call_static(&amp;result,
2624                        SystemDictionary::System_klass(),
2625                        vmSymbols::exit_method_name(),
2626                        vmSymbols::int_void_signature(),
2627                        &amp;jargs,
2628                        CHECK);
2629 }
2630 







































2631 #define CC (char*)  /*cast a literal from (const char*)*/
2632 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
2633 
2634 #define STRING                  &quot;Ljava/lang/String;&quot;
2635 #define OBJECT                  &quot;Ljava/lang/Object;&quot;
2636 #define CLASS                   &quot;Ljava/lang/Class;&quot;
2637 #define OBJECTCONSTANT          &quot;Ljdk/vm/ci/hotspot/HotSpotObjectConstantImpl;&quot;
2638 #define HANDLECONSTANT          &quot;Ljdk/vm/ci/hotspot/IndirectHotSpotObjectConstantImpl;&quot;
2639 #define EXECUTABLE              &quot;Ljava/lang/reflect/Executable;&quot;
2640 #define STACK_TRACE_ELEMENT     &quot;Ljava/lang/StackTraceElement;&quot;
2641 #define INSTALLED_CODE          &quot;Ljdk/vm/ci/code/InstalledCode;&quot;
2642 #define TARGET_DESCRIPTION      &quot;Ljdk/vm/ci/code/TargetDescription;&quot;
2643 #define BYTECODE_FRAME          &quot;Ljdk/vm/ci/code/BytecodeFrame;&quot;
2644 #define JAVACONSTANT            &quot;Ljdk/vm/ci/meta/JavaConstant;&quot;
2645 #define INSPECTED_FRAME_VISITOR &quot;Ljdk/vm/ci/code/stack/InspectedFrameVisitor;&quot;
2646 #define RESOLVED_METHOD         &quot;Ljdk/vm/ci/meta/ResolvedJavaMethod;&quot;
2647 #define HS_RESOLVED_METHOD      &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;&quot;
2648 #define HS_RESOLVED_KLASS       &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;&quot;
2649 #define HS_RESOLVED_TYPE        &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaType;&quot;
2650 #define HS_RESOLVED_FIELD       &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaField;&quot;
</pre>
<hr />
<pre>
2758   {CC &quot;getInt&quot;,                                       CC &quot;(&quot; OBJECTCONSTANT &quot;J)I&quot;,                                                          FN_PTR(getInt)},
2759   {CC &quot;getLong&quot;,                                      CC &quot;(&quot; OBJECTCONSTANT &quot;J)J&quot;,                                                          FN_PTR(getLong)},
2760   {CC &quot;getObject&quot;,                                    CC &quot;(&quot; OBJECTCONSTANT &quot;J)&quot; OBJECTCONSTANT,                                            FN_PTR(getObject)},
2761   {CC &quot;deleteGlobalHandle&quot;,                           CC &quot;(J)V&quot;,                                                                            FN_PTR(deleteGlobalHandle)},
2762   {CC &quot;registerNativeMethods&quot;,                        CC &quot;(&quot; CLASS &quot;)[J&quot;,                                                                   FN_PTR(registerNativeMethods)},
2763   {CC &quot;isCurrentThreadAttached&quot;,                      CC &quot;()Z&quot;,                                                                             FN_PTR(isCurrentThreadAttached)},
2764   {CC &quot;getCurrentJavaThread&quot;,                         CC &quot;()J&quot;,                                                                             FN_PTR(getCurrentJavaThread)},
2765   {CC &quot;attachCurrentThread&quot;,                          CC &quot;(Z)Z&quot;,                                                                            FN_PTR(attachCurrentThread)},
2766   {CC &quot;detachCurrentThread&quot;,                          CC &quot;()V&quot;,                                                                             FN_PTR(detachCurrentThread)},
2767   {CC &quot;translate&quot;,                                    CC &quot;(&quot; OBJECT &quot;)J&quot;,                                                                   FN_PTR(translate)},
2768   {CC &quot;unhand&quot;,                                       CC &quot;(J)&quot; OBJECT,                                                                      FN_PTR(unhand)},
2769   {CC &quot;updateHotSpotNmethod&quot;,                         CC &quot;(&quot; HS_NMETHOD &quot;)V&quot;,                                                               FN_PTR(updateHotSpotNmethod)},
2770   {CC &quot;getCode&quot;,                                      CC &quot;(&quot; HS_INSTALLED_CODE &quot;)[B&quot;,                                                       FN_PTR(getCode)},
2771   {CC &quot;asReflectionExecutable&quot;,                       CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)&quot; REFLECTION_EXECUTABLE,                                  FN_PTR(asReflectionExecutable)},
2772   {CC &quot;asReflectionField&quot;,                            CC &quot;(&quot; HS_RESOLVED_KLASS &quot;I)&quot; REFLECTION_FIELD,                                       FN_PTR(asReflectionField)},
2773   {CC &quot;getFailedSpeculations&quot;,                        CC &quot;(J[[B)[[B&quot;,                                                                       FN_PTR(getFailedSpeculations)},
2774   {CC &quot;getFailedSpeculationsAddress&quot;,                 CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getFailedSpeculationsAddress)},
2775   {CC &quot;releaseFailedSpeculations&quot;,                    CC &quot;(J)V&quot;,                                                                            FN_PTR(releaseFailedSpeculations)},
2776   {CC &quot;addFailedSpeculation&quot;,                         CC &quot;(J[B)Z&quot;,                                                                          FN_PTR(addFailedSpeculation)},
2777   {CC &quot;callSystemExit&quot;,                               CC &quot;(I)V&quot;,                                                                            FN_PTR(callSystemExit)},




2778 };
2779 
2780 int CompilerToVM::methods_count() {
2781   return sizeof(methods) / sizeof(JNINativeMethod);
2782 }
</pre>
</td>
<td>
<hr />
<pre>
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/stringTable.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;code/scopeDesc.hpp&quot;
  30 #include &quot;compiler/compileBroker.hpp&quot;
<span class="line-added">  31 #include &quot;compiler/compilerEvent.hpp&quot;</span>
  32 #include &quot;compiler/disassembler.hpp&quot;
  33 #include &quot;interpreter/linkResolver.hpp&quot;
  34 #include &quot;interpreter/bytecodeStream.hpp&quot;
  35 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  36 #include &quot;jvmci/jvmciCodeInstaller.hpp&quot;
  37 #include &quot;jvmci/jvmciRuntime.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logTag.hpp&quot;
  40 #include &quot;memory/oopFactory.hpp&quot;
  41 #include &quot;memory/universe.hpp&quot;
  42 #include &quot;oops/constantPool.inline.hpp&quot;
  43 #include &quot;oops/method.inline.hpp&quot;
  44 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  45 #include &quot;prims/nativeLookup.hpp&quot;
  46 #include &quot;runtime/atomic.hpp&quot;
  47 #include &quot;runtime/deoptimization.hpp&quot;
  48 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  49 #include &quot;runtime/frame.inline.hpp&quot;
  50 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  51 #include &quot;runtime/jniHandles.inline.hpp&quot;
</pre>
<hr />
<pre>
 518 
 519   if (class_name-&gt;utf8_length() &lt;= 1) {
 520     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Primitive type %s should be handled in Java code&quot;, class_name-&gt;as_C_string()));
 521   }
 522 
 523   JVMCIKlassHandle resolved_klass(THREAD);
 524   Klass* accessing_klass = NULL;
 525   Handle class_loader;
 526   Handle protection_domain;
 527   if (accessing_class != NULL) {
 528     accessing_klass = JVMCIENV-&gt;asKlass(accessing_class);
 529     class_loader = Handle(THREAD, accessing_klass-&gt;class_loader());
 530     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
 531   } else {
 532     // Use the System class loader
 533     class_loader = Handle(THREAD, SystemDictionary::java_system_loader());
 534     JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);
 535   }
 536 
 537   if (resolve) {
<span class="line-modified"> 538     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_NULL);</span>
 539     if (resolved_klass == NULL) {
 540       JVMCI_THROW_MSG_NULL(ClassNotFoundException, str);
 541     }
 542   } else {
 543     if (Signature::has_envelope(class_name)) {
 544       // This is a name from a signature.  Strip off the trimmings.
 545       // Call recursive to keep scope of strippedsym.
 546       TempNewSymbol strippedsym = Signature::strip_envelope(class_name);
<span class="line-modified"> 547       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_NULL);</span>
 548     } else if (Signature::is_array(class_name)) {
 549       SignatureStream ss(class_name, false);
 550       int ndim = ss.skip_array_prefix();
 551       if (ss.type() == T_OBJECT) {
 552         Symbol* strippedsym = ss.as_symbol();
 553         resolved_klass = SystemDictionary::find(strippedsym,
 554                                                 class_loader,
 555                                                 protection_domain,
<span class="line-modified"> 556                                                 CHECK_NULL);</span>
 557         if (!resolved_klass.is_null()) {
<span class="line-modified"> 558           resolved_klass = resolved_klass-&gt;array_klass(ndim, CHECK_NULL);</span>
 559         }
 560       } else {
<span class="line-modified"> 561         resolved_klass = TypeArrayKlass::cast(Universe::typeArrayKlassObj(ss.type()))-&gt;array_klass(ndim, CHECK_NULL);</span>
 562       }
 563     } else {
<span class="line-modified"> 564       resolved_klass = SystemDictionary::find(class_name, class_loader, protection_domain, CHECK_NULL);</span>
 565     }
 566   }
 567   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(resolved_klass, JVMCI_CHECK_NULL);
 568   return JVMCIENV-&gt;get_jobject(result);
 569 C2V_END
 570 
 571 C2V_VMENTRY_NULL(jobject, getArrayType, (JNIEnv* env, jobject, jobject jvmci_type))
 572   if (jvmci_type == NULL) {
 573     JVMCI_THROW_0(NullPointerException);
 574   }
 575 
 576   JVMCIObject jvmci_type_object = JVMCIENV-&gt;wrap(jvmci_type);
 577   JVMCIKlassHandle array_klass(THREAD);
 578   if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(jvmci_type_object)) {
 579     BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(jvmci_type_object), JVMCI_CHECK_0);
 580     if (type == T_VOID) {
 581       return NULL;
 582     }
 583     array_klass = Universe::typeArrayKlassObj(type);
 584     if (array_klass == NULL) {
</pre>
<hr />
<pre>
 688 
 689 C2V_VMENTRY_NULL(jobject, lookupMethodInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 690   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 691   InstanceKlass* pool_holder = cp-&gt;pool_holder();
 692   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 693   methodHandle method(THREAD, JVMCIRuntime::get_method_by_index(cp, index, bc, pool_holder));
 694   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(method, JVMCI_CHECK_NULL);
 695   return JVMCIENV-&gt;get_jobject(result);
 696 C2V_END
 697 
 698 C2V_VMENTRY_0(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 699   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 700   return cp-&gt;remap_instruction_operand_from_cache(index);
 701 C2V_END
 702 
 703 C2V_VMENTRY_NULL(jobject, resolveFieldInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))
 704   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 705   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 706   fieldDescriptor fd;
 707   methodHandle mh(THREAD, (jvmci_method != NULL) ? JVMCIENV-&gt;asMethod(jvmci_method) : NULL);
<span class="line-modified"> 708   LinkInfo link_info(cp, index, mh, CHECK_NULL);</span>
<span class="line-modified"> 709   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_NULL);</span>
 710   JVMCIPrimitiveArray info = JVMCIENV-&gt;wrap(info_handle);
 711   if (info.is_null() || JVMCIENV-&gt;get_length(info) != 3) {
 712     JVMCI_ERROR_NULL(&quot;info must not be null and have a length of 3&quot;);
 713   }
 714   JVMCIENV-&gt;put_int_at(info, 0, fd.access_flags().as_int());
 715   JVMCIENV-&gt;put_int_at(info, 1, fd.offset());
 716   JVMCIENV-&gt;put_int_at(info, 2, fd.index());
 717   JVMCIKlassHandle handle(THREAD, fd.field_holder());
 718   JVMCIObject field_holder = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);
 719   return JVMCIENV-&gt;get_jobject(field_holder);
 720 C2V_END
 721 
 722 C2V_VMENTRY_0(jint, getVtableIndexForInterfaceMethod, (JNIEnv* env, jobject, jobject jvmci_type, jobject jvmci_method))
 723   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 724   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 725   if (klass-&gt;is_interface()) {
 726     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Interface %s should be handled in Java code&quot;, klass-&gt;external_name()));
 727   }
 728   if (!method-&gt;method_holder()-&gt;is_interface()) {
 729     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Method %s is not held by an interface, this case should be handled in Java code&quot;, method-&gt;name_and_sig_as_C_string()));
</pre>
<hr />
<pre>
1809     TempNewSymbol compileToBytecode = SymbolTable::new_symbol(&quot;compileToBytecode&quot;);
1810     JavaValue result(T_VOID);
1811     JavaCalls::call_special(&amp;result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);
1812   } else {
1813     JVMCI_THROW_MSG(IllegalArgumentException,
1814                     err_msg(&quot;Unexpected type: %s&quot;, lambda_form-&gt;klass()-&gt;external_name()))
1815   }
1816 C2V_END
1817 
1818 C2V_VMENTRY_0(jint, getIdentityHashCode, (JNIEnv* env, jobject, jobject object))
1819   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);
1820   return obj-&gt;identity_hash();
1821 C2V_END
1822 
1823 C2V_VMENTRY_0(jboolean, isInternedString, (JNIEnv* env, jobject, jobject object))
1824   Handle str = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);
1825   if (!java_lang_String::is_instance(str())) {
1826     return false;
1827   }
1828   int len;
<span class="line-modified">1829   jchar* name = java_lang_String::as_unicode_string(str(), len, CHECK_false);</span>
1830   return (StringTable::lookup(name, len) != NULL);
1831 C2V_END
1832 
1833 
1834 C2V_VMENTRY_NULL(jobject, unboxPrimitive, (JNIEnv* env, jobject, jobject object))
1835   if (object == NULL) {
1836     JVMCI_THROW_0(NullPointerException);
1837   }
1838   Handle box = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);
1839   BasicType type = java_lang_boxing_object::basic_type(box());
1840   jvalue result;
1841   if (java_lang_boxing_object::get_value(box(), &amp;result) == T_ILLEGAL) {
1842     return NULL;
1843   }
1844   JVMCIObject boxResult = JVMCIENV-&gt;create_box(type, &amp;result, JVMCI_CHECK_NULL);
1845   return JVMCIENV-&gt;get_jobject(boxResult);
1846 C2V_END
1847 
1848 C2V_VMENTRY_NULL(jobject, boxPrimitive, (JNIEnv* env, jobject, jobject object))
1849   if (object == NULL) {
</pre>
<hr />
<pre>
2612 C2V_VMENTRY_0(jboolean, addFailedSpeculation, (JNIEnv* env, jobject, jlong failed_speculations_address, jbyteArray speculation_obj))
2613   JVMCIPrimitiveArray speculation_handle = JVMCIENV-&gt;wrap(speculation_obj);
2614   int speculation_len = JVMCIENV-&gt;get_length(speculation_handle);
2615   char* speculation = NEW_RESOURCE_ARRAY(char, speculation_len);
2616   JVMCIENV-&gt;copy_bytes_to(speculation_handle, (jbyte*) speculation, 0, speculation_len);
2617   return FailedSpeculation::add_failed_speculation(NULL, (FailedSpeculation**)(address) failed_speculations_address, (address) speculation, speculation_len);
2618 }
2619 
2620 C2V_VMENTRY(void, callSystemExit, (JNIEnv* env, jobject, jint status))
2621   JavaValue result(T_VOID);
2622   JavaCallArguments jargs(1);
2623   jargs.push_int(status);
2624   JavaCalls::call_static(&amp;result,
2625                        SystemDictionary::System_klass(),
2626                        vmSymbols::exit_method_name(),
2627                        vmSymbols::int_void_signature(),
2628                        &amp;jargs,
2629                        CHECK);
2630 }
2631 
<span class="line-added">2632 C2V_VMENTRY_0(jlong, ticksNow, (JNIEnv* env, jobject))</span>
<span class="line-added">2633   return CompilerEvent::ticksNow();</span>
<span class="line-added">2634 }</span>
<span class="line-added">2635 </span>
<span class="line-added">2636 C2V_VMENTRY_0(jint, registerCompilerPhases, (JNIEnv* env, jobject, jobjectArray jphases))</span>
<span class="line-added">2637 #if INCLUDE_JFR</span>
<span class="line-added">2638   if (jphases == NULL) {</span>
<span class="line-added">2639     return -1;</span>
<span class="line-added">2640   }</span>
<span class="line-added">2641   JVMCIObjectArray phases = JVMCIENV-&gt;wrap(jphases);</span>
<span class="line-added">2642   int len = JVMCIENV-&gt;get_length(phases);</span>
<span class="line-added">2643   GrowableArray&lt;const char*&gt;* jvmci_phase_names = new GrowableArray&lt;const char*&gt;(len);</span>
<span class="line-added">2644   for (int i = 0; i &lt; len; i++) {</span>
<span class="line-added">2645     JVMCIObject phase = JVMCIENV-&gt;get_object_at(phases, i);</span>
<span class="line-added">2646     jvmci_phase_names-&gt;append(strdup(JVMCIENV-&gt;as_utf8_string(phase)));</span>
<span class="line-added">2647   }</span>
<span class="line-added">2648   return CompilerEvent::PhaseEvent::register_phases(jvmci_phase_names);</span>
<span class="line-added">2649 #else</span>
<span class="line-added">2650   return -1;</span>
<span class="line-added">2651 #endif // !INCLUDE_JFR</span>
<span class="line-added">2652 }</span>
<span class="line-added">2653 </span>
<span class="line-added">2654 C2V_VMENTRY(void, notifyCompilerPhaseEvent, (JNIEnv* env, jobject, jlong startTime, jint phase, jint compileId, jint level))</span>
<span class="line-added">2655   EventCompilerPhase event;</span>
<span class="line-added">2656   if (event.should_commit()) {</span>
<span class="line-added">2657     CompilerEvent::PhaseEvent::post(event, startTime, phase, compileId, level);</span>
<span class="line-added">2658   }</span>
<span class="line-added">2659 }</span>
<span class="line-added">2660 </span>
<span class="line-added">2661 C2V_VMENTRY(void, notifyCompilerInliningEvent, (JNIEnv* env, jobject, jint compileId, jobject caller, jobject callee, jboolean succeeded, jstring jmessage, jint bci))</span>
<span class="line-added">2662   EventCompilerInlining event;</span>
<span class="line-added">2663   if (event.should_commit()) {</span>
<span class="line-added">2664     Method* caller_method = JVMCIENV-&gt;asMethod(caller);</span>
<span class="line-added">2665     Method* callee_method = JVMCIENV-&gt;asMethod(callee);</span>
<span class="line-added">2666     JVMCIObject message = JVMCIENV-&gt;wrap(jmessage);</span>
<span class="line-added">2667     CompilerEvent::InlineEvent::post(event, compileId, caller_method, callee_method, succeeded, JVMCIENV-&gt;as_utf8_string(message), bci);</span>
<span class="line-added">2668   }</span>
<span class="line-added">2669 }</span>
<span class="line-added">2670 </span>
2671 #define CC (char*)  /*cast a literal from (const char*)*/
2672 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
2673 
2674 #define STRING                  &quot;Ljava/lang/String;&quot;
2675 #define OBJECT                  &quot;Ljava/lang/Object;&quot;
2676 #define CLASS                   &quot;Ljava/lang/Class;&quot;
2677 #define OBJECTCONSTANT          &quot;Ljdk/vm/ci/hotspot/HotSpotObjectConstantImpl;&quot;
2678 #define HANDLECONSTANT          &quot;Ljdk/vm/ci/hotspot/IndirectHotSpotObjectConstantImpl;&quot;
2679 #define EXECUTABLE              &quot;Ljava/lang/reflect/Executable;&quot;
2680 #define STACK_TRACE_ELEMENT     &quot;Ljava/lang/StackTraceElement;&quot;
2681 #define INSTALLED_CODE          &quot;Ljdk/vm/ci/code/InstalledCode;&quot;
2682 #define TARGET_DESCRIPTION      &quot;Ljdk/vm/ci/code/TargetDescription;&quot;
2683 #define BYTECODE_FRAME          &quot;Ljdk/vm/ci/code/BytecodeFrame;&quot;
2684 #define JAVACONSTANT            &quot;Ljdk/vm/ci/meta/JavaConstant;&quot;
2685 #define INSPECTED_FRAME_VISITOR &quot;Ljdk/vm/ci/code/stack/InspectedFrameVisitor;&quot;
2686 #define RESOLVED_METHOD         &quot;Ljdk/vm/ci/meta/ResolvedJavaMethod;&quot;
2687 #define HS_RESOLVED_METHOD      &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;&quot;
2688 #define HS_RESOLVED_KLASS       &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;&quot;
2689 #define HS_RESOLVED_TYPE        &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaType;&quot;
2690 #define HS_RESOLVED_FIELD       &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaField;&quot;
</pre>
<hr />
<pre>
2798   {CC &quot;getInt&quot;,                                       CC &quot;(&quot; OBJECTCONSTANT &quot;J)I&quot;,                                                          FN_PTR(getInt)},
2799   {CC &quot;getLong&quot;,                                      CC &quot;(&quot; OBJECTCONSTANT &quot;J)J&quot;,                                                          FN_PTR(getLong)},
2800   {CC &quot;getObject&quot;,                                    CC &quot;(&quot; OBJECTCONSTANT &quot;J)&quot; OBJECTCONSTANT,                                            FN_PTR(getObject)},
2801   {CC &quot;deleteGlobalHandle&quot;,                           CC &quot;(J)V&quot;,                                                                            FN_PTR(deleteGlobalHandle)},
2802   {CC &quot;registerNativeMethods&quot;,                        CC &quot;(&quot; CLASS &quot;)[J&quot;,                                                                   FN_PTR(registerNativeMethods)},
2803   {CC &quot;isCurrentThreadAttached&quot;,                      CC &quot;()Z&quot;,                                                                             FN_PTR(isCurrentThreadAttached)},
2804   {CC &quot;getCurrentJavaThread&quot;,                         CC &quot;()J&quot;,                                                                             FN_PTR(getCurrentJavaThread)},
2805   {CC &quot;attachCurrentThread&quot;,                          CC &quot;(Z)Z&quot;,                                                                            FN_PTR(attachCurrentThread)},
2806   {CC &quot;detachCurrentThread&quot;,                          CC &quot;()V&quot;,                                                                             FN_PTR(detachCurrentThread)},
2807   {CC &quot;translate&quot;,                                    CC &quot;(&quot; OBJECT &quot;)J&quot;,                                                                   FN_PTR(translate)},
2808   {CC &quot;unhand&quot;,                                       CC &quot;(J)&quot; OBJECT,                                                                      FN_PTR(unhand)},
2809   {CC &quot;updateHotSpotNmethod&quot;,                         CC &quot;(&quot; HS_NMETHOD &quot;)V&quot;,                                                               FN_PTR(updateHotSpotNmethod)},
2810   {CC &quot;getCode&quot;,                                      CC &quot;(&quot; HS_INSTALLED_CODE &quot;)[B&quot;,                                                       FN_PTR(getCode)},
2811   {CC &quot;asReflectionExecutable&quot;,                       CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)&quot; REFLECTION_EXECUTABLE,                                  FN_PTR(asReflectionExecutable)},
2812   {CC &quot;asReflectionField&quot;,                            CC &quot;(&quot; HS_RESOLVED_KLASS &quot;I)&quot; REFLECTION_FIELD,                                       FN_PTR(asReflectionField)},
2813   {CC &quot;getFailedSpeculations&quot;,                        CC &quot;(J[[B)[[B&quot;,                                                                       FN_PTR(getFailedSpeculations)},
2814   {CC &quot;getFailedSpeculationsAddress&quot;,                 CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getFailedSpeculationsAddress)},
2815   {CC &quot;releaseFailedSpeculations&quot;,                    CC &quot;(J)V&quot;,                                                                            FN_PTR(releaseFailedSpeculations)},
2816   {CC &quot;addFailedSpeculation&quot;,                         CC &quot;(J[B)Z&quot;,                                                                          FN_PTR(addFailedSpeculation)},
2817   {CC &quot;callSystemExit&quot;,                               CC &quot;(I)V&quot;,                                                                            FN_PTR(callSystemExit)},
<span class="line-added">2818   {CC &quot;ticksNow&quot;,                                     CC &quot;()J&quot;,                                                                             FN_PTR(ticksNow)},</span>
<span class="line-added">2819   {CC &quot;registerCompilerPhases&quot;,                       CC &quot;([&quot; STRING &quot;)I&quot;,                                                                  FN_PTR(registerCompilerPhases)},</span>
<span class="line-added">2820   {CC &quot;notifyCompilerPhaseEvent&quot;,                     CC &quot;(JIII)V&quot;,                                                                         FN_PTR(notifyCompilerPhaseEvent)},</span>
<span class="line-added">2821   {CC &quot;notifyCompilerInliningEvent&quot;,                  CC &quot;(I&quot; HS_RESOLVED_METHOD HS_RESOLVED_METHOD &quot;ZLjava/lang/String;I)V&quot;,               FN_PTR(notifyCompilerInliningEvent)},</span>
2822 };
2823 
2824 int CompilerToVM::methods_count() {
2825   return sizeof(methods) / sizeof(JNINativeMethod);
2826 }
</pre>
</td>
</tr>
</table>
<center><a href="jvmciCodeInstaller.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciCompilerToVMInit.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
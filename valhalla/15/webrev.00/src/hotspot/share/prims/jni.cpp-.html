<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/prims/jni.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012 Red Hat, Inc.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jni.h&quot;
  28 #include &quot;jvm.h&quot;
  29 #include &quot;ci/ciReplay.hpp&quot;
  30 #include &quot;classfile/altHashing.hpp&quot;
  31 #include &quot;classfile/classFileStream.hpp&quot;
  32 #include &quot;classfile/classLoader.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/modules.hpp&quot;
  36 #include &quot;classfile/symbolTable.hpp&quot;
  37 #include &quot;classfile/systemDictionary.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  40 #include &quot;interpreter/linkResolver.hpp&quot;
  41 #include &quot;jfr/jfrEvents.hpp&quot;
  42 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/allocation.hpp&quot;
  45 #include &quot;memory/allocation.inline.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/arrayOop.inline.hpp&quot;
  51 #include &quot;oops/instanceKlass.hpp&quot;
  52 #include &quot;oops/instanceOop.hpp&quot;
  53 #include &quot;oops/markWord.hpp&quot;
  54 #include &quot;oops/method.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
  58 #include &quot;oops/symbol.hpp&quot;
  59 #include &quot;oops/typeArrayKlass.hpp&quot;
  60 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  61 #include &quot;oops/valueArrayOop.inline.hpp&quot;
  62 #include &quot;oops/valueKlass.inline.hpp&quot;
  63 #include &quot;prims/jniCheck.hpp&quot;
  64 #include &quot;prims/jniExport.hpp&quot;
  65 #include &quot;prims/jniFastGetField.hpp&quot;
  66 #include &quot;prims/jvm_misc.hpp&quot;
  67 #include &quot;prims/jvmtiExport.hpp&quot;
  68 #include &quot;prims/jvmtiThreadState.hpp&quot;
  69 #include &quot;runtime/atomic.hpp&quot;
  70 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  71 #include &quot;runtime/handles.inline.hpp&quot;
  72 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  73 #include &quot;runtime/java.hpp&quot;
  74 #include &quot;runtime/javaCalls.hpp&quot;
  75 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  76 #include &quot;runtime/jniHandles.inline.hpp&quot;
  77 #include &quot;runtime/reflection.hpp&quot;
  78 #include &quot;runtime/safepointVerifiers.hpp&quot;
  79 #include &quot;runtime/sharedRuntime.hpp&quot;
  80 #include &quot;runtime/signature.hpp&quot;
  81 #include &quot;runtime/thread.inline.hpp&quot;
  82 #include &quot;runtime/vmOperations.hpp&quot;
  83 #include &quot;services/memTracker.hpp&quot;
  84 #include &quot;services/runtimeService.hpp&quot;
  85 #include &quot;utilities/defaultStream.hpp&quot;
  86 #include &quot;utilities/dtrace.hpp&quot;
  87 #include &quot;utilities/events.hpp&quot;
  88 #include &quot;utilities/histogram.hpp&quot;
  89 #include &quot;utilities/macros.hpp&quot;
  90 #include &quot;utilities/vmError.hpp&quot;
  91 #if INCLUDE_JVMCI
  92 #include &quot;jvmci/jvmciCompiler.hpp&quot;
  93 #endif
  94 
  95 static jint CurrentVersion = JNI_VERSION_10;
  96 
  97 #ifdef _WIN32
  98 extern LONG WINAPI topLevelExceptionFilter(_EXCEPTION_POINTERS* );
  99 #endif
 100 
 101 // The DT_RETURN_MARK macros create a scoped object to fire the dtrace
 102 // &#39;-return&#39; probe regardless of the return path is taken out of the function.
 103 // Methods that have multiple return paths use this to avoid having to
 104 // instrument each return path.  Methods that use CHECK or THROW must use this
 105 // since those macros can cause an immedate uninstrumented return.
 106 //
 107 // In order to get the return value, a reference to the variable containing
 108 // the return value must be passed to the contructor of the object, and
 109 // the return value must be set before return (since the mark object has
 110 // a reference to it).
 111 //
 112 // Example:
 113 // DT_RETURN_MARK_DECL(SomeFunc, int);
 114 // JNI_ENTRY(int, SomeFunc, ...)
 115 //   int return_value = 0;
 116 //   DT_RETURN_MARK(SomeFunc, int, (const int&amp;)return_value);
 117 //   foo(CHECK_0)
 118 //   return_value = 5;
 119 //   return return_value;
 120 // JNI_END
 121 #define DT_RETURN_MARK_DECL(name, type, probe)                             \
 122   DTRACE_ONLY(                                                             \
 123     class DTraceReturnProbeMark_##name {                                   \
 124      public:                                                               \
 125       const type&amp; _ret_ref;                                                \
 126       DTraceReturnProbeMark_##name(const type&amp; v) : _ret_ref(v) {}         \
 127       ~DTraceReturnProbeMark_##name() {                                    \
 128         probe;                                                             \
 129       }                                                                    \
 130     }                                                                      \
 131   )
 132 // Void functions are simpler since there&#39;s no return value
 133 #define DT_VOID_RETURN_MARK_DECL(name, probe)                              \
 134   DTRACE_ONLY(                                                             \
 135     class DTraceReturnProbeMark_##name {                                   \
 136      public:                                                               \
 137       ~DTraceReturnProbeMark_##name() {                                    \
 138         probe;                                                             \
 139       }                                                                    \
 140     }                                                                      \
 141   )
 142 
 143 // Place these macros in the function to mark the return.  Non-void
 144 // functions need the type and address of the return value.
 145 #define DT_RETURN_MARK(name, type, ref) \
 146   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark(ref) )
 147 #define DT_VOID_RETURN_MARK(name) \
 148   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark )
 149 
 150 
 151 // Use these to select distinct code for floating-point vs. non-floating point
 152 // situations.  Used from within common macros where we need slightly
 153 // different behavior for Float/Double
 154 #define FP_SELECT_Boolean(intcode, fpcode) intcode
 155 #define FP_SELECT_Byte(intcode, fpcode)    intcode
 156 #define FP_SELECT_Char(intcode, fpcode)    intcode
 157 #define FP_SELECT_Short(intcode, fpcode)   intcode
 158 #define FP_SELECT_Object(intcode, fpcode)  intcode
 159 #define FP_SELECT_Int(intcode, fpcode)     intcode
 160 #define FP_SELECT_Long(intcode, fpcode)    intcode
 161 #define FP_SELECT_Float(intcode, fpcode)   fpcode
 162 #define FP_SELECT_Double(intcode, fpcode)  fpcode
 163 #define FP_SELECT(TypeName, intcode, fpcode) \
 164   FP_SELECT_##TypeName(intcode, fpcode)
 165 
 166 // Choose DT_RETURN_MARK macros  based on the type: float/double -&gt; void
 167 // (dtrace doesn&#39;t do FP yet)
 168 #define DT_RETURN_MARK_DECL_FOR(TypeName, name, type, probe)    \
 169   FP_SELECT(TypeName, \
 170     DT_RETURN_MARK_DECL(name, type, probe), DT_VOID_RETURN_MARK_DECL(name, probe) )
 171 #define DT_RETURN_MARK_FOR(TypeName, name, type, ref) \
 172   FP_SELECT(TypeName, \
 173     DT_RETURN_MARK(name, type, ref), DT_VOID_RETURN_MARK(name) )
 174 
 175 
 176 // out-of-line helpers for class jfieldIDWorkaround:
 177 
 178 bool jfieldIDWorkaround::is_valid_jfieldID(Klass* k, jfieldID id) {
 179   if (jfieldIDWorkaround::is_instance_jfieldID(k, id)) {
 180     uintptr_t as_uint = (uintptr_t) id;
 181     intptr_t offset = raw_instance_offset(id);
 182     if (is_checked_jfieldID(id)) {
 183       if (!klass_hash_ok(k, id)) {
 184         return false;
 185       }
 186     }
 187     return InstanceKlass::cast(k)-&gt;contains_field_offset(offset);
 188   } else {
 189     JNIid* result = (JNIid*) id;
 190 #ifdef ASSERT
 191     return result != NULL &amp;&amp; result-&gt;is_static_field_id();
 192 #else
 193     return result != NULL;
 194 #endif
 195   }
 196 }
 197 
 198 
 199 intptr_t jfieldIDWorkaround::encode_klass_hash(Klass* k, intptr_t offset) {
 200   if (offset &lt;= small_offset_mask) {
 201     Klass* field_klass = k;
 202     Klass* super_klass = field_klass-&gt;super();
 203     // With compressed oops the most super class with nonstatic fields would
 204     // be the owner of fields embedded in the header.
 205     while (InstanceKlass::cast(super_klass)-&gt;has_nonstatic_fields() &amp;&amp;
 206            InstanceKlass::cast(super_klass)-&gt;contains_field_offset(offset)) {
 207       field_klass = super_klass;   // super contains the field also
 208       super_klass = field_klass-&gt;super();
 209     }
 210     debug_only(NoSafepointVerifier nosafepoint;)
 211     uintptr_t klass_hash = field_klass-&gt;identity_hash();
 212     return ((klass_hash &amp; klass_mask) &lt;&lt; klass_shift) | checked_mask_in_place;
 213   } else {
 214 #if 0
 215     #ifndef PRODUCT
 216     {
 217       ResourceMark rm;
 218       warning(&quot;VerifyJNIFields: long offset %d in %s&quot;, offset, k-&gt;external_name());
 219     }
 220     #endif
 221 #endif
 222     return 0;
 223   }
 224 }
 225 
 226 bool jfieldIDWorkaround::klass_hash_ok(Klass* k, jfieldID id) {
 227   uintptr_t as_uint = (uintptr_t) id;
 228   intptr_t klass_hash = (as_uint &gt;&gt; klass_shift) &amp; klass_mask;
 229   do {
 230     debug_only(NoSafepointVerifier nosafepoint;)
 231     // Could use a non-blocking query for identity_hash here...
 232     if ((k-&gt;identity_hash() &amp; klass_mask) == klass_hash)
 233       return true;
 234     k = k-&gt;super();
 235   } while (k != NULL);
 236   return false;
 237 }
 238 
 239 void jfieldIDWorkaround::verify_instance_jfieldID(Klass* k, jfieldID id) {
 240   guarantee(jfieldIDWorkaround::is_instance_jfieldID(k, id), &quot;must be an instance field&quot; );
 241   uintptr_t as_uint = (uintptr_t) id;
 242   intptr_t offset = raw_instance_offset(id);
 243   if (VerifyJNIFields) {
 244     if (is_checked_jfieldID(id)) {
 245       guarantee(klass_hash_ok(k, id),
 246     &quot;Bug in native code: jfieldID class must match object&quot;);
 247     } else {
 248 #if 0
 249       #ifndef PRODUCT
 250       if (Verbose) {
 251   ResourceMark rm;
 252   warning(&quot;VerifyJNIFields: unverified offset %d for %s&quot;, offset, k-&gt;external_name());
 253       }
 254       #endif
 255 #endif
 256     }
 257   }
 258   guarantee(InstanceKlass::cast(k)-&gt;contains_field_offset(offset),
 259       &quot;Bug in native code: jfieldID offset must address interior of object&quot;);
 260 }
 261 
 262 // Wrapper to trace JNI functions
 263 
 264 #ifdef ASSERT
 265   Histogram* JNIHistogram;
 266   static volatile int JNIHistogram_lock = 0;
 267 
 268   class JNIHistogramElement : public HistogramElement {
 269     public:
 270      JNIHistogramElement(const char* name);
 271   };
 272 
 273   JNIHistogramElement::JNIHistogramElement(const char* elementName) {
 274     _name = elementName;
 275     uintx count = 0;
 276 
 277     while (Atomic::cmpxchg(&amp;JNIHistogram_lock, 0, 1) != 0) {
 278       while (Atomic::load_acquire(&amp;JNIHistogram_lock) != 0) {
 279         count +=1;
 280         if ( (WarnOnStalledSpinLock &gt; 0)
 281           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 282           warning(&quot;JNIHistogram_lock seems to be stalled&quot;);
 283         }
 284       }
 285      }
 286 
 287 
 288     if(JNIHistogram == NULL)
 289       JNIHistogram = new Histogram(&quot;JNI Call Counts&quot;,100);
 290 
 291     JNIHistogram-&gt;add_element(this);
 292     Atomic::dec(&amp;JNIHistogram_lock);
 293   }
 294 
 295   #define JNICountWrapper(arg)                                     \
 296      static JNIHistogramElement* e = new JNIHistogramElement(arg); \
 297       /* There is a MT-race condition in VC++. So we need to make sure that that e has been initialized */ \
 298      if (e != NULL) e-&gt;increment_count()
 299   #define JNIWrapper(arg) JNICountWrapper(arg);
 300 #else
 301   #define JNIWrapper(arg)
 302 #endif
 303 
 304 
 305 // Implementation of JNI entries
 306 
 307 DT_RETURN_MARK_DECL(DefineClass, jclass
 308                     , HOTSPOT_JNI_DEFINECLASS_RETURN(_ret_ref));
 309 
 310 JNI_ENTRY(jclass, jni_DefineClass(JNIEnv *env, const char *name, jobject loaderRef,
 311                                   const jbyte *buf, jsize bufLen))
 312   JNIWrapper(&quot;DefineClass&quot;);
 313 
 314   HOTSPOT_JNI_DEFINECLASS_ENTRY(
 315     env, (char*) name, loaderRef, (char*) buf, bufLen);
 316 
 317   jclass cls = NULL;
 318   DT_RETURN_MARK(DefineClass, jclass, (const jclass&amp;)cls);
 319 
 320   TempNewSymbol class_name = NULL;
 321   // Since exceptions can be thrown, class initialization can take place
 322   // if name is NULL no check for class name in .class stream has to be made.
 323   if (name != NULL) {
 324     const int str_len = (int)strlen(name);
 325     if (str_len &gt; Symbol::max_length()) {
 326       // It&#39;s impossible to create this class;  the name cannot fit
 327       // into the constant pool.
 328       Exceptions::fthrow(THREAD_AND_LOCATION,
 329                          vmSymbols::java_lang_NoClassDefFoundError(),
 330                          &quot;Class name exceeds maximum length of %d: %s&quot;,
 331                          Symbol::max_length(),
 332                          name);
 333       return 0;
 334     }
 335     class_name = SymbolTable::new_symbol(name);
 336   }
 337   ResourceMark rm(THREAD);
 338   ClassFileStream st((u1*)buf, bufLen, NULL, ClassFileStream::verify);
 339   Handle class_loader (THREAD, JNIHandles::resolve(loaderRef));
 340 
 341   if (UsePerfData &amp;&amp; !class_loader.is_null()) {
 342     // check whether the current caller thread holds the lock or not.
 343     // If not, increment the corresponding counter
 344     if (ObjectSynchronizer::
 345         query_lock_ownership((JavaThread*)THREAD, class_loader) !=
 346         ObjectSynchronizer::owner_self) {
 347       ClassLoader::sync_JNIDefineClassLockFreeCounter()-&gt;inc();
 348     }
 349   }
 350   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 351                                                    class_loader,
 352                                                    Handle(),
 353                                                    &amp;st,
 354                                                    CHECK_NULL);
 355 
 356   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 357     trace_class_resolution(k);
 358   }
 359 
 360   cls = (jclass)JNIHandles::make_local(
 361     env, k-&gt;java_mirror());
 362   return cls;
 363 JNI_END
 364 
 365 
 366 
 367 DT_RETURN_MARK_DECL(FindClass, jclass
 368                     , HOTSPOT_JNI_FINDCLASS_RETURN(_ret_ref));
 369 
 370 JNI_ENTRY(jclass, jni_FindClass(JNIEnv *env, const char *name))
 371   JNIWrapper(&quot;FindClass&quot;);
 372 
 373   HOTSPOT_JNI_FINDCLASS_ENTRY(env, (char *)name);
 374 
 375   jclass result = NULL;
 376   DT_RETURN_MARK(FindClass, jclass, (const jclass&amp;)result);
 377 
 378   // Sanity check the name:  it cannot be null or larger than the maximum size
 379   // name we can fit in the constant pool.
 380   if (name == NULL) {
 381     THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), &quot;No class name given&quot;);
 382   }
 383   if ((int)strlen(name) &gt; Symbol::max_length()) {
 384     Exceptions::fthrow(THREAD_AND_LOCATION,
 385                        vmSymbols::java_lang_NoClassDefFoundError(),
 386                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 387                        Symbol::max_length(),
 388                        name);
 389     return 0;
 390   }
 391 
 392   //%note jni_3
 393   Handle protection_domain;
 394   // Find calling class
 395   Klass* k = thread-&gt;security_get_caller_class(0);
 396   // default to the system loader when no context
 397   Handle loader(THREAD, SystemDictionary::java_system_loader());
 398   if (k != NULL) {
 399     // Special handling to make sure JNI_OnLoad and JNI_OnUnload are executed
 400     // in the correct class context.
 401     if (k-&gt;class_loader() == NULL &amp;&amp;
 402         k-&gt;name() == vmSymbols::java_lang_ClassLoader_NativeLibrary()) {
 403       JavaValue result(T_OBJECT);
 404       JavaCalls::call_static(&amp;result, k,
 405                              vmSymbols::getFromClass_name(),
 406                              vmSymbols::void_class_signature(),
 407                              CHECK_NULL);
 408       // When invoked from JNI_OnLoad, NativeLibrary::getFromClass returns
 409       // a non-NULL Class object.  When invoked from JNI_OnUnload,
 410       // it will return NULL to indicate no context.
 411       oop mirror = (oop) result.get_jobject();
 412       if (mirror != NULL) {
 413         Klass* fromClass = java_lang_Class::as_Klass(mirror);
 414         loader = Handle(THREAD, fromClass-&gt;class_loader());
 415         protection_domain = Handle(THREAD, fromClass-&gt;protection_domain());
 416       }
 417     } else {
 418       loader = Handle(THREAD, k-&gt;class_loader());
 419     }
 420   }
 421 
 422   TempNewSymbol sym = SymbolTable::new_symbol(name);
 423   result = find_class_from_class_loader(env, sym, true, loader,
 424                                         protection_domain, true, thread);
 425 
 426   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 427     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 428   }
 429 
 430   return result;
 431 JNI_END
 432 
 433 DT_RETURN_MARK_DECL(FromReflectedMethod, jmethodID
 434                     , HOTSPOT_JNI_FROMREFLECTEDMETHOD_RETURN((uintptr_t)_ret_ref));
 435 
 436 JNI_ENTRY(jmethodID, jni_FromReflectedMethod(JNIEnv *env, jobject method))
 437   JNIWrapper(&quot;FromReflectedMethod&quot;);
 438 
 439   HOTSPOT_JNI_FROMREFLECTEDMETHOD_ENTRY(env, method);
 440 
 441   jmethodID ret = NULL;
 442   DT_RETURN_MARK(FromReflectedMethod, jmethodID, (const jmethodID&amp;)ret);
 443 
 444   // method is a handle to a java.lang.reflect.Method object
 445   oop reflected  = JNIHandles::resolve_non_null(method);
 446   oop mirror     = NULL;
 447   int slot       = 0;
 448 
 449   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 450     mirror = java_lang_reflect_Constructor::clazz(reflected);
 451     slot   = java_lang_reflect_Constructor::slot(reflected);
 452   } else {
 453     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(), &quot;wrong type&quot;);
 454     mirror = java_lang_reflect_Method::clazz(reflected);
 455     slot   = java_lang_reflect_Method::slot(reflected);
 456   }
 457   Klass* k1 = java_lang_Class::as_Klass(mirror);
 458 
 459   // Make sure class is initialized before handing id&#39;s out to methods
 460   k1-&gt;initialize(CHECK_NULL);
 461   Method* m = InstanceKlass::cast(k1)-&gt;method_with_idnum(slot);
 462   ret = m==NULL? NULL : m-&gt;jmethod_id();  // return NULL if reflected method deleted
 463   return ret;
 464 JNI_END
 465 
 466 DT_RETURN_MARK_DECL(FromReflectedField, jfieldID
 467                     , HOTSPOT_JNI_FROMREFLECTEDFIELD_RETURN((uintptr_t)_ret_ref));
 468 
 469 JNI_ENTRY(jfieldID, jni_FromReflectedField(JNIEnv *env, jobject field))
 470   JNIWrapper(&quot;FromReflectedField&quot;);
 471 
 472   HOTSPOT_JNI_FROMREFLECTEDFIELD_ENTRY(env, field);
 473 
 474   jfieldID ret = NULL;
 475   DT_RETURN_MARK(FromReflectedField, jfieldID, (const jfieldID&amp;)ret);
 476 
 477   // field is a handle to a java.lang.reflect.Field object
 478   oop reflected   = JNIHandles::resolve_non_null(field);
 479   oop mirror      = java_lang_reflect_Field::clazz(reflected);
 480   Klass* k1       = java_lang_Class::as_Klass(mirror);
 481   int slot        = java_lang_reflect_Field::slot(reflected);
 482   int modifiers   = java_lang_reflect_Field::modifiers(reflected);
 483 
 484   // Make sure class is initialized before handing id&#39;s out to fields
 485   k1-&gt;initialize(CHECK_NULL);
 486 
 487   // First check if this is a static field
 488   if (modifiers &amp; JVM_ACC_STATIC) {
 489     intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 490     JNIid* id = InstanceKlass::cast(k1)-&gt;jni_id_for(offset);
 491     assert(id != NULL, &quot;corrupt Field object&quot;);
 492     debug_only(id-&gt;set_is_static_field_id();)
 493     // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
 494     ret = jfieldIDWorkaround::to_static_jfieldID(id);
 495     return ret;
 496   }
 497 
 498   // The slot is the index of the field description in the field-array
 499   // The jfieldID is the offset of the field within the object
 500   // It may also have hash bits for k, if VerifyJNIFields is turned on.
 501   intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 502   bool is_flattened = InstanceKlass::cast(k1)-&gt;field_is_flattened(slot);
 503   assert(InstanceKlass::cast(k1)-&gt;contains_field_offset(offset), &quot;stay within object&quot;);
 504   ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset, is_flattened);
 505   return ret;
 506 JNI_END
 507 
 508 
 509 DT_RETURN_MARK_DECL(ToReflectedMethod, jobject
 510                     , HOTSPOT_JNI_TOREFLECTEDMETHOD_RETURN(_ret_ref));
 511 
 512 JNI_ENTRY(jobject, jni_ToReflectedMethod(JNIEnv *env, jclass cls, jmethodID method_id, jboolean isStatic))
 513   JNIWrapper(&quot;ToReflectedMethod&quot;);
 514 
 515   HOTSPOT_JNI_TOREFLECTEDMETHOD_ENTRY(env, cls, (uintptr_t) method_id, isStatic);
 516 
 517   jobject ret = NULL;
 518   DT_RETURN_MARK(ToReflectedMethod, jobject, (const jobject&amp;)ret);
 519 
 520   methodHandle m (THREAD, Method::resolve_jmethod_id(method_id));
 521   assert(m-&gt;is_static() == (isStatic != 0), &quot;jni_ToReflectedMethod access flags doesn&#39;t match&quot;);
 522   oop reflection_method;
 523   if (m-&gt;is_object_constructor()) {
 524     reflection_method = Reflection::new_constructor(m, CHECK_NULL);
 525   } else {
 526     reflection_method = Reflection::new_method(m, false, CHECK_NULL);
 527   }
 528   ret = JNIHandles::make_local(env, reflection_method);
 529   return ret;
 530 JNI_END
 531 
 532 DT_RETURN_MARK_DECL(GetSuperclass, jclass
 533                     , HOTSPOT_JNI_GETSUPERCLASS_RETURN(_ret_ref));
 534 
 535 JNI_ENTRY(jclass, jni_GetSuperclass(JNIEnv *env, jclass sub))
 536   JNIWrapper(&quot;GetSuperclass&quot;);
 537 
 538   HOTSPOT_JNI_GETSUPERCLASS_ENTRY(env, sub);
 539 
 540   jclass obj = NULL;
 541   DT_RETURN_MARK(GetSuperclass, jclass, (const jclass&amp;)obj);
 542 
 543   oop mirror = JNIHandles::resolve_non_null(sub);
 544   // primitive classes return NULL
 545   if (java_lang_Class::is_primitive(mirror)) return NULL;
 546 
 547   // Rules of Class.getSuperClass as implemented by KLass::java_super:
 548   // arrays return Object
 549   // interfaces return NULL
 550   // proper classes return Klass::super()
 551   Klass* k = java_lang_Class::as_Klass(mirror);
 552   if (k-&gt;is_interface()) return NULL;
 553 
 554   // return mirror for superclass
 555   Klass* super = k-&gt;java_super();
 556   // super2 is the value computed by the compiler&#39;s getSuperClass intrinsic:
 557   debug_only(Klass* super2 = ( k-&gt;is_array_klass()
 558                                  ? SystemDictionary::Object_klass()
 559                                  : k-&gt;super() ) );
 560   assert(super == super2,
 561          &quot;java_super computation depends on interface, array, other super&quot;);
 562   obj = (super == NULL) ? NULL : (jclass) JNIHandles::make_local(super-&gt;java_mirror());
 563   return obj;
 564 JNI_END
 565 
 566 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))
 567   JNIWrapper(&quot;IsSubclassOf&quot;);
 568 
 569   HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);
 570 
 571   oop sub_mirror   = JNIHandles::resolve_non_null(sub);
 572   oop super_mirror = JNIHandles::resolve_non_null(super);
 573   if (java_lang_Class::is_primitive(sub_mirror) ||
 574       java_lang_Class::is_primitive(super_mirror)) {
 575     jboolean ret = (sub_mirror == super_mirror);
 576 
 577     HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 578     return ret;
 579   }
 580   Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
 581   Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
 582   assert(sub_klass != NULL &amp;&amp; super_klass != NULL, &quot;invalid arguments to jni_IsAssignableFrom&quot;);
 583   jboolean ret = sub_klass-&gt;is_subtype_of(super_klass) ?
 584                    JNI_TRUE : JNI_FALSE;
 585   if (sub_klass == super_klass &amp;&amp; sub_klass-&gt;is_value()) {
 586     // for inline class, V &lt;: V?
 587     ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(sub_klass));
 588     if (sub_mirror == super_mirror || (sub_mirror == vk-&gt;value_mirror() &amp;&amp; super_mirror == vk-&gt;indirect_mirror())) {
 589       ret = JNI_TRUE;
 590     } else {
 591       ret = JNI_FALSE;
 592     }
 593   }
 594   HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 595   return ret;
 596 JNI_END
 597 
 598 
 599 DT_RETURN_MARK_DECL(Throw, jint
 600                     , HOTSPOT_JNI_THROW_RETURN(_ret_ref));
 601 
 602 JNI_ENTRY(jint, jni_Throw(JNIEnv *env, jthrowable obj))
 603   JNIWrapper(&quot;Throw&quot;);
 604 
 605   HOTSPOT_JNI_THROW_ENTRY(env, obj);
 606 
 607   jint ret = JNI_OK;
 608   DT_RETURN_MARK(Throw, jint, (const jint&amp;)ret);
 609 
 610   THROW_OOP_(JNIHandles::resolve(obj), JNI_OK);
 611   ShouldNotReachHere();
 612   return 0;  // Mute compiler.
 613 JNI_END
 614 
 615 
 616 DT_RETURN_MARK_DECL(ThrowNew, jint
 617                     , HOTSPOT_JNI_THROWNEW_RETURN(_ret_ref));
 618 
 619 JNI_ENTRY(jint, jni_ThrowNew(JNIEnv *env, jclass clazz, const char *message))
 620   JNIWrapper(&quot;ThrowNew&quot;);
 621 
 622   HOTSPOT_JNI_THROWNEW_ENTRY(env, clazz, (char *) message);
 623 
 624   jint ret = JNI_OK;
 625   DT_RETURN_MARK(ThrowNew, jint, (const jint&amp;)ret);
 626 
 627   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
 628   Symbol*  name = k-&gt;name();
 629   Handle class_loader (THREAD,  k-&gt;class_loader());
 630   Handle protection_domain (THREAD, k-&gt;protection_domain());
 631   THROW_MSG_LOADER_(name, (char *)message, class_loader, protection_domain, JNI_OK);
 632   ShouldNotReachHere();
 633   return 0;  // Mute compiler.
 634 JNI_END
 635 
 636 
 637 // JNI functions only transform a pending async exception to a synchronous
 638 // exception in ExceptionOccurred and ExceptionCheck calls, since
 639 // delivering an async exception in other places won&#39;t change the native
 640 // code&#39;s control flow and would be harmful when native code further calls
 641 // JNI functions with a pending exception. Async exception is also checked
 642 // during the call, so ExceptionOccurred/ExceptionCheck won&#39;t return
 643 // false but deliver the async exception at the very end during
 644 // state transition.
 645 
 646 static void jni_check_async_exceptions(JavaThread *thread) {
 647   assert(thread == Thread::current(), &quot;must be itself&quot;);
 648   thread-&gt;check_and_handle_async_exceptions();
 649 }
 650 
 651 JNI_ENTRY_NO_PRESERVE(jthrowable, jni_ExceptionOccurred(JNIEnv *env))
 652   JNIWrapper(&quot;ExceptionOccurred&quot;);
 653 
 654   HOTSPOT_JNI_EXCEPTIONOCCURRED_ENTRY(env);
 655 
 656   jni_check_async_exceptions(thread);
 657   oop exception = thread-&gt;pending_exception();
 658   jthrowable ret = (jthrowable) JNIHandles::make_local(env, exception);
 659 
 660   HOTSPOT_JNI_EXCEPTIONOCCURRED_RETURN(ret);
 661   return ret;
 662 JNI_END
 663 
 664 
 665 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionDescribe(JNIEnv *env))
 666   JNIWrapper(&quot;ExceptionDescribe&quot;);
 667 
 668   HOTSPOT_JNI_EXCEPTIONDESCRIBE_ENTRY(env);
 669 
 670   if (thread-&gt;has_pending_exception()) {
 671     Handle ex(thread, thread-&gt;pending_exception());
 672     thread-&gt;clear_pending_exception();
 673     if (ex-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
 674       // Don&#39;t print anything if we are being killed.
 675     } else {
 676       jio_fprintf(defaultStream::error_stream(), &quot;Exception &quot;);
 677       if (thread != NULL &amp;&amp; thread-&gt;threadObj() != NULL) {
 678         ResourceMark rm(THREAD);
 679         jio_fprintf(defaultStream::error_stream(),
 680         &quot;in thread \&quot;%s\&quot; &quot;, thread-&gt;get_thread_name());
 681       }
 682       if (ex-&gt;is_a(SystemDictionary::Throwable_klass())) {
 683         JavaValue result(T_VOID);
 684         JavaCalls::call_virtual(&amp;result,
 685                                 ex,
 686                                 SystemDictionary::Throwable_klass(),
 687                                 vmSymbols::printStackTrace_name(),
 688                                 vmSymbols::void_method_signature(),
 689                                 THREAD);
 690         // If an exception is thrown in the call it gets thrown away. Not much
 691         // we can do with it. The native code that calls this, does not check
 692         // for the exception - hence, it might still be in the thread when DestroyVM gets
 693         // called, potentially causing a few asserts to trigger - since no pending exception
 694         // is expected.
 695         CLEAR_PENDING_EXCEPTION;
 696       } else {
 697         ResourceMark rm(THREAD);
 698         jio_fprintf(defaultStream::error_stream(),
 699         &quot;. Uncaught exception of type %s.&quot;,
 700         ex-&gt;klass()-&gt;external_name());
 701       }
 702     }
 703   }
 704 
 705   HOTSPOT_JNI_EXCEPTIONDESCRIBE_RETURN();
 706 JNI_END
 707 
 708 
 709 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionClear(JNIEnv *env))
 710   JNIWrapper(&quot;ExceptionClear&quot;);
 711 
 712   HOTSPOT_JNI_EXCEPTIONCLEAR_ENTRY(env);
 713 
 714   // The jni code might be using this API to clear java thrown exception.
 715   // So just mark jvmti thread exception state as exception caught.
 716   JvmtiThreadState *state = JavaThread::current()-&gt;jvmti_thread_state();
 717   if (state != NULL &amp;&amp; state-&gt;is_exception_detected()) {
 718     state-&gt;set_exception_caught();
 719   }
 720   thread-&gt;clear_pending_exception();
 721 
 722   HOTSPOT_JNI_EXCEPTIONCLEAR_RETURN();
 723 JNI_END
 724 
 725 
 726 JNI_ENTRY(void, jni_FatalError(JNIEnv *env, const char *msg))
 727   JNIWrapper(&quot;FatalError&quot;);
 728 
 729   HOTSPOT_JNI_FATALERROR_ENTRY(env, (char *) msg);
 730 
 731   tty-&gt;print_cr(&quot;FATAL ERROR in native method: %s&quot;, msg);
 732   thread-&gt;print_stack();
 733   os::abort(); // Dump core and abort
 734 JNI_END
 735 
 736 
 737 JNI_ENTRY(jint, jni_PushLocalFrame(JNIEnv *env, jint capacity))
 738   JNIWrapper(&quot;PushLocalFrame&quot;);
 739 
 740   HOTSPOT_JNI_PUSHLOCALFRAME_ENTRY(env, capacity);
 741 
 742   //%note jni_11
 743   if (capacity &lt; 0 ||
 744       ((MaxJNILocalCapacity &gt; 0) &amp;&amp; (capacity &gt; MaxJNILocalCapacity))) {
 745     HOTSPOT_JNI_PUSHLOCALFRAME_RETURN((uint32_t)JNI_ERR);
 746     return JNI_ERR;
 747   }
 748   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 749   JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(thread);
 750   assert(new_handles != NULL, &quot;should not be NULL&quot;);
 751   new_handles-&gt;set_pop_frame_link(old_handles);
 752   thread-&gt;set_active_handles(new_handles);
 753   jint ret = JNI_OK;
 754   HOTSPOT_JNI_PUSHLOCALFRAME_RETURN(ret);
 755   return ret;
 756 JNI_END
 757 
 758 
 759 JNI_ENTRY(jobject, jni_PopLocalFrame(JNIEnv *env, jobject result))
 760   JNIWrapper(&quot;PopLocalFrame&quot;);
 761 
 762   HOTSPOT_JNI_POPLOCALFRAME_ENTRY(env, result);
 763 
 764   //%note jni_11
 765   Handle result_handle(thread, JNIHandles::resolve(result));
 766   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 767   JNIHandleBlock* new_handles = old_handles-&gt;pop_frame_link();
 768   if (new_handles != NULL) {
 769     // As a sanity check we only release the handle blocks if the pop_frame_link is not NULL.
 770     // This way code will still work if PopLocalFrame is called without a corresponding
 771     // PushLocalFrame call. Note that we set the pop_frame_link to NULL explicitly, otherwise
 772     // the release_block call will release the blocks.
 773     thread-&gt;set_active_handles(new_handles);
 774     old_handles-&gt;set_pop_frame_link(NULL);              // clear link we won&#39;t release new_handles below
 775     JNIHandleBlock::release_block(old_handles, thread); // may block
 776     result = JNIHandles::make_local(thread, result_handle());
 777   }
 778   HOTSPOT_JNI_POPLOCALFRAME_RETURN(result);
 779   return result;
 780 JNI_END
 781 
 782 
 783 JNI_ENTRY(jobject, jni_NewGlobalRef(JNIEnv *env, jobject ref))
 784   JNIWrapper(&quot;NewGlobalRef&quot;);
 785 
 786   HOTSPOT_JNI_NEWGLOBALREF_ENTRY(env, ref);
 787 
 788   Handle ref_handle(thread, JNIHandles::resolve(ref));
 789   jobject ret = JNIHandles::make_global(ref_handle);
 790 
 791   HOTSPOT_JNI_NEWGLOBALREF_RETURN(ret);
 792   return ret;
 793 JNI_END
 794 
 795 // Must be JNI_ENTRY (with HandleMark)
 796 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteGlobalRef(JNIEnv *env, jobject ref))
 797   JNIWrapper(&quot;DeleteGlobalRef&quot;);
 798 
 799   HOTSPOT_JNI_DELETEGLOBALREF_ENTRY(env, ref);
 800 
 801   JNIHandles::destroy_global(ref);
 802 
 803   HOTSPOT_JNI_DELETEGLOBALREF_RETURN();
 804 JNI_END
 805 
 806 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteLocalRef(JNIEnv *env, jobject obj))
 807   JNIWrapper(&quot;DeleteLocalRef&quot;);
 808 
 809   HOTSPOT_JNI_DELETELOCALREF_ENTRY(env, obj);
 810 
 811   JNIHandles::destroy_local(obj);
 812 
 813   HOTSPOT_JNI_DELETELOCALREF_RETURN();
 814 JNI_END
 815 
 816 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsSameObject(JNIEnv *env, jobject r1, jobject r2))
 817   JNIWrapper(&quot;IsSameObject&quot;);
 818 
 819   HOTSPOT_JNI_ISSAMEOBJECT_ENTRY(env, r1, r2);
 820 
 821   jboolean ret = JNIHandles::is_same_object(r1, r2) ? JNI_TRUE : JNI_FALSE;
 822 
 823   HOTSPOT_JNI_ISSAMEOBJECT_RETURN(ret);
 824   return ret;
 825 JNI_END
 826 
 827 
 828 JNI_ENTRY(jobject, jni_NewLocalRef(JNIEnv *env, jobject ref))
 829   JNIWrapper(&quot;NewLocalRef&quot;);
 830 
 831   HOTSPOT_JNI_NEWLOCALREF_ENTRY(env, ref);
 832 
 833   jobject ret = JNIHandles::make_local(env, JNIHandles::resolve(ref));
 834 
 835   HOTSPOT_JNI_NEWLOCALREF_RETURN(ret);
 836   return ret;
 837 JNI_END
 838 
 839 JNI_LEAF(jint, jni_EnsureLocalCapacity(JNIEnv *env, jint capacity))
 840   JNIWrapper(&quot;EnsureLocalCapacity&quot;);
 841 
 842   HOTSPOT_JNI_ENSURELOCALCAPACITY_ENTRY(env, capacity);
 843 
 844   jint ret;
 845   if (capacity &gt;= 0 &amp;&amp;
 846       ((MaxJNILocalCapacity &lt;= 0) || (capacity &lt;= MaxJNILocalCapacity))) {
 847     ret = JNI_OK;
 848   } else {
 849     ret = JNI_ERR;
 850   }
 851 
 852   HOTSPOT_JNI_ENSURELOCALCAPACITY_RETURN(ret);
 853   return ret;
 854 JNI_END
 855 
 856 // Return the Handle Type
 857 JNI_LEAF(jobjectRefType, jni_GetObjectRefType(JNIEnv *env, jobject obj))
 858   JNIWrapper(&quot;GetObjectRefType&quot;);
 859 
 860   HOTSPOT_JNI_GETOBJECTREFTYPE_ENTRY(env, obj);
 861 
 862   jobjectRefType ret = JNIInvalidRefType;
 863   if (obj != NULL) {
 864     ret = JNIHandles::handle_type(thread, obj);
 865   }
 866 
 867   HOTSPOT_JNI_GETOBJECTREFTYPE_RETURN((void *) ret);
 868   return ret;
 869 JNI_END
 870 
 871 
 872 class JNI_ArgumentPusher : public SignatureIterator {
 873  protected:
 874   JavaCallArguments*  _arguments;
 875 
 876   void push_int(jint x)         { _arguments-&gt;push_int(x); }
 877   void push_long(jlong x)       { _arguments-&gt;push_long(x); }
 878   void push_float(jfloat x)     { _arguments-&gt;push_float(x); }
 879   void push_double(jdouble x)   { _arguments-&gt;push_double(x); }
 880   void push_object(jobject x)   { _arguments-&gt;push_jobject(x); }
 881 
 882   void push_boolean(jboolean b) {
 883     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and
 884     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in
 885     // TemplateInterpreterGenerator::generate_result_handler_for and
 886     // SharedRuntime::generate_native_wrapper.
 887     push_int(b == 0 ? JNI_FALSE : JNI_TRUE);
 888   }
 889 
 890   JNI_ArgumentPusher(Method* method)
 891     : SignatureIterator(method-&gt;signature(),
 892                         Fingerprinter(methodHandle(Thread::current(), method)).fingerprint())
 893   {
 894     _arguments = NULL;
 895   }
 896 
 897  public:
 898   virtual void push_arguments_on(JavaCallArguments* arguments) = 0;
 899 };
 900 
 901 
 902 class JNI_ArgumentPusherVaArg : public JNI_ArgumentPusher {
 903  protected:
 904   va_list _ap;
 905 
 906   void set_ap(va_list rap) {
 907     va_copy(_ap, rap);
 908   }
 909 
 910   friend class SignatureIterator;  // so do_parameters_on can call do_type
 911   void do_type(BasicType type) {
 912     switch (type) {
 913     // these are coerced to int when using va_arg
 914     case T_BYTE:
 915     case T_CHAR:
 916     case T_SHORT:
 917     case T_INT:         push_int(va_arg(_ap, jint)); break;
 918     case T_BOOLEAN:     push_boolean((jboolean) va_arg(_ap, jint)); break;
 919 
 920     // each of these paths is exercised by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests
 921 
 922     case T_LONG:        push_long(va_arg(_ap, jlong)); break;
 923     // float is coerced to double w/ va_arg
 924     case T_FLOAT:       push_float((jfloat) va_arg(_ap, jdouble)); break;
 925     case T_DOUBLE:      push_double(va_arg(_ap, jdouble)); break;
 926 
 927     case T_ARRAY:
 928     case T_OBJECT:
 929     case T_VALUETYPE:   push_object(va_arg(_ap, jobject)); break;
 930     default:            ShouldNotReachHere();
 931     }
 932   }
 933 
 934  public:
 935   JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
 936       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
 937     set_ap(rap);
 938   }
 939 
 940   virtual void push_arguments_on(JavaCallArguments* arguments) {
 941     _arguments = arguments;
 942     do_parameters_on(this);
 943   }
 944 };
 945 
 946 
 947 class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
 948  protected:
 949   const jvalue *_ap;
 950 
 951   inline void set_ap(const jvalue *rap) { _ap = rap; }
 952 
 953   friend class SignatureIterator;  // so do_parameters_on can call do_type
 954   void do_type(BasicType type) {
 955     switch (type) {
 956     case T_CHAR:        push_int((_ap++)-&gt;c); break;
 957     case T_SHORT:       push_int((_ap++)-&gt;s); break;
 958     case T_BYTE:        push_int((_ap++)-&gt;b); break;
 959     case T_INT:         push_int((_ap++)-&gt;i); break;
 960     case T_BOOLEAN:     push_boolean((_ap++)-&gt;z); break;
 961     case T_LONG:        push_long((_ap++)-&gt;j); break;
 962     case T_FLOAT:       push_float((_ap++)-&gt;f); break;
 963     case T_DOUBLE:      push_double((_ap++)-&gt;d); break;
 964     case T_ARRAY:
 965     case T_OBJECT:
 966     case T_VALUETYPE:   push_object((_ap++)-&gt;l); break;
 967     default:            ShouldNotReachHere();
 968     }
 969   }
 970 
 971  public:
 972   JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
 973       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
 974     set_ap(rap);
 975   }
 976 
 977   virtual void push_arguments_on(JavaCallArguments* arguments) {
 978     _arguments = arguments;
 979     do_parameters_on(this);
 980   }
 981 };
 982 
 983 
 984 enum JNICallType {
 985   JNI_STATIC,
 986   JNI_VIRTUAL,
 987   JNI_NONVIRTUAL
 988 };
 989 
 990 
 991 
 992 static void jni_invoke_static(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
 993   methodHandle method(THREAD, Method::resolve_jmethod_id(method_id));
 994 
 995   // Create object to hold arguments for the JavaCall, and associate it with
 996   // the jni parser
 997   ResourceMark rm(THREAD);
 998   int number_of_parameters = method-&gt;size_of_parameters();
 999   JavaCallArguments java_args(number_of_parameters);
1000 
1001   assert(method-&gt;is_static(), &quot;method should be static&quot;);
1002 
1003   // Fill out JavaCallArguments object
1004   args-&gt;push_arguments_on(&amp;java_args);
1005   // Initialize result type
1006   result-&gt;set_type(args-&gt;return_type());
1007 
1008   // Invoke the method. Result is returned as oop.
1009   JavaCalls::call(result, method, &amp;java_args, CHECK);
1010 
1011   // Convert result
1012   if (is_reference_type(result-&gt;get_type())) {
1013     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1014   }
1015 }
1016 
1017 
1018 static void jni_invoke_nonstatic(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1019   oop recv = JNIHandles::resolve(receiver);
1020   if (recv == NULL) {
1021     THROW(vmSymbols::java_lang_NullPointerException());
1022   }
1023   Handle h_recv(THREAD, recv);
1024 
1025   int number_of_parameters;
1026   Method* selected_method;
1027   {
1028     Method* m = Method::resolve_jmethod_id(method_id);
1029     number_of_parameters = m-&gt;size_of_parameters();
1030     Klass* holder = m-&gt;method_holder();
1031     if (call_type != JNI_VIRTUAL) {
1032         selected_method = m;
1033     } else if (!m-&gt;has_itable_index()) {
1034       // non-interface call -- for that little speed boost, don&#39;t handlize
1035       debug_only(NoSafepointVerifier nosafepoint;)
1036       // jni_GetMethodID makes sure class is linked and initialized
1037       // so m should have a valid vtable index.
1038       assert(m-&gt;valid_vtable_index(), &quot;no valid vtable index&quot;);
1039       int vtbl_index = m-&gt;vtable_index();
1040       if (vtbl_index != Method::nonvirtual_vtable_index) {
1041         selected_method = h_recv-&gt;klass()-&gt;method_at_vtable(vtbl_index);
1042       } else {
1043         // final method
1044         selected_method = m;
1045       }
1046     } else {
1047       // interface call
1048       int itbl_index = m-&gt;itable_index();
1049       Klass* k = h_recv-&gt;klass();
1050       selected_method = InstanceKlass::cast(k)-&gt;method_at_itable(holder, itbl_index, CHECK);
1051     }
1052   }
1053 
1054   methodHandle method(THREAD, selected_method);
1055 
1056   // Create object to hold arguments for the JavaCall, and associate it with
1057   // the jni parser
1058   ResourceMark rm(THREAD);
1059   JavaCallArguments java_args(number_of_parameters);
1060 
1061   // handle arguments
1062   assert(!method-&gt;is_static(), &quot;method %s should not be static&quot;, method-&gt;name_and_sig_as_C_string());
1063   java_args.push_oop(h_recv); // Push jobject handle
1064 
1065   // Fill out JavaCallArguments object
1066   args-&gt;push_arguments_on(&amp;java_args);
1067   // Initialize result type
1068   result-&gt;set_type(args-&gt;return_type());
1069 
1070   // Invoke the method. Result is returned as oop.
1071   JavaCalls::call(result, method, &amp;java_args, CHECK);
1072 
1073   // Convert result
1074   if (is_reference_type(result-&gt;get_type())) {
1075     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1076   }
1077 }
1078 
1079 
1080 static instanceOop alloc_object(jclass clazz, TRAPS) {
1081   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1082   if (k == NULL) {
1083     ResourceMark rm(THREAD);
1084     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1085   }
1086   k-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1087   k-&gt;initialize(CHECK_NULL);
1088   instanceOop ih = InstanceKlass::cast(k)-&gt;allocate_instance(THREAD);
1089   return ih;
1090 }
1091 
1092 DT_RETURN_MARK_DECL(AllocObject, jobject
1093                     , HOTSPOT_JNI_ALLOCOBJECT_RETURN(_ret_ref));
1094 
1095 JNI_ENTRY(jobject, jni_AllocObject(JNIEnv *env, jclass clazz))
1096   JNIWrapper(&quot;AllocObject&quot;);
1097 
1098   HOTSPOT_JNI_ALLOCOBJECT_ENTRY(env, clazz);
1099 
1100   jobject ret = NULL;
1101   DT_RETURN_MARK(AllocObject, jobject, (const jobject&amp;)ret);
1102 
1103   instanceOop i = alloc_object(clazz, CHECK_NULL);
1104   ret = JNIHandles::make_local(env, i);
1105   return ret;
1106 JNI_END
1107 
1108 DT_RETURN_MARK_DECL(NewObjectA, jobject
1109                     , HOTSPOT_JNI_NEWOBJECTA_RETURN(_ret_ref));
1110 
1111 JNI_ENTRY(jobject, jni_NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args))
1112   JNIWrapper(&quot;NewObjectA&quot;);
1113 
1114   HOTSPOT_JNI_NEWOBJECTA_ENTRY(env, clazz, (uintptr_t) methodID);
1115 
1116   jobject obj = NULL;
1117   DT_RETURN_MARK(NewObjectA, jobject, (const jobject)obj);
1118 
1119   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1120   if (k == NULL) {
1121     ResourceMark rm(THREAD);
1122     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1123   }
1124 
1125   if (!k-&gt;is_value()) {
1126     instanceOop i = alloc_object(clazz, CHECK_NULL);
1127     obj = JNIHandles::make_local(env, i);
1128     JavaValue jvalue(T_VOID);
1129     JNI_ArgumentPusherArray ap(methodID, args);
1130     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1131   } else {
1132     JavaValue jvalue(T_VALUETYPE);
1133     JNI_ArgumentPusherArray ap(methodID, args);
1134     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);
1135     obj = jvalue.get_jobject();
1136   }
1137   return obj;
1138   JNI_END
1139 
1140 
1141 DT_RETURN_MARK_DECL(NewObjectV, jobject
1142                     , HOTSPOT_JNI_NEWOBJECTV_RETURN(_ret_ref));
1143 
1144 JNI_ENTRY(jobject, jni_NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args))
1145   JNIWrapper(&quot;NewObjectV&quot;);
1146 
1147   HOTSPOT_JNI_NEWOBJECTV_ENTRY(env, clazz, (uintptr_t) methodID);
1148 
1149   jobject obj = NULL;
1150   DT_RETURN_MARK(NewObjectV, jobject, (const jobject&amp;)obj);
1151 
1152   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1153   if (k == NULL) {
1154     ResourceMark rm(THREAD);
1155     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1156   }
1157 
1158   if (!k-&gt;is_value()) {
1159     instanceOop i = alloc_object(clazz, CHECK_NULL);
1160     obj = JNIHandles::make_local(env, i);
1161     JavaValue jvalue(T_VOID);
1162     JNI_ArgumentPusherVaArg ap(methodID, args);
1163     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1164   } else {
1165     JavaValue jvalue(T_VALUETYPE);
1166     JNI_ArgumentPusherVaArg ap(methodID, args);
1167     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);
1168     obj = jvalue.get_jobject();
1169   }
1170   return obj;
1171 JNI_END
1172 
1173 
1174 DT_RETURN_MARK_DECL(NewObject, jobject
1175                     , HOTSPOT_JNI_NEWOBJECT_RETURN(_ret_ref));
1176 
1177 JNI_ENTRY(jobject, jni_NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...))
1178   JNIWrapper(&quot;NewObject&quot;);
1179 
1180   HOTSPOT_JNI_NEWOBJECT_ENTRY(env, clazz, (uintptr_t) methodID);
1181 
1182   jobject obj = NULL;
1183   DT_RETURN_MARK(NewObject, jobject, (const jobject&amp;)obj);
1184 
1185   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1186   if (k == NULL) {
1187     ResourceMark rm(THREAD);
1188     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1189   }
1190 
1191   if (!k-&gt;is_value()) {
1192     instanceOop i = alloc_object(clazz, CHECK_NULL);
1193     obj = JNIHandles::make_local(env, i);
1194     va_list args;
1195     va_start(args, methodID);
1196     JavaValue jvalue(T_VOID);
1197     JNI_ArgumentPusherVaArg ap(methodID, args);
1198     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1199     va_end(args);
1200   } else {
1201     va_list args;
1202     va_start(args, methodID);
1203     JavaValue jvalue(T_VALUETYPE);
1204     JNI_ArgumentPusherVaArg ap(methodID, args);
1205     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);
1206     va_end(args);
1207     obj = jvalue.get_jobject();
1208   }
1209   return obj;
1210 JNI_END
1211 
1212 
1213 JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
1214   JNIWrapper(&quot;GetObjectClass&quot;);
1215 
1216   HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(env, obj);
1217 
1218   Klass* k = JNIHandles::resolve_non_null(obj)-&gt;klass();
1219   jclass ret =
1220     (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1221 
1222   HOTSPOT_JNI_GETOBJECTCLASS_RETURN(ret);
1223   return ret;
1224 JNI_END
1225 
1226 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))
1227   JNIWrapper(&quot;IsInstanceOf&quot;);
1228 
1229   HOTSPOT_JNI_ISINSTANCEOF_ENTRY(env, obj, clazz);
1230 
1231   jboolean ret = JNI_TRUE;
1232   if (obj != NULL) {
1233     ret = JNI_FALSE;
1234     Klass* k = java_lang_Class::as_Klass(
1235       JNIHandles::resolve_non_null(clazz));
1236     if (k != NULL) {
1237       ret = JNIHandles::resolve_non_null(obj)-&gt;is_a(k) ? JNI_TRUE : JNI_FALSE;
1238     }
1239   }
1240 
1241   HOTSPOT_JNI_ISINSTANCEOF_RETURN(ret);
1242   return ret;
1243 JNI_END
1244 
1245 
1246 static jmethodID get_method_id(JNIEnv *env, jclass clazz, const char *name_str,
1247                                const char *sig, bool is_static, TRAPS) {
1248   // %%%% This code should probably just call into a method in the LinkResolver
1249   //
1250   // The class should have been loaded (we have an instance of the class
1251   // passed in) so the method and signature should already be in the symbol
1252   // table.  If they&#39;re not there, the method doesn&#39;t exist.
1253   const char *name_to_probe = (name_str == NULL)
1254                         ? vmSymbols::object_initializer_name()-&gt;as_C_string()
1255                         : name_str;
1256   TempNewSymbol name = SymbolTable::probe(name_to_probe, (int)strlen(name_to_probe));
1257   TempNewSymbol signature = SymbolTable::probe(sig, (int)strlen(sig));
1258 
1259   if (name == NULL || signature == NULL) {
1260     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
1261   }
1262 
1263   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1264 
1265   // Throw a NoSuchMethodError exception if we have an instance of a
1266   // primitive java.lang.Class
1267   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(clazz))) {
1268     ResourceMark rm;
1269     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg(&quot;%s%s.%s%s&quot;, is_static ? &quot;static &quot; : &quot;&quot;, klass-&gt;signature_name(), name_str, sig));
1270   }
1271 
1272   // Make sure class is linked and initialized before handing id&#39;s out to
1273   // Method*s.
1274   klass-&gt;initialize(CHECK_NULL);
1275 
1276   Method* m;
1277   if (name == vmSymbols::object_initializer_name() ||
1278       name == vmSymbols::class_initializer_name()) {
1279     // Never search superclasses for constructors
1280     if (klass-&gt;is_instance_klass()) {
1281       m = InstanceKlass::cast(klass)-&gt;find_method(name, signature);
1282     } else {
1283       m = NULL;
1284     }
1285   } else {
1286     m = klass-&gt;lookup_method(name, signature);
1287     if (m == NULL &amp;&amp;  klass-&gt;is_instance_klass()) {
1288       m = InstanceKlass::cast(klass)-&gt;lookup_method_in_ordered_interfaces(name, signature);
1289     }
1290   }
1291   if (m == NULL || (m-&gt;is_static() != is_static)) {
1292     ResourceMark rm;
1293     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg(&quot;%s%s.%s%s&quot;, is_static ? &quot;static &quot; : &quot;&quot;, klass-&gt;signature_name(), name_str, sig));
1294   }
1295   return m-&gt;jmethod_id();
1296 }
1297 
1298 
1299 JNI_ENTRY(jmethodID, jni_GetMethodID(JNIEnv *env, jclass clazz,
1300           const char *name, const char *sig))
1301   JNIWrapper(&quot;GetMethodID&quot;);
1302   HOTSPOT_JNI_GETMETHODID_ENTRY(env, clazz, (char *) name, (char *) sig);
1303   jmethodID ret = get_method_id(env, clazz, name, sig, false, thread);
1304   HOTSPOT_JNI_GETMETHODID_RETURN((uintptr_t) ret);
1305   return ret;
1306 JNI_END
1307 
1308 
1309 JNI_ENTRY(jmethodID, jni_GetStaticMethodID(JNIEnv *env, jclass clazz,
1310           const char *name, const char *sig))
1311   JNIWrapper(&quot;GetStaticMethodID&quot;);
1312   HOTSPOT_JNI_GETSTATICMETHODID_ENTRY(env, (char *) clazz, (char *) name, (char *)sig);
1313   jmethodID ret = get_method_id(env, clazz, name, sig, true, thread);
1314   HOTSPOT_JNI_GETSTATICMETHODID_RETURN((uintptr_t) ret);
1315   return ret;
1316 JNI_END
1317 
1318 
1319 
1320 //
1321 // Calling Methods
1322 //
1323 
1324 
1325 #define DEFINE_CALLMETHOD(ResultType, Result, Tag \
1326                           , EntryProbe, ReturnProbe)    \
1327 \
1328   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##Method, ResultType \
1329                           , ReturnProbe);                          \
1330 \
1331 JNI_ENTRY(ResultType, \
1332           jni_Call##Result##Method(JNIEnv *env, jobject obj, jmethodID methodID, ...)) \
1333   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;Method&quot;); \
1334 \
1335   EntryProbe; \
1336   ResultType ret = 0;\
1337   DT_RETURN_MARK_FOR(Result, Call##Result##Method, ResultType, \
1338                      (const ResultType&amp;)ret);\
1339 \
1340   va_list args; \
1341   va_start(args, methodID); \
1342   JavaValue jvalue(Tag); \
1343   JNI_ArgumentPusherVaArg ap(methodID, args); \
1344   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1345   va_end(args); \
1346   ret = jvalue.get_##ResultType(); \
1347   return ret;\
1348 JNI_END
1349 
1350 // the runtime type of subword integral basic types is integer
1351 DEFINE_CALLMETHOD(jboolean, Boolean, T_BOOLEAN
1352                   , HOTSPOT_JNI_CALLBOOLEANMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1353                   HOTSPOT_JNI_CALLBOOLEANMETHOD_RETURN(_ret_ref))
1354 DEFINE_CALLMETHOD(jbyte,    Byte,    T_BYTE
1355                   , HOTSPOT_JNI_CALLBYTEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1356                   HOTSPOT_JNI_CALLBYTEMETHOD_RETURN(_ret_ref))
1357 DEFINE_CALLMETHOD(jchar,    Char,    T_CHAR
1358                   , HOTSPOT_JNI_CALLCHARMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1359                   HOTSPOT_JNI_CALLCHARMETHOD_RETURN(_ret_ref))
1360 DEFINE_CALLMETHOD(jshort,   Short,   T_SHORT
1361                   , HOTSPOT_JNI_CALLSHORTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1362                   HOTSPOT_JNI_CALLSHORTMETHOD_RETURN(_ret_ref))
1363 
1364 DEFINE_CALLMETHOD(jobject,  Object,  T_OBJECT
1365                   , HOTSPOT_JNI_CALLOBJECTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1366                   HOTSPOT_JNI_CALLOBJECTMETHOD_RETURN(_ret_ref))
1367 DEFINE_CALLMETHOD(jint,     Int,     T_INT,
1368                   HOTSPOT_JNI_CALLINTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1369                   HOTSPOT_JNI_CALLINTMETHOD_RETURN(_ret_ref))
1370 DEFINE_CALLMETHOD(jlong,    Long,    T_LONG
1371                   , HOTSPOT_JNI_CALLLONGMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1372                   HOTSPOT_JNI_CALLLONGMETHOD_RETURN(_ret_ref))
1373 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1374 DEFINE_CALLMETHOD(jfloat,   Float,   T_FLOAT
1375                   , HOTSPOT_JNI_CALLFLOATMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1376                   HOTSPOT_JNI_CALLFLOATMETHOD_RETURN())
1377 DEFINE_CALLMETHOD(jdouble,  Double,  T_DOUBLE
1378                   , HOTSPOT_JNI_CALLDOUBLEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1379                   HOTSPOT_JNI_CALLDOUBLEMETHOD_RETURN())
1380 
1381 #define DEFINE_CALLMETHODV(ResultType, Result, Tag \
1382                           , EntryProbe, ReturnProbe)    \
1383 \
1384   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodV, ResultType \
1385                           , ReturnProbe);                          \
1386 \
1387 JNI_ENTRY(ResultType, \
1388           jni_Call##Result##MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args)) \
1389   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;MethodV&quot;); \
1390 \
1391   EntryProbe;\
1392   ResultType ret = 0;\
1393   DT_RETURN_MARK_FOR(Result, Call##Result##MethodV, ResultType, \
1394                      (const ResultType&amp;)ret);\
1395 \
1396   JavaValue jvalue(Tag); \
1397   JNI_ArgumentPusherVaArg ap(methodID, args); \
1398   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1399   ret = jvalue.get_##ResultType(); \
1400   return ret;\
1401 JNI_END
1402 
1403 // the runtime type of subword integral basic types is integer
1404 DEFINE_CALLMETHODV(jboolean, Boolean, T_BOOLEAN
1405                   , HOTSPOT_JNI_CALLBOOLEANMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1406                   HOTSPOT_JNI_CALLBOOLEANMETHODV_RETURN(_ret_ref))
1407 DEFINE_CALLMETHODV(jbyte,    Byte,    T_BYTE
1408                   , HOTSPOT_JNI_CALLBYTEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1409                   HOTSPOT_JNI_CALLBYTEMETHODV_RETURN(_ret_ref))
1410 DEFINE_CALLMETHODV(jchar,    Char,    T_CHAR
1411                   , HOTSPOT_JNI_CALLCHARMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1412                   HOTSPOT_JNI_CALLCHARMETHODV_RETURN(_ret_ref))
1413 DEFINE_CALLMETHODV(jshort,   Short,   T_SHORT
1414                   , HOTSPOT_JNI_CALLSHORTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1415                   HOTSPOT_JNI_CALLSHORTMETHODV_RETURN(_ret_ref))
1416 
1417 DEFINE_CALLMETHODV(jobject,  Object,  T_OBJECT
1418                   , HOTSPOT_JNI_CALLOBJECTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1419                   HOTSPOT_JNI_CALLOBJECTMETHODV_RETURN(_ret_ref))
1420 DEFINE_CALLMETHODV(jint,     Int,     T_INT,
1421                   HOTSPOT_JNI_CALLINTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1422                   HOTSPOT_JNI_CALLINTMETHODV_RETURN(_ret_ref))
1423 DEFINE_CALLMETHODV(jlong,    Long,    T_LONG
1424                   , HOTSPOT_JNI_CALLLONGMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1425                   HOTSPOT_JNI_CALLLONGMETHODV_RETURN(_ret_ref))
1426 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1427 DEFINE_CALLMETHODV(jfloat,   Float,   T_FLOAT
1428                   , HOTSPOT_JNI_CALLFLOATMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1429                   HOTSPOT_JNI_CALLFLOATMETHODV_RETURN())
1430 DEFINE_CALLMETHODV(jdouble,  Double,  T_DOUBLE
1431                   , HOTSPOT_JNI_CALLDOUBLEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1432                   HOTSPOT_JNI_CALLDOUBLEMETHODV_RETURN())
1433 
1434 #define DEFINE_CALLMETHODA(ResultType, Result, Tag \
1435                           , EntryProbe, ReturnProbe)    \
1436 \
1437   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodA, ResultType \
1438                           , ReturnProbe);                          \
1439 \
1440 JNI_ENTRY(ResultType, \
1441           jni_Call##Result##MethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args)) \
1442   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;MethodA&quot;); \
1443   EntryProbe; \
1444   ResultType ret = 0;\
1445   DT_RETURN_MARK_FOR(Result, Call##Result##MethodA, ResultType, \
1446                      (const ResultType&amp;)ret);\
1447 \
1448   JavaValue jvalue(Tag); \
1449   JNI_ArgumentPusherArray ap(methodID, args); \
1450   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1451   ret = jvalue.get_##ResultType(); \
1452   return ret;\
1453 JNI_END
1454 
1455 // the runtime type of subword integral basic types is integer
1456 DEFINE_CALLMETHODA(jboolean, Boolean, T_BOOLEAN
1457                   , HOTSPOT_JNI_CALLBOOLEANMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1458                   HOTSPOT_JNI_CALLBOOLEANMETHODA_RETURN(_ret_ref))
1459 DEFINE_CALLMETHODA(jbyte,    Byte,    T_BYTE
1460                   , HOTSPOT_JNI_CALLBYTEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1461                   HOTSPOT_JNI_CALLBYTEMETHODA_RETURN(_ret_ref))
1462 DEFINE_CALLMETHODA(jchar,    Char,    T_CHAR
1463                   , HOTSPOT_JNI_CALLCHARMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1464                   HOTSPOT_JNI_CALLCHARMETHODA_RETURN(_ret_ref))
1465 DEFINE_CALLMETHODA(jshort,   Short,   T_SHORT
1466                   , HOTSPOT_JNI_CALLSHORTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1467                   HOTSPOT_JNI_CALLSHORTMETHODA_RETURN(_ret_ref))
1468 
1469 DEFINE_CALLMETHODA(jobject,  Object,  T_OBJECT
1470                   , HOTSPOT_JNI_CALLOBJECTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1471                   HOTSPOT_JNI_CALLOBJECTMETHODA_RETURN(_ret_ref))
1472 DEFINE_CALLMETHODA(jint,     Int,     T_INT,
1473                   HOTSPOT_JNI_CALLINTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1474                   HOTSPOT_JNI_CALLINTMETHODA_RETURN(_ret_ref))
1475 DEFINE_CALLMETHODA(jlong,    Long,    T_LONG
1476                   , HOTSPOT_JNI_CALLLONGMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1477                   HOTSPOT_JNI_CALLLONGMETHODA_RETURN(_ret_ref))
1478 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1479 DEFINE_CALLMETHODA(jfloat,   Float,   T_FLOAT
1480                   , HOTSPOT_JNI_CALLFLOATMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1481                   HOTSPOT_JNI_CALLFLOATMETHODA_RETURN())
1482 DEFINE_CALLMETHODA(jdouble,  Double,  T_DOUBLE
1483                   , HOTSPOT_JNI_CALLDOUBLEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1484                   HOTSPOT_JNI_CALLDOUBLEMETHODA_RETURN())
1485 
1486 DT_VOID_RETURN_MARK_DECL(CallVoidMethod, HOTSPOT_JNI_CALLVOIDMETHOD_RETURN());
1487 DT_VOID_RETURN_MARK_DECL(CallVoidMethodV, HOTSPOT_JNI_CALLVOIDMETHODV_RETURN());
1488 DT_VOID_RETURN_MARK_DECL(CallVoidMethodA, HOTSPOT_JNI_CALLVOIDMETHODA_RETURN());
1489 
1490 
1491 JNI_ENTRY(void, jni_CallVoidMethod(JNIEnv *env, jobject obj, jmethodID methodID, ...))
1492   JNIWrapper(&quot;CallVoidMethod&quot;);
1493   HOTSPOT_JNI_CALLVOIDMETHOD_ENTRY(env, obj, (uintptr_t) methodID);
1494   DT_VOID_RETURN_MARK(CallVoidMethod);
1495 
1496   va_list args;
1497   va_start(args, methodID);
1498   JavaValue jvalue(T_VOID);
1499   JNI_ArgumentPusherVaArg ap(methodID, args);
1500   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1501   va_end(args);
1502 JNI_END
1503 
1504 
1505 JNI_ENTRY(void, jni_CallVoidMethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args))
1506   JNIWrapper(&quot;CallVoidMethodV&quot;);
1507   HOTSPOT_JNI_CALLVOIDMETHODV_ENTRY(env, obj, (uintptr_t) methodID);
1508   DT_VOID_RETURN_MARK(CallVoidMethodV);
1509 
1510   JavaValue jvalue(T_VOID);
1511   JNI_ArgumentPusherVaArg ap(methodID, args);
1512   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1513 JNI_END
1514 
1515 
1516 JNI_ENTRY(void, jni_CallVoidMethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args))
1517   JNIWrapper(&quot;CallVoidMethodA&quot;);
1518   HOTSPOT_JNI_CALLVOIDMETHODA_ENTRY(env, obj, (uintptr_t) methodID);
1519   DT_VOID_RETURN_MARK(CallVoidMethodA);
1520 
1521   JavaValue jvalue(T_VOID);
1522   JNI_ArgumentPusherArray ap(methodID, args);
1523   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1524 JNI_END
1525 
1526 
1527 
1528 #define DEFINE_CALLNONVIRTUALMETHOD(ResultType, Result, Tag \
1529                                     , EntryProbe, ReturnProbe)      \
1530 \
1531   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##Method, ResultType \
1532                           , ReturnProbe);\
1533 \
1534 JNI_ENTRY(ResultType, \
1535           jni_CallNonvirtual##Result##Method(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...)) \
1536   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;Method&quot;); \
1537 \
1538   EntryProbe;\
1539   ResultType ret;\
1540   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##Method, ResultType, \
1541                      (const ResultType&amp;)ret);\
1542 \
1543   va_list args; \
1544   va_start(args, methodID); \
1545   JavaValue jvalue(Tag); \
1546   JNI_ArgumentPusherVaArg ap(methodID, args); \
1547   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1548   va_end(args); \
1549   ret = jvalue.get_##ResultType(); \
1550   return ret;\
1551 JNI_END
1552 
1553 // the runtime type of subword integral basic types is integer
1554 DEFINE_CALLNONVIRTUALMETHOD(jboolean, Boolean, T_BOOLEAN
1555                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1556                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_RETURN(_ret_ref))
1557 DEFINE_CALLNONVIRTUALMETHOD(jbyte,    Byte,    T_BYTE
1558                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1559                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_RETURN(_ret_ref))
1560 DEFINE_CALLNONVIRTUALMETHOD(jchar,    Char,    T_CHAR
1561                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1562                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_RETURN(_ret_ref))
1563 DEFINE_CALLNONVIRTUALMETHOD(jshort,   Short,   T_SHORT
1564                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1565                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_RETURN(_ret_ref))
1566 
1567 DEFINE_CALLNONVIRTUALMETHOD(jobject,  Object,  T_OBJECT
1568                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1569                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_RETURN(_ret_ref))
1570 DEFINE_CALLNONVIRTUALMETHOD(jint,     Int,     T_INT
1571                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1572                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_RETURN(_ret_ref))
1573 DEFINE_CALLNONVIRTUALMETHOD(jlong,    Long,    T_LONG
1574                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1575 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1576                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_RETURN(_ret_ref))
1577 DEFINE_CALLNONVIRTUALMETHOD(jfloat,   Float,   T_FLOAT
1578                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1579                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_RETURN())
1580 DEFINE_CALLNONVIRTUALMETHOD(jdouble,  Double,  T_DOUBLE
1581                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1582                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_RETURN())
1583 
1584 #define DEFINE_CALLNONVIRTUALMETHODV(ResultType, Result, Tag \
1585                                     , EntryProbe, ReturnProbe)      \
1586 \
1587   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodV, ResultType \
1588                           , ReturnProbe);\
1589 \
1590 JNI_ENTRY(ResultType, \
1591           jni_CallNonvirtual##Result##MethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args)) \
1592   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;MethodV&quot;); \
1593 \
1594   EntryProbe;\
1595   ResultType ret;\
1596   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodV, ResultType, \
1597                      (const ResultType&amp;)ret);\
1598 \
1599   JavaValue jvalue(Tag); \
1600   JNI_ArgumentPusherVaArg ap(methodID, args); \
1601   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1602   ret = jvalue.get_##ResultType(); \
1603   return ret;\
1604 JNI_END
1605 
1606 // the runtime type of subword integral basic types is integer
1607 DEFINE_CALLNONVIRTUALMETHODV(jboolean, Boolean, T_BOOLEAN
1608                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1609                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_RETURN(_ret_ref))
1610 DEFINE_CALLNONVIRTUALMETHODV(jbyte,    Byte,    T_BYTE
1611                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1612                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_RETURN(_ret_ref))
1613 DEFINE_CALLNONVIRTUALMETHODV(jchar,    Char,    T_CHAR
1614                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1615                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_RETURN(_ret_ref))
1616 DEFINE_CALLNONVIRTUALMETHODV(jshort,   Short,   T_SHORT
1617                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1618                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_RETURN(_ret_ref))
1619 
1620 DEFINE_CALLNONVIRTUALMETHODV(jobject,  Object,  T_OBJECT
1621                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1622                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_RETURN(_ret_ref))
1623 DEFINE_CALLNONVIRTUALMETHODV(jint,     Int,     T_INT
1624                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1625                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_RETURN(_ret_ref))
1626 DEFINE_CALLNONVIRTUALMETHODV(jlong,    Long,    T_LONG
1627                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1628 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1629                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_RETURN(_ret_ref))
1630 DEFINE_CALLNONVIRTUALMETHODV(jfloat,   Float,   T_FLOAT
1631                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1632                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_RETURN())
1633 DEFINE_CALLNONVIRTUALMETHODV(jdouble,  Double,  T_DOUBLE
1634                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1635                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_RETURN())
1636 
1637 #define DEFINE_CALLNONVIRTUALMETHODA(ResultType, Result, Tag \
1638                                     , EntryProbe, ReturnProbe)      \
1639 \
1640   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodA, ResultType \
1641                           , ReturnProbe);\
1642 \
1643 JNI_ENTRY(ResultType, \
1644           jni_CallNonvirtual##Result##MethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args)) \
1645   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;MethodA&quot;); \
1646 \
1647   EntryProbe;\
1648   ResultType ret;\
1649   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodA, ResultType, \
1650                      (const ResultType&amp;)ret);\
1651 \
1652   JavaValue jvalue(Tag); \
1653   JNI_ArgumentPusherArray ap(methodID, args); \
1654   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1655   ret = jvalue.get_##ResultType(); \
1656   return ret;\
1657 JNI_END
1658 
1659 // the runtime type of subword integral basic types is integer
1660 DEFINE_CALLNONVIRTUALMETHODA(jboolean, Boolean, T_BOOLEAN
1661                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1662                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_RETURN(_ret_ref))
1663 DEFINE_CALLNONVIRTUALMETHODA(jbyte,    Byte,    T_BYTE
1664                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1665                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_RETURN(_ret_ref))
1666 DEFINE_CALLNONVIRTUALMETHODA(jchar,    Char,    T_CHAR
1667                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1668                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_RETURN(_ret_ref))
1669 DEFINE_CALLNONVIRTUALMETHODA(jshort,   Short,   T_SHORT
1670                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1671                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_RETURN(_ret_ref))
1672 
1673 DEFINE_CALLNONVIRTUALMETHODA(jobject,  Object,  T_OBJECT
1674                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1675                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_RETURN(_ret_ref))
1676 DEFINE_CALLNONVIRTUALMETHODA(jint,     Int,     T_INT
1677                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1678                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_RETURN(_ret_ref))
1679 DEFINE_CALLNONVIRTUALMETHODA(jlong,    Long,    T_LONG
1680                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1681 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1682                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_RETURN(_ret_ref))
1683 DEFINE_CALLNONVIRTUALMETHODA(jfloat,   Float,   T_FLOAT
1684                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1685                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_RETURN())
1686 DEFINE_CALLNONVIRTUALMETHODA(jdouble,  Double,  T_DOUBLE
1687                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1688                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_RETURN())
1689 
1690 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethod
1691                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_RETURN());
1692 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodV
1693                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_RETURN());
1694 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodA
1695                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_RETURN());
1696 
1697 JNI_ENTRY(void, jni_CallNonvirtualVoidMethod(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...))
1698   JNIWrapper(&quot;CallNonvirtualVoidMethod&quot;);
1699 
1700   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_ENTRY(env, obj, cls, (uintptr_t) methodID);
1701   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethod);
1702 
1703   va_list args;
1704   va_start(args, methodID);
1705   JavaValue jvalue(T_VOID);
1706   JNI_ArgumentPusherVaArg ap(methodID, args);
1707   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1708   va_end(args);
1709 JNI_END
1710 
1711 
1712 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args))
1713   JNIWrapper(&quot;CallNonvirtualVoidMethodV&quot;);
1714 
1715   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_ENTRY(
1716                env, obj, cls, (uintptr_t) methodID);
1717   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodV);
1718 
1719   JavaValue jvalue(T_VOID);
1720   JNI_ArgumentPusherVaArg ap(methodID, args);
1721   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1722 JNI_END
1723 
1724 
1725 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args))
1726   JNIWrapper(&quot;CallNonvirtualVoidMethodA&quot;);
1727   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_ENTRY(
1728                 env, obj, cls, (uintptr_t) methodID);
1729   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodA);
1730   JavaValue jvalue(T_VOID);
1731   JNI_ArgumentPusherArray ap(methodID, args);
1732   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1733 JNI_END
1734 
1735 
1736 
1737 #define DEFINE_CALLSTATICMETHOD(ResultType, Result, Tag \
1738                                 , EntryProbe, ResultProbe) \
1739 \
1740   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##Method, ResultType \
1741                           , ResultProbe);                               \
1742 \
1743 JNI_ENTRY(ResultType, \
1744           jni_CallStatic##Result##Method(JNIEnv *env, jclass cls, jmethodID methodID, ...)) \
1745   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;Method&quot;); \
1746 \
1747   EntryProbe; \
1748   ResultType ret = 0;\
1749   DT_RETURN_MARK_FOR(Result, CallStatic##Result##Method, ResultType, \
1750                      (const ResultType&amp;)ret);\
1751 \
1752   va_list args; \
1753   va_start(args, methodID); \
1754   JavaValue jvalue(Tag); \
1755   JNI_ArgumentPusherVaArg ap(methodID, args); \
1756   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1757   va_end(args); \
1758   ret = jvalue.get_##ResultType(); \
1759   return ret;\
1760 JNI_END
1761 
1762 // the runtime type of subword integral basic types is integer
1763 DEFINE_CALLSTATICMETHOD(jboolean, Boolean, T_BOOLEAN
1764                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1765                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_RETURN(_ret_ref));
1766 DEFINE_CALLSTATICMETHOD(jbyte,    Byte,    T_BYTE
1767                         , HOTSPOT_JNI_CALLSTATICBYTEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1768                         HOTSPOT_JNI_CALLSTATICBYTEMETHOD_RETURN(_ret_ref));
1769 DEFINE_CALLSTATICMETHOD(jchar,    Char,    T_CHAR
1770                         , HOTSPOT_JNI_CALLSTATICCHARMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1771                         HOTSPOT_JNI_CALLSTATICCHARMETHOD_RETURN(_ret_ref));
1772 DEFINE_CALLSTATICMETHOD(jshort,   Short,   T_SHORT
1773                         , HOTSPOT_JNI_CALLSTATICSHORTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1774                         HOTSPOT_JNI_CALLSTATICSHORTMETHOD_RETURN(_ret_ref));
1775 
1776 DEFINE_CALLSTATICMETHOD(jobject,  Object,  T_OBJECT
1777                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1778                         HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_RETURN(_ret_ref));
1779 DEFINE_CALLSTATICMETHOD(jint,     Int,     T_INT
1780                         , HOTSPOT_JNI_CALLSTATICINTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1781                         HOTSPOT_JNI_CALLSTATICINTMETHOD_RETURN(_ret_ref));
1782 DEFINE_CALLSTATICMETHOD(jlong,    Long,    T_LONG
1783                         , HOTSPOT_JNI_CALLSTATICLONGMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1784                         HOTSPOT_JNI_CALLSTATICLONGMETHOD_RETURN(_ret_ref));
1785 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1786 DEFINE_CALLSTATICMETHOD(jfloat,   Float,   T_FLOAT
1787                         , HOTSPOT_JNI_CALLSTATICFLOATMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1788                         HOTSPOT_JNI_CALLSTATICFLOATMETHOD_RETURN());
1789 DEFINE_CALLSTATICMETHOD(jdouble,  Double,  T_DOUBLE
1790                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1791                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_RETURN());
1792 
1793 #define DEFINE_CALLSTATICMETHODV(ResultType, Result, Tag \
1794                                 , EntryProbe, ResultProbe) \
1795 \
1796   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodV, ResultType \
1797                           , ResultProbe);                               \
1798 \
1799 JNI_ENTRY(ResultType, \
1800           jni_CallStatic##Result##MethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args)) \
1801   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;MethodV&quot;); \
1802 \
1803   EntryProbe; \
1804   ResultType ret = 0;\
1805   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodV, ResultType, \
1806                      (const ResultType&amp;)ret);\
1807 \
1808   JavaValue jvalue(Tag); \
1809   JNI_ArgumentPusherVaArg ap(methodID, args); \
1810   /* Make sure class is initialized before trying to invoke its method */ \
1811   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls)); \
1812   k-&gt;initialize(CHECK_0); \
1813   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1814   va_end(args); \
1815   ret = jvalue.get_##ResultType(); \
1816   return ret;\
1817 JNI_END
1818 
1819 // the runtime type of subword integral basic types is integer
1820 DEFINE_CALLSTATICMETHODV(jboolean, Boolean, T_BOOLEAN
1821                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1822                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_RETURN(_ret_ref));
1823 DEFINE_CALLSTATICMETHODV(jbyte,    Byte,    T_BYTE
1824                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1825                         HOTSPOT_JNI_CALLSTATICBYTEMETHODV_RETURN(_ret_ref));
1826 DEFINE_CALLSTATICMETHODV(jchar,    Char,    T_CHAR
1827                         , HOTSPOT_JNI_CALLSTATICCHARMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1828                         HOTSPOT_JNI_CALLSTATICCHARMETHODV_RETURN(_ret_ref));
1829 DEFINE_CALLSTATICMETHODV(jshort,   Short,   T_SHORT
1830                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1831                         HOTSPOT_JNI_CALLSTATICSHORTMETHODV_RETURN(_ret_ref));
1832 
1833 DEFINE_CALLSTATICMETHODV(jobject,  Object,  T_OBJECT
1834                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1835                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_RETURN(_ret_ref));
1836 DEFINE_CALLSTATICMETHODV(jint,     Int,     T_INT
1837                         , HOTSPOT_JNI_CALLSTATICINTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1838                         HOTSPOT_JNI_CALLSTATICINTMETHODV_RETURN(_ret_ref));
1839 DEFINE_CALLSTATICMETHODV(jlong,    Long,    T_LONG
1840                         , HOTSPOT_JNI_CALLSTATICLONGMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1841                         HOTSPOT_JNI_CALLSTATICLONGMETHODV_RETURN(_ret_ref));
1842 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1843 DEFINE_CALLSTATICMETHODV(jfloat,   Float,   T_FLOAT
1844                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1845                         HOTSPOT_JNI_CALLSTATICFLOATMETHODV_RETURN());
1846 DEFINE_CALLSTATICMETHODV(jdouble,  Double,  T_DOUBLE
1847                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1848                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_RETURN());
1849 
1850 #define DEFINE_CALLSTATICMETHODA(ResultType, Result, Tag \
1851                                 , EntryProbe, ResultProbe) \
1852 \
1853   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodA, ResultType \
1854                           , ResultProbe);                               \
1855 \
1856 JNI_ENTRY(ResultType, \
1857           jni_CallStatic##Result##MethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args)) \
1858   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;MethodA&quot;); \
1859 \
1860   EntryProbe; \
1861   ResultType ret = 0;\
1862   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodA, ResultType, \
1863                      (const ResultType&amp;)ret);\
1864 \
1865   JavaValue jvalue(Tag); \
1866   JNI_ArgumentPusherArray ap(methodID, args); \
1867   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1868   ret = jvalue.get_##ResultType(); \
1869   return ret;\
1870 JNI_END
1871 
1872 // the runtime type of subword integral basic types is integer
1873 DEFINE_CALLSTATICMETHODA(jboolean, Boolean, T_BOOLEAN
1874                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1875                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_RETURN(_ret_ref));
1876 DEFINE_CALLSTATICMETHODA(jbyte,    Byte,    T_BYTE
1877                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1878                         HOTSPOT_JNI_CALLSTATICBYTEMETHODA_RETURN(_ret_ref));
1879 DEFINE_CALLSTATICMETHODA(jchar,    Char,    T_CHAR
1880                         , HOTSPOT_JNI_CALLSTATICCHARMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1881                         HOTSPOT_JNI_CALLSTATICCHARMETHODA_RETURN(_ret_ref));
1882 DEFINE_CALLSTATICMETHODA(jshort,   Short,   T_SHORT
1883                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1884                         HOTSPOT_JNI_CALLSTATICSHORTMETHODA_RETURN(_ret_ref));
1885 
1886 DEFINE_CALLSTATICMETHODA(jobject,  Object,  T_OBJECT
1887                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1888                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_RETURN(_ret_ref));
1889 DEFINE_CALLSTATICMETHODA(jint,     Int,     T_INT
1890                         , HOTSPOT_JNI_CALLSTATICINTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1891                         HOTSPOT_JNI_CALLSTATICINTMETHODA_RETURN(_ret_ref));
1892 DEFINE_CALLSTATICMETHODA(jlong,    Long,    T_LONG
1893                         , HOTSPOT_JNI_CALLSTATICLONGMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1894                         HOTSPOT_JNI_CALLSTATICLONGMETHODA_RETURN(_ret_ref));
1895 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1896 DEFINE_CALLSTATICMETHODA(jfloat,   Float,   T_FLOAT
1897                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1898                         HOTSPOT_JNI_CALLSTATICFLOATMETHODA_RETURN());
1899 DEFINE_CALLSTATICMETHODA(jdouble,  Double,  T_DOUBLE
1900                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1901                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_RETURN());
1902 
1903 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethod
1904                          , HOTSPOT_JNI_CALLSTATICVOIDMETHOD_RETURN());
1905 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodV
1906                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODV_RETURN());
1907 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodA
1908                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODA_RETURN());
1909 
1910 JNI_ENTRY(void, jni_CallStaticVoidMethod(JNIEnv *env, jclass cls, jmethodID methodID, ...))
1911   JNIWrapper(&quot;CallStaticVoidMethod&quot;);
1912   HOTSPOT_JNI_CALLSTATICVOIDMETHOD_ENTRY(env, cls, (uintptr_t) methodID);
1913   DT_VOID_RETURN_MARK(CallStaticVoidMethod);
1914 
1915   va_list args;
1916   va_start(args, methodID);
1917   JavaValue jvalue(T_VOID);
1918   JNI_ArgumentPusherVaArg ap(methodID, args);
1919   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1920   va_end(args);
1921 JNI_END
1922 
1923 
1924 JNI_ENTRY(void, jni_CallStaticVoidMethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args))
1925   JNIWrapper(&quot;CallStaticVoidMethodV&quot;);
1926   HOTSPOT_JNI_CALLSTATICVOIDMETHODV_ENTRY(env, cls, (uintptr_t) methodID);
1927   DT_VOID_RETURN_MARK(CallStaticVoidMethodV);
1928 
1929   JavaValue jvalue(T_VOID);
1930   JNI_ArgumentPusherVaArg ap(methodID, args);
1931   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1932 JNI_END
1933 
1934 
1935 JNI_ENTRY(void, jni_CallStaticVoidMethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args))
1936   JNIWrapper(&quot;CallStaticVoidMethodA&quot;);
1937   HOTSPOT_JNI_CALLSTATICVOIDMETHODA_ENTRY(env, cls, (uintptr_t) methodID);
1938   DT_VOID_RETURN_MARK(CallStaticVoidMethodA);
1939 
1940   JavaValue jvalue(T_VOID);
1941   JNI_ArgumentPusherArray ap(methodID, args);
1942   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1943 JNI_END
1944 
1945 
1946 //
1947 // Accessing Fields
1948 //
1949 
1950 
1951 DT_RETURN_MARK_DECL(GetFieldID, jfieldID
1952                     , HOTSPOT_JNI_GETFIELDID_RETURN((uintptr_t)_ret_ref));
1953 
1954 JNI_ENTRY(jfieldID, jni_GetFieldID(JNIEnv *env, jclass clazz,
1955           const char *name, const char *sig))
1956   JNIWrapper(&quot;GetFieldID&quot;);
1957   HOTSPOT_JNI_GETFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
1958   jfieldID ret = 0;
1959   DT_RETURN_MARK(GetFieldID, jfieldID, (const jfieldID&amp;)ret);
1960 
1961   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1962 
1963   // The class should have been loaded (we have an instance of the class
1964   // passed in) so the field and signature should already be in the symbol
1965   // table.  If they&#39;re not there, the field doesn&#39;t exist.
1966   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
1967   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
1968   if (fieldname == NULL || signame == NULL) {
1969     ResourceMark rm;
1970     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
1971   }
1972 
1973   // Make sure class is initialized before handing id&#39;s out to fields
1974   k-&gt;initialize(CHECK_NULL);
1975 
1976   fieldDescriptor fd;
1977   if (!k-&gt;is_instance_klass() ||
1978       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
1979     ResourceMark rm;
1980     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
1981   }
1982 
1983   // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
1984   // It may also have hash bits for k, if VerifyJNIFields is turned on.
1985   ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset(), fd.is_flattened());
1986   return ret;
1987 JNI_END
1988 
1989 
1990 JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
1991   JNIWrapper(&quot;GetObjectField&quot;);
1992   HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
1993   oop o = JNIHandles::resolve_non_null(obj);
1994   Klass* k = o-&gt;klass();
1995   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
1996   oop res = NULL;
1997   // Keep JVMTI addition small and only check enabled flag here.
1998   // jni_GetField_probe() assumes that is okay to create handles.
1999   if (JvmtiExport::should_post_field_access()) {
2000     o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
2001   }
2002   if (!jfieldIDWorkaround::is_flattened_field(fieldID)) {
2003     res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(o, offset);
2004   } else {
2005     assert(k-&gt;is_instance_klass(), &quot;Only instance can have flattened fields&quot;);
2006     InstanceKlass* ik = InstanceKlass::cast(k);
2007     fieldDescriptor fd;
2008     ik-&gt;find_field_from_offset(offset, false, &amp;fd);  // performance bottleneck
2009     InstanceKlass* holder = fd.field_holder();
2010     ValueKlass* field_vklass = ValueKlass::cast(holder-&gt;get_value_field_klass(fd.index()));
2011     res = field_vklass-&gt;read_flattened_field(o, ik-&gt;field_offset(fd.index()), CHECK_NULL);
2012   }
2013   jobject ret = JNIHandles::make_local(env, res);
2014   HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
2015   return ret;
2016 JNI_END
2017 
2018 
2019 
2020 #define DEFINE_GETFIELD(Return,Fieldname,Result \
2021   , EntryProbe, ReturnProbe) \
2022 \
2023   DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
2024   , ReturnProbe); \
2025 \
2026 JNI_ENTRY_NO_PRESERVE(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \
2027   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;Field&quot;); \
2028 \
2029   EntryProbe; \
2030   Return ret = 0;\
2031   DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&amp;)ret);\
2032 \
2033   oop o = JNIHandles::resolve_non_null(obj); \
2034   Klass* k = o-&gt;klass(); \
2035   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2036   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2037   /* jni_GetField_probe_nh() assumes that is not okay to create handles */ \
2038   /* and creates a ResetNoHandleMark.                                   */ \
2039   if (JvmtiExport::should_post_field_access()) { \
2040     o = JvmtiExport::jni_GetField_probe_nh(thread, obj, o, k, fieldID, false); \
2041   } \
2042   ret = o-&gt;Fieldname##_field(offset); \
2043   return ret; \
2044 JNI_END
2045 
2046 DEFINE_GETFIELD(jboolean, bool,   Boolean
2047                 , HOTSPOT_JNI_GETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2048                 HOTSPOT_JNI_GETBOOLEANFIELD_RETURN(_ret_ref))
2049 DEFINE_GETFIELD(jbyte,    byte,   Byte
2050                 , HOTSPOT_JNI_GETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2051                 HOTSPOT_JNI_GETBYTEFIELD_RETURN(_ret_ref))
2052 DEFINE_GETFIELD(jchar,    char,   Char
2053                 , HOTSPOT_JNI_GETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2054                 HOTSPOT_JNI_GETCHARFIELD_RETURN(_ret_ref))
2055 DEFINE_GETFIELD(jshort,   short,  Short
2056                 , HOTSPOT_JNI_GETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2057                 HOTSPOT_JNI_GETSHORTFIELD_RETURN(_ret_ref))
2058 DEFINE_GETFIELD(jint,     int,    Int
2059                 , HOTSPOT_JNI_GETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2060                 HOTSPOT_JNI_GETINTFIELD_RETURN(_ret_ref))
2061 DEFINE_GETFIELD(jlong,    long,   Long
2062                 , HOTSPOT_JNI_GETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2063                 HOTSPOT_JNI_GETLONGFIELD_RETURN(_ret_ref))
2064 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2065 DEFINE_GETFIELD(jfloat,   float,  Float
2066                 , HOTSPOT_JNI_GETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2067                 HOTSPOT_JNI_GETFLOATFIELD_RETURN())
2068 DEFINE_GETFIELD(jdouble,  double, Double
2069                 , HOTSPOT_JNI_GETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2070                 HOTSPOT_JNI_GETDOUBLEFIELD_RETURN())
2071 
2072 address jni_GetBooleanField_addr() {
2073   return (address)jni_GetBooleanField;
2074 }
2075 address jni_GetByteField_addr() {
2076   return (address)jni_GetByteField;
2077 }
2078 address jni_GetCharField_addr() {
2079   return (address)jni_GetCharField;
2080 }
2081 address jni_GetShortField_addr() {
2082   return (address)jni_GetShortField;
2083 }
2084 address jni_GetIntField_addr() {
2085   return (address)jni_GetIntField;
2086 }
2087 address jni_GetLongField_addr() {
2088   return (address)jni_GetLongField;
2089 }
2090 address jni_GetFloatField_addr() {
2091   return (address)jni_GetFloatField;
2092 }
2093 address jni_GetDoubleField_addr() {
2094   return (address)jni_GetDoubleField;
2095 }
2096 
2097 JNI_ENTRY_NO_PRESERVE(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))
2098   JNIWrapper(&quot;SetObjectField&quot;);
2099   HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID, value);
2100   oop o = JNIHandles::resolve_non_null(obj);
2101   Klass* k = o-&gt;klass();
2102   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2103   // Keep JVMTI addition small and only check enabled flag here.
2104   // jni_SetField_probe_nh() assumes that is not okay to create handles
2105   // and creates a ResetNoHandleMark.
2106   if (JvmtiExport::should_post_field_modification()) {
2107     jvalue field_value;
2108     field_value.l = value;
2109     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
2110   }
2111   if (!jfieldIDWorkaround::is_flattened_field(fieldID)) {
2112     HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(o, offset, JNIHandles::resolve(value));
2113   } else {
2114     assert(k-&gt;is_instance_klass(), &quot;Only instances can have flattened fields&quot;);
2115     InstanceKlass* ik = InstanceKlass::cast(k);
2116     fieldDescriptor fd;
2117     ik-&gt;find_field_from_offset(offset, false, &amp;fd);
2118     InstanceKlass* holder = fd.field_holder();
2119     ValueKlass* vklass = ValueKlass::cast(holder-&gt;get_value_field_klass(fd.index()));
2120     oop v = JNIHandles::resolve_non_null(value);
2121     vklass-&gt;write_flattened_field(o, offset, v, CHECK);
2122   }
2123   HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
2124 JNI_END
2125 
2126 
2127 #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
2128                         , EntryProbe, ReturnProbe) \
2129 \
2130 JNI_ENTRY_NO_PRESERVE(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \
2131   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;Field&quot;); \
2132 \
2133   EntryProbe; \
2134 \
2135   oop o = JNIHandles::resolve_non_null(obj); \
2136   Klass* k = o-&gt;klass(); \
2137   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2138   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2139   /* jni_SetField_probe_nh() assumes that is not okay to create handles */ \
2140   /* and creates a ResetNoHandleMark.                                   */ \
2141   if (JvmtiExport::should_post_field_modification()) { \
2142     jvalue field_value; \
2143     field_value.unionType = value; \
2144     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&amp;field_value); \
2145   } \
2146   if (SigType == JVM_SIGNATURE_BOOLEAN) { value = ((jboolean)value) &amp; 1; } \
2147   o-&gt;Fieldname##_field_put(offset, value); \
2148   ReturnProbe; \
2149 JNI_END
2150 
2151 DEFINE_SETFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z
2152                 , HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2153                 HOTSPOT_JNI_SETBOOLEANFIELD_RETURN())
2154 DEFINE_SETFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b
2155                 , HOTSPOT_JNI_SETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2156                 HOTSPOT_JNI_SETBYTEFIELD_RETURN())
2157 DEFINE_SETFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c
2158                 , HOTSPOT_JNI_SETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2159                 HOTSPOT_JNI_SETCHARFIELD_RETURN())
2160 DEFINE_SETFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s
2161                 , HOTSPOT_JNI_SETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2162                 HOTSPOT_JNI_SETSHORTFIELD_RETURN())
2163 DEFINE_SETFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i
2164                 , HOTSPOT_JNI_SETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2165                 HOTSPOT_JNI_SETINTFIELD_RETURN())
2166 DEFINE_SETFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j
2167                 , HOTSPOT_JNI_SETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2168                 HOTSPOT_JNI_SETLONGFIELD_RETURN())
2169 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2170 DEFINE_SETFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f
2171                 , HOTSPOT_JNI_SETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2172                 HOTSPOT_JNI_SETFLOATFIELD_RETURN())
2173 DEFINE_SETFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d
2174                 , HOTSPOT_JNI_SETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2175                 HOTSPOT_JNI_SETDOUBLEFIELD_RETURN())
2176 
2177 DT_RETURN_MARK_DECL(ToReflectedField, jobject
2178                     , HOTSPOT_JNI_TOREFLECTEDFIELD_RETURN(_ret_ref));
2179 
2180 JNI_ENTRY(jobject, jni_ToReflectedField(JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic))
2181   JNIWrapper(&quot;ToReflectedField&quot;);
2182   HOTSPOT_JNI_TOREFLECTEDFIELD_ENTRY(env, cls, (uintptr_t) fieldID, isStatic);
2183   jobject ret = NULL;
2184   DT_RETURN_MARK(ToReflectedField, jobject, (const jobject&amp;)ret);
2185 
2186   fieldDescriptor fd;
2187   bool found = false;
2188   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2189 
2190   assert(jfieldIDWorkaround::is_static_jfieldID(fieldID) == (isStatic != 0), &quot;invalid fieldID&quot;);
2191 
2192   if (isStatic) {
2193     // Static field. The fieldID a JNIid specifying the field holder and the offset within the Klass*.
2194     JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2195     assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2196     found = id-&gt;find_local_field(&amp;fd);
2197   } else {
2198     // Non-static field. The fieldID is really the offset of the field within the instanceOop.
2199     int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2200     found = InstanceKlass::cast(k)-&gt;find_field_from_offset(offset, false, &amp;fd);
2201   }
2202   assert(found, &quot;bad fieldID passed into jni_ToReflectedField&quot;);
2203   oop reflected = Reflection::new_field(&amp;fd, CHECK_NULL);
2204   ret = JNIHandles::make_local(env, reflected);
2205   return ret;
2206 JNI_END
2207 
2208 
2209 //
2210 // Accessing Static Fields
2211 //
2212 DT_RETURN_MARK_DECL(GetStaticFieldID, jfieldID
2213                     , HOTSPOT_JNI_GETSTATICFIELDID_RETURN((uintptr_t)_ret_ref));
2214 
2215 JNI_ENTRY(jfieldID, jni_GetStaticFieldID(JNIEnv *env, jclass clazz,
2216           const char *name, const char *sig))
2217   JNIWrapper(&quot;GetStaticFieldID&quot;);
2218   HOTSPOT_JNI_GETSTATICFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
2219   jfieldID ret = NULL;
2220   DT_RETURN_MARK(GetStaticFieldID, jfieldID, (const jfieldID&amp;)ret);
2221 
2222   // The class should have been loaded (we have an instance of the class
2223   // passed in) so the field and signature should already be in the symbol
2224   // table.  If they&#39;re not there, the field doesn&#39;t exist.
2225   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
2226   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
2227   if (fieldname == NULL || signame == NULL) {
2228     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2229   }
2230   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2231   // Make sure class is initialized before handing id&#39;s out to static fields
2232   k-&gt;initialize(CHECK_NULL);
2233 
2234   fieldDescriptor fd;
2235   if (!k-&gt;is_instance_klass() ||
2236       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, true, &amp;fd)) {
2237     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2238   }
2239 
2240   // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
2241   JNIid* id = fd.field_holder()-&gt;jni_id_for(fd.offset());
2242   debug_only(id-&gt;set_is_static_field_id();)
2243 
2244   debug_only(id-&gt;verify(fd.field_holder()));
2245 
2246   ret = jfieldIDWorkaround::to_static_jfieldID(id);
2247   return ret;
2248 JNI_END
2249 
2250 
2251 JNI_ENTRY(jobject, jni_GetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID))
2252   JNIWrapper(&quot;GetStaticObjectField&quot;);
2253   HOTSPOT_JNI_GETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID);
2254 #if INCLUDE_JNI_CHECK
2255   DEBUG_ONLY(Klass* param_k = jniCheck::validate_class(thread, clazz);)
2256 #endif // INCLUDE_JNI_CHECK
2257   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2258   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2259   // Keep JVMTI addition small and only check enabled flag here.
2260   // jni_GetField_probe() assumes that is okay to create handles.
2261   if (JvmtiExport::should_post_field_access()) {
2262     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true);
2263   }
2264   jobject ret = JNIHandles::make_local(id-&gt;holder()-&gt;java_mirror()-&gt;obj_field(id-&gt;offset()));
2265   HOTSPOT_JNI_GETSTATICOBJECTFIELD_RETURN(ret);
2266   return ret;
2267 JNI_END
2268 
2269 
2270 #define DEFINE_GETSTATICFIELD(Return,Fieldname,Result \
2271                               , EntryProbe, ReturnProbe) \
2272 \
2273   DT_RETURN_MARK_DECL_FOR(Result, GetStatic##Result##Field, Return \
2274                           , ReturnProbe);                                          \
2275 \
2276 JNI_ENTRY(Return, jni_GetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID)) \
2277   JNIWrapper(&quot;GetStatic&quot; XSTR(Result) &quot;Field&quot;); \
2278   EntryProbe; \
2279   Return ret = 0;\
2280   DT_RETURN_MARK_FOR(Result, GetStatic##Result##Field, Return, \
2281                      (const Return&amp;)ret);\
2282   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2283   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;); \
2284   /* Keep JVMTI addition small and only check enabled flag here. */ \
2285   /* jni_GetField_probe() assumes that is okay to create handles. */ \
2286   if (JvmtiExport::should_post_field_access()) { \
2287     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true); \
2288   } \
2289   ret = id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field (id-&gt;offset()); \
2290   return ret;\
2291 JNI_END
2292 
2293 DEFINE_GETSTATICFIELD(jboolean, bool,   Boolean
2294                       , HOTSPOT_JNI_GETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t) fieldID), HOTSPOT_JNI_GETSTATICBOOLEANFIELD_RETURN(_ret_ref))
2295 DEFINE_GETSTATICFIELD(jbyte,    byte,   Byte
2296                       , HOTSPOT_JNI_GETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICBYTEFIELD_RETURN(_ret_ref)   )
2297 DEFINE_GETSTATICFIELD(jchar,    char,   Char
2298                       , HOTSPOT_JNI_GETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICCHARFIELD_RETURN(_ret_ref)   )
2299 DEFINE_GETSTATICFIELD(jshort,   short,  Short
2300                       , HOTSPOT_JNI_GETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICSHORTFIELD_RETURN(_ret_ref)  )
2301 DEFINE_GETSTATICFIELD(jint,     int,    Int
2302                       , HOTSPOT_JNI_GETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),     HOTSPOT_JNI_GETSTATICINTFIELD_RETURN(_ret_ref)    )
2303 DEFINE_GETSTATICFIELD(jlong,    long,   Long
2304                       , HOTSPOT_JNI_GETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICLONGFIELD_RETURN(_ret_ref)   )
2305 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2306 DEFINE_GETSTATICFIELD(jfloat,   float,  Float
2307                       , HOTSPOT_JNI_GETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICFLOATFIELD_RETURN()          )
2308 DEFINE_GETSTATICFIELD(jdouble,  double, Double
2309                       , HOTSPOT_JNI_GETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),  HOTSPOT_JNI_GETSTATICDOUBLEFIELD_RETURN()         )
2310 
2311 JNI_ENTRY(void, jni_SetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value))
2312   JNIWrapper(&quot;SetStaticObjectField&quot;);
2313  HOTSPOT_JNI_SETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value);
2314   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2315   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2316   // Keep JVMTI addition small and only check enabled flag here.
2317   // jni_SetField_probe() assumes that is okay to create handles.
2318   if (JvmtiExport::should_post_field_modification()) {
2319     jvalue field_value;
2320     field_value.l = value;
2321     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
2322   }
2323   id-&gt;holder()-&gt;java_mirror()-&gt;obj_field_put(id-&gt;offset(), JNIHandles::resolve(value));
2324   HOTSPOT_JNI_SETSTATICOBJECTFIELD_RETURN();
2325 JNI_END
2326 
2327 
2328 
2329 #define DEFINE_SETSTATICFIELD(Argument,Fieldname,Result,SigType,unionType \
2330                               , EntryProbe, ReturnProbe) \
2331 \
2332 JNI_ENTRY(void, jni_SetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID, Argument value)) \
2333   JNIWrapper(&quot;SetStatic&quot; XSTR(Result) &quot;Field&quot;); \
2334   EntryProbe; \
2335 \
2336   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2337   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;); \
2338   /* Keep JVMTI addition small and only check enabled flag here. */ \
2339   /* jni_SetField_probe() assumes that is okay to create handles. */ \
2340   if (JvmtiExport::should_post_field_modification()) { \
2341     jvalue field_value; \
2342     field_value.unionType = value; \
2343     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, SigType, (jvalue *)&amp;field_value); \
2344   } \
2345   if (SigType == JVM_SIGNATURE_BOOLEAN) { value = ((jboolean)value) &amp; 1; } \
2346   id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field_put (id-&gt;offset(), value); \
2347   ReturnProbe;\
2348 JNI_END
2349 
2350 DEFINE_SETSTATICFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z
2351                       , HOTSPOT_JNI_SETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
2352                       HOTSPOT_JNI_SETSTATICBOOLEANFIELD_RETURN())
2353 DEFINE_SETSTATICFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b
2354                       , HOTSPOT_JNI_SETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2355                       HOTSPOT_JNI_SETSTATICBYTEFIELD_RETURN())
2356 DEFINE_SETSTATICFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c
2357                       , HOTSPOT_JNI_SETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2358                       HOTSPOT_JNI_SETSTATICCHARFIELD_RETURN())
2359 DEFINE_SETSTATICFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s
2360                       , HOTSPOT_JNI_SETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2361                       HOTSPOT_JNI_SETSTATICSHORTFIELD_RETURN())
2362 DEFINE_SETSTATICFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i
2363                       , HOTSPOT_JNI_SETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2364                       HOTSPOT_JNI_SETSTATICINTFIELD_RETURN())
2365 DEFINE_SETSTATICFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j
2366                       , HOTSPOT_JNI_SETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2367                       HOTSPOT_JNI_SETSTATICLONGFIELD_RETURN())
2368 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2369 DEFINE_SETSTATICFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f
2370                       , HOTSPOT_JNI_SETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2371                       HOTSPOT_JNI_SETSTATICFLOATFIELD_RETURN())
2372 DEFINE_SETSTATICFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d
2373                       , HOTSPOT_JNI_SETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2374                       HOTSPOT_JNI_SETSTATICDOUBLEFIELD_RETURN())
2375 
2376 //
2377 // String Operations
2378 //
2379 
2380 // Unicode Interface
2381 
2382 DT_RETURN_MARK_DECL(NewString, jstring
2383                     , HOTSPOT_JNI_NEWSTRING_RETURN(_ret_ref));
2384 
2385 JNI_ENTRY(jstring, jni_NewString(JNIEnv *env, const jchar *unicodeChars, jsize len))
2386   JNIWrapper(&quot;NewString&quot;);
2387  HOTSPOT_JNI_NEWSTRING_ENTRY(env, (uint16_t *) unicodeChars, len);
2388   jstring ret = NULL;
2389   DT_RETURN_MARK(NewString, jstring, (const jstring&amp;)ret);
2390   oop string=java_lang_String::create_oop_from_unicode((jchar*) unicodeChars, len, CHECK_NULL);
2391   ret = (jstring) JNIHandles::make_local(env, string);
2392   return ret;
2393 JNI_END
2394 
2395 
2396 JNI_ENTRY_NO_PRESERVE(jsize, jni_GetStringLength(JNIEnv *env, jstring string))
2397   JNIWrapper(&quot;GetStringLength&quot;);
2398   HOTSPOT_JNI_GETSTRINGLENGTH_ENTRY(env, string);
2399   jsize ret = 0;
2400   oop s = JNIHandles::resolve_non_null(string);
2401   ret = java_lang_String::length(s);
2402  HOTSPOT_JNI_GETSTRINGLENGTH_RETURN(ret);
2403   return ret;
2404 JNI_END
2405 
2406 
2407 JNI_ENTRY_NO_PRESERVE(const jchar*, jni_GetStringChars(
2408   JNIEnv *env, jstring string, jboolean *isCopy))
2409   JNIWrapper(&quot;GetStringChars&quot;);
2410  HOTSPOT_JNI_GETSTRINGCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2411   jchar* buf = NULL;
2412   oop s = JNIHandles::resolve_non_null(string);
2413   typeArrayOop s_value = java_lang_String::value(s);
2414   if (s_value != NULL) {
2415     int s_len = java_lang_String::length(s, s_value);
2416     bool is_latin1 = java_lang_String::is_latin1(s);
2417     buf = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
2418     /* JNI Specification states return NULL on OOM */
2419     if (buf != NULL) {
2420       if (s_len &gt; 0) {
2421         if (!is_latin1) {
2422           ArrayAccess&lt;&gt;::arraycopy_to_native(s_value, (size_t) typeArrayOopDesc::element_offset&lt;jchar&gt;(0),
2423                                              buf, s_len);
2424         } else {
2425           for (int i = 0; i &lt; s_len; i++) {
2426             buf[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
2427           }
2428         }
2429       }
2430       buf[s_len] = 0;
2431       //%note jni_5
2432       if (isCopy != NULL) {
2433         *isCopy = JNI_TRUE;
2434       }
2435     }
2436   }
2437   HOTSPOT_JNI_GETSTRINGCHARS_RETURN(buf);
2438   return buf;
2439 JNI_END
2440 
2441 
2442 JNI_ENTRY_NO_PRESERVE(void, jni_ReleaseStringChars(JNIEnv *env, jstring str, const jchar *chars))
2443   JNIWrapper(&quot;ReleaseStringChars&quot;);
2444   HOTSPOT_JNI_RELEASESTRINGCHARS_ENTRY(env, str, (uint16_t *) chars);
2445   //%note jni_6
2446   if (chars != NULL) {
2447     // Since String objects are supposed to be immutable, don&#39;t copy any
2448     // new data back.  A bad user will have to go after the char array.
2449     FreeHeap((void*) chars);
2450   }
2451   HOTSPOT_JNI_RELEASESTRINGCHARS_RETURN();
2452 JNI_END
2453 
2454 
2455 // UTF Interface
2456 
2457 DT_RETURN_MARK_DECL(NewStringUTF, jstring
2458                     , HOTSPOT_JNI_NEWSTRINGUTF_RETURN(_ret_ref));
2459 
2460 JNI_ENTRY(jstring, jni_NewStringUTF(JNIEnv *env, const char *bytes))
2461   JNIWrapper(&quot;NewStringUTF&quot;);
2462   HOTSPOT_JNI_NEWSTRINGUTF_ENTRY(env, (char *) bytes);
2463   jstring ret;
2464   DT_RETURN_MARK(NewStringUTF, jstring, (const jstring&amp;)ret);
2465 
2466   oop result = java_lang_String::create_oop_from_str((char*) bytes, CHECK_NULL);
2467   ret = (jstring) JNIHandles::make_local(env, result);
2468   return ret;
2469 JNI_END
2470 
2471 
2472 JNI_ENTRY(jsize, jni_GetStringUTFLength(JNIEnv *env, jstring string))
2473   JNIWrapper(&quot;GetStringUTFLength&quot;);
2474  HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(env, string);
2475   oop java_string = JNIHandles::resolve_non_null(string);
2476   jsize ret = java_lang_String::utf8_length(java_string);
2477   HOTSPOT_JNI_GETSTRINGUTFLENGTH_RETURN(ret);
2478   return ret;
2479 JNI_END
2480 
2481 
2482 JNI_ENTRY(const char*, jni_GetStringUTFChars(JNIEnv *env, jstring string, jboolean *isCopy))
2483   JNIWrapper(&quot;GetStringUTFChars&quot;);
2484  HOTSPOT_JNI_GETSTRINGUTFCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2485   char* result = NULL;
2486   oop java_string = JNIHandles::resolve_non_null(string);
2487   typeArrayOop s_value = java_lang_String::value(java_string);
2488   if (s_value != NULL) {
2489     size_t length = java_lang_String::utf8_length(java_string, s_value);
2490     /* JNI Specification states return NULL on OOM */
2491     result = AllocateHeap(length + 1, mtInternal, 0, AllocFailStrategy::RETURN_NULL);
2492     if (result != NULL) {
2493       java_lang_String::as_utf8_string(java_string, s_value, result, (int) length + 1);
2494       if (isCopy != NULL) {
2495         *isCopy = JNI_TRUE;
2496       }
2497     }
2498   }
2499  HOTSPOT_JNI_GETSTRINGUTFCHARS_RETURN(result);
2500   return result;
2501 JNI_END
2502 
2503 
2504 JNI_LEAF(void, jni_ReleaseStringUTFChars(JNIEnv *env, jstring str, const char *chars))
2505   JNIWrapper(&quot;ReleaseStringUTFChars&quot;);
2506  HOTSPOT_JNI_RELEASESTRINGUTFCHARS_ENTRY(env, str, (char *) chars);
2507   if (chars != NULL) {
2508     FreeHeap((char*) chars);
2509   }
2510 HOTSPOT_JNI_RELEASESTRINGUTFCHARS_RETURN();
2511 JNI_END
2512 
2513 
2514 JNI_ENTRY_NO_PRESERVE(jsize, jni_GetArrayLength(JNIEnv *env, jarray array))
2515   JNIWrapper(&quot;GetArrayLength&quot;);
2516  HOTSPOT_JNI_GETARRAYLENGTH_ENTRY(env, array);
2517   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
2518   assert(a-&gt;is_array(), &quot;must be array&quot;);
2519   jsize ret = a-&gt;length();
2520  HOTSPOT_JNI_GETARRAYLENGTH_RETURN(ret);
2521   return ret;
2522 JNI_END
2523 
2524 
2525 //
2526 // Object Array Operations
2527 //
2528 
2529 DT_RETURN_MARK_DECL(NewObjectArray, jobjectArray
2530                     , HOTSPOT_JNI_NEWOBJECTARRAY_RETURN(_ret_ref));
2531 
2532 JNI_ENTRY(jobjectArray, jni_NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement))
2533   JNIWrapper(&quot;NewObjectArray&quot;);
2534  HOTSPOT_JNI_NEWOBJECTARRAY_ENTRY(env, length, elementClass, initialElement);
2535   jobjectArray ret = NULL;
2536   DT_RETURN_MARK(NewObjectArray, jobjectArray, (const jobjectArray&amp;)ret);
2537   Klass* ek = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(elementClass));
2538   Klass* ak = ek-&gt;array_klass(CHECK_NULL);
2539   ObjArrayKlass::cast(ak)-&gt;initialize(CHECK_NULL);
2540   objArrayOop result = ObjArrayKlass::cast(ak)-&gt;allocate(length, CHECK_NULL);
2541   oop initial_value = JNIHandles::resolve(initialElement);
2542   if (initial_value != NULL) {  // array already initialized with NULL
2543     for (int index = 0; index &lt; length; index++) {
2544       result-&gt;obj_at_put(index, initial_value);
2545     }
2546   }
2547   ret = (jobjectArray) JNIHandles::make_local(env, result);
2548   return ret;
2549 JNI_END
2550 
2551 DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject
2552                     , HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(_ret_ref));
2553 
2554 JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
2555   JNIWrapper(&quot;GetObjectArrayElement&quot;);
2556  HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
2557   jobject ret = NULL;
2558   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&amp;)ret);
2559   oop res = NULL;
2560   arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));
2561   if (arr-&gt;is_within_bounds(index)) {
2562     if (arr-&gt;is_valueArray()) {
2563       valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));
2564       arrayHandle ah(THREAD, a);
2565       valueArrayHandle vah(thread, a);
2566       res = valueArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK_NULL);
2567       assert(res != NULL, &quot;Must be set in one of two paths above&quot;);
2568     } else {
2569       assert(arr-&gt;is_objArray(), &quot;If not a valueArray. must be an objArray&quot;);
2570       objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2571       res = a-&gt;obj_at(index);
2572     }
2573   } else {
2574     ResourceMark rm(THREAD);
2575     stringStream ss;
2576     ss.print(&quot;Index %d out of bounds for length %d&quot;, index,arr-&gt;length());
2577     THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2578   }
2579   ret = JNIHandles::make_local(env, res);
2580   return ret;
2581 JNI_END
2582 
2583 DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
2584                          , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
2585 
2586 JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
2587   JNIWrapper(&quot;SetObjectArrayElement&quot;);
2588   HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);
2589   DT_VOID_RETURN_MARK(SetObjectArrayElement);
2590 
2591    bool oob = false;
2592    int length = -1;
2593    oop res = NULL;
2594    arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));
2595    if (arr-&gt;is_within_bounds(index)) {
2596      if (arr-&gt;is_valueArray()) {
2597        valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));
2598        oop v = JNIHandles::resolve(value);
2599        ValueArrayKlass* vaklass = ValueArrayKlass::cast(a-&gt;klass());
2600        ValueKlass* element_vklass = vaklass-&gt;element_klass();
2601        if (v != NULL &amp;&amp; v-&gt;is_a(element_vklass)) {
2602          a-&gt;value_copy_to_index(v, index);
2603        } else {
2604          ResourceMark rm(THREAD);
2605          stringStream ss;
2606          Klass *kl = ValueArrayKlass::cast(a-&gt;klass());
2607          ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,
2608              v-&gt;klass()-&gt;external_name(),
2609              kl-&gt;external_name(),
2610              index);
2611          for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {
2612            ss.print(&quot;[]&quot;);
2613          }
2614          THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
2615        }
2616      } else {
2617        assert(arr-&gt;is_objArray(), &quot;If not a valueArray. must be an objArray&quot;);
2618        objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2619        oop v = JNIHandles::resolve(value);
2620        if (v == NULL || v-&gt;is_a(ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass())) {
2621          a-&gt;obj_at_put(index, v);
2622        } else {
2623          ResourceMark rm(THREAD);
2624          stringStream ss;
2625          Klass *bottom_kl = ObjArrayKlass::cast(a-&gt;klass())-&gt;bottom_klass();
2626          ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,
2627              v-&gt;klass()-&gt;external_name(),
2628              bottom_kl-&gt;is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)-&gt;element_type()] : bottom_kl-&gt;external_name(),
2629                  index);
2630          for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {
2631            ss.print(&quot;[]&quot;);
2632          }
2633          THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
2634        }
2635      }
2636    } else {
2637      ResourceMark rm(THREAD);
2638      stringStream ss;
2639      ss.print(&quot;Index %d out of bounds for length %d&quot;, index, arr-&gt;length());
2640      THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2641    }
2642 JNI_END
2643 
2644 
2645 
2646 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
2647                               ,EntryProbe,ReturnProbe)  \
2648 \
2649   DT_RETURN_MARK_DECL(New##Result##Array, Return \
2650                       , ReturnProbe); \
2651 \
2652 JNI_ENTRY(Return, \
2653           jni_New##Result##Array(JNIEnv *env, jsize len)) \
2654   JNIWrapper(&quot;New&quot; XSTR(Result) &quot;Array&quot;); \
2655   EntryProbe; \
2656   Return ret = NULL;\
2657   DT_RETURN_MARK(New##Result##Array, Return, (const Return&amp;)ret);\
2658 \
2659   oop obj= oopFactory::Allocator(len, CHECK_0); \
2660   ret = (Return) JNIHandles::make_local(env, obj); \
2661   return ret;\
2662 JNI_END
2663 
2664 DEFINE_NEWSCALARARRAY(jbooleanArray, new_boolArray,   Boolean,
2665                       HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY(env, len),
2666                       HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN(_ret_ref))
2667 DEFINE_NEWSCALARARRAY(jbyteArray,    new_byteArray,   Byte,
2668                       HOTSPOT_JNI_NEWBYTEARRAY_ENTRY(env, len),
2669                       HOTSPOT_JNI_NEWBYTEARRAY_RETURN(_ret_ref))
2670 DEFINE_NEWSCALARARRAY(jshortArray,   new_shortArray,  Short,
2671                       HOTSPOT_JNI_NEWSHORTARRAY_ENTRY(env, len),
2672                       HOTSPOT_JNI_NEWSHORTARRAY_RETURN(_ret_ref))
2673 DEFINE_NEWSCALARARRAY(jcharArray,    new_charArray,   Char,
2674                       HOTSPOT_JNI_NEWCHARARRAY_ENTRY(env, len),
2675                       HOTSPOT_JNI_NEWCHARARRAY_RETURN(_ret_ref))
2676 DEFINE_NEWSCALARARRAY(jintArray,     new_intArray,    Int,
2677                       HOTSPOT_JNI_NEWINTARRAY_ENTRY(env, len),
2678                       HOTSPOT_JNI_NEWINTARRAY_RETURN(_ret_ref))
2679 DEFINE_NEWSCALARARRAY(jlongArray,    new_longArray,   Long,
2680                       HOTSPOT_JNI_NEWLONGARRAY_ENTRY(env, len),
2681                       HOTSPOT_JNI_NEWLONGARRAY_RETURN(_ret_ref))
2682 DEFINE_NEWSCALARARRAY(jfloatArray,   new_floatArray,  Float,
2683                       HOTSPOT_JNI_NEWFLOATARRAY_ENTRY(env, len),
2684                       HOTSPOT_JNI_NEWFLOATARRAY_RETURN(_ret_ref))
2685 DEFINE_NEWSCALARARRAY(jdoubleArray,  new_doubleArray, Double,
2686                       HOTSPOT_JNI_NEWDOUBLEARRAY_ENTRY(env, len),
2687                       HOTSPOT_JNI_NEWDOUBLEARRAY_RETURN(_ret_ref))
2688 
2689 // Return an address which will fault if the caller writes to it.
2690 
2691 static char* get_bad_address() {
2692   static char* bad_address = NULL;
2693   if (bad_address == NULL) {
2694     size_t size = os::vm_allocation_granularity();
2695     bad_address = os::reserve_memory(size);
2696     if (bad_address != NULL) {
2697       os::protect_memory(bad_address, size, os::MEM_PROT_READ,
2698                          /*is_committed*/false);
2699       MemTracker::record_virtual_memory_type((void*)bad_address, mtInternal);
2700     }
2701   }
2702   return bad_address;
2703 }
2704 
2705 
2706 
2707 #define DEFINE_GETSCALARARRAYELEMENTS(ElementTag,ElementType,Result, Tag \
2708                                       , EntryProbe, ReturnProbe) \
2709 \
2710 JNI_ENTRY_NO_PRESERVE(ElementType*, \
2711           jni_Get##Result##ArrayElements(JNIEnv *env, ElementType##Array array, jboolean *isCopy)) \
2712   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2713   EntryProbe; \
2714   /* allocate an chunk of memory in c land */ \
2715   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2716   ElementType* result; \
2717   int len = a-&gt;length(); \
2718   if (len == 0) { \
2719     if (isCopy != NULL) { \
2720       *isCopy = JNI_FALSE; \
2721     } \
2722     /* Empty array: legal but useless, can&#39;t return NULL. \
2723      * Return a pointer to something useless. \
2724      * Avoid asserts in typeArrayOop. */ \
2725     result = (ElementType*)get_bad_address(); \
2726   } else { \
2727     /* JNI Specification states return NULL on OOM */                    \
2728     result = NEW_C_HEAP_ARRAY_RETURN_NULL(ElementType, len, mtInternal); \
2729     if (result != NULL) {                                                \
2730       /* copy the array to the c chunk */                                \
2731       ArrayAccess&lt;&gt;::arraycopy_to_native(a, typeArrayOopDesc::element_offset&lt;ElementType&gt;(0), \
2732                                          result, len);                   \
2733       if (isCopy) {                                                      \
2734         *isCopy = JNI_TRUE;                                              \
2735       }                                                                  \
2736     }                                                                    \
2737   } \
2738   ReturnProbe; \
2739   return result; \
2740 JNI_END
2741 
2742 DEFINE_GETSCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2743                               , HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2744                               HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_RETURN((uintptr_t*)result))
2745 DEFINE_GETSCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2746                               , HOTSPOT_JNI_GETBYTEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2747                               HOTSPOT_JNI_GETBYTEARRAYELEMENTS_RETURN((char*)result))
2748 DEFINE_GETSCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2749                               , HOTSPOT_JNI_GETSHORTARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2750                               HOTSPOT_JNI_GETSHORTARRAYELEMENTS_RETURN((uint16_t*)result))
2751 DEFINE_GETSCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2752                               , HOTSPOT_JNI_GETCHARARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2753                               HOTSPOT_JNI_GETCHARARRAYELEMENTS_RETURN(result))
2754 DEFINE_GETSCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2755                               , HOTSPOT_JNI_GETINTARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2756                               HOTSPOT_JNI_GETINTARRAYELEMENTS_RETURN((uint32_t*)result))
2757 DEFINE_GETSCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2758                               , HOTSPOT_JNI_GETLONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2759                               HOTSPOT_JNI_GETLONGARRAYELEMENTS_RETURN(((uintptr_t*)result)))
2760 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2761 DEFINE_GETSCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2762                               , HOTSPOT_JNI_GETFLOATARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2763                               HOTSPOT_JNI_GETFLOATARRAYELEMENTS_RETURN(result))
2764 DEFINE_GETSCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2765                               , HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2766                               HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_RETURN(result))
2767 
2768 
2769 #define DEFINE_RELEASESCALARARRAYELEMENTS(ElementTag,ElementType,Result,Tag \
2770                                           , EntryProbe, ReturnProbe);\
2771 \
2772 JNI_ENTRY_NO_PRESERVE(void, \
2773           jni_Release##Result##ArrayElements(JNIEnv *env, ElementType##Array array, \
2774                                              ElementType *buf, jint mode)) \
2775   JNIWrapper(&quot;Release&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2776   EntryProbe; \
2777   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2778   int len = a-&gt;length(); \
2779   if (len != 0) {   /* Empty array:  nothing to free or copy. */  \
2780     if ((mode == 0) || (mode == JNI_COMMIT)) { \
2781       ArrayAccess&lt;&gt;::arraycopy_from_native(buf, a, typeArrayOopDesc::element_offset&lt;ElementType&gt;(0), len); \
2782     } \
2783     if ((mode == 0) || (mode == JNI_ABORT)) { \
2784       FreeHeap(buf); \
2785     } \
2786   } \
2787   ReturnProbe; \
2788 JNI_END
2789 
2790 DEFINE_RELEASESCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2791                                   , HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2792                                   HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_RETURN())
2793 DEFINE_RELEASESCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2794                                   , HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_ENTRY(env, array, (char *) buf, mode),
2795                                   HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_RETURN())
2796 DEFINE_RELEASESCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2797                                   ,  HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2798                                   HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_RETURN())
2799 DEFINE_RELEASESCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2800                                   ,  HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2801                                   HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_RETURN())
2802 DEFINE_RELEASESCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2803                                   , HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_ENTRY(env, array, (uint32_t *) buf, mode),
2804                                   HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_RETURN())
2805 DEFINE_RELEASESCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2806                                   , HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2807                                   HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_RETURN())
2808 DEFINE_RELEASESCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2809                                   , HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_ENTRY(env, array, (float *) buf, mode),
2810                                   HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_RETURN())
2811 DEFINE_RELEASESCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2812                                   , HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_ENTRY(env, array, (double *) buf, mode),
2813                                   HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_RETURN())
2814 
2815 static void check_bounds(jsize start, jsize copy_len, jsize array_len, TRAPS) {
2816   ResourceMark rm(THREAD);
2817   if (copy_len &lt; 0) {
2818     stringStream ss;
2819     ss.print(&quot;Length %d is negative&quot;, copy_len);
2820     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2821   } else if (start &lt; 0 || (start &gt; array_len - copy_len)) {
2822     stringStream ss;
2823     ss.print(&quot;Array region %d..&quot; INT64_FORMAT &quot; out of bounds for length %d&quot;,
2824              start, (int64_t)start+(int64_t)copy_len, array_len);
2825     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2826   }
2827 }
2828 
2829 #define DEFINE_GETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2830                                     , EntryProbe, ReturnProbe); \
2831   DT_VOID_RETURN_MARK_DECL(Get##Result##ArrayRegion \
2832                            , ReturnProbe); \
2833 \
2834 JNI_ENTRY(void, \
2835 jni_Get##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2836              jsize len, ElementType *buf)) \
2837   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayRegion&quot;); \
2838   EntryProbe; \
2839   DT_VOID_RETURN_MARK(Get##Result##ArrayRegion); \
2840   typeArrayOop src = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2841   check_bounds(start, len, src-&gt;length(), CHECK); \
2842   if (len &gt; 0) {    \
2843     ArrayAccess&lt;&gt;::arraycopy_to_native(src, typeArrayOopDesc::element_offset&lt;ElementType&gt;(start), buf, len); \
2844   } \
2845 JNI_END
2846 
2847 DEFINE_GETSCALARARRAYREGION(T_BOOLEAN, jboolean,Boolean, bool
2848                             , HOTSPOT_JNI_GETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2849                             HOTSPOT_JNI_GETBOOLEANARRAYREGION_RETURN());
2850 DEFINE_GETSCALARARRAYREGION(T_BYTE,    jbyte,   Byte,    byte
2851                             ,  HOTSPOT_JNI_GETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2852                             HOTSPOT_JNI_GETBYTEARRAYREGION_RETURN());
2853 DEFINE_GETSCALARARRAYREGION(T_SHORT,   jshort,  Short,   short
2854                             , HOTSPOT_JNI_GETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2855                             HOTSPOT_JNI_GETSHORTARRAYREGION_RETURN());
2856 DEFINE_GETSCALARARRAYREGION(T_CHAR,    jchar,   Char,    char
2857                             ,  HOTSPOT_JNI_GETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t*) buf),
2858                             HOTSPOT_JNI_GETCHARARRAYREGION_RETURN());
2859 DEFINE_GETSCALARARRAYREGION(T_INT,     jint,    Int,     int
2860                             , HOTSPOT_JNI_GETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t*) buf),
2861                             HOTSPOT_JNI_GETINTARRAYREGION_RETURN());
2862 DEFINE_GETSCALARARRAYREGION(T_LONG,    jlong,   Long,    long
2863                             ,  HOTSPOT_JNI_GETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2864                             HOTSPOT_JNI_GETLONGARRAYREGION_RETURN());
2865 DEFINE_GETSCALARARRAYREGION(T_FLOAT,   jfloat,  Float,   float
2866                             , HOTSPOT_JNI_GETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2867                             HOTSPOT_JNI_GETFLOATARRAYREGION_RETURN());
2868 DEFINE_GETSCALARARRAYREGION(T_DOUBLE,  jdouble, Double,  double
2869                             , HOTSPOT_JNI_GETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2870                             HOTSPOT_JNI_GETDOUBLEARRAYREGION_RETURN());
2871 
2872 
2873 #define DEFINE_SETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2874                                     , EntryProbe, ReturnProbe); \
2875   DT_VOID_RETURN_MARK_DECL(Set##Result##ArrayRegion \
2876                            ,ReturnProbe);           \
2877 \
2878 JNI_ENTRY(void, \
2879 jni_Set##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2880              jsize len, const ElementType *buf)) \
2881   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;ArrayRegion&quot;); \
2882   EntryProbe; \
2883   DT_VOID_RETURN_MARK(Set##Result##ArrayRegion); \
2884   typeArrayOop dst = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2885   check_bounds(start, len, dst-&gt;length(), CHECK); \
2886   if (len &gt; 0) { \
2887     ArrayAccess&lt;&gt;::arraycopy_from_native(buf, dst, typeArrayOopDesc::element_offset&lt;ElementType&gt;(start), len); \
2888   } \
2889 JNI_END
2890 
2891 DEFINE_SETSCALARARRAYREGION(T_BOOLEAN, jboolean, Boolean, bool
2892                             , HOTSPOT_JNI_SETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *)buf),
2893                             HOTSPOT_JNI_SETBOOLEANARRAYREGION_RETURN())
2894 DEFINE_SETSCALARARRAYREGION(T_BYTE,    jbyte,    Byte,    byte
2895                             , HOTSPOT_JNI_SETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2896                             HOTSPOT_JNI_SETBYTEARRAYREGION_RETURN())
2897 DEFINE_SETSCALARARRAYREGION(T_SHORT,   jshort,   Short,   short
2898                             , HOTSPOT_JNI_SETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2899                             HOTSPOT_JNI_SETSHORTARRAYREGION_RETURN())
2900 DEFINE_SETSCALARARRAYREGION(T_CHAR,    jchar,    Char,    char
2901                             , HOTSPOT_JNI_SETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2902                             HOTSPOT_JNI_SETCHARARRAYREGION_RETURN())
2903 DEFINE_SETSCALARARRAYREGION(T_INT,     jint,     Int,     int
2904                             , HOTSPOT_JNI_SETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t *) buf),
2905                             HOTSPOT_JNI_SETINTARRAYREGION_RETURN())
2906 DEFINE_SETSCALARARRAYREGION(T_LONG,    jlong,    Long,    long
2907                             , HOTSPOT_JNI_SETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2908                             HOTSPOT_JNI_SETLONGARRAYREGION_RETURN())
2909 DEFINE_SETSCALARARRAYREGION(T_FLOAT,   jfloat,   Float,   float
2910                             , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2911                             HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
2912 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
2913                             , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2914                             HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
2915 
2916 
2917 DT_RETURN_MARK_DECL(RegisterNatives, jint
2918                     , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
2919 
2920 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
2921                                     const JNINativeMethod *methods,
2922                                     jint nMethods))
2923   JNIWrapper(&quot;RegisterNatives&quot;);
2924   HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
2925   jint ret = 0;
2926   DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
2927 
2928   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2929 
2930   // There are no restrictions on native code registering native methods, which
2931   // allows agents to redefine the bindings to native methods. But we issue a
2932   // warning if any code running outside of the boot/platform loader is rebinding
2933   // any native methods in classes loaded by the boot/platform loader.
2934   Klass* caller = thread-&gt;security_get_caller_class(1);
2935   bool do_warning = false;
2936   oop cl = k-&gt;class_loader();
2937   if (cl ==  NULL || SystemDictionary::is_platform_class_loader(cl)) {
2938     // If no caller class, or caller class has a different loader, then
2939     // issue a warning below.
2940     do_warning = (caller == NULL) || caller-&gt;class_loader() != cl;
2941   }
2942 
2943 
2944   for (int index = 0; index &lt; nMethods; index++) {
2945     const char* meth_name = methods[index].name;
2946     const char* meth_sig = methods[index].signature;
2947     int meth_name_len = (int)strlen(meth_name);
2948 
2949     // The class should have been loaded (we have an instance of the class
2950     // passed in) so the method and signature should already be in the symbol
2951     // table.  If they&#39;re not there, the method doesn&#39;t exist.
2952     TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
2953     TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
2954 
2955     if (name == NULL || signature == NULL) {
2956       ResourceMark rm(THREAD);
2957       stringStream st;
2958       st.print(&quot;Method %s.%s%s not found&quot;, k-&gt;external_name(), meth_name, meth_sig);
2959       // Must return negative value on failure
2960       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
2961     }
2962 
2963     if (do_warning) {
2964       ResourceMark rm(THREAD);
2965       log_warning(jni, resolve)(&quot;Re-registering of platform native method: %s.%s%s &quot;
2966               &quot;from code in a different classloader&quot;, k-&gt;external_name(), meth_name, meth_sig);
2967     }
2968 
2969     bool res = Method::register_native(k, name, signature,
2970                                        (address) methods[index].fnPtr, THREAD);
2971     if (!res) {
2972       ret = -1;
2973       break;
2974     }
2975   }
2976   return ret;
2977 JNI_END
2978 
2979 
2980 JNI_ENTRY(jint, jni_UnregisterNatives(JNIEnv *env, jclass clazz))
2981   JNIWrapper(&quot;UnregisterNatives&quot;);
2982  HOTSPOT_JNI_UNREGISTERNATIVES_ENTRY(env, clazz);
2983   Klass* k   = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2984   //%note jni_2
2985   if (k-&gt;is_instance_klass()) {
2986     for (int index = 0; index &lt; InstanceKlass::cast(k)-&gt;methods()-&gt;length(); index++) {
2987       Method* m = InstanceKlass::cast(k)-&gt;methods()-&gt;at(index);
2988       if (m-&gt;is_native()) {
2989         m-&gt;clear_native_function();
2990         m-&gt;set_signature_handler(NULL);
2991       }
2992     }
2993   }
2994  HOTSPOT_JNI_UNREGISTERNATIVES_RETURN(0);
2995   return 0;
2996 JNI_END
2997 
2998 //
2999 // Monitor functions
3000 //
3001 
3002 DT_RETURN_MARK_DECL(MonitorEnter, jint
3003                     , HOTSPOT_JNI_MONITORENTER_RETURN(_ret_ref));
3004 
3005 JNI_ENTRY(jint, jni_MonitorEnter(JNIEnv *env, jobject jobj))
3006  HOTSPOT_JNI_MONITORENTER_ENTRY(env, jobj);
3007   jint ret = JNI_ERR;
3008   DT_RETURN_MARK(MonitorEnter, jint, (const jint&amp;)ret);
3009 
3010   // If the object is null, we can&#39;t do anything with it
3011   if (jobj == NULL) {
3012     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
3013   }
3014 
3015   Handle obj(thread, JNIHandles::resolve_non_null(jobj));
3016   ObjectSynchronizer::jni_enter(obj, CHECK_(JNI_ERR));
3017   ret = JNI_OK;
3018   return ret;
3019 JNI_END
3020 
3021 DT_RETURN_MARK_DECL(MonitorExit, jint
3022                     , HOTSPOT_JNI_MONITOREXIT_RETURN(_ret_ref));
3023 
3024 JNI_ENTRY(jint, jni_MonitorExit(JNIEnv *env, jobject jobj))
3025  HOTSPOT_JNI_MONITOREXIT_ENTRY(env, jobj);
3026   jint ret = JNI_ERR;
3027   DT_RETURN_MARK(MonitorExit, jint, (const jint&amp;)ret);
3028 
3029   // Don&#39;t do anything with a null object
3030   if (jobj == NULL) {
3031     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
3032   }
3033 
3034   Handle obj(THREAD, JNIHandles::resolve_non_null(jobj));
3035   ObjectSynchronizer::jni_exit(obj(), CHECK_(JNI_ERR));
3036 
3037   ret = JNI_OK;
3038   return ret;
3039 JNI_END
3040 
3041 //
3042 // Extensions
3043 //
3044 
3045 DT_VOID_RETURN_MARK_DECL(GetStringRegion
3046                          , HOTSPOT_JNI_GETSTRINGREGION_RETURN());
3047 
3048 JNI_ENTRY(void, jni_GetStringRegion(JNIEnv *env, jstring string, jsize start, jsize len, jchar *buf))
3049   JNIWrapper(&quot;GetStringRegion&quot;);
3050  HOTSPOT_JNI_GETSTRINGREGION_ENTRY(env, string, start, len, buf);
3051   DT_VOID_RETURN_MARK(GetStringRegion);
3052   oop s = JNIHandles::resolve_non_null(string);
3053   typeArrayOop s_value = java_lang_String::value(s);
3054   int s_len = java_lang_String::length(s, s_value);
3055   if (start &lt; 0 || len &lt; 0 || start &gt; s_len - len) {
3056     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
3057   } else {
3058     if (len &gt; 0) {
3059       bool is_latin1 = java_lang_String::is_latin1(s);
3060       if (!is_latin1) {
3061         ArrayAccess&lt;&gt;::arraycopy_to_native(s_value, typeArrayOopDesc::element_offset&lt;jchar&gt;(start),
3062                                            buf, len);
3063       } else {
3064         for (int i = 0; i &lt; len; i++) {
3065           buf[i] = ((jchar) s_value-&gt;byte_at(i + start)) &amp; 0xff;
3066         }
3067       }
3068     }
3069   }
3070 JNI_END
3071 
3072 DT_VOID_RETURN_MARK_DECL(GetStringUTFRegion
3073                          , HOTSPOT_JNI_GETSTRINGUTFREGION_RETURN());
3074 
3075 JNI_ENTRY(void, jni_GetStringUTFRegion(JNIEnv *env, jstring string, jsize start, jsize len, char *buf))
3076   JNIWrapper(&quot;GetStringUTFRegion&quot;);
3077  HOTSPOT_JNI_GETSTRINGUTFREGION_ENTRY(env, string, start, len, buf);
3078   DT_VOID_RETURN_MARK(GetStringUTFRegion);
3079   oop s = JNIHandles::resolve_non_null(string);
3080   typeArrayOop s_value = java_lang_String::value(s);
3081   int s_len = java_lang_String::length(s, s_value);
3082   if (start &lt; 0 || len &lt; 0 || start &gt; s_len - len) {
3083     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
3084   } else {
3085     //%note jni_7
3086     if (len &gt; 0) {
3087       // Assume the buffer is large enough as the JNI spec. does not require user error checking
3088       java_lang_String::as_utf8_string(s, s_value, start, len, buf, INT_MAX);
3089       // as_utf8_string null-terminates the result string
3090     } else {
3091       // JDK null-terminates the buffer even in len is zero
3092       if (buf != NULL) {
3093         buf[0] = 0;
3094       }
3095     }
3096   }
3097 JNI_END
3098 
3099 static oop lock_gc_or_pin_object(JavaThread* thread, jobject obj) {
3100   if (Universe::heap()-&gt;supports_object_pinning()) {
3101     const oop o = JNIHandles::resolve_non_null(obj);
3102     return Universe::heap()-&gt;pin_object(thread, o);
3103   } else {
3104     GCLocker::lock_critical(thread);
3105     return JNIHandles::resolve_non_null(obj);
3106   }
3107 }
3108 
3109 static void unlock_gc_or_unpin_object(JavaThread* thread, jobject obj) {
3110   if (Universe::heap()-&gt;supports_object_pinning()) {
3111     const oop o = JNIHandles::resolve_non_null(obj);
3112     return Universe::heap()-&gt;unpin_object(thread, o);
3113   } else {
3114     GCLocker::unlock_critical(thread);
3115   }
3116 }
3117 
3118 JNI_ENTRY(void*, jni_GetPrimitiveArrayCritical(JNIEnv *env, jarray array, jboolean *isCopy))
3119   JNIWrapper(&quot;GetPrimitiveArrayCritical&quot;);
3120  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_ENTRY(env, array, (uintptr_t *) isCopy);
3121   if (isCopy != NULL) {
3122     *isCopy = JNI_FALSE;
3123   }
3124   oop a = lock_gc_or_pin_object(thread, array);
3125   assert(a-&gt;is_array(), &quot;just checking&quot;);
3126   BasicType type;
3127   if (a-&gt;is_objArray()) {
3128     type = T_OBJECT;
3129   } else {
3130     type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
3131   }
3132   void* ret = arrayOop(a)-&gt;base(type);
3133  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_RETURN(ret);
3134   return ret;
3135 JNI_END
3136 
3137 
3138 JNI_ENTRY(void, jni_ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode))
3139   JNIWrapper(&quot;ReleasePrimitiveArrayCritical&quot;);
3140   HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_ENTRY(env, array, carray, mode);
3141   unlock_gc_or_unpin_object(thread, array);
3142 HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_RETURN();
3143 JNI_END
3144 
3145 
3146 JNI_ENTRY(const jchar*, jni_GetStringCritical(JNIEnv *env, jstring string, jboolean *isCopy))
3147   JNIWrapper(&quot;GetStringCritical&quot;);
3148   HOTSPOT_JNI_GETSTRINGCRITICAL_ENTRY(env, string, (uintptr_t *) isCopy);
3149   oop s = lock_gc_or_pin_object(thread, string);
3150   typeArrayOop s_value = java_lang_String::value(s);
3151   bool is_latin1 = java_lang_String::is_latin1(s);
3152   if (isCopy != NULL) {
3153     *isCopy = is_latin1 ? JNI_TRUE : JNI_FALSE;
3154   }
3155   jchar* ret;
3156   if (!is_latin1) {
3157     ret = (jchar*) s_value-&gt;base(T_CHAR);
3158   } else {
3159     // Inflate latin1 encoded string to UTF16
3160     int s_len = java_lang_String::length(s, s_value);
3161     ret = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
3162     /* JNI Specification states return NULL on OOM */
3163     if (ret != NULL) {
3164       for (int i = 0; i &lt; s_len; i++) {
3165         ret[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
3166       }
3167       ret[s_len] = 0;
3168     }
3169   }
3170  HOTSPOT_JNI_GETSTRINGCRITICAL_RETURN((uint16_t *) ret);
3171   return ret;
3172 JNI_END
3173 
3174 
3175 JNI_ENTRY(void, jni_ReleaseStringCritical(JNIEnv *env, jstring str, const jchar *chars))
3176   JNIWrapper(&quot;ReleaseStringCritical&quot;);
3177   HOTSPOT_JNI_RELEASESTRINGCRITICAL_ENTRY(env, str, (uint16_t *) chars);
3178   // The str and chars arguments are ignored for UTF16 strings
3179   oop s = JNIHandles::resolve_non_null(str);
3180   bool is_latin1 = java_lang_String::is_latin1(s);
3181   if (is_latin1) {
3182     // For latin1 string, free jchar array allocated by earlier call to GetStringCritical.
3183     // This assumes that ReleaseStringCritical bookends GetStringCritical.
3184     FREE_C_HEAP_ARRAY(jchar, chars);
3185   }
3186   unlock_gc_or_unpin_object(thread, str);
3187 HOTSPOT_JNI_RELEASESTRINGCRITICAL_RETURN();
3188 JNI_END
3189 
3190 
3191 JNI_ENTRY(jweak, jni_NewWeakGlobalRef(JNIEnv *env, jobject ref))
3192   JNIWrapper(&quot;jni_NewWeakGlobalRef&quot;);
3193  HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY(env, ref);
3194   Handle ref_handle(thread, JNIHandles::resolve(ref));
3195   jweak ret = JNIHandles::make_weak_global(ref_handle);
3196  HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN(ret);
3197   return ret;
3198 JNI_END
3199 
3200 // Must be JNI_ENTRY (with HandleMark)
3201 JNI_ENTRY(void, jni_DeleteWeakGlobalRef(JNIEnv *env, jweak ref))
3202   JNIWrapper(&quot;jni_DeleteWeakGlobalRef&quot;);
3203   HOTSPOT_JNI_DELETEWEAKGLOBALREF_ENTRY(env, ref);
3204   JNIHandles::destroy_weak_global(ref);
3205   HOTSPOT_JNI_DELETEWEAKGLOBALREF_RETURN();
3206 JNI_END
3207 
3208 
3209 JNI_ENTRY_NO_PRESERVE(jboolean, jni_ExceptionCheck(JNIEnv *env))
3210   JNIWrapper(&quot;jni_ExceptionCheck&quot;);
3211  HOTSPOT_JNI_EXCEPTIONCHECK_ENTRY(env);
3212   jni_check_async_exceptions(thread);
3213   jboolean ret = (thread-&gt;has_pending_exception()) ? JNI_TRUE : JNI_FALSE;
3214  HOTSPOT_JNI_EXCEPTIONCHECK_RETURN(ret);
3215   return ret;
3216 JNI_END
3217 
3218 
3219 // Initialization state for three routines below relating to
3220 // java.nio.DirectBuffers
3221 static          int directBufferSupportInitializeStarted = 0;
3222 static volatile int directBufferSupportInitializeEnded   = 0;
3223 static volatile int directBufferSupportInitializeFailed  = 0;
3224 static jclass    bufferClass                 = NULL;
3225 static jclass    directBufferClass           = NULL;
3226 static jclass    directByteBufferClass       = NULL;
3227 static jmethodID directByteBufferConstructor = NULL;
3228 static jfieldID  directBufferAddressField    = NULL;
3229 static jfieldID  bufferCapacityField         = NULL;
3230 
3231 static jclass lookupOne(JNIEnv* env, const char* name, TRAPS) {
3232   Handle loader;            // null (bootstrap) loader
3233   Handle protection_domain; // null protection domain
3234 
3235   TempNewSymbol sym = SymbolTable::new_symbol(name);
3236   jclass result =  find_class_from_class_loader(env, sym, true, loader, protection_domain, true, CHECK_NULL);
3237 
3238   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
3239     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
3240   }
3241   return result;
3242 }
3243 
3244 // These lookups are done with the NULL (bootstrap) ClassLoader to
3245 // circumvent any security checks that would be done by jni_FindClass.
3246 JNI_ENTRY(bool, lookupDirectBufferClasses(JNIEnv* env))
3247 {
3248   if ((bufferClass           = lookupOne(env, &quot;java/nio/Buffer&quot;, thread))           == NULL) { return false; }
3249   if ((directBufferClass     = lookupOne(env, &quot;sun/nio/ch/DirectBuffer&quot;, thread))   == NULL) { return false; }
3250   if ((directByteBufferClass = lookupOne(env, &quot;java/nio/DirectByteBuffer&quot;, thread)) == NULL) { return false; }
3251   return true;
3252 }
3253 JNI_END
3254 
3255 
3256 static bool initializeDirectBufferSupport(JNIEnv* env, JavaThread* thread) {
3257   if (directBufferSupportInitializeFailed) {
3258     return false;
3259   }
3260 
3261   if (Atomic::cmpxchg(&amp;directBufferSupportInitializeStarted, 0, 1) == 0) {
3262     if (!lookupDirectBufferClasses(env)) {
3263       directBufferSupportInitializeFailed = 1;
3264       return false;
3265     }
3266 
3267     // Make global references for these
3268     bufferClass           = (jclass) env-&gt;NewGlobalRef(bufferClass);
3269     directBufferClass     = (jclass) env-&gt;NewGlobalRef(directBufferClass);
3270     directByteBufferClass = (jclass) env-&gt;NewGlobalRef(directByteBufferClass);
3271 
3272     // Get needed field and method IDs
3273     directByteBufferConstructor = env-&gt;GetMethodID(directByteBufferClass, &quot;&lt;init&gt;&quot;, &quot;(JI)V&quot;);
3274     if (env-&gt;ExceptionCheck()) {
3275       env-&gt;ExceptionClear();
3276       directBufferSupportInitializeFailed = 1;
3277       return false;
3278     }
3279     directBufferAddressField    = env-&gt;GetFieldID(bufferClass, &quot;address&quot;, &quot;J&quot;);
3280     if (env-&gt;ExceptionCheck()) {
3281       env-&gt;ExceptionClear();
3282       directBufferSupportInitializeFailed = 1;
3283       return false;
3284     }
3285     bufferCapacityField         = env-&gt;GetFieldID(bufferClass, &quot;capacity&quot;, &quot;I&quot;);
3286     if (env-&gt;ExceptionCheck()) {
3287       env-&gt;ExceptionClear();
3288       directBufferSupportInitializeFailed = 1;
3289       return false;
3290     }
3291 
3292     if ((directByteBufferConstructor == NULL) ||
3293         (directBufferAddressField    == NULL) ||
3294         (bufferCapacityField         == NULL)) {
3295       directBufferSupportInitializeFailed = 1;
3296       return false;
3297     }
3298 
3299     directBufferSupportInitializeEnded = 1;
3300   } else {
3301     while (!directBufferSupportInitializeEnded &amp;&amp; !directBufferSupportInitializeFailed) {
3302       os::naked_yield();
3303     }
3304   }
3305 
3306   return !directBufferSupportInitializeFailed;
3307 }
3308 
3309 extern &quot;C&quot; jobject JNICALL jni_NewDirectByteBuffer(JNIEnv *env, void* address, jlong capacity)
3310 {
3311   // thread_from_jni_environment() will block if VM is gone.
3312   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3313 
3314   JNIWrapper(&quot;jni_NewDirectByteBuffer&quot;);
3315  HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_ENTRY(env, address, capacity);
3316 
3317   if (!directBufferSupportInitializeEnded) {
3318     if (!initializeDirectBufferSupport(env, thread)) {
3319       HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(NULL);
3320       return NULL;
3321     }
3322   }
3323 
3324   // Being paranoid about accidental sign extension on address
3325   jlong addr = (jlong) ((uintptr_t) address);
3326   // NOTE that package-private DirectByteBuffer constructor currently
3327   // takes int capacity
3328   jint  cap  = (jint)  capacity;
3329   jobject ret = env-&gt;NewObject(directByteBufferClass, directByteBufferConstructor, addr, cap);
3330   HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(ret);
3331   return ret;
3332 }
3333 
3334 DT_RETURN_MARK_DECL(GetDirectBufferAddress, void*
3335                     , HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_RETURN((void*) _ret_ref));
3336 
3337 extern &quot;C&quot; void* JNICALL jni_GetDirectBufferAddress(JNIEnv *env, jobject buf)
3338 {
3339   // thread_from_jni_environment() will block if VM is gone.
3340   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3341 
3342   JNIWrapper(&quot;jni_GetDirectBufferAddress&quot;);
3343   HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_ENTRY(env, buf);
3344   void* ret = NULL;
3345   DT_RETURN_MARK(GetDirectBufferAddress, void*, (const void*&amp;)ret);
3346 
3347   if (!directBufferSupportInitializeEnded) {
3348     if (!initializeDirectBufferSupport(env, thread)) {
3349       return 0;
3350     }
3351   }
3352 
3353   if ((buf != NULL) &amp;&amp; (!env-&gt;IsInstanceOf(buf, directBufferClass))) {
3354     return 0;
3355   }
3356 
3357   ret = (void*)(intptr_t)env-&gt;GetLongField(buf, directBufferAddressField);
3358   return ret;
3359 }
3360 
3361 DT_RETURN_MARK_DECL(GetDirectBufferCapacity, jlong
3362                     , HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_RETURN(_ret_ref));
3363 
3364 extern &quot;C&quot; jlong JNICALL jni_GetDirectBufferCapacity(JNIEnv *env, jobject buf)
3365 {
3366   // thread_from_jni_environment() will block if VM is gone.
3367   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3368 
3369   JNIWrapper(&quot;jni_GetDirectBufferCapacity&quot;);
3370   HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_ENTRY(env, buf);
3371   jlong ret = -1;
3372   DT_RETURN_MARK(GetDirectBufferCapacity, jlong, (const jlong&amp;)ret);
3373 
3374   if (!directBufferSupportInitializeEnded) {
3375     if (!initializeDirectBufferSupport(env, thread)) {
3376       ret = 0;
3377       return ret;
3378     }
3379   }
3380 
3381   if (buf == NULL) {
3382     return -1;
3383   }
3384 
3385   if (!env-&gt;IsInstanceOf(buf, directBufferClass)) {
3386     return -1;
3387   }
3388 
3389   // NOTE that capacity is currently an int in the implementation
3390   ret = env-&gt;GetIntField(buf, bufferCapacityField);
3391   return ret;
3392 }
3393 
3394 
3395 JNI_LEAF(jint, jni_GetVersion(JNIEnv *env))
3396   JNIWrapper(&quot;GetVersion&quot;);
3397   HOTSPOT_JNI_GETVERSION_ENTRY(env);
3398   HOTSPOT_JNI_GETVERSION_RETURN(CurrentVersion);
3399   return CurrentVersion;
3400 JNI_END
3401 
3402 extern struct JavaVM_ main_vm;
3403 
3404 JNI_LEAF(jint, jni_GetJavaVM(JNIEnv *env, JavaVM **vm))
3405   JNIWrapper(&quot;jni_GetJavaVM&quot;);
3406   HOTSPOT_JNI_GETJAVAVM_ENTRY(env, (void **) vm);
3407   *vm  = (JavaVM *)(&amp;main_vm);
3408   HOTSPOT_JNI_GETJAVAVM_RETURN(JNI_OK);
3409   return JNI_OK;
3410 JNI_END
3411 
3412 
3413 JNI_ENTRY(jobject, jni_GetModule(JNIEnv* env, jclass clazz))
3414   JNIWrapper(&quot;GetModule&quot;);
3415   return Modules::get_module(clazz, THREAD);
3416 JNI_END
3417 
3418 
3419 JNI_ENTRY(void*, jni_GetFlattenedArrayElements(JNIEnv* env, jarray array, jboolean* isCopy))
3420   JNIWrapper(&quot;jni_GetFlattenedArrayElements&quot;);
3421   if (isCopy != NULL) {
3422     *isCopy = JNI_FALSE;
3423   }
3424   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));
3425   if (!ar-&gt;is_array()) {
3426     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3427   }
3428   if (!ar-&gt;is_valueArray()) {
3429     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3430   }
3431   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());
3432   if (vak-&gt;contains_oops()) {
3433     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Flattened array contains oops&quot;);
3434   }
3435   oop a = lock_gc_or_pin_object(thread, array);
3436   valueArrayOop vap = valueArrayOop(a);
3437   void* ret = vap-&gt;value_at_addr(0, vak-&gt;layout_helper());
3438   return ret;
3439 JNI_END
3440 
3441 JNI_ENTRY(void, jni_ReleaseFlattenedArrayElements(JNIEnv* env, jarray array, void* elem, jint mode))
3442   JNIWrapper(&quot;jni_ReleaseFlattenedArrayElements&quot;);
3443   unlock_gc_or_unpin_object(thread, array);
3444 JNI_END
3445 
3446 JNI_ENTRY(jsize, jni_GetFlattenedArrayElementSize(JNIEnv* env, jarray array)) {
3447   JNIWrapper(&quot;jni_GetFlattenedElementSize&quot;);
3448   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
3449   if (!a-&gt;is_array()) {
3450     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3451   }
3452   if (!a-&gt;is_valueArray()) {
3453     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3454   }
3455   ValueArrayKlass* vak = ValueArrayKlass::cast(a-&gt;klass());
3456   jsize ret = vak-&gt;element_byte_size();
3457   return ret;
3458 }
3459 JNI_END
3460 
3461 JNI_ENTRY(jclass, jni_GetFlattenedArrayElementClass(JNIEnv* env, jarray array))
3462   JNIWrapper(&quot;jni_GetArrayElementClass&quot;);
3463   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
3464   if (!a-&gt;is_array()) {
3465     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3466   }
3467   if (!a-&gt;is_valueArray()) {
3468     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3469   }
3470   ValueArrayKlass* vak = ValueArrayKlass::cast(a-&gt;klass());
3471   ValueKlass* vk = vak-&gt;element_klass();
3472   return (jclass) JNIHandles::make_local(vk-&gt;java_mirror());
3473 JNI_END
3474 
3475 JNI_ENTRY(jsize, jni_GetFieldOffsetInFlattenedLayout(JNIEnv* env, jclass clazz, const char *name, const char *signature, jboolean* isFlattened))
3476   JNIWrapper(&quot;jni_GetFieldOffsetInFlattenedLayout&quot;);
3477 
3478   oop mirror = JNIHandles::resolve_non_null(clazz);
3479   Klass* k = java_lang_Class::as_Klass(mirror);
3480   if (!k-&gt;is_value()) {
3481     ResourceMark rm;
3482         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;%s has not flattened layout&quot;, k-&gt;external_name()));
3483   }
3484   ValueKlass* vk = ValueKlass::cast(k);
3485 
3486   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
3487   TempNewSymbol signame = SymbolTable::probe(signature, (int)strlen(signature));
3488   if (fieldname == NULL || signame == NULL) {
3489     ResourceMark rm;
3490     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, vk-&gt;external_name(), name, signature));
3491   }
3492 
3493   assert(vk-&gt;is_initialized(), &quot;If a flattened array has been created, the element klass must have been initialized&quot;);
3494 
3495   fieldDescriptor fd;
3496   if (!vk-&gt;is_instance_klass() ||
3497       !InstanceKlass::cast(vk)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
3498     ResourceMark rm;
3499     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, vk-&gt;external_name(), name, signature));
3500   }
3501 
3502   int offset = fd.offset() - vk-&gt;first_field_offset();
3503   if (isFlattened != NULL) {
3504     *isFlattened = fd.is_flattened();
3505   }
3506   return (jsize)offset;
3507 JNI_END
3508 
3509 JNI_ENTRY(jobject, jni_CreateSubElementSelector(JNIEnv* env, jarray array))
3510   JNIWrapper(&quot;jni_CreateSubElementSelector&quot;);
3511 
3512   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));
3513   if (!ar-&gt;is_array()) {
3514     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3515   }
3516   if (!ar-&gt;is_valueArray()) {
3517     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3518   }
3519   Klass* ses_k = SystemDictionary::resolve_or_null(vmSymbols::jdk_internal_vm_jni_SubElementSelector(),
3520         Handle(THREAD, SystemDictionary::java_system_loader()), Handle(), CHECK_NULL);
3521   InstanceKlass* ses_ik = InstanceKlass::cast(ses_k);
3522   ses_ik-&gt;initialize(CHECK_NULL);
3523   Klass* elementKlass = ArrayKlass::cast(ar-&gt;klass())-&gt;element_klass();
3524   oop ses = ses_ik-&gt;allocate_instance(CHECK_NULL);
3525   Handle ses_h(THREAD, ses);
3526   jdk_internal_vm_jni_SubElementSelector::setArrayElementType(ses_h(), elementKlass-&gt;java_mirror());
3527   jdk_internal_vm_jni_SubElementSelector::setSubElementType(ses_h(), elementKlass-&gt;java_mirror());
3528   jdk_internal_vm_jni_SubElementSelector::setOffset(ses_h(), 0);
3529   jdk_internal_vm_jni_SubElementSelector::setIsFlattened(ses_h(), true);   // by definition, top element of a flattened array is flattened
3530   jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(ses_h(), true); // by definition, top element of a flattened array is flattenable
3531   return JNIHandles::make_local(ses_h());
3532 JNI_END
3533 
3534 JNI_ENTRY(jobject, jni_GetSubElementSelector(JNIEnv* env, jobject selector, jfieldID fieldID))
3535   JNIWrapper(&quot;jni_GetSubElementSelector&quot;);
3536 
3537   oop slct = JNIHandles::resolve_non_null(selector);
3538   if (slct-&gt;klass()-&gt;name() != vmSymbols::jdk_internal_vm_jni_SubElementSelector()) {
3539     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a SubElementSelector&quot;);
3540   }
3541   jboolean isflattened = jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct);
3542   if (!isflattened) {
3543     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;SubElement is not flattened&quot;);
3544   }
3545   oop semirror = jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct);
3546   Klass* k = java_lang_Class::as_Klass(semirror);
3547   if (!k-&gt;is_value()) {
3548     ResourceMark rm;
3549         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;%s is not an inline type&quot;, k-&gt;external_name()));
3550   }
3551   ValueKlass* vk = ValueKlass::cast(k);
3552   assert(vk-&gt;is_initialized(), &quot;If a flattened array has been created, the element klass must have been initialized&quot;);
3553   int field_offset = jfieldIDWorkaround::from_instance_jfieldID(vk, fieldID);
3554   fieldDescriptor fd;
3555   if (!vk-&gt;find_field_from_offset(field_offset, false, &amp;fd)) {
3556     THROW_NULL(vmSymbols::java_lang_NoSuchFieldError());
3557   }
3558   Handle arrayElementMirror(THREAD, jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct));
3559   // offset of the SubElement is offset of the original SubElement plus the offset of the field inside the element
3560   int offset = fd.offset() - vk-&gt;first_field_offset() + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3561   InstanceKlass* sesklass = InstanceKlass::cast(JNIHandles::resolve_non_null(selector)-&gt;klass());
3562   oop res = sesklass-&gt;allocate_instance(CHECK_NULL);
3563   Handle res_h(THREAD, res);
3564   jdk_internal_vm_jni_SubElementSelector::setArrayElementType(res_h(), arrayElementMirror());
3565   InstanceKlass* holder = fd.field_holder();
3566   BasicType bt = Signature::basic_type(fd.signature());
3567   if (is_java_primitive(bt)) {
3568     jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(), java_lang_Class::primitive_mirror(bt));
3569   } else {
3570     Klass* fieldKlass = SystemDictionary::resolve_or_fail(fd.signature(), Handle(THREAD, holder-&gt;class_loader()),
3571         Handle(THREAD, holder-&gt;protection_domain()), true, CHECK_NULL);
3572     jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(),fieldKlass-&gt;java_mirror());
3573   }
3574   jdk_internal_vm_jni_SubElementSelector::setOffset(res_h(), offset);
3575   jdk_internal_vm_jni_SubElementSelector::setIsFlattened(res_h(), fd.is_flattened());
3576   jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(res_h(), fd.is_flattenable());
3577   return JNIHandles::make_local(res_h());
3578 JNI_END
3579 
3580 JNI_ENTRY(jobject, jni_GetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index))
3581   JNIWrapper(&quot;jni_GetObjectSubElement&quot;);
3582 
3583   valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);
3584   oop slct = JNIHandles::resolve_non_null(selector);
3585   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());
3586   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) {
3587     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;);
3588   }
3589   oop res = NULL;
3590   if (!jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct)) {
3591     int offset = (address)ar-&gt;base() - cast_from_oop&lt;address&gt;(ar) + index * vak-&gt;element_byte_size()
3592                       + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3593     res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(ar, offset);
3594   } else {
3595     ValueKlass* fieldKlass = ValueKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));
3596     res = fieldKlass-&gt;allocate_instance(CHECK_NULL);
3597     // The array might have been moved by the GC, refreshing the arrayOop
3598     ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);
3599     address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper())
3600               + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3601     fieldKlass-&gt;value_copy_payload_to_new_oop(addr, res);
3602   }
3603   return JNIHandles::make_local(res);
3604 JNI_END
3605 
3606 JNI_ENTRY(void, jni_SetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index, jobject value))
3607   JNIWrapper(&quot;jni_SetObjectSubElement&quot;);
3608 
3609   valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);
3610   oop slct = JNIHandles::resolve_non_null(selector);
3611   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());
3612   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) {
3613     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;);
3614   }
3615   oop val = JNIHandles::resolve(value);
3616   if (val == NULL) {
3617     if (jdk_internal_vm_jni_SubElementSelector::getIsFlattenable(slct)) {
3618       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), &quot;null cannot be stored in a flattened array&quot;);
3619     }
3620   } else {
3621     if (!val-&gt;is_a(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)))) {
3622       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), &quot;type mismatch&quot;);
3623     }
3624   }
3625   if (!jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct)) {
3626     int offset = (address)ar-&gt;base() - cast_from_oop&lt;address&gt;(ar) + index * vak-&gt;element_byte_size()
3627                   + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3628     HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(ar, offset, JNIHandles::resolve(value));
3629   } else {
3630     ValueKlass* fieldKlass = ValueKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));
3631     address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper())
3632                   + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3633     fieldKlass-&gt;value_copy_oop_to_payload(JNIHandles::resolve_non_null(value), addr);
3634   }
3635 JNI_END
3636 
3637 #define DEFINE_GETSUBELEMENT(ElementType,Result,ElementBasicType) \
3638 \
3639 JNI_ENTRY(ElementType, \
3640           jni_Get##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index)) \
3641   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;SubElement&quot;); \
3642   valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \
3643   oop slct = JNIHandles::resolve_non_null(selector); \
3644   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass()); \
3645   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) { \
3646     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;); \
3647   } \
3648   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \
3649     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong SubElement type&quot;); \
3650   } \
3651   address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper()) \
3652                + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \
3653   ElementType result = *(ElementType*)addr; \
3654   return result; \
3655 JNI_END
3656 
3657 DEFINE_GETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)
3658 DEFINE_GETSUBELEMENT(jbyte, Byte, T_BYTE)
3659 DEFINE_GETSUBELEMENT(jshort, Short,T_SHORT)
3660 DEFINE_GETSUBELEMENT(jchar, Char,T_CHAR)
3661 DEFINE_GETSUBELEMENT(jint, Int,T_INT)
3662 DEFINE_GETSUBELEMENT(jlong, Long,T_LONG)
3663 DEFINE_GETSUBELEMENT(jfloat, Float,T_FLOAT)
3664 DEFINE_GETSUBELEMENT(jdouble, Double,T_DOUBLE)
3665 
3666 #define DEFINE_SETSUBELEMENT(ElementType,Result,ElementBasicType) \
3667 \
3668 JNI_ENTRY(void, \
3669           jni_Set##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index, ElementType value)) \
3670   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;SubElement&quot;); \
3671   valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \
3672   oop slct = JNIHandles::resolve_non_null(selector); \
3673   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass()); \
3674   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) { \
3675     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;); \
3676   } \
3677   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \
3678     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong SubElement type&quot;); \
3679   } \
3680   address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper()) \
3681                + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \
3682   *(ElementType*)addr = value; \
3683 JNI_END
3684 
3685 DEFINE_SETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)
3686 DEFINE_SETSUBELEMENT(jbyte, Byte, T_BYTE)
3687 DEFINE_SETSUBELEMENT(jshort, Short,T_SHORT)
3688 DEFINE_SETSUBELEMENT(jchar, Char,T_CHAR)
3689 DEFINE_SETSUBELEMENT(jint, Int,T_INT)
3690 DEFINE_SETSUBELEMENT(jlong, Long,T_LONG)
3691 DEFINE_SETSUBELEMENT(jfloat, Float,T_FLOAT)
3692 DEFINE_SETSUBELEMENT(jdouble, Double,T_DOUBLE)
3693 
3694 // Structure containing all jni functions
3695 struct JNINativeInterface_ jni_NativeInterface = {
3696     NULL,
3697     NULL,
3698     NULL,
3699 
3700     NULL,
3701 
3702     jni_GetVersion,
3703 
3704     jni_DefineClass,
3705     jni_FindClass,
3706 
3707     jni_FromReflectedMethod,
3708     jni_FromReflectedField,
3709 
3710     jni_ToReflectedMethod,
3711 
3712     jni_GetSuperclass,
3713     jni_IsAssignableFrom,
3714 
3715     jni_ToReflectedField,
3716 
3717     jni_Throw,
3718     jni_ThrowNew,
3719     jni_ExceptionOccurred,
3720     jni_ExceptionDescribe,
3721     jni_ExceptionClear,
3722     jni_FatalError,
3723 
3724     jni_PushLocalFrame,
3725     jni_PopLocalFrame,
3726 
3727     jni_NewGlobalRef,
3728     jni_DeleteGlobalRef,
3729     jni_DeleteLocalRef,
3730     jni_IsSameObject,
3731 
3732     jni_NewLocalRef,
3733     jni_EnsureLocalCapacity,
3734 
3735     jni_AllocObject,
3736     jni_NewObject,
3737     jni_NewObjectV,
3738     jni_NewObjectA,
3739 
3740     jni_GetObjectClass,
3741     jni_IsInstanceOf,
3742 
3743     jni_GetMethodID,
3744 
3745     jni_CallObjectMethod,
3746     jni_CallObjectMethodV,
3747     jni_CallObjectMethodA,
3748     jni_CallBooleanMethod,
3749     jni_CallBooleanMethodV,
3750     jni_CallBooleanMethodA,
3751     jni_CallByteMethod,
3752     jni_CallByteMethodV,
3753     jni_CallByteMethodA,
3754     jni_CallCharMethod,
3755     jni_CallCharMethodV,
3756     jni_CallCharMethodA,
3757     jni_CallShortMethod,
3758     jni_CallShortMethodV,
3759     jni_CallShortMethodA,
3760     jni_CallIntMethod,
3761     jni_CallIntMethodV,
3762     jni_CallIntMethodA,
3763     jni_CallLongMethod,
3764     jni_CallLongMethodV,
3765     jni_CallLongMethodA,
3766     jni_CallFloatMethod,
3767     jni_CallFloatMethodV,
3768     jni_CallFloatMethodA,
3769     jni_CallDoubleMethod,
3770     jni_CallDoubleMethodV,
3771     jni_CallDoubleMethodA,
3772     jni_CallVoidMethod,
3773     jni_CallVoidMethodV,
3774     jni_CallVoidMethodA,
3775 
3776     jni_CallNonvirtualObjectMethod,
3777     jni_CallNonvirtualObjectMethodV,
3778     jni_CallNonvirtualObjectMethodA,
3779     jni_CallNonvirtualBooleanMethod,
3780     jni_CallNonvirtualBooleanMethodV,
3781     jni_CallNonvirtualBooleanMethodA,
3782     jni_CallNonvirtualByteMethod,
3783     jni_CallNonvirtualByteMethodV,
3784     jni_CallNonvirtualByteMethodA,
3785     jni_CallNonvirtualCharMethod,
3786     jni_CallNonvirtualCharMethodV,
3787     jni_CallNonvirtualCharMethodA,
3788     jni_CallNonvirtualShortMethod,
3789     jni_CallNonvirtualShortMethodV,
3790     jni_CallNonvirtualShortMethodA,
3791     jni_CallNonvirtualIntMethod,
3792     jni_CallNonvirtualIntMethodV,
3793     jni_CallNonvirtualIntMethodA,
3794     jni_CallNonvirtualLongMethod,
3795     jni_CallNonvirtualLongMethodV,
3796     jni_CallNonvirtualLongMethodA,
3797     jni_CallNonvirtualFloatMethod,
3798     jni_CallNonvirtualFloatMethodV,
3799     jni_CallNonvirtualFloatMethodA,
3800     jni_CallNonvirtualDoubleMethod,
3801     jni_CallNonvirtualDoubleMethodV,
3802     jni_CallNonvirtualDoubleMethodA,
3803     jni_CallNonvirtualVoidMethod,
3804     jni_CallNonvirtualVoidMethodV,
3805     jni_CallNonvirtualVoidMethodA,
3806 
3807     jni_GetFieldID,
3808 
3809     jni_GetObjectField,
3810     jni_GetBooleanField,
3811     jni_GetByteField,
3812     jni_GetCharField,
3813     jni_GetShortField,
3814     jni_GetIntField,
3815     jni_GetLongField,
3816     jni_GetFloatField,
3817     jni_GetDoubleField,
3818 
3819     jni_SetObjectField,
3820     jni_SetBooleanField,
3821     jni_SetByteField,
3822     jni_SetCharField,
3823     jni_SetShortField,
3824     jni_SetIntField,
3825     jni_SetLongField,
3826     jni_SetFloatField,
3827     jni_SetDoubleField,
3828 
3829     jni_GetStaticMethodID,
3830 
3831     jni_CallStaticObjectMethod,
3832     jni_CallStaticObjectMethodV,
3833     jni_CallStaticObjectMethodA,
3834     jni_CallStaticBooleanMethod,
3835     jni_CallStaticBooleanMethodV,
3836     jni_CallStaticBooleanMethodA,
3837     jni_CallStaticByteMethod,
3838     jni_CallStaticByteMethodV,
3839     jni_CallStaticByteMethodA,
3840     jni_CallStaticCharMethod,
3841     jni_CallStaticCharMethodV,
3842     jni_CallStaticCharMethodA,
3843     jni_CallStaticShortMethod,
3844     jni_CallStaticShortMethodV,
3845     jni_CallStaticShortMethodA,
3846     jni_CallStaticIntMethod,
3847     jni_CallStaticIntMethodV,
3848     jni_CallStaticIntMethodA,
3849     jni_CallStaticLongMethod,
3850     jni_CallStaticLongMethodV,
3851     jni_CallStaticLongMethodA,
3852     jni_CallStaticFloatMethod,
3853     jni_CallStaticFloatMethodV,
3854     jni_CallStaticFloatMethodA,
3855     jni_CallStaticDoubleMethod,
3856     jni_CallStaticDoubleMethodV,
3857     jni_CallStaticDoubleMethodA,
3858     jni_CallStaticVoidMethod,
3859     jni_CallStaticVoidMethodV,
3860     jni_CallStaticVoidMethodA,
3861 
3862     jni_GetStaticFieldID,
3863 
3864     jni_GetStaticObjectField,
3865     jni_GetStaticBooleanField,
3866     jni_GetStaticByteField,
3867     jni_GetStaticCharField,
3868     jni_GetStaticShortField,
3869     jni_GetStaticIntField,
3870     jni_GetStaticLongField,
3871     jni_GetStaticFloatField,
3872     jni_GetStaticDoubleField,
3873 
3874     jni_SetStaticObjectField,
3875     jni_SetStaticBooleanField,
3876     jni_SetStaticByteField,
3877     jni_SetStaticCharField,
3878     jni_SetStaticShortField,
3879     jni_SetStaticIntField,
3880     jni_SetStaticLongField,
3881     jni_SetStaticFloatField,
3882     jni_SetStaticDoubleField,
3883 
3884     jni_NewString,
3885     jni_GetStringLength,
3886     jni_GetStringChars,
3887     jni_ReleaseStringChars,
3888 
3889     jni_NewStringUTF,
3890     jni_GetStringUTFLength,
3891     jni_GetStringUTFChars,
3892     jni_ReleaseStringUTFChars,
3893 
3894     jni_GetArrayLength,
3895 
3896     jni_NewObjectArray,
3897     jni_GetObjectArrayElement,
3898     jni_SetObjectArrayElement,
3899 
3900     jni_NewBooleanArray,
3901     jni_NewByteArray,
3902     jni_NewCharArray,
3903     jni_NewShortArray,
3904     jni_NewIntArray,
3905     jni_NewLongArray,
3906     jni_NewFloatArray,
3907     jni_NewDoubleArray,
3908 
3909     jni_GetBooleanArrayElements,
3910     jni_GetByteArrayElements,
3911     jni_GetCharArrayElements,
3912     jni_GetShortArrayElements,
3913     jni_GetIntArrayElements,
3914     jni_GetLongArrayElements,
3915     jni_GetFloatArrayElements,
3916     jni_GetDoubleArrayElements,
3917 
3918     jni_ReleaseBooleanArrayElements,
3919     jni_ReleaseByteArrayElements,
3920     jni_ReleaseCharArrayElements,
3921     jni_ReleaseShortArrayElements,
3922     jni_ReleaseIntArrayElements,
3923     jni_ReleaseLongArrayElements,
3924     jni_ReleaseFloatArrayElements,
3925     jni_ReleaseDoubleArrayElements,
3926 
3927     jni_GetBooleanArrayRegion,
3928     jni_GetByteArrayRegion,
3929     jni_GetCharArrayRegion,
3930     jni_GetShortArrayRegion,
3931     jni_GetIntArrayRegion,
3932     jni_GetLongArrayRegion,
3933     jni_GetFloatArrayRegion,
3934     jni_GetDoubleArrayRegion,
3935 
3936     jni_SetBooleanArrayRegion,
3937     jni_SetByteArrayRegion,
3938     jni_SetCharArrayRegion,
3939     jni_SetShortArrayRegion,
3940     jni_SetIntArrayRegion,
3941     jni_SetLongArrayRegion,
3942     jni_SetFloatArrayRegion,
3943     jni_SetDoubleArrayRegion,
3944 
3945     jni_RegisterNatives,
3946     jni_UnregisterNatives,
3947 
3948     jni_MonitorEnter,
3949     jni_MonitorExit,
3950 
3951     jni_GetJavaVM,
3952 
3953     jni_GetStringRegion,
3954     jni_GetStringUTFRegion,
3955 
3956     jni_GetPrimitiveArrayCritical,
3957     jni_ReleasePrimitiveArrayCritical,
3958 
3959     jni_GetStringCritical,
3960     jni_ReleaseStringCritical,
3961 
3962     jni_NewWeakGlobalRef,
3963     jni_DeleteWeakGlobalRef,
3964 
3965     jni_ExceptionCheck,
3966 
3967     jni_NewDirectByteBuffer,
3968     jni_GetDirectBufferAddress,
3969     jni_GetDirectBufferCapacity,
3970 
3971     // New 1_6 features
3972 
3973     jni_GetObjectRefType,
3974 
3975     // Module features
3976 
3977     jni_GetModule,
3978 
3979     // Flattened arrays features
3980 
3981     jni_GetFlattenedArrayElements,
3982     jni_ReleaseFlattenedArrayElements,
3983     jni_GetFlattenedArrayElementClass,
3984     jni_GetFlattenedArrayElementSize,
3985     jni_GetFieldOffsetInFlattenedLayout,
3986 
3987     jni_CreateSubElementSelector,
3988     jni_GetSubElementSelector,
3989     jni_GetObjectSubElement,
3990     jni_SetObjectSubElement,
3991 
3992     jni_GetBooleanSubElement,
3993     jni_GetByteSubElement,
3994     jni_GetShortSubElement,
3995     jni_GetCharSubElement,
3996     jni_GetIntSubElement,
3997     jni_GetLongSubElement,
3998     jni_GetFloatSubElement,
3999     jni_GetDoubleSubElement,
4000 
4001     jni_SetBooleanSubElement,
4002     jni_SetByteSubElement,
4003     jni_SetShortSubElement,
4004     jni_SetCharSubElement,
4005     jni_SetIntSubElement,
4006     jni_SetLongSubElement,
4007     jni_SetFloatSubElement,
4008     jni_SetDoubleSubElement
4009 };
4010 
4011 
4012 // For jvmti use to modify jni function table.
4013 // Java threads in native contiues to run until it is transitioned
4014 // to VM at safepoint. Before the transition or before it is blocked
4015 // for safepoint it may access jni function table. VM could crash if
4016 // any java thread access the jni function table in the middle of memcpy.
4017 // To avoid this each function pointers are copied automically.
4018 void copy_jni_function_table(const struct JNINativeInterface_ *new_jni_NativeInterface) {
4019   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
4020   intptr_t *a = (intptr_t *) jni_functions();
4021   intptr_t *b = (intptr_t *) new_jni_NativeInterface;
4022   for (uint i=0; i &lt;  sizeof(struct JNINativeInterface_)/sizeof(void *); i++) {
4023     Atomic::store(a++, *b++);
4024   }
4025 }
4026 
4027 void quicken_jni_functions() {
4028   // Replace Get&lt;Primitive&gt;Field with fast versions
4029   if (UseFastJNIAccessors &amp;&amp; !VerifyJNIFields &amp;&amp; !CountJNICalls &amp;&amp; !CheckJNICalls) {
4030     address func;
4031     func = JNI_FastGetField::generate_fast_get_boolean_field();
4032     if (func != (address)-1) {
4033       jni_NativeInterface.GetBooleanField = (GetBooleanField_t)func;
4034     }
4035     func = JNI_FastGetField::generate_fast_get_byte_field();
4036     if (func != (address)-1) {
4037       jni_NativeInterface.GetByteField = (GetByteField_t)func;
4038     }
4039     func = JNI_FastGetField::generate_fast_get_char_field();
4040     if (func != (address)-1) {
4041       jni_NativeInterface.GetCharField = (GetCharField_t)func;
4042     }
4043     func = JNI_FastGetField::generate_fast_get_short_field();
4044     if (func != (address)-1) {
4045       jni_NativeInterface.GetShortField = (GetShortField_t)func;
4046     }
4047     func = JNI_FastGetField::generate_fast_get_int_field();
4048     if (func != (address)-1) {
4049       jni_NativeInterface.GetIntField = (GetIntField_t)func;
4050     }
4051     func = JNI_FastGetField::generate_fast_get_long_field();
4052     if (func != (address)-1) {
4053       jni_NativeInterface.GetLongField = (GetLongField_t)func;
4054     }
4055     func = JNI_FastGetField::generate_fast_get_float_field();
4056     if (func != (address)-1) {
4057       jni_NativeInterface.GetFloatField = (GetFloatField_t)func;
4058     }
4059     func = JNI_FastGetField::generate_fast_get_double_field();
4060     if (func != (address)-1) {
4061       jni_NativeInterface.GetDoubleField = (GetDoubleField_t)func;
4062     }
4063   }
4064 }
4065 
4066 // Returns the function structure
4067 struct JNINativeInterface_* jni_functions() {
4068 #if INCLUDE_JNI_CHECK
4069   if (CheckJNICalls) return jni_functions_check();
4070 #endif // INCLUDE_JNI_CHECK
4071   return &amp;jni_NativeInterface;
4072 }
4073 
4074 // Returns the function structure
4075 struct JNINativeInterface_* jni_functions_nocheck() {
4076   return &amp;jni_NativeInterface;
4077 }
4078 
4079 static void post_thread_start_event(const JavaThread* jt) {
4080   assert(jt != NULL, &quot;invariant&quot;);
4081   EventThreadStart event;
4082   if (event.should_commit()) {
4083     event.set_thread(JFR_THREAD_ID(jt));
4084     event.set_parentThread((traceid)0);
4085 #if INCLUDE_JFR
4086     if (EventThreadStart::is_stacktrace_enabled()) {
4087       jt-&gt;jfr_thread_local()-&gt;set_cached_stack_trace_id((traceid)0);
4088       event.commit();
4089       jt-&gt;jfr_thread_local()-&gt;clear_cached_stack_trace();
4090     } else
4091 #endif
4092     {
4093       event.commit();
4094     }
4095   }
4096 }
4097 
4098 // Invocation API
4099 
4100 
4101 // Forward declaration
4102 extern const struct JNIInvokeInterface_ jni_InvokeInterface;
4103 
4104 // Global invocation API vars
4105 volatile int vm_created = 0;
4106 // Indicate whether it is safe to recreate VM
4107 volatile int safe_to_recreate_vm = 1;
4108 struct JavaVM_ main_vm = {&amp;jni_InvokeInterface};
4109 
4110 
4111 #define JAVASTACKSIZE (400 * 1024)    /* Default size of a thread java stack */
4112 enum { VERIFY_NONE, VERIFY_REMOTE, VERIFY_ALL };
4113 
4114 DT_RETURN_MARK_DECL(GetDefaultJavaVMInitArgs, jint
4115                     , HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_RETURN(_ret_ref));
4116 
4117 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args_) {
4118   HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_ENTRY(args_);
4119   JDK1_1InitArgs *args = (JDK1_1InitArgs *)args_;
4120   jint ret = JNI_ERR;
4121   DT_RETURN_MARK(GetDefaultJavaVMInitArgs, jint, (const jint&amp;)ret);
4122 
4123   if (Threads::is_supported_jni_version(args-&gt;version)) {
4124     ret = JNI_OK;
4125   }
4126   // 1.1 style no longer supported in hotspot.
4127   // According the JNI spec, we should update args-&gt;version on return.
4128   // We also use the structure to communicate with launcher about default
4129   // stack size.
4130   if (args-&gt;version == JNI_VERSION_1_1) {
4131     args-&gt;version = JNI_VERSION_1_2;
4132     // javaStackSize is int in arguments structure
4133     assert(jlong(ThreadStackSize) * K &lt; INT_MAX, &quot;integer overflow&quot;);
4134     args-&gt;javaStackSize = (jint)(ThreadStackSize * K);
4135   }
4136   return ret;
4137 }
4138 
4139 DT_RETURN_MARK_DECL(CreateJavaVM, jint
4140                     , HOTSPOT_JNI_CREATEJAVAVM_RETURN(_ret_ref));
4141 
4142 static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) {
4143   HOTSPOT_JNI_CREATEJAVAVM_ENTRY((void **) vm, penv, args);
4144 
4145   jint result = JNI_ERR;
4146   DT_RETURN_MARK(CreateJavaVM, jint, (const jint&amp;)result);
4147 
4148   // We&#39;re about to use Atomic::xchg for synchronization.  Some Zero
4149   // platforms use the GCC builtin __sync_lock_test_and_set for this,
4150   // but __sync_lock_test_and_set is not guaranteed to do what we want
4151   // on all architectures.  So we check it works before relying on it.
4152 #if defined(ZERO) &amp;&amp; defined(ASSERT)
4153   {
4154     jint a = 0xcafebabe;
4155     jint b = Atomic::xchg(&amp;a, (jint) 0xdeadbeef);
4156     void *c = &amp;a;
4157     void *d = Atomic::xchg(&amp;c, &amp;b);
4158     assert(a == (jint) 0xdeadbeef &amp;&amp; b == (jint) 0xcafebabe, &quot;Atomic::xchg() works&quot;);
4159     assert(c == &amp;b &amp;&amp; d == &amp;a, &quot;Atomic::xchg() works&quot;);
4160   }
4161 #endif // ZERO &amp;&amp; ASSERT
4162 
4163   // At the moment it&#39;s only possible to have one Java VM,
4164   // since some of the runtime state is in global variables.
4165 
4166   // We cannot use our mutex locks here, since they only work on
4167   // Threads. We do an atomic compare and exchange to ensure only
4168   // one thread can call this method at a time
4169 
4170   // We use Atomic::xchg rather than Atomic::add/dec since on some platforms
4171   // the add/dec implementations are dependent on whether we are running
4172   // on a multiprocessor Atomic::xchg does not have this problem.
4173   if (Atomic::xchg(&amp;vm_created, 1) == 1) {
4174     return JNI_EEXIST;   // already created, or create attempt in progress
4175   }
4176   if (Atomic::xchg(&amp;safe_to_recreate_vm, 0) == 0) {
4177     return JNI_ERR;  // someone tried and failed and retry not allowed.
4178   }
4179 
4180   assert(vm_created == 1, &quot;vm_created is true during the creation&quot;);
4181 
4182   /**
4183    * Certain errors during initialization are recoverable and do not
4184    * prevent this method from being called again at a later time
4185    * (perhaps with different arguments).  However, at a certain
4186    * point during initialization if an error occurs we cannot allow
4187    * this function to be called again (or it will crash).  In those
4188    * situations, the &#39;canTryAgain&#39; flag is set to false, which atomically
4189    * sets safe_to_recreate_vm to 1, such that any new call to
4190    * JNI_CreateJavaVM will immediately fail using the above logic.
4191    */
4192   bool can_try_again = true;
4193 
4194   result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again);
4195   if (result == JNI_OK) {
4196     JavaThread *thread = JavaThread::current();
4197     assert(!thread-&gt;has_pending_exception(), &quot;should have returned not OK&quot;);
4198     /* thread is thread_in_vm here */
4199     *vm = (JavaVM *)(&amp;main_vm);
4200     *(JNIEnv**)penv = thread-&gt;jni_environment();
4201 
4202 #if INCLUDE_JVMCI
4203     if (EnableJVMCI) {
4204       if (UseJVMCICompiler) {
4205         // JVMCI is initialized on a CompilerThread
4206         if (BootstrapJVMCI) {
4207           JavaThread* THREAD = thread;
4208           JVMCICompiler* compiler = JVMCICompiler::instance(true, CATCH);
4209           compiler-&gt;bootstrap(THREAD);
4210           if (HAS_PENDING_EXCEPTION) {
4211             HandleMark hm;
4212             vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
4213           }
4214         }
4215       }
4216     }
4217 #endif
4218 
4219     // Notify JVMTI
4220     if (JvmtiExport::should_post_thread_life()) {
4221        JvmtiExport::post_thread_start(thread);
4222     }
4223 
4224     post_thread_start_event(thread);
4225 
4226 #ifndef PRODUCT
4227     if (ReplayCompiles) ciReplay::replay(thread);
4228 
4229     // Some platforms (like Win*) need a wrapper around these test
4230     // functions in order to properly handle error conditions.
4231     VMError::test_error_handler();
4232 #endif
4233 
4234     // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
4235     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4236   } else {
4237     // If create_vm exits because of a pending exception, exit with that
4238     // exception.  In the future when we figure out how to reclaim memory,
4239     // we may be able to exit with JNI_ERR and allow the calling application
4240     // to continue.
4241     if (Universe::is_fully_initialized()) {
4242       // otherwise no pending exception possible - VM will already have aborted
4243       JavaThread* THREAD = JavaThread::current();
4244       if (HAS_PENDING_EXCEPTION) {
4245         HandleMark hm;
4246         vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
4247       }
4248     }
4249 
4250     if (can_try_again) {
4251       // reset safe_to_recreate_vm to 1 so that retrial would be possible
4252       safe_to_recreate_vm = 1;
4253     }
4254 
4255     // Creation failed. We must reset vm_created
4256     *vm = 0;
4257     *(JNIEnv**)penv = 0;
4258     // reset vm_created last to avoid race condition. Use OrderAccess to
4259     // control both compiler and architectural-based reordering.
4260     Atomic::release_store(&amp;vm_created, 0);
4261   }
4262 
4263   // Flush stdout and stderr before exit.
4264   fflush(stdout);
4265   fflush(stderr);
4266 
4267   return result;
4268 
4269 }
4270 
4271 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) {
4272   jint result = JNI_ERR;
4273   // On Windows, let CreateJavaVM run with SEH protection
4274 #ifdef _WIN32
4275   __try {
4276 #endif
4277     result = JNI_CreateJavaVM_inner(vm, penv, args);
4278 #ifdef _WIN32
4279   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
4280     // Nothing to do.
4281   }
4282 #endif
4283   return result;
4284 }
4285 
4286 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetCreatedJavaVMs(JavaVM **vm_buf, jsize bufLen, jsize *numVMs) {
4287   // See bug 4367188, the wrapper can sometimes cause VM crashes
4288   // JNIWrapper(&quot;GetCreatedJavaVMs&quot;);
4289 
4290   HOTSPOT_JNI_GETCREATEDJAVAVMS_ENTRY((void **) vm_buf, bufLen, (uintptr_t *) numVMs);
4291 
4292   if (vm_created == 1) {
4293     if (numVMs != NULL) *numVMs = 1;
4294     if (bufLen &gt; 0)     *vm_buf = (JavaVM *)(&amp;main_vm);
4295   } else {
4296     if (numVMs != NULL) *numVMs = 0;
4297   }
4298   HOTSPOT_JNI_GETCREATEDJAVAVMS_RETURN(JNI_OK);
4299   return JNI_OK;
4300 }
4301 
4302 extern &quot;C&quot; {
4303 
4304 DT_RETURN_MARK_DECL(DestroyJavaVM, jint
4305                     , HOTSPOT_JNI_DESTROYJAVAVM_RETURN(_ret_ref));
4306 
4307 static jint JNICALL jni_DestroyJavaVM_inner(JavaVM *vm) {
4308   HOTSPOT_JNI_DESTROYJAVAVM_ENTRY(vm);
4309   jint res = JNI_ERR;
4310   DT_RETURN_MARK(DestroyJavaVM, jint, (const jint&amp;)res);
4311 
4312   if (vm_created == 0) {
4313     res = JNI_ERR;
4314     return res;
4315   }
4316 
4317   JNIWrapper(&quot;DestroyJavaVM&quot;);
4318   JNIEnv *env;
4319   JavaVMAttachArgs destroyargs;
4320   destroyargs.version = CurrentVersion;
4321   destroyargs.name = (char *)&quot;DestroyJavaVM&quot;;
4322   destroyargs.group = NULL;
4323   res = vm-&gt;AttachCurrentThread((void **)&amp;env, (void *)&amp;destroyargs);
4324   if (res != JNI_OK) {
4325     return res;
4326   }
4327 
4328   // Since this is not a JVM_ENTRY we have to set the thread state manually before entering.
4329   JavaThread* thread = JavaThread::current();
4330   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4331   if (Threads::destroy_vm()) {
4332     // Should not change thread state, VM is gone
4333     vm_created = 0;
4334     res = JNI_OK;
4335     return res;
4336   } else {
4337     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4338     res = JNI_ERR;
4339     return res;
4340   }
4341 }
4342 
4343 jint JNICALL jni_DestroyJavaVM(JavaVM *vm) {
4344   jint result = JNI_ERR;
4345   // On Windows, we need SEH protection
4346 #ifdef _WIN32
4347   __try {
4348 #endif
4349     result = jni_DestroyJavaVM_inner(vm);
4350 #ifdef _WIN32
4351   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
4352     // Nothing to do.
4353   }
4354 #endif
4355   return result;
4356 }
4357 
4358 static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool daemon) {
4359   JavaVMAttachArgs *args = (JavaVMAttachArgs *) _args;
4360 
4361   // Check below commented out from JDK1.2fcs as well
4362   /*
4363   if (args &amp;&amp; (args-&gt;version != JNI_VERSION_1_1 || args-&gt;version != JNI_VERSION_1_2)) {
4364     return JNI_EVERSION;
4365   }
4366   */
4367 
4368   Thread* t = Thread::current_or_null();
4369   if (t != NULL) {
4370     // If the thread has been attached this operation is a no-op
4371     *(JNIEnv**)penv = ((JavaThread*) t)-&gt;jni_environment();
4372     return JNI_OK;
4373   }
4374 
4375   // Create a thread and mark it as attaching so it will be skipped by the
4376   // ThreadsListEnumerator - see CR 6404306
4377   JavaThread* thread = new JavaThread(true);
4378 
4379   // Set correct safepoint info. The thread is going to call into Java when
4380   // initializing the Java level thread object. Hence, the correct state must
4381   // be set in order for the Safepoint code to deal with it correctly.
4382   thread-&gt;set_thread_state(_thread_in_vm);
4383   thread-&gt;record_stack_base_and_size();
4384   thread-&gt;register_thread_stack_with_NMT();
4385   thread-&gt;initialize_thread_current();
4386 
4387   if (!os::create_attached_thread(thread)) {
4388     thread-&gt;smr_delete();
4389     return JNI_ERR;
4390   }
4391   // Enable stack overflow checks
4392   thread-&gt;create_stack_guard_pages();
4393 
4394   thread-&gt;initialize_tlab();
4395 
4396   thread-&gt;cache_global_variables();
4397 
4398   // This thread will not do a safepoint check, since it has
4399   // not been added to the Thread list yet.
4400   { MutexLocker ml(Threads_lock);
4401     // This must be inside this lock in order to get FullGCALot to work properly, i.e., to
4402     // avoid this thread trying to do a GC before it is added to the thread-list
4403     thread-&gt;set_active_handles(JNIHandleBlock::allocate_block());
4404     Threads::add(thread, daemon);
4405   }
4406   // Create thread group and name info from attach arguments
4407   oop group = NULL;
4408   char* thread_name = NULL;
4409   if (args != NULL &amp;&amp; Threads::is_supported_jni_version(args-&gt;version)) {
4410     group = JNIHandles::resolve(args-&gt;group);
4411     thread_name = args-&gt;name; // may be NULL
4412   }
4413   if (group == NULL) group = Universe::main_thread_group();
4414 
4415   // Create Java level thread object and attach it to this thread
4416   bool attach_failed = false;
4417   {
4418     EXCEPTION_MARK;
4419     HandleMark hm(THREAD);
4420     Handle thread_group(THREAD, group);
4421     thread-&gt;allocate_threadObj(thread_group, thread_name, daemon, THREAD);
4422     if (HAS_PENDING_EXCEPTION) {
4423       CLEAR_PENDING_EXCEPTION;
4424       // cleanup outside the handle mark.
4425       attach_failed = true;
4426     }
4427   }
4428 
4429   if (attach_failed) {
4430     // Added missing cleanup
4431     thread-&gt;cleanup_failed_attach_current_thread(daemon);
4432     return JNI_ERR;
4433   }
4434 
4435   // mark the thread as no longer attaching
4436   // this uses a fence to push the change through so we don&#39;t have
4437   // to regrab the threads_lock
4438   thread-&gt;set_done_attaching_via_jni();
4439 
4440   // Set java thread status.
4441   java_lang_Thread::set_thread_status(thread-&gt;threadObj(),
4442               java_lang_Thread::RUNNABLE);
4443 
4444   // Notify the debugger
4445   if (JvmtiExport::should_post_thread_life()) {
4446     JvmtiExport::post_thread_start(thread);
4447   }
4448 
4449   post_thread_start_event(thread);
4450 
4451   *(JNIEnv**)penv = thread-&gt;jni_environment();
4452 
4453   // Now leaving the VM, so change thread_state. This is normally automatically taken care
4454   // of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by
4455   // using ThreadStateTransition::transition, we do a callback to the safepoint code if
4456   // needed.
4457 
4458   ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4459 
4460   // Perform any platform dependent FPU setup
4461   os::setup_fpu();
4462 
4463   return JNI_OK;
4464 }
4465 
4466 
4467 jint JNICALL jni_AttachCurrentThread(JavaVM *vm, void **penv, void *_args) {
4468   HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(vm, penv, _args);
4469   if (vm_created == 0) {
4470   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4471     return JNI_ERR;
4472   }
4473 
4474   JNIWrapper(&quot;AttachCurrentThread&quot;);
4475   jint ret = attach_current_thread(vm, penv, _args, false);
4476   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(ret);
4477   return ret;
4478 }
4479 
4480 
4481 jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
4482   HOTSPOT_JNI_DETACHCURRENTTHREAD_ENTRY(vm);
4483 
4484   JNIWrapper(&quot;DetachCurrentThread&quot;);
4485 
4486   // If the thread has already been detached the operation is a no-op
4487   if (Thread::current_or_null() == NULL) {
4488     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4489     return JNI_OK;
4490   }
4491 
4492   VM_Exit::block_if_vm_exited();
4493 
4494   JavaThread* thread = JavaThread::current();
4495   if (thread-&gt;has_last_Java_frame()) {
4496     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4497     // Can&#39;t detach a thread that&#39;s running java, that can&#39;t work.
4498     return JNI_ERR;
4499   }
4500 
4501   // Safepoint support. Have to do call-back to safepoint code, if in the
4502   // middle of a safepoint operation
4503   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4504 
4505   // XXX: Note that JavaThread::exit() call below removes the guards on the
4506   // stack pages set up via enable_stack_{red,yellow}_zone() calls
4507   // above in jni_AttachCurrentThread. Unfortunately, while the setting
4508   // of the guards is visible in jni_AttachCurrentThread above,
4509   // the removal of the guards is buried below in JavaThread::exit()
4510   // here. The abstraction should be more symmetrically either exposed
4511   // or hidden (e.g. it could probably be hidden in the same
4512   // (platform-dependent) methods where we do alternate stack
4513   // maintenance work?)
4514   thread-&gt;exit(false, JavaThread::jni_detach);
4515   thread-&gt;smr_delete();
4516 
4517   HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4518   return JNI_OK;
4519 }
4520 
4521 DT_RETURN_MARK_DECL(GetEnv, jint
4522                     , HOTSPOT_JNI_GETENV_RETURN(_ret_ref));
4523 
4524 jint JNICALL jni_GetEnv(JavaVM *vm, void **penv, jint version) {
4525   HOTSPOT_JNI_GETENV_ENTRY(vm, penv, version);
4526   jint ret = JNI_ERR;
4527   DT_RETURN_MARK(GetEnv, jint, (const jint&amp;)ret);
4528 
4529   if (vm_created == 0) {
4530     *penv = NULL;
4531     ret = JNI_EDETACHED;
4532     return ret;
4533   }
4534 
4535   if (JniExportedInterface::GetExportedInterface(vm, penv, version, &amp;ret)) {
4536     return ret;
4537   }
4538 
4539 #ifndef JVMPI_VERSION_1
4540 // need these in order to be polite about older agents
4541 #define JVMPI_VERSION_1   ((jint)0x10000001)
4542 #define JVMPI_VERSION_1_1 ((jint)0x10000002)
4543 #define JVMPI_VERSION_1_2 ((jint)0x10000003)
4544 #endif // !JVMPI_VERSION_1
4545 
4546   Thread* thread = Thread::current_or_null();
4547   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread()) {
4548     if (Threads::is_supported_jni_version_including_1_1(version)) {
4549       *(JNIEnv**)penv = ((JavaThread*) thread)-&gt;jni_environment();
4550       ret = JNI_OK;
4551       return ret;
4552 
4553     } else if (version == JVMPI_VERSION_1 ||
4554                version == JVMPI_VERSION_1_1 ||
4555                version == JVMPI_VERSION_1_2) {
4556       tty-&gt;print_cr(&quot;ERROR: JVMPI, an experimental interface, is no longer supported.&quot;);
4557       tty-&gt;print_cr(&quot;Please use the supported interface: the JVM Tool Interface (JVM TI).&quot;);
4558       ret = JNI_EVERSION;
4559       return ret;
4560     } else if (JvmtiExport::is_jvmdi_version(version)) {
4561       tty-&gt;print_cr(&quot;FATAL ERROR: JVMDI is no longer supported.&quot;);
4562       tty-&gt;print_cr(&quot;Please use the supported interface: the JVM Tool Interface (JVM TI).&quot;);
4563       ret = JNI_EVERSION;
4564       return ret;
4565     } else {
4566       *penv = NULL;
4567       ret = JNI_EVERSION;
4568       return ret;
4569     }
4570   } else {
4571     *penv = NULL;
4572     ret = JNI_EDETACHED;
4573     return ret;
4574   }
4575 }
4576 
4577 
4578 jint JNICALL jni_AttachCurrentThreadAsDaemon(JavaVM *vm, void **penv, void *_args) {
4579   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_ENTRY(vm, penv, _args);
4580   if (vm_created == 0) {
4581   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN((uint32_t) JNI_ERR);
4582     return JNI_ERR;
4583   }
4584 
4585   JNIWrapper(&quot;AttachCurrentThreadAsDaemon&quot;);
4586   jint ret = attach_current_thread(vm, penv, _args, true);
4587   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN(ret);
4588   return ret;
4589 }
4590 
4591 
4592 } // End extern &quot;C&quot;
4593 
4594 const struct JNIInvokeInterface_ jni_InvokeInterface = {
4595     NULL,
4596     NULL,
4597     NULL,
4598 
4599     jni_DestroyJavaVM,
4600     jni_AttachCurrentThread,
4601     jni_DetachCurrentThread,
4602     jni_GetEnv,
4603     jni_AttachCurrentThreadAsDaemon
4604 };
    </pre>
  </body>
</html>
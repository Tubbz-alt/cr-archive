<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvmtiRedefineClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/metadataOnStackMark.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/systemDictionary.hpp&quot;
  33 #include &quot;classfile/verifier.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;compiler/compileBroker.hpp&quot;
  36 #include &quot;interpreter/oopMapCache.hpp&quot;
  37 #include &quot;interpreter/rewriter.hpp&quot;
  38 #include &quot;jfr/jfrEvents.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/metadataFactory.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/annotations.hpp&quot;
  45 #include &quot;oops/constantPool.hpp&quot;
  46 #include &quot;oops/fieldStreams.inline.hpp&quot;
  47 #include &quot;oops/klassVtable.hpp&quot;
  48 #include &quot;oops/oop.inline.hpp&quot;
  49 #include &quot;oops/recordComponent.hpp&quot;
  50 #include &quot;prims/jvmtiImpl.hpp&quot;
  51 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  52 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
  53 #include &quot;prims/resolvedMethodTable.hpp&quot;
  54 #include &quot;prims/methodComparator.hpp&quot;
  55 #include &quot;runtime/atomic.hpp&quot;
  56 #include &quot;runtime/deoptimization.hpp&quot;
  57 #include &quot;runtime/handles.inline.hpp&quot;
  58 #include &quot;runtime/jniHandles.inline.hpp&quot;
  59 #include &quot;runtime/relocator.hpp&quot;
  60 #include &quot;runtime/safepointVerifiers.hpp&quot;
  61 #include &quot;utilities/bitMap.inline.hpp&quot;
  62 #include &quot;utilities/events.hpp&quot;
  63 
  64 Array&lt;Method*&gt;* VM_RedefineClasses::_old_methods = NULL;
  65 Array&lt;Method*&gt;* VM_RedefineClasses::_new_methods = NULL;
  66 Method**  VM_RedefineClasses::_matching_old_methods = NULL;
  67 Method**  VM_RedefineClasses::_matching_new_methods = NULL;
  68 Method**  VM_RedefineClasses::_deleted_methods      = NULL;
  69 Method**  VM_RedefineClasses::_added_methods        = NULL;
  70 int       VM_RedefineClasses::_matching_methods_length = 0;
  71 int       VM_RedefineClasses::_deleted_methods_length  = 0;
  72 int       VM_RedefineClasses::_added_methods_length    = 0;
  73 bool      VM_RedefineClasses::_has_redefined_Object = false;
  74 bool      VM_RedefineClasses::_has_null_class_loader = false;
  75 u8        VM_RedefineClasses::_id_counter = 0;
  76 
  77 VM_RedefineClasses::VM_RedefineClasses(jint class_count,
  78                                        const jvmtiClassDefinition *class_defs,
  79                                        JvmtiClassLoadKind class_load_kind) {
  80   _class_count = class_count;
  81   _class_defs = class_defs;
  82   _class_load_kind = class_load_kind;
  83   _any_class_has_resolved_methods = false;
  84   _res = JVMTI_ERROR_NONE;
  85   _the_class = NULL;
  86   _has_redefined_Object = false;
  87   _has_null_class_loader = false;
  88   _id = next_id();
  89 }
  90 
  91 static inline InstanceKlass* get_ik(jclass def) {
  92   oop mirror = JNIHandles::resolve_non_null(def);
  93   return InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
  94 }
  95 
  96 // If any of the classes are being redefined, wait
  97 // Parallel constant pool merging leads to indeterminate constant pools.
  98 void VM_RedefineClasses::lock_classes() {
  99   MonitorLocker ml(RedefineClasses_lock);
 100   bool has_redefined;
 101   do {
 102     has_redefined = false;
 103     // Go through classes each time until none are being redefined.
 104     for (int i = 0; i &lt; _class_count; i++) {
 105       if (get_ik(_class_defs[i].klass)-&gt;is_being_redefined()) {
 106         ml.wait();
 107         has_redefined = true;
 108         break;  // for loop
 109       }
 110     }
 111   } while (has_redefined);
 112   for (int i = 0; i &lt; _class_count; i++) {
 113     get_ik(_class_defs[i].klass)-&gt;set_is_being_redefined(true);
 114   }
 115   ml.notify_all();
 116 }
 117 
 118 void VM_RedefineClasses::unlock_classes() {
 119   MonitorLocker ml(RedefineClasses_lock);
 120   for (int i = 0; i &lt; _class_count; i++) {
 121     assert(get_ik(_class_defs[i].klass)-&gt;is_being_redefined(),
 122            &quot;should be being redefined to get here&quot;);
 123     get_ik(_class_defs[i].klass)-&gt;set_is_being_redefined(false);
 124   }
 125   ml.notify_all();
 126 }
 127 
 128 bool VM_RedefineClasses::doit_prologue() {
 129   if (_class_count == 0) {
 130     _res = JVMTI_ERROR_NONE;
 131     return false;
 132   }
 133   if (_class_defs == NULL) {
 134     _res = JVMTI_ERROR_NULL_POINTER;
 135     return false;
 136   }
 137 
 138   for (int i = 0; i &lt; _class_count; i++) {
 139     if (_class_defs[i].klass == NULL) {
 140       _res = JVMTI_ERROR_INVALID_CLASS;
 141       return false;
 142     }
 143     if (_class_defs[i].class_byte_count == 0) {
 144       _res = JVMTI_ERROR_INVALID_CLASS_FORMAT;
 145       return false;
 146     }
 147     if (_class_defs[i].class_bytes == NULL) {
 148       _res = JVMTI_ERROR_NULL_POINTER;
 149       return false;
 150     }
 151 
 152     oop mirror = JNIHandles::resolve_non_null(_class_defs[i].klass);
 153     // classes for primitives and arrays and vm unsafe anonymous classes cannot be redefined
 154     // check here so following code can assume these classes are InstanceKlass
 155     if (!is_modifiable_class(mirror)) {
 156       _res = JVMTI_ERROR_UNMODIFIABLE_CLASS;
 157       return false;
 158     }
 159   }
 160 
 161   // Start timer after all the sanity checks; not quite accurate, but
 162   // better than adding a bunch of stop() calls.
 163   if (log_is_enabled(Info, redefine, class, timer)) {
 164     _timer_vm_op_prologue.start();
 165   }
 166 
 167   lock_classes();
 168   // We first load new class versions in the prologue, because somewhere down the
 169   // call chain it is required that the current thread is a Java thread.
 170   _res = load_new_class_versions(Thread::current());
 171   if (_res != JVMTI_ERROR_NONE) {
 172     // free any successfully created classes, since none are redefined
 173     for (int i = 0; i &lt; _class_count; i++) {
 174       if (_scratch_classes[i] != NULL) {
 175         ClassLoaderData* cld = _scratch_classes[i]-&gt;class_loader_data();
 176         // Free the memory for this class at class unloading time.  Not before
 177         // because CMS might think this is still live.
 178         InstanceKlass* ik = get_ik(_class_defs[i].klass);
 179         if (ik-&gt;get_cached_class_file() == _scratch_classes[i]-&gt;get_cached_class_file()) {
 180           // Don&#39;t double-free cached_class_file copied from the original class if error.
 181           _scratch_classes[i]-&gt;set_cached_class_file(NULL);
 182         }
 183         cld-&gt;add_to_deallocate_list(InstanceKlass::cast(_scratch_classes[i]));
 184       }
 185     }
 186     // Free os::malloc allocated memory in load_new_class_version.
 187     os::free(_scratch_classes);
 188     _timer_vm_op_prologue.stop();
 189     unlock_classes();
 190     return false;
 191   }
 192 
 193   _timer_vm_op_prologue.stop();
 194   return true;
 195 }
 196 
 197 void VM_RedefineClasses::doit() {
 198   Thread *thread = Thread::current();
 199 
 200 #if INCLUDE_CDS
 201   if (UseSharedSpaces) {
 202     // Sharing is enabled so we remap the shared readonly space to
 203     // shared readwrite, private just in case we need to redefine
 204     // a shared class. We do the remap during the doit() phase of
 205     // the safepoint to be safer.
 206     if (!MetaspaceShared::remap_shared_readonly_as_readwrite()) {
 207       log_info(redefine, class, load)(&quot;failed to remap shared readonly space to readwrite, private&quot;);
 208       _res = JVMTI_ERROR_INTERNAL;
 209       return;
 210     }
 211   }
 212 #endif
 213 
 214   // Mark methods seen on stack and everywhere else so old methods are not
 215   // cleaned up if they&#39;re on the stack.
 216   MetadataOnStackMark md_on_stack(/*walk_all_metadata*/true, /*redefinition_walk*/true);
 217   HandleMark hm(thread);   // make sure any handles created are deleted
 218                            // before the stack walk again.
 219 
 220   for (int i = 0; i &lt; _class_count; i++) {
 221     redefine_single_class(_class_defs[i].klass, _scratch_classes[i], thread);
 222   }
 223 
 224   // Flush all compiled code that depends on the classes redefined.
 225   flush_dependent_code();
 226 
 227   // Adjust constantpool caches and vtables for all classes
 228   // that reference methods of the evolved classes.
 229   // Have to do this after all classes are redefined and all methods that
 230   // are redefined are marked as old.
 231   AdjustAndCleanMetadata adjust_and_clean_metadata(thread);
 232   ClassLoaderDataGraph::classes_do(&amp;adjust_and_clean_metadata);
 233 
 234   // JSR-292 support
 235   if (_any_class_has_resolved_methods) {
 236     bool trace_name_printed = false;
 237     ResolvedMethodTable::adjust_method_entries(&amp;trace_name_printed);
 238   }
 239 
 240   // Increment flag indicating that some invariants are no longer true.
 241   // See jvmtiExport.hpp for detailed explanation.
 242   JvmtiExport::increment_redefinition_count();
 243 
 244   // check_class() is optionally called for product bits, but is
 245   // always called for non-product bits.
 246 #ifdef PRODUCT
 247   if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
 248 #endif
 249     log_trace(redefine, class, obsolete, metadata)(&quot;calling check_class&quot;);
 250     CheckClass check_class(thread);
 251     ClassLoaderDataGraph::classes_do(&amp;check_class);
 252 #ifdef PRODUCT
 253   }
 254 #endif
 255 
 256   // Clean up any metadata now unreferenced while MetadataOnStackMark is set.
 257   ClassLoaderDataGraph::clean_deallocate_lists(false);
 258 }
 259 
 260 void VM_RedefineClasses::doit_epilogue() {
 261   unlock_classes();
 262 
 263   // Free os::malloc allocated memory.
 264   os::free(_scratch_classes);
 265 
 266   // Reset the_class to null for error printing.
 267   _the_class = NULL;
 268 
 269   if (log_is_enabled(Info, redefine, class, timer)) {
 270     // Used to have separate timers for &quot;doit&quot; and &quot;all&quot;, but the timer
 271     // overhead skewed the measurements.
 272     julong doit_time = _timer_rsc_phase1.milliseconds() +
 273                        _timer_rsc_phase2.milliseconds();
 274     julong all_time = _timer_vm_op_prologue.milliseconds() + doit_time;
 275 
 276     log_info(redefine, class, timer)
 277       (&quot;vm_op: all=&quot; JULONG_FORMAT &quot;  prologue=&quot; JULONG_FORMAT &quot;  doit=&quot; JULONG_FORMAT,
 278        all_time, (julong)_timer_vm_op_prologue.milliseconds(), doit_time);
 279     log_info(redefine, class, timer)
 280       (&quot;redefine_single_class: phase1=&quot; JULONG_FORMAT &quot;  phase2=&quot; JULONG_FORMAT,
 281        (julong)_timer_rsc_phase1.milliseconds(), (julong)_timer_rsc_phase2.milliseconds());
 282   }
 283 }
 284 
 285 bool VM_RedefineClasses::is_modifiable_class(oop klass_mirror) {
 286   // classes for primitives cannot be redefined
 287   if (java_lang_Class::is_primitive(klass_mirror)) {
 288     return false;
 289   }
 290   Klass* k = java_lang_Class::as_Klass(klass_mirror);
 291   // classes for arrays cannot be redefined
 292   if (k == NULL || !k-&gt;is_instance_klass()) {
 293     return false;
 294   }
 295 
 296   // Cannot redefine or retransform an unsafe anonymous class.
 297   if (InstanceKlass::cast(k)-&gt;is_unsafe_anonymous()) {
 298     return false;
 299   }
 300   return true;
 301 }
 302 
 303 // Append the current entry at scratch_i in scratch_cp to *merge_cp_p
 304 // where the end of *merge_cp_p is specified by *merge_cp_length_p. For
 305 // direct CP entries, there is just the current entry to append. For
 306 // indirect and double-indirect CP entries, there are zero or more
 307 // referenced CP entries along with the current entry to append.
 308 // Indirect and double-indirect CP entries are handled by recursive
 309 // calls to append_entry() as needed. The referenced CP entries are
 310 // always appended to *merge_cp_p before the referee CP entry. These
 311 // referenced CP entries may already exist in *merge_cp_p in which case
 312 // there is nothing extra to append and only the current entry is
 313 // appended.
 314 void VM_RedefineClasses::append_entry(const constantPoolHandle&amp; scratch_cp,
 315        int scratch_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p,
 316        TRAPS) {
 317 
 318   // append is different depending on entry tag type
 319   switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
 320 
 321     // The old verifier is implemented outside the VM. It loads classes,
 322     // but does not resolve constant pool entries directly so we never
 323     // see Class entries here with the old verifier. Similarly the old
 324     // verifier does not like Class entries in the input constant pool.
 325     // The split-verifier is implemented in the VM so it can optionally
 326     // and directly resolve constant pool entries to load classes. The
 327     // split-verifier can accept either Class entries or UnresolvedClass
 328     // entries in the input constant pool. We revert the appended copy
 329     // back to UnresolvedClass so that either verifier will be happy
 330     // with the constant pool entry.
 331     //
 332     // this is an indirect CP entry so it needs special handling
 333     case JVM_CONSTANT_Class:
 334     case JVM_CONSTANT_UnresolvedClass:
 335     {
 336       int name_i = scratch_cp-&gt;klass_name_index_at(scratch_i);
 337       int new_name_i = find_or_append_indirect_entry(scratch_cp, name_i, merge_cp_p,
 338                                                      merge_cp_length_p, THREAD);
 339 
 340       if (new_name_i != name_i) {
 341         log_trace(redefine, class, constantpool)
 342           (&quot;Class entry@%d name_index change: %d to %d&quot;,
 343            *merge_cp_length_p, name_i, new_name_i);
 344       }
 345 
 346       (*merge_cp_p)-&gt;temp_unresolved_klass_at_put(*merge_cp_length_p, new_name_i);
 347       if (scratch_i != *merge_cp_length_p) {
 348         // The new entry in *merge_cp_p is at a different index than
 349         // the new entry in scratch_cp so we need to map the index values.
 350         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 351       }
 352       (*merge_cp_length_p)++;
 353     } break;
 354 
 355     // these are direct CP entries so they can be directly appended,
 356     // but double and long take two constant pool entries
 357     case JVM_CONSTANT_Double:  // fall through
 358     case JVM_CONSTANT_Long:
 359     {
 360       ConstantPool::copy_entry_to(scratch_cp, scratch_i, *merge_cp_p, *merge_cp_length_p,
 361         THREAD);
 362 
 363       if (scratch_i != *merge_cp_length_p) {
 364         // The new entry in *merge_cp_p is at a different index than
 365         // the new entry in scratch_cp so we need to map the index values.
 366         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 367       }
 368       (*merge_cp_length_p) += 2;
 369     } break;
 370 
 371     // these are direct CP entries so they can be directly appended
 372     case JVM_CONSTANT_Float:   // fall through
 373     case JVM_CONSTANT_Integer: // fall through
 374     case JVM_CONSTANT_Utf8:    // fall through
 375 
 376     // This was an indirect CP entry, but it has been changed into
 377     // Symbol*s so this entry can be directly appended.
 378     case JVM_CONSTANT_String:      // fall through
 379     {
 380       ConstantPool::copy_entry_to(scratch_cp, scratch_i, *merge_cp_p, *merge_cp_length_p,
 381         THREAD);
 382 
 383       if (scratch_i != *merge_cp_length_p) {
 384         // The new entry in *merge_cp_p is at a different index than
 385         // the new entry in scratch_cp so we need to map the index values.
 386         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 387       }
 388       (*merge_cp_length_p)++;
 389     } break;
 390 
 391     // this is an indirect CP entry so it needs special handling
 392     case JVM_CONSTANT_NameAndType:
 393     {
 394       int name_ref_i = scratch_cp-&gt;name_ref_index_at(scratch_i);
 395       int new_name_ref_i = find_or_append_indirect_entry(scratch_cp, name_ref_i, merge_cp_p,
 396                                                          merge_cp_length_p, THREAD);
 397 
 398       int signature_ref_i = scratch_cp-&gt;signature_ref_index_at(scratch_i);
 399       int new_signature_ref_i = find_or_append_indirect_entry(scratch_cp, signature_ref_i,
 400                                                               merge_cp_p, merge_cp_length_p,
 401                                                               THREAD);
 402 
 403       // If the referenced entries already exist in *merge_cp_p, then
 404       // both new_name_ref_i and new_signature_ref_i will both be 0.
 405       // In that case, all we are appending is the current entry.
 406       if (new_name_ref_i != name_ref_i) {
 407         log_trace(redefine, class, constantpool)
 408           (&quot;NameAndType entry@%d name_ref_index change: %d to %d&quot;,
 409            *merge_cp_length_p, name_ref_i, new_name_ref_i);
 410       }
 411       if (new_signature_ref_i != signature_ref_i) {
 412         log_trace(redefine, class, constantpool)
 413           (&quot;NameAndType entry@%d signature_ref_index change: %d to %d&quot;,
 414            *merge_cp_length_p, signature_ref_i, new_signature_ref_i);
 415       }
 416 
 417       (*merge_cp_p)-&gt;name_and_type_at_put(*merge_cp_length_p,
 418         new_name_ref_i, new_signature_ref_i);
 419       if (scratch_i != *merge_cp_length_p) {
 420         // The new entry in *merge_cp_p is at a different index than
 421         // the new entry in scratch_cp so we need to map the index values.
 422         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 423       }
 424       (*merge_cp_length_p)++;
 425     } break;
 426 
 427     // this is a double-indirect CP entry so it needs special handling
 428     case JVM_CONSTANT_Fieldref:           // fall through
 429     case JVM_CONSTANT_InterfaceMethodref: // fall through
 430     case JVM_CONSTANT_Methodref:
 431     {
 432       int klass_ref_i = scratch_cp-&gt;uncached_klass_ref_index_at(scratch_i);
 433       int new_klass_ref_i = find_or_append_indirect_entry(scratch_cp, klass_ref_i,
 434                                                           merge_cp_p, merge_cp_length_p, THREAD);
 435 
 436       int name_and_type_ref_i = scratch_cp-&gt;uncached_name_and_type_ref_index_at(scratch_i);
 437       int new_name_and_type_ref_i = find_or_append_indirect_entry(scratch_cp, name_and_type_ref_i,
 438                                                           merge_cp_p, merge_cp_length_p, THREAD);
 439 
 440       const char *entry_name = NULL;
 441       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
 442       case JVM_CONSTANT_Fieldref:
 443         entry_name = &quot;Fieldref&quot;;
 444         (*merge_cp_p)-&gt;field_at_put(*merge_cp_length_p, new_klass_ref_i,
 445           new_name_and_type_ref_i);
 446         break;
 447       case JVM_CONSTANT_InterfaceMethodref:
 448         entry_name = &quot;IFMethodref&quot;;
 449         (*merge_cp_p)-&gt;interface_method_at_put(*merge_cp_length_p,
 450           new_klass_ref_i, new_name_and_type_ref_i);
 451         break;
 452       case JVM_CONSTANT_Methodref:
 453         entry_name = &quot;Methodref&quot;;
 454         (*merge_cp_p)-&gt;method_at_put(*merge_cp_length_p, new_klass_ref_i,
 455           new_name_and_type_ref_i);
 456         break;
 457       default:
 458         guarantee(false, &quot;bad switch&quot;);
 459         break;
 460       }
 461 
 462       if (klass_ref_i != new_klass_ref_i) {
 463         log_trace(redefine, class, constantpool)
 464           (&quot;%s entry@%d class_index changed: %d to %d&quot;, entry_name, *merge_cp_length_p, klass_ref_i, new_klass_ref_i);
 465       }
 466       if (name_and_type_ref_i != new_name_and_type_ref_i) {
 467         log_trace(redefine, class, constantpool)
 468           (&quot;%s entry@%d name_and_type_index changed: %d to %d&quot;,
 469            entry_name, *merge_cp_length_p, name_and_type_ref_i, new_name_and_type_ref_i);
 470       }
 471 
 472       if (scratch_i != *merge_cp_length_p) {
 473         // The new entry in *merge_cp_p is at a different index than
 474         // the new entry in scratch_cp so we need to map the index values.
 475         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 476       }
 477       (*merge_cp_length_p)++;
 478     } break;
 479 
 480     // this is an indirect CP entry so it needs special handling
 481     case JVM_CONSTANT_MethodType:
 482     {
 483       int ref_i = scratch_cp-&gt;method_type_index_at(scratch_i);
 484       int new_ref_i = find_or_append_indirect_entry(scratch_cp, ref_i, merge_cp_p,
 485                                                     merge_cp_length_p, THREAD);
 486       if (new_ref_i != ref_i) {
 487         log_trace(redefine, class, constantpool)
 488           (&quot;MethodType entry@%d ref_index change: %d to %d&quot;, *merge_cp_length_p, ref_i, new_ref_i);
 489       }
 490       (*merge_cp_p)-&gt;method_type_index_at_put(*merge_cp_length_p, new_ref_i);
 491       if (scratch_i != *merge_cp_length_p) {
 492         // The new entry in *merge_cp_p is at a different index than
 493         // the new entry in scratch_cp so we need to map the index values.
 494         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 495       }
 496       (*merge_cp_length_p)++;
 497     } break;
 498 
 499     // this is an indirect CP entry so it needs special handling
 500     case JVM_CONSTANT_MethodHandle:
 501     {
 502       int ref_kind = scratch_cp-&gt;method_handle_ref_kind_at(scratch_i);
 503       int ref_i = scratch_cp-&gt;method_handle_index_at(scratch_i);
 504       int new_ref_i = find_or_append_indirect_entry(scratch_cp, ref_i, merge_cp_p,
 505                                                     merge_cp_length_p, THREAD);
 506       if (new_ref_i != ref_i) {
 507         log_trace(redefine, class, constantpool)
 508           (&quot;MethodHandle entry@%d ref_index change: %d to %d&quot;, *merge_cp_length_p, ref_i, new_ref_i);
 509       }
 510       (*merge_cp_p)-&gt;method_handle_index_at_put(*merge_cp_length_p, ref_kind, new_ref_i);
 511       if (scratch_i != *merge_cp_length_p) {
 512         // The new entry in *merge_cp_p is at a different index than
 513         // the new entry in scratch_cp so we need to map the index values.
 514         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 515       }
 516       (*merge_cp_length_p)++;
 517     } break;
 518 
 519     // this is an indirect CP entry so it needs special handling
 520     case JVM_CONSTANT_Dynamic:  // fall through
 521     case JVM_CONSTANT_InvokeDynamic:
 522     {
 523       // Index of the bootstrap specifier in the operands array
 524       int old_bs_i = scratch_cp-&gt;bootstrap_methods_attribute_index(scratch_i);
 525       int new_bs_i = find_or_append_operand(scratch_cp, old_bs_i, merge_cp_p,
 526                                             merge_cp_length_p, THREAD);
 527       // The bootstrap method NameAndType_info index
 528       int old_ref_i = scratch_cp-&gt;bootstrap_name_and_type_ref_index_at(scratch_i);
 529       int new_ref_i = find_or_append_indirect_entry(scratch_cp, old_ref_i, merge_cp_p,
 530                                                     merge_cp_length_p, THREAD);
 531       if (new_bs_i != old_bs_i) {
 532         log_trace(redefine, class, constantpool)
 533           (&quot;Dynamic entry@%d bootstrap_method_attr_index change: %d to %d&quot;,
 534            *merge_cp_length_p, old_bs_i, new_bs_i);
 535       }
 536       if (new_ref_i != old_ref_i) {
 537         log_trace(redefine, class, constantpool)
 538           (&quot;Dynamic entry@%d name_and_type_index change: %d to %d&quot;, *merge_cp_length_p, old_ref_i, new_ref_i);
 539       }
 540 
 541       if (scratch_cp-&gt;tag_at(scratch_i).is_dynamic_constant())
 542         (*merge_cp_p)-&gt;dynamic_constant_at_put(*merge_cp_length_p, new_bs_i, new_ref_i);
 543       else
 544         (*merge_cp_p)-&gt;invoke_dynamic_at_put(*merge_cp_length_p, new_bs_i, new_ref_i);
 545       if (scratch_i != *merge_cp_length_p) {
 546         // The new entry in *merge_cp_p is at a different index than
 547         // the new entry in scratch_cp so we need to map the index values.
 548         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 549       }
 550       (*merge_cp_length_p)++;
 551     } break;
 552 
 553     // At this stage, Class or UnresolvedClass could be in scratch_cp, but not
 554     // ClassIndex
 555     case JVM_CONSTANT_ClassIndex: // fall through
 556 
 557     // Invalid is used as the tag for the second constant pool entry
 558     // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
 559     // not be seen by itself.
 560     case JVM_CONSTANT_Invalid: // fall through
 561 
 562     // At this stage, String could be here, but not StringIndex
 563     case JVM_CONSTANT_StringIndex: // fall through
 564 
 565     // At this stage JVM_CONSTANT_UnresolvedClassInError should not be here
 566     case JVM_CONSTANT_UnresolvedClassInError: // fall through
 567 
 568     default:
 569     {
 570       // leave a breadcrumb
 571       jbyte bad_value = scratch_cp-&gt;tag_at(scratch_i).value();
 572       ShouldNotReachHere();
 573     } break;
 574   } // end switch tag value
 575 } // end append_entry()
 576 
 577 
 578 int VM_RedefineClasses::find_or_append_indirect_entry(const constantPoolHandle&amp; scratch_cp,
 579       int ref_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 580 
 581   int new_ref_i = ref_i;
 582   bool match = (ref_i &lt; *merge_cp_length_p) &amp;&amp;
 583                scratch_cp-&gt;compare_entry_to(ref_i, *merge_cp_p, ref_i, THREAD);
 584 
 585   if (!match) {
 586     // forward reference in *merge_cp_p or not a direct match
 587     int found_i = scratch_cp-&gt;find_matching_entry(ref_i, *merge_cp_p, THREAD);
 588     if (found_i != 0) {
 589       guarantee(found_i != ref_i, &quot;compare_entry_to() and find_matching_entry() do not agree&quot;);
 590       // Found a matching entry somewhere else in *merge_cp_p so just need a mapping entry.
 591       new_ref_i = found_i;
 592       map_index(scratch_cp, ref_i, found_i);
 593     } else {
 594       // no match found so we have to append this entry to *merge_cp_p
 595       append_entry(scratch_cp, ref_i, merge_cp_p, merge_cp_length_p, THREAD);
 596       // The above call to append_entry() can only append one entry
 597       // so the post call query of *merge_cp_length_p is only for
 598       // the sake of consistency.
 599       new_ref_i = *merge_cp_length_p - 1;
 600     }
 601   }
 602 
 603   return new_ref_i;
 604 } // end find_or_append_indirect_entry()
 605 
 606 
 607 // Append a bootstrap specifier into the merge_cp operands that is semantically equal
 608 // to the scratch_cp operands bootstrap specifier passed by the old_bs_i index.
 609 // Recursively append new merge_cp entries referenced by the new bootstrap specifier.
 610 void VM_RedefineClasses::append_operand(const constantPoolHandle&amp; scratch_cp, int old_bs_i,
 611        constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 612 
 613   int old_ref_i = scratch_cp-&gt;operand_bootstrap_method_ref_index_at(old_bs_i);
 614   int new_ref_i = find_or_append_indirect_entry(scratch_cp, old_ref_i, merge_cp_p,
 615                                                 merge_cp_length_p, THREAD);
 616   if (new_ref_i != old_ref_i) {
 617     log_trace(redefine, class, constantpool)
 618       (&quot;operands entry@%d bootstrap method ref_index change: %d to %d&quot;, _operands_cur_length, old_ref_i, new_ref_i);
 619   }
 620 
 621   Array&lt;u2&gt;* merge_ops = (*merge_cp_p)-&gt;operands();
 622   int new_bs_i = _operands_cur_length;
 623   // We have _operands_cur_length == 0 when the merge_cp operands is empty yet.
 624   // However, the operand_offset_at(0) was set in the extend_operands() call.
 625   int new_base = (new_bs_i == 0) ? (*merge_cp_p)-&gt;operand_offset_at(0)
 626                                  : (*merge_cp_p)-&gt;operand_next_offset_at(new_bs_i - 1);
 627   int argc     = scratch_cp-&gt;operand_argument_count_at(old_bs_i);
 628 
 629   ConstantPool::operand_offset_at_put(merge_ops, _operands_cur_length, new_base);
 630   merge_ops-&gt;at_put(new_base++, new_ref_i);
 631   merge_ops-&gt;at_put(new_base++, argc);
 632 
 633   for (int i = 0; i &lt; argc; i++) {
 634     int old_arg_ref_i = scratch_cp-&gt;operand_argument_index_at(old_bs_i, i);
 635     int new_arg_ref_i = find_or_append_indirect_entry(scratch_cp, old_arg_ref_i, merge_cp_p,
 636                                                       merge_cp_length_p, THREAD);
 637     merge_ops-&gt;at_put(new_base++, new_arg_ref_i);
 638     if (new_arg_ref_i != old_arg_ref_i) {
 639       log_trace(redefine, class, constantpool)
 640         (&quot;operands entry@%d bootstrap method argument ref_index change: %d to %d&quot;,
 641          _operands_cur_length, old_arg_ref_i, new_arg_ref_i);
 642     }
 643   }
 644   if (old_bs_i != _operands_cur_length) {
 645     // The bootstrap specifier in *merge_cp_p is at a different index than
 646     // that in scratch_cp so we need to map the index values.
 647     map_operand_index(old_bs_i, new_bs_i);
 648   }
 649   _operands_cur_length++;
 650 } // end append_operand()
 651 
 652 
 653 int VM_RedefineClasses::find_or_append_operand(const constantPoolHandle&amp; scratch_cp,
 654       int old_bs_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 655 
 656   int new_bs_i = old_bs_i; // bootstrap specifier index
 657   bool match = (old_bs_i &lt; _operands_cur_length) &amp;&amp;
 658                scratch_cp-&gt;compare_operand_to(old_bs_i, *merge_cp_p, old_bs_i, THREAD);
 659 
 660   if (!match) {
 661     // forward reference in *merge_cp_p or not a direct match
 662     int found_i = scratch_cp-&gt;find_matching_operand(old_bs_i, *merge_cp_p,
 663                                                     _operands_cur_length, THREAD);
 664     if (found_i != -1) {
 665       guarantee(found_i != old_bs_i, &quot;compare_operand_to() and find_matching_operand() disagree&quot;);
 666       // found a matching operand somewhere else in *merge_cp_p so just need a mapping
 667       new_bs_i = found_i;
 668       map_operand_index(old_bs_i, found_i);
 669     } else {
 670       // no match found so we have to append this bootstrap specifier to *merge_cp_p
 671       append_operand(scratch_cp, old_bs_i, merge_cp_p, merge_cp_length_p, THREAD);
 672       new_bs_i = _operands_cur_length - 1;
 673     }
 674   }
 675   return new_bs_i;
 676 } // end find_or_append_operand()
 677 
 678 
 679 void VM_RedefineClasses::finalize_operands_merge(const constantPoolHandle&amp; merge_cp, TRAPS) {
 680   if (merge_cp-&gt;operands() == NULL) {
 681     return;
 682   }
 683   // Shrink the merge_cp operands
 684   merge_cp-&gt;shrink_operands(_operands_cur_length, CHECK);
 685 
 686   if (log_is_enabled(Trace, redefine, class, constantpool)) {
 687     // don&#39;t want to loop unless we are tracing
 688     int count = 0;
 689     for (int i = 1; i &lt; _operands_index_map_p-&gt;length(); i++) {
 690       int value = _operands_index_map_p-&gt;at(i);
 691       if (value != -1) {
 692         log_trace(redefine, class, constantpool)(&quot;operands_index_map[%d]: old=%d new=%d&quot;, count, i, value);
 693         count++;
 694       }
 695     }
 696   }
 697   // Clean-up
 698   _operands_index_map_p = NULL;
 699   _operands_cur_length = 0;
 700   _operands_index_map_count = 0;
 701 } // end finalize_operands_merge()
 702 
 703 // Symbol* comparator for qsort
 704 // The caller must have an active ResourceMark.
 705 static int symcmp(const void* a, const void* b) {
 706   char* astr = (*(Symbol**)a)-&gt;as_C_string();
 707   char* bstr = (*(Symbol**)b)-&gt;as_C_string();
 708   return strcmp(astr, bstr);
 709 }
 710 
 711 static jvmtiError check_nest_attributes(InstanceKlass* the_class,
 712                                         InstanceKlass* scratch_class) {
 713   // Check whether the class NestHost attribute has been changed.
 714   Thread* thread = Thread::current();
 715   ResourceMark rm(thread);
 716   u2 the_nest_host_idx = the_class-&gt;nest_host_index();
 717   u2 scr_nest_host_idx = scratch_class-&gt;nest_host_index();
 718 
 719   if (the_nest_host_idx != 0 &amp;&amp; scr_nest_host_idx != 0) {
 720     Symbol* the_sym = the_class-&gt;constants()-&gt;klass_name_at(the_nest_host_idx);
 721     Symbol* scr_sym = scratch_class-&gt;constants()-&gt;klass_name_at(scr_nest_host_idx);
 722     if (the_sym != scr_sym) {
 723       log_trace(redefine, class, nestmates)
 724         (&quot;redefined class %s attribute change error: NestHost class: %s replaced with: %s&quot;,
 725          the_class-&gt;external_name(), the_sym-&gt;as_C_string(), scr_sym-&gt;as_C_string());
 726       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 727     }
 728   } else if ((the_nest_host_idx == 0) ^ (scr_nest_host_idx == 0)) {
 729     const char* action_str = (the_nest_host_idx != 0) ? &quot;removed&quot; : &quot;added&quot;;
 730     log_trace(redefine, class, nestmates)
 731       (&quot;redefined class %s attribute change error: NestHost attribute %s&quot;,
 732        the_class-&gt;external_name(), action_str);
 733     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 734   }
 735 
 736   // Check whether the class NestMembers attribute has been changed.
 737   Array&lt;u2&gt;* the_nest_members = the_class-&gt;nest_members();
 738   Array&lt;u2&gt;* scr_nest_members = scratch_class-&gt;nest_members();
 739   bool the_members_exists = the_nest_members != Universe::the_empty_short_array();
 740   bool scr_members_exists = scr_nest_members != Universe::the_empty_short_array();
 741 
 742   int members_len = the_nest_members-&gt;length();
 743   if (the_members_exists &amp;&amp; scr_members_exists) {
 744     if (members_len != scr_nest_members-&gt;length()) {
 745       log_trace(redefine, class, nestmates)
 746         (&quot;redefined class %s attribute change error: NestMember len=%d changed to len=%d&quot;,
 747          the_class-&gt;external_name(), members_len, scr_nest_members-&gt;length());
 748       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 749     }
 750 
 751     // The order of entries in the NestMembers array is not specified so we
 752     // have to explicitly check for the same contents. We do this by copying
 753     // the referenced symbols into their own arrays, sorting them and then
 754     // comparing each element pair.
 755 
 756     Symbol** the_syms = NEW_RESOURCE_ARRAY_RETURN_NULL(Symbol*, members_len);
 757     Symbol** scr_syms = NEW_RESOURCE_ARRAY_RETURN_NULL(Symbol*, members_len);
 758 
 759     if (the_syms == NULL || scr_syms == NULL) {
 760       return JVMTI_ERROR_OUT_OF_MEMORY;
 761     }
 762 
 763     for (int i = 0; i &lt; members_len; i++) {
 764       int the_cp_index = the_nest_members-&gt;at(i);
 765       int scr_cp_index = scr_nest_members-&gt;at(i);
 766       the_syms[i] = the_class-&gt;constants()-&gt;klass_name_at(the_cp_index);
 767       scr_syms[i] = scratch_class-&gt;constants()-&gt;klass_name_at(scr_cp_index);
 768     }
 769 
 770     qsort(the_syms, members_len, sizeof(Symbol*), symcmp);
 771     qsort(scr_syms, members_len, sizeof(Symbol*), symcmp);
 772 
 773     for (int i = 0; i &lt; members_len; i++) {
 774       if (the_syms[i] != scr_syms[i]) {
 775         log_trace(redefine, class, nestmates)
 776           (&quot;redefined class %s attribute change error: NestMembers[%d]: %s changed to %s&quot;,
 777            the_class-&gt;external_name(), i, the_syms[i]-&gt;as_C_string(), scr_syms[i]-&gt;as_C_string());
 778         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 779       }
 780     }
 781   } else if (the_members_exists ^ scr_members_exists) {
 782     const char* action_str = (the_members_exists) ? &quot;removed&quot; : &quot;added&quot;;
 783     log_trace(redefine, class, nestmates)
 784       (&quot;redefined class %s attribute change error: NestMembers attribute %s&quot;,
 785        the_class-&gt;external_name(), action_str);
 786     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 787   }
 788 
 789   return JVMTI_ERROR_NONE;
 790 }
 791 
 792 // Return an error status if the class Record attribute was changed.
 793 static jvmtiError check_record_attribute(InstanceKlass* the_class, InstanceKlass* scratch_class) {
 794   // Get lists of record components.
 795   Array&lt;RecordComponent*&gt;* the_record = the_class-&gt;record_components();
 796   Array&lt;RecordComponent*&gt;* scr_record = scratch_class-&gt;record_components();
 797   bool the_record_exists = the_record != NULL;
 798   bool scr_record_exists = scr_record != NULL;
 799 
 800   if (the_record_exists &amp;&amp; scr_record_exists) {
 801     int the_num_components = the_record-&gt;length();
 802     int scr_num_components = scr_record-&gt;length();
 803     if (the_num_components != scr_num_components) {
 804       log_trace(redefine, class, record)
 805         (&quot;redefined class %s attribute change error: Record num_components=%d changed to num_components=%d&quot;,
 806          the_class-&gt;external_name(), the_num_components, scr_num_components);
 807       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 808     }
 809 
 810     // Compare each field in each record component.
 811     ConstantPool* the_cp =  the_class-&gt;constants();
 812     ConstantPool* scr_cp =  scratch_class-&gt;constants();
 813     for (int x = 0; x &lt; the_num_components; x++) {
 814       RecordComponent* the_component = the_record-&gt;at(x);
 815       RecordComponent* scr_component = scr_record-&gt;at(x);
 816       const Symbol* const the_name = the_cp-&gt;symbol_at(the_component-&gt;name_index());
 817       const Symbol* const scr_name = scr_cp-&gt;symbol_at(scr_component-&gt;name_index());
 818       const Symbol* const the_descr = the_cp-&gt;symbol_at(the_component-&gt;descriptor_index());
 819       const Symbol* const scr_descr = scr_cp-&gt;symbol_at(scr_component-&gt;descriptor_index());
 820       if (the_name != scr_name || the_descr != scr_descr) {
 821         log_trace(redefine, class, record)
 822           (&quot;redefined class %s attribute change error: Record name_index, descriptor_index, and/or attributes_count changed&quot;,
 823            the_class-&gt;external_name());
 824         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 825       }
 826 
 827       int the_gen_sig = the_component-&gt;generic_signature_index();
 828       int scr_gen_sig = scr_component-&gt;generic_signature_index();
 829       const Symbol* const the_gen_sig_sym = (the_gen_sig == 0 ? NULL :
 830         the_cp-&gt;symbol_at(the_component-&gt;generic_signature_index()));
 831       const Symbol* const scr_gen_sig_sym = (scr_gen_sig == 0 ? NULL :
 832         scr_cp-&gt;symbol_at(scr_component-&gt;generic_signature_index()));
 833       if (the_gen_sig_sym != scr_gen_sig_sym) {
 834         log_trace(redefine, class, record)
 835           (&quot;redefined class %s attribute change error: Record generic_signature attribute changed&quot;,
 836            the_class-&gt;external_name());
 837         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 838       }
 839 
 840       // It&#39;s okay if a record component&#39;s annotations were changed.
 841     }
 842 
 843   } else if (the_record_exists ^ scr_record_exists) {
 844     const char* action_str = (the_record_exists) ? &quot;removed&quot; : &quot;added&quot;;
 845     log_trace(redefine, class, record)
 846       (&quot;redefined class %s attribute change error: Record attribute %s&quot;,
 847        the_class-&gt;external_name(), action_str);
 848     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 849   }
 850 
 851   return JVMTI_ERROR_NONE;
 852 }
 853 
 854 
 855 static bool can_add_or_delete(Method* m) {
 856       // Compatibility mode
 857   return (AllowRedefinitionToAddDeleteMethods &amp;&amp;
 858           (m-&gt;is_private() &amp;&amp; (m-&gt;is_static() || m-&gt;is_final())));
 859 }
 860 
 861 jvmtiError VM_RedefineClasses::compare_and_normalize_class_versions(
 862              InstanceKlass* the_class,
 863              InstanceKlass* scratch_class) {
 864   int i;
 865 
 866   // Check superclasses, or rather their names, since superclasses themselves can be
 867   // requested to replace.
 868   // Check for NULL superclass first since this might be java.lang.Object
 869   if (the_class-&gt;super() != scratch_class-&gt;super() &amp;&amp;
 870       (the_class-&gt;super() == NULL || scratch_class-&gt;super() == NULL ||
 871        the_class-&gt;super()-&gt;name() !=
 872        scratch_class-&gt;super()-&gt;name())) {
 873     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 874   }
 875 
 876   // Check if the number, names and order of directly implemented interfaces are the same.
 877   // I think in principle we should just check if the sets of names of directly implemented
 878   // interfaces are the same, i.e. the order of declaration (which, however, if changed in the
 879   // .java file, also changes in .class file) should not matter. However, comparing sets is
 880   // technically a bit more difficult, and, more importantly, I am not sure at present that the
 881   // order of interfaces does not matter on the implementation level, i.e. that the VM does not
 882   // rely on it somewhere.
 883   Array&lt;InstanceKlass*&gt;* k_interfaces = the_class-&gt;local_interfaces();
 884   Array&lt;InstanceKlass*&gt;* k_new_interfaces = scratch_class-&gt;local_interfaces();
 885   int n_intfs = k_interfaces-&gt;length();
 886   if (n_intfs != k_new_interfaces-&gt;length()) {
 887     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 888   }
 889   for (i = 0; i &lt; n_intfs; i++) {
 890     if (k_interfaces-&gt;at(i)-&gt;name() !=
 891         k_new_interfaces-&gt;at(i)-&gt;name()) {
 892       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 893     }
 894   }
 895 
 896   // Check whether class is in the error init state.
 897   if (the_class-&gt;is_in_error_state()) {
 898     // TBD #5057930: special error code is needed in 1.6
 899     return JVMTI_ERROR_INVALID_CLASS;
 900   }
 901 
 902   // Check whether the nest-related attributes have been changed.
 903   jvmtiError err = check_nest_attributes(the_class, scratch_class);
 904   if (err != JVMTI_ERROR_NONE) {
 905     return err;
 906   }
 907 
 908   // Check whether the Record attribute has been changed.
 909   err = check_record_attribute(the_class, scratch_class);
 910   if (err != JVMTI_ERROR_NONE) {
 911     return err;
 912   }
 913 
 914   // Check whether class modifiers are the same.
 915   jushort old_flags = (jushort) the_class-&gt;access_flags().get_flags();
 916   jushort new_flags = (jushort) scratch_class-&gt;access_flags().get_flags();
 917   if (old_flags != new_flags) {
 918     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED;
 919   }
 920 
 921   // Check if the number, names, types and order of fields declared in these classes
 922   // are the same.
 923   JavaFieldStream old_fs(the_class);
 924   JavaFieldStream new_fs(scratch_class);
 925   for (; !old_fs.done() &amp;&amp; !new_fs.done(); old_fs.next(), new_fs.next()) {
 926     // access
 927     old_flags = old_fs.access_flags().as_short();
 928     new_flags = new_fs.access_flags().as_short();
 929     if ((old_flags ^ new_flags) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS) {
 930       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 931     }
 932     // offset
 933     if (old_fs.offset() != new_fs.offset()) {
 934       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 935     }
 936     // name and signature
 937     Symbol* name_sym1 = the_class-&gt;constants()-&gt;symbol_at(old_fs.name_index());
 938     Symbol* sig_sym1 = the_class-&gt;constants()-&gt;symbol_at(old_fs.signature_index());
 939     Symbol* name_sym2 = scratch_class-&gt;constants()-&gt;symbol_at(new_fs.name_index());
 940     Symbol* sig_sym2 = scratch_class-&gt;constants()-&gt;symbol_at(new_fs.signature_index());
 941     if (name_sym1 != name_sym2 || sig_sym1 != sig_sym2) {
 942       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 943     }
 944   }
 945 
 946   // If both streams aren&#39;t done then we have a differing number of
 947   // fields.
 948   if (!old_fs.done() || !new_fs.done()) {
 949     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 950   }
 951 
 952   // Do a parallel walk through the old and new methods. Detect
 953   // cases where they match (exist in both), have been added in
 954   // the new methods, or have been deleted (exist only in the
 955   // old methods).  The class file parser places methods in order
 956   // by method name, but does not order overloaded methods by
 957   // signature.  In order to determine what fate befell the methods,
 958   // this code places the overloaded new methods that have matching
 959   // old methods in the same order as the old methods and places
 960   // new overloaded methods at the end of overloaded methods of
 961   // that name. The code for this order normalization is adapted
 962   // from the algorithm used in InstanceKlass::find_method().
 963   // Since we are swapping out of order entries as we find them,
 964   // we only have to search forward through the overloaded methods.
 965   // Methods which are added and have the same name as an existing
 966   // method (but different signature) will be put at the end of
 967   // the methods with that name, and the name mismatch code will
 968   // handle them.
 969   Array&lt;Method*&gt;* k_old_methods(the_class-&gt;methods());
 970   Array&lt;Method*&gt;* k_new_methods(scratch_class-&gt;methods());
 971   int n_old_methods = k_old_methods-&gt;length();
 972   int n_new_methods = k_new_methods-&gt;length();
 973   Thread* thread = Thread::current();
 974 
 975   int ni = 0;
 976   int oi = 0;
 977   while (true) {
 978     Method* k_old_method;
 979     Method* k_new_method;
 980     enum { matched, added, deleted, undetermined } method_was = undetermined;
 981 
 982     if (oi &gt;= n_old_methods) {
 983       if (ni &gt;= n_new_methods) {
 984         break; // we&#39;ve looked at everything, done
 985       }
 986       // New method at the end
 987       k_new_method = k_new_methods-&gt;at(ni);
 988       method_was = added;
 989     } else if (ni &gt;= n_new_methods) {
 990       // Old method, at the end, is deleted
 991       k_old_method = k_old_methods-&gt;at(oi);
 992       method_was = deleted;
 993     } else {
 994       // There are more methods in both the old and new lists
 995       k_old_method = k_old_methods-&gt;at(oi);
 996       k_new_method = k_new_methods-&gt;at(ni);
 997       if (k_old_method-&gt;name() != k_new_method-&gt;name()) {
 998         // Methods are sorted by method name, so a mismatch means added
 999         // or deleted
1000         if (k_old_method-&gt;name()-&gt;fast_compare(k_new_method-&gt;name()) &gt; 0) {
1001           method_was = added;
1002         } else {
1003           method_was = deleted;
1004         }
1005       } else if (k_old_method-&gt;signature() == k_new_method-&gt;signature()) {
1006         // Both the name and signature match
1007         method_was = matched;
1008       } else {
1009         // The name matches, but the signature doesn&#39;t, which means we have to
1010         // search forward through the new overloaded methods.
1011         int nj;  // outside the loop for post-loop check
1012         for (nj = ni + 1; nj &lt; n_new_methods; nj++) {
1013           Method* m = k_new_methods-&gt;at(nj);
1014           if (k_old_method-&gt;name() != m-&gt;name()) {
1015             // reached another method name so no more overloaded methods
1016             method_was = deleted;
1017             break;
1018           }
1019           if (k_old_method-&gt;signature() == m-&gt;signature()) {
1020             // found a match so swap the methods
1021             k_new_methods-&gt;at_put(ni, m);
1022             k_new_methods-&gt;at_put(nj, k_new_method);
1023             k_new_method = m;
1024             method_was = matched;
1025             break;
1026           }
1027         }
1028 
1029         if (nj &gt;= n_new_methods) {
1030           // reached the end without a match; so method was deleted
1031           method_was = deleted;
1032         }
1033       }
1034     }
1035 
1036     switch (method_was) {
1037     case matched:
1038       // methods match, be sure modifiers do too
1039       old_flags = (jushort) k_old_method-&gt;access_flags().get_flags();
1040       new_flags = (jushort) k_new_method-&gt;access_flags().get_flags();
1041       if ((old_flags ^ new_flags) &amp; ~(JVM_ACC_NATIVE)) {
1042         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED;
1043       }
1044       {
1045         u2 new_num = k_new_method-&gt;method_idnum();
1046         u2 old_num = k_old_method-&gt;method_idnum();
1047         if (new_num != old_num) {
1048           Method* idnum_owner = scratch_class-&gt;method_with_idnum(old_num);
1049           if (idnum_owner != NULL) {
1050             // There is already a method assigned this idnum -- switch them
1051             // Take current and original idnum from the new_method
1052             idnum_owner-&gt;set_method_idnum(new_num);
1053             idnum_owner-&gt;set_orig_method_idnum(k_new_method-&gt;orig_method_idnum());
1054           }
1055           // Take current and original idnum from the old_method
1056           k_new_method-&gt;set_method_idnum(old_num);
1057           k_new_method-&gt;set_orig_method_idnum(k_old_method-&gt;orig_method_idnum());
1058           if (thread-&gt;has_pending_exception()) {
1059             return JVMTI_ERROR_OUT_OF_MEMORY;
1060           }
1061         }
1062       }
1063       log_trace(redefine, class, normalize)
1064         (&quot;Method matched: new: %s [%d] == old: %s [%d]&quot;,
1065          k_new_method-&gt;name_and_sig_as_C_string(), ni, k_old_method-&gt;name_and_sig_as_C_string(), oi);
1066       // advance to next pair of methods
1067       ++oi;
1068       ++ni;
1069       break;
1070     case added:
1071       // method added, see if it is OK
1072       if (!can_add_or_delete(k_new_method)) {
1073         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
1074       }
1075       {
1076         u2 num = the_class-&gt;next_method_idnum();
1077         if (num == ConstMethod::UNSET_IDNUM) {
1078           // cannot add any more methods
1079           return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
1080         }
1081         u2 new_num = k_new_method-&gt;method_idnum();
1082         Method* idnum_owner = scratch_class-&gt;method_with_idnum(num);
1083         if (idnum_owner != NULL) {
1084           // There is already a method assigned this idnum -- switch them
1085           // Take current and original idnum from the new_method
1086           idnum_owner-&gt;set_method_idnum(new_num);
1087           idnum_owner-&gt;set_orig_method_idnum(k_new_method-&gt;orig_method_idnum());
1088         }
1089         k_new_method-&gt;set_method_idnum(num);
1090         k_new_method-&gt;set_orig_method_idnum(num);
1091         if (thread-&gt;has_pending_exception()) {
1092           return JVMTI_ERROR_OUT_OF_MEMORY;
1093         }
1094       }
1095       log_trace(redefine, class, normalize)
1096         (&quot;Method added: new: %s [%d]&quot;, k_new_method-&gt;name_and_sig_as_C_string(), ni);
1097       ++ni; // advance to next new method
1098       break;
1099     case deleted:
1100       // method deleted, see if it is OK
1101       if (!can_add_or_delete(k_old_method)) {
1102         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED;
1103       }
1104       log_trace(redefine, class, normalize)
1105         (&quot;Method deleted: old: %s [%d]&quot;, k_old_method-&gt;name_and_sig_as_C_string(), oi);
1106       ++oi; // advance to next old method
1107       break;
1108     default:
1109       ShouldNotReachHere();
1110     }
1111   }
1112 
1113   return JVMTI_ERROR_NONE;
1114 }
1115 
1116 
1117 // Find new constant pool index value for old constant pool index value
1118 // by seaching the index map. Returns zero (0) if there is no mapped
1119 // value for the old constant pool index.
1120 int VM_RedefineClasses::find_new_index(int old_index) {
1121   if (_index_map_count == 0) {
1122     // map is empty so nothing can be found
1123     return 0;
1124   }
1125 
1126   if (old_index &lt; 1 || old_index &gt;= _index_map_p-&gt;length()) {
1127     // The old_index is out of range so it is not mapped. This should
1128     // not happen in regular constant pool merging use, but it can
1129     // happen if a corrupt annotation is processed.
1130     return 0;
1131   }
1132 
1133   int value = _index_map_p-&gt;at(old_index);
1134   if (value == -1) {
1135     // the old_index is not mapped
1136     return 0;
1137   }
1138 
1139   return value;
1140 } // end find_new_index()
1141 
1142 
1143 // Find new bootstrap specifier index value for old bootstrap specifier index
1144 // value by seaching the index map. Returns unused index (-1) if there is
1145 // no mapped value for the old bootstrap specifier index.
1146 int VM_RedefineClasses::find_new_operand_index(int old_index) {
1147   if (_operands_index_map_count == 0) {
1148     // map is empty so nothing can be found
1149     return -1;
1150   }
1151 
1152   if (old_index == -1 || old_index &gt;= _operands_index_map_p-&gt;length()) {
1153     // The old_index is out of range so it is not mapped.
1154     // This should not happen in regular constant pool merging use.
1155     return -1;
1156   }
1157 
1158   int value = _operands_index_map_p-&gt;at(old_index);
1159   if (value == -1) {
1160     // the old_index is not mapped
1161     return -1;
1162   }
1163 
1164   return value;
1165 } // end find_new_operand_index()
1166 
1167 
1168 // Returns true if the current mismatch is due to a resolved/unresolved
1169 // class pair. Otherwise, returns false.
1170 bool VM_RedefineClasses::is_unresolved_class_mismatch(const constantPoolHandle&amp; cp1,
1171        int index1, const constantPoolHandle&amp; cp2, int index2) {
1172 
1173   jbyte t1 = cp1-&gt;tag_at(index1).value();
1174   if (t1 != JVM_CONSTANT_Class &amp;&amp; t1 != JVM_CONSTANT_UnresolvedClass) {
1175     return false;  // wrong entry type; not our special case
1176   }
1177 
1178   jbyte t2 = cp2-&gt;tag_at(index2).value();
1179   if (t2 != JVM_CONSTANT_Class &amp;&amp; t2 != JVM_CONSTANT_UnresolvedClass) {
1180     return false;  // wrong entry type; not our special case
1181   }
1182 
1183   if (t1 == t2) {
1184     return false;  // not a mismatch; not our special case
1185   }
1186 
1187   char *s1 = cp1-&gt;klass_name_at(index1)-&gt;as_C_string();
1188   char *s2 = cp2-&gt;klass_name_at(index2)-&gt;as_C_string();
1189   if (strcmp(s1, s2) != 0) {
1190     return false;  // strings don&#39;t match; not our special case
1191   }
1192 
1193   return true;  // made it through the gauntlet; this is our special case
1194 } // end is_unresolved_class_mismatch()
1195 
1196 
1197 jvmtiError VM_RedefineClasses::load_new_class_versions(TRAPS) {
1198 
1199   // For consistency allocate memory using os::malloc wrapper.
1200   _scratch_classes = (InstanceKlass**)
1201     os::malloc(sizeof(InstanceKlass*) * _class_count, mtClass);
1202   if (_scratch_classes == NULL) {
1203     return JVMTI_ERROR_OUT_OF_MEMORY;
1204   }
1205   // Zero initialize the _scratch_classes array.
1206   for (int i = 0; i &lt; _class_count; i++) {
1207     _scratch_classes[i] = NULL;
1208   }
1209 
1210   ResourceMark rm(THREAD);
1211 
1212   JvmtiThreadState *state = JvmtiThreadState::state_for(JavaThread::current());
1213   // state can only be NULL if the current thread is exiting which
1214   // should not happen since we&#39;re trying to do a RedefineClasses
1215   guarantee(state != NULL, &quot;exiting thread calling load_new_class_versions&quot;);
1216   for (int i = 0; i &lt; _class_count; i++) {
1217     // Create HandleMark so that any handles created while loading new class
1218     // versions are deleted. Constant pools are deallocated while merging
1219     // constant pools
1220     HandleMark hm(THREAD);
1221     InstanceKlass* the_class = get_ik(_class_defs[i].klass);
1222     Symbol*  the_class_sym = the_class-&gt;name();
1223 
1224     log_debug(redefine, class, load)
1225       (&quot;loading name=%s kind=%d (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;,
1226        the_class-&gt;external_name(), _class_load_kind, os::available_memory() &gt;&gt; 10);
1227 
1228     ClassFileStream st((u1*)_class_defs[i].class_bytes,
1229                        _class_defs[i].class_byte_count,
1230                        &quot;__VM_RedefineClasses__&quot;,
1231                        ClassFileStream::verify);
1232 
1233     // Parse the stream.
1234     Handle the_class_loader(THREAD, the_class-&gt;class_loader());
1235     Handle protection_domain(THREAD, the_class-&gt;protection_domain());
1236     // Set redefined class handle in JvmtiThreadState class.
1237     // This redefined class is sent to agent event handler for class file
1238     // load hook event.
1239     state-&gt;set_class_being_redefined(the_class, _class_load_kind);
1240 
1241     InstanceKlass* scratch_class = SystemDictionary::parse_stream(
1242                                                       the_class_sym,
1243                                                       the_class_loader,
1244                                                       protection_domain,
1245                                                       &amp;st,
1246                                                       THREAD);
1247     // Clear class_being_redefined just to be sure.
1248     state-&gt;clear_class_being_redefined();
1249 
1250     // TODO: if this is retransform, and nothing changed we can skip it
1251 
1252     // Need to clean up allocated InstanceKlass if there&#39;s an error so assign
1253     // the result here. Caller deallocates all the scratch classes in case of
1254     // an error.
1255     _scratch_classes[i] = scratch_class;
1256 
1257     if (HAS_PENDING_EXCEPTION) {
1258       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1259       log_info(redefine, class, load, exceptions)(&quot;parse_stream exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1260       CLEAR_PENDING_EXCEPTION;
1261 
1262       if (ex_name == vmSymbols::java_lang_UnsupportedClassVersionError()) {
1263         return JVMTI_ERROR_UNSUPPORTED_VERSION;
1264       } else if (ex_name == vmSymbols::java_lang_ClassFormatError()) {
1265         return JVMTI_ERROR_INVALID_CLASS_FORMAT;
1266       } else if (ex_name == vmSymbols::java_lang_ClassCircularityError()) {
1267         return JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION;
1268       } else if (ex_name == vmSymbols::java_lang_NoClassDefFoundError()) {
1269         // The message will be &quot;XXX (wrong name: YYY)&quot;
1270         return JVMTI_ERROR_NAMES_DONT_MATCH;
1271       } else if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1272         return JVMTI_ERROR_OUT_OF_MEMORY;
1273       } else {  // Just in case more exceptions can be thrown..
1274         return JVMTI_ERROR_FAILS_VERIFICATION;
1275       }
1276     }
1277 
1278     // Ensure class is linked before redefine
1279     if (!the_class-&gt;is_linked()) {
1280       the_class-&gt;link_class(THREAD);
1281       if (HAS_PENDING_EXCEPTION) {
1282         Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1283         log_info(redefine, class, load, exceptions)(&quot;link_class exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1284         CLEAR_PENDING_EXCEPTION;
1285         if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1286           return JVMTI_ERROR_OUT_OF_MEMORY;
1287         } else {
1288           return JVMTI_ERROR_INTERNAL;
1289         }
1290       }
1291     }
1292 
1293     // Do the validity checks in compare_and_normalize_class_versions()
1294     // before verifying the byte codes. By doing these checks first, we
1295     // limit the number of functions that require redirection from
1296     // the_class to scratch_class. In particular, we don&#39;t have to
1297     // modify JNI GetSuperclass() and thus won&#39;t change its performance.
1298     jvmtiError res = compare_and_normalize_class_versions(the_class,
1299                        scratch_class);
1300     if (res != JVMTI_ERROR_NONE) {
1301       return res;
1302     }
1303 
1304     // verify what the caller passed us
1305     {
1306       // The bug 6214132 caused the verification to fail.
1307       // Information about the_class and scratch_class is temporarily
1308       // recorded into jvmtiThreadState. This data is used to redirect
1309       // the_class to scratch_class in the JVM_* functions called by the
1310       // verifier. Please, refer to jvmtiThreadState.hpp for the detailed
1311       // description.
1312       RedefineVerifyMark rvm(the_class, scratch_class, state);
1313       Verifier::verify(scratch_class, true, THREAD);
1314     }
1315 
1316     if (HAS_PENDING_EXCEPTION) {
1317       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1318       log_info(redefine, class, load, exceptions)(&quot;verify_byte_codes exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1319       CLEAR_PENDING_EXCEPTION;
1320       if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1321         return JVMTI_ERROR_OUT_OF_MEMORY;
1322       } else {
1323         // tell the caller the bytecodes are bad
1324         return JVMTI_ERROR_FAILS_VERIFICATION;
1325       }
1326     }
1327 
1328     res = merge_cp_and_rewrite(the_class, scratch_class, THREAD);
1329     if (HAS_PENDING_EXCEPTION) {
1330       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1331       log_info(redefine, class, load, exceptions)(&quot;merge_cp_and_rewrite exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1332       CLEAR_PENDING_EXCEPTION;
1333       if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1334         return JVMTI_ERROR_OUT_OF_MEMORY;
1335       } else {
1336         return JVMTI_ERROR_INTERNAL;
1337       }
1338     }
1339 
1340     if (VerifyMergedCPBytecodes) {
1341       // verify what we have done during constant pool merging
1342       {
1343         RedefineVerifyMark rvm(the_class, scratch_class, state);
1344         Verifier::verify(scratch_class, true, THREAD);
1345       }
1346 
1347       if (HAS_PENDING_EXCEPTION) {
1348         Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1349         log_info(redefine, class, load, exceptions)
1350           (&quot;verify_byte_codes post merge-CP exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1351         CLEAR_PENDING_EXCEPTION;
1352         if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1353           return JVMTI_ERROR_OUT_OF_MEMORY;
1354         } else {
1355           // tell the caller that constant pool merging screwed up
1356           return JVMTI_ERROR_INTERNAL;
1357         }
1358       }
1359     }
1360 
1361     Rewriter::rewrite(scratch_class, THREAD);
1362     if (!HAS_PENDING_EXCEPTION) {
1363       scratch_class-&gt;link_methods(THREAD);
1364     }
1365     if (HAS_PENDING_EXCEPTION) {
1366       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1367       log_info(redefine, class, load, exceptions)
1368         (&quot;Rewriter::rewrite or link_methods exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1369       CLEAR_PENDING_EXCEPTION;
1370       if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1371         return JVMTI_ERROR_OUT_OF_MEMORY;
1372       } else {
1373         return JVMTI_ERROR_INTERNAL;
1374       }
1375     }
1376 
1377     log_debug(redefine, class, load)
1378       (&quot;loaded name=%s (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;, the_class-&gt;external_name(), os::available_memory() &gt;&gt; 10);
1379   }
1380 
1381   return JVMTI_ERROR_NONE;
1382 }
1383 
1384 
1385 // Map old_index to new_index as needed. scratch_cp is only needed
1386 // for log calls.
1387 void VM_RedefineClasses::map_index(const constantPoolHandle&amp; scratch_cp,
1388        int old_index, int new_index) {
1389   if (find_new_index(old_index) != 0) {
1390     // old_index is already mapped
1391     return;
1392   }
1393 
1394   if (old_index == new_index) {
1395     // no mapping is needed
1396     return;
1397   }
1398 
1399   _index_map_p-&gt;at_put(old_index, new_index);
1400   _index_map_count++;
1401 
1402   log_trace(redefine, class, constantpool)
1403     (&quot;mapped tag %d at index %d to %d&quot;, scratch_cp-&gt;tag_at(old_index).value(), old_index, new_index);
1404 } // end map_index()
1405 
1406 
1407 // Map old_index to new_index as needed.
1408 void VM_RedefineClasses::map_operand_index(int old_index, int new_index) {
1409   if (find_new_operand_index(old_index) != -1) {
1410     // old_index is already mapped
1411     return;
1412   }
1413 
1414   if (old_index == new_index) {
1415     // no mapping is needed
1416     return;
1417   }
1418 
1419   _operands_index_map_p-&gt;at_put(old_index, new_index);
1420   _operands_index_map_count++;
1421 
1422   log_trace(redefine, class, constantpool)(&quot;mapped bootstrap specifier at index %d to %d&quot;, old_index, new_index);
1423 } // end map_index()
1424 
1425 
1426 // Merge old_cp and scratch_cp and return the results of the merge via
1427 // merge_cp_p. The number of entries in *merge_cp_p is returned via
1428 // merge_cp_length_p. The entries in old_cp occupy the same locations
1429 // in *merge_cp_p. Also creates a map of indices from entries in
1430 // scratch_cp to the corresponding entry in *merge_cp_p. Index map
1431 // entries are only created for entries in scratch_cp that occupy a
1432 // different location in *merged_cp_p.
1433 bool VM_RedefineClasses::merge_constant_pools(const constantPoolHandle&amp; old_cp,
1434        const constantPoolHandle&amp; scratch_cp, constantPoolHandle *merge_cp_p,
1435        int *merge_cp_length_p, TRAPS) {
1436 
1437   if (merge_cp_p == NULL) {
1438     assert(false, &quot;caller must provide scratch constantPool&quot;);
1439     return false; // robustness
1440   }
1441   if (merge_cp_length_p == NULL) {
1442     assert(false, &quot;caller must provide scratch CP length&quot;);
1443     return false; // robustness
1444   }
1445   // Worst case we need old_cp-&gt;length() + scratch_cp()-&gt;length(),
1446   // but the caller might be smart so make sure we have at least
1447   // the minimum.
1448   if ((*merge_cp_p)-&gt;length() &lt; old_cp-&gt;length()) {
1449     assert(false, &quot;merge area too small&quot;);
1450     return false; // robustness
1451   }
1452 
1453   log_info(redefine, class, constantpool)(&quot;old_cp_len=%d, scratch_cp_len=%d&quot;, old_cp-&gt;length(), scratch_cp-&gt;length());
1454 
1455   {
1456     // Pass 0:
1457     // The old_cp is copied to *merge_cp_p; this means that any code
1458     // using old_cp does not have to change. This work looks like a
1459     // perfect fit for ConstantPool*::copy_cp_to(), but we need to
1460     // handle one special case:
1461     // - revert JVM_CONSTANT_Class to JVM_CONSTANT_UnresolvedClass
1462     // This will make verification happy.
1463 
1464     int old_i;  // index into old_cp
1465 
1466     // index zero (0) is not used in constantPools
1467     for (old_i = 1; old_i &lt; old_cp-&gt;length(); old_i++) {
1468       // leave debugging crumb
1469       jbyte old_tag = old_cp-&gt;tag_at(old_i).value();
1470       switch (old_tag) {
1471       case JVM_CONSTANT_Class:
1472       case JVM_CONSTANT_UnresolvedClass:
1473         // revert the copy to JVM_CONSTANT_UnresolvedClass
1474         // May be resolving while calling this so do the same for
1475         // JVM_CONSTANT_UnresolvedClass (klass_name_at() deals with transition)
1476         (*merge_cp_p)-&gt;temp_unresolved_klass_at_put(old_i,
1477           old_cp-&gt;klass_name_index_at(old_i));
1478         break;
1479 
1480       case JVM_CONSTANT_Double:
1481       case JVM_CONSTANT_Long:
1482         // just copy the entry to *merge_cp_p, but double and long take
1483         // two constant pool entries
<a name="1" id="anc1"></a><span class="line-modified">1484         ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i, CHECK_false);</span>
1485         old_i++;
1486         break;
1487 
1488       default:
1489         // just copy the entry to *merge_cp_p
<a name="2" id="anc2"></a><span class="line-modified">1490         ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i, CHECK_false);</span>
1491         break;
1492       }
1493     } // end for each old_cp entry
1494 
<a name="3" id="anc3"></a><span class="line-modified">1495     ConstantPool::copy_operands(old_cp, *merge_cp_p, CHECK_false);</span>
<span class="line-modified">1496     (*merge_cp_p)-&gt;extend_operands(scratch_cp, CHECK_false);</span>
1497 
1498     // We don&#39;t need to sanity check that *merge_cp_length_p is within
1499     // *merge_cp_p bounds since we have the minimum on-entry check above.
1500     (*merge_cp_length_p) = old_i;
1501   }
1502 
1503   // merge_cp_len should be the same as old_cp-&gt;length() at this point
1504   // so this trace message is really a &quot;warm-and-breathing&quot; message.
1505   log_debug(redefine, class, constantpool)(&quot;after pass 0: merge_cp_len=%d&quot;, *merge_cp_length_p);
1506 
1507   int scratch_i;  // index into scratch_cp
1508   {
1509     // Pass 1a:
1510     // Compare scratch_cp entries to the old_cp entries that we have
1511     // already copied to *merge_cp_p. In this pass, we are eliminating
1512     // exact duplicates (matching entry at same index) so we only
1513     // compare entries in the common indice range.
1514     int increment = 1;
1515     int pass1a_length = MIN2(old_cp-&gt;length(), scratch_cp-&gt;length());
1516     for (scratch_i = 1; scratch_i &lt; pass1a_length; scratch_i += increment) {
1517       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
1518       case JVM_CONSTANT_Double:
1519       case JVM_CONSTANT_Long:
1520         // double and long take two constant pool entries
1521         increment = 2;
1522         break;
1523 
1524       default:
1525         increment = 1;
1526         break;
1527       }
1528 
1529       bool match = scratch_cp-&gt;compare_entry_to(scratch_i, *merge_cp_p,
<a name="4" id="anc4"></a><span class="line-modified">1530         scratch_i, CHECK_false);</span>
1531       if (match) {
1532         // found a match at the same index so nothing more to do
1533         continue;
1534       } else if (is_unresolved_class_mismatch(scratch_cp, scratch_i,
1535                                               *merge_cp_p, scratch_i)) {
1536         // The mismatch in compare_entry_to() above is because of a
1537         // resolved versus unresolved class entry at the same index
1538         // with the same string value. Since Pass 0 reverted any
1539         // class entries to unresolved class entries in *merge_cp_p,
1540         // we go with the unresolved class entry.
1541         continue;
1542       }
1543 
1544       int found_i = scratch_cp-&gt;find_matching_entry(scratch_i, *merge_cp_p,
<a name="5" id="anc5"></a><span class="line-modified">1545         CHECK_false);</span>
1546       if (found_i != 0) {
1547         guarantee(found_i != scratch_i,
1548           &quot;compare_entry_to() and find_matching_entry() do not agree&quot;);
1549 
1550         // Found a matching entry somewhere else in *merge_cp_p so
1551         // just need a mapping entry.
1552         map_index(scratch_cp, scratch_i, found_i);
1553         continue;
1554       }
1555 
1556       // The find_matching_entry() call above could fail to find a match
1557       // due to a resolved versus unresolved class or string entry situation
1558       // like we solved above with the is_unresolved_*_mismatch() calls.
1559       // However, we would have to call is_unresolved_*_mismatch() over
1560       // all of *merge_cp_p (potentially) and that doesn&#39;t seem to be
1561       // worth the time.
1562 
1563       // No match found so we have to append this entry and any unique
1564       // referenced entries to *merge_cp_p.
1565       append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p,
<a name="6" id="anc6"></a><span class="line-modified">1566         CHECK_false);</span>
1567     }
1568   }
1569 
1570   log_debug(redefine, class, constantpool)
1571     (&quot;after pass 1a: merge_cp_len=%d, scratch_i=%d, index_map_len=%d&quot;,
1572      *merge_cp_length_p, scratch_i, _index_map_count);
1573 
1574   if (scratch_i &lt; scratch_cp-&gt;length()) {
1575     // Pass 1b:
1576     // old_cp is smaller than scratch_cp so there are entries in
1577     // scratch_cp that we have not yet processed. We take care of
1578     // those now.
1579     int increment = 1;
1580     for (; scratch_i &lt; scratch_cp-&gt;length(); scratch_i += increment) {
1581       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
1582       case JVM_CONSTANT_Double:
1583       case JVM_CONSTANT_Long:
1584         // double and long take two constant pool entries
1585         increment = 2;
1586         break;
1587 
1588       default:
1589         increment = 1;
1590         break;
1591       }
1592 
1593       int found_i =
<a name="7" id="anc7"></a><span class="line-modified">1594         scratch_cp-&gt;find_matching_entry(scratch_i, *merge_cp_p, CHECK_false);</span>
1595       if (found_i != 0) {
1596         // Found a matching entry somewhere else in *merge_cp_p so
1597         // just need a mapping entry.
1598         map_index(scratch_cp, scratch_i, found_i);
1599         continue;
1600       }
1601 
1602       // No match found so we have to append this entry and any unique
1603       // referenced entries to *merge_cp_p.
1604       append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p,
<a name="8" id="anc8"></a><span class="line-modified">1605         CHECK_false);</span>
1606     }
1607 
1608     log_debug(redefine, class, constantpool)
1609       (&quot;after pass 1b: merge_cp_len=%d, scratch_i=%d, index_map_len=%d&quot;,
1610        *merge_cp_length_p, scratch_i, _index_map_count);
1611   }
1612   finalize_operands_merge(*merge_cp_p, THREAD);
1613 
1614   return true;
1615 } // end merge_constant_pools()
1616 
1617 
1618 // Scoped object to clean up the constant pool(s) created for merging
1619 class MergeCPCleaner {
1620   ClassLoaderData*   _loader_data;
1621   ConstantPool*      _cp;
1622   ConstantPool*      _scratch_cp;
1623  public:
1624   MergeCPCleaner(ClassLoaderData* loader_data, ConstantPool* merge_cp) :
1625                  _loader_data(loader_data), _cp(merge_cp), _scratch_cp(NULL) {}
1626   ~MergeCPCleaner() {
1627     _loader_data-&gt;add_to_deallocate_list(_cp);
1628     if (_scratch_cp != NULL) {
1629       _loader_data-&gt;add_to_deallocate_list(_scratch_cp);
1630     }
1631   }
1632   void add_scratch_cp(ConstantPool* scratch_cp) { _scratch_cp = scratch_cp; }
1633 };
1634 
1635 // Merge constant pools between the_class and scratch_class and
1636 // potentially rewrite bytecodes in scratch_class to use the merged
1637 // constant pool.
1638 jvmtiError VM_RedefineClasses::merge_cp_and_rewrite(
1639              InstanceKlass* the_class, InstanceKlass* scratch_class,
1640              TRAPS) {
1641   // worst case merged constant pool length is old and new combined
1642   int merge_cp_length = the_class-&gt;constants()-&gt;length()
1643         + scratch_class-&gt;constants()-&gt;length();
1644 
1645   // Constant pools are not easily reused so we allocate a new one
1646   // each time.
1647   // merge_cp is created unsafe for concurrent GC processing.  It
1648   // should be marked safe before discarding it. Even though
1649   // garbage,  if it crosses a card boundary, it may be scanned
1650   // in order to find the start of the first complete object on the card.
1651   ClassLoaderData* loader_data = the_class-&gt;class_loader_data();
1652   ConstantPool* merge_cp_oop =
1653     ConstantPool::allocate(loader_data,
1654                            merge_cp_length,
1655                            CHECK_(JVMTI_ERROR_OUT_OF_MEMORY));
1656   MergeCPCleaner cp_cleaner(loader_data, merge_cp_oop);
1657 
1658   HandleMark hm(THREAD);  // make sure handles are cleared before
1659                           // MergeCPCleaner clears out merge_cp_oop
1660   constantPoolHandle merge_cp(THREAD, merge_cp_oop);
1661 
1662   // Get constants() from the old class because it could have been rewritten
1663   // while we were at a safepoint allocating a new constant pool.
1664   constantPoolHandle old_cp(THREAD, the_class-&gt;constants());
1665   constantPoolHandle scratch_cp(THREAD, scratch_class-&gt;constants());
1666 
1667   // If the length changed, the class was redefined out from under us. Return
1668   // an error.
1669   if (merge_cp_length != the_class-&gt;constants()-&gt;length()
1670          + scratch_class-&gt;constants()-&gt;length()) {
1671     return JVMTI_ERROR_INTERNAL;
1672   }
1673 
1674   // Update the version number of the constant pools (may keep scratch_cp)
1675   merge_cp-&gt;increment_and_save_version(old_cp-&gt;version());
1676   scratch_cp-&gt;increment_and_save_version(old_cp-&gt;version());
1677 
1678   ResourceMark rm(THREAD);
1679   _index_map_count = 0;
1680   _index_map_p = new intArray(scratch_cp-&gt;length(), scratch_cp-&gt;length(), -1);
1681 
1682   _operands_cur_length = ConstantPool::operand_array_length(old_cp-&gt;operands());
1683   _operands_index_map_count = 0;
1684   int operands_index_map_len = ConstantPool::operand_array_length(scratch_cp-&gt;operands());
1685   _operands_index_map_p = new intArray(operands_index_map_len, operands_index_map_len, -1);
1686 
1687   // reference to the cp holder is needed for copy_operands()
1688   merge_cp-&gt;set_pool_holder(scratch_class);
1689   bool result = merge_constant_pools(old_cp, scratch_cp, &amp;merge_cp,
1690                   &amp;merge_cp_length, THREAD);
1691   merge_cp-&gt;set_pool_holder(NULL);
1692 
1693   if (!result) {
1694     // The merge can fail due to memory allocation failure or due
1695     // to robustness checks.
1696     return JVMTI_ERROR_INTERNAL;
1697   }
1698 
1699   if (old_cp-&gt;has_dynamic_constant()) {
1700     merge_cp-&gt;set_has_dynamic_constant();
1701     scratch_cp-&gt;set_has_dynamic_constant();
1702   }
1703 
1704   log_info(redefine, class, constantpool)(&quot;merge_cp_len=%d, index_map_len=%d&quot;, merge_cp_length, _index_map_count);
1705 
1706   if (_index_map_count == 0) {
1707     // there is nothing to map between the new and merged constant pools
1708 
1709     if (old_cp-&gt;length() == scratch_cp-&gt;length()) {
1710       // The old and new constant pools are the same length and the
1711       // index map is empty. This means that the three constant pools
1712       // are equivalent (but not the same). Unfortunately, the new
1713       // constant pool has not gone through link resolution nor have
1714       // the new class bytecodes gone through constant pool cache
1715       // rewriting so we can&#39;t use the old constant pool with the new
1716       // class.
1717 
1718       // toss the merged constant pool at return
1719     } else if (old_cp-&gt;length() &lt; scratch_cp-&gt;length()) {
1720       // The old constant pool has fewer entries than the new constant
1721       // pool and the index map is empty. This means the new constant
1722       // pool is a superset of the old constant pool. However, the old
1723       // class bytecodes have already gone through constant pool cache
1724       // rewriting so we can&#39;t use the new constant pool with the old
1725       // class.
1726 
1727       // toss the merged constant pool at return
1728     } else {
1729       // The old constant pool has more entries than the new constant
1730       // pool and the index map is empty. This means that both the old
1731       // and merged constant pools are supersets of the new constant
1732       // pool.
1733 
1734       // Replace the new constant pool with a shrunken copy of the
1735       // merged constant pool
1736       set_new_constant_pool(loader_data, scratch_class, merge_cp, merge_cp_length,
1737                             CHECK_(JVMTI_ERROR_OUT_OF_MEMORY));
1738       // The new constant pool replaces scratch_cp so have cleaner clean it up.
1739       // It can&#39;t be cleaned up while there are handles to it.
1740       cp_cleaner.add_scratch_cp(scratch_cp());
1741     }
1742   } else {
1743     if (log_is_enabled(Trace, redefine, class, constantpool)) {
1744       // don&#39;t want to loop unless we are tracing
1745       int count = 0;
1746       for (int i = 1; i &lt; _index_map_p-&gt;length(); i++) {
1747         int value = _index_map_p-&gt;at(i);
1748 
1749         if (value != -1) {
1750           log_trace(redefine, class, constantpool)(&quot;index_map[%d]: old=%d new=%d&quot;, count, i, value);
1751           count++;
1752         }
1753       }
1754     }
1755 
1756     // We have entries mapped between the new and merged constant pools
1757     // so we have to rewrite some constant pool references.
1758     if (!rewrite_cp_refs(scratch_class, THREAD)) {
1759       return JVMTI_ERROR_INTERNAL;
1760     }
1761 
1762     // Replace the new constant pool with a shrunken copy of the
1763     // merged constant pool so now the rewritten bytecodes have
1764     // valid references; the previous new constant pool will get
1765     // GCed.
1766     set_new_constant_pool(loader_data, scratch_class, merge_cp, merge_cp_length,
1767                           CHECK_(JVMTI_ERROR_OUT_OF_MEMORY));
1768     // The new constant pool replaces scratch_cp so have cleaner clean it up.
1769     // It can&#39;t be cleaned up while there are handles to it.
1770     cp_cleaner.add_scratch_cp(scratch_cp());
1771   }
1772 
1773   return JVMTI_ERROR_NONE;
1774 } // end merge_cp_and_rewrite()
1775 
1776 
1777 // Rewrite constant pool references in klass scratch_class.
1778 bool VM_RedefineClasses::rewrite_cp_refs(InstanceKlass* scratch_class,
1779        TRAPS) {
1780 
1781   // rewrite constant pool references in the nest attributes:
1782   if (!rewrite_cp_refs_in_nest_attributes(scratch_class)) {
1783     // propagate failure back to caller
1784     return false;
1785   }
1786 
1787   // rewrite constant pool references in the Record attribute:
1788   if (!rewrite_cp_refs_in_record_attribute(scratch_class, THREAD)) {
1789     // propagate failure back to caller
1790     return false;
1791   }
1792 
1793   // rewrite constant pool references in the methods:
1794   if (!rewrite_cp_refs_in_methods(scratch_class, THREAD)) {
1795     // propagate failure back to caller
1796     return false;
1797   }
1798 
1799   // rewrite constant pool references in the class_annotations:
1800   if (!rewrite_cp_refs_in_class_annotations(scratch_class, THREAD)) {
1801     // propagate failure back to caller
1802     return false;
1803   }
1804 
1805   // rewrite constant pool references in the fields_annotations:
1806   if (!rewrite_cp_refs_in_fields_annotations(scratch_class, THREAD)) {
1807     // propagate failure back to caller
1808     return false;
1809   }
1810 
1811   // rewrite constant pool references in the methods_annotations:
1812   if (!rewrite_cp_refs_in_methods_annotations(scratch_class, THREAD)) {
1813     // propagate failure back to caller
1814     return false;
1815   }
1816 
1817   // rewrite constant pool references in the methods_parameter_annotations:
1818   if (!rewrite_cp_refs_in_methods_parameter_annotations(scratch_class,
1819          THREAD)) {
1820     // propagate failure back to caller
1821     return false;
1822   }
1823 
1824   // rewrite constant pool references in the methods_default_annotations:
1825   if (!rewrite_cp_refs_in_methods_default_annotations(scratch_class,
1826          THREAD)) {
1827     // propagate failure back to caller
1828     return false;
1829   }
1830 
1831   // rewrite constant pool references in the class_type_annotations:
1832   if (!rewrite_cp_refs_in_class_type_annotations(scratch_class, THREAD)) {
1833     // propagate failure back to caller
1834     return false;
1835   }
1836 
1837   // rewrite constant pool references in the fields_type_annotations:
1838   if (!rewrite_cp_refs_in_fields_type_annotations(scratch_class, THREAD)) {
1839     // propagate failure back to caller
1840     return false;
1841   }
1842 
1843   // rewrite constant pool references in the methods_type_annotations:
1844   if (!rewrite_cp_refs_in_methods_type_annotations(scratch_class, THREAD)) {
1845     // propagate failure back to caller
1846     return false;
1847   }
1848 
1849   // There can be type annotations in the Code part of a method_info attribute.
1850   // These annotations are not accessible, even by reflection.
1851   // Currently they are not even parsed by the ClassFileParser.
1852   // If runtime access is added they will also need to be rewritten.
1853 
1854   // rewrite source file name index:
1855   u2 source_file_name_idx = scratch_class-&gt;source_file_name_index();
1856   if (source_file_name_idx != 0) {
1857     u2 new_source_file_name_idx = find_new_index(source_file_name_idx);
1858     if (new_source_file_name_idx != 0) {
1859       scratch_class-&gt;set_source_file_name_index(new_source_file_name_idx);
1860     }
1861   }
1862 
1863   // rewrite class generic signature index:
1864   u2 generic_signature_index = scratch_class-&gt;generic_signature_index();
1865   if (generic_signature_index != 0) {
1866     u2 new_generic_signature_index = find_new_index(generic_signature_index);
1867     if (new_generic_signature_index != 0) {
1868       scratch_class-&gt;set_generic_signature_index(new_generic_signature_index);
1869     }
1870   }
1871 
1872   return true;
1873 } // end rewrite_cp_refs()
1874 
1875 // Rewrite constant pool references in the NestHost and NestMembers attributes.
1876 bool VM_RedefineClasses::rewrite_cp_refs_in_nest_attributes(
1877        InstanceKlass* scratch_class) {
1878 
1879   u2 cp_index = scratch_class-&gt;nest_host_index();
1880   if (cp_index != 0) {
1881     scratch_class-&gt;set_nest_host_index(find_new_index(cp_index));
1882   }
1883   Array&lt;u2&gt;* nest_members = scratch_class-&gt;nest_members();
1884   for (int i = 0; i &lt; nest_members-&gt;length(); i++) {
1885     u2 cp_index = nest_members-&gt;at(i);
1886     nest_members-&gt;at_put(i, find_new_index(cp_index));
1887   }
1888   return true;
1889 }
1890 
1891 // Rewrite constant pool references in the Record attribute.
1892 bool VM_RedefineClasses::rewrite_cp_refs_in_record_attribute(
1893        InstanceKlass* scratch_class, TRAPS) {
1894   Array&lt;RecordComponent*&gt;* components = scratch_class-&gt;record_components();
1895   if (components != NULL) {
1896     for (int i = 0; i &lt; components-&gt;length(); i++) {
1897       RecordComponent* component = components-&gt;at(i);
1898       u2 cp_index = component-&gt;name_index();
1899       component-&gt;set_name_index(find_new_index(cp_index));
1900       cp_index = component-&gt;descriptor_index();
1901       component-&gt;set_descriptor_index(find_new_index(cp_index));
1902       cp_index = component-&gt;generic_signature_index();
1903       if (cp_index != 0) {
1904         component-&gt;set_generic_signature_index(find_new_index(cp_index));
1905       }
1906 
1907       AnnotationArray* annotations = component-&gt;annotations();
1908       if (annotations != NULL &amp;&amp; annotations-&gt;length() != 0) {
1909         int byte_i = 0;  // byte index into annotations
1910         if (!rewrite_cp_refs_in_annotations_typeArray(annotations, byte_i, THREAD)) {
1911           log_debug(redefine, class, annotation)(&quot;bad record_component_annotations at %d&quot;, i);
1912           // propagate failure back to caller
1913           return false;
1914         }
1915       }
1916 
1917       AnnotationArray* type_annotations = component-&gt;type_annotations();
1918       if (type_annotations != NULL &amp;&amp; type_annotations-&gt;length() != 0) {
1919         int byte_i = 0;  // byte index into annotations
1920         if (!rewrite_cp_refs_in_annotations_typeArray(type_annotations, byte_i, THREAD)) {
1921           log_debug(redefine, class, annotation)(&quot;bad record_component_type_annotations at %d&quot;, i);
1922           // propagate failure back to caller
1923           return false;
1924         }
1925       }
1926     }
1927   }
1928   return true;
1929 }
1930 
1931 // Rewrite constant pool references in the methods.
1932 bool VM_RedefineClasses::rewrite_cp_refs_in_methods(
1933        InstanceKlass* scratch_class, TRAPS) {
1934 
1935   Array&lt;Method*&gt;* methods = scratch_class-&gt;methods();
1936 
1937   if (methods == NULL || methods-&gt;length() == 0) {
1938     // no methods so nothing to do
1939     return true;
1940   }
1941 
1942   // rewrite constant pool references in the methods:
1943   for (int i = methods-&gt;length() - 1; i &gt;= 0; i--) {
1944     methodHandle method(THREAD, methods-&gt;at(i));
1945     methodHandle new_method;
1946     rewrite_cp_refs_in_method(method, &amp;new_method, THREAD);
1947     if (!new_method.is_null()) {
1948       // the method has been replaced so save the new method version
1949       // even in the case of an exception.  original method is on the
1950       // deallocation list.
1951       methods-&gt;at_put(i, new_method());
1952     }
1953     if (HAS_PENDING_EXCEPTION) {
1954       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1955       log_info(redefine, class, load, exceptions)(&quot;rewrite_cp_refs_in_method exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1956       // Need to clear pending exception here as the super caller sets
1957       // the JVMTI_ERROR_INTERNAL if the returned value is false.
1958       CLEAR_PENDING_EXCEPTION;
1959       return false;
1960     }
1961   }
1962 
1963   return true;
1964 }
1965 
1966 
1967 // Rewrite constant pool references in the specific method. This code
1968 // was adapted from Rewriter::rewrite_method().
1969 void VM_RedefineClasses::rewrite_cp_refs_in_method(methodHandle method,
1970        methodHandle *new_method_p, TRAPS) {
1971 
1972   *new_method_p = methodHandle();  // default is no new method
1973 
1974   // We cache a pointer to the bytecodes here in code_base. If GC
1975   // moves the Method*, then the bytecodes will also move which
1976   // will likely cause a crash. We create a NoSafepointVerifier
1977   // object to detect whether we pass a possible safepoint in this
1978   // code block.
1979   NoSafepointVerifier nsv;
1980 
1981   // Bytecodes and their length
1982   address code_base = method-&gt;code_base();
1983   int code_length = method-&gt;code_size();
1984 
1985   int bc_length;
1986   for (int bci = 0; bci &lt; code_length; bci += bc_length) {
1987     address bcp = code_base + bci;
1988     Bytecodes::Code c = (Bytecodes::Code)(*bcp);
1989 
1990     bc_length = Bytecodes::length_for(c);
1991     if (bc_length == 0) {
1992       // More complicated bytecodes report a length of zero so
1993       // we have to try again a slightly different way.
1994       bc_length = Bytecodes::length_at(method(), bcp);
1995     }
1996 
1997     assert(bc_length != 0, &quot;impossible bytecode length&quot;);
1998 
1999     switch (c) {
2000       case Bytecodes::_ldc:
2001       {
2002         int cp_index = *(bcp + 1);
2003         int new_index = find_new_index(cp_index);
2004 
2005         if (StressLdcRewrite &amp;&amp; new_index == 0) {
2006           // If we are stressing ldc -&gt; ldc_w rewriting, then we
2007           // always need a new_index value.
2008           new_index = cp_index;
2009         }
2010         if (new_index != 0) {
2011           // the original index is mapped so we have more work to do
2012           if (!StressLdcRewrite &amp;&amp; new_index &lt;= max_jubyte) {
2013             // The new value can still use ldc instead of ldc_w
2014             // unless we are trying to stress ldc -&gt; ldc_w rewriting
2015             log_trace(redefine, class, constantpool)
2016               (&quot;%s@&quot; INTPTR_FORMAT &quot; old=%d, new=%d&quot;, Bytecodes::name(c), p2i(bcp), cp_index, new_index);
2017             *(bcp + 1) = new_index;
2018           } else {
2019             log_trace(redefine, class, constantpool)
2020               (&quot;%s-&gt;ldc_w@&quot; INTPTR_FORMAT &quot; old=%d, new=%d&quot;, Bytecodes::name(c), p2i(bcp), cp_index, new_index);
2021             // the new value needs ldc_w instead of ldc
2022             u_char inst_buffer[4]; // max instruction size is 4 bytes
2023             bcp = (address)inst_buffer;
2024             // construct new instruction sequence
2025             *bcp = Bytecodes::_ldc_w;
2026             bcp++;
2027             // Rewriter::rewrite_method() does not rewrite ldc -&gt; ldc_w.
2028             // See comment below for difference between put_Java_u2()
2029             // and put_native_u2().
2030             Bytes::put_Java_u2(bcp, new_index);
2031 
2032             Relocator rc(method, NULL /* no RelocatorListener needed */);
2033             methodHandle m;
2034             {
2035               PauseNoSafepointVerifier pnsv(&amp;nsv);
2036 
2037               // ldc is 2 bytes and ldc_w is 3 bytes
2038               m = rc.insert_space_at(bci, 3, inst_buffer, CHECK);
2039             }
2040 
2041             // return the new method so that the caller can update
2042             // the containing class
2043             *new_method_p = method = m;
2044             // switch our bytecode processing loop from the old method
2045             // to the new method
2046             code_base = method-&gt;code_base();
2047             code_length = method-&gt;code_size();
2048             bcp = code_base + bci;
2049             c = (Bytecodes::Code)(*bcp);
2050             bc_length = Bytecodes::length_for(c);
2051             assert(bc_length != 0, &quot;sanity check&quot;);
2052           } // end we need ldc_w instead of ldc
2053         } // end if there is a mapped index
2054       } break;
2055 
2056       // these bytecodes have a two-byte constant pool index
2057       case Bytecodes::_anewarray      : // fall through
2058       case Bytecodes::_checkcast      : // fall through
2059       case Bytecodes::_getfield       : // fall through
2060       case Bytecodes::_getstatic      : // fall through
2061       case Bytecodes::_instanceof     : // fall through
2062       case Bytecodes::_invokedynamic  : // fall through
2063       case Bytecodes::_invokeinterface: // fall through
2064       case Bytecodes::_invokespecial  : // fall through
2065       case Bytecodes::_invokestatic   : // fall through
2066       case Bytecodes::_invokevirtual  : // fall through
2067       case Bytecodes::_ldc_w          : // fall through
2068       case Bytecodes::_ldc2_w         : // fall through
2069       case Bytecodes::_multianewarray : // fall through
2070       case Bytecodes::_new            : // fall through
2071       case Bytecodes::_putfield       : // fall through
2072       case Bytecodes::_putstatic      :
2073       {
2074         address p = bcp + 1;
2075         int cp_index = Bytes::get_Java_u2(p);
2076         int new_index = find_new_index(cp_index);
2077         if (new_index != 0) {
2078           // the original index is mapped so update w/ new value
2079           log_trace(redefine, class, constantpool)
2080             (&quot;%s@&quot; INTPTR_FORMAT &quot; old=%d, new=%d&quot;, Bytecodes::name(c),p2i(bcp), cp_index, new_index);
2081           // Rewriter::rewrite_method() uses put_native_u2() in this
2082           // situation because it is reusing the constant pool index
2083           // location for a native index into the ConstantPoolCache.
2084           // Since we are updating the constant pool index prior to
2085           // verification and ConstantPoolCache initialization, we
2086           // need to keep the new index in Java byte order.
2087           Bytes::put_Java_u2(p, new_index);
2088         }
2089       } break;
2090       default:
2091         break;
2092     }
2093   } // end for each bytecode
2094 
2095   // We also need to rewrite the parameter name indexes, if there is
2096   // method parameter data present
2097   if(method-&gt;has_method_parameters()) {
2098     const int len = method-&gt;method_parameters_length();
2099     MethodParametersElement* elem = method-&gt;method_parameters_start();
2100 
2101     for (int i = 0; i &lt; len; i++) {
2102       const u2 cp_index = elem[i].name_cp_index;
2103       const u2 new_cp_index = find_new_index(cp_index);
2104       if (new_cp_index != 0) {
2105         elem[i].name_cp_index = new_cp_index;
2106       }
2107     }
2108   }
2109 } // end rewrite_cp_refs_in_method()
2110 
2111 
2112 // Rewrite constant pool references in the class_annotations field.
2113 bool VM_RedefineClasses::rewrite_cp_refs_in_class_annotations(
2114        InstanceKlass* scratch_class, TRAPS) {
2115 
2116   AnnotationArray* class_annotations = scratch_class-&gt;class_annotations();
2117   if (class_annotations == NULL || class_annotations-&gt;length() == 0) {
2118     // no class_annotations so nothing to do
2119     return true;
2120   }
2121 
2122   log_debug(redefine, class, annotation)(&quot;class_annotations length=%d&quot;, class_annotations-&gt;length());
2123 
2124   int byte_i = 0;  // byte index into class_annotations
2125   return rewrite_cp_refs_in_annotations_typeArray(class_annotations, byte_i,
2126            THREAD);
2127 }
2128 
2129 
2130 // Rewrite constant pool references in an annotations typeArray. This
2131 // &quot;structure&quot; is adapted from the RuntimeVisibleAnnotations_attribute
2132 // that is described in section 4.8.15 of the 2nd-edition of the VM spec:
2133 //
2134 // annotations_typeArray {
2135 //   u2 num_annotations;
2136 //   annotation annotations[num_annotations];
2137 // }
2138 //
2139 bool VM_RedefineClasses::rewrite_cp_refs_in_annotations_typeArray(
2140        AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
2141 
2142   if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2143     // not enough room for num_annotations field
2144     log_debug(redefine, class, annotation)(&quot;length() is too small for num_annotations field&quot;);
2145     return false;
2146   }
2147 
2148   u2 num_annotations = Bytes::get_Java_u2((address)
2149                          annotations_typeArray-&gt;adr_at(byte_i_ref));
2150   byte_i_ref += 2;
2151 
2152   log_debug(redefine, class, annotation)(&quot;num_annotations=%d&quot;, num_annotations);
2153 
2154   int calc_num_annotations = 0;
2155   for (; calc_num_annotations &lt; num_annotations; calc_num_annotations++) {
2156     if (!rewrite_cp_refs_in_annotation_struct(annotations_typeArray,
2157            byte_i_ref, THREAD)) {
2158       log_debug(redefine, class, annotation)(&quot;bad annotation_struct at %d&quot;, calc_num_annotations);
2159       // propagate failure back to caller
2160       return false;
2161     }
2162   }
2163   assert(num_annotations == calc_num_annotations, &quot;sanity check&quot;);
2164 
2165   return true;
2166 } // end rewrite_cp_refs_in_annotations_typeArray()
2167 
2168 
2169 // Rewrite constant pool references in the annotation struct portion of
2170 // an annotations_typeArray. This &quot;structure&quot; is from section 4.8.15 of
2171 // the 2nd-edition of the VM spec:
2172 //
2173 // struct annotation {
2174 //   u2 type_index;
2175 //   u2 num_element_value_pairs;
2176 //   {
2177 //     u2 element_name_index;
2178 //     element_value value;
2179 //   } element_value_pairs[num_element_value_pairs];
2180 // }
2181 //
2182 bool VM_RedefineClasses::rewrite_cp_refs_in_annotation_struct(
2183        AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
2184   if ((byte_i_ref + 2 + 2) &gt; annotations_typeArray-&gt;length()) {
2185     // not enough room for smallest annotation_struct
2186     log_debug(redefine, class, annotation)(&quot;length() is too small for annotation_struct&quot;);
2187     return false;
2188   }
2189 
2190   u2 type_index = rewrite_cp_ref_in_annotation_data(annotations_typeArray,
2191                     byte_i_ref, &quot;type_index&quot;, THREAD);
2192 
2193   u2 num_element_value_pairs = Bytes::get_Java_u2((address)
2194                                  annotations_typeArray-&gt;adr_at(byte_i_ref));
2195   byte_i_ref += 2;
2196 
2197   log_debug(redefine, class, annotation)
2198     (&quot;type_index=%d  num_element_value_pairs=%d&quot;, type_index, num_element_value_pairs);
2199 
2200   int calc_num_element_value_pairs = 0;
2201   for (; calc_num_element_value_pairs &lt; num_element_value_pairs;
2202        calc_num_element_value_pairs++) {
2203     if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2204       // not enough room for another element_name_index, let alone
2205       // the rest of another component
2206       log_debug(redefine, class, annotation)(&quot;length() is too small for element_name_index&quot;);
2207       return false;
2208     }
2209 
2210     u2 element_name_index = rewrite_cp_ref_in_annotation_data(
2211                               annotations_typeArray, byte_i_ref,
2212                               &quot;element_name_index&quot;, THREAD);
2213 
2214     log_debug(redefine, class, annotation)(&quot;element_name_index=%d&quot;, element_name_index);
2215 
2216     if (!rewrite_cp_refs_in_element_value(annotations_typeArray,
2217            byte_i_ref, THREAD)) {
2218       log_debug(redefine, class, annotation)(&quot;bad element_value at %d&quot;, calc_num_element_value_pairs);
2219       // propagate failure back to caller
2220       return false;
2221     }
2222   } // end for each component
2223   assert(num_element_value_pairs == calc_num_element_value_pairs,
2224     &quot;sanity check&quot;);
2225 
2226   return true;
2227 } // end rewrite_cp_refs_in_annotation_struct()
2228 
2229 
2230 // Rewrite a constant pool reference at the current position in
2231 // annotations_typeArray if needed. Returns the original constant
2232 // pool reference if a rewrite was not needed or the new constant
2233 // pool reference if a rewrite was needed.
2234 u2 VM_RedefineClasses::rewrite_cp_ref_in_annotation_data(
2235      AnnotationArray* annotations_typeArray, int &amp;byte_i_ref,
2236      const char * trace_mesg, TRAPS) {
2237 
2238   address cp_index_addr = (address)
2239     annotations_typeArray-&gt;adr_at(byte_i_ref);
2240   u2 old_cp_index = Bytes::get_Java_u2(cp_index_addr);
2241   u2 new_cp_index = find_new_index(old_cp_index);
2242   if (new_cp_index != 0) {
2243     log_debug(redefine, class, annotation)(&quot;mapped old %s=%d&quot;, trace_mesg, old_cp_index);
2244     Bytes::put_Java_u2(cp_index_addr, new_cp_index);
2245     old_cp_index = new_cp_index;
2246   }
2247   byte_i_ref += 2;
2248   return old_cp_index;
2249 }
2250 
2251 
2252 // Rewrite constant pool references in the element_value portion of an
2253 // annotations_typeArray. This &quot;structure&quot; is from section 4.8.15.1 of
2254 // the 2nd-edition of the VM spec:
2255 //
2256 // struct element_value {
2257 //   u1 tag;
2258 //   union {
2259 //     u2 const_value_index;
2260 //     {
2261 //       u2 type_name_index;
2262 //       u2 const_name_index;
2263 //     } enum_const_value;
2264 //     u2 class_info_index;
2265 //     annotation annotation_value;
2266 //     struct {
2267 //       u2 num_values;
2268 //       element_value values[num_values];
2269 //     } array_value;
2270 //   } value;
2271 // }
2272 //
2273 bool VM_RedefineClasses::rewrite_cp_refs_in_element_value(
2274        AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
2275 
2276   if ((byte_i_ref + 1) &gt; annotations_typeArray-&gt;length()) {
2277     // not enough room for a tag let alone the rest of an element_value
2278     log_debug(redefine, class, annotation)(&quot;length() is too small for a tag&quot;);
2279     return false;
2280   }
2281 
2282   u1 tag = annotations_typeArray-&gt;at(byte_i_ref);
2283   byte_i_ref++;
2284   log_debug(redefine, class, annotation)(&quot;tag=&#39;%c&#39;&quot;, tag);
2285 
2286   switch (tag) {
2287     // These BaseType tag values are from Table 4.2 in VM spec:
2288     case JVM_SIGNATURE_BYTE:
2289     case JVM_SIGNATURE_CHAR:
2290     case JVM_SIGNATURE_DOUBLE:
2291     case JVM_SIGNATURE_FLOAT:
2292     case JVM_SIGNATURE_INT:
2293     case JVM_SIGNATURE_LONG:
2294     case JVM_SIGNATURE_SHORT:
2295     case JVM_SIGNATURE_BOOLEAN:
2296 
2297     // The remaining tag values are from Table 4.8 in the 2nd-edition of
2298     // the VM spec:
2299     case &#39;s&#39;:
2300     {
2301       // For the above tag values (including the BaseType values),
2302       // value.const_value_index is right union field.
2303 
2304       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2305         // not enough room for a const_value_index
2306         log_debug(redefine, class, annotation)(&quot;length() is too small for a const_value_index&quot;);
2307         return false;
2308       }
2309 
2310       u2 const_value_index = rewrite_cp_ref_in_annotation_data(
2311                                annotations_typeArray, byte_i_ref,
2312                                &quot;const_value_index&quot;, THREAD);
2313 
2314       log_debug(redefine, class, annotation)(&quot;const_value_index=%d&quot;, const_value_index);
2315     } break;
2316 
2317     case &#39;e&#39;:
2318     {
2319       // for the above tag value, value.enum_const_value is right union field
2320 
2321       if ((byte_i_ref + 4) &gt; annotations_typeArray-&gt;length()) {
2322         // not enough room for a enum_const_value
2323         log_debug(redefine, class, annotation)(&quot;length() is too small for a enum_const_value&quot;);
2324         return false;
2325       }
2326 
2327       u2 type_name_index = rewrite_cp_ref_in_annotation_data(
2328                              annotations_typeArray, byte_i_ref,
2329                              &quot;type_name_index&quot;, THREAD);
2330 
2331       u2 const_name_index = rewrite_cp_ref_in_annotation_data(
2332                               annotations_typeArray, byte_i_ref,
2333                               &quot;const_name_index&quot;, THREAD);
2334 
2335       log_debug(redefine, class, annotation)
2336         (&quot;type_name_index=%d  const_name_index=%d&quot;, type_name_index, const_name_index);
2337     } break;
2338 
2339     case &#39;c&#39;:
2340     {
2341       // for the above tag value, value.class_info_index is right union field
2342 
2343       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2344         // not enough room for a class_info_index
2345         log_debug(redefine, class, annotation)(&quot;length() is too small for a class_info_index&quot;);
2346         return false;
2347       }
2348 
2349       u2 class_info_index = rewrite_cp_ref_in_annotation_data(
2350                               annotations_typeArray, byte_i_ref,
2351                               &quot;class_info_index&quot;, THREAD);
2352 
2353       log_debug(redefine, class, annotation)(&quot;class_info_index=%d&quot;, class_info_index);
2354     } break;
2355 
2356     case &#39;@&#39;:
2357       // For the above tag value, value.attr_value is the right union
2358       // field. This is a nested annotation.
2359       if (!rewrite_cp_refs_in_annotation_struct(annotations_typeArray,
2360              byte_i_ref, THREAD)) {
2361         // propagate failure back to caller
2362         return false;
2363       }
2364       break;
2365 
2366     case JVM_SIGNATURE_ARRAY:
2367     {
2368       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2369         // not enough room for a num_values field
2370         log_debug(redefine, class, annotation)(&quot;length() is too small for a num_values field&quot;);
2371         return false;
2372       }
2373 
2374       // For the above tag value, value.array_value is the right union
2375       // field. This is an array of nested element_value.
2376       u2 num_values = Bytes::get_Java_u2((address)
2377                         annotations_typeArray-&gt;adr_at(byte_i_ref));
2378       byte_i_ref += 2;
2379       log_debug(redefine, class, annotation)(&quot;num_values=%d&quot;, num_values);
2380 
2381       int calc_num_values = 0;
2382       for (; calc_num_values &lt; num_values; calc_num_values++) {
2383         if (!rewrite_cp_refs_in_element_value(
2384                annotations_typeArray, byte_i_ref, THREAD)) {
2385           log_debug(redefine, class, annotation)(&quot;bad nested element_value at %d&quot;, calc_num_values);
2386           // propagate failure back to caller
2387           return false;
2388         }
2389       }
2390       assert(num_values == calc_num_values, &quot;sanity check&quot;);
2391     } break;
2392 
2393     default:
2394       log_debug(redefine, class, annotation)(&quot;bad tag=0x%x&quot;, tag);
2395       return false;
2396   } // end decode tag field
2397 
2398   return true;
2399 } // end rewrite_cp_refs_in_element_value()
2400 
2401 
2402 // Rewrite constant pool references in a fields_annotations field.
2403 bool VM_RedefineClasses::rewrite_cp_refs_in_fields_annotations(
2404        InstanceKlass* scratch_class, TRAPS) {
2405 
2406   Array&lt;AnnotationArray*&gt;* fields_annotations = scratch_class-&gt;fields_annotations();
2407 
2408   if (fields_annotations == NULL || fields_annotations-&gt;length() == 0) {
2409     // no fields_annotations so nothing to do
2410     return true;
2411   }
2412 
2413   log_debug(redefine, class, annotation)(&quot;fields_annotations length=%d&quot;, fields_annotations-&gt;length());
2414 
2415   for (int i = 0; i &lt; fields_annotations-&gt;length(); i++) {
2416     AnnotationArray* field_annotations = fields_annotations-&gt;at(i);
2417     if (field_annotations == NULL || field_annotations-&gt;length() == 0) {
2418       // this field does not have any annotations so skip it
2419       continue;
2420     }
2421 
2422     int byte_i = 0;  // byte index into field_annotations
2423     if (!rewrite_cp_refs_in_annotations_typeArray(field_annotations, byte_i,
2424            THREAD)) {
2425       log_debug(redefine, class, annotation)(&quot;bad field_annotations at %d&quot;, i);
2426       // propagate failure back to caller
2427       return false;
2428     }
2429   }
2430 
2431   return true;
2432 } // end rewrite_cp_refs_in_fields_annotations()
2433 
2434 
2435 // Rewrite constant pool references in a methods_annotations field.
2436 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_annotations(
2437        InstanceKlass* scratch_class, TRAPS) {
2438 
2439   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2440     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2441     AnnotationArray* method_annotations = m-&gt;constMethod()-&gt;method_annotations();
2442 
2443     if (method_annotations == NULL || method_annotations-&gt;length() == 0) {
2444       // this method does not have any annotations so skip it
2445       continue;
2446     }
2447 
2448     int byte_i = 0;  // byte index into method_annotations
2449     if (!rewrite_cp_refs_in_annotations_typeArray(method_annotations, byte_i,
2450            THREAD)) {
2451       log_debug(redefine, class, annotation)(&quot;bad method_annotations at %d&quot;, i);
2452       // propagate failure back to caller
2453       return false;
2454     }
2455   }
2456 
2457   return true;
2458 } // end rewrite_cp_refs_in_methods_annotations()
2459 
2460 
2461 // Rewrite constant pool references in a methods_parameter_annotations
2462 // field. This &quot;structure&quot; is adapted from the
2463 // RuntimeVisibleParameterAnnotations_attribute described in section
2464 // 4.8.17 of the 2nd-edition of the VM spec:
2465 //
2466 // methods_parameter_annotations_typeArray {
2467 //   u1 num_parameters;
2468 //   {
2469 //     u2 num_annotations;
2470 //     annotation annotations[num_annotations];
2471 //   } parameter_annotations[num_parameters];
2472 // }
2473 //
2474 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_parameter_annotations(
2475        InstanceKlass* scratch_class, TRAPS) {
2476 
2477   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2478     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2479     AnnotationArray* method_parameter_annotations = m-&gt;constMethod()-&gt;parameter_annotations();
2480     if (method_parameter_annotations == NULL
2481         || method_parameter_annotations-&gt;length() == 0) {
2482       // this method does not have any parameter annotations so skip it
2483       continue;
2484     }
2485 
2486     if (method_parameter_annotations-&gt;length() &lt; 1) {
2487       // not enough room for a num_parameters field
2488       log_debug(redefine, class, annotation)(&quot;length() is too small for a num_parameters field at %d&quot;, i);
2489       return false;
2490     }
2491 
2492     int byte_i = 0;  // byte index into method_parameter_annotations
2493 
2494     u1 num_parameters = method_parameter_annotations-&gt;at(byte_i);
2495     byte_i++;
2496 
2497     log_debug(redefine, class, annotation)(&quot;num_parameters=%d&quot;, num_parameters);
2498 
2499     int calc_num_parameters = 0;
2500     for (; calc_num_parameters &lt; num_parameters; calc_num_parameters++) {
2501       if (!rewrite_cp_refs_in_annotations_typeArray(
2502              method_parameter_annotations, byte_i, THREAD)) {
2503         log_debug(redefine, class, annotation)(&quot;bad method_parameter_annotations at %d&quot;, calc_num_parameters);
2504         // propagate failure back to caller
2505         return false;
2506       }
2507     }
2508     assert(num_parameters == calc_num_parameters, &quot;sanity check&quot;);
2509   }
2510 
2511   return true;
2512 } // end rewrite_cp_refs_in_methods_parameter_annotations()
2513 
2514 
2515 // Rewrite constant pool references in a methods_default_annotations
2516 // field. This &quot;structure&quot; is adapted from the AnnotationDefault_attribute
2517 // that is described in section 4.8.19 of the 2nd-edition of the VM spec:
2518 //
2519 // methods_default_annotations_typeArray {
2520 //   element_value default_value;
2521 // }
2522 //
2523 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_default_annotations(
2524        InstanceKlass* scratch_class, TRAPS) {
2525 
2526   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2527     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2528     AnnotationArray* method_default_annotations = m-&gt;constMethod()-&gt;default_annotations();
2529     if (method_default_annotations == NULL
2530         || method_default_annotations-&gt;length() == 0) {
2531       // this method does not have any default annotations so skip it
2532       continue;
2533     }
2534 
2535     int byte_i = 0;  // byte index into method_default_annotations
2536 
2537     if (!rewrite_cp_refs_in_element_value(
2538            method_default_annotations, byte_i, THREAD)) {
2539       log_debug(redefine, class, annotation)(&quot;bad default element_value at %d&quot;, i);
2540       // propagate failure back to caller
2541       return false;
2542     }
2543   }
2544 
2545   return true;
2546 } // end rewrite_cp_refs_in_methods_default_annotations()
2547 
2548 
2549 // Rewrite constant pool references in a class_type_annotations field.
2550 bool VM_RedefineClasses::rewrite_cp_refs_in_class_type_annotations(
2551        InstanceKlass* scratch_class, TRAPS) {
2552 
2553   AnnotationArray* class_type_annotations = scratch_class-&gt;class_type_annotations();
2554   if (class_type_annotations == NULL || class_type_annotations-&gt;length() == 0) {
2555     // no class_type_annotations so nothing to do
2556     return true;
2557   }
2558 
2559   log_debug(redefine, class, annotation)(&quot;class_type_annotations length=%d&quot;, class_type_annotations-&gt;length());
2560 
2561   int byte_i = 0;  // byte index into class_type_annotations
2562   return rewrite_cp_refs_in_type_annotations_typeArray(class_type_annotations,
2563       byte_i, &quot;ClassFile&quot;, THREAD);
2564 } // end rewrite_cp_refs_in_class_type_annotations()
2565 
2566 
2567 // Rewrite constant pool references in a fields_type_annotations field.
2568 bool VM_RedefineClasses::rewrite_cp_refs_in_fields_type_annotations(
2569        InstanceKlass* scratch_class, TRAPS) {
2570 
2571   Array&lt;AnnotationArray*&gt;* fields_type_annotations = scratch_class-&gt;fields_type_annotations();
2572   if (fields_type_annotations == NULL || fields_type_annotations-&gt;length() == 0) {
2573     // no fields_type_annotations so nothing to do
2574     return true;
2575   }
2576 
2577   log_debug(redefine, class, annotation)(&quot;fields_type_annotations length=%d&quot;, fields_type_annotations-&gt;length());
2578 
2579   for (int i = 0; i &lt; fields_type_annotations-&gt;length(); i++) {
2580     AnnotationArray* field_type_annotations = fields_type_annotations-&gt;at(i);
2581     if (field_type_annotations == NULL || field_type_annotations-&gt;length() == 0) {
2582       // this field does not have any annotations so skip it
2583       continue;
2584     }
2585 
2586     int byte_i = 0;  // byte index into field_type_annotations
2587     if (!rewrite_cp_refs_in_type_annotations_typeArray(field_type_annotations,
2588            byte_i, &quot;field_info&quot;, THREAD)) {
2589       log_debug(redefine, class, annotation)(&quot;bad field_type_annotations at %d&quot;, i);
2590       // propagate failure back to caller
2591       return false;
2592     }
2593   }
2594 
2595   return true;
2596 } // end rewrite_cp_refs_in_fields_type_annotations()
2597 
2598 
2599 // Rewrite constant pool references in a methods_type_annotations field.
2600 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_type_annotations(
2601        InstanceKlass* scratch_class, TRAPS) {
2602 
2603   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2604     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2605     AnnotationArray* method_type_annotations = m-&gt;constMethod()-&gt;type_annotations();
2606 
2607     if (method_type_annotations == NULL || method_type_annotations-&gt;length() == 0) {
2608       // this method does not have any annotations so skip it
2609       continue;
2610     }
2611 
2612     log_debug(redefine, class, annotation)(&quot;methods type_annotations length=%d&quot;, method_type_annotations-&gt;length());
2613 
2614     int byte_i = 0;  // byte index into method_type_annotations
2615     if (!rewrite_cp_refs_in_type_annotations_typeArray(method_type_annotations,
2616            byte_i, &quot;method_info&quot;, THREAD)) {
2617       log_debug(redefine, class, annotation)(&quot;bad method_type_annotations at %d&quot;, i);
2618       // propagate failure back to caller
2619       return false;
2620     }
2621   }
2622 
2623   return true;
2624 } // end rewrite_cp_refs_in_methods_type_annotations()
2625 
2626 
2627 // Rewrite constant pool references in a type_annotations
2628 // field. This &quot;structure&quot; is adapted from the
2629 // RuntimeVisibleTypeAnnotations_attribute described in
2630 // section 4.7.20 of the Java SE 8 Edition of the VM spec:
2631 //
2632 // type_annotations_typeArray {
2633 //   u2              num_annotations;
2634 //   type_annotation annotations[num_annotations];
2635 // }
2636 //
2637 bool VM_RedefineClasses::rewrite_cp_refs_in_type_annotations_typeArray(
2638        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
2639        const char * location_mesg, TRAPS) {
2640 
2641   if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2642     // not enough room for num_annotations field
2643     log_debug(redefine, class, annotation)(&quot;length() is too small for num_annotations field&quot;);
2644     return false;
2645   }
2646 
2647   u2 num_annotations = Bytes::get_Java_u2((address)
2648                          type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2649   byte_i_ref += 2;
2650 
2651   log_debug(redefine, class, annotation)(&quot;num_type_annotations=%d&quot;, num_annotations);
2652 
2653   int calc_num_annotations = 0;
2654   for (; calc_num_annotations &lt; num_annotations; calc_num_annotations++) {
2655     if (!rewrite_cp_refs_in_type_annotation_struct(type_annotations_typeArray,
2656            byte_i_ref, location_mesg, THREAD)) {
2657       log_debug(redefine, class, annotation)(&quot;bad type_annotation_struct at %d&quot;, calc_num_annotations);
2658       // propagate failure back to caller
2659       return false;
2660     }
2661   }
2662   assert(num_annotations == calc_num_annotations, &quot;sanity check&quot;);
2663 
2664   if (byte_i_ref != type_annotations_typeArray-&gt;length()) {
2665     log_debug(redefine, class, annotation)
2666       (&quot;read wrong amount of bytes at end of processing type_annotations_typeArray (%d of %d bytes were read)&quot;,
2667        byte_i_ref, type_annotations_typeArray-&gt;length());
2668     return false;
2669   }
2670 
2671   return true;
2672 } // end rewrite_cp_refs_in_type_annotations_typeArray()
2673 
2674 
2675 // Rewrite constant pool references in a type_annotation
2676 // field. This &quot;structure&quot; is adapted from the
2677 // RuntimeVisibleTypeAnnotations_attribute described in
2678 // section 4.7.20 of the Java SE 8 Edition of the VM spec:
2679 //
2680 // type_annotation {
2681 //   u1 target_type;
2682 //   union {
2683 //     type_parameter_target;
2684 //     supertype_target;
2685 //     type_parameter_bound_target;
2686 //     empty_target;
2687 //     method_formal_parameter_target;
2688 //     throws_target;
2689 //     localvar_target;
2690 //     catch_target;
2691 //     offset_target;
2692 //     type_argument_target;
2693 //   } target_info;
2694 //   type_path target_path;
2695 //   annotation anno;
2696 // }
2697 //
2698 bool VM_RedefineClasses::rewrite_cp_refs_in_type_annotation_struct(
2699        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
2700        const char * location_mesg, TRAPS) {
2701 
2702   if (!skip_type_annotation_target(type_annotations_typeArray,
2703          byte_i_ref, location_mesg, THREAD)) {
2704     return false;
2705   }
2706 
2707   if (!skip_type_annotation_type_path(type_annotations_typeArray,
2708          byte_i_ref, THREAD)) {
2709     return false;
2710   }
2711 
2712   if (!rewrite_cp_refs_in_annotation_struct(type_annotations_typeArray,
2713          byte_i_ref, THREAD)) {
2714     return false;
2715   }
2716 
2717   return true;
2718 } // end rewrite_cp_refs_in_type_annotation_struct()
2719 
2720 
2721 // Read, verify and skip over the target_type and target_info part
2722 // so that rewriting can continue in the later parts of the struct.
2723 //
2724 // u1 target_type;
2725 // union {
2726 //   type_parameter_target;
2727 //   supertype_target;
2728 //   type_parameter_bound_target;
2729 //   empty_target;
2730 //   method_formal_parameter_target;
2731 //   throws_target;
2732 //   localvar_target;
2733 //   catch_target;
2734 //   offset_target;
2735 //   type_argument_target;
2736 // } target_info;
2737 //
2738 bool VM_RedefineClasses::skip_type_annotation_target(
2739        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
2740        const char * location_mesg, TRAPS) {
2741 
2742   if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
2743     // not enough room for a target_type let alone the rest of a type_annotation
2744     log_debug(redefine, class, annotation)(&quot;length() is too small for a target_type&quot;);
2745     return false;
2746   }
2747 
2748   u1 target_type = type_annotations_typeArray-&gt;at(byte_i_ref);
2749   byte_i_ref += 1;
2750   log_debug(redefine, class, annotation)(&quot;target_type=0x%.2x&quot;, target_type);
2751   log_debug(redefine, class, annotation)(&quot;location=%s&quot;, location_mesg);
2752 
2753   // Skip over target_info
2754   switch (target_type) {
2755     case 0x00:
2756     // kind: type parameter declaration of generic class or interface
2757     // location: ClassFile
2758     case 0x01:
2759     // kind: type parameter declaration of generic method or constructor
2760     // location: method_info
2761 
2762     {
2763       // struct:
2764       // type_parameter_target {
2765       //   u1 type_parameter_index;
2766       // }
2767       //
2768       if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
2769         log_debug(redefine, class, annotation)(&quot;length() is too small for a type_parameter_target&quot;);
2770         return false;
2771       }
2772 
2773       u1 type_parameter_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2774       byte_i_ref += 1;
2775 
2776       log_debug(redefine, class, annotation)(&quot;type_parameter_target: type_parameter_index=%d&quot;, type_parameter_index);
2777     } break;
2778 
2779     case 0x10:
2780     // kind: type in extends clause of class or interface declaration
2781     //       (including the direct superclass of an unsafe anonymous class declaration),
2782     //       or in implements clause of interface declaration
2783     // location: ClassFile
2784 
2785     {
2786       // struct:
2787       // supertype_target {
2788       //   u2 supertype_index;
2789       // }
2790       //
2791       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2792         log_debug(redefine, class, annotation)(&quot;length() is too small for a supertype_target&quot;);
2793         return false;
2794       }
2795 
2796       u2 supertype_index = Bytes::get_Java_u2((address)
2797                              type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2798       byte_i_ref += 2;
2799 
2800       log_debug(redefine, class, annotation)(&quot;supertype_target: supertype_index=%d&quot;, supertype_index);
2801     } break;
2802 
2803     case 0x11:
2804     // kind: type in bound of type parameter declaration of generic class or interface
2805     // location: ClassFile
2806     case 0x12:
2807     // kind: type in bound of type parameter declaration of generic method or constructor
2808     // location: method_info
2809 
2810     {
2811       // struct:
2812       // type_parameter_bound_target {
2813       //   u1 type_parameter_index;
2814       //   u1 bound_index;
2815       // }
2816       //
2817       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2818         log_debug(redefine, class, annotation)(&quot;length() is too small for a type_parameter_bound_target&quot;);
2819         return false;
2820       }
2821 
2822       u1 type_parameter_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2823       byte_i_ref += 1;
2824       u1 bound_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2825       byte_i_ref += 1;
2826 
2827       log_debug(redefine, class, annotation)
2828         (&quot;type_parameter_bound_target: type_parameter_index=%d, bound_index=%d&quot;, type_parameter_index, bound_index);
2829     } break;
2830 
2831     case 0x13:
2832     // kind: type in field declaration
2833     // location: field_info
2834     case 0x14:
2835     // kind: return type of method, or type of newly constructed object
2836     // location: method_info
2837     case 0x15:
2838     // kind: receiver type of method or constructor
2839     // location: method_info
2840 
2841     {
2842       // struct:
2843       // empty_target {
2844       // }
2845       //
2846       log_debug(redefine, class, annotation)(&quot;empty_target&quot;);
2847     } break;
2848 
2849     case 0x16:
2850     // kind: type in formal parameter declaration of method, constructor, or lambda expression
2851     // location: method_info
2852 
2853     {
2854       // struct:
2855       // formal_parameter_target {
2856       //   u1 formal_parameter_index;
2857       // }
2858       //
2859       if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
2860         log_debug(redefine, class, annotation)(&quot;length() is too small for a formal_parameter_target&quot;);
2861         return false;
2862       }
2863 
2864       u1 formal_parameter_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2865       byte_i_ref += 1;
2866 
2867       log_debug(redefine, class, annotation)
2868         (&quot;formal_parameter_target: formal_parameter_index=%d&quot;, formal_parameter_index);
2869     } break;
2870 
2871     case 0x17:
2872     // kind: type in throws clause of method or constructor
2873     // location: method_info
2874 
2875     {
2876       // struct:
2877       // throws_target {
2878       //   u2 throws_type_index
2879       // }
2880       //
2881       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2882         log_debug(redefine, class, annotation)(&quot;length() is too small for a throws_target&quot;);
2883         return false;
2884       }
2885 
2886       u2 throws_type_index = Bytes::get_Java_u2((address)
2887                                type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2888       byte_i_ref += 2;
2889 
2890       log_debug(redefine, class, annotation)(&quot;throws_target: throws_type_index=%d&quot;, throws_type_index);
2891     } break;
2892 
2893     case 0x40:
2894     // kind: type in local variable declaration
2895     // location: Code
2896     case 0x41:
2897     // kind: type in resource variable declaration
2898     // location: Code
2899 
2900     {
2901       // struct:
2902       // localvar_target {
2903       //   u2 table_length;
2904       //   struct {
2905       //     u2 start_pc;
2906       //     u2 length;
2907       //     u2 index;
2908       //   } table[table_length];
2909       // }
2910       //
2911       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2912         // not enough room for a table_length let alone the rest of a localvar_target
2913         log_debug(redefine, class, annotation)(&quot;length() is too small for a localvar_target table_length&quot;);
2914         return false;
2915       }
2916 
2917       u2 table_length = Bytes::get_Java_u2((address)
2918                           type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2919       byte_i_ref += 2;
2920 
2921       log_debug(redefine, class, annotation)(&quot;localvar_target: table_length=%d&quot;, table_length);
2922 
2923       int table_struct_size = 2 + 2 + 2; // 3 u2 variables per table entry
2924       int table_size = table_length * table_struct_size;
2925 
2926       if ((byte_i_ref + table_size) &gt; type_annotations_typeArray-&gt;length()) {
2927         // not enough room for a table
2928         log_debug(redefine, class, annotation)(&quot;length() is too small for a table array of length %d&quot;, table_length);
2929         return false;
2930       }
2931 
2932       // Skip over table
2933       byte_i_ref += table_size;
2934     } break;
2935 
2936     case 0x42:
2937     // kind: type in exception parameter declaration
2938     // location: Code
2939 
2940     {
2941       // struct:
2942       // catch_target {
2943       //   u2 exception_table_index;
2944       // }
2945       //
2946       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2947         log_debug(redefine, class, annotation)(&quot;length() is too small for a catch_target&quot;);
2948         return false;
2949       }
2950 
2951       u2 exception_table_index = Bytes::get_Java_u2((address)
2952                                    type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2953       byte_i_ref += 2;
2954 
2955       log_debug(redefine, class, annotation)(&quot;catch_target: exception_table_index=%d&quot;, exception_table_index);
2956     } break;
2957 
2958     case 0x43:
2959     // kind: type in instanceof expression
2960     // location: Code
2961     case 0x44:
2962     // kind: type in new expression
2963     // location: Code
2964     case 0x45:
2965     // kind: type in method reference expression using ::new
2966     // location: Code
2967     case 0x46:
2968     // kind: type in method reference expression using ::Identifier
2969     // location: Code
2970 
2971     {
2972       // struct:
2973       // offset_target {
2974       //   u2 offset;
2975       // }
2976       //
2977       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2978         log_debug(redefine, class, annotation)(&quot;length() is too small for a offset_target&quot;);
2979         return false;
2980       }
2981 
2982       u2 offset = Bytes::get_Java_u2((address)
2983                     type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2984       byte_i_ref += 2;
2985 
2986       log_debug(redefine, class, annotation)(&quot;offset_target: offset=%d&quot;, offset);
2987     } break;
2988 
2989     case 0x47:
2990     // kind: type in cast expression
2991     // location: Code
2992     case 0x48:
2993     // kind: type argument for generic constructor in new expression or
2994     //       explicit constructor invocation statement
2995     // location: Code
2996     case 0x49:
2997     // kind: type argument for generic method in method invocation expression
2998     // location: Code
2999     case 0x4A:
3000     // kind: type argument for generic constructor in method reference expression using ::new
3001     // location: Code
3002     case 0x4B:
3003     // kind: type argument for generic method in method reference expression using ::Identifier
3004     // location: Code
3005 
3006     {
3007       // struct:
3008       // type_argument_target {
3009       //   u2 offset;
3010       //   u1 type_argument_index;
3011       // }
3012       //
3013       if ((byte_i_ref + 3) &gt; type_annotations_typeArray-&gt;length()) {
3014         log_debug(redefine, class, annotation)(&quot;length() is too small for a type_argument_target&quot;);
3015         return false;
3016       }
3017 
3018       u2 offset = Bytes::get_Java_u2((address)
3019                     type_annotations_typeArray-&gt;adr_at(byte_i_ref));
3020       byte_i_ref += 2;
3021       u1 type_argument_index = type_annotations_typeArray-&gt;at(byte_i_ref);
3022       byte_i_ref += 1;
3023 
3024       log_debug(redefine, class, annotation)
3025         (&quot;type_argument_target: offset=%d, type_argument_index=%d&quot;, offset, type_argument_index);
3026     } break;
3027 
3028     default:
3029       log_debug(redefine, class, annotation)(&quot;unknown target_type&quot;);
3030 #ifdef ASSERT
3031       ShouldNotReachHere();
3032 #endif
3033       return false;
3034   }
3035 
3036   return true;
3037 } // end skip_type_annotation_target()
3038 
3039 
3040 // Read, verify and skip over the type_path part so that rewriting
3041 // can continue in the later parts of the struct.
3042 //
3043 // type_path {
3044 //   u1 path_length;
3045 //   {
3046 //     u1 type_path_kind;
3047 //     u1 type_argument_index;
3048 //   } path[path_length];
3049 // }
3050 //
3051 bool VM_RedefineClasses::skip_type_annotation_type_path(
3052        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
3053 
3054   if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
3055     // not enough room for a path_length let alone the rest of the type_path
3056     log_debug(redefine, class, annotation)(&quot;length() is too small for a type_path&quot;);
3057     return false;
3058   }
3059 
3060   u1 path_length = type_annotations_typeArray-&gt;at(byte_i_ref);
3061   byte_i_ref += 1;
3062 
3063   log_debug(redefine, class, annotation)(&quot;type_path: path_length=%d&quot;, path_length);
3064 
3065   int calc_path_length = 0;
3066   for (; calc_path_length &lt; path_length; calc_path_length++) {
3067     if ((byte_i_ref + 1 + 1) &gt; type_annotations_typeArray-&gt;length()) {
3068       // not enough room for a path
3069       log_debug(redefine, class, annotation)
3070         (&quot;length() is too small for path entry %d of %d&quot;, calc_path_length, path_length);
3071       return false;
3072     }
3073 
3074     u1 type_path_kind = type_annotations_typeArray-&gt;at(byte_i_ref);
3075     byte_i_ref += 1;
3076     u1 type_argument_index = type_annotations_typeArray-&gt;at(byte_i_ref);
3077     byte_i_ref += 1;
3078 
3079     log_debug(redefine, class, annotation)
3080       (&quot;type_path: path[%d]: type_path_kind=%d, type_argument_index=%d&quot;,
3081        calc_path_length, type_path_kind, type_argument_index);
3082 
3083     if (type_path_kind &gt; 3 || (type_path_kind != 3 &amp;&amp; type_argument_index != 0)) {
3084       // not enough room for a path
3085       log_debug(redefine, class, annotation)(&quot;inconsistent type_path values&quot;);
3086       return false;
3087     }
3088   }
3089   assert(path_length == calc_path_length, &quot;sanity check&quot;);
3090 
3091   return true;
3092 } // end skip_type_annotation_type_path()
3093 
3094 
3095 // Rewrite constant pool references in the method&#39;s stackmap table.
3096 // These &quot;structures&quot; are adapted from the StackMapTable_attribute that
3097 // is described in section 4.8.4 of the 6.0 version of the VM spec
3098 // (dated 2005.10.26):
3099 // file:///net/quincunx.sfbay/export/gbracha/ClassFile-Java6.pdf
3100 //
3101 // stack_map {
3102 //   u2 number_of_entries;
3103 //   stack_map_frame entries[number_of_entries];
3104 // }
3105 //
3106 void VM_RedefineClasses::rewrite_cp_refs_in_stack_map_table(
3107        const methodHandle&amp; method, TRAPS) {
3108 
3109   if (!method-&gt;has_stackmap_table()) {
3110     return;
3111   }
3112 
3113   AnnotationArray* stackmap_data = method-&gt;stackmap_data();
3114   address stackmap_p = (address)stackmap_data-&gt;adr_at(0);
3115   address stackmap_end = stackmap_p + stackmap_data-&gt;length();
3116 
3117   assert(stackmap_p + 2 &lt;= stackmap_end, &quot;no room for number_of_entries&quot;);
3118   u2 number_of_entries = Bytes::get_Java_u2(stackmap_p);
3119   stackmap_p += 2;
3120 
3121   log_debug(redefine, class, stackmap)(&quot;number_of_entries=%u&quot;, number_of_entries);
3122 
3123   // walk through each stack_map_frame
3124   u2 calc_number_of_entries = 0;
3125   for (; calc_number_of_entries &lt; number_of_entries; calc_number_of_entries++) {
3126     // The stack_map_frame structure is a u1 frame_type followed by
3127     // 0 or more bytes of data:
3128     //
3129     // union stack_map_frame {
3130     //   same_frame;
3131     //   same_locals_1_stack_item_frame;
3132     //   same_locals_1_stack_item_frame_extended;
3133     //   chop_frame;
3134     //   same_frame_extended;
3135     //   append_frame;
3136     //   full_frame;
3137     // }
3138 
3139     assert(stackmap_p + 1 &lt;= stackmap_end, &quot;no room for frame_type&quot;);
3140     u1 frame_type = *stackmap_p;
3141     stackmap_p++;
3142 
3143     // same_frame {
3144     //   u1 frame_type = SAME; /* 0-63 */
3145     // }
3146     if (frame_type &lt;= 63) {
3147       // nothing more to do for same_frame
3148     }
3149 
3150     // same_locals_1_stack_item_frame {
3151     //   u1 frame_type = SAME_LOCALS_1_STACK_ITEM; /* 64-127 */
3152     //   verification_type_info stack[1];
3153     // }
3154     else if (frame_type &gt;= 64 &amp;&amp; frame_type &lt;= 127) {
3155       rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3156         calc_number_of_entries, frame_type, THREAD);
3157     }
3158 
3159     // reserved for future use
3160     else if (frame_type &gt;= 128 &amp;&amp; frame_type &lt;= 246) {
3161       // nothing more to do for reserved frame_types
3162     }
3163 
3164     // same_locals_1_stack_item_frame_extended {
3165     //   u1 frame_type = SAME_LOCALS_1_STACK_ITEM_EXTENDED; /* 247 */
3166     //   u2 offset_delta;
3167     //   verification_type_info stack[1];
3168     // }
3169     else if (frame_type == 247) {
3170       stackmap_p += 2;
3171       rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3172         calc_number_of_entries, frame_type, THREAD);
3173     }
3174 
3175     // chop_frame {
3176     //   u1 frame_type = CHOP; /* 248-250 */
3177     //   u2 offset_delta;
3178     // }
3179     else if (frame_type &gt;= 248 &amp;&amp; frame_type &lt;= 250) {
3180       stackmap_p += 2;
3181     }
3182 
3183     // same_frame_extended {
3184     //   u1 frame_type = SAME_FRAME_EXTENDED; /* 251*/
3185     //   u2 offset_delta;
3186     // }
3187     else if (frame_type == 251) {
3188       stackmap_p += 2;
3189     }
3190 
3191     // append_frame {
3192     //   u1 frame_type = APPEND; /* 252-254 */
3193     //   u2 offset_delta;
3194     //   verification_type_info locals[frame_type - 251];
3195     // }
3196     else if (frame_type &gt;= 252 &amp;&amp; frame_type &lt;= 254) {
3197       assert(stackmap_p + 2 &lt;= stackmap_end,
3198         &quot;no room for offset_delta&quot;);
3199       stackmap_p += 2;
3200       u1 len = frame_type - 251;
3201       for (u1 i = 0; i &lt; len; i++) {
3202         rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3203           calc_number_of_entries, frame_type, THREAD);
3204       }
3205     }
3206 
3207     // full_frame {
3208     //   u1 frame_type = FULL_FRAME; /* 255 */
3209     //   u2 offset_delta;
3210     //   u2 number_of_locals;
3211     //   verification_type_info locals[number_of_locals];
3212     //   u2 number_of_stack_items;
3213     //   verification_type_info stack[number_of_stack_items];
3214     // }
3215     else if (frame_type == 255) {
3216       assert(stackmap_p + 2 + 2 &lt;= stackmap_end,
3217         &quot;no room for smallest full_frame&quot;);
3218       stackmap_p += 2;
3219 
3220       u2 number_of_locals = Bytes::get_Java_u2(stackmap_p);
3221       stackmap_p += 2;
3222 
3223       for (u2 locals_i = 0; locals_i &lt; number_of_locals; locals_i++) {
3224         rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3225           calc_number_of_entries, frame_type, THREAD);
3226       }
3227 
3228       // Use the largest size for the number_of_stack_items, but only get
3229       // the right number of bytes.
3230       u2 number_of_stack_items = Bytes::get_Java_u2(stackmap_p);
3231       stackmap_p += 2;
3232 
3233       for (u2 stack_i = 0; stack_i &lt; number_of_stack_items; stack_i++) {
3234         rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3235           calc_number_of_entries, frame_type, THREAD);
3236       }
3237     }
3238   } // end while there is a stack_map_frame
3239   assert(number_of_entries == calc_number_of_entries, &quot;sanity check&quot;);
3240 } // end rewrite_cp_refs_in_stack_map_table()
3241 
3242 
3243 // Rewrite constant pool references in the verification type info
3244 // portion of the method&#39;s stackmap table. These &quot;structures&quot; are
3245 // adapted from the StackMapTable_attribute that is described in
3246 // section 4.8.4 of the 6.0 version of the VM spec (dated 2005.10.26):
3247 // file:///net/quincunx.sfbay/export/gbracha/ClassFile-Java6.pdf
3248 //
3249 // The verification_type_info structure is a u1 tag followed by 0 or
3250 // more bytes of data:
3251 //
3252 // union verification_type_info {
3253 //   Top_variable_info;
3254 //   Integer_variable_info;
3255 //   Float_variable_info;
3256 //   Long_variable_info;
3257 //   Double_variable_info;
3258 //   Null_variable_info;
3259 //   UninitializedThis_variable_info;
3260 //   Object_variable_info;
3261 //   Uninitialized_variable_info;
3262 // }
3263 //
3264 void VM_RedefineClasses::rewrite_cp_refs_in_verification_type_info(
3265        address&amp; stackmap_p_ref, address stackmap_end, u2 frame_i,
3266        u1 frame_type, TRAPS) {
3267 
3268   assert(stackmap_p_ref + 1 &lt;= stackmap_end, &quot;no room for tag&quot;);
3269   u1 tag = *stackmap_p_ref;
3270   stackmap_p_ref++;
3271 
3272   switch (tag) {
3273   // Top_variable_info {
3274   //   u1 tag = ITEM_Top; /* 0 */
3275   // }
3276   // verificationType.hpp has zero as ITEM_Bogus instead of ITEM_Top
3277   case 0:  // fall through
3278 
3279   // Integer_variable_info {
3280   //   u1 tag = ITEM_Integer; /* 1 */
3281   // }
3282   case ITEM_Integer:  // fall through
3283 
3284   // Float_variable_info {
3285   //   u1 tag = ITEM_Float; /* 2 */
3286   // }
3287   case ITEM_Float:  // fall through
3288 
3289   // Double_variable_info {
3290   //   u1 tag = ITEM_Double; /* 3 */
3291   // }
3292   case ITEM_Double:  // fall through
3293 
3294   // Long_variable_info {
3295   //   u1 tag = ITEM_Long; /* 4 */
3296   // }
3297   case ITEM_Long:  // fall through
3298 
3299   // Null_variable_info {
3300   //   u1 tag = ITEM_Null; /* 5 */
3301   // }
3302   case ITEM_Null:  // fall through
3303 
3304   // UninitializedThis_variable_info {
3305   //   u1 tag = ITEM_UninitializedThis; /* 6 */
3306   // }
3307   case ITEM_UninitializedThis:
3308     // nothing more to do for the above tag types
3309     break;
3310 
3311   // Object_variable_info {
3312   //   u1 tag = ITEM_Object; /* 7 */
3313   //   u2 cpool_index;
3314   // }
3315   case ITEM_Object:
3316   {
3317     assert(stackmap_p_ref + 2 &lt;= stackmap_end, &quot;no room for cpool_index&quot;);
3318     u2 cpool_index = Bytes::get_Java_u2(stackmap_p_ref);
3319     u2 new_cp_index = find_new_index(cpool_index);
3320     if (new_cp_index != 0) {
3321       log_debug(redefine, class, stackmap)(&quot;mapped old cpool_index=%d&quot;, cpool_index);
3322       Bytes::put_Java_u2(stackmap_p_ref, new_cp_index);
3323       cpool_index = new_cp_index;
3324     }
3325     stackmap_p_ref += 2;
3326 
3327     log_debug(redefine, class, stackmap)
3328       (&quot;frame_i=%u, frame_type=%u, cpool_index=%d&quot;, frame_i, frame_type, cpool_index);
3329   } break;
3330 
3331   // Uninitialized_variable_info {
3332   //   u1 tag = ITEM_Uninitialized; /* 8 */
3333   //   u2 offset;
3334   // }
3335   case ITEM_Uninitialized:
3336     assert(stackmap_p_ref + 2 &lt;= stackmap_end, &quot;no room for offset&quot;);
3337     stackmap_p_ref += 2;
3338     break;
3339 
3340   default:
3341     log_debug(redefine, class, stackmap)(&quot;frame_i=%u, frame_type=%u, bad tag=0x%x&quot;, frame_i, frame_type, tag);
3342     ShouldNotReachHere();
3343     break;
3344   } // end switch (tag)
3345 } // end rewrite_cp_refs_in_verification_type_info()
3346 
3347 
3348 // Change the constant pool associated with klass scratch_class to
3349 // scratch_cp. If shrink is true, then scratch_cp_length elements
3350 // are copied from scratch_cp to a smaller constant pool and the
3351 // smaller constant pool is associated with scratch_class.
3352 void VM_RedefineClasses::set_new_constant_pool(
3353        ClassLoaderData* loader_data,
3354        InstanceKlass* scratch_class, constantPoolHandle scratch_cp,
3355        int scratch_cp_length, TRAPS) {
3356   assert(scratch_cp-&gt;length() &gt;= scratch_cp_length, &quot;sanity check&quot;);
3357 
3358   // scratch_cp is a merged constant pool and has enough space for a
3359   // worst case merge situation. We want to associate the minimum
3360   // sized constant pool with the klass to save space.
3361   ConstantPool* cp = ConstantPool::allocate(loader_data, scratch_cp_length, CHECK);
3362   constantPoolHandle smaller_cp(THREAD, cp);
3363 
3364   // preserve version() value in the smaller copy
3365   int version = scratch_cp-&gt;version();
3366   assert(version != 0, &quot;sanity check&quot;);
3367   smaller_cp-&gt;set_version(version);
3368 
3369   // attach klass to new constant pool
3370   // reference to the cp holder is needed for copy_operands()
3371   smaller_cp-&gt;set_pool_holder(scratch_class);
3372 
3373   if (scratch_cp-&gt;has_dynamic_constant()) {
3374     smaller_cp-&gt;set_has_dynamic_constant();
3375   }
3376 
3377   scratch_cp-&gt;copy_cp_to(1, scratch_cp_length - 1, smaller_cp, 1, THREAD);
3378   if (HAS_PENDING_EXCEPTION) {
3379     // Exception is handled in the caller
3380     loader_data-&gt;add_to_deallocate_list(smaller_cp());
3381     return;
3382   }
3383   scratch_cp = smaller_cp;
3384 
3385   // attach new constant pool to klass
3386   scratch_class-&gt;set_constants(scratch_cp());
3387   scratch_cp-&gt;initialize_unresolved_klasses(loader_data, CHECK);
3388 
3389   int i;  // for portability
3390 
3391   // update each field in klass to use new constant pool indices as needed
3392   for (JavaFieldStream fs(scratch_class); !fs.done(); fs.next()) {
3393     jshort cur_index = fs.name_index();
3394     jshort new_index = find_new_index(cur_index);
3395     if (new_index != 0) {
3396       log_trace(redefine, class, constantpool)(&quot;field-name_index change: %d to %d&quot;, cur_index, new_index);
3397       fs.set_name_index(new_index);
3398     }
3399     cur_index = fs.signature_index();
3400     new_index = find_new_index(cur_index);
3401     if (new_index != 0) {
3402       log_trace(redefine, class, constantpool)(&quot;field-signature_index change: %d to %d&quot;, cur_index, new_index);
3403       fs.set_signature_index(new_index);
3404     }
3405     cur_index = fs.initval_index();
3406     new_index = find_new_index(cur_index);
3407     if (new_index != 0) {
3408       log_trace(redefine, class, constantpool)(&quot;field-initval_index change: %d to %d&quot;, cur_index, new_index);
3409       fs.set_initval_index(new_index);
3410     }
3411     cur_index = fs.generic_signature_index();
3412     new_index = find_new_index(cur_index);
3413     if (new_index != 0) {
3414       log_trace(redefine, class, constantpool)(&quot;field-generic_signature change: %d to %d&quot;, cur_index, new_index);
3415       fs.set_generic_signature_index(new_index);
3416     }
3417   } // end for each field
3418 
3419   // Update constant pool indices in the inner classes info to use
3420   // new constant indices as needed. The inner classes info is a
3421   // quadruple:
3422   // (inner_class_info, outer_class_info, inner_name, inner_access_flags)
3423   InnerClassesIterator iter(scratch_class);
3424   for (; !iter.done(); iter.next()) {
3425     int cur_index = iter.inner_class_info_index();
3426     if (cur_index == 0) {
3427       continue;  // JVM spec. allows null inner class refs so skip it
3428     }
3429     int new_index = find_new_index(cur_index);
3430     if (new_index != 0) {
3431       log_trace(redefine, class, constantpool)(&quot;inner_class_info change: %d to %d&quot;, cur_index, new_index);
3432       iter.set_inner_class_info_index(new_index);
3433     }
3434     cur_index = iter.outer_class_info_index();
3435     new_index = find_new_index(cur_index);
3436     if (new_index != 0) {
3437       log_trace(redefine, class, constantpool)(&quot;outer_class_info change: %d to %d&quot;, cur_index, new_index);
3438       iter.set_outer_class_info_index(new_index);
3439     }
3440     cur_index = iter.inner_name_index();
3441     new_index = find_new_index(cur_index);
3442     if (new_index != 0) {
3443       log_trace(redefine, class, constantpool)(&quot;inner_name change: %d to %d&quot;, cur_index, new_index);
3444       iter.set_inner_name_index(new_index);
3445     }
3446   } // end for each inner class
3447 
3448   // Attach each method in klass to the new constant pool and update
3449   // to use new constant pool indices as needed:
3450   Array&lt;Method*&gt;* methods = scratch_class-&gt;methods();
3451   for (i = methods-&gt;length() - 1; i &gt;= 0; i--) {
3452     methodHandle method(THREAD, methods-&gt;at(i));
3453     method-&gt;set_constants(scratch_cp());
3454 
3455     int new_index = find_new_index(method-&gt;name_index());
3456     if (new_index != 0) {
3457       log_trace(redefine, class, constantpool)
3458         (&quot;method-name_index change: %d to %d&quot;, method-&gt;name_index(), new_index);
3459       method-&gt;set_name_index(new_index);
3460     }
3461     new_index = find_new_index(method-&gt;signature_index());
3462     if (new_index != 0) {
3463       log_trace(redefine, class, constantpool)
3464         (&quot;method-signature_index change: %d to %d&quot;, method-&gt;signature_index(), new_index);
3465       method-&gt;set_signature_index(new_index);
3466     }
3467     new_index = find_new_index(method-&gt;generic_signature_index());
3468     if (new_index != 0) {
3469       log_trace(redefine, class, constantpool)
3470         (&quot;method-generic_signature_index change: %d to %d&quot;, method-&gt;generic_signature_index(), new_index);
3471       method-&gt;set_generic_signature_index(new_index);
3472     }
3473 
3474     // Update constant pool indices in the method&#39;s checked exception
3475     // table to use new constant indices as needed.
3476     int cext_length = method-&gt;checked_exceptions_length();
3477     if (cext_length &gt; 0) {
3478       CheckedExceptionElement * cext_table =
3479         method-&gt;checked_exceptions_start();
3480       for (int j = 0; j &lt; cext_length; j++) {
3481         int cur_index = cext_table[j].class_cp_index;
3482         int new_index = find_new_index(cur_index);
3483         if (new_index != 0) {
3484           log_trace(redefine, class, constantpool)(&quot;cext-class_cp_index change: %d to %d&quot;, cur_index, new_index);
3485           cext_table[j].class_cp_index = (u2)new_index;
3486         }
3487       } // end for each checked exception table entry
3488     } // end if there are checked exception table entries
3489 
3490     // Update each catch type index in the method&#39;s exception table
3491     // to use new constant pool indices as needed. The exception table
3492     // holds quadruple entries of the form:
3493     //   (beg_bci, end_bci, handler_bci, klass_index)
3494 
3495     ExceptionTable ex_table(method());
3496     int ext_length = ex_table.length();
3497 
3498     for (int j = 0; j &lt; ext_length; j ++) {
3499       int cur_index = ex_table.catch_type_index(j);
3500       int new_index = find_new_index(cur_index);
3501       if (new_index != 0) {
3502         log_trace(redefine, class, constantpool)(&quot;ext-klass_index change: %d to %d&quot;, cur_index, new_index);
3503         ex_table.set_catch_type_index(j, new_index);
3504       }
3505     } // end for each exception table entry
3506 
3507     // Update constant pool indices in the method&#39;s local variable
3508     // table to use new constant indices as needed. The local variable
3509     // table hold sextuple entries of the form:
3510     // (start_pc, length, name_index, descriptor_index, signature_index, slot)
3511     int lvt_length = method-&gt;localvariable_table_length();
3512     if (lvt_length &gt; 0) {
3513       LocalVariableTableElement * lv_table =
3514         method-&gt;localvariable_table_start();
3515       for (int j = 0; j &lt; lvt_length; j++) {
3516         int cur_index = lv_table[j].name_cp_index;
3517         int new_index = find_new_index(cur_index);
3518         if (new_index != 0) {
3519           log_trace(redefine, class, constantpool)(&quot;lvt-name_cp_index change: %d to %d&quot;, cur_index, new_index);
3520           lv_table[j].name_cp_index = (u2)new_index;
3521         }
3522         cur_index = lv_table[j].descriptor_cp_index;
3523         new_index = find_new_index(cur_index);
3524         if (new_index != 0) {
3525           log_trace(redefine, class, constantpool)(&quot;lvt-descriptor_cp_index change: %d to %d&quot;, cur_index, new_index);
3526           lv_table[j].descriptor_cp_index = (u2)new_index;
3527         }
3528         cur_index = lv_table[j].signature_cp_index;
3529         new_index = find_new_index(cur_index);
3530         if (new_index != 0) {
3531           log_trace(redefine, class, constantpool)(&quot;lvt-signature_cp_index change: %d to %d&quot;, cur_index, new_index);
3532           lv_table[j].signature_cp_index = (u2)new_index;
3533         }
3534       } // end for each local variable table entry
3535     } // end if there are local variable table entries
3536 
3537     rewrite_cp_refs_in_stack_map_table(method, THREAD);
3538   } // end for each method
3539 } // end set_new_constant_pool()
3540 
3541 
3542 // Unevolving classes may point to methods of the_class directly
3543 // from their constant pool caches, itables, and/or vtables. We
3544 // use the ClassLoaderDataGraph::classes_do() facility and this helper
3545 // to fix up these pointers.  MethodData also points to old methods and
3546 // must be cleaned.
3547 
3548 // Adjust cpools and vtables closure
3549 void VM_RedefineClasses::AdjustAndCleanMetadata::do_klass(Klass* k) {
3550 
3551   // This is a very busy routine. We don&#39;t want too much tracing
3552   // printed out.
3553   bool trace_name_printed = false;
3554 
3555   // If the class being redefined is java.lang.Object, we need to fix all
3556   // array class vtables also
3557   if (k-&gt;is_array_klass() &amp;&amp; _has_redefined_Object) {
3558     k-&gt;vtable().adjust_method_entries(&amp;trace_name_printed);
3559 
3560   } else if (k-&gt;is_instance_klass()) {
3561     HandleMark hm(_thread);
3562     InstanceKlass *ik = InstanceKlass::cast(k);
3563 
3564     // Clean MethodData of this class&#39;s methods so they don&#39;t refer to
3565     // old methods that are no longer running.
3566     Array&lt;Method*&gt;* methods = ik-&gt;methods();
3567     int num_methods = methods-&gt;length();
3568     for (int index = 0; index &lt; num_methods; ++index) {
3569       if (methods-&gt;at(index)-&gt;method_data() != NULL) {
3570         methods-&gt;at(index)-&gt;method_data()-&gt;clean_weak_method_links();
3571       }
3572     }
3573 
3574     // HotSpot specific optimization! HotSpot does not currently
3575     // support delegation from the bootstrap class loader to a
3576     // user-defined class loader. This means that if the bootstrap
3577     // class loader is the initiating class loader, then it will also
3578     // be the defining class loader. This also means that classes
3579     // loaded by the bootstrap class loader cannot refer to classes
3580     // loaded by a user-defined class loader. Note: a user-defined
3581     // class loader can delegate to the bootstrap class loader.
3582     //
3583     // If the current class being redefined has a user-defined class
3584     // loader as its defining class loader, then we can skip all
3585     // classes loaded by the bootstrap class loader.
3586     if (!_has_null_class_loader &amp;&amp; ik-&gt;class_loader() == NULL) {
3587       return;
3588     }
3589 
3590     // Adjust all vtables, default methods and itables, to clean out old methods.
3591     ResourceMark rm(_thread);
3592     if (ik-&gt;vtable_length() &gt; 0) {
3593       ik-&gt;vtable().adjust_method_entries(&amp;trace_name_printed);
3594       ik-&gt;adjust_default_methods(&amp;trace_name_printed);
3595     }
3596 
3597     if (ik-&gt;itable_length() &gt; 0) {
3598       ik-&gt;itable().adjust_method_entries(&amp;trace_name_printed);
3599     }
3600 
3601     // The constant pools in other classes (other_cp) can refer to
3602     // old methods.  We have to update method information in
3603     // other_cp&#39;s cache. If other_cp has a previous version, then we
3604     // have to repeat the process for each previous version. The
3605     // constant pool cache holds the Method*s for non-virtual
3606     // methods and for virtual, final methods.
3607     //
3608     // Special case: if the current class being redefined, then new_cp
3609     // has already been attached to the_class and old_cp has already
3610     // been added as a previous version. The new_cp doesn&#39;t have any
3611     // cached references to old methods so it doesn&#39;t need to be
3612     // updated. We can simply start with the previous version(s) in
3613     // that case.
3614     ConstantPoolCache* cp_cache;
3615 
3616     if (!ik-&gt;is_being_redefined()) {
3617       // this klass&#39; constant pool cache may need adjustment
3618       ConstantPool* other_cp = ik-&gt;constants();
3619       cp_cache = other_cp-&gt;cache();
3620       if (cp_cache != NULL) {
3621         cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);
3622       }
3623     }
3624 
3625     // the previous versions&#39; constant pool caches may need adjustment
3626     for (InstanceKlass* pv_node = ik-&gt;previous_versions();
3627          pv_node != NULL;
3628          pv_node = pv_node-&gt;previous_versions()) {
3629       cp_cache = pv_node-&gt;constants()-&gt;cache();
3630       if (cp_cache != NULL) {
3631         cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);
3632       }
3633     }
3634   }
3635 }
3636 
3637 void VM_RedefineClasses::update_jmethod_ids(Thread* thread) {
3638   for (int j = 0; j &lt; _matching_methods_length; ++j) {
3639     Method* old_method = _matching_old_methods[j];
3640     jmethodID jmid = old_method-&gt;find_jmethod_id_or_null();
3641     if (jmid != NULL) {
3642       // There is a jmethodID, change it to point to the new method
3643       methodHandle new_method_h(thread, _matching_new_methods[j]);
3644       Method::change_method_associated_with_jmethod_id(jmid, new_method_h());
3645       assert(Method::resolve_jmethod_id(jmid) == _matching_new_methods[j],
3646              &quot;should be replaced&quot;);
3647     }
3648   }
3649 }
3650 
3651 int VM_RedefineClasses::check_methods_and_mark_as_obsolete() {
3652   int emcp_method_count = 0;
3653   int obsolete_count = 0;
3654   int old_index = 0;
3655   for (int j = 0; j &lt; _matching_methods_length; ++j, ++old_index) {
3656     Method* old_method = _matching_old_methods[j];
3657     Method* new_method = _matching_new_methods[j];
3658     Method* old_array_method;
3659 
3660     // Maintain an old_index into the _old_methods array by skipping
3661     // deleted methods
3662     while ((old_array_method = _old_methods-&gt;at(old_index)) != old_method) {
3663       ++old_index;
3664     }
3665 
3666     if (MethodComparator::methods_EMCP(old_method, new_method)) {
3667       // The EMCP definition from JSR-163 requires the bytecodes to be
3668       // the same with the exception of constant pool indices which may
3669       // differ. However, the constants referred to by those indices
3670       // must be the same.
3671       //
3672       // We use methods_EMCP() for comparison since constant pool
3673       // merging can remove duplicate constant pool entries that were
3674       // present in the old method and removed from the rewritten new
3675       // method. A faster binary comparison function would consider the
3676       // old and new methods to be different when they are actually
3677       // EMCP.
3678       //
3679       // The old and new methods are EMCP and you would think that we
3680       // could get rid of one of them here and now and save some space.
3681       // However, the concept of EMCP only considers the bytecodes and
3682       // the constant pool entries in the comparison. Other things,
3683       // e.g., the line number table (LNT) or the local variable table
3684       // (LVT) don&#39;t count in the comparison. So the new (and EMCP)
3685       // method can have a new LNT that we need so we can&#39;t just
3686       // overwrite the new method with the old method.
3687       //
3688       // When this routine is called, we have already attached the new
3689       // methods to the_class so the old methods are effectively
3690       // overwritten. However, if an old method is still executing,
3691       // then the old method cannot be collected until sometime after
3692       // the old method call has returned. So the overwriting of old
3693       // methods by new methods will save us space except for those
3694       // (hopefully few) old methods that are still executing.
3695       //
3696       // A method refers to a ConstMethod* and this presents another
3697       // possible avenue to space savings. The ConstMethod* in the
3698       // new method contains possibly new attributes (LNT, LVT, etc).
3699       // At first glance, it seems possible to save space by replacing
3700       // the ConstMethod* in the old method with the ConstMethod*
3701       // from the new method. The old and new methods would share the
3702       // same ConstMethod* and we would save the space occupied by
3703       // the old ConstMethod*. However, the ConstMethod* contains
3704       // a back reference to the containing method. Sharing the
3705       // ConstMethod* between two methods could lead to confusion in
3706       // the code that uses the back reference. This would lead to
3707       // brittle code that could be broken in non-obvious ways now or
3708       // in the future.
3709       //
3710       // Another possibility is to copy the ConstMethod* from the new
3711       // method to the old method and then overwrite the new method with
3712       // the old method. Since the ConstMethod* contains the bytecodes
3713       // for the method embedded in the oop, this option would change
3714       // the bytecodes out from under any threads executing the old
3715       // method and make the thread&#39;s bcp invalid. Since EMCP requires
3716       // that the bytecodes be the same modulo constant pool indices, it
3717       // is straight forward to compute the correct new bcp in the new
3718       // ConstMethod* from the old bcp in the old ConstMethod*. The
3719       // time consuming part would be searching all the frames in all
3720       // of the threads to find all of the calls to the old method.
3721       //
3722       // It looks like we will have to live with the limited savings
3723       // that we get from effectively overwriting the old methods
3724       // when the new methods are attached to the_class.
3725 
3726       // Count number of methods that are EMCP.  The method will be marked
3727       // old but not obsolete if it is EMCP.
3728       emcp_method_count++;
3729 
3730       // An EMCP method is _not_ obsolete. An obsolete method has a
3731       // different jmethodID than the current method. An EMCP method
3732       // has the same jmethodID as the current method. Having the
3733       // same jmethodID for all EMCP versions of a method allows for
3734       // a consistent view of the EMCP methods regardless of which
3735       // EMCP method you happen to have in hand. For example, a
3736       // breakpoint set in one EMCP method will work for all EMCP
3737       // versions of the method including the current one.
3738     } else {
3739       // mark obsolete methods as such
3740       old_method-&gt;set_is_obsolete();
3741       obsolete_count++;
3742 
3743       // obsolete methods need a unique idnum so they become new entries in
3744       // the jmethodID cache in InstanceKlass
3745       assert(old_method-&gt;method_idnum() == new_method-&gt;method_idnum(), &quot;must match&quot;);
3746       u2 num = InstanceKlass::cast(_the_class)-&gt;next_method_idnum();
3747       if (num != ConstMethod::UNSET_IDNUM) {
3748         old_method-&gt;set_method_idnum(num);
3749       }
3750 
3751       // With tracing we try not to &quot;yack&quot; too much. The position of
3752       // this trace assumes there are fewer obsolete methods than
3753       // EMCP methods.
3754       if (log_is_enabled(Trace, redefine, class, obsolete, mark)) {
3755         ResourceMark rm;
3756         log_trace(redefine, class, obsolete, mark)
3757           (&quot;mark %s(%s) as obsolete&quot;, old_method-&gt;name()-&gt;as_C_string(), old_method-&gt;signature()-&gt;as_C_string());
3758       }
3759     }
3760     old_method-&gt;set_is_old();
3761   }
3762   for (int i = 0; i &lt; _deleted_methods_length; ++i) {
3763     Method* old_method = _deleted_methods[i];
3764 
3765     assert(!old_method-&gt;has_vtable_index(),
3766            &quot;cannot delete methods with vtable entries&quot;);;
3767 
3768     // Mark all deleted methods as old, obsolete and deleted
3769     old_method-&gt;set_is_deleted();
3770     old_method-&gt;set_is_old();
3771     old_method-&gt;set_is_obsolete();
3772     ++obsolete_count;
3773     // With tracing we try not to &quot;yack&quot; too much. The position of
3774     // this trace assumes there are fewer obsolete methods than
3775     // EMCP methods.
3776     if (log_is_enabled(Trace, redefine, class, obsolete, mark)) {
3777       ResourceMark rm;
3778       log_trace(redefine, class, obsolete, mark)
3779         (&quot;mark deleted %s(%s) as obsolete&quot;, old_method-&gt;name()-&gt;as_C_string(), old_method-&gt;signature()-&gt;as_C_string());
3780     }
3781   }
3782   assert((emcp_method_count + obsolete_count) == _old_methods-&gt;length(),
3783     &quot;sanity check&quot;);
3784   log_trace(redefine, class, obsolete, mark)(&quot;EMCP_cnt=%d, obsolete_cnt=%d&quot;, emcp_method_count, obsolete_count);
3785   return emcp_method_count;
3786 }
3787 
3788 // This internal class transfers the native function registration from old methods
3789 // to new methods.  It is designed to handle both the simple case of unchanged
3790 // native methods and the complex cases of native method prefixes being added and/or
3791 // removed.
3792 // It expects only to be used during the VM_RedefineClasses op (a safepoint).
3793 //
3794 // This class is used after the new methods have been installed in &quot;the_class&quot;.
3795 //
3796 // So, for example, the following must be handled.  Where &#39;m&#39; is a method and
3797 // a number followed by an underscore is a prefix.
3798 //
3799 //                                      Old Name    New Name
3800 // Simple transfer to new method        m       -&gt;  m
3801 // Add prefix                           m       -&gt;  1_m
3802 // Remove prefix                        1_m     -&gt;  m
3803 // Simultaneous add of prefixes         m       -&gt;  3_2_1_m
3804 // Simultaneous removal of prefixes     3_2_1_m -&gt;  m
3805 // Simultaneous add and remove          1_m     -&gt;  2_m
3806 // Same, caused by prefix removal only  3_2_1_m -&gt;  3_2_m
3807 //
3808 class TransferNativeFunctionRegistration {
3809  private:
3810   InstanceKlass* the_class;
3811   int prefix_count;
3812   char** prefixes;
3813 
3814   // Recursively search the binary tree of possibly prefixed method names.
3815   // Iteration could be used if all agents were well behaved. Full tree walk is
3816   // more resilent to agents not cleaning up intermediate methods.
3817   // Branch at each depth in the binary tree is:
3818   //    (1) without the prefix.
3819   //    (2) with the prefix.
3820   // where &#39;prefix&#39; is the prefix at that &#39;depth&#39; (first prefix, second prefix,...)
3821   Method* search_prefix_name_space(int depth, char* name_str, size_t name_len,
3822                                      Symbol* signature) {
3823     TempNewSymbol name_symbol = SymbolTable::probe(name_str, (int)name_len);
3824     if (name_symbol != NULL) {
3825       Method* method = the_class-&gt;lookup_method(name_symbol, signature);
3826       if (method != NULL) {
3827         // Even if prefixed, intermediate methods must exist.
3828         if (method-&gt;is_native()) {
3829           // Wahoo, we found a (possibly prefixed) version of the method, return it.
3830           return method;
3831         }
3832         if (depth &lt; prefix_count) {
3833           // Try applying further prefixes (other than this one).
3834           method = search_prefix_name_space(depth+1, name_str, name_len, signature);
3835           if (method != NULL) {
3836             return method; // found
3837           }
3838 
3839           // Try adding this prefix to the method name and see if it matches
3840           // another method name.
3841           char* prefix = prefixes[depth];
3842           size_t prefix_len = strlen(prefix);
3843           size_t trial_len = name_len + prefix_len;
3844           char* trial_name_str = NEW_RESOURCE_ARRAY(char, trial_len + 1);
3845           strcpy(trial_name_str, prefix);
3846           strcat(trial_name_str, name_str);
3847           method = search_prefix_name_space(depth+1, trial_name_str, trial_len,
3848                                             signature);
3849           if (method != NULL) {
3850             // If found along this branch, it was prefixed, mark as such
3851             method-&gt;set_is_prefixed_native();
3852             return method; // found
3853           }
3854         }
3855       }
3856     }
3857     return NULL;  // This whole branch bore nothing
3858   }
3859 
3860   // Return the method name with old prefixes stripped away.
3861   char* method_name_without_prefixes(Method* method) {
3862     Symbol* name = method-&gt;name();
3863     char* name_str = name-&gt;as_utf8();
3864 
3865     // Old prefixing may be defunct, strip prefixes, if any.
3866     for (int i = prefix_count-1; i &gt;= 0; i--) {
3867       char* prefix = prefixes[i];
3868       size_t prefix_len = strlen(prefix);
3869       if (strncmp(prefix, name_str, prefix_len) == 0) {
3870         name_str += prefix_len;
3871       }
3872     }
3873     return name_str;
3874   }
3875 
3876   // Strip any prefixes off the old native method, then try to find a
3877   // (possibly prefixed) new native that matches it.
3878   Method* strip_and_search_for_new_native(Method* method) {
3879     ResourceMark rm;
3880     char* name_str = method_name_without_prefixes(method);
3881     return search_prefix_name_space(0, name_str, strlen(name_str),
3882                                     method-&gt;signature());
3883   }
3884 
3885  public:
3886 
3887   // Construct a native method transfer processor for this class.
3888   TransferNativeFunctionRegistration(InstanceKlass* _the_class) {
3889     assert(SafepointSynchronize::is_at_safepoint(), &quot;sanity check&quot;);
3890 
3891     the_class = _the_class;
3892     prefixes = JvmtiExport::get_all_native_method_prefixes(&amp;prefix_count);
3893   }
3894 
3895   // Attempt to transfer any of the old or deleted methods that are native
3896   void transfer_registrations(Method** old_methods, int methods_length) {
3897     for (int j = 0; j &lt; methods_length; j++) {
3898       Method* old_method = old_methods[j];
3899 
3900       if (old_method-&gt;is_native() &amp;&amp; old_method-&gt;has_native_function()) {
3901         Method* new_method = strip_and_search_for_new_native(old_method);
3902         if (new_method != NULL) {
3903           // Actually set the native function in the new method.
3904           // Redefine does not send events (except CFLH), certainly not this
3905           // behind the scenes re-registration.
3906           new_method-&gt;set_native_function(old_method-&gt;native_function(),
3907                               !Method::native_bind_event_is_interesting);
3908         }
3909       }
3910     }
3911   }
3912 };
3913 
3914 // Don&#39;t lose the association between a native method and its JNI function.
3915 void VM_RedefineClasses::transfer_old_native_function_registrations(InstanceKlass* the_class) {
3916   TransferNativeFunctionRegistration transfer(the_class);
3917   transfer.transfer_registrations(_deleted_methods, _deleted_methods_length);
3918   transfer.transfer_registrations(_matching_old_methods, _matching_methods_length);
3919 }
3920 
3921 // Deoptimize all compiled code that depends on this class.
3922 //
3923 // If the can_redefine_classes capability is obtained in the onload
3924 // phase then the compiler has recorded all dependencies from startup.
3925 // In that case we need only deoptimize and throw away all compiled code
3926 // that depends on the class.
3927 //
3928 // If can_redefine_classes is obtained sometime after the onload
3929 // phase then the dependency information may be incomplete. In that case
3930 // the first call to RedefineClasses causes all compiled code to be
3931 // thrown away. As can_redefine_classes has been obtained then
3932 // all future compilations will record dependencies so second and
3933 // subsequent calls to RedefineClasses need only throw away code
3934 // that depends on the class.
3935 //
3936 
3937 // First step is to walk the code cache for each class redefined and mark
3938 // dependent methods.  Wait until all classes are processed to deoptimize everything.
3939 void VM_RedefineClasses::mark_dependent_code(InstanceKlass* ik) {
3940   assert_locked_or_safepoint(Compile_lock);
3941 
3942   // All dependencies have been recorded from startup or this is a second or
3943   // subsequent use of RedefineClasses
3944   if (JvmtiExport::all_dependencies_are_recorded()) {
3945     CodeCache::mark_for_evol_deoptimization(ik);
3946   }
3947 }
3948 
3949 void VM_RedefineClasses::flush_dependent_code() {
3950   assert(SafepointSynchronize::is_at_safepoint(), &quot;sanity check&quot;);
3951 
3952   bool deopt_needed;
3953 
3954   // This is the first redefinition, mark all the nmethods for deoptimization
3955   if (!JvmtiExport::all_dependencies_are_recorded()) {
3956     log_debug(redefine, class, nmethod)(&quot;Marked all nmethods for deopt&quot;);
3957     CodeCache::mark_all_nmethods_for_evol_deoptimization();
3958     deopt_needed = true;
3959   } else {
3960     int deopt = CodeCache::mark_dependents_for_evol_deoptimization();
3961     log_debug(redefine, class, nmethod)(&quot;Marked %d dependent nmethods for deopt&quot;, deopt);
3962     deopt_needed = (deopt != 0);
3963   }
3964 
3965   if (deopt_needed) {
3966     CodeCache::flush_evol_dependents();
3967   }
3968 
3969   // From now on we know that the dependency information is complete
3970   JvmtiExport::set_all_dependencies_are_recorded(true);
3971 }
3972 
3973 void VM_RedefineClasses::compute_added_deleted_matching_methods() {
3974   Method* old_method;
3975   Method* new_method;
3976 
3977   _matching_old_methods = NEW_RESOURCE_ARRAY(Method*, _old_methods-&gt;length());
3978   _matching_new_methods = NEW_RESOURCE_ARRAY(Method*, _old_methods-&gt;length());
3979   _added_methods        = NEW_RESOURCE_ARRAY(Method*, _new_methods-&gt;length());
3980   _deleted_methods      = NEW_RESOURCE_ARRAY(Method*, _old_methods-&gt;length());
3981 
3982   _matching_methods_length = 0;
3983   _deleted_methods_length  = 0;
3984   _added_methods_length    = 0;
3985 
3986   int nj = 0;
3987   int oj = 0;
3988   while (true) {
3989     if (oj &gt;= _old_methods-&gt;length()) {
3990       if (nj &gt;= _new_methods-&gt;length()) {
3991         break; // we&#39;ve looked at everything, done
3992       }
3993       // New method at the end
3994       new_method = _new_methods-&gt;at(nj);
3995       _added_methods[_added_methods_length++] = new_method;
3996       ++nj;
3997     } else if (nj &gt;= _new_methods-&gt;length()) {
3998       // Old method, at the end, is deleted
3999       old_method = _old_methods-&gt;at(oj);
4000       _deleted_methods[_deleted_methods_length++] = old_method;
4001       ++oj;
4002     } else {
4003       old_method = _old_methods-&gt;at(oj);
4004       new_method = _new_methods-&gt;at(nj);
4005       if (old_method-&gt;name() == new_method-&gt;name()) {
4006         if (old_method-&gt;signature() == new_method-&gt;signature()) {
4007           _matching_old_methods[_matching_methods_length  ] = old_method;
4008           _matching_new_methods[_matching_methods_length++] = new_method;
4009           ++nj;
4010           ++oj;
4011         } else {
4012           // added overloaded have already been moved to the end,
4013           // so this is a deleted overloaded method
4014           _deleted_methods[_deleted_methods_length++] = old_method;
4015           ++oj;
4016         }
4017       } else { // names don&#39;t match
4018         if (old_method-&gt;name()-&gt;fast_compare(new_method-&gt;name()) &gt; 0) {
4019           // new method
4020           _added_methods[_added_methods_length++] = new_method;
4021           ++nj;
4022         } else {
4023           // deleted method
4024           _deleted_methods[_deleted_methods_length++] = old_method;
4025           ++oj;
4026         }
4027       }
4028     }
4029   }
4030   assert(_matching_methods_length + _deleted_methods_length == _old_methods-&gt;length(), &quot;sanity&quot;);
4031   assert(_matching_methods_length + _added_methods_length == _new_methods-&gt;length(), &quot;sanity&quot;);
4032 }
4033 
4034 
4035 void VM_RedefineClasses::swap_annotations(InstanceKlass* the_class,
4036                                           InstanceKlass* scratch_class) {
4037   // Swap annotation fields values
4038   Annotations* old_annotations = the_class-&gt;annotations();
4039   the_class-&gt;set_annotations(scratch_class-&gt;annotations());
4040   scratch_class-&gt;set_annotations(old_annotations);
4041 }
4042 
4043 
4044 // Install the redefinition of a class:
4045 //    - house keeping (flushing breakpoints and caches, deoptimizing
4046 //      dependent compiled code)
4047 //    - replacing parts in the_class with parts from scratch_class
4048 //    - adding a weak reference to track the obsolete but interesting
4049 //      parts of the_class
4050 //    - adjusting constant pool caches and vtables in other classes
4051 //      that refer to methods in the_class. These adjustments use the
4052 //      ClassLoaderDataGraph::classes_do() facility which only allows
4053 //      a helper method to be specified. The interesting parameters
4054 //      that we would like to pass to the helper method are saved in
4055 //      static global fields in the VM operation.
4056 void VM_RedefineClasses::redefine_single_class(jclass the_jclass,
4057        InstanceKlass* scratch_class, TRAPS) {
4058 
4059   HandleMark hm(THREAD);   // make sure handles from this call are freed
4060 
4061   if (log_is_enabled(Info, redefine, class, timer)) {
4062     _timer_rsc_phase1.start();
4063   }
4064 
4065   InstanceKlass* the_class = get_ik(the_jclass);
4066 
4067   // Set some flags to control and optimize adjusting method entries
4068   _has_redefined_Object |= the_class == SystemDictionary::Object_klass();
4069   _has_null_class_loader |= the_class-&gt;class_loader() == NULL;
4070 
4071   // Remove all breakpoints in methods of this class
4072   JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
4073   jvmti_breakpoints.clearall_in_class_at_safepoint(the_class);
4074 
4075   // Mark all compiled code that depends on this class
4076   mark_dependent_code(the_class);
4077 
4078   _old_methods = the_class-&gt;methods();
4079   _new_methods = scratch_class-&gt;methods();
4080   _the_class = the_class;
4081   compute_added_deleted_matching_methods();
4082   update_jmethod_ids(THREAD);
4083 
4084   _any_class_has_resolved_methods = the_class-&gt;has_resolved_methods() || _any_class_has_resolved_methods;
4085 
4086   // Attach new constant pool to the original klass. The original
4087   // klass still refers to the old constant pool (for now).
4088   scratch_class-&gt;constants()-&gt;set_pool_holder(the_class);
4089 
4090 #if 0
4091   // In theory, with constant pool merging in place we should be able
4092   // to save space by using the new, merged constant pool in place of
4093   // the old constant pool(s). By &quot;pool(s)&quot; I mean the constant pool in
4094   // the klass version we are replacing now and any constant pool(s) in
4095   // previous versions of klass. Nice theory, doesn&#39;t work in practice.
4096   // When this code is enabled, even simple programs throw NullPointer
4097   // exceptions. I&#39;m guessing that this is caused by some constant pool
4098   // cache difference between the new, merged constant pool and the
4099   // constant pool that was just being used by the klass. I&#39;m keeping
4100   // this code around to archive the idea, but the code has to remain
4101   // disabled for now.
4102 
4103   // Attach each old method to the new constant pool. This can be
4104   // done here since we are past the bytecode verification and
4105   // constant pool optimization phases.
4106   for (int i = _old_methods-&gt;length() - 1; i &gt;= 0; i--) {
4107     Method* method = _old_methods-&gt;at(i);
4108     method-&gt;set_constants(scratch_class-&gt;constants());
4109   }
4110 
4111   // NOTE: this doesn&#39;t work because you can redefine the same class in two
4112   // threads, each getting their own constant pool data appended to the
4113   // original constant pool.  In order for the new methods to work when they
4114   // become old methods, they need to keep their updated copy of the constant pool.
4115 
4116   {
4117     // walk all previous versions of the klass
4118     InstanceKlass *ik = the_class;
4119     PreviousVersionWalker pvw(ik);
4120     do {
4121       ik = pvw.next_previous_version();
4122       if (ik != NULL) {
4123 
4124         // attach previous version of klass to the new constant pool
4125         ik-&gt;set_constants(scratch_class-&gt;constants());
4126 
4127         // Attach each method in the previous version of klass to the
4128         // new constant pool
4129         Array&lt;Method*&gt;* prev_methods = ik-&gt;methods();
4130         for (int i = prev_methods-&gt;length() - 1; i &gt;= 0; i--) {
4131           Method* method = prev_methods-&gt;at(i);
4132           method-&gt;set_constants(scratch_class-&gt;constants());
4133         }
4134       }
4135     } while (ik != NULL);
4136   }
4137 #endif
4138 
4139   // Replace methods and constantpool
4140   the_class-&gt;set_methods(_new_methods);
4141   scratch_class-&gt;set_methods(_old_methods);     // To prevent potential GCing of the old methods,
4142                                           // and to be able to undo operation easily.
4143 
4144   Array&lt;int&gt;* old_ordering = the_class-&gt;method_ordering();
4145   the_class-&gt;set_method_ordering(scratch_class-&gt;method_ordering());
4146   scratch_class-&gt;set_method_ordering(old_ordering);
4147 
4148   ConstantPool* old_constants = the_class-&gt;constants();
4149   the_class-&gt;set_constants(scratch_class-&gt;constants());
4150   scratch_class-&gt;set_constants(old_constants);  // See the previous comment.
4151 #if 0
4152   // We are swapping the guts of &quot;the new class&quot; with the guts of &quot;the
4153   // class&quot;. Since the old constant pool has just been attached to &quot;the
4154   // new class&quot;, it seems logical to set the pool holder in the old
4155   // constant pool also. However, doing this will change the observable
4156   // class hierarchy for any old methods that are still executing. A
4157   // method can query the identity of its &quot;holder&quot; and this query uses
4158   // the method&#39;s constant pool link to find the holder. The change in
4159   // holding class from &quot;the class&quot; to &quot;the new class&quot; can confuse
4160   // things.
4161   //
4162   // Setting the old constant pool&#39;s holder will also cause
4163   // verification done during vtable initialization below to fail.
4164   // During vtable initialization, the vtable&#39;s class is verified to be
4165   // a subtype of the method&#39;s holder. The vtable&#39;s class is &quot;the
4166   // class&quot; and the method&#39;s holder is gotten from the constant pool
4167   // link in the method itself. For &quot;the class&quot;&#39;s directly implemented
4168   // methods, the method holder is &quot;the class&quot; itself (as gotten from
4169   // the new constant pool). The check works fine in this case. The
4170   // check also works fine for methods inherited from super classes.
4171   //
4172   // Miranda methods are a little more complicated. A miranda method is
4173   // provided by an interface when the class implementing the interface
4174   // does not provide its own method.  These interfaces are implemented
4175   // internally as an InstanceKlass. These special instanceKlasses
4176   // share the constant pool of the class that &quot;implements&quot; the
4177   // interface. By sharing the constant pool, the method holder of a
4178   // miranda method is the class that &quot;implements&quot; the interface. In a
4179   // non-redefine situation, the subtype check works fine. However, if
4180   // the old constant pool&#39;s pool holder is modified, then the check
4181   // fails because there is no class hierarchy relationship between the
4182   // vtable&#39;s class and &quot;the new class&quot;.
4183 
4184   old_constants-&gt;set_pool_holder(scratch_class());
4185 #endif
4186 
4187   // track number of methods that are EMCP for add_previous_version() call below
4188   int emcp_method_count = check_methods_and_mark_as_obsolete();
4189   transfer_old_native_function_registrations(the_class);
4190 
4191   // The class file bytes from before any retransformable agents mucked
4192   // with them was cached on the scratch class, move to the_class.
4193   // Note: we still want to do this if nothing needed caching since it
4194   // should get cleared in the_class too.
4195   if (the_class-&gt;get_cached_class_file() == 0) {
4196     // the_class doesn&#39;t have a cache yet so copy it
4197     the_class-&gt;set_cached_class_file(scratch_class-&gt;get_cached_class_file());
4198   }
4199   else if (scratch_class-&gt;get_cached_class_file() !=
4200            the_class-&gt;get_cached_class_file()) {
4201     // The same class can be present twice in the scratch classes list or there
4202     // are multiple concurrent RetransformClasses calls on different threads.
4203     // In such cases we have to deallocate scratch_class cached_class_file.
4204     os::free(scratch_class-&gt;get_cached_class_file());
4205   }
4206 
4207   // NULL out in scratch class to not delete twice.  The class to be redefined
4208   // always owns these bytes.
4209   scratch_class-&gt;set_cached_class_file(NULL);
4210 
4211   // Replace inner_classes
4212   Array&lt;u2&gt;* old_inner_classes = the_class-&gt;inner_classes();
4213   the_class-&gt;set_inner_classes(scratch_class-&gt;inner_classes());
4214   scratch_class-&gt;set_inner_classes(old_inner_classes);
4215 
4216   // Initialize the vtable and interface table after
4217   // methods have been rewritten
4218   // no exception should happen here since we explicitly
4219   // do not check loader constraints.
4220   // compare_and_normalize_class_versions has already checked:
4221   //  - classloaders unchanged, signatures unchanged
4222   //  - all instanceKlasses for redefined classes reused &amp; contents updated
4223   the_class-&gt;vtable().initialize_vtable(false, THREAD);
4224   the_class-&gt;itable().initialize_itable(false, THREAD);
4225   assert(!HAS_PENDING_EXCEPTION || (THREAD-&gt;pending_exception()-&gt;is_a(SystemDictionary::ThreadDeath_klass())), &quot;redefine exception&quot;);
4226 
4227   // Leave arrays of jmethodIDs and itable index cache unchanged
4228 
4229   // Copy the &quot;source file name&quot; attribute from new class version
4230   the_class-&gt;set_source_file_name_index(
4231     scratch_class-&gt;source_file_name_index());
4232 
4233   // Copy the &quot;source debug extension&quot; attribute from new class version
4234   the_class-&gt;set_source_debug_extension(
4235     scratch_class-&gt;source_debug_extension(),
4236     scratch_class-&gt;source_debug_extension() == NULL ? 0 :
4237     (int)strlen(scratch_class-&gt;source_debug_extension()));
4238 
4239   // Use of javac -g could be different in the old and the new
4240   if (scratch_class-&gt;access_flags().has_localvariable_table() !=
4241       the_class-&gt;access_flags().has_localvariable_table()) {
4242 
4243     AccessFlags flags = the_class-&gt;access_flags();
4244     if (scratch_class-&gt;access_flags().has_localvariable_table()) {
4245       flags.set_has_localvariable_table();
4246     } else {
4247       flags.clear_has_localvariable_table();
4248     }
4249     the_class-&gt;set_access_flags(flags);
4250   }
4251 
4252   swap_annotations(the_class, scratch_class);
4253 
4254   // Replace minor version number of class file
4255   u2 old_minor_version = the_class-&gt;minor_version();
4256   the_class-&gt;set_minor_version(scratch_class-&gt;minor_version());
4257   scratch_class-&gt;set_minor_version(old_minor_version);
4258 
4259   // Replace major version number of class file
4260   u2 old_major_version = the_class-&gt;major_version();
4261   the_class-&gt;set_major_version(scratch_class-&gt;major_version());
4262   scratch_class-&gt;set_major_version(old_major_version);
4263 
4264   // Replace CP indexes for class and name+type of enclosing method
4265   u2 old_class_idx  = the_class-&gt;enclosing_method_class_index();
4266   u2 old_method_idx = the_class-&gt;enclosing_method_method_index();
4267   the_class-&gt;set_enclosing_method_indices(
4268     scratch_class-&gt;enclosing_method_class_index(),
4269     scratch_class-&gt;enclosing_method_method_index());
4270   scratch_class-&gt;set_enclosing_method_indices(old_class_idx, old_method_idx);
4271 
4272   // Replace fingerprint data
4273   the_class-&gt;set_has_passed_fingerprint_check(scratch_class-&gt;has_passed_fingerprint_check());
4274   the_class-&gt;store_fingerprint(scratch_class-&gt;get_stored_fingerprint());
4275 
4276   the_class-&gt;set_has_been_redefined();
4277 
4278   if (!the_class-&gt;should_be_initialized()) {
4279     // Class was already initialized, so AOT has only seen the original version.
4280     // We need to let AOT look at it again.
4281     AOTLoader::load_for_klass(the_class, THREAD);
4282   }
4283 
4284   // keep track of previous versions of this class
4285   the_class-&gt;add_previous_version(scratch_class, emcp_method_count);
4286 
4287   _timer_rsc_phase1.stop();
4288   if (log_is_enabled(Info, redefine, class, timer)) {
4289     _timer_rsc_phase2.start();
4290   }
4291 
4292   if (the_class-&gt;oop_map_cache() != NULL) {
4293     // Flush references to any obsolete methods from the oop map cache
4294     // so that obsolete methods are not pinned.
4295     the_class-&gt;oop_map_cache()-&gt;flush_obsolete_entries();
4296   }
4297 
4298   increment_class_counter((InstanceKlass *)the_class, THREAD);
4299 
4300   if (EventClassRedefinition::is_enabled()) {
4301     EventClassRedefinition event;
4302     event.set_classModificationCount(java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()));
4303     event.set_redefinedClass(the_class);
4304     event.set_redefinitionId(_id);
4305     event.commit();
4306   }
4307 
4308   {
4309     ResourceMark rm(THREAD);
4310     // increment the classRedefinedCount field in the_class and in any
4311     // direct and indirect subclasses of the_class
4312     log_info(redefine, class, load)
4313       (&quot;redefined name=%s, count=%d (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;,
4314        the_class-&gt;external_name(), java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()), os::available_memory() &gt;&gt; 10);
4315     Events::log_redefinition(THREAD, &quot;redefined class name=%s, count=%d&quot;,
4316                              the_class-&gt;external_name(),
4317                              java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()));
4318 
4319   }
4320   _timer_rsc_phase2.stop();
4321 
4322 } // end redefine_single_class()
4323 
4324 
4325 // Increment the classRedefinedCount field in the specific InstanceKlass
4326 // and in all direct and indirect subclasses.
4327 void VM_RedefineClasses::increment_class_counter(InstanceKlass *ik, TRAPS) {
4328   oop class_mirror = ik-&gt;java_mirror();
4329   Klass* class_oop = java_lang_Class::as_Klass(class_mirror);
4330   int new_count = java_lang_Class::classRedefinedCount(class_mirror) + 1;
4331   java_lang_Class::set_classRedefinedCount(class_mirror, new_count);
4332 
4333   if (class_oop != _the_class) {
4334     // _the_class count is printed at end of redefine_single_class()
4335     log_debug(redefine, class, subclass)(&quot;updated count in subclass=%s to %d&quot;, ik-&gt;external_name(), new_count);
4336   }
4337 
4338   for (Klass *subk = ik-&gt;subklass(); subk != NULL;
4339        subk = subk-&gt;next_sibling()) {
4340     if (subk-&gt;is_instance_klass()) {
4341       // Only update instanceKlasses
4342       InstanceKlass *subik = InstanceKlass::cast(subk);
4343       // recursively do subclasses of the current subclass
4344       increment_class_counter(subik, THREAD);
4345     }
4346   }
4347 }
4348 
4349 void VM_RedefineClasses::CheckClass::do_klass(Klass* k) {
4350   bool no_old_methods = true;  // be optimistic
4351 
4352   // Both array and instance classes have vtables.
4353   // a vtable should never contain old or obsolete methods
4354   ResourceMark rm(_thread);
4355   if (k-&gt;vtable_length() &gt; 0 &amp;&amp;
4356       !k-&gt;vtable().check_no_old_or_obsolete_entries()) {
4357     if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4358       log_trace(redefine, class, obsolete, metadata)
4359         (&quot;klassVtable::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4360          k-&gt;signature_name());
4361       k-&gt;vtable().dump_vtable();
4362     }
4363     no_old_methods = false;
4364   }
4365 
4366   if (k-&gt;is_instance_klass()) {
4367     HandleMark hm(_thread);
4368     InstanceKlass *ik = InstanceKlass::cast(k);
4369 
4370     // an itable should never contain old or obsolete methods
4371     if (ik-&gt;itable_length() &gt; 0 &amp;&amp;
4372         !ik-&gt;itable().check_no_old_or_obsolete_entries()) {
4373       if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4374         log_trace(redefine, class, obsolete, metadata)
4375           (&quot;klassItable::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4376            ik-&gt;signature_name());
4377         ik-&gt;itable().dump_itable();
4378       }
4379       no_old_methods = false;
4380     }
4381 
4382     // the constant pool cache should never contain non-deleted old or obsolete methods
4383     if (ik-&gt;constants() != NULL &amp;&amp;
4384         ik-&gt;constants()-&gt;cache() != NULL &amp;&amp;
4385         !ik-&gt;constants()-&gt;cache()-&gt;check_no_old_or_obsolete_entries()) {
4386       if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4387         log_trace(redefine, class, obsolete, metadata)
4388           (&quot;cp-cache::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4389            ik-&gt;signature_name());
4390         ik-&gt;constants()-&gt;cache()-&gt;dump_cache();
4391       }
4392       no_old_methods = false;
4393     }
4394   }
4395 
4396   // print and fail guarantee if old methods are found.
4397   if (!no_old_methods) {
4398     if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4399       dump_methods();
4400     } else {
4401       log_trace(redefine, class)(&quot;Use the &#39;-Xlog:redefine+class*:&#39; option &quot;
4402         &quot;to see more info about the following guarantee() failure.&quot;);
4403     }
4404     guarantee(false, &quot;OLD and/or OBSOLETE method(s) found&quot;);
4405   }
4406 }
4407 
4408 u8 VM_RedefineClasses::next_id() {
4409   while (true) {
4410     u8 id = _id_counter;
4411     u8 next_id = id + 1;
4412     u8 result = Atomic::cmpxchg(&amp;_id_counter, id, next_id);
4413     if (result == id) {
4414       return next_id;
4415     }
4416   }
4417 }
4418 
4419 void VM_RedefineClasses::dump_methods() {
4420   int j;
4421   log_trace(redefine, class, dump)(&quot;_old_methods --&quot;);
4422   for (j = 0; j &lt; _old_methods-&gt;length(); ++j) {
4423     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4424     Method* m = _old_methods-&gt;at(j);
4425     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4426     m-&gt;access_flags().print_on(&amp;log_stream);
4427     log_stream.print(&quot; --  &quot;);
4428     m-&gt;print_name(&amp;log_stream);
4429     log_stream.cr();
4430   }
4431   log_trace(redefine, class, dump)(&quot;_new_methods --&quot;);
4432   for (j = 0; j &lt; _new_methods-&gt;length(); ++j) {
4433     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4434     Method* m = _new_methods-&gt;at(j);
4435     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4436     m-&gt;access_flags().print_on(&amp;log_stream);
4437     log_stream.print(&quot; --  &quot;);
4438     m-&gt;print_name(&amp;log_stream);
4439     log_stream.cr();
4440   }
4441   log_trace(redefine, class, dump)(&quot;_matching_methods --&quot;);
4442   for (j = 0; j &lt; _matching_methods_length; ++j) {
4443     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4444     Method* m = _matching_old_methods[j];
4445     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4446     m-&gt;access_flags().print_on(&amp;log_stream);
4447     log_stream.print(&quot; --  &quot;);
4448     m-&gt;print_name();
4449     log_stream.cr();
4450 
4451     m = _matching_new_methods[j];
4452     log_stream.print(&quot;      (%5d)  &quot;, m-&gt;vtable_index());
4453     m-&gt;access_flags().print_on(&amp;log_stream);
4454     log_stream.cr();
4455   }
4456   log_trace(redefine, class, dump)(&quot;_deleted_methods --&quot;);
4457   for (j = 0; j &lt; _deleted_methods_length; ++j) {
4458     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4459     Method* m = _deleted_methods[j];
4460     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4461     m-&gt;access_flags().print_on(&amp;log_stream);
4462     log_stream.print(&quot; --  &quot;);
4463     m-&gt;print_name(&amp;log_stream);
4464     log_stream.cr();
4465   }
4466   log_trace(redefine, class, dump)(&quot;_added_methods --&quot;);
4467   for (j = 0; j &lt; _added_methods_length; ++j) {
4468     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4469     Method* m = _added_methods[j];
4470     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4471     m-&gt;access_flags().print_on(&amp;log_stream);
4472     log_stream.print(&quot; --  &quot;);
4473     m-&gt;print_name(&amp;log_stream);
4474     log_stream.cr();
4475   }
4476 }
4477 
4478 void VM_RedefineClasses::print_on_error(outputStream* st) const {
4479   VM_Operation::print_on_error(st);
4480   if (_the_class != NULL) {
4481     ResourceMark rm;
4482     st-&gt;print_cr(&quot;, redefining class %s&quot;, _the_class-&gt;external_name());
4483   }
4484 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
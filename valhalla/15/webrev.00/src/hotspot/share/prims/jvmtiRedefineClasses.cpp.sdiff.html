<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiRedefineClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeLookup.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiRedefineClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1464     int old_i;  // index into old_cp
1465 
1466     // index zero (0) is not used in constantPools
1467     for (old_i = 1; old_i &lt; old_cp-&gt;length(); old_i++) {
1468       // leave debugging crumb
1469       jbyte old_tag = old_cp-&gt;tag_at(old_i).value();
1470       switch (old_tag) {
1471       case JVM_CONSTANT_Class:
1472       case JVM_CONSTANT_UnresolvedClass:
1473         // revert the copy to JVM_CONSTANT_UnresolvedClass
1474         // May be resolving while calling this so do the same for
1475         // JVM_CONSTANT_UnresolvedClass (klass_name_at() deals with transition)
1476         (*merge_cp_p)-&gt;temp_unresolved_klass_at_put(old_i,
1477           old_cp-&gt;klass_name_index_at(old_i));
1478         break;
1479 
1480       case JVM_CONSTANT_Double:
1481       case JVM_CONSTANT_Long:
1482         // just copy the entry to *merge_cp_p, but double and long take
1483         // two constant pool entries
<span class="line-modified">1484         ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i, CHECK_0);</span>
1485         old_i++;
1486         break;
1487 
1488       default:
1489         // just copy the entry to *merge_cp_p
<span class="line-modified">1490         ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i, CHECK_0);</span>
1491         break;
1492       }
1493     } // end for each old_cp entry
1494 
<span class="line-modified">1495     ConstantPool::copy_operands(old_cp, *merge_cp_p, CHECK_0);</span>
<span class="line-modified">1496     (*merge_cp_p)-&gt;extend_operands(scratch_cp, CHECK_0);</span>
1497 
1498     // We don&#39;t need to sanity check that *merge_cp_length_p is within
1499     // *merge_cp_p bounds since we have the minimum on-entry check above.
1500     (*merge_cp_length_p) = old_i;
1501   }
1502 
1503   // merge_cp_len should be the same as old_cp-&gt;length() at this point
1504   // so this trace message is really a &quot;warm-and-breathing&quot; message.
1505   log_debug(redefine, class, constantpool)(&quot;after pass 0: merge_cp_len=%d&quot;, *merge_cp_length_p);
1506 
1507   int scratch_i;  // index into scratch_cp
1508   {
1509     // Pass 1a:
1510     // Compare scratch_cp entries to the old_cp entries that we have
1511     // already copied to *merge_cp_p. In this pass, we are eliminating
1512     // exact duplicates (matching entry at same index) so we only
1513     // compare entries in the common indice range.
1514     int increment = 1;
1515     int pass1a_length = MIN2(old_cp-&gt;length(), scratch_cp-&gt;length());
1516     for (scratch_i = 1; scratch_i &lt; pass1a_length; scratch_i += increment) {
1517       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
1518       case JVM_CONSTANT_Double:
1519       case JVM_CONSTANT_Long:
1520         // double and long take two constant pool entries
1521         increment = 2;
1522         break;
1523 
1524       default:
1525         increment = 1;
1526         break;
1527       }
1528 
1529       bool match = scratch_cp-&gt;compare_entry_to(scratch_i, *merge_cp_p,
<span class="line-modified">1530         scratch_i, CHECK_0);</span>
1531       if (match) {
1532         // found a match at the same index so nothing more to do
1533         continue;
1534       } else if (is_unresolved_class_mismatch(scratch_cp, scratch_i,
1535                                               *merge_cp_p, scratch_i)) {
1536         // The mismatch in compare_entry_to() above is because of a
1537         // resolved versus unresolved class entry at the same index
1538         // with the same string value. Since Pass 0 reverted any
1539         // class entries to unresolved class entries in *merge_cp_p,
1540         // we go with the unresolved class entry.
1541         continue;
1542       }
1543 
1544       int found_i = scratch_cp-&gt;find_matching_entry(scratch_i, *merge_cp_p,
<span class="line-modified">1545         CHECK_0);</span>
1546       if (found_i != 0) {
1547         guarantee(found_i != scratch_i,
1548           &quot;compare_entry_to() and find_matching_entry() do not agree&quot;);
1549 
1550         // Found a matching entry somewhere else in *merge_cp_p so
1551         // just need a mapping entry.
1552         map_index(scratch_cp, scratch_i, found_i);
1553         continue;
1554       }
1555 
1556       // The find_matching_entry() call above could fail to find a match
1557       // due to a resolved versus unresolved class or string entry situation
1558       // like we solved above with the is_unresolved_*_mismatch() calls.
1559       // However, we would have to call is_unresolved_*_mismatch() over
1560       // all of *merge_cp_p (potentially) and that doesn&#39;t seem to be
1561       // worth the time.
1562 
1563       // No match found so we have to append this entry and any unique
1564       // referenced entries to *merge_cp_p.
1565       append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p,
<span class="line-modified">1566         CHECK_0);</span>
1567     }
1568   }
1569 
1570   log_debug(redefine, class, constantpool)
1571     (&quot;after pass 1a: merge_cp_len=%d, scratch_i=%d, index_map_len=%d&quot;,
1572      *merge_cp_length_p, scratch_i, _index_map_count);
1573 
1574   if (scratch_i &lt; scratch_cp-&gt;length()) {
1575     // Pass 1b:
1576     // old_cp is smaller than scratch_cp so there are entries in
1577     // scratch_cp that we have not yet processed. We take care of
1578     // those now.
1579     int increment = 1;
1580     for (; scratch_i &lt; scratch_cp-&gt;length(); scratch_i += increment) {
1581       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
1582       case JVM_CONSTANT_Double:
1583       case JVM_CONSTANT_Long:
1584         // double and long take two constant pool entries
1585         increment = 2;
1586         break;
1587 
1588       default:
1589         increment = 1;
1590         break;
1591       }
1592 
1593       int found_i =
<span class="line-modified">1594         scratch_cp-&gt;find_matching_entry(scratch_i, *merge_cp_p, CHECK_0);</span>
1595       if (found_i != 0) {
1596         // Found a matching entry somewhere else in *merge_cp_p so
1597         // just need a mapping entry.
1598         map_index(scratch_cp, scratch_i, found_i);
1599         continue;
1600       }
1601 
1602       // No match found so we have to append this entry and any unique
1603       // referenced entries to *merge_cp_p.
1604       append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p,
<span class="line-modified">1605         CHECK_0);</span>
1606     }
1607 
1608     log_debug(redefine, class, constantpool)
1609       (&quot;after pass 1b: merge_cp_len=%d, scratch_i=%d, index_map_len=%d&quot;,
1610        *merge_cp_length_p, scratch_i, _index_map_count);
1611   }
1612   finalize_operands_merge(*merge_cp_p, THREAD);
1613 
1614   return true;
1615 } // end merge_constant_pools()
1616 
1617 
1618 // Scoped object to clean up the constant pool(s) created for merging
1619 class MergeCPCleaner {
1620   ClassLoaderData*   _loader_data;
1621   ConstantPool*      _cp;
1622   ConstantPool*      _scratch_cp;
1623  public:
1624   MergeCPCleaner(ClassLoaderData* loader_data, ConstantPool* merge_cp) :
1625                  _loader_data(loader_data), _cp(merge_cp), _scratch_cp(NULL) {}
</pre>
</td>
<td>
<hr />
<pre>
1464     int old_i;  // index into old_cp
1465 
1466     // index zero (0) is not used in constantPools
1467     for (old_i = 1; old_i &lt; old_cp-&gt;length(); old_i++) {
1468       // leave debugging crumb
1469       jbyte old_tag = old_cp-&gt;tag_at(old_i).value();
1470       switch (old_tag) {
1471       case JVM_CONSTANT_Class:
1472       case JVM_CONSTANT_UnresolvedClass:
1473         // revert the copy to JVM_CONSTANT_UnresolvedClass
1474         // May be resolving while calling this so do the same for
1475         // JVM_CONSTANT_UnresolvedClass (klass_name_at() deals with transition)
1476         (*merge_cp_p)-&gt;temp_unresolved_klass_at_put(old_i,
1477           old_cp-&gt;klass_name_index_at(old_i));
1478         break;
1479 
1480       case JVM_CONSTANT_Double:
1481       case JVM_CONSTANT_Long:
1482         // just copy the entry to *merge_cp_p, but double and long take
1483         // two constant pool entries
<span class="line-modified">1484         ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i, CHECK_false);</span>
1485         old_i++;
1486         break;
1487 
1488       default:
1489         // just copy the entry to *merge_cp_p
<span class="line-modified">1490         ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i, CHECK_false);</span>
1491         break;
1492       }
1493     } // end for each old_cp entry
1494 
<span class="line-modified">1495     ConstantPool::copy_operands(old_cp, *merge_cp_p, CHECK_false);</span>
<span class="line-modified">1496     (*merge_cp_p)-&gt;extend_operands(scratch_cp, CHECK_false);</span>
1497 
1498     // We don&#39;t need to sanity check that *merge_cp_length_p is within
1499     // *merge_cp_p bounds since we have the minimum on-entry check above.
1500     (*merge_cp_length_p) = old_i;
1501   }
1502 
1503   // merge_cp_len should be the same as old_cp-&gt;length() at this point
1504   // so this trace message is really a &quot;warm-and-breathing&quot; message.
1505   log_debug(redefine, class, constantpool)(&quot;after pass 0: merge_cp_len=%d&quot;, *merge_cp_length_p);
1506 
1507   int scratch_i;  // index into scratch_cp
1508   {
1509     // Pass 1a:
1510     // Compare scratch_cp entries to the old_cp entries that we have
1511     // already copied to *merge_cp_p. In this pass, we are eliminating
1512     // exact duplicates (matching entry at same index) so we only
1513     // compare entries in the common indice range.
1514     int increment = 1;
1515     int pass1a_length = MIN2(old_cp-&gt;length(), scratch_cp-&gt;length());
1516     for (scratch_i = 1; scratch_i &lt; pass1a_length; scratch_i += increment) {
1517       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
1518       case JVM_CONSTANT_Double:
1519       case JVM_CONSTANT_Long:
1520         // double and long take two constant pool entries
1521         increment = 2;
1522         break;
1523 
1524       default:
1525         increment = 1;
1526         break;
1527       }
1528 
1529       bool match = scratch_cp-&gt;compare_entry_to(scratch_i, *merge_cp_p,
<span class="line-modified">1530         scratch_i, CHECK_false);</span>
1531       if (match) {
1532         // found a match at the same index so nothing more to do
1533         continue;
1534       } else if (is_unresolved_class_mismatch(scratch_cp, scratch_i,
1535                                               *merge_cp_p, scratch_i)) {
1536         // The mismatch in compare_entry_to() above is because of a
1537         // resolved versus unresolved class entry at the same index
1538         // with the same string value. Since Pass 0 reverted any
1539         // class entries to unresolved class entries in *merge_cp_p,
1540         // we go with the unresolved class entry.
1541         continue;
1542       }
1543 
1544       int found_i = scratch_cp-&gt;find_matching_entry(scratch_i, *merge_cp_p,
<span class="line-modified">1545         CHECK_false);</span>
1546       if (found_i != 0) {
1547         guarantee(found_i != scratch_i,
1548           &quot;compare_entry_to() and find_matching_entry() do not agree&quot;);
1549 
1550         // Found a matching entry somewhere else in *merge_cp_p so
1551         // just need a mapping entry.
1552         map_index(scratch_cp, scratch_i, found_i);
1553         continue;
1554       }
1555 
1556       // The find_matching_entry() call above could fail to find a match
1557       // due to a resolved versus unresolved class or string entry situation
1558       // like we solved above with the is_unresolved_*_mismatch() calls.
1559       // However, we would have to call is_unresolved_*_mismatch() over
1560       // all of *merge_cp_p (potentially) and that doesn&#39;t seem to be
1561       // worth the time.
1562 
1563       // No match found so we have to append this entry and any unique
1564       // referenced entries to *merge_cp_p.
1565       append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p,
<span class="line-modified">1566         CHECK_false);</span>
1567     }
1568   }
1569 
1570   log_debug(redefine, class, constantpool)
1571     (&quot;after pass 1a: merge_cp_len=%d, scratch_i=%d, index_map_len=%d&quot;,
1572      *merge_cp_length_p, scratch_i, _index_map_count);
1573 
1574   if (scratch_i &lt; scratch_cp-&gt;length()) {
1575     // Pass 1b:
1576     // old_cp is smaller than scratch_cp so there are entries in
1577     // scratch_cp that we have not yet processed. We take care of
1578     // those now.
1579     int increment = 1;
1580     for (; scratch_i &lt; scratch_cp-&gt;length(); scratch_i += increment) {
1581       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
1582       case JVM_CONSTANT_Double:
1583       case JVM_CONSTANT_Long:
1584         // double and long take two constant pool entries
1585         increment = 2;
1586         break;
1587 
1588       default:
1589         increment = 1;
1590         break;
1591       }
1592 
1593       int found_i =
<span class="line-modified">1594         scratch_cp-&gt;find_matching_entry(scratch_i, *merge_cp_p, CHECK_false);</span>
1595       if (found_i != 0) {
1596         // Found a matching entry somewhere else in *merge_cp_p so
1597         // just need a mapping entry.
1598         map_index(scratch_cp, scratch_i, found_i);
1599         continue;
1600       }
1601 
1602       // No match found so we have to append this entry and any unique
1603       // referenced entries to *merge_cp_p.
1604       append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p,
<span class="line-modified">1605         CHECK_false);</span>
1606     }
1607 
1608     log_debug(redefine, class, constantpool)
1609       (&quot;after pass 1b: merge_cp_len=%d, scratch_i=%d, index_map_len=%d&quot;,
1610        *merge_cp_length_p, scratch_i, _index_map_count);
1611   }
1612   finalize_operands_merge(*merge_cp_p, THREAD);
1613 
1614   return true;
1615 } // end merge_constant_pools()
1616 
1617 
1618 // Scoped object to clean up the constant pool(s) created for merging
1619 class MergeCPCleaner {
1620   ClassLoaderData*   _loader_data;
1621   ConstantPool*      _cp;
1622   ConstantPool*      _scratch_cp;
1623  public:
1624   MergeCPCleaner(ClassLoaderData* loader_data, ConstantPool* merge_cp) :
1625                  _loader_data(loader_data), _cp(merge_cp), _scratch_cp(NULL) {}
</pre>
</td>
</tr>
</table>
<center><a href="jvm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeLookup.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
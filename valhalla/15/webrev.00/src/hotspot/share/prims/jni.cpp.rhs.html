<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jni.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012 Red Hat, Inc.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jni.h&quot;
  28 #include &quot;jvm.h&quot;
  29 #include &quot;ci/ciReplay.hpp&quot;
  30 #include &quot;classfile/altHashing.hpp&quot;
  31 #include &quot;classfile/classFileStream.hpp&quot;
  32 #include &quot;classfile/classLoader.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  35 #include &quot;classfile/moduleEntry.hpp&quot;</span>
  36 #include &quot;classfile/modules.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/vmSymbols.hpp&quot;
  40 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  41 #include &quot;interpreter/linkResolver.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/allocation.inline.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/access.inline.hpp&quot;
  51 #include &quot;oops/arrayOop.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/instanceOop.hpp&quot;
  54 #include &quot;oops/markWord.hpp&quot;
  55 #include &quot;oops/method.hpp&quot;
  56 #include &quot;oops/objArrayKlass.hpp&quot;
  57 #include &quot;oops/objArrayOop.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/symbol.hpp&quot;
  60 #include &quot;oops/typeArrayKlass.hpp&quot;
  61 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  62 #include &quot;oops/valueArrayOop.inline.hpp&quot;
  63 #include &quot;oops/valueKlass.inline.hpp&quot;
  64 #include &quot;prims/jniCheck.hpp&quot;
  65 #include &quot;prims/jniExport.hpp&quot;
  66 #include &quot;prims/jniFastGetField.hpp&quot;
  67 #include &quot;prims/jvm_misc.hpp&quot;
  68 #include &quot;prims/jvmtiExport.hpp&quot;
  69 #include &quot;prims/jvmtiThreadState.hpp&quot;
  70 #include &quot;runtime/atomic.hpp&quot;
  71 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  72 #include &quot;runtime/handles.inline.hpp&quot;
  73 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  74 #include &quot;runtime/java.hpp&quot;
  75 #include &quot;runtime/javaCalls.hpp&quot;
  76 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  77 #include &quot;runtime/jniHandles.inline.hpp&quot;
  78 #include &quot;runtime/reflection.hpp&quot;
  79 #include &quot;runtime/safepointVerifiers.hpp&quot;
  80 #include &quot;runtime/sharedRuntime.hpp&quot;
  81 #include &quot;runtime/signature.hpp&quot;
  82 #include &quot;runtime/thread.inline.hpp&quot;
  83 #include &quot;runtime/vmOperations.hpp&quot;
  84 #include &quot;services/memTracker.hpp&quot;
  85 #include &quot;services/runtimeService.hpp&quot;
  86 #include &quot;utilities/defaultStream.hpp&quot;
  87 #include &quot;utilities/dtrace.hpp&quot;
  88 #include &quot;utilities/events.hpp&quot;
  89 #include &quot;utilities/histogram.hpp&quot;
  90 #include &quot;utilities/macros.hpp&quot;
  91 #include &quot;utilities/vmError.hpp&quot;
  92 #if INCLUDE_JVMCI
  93 #include &quot;jvmci/jvmciCompiler.hpp&quot;
  94 #endif
  95 
  96 static jint CurrentVersion = JNI_VERSION_10;
  97 
  98 #ifdef _WIN32
  99 extern LONG WINAPI topLevelExceptionFilter(_EXCEPTION_POINTERS* );
 100 #endif
 101 
 102 // The DT_RETURN_MARK macros create a scoped object to fire the dtrace
 103 // &#39;-return&#39; probe regardless of the return path is taken out of the function.
 104 // Methods that have multiple return paths use this to avoid having to
 105 // instrument each return path.  Methods that use CHECK or THROW must use this
 106 // since those macros can cause an immedate uninstrumented return.
 107 //
 108 // In order to get the return value, a reference to the variable containing
 109 // the return value must be passed to the contructor of the object, and
 110 // the return value must be set before return (since the mark object has
 111 // a reference to it).
 112 //
 113 // Example:
 114 // DT_RETURN_MARK_DECL(SomeFunc, int);
 115 // JNI_ENTRY(int, SomeFunc, ...)
 116 //   int return_value = 0;
 117 //   DT_RETURN_MARK(SomeFunc, int, (const int&amp;)return_value);
 118 //   foo(CHECK_0)
 119 //   return_value = 5;
 120 //   return return_value;
 121 // JNI_END
 122 #define DT_RETURN_MARK_DECL(name, type, probe)                             \
 123   DTRACE_ONLY(                                                             \
 124     class DTraceReturnProbeMark_##name {                                   \
 125      public:                                                               \
 126       const type&amp; _ret_ref;                                                \
 127       DTraceReturnProbeMark_##name(const type&amp; v) : _ret_ref(v) {}         \
 128       ~DTraceReturnProbeMark_##name() {                                    \
 129         probe;                                                             \
 130       }                                                                    \
 131     }                                                                      \
 132   )
 133 // Void functions are simpler since there&#39;s no return value
 134 #define DT_VOID_RETURN_MARK_DECL(name, probe)                              \
 135   DTRACE_ONLY(                                                             \
 136     class DTraceReturnProbeMark_##name {                                   \
 137      public:                                                               \
 138       ~DTraceReturnProbeMark_##name() {                                    \
 139         probe;                                                             \
 140       }                                                                    \
 141     }                                                                      \
 142   )
 143 
 144 // Place these macros in the function to mark the return.  Non-void
 145 // functions need the type and address of the return value.
 146 #define DT_RETURN_MARK(name, type, ref) \
 147   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark(ref) )
 148 #define DT_VOID_RETURN_MARK(name) \
 149   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark )
 150 
 151 
 152 // Use these to select distinct code for floating-point vs. non-floating point
 153 // situations.  Used from within common macros where we need slightly
 154 // different behavior for Float/Double
 155 #define FP_SELECT_Boolean(intcode, fpcode) intcode
 156 #define FP_SELECT_Byte(intcode, fpcode)    intcode
 157 #define FP_SELECT_Char(intcode, fpcode)    intcode
 158 #define FP_SELECT_Short(intcode, fpcode)   intcode
 159 #define FP_SELECT_Object(intcode, fpcode)  intcode
 160 #define FP_SELECT_Int(intcode, fpcode)     intcode
 161 #define FP_SELECT_Long(intcode, fpcode)    intcode
 162 #define FP_SELECT_Float(intcode, fpcode)   fpcode
 163 #define FP_SELECT_Double(intcode, fpcode)  fpcode
 164 #define FP_SELECT(TypeName, intcode, fpcode) \
 165   FP_SELECT_##TypeName(intcode, fpcode)
 166 
 167 // Choose DT_RETURN_MARK macros  based on the type: float/double -&gt; void
 168 // (dtrace doesn&#39;t do FP yet)
 169 #define DT_RETURN_MARK_DECL_FOR(TypeName, name, type, probe)    \
 170   FP_SELECT(TypeName, \
 171     DT_RETURN_MARK_DECL(name, type, probe), DT_VOID_RETURN_MARK_DECL(name, probe) )
 172 #define DT_RETURN_MARK_FOR(TypeName, name, type, ref) \
 173   FP_SELECT(TypeName, \
 174     DT_RETURN_MARK(name, type, ref), DT_VOID_RETURN_MARK(name) )
 175 
 176 
 177 // out-of-line helpers for class jfieldIDWorkaround:
 178 
 179 bool jfieldIDWorkaround::is_valid_jfieldID(Klass* k, jfieldID id) {
 180   if (jfieldIDWorkaround::is_instance_jfieldID(k, id)) {
 181     uintptr_t as_uint = (uintptr_t) id;
 182     intptr_t offset = raw_instance_offset(id);
 183     if (is_checked_jfieldID(id)) {
 184       if (!klass_hash_ok(k, id)) {
 185         return false;
 186       }
 187     }
 188     return InstanceKlass::cast(k)-&gt;contains_field_offset(offset);
 189   } else {
 190     JNIid* result = (JNIid*) id;
 191 #ifdef ASSERT
 192     return result != NULL &amp;&amp; result-&gt;is_static_field_id();
 193 #else
 194     return result != NULL;
 195 #endif
 196   }
 197 }
 198 
 199 
 200 intptr_t jfieldIDWorkaround::encode_klass_hash(Klass* k, intptr_t offset) {
 201   if (offset &lt;= small_offset_mask) {
 202     Klass* field_klass = k;
 203     Klass* super_klass = field_klass-&gt;super();
 204     // With compressed oops the most super class with nonstatic fields would
 205     // be the owner of fields embedded in the header.
 206     while (InstanceKlass::cast(super_klass)-&gt;has_nonstatic_fields() &amp;&amp;
 207            InstanceKlass::cast(super_klass)-&gt;contains_field_offset(offset)) {
 208       field_klass = super_klass;   // super contains the field also
 209       super_klass = field_klass-&gt;super();
 210     }
 211     debug_only(NoSafepointVerifier nosafepoint;)
 212     uintptr_t klass_hash = field_klass-&gt;identity_hash();
 213     return ((klass_hash &amp; klass_mask) &lt;&lt; klass_shift) | checked_mask_in_place;
 214   } else {
 215 #if 0
 216     #ifndef PRODUCT
 217     {
 218       ResourceMark rm;
 219       warning(&quot;VerifyJNIFields: long offset %d in %s&quot;, offset, k-&gt;external_name());
 220     }
 221     #endif
 222 #endif
 223     return 0;
 224   }
 225 }
 226 
 227 bool jfieldIDWorkaround::klass_hash_ok(Klass* k, jfieldID id) {
 228   uintptr_t as_uint = (uintptr_t) id;
 229   intptr_t klass_hash = (as_uint &gt;&gt; klass_shift) &amp; klass_mask;
 230   do {
 231     debug_only(NoSafepointVerifier nosafepoint;)
 232     // Could use a non-blocking query for identity_hash here...
 233     if ((k-&gt;identity_hash() &amp; klass_mask) == klass_hash)
 234       return true;
 235     k = k-&gt;super();
 236   } while (k != NULL);
 237   return false;
 238 }
 239 
 240 void jfieldIDWorkaround::verify_instance_jfieldID(Klass* k, jfieldID id) {
 241   guarantee(jfieldIDWorkaround::is_instance_jfieldID(k, id), &quot;must be an instance field&quot; );
 242   uintptr_t as_uint = (uintptr_t) id;
 243   intptr_t offset = raw_instance_offset(id);
 244   if (VerifyJNIFields) {
 245     if (is_checked_jfieldID(id)) {
 246       guarantee(klass_hash_ok(k, id),
 247     &quot;Bug in native code: jfieldID class must match object&quot;);
 248     } else {
 249 #if 0
 250       #ifndef PRODUCT
 251       if (Verbose) {
 252   ResourceMark rm;
 253   warning(&quot;VerifyJNIFields: unverified offset %d for %s&quot;, offset, k-&gt;external_name());
 254       }
 255       #endif
 256 #endif
 257     }
 258   }
 259   guarantee(InstanceKlass::cast(k)-&gt;contains_field_offset(offset),
 260       &quot;Bug in native code: jfieldID offset must address interior of object&quot;);
 261 }
 262 
 263 // Wrapper to trace JNI functions
 264 
 265 #ifdef ASSERT
 266   Histogram* JNIHistogram;
 267   static volatile int JNIHistogram_lock = 0;
 268 
 269   class JNIHistogramElement : public HistogramElement {
 270     public:
 271      JNIHistogramElement(const char* name);
 272   };
 273 
 274   JNIHistogramElement::JNIHistogramElement(const char* elementName) {
 275     _name = elementName;
 276     uintx count = 0;
 277 
 278     while (Atomic::cmpxchg(&amp;JNIHistogram_lock, 0, 1) != 0) {
 279       while (Atomic::load_acquire(&amp;JNIHistogram_lock) != 0) {
 280         count +=1;
 281         if ( (WarnOnStalledSpinLock &gt; 0)
 282           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 283           warning(&quot;JNIHistogram_lock seems to be stalled&quot;);
 284         }
 285       }
 286      }
 287 
 288 
 289     if(JNIHistogram == NULL)
 290       JNIHistogram = new Histogram(&quot;JNI Call Counts&quot;,100);
 291 
 292     JNIHistogram-&gt;add_element(this);
 293     Atomic::dec(&amp;JNIHistogram_lock);
 294   }
 295 
 296   #define JNICountWrapper(arg)                                     \
 297      static JNIHistogramElement* e = new JNIHistogramElement(arg); \
 298       /* There is a MT-race condition in VC++. So we need to make sure that that e has been initialized */ \
 299      if (e != NULL) e-&gt;increment_count()
 300   #define JNIWrapper(arg) JNICountWrapper(arg);
 301 #else
 302   #define JNIWrapper(arg)
 303 #endif
 304 
 305 
 306 // Implementation of JNI entries
 307 
 308 DT_RETURN_MARK_DECL(DefineClass, jclass
 309                     , HOTSPOT_JNI_DEFINECLASS_RETURN(_ret_ref));
 310 
 311 JNI_ENTRY(jclass, jni_DefineClass(JNIEnv *env, const char *name, jobject loaderRef,
 312                                   const jbyte *buf, jsize bufLen))
 313   JNIWrapper(&quot;DefineClass&quot;);
 314 
 315   HOTSPOT_JNI_DEFINECLASS_ENTRY(
 316     env, (char*) name, loaderRef, (char*) buf, bufLen);
 317 
 318   jclass cls = NULL;
 319   DT_RETURN_MARK(DefineClass, jclass, (const jclass&amp;)cls);
 320 
 321   TempNewSymbol class_name = NULL;
 322   // Since exceptions can be thrown, class initialization can take place
 323   // if name is NULL no check for class name in .class stream has to be made.
 324   if (name != NULL) {
 325     const int str_len = (int)strlen(name);
 326     if (str_len &gt; Symbol::max_length()) {
 327       // It&#39;s impossible to create this class;  the name cannot fit
 328       // into the constant pool.
 329       Exceptions::fthrow(THREAD_AND_LOCATION,
 330                          vmSymbols::java_lang_NoClassDefFoundError(),
 331                          &quot;Class name exceeds maximum length of %d: %s&quot;,
 332                          Symbol::max_length(),
 333                          name);
 334       return 0;
 335     }
 336     class_name = SymbolTable::new_symbol(name);
 337   }
 338   ResourceMark rm(THREAD);
 339   ClassFileStream st((u1*)buf, bufLen, NULL, ClassFileStream::verify);
 340   Handle class_loader (THREAD, JNIHandles::resolve(loaderRef));
 341 
 342   if (UsePerfData &amp;&amp; !class_loader.is_null()) {
 343     // check whether the current caller thread holds the lock or not.
 344     // If not, increment the corresponding counter
 345     if (ObjectSynchronizer::
 346         query_lock_ownership((JavaThread*)THREAD, class_loader) !=
 347         ObjectSynchronizer::owner_self) {
 348       ClassLoader::sync_JNIDefineClassLockFreeCounter()-&gt;inc();
 349     }
 350   }
 351   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 352                                                    class_loader,
 353                                                    Handle(),
 354                                                    &amp;st,
 355                                                    CHECK_NULL);
 356 
 357   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 358     trace_class_resolution(k);
 359   }
 360 
 361   cls = (jclass)JNIHandles::make_local(
 362     env, k-&gt;java_mirror());
 363   return cls;
 364 JNI_END
 365 
 366 
 367 
 368 DT_RETURN_MARK_DECL(FindClass, jclass
 369                     , HOTSPOT_JNI_FINDCLASS_RETURN(_ret_ref));
 370 
 371 JNI_ENTRY(jclass, jni_FindClass(JNIEnv *env, const char *name))
 372   JNIWrapper(&quot;FindClass&quot;);
 373 
 374   HOTSPOT_JNI_FINDCLASS_ENTRY(env, (char *)name);
 375 
 376   jclass result = NULL;
 377   DT_RETURN_MARK(FindClass, jclass, (const jclass&amp;)result);
 378 
 379   // Sanity check the name:  it cannot be null or larger than the maximum size
 380   // name we can fit in the constant pool.
 381   if (name == NULL) {
 382     THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), &quot;No class name given&quot;);
 383   }
 384   if ((int)strlen(name) &gt; Symbol::max_length()) {
 385     Exceptions::fthrow(THREAD_AND_LOCATION,
 386                        vmSymbols::java_lang_NoClassDefFoundError(),
 387                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 388                        Symbol::max_length(),
 389                        name);
 390     return 0;
 391   }
 392 
 393   //%note jni_3
 394   Handle protection_domain;
 395   // Find calling class
 396   Klass* k = thread-&gt;security_get_caller_class(0);
 397   // default to the system loader when no context
 398   Handle loader(THREAD, SystemDictionary::java_system_loader());
 399   if (k != NULL) {
 400     // Special handling to make sure JNI_OnLoad and JNI_OnUnload are executed
 401     // in the correct class context.
 402     if (k-&gt;class_loader() == NULL &amp;&amp;
<a name="2" id="anc2"></a><span class="line-modified"> 403         k-&gt;name() == vmSymbols::jdk_internal_loader_NativeLibraries()) {</span>
 404       JavaValue result(T_OBJECT);
 405       JavaCalls::call_static(&amp;result, k,
 406                              vmSymbols::getFromClass_name(),
 407                              vmSymbols::void_class_signature(),
 408                              CHECK_NULL);
<a name="3" id="anc3"></a><span class="line-modified"> 409       // When invoked from JNI_OnLoad, NativeLibraries::getFromClass returns</span>
 410       // a non-NULL Class object.  When invoked from JNI_OnUnload,
 411       // it will return NULL to indicate no context.
 412       oop mirror = (oop) result.get_jobject();
 413       if (mirror != NULL) {
 414         Klass* fromClass = java_lang_Class::as_Klass(mirror);
 415         loader = Handle(THREAD, fromClass-&gt;class_loader());
 416         protection_domain = Handle(THREAD, fromClass-&gt;protection_domain());
 417       }
 418     } else {
 419       loader = Handle(THREAD, k-&gt;class_loader());
 420     }
 421   }
 422 
 423   TempNewSymbol sym = SymbolTable::new_symbol(name);
 424   result = find_class_from_class_loader(env, sym, true, loader,
 425                                         protection_domain, true, thread);
 426 
 427   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 428     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 429   }
 430 
 431   return result;
 432 JNI_END
 433 
 434 DT_RETURN_MARK_DECL(FromReflectedMethod, jmethodID
 435                     , HOTSPOT_JNI_FROMREFLECTEDMETHOD_RETURN((uintptr_t)_ret_ref));
 436 
 437 JNI_ENTRY(jmethodID, jni_FromReflectedMethod(JNIEnv *env, jobject method))
 438   JNIWrapper(&quot;FromReflectedMethod&quot;);
 439 
 440   HOTSPOT_JNI_FROMREFLECTEDMETHOD_ENTRY(env, method);
 441 
 442   jmethodID ret = NULL;
 443   DT_RETURN_MARK(FromReflectedMethod, jmethodID, (const jmethodID&amp;)ret);
 444 
 445   // method is a handle to a java.lang.reflect.Method object
 446   oop reflected  = JNIHandles::resolve_non_null(method);
 447   oop mirror     = NULL;
 448   int slot       = 0;
 449 
 450   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 451     mirror = java_lang_reflect_Constructor::clazz(reflected);
 452     slot   = java_lang_reflect_Constructor::slot(reflected);
 453   } else {
 454     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(), &quot;wrong type&quot;);
 455     mirror = java_lang_reflect_Method::clazz(reflected);
 456     slot   = java_lang_reflect_Method::slot(reflected);
 457   }
 458   Klass* k1 = java_lang_Class::as_Klass(mirror);
 459 
 460   // Make sure class is initialized before handing id&#39;s out to methods
 461   k1-&gt;initialize(CHECK_NULL);
 462   Method* m = InstanceKlass::cast(k1)-&gt;method_with_idnum(slot);
 463   ret = m==NULL? NULL : m-&gt;jmethod_id();  // return NULL if reflected method deleted
 464   return ret;
 465 JNI_END
 466 
 467 DT_RETURN_MARK_DECL(FromReflectedField, jfieldID
 468                     , HOTSPOT_JNI_FROMREFLECTEDFIELD_RETURN((uintptr_t)_ret_ref));
 469 
 470 JNI_ENTRY(jfieldID, jni_FromReflectedField(JNIEnv *env, jobject field))
 471   JNIWrapper(&quot;FromReflectedField&quot;);
 472 
 473   HOTSPOT_JNI_FROMREFLECTEDFIELD_ENTRY(env, field);
 474 
 475   jfieldID ret = NULL;
 476   DT_RETURN_MARK(FromReflectedField, jfieldID, (const jfieldID&amp;)ret);
 477 
 478   // field is a handle to a java.lang.reflect.Field object
 479   oop reflected   = JNIHandles::resolve_non_null(field);
 480   oop mirror      = java_lang_reflect_Field::clazz(reflected);
 481   Klass* k1       = java_lang_Class::as_Klass(mirror);
 482   int slot        = java_lang_reflect_Field::slot(reflected);
 483   int modifiers   = java_lang_reflect_Field::modifiers(reflected);
 484 
 485   // Make sure class is initialized before handing id&#39;s out to fields
 486   k1-&gt;initialize(CHECK_NULL);
 487 
 488   // First check if this is a static field
 489   if (modifiers &amp; JVM_ACC_STATIC) {
 490     intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 491     JNIid* id = InstanceKlass::cast(k1)-&gt;jni_id_for(offset);
 492     assert(id != NULL, &quot;corrupt Field object&quot;);
 493     debug_only(id-&gt;set_is_static_field_id();)
 494     // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
 495     ret = jfieldIDWorkaround::to_static_jfieldID(id);
 496     return ret;
 497   }
 498 
 499   // The slot is the index of the field description in the field-array
 500   // The jfieldID is the offset of the field within the object
 501   // It may also have hash bits for k, if VerifyJNIFields is turned on.
 502   intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 503   bool is_flattened = InstanceKlass::cast(k1)-&gt;field_is_flattened(slot);
 504   assert(InstanceKlass::cast(k1)-&gt;contains_field_offset(offset), &quot;stay within object&quot;);
 505   ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset, is_flattened);
 506   return ret;
 507 JNI_END
 508 
 509 
 510 DT_RETURN_MARK_DECL(ToReflectedMethod, jobject
 511                     , HOTSPOT_JNI_TOREFLECTEDMETHOD_RETURN(_ret_ref));
 512 
 513 JNI_ENTRY(jobject, jni_ToReflectedMethod(JNIEnv *env, jclass cls, jmethodID method_id, jboolean isStatic))
 514   JNIWrapper(&quot;ToReflectedMethod&quot;);
 515 
 516   HOTSPOT_JNI_TOREFLECTEDMETHOD_ENTRY(env, cls, (uintptr_t) method_id, isStatic);
 517 
 518   jobject ret = NULL;
 519   DT_RETURN_MARK(ToReflectedMethod, jobject, (const jobject&amp;)ret);
 520 
 521   methodHandle m (THREAD, Method::resolve_jmethod_id(method_id));
 522   assert(m-&gt;is_static() == (isStatic != 0), &quot;jni_ToReflectedMethod access flags doesn&#39;t match&quot;);
 523   oop reflection_method;
 524   if (m-&gt;is_object_constructor()) {
 525     reflection_method = Reflection::new_constructor(m, CHECK_NULL);
 526   } else {
 527     reflection_method = Reflection::new_method(m, false, CHECK_NULL);
 528   }
 529   ret = JNIHandles::make_local(env, reflection_method);
 530   return ret;
 531 JNI_END
 532 
 533 DT_RETURN_MARK_DECL(GetSuperclass, jclass
 534                     , HOTSPOT_JNI_GETSUPERCLASS_RETURN(_ret_ref));
 535 
 536 JNI_ENTRY(jclass, jni_GetSuperclass(JNIEnv *env, jclass sub))
 537   JNIWrapper(&quot;GetSuperclass&quot;);
 538 
 539   HOTSPOT_JNI_GETSUPERCLASS_ENTRY(env, sub);
 540 
 541   jclass obj = NULL;
 542   DT_RETURN_MARK(GetSuperclass, jclass, (const jclass&amp;)obj);
 543 
 544   oop mirror = JNIHandles::resolve_non_null(sub);
 545   // primitive classes return NULL
 546   if (java_lang_Class::is_primitive(mirror)) return NULL;
 547 
 548   // Rules of Class.getSuperClass as implemented by KLass::java_super:
 549   // arrays return Object
 550   // interfaces return NULL
 551   // proper classes return Klass::super()
 552   Klass* k = java_lang_Class::as_Klass(mirror);
 553   if (k-&gt;is_interface()) return NULL;
 554 
 555   // return mirror for superclass
 556   Klass* super = k-&gt;java_super();
 557   // super2 is the value computed by the compiler&#39;s getSuperClass intrinsic:
 558   debug_only(Klass* super2 = ( k-&gt;is_array_klass()
 559                                  ? SystemDictionary::Object_klass()
 560                                  : k-&gt;super() ) );
 561   assert(super == super2,
 562          &quot;java_super computation depends on interface, array, other super&quot;);
 563   obj = (super == NULL) ? NULL : (jclass) JNIHandles::make_local(super-&gt;java_mirror());
 564   return obj;
 565 JNI_END
 566 
 567 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))
 568   JNIWrapper(&quot;IsSubclassOf&quot;);
 569 
 570   HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);
 571 
 572   oop sub_mirror   = JNIHandles::resolve_non_null(sub);
 573   oop super_mirror = JNIHandles::resolve_non_null(super);
 574   if (java_lang_Class::is_primitive(sub_mirror) ||
 575       java_lang_Class::is_primitive(super_mirror)) {
 576     jboolean ret = (sub_mirror == super_mirror);
 577 
 578     HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 579     return ret;
 580   }
 581   Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
 582   Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
 583   assert(sub_klass != NULL &amp;&amp; super_klass != NULL, &quot;invalid arguments to jni_IsAssignableFrom&quot;);
 584   jboolean ret = sub_klass-&gt;is_subtype_of(super_klass) ?
 585                    JNI_TRUE : JNI_FALSE;
 586   if (sub_klass == super_klass &amp;&amp; sub_klass-&gt;is_value()) {
 587     // for inline class, V &lt;: V?
 588     ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(sub_klass));
 589     if (sub_mirror == super_mirror || (sub_mirror == vk-&gt;value_mirror() &amp;&amp; super_mirror == vk-&gt;indirect_mirror())) {
 590       ret = JNI_TRUE;
 591     } else {
 592       ret = JNI_FALSE;
 593     }
 594   }
 595   HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 596   return ret;
 597 JNI_END
 598 
 599 
 600 DT_RETURN_MARK_DECL(Throw, jint
 601                     , HOTSPOT_JNI_THROW_RETURN(_ret_ref));
 602 
 603 JNI_ENTRY(jint, jni_Throw(JNIEnv *env, jthrowable obj))
 604   JNIWrapper(&quot;Throw&quot;);
 605 
 606   HOTSPOT_JNI_THROW_ENTRY(env, obj);
 607 
 608   jint ret = JNI_OK;
 609   DT_RETURN_MARK(Throw, jint, (const jint&amp;)ret);
 610 
 611   THROW_OOP_(JNIHandles::resolve(obj), JNI_OK);
 612   ShouldNotReachHere();
 613   return 0;  // Mute compiler.
 614 JNI_END
 615 
 616 
 617 DT_RETURN_MARK_DECL(ThrowNew, jint
 618                     , HOTSPOT_JNI_THROWNEW_RETURN(_ret_ref));
 619 
 620 JNI_ENTRY(jint, jni_ThrowNew(JNIEnv *env, jclass clazz, const char *message))
 621   JNIWrapper(&quot;ThrowNew&quot;);
 622 
 623   HOTSPOT_JNI_THROWNEW_ENTRY(env, clazz, (char *) message);
 624 
 625   jint ret = JNI_OK;
 626   DT_RETURN_MARK(ThrowNew, jint, (const jint&amp;)ret);
 627 
 628   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
 629   Symbol*  name = k-&gt;name();
 630   Handle class_loader (THREAD,  k-&gt;class_loader());
 631   Handle protection_domain (THREAD, k-&gt;protection_domain());
 632   THROW_MSG_LOADER_(name, (char *)message, class_loader, protection_domain, JNI_OK);
 633   ShouldNotReachHere();
 634   return 0;  // Mute compiler.
 635 JNI_END
 636 
 637 
 638 // JNI functions only transform a pending async exception to a synchronous
 639 // exception in ExceptionOccurred and ExceptionCheck calls, since
 640 // delivering an async exception in other places won&#39;t change the native
 641 // code&#39;s control flow and would be harmful when native code further calls
 642 // JNI functions with a pending exception. Async exception is also checked
 643 // during the call, so ExceptionOccurred/ExceptionCheck won&#39;t return
 644 // false but deliver the async exception at the very end during
 645 // state transition.
 646 
 647 static void jni_check_async_exceptions(JavaThread *thread) {
 648   assert(thread == Thread::current(), &quot;must be itself&quot;);
 649   thread-&gt;check_and_handle_async_exceptions();
 650 }
 651 
 652 JNI_ENTRY_NO_PRESERVE(jthrowable, jni_ExceptionOccurred(JNIEnv *env))
 653   JNIWrapper(&quot;ExceptionOccurred&quot;);
 654 
 655   HOTSPOT_JNI_EXCEPTIONOCCURRED_ENTRY(env);
 656 
 657   jni_check_async_exceptions(thread);
 658   oop exception = thread-&gt;pending_exception();
 659   jthrowable ret = (jthrowable) JNIHandles::make_local(env, exception);
 660 
 661   HOTSPOT_JNI_EXCEPTIONOCCURRED_RETURN(ret);
 662   return ret;
 663 JNI_END
 664 
 665 
 666 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionDescribe(JNIEnv *env))
 667   JNIWrapper(&quot;ExceptionDescribe&quot;);
 668 
 669   HOTSPOT_JNI_EXCEPTIONDESCRIBE_ENTRY(env);
 670 
 671   if (thread-&gt;has_pending_exception()) {
 672     Handle ex(thread, thread-&gt;pending_exception());
 673     thread-&gt;clear_pending_exception();
 674     if (ex-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
 675       // Don&#39;t print anything if we are being killed.
 676     } else {
 677       jio_fprintf(defaultStream::error_stream(), &quot;Exception &quot;);
 678       if (thread != NULL &amp;&amp; thread-&gt;threadObj() != NULL) {
 679         ResourceMark rm(THREAD);
 680         jio_fprintf(defaultStream::error_stream(),
 681         &quot;in thread \&quot;%s\&quot; &quot;, thread-&gt;get_thread_name());
 682       }
 683       if (ex-&gt;is_a(SystemDictionary::Throwable_klass())) {
 684         JavaValue result(T_VOID);
 685         JavaCalls::call_virtual(&amp;result,
 686                                 ex,
 687                                 SystemDictionary::Throwable_klass(),
 688                                 vmSymbols::printStackTrace_name(),
 689                                 vmSymbols::void_method_signature(),
 690                                 THREAD);
 691         // If an exception is thrown in the call it gets thrown away. Not much
 692         // we can do with it. The native code that calls this, does not check
 693         // for the exception - hence, it might still be in the thread when DestroyVM gets
 694         // called, potentially causing a few asserts to trigger - since no pending exception
 695         // is expected.
 696         CLEAR_PENDING_EXCEPTION;
 697       } else {
 698         ResourceMark rm(THREAD);
 699         jio_fprintf(defaultStream::error_stream(),
 700         &quot;. Uncaught exception of type %s.&quot;,
 701         ex-&gt;klass()-&gt;external_name());
 702       }
 703     }
 704   }
 705 
 706   HOTSPOT_JNI_EXCEPTIONDESCRIBE_RETURN();
 707 JNI_END
 708 
 709 
 710 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionClear(JNIEnv *env))
 711   JNIWrapper(&quot;ExceptionClear&quot;);
 712 
 713   HOTSPOT_JNI_EXCEPTIONCLEAR_ENTRY(env);
 714 
 715   // The jni code might be using this API to clear java thrown exception.
 716   // So just mark jvmti thread exception state as exception caught.
 717   JvmtiThreadState *state = JavaThread::current()-&gt;jvmti_thread_state();
 718   if (state != NULL &amp;&amp; state-&gt;is_exception_detected()) {
 719     state-&gt;set_exception_caught();
 720   }
 721   thread-&gt;clear_pending_exception();
 722 
 723   HOTSPOT_JNI_EXCEPTIONCLEAR_RETURN();
 724 JNI_END
 725 
 726 
 727 JNI_ENTRY(void, jni_FatalError(JNIEnv *env, const char *msg))
 728   JNIWrapper(&quot;FatalError&quot;);
 729 
 730   HOTSPOT_JNI_FATALERROR_ENTRY(env, (char *) msg);
 731 
 732   tty-&gt;print_cr(&quot;FATAL ERROR in native method: %s&quot;, msg);
 733   thread-&gt;print_stack();
 734   os::abort(); // Dump core and abort
 735 JNI_END
 736 
 737 
 738 JNI_ENTRY(jint, jni_PushLocalFrame(JNIEnv *env, jint capacity))
 739   JNIWrapper(&quot;PushLocalFrame&quot;);
 740 
 741   HOTSPOT_JNI_PUSHLOCALFRAME_ENTRY(env, capacity);
 742 
 743   //%note jni_11
 744   if (capacity &lt; 0 ||
 745       ((MaxJNILocalCapacity &gt; 0) &amp;&amp; (capacity &gt; MaxJNILocalCapacity))) {
 746     HOTSPOT_JNI_PUSHLOCALFRAME_RETURN((uint32_t)JNI_ERR);
 747     return JNI_ERR;
 748   }
 749   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 750   JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(thread);
 751   assert(new_handles != NULL, &quot;should not be NULL&quot;);
 752   new_handles-&gt;set_pop_frame_link(old_handles);
 753   thread-&gt;set_active_handles(new_handles);
 754   jint ret = JNI_OK;
 755   HOTSPOT_JNI_PUSHLOCALFRAME_RETURN(ret);
 756   return ret;
 757 JNI_END
 758 
 759 
 760 JNI_ENTRY(jobject, jni_PopLocalFrame(JNIEnv *env, jobject result))
 761   JNIWrapper(&quot;PopLocalFrame&quot;);
 762 
 763   HOTSPOT_JNI_POPLOCALFRAME_ENTRY(env, result);
 764 
 765   //%note jni_11
 766   Handle result_handle(thread, JNIHandles::resolve(result));
 767   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 768   JNIHandleBlock* new_handles = old_handles-&gt;pop_frame_link();
 769   if (new_handles != NULL) {
 770     // As a sanity check we only release the handle blocks if the pop_frame_link is not NULL.
 771     // This way code will still work if PopLocalFrame is called without a corresponding
 772     // PushLocalFrame call. Note that we set the pop_frame_link to NULL explicitly, otherwise
 773     // the release_block call will release the blocks.
 774     thread-&gt;set_active_handles(new_handles);
 775     old_handles-&gt;set_pop_frame_link(NULL);              // clear link we won&#39;t release new_handles below
 776     JNIHandleBlock::release_block(old_handles, thread); // may block
 777     result = JNIHandles::make_local(thread, result_handle());
 778   }
 779   HOTSPOT_JNI_POPLOCALFRAME_RETURN(result);
 780   return result;
 781 JNI_END
 782 
 783 
 784 JNI_ENTRY(jobject, jni_NewGlobalRef(JNIEnv *env, jobject ref))
 785   JNIWrapper(&quot;NewGlobalRef&quot;);
 786 
 787   HOTSPOT_JNI_NEWGLOBALREF_ENTRY(env, ref);
 788 
 789   Handle ref_handle(thread, JNIHandles::resolve(ref));
 790   jobject ret = JNIHandles::make_global(ref_handle);
 791 
 792   HOTSPOT_JNI_NEWGLOBALREF_RETURN(ret);
 793   return ret;
 794 JNI_END
 795 
 796 // Must be JNI_ENTRY (with HandleMark)
 797 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteGlobalRef(JNIEnv *env, jobject ref))
 798   JNIWrapper(&quot;DeleteGlobalRef&quot;);
 799 
 800   HOTSPOT_JNI_DELETEGLOBALREF_ENTRY(env, ref);
 801 
 802   JNIHandles::destroy_global(ref);
 803 
 804   HOTSPOT_JNI_DELETEGLOBALREF_RETURN();
 805 JNI_END
 806 
 807 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteLocalRef(JNIEnv *env, jobject obj))
 808   JNIWrapper(&quot;DeleteLocalRef&quot;);
 809 
 810   HOTSPOT_JNI_DELETELOCALREF_ENTRY(env, obj);
 811 
 812   JNIHandles::destroy_local(obj);
 813 
 814   HOTSPOT_JNI_DELETELOCALREF_RETURN();
 815 JNI_END
 816 
 817 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsSameObject(JNIEnv *env, jobject r1, jobject r2))
 818   JNIWrapper(&quot;IsSameObject&quot;);
 819 
 820   HOTSPOT_JNI_ISSAMEOBJECT_ENTRY(env, r1, r2);
 821 
 822   jboolean ret = JNIHandles::is_same_object(r1, r2) ? JNI_TRUE : JNI_FALSE;
 823 
 824   HOTSPOT_JNI_ISSAMEOBJECT_RETURN(ret);
 825   return ret;
 826 JNI_END
 827 
 828 
 829 JNI_ENTRY(jobject, jni_NewLocalRef(JNIEnv *env, jobject ref))
 830   JNIWrapper(&quot;NewLocalRef&quot;);
 831 
 832   HOTSPOT_JNI_NEWLOCALREF_ENTRY(env, ref);
 833 
 834   jobject ret = JNIHandles::make_local(env, JNIHandles::resolve(ref));
 835 
 836   HOTSPOT_JNI_NEWLOCALREF_RETURN(ret);
 837   return ret;
 838 JNI_END
 839 
 840 JNI_LEAF(jint, jni_EnsureLocalCapacity(JNIEnv *env, jint capacity))
 841   JNIWrapper(&quot;EnsureLocalCapacity&quot;);
 842 
 843   HOTSPOT_JNI_ENSURELOCALCAPACITY_ENTRY(env, capacity);
 844 
 845   jint ret;
 846   if (capacity &gt;= 0 &amp;&amp;
 847       ((MaxJNILocalCapacity &lt;= 0) || (capacity &lt;= MaxJNILocalCapacity))) {
 848     ret = JNI_OK;
 849   } else {
 850     ret = JNI_ERR;
 851   }
 852 
 853   HOTSPOT_JNI_ENSURELOCALCAPACITY_RETURN(ret);
 854   return ret;
 855 JNI_END
 856 
 857 // Return the Handle Type
 858 JNI_LEAF(jobjectRefType, jni_GetObjectRefType(JNIEnv *env, jobject obj))
 859   JNIWrapper(&quot;GetObjectRefType&quot;);
 860 
 861   HOTSPOT_JNI_GETOBJECTREFTYPE_ENTRY(env, obj);
 862 
 863   jobjectRefType ret = JNIInvalidRefType;
 864   if (obj != NULL) {
 865     ret = JNIHandles::handle_type(thread, obj);
 866   }
 867 
 868   HOTSPOT_JNI_GETOBJECTREFTYPE_RETURN((void *) ret);
 869   return ret;
 870 JNI_END
 871 
 872 
 873 class JNI_ArgumentPusher : public SignatureIterator {
 874  protected:
 875   JavaCallArguments*  _arguments;
 876 
 877   void push_int(jint x)         { _arguments-&gt;push_int(x); }
 878   void push_long(jlong x)       { _arguments-&gt;push_long(x); }
 879   void push_float(jfloat x)     { _arguments-&gt;push_float(x); }
 880   void push_double(jdouble x)   { _arguments-&gt;push_double(x); }
 881   void push_object(jobject x)   { _arguments-&gt;push_jobject(x); }
 882 
 883   void push_boolean(jboolean b) {
 884     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and
 885     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in
 886     // TemplateInterpreterGenerator::generate_result_handler_for and
 887     // SharedRuntime::generate_native_wrapper.
 888     push_int(b == 0 ? JNI_FALSE : JNI_TRUE);
 889   }
 890 
 891   JNI_ArgumentPusher(Method* method)
 892     : SignatureIterator(method-&gt;signature(),
 893                         Fingerprinter(methodHandle(Thread::current(), method)).fingerprint())
 894   {
 895     _arguments = NULL;
 896   }
 897 
 898  public:
 899   virtual void push_arguments_on(JavaCallArguments* arguments) = 0;
 900 };
 901 
 902 
 903 class JNI_ArgumentPusherVaArg : public JNI_ArgumentPusher {
 904  protected:
 905   va_list _ap;
 906 
 907   void set_ap(va_list rap) {
 908     va_copy(_ap, rap);
 909   }
 910 
 911   friend class SignatureIterator;  // so do_parameters_on can call do_type
 912   void do_type(BasicType type) {
 913     switch (type) {
 914     // these are coerced to int when using va_arg
 915     case T_BYTE:
 916     case T_CHAR:
 917     case T_SHORT:
 918     case T_INT:         push_int(va_arg(_ap, jint)); break;
 919     case T_BOOLEAN:     push_boolean((jboolean) va_arg(_ap, jint)); break;
 920 
 921     // each of these paths is exercised by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests
 922 
 923     case T_LONG:        push_long(va_arg(_ap, jlong)); break;
 924     // float is coerced to double w/ va_arg
 925     case T_FLOAT:       push_float((jfloat) va_arg(_ap, jdouble)); break;
 926     case T_DOUBLE:      push_double(va_arg(_ap, jdouble)); break;
 927 
 928     case T_ARRAY:
 929     case T_OBJECT:
 930     case T_VALUETYPE:   push_object(va_arg(_ap, jobject)); break;
 931     default:            ShouldNotReachHere();
 932     }
 933   }
 934 
 935  public:
 936   JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
 937       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
 938     set_ap(rap);
 939   }
 940 
 941   virtual void push_arguments_on(JavaCallArguments* arguments) {
 942     _arguments = arguments;
 943     do_parameters_on(this);
 944   }
 945 };
 946 
 947 
 948 class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
 949  protected:
 950   const jvalue *_ap;
 951 
 952   inline void set_ap(const jvalue *rap) { _ap = rap; }
 953 
 954   friend class SignatureIterator;  // so do_parameters_on can call do_type
 955   void do_type(BasicType type) {
 956     switch (type) {
 957     case T_CHAR:        push_int((_ap++)-&gt;c); break;
 958     case T_SHORT:       push_int((_ap++)-&gt;s); break;
 959     case T_BYTE:        push_int((_ap++)-&gt;b); break;
 960     case T_INT:         push_int((_ap++)-&gt;i); break;
 961     case T_BOOLEAN:     push_boolean((_ap++)-&gt;z); break;
 962     case T_LONG:        push_long((_ap++)-&gt;j); break;
 963     case T_FLOAT:       push_float((_ap++)-&gt;f); break;
 964     case T_DOUBLE:      push_double((_ap++)-&gt;d); break;
 965     case T_ARRAY:
 966     case T_OBJECT:
 967     case T_VALUETYPE:   push_object((_ap++)-&gt;l); break;
 968     default:            ShouldNotReachHere();
 969     }
 970   }
 971 
 972  public:
 973   JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
 974       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
 975     set_ap(rap);
 976   }
 977 
 978   virtual void push_arguments_on(JavaCallArguments* arguments) {
 979     _arguments = arguments;
 980     do_parameters_on(this);
 981   }
 982 };
 983 
 984 
 985 enum JNICallType {
 986   JNI_STATIC,
 987   JNI_VIRTUAL,
 988   JNI_NONVIRTUAL
 989 };
 990 
 991 
 992 
 993 static void jni_invoke_static(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
 994   methodHandle method(THREAD, Method::resolve_jmethod_id(method_id));
 995 
 996   // Create object to hold arguments for the JavaCall, and associate it with
 997   // the jni parser
 998   ResourceMark rm(THREAD);
 999   int number_of_parameters = method-&gt;size_of_parameters();
1000   JavaCallArguments java_args(number_of_parameters);
1001 
1002   assert(method-&gt;is_static(), &quot;method should be static&quot;);
1003 
1004   // Fill out JavaCallArguments object
1005   args-&gt;push_arguments_on(&amp;java_args);
1006   // Initialize result type
1007   result-&gt;set_type(args-&gt;return_type());
1008 
1009   // Invoke the method. Result is returned as oop.
1010   JavaCalls::call(result, method, &amp;java_args, CHECK);
1011 
1012   // Convert result
1013   if (is_reference_type(result-&gt;get_type())) {
1014     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1015   }
1016 }
1017 
1018 
1019 static void jni_invoke_nonstatic(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1020   oop recv = JNIHandles::resolve(receiver);
1021   if (recv == NULL) {
1022     THROW(vmSymbols::java_lang_NullPointerException());
1023   }
1024   Handle h_recv(THREAD, recv);
1025 
1026   int number_of_parameters;
1027   Method* selected_method;
1028   {
1029     Method* m = Method::resolve_jmethod_id(method_id);
1030     number_of_parameters = m-&gt;size_of_parameters();
1031     Klass* holder = m-&gt;method_holder();
1032     if (call_type != JNI_VIRTUAL) {
1033         selected_method = m;
1034     } else if (!m-&gt;has_itable_index()) {
1035       // non-interface call -- for that little speed boost, don&#39;t handlize
1036       debug_only(NoSafepointVerifier nosafepoint;)
1037       // jni_GetMethodID makes sure class is linked and initialized
1038       // so m should have a valid vtable index.
1039       assert(m-&gt;valid_vtable_index(), &quot;no valid vtable index&quot;);
1040       int vtbl_index = m-&gt;vtable_index();
1041       if (vtbl_index != Method::nonvirtual_vtable_index) {
1042         selected_method = h_recv-&gt;klass()-&gt;method_at_vtable(vtbl_index);
1043       } else {
1044         // final method
1045         selected_method = m;
1046       }
1047     } else {
1048       // interface call
1049       int itbl_index = m-&gt;itable_index();
1050       Klass* k = h_recv-&gt;klass();
1051       selected_method = InstanceKlass::cast(k)-&gt;method_at_itable(holder, itbl_index, CHECK);
1052     }
1053   }
1054 
1055   methodHandle method(THREAD, selected_method);
1056 
1057   // Create object to hold arguments for the JavaCall, and associate it with
1058   // the jni parser
1059   ResourceMark rm(THREAD);
1060   JavaCallArguments java_args(number_of_parameters);
1061 
1062   // handle arguments
1063   assert(!method-&gt;is_static(), &quot;method %s should not be static&quot;, method-&gt;name_and_sig_as_C_string());
1064   java_args.push_oop(h_recv); // Push jobject handle
1065 
1066   // Fill out JavaCallArguments object
1067   args-&gt;push_arguments_on(&amp;java_args);
1068   // Initialize result type
1069   result-&gt;set_type(args-&gt;return_type());
1070 
1071   // Invoke the method. Result is returned as oop.
1072   JavaCalls::call(result, method, &amp;java_args, CHECK);
1073 
1074   // Convert result
1075   if (is_reference_type(result-&gt;get_type())) {
1076     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1077   }
1078 }
1079 
1080 
1081 static instanceOop alloc_object(jclass clazz, TRAPS) {
1082   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1083   if (k == NULL) {
1084     ResourceMark rm(THREAD);
1085     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1086   }
1087   k-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1088   k-&gt;initialize(CHECK_NULL);
1089   instanceOop ih = InstanceKlass::cast(k)-&gt;allocate_instance(THREAD);
1090   return ih;
1091 }
1092 
1093 DT_RETURN_MARK_DECL(AllocObject, jobject
1094                     , HOTSPOT_JNI_ALLOCOBJECT_RETURN(_ret_ref));
1095 
1096 JNI_ENTRY(jobject, jni_AllocObject(JNIEnv *env, jclass clazz))
1097   JNIWrapper(&quot;AllocObject&quot;);
1098 
1099   HOTSPOT_JNI_ALLOCOBJECT_ENTRY(env, clazz);
1100 
1101   jobject ret = NULL;
1102   DT_RETURN_MARK(AllocObject, jobject, (const jobject&amp;)ret);
1103 
1104   instanceOop i = alloc_object(clazz, CHECK_NULL);
1105   ret = JNIHandles::make_local(env, i);
1106   return ret;
1107 JNI_END
1108 
1109 DT_RETURN_MARK_DECL(NewObjectA, jobject
1110                     , HOTSPOT_JNI_NEWOBJECTA_RETURN(_ret_ref));
1111 
1112 JNI_ENTRY(jobject, jni_NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args))
1113   JNIWrapper(&quot;NewObjectA&quot;);
1114 
1115   HOTSPOT_JNI_NEWOBJECTA_ENTRY(env, clazz, (uintptr_t) methodID);
1116 
1117   jobject obj = NULL;
1118   DT_RETURN_MARK(NewObjectA, jobject, (const jobject)obj);
1119 
1120   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1121   if (k == NULL) {
1122     ResourceMark rm(THREAD);
1123     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1124   }
1125 
1126   if (!k-&gt;is_value()) {
1127     instanceOop i = alloc_object(clazz, CHECK_NULL);
1128     obj = JNIHandles::make_local(env, i);
1129     JavaValue jvalue(T_VOID);
1130     JNI_ArgumentPusherArray ap(methodID, args);
1131     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1132   } else {
1133     JavaValue jvalue(T_VALUETYPE);
1134     JNI_ArgumentPusherArray ap(methodID, args);
1135     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);
1136     obj = jvalue.get_jobject();
1137   }
1138   return obj;
1139   JNI_END
1140 
1141 
1142 DT_RETURN_MARK_DECL(NewObjectV, jobject
1143                     , HOTSPOT_JNI_NEWOBJECTV_RETURN(_ret_ref));
1144 
1145 JNI_ENTRY(jobject, jni_NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args))
1146   JNIWrapper(&quot;NewObjectV&quot;);
1147 
1148   HOTSPOT_JNI_NEWOBJECTV_ENTRY(env, clazz, (uintptr_t) methodID);
1149 
1150   jobject obj = NULL;
1151   DT_RETURN_MARK(NewObjectV, jobject, (const jobject&amp;)obj);
1152 
1153   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1154   if (k == NULL) {
1155     ResourceMark rm(THREAD);
1156     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1157   }
1158 
1159   if (!k-&gt;is_value()) {
1160     instanceOop i = alloc_object(clazz, CHECK_NULL);
1161     obj = JNIHandles::make_local(env, i);
1162     JavaValue jvalue(T_VOID);
1163     JNI_ArgumentPusherVaArg ap(methodID, args);
1164     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1165   } else {
1166     JavaValue jvalue(T_VALUETYPE);
1167     JNI_ArgumentPusherVaArg ap(methodID, args);
1168     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);
1169     obj = jvalue.get_jobject();
1170   }
1171   return obj;
1172 JNI_END
1173 
1174 
1175 DT_RETURN_MARK_DECL(NewObject, jobject
1176                     , HOTSPOT_JNI_NEWOBJECT_RETURN(_ret_ref));
1177 
1178 JNI_ENTRY(jobject, jni_NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...))
1179   JNIWrapper(&quot;NewObject&quot;);
1180 
1181   HOTSPOT_JNI_NEWOBJECT_ENTRY(env, clazz, (uintptr_t) methodID);
1182 
1183   jobject obj = NULL;
1184   DT_RETURN_MARK(NewObject, jobject, (const jobject&amp;)obj);
1185 
1186   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1187   if (k == NULL) {
1188     ResourceMark rm(THREAD);
1189     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1190   }
1191 
1192   if (!k-&gt;is_value()) {
1193     instanceOop i = alloc_object(clazz, CHECK_NULL);
1194     obj = JNIHandles::make_local(env, i);
1195     va_list args;
1196     va_start(args, methodID);
1197     JavaValue jvalue(T_VOID);
1198     JNI_ArgumentPusherVaArg ap(methodID, args);
1199     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1200     va_end(args);
1201   } else {
1202     va_list args;
1203     va_start(args, methodID);
1204     JavaValue jvalue(T_VALUETYPE);
1205     JNI_ArgumentPusherVaArg ap(methodID, args);
1206     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);
1207     va_end(args);
1208     obj = jvalue.get_jobject();
1209   }
1210   return obj;
1211 JNI_END
1212 
1213 
1214 JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
1215   JNIWrapper(&quot;GetObjectClass&quot;);
1216 
1217   HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(env, obj);
1218 
1219   Klass* k = JNIHandles::resolve_non_null(obj)-&gt;klass();
1220   jclass ret =
1221     (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1222 
1223   HOTSPOT_JNI_GETOBJECTCLASS_RETURN(ret);
1224   return ret;
1225 JNI_END
1226 
1227 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))
1228   JNIWrapper(&quot;IsInstanceOf&quot;);
1229 
1230   HOTSPOT_JNI_ISINSTANCEOF_ENTRY(env, obj, clazz);
1231 
1232   jboolean ret = JNI_TRUE;
1233   if (obj != NULL) {
1234     ret = JNI_FALSE;
1235     Klass* k = java_lang_Class::as_Klass(
1236       JNIHandles::resolve_non_null(clazz));
1237     if (k != NULL) {
1238       ret = JNIHandles::resolve_non_null(obj)-&gt;is_a(k) ? JNI_TRUE : JNI_FALSE;
1239     }
1240   }
1241 
1242   HOTSPOT_JNI_ISINSTANCEOF_RETURN(ret);
1243   return ret;
1244 JNI_END
1245 
1246 
1247 static jmethodID get_method_id(JNIEnv *env, jclass clazz, const char *name_str,
1248                                const char *sig, bool is_static, TRAPS) {
1249   // %%%% This code should probably just call into a method in the LinkResolver
1250   //
1251   // The class should have been loaded (we have an instance of the class
1252   // passed in) so the method and signature should already be in the symbol
1253   // table.  If they&#39;re not there, the method doesn&#39;t exist.
1254   const char *name_to_probe = (name_str == NULL)
1255                         ? vmSymbols::object_initializer_name()-&gt;as_C_string()
1256                         : name_str;
1257   TempNewSymbol name = SymbolTable::probe(name_to_probe, (int)strlen(name_to_probe));
1258   TempNewSymbol signature = SymbolTable::probe(sig, (int)strlen(sig));
1259 
1260   if (name == NULL || signature == NULL) {
1261     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
1262   }
1263 
1264   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1265 
1266   // Throw a NoSuchMethodError exception if we have an instance of a
1267   // primitive java.lang.Class
1268   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(clazz))) {
1269     ResourceMark rm;
1270     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg(&quot;%s%s.%s%s&quot;, is_static ? &quot;static &quot; : &quot;&quot;, klass-&gt;signature_name(), name_str, sig));
1271   }
1272 
1273   // Make sure class is linked and initialized before handing id&#39;s out to
1274   // Method*s.
1275   klass-&gt;initialize(CHECK_NULL);
1276 
1277   Method* m;
1278   if (name == vmSymbols::object_initializer_name() ||
1279       name == vmSymbols::class_initializer_name()) {
1280     // Never search superclasses for constructors
1281     if (klass-&gt;is_instance_klass()) {
1282       m = InstanceKlass::cast(klass)-&gt;find_method(name, signature);
1283     } else {
1284       m = NULL;
1285     }
1286   } else {
1287     m = klass-&gt;lookup_method(name, signature);
1288     if (m == NULL &amp;&amp;  klass-&gt;is_instance_klass()) {
1289       m = InstanceKlass::cast(klass)-&gt;lookup_method_in_ordered_interfaces(name, signature);
1290     }
1291   }
1292   if (m == NULL || (m-&gt;is_static() != is_static)) {
1293     ResourceMark rm;
1294     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg(&quot;%s%s.%s%s&quot;, is_static ? &quot;static &quot; : &quot;&quot;, klass-&gt;signature_name(), name_str, sig));
1295   }
1296   return m-&gt;jmethod_id();
1297 }
1298 
1299 
1300 JNI_ENTRY(jmethodID, jni_GetMethodID(JNIEnv *env, jclass clazz,
1301           const char *name, const char *sig))
1302   JNIWrapper(&quot;GetMethodID&quot;);
1303   HOTSPOT_JNI_GETMETHODID_ENTRY(env, clazz, (char *) name, (char *) sig);
1304   jmethodID ret = get_method_id(env, clazz, name, sig, false, thread);
1305   HOTSPOT_JNI_GETMETHODID_RETURN((uintptr_t) ret);
1306   return ret;
1307 JNI_END
1308 
1309 
1310 JNI_ENTRY(jmethodID, jni_GetStaticMethodID(JNIEnv *env, jclass clazz,
1311           const char *name, const char *sig))
1312   JNIWrapper(&quot;GetStaticMethodID&quot;);
1313   HOTSPOT_JNI_GETSTATICMETHODID_ENTRY(env, (char *) clazz, (char *) name, (char *)sig);
1314   jmethodID ret = get_method_id(env, clazz, name, sig, true, thread);
1315   HOTSPOT_JNI_GETSTATICMETHODID_RETURN((uintptr_t) ret);
1316   return ret;
1317 JNI_END
1318 
1319 
1320 
1321 //
1322 // Calling Methods
1323 //
1324 
1325 
1326 #define DEFINE_CALLMETHOD(ResultType, Result, Tag \
1327                           , EntryProbe, ReturnProbe)    \
1328 \
1329   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##Method, ResultType \
1330                           , ReturnProbe);                          \
1331 \
1332 JNI_ENTRY(ResultType, \
1333           jni_Call##Result##Method(JNIEnv *env, jobject obj, jmethodID methodID, ...)) \
1334   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;Method&quot;); \
1335 \
1336   EntryProbe; \
1337   ResultType ret = 0;\
1338   DT_RETURN_MARK_FOR(Result, Call##Result##Method, ResultType, \
1339                      (const ResultType&amp;)ret);\
1340 \
1341   va_list args; \
1342   va_start(args, methodID); \
1343   JavaValue jvalue(Tag); \
1344   JNI_ArgumentPusherVaArg ap(methodID, args); \
1345   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1346   va_end(args); \
1347   ret = jvalue.get_##ResultType(); \
1348   return ret;\
1349 JNI_END
1350 
1351 // the runtime type of subword integral basic types is integer
1352 DEFINE_CALLMETHOD(jboolean, Boolean, T_BOOLEAN
1353                   , HOTSPOT_JNI_CALLBOOLEANMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1354                   HOTSPOT_JNI_CALLBOOLEANMETHOD_RETURN(_ret_ref))
1355 DEFINE_CALLMETHOD(jbyte,    Byte,    T_BYTE
1356                   , HOTSPOT_JNI_CALLBYTEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1357                   HOTSPOT_JNI_CALLBYTEMETHOD_RETURN(_ret_ref))
1358 DEFINE_CALLMETHOD(jchar,    Char,    T_CHAR
1359                   , HOTSPOT_JNI_CALLCHARMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1360                   HOTSPOT_JNI_CALLCHARMETHOD_RETURN(_ret_ref))
1361 DEFINE_CALLMETHOD(jshort,   Short,   T_SHORT
1362                   , HOTSPOT_JNI_CALLSHORTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1363                   HOTSPOT_JNI_CALLSHORTMETHOD_RETURN(_ret_ref))
1364 
1365 DEFINE_CALLMETHOD(jobject,  Object,  T_OBJECT
1366                   , HOTSPOT_JNI_CALLOBJECTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1367                   HOTSPOT_JNI_CALLOBJECTMETHOD_RETURN(_ret_ref))
1368 DEFINE_CALLMETHOD(jint,     Int,     T_INT,
1369                   HOTSPOT_JNI_CALLINTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1370                   HOTSPOT_JNI_CALLINTMETHOD_RETURN(_ret_ref))
1371 DEFINE_CALLMETHOD(jlong,    Long,    T_LONG
1372                   , HOTSPOT_JNI_CALLLONGMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1373                   HOTSPOT_JNI_CALLLONGMETHOD_RETURN(_ret_ref))
1374 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1375 DEFINE_CALLMETHOD(jfloat,   Float,   T_FLOAT
1376                   , HOTSPOT_JNI_CALLFLOATMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1377                   HOTSPOT_JNI_CALLFLOATMETHOD_RETURN())
1378 DEFINE_CALLMETHOD(jdouble,  Double,  T_DOUBLE
1379                   , HOTSPOT_JNI_CALLDOUBLEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1380                   HOTSPOT_JNI_CALLDOUBLEMETHOD_RETURN())
1381 
1382 #define DEFINE_CALLMETHODV(ResultType, Result, Tag \
1383                           , EntryProbe, ReturnProbe)    \
1384 \
1385   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodV, ResultType \
1386                           , ReturnProbe);                          \
1387 \
1388 JNI_ENTRY(ResultType, \
1389           jni_Call##Result##MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args)) \
1390   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;MethodV&quot;); \
1391 \
1392   EntryProbe;\
1393   ResultType ret = 0;\
1394   DT_RETURN_MARK_FOR(Result, Call##Result##MethodV, ResultType, \
1395                      (const ResultType&amp;)ret);\
1396 \
1397   JavaValue jvalue(Tag); \
1398   JNI_ArgumentPusherVaArg ap(methodID, args); \
1399   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1400   ret = jvalue.get_##ResultType(); \
1401   return ret;\
1402 JNI_END
1403 
1404 // the runtime type of subword integral basic types is integer
1405 DEFINE_CALLMETHODV(jboolean, Boolean, T_BOOLEAN
1406                   , HOTSPOT_JNI_CALLBOOLEANMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1407                   HOTSPOT_JNI_CALLBOOLEANMETHODV_RETURN(_ret_ref))
1408 DEFINE_CALLMETHODV(jbyte,    Byte,    T_BYTE
1409                   , HOTSPOT_JNI_CALLBYTEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1410                   HOTSPOT_JNI_CALLBYTEMETHODV_RETURN(_ret_ref))
1411 DEFINE_CALLMETHODV(jchar,    Char,    T_CHAR
1412                   , HOTSPOT_JNI_CALLCHARMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1413                   HOTSPOT_JNI_CALLCHARMETHODV_RETURN(_ret_ref))
1414 DEFINE_CALLMETHODV(jshort,   Short,   T_SHORT
1415                   , HOTSPOT_JNI_CALLSHORTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1416                   HOTSPOT_JNI_CALLSHORTMETHODV_RETURN(_ret_ref))
1417 
1418 DEFINE_CALLMETHODV(jobject,  Object,  T_OBJECT
1419                   , HOTSPOT_JNI_CALLOBJECTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1420                   HOTSPOT_JNI_CALLOBJECTMETHODV_RETURN(_ret_ref))
1421 DEFINE_CALLMETHODV(jint,     Int,     T_INT,
1422                   HOTSPOT_JNI_CALLINTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1423                   HOTSPOT_JNI_CALLINTMETHODV_RETURN(_ret_ref))
1424 DEFINE_CALLMETHODV(jlong,    Long,    T_LONG
1425                   , HOTSPOT_JNI_CALLLONGMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1426                   HOTSPOT_JNI_CALLLONGMETHODV_RETURN(_ret_ref))
1427 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1428 DEFINE_CALLMETHODV(jfloat,   Float,   T_FLOAT
1429                   , HOTSPOT_JNI_CALLFLOATMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1430                   HOTSPOT_JNI_CALLFLOATMETHODV_RETURN())
1431 DEFINE_CALLMETHODV(jdouble,  Double,  T_DOUBLE
1432                   , HOTSPOT_JNI_CALLDOUBLEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1433                   HOTSPOT_JNI_CALLDOUBLEMETHODV_RETURN())
1434 
1435 #define DEFINE_CALLMETHODA(ResultType, Result, Tag \
1436                           , EntryProbe, ReturnProbe)    \
1437 \
1438   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodA, ResultType \
1439                           , ReturnProbe);                          \
1440 \
1441 JNI_ENTRY(ResultType, \
1442           jni_Call##Result##MethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args)) \
1443   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;MethodA&quot;); \
1444   EntryProbe; \
1445   ResultType ret = 0;\
1446   DT_RETURN_MARK_FOR(Result, Call##Result##MethodA, ResultType, \
1447                      (const ResultType&amp;)ret);\
1448 \
1449   JavaValue jvalue(Tag); \
1450   JNI_ArgumentPusherArray ap(methodID, args); \
1451   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1452   ret = jvalue.get_##ResultType(); \
1453   return ret;\
1454 JNI_END
1455 
1456 // the runtime type of subword integral basic types is integer
1457 DEFINE_CALLMETHODA(jboolean, Boolean, T_BOOLEAN
1458                   , HOTSPOT_JNI_CALLBOOLEANMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1459                   HOTSPOT_JNI_CALLBOOLEANMETHODA_RETURN(_ret_ref))
1460 DEFINE_CALLMETHODA(jbyte,    Byte,    T_BYTE
1461                   , HOTSPOT_JNI_CALLBYTEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1462                   HOTSPOT_JNI_CALLBYTEMETHODA_RETURN(_ret_ref))
1463 DEFINE_CALLMETHODA(jchar,    Char,    T_CHAR
1464                   , HOTSPOT_JNI_CALLCHARMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1465                   HOTSPOT_JNI_CALLCHARMETHODA_RETURN(_ret_ref))
1466 DEFINE_CALLMETHODA(jshort,   Short,   T_SHORT
1467                   , HOTSPOT_JNI_CALLSHORTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1468                   HOTSPOT_JNI_CALLSHORTMETHODA_RETURN(_ret_ref))
1469 
1470 DEFINE_CALLMETHODA(jobject,  Object,  T_OBJECT
1471                   , HOTSPOT_JNI_CALLOBJECTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1472                   HOTSPOT_JNI_CALLOBJECTMETHODA_RETURN(_ret_ref))
1473 DEFINE_CALLMETHODA(jint,     Int,     T_INT,
1474                   HOTSPOT_JNI_CALLINTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1475                   HOTSPOT_JNI_CALLINTMETHODA_RETURN(_ret_ref))
1476 DEFINE_CALLMETHODA(jlong,    Long,    T_LONG
1477                   , HOTSPOT_JNI_CALLLONGMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1478                   HOTSPOT_JNI_CALLLONGMETHODA_RETURN(_ret_ref))
1479 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1480 DEFINE_CALLMETHODA(jfloat,   Float,   T_FLOAT
1481                   , HOTSPOT_JNI_CALLFLOATMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1482                   HOTSPOT_JNI_CALLFLOATMETHODA_RETURN())
1483 DEFINE_CALLMETHODA(jdouble,  Double,  T_DOUBLE
1484                   , HOTSPOT_JNI_CALLDOUBLEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1485                   HOTSPOT_JNI_CALLDOUBLEMETHODA_RETURN())
1486 
1487 DT_VOID_RETURN_MARK_DECL(CallVoidMethod, HOTSPOT_JNI_CALLVOIDMETHOD_RETURN());
1488 DT_VOID_RETURN_MARK_DECL(CallVoidMethodV, HOTSPOT_JNI_CALLVOIDMETHODV_RETURN());
1489 DT_VOID_RETURN_MARK_DECL(CallVoidMethodA, HOTSPOT_JNI_CALLVOIDMETHODA_RETURN());
1490 
1491 
1492 JNI_ENTRY(void, jni_CallVoidMethod(JNIEnv *env, jobject obj, jmethodID methodID, ...))
1493   JNIWrapper(&quot;CallVoidMethod&quot;);
1494   HOTSPOT_JNI_CALLVOIDMETHOD_ENTRY(env, obj, (uintptr_t) methodID);
1495   DT_VOID_RETURN_MARK(CallVoidMethod);
1496 
1497   va_list args;
1498   va_start(args, methodID);
1499   JavaValue jvalue(T_VOID);
1500   JNI_ArgumentPusherVaArg ap(methodID, args);
1501   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1502   va_end(args);
1503 JNI_END
1504 
1505 
1506 JNI_ENTRY(void, jni_CallVoidMethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args))
1507   JNIWrapper(&quot;CallVoidMethodV&quot;);
1508   HOTSPOT_JNI_CALLVOIDMETHODV_ENTRY(env, obj, (uintptr_t) methodID);
1509   DT_VOID_RETURN_MARK(CallVoidMethodV);
1510 
1511   JavaValue jvalue(T_VOID);
1512   JNI_ArgumentPusherVaArg ap(methodID, args);
1513   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1514 JNI_END
1515 
1516 
1517 JNI_ENTRY(void, jni_CallVoidMethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args))
1518   JNIWrapper(&quot;CallVoidMethodA&quot;);
1519   HOTSPOT_JNI_CALLVOIDMETHODA_ENTRY(env, obj, (uintptr_t) methodID);
1520   DT_VOID_RETURN_MARK(CallVoidMethodA);
1521 
1522   JavaValue jvalue(T_VOID);
1523   JNI_ArgumentPusherArray ap(methodID, args);
1524   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1525 JNI_END
1526 
1527 
1528 
1529 #define DEFINE_CALLNONVIRTUALMETHOD(ResultType, Result, Tag \
1530                                     , EntryProbe, ReturnProbe)      \
1531 \
1532   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##Method, ResultType \
1533                           , ReturnProbe);\
1534 \
1535 JNI_ENTRY(ResultType, \
1536           jni_CallNonvirtual##Result##Method(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...)) \
1537   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;Method&quot;); \
1538 \
1539   EntryProbe;\
1540   ResultType ret;\
1541   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##Method, ResultType, \
1542                      (const ResultType&amp;)ret);\
1543 \
1544   va_list args; \
1545   va_start(args, methodID); \
1546   JavaValue jvalue(Tag); \
1547   JNI_ArgumentPusherVaArg ap(methodID, args); \
1548   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1549   va_end(args); \
1550   ret = jvalue.get_##ResultType(); \
1551   return ret;\
1552 JNI_END
1553 
1554 // the runtime type of subword integral basic types is integer
1555 DEFINE_CALLNONVIRTUALMETHOD(jboolean, Boolean, T_BOOLEAN
1556                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1557                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_RETURN(_ret_ref))
1558 DEFINE_CALLNONVIRTUALMETHOD(jbyte,    Byte,    T_BYTE
1559                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1560                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_RETURN(_ret_ref))
1561 DEFINE_CALLNONVIRTUALMETHOD(jchar,    Char,    T_CHAR
1562                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1563                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_RETURN(_ret_ref))
1564 DEFINE_CALLNONVIRTUALMETHOD(jshort,   Short,   T_SHORT
1565                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1566                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_RETURN(_ret_ref))
1567 
1568 DEFINE_CALLNONVIRTUALMETHOD(jobject,  Object,  T_OBJECT
1569                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1570                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_RETURN(_ret_ref))
1571 DEFINE_CALLNONVIRTUALMETHOD(jint,     Int,     T_INT
1572                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1573                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_RETURN(_ret_ref))
1574 DEFINE_CALLNONVIRTUALMETHOD(jlong,    Long,    T_LONG
1575                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1576 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1577                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_RETURN(_ret_ref))
1578 DEFINE_CALLNONVIRTUALMETHOD(jfloat,   Float,   T_FLOAT
1579                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1580                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_RETURN())
1581 DEFINE_CALLNONVIRTUALMETHOD(jdouble,  Double,  T_DOUBLE
1582                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1583                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_RETURN())
1584 
1585 #define DEFINE_CALLNONVIRTUALMETHODV(ResultType, Result, Tag \
1586                                     , EntryProbe, ReturnProbe)      \
1587 \
1588   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodV, ResultType \
1589                           , ReturnProbe);\
1590 \
1591 JNI_ENTRY(ResultType, \
1592           jni_CallNonvirtual##Result##MethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args)) \
1593   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;MethodV&quot;); \
1594 \
1595   EntryProbe;\
1596   ResultType ret;\
1597   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodV, ResultType, \
1598                      (const ResultType&amp;)ret);\
1599 \
1600   JavaValue jvalue(Tag); \
1601   JNI_ArgumentPusherVaArg ap(methodID, args); \
1602   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1603   ret = jvalue.get_##ResultType(); \
1604   return ret;\
1605 JNI_END
1606 
1607 // the runtime type of subword integral basic types is integer
1608 DEFINE_CALLNONVIRTUALMETHODV(jboolean, Boolean, T_BOOLEAN
1609                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1610                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_RETURN(_ret_ref))
1611 DEFINE_CALLNONVIRTUALMETHODV(jbyte,    Byte,    T_BYTE
1612                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1613                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_RETURN(_ret_ref))
1614 DEFINE_CALLNONVIRTUALMETHODV(jchar,    Char,    T_CHAR
1615                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1616                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_RETURN(_ret_ref))
1617 DEFINE_CALLNONVIRTUALMETHODV(jshort,   Short,   T_SHORT
1618                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1619                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_RETURN(_ret_ref))
1620 
1621 DEFINE_CALLNONVIRTUALMETHODV(jobject,  Object,  T_OBJECT
1622                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1623                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_RETURN(_ret_ref))
1624 DEFINE_CALLNONVIRTUALMETHODV(jint,     Int,     T_INT
1625                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1626                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_RETURN(_ret_ref))
1627 DEFINE_CALLNONVIRTUALMETHODV(jlong,    Long,    T_LONG
1628                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1629 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1630                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_RETURN(_ret_ref))
1631 DEFINE_CALLNONVIRTUALMETHODV(jfloat,   Float,   T_FLOAT
1632                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1633                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_RETURN())
1634 DEFINE_CALLNONVIRTUALMETHODV(jdouble,  Double,  T_DOUBLE
1635                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1636                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_RETURN())
1637 
1638 #define DEFINE_CALLNONVIRTUALMETHODA(ResultType, Result, Tag \
1639                                     , EntryProbe, ReturnProbe)      \
1640 \
1641   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodA, ResultType \
1642                           , ReturnProbe);\
1643 \
1644 JNI_ENTRY(ResultType, \
1645           jni_CallNonvirtual##Result##MethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args)) \
1646   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;MethodA&quot;); \
1647 \
1648   EntryProbe;\
1649   ResultType ret;\
1650   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodA, ResultType, \
1651                      (const ResultType&amp;)ret);\
1652 \
1653   JavaValue jvalue(Tag); \
1654   JNI_ArgumentPusherArray ap(methodID, args); \
1655   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1656   ret = jvalue.get_##ResultType(); \
1657   return ret;\
1658 JNI_END
1659 
1660 // the runtime type of subword integral basic types is integer
1661 DEFINE_CALLNONVIRTUALMETHODA(jboolean, Boolean, T_BOOLEAN
1662                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1663                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_RETURN(_ret_ref))
1664 DEFINE_CALLNONVIRTUALMETHODA(jbyte,    Byte,    T_BYTE
1665                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1666                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_RETURN(_ret_ref))
1667 DEFINE_CALLNONVIRTUALMETHODA(jchar,    Char,    T_CHAR
1668                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1669                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_RETURN(_ret_ref))
1670 DEFINE_CALLNONVIRTUALMETHODA(jshort,   Short,   T_SHORT
1671                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1672                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_RETURN(_ret_ref))
1673 
1674 DEFINE_CALLNONVIRTUALMETHODA(jobject,  Object,  T_OBJECT
1675                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1676                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_RETURN(_ret_ref))
1677 DEFINE_CALLNONVIRTUALMETHODA(jint,     Int,     T_INT
1678                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1679                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_RETURN(_ret_ref))
1680 DEFINE_CALLNONVIRTUALMETHODA(jlong,    Long,    T_LONG
1681                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1682 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1683                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_RETURN(_ret_ref))
1684 DEFINE_CALLNONVIRTUALMETHODA(jfloat,   Float,   T_FLOAT
1685                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1686                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_RETURN())
1687 DEFINE_CALLNONVIRTUALMETHODA(jdouble,  Double,  T_DOUBLE
1688                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1689                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_RETURN())
1690 
1691 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethod
1692                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_RETURN());
1693 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodV
1694                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_RETURN());
1695 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodA
1696                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_RETURN());
1697 
1698 JNI_ENTRY(void, jni_CallNonvirtualVoidMethod(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...))
1699   JNIWrapper(&quot;CallNonvirtualVoidMethod&quot;);
1700 
1701   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_ENTRY(env, obj, cls, (uintptr_t) methodID);
1702   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethod);
1703 
1704   va_list args;
1705   va_start(args, methodID);
1706   JavaValue jvalue(T_VOID);
1707   JNI_ArgumentPusherVaArg ap(methodID, args);
1708   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1709   va_end(args);
1710 JNI_END
1711 
1712 
1713 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args))
1714   JNIWrapper(&quot;CallNonvirtualVoidMethodV&quot;);
1715 
1716   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_ENTRY(
1717                env, obj, cls, (uintptr_t) methodID);
1718   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodV);
1719 
1720   JavaValue jvalue(T_VOID);
1721   JNI_ArgumentPusherVaArg ap(methodID, args);
1722   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1723 JNI_END
1724 
1725 
1726 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args))
1727   JNIWrapper(&quot;CallNonvirtualVoidMethodA&quot;);
1728   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_ENTRY(
1729                 env, obj, cls, (uintptr_t) methodID);
1730   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodA);
1731   JavaValue jvalue(T_VOID);
1732   JNI_ArgumentPusherArray ap(methodID, args);
1733   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1734 JNI_END
1735 
1736 
1737 
1738 #define DEFINE_CALLSTATICMETHOD(ResultType, Result, Tag \
1739                                 , EntryProbe, ResultProbe) \
1740 \
1741   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##Method, ResultType \
1742                           , ResultProbe);                               \
1743 \
1744 JNI_ENTRY(ResultType, \
1745           jni_CallStatic##Result##Method(JNIEnv *env, jclass cls, jmethodID methodID, ...)) \
1746   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;Method&quot;); \
1747 \
1748   EntryProbe; \
1749   ResultType ret = 0;\
1750   DT_RETURN_MARK_FOR(Result, CallStatic##Result##Method, ResultType, \
1751                      (const ResultType&amp;)ret);\
1752 \
1753   va_list args; \
1754   va_start(args, methodID); \
1755   JavaValue jvalue(Tag); \
1756   JNI_ArgumentPusherVaArg ap(methodID, args); \
1757   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1758   va_end(args); \
1759   ret = jvalue.get_##ResultType(); \
1760   return ret;\
1761 JNI_END
1762 
1763 // the runtime type of subword integral basic types is integer
1764 DEFINE_CALLSTATICMETHOD(jboolean, Boolean, T_BOOLEAN
1765                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1766                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_RETURN(_ret_ref));
1767 DEFINE_CALLSTATICMETHOD(jbyte,    Byte,    T_BYTE
1768                         , HOTSPOT_JNI_CALLSTATICBYTEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1769                         HOTSPOT_JNI_CALLSTATICBYTEMETHOD_RETURN(_ret_ref));
1770 DEFINE_CALLSTATICMETHOD(jchar,    Char,    T_CHAR
1771                         , HOTSPOT_JNI_CALLSTATICCHARMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1772                         HOTSPOT_JNI_CALLSTATICCHARMETHOD_RETURN(_ret_ref));
1773 DEFINE_CALLSTATICMETHOD(jshort,   Short,   T_SHORT
1774                         , HOTSPOT_JNI_CALLSTATICSHORTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1775                         HOTSPOT_JNI_CALLSTATICSHORTMETHOD_RETURN(_ret_ref));
1776 
1777 DEFINE_CALLSTATICMETHOD(jobject,  Object,  T_OBJECT
1778                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1779                         HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_RETURN(_ret_ref));
1780 DEFINE_CALLSTATICMETHOD(jint,     Int,     T_INT
1781                         , HOTSPOT_JNI_CALLSTATICINTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1782                         HOTSPOT_JNI_CALLSTATICINTMETHOD_RETURN(_ret_ref));
1783 DEFINE_CALLSTATICMETHOD(jlong,    Long,    T_LONG
1784                         , HOTSPOT_JNI_CALLSTATICLONGMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1785                         HOTSPOT_JNI_CALLSTATICLONGMETHOD_RETURN(_ret_ref));
1786 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1787 DEFINE_CALLSTATICMETHOD(jfloat,   Float,   T_FLOAT
1788                         , HOTSPOT_JNI_CALLSTATICFLOATMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1789                         HOTSPOT_JNI_CALLSTATICFLOATMETHOD_RETURN());
1790 DEFINE_CALLSTATICMETHOD(jdouble,  Double,  T_DOUBLE
1791                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1792                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_RETURN());
1793 
1794 #define DEFINE_CALLSTATICMETHODV(ResultType, Result, Tag \
1795                                 , EntryProbe, ResultProbe) \
1796 \
1797   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodV, ResultType \
1798                           , ResultProbe);                               \
1799 \
1800 JNI_ENTRY(ResultType, \
1801           jni_CallStatic##Result##MethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args)) \
1802   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;MethodV&quot;); \
1803 \
1804   EntryProbe; \
1805   ResultType ret = 0;\
1806   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodV, ResultType, \
1807                      (const ResultType&amp;)ret);\
1808 \
1809   JavaValue jvalue(Tag); \
1810   JNI_ArgumentPusherVaArg ap(methodID, args); \
1811   /* Make sure class is initialized before trying to invoke its method */ \
1812   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls)); \
1813   k-&gt;initialize(CHECK_0); \
1814   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1815   va_end(args); \
1816   ret = jvalue.get_##ResultType(); \
1817   return ret;\
1818 JNI_END
1819 
1820 // the runtime type of subword integral basic types is integer
1821 DEFINE_CALLSTATICMETHODV(jboolean, Boolean, T_BOOLEAN
1822                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1823                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_RETURN(_ret_ref));
1824 DEFINE_CALLSTATICMETHODV(jbyte,    Byte,    T_BYTE
1825                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1826                         HOTSPOT_JNI_CALLSTATICBYTEMETHODV_RETURN(_ret_ref));
1827 DEFINE_CALLSTATICMETHODV(jchar,    Char,    T_CHAR
1828                         , HOTSPOT_JNI_CALLSTATICCHARMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1829                         HOTSPOT_JNI_CALLSTATICCHARMETHODV_RETURN(_ret_ref));
1830 DEFINE_CALLSTATICMETHODV(jshort,   Short,   T_SHORT
1831                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1832                         HOTSPOT_JNI_CALLSTATICSHORTMETHODV_RETURN(_ret_ref));
1833 
1834 DEFINE_CALLSTATICMETHODV(jobject,  Object,  T_OBJECT
1835                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1836                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_RETURN(_ret_ref));
1837 DEFINE_CALLSTATICMETHODV(jint,     Int,     T_INT
1838                         , HOTSPOT_JNI_CALLSTATICINTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1839                         HOTSPOT_JNI_CALLSTATICINTMETHODV_RETURN(_ret_ref));
1840 DEFINE_CALLSTATICMETHODV(jlong,    Long,    T_LONG
1841                         , HOTSPOT_JNI_CALLSTATICLONGMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1842                         HOTSPOT_JNI_CALLSTATICLONGMETHODV_RETURN(_ret_ref));
1843 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1844 DEFINE_CALLSTATICMETHODV(jfloat,   Float,   T_FLOAT
1845                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1846                         HOTSPOT_JNI_CALLSTATICFLOATMETHODV_RETURN());
1847 DEFINE_CALLSTATICMETHODV(jdouble,  Double,  T_DOUBLE
1848                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1849                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_RETURN());
1850 
1851 #define DEFINE_CALLSTATICMETHODA(ResultType, Result, Tag \
1852                                 , EntryProbe, ResultProbe) \
1853 \
1854   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodA, ResultType \
1855                           , ResultProbe);                               \
1856 \
1857 JNI_ENTRY(ResultType, \
1858           jni_CallStatic##Result##MethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args)) \
1859   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;MethodA&quot;); \
1860 \
1861   EntryProbe; \
1862   ResultType ret = 0;\
1863   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodA, ResultType, \
1864                      (const ResultType&amp;)ret);\
1865 \
1866   JavaValue jvalue(Tag); \
1867   JNI_ArgumentPusherArray ap(methodID, args); \
1868   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1869   ret = jvalue.get_##ResultType(); \
1870   return ret;\
1871 JNI_END
1872 
1873 // the runtime type of subword integral basic types is integer
1874 DEFINE_CALLSTATICMETHODA(jboolean, Boolean, T_BOOLEAN
1875                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1876                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_RETURN(_ret_ref));
1877 DEFINE_CALLSTATICMETHODA(jbyte,    Byte,    T_BYTE
1878                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1879                         HOTSPOT_JNI_CALLSTATICBYTEMETHODA_RETURN(_ret_ref));
1880 DEFINE_CALLSTATICMETHODA(jchar,    Char,    T_CHAR
1881                         , HOTSPOT_JNI_CALLSTATICCHARMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1882                         HOTSPOT_JNI_CALLSTATICCHARMETHODA_RETURN(_ret_ref));
1883 DEFINE_CALLSTATICMETHODA(jshort,   Short,   T_SHORT
1884                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1885                         HOTSPOT_JNI_CALLSTATICSHORTMETHODA_RETURN(_ret_ref));
1886 
1887 DEFINE_CALLSTATICMETHODA(jobject,  Object,  T_OBJECT
1888                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1889                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_RETURN(_ret_ref));
1890 DEFINE_CALLSTATICMETHODA(jint,     Int,     T_INT
1891                         , HOTSPOT_JNI_CALLSTATICINTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1892                         HOTSPOT_JNI_CALLSTATICINTMETHODA_RETURN(_ret_ref));
1893 DEFINE_CALLSTATICMETHODA(jlong,    Long,    T_LONG
1894                         , HOTSPOT_JNI_CALLSTATICLONGMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1895                         HOTSPOT_JNI_CALLSTATICLONGMETHODA_RETURN(_ret_ref));
1896 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1897 DEFINE_CALLSTATICMETHODA(jfloat,   Float,   T_FLOAT
1898                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1899                         HOTSPOT_JNI_CALLSTATICFLOATMETHODA_RETURN());
1900 DEFINE_CALLSTATICMETHODA(jdouble,  Double,  T_DOUBLE
1901                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1902                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_RETURN());
1903 
1904 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethod
1905                          , HOTSPOT_JNI_CALLSTATICVOIDMETHOD_RETURN());
1906 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodV
1907                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODV_RETURN());
1908 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodA
1909                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODA_RETURN());
1910 
1911 JNI_ENTRY(void, jni_CallStaticVoidMethod(JNIEnv *env, jclass cls, jmethodID methodID, ...))
1912   JNIWrapper(&quot;CallStaticVoidMethod&quot;);
1913   HOTSPOT_JNI_CALLSTATICVOIDMETHOD_ENTRY(env, cls, (uintptr_t) methodID);
1914   DT_VOID_RETURN_MARK(CallStaticVoidMethod);
1915 
1916   va_list args;
1917   va_start(args, methodID);
1918   JavaValue jvalue(T_VOID);
1919   JNI_ArgumentPusherVaArg ap(methodID, args);
1920   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1921   va_end(args);
1922 JNI_END
1923 
1924 
1925 JNI_ENTRY(void, jni_CallStaticVoidMethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args))
1926   JNIWrapper(&quot;CallStaticVoidMethodV&quot;);
1927   HOTSPOT_JNI_CALLSTATICVOIDMETHODV_ENTRY(env, cls, (uintptr_t) methodID);
1928   DT_VOID_RETURN_MARK(CallStaticVoidMethodV);
1929 
1930   JavaValue jvalue(T_VOID);
1931   JNI_ArgumentPusherVaArg ap(methodID, args);
1932   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1933 JNI_END
1934 
1935 
1936 JNI_ENTRY(void, jni_CallStaticVoidMethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args))
1937   JNIWrapper(&quot;CallStaticVoidMethodA&quot;);
1938   HOTSPOT_JNI_CALLSTATICVOIDMETHODA_ENTRY(env, cls, (uintptr_t) methodID);
1939   DT_VOID_RETURN_MARK(CallStaticVoidMethodA);
1940 
1941   JavaValue jvalue(T_VOID);
1942   JNI_ArgumentPusherArray ap(methodID, args);
1943   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1944 JNI_END
1945 
1946 
1947 //
1948 // Accessing Fields
1949 //
1950 
1951 
1952 DT_RETURN_MARK_DECL(GetFieldID, jfieldID
1953                     , HOTSPOT_JNI_GETFIELDID_RETURN((uintptr_t)_ret_ref));
1954 
1955 JNI_ENTRY(jfieldID, jni_GetFieldID(JNIEnv *env, jclass clazz,
1956           const char *name, const char *sig))
1957   JNIWrapper(&quot;GetFieldID&quot;);
1958   HOTSPOT_JNI_GETFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
1959   jfieldID ret = 0;
1960   DT_RETURN_MARK(GetFieldID, jfieldID, (const jfieldID&amp;)ret);
1961 
1962   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1963 
1964   // The class should have been loaded (we have an instance of the class
1965   // passed in) so the field and signature should already be in the symbol
1966   // table.  If they&#39;re not there, the field doesn&#39;t exist.
1967   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
1968   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
1969   if (fieldname == NULL || signame == NULL) {
1970     ResourceMark rm;
1971     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
1972   }
1973 
1974   // Make sure class is initialized before handing id&#39;s out to fields
1975   k-&gt;initialize(CHECK_NULL);
1976 
1977   fieldDescriptor fd;
1978   if (!k-&gt;is_instance_klass() ||
1979       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
1980     ResourceMark rm;
1981     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
1982   }
1983 
1984   // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
1985   // It may also have hash bits for k, if VerifyJNIFields is turned on.
1986   ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset(), fd.is_flattened());
1987   return ret;
1988 JNI_END
1989 
1990 
1991 JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
1992   JNIWrapper(&quot;GetObjectField&quot;);
1993   HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
1994   oop o = JNIHandles::resolve_non_null(obj);
1995   Klass* k = o-&gt;klass();
1996   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
1997   oop res = NULL;
1998   // Keep JVMTI addition small and only check enabled flag here.
1999   // jni_GetField_probe() assumes that is okay to create handles.
2000   if (JvmtiExport::should_post_field_access()) {
2001     o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
2002   }
2003   if (!jfieldIDWorkaround::is_flattened_field(fieldID)) {
2004     res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(o, offset);
2005   } else {
2006     assert(k-&gt;is_instance_klass(), &quot;Only instance can have flattened fields&quot;);
2007     InstanceKlass* ik = InstanceKlass::cast(k);
2008     fieldDescriptor fd;
2009     ik-&gt;find_field_from_offset(offset, false, &amp;fd);  // performance bottleneck
2010     InstanceKlass* holder = fd.field_holder();
2011     ValueKlass* field_vklass = ValueKlass::cast(holder-&gt;get_value_field_klass(fd.index()));
2012     res = field_vklass-&gt;read_flattened_field(o, ik-&gt;field_offset(fd.index()), CHECK_NULL);
2013   }
2014   jobject ret = JNIHandles::make_local(env, res);
2015   HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
2016   return ret;
2017 JNI_END
2018 
2019 
2020 
2021 #define DEFINE_GETFIELD(Return,Fieldname,Result \
2022   , EntryProbe, ReturnProbe) \
2023 \
2024   DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
2025   , ReturnProbe); \
2026 \
2027 JNI_ENTRY_NO_PRESERVE(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \
2028   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;Field&quot;); \
2029 \
2030   EntryProbe; \
2031   Return ret = 0;\
2032   DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&amp;)ret);\
2033 \
2034   oop o = JNIHandles::resolve_non_null(obj); \
2035   Klass* k = o-&gt;klass(); \
2036   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2037   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2038   /* jni_GetField_probe_nh() assumes that is not okay to create handles */ \
2039   /* and creates a ResetNoHandleMark.                                   */ \
2040   if (JvmtiExport::should_post_field_access()) { \
2041     o = JvmtiExport::jni_GetField_probe_nh(thread, obj, o, k, fieldID, false); \
2042   } \
2043   ret = o-&gt;Fieldname##_field(offset); \
2044   return ret; \
2045 JNI_END
2046 
2047 DEFINE_GETFIELD(jboolean, bool,   Boolean
2048                 , HOTSPOT_JNI_GETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2049                 HOTSPOT_JNI_GETBOOLEANFIELD_RETURN(_ret_ref))
2050 DEFINE_GETFIELD(jbyte,    byte,   Byte
2051                 , HOTSPOT_JNI_GETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2052                 HOTSPOT_JNI_GETBYTEFIELD_RETURN(_ret_ref))
2053 DEFINE_GETFIELD(jchar,    char,   Char
2054                 , HOTSPOT_JNI_GETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2055                 HOTSPOT_JNI_GETCHARFIELD_RETURN(_ret_ref))
2056 DEFINE_GETFIELD(jshort,   short,  Short
2057                 , HOTSPOT_JNI_GETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2058                 HOTSPOT_JNI_GETSHORTFIELD_RETURN(_ret_ref))
2059 DEFINE_GETFIELD(jint,     int,    Int
2060                 , HOTSPOT_JNI_GETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2061                 HOTSPOT_JNI_GETINTFIELD_RETURN(_ret_ref))
2062 DEFINE_GETFIELD(jlong,    long,   Long
2063                 , HOTSPOT_JNI_GETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2064                 HOTSPOT_JNI_GETLONGFIELD_RETURN(_ret_ref))
2065 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2066 DEFINE_GETFIELD(jfloat,   float,  Float
2067                 , HOTSPOT_JNI_GETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2068                 HOTSPOT_JNI_GETFLOATFIELD_RETURN())
2069 DEFINE_GETFIELD(jdouble,  double, Double
2070                 , HOTSPOT_JNI_GETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2071                 HOTSPOT_JNI_GETDOUBLEFIELD_RETURN())
2072 
2073 address jni_GetBooleanField_addr() {
2074   return (address)jni_GetBooleanField;
2075 }
2076 address jni_GetByteField_addr() {
2077   return (address)jni_GetByteField;
2078 }
2079 address jni_GetCharField_addr() {
2080   return (address)jni_GetCharField;
2081 }
2082 address jni_GetShortField_addr() {
2083   return (address)jni_GetShortField;
2084 }
2085 address jni_GetIntField_addr() {
2086   return (address)jni_GetIntField;
2087 }
2088 address jni_GetLongField_addr() {
2089   return (address)jni_GetLongField;
2090 }
2091 address jni_GetFloatField_addr() {
2092   return (address)jni_GetFloatField;
2093 }
2094 address jni_GetDoubleField_addr() {
2095   return (address)jni_GetDoubleField;
2096 }
2097 
2098 JNI_ENTRY_NO_PRESERVE(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))
2099   JNIWrapper(&quot;SetObjectField&quot;);
2100   HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID, value);
2101   oop o = JNIHandles::resolve_non_null(obj);
2102   Klass* k = o-&gt;klass();
2103   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2104   // Keep JVMTI addition small and only check enabled flag here.
2105   // jni_SetField_probe_nh() assumes that is not okay to create handles
2106   // and creates a ResetNoHandleMark.
2107   if (JvmtiExport::should_post_field_modification()) {
2108     jvalue field_value;
2109     field_value.l = value;
2110     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
2111   }
2112   if (!jfieldIDWorkaround::is_flattened_field(fieldID)) {
2113     HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(o, offset, JNIHandles::resolve(value));
2114   } else {
2115     assert(k-&gt;is_instance_klass(), &quot;Only instances can have flattened fields&quot;);
2116     InstanceKlass* ik = InstanceKlass::cast(k);
2117     fieldDescriptor fd;
2118     ik-&gt;find_field_from_offset(offset, false, &amp;fd);
2119     InstanceKlass* holder = fd.field_holder();
2120     ValueKlass* vklass = ValueKlass::cast(holder-&gt;get_value_field_klass(fd.index()));
2121     oop v = JNIHandles::resolve_non_null(value);
2122     vklass-&gt;write_flattened_field(o, offset, v, CHECK);
2123   }
2124   HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
2125 JNI_END
2126 
2127 
2128 #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
2129                         , EntryProbe, ReturnProbe) \
2130 \
2131 JNI_ENTRY_NO_PRESERVE(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \
2132   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;Field&quot;); \
2133 \
2134   EntryProbe; \
2135 \
2136   oop o = JNIHandles::resolve_non_null(obj); \
2137   Klass* k = o-&gt;klass(); \
2138   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2139   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2140   /* jni_SetField_probe_nh() assumes that is not okay to create handles */ \
2141   /* and creates a ResetNoHandleMark.                                   */ \
2142   if (JvmtiExport::should_post_field_modification()) { \
2143     jvalue field_value; \
2144     field_value.unionType = value; \
2145     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&amp;field_value); \
2146   } \
2147   if (SigType == JVM_SIGNATURE_BOOLEAN) { value = ((jboolean)value) &amp; 1; } \
2148   o-&gt;Fieldname##_field_put(offset, value); \
2149   ReturnProbe; \
2150 JNI_END
2151 
2152 DEFINE_SETFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z
2153                 , HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2154                 HOTSPOT_JNI_SETBOOLEANFIELD_RETURN())
2155 DEFINE_SETFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b
2156                 , HOTSPOT_JNI_SETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2157                 HOTSPOT_JNI_SETBYTEFIELD_RETURN())
2158 DEFINE_SETFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c
2159                 , HOTSPOT_JNI_SETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2160                 HOTSPOT_JNI_SETCHARFIELD_RETURN())
2161 DEFINE_SETFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s
2162                 , HOTSPOT_JNI_SETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2163                 HOTSPOT_JNI_SETSHORTFIELD_RETURN())
2164 DEFINE_SETFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i
2165                 , HOTSPOT_JNI_SETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2166                 HOTSPOT_JNI_SETINTFIELD_RETURN())
2167 DEFINE_SETFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j
2168                 , HOTSPOT_JNI_SETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2169                 HOTSPOT_JNI_SETLONGFIELD_RETURN())
2170 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2171 DEFINE_SETFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f
2172                 , HOTSPOT_JNI_SETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2173                 HOTSPOT_JNI_SETFLOATFIELD_RETURN())
2174 DEFINE_SETFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d
2175                 , HOTSPOT_JNI_SETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2176                 HOTSPOT_JNI_SETDOUBLEFIELD_RETURN())
2177 
2178 DT_RETURN_MARK_DECL(ToReflectedField, jobject
2179                     , HOTSPOT_JNI_TOREFLECTEDFIELD_RETURN(_ret_ref));
2180 
2181 JNI_ENTRY(jobject, jni_ToReflectedField(JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic))
2182   JNIWrapper(&quot;ToReflectedField&quot;);
2183   HOTSPOT_JNI_TOREFLECTEDFIELD_ENTRY(env, cls, (uintptr_t) fieldID, isStatic);
2184   jobject ret = NULL;
2185   DT_RETURN_MARK(ToReflectedField, jobject, (const jobject&amp;)ret);
2186 
2187   fieldDescriptor fd;
2188   bool found = false;
2189   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2190 
2191   assert(jfieldIDWorkaround::is_static_jfieldID(fieldID) == (isStatic != 0), &quot;invalid fieldID&quot;);
2192 
2193   if (isStatic) {
2194     // Static field. The fieldID a JNIid specifying the field holder and the offset within the Klass*.
2195     JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2196     assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2197     found = id-&gt;find_local_field(&amp;fd);
2198   } else {
2199     // Non-static field. The fieldID is really the offset of the field within the instanceOop.
2200     int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2201     found = InstanceKlass::cast(k)-&gt;find_field_from_offset(offset, false, &amp;fd);
2202   }
2203   assert(found, &quot;bad fieldID passed into jni_ToReflectedField&quot;);
2204   oop reflected = Reflection::new_field(&amp;fd, CHECK_NULL);
2205   ret = JNIHandles::make_local(env, reflected);
2206   return ret;
2207 JNI_END
2208 
2209 
2210 //
2211 // Accessing Static Fields
2212 //
2213 DT_RETURN_MARK_DECL(GetStaticFieldID, jfieldID
2214                     , HOTSPOT_JNI_GETSTATICFIELDID_RETURN((uintptr_t)_ret_ref));
2215 
2216 JNI_ENTRY(jfieldID, jni_GetStaticFieldID(JNIEnv *env, jclass clazz,
2217           const char *name, const char *sig))
2218   JNIWrapper(&quot;GetStaticFieldID&quot;);
2219   HOTSPOT_JNI_GETSTATICFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
2220   jfieldID ret = NULL;
2221   DT_RETURN_MARK(GetStaticFieldID, jfieldID, (const jfieldID&amp;)ret);
2222 
2223   // The class should have been loaded (we have an instance of the class
2224   // passed in) so the field and signature should already be in the symbol
2225   // table.  If they&#39;re not there, the field doesn&#39;t exist.
2226   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
2227   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
2228   if (fieldname == NULL || signame == NULL) {
2229     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2230   }
2231   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2232   // Make sure class is initialized before handing id&#39;s out to static fields
2233   k-&gt;initialize(CHECK_NULL);
2234 
2235   fieldDescriptor fd;
2236   if (!k-&gt;is_instance_klass() ||
2237       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, true, &amp;fd)) {
2238     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2239   }
2240 
2241   // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
2242   JNIid* id = fd.field_holder()-&gt;jni_id_for(fd.offset());
2243   debug_only(id-&gt;set_is_static_field_id();)
2244 
2245   debug_only(id-&gt;verify(fd.field_holder()));
2246 
2247   ret = jfieldIDWorkaround::to_static_jfieldID(id);
2248   return ret;
2249 JNI_END
2250 
2251 
2252 JNI_ENTRY(jobject, jni_GetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID))
2253   JNIWrapper(&quot;GetStaticObjectField&quot;);
2254   HOTSPOT_JNI_GETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID);
2255 #if INCLUDE_JNI_CHECK
2256   DEBUG_ONLY(Klass* param_k = jniCheck::validate_class(thread, clazz);)
2257 #endif // INCLUDE_JNI_CHECK
2258   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2259   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2260   // Keep JVMTI addition small and only check enabled flag here.
2261   // jni_GetField_probe() assumes that is okay to create handles.
2262   if (JvmtiExport::should_post_field_access()) {
2263     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true);
2264   }
2265   jobject ret = JNIHandles::make_local(id-&gt;holder()-&gt;java_mirror()-&gt;obj_field(id-&gt;offset()));
2266   HOTSPOT_JNI_GETSTATICOBJECTFIELD_RETURN(ret);
2267   return ret;
2268 JNI_END
2269 
2270 
2271 #define DEFINE_GETSTATICFIELD(Return,Fieldname,Result \
2272                               , EntryProbe, ReturnProbe) \
2273 \
2274   DT_RETURN_MARK_DECL_FOR(Result, GetStatic##Result##Field, Return \
2275                           , ReturnProbe);                                          \
2276 \
2277 JNI_ENTRY(Return, jni_GetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID)) \
2278   JNIWrapper(&quot;GetStatic&quot; XSTR(Result) &quot;Field&quot;); \
2279   EntryProbe; \
2280   Return ret = 0;\
2281   DT_RETURN_MARK_FOR(Result, GetStatic##Result##Field, Return, \
2282                      (const Return&amp;)ret);\
2283   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2284   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;); \
2285   /* Keep JVMTI addition small and only check enabled flag here. */ \
2286   /* jni_GetField_probe() assumes that is okay to create handles. */ \
2287   if (JvmtiExport::should_post_field_access()) { \
2288     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true); \
2289   } \
2290   ret = id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field (id-&gt;offset()); \
2291   return ret;\
2292 JNI_END
2293 
2294 DEFINE_GETSTATICFIELD(jboolean, bool,   Boolean
2295                       , HOTSPOT_JNI_GETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t) fieldID), HOTSPOT_JNI_GETSTATICBOOLEANFIELD_RETURN(_ret_ref))
2296 DEFINE_GETSTATICFIELD(jbyte,    byte,   Byte
2297                       , HOTSPOT_JNI_GETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICBYTEFIELD_RETURN(_ret_ref)   )
2298 DEFINE_GETSTATICFIELD(jchar,    char,   Char
2299                       , HOTSPOT_JNI_GETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICCHARFIELD_RETURN(_ret_ref)   )
2300 DEFINE_GETSTATICFIELD(jshort,   short,  Short
2301                       , HOTSPOT_JNI_GETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICSHORTFIELD_RETURN(_ret_ref)  )
2302 DEFINE_GETSTATICFIELD(jint,     int,    Int
2303                       , HOTSPOT_JNI_GETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),     HOTSPOT_JNI_GETSTATICINTFIELD_RETURN(_ret_ref)    )
2304 DEFINE_GETSTATICFIELD(jlong,    long,   Long
2305                       , HOTSPOT_JNI_GETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICLONGFIELD_RETURN(_ret_ref)   )
2306 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2307 DEFINE_GETSTATICFIELD(jfloat,   float,  Float
2308                       , HOTSPOT_JNI_GETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICFLOATFIELD_RETURN()          )
2309 DEFINE_GETSTATICFIELD(jdouble,  double, Double
2310                       , HOTSPOT_JNI_GETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),  HOTSPOT_JNI_GETSTATICDOUBLEFIELD_RETURN()         )
2311 
2312 JNI_ENTRY(void, jni_SetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value))
2313   JNIWrapper(&quot;SetStaticObjectField&quot;);
2314  HOTSPOT_JNI_SETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value);
2315   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2316   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2317   // Keep JVMTI addition small and only check enabled flag here.
2318   // jni_SetField_probe() assumes that is okay to create handles.
2319   if (JvmtiExport::should_post_field_modification()) {
2320     jvalue field_value;
2321     field_value.l = value;
2322     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
2323   }
2324   id-&gt;holder()-&gt;java_mirror()-&gt;obj_field_put(id-&gt;offset(), JNIHandles::resolve(value));
2325   HOTSPOT_JNI_SETSTATICOBJECTFIELD_RETURN();
2326 JNI_END
2327 
2328 
2329 
2330 #define DEFINE_SETSTATICFIELD(Argument,Fieldname,Result,SigType,unionType \
2331                               , EntryProbe, ReturnProbe) \
2332 \
2333 JNI_ENTRY(void, jni_SetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID, Argument value)) \
2334   JNIWrapper(&quot;SetStatic&quot; XSTR(Result) &quot;Field&quot;); \
2335   EntryProbe; \
2336 \
2337   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2338   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;); \
2339   /* Keep JVMTI addition small and only check enabled flag here. */ \
2340   /* jni_SetField_probe() assumes that is okay to create handles. */ \
2341   if (JvmtiExport::should_post_field_modification()) { \
2342     jvalue field_value; \
2343     field_value.unionType = value; \
2344     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, SigType, (jvalue *)&amp;field_value); \
2345   } \
2346   if (SigType == JVM_SIGNATURE_BOOLEAN) { value = ((jboolean)value) &amp; 1; } \
2347   id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field_put (id-&gt;offset(), value); \
2348   ReturnProbe;\
2349 JNI_END
2350 
2351 DEFINE_SETSTATICFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z
2352                       , HOTSPOT_JNI_SETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
2353                       HOTSPOT_JNI_SETSTATICBOOLEANFIELD_RETURN())
2354 DEFINE_SETSTATICFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b
2355                       , HOTSPOT_JNI_SETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2356                       HOTSPOT_JNI_SETSTATICBYTEFIELD_RETURN())
2357 DEFINE_SETSTATICFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c
2358                       , HOTSPOT_JNI_SETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2359                       HOTSPOT_JNI_SETSTATICCHARFIELD_RETURN())
2360 DEFINE_SETSTATICFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s
2361                       , HOTSPOT_JNI_SETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2362                       HOTSPOT_JNI_SETSTATICSHORTFIELD_RETURN())
2363 DEFINE_SETSTATICFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i
2364                       , HOTSPOT_JNI_SETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2365                       HOTSPOT_JNI_SETSTATICINTFIELD_RETURN())
2366 DEFINE_SETSTATICFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j
2367                       , HOTSPOT_JNI_SETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2368                       HOTSPOT_JNI_SETSTATICLONGFIELD_RETURN())
2369 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2370 DEFINE_SETSTATICFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f
2371                       , HOTSPOT_JNI_SETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2372                       HOTSPOT_JNI_SETSTATICFLOATFIELD_RETURN())
2373 DEFINE_SETSTATICFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d
2374                       , HOTSPOT_JNI_SETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2375                       HOTSPOT_JNI_SETSTATICDOUBLEFIELD_RETURN())
2376 
2377 //
2378 // String Operations
2379 //
2380 
2381 // Unicode Interface
2382 
2383 DT_RETURN_MARK_DECL(NewString, jstring
2384                     , HOTSPOT_JNI_NEWSTRING_RETURN(_ret_ref));
2385 
2386 JNI_ENTRY(jstring, jni_NewString(JNIEnv *env, const jchar *unicodeChars, jsize len))
2387   JNIWrapper(&quot;NewString&quot;);
2388  HOTSPOT_JNI_NEWSTRING_ENTRY(env, (uint16_t *) unicodeChars, len);
2389   jstring ret = NULL;
2390   DT_RETURN_MARK(NewString, jstring, (const jstring&amp;)ret);
2391   oop string=java_lang_String::create_oop_from_unicode((jchar*) unicodeChars, len, CHECK_NULL);
2392   ret = (jstring) JNIHandles::make_local(env, string);
2393   return ret;
2394 JNI_END
2395 
2396 
2397 JNI_ENTRY_NO_PRESERVE(jsize, jni_GetStringLength(JNIEnv *env, jstring string))
2398   JNIWrapper(&quot;GetStringLength&quot;);
2399   HOTSPOT_JNI_GETSTRINGLENGTH_ENTRY(env, string);
2400   jsize ret = 0;
2401   oop s = JNIHandles::resolve_non_null(string);
2402   ret = java_lang_String::length(s);
2403  HOTSPOT_JNI_GETSTRINGLENGTH_RETURN(ret);
2404   return ret;
2405 JNI_END
2406 
2407 
2408 JNI_ENTRY_NO_PRESERVE(const jchar*, jni_GetStringChars(
2409   JNIEnv *env, jstring string, jboolean *isCopy))
2410   JNIWrapper(&quot;GetStringChars&quot;);
2411  HOTSPOT_JNI_GETSTRINGCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2412   jchar* buf = NULL;
2413   oop s = JNIHandles::resolve_non_null(string);
2414   typeArrayOop s_value = java_lang_String::value(s);
2415   if (s_value != NULL) {
2416     int s_len = java_lang_String::length(s, s_value);
2417     bool is_latin1 = java_lang_String::is_latin1(s);
2418     buf = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
2419     /* JNI Specification states return NULL on OOM */
2420     if (buf != NULL) {
2421       if (s_len &gt; 0) {
2422         if (!is_latin1) {
2423           ArrayAccess&lt;&gt;::arraycopy_to_native(s_value, (size_t) typeArrayOopDesc::element_offset&lt;jchar&gt;(0),
2424                                              buf, s_len);
2425         } else {
2426           for (int i = 0; i &lt; s_len; i++) {
2427             buf[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
2428           }
2429         }
2430       }
2431       buf[s_len] = 0;
2432       //%note jni_5
2433       if (isCopy != NULL) {
2434         *isCopy = JNI_TRUE;
2435       }
2436     }
2437   }
2438   HOTSPOT_JNI_GETSTRINGCHARS_RETURN(buf);
2439   return buf;
2440 JNI_END
2441 
2442 
2443 JNI_ENTRY_NO_PRESERVE(void, jni_ReleaseStringChars(JNIEnv *env, jstring str, const jchar *chars))
2444   JNIWrapper(&quot;ReleaseStringChars&quot;);
2445   HOTSPOT_JNI_RELEASESTRINGCHARS_ENTRY(env, str, (uint16_t *) chars);
2446   //%note jni_6
2447   if (chars != NULL) {
2448     // Since String objects are supposed to be immutable, don&#39;t copy any
2449     // new data back.  A bad user will have to go after the char array.
2450     FreeHeap((void*) chars);
2451   }
2452   HOTSPOT_JNI_RELEASESTRINGCHARS_RETURN();
2453 JNI_END
2454 
2455 
2456 // UTF Interface
2457 
2458 DT_RETURN_MARK_DECL(NewStringUTF, jstring
2459                     , HOTSPOT_JNI_NEWSTRINGUTF_RETURN(_ret_ref));
2460 
2461 JNI_ENTRY(jstring, jni_NewStringUTF(JNIEnv *env, const char *bytes))
2462   JNIWrapper(&quot;NewStringUTF&quot;);
2463   HOTSPOT_JNI_NEWSTRINGUTF_ENTRY(env, (char *) bytes);
2464   jstring ret;
2465   DT_RETURN_MARK(NewStringUTF, jstring, (const jstring&amp;)ret);
2466 
2467   oop result = java_lang_String::create_oop_from_str((char*) bytes, CHECK_NULL);
2468   ret = (jstring) JNIHandles::make_local(env, result);
2469   return ret;
2470 JNI_END
2471 
2472 
2473 JNI_ENTRY(jsize, jni_GetStringUTFLength(JNIEnv *env, jstring string))
2474   JNIWrapper(&quot;GetStringUTFLength&quot;);
2475  HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(env, string);
2476   oop java_string = JNIHandles::resolve_non_null(string);
2477   jsize ret = java_lang_String::utf8_length(java_string);
2478   HOTSPOT_JNI_GETSTRINGUTFLENGTH_RETURN(ret);
2479   return ret;
2480 JNI_END
2481 
2482 
2483 JNI_ENTRY(const char*, jni_GetStringUTFChars(JNIEnv *env, jstring string, jboolean *isCopy))
2484   JNIWrapper(&quot;GetStringUTFChars&quot;);
2485  HOTSPOT_JNI_GETSTRINGUTFCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2486   char* result = NULL;
2487   oop java_string = JNIHandles::resolve_non_null(string);
2488   typeArrayOop s_value = java_lang_String::value(java_string);
2489   if (s_value != NULL) {
2490     size_t length = java_lang_String::utf8_length(java_string, s_value);
2491     /* JNI Specification states return NULL on OOM */
2492     result = AllocateHeap(length + 1, mtInternal, 0, AllocFailStrategy::RETURN_NULL);
2493     if (result != NULL) {
2494       java_lang_String::as_utf8_string(java_string, s_value, result, (int) length + 1);
2495       if (isCopy != NULL) {
2496         *isCopy = JNI_TRUE;
2497       }
2498     }
2499   }
2500  HOTSPOT_JNI_GETSTRINGUTFCHARS_RETURN(result);
2501   return result;
2502 JNI_END
2503 
2504 
2505 JNI_LEAF(void, jni_ReleaseStringUTFChars(JNIEnv *env, jstring str, const char *chars))
2506   JNIWrapper(&quot;ReleaseStringUTFChars&quot;);
2507  HOTSPOT_JNI_RELEASESTRINGUTFCHARS_ENTRY(env, str, (char *) chars);
2508   if (chars != NULL) {
2509     FreeHeap((char*) chars);
2510   }
2511 HOTSPOT_JNI_RELEASESTRINGUTFCHARS_RETURN();
2512 JNI_END
2513 
2514 
2515 JNI_ENTRY_NO_PRESERVE(jsize, jni_GetArrayLength(JNIEnv *env, jarray array))
2516   JNIWrapper(&quot;GetArrayLength&quot;);
2517  HOTSPOT_JNI_GETARRAYLENGTH_ENTRY(env, array);
2518   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
2519   assert(a-&gt;is_array(), &quot;must be array&quot;);
2520   jsize ret = a-&gt;length();
2521  HOTSPOT_JNI_GETARRAYLENGTH_RETURN(ret);
2522   return ret;
2523 JNI_END
2524 
2525 
2526 //
2527 // Object Array Operations
2528 //
2529 
2530 DT_RETURN_MARK_DECL(NewObjectArray, jobjectArray
2531                     , HOTSPOT_JNI_NEWOBJECTARRAY_RETURN(_ret_ref));
2532 
2533 JNI_ENTRY(jobjectArray, jni_NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement))
2534   JNIWrapper(&quot;NewObjectArray&quot;);
2535  HOTSPOT_JNI_NEWOBJECTARRAY_ENTRY(env, length, elementClass, initialElement);
2536   jobjectArray ret = NULL;
2537   DT_RETURN_MARK(NewObjectArray, jobjectArray, (const jobjectArray&amp;)ret);
2538   Klass* ek = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(elementClass));
2539   Klass* ak = ek-&gt;array_klass(CHECK_NULL);
2540   ObjArrayKlass::cast(ak)-&gt;initialize(CHECK_NULL);
2541   objArrayOop result = ObjArrayKlass::cast(ak)-&gt;allocate(length, CHECK_NULL);
2542   oop initial_value = JNIHandles::resolve(initialElement);
2543   if (initial_value != NULL) {  // array already initialized with NULL
2544     for (int index = 0; index &lt; length; index++) {
2545       result-&gt;obj_at_put(index, initial_value);
2546     }
2547   }
2548   ret = (jobjectArray) JNIHandles::make_local(env, result);
2549   return ret;
2550 JNI_END
2551 
2552 DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject
2553                     , HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(_ret_ref));
2554 
2555 JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
2556   JNIWrapper(&quot;GetObjectArrayElement&quot;);
2557  HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
2558   jobject ret = NULL;
2559   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&amp;)ret);
2560   oop res = NULL;
2561   arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));
2562   if (arr-&gt;is_within_bounds(index)) {
2563     if (arr-&gt;is_valueArray()) {
2564       valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));
2565       arrayHandle ah(THREAD, a);
2566       valueArrayHandle vah(thread, a);
2567       res = valueArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK_NULL);
2568       assert(res != NULL, &quot;Must be set in one of two paths above&quot;);
2569     } else {
2570       assert(arr-&gt;is_objArray(), &quot;If not a valueArray. must be an objArray&quot;);
2571       objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2572       res = a-&gt;obj_at(index);
2573     }
2574   } else {
2575     ResourceMark rm(THREAD);
2576     stringStream ss;
2577     ss.print(&quot;Index %d out of bounds for length %d&quot;, index,arr-&gt;length());
2578     THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2579   }
2580   ret = JNIHandles::make_local(env, res);
2581   return ret;
2582 JNI_END
2583 
2584 DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
2585                          , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
2586 
2587 JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
2588   JNIWrapper(&quot;SetObjectArrayElement&quot;);
2589   HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);
2590   DT_VOID_RETURN_MARK(SetObjectArrayElement);
2591 
2592    bool oob = false;
2593    int length = -1;
2594    oop res = NULL;
2595    arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));
2596    if (arr-&gt;is_within_bounds(index)) {
2597      if (arr-&gt;is_valueArray()) {
2598        valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));
2599        oop v = JNIHandles::resolve(value);
2600        ValueArrayKlass* vaklass = ValueArrayKlass::cast(a-&gt;klass());
2601        ValueKlass* element_vklass = vaklass-&gt;element_klass();
2602        if (v != NULL &amp;&amp; v-&gt;is_a(element_vklass)) {
2603          a-&gt;value_copy_to_index(v, index);
2604        } else {
2605          ResourceMark rm(THREAD);
2606          stringStream ss;
2607          Klass *kl = ValueArrayKlass::cast(a-&gt;klass());
2608          ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,
2609              v-&gt;klass()-&gt;external_name(),
2610              kl-&gt;external_name(),
2611              index);
2612          for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {
2613            ss.print(&quot;[]&quot;);
2614          }
2615          THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
2616        }
2617      } else {
2618        assert(arr-&gt;is_objArray(), &quot;If not a valueArray. must be an objArray&quot;);
2619        objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2620        oop v = JNIHandles::resolve(value);
2621        if (v == NULL || v-&gt;is_a(ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass())) {
2622          a-&gt;obj_at_put(index, v);
2623        } else {
2624          ResourceMark rm(THREAD);
2625          stringStream ss;
2626          Klass *bottom_kl = ObjArrayKlass::cast(a-&gt;klass())-&gt;bottom_klass();
2627          ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,
2628              v-&gt;klass()-&gt;external_name(),
2629              bottom_kl-&gt;is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)-&gt;element_type()] : bottom_kl-&gt;external_name(),
2630                  index);
2631          for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {
2632            ss.print(&quot;[]&quot;);
2633          }
2634          THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
2635        }
2636      }
2637    } else {
2638      ResourceMark rm(THREAD);
2639      stringStream ss;
2640      ss.print(&quot;Index %d out of bounds for length %d&quot;, index, arr-&gt;length());
2641      THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2642    }
2643 JNI_END
2644 
2645 
2646 
2647 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
2648                               ,EntryProbe,ReturnProbe)  \
2649 \
2650   DT_RETURN_MARK_DECL(New##Result##Array, Return \
2651                       , ReturnProbe); \
2652 \
2653 JNI_ENTRY(Return, \
2654           jni_New##Result##Array(JNIEnv *env, jsize len)) \
2655   JNIWrapper(&quot;New&quot; XSTR(Result) &quot;Array&quot;); \
2656   EntryProbe; \
2657   Return ret = NULL;\
2658   DT_RETURN_MARK(New##Result##Array, Return, (const Return&amp;)ret);\
2659 \
<a name="4" id="anc4"></a><span class="line-modified">2660   oop obj= oopFactory::Allocator(len, CHECK_NULL); \</span>
2661   ret = (Return) JNIHandles::make_local(env, obj); \
2662   return ret;\
2663 JNI_END
2664 
2665 DEFINE_NEWSCALARARRAY(jbooleanArray, new_boolArray,   Boolean,
2666                       HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY(env, len),
2667                       HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN(_ret_ref))
2668 DEFINE_NEWSCALARARRAY(jbyteArray,    new_byteArray,   Byte,
2669                       HOTSPOT_JNI_NEWBYTEARRAY_ENTRY(env, len),
2670                       HOTSPOT_JNI_NEWBYTEARRAY_RETURN(_ret_ref))
2671 DEFINE_NEWSCALARARRAY(jshortArray,   new_shortArray,  Short,
2672                       HOTSPOT_JNI_NEWSHORTARRAY_ENTRY(env, len),
2673                       HOTSPOT_JNI_NEWSHORTARRAY_RETURN(_ret_ref))
2674 DEFINE_NEWSCALARARRAY(jcharArray,    new_charArray,   Char,
2675                       HOTSPOT_JNI_NEWCHARARRAY_ENTRY(env, len),
2676                       HOTSPOT_JNI_NEWCHARARRAY_RETURN(_ret_ref))
2677 DEFINE_NEWSCALARARRAY(jintArray,     new_intArray,    Int,
2678                       HOTSPOT_JNI_NEWINTARRAY_ENTRY(env, len),
2679                       HOTSPOT_JNI_NEWINTARRAY_RETURN(_ret_ref))
2680 DEFINE_NEWSCALARARRAY(jlongArray,    new_longArray,   Long,
2681                       HOTSPOT_JNI_NEWLONGARRAY_ENTRY(env, len),
2682                       HOTSPOT_JNI_NEWLONGARRAY_RETURN(_ret_ref))
2683 DEFINE_NEWSCALARARRAY(jfloatArray,   new_floatArray,  Float,
2684                       HOTSPOT_JNI_NEWFLOATARRAY_ENTRY(env, len),
2685                       HOTSPOT_JNI_NEWFLOATARRAY_RETURN(_ret_ref))
2686 DEFINE_NEWSCALARARRAY(jdoubleArray,  new_doubleArray, Double,
2687                       HOTSPOT_JNI_NEWDOUBLEARRAY_ENTRY(env, len),
2688                       HOTSPOT_JNI_NEWDOUBLEARRAY_RETURN(_ret_ref))
2689 
2690 // Return an address which will fault if the caller writes to it.
2691 
2692 static char* get_bad_address() {
2693   static char* bad_address = NULL;
2694   if (bad_address == NULL) {
2695     size_t size = os::vm_allocation_granularity();
2696     bad_address = os::reserve_memory(size);
2697     if (bad_address != NULL) {
2698       os::protect_memory(bad_address, size, os::MEM_PROT_READ,
2699                          /*is_committed*/false);
2700       MemTracker::record_virtual_memory_type((void*)bad_address, mtInternal);
2701     }
2702   }
2703   return bad_address;
2704 }
2705 
2706 
2707 
2708 #define DEFINE_GETSCALARARRAYELEMENTS(ElementTag,ElementType,Result, Tag \
2709                                       , EntryProbe, ReturnProbe) \
2710 \
2711 JNI_ENTRY_NO_PRESERVE(ElementType*, \
2712           jni_Get##Result##ArrayElements(JNIEnv *env, ElementType##Array array, jboolean *isCopy)) \
2713   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2714   EntryProbe; \
2715   /* allocate an chunk of memory in c land */ \
2716   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2717   ElementType* result; \
2718   int len = a-&gt;length(); \
2719   if (len == 0) { \
2720     if (isCopy != NULL) { \
2721       *isCopy = JNI_FALSE; \
2722     } \
2723     /* Empty array: legal but useless, can&#39;t return NULL. \
2724      * Return a pointer to something useless. \
2725      * Avoid asserts in typeArrayOop. */ \
2726     result = (ElementType*)get_bad_address(); \
2727   } else { \
2728     /* JNI Specification states return NULL on OOM */                    \
2729     result = NEW_C_HEAP_ARRAY_RETURN_NULL(ElementType, len, mtInternal); \
2730     if (result != NULL) {                                                \
2731       /* copy the array to the c chunk */                                \
2732       ArrayAccess&lt;&gt;::arraycopy_to_native(a, typeArrayOopDesc::element_offset&lt;ElementType&gt;(0), \
2733                                          result, len);                   \
2734       if (isCopy) {                                                      \
2735         *isCopy = JNI_TRUE;                                              \
2736       }                                                                  \
2737     }                                                                    \
2738   } \
2739   ReturnProbe; \
2740   return result; \
2741 JNI_END
2742 
2743 DEFINE_GETSCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2744                               , HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2745                               HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_RETURN((uintptr_t*)result))
2746 DEFINE_GETSCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2747                               , HOTSPOT_JNI_GETBYTEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2748                               HOTSPOT_JNI_GETBYTEARRAYELEMENTS_RETURN((char*)result))
2749 DEFINE_GETSCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2750                               , HOTSPOT_JNI_GETSHORTARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2751                               HOTSPOT_JNI_GETSHORTARRAYELEMENTS_RETURN((uint16_t*)result))
2752 DEFINE_GETSCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2753                               , HOTSPOT_JNI_GETCHARARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2754                               HOTSPOT_JNI_GETCHARARRAYELEMENTS_RETURN(result))
2755 DEFINE_GETSCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2756                               , HOTSPOT_JNI_GETINTARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2757                               HOTSPOT_JNI_GETINTARRAYELEMENTS_RETURN((uint32_t*)result))
2758 DEFINE_GETSCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2759                               , HOTSPOT_JNI_GETLONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2760                               HOTSPOT_JNI_GETLONGARRAYELEMENTS_RETURN(((uintptr_t*)result)))
2761 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2762 DEFINE_GETSCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2763                               , HOTSPOT_JNI_GETFLOATARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2764                               HOTSPOT_JNI_GETFLOATARRAYELEMENTS_RETURN(result))
2765 DEFINE_GETSCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2766                               , HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2767                               HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_RETURN(result))
2768 
2769 
2770 #define DEFINE_RELEASESCALARARRAYELEMENTS(ElementTag,ElementType,Result,Tag \
2771                                           , EntryProbe, ReturnProbe);\
2772 \
2773 JNI_ENTRY_NO_PRESERVE(void, \
2774           jni_Release##Result##ArrayElements(JNIEnv *env, ElementType##Array array, \
2775                                              ElementType *buf, jint mode)) \
2776   JNIWrapper(&quot;Release&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2777   EntryProbe; \
2778   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2779   int len = a-&gt;length(); \
2780   if (len != 0) {   /* Empty array:  nothing to free or copy. */  \
2781     if ((mode == 0) || (mode == JNI_COMMIT)) { \
2782       ArrayAccess&lt;&gt;::arraycopy_from_native(buf, a, typeArrayOopDesc::element_offset&lt;ElementType&gt;(0), len); \
2783     } \
2784     if ((mode == 0) || (mode == JNI_ABORT)) { \
2785       FreeHeap(buf); \
2786     } \
2787   } \
2788   ReturnProbe; \
2789 JNI_END
2790 
2791 DEFINE_RELEASESCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2792                                   , HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2793                                   HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_RETURN())
2794 DEFINE_RELEASESCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2795                                   , HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_ENTRY(env, array, (char *) buf, mode),
2796                                   HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_RETURN())
2797 DEFINE_RELEASESCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2798                                   ,  HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2799                                   HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_RETURN())
2800 DEFINE_RELEASESCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2801                                   ,  HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2802                                   HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_RETURN())
2803 DEFINE_RELEASESCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2804                                   , HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_ENTRY(env, array, (uint32_t *) buf, mode),
2805                                   HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_RETURN())
2806 DEFINE_RELEASESCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2807                                   , HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2808                                   HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_RETURN())
2809 DEFINE_RELEASESCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2810                                   , HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_ENTRY(env, array, (float *) buf, mode),
2811                                   HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_RETURN())
2812 DEFINE_RELEASESCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2813                                   , HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_ENTRY(env, array, (double *) buf, mode),
2814                                   HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_RETURN())
2815 
2816 static void check_bounds(jsize start, jsize copy_len, jsize array_len, TRAPS) {
2817   ResourceMark rm(THREAD);
2818   if (copy_len &lt; 0) {
2819     stringStream ss;
2820     ss.print(&quot;Length %d is negative&quot;, copy_len);
2821     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2822   } else if (start &lt; 0 || (start &gt; array_len - copy_len)) {
2823     stringStream ss;
2824     ss.print(&quot;Array region %d..&quot; INT64_FORMAT &quot; out of bounds for length %d&quot;,
2825              start, (int64_t)start+(int64_t)copy_len, array_len);
2826     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2827   }
2828 }
2829 
2830 #define DEFINE_GETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2831                                     , EntryProbe, ReturnProbe); \
2832   DT_VOID_RETURN_MARK_DECL(Get##Result##ArrayRegion \
2833                            , ReturnProbe); \
2834 \
2835 JNI_ENTRY(void, \
2836 jni_Get##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2837              jsize len, ElementType *buf)) \
2838   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayRegion&quot;); \
2839   EntryProbe; \
2840   DT_VOID_RETURN_MARK(Get##Result##ArrayRegion); \
2841   typeArrayOop src = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2842   check_bounds(start, len, src-&gt;length(), CHECK); \
2843   if (len &gt; 0) {    \
2844     ArrayAccess&lt;&gt;::arraycopy_to_native(src, typeArrayOopDesc::element_offset&lt;ElementType&gt;(start), buf, len); \
2845   } \
2846 JNI_END
2847 
2848 DEFINE_GETSCALARARRAYREGION(T_BOOLEAN, jboolean,Boolean, bool
2849                             , HOTSPOT_JNI_GETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2850                             HOTSPOT_JNI_GETBOOLEANARRAYREGION_RETURN());
2851 DEFINE_GETSCALARARRAYREGION(T_BYTE,    jbyte,   Byte,    byte
2852                             ,  HOTSPOT_JNI_GETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2853                             HOTSPOT_JNI_GETBYTEARRAYREGION_RETURN());
2854 DEFINE_GETSCALARARRAYREGION(T_SHORT,   jshort,  Short,   short
2855                             , HOTSPOT_JNI_GETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2856                             HOTSPOT_JNI_GETSHORTARRAYREGION_RETURN());
2857 DEFINE_GETSCALARARRAYREGION(T_CHAR,    jchar,   Char,    char
2858                             ,  HOTSPOT_JNI_GETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t*) buf),
2859                             HOTSPOT_JNI_GETCHARARRAYREGION_RETURN());
2860 DEFINE_GETSCALARARRAYREGION(T_INT,     jint,    Int,     int
2861                             , HOTSPOT_JNI_GETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t*) buf),
2862                             HOTSPOT_JNI_GETINTARRAYREGION_RETURN());
2863 DEFINE_GETSCALARARRAYREGION(T_LONG,    jlong,   Long,    long
2864                             ,  HOTSPOT_JNI_GETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2865                             HOTSPOT_JNI_GETLONGARRAYREGION_RETURN());
2866 DEFINE_GETSCALARARRAYREGION(T_FLOAT,   jfloat,  Float,   float
2867                             , HOTSPOT_JNI_GETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2868                             HOTSPOT_JNI_GETFLOATARRAYREGION_RETURN());
2869 DEFINE_GETSCALARARRAYREGION(T_DOUBLE,  jdouble, Double,  double
2870                             , HOTSPOT_JNI_GETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2871                             HOTSPOT_JNI_GETDOUBLEARRAYREGION_RETURN());
2872 
2873 
2874 #define DEFINE_SETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2875                                     , EntryProbe, ReturnProbe); \
2876   DT_VOID_RETURN_MARK_DECL(Set##Result##ArrayRegion \
2877                            ,ReturnProbe);           \
2878 \
2879 JNI_ENTRY(void, \
2880 jni_Set##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2881              jsize len, const ElementType *buf)) \
2882   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;ArrayRegion&quot;); \
2883   EntryProbe; \
2884   DT_VOID_RETURN_MARK(Set##Result##ArrayRegion); \
2885   typeArrayOop dst = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2886   check_bounds(start, len, dst-&gt;length(), CHECK); \
2887   if (len &gt; 0) { \
2888     ArrayAccess&lt;&gt;::arraycopy_from_native(buf, dst, typeArrayOopDesc::element_offset&lt;ElementType&gt;(start), len); \
2889   } \
2890 JNI_END
2891 
2892 DEFINE_SETSCALARARRAYREGION(T_BOOLEAN, jboolean, Boolean, bool
2893                             , HOTSPOT_JNI_SETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *)buf),
2894                             HOTSPOT_JNI_SETBOOLEANARRAYREGION_RETURN())
2895 DEFINE_SETSCALARARRAYREGION(T_BYTE,    jbyte,    Byte,    byte
2896                             , HOTSPOT_JNI_SETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2897                             HOTSPOT_JNI_SETBYTEARRAYREGION_RETURN())
2898 DEFINE_SETSCALARARRAYREGION(T_SHORT,   jshort,   Short,   short
2899                             , HOTSPOT_JNI_SETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2900                             HOTSPOT_JNI_SETSHORTARRAYREGION_RETURN())
2901 DEFINE_SETSCALARARRAYREGION(T_CHAR,    jchar,    Char,    char
2902                             , HOTSPOT_JNI_SETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2903                             HOTSPOT_JNI_SETCHARARRAYREGION_RETURN())
2904 DEFINE_SETSCALARARRAYREGION(T_INT,     jint,     Int,     int
2905                             , HOTSPOT_JNI_SETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t *) buf),
2906                             HOTSPOT_JNI_SETINTARRAYREGION_RETURN())
2907 DEFINE_SETSCALARARRAYREGION(T_LONG,    jlong,    Long,    long
2908                             , HOTSPOT_JNI_SETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2909                             HOTSPOT_JNI_SETLONGARRAYREGION_RETURN())
2910 DEFINE_SETSCALARARRAYREGION(T_FLOAT,   jfloat,   Float,   float
2911                             , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2912                             HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
2913 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
2914                             , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2915                             HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
2916 
2917 
2918 DT_RETURN_MARK_DECL(RegisterNatives, jint
2919                     , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
2920 
2921 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
2922                                     const JNINativeMethod *methods,
2923                                     jint nMethods))
2924   JNIWrapper(&quot;RegisterNatives&quot;);
2925   HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
2926   jint ret = 0;
2927   DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
2928 
2929   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2930 
<a name="5" id="anc5"></a><span class="line-modified">2931   // There are no restrictions on native code registering native methods,</span>
<span class="line-modified">2932   // which allows agents to redefine the bindings to native methods, however</span>
<span class="line-modified">2933   // we issue a warning if any code running outside of the boot/platform</span>
<span class="line-modified">2934   // loader is rebinding any native methods in classes loaded by the</span>
<span class="line-modified">2935   // boot/platform loader that are in named modules. That will catch changes</span>
<span class="line-added">2936   // to platform classes while excluding classes added to the bootclasspath.</span>
2937   bool do_warning = false;
<a name="6" id="anc6"></a><span class="line-modified">2938 </span>
<span class="line-modified">2939   // Only instanceKlasses can have native methods</span>
<span class="line-modified">2940   if (k-&gt;is_instance_klass()) {</span>
<span class="line-modified">2941     oop cl = k-&gt;class_loader();</span>
<span class="line-modified">2942     InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-added">2943     // Check for a platform class</span>
<span class="line-added">2944     if ((cl ==  NULL || SystemDictionary::is_platform_class_loader(cl)) &amp;&amp;</span>
<span class="line-added">2945         ik-&gt;module()-&gt;is_named()) {</span>
<span class="line-added">2946       Klass* caller = thread-&gt;security_get_caller_class(1);</span>
<span class="line-added">2947       // If no caller class, or caller class has a different loader, then</span>
<span class="line-added">2948       // issue a warning below.</span>
<span class="line-added">2949       do_warning = (caller == NULL) || caller-&gt;class_loader() != cl;</span>
<span class="line-added">2950     }</span>
2951   }
2952 
2953 
2954   for (int index = 0; index &lt; nMethods; index++) {
2955     const char* meth_name = methods[index].name;
2956     const char* meth_sig = methods[index].signature;
2957     int meth_name_len = (int)strlen(meth_name);
2958 
2959     // The class should have been loaded (we have an instance of the class
2960     // passed in) so the method and signature should already be in the symbol
2961     // table.  If they&#39;re not there, the method doesn&#39;t exist.
2962     TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
2963     TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
2964 
2965     if (name == NULL || signature == NULL) {
2966       ResourceMark rm(THREAD);
2967       stringStream st;
2968       st.print(&quot;Method %s.%s%s not found&quot;, k-&gt;external_name(), meth_name, meth_sig);
2969       // Must return negative value on failure
2970       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
2971     }
2972 
2973     if (do_warning) {
2974       ResourceMark rm(THREAD);
2975       log_warning(jni, resolve)(&quot;Re-registering of platform native method: %s.%s%s &quot;
2976               &quot;from code in a different classloader&quot;, k-&gt;external_name(), meth_name, meth_sig);
2977     }
2978 
2979     bool res = Method::register_native(k, name, signature,
2980                                        (address) methods[index].fnPtr, THREAD);
2981     if (!res) {
2982       ret = -1;
2983       break;
2984     }
2985   }
2986   return ret;
2987 JNI_END
2988 
2989 
2990 JNI_ENTRY(jint, jni_UnregisterNatives(JNIEnv *env, jclass clazz))
2991   JNIWrapper(&quot;UnregisterNatives&quot;);
2992  HOTSPOT_JNI_UNREGISTERNATIVES_ENTRY(env, clazz);
2993   Klass* k   = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2994   //%note jni_2
2995   if (k-&gt;is_instance_klass()) {
2996     for (int index = 0; index &lt; InstanceKlass::cast(k)-&gt;methods()-&gt;length(); index++) {
2997       Method* m = InstanceKlass::cast(k)-&gt;methods()-&gt;at(index);
2998       if (m-&gt;is_native()) {
2999         m-&gt;clear_native_function();
3000         m-&gt;set_signature_handler(NULL);
3001       }
3002     }
3003   }
3004  HOTSPOT_JNI_UNREGISTERNATIVES_RETURN(0);
3005   return 0;
3006 JNI_END
3007 
3008 //
3009 // Monitor functions
3010 //
3011 
3012 DT_RETURN_MARK_DECL(MonitorEnter, jint
3013                     , HOTSPOT_JNI_MONITORENTER_RETURN(_ret_ref));
3014 
3015 JNI_ENTRY(jint, jni_MonitorEnter(JNIEnv *env, jobject jobj))
3016  HOTSPOT_JNI_MONITORENTER_ENTRY(env, jobj);
3017   jint ret = JNI_ERR;
3018   DT_RETURN_MARK(MonitorEnter, jint, (const jint&amp;)ret);
3019 
3020   // If the object is null, we can&#39;t do anything with it
3021   if (jobj == NULL) {
3022     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
3023   }
3024 
3025   Handle obj(thread, JNIHandles::resolve_non_null(jobj));
3026   ObjectSynchronizer::jni_enter(obj, CHECK_(JNI_ERR));
3027   ret = JNI_OK;
3028   return ret;
3029 JNI_END
3030 
3031 DT_RETURN_MARK_DECL(MonitorExit, jint
3032                     , HOTSPOT_JNI_MONITOREXIT_RETURN(_ret_ref));
3033 
3034 JNI_ENTRY(jint, jni_MonitorExit(JNIEnv *env, jobject jobj))
3035  HOTSPOT_JNI_MONITOREXIT_ENTRY(env, jobj);
3036   jint ret = JNI_ERR;
3037   DT_RETURN_MARK(MonitorExit, jint, (const jint&amp;)ret);
3038 
3039   // Don&#39;t do anything with a null object
3040   if (jobj == NULL) {
3041     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
3042   }
3043 
3044   Handle obj(THREAD, JNIHandles::resolve_non_null(jobj));
3045   ObjectSynchronizer::jni_exit(obj(), CHECK_(JNI_ERR));
3046 
3047   ret = JNI_OK;
3048   return ret;
3049 JNI_END
3050 
3051 //
3052 // Extensions
3053 //
3054 
3055 DT_VOID_RETURN_MARK_DECL(GetStringRegion
3056                          , HOTSPOT_JNI_GETSTRINGREGION_RETURN());
3057 
3058 JNI_ENTRY(void, jni_GetStringRegion(JNIEnv *env, jstring string, jsize start, jsize len, jchar *buf))
3059   JNIWrapper(&quot;GetStringRegion&quot;);
3060  HOTSPOT_JNI_GETSTRINGREGION_ENTRY(env, string, start, len, buf);
3061   DT_VOID_RETURN_MARK(GetStringRegion);
3062   oop s = JNIHandles::resolve_non_null(string);
3063   typeArrayOop s_value = java_lang_String::value(s);
3064   int s_len = java_lang_String::length(s, s_value);
3065   if (start &lt; 0 || len &lt; 0 || start &gt; s_len - len) {
3066     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
3067   } else {
3068     if (len &gt; 0) {
3069       bool is_latin1 = java_lang_String::is_latin1(s);
3070       if (!is_latin1) {
3071         ArrayAccess&lt;&gt;::arraycopy_to_native(s_value, typeArrayOopDesc::element_offset&lt;jchar&gt;(start),
3072                                            buf, len);
3073       } else {
3074         for (int i = 0; i &lt; len; i++) {
3075           buf[i] = ((jchar) s_value-&gt;byte_at(i + start)) &amp; 0xff;
3076         }
3077       }
3078     }
3079   }
3080 JNI_END
3081 
3082 DT_VOID_RETURN_MARK_DECL(GetStringUTFRegion
3083                          , HOTSPOT_JNI_GETSTRINGUTFREGION_RETURN());
3084 
3085 JNI_ENTRY(void, jni_GetStringUTFRegion(JNIEnv *env, jstring string, jsize start, jsize len, char *buf))
3086   JNIWrapper(&quot;GetStringUTFRegion&quot;);
3087  HOTSPOT_JNI_GETSTRINGUTFREGION_ENTRY(env, string, start, len, buf);
3088   DT_VOID_RETURN_MARK(GetStringUTFRegion);
3089   oop s = JNIHandles::resolve_non_null(string);
3090   typeArrayOop s_value = java_lang_String::value(s);
3091   int s_len = java_lang_String::length(s, s_value);
3092   if (start &lt; 0 || len &lt; 0 || start &gt; s_len - len) {
3093     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
3094   } else {
3095     //%note jni_7
3096     if (len &gt; 0) {
3097       // Assume the buffer is large enough as the JNI spec. does not require user error checking
3098       java_lang_String::as_utf8_string(s, s_value, start, len, buf, INT_MAX);
3099       // as_utf8_string null-terminates the result string
3100     } else {
3101       // JDK null-terminates the buffer even in len is zero
3102       if (buf != NULL) {
3103         buf[0] = 0;
3104       }
3105     }
3106   }
3107 JNI_END
3108 
3109 static oop lock_gc_or_pin_object(JavaThread* thread, jobject obj) {
3110   if (Universe::heap()-&gt;supports_object_pinning()) {
3111     const oop o = JNIHandles::resolve_non_null(obj);
3112     return Universe::heap()-&gt;pin_object(thread, o);
3113   } else {
3114     GCLocker::lock_critical(thread);
3115     return JNIHandles::resolve_non_null(obj);
3116   }
3117 }
3118 
3119 static void unlock_gc_or_unpin_object(JavaThread* thread, jobject obj) {
3120   if (Universe::heap()-&gt;supports_object_pinning()) {
3121     const oop o = JNIHandles::resolve_non_null(obj);
3122     return Universe::heap()-&gt;unpin_object(thread, o);
3123   } else {
3124     GCLocker::unlock_critical(thread);
3125   }
3126 }
3127 
3128 JNI_ENTRY(void*, jni_GetPrimitiveArrayCritical(JNIEnv *env, jarray array, jboolean *isCopy))
3129   JNIWrapper(&quot;GetPrimitiveArrayCritical&quot;);
3130  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_ENTRY(env, array, (uintptr_t *) isCopy);
3131   if (isCopy != NULL) {
3132     *isCopy = JNI_FALSE;
3133   }
3134   oop a = lock_gc_or_pin_object(thread, array);
3135   assert(a-&gt;is_array(), &quot;just checking&quot;);
3136   BasicType type;
3137   if (a-&gt;is_objArray()) {
3138     type = T_OBJECT;
3139   } else {
3140     type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
3141   }
3142   void* ret = arrayOop(a)-&gt;base(type);
3143  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_RETURN(ret);
3144   return ret;
3145 JNI_END
3146 
3147 
3148 JNI_ENTRY(void, jni_ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode))
3149   JNIWrapper(&quot;ReleasePrimitiveArrayCritical&quot;);
3150   HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_ENTRY(env, array, carray, mode);
3151   unlock_gc_or_unpin_object(thread, array);
3152 HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_RETURN();
3153 JNI_END
3154 
3155 
3156 JNI_ENTRY(const jchar*, jni_GetStringCritical(JNIEnv *env, jstring string, jboolean *isCopy))
3157   JNIWrapper(&quot;GetStringCritical&quot;);
3158   HOTSPOT_JNI_GETSTRINGCRITICAL_ENTRY(env, string, (uintptr_t *) isCopy);
3159   oop s = lock_gc_or_pin_object(thread, string);
3160   typeArrayOop s_value = java_lang_String::value(s);
3161   bool is_latin1 = java_lang_String::is_latin1(s);
3162   if (isCopy != NULL) {
3163     *isCopy = is_latin1 ? JNI_TRUE : JNI_FALSE;
3164   }
3165   jchar* ret;
3166   if (!is_latin1) {
3167     ret = (jchar*) s_value-&gt;base(T_CHAR);
3168   } else {
3169     // Inflate latin1 encoded string to UTF16
3170     int s_len = java_lang_String::length(s, s_value);
3171     ret = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
3172     /* JNI Specification states return NULL on OOM */
3173     if (ret != NULL) {
3174       for (int i = 0; i &lt; s_len; i++) {
3175         ret[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
3176       }
3177       ret[s_len] = 0;
3178     }
3179   }
3180  HOTSPOT_JNI_GETSTRINGCRITICAL_RETURN((uint16_t *) ret);
3181   return ret;
3182 JNI_END
3183 
3184 
3185 JNI_ENTRY(void, jni_ReleaseStringCritical(JNIEnv *env, jstring str, const jchar *chars))
3186   JNIWrapper(&quot;ReleaseStringCritical&quot;);
3187   HOTSPOT_JNI_RELEASESTRINGCRITICAL_ENTRY(env, str, (uint16_t *) chars);
3188   // The str and chars arguments are ignored for UTF16 strings
3189   oop s = JNIHandles::resolve_non_null(str);
3190   bool is_latin1 = java_lang_String::is_latin1(s);
3191   if (is_latin1) {
3192     // For latin1 string, free jchar array allocated by earlier call to GetStringCritical.
3193     // This assumes that ReleaseStringCritical bookends GetStringCritical.
3194     FREE_C_HEAP_ARRAY(jchar, chars);
3195   }
3196   unlock_gc_or_unpin_object(thread, str);
3197 HOTSPOT_JNI_RELEASESTRINGCRITICAL_RETURN();
3198 JNI_END
3199 
3200 
3201 JNI_ENTRY(jweak, jni_NewWeakGlobalRef(JNIEnv *env, jobject ref))
3202   JNIWrapper(&quot;jni_NewWeakGlobalRef&quot;);
3203  HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY(env, ref);
3204   Handle ref_handle(thread, JNIHandles::resolve(ref));
3205   jweak ret = JNIHandles::make_weak_global(ref_handle);
3206  HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN(ret);
3207   return ret;
3208 JNI_END
3209 
3210 // Must be JNI_ENTRY (with HandleMark)
3211 JNI_ENTRY(void, jni_DeleteWeakGlobalRef(JNIEnv *env, jweak ref))
3212   JNIWrapper(&quot;jni_DeleteWeakGlobalRef&quot;);
3213   HOTSPOT_JNI_DELETEWEAKGLOBALREF_ENTRY(env, ref);
3214   JNIHandles::destroy_weak_global(ref);
3215   HOTSPOT_JNI_DELETEWEAKGLOBALREF_RETURN();
3216 JNI_END
3217 
3218 
3219 JNI_ENTRY_NO_PRESERVE(jboolean, jni_ExceptionCheck(JNIEnv *env))
3220   JNIWrapper(&quot;jni_ExceptionCheck&quot;);
3221  HOTSPOT_JNI_EXCEPTIONCHECK_ENTRY(env);
3222   jni_check_async_exceptions(thread);
3223   jboolean ret = (thread-&gt;has_pending_exception()) ? JNI_TRUE : JNI_FALSE;
3224  HOTSPOT_JNI_EXCEPTIONCHECK_RETURN(ret);
3225   return ret;
3226 JNI_END
3227 
3228 
3229 // Initialization state for three routines below relating to
3230 // java.nio.DirectBuffers
3231 static          int directBufferSupportInitializeStarted = 0;
3232 static volatile int directBufferSupportInitializeEnded   = 0;
3233 static volatile int directBufferSupportInitializeFailed  = 0;
3234 static jclass    bufferClass                 = NULL;
3235 static jclass    directBufferClass           = NULL;
3236 static jclass    directByteBufferClass       = NULL;
3237 static jmethodID directByteBufferConstructor = NULL;
3238 static jfieldID  directBufferAddressField    = NULL;
3239 static jfieldID  bufferCapacityField         = NULL;
3240 
3241 static jclass lookupOne(JNIEnv* env, const char* name, TRAPS) {
3242   Handle loader;            // null (bootstrap) loader
3243   Handle protection_domain; // null protection domain
3244 
3245   TempNewSymbol sym = SymbolTable::new_symbol(name);
3246   jclass result =  find_class_from_class_loader(env, sym, true, loader, protection_domain, true, CHECK_NULL);
3247 
3248   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
3249     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
3250   }
3251   return result;
3252 }
3253 
3254 // These lookups are done with the NULL (bootstrap) ClassLoader to
3255 // circumvent any security checks that would be done by jni_FindClass.
3256 JNI_ENTRY(bool, lookupDirectBufferClasses(JNIEnv* env))
3257 {
3258   if ((bufferClass           = lookupOne(env, &quot;java/nio/Buffer&quot;, thread))           == NULL) { return false; }
3259   if ((directBufferClass     = lookupOne(env, &quot;sun/nio/ch/DirectBuffer&quot;, thread))   == NULL) { return false; }
3260   if ((directByteBufferClass = lookupOne(env, &quot;java/nio/DirectByteBuffer&quot;, thread)) == NULL) { return false; }
3261   return true;
3262 }
3263 JNI_END
3264 
3265 
3266 static bool initializeDirectBufferSupport(JNIEnv* env, JavaThread* thread) {
3267   if (directBufferSupportInitializeFailed) {
3268     return false;
3269   }
3270 
3271   if (Atomic::cmpxchg(&amp;directBufferSupportInitializeStarted, 0, 1) == 0) {
3272     if (!lookupDirectBufferClasses(env)) {
3273       directBufferSupportInitializeFailed = 1;
3274       return false;
3275     }
3276 
3277     // Make global references for these
3278     bufferClass           = (jclass) env-&gt;NewGlobalRef(bufferClass);
3279     directBufferClass     = (jclass) env-&gt;NewGlobalRef(directBufferClass);
3280     directByteBufferClass = (jclass) env-&gt;NewGlobalRef(directByteBufferClass);
3281 
3282     // Get needed field and method IDs
3283     directByteBufferConstructor = env-&gt;GetMethodID(directByteBufferClass, &quot;&lt;init&gt;&quot;, &quot;(JI)V&quot;);
3284     if (env-&gt;ExceptionCheck()) {
3285       env-&gt;ExceptionClear();
3286       directBufferSupportInitializeFailed = 1;
3287       return false;
3288     }
3289     directBufferAddressField    = env-&gt;GetFieldID(bufferClass, &quot;address&quot;, &quot;J&quot;);
3290     if (env-&gt;ExceptionCheck()) {
3291       env-&gt;ExceptionClear();
3292       directBufferSupportInitializeFailed = 1;
3293       return false;
3294     }
3295     bufferCapacityField         = env-&gt;GetFieldID(bufferClass, &quot;capacity&quot;, &quot;I&quot;);
3296     if (env-&gt;ExceptionCheck()) {
3297       env-&gt;ExceptionClear();
3298       directBufferSupportInitializeFailed = 1;
3299       return false;
3300     }
3301 
3302     if ((directByteBufferConstructor == NULL) ||
3303         (directBufferAddressField    == NULL) ||
3304         (bufferCapacityField         == NULL)) {
3305       directBufferSupportInitializeFailed = 1;
3306       return false;
3307     }
3308 
3309     directBufferSupportInitializeEnded = 1;
3310   } else {
3311     while (!directBufferSupportInitializeEnded &amp;&amp; !directBufferSupportInitializeFailed) {
3312       os::naked_yield();
3313     }
3314   }
3315 
3316   return !directBufferSupportInitializeFailed;
3317 }
3318 
3319 extern &quot;C&quot; jobject JNICALL jni_NewDirectByteBuffer(JNIEnv *env, void* address, jlong capacity)
3320 {
3321   // thread_from_jni_environment() will block if VM is gone.
3322   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3323 
3324   JNIWrapper(&quot;jni_NewDirectByteBuffer&quot;);
3325  HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_ENTRY(env, address, capacity);
3326 
3327   if (!directBufferSupportInitializeEnded) {
3328     if (!initializeDirectBufferSupport(env, thread)) {
3329       HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(NULL);
3330       return NULL;
3331     }
3332   }
3333 
3334   // Being paranoid about accidental sign extension on address
3335   jlong addr = (jlong) ((uintptr_t) address);
3336   // NOTE that package-private DirectByteBuffer constructor currently
3337   // takes int capacity
3338   jint  cap  = (jint)  capacity;
3339   jobject ret = env-&gt;NewObject(directByteBufferClass, directByteBufferConstructor, addr, cap);
3340   HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(ret);
3341   return ret;
3342 }
3343 
3344 DT_RETURN_MARK_DECL(GetDirectBufferAddress, void*
3345                     , HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_RETURN((void*) _ret_ref));
3346 
3347 extern &quot;C&quot; void* JNICALL jni_GetDirectBufferAddress(JNIEnv *env, jobject buf)
3348 {
3349   // thread_from_jni_environment() will block if VM is gone.
3350   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3351 
3352   JNIWrapper(&quot;jni_GetDirectBufferAddress&quot;);
3353   HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_ENTRY(env, buf);
3354   void* ret = NULL;
3355   DT_RETURN_MARK(GetDirectBufferAddress, void*, (const void*&amp;)ret);
3356 
3357   if (!directBufferSupportInitializeEnded) {
3358     if (!initializeDirectBufferSupport(env, thread)) {
3359       return 0;
3360     }
3361   }
3362 
3363   if ((buf != NULL) &amp;&amp; (!env-&gt;IsInstanceOf(buf, directBufferClass))) {
3364     return 0;
3365   }
3366 
3367   ret = (void*)(intptr_t)env-&gt;GetLongField(buf, directBufferAddressField);
3368   return ret;
3369 }
3370 
3371 DT_RETURN_MARK_DECL(GetDirectBufferCapacity, jlong
3372                     , HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_RETURN(_ret_ref));
3373 
3374 extern &quot;C&quot; jlong JNICALL jni_GetDirectBufferCapacity(JNIEnv *env, jobject buf)
3375 {
3376   // thread_from_jni_environment() will block if VM is gone.
3377   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3378 
3379   JNIWrapper(&quot;jni_GetDirectBufferCapacity&quot;);
3380   HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_ENTRY(env, buf);
3381   jlong ret = -1;
3382   DT_RETURN_MARK(GetDirectBufferCapacity, jlong, (const jlong&amp;)ret);
3383 
3384   if (!directBufferSupportInitializeEnded) {
3385     if (!initializeDirectBufferSupport(env, thread)) {
3386       ret = 0;
3387       return ret;
3388     }
3389   }
3390 
3391   if (buf == NULL) {
3392     return -1;
3393   }
3394 
3395   if (!env-&gt;IsInstanceOf(buf, directBufferClass)) {
3396     return -1;
3397   }
3398 
3399   // NOTE that capacity is currently an int in the implementation
3400   ret = env-&gt;GetIntField(buf, bufferCapacityField);
3401   return ret;
3402 }
3403 
3404 
3405 JNI_LEAF(jint, jni_GetVersion(JNIEnv *env))
3406   JNIWrapper(&quot;GetVersion&quot;);
3407   HOTSPOT_JNI_GETVERSION_ENTRY(env);
3408   HOTSPOT_JNI_GETVERSION_RETURN(CurrentVersion);
3409   return CurrentVersion;
3410 JNI_END
3411 
3412 extern struct JavaVM_ main_vm;
3413 
3414 JNI_LEAF(jint, jni_GetJavaVM(JNIEnv *env, JavaVM **vm))
3415   JNIWrapper(&quot;jni_GetJavaVM&quot;);
3416   HOTSPOT_JNI_GETJAVAVM_ENTRY(env, (void **) vm);
3417   *vm  = (JavaVM *)(&amp;main_vm);
3418   HOTSPOT_JNI_GETJAVAVM_RETURN(JNI_OK);
3419   return JNI_OK;
3420 JNI_END
3421 
3422 
3423 JNI_ENTRY(jobject, jni_GetModule(JNIEnv* env, jclass clazz))
3424   JNIWrapper(&quot;GetModule&quot;);
3425   return Modules::get_module(clazz, THREAD);
3426 JNI_END
3427 
3428 
3429 JNI_ENTRY(void*, jni_GetFlattenedArrayElements(JNIEnv* env, jarray array, jboolean* isCopy))
3430   JNIWrapper(&quot;jni_GetFlattenedArrayElements&quot;);
3431   if (isCopy != NULL) {
3432     *isCopy = JNI_FALSE;
3433   }
3434   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));
3435   if (!ar-&gt;is_array()) {
3436     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3437   }
3438   if (!ar-&gt;is_valueArray()) {
3439     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3440   }
3441   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());
3442   if (vak-&gt;contains_oops()) {
3443     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Flattened array contains oops&quot;);
3444   }
3445   oop a = lock_gc_or_pin_object(thread, array);
3446   valueArrayOop vap = valueArrayOop(a);
3447   void* ret = vap-&gt;value_at_addr(0, vak-&gt;layout_helper());
3448   return ret;
3449 JNI_END
3450 
3451 JNI_ENTRY(void, jni_ReleaseFlattenedArrayElements(JNIEnv* env, jarray array, void* elem, jint mode))
3452   JNIWrapper(&quot;jni_ReleaseFlattenedArrayElements&quot;);
3453   unlock_gc_or_unpin_object(thread, array);
3454 JNI_END
3455 
3456 JNI_ENTRY(jsize, jni_GetFlattenedArrayElementSize(JNIEnv* env, jarray array)) {
3457   JNIWrapper(&quot;jni_GetFlattenedElementSize&quot;);
3458   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
3459   if (!a-&gt;is_array()) {
3460     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3461   }
3462   if (!a-&gt;is_valueArray()) {
3463     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3464   }
3465   ValueArrayKlass* vak = ValueArrayKlass::cast(a-&gt;klass());
3466   jsize ret = vak-&gt;element_byte_size();
3467   return ret;
3468 }
3469 JNI_END
3470 
3471 JNI_ENTRY(jclass, jni_GetFlattenedArrayElementClass(JNIEnv* env, jarray array))
3472   JNIWrapper(&quot;jni_GetArrayElementClass&quot;);
3473   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
3474   if (!a-&gt;is_array()) {
3475     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3476   }
3477   if (!a-&gt;is_valueArray()) {
3478     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3479   }
3480   ValueArrayKlass* vak = ValueArrayKlass::cast(a-&gt;klass());
3481   ValueKlass* vk = vak-&gt;element_klass();
3482   return (jclass) JNIHandles::make_local(vk-&gt;java_mirror());
3483 JNI_END
3484 
3485 JNI_ENTRY(jsize, jni_GetFieldOffsetInFlattenedLayout(JNIEnv* env, jclass clazz, const char *name, const char *signature, jboolean* isFlattened))
3486   JNIWrapper(&quot;jni_GetFieldOffsetInFlattenedLayout&quot;);
3487 
3488   oop mirror = JNIHandles::resolve_non_null(clazz);
3489   Klass* k = java_lang_Class::as_Klass(mirror);
3490   if (!k-&gt;is_value()) {
3491     ResourceMark rm;
3492         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;%s has not flattened layout&quot;, k-&gt;external_name()));
3493   }
3494   ValueKlass* vk = ValueKlass::cast(k);
3495 
3496   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
3497   TempNewSymbol signame = SymbolTable::probe(signature, (int)strlen(signature));
3498   if (fieldname == NULL || signame == NULL) {
3499     ResourceMark rm;
3500     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, vk-&gt;external_name(), name, signature));
3501   }
3502 
3503   assert(vk-&gt;is_initialized(), &quot;If a flattened array has been created, the element klass must have been initialized&quot;);
3504 
3505   fieldDescriptor fd;
3506   if (!vk-&gt;is_instance_klass() ||
3507       !InstanceKlass::cast(vk)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
3508     ResourceMark rm;
3509     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, vk-&gt;external_name(), name, signature));
3510   }
3511 
3512   int offset = fd.offset() - vk-&gt;first_field_offset();
3513   if (isFlattened != NULL) {
3514     *isFlattened = fd.is_flattened();
3515   }
3516   return (jsize)offset;
3517 JNI_END
3518 
3519 JNI_ENTRY(jobject, jni_CreateSubElementSelector(JNIEnv* env, jarray array))
3520   JNIWrapper(&quot;jni_CreateSubElementSelector&quot;);
3521 
3522   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));
3523   if (!ar-&gt;is_array()) {
3524     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3525   }
3526   if (!ar-&gt;is_valueArray()) {
3527     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3528   }
3529   Klass* ses_k = SystemDictionary::resolve_or_null(vmSymbols::jdk_internal_vm_jni_SubElementSelector(),
3530         Handle(THREAD, SystemDictionary::java_system_loader()), Handle(), CHECK_NULL);
3531   InstanceKlass* ses_ik = InstanceKlass::cast(ses_k);
3532   ses_ik-&gt;initialize(CHECK_NULL);
3533   Klass* elementKlass = ArrayKlass::cast(ar-&gt;klass())-&gt;element_klass();
3534   oop ses = ses_ik-&gt;allocate_instance(CHECK_NULL);
3535   Handle ses_h(THREAD, ses);
3536   jdk_internal_vm_jni_SubElementSelector::setArrayElementType(ses_h(), elementKlass-&gt;java_mirror());
3537   jdk_internal_vm_jni_SubElementSelector::setSubElementType(ses_h(), elementKlass-&gt;java_mirror());
3538   jdk_internal_vm_jni_SubElementSelector::setOffset(ses_h(), 0);
3539   jdk_internal_vm_jni_SubElementSelector::setIsFlattened(ses_h(), true);   // by definition, top element of a flattened array is flattened
3540   jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(ses_h(), true); // by definition, top element of a flattened array is flattenable
3541   return JNIHandles::make_local(ses_h());
3542 JNI_END
3543 
3544 JNI_ENTRY(jobject, jni_GetSubElementSelector(JNIEnv* env, jobject selector, jfieldID fieldID))
3545   JNIWrapper(&quot;jni_GetSubElementSelector&quot;);
3546 
3547   oop slct = JNIHandles::resolve_non_null(selector);
3548   if (slct-&gt;klass()-&gt;name() != vmSymbols::jdk_internal_vm_jni_SubElementSelector()) {
3549     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a SubElementSelector&quot;);
3550   }
3551   jboolean isflattened = jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct);
3552   if (!isflattened) {
3553     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;SubElement is not flattened&quot;);
3554   }
3555   oop semirror = jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct);
3556   Klass* k = java_lang_Class::as_Klass(semirror);
3557   if (!k-&gt;is_value()) {
3558     ResourceMark rm;
3559         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;%s is not an inline type&quot;, k-&gt;external_name()));
3560   }
3561   ValueKlass* vk = ValueKlass::cast(k);
3562   assert(vk-&gt;is_initialized(), &quot;If a flattened array has been created, the element klass must have been initialized&quot;);
3563   int field_offset = jfieldIDWorkaround::from_instance_jfieldID(vk, fieldID);
3564   fieldDescriptor fd;
3565   if (!vk-&gt;find_field_from_offset(field_offset, false, &amp;fd)) {
3566     THROW_NULL(vmSymbols::java_lang_NoSuchFieldError());
3567   }
3568   Handle arrayElementMirror(THREAD, jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct));
3569   // offset of the SubElement is offset of the original SubElement plus the offset of the field inside the element
3570   int offset = fd.offset() - vk-&gt;first_field_offset() + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3571   InstanceKlass* sesklass = InstanceKlass::cast(JNIHandles::resolve_non_null(selector)-&gt;klass());
3572   oop res = sesklass-&gt;allocate_instance(CHECK_NULL);
3573   Handle res_h(THREAD, res);
3574   jdk_internal_vm_jni_SubElementSelector::setArrayElementType(res_h(), arrayElementMirror());
3575   InstanceKlass* holder = fd.field_holder();
3576   BasicType bt = Signature::basic_type(fd.signature());
3577   if (is_java_primitive(bt)) {
3578     jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(), java_lang_Class::primitive_mirror(bt));
3579   } else {
3580     Klass* fieldKlass = SystemDictionary::resolve_or_fail(fd.signature(), Handle(THREAD, holder-&gt;class_loader()),
3581         Handle(THREAD, holder-&gt;protection_domain()), true, CHECK_NULL);
3582     jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(),fieldKlass-&gt;java_mirror());
3583   }
3584   jdk_internal_vm_jni_SubElementSelector::setOffset(res_h(), offset);
3585   jdk_internal_vm_jni_SubElementSelector::setIsFlattened(res_h(), fd.is_flattened());
3586   jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(res_h(), fd.is_flattenable());
3587   return JNIHandles::make_local(res_h());
3588 JNI_END
3589 
3590 JNI_ENTRY(jobject, jni_GetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index))
3591   JNIWrapper(&quot;jni_GetObjectSubElement&quot;);
3592 
3593   valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);
3594   oop slct = JNIHandles::resolve_non_null(selector);
3595   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());
3596   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) {
3597     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;);
3598   }
3599   oop res = NULL;
3600   if (!jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct)) {
3601     int offset = (address)ar-&gt;base() - cast_from_oop&lt;address&gt;(ar) + index * vak-&gt;element_byte_size()
3602                       + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3603     res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(ar, offset);
3604   } else {
3605     ValueKlass* fieldKlass = ValueKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));
3606     res = fieldKlass-&gt;allocate_instance(CHECK_NULL);
3607     // The array might have been moved by the GC, refreshing the arrayOop
3608     ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);
3609     address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper())
3610               + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3611     fieldKlass-&gt;value_copy_payload_to_new_oop(addr, res);
3612   }
3613   return JNIHandles::make_local(res);
3614 JNI_END
3615 
3616 JNI_ENTRY(void, jni_SetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index, jobject value))
3617   JNIWrapper(&quot;jni_SetObjectSubElement&quot;);
3618 
3619   valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);
3620   oop slct = JNIHandles::resolve_non_null(selector);
3621   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());
3622   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) {
3623     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;);
3624   }
3625   oop val = JNIHandles::resolve(value);
3626   if (val == NULL) {
3627     if (jdk_internal_vm_jni_SubElementSelector::getIsFlattenable(slct)) {
3628       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), &quot;null cannot be stored in a flattened array&quot;);
3629     }
3630   } else {
3631     if (!val-&gt;is_a(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)))) {
3632       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), &quot;type mismatch&quot;);
3633     }
3634   }
3635   if (!jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct)) {
3636     int offset = (address)ar-&gt;base() - cast_from_oop&lt;address&gt;(ar) + index * vak-&gt;element_byte_size()
3637                   + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3638     HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(ar, offset, JNIHandles::resolve(value));
3639   } else {
3640     ValueKlass* fieldKlass = ValueKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));
3641     address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper())
3642                   + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3643     fieldKlass-&gt;value_copy_oop_to_payload(JNIHandles::resolve_non_null(value), addr);
3644   }
3645 JNI_END
3646 
3647 #define DEFINE_GETSUBELEMENT(ElementType,Result,ElementBasicType) \
3648 \
3649 JNI_ENTRY(ElementType, \
3650           jni_Get##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index)) \
3651   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;SubElement&quot;); \
3652   valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \
3653   oop slct = JNIHandles::resolve_non_null(selector); \
3654   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass()); \
3655   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) { \
3656     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;); \
3657   } \
3658   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \
3659     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong SubElement type&quot;); \
3660   } \
3661   address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper()) \
3662                + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \
3663   ElementType result = *(ElementType*)addr; \
3664   return result; \
3665 JNI_END
3666 
3667 DEFINE_GETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)
3668 DEFINE_GETSUBELEMENT(jbyte, Byte, T_BYTE)
3669 DEFINE_GETSUBELEMENT(jshort, Short,T_SHORT)
3670 DEFINE_GETSUBELEMENT(jchar, Char,T_CHAR)
3671 DEFINE_GETSUBELEMENT(jint, Int,T_INT)
3672 DEFINE_GETSUBELEMENT(jlong, Long,T_LONG)
3673 DEFINE_GETSUBELEMENT(jfloat, Float,T_FLOAT)
3674 DEFINE_GETSUBELEMENT(jdouble, Double,T_DOUBLE)
3675 
3676 #define DEFINE_SETSUBELEMENT(ElementType,Result,ElementBasicType) \
3677 \
3678 JNI_ENTRY(void, \
3679           jni_Set##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index, ElementType value)) \
3680   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;SubElement&quot;); \
3681   valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \
3682   oop slct = JNIHandles::resolve_non_null(selector); \
3683   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass()); \
3684   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) { \
3685     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;); \
3686   } \
3687   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \
3688     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong SubElement type&quot;); \
3689   } \
3690   address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper()) \
3691                + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \
3692   *(ElementType*)addr = value; \
3693 JNI_END
3694 
3695 DEFINE_SETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)
3696 DEFINE_SETSUBELEMENT(jbyte, Byte, T_BYTE)
3697 DEFINE_SETSUBELEMENT(jshort, Short,T_SHORT)
3698 DEFINE_SETSUBELEMENT(jchar, Char,T_CHAR)
3699 DEFINE_SETSUBELEMENT(jint, Int,T_INT)
3700 DEFINE_SETSUBELEMENT(jlong, Long,T_LONG)
3701 DEFINE_SETSUBELEMENT(jfloat, Float,T_FLOAT)
3702 DEFINE_SETSUBELEMENT(jdouble, Double,T_DOUBLE)
3703 
3704 // Structure containing all jni functions
3705 struct JNINativeInterface_ jni_NativeInterface = {
3706     NULL,
3707     NULL,
3708     NULL,
3709 
3710     NULL,
3711 
3712     jni_GetVersion,
3713 
3714     jni_DefineClass,
3715     jni_FindClass,
3716 
3717     jni_FromReflectedMethod,
3718     jni_FromReflectedField,
3719 
3720     jni_ToReflectedMethod,
3721 
3722     jni_GetSuperclass,
3723     jni_IsAssignableFrom,
3724 
3725     jni_ToReflectedField,
3726 
3727     jni_Throw,
3728     jni_ThrowNew,
3729     jni_ExceptionOccurred,
3730     jni_ExceptionDescribe,
3731     jni_ExceptionClear,
3732     jni_FatalError,
3733 
3734     jni_PushLocalFrame,
3735     jni_PopLocalFrame,
3736 
3737     jni_NewGlobalRef,
3738     jni_DeleteGlobalRef,
3739     jni_DeleteLocalRef,
3740     jni_IsSameObject,
3741 
3742     jni_NewLocalRef,
3743     jni_EnsureLocalCapacity,
3744 
3745     jni_AllocObject,
3746     jni_NewObject,
3747     jni_NewObjectV,
3748     jni_NewObjectA,
3749 
3750     jni_GetObjectClass,
3751     jni_IsInstanceOf,
3752 
3753     jni_GetMethodID,
3754 
3755     jni_CallObjectMethod,
3756     jni_CallObjectMethodV,
3757     jni_CallObjectMethodA,
3758     jni_CallBooleanMethod,
3759     jni_CallBooleanMethodV,
3760     jni_CallBooleanMethodA,
3761     jni_CallByteMethod,
3762     jni_CallByteMethodV,
3763     jni_CallByteMethodA,
3764     jni_CallCharMethod,
3765     jni_CallCharMethodV,
3766     jni_CallCharMethodA,
3767     jni_CallShortMethod,
3768     jni_CallShortMethodV,
3769     jni_CallShortMethodA,
3770     jni_CallIntMethod,
3771     jni_CallIntMethodV,
3772     jni_CallIntMethodA,
3773     jni_CallLongMethod,
3774     jni_CallLongMethodV,
3775     jni_CallLongMethodA,
3776     jni_CallFloatMethod,
3777     jni_CallFloatMethodV,
3778     jni_CallFloatMethodA,
3779     jni_CallDoubleMethod,
3780     jni_CallDoubleMethodV,
3781     jni_CallDoubleMethodA,
3782     jni_CallVoidMethod,
3783     jni_CallVoidMethodV,
3784     jni_CallVoidMethodA,
3785 
3786     jni_CallNonvirtualObjectMethod,
3787     jni_CallNonvirtualObjectMethodV,
3788     jni_CallNonvirtualObjectMethodA,
3789     jni_CallNonvirtualBooleanMethod,
3790     jni_CallNonvirtualBooleanMethodV,
3791     jni_CallNonvirtualBooleanMethodA,
3792     jni_CallNonvirtualByteMethod,
3793     jni_CallNonvirtualByteMethodV,
3794     jni_CallNonvirtualByteMethodA,
3795     jni_CallNonvirtualCharMethod,
3796     jni_CallNonvirtualCharMethodV,
3797     jni_CallNonvirtualCharMethodA,
3798     jni_CallNonvirtualShortMethod,
3799     jni_CallNonvirtualShortMethodV,
3800     jni_CallNonvirtualShortMethodA,
3801     jni_CallNonvirtualIntMethod,
3802     jni_CallNonvirtualIntMethodV,
3803     jni_CallNonvirtualIntMethodA,
3804     jni_CallNonvirtualLongMethod,
3805     jni_CallNonvirtualLongMethodV,
3806     jni_CallNonvirtualLongMethodA,
3807     jni_CallNonvirtualFloatMethod,
3808     jni_CallNonvirtualFloatMethodV,
3809     jni_CallNonvirtualFloatMethodA,
3810     jni_CallNonvirtualDoubleMethod,
3811     jni_CallNonvirtualDoubleMethodV,
3812     jni_CallNonvirtualDoubleMethodA,
3813     jni_CallNonvirtualVoidMethod,
3814     jni_CallNonvirtualVoidMethodV,
3815     jni_CallNonvirtualVoidMethodA,
3816 
3817     jni_GetFieldID,
3818 
3819     jni_GetObjectField,
3820     jni_GetBooleanField,
3821     jni_GetByteField,
3822     jni_GetCharField,
3823     jni_GetShortField,
3824     jni_GetIntField,
3825     jni_GetLongField,
3826     jni_GetFloatField,
3827     jni_GetDoubleField,
3828 
3829     jni_SetObjectField,
3830     jni_SetBooleanField,
3831     jni_SetByteField,
3832     jni_SetCharField,
3833     jni_SetShortField,
3834     jni_SetIntField,
3835     jni_SetLongField,
3836     jni_SetFloatField,
3837     jni_SetDoubleField,
3838 
3839     jni_GetStaticMethodID,
3840 
3841     jni_CallStaticObjectMethod,
3842     jni_CallStaticObjectMethodV,
3843     jni_CallStaticObjectMethodA,
3844     jni_CallStaticBooleanMethod,
3845     jni_CallStaticBooleanMethodV,
3846     jni_CallStaticBooleanMethodA,
3847     jni_CallStaticByteMethod,
3848     jni_CallStaticByteMethodV,
3849     jni_CallStaticByteMethodA,
3850     jni_CallStaticCharMethod,
3851     jni_CallStaticCharMethodV,
3852     jni_CallStaticCharMethodA,
3853     jni_CallStaticShortMethod,
3854     jni_CallStaticShortMethodV,
3855     jni_CallStaticShortMethodA,
3856     jni_CallStaticIntMethod,
3857     jni_CallStaticIntMethodV,
3858     jni_CallStaticIntMethodA,
3859     jni_CallStaticLongMethod,
3860     jni_CallStaticLongMethodV,
3861     jni_CallStaticLongMethodA,
3862     jni_CallStaticFloatMethod,
3863     jni_CallStaticFloatMethodV,
3864     jni_CallStaticFloatMethodA,
3865     jni_CallStaticDoubleMethod,
3866     jni_CallStaticDoubleMethodV,
3867     jni_CallStaticDoubleMethodA,
3868     jni_CallStaticVoidMethod,
3869     jni_CallStaticVoidMethodV,
3870     jni_CallStaticVoidMethodA,
3871 
3872     jni_GetStaticFieldID,
3873 
3874     jni_GetStaticObjectField,
3875     jni_GetStaticBooleanField,
3876     jni_GetStaticByteField,
3877     jni_GetStaticCharField,
3878     jni_GetStaticShortField,
3879     jni_GetStaticIntField,
3880     jni_GetStaticLongField,
3881     jni_GetStaticFloatField,
3882     jni_GetStaticDoubleField,
3883 
3884     jni_SetStaticObjectField,
3885     jni_SetStaticBooleanField,
3886     jni_SetStaticByteField,
3887     jni_SetStaticCharField,
3888     jni_SetStaticShortField,
3889     jni_SetStaticIntField,
3890     jni_SetStaticLongField,
3891     jni_SetStaticFloatField,
3892     jni_SetStaticDoubleField,
3893 
3894     jni_NewString,
3895     jni_GetStringLength,
3896     jni_GetStringChars,
3897     jni_ReleaseStringChars,
3898 
3899     jni_NewStringUTF,
3900     jni_GetStringUTFLength,
3901     jni_GetStringUTFChars,
3902     jni_ReleaseStringUTFChars,
3903 
3904     jni_GetArrayLength,
3905 
3906     jni_NewObjectArray,
3907     jni_GetObjectArrayElement,
3908     jni_SetObjectArrayElement,
3909 
3910     jni_NewBooleanArray,
3911     jni_NewByteArray,
3912     jni_NewCharArray,
3913     jni_NewShortArray,
3914     jni_NewIntArray,
3915     jni_NewLongArray,
3916     jni_NewFloatArray,
3917     jni_NewDoubleArray,
3918 
3919     jni_GetBooleanArrayElements,
3920     jni_GetByteArrayElements,
3921     jni_GetCharArrayElements,
3922     jni_GetShortArrayElements,
3923     jni_GetIntArrayElements,
3924     jni_GetLongArrayElements,
3925     jni_GetFloatArrayElements,
3926     jni_GetDoubleArrayElements,
3927 
3928     jni_ReleaseBooleanArrayElements,
3929     jni_ReleaseByteArrayElements,
3930     jni_ReleaseCharArrayElements,
3931     jni_ReleaseShortArrayElements,
3932     jni_ReleaseIntArrayElements,
3933     jni_ReleaseLongArrayElements,
3934     jni_ReleaseFloatArrayElements,
3935     jni_ReleaseDoubleArrayElements,
3936 
3937     jni_GetBooleanArrayRegion,
3938     jni_GetByteArrayRegion,
3939     jni_GetCharArrayRegion,
3940     jni_GetShortArrayRegion,
3941     jni_GetIntArrayRegion,
3942     jni_GetLongArrayRegion,
3943     jni_GetFloatArrayRegion,
3944     jni_GetDoubleArrayRegion,
3945 
3946     jni_SetBooleanArrayRegion,
3947     jni_SetByteArrayRegion,
3948     jni_SetCharArrayRegion,
3949     jni_SetShortArrayRegion,
3950     jni_SetIntArrayRegion,
3951     jni_SetLongArrayRegion,
3952     jni_SetFloatArrayRegion,
3953     jni_SetDoubleArrayRegion,
3954 
3955     jni_RegisterNatives,
3956     jni_UnregisterNatives,
3957 
3958     jni_MonitorEnter,
3959     jni_MonitorExit,
3960 
3961     jni_GetJavaVM,
3962 
3963     jni_GetStringRegion,
3964     jni_GetStringUTFRegion,
3965 
3966     jni_GetPrimitiveArrayCritical,
3967     jni_ReleasePrimitiveArrayCritical,
3968 
3969     jni_GetStringCritical,
3970     jni_ReleaseStringCritical,
3971 
3972     jni_NewWeakGlobalRef,
3973     jni_DeleteWeakGlobalRef,
3974 
3975     jni_ExceptionCheck,
3976 
3977     jni_NewDirectByteBuffer,
3978     jni_GetDirectBufferAddress,
3979     jni_GetDirectBufferCapacity,
3980 
3981     // New 1_6 features
3982 
3983     jni_GetObjectRefType,
3984 
3985     // Module features
3986 
3987     jni_GetModule,
3988 
3989     // Flattened arrays features
3990 
3991     jni_GetFlattenedArrayElements,
3992     jni_ReleaseFlattenedArrayElements,
3993     jni_GetFlattenedArrayElementClass,
3994     jni_GetFlattenedArrayElementSize,
3995     jni_GetFieldOffsetInFlattenedLayout,
3996 
3997     jni_CreateSubElementSelector,
3998     jni_GetSubElementSelector,
3999     jni_GetObjectSubElement,
4000     jni_SetObjectSubElement,
4001 
4002     jni_GetBooleanSubElement,
4003     jni_GetByteSubElement,
4004     jni_GetShortSubElement,
4005     jni_GetCharSubElement,
4006     jni_GetIntSubElement,
4007     jni_GetLongSubElement,
4008     jni_GetFloatSubElement,
4009     jni_GetDoubleSubElement,
4010 
4011     jni_SetBooleanSubElement,
4012     jni_SetByteSubElement,
4013     jni_SetShortSubElement,
4014     jni_SetCharSubElement,
4015     jni_SetIntSubElement,
4016     jni_SetLongSubElement,
4017     jni_SetFloatSubElement,
4018     jni_SetDoubleSubElement
4019 };
4020 
4021 
4022 // For jvmti use to modify jni function table.
4023 // Java threads in native contiues to run until it is transitioned
4024 // to VM at safepoint. Before the transition or before it is blocked
4025 // for safepoint it may access jni function table. VM could crash if
4026 // any java thread access the jni function table in the middle of memcpy.
4027 // To avoid this each function pointers are copied automically.
4028 void copy_jni_function_table(const struct JNINativeInterface_ *new_jni_NativeInterface) {
4029   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
4030   intptr_t *a = (intptr_t *) jni_functions();
4031   intptr_t *b = (intptr_t *) new_jni_NativeInterface;
4032   for (uint i=0; i &lt;  sizeof(struct JNINativeInterface_)/sizeof(void *); i++) {
4033     Atomic::store(a++, *b++);
4034   }
4035 }
4036 
4037 void quicken_jni_functions() {
4038   // Replace Get&lt;Primitive&gt;Field with fast versions
4039   if (UseFastJNIAccessors &amp;&amp; !VerifyJNIFields &amp;&amp; !CountJNICalls &amp;&amp; !CheckJNICalls) {
4040     address func;
4041     func = JNI_FastGetField::generate_fast_get_boolean_field();
4042     if (func != (address)-1) {
4043       jni_NativeInterface.GetBooleanField = (GetBooleanField_t)func;
4044     }
4045     func = JNI_FastGetField::generate_fast_get_byte_field();
4046     if (func != (address)-1) {
4047       jni_NativeInterface.GetByteField = (GetByteField_t)func;
4048     }
4049     func = JNI_FastGetField::generate_fast_get_char_field();
4050     if (func != (address)-1) {
4051       jni_NativeInterface.GetCharField = (GetCharField_t)func;
4052     }
4053     func = JNI_FastGetField::generate_fast_get_short_field();
4054     if (func != (address)-1) {
4055       jni_NativeInterface.GetShortField = (GetShortField_t)func;
4056     }
4057     func = JNI_FastGetField::generate_fast_get_int_field();
4058     if (func != (address)-1) {
4059       jni_NativeInterface.GetIntField = (GetIntField_t)func;
4060     }
4061     func = JNI_FastGetField::generate_fast_get_long_field();
4062     if (func != (address)-1) {
4063       jni_NativeInterface.GetLongField = (GetLongField_t)func;
4064     }
4065     func = JNI_FastGetField::generate_fast_get_float_field();
4066     if (func != (address)-1) {
4067       jni_NativeInterface.GetFloatField = (GetFloatField_t)func;
4068     }
4069     func = JNI_FastGetField::generate_fast_get_double_field();
4070     if (func != (address)-1) {
4071       jni_NativeInterface.GetDoubleField = (GetDoubleField_t)func;
4072     }
4073   }
4074 }
4075 
4076 // Returns the function structure
4077 struct JNINativeInterface_* jni_functions() {
4078 #if INCLUDE_JNI_CHECK
4079   if (CheckJNICalls) return jni_functions_check();
4080 #endif // INCLUDE_JNI_CHECK
4081   return &amp;jni_NativeInterface;
4082 }
4083 
4084 // Returns the function structure
4085 struct JNINativeInterface_* jni_functions_nocheck() {
4086   return &amp;jni_NativeInterface;
4087 }
4088 
4089 static void post_thread_start_event(const JavaThread* jt) {
4090   assert(jt != NULL, &quot;invariant&quot;);
4091   EventThreadStart event;
4092   if (event.should_commit()) {
4093     event.set_thread(JFR_THREAD_ID(jt));
4094     event.set_parentThread((traceid)0);
4095 #if INCLUDE_JFR
4096     if (EventThreadStart::is_stacktrace_enabled()) {
4097       jt-&gt;jfr_thread_local()-&gt;set_cached_stack_trace_id((traceid)0);
4098       event.commit();
4099       jt-&gt;jfr_thread_local()-&gt;clear_cached_stack_trace();
4100     } else
4101 #endif
4102     {
4103       event.commit();
4104     }
4105   }
4106 }
4107 
4108 // Invocation API
4109 
4110 
4111 // Forward declaration
4112 extern const struct JNIInvokeInterface_ jni_InvokeInterface;
4113 
4114 // Global invocation API vars
4115 volatile int vm_created = 0;
<a name="7" id="anc7"></a><span class="line-modified">4116 // Indicate whether it is safe to recreate VM. Recreation is only</span>
<span class="line-added">4117 // possible after a failed initial creation attempt in some cases.</span>
4118 volatile int safe_to_recreate_vm = 1;
4119 struct JavaVM_ main_vm = {&amp;jni_InvokeInterface};
4120 
4121 
4122 #define JAVASTACKSIZE (400 * 1024)    /* Default size of a thread java stack */
4123 enum { VERIFY_NONE, VERIFY_REMOTE, VERIFY_ALL };
4124 
4125 DT_RETURN_MARK_DECL(GetDefaultJavaVMInitArgs, jint
4126                     , HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_RETURN(_ret_ref));
4127 
4128 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args_) {
4129   HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_ENTRY(args_);
4130   JDK1_1InitArgs *args = (JDK1_1InitArgs *)args_;
4131   jint ret = JNI_ERR;
4132   DT_RETURN_MARK(GetDefaultJavaVMInitArgs, jint, (const jint&amp;)ret);
4133 
4134   if (Threads::is_supported_jni_version(args-&gt;version)) {
4135     ret = JNI_OK;
4136   }
4137   // 1.1 style no longer supported in hotspot.
4138   // According the JNI spec, we should update args-&gt;version on return.
4139   // We also use the structure to communicate with launcher about default
4140   // stack size.
4141   if (args-&gt;version == JNI_VERSION_1_1) {
4142     args-&gt;version = JNI_VERSION_1_2;
4143     // javaStackSize is int in arguments structure
4144     assert(jlong(ThreadStackSize) * K &lt; INT_MAX, &quot;integer overflow&quot;);
4145     args-&gt;javaStackSize = (jint)(ThreadStackSize * K);
4146   }
4147   return ret;
4148 }
4149 
4150 DT_RETURN_MARK_DECL(CreateJavaVM, jint
4151                     , HOTSPOT_JNI_CREATEJAVAVM_RETURN(_ret_ref));
4152 
4153 static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) {
4154   HOTSPOT_JNI_CREATEJAVAVM_ENTRY((void **) vm, penv, args);
4155 
4156   jint result = JNI_ERR;
4157   DT_RETURN_MARK(CreateJavaVM, jint, (const jint&amp;)result);
4158 
4159   // We&#39;re about to use Atomic::xchg for synchronization.  Some Zero
4160   // platforms use the GCC builtin __sync_lock_test_and_set for this,
4161   // but __sync_lock_test_and_set is not guaranteed to do what we want
4162   // on all architectures.  So we check it works before relying on it.
4163 #if defined(ZERO) &amp;&amp; defined(ASSERT)
4164   {
4165     jint a = 0xcafebabe;
4166     jint b = Atomic::xchg(&amp;a, (jint) 0xdeadbeef);
4167     void *c = &amp;a;
4168     void *d = Atomic::xchg(&amp;c, &amp;b);
4169     assert(a == (jint) 0xdeadbeef &amp;&amp; b == (jint) 0xcafebabe, &quot;Atomic::xchg() works&quot;);
4170     assert(c == &amp;b &amp;&amp; d == &amp;a, &quot;Atomic::xchg() works&quot;);
4171   }
4172 #endif // ZERO &amp;&amp; ASSERT
4173 
4174   // At the moment it&#39;s only possible to have one Java VM,
4175   // since some of the runtime state is in global variables.
4176 
4177   // We cannot use our mutex locks here, since they only work on
4178   // Threads. We do an atomic compare and exchange to ensure only
4179   // one thread can call this method at a time
4180 
4181   // We use Atomic::xchg rather than Atomic::add/dec since on some platforms
4182   // the add/dec implementations are dependent on whether we are running
4183   // on a multiprocessor Atomic::xchg does not have this problem.
4184   if (Atomic::xchg(&amp;vm_created, 1) == 1) {
4185     return JNI_EEXIST;   // already created, or create attempt in progress
4186   }
<a name="8" id="anc8"></a><span class="line-added">4187 </span>
<span class="line-added">4188   // If a previous creation attempt failed but can be retried safely,</span>
<span class="line-added">4189   // then safe_to_recreate_vm will have been reset to 1 after being</span>
<span class="line-added">4190   // cleared here. If a previous creation attempt succeeded and we then</span>
<span class="line-added">4191   // destroyed that VM, we will be prevented from trying to recreate</span>
<span class="line-added">4192   // the VM in the same process, as the value will still be 0.</span>
4193   if (Atomic::xchg(&amp;safe_to_recreate_vm, 0) == 0) {
<a name="9" id="anc9"></a><span class="line-modified">4194     return JNI_ERR;</span>
4195   }
4196 
4197   assert(vm_created == 1, &quot;vm_created is true during the creation&quot;);
4198 
4199   /**
4200    * Certain errors during initialization are recoverable and do not
4201    * prevent this method from being called again at a later time
4202    * (perhaps with different arguments).  However, at a certain
4203    * point during initialization if an error occurs we cannot allow
4204    * this function to be called again (or it will crash).  In those
4205    * situations, the &#39;canTryAgain&#39; flag is set to false, which atomically
4206    * sets safe_to_recreate_vm to 1, such that any new call to
4207    * JNI_CreateJavaVM will immediately fail using the above logic.
4208    */
4209   bool can_try_again = true;
4210 
4211   result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again);
4212   if (result == JNI_OK) {
4213     JavaThread *thread = JavaThread::current();
4214     assert(!thread-&gt;has_pending_exception(), &quot;should have returned not OK&quot;);
4215     /* thread is thread_in_vm here */
4216     *vm = (JavaVM *)(&amp;main_vm);
4217     *(JNIEnv**)penv = thread-&gt;jni_environment();
4218 
4219 #if INCLUDE_JVMCI
4220     if (EnableJVMCI) {
4221       if (UseJVMCICompiler) {
4222         // JVMCI is initialized on a CompilerThread
4223         if (BootstrapJVMCI) {
4224           JavaThread* THREAD = thread;
4225           JVMCICompiler* compiler = JVMCICompiler::instance(true, CATCH);
4226           compiler-&gt;bootstrap(THREAD);
4227           if (HAS_PENDING_EXCEPTION) {
4228             HandleMark hm;
4229             vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
4230           }
4231         }
4232       }
4233     }
4234 #endif
4235 
4236     // Notify JVMTI
4237     if (JvmtiExport::should_post_thread_life()) {
4238        JvmtiExport::post_thread_start(thread);
4239     }
4240 
4241     post_thread_start_event(thread);
4242 
4243 #ifndef PRODUCT
4244     if (ReplayCompiles) ciReplay::replay(thread);
4245 
4246     // Some platforms (like Win*) need a wrapper around these test
4247     // functions in order to properly handle error conditions.
4248     VMError::test_error_handler();
4249 #endif
4250 
4251     // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
4252     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4253   } else {
4254     // If create_vm exits because of a pending exception, exit with that
4255     // exception.  In the future when we figure out how to reclaim memory,
4256     // we may be able to exit with JNI_ERR and allow the calling application
4257     // to continue.
4258     if (Universe::is_fully_initialized()) {
4259       // otherwise no pending exception possible - VM will already have aborted
4260       JavaThread* THREAD = JavaThread::current();
4261       if (HAS_PENDING_EXCEPTION) {
4262         HandleMark hm;
4263         vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
4264       }
4265     }
4266 
4267     if (can_try_again) {
4268       // reset safe_to_recreate_vm to 1 so that retrial would be possible
4269       safe_to_recreate_vm = 1;
4270     }
4271 
4272     // Creation failed. We must reset vm_created
4273     *vm = 0;
4274     *(JNIEnv**)penv = 0;
4275     // reset vm_created last to avoid race condition. Use OrderAccess to
4276     // control both compiler and architectural-based reordering.
4277     Atomic::release_store(&amp;vm_created, 0);
4278   }
4279 
4280   // Flush stdout and stderr before exit.
4281   fflush(stdout);
4282   fflush(stderr);
4283 
4284   return result;
4285 
4286 }
4287 
4288 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) {
4289   jint result = JNI_ERR;
4290   // On Windows, let CreateJavaVM run with SEH protection
4291 #ifdef _WIN32
4292   __try {
4293 #endif
4294     result = JNI_CreateJavaVM_inner(vm, penv, args);
4295 #ifdef _WIN32
4296   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
4297     // Nothing to do.
4298   }
4299 #endif
4300   return result;
4301 }
4302 
4303 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetCreatedJavaVMs(JavaVM **vm_buf, jsize bufLen, jsize *numVMs) {
4304   // See bug 4367188, the wrapper can sometimes cause VM crashes
4305   // JNIWrapper(&quot;GetCreatedJavaVMs&quot;);
4306 
4307   HOTSPOT_JNI_GETCREATEDJAVAVMS_ENTRY((void **) vm_buf, bufLen, (uintptr_t *) numVMs);
4308 
4309   if (vm_created == 1) {
4310     if (numVMs != NULL) *numVMs = 1;
4311     if (bufLen &gt; 0)     *vm_buf = (JavaVM *)(&amp;main_vm);
4312   } else {
4313     if (numVMs != NULL) *numVMs = 0;
4314   }
4315   HOTSPOT_JNI_GETCREATEDJAVAVMS_RETURN(JNI_OK);
4316   return JNI_OK;
4317 }
4318 
4319 extern &quot;C&quot; {
4320 
4321 DT_RETURN_MARK_DECL(DestroyJavaVM, jint
4322                     , HOTSPOT_JNI_DESTROYJAVAVM_RETURN(_ret_ref));
4323 
4324 static jint JNICALL jni_DestroyJavaVM_inner(JavaVM *vm) {
4325   HOTSPOT_JNI_DESTROYJAVAVM_ENTRY(vm);
4326   jint res = JNI_ERR;
4327   DT_RETURN_MARK(DestroyJavaVM, jint, (const jint&amp;)res);
4328 
4329   if (vm_created == 0) {
4330     res = JNI_ERR;
4331     return res;
4332   }
4333 
4334   JNIWrapper(&quot;DestroyJavaVM&quot;);
4335   JNIEnv *env;
4336   JavaVMAttachArgs destroyargs;
4337   destroyargs.version = CurrentVersion;
4338   destroyargs.name = (char *)&quot;DestroyJavaVM&quot;;
4339   destroyargs.group = NULL;
4340   res = vm-&gt;AttachCurrentThread((void **)&amp;env, (void *)&amp;destroyargs);
4341   if (res != JNI_OK) {
4342     return res;
4343   }
4344 
4345   // Since this is not a JVM_ENTRY we have to set the thread state manually before entering.
4346   JavaThread* thread = JavaThread::current();
4347   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4348   if (Threads::destroy_vm()) {
4349     // Should not change thread state, VM is gone
4350     vm_created = 0;
4351     res = JNI_OK;
4352     return res;
4353   } else {
4354     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4355     res = JNI_ERR;
4356     return res;
4357   }
4358 }
4359 
4360 jint JNICALL jni_DestroyJavaVM(JavaVM *vm) {
4361   jint result = JNI_ERR;
4362   // On Windows, we need SEH protection
4363 #ifdef _WIN32
4364   __try {
4365 #endif
4366     result = jni_DestroyJavaVM_inner(vm);
4367 #ifdef _WIN32
4368   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
4369     // Nothing to do.
4370   }
4371 #endif
4372   return result;
4373 }
4374 
4375 static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool daemon) {
4376   JavaVMAttachArgs *args = (JavaVMAttachArgs *) _args;
4377 
4378   // Check below commented out from JDK1.2fcs as well
4379   /*
4380   if (args &amp;&amp; (args-&gt;version != JNI_VERSION_1_1 || args-&gt;version != JNI_VERSION_1_2)) {
4381     return JNI_EVERSION;
4382   }
4383   */
4384 
4385   Thread* t = Thread::current_or_null();
4386   if (t != NULL) {
<a name="10" id="anc10"></a><span class="line-modified">4387     // If executing from an atexit hook we may be in the VMThread.</span>
<span class="line-modified">4388     if (t-&gt;is_Java_thread()) {</span>
<span class="line-modified">4389       // If the thread has been attached this operation is a no-op</span>
<span class="line-added">4390       *(JNIEnv**)penv = ((JavaThread*) t)-&gt;jni_environment();</span>
<span class="line-added">4391       return JNI_OK;</span>
<span class="line-added">4392     } else {</span>
<span class="line-added">4393       return JNI_ERR;</span>
<span class="line-added">4394     }</span>
4395   }
4396 
4397   // Create a thread and mark it as attaching so it will be skipped by the
4398   // ThreadsListEnumerator - see CR 6404306
4399   JavaThread* thread = new JavaThread(true);
4400 
4401   // Set correct safepoint info. The thread is going to call into Java when
4402   // initializing the Java level thread object. Hence, the correct state must
4403   // be set in order for the Safepoint code to deal with it correctly.
4404   thread-&gt;set_thread_state(_thread_in_vm);
4405   thread-&gt;record_stack_base_and_size();
4406   thread-&gt;register_thread_stack_with_NMT();
4407   thread-&gt;initialize_thread_current();
4408 
4409   if (!os::create_attached_thread(thread)) {
4410     thread-&gt;smr_delete();
4411     return JNI_ERR;
4412   }
4413   // Enable stack overflow checks
4414   thread-&gt;create_stack_guard_pages();
4415 
4416   thread-&gt;initialize_tlab();
4417 
4418   thread-&gt;cache_global_variables();
4419 
4420   // This thread will not do a safepoint check, since it has
4421   // not been added to the Thread list yet.
4422   { MutexLocker ml(Threads_lock);
4423     // This must be inside this lock in order to get FullGCALot to work properly, i.e., to
4424     // avoid this thread trying to do a GC before it is added to the thread-list
4425     thread-&gt;set_active_handles(JNIHandleBlock::allocate_block());
4426     Threads::add(thread, daemon);
4427   }
4428   // Create thread group and name info from attach arguments
4429   oop group = NULL;
4430   char* thread_name = NULL;
4431   if (args != NULL &amp;&amp; Threads::is_supported_jni_version(args-&gt;version)) {
4432     group = JNIHandles::resolve(args-&gt;group);
4433     thread_name = args-&gt;name; // may be NULL
4434   }
4435   if (group == NULL) group = Universe::main_thread_group();
4436 
4437   // Create Java level thread object and attach it to this thread
4438   bool attach_failed = false;
4439   {
4440     EXCEPTION_MARK;
4441     HandleMark hm(THREAD);
4442     Handle thread_group(THREAD, group);
4443     thread-&gt;allocate_threadObj(thread_group, thread_name, daemon, THREAD);
4444     if (HAS_PENDING_EXCEPTION) {
4445       CLEAR_PENDING_EXCEPTION;
4446       // cleanup outside the handle mark.
4447       attach_failed = true;
4448     }
4449   }
4450 
4451   if (attach_failed) {
4452     // Added missing cleanup
4453     thread-&gt;cleanup_failed_attach_current_thread(daemon);
4454     return JNI_ERR;
4455   }
4456 
4457   // mark the thread as no longer attaching
4458   // this uses a fence to push the change through so we don&#39;t have
4459   // to regrab the threads_lock
4460   thread-&gt;set_done_attaching_via_jni();
4461 
4462   // Set java thread status.
4463   java_lang_Thread::set_thread_status(thread-&gt;threadObj(),
4464               java_lang_Thread::RUNNABLE);
4465 
4466   // Notify the debugger
4467   if (JvmtiExport::should_post_thread_life()) {
4468     JvmtiExport::post_thread_start(thread);
4469   }
4470 
4471   post_thread_start_event(thread);
4472 
4473   *(JNIEnv**)penv = thread-&gt;jni_environment();
4474 
4475   // Now leaving the VM, so change thread_state. This is normally automatically taken care
4476   // of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by
4477   // using ThreadStateTransition::transition, we do a callback to the safepoint code if
4478   // needed.
4479 
4480   ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4481 
4482   // Perform any platform dependent FPU setup
4483   os::setup_fpu();
4484 
4485   return JNI_OK;
4486 }
4487 
4488 
4489 jint JNICALL jni_AttachCurrentThread(JavaVM *vm, void **penv, void *_args) {
4490   HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(vm, penv, _args);
4491   if (vm_created == 0) {
<a name="11" id="anc11"></a><span class="line-modified">4492     HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);</span>
4493     return JNI_ERR;
4494   }
4495 
4496   JNIWrapper(&quot;AttachCurrentThread&quot;);
4497   jint ret = attach_current_thread(vm, penv, _args, false);
4498   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(ret);
4499   return ret;
4500 }
4501 
4502 
4503 jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
4504   HOTSPOT_JNI_DETACHCURRENTTHREAD_ENTRY(vm);
<a name="12" id="anc12"></a><span class="line-added">4505   if (vm_created == 0) {</span>
<span class="line-added">4506     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_ERR);</span>
<span class="line-added">4507     return JNI_ERR;</span>
<span class="line-added">4508   }</span>
4509 
4510   JNIWrapper(&quot;DetachCurrentThread&quot;);
4511 
<a name="13" id="anc13"></a><span class="line-added">4512   Thread* current = Thread::current_or_null();</span>
<span class="line-added">4513 </span>
4514   // If the thread has already been detached the operation is a no-op
<a name="14" id="anc14"></a><span class="line-modified">4515   if (current == NULL) {</span>
4516     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4517     return JNI_OK;
4518   }
4519 
<a name="15" id="anc15"></a><span class="line-added">4520   // If executing from an atexit hook we may be in the VMThread.</span>
<span class="line-added">4521   if (!current-&gt;is_Java_thread()) {</span>
<span class="line-added">4522     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);</span>
<span class="line-added">4523     return JNI_ERR;</span>
<span class="line-added">4524   }</span>
<span class="line-added">4525 </span>
4526   VM_Exit::block_if_vm_exited();
4527 
<a name="16" id="anc16"></a><span class="line-modified">4528   JavaThread* thread = (JavaThread*) current;</span>
4529   if (thread-&gt;has_last_Java_frame()) {
4530     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4531     // Can&#39;t detach a thread that&#39;s running java, that can&#39;t work.
4532     return JNI_ERR;
4533   }
4534 
4535   // Safepoint support. Have to do call-back to safepoint code, if in the
4536   // middle of a safepoint operation
4537   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4538 
4539   // XXX: Note that JavaThread::exit() call below removes the guards on the
4540   // stack pages set up via enable_stack_{red,yellow}_zone() calls
4541   // above in jni_AttachCurrentThread. Unfortunately, while the setting
4542   // of the guards is visible in jni_AttachCurrentThread above,
4543   // the removal of the guards is buried below in JavaThread::exit()
4544   // here. The abstraction should be more symmetrically either exposed
4545   // or hidden (e.g. it could probably be hidden in the same
4546   // (platform-dependent) methods where we do alternate stack
4547   // maintenance work?)
4548   thread-&gt;exit(false, JavaThread::jni_detach);
4549   thread-&gt;smr_delete();
4550 
4551   HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4552   return JNI_OK;
4553 }
4554 
4555 DT_RETURN_MARK_DECL(GetEnv, jint
4556                     , HOTSPOT_JNI_GETENV_RETURN(_ret_ref));
4557 
4558 jint JNICALL jni_GetEnv(JavaVM *vm, void **penv, jint version) {
4559   HOTSPOT_JNI_GETENV_ENTRY(vm, penv, version);
4560   jint ret = JNI_ERR;
4561   DT_RETURN_MARK(GetEnv, jint, (const jint&amp;)ret);
4562 
4563   if (vm_created == 0) {
4564     *penv = NULL;
4565     ret = JNI_EDETACHED;
4566     return ret;
4567   }
4568 
4569   if (JniExportedInterface::GetExportedInterface(vm, penv, version, &amp;ret)) {
4570     return ret;
4571   }
4572 
4573 #ifndef JVMPI_VERSION_1
4574 // need these in order to be polite about older agents
4575 #define JVMPI_VERSION_1   ((jint)0x10000001)
4576 #define JVMPI_VERSION_1_1 ((jint)0x10000002)
4577 #define JVMPI_VERSION_1_2 ((jint)0x10000003)
4578 #endif // !JVMPI_VERSION_1
4579 
4580   Thread* thread = Thread::current_or_null();
4581   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread()) {
4582     if (Threads::is_supported_jni_version_including_1_1(version)) {
4583       *(JNIEnv**)penv = ((JavaThread*) thread)-&gt;jni_environment();
4584       ret = JNI_OK;
4585       return ret;
4586 
4587     } else if (version == JVMPI_VERSION_1 ||
4588                version == JVMPI_VERSION_1_1 ||
4589                version == JVMPI_VERSION_1_2) {
4590       tty-&gt;print_cr(&quot;ERROR: JVMPI, an experimental interface, is no longer supported.&quot;);
4591       tty-&gt;print_cr(&quot;Please use the supported interface: the JVM Tool Interface (JVM TI).&quot;);
4592       ret = JNI_EVERSION;
4593       return ret;
4594     } else if (JvmtiExport::is_jvmdi_version(version)) {
4595       tty-&gt;print_cr(&quot;FATAL ERROR: JVMDI is no longer supported.&quot;);
4596       tty-&gt;print_cr(&quot;Please use the supported interface: the JVM Tool Interface (JVM TI).&quot;);
4597       ret = JNI_EVERSION;
4598       return ret;
4599     } else {
4600       *penv = NULL;
4601       ret = JNI_EVERSION;
4602       return ret;
4603     }
4604   } else {
4605     *penv = NULL;
4606     ret = JNI_EDETACHED;
4607     return ret;
4608   }
4609 }
4610 
4611 
4612 jint JNICALL jni_AttachCurrentThreadAsDaemon(JavaVM *vm, void **penv, void *_args) {
4613   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_ENTRY(vm, penv, _args);
4614   if (vm_created == 0) {
4615   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN((uint32_t) JNI_ERR);
4616     return JNI_ERR;
4617   }
4618 
4619   JNIWrapper(&quot;AttachCurrentThreadAsDaemon&quot;);
4620   jint ret = attach_current_thread(vm, penv, _args, true);
4621   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN(ret);
4622   return ret;
4623 }
4624 
4625 
4626 } // End extern &quot;C&quot;
4627 
4628 const struct JNIInvokeInterface_ jni_InvokeInterface = {
4629     NULL,
4630     NULL,
4631     NULL,
4632 
4633     jni_DestroyJavaVM,
4634     jni_AttachCurrentThread,
4635     jni_DetachCurrentThread,
4636     jni_GetEnv,
4637     jni_AttachCurrentThreadAsDaemon
4638 };
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
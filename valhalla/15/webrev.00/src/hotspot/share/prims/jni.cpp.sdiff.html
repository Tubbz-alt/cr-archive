<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jni.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../opto/vectornode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jni.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jni.h&quot;
  28 #include &quot;jvm.h&quot;
  29 #include &quot;ci/ciReplay.hpp&quot;
  30 #include &quot;classfile/altHashing.hpp&quot;
  31 #include &quot;classfile/classFileStream.hpp&quot;
  32 #include &quot;classfile/classLoader.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;

  35 #include &quot;classfile/modules.hpp&quot;
  36 #include &quot;classfile/symbolTable.hpp&quot;
  37 #include &quot;classfile/systemDictionary.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  40 #include &quot;interpreter/linkResolver.hpp&quot;
  41 #include &quot;jfr/jfrEvents.hpp&quot;
  42 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/allocation.hpp&quot;
  45 #include &quot;memory/allocation.inline.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/arrayOop.inline.hpp&quot;
  51 #include &quot;oops/instanceKlass.hpp&quot;
  52 #include &quot;oops/instanceOop.hpp&quot;
  53 #include &quot;oops/markWord.hpp&quot;
  54 #include &quot;oops/method.hpp&quot;
</pre>
<hr />
<pre>
 382   }
 383   if ((int)strlen(name) &gt; Symbol::max_length()) {
 384     Exceptions::fthrow(THREAD_AND_LOCATION,
 385                        vmSymbols::java_lang_NoClassDefFoundError(),
 386                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 387                        Symbol::max_length(),
 388                        name);
 389     return 0;
 390   }
 391 
 392   //%note jni_3
 393   Handle protection_domain;
 394   // Find calling class
 395   Klass* k = thread-&gt;security_get_caller_class(0);
 396   // default to the system loader when no context
 397   Handle loader(THREAD, SystemDictionary::java_system_loader());
 398   if (k != NULL) {
 399     // Special handling to make sure JNI_OnLoad and JNI_OnUnload are executed
 400     // in the correct class context.
 401     if (k-&gt;class_loader() == NULL &amp;&amp;
<span class="line-modified"> 402         k-&gt;name() == vmSymbols::java_lang_ClassLoader_NativeLibrary()) {</span>
 403       JavaValue result(T_OBJECT);
 404       JavaCalls::call_static(&amp;result, k,
 405                              vmSymbols::getFromClass_name(),
 406                              vmSymbols::void_class_signature(),
 407                              CHECK_NULL);
<span class="line-modified"> 408       // When invoked from JNI_OnLoad, NativeLibrary::getFromClass returns</span>
 409       // a non-NULL Class object.  When invoked from JNI_OnUnload,
 410       // it will return NULL to indicate no context.
 411       oop mirror = (oop) result.get_jobject();
 412       if (mirror != NULL) {
 413         Klass* fromClass = java_lang_Class::as_Klass(mirror);
 414         loader = Handle(THREAD, fromClass-&gt;class_loader());
 415         protection_domain = Handle(THREAD, fromClass-&gt;protection_domain());
 416       }
 417     } else {
 418       loader = Handle(THREAD, k-&gt;class_loader());
 419     }
 420   }
 421 
 422   TempNewSymbol sym = SymbolTable::new_symbol(name);
 423   result = find_class_from_class_loader(env, sym, true, loader,
 424                                         protection_domain, true, thread);
 425 
 426   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 427     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 428   }
</pre>
<hr />
<pre>
2639      ss.print(&quot;Index %d out of bounds for length %d&quot;, index, arr-&gt;length());
2640      THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2641    }
2642 JNI_END
2643 
2644 
2645 
2646 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
2647                               ,EntryProbe,ReturnProbe)  \
2648 \
2649   DT_RETURN_MARK_DECL(New##Result##Array, Return \
2650                       , ReturnProbe); \
2651 \
2652 JNI_ENTRY(Return, \
2653           jni_New##Result##Array(JNIEnv *env, jsize len)) \
2654   JNIWrapper(&quot;New&quot; XSTR(Result) &quot;Array&quot;); \
2655   EntryProbe; \
2656   Return ret = NULL;\
2657   DT_RETURN_MARK(New##Result##Array, Return, (const Return&amp;)ret);\
2658 \
<span class="line-modified">2659   oop obj= oopFactory::Allocator(len, CHECK_0); \</span>
2660   ret = (Return) JNIHandles::make_local(env, obj); \
2661   return ret;\
2662 JNI_END
2663 
2664 DEFINE_NEWSCALARARRAY(jbooleanArray, new_boolArray,   Boolean,
2665                       HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY(env, len),
2666                       HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN(_ret_ref))
2667 DEFINE_NEWSCALARARRAY(jbyteArray,    new_byteArray,   Byte,
2668                       HOTSPOT_JNI_NEWBYTEARRAY_ENTRY(env, len),
2669                       HOTSPOT_JNI_NEWBYTEARRAY_RETURN(_ret_ref))
2670 DEFINE_NEWSCALARARRAY(jshortArray,   new_shortArray,  Short,
2671                       HOTSPOT_JNI_NEWSHORTARRAY_ENTRY(env, len),
2672                       HOTSPOT_JNI_NEWSHORTARRAY_RETURN(_ret_ref))
2673 DEFINE_NEWSCALARARRAY(jcharArray,    new_charArray,   Char,
2674                       HOTSPOT_JNI_NEWCHARARRAY_ENTRY(env, len),
2675                       HOTSPOT_JNI_NEWCHARARRAY_RETURN(_ret_ref))
2676 DEFINE_NEWSCALARARRAY(jintArray,     new_intArray,    Int,
2677                       HOTSPOT_JNI_NEWINTARRAY_ENTRY(env, len),
2678                       HOTSPOT_JNI_NEWINTARRAY_RETURN(_ret_ref))
2679 DEFINE_NEWSCALARARRAY(jlongArray,    new_longArray,   Long,
</pre>
<hr />
<pre>
2910                             , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2911                             HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
2912 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
2913                             , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2914                             HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
2915 
2916 
2917 DT_RETURN_MARK_DECL(RegisterNatives, jint
2918                     , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
2919 
2920 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
2921                                     const JNINativeMethod *methods,
2922                                     jint nMethods))
2923   JNIWrapper(&quot;RegisterNatives&quot;);
2924   HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
2925   jint ret = 0;
2926   DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
2927 
2928   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2929 
<span class="line-modified">2930   // There are no restrictions on native code registering native methods, which</span>
<span class="line-modified">2931   // allows agents to redefine the bindings to native methods. But we issue a</span>
<span class="line-modified">2932   // warning if any code running outside of the boot/platform loader is rebinding</span>
<span class="line-modified">2933   // any native methods in classes loaded by the boot/platform loader.</span>
<span class="line-modified">2934   Klass* caller = thread-&gt;security_get_caller_class(1);</span>

2935   bool do_warning = false;
<span class="line-modified">2936   oop cl = k-&gt;class_loader();</span>
<span class="line-modified">2937   if (cl ==  NULL || SystemDictionary::is_platform_class_loader(cl)) {</span>
<span class="line-modified">2938     // If no caller class, or caller class has a different loader, then</span>
<span class="line-modified">2939     // issue a warning below.</span>
<span class="line-modified">2940     do_warning = (caller == NULL) || caller-&gt;class_loader() != cl;</span>








2941   }
2942 
2943 
2944   for (int index = 0; index &lt; nMethods; index++) {
2945     const char* meth_name = methods[index].name;
2946     const char* meth_sig = methods[index].signature;
2947     int meth_name_len = (int)strlen(meth_name);
2948 
2949     // The class should have been loaded (we have an instance of the class
2950     // passed in) so the method and signature should already be in the symbol
2951     // table.  If they&#39;re not there, the method doesn&#39;t exist.
2952     TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
2953     TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
2954 
2955     if (name == NULL || signature == NULL) {
2956       ResourceMark rm(THREAD);
2957       stringStream st;
2958       st.print(&quot;Method %s.%s%s not found&quot;, k-&gt;external_name(), meth_name, meth_sig);
2959       // Must return negative value on failure
2960       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
</pre>
<hr />
<pre>
4086     if (EventThreadStart::is_stacktrace_enabled()) {
4087       jt-&gt;jfr_thread_local()-&gt;set_cached_stack_trace_id((traceid)0);
4088       event.commit();
4089       jt-&gt;jfr_thread_local()-&gt;clear_cached_stack_trace();
4090     } else
4091 #endif
4092     {
4093       event.commit();
4094     }
4095   }
4096 }
4097 
4098 // Invocation API
4099 
4100 
4101 // Forward declaration
4102 extern const struct JNIInvokeInterface_ jni_InvokeInterface;
4103 
4104 // Global invocation API vars
4105 volatile int vm_created = 0;
<span class="line-modified">4106 // Indicate whether it is safe to recreate VM</span>

4107 volatile int safe_to_recreate_vm = 1;
4108 struct JavaVM_ main_vm = {&amp;jni_InvokeInterface};
4109 
4110 
4111 #define JAVASTACKSIZE (400 * 1024)    /* Default size of a thread java stack */
4112 enum { VERIFY_NONE, VERIFY_REMOTE, VERIFY_ALL };
4113 
4114 DT_RETURN_MARK_DECL(GetDefaultJavaVMInitArgs, jint
4115                     , HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_RETURN(_ret_ref));
4116 
4117 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args_) {
4118   HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_ENTRY(args_);
4119   JDK1_1InitArgs *args = (JDK1_1InitArgs *)args_;
4120   jint ret = JNI_ERR;
4121   DT_RETURN_MARK(GetDefaultJavaVMInitArgs, jint, (const jint&amp;)ret);
4122 
4123   if (Threads::is_supported_jni_version(args-&gt;version)) {
4124     ret = JNI_OK;
4125   }
4126   // 1.1 style no longer supported in hotspot.
</pre>
<hr />
<pre>
4156     void *c = &amp;a;
4157     void *d = Atomic::xchg(&amp;c, &amp;b);
4158     assert(a == (jint) 0xdeadbeef &amp;&amp; b == (jint) 0xcafebabe, &quot;Atomic::xchg() works&quot;);
4159     assert(c == &amp;b &amp;&amp; d == &amp;a, &quot;Atomic::xchg() works&quot;);
4160   }
4161 #endif // ZERO &amp;&amp; ASSERT
4162 
4163   // At the moment it&#39;s only possible to have one Java VM,
4164   // since some of the runtime state is in global variables.
4165 
4166   // We cannot use our mutex locks here, since they only work on
4167   // Threads. We do an atomic compare and exchange to ensure only
4168   // one thread can call this method at a time
4169 
4170   // We use Atomic::xchg rather than Atomic::add/dec since on some platforms
4171   // the add/dec implementations are dependent on whether we are running
4172   // on a multiprocessor Atomic::xchg does not have this problem.
4173   if (Atomic::xchg(&amp;vm_created, 1) == 1) {
4174     return JNI_EEXIST;   // already created, or create attempt in progress
4175   }






4176   if (Atomic::xchg(&amp;safe_to_recreate_vm, 0) == 0) {
<span class="line-modified">4177     return JNI_ERR;  // someone tried and failed and retry not allowed.</span>
4178   }
4179 
4180   assert(vm_created == 1, &quot;vm_created is true during the creation&quot;);
4181 
4182   /**
4183    * Certain errors during initialization are recoverable and do not
4184    * prevent this method from being called again at a later time
4185    * (perhaps with different arguments).  However, at a certain
4186    * point during initialization if an error occurs we cannot allow
4187    * this function to be called again (or it will crash).  In those
4188    * situations, the &#39;canTryAgain&#39; flag is set to false, which atomically
4189    * sets safe_to_recreate_vm to 1, such that any new call to
4190    * JNI_CreateJavaVM will immediately fail using the above logic.
4191    */
4192   bool can_try_again = true;
4193 
4194   result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again);
4195   if (result == JNI_OK) {
4196     JavaThread *thread = JavaThread::current();
4197     assert(!thread-&gt;has_pending_exception(), &quot;should have returned not OK&quot;);
</pre>
<hr />
<pre>
4350 #ifdef _WIN32
4351   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
4352     // Nothing to do.
4353   }
4354 #endif
4355   return result;
4356 }
4357 
4358 static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool daemon) {
4359   JavaVMAttachArgs *args = (JavaVMAttachArgs *) _args;
4360 
4361   // Check below commented out from JDK1.2fcs as well
4362   /*
4363   if (args &amp;&amp; (args-&gt;version != JNI_VERSION_1_1 || args-&gt;version != JNI_VERSION_1_2)) {
4364     return JNI_EVERSION;
4365   }
4366   */
4367 
4368   Thread* t = Thread::current_or_null();
4369   if (t != NULL) {
<span class="line-modified">4370     // If the thread has been attached this operation is a no-op</span>
<span class="line-modified">4371     *(JNIEnv**)penv = ((JavaThread*) t)-&gt;jni_environment();</span>
<span class="line-modified">4372     return JNI_OK;</span>





4373   }
4374 
4375   // Create a thread and mark it as attaching so it will be skipped by the
4376   // ThreadsListEnumerator - see CR 6404306
4377   JavaThread* thread = new JavaThread(true);
4378 
4379   // Set correct safepoint info. The thread is going to call into Java when
4380   // initializing the Java level thread object. Hence, the correct state must
4381   // be set in order for the Safepoint code to deal with it correctly.
4382   thread-&gt;set_thread_state(_thread_in_vm);
4383   thread-&gt;record_stack_base_and_size();
4384   thread-&gt;register_thread_stack_with_NMT();
4385   thread-&gt;initialize_thread_current();
4386 
4387   if (!os::create_attached_thread(thread)) {
4388     thread-&gt;smr_delete();
4389     return JNI_ERR;
4390   }
4391   // Enable stack overflow checks
4392   thread-&gt;create_stack_guard_pages();
</pre>
<hr />
<pre>
4450 
4451   *(JNIEnv**)penv = thread-&gt;jni_environment();
4452 
4453   // Now leaving the VM, so change thread_state. This is normally automatically taken care
4454   // of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by
4455   // using ThreadStateTransition::transition, we do a callback to the safepoint code if
4456   // needed.
4457 
4458   ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4459 
4460   // Perform any platform dependent FPU setup
4461   os::setup_fpu();
4462 
4463   return JNI_OK;
4464 }
4465 
4466 
4467 jint JNICALL jni_AttachCurrentThread(JavaVM *vm, void **penv, void *_args) {
4468   HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(vm, penv, _args);
4469   if (vm_created == 0) {
<span class="line-modified">4470   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);</span>
4471     return JNI_ERR;
4472   }
4473 
4474   JNIWrapper(&quot;AttachCurrentThread&quot;);
4475   jint ret = attach_current_thread(vm, penv, _args, false);
4476   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(ret);
4477   return ret;
4478 }
4479 
4480 
4481 jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
4482   HOTSPOT_JNI_DETACHCURRENTTHREAD_ENTRY(vm);




4483 
4484   JNIWrapper(&quot;DetachCurrentThread&quot;);
4485 


4486   // If the thread has already been detached the operation is a no-op
<span class="line-modified">4487   if (Thread::current_or_null() == NULL) {</span>
4488     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4489     return JNI_OK;
4490   }
4491 






4492   VM_Exit::block_if_vm_exited();
4493 
<span class="line-modified">4494   JavaThread* thread = JavaThread::current();</span>
4495   if (thread-&gt;has_last_Java_frame()) {
4496     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4497     // Can&#39;t detach a thread that&#39;s running java, that can&#39;t work.
4498     return JNI_ERR;
4499   }
4500 
4501   // Safepoint support. Have to do call-back to safepoint code, if in the
4502   // middle of a safepoint operation
4503   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4504 
4505   // XXX: Note that JavaThread::exit() call below removes the guards on the
4506   // stack pages set up via enable_stack_{red,yellow}_zone() calls
4507   // above in jni_AttachCurrentThread. Unfortunately, while the setting
4508   // of the guards is visible in jni_AttachCurrentThread above,
4509   // the removal of the guards is buried below in JavaThread::exit()
4510   // here. The abstraction should be more symmetrically either exposed
4511   // or hidden (e.g. it could probably be hidden in the same
4512   // (platform-dependent) methods where we do alternate stack
4513   // maintenance work?)
4514   thread-&gt;exit(false, JavaThread::jni_detach);
</pre>
</td>
<td>
<hr />
<pre>
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jni.h&quot;
  28 #include &quot;jvm.h&quot;
  29 #include &quot;ci/ciReplay.hpp&quot;
  30 #include &quot;classfile/altHashing.hpp&quot;
  31 #include &quot;classfile/classFileStream.hpp&quot;
  32 #include &quot;classfile/classLoader.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
<span class="line-added">  35 #include &quot;classfile/moduleEntry.hpp&quot;</span>
  36 #include &quot;classfile/modules.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/vmSymbols.hpp&quot;
  40 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  41 #include &quot;interpreter/linkResolver.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/allocation.inline.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/access.inline.hpp&quot;
  51 #include &quot;oops/arrayOop.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/instanceOop.hpp&quot;
  54 #include &quot;oops/markWord.hpp&quot;
  55 #include &quot;oops/method.hpp&quot;
</pre>
<hr />
<pre>
 383   }
 384   if ((int)strlen(name) &gt; Symbol::max_length()) {
 385     Exceptions::fthrow(THREAD_AND_LOCATION,
 386                        vmSymbols::java_lang_NoClassDefFoundError(),
 387                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 388                        Symbol::max_length(),
 389                        name);
 390     return 0;
 391   }
 392 
 393   //%note jni_3
 394   Handle protection_domain;
 395   // Find calling class
 396   Klass* k = thread-&gt;security_get_caller_class(0);
 397   // default to the system loader when no context
 398   Handle loader(THREAD, SystemDictionary::java_system_loader());
 399   if (k != NULL) {
 400     // Special handling to make sure JNI_OnLoad and JNI_OnUnload are executed
 401     // in the correct class context.
 402     if (k-&gt;class_loader() == NULL &amp;&amp;
<span class="line-modified"> 403         k-&gt;name() == vmSymbols::jdk_internal_loader_NativeLibraries()) {</span>
 404       JavaValue result(T_OBJECT);
 405       JavaCalls::call_static(&amp;result, k,
 406                              vmSymbols::getFromClass_name(),
 407                              vmSymbols::void_class_signature(),
 408                              CHECK_NULL);
<span class="line-modified"> 409       // When invoked from JNI_OnLoad, NativeLibraries::getFromClass returns</span>
 410       // a non-NULL Class object.  When invoked from JNI_OnUnload,
 411       // it will return NULL to indicate no context.
 412       oop mirror = (oop) result.get_jobject();
 413       if (mirror != NULL) {
 414         Klass* fromClass = java_lang_Class::as_Klass(mirror);
 415         loader = Handle(THREAD, fromClass-&gt;class_loader());
 416         protection_domain = Handle(THREAD, fromClass-&gt;protection_domain());
 417       }
 418     } else {
 419       loader = Handle(THREAD, k-&gt;class_loader());
 420     }
 421   }
 422 
 423   TempNewSymbol sym = SymbolTable::new_symbol(name);
 424   result = find_class_from_class_loader(env, sym, true, loader,
 425                                         protection_domain, true, thread);
 426 
 427   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 428     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 429   }
</pre>
<hr />
<pre>
2640      ss.print(&quot;Index %d out of bounds for length %d&quot;, index, arr-&gt;length());
2641      THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2642    }
2643 JNI_END
2644 
2645 
2646 
2647 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
2648                               ,EntryProbe,ReturnProbe)  \
2649 \
2650   DT_RETURN_MARK_DECL(New##Result##Array, Return \
2651                       , ReturnProbe); \
2652 \
2653 JNI_ENTRY(Return, \
2654           jni_New##Result##Array(JNIEnv *env, jsize len)) \
2655   JNIWrapper(&quot;New&quot; XSTR(Result) &quot;Array&quot;); \
2656   EntryProbe; \
2657   Return ret = NULL;\
2658   DT_RETURN_MARK(New##Result##Array, Return, (const Return&amp;)ret);\
2659 \
<span class="line-modified">2660   oop obj= oopFactory::Allocator(len, CHECK_NULL); \</span>
2661   ret = (Return) JNIHandles::make_local(env, obj); \
2662   return ret;\
2663 JNI_END
2664 
2665 DEFINE_NEWSCALARARRAY(jbooleanArray, new_boolArray,   Boolean,
2666                       HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY(env, len),
2667                       HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN(_ret_ref))
2668 DEFINE_NEWSCALARARRAY(jbyteArray,    new_byteArray,   Byte,
2669                       HOTSPOT_JNI_NEWBYTEARRAY_ENTRY(env, len),
2670                       HOTSPOT_JNI_NEWBYTEARRAY_RETURN(_ret_ref))
2671 DEFINE_NEWSCALARARRAY(jshortArray,   new_shortArray,  Short,
2672                       HOTSPOT_JNI_NEWSHORTARRAY_ENTRY(env, len),
2673                       HOTSPOT_JNI_NEWSHORTARRAY_RETURN(_ret_ref))
2674 DEFINE_NEWSCALARARRAY(jcharArray,    new_charArray,   Char,
2675                       HOTSPOT_JNI_NEWCHARARRAY_ENTRY(env, len),
2676                       HOTSPOT_JNI_NEWCHARARRAY_RETURN(_ret_ref))
2677 DEFINE_NEWSCALARARRAY(jintArray,     new_intArray,    Int,
2678                       HOTSPOT_JNI_NEWINTARRAY_ENTRY(env, len),
2679                       HOTSPOT_JNI_NEWINTARRAY_RETURN(_ret_ref))
2680 DEFINE_NEWSCALARARRAY(jlongArray,    new_longArray,   Long,
</pre>
<hr />
<pre>
2911                             , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2912                             HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
2913 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
2914                             , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2915                             HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
2916 
2917 
2918 DT_RETURN_MARK_DECL(RegisterNatives, jint
2919                     , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
2920 
2921 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
2922                                     const JNINativeMethod *methods,
2923                                     jint nMethods))
2924   JNIWrapper(&quot;RegisterNatives&quot;);
2925   HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
2926   jint ret = 0;
2927   DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
2928 
2929   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2930 
<span class="line-modified">2931   // There are no restrictions on native code registering native methods,</span>
<span class="line-modified">2932   // which allows agents to redefine the bindings to native methods, however</span>
<span class="line-modified">2933   // we issue a warning if any code running outside of the boot/platform</span>
<span class="line-modified">2934   // loader is rebinding any native methods in classes loaded by the</span>
<span class="line-modified">2935   // boot/platform loader that are in named modules. That will catch changes</span>
<span class="line-added">2936   // to platform classes while excluding classes added to the bootclasspath.</span>
2937   bool do_warning = false;
<span class="line-modified">2938 </span>
<span class="line-modified">2939   // Only instanceKlasses can have native methods</span>
<span class="line-modified">2940   if (k-&gt;is_instance_klass()) {</span>
<span class="line-modified">2941     oop cl = k-&gt;class_loader();</span>
<span class="line-modified">2942     InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-added">2943     // Check for a platform class</span>
<span class="line-added">2944     if ((cl ==  NULL || SystemDictionary::is_platform_class_loader(cl)) &amp;&amp;</span>
<span class="line-added">2945         ik-&gt;module()-&gt;is_named()) {</span>
<span class="line-added">2946       Klass* caller = thread-&gt;security_get_caller_class(1);</span>
<span class="line-added">2947       // If no caller class, or caller class has a different loader, then</span>
<span class="line-added">2948       // issue a warning below.</span>
<span class="line-added">2949       do_warning = (caller == NULL) || caller-&gt;class_loader() != cl;</span>
<span class="line-added">2950     }</span>
2951   }
2952 
2953 
2954   for (int index = 0; index &lt; nMethods; index++) {
2955     const char* meth_name = methods[index].name;
2956     const char* meth_sig = methods[index].signature;
2957     int meth_name_len = (int)strlen(meth_name);
2958 
2959     // The class should have been loaded (we have an instance of the class
2960     // passed in) so the method and signature should already be in the symbol
2961     // table.  If they&#39;re not there, the method doesn&#39;t exist.
2962     TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
2963     TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
2964 
2965     if (name == NULL || signature == NULL) {
2966       ResourceMark rm(THREAD);
2967       stringStream st;
2968       st.print(&quot;Method %s.%s%s not found&quot;, k-&gt;external_name(), meth_name, meth_sig);
2969       // Must return negative value on failure
2970       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
</pre>
<hr />
<pre>
4096     if (EventThreadStart::is_stacktrace_enabled()) {
4097       jt-&gt;jfr_thread_local()-&gt;set_cached_stack_trace_id((traceid)0);
4098       event.commit();
4099       jt-&gt;jfr_thread_local()-&gt;clear_cached_stack_trace();
4100     } else
4101 #endif
4102     {
4103       event.commit();
4104     }
4105   }
4106 }
4107 
4108 // Invocation API
4109 
4110 
4111 // Forward declaration
4112 extern const struct JNIInvokeInterface_ jni_InvokeInterface;
4113 
4114 // Global invocation API vars
4115 volatile int vm_created = 0;
<span class="line-modified">4116 // Indicate whether it is safe to recreate VM. Recreation is only</span>
<span class="line-added">4117 // possible after a failed initial creation attempt in some cases.</span>
4118 volatile int safe_to_recreate_vm = 1;
4119 struct JavaVM_ main_vm = {&amp;jni_InvokeInterface};
4120 
4121 
4122 #define JAVASTACKSIZE (400 * 1024)    /* Default size of a thread java stack */
4123 enum { VERIFY_NONE, VERIFY_REMOTE, VERIFY_ALL };
4124 
4125 DT_RETURN_MARK_DECL(GetDefaultJavaVMInitArgs, jint
4126                     , HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_RETURN(_ret_ref));
4127 
4128 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args_) {
4129   HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_ENTRY(args_);
4130   JDK1_1InitArgs *args = (JDK1_1InitArgs *)args_;
4131   jint ret = JNI_ERR;
4132   DT_RETURN_MARK(GetDefaultJavaVMInitArgs, jint, (const jint&amp;)ret);
4133 
4134   if (Threads::is_supported_jni_version(args-&gt;version)) {
4135     ret = JNI_OK;
4136   }
4137   // 1.1 style no longer supported in hotspot.
</pre>
<hr />
<pre>
4167     void *c = &amp;a;
4168     void *d = Atomic::xchg(&amp;c, &amp;b);
4169     assert(a == (jint) 0xdeadbeef &amp;&amp; b == (jint) 0xcafebabe, &quot;Atomic::xchg() works&quot;);
4170     assert(c == &amp;b &amp;&amp; d == &amp;a, &quot;Atomic::xchg() works&quot;);
4171   }
4172 #endif // ZERO &amp;&amp; ASSERT
4173 
4174   // At the moment it&#39;s only possible to have one Java VM,
4175   // since some of the runtime state is in global variables.
4176 
4177   // We cannot use our mutex locks here, since they only work on
4178   // Threads. We do an atomic compare and exchange to ensure only
4179   // one thread can call this method at a time
4180 
4181   // We use Atomic::xchg rather than Atomic::add/dec since on some platforms
4182   // the add/dec implementations are dependent on whether we are running
4183   // on a multiprocessor Atomic::xchg does not have this problem.
4184   if (Atomic::xchg(&amp;vm_created, 1) == 1) {
4185     return JNI_EEXIST;   // already created, or create attempt in progress
4186   }
<span class="line-added">4187 </span>
<span class="line-added">4188   // If a previous creation attempt failed but can be retried safely,</span>
<span class="line-added">4189   // then safe_to_recreate_vm will have been reset to 1 after being</span>
<span class="line-added">4190   // cleared here. If a previous creation attempt succeeded and we then</span>
<span class="line-added">4191   // destroyed that VM, we will be prevented from trying to recreate</span>
<span class="line-added">4192   // the VM in the same process, as the value will still be 0.</span>
4193   if (Atomic::xchg(&amp;safe_to_recreate_vm, 0) == 0) {
<span class="line-modified">4194     return JNI_ERR;</span>
4195   }
4196 
4197   assert(vm_created == 1, &quot;vm_created is true during the creation&quot;);
4198 
4199   /**
4200    * Certain errors during initialization are recoverable and do not
4201    * prevent this method from being called again at a later time
4202    * (perhaps with different arguments).  However, at a certain
4203    * point during initialization if an error occurs we cannot allow
4204    * this function to be called again (or it will crash).  In those
4205    * situations, the &#39;canTryAgain&#39; flag is set to false, which atomically
4206    * sets safe_to_recreate_vm to 1, such that any new call to
4207    * JNI_CreateJavaVM will immediately fail using the above logic.
4208    */
4209   bool can_try_again = true;
4210 
4211   result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again);
4212   if (result == JNI_OK) {
4213     JavaThread *thread = JavaThread::current();
4214     assert(!thread-&gt;has_pending_exception(), &quot;should have returned not OK&quot;);
</pre>
<hr />
<pre>
4367 #ifdef _WIN32
4368   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
4369     // Nothing to do.
4370   }
4371 #endif
4372   return result;
4373 }
4374 
4375 static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool daemon) {
4376   JavaVMAttachArgs *args = (JavaVMAttachArgs *) _args;
4377 
4378   // Check below commented out from JDK1.2fcs as well
4379   /*
4380   if (args &amp;&amp; (args-&gt;version != JNI_VERSION_1_1 || args-&gt;version != JNI_VERSION_1_2)) {
4381     return JNI_EVERSION;
4382   }
4383   */
4384 
4385   Thread* t = Thread::current_or_null();
4386   if (t != NULL) {
<span class="line-modified">4387     // If executing from an atexit hook we may be in the VMThread.</span>
<span class="line-modified">4388     if (t-&gt;is_Java_thread()) {</span>
<span class="line-modified">4389       // If the thread has been attached this operation is a no-op</span>
<span class="line-added">4390       *(JNIEnv**)penv = ((JavaThread*) t)-&gt;jni_environment();</span>
<span class="line-added">4391       return JNI_OK;</span>
<span class="line-added">4392     } else {</span>
<span class="line-added">4393       return JNI_ERR;</span>
<span class="line-added">4394     }</span>
4395   }
4396 
4397   // Create a thread and mark it as attaching so it will be skipped by the
4398   // ThreadsListEnumerator - see CR 6404306
4399   JavaThread* thread = new JavaThread(true);
4400 
4401   // Set correct safepoint info. The thread is going to call into Java when
4402   // initializing the Java level thread object. Hence, the correct state must
4403   // be set in order for the Safepoint code to deal with it correctly.
4404   thread-&gt;set_thread_state(_thread_in_vm);
4405   thread-&gt;record_stack_base_and_size();
4406   thread-&gt;register_thread_stack_with_NMT();
4407   thread-&gt;initialize_thread_current();
4408 
4409   if (!os::create_attached_thread(thread)) {
4410     thread-&gt;smr_delete();
4411     return JNI_ERR;
4412   }
4413   // Enable stack overflow checks
4414   thread-&gt;create_stack_guard_pages();
</pre>
<hr />
<pre>
4472 
4473   *(JNIEnv**)penv = thread-&gt;jni_environment();
4474 
4475   // Now leaving the VM, so change thread_state. This is normally automatically taken care
4476   // of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by
4477   // using ThreadStateTransition::transition, we do a callback to the safepoint code if
4478   // needed.
4479 
4480   ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4481 
4482   // Perform any platform dependent FPU setup
4483   os::setup_fpu();
4484 
4485   return JNI_OK;
4486 }
4487 
4488 
4489 jint JNICALL jni_AttachCurrentThread(JavaVM *vm, void **penv, void *_args) {
4490   HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(vm, penv, _args);
4491   if (vm_created == 0) {
<span class="line-modified">4492     HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);</span>
4493     return JNI_ERR;
4494   }
4495 
4496   JNIWrapper(&quot;AttachCurrentThread&quot;);
4497   jint ret = attach_current_thread(vm, penv, _args, false);
4498   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(ret);
4499   return ret;
4500 }
4501 
4502 
4503 jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
4504   HOTSPOT_JNI_DETACHCURRENTTHREAD_ENTRY(vm);
<span class="line-added">4505   if (vm_created == 0) {</span>
<span class="line-added">4506     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_ERR);</span>
<span class="line-added">4507     return JNI_ERR;</span>
<span class="line-added">4508   }</span>
4509 
4510   JNIWrapper(&quot;DetachCurrentThread&quot;);
4511 
<span class="line-added">4512   Thread* current = Thread::current_or_null();</span>
<span class="line-added">4513 </span>
4514   // If the thread has already been detached the operation is a no-op
<span class="line-modified">4515   if (current == NULL) {</span>
4516     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4517     return JNI_OK;
4518   }
4519 
<span class="line-added">4520   // If executing from an atexit hook we may be in the VMThread.</span>
<span class="line-added">4521   if (!current-&gt;is_Java_thread()) {</span>
<span class="line-added">4522     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);</span>
<span class="line-added">4523     return JNI_ERR;</span>
<span class="line-added">4524   }</span>
<span class="line-added">4525 </span>
4526   VM_Exit::block_if_vm_exited();
4527 
<span class="line-modified">4528   JavaThread* thread = (JavaThread*) current;</span>
4529   if (thread-&gt;has_last_Java_frame()) {
4530     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4531     // Can&#39;t detach a thread that&#39;s running java, that can&#39;t work.
4532     return JNI_ERR;
4533   }
4534 
4535   // Safepoint support. Have to do call-back to safepoint code, if in the
4536   // middle of a safepoint operation
4537   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4538 
4539   // XXX: Note that JavaThread::exit() call below removes the guards on the
4540   // stack pages set up via enable_stack_{red,yellow}_zone() calls
4541   // above in jni_AttachCurrentThread. Unfortunately, while the setting
4542   // of the guards is visible in jni_AttachCurrentThread above,
4543   // the removal of the guards is buried below in JavaThread::exit()
4544   // here. The abstraction should be more symmetrically either exposed
4545   // or hidden (e.g. it could probably be hidden in the same
4546   // (platform-dependent) methods where we do alternate stack
4547   // maintenance work?)
4548   thread-&gt;exit(false, JavaThread::jni_detach);
</pre>
</td>
</tr>
</table>
<center><a href="../opto/vectornode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
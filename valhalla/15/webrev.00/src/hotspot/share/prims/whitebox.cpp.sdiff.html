<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/whitebox.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stackwalk.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="whitebox.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/whitebox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &lt;new&gt;
  28 
  29 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  30 #include &quot;classfile/modules.hpp&quot;
  31 #include &quot;classfile/protectionDomainCache.hpp&quot;
  32 #include &quot;classfile/stringTable.hpp&quot;
  33 #include &quot;classfile/symbolTable.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;compiler/compilationPolicy.hpp&quot;
  36 #include &quot;compiler/methodMatcher.hpp&quot;
  37 #include &quot;compiler/directivesParser.hpp&quot;

  38 #include &quot;gc/shared/gcConfig.hpp&quot;
  39 #include &quot;gc/shared/genArguments.hpp&quot;
  40 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  41 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  42 #include &quot;memory/filemap.hpp&quot;
  43 #include &quot;memory/heapShared.inline.hpp&quot;
  44 #include &quot;memory/metaspaceShared.hpp&quot;
  45 #include &quot;memory/metadataFactory.hpp&quot;
  46 #include &quot;memory/iterator.inline.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;memory/oopFactory.hpp&quot;
  50 #include &quot;oops/array.hpp&quot;
  51 #include &quot;oops/compressedOops.hpp&quot;
  52 #include &quot;oops/compressedOops.inline.hpp&quot;
  53 #include &quot;oops/constantPool.inline.hpp&quot;
  54 #include &quot;oops/method.inline.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
</pre>
<hr />
<pre>
  91 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  92 #include &quot;gc/g1/g1ConcurrentMarkThread.hpp&quot;
  93 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  94 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
  95 #endif // INCLUDE_G1GC
  96 #if INCLUDE_PARALLELGC
  97 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
  98 #include &quot;gc/parallel/adjoiningGenerations.hpp&quot;
  99 #endif // INCLUDE_PARALLELGC
 100 #if INCLUDE_NMT
 101 #include &quot;services/mallocSiteTable.hpp&quot;
 102 #include &quot;services/memTracker.hpp&quot;
 103 #include &quot;utilities/nativeCallStack.hpp&quot;
 104 #endif // INCLUDE_NMT
 105 #if INCLUDE_AOT
 106 #include &quot;aot/aotLoader.hpp&quot;
 107 #endif // INCLUDE_AOT
 108 
 109 #ifdef LINUX
 110 #include &quot;osContainer_linux.hpp&quot;

 111 #endif
 112 
 113 #define SIZE_T_MAX_VALUE ((size_t) -1)
 114 
 115 #define CHECK_JNI_EXCEPTION_(env, value)                               \
 116   do {                                                                 \
 117     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 118     THREAD-&gt;clear_pending_jni_exception_check();                       \
 119     if (HAS_PENDING_EXCEPTION) {                                       \
 120       return(value);                                                   \
 121     }                                                                  \
 122   } while (0)
 123 
 124 #define CHECK_JNI_EXCEPTION(env)                                       \
 125   do {                                                                 \
 126     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 127     THREAD-&gt;clear_pending_jni_exception_check();                       \
 128     if (HAS_PENDING_EXCEPTION) {                                       \
 129       return;                                                          \
 130     }                                                                  \
</pre>
<hr />
<pre>
 379     return Universe::heap()-&gt;is_in(p);
 380   }
 381 #endif
 382   GenCollectedHeap* gch = GenCollectedHeap::heap();
 383   return !gch-&gt;is_in_young(p);
 384 WB_END
 385 
 386 WB_ENTRY(jlong, WB_GetObjectSize(JNIEnv* env, jobject o, jobject obj))
 387   oop p = JNIHandles::resolve(obj);
 388   return Universe::heap()-&gt;obj_size(p) * HeapWordSize;
 389 WB_END
 390 
 391 WB_ENTRY(jlong, WB_GetHeapSpaceAlignment(JNIEnv* env, jobject o))
 392   return (jlong)SpaceAlignment;
 393 WB_END
 394 
 395 WB_ENTRY(jlong, WB_GetHeapAlignment(JNIEnv* env, jobject o))
 396   return (jlong)HeapAlignment;
 397 WB_END
 398 
<span class="line-modified"> 399 WB_ENTRY(jboolean, WB_SupportsConcurrentGCPhaseControl(JNIEnv* env, jobject o))</span>
<span class="line-modified"> 400   return Universe::heap()-&gt;supports_concurrent_phase_control();</span>
 401 WB_END
 402 
<span class="line-modified"> 403 WB_ENTRY(jboolean, WB_RequestConcurrentGCPhase(JNIEnv* env, jobject o, jstring name))</span>
<span class="line-modified"> 404   Handle h_name(THREAD, JNIHandles::resolve(name));</span>












 405   ResourceMark rm;
 406   const char* c_name = java_lang_String::as_utf8_string(h_name());
<span class="line-modified"> 407   return Universe::heap()-&gt;request_concurrent_phase(c_name);</span>
 408 WB_END
 409 
 410 #if INCLUDE_G1GC
 411 
 412 WB_ENTRY(jboolean, WB_G1IsHumongous(JNIEnv* env, jobject o, jobject obj))
 413   if (UseG1GC) {
 414     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 415     oop result = JNIHandles::resolve(obj);
 416     const HeapRegion* hr = g1h-&gt;heap_region_containing(result);
 417     return hr-&gt;is_humongous();
 418   }
 419   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1IsHumongous: G1 GC is not enabled&quot;);
 420 WB_END
 421 
 422 WB_ENTRY(jboolean, WB_G1BelongsToHumongousRegion(JNIEnv* env, jobject o, jlong addr))
 423   if (UseG1GC) {
 424     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 425     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 426     return hr-&gt;is_humongous();
 427   }
</pre>
<hr />
<pre>
 985 WB_END
 986 
 987 WB_ENTRY(jint, WB_GetCompileQueueSize(JNIEnv* env, jobject o, jint comp_level))
 988   if (comp_level == CompLevel_any) {
 989     return CompileBroker::queue_size(CompLevel_full_optimization) /* C2 */ +
 990         CompileBroker::queue_size(CompLevel_full_profile) /* C1 */;
 991   } else {
 992     return CompileBroker::queue_size(comp_level);
 993   }
 994 WB_END
 995 
 996 WB_ENTRY(jboolean, WB_TestSetForceInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
 997   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 998   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 999   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1000   bool result = mh-&gt;force_inline();
1001   mh-&gt;set_force_inline(value == JNI_TRUE);
1002   return result;
1003 WB_END
1004 












1005 bool WhiteBox::compile_method(Method* method, int comp_level, int bci, Thread* THREAD) {
1006   // Screen for unavailable/bad comp level or null method
1007   AbstractCompiler* comp = CompileBroker::compiler(comp_level);
1008   if (method == NULL) {
1009     tty-&gt;print_cr(&quot;WB error: request to compile NULL method&quot;);
1010     return false;
1011   }
1012   if (comp_level &gt; highestCompLevel()) {
1013     tty-&gt;print_cr(&quot;WB error: invalid compilation level %d&quot;, comp_level);
1014     return false;
1015   }
1016   if (comp == NULL) {
1017     tty-&gt;print_cr(&quot;WB error: no compiler for requested compilation level %d&quot;, comp_level);
1018     return false;
1019   }
1020 
1021   // Check if compilation is blocking
1022   methodHandle mh(THREAD, method);
1023   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, comp);
1024   bool is_blocking = !directive-&gt;BackgroundCompilationOption;
</pre>
<hr />
<pre>
1472 
1473 CodeHeap* WhiteBox::get_code_heap(int blob_type) {
1474   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1475   return CodeCache::get_code_heap(blob_type);
1476 }
1477 
1478 struct CodeBlobStub {
1479   CodeBlobStub(const CodeBlob* blob) :
1480       name(os::strdup(blob-&gt;name())),
1481       size(blob-&gt;size()),
1482       blob_type(WhiteBox::get_blob_type(blob)),
1483       address((jlong) blob) { }
1484   ~CodeBlobStub() { os::free((void*) name); }
1485   const char* const name;
1486   const jint        size;
1487   const jint        blob_type;
1488   const jlong       address;
1489 };
1490 
1491 static jobjectArray codeBlob2objectArray(JavaThread* thread, JNIEnv* env, CodeBlobStub* cb) {

1492   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1493   CHECK_JNI_EXCEPTION_(env, NULL);
1494   jobjectArray result = env-&gt;NewObjectArray(4, clazz, NULL);
1495 
1496   jstring name = env-&gt;NewStringUTF(cb-&gt;name);
1497   CHECK_JNI_EXCEPTION_(env, NULL);
1498   env-&gt;SetObjectArrayElement(result, 0, name);
1499 
1500   jobject obj = integerBox(thread, env, cb-&gt;size);
1501   CHECK_JNI_EXCEPTION_(env, NULL);
1502   env-&gt;SetObjectArrayElement(result, 1, obj);
1503 
1504   obj = integerBox(thread, env, cb-&gt;blob_type);
1505   CHECK_JNI_EXCEPTION_(env, NULL);
1506   env-&gt;SetObjectArrayElement(result, 2, obj);
1507 
1508   obj = longBox(thread, env, cb-&gt;address);
1509   CHECK_JNI_EXCEPTION_(env, NULL);
1510   env-&gt;SetObjectArrayElement(result, 3, obj);
1511 
</pre>
<hr />
<pre>
2054   } else {
2055     return NULL;
2056   }
2057 WB_END
2058 
2059 WB_ENTRY(void, WB_LinkClass(JNIEnv* env, jobject wb, jclass clazz))
2060   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2061   if (!k-&gt;is_instance_klass()) {
2062     return;
2063   }
2064   InstanceKlass *ik = InstanceKlass::cast(k);
2065   ik-&gt;link_class(THREAD); // may throw verification error
2066 WB_END
2067 
2068 WB_ENTRY(jboolean, WB_AreOpenArchiveHeapObjectsMapped(JNIEnv* env))
2069   return HeapShared::open_archive_heap_region_mapped();
2070 WB_END
2071 
2072 WB_ENTRY(jboolean, WB_IsCDSIncludedInVmBuild(JNIEnv* env))
2073 #if INCLUDE_CDS
<span class="line-removed">2074 # ifdef _LP64</span>
<span class="line-removed">2075     if (!UseCompressedOops || !UseCompressedClassPointers) {</span>
<span class="line-removed">2076       // On 64-bit VMs, CDS is supported only with compressed oops/pointers</span>
<span class="line-removed">2077       return false;</span>
<span class="line-removed">2078     }</span>
<span class="line-removed">2079 # endif // _LP64</span>
2080   return true;
2081 #else
2082   return false;
2083 #endif // INCLUDE_CDS
2084 WB_END
2085 
2086 WB_ENTRY(jboolean, WB_isC2OrJVMCIIncludedInVmBuild(JNIEnv* env))
2087 #if COMPILER2_OR_JVMCI
2088   return true;
2089 #else
2090   return false;
2091 #endif
2092 WB_END
2093 
2094 WB_ENTRY(jboolean, WB_IsJavaHeapArchiveSupported(JNIEnv* env))
2095   return HeapShared::is_heap_object_archiving_allowed();
2096 WB_END
2097 
2098 
2099 WB_ENTRY(jboolean, WB_IsJFRIncludedInVmBuild(JNIEnv* env))
</pre>
<hr />
<pre>
2253 
2254 // Checks that the library libfile has the noexecstack bit set.
2255 WB_ENTRY(jboolean, WB_CheckLibSpecifiesNoexecstack(JNIEnv* env, jobject o, jstring libfile))
2256   jboolean ret = false;
2257 #ifdef LINUX
2258   // Can&#39;t be in VM when we call JNI.
2259   ThreadToNativeFromVM ttnfv(thread);
2260   const char* lf = env-&gt;GetStringUTFChars(libfile, NULL);
2261   CHECK_JNI_EXCEPTION_(env, 0);
2262   ret = (jboolean) ElfFile::specifies_noexecstack(lf);
2263   env-&gt;ReleaseStringUTFChars(libfile, lf);
2264 #endif
2265   return ret;
2266 WB_END
2267 
2268 WB_ENTRY(jboolean, WB_IsContainerized(JNIEnv* env, jobject o))
2269   LINUX_ONLY(return OSContainer::is_containerized();)
2270   return false;
2271 WB_END
2272 

























2273 WB_ENTRY(void, WB_PrintOsInfo(JNIEnv* env, jobject o))
2274   os::print_os_info(tty);
2275 WB_END
2276 
2277 // Elf decoder
2278 WB_ENTRY(void, WB_DisableElfSectionCache(JNIEnv* env))
2279 #if !defined(_WINDOWS) &amp;&amp; !defined(__APPLE__) &amp;&amp; !defined(_AIX)
2280   ElfFile::_do_not_cache_elf_section = true;
2281 #endif
2282 WB_END
2283 
2284 WB_ENTRY(jlong, WB_ResolvedMethodItemsCount(JNIEnv* env, jobject o))
2285   return (jlong) ResolvedMethodTable::items_count();
2286 WB_END
2287 
2288 WB_ENTRY(jint, WB_ProtectionDomainRemovedCount(JNIEnv* env, jobject o))
2289   return (jint) SystemDictionary::pd_cache_table()-&gt;removed_entries_count();
2290 WB_END
2291 
2292 WB_ENTRY(jint, WB_AotLibrariesCount(JNIEnv* env, jobject o))
</pre>
<hr />
<pre>
2523   {CC&quot;isShared&quot;,           CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsShared },
2524   {CC&quot;isSharedClass&quot;,      CC&quot;(Ljava/lang/Class;)Z&quot;,  (void*)&amp;WB_IsSharedClass },
2525   {CC&quot;areSharedStringsIgnored&quot;,           CC&quot;()Z&quot;,    (void*)&amp;WB_AreSharedStringsIgnored },
2526   {CC&quot;getResolvedReferences&quot;, CC&quot;(Ljava/lang/Class;)Ljava/lang/Object;&quot;, (void*)&amp;WB_GetResolvedReferences},
2527   {CC&quot;linkClass&quot;,          CC&quot;(Ljava/lang/Class;)V&quot;,  (void*)&amp;WB_LinkClass},
2528   {CC&quot;areOpenArchiveHeapObjectsMapped&quot;,   CC&quot;()Z&quot;,    (void*)&amp;WB_AreOpenArchiveHeapObjectsMapped},
2529   {CC&quot;isCDSIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsCDSIncludedInVmBuild },
2530   {CC&quot;isJFRIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsJFRIncludedInVmBuild },
2531   {CC&quot;isC2OrJVMCIIncludedInVmBuild&quot;,      CC&quot;()Z&quot;,    (void*)&amp;WB_isC2OrJVMCIIncludedInVmBuild },
2532   {CC&quot;isJavaHeapArchiveSupported&quot;,        CC&quot;()Z&quot;,    (void*)&amp;WB_IsJavaHeapArchiveSupported },
2533   {CC&quot;cdsMemoryMappingFailed&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_CDSMemoryMappingFailed },
2534 
2535   {CC&quot;clearInlineCaches0&quot;,  CC&quot;(Z)V&quot;,                 (void*)&amp;WB_ClearInlineCaches },
2536   {CC&quot;handshakeWalkStack&quot;, CC&quot;(Ljava/lang/Thread;Z)I&quot;, (void*)&amp;WB_HandshakeWalkStack },
2537   {CC&quot;addCompilerDirective&quot;,    CC&quot;(Ljava/lang/String;)I&quot;,
2538                                                       (void*)&amp;WB_AddCompilerDirective },
2539   {CC&quot;removeCompilerDirective&quot;,   CC&quot;(I)V&quot;,           (void*)&amp;WB_RemoveCompilerDirective },
2540   {CC&quot;isGCSupported&quot;,             CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSupported},
2541   {CC&quot;isGCSelected&quot;,              CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSelected},
2542   {CC&quot;isGCSelectedErgonomically&quot;, CC&quot;()Z&quot;,            (void*)&amp;WB_IsGCSelectedErgonomically},
<span class="line-modified">2543   {CC&quot;supportsConcurrentGCPhaseControl&quot;, CC&quot;()Z&quot;,     (void*)&amp;WB_SupportsConcurrentGCPhaseControl},</span>
<span class="line-modified">2544   {CC&quot;requestConcurrentGCPhase0&quot;, CC&quot;(Ljava/lang/String;)Z&quot;,</span>
<span class="line-modified">2545                                                       (void*)&amp;WB_RequestConcurrentGCPhase},</span>



2546   {CC&quot;checkLibSpecifiesNoexecstack&quot;, CC&quot;(Ljava/lang/String;)Z&quot;,
2547                                                       (void*)&amp;WB_CheckLibSpecifiesNoexecstack},
2548   {CC&quot;isContainerized&quot;,           CC&quot;()Z&quot;,            (void*)&amp;WB_IsContainerized },



2549   {CC&quot;printOsInfo&quot;,               CC&quot;()V&quot;,            (void*)&amp;WB_PrintOsInfo },
2550   {CC&quot;disableElfSectionCache&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_DisableElfSectionCache },
2551   {CC&quot;resolvedMethodItemsCount&quot;,  CC&quot;()J&quot;,            (void*)&amp;WB_ResolvedMethodItemsCount },
2552   {CC&quot;protectionDomainRemovedCount&quot;,   CC&quot;()I&quot;,       (void*)&amp;WB_ProtectionDomainRemovedCount },
2553   {CC&quot;aotLibrariesCount&quot;, CC&quot;()I&quot;,                    (void*)&amp;WB_AotLibrariesCount },
2554   {CC&quot;getKlassMetadataSize&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,(void*)&amp;WB_GetKlassMetadataSize},
2555 };
2556 
2557 
2558 #undef CC
2559 
2560 JVM_ENTRY(void, JVM_RegisterWhiteBoxMethods(JNIEnv* env, jclass wbclass))
2561   {
2562     if (WhiteBoxAPI) {
2563       // Make sure that wbclass is loaded by the null classloader
2564       InstanceKlass* ik = InstanceKlass::cast(JNIHandles::resolve(wbclass)-&gt;klass());
2565       Handle loader(THREAD, ik-&gt;class_loader());
2566       if (loader.is_null()) {
2567         WhiteBox::register_methods(env, wbclass, thread, methods, sizeof(methods) / sizeof(methods[0]));
2568         WhiteBox::set_used();
</pre>
</td>
<td>
<hr />
<pre>
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &lt;new&gt;
  28 
  29 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  30 #include &quot;classfile/modules.hpp&quot;
  31 #include &quot;classfile/protectionDomainCache.hpp&quot;
  32 #include &quot;classfile/stringTable.hpp&quot;
  33 #include &quot;classfile/symbolTable.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;compiler/compilationPolicy.hpp&quot;
  36 #include &quot;compiler/methodMatcher.hpp&quot;
  37 #include &quot;compiler/directivesParser.hpp&quot;
<span class="line-added">  38 #include &quot;gc/shared/concurrentGCBreakpoints.hpp&quot;</span>
  39 #include &quot;gc/shared/gcConfig.hpp&quot;
  40 #include &quot;gc/shared/genArguments.hpp&quot;
  41 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  42 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  43 #include &quot;memory/filemap.hpp&quot;
  44 #include &quot;memory/heapShared.inline.hpp&quot;
  45 #include &quot;memory/metaspaceShared.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
  47 #include &quot;memory/iterator.inline.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;memory/oopFactory.hpp&quot;
  51 #include &quot;oops/array.hpp&quot;
  52 #include &quot;oops/compressedOops.hpp&quot;
  53 #include &quot;oops/compressedOops.inline.hpp&quot;
  54 #include &quot;oops/constantPool.inline.hpp&quot;
  55 #include &quot;oops/method.inline.hpp&quot;
  56 #include &quot;oops/objArrayKlass.hpp&quot;
  57 #include &quot;oops/objArrayOop.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
</pre>
<hr />
<pre>
  92 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  93 #include &quot;gc/g1/g1ConcurrentMarkThread.hpp&quot;
  94 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  95 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
  96 #endif // INCLUDE_G1GC
  97 #if INCLUDE_PARALLELGC
  98 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
  99 #include &quot;gc/parallel/adjoiningGenerations.hpp&quot;
 100 #endif // INCLUDE_PARALLELGC
 101 #if INCLUDE_NMT
 102 #include &quot;services/mallocSiteTable.hpp&quot;
 103 #include &quot;services/memTracker.hpp&quot;
 104 #include &quot;utilities/nativeCallStack.hpp&quot;
 105 #endif // INCLUDE_NMT
 106 #if INCLUDE_AOT
 107 #include &quot;aot/aotLoader.hpp&quot;
 108 #endif // INCLUDE_AOT
 109 
 110 #ifdef LINUX
 111 #include &quot;osContainer_linux.hpp&quot;
<span class="line-added"> 112 #include &quot;cgroupSubsystem_linux.hpp&quot;</span>
 113 #endif
 114 
 115 #define SIZE_T_MAX_VALUE ((size_t) -1)
 116 
 117 #define CHECK_JNI_EXCEPTION_(env, value)                               \
 118   do {                                                                 \
 119     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 120     THREAD-&gt;clear_pending_jni_exception_check();                       \
 121     if (HAS_PENDING_EXCEPTION) {                                       \
 122       return(value);                                                   \
 123     }                                                                  \
 124   } while (0)
 125 
 126 #define CHECK_JNI_EXCEPTION(env)                                       \
 127   do {                                                                 \
 128     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 129     THREAD-&gt;clear_pending_jni_exception_check();                       \
 130     if (HAS_PENDING_EXCEPTION) {                                       \
 131       return;                                                          \
 132     }                                                                  \
</pre>
<hr />
<pre>
 381     return Universe::heap()-&gt;is_in(p);
 382   }
 383 #endif
 384   GenCollectedHeap* gch = GenCollectedHeap::heap();
 385   return !gch-&gt;is_in_young(p);
 386 WB_END
 387 
 388 WB_ENTRY(jlong, WB_GetObjectSize(JNIEnv* env, jobject o, jobject obj))
 389   oop p = JNIHandles::resolve(obj);
 390   return Universe::heap()-&gt;obj_size(p) * HeapWordSize;
 391 WB_END
 392 
 393 WB_ENTRY(jlong, WB_GetHeapSpaceAlignment(JNIEnv* env, jobject o))
 394   return (jlong)SpaceAlignment;
 395 WB_END
 396 
 397 WB_ENTRY(jlong, WB_GetHeapAlignment(JNIEnv* env, jobject o))
 398   return (jlong)HeapAlignment;
 399 WB_END
 400 
<span class="line-modified"> 401 WB_ENTRY(jboolean, WB_SupportsConcurrentGCBreakpoints(JNIEnv* env, jobject o))</span>
<span class="line-modified"> 402   return Universe::heap()-&gt;supports_concurrent_gc_breakpoints();</span>
 403 WB_END
 404 
<span class="line-modified"> 405 WB_ENTRY(void, WB_ConcurrentGCAcquireControl(JNIEnv* env, jobject o))</span>
<span class="line-modified"> 406   ConcurrentGCBreakpoints::acquire_control();</span>
<span class="line-added"> 407 WB_END</span>
<span class="line-added"> 408 </span>
<span class="line-added"> 409 WB_ENTRY(void, WB_ConcurrentGCReleaseControl(JNIEnv* env, jobject o))</span>
<span class="line-added"> 410   ConcurrentGCBreakpoints::release_control();</span>
<span class="line-added"> 411 WB_END</span>
<span class="line-added"> 412 </span>
<span class="line-added"> 413 WB_ENTRY(void, WB_ConcurrentGCRunToIdle(JNIEnv* env, jobject o))</span>
<span class="line-added"> 414   ConcurrentGCBreakpoints::run_to_idle();</span>
<span class="line-added"> 415 WB_END</span>
<span class="line-added"> 416 </span>
<span class="line-added"> 417 WB_ENTRY(jboolean, WB_ConcurrentGCRunTo(JNIEnv* env, jobject o, jobject at))</span>
<span class="line-added"> 418   Handle h_name(THREAD, JNIHandles::resolve(at));</span>
 419   ResourceMark rm;
 420   const char* c_name = java_lang_String::as_utf8_string(h_name());
<span class="line-modified"> 421   return ConcurrentGCBreakpoints::run_to(c_name);</span>
 422 WB_END
 423 
 424 #if INCLUDE_G1GC
 425 
 426 WB_ENTRY(jboolean, WB_G1IsHumongous(JNIEnv* env, jobject o, jobject obj))
 427   if (UseG1GC) {
 428     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 429     oop result = JNIHandles::resolve(obj);
 430     const HeapRegion* hr = g1h-&gt;heap_region_containing(result);
 431     return hr-&gt;is_humongous();
 432   }
 433   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1IsHumongous: G1 GC is not enabled&quot;);
 434 WB_END
 435 
 436 WB_ENTRY(jboolean, WB_G1BelongsToHumongousRegion(JNIEnv* env, jobject o, jlong addr))
 437   if (UseG1GC) {
 438     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 439     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 440     return hr-&gt;is_humongous();
 441   }
</pre>
<hr />
<pre>
 999 WB_END
1000 
1001 WB_ENTRY(jint, WB_GetCompileQueueSize(JNIEnv* env, jobject o, jint comp_level))
1002   if (comp_level == CompLevel_any) {
1003     return CompileBroker::queue_size(CompLevel_full_optimization) /* C2 */ +
1004         CompileBroker::queue_size(CompLevel_full_profile) /* C1 */;
1005   } else {
1006     return CompileBroker::queue_size(comp_level);
1007   }
1008 WB_END
1009 
1010 WB_ENTRY(jboolean, WB_TestSetForceInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
1011   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1012   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1013   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1014   bool result = mh-&gt;force_inline();
1015   mh-&gt;set_force_inline(value == JNI_TRUE);
1016   return result;
1017 WB_END
1018 
<span class="line-added">1019 #ifdef LINUX</span>
<span class="line-added">1020 bool WhiteBox::validate_cgroup(const char* proc_cgroups,</span>
<span class="line-added">1021                                const char* proc_self_cgroup,</span>
<span class="line-added">1022                                const char* proc_self_mountinfo,</span>
<span class="line-added">1023                                u1* cg_flags) {</span>
<span class="line-added">1024   CgroupInfo cg_infos[4];</span>
<span class="line-added">1025   return CgroupSubsystemFactory::determine_type(cg_infos, proc_cgroups,</span>
<span class="line-added">1026                                                     proc_self_cgroup,</span>
<span class="line-added">1027                                                     proc_self_mountinfo, cg_flags);</span>
<span class="line-added">1028 }</span>
<span class="line-added">1029 #endif</span>
<span class="line-added">1030 </span>
1031 bool WhiteBox::compile_method(Method* method, int comp_level, int bci, Thread* THREAD) {
1032   // Screen for unavailable/bad comp level or null method
1033   AbstractCompiler* comp = CompileBroker::compiler(comp_level);
1034   if (method == NULL) {
1035     tty-&gt;print_cr(&quot;WB error: request to compile NULL method&quot;);
1036     return false;
1037   }
1038   if (comp_level &gt; highestCompLevel()) {
1039     tty-&gt;print_cr(&quot;WB error: invalid compilation level %d&quot;, comp_level);
1040     return false;
1041   }
1042   if (comp == NULL) {
1043     tty-&gt;print_cr(&quot;WB error: no compiler for requested compilation level %d&quot;, comp_level);
1044     return false;
1045   }
1046 
1047   // Check if compilation is blocking
1048   methodHandle mh(THREAD, method);
1049   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, comp);
1050   bool is_blocking = !directive-&gt;BackgroundCompilationOption;
</pre>
<hr />
<pre>
1498 
1499 CodeHeap* WhiteBox::get_code_heap(int blob_type) {
1500   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1501   return CodeCache::get_code_heap(blob_type);
1502 }
1503 
1504 struct CodeBlobStub {
1505   CodeBlobStub(const CodeBlob* blob) :
1506       name(os::strdup(blob-&gt;name())),
1507       size(blob-&gt;size()),
1508       blob_type(WhiteBox::get_blob_type(blob)),
1509       address((jlong) blob) { }
1510   ~CodeBlobStub() { os::free((void*) name); }
1511   const char* const name;
1512   const jint        size;
1513   const jint        blob_type;
1514   const jlong       address;
1515 };
1516 
1517 static jobjectArray codeBlob2objectArray(JavaThread* thread, JNIEnv* env, CodeBlobStub* cb) {
<span class="line-added">1518   ResourceMark rm;</span>
1519   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1520   CHECK_JNI_EXCEPTION_(env, NULL);
1521   jobjectArray result = env-&gt;NewObjectArray(4, clazz, NULL);
1522 
1523   jstring name = env-&gt;NewStringUTF(cb-&gt;name);
1524   CHECK_JNI_EXCEPTION_(env, NULL);
1525   env-&gt;SetObjectArrayElement(result, 0, name);
1526 
1527   jobject obj = integerBox(thread, env, cb-&gt;size);
1528   CHECK_JNI_EXCEPTION_(env, NULL);
1529   env-&gt;SetObjectArrayElement(result, 1, obj);
1530 
1531   obj = integerBox(thread, env, cb-&gt;blob_type);
1532   CHECK_JNI_EXCEPTION_(env, NULL);
1533   env-&gt;SetObjectArrayElement(result, 2, obj);
1534 
1535   obj = longBox(thread, env, cb-&gt;address);
1536   CHECK_JNI_EXCEPTION_(env, NULL);
1537   env-&gt;SetObjectArrayElement(result, 3, obj);
1538 
</pre>
<hr />
<pre>
2081   } else {
2082     return NULL;
2083   }
2084 WB_END
2085 
2086 WB_ENTRY(void, WB_LinkClass(JNIEnv* env, jobject wb, jclass clazz))
2087   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2088   if (!k-&gt;is_instance_klass()) {
2089     return;
2090   }
2091   InstanceKlass *ik = InstanceKlass::cast(k);
2092   ik-&gt;link_class(THREAD); // may throw verification error
2093 WB_END
2094 
2095 WB_ENTRY(jboolean, WB_AreOpenArchiveHeapObjectsMapped(JNIEnv* env))
2096   return HeapShared::open_archive_heap_region_mapped();
2097 WB_END
2098 
2099 WB_ENTRY(jboolean, WB_IsCDSIncludedInVmBuild(JNIEnv* env))
2100 #if INCLUDE_CDS






2101   return true;
2102 #else
2103   return false;
2104 #endif // INCLUDE_CDS
2105 WB_END
2106 
2107 WB_ENTRY(jboolean, WB_isC2OrJVMCIIncludedInVmBuild(JNIEnv* env))
2108 #if COMPILER2_OR_JVMCI
2109   return true;
2110 #else
2111   return false;
2112 #endif
2113 WB_END
2114 
2115 WB_ENTRY(jboolean, WB_IsJavaHeapArchiveSupported(JNIEnv* env))
2116   return HeapShared::is_heap_object_archiving_allowed();
2117 WB_END
2118 
2119 
2120 WB_ENTRY(jboolean, WB_IsJFRIncludedInVmBuild(JNIEnv* env))
</pre>
<hr />
<pre>
2274 
2275 // Checks that the library libfile has the noexecstack bit set.
2276 WB_ENTRY(jboolean, WB_CheckLibSpecifiesNoexecstack(JNIEnv* env, jobject o, jstring libfile))
2277   jboolean ret = false;
2278 #ifdef LINUX
2279   // Can&#39;t be in VM when we call JNI.
2280   ThreadToNativeFromVM ttnfv(thread);
2281   const char* lf = env-&gt;GetStringUTFChars(libfile, NULL);
2282   CHECK_JNI_EXCEPTION_(env, 0);
2283   ret = (jboolean) ElfFile::specifies_noexecstack(lf);
2284   env-&gt;ReleaseStringUTFChars(libfile, lf);
2285 #endif
2286   return ret;
2287 WB_END
2288 
2289 WB_ENTRY(jboolean, WB_IsContainerized(JNIEnv* env, jobject o))
2290   LINUX_ONLY(return OSContainer::is_containerized();)
2291   return false;
2292 WB_END
2293 
<span class="line-added">2294 WB_ENTRY(jint, WB_ValidateCgroup(JNIEnv* env,</span>
<span class="line-added">2295                                     jobject o,</span>
<span class="line-added">2296                                     jstring proc_cgroups,</span>
<span class="line-added">2297                                     jstring proc_self_cgroup,</span>
<span class="line-added">2298                                     jstring proc_self_mountinfo))</span>
<span class="line-added">2299   jint ret = 0;</span>
<span class="line-added">2300 #ifdef LINUX</span>
<span class="line-added">2301   ThreadToNativeFromVM ttnfv(thread);</span>
<span class="line-added">2302   const char* p_cgroups = env-&gt;GetStringUTFChars(proc_cgroups, NULL);</span>
<span class="line-added">2303   CHECK_JNI_EXCEPTION_(env, 0);</span>
<span class="line-added">2304   const char* p_s_cgroup = env-&gt;GetStringUTFChars(proc_self_cgroup, NULL);</span>
<span class="line-added">2305   CHECK_JNI_EXCEPTION_(env, 0);</span>
<span class="line-added">2306   const char* p_s_mountinfo = env-&gt;GetStringUTFChars(proc_self_mountinfo, NULL);</span>
<span class="line-added">2307   CHECK_JNI_EXCEPTION_(env, 0);</span>
<span class="line-added">2308   u1 cg_type_flags = 0;</span>
<span class="line-added">2309   // This sets cg_type_flags</span>
<span class="line-added">2310   WhiteBox::validate_cgroup(p_cgroups, p_s_cgroup, p_s_mountinfo, &amp;cg_type_flags);</span>
<span class="line-added">2311   ret = (jint)cg_type_flags;</span>
<span class="line-added">2312   env-&gt;ReleaseStringUTFChars(proc_cgroups, p_cgroups);</span>
<span class="line-added">2313   env-&gt;ReleaseStringUTFChars(proc_self_cgroup, p_s_cgroup);</span>
<span class="line-added">2314   env-&gt;ReleaseStringUTFChars(proc_self_mountinfo, p_s_mountinfo);</span>
<span class="line-added">2315 #endif</span>
<span class="line-added">2316   return ret;</span>
<span class="line-added">2317 WB_END</span>
<span class="line-added">2318 </span>
2319 WB_ENTRY(void, WB_PrintOsInfo(JNIEnv* env, jobject o))
2320   os::print_os_info(tty);
2321 WB_END
2322 
2323 // Elf decoder
2324 WB_ENTRY(void, WB_DisableElfSectionCache(JNIEnv* env))
2325 #if !defined(_WINDOWS) &amp;&amp; !defined(__APPLE__) &amp;&amp; !defined(_AIX)
2326   ElfFile::_do_not_cache_elf_section = true;
2327 #endif
2328 WB_END
2329 
2330 WB_ENTRY(jlong, WB_ResolvedMethodItemsCount(JNIEnv* env, jobject o))
2331   return (jlong) ResolvedMethodTable::items_count();
2332 WB_END
2333 
2334 WB_ENTRY(jint, WB_ProtectionDomainRemovedCount(JNIEnv* env, jobject o))
2335   return (jint) SystemDictionary::pd_cache_table()-&gt;removed_entries_count();
2336 WB_END
2337 
2338 WB_ENTRY(jint, WB_AotLibrariesCount(JNIEnv* env, jobject o))
</pre>
<hr />
<pre>
2569   {CC&quot;isShared&quot;,           CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsShared },
2570   {CC&quot;isSharedClass&quot;,      CC&quot;(Ljava/lang/Class;)Z&quot;,  (void*)&amp;WB_IsSharedClass },
2571   {CC&quot;areSharedStringsIgnored&quot;,           CC&quot;()Z&quot;,    (void*)&amp;WB_AreSharedStringsIgnored },
2572   {CC&quot;getResolvedReferences&quot;, CC&quot;(Ljava/lang/Class;)Ljava/lang/Object;&quot;, (void*)&amp;WB_GetResolvedReferences},
2573   {CC&quot;linkClass&quot;,          CC&quot;(Ljava/lang/Class;)V&quot;,  (void*)&amp;WB_LinkClass},
2574   {CC&quot;areOpenArchiveHeapObjectsMapped&quot;,   CC&quot;()Z&quot;,    (void*)&amp;WB_AreOpenArchiveHeapObjectsMapped},
2575   {CC&quot;isCDSIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsCDSIncludedInVmBuild },
2576   {CC&quot;isJFRIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsJFRIncludedInVmBuild },
2577   {CC&quot;isC2OrJVMCIIncludedInVmBuild&quot;,      CC&quot;()Z&quot;,    (void*)&amp;WB_isC2OrJVMCIIncludedInVmBuild },
2578   {CC&quot;isJavaHeapArchiveSupported&quot;,        CC&quot;()Z&quot;,    (void*)&amp;WB_IsJavaHeapArchiveSupported },
2579   {CC&quot;cdsMemoryMappingFailed&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_CDSMemoryMappingFailed },
2580 
2581   {CC&quot;clearInlineCaches0&quot;,  CC&quot;(Z)V&quot;,                 (void*)&amp;WB_ClearInlineCaches },
2582   {CC&quot;handshakeWalkStack&quot;, CC&quot;(Ljava/lang/Thread;Z)I&quot;, (void*)&amp;WB_HandshakeWalkStack },
2583   {CC&quot;addCompilerDirective&quot;,    CC&quot;(Ljava/lang/String;)I&quot;,
2584                                                       (void*)&amp;WB_AddCompilerDirective },
2585   {CC&quot;removeCompilerDirective&quot;,   CC&quot;(I)V&quot;,           (void*)&amp;WB_RemoveCompilerDirective },
2586   {CC&quot;isGCSupported&quot;,             CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSupported},
2587   {CC&quot;isGCSelected&quot;,              CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSelected},
2588   {CC&quot;isGCSelectedErgonomically&quot;, CC&quot;()Z&quot;,            (void*)&amp;WB_IsGCSelectedErgonomically},
<span class="line-modified">2589   {CC&quot;supportsConcurrentGCBreakpoints&quot;, CC&quot;()Z&quot;,      (void*)&amp;WB_SupportsConcurrentGCBreakpoints},</span>
<span class="line-modified">2590   {CC&quot;concurrentGCAcquireControl0&quot;, CC&quot;()V&quot;,          (void*)&amp;WB_ConcurrentGCAcquireControl},</span>
<span class="line-modified">2591   {CC&quot;concurrentGCReleaseControl0&quot;, CC&quot;()V&quot;,          (void*)&amp;WB_ConcurrentGCReleaseControl},</span>
<span class="line-added">2592   {CC&quot;concurrentGCRunToIdle0&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_ConcurrentGCRunToIdle},</span>
<span class="line-added">2593   {CC&quot;concurrentGCRunTo0&quot;,        CC&quot;(Ljava/lang/String;)Z&quot;,</span>
<span class="line-added">2594                                                       (void*)&amp;WB_ConcurrentGCRunTo},</span>
2595   {CC&quot;checkLibSpecifiesNoexecstack&quot;, CC&quot;(Ljava/lang/String;)Z&quot;,
2596                                                       (void*)&amp;WB_CheckLibSpecifiesNoexecstack},
2597   {CC&quot;isContainerized&quot;,           CC&quot;()Z&quot;,            (void*)&amp;WB_IsContainerized },
<span class="line-added">2598   {CC&quot;validateCgroup&quot;,</span>
<span class="line-added">2599       CC&quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I&quot;,</span>
<span class="line-added">2600                                                       (void*)&amp;WB_ValidateCgroup },</span>
2601   {CC&quot;printOsInfo&quot;,               CC&quot;()V&quot;,            (void*)&amp;WB_PrintOsInfo },
2602   {CC&quot;disableElfSectionCache&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_DisableElfSectionCache },
2603   {CC&quot;resolvedMethodItemsCount&quot;,  CC&quot;()J&quot;,            (void*)&amp;WB_ResolvedMethodItemsCount },
2604   {CC&quot;protectionDomainRemovedCount&quot;,   CC&quot;()I&quot;,       (void*)&amp;WB_ProtectionDomainRemovedCount },
2605   {CC&quot;aotLibrariesCount&quot;, CC&quot;()I&quot;,                    (void*)&amp;WB_AotLibrariesCount },
2606   {CC&quot;getKlassMetadataSize&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,(void*)&amp;WB_GetKlassMetadataSize},
2607 };
2608 
2609 
2610 #undef CC
2611 
2612 JVM_ENTRY(void, JVM_RegisterWhiteBoxMethods(JNIEnv* env, jclass wbclass))
2613   {
2614     if (WhiteBoxAPI) {
2615       // Make sure that wbclass is loaded by the null classloader
2616       InstanceKlass* ik = InstanceKlass::cast(JNIHandles::resolve(wbclass)-&gt;klass());
2617       Handle loader(THREAD, ik-&gt;class_loader());
2618       if (loader.is_null()) {
2619         WhiteBox::register_methods(env, wbclass, thread, methods, sizeof(methods) / sizeof(methods[0]));
2620         WhiteBox::set_used();
</pre>
</td>
</tr>
</table>
<center><a href="stackwalk.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="whitebox.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
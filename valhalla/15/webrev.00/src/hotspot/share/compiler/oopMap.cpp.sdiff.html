<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/compiler/oopMap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compileBroker.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopMap.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/compiler/oopMap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
152   set_xxx(reg, OopMapValue::narrowoop_value, VMRegImpl::Bad());
153 }
154 
155 
156 void OopMap::set_callee_saved(VMReg reg, VMReg caller_machine_register ) {
157   set_xxx(reg, OopMapValue::callee_saved_value, caller_machine_register);
158 }
159 
160 
161 void OopMap::set_derived_oop(VMReg reg, VMReg derived_from_local_register ) {
162   if( reg == derived_from_local_register ) {
163     // Actually an oop, derived shares storage with base,
164     set_oop(reg);
165   } else {
166     set_xxx(reg, OopMapValue::derived_oop_value, derived_from_local_register);
167   }
168 }
169 
170 // OopMapSet
171 
<span class="line-modified">172 OopMapSet::OopMapSet() {</span>
<span class="line-removed">173   set_om_size(MinOopMapAllocation);</span>
<span class="line-removed">174   set_om_count(0);</span>
<span class="line-removed">175   OopMap** temp = NEW_RESOURCE_ARRAY(OopMap*, om_size());</span>
<span class="line-removed">176   set_om_data(temp);</span>
<span class="line-removed">177 }</span>
<span class="line-removed">178 </span>
<span class="line-removed">179 </span>
<span class="line-removed">180 void OopMapSet::grow_om_data() {</span>
<span class="line-removed">181   int new_size = om_size() * 2;</span>
<span class="line-removed">182   OopMap** new_data = NEW_RESOURCE_ARRAY(OopMap*, new_size);</span>
<span class="line-removed">183   memcpy(new_data,om_data(),om_size() * sizeof(OopMap*));</span>
<span class="line-removed">184   set_om_size(new_size);</span>
<span class="line-removed">185   set_om_data(new_data);</span>
<span class="line-removed">186 }</span>
187 
188 void OopMapSet::add_gc_map(int pc_offset, OopMap *map ) {
<span class="line-removed">189   assert(om_size() != -1,&quot;Cannot grow a fixed OopMapSet&quot;);</span>
<span class="line-removed">190 </span>
<span class="line-removed">191   if(om_count() &gt;= om_size()) {</span>
<span class="line-removed">192     grow_om_data();</span>
<span class="line-removed">193   }</span>
194   map-&gt;set_offset(pc_offset);
195 
196 #ifdef ASSERT
<span class="line-modified">197   if(om_count() &gt; 0) {</span>
<span class="line-modified">198     OopMap* last = at(om_count()-1);</span>
199     if (last-&gt;offset() == map-&gt;offset() ) {
200       fatal(&quot;OopMap inserted twice&quot;);
201     }
<span class="line-modified">202     if(last-&gt;offset() &gt; map-&gt;offset()) {</span>
203       tty-&gt;print_cr( &quot;WARNING, maps not sorted: pc[%d]=%d, pc[%d]=%d&quot;,
<span class="line-modified">204                       om_count(),last-&gt;offset(),om_count()+1,map-&gt;offset());</span>
205     }
206   }
207 #endif // ASSERT
208 
<span class="line-modified">209   set(om_count(),map);</span>
<span class="line-removed">210   increment_count();</span>
<span class="line-removed">211 }</span>
<span class="line-removed">212 </span>
<span class="line-removed">213 </span>
<span class="line-removed">214 int OopMapSet::heap_size() const {</span>
<span class="line-removed">215   // The space we use</span>
<span class="line-removed">216   int size = sizeof(OopMap);</span>
<span class="line-removed">217   int align = sizeof(void *) - 1;</span>
<span class="line-removed">218   size = ((size+align) &amp; ~align);</span>
<span class="line-removed">219   size += om_count() * sizeof(OopMap*);</span>
<span class="line-removed">220 </span>
<span class="line-removed">221   // Now add in the space needed for the indivdiual OopMaps</span>
<span class="line-removed">222   for(int i=0; i &lt; om_count(); i++) {</span>
<span class="line-removed">223     size += at(i)-&gt;heap_size();</span>
<span class="line-removed">224   }</span>
<span class="line-removed">225   // We don&#39;t need to align this, it will be naturally pointer aligned</span>
<span class="line-removed">226   return size;</span>
<span class="line-removed">227 }</span>
<span class="line-removed">228 </span>
<span class="line-removed">229 </span>
<span class="line-removed">230 OopMap* OopMapSet::singular_oop_map() {</span>
<span class="line-removed">231   guarantee(om_count() == 1, &quot;Make sure we only have a single gc point&quot;);</span>
<span class="line-removed">232   return at(0);</span>
<span class="line-removed">233 }</span>
<span class="line-removed">234 </span>
<span class="line-removed">235 </span>
<span class="line-removed">236 OopMap* OopMapSet::find_map_at_offset(int pc_offset) const {</span>
<span class="line-removed">237   int i, len = om_count();</span>
<span class="line-removed">238   assert( len &gt; 0, &quot;must have pointer maps&quot; );</span>
<span class="line-removed">239 </span>
<span class="line-removed">240   // Scan through oopmaps. Stop when current offset is either equal or greater</span>
<span class="line-removed">241   // than the one we are looking for.</span>
<span class="line-removed">242   for( i = 0; i &lt; len; i++) {</span>
<span class="line-removed">243     if( at(i)-&gt;offset() &gt;= pc_offset )</span>
<span class="line-removed">244       break;</span>
<span class="line-removed">245   }</span>
<span class="line-removed">246 </span>
<span class="line-removed">247   assert( i &lt; len, &quot;oopmap not found&quot; );</span>
<span class="line-removed">248 </span>
<span class="line-removed">249   OopMap* m = at(i);</span>
<span class="line-removed">250   assert( m-&gt;offset() == pc_offset, &quot;oopmap not found&quot; );</span>
<span class="line-removed">251   return m;</span>
252 }
253 
254 static void add_derived_oop(oop* base, oop* derived) {
255 #if !defined(TIERED) &amp;&amp; !INCLUDE_JVMCI
256   COMPILER1_PRESENT(ShouldNotReachHere();)
257 #endif // !defined(TIERED) &amp;&amp; !INCLUDE_JVMCI
258 #if COMPILER2_OR_JVMCI
259   DerivedPointerTable::add(derived, base);
260 #endif // COMPILER2_OR_JVMCI
261 }
262 
263 
264 #ifndef PRODUCT
265 static void trace_codeblob_maps(const frame *fr, const RegisterMap *reg_map) {
266   // Print oopmap and regmap
267   tty-&gt;print_cr(&quot;------ &quot;);
268   CodeBlob* cb = fr-&gt;cb();
269   const ImmutableOopMapSet* maps = cb-&gt;oop_maps();
270   const ImmutableOopMap* map = cb-&gt;oop_map_for_return_address(fr-&gt;pc());
271   map-&gt;print();
</pre>
<hr />
<pre>
286   reg_map-&gt;print();
287   tty-&gt;print_cr(&quot;------ &quot;);
288 
289 }
290 #endif // PRODUCT
291 
292 void OopMapSet::oops_do(const frame *fr, const RegisterMap* reg_map, OopClosure* f) {
293   // add derived oops to a table
294   all_do(fr, reg_map, f, add_derived_oop, &amp;do_nothing_cl);
295 }
296 
297 
298 void OopMapSet::all_do(const frame *fr, const RegisterMap *reg_map,
299                        OopClosure* oop_fn, void derived_oop_fn(oop*, oop*),
300                        OopClosure* value_fn) {
301   CodeBlob* cb = fr-&gt;cb();
302   assert(cb != NULL, &quot;no codeblob&quot;);
303 
304   NOT_PRODUCT(if (TraceCodeBlobStacks) trace_codeblob_maps(fr, reg_map);)
305 
<span class="line-removed">306   const ImmutableOopMapSet* maps = cb-&gt;oop_maps();</span>
307   const ImmutableOopMap* map = cb-&gt;oop_map_for_return_address(fr-&gt;pc());
308   assert(map != NULL, &quot;no ptr map found&quot;);
309 
310   // handle derived pointers first (otherwise base pointer may be
311   // changed before derived pointer offset has been collected)
312   {
313     for (OopMapStream oms(map); !oms.is_done(); oms.next()) {
314       OopMapValue omv = oms.current();
315       if (omv.type() != OopMapValue::derived_oop_value) {
316         continue;
317       }
318 
319 #ifndef TIERED
320       COMPILER1_PRESENT(ShouldNotReachHere();)
321 #if INCLUDE_JVMCI
322       if (UseJVMCICompiler) {
323         ShouldNotReachHere();
324       }
325 #endif
326 #endif // !TIERED
</pre>
<hr />
<pre>
500 
501   st-&gt;print_cr(&quot;ImmutableOopMapSet contains %d OopMaps&quot;, len);
502 
503   for (int i = 0; i &lt; len; i++) {
504     const ImmutableOopMapPair* pair = pair_at(i);
505     const ImmutableOopMap* map = pair-&gt;get_from(this);
506     if (map != last) {
507       st-&gt;cr();
508       map-&gt;print_on(st);
509       st-&gt;print(&quot; pc offsets: &quot;);
510     }
511     last = map;
512     st-&gt;print(&quot;%d &quot;, pair-&gt;pc_offset());
513   }
514   st-&gt;cr();
515 }
516 
517 void ImmutableOopMapSet::print() const { print_on(tty); }
518 
519 void OopMapSet::print_on(outputStream* st) const {
<span class="line-modified">520   const int len = om_count();</span>
521 
522   st-&gt;print_cr(&quot;OopMapSet contains %d OopMaps&quot;, len);
523 
524   for( int i = 0; i &lt; len; i++) {
525     OopMap* m = at(i);
526     st-&gt;print_cr(&quot;#%d &quot;,i);
527     m-&gt;print_on(st);
528     st-&gt;cr();
529   }
530   st-&gt;cr();
531 }
532 
533 void OopMapSet::print() const { print_on(tty); }
534 
535 bool OopMap::equals(const OopMap* other) const {
536   if (other-&gt;_omv_count != _omv_count) {
537     return false;
538   }
539   if (other-&gt;write_stream()-&gt;position() != write_stream()-&gt;position()) {
540     return false;
</pre>
</td>
<td>
<hr />
<pre>
152   set_xxx(reg, OopMapValue::narrowoop_value, VMRegImpl::Bad());
153 }
154 
155 
156 void OopMap::set_callee_saved(VMReg reg, VMReg caller_machine_register ) {
157   set_xxx(reg, OopMapValue::callee_saved_value, caller_machine_register);
158 }
159 
160 
161 void OopMap::set_derived_oop(VMReg reg, VMReg derived_from_local_register ) {
162   if( reg == derived_from_local_register ) {
163     // Actually an oop, derived shares storage with base,
164     set_oop(reg);
165   } else {
166     set_xxx(reg, OopMapValue::derived_oop_value, derived_from_local_register);
167   }
168 }
169 
170 // OopMapSet
171 
<span class="line-modified">172 OopMapSet::OopMapSet() : _list(MinOopMapAllocation) {}</span>














173 
174 void OopMapSet::add_gc_map(int pc_offset, OopMap *map ) {





175   map-&gt;set_offset(pc_offset);
176 
177 #ifdef ASSERT
<span class="line-modified">178   if(_list.length() &gt; 0) {</span>
<span class="line-modified">179     OopMap* last = _list.last();</span>
180     if (last-&gt;offset() == map-&gt;offset() ) {
181       fatal(&quot;OopMap inserted twice&quot;);
182     }
<span class="line-modified">183     if (last-&gt;offset() &gt; map-&gt;offset()) {</span>
184       tty-&gt;print_cr( &quot;WARNING, maps not sorted: pc[%d]=%d, pc[%d]=%d&quot;,
<span class="line-modified">185                       _list.length(),last-&gt;offset(),_list.length()+1,map-&gt;offset());</span>
186     }
187   }
188 #endif // ASSERT
189 
<span class="line-modified">190   add(map);</span>










































191 }
192 
193 static void add_derived_oop(oop* base, oop* derived) {
194 #if !defined(TIERED) &amp;&amp; !INCLUDE_JVMCI
195   COMPILER1_PRESENT(ShouldNotReachHere();)
196 #endif // !defined(TIERED) &amp;&amp; !INCLUDE_JVMCI
197 #if COMPILER2_OR_JVMCI
198   DerivedPointerTable::add(derived, base);
199 #endif // COMPILER2_OR_JVMCI
200 }
201 
202 
203 #ifndef PRODUCT
204 static void trace_codeblob_maps(const frame *fr, const RegisterMap *reg_map) {
205   // Print oopmap and regmap
206   tty-&gt;print_cr(&quot;------ &quot;);
207   CodeBlob* cb = fr-&gt;cb();
208   const ImmutableOopMapSet* maps = cb-&gt;oop_maps();
209   const ImmutableOopMap* map = cb-&gt;oop_map_for_return_address(fr-&gt;pc());
210   map-&gt;print();
</pre>
<hr />
<pre>
225   reg_map-&gt;print();
226   tty-&gt;print_cr(&quot;------ &quot;);
227 
228 }
229 #endif // PRODUCT
230 
231 void OopMapSet::oops_do(const frame *fr, const RegisterMap* reg_map, OopClosure* f) {
232   // add derived oops to a table
233   all_do(fr, reg_map, f, add_derived_oop, &amp;do_nothing_cl);
234 }
235 
236 
237 void OopMapSet::all_do(const frame *fr, const RegisterMap *reg_map,
238                        OopClosure* oop_fn, void derived_oop_fn(oop*, oop*),
239                        OopClosure* value_fn) {
240   CodeBlob* cb = fr-&gt;cb();
241   assert(cb != NULL, &quot;no codeblob&quot;);
242 
243   NOT_PRODUCT(if (TraceCodeBlobStacks) trace_codeblob_maps(fr, reg_map);)
244 

245   const ImmutableOopMap* map = cb-&gt;oop_map_for_return_address(fr-&gt;pc());
246   assert(map != NULL, &quot;no ptr map found&quot;);
247 
248   // handle derived pointers first (otherwise base pointer may be
249   // changed before derived pointer offset has been collected)
250   {
251     for (OopMapStream oms(map); !oms.is_done(); oms.next()) {
252       OopMapValue omv = oms.current();
253       if (omv.type() != OopMapValue::derived_oop_value) {
254         continue;
255       }
256 
257 #ifndef TIERED
258       COMPILER1_PRESENT(ShouldNotReachHere();)
259 #if INCLUDE_JVMCI
260       if (UseJVMCICompiler) {
261         ShouldNotReachHere();
262       }
263 #endif
264 #endif // !TIERED
</pre>
<hr />
<pre>
438 
439   st-&gt;print_cr(&quot;ImmutableOopMapSet contains %d OopMaps&quot;, len);
440 
441   for (int i = 0; i &lt; len; i++) {
442     const ImmutableOopMapPair* pair = pair_at(i);
443     const ImmutableOopMap* map = pair-&gt;get_from(this);
444     if (map != last) {
445       st-&gt;cr();
446       map-&gt;print_on(st);
447       st-&gt;print(&quot; pc offsets: &quot;);
448     }
449     last = map;
450     st-&gt;print(&quot;%d &quot;, pair-&gt;pc_offset());
451   }
452   st-&gt;cr();
453 }
454 
455 void ImmutableOopMapSet::print() const { print_on(tty); }
456 
457 void OopMapSet::print_on(outputStream* st) const {
<span class="line-modified">458   const int len = _list.length();</span>
459 
460   st-&gt;print_cr(&quot;OopMapSet contains %d OopMaps&quot;, len);
461 
462   for( int i = 0; i &lt; len; i++) {
463     OopMap* m = at(i);
464     st-&gt;print_cr(&quot;#%d &quot;,i);
465     m-&gt;print_on(st);
466     st-&gt;cr();
467   }
468   st-&gt;cr();
469 }
470 
471 void OopMapSet::print() const { print_on(tty); }
472 
473 bool OopMap::equals(const OopMap* other) const {
474   if (other-&gt;_omv_count != _omv_count) {
475     return false;
476   }
477   if (other-&gt;write_stream()-&gt;position() != write_stream()-&gt;position()) {
478     return false;
</pre>
</td>
</tr>
</table>
<center><a href="compileBroker.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopMap.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
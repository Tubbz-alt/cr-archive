diff a/src/hotspot/share/compiler/compileBroker.cpp b/src/hotspot/share/compiler/compileBroker.cpp
--- a/src/hotspot/share/compiler/compileBroker.cpp
+++ b/src/hotspot/share/compiler/compileBroker.cpp
@@ -31,14 +31,14 @@
 #include "code/codeHeapState.hpp"
 #include "code/dependencyContext.hpp"
 #include "compiler/compilationPolicy.hpp"
 #include "compiler/compileBroker.hpp"
 #include "compiler/compileLog.hpp"
+#include "compiler/compilerEvent.hpp"
 #include "compiler/compilerOracle.hpp"
 #include "compiler/directivesParser.hpp"
 #include "interpreter/linkResolver.hpp"
-#include "jfr/jfrEvents.hpp"
 #include "logging/log.hpp"
 #include "logging/logStream.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
@@ -590,10 +590,38 @@
 CompilerCounters::CompilerCounters() {
   _current_method[0] = '\0';
   _compile_type = CompileBroker::no_compile;
 }
 
+#if INCLUDE_JFR
+// It appends new compiler phase names to growable array phase_names(a new CompilerPhaseType mapping
+// in compiler/compilerEvent.cpp) and registers it with its serializer.
+//
+// c2 uses explicit CompilerPhaseType idToPhase mapping in opto/phasetype.hpp,
+// so if c2 is used, it should be always registered first.
+// This function is called during vm initialization.
+void register_jfr_phasetype_serializer(CompilerType compiler_type) {
+  ResourceMark rm;
+  static bool first_registration = true;
+  if (compiler_type == compiler_jvmci) {
+    // register serializer, phases will be added later lazily.
+    GrowableArray<const char*>* jvmci_phase_names = new GrowableArray<const char*>(1);
+    jvmci_phase_names->append("NOT_A_PHASE_NAME");
+    CompilerEvent::PhaseEvent::register_phases(jvmci_phase_names);
+    first_registration = false;
+  } else if (compiler_type == compiler_c2) {
+    assert(first_registration, "invariant"); // c2 must be registered first.
+    GrowableArray<const char*>* c2_phase_names = new GrowableArray<const char*>(PHASE_NUM_TYPES);
+    for (int i = 0; i < PHASE_NUM_TYPES; i++) {
+      c2_phase_names->append(CompilerPhaseTypeHelper::to_string((CompilerPhaseType)i));
+    }
+    CompilerEvent::PhaseEvent::register_phases(c2_phase_names);
+    first_registration = false;
+  }
+}
+#endif // INCLUDE_JFR
+
 // ------------------------------------------------------------------
 // CompileBroker::compilation_init
 //
 // Initialize the Compilation object
 void CompileBroker::compilation_init_phase1(Thread* THREAD) {
@@ -636,14 +664,25 @@
 
 #ifdef COMPILER2
   if (true JVMCI_ONLY( && !UseJVMCICompiler)) {
     if (_c2_count > 0) {
       _compilers[1] = new C2Compiler();
+      // Register c2 first as c2 CompilerPhaseType idToPhase mapping is explicit.
+      // idToPhase mapping for c2 is in opto/phasetype.hpp
+      JFR_ONLY(register_jfr_phasetype_serializer(compiler_c2);)
     }
   }
 #endif // COMPILER2
 
+#if INCLUDE_JVMCI
+   // Register after c2 registration.
+   // JVMCI CompilerPhaseType idToPhase mapping is dynamic.
+   if (EnableJVMCI) {
+     JFR_ONLY(register_jfr_phasetype_serializer(compiler_jvmci);)
+   }
+#endif // INCLUDE_JVMCI
+
   // Start the compiler thread(s) and the sweeper thread
   init_compiler_sweeper_threads();
   // totalTime performance counter is always created as it is required
   // by the implementation of java.lang.management.CompilationMBean.
   {
@@ -1326,10 +1365,11 @@
   }
 
   // do the compilation
   if (method->is_native()) {
     if (!PreferInterpreterNativeStubs || method->is_method_handle_intrinsic()) {
+#if defined(X86) && !defined(ZERO)
       // The following native methods:
       //
       // java.lang.Float.intBitsToFloat
       // java.lang.Float.floatToRawIntBits
       // java.lang.Double.longBitsToDouble
@@ -1347,10 +1387,11 @@
           (UseSSE >= 2 &&
            (method->intrinsic_id() == vmIntrinsics::_longBitsToDouble ||
             method->intrinsic_id() == vmIntrinsics::_doubleToRawLongBits))) {
         return NULL;
       }
+#endif // X86 && !ZERO
 
       // To properly handle the appendix argument for out-of-line calls we are using a small trampoline that
       // pops off the appendix argument and jumps to the target (see gen_special_dispatch in SharedRuntime).
       //
       // Since normal compiled-to-compiled calls are not able to handle such a thing we MUST generate an adapter
@@ -2014,23 +2055,21 @@
   }
   // simulate crash during compilation
   assert(task->compile_id() != CICrashAt, "just as planned");
 }
 
-static void post_compilation_event(EventCompilation* event, CompileTask* task) {
-  assert(event != NULL, "invariant");
-  assert(event->should_commit(), "invariant");
+static void post_compilation_event(EventCompilation& event, CompileTask* task) {
   assert(task != NULL, "invariant");
-  event->set_compileId(task->compile_id());
-  event->set_compiler(task->compiler()->type());
-  event->set_method(task->method());
-  event->set_compileLevel(task->comp_level());
-  event->set_succeded(task->is_success());
-  event->set_isOsr(task->osr_bci() != CompileBroker::standard_entry_bci);
-  event->set_codeSize((task->code() == NULL) ? 0 : task->code()->total_size());
-  event->set_inlinedBytes(task->num_inlined_bytecodes());
-  event->commit();
+  CompilerEvent::CompilationEvent::post(event,
+                                        task->compile_id(),
+                                        task->compiler()->type(),
+                                        task->method(),
+                                        task->comp_level(),
+                                        task->is_success(),
+                                        task->osr_bci() != CompileBroker::standard_entry_bci,
+                                        (task->code() == NULL) ? 0 : task->code()->total_size(),
+                                        task->num_inlined_bytecodes());
 }
 
 int DirectivesStack::_depth = 0;
 CompilerDirectives* DirectivesStack::_top = NULL;
 CompilerDirectives* DirectivesStack::_bottom = NULL;
@@ -2125,11 +2164,11 @@
         assert(failure_reason != NULL, "must specify failure_reason");
       }
     }
     post_compile(thread, task, task->code() != NULL, NULL, compilable, failure_reason);
     if (event.should_commit()) {
-      post_compilation_event(&event, task);
+      post_compilation_event(event, task);
     }
 
   } else
 #endif // INCLUDE_JVMCI
   {
@@ -2185,11 +2224,11 @@
       ci_env.report_failure(failure_reason);
     }
 
     post_compile(thread, task, !ci_env.failing(), &ci_env, compilable, failure_reason);
     if (event.should_commit()) {
-      post_compilation_event(&event, task);
+      post_compilation_event(event, task);
     }
   }
   // Remove the JNI handle block after the ciEnv destructor has run in
   // the previous block.
   pop_jni_handle_block();

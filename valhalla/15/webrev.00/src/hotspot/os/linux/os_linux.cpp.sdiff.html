<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/os_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="cgroupSubsystem_linux.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../solaris/os_solaris.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2285   st-&gt;print_cr(&quot;/proc/sys/kernel/threads-max (system-wide limit on the number of threads):&quot;);
2286   _print_ascii_file(&quot;/proc/sys/kernel/threads-max&quot;, st);
2287   st-&gt;cr();
2288   st-&gt;cr();
2289 
2290   st-&gt;print_cr(&quot;/proc/sys/vm/max_map_count (maximum number of memory map areas a process may have):&quot;);
2291   _print_ascii_file(&quot;/proc/sys/vm/max_map_count&quot;, st);
2292   st-&gt;cr();
2293   st-&gt;cr();
2294 
2295   st-&gt;print_cr(&quot;/proc/sys/kernel/pid_max (system-wide limit on number of process identifiers):&quot;);
2296   _print_ascii_file(&quot;/proc/sys/kernel/pid_max&quot;, st);
2297   st-&gt;cr();
2298   st-&gt;cr();
2299 }
2300 
2301 void os::Linux::print_full_memory_info(outputStream* st) {
2302   st-&gt;print(&quot;\n/proc/meminfo:\n&quot;);
2303   _print_ascii_file(&quot;/proc/meminfo&quot;, st);
2304   st-&gt;cr();













2305 }
2306 
2307 void os::Linux::print_ld_preload_file(outputStream* st) {
2308   _print_ascii_file(&quot;/etc/ld.so.preload&quot;, st, &quot;\n/etc/ld.so.preload:&quot;);
2309   st-&gt;cr();
2310 }
2311 
2312 void os::Linux::print_uptime_info(outputStream* st) {
2313   struct sysinfo sinfo;
2314   int ret = sysinfo(&amp;sinfo);
2315   if (ret == 0) {
2316     os::print_dhm(st, &quot;OS uptime:&quot;, (long) sinfo.uptime);
2317   }
2318 }
2319 
2320 
2321 void os::Linux::print_container_info(outputStream* st) {
2322   if (!OSContainer::is_containerized()) {
2323     return;
2324   }
</pre>
<hr />
<pre>
4115   return start;
4116 }
4117 
4118 char* os::Linux::reserve_memory_special_huge_tlbfs(size_t bytes,
4119                                                    size_t alignment,
4120                                                    char* req_addr,
4121                                                    bool exec) {
4122   assert(UseLargePages &amp;&amp; UseHugeTLBFS, &quot;only for Huge TLBFS large pages&quot;);
4123   assert(is_aligned(req_addr, alignment), &quot;Must be&quot;);
4124   assert(is_aligned(alignment, os::vm_allocation_granularity()), &quot;Must be&quot;);
4125   assert(is_power_of_2(os::large_page_size()), &quot;Must be&quot;);
4126   assert(bytes &gt;= os::large_page_size(), &quot;Shouldn&#39;t allocate large pages for small sizes&quot;);
4127 
4128   if (is_aligned(bytes, os::large_page_size()) &amp;&amp; alignment &lt;= os::large_page_size()) {
4129     return reserve_memory_special_huge_tlbfs_only(bytes, req_addr, exec);
4130   } else {
4131     return reserve_memory_special_huge_tlbfs_mixed(bytes, alignment, req_addr, exec);
4132   }
4133 }
4134 
<span class="line-modified">4135 char* os::reserve_memory_special(size_t bytes, size_t alignment,</span>
<span class="line-modified">4136                                  char* req_addr, bool exec) {</span>
4137   assert(UseLargePages, &quot;only for large pages&quot;);
4138 
4139   char* addr;
4140   if (UseSHM) {
4141     addr = os::Linux::reserve_memory_special_shm(bytes, alignment, req_addr, exec);
4142   } else {
4143     assert(UseHugeTLBFS, &quot;must be&quot;);
4144     addr = os::Linux::reserve_memory_special_huge_tlbfs(bytes, alignment, req_addr, exec);
4145   }
4146 
4147   if (addr != NULL) {
4148     if (UseNUMAInterleaving) {
4149       numa_make_global(addr, bytes);
4150     }
<span class="line-removed">4151 </span>
<span class="line-removed">4152     // The memory is committed</span>
<span class="line-removed">4153     MemTracker::record_virtual_memory_reserve_and_commit((address)addr, bytes, CALLER_PC);</span>
4154   }
4155 
4156   return addr;
4157 }
4158 
4159 bool os::Linux::release_memory_special_shm(char* base, size_t bytes) {
4160   // detaching the SHM segment will also delete it, see reserve_memory_special_shm()
4161   return shmdt(base) == 0;
4162 }
4163 
4164 bool os::Linux::release_memory_special_huge_tlbfs(char* base, size_t bytes) {
4165   return pd_release_memory(base, bytes);
4166 }
4167 
<span class="line-modified">4168 bool os::release_memory_special(char* base, size_t bytes) {</span>
<span class="line-removed">4169   bool res;</span>
<span class="line-removed">4170   if (MemTracker::tracking_level() &gt; NMT_minimal) {</span>
<span class="line-removed">4171     Tracker tkr(Tracker::release);</span>
<span class="line-removed">4172     res = os::Linux::release_memory_special_impl(base, bytes);</span>
<span class="line-removed">4173     if (res) {</span>
<span class="line-removed">4174       tkr.record((address)base, bytes);</span>
<span class="line-removed">4175     }</span>
<span class="line-removed">4176 </span>
<span class="line-removed">4177   } else {</span>
<span class="line-removed">4178     res = os::Linux::release_memory_special_impl(base, bytes);</span>
<span class="line-removed">4179   }</span>
<span class="line-removed">4180   return res;</span>
<span class="line-removed">4181 }</span>
<span class="line-removed">4182 </span>
<span class="line-removed">4183 bool os::Linux::release_memory_special_impl(char* base, size_t bytes) {</span>
4184   assert(UseLargePages, &quot;only for large pages&quot;);
4185   bool res;
4186 
4187   if (UseSHM) {
4188     res = os::Linux::release_memory_special_shm(base, bytes);
4189   } else {
4190     assert(UseHugeTLBFS, &quot;must be&quot;);
4191     res = os::Linux::release_memory_special_huge_tlbfs(base, bytes);
4192   }
4193   return res;
4194 }
4195 
4196 size_t os::large_page_size() {
4197   return _large_page_size;
4198 }
4199 
4200 // With SysV SHM the entire memory region must be allocated as shared
4201 // memory.
4202 // HugeTLBFS allows application to commit large page memory on demand.
4203 // However, when committing memory with HugeTLBFS fails, the region
</pre>
<hr />
<pre>
4302    4,              // 1 MinPriority
4303    3,              // 2
4304    2,              // 3
4305 
4306    1,              // 4
4307    0,              // 5 NormPriority
4308   -1,              // 6
4309 
4310   -2,              // 7
4311   -3,              // 8
4312   -4,              // 9 NearMaxPriority
4313 
4314   -5,              // 10 MaxPriority
4315 
4316   -5               // 11 CriticalPriority
4317 };
4318 
4319 static int prio_init() {
4320   if (ThreadPriorityPolicy == 1) {
4321     if (geteuid() != 0) {
<span class="line-modified">4322       if (!FLAG_IS_DEFAULT(ThreadPriorityPolicy)) {</span>
4323         warning(&quot;-XX:ThreadPriorityPolicy=1 may require system level permission, &quot; \
4324                 &quot;e.g., being the root user. If the necessary permission is not &quot; \
4325                 &quot;possessed, changes to priority will be silently ignored.&quot;);
4326       }
4327     }
4328   }
4329   if (UseCriticalJavaThreadPriority) {
4330     os::java_to_os_priority[MaxPriority] = os::java_to_os_priority[CriticalPriority];
4331   }
4332   return 0;
4333 }
4334 
4335 OSReturn os::set_native_priority(Thread* thread, int newpri) {
4336   if (!UseThreadPriorities || ThreadPriorityPolicy == 0) return OS_OK;
4337 
4338   int ret = setpriority(PRIO_PROCESS, thread-&gt;osthread()-&gt;thread_id(), newpri);
4339   return (ret == 0) ? OS_OK : OS_ERR;
4340 }
4341 
4342 OSReturn os::get_native_priority(const Thread* const thread,
</pre>
</td>
<td>
<hr />
<pre>
2285   st-&gt;print_cr(&quot;/proc/sys/kernel/threads-max (system-wide limit on the number of threads):&quot;);
2286   _print_ascii_file(&quot;/proc/sys/kernel/threads-max&quot;, st);
2287   st-&gt;cr();
2288   st-&gt;cr();
2289 
2290   st-&gt;print_cr(&quot;/proc/sys/vm/max_map_count (maximum number of memory map areas a process may have):&quot;);
2291   _print_ascii_file(&quot;/proc/sys/vm/max_map_count&quot;, st);
2292   st-&gt;cr();
2293   st-&gt;cr();
2294 
2295   st-&gt;print_cr(&quot;/proc/sys/kernel/pid_max (system-wide limit on number of process identifiers):&quot;);
2296   _print_ascii_file(&quot;/proc/sys/kernel/pid_max&quot;, st);
2297   st-&gt;cr();
2298   st-&gt;cr();
2299 }
2300 
2301 void os::Linux::print_full_memory_info(outputStream* st) {
2302   st-&gt;print(&quot;\n/proc/meminfo:\n&quot;);
2303   _print_ascii_file(&quot;/proc/meminfo&quot;, st);
2304   st-&gt;cr();
<span class="line-added">2305 </span>
<span class="line-added">2306   // some information regarding THPs; for details see</span>
<span class="line-added">2307   // https://www.kernel.org/doc/Documentation/vm/transhuge.txt</span>
<span class="line-added">2308   st-&gt;print_cr(&quot;/sys/kernel/mm/transparent_hugepage/enabled:&quot;);</span>
<span class="line-added">2309   if (!_print_ascii_file(&quot;/sys/kernel/mm/transparent_hugepage/enabled&quot;, st)) {</span>
<span class="line-added">2310     st-&gt;print_cr(&quot;  &lt;Not Available&gt;&quot;);</span>
<span class="line-added">2311   }</span>
<span class="line-added">2312   st-&gt;cr();</span>
<span class="line-added">2313   st-&gt;print_cr(&quot;/sys/kernel/mm/transparent_hugepage/defrag (defrag/compaction efforts parameter):&quot;);</span>
<span class="line-added">2314   if (!_print_ascii_file(&quot;/sys/kernel/mm/transparent_hugepage/defrag&quot;, st)) {</span>
<span class="line-added">2315     st-&gt;print_cr(&quot;  &lt;Not Available&gt;&quot;);</span>
<span class="line-added">2316   }</span>
<span class="line-added">2317   st-&gt;cr();</span>
2318 }
2319 
2320 void os::Linux::print_ld_preload_file(outputStream* st) {
2321   _print_ascii_file(&quot;/etc/ld.so.preload&quot;, st, &quot;\n/etc/ld.so.preload:&quot;);
2322   st-&gt;cr();
2323 }
2324 
2325 void os::Linux::print_uptime_info(outputStream* st) {
2326   struct sysinfo sinfo;
2327   int ret = sysinfo(&amp;sinfo);
2328   if (ret == 0) {
2329     os::print_dhm(st, &quot;OS uptime:&quot;, (long) sinfo.uptime);
2330   }
2331 }
2332 
2333 
2334 void os::Linux::print_container_info(outputStream* st) {
2335   if (!OSContainer::is_containerized()) {
2336     return;
2337   }
</pre>
<hr />
<pre>
4128   return start;
4129 }
4130 
4131 char* os::Linux::reserve_memory_special_huge_tlbfs(size_t bytes,
4132                                                    size_t alignment,
4133                                                    char* req_addr,
4134                                                    bool exec) {
4135   assert(UseLargePages &amp;&amp; UseHugeTLBFS, &quot;only for Huge TLBFS large pages&quot;);
4136   assert(is_aligned(req_addr, alignment), &quot;Must be&quot;);
4137   assert(is_aligned(alignment, os::vm_allocation_granularity()), &quot;Must be&quot;);
4138   assert(is_power_of_2(os::large_page_size()), &quot;Must be&quot;);
4139   assert(bytes &gt;= os::large_page_size(), &quot;Shouldn&#39;t allocate large pages for small sizes&quot;);
4140 
4141   if (is_aligned(bytes, os::large_page_size()) &amp;&amp; alignment &lt;= os::large_page_size()) {
4142     return reserve_memory_special_huge_tlbfs_only(bytes, req_addr, exec);
4143   } else {
4144     return reserve_memory_special_huge_tlbfs_mixed(bytes, alignment, req_addr, exec);
4145   }
4146 }
4147 
<span class="line-modified">4148 char* os::pd_reserve_memory_special(size_t bytes, size_t alignment,</span>
<span class="line-modified">4149                                     char* req_addr, bool exec) {</span>
4150   assert(UseLargePages, &quot;only for large pages&quot;);
4151 
4152   char* addr;
4153   if (UseSHM) {
4154     addr = os::Linux::reserve_memory_special_shm(bytes, alignment, req_addr, exec);
4155   } else {
4156     assert(UseHugeTLBFS, &quot;must be&quot;);
4157     addr = os::Linux::reserve_memory_special_huge_tlbfs(bytes, alignment, req_addr, exec);
4158   }
4159 
4160   if (addr != NULL) {
4161     if (UseNUMAInterleaving) {
4162       numa_make_global(addr, bytes);
4163     }



4164   }
4165 
4166   return addr;
4167 }
4168 
4169 bool os::Linux::release_memory_special_shm(char* base, size_t bytes) {
4170   // detaching the SHM segment will also delete it, see reserve_memory_special_shm()
4171   return shmdt(base) == 0;
4172 }
4173 
4174 bool os::Linux::release_memory_special_huge_tlbfs(char* base, size_t bytes) {
4175   return pd_release_memory(base, bytes);
4176 }
4177 
<span class="line-modified">4178 bool os::pd_release_memory_special(char* base, size_t bytes) {</span>















4179   assert(UseLargePages, &quot;only for large pages&quot;);
4180   bool res;
4181 
4182   if (UseSHM) {
4183     res = os::Linux::release_memory_special_shm(base, bytes);
4184   } else {
4185     assert(UseHugeTLBFS, &quot;must be&quot;);
4186     res = os::Linux::release_memory_special_huge_tlbfs(base, bytes);
4187   }
4188   return res;
4189 }
4190 
4191 size_t os::large_page_size() {
4192   return _large_page_size;
4193 }
4194 
4195 // With SysV SHM the entire memory region must be allocated as shared
4196 // memory.
4197 // HugeTLBFS allows application to commit large page memory on demand.
4198 // However, when committing memory with HugeTLBFS fails, the region
</pre>
<hr />
<pre>
4297    4,              // 1 MinPriority
4298    3,              // 2
4299    2,              // 3
4300 
4301    1,              // 4
4302    0,              // 5 NormPriority
4303   -1,              // 6
4304 
4305   -2,              // 7
4306   -3,              // 8
4307   -4,              // 9 NearMaxPriority
4308 
4309   -5,              // 10 MaxPriority
4310 
4311   -5               // 11 CriticalPriority
4312 };
4313 
4314 static int prio_init() {
4315   if (ThreadPriorityPolicy == 1) {
4316     if (geteuid() != 0) {
<span class="line-modified">4317       if (!FLAG_IS_DEFAULT(ThreadPriorityPolicy) &amp;&amp; !FLAG_IS_JIMAGE_RESOURCE(ThreadPriorityPolicy)) {</span>
4318         warning(&quot;-XX:ThreadPriorityPolicy=1 may require system level permission, &quot; \
4319                 &quot;e.g., being the root user. If the necessary permission is not &quot; \
4320                 &quot;possessed, changes to priority will be silently ignored.&quot;);
4321       }
4322     }
4323   }
4324   if (UseCriticalJavaThreadPriority) {
4325     os::java_to_os_priority[MaxPriority] = os::java_to_os_priority[CriticalPriority];
4326   }
4327   return 0;
4328 }
4329 
4330 OSReturn os::set_native_priority(Thread* thread, int newpri) {
4331   if (!UseThreadPriorities || ThreadPriorityPolicy == 0) return OS_OK;
4332 
4333   int ret = setpriority(PRIO_PROCESS, thread-&gt;osthread()-&gt;thread_id(), newpri);
4334   return (ret == 0) ? OS_OK : OS_ERR;
4335 }
4336 
4337 OSReturn os::get_native_priority(const Thread* const thread,
</pre>
</td>
</tr>
</table>
<center><a href="cgroupSubsystem_linux.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../solaris/os_solaris.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
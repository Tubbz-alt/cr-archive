<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/windows/os_windows.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../solaris/os_solaris.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../os_cpu/solaris_x86/thread_solaris_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/windows/os_windows.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3159 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {
3160   assert(file_desc &gt;= 0, &quot;file_desc is not valid&quot;);
3161   return map_memory_to_file(requested_addr, bytes, file_desc);
3162 }
3163 
3164 size_t os::large_page_size() {
3165   return _large_page_size;
3166 }
3167 
3168 bool os::can_commit_large_page_memory() {
3169   // Windows only uses large page memory when the entire region is reserved
3170   // and committed in a single VirtualAlloc() call. This may change in the
3171   // future, but with Windows 2003 it&#39;s not possible to commit on demand.
3172   return false;
3173 }
3174 
3175 bool os::can_execute_large_page_memory() {
3176   return true;
3177 }
3178 
<span class="line-modified">3179 char* os::reserve_memory_special(size_t bytes, size_t alignment, char* addr,</span>
<span class="line-modified">3180                                  bool exec) {</span>
3181   assert(UseLargePages, &quot;only for large pages&quot;);
3182 
3183   if (!is_aligned(bytes, os::large_page_size()) || alignment &gt; os::large_page_size()) {
3184     return NULL; // Fallback to small pages.
3185   }
3186 
3187   const DWORD prot = exec ? PAGE_EXECUTE_READWRITE : PAGE_READWRITE;
3188   const DWORD flags = MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES;
3189 
3190   // with large pages, there are two cases where we need to use Individual Allocation
3191   // 1) the UseLargePagesIndividualAllocation flag is set (set by default on WS2003)
3192   // 2) NUMA Interleaving is enabled, in which case we use a different node for each page
3193   if (UseLargePagesIndividualAllocation || UseNUMAInterleaving) {
3194     log_debug(pagesize)(&quot;Reserving large pages individually.&quot;);
3195 
3196     char * p_buf = allocate_pages_individually(bytes, addr, flags, prot, LargePagesIndividualAllocationInjectError);
3197     if (p_buf == NULL) {
3198       // give an appropriate warning message
3199       if (UseNUMAInterleaving) {
3200         warning(&quot;NUMA large page allocation failed, UseLargePages flag ignored&quot;);
3201       }
3202       if (UseLargePagesIndividualAllocation) {
3203         warning(&quot;Individually allocated large pages failed, &quot;
3204                 &quot;use -XX:-UseLargePagesIndividualAllocation to turn off&quot;);
3205       }
3206       return NULL;
3207     }
3208 
3209     return p_buf;
3210 
3211   } else {
3212     log_debug(pagesize)(&quot;Reserving large pages in a single large chunk.&quot;);
3213 
3214     // normal policy just allocate it all at once
3215     DWORD flag = MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES;
3216     char * res = (char *)VirtualAlloc(addr, bytes, flag, prot);
<span class="line-removed">3217     if (res != NULL) {</span>
<span class="line-removed">3218       MemTracker::record_virtual_memory_reserve_and_commit((address)res, bytes, CALLER_PC);</span>
<span class="line-removed">3219     }</span>
3220 
3221     return res;
3222   }
3223 }
3224 
<span class="line-modified">3225 bool os::release_memory_special(char* base, size_t bytes) {</span>
3226   assert(base != NULL, &quot;Sanity check&quot;);
<span class="line-modified">3227   return release_memory(base, bytes);</span>
3228 }
3229 
3230 void os::print_statistics() {
3231 }
3232 
3233 static void warn_fail_commit_memory(char* addr, size_t bytes, bool exec) {
3234   int err = os::get_last_error();
3235   char buf[256];
3236   size_t buf_len = os::lasterror(buf, sizeof(buf));
3237   warning(&quot;INFO: os::commit_memory(&quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT
3238           &quot;, %d) failed; error=&#39;%s&#39; (DOS error/errno=%d)&quot;, addr, bytes,
3239           exec, buf_len != 0 ? buf : &quot;&lt;no_error_string&gt;&quot;, err);
3240 }
3241 
3242 bool os::pd_commit_memory(char* addr, size_t bytes, bool exec) {
3243   if (bytes == 0) {
3244     // Don&#39;t bother the OS with noops.
3245     return true;
3246   }
3247   assert((size_t) addr % os::vm_page_size() == 0, &quot;commit on page boundaries&quot;);
</pre>
<hr />
<pre>
4144   return value;
4145 }
4146 
4147 // Transfers data from WIN32_FILE_ATTRIBUTE_DATA structure to struct stat
4148 static void file_attribute_data_to_stat(struct stat* sbuf, WIN32_FILE_ATTRIBUTE_DATA file_data) {
4149   ::memset((void*)sbuf, 0, sizeof(struct stat));
4150   sbuf-&gt;st_size = (_off_t)make_double_word(file_data.nFileSizeHigh, file_data.nFileSizeLow);
4151   sbuf-&gt;st_mtime = make_double_word(file_data.ftLastWriteTime.dwHighDateTime,
4152                                   file_data.ftLastWriteTime.dwLowDateTime);
4153   sbuf-&gt;st_ctime = make_double_word(file_data.ftCreationTime.dwHighDateTime,
4154                                   file_data.ftCreationTime.dwLowDateTime);
4155   sbuf-&gt;st_atime = make_double_word(file_data.ftLastAccessTime.dwHighDateTime,
4156                                   file_data.ftLastAccessTime.dwLowDateTime);
4157   if ((file_data.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) != 0) {
4158     sbuf-&gt;st_mode |= S_IFDIR;
4159   } else {
4160     sbuf-&gt;st_mode |= S_IFREG;
4161   }
4162 }
4163 


























































4164 // Returns the given path as an absolute wide path in unc format. The returned path is NULL
4165 // on error (with err being set accordingly) and should be freed via os::free() otherwise.
<span class="line-modified">4166 // additional_space is the number of additionally allocated wchars after the terminating L&#39;\0&#39;.</span>
<span class="line-modified">4167 // This is based on pathToNTPath() in io_util_md.cpp, but omits the optimizations for</span>
<span class="line-modified">4168 // short paths.</span>
4169 static wchar_t* wide_abs_unc_path(char const* path, errno_t &amp; err, int additional_space = 0) {
4170   if ((path == NULL) || (path[0] == &#39;\0&#39;)) {
4171     err = ENOENT;
4172     return NULL;
4173   }
4174 
<span class="line-removed">4175   size_t path_len = strlen(path);</span>
4176   // Need to allocate at least room for 3 characters, since os::native_path transforms C: to C:.
<span class="line-modified">4177   char* buf = (char*) os::malloc(1 + MAX2((size_t) 3, path_len), mtInternal);</span>
<span class="line-modified">4178   wchar_t* result = NULL;</span>














4179 
<span class="line-modified">4180   if (buf == NULL) {</span>
<span class="line-modified">4181     err = ENOMEM;</span>

4182   } else {
<span class="line-modified">4183     memcpy(buf, path, path_len + 1);</span>
<span class="line-modified">4184     os::native_path(buf);</span>
<span class="line-removed">4185 </span>
<span class="line-removed">4186     wchar_t* prefix;</span>
<span class="line-removed">4187     int prefix_off = 0;</span>
<span class="line-removed">4188     bool is_abs = true;</span>
<span class="line-removed">4189     bool needs_fullpath = true;</span>
<span class="line-removed">4190 </span>
<span class="line-removed">4191     if (::isalpha(buf[0]) &amp;&amp; !::IsDBCSLeadByte(buf[0]) &amp;&amp; buf[1] == &#39;:&#39; &amp;&amp; buf[2] == &#39;\\&#39;) {</span>
<span class="line-removed">4192       prefix = L&quot;\\\\?\\&quot;;</span>
<span class="line-removed">4193     } else if (buf[0] == &#39;\\&#39; &amp;&amp; buf[1] == &#39;\\&#39;) {</span>
<span class="line-removed">4194       if (buf[2] == &#39;?&#39; &amp;&amp; buf[3] == &#39;\\&#39;) {</span>
<span class="line-removed">4195         prefix = L&quot;&quot;;</span>
<span class="line-removed">4196         needs_fullpath = false;</span>
<span class="line-removed">4197       } else {</span>
<span class="line-removed">4198         prefix = L&quot;\\\\?\\UNC&quot;;</span>
<span class="line-removed">4199         prefix_off = 1; // Overwrite the first char with the prefix, so \\share\path becomes \\?\UNC\share\path</span>
<span class="line-removed">4200       }</span>
<span class="line-removed">4201     } else {</span>
<span class="line-removed">4202       is_abs = false;</span>
<span class="line-removed">4203       prefix = L&quot;\\\\?\\&quot;;</span>
<span class="line-removed">4204     }</span>
4205 
<span class="line-modified">4206     size_t buf_len = strlen(buf);</span>

4207     size_t prefix_len = wcslen(prefix);
<span class="line-modified">4208     size_t full_path_size = is_abs ? 1 + buf_len : JVM_MAXPATHLEN;</span>
<span class="line-modified">4209     size_t result_size = prefix_len + full_path_size - prefix_off;</span>
<span class="line-modified">4210     result = (wchar_t*) os::malloc(sizeof(wchar_t) * (additional_space + result_size), mtInternal);</span>
<span class="line-modified">4211 </span>
<span class="line-modified">4212     if (result == NULL) {</span>
<span class="line-modified">4213       err = ENOMEM;</span>
<span class="line-modified">4214     } else {</span>
<span class="line-modified">4215       size_t converted_chars;</span>
<span class="line-modified">4216       wchar_t* path_start = result + prefix_len - prefix_off;</span>
<span class="line-removed">4217       err = ::mbstowcs_s(&amp;converted_chars, path_start, buf_len + 1, buf, buf_len);</span>
<span class="line-removed">4218 </span>
<span class="line-removed">4219       if ((err == ERROR_SUCCESS) &amp;&amp; needs_fullpath) {</span>
<span class="line-removed">4220         wchar_t* tmp = (wchar_t*) os::malloc(sizeof(wchar_t) * full_path_size, mtInternal);</span>
<span class="line-removed">4221 </span>
<span class="line-removed">4222         if (tmp == NULL) {</span>
<span class="line-removed">4223           err = ENOMEM;</span>
<span class="line-removed">4224         } else {</span>
<span class="line-removed">4225           if (!_wfullpath(tmp, path_start, full_path_size)) {</span>
<span class="line-removed">4226             err = ENOENT;</span>
<span class="line-removed">4227           } else {</span>
<span class="line-removed">4228             ::memcpy(path_start, tmp, (1 + wcslen(tmp)) * sizeof(wchar_t));</span>
<span class="line-removed">4229           }</span>
<span class="line-removed">4230 </span>
<span class="line-removed">4231           os::free(tmp);</span>
<span class="line-removed">4232         }</span>
<span class="line-removed">4233       }</span>
<span class="line-removed">4234 </span>
<span class="line-removed">4235       memcpy(result, prefix, sizeof(wchar_t) * prefix_len);</span>
<span class="line-removed">4236 </span>
<span class="line-removed">4237       // Remove trailing pathsep (not for \\?\&lt;DRIVE&gt;:\, since it would make it relative)</span>
<span class="line-removed">4238       size_t result_len = wcslen(result);</span>
<span class="line-removed">4239 </span>
<span class="line-removed">4240       if (result[result_len - 1] == L&#39;\\&#39;) {</span>
<span class="line-removed">4241         if (!(::iswalpha(result[4]) &amp;&amp; result[5] == L&#39;:&#39; &amp;&amp; result_len == 7)) {</span>
<span class="line-removed">4242           result[result_len - 1] = L&#39;\0&#39;;</span>
<span class="line-removed">4243         }</span>
<span class="line-removed">4244       }</span>
4245     }
4246   }
4247 
<span class="line-modified">4248   os::free(buf);</span>
<span class="line-modified">4249 </span>
<span class="line-removed">4250   if (err != ERROR_SUCCESS) {</span>
<span class="line-removed">4251     os::free(result);</span>
<span class="line-removed">4252     result = NULL;</span>
4253   }

4254 
<span class="line-modified">4255   return result;</span>
4256 }
4257 
4258 int os::stat(const char *path, struct stat *sbuf) {
4259   errno_t err;
4260   wchar_t* wide_path = wide_abs_unc_path(path, err);
4261 
4262   if (wide_path == NULL) {
4263     errno = err;
4264     return -1;
4265   }
4266 
4267   WIN32_FILE_ATTRIBUTE_DATA file_data;;
4268   BOOL bret = ::GetFileAttributesExW(wide_path, GetFileExInfoStandard, &amp;file_data);
4269   os::free(wide_path);
4270 
4271   if (!bret) {
4272     errno = ::GetLastError();
4273     return -1;
4274   }
4275 
</pre>
</td>
<td>
<hr />
<pre>
3159 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {
3160   assert(file_desc &gt;= 0, &quot;file_desc is not valid&quot;);
3161   return map_memory_to_file(requested_addr, bytes, file_desc);
3162 }
3163 
3164 size_t os::large_page_size() {
3165   return _large_page_size;
3166 }
3167 
3168 bool os::can_commit_large_page_memory() {
3169   // Windows only uses large page memory when the entire region is reserved
3170   // and committed in a single VirtualAlloc() call. This may change in the
3171   // future, but with Windows 2003 it&#39;s not possible to commit on demand.
3172   return false;
3173 }
3174 
3175 bool os::can_execute_large_page_memory() {
3176   return true;
3177 }
3178 
<span class="line-modified">3179 char* os::pd_reserve_memory_special(size_t bytes, size_t alignment, char* addr,</span>
<span class="line-modified">3180                                     bool exec) {</span>
3181   assert(UseLargePages, &quot;only for large pages&quot;);
3182 
3183   if (!is_aligned(bytes, os::large_page_size()) || alignment &gt; os::large_page_size()) {
3184     return NULL; // Fallback to small pages.
3185   }
3186 
3187   const DWORD prot = exec ? PAGE_EXECUTE_READWRITE : PAGE_READWRITE;
3188   const DWORD flags = MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES;
3189 
3190   // with large pages, there are two cases where we need to use Individual Allocation
3191   // 1) the UseLargePagesIndividualAllocation flag is set (set by default on WS2003)
3192   // 2) NUMA Interleaving is enabled, in which case we use a different node for each page
3193   if (UseLargePagesIndividualAllocation || UseNUMAInterleaving) {
3194     log_debug(pagesize)(&quot;Reserving large pages individually.&quot;);
3195 
3196     char * p_buf = allocate_pages_individually(bytes, addr, flags, prot, LargePagesIndividualAllocationInjectError);
3197     if (p_buf == NULL) {
3198       // give an appropriate warning message
3199       if (UseNUMAInterleaving) {
3200         warning(&quot;NUMA large page allocation failed, UseLargePages flag ignored&quot;);
3201       }
3202       if (UseLargePagesIndividualAllocation) {
3203         warning(&quot;Individually allocated large pages failed, &quot;
3204                 &quot;use -XX:-UseLargePagesIndividualAllocation to turn off&quot;);
3205       }
3206       return NULL;
3207     }
3208 
3209     return p_buf;
3210 
3211   } else {
3212     log_debug(pagesize)(&quot;Reserving large pages in a single large chunk.&quot;);
3213 
3214     // normal policy just allocate it all at once
3215     DWORD flag = MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES;
3216     char * res = (char *)VirtualAlloc(addr, bytes, flag, prot);



3217 
3218     return res;
3219   }
3220 }
3221 
<span class="line-modified">3222 bool os::pd_release_memory_special(char* base, size_t bytes) {</span>
3223   assert(base != NULL, &quot;Sanity check&quot;);
<span class="line-modified">3224   return pd_release_memory(base, bytes);</span>
3225 }
3226 
3227 void os::print_statistics() {
3228 }
3229 
3230 static void warn_fail_commit_memory(char* addr, size_t bytes, bool exec) {
3231   int err = os::get_last_error();
3232   char buf[256];
3233   size_t buf_len = os::lasterror(buf, sizeof(buf));
3234   warning(&quot;INFO: os::commit_memory(&quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT
3235           &quot;, %d) failed; error=&#39;%s&#39; (DOS error/errno=%d)&quot;, addr, bytes,
3236           exec, buf_len != 0 ? buf : &quot;&lt;no_error_string&gt;&quot;, err);
3237 }
3238 
3239 bool os::pd_commit_memory(char* addr, size_t bytes, bool exec) {
3240   if (bytes == 0) {
3241     // Don&#39;t bother the OS with noops.
3242     return true;
3243   }
3244   assert((size_t) addr % os::vm_page_size() == 0, &quot;commit on page boundaries&quot;);
</pre>
<hr />
<pre>
4141   return value;
4142 }
4143 
4144 // Transfers data from WIN32_FILE_ATTRIBUTE_DATA structure to struct stat
4145 static void file_attribute_data_to_stat(struct stat* sbuf, WIN32_FILE_ATTRIBUTE_DATA file_data) {
4146   ::memset((void*)sbuf, 0, sizeof(struct stat));
4147   sbuf-&gt;st_size = (_off_t)make_double_word(file_data.nFileSizeHigh, file_data.nFileSizeLow);
4148   sbuf-&gt;st_mtime = make_double_word(file_data.ftLastWriteTime.dwHighDateTime,
4149                                   file_data.ftLastWriteTime.dwLowDateTime);
4150   sbuf-&gt;st_ctime = make_double_word(file_data.ftCreationTime.dwHighDateTime,
4151                                   file_data.ftCreationTime.dwLowDateTime);
4152   sbuf-&gt;st_atime = make_double_word(file_data.ftLastAccessTime.dwHighDateTime,
4153                                   file_data.ftLastAccessTime.dwLowDateTime);
4154   if ((file_data.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) != 0) {
4155     sbuf-&gt;st_mode |= S_IFDIR;
4156   } else {
4157     sbuf-&gt;st_mode |= S_IFREG;
4158   }
4159 }
4160 
<span class="line-added">4161 static errno_t convert_to_unicode(char const* char_path, LPWSTR* unicode_path) {</span>
<span class="line-added">4162   // Get required buffer size to convert to Unicode</span>
<span class="line-added">4163   int unicode_path_len = MultiByteToWideChar(CP_THREAD_ACP,</span>
<span class="line-added">4164                                              MB_ERR_INVALID_CHARS,</span>
<span class="line-added">4165                                              char_path, -1,</span>
<span class="line-added">4166                                              NULL, 0);</span>
<span class="line-added">4167   if (unicode_path_len == 0) {</span>
<span class="line-added">4168     return EINVAL;</span>
<span class="line-added">4169   }</span>
<span class="line-added">4170 </span>
<span class="line-added">4171   *unicode_path = NEW_C_HEAP_ARRAY(WCHAR, unicode_path_len, mtInternal);</span>
<span class="line-added">4172 </span>
<span class="line-added">4173   int result = MultiByteToWideChar(CP_THREAD_ACP,</span>
<span class="line-added">4174                                    MB_ERR_INVALID_CHARS,</span>
<span class="line-added">4175                                    char_path, -1,</span>
<span class="line-added">4176                                    *unicode_path, unicode_path_len);</span>
<span class="line-added">4177   assert(result == unicode_path_len, &quot;length already checked above&quot;);</span>
<span class="line-added">4178 </span>
<span class="line-added">4179   return ERROR_SUCCESS;</span>
<span class="line-added">4180 }</span>
<span class="line-added">4181 </span>
<span class="line-added">4182 static errno_t get_full_path(LPCWSTR unicode_path, LPWSTR* full_path) {</span>
<span class="line-added">4183   // Get required buffer size to convert to full path. The return</span>
<span class="line-added">4184   // value INCLUDES the terminating null character.</span>
<span class="line-added">4185   DWORD full_path_len = GetFullPathNameW(unicode_path, 0, NULL, NULL);</span>
<span class="line-added">4186   if (full_path_len == 0) {</span>
<span class="line-added">4187     return EINVAL;</span>
<span class="line-added">4188   }</span>
<span class="line-added">4189 </span>
<span class="line-added">4190   *full_path = NEW_C_HEAP_ARRAY(WCHAR, full_path_len, mtInternal);</span>
<span class="line-added">4191 </span>
<span class="line-added">4192   // When the buffer has sufficient size, the return value EXCLUDES the</span>
<span class="line-added">4193   // terminating null character</span>
<span class="line-added">4194   DWORD result = GetFullPathNameW(unicode_path, full_path_len, *full_path, NULL);</span>
<span class="line-added">4195   assert(result &lt;= full_path_len, &quot;length already checked above&quot;);</span>
<span class="line-added">4196 </span>
<span class="line-added">4197   return ERROR_SUCCESS;</span>
<span class="line-added">4198 }</span>
<span class="line-added">4199 </span>
<span class="line-added">4200 static void set_path_prefix(char* buf, LPWSTR* prefix, int* prefix_off, bool* needs_fullpath) {</span>
<span class="line-added">4201   *prefix_off = 0;</span>
<span class="line-added">4202   *needs_fullpath = true;</span>
<span class="line-added">4203 </span>
<span class="line-added">4204   if (::isalpha(buf[0]) &amp;&amp; !::IsDBCSLeadByte(buf[0]) &amp;&amp; buf[1] == &#39;:&#39; &amp;&amp; buf[2] == &#39;\\&#39;) {</span>
<span class="line-added">4205     *prefix = L&quot;\\\\?\\&quot;;</span>
<span class="line-added">4206   } else if (buf[0] == &#39;\\&#39; &amp;&amp; buf[1] == &#39;\\&#39;) {</span>
<span class="line-added">4207     if (buf[2] == &#39;?&#39; &amp;&amp; buf[3] == &#39;\\&#39;) {</span>
<span class="line-added">4208       *prefix = L&quot;&quot;;</span>
<span class="line-added">4209       *needs_fullpath = false;</span>
<span class="line-added">4210     } else {</span>
<span class="line-added">4211       *prefix = L&quot;\\\\?\\UNC&quot;;</span>
<span class="line-added">4212       *prefix_off = 1; // Overwrite the first char with the prefix, so \\share\path becomes \\?\UNC\share\path</span>
<span class="line-added">4213     }</span>
<span class="line-added">4214   } else {</span>
<span class="line-added">4215     *prefix = L&quot;\\\\?\\&quot;;</span>
<span class="line-added">4216   }</span>
<span class="line-added">4217 }</span>
<span class="line-added">4218 </span>
4219 // Returns the given path as an absolute wide path in unc format. The returned path is NULL
4220 // on error (with err being set accordingly) and should be freed via os::free() otherwise.
<span class="line-modified">4221 // additional_space is the size of space, in wchar_t, the function will additionally add to</span>
<span class="line-modified">4222 // the allocation of return buffer (such that the size of the returned buffer is at least</span>
<span class="line-modified">4223 // wcslen(buf) + 1 + additional_space).</span>
4224 static wchar_t* wide_abs_unc_path(char const* path, errno_t &amp; err, int additional_space = 0) {
4225   if ((path == NULL) || (path[0] == &#39;\0&#39;)) {
4226     err = ENOENT;
4227     return NULL;
4228   }
4229 

4230   // Need to allocate at least room for 3 characters, since os::native_path transforms C: to C:.
<span class="line-modified">4231   size_t buf_len = 1 + MAX2((size_t)3, strlen(path));</span>
<span class="line-modified">4232   char* buf = NEW_C_HEAP_ARRAY(char, buf_len, mtInternal);</span>
<span class="line-added">4233   strncpy(buf, path, buf_len);</span>
<span class="line-added">4234   os::native_path(buf);</span>
<span class="line-added">4235 </span>
<span class="line-added">4236   LPWSTR prefix = NULL;</span>
<span class="line-added">4237   int prefix_off = 0;</span>
<span class="line-added">4238   bool needs_fullpath = true;</span>
<span class="line-added">4239   set_path_prefix(buf, &amp;prefix, &amp;prefix_off, &amp;needs_fullpath);</span>
<span class="line-added">4240 </span>
<span class="line-added">4241   LPWSTR unicode_path = NULL;</span>
<span class="line-added">4242   err = convert_to_unicode(buf, &amp;unicode_path);</span>
<span class="line-added">4243   FREE_C_HEAP_ARRAY(char, buf);</span>
<span class="line-added">4244   if (err != ERROR_SUCCESS) {</span>
<span class="line-added">4245     return NULL;</span>
<span class="line-added">4246   }</span>
4247 
<span class="line-modified">4248   LPWSTR converted_path = NULL;</span>
<span class="line-modified">4249   if (needs_fullpath) {</span>
<span class="line-added">4250     err = get_full_path(unicode_path, &amp;converted_path);</span>
4251   } else {
<span class="line-modified">4252     converted_path = unicode_path;</span>
<span class="line-modified">4253   }</span>




















4254 
<span class="line-modified">4255   LPWSTR result = NULL;</span>
<span class="line-added">4256   if (converted_path != NULL) {</span>
4257     size_t prefix_len = wcslen(prefix);
<span class="line-modified">4258     size_t result_len = prefix_len - prefix_off + wcslen(converted_path) + additional_space + 1;</span>
<span class="line-modified">4259     result = NEW_C_HEAP_ARRAY(WCHAR, result_len, mtInternal);</span>
<span class="line-modified">4260     _snwprintf(result, result_len, L&quot;%s%s&quot;, prefix, &amp;converted_path[prefix_off]);</span>
<span class="line-modified">4261 </span>
<span class="line-modified">4262     // Remove trailing pathsep (not for \\?\&lt;DRIVE&gt;:\, since it would make it relative)</span>
<span class="line-modified">4263     result_len = wcslen(result);</span>
<span class="line-modified">4264     if ((result[result_len - 1] == L&#39;\\&#39;) &amp;&amp;</span>
<span class="line-modified">4265         !(::iswalpha(result[4]) &amp;&amp; result[5] == L&#39;:&#39; &amp;&amp; result_len == 7)) {</span>
<span class="line-modified">4266       result[result_len - 1] = L&#39;\0&#39;;</span>




























4267     }
4268   }
4269 
<span class="line-modified">4270   if (converted_path != unicode_path) {</span>
<span class="line-modified">4271     FREE_C_HEAP_ARRAY(WCHAR, converted_path);</span>



4272   }
<span class="line-added">4273   FREE_C_HEAP_ARRAY(WCHAR, unicode_path);</span>
4274 
<span class="line-modified">4275   return static_cast&lt;wchar_t*&gt;(result); // LPWSTR and wchat_t* are the same type on Windows.</span>
4276 }
4277 
4278 int os::stat(const char *path, struct stat *sbuf) {
4279   errno_t err;
4280   wchar_t* wide_path = wide_abs_unc_path(path, err);
4281 
4282   if (wide_path == NULL) {
4283     errno = err;
4284     return -1;
4285   }
4286 
4287   WIN32_FILE_ATTRIBUTE_DATA file_data;;
4288   BOOL bret = ::GetFileAttributesExW(wide_path, GetFileExInfoStandard, &amp;file_data);
4289   os::free(wide_path);
4290 
4291   if (!bret) {
4292     errno = ::GetLastError();
4293     return -1;
4294   }
4295 
</pre>
</td>
</tr>
</table>
<center><a href="../solaris/os_solaris.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../os_cpu/solaris_x86/thread_solaris_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
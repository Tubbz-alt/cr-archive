<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/solaris/os_solaris.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../linux/os_linux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../windows/os_windows.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/solaris/os_solaris.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2589   assert(is_valid_page_size(align), SIZE_FORMAT &quot; is not a valid page size&quot;, align);
2590   assert(is_aligned((void*) start, align),
2591          PTR_FORMAT &quot; is not aligned to &quot; SIZE_FORMAT, p2i((void*) start), align);
2592   assert(is_aligned(bytes, align),
2593          SIZE_FORMAT &quot; is not aligned to &quot; SIZE_FORMAT, bytes, align);
2594 
2595   // Signal to OS that we want large pages for addresses
2596   // from addr, addr + bytes
2597   struct memcntl_mha mpss_struct;
2598   mpss_struct.mha_cmd = MHA_MAPSIZE_VA;
2599   mpss_struct.mha_pagesize = align;
2600   mpss_struct.mha_flags = 0;
2601   // Upon successful completion, memcntl() returns 0
2602   if (memcntl(start, bytes, MC_HAT_ADVISE, (caddr_t) &amp;mpss_struct, 0, 0)) {
2603     debug_only(warning(&quot;Attempt to use MPSS failed.&quot;));
2604     return false;
2605   }
2606   return true;
2607 }
2608 
<span class="line-modified">2609 char* os::reserve_memory_special(size_t size, size_t alignment, char* addr, bool exec) {</span>
2610   fatal(&quot;os::reserve_memory_special should not be called on Solaris.&quot;);
2611   return NULL;
2612 }
2613 
<span class="line-modified">2614 bool os::release_memory_special(char* base, size_t bytes) {</span>
2615   fatal(&quot;os::release_memory_special should not be called on Solaris.&quot;);
2616   return false;
2617 }
2618 
2619 size_t os::large_page_size() {
2620   return _large_page_size;
2621 }
2622 
2623 // MPSS allows application to commit large page memory on demand; with ISM
2624 // the entire memory region must be allocated as shared memory.
2625 bool os::can_commit_large_page_memory() {
2626   return true;
2627 }
2628 
2629 bool os::can_execute_large_page_memory() {
2630   return true;
2631 }
2632 
2633 // Sleep forever; naked call to OS-specific sleep; use with CAUTION
2634 void os::infinite_sleep() {
</pre>
</td>
<td>
<hr />
<pre>
2589   assert(is_valid_page_size(align), SIZE_FORMAT &quot; is not a valid page size&quot;, align);
2590   assert(is_aligned((void*) start, align),
2591          PTR_FORMAT &quot; is not aligned to &quot; SIZE_FORMAT, p2i((void*) start), align);
2592   assert(is_aligned(bytes, align),
2593          SIZE_FORMAT &quot; is not aligned to &quot; SIZE_FORMAT, bytes, align);
2594 
2595   // Signal to OS that we want large pages for addresses
2596   // from addr, addr + bytes
2597   struct memcntl_mha mpss_struct;
2598   mpss_struct.mha_cmd = MHA_MAPSIZE_VA;
2599   mpss_struct.mha_pagesize = align;
2600   mpss_struct.mha_flags = 0;
2601   // Upon successful completion, memcntl() returns 0
2602   if (memcntl(start, bytes, MC_HAT_ADVISE, (caddr_t) &amp;mpss_struct, 0, 0)) {
2603     debug_only(warning(&quot;Attempt to use MPSS failed.&quot;));
2604     return false;
2605   }
2606   return true;
2607 }
2608 
<span class="line-modified">2609 char* os::pd_reserve_memory_special(size_t size, size_t alignment, char* addr, bool exec) {</span>
2610   fatal(&quot;os::reserve_memory_special should not be called on Solaris.&quot;);
2611   return NULL;
2612 }
2613 
<span class="line-modified">2614 bool os::pd_release_memory_special(char* base, size_t bytes) {</span>
2615   fatal(&quot;os::release_memory_special should not be called on Solaris.&quot;);
2616   return false;
2617 }
2618 
2619 size_t os::large_page_size() {
2620   return _large_page_size;
2621 }
2622 
2623 // MPSS allows application to commit large page memory on demand; with ISM
2624 // the entire memory region must be allocated as shared memory.
2625 bool os::can_commit_large_page_memory() {
2626   return true;
2627 }
2628 
2629 bool os::can_execute_large_page_memory() {
2630   return true;
2631 }
2632 
2633 // Sleep forever; naked call to OS-specific sleep; use with CAUTION
2634 void os::infinite_sleep() {
</pre>
</td>
</tr>
</table>
<center><a href="../linux/os_linux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../windows/os_windows.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
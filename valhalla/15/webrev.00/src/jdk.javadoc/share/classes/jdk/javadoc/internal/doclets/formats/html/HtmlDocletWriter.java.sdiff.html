<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/HtmlDocletWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HelpWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HtmlSerialFieldWriter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/HtmlDocletWriter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  63 import com.sun.source.doctree.EndElementTree;
  64 import com.sun.source.doctree.EntityTree;
  65 import com.sun.source.doctree.ErroneousTree;
  66 import com.sun.source.doctree.IndexTree;
  67 import com.sun.source.doctree.InheritDocTree;
  68 import com.sun.source.doctree.LinkTree;
  69 import com.sun.source.doctree.LiteralTree;
  70 import com.sun.source.doctree.SeeTree;
  71 import com.sun.source.doctree.StartElementTree;
  72 import com.sun.source.doctree.SummaryTree;
  73 import com.sun.source.doctree.SystemPropertyTree;
  74 import com.sun.source.doctree.TextTree;
  75 import com.sun.source.util.SimpleDocTreeVisitor;
  76 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
  77 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
  78 import jdk.javadoc.internal.doclets.formats.html.markup.FixedStringContent;
  79 import jdk.javadoc.internal.doclets.formats.html.markup.Head;
  80 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;
  81 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlDocument;
  82 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
<span class="line-modified">  83 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;</span>
  84 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
  85 import jdk.javadoc.internal.doclets.formats.html.markup.Links;
  86 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
  87 import jdk.javadoc.internal.doclets.formats.html.markup.Script;
  88 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
  89 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;
  90 import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeWriter;
  91 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
  92 import jdk.javadoc.internal.doclets.toolkit.Content;
  93 import jdk.javadoc.internal.doclets.toolkit.Messages;
  94 import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;
  95 import jdk.javadoc.internal.doclets.toolkit.Resources;
  96 import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;
  97 import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;
  98 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  99 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
 100 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 101 import jdk.javadoc.internal.doclets.toolkit.util.DocLink;
 102 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
 103 import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
</pre>
<hr />
<pre>
 269                 // Insert the absolute link if {@docRoot} is followed by &quot;/..&quot;.
 270                 buf.append(options.docrootParent());
 271                 prevEnd += 3;
 272             } else {
 273                 // Insert relative path where {@docRoot} was located
 274                 buf.append(pathToRoot.isEmpty() ? &quot;.&quot; : pathToRoot.getPath());
 275             }
 276             // Append slash if next character is not a slash
 277             if (prevEnd &lt; htmlstr.length() &amp;&amp; htmlstr.charAt(prevEnd) != &#39;/&#39;) {
 278                 buf.append(&#39;/&#39;);
 279             }
 280         } while (docrootMatcher.find());
 281         buf.append(htmlstr.substring(prevEnd));
 282         return buf.toString();
 283     }
 284     //where:
 285         // Note: {@docRoot} is not case sensitive when passed in with a command-line option:
 286         private static final Pattern docrootPattern =
 287                 Pattern.compile(Pattern.quote(&quot;{@docroot}&quot;), Pattern.CASE_INSENSITIVE);
 288 
<span class="line-removed"> 289     /**</span>
<span class="line-removed"> 290      * Get the script to show or hide the All classes link.</span>
<span class="line-removed"> 291      *</span>
<span class="line-removed"> 292      * @param id id of the element to show or hide</span>
<span class="line-removed"> 293      * @return a content tree for the script</span>
<span class="line-removed"> 294      */</span>
<span class="line-removed"> 295     public Content getAllClassesLinkScript(String id) {</span>
<span class="line-removed"> 296         Script script = new Script(&quot;&lt;!--\n&quot; +</span>
<span class="line-removed"> 297                 &quot;  allClassesLink = document.getElementById(&quot;)</span>
<span class="line-removed"> 298                 .appendStringLiteral(id)</span>
<span class="line-removed"> 299                 .append(&quot;);\n&quot; +</span>
<span class="line-removed"> 300                 &quot;  if(window==top) {\n&quot; +</span>
<span class="line-removed"> 301                 &quot;    allClassesLink.style.display = \&quot;block\&quot;;\n&quot; +</span>
<span class="line-removed"> 302                 &quot;  }\n&quot; +</span>
<span class="line-removed"> 303                 &quot;  else {\n&quot; +</span>
<span class="line-removed"> 304                 &quot;    allClassesLink.style.display = \&quot;none\&quot;;\n&quot; +</span>
<span class="line-removed"> 305                 &quot;  }\n&quot; +</span>
<span class="line-removed"> 306                 &quot;  //--&gt;\n&quot;);</span>
<span class="line-removed"> 307         Content div = HtmlTree.DIV(script.asContent());</span>
<span class="line-removed"> 308         Content div_noscript = HtmlTree.DIV(contents.noScriptMessage);</span>
<span class="line-removed"> 309         Content noScript = HtmlTree.NOSCRIPT(div_noscript);</span>
<span class="line-removed"> 310         div.add(noScript);</span>
<span class="line-removed"> 311         return div;</span>
<span class="line-removed"> 312     }</span>
 313 
 314     /**
 315      * Add method information.
 316      *
 317      * @param method the method to be documented
 318      * @param dl the content tree to which the method information will be added
 319      */
 320     private void addMethodInfo(ExecutableElement method, Content dl) {
 321         TypeElement enclosing = utils.getEnclosingTypeElement(method);
 322         List&lt;? extends TypeMirror&gt; intfacs = enclosing.getInterfaces();
 323         ExecutableElement overriddenMethod = utils.overriddenMethod(method);
 324         VisibleMemberTable vmt = configuration.getVisibleMemberTable(enclosing);
 325         // Check whether there is any implementation or overridden info to be
 326         // printed. If no overridden or implementation info needs to be
 327         // printed, do not print this section.
 328         if ((!intfacs.isEmpty()
 329                 &amp;&amp; vmt.getImplementedMethods(method).isEmpty() == false)
 330                 || overriddenMethod != null) {
 331             MethodWriterImpl.addImplementsInfo(this, method, dl);
 332             if (overriddenMethod != null) {
 333                 MethodWriterImpl.addOverridden(this,
 334                         utils.overriddenType(method),
 335                         overriddenMethod,
 336                         dl);
 337             }
 338         }
 339     }
 340 
 341     /**
 342      * Adds the tags information.
 343      *
 344      * @param e the Element for which the tags will be generated
<span class="line-modified"> 345      * @param htmltree the documentation tree to which the tags will be added</span>
 346      */
<span class="line-modified"> 347     protected void addTagsInfo(Element e, Content htmltree) {</span>
 348         if (options.noComment()) {
 349             return;
 350         }
<span class="line-modified"> 351         Content dl = new HtmlTree(HtmlTag.DL);</span>
 352         if (utils.isExecutableElement(e) &amp;&amp; !utils.isConstructor(e)) {
 353             addMethodInfo((ExecutableElement)e, dl);
 354         }
 355         Content output = new ContentBuilder();
 356         TagletWriter.genTagOutput(configuration.tagletManager, e,
 357             configuration.tagletManager.getBlockTaglets(e),
 358                 getTagletWriterInstance(false), output);
 359         dl.add(output);
<span class="line-modified"> 360         htmltree.add(dl);</span>
 361     }
 362 
 363     /**
 364      * Check whether there are any tags for Serialization Overview
 365      * section to be printed.
 366      *
 367      * @param field the VariableElement object to check for tags.
 368      * @return true if there are tags to be printed else return false.
 369      */
 370     protected boolean hasSerializationOverviewTags(VariableElement field) {
 371         Content output = new ContentBuilder();
 372         TagletWriter.genTagOutput(configuration.tagletManager, field,
 373                 configuration.tagletManager.getBlockTaglets(field),
 374                 getTagletWriterInstance(false), output);
 375         return !output.isEmpty();
 376     }
 377 
 378     /**
 379      * Returns a TagletWriter that knows how to write HTML.
 380      *
</pre>
<hr />
<pre>
 447     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 448                                   String description,
 449                                   Content extraHeadContent,
 450                                   List&lt;DocPath&gt; localStylesheets,
 451                                   Content body)
 452             throws DocFileIOException {
 453         Content htmlComment = contents.newPage;
 454         List&lt;DocPath&gt; additionalStylesheets = configuration.getAdditionalStylesheets();
 455         additionalStylesheets.addAll(localStylesheets);
 456         Head head = new Head(path, configuration.docletVersion, configuration.startTime)
 457                 .setTimestamp(!options.noTimestamp())
 458                 .setDescription(description)
 459                 .setGenerator(getGenerator(getClass()))
 460                 .setTitle(winTitle)
 461                 .setCharset(options.charset())
 462                 .addKeywords(metakeywords)
 463                 .setStylesheets(configuration.getMainStylesheet(), additionalStylesheets)
 464                 .setIndex(options.createIndex(), mainBodyScript)
 465                 .addContent(extraHeadContent);
 466 
<span class="line-modified"> 467         Content htmlTree = HtmlTree.HTML(configuration.getLocale().getLanguage(), head.toContent(), body);</span>
 468         HtmlDocument htmlDocument = new HtmlDocument(htmlComment, htmlTree);
 469         htmlDocument.write(DocFile.createFileForOutput(configuration, path));
 470     }
 471 
 472     /**
 473      * Get the window title.
 474      *
 475      * @param title the title string to construct the complete window title
 476      * @return the window title string
 477      */
 478     public String getWindowTitle(String title) {
 479         if (options.windowTitle().length() &gt; 0) {
 480             title += &quot; (&quot; + options.windowTitle() + &quot;)&quot;;
 481         }
 482         return title;
 483     }
 484 
 485     /**
 486      * Get user specified header and the footer.
 487      *
</pre>
<hr />
<pre>
1340      * inline tags along the way.  Called wherever text can contain
1341      * an inline tag, such as in comments or in free-form text arguments
1342      * to block tags.
1343      *
1344      * @param holderTag       specific tag where comment resides
1345      * @param element         specific element where comment resides
1346      * @param trees           array of text tags and inline tags (often alternating)
1347      *                        present in the text of interest for this element
1348      * @param isFirstSentence true if text is first sentence
1349      * @param inSummary       if the comment tags are added into the summary section
1350      * @return a Content object
1351      */
1352     public Content commentTagsToContent(DocTree holderTag,
1353                                         Element element,
1354                                         List&lt;? extends DocTree&gt; trees,
1355                                         boolean isFirstSentence,
1356                                         boolean inSummary)
1357     {
1358         final Content result = new ContentBuilder() {
1359             @Override
<span class="line-modified">1360             public void add(CharSequence text) {</span>
<span class="line-modified">1361                 super.add(utils.normalizeNewlines(text));</span>
1362             }
1363         };
1364         CommentHelper ch = utils.getCommentHelper(element);
1365         // Array of all possible inline tags for this javadoc run
1366         configuration.tagletManager.checkTags(element, trees, true);
1367         commentRemoved = false;
1368 
1369         for (ListIterator&lt;? extends DocTree&gt; iterator = trees.listIterator(); iterator.hasNext();) {
1370             boolean isFirstNode = !iterator.hasPrevious();
1371             DocTree tag = iterator.next();
1372             boolean isLastNode  = !iterator.hasNext();
1373 
1374             if (isFirstSentence) {
1375                 // Ignore block tags
1376                 if (ignoreNonInlineTag(tag))
1377                     continue;
1378 
1379                 // Ignore any trailing whitespace OR whitespace after removed html comment
1380                 if ((isLastNode || commentRemoved)
1381                         &amp;&amp; tag.getKind() == TEXT
</pre>
<hr />
<pre>
2102                 sb.append(&quot;, &quot;);
2103             }
2104             sb.append(e.getKind().toString().toLowerCase(Locale.US).replace(&quot;_&quot;, &quot; &quot;))
2105                     .append(&quot;: &quot;)
2106                     .append(name);
2107         }
2108         return sb.toString();
2109     }
2110 
2111     static String getGenerator(Class&lt;?&gt; clazz) {
2112         return &quot;javadoc/&quot; + clazz.getSimpleName();
2113     }
2114 
2115     /**
2116      * Returns an HtmlTree for the BODY tag.
2117      *
2118      * @param title title for the window
2119      * @return an HtmlTree for the BODY tag
2120      */
2121     public HtmlTree getBody(String title) {
<span class="line-modified">2122         HtmlTree body = new HtmlTree(HtmlTag.BODY);</span>
<span class="line-removed">2123         body.put(HtmlAttr.CLASS, getBodyClass());</span>
2124 
2125         this.winTitle = title;
2126         // Don&#39;t print windowtitle script for overview-frame, allclasses-frame
2127         // and package-frame
2128         body.add(mainBodyScript.asContent());
2129         Content noScript = HtmlTree.NOSCRIPT(HtmlTree.DIV(contents.noScriptMessage));
2130         body.add(noScript);
2131         return body;
2132     }
2133 
<span class="line-modified">2134     public String getBodyClass() {</span>
<span class="line-modified">2135         return getClass().getSimpleName()</span>
2136                 .replaceAll(&quot;(Writer)?(Impl)?$&quot;, &quot;&quot;)
2137                 .replaceAll(&quot;AnnotationType&quot;, &quot;Class&quot;)
<span class="line-modified">2138                 .replaceAll(&quot;(.)([A-Z])&quot;, &quot;$1-$2&quot;)</span>
<span class="line-modified">2139                 .replaceAll(&quot;(?i)^(module|package|class)$&quot;, &quot;$1-declaration&quot;)</span>
<span class="line-modified">2140                 .toLowerCase(Locale.US);</span>
2141     }
2142 
2143     Script getMainBodyScript() {
2144         return mainBodyScript;
2145     }
2146 
2147     /**
2148      * Returns the path of module/package specific stylesheets for the element.
2149      * @param element module/Package element
2150      * @return list of path of module/package specific stylesheets
2151      * @throws DocFileIOException
2152      */
2153     List&lt;DocPath&gt; getLocalStylesheets(Element element) throws DocFileIOException {
2154         List&lt;DocPath&gt; stylesheets = new ArrayList&lt;&gt;();
2155         DocPath basePath = null;
2156         if (element instanceof PackageElement) {
2157             stylesheets.addAll(getModuleStylesheets((PackageElement)element));
2158             basePath = docPaths.forPackage((PackageElement)element);
2159         } else if (element instanceof ModuleElement) {
2160             basePath = DocPaths.forModule((ModuleElement)element);
</pre>
</td>
<td>
<hr />
<pre>
  63 import com.sun.source.doctree.EndElementTree;
  64 import com.sun.source.doctree.EntityTree;
  65 import com.sun.source.doctree.ErroneousTree;
  66 import com.sun.source.doctree.IndexTree;
  67 import com.sun.source.doctree.InheritDocTree;
  68 import com.sun.source.doctree.LinkTree;
  69 import com.sun.source.doctree.LiteralTree;
  70 import com.sun.source.doctree.SeeTree;
  71 import com.sun.source.doctree.StartElementTree;
  72 import com.sun.source.doctree.SummaryTree;
  73 import com.sun.source.doctree.SystemPropertyTree;
  74 import com.sun.source.doctree.TextTree;
  75 import com.sun.source.util.SimpleDocTreeVisitor;
  76 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
  77 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
  78 import jdk.javadoc.internal.doclets.formats.html.markup.FixedStringContent;
  79 import jdk.javadoc.internal.doclets.formats.html.markup.Head;
  80 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;
  81 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlDocument;
  82 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
<span class="line-modified">  83 import jdk.javadoc.internal.doclets.formats.html.markup.TagName;</span>
  84 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
  85 import jdk.javadoc.internal.doclets.formats.html.markup.Links;
  86 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
  87 import jdk.javadoc.internal.doclets.formats.html.markup.Script;
  88 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
  89 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;
  90 import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeWriter;
  91 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
  92 import jdk.javadoc.internal.doclets.toolkit.Content;
  93 import jdk.javadoc.internal.doclets.toolkit.Messages;
  94 import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;
  95 import jdk.javadoc.internal.doclets.toolkit.Resources;
  96 import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;
  97 import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;
  98 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  99 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
 100 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 101 import jdk.javadoc.internal.doclets.toolkit.util.DocLink;
 102 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
 103 import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
</pre>
<hr />
<pre>
 269                 // Insert the absolute link if {@docRoot} is followed by &quot;/..&quot;.
 270                 buf.append(options.docrootParent());
 271                 prevEnd += 3;
 272             } else {
 273                 // Insert relative path where {@docRoot} was located
 274                 buf.append(pathToRoot.isEmpty() ? &quot;.&quot; : pathToRoot.getPath());
 275             }
 276             // Append slash if next character is not a slash
 277             if (prevEnd &lt; htmlstr.length() &amp;&amp; htmlstr.charAt(prevEnd) != &#39;/&#39;) {
 278                 buf.append(&#39;/&#39;);
 279             }
 280         } while (docrootMatcher.find());
 281         buf.append(htmlstr.substring(prevEnd));
 282         return buf.toString();
 283     }
 284     //where:
 285         // Note: {@docRoot} is not case sensitive when passed in with a command-line option:
 286         private static final Pattern docrootPattern =
 287                 Pattern.compile(Pattern.quote(&quot;{@docroot}&quot;), Pattern.CASE_INSENSITIVE);
 288 
























 289 
 290     /**
 291      * Add method information.
 292      *
 293      * @param method the method to be documented
 294      * @param dl the content tree to which the method information will be added
 295      */
 296     private void addMethodInfo(ExecutableElement method, Content dl) {
 297         TypeElement enclosing = utils.getEnclosingTypeElement(method);
 298         List&lt;? extends TypeMirror&gt; intfacs = enclosing.getInterfaces();
 299         ExecutableElement overriddenMethod = utils.overriddenMethod(method);
 300         VisibleMemberTable vmt = configuration.getVisibleMemberTable(enclosing);
 301         // Check whether there is any implementation or overridden info to be
 302         // printed. If no overridden or implementation info needs to be
 303         // printed, do not print this section.
 304         if ((!intfacs.isEmpty()
 305                 &amp;&amp; vmt.getImplementedMethods(method).isEmpty() == false)
 306                 || overriddenMethod != null) {
 307             MethodWriterImpl.addImplementsInfo(this, method, dl);
 308             if (overriddenMethod != null) {
 309                 MethodWriterImpl.addOverridden(this,
 310                         utils.overriddenType(method),
 311                         overriddenMethod,
 312                         dl);
 313             }
 314         }
 315     }
 316 
 317     /**
 318      * Adds the tags information.
 319      *
 320      * @param e the Element for which the tags will be generated
<span class="line-modified"> 321      * @param htmlTree the documentation tree to which the tags will be added</span>
 322      */
<span class="line-modified"> 323     protected void addTagsInfo(Element e, Content htmlTree) {</span>
 324         if (options.noComment()) {
 325             return;
 326         }
<span class="line-modified"> 327         HtmlTree dl = HtmlTree.DL(HtmlStyle.notes);</span>
 328         if (utils.isExecutableElement(e) &amp;&amp; !utils.isConstructor(e)) {
 329             addMethodInfo((ExecutableElement)e, dl);
 330         }
 331         Content output = new ContentBuilder();
 332         TagletWriter.genTagOutput(configuration.tagletManager, e,
 333             configuration.tagletManager.getBlockTaglets(e),
 334                 getTagletWriterInstance(false), output);
 335         dl.add(output);
<span class="line-modified"> 336         htmlTree.add(dl);</span>
 337     }
 338 
 339     /**
 340      * Check whether there are any tags for Serialization Overview
 341      * section to be printed.
 342      *
 343      * @param field the VariableElement object to check for tags.
 344      * @return true if there are tags to be printed else return false.
 345      */
 346     protected boolean hasSerializationOverviewTags(VariableElement field) {
 347         Content output = new ContentBuilder();
 348         TagletWriter.genTagOutput(configuration.tagletManager, field,
 349                 configuration.tagletManager.getBlockTaglets(field),
 350                 getTagletWriterInstance(false), output);
 351         return !output.isEmpty();
 352     }
 353 
 354     /**
 355      * Returns a TagletWriter that knows how to write HTML.
 356      *
</pre>
<hr />
<pre>
 423     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 424                                   String description,
 425                                   Content extraHeadContent,
 426                                   List&lt;DocPath&gt; localStylesheets,
 427                                   Content body)
 428             throws DocFileIOException {
 429         Content htmlComment = contents.newPage;
 430         List&lt;DocPath&gt; additionalStylesheets = configuration.getAdditionalStylesheets();
 431         additionalStylesheets.addAll(localStylesheets);
 432         Head head = new Head(path, configuration.docletVersion, configuration.startTime)
 433                 .setTimestamp(!options.noTimestamp())
 434                 .setDescription(description)
 435                 .setGenerator(getGenerator(getClass()))
 436                 .setTitle(winTitle)
 437                 .setCharset(options.charset())
 438                 .addKeywords(metakeywords)
 439                 .setStylesheets(configuration.getMainStylesheet(), additionalStylesheets)
 440                 .setIndex(options.createIndex(), mainBodyScript)
 441                 .addContent(extraHeadContent);
 442 
<span class="line-modified"> 443         Content htmlTree = HtmlTree.HTML(configuration.getLocale().getLanguage(), head, body);</span>
 444         HtmlDocument htmlDocument = new HtmlDocument(htmlComment, htmlTree);
 445         htmlDocument.write(DocFile.createFileForOutput(configuration, path));
 446     }
 447 
 448     /**
 449      * Get the window title.
 450      *
 451      * @param title the title string to construct the complete window title
 452      * @return the window title string
 453      */
 454     public String getWindowTitle(String title) {
 455         if (options.windowTitle().length() &gt; 0) {
 456             title += &quot; (&quot; + options.windowTitle() + &quot;)&quot;;
 457         }
 458         return title;
 459     }
 460 
 461     /**
 462      * Get user specified header and the footer.
 463      *
</pre>
<hr />
<pre>
1316      * inline tags along the way.  Called wherever text can contain
1317      * an inline tag, such as in comments or in free-form text arguments
1318      * to block tags.
1319      *
1320      * @param holderTag       specific tag where comment resides
1321      * @param element         specific element where comment resides
1322      * @param trees           array of text tags and inline tags (often alternating)
1323      *                        present in the text of interest for this element
1324      * @param isFirstSentence true if text is first sentence
1325      * @param inSummary       if the comment tags are added into the summary section
1326      * @return a Content object
1327      */
1328     public Content commentTagsToContent(DocTree holderTag,
1329                                         Element element,
1330                                         List&lt;? extends DocTree&gt; trees,
1331                                         boolean isFirstSentence,
1332                                         boolean inSummary)
1333     {
1334         final Content result = new ContentBuilder() {
1335             @Override
<span class="line-modified">1336             public ContentBuilder add(CharSequence text) {</span>
<span class="line-modified">1337                 return super.add(utils.normalizeNewlines(text));</span>
1338             }
1339         };
1340         CommentHelper ch = utils.getCommentHelper(element);
1341         // Array of all possible inline tags for this javadoc run
1342         configuration.tagletManager.checkTags(element, trees, true);
1343         commentRemoved = false;
1344 
1345         for (ListIterator&lt;? extends DocTree&gt; iterator = trees.listIterator(); iterator.hasNext();) {
1346             boolean isFirstNode = !iterator.hasPrevious();
1347             DocTree tag = iterator.next();
1348             boolean isLastNode  = !iterator.hasNext();
1349 
1350             if (isFirstSentence) {
1351                 // Ignore block tags
1352                 if (ignoreNonInlineTag(tag))
1353                     continue;
1354 
1355                 // Ignore any trailing whitespace OR whitespace after removed html comment
1356                 if ((isLastNode || commentRemoved)
1357                         &amp;&amp; tag.getKind() == TEXT
</pre>
<hr />
<pre>
2078                 sb.append(&quot;, &quot;);
2079             }
2080             sb.append(e.getKind().toString().toLowerCase(Locale.US).replace(&quot;_&quot;, &quot; &quot;))
2081                     .append(&quot;: &quot;)
2082                     .append(name);
2083         }
2084         return sb.toString();
2085     }
2086 
2087     static String getGenerator(Class&lt;?&gt; clazz) {
2088         return &quot;javadoc/&quot; + clazz.getSimpleName();
2089     }
2090 
2091     /**
2092      * Returns an HtmlTree for the BODY tag.
2093      *
2094      * @param title title for the window
2095      * @return an HtmlTree for the BODY tag
2096      */
2097     public HtmlTree getBody(String title) {
<span class="line-modified">2098         HtmlTree body = new HtmlTree(TagName.BODY).setStyle(getBodyStyle());</span>

2099 
2100         this.winTitle = title;
2101         // Don&#39;t print windowtitle script for overview-frame, allclasses-frame
2102         // and package-frame
2103         body.add(mainBodyScript.asContent());
2104         Content noScript = HtmlTree.NOSCRIPT(HtmlTree.DIV(contents.noScriptMessage));
2105         body.add(noScript);
2106         return body;
2107     }
2108 
<span class="line-modified">2109     public HtmlStyle getBodyStyle() {</span>
<span class="line-modified">2110         String kind = getClass().getSimpleName()</span>
2111                 .replaceAll(&quot;(Writer)?(Impl)?$&quot;, &quot;&quot;)
2112                 .replaceAll(&quot;AnnotationType&quot;, &quot;Class&quot;)
<span class="line-modified">2113                 .replaceAll(&quot;^(Module|Package|Class)$&quot;, &quot;$1Declaration&quot;);</span>
<span class="line-modified">2114         String page = kind.substring(0, 1).toLowerCase(Locale.US) + kind.substring(1) + &quot;Page&quot;;</span>
<span class="line-modified">2115         return HtmlStyle.valueOf(page);</span>
2116     }
2117 
2118     Script getMainBodyScript() {
2119         return mainBodyScript;
2120     }
2121 
2122     /**
2123      * Returns the path of module/package specific stylesheets for the element.
2124      * @param element module/Package element
2125      * @return list of path of module/package specific stylesheets
2126      * @throws DocFileIOException
2127      */
2128     List&lt;DocPath&gt; getLocalStylesheets(Element element) throws DocFileIOException {
2129         List&lt;DocPath&gt; stylesheets = new ArrayList&lt;&gt;();
2130         DocPath basePath = null;
2131         if (element instanceof PackageElement) {
2132             stylesheets.addAll(getModuleStylesheets((PackageElement)element));
2133             basePath = docPaths.forPackage((PackageElement)element);
2134         } else if (element instanceof ModuleElement) {
2135             basePath = DocPaths.forModule((ModuleElement)element);
</pre>
</td>
</tr>
</table>
<center><a href="HelpWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HtmlSerialFieldWriter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ClassWriterImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ClassUseWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantsSummaryWriterImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ClassWriterImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 28 import java.util.Collection;
 29 import java.util.List;
 30 import java.util.Set;
 31 import java.util.SortedSet;
 32 import java.util.TreeSet;
 33 
 34 import javax.lang.model.element.AnnotationMirror;
 35 import javax.lang.model.element.Element;
 36 import javax.lang.model.element.ModuleElement;
 37 import javax.lang.model.element.PackageElement;
 38 import javax.lang.model.element.RecordComponentElement;
 39 import javax.lang.model.element.TypeElement;
 40 import javax.lang.model.type.TypeMirror;
 41 import javax.lang.model.util.SimpleElementVisitor8;
 42 
 43 import com.sun.source.doctree.DocTree;
 44 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
 45 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
 46 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;
 47 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
<span class="line-modified"> 48 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;</span>
 49 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
<span class="line-modified"> 50 import jdk.javadoc.internal.doclets.formats.html.markup.Navigation;</span>
<span class="line-removed"> 51 import jdk.javadoc.internal.doclets.formats.html.markup.Navigation.PageMode;</span>
 52 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
 53 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
 54 import jdk.javadoc.internal.doclets.toolkit.Content;
 55 import jdk.javadoc.internal.doclets.toolkit.taglets.ParamTaglet;
 56 import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;
 57 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 58 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 59 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
 60 import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
 61 
 62 /**
 63  * Generate the Class Information Page.
 64  *
 65  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 66  *  If you write code that depends on this, you do so at your own risk.
 67  *  This code and its internal interfaces are subject to change or
 68  *  deletion without notice.&lt;/b&gt;
 69  *
 70  * @see javax.lang.model.element.TypeElement
 71  * @see java.util.Collections
</pre>
<hr />
<pre>
 98      */
 99     public ClassWriterImpl(HtmlConfiguration configuration, TypeElement typeElement,
100                            ClassTree classTree) {
101         super(configuration, configuration.docPaths.forClass(typeElement));
102         this.typeElement = typeElement;
103         configuration.currentTypeElement = typeElement;
104         this.classtree = classTree;
105         this.navBar = new Navigation(typeElement, configuration, PageMode.CLASS, path);
106     }
107 
108     @Override
109     public Content getHeader(String header) {
110         HtmlTree bodyTree = getBody(getWindowTitle(utils.getSimpleName(typeElement)));
111         Content headerContent = new ContentBuilder();
112         addTop(headerContent);
113         Content linkContent = getModuleLink(utils.elementUtils.getModuleOf(typeElement),
114                 contents.moduleLabel);
115         navBar.setNavLinkModule(linkContent);
116         navBar.setMemberSummaryBuilder(configuration.getBuilderFactory().getMemberSummaryBuilder(this));
117         navBar.setUserHeader(getUserHeaderFooter(true));
<span class="line-modified">118         headerContent.add(navBar.getContent(true));</span>
<span class="line-modified">119         HtmlTree div = new HtmlTree(HtmlTag.DIV);</span>
120         div.setStyle(HtmlStyle.header);
121         if (configuration.showModules) {
122             ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(typeElement);
123             Content classModuleLabel = HtmlTree.SPAN(HtmlStyle.moduleLabelInType, contents.moduleLabel);
124             Content moduleNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classModuleLabel);
125             moduleNameDiv.add(Entity.NO_BREAK_SPACE);
126             moduleNameDiv.add(getModuleLink(mdle,
127                     new StringContent(mdle.getQualifiedName())));
128             div.add(moduleNameDiv);
129         }
130         PackageElement pkg = utils.containingPackage(typeElement);
131         if (!pkg.isUnnamed()) {
132             Content classPackageLabel = HtmlTree.SPAN(HtmlStyle.packageLabelInType, contents.packageLabel);
133             Content pkgNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classPackageLabel);
134             pkgNameDiv.add(Entity.NO_BREAK_SPACE);
135             Content pkgNameContent = getPackageLink(pkg,
136                     new StringContent(utils.getPackageName(pkg)));
137             pkgNameDiv.add(pkgNameContent);
138             div.add(pkgNameDiv);
139         }
140         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
141                 LinkInfoImpl.Kind.CLASS_HEADER, typeElement);
142         //Let&#39;s not link to ourselves in the header.
143         linkInfo.linkToSelf = false;
<span class="line-modified">144         Content heading = HtmlTree.HEADING(Headings.PAGE_TITLE_HEADING, true,</span>
145                 HtmlStyle.title, new StringContent(header));
146         heading.add(getTypeParameterLinks(linkInfo));
147         div.add(heading);
148         bodyContents.setHeader(headerContent)
149                 .addMainContent(MarkerComments.START_OF_CLASS_DATA)
150                 .addMainContent(div);
151         return bodyTree;
152     }
153 
154     @Override
155     public Content getClassContentHeader() {
156         return getContentHeader();
157     }
158 
159     @Override
160     public void addFooter() {
161         bodyContents.addMainContent(MarkerComments.END_OF_CLASS_DATA);
162         Content htmlTree = HtmlTree.FOOTER();
163         navBar.setUserFooter(getUserHeaderFooter(false));
<span class="line-modified">164         htmlTree.add(navBar.getContent(false));</span>
165         addBottom(htmlTree);
166         bodyContents.setFooter(htmlTree);
167     }
168 
169     @Override
170     public void printDocument(Content contentTree) throws DocFileIOException {
171         String description = getDescription(&quot;declaration&quot;, typeElement);
172         PackageElement pkg = utils.containingPackage(typeElement);
173         List&lt;DocPath&gt; localStylesheets = getLocalStylesheets(pkg);
<span class="line-modified">174         contentTree.add(bodyContents.toContent());</span>
175         printHtmlDocument(configuration.metakeywords.getMetaKeywords(typeElement),
176                 description, localStylesheets, contentTree);
177     }
178 
179     @Override
180     public Content getClassInfoTreeHeader() {
181         return getMemberTreeHeader();
182     }
183 
184     @Override
185     public Content getClassInfo(Content classInfoTree) {
186         return getMemberTree(HtmlStyle.description, classInfoTree);
187     }
188 
189     @Override
190     protected TypeElement getCurrentPageElement() {
191         return typeElement;
192     }
193 
194     @Override @SuppressWarnings(&quot;preview&quot;)
195     public void addClassSignature(String modifiers, Content classInfoTree) {
<span class="line-modified">196         Content hr = new HtmlTree(HtmlTag.HR);</span>
197         classInfoTree.add(hr);
<span class="line-modified">198         Content pre = new HtmlTree(HtmlTag.PRE);</span>
199         addAnnotationInfo(typeElement, pre);
200         pre.add(modifiers);
201         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
202                 LinkInfoImpl.Kind.CLASS_SIGNATURE, typeElement);
203         //Let&#39;s not link to ourselves in the signature.
204         linkInfo.linkToSelf = false;
205         Content className = new StringContent(utils.getSimpleName(typeElement));
206         Content parameterLinks = getTypeParameterLinks(linkInfo);
207         if (options.linkSource()) {
208             addSrcLink(typeElement, className, pre);
209             pre.add(parameterLinks);
210         } else {
211             Content span = HtmlTree.SPAN(HtmlStyle.typeNameLabel, className);
212             span.add(parameterLinks);
213             pre.add(span);
214         }
215         if (utils.isRecord(typeElement)) {
216             pre.add(getRecordComponents(typeElement));
217         }
218         if (!utils.isInterface(typeElement)) {
</pre>
<hr />
<pre>
334                     .label(configuration.getClassName(utils.asTypeElement(type))));
335             content.add(link);
336         }
337         return content;
338     }
339 
340     @Override
341     public void addClassTree(Content classContentTree) {
342         if (!utils.isClass(typeElement)) {
343             return;
344         }
345         classContentTree.add(getClassInheritanceTree(typeElement.asType()));
346     }
347 
348     @Override
349     public void addParamInfo(Content classInfoTree) {
350         if (utils.hasBlockTag(typeElement, DocTree.Kind.PARAM)) {
351             Content paramInfo = (new ParamTaglet()).getTagletOutput(typeElement,
352                     getTagletWriterInstance(false));
353             if (!paramInfo.isEmpty()) {
<span class="line-modified">354                 classInfoTree.add(HtmlTree.DL(paramInfo));</span>
355             }
356         }
357     }
358 
359     @Override
360     public void addSubClassInfo(Content classInfoTree) {
361         if (utils.isClass(typeElement)) {
362             for (String s : suppressSubtypesSet) {
363                 if (typeElement.getQualifiedName().contentEquals(s)) {
364                     return;    // Don&#39;t generate the list, too huge
365                 }
366             }
367             Set&lt;TypeElement&gt; subclasses = classtree.directSubClasses(typeElement, false);
368             if (!subclasses.isEmpty()) {
<span class="line-modified">369                 Content label = contents.subclassesLabel;</span>
<span class="line-modified">370                 Content dt = HtmlTree.DT(label);</span>
<span class="line-modified">371                 Content dl = HtmlTree.DL(dt);</span>
<span class="line-removed">372                 dl.add(getClassLinks(LinkInfoImpl.Kind.SUBCLASSES,</span>
<span class="line-removed">373                         subclasses));</span>
374                 classInfoTree.add(dl);
375             }
376         }
377     }
378 
379     @Override
380     public void addSubInterfacesInfo(Content classInfoTree) {
381         if (utils.isInterface(typeElement)) {
382             Set&lt;TypeElement&gt; subInterfaces = classtree.allSubClasses(typeElement, false);
383             if (!subInterfaces.isEmpty()) {
<span class="line-modified">384                 Content label = contents.subinterfacesLabel;</span>
<span class="line-modified">385                 Content dt = HtmlTree.DT(label);</span>
<span class="line-modified">386                 Content dl = HtmlTree.DL(dt);</span>
<span class="line-removed">387                 dl.add(getClassLinks(LinkInfoImpl.Kind.SUBINTERFACES,</span>
<span class="line-removed">388                         subInterfaces));</span>
389                 classInfoTree.add(dl);
390             }
391         }
392     }
393 
394     @Override
395     public void addInterfaceUsageInfo (Content classInfoTree) {
396         if (!utils.isInterface(typeElement)) {
397             return;
398         }
399         for (String s : suppressImplementingSet) {
400             if (typeElement.getQualifiedName().contentEquals(s)) {
401                 return;    // Don&#39;t generate the list, too huge
402             }
403         }
404         Set&lt;TypeElement&gt; implcl = classtree.implementingClasses(typeElement);
405         if (!implcl.isEmpty()) {
<span class="line-modified">406             Content label = contents.implementingClassesLabel;</span>
<span class="line-modified">407             Content dt = HtmlTree.DT(label);</span>
<span class="line-modified">408             Content dl = HtmlTree.DL(dt);</span>
<span class="line-removed">409             dl.add(getClassLinks(LinkInfoImpl.Kind.IMPLEMENTED_CLASSES,</span>
<span class="line-removed">410                     implcl));</span>
411             classInfoTree.add(dl);
412         }
413     }
414 
415     @Override
416     public void addImplementedInterfacesInfo(Content classInfoTree) {
417         SortedSet&lt;TypeMirror&gt; interfaces = new TreeSet&lt;&gt;(utils.makeTypeMirrorClassUseComparator());
418         interfaces.addAll(utils.getAllInterfaces(typeElement));
419         if (utils.isClass(typeElement) &amp;&amp; !interfaces.isEmpty()) {
<span class="line-modified">420             Content label = contents.allImplementedInterfacesLabel;</span>
<span class="line-modified">421             Content dt = HtmlTree.DT(label);</span>
<span class="line-modified">422             Content dl = HtmlTree.DL(dt);</span>
<span class="line-removed">423             dl.add(getClassLinks(LinkInfoImpl.Kind.IMPLEMENTED_INTERFACES, interfaces));</span>
424             classInfoTree.add(dl);
425         }
426     }
427 
428     @Override
429     public void addSuperInterfacesInfo(Content classInfoTree) {
430         SortedSet&lt;TypeMirror&gt; interfaces =
431                 new TreeSet&lt;&gt;(utils.makeTypeMirrorIndexUseComparator());
432         interfaces.addAll(utils.getAllInterfaces(typeElement));
433 
434         if (utils.isInterface(typeElement) &amp;&amp; !interfaces.isEmpty()) {
<span class="line-modified">435             Content label = contents.allSuperinterfacesLabel;</span>
<span class="line-modified">436             Content dt = HtmlTree.DT(label);</span>
<span class="line-modified">437             Content dl = HtmlTree.DL(dt);</span>
<span class="line-removed">438             dl.add(getClassLinks(LinkInfoImpl.Kind.SUPER_INTERFACES, interfaces));</span>
439             classInfoTree.add(dl);
440         }
441     }
442 
443     @Override
444     public void addNestedClassInfo(final Content classInfoTree) {
445         Element outerClass = typeElement.getEnclosingElement();
446         if (outerClass == null)
447             return;
448         new SimpleElementVisitor8&lt;Void, Void&gt;() {
449             @Override
450             public Void visitType(TypeElement e, Void p) {
<span class="line-modified">451                 Content label = utils.isInterface(e)</span>

452                         ? contents.enclosingInterfaceLabel
<span class="line-modified">453                         : contents.enclosingClassLabel;</span>
<span class="line-modified">454                 Content dt = HtmlTree.DT(label);</span>
<span class="line-removed">455                 Content dl = HtmlTree.DL(dt);</span>
<span class="line-removed">456                 Content dd = new HtmlTree(HtmlTag.DD);</span>
457                 dd.add(getLink(new LinkInfoImpl(configuration,
458                         LinkInfoImpl.Kind.CLASS, e)));
459                 dl.add(dd);
460                 classInfoTree.add(dl);
461                 return null;
462             }
463         }.visit(outerClass);
464     }
465 
466     @Override
467     public void addFunctionalInterfaceInfo (Content classInfoTree) {
468         if (isFunctionalInterface()) {
<span class="line-modified">469             Content dt = HtmlTree.DT(contents.functionalInterface);</span>
<span class="line-modified">470             Content dl = HtmlTree.DL(dt);</span>
<span class="line-modified">471             Content dd = new HtmlTree(HtmlTag.DD);</span>
472             dd.add(contents.functionalInterfaceMessage);
473             dl.add(dd);
474             classInfoTree.add(dl);
475         }
476     }
477 
478     public boolean isFunctionalInterface() {
479         List&lt;? extends AnnotationMirror&gt; annotationMirrors = ((Element) typeElement).getAnnotationMirrors();
480         for (AnnotationMirror anno : annotationMirrors) {
481             if (utils.isFunctionalInterface(anno)) {
482                 return true;
483             }
484         }
485         return false;
486     }
487 
488 
489     @Override
490     public void addClassDeprecationInfo(Content classInfoTree) {
491         List&lt;? extends DocTree&gt; deprs = utils.getBlockTags(typeElement, DocTree.Kind.DEPRECATED);
</pre>
<hr />
<pre>
495             if (!deprs.isEmpty()) {
496                 CommentHelper ch = utils.getCommentHelper(typeElement);
497                 DocTree dt = deprs.get(0);
498                 List&lt;? extends DocTree&gt; commentTags = ch.getBody(dt);
499                 if (!commentTags.isEmpty()) {
500                     addInlineDeprecatedComment(typeElement, deprs.get(0), div);
501                 }
502             }
503             classInfoTree.add(div);
504         }
505     }
506 
507     /**
508      * Get links to the given classes.
509      *
510      * @param context the id of the context where the link will be printed
511      * @param list the list of classes
512      * @return a content tree for the class list
513      */
514     private Content getClassLinks(LinkInfoImpl.Kind context, Collection&lt;?&gt; list) {
<span class="line-modified">515         Content dd = new HtmlTree(HtmlTag.DD);</span>
516         boolean isFirst = true;
517         for (Object type : list) {
518             if (!isFirst) {
519                 Content separator = new StringContent(&quot;, &quot;);
<span class="line-modified">520                 dd.add(separator);</span>
521             } else {
522                 isFirst = false;
523             }
524             // TODO: should we simply split this method up to avoid instanceof ?
525             if (type instanceof TypeElement) {
526                 Content link = getLink(
527                         new LinkInfoImpl(configuration, context, (TypeElement)(type)));
<span class="line-modified">528                 dd.add(HtmlTree.CODE(link));</span>
529             } else {
530                 Content link = getLink(
531                         new LinkInfoImpl(configuration, context, ((TypeMirror)type)));
<span class="line-modified">532                 dd.add(HtmlTree.CODE(link));</span>
533             }
534         }
<span class="line-modified">535         return dd;</span>
536     }
537 
538     /**
539      * Return the TypeElement being documented.
540      *
541      * @return the TypeElement being documented.
542      */
543     @Override
544     public TypeElement getTypeElement() {
545         return typeElement;
546     }
547 }
</pre>
</td>
<td>
<hr />
<pre>
 28 import java.util.Collection;
 29 import java.util.List;
 30 import java.util.Set;
 31 import java.util.SortedSet;
 32 import java.util.TreeSet;
 33 
 34 import javax.lang.model.element.AnnotationMirror;
 35 import javax.lang.model.element.Element;
 36 import javax.lang.model.element.ModuleElement;
 37 import javax.lang.model.element.PackageElement;
 38 import javax.lang.model.element.RecordComponentElement;
 39 import javax.lang.model.element.TypeElement;
 40 import javax.lang.model.type.TypeMirror;
 41 import javax.lang.model.util.SimpleElementVisitor8;
 42 
 43 import com.sun.source.doctree.DocTree;
 44 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
 45 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
 46 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;
 47 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
<span class="line-modified"> 48 import jdk.javadoc.internal.doclets.formats.html.markup.TagName;</span>
 49 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
<span class="line-modified"> 50 import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;</span>

 51 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
 52 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
 53 import jdk.javadoc.internal.doclets.toolkit.Content;
 54 import jdk.javadoc.internal.doclets.toolkit.taglets.ParamTaglet;
 55 import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;
 56 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 57 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 58 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
 59 import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
 60 
 61 /**
 62  * Generate the Class Information Page.
 63  *
 64  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 65  *  If you write code that depends on this, you do so at your own risk.
 66  *  This code and its internal interfaces are subject to change or
 67  *  deletion without notice.&lt;/b&gt;
 68  *
 69  * @see javax.lang.model.element.TypeElement
 70  * @see java.util.Collections
</pre>
<hr />
<pre>
 97      */
 98     public ClassWriterImpl(HtmlConfiguration configuration, TypeElement typeElement,
 99                            ClassTree classTree) {
100         super(configuration, configuration.docPaths.forClass(typeElement));
101         this.typeElement = typeElement;
102         configuration.currentTypeElement = typeElement;
103         this.classtree = classTree;
104         this.navBar = new Navigation(typeElement, configuration, PageMode.CLASS, path);
105     }
106 
107     @Override
108     public Content getHeader(String header) {
109         HtmlTree bodyTree = getBody(getWindowTitle(utils.getSimpleName(typeElement)));
110         Content headerContent = new ContentBuilder();
111         addTop(headerContent);
112         Content linkContent = getModuleLink(utils.elementUtils.getModuleOf(typeElement),
113                 contents.moduleLabel);
114         navBar.setNavLinkModule(linkContent);
115         navBar.setMemberSummaryBuilder(configuration.getBuilderFactory().getMemberSummaryBuilder(this));
116         navBar.setUserHeader(getUserHeaderFooter(true));
<span class="line-modified">117         headerContent.add(navBar.getContent(Navigation.Position.TOP));</span>
<span class="line-modified">118         HtmlTree div = new HtmlTree(TagName.DIV);</span>
119         div.setStyle(HtmlStyle.header);
120         if (configuration.showModules) {
121             ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(typeElement);
122             Content classModuleLabel = HtmlTree.SPAN(HtmlStyle.moduleLabelInType, contents.moduleLabel);
123             Content moduleNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classModuleLabel);
124             moduleNameDiv.add(Entity.NO_BREAK_SPACE);
125             moduleNameDiv.add(getModuleLink(mdle,
126                     new StringContent(mdle.getQualifiedName())));
127             div.add(moduleNameDiv);
128         }
129         PackageElement pkg = utils.containingPackage(typeElement);
130         if (!pkg.isUnnamed()) {
131             Content classPackageLabel = HtmlTree.SPAN(HtmlStyle.packageLabelInType, contents.packageLabel);
132             Content pkgNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classPackageLabel);
133             pkgNameDiv.add(Entity.NO_BREAK_SPACE);
134             Content pkgNameContent = getPackageLink(pkg,
135                     new StringContent(utils.getPackageName(pkg)));
136             pkgNameDiv.add(pkgNameContent);
137             div.add(pkgNameDiv);
138         }
139         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
140                 LinkInfoImpl.Kind.CLASS_HEADER, typeElement);
141         //Let&#39;s not link to ourselves in the header.
142         linkInfo.linkToSelf = false;
<span class="line-modified">143         Content heading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,</span>
144                 HtmlStyle.title, new StringContent(header));
145         heading.add(getTypeParameterLinks(linkInfo));
146         div.add(heading);
147         bodyContents.setHeader(headerContent)
148                 .addMainContent(MarkerComments.START_OF_CLASS_DATA)
149                 .addMainContent(div);
150         return bodyTree;
151     }
152 
153     @Override
154     public Content getClassContentHeader() {
155         return getContentHeader();
156     }
157 
158     @Override
159     public void addFooter() {
160         bodyContents.addMainContent(MarkerComments.END_OF_CLASS_DATA);
161         Content htmlTree = HtmlTree.FOOTER();
162         navBar.setUserFooter(getUserHeaderFooter(false));
<span class="line-modified">163         htmlTree.add(navBar.getContent(Navigation.Position.BOTTOM));</span>
164         addBottom(htmlTree);
165         bodyContents.setFooter(htmlTree);
166     }
167 
168     @Override
169     public void printDocument(Content contentTree) throws DocFileIOException {
170         String description = getDescription(&quot;declaration&quot;, typeElement);
171         PackageElement pkg = utils.containingPackage(typeElement);
172         List&lt;DocPath&gt; localStylesheets = getLocalStylesheets(pkg);
<span class="line-modified">173         contentTree.add(bodyContents);</span>
174         printHtmlDocument(configuration.metakeywords.getMetaKeywords(typeElement),
175                 description, localStylesheets, contentTree);
176     }
177 
178     @Override
179     public Content getClassInfoTreeHeader() {
180         return getMemberTreeHeader();
181     }
182 
183     @Override
184     public Content getClassInfo(Content classInfoTree) {
185         return getMemberTree(HtmlStyle.description, classInfoTree);
186     }
187 
188     @Override
189     protected TypeElement getCurrentPageElement() {
190         return typeElement;
191     }
192 
193     @Override @SuppressWarnings(&quot;preview&quot;)
194     public void addClassSignature(String modifiers, Content classInfoTree) {
<span class="line-modified">195         Content hr = new HtmlTree(TagName.HR);</span>
196         classInfoTree.add(hr);
<span class="line-modified">197         Content pre = new HtmlTree(TagName.PRE);</span>
198         addAnnotationInfo(typeElement, pre);
199         pre.add(modifiers);
200         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
201                 LinkInfoImpl.Kind.CLASS_SIGNATURE, typeElement);
202         //Let&#39;s not link to ourselves in the signature.
203         linkInfo.linkToSelf = false;
204         Content className = new StringContent(utils.getSimpleName(typeElement));
205         Content parameterLinks = getTypeParameterLinks(linkInfo);
206         if (options.linkSource()) {
207             addSrcLink(typeElement, className, pre);
208             pre.add(parameterLinks);
209         } else {
210             Content span = HtmlTree.SPAN(HtmlStyle.typeNameLabel, className);
211             span.add(parameterLinks);
212             pre.add(span);
213         }
214         if (utils.isRecord(typeElement)) {
215             pre.add(getRecordComponents(typeElement));
216         }
217         if (!utils.isInterface(typeElement)) {
</pre>
<hr />
<pre>
333                     .label(configuration.getClassName(utils.asTypeElement(type))));
334             content.add(link);
335         }
336         return content;
337     }
338 
339     @Override
340     public void addClassTree(Content classContentTree) {
341         if (!utils.isClass(typeElement)) {
342             return;
343         }
344         classContentTree.add(getClassInheritanceTree(typeElement.asType()));
345     }
346 
347     @Override
348     public void addParamInfo(Content classInfoTree) {
349         if (utils.hasBlockTag(typeElement, DocTree.Kind.PARAM)) {
350             Content paramInfo = (new ParamTaglet()).getTagletOutput(typeElement,
351                     getTagletWriterInstance(false));
352             if (!paramInfo.isEmpty()) {
<span class="line-modified">353                 classInfoTree.add(HtmlTree.DL(HtmlStyle.notes, paramInfo));</span>
354             }
355         }
356     }
357 
358     @Override
359     public void addSubClassInfo(Content classInfoTree) {
360         if (utils.isClass(typeElement)) {
361             for (String s : suppressSubtypesSet) {
362                 if (typeElement.getQualifiedName().contentEquals(s)) {
363                     return;    // Don&#39;t generate the list, too huge
364                 }
365             }
366             Set&lt;TypeElement&gt; subclasses = classtree.directSubClasses(typeElement, false);
367             if (!subclasses.isEmpty()) {
<span class="line-modified">368                 HtmlTree dl = HtmlTree.DL(HtmlStyle.notes);</span>
<span class="line-modified">369                 dl.add(HtmlTree.DT(contents.subclassesLabel));</span>
<span class="line-modified">370                 dl.add(HtmlTree.DD(getClassLinks(LinkInfoImpl.Kind.SUBCLASSES, subclasses)));</span>


371                 classInfoTree.add(dl);
372             }
373         }
374     }
375 
376     @Override
377     public void addSubInterfacesInfo(Content classInfoTree) {
378         if (utils.isInterface(typeElement)) {
379             Set&lt;TypeElement&gt; subInterfaces = classtree.allSubClasses(typeElement, false);
380             if (!subInterfaces.isEmpty()) {
<span class="line-modified">381                 Content dl = HtmlTree.DL(HtmlStyle.notes);</span>
<span class="line-modified">382                 dl.add(HtmlTree.DT(contents.subinterfacesLabel));</span>
<span class="line-modified">383                 dl.add(HtmlTree.DD(getClassLinks(LinkInfoImpl.Kind.SUBINTERFACES, subInterfaces)));</span>


384                 classInfoTree.add(dl);
385             }
386         }
387     }
388 
389     @Override
390     public void addInterfaceUsageInfo (Content classInfoTree) {
391         if (!utils.isInterface(typeElement)) {
392             return;
393         }
394         for (String s : suppressImplementingSet) {
395             if (typeElement.getQualifiedName().contentEquals(s)) {
396                 return;    // Don&#39;t generate the list, too huge
397             }
398         }
399         Set&lt;TypeElement&gt; implcl = classtree.implementingClasses(typeElement);
400         if (!implcl.isEmpty()) {
<span class="line-modified">401             HtmlTree dl = HtmlTree.DL(HtmlStyle.notes);</span>
<span class="line-modified">402             dl.add(HtmlTree.DT(contents.implementingClassesLabel));</span>
<span class="line-modified">403             dl.add(HtmlTree.DD(getClassLinks(LinkInfoImpl.Kind.IMPLEMENTED_CLASSES, implcl)));</span>


404             classInfoTree.add(dl);
405         }
406     }
407 
408     @Override
409     public void addImplementedInterfacesInfo(Content classInfoTree) {
410         SortedSet&lt;TypeMirror&gt; interfaces = new TreeSet&lt;&gt;(utils.makeTypeMirrorClassUseComparator());
411         interfaces.addAll(utils.getAllInterfaces(typeElement));
412         if (utils.isClass(typeElement) &amp;&amp; !interfaces.isEmpty()) {
<span class="line-modified">413             HtmlTree dl = HtmlTree.DL(HtmlStyle.notes);</span>
<span class="line-modified">414             dl.add(HtmlTree.DT(contents.allImplementedInterfacesLabel));</span>
<span class="line-modified">415             dl.add(HtmlTree.DD(getClassLinks(LinkInfoImpl.Kind.IMPLEMENTED_INTERFACES, interfaces)));</span>

416             classInfoTree.add(dl);
417         }
418     }
419 
420     @Override
421     public void addSuperInterfacesInfo(Content classInfoTree) {
422         SortedSet&lt;TypeMirror&gt; interfaces =
423                 new TreeSet&lt;&gt;(utils.makeTypeMirrorIndexUseComparator());
424         interfaces.addAll(utils.getAllInterfaces(typeElement));
425 
426         if (utils.isInterface(typeElement) &amp;&amp; !interfaces.isEmpty()) {
<span class="line-modified">427             HtmlTree dl = HtmlTree.DL(HtmlStyle.notes);</span>
<span class="line-modified">428             dl.add(HtmlTree.DT(contents.allSuperinterfacesLabel));</span>
<span class="line-modified">429             dl.add(HtmlTree.DD(getClassLinks(LinkInfoImpl.Kind.SUPER_INTERFACES, interfaces)));</span>

430             classInfoTree.add(dl);
431         }
432     }
433 
434     @Override
435     public void addNestedClassInfo(final Content classInfoTree) {
436         Element outerClass = typeElement.getEnclosingElement();
437         if (outerClass == null)
438             return;
439         new SimpleElementVisitor8&lt;Void, Void&gt;() {
440             @Override
441             public Void visitType(TypeElement e, Void p) {
<span class="line-modified">442                 HtmlTree dl = HtmlTree.DL(HtmlStyle.notes);</span>
<span class="line-added">443                 dl.add(HtmlTree.DT(utils.isInterface(e)</span>
444                         ? contents.enclosingInterfaceLabel
<span class="line-modified">445                         : contents.enclosingClassLabel));</span>
<span class="line-modified">446                 Content dd = new HtmlTree(TagName.DD);</span>


447                 dd.add(getLink(new LinkInfoImpl(configuration,
448                         LinkInfoImpl.Kind.CLASS, e)));
449                 dl.add(dd);
450                 classInfoTree.add(dl);
451                 return null;
452             }
453         }.visit(outerClass);
454     }
455 
456     @Override
457     public void addFunctionalInterfaceInfo (Content classInfoTree) {
458         if (isFunctionalInterface()) {
<span class="line-modified">459             HtmlTree dl = HtmlTree.DL(HtmlStyle.notes);</span>
<span class="line-modified">460             dl.add(HtmlTree.DT(contents.functionalInterface));</span>
<span class="line-modified">461             Content dd = new HtmlTree(TagName.DD);</span>
462             dd.add(contents.functionalInterfaceMessage);
463             dl.add(dd);
464             classInfoTree.add(dl);
465         }
466     }
467 
468     public boolean isFunctionalInterface() {
469         List&lt;? extends AnnotationMirror&gt; annotationMirrors = ((Element) typeElement).getAnnotationMirrors();
470         for (AnnotationMirror anno : annotationMirrors) {
471             if (utils.isFunctionalInterface(anno)) {
472                 return true;
473             }
474         }
475         return false;
476     }
477 
478 
479     @Override
480     public void addClassDeprecationInfo(Content classInfoTree) {
481         List&lt;? extends DocTree&gt; deprs = utils.getBlockTags(typeElement, DocTree.Kind.DEPRECATED);
</pre>
<hr />
<pre>
485             if (!deprs.isEmpty()) {
486                 CommentHelper ch = utils.getCommentHelper(typeElement);
487                 DocTree dt = deprs.get(0);
488                 List&lt;? extends DocTree&gt; commentTags = ch.getBody(dt);
489                 if (!commentTags.isEmpty()) {
490                     addInlineDeprecatedComment(typeElement, deprs.get(0), div);
491                 }
492             }
493             classInfoTree.add(div);
494         }
495     }
496 
497     /**
498      * Get links to the given classes.
499      *
500      * @param context the id of the context where the link will be printed
501      * @param list the list of classes
502      * @return a content tree for the class list
503      */
504     private Content getClassLinks(LinkInfoImpl.Kind context, Collection&lt;?&gt; list) {
<span class="line-modified">505         Content content = new ContentBuilder();</span>
506         boolean isFirst = true;
507         for (Object type : list) {
508             if (!isFirst) {
509                 Content separator = new StringContent(&quot;, &quot;);
<span class="line-modified">510                 content.add(separator);</span>
511             } else {
512                 isFirst = false;
513             }
514             // TODO: should we simply split this method up to avoid instanceof ?
515             if (type instanceof TypeElement) {
516                 Content link = getLink(
517                         new LinkInfoImpl(configuration, context, (TypeElement)(type)));
<span class="line-modified">518                 content.add(HtmlTree.CODE(link));</span>
519             } else {
520                 Content link = getLink(
521                         new LinkInfoImpl(configuration, context, ((TypeMirror)type)));
<span class="line-modified">522                 content.add(HtmlTree.CODE(link));</span>
523             }
524         }
<span class="line-modified">525         return content;</span>
526     }
527 
528     /**
529      * Return the TypeElement being documented.
530      *
531      * @return the TypeElement being documented.
532      */
533     @Override
534     public TypeElement getTypeElement() {
535         return typeElement;
536     }
537 }
</pre>
</td>
</tr>
</table>
<center><a href="ClassUseWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantsSummaryWriterImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  66 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/javaCalls.hpp&quot;
  69 #include &quot;runtime/os.hpp&quot;
  70 #include &quot;runtime/perfData.hpp&quot;
  71 #include &quot;runtime/reflection.hpp&quot;
  72 #include &quot;runtime/safepointVerifiers.hpp&quot;
  73 #include &quot;runtime/signature.hpp&quot;
  74 #include &quot;runtime/timer.hpp&quot;
  75 #include &quot;services/classLoadingService.hpp&quot;
  76 #include &quot;services/threadService.hpp&quot;
  77 #include &quot;utilities/align.hpp&quot;
  78 #include &quot;utilities/bitMap.inline.hpp&quot;
  79 #include &quot;utilities/copy.hpp&quot;
  80 #include &quot;utilities/exceptions.hpp&quot;
  81 #include &quot;utilities/globalDefinitions.hpp&quot;
  82 #include &quot;utilities/growableArray.hpp&quot;
  83 #include &quot;utilities/macros.hpp&quot;
  84 #include &quot;utilities/ostream.hpp&quot;
  85 #include &quot;utilities/resourceHash.hpp&quot;

  86 #include &quot;utilities/utf8.hpp&quot;
  87 
  88 #if INCLUDE_CDS
  89 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  90 #endif
  91 #if INCLUDE_JFR
  92 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  93 #endif
  94 
  95 // We generally try to create the oops directly when parsing, rather than
  96 // allocating temporary data structures and copying the bytes twice. A
  97 // temporary area is only needed when parsing utf8 entries in the constant
  98 // pool and when parsing line number tables.
  99 
 100 // We add assert in debug mode when class format is not checked.
 101 
 102 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 103 #define JAVA_MIN_SUPPORTED_VERSION        45
 104 #define JAVA_PREVIEW_MINOR_VERSION        65535
 105 
</pre>
<hr />
<pre>
 926   while (entry != NULL) {
 927     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 928       return false;
 929     }
 930     entry = entry-&gt;_next;
 931   }
 932 
 933   // No duplicate is found, allocate a new entry and fill it.
 934   entry = new NameSigHash();
 935   entry-&gt;_name = name;
 936   entry-&gt;_sig = sig;
 937 
 938   // Insert into hash table
 939   entry-&gt;_next = table[index];
 940   table[index] = entry;
 941 
 942   return true;
 943 }
 944 
 945 // Side-effects: populates the _local_interfaces field
<span class="line-modified"> 946 void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,</span>
<span class="line-modified"> 947                                        const int itfs_len,</span>
<span class="line-modified"> 948                                        ConstantPool* const cp,</span>
 949                                        bool* const has_nonstatic_concrete_methods,







 950                                        TRAPS) {
 951   assert(stream != NULL, &quot;invariant&quot;);
 952   assert(cp != NULL, &quot;invariant&quot;);
 953   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 954 
 955   if (itfs_len == 0) {
 956     _local_interfaces = Universe::the_empty_instance_klass_array();
 957   } else {
 958     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
 959     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);
 960 
 961     int index;
 962     for (index = 0; index &lt; itfs_len; index++) {
 963       const u2 interface_index = stream-&gt;get_u2(CHECK);
 964       Klass* interf;
 965       check_property(
 966         valid_klass_reference_at(interface_index),
 967         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 968         interface_index, CHECK);
 969       if (cp-&gt;tag_at(interface_index).is_klass()) {
</pre>
<hr />
<pre>
 977                            &quot;Bad interface name in class file %s&quot;, CHECK);
 978 
 979         // Call resolve_super so classcircularity is checked
 980         interf = SystemDictionary::resolve_super_or_fail(
 981                                                   _class_name,
 982                                                   unresolved_klass,
 983                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 984                                                   _protection_domain,
 985                                                   false,
 986                                                   CHECK);
 987       }
 988 
 989       if (!interf-&gt;is_interface()) {
 990         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 991                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
 992                           _class_name-&gt;as_klass_external_name(),
 993                           interf-&gt;external_name(),
 994                           interf-&gt;class_in_module_of_loader()));
 995       }
 996 
<span class="line-modified"> 997       if (InstanceKlass::cast(interf)-&gt;has_nonstatic_concrete_methods()) {</span>

 998         *has_nonstatic_concrete_methods = true;
 999       }
<span class="line-modified">1000       _local_interfaces-&gt;at_put(index, InstanceKlass::cast(interf));</span>



1001     }
1002 
1003     if (!_need_verify || itfs_len &lt;= 1) {
1004       return;
1005     }
1006 
1007     // Check if there&#39;s any duplicates in interfaces
1008     ResourceMark rm(THREAD);
1009     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1010                                                                  NameSigHash*,
1011                                                                  HASH_ROW_SIZE);
1012     initialize_hashtable(interface_names);
1013     bool dup = false;
1014     const Symbol* name = NULL;
1015     {
1016       debug_only(NoSafepointVerifier nsv;)
1017       for (index = 0; index &lt; itfs_len; index++) {
1018         const InstanceKlass* const k = _local_interfaces-&gt;at(index);
1019         name = k-&gt;name();
1020         // If no duplicates, add (name, NULL) in hashtable interface_names.
</pre>
<hr />
<pre>
4329       return;
4330     }
4331   }
4332 
4333   // Compute the non-contended fields count.
4334   // The packing code below relies on these counts to determine if some field
4335   // can be squeezed into the alignment gap. Contended fields are obviously
4336   // exempt from that.
4337   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4338   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4339   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4340   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4341   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4342 
4343   int static_value_type_count = 0;
4344   int nonstatic_value_type_count = 0;
4345   int* nonstatic_value_type_indexes = NULL;
4346   Klass** nonstatic_value_type_klasses = NULL;
4347   unsigned int value_type_oop_map_count = 0;
4348   int not_flattened_value_types = 0;

4349 
4350   int max_nonstatic_value_type = fac-&gt;count[NONSTATIC_FLATTENABLE] + 1;
4351 
4352   nonstatic_value_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,
4353                                                               max_nonstatic_value_type);
4354   for (int i = 0; i &lt; max_nonstatic_value_type; i++) {
4355     nonstatic_value_type_indexes[i] = -1;
4356   }
4357   nonstatic_value_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,
4358                                                               max_nonstatic_value_type);
4359 
4360   for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {
4361     if (fs.allocation_type() == STATIC_FLATTENABLE) {
4362       ResourceMark rm;
4363       if (!fs.signature()-&gt;is_Q_signature()) {
4364         THROW(vmSymbols::java_lang_ClassFormatError());
4365       }
4366       static_value_type_count++;
4367     } else if (fs.allocation_type() == NONSTATIC_FLATTENABLE) {
4368       // Pre-resolve the flattenable field and check for value type circularity issues.
4369       ResourceMark rm;
4370       if (!fs.signature()-&gt;is_Q_signature()) {
4371         THROW(vmSymbols::java_lang_ClassFormatError());
4372       }
4373       Klass* klass =
4374         SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
4375                                                             Handle(THREAD, _loader_data-&gt;class_loader()),
4376                                                             _protection_domain, true, CHECK);
4377       assert(klass != NULL, &quot;Sanity check&quot;);
4378       if (!klass-&gt;access_flags().is_value_type()) {
4379         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
4380       }
4381       ValueKlass* vk = ValueKlass::cast(klass);
4382       // Conditions to apply flattening or not should be defined in a single place
<span class="line-modified">4383       if ((ValueFieldMaxFlatSize &lt; 0) || (vk-&gt;size_helper() * HeapWordSize) &lt;= ValueFieldMaxFlatSize) {</span>









4384         nonstatic_value_type_indexes[nonstatic_value_type_count] = fs.index();
4385         nonstatic_value_type_klasses[nonstatic_value_type_count] = klass;
4386         nonstatic_value_type_count++;
4387 
4388         ValueKlass* vklass = ValueKlass::cast(klass);
4389         if (vklass-&gt;contains_oops()) {
4390           value_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();
4391         }
4392         fs.set_flattened(true);



4393       } else {
4394         not_flattened_value_types++;
4395         fs.set_flattened(false);
4396       }
4397     }
4398   }
4399 
4400   // Adjusting non_static_oop_count to take into account not flattened value types;
4401   nonstatic_oop_count += not_flattened_value_types;
4402 
4403   // Total non-static fields count, including every contended field
4404   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4405                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
4406                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_FLATTENABLE];
4407 
4408   const bool super_has_nonstatic_fields =
4409           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4410   const bool has_nonstatic_fields =
4411     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
4412   const bool has_nonstatic_value_fields = nonstatic_value_type_count &gt; 0;
</pre>
<hr />
<pre>
4831           instance_size,
4832           nonstatic_fields_start,
4833           nonstatic_fields_end,
4834           static_fields_end);
4835     nonstatic_oop_maps-&gt;print_on(tty);
4836     tty-&gt;print(&quot;\n&quot;);
4837     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);
4838     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);
4839     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);
4840     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);
4841     tty-&gt;print_cr(&quot;---&quot;);
4842   }
4843 
4844 #endif
4845   // Pass back information needed for InstanceKlass creation
4846   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4847   info-&gt;_instance_size = instance_size;
4848   info-&gt;_static_field_size = static_field_size;
4849   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4850   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;













4851 }
4852 
4853 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4854   assert(ik != NULL, &quot;invariant&quot;);
4855 
4856   const Klass* const super = ik-&gt;super();
4857 
4858   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4859   // in which case we don&#39;t have to register objects as finalizable
4860   if (!_has_empty_finalizer) {
4861     if (_has_finalizer ||
4862         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4863       ik-&gt;set_has_finalizer();
4864     }
4865   }
4866 
4867 #ifdef ASSERT
4868   bool f = false;
4869   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4870                                            vmSymbols::void_method_signature());
</pre>
<hr />
<pre>
5966 
5967           if (!match) {
5968             char buf[1000];
5969             tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
5970                        &quot;but the method is not available in class [%s].%s&quot;,
5971                         vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID_from(id),
5972                                                              buf, sizeof(buf)),
5973                         ik-&gt;name()-&gt;as_C_string(),
5974                         NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
5975             );
5976             tty-&gt;cr();
5977             DEBUG_ONLY(vm_exit(1));
5978           }
5979         }
5980       } // end for
5981     } // CheckIntrinsics
5982 #endif // ASSERT
5983   }
5984 }
5985 

5986 InstanceKlass* ClassFileParser::create_instance_klass(bool changed_by_loadhook, TRAPS) {
5987   if (_klass != NULL) {
5988     return _klass;
5989   }
5990 
5991   InstanceKlass* const ik =
5992     InstanceKlass::allocate_instance_klass(*this, CHECK_NULL);
5993 
5994   fill_instance_klass(ik, changed_by_loadhook, CHECK_NULL);
5995 
5996   assert(_klass == ik, &quot;invariant&quot;);
5997 
5998 
5999   if (ik-&gt;should_store_fingerprint()) {
6000     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
6001   }
6002 
6003   ik-&gt;set_has_passed_fingerprint_check(false);
6004   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
6005     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
</pre>
<hr />
<pre>
6035   const bool publicize = !is_internal();
6036 
6037   _loader_data-&gt;add_class(ik, publicize);
6038 
6039   set_klass_to_deallocate(ik);
6040 
6041   assert(_field_info != NULL, &quot;invariant&quot;);
6042   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
6043   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
6044          &quot;sanity&quot;);
6045 
6046   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
6047   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
6048 
6049   // Fill in information already parsed
6050   ik-&gt;set_should_verify_class(_need_verify);
6051 
6052   // Not yet: supers are done below to support the new subtype-checking fields
6053   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
6054   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);



6055   if (_is_empty_value) {
6056     ik-&gt;set_is_empty_value();
6057   }
6058   assert(_fac != NULL, &quot;invariant&quot;);
6059   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);
6060 
6061   // this transfers ownership of a lot of arrays from
6062   // the parser onto the InstanceKlass*
6063   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6064 
6065   // note that is not safe to use the fields in the parser from this point on
6066   assert(NULL == _cp, &quot;invariant&quot;);
6067   assert(NULL == _fields, &quot;invariant&quot;);
6068   assert(NULL == _methods, &quot;invariant&quot;);
6069   assert(NULL == _inner_classes, &quot;invariant&quot;);
6070   assert(NULL == _nest_members, &quot;invariant&quot;);
6071   assert(NULL == _local_interfaces, &quot;invariant&quot;);
6072   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6073   assert(NULL == _record_components, &quot;invariant&quot;);
6074 
</pre>
<hr />
<pre>
6084   // has to be changed accordingly.
6085   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
6086 
6087   ik-&gt;set_this_class_index(_this_class_index);
6088 
6089   if (is_unsafe_anonymous()) {
6090     // _this_class_index is a CONSTANT_Class entry that refers to this
6091     // anonymous class itself. If this class needs to refer to its own methods or
6092     // fields, it would use a CONSTANT_MethodRef, etc, which would reference
6093     // _this_class_index. However, because this class is anonymous (it&#39;s
6094     // not stored in SystemDictionary), _this_class_index cannot be resolved
6095     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
6096     // Therefore, we must eagerly resolve _this_class_index now.
6097     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
6098   }
6099 
6100   ik-&gt;set_minor_version(_minor_version);
6101   ik-&gt;set_major_version(_major_version);
6102   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
6103   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);



6104 
6105   if (_unsafe_anonymous_host != NULL) {
6106     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
6107     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
6108   }
6109 
6110   // Set PackageEntry for this_klass
6111   oop cl = ik-&gt;class_loader();
6112   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
6113   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
6114   ik-&gt;set_package(cld, CHECK);
6115 
6116   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
6117   assert(methods != NULL, &quot;invariant&quot;);
6118   const int methods_len = methods-&gt;length();
6119 
6120   check_methods_for_intrinsics(ik, methods);
6121 
6122   // Fill in field values obtained by parse_classfile_attributes
6123   if (_parsed_annotations-&gt;has_any_annotations()) {
</pre>
<hr />
<pre>
6416   _bad_constant_seen(0),
6417   _synthetic_flag(false),
6418   _sde_length(false),
6419   _sde_buffer(NULL),
6420   _sourcefile_index(0),
6421   _generic_signature_index(0),
6422   _major_version(0),
6423   _minor_version(0),
6424   _this_class_index(0),
6425   _super_class_index(0),
6426   _itfs_len(0),
6427   _java_fields_count(0),
6428   _need_verify(false),
6429   _relax_verify(false),
6430   _has_nonstatic_concrete_methods(false),
6431   _declares_nonstatic_concrete_methods(false),
6432   _has_final_method(false),
6433   _has_contended_fields(false),
6434   _has_flattenable_fields(false),
6435   _is_empty_value(false),


6436   _has_finalizer(false),
6437   _has_empty_finalizer(false),
6438   _has_vanilla_constructor(false),
6439   _max_bootstrap_specifier_index(-1) {
6440 
6441   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6442   _class_name-&gt;increment_refcount();
6443 
6444   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6445   assert(_loader_data != NULL, &quot;invariant&quot;);
6446   assert(stream != NULL, &quot;invariant&quot;);
6447   assert(_stream != NULL, &quot;invariant&quot;);
6448   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6449   assert(_class_name != NULL, &quot;invariant&quot;);
6450   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6451 
6452   // Figure out whether we can skip format checking (matching classic VM behavior)
6453   if (DumpSharedSpaces) {
6454     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6455     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
6755           classlist_file-&gt;flush();
6756         }
6757       }
6758     }
6759 #endif
6760   }
6761 
6762   // SUPERKLASS
6763   _super_class_index = stream-&gt;get_u2_fast();
6764   _super_klass = parse_super_class(cp,
6765                                    _super_class_index,
6766                                    _need_verify,
6767                                    CHECK);
6768 
6769   // Interfaces
6770   _itfs_len = stream-&gt;get_u2_fast();
6771   parse_interfaces(stream,
6772                    _itfs_len,
6773                    cp,
6774                    &amp;_has_nonstatic_concrete_methods,

6775                    CHECK);
6776 
6777   assert(_local_interfaces != NULL, &quot;invariant&quot;);
6778 
6779   // Fields (offsets are filled in later)
6780   _fac = new FieldAllocationCount();
6781   parse_fields(stream,
<span class="line-modified">6782                _access_flags.is_interface(),</span>
<span class="line-modified">6783                _access_flags.is_value_type(),</span>
6784                _fac,
6785                cp,
6786                cp_size,
6787                &amp;_java_fields_count,
6788                CHECK);
6789 
6790   assert(_fields != NULL, &quot;invariant&quot;);
6791 
6792   // Methods
6793   AccessFlags promoted_flags;
6794   parse_methods(stream,
<span class="line-modified">6795                 _access_flags.is_interface(),</span>
<span class="line-modified">6796                 _access_flags.is_value_type(),</span>
6797                 &amp;promoted_flags,
6798                 &amp;_has_final_method,
6799                 &amp;_declares_nonstatic_concrete_methods,
6800                 CHECK);
6801 
6802   assert(_methods != NULL, &quot;invariant&quot;);
6803 
6804   // promote flags from parse_methods() to the klass&#39; flags
6805   _access_flags.add_promoted_flags(promoted_flags.as_int());
6806 
6807   if (_declares_nonstatic_concrete_methods) {
6808     _has_nonstatic_concrete_methods = true;
6809   }
6810 
6811   // Additional attributes/annotations
6812   _parsed_annotations = new ClassAnnotationCollector();
6813   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6814 
6815   assert(_inner_classes != NULL, &quot;invariant&quot;);
6816 
</pre>
<hr />
<pre>
6825 
6826   // all bytes in stream read and parsed
6827 }
6828 
6829 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6830                                                  ConstantPool* cp,
6831                                                  TRAPS) {
6832   assert(stream != NULL, &quot;invariant&quot;);
6833   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6834   assert(cp != NULL, &quot;invariant&quot;);
6835   assert(_loader_data != NULL, &quot;invariant&quot;);
6836 
6837   if (_class_name == vmSymbols::java_lang_Object()) {
6838     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),
6839                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,
6840                    CHECK);
6841   }
6842   // We check super class after class file is parsed and format is checked
6843   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6844     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
<span class="line-modified">6845     if (_access_flags.is_interface()) {</span>
6846       // Before attempting to resolve the superclass, check for class format
6847       // errors not checked yet.
6848       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6849         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6850         CHECK);
6851     }
6852     Handle loader(THREAD, _loader_data-&gt;class_loader());
6853     _super_klass = (const InstanceKlass*)
6854                        SystemDictionary::resolve_super_or_fail(_class_name,
6855                                                                super_class_name,
6856                                                                loader,
6857                                                                _protection_domain,
6858                                                                true,
6859                                                                CHECK);
6860   }
6861 
6862   if (_super_klass != NULL) {
6863     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
6864       _has_nonstatic_concrete_methods = true;
6865     }



6866 
6867     if (_super_klass-&gt;is_interface()) {
6868       ResourceMark rm(THREAD);
6869       Exceptions::fthrow(
6870         THREAD_AND_LOCATION,
6871         vmSymbols::java_lang_IncompatibleClassChangeError(),
6872         &quot;class %s has interface %s as super class&quot;,
6873         _class_name-&gt;as_klass_external_name(),
6874         _super_klass-&gt;external_name()
6875       );
6876       return;
6877     }
6878 
6879     // For a value class, only java/lang/Object is an acceptable super class
6880     if (_access_flags.get_flags() &amp; JVM_ACC_VALUE) {
6881       guarantee_property(_super_klass-&gt;name() == vmSymbols::java_lang_Object(),
6882         &quot;Value type must have java.lang.Object as superclass in class file %s&quot;,
6883         CHECK);
6884     }
6885 
6886     // Make sure super class is not final
6887     if (_super_klass-&gt;is_final()) {
6888       THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
6889     }
6890   }
6891 












6892   // Compute the transitive list of all unique interfaces implemented by this class
6893   _transitive_interfaces =
6894     compute_transitive_interfaces(_super_klass,
6895                                   _local_interfaces,
6896                                   _loader_data,
6897                                   CHECK);
6898 
6899   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
6900 
6901   // sort methods
6902   _method_ordering = sort_methods(_methods);
6903 
6904   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
6905 
6906   Handle loader(THREAD, _loader_data-&gt;class_loader());
6907   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6908                                                     &amp;_num_miranda_methods,
6909                                                     _all_mirandas,
6910                                                     _super_klass,
6911                                                     _methods,
6912                                                     _access_flags,
6913                                                     _major_version,
6914                                                     loader,
6915                                                     _class_name,
6916                                                     _local_interfaces,
6917                                                     CHECK);
6918 
6919   // Size of Java itable (in words)
<span class="line-modified">6920   _itable_size = _access_flags.is_interface() ? 0 :</span>
6921     klassItable::compute_itable_size(_transitive_interfaces);
6922 
6923   assert(_fac != NULL, &quot;invariant&quot;);
6924   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
6925 
6926 
6927   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
6928     if (fs.is_flattenable() &amp;&amp; !fs.access_flags().is_static()) {
6929       // Pre-load value class
6930       Klass* klass = SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
6931           Handle(THREAD, _loader_data-&gt;class_loader()),
6932           _protection_domain, true, CHECK);
6933       assert(klass != NULL, &quot;Sanity check&quot;);
6934       assert(klass-&gt;access_flags().is_value_type(), &quot;Value type expected&quot;);
6935       _has_flattenable_fields = true;
6936     }
6937   }
6938 
6939   _field_info = new FieldLayoutInfo();
6940   if (UseNewFieldLayout) {
</pre>
</td>
<td>
<hr />
<pre>
  66 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/javaCalls.hpp&quot;
  69 #include &quot;runtime/os.hpp&quot;
  70 #include &quot;runtime/perfData.hpp&quot;
  71 #include &quot;runtime/reflection.hpp&quot;
  72 #include &quot;runtime/safepointVerifiers.hpp&quot;
  73 #include &quot;runtime/signature.hpp&quot;
  74 #include &quot;runtime/timer.hpp&quot;
  75 #include &quot;services/classLoadingService.hpp&quot;
  76 #include &quot;services/threadService.hpp&quot;
  77 #include &quot;utilities/align.hpp&quot;
  78 #include &quot;utilities/bitMap.inline.hpp&quot;
  79 #include &quot;utilities/copy.hpp&quot;
  80 #include &quot;utilities/exceptions.hpp&quot;
  81 #include &quot;utilities/globalDefinitions.hpp&quot;
  82 #include &quot;utilities/growableArray.hpp&quot;
  83 #include &quot;utilities/macros.hpp&quot;
  84 #include &quot;utilities/ostream.hpp&quot;
  85 #include &quot;utilities/resourceHash.hpp&quot;
<span class="line-added">  86 #include &quot;utilities/stringUtils.hpp&quot;</span>
  87 #include &quot;utilities/utf8.hpp&quot;
  88 
  89 #if INCLUDE_CDS
  90 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  91 #endif
  92 #if INCLUDE_JFR
  93 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  94 #endif
  95 
  96 // We generally try to create the oops directly when parsing, rather than
  97 // allocating temporary data structures and copying the bytes twice. A
  98 // temporary area is only needed when parsing utf8 entries in the constant
  99 // pool and when parsing line number tables.
 100 
 101 // We add assert in debug mode when class format is not checked.
 102 
 103 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 104 #define JAVA_MIN_SUPPORTED_VERSION        45
 105 #define JAVA_PREVIEW_MINOR_VERSION        65535
 106 
</pre>
<hr />
<pre>
 927   while (entry != NULL) {
 928     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 929       return false;
 930     }
 931     entry = entry-&gt;_next;
 932   }
 933 
 934   // No duplicate is found, allocate a new entry and fill it.
 935   entry = new NameSigHash();
 936   entry-&gt;_name = name;
 937   entry-&gt;_sig = sig;
 938 
 939   // Insert into hash table
 940   entry-&gt;_next = table[index];
 941   table[index] = entry;
 942 
 943   return true;
 944 }
 945 
 946 // Side-effects: populates the _local_interfaces field
<span class="line-modified"> 947 void ClassFileParser::parse_interfaces(const ClassFileStream* stream,</span>
<span class="line-modified"> 948                                        int itfs_len,</span>
<span class="line-modified"> 949                                        ConstantPool* cp,</span>
 950                                        bool* const has_nonstatic_concrete_methods,
<span class="line-added"> 951                                        // FIXME: lots of these functions</span>
<span class="line-added"> 952                                        // declare their parameters as const,</span>
<span class="line-added"> 953                                        // which adds only noise to the code.</span>
<span class="line-added"> 954                                        // Remove the spurious const modifiers.</span>
<span class="line-added"> 955                                        // Many are of the form &quot;const int x&quot;</span>
<span class="line-added"> 956                                        // or &quot;T* const x&quot;.</span>
<span class="line-added"> 957                                        bool* const is_declared_atomic,</span>
 958                                        TRAPS) {
 959   assert(stream != NULL, &quot;invariant&quot;);
 960   assert(cp != NULL, &quot;invariant&quot;);
 961   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 962 
 963   if (itfs_len == 0) {
 964     _local_interfaces = Universe::the_empty_instance_klass_array();
 965   } else {
 966     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
 967     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);
 968 
 969     int index;
 970     for (index = 0; index &lt; itfs_len; index++) {
 971       const u2 interface_index = stream-&gt;get_u2(CHECK);
 972       Klass* interf;
 973       check_property(
 974         valid_klass_reference_at(interface_index),
 975         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 976         interface_index, CHECK);
 977       if (cp-&gt;tag_at(interface_index).is_klass()) {
</pre>
<hr />
<pre>
 985                            &quot;Bad interface name in class file %s&quot;, CHECK);
 986 
 987         // Call resolve_super so classcircularity is checked
 988         interf = SystemDictionary::resolve_super_or_fail(
 989                                                   _class_name,
 990                                                   unresolved_klass,
 991                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 992                                                   _protection_domain,
 993                                                   false,
 994                                                   CHECK);
 995       }
 996 
 997       if (!interf-&gt;is_interface()) {
 998         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 999                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
1000                           _class_name-&gt;as_klass_external_name(),
1001                           interf-&gt;external_name(),
1002                           interf-&gt;class_in_module_of_loader()));
1003       }
1004 
<span class="line-modified">1005       InstanceKlass* ik = InstanceKlass::cast(interf);</span>
<span class="line-added">1006       if (ik-&gt;has_nonstatic_concrete_methods()) {</span>
1007         *has_nonstatic_concrete_methods = true;
1008       }
<span class="line-modified">1009       if (ik-&gt;is_declared_atomic()) {</span>
<span class="line-added">1010         *is_declared_atomic = true;</span>
<span class="line-added">1011       }</span>
<span class="line-added">1012       _local_interfaces-&gt;at_put(index, ik);</span>
1013     }
1014 
1015     if (!_need_verify || itfs_len &lt;= 1) {
1016       return;
1017     }
1018 
1019     // Check if there&#39;s any duplicates in interfaces
1020     ResourceMark rm(THREAD);
1021     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1022                                                                  NameSigHash*,
1023                                                                  HASH_ROW_SIZE);
1024     initialize_hashtable(interface_names);
1025     bool dup = false;
1026     const Symbol* name = NULL;
1027     {
1028       debug_only(NoSafepointVerifier nsv;)
1029       for (index = 0; index &lt; itfs_len; index++) {
1030         const InstanceKlass* const k = _local_interfaces-&gt;at(index);
1031         name = k-&gt;name();
1032         // If no duplicates, add (name, NULL) in hashtable interface_names.
</pre>
<hr />
<pre>
4341       return;
4342     }
4343   }
4344 
4345   // Compute the non-contended fields count.
4346   // The packing code below relies on these counts to determine if some field
4347   // can be squeezed into the alignment gap. Contended fields are obviously
4348   // exempt from that.
4349   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4350   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4351   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4352   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4353   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4354 
4355   int static_value_type_count = 0;
4356   int nonstatic_value_type_count = 0;
4357   int* nonstatic_value_type_indexes = NULL;
4358   Klass** nonstatic_value_type_klasses = NULL;
4359   unsigned int value_type_oop_map_count = 0;
4360   int not_flattened_value_types = 0;
<span class="line-added">4361   int not_atomic_value_types = 0;</span>
4362 
4363   int max_nonstatic_value_type = fac-&gt;count[NONSTATIC_FLATTENABLE] + 1;
4364 
4365   nonstatic_value_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,
4366                                                               max_nonstatic_value_type);
4367   for (int i = 0; i &lt; max_nonstatic_value_type; i++) {
4368     nonstatic_value_type_indexes[i] = -1;
4369   }
4370   nonstatic_value_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,
4371                                                               max_nonstatic_value_type);
4372 
4373   for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {
4374     if (fs.allocation_type() == STATIC_FLATTENABLE) {
4375       ResourceMark rm;
4376       if (!fs.signature()-&gt;is_Q_signature()) {
4377         THROW(vmSymbols::java_lang_ClassFormatError());
4378       }
4379       static_value_type_count++;
4380     } else if (fs.allocation_type() == NONSTATIC_FLATTENABLE) {
4381       // Pre-resolve the flattenable field and check for value type circularity issues.
4382       ResourceMark rm;
4383       if (!fs.signature()-&gt;is_Q_signature()) {
4384         THROW(vmSymbols::java_lang_ClassFormatError());
4385       }
4386       Klass* klass =
4387         SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
4388                                                             Handle(THREAD, _loader_data-&gt;class_loader()),
4389                                                             _protection_domain, true, CHECK);
4390       assert(klass != NULL, &quot;Sanity check&quot;);
4391       if (!klass-&gt;access_flags().is_value_type()) {
4392         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
4393       }
4394       ValueKlass* vk = ValueKlass::cast(klass);
4395       // Conditions to apply flattening or not should be defined in a single place
<span class="line-modified">4396       bool too_big_to_flatten = (ValueFieldMaxFlatSize &gt;= 0 &amp;&amp;</span>
<span class="line-added">4397                                  (vk-&gt;size_helper() * HeapWordSize) &gt; ValueFieldMaxFlatSize);</span>
<span class="line-added">4398       bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();</span>
<span class="line-added">4399       bool too_volatile_to_flatten = fs.access_flags().is_volatile();</span>
<span class="line-added">4400       if (vk-&gt;is_naturally_atomic()) {</span>
<span class="line-added">4401         too_atomic_to_flatten = false;</span>
<span class="line-added">4402         //too_volatile_to_flatten = false; //FIXME</span>
<span class="line-added">4403         // volatile fields are currently never flattened, this could change in the future</span>
<span class="line-added">4404       }</span>
<span class="line-added">4405       if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {</span>
4406         nonstatic_value_type_indexes[nonstatic_value_type_count] = fs.index();
4407         nonstatic_value_type_klasses[nonstatic_value_type_count] = klass;
4408         nonstatic_value_type_count++;
4409 
4410         ValueKlass* vklass = ValueKlass::cast(klass);
4411         if (vklass-&gt;contains_oops()) {
4412           value_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();
4413         }
4414         fs.set_flattened(true);
<span class="line-added">4415         if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note</span>
<span class="line-added">4416           not_atomic_value_types++;</span>
<span class="line-added">4417         }</span>
4418       } else {
4419         not_flattened_value_types++;
4420         fs.set_flattened(false);
4421       }
4422     }
4423   }
4424 
4425   // Adjusting non_static_oop_count to take into account not flattened value types;
4426   nonstatic_oop_count += not_flattened_value_types;
4427 
4428   // Total non-static fields count, including every contended field
4429   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4430                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
4431                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_FLATTENABLE];
4432 
4433   const bool super_has_nonstatic_fields =
4434           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4435   const bool has_nonstatic_fields =
4436     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
4437   const bool has_nonstatic_value_fields = nonstatic_value_type_count &gt; 0;
</pre>
<hr />
<pre>
4856           instance_size,
4857           nonstatic_fields_start,
4858           nonstatic_fields_end,
4859           static_fields_end);
4860     nonstatic_oop_maps-&gt;print_on(tty);
4861     tty-&gt;print(&quot;\n&quot;);
4862     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);
4863     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);
4864     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);
4865     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);
4866     tty-&gt;print_cr(&quot;---&quot;);
4867   }
4868 
4869 #endif
4870   // Pass back information needed for InstanceKlass creation
4871   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4872   info-&gt;_instance_size = instance_size;
4873   info-&gt;_static_field_size = static_field_size;
4874   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4875   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;
<span class="line-added">4876 </span>
<span class="line-added">4877   // A value type is naturally atomic if it has just one field, and</span>
<span class="line-added">4878   // that field is simple enough.</span>
<span class="line-added">4879   info-&gt;_is_naturally_atomic = (is_value_type() &amp;&amp;</span>
<span class="line-added">4880                                 !super_has_nonstatic_fields &amp;&amp;</span>
<span class="line-added">4881                                 (nonstatic_fields_count &lt;= 1) &amp;&amp;</span>
<span class="line-added">4882                                 (not_atomic_value_types == 0) &amp;&amp;</span>
<span class="line-added">4883                                 (nonstatic_contended_count == 0));</span>
<span class="line-added">4884   // This may be too restrictive, since if all the fields fit in 64</span>
<span class="line-added">4885   // bits we could make the decision to align instances of this class</span>
<span class="line-added">4886   // to 64-bit boundaries, and load and store them as single words.</span>
<span class="line-added">4887   // And on machines which supported larger atomics we could similarly</span>
<span class="line-added">4888   // allow larger values to be atomic, if properly aligned.</span>
4889 }
4890 
4891 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4892   assert(ik != NULL, &quot;invariant&quot;);
4893 
4894   const Klass* const super = ik-&gt;super();
4895 
4896   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4897   // in which case we don&#39;t have to register objects as finalizable
4898   if (!_has_empty_finalizer) {
4899     if (_has_finalizer ||
4900         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4901       ik-&gt;set_has_finalizer();
4902     }
4903   }
4904 
4905 #ifdef ASSERT
4906   bool f = false;
4907   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4908                                            vmSymbols::void_method_signature());
</pre>
<hr />
<pre>
6004 
6005           if (!match) {
6006             char buf[1000];
6007             tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
6008                        &quot;but the method is not available in class [%s].%s&quot;,
6009                         vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID_from(id),
6010                                                              buf, sizeof(buf)),
6011                         ik-&gt;name()-&gt;as_C_string(),
6012                         NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
6013             );
6014             tty-&gt;cr();
6015             DEBUG_ONLY(vm_exit(1));
6016           }
6017         }
6018       } // end for
6019     } // CheckIntrinsics
6020 #endif // ASSERT
6021   }
6022 }
6023 
<span class="line-added">6024 // Called from a factory method in KlassFactory, not from this file.</span>
6025 InstanceKlass* ClassFileParser::create_instance_klass(bool changed_by_loadhook, TRAPS) {
6026   if (_klass != NULL) {
6027     return _klass;
6028   }
6029 
6030   InstanceKlass* const ik =
6031     InstanceKlass::allocate_instance_klass(*this, CHECK_NULL);
6032 
6033   fill_instance_klass(ik, changed_by_loadhook, CHECK_NULL);
6034 
6035   assert(_klass == ik, &quot;invariant&quot;);
6036 
6037 
6038   if (ik-&gt;should_store_fingerprint()) {
6039     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
6040   }
6041 
6042   ik-&gt;set_has_passed_fingerprint_check(false);
6043   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
6044     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
</pre>
<hr />
<pre>
6074   const bool publicize = !is_internal();
6075 
6076   _loader_data-&gt;add_class(ik, publicize);
6077 
6078   set_klass_to_deallocate(ik);
6079 
6080   assert(_field_info != NULL, &quot;invariant&quot;);
6081   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
6082   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
6083          &quot;sanity&quot;);
6084 
6085   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
6086   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
6087 
6088   // Fill in information already parsed
6089   ik-&gt;set_should_verify_class(_need_verify);
6090 
6091   // Not yet: supers are done below to support the new subtype-checking fields
6092   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
6093   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
<span class="line-added">6094   if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_value()) {</span>
<span class="line-added">6095     ik-&gt;set_is_naturally_atomic();</span>
<span class="line-added">6096   }</span>
6097   if (_is_empty_value) {
6098     ik-&gt;set_is_empty_value();
6099   }
6100   assert(_fac != NULL, &quot;invariant&quot;);
6101   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);
6102 
6103   // this transfers ownership of a lot of arrays from
6104   // the parser onto the InstanceKlass*
6105   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6106 
6107   // note that is not safe to use the fields in the parser from this point on
6108   assert(NULL == _cp, &quot;invariant&quot;);
6109   assert(NULL == _fields, &quot;invariant&quot;);
6110   assert(NULL == _methods, &quot;invariant&quot;);
6111   assert(NULL == _inner_classes, &quot;invariant&quot;);
6112   assert(NULL == _nest_members, &quot;invariant&quot;);
6113   assert(NULL == _local_interfaces, &quot;invariant&quot;);
6114   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6115   assert(NULL == _record_components, &quot;invariant&quot;);
6116 
</pre>
<hr />
<pre>
6126   // has to be changed accordingly.
6127   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
6128 
6129   ik-&gt;set_this_class_index(_this_class_index);
6130 
6131   if (is_unsafe_anonymous()) {
6132     // _this_class_index is a CONSTANT_Class entry that refers to this
6133     // anonymous class itself. If this class needs to refer to its own methods or
6134     // fields, it would use a CONSTANT_MethodRef, etc, which would reference
6135     // _this_class_index. However, because this class is anonymous (it&#39;s
6136     // not stored in SystemDictionary), _this_class_index cannot be resolved
6137     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
6138     // Therefore, we must eagerly resolve _this_class_index now.
6139     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
6140   }
6141 
6142   ik-&gt;set_minor_version(_minor_version);
6143   ik-&gt;set_major_version(_major_version);
6144   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
6145   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);
<span class="line-added">6146   if (_is_declared_atomic) {</span>
<span class="line-added">6147     ik-&gt;set_is_declared_atomic();</span>
<span class="line-added">6148   }</span>
6149 
6150   if (_unsafe_anonymous_host != NULL) {
6151     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
6152     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
6153   }
6154 
6155   // Set PackageEntry for this_klass
6156   oop cl = ik-&gt;class_loader();
6157   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
6158   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
6159   ik-&gt;set_package(cld, CHECK);
6160 
6161   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
6162   assert(methods != NULL, &quot;invariant&quot;);
6163   const int methods_len = methods-&gt;length();
6164 
6165   check_methods_for_intrinsics(ik, methods);
6166 
6167   // Fill in field values obtained by parse_classfile_attributes
6168   if (_parsed_annotations-&gt;has_any_annotations()) {
</pre>
<hr />
<pre>
6461   _bad_constant_seen(0),
6462   _synthetic_flag(false),
6463   _sde_length(false),
6464   _sde_buffer(NULL),
6465   _sourcefile_index(0),
6466   _generic_signature_index(0),
6467   _major_version(0),
6468   _minor_version(0),
6469   _this_class_index(0),
6470   _super_class_index(0),
6471   _itfs_len(0),
6472   _java_fields_count(0),
6473   _need_verify(false),
6474   _relax_verify(false),
6475   _has_nonstatic_concrete_methods(false),
6476   _declares_nonstatic_concrete_methods(false),
6477   _has_final_method(false),
6478   _has_contended_fields(false),
6479   _has_flattenable_fields(false),
6480   _is_empty_value(false),
<span class="line-added">6481   _is_naturally_atomic(false),</span>
<span class="line-added">6482   _is_declared_atomic(false),</span>
6483   _has_finalizer(false),
6484   _has_empty_finalizer(false),
6485   _has_vanilla_constructor(false),
6486   _max_bootstrap_specifier_index(-1) {
6487 
6488   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6489   _class_name-&gt;increment_refcount();
6490 
6491   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6492   assert(_loader_data != NULL, &quot;invariant&quot;);
6493   assert(stream != NULL, &quot;invariant&quot;);
6494   assert(_stream != NULL, &quot;invariant&quot;);
6495   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6496   assert(_class_name != NULL, &quot;invariant&quot;);
6497   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6498 
6499   // Figure out whether we can skip format checking (matching classic VM behavior)
6500   if (DumpSharedSpaces) {
6501     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6502     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
6802           classlist_file-&gt;flush();
6803         }
6804       }
6805     }
6806 #endif
6807   }
6808 
6809   // SUPERKLASS
6810   _super_class_index = stream-&gt;get_u2_fast();
6811   _super_klass = parse_super_class(cp,
6812                                    _super_class_index,
6813                                    _need_verify,
6814                                    CHECK);
6815 
6816   // Interfaces
6817   _itfs_len = stream-&gt;get_u2_fast();
6818   parse_interfaces(stream,
6819                    _itfs_len,
6820                    cp,
6821                    &amp;_has_nonstatic_concrete_methods,
<span class="line-added">6822                    &amp;_is_declared_atomic,</span>
6823                    CHECK);
6824 
6825   assert(_local_interfaces != NULL, &quot;invariant&quot;);
6826 
6827   // Fields (offsets are filled in later)
6828   _fac = new FieldAllocationCount();
6829   parse_fields(stream,
<span class="line-modified">6830                is_interface(),</span>
<span class="line-modified">6831                is_value_type(),</span>
6832                _fac,
6833                cp,
6834                cp_size,
6835                &amp;_java_fields_count,
6836                CHECK);
6837 
6838   assert(_fields != NULL, &quot;invariant&quot;);
6839 
6840   // Methods
6841   AccessFlags promoted_flags;
6842   parse_methods(stream,
<span class="line-modified">6843                 is_interface(),</span>
<span class="line-modified">6844                 is_value_type(),</span>
6845                 &amp;promoted_flags,
6846                 &amp;_has_final_method,
6847                 &amp;_declares_nonstatic_concrete_methods,
6848                 CHECK);
6849 
6850   assert(_methods != NULL, &quot;invariant&quot;);
6851 
6852   // promote flags from parse_methods() to the klass&#39; flags
6853   _access_flags.add_promoted_flags(promoted_flags.as_int());
6854 
6855   if (_declares_nonstatic_concrete_methods) {
6856     _has_nonstatic_concrete_methods = true;
6857   }
6858 
6859   // Additional attributes/annotations
6860   _parsed_annotations = new ClassAnnotationCollector();
6861   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6862 
6863   assert(_inner_classes != NULL, &quot;invariant&quot;);
6864 
</pre>
<hr />
<pre>
6873 
6874   // all bytes in stream read and parsed
6875 }
6876 
6877 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6878                                                  ConstantPool* cp,
6879                                                  TRAPS) {
6880   assert(stream != NULL, &quot;invariant&quot;);
6881   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6882   assert(cp != NULL, &quot;invariant&quot;);
6883   assert(_loader_data != NULL, &quot;invariant&quot;);
6884 
6885   if (_class_name == vmSymbols::java_lang_Object()) {
6886     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),
6887                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,
6888                    CHECK);
6889   }
6890   // We check super class after class file is parsed and format is checked
6891   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6892     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
<span class="line-modified">6893     if (is_interface()) {</span>
6894       // Before attempting to resolve the superclass, check for class format
6895       // errors not checked yet.
6896       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6897         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6898         CHECK);
6899     }
6900     Handle loader(THREAD, _loader_data-&gt;class_loader());
6901     _super_klass = (const InstanceKlass*)
6902                        SystemDictionary::resolve_super_or_fail(_class_name,
6903                                                                super_class_name,
6904                                                                loader,
6905                                                                _protection_domain,
6906                                                                true,
6907                                                                CHECK);
6908   }
6909 
6910   if (_super_klass != NULL) {
6911     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
6912       _has_nonstatic_concrete_methods = true;
6913     }
<span class="line-added">6914     if (_super_klass-&gt;is_declared_atomic()) {</span>
<span class="line-added">6915       _is_declared_atomic = true;</span>
<span class="line-added">6916     }</span>
6917 
6918     if (_super_klass-&gt;is_interface()) {
6919       ResourceMark rm(THREAD);
6920       Exceptions::fthrow(
6921         THREAD_AND_LOCATION,
6922         vmSymbols::java_lang_IncompatibleClassChangeError(),
6923         &quot;class %s has interface %s as super class&quot;,
6924         _class_name-&gt;as_klass_external_name(),
6925         _super_klass-&gt;external_name()
6926       );
6927       return;
6928     }
6929 
6930     // For a value class, only java/lang/Object is an acceptable super class
6931     if (_access_flags.get_flags() &amp; JVM_ACC_VALUE) {
6932       guarantee_property(_super_klass-&gt;name() == vmSymbols::java_lang_Object(),
6933         &quot;Value type must have java.lang.Object as superclass in class file %s&quot;,
6934         CHECK);
6935     }
6936 
6937     // Make sure super class is not final
6938     if (_super_klass-&gt;is_final()) {
6939       THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
6940     }
6941   }
6942 
<span class="line-added">6943   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {</span>
<span class="line-added">6944     // This is the original source of this condition.</span>
<span class="line-added">6945     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.</span>
<span class="line-added">6946     _is_declared_atomic = true;</span>
<span class="line-added">6947   } else if (*ForceNonTearable != &#39;\0&#39;) {</span>
<span class="line-added">6948     // Allow a command line switch to force the same atomicity property:</span>
<span class="line-added">6949     const char* class_name_str = _class_name-&gt;as_C_string();</span>
<span class="line-added">6950     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {</span>
<span class="line-added">6951       _is_declared_atomic = true;</span>
<span class="line-added">6952     }</span>
<span class="line-added">6953   }</span>
<span class="line-added">6954 </span>
6955   // Compute the transitive list of all unique interfaces implemented by this class
6956   _transitive_interfaces =
6957     compute_transitive_interfaces(_super_klass,
6958                                   _local_interfaces,
6959                                   _loader_data,
6960                                   CHECK);
6961 
6962   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
6963 
6964   // sort methods
6965   _method_ordering = sort_methods(_methods);
6966 
6967   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
6968 
6969   Handle loader(THREAD, _loader_data-&gt;class_loader());
6970   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6971                                                     &amp;_num_miranda_methods,
6972                                                     _all_mirandas,
6973                                                     _super_klass,
6974                                                     _methods,
6975                                                     _access_flags,
6976                                                     _major_version,
6977                                                     loader,
6978                                                     _class_name,
6979                                                     _local_interfaces,
6980                                                     CHECK);
6981 
6982   // Size of Java itable (in words)
<span class="line-modified">6983   _itable_size = is_interface() ? 0 :</span>
6984     klassItable::compute_itable_size(_transitive_interfaces);
6985 
6986   assert(_fac != NULL, &quot;invariant&quot;);
6987   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
6988 
6989 
6990   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
6991     if (fs.is_flattenable() &amp;&amp; !fs.access_flags().is_static()) {
6992       // Pre-load value class
6993       Klass* klass = SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
6994           Handle(THREAD, _loader_data-&gt;class_loader()),
6995           _protection_domain, true, CHECK);
6996       assert(klass != NULL, &quot;Sanity check&quot;);
6997       assert(klass-&gt;access_flags().is_value_type(), &quot;Value type expected&quot;);
6998       _has_flattenable_fields = true;
6999     }
7000   }
7001 
7002   _field_info = new FieldLayoutInfo();
7003   if (UseNewFieldLayout) {
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
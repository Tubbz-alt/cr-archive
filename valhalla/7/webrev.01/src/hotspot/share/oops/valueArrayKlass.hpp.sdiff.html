<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/valueArrayKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="valueArrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/valueArrayKlass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 70   // klass allocation
 71   static ValueArrayKlass* allocate_klass(ArrayStorageProperties storage_props, Klass* element_klass, TRAPS);
 72 
 73   void initialize(TRAPS);
 74 
 75   ModuleEntry* module() const;
 76   PackageEntry* package() const;
 77 
 78   bool can_be_primary_super_slow() const;
 79   GrowableArray&lt;Klass*&gt;* compute_secondary_supers(int num_extra_slots,
 80                                                   Array&lt;InstanceKlass*&gt;* transitive_interfaces);
 81 
 82   int element_byte_size() const { return 1 &lt;&lt; layout_helper_log2_element_size(_layout_helper); }
 83 
 84   bool is_valueArray_klass_slow() const { return true; }
 85 
 86   bool contains_oops() {
 87     return element_klass()-&gt;contains_oops();
 88   }
 89 
<span class="line-modified"> 90   bool is_atomic() {</span>

 91     return element_klass()-&gt;is_atomic();
 92   }
 93 
 94   oop protection_domain() const;
 95 
 96   static jint array_layout_helper(ValueKlass* vklass); // layout helper for values
 97 
 98   // sizing
 99   static int header_size()  { return sizeof(ValueArrayKlass)/HeapWordSize; }
100   int size() const          { return ArrayKlass::static_size(header_size()); }
101 
102   jint max_elements() const;
103 
104   int oop_size(oop obj) const;
105 
106   // Oop Allocation
107   valueArrayOop allocate(int length, TRAPS);
108   oop multi_allocate(int rank, jint* sizes, TRAPS);
109 
110   // Naming
</pre>
</td>
<td>
<hr />
<pre>
 70   // klass allocation
 71   static ValueArrayKlass* allocate_klass(ArrayStorageProperties storage_props, Klass* element_klass, TRAPS);
 72 
 73   void initialize(TRAPS);
 74 
 75   ModuleEntry* module() const;
 76   PackageEntry* package() const;
 77 
 78   bool can_be_primary_super_slow() const;
 79   GrowableArray&lt;Klass*&gt;* compute_secondary_supers(int num_extra_slots,
 80                                                   Array&lt;InstanceKlass*&gt;* transitive_interfaces);
 81 
 82   int element_byte_size() const { return 1 &lt;&lt; layout_helper_log2_element_size(_layout_helper); }
 83 
 84   bool is_valueArray_klass_slow() const { return true; }
 85 
 86   bool contains_oops() {
 87     return element_klass()-&gt;contains_oops();
 88   }
 89 
<span class="line-modified"> 90   // Override.</span>
<span class="line-added"> 91   bool element_access_is_atomic() {</span>
 92     return element_klass()-&gt;is_atomic();
 93   }
 94 
 95   oop protection_domain() const;
 96 
 97   static jint array_layout_helper(ValueKlass* vklass); // layout helper for values
 98 
 99   // sizing
100   static int header_size()  { return sizeof(ValueArrayKlass)/HeapWordSize; }
101   int size() const          { return ArrayKlass::static_size(header_size()); }
102 
103   jint max_elements() const;
104 
105   int oop_size(oop obj) const;
106 
107   // Oop Allocation
108   valueArrayOop allocate(int length, TRAPS);
109   oop multi_allocate(int rank, jint* sizes, TRAPS);
110 
111   // Naming
</pre>
</td>
</tr>
</table>
<center><a href="valueArrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/valueArrayKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="instanceKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueArrayKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/valueArrayKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 66   assert(is_valueArray_klass(), &quot;sanity&quot;);
 67 
 68   CMH(&quot;tweak name symbol refcnt ?&quot;)
 69 #ifndef PRODUCT
 70   if (PrintValueArrayLayout) {
 71     print();
 72   }
 73 #endif
 74 }
 75 
 76 ValueKlass* ValueArrayKlass::element_klass() const {
 77   return ValueKlass::cast(_element_klass);
 78 }
 79 
 80 void ValueArrayKlass::set_element_klass(Klass* k) {
 81   _element_klass = k;
 82 }
 83 
 84 ValueArrayKlass* ValueArrayKlass::allocate_klass(Klass* element_klass, TRAPS) {
 85   assert(ValueArrayFlatten, &quot;Flatten array required&quot;);
<span class="line-modified"> 86   assert(ValueKlass::cast(element_klass)-&gt;is_atomic() || (!ValueArrayAtomicAccess), &quot;Atomic by-default&quot;);</span>
 87 
 88   /*
 89    *  MVT-&gt;LWorld, now need to allocate secondaries array types, just like objArrayKlass...
 90    *  ...so now we are trying out covariant array types, just copy objArrayKlass
 91    *  TODO refactor any remaining commonality
 92    */
 93 
 94   // Eagerly allocate the direct array supertype, which would be &quot;[L&lt;vt&gt;;&quot; for this &quot;[Q&lt;vt&gt;;&quot;
 95   Klass* super_klass = element_klass-&gt;array_klass_or_null(ArrayStorageProperties::empty);
 96   if (super_klass == NULL) {
 97     MutexUnlocker mu(MultiArray_lock);
 98     // allocate super...need to drop the lock
 99     element_klass-&gt;array_klass(ArrayStorageProperties::empty, 1, CHECK_NULL);
100     // retry, start from the beginning since lock dropped...
101     Klass* ak = element_klass-&gt;array_klass(ArrayStorageProperties::flattened_and_null_free, 1, CHECK_NULL);
102     return ValueArrayKlass::cast(ak);
103   }
104 
105   Symbol* name = ArrayKlass::create_element_klass_array_name(true, element_klass, CHECK_NULL);
106   ClassLoaderData* loader_data = element_klass-&gt;class_loader_data();
</pre>
</td>
<td>
<hr />
<pre>
 66   assert(is_valueArray_klass(), &quot;sanity&quot;);
 67 
 68   CMH(&quot;tweak name symbol refcnt ?&quot;)
 69 #ifndef PRODUCT
 70   if (PrintValueArrayLayout) {
 71     print();
 72   }
 73 #endif
 74 }
 75 
 76 ValueKlass* ValueArrayKlass::element_klass() const {
 77   return ValueKlass::cast(_element_klass);
 78 }
 79 
 80 void ValueArrayKlass::set_element_klass(Klass* k) {
 81   _element_klass = k;
 82 }
 83 
 84 ValueArrayKlass* ValueArrayKlass::allocate_klass(Klass* element_klass, TRAPS) {
 85   assert(ValueArrayFlatten, &quot;Flatten array required&quot;);
<span class="line-modified"> 86   assert(ValueKlass::cast(element_klass)-&gt;is_naturally_atomic() || (!ValueArrayAtomicAccess), &quot;Atomic by-default&quot;);</span>
 87 
 88   /*
 89    *  MVT-&gt;LWorld, now need to allocate secondaries array types, just like objArrayKlass...
 90    *  ...so now we are trying out covariant array types, just copy objArrayKlass
 91    *  TODO refactor any remaining commonality
 92    */
 93 
 94   // Eagerly allocate the direct array supertype, which would be &quot;[L&lt;vt&gt;;&quot; for this &quot;[Q&lt;vt&gt;;&quot;
 95   Klass* super_klass = element_klass-&gt;array_klass_or_null(ArrayStorageProperties::empty);
 96   if (super_klass == NULL) {
 97     MutexUnlocker mu(MultiArray_lock);
 98     // allocate super...need to drop the lock
 99     element_klass-&gt;array_klass(ArrayStorageProperties::empty, 1, CHECK_NULL);
100     // retry, start from the beginning since lock dropped...
101     Klass* ak = element_klass-&gt;array_klass(ArrayStorageProperties::flattened_and_null_free, 1, CHECK_NULL);
102     return ValueArrayKlass::cast(ak);
103   }
104 
105   Symbol* name = ArrayKlass::create_element_klass_array_name(true, element_klass, CHECK_NULL);
106   ClassLoaderData* loader_data = element_klass-&gt;class_loader_data();
</pre>
</td>
</tr>
</table>
<center><a href="instanceKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueArrayKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
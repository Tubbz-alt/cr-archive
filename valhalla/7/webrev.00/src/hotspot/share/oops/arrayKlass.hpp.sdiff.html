<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/arrayKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../classfile/vmSymbols.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/arrayKlass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 52   // Constructors
 53   // The constructor with the Symbol argument does the real array
 54   // initialization, the other is a dummy
 55   ArrayKlass(Symbol* name, KlassID id);
 56   ArrayKlass() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for cds&quot;); }
 57 
 58   // Create array_name for element klass, creates a permanent symbol, returns result
 59   static Symbol* create_element_klass_array_name(bool is_qtype, Klass* element_klass, TRAPS);
 60 
 61  public:
 62   // Instance variables
 63   virtual Klass* element_klass() const      { return _element_klass; }
 64   virtual void set_element_klass(Klass* k)  { _element_klass = k; }
 65 
 66   // Compiler/Interpreter offset
 67   static ByteSize element_klass_offset() { return in_ByteSize(offset_of(ArrayKlass, _element_klass)); }
 68 
 69   // Presented with an ArrayKlass, which storage_properties should be encoded into arrayOop
 70   virtual ArrayStorageProperties storage_properties() { return ArrayStorageProperties::empty; }
 71 




 72   // Testing operation
 73   DEBUG_ONLY(bool is_array_klass_slow() const { return true; })
 74 
 75   // Instance variables
 76   int dimension() const                 { return _dimension;      }
 77   void set_dimension(int dimension)     { _dimension = dimension; }
 78 
 79   Klass* higher_dimension() const     { return _higher_dimension; }
 80   inline Klass* higher_dimension_acquire() const; // load with acquire semantics
 81   void set_higher_dimension(Klass* k) { _higher_dimension = k; }
 82   inline void release_set_higher_dimension(Klass* k); // store with release semantics
 83 
 84   Klass* lower_dimension() const      { return _lower_dimension; }
 85   void set_lower_dimension(Klass* k)  { _lower_dimension = k; }
 86 
 87   // offset of first element, including any padding for the sake of alignment
 88   int  array_header_in_bytes() const    { return layout_helper_header_size(layout_helper()); }
 89   int  log2_element_size() const        { return layout_helper_log2_element_size(layout_helper()); }
 90   // type of elements (T_OBJECT for both oop arrays and array-arrays)
 91   BasicType element_type() const        { return layout_helper_element_type(layout_helper()); }
</pre>
</td>
<td>
<hr />
<pre>
 52   // Constructors
 53   // The constructor with the Symbol argument does the real array
 54   // initialization, the other is a dummy
 55   ArrayKlass(Symbol* name, KlassID id);
 56   ArrayKlass() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for cds&quot;); }
 57 
 58   // Create array_name for element klass, creates a permanent symbol, returns result
 59   static Symbol* create_element_klass_array_name(bool is_qtype, Klass* element_klass, TRAPS);
 60 
 61  public:
 62   // Instance variables
 63   virtual Klass* element_klass() const      { return _element_klass; }
 64   virtual void set_element_klass(Klass* k)  { _element_klass = k; }
 65 
 66   // Compiler/Interpreter offset
 67   static ByteSize element_klass_offset() { return in_ByteSize(offset_of(ArrayKlass, _element_klass)); }
 68 
 69   // Presented with an ArrayKlass, which storage_properties should be encoded into arrayOop
 70   virtual ArrayStorageProperties storage_properties() { return ArrayStorageProperties::empty; }
 71 
<span class="line-added"> 72   // Are loads and stores to this concrete array type atomic?</span>
<span class="line-added"> 73   // Note that Object[] is naturally atomic, but its subtypes may not be.</span>
<span class="line-added"> 74   virtual bool element_access_is_atomic() { return true; }</span>
<span class="line-added"> 75 </span>
 76   // Testing operation
 77   DEBUG_ONLY(bool is_array_klass_slow() const { return true; })
 78 
 79   // Instance variables
 80   int dimension() const                 { return _dimension;      }
 81   void set_dimension(int dimension)     { _dimension = dimension; }
 82 
 83   Klass* higher_dimension() const     { return _higher_dimension; }
 84   inline Klass* higher_dimension_acquire() const; // load with acquire semantics
 85   void set_higher_dimension(Klass* k) { _higher_dimension = k; }
 86   inline void release_set_higher_dimension(Klass* k); // store with release semantics
 87 
 88   Klass* lower_dimension() const      { return _lower_dimension; }
 89   void set_lower_dimension(Klass* k)  { _lower_dimension = k; }
 90 
 91   // offset of first element, including any padding for the sake of alignment
 92   int  array_header_in_bytes() const    { return layout_helper_header_size(layout_helper()); }
 93   int  log2_element_size() const        { return layout_helper_log2_element_size(layout_helper()); }
 94   // type of elements (T_OBJECT for both oop arrays and array-arrays)
 95   BasicType element_type() const        { return layout_helper_element_type(layout_helper()); }
</pre>
</td>
</tr>
</table>
<center><a href="../classfile/vmSymbols.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
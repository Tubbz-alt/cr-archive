<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/defaultMethods.hpp&quot;
  33 #include &quot;classfile/dictionary.hpp&quot;
  34 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/moduleEntry.hpp&quot;
  37 #include &quot;classfile/packageEntry.hpp&quot;
  38 #include &quot;classfile/symbolTable.hpp&quot;
  39 #include &quot;classfile/systemDictionary.hpp&quot;
  40 #include &quot;classfile/verificationType.hpp&quot;
  41 #include &quot;classfile/verifier.hpp&quot;
  42 #include &quot;classfile/vmSymbols.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;logging/logStream.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/annotations.hpp&quot;
  51 #include &quot;oops/constantPool.inline.hpp&quot;
  52 #include &quot;oops/fieldStreams.inline.hpp&quot;
  53 #include &quot;oops/instanceKlass.hpp&quot;
  54 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  55 #include &quot;oops/klass.inline.hpp&quot;
  56 #include &quot;oops/klassVtable.hpp&quot;
  57 #include &quot;oops/metadata.hpp&quot;
  58 #include &quot;oops/method.inline.hpp&quot;
  59 #include &quot;oops/oop.inline.hpp&quot;
  60 #include &quot;oops/recordComponent.hpp&quot;
  61 #include &quot;oops/symbol.hpp&quot;
  62 #include &quot;oops/valueKlass.inline.hpp&quot;
  63 #include &quot;prims/jvmtiExport.hpp&quot;
  64 #include &quot;prims/jvmtiThreadState.hpp&quot;
  65 #include &quot;runtime/arguments.hpp&quot;
  66 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/javaCalls.hpp&quot;
  69 #include &quot;runtime/os.hpp&quot;
  70 #include &quot;runtime/perfData.hpp&quot;
  71 #include &quot;runtime/reflection.hpp&quot;
  72 #include &quot;runtime/safepointVerifiers.hpp&quot;
  73 #include &quot;runtime/signature.hpp&quot;
  74 #include &quot;runtime/timer.hpp&quot;
  75 #include &quot;services/classLoadingService.hpp&quot;
  76 #include &quot;services/threadService.hpp&quot;
  77 #include &quot;utilities/align.hpp&quot;
  78 #include &quot;utilities/bitMap.inline.hpp&quot;
  79 #include &quot;utilities/copy.hpp&quot;
  80 #include &quot;utilities/exceptions.hpp&quot;
  81 #include &quot;utilities/globalDefinitions.hpp&quot;
  82 #include &quot;utilities/growableArray.hpp&quot;
  83 #include &quot;utilities/macros.hpp&quot;
  84 #include &quot;utilities/ostream.hpp&quot;
  85 #include &quot;utilities/resourceHash.hpp&quot;
<a name="1" id="anc1"></a>
  86 #include &quot;utilities/utf8.hpp&quot;
  87 
  88 #if INCLUDE_CDS
  89 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  90 #endif
  91 #if INCLUDE_JFR
  92 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  93 #endif
  94 
  95 // We generally try to create the oops directly when parsing, rather than
  96 // allocating temporary data structures and copying the bytes twice. A
  97 // temporary area is only needed when parsing utf8 entries in the constant
  98 // pool and when parsing line number tables.
  99 
 100 // We add assert in debug mode when class format is not checked.
 101 
 102 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 103 #define JAVA_MIN_SUPPORTED_VERSION        45
 104 #define JAVA_PREVIEW_MINOR_VERSION        65535
 105 
 106 // Used for two backward compatibility reasons:
 107 // - to check for new additions to the class file format in JDK1.5
 108 // - to check for bug fixes in the format checker in JDK1.5
 109 #define JAVA_1_5_VERSION                  49
 110 
 111 // Used for backward compatibility reasons:
 112 // - to check for javac bug fixes that happened after 1.5
 113 // - also used as the max version when running in jdk6
 114 #define JAVA_6_VERSION                    50
 115 
 116 // Used for backward compatibility reasons:
 117 // - to disallow argument and require ACC_STATIC for &lt;clinit&gt; methods
 118 #define JAVA_7_VERSION                    51
 119 
 120 // Extension method support.
 121 #define JAVA_8_VERSION                    52
 122 
 123 #define JAVA_9_VERSION                    53
 124 
 125 #define JAVA_10_VERSION                   54
 126 
 127 #define JAVA_11_VERSION                   55
 128 
 129 #define JAVA_12_VERSION                   56
 130 
 131 #define JAVA_13_VERSION                   57
 132 
 133 #define JAVA_14_VERSION                   58
 134 
 135 #define JAVA_15_VERSION                   59
 136 
 137 #define CONSTANT_CLASS_DESCRIPTORS        59
 138 
 139 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 140   assert((bad_constant == JVM_CONSTANT_Module ||
 141           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 142          &quot;Unexpected bad constant pool entry&quot;);
 143   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 144 }
 145 
 146 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 147                                                   ConstantPool* cp,
 148                                                   const int length,
 149                                                   TRAPS) {
 150   assert(stream != NULL, &quot;invariant&quot;);
 151   assert(cp != NULL, &quot;invariant&quot;);
 152 
 153   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 154   // this function (_current can be allocated in a register, with scalar
 155   // replacement of aggregates). The _current pointer is copied back to
 156   // stream() when this function returns. DON&#39;T call another method within
 157   // this method that uses stream().
 158   const ClassFileStream cfs1 = *stream;
 159   const ClassFileStream* const cfs = &amp;cfs1;
 160 
 161   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 162   debug_only(const u1* const old_current = stream-&gt;current();)
 163 
 164   // Used for batching symbol allocations.
 165   const char* names[SymbolTable::symbol_alloc_batch_size];
 166   int lengths[SymbolTable::symbol_alloc_batch_size];
 167   int indices[SymbolTable::symbol_alloc_batch_size];
 168   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 169   int names_count = 0;
 170 
 171   // parsing  Index 0 is unused
 172   for (int index = 1; index &lt; length; index++) {
 173     // Each of the following case guarantees one more byte in the stream
 174     // for the following tag or the access_flags following constant pool,
 175     // so we don&#39;t need bounds-check for reading tag.
 176     const u1 tag = cfs-&gt;get_u1_fast();
 177     switch (tag) {
 178       case JVM_CONSTANT_Class: {
 179         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 180         const u2 name_index = cfs-&gt;get_u2_fast();
 181         cp-&gt;klass_index_at_put(index, name_index);
 182         break;
 183       }
 184       case JVM_CONSTANT_Fieldref: {
 185         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 186         const u2 class_index = cfs-&gt;get_u2_fast();
 187         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 188         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 189         break;
 190       }
 191       case JVM_CONSTANT_Methodref: {
 192         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 193         const u2 class_index = cfs-&gt;get_u2_fast();
 194         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 195         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 196         break;
 197       }
 198       case JVM_CONSTANT_InterfaceMethodref: {
 199         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 200         const u2 class_index = cfs-&gt;get_u2_fast();
 201         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 202         cp-&gt;interface_method_at_put(index, class_index, name_and_type_index);
 203         break;
 204       }
 205       case JVM_CONSTANT_String : {
 206         cfs-&gt;guarantee_more(3, CHECK);  // string_index, tag/access_flags
 207         const u2 string_index = cfs-&gt;get_u2_fast();
 208         cp-&gt;string_index_at_put(index, string_index);
 209         break;
 210       }
 211       case JVM_CONSTANT_MethodHandle :
 212       case JVM_CONSTANT_MethodType: {
 213         if (_major_version &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
 214           classfile_parse_error(
 215             &quot;Class file version does not support constant tag %u in class file %s&quot;,
 216             tag, CHECK);
 217         }
 218         if (tag == JVM_CONSTANT_MethodHandle) {
 219           cfs-&gt;guarantee_more(4, CHECK);  // ref_kind, method_index, tag/access_flags
 220           const u1 ref_kind = cfs-&gt;get_u1_fast();
 221           const u2 method_index = cfs-&gt;get_u2_fast();
 222           cp-&gt;method_handle_index_at_put(index, ref_kind, method_index);
 223         }
 224         else if (tag == JVM_CONSTANT_MethodType) {
 225           cfs-&gt;guarantee_more(3, CHECK);  // signature_index, tag/access_flags
 226           const u2 signature_index = cfs-&gt;get_u2_fast();
 227           cp-&gt;method_type_index_at_put(index, signature_index);
 228         }
 229         else {
 230           ShouldNotReachHere();
 231         }
 232         break;
 233       }
 234       case JVM_CONSTANT_Dynamic : {
 235         if (_major_version &lt; Verifier::DYNAMICCONSTANT_MAJOR_VERSION) {
 236           classfile_parse_error(
 237               &quot;Class file version does not support constant tag %u in class file %s&quot;,
 238               tag, CHECK);
 239         }
 240         cfs-&gt;guarantee_more(5, CHECK);  // bsm_index, nt, tag/access_flags
 241         const u2 bootstrap_specifier_index = cfs-&gt;get_u2_fast();
 242         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 243         if (_max_bootstrap_specifier_index &lt; (int) bootstrap_specifier_index) {
 244           _max_bootstrap_specifier_index = (int) bootstrap_specifier_index;  // collect for later
 245         }
 246         cp-&gt;dynamic_constant_at_put(index, bootstrap_specifier_index, name_and_type_index);
 247         break;
 248       }
 249       case JVM_CONSTANT_InvokeDynamic : {
 250         if (_major_version &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
 251           classfile_parse_error(
 252               &quot;Class file version does not support constant tag %u in class file %s&quot;,
 253               tag, CHECK);
 254         }
 255         cfs-&gt;guarantee_more(5, CHECK);  // bsm_index, nt, tag/access_flags
 256         const u2 bootstrap_specifier_index = cfs-&gt;get_u2_fast();
 257         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 258         if (_max_bootstrap_specifier_index &lt; (int) bootstrap_specifier_index) {
 259           _max_bootstrap_specifier_index = (int) bootstrap_specifier_index;  // collect for later
 260         }
 261         cp-&gt;invoke_dynamic_at_put(index, bootstrap_specifier_index, name_and_type_index);
 262         break;
 263       }
 264       case JVM_CONSTANT_Integer: {
 265         cfs-&gt;guarantee_more(5, CHECK);  // bytes, tag/access_flags
 266         const u4 bytes = cfs-&gt;get_u4_fast();
 267         cp-&gt;int_at_put(index, (jint)bytes);
 268         break;
 269       }
 270       case JVM_CONSTANT_Float: {
 271         cfs-&gt;guarantee_more(5, CHECK);  // bytes, tag/access_flags
 272         const u4 bytes = cfs-&gt;get_u4_fast();
 273         cp-&gt;float_at_put(index, *(jfloat*)&amp;bytes);
 274         break;
 275       }
 276       case JVM_CONSTANT_Long: {
 277         // A mangled type might cause you to overrun allocated memory
 278         guarantee_property(index + 1 &lt; length,
 279                            &quot;Invalid constant pool entry %u in class file %s&quot;,
 280                            index,
 281                            CHECK);
 282         cfs-&gt;guarantee_more(9, CHECK);  // bytes, tag/access_flags
 283         const u8 bytes = cfs-&gt;get_u8_fast();
 284         cp-&gt;long_at_put(index, bytes);
 285         index++;   // Skip entry following eigth-byte constant, see JVM book p. 98
 286         break;
 287       }
 288       case JVM_CONSTANT_Double: {
 289         // A mangled type might cause you to overrun allocated memory
 290         guarantee_property(index+1 &lt; length,
 291                            &quot;Invalid constant pool entry %u in class file %s&quot;,
 292                            index,
 293                            CHECK);
 294         cfs-&gt;guarantee_more(9, CHECK);  // bytes, tag/access_flags
 295         const u8 bytes = cfs-&gt;get_u8_fast();
 296         cp-&gt;double_at_put(index, *(jdouble*)&amp;bytes);
 297         index++;   // Skip entry following eigth-byte constant, see JVM book p. 98
 298         break;
 299       }
 300       case JVM_CONSTANT_NameAndType: {
 301         cfs-&gt;guarantee_more(5, CHECK);  // name_index, signature_index, tag/access_flags
 302         const u2 name_index = cfs-&gt;get_u2_fast();
 303         const u2 signature_index = cfs-&gt;get_u2_fast();
 304         cp-&gt;name_and_type_at_put(index, name_index, signature_index);
 305         break;
 306       }
 307       case JVM_CONSTANT_Utf8 : {
 308         cfs-&gt;guarantee_more(2, CHECK);  // utf8_length
 309         u2  utf8_length = cfs-&gt;get_u2_fast();
 310         const u1* utf8_buffer = cfs-&gt;current();
 311         assert(utf8_buffer != NULL, &quot;null utf8 buffer&quot;);
 312         // Got utf8 string, guarantee utf8_length+1 bytes, set stream position forward.
 313         cfs-&gt;guarantee_more(utf8_length+1, CHECK);  // utf8 string, tag/access_flags
 314         cfs-&gt;skip_u1_fast(utf8_length);
 315 
 316         // Before storing the symbol, make sure it&#39;s legal
 317         if (_need_verify) {
 318           verify_legal_utf8(utf8_buffer, utf8_length, CHECK);
 319         }
 320 
 321         if (has_cp_patch_at(index)) {
 322           Handle patch = clear_cp_patch_at(index);
 323           guarantee_property(java_lang_String::is_instance(patch()),
 324                              &quot;Illegal utf8 patch at %d in class file %s&quot;,
 325                              index,
 326                              CHECK);
 327           const char* const str = java_lang_String::as_utf8_string(patch());
 328           // (could use java_lang_String::as_symbol instead, but might as well batch them)
 329           utf8_buffer = (const u1*) str;
 330           utf8_length = (u2) strlen(str);
 331         }
 332 
 333         unsigned int hash;
 334         Symbol* const result = SymbolTable::lookup_only((const char*)utf8_buffer,
 335                                                         utf8_length,
 336                                                         hash);
 337         if (result == NULL) {
 338           names[names_count] = (const char*)utf8_buffer;
 339           lengths[names_count] = utf8_length;
 340           indices[names_count] = index;
 341           hashValues[names_count++] = hash;
 342           if (names_count == SymbolTable::symbol_alloc_batch_size) {
 343             SymbolTable::new_symbols(_loader_data,
 344                                      constantPoolHandle(THREAD, cp),
 345                                      names_count,
 346                                      names,
 347                                      lengths,
 348                                      indices,
 349                                      hashValues);
 350             names_count = 0;
 351           }
 352         } else {
 353           cp-&gt;symbol_at_put(index, result);
 354         }
 355         break;
 356       }
 357       case JVM_CONSTANT_Module:
 358       case JVM_CONSTANT_Package: {
 359         // Record that an error occurred in these two cases but keep parsing so
 360         // that ACC_Module can be checked for in the access_flags.  Need to
 361         // throw NoClassDefFoundError in that case.
 362         if (_major_version &gt;= JAVA_9_VERSION) {
 363           cfs-&gt;guarantee_more(3, CHECK);
 364           cfs-&gt;get_u2_fast();
 365           set_class_bad_constant_seen(tag);
 366           break;
 367         }
 368       }
 369       default: {
 370         classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;,
 371                               tag,
 372                               CHECK);
 373         break;
 374       }
 375     } // end of switch(tag)
 376   } // end of for
 377 
 378   // Allocate the remaining symbols
 379   if (names_count &gt; 0) {
 380     SymbolTable::new_symbols(_loader_data,
 381                              constantPoolHandle(THREAD, cp),
 382                              names_count,
 383                              names,
 384                              lengths,
 385                              indices,
 386                              hashValues);
 387   }
 388 
 389   // Copy _current pointer of local copy back to stream.
 390   assert(stream-&gt;current() == old_current, &quot;non-exclusive use of stream&quot;);
 391   stream-&gt;set_current(cfs1.current());
 392 
 393 }
 394 
 395 static inline bool valid_cp_range(int index, int length) {
 396   return (index &gt; 0 &amp;&amp; index &lt; length);
 397 }
 398 
 399 static inline Symbol* check_symbol_at(const ConstantPool* cp, int index) {
 400   assert(cp != NULL, &quot;invariant&quot;);
 401   if (valid_cp_range(index, cp-&gt;length()) &amp;&amp; cp-&gt;tag_at(index).is_utf8()) {
 402     return cp-&gt;symbol_at(index);
 403   }
 404   return NULL;
 405 }
 406 
 407 #ifdef ASSERT
 408 PRAGMA_DIAG_PUSH
 409 PRAGMA_FORMAT_NONLITERAL_IGNORED
 410 void ClassFileParser::report_assert_property_failure(const char* msg, TRAPS) const {
 411   ResourceMark rm(THREAD);
 412   fatal(msg, _class_name-&gt;as_C_string());
 413 }
 414 
 415 void ClassFileParser::report_assert_property_failure(const char* msg,
 416                                                      int index,
 417                                                      TRAPS) const {
 418   ResourceMark rm(THREAD);
 419   fatal(msg, index, _class_name-&gt;as_C_string());
 420 }
 421 PRAGMA_DIAG_POP
 422 #endif
 423 
 424 void ClassFileParser::parse_constant_pool(const ClassFileStream* const stream,
 425                                          ConstantPool* const cp,
 426                                          const int length,
 427                                          TRAPS) {
 428   assert(cp != NULL, &quot;invariant&quot;);
 429   assert(stream != NULL, &quot;invariant&quot;);
 430 
 431   // parsing constant pool entries
 432   parse_constant_pool_entries(stream, cp, length, CHECK);
 433   if (class_bad_constant_seen() != 0) {
 434     // a bad CP entry has been detected previously so stop parsing and just return.
 435     return;
 436   }
 437 
 438   int index = 1;  // declared outside of loops for portability
 439   int num_klasses = 0;
 440 
 441   // first verification pass - validate cross references
 442   // and fixup class and string constants
 443   for (index = 1; index &lt; length; index++) {          // Index 0 is unused
 444     const jbyte tag = cp-&gt;tag_at(index).value();
 445     switch (tag) {
 446       case JVM_CONSTANT_Class: {
 447         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 448         break;
 449       }
 450       case JVM_CONSTANT_Fieldref:
 451         // fall through
 452       case JVM_CONSTANT_Methodref:
 453         // fall through
 454       case JVM_CONSTANT_InterfaceMethodref: {
 455         if (!_need_verify) break;
 456         const int klass_ref_index = cp-&gt;klass_ref_index_at(index);
 457         const int name_and_type_ref_index = cp-&gt;name_and_type_ref_index_at(index);
 458         check_property(valid_klass_reference_at(klass_ref_index),
 459                        &quot;Invalid constant pool index %u in class file %s&quot;,
 460                        klass_ref_index, CHECK);
 461         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 462           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 463           &quot;Invalid constant pool index %u in class file %s&quot;,
 464           name_and_type_ref_index, CHECK);
 465         break;
 466       }
 467       case JVM_CONSTANT_String: {
 468         ShouldNotReachHere();     // Only JVM_CONSTANT_StringIndex should be present
 469         break;
 470       }
 471       case JVM_CONSTANT_Integer:
 472         break;
 473       case JVM_CONSTANT_Float:
 474         break;
 475       case JVM_CONSTANT_Long:
 476       case JVM_CONSTANT_Double: {
 477         index++;
 478         check_property(
 479           (index &lt; length &amp;&amp; cp-&gt;tag_at(index).is_invalid()),
 480           &quot;Improper constant pool long/double index %u in class file %s&quot;,
 481           index, CHECK);
 482         break;
 483       }
 484       case JVM_CONSTANT_NameAndType: {
 485         if (!_need_verify) break;
 486         const int name_ref_index = cp-&gt;name_ref_index_at(index);
 487         const int signature_ref_index = cp-&gt;signature_ref_index_at(index);
 488         check_property(valid_symbol_at(name_ref_index),
 489           &quot;Invalid constant pool index %u in class file %s&quot;,
 490           name_ref_index, CHECK);
 491         check_property(valid_symbol_at(signature_ref_index),
 492           &quot;Invalid constant pool index %u in class file %s&quot;,
 493           signature_ref_index, CHECK);
 494         break;
 495       }
 496       case JVM_CONSTANT_Utf8:
 497         break;
 498       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 499       case JVM_CONSTANT_UnresolvedClassInError: {
 500         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 501         break;
 502       }
 503       case JVM_CONSTANT_ClassIndex: {
 504         const int class_index = cp-&gt;klass_index_at(index);
 505         check_property(valid_symbol_at(class_index),
 506           &quot;Invalid constant pool index %u in class file %s&quot;,
 507           class_index, CHECK);
 508 
 509         Symbol* const name = cp-&gt;symbol_at(class_index);
 510         const unsigned int name_len = name-&gt;utf8_length();
 511         if (name-&gt;is_Q_signature()) {
 512           cp-&gt;unresolved_qdescriptor_at_put(index, class_index, num_klasses++);
 513         } else {
 514           cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);
 515         }
 516         break;
 517       }
 518       case JVM_CONSTANT_StringIndex: {
 519         const int string_index = cp-&gt;string_index_at(index);
 520         check_property(valid_symbol_at(string_index),
 521           &quot;Invalid constant pool index %u in class file %s&quot;,
 522           string_index, CHECK);
 523         Symbol* const sym = cp-&gt;symbol_at(string_index);
 524         cp-&gt;unresolved_string_at_put(index, sym);
 525         break;
 526       }
 527       case JVM_CONSTANT_MethodHandle: {
 528         const int ref_index = cp-&gt;method_handle_index_at(index);
 529         check_property(valid_cp_range(ref_index, length),
 530           &quot;Invalid constant pool index %u in class file %s&quot;,
 531           ref_index, CHECK);
 532         const constantTag tag = cp-&gt;tag_at(ref_index);
 533         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 534 
 535         switch (ref_kind) {
 536           case JVM_REF_getField:
 537           case JVM_REF_getStatic:
 538           case JVM_REF_putField:
 539           case JVM_REF_putStatic: {
 540             check_property(
 541               tag.is_field(),
 542               &quot;Invalid constant pool index %u in class file %s (not a field)&quot;,
 543               ref_index, CHECK);
 544             break;
 545           }
 546           case JVM_REF_invokeVirtual:
 547           case JVM_REF_newInvokeSpecial: {
 548             check_property(
 549               tag.is_method(),
 550               &quot;Invalid constant pool index %u in class file %s (not a method)&quot;,
 551               ref_index, CHECK);
 552             break;
 553           }
 554           case JVM_REF_invokeStatic:
 555           case JVM_REF_invokeSpecial: {
 556             check_property(
 557               tag.is_method() ||
 558               ((_major_version &gt;= JAVA_8_VERSION) &amp;&amp; tag.is_interface_method()),
 559               &quot;Invalid constant pool index %u in class file %s (not a method)&quot;,
 560               ref_index, CHECK);
 561             break;
 562           }
 563           case JVM_REF_invokeInterface: {
 564             check_property(
 565               tag.is_interface_method(),
 566               &quot;Invalid constant pool index %u in class file %s (not an interface method)&quot;,
 567               ref_index, CHECK);
 568             break;
 569           }
 570           default: {
 571             classfile_parse_error(
 572               &quot;Bad method handle kind at constant pool index %u in class file %s&quot;,
 573               index, CHECK);
 574           }
 575         } // switch(refkind)
 576         // Keep the ref_index unchanged.  It will be indirected at link-time.
 577         break;
 578       } // case MethodHandle
 579       case JVM_CONSTANT_MethodType: {
 580         const int ref_index = cp-&gt;method_type_index_at(index);
 581         check_property(valid_symbol_at(ref_index),
 582           &quot;Invalid constant pool index %u in class file %s&quot;,
 583           ref_index, CHECK);
 584         break;
 585       }
 586       case JVM_CONSTANT_Dynamic: {
 587         const int name_and_type_ref_index =
 588           cp-&gt;bootstrap_name_and_type_ref_index_at(index);
 589 
 590         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 591           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 592           &quot;Invalid constant pool index %u in class file %s&quot;,
 593           name_and_type_ref_index, CHECK);
 594         // bootstrap specifier index must be checked later,
 595         // when BootstrapMethods attr is available
 596 
 597         // Mark the constant pool as having a CONSTANT_Dynamic_info structure
 598         cp-&gt;set_has_dynamic_constant();
 599         break;
 600       }
 601       case JVM_CONSTANT_InvokeDynamic: {
 602         const int name_and_type_ref_index =
 603           cp-&gt;bootstrap_name_and_type_ref_index_at(index);
 604 
 605         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 606           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 607           &quot;Invalid constant pool index %u in class file %s&quot;,
 608           name_and_type_ref_index, CHECK);
 609         // bootstrap specifier index must be checked later,
 610         // when BootstrapMethods attr is available
 611         break;
 612       }
 613       default: {
 614         fatal(&quot;bad constant pool tag value %u&quot;, cp-&gt;tag_at(index).value());
 615         ShouldNotReachHere();
 616         break;
 617       }
 618     } // switch(tag)
 619   } // end of for
 620 
 621   _first_patched_klass_resolved_index = num_klasses;
 622   cp-&gt;allocate_resolved_klasses(_loader_data, num_klasses + _max_num_patched_klasses, CHECK);
 623 
 624   if (_cp_patches != NULL) {
 625     // need to treat this_class specially...
 626 
 627     // Add dummy utf8 entries in the space reserved for names of patched classes. We&#39;ll use &quot;*&quot;
 628     // for now. These will be replaced with actual names of the patched classes in patch_class().
 629     Symbol* s = vmSymbols::star_name();
 630     for (int n=_orig_cp_size; n&lt;cp-&gt;length(); n++) {
 631       cp-&gt;symbol_at_put(n, s);
 632     }
 633 
 634     int this_class_index;
 635     {
 636       stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
 637       const u1* const mark = stream-&gt;current();
 638       stream-&gt;skip_u2_fast(1); // skip flags
 639       this_class_index = stream-&gt;get_u2_fast();
 640       stream-&gt;set_current(mark);  // revert to mark
 641     }
 642 
 643     for (index = 1; index &lt; length; index++) {          // Index 0 is unused
 644       if (has_cp_patch_at(index)) {
 645         guarantee_property(index != this_class_index,
 646           &quot;Illegal constant pool patch to self at %d in class file %s&quot;,
 647           index, CHECK);
 648         patch_constant_pool(cp, index, cp_patch_at(index), CHECK);
 649       }
 650     }
 651   }
 652 
 653   if (!_need_verify) {
 654     return;
 655   }
 656 
 657   // second verification pass - checks the strings are of the right format.
 658   // but not yet to the other entries
 659   for (index = 1; index &lt; length; index++) {
 660     const jbyte tag = cp-&gt;tag_at(index).value();
 661     switch (tag) {
 662       case JVM_CONSTANT_UnresolvedClass: {
 663         const Symbol* const class_name = cp-&gt;klass_name_at(index);
 664         // check the name, even if _cp_patches will overwrite it
 665         verify_legal_class_name(class_name, CHECK);
 666         break;
 667       }
 668       case JVM_CONSTANT_NameAndType: {
 669         if (_need_verify) {
 670           const int sig_index = cp-&gt;signature_ref_index_at(index);
 671           const int name_index = cp-&gt;name_ref_index_at(index);
 672           const Symbol* const name = cp-&gt;symbol_at(name_index);
 673           const Symbol* const sig = cp-&gt;symbol_at(sig_index);
 674           guarantee_property(sig-&gt;utf8_length() != 0,
 675             &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
 676             sig_index, CHECK);
 677           guarantee_property(name-&gt;utf8_length() != 0,
 678             &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
 679             name_index, CHECK);
 680 
 681           if (Signature::is_method(sig)) {
 682             // Format check method name and signature
 683             verify_legal_method_name(name, CHECK);
 684             verify_legal_method_signature(name, sig, CHECK);
 685           } else {
 686             // Format check field name and signature
 687             verify_legal_field_name(name, CHECK);
 688             verify_legal_field_signature(name, sig, CHECK);
 689           }
 690         }
 691         break;
 692       }
 693       case JVM_CONSTANT_Dynamic: {
 694         const int name_and_type_ref_index =
 695           cp-&gt;name_and_type_ref_index_at(index);
 696         // already verified to be utf8
 697         const int name_ref_index =
 698           cp-&gt;name_ref_index_at(name_and_type_ref_index);
 699         // already verified to be utf8
 700         const int signature_ref_index =
 701           cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 702         const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 703         const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 704         if (_need_verify) {
 705           // CONSTANT_Dynamic&#39;s name and signature are verified above, when iterating NameAndType_info.
 706           // Need only to be sure signature is the right type.
 707           if (Signature::is_method(signature)) {
 708             throwIllegalSignature(&quot;CONSTANT_Dynamic&quot;, name, signature, CHECK);
 709           }
 710         }
 711         break;
 712       }
 713       case JVM_CONSTANT_InvokeDynamic:
 714       case JVM_CONSTANT_Fieldref:
 715       case JVM_CONSTANT_Methodref:
 716       case JVM_CONSTANT_InterfaceMethodref: {
 717         const int name_and_type_ref_index =
 718           cp-&gt;name_and_type_ref_index_at(index);
 719         // already verified to be utf8
 720         const int name_ref_index =
 721           cp-&gt;name_ref_index_at(name_and_type_ref_index);
 722         // already verified to be utf8
 723         const int signature_ref_index =
 724           cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 725         const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 726         const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 727         if (tag == JVM_CONSTANT_Fieldref) {
 728           if (_need_verify) {
 729             // Field name and signature are verified above, when iterating NameAndType_info.
 730             // Need only to be sure signature is non-zero length and the right type.
 731             if (Signature::is_method(signature)) {
 732               throwIllegalSignature(&quot;Field&quot;, name, signature, CHECK);
 733             }
 734           }
 735         } else {
 736           if (_need_verify) {
 737             // Method name and signature are verified above, when iterating NameAndType_info.
 738             // Need only to be sure signature is non-zero length and the right type.
 739             if (!Signature::is_method(signature)) {
 740               throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK);
 741             }
 742           }
 743           // 4509014: If a class method name begins with &#39;&lt;&#39;, it must be &quot;&lt;init&gt;&quot;
 744           const unsigned int name_len = name-&gt;utf8_length();
 745           if (tag == JVM_CONSTANT_Methodref &amp;&amp;
 746               name_len != 0 &amp;&amp;
 747               name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL &amp;&amp;
 748               name != vmSymbols::object_initializer_name()) {
 749             classfile_parse_error(
 750               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 751               name_ref_index, CHECK);
 752           }
 753         }
 754         break;
 755       }
 756       case JVM_CONSTANT_MethodHandle: {
 757         const int ref_index = cp-&gt;method_handle_index_at(index);
 758         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 759         switch (ref_kind) {
 760           case JVM_REF_invokeVirtual:
 761           case JVM_REF_invokeStatic:
 762           case JVM_REF_invokeSpecial:
 763           case JVM_REF_newInvokeSpecial: {
 764             const int name_and_type_ref_index =
 765               cp-&gt;name_and_type_ref_index_at(ref_index);
 766             const int name_ref_index =
 767               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 768             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 769             if (name != vmSymbols::object_initializer_name()) {
 770               if (ref_kind == JVM_REF_newInvokeSpecial) {
 771                 classfile_parse_error(
 772                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 773                     name_ref_index, CHECK);
 774               }
 775             } else {
 776               // The allowed invocation mode of &lt;init&gt; depends on its signature.
 777               // This test corresponds to verify_invoke_instructions in the verifier.
 778               const int signature_ref_index =
 779                 cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 780               const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 781               if (signature-&gt;is_void_method_signature()
 782                   &amp;&amp; ref_kind == JVM_REF_newInvokeSpecial) {
 783                 // OK, could be a constructor call
 784               } else if (!signature-&gt;is_void_method_signature()
 785                          &amp;&amp; ref_kind == JVM_REF_invokeStatic) {
 786                 // also OK, could be a static factory call
 787               } else {
 788                 classfile_parse_error(
 789                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 790                   name_ref_index, CHECK);
 791               }
 792             }
 793             break;
 794           }
 795           // Other ref_kinds are already fully checked in previous pass.
 796         } // switch(ref_kind)
 797         break;
 798       }
 799       case JVM_CONSTANT_MethodType: {
 800         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 801         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 802         verify_legal_method_signature(no_name, signature, CHECK);
 803         break;
 804       }
 805       case JVM_CONSTANT_Utf8: {
 806         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 807       }
 808     }  // switch(tag)
 809   }  // end of for
 810 }
 811 
 812 Handle ClassFileParser::clear_cp_patch_at(int index) {
 813   Handle patch = cp_patch_at(index);
 814   _cp_patches-&gt;at_put(index, Handle());
 815   assert(!has_cp_patch_at(index), &quot;&quot;);
 816   return patch;
 817 }
 818 
 819 void ClassFileParser::patch_class(ConstantPool* cp, int class_index, Klass* k, Symbol* name) {
 820   int name_index = _orig_cp_size + _num_patched_klasses;
 821   int resolved_klass_index = _first_patched_klass_resolved_index + _num_patched_klasses;
 822 
 823   cp-&gt;klass_at_put(class_index, name_index, resolved_klass_index, k, name);
 824   _num_patched_klasses ++;
 825 }
 826 
 827 void ClassFileParser::patch_constant_pool(ConstantPool* cp,
 828                                           int index,
 829                                           Handle patch,
 830                                           TRAPS) {
 831   assert(cp != NULL, &quot;invariant&quot;);
 832 
 833   BasicType patch_type = T_VOID;
 834 
 835   switch (cp-&gt;tag_at(index).value()) {
 836 
 837     case JVM_CONSTANT_UnresolvedClass: {
 838       // Patching a class means pre-resolving it.
 839       // The name in the constant pool is ignored.
 840       if (java_lang_Class::is_instance(patch())) {
 841         guarantee_property(!java_lang_Class::is_primitive(patch()),
 842                            &quot;Illegal class patch at %d in class file %s&quot;,
 843                            index, CHECK);
 844         Klass* k = java_lang_Class::as_Klass(patch());
 845         patch_class(cp, index, k, k-&gt;name());
 846       } else {
 847         guarantee_property(java_lang_String::is_instance(patch()),
 848                            &quot;Illegal class patch at %d in class file %s&quot;,
 849                            index, CHECK);
 850         Symbol* const name = java_lang_String::as_symbol(patch());
 851         patch_class(cp, index, NULL, name);
 852       }
 853       break;
 854     }
 855 
 856     case JVM_CONSTANT_String: {
 857       // skip this patch and don&#39;t clear it.  Needs the oop array for resolved
 858       // references to be created first.
 859       return;
 860     }
 861     case JVM_CONSTANT_Integer: patch_type = T_INT;    goto patch_prim;
 862     case JVM_CONSTANT_Float:   patch_type = T_FLOAT;  goto patch_prim;
 863     case JVM_CONSTANT_Long:    patch_type = T_LONG;   goto patch_prim;
 864     case JVM_CONSTANT_Double:  patch_type = T_DOUBLE; goto patch_prim;
 865     patch_prim:
 866     {
 867       jvalue value;
 868       BasicType value_type = java_lang_boxing_object::get_value(patch(), &amp;value);
 869       guarantee_property(value_type == patch_type,
 870                          &quot;Illegal primitive patch at %d in class file %s&quot;,
 871                          index, CHECK);
 872       switch (value_type) {
 873         case T_INT:    cp-&gt;int_at_put(index,   value.i); break;
 874         case T_FLOAT:  cp-&gt;float_at_put(index, value.f); break;
 875         case T_LONG:   cp-&gt;long_at_put(index,  value.j); break;
 876         case T_DOUBLE: cp-&gt;double_at_put(index, value.d); break;
 877         default:       assert(false, &quot;&quot;);
 878       }
 879     } // end patch_prim label
 880     break;
 881 
 882     default: {
 883       // %%% TODO: put method handles into CONSTANT_InterfaceMethodref, etc.
 884       guarantee_property(!has_cp_patch_at(index),
 885                          &quot;Illegal unexpected patch at %d in class file %s&quot;,
 886                          index, CHECK);
 887       return;
 888     }
 889   } // end of switch(tag)
 890 
 891   // On fall-through, mark the patch as used.
 892   clear_cp_patch_at(index);
 893 }
 894 class NameSigHash: public ResourceObj {
 895  public:
 896   const Symbol*       _name;       // name
 897   const Symbol*       _sig;        // signature
 898   NameSigHash*  _next;             // Next entry in hash table
 899 };
 900 
 901 static const int HASH_ROW_SIZE = 256;
 902 
 903 static unsigned int hash(const Symbol* name, const Symbol* sig) {
 904   unsigned int raw_hash = 0;
 905   raw_hash += ((unsigned int)(uintptr_t)name) &gt;&gt; (LogHeapWordSize + 2);
 906   raw_hash += ((unsigned int)(uintptr_t)sig) &gt;&gt; LogHeapWordSize;
 907 
 908   return (raw_hash + (unsigned int)(uintptr_t)name) % HASH_ROW_SIZE;
 909 }
 910 
 911 
 912 static void initialize_hashtable(NameSigHash** table) {
 913   memset((void*)table, 0, sizeof(NameSigHash*) * HASH_ROW_SIZE);
 914 }
 915 // Return false if the name/sig combination is found in table.
 916 // Return true if no duplicate is found. And name/sig is added as a new entry in table.
 917 // The old format checker uses heap sort to find duplicates.
 918 // NOTE: caller should guarantee that GC doesn&#39;t happen during the life cycle
 919 // of table since we don&#39;t expect Symbol*&#39;s to move.
 920 static bool put_after_lookup(const Symbol* name, const Symbol* sig, NameSigHash** table) {
 921   assert(name != NULL, &quot;name in constant pool is NULL&quot;);
 922 
 923   // First lookup for duplicates
 924   int index = hash(name, sig);
 925   NameSigHash* entry = table[index];
 926   while (entry != NULL) {
 927     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 928       return false;
 929     }
 930     entry = entry-&gt;_next;
 931   }
 932 
 933   // No duplicate is found, allocate a new entry and fill it.
 934   entry = new NameSigHash();
 935   entry-&gt;_name = name;
 936   entry-&gt;_sig = sig;
 937 
 938   // Insert into hash table
 939   entry-&gt;_next = table[index];
 940   table[index] = entry;
 941 
 942   return true;
 943 }
 944 
 945 // Side-effects: populates the _local_interfaces field
<a name="2" id="anc2"></a><span class="line-modified"> 946 void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,</span>
<span class="line-modified"> 947                                        const int itfs_len,</span>
<span class="line-modified"> 948                                        ConstantPool* const cp,</span>
 949                                        bool* const has_nonstatic_concrete_methods,
<a name="3" id="anc3"></a>






 950                                        TRAPS) {
 951   assert(stream != NULL, &quot;invariant&quot;);
 952   assert(cp != NULL, &quot;invariant&quot;);
 953   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 954 
 955   if (itfs_len == 0) {
 956     _local_interfaces = Universe::the_empty_instance_klass_array();
 957   } else {
 958     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
 959     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);
 960 
 961     int index;
 962     for (index = 0; index &lt; itfs_len; index++) {
 963       const u2 interface_index = stream-&gt;get_u2(CHECK);
 964       Klass* interf;
 965       check_property(
 966         valid_klass_reference_at(interface_index),
 967         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 968         interface_index, CHECK);
 969       if (cp-&gt;tag_at(interface_index).is_klass()) {
 970         interf = cp-&gt;resolved_klass_at(interface_index);
 971       } else {
 972         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 973 
 974         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 975         // But need to make sure it&#39;s not an array type.
 976         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 977                            &quot;Bad interface name in class file %s&quot;, CHECK);
 978 
 979         // Call resolve_super so classcircularity is checked
 980         interf = SystemDictionary::resolve_super_or_fail(
 981                                                   _class_name,
 982                                                   unresolved_klass,
 983                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 984                                                   _protection_domain,
 985                                                   false,
 986                                                   CHECK);
 987       }
 988 
 989       if (!interf-&gt;is_interface()) {
 990         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 991                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
 992                           _class_name-&gt;as_klass_external_name(),
 993                           interf-&gt;external_name(),
 994                           interf-&gt;class_in_module_of_loader()));
 995       }
 996 
<a name="4" id="anc4"></a><span class="line-modified"> 997       if (InstanceKlass::cast(interf)-&gt;has_nonstatic_concrete_methods()) {</span>

 998         *has_nonstatic_concrete_methods = true;
 999       }
<a name="5" id="anc5"></a><span class="line-modified">1000       _local_interfaces-&gt;at_put(index, InstanceKlass::cast(interf));</span>



1001     }
1002 
1003     if (!_need_verify || itfs_len &lt;= 1) {
1004       return;
1005     }
1006 
1007     // Check if there&#39;s any duplicates in interfaces
1008     ResourceMark rm(THREAD);
1009     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1010                                                                  NameSigHash*,
1011                                                                  HASH_ROW_SIZE);
1012     initialize_hashtable(interface_names);
1013     bool dup = false;
1014     const Symbol* name = NULL;
1015     {
1016       debug_only(NoSafepointVerifier nsv;)
1017       for (index = 0; index &lt; itfs_len; index++) {
1018         const InstanceKlass* const k = _local_interfaces-&gt;at(index);
1019         name = k-&gt;name();
1020         // If no duplicates, add (name, NULL) in hashtable interface_names.
1021         if (!put_after_lookup(name, NULL, interface_names)) {
1022           dup = true;
1023           break;
1024         }
1025       }
1026     }
1027     if (dup) {
1028       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1029                              name-&gt;as_C_string(), CHECK);
1030     }
1031   }
1032 }
1033 
1034 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1035                                            int constantvalue_index,
1036                                            int signature_index,
1037                                            TRAPS) const {
1038   // Make sure the constant pool entry is of a type appropriate to this field
1039   guarantee_property(
1040     (constantvalue_index &gt; 0 &amp;&amp;
1041       constantvalue_index &lt; cp-&gt;length()),
1042     &quot;Bad initial value index %u in ConstantValue attribute in class file %s&quot;,
1043     constantvalue_index, CHECK);
1044 
1045   const constantTag value_type = cp-&gt;tag_at(constantvalue_index);
1046   switch(cp-&gt;basic_type_for_signature_at(signature_index)) {
1047     case T_LONG: {
1048       guarantee_property(value_type.is_long(),
1049                          &quot;Inconsistent constant value type in class file %s&quot;,
1050                          CHECK);
1051       break;
1052     }
1053     case T_FLOAT: {
1054       guarantee_property(value_type.is_float(),
1055                          &quot;Inconsistent constant value type in class file %s&quot;,
1056                          CHECK);
1057       break;
1058     }
1059     case T_DOUBLE: {
1060       guarantee_property(value_type.is_double(),
1061                          &quot;Inconsistent constant value type in class file %s&quot;,
1062                          CHECK);
1063       break;
1064     }
1065     case T_BYTE:
1066     case T_CHAR:
1067     case T_SHORT:
1068     case T_BOOLEAN:
1069     case T_INT: {
1070       guarantee_property(value_type.is_int(),
1071                          &quot;Inconsistent constant value type in class file %s&quot;,
1072                          CHECK);
1073       break;
1074     }
1075     case T_OBJECT: {
1076       guarantee_property((cp-&gt;symbol_at(signature_index)-&gt;equals(&quot;Ljava/lang/String;&quot;)
1077                          &amp;&amp; value_type.is_string()),
1078                          &quot;Bad string initial value in class file %s&quot;,
1079                          CHECK);
1080       break;
1081     }
1082     default: {
1083       classfile_parse_error(&quot;Unable to set initial value %u in class file %s&quot;,
1084                              constantvalue_index,
1085                              CHECK);
1086     }
1087   }
1088 }
1089 
1090 class AnnotationCollector : public ResourceObj{
1091 public:
1092   enum Location { _in_field, _in_method, _in_class };
1093   enum ID {
1094     _unknown = 0,
1095     _method_CallerSensitive,
1096     _method_ForceInline,
1097     _method_DontInline,
1098     _method_InjectedProfile,
1099     _method_LambdaForm_Compiled,
1100     _method_Hidden,
1101     _method_HotSpotIntrinsicCandidate,
1102     _jdk_internal_vm_annotation_Contended,
1103     _field_Stable,
1104     _jdk_internal_vm_annotation_ReservedStackAccess,
1105     _annotation_LIMIT
1106   };
1107   const Location _location;
1108   int _annotations_present;
1109   u2 _contended_group;
1110 
1111   AnnotationCollector(Location location)
1112     : _location(location), _annotations_present(0)
1113   {
1114     assert((int)_annotation_LIMIT &lt;= (int)sizeof(_annotations_present) * BitsPerByte, &quot;&quot;);
1115   }
1116   // If this annotation name has an ID, report it (or _none).
1117   ID annotation_index(const ClassLoaderData* loader_data, const Symbol* name);
1118   // Set the annotation name:
1119   void set_annotation(ID id) {
1120     assert((int)id &gt;= 0 &amp;&amp; (int)id &lt; (int)_annotation_LIMIT, &quot;oob&quot;);
1121     _annotations_present |= nth_bit((int)id);
1122   }
1123 
1124   void remove_annotation(ID id) {
1125     assert((int)id &gt;= 0 &amp;&amp; (int)id &lt; (int)_annotation_LIMIT, &quot;oob&quot;);
1126     _annotations_present &amp;= ~nth_bit((int)id);
1127   }
1128 
1129   // Report if the annotation is present.
1130   bool has_any_annotations() const { return _annotations_present != 0; }
1131   bool has_annotation(ID id) const { return (nth_bit((int)id) &amp; _annotations_present) != 0; }
1132 
1133   void set_contended_group(u2 group) { _contended_group = group; }
1134   u2 contended_group() const { return _contended_group; }
1135 
1136   bool is_contended() const { return has_annotation(_jdk_internal_vm_annotation_Contended); }
1137 
1138   void set_stable(bool stable) { set_annotation(_field_Stable); }
1139   bool is_stable() const { return has_annotation(_field_Stable); }
1140 };
1141 
1142 // This class also doubles as a holder for metadata cleanup.
1143 class ClassFileParser::FieldAnnotationCollector : public AnnotationCollector {
1144 private:
1145   ClassLoaderData* _loader_data;
1146   AnnotationArray* _field_annotations;
1147   AnnotationArray* _field_type_annotations;
1148 public:
1149   FieldAnnotationCollector(ClassLoaderData* loader_data) :
1150     AnnotationCollector(_in_field),
1151     _loader_data(loader_data),
1152     _field_annotations(NULL),
1153     _field_type_annotations(NULL) {}
1154   ~FieldAnnotationCollector();
1155   void apply_to(FieldInfo* f);
1156   AnnotationArray* field_annotations()      { return _field_annotations; }
1157   AnnotationArray* field_type_annotations() { return _field_type_annotations; }
1158 
1159   void set_field_annotations(AnnotationArray* a)      { _field_annotations = a; }
1160   void set_field_type_annotations(AnnotationArray* a) { _field_type_annotations = a; }
1161 };
1162 
1163 class MethodAnnotationCollector : public AnnotationCollector{
1164 public:
1165   MethodAnnotationCollector() : AnnotationCollector(_in_method) { }
1166   void apply_to(const methodHandle&amp; m);
1167 };
1168 
1169 class ClassFileParser::ClassAnnotationCollector : public AnnotationCollector{
1170 public:
1171   ClassAnnotationCollector() : AnnotationCollector(_in_class) { }
1172   void apply_to(InstanceKlass* ik);
1173 };
1174 
1175 
1176 static int skip_annotation_value(const u1*, int, int); // fwd decl
1177 
1178 // Safely increment index by val if does not pass limit
1179 #define SAFE_ADD(index, limit, val) \
1180 if (index &gt;= limit - val) return limit; \
1181 index += val;
1182 
1183 // Skip an annotation.  Return &gt;=limit if there is any problem.
1184 static int skip_annotation(const u1* buffer, int limit, int index) {
1185   assert(buffer != NULL, &quot;invariant&quot;);
1186   // annotation := atype:u2 do(nmem:u2) {member:u2 value}
1187   // value := switch (tag:u1) { ... }
1188   SAFE_ADD(index, limit, 4); // skip atype and read nmem
1189   int nmem = Bytes::get_Java_u2((address)buffer + index - 2);
1190   while (--nmem &gt;= 0 &amp;&amp; index &lt; limit) {
1191     SAFE_ADD(index, limit, 2); // skip member
1192     index = skip_annotation_value(buffer, limit, index);
1193   }
1194   return index;
1195 }
1196 
1197 // Skip an annotation value.  Return &gt;=limit if there is any problem.
1198 static int skip_annotation_value(const u1* buffer, int limit, int index) {
1199   assert(buffer != NULL, &quot;invariant&quot;);
1200 
1201   // value := switch (tag:u1) {
1202   //   case B, C, I, S, Z, D, F, J, c: con:u2;
1203   //   case e: e_class:u2 e_name:u2;
1204   //   case s: s_con:u2;
1205   //   case [: do(nval:u2) {value};
1206   //   case @: annotation;
1207   //   case s: s_con:u2;
1208   // }
1209   SAFE_ADD(index, limit, 1); // read tag
1210   const u1 tag = buffer[index - 1];
1211   switch (tag) {
1212     case &#39;B&#39;:
1213     case &#39;C&#39;:
1214     case &#39;I&#39;:
1215     case &#39;S&#39;:
1216     case &#39;Z&#39;:
1217     case &#39;D&#39;:
1218     case &#39;F&#39;:
1219     case &#39;J&#39;:
1220     case &#39;c&#39;:
1221     case &#39;s&#39;:
1222       SAFE_ADD(index, limit, 2);  // skip con or s_con
1223       break;
1224     case &#39;e&#39;:
1225       SAFE_ADD(index, limit, 4);  // skip e_class, e_name
1226       break;
1227     case &#39;[&#39;:
1228     {
1229       SAFE_ADD(index, limit, 2); // read nval
1230       int nval = Bytes::get_Java_u2((address)buffer + index - 2);
1231       while (--nval &gt;= 0 &amp;&amp; index &lt; limit) {
1232         index = skip_annotation_value(buffer, limit, index);
1233       }
1234     }
1235     break;
1236     case &#39;@&#39;:
1237       index = skip_annotation(buffer, limit, index);
1238       break;
1239     default:
1240       return limit;  //  bad tag byte
1241   }
1242   return index;
1243 }
1244 
1245 // Sift through annotations, looking for those significant to the VM:
1246 static void parse_annotations(const ConstantPool* const cp,
1247                               const u1* buffer, int limit,
1248                               AnnotationCollector* coll,
1249                               ClassLoaderData* loader_data,
1250                               TRAPS) {
1251 
1252   assert(cp != NULL, &quot;invariant&quot;);
1253   assert(buffer != NULL, &quot;invariant&quot;);
1254   assert(coll != NULL, &quot;invariant&quot;);
1255   assert(loader_data != NULL, &quot;invariant&quot;);
1256 
1257   // annotations := do(nann:u2) {annotation}
1258   int index = 2; // read nann
1259   if (index &gt;= limit)  return;
1260   int nann = Bytes::get_Java_u2((address)buffer + index - 2);
1261   enum {  // initial annotation layout
1262     atype_off = 0,      // utf8 such as &#39;Ljava/lang/annotation/Retention;&#39;
1263     count_off = 2,      // u2   such as 1 (one value)
1264     member_off = 4,     // utf8 such as &#39;value&#39;
1265     tag_off = 6,        // u1   such as &#39;c&#39; (type) or &#39;e&#39; (enum)
1266     e_tag_val = &#39;e&#39;,
1267     e_type_off = 7,   // utf8 such as &#39;Ljava/lang/annotation/RetentionPolicy;&#39;
1268     e_con_off = 9,    // utf8 payload, such as &#39;SOURCE&#39;, &#39;CLASS&#39;, &#39;RUNTIME&#39;
1269     e_size = 11,     // end of &#39;e&#39; annotation
1270     c_tag_val = &#39;c&#39;,    // payload is type
1271     c_con_off = 7,    // utf8 payload, such as &#39;I&#39;
1272     c_size = 9,       // end of &#39;c&#39; annotation
1273     s_tag_val = &#39;s&#39;,    // payload is String
1274     s_con_off = 7,    // utf8 payload, such as &#39;Ljava/lang/String;&#39;
1275     s_size = 9,
1276     min_size = 6        // smallest possible size (zero members)
1277   };
1278   // Cannot add min_size to index in case of overflow MAX_INT
1279   while ((--nann) &gt;= 0 &amp;&amp; (index - 2 &lt;= limit - min_size)) {
1280     int index0 = index;
1281     index = skip_annotation(buffer, limit, index);
1282     const u1* const abase = buffer + index0;
1283     const int atype = Bytes::get_Java_u2((address)abase + atype_off);
1284     const int count = Bytes::get_Java_u2((address)abase + count_off);
1285     const Symbol* const aname = check_symbol_at(cp, atype);
1286     if (aname == NULL)  break;  // invalid annotation name
1287     const Symbol* member = NULL;
1288     if (count &gt;= 1) {
1289       const int member_index = Bytes::get_Java_u2((address)abase + member_off);
1290       member = check_symbol_at(cp, member_index);
1291       if (member == NULL)  break;  // invalid member name
1292     }
1293 
1294     // Here is where parsing particular annotations will take place.
1295     AnnotationCollector::ID id = coll-&gt;annotation_index(loader_data, aname);
1296     if (AnnotationCollector::_unknown == id)  continue;
1297     coll-&gt;set_annotation(id);
1298 
1299     if (AnnotationCollector::_jdk_internal_vm_annotation_Contended == id) {
1300       // @Contended can optionally specify the contention group.
1301       //
1302       // Contended group defines the equivalence class over the fields:
1303       // the fields within the same contended group are not treated distinct.
1304       // The only exception is default group, which does not incur the
1305       // equivalence. Naturally, contention group for classes is meaningless.
1306       //
1307       // While the contention group is specified as String, annotation
1308       // values are already interned, and we might as well use the constant
1309       // pool index as the group tag.
1310       //
1311       u2 group_index = 0; // default contended group
1312       if (count == 1
1313         &amp;&amp; s_size == (index - index0)  // match size
1314         &amp;&amp; s_tag_val == *(abase + tag_off)
1315         &amp;&amp; member == vmSymbols::value_name()) {
1316         group_index = Bytes::get_Java_u2((address)abase + s_con_off);
1317         if (cp-&gt;symbol_at(group_index)-&gt;utf8_length() == 0) {
1318           group_index = 0; // default contended group
1319         }
1320       }
1321       coll-&gt;set_contended_group(group_index);
1322     }
1323   }
1324 }
1325 
1326 
1327 // Parse attributes for a field.
1328 void ClassFileParser::parse_field_attributes(const ClassFileStream* const cfs,
1329                                              u2 attributes_count,
1330                                              bool is_static, u2 signature_index,
1331                                              u2* const constantvalue_index_addr,
1332                                              bool* const is_synthetic_addr,
1333                                              u2* const generic_signature_index_addr,
1334                                              ClassFileParser::FieldAnnotationCollector* parsed_annotations,
1335                                              TRAPS) {
1336   assert(cfs != NULL, &quot;invariant&quot;);
1337   assert(constantvalue_index_addr != NULL, &quot;invariant&quot;);
1338   assert(is_synthetic_addr != NULL, &quot;invariant&quot;);
1339   assert(generic_signature_index_addr != NULL, &quot;invariant&quot;);
1340   assert(parsed_annotations != NULL, &quot;invariant&quot;);
1341   assert(attributes_count &gt; 0, &quot;attributes_count should be greater than 0&quot;);
1342 
1343   u2 constantvalue_index = 0;
1344   u2 generic_signature_index = 0;
1345   bool is_synthetic = false;
1346   const u1* runtime_visible_annotations = NULL;
1347   int runtime_visible_annotations_length = 0;
1348   const u1* runtime_invisible_annotations = NULL;
1349   int runtime_invisible_annotations_length = 0;
1350   const u1* runtime_visible_type_annotations = NULL;
1351   int runtime_visible_type_annotations_length = 0;
1352   const u1* runtime_invisible_type_annotations = NULL;
1353   int runtime_invisible_type_annotations_length = 0;
1354   bool runtime_invisible_annotations_exists = false;
1355   bool runtime_invisible_type_annotations_exists = false;
1356   const ConstantPool* const cp = _cp;
1357 
1358   while (attributes_count--) {
1359     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
1360     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
1361     const u4 attribute_length = cfs-&gt;get_u4_fast();
1362     check_property(valid_symbol_at(attribute_name_index),
1363                    &quot;Invalid field attribute index %u in class file %s&quot;,
1364                    attribute_name_index,
1365                    CHECK);
1366 
1367     const Symbol* const attribute_name = cp-&gt;symbol_at(attribute_name_index);
1368     if (is_static &amp;&amp; attribute_name == vmSymbols::tag_constant_value()) {
1369       // ignore if non-static
1370       if (constantvalue_index != 0) {
1371         classfile_parse_error(&quot;Duplicate ConstantValue attribute in class file %s&quot;, CHECK);
1372       }
1373       check_property(
1374         attribute_length == 2,
1375         &quot;Invalid ConstantValue field attribute length %u in class file %s&quot;,
1376         attribute_length, CHECK);
1377 
1378       constantvalue_index = cfs-&gt;get_u2(CHECK);
1379       if (_need_verify) {
1380         verify_constantvalue(cp, constantvalue_index, signature_index, CHECK);
1381       }
1382     } else if (attribute_name == vmSymbols::tag_synthetic()) {
1383       if (attribute_length != 0) {
1384         classfile_parse_error(
1385           &quot;Invalid Synthetic field attribute length %u in class file %s&quot;,
1386           attribute_length, CHECK);
1387       }
1388       is_synthetic = true;
1389     } else if (attribute_name == vmSymbols::tag_deprecated()) { // 4276120
1390       if (attribute_length != 0) {
1391         classfile_parse_error(
1392           &quot;Invalid Deprecated field attribute length %u in class file %s&quot;,
1393           attribute_length, CHECK);
1394       }
1395     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
1396       if (attribute_name == vmSymbols::tag_signature()) {
1397         if (generic_signature_index != 0) {
1398           classfile_parse_error(
1399             &quot;Multiple Signature attributes for field in class file %s&quot;, CHECK);
1400         }
1401         if (attribute_length != 2) {
1402           classfile_parse_error(
1403             &quot;Wrong size %u for field&#39;s Signature attribute in class file %s&quot;,
1404             attribute_length, CHECK);
1405         }
1406         generic_signature_index = parse_generic_signature_attribute(cfs, CHECK);
1407       } else if (attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
1408         if (runtime_visible_annotations != NULL) {
1409           classfile_parse_error(
1410             &quot;Multiple RuntimeVisibleAnnotations attributes for field in class file %s&quot;, CHECK);
1411         }
1412         runtime_visible_annotations_length = attribute_length;
1413         runtime_visible_annotations = cfs-&gt;current();
1414         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
1415         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK);
1416         parse_annotations(cp,
1417                           runtime_visible_annotations,
1418                           runtime_visible_annotations_length,
1419                           parsed_annotations,
1420                           _loader_data,
1421                           CHECK);
1422         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
1423       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
1424         if (runtime_invisible_annotations_exists) {
1425           classfile_parse_error(
1426             &quot;Multiple RuntimeInvisibleAnnotations attributes for field in class file %s&quot;, CHECK);
1427         }
1428         runtime_invisible_annotations_exists = true;
1429         if (PreserveAllAnnotations) {
1430           runtime_invisible_annotations_length = attribute_length;
1431           runtime_invisible_annotations = cfs-&gt;current();
1432           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
1433         }
1434         cfs-&gt;skip_u1(attribute_length, CHECK);
1435       } else if (attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
1436         if (runtime_visible_type_annotations != NULL) {
1437           classfile_parse_error(
1438             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for field in class file %s&quot;, CHECK);
1439         }
1440         runtime_visible_type_annotations_length = attribute_length;
1441         runtime_visible_type_annotations = cfs-&gt;current();
1442         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
1443         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK);
1444       } else if (attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
1445         if (runtime_invisible_type_annotations_exists) {
1446           classfile_parse_error(
1447             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for field in class file %s&quot;, CHECK);
1448         } else {
1449           runtime_invisible_type_annotations_exists = true;
1450         }
1451         if (PreserveAllAnnotations) {
1452           runtime_invisible_type_annotations_length = attribute_length;
1453           runtime_invisible_type_annotations = cfs-&gt;current();
1454           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
1455         }
1456         cfs-&gt;skip_u1(attribute_length, CHECK);
1457       } else {
1458         cfs-&gt;skip_u1(attribute_length, CHECK);  // Skip unknown attributes
1459       }
1460     } else {
1461       cfs-&gt;skip_u1(attribute_length, CHECK);  // Skip unknown attributes
1462     }
1463   }
1464 
1465   *constantvalue_index_addr = constantvalue_index;
1466   *is_synthetic_addr = is_synthetic;
1467   *generic_signature_index_addr = generic_signature_index;
1468   AnnotationArray* a = assemble_annotations(runtime_visible_annotations,
1469                                             runtime_visible_annotations_length,
1470                                             runtime_invisible_annotations,
1471                                             runtime_invisible_annotations_length,
1472                                             CHECK);
1473   parsed_annotations-&gt;set_field_annotations(a);
1474   a = assemble_annotations(runtime_visible_type_annotations,
1475                            runtime_visible_type_annotations_length,
1476                            runtime_invisible_type_annotations,
1477                            runtime_invisible_type_annotations_length,
1478                            CHECK);
1479   parsed_annotations-&gt;set_field_type_annotations(a);
1480   return;
1481 }
1482 
1483 
1484 // Field allocation types. Used for computing field offsets.
1485 
1486 enum FieldAllocationType {
1487   STATIC_OOP,           // Oops
1488   STATIC_BYTE,          // Boolean, Byte, char
1489   STATIC_SHORT,         // shorts
1490   STATIC_WORD,          // ints
1491   STATIC_DOUBLE,        // aligned long or double
1492   STATIC_FLATTENABLE,   // flattenable field
1493   NONSTATIC_OOP,
1494   NONSTATIC_BYTE,
1495   NONSTATIC_SHORT,
1496   NONSTATIC_WORD,
1497   NONSTATIC_DOUBLE,
1498   NONSTATIC_FLATTENABLE,
1499   MAX_FIELD_ALLOCATION_TYPE,
1500   BAD_ALLOCATION_TYPE = -1
1501 };
1502 
1503 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1504   BAD_ALLOCATION_TYPE, // 0
1505   BAD_ALLOCATION_TYPE, // 1
1506   BAD_ALLOCATION_TYPE, // 2
1507   BAD_ALLOCATION_TYPE, // 3
1508   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1509   NONSTATIC_SHORT,     // T_CHAR        =  5,
1510   NONSTATIC_WORD,      // T_FLOAT       =  6,
1511   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1512   NONSTATIC_BYTE,      // T_BYTE        =  8,
1513   NONSTATIC_SHORT,     // T_SHORT       =  9,
1514   NONSTATIC_WORD,      // T_INT         = 10,
1515   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1516   NONSTATIC_OOP,       // T_OBJECT      = 12,
1517   NONSTATIC_OOP,       // T_ARRAY       = 13,
1518   NONSTATIC_OOP,       // T_VALUETYPE   = 14,
1519   BAD_ALLOCATION_TYPE, // T_VOID        = 15,
1520   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,
1521   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,
1522   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,
1523   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,
1524   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20,
1525   BAD_ALLOCATION_TYPE, // 0
1526   BAD_ALLOCATION_TYPE, // 1
1527   BAD_ALLOCATION_TYPE, // 2
1528   BAD_ALLOCATION_TYPE, // 3
1529   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1530   STATIC_SHORT,        // T_CHAR        =  5,
1531   STATIC_WORD,         // T_FLOAT       =  6,
1532   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1533   STATIC_BYTE,         // T_BYTE        =  8,
1534   STATIC_SHORT,        // T_SHORT       =  9,
1535   STATIC_WORD,         // T_INT         = 10,
1536   STATIC_DOUBLE,       // T_LONG        = 11,
1537   STATIC_OOP,          // T_OBJECT      = 12,
1538   STATIC_OOP,          // T_ARRAY       = 13,
1539   STATIC_OOP,          // T_VALUETYPE   = 14,
1540   BAD_ALLOCATION_TYPE, // T_VOID        = 15,
1541   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,
1542   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,
1543   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,
1544   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,
1545   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20
1546 };
1547 
1548 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type, bool is_flattenable) {
1549   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1550   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1551   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);
1552   if (is_flattenable) {
1553     result = is_static ? STATIC_FLATTENABLE : NONSTATIC_FLATTENABLE;
1554   }
1555   return result;
1556 }
1557 
1558 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1559  public:
1560   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1561 
1562   FieldAllocationCount() {
1563     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1564       count[i] = 0;
1565     }
1566   }
1567 
1568   FieldAllocationType update(bool is_static, BasicType type, bool is_flattenable) {
1569     FieldAllocationType atype = basic_type_to_atype(is_static, type, is_flattenable);
1570     if (atype != BAD_ALLOCATION_TYPE) {
1571       // Make sure there is no overflow with injected fields.
1572       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1573       count[atype]++;
1574     }
1575     return atype;
1576   }
1577 };
1578 
1579 // Side-effects: populates the _fields, _fields_annotations,
1580 // _fields_type_annotations fields
1581 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1582                                    bool is_interface,
1583                                    bool is_value_type,
1584                                    FieldAllocationCount* const fac,
1585                                    ConstantPool* cp,
1586                                    const int cp_size,
1587                                    u2* const java_fields_count_ptr,
1588                                    TRAPS) {
1589 
1590   assert(cfs != NULL, &quot;invariant&quot;);
1591   assert(fac != NULL, &quot;invariant&quot;);
1592   assert(cp != NULL, &quot;invariant&quot;);
1593   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1594 
1595   assert(NULL == _fields, &quot;invariant&quot;);
1596   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1597   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1598 
1599   cfs-&gt;guarantee_more(2, CHECK);  // length
1600   const u2 length = cfs-&gt;get_u2_fast();
1601   *java_fields_count_ptr = length;
1602 
1603   int num_injected = 0;
1604   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1605                                                                   &amp;num_injected);
1606 
1607   // two more slots are required for inline classes:
1608   // one for the static field with a reference to the pre-allocated default value
1609   // one for the field the JVM injects when detecting an empty inline class
1610   const int total_fields = length + num_injected + (is_value_type ? 2 : 0);
1611 
1612   // The field array starts with tuples of shorts
1613   // [access, name index, sig index, initial value index, byte offset].
1614   // A generic signature slot only exists for field with generic
1615   // signature attribute. And the access flag is set with
1616   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1617   // signature slots are at the end of the field array and after all
1618   // other fields data.
1619   //
1620   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1621   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1622   //       ...
1623   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1624   //       [generic signature index]
1625   //       [generic signature index]
1626   //       ...
1627   //
1628   // Allocate a temporary resource array for field data. For each field,
1629   // a slot is reserved in the temporary array for the generic signature
1630   // index. After parsing all fields, the data are copied to a permanent
1631   // array and any unused slots will be discarded.
1632   ResourceMark rm(THREAD);
1633   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1634                                               u2,
1635                                               total_fields * (FieldInfo::field_slots + 1));
1636 
1637   // The generic signature slots start after all other fields&#39; data.
1638   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1639   int num_generic_signature = 0;
1640   int instance_fields_count = 0;
1641   for (int n = 0; n &lt; length; n++) {
1642     // access_flags, name_index, descriptor_index, attributes_count
1643     cfs-&gt;guarantee_more(8, CHECK);
1644 
1645     jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;
1646 
1647     const jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;
1648     verify_legal_field_modifiers(flags, is_interface, is_value_type, CHECK);
1649     AccessFlags access_flags;
1650     access_flags.set_flags(flags);
1651 
1652     const u2 name_index = cfs-&gt;get_u2_fast();
1653     check_property(valid_symbol_at(name_index),
1654       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1655       name_index, CHECK);
1656     const Symbol* const name = cp-&gt;symbol_at(name_index);
1657     verify_legal_field_name(name, CHECK);
1658 
1659     const u2 signature_index = cfs-&gt;get_u2_fast();
1660     check_property(valid_symbol_at(signature_index),
1661       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1662       signature_index, CHECK);
1663     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1664     verify_legal_field_signature(name, sig, CHECK);
1665     assert(!access_flags.is_flattenable(), &quot;ACC_FLATTENABLE should have been filtered out&quot;);
1666     if (sig-&gt;is_Q_signature()) {
1667       // assert(_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS, &quot;Q-descriptors are only supported in recent classfiles&quot;);
1668       access_flags.set_is_flattenable();
1669     }
1670     if (access_flags.is_flattenable()) {
1671       // Array flattenability cannot be specified.  Arrays of value classes are
1672       // are always flattenable.  Arrays of other classes are not flattenable.
1673       if (sig-&gt;utf8_length() &gt; 1 &amp;&amp; sig-&gt;char_at(0) == &#39;[&#39;) {
1674         classfile_parse_error(
1675             &quot;Field \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s is invalid.&quot;
1676             &quot; ACC_FLATTENABLE cannot be specified for an array&quot;,
1677             name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);
1678       }
1679       _has_flattenable_fields = true;
1680     }
1681     if (!access_flags.is_static()) instance_fields_count++;
1682 
1683     u2 constantvalue_index = 0;
1684     bool is_synthetic = false;
1685     u2 generic_signature_index = 0;
1686     const bool is_static = access_flags.is_static();
1687     FieldAnnotationCollector parsed_annotations(_loader_data);
1688 
1689     const u2 attributes_count = cfs-&gt;get_u2_fast();
1690     if (attributes_count &gt; 0) {
1691       parse_field_attributes(cfs,
1692                              attributes_count,
1693                              is_static,
1694                              signature_index,
1695                              &amp;constantvalue_index,
1696                              &amp;is_synthetic,
1697                              &amp;generic_signature_index,
1698                              &amp;parsed_annotations,
1699                              CHECK);
1700 
1701       if (parsed_annotations.field_annotations() != NULL) {
1702         if (_fields_annotations == NULL) {
1703           _fields_annotations = MetadataFactory::new_array&lt;AnnotationArray*&gt;(
1704                                              _loader_data, length, NULL,
1705                                              CHECK);
1706         }
1707         _fields_annotations-&gt;at_put(n, parsed_annotations.field_annotations());
1708         parsed_annotations.set_field_annotations(NULL);
1709       }
1710       if (parsed_annotations.field_type_annotations() != NULL) {
1711         if (_fields_type_annotations == NULL) {
1712           _fields_type_annotations =
1713             MetadataFactory::new_array&lt;AnnotationArray*&gt;(_loader_data,
1714                                                          length,
1715                                                          NULL,
1716                                                          CHECK);
1717         }
1718         _fields_type_annotations-&gt;at_put(n, parsed_annotations.field_type_annotations());
1719         parsed_annotations.set_field_type_annotations(NULL);
1720       }
1721 
1722       if (is_synthetic) {
1723         access_flags.set_is_synthetic();
1724       }
1725       if (generic_signature_index != 0) {
1726         access_flags.set_field_has_generic_signature();
1727         fa[generic_signature_slot] = generic_signature_index;
1728         generic_signature_slot ++;
1729         num_generic_signature ++;
1730       }
1731     }
1732 
1733     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1734     field-&gt;initialize(access_flags.as_short(),
1735                       name_index,
1736                       signature_index,
1737                       constantvalue_index);
1738     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1739 
1740     // Remember how many oops we encountered and compute allocation type
1741     const FieldAllocationType atype = fac-&gt;update(is_static, type, access_flags.is_flattenable());
1742     field-&gt;set_allocation_type(atype);
1743 
1744     // After field is initialized with type, we can augment it with aux info
1745     if (parsed_annotations.has_any_annotations()) {
1746       parsed_annotations.apply_to(field);
1747       if (field-&gt;is_contended()) {
1748         _has_contended_fields = true;
1749       }
1750     }
1751   }
1752 
1753   int index = length;
1754   if (num_injected != 0) {
1755     for (int n = 0; n &lt; num_injected; n++) {
1756       // Check for duplicates
1757       if (injected[n].may_be_java) {
1758         const Symbol* const name      = injected[n].name();
1759         const Symbol* const signature = injected[n].signature();
1760         bool duplicate = false;
1761         for (int i = 0; i &lt; length; i++) {
1762           const FieldInfo* const f = FieldInfo::from_field_array(fa, i);
1763           if (name      == cp-&gt;symbol_at(f-&gt;name_index()) &amp;&amp;
1764               signature == cp-&gt;symbol_at(f-&gt;signature_index())) {
1765             // Symbol is desclared in Java so skip this one
1766             duplicate = true;
1767             break;
1768           }
1769         }
1770         if (duplicate) {
1771           // These will be removed from the field array at the end
1772           continue;
1773         }
1774       }
1775 
1776       // Injected field
1777       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1778       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1779                         injected[n].name_index,
1780                         injected[n].signature_index,
1781                         0);
1782 
1783       const BasicType type = Signature::basic_type(injected[n].signature());
1784 
1785       // Remember how many oops we encountered and compute allocation type
1786       const FieldAllocationType atype = fac-&gt;update(false, type, false);
1787       field-&gt;set_allocation_type(atype);
1788       index++;
1789     }
1790   }
1791 
1792   if (is_value_type) {
1793     FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1794     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,
1795                       vmSymbols::default_value_name_enum,
1796                       vmSymbols::object_signature_enum,
1797                       0);
1798     const BasicType type = Signature::basic_type(vmSymbols::object_signature());
1799     const FieldAllocationType atype = fac-&gt;update(true, type, false);
1800     field-&gt;set_allocation_type(atype);
1801     index++;
1802   }
1803 
1804   if (is_value_type &amp;&amp; instance_fields_count == 0) {
1805     _is_empty_value = true;
1806     FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1807     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1808         vmSymbols::empty_marker_name_enum,
1809         vmSymbols::byte_signature_enum,
1810         0);
1811     const BasicType type = Signature::basic_type(vmSymbols::byte_signature());
1812     const FieldAllocationType atype = fac-&gt;update(false, type, false);
1813     field-&gt;set_allocation_type(atype);
1814     index++;
1815   }
1816 
1817   assert(NULL == _fields, &quot;invariant&quot;);
1818 
1819   _fields =
1820     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1821                                    index * FieldInfo::field_slots + num_generic_signature,
1822                                    CHECK);
1823   // Sometimes injected fields already exist in the Java source so
1824   // the fields array could be too long.  In that case the
1825   // fields array is trimed. Also unused slots that were reserved
1826   // for generic signature indexes are discarded.
1827   {
1828     int i = 0;
1829     for (; i &lt; index * FieldInfo::field_slots; i++) {
1830       _fields-&gt;at_put(i, fa[i]);
1831     }
1832     for (int j = total_fields * FieldInfo::field_slots;
1833          j &lt; generic_signature_slot; j++) {
1834       _fields-&gt;at_put(i++, fa[j]);
1835     }
1836     assert(_fields-&gt;length() == i, &quot;&quot;);
1837   }
1838 
1839   if (_need_verify &amp;&amp; length &gt; 1) {
1840     // Check duplicated fields
1841     ResourceMark rm(THREAD);
1842     NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
1843       THREAD, NameSigHash*, HASH_ROW_SIZE);
1844     initialize_hashtable(names_and_sigs);
1845     bool dup = false;
1846     const Symbol* name = NULL;
1847     const Symbol* sig = NULL;
1848     {
1849       debug_only(NoSafepointVerifier nsv;)
1850       for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
1851         name = fs.name();
1852         sig = fs.signature();
1853         // If no duplicates, add name/signature in hashtable names_and_sigs.
1854         if (!put_after_lookup(name, sig, names_and_sigs)) {
1855           dup = true;
1856           break;
1857         }
1858       }
1859     }
1860     if (dup) {
1861       classfile_parse_error(&quot;Duplicate field name \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s&quot;,
1862                              name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);
1863     }
1864   }
1865 }
1866 
1867 
1868 const ClassFileParser::unsafe_u2* ClassFileParser::parse_exception_table(const ClassFileStream* const cfs,
1869                                                                          u4 code_length,
1870                                                                          u4 exception_table_length,
1871                                                                          TRAPS) {
1872   assert(cfs != NULL, &quot;invariant&quot;);
1873 
1874   const unsafe_u2* const exception_table_start = cfs-&gt;current();
1875   assert(exception_table_start != NULL, &quot;null exception table&quot;);
1876 
1877   cfs-&gt;guarantee_more(8 * exception_table_length, CHECK_NULL); // start_pc,
1878                                                                // end_pc,
1879                                                                // handler_pc,
1880                                                                // catch_type_index
1881 
1882   // Will check legal target after parsing code array in verifier.
1883   if (_need_verify) {
1884     for (unsigned int i = 0; i &lt; exception_table_length; i++) {
1885       const u2 start_pc = cfs-&gt;get_u2_fast();
1886       const u2 end_pc = cfs-&gt;get_u2_fast();
1887       const u2 handler_pc = cfs-&gt;get_u2_fast();
1888       const u2 catch_type_index = cfs-&gt;get_u2_fast();
1889       guarantee_property((start_pc &lt; end_pc) &amp;&amp; (end_pc &lt;= code_length),
1890                          &quot;Illegal exception table range in class file %s&quot;,
1891                          CHECK_NULL);
1892       guarantee_property(handler_pc &lt; code_length,
1893                          &quot;Illegal exception table handler in class file %s&quot;,
1894                          CHECK_NULL);
1895       if (catch_type_index != 0) {
1896         guarantee_property(valid_klass_reference_at(catch_type_index),
1897                            &quot;Catch type in exception table has bad constant type in class file %s&quot;, CHECK_NULL);
1898       }
1899     }
1900   } else {
1901     cfs-&gt;skip_u2_fast(exception_table_length * 4);
1902   }
1903   return exception_table_start;
1904 }
1905 
1906 void ClassFileParser::parse_linenumber_table(u4 code_attribute_length,
1907                                              u4 code_length,
1908                                              CompressedLineNumberWriteStream**const write_stream,
1909                                              TRAPS) {
1910 
1911   const ClassFileStream* const cfs = _stream;
1912   unsigned int num_entries = cfs-&gt;get_u2(CHECK);
1913 
1914   // Each entry is a u2 start_pc, and a u2 line_number
1915   const unsigned int length_in_bytes = num_entries * (sizeof(u2) * 2);
1916 
1917   // Verify line number attribute and table length
1918   check_property(
1919     code_attribute_length == sizeof(u2) + length_in_bytes,
1920     &quot;LineNumberTable attribute has wrong length in class file %s&quot;, CHECK);
1921 
1922   cfs-&gt;guarantee_more(length_in_bytes, CHECK);
1923 
1924   if ((*write_stream) == NULL) {
1925     if (length_in_bytes &gt; fixed_buffer_size) {
1926       (*write_stream) = new CompressedLineNumberWriteStream(length_in_bytes);
1927     } else {
1928       (*write_stream) = new CompressedLineNumberWriteStream(
1929         _linenumbertable_buffer, fixed_buffer_size);
1930     }
1931   }
1932 
1933   while (num_entries-- &gt; 0) {
1934     const u2 bci  = cfs-&gt;get_u2_fast(); // start_pc
1935     const u2 line = cfs-&gt;get_u2_fast(); // line_number
1936     guarantee_property(bci &lt; code_length,
1937         &quot;Invalid pc in LineNumberTable in class file %s&quot;, CHECK);
1938     (*write_stream)-&gt;write_pair(bci, line);
1939   }
1940 }
1941 
1942 
1943 class LVT_Hash : public AllStatic {
1944  public:
1945 
1946   static bool equals(LocalVariableTableElement const&amp; e0, LocalVariableTableElement const&amp; e1) {
1947   /*
1948    * 3-tuple start_bci/length/slot has to be unique key,
1949    * so the following comparison seems to be redundant:
1950    *       &amp;&amp; elem-&gt;name_cp_index == entry-&gt;_elem-&gt;name_cp_index
1951    */
1952     return (e0.start_bci     == e1.start_bci &amp;&amp;
1953             e0.length        == e1.length &amp;&amp;
1954             e0.name_cp_index == e1.name_cp_index &amp;&amp;
1955             e0.slot          == e1.slot);
1956   }
1957 
1958   static unsigned int hash(LocalVariableTableElement const&amp; e0) {
1959     unsigned int raw_hash = e0.start_bci;
1960 
1961     raw_hash = e0.length        + raw_hash * 37;
1962     raw_hash = e0.name_cp_index + raw_hash * 37;
1963     raw_hash = e0.slot          + raw_hash * 37;
1964 
1965     return raw_hash;
1966   }
1967 };
1968 
1969 
1970 // Class file LocalVariableTable elements.
1971 class Classfile_LVT_Element {
1972  public:
1973   u2 start_bci;
1974   u2 length;
1975   u2 name_cp_index;
1976   u2 descriptor_cp_index;
1977   u2 slot;
1978 };
1979 
1980 static void copy_lvt_element(const Classfile_LVT_Element* const src,
1981                              LocalVariableTableElement* const lvt) {
1982   lvt-&gt;start_bci           = Bytes::get_Java_u2((u1*) &amp;src-&gt;start_bci);
1983   lvt-&gt;length              = Bytes::get_Java_u2((u1*) &amp;src-&gt;length);
1984   lvt-&gt;name_cp_index       = Bytes::get_Java_u2((u1*) &amp;src-&gt;name_cp_index);
1985   lvt-&gt;descriptor_cp_index = Bytes::get_Java_u2((u1*) &amp;src-&gt;descriptor_cp_index);
1986   lvt-&gt;signature_cp_index  = 0;
1987   lvt-&gt;slot                = Bytes::get_Java_u2((u1*) &amp;src-&gt;slot);
1988 }
1989 
1990 // Function is used to parse both attributes:
1991 // LocalVariableTable (LVT) and LocalVariableTypeTable (LVTT)
1992 const ClassFileParser::unsafe_u2* ClassFileParser::parse_localvariable_table(const ClassFileStream* cfs,
1993                                                                              u4 code_length,
1994                                                                              u2 max_locals,
1995                                                                              u4 code_attribute_length,
1996                                                                              u2* const localvariable_table_length,
1997                                                                              bool isLVTT,
1998                                                                              TRAPS) {
1999   const char* const tbl_name = (isLVTT) ? &quot;LocalVariableTypeTable&quot; : &quot;LocalVariableTable&quot;;
2000   *localvariable_table_length = cfs-&gt;get_u2(CHECK_NULL);
2001   const unsigned int size =
2002     (*localvariable_table_length) * sizeof(Classfile_LVT_Element) / sizeof(u2);
2003 
2004   const ConstantPool* const cp = _cp;
2005 
2006   // Verify local variable table attribute has right length
2007   if (_need_verify) {
2008     guarantee_property(code_attribute_length == (sizeof(*localvariable_table_length) + size * sizeof(u2)),
2009                        &quot;%s has wrong length in class file %s&quot;, tbl_name, CHECK_NULL);
2010   }
2011 
2012   const unsafe_u2* const localvariable_table_start = cfs-&gt;current();
2013   assert(localvariable_table_start != NULL, &quot;null local variable table&quot;);
2014   if (!_need_verify) {
2015     cfs-&gt;skip_u2_fast(size);
2016   } else {
2017     cfs-&gt;guarantee_more(size * 2, CHECK_NULL);
2018     for(int i = 0; i &lt; (*localvariable_table_length); i++) {
2019       const u2 start_pc = cfs-&gt;get_u2_fast();
2020       const u2 length = cfs-&gt;get_u2_fast();
2021       const u2 name_index = cfs-&gt;get_u2_fast();
2022       const u2 descriptor_index = cfs-&gt;get_u2_fast();
2023       const u2 index = cfs-&gt;get_u2_fast();
2024       // Assign to a u4 to avoid overflow
2025       const u4 end_pc = (u4)start_pc + (u4)length;
2026 
2027       if (start_pc &gt;= code_length) {
2028         classfile_parse_error(
2029           &quot;Invalid start_pc %u in %s in class file %s&quot;,
2030           start_pc, tbl_name, CHECK_NULL);
2031       }
2032       if (end_pc &gt; code_length) {
2033         classfile_parse_error(
2034           &quot;Invalid length %u in %s in class file %s&quot;,
2035           length, tbl_name, CHECK_NULL);
2036       }
2037       const int cp_size = cp-&gt;length();
2038       guarantee_property(valid_symbol_at(name_index),
2039         &quot;Name index %u in %s has bad constant type in class file %s&quot;,
2040         name_index, tbl_name, CHECK_NULL);
2041       guarantee_property(valid_symbol_at(descriptor_index),
2042         &quot;Signature index %u in %s has bad constant type in class file %s&quot;,
2043         descriptor_index, tbl_name, CHECK_NULL);
2044 
2045       const Symbol* const name = cp-&gt;symbol_at(name_index);
2046       const Symbol* const sig = cp-&gt;symbol_at(descriptor_index);
2047       verify_legal_field_name(name, CHECK_NULL);
2048       u2 extra_slot = 0;
2049       if (!isLVTT) {
2050         verify_legal_field_signature(name, sig, CHECK_NULL);
2051 
2052         // 4894874: check special cases for double and long local variables
2053         if (sig == vmSymbols::type_signature(T_DOUBLE) ||
2054             sig == vmSymbols::type_signature(T_LONG)) {
2055           extra_slot = 1;
2056         }
2057       }
2058       guarantee_property((index + extra_slot) &lt; max_locals,
2059                           &quot;Invalid index %u in %s in class file %s&quot;,
2060                           index, tbl_name, CHECK_NULL);
2061     }
2062   }
2063   return localvariable_table_start;
2064 }
2065 
2066 static const u1* parse_stackmap_table(const ClassFileStream* const cfs,
2067                                       u4 code_attribute_length,
2068                                       bool need_verify,
2069                                       TRAPS) {
2070   assert(cfs != NULL, &quot;invariant&quot;);
2071 
2072   if (0 == code_attribute_length) {
2073     return NULL;
2074   }
2075 
2076   const u1* const stackmap_table_start = cfs-&gt;current();
2077   assert(stackmap_table_start != NULL, &quot;null stackmap table&quot;);
2078 
2079   // check code_attribute_length first
2080   cfs-&gt;skip_u1(code_attribute_length, CHECK_NULL);
2081 
2082   if (!need_verify &amp;&amp; !DumpSharedSpaces) {
2083     return NULL;
2084   }
2085   return stackmap_table_start;
2086 }
2087 
2088 const ClassFileParser::unsafe_u2* ClassFileParser::parse_checked_exceptions(const ClassFileStream* const cfs,
2089                                                                             u2* const checked_exceptions_length,
2090                                                                             u4 method_attribute_length,
2091                                                                             TRAPS) {
2092   assert(cfs != NULL, &quot;invariant&quot;);
2093   assert(checked_exceptions_length != NULL, &quot;invariant&quot;);
2094 
2095   cfs-&gt;guarantee_more(2, CHECK_NULL);  // checked_exceptions_length
2096   *checked_exceptions_length = cfs-&gt;get_u2_fast();
2097   const unsigned int size =
2098     (*checked_exceptions_length) * sizeof(CheckedExceptionElement) / sizeof(u2);
2099   const unsafe_u2* const checked_exceptions_start = cfs-&gt;current();
2100   assert(checked_exceptions_start != NULL, &quot;null checked exceptions&quot;);
2101   if (!_need_verify) {
2102     cfs-&gt;skip_u2_fast(size);
2103   } else {
2104     // Verify each value in the checked exception table
2105     u2 checked_exception;
2106     const u2 len = *checked_exceptions_length;
2107     cfs-&gt;guarantee_more(2 * len, CHECK_NULL);
2108     for (int i = 0; i &lt; len; i++) {
2109       checked_exception = cfs-&gt;get_u2_fast();
2110       check_property(
2111         valid_klass_reference_at(checked_exception),
2112         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2113         checked_exception, CHECK_NULL);
2114     }
2115   }
2116   // check exceptions attribute length
2117   if (_need_verify) {
2118     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2119                                                    sizeof(u2) * size),
2120                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2121   }
2122   return checked_exceptions_start;
2123 }
2124 
2125 void ClassFileParser::throwIllegalSignature(const char* type,
2126                                             const Symbol* name,
2127                                             const Symbol* sig,
2128                                             TRAPS) const {
2129   assert(name != NULL, &quot;invariant&quot;);
2130   assert(sig != NULL, &quot;invariant&quot;);
2131 
2132   const char* class_note = &quot;&quot;;
2133   if (is_value_type() &amp;&amp; name == vmSymbols::object_initializer_name()) {
2134     class_note = &quot; (an inline class)&quot;;
2135   }
2136 
2137   ResourceMark rm(THREAD);
2138   Exceptions::fthrow(THREAD_AND_LOCATION,
2139       vmSymbols::java_lang_ClassFormatError(),
2140       &quot;%s \&quot;%s\&quot; in class %s%s has illegal signature \&quot;%s\&quot;&quot;, type,
2141       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, sig-&gt;as_C_string());
2142 }
2143 
2144 AnnotationCollector::ID
2145 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2146                                       const Symbol* name) {
2147   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2148   // Privileged code can use all annotations.  Other code silently drops some.
2149   const bool privileged = loader_data-&gt;is_the_null_class_loader_data() ||
2150                           loader_data-&gt;is_platform_class_loader_data() ||
2151                           loader_data-&gt;is_unsafe_anonymous();
2152   switch (sid) {
2153     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2154       if (_location != _in_method)  break;  // only allow for methods
2155       if (!privileged)              break;  // only allow in privileged code
2156       return _method_CallerSensitive;
2157     }
2158     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2159       if (_location != _in_method)  break;  // only allow for methods
2160       if (!privileged)              break;  // only allow in privileged code
2161       return _method_ForceInline;
2162     }
2163     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_DontInline_signature): {
2164       if (_location != _in_method)  break;  // only allow for methods
2165       if (!privileged)              break;  // only allow in privileged code
2166       return _method_DontInline;
2167     }
2168     case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_InjectedProfile_signature): {
2169       if (_location != _in_method)  break;  // only allow for methods
2170       if (!privileged)              break;  // only allow in privileged code
2171       return _method_InjectedProfile;
2172     }
2173     case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_LambdaForm_Compiled_signature): {
2174       if (_location != _in_method)  break;  // only allow for methods
2175       if (!privileged)              break;  // only allow in privileged code
2176       return _method_LambdaForm_Compiled;
2177     }
2178     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Hidden_signature): {
2179       if (_location != _in_method)  break;  // only allow for methods
2180       if (!privileged)              break;  // only allow in privileged code
2181       return _method_Hidden;
2182     }
2183     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_HotSpotIntrinsicCandidate_signature): {
2184       if (_location != _in_method)  break;  // only allow for methods
2185       if (!privileged)              break;  // only allow in privileged code
2186       return _method_HotSpotIntrinsicCandidate;
2187     }
2188     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Stable_signature): {
2189       if (_location != _in_field)   break;  // only allow for fields
2190       if (!privileged)              break;  // only allow in privileged code
2191       return _field_Stable;
2192     }
2193     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Contended_signature): {
2194       if (_location != _in_field &amp;&amp; _location != _in_class) {
2195         break;  // only allow for fields and classes
2196       }
2197       if (!EnableContended || (RestrictContended &amp;&amp; !privileged)) {
2198         break;  // honor privileges
2199       }
2200       return _jdk_internal_vm_annotation_Contended;
2201     }
2202     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ReservedStackAccess_signature): {
2203       if (_location != _in_method)  break;  // only allow for methods
2204       if (RestrictReservedStack &amp;&amp; !privileged) break; // honor privileges
2205       return _jdk_internal_vm_annotation_ReservedStackAccess;
2206     }
2207     default: {
2208       break;
2209     }
2210   }
2211   return AnnotationCollector::_unknown;
2212 }
2213 
2214 void ClassFileParser::FieldAnnotationCollector::apply_to(FieldInfo* f) {
2215   if (is_contended())
2216     f-&gt;set_contended_group(contended_group());
2217   if (is_stable())
2218     f-&gt;set_stable(true);
2219 }
2220 
2221 ClassFileParser::FieldAnnotationCollector::~FieldAnnotationCollector() {
2222   // If there&#39;s an error deallocate metadata for field annotations
2223   MetadataFactory::free_array&lt;u1&gt;(_loader_data, _field_annotations);
2224   MetadataFactory::free_array&lt;u1&gt;(_loader_data, _field_type_annotations);
2225 }
2226 
2227 void MethodAnnotationCollector::apply_to(const methodHandle&amp; m) {
2228   if (has_annotation(_method_CallerSensitive))
2229     m-&gt;set_caller_sensitive(true);
2230   if (has_annotation(_method_ForceInline))
2231     m-&gt;set_force_inline(true);
2232   if (has_annotation(_method_DontInline))
2233     m-&gt;set_dont_inline(true);
2234   if (has_annotation(_method_InjectedProfile))
2235     m-&gt;set_has_injected_profile(true);
2236   if (has_annotation(_method_LambdaForm_Compiled) &amp;&amp; m-&gt;intrinsic_id() == vmIntrinsics::_none)
2237     m-&gt;set_intrinsic_id(vmIntrinsics::_compiledLambdaForm);
2238   if (has_annotation(_method_Hidden))
2239     m-&gt;set_hidden(true);
2240   if (has_annotation(_method_HotSpotIntrinsicCandidate) &amp;&amp; !m-&gt;is_synthetic())
2241     m-&gt;set_intrinsic_candidate(true);
2242   if (has_annotation(_jdk_internal_vm_annotation_ReservedStackAccess))
2243     m-&gt;set_has_reserved_stack_access(true);
2244 }
2245 
2246 void ClassFileParser::ClassAnnotationCollector::apply_to(InstanceKlass* ik) {
2247   assert(ik != NULL, &quot;invariant&quot;);
2248   ik-&gt;set_is_contended(is_contended());
2249 }
2250 
2251 #define MAX_ARGS_SIZE 255
2252 #define MAX_CODE_SIZE 65535
2253 #define INITIAL_MAX_LVT_NUMBER 256
2254 
2255 /* Copy class file LVT&#39;s/LVTT&#39;s into the HotSpot internal LVT.
2256  *
2257  * Rules for LVT&#39;s and LVTT&#39;s are:
2258  *   - There can be any number of LVT&#39;s and LVTT&#39;s.
2259  *   - If there are n LVT&#39;s, it is the same as if there was just
2260  *     one LVT containing all the entries from the n LVT&#39;s.
2261  *   - There may be no more than one LVT entry per local variable.
2262  *     Two LVT entries are &#39;equal&#39; if these fields are the same:
2263  *        start_pc, length, name, slot
2264  *   - There may be no more than one LVTT entry per each LVT entry.
2265  *     Each LVTT entry has to match some LVT entry.
2266  *   - HotSpot internal LVT keeps natural ordering of class file LVT entries.
2267  */
2268 void ClassFileParser::copy_localvariable_table(const ConstMethod* cm,
2269                                                int lvt_cnt,
2270                                                u2* const localvariable_table_length,
2271                                                const unsafe_u2** const localvariable_table_start,
2272                                                int lvtt_cnt,
2273                                                u2* const localvariable_type_table_length,
2274                                                const unsafe_u2** const localvariable_type_table_start,
2275                                                TRAPS) {
2276 
2277   ResourceMark rm(THREAD);
2278 
2279   typedef ResourceHashtable&lt;LocalVariableTableElement, LocalVariableTableElement*,
2280                             &amp;LVT_Hash::hash, &amp;LVT_Hash::equals&gt; LVT_HashTable;
2281 
2282   LVT_HashTable* const table = new LVT_HashTable();
2283 
2284   // To fill LocalVariableTable in
2285   const Classfile_LVT_Element* cf_lvt;
2286   LocalVariableTableElement* lvt = cm-&gt;localvariable_table_start();
2287 
2288   for (int tbl_no = 0; tbl_no &lt; lvt_cnt; tbl_no++) {
2289     cf_lvt = (Classfile_LVT_Element *) localvariable_table_start[tbl_no];
2290     for (int idx = 0; idx &lt; localvariable_table_length[tbl_no]; idx++, lvt++) {
2291       copy_lvt_element(&amp;cf_lvt[idx], lvt);
2292       // If no duplicates, add LVT elem in hashtable.
2293       if (table-&gt;put(*lvt, lvt) == false
2294           &amp;&amp; _need_verify
2295           &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
2296         classfile_parse_error(&quot;Duplicated LocalVariableTable attribute &quot;
2297                               &quot;entry for &#39;%s&#39; in class file %s&quot;,
2298                                _cp-&gt;symbol_at(lvt-&gt;name_cp_index)-&gt;as_utf8(),
2299                                CHECK);
2300       }
2301     }
2302   }
2303 
2304   // To merge LocalVariableTable and LocalVariableTypeTable
2305   const Classfile_LVT_Element* cf_lvtt;
2306   LocalVariableTableElement lvtt_elem;
2307 
2308   for (int tbl_no = 0; tbl_no &lt; lvtt_cnt; tbl_no++) {
2309     cf_lvtt = (Classfile_LVT_Element *) localvariable_type_table_start[tbl_no];
2310     for (int idx = 0; idx &lt; localvariable_type_table_length[tbl_no]; idx++) {
2311       copy_lvt_element(&amp;cf_lvtt[idx], &amp;lvtt_elem);
2312       LocalVariableTableElement** entry = table-&gt;get(lvtt_elem);
2313       if (entry == NULL) {
2314         if (_need_verify) {
2315           classfile_parse_error(&quot;LVTT entry for &#39;%s&#39; in class file %s &quot;
2316                                 &quot;does not match any LVT entry&quot;,
2317                                  _cp-&gt;symbol_at(lvtt_elem.name_cp_index)-&gt;as_utf8(),
2318                                  CHECK);
2319         }
2320       } else if ((*entry)-&gt;signature_cp_index != 0 &amp;&amp; _need_verify) {
2321         classfile_parse_error(&quot;Duplicated LocalVariableTypeTable attribute &quot;
2322                               &quot;entry for &#39;%s&#39; in class file %s&quot;,
2323                                _cp-&gt;symbol_at(lvtt_elem.name_cp_index)-&gt;as_utf8(),
2324                                CHECK);
2325       } else {
2326         // to add generic signatures into LocalVariableTable
2327         (*entry)-&gt;signature_cp_index = lvtt_elem.descriptor_cp_index;
2328       }
2329     }
2330   }
2331 }
2332 
2333 
2334 void ClassFileParser::copy_method_annotations(ConstMethod* cm,
2335                                        const u1* runtime_visible_annotations,
2336                                        int runtime_visible_annotations_length,
2337                                        const u1* runtime_invisible_annotations,
2338                                        int runtime_invisible_annotations_length,
2339                                        const u1* runtime_visible_parameter_annotations,
2340                                        int runtime_visible_parameter_annotations_length,
2341                                        const u1* runtime_invisible_parameter_annotations,
2342                                        int runtime_invisible_parameter_annotations_length,
2343                                        const u1* runtime_visible_type_annotations,
2344                                        int runtime_visible_type_annotations_length,
2345                                        const u1* runtime_invisible_type_annotations,
2346                                        int runtime_invisible_type_annotations_length,
2347                                        const u1* annotation_default,
2348                                        int annotation_default_length,
2349                                        TRAPS) {
2350 
2351   AnnotationArray* a;
2352 
2353   if (runtime_visible_annotations_length +
2354       runtime_invisible_annotations_length &gt; 0) {
2355      a = assemble_annotations(runtime_visible_annotations,
2356                               runtime_visible_annotations_length,
2357                               runtime_invisible_annotations,
2358                               runtime_invisible_annotations_length,
2359                               CHECK);
2360      cm-&gt;set_method_annotations(a);
2361   }
2362 
2363   if (runtime_visible_parameter_annotations_length +
2364       runtime_invisible_parameter_annotations_length &gt; 0) {
2365     a = assemble_annotations(runtime_visible_parameter_annotations,
2366                              runtime_visible_parameter_annotations_length,
2367                              runtime_invisible_parameter_annotations,
2368                              runtime_invisible_parameter_annotations_length,
2369                              CHECK);
2370     cm-&gt;set_parameter_annotations(a);
2371   }
2372 
2373   if (annotation_default_length &gt; 0) {
2374     a = assemble_annotations(annotation_default,
2375                              annotation_default_length,
2376                              NULL,
2377                              0,
2378                              CHECK);
2379     cm-&gt;set_default_annotations(a);
2380   }
2381 
2382   if (runtime_visible_type_annotations_length +
2383       runtime_invisible_type_annotations_length &gt; 0) {
2384     a = assemble_annotations(runtime_visible_type_annotations,
2385                              runtime_visible_type_annotations_length,
2386                              runtime_invisible_type_annotations,
2387                              runtime_invisible_type_annotations_length,
2388                              CHECK);
2389     cm-&gt;set_type_annotations(a);
2390   }
2391 }
2392 
2393 
2394 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2395 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2396 // Method* to save footprint, so we only know the size of the resulting Method* when the
2397 // entire method attribute is parsed.
2398 //
2399 // The promoted_flags parameter is used to pass relevant access_flags
2400 // from the method back up to the containing klass. These flag values
2401 // are added to klass&#39;s access_flags.
2402 
2403 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2404                                       bool is_interface,
2405                                       bool is_value_type,
2406                                       const ConstantPool* cp,
2407                                       AccessFlags* const promoted_flags,
2408                                       TRAPS) {
2409   assert(cfs != NULL, &quot;invariant&quot;);
2410   assert(cp != NULL, &quot;invariant&quot;);
2411   assert(promoted_flags != NULL, &quot;invariant&quot;);
2412 
2413   ResourceMark rm(THREAD);
2414   // Parse fixed parts:
2415   // access_flags, name_index, descriptor_index, attributes_count
2416   cfs-&gt;guarantee_more(8, CHECK_NULL);
2417 
2418   int flags = cfs-&gt;get_u2_fast();
2419   const u2 name_index = cfs-&gt;get_u2_fast();
2420   const int cp_size = cp-&gt;length();
2421   check_property(
2422     valid_symbol_at(name_index),
2423     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2424     name_index, CHECK_NULL);
2425   const Symbol* const name = cp-&gt;symbol_at(name_index);
2426   verify_legal_method_name(name, CHECK_NULL);
2427 
2428   const u2 signature_index = cfs-&gt;get_u2_fast();
2429   guarantee_property(
2430     valid_symbol_at(signature_index),
2431     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2432     signature_index, CHECK_NULL);
2433   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2434 
2435   if (name == vmSymbols::class_initializer_name()) {
2436     // We ignore the other access flags for a valid class initializer.
2437     // (JVM Spec 2nd ed., chapter 4.6)
2438     if (_major_version &lt; 51) { // backward compatibility
2439       flags = JVM_ACC_STATIC;
2440     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2441       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2442     } else {
2443       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2444     }
2445   } else {
2446     verify_legal_method_modifiers(flags, is_interface, is_value_type, name, CHECK_NULL);
2447   }
2448 
2449   if (name == vmSymbols::object_initializer_name()) {
2450     if (is_interface) {
2451       classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);
2452     } else if (!is_value_type &amp;&amp; signature-&gt;is_void_method_signature()) {
2453       // OK, a constructor
2454     } else if (is_value_type &amp;&amp; !signature-&gt;is_void_method_signature()) {
2455       // also OK, a static factory, as long as the return value is good
2456       bool ok = false;
2457       SignatureStream ss((Symbol*) signature, true);
2458       while (!ss.at_return_type())  ss.next();
2459       if (ss.is_reference()) {
2460         Symbol* ret = ss.as_symbol();
2461         const Symbol* required = class_name();
2462         if (is_unsafe_anonymous()) {
2463           // The original class name in the UAC byte stream gets changed.  So
2464           // using the original name in the return type is no longer valid.
2465           required = vmSymbols::java_lang_Object();
2466         }
2467         ok = (ret == required);
2468       }
2469       if (!ok) {
2470         throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
2471       }
2472     } else {
2473       // not OK, so throw the same error as in verify_legal_method_signature.
2474       throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
2475     }
2476     // A declared &lt;init&gt; method must always be either a non-static
2477     // object constructor, with a void return, or else it must be a
2478     // static factory method, with a non-void return.  No other
2479     // definition of &lt;init&gt; is possible.
2480     //
2481     // The verifier (in verify_invoke_instructions) will inspect the
2482     // signature of any attempt to invoke &lt;init&gt;, and ensures that it
2483     // returns non-void if and only if it is being invoked by
2484     // invokestatic, and void if and only if it is being invoked by
2485     // invokespecial.
2486     //
2487     // When a symbolic reference to &lt;init&gt; is resolved for a
2488     // particular invocation mode (special or static), the mode is
2489     // matched to the JVM_ACC_STATIC modifier of the &lt;init&gt; method.
2490     // Thus, it is impossible to statically invoke a constructor, and
2491     // impossible to &quot;new + invokespecial&quot; a static factory, either
2492     // through bytecode or through reflection.
2493   }
2494 
2495   int args_size = -1;  // only used when _need_verify is true
2496   if (_need_verify) {
2497     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2498                  verify_legal_method_signature(name, signature, CHECK_NULL);
2499     if (args_size &gt; MAX_ARGS_SIZE) {
2500       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2501     }
2502   }
2503 
2504   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2505 
2506   // Default values for code and exceptions attribute elements
2507   u2 max_stack = 0;
2508   u2 max_locals = 0;
2509   u4 code_length = 0;
2510   const u1* code_start = 0;
2511   u2 exception_table_length = 0;
2512   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
2513   Array&lt;int&gt;* exception_handlers = Universe::the_empty_int_array();
2514   u2 checked_exceptions_length = 0;
2515   const unsafe_u2* checked_exceptions_start = NULL; // (potentially unaligned) pointer to array of u2 elements
2516   CompressedLineNumberWriteStream* linenumber_table = NULL;
2517   int linenumber_table_length = 0;
2518   int total_lvt_length = 0;
2519   u2 lvt_cnt = 0;
2520   u2 lvtt_cnt = 0;
2521   bool lvt_allocated = false;
2522   u2 max_lvt_cnt = INITIAL_MAX_LVT_NUMBER;
2523   u2 max_lvtt_cnt = INITIAL_MAX_LVT_NUMBER;
2524   u2* localvariable_table_length = NULL;
2525   const unsafe_u2** localvariable_table_start = NULL; // (potentially unaligned) pointer to array of LVT attributes
2526   u2* localvariable_type_table_length = NULL;
2527   const unsafe_u2** localvariable_type_table_start = NULL; // (potentially unaligned) pointer to LVTT attributes
2528   int method_parameters_length = -1;
2529   const u1* method_parameters_data = NULL;
2530   bool method_parameters_seen = false;
2531   bool parsed_code_attribute = false;
2532   bool parsed_checked_exceptions_attribute = false;
2533   bool parsed_stackmap_attribute = false;
2534   // stackmap attribute - JDK1.5
2535   const u1* stackmap_data = NULL;
2536   int stackmap_data_length = 0;
2537   u2 generic_signature_index = 0;
2538   MethodAnnotationCollector parsed_annotations;
2539   const u1* runtime_visible_annotations = NULL;
2540   int runtime_visible_annotations_length = 0;
2541   const u1* runtime_invisible_annotations = NULL;
2542   int runtime_invisible_annotations_length = 0;
2543   const u1* runtime_visible_parameter_annotations = NULL;
2544   int runtime_visible_parameter_annotations_length = 0;
2545   const u1* runtime_invisible_parameter_annotations = NULL;
2546   int runtime_invisible_parameter_annotations_length = 0;
2547   const u1* runtime_visible_type_annotations = NULL;
2548   int runtime_visible_type_annotations_length = 0;
2549   const u1* runtime_invisible_type_annotations = NULL;
2550   int runtime_invisible_type_annotations_length = 0;
2551   bool runtime_invisible_annotations_exists = false;
2552   bool runtime_invisible_type_annotations_exists = false;
2553   bool runtime_invisible_parameter_annotations_exists = false;
2554   const u1* annotation_default = NULL;
2555   int annotation_default_length = 0;
2556 
2557   // Parse code and exceptions attribute
2558   u2 method_attributes_count = cfs-&gt;get_u2_fast();
2559   while (method_attributes_count--) {
2560     cfs-&gt;guarantee_more(6, CHECK_NULL);  // method_attribute_name_index, method_attribute_length
2561     const u2 method_attribute_name_index = cfs-&gt;get_u2_fast();
2562     const u4 method_attribute_length = cfs-&gt;get_u4_fast();
2563     check_property(
2564       valid_symbol_at(method_attribute_name_index),
2565       &quot;Invalid method attribute name index %u in class file %s&quot;,
2566       method_attribute_name_index, CHECK_NULL);
2567 
2568     const Symbol* const method_attribute_name = cp-&gt;symbol_at(method_attribute_name_index);
2569     if (method_attribute_name == vmSymbols::tag_code()) {
2570       // Parse Code attribute
2571       if (_need_verify) {
2572         guarantee_property(
2573             !access_flags.is_native() &amp;&amp; !access_flags.is_abstract(),
2574                         &quot;Code attribute in native or abstract methods in class file %s&quot;,
2575                          CHECK_NULL);
2576       }
2577       if (parsed_code_attribute) {
2578         classfile_parse_error(&quot;Multiple Code attributes in class file %s&quot;,
2579                               CHECK_NULL);
2580       }
2581       parsed_code_attribute = true;
2582 
2583       // Stack size, locals size, and code size
2584       cfs-&gt;guarantee_more(8, CHECK_NULL);
2585       max_stack = cfs-&gt;get_u2_fast();
2586       max_locals = cfs-&gt;get_u2_fast();
2587       code_length = cfs-&gt;get_u4_fast();
2588       if (_need_verify) {
2589         guarantee_property(args_size &lt;= max_locals,
2590                            &quot;Arguments can&#39;t fit into locals in class file %s&quot;,
2591                            CHECK_NULL);
2592         guarantee_property(code_length &gt; 0 &amp;&amp; code_length &lt;= MAX_CODE_SIZE,
2593                            &quot;Invalid method Code length %u in class file %s&quot;,
2594                            code_length, CHECK_NULL);
2595       }
2596       // Code pointer
2597       code_start = cfs-&gt;current();
2598       assert(code_start != NULL, &quot;null code start&quot;);
2599       cfs-&gt;guarantee_more(code_length, CHECK_NULL);
2600       cfs-&gt;skip_u1_fast(code_length);
2601 
2602       // Exception handler table
2603       cfs-&gt;guarantee_more(2, CHECK_NULL);  // exception_table_length
2604       exception_table_length = cfs-&gt;get_u2_fast();
2605       if (exception_table_length &gt; 0) {
2606         exception_table_start = parse_exception_table(cfs,
2607                                                       code_length,
2608                                                       exception_table_length,
2609                                                       CHECK_NULL);
2610       }
2611 
2612       // Parse additional attributes in code attribute
2613       cfs-&gt;guarantee_more(2, CHECK_NULL);  // code_attributes_count
2614       u2 code_attributes_count = cfs-&gt;get_u2_fast();
2615 
2616       unsigned int calculated_attribute_length = 0;
2617 
2618       calculated_attribute_length =
2619           sizeof(max_stack) + sizeof(max_locals) + sizeof(code_length);
2620       calculated_attribute_length +=
2621         code_length +
2622         sizeof(exception_table_length) +
2623         sizeof(code_attributes_count) +
2624         exception_table_length *
2625             ( sizeof(u2) +   // start_pc
2626               sizeof(u2) +   // end_pc
2627               sizeof(u2) +   // handler_pc
2628               sizeof(u2) );  // catch_type_index
2629 
2630       while (code_attributes_count--) {
2631         cfs-&gt;guarantee_more(6, CHECK_NULL);  // code_attribute_name_index, code_attribute_length
2632         const u2 code_attribute_name_index = cfs-&gt;get_u2_fast();
2633         const u4 code_attribute_length = cfs-&gt;get_u4_fast();
2634         calculated_attribute_length += code_attribute_length +
2635                                        sizeof(code_attribute_name_index) +
2636                                        sizeof(code_attribute_length);
2637         check_property(valid_symbol_at(code_attribute_name_index),
2638                        &quot;Invalid code attribute name index %u in class file %s&quot;,
2639                        code_attribute_name_index,
2640                        CHECK_NULL);
2641         if (LoadLineNumberTables &amp;&amp;
2642             cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_line_number_table()) {
2643           // Parse and compress line number table
2644           parse_linenumber_table(code_attribute_length,
2645                                  code_length,
2646                                  &amp;linenumber_table,
2647                                  CHECK_NULL);
2648 
2649         } else if (LoadLocalVariableTables &amp;&amp;
2650                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_local_variable_table()) {
2651           // Parse local variable table
2652           if (!lvt_allocated) {
2653             localvariable_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2654               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2655             localvariable_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2656               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2657             localvariable_type_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2658               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2659             localvariable_type_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2660               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2661             lvt_allocated = true;
2662           }
2663           if (lvt_cnt == max_lvt_cnt) {
2664             max_lvt_cnt &lt;&lt;= 1;
2665             localvariable_table_length = REALLOC_RESOURCE_ARRAY(u2, localvariable_table_length, lvt_cnt, max_lvt_cnt);
2666             localvariable_table_start  = REALLOC_RESOURCE_ARRAY(const unsafe_u2*, localvariable_table_start, lvt_cnt, max_lvt_cnt);
2667           }
2668           localvariable_table_start[lvt_cnt] =
2669             parse_localvariable_table(cfs,
2670                                       code_length,
2671                                       max_locals,
2672                                       code_attribute_length,
2673                                       &amp;localvariable_table_length[lvt_cnt],
2674                                       false,    // is not LVTT
2675                                       CHECK_NULL);
2676           total_lvt_length += localvariable_table_length[lvt_cnt];
2677           lvt_cnt++;
2678         } else if (LoadLocalVariableTypeTables &amp;&amp;
2679                    _major_version &gt;= JAVA_1_5_VERSION &amp;&amp;
2680                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_local_variable_type_table()) {
2681           if (!lvt_allocated) {
2682             localvariable_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2683               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2684             localvariable_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2685               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2686             localvariable_type_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2687               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2688             localvariable_type_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2689               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2690             lvt_allocated = true;
2691           }
2692           // Parse local variable type table
2693           if (lvtt_cnt == max_lvtt_cnt) {
2694             max_lvtt_cnt &lt;&lt;= 1;
2695             localvariable_type_table_length = REALLOC_RESOURCE_ARRAY(u2, localvariable_type_table_length, lvtt_cnt, max_lvtt_cnt);
2696             localvariable_type_table_start  = REALLOC_RESOURCE_ARRAY(const unsafe_u2*, localvariable_type_table_start, lvtt_cnt, max_lvtt_cnt);
2697           }
2698           localvariable_type_table_start[lvtt_cnt] =
2699             parse_localvariable_table(cfs,
2700                                       code_length,
2701                                       max_locals,
2702                                       code_attribute_length,
2703                                       &amp;localvariable_type_table_length[lvtt_cnt],
2704                                       true,     // is LVTT
2705                                       CHECK_NULL);
2706           lvtt_cnt++;
2707         } else if (_major_version &gt;= Verifier::STACKMAP_ATTRIBUTE_MAJOR_VERSION &amp;&amp;
2708                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_stack_map_table()) {
2709           // Stack map is only needed by the new verifier in JDK1.5.
2710           if (parsed_stackmap_attribute) {
2711             classfile_parse_error(&quot;Multiple StackMapTable attributes in class file %s&quot;, CHECK_NULL);
2712           }
2713           stackmap_data = parse_stackmap_table(cfs, code_attribute_length, _need_verify, CHECK_NULL);
2714           stackmap_data_length = code_attribute_length;
2715           parsed_stackmap_attribute = true;
2716         } else {
2717           // Skip unknown attributes
2718           cfs-&gt;skip_u1(code_attribute_length, CHECK_NULL);
2719         }
2720       }
2721       // check method attribute length
2722       if (_need_verify) {
2723         guarantee_property(method_attribute_length == calculated_attribute_length,
2724                            &quot;Code segment has wrong length in class file %s&quot;,
2725                            CHECK_NULL);
2726       }
2727     } else if (method_attribute_name == vmSymbols::tag_exceptions()) {
2728       // Parse Exceptions attribute
2729       if (parsed_checked_exceptions_attribute) {
2730         classfile_parse_error(&quot;Multiple Exceptions attributes in class file %s&quot;,
2731                               CHECK_NULL);
2732       }
2733       parsed_checked_exceptions_attribute = true;
2734       checked_exceptions_start =
2735             parse_checked_exceptions(cfs,
2736                                      &amp;checked_exceptions_length,
2737                                      method_attribute_length,
2738                                      CHECK_NULL);
2739     } else if (method_attribute_name == vmSymbols::tag_method_parameters()) {
2740       // reject multiple method parameters
2741       if (method_parameters_seen) {
2742         classfile_parse_error(&quot;Multiple MethodParameters attributes in class file %s&quot;,
2743                               CHECK_NULL);
2744       }
2745       method_parameters_seen = true;
2746       method_parameters_length = cfs-&gt;get_u1_fast();
2747       const u2 real_length = (method_parameters_length * 4u) + 1u;
2748       if (method_attribute_length != real_length) {
2749         classfile_parse_error(
2750           &quot;Invalid MethodParameters method attribute length %u in class file&quot;,
2751           method_attribute_length, CHECK_NULL);
2752       }
2753       method_parameters_data = cfs-&gt;current();
2754       cfs-&gt;skip_u2_fast(method_parameters_length);
2755       cfs-&gt;skip_u2_fast(method_parameters_length);
2756       // ignore this attribute if it cannot be reflected
2757       if (!SystemDictionary::Parameter_klass_loaded())
2758         method_parameters_length = -1;
2759     } else if (method_attribute_name == vmSymbols::tag_synthetic()) {
2760       if (method_attribute_length != 0) {
2761         classfile_parse_error(
2762           &quot;Invalid Synthetic method attribute length %u in class file %s&quot;,
2763           method_attribute_length, CHECK_NULL);
2764       }
2765       // Should we check that there hasn&#39;t already been a synthetic attribute?
2766       access_flags.set_is_synthetic();
2767     } else if (method_attribute_name == vmSymbols::tag_deprecated()) { // 4276120
2768       if (method_attribute_length != 0) {
2769         classfile_parse_error(
2770           &quot;Invalid Deprecated method attribute length %u in class file %s&quot;,
2771           method_attribute_length, CHECK_NULL);
2772       }
2773     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
2774       if (method_attribute_name == vmSymbols::tag_signature()) {
2775         if (generic_signature_index != 0) {
2776           classfile_parse_error(
2777             &quot;Multiple Signature attributes for method in class file %s&quot;,
2778             CHECK_NULL);
2779         }
2780         if (method_attribute_length != 2) {
2781           classfile_parse_error(
2782             &quot;Invalid Signature attribute length %u in class file %s&quot;,
2783             method_attribute_length, CHECK_NULL);
2784         }
2785         generic_signature_index = parse_generic_signature_attribute(cfs, CHECK_NULL);
2786       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
2787         if (runtime_visible_annotations != NULL) {
2788           classfile_parse_error(
2789             &quot;Multiple RuntimeVisibleAnnotations attributes for method in class file %s&quot;,
2790             CHECK_NULL);
2791         }
2792         runtime_visible_annotations_length = method_attribute_length;
2793         runtime_visible_annotations = cfs-&gt;current();
2794         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
2795         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK_NULL);
2796         parse_annotations(cp,
2797                           runtime_visible_annotations,
2798                           runtime_visible_annotations_length,
2799                           &amp;parsed_annotations,
2800                           _loader_data,
2801                           CHECK_NULL);
2802         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
2803       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
2804         if (runtime_invisible_annotations_exists) {
2805           classfile_parse_error(
2806             &quot;Multiple RuntimeInvisibleAnnotations attributes for method in class file %s&quot;,
2807             CHECK_NULL);
2808         }
2809         runtime_invisible_annotations_exists = true;
2810         if (PreserveAllAnnotations) {
2811           runtime_invisible_annotations_length = method_attribute_length;
2812           runtime_invisible_annotations = cfs-&gt;current();
2813           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
2814         }
2815         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2816       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_parameter_annotations()) {
2817         if (runtime_visible_parameter_annotations != NULL) {
2818           classfile_parse_error(
2819             &quot;Multiple RuntimeVisibleParameterAnnotations attributes for method in class file %s&quot;,
2820             CHECK_NULL);
2821         }
2822         runtime_visible_parameter_annotations_length = method_attribute_length;
2823         runtime_visible_parameter_annotations = cfs-&gt;current();
2824         assert(runtime_visible_parameter_annotations != NULL, &quot;null visible parameter annotations&quot;);
2825         cfs-&gt;skip_u1(runtime_visible_parameter_annotations_length, CHECK_NULL);
2826       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_parameter_annotations()) {
2827         if (runtime_invisible_parameter_annotations_exists) {
2828           classfile_parse_error(
2829             &quot;Multiple RuntimeInvisibleParameterAnnotations attributes for method in class file %s&quot;,
2830             CHECK_NULL);
2831         }
2832         runtime_invisible_parameter_annotations_exists = true;
2833         if (PreserveAllAnnotations) {
2834           runtime_invisible_parameter_annotations_length = method_attribute_length;
2835           runtime_invisible_parameter_annotations = cfs-&gt;current();
2836           assert(runtime_invisible_parameter_annotations != NULL,
2837             &quot;null invisible parameter annotations&quot;);
2838         }
2839         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2840       } else if (method_attribute_name == vmSymbols::tag_annotation_default()) {
2841         if (annotation_default != NULL) {
2842           classfile_parse_error(
2843             &quot;Multiple AnnotationDefault attributes for method in class file %s&quot;,
2844             CHECK_NULL);
2845         }
2846         annotation_default_length = method_attribute_length;
2847         annotation_default = cfs-&gt;current();
2848         assert(annotation_default != NULL, &quot;null annotation default&quot;);
2849         cfs-&gt;skip_u1(annotation_default_length, CHECK_NULL);
2850       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
2851         if (runtime_visible_type_annotations != NULL) {
2852           classfile_parse_error(
2853             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for method in class file %s&quot;,
2854             CHECK_NULL);
2855         }
2856         runtime_visible_type_annotations_length = method_attribute_length;
2857         runtime_visible_type_annotations = cfs-&gt;current();
2858         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
2859         // No need for the VM to parse Type annotations
2860         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK_NULL);
2861       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
2862         if (runtime_invisible_type_annotations_exists) {
2863           classfile_parse_error(
2864             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for method in class file %s&quot;,
2865             CHECK_NULL);
2866         } else {
2867           runtime_invisible_type_annotations_exists = true;
2868         }
2869         if (PreserveAllAnnotations) {
2870           runtime_invisible_type_annotations_length = method_attribute_length;
2871           runtime_invisible_type_annotations = cfs-&gt;current();
2872           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
2873         }
2874         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2875       } else {
2876         // Skip unknown attributes
2877         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2878       }
2879     } else {
2880       // Skip unknown attributes
2881       cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2882     }
2883   }
2884 
2885   if (linenumber_table != NULL) {
2886     linenumber_table-&gt;write_terminator();
2887     linenumber_table_length = linenumber_table-&gt;position();
2888   }
2889 
2890   // Make sure there&#39;s at least one Code attribute in non-native/non-abstract method
2891   if (_need_verify) {
2892     guarantee_property(access_flags.is_native() ||
2893                        access_flags.is_abstract() ||
2894                        parsed_code_attribute,
2895                        &quot;Absent Code attribute in method that is not native or abstract in class file %s&quot;,
2896                        CHECK_NULL);
2897   }
2898 
2899   // All sizing information for a Method* is finally available, now create it
2900   InlineTableSizes sizes(
2901       total_lvt_length,
2902       linenumber_table_length,
2903       exception_table_length,
2904       checked_exceptions_length,
2905       method_parameters_length,
2906       generic_signature_index,
2907       runtime_visible_annotations_length +
2908            runtime_invisible_annotations_length,
2909       runtime_visible_parameter_annotations_length +
2910            runtime_invisible_parameter_annotations_length,
2911       runtime_visible_type_annotations_length +
2912            runtime_invisible_type_annotations_length,
2913       annotation_default_length,
2914       0);
2915 
2916   Method* const m = Method::allocate(_loader_data,
2917                                      code_length,
2918                                      access_flags,
2919                                      &amp;sizes,
2920                                      ConstMethod::NORMAL,
2921                                      CHECK_NULL);
2922 
2923   ClassLoadingService::add_class_method_size(m-&gt;size()*wordSize);
2924 
2925   // Fill in information from fixed part (access_flags already set)
2926   m-&gt;set_constants(_cp);
2927   m-&gt;set_name_index(name_index);
2928   m-&gt;set_signature_index(signature_index);
2929   m-&gt;compute_from_signature(cp-&gt;symbol_at(signature_index));
2930   assert(args_size &lt; 0 || args_size == m-&gt;size_of_parameters(), &quot;&quot;);
2931 
2932   // Fill in code attribute information
2933   m-&gt;set_max_stack(max_stack);
2934   m-&gt;set_max_locals(max_locals);
2935   if (stackmap_data != NULL) {
2936     m-&gt;constMethod()-&gt;copy_stackmap_data(_loader_data,
2937                                          (u1*)stackmap_data,
2938                                          stackmap_data_length,
2939                                          CHECK_NULL);
2940   }
2941 
2942   // Copy byte codes
2943   m-&gt;set_code((u1*)code_start);
2944 
2945   // Copy line number table
2946   if (linenumber_table != NULL) {
2947     memcpy(m-&gt;compressed_linenumber_table(),
2948            linenumber_table-&gt;buffer(),
2949            linenumber_table_length);
2950   }
2951 
2952   // Copy exception table
2953   if (exception_table_length &gt; 0) {
2954     Copy::conjoint_swap_if_needed&lt;Endian::JAVA&gt;(exception_table_start,
2955                                                 m-&gt;exception_table_start(),
2956                                                 exception_table_length * sizeof(ExceptionTableElement),
2957                                                 sizeof(u2));
2958   }
2959 
2960   // Copy method parameters
2961   if (method_parameters_length &gt; 0) {
2962     MethodParametersElement* elem = m-&gt;constMethod()-&gt;method_parameters_start();
2963     for (int i = 0; i &lt; method_parameters_length; i++) {
2964       elem[i].name_cp_index = Bytes::get_Java_u2((address)method_parameters_data);
2965       method_parameters_data += 2;
2966       elem[i].flags = Bytes::get_Java_u2((address)method_parameters_data);
2967       method_parameters_data += 2;
2968     }
2969   }
2970 
2971   // Copy checked exceptions
2972   if (checked_exceptions_length &gt; 0) {
2973     Copy::conjoint_swap_if_needed&lt;Endian::JAVA&gt;(checked_exceptions_start,
2974                                                 m-&gt;checked_exceptions_start(),
2975                                                 checked_exceptions_length * sizeof(CheckedExceptionElement),
2976                                                 sizeof(u2));
2977   }
2978 
2979   // Copy class file LVT&#39;s/LVTT&#39;s into the HotSpot internal LVT.
2980   if (total_lvt_length &gt; 0) {
2981     promoted_flags-&gt;set_has_localvariable_table();
2982     copy_localvariable_table(m-&gt;constMethod(),
2983                              lvt_cnt,
2984                              localvariable_table_length,
2985                              localvariable_table_start,
2986                              lvtt_cnt,
2987                              localvariable_type_table_length,
2988                              localvariable_type_table_start,
2989                              CHECK_NULL);
2990   }
2991 
2992   if (parsed_annotations.has_any_annotations())
2993     parsed_annotations.apply_to(methodHandle(THREAD, m));
2994 
2995   // Copy annotations
2996   copy_method_annotations(m-&gt;constMethod(),
2997                           runtime_visible_annotations,
2998                           runtime_visible_annotations_length,
2999                           runtime_invisible_annotations,
3000                           runtime_invisible_annotations_length,
3001                           runtime_visible_parameter_annotations,
3002                           runtime_visible_parameter_annotations_length,
3003                           runtime_invisible_parameter_annotations,
3004                           runtime_invisible_parameter_annotations_length,
3005                           runtime_visible_type_annotations,
3006                           runtime_visible_type_annotations_length,
3007                           runtime_invisible_type_annotations,
3008                           runtime_invisible_type_annotations_length,
3009                           annotation_default,
3010                           annotation_default_length,
3011                           CHECK_NULL);
3012 
3013   if (name == vmSymbols::finalize_method_name() &amp;&amp;
3014       signature == vmSymbols::void_method_signature()) {
3015     if (m-&gt;is_empty_method()) {
3016       _has_empty_finalizer = true;
3017     } else {
3018       _has_finalizer = true;
3019     }
3020   }
3021   if (name == vmSymbols::object_initializer_name() &amp;&amp;
3022       signature == vmSymbols::void_method_signature() &amp;&amp;
3023       m-&gt;is_vanilla_constructor()) {
3024     _has_vanilla_constructor = true;
3025   }
3026 
3027   NOT_PRODUCT(m-&gt;verify());
3028   return m;
3029 }
3030 
3031 
3032 // The promoted_flags parameter is used to pass relevant access_flags
3033 // from the methods back up to the containing klass. These flag values
3034 // are added to klass&#39;s access_flags.
3035 // Side-effects: populates the _methods field in the parser
3036 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
3037                                     bool is_interface,
3038                                     bool is_value_type,
3039                                     AccessFlags* promoted_flags,
3040                                     bool* has_final_method,
3041                                     bool* declares_nonstatic_concrete_methods,
3042                                     TRAPS) {
3043   assert(cfs != NULL, &quot;invariant&quot;);
3044   assert(promoted_flags != NULL, &quot;invariant&quot;);
3045   assert(has_final_method != NULL, &quot;invariant&quot;);
3046   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
3047 
3048   assert(NULL == _methods, &quot;invariant&quot;);
3049 
3050   cfs-&gt;guarantee_more(2, CHECK);  // length
3051   const u2 length = cfs-&gt;get_u2_fast();
3052   if (length == 0) {
3053     _methods = Universe::the_empty_method_array();
3054   } else {
3055     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
3056                                                    length,
3057                                                    NULL,
3058                                                    CHECK);
3059 
3060     for (int index = 0; index &lt; length; index++) {
3061       Method* method = parse_method(cfs,
3062                                     is_interface,
3063                                     is_value_type,
3064                                     _cp,
3065                                     promoted_flags,
3066                                     CHECK);
3067 
3068       if (method-&gt;is_final()) {
3069         *has_final_method = true;
3070       }
3071       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
3072       // used for interface initialization, and default method inheritance analysis
3073       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
3074         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
3075         *declares_nonstatic_concrete_methods = true;
3076       }
3077       _methods-&gt;at_put(index, method);
3078     }
3079 
3080     if (_need_verify &amp;&amp; length &gt; 1) {
3081       // Check duplicated methods
3082       ResourceMark rm(THREAD);
3083       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
3084         THREAD, NameSigHash*, HASH_ROW_SIZE);
3085       initialize_hashtable(names_and_sigs);
3086       bool dup = false;
3087       const Symbol* name = NULL;
3088       const Symbol* sig = NULL;
3089       {
3090         debug_only(NoSafepointVerifier nsv;)
3091         for (int i = 0; i &lt; length; i++) {
3092           const Method* const m = _methods-&gt;at(i);
3093           name = m-&gt;name();
3094           sig = m-&gt;signature();
3095           // If no duplicates, add name/signature in hashtable names_and_sigs.
3096           if (!put_after_lookup(name, sig, names_and_sigs)) {
3097             dup = true;
3098             break;
3099           }
3100         }
3101       }
3102       if (dup) {
3103         classfile_parse_error(&quot;Duplicate method name \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s&quot;,
3104                                name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);
3105       }
3106     }
3107   }
3108 }
3109 
3110 static const intArray* sort_methods(Array&lt;Method*&gt;* methods) {
3111   const int length = methods-&gt;length();
3112   // If JVMTI original method ordering or sharing is enabled we have to
3113   // remember the original class file ordering.
3114   // We temporarily use the vtable_index field in the Method* to store the
3115   // class file index, so we can read in after calling qsort.
3116   // Put the method ordering in the shared archive.
3117   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {
3118     for (int index = 0; index &lt; length; index++) {
3119       Method* const m = methods-&gt;at(index);
3120       assert(!m-&gt;valid_vtable_index(), &quot;vtable index should not be set&quot;);
3121       m-&gt;set_vtable_index(index);
3122     }
3123   }
3124   // Sort method array by ascending method name (for faster lookups &amp; vtable construction)
3125   // Note that the ordering is not alphabetical, see Symbol::fast_compare
3126   Method::sort_methods(methods);
3127 
3128   intArray* method_ordering = NULL;
3129   // If JVMTI original method ordering or sharing is enabled construct int
3130   // array remembering the original ordering
3131   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {
3132     method_ordering = new intArray(length, length, -1);
3133     for (int index = 0; index &lt; length; index++) {
3134       Method* const m = methods-&gt;at(index);
3135       const int old_index = m-&gt;vtable_index();
3136       assert(old_index &gt;= 0 &amp;&amp; old_index &lt; length, &quot;invalid method index&quot;);
3137       method_ordering-&gt;at_put(index, old_index);
3138       m-&gt;set_vtable_index(Method::invalid_vtable_index);
3139     }
3140   }
3141   return method_ordering;
3142 }
3143 
3144 // Parse generic_signature attribute for methods and fields
3145 u2 ClassFileParser::parse_generic_signature_attribute(const ClassFileStream* const cfs,
3146                                                       TRAPS) {
3147   assert(cfs != NULL, &quot;invariant&quot;);
3148 
3149   cfs-&gt;guarantee_more(2, CHECK_0);  // generic_signature_index
3150   const u2 generic_signature_index = cfs-&gt;get_u2_fast();
3151   check_property(
3152     valid_symbol_at(generic_signature_index),
3153     &quot;Invalid Signature attribute at constant pool index %u in class file %s&quot;,
3154     generic_signature_index, CHECK_0);
3155   return generic_signature_index;
3156 }
3157 
3158 void ClassFileParser::parse_classfile_sourcefile_attribute(const ClassFileStream* const cfs,
3159                                                            TRAPS) {
3160 
3161   assert(cfs != NULL, &quot;invariant&quot;);
3162 
3163   cfs-&gt;guarantee_more(2, CHECK);  // sourcefile_index
3164   const u2 sourcefile_index = cfs-&gt;get_u2_fast();
3165   check_property(
3166     valid_symbol_at(sourcefile_index),
3167     &quot;Invalid SourceFile attribute at constant pool index %u in class file %s&quot;,
3168     sourcefile_index, CHECK);
3169   set_class_sourcefile_index(sourcefile_index);
3170 }
3171 
3172 void ClassFileParser::parse_classfile_source_debug_extension_attribute(const ClassFileStream* const cfs,
3173                                                                        int length,
3174                                                                        TRAPS) {
3175   assert(cfs != NULL, &quot;invariant&quot;);
3176 
3177   const u1* const sde_buffer = cfs-&gt;current();
3178   assert(sde_buffer != NULL, &quot;null sde buffer&quot;);
3179 
3180   // Don&#39;t bother storing it if there is no way to retrieve it
3181   if (JvmtiExport::can_get_source_debug_extension()) {
3182     assert((length+1) &gt; length, &quot;Overflow checking&quot;);
3183     u1* const sde = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, u1, length+1);
3184     for (int i = 0; i &lt; length; i++) {
3185       sde[i] = sde_buffer[i];
3186     }
3187     sde[length] = &#39;\0&#39;;
3188     set_class_sde_buffer((const char*)sde, length);
3189   }
3190   // Got utf8 string, set stream position forward
3191   cfs-&gt;skip_u1(length, CHECK);
3192 }
3193 
3194 
3195 // Inner classes can be static, private or protected (classic VM does this)
3196 #define RECOGNIZED_INNER_CLASS_MODIFIERS ( JVM_RECOGNIZED_CLASS_MODIFIERS | \
3197                                            JVM_ACC_PRIVATE |                \
3198                                            JVM_ACC_PROTECTED |              \
3199                                            JVM_ACC_STATIC                   \
3200                                          )
3201 
3202 // Return number of classes in the inner classes attribute table
3203 u2 ClassFileParser::parse_classfile_inner_classes_attribute(const ClassFileStream* const cfs,
3204                                                             const u1* const inner_classes_attribute_start,
3205                                                             bool parsed_enclosingmethod_attribute,
3206                                                             u2 enclosing_method_class_index,
3207                                                             u2 enclosing_method_method_index,
3208                                                             TRAPS) {
3209   const u1* const current_mark = cfs-&gt;current();
3210   u2 length = 0;
3211   if (inner_classes_attribute_start != NULL) {
3212     cfs-&gt;set_current(inner_classes_attribute_start);
3213     cfs-&gt;guarantee_more(2, CHECK_0);  // length
3214     length = cfs-&gt;get_u2_fast();
3215   }
3216 
3217   // 4-tuples of shorts of inner classes data and 2 shorts of enclosing
3218   // method data:
3219   //   [inner_class_info_index,
3220   //    outer_class_info_index,
3221   //    inner_name_index,
3222   //    inner_class_access_flags,
3223   //    ...
3224   //    enclosing_method_class_index,
3225   //    enclosing_method_method_index]
3226   const int size = length * 4 + (parsed_enclosingmethod_attribute ? 2 : 0);
3227   Array&lt;u2&gt;* const inner_classes = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);
3228   _inner_classes = inner_classes;
3229 
3230   int index = 0;
3231   cfs-&gt;guarantee_more(8 * length, CHECK_0);  // 4-tuples of u2
3232   for (int n = 0; n &lt; length; n++) {
3233     // Inner class index
3234     const u2 inner_class_info_index = cfs-&gt;get_u2_fast();
3235     check_property(
3236       valid_klass_reference_at(inner_class_info_index),
3237       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3238       inner_class_info_index, CHECK_0);
3239     // Outer class index
3240     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3241     check_property(
3242       outer_class_info_index == 0 ||
3243         valid_klass_reference_at(outer_class_info_index),
3244       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3245       outer_class_info_index, CHECK_0);
3246     // Inner class name
3247     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3248     check_property(
3249       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3250       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3251       inner_name_index, CHECK_0);
3252     if (_need_verify) {
3253       guarantee_property(inner_class_info_index != outer_class_info_index,
3254                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3255     }
3256 
3257     jint recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;
3258     // JVM_ACC_MODULE is defined in JDK-9 and later.
3259     if (_major_version &gt;= JAVA_9_VERSION) {
3260       recognized_modifiers |= JVM_ACC_MODULE;
3261     }
3262     // JVM_ACC_VALUE is defined for class file version 55 and later
3263     if (supports_value_types()) {
3264       recognized_modifiers |= JVM_ACC_VALUE;
3265     }
3266 
3267     // Access flags
3268     jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;
3269 
3270     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3271       // Set abstract bit for old class files for backward compatibility
3272       flags |= JVM_ACC_ABSTRACT;
3273     }
3274     verify_legal_class_modifiers(flags, CHECK_0);
3275     AccessFlags inner_access_flags(flags);
3276 
3277     inner_classes-&gt;at_put(index++, inner_class_info_index);
3278     inner_classes-&gt;at_put(index++, outer_class_info_index);
3279     inner_classes-&gt;at_put(index++, inner_name_index);
3280     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3281   }
3282 
3283   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3284   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3285     for(int i = 0; i &lt; length * 4; i += 4) {
3286       for(int j = i + 4; j &lt; length * 4; j += 4) {
3287         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3288                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3289                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
3290                             inner_classes-&gt;at(i+3) != inner_classes-&gt;at(j+3)),
3291                             &quot;Duplicate entry in InnerClasses in class file %s&quot;,
3292                             CHECK_0);
3293       }
3294     }
3295   }
3296 
3297   // Set EnclosingMethod class and method indexes.
3298   if (parsed_enclosingmethod_attribute) {
3299     inner_classes-&gt;at_put(index++, enclosing_method_class_index);
3300     inner_classes-&gt;at_put(index++, enclosing_method_method_index);
3301   }
3302   assert(index == size, &quot;wrong size&quot;);
3303 
3304   // Restore buffer&#39;s current position.
3305   cfs-&gt;set_current(current_mark);
3306 
3307   return length;
3308 }
3309 
3310 u2 ClassFileParser::parse_classfile_nest_members_attribute(const ClassFileStream* const cfs,
3311                                                            const u1* const nest_members_attribute_start,
3312                                                            TRAPS) {
3313   const u1* const current_mark = cfs-&gt;current();
3314   u2 length = 0;
3315   if (nest_members_attribute_start != NULL) {
3316     cfs-&gt;set_current(nest_members_attribute_start);
3317     cfs-&gt;guarantee_more(2, CHECK_0);  // length
3318     length = cfs-&gt;get_u2_fast();
3319   }
3320   const int size = length;
3321   Array&lt;u2&gt;* const nest_members = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);
3322   _nest_members = nest_members;
3323 
3324   int index = 0;
3325   cfs-&gt;guarantee_more(2 * length, CHECK_0);
3326   for (int n = 0; n &lt; length; n++) {
3327     const u2 class_info_index = cfs-&gt;get_u2_fast();
3328     check_property(
3329       valid_klass_reference_at(class_info_index),
3330       &quot;Nest member class_info_index %u has bad constant type in class file %s&quot;,
3331       class_info_index, CHECK_0);
3332     nest_members-&gt;at_put(index++, class_info_index);
3333   }
3334   assert(index == size, &quot;wrong size&quot;);
3335 
3336   // Restore buffer&#39;s current position.
3337   cfs-&gt;set_current(current_mark);
3338 
3339   return length;
3340 }
3341 
3342 //  Record {
3343 //    u2 attribute_name_index;
3344 //    u4 attribute_length;
3345 //    u2 components_count;
3346 //    component_info components[components_count];
3347 //  }
3348 //  component_info {
3349 //    u2 name_index;
3350 //    u2 descriptor_index
3351 //    u2 attributes_count;
3352 //    attribute_info_attributes[attributes_count];
3353 //  }
3354 u2 ClassFileParser::parse_classfile_record_attribute(const ClassFileStream* const cfs,
3355                                                      const ConstantPool* cp,
3356                                                      const u1* const record_attribute_start,
3357                                                      TRAPS) {
3358   const u1* const current_mark = cfs-&gt;current();
3359   int components_count = 0;
3360   unsigned int calculate_attr_size = 0;
3361   if (record_attribute_start != NULL) {
3362     cfs-&gt;set_current(record_attribute_start);
3363     cfs-&gt;guarantee_more(2, CHECK_0);  // num of components
3364     components_count = (int)cfs-&gt;get_u2_fast();
3365     calculate_attr_size = 2;
3366   }
3367 
3368   Array&lt;RecordComponent*&gt;* const record_components =
3369     MetadataFactory::new_array&lt;RecordComponent*&gt;(_loader_data, components_count, NULL, CHECK_0);
3370   _record_components = record_components;
3371 
3372   for (int x = 0; x &lt; components_count; x++) {
3373     cfs-&gt;guarantee_more(6, CHECK_0); // name_index, descriptor_index, attributes_count
3374 
3375     const u2 name_index = cfs-&gt;get_u2_fast();
3376     check_property(valid_symbol_at(name_index),
3377       &quot;Invalid constant pool index %u for name in Record attribute in class file %s&quot;,
3378       name_index, CHECK_0);
3379     const Symbol* const name = cp-&gt;symbol_at(name_index);
3380     verify_legal_field_name(name, CHECK_0);
3381 
3382     const u2 descriptor_index = cfs-&gt;get_u2_fast();
3383     check_property(valid_symbol_at(descriptor_index),
3384       &quot;Invalid constant pool index %u for descriptor in Record attribute in class file %s&quot;,
3385       descriptor_index, CHECK_0);
3386     const Symbol* const descr = cp-&gt;symbol_at(descriptor_index);
3387     verify_legal_field_signature(name, descr, CHECK_0);
3388 
3389     const u2 attributes_count = cfs-&gt;get_u2_fast();
3390     calculate_attr_size += 6;
3391     u2 generic_sig_index = 0;
3392     const u1* runtime_visible_annotations = NULL;
3393     int runtime_visible_annotations_length = 0;
3394     const u1* runtime_invisible_annotations = NULL;
3395     int runtime_invisible_annotations_length = 0;
3396     bool runtime_invisible_annotations_exists = false;
3397     const u1* runtime_visible_type_annotations = NULL;
3398     int runtime_visible_type_annotations_length = 0;
3399     const u1* runtime_invisible_type_annotations = NULL;
3400     int runtime_invisible_type_annotations_length = 0;
3401     bool runtime_invisible_type_annotations_exists = false;
3402 
3403     // Expected attributes for record components are Signature, Runtime(In)VisibleAnnotations,
3404     // and Runtime(In)VisibleTypeAnnotations.  Other attributes are ignored.
3405     for (int y = 0; y &lt; attributes_count; y++) {
3406       cfs-&gt;guarantee_more(6, CHECK_0);  // attribute_name_index, attribute_length
3407       const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3408       const u4 attribute_length = cfs-&gt;get_u4_fast();
3409       calculate_attr_size += 6;
3410       check_property(
3411         valid_symbol_at(attribute_name_index),
3412         &quot;Invalid Record attribute name index %u in class file %s&quot;,
3413         attribute_name_index, CHECK_0);
3414 
3415       const Symbol* const attribute_name = cp-&gt;symbol_at(attribute_name_index);
3416       if (attribute_name == vmSymbols::tag_signature()) {
3417         if (generic_sig_index != 0) {
3418           classfile_parse_error(
3419             &quot;Multiple Signature attributes for Record component in class file %s&quot;,
3420             CHECK_0);
3421         }
3422         if (attribute_length != 2) {
3423           classfile_parse_error(
3424             &quot;Invalid Signature attribute length %u in Record component in class file %s&quot;,
3425             attribute_length, CHECK_0);
3426         }
3427         generic_sig_index = parse_generic_signature_attribute(cfs, CHECK_0);
3428 
3429       } else if (attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
3430         if (runtime_visible_annotations != NULL) {
3431           classfile_parse_error(
3432             &quot;Multiple RuntimeVisibleAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3433         }
3434         runtime_visible_annotations_length = attribute_length;
3435         runtime_visible_annotations = cfs-&gt;current();
3436 
3437         assert(runtime_visible_annotations != NULL, &quot;null record component visible annotation&quot;);
3438         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK_0);
3439         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
3440 
3441       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
3442         if (runtime_invisible_annotations_exists) {
3443           classfile_parse_error(
3444             &quot;Multiple RuntimeInvisibleAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3445         }
3446         runtime_invisible_annotations_exists = true;
3447         if (PreserveAllAnnotations) {
3448           runtime_invisible_annotations_length = attribute_length;
3449           runtime_invisible_annotations = cfs-&gt;current();
3450           assert(runtime_invisible_annotations != NULL, &quot;null record component invisible annotation&quot;);
3451         }
3452         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3453 
3454       } else if (attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
3455         if (runtime_visible_type_annotations != NULL) {
3456           classfile_parse_error(
3457             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3458         }
3459         runtime_visible_type_annotations_length = attribute_length;
3460         runtime_visible_type_annotations = cfs-&gt;current();
3461 
3462         assert(runtime_visible_type_annotations != NULL, &quot;null record component visible type annotation&quot;);
3463         cfs-&gt;guarantee_more(runtime_visible_type_annotations_length, CHECK_0);
3464         cfs-&gt;skip_u1_fast(runtime_visible_type_annotations_length);
3465 
3466       } else if (attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
3467         if (runtime_invisible_type_annotations_exists) {
3468           classfile_parse_error(
3469             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3470         }
3471         runtime_invisible_type_annotations_exists = true;
3472         if (PreserveAllAnnotations) {
3473           runtime_invisible_type_annotations_length = attribute_length;
3474           runtime_invisible_type_annotations = cfs-&gt;current();
3475           assert(runtime_invisible_type_annotations != NULL, &quot;null record component invisible type annotation&quot;);
3476         }
3477         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3478 
3479       } else {
3480         // Skip unknown attributes
3481         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3482       }
3483       calculate_attr_size += attribute_length;
3484     } // End of attributes For loop
3485 
3486     AnnotationArray* annotations = assemble_annotations(runtime_visible_annotations,
3487                                                         runtime_visible_annotations_length,
3488                                                         runtime_invisible_annotations,
3489                                                         runtime_invisible_annotations_length,
3490                                                         CHECK_0);
3491     AnnotationArray* type_annotations = assemble_annotations(runtime_visible_type_annotations,
3492                                                              runtime_visible_type_annotations_length,
3493                                                              runtime_invisible_type_annotations,
3494                                                              runtime_invisible_type_annotations_length,
3495                                                              CHECK_0);
3496 
3497     RecordComponent* record_component =
3498       RecordComponent::allocate(_loader_data, name_index, descriptor_index,
3499                                 attributes_count, generic_sig_index,
3500                                 annotations, type_annotations, CHECK_0);
3501     record_components-&gt;at_put(x, record_component);
3502   }  // End of component processing loop
3503 
3504   // Restore buffer&#39;s current position.
3505   cfs-&gt;set_current(current_mark);
3506   return calculate_attr_size;
3507 }
3508 
3509 void ClassFileParser::parse_classfile_synthetic_attribute(TRAPS) {
3510   set_class_synthetic_flag(true);
3511 }
3512 
3513 void ClassFileParser::parse_classfile_signature_attribute(const ClassFileStream* const cfs, TRAPS) {
3514   assert(cfs != NULL, &quot;invariant&quot;);
3515 
3516   const u2 signature_index = cfs-&gt;get_u2(CHECK);
3517   check_property(
3518     valid_symbol_at(signature_index),
3519     &quot;Invalid constant pool index %u in Signature attribute in class file %s&quot;,
3520     signature_index, CHECK);
3521   set_class_generic_signature_index(signature_index);
3522 }
3523 
3524 void ClassFileParser::parse_classfile_bootstrap_methods_attribute(const ClassFileStream* const cfs,
3525                                                                   ConstantPool* cp,
3526                                                                   u4 attribute_byte_length,
3527                                                                   TRAPS) {
3528   assert(cfs != NULL, &quot;invariant&quot;);
3529   assert(cp != NULL, &quot;invariant&quot;);
3530 
3531   const u1* const current_start = cfs-&gt;current();
3532 
3533   guarantee_property(attribute_byte_length &gt;= sizeof(u2),
3534                      &quot;Invalid BootstrapMethods attribute length %u in class file %s&quot;,
3535                      attribute_byte_length,
3536                      CHECK);
3537 
3538   cfs-&gt;guarantee_more(attribute_byte_length, CHECK);
3539 
3540   const int attribute_array_length = cfs-&gt;get_u2_fast();
3541 
3542   guarantee_property(_max_bootstrap_specifier_index &lt; attribute_array_length,
3543                      &quot;Short length on BootstrapMethods in class file %s&quot;,
3544                      CHECK);
3545 
3546 
3547   // The attribute contains a counted array of counted tuples of shorts,
3548   // represending bootstrap specifiers:
3549   //    length*{bootstrap_method_index, argument_count*{argument_index}}
3550   const int operand_count = (attribute_byte_length - sizeof(u2)) / sizeof(u2);
3551   // operand_count = number of shorts in attr, except for leading length
3552 
3553   // The attribute is copied into a short[] array.
3554   // The array begins with a series of short[2] pairs, one for each tuple.
3555   const int index_size = (attribute_array_length * 2);
3556 
3557   Array&lt;u2&gt;* const operands =
3558     MetadataFactory::new_array&lt;u2&gt;(_loader_data, index_size + operand_count, CHECK);
3559 
3560   // Eagerly assign operands so they will be deallocated with the constant
3561   // pool if there is an error.
3562   cp-&gt;set_operands(operands);
3563 
3564   int operand_fill_index = index_size;
3565   const int cp_size = cp-&gt;length();
3566 
3567   for (int n = 0; n &lt; attribute_array_length; n++) {
3568     // Store a 32-bit offset into the header of the operand array.
3569     ConstantPool::operand_offset_at_put(operands, n, operand_fill_index);
3570 
3571     // Read a bootstrap specifier.
3572     cfs-&gt;guarantee_more(sizeof(u2) * 2, CHECK);  // bsm, argc
3573     const u2 bootstrap_method_index = cfs-&gt;get_u2_fast();
3574     const u2 argument_count = cfs-&gt;get_u2_fast();
3575     check_property(
3576       valid_cp_range(bootstrap_method_index, cp_size) &amp;&amp;
3577       cp-&gt;tag_at(bootstrap_method_index).is_method_handle(),
3578       &quot;bootstrap_method_index %u has bad constant type in class file %s&quot;,
3579       bootstrap_method_index,
3580       CHECK);
3581 
3582     guarantee_property((operand_fill_index + 1 + argument_count) &lt; operands-&gt;length(),
3583       &quot;Invalid BootstrapMethods num_bootstrap_methods or num_bootstrap_arguments value in class file %s&quot;,
3584       CHECK);
3585 
3586     operands-&gt;at_put(operand_fill_index++, bootstrap_method_index);
3587     operands-&gt;at_put(operand_fill_index++, argument_count);
3588 
3589     cfs-&gt;guarantee_more(sizeof(u2) * argument_count, CHECK);  // argv[argc]
3590     for (int j = 0; j &lt; argument_count; j++) {
3591       const u2 argument_index = cfs-&gt;get_u2_fast();
3592       check_property(
3593         valid_cp_range(argument_index, cp_size) &amp;&amp;
3594         cp-&gt;tag_at(argument_index).is_loadable_constant(),
3595         &quot;argument_index %u has bad constant type in class file %s&quot;,
3596         argument_index,
3597         CHECK);
3598       operands-&gt;at_put(operand_fill_index++, argument_index);
3599     }
3600   }
3601   guarantee_property(current_start + attribute_byte_length == cfs-&gt;current(),
3602                      &quot;Bad length on BootstrapMethods in class file %s&quot;,
3603                      CHECK);
3604 }
3605 
3606 bool ClassFileParser::supports_records() {
3607   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
3608     _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
3609     Arguments::enable_preview();
3610 }
3611 
3612 void ClassFileParser::parse_classfile_attributes(const ClassFileStream* const cfs,
3613                                                  ConstantPool* cp,
3614                  ClassFileParser::ClassAnnotationCollector* parsed_annotations,
3615                                                  TRAPS) {
3616   assert(cfs != NULL, &quot;invariant&quot;);
3617   assert(cp != NULL, &quot;invariant&quot;);
3618   assert(parsed_annotations != NULL, &quot;invariant&quot;);
3619 
3620   // Set inner classes attribute to default sentinel
3621   _inner_classes = Universe::the_empty_short_array();
3622   // Set nest members attribute to default sentinel
3623   _nest_members = Universe::the_empty_short_array();
3624   cfs-&gt;guarantee_more(2, CHECK);  // attributes_count
3625   u2 attributes_count = cfs-&gt;get_u2_fast();
3626   bool parsed_sourcefile_attribute = false;
3627   bool parsed_innerclasses_attribute = false;
3628   bool parsed_nest_members_attribute = false;
3629   bool parsed_nest_host_attribute = false;
3630   bool parsed_record_attribute = false;
3631   bool parsed_enclosingmethod_attribute = false;
3632   bool parsed_bootstrap_methods_attribute = false;
3633   const u1* runtime_visible_annotations = NULL;
3634   int runtime_visible_annotations_length = 0;
3635   const u1* runtime_invisible_annotations = NULL;
3636   int runtime_invisible_annotations_length = 0;
3637   const u1* runtime_visible_type_annotations = NULL;
3638   int runtime_visible_type_annotations_length = 0;
3639   const u1* runtime_invisible_type_annotations = NULL;
3640   int runtime_invisible_type_annotations_length = 0;
3641   bool runtime_invisible_type_annotations_exists = false;
3642   bool runtime_invisible_annotations_exists = false;
3643   bool parsed_source_debug_ext_annotations_exist = false;
3644   const u1* inner_classes_attribute_start = NULL;
3645   u4  inner_classes_attribute_length = 0;
3646   const u1* value_types_attribute_start = NULL;
3647   u4 value_types_attribute_length = 0;
3648   u2  enclosing_method_class_index = 0;
3649   u2  enclosing_method_method_index = 0;
3650   const u1* nest_members_attribute_start = NULL;
3651   u4  nest_members_attribute_length = 0;
3652   const u1* record_attribute_start = NULL;
3653   u4  record_attribute_length = 0;
3654 
3655   // Iterate over attributes
3656   while (attributes_count--) {
3657     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
3658     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3659     const u4 attribute_length = cfs-&gt;get_u4_fast();
3660     check_property(
3661       valid_symbol_at(attribute_name_index),
3662       &quot;Attribute name has bad constant pool index %u in class file %s&quot;,
3663       attribute_name_index, CHECK);
3664     const Symbol* const tag = cp-&gt;symbol_at(attribute_name_index);
3665     if (tag == vmSymbols::tag_source_file()) {
3666       // Check for SourceFile tag
3667       if (_need_verify) {
3668         guarantee_property(attribute_length == 2, &quot;Wrong SourceFile attribute length in class file %s&quot;, CHECK);
3669       }
3670       if (parsed_sourcefile_attribute) {
3671         classfile_parse_error(&quot;Multiple SourceFile attributes in class file %s&quot;, CHECK);
3672       } else {
3673         parsed_sourcefile_attribute = true;
3674       }
3675       parse_classfile_sourcefile_attribute(cfs, CHECK);
3676     } else if (tag == vmSymbols::tag_source_debug_extension()) {
3677       // Check for SourceDebugExtension tag
3678       if (parsed_source_debug_ext_annotations_exist) {
3679           classfile_parse_error(
3680             &quot;Multiple SourceDebugExtension attributes in class file %s&quot;, CHECK);
3681       }
3682       parsed_source_debug_ext_annotations_exist = true;
3683       parse_classfile_source_debug_extension_attribute(cfs, (int)attribute_length, CHECK);
3684     } else if (tag == vmSymbols::tag_inner_classes()) {
3685       // Check for InnerClasses tag
3686       if (parsed_innerclasses_attribute) {
3687         classfile_parse_error(&quot;Multiple InnerClasses attributes in class file %s&quot;, CHECK);
3688       } else {
3689         parsed_innerclasses_attribute = true;
3690       }
3691       inner_classes_attribute_start = cfs-&gt;current();
3692       inner_classes_attribute_length = attribute_length;
3693       cfs-&gt;skip_u1(inner_classes_attribute_length, CHECK);
3694     } else if (tag == vmSymbols::tag_synthetic()) {
3695       // Check for Synthetic tag
3696       // Shouldn&#39;t we check that the synthetic flags wasn&#39;t already set? - not required in spec
3697       if (attribute_length != 0) {
3698         classfile_parse_error(
3699           &quot;Invalid Synthetic classfile attribute length %u in class file %s&quot;,
3700           attribute_length, CHECK);
3701       }
3702       parse_classfile_synthetic_attribute(CHECK);
3703     } else if (tag == vmSymbols::tag_deprecated()) {
3704       // Check for Deprecatd tag - 4276120
3705       if (attribute_length != 0) {
3706         classfile_parse_error(
3707           &quot;Invalid Deprecated classfile attribute length %u in class file %s&quot;,
3708           attribute_length, CHECK);
3709       }
3710     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
3711       if (tag == vmSymbols::tag_signature()) {
3712         if (_generic_signature_index != 0) {
3713           classfile_parse_error(
3714             &quot;Multiple Signature attributes in class file %s&quot;, CHECK);
3715         }
3716         if (attribute_length != 2) {
3717           classfile_parse_error(
3718             &quot;Wrong Signature attribute length %u in class file %s&quot;,
3719             attribute_length, CHECK);
3720         }
3721         parse_classfile_signature_attribute(cfs, CHECK);
3722       } else if (tag == vmSymbols::tag_runtime_visible_annotations()) {
3723         if (runtime_visible_annotations != NULL) {
3724           classfile_parse_error(
3725             &quot;Multiple RuntimeVisibleAnnotations attributes in class file %s&quot;, CHECK);
3726         }
3727         runtime_visible_annotations_length = attribute_length;
3728         runtime_visible_annotations = cfs-&gt;current();
3729         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
3730         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK);
3731         parse_annotations(cp,
3732                           runtime_visible_annotations,
3733                           runtime_visible_annotations_length,
3734                           parsed_annotations,
3735                           _loader_data,
3736                           CHECK);
3737         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
3738       } else if (tag == vmSymbols::tag_runtime_invisible_annotations()) {
3739         if (runtime_invisible_annotations_exists) {
3740           classfile_parse_error(
3741             &quot;Multiple RuntimeInvisibleAnnotations attributes in class file %s&quot;, CHECK);
3742         }
3743         runtime_invisible_annotations_exists = true;
3744         if (PreserveAllAnnotations) {
3745           runtime_invisible_annotations_length = attribute_length;
3746           runtime_invisible_annotations = cfs-&gt;current();
3747           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
3748         }
3749         cfs-&gt;skip_u1(attribute_length, CHECK);
3750       } else if (tag == vmSymbols::tag_enclosing_method()) {
3751         if (parsed_enclosingmethod_attribute) {
3752           classfile_parse_error(&quot;Multiple EnclosingMethod attributes in class file %s&quot;, CHECK);
3753         } else {
3754           parsed_enclosingmethod_attribute = true;
3755         }
3756         guarantee_property(attribute_length == 4,
3757           &quot;Wrong EnclosingMethod attribute length %u in class file %s&quot;,
3758           attribute_length, CHECK);
3759         cfs-&gt;guarantee_more(4, CHECK);  // class_index, method_index
3760         enclosing_method_class_index  = cfs-&gt;get_u2_fast();
3761         enclosing_method_method_index = cfs-&gt;get_u2_fast();
3762         if (enclosing_method_class_index == 0) {
3763           classfile_parse_error(&quot;Invalid class index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3764         }
3765         // Validate the constant pool indices and types
3766         check_property(valid_klass_reference_at(enclosing_method_class_index),
3767           &quot;Invalid or out-of-bounds class index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3768         if (enclosing_method_method_index != 0 &amp;&amp;
3769             (!cp-&gt;is_within_bounds(enclosing_method_method_index) ||
3770              !cp-&gt;tag_at(enclosing_method_method_index).is_name_and_type())) {
3771           classfile_parse_error(&quot;Invalid or out-of-bounds method index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3772         }
3773       } else if (tag == vmSymbols::tag_bootstrap_methods() &amp;&amp;
3774                  _major_version &gt;= Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
3775         if (parsed_bootstrap_methods_attribute) {
3776           classfile_parse_error(&quot;Multiple BootstrapMethods attributes in class file %s&quot;, CHECK);
3777         }
3778         parsed_bootstrap_methods_attribute = true;
3779         parse_classfile_bootstrap_methods_attribute(cfs, cp, attribute_length, CHECK);
3780       } else if (tag == vmSymbols::tag_runtime_visible_type_annotations()) {
3781         if (runtime_visible_type_annotations != NULL) {
3782           classfile_parse_error(
3783             &quot;Multiple RuntimeVisibleTypeAnnotations attributes in class file %s&quot;, CHECK);
3784         }
3785         runtime_visible_type_annotations_length = attribute_length;
3786         runtime_visible_type_annotations = cfs-&gt;current();
3787         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
3788         // No need for the VM to parse Type annotations
3789         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK);
3790       } else if (tag == vmSymbols::tag_runtime_invisible_type_annotations()) {
3791         if (runtime_invisible_type_annotations_exists) {
3792           classfile_parse_error(
3793             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes in class file %s&quot;, CHECK);
3794         } else {
3795           runtime_invisible_type_annotations_exists = true;
3796         }
3797         if (PreserveAllAnnotations) {
3798           runtime_invisible_type_annotations_length = attribute_length;
3799           runtime_invisible_type_annotations = cfs-&gt;current();
3800           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
3801         }
3802         cfs-&gt;skip_u1(attribute_length, CHECK);
3803       } else if (_major_version &gt;= JAVA_11_VERSION) {
3804         if (tag == vmSymbols::tag_nest_members()) {
3805           // Check for NestMembers tag
3806           if (parsed_nest_members_attribute) {
3807             classfile_parse_error(&quot;Multiple NestMembers attributes in class file %s&quot;, CHECK);
3808           } else {
3809             parsed_nest_members_attribute = true;
3810           }
3811           if (parsed_nest_host_attribute) {
3812             classfile_parse_error(&quot;Conflicting NestHost and NestMembers attributes in class file %s&quot;, CHECK);
3813           }
3814           nest_members_attribute_start = cfs-&gt;current();
3815           nest_members_attribute_length = attribute_length;
3816           cfs-&gt;skip_u1(nest_members_attribute_length, CHECK);
3817         } else if (tag == vmSymbols::tag_nest_host()) {
3818           if (parsed_nest_host_attribute) {
3819             classfile_parse_error(&quot;Multiple NestHost attributes in class file %s&quot;, CHECK);
3820           } else {
3821             parsed_nest_host_attribute = true;
3822           }
3823           if (parsed_nest_members_attribute) {
3824             classfile_parse_error(&quot;Conflicting NestMembers and NestHost attributes in class file %s&quot;, CHECK);
3825           }
3826           if (_need_verify) {
3827             guarantee_property(attribute_length == 2, &quot;Wrong NestHost attribute length in class file %s&quot;, CHECK);
3828           }
3829           cfs-&gt;guarantee_more(2, CHECK);
3830           u2 class_info_index = cfs-&gt;get_u2_fast();
3831           check_property(
3832                          valid_klass_reference_at(class_info_index),
3833                          &quot;Nest-host class_info_index %u has bad constant type in class file %s&quot;,
3834                          class_info_index, CHECK);
3835           _nest_host = class_info_index;
3836         } else if (_major_version &gt;= JAVA_14_VERSION) {
3837           if (tag == vmSymbols::tag_record()) {
3838             // Skip over Record attribute if not supported or if super class is
3839             // not java.lang.Record.
3840             if (supports_records() &amp;&amp;
3841                 cp-&gt;klass_name_at(_super_class_index) == vmSymbols::java_lang_Record()) {
3842               if (parsed_record_attribute) {
3843                 classfile_parse_error(&quot;Multiple Record attributes in class file %s&quot;, CHECK);
3844               }
3845               // Check that class is final and not abstract.
3846               if (!_access_flags.is_final() || _access_flags.is_abstract()) {
3847                 classfile_parse_error(&quot;Record attribute in non-final or abstract class file %s&quot;, CHECK);
3848               }
3849               parsed_record_attribute = true;
3850               record_attribute_start = cfs-&gt;current();
3851               record_attribute_length = attribute_length;
3852             } else if (log_is_enabled(Info, class, record)) {
3853               // Log why the Record attribute was ignored.  Note that if the
3854               // class file version is JVM_CLASSFILE_MAJOR_VERSION.65535 and
3855               // --enable-preview wasn&#39;t specified then a java.lang.UnsupportedClassVersionError
3856               // exception would have been thrown.
3857               ResourceMark rm(THREAD);
3858               if (supports_records()) {
3859                 log_info(class, record)(
3860                   &quot;Ignoring Record attribute in class %s because super type is not java.lang.Record&quot;,
3861                   _class_name-&gt;as_C_string());
3862               } else {
3863                 log_info(class, record)(
3864                   &quot;Ignoring Record attribute in class %s because class file version is not %d.65535&quot;,
3865                    _class_name-&gt;as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);
3866               }
3867             }
3868             cfs-&gt;skip_u1(attribute_length, CHECK);
3869           } else {
3870             // Unknown attribute
3871             cfs-&gt;skip_u1(attribute_length, CHECK);
3872           }
3873         } else {
3874           // Unknown attribute
3875           cfs-&gt;skip_u1(attribute_length, CHECK);
3876         }
3877       } else {
3878         // Unknown attribute
3879         cfs-&gt;skip_u1(attribute_length, CHECK);
3880       }
3881     } else {
3882       // Unknown attribute
3883       cfs-&gt;skip_u1(attribute_length, CHECK);
3884     }
3885   }
3886   _class_annotations = assemble_annotations(runtime_visible_annotations,
3887                                             runtime_visible_annotations_length,
3888                                             runtime_invisible_annotations,
3889                                             runtime_invisible_annotations_length,
3890                                             CHECK);
3891   _class_type_annotations = assemble_annotations(runtime_visible_type_annotations,
3892                                                  runtime_visible_type_annotations_length,
3893                                                  runtime_invisible_type_annotations,
3894                                                  runtime_invisible_type_annotations_length,
3895                                                  CHECK);
3896 
3897   if (parsed_innerclasses_attribute || parsed_enclosingmethod_attribute) {
3898     const u2 num_of_classes = parse_classfile_inner_classes_attribute(
3899                             cfs,
3900                             inner_classes_attribute_start,
3901                             parsed_innerclasses_attribute,
3902                             enclosing_method_class_index,
3903                             enclosing_method_method_index,
3904                             CHECK);
3905     if (parsed_innerclasses_attribute &amp;&amp; _need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3906       guarantee_property(
3907         inner_classes_attribute_length == sizeof(num_of_classes) + 4 * sizeof(u2) * num_of_classes,
3908         &quot;Wrong InnerClasses attribute length in class file %s&quot;, CHECK);
3909     }
3910   }
3911 
3912   if (parsed_nest_members_attribute) {
3913     const u2 num_of_classes = parse_classfile_nest_members_attribute(
3914                             cfs,
3915                             nest_members_attribute_start,
3916                             CHECK);
3917     if (_need_verify) {
3918       guarantee_property(
3919         nest_members_attribute_length == sizeof(num_of_classes) + sizeof(u2) * num_of_classes,
3920         &quot;Wrong NestMembers attribute length in class file %s&quot;, CHECK);
3921     }
3922   }
3923 
3924   if (parsed_record_attribute) {
3925     const unsigned int calculated_attr_length = parse_classfile_record_attribute(
3926                             cfs,
3927                             cp,
3928                             record_attribute_start,
3929                             CHECK);
3930     if (_need_verify) {
3931       guarantee_property(record_attribute_length == calculated_attr_length,
3932                          &quot;Record attribute has wrong length in class file %s&quot;,
3933                          CHECK);
3934     }
3935   }
3936 
3937   if (_max_bootstrap_specifier_index &gt;= 0) {
3938     guarantee_property(parsed_bootstrap_methods_attribute,
3939                        &quot;Missing BootstrapMethods attribute in class file %s&quot;, CHECK);
3940   }
3941 }
3942 
3943 void ClassFileParser::apply_parsed_class_attributes(InstanceKlass* k) {
3944   assert(k != NULL, &quot;invariant&quot;);
3945 
3946   if (_synthetic_flag)
3947     k-&gt;set_is_synthetic();
3948   if (_sourcefile_index != 0) {
3949     k-&gt;set_source_file_name_index(_sourcefile_index);
3950   }
3951   if (_generic_signature_index != 0) {
3952     k-&gt;set_generic_signature_index(_generic_signature_index);
3953   }
3954   if (_sde_buffer != NULL) {
3955     k-&gt;set_source_debug_extension(_sde_buffer, _sde_length);
3956   }
3957 }
3958 
3959 // Create the Annotations object that will
3960 // hold the annotations array for the Klass.
3961 void ClassFileParser::create_combined_annotations(TRAPS) {
3962     if (_class_annotations == NULL &amp;&amp;
3963         _class_type_annotations == NULL &amp;&amp;
3964         _fields_annotations == NULL &amp;&amp;
3965         _fields_type_annotations == NULL) {
3966       // Don&#39;t create the Annotations object unnecessarily.
3967       return;
3968     }
3969 
3970     Annotations* const annotations = Annotations::allocate(_loader_data, CHECK);
3971     annotations-&gt;set_class_annotations(_class_annotations);
3972     annotations-&gt;set_class_type_annotations(_class_type_annotations);
3973     annotations-&gt;set_fields_annotations(_fields_annotations);
3974     annotations-&gt;set_fields_type_annotations(_fields_type_annotations);
3975 
3976     // This is the Annotations object that will be
3977     // assigned to InstanceKlass being constructed.
3978     _combined_annotations = annotations;
3979 
3980     // The annotations arrays below has been transfered the
3981     // _combined_annotations so these fields can now be cleared.
3982     _class_annotations       = NULL;
3983     _class_type_annotations  = NULL;
3984     _fields_annotations      = NULL;
3985     _fields_type_annotations = NULL;
3986 }
3987 
3988 // Transfer ownership of metadata allocated to the InstanceKlass.
3989 void ClassFileParser::apply_parsed_class_metadata(
3990                                             InstanceKlass* this_klass,
3991                                             int java_fields_count,
3992                                             TRAPS) {
3993   assert(this_klass != NULL, &quot;invariant&quot;);
3994 
3995   _cp-&gt;set_pool_holder(this_klass);
3996   this_klass-&gt;set_constants(_cp);
3997   this_klass-&gt;set_fields(_fields, java_fields_count);
3998   this_klass-&gt;set_methods(_methods);
3999   this_klass-&gt;set_inner_classes(_inner_classes);
4000   this_klass-&gt;set_nest_members(_nest_members);
4001   this_klass-&gt;set_nest_host_index(_nest_host);
4002   this_klass-&gt;set_local_interfaces(_local_interfaces);
4003   this_klass-&gt;set_annotations(_combined_annotations);
4004   this_klass-&gt;set_record_components(_record_components);
4005   // Delay the setting of _transitive_interfaces until after initialize_supers() in
4006   // fill_instance_klass(). It is because the _transitive_interfaces may be shared with
4007   // its _super. If an OOM occurs while loading the current klass, its _super field
4008   // may not have been set. When GC tries to free the klass, the _transitive_interfaces
4009   // may be deallocated mistakenly in InstanceKlass::deallocate_interfaces(). Subsequent
4010   // dereferences to the deallocated _transitive_interfaces will result in a crash.
4011 
4012   // Clear out these fields so they don&#39;t get deallocated by the destructor
4013   clear_class_metadata();
4014 }
4015 
4016 AnnotationArray* ClassFileParser::assemble_annotations(const u1* const runtime_visible_annotations,
4017                                                        int runtime_visible_annotations_length,
4018                                                        const u1* const runtime_invisible_annotations,
4019                                                        int runtime_invisible_annotations_length,
4020                                                        TRAPS) {
4021   AnnotationArray* annotations = NULL;
4022   if (runtime_visible_annotations != NULL ||
4023       runtime_invisible_annotations != NULL) {
4024     annotations = MetadataFactory::new_array&lt;u1&gt;(_loader_data,
4025                                           runtime_visible_annotations_length +
4026                                           runtime_invisible_annotations_length,
4027                                           CHECK_(annotations));
4028     if (runtime_visible_annotations != NULL) {
4029       for (int i = 0; i &lt; runtime_visible_annotations_length; i++) {
4030         annotations-&gt;at_put(i, runtime_visible_annotations[i]);
4031       }
4032     }
4033     if (runtime_invisible_annotations != NULL) {
4034       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
4035         int append = runtime_visible_annotations_length+i;
4036         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
4037       }
4038     }
4039   }
4040   return annotations;
4041 }
4042 
4043 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
4044                                                         const int super_class_index,
4045                                                         const bool need_verify,
4046                                                         TRAPS) {
4047   assert(cp != NULL, &quot;invariant&quot;);
4048   const InstanceKlass* super_klass = NULL;
4049 
4050   if (super_class_index == 0) {
4051     check_property(_class_name == vmSymbols::java_lang_Object()
4052                    || (_access_flags.get_flags() &amp; JVM_ACC_VALUE),
4053                    &quot;Invalid superclass index %u in class file %s&quot;,
4054                    super_class_index,
4055                    CHECK_NULL);
4056   } else {
4057     check_property(valid_klass_reference_at(super_class_index),
4058                    &quot;Invalid superclass index %u in class file %s&quot;,
4059                    super_class_index,
4060                    CHECK_NULL);
4061     // The class name should be legal because it is checked when parsing constant pool.
4062     // However, make sure it is not an array type.
4063     bool is_array = false;
4064     if (cp-&gt;tag_at(super_class_index).is_klass()) {
4065       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
4066       if (need_verify)
4067         is_array = super_klass-&gt;is_array_klass();
4068     } else if (need_verify) {
4069       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
4070     }
4071     if (need_verify) {
4072       guarantee_property(!is_array,
4073                         &quot;Bad superclass name in class file %s&quot;, CHECK_NULL);
4074     }
4075   }
4076   return super_klass;
4077 }
4078 
4079 #ifndef PRODUCT
4080 static void print_field_layout(const Symbol* name,
4081                                Array&lt;u2&gt;* fields,
4082                                ConstantPool* cp,
4083                                int instance_size,
4084                                int instance_fields_start,
4085                                int instance_fields_end,
4086                                int static_fields_end) {
4087 
4088   assert(name != NULL, &quot;invariant&quot;);
4089 
4090   tty-&gt;print(&quot;%s: field layout\n&quot;, name-&gt;as_klass_external_name());
4091   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_start, &quot;--- instance fields start ---&quot;);
4092   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
4093     if (!fs.access_flags().is_static()) {
4094       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,
4095         fs.offset(),
4096         fs.name()-&gt;as_klass_external_name(),
4097         fs.signature()-&gt;as_klass_external_name());
4098     }
4099   }
4100   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_end, &quot;--- instance fields end ---&quot;);
4101   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_size * wordSize, &quot;--- instance ends ---&quot;);
4102   tty-&gt;print(&quot;  @%3d %s\n&quot;, InstanceMirrorKlass::offset_of_static_fields(), &quot;--- static fields start ---&quot;);
4103   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
4104     if (fs.access_flags().is_static()) {
4105       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,
4106         fs.offset(),
4107         fs.name()-&gt;as_klass_external_name(),
4108         fs.signature()-&gt;as_klass_external_name());
4109     }
4110   }
4111   tty-&gt;print(&quot;  @%3d %s\n&quot;, static_fields_end, &quot;--- static fields end ---&quot;);
4112   tty-&gt;print(&quot;\n&quot;);
4113 }
4114 #endif
4115 
4116 OopMapBlocksBuilder::OopMapBlocksBuilder(unsigned int max_blocks) {
4117   _max_nonstatic_oop_maps = max_blocks;
4118   _nonstatic_oop_map_count = 0;
4119   if (max_blocks == 0) {
4120     _nonstatic_oop_maps = NULL;
4121   } else {
4122     _nonstatic_oop_maps =
4123         NEW_RESOURCE_ARRAY(OopMapBlock, _max_nonstatic_oop_maps);
4124     memset(_nonstatic_oop_maps, 0, sizeof(OopMapBlock) * max_blocks);
4125   }
4126 }
4127 
4128 OopMapBlock* OopMapBlocksBuilder::last_oop_map() const {
4129   assert(_nonstatic_oop_map_count &gt; 0, &quot;Has no oop maps&quot;);
4130   return _nonstatic_oop_maps + (_nonstatic_oop_map_count - 1);
4131 }
4132 
4133 // addition of super oop maps
4134 void OopMapBlocksBuilder::initialize_inherited_blocks(OopMapBlock* blocks, unsigned int nof_blocks) {
4135   assert(nof_blocks &amp;&amp; _nonstatic_oop_map_count == 0 &amp;&amp;
4136          nof_blocks &lt;= _max_nonstatic_oop_maps, &quot;invariant&quot;);
4137 
4138   memcpy(_nonstatic_oop_maps, blocks, sizeof(OopMapBlock) * nof_blocks);
4139   _nonstatic_oop_map_count += nof_blocks;
4140 }
4141 
4142 // collection of oops
4143 void OopMapBlocksBuilder::add(int offset, int count) {
4144   if (_nonstatic_oop_map_count == 0) {
4145     _nonstatic_oop_map_count++;
4146   }
4147   OopMapBlock* nonstatic_oop_map = last_oop_map();
4148   if (nonstatic_oop_map-&gt;count() == 0) {  // Unused map, set it up
4149     nonstatic_oop_map-&gt;set_offset(offset);
4150     nonstatic_oop_map-&gt;set_count(count);
4151   } else if (nonstatic_oop_map-&gt;is_contiguous(offset)) { // contiguous, add
4152     nonstatic_oop_map-&gt;increment_count(count);
4153   } else { // Need a new one...
4154     _nonstatic_oop_map_count++;
4155     assert(_nonstatic_oop_map_count &lt;= _max_nonstatic_oop_maps, &quot;range check&quot;);
4156     nonstatic_oop_map = last_oop_map();
4157     nonstatic_oop_map-&gt;set_offset(offset);
4158     nonstatic_oop_map-&gt;set_count(count);
4159   }
4160 }
4161 
4162 // general purpose copy, e.g. into allocated instanceKlass
4163 void OopMapBlocksBuilder::copy(OopMapBlock* dst) {
4164   if (_nonstatic_oop_map_count != 0) {
4165     memcpy(dst, _nonstatic_oop_maps, sizeof(OopMapBlock) * _nonstatic_oop_map_count);
4166   }
4167 }
4168 
4169 // Sort and compact adjacent blocks
4170 void OopMapBlocksBuilder::compact() {
4171   if (_nonstatic_oop_map_count &lt;= 1) {
4172     return;
4173   }
4174   /*
4175    * Since field layout sneeks in oops before values, we will be able to condense
4176    * blocks. There is potential to compact between super, own refs and values
4177    * containing refs.
4178    *
4179    * Currently compaction is slightly limited due to values being 8 byte aligned.
4180    * This may well change: FixMe if it doesn&#39;t, the code below is fairly general purpose
4181    * and maybe it doesn&#39;t need to be.
4182    */
4183   qsort(_nonstatic_oop_maps, _nonstatic_oop_map_count, sizeof(OopMapBlock),
4184         (_sort_Fn)OopMapBlock::compare_offset);
4185   if (_nonstatic_oop_map_count &lt; 2) {
4186     return;
4187   }
4188 
4189   // Make a temp copy, and iterate through and copy back into the original
4190   ResourceMark rm;
4191   OopMapBlock* oop_maps_copy =
4192       NEW_RESOURCE_ARRAY(OopMapBlock, _nonstatic_oop_map_count);
4193   OopMapBlock* oop_maps_copy_end = oop_maps_copy + _nonstatic_oop_map_count;
4194   copy(oop_maps_copy);
4195   OopMapBlock* nonstatic_oop_map = _nonstatic_oop_maps;
4196   unsigned int new_count = 1;
4197   oop_maps_copy++;
4198   while(oop_maps_copy &lt; oop_maps_copy_end) {
4199     assert(nonstatic_oop_map-&gt;offset() &lt; oop_maps_copy-&gt;offset(), &quot;invariant&quot;);
4200     if (nonstatic_oop_map-&gt;is_contiguous(oop_maps_copy-&gt;offset())) {
4201       nonstatic_oop_map-&gt;increment_count(oop_maps_copy-&gt;count());
4202     } else {
4203       nonstatic_oop_map++;
4204       new_count++;
4205       nonstatic_oop_map-&gt;set_offset(oop_maps_copy-&gt;offset());
4206       nonstatic_oop_map-&gt;set_count(oop_maps_copy-&gt;count());
4207     }
4208     oop_maps_copy++;
4209   }
4210   assert(new_count &lt;= _nonstatic_oop_map_count, &quot;end up with more maps after compact() ?&quot;);
4211   _nonstatic_oop_map_count = new_count;
4212 }
4213 
4214 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4215   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4216   if (_nonstatic_oop_map_count &gt; 0) {
4217     OopMapBlock* map = _nonstatic_oop_maps;
4218     OopMapBlock* last_map = last_oop_map();
4219     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4220     while (map &lt;= last_map) {
4221       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4222                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4223       map++;
4224     }
4225   }
4226 }
4227 
4228 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4229   print_on(st);
4230 }
4231 
4232 void ClassFileParser::throwValueTypeLimitation(THREAD_AND_LOCATION_DECL,
4233                                                const char* msg,
4234                                                const Symbol* name,
4235                                                const Symbol* sig) const {
4236 
4237   ResourceMark rm(THREAD);
4238   if (name == NULL || sig == NULL) {
4239     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,
4240         vmSymbols::java_lang_ClassFormatError(),
4241         &quot;class: %s - %s&quot;, _class_name-&gt;as_C_string(), msg);
4242   }
4243   else {
4244     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,
4245         vmSymbols::java_lang_ClassFormatError(),
4246         &quot;\&quot;%s\&quot; sig: \&quot;%s\&quot; class: %s - %s&quot;, name-&gt;as_C_string(), sig-&gt;as_C_string(),
4247         _class_name-&gt;as_C_string(), msg);
4248   }
4249 }
4250 
4251 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4252 void ClassFileParser::layout_fields(ConstantPool* cp,
4253                                     const FieldAllocationCount* fac,
4254                                     const ClassAnnotationCollector* parsed_annotations,
4255                                     FieldLayoutInfo* info,
4256                                     TRAPS) {
4257 
4258   assert(cp != NULL, &quot;invariant&quot;);
4259 
4260   // Field size and offset computation
4261   int nonstatic_field_size = _super_klass == NULL ? 0 :
4262                                _super_klass-&gt;nonstatic_field_size();
4263   int next_nonstatic_valuetype_offset = 0;
4264   int first_nonstatic_valuetype_offset = 0;
4265 
4266   // Fields that are value types are handled differently depending if they are static or not:
4267   // - static fields are oops
4268   // - non-static fields are embedded
4269 
4270   // Count the contended fields by type.
4271   //
4272   // We ignore static fields, because @Contended is not supported for them.
4273   // The layout code below will also ignore the static fields.
4274   int nonstatic_contended_count = 0;
4275   FieldAllocationCount fac_contended;
4276   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4277     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4278     if (fs.is_contended()) {
4279       fac_contended.count[atype]++;
4280       if (!fs.access_flags().is_static()) {
4281         nonstatic_contended_count++;
4282       }
4283     }
4284   }
4285 
4286 
4287   // Calculate the starting byte offsets
4288   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
4289   // Value types in static fields are not embedded, they are handled with oops
4290   int next_static_double_offset = next_static_oop_offset +
4291                                   ((fac-&gt;count[STATIC_OOP] + fac-&gt;count[STATIC_FLATTENABLE]) * heapOopSize);
4292   if (fac-&gt;count[STATIC_DOUBLE]) {
4293     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4294   }
4295 
4296   int next_static_word_offset   = next_static_double_offset +
4297                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4298   int next_static_short_offset  = next_static_word_offset +
4299                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4300   int next_static_byte_offset   = next_static_short_offset +
4301                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4302 
4303   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4304                                 nonstatic_field_size * heapOopSize;
4305 
4306   // First field of value types is aligned on a long boundary in order to ease
4307   // in-lining of value types (with header removal) in packed arrays and
4308   // flatten value types
4309   int initial_value_type_padding = 0;
4310   if (is_value_type()) {
4311     int old = nonstatic_fields_start;
4312     nonstatic_fields_start = align_up(nonstatic_fields_start, BytesPerLong);
4313     initial_value_type_padding = nonstatic_fields_start - old;
4314   }
4315 
4316   int next_nonstatic_field_offset = nonstatic_fields_start;
4317 
4318   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4319 
4320   // Class is contended, pad before all the fields
4321   if (is_contended_class) {
4322     next_nonstatic_field_offset += ContendedPaddingWidth;
4323   }
4324 
4325   // Temporary value types restrictions
4326   if (is_value_type()) {
4327     if (is_contended_class) {
4328       throwValueTypeLimitation(THREAD_AND_LOCATION, &quot;Value Types do not support @Contended annotation yet&quot;);
4329       return;
4330     }
4331   }
4332 
4333   // Compute the non-contended fields count.
4334   // The packing code below relies on these counts to determine if some field
4335   // can be squeezed into the alignment gap. Contended fields are obviously
4336   // exempt from that.
4337   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4338   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4339   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4340   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4341   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4342 
4343   int static_value_type_count = 0;
4344   int nonstatic_value_type_count = 0;
4345   int* nonstatic_value_type_indexes = NULL;
4346   Klass** nonstatic_value_type_klasses = NULL;
4347   unsigned int value_type_oop_map_count = 0;
4348   int not_flattened_value_types = 0;
<a name="6" id="anc6"></a>
4349 
4350   int max_nonstatic_value_type = fac-&gt;count[NONSTATIC_FLATTENABLE] + 1;
4351 
4352   nonstatic_value_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,
4353                                                               max_nonstatic_value_type);
4354   for (int i = 0; i &lt; max_nonstatic_value_type; i++) {
4355     nonstatic_value_type_indexes[i] = -1;
4356   }
4357   nonstatic_value_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,
4358                                                               max_nonstatic_value_type);
4359 
4360   for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {
4361     if (fs.allocation_type() == STATIC_FLATTENABLE) {
4362       ResourceMark rm;
4363       if (!fs.signature()-&gt;is_Q_signature()) {
4364         THROW(vmSymbols::java_lang_ClassFormatError());
4365       }
4366       static_value_type_count++;
4367     } else if (fs.allocation_type() == NONSTATIC_FLATTENABLE) {
4368       // Pre-resolve the flattenable field and check for value type circularity issues.
4369       ResourceMark rm;
4370       if (!fs.signature()-&gt;is_Q_signature()) {
4371         THROW(vmSymbols::java_lang_ClassFormatError());
4372       }
4373       Klass* klass =
4374         SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
4375                                                             Handle(THREAD, _loader_data-&gt;class_loader()),
4376                                                             _protection_domain, true, CHECK);
4377       assert(klass != NULL, &quot;Sanity check&quot;);
4378       if (!klass-&gt;access_flags().is_value_type()) {
4379         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
4380       }
4381       ValueKlass* vk = ValueKlass::cast(klass);
4382       // Conditions to apply flattening or not should be defined in a single place
<a name="7" id="anc7"></a><span class="line-modified">4383       if ((ValueFieldMaxFlatSize &lt; 0) || (vk-&gt;size_helper() * HeapWordSize) &lt;= ValueFieldMaxFlatSize) {</span>









4384         nonstatic_value_type_indexes[nonstatic_value_type_count] = fs.index();
4385         nonstatic_value_type_klasses[nonstatic_value_type_count] = klass;
4386         nonstatic_value_type_count++;
4387 
4388         ValueKlass* vklass = ValueKlass::cast(klass);
4389         if (vklass-&gt;contains_oops()) {
4390           value_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();
4391         }
4392         fs.set_flattened(true);
<a name="8" id="anc8"></a>


4393       } else {
4394         not_flattened_value_types++;
4395         fs.set_flattened(false);
4396       }
4397     }
4398   }
4399 
4400   // Adjusting non_static_oop_count to take into account not flattened value types;
4401   nonstatic_oop_count += not_flattened_value_types;
4402 
4403   // Total non-static fields count, including every contended field
4404   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4405                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
4406                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_FLATTENABLE];
4407 
4408   const bool super_has_nonstatic_fields =
4409           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4410   const bool has_nonstatic_fields =
4411     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
4412   const bool has_nonstatic_value_fields = nonstatic_value_type_count &gt; 0;
4413 
4414   if (is_value_type() &amp;&amp; (!has_nonstatic_fields)) {
4415     // There are a number of fixes required throughout the type system and JIT
4416     throwValueTypeLimitation(THREAD_AND_LOCATION, &quot;Value Types do not support zero instance size yet&quot;);
4417     return;
4418   }
4419 
4420   // Prepare list of oops for oop map generation.
4421   //
4422   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4423   // regions. offset[i] is the start of the i-th region, which then has
4424   // count[i] oops following. Before we know how many regions are required,
4425   // we pessimistically allocate the maps to fit all the oops into the
4426   // distinct regions.
4427   //
4428   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
4429   int max_oop_map_count =
4430       super_oop_map_count +
4431       fac-&gt;count[NONSTATIC_OOP] +
4432       value_type_oop_map_count +
4433       not_flattened_value_types;
4434 
4435   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
4436   if (super_oop_map_count &gt; 0) {
4437     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
4438                                                     _super_klass-&gt;nonstatic_oop_map_count());
4439   }
4440 
4441   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4442 
4443   bool compact_fields  = true;
4444   bool allocate_oops_first = false;
4445 
4446   // The next classes have predefined hard-coded fields offsets
4447   // (see in JavaClasses::compute_hard_coded_offsets()).
4448   // Use default fields allocation order for them.
4449   if (_loader_data-&gt;class_loader() == NULL &amp;&amp;
4450       (_class_name == vmSymbols::java_lang_ref_Reference() ||
4451        _class_name == vmSymbols::java_lang_Boolean() ||
4452        _class_name == vmSymbols::java_lang_Character() ||
4453        _class_name == vmSymbols::java_lang_Float() ||
4454        _class_name == vmSymbols::java_lang_Double() ||
4455        _class_name == vmSymbols::java_lang_Byte() ||
4456        _class_name == vmSymbols::java_lang_Short() ||
4457        _class_name == vmSymbols::java_lang_Integer() ||
4458        _class_name == vmSymbols::java_lang_Long())) {
4459     allocate_oops_first = true;     // Allocate oops first
4460     compact_fields   = false; // Don&#39;t compact fields
4461   }
4462 
4463   int next_nonstatic_oop_offset = 0;
4464   int next_nonstatic_double_offset = 0;
4465 
4466   // Rearrange fields for a given allocation style
4467   if (allocate_oops_first) {
4468     // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields
4469     next_nonstatic_oop_offset    = next_nonstatic_field_offset;
4470     next_nonstatic_double_offset = next_nonstatic_oop_offset +
4471                                     (nonstatic_oop_count * heapOopSize);
4472   } else {
4473     // Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields
4474     next_nonstatic_double_offset = next_nonstatic_field_offset;
4475   }
4476 
4477   int nonstatic_oop_space_count   = 0;
4478   int nonstatic_word_space_count  = 0;
4479   int nonstatic_short_space_count = 0;
4480   int nonstatic_byte_space_count  = 0;
4481   int nonstatic_oop_space_offset = 0;
4482   int nonstatic_word_space_offset = 0;
4483   int nonstatic_short_space_offset = 0;
4484   int nonstatic_byte_space_offset = 0;
4485 
4486   // Try to squeeze some of the fields into the gaps due to
4487   // long/double alignment.
4488   if (nonstatic_double_count &gt; 0) {
4489     int offset = next_nonstatic_double_offset;
4490     next_nonstatic_double_offset = align_up(offset, BytesPerLong);
4491     if (compact_fields &amp;&amp; offset != next_nonstatic_double_offset) {
4492       // Allocate available fields into the gap before double field.
4493       int length = next_nonstatic_double_offset - offset;
4494       assert(length == BytesPerInt, &quot;&quot;);
4495       nonstatic_word_space_offset = offset;
4496       if (nonstatic_word_count &gt; 0) {
4497         nonstatic_word_count      -= 1;
4498         nonstatic_word_space_count = 1; // Only one will fit
4499         length -= BytesPerInt;
4500         offset += BytesPerInt;
4501       }
4502       nonstatic_short_space_offset = offset;
4503       while (length &gt;= BytesPerShort &amp;&amp; nonstatic_short_count &gt; 0) {
4504         nonstatic_short_count       -= 1;
4505         nonstatic_short_space_count += 1;
4506         length -= BytesPerShort;
4507         offset += BytesPerShort;
4508       }
4509       nonstatic_byte_space_offset = offset;
4510       while (length &gt; 0 &amp;&amp; nonstatic_byte_count &gt; 0) {
4511         nonstatic_byte_count       -= 1;
4512         nonstatic_byte_space_count += 1;
4513         length -= 1;
4514       }
4515       // Allocate oop field in the gap if there are no other fields for that.
4516       nonstatic_oop_space_offset = offset;
4517       if (length &gt;= heapOopSize &amp;&amp; nonstatic_oop_count &gt; 0 &amp;&amp;
4518           !allocate_oops_first) { // when oop fields not first
4519         nonstatic_oop_count      -= 1;
4520         nonstatic_oop_space_count = 1; // Only one will fit
4521         length -= heapOopSize;
4522         offset += heapOopSize;
4523       }
4524     }
4525   }
4526 
4527   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4528                                      (nonstatic_double_count * BytesPerLong);
4529   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4530                                       (nonstatic_word_count * BytesPerInt);
4531   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4532                                      (nonstatic_short_count * BytesPerShort);
4533   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4534                                        nonstatic_byte_count;
4535 
4536   // let oops jump before padding with this allocation style
4537   if (!allocate_oops_first) {
4538     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4539     if( nonstatic_oop_count &gt; 0 ) {
4540       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4541     }
4542     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4543   }
4544 
4545   // Aligning embedded value types
4546   // bug below, the current algorithm to layout embedded value types always put them at the
4547   // end of the layout, which doesn&#39;t match the different allocation policies the VM is
4548   // supposed to provide =&gt; FixMe
4549   // Note also that the current alignment policy is to make each value type starting on a
4550   // 64 bits boundary. This could be optimized later. For instance, it could be nice to
4551   // align value types according to their most constrained internal type.
4552   next_nonstatic_valuetype_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4553   int next_value_type_index = 0;
4554 
4555   // Iterate over fields again and compute correct offsets.
4556   // The field allocation type was temporarily stored in the offset slot.
4557   // oop fields are located before non-oop fields (static and non-static).
4558   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4559 
4560     // skip already laid out fields
4561     if (fs.is_offset_set()) continue;
4562 
4563     // contended instance fields are handled below
4564     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4565 
4566     int real_offset = 0;
4567     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4568 
4569     // pack the rest of the fields
4570     switch (atype) {
4571       // Value types in static fields are handled with oops
4572       case STATIC_FLATTENABLE:   // Fallthrough
4573       case STATIC_OOP:
4574         real_offset = next_static_oop_offset;
4575         next_static_oop_offset += heapOopSize;
4576         break;
4577       case STATIC_BYTE:
4578         real_offset = next_static_byte_offset;
4579         next_static_byte_offset += 1;
4580         break;
4581       case STATIC_SHORT:
4582         real_offset = next_static_short_offset;
4583         next_static_short_offset += BytesPerShort;
4584         break;
4585       case STATIC_WORD:
4586         real_offset = next_static_word_offset;
4587         next_static_word_offset += BytesPerInt;
4588         break;
4589       case STATIC_DOUBLE:
4590         real_offset = next_static_double_offset;
4591         next_static_double_offset += BytesPerLong;
4592         break;
4593       case NONSTATIC_FLATTENABLE:
4594         if (fs.is_flattened()) {
4595           Klass* klass = nonstatic_value_type_klasses[next_value_type_index];
4596           assert(klass != NULL, &quot;Klass should have been loaded and resolved earlier&quot;);
4597           assert(klass-&gt;access_flags().is_value_type(),&quot;Must be a value type&quot;);
4598           ValueKlass* vklass = ValueKlass::cast(klass);
4599           real_offset = next_nonstatic_valuetype_offset;
4600           next_nonstatic_valuetype_offset += (vklass-&gt;size_helper()) * wordSize - vklass-&gt;first_field_offset();
4601           // aligning next value type on a 64 bits boundary
4602           next_nonstatic_valuetype_offset = align_up(next_nonstatic_valuetype_offset, BytesPerLong);
4603           next_value_type_index += 1;
4604 
4605           if (vklass-&gt;contains_oops()) { // add flatten oop maps
4606             int diff = real_offset - vklass-&gt;first_field_offset();
4607             const OopMapBlock* map = vklass-&gt;start_of_nonstatic_oop_maps();
4608             const OopMapBlock* const last_map = map + vklass-&gt;nonstatic_oop_map_count();
4609             while (map &lt; last_map) {
4610               nonstatic_oop_maps-&gt;add(map-&gt;offset() + diff, map-&gt;count());
4611               map++;
4612             }
4613           }
4614           break;
4615         } else {
4616           // Fall through
4617         }
4618       case NONSTATIC_OOP:
4619         if( nonstatic_oop_space_count &gt; 0 ) {
4620           real_offset = nonstatic_oop_space_offset;
4621           nonstatic_oop_space_offset += heapOopSize;
4622           nonstatic_oop_space_count  -= 1;
4623         } else {
4624           real_offset = next_nonstatic_oop_offset;
4625           next_nonstatic_oop_offset += heapOopSize;
4626         }
4627         nonstatic_oop_maps-&gt;add(real_offset, 1);
4628         break;
4629       case NONSTATIC_BYTE:
4630         if( nonstatic_byte_space_count &gt; 0 ) {
4631           real_offset = nonstatic_byte_space_offset;
4632           nonstatic_byte_space_offset += 1;
4633           nonstatic_byte_space_count  -= 1;
4634         } else {
4635           real_offset = next_nonstatic_byte_offset;
4636           next_nonstatic_byte_offset += 1;
4637         }
4638         break;
4639       case NONSTATIC_SHORT:
4640         if( nonstatic_short_space_count &gt; 0 ) {
4641           real_offset = nonstatic_short_space_offset;
4642           nonstatic_short_space_offset += BytesPerShort;
4643           nonstatic_short_space_count  -= 1;
4644         } else {
4645           real_offset = next_nonstatic_short_offset;
4646           next_nonstatic_short_offset += BytesPerShort;
4647         }
4648         break;
4649       case NONSTATIC_WORD:
4650         if( nonstatic_word_space_count &gt; 0 ) {
4651           real_offset = nonstatic_word_space_offset;
4652           nonstatic_word_space_offset += BytesPerInt;
4653           nonstatic_word_space_count  -= 1;
4654         } else {
4655           real_offset = next_nonstatic_word_offset;
4656           next_nonstatic_word_offset += BytesPerInt;
4657         }
4658         break;
4659       case NONSTATIC_DOUBLE:
4660         real_offset = next_nonstatic_double_offset;
4661         next_nonstatic_double_offset += BytesPerLong;
4662         break;
4663       default:
4664         ShouldNotReachHere();
4665     }
4666     fs.set_offset(real_offset);
4667   }
4668 
4669 
4670   // Handle the contended cases.
4671   //
4672   // Each contended field should not intersect the cache line with another contended field.
4673   // In the absence of alignment information, we end up with pessimistically separating
4674   // the fields with full-width padding.
4675   //
4676   // Additionally, this should not break alignment for the fields, so we round the alignment up
4677   // for each field.
4678   if (nonstatic_contended_count &gt; 0) {
4679 
4680     // if there is at least one contended field, we need to have pre-padding for them
4681     next_nonstatic_padded_offset += ContendedPaddingWidth;
4682 
4683     // collect all contended groups
4684     ResourceBitMap bm(cp-&gt;size());
4685     for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4686       // skip already laid out fields
4687       if (fs.is_offset_set()) continue;
4688 
4689       if (fs.is_contended()) {
4690         bm.set_bit(fs.contended_group());
4691       }
4692     }
4693 
4694     int current_group = -1;
4695     while ((current_group = (int)bm.get_next_one_offset(current_group + 1)) != (int)bm.size()) {
4696 
4697       for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4698 
4699         // skip already laid out fields
4700         if (fs.is_offset_set()) continue;
4701 
4702         // skip non-contended fields and fields from different group
4703         if (!fs.is_contended() || (fs.contended_group() != current_group)) continue;
4704 
4705         // handle statics below
4706         if (fs.access_flags().is_static()) continue;
4707 
4708         int real_offset = 0;
4709         FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4710 
4711         switch (atype) {
4712           case NONSTATIC_BYTE:
4713             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, 1);
4714             real_offset = next_nonstatic_padded_offset;
4715             next_nonstatic_padded_offset += 1;
4716             break;
4717 
4718           case NONSTATIC_SHORT:
4719             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4720             real_offset = next_nonstatic_padded_offset;
4721             next_nonstatic_padded_offset += BytesPerShort;
4722             break;
4723 
4724           case NONSTATIC_WORD:
4725             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4726             real_offset = next_nonstatic_padded_offset;
4727             next_nonstatic_padded_offset += BytesPerInt;
4728             break;
4729 
4730           case NONSTATIC_DOUBLE:
4731             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4732             real_offset = next_nonstatic_padded_offset;
4733             next_nonstatic_padded_offset += BytesPerLong;
4734             break;
4735 
4736             // Value types in static fields are handled with oops
4737           case NONSTATIC_FLATTENABLE:
4738             throwValueTypeLimitation(THREAD_AND_LOCATION,
4739                                      &quot;@Contended annotation not supported for value types yet&quot;, fs.name(), fs.signature());
4740             return;
4741 
4742           case NONSTATIC_OOP:
4743             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4744             real_offset = next_nonstatic_padded_offset;
4745             next_nonstatic_padded_offset += heapOopSize;
4746             nonstatic_oop_maps-&gt;add(real_offset, 1);
4747             break;
4748 
4749           default:
4750             ShouldNotReachHere();
4751         }
4752 
4753         if (fs.contended_group() == 0) {
4754           // Contended group defines the equivalence class over the fields:
4755           // the fields within the same contended group are not inter-padded.
4756           // The only exception is default group, which does not incur the
4757           // equivalence, and so requires intra-padding.
4758           next_nonstatic_padded_offset += ContendedPaddingWidth;
4759         }
4760 
4761         fs.set_offset(real_offset);
4762       } // for
4763 
4764       // Start laying out the next group.
4765       // Note that this will effectively pad the last group in the back;
4766       // this is expected to alleviate memory contention effects for
4767       // subclass fields and/or adjacent object.
4768       // If this was the default group, the padding is already in place.
4769       if (current_group != 0) {
4770         next_nonstatic_padded_offset += ContendedPaddingWidth;
4771       }
4772     }
4773 
4774     // handle static fields
4775   }
4776 
4777   // Entire class is contended, pad in the back.
4778   // This helps to alleviate memory contention effects for subclass fields
4779   // and/or adjacent object.
4780   if (is_contended_class) {
4781     assert(!is_value_type(), &quot;@Contended not supported for value types yet&quot;);
4782     next_nonstatic_padded_offset += ContendedPaddingWidth;
4783   }
4784 
4785   int notaligned_nonstatic_fields_end;
4786   if (nonstatic_value_type_count != 0) {
4787     notaligned_nonstatic_fields_end = next_nonstatic_valuetype_offset;
4788   } else {
4789     notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;
4790   }
4791 
4792   int nonstatic_field_sz_align = heapOopSize;
4793   if (is_value_type()) {
4794     if ((notaligned_nonstatic_fields_end - nonstatic_fields_start) &gt; heapOopSize) {
4795       nonstatic_field_sz_align = BytesPerLong; // value copy of fields only uses jlong copy
4796     }
4797   }
4798   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, nonstatic_field_sz_align);
4799   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4800   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4801 
4802   int static_field_size         = (static_fields_end -
4803                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4804   nonstatic_field_size          = nonstatic_field_size +
4805                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4806 
4807   int instance_size             = align_object_size(instance_end / wordSize);
4808 
4809   assert(instance_size == align_object_size(align_up(
4810          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)
4811          + initial_value_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);
4812 
4813 
4814   // Invariant: nonstatic_field end/start should only change if there are
4815   // nonstatic fields in the class, or if the class is contended. We compare
4816   // against the non-aligned value, so that end alignment will not fail the
4817   // assert without actually having the fields.
4818   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4819          is_contended_class ||
4820          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4821 
4822   // Number of non-static oop map blocks allocated at end of klass.
4823   nonstatic_oop_maps-&gt;compact();
4824 
4825 #ifndef PRODUCT
4826   if ((PrintFieldLayout &amp;&amp; !is_value_type()) ||
4827       (PrintValueLayout &amp;&amp; (is_value_type() || has_nonstatic_value_fields))) {
4828     print_field_layout(_class_name,
4829           _fields,
4830           cp,
4831           instance_size,
4832           nonstatic_fields_start,
4833           nonstatic_fields_end,
4834           static_fields_end);
4835     nonstatic_oop_maps-&gt;print_on(tty);
4836     tty-&gt;print(&quot;\n&quot;);
4837     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);
4838     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);
4839     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);
4840     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);
4841     tty-&gt;print_cr(&quot;---&quot;);
4842   }
4843 
4844 #endif
4845   // Pass back information needed for InstanceKlass creation
4846   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4847   info-&gt;_instance_size = instance_size;
4848   info-&gt;_static_field_size = static_field_size;
4849   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4850   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;
<a name="9" id="anc9"></a>












4851 }
4852 
4853 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4854   assert(ik != NULL, &quot;invariant&quot;);
4855 
4856   const Klass* const super = ik-&gt;super();
4857 
4858   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4859   // in which case we don&#39;t have to register objects as finalizable
4860   if (!_has_empty_finalizer) {
4861     if (_has_finalizer ||
4862         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4863       ik-&gt;set_has_finalizer();
4864     }
4865   }
4866 
4867 #ifdef ASSERT
4868   bool f = false;
4869   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4870                                            vmSymbols::void_method_signature());
4871   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4872       f = true;
4873   }
4874 
4875   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4876   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4877   // will not work as expected we shouldn&#39;t abort vm in this case
4878   if (!ik-&gt;has_redefined_this_or_super()) {
4879     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4880   }
4881 #endif
4882 
4883   // Check if this klass supports the java.lang.Cloneable interface
4884   if (SystemDictionary::Cloneable_klass_loaded()) {
4885     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {
4886       if (ik-&gt;is_value()) {
4887         Thread *THREAD = Thread::current();
4888         throwValueTypeLimitation(THREAD_AND_LOCATION, &quot;Value Types do not support Cloneable&quot;);
4889         return;
4890       }
4891       ik-&gt;set_is_cloneable();
4892     }
4893   }
4894 
4895   // Check if this klass has a vanilla default constructor
4896   if (super == NULL) {
4897     // java.lang.Object has empty default constructor
4898     ik-&gt;set_has_vanilla_constructor();
4899   } else {
4900     if (super-&gt;has_vanilla_constructor() &amp;&amp;
4901         _has_vanilla_constructor) {
4902       ik-&gt;set_has_vanilla_constructor();
4903     }
4904 #ifdef ASSERT
4905     bool v = false;
4906     if (super-&gt;has_vanilla_constructor()) {
4907       const Method* const constructor =
4908         ik-&gt;find_method(vmSymbols::object_initializer_name(),
4909                        vmSymbols::void_method_signature());
4910       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
4911         v = true;
4912       }
4913     }
4914     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
4915 #endif
4916   }
4917 
4918   // If it cannot be fast-path allocated, set a bit in the layout helper.
4919   // See documentation of InstanceKlass::can_be_fastpath_allocated().
4920   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
4921   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
4922       || ik-&gt;is_abstract() || ik-&gt;is_interface()
4923       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
4924       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
4925     // Forbid fast-path allocation.
4926     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
4927     ik-&gt;set_layout_helper(lh);
4928   }
4929 }
4930 
4931 bool ClassFileParser::supports_value_types() const {
4932   // Value types are only supported by class file version 55 and later
4933   return _major_version &gt;= JAVA_11_VERSION;
4934 }
4935 
4936 // utility methods for appending an array with check for duplicates
4937 
4938 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
4939                               const Array&lt;InstanceKlass*&gt;* const ifs) {
4940   // iterate over new interfaces
4941   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
4942     InstanceKlass* const e = ifs-&gt;at(i);
4943     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
4944     // add new interface
4945     result-&gt;append_if_missing(e);
4946   }
4947 }
4948 
4949 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
4950                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
4951                                                             ClassLoaderData* loader_data,
4952                                                             TRAPS) {
4953   assert(local_ifs != NULL, &quot;invariant&quot;);
4954   assert(loader_data != NULL, &quot;invariant&quot;);
4955 
4956   // Compute maximum size for transitive interfaces
4957   int max_transitive_size = 0;
4958   int super_size = 0;
4959   // Add superclass transitive interfaces size
4960   if (super != NULL) {
4961     super_size = super-&gt;transitive_interfaces()-&gt;length();
4962     max_transitive_size += super_size;
4963   }
4964   // Add local interfaces&#39; super interfaces
4965   const int local_size = local_ifs-&gt;length();
4966   for (int i = 0; i &lt; local_size; i++) {
4967     InstanceKlass* const l = local_ifs-&gt;at(i);
4968     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
4969   }
4970   // Finally add local interfaces
4971   max_transitive_size += local_size;
4972   // Construct array
4973   if (max_transitive_size == 0) {
4974     // no interfaces, use canonicalized array
4975     return Universe::the_empty_instance_klass_array();
4976   } else if (max_transitive_size == super_size) {
4977     // no new local interfaces added, share superklass&#39; transitive interface array
4978     return super-&gt;transitive_interfaces();
4979   } else if (max_transitive_size == local_size) {
4980     // only local interfaces added, share local interface array
4981     return local_ifs;
4982   } else {
4983     ResourceMark rm;
4984     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
4985 
4986     // Copy down from superclass
4987     if (super != NULL) {
4988       append_interfaces(result, super-&gt;transitive_interfaces());
4989     }
4990 
4991     // Copy down from local interfaces&#39; superinterfaces
4992     for (int i = 0; i &lt; local_size; i++) {
4993       InstanceKlass* const l = local_ifs-&gt;at(i);
4994       append_interfaces(result, l-&gt;transitive_interfaces());
4995     }
4996     // Finally add local interfaces
4997     append_interfaces(result, local_ifs);
4998 
4999     // length will be less than the max_transitive_size if duplicates were removed
5000     const int length = result-&gt;length();
5001     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
5002     Array&lt;InstanceKlass*&gt;* const new_result =
5003       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
5004     for (int i = 0; i &lt; length; i++) {
5005       InstanceKlass* const e = result-&gt;at(i);
5006       assert(e != NULL, &quot;just checking&quot;);
5007       new_result-&gt;at_put(i, e);
5008     }
5009     return new_result;
5010   }
5011 }
5012 
5013 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
5014   assert(this_klass != NULL, &quot;invariant&quot;);
5015   const Klass* const super = this_klass-&gt;super();
5016 
5017   if (super != NULL) {
5018 
5019     // If the loader is not the boot loader then throw an exception if its
5020     // superclass is in package jdk.internal.reflect and its loader is not a
5021     // special reflection class loader
5022     if (!this_klass-&gt;class_loader_data()-&gt;is_the_null_class_loader_data()) {
5023       assert(super-&gt;is_instance_klass(), &quot;super is not instance klass&quot;);
5024       PackageEntry* super_package = super-&gt;package();
5025       if (super_package != NULL &amp;&amp;
5026           super_package-&gt;name()-&gt;fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &amp;&amp;
5027           !java_lang_ClassLoader::is_reflection_class_loader(this_klass-&gt;class_loader())) {
5028         ResourceMark rm(THREAD);
5029         Exceptions::fthrow(
5030           THREAD_AND_LOCATION,
5031           vmSymbols::java_lang_IllegalAccessError(),
5032           &quot;class %s loaded by %s cannot access jdk/internal/reflect superclass %s&quot;,
5033           this_klass-&gt;external_name(),
5034           this_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
5035           super-&gt;external_name());
5036         return;
5037       }
5038     }
5039 
5040     Reflection::VerifyClassAccessResults vca_result =
5041       Reflection::verify_class_access(this_klass, InstanceKlass::cast(super), false);
5042     if (vca_result != Reflection::ACCESS_OK) {
5043       ResourceMark rm(THREAD);
5044       char* msg = Reflection::verify_class_access_msg(this_klass,
5045                                                       InstanceKlass::cast(super),
5046                                                       vca_result);
5047       if (msg == NULL) {
5048         bool same_module = (this_klass-&gt;module() == super-&gt;module());
5049         Exceptions::fthrow(
5050           THREAD_AND_LOCATION,
5051           vmSymbols::java_lang_IllegalAccessError(),
5052           &quot;class %s cannot access its %ssuperclass %s (%s%s%s)&quot;,
5053           this_klass-&gt;external_name(),
5054           super-&gt;is_abstract() ? &quot;abstract &quot; : &quot;&quot;,
5055           super-&gt;external_name(),
5056           (same_module) ? this_klass-&gt;joint_in_module_of_loader(super) : this_klass-&gt;class_in_module_of_loader(),
5057           (same_module) ? &quot;&quot; : &quot;; &quot;,
5058           (same_module) ? &quot;&quot; : super-&gt;class_in_module_of_loader());
5059       } else {
5060         // Add additional message content.
5061         Exceptions::fthrow(
5062           THREAD_AND_LOCATION,
5063           vmSymbols::java_lang_IllegalAccessError(),
5064           &quot;superclass access check failed: %s&quot;,
5065           msg);
5066       }
5067     }
5068   }
5069 }
5070 
5071 
5072 static void check_super_interface_access(const InstanceKlass* this_klass, TRAPS) {
5073   assert(this_klass != NULL, &quot;invariant&quot;);
5074   const Array&lt;InstanceKlass*&gt;* const local_interfaces = this_klass-&gt;local_interfaces();
5075   const int lng = local_interfaces-&gt;length();
5076   for (int i = lng - 1; i &gt;= 0; i--) {
5077     InstanceKlass* const k = local_interfaces-&gt;at(i);
5078     assert (k != NULL &amp;&amp; k-&gt;is_interface(), &quot;invalid interface&quot;);
5079     Reflection::VerifyClassAccessResults vca_result =
5080       Reflection::verify_class_access(this_klass, k, false);
5081     if (vca_result != Reflection::ACCESS_OK) {
5082       ResourceMark rm(THREAD);
5083       char* msg = Reflection::verify_class_access_msg(this_klass,
5084                                                       k,
5085                                                       vca_result);
5086       if (msg == NULL) {
5087         bool same_module = (this_klass-&gt;module() == k-&gt;module());
5088         Exceptions::fthrow(
5089           THREAD_AND_LOCATION,
5090           vmSymbols::java_lang_IllegalAccessError(),
5091           &quot;class %s cannot access its superinterface %s (%s%s%s)&quot;,
5092           this_klass-&gt;external_name(),
5093           k-&gt;external_name(),
5094           (same_module) ? this_klass-&gt;joint_in_module_of_loader(k) : this_klass-&gt;class_in_module_of_loader(),
5095           (same_module) ? &quot;&quot; : &quot;; &quot;,
5096           (same_module) ? &quot;&quot; : k-&gt;class_in_module_of_loader());
5097       } else {
5098         // Add additional message content.
5099         Exceptions::fthrow(
5100           THREAD_AND_LOCATION,
5101           vmSymbols::java_lang_IllegalAccessError(),
5102           &quot;superinterface check failed: %s&quot;,
5103           msg);
5104       }
5105     }
5106   }
5107 }
5108 
5109 
5110 static void check_final_method_override(const InstanceKlass* this_klass, TRAPS) {
5111   assert(this_klass != NULL, &quot;invariant&quot;);
5112   const Array&lt;Method*&gt;* const methods = this_klass-&gt;methods();
5113   const int num_methods = methods-&gt;length();
5114 
5115   // go thru each method and check if it overrides a final method
5116   for (int index = 0; index &lt; num_methods; index++) {
5117     const Method* const m = methods-&gt;at(index);
5118 
5119     // skip private, static, and &lt;init&gt; methods
5120     if ((!m-&gt;is_private() &amp;&amp; !m-&gt;is_static()) &amp;&amp;
5121         (m-&gt;name() != vmSymbols::object_initializer_name())) {
5122 
5123       const Symbol* const name = m-&gt;name();
5124       const Symbol* const signature = m-&gt;signature();
5125       const Klass* k = this_klass-&gt;super();
5126       const Method* super_m = NULL;
5127       while (k != NULL) {
5128         // skip supers that don&#39;t have final methods.
5129         if (k-&gt;has_final_method()) {
5130           // lookup a matching method in the super class hierarchy
5131           super_m = InstanceKlass::cast(k)-&gt;lookup_method(name, signature);
5132           if (super_m == NULL) {
5133             break; // didn&#39;t find any match; get out
5134           }
5135 
5136           if (super_m-&gt;is_final() &amp;&amp; !super_m-&gt;is_static() &amp;&amp;
5137               !super_m-&gt;access_flags().is_private()) {
5138             // matching method in super is final, and not static or private
5139             bool can_access = Reflection::verify_member_access(this_klass,
5140                                                                super_m-&gt;method_holder(),
5141                                                                super_m-&gt;method_holder(),
5142                                                                super_m-&gt;access_flags(),
5143                                                               false, false, CHECK);
5144             if (can_access) {
5145               // this class can access super final method and therefore override
5146               ResourceMark rm(THREAD);
5147               Exceptions::fthrow(THREAD_AND_LOCATION,
5148                                  vmSymbols::java_lang_VerifyError(),
5149                                  &quot;class %s overrides final method %s.%s%s&quot;,
5150                                  this_klass-&gt;external_name(),
5151                                  super_m-&gt;method_holder()-&gt;external_name(),
5152                                  name-&gt;as_C_string(),
5153                                  signature-&gt;as_C_string()
5154                                  );
5155               return;
5156             }
5157           }
5158 
5159           // continue to look from super_m&#39;s holder&#39;s super.
5160           k = super_m-&gt;method_holder()-&gt;super();
5161           continue;
5162         }
5163 
5164         k = k-&gt;super();
5165       }
5166     }
5167   }
5168 }
5169 
5170 
5171 // assumes that this_klass is an interface
5172 static void check_illegal_static_method(const InstanceKlass* this_klass, TRAPS) {
5173   assert(this_klass != NULL, &quot;invariant&quot;);
5174   assert(this_klass-&gt;is_interface(), &quot;not an interface&quot;);
5175   const Array&lt;Method*&gt;* methods = this_klass-&gt;methods();
5176   const int num_methods = methods-&gt;length();
5177 
5178   for (int index = 0; index &lt; num_methods; index++) {
5179     const Method* const m = methods-&gt;at(index);
5180     // if m is static and not the init method, throw a verify error
5181     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
5182       ResourceMark rm(THREAD);
5183       Exceptions::fthrow(
5184         THREAD_AND_LOCATION,
5185         vmSymbols::java_lang_VerifyError(),
5186         &quot;Illegal static method %s in interface %s&quot;,
5187         m-&gt;name()-&gt;as_C_string(),
5188         this_klass-&gt;external_name()
5189       );
5190       return;
5191     }
5192   }
5193 }
5194 
5195 // utility methods for format checking
5196 
5197 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
5198   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
5199   const bool is_value_type = (flags &amp; JVM_ACC_VALUE) != 0;
5200   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
5201   assert(supports_value_types() || !is_value_type, &quot;JVM_ACC_VALUE should not be set&quot;);
5202   if (is_module) {
5203     ResourceMark rm(THREAD);
5204     Exceptions::fthrow(
5205       THREAD_AND_LOCATION,
5206       vmSymbols::java_lang_NoClassDefFoundError(),
5207       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
5208       _class_name-&gt;as_C_string());
5209     return;
5210   }
5211 
5212   if (is_value_type &amp;&amp; !EnableValhalla) {
5213     ResourceMark rm(THREAD);
5214     Exceptions::fthrow(
5215       THREAD_AND_LOCATION,
5216       vmSymbols::java_lang_ClassFormatError(),
5217       &quot;Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla&quot;,
5218       _class_name-&gt;as_C_string()
5219     );
5220   }
5221 
5222   if (!_need_verify) { return; }
5223 
5224   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
5225   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
5226   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
5227   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
5228   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
5229   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
5230   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5231   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
5232 
5233   if ((is_abstract &amp;&amp; is_final) ||
5234       (is_interface &amp;&amp; !is_abstract) ||
5235       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
5236       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation) ||
5237       (is_value_type &amp;&amp; (is_interface || is_abstract || is_enum || !is_final))) {
5238     ResourceMark rm(THREAD);
5239     const char* class_note = &quot;&quot;;
5240     if (is_value_type)  class_note = &quot; (an inline class)&quot;;
5241     Exceptions::fthrow(
5242       THREAD_AND_LOCATION,
5243       vmSymbols::java_lang_ClassFormatError(),
5244       &quot;Illegal class modifiers in class %s%s: 0x%X&quot;,
5245       _class_name-&gt;as_C_string(), class_note, flags
5246     );
5247     return;
5248   }
5249 }
5250 
5251 static bool has_illegal_visibility(jint flags) {
5252   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5253   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5254   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5255 
5256   return ((is_public &amp;&amp; is_protected) ||
5257           (is_public &amp;&amp; is_private) ||
5258           (is_protected &amp;&amp; is_private));
5259 }
5260 
5261 // A legal major_version.minor_version must be one of the following:
5262 //
5263 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
5264 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
5265 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
5266 //
5267 static void verify_class_version(u2 major, u2 minor, Symbol* class_name, TRAPS){
5268   ResourceMark rm(THREAD);
5269   const u2 max_version = JVM_CLASSFILE_MAJOR_VERSION;
5270   if (major &lt; JAVA_MIN_SUPPORTED_VERSION) {
5271     Exceptions::fthrow(
5272       THREAD_AND_LOCATION,
5273       vmSymbols::java_lang_UnsupportedClassVersionError(),
5274       &quot;%s (class file version %u.%u) was compiled with an invalid major version&quot;,
5275       class_name-&gt;as_C_string(), major, minor);
5276     return;
5277   }
5278 
5279   if (major &gt; max_version) {
5280     Exceptions::fthrow(
5281       THREAD_AND_LOCATION,
5282       vmSymbols::java_lang_UnsupportedClassVersionError(),
5283       &quot;%s has been compiled by a more recent version of the Java Runtime (class file version %u.%u), &quot;
5284       &quot;this version of the Java Runtime only recognizes class file versions up to %u.0&quot;,
5285       class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION);
5286     return;
5287   }
5288 
5289   if (major &lt; JAVA_12_VERSION || minor == 0) {
5290     return;
5291   }
5292 
5293   if (minor == JAVA_PREVIEW_MINOR_VERSION) {
5294     if (major != max_version) {
5295       Exceptions::fthrow(
5296         THREAD_AND_LOCATION,
5297         vmSymbols::java_lang_UnsupportedClassVersionError(),
5298         &quot;%s (class file version %u.%u) was compiled with preview features that are unsupported. &quot;
5299         &quot;This version of the Java Runtime only recognizes preview features for class file version %u.%u&quot;,
5300         class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION, JAVA_PREVIEW_MINOR_VERSION);
5301       return;
5302     }
5303 
5304     if (!Arguments::enable_preview()) {
5305       Exceptions::fthrow(
5306         THREAD_AND_LOCATION,
5307         vmSymbols::java_lang_UnsupportedClassVersionError(),
5308         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
5309         class_name-&gt;as_C_string(), major, minor);
5310       return;
5311     }
5312 
5313   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
5314     Exceptions::fthrow(
5315         THREAD_AND_LOCATION,
5316         vmSymbols::java_lang_UnsupportedClassVersionError(),
5317         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
5318         class_name-&gt;as_C_string(), major, minor);
5319   }
5320 }
5321 
5322 void ClassFileParser::verify_legal_field_modifiers(jint flags,
5323                                                    bool is_interface,
5324                                                    bool is_value_type,
5325                                                    TRAPS) const {
5326   if (!_need_verify) { return; }
5327 
5328   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5329   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5330   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5331   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
5332   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
5333   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
5334   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
5335   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
5336   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5337 
5338   bool is_illegal = false;
5339 
5340   if (is_interface) {
5341     if (!is_public || !is_static || !is_final || is_private ||
5342         is_protected || is_volatile || is_transient ||
5343         (major_gte_1_5 &amp;&amp; is_enum)) {
5344       is_illegal = true;
5345     }
5346   } else { // not interface
5347     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5348       is_illegal = true;
5349     } else {
5350       if (is_value_type &amp;&amp; !is_static &amp;&amp; !is_final) {
5351         is_illegal = true;
5352       }
5353     }
5354   }
5355 
5356   if (is_illegal) {
5357     ResourceMark rm(THREAD);
5358     Exceptions::fthrow(
5359       THREAD_AND_LOCATION,
5360       vmSymbols::java_lang_ClassFormatError(),
5361       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5362       _class_name-&gt;as_C_string(), flags);
5363     return;
5364   }
5365 }
5366 
5367 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5368                                                     bool is_interface,
5369                                                     bool is_value_type,
5370                                                     const Symbol* name,
5371                                                     TRAPS) const {
5372   if (!_need_verify) { return; }
5373 
5374   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5375   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5376   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5377   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5378   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5379   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5380   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5381   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5382   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5383   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5384   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5385   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5386   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5387 
5388   bool is_illegal = false;
5389 
5390   const char* class_note = &quot;&quot;;
5391 
5392   if (is_interface) {
5393     if (major_gte_8) {
5394       // Class file version is JAVA_8_VERSION or later Methods of
5395       // interfaces may set any of the flags except ACC_PROTECTED,
5396       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
5397       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
5398       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
5399           (is_native || is_protected || is_final || is_synchronized) ||
5400           // If a specific method of a class or interface has its
5401           // ACC_ABSTRACT flag set, it must not have any of its
5402           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
5403           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
5404           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
5405           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
5406           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
5407         is_illegal = true;
5408       }
5409     } else if (major_gte_1_5) {
5410       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5411       if (!is_public || is_private || is_protected || is_static || is_final ||
5412           is_synchronized || is_native || !is_abstract || is_strict) {
5413         is_illegal = true;
5414       }
5415     } else {
5416       // Class file version is pre-JAVA_1_5_VERSION
5417       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5418         is_illegal = true;
5419       }
5420     }
5421   } else { // not interface
5422     if (has_illegal_visibility(flags)) {
5423       is_illegal = true;
5424     } else {
5425       if (is_initializer) {
5426         if (is_final || is_synchronized || is_native ||
5427             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5428           is_illegal = true;
5429         }
5430         if (!is_static &amp;&amp; !is_value_type) {
5431           // OK, an object constructor in a regular class
5432         } else if (is_static &amp;&amp; is_value_type) {
5433           // OK, a static init factory in an inline class
5434         } else {
5435           // but no other combinations are allowed
5436           is_illegal = true;
5437           class_note = (is_value_type ? &quot; (an inline class)&quot; : &quot; (not an inline class)&quot;);
5438         }
5439       } else { // not initializer
5440         if (is_value_type &amp;&amp; is_synchronized &amp;&amp; !is_static) {
5441           is_illegal = true;
5442           class_note = &quot; (an inline class)&quot;;
5443         } else {
5444           if (is_abstract) {
5445             if ((is_final || is_native || is_private || is_static ||
5446                 (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {
5447               is_illegal = true;
5448             }
5449           }
5450         }
5451       }
5452     }
5453   }
5454 
5455   if (is_illegal) {
5456     ResourceMark rm(THREAD);
5457     Exceptions::fthrow(
5458       THREAD_AND_LOCATION,
5459       vmSymbols::java_lang_ClassFormatError(),
5460       &quot;Method %s in class %s%s has illegal modifiers: 0x%X&quot;,
5461       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, flags);
5462     return;
5463   }
5464 }
5465 
5466 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
5467                                         int length,
5468                                         TRAPS) const {
5469   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
5470   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
5471     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
5472   }
5473 }
5474 
5475 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
5476 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
5477 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
5478 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
5479 // method.  Because these names have been checked as special cases before
5480 // calling this method in verify_legal_method_name.
5481 //
5482 // This method is also called from the modular system APIs in modules.cpp
5483 // to verify the validity of module and package names.
5484 bool ClassFileParser::verify_unqualified_name(const char* name,
5485                                               unsigned int length,
5486                                               int type) {
5487   if (length == 0) return false;  // Must have at least one char.
5488   for (const char* p = name; p != name + length; p++) {
5489     switch(*p) {
5490       case JVM_SIGNATURE_DOT:
5491       case JVM_SIGNATURE_ENDCLASS:
5492       case JVM_SIGNATURE_ARRAY:
5493         // do not permit &#39;.&#39;, &#39;;&#39;, or &#39;[&#39;
5494         return false;
5495       case JVM_SIGNATURE_SLASH:
5496         // check for &#39;//&#39; or leading or trailing &#39;/&#39; which are not legal
5497         // unqualified name must not be empty
5498         if (type == ClassFileParser::LegalClass) {
5499           if (p == name || p+1 &gt;= name+length ||
5500               *(p+1) == JVM_SIGNATURE_SLASH) {
5501             return false;
5502           }
5503         } else {
5504           return false;   // do not permit &#39;/&#39; unless it&#39;s class name
5505         }
5506         break;
5507       case JVM_SIGNATURE_SPECIAL:
5508       case JVM_SIGNATURE_ENDSPECIAL:
5509         // do not permit &#39;&lt;&#39; or &#39;&gt;&#39; in method names
5510         if (type == ClassFileParser::LegalMethod) {
5511           return false;
5512         }
5513     }
5514   }
5515   return true;
5516 }
5517 
5518 // Take pointer to a UTF8 byte string (not NUL-terminated).
5519 // Skip over the longest part of the string that could
5520 // be taken as a fieldname. Allow &#39;/&#39; if slash_ok is true.
5521 // Return a pointer to just past the fieldname.
5522 // Return NULL if no fieldname at all was found, or in the case of slash_ok
5523 // being true, we saw consecutive slashes (meaning we were looking for a
5524 // qualified path but found something that was badly-formed).
5525 static const char* skip_over_field_name(const char* const name,
5526                                         bool slash_ok,
5527                                         unsigned int length) {
5528   const char* p;
5529   jboolean last_is_slash = false;
5530   jboolean not_first_ch = false;
5531 
5532   for (p = name; p != name + length; not_first_ch = true) {
5533     const char* old_p = p;
5534     jchar ch = *p;
5535     if (ch &lt; 128) {
5536       p++;
5537       // quick check for ascii
5538       if ((ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) ||
5539         (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;) ||
5540         (ch == &#39;_&#39; || ch == &#39;$&#39;) ||
5541         (not_first_ch &amp;&amp; ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)) {
5542         last_is_slash = false;
5543         continue;
5544       }
5545       if (slash_ok &amp;&amp; ch == JVM_SIGNATURE_SLASH) {
5546         if (last_is_slash) {
5547           return NULL;  // Don&#39;t permit consecutive slashes
5548         }
5549         last_is_slash = true;
5550         continue;
5551       }
5552     }
5553     else {
5554       jint unicode_ch;
5555       char* tmp_p = UTF8::next_character(p, &amp;unicode_ch);
5556       p = tmp_p;
5557       last_is_slash = false;
5558       // Check if ch is Java identifier start or is Java identifier part
5559       // 4672820: call java.lang.Character methods directly without generating separate tables.
5560       EXCEPTION_MARK;
5561       // return value
5562       JavaValue result(T_BOOLEAN);
5563       // Set up the arguments to isJavaIdentifierStart or isJavaIdentifierPart
5564       JavaCallArguments args;
5565       args.push_int(unicode_ch);
5566 
5567       if (not_first_ch) {
5568         // public static boolean isJavaIdentifierPart(char ch);
5569         JavaCalls::call_static(&amp;result,
5570           SystemDictionary::Character_klass(),
5571           vmSymbols::isJavaIdentifierPart_name(),
5572           vmSymbols::int_bool_signature(),
5573           &amp;args,
5574           THREAD);
5575       } else {
5576         // public static boolean isJavaIdentifierStart(char ch);
5577         JavaCalls::call_static(&amp;result,
5578           SystemDictionary::Character_klass(),
5579           vmSymbols::isJavaIdentifierStart_name(),
5580           vmSymbols::int_bool_signature(),
5581           &amp;args,
5582           THREAD);
5583       }
5584       if (HAS_PENDING_EXCEPTION) {
5585         CLEAR_PENDING_EXCEPTION;
5586         return NULL;
5587       }
5588       if(result.get_jboolean()) {
5589         continue;
5590       }
5591     }
5592     return (not_first_ch) ? old_p : NULL;
5593   }
5594   return (not_first_ch) ? p : NULL;
5595 }
5596 
5597 // Take pointer to a UTF8 byte string (not NUL-terminated).
5598 // Skip over the longest part of the string that could
5599 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5600 // Return a pointer to just past the signature.
5601 // Return NULL if no legal signature is found.
5602 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5603                                                        bool void_ok,
5604                                                        unsigned int length,
5605                                                        TRAPS) const {
5606   unsigned int array_dim = 0;
5607   while (length &gt; 0) {
5608     switch (signature[0]) {
5609     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5610     case JVM_SIGNATURE_BOOLEAN:
5611     case JVM_SIGNATURE_BYTE:
5612     case JVM_SIGNATURE_CHAR:
5613     case JVM_SIGNATURE_SHORT:
5614     case JVM_SIGNATURE_INT:
5615     case JVM_SIGNATURE_FLOAT:
5616     case JVM_SIGNATURE_LONG:
5617     case JVM_SIGNATURE_DOUBLE:
5618       return signature + 1;
5619     case JVM_SIGNATURE_VALUETYPE:
5620       // Can&#39;t enable this check until JDK upgrades the bytecode generators
5621       // if (_major_version &lt; CONSTANT_CLASS_DESCRIPTORS ) {
5622       //   classfile_parse_error(&quot;Class name contains illegal Q-signature &quot;
5623       //                                    &quot;in descriptor in class file %s&quot;,
5624       //                                    CHECK_0);
5625       // }
5626       // fall through
5627     case JVM_SIGNATURE_CLASS:
5628     {
5629       if (_major_version &lt; JAVA_1_5_VERSION) {
5630         // Skip over the class name if one is there
5631         const char* const p = skip_over_field_name(signature + 1, true, --length);
5632 
5633         // The next character better be a semicolon
5634         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5635           return p + 1;
5636         }
5637       }
5638       else {
5639         // Skip leading &#39;L&#39; or &#39;Q&#39; and ignore first appearance of &#39;;&#39;
5640         signature++;
5641         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5642         // Format check signature
5643         if (c != NULL) {
5644           int newlen = c - (char*) signature;
5645           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5646           if (!legal) {
5647             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5648                                   &quot;in descriptor in class file %s&quot;,
5649                                   CHECK_0);
5650             return NULL;
5651           }
5652           return signature + newlen + 1;
5653         }
5654       }
5655       return NULL;
5656     }
5657     case JVM_SIGNATURE_ARRAY:
5658       array_dim++;
5659       if (array_dim &gt; 255) {
5660         // 4277370: array descriptor is valid only if it represents 255 or fewer dimensions.
5661         classfile_parse_error(&quot;Array type descriptor has more than 255 dimensions in class file %s&quot;, CHECK_0);
5662       }
5663       // The rest of what&#39;s there better be a legal signature
5664       signature++;
5665       length--;
5666       void_ok = false;
5667       break;
5668     default:
5669       return NULL;
5670     }
5671   }
5672   return NULL;
5673 }
5674 
5675 // Checks if name is a legal class name.
5676 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5677   if (!_need_verify || _relax_verify) { return; }
5678 
5679   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5680   char* bytes = (char*)name-&gt;bytes();
5681   unsigned int length = name-&gt;utf8_length();
5682   bool legal = false;
5683 
5684   if (length &gt; 0) {
5685     const char* p;
5686     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5687       p = skip_over_field_signature(bytes, false, length, CHECK);
5688       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5689     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5690       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5691         p = skip_over_field_name(bytes, true, length);
5692         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5693       }
5694     } else if (_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS &amp;&amp; bytes[length - 1] == &#39;;&#39; ) {
5695       // Support for L...; and Q...; descriptors
5696       legal = verify_unqualified_name(bytes + 1, length - 2, LegalClass);
5697     } else {
5698       // 4900761: relax the constraints based on JSR202 spec
5699       // Class names may be drawn from the entire Unicode character set.
5700       // Identifiers between &#39;/&#39; must be unqualified names.
5701       // The utf8 string has been verified when parsing cpool entries.
5702       legal = verify_unqualified_name(bytes, length, LegalClass);
5703     }
5704   }
5705   if (!legal) {
5706     ResourceMark rm(THREAD);
5707     assert(_class_name != NULL, &quot;invariant&quot;);
5708     Exceptions::fthrow(
5709       THREAD_AND_LOCATION,
5710       vmSymbols::java_lang_ClassFormatError(),
5711       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5712       _class_name-&gt;as_C_string()
5713     );
5714     return;
5715   }
5716 }
5717 
5718 // Checks if name is a legal field name.
5719 void ClassFileParser::verify_legal_field_name(const Symbol* name, TRAPS) const {
5720   if (!_need_verify || _relax_verify) { return; }
5721 
5722   char* bytes = (char*)name-&gt;bytes();
5723   unsigned int length = name-&gt;utf8_length();
5724   bool legal = false;
5725 
5726   if (length &gt; 0) {
5727     if (_major_version &lt; JAVA_1_5_VERSION) {
5728       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5729         const char* p = skip_over_field_name(bytes, false, length);
5730         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5731       }
5732     } else {
5733       // 4881221: relax the constraints based on JSR202 spec
5734       legal = verify_unqualified_name(bytes, length, LegalField);
5735     }
5736   }
5737 
5738   if (!legal) {
5739     ResourceMark rm(THREAD);
5740     assert(_class_name != NULL, &quot;invariant&quot;);
5741     Exceptions::fthrow(
5742       THREAD_AND_LOCATION,
5743       vmSymbols::java_lang_ClassFormatError(),
5744       &quot;Illegal field name \&quot;%.*s\&quot; in class %s&quot;, length, bytes,
5745       _class_name-&gt;as_C_string()
5746     );
5747     return;
5748   }
5749 }
5750 
5751 // Checks if name is a legal method name.
5752 void ClassFileParser::verify_legal_method_name(const Symbol* name, TRAPS) const {
5753   if (!_need_verify || _relax_verify) { return; }
5754 
5755   assert(name != NULL, &quot;method name is null&quot;);
5756   char* bytes = (char*)name-&gt;bytes();
5757   unsigned int length = name-&gt;utf8_length();
5758   bool legal = false;
5759 
5760   if (length &gt; 0) {
5761     if (bytes[0] == JVM_SIGNATURE_SPECIAL) {
5762       if (name == vmSymbols::object_initializer_name() || name == vmSymbols::class_initializer_name()) {
5763         legal = true;
5764       }
5765     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5766       const char* p;
5767       p = skip_over_field_name(bytes, false, length);
5768       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5769     } else {
5770       // 4881221: relax the constraints based on JSR202 spec
5771       legal = verify_unqualified_name(bytes, length, LegalMethod);
5772     }
5773   }
5774 
5775   if (!legal) {
5776     ResourceMark rm(THREAD);
5777     assert(_class_name != NULL, &quot;invariant&quot;);
5778     Exceptions::fthrow(
5779       THREAD_AND_LOCATION,
5780       vmSymbols::java_lang_ClassFormatError(),
5781       &quot;Illegal method name \&quot;%.*s\&quot; in class %s&quot;, length, bytes,
5782       _class_name-&gt;as_C_string()
5783     );
5784     return;
5785   }
5786 }
5787 
5788 
5789 // Checks if signature is a legal field signature.
5790 void ClassFileParser::verify_legal_field_signature(const Symbol* name,
5791                                                    const Symbol* signature,
5792                                                    TRAPS) const {
5793   if (!_need_verify) { return; }
5794 
5795   const char* const bytes = (const char* const)signature-&gt;bytes();
5796   const unsigned int length = signature-&gt;utf8_length();
5797   const char* const p = skip_over_field_signature(bytes, false, length, CHECK);
5798 
5799   if (p == NULL || (p - bytes) != (int)length) {
5800     throwIllegalSignature(&quot;Field&quot;, name, signature, CHECK);
5801   }
5802 }
5803 
5804 // Checks if signature is a legal method signature.
5805 // Returns number of parameters
5806 int ClassFileParser::verify_legal_method_signature(const Symbol* name,
5807                                                    const Symbol* signature,
5808                                                    TRAPS) const {
5809   if (!_need_verify) {
5810     // make sure caller&#39;s args_size will be less than 0 even for non-static
5811     // method so it will be recomputed in compute_size_of_parameters().
5812     return -2;
5813   }
5814 
5815   // Class initializers cannot have args for class format version &gt;= 51.
5816   if (name == vmSymbols::class_initializer_name() &amp;&amp;
5817       signature != vmSymbols::void_method_signature() &amp;&amp;
5818       _major_version &gt;= JAVA_7_VERSION) {
5819     throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5820     return 0;
5821   }
5822 
5823   unsigned int args_size = 0;
5824   const char* p = (const char*)signature-&gt;bytes();
5825   unsigned int length = signature-&gt;utf8_length();
5826   const char* nextp;
5827 
5828   // The first character must be a &#39;(&#39;
5829   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5830     length--;
5831     // Skip over legal field signatures
5832     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5833     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5834       args_size++;
5835       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5836         args_size++;
5837       }
5838       length -= nextp - p;
5839       p = nextp;
5840       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5841     }
5842     // The first non-signature thing better be a &#39;)&#39;
5843     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
5844       length--;
5845       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
5846         // All constructor methods must return void
5847         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
5848           return args_size;
5849         }
5850         // All static init methods must return the current class
5851         if ((length &gt;= 3) &amp;&amp; (p[length-1] == JVM_SIGNATURE_ENDCLASS)
5852             &amp;&amp; name == vmSymbols::object_initializer_name()) {
5853           nextp = skip_over_field_signature(p, true, length, CHECK_0);
5854           if (nextp &amp;&amp; ((int)length == (nextp - p))) {
5855             // The actual class will be checked against current class
5856             // when the method is defined (see parse_method).
5857             // A reference to a static init with a bad return type
5858             // will load and verify OK, but will fail to link.
5859             return args_size;
5860           }
5861         }
5862         // The distinction between static factory methods and
5863         // constructors depends on the JVM_ACC_STATIC modifier.
5864         // This distinction must be reflected in a void or non-void
5865         // return. For declared methods, the check is in parse_method.
5866       } else {
5867         // Now we better just have a return value
5868         nextp = skip_over_field_signature(p, true, length, CHECK_0);
5869         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
5870           return args_size;
5871         }
5872       }
5873     }
5874   }
5875   // Report error
5876   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5877   return 0;
5878 }
5879 
5880 int ClassFileParser::static_field_size() const {
5881   assert(_field_info != NULL, &quot;invariant&quot;);
5882   return _field_info-&gt;_static_field_size;
5883 }
5884 
5885 int ClassFileParser::total_oop_map_count() const {
5886   assert(_field_info != NULL, &quot;invariant&quot;);
5887   return _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count;
5888 }
5889 
5890 jint ClassFileParser::layout_size() const {
5891   assert(_field_info != NULL, &quot;invariant&quot;);
5892   return _field_info-&gt;_instance_size;
5893 }
5894 
5895 static void check_methods_for_intrinsics(const InstanceKlass* ik,
5896                                          const Array&lt;Method*&gt;* methods) {
5897   assert(ik != NULL, &quot;invariant&quot;);
5898   assert(methods != NULL, &quot;invariant&quot;);
5899 
5900   // Set up Method*::intrinsic_id as soon as we know the names of methods.
5901   // (We used to do this lazily, but now we query it in Rewriter,
5902   // which is eagerly done for every method, so we might as well do it now,
5903   // when everything is fresh in memory.)
5904   const vmSymbols::SID klass_id = Method::klass_id_for_intrinsics(ik);
5905 
5906   if (klass_id != vmSymbols::NO_SID) {
5907     for (int j = 0; j &lt; methods-&gt;length(); ++j) {
5908       Method* method = methods-&gt;at(j);
5909       method-&gt;init_intrinsic_id();
5910 
5911       if (CheckIntrinsics) {
5912         // Check if an intrinsic is defined for method &#39;method&#39;,
5913         // but the method is not annotated with @HotSpotIntrinsicCandidate.
5914         if (method-&gt;intrinsic_id() != vmIntrinsics::_none &amp;&amp;
5915             !method-&gt;intrinsic_candidate()) {
5916               tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
5917               &quot;but the method is not annotated with @HotSpotIntrinsicCandidate.%s&quot;,
5918               method-&gt;name_and_sig_as_C_string(),
5919               NOT_DEBUG(&quot; Method will not be inlined.&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
5920             );
5921           tty-&gt;cr();
5922           DEBUG_ONLY(vm_exit(1));
5923         }
5924         // Check is the method &#39;method&#39; is annotated with @HotSpotIntrinsicCandidate,
5925         // but there is no intrinsic available for it.
5926         if (method-&gt;intrinsic_candidate() &amp;&amp;
5927           method-&gt;intrinsic_id() == vmIntrinsics::_none) {
5928             tty-&gt;print(&quot;Method [%s] is annotated with @HotSpotIntrinsicCandidate, &quot;
5929               &quot;but no compiler intrinsic is defined for the method.%s&quot;,
5930               method-&gt;name_and_sig_as_C_string(),
5931               NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
5932             );
5933           tty-&gt;cr();
5934           DEBUG_ONLY(vm_exit(1));
5935         }
5936       }
5937     } // end for
5938 
5939 #ifdef ASSERT
5940     if (CheckIntrinsics) {
5941       // Check for orphan methods in the current class. A method m
5942       // of a class C is orphan if an intrinsic is defined for method m,
5943       // but class C does not declare m.
5944       // The check is potentially expensive, therefore it is available
5945       // only in debug builds.
5946 
5947       for (int id = vmIntrinsics::FIRST_ID; id &lt; (int)vmIntrinsics::ID_LIMIT; ++id) {
5948         if (vmIntrinsics::_compiledLambdaForm == id) {
5949           // The _compiledLamdbdaForm intrinsic is a special marker for bytecode
5950           // generated for the JVM from a LambdaForm and therefore no method
5951           // is defined for it.
5952           continue;
5953         }
5954 
5955         if (vmIntrinsics::class_for(vmIntrinsics::ID_from(id)) == klass_id) {
5956           // Check if the current class contains a method with the same
5957           // name, flags, signature.
5958           bool match = false;
5959           for (int j = 0; j &lt; methods-&gt;length(); ++j) {
5960             const Method* method = methods-&gt;at(j);
5961             if (method-&gt;intrinsic_id() == id) {
5962               match = true;
5963               break;
5964             }
5965           }
5966 
5967           if (!match) {
5968             char buf[1000];
5969             tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
5970                        &quot;but the method is not available in class [%s].%s&quot;,
5971                         vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID_from(id),
5972                                                              buf, sizeof(buf)),
5973                         ik-&gt;name()-&gt;as_C_string(),
5974                         NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
5975             );
5976             tty-&gt;cr();
5977             DEBUG_ONLY(vm_exit(1));
5978           }
5979         }
5980       } // end for
5981     } // CheckIntrinsics
5982 #endif // ASSERT
5983   }
5984 }
5985 
<a name="10" id="anc10"></a>
5986 InstanceKlass* ClassFileParser::create_instance_klass(bool changed_by_loadhook, TRAPS) {
5987   if (_klass != NULL) {
5988     return _klass;
5989   }
5990 
5991   InstanceKlass* const ik =
5992     InstanceKlass::allocate_instance_klass(*this, CHECK_NULL);
5993 
5994   fill_instance_klass(ik, changed_by_loadhook, CHECK_NULL);
5995 
5996   assert(_klass == ik, &quot;invariant&quot;);
5997 
5998 
5999   if (ik-&gt;should_store_fingerprint()) {
6000     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
6001   }
6002 
6003   ik-&gt;set_has_passed_fingerprint_check(false);
6004   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
6005     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
6006     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
6007     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
6008       // This class matches with a class saved in an AOT library
6009       ik-&gt;set_has_passed_fingerprint_check(true);
6010     } else {
6011       ResourceMark rm;
6012       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
6013                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
6014     }
6015   }
6016 
6017   if (ik-&gt;is_value()) {
6018     ValueKlass* vk = ValueKlass::cast(ik);
6019     oop val = ik-&gt;allocate_instance(CHECK_NULL);
6020     vk-&gt;set_default_value(val);
6021   }
6022 
6023   return ik;
6024 }
6025 
6026 void ClassFileParser::fill_instance_klass(InstanceKlass* ik, bool changed_by_loadhook, TRAPS) {
6027   assert(ik != NULL, &quot;invariant&quot;);
6028 
6029   // Set name and CLD before adding to CLD
6030   ik-&gt;set_class_loader_data(_loader_data);
6031   ik-&gt;set_name(_class_name);
6032 
6033   // Add all classes to our internal class loader list here,
6034   // including classes in the bootstrap (NULL) class loader.
6035   const bool publicize = !is_internal();
6036 
6037   _loader_data-&gt;add_class(ik, publicize);
6038 
6039   set_klass_to_deallocate(ik);
6040 
6041   assert(_field_info != NULL, &quot;invariant&quot;);
6042   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
6043   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
6044          &quot;sanity&quot;);
6045 
6046   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
6047   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
6048 
6049   // Fill in information already parsed
6050   ik-&gt;set_should_verify_class(_need_verify);
6051 
6052   // Not yet: supers are done below to support the new subtype-checking fields
6053   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
6054   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
<a name="11" id="anc11"></a>


6055   if (_is_empty_value) {
6056     ik-&gt;set_is_empty_value();
6057   }
6058   assert(_fac != NULL, &quot;invariant&quot;);
6059   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);
6060 
6061   // this transfers ownership of a lot of arrays from
6062   // the parser onto the InstanceKlass*
6063   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6064 
6065   // note that is not safe to use the fields in the parser from this point on
6066   assert(NULL == _cp, &quot;invariant&quot;);
6067   assert(NULL == _fields, &quot;invariant&quot;);
6068   assert(NULL == _methods, &quot;invariant&quot;);
6069   assert(NULL == _inner_classes, &quot;invariant&quot;);
6070   assert(NULL == _nest_members, &quot;invariant&quot;);
6071   assert(NULL == _local_interfaces, &quot;invariant&quot;);
6072   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6073   assert(NULL == _record_components, &quot;invariant&quot;);
6074 
6075   if (_has_final_method) {
6076     ik-&gt;set_has_final_method();
6077   }
6078 
6079   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
6080   // The InstanceKlass::_methods_jmethod_ids cache
6081   // is managed on the assumption that the initial cache
6082   // size is equal to the number of methods in the class. If
6083   // that changes, then InstanceKlass::idnum_can_increment()
6084   // has to be changed accordingly.
6085   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
6086 
6087   ik-&gt;set_this_class_index(_this_class_index);
6088 
6089   if (is_unsafe_anonymous()) {
6090     // _this_class_index is a CONSTANT_Class entry that refers to this
6091     // anonymous class itself. If this class needs to refer to its own methods or
6092     // fields, it would use a CONSTANT_MethodRef, etc, which would reference
6093     // _this_class_index. However, because this class is anonymous (it&#39;s
6094     // not stored in SystemDictionary), _this_class_index cannot be resolved
6095     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
6096     // Therefore, we must eagerly resolve _this_class_index now.
6097     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
6098   }
6099 
6100   ik-&gt;set_minor_version(_minor_version);
6101   ik-&gt;set_major_version(_major_version);
6102   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
6103   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);
<a name="12" id="anc12"></a>


6104 
6105   if (_unsafe_anonymous_host != NULL) {
6106     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
6107     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
6108   }
6109 
6110   // Set PackageEntry for this_klass
6111   oop cl = ik-&gt;class_loader();
6112   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
6113   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
6114   ik-&gt;set_package(cld, CHECK);
6115 
6116   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
6117   assert(methods != NULL, &quot;invariant&quot;);
6118   const int methods_len = methods-&gt;length();
6119 
6120   check_methods_for_intrinsics(ik, methods);
6121 
6122   // Fill in field values obtained by parse_classfile_attributes
6123   if (_parsed_annotations-&gt;has_any_annotations()) {
6124     _parsed_annotations-&gt;apply_to(ik);
6125   }
6126 
6127   apply_parsed_class_attributes(ik);
6128 
6129   // Miranda methods
6130   if ((_num_miranda_methods &gt; 0) ||
6131       // if this class introduced new miranda methods or
6132       (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_miranda_methods())
6133         // super class exists and this class inherited miranda methods
6134      ) {
6135        ik-&gt;set_has_miranda_methods(); // then set a flag
6136   }
6137 
6138   // Fill in information needed to compute superclasses.
6139   ik-&gt;initialize_supers(const_cast&lt;InstanceKlass*&gt;(_super_klass), _transitive_interfaces, CHECK);
6140   ik-&gt;set_transitive_interfaces(_transitive_interfaces);
6141   _transitive_interfaces = NULL;
6142 
6143   // Initialize itable offset tables
6144   klassItable::setup_itable_offset_table(ik);
6145 
6146   // Compute transitive closure of interfaces this class implements
6147   // Do final class setup
6148   OopMapBlocksBuilder* oop_map_blocks = _field_info-&gt;oop_map_blocks;
6149   if (oop_map_blocks-&gt;_nonstatic_oop_map_count &gt; 0) {
6150     oop_map_blocks-&gt;copy(ik-&gt;start_of_nonstatic_oop_maps());
6151   }
6152 
6153   if (_has_contended_fields || _parsed_annotations-&gt;is_contended() ||
6154       ( _super_klass != NULL &amp;&amp; _super_klass-&gt;has_contended_annotations())) {
6155     ik-&gt;set_has_contended_annotations(true);
6156   }
6157 
6158   // Fill in has_finalizer, has_vanilla_constructor, and layout_helper
6159   set_precomputed_flags(ik);
6160 
6161   // check if this class can access its super class
6162   check_super_class_access(ik, CHECK);
6163 
6164   // check if this class can access its superinterfaces
6165   check_super_interface_access(ik, CHECK);
6166 
6167   // check if this class overrides any final method
6168   check_final_method_override(ik, CHECK);
6169 
6170   // reject static interface methods prior to Java 8
6171   if (ik-&gt;is_interface() &amp;&amp; _major_version &lt; JAVA_8_VERSION) {
6172     check_illegal_static_method(ik, CHECK);
6173   }
6174 
6175   // Obtain this_klass&#39; module entry
6176   ModuleEntry* module_entry = ik-&gt;module();
6177   assert(module_entry != NULL, &quot;module_entry should always be set&quot;);
6178 
6179   // Obtain java.lang.Module
6180   Handle module_handle(THREAD, module_entry-&gt;module());
6181 
6182   // Allocate mirror and initialize static fields
6183   // The create_mirror() call will also call compute_modifiers()
6184   java_lang_Class::create_mirror(ik,
6185                                  Handle(THREAD, _loader_data-&gt;class_loader()),
6186                                  module_handle,
6187                                  _protection_domain,
6188                                  CHECK);
6189 
6190   assert(_all_mirandas != NULL, &quot;invariant&quot;);
6191 
6192   // Generate any default methods - default methods are public interface methods
6193   // that have a default implementation.  This is new with Java 8.
6194   if (_has_nonstatic_concrete_methods) {
6195     DefaultMethods::generate_default_methods(ik,
6196                                              _all_mirandas,
6197                                              CHECK);
6198   }
6199 
6200   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
6201   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
6202       !module_entry-&gt;has_default_read_edges()) {
6203     if (!module_entry-&gt;set_has_default_read_edges()) {
6204       // We won a potential race
6205       JvmtiExport::add_default_read_edges(module_handle, THREAD);
6206     }
6207   }
6208 
6209   int nfields = ik-&gt;java_fields_count();
6210   if (ik-&gt;is_value()) nfields++;
6211   for (int i = 0; i &lt; nfields; i++) {
6212     if (ik-&gt;field_is_flattenable(i)) {
6213       Symbol* klass_name = ik-&gt;field_signature(i)-&gt;fundamental_name(CHECK);
6214       // Inline classes for instance fields must have been pre-loaded
6215       // Inline classes for static fields might not have been loaded yet
6216       Klass* klass = SystemDictionary::find(klass_name,
6217           Handle(THREAD, ik-&gt;class_loader()),
6218           Handle(THREAD, ik-&gt;protection_domain()), CHECK);
6219       if (klass != NULL) {
6220         assert(klass-&gt;access_flags().is_value_type(), &quot;Value type expected&quot;);
6221         ik-&gt;set_value_field_klass(i, klass);
6222       }
6223       klass_name-&gt;decrement_refcount();
6224     } else
6225       if (is_value_type() &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_FIELD_INTERNAL) != 0)
6226         &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) != 0)) {
6227       ValueKlass::cast(ik)-&gt;set_default_value_offset(ik-&gt;field_offset(i));
6228     }
6229   }
6230 
6231   if (is_value_type()) {
6232     ValueKlass* vk = ValueKlass::cast(ik);
6233     if (UseNewFieldLayout) {
6234       vk-&gt;set_alignment(_alignment);
6235       vk-&gt;set_first_field_offset(_first_field_offset);
6236       vk-&gt;set_exact_size_in_bytes(_exact_size_in_bytes);
6237     } else {
6238       vk-&gt;set_first_field_offset(vk-&gt;first_field_offset_old());
6239     }
6240     ValueKlass::cast(ik)-&gt;initialize_calling_convention(CHECK);
6241   }
6242 
6243   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
6244 
6245   if (!is_internal()) {
6246     if (log_is_enabled(Info, class, load)) {
6247       ResourceMark rm;
6248       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
6249       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
6250     }
6251 
6252     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
6253         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
6254         log_is_enabled(Info, class, preview)) {
6255       ResourceMark rm;
6256       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
6257                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
6258     }
6259 
6260     if (log_is_enabled(Debug, class, resolve))  {
6261       ResourceMark rm;
6262       // print out the superclass.
6263       const char * from = ik-&gt;external_name();
6264       if (ik-&gt;java_super() != NULL) {
6265         log_debug(class, resolve)(&quot;%s %s (super)&quot;,
6266                    from,
6267                    ik-&gt;java_super()-&gt;external_name());
6268       }
6269       // print out each of the interface classes referred to by this class.
6270       const Array&lt;InstanceKlass*&gt;* const local_interfaces = ik-&gt;local_interfaces();
6271       if (local_interfaces != NULL) {
6272         const int length = local_interfaces-&gt;length();
6273         for (int i = 0; i &lt; length; i++) {
6274           const InstanceKlass* const k = local_interfaces-&gt;at(i);
6275           const char * to = k-&gt;external_name();
6276           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
6277         }
6278       }
6279     }
6280   }
6281 
6282   JFR_ONLY(INIT_ID(ik);)
6283 
6284   // If we reach here, all is well.
6285   // Now remove the InstanceKlass* from the _klass_to_deallocate field
6286   // in order for it to not be destroyed in the ClassFileParser destructor.
6287   set_klass_to_deallocate(NULL);
6288 
6289   // it&#39;s official
6290   set_klass(ik);
6291 
6292   debug_only(ik-&gt;verify();)
6293 }
6294 
6295 void ClassFileParser::update_class_name(Symbol* new_class_name) {
6296   // Decrement the refcount in the old name, since we&#39;re clobbering it.
6297   _class_name-&gt;decrement_refcount();
6298 
6299   _class_name = new_class_name;
6300   // Increment the refcount of the new name.
6301   // Now the ClassFileParser owns this name and will decrement in
6302   // the destructor.
6303   _class_name-&gt;increment_refcount();
6304 }
6305 
6306 
6307 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
6308 // package by prepending its host class&#39;s package name to its class name and setting
6309 // its _class_name field.
6310 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
6311   ResourceMark rm(THREAD);
6312   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
6313          &quot;Unsafe anonymous class should not be in a package&quot;);
6314   const char* host_pkg_name =
6315     ClassLoader::package_from_name(unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), NULL);
6316 
6317   if (host_pkg_name != NULL) {
6318     int host_pkg_len = (int)strlen(host_pkg_name);
6319     int class_name_len = _class_name-&gt;utf8_length();
6320     int symbol_len = host_pkg_len + 1 + class_name_len;
6321     char* new_anon_name = NEW_RESOURCE_ARRAY(char, symbol_len + 1);
6322     int n = os::snprintf(new_anon_name, symbol_len + 1, &quot;%s/%.*s&quot;,
6323                          host_pkg_name, class_name_len, _class_name-&gt;base());
6324     assert(n == symbol_len, &quot;Unexpected number of characters in string&quot;);
6325 
6326     // Decrement old _class_name to avoid leaking.
6327     _class_name-&gt;decrement_refcount();
6328 
6329     // Create a symbol and update the anonymous class name.
6330     // The new class name is created with a refcount of one. When installed into the InstanceKlass,
6331     // it&#39;ll be two and when the ClassFileParser destructor runs, it&#39;ll go back to one and get deleted
6332     // when the class is unloaded.
6333     _class_name = SymbolTable::new_symbol(new_anon_name, symbol_len);
6334   }
6335 }
6336 
6337 // If the host class and the anonymous class are in the same package then do
6338 // nothing.  If the anonymous class is in the unnamed package then move it to its
6339 // host&#39;s package.  If the classes are in different packages then throw an IAE
6340 // exception.
6341 void ClassFileParser::fix_unsafe_anonymous_class_name(TRAPS) {
6342   assert(_unsafe_anonymous_host != NULL, &quot;Expected an unsafe anonymous class&quot;);
6343 
6344   const jbyte* anon_last_slash = UTF8::strrchr((const jbyte*)_class_name-&gt;base(),
6345                                                _class_name-&gt;utf8_length(), JVM_SIGNATURE_SLASH);
6346   if (anon_last_slash == NULL) {  // Unnamed package
6347     prepend_host_package_name(_unsafe_anonymous_host, CHECK);
6348   } else {
6349     if (!_unsafe_anonymous_host-&gt;is_same_class_package(_unsafe_anonymous_host-&gt;class_loader(), _class_name)) {
6350       ResourceMark rm(THREAD);
6351       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
6352         err_msg(&quot;Host class %s and anonymous class %s are in different packages&quot;,
6353         _unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), _class_name-&gt;as_C_string()));
6354     }
6355   }
6356 }
6357 
6358 static bool relax_format_check_for(ClassLoaderData* loader_data) {
6359   bool trusted = (loader_data-&gt;is_the_null_class_loader_data() ||
6360                   SystemDictionary::is_platform_class_loader(loader_data-&gt;class_loader()));
6361   bool need_verify =
6362     // verifyAll
6363     (BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote) ||
6364     // verifyRemote
6365     (!BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote &amp;&amp; !trusted);
6366   return !need_verify;
6367 }
6368 
6369 ClassFileParser::ClassFileParser(ClassFileStream* stream,
6370                                  Symbol* name,
6371                                  ClassLoaderData* loader_data,
6372                                  Handle protection_domain,
6373                                  const InstanceKlass* unsafe_anonymous_host,
6374                                  GrowableArray&lt;Handle&gt;* cp_patches,
6375                                  Publicity pub_level,
6376                                  TRAPS) :
6377   _stream(stream),
6378   _requested_name(name),
6379   _class_name(NULL),
6380   _loader_data(loader_data),
6381   _unsafe_anonymous_host(unsafe_anonymous_host),
6382   _cp_patches(cp_patches),
6383   _num_patched_klasses(0),
6384   _max_num_patched_klasses(0),
6385   _orig_cp_size(0),
6386   _first_patched_klass_resolved_index(0),
6387   _super_klass(),
6388   _cp(NULL),
6389   _fields(NULL),
6390   _methods(NULL),
6391   _inner_classes(NULL),
6392   _nest_members(NULL),
6393   _nest_host(0),
6394   _record_components(NULL),
6395   _local_interfaces(NULL),
6396   _transitive_interfaces(NULL),
6397   _combined_annotations(NULL),
6398   _class_annotations(NULL),
6399   _class_type_annotations(NULL),
6400   _fields_annotations(NULL),
6401   _fields_type_annotations(NULL),
6402   _klass(NULL),
6403   _klass_to_deallocate(NULL),
6404   _parsed_annotations(NULL),
6405   _fac(NULL),
6406   _field_info(NULL),
6407   _method_ordering(NULL),
6408   _all_mirandas(NULL),
6409   _vtable_size(0),
6410   _itable_size(0),
6411   _num_miranda_methods(0),
6412   _rt(REF_NONE),
6413   _protection_domain(protection_domain),
6414   _access_flags(),
6415   _pub_level(pub_level),
6416   _bad_constant_seen(0),
6417   _synthetic_flag(false),
6418   _sde_length(false),
6419   _sde_buffer(NULL),
6420   _sourcefile_index(0),
6421   _generic_signature_index(0),
6422   _major_version(0),
6423   _minor_version(0),
6424   _this_class_index(0),
6425   _super_class_index(0),
6426   _itfs_len(0),
6427   _java_fields_count(0),
6428   _need_verify(false),
6429   _relax_verify(false),
6430   _has_nonstatic_concrete_methods(false),
6431   _declares_nonstatic_concrete_methods(false),
6432   _has_final_method(false),
6433   _has_contended_fields(false),
6434   _has_flattenable_fields(false),
6435   _is_empty_value(false),
<a name="13" id="anc13"></a>

6436   _has_finalizer(false),
6437   _has_empty_finalizer(false),
6438   _has_vanilla_constructor(false),
6439   _max_bootstrap_specifier_index(-1) {
6440 
6441   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6442   _class_name-&gt;increment_refcount();
6443 
6444   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6445   assert(_loader_data != NULL, &quot;invariant&quot;);
6446   assert(stream != NULL, &quot;invariant&quot;);
6447   assert(_stream != NULL, &quot;invariant&quot;);
6448   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6449   assert(_class_name != NULL, &quot;invariant&quot;);
6450   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6451 
6452   // Figure out whether we can skip format checking (matching classic VM behavior)
6453   if (DumpSharedSpaces) {
6454     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6455     // Verification decision is based on BytecodeVerificationRemote flag
6456     // for those classes.
6457     _need_verify = (stream-&gt;need_verify()) ? BytecodeVerificationRemote :
6458                                               BytecodeVerificationLocal;
6459   }
6460   else {
6461     _need_verify = Verifier::should_verify_for(_loader_data-&gt;class_loader(),
6462                                                stream-&gt;need_verify());
6463   }
6464   if (_cp_patches != NULL) {
6465     int len = _cp_patches-&gt;length();
6466     for (int i=0; i&lt;len; i++) {
6467       if (has_cp_patch_at(i)) {
6468         Handle patch = cp_patch_at(i);
6469         if (java_lang_String::is_instance(patch()) || java_lang_Class::is_instance(patch())) {
6470           // We need to append the names of the patched classes to the end of the constant pool,
6471           // because a patched class may have a Utf8 name that&#39;s not already included in the
6472           // original constant pool. These class names are used when patch_constant_pool()
6473           // calls patch_class().
6474           //
6475           // Note that a String in cp_patch_at(i) may be used to patch a Utf8, a String, or a Class.
6476           // At this point, we don&#39;t know the tag for index i yet, because we haven&#39;t parsed the
6477           // constant pool. So we can only assume the worst -- every String is used to patch a Class.
6478           _max_num_patched_klasses++;
6479         }
6480       }
6481     }
6482   }
6483 
6484   // synch back verification state to stream
6485   stream-&gt;set_verify(_need_verify);
6486 
6487   // Check if verification needs to be relaxed for this class file
6488   // Do not restrict it to jdk1.0 or jdk1.1 to maintain backward compatibility (4982376)
6489   _relax_verify = relax_format_check_for(_loader_data);
6490 
6491   parse_stream(stream, CHECK);
6492 
6493   post_process_parsed_stream(stream, _cp, CHECK);
6494 }
6495 
6496 void ClassFileParser::clear_class_metadata() {
6497   // metadata created before the instance klass is created.  Must be
6498   // deallocated if classfile parsing returns an error.
6499   _cp = NULL;
6500   _fields = NULL;
6501   _methods = NULL;
6502   _inner_classes = NULL;
6503   _nest_members = NULL;
6504   _local_interfaces = NULL;
6505   _combined_annotations = NULL;
6506   _class_annotations = _class_type_annotations = NULL;
6507   _fields_annotations = _fields_type_annotations = NULL;
6508   _record_components = NULL;
6509 }
6510 
6511 // Destructor to clean up
6512 ClassFileParser::~ClassFileParser() {
6513   _class_name-&gt;decrement_refcount();
6514 
6515   if (_cp != NULL) {
6516     MetadataFactory::free_metadata(_loader_data, _cp);
6517   }
6518   if (_fields != NULL) {
6519     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _fields);
6520   }
6521 
6522   if (_methods != NULL) {
6523     // Free methods
6524     InstanceKlass::deallocate_methods(_loader_data, _methods);
6525   }
6526 
6527   // beware of the Universe::empty_blah_array!!
6528   if (_inner_classes != NULL &amp;&amp; _inner_classes != Universe::the_empty_short_array()) {
6529     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _inner_classes);
6530   }
6531 
6532   if (_nest_members != NULL &amp;&amp; _nest_members != Universe::the_empty_short_array()) {
6533     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _nest_members);
6534   }
6535 
6536   if (_record_components != NULL) {
6537     InstanceKlass::deallocate_record_components(_loader_data, _record_components);
6538   }
6539 
6540   // Free interfaces
6541   InstanceKlass::deallocate_interfaces(_loader_data, _super_klass,
6542                                        _local_interfaces, _transitive_interfaces);
6543 
6544   if (_combined_annotations != NULL) {
6545     // After all annotations arrays have been created, they are installed into the
6546     // Annotations object that will be assigned to the InstanceKlass being created.
6547 
6548     // Deallocate the Annotations object and the installed annotations arrays.
6549     _combined_annotations-&gt;deallocate_contents(_loader_data);
6550 
6551     // If the _combined_annotations pointer is non-NULL,
6552     // then the other annotations fields should have been cleared.
6553     assert(_class_annotations       == NULL, &quot;Should have been cleared&quot;);
6554     assert(_class_type_annotations  == NULL, &quot;Should have been cleared&quot;);
6555     assert(_fields_annotations      == NULL, &quot;Should have been cleared&quot;);
6556     assert(_fields_type_annotations == NULL, &quot;Should have been cleared&quot;);
6557   } else {
6558     // If the annotations arrays were not installed into the Annotations object,
6559     // then they have to be deallocated explicitly.
6560     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_annotations);
6561     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_type_annotations);
6562     Annotations::free_contents(_loader_data, _fields_annotations);
6563     Annotations::free_contents(_loader_data, _fields_type_annotations);
6564   }
6565 
6566   clear_class_metadata();
6567   _transitive_interfaces = NULL;
6568 
6569   // deallocate the klass if already created.  Don&#39;t directly deallocate, but add
6570   // to the deallocate list so that the klass is removed from the CLD::_klasses list
6571   // at a safepoint.
6572   if (_klass_to_deallocate != NULL) {
6573     _loader_data-&gt;add_to_deallocate_list(_klass_to_deallocate);
6574   }
6575 }
6576 
6577 void ClassFileParser::parse_stream(const ClassFileStream* const stream,
6578                                    TRAPS) {
6579 
6580   assert(stream != NULL, &quot;invariant&quot;);
6581   assert(_class_name != NULL, &quot;invariant&quot;);
6582 
6583   // BEGIN STREAM PARSING
6584   stream-&gt;guarantee_more(8, CHECK);  // magic, major, minor
6585   // Magic value
6586   const u4 magic = stream-&gt;get_u4_fast();
6587   guarantee_property(magic == JAVA_CLASSFILE_MAGIC,
6588                      &quot;Incompatible magic value %u in class file %s&quot;,
6589                      magic, CHECK);
6590 
6591   // Version numbers
6592   _minor_version = stream-&gt;get_u2_fast();
6593   _major_version = stream-&gt;get_u2_fast();
6594 
6595   if (DumpSharedSpaces &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6596     ResourceMark rm;
6597     warning(&quot;Pre JDK 6 class not supported by CDS: %u.%u %s&quot;,
6598             _major_version,  _minor_version, _class_name-&gt;as_C_string());
6599     Exceptions::fthrow(
6600       THREAD_AND_LOCATION,
6601       vmSymbols::java_lang_UnsupportedClassVersionError(),
6602       &quot;Unsupported major.minor version for dump time %u.%u&quot;,
6603       _major_version,
6604       _minor_version);
6605   }
6606 
6607   // Check version numbers - we check this even with verifier off
6608   verify_class_version(_major_version, _minor_version, _class_name, CHECK);
6609 
6610   stream-&gt;guarantee_more(3, CHECK); // length, first cp tag
6611   u2 cp_size = stream-&gt;get_u2_fast();
6612 
6613   guarantee_property(
6614     cp_size &gt;= 1, &quot;Illegal constant pool size %u in class file %s&quot;,
6615     cp_size, CHECK);
6616 
6617   _orig_cp_size = cp_size;
6618   if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
6619     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
6620   }
6621   cp_size += _max_num_patched_klasses;
6622 
6623   _cp = ConstantPool::allocate(_loader_data,
6624                                cp_size,
6625                                CHECK);
6626 
6627   ConstantPool* const cp = _cp;
6628 
6629   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6630 
6631   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6632 
6633   // ACCESS FLAGS
6634   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6635 
6636   jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;
6637   // JVM_ACC_MODULE is defined in JDK-9 and later.
6638   if (_major_version &gt;= JAVA_9_VERSION) {
6639     recognized_modifiers |= JVM_ACC_MODULE;
6640   }
6641   // JVM_ACC_VALUE is defined for class file version 55 and later
6642   if (supports_value_types()) {
6643     recognized_modifiers |= JVM_ACC_VALUE;
6644   }
6645 
6646   // Access flags
6647   jint flags = stream-&gt;get_u2_fast() &amp; recognized_modifiers;
6648 
6649   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6650     // Set abstract bit for old class files for backward compatibility
6651     flags |= JVM_ACC_ABSTRACT;
6652   }
6653 
6654   verify_legal_class_modifiers(flags, CHECK);
6655 
6656   short bad_constant = class_bad_constant_seen();
6657   if (bad_constant != 0) {
6658     // Do not throw CFE until after the access_flags are checked because if
6659     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6660     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6661   }
6662 
6663   _access_flags.set_flags(flags);
6664 
6665   // This class and superclass
6666   _this_class_index = stream-&gt;get_u2_fast();
6667   check_property(
6668     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
6669       cp-&gt;tag_at(_this_class_index).is_unresolved_klass(),
6670     &quot;Invalid this class index %u in constant pool in class file %s&quot;,
6671     _this_class_index, CHECK);
6672 
6673   Symbol* const class_name_in_cp = cp-&gt;klass_name_at(_this_class_index);
6674   assert(class_name_in_cp != NULL, &quot;class_name can&#39;t be null&quot;);
6675 
6676   // Update _class_name to reflect the name in the constant pool
6677   update_class_name(class_name_in_cp);
6678 
6679   // Don&#39;t need to check whether this class name is legal or not.
6680   // It has been checked when constant pool is parsed.
6681   // However, make sure it is not an array type.
6682   if (_need_verify) {
6683     guarantee_property(_class_name-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
6684                        &quot;Bad class name in class file %s&quot;,
6685                        CHECK);
6686   }
6687 
6688   // Checks if name in class file matches requested name
6689   if (_requested_name != NULL &amp;&amp; _requested_name != _class_name) {
6690     ResourceMark rm(THREAD);
6691     Exceptions::fthrow(
6692       THREAD_AND_LOCATION,
6693       vmSymbols::java_lang_NoClassDefFoundError(),
6694       &quot;%s (wrong name: %s)&quot;,
6695       _class_name-&gt;as_C_string(),
6696       _requested_name != NULL ? _requested_name-&gt;as_C_string() : &quot;NoName&quot;
6697     );
6698     return;
6699   }
6700 
6701   // if this is an anonymous class fix up its name if it&#39;s in the unnamed
6702   // package.  Otherwise, throw IAE if it is in a different package than
6703   // its host class.
6704   if (_unsafe_anonymous_host != NULL) {
6705     fix_unsafe_anonymous_class_name(CHECK);
6706   }
6707 
6708   // Verification prevents us from creating names with dots in them, this
6709   // asserts that that&#39;s the case.
6710   assert(is_internal_format(_class_name), &quot;external class name format used internally&quot;);
6711 
6712   if (!is_internal()) {
6713     LogTarget(Debug, class, preorder) lt;
6714     if (lt.is_enabled()){
6715       ResourceMark rm(THREAD);
6716       LogStream ls(lt);
6717       ls.print(&quot;%s&quot;, _class_name-&gt;as_klass_external_name());
6718       if (stream-&gt;source() != NULL) {
6719         ls.print(&quot; source: %s&quot;, stream-&gt;source());
6720       }
6721       ls.cr();
6722     }
6723 
6724 #if INCLUDE_CDS
6725     if (DumpLoadedClassList != NULL &amp;&amp; stream-&gt;source() != NULL &amp;&amp; classlist_file-&gt;is_open()) {
6726       if (!ClassLoader::has_jrt_entry()) {
6727         warning(&quot;DumpLoadedClassList and CDS are not supported in exploded build&quot;);
6728         DumpLoadedClassList = NULL;
6729       } else if (SystemDictionaryShared::is_sharing_possible(_loader_data) &amp;&amp;
6730                  _unsafe_anonymous_host == NULL) {
6731         // Only dump the classes that can be stored into CDS archive.
6732         // Unsafe anonymous classes such as generated LambdaForm classes are also not included.
6733         oop class_loader = _loader_data-&gt;class_loader();
6734         ResourceMark rm(THREAD);
6735         bool skip = false;
6736         if (class_loader == NULL || SystemDictionary::is_platform_class_loader(class_loader)) {
6737           // For the boot and platform class loaders, skip classes that are not found in the
6738           // java runtime image, such as those found in the --patch-module entries.
6739           // These classes can&#39;t be loaded from the archive during runtime.
6740           if (!stream-&gt;from_boot_loader_modules_image() &amp;&amp; strncmp(stream-&gt;source(), &quot;jrt:&quot;, 4) != 0) {
6741             skip = true;
6742           }
6743 
6744           if (class_loader == NULL &amp;&amp; ClassLoader::contains_append_entry(stream-&gt;source())) {
6745             // .. but don&#39;t skip the boot classes that are loaded from -Xbootclasspath/a
6746             // as they can be loaded from the archive during runtime.
6747             skip = false;
6748           }
6749         }
6750         if (skip) {
6751           tty-&gt;print_cr(&quot;skip writing class %s from source %s to classlist file&quot;,
6752             _class_name-&gt;as_C_string(), stream-&gt;source());
6753         } else {
6754           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
6755           classlist_file-&gt;flush();
6756         }
6757       }
6758     }
6759 #endif
6760   }
6761 
6762   // SUPERKLASS
6763   _super_class_index = stream-&gt;get_u2_fast();
6764   _super_klass = parse_super_class(cp,
6765                                    _super_class_index,
6766                                    _need_verify,
6767                                    CHECK);
6768 
6769   // Interfaces
6770   _itfs_len = stream-&gt;get_u2_fast();
6771   parse_interfaces(stream,
6772                    _itfs_len,
6773                    cp,
6774                    &amp;_has_nonstatic_concrete_methods,
<a name="14" id="anc14"></a>
6775                    CHECK);
6776 
6777   assert(_local_interfaces != NULL, &quot;invariant&quot;);
6778 
6779   // Fields (offsets are filled in later)
6780   _fac = new FieldAllocationCount();
6781   parse_fields(stream,
<a name="15" id="anc15"></a><span class="line-modified">6782                _access_flags.is_interface(),</span>
<span class="line-modified">6783                _access_flags.is_value_type(),</span>
6784                _fac,
6785                cp,
6786                cp_size,
6787                &amp;_java_fields_count,
6788                CHECK);
6789 
6790   assert(_fields != NULL, &quot;invariant&quot;);
6791 
6792   // Methods
6793   AccessFlags promoted_flags;
6794   parse_methods(stream,
<a name="16" id="anc16"></a><span class="line-modified">6795                 _access_flags.is_interface(),</span>
<span class="line-modified">6796                 _access_flags.is_value_type(),</span>
6797                 &amp;promoted_flags,
6798                 &amp;_has_final_method,
6799                 &amp;_declares_nonstatic_concrete_methods,
6800                 CHECK);
6801 
6802   assert(_methods != NULL, &quot;invariant&quot;);
6803 
6804   // promote flags from parse_methods() to the klass&#39; flags
6805   _access_flags.add_promoted_flags(promoted_flags.as_int());
6806 
6807   if (_declares_nonstatic_concrete_methods) {
6808     _has_nonstatic_concrete_methods = true;
6809   }
6810 
6811   // Additional attributes/annotations
6812   _parsed_annotations = new ClassAnnotationCollector();
6813   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6814 
6815   assert(_inner_classes != NULL, &quot;invariant&quot;);
6816 
6817   // Finalize the Annotations metadata object,
6818   // now that all annotation arrays have been created.
6819   create_combined_annotations(CHECK);
6820 
6821   // Make sure this is the end of class file stream
6822   guarantee_property(stream-&gt;at_eos(),
6823                      &quot;Extra bytes at the end of class file %s&quot;,
6824                      CHECK);
6825 
6826   // all bytes in stream read and parsed
6827 }
6828 
6829 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6830                                                  ConstantPool* cp,
6831                                                  TRAPS) {
6832   assert(stream != NULL, &quot;invariant&quot;);
6833   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6834   assert(cp != NULL, &quot;invariant&quot;);
6835   assert(_loader_data != NULL, &quot;invariant&quot;);
6836 
6837   if (_class_name == vmSymbols::java_lang_Object()) {
6838     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),
6839                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,
6840                    CHECK);
6841   }
6842   // We check super class after class file is parsed and format is checked
6843   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6844     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
<a name="17" id="anc17"></a><span class="line-modified">6845     if (_access_flags.is_interface()) {</span>
6846       // Before attempting to resolve the superclass, check for class format
6847       // errors not checked yet.
6848       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6849         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6850         CHECK);
6851     }
6852     Handle loader(THREAD, _loader_data-&gt;class_loader());
6853     _super_klass = (const InstanceKlass*)
6854                        SystemDictionary::resolve_super_or_fail(_class_name,
6855                                                                super_class_name,
6856                                                                loader,
6857                                                                _protection_domain,
6858                                                                true,
6859                                                                CHECK);
6860   }
6861 
6862   if (_super_klass != NULL) {
6863     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
6864       _has_nonstatic_concrete_methods = true;
6865     }
<a name="18" id="anc18"></a>


6866 
6867     if (_super_klass-&gt;is_interface()) {
6868       ResourceMark rm(THREAD);
6869       Exceptions::fthrow(
6870         THREAD_AND_LOCATION,
6871         vmSymbols::java_lang_IncompatibleClassChangeError(),
6872         &quot;class %s has interface %s as super class&quot;,
6873         _class_name-&gt;as_klass_external_name(),
6874         _super_klass-&gt;external_name()
6875       );
6876       return;
6877     }
6878 
6879     // For a value class, only java/lang/Object is an acceptable super class
6880     if (_access_flags.get_flags() &amp; JVM_ACC_VALUE) {
6881       guarantee_property(_super_klass-&gt;name() == vmSymbols::java_lang_Object(),
6882         &quot;Value type must have java.lang.Object as superclass in class file %s&quot;,
6883         CHECK);
6884     }
6885 
6886     // Make sure super class is not final
6887     if (_super_klass-&gt;is_final()) {
6888       THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
6889     }
6890   }
6891 
<a name="19" id="anc19"></a>











6892   // Compute the transitive list of all unique interfaces implemented by this class
6893   _transitive_interfaces =
6894     compute_transitive_interfaces(_super_klass,
6895                                   _local_interfaces,
6896                                   _loader_data,
6897                                   CHECK);
6898 
6899   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
6900 
6901   // sort methods
6902   _method_ordering = sort_methods(_methods);
6903 
6904   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
6905 
6906   Handle loader(THREAD, _loader_data-&gt;class_loader());
6907   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6908                                                     &amp;_num_miranda_methods,
6909                                                     _all_mirandas,
6910                                                     _super_klass,
6911                                                     _methods,
6912                                                     _access_flags,
6913                                                     _major_version,
6914                                                     loader,
6915                                                     _class_name,
6916                                                     _local_interfaces,
6917                                                     CHECK);
6918 
6919   // Size of Java itable (in words)
<a name="20" id="anc20"></a><span class="line-modified">6920   _itable_size = _access_flags.is_interface() ? 0 :</span>
6921     klassItable::compute_itable_size(_transitive_interfaces);
6922 
6923   assert(_fac != NULL, &quot;invariant&quot;);
6924   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
6925 
6926 
6927   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
6928     if (fs.is_flattenable() &amp;&amp; !fs.access_flags().is_static()) {
6929       // Pre-load value class
6930       Klass* klass = SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
6931           Handle(THREAD, _loader_data-&gt;class_loader()),
6932           _protection_domain, true, CHECK);
6933       assert(klass != NULL, &quot;Sanity check&quot;);
6934       assert(klass-&gt;access_flags().is_value_type(), &quot;Value type expected&quot;);
6935       _has_flattenable_fields = true;
6936     }
6937   }
6938 
6939   _field_info = new FieldLayoutInfo();
6940   if (UseNewFieldLayout) {
6941     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
6942         _parsed_annotations-&gt;is_contended(), is_value_type(),
6943         loader_data(), _protection_domain, _field_info);
6944     lb.build_layout(CHECK);
6945     if (is_value_type()) {
6946       _alignment = lb.get_alignment();
6947       _first_field_offset = lb.get_first_field_offset();
6948       _exact_size_in_bytes = lb.get_exact_size_in_byte();
6949     }
6950   } else {
6951     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
6952   }
6953 
6954   // Compute reference type
6955   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
6956 
6957 }
6958 
6959 void ClassFileParser::set_klass(InstanceKlass* klass) {
6960 
6961 #ifdef ASSERT
6962   if (klass != NULL) {
6963     assert(NULL == _klass, &quot;leaking?&quot;);
6964   }
6965 #endif
6966 
6967   _klass = klass;
6968 }
6969 
6970 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
6971 
6972 #ifdef ASSERT
6973   if (klass != NULL) {
6974     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
6975   }
6976 #endif
6977 
6978   _klass_to_deallocate = klass;
6979 }
6980 
6981 // Caller responsible for ResourceMark
6982 // clone stream with rewound position
6983 const ClassFileStream* ClassFileParser::clone_stream() const {
6984   assert(_stream != NULL, &quot;invariant&quot;);
6985 
6986   return _stream-&gt;clone();
6987 }
6988 
6989 // ----------------------------------------------------------------------------
6990 // debugging
6991 
6992 #ifdef ASSERT
6993 
6994 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
6995 bool ClassFileParser::is_internal_format(Symbol* class_name) {
6996   if (class_name != NULL) {
6997     ResourceMark rm;
6998     char* name = class_name-&gt;as_C_string();
6999     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
7000   } else {
7001     return true;
7002   }
7003 }
7004 
7005 #endif
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
diff a/src/hotspot/cpu/aarch64/templateTable_aarch64.cpp b/src/hotspot/cpu/aarch64/templateTable_aarch64.cpp
--- a/src/hotspot/cpu/aarch64/templateTable_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/templateTable_aarch64.cpp
@@ -808,11 +808,11 @@
   __ mov(r1, r0);
   __ pop_ptr(r0);
   // r0: array
   // r1: index
   index_check(r0, r1); // leaves index in r1, kills rscratch1
-  if (ValueArrayFlatten) {
+  if (InlineArrayFlatten) {
     Label is_flat_array, done;
 
     __ test_flattened_array_oop(r0, r8 /*temp*/, is_flat_array);
     __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) >> LogBytesPerHeapOop);
     do_oop_load(_masm, Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)), r0, IS_ARRAY);
@@ -1127,11 +1127,11 @@
 
   // do array store check - check for NULL value first
   __ cbz(r0, is_null);
 
   Label  is_flat_array;
-  if (ValueArrayFlatten) {
+  if (InlineArrayFlatten) {
     __ test_flattened_array_oop(r3, r8 /*temp*/, is_flat_array);
   }
 
   // Move subklass into r1
   __ load_klass(r1, r0);
diff a/src/hotspot/cpu/x86/templateTable_x86.cpp b/src/hotspot/cpu/x86/templateTable_x86.cpp
--- a/src/hotspot/cpu/x86/templateTable_x86.cpp
+++ b/src/hotspot/cpu/x86/templateTable_x86.cpp
@@ -825,11 +825,11 @@
   Register array = rdx;
   Register index = rax;
 
   index_check(array, index); // kills rbx
   __ profile_array(rbx, array, rcx);
-  if (ValueArrayFlatten) {
+  if (InlineArrayFlatten) {
     Label is_flat_array, done;
     __ test_flattened_array_oop(array, rbx, is_flat_array);
     do_oop_load(_masm,
                 Address(array, index,
                         UseCompressedOops ? Address::times_4 : Address::times_ptr,
@@ -1154,11 +1154,11 @@
   __ jcc(Assembler::zero, is_null);
 
   // Move array class to rdi
   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
   __ load_klass(rdi, rdx, tmp_load_klass);
-  if (ValueArrayFlatten) {
+  if (InlineArrayFlatten) {
     __ movl(rbx, Address(rdi, Klass::layout_helper_offset()));
     __ test_flattened_array_layout(rbx, is_flat_array);
   }
 
   // Move subklass into rbx
diff a/src/hotspot/share/c1/c1_Instruction.cpp b/src/hotspot/share/c1/c1_Instruction.cpp
--- a/src/hotspot/share/c1/c1_Instruction.cpp
+++ b/src/hotspot/share/c1/c1_Instruction.cpp
@@ -125,19 +125,19 @@
   }
   return NULL;
 }
 
 bool Instruction::is_loaded_flattened_array() const {
-  if (ValueArrayFlatten) {
+  if (InlineArrayFlatten) {
     ciType* type = declared_type();
     return type != NULL && type->is_value_array_klass();
   }
   return false;
 }
 
 bool Instruction::maybe_flattened_array() {
-  if (ValueArrayFlatten) {
+  if (InlineArrayFlatten) {
     ciType* type = declared_type();
     if (type != NULL) {
       if (type->is_obj_array_klass()) {
         // Due to array covariance, the runtime type might be a flattened array.
         ciKlass* element_klass = type->as_obj_array_klass()->element_klass();
diff a/src/hotspot/share/c1/c1_Runtime1.cpp b/src/hotspot/share/c1/c1_Runtime1.cpp
--- a/src/hotspot/share/c1/c1_Runtime1.cpp
+++ b/src/hotspot/share/c1/c1_Runtime1.cpp
@@ -50,15 +50,15 @@
 #include "memory/allocation.inline.hpp"
 #include "memory/oopFactory.hpp"
 #include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
 #include "oops/access.inline.hpp"
+#include "oops/inlineArrayKlass.hpp"
+#include "oops/inlineArrayOop.inline.hpp"
 #include "oops/objArrayOop.inline.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "oops/oop.inline.hpp"
-#include "oops/valueArrayKlass.hpp"
-#include "oops/valueArrayOop.inline.hpp"
 #include "runtime/atomic.hpp"
 #include "runtime/biasedLocking.hpp"
 #include "runtime/fieldDescriptor.inline.hpp"
 #include "runtime/frame.inline.hpp"
 #include "runtime/handles.inline.hpp"
@@ -423,11 +423,11 @@
   Handle holder(THREAD, array_klass->klass_holder()); // keep the klass alive
   Klass* elem_klass = ArrayKlass::cast(array_klass)->element_klass();
   assert(elem_klass->is_inline_klass(), "must be");
   // Logically creates elements, ensure klass init
   elem_klass->initialize(CHECK);
-  arrayOop obj = oopFactory::new_valueArray(elem_klass, length, CHECK);
+  arrayOop obj = oopFactory::new_inlineArray(elem_klass, length, CHECK);
   thread->set_vm_result(obj);
   // This is pretty rare but this runtime patch is stressful to deoptimization
   // if we deoptimize here so force a deopt to stress the path.
   if (DeoptimizeALot) {
     deopt_caller();
@@ -459,33 +459,33 @@
     ArrayLoadStoreData* load_store = (ArrayLoadStoreData*)data;
     load_store->set_flat_array();
   }
 }
 
-JRT_ENTRY(void, Runtime1::load_flattened_array(JavaThread* thread, valueArrayOopDesc* array, int index))
-  assert(array->klass()->is_valueArray_klass(), "should not be called");
+JRT_ENTRY(void, Runtime1::load_flattened_array(JavaThread* thread, inlineArrayOopDesc* array, int index))
+  assert(array->klass()->is_inlineArray_klass(), "should not be called");
   profile_flat_array(thread);
 
   NOT_PRODUCT(_load_flattened_array_slowcase_cnt++;)
   assert(array->length() > 0 && index < array->length(), "already checked");
-  valueArrayHandle vah(thread, array);
-  oop obj = valueArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK);
+  inlineArrayHandle vah(thread, array);
+  oop obj = inlineArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK);
   thread->set_vm_result(obj);
 JRT_END
 
 
-JRT_ENTRY(void, Runtime1::store_flattened_array(JavaThread* thread, valueArrayOopDesc* array, int index, oopDesc* value))
-  if (array->klass()->is_valueArray_klass()) {
+JRT_ENTRY(void, Runtime1::store_flattened_array(JavaThread* thread, inlineArrayOopDesc* array, int index, oopDesc* value))
+  if (array->klass()->is_inlineArray_klass()) {
     profile_flat_array(thread);
   }
 
   NOT_PRODUCT(_store_flattened_array_slowcase_cnt++;)
   if (value == NULL) {
-    assert(array->klass()->is_valueArray_klass() || array->klass()->is_null_free_array_klass(), "should not be called");
+    assert(array->klass()->is_inlineArray_klass() || array->klass()->is_null_free_array_klass(), "should not be called");
     SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_NullPointerException());
   } else {
-    assert(array->klass()->is_valueArray_klass(), "should not be called");
+    assert(array->klass()->is_inlineArray_klass(), "should not be called");
     array->value_copy_to_index(value, index);
   }
 JRT_END
 
 
diff a/src/hotspot/share/c1/c1_Runtime1.hpp b/src/hotspot/share/c1/c1_Runtime1.hpp
--- a/src/hotspot/share/c1/c1_Runtime1.hpp
+++ b/src/hotspot/share/c1/c1_Runtime1.hpp
@@ -156,12 +156,12 @@
   static void new_instance    (JavaThread* thread, Klass* klass);
   static void new_type_array  (JavaThread* thread, Klass* klass, jint length);
   static void new_object_array(JavaThread* thread, Klass* klass, jint length);
   static void new_value_array (JavaThread* thread, Klass* klass, jint length);
   static void new_multi_array (JavaThread* thread, Klass* klass, int rank, jint* dims);
-  static void load_flattened_array(JavaThread* thread, valueArrayOopDesc* array, int index);
-  static void store_flattened_array(JavaThread* thread, valueArrayOopDesc* array, int index, oopDesc* value);
+  static void load_flattened_array(JavaThread* thread, inlineArrayOopDesc* array, int index);
+  static void store_flattened_array(JavaThread* thread, inlineArrayOopDesc* array, int index, oopDesc* value);
   static int  substitutability_check(JavaThread* thread, oopDesc* left, oopDesc* right);
   static void buffer_value_args(JavaThread* thread, Method* method);
   static void buffer_value_args_no_receiver(JavaThread* thread, Method* method);
 
   static address counter_overflow(JavaThread* thread, int bci, Method* method);
diff a/src/hotspot/share/ci/ciArray.hpp b/src/hotspot/share/ci/ciArray.hpp
--- a/src/hotspot/share/ci/ciArray.hpp
+++ b/src/hotspot/share/ci/ciArray.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -27,13 +27,13 @@
 
 #include "ci/ciArrayKlass.hpp"
 #include "ci/ciConstant.hpp"
 #include "ci/ciObject.hpp"
 #include "oops/arrayOop.hpp"
+#include "oops/inlineArrayOop.hpp"
 #include "oops/objArrayOop.hpp"
 #include "oops/typeArrayOop.hpp"
-#include "oops/valueArrayOop.hpp"
 
 // ciArray
 //
 // This class represents an arrayOop in the HotSpot virtual
 // machine.
@@ -43,11 +43,11 @@
 
 protected:
   ciArray(    arrayHandle h_a) : ciObject(h_a), _length(h_a()->length()) {}
   ciArray( objArrayHandle h_a) : ciObject(h_a), _length(h_a()->length()) {}
   ciArray(typeArrayHandle h_a) : ciObject(h_a), _length(h_a()->length()) {}
-  ciArray(valueArrayHandle h_a): ciObject(h_a), _length(h_a()->length()) {}
+  ciArray(inlineArrayHandle h_a): ciObject(h_a), _length(h_a()->length()) {}
 
   ciArray(ciKlass* klass, int len) : ciObject(klass), _length(len) {}
 
   arrayOop get_arrayOop() const { return (arrayOop)get_oop(); }
 
diff a/src/hotspot/share/ci/ciInstanceKlass.cpp b/src/hotspot/share/ci/ciInstanceKlass.cpp
--- a/src/hotspot/share/ci/ciInstanceKlass.cpp
+++ b/src/hotspot/share/ci/ciInstanceKlass.cpp
@@ -799,11 +799,11 @@
           _out->print("%s", klass_name);
         }
       } else if (value->is_array()) {
         typeArrayOop ta = (typeArrayOop)value;
         _out->print("%d", ta->length());
-        if (value->is_objArray() || value->is_valueArray()) {
+        if (value->is_objArray() || value->is_inlineArray()) {
           objArrayOop oa = (objArrayOop)value;
           const char* klass_name  = value->klass()->name()->as_quoted_ascii();
           _out->print(" %s", klass_name);
         }
       } else {
diff a/src/hotspot/share/ci/ciObjectFactory.cpp b/src/hotspot/share/ci/ciObjectFactory.cpp
--- a/src/hotspot/share/ci/ciObjectFactory.cpp
+++ b/src/hotspot/share/ci/ciObjectFactory.cpp
@@ -364,12 +364,12 @@
     objArrayHandle h_oa(THREAD, (objArrayOop)o);
     return new (arena()) ciObjArray(h_oa);
   } else if (o->is_typeArray()) {
     typeArrayHandle h_ta(THREAD, (typeArrayOop)o);
     return new (arena()) ciTypeArray(h_ta);
-  } else if (o->is_valueArray()) {
-    valueArrayHandle h_ta(THREAD, (valueArrayOop)o);
+  } else if (o->is_inlineArray()) {
+    inlineArrayHandle h_ta(THREAD, (inlineArrayOop)o);
     return new (arena()) ciValueArray(h_ta);
   }
 
   // The oop is of some type not supported by the compiler interface.
   ShouldNotReachHere();
@@ -390,11 +390,11 @@
     Klass* k = (Klass*)o;
     if (k->is_inline_klass()) {
       return new (arena()) ciValueKlass(k);
     } else if (k->is_instance_klass()) {
       return new (arena()) ciInstanceKlass(k);
-    } else if (k->is_valueArray_klass()) {
+    } else if (k->is_inlineArray_klass()) {
       return new (arena()) ciValueArrayKlass(k);
     } else if (k->is_objArray_klass()) {
       return new (arena()) ciObjArrayKlass(k);
     } else if (k->is_typeArray_klass()) {
       return new (arena()) ciTypeArrayKlass(k);
diff a/src/hotspot/share/ci/ciReplay.cpp b/src/hotspot/share/ci/ciReplay.cpp
--- a/src/hotspot/share/ci/ciReplay.cpp
+++ b/src/hotspot/share/ci/ciReplay.cpp
@@ -33,13 +33,13 @@
 #include "compiler/compileBroker.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/oopFactory.hpp"
 #include "memory/resourceArea.hpp"
 #include "oops/constantPool.hpp"
+#include "oops/inlineKlass.inline.hpp"
 #include "oops/method.inline.hpp"
 #include "oops/oop.inline.hpp"
-#include "oops/inlineKlass.inline.hpp"
 #include "runtime/fieldDescriptor.inline.hpp"
 #include "runtime/handles.inline.hpp"
 #include "utilities/copy.hpp"
 #include "utilities/macros.hpp"
 #include "utilities/utf8.hpp"
@@ -912,11 +912,11 @@
           Klass* kelem = resolve_klass(field_signature + 1, CHECK_(true));
           value = oopFactory::new_objArray(kelem, length, CHECK_(true));
         } else if (field_signature[0] == JVM_SIGNATURE_ARRAY &&
                    field_signature[1] == JVM_SIGNATURE_INLINE_TYPE) {
           Klass* kelem = resolve_klass(field_signature + 1, CHECK_(true));
-          value = oopFactory::new_valueArray(kelem, length, CHECK_(true));
+          value = oopFactory::new_inlineArray(kelem, length, CHECK_(true));
         } else {
           report_error("unhandled array staticfield");
         }
       }
       java_mirror->obj_field_put(fd->offset(), value);
diff a/src/hotspot/share/ci/ciTypeFlow.hpp b/src/hotspot/share/ci/ciTypeFlow.hpp
--- a/src/hotspot/share/ci/ciTypeFlow.hpp
+++ b/src/hotspot/share/ci/ciTypeFlow.hpp
@@ -340,11 +340,11 @@
     // null is popped from the stack, we return NULL.  Caller beware.
     ciArrayKlass* pop_objOrValueArray() {
       ciType* array = pop_value();
       if (array == null_type())  return NULL;
       // Value type arrays may contain oop or flattened representation
-      assert(array->is_obj_array_klass() || (ValueArrayFlatten && array->is_value_array_klass()),
+      assert(array->is_obj_array_klass() || (InlineArrayFlatten && array->is_value_array_klass()),
           "must be value or object array type");
       return array->as_array_klass();
     }
     ciTypeArrayKlass* pop_typeArray() {
       ciType* array = pop_value();
diff a/src/hotspot/share/ci/ciValueArray.hpp b/src/hotspot/share/ci/ciValueArray.hpp
--- a/src/hotspot/share/ci/ciValueArray.hpp
+++ b/src/hotspot/share/ci/ciValueArray.hpp
@@ -25,26 +25,26 @@
 #ifndef SHARE_VM_CI_CIVALUEARRAY_HPP
 #define SHARE_VM_CI_CIVALUEARRAY_HPP
 
 #include "ci/ciArray.hpp"
 #include "ci/ciClassList.hpp"
-#include "oops/valueArrayOop.hpp"
+#include "oops/inlineArrayOop.hpp"
 
 // ciValueArray
 //
-// This class represents a valueArrayOop in the HotSpot virtual
+// This class represents an inlineArrayOop in the HotSpot virtual
 // machine.
 class ciValueArray : public ciArray {
   CI_PACKAGE_ACCESS
 
 protected:
-  ciValueArray(valueArrayHandle h_o) : ciArray(h_o) {}
+  ciValueArray(inlineArrayHandle h_o) : ciArray(h_o) {}
 
   ciValueArray(ciValueKlass* klass, int len) : ciArray(klass, len) {}
 
-  valueArrayOop get_valueArrayOop() {
-    return (valueArrayOop)get_oop();
+  inlineArrayOop get_valueArrayOop() {
+    return (inlineArrayOop)get_oop();
   }
 
   const char* type_string() { return "ciValuejArray"; }
 
 public:
diff a/src/hotspot/share/ci/ciValueArrayKlass.cpp b/src/hotspot/share/ci/ciValueArrayKlass.cpp
--- a/src/hotspot/share/ci/ciValueArrayKlass.cpp
+++ b/src/hotspot/share/ci/ciValueArrayKlass.cpp
@@ -27,11 +27,11 @@
 #include "ci/ciValueArrayKlass.hpp"
 #include "ci/ciValueKlass.hpp"
 #include "ci/ciSymbol.hpp"
 #include "ci/ciUtilities.hpp"
 #include "ci/ciUtilities.inline.hpp"
-#include "oops/valueArrayKlass.hpp"
+#include "oops/inlineArrayKlass.hpp"
 
 // ciValueArrayKlass
 //
 // This class represents a Klass* in the HotSpot virtual machine
 // whose Klass part is a ValueArrayKlass.
@@ -39,11 +39,11 @@
 // ------------------------------------------------------------------
 // ciValueArrayKlass::ciValueArrayKlass
 //
 // Constructor for loaded value array klasses.
 ciValueArrayKlass::ciValueArrayKlass(Klass* h_k) : ciArrayKlass(h_k) {
-  assert(get_Klass()->is_valueArray_klass(), "wrong type");
+  assert(get_Klass()->is_inlineArray_klass(), "wrong type");
   InlineKlass* element_Klass = get_ValueArrayKlass()->element_klass();
   _base_element_klass = CURRENT_ENV->get_klass(element_Klass);
   assert(_base_element_klass->is_valuetype(), "bad base klass");
   if (dimension() == 1) {
     _element_klass = _base_element_klass;
@@ -125,11 +125,11 @@
 // ------------------------------------------------------------------
 // ciValueArrayKlass::make_impl
 //
 // Implementation of make.
 ciValueArrayKlass* ciValueArrayKlass::make_impl(ciKlass* element_klass) {
-  assert(ValueArrayFlatten, "should only be used for flattened value type arrays");
+  assert(InlineArrayFlatten, "should only be used for flattened value type arrays");
   assert(element_klass->is_valuetype(), "element type must be value type");
   assert(element_klass->is_loaded(), "unloaded Q klasses are represented by ciInstanceKlass");
   {
     EXCEPTION_CONTEXT;
     // The element klass is loaded
diff a/src/hotspot/share/ci/ciValueArrayKlass.hpp b/src/hotspot/share/ci/ciValueArrayKlass.hpp
--- a/src/hotspot/share/ci/ciValueArrayKlass.hpp
+++ b/src/hotspot/share/ci/ciValueArrayKlass.hpp
@@ -28,11 +28,11 @@
 #include "ci/ciArrayKlass.hpp"
 
 // ciValueArrayKlass
 //
 // This class represents a Klass* in the HotSpot virtual machine
-// whose Klass part is a ValueArrayKlass.
+// whose Klass part is an InlineArrayKlass.
 class ciValueArrayKlass : public ciArrayKlass {
   CI_PACKAGE_ACCESS
   friend class ciEnv;
 
 private:
@@ -43,12 +43,12 @@
   ciValueArrayKlass(Klass* h_k);
   ciValueArrayKlass(ciSymbol* array_name,
                     ciValueKlass* element_klass,
                     int dimension);
 
-  ValueArrayKlass* get_ValueArrayKlass() {
-    return (ValueArrayKlass*)get_Klass();
+  InlineArrayKlass* get_ValueArrayKlass() {
+    return (InlineArrayKlass*)get_Klass();
   }
 
   static ciValueArrayKlass* make_impl(ciKlass* element_klass);
   static ciSymbol* construct_array_name(ciSymbol* element_name,
                                         int       dimension);
diff a/src/hotspot/share/classfile/javaClasses.cpp b/src/hotspot/share/classfile/javaClasses.cpp
--- a/src/hotspot/share/classfile/javaClasses.cpp
+++ b/src/hotspot/share/classfile/javaClasses.cpp
@@ -41,21 +41,21 @@
 #include "memory/metaspaceShared.hpp"
 #include "memory/oopFactory.hpp"
 #include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
 #include "oops/fieldStreams.inline.hpp"
+#include "oops/inlineArrayKlass.hpp"
+#include "oops/inlineKlass.inline.hpp"
 #include "oops/instanceKlass.hpp"
 #include "oops/instanceMirrorKlass.inline.hpp"
 #include "oops/klass.hpp"
 #include "oops/method.inline.hpp"
 #include "oops/objArrayOop.inline.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/symbol.hpp"
 #include "oops/recordComponent.hpp"
 #include "oops/typeArrayOop.inline.hpp"
-#include "oops/valueArrayKlass.hpp"
-#include "oops/inlineKlass.inline.hpp"
 #include "prims/jvmtiExport.hpp"
 #include "prims/resolvedMethodTable.hpp"
 #include "runtime/fieldDescriptor.inline.hpp"
 #include "runtime/frame.inline.hpp"
 #include "runtime/handles.inline.hpp"
@@ -1005,12 +1005,12 @@
 
     java_lang_Class::set_static_oop_field_count(mirror(), mk->compute_static_oop_field_count(mirror()));
 
     // It might also have a component mirror.  This mirror must already exist.
     if (k->is_array_klass()) {
-      if (k->is_valueArray_klass()) {
-        Klass* element_klass = (Klass*) ValueArrayKlass::cast(k)->element_klass();
+      if (k->is_inlineArray_klass()) {
+        Klass* element_klass = (Klass*) InlineArrayKlass::cast(k)->element_klass();
         assert(element_klass->is_inline_klass(), "Must be inline type component");
         InlineKlass* vk = InlineKlass::cast(InstanceKlass::cast(element_klass));
         comp_mirror = Handle(THREAD, vk->java_mirror());
       } else if (k->is_typeArray_klass()) {
         BasicType type = TypeArrayKlass::cast(k)->element_type();
diff a/src/hotspot/share/gc/parallel/psCompactionManager.cpp b/src/hotspot/share/gc/parallel/psCompactionManager.cpp
--- a/src/hotspot/share/gc/parallel/psCompactionManager.cpp
+++ b/src/hotspot/share/gc/parallel/psCompactionManager.cpp
@@ -33,15 +33,15 @@
 #include "gc/shared/taskqueue.inline.hpp"
 #include "logging/log.hpp"
 #include "memory/iterator.inline.hpp"
 #include "oops/access.inline.hpp"
 #include "oops/compressedOops.inline.hpp"
+#include "oops/inlineArrayKlass.inline.hpp"
 #include "oops/instanceKlass.inline.hpp"
 #include "oops/instanceMirrorKlass.inline.hpp"
 #include "oops/objArrayKlass.inline.hpp"
 #include "oops/oop.inline.hpp"
-#include "oops/valueArrayKlass.inline.hpp"
 
 PSOldGen*               ParCompactionManager::_old_gen = NULL;
 ParCompactionManager**  ParCompactionManager::_manager_array = NULL;
 
 ParCompactionManager::OopTaskQueueSet*      ParCompactionManager::_oop_task_queues = NULL;
diff a/src/hotspot/share/gc/parallel/psParallelCompact.cpp b/src/hotspot/share/gc/parallel/psParallelCompact.cpp
--- a/src/hotspot/share/gc/parallel/psParallelCompact.cpp
+++ b/src/hotspot/share/gc/parallel/psParallelCompact.cpp
@@ -62,17 +62,17 @@
 #include "logging/log.hpp"
 #include "memory/iterator.inline.hpp"
 #include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
 #include "oops/access.inline.hpp"
+#include "oops/inlineArrayKlass.inline.hpp"
 #include "oops/instanceClassLoaderKlass.inline.hpp"
 #include "oops/instanceKlass.inline.hpp"
 #include "oops/instanceMirrorKlass.inline.hpp"
 #include "oops/methodData.hpp"
 #include "oops/objArrayKlass.inline.hpp"
 #include "oops/oop.inline.hpp"
-#include "oops/valueArrayKlass.inline.hpp"
 #include "runtime/atomic.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/safepoint.hpp"
 #include "runtime/vmThread.hpp"
 #include "services/management.hpp"
diff a/src/hotspot/share/gc/parallel/psPromotionManager.cpp b/src/hotspot/share/gc/parallel/psPromotionManager.cpp
--- a/src/hotspot/share/gc/parallel/psPromotionManager.cpp
+++ b/src/hotspot/share/gc/parallel/psPromotionManager.cpp
@@ -39,11 +39,11 @@
 #include "memory/memRegion.hpp"
 #include "memory/padded.inline.hpp"
 #include "memory/resourceArea.hpp"
 #include "oops/access.inline.hpp"
 #include "oops/compressedOops.inline.hpp"
-#include "oops/valueArrayKlass.inline.hpp"
+#include "oops/inlineArrayKlass.inline.hpp"
 
 PaddedEnd<PSPromotionManager>* PSPromotionManager::_manager_array = NULL;
 PSPromotionManager::PSScannerTasksQueueSet* PSPromotionManager::_stack_array_depth = NULL;
 PreservedMarksSet*             PSPromotionManager::_preserved_marks_set = NULL;
 PSOldGen*                      PSPromotionManager::_old_gen = NULL;
diff a/src/hotspot/share/interpreter/interpreterRuntime.cpp b/src/hotspot/share/interpreter/interpreterRuntime.cpp
--- a/src/hotspot/share/interpreter/interpreterRuntime.cpp
+++ b/src/hotspot/share/interpreter/interpreterRuntime.cpp
@@ -41,19 +41,19 @@
 #include "memory/oopFactory.hpp"
 #include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
 #include "oops/constantPool.hpp"
 #include "oops/cpCache.inline.hpp"
+#include "oops/inlineArrayKlass.hpp"
+#include "oops/inlineArrayOop.inline.hpp"
+#include "oops/inlineKlass.inline.hpp"
 #include "oops/instanceKlass.hpp"
 #include "oops/methodData.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "oops/objArrayOop.inline.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/symbol.hpp"
-#include "oops/valueArrayKlass.hpp"
-#include "oops/valueArrayOop.inline.hpp"
-#include "oops/inlineKlass.inline.hpp"
 #include "prims/jvmtiExport.hpp"
 #include "prims/nativeLookup.hpp"
 #include "runtime/atomic.hpp"
 #include "runtime/biasedLocking.hpp"
 #include "runtime/deoptimization.hpp"
@@ -452,26 +452,26 @@
   Klass*    klass = pool->klass_at(index, CHECK);
   bool      is_qtype_desc = pool->tag_at(index).is_Qdescriptor_klass();
   arrayOop obj;
   if ((!klass->is_array_klass()) && is_qtype_desc) { // Logically creates elements, ensure klass init
     klass->initialize(CHECK);
-    obj = oopFactory::new_valueArray(klass, size, CHECK);
+    obj = oopFactory::new_inlineArray(klass, size, CHECK);
   } else {
     obj = oopFactory::new_objArray(klass, size, CHECK);
   }
   thread->set_vm_result(obj);
 JRT_END
 
 JRT_ENTRY(void, InterpreterRuntime::value_array_load(JavaThread* thread, arrayOopDesc* array, int index))
-  valueArrayHandle vah(thread, (valueArrayOop)array);
-  oop value_holder = valueArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK);
+  inlineArrayHandle vah(thread, (inlineArrayOop)array);
+  oop value_holder = inlineArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK);
   thread->set_vm_result(value_holder);
 JRT_END
 
 JRT_ENTRY(void, InterpreterRuntime::value_array_store(JavaThread* thread, void* val, arrayOopDesc* array, int index))
   assert(val != NULL, "can't store null into flat array");
-  ((valueArrayOop)array)->value_copy_to_index((oop)val, index);
+  ((inlineArrayOop)array)->value_copy_to_index((oop)val, index);
 JRT_END
 
 JRT_ENTRY(void, InterpreterRuntime::multianewarray(JavaThread* thread, jint* first_size_address))
   // We may want to pass in more arguments - could make this slightly faster
   LastFrameAccessor last_frame(thread);
diff a/src/hotspot/share/memory/iterator.inline.hpp b/src/hotspot/share/memory/iterator.inline.hpp
--- a/src/hotspot/share/memory/iterator.inline.hpp
+++ b/src/hotspot/share/memory/iterator.inline.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -29,17 +29,17 @@
 #include "memory/iterator.hpp"
 #include "memory/universe.hpp"
 #include "oops/access.inline.hpp"
 #include "oops/compressedOops.inline.hpp"
 #include "oops/klass.hpp"
+#include "oops/inlineArrayKlass.inline.hpp"
 #include "oops/instanceKlass.inline.hpp"
 #include "oops/instanceMirrorKlass.inline.hpp"
 #include "oops/instanceClassLoaderKlass.inline.hpp"
 #include "oops/instanceRefKlass.inline.hpp"
 #include "oops/objArrayKlass.inline.hpp"
 #include "oops/typeArrayKlass.inline.hpp"
-#include "oops/valueArrayKlass.inline.hpp"
 #include "utilities/debug.hpp"
 
 // Defaults to strong claiming.
 inline MetadataVisitingOopIterateClosure::MetadataVisitingOopIterateClosure(ReferenceDiscoverer* rd) :
     ClaimMetadataVisitingOopIterateClosure(ClassLoaderData::_claim_strong, rd) {}
@@ -274,11 +274,11 @@
       set_init_function<InstanceRefKlass>();
       set_init_function<InstanceMirrorKlass>();
       set_init_function<InstanceClassLoaderKlass>();
       set_init_function<ObjArrayKlass>();
       set_init_function<TypeArrayKlass>();
-      set_init_function<ValueArrayKlass>();
+      set_init_function<InlineArrayKlass>();
     }
   };
 
   static Table _table;
 public:
@@ -335,11 +335,11 @@
       set_init_function<InstanceRefKlass>();
       set_init_function<InstanceMirrorKlass>();
       set_init_function<InstanceClassLoaderKlass>();
       set_init_function<ObjArrayKlass>();
       set_init_function<TypeArrayKlass>();
-      set_init_function<ValueArrayKlass>();
+      set_init_function<InlineArrayKlass>();
     }
   };
 
   static Table _table;
 public:
@@ -396,11 +396,11 @@
       set_init_function<InstanceRefKlass>();
       set_init_function<InstanceMirrorKlass>();
       set_init_function<InstanceClassLoaderKlass>();
       set_init_function<ObjArrayKlass>();
       set_init_function<TypeArrayKlass>();
-      set_init_function<ValueArrayKlass>();
+      set_init_function<InlineArrayKlass>();
     }
   };
 
   static Table _table;
 public:
diff a/src/hotspot/share/memory/metaspaceShared.cpp b/src/hotspot/share/memory/metaspaceShared.cpp
--- a/src/hotspot/share/memory/metaspaceShared.cpp
+++ b/src/hotspot/share/memory/metaspaceShared.cpp
@@ -49,20 +49,20 @@
 #include "memory/metaspaceClosure.hpp"
 #include "memory/metaspaceShared.hpp"
 #include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
 #include "oops/compressedOops.inline.hpp"
+#include "oops/inlineArrayKlass.hpp"
+#include "oops/inlineKlass.hpp"
 #include "oops/instanceClassLoaderKlass.hpp"
 #include "oops/instanceMirrorKlass.hpp"
 #include "oops/instanceRefKlass.hpp"
 #include "oops/methodData.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "oops/objArrayOop.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/typeArrayKlass.hpp"
-#include "oops/valueArrayKlass.hpp"
-#include "oops/inlineKlass.hpp"
 #include "prims/jvmtiRedefineClasses.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/os.hpp"
 #include "runtime/safepointVerifiers.hpp"
 #include "runtime/signature.hpp"
@@ -767,11 +767,11 @@
   f(InstanceMirrorKlass) \
   f(InstanceRefKlass) \
   f(Method) \
   f(ObjArrayKlass) \
   f(TypeArrayKlass) \
-  f(ValueArrayKlass) \
+  f(InlineArrayKlass) \
   f(InlineKlass)
 
 class CppVtableInfo {
   intptr_t _vtable_size;
   intptr_t _cloned_vtable[1];
diff a/src/hotspot/share/memory/oopFactory.cpp b/src/hotspot/share/memory/oopFactory.cpp
--- a/src/hotspot/share/memory/oopFactory.cpp
+++ b/src/hotspot/share/memory/oopFactory.cpp
@@ -29,21 +29,21 @@
 #include "classfile/vmSymbols.hpp"
 #include "gc/shared/collectedHeap.inline.hpp"
 #include "memory/oopFactory.hpp"
 #include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
+#include "oops/inlineArrayKlass.hpp"
+#include "oops/inlineArrayOop.inline.hpp"
+#include "oops/inlineArrayOop.hpp"
 #include "oops/instanceKlass.hpp"
 #include "oops/instanceOop.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "oops/objArrayOop.inline.hpp"
 #include "oops/objArrayOop.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/typeArrayKlass.hpp"
 #include "oops/typeArrayOop.inline.hpp"
-#include "oops/valueArrayKlass.hpp"
-#include "oops/valueArrayOop.inline.hpp"
-#include "oops/valueArrayOop.hpp"
 #include "runtime/handles.inline.hpp"
 #include "utilities/utf8.hpp"
 
 typeArrayOop oopFactory::new_boolArray(int length, TRAPS) {
   return TypeArrayKlass::cast(Universe::boolArrayKlassObj())->allocate(length, THREAD);
@@ -126,38 +126,38 @@
   } else {
     return InstanceKlass::cast(klass)->allocate_objArray(1, length, THREAD);
   }
 }
 
-arrayOop oopFactory::new_valueArray(Klass* klass, int length, TRAPS) {
+arrayOop oopFactory::new_inlineArray(Klass* klass, int length, TRAPS) {
   assert(klass->is_inline_klass(), "Klass must be inline type");
   // Request flattened, but we might not actually get it...either way "null-free" are the aaload/aastore semantics
   Klass* array_klass = klass->array_klass(1, CHECK_NULL);
   assert(array_klass->is_null_free_array_klass(), "Expect a null-free array class here");
 
   arrayOop oop;
-  if (array_klass->is_valueArray_klass()) {
-    oop = (arrayOop) ValueArrayKlass::cast(array_klass)->allocate(length, THREAD);
+  if (array_klass->is_inlineArray_klass()) {
+    oop = (arrayOop) InlineArrayKlass::cast(array_klass)->allocate(length, THREAD);
   } else {
     oop = (arrayOop) ObjArrayKlass::cast(array_klass)->allocate(length, THREAD);
   }
   assert(oop == NULL || oop->klass()->is_null_free_array_klass(), "Bad array storage encoding");
   return oop;
 }
 
-objArrayHandle oopFactory::copy_valueArray_to_objArray(valueArrayHandle array, TRAPS) {
+objArrayHandle oopFactory::copy_inlineArray_to_objArray(inlineArrayHandle array, TRAPS) {
   int len = array->length();
-  ValueArrayKlass* vak = ValueArrayKlass::cast(array->klass());
+  InlineArrayKlass* vak = InlineArrayKlass::cast(array->klass());
   objArrayOop oarray = new_objectArray(array->length(), CHECK_(objArrayHandle()));
   objArrayHandle oarrayh(THREAD, oarray);
   vak->copy_array(array(), 0, oarrayh(), 0, len, CHECK_(objArrayHandle()));
   return oarrayh;
 }
 
 objArrayHandle  oopFactory::ensure_objArray(oop array, TRAPS) {
-  if (array != NULL && array->is_valueArray()) {
-    return copy_valueArray_to_objArray(valueArrayHandle(THREAD, valueArrayOop(array)), THREAD);
+  if (array != NULL && array->is_inlineArray()) {
+    return copy_inlineArray_to_objArray(inlineArrayHandle(THREAD, inlineArrayOop(array)), THREAD);
   } else {
     return objArrayHandle(THREAD, objArrayOop(array));
   }
 }
 
diff a/src/hotspot/share/memory/oopFactory.hpp b/src/hotspot/share/memory/oopFactory.hpp
--- a/src/hotspot/share/memory/oopFactory.hpp
+++ b/src/hotspot/share/memory/oopFactory.hpp
@@ -60,15 +60,15 @@
   // LWorld:
   //    - Q-type signature allocation should use this path.
   //    - L-type signature allocation should use new_objArray
   //
   // Method specifically null free and possibly flattened if possible
-  // i.e. valueArrayOop if flattening can be done, else "null free" objArrayOop
-  static arrayOop        new_valueArray(Klass* klass, int length, TRAPS);
+  // i.e. inlineArrayOop if flattening can be done, else "null free" objArrayOop
+  static arrayOop        new_inlineArray(Klass* klass, int length, TRAPS);
 
   // Helper conversions from value to obj array...
-  static objArrayHandle  copy_valueArray_to_objArray(valueArrayHandle array, TRAPS);
+  static objArrayHandle  copy_inlineArray_to_objArray(inlineArrayHandle array, TRAPS);
   static objArrayHandle  ensure_objArray(oop array, TRAPS); // copy into new objArray if not already an objArray
 
   // Helper that returns a Handle
   static objArrayHandle  new_objArray_handle(Klass* klass, int length, TRAPS);
 };
diff a/src/hotspot/share/oops/constantPool.cpp b/src/hotspot/share/oops/constantPool.cpp
--- a/src/hotspot/share/oops/constantPool.cpp
+++ b/src/hotspot/share/oops/constantPool.cpp
@@ -43,16 +43,16 @@
 #include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
 #include "oops/array.hpp"
 #include "oops/constantPool.inline.hpp"
 #include "oops/cpCache.inline.hpp"
+#include "oops/inlineArrayKlass.hpp"
 #include "oops/instanceKlass.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "oops/objArrayOop.inline.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/typeArrayOop.inline.hpp"
-#include "oops/valueArrayKlass.hpp"
 #include "runtime/atomic.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/init.hpp"
 #include "runtime/javaCalls.hpp"
 #include "runtime/signature.hpp"
@@ -553,12 +553,12 @@
     Klass* bottom_klass = NULL;
     if (k->is_objArray_klass()) {
       bottom_klass = ObjArrayKlass::cast(k)->bottom_klass();
       assert(bottom_klass != NULL, "Should be set");
       assert(bottom_klass->is_instance_klass() || bottom_klass->is_typeArray_klass(), "Sanity check");
-    } else if (k->is_valueArray_klass()) {
-      bottom_klass = ValueArrayKlass::cast(k)->element_klass();
+    } else if (k->is_inlineArray_klass()) {
+      bottom_klass = InlineArrayKlass::cast(k)->element_klass();
       assert(bottom_klass != NULL, "Should be set");
     }
   }
 
   // Failed to resolve class. We must record the errors so that subsequent attempts
diff a/src/hotspot/share/oops/inlineArrayKlass.cpp b/src/hotspot/share/oops/inlineArrayKlass.cpp
--- /dev/null
+++ b/src/hotspot/share/oops/inlineArrayKlass.cpp
@@ -0,0 +1,501 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "classfile/moduleEntry.hpp"
+#include "classfile/packageEntry.hpp"
+#include "classfile/symbolTable.hpp"
+#include "classfile/systemDictionary.hpp"
+#include "classfile/vmSymbols.hpp"
+#include "gc/shared/collectedHeap.inline.hpp"
+#include "memory/iterator.inline.hpp"
+#include "memory/metadataFactory.hpp"
+#include "memory/metaspaceClosure.hpp"
+#include "memory/oopFactory.hpp"
+#include "memory/resourceArea.hpp"
+#include "memory/universe.hpp"
+#include "oops/arrayKlass.inline.hpp"
+#include "oops/arrayOop.hpp"
+#include "oops/inlineKlass.hpp"
+#include "oops/inlineArrayOop.hpp"
+#include "oops/inlineArrayOop.inline.hpp"
+#include "oops/instanceKlass.hpp"
+#include "oops/klass.inline.hpp"
+#include "oops/objArrayKlass.hpp"
+#include "oops/objArrayOop.inline.hpp"
+#include "oops/oop.inline.hpp"
+#include "oops/verifyOopClosure.hpp"
+#include "runtime/handles.inline.hpp"
+#include "runtime/mutexLocker.hpp"
+#include "utilities/copy.hpp"
+#include "utilities/macros.hpp"
+
+#include "oops/inlineArrayKlass.hpp"
+
+// Allocation...
+
+InlineArrayKlass::InlineArrayKlass(Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {
+  assert(element_klass->is_inline_klass(), "Expected Inline");
+
+  set_element_klass(InlineKlass::cast(element_klass));
+  set_class_loader_data(element_klass->class_loader_data());
+  set_layout_helper(array_layout_helper(InlineKlass::cast(element_klass)));
+
+  assert(is_array_klass(), "sanity");
+  assert(is_inlineArray_klass(), "sanity");
+
+  CMH("tweak name symbol refcnt ?")
+#ifndef PRODUCT
+  if (PrintInlineArrayLayout) {
+    print();
+  }
+#endif
+}
+
+InlineKlass* InlineArrayKlass::element_klass() const {
+  return InlineKlass::cast(_element_klass);
+}
+
+void InlineArrayKlass::set_element_klass(Klass* k) {
+  _element_klass = k;
+}
+
+InlineArrayKlass* InlineArrayKlass::allocate_klass(Klass* element_klass, TRAPS) {
+  guarantee((!Universe::is_bootstrapping() || SystemDictionary::Object_klass_loaded()), "Really ?!");
+  assert(InlineArrayFlatten, "Flatten array required");
+  assert(InlineKlass::cast(element_klass)->is_naturally_atomic() || (!InlineArrayAtomicAccess), "Atomic by-default");
+
+  /*
+   *  MVT->LWorld, now need to allocate secondaries array types, just like objArrayKlass...
+   *  ...so now we are trying out covariant array types, just copy objArrayKlass
+   *  TODO refactor any remaining commonality
+   *
+   */
+  // Eagerly allocate the direct array supertype.
+  Klass* super_klass = NULL;
+  Klass* element_super = element_klass->super();
+  if (element_super != NULL) {
+    // The element type has a direct super.  E.g., String[] has direct super of Object[].
+    super_klass = element_super->array_klass_or_null();
+    bool supers_exist = super_klass != NULL;
+    // Also, see if the element has secondary supertypes.
+    // We need an array type for each.
+    const Array<Klass*>* element_supers = element_klass->secondary_supers();
+    for( int i = element_supers->length()-1; i >= 0; i-- ) {
+      Klass* elem_super = element_supers->at(i);
+      if (elem_super->array_klass_or_null() == NULL) {
+        supers_exist = false;
+        break;
+      }
+    }
+    if (!supers_exist) {
+      // Oops.  Not allocated yet.  Back out, allocate it, and retry.
+      Klass* ek = NULL;
+      {
+        MutexUnlocker mu(MultiArray_lock);
+        super_klass = element_super->array_klass(CHECK_NULL);
+        for( int i = element_supers->length()-1; i >= 0; i-- ) {
+          Klass* elem_super = element_supers->at(i);
+          elem_super->array_klass(CHECK_NULL);
+        }
+        // Now retry from the beginning
+        ek = element_klass->array_klass(CHECK_NULL);
+      }  // re-lock
+      return InlineArrayKlass::cast(ek);
+    }
+  }
+
+  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, CHECK_NULL);
+  ClassLoaderData* loader_data = element_klass->class_loader_data();
+  int size = ArrayKlass::static_size(InlineArrayKlass::header_size());
+  InlineArrayKlass* vak = new (loader_data, size, THREAD) InlineArrayKlass(element_klass, name);
+
+  ModuleEntry* module = vak->module();
+  assert(module != NULL, "No module entry for array");
+  complete_create_array_klass(vak, super_klass, module, CHECK_NULL);
+
+  loader_data->add_class(vak);
+
+  return vak;
+}
+
+void InlineArrayKlass::initialize(TRAPS) {
+  element_klass()->initialize(THREAD);
+}
+
+// Oops allocation...
+inlineArrayOop InlineArrayKlass::allocate(int length, TRAPS) {
+  check_array_allocation_length(length, max_elements(), CHECK_NULL);
+  int size = inlineArrayOopDesc::object_size(layout_helper(), length);
+  return (inlineArrayOop) Universe::heap()->array_allocate(this, size, length, true, THREAD);
+}
+
+
+oop InlineArrayKlass::multi_allocate(int rank, jint* last_size, TRAPS) {
+  // For inlineArrays this is only called for the last dimension
+  assert(rank == 1, "just checking");
+  int length = *last_size;
+  return allocate(length, THREAD);
+}
+
+jint InlineArrayKlass::array_layout_helper(InlineKlass* vk) {
+  BasicType etype = T_INLINE_TYPE;
+  int esize = upper_log2(vk->raw_value_byte_size());
+  int hsize = arrayOopDesc::base_offset_in_bytes(etype);
+
+  int lh = Klass::array_layout_helper(_lh_array_tag_vt_value, true, hsize, etype, esize);
+
+  assert(lh < (int)_lh_neutral_value, "must look like an array layout");
+  assert(layout_helper_is_array(lh), "correct kind");
+  assert(layout_helper_is_inlineArray(lh), "correct kind");
+  assert(!layout_helper_is_typeArray(lh), "correct kind");
+  assert(!layout_helper_is_objArray(lh), "correct kind");
+  assert(layout_helper_is_null_free(lh), "correct kind");
+  assert(layout_helper_header_size(lh) == hsize, "correct decode");
+  assert(layout_helper_element_type(lh) == etype, "correct decode");
+  assert(layout_helper_log2_element_size(lh) == esize, "correct decode");
+  assert((1 << esize) < BytesPerLong || is_aligned(hsize, HeapWordsPerLong), "unaligned base");
+
+  return lh;
+}
+
+int InlineArrayKlass::oop_size(oop obj) const {
+  assert(obj->is_inlineArray(),"must be an inline array");
+  inlineArrayOop array = inlineArrayOop(obj);
+  return array->object_size();
+}
+
+// For now return the maximum number of array elements that will not exceed:
+// nof bytes = "max_jint * HeapWord" since the "oopDesc::oop_iterate_size"
+// returns "int" HeapWords, need fix for JDK-4718400 and JDK-8233189
+jint InlineArrayKlass::max_elements() const {
+  // Check the max number of heap words limit first (because of int32_t in oopDesc_oop_size() etc)
+  size_t max_size = max_jint;
+  max_size -= arrayOopDesc::header_size(T_INLINE_TYPE);
+  max_size = align_down(max_size, MinObjAlignment);
+  max_size <<= LogHeapWordSize;                                  // convert to max payload size in bytes
+  max_size >>= layout_helper_log2_element_size(_layout_helper);  // divide by element size (in bytes) = max elements
+  // Within int32_t heap words, still can't exceed Java array element limit
+  if (max_size > max_jint) {
+    max_size = max_jint;
+  }
+  assert((max_size >> LogHeapWordSize) <= max_jint, "Overflow");
+  return (jint) max_size;
+}
+
+oop InlineArrayKlass::protection_domain() const {
+  return element_klass()->protection_domain();
+}
+
+// Temp hack having this here: need to move towards Access API
+static bool needs_backwards_copy(arrayOop s, int src_pos,
+                                 arrayOop d, int dst_pos, int length) {
+  return (s == d) && (dst_pos > src_pos) && (dst_pos - src_pos) < length;
+}
+
+void InlineArrayKlass::copy_array(arrayOop s, int src_pos,
+                                 arrayOop d, int dst_pos, int length, TRAPS) {
+
+  assert(s->is_objArray() || s->is_inlineArray(), "must be obj or inline array");
+
+   // Check destination
+   if ((!d->is_inlineArray()) && (!d->is_objArray())) {
+     THROW(vmSymbols::java_lang_ArrayStoreException());
+   }
+
+   // Check if all offsets and lengths are non negative
+   if (src_pos < 0 || dst_pos < 0 || length < 0) {
+     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
+   }
+   // Check if the ranges are valid
+   if  ( (((unsigned int) length + (unsigned int) src_pos) > (unsigned int) s->length())
+      || (((unsigned int) length + (unsigned int) dst_pos) > (unsigned int) d->length()) ) {
+     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
+   }
+   // Check zero copy
+   if (length == 0)
+     return;
+
+   ArrayKlass* sk = ArrayKlass::cast(s->klass());
+   ArrayKlass* dk = ArrayKlass::cast(d->klass());
+   Klass* d_elem_klass = dk->element_klass();
+   Klass* s_elem_klass = sk->element_klass();
+   /**** CMH: compare and contrast impl, re-factor once we find edge cases... ****/
+
+   if (sk->is_inlineArray_klass()) {
+     assert(sk == this, "Unexpected call to copy_array");
+     // Check subtype, all src homogeneous, so just once
+     if (!s_elem_klass->is_subtype_of(d_elem_klass)) {
+       THROW(vmSymbols::java_lang_ArrayStoreException());
+     }
+
+     inlineArrayOop sa = inlineArrayOop(s);
+     InlineKlass* s_elem_vklass = element_klass();
+
+     // inlineArray-to-inlineArray
+     if (dk->is_inlineArray_klass()) {
+       // element types MUST be exact, subtype check would be dangerous
+       if (dk != this) {
+         THROW(vmSymbols::java_lang_ArrayStoreException());
+       }
+
+       inlineArrayOop da = inlineArrayOop(d);
+       address dst = (address) da->value_at_addr(dst_pos, layout_helper());
+       address src = (address) sa->value_at_addr(src_pos, layout_helper());
+       if (contains_oops()) {
+         int elem_incr = 1 << log2_element_size();
+         address src_end = src + (length << log2_element_size());
+         if (needs_backwards_copy(s, src_pos, d, dst_pos, length)) {
+           swap(src, src_end);
+           dst = dst + (length << log2_element_size());
+           do {
+             src -= elem_incr;
+             dst -= elem_incr;
+             HeapAccess<>::value_copy(src, dst, s_elem_vklass);
+           } while (src > src_end);
+         } else {
+           address src_end = src + (length << log2_element_size());
+           while (src < src_end) {
+             HeapAccess<>::value_copy(src, dst, s_elem_vklass);
+             src += elem_incr;
+             dst += elem_incr;
+           }
+         }
+       } else {
+         // we are basically a type array...don't bother limiting element copy
+         // it would have to be a lot wasted space to be worth value_store() calls, need a setting here ?
+         Copy::conjoint_memory_atomic(src, dst, (size_t)length << log2_element_size());
+       }
+     }
+     else { // inlineArray-to-objArray
+       assert(dk->is_objArray_klass(), "Expected objArray here");
+       // Need to allocate each new src elem payload -> dst oop
+       objArrayHandle dh(THREAD, (objArrayOop)d);
+       inlineArrayHandle sh(THREAD, sa);
+       int dst_end = dst_pos + length;
+       while (dst_pos < dst_end) {
+         oop o = inlineArrayOopDesc::value_alloc_copy_from_index(sh, src_pos, CHECK);
+         dh->obj_at_put(dst_pos, o);
+         dst_pos++;
+         src_pos++;
+       }
+     }
+   } else {
+     assert(s->is_objArray(), "Expected objArray");
+     objArrayOop sa = objArrayOop(s);
+     assert(d->is_inlineArray(), "Excepted inlineArray");  // objArray-to-inlineArray
+     InlineKlass* d_elem_vklass = InlineKlass::cast(d_elem_klass);
+     inlineArrayOop da = inlineArrayOop(d);
+
+     int src_end = src_pos + length;
+     int delem_incr = 1 << dk->log2_element_size();
+     address dst = (address) da->value_at_addr(dst_pos, layout_helper());
+     while (src_pos < src_end) {
+       oop se = sa->obj_at(src_pos);
+       if (se == NULL) {
+         THROW(vmSymbols::java_lang_NullPointerException());
+       }
+       // Check exact type per element
+       if (se->klass() != d_elem_klass) {
+         THROW(vmSymbols::java_lang_ArrayStoreException());
+       }
+       d_elem_vklass->inline_copy_oop_to_payload(se, dst);
+       dst += delem_incr;
+       src_pos++;
+     }
+   }
+}
+
+
+Klass* InlineArrayKlass::array_klass_impl(bool or_null, int n, TRAPS) {
+  assert(dimension() <= n, "check order of chain");
+  int dim = dimension();
+  if (dim == n) return this;
+
+  if (higher_dimension_acquire() == NULL) {
+    if (or_null)  return NULL;
+
+    ResourceMark rm;
+    {
+      // Ensure atomic creation of higher dimensions
+      MutexLocker mu(THREAD, MultiArray_lock);
+
+      // Check if another thread beat us
+      if (higher_dimension() == NULL) {
+
+        // Create multi-dim klass object and link them together
+        Klass* k =
+          ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);
+        ObjArrayKlass* ak = ObjArrayKlass::cast(k);
+        ak->set_lower_dimension(this);
+        OrderAccess::storestore();
+        release_set_higher_dimension(ak);
+        assert(ak->is_objArray_klass(), "incorrect initialization of ObjArrayKlass");
+      }
+    }
+  } else {
+    CHECK_UNHANDLED_OOPS_ONLY(Thread::current()->clear_unhandled_oops());
+  }
+
+  ObjArrayKlass *ak = ObjArrayKlass::cast(higher_dimension());
+  if (or_null) {
+    return ak->array_klass_or_null(n);
+  }
+  return ak->array_klass(n, THREAD);
+}
+
+Klass* InlineArrayKlass::array_klass_impl(bool or_null, TRAPS) {
+  return array_klass_impl(or_null, dimension() +  1, THREAD);
+}
+
+ModuleEntry* InlineArrayKlass::module() const {
+  assert(element_klass() != NULL, "InlineArrayKlass returned unexpected NULL bottom_klass");
+  // The array is defined in the module of its bottom class
+  return element_klass()->module();
+}
+
+PackageEntry* InlineArrayKlass::package() const {
+  assert(element_klass() != NULL, "InlineArrayKlass returned unexpected NULL bottom_klass");
+  return element_klass()->package();
+}
+
+bool InlineArrayKlass::can_be_primary_super_slow() const {
+    return true;
+}
+
+GrowableArray<Klass*>* InlineArrayKlass::compute_secondary_supers(int num_extra_slots,
+                                                                 Array<InstanceKlass*>* transitive_interfaces) {
+  assert(transitive_interfaces == NULL, "sanity");
+  // interfaces = { cloneable_klass, serializable_klass, elemSuper[], ... };
+  Array<Klass*>* elem_supers = element_klass()->secondary_supers();
+  int num_elem_supers = elem_supers == NULL ? 0 : elem_supers->length();
+  int num_secondaries = num_extra_slots + 2 + num_elem_supers;
+  if (num_secondaries == 2) {
+    // Must share this for correct bootstrapping!
+    set_secondary_supers(Universe::the_array_interfaces_array());
+    return NULL;
+  } else {
+    GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(num_elem_supers+3);
+    secondaries->push(SystemDictionary::Cloneable_klass());
+    secondaries->push(SystemDictionary::Serializable_klass());
+    secondaries->push(SystemDictionary::IdentityObject_klass());
+    for (int i = 0; i < num_elem_supers; i++) {
+      Klass* elem_super = (Klass*) elem_supers->at(i);
+      Klass* array_super = elem_super->array_klass_or_null();
+      assert(array_super != NULL, "must already have been created");
+      secondaries->push(array_super);
+    }
+    return secondaries;
+  }
+}
+
+void InlineArrayKlass::print_on(outputStream* st) const {
+#ifndef PRODUCT
+  assert(!is_objArray_klass(), "Unimplemented");
+
+  st->print("Inline Type Array: ");
+  Klass::print_on(st);
+
+  st->print(" - element klass: ");
+  element_klass()->print_value_on(st);
+  st->cr();
+
+  int elem_size = element_byte_size();
+  st->print(" - element size %i ", elem_size);
+  st->print("aligned layout size %i", 1 << layout_helper_log2_element_size(layout_helper()));
+  st->cr();
+#endif //PRODUCT
+}
+
+void InlineArrayKlass::print_value_on(outputStream* st) const {
+  assert(is_klass(), "must be klass");
+
+  element_klass()->print_value_on(st);
+  st->print("[]");
+}
+
+
+#ifndef PRODUCT
+void InlineArrayKlass::oop_print_on(oop obj, outputStream* st) {
+  ArrayKlass::oop_print_on(obj, st);
+  inlineArrayOop va = inlineArrayOop(obj);
+  InlineKlass* vk = element_klass();
+  int print_len = MIN2((intx) va->length(), MaxElementPrintSize);
+  for(int index = 0; index < print_len; index++) {
+    int off = (address) va->value_at_addr(index, layout_helper()) - cast_from_oop<address>(obj);
+    st->print_cr(" - Index %3d offset %3d: ", index, off);
+    oop obj = (oop) ((address)va->value_at_addr(index, layout_helper()) - vk->first_field_offset());
+    FieldPrinter print_field(st, obj);
+    vk->do_nonstatic_fields(&print_field);
+    st->cr();
+  }
+  int remaining = va->length() - print_len;
+  if (remaining > 0) {
+    st->print_cr(" - <%d more elements, increase MaxElementPrintSize to print>", remaining);
+  }
+}
+#endif //PRODUCT
+
+void InlineArrayKlass::oop_print_value_on(oop obj, outputStream* st) {
+  assert(obj->is_inlineArray(), "must be inlineArray");
+  st->print("a ");
+  element_klass()->print_value_on(st);
+  int len = inlineArrayOop(obj)->length();
+  st->print("[%d] ", len);
+  obj->print_address_on(st);
+  if (PrintMiscellaneous && (WizardMode || Verbose)) {
+    int lh = layout_helper();
+    st->print("{");
+    for (int i = 0; i < len; i++) {
+      if (i > 4) {
+        st->print("..."); break;
+      }
+      st->print(" " INTPTR_FORMAT, (intptr_t)(void*)inlineArrayOop(obj)->value_at_addr(i , lh));
+    }
+    st->print(" }");
+  }
+}
+
+// Verification
+class VerifyElementClosure: public BasicOopIterateClosure {
+ public:
+  virtual void do_oop(oop* p)       { VerifyOopClosure::verify_oop.do_oop(p); }
+  virtual void do_oop(narrowOop* p) { VerifyOopClosure::verify_oop.do_oop(p); }
+};
+
+void InlineArrayKlass::oop_verify_on(oop obj, outputStream* st) {
+  ArrayKlass::oop_verify_on(obj, st);
+  guarantee(obj->is_inlineArray(), "must be inlineArray");
+
+  if (contains_oops()) {
+    inlineArrayOop va = inlineArrayOop(obj);
+    VerifyElementClosure ec;
+    va->oop_iterate(&ec);
+  }
+}
+
+void InlineArrayKlass::verify_on(outputStream* st) {
+  ArrayKlass::verify_on(st);
+  guarantee(element_klass()->is_inline_klass(), "should be inline type klass");
+}
diff a/src/hotspot/share/oops/inlineArrayKlass.hpp b/src/hotspot/share/oops/inlineArrayKlass.hpp
--- /dev/null
+++ b/src/hotspot/share/oops/inlineArrayKlass.hpp
@@ -0,0 +1,156 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef SHARE_VM_OOPS_INLINEARRAYKLASS_HPP
+#define SHARE_VM_OOPS_INLINEARRAYKLASS_HPP
+
+#include "classfile/classLoaderData.hpp"
+#include "oops/arrayKlass.hpp"
+#include "oops/inlineKlass.hpp"
+#include "utilities/macros.hpp"
+
+/**
+ * Array of inline types, gives a layout of typeArrayOop, but needs oops iterators
+ */
+class InlineArrayKlass : public ArrayKlass {
+  friend class VMStructs;
+
+ public:
+  static const KlassID ID = InlineArrayKlassID;
+
+ private:
+  // Constructor
+  InlineArrayKlass(Klass* element_klass, Symbol* name);
+
+ protected:
+  // Returns the ArrayKlass for n'th dimension.
+  Klass* array_klass_impl(bool or_null, int n, TRAPS);
+
+  // Returns the array class with this class as element type.
+  Klass* array_klass_impl(bool or_null, TRAPS);
+
+ public:
+
+  InlineArrayKlass() {}
+
+  virtual InlineKlass* element_klass() const;
+  virtual void set_element_klass(Klass* k);
+
+  // Casting from Klass*
+  static InlineArrayKlass* cast(Klass* k) {
+    assert(k->is_inlineArray_klass(), "cast to InlineArrayKlass");
+    return (InlineArrayKlass*) k;
+  }
+
+  // klass allocation
+  static InlineArrayKlass* allocate_klass(Klass* element_klass, TRAPS);
+
+  void initialize(TRAPS);
+
+  ModuleEntry* module() const;
+  PackageEntry* package() const;
+
+  bool can_be_primary_super_slow() const;
+  GrowableArray<Klass*>* compute_secondary_supers(int num_extra_slots,
+                                                  Array<InstanceKlass*>* transitive_interfaces);
+
+  int element_byte_size() const { return 1 << layout_helper_log2_element_size(_layout_helper); }
+
+  bool is_inlineArray_klass_slow() const { return true; }
+
+  bool contains_oops() {
+    return element_klass()->contains_oops();
+  }
+
+  // Override.
+  bool element_access_is_atomic() {
+    return element_klass()->is_atomic();
+  }
+
+  oop protection_domain() const;
+
+  static jint array_layout_helper(InlineKlass* vklass); // layout helper for values
+
+  // sizing
+  static int header_size()  { return sizeof(InlineArrayKlass)/HeapWordSize; }
+  int size() const          { return ArrayKlass::static_size(header_size()); }
+
+  jint max_elements() const;
+
+  int oop_size(oop obj) const;
+
+  // Oop Allocation
+  inlineArrayOop allocate(int length, TRAPS);
+  oop multi_allocate(int rank, jint* sizes, TRAPS);
+
+  // Naming
+  const char* internal_name() const { return external_name(); }
+
+  // Copying
+  void copy_array(arrayOop s, int src_pos, arrayOop d, int dst_pos, int length, TRAPS);
+
+  // GC specific object visitors
+  //
+  // Mark Sweep
+  int oop_ms_adjust_pointers(oop obj);
+
+
+  template <typename T, typename OopClosureType>
+  inline void oop_oop_iterate(oop obj, OopClosureType* closure);
+
+  template <typename T, typename OopClosureType>
+  inline void oop_oop_iterate_reverse(oop obj, OopClosureType* closure);
+
+  template <typename T, typename OopClosureType>
+  inline void oop_oop_iterate_bounded(oop obj, OopClosureType* closure, MemRegion mr);
+
+  template <typename T, class OopClosureType>
+  inline void oop_oop_iterate_elements(inlineArrayOop a, OopClosureType* closure);
+
+private:
+  template <typename T, class OopClosureType>
+  inline void oop_oop_iterate_elements_specialized(inlineArrayOop a, OopClosureType* closure);
+
+  template <typename T, class OopClosureType>
+  inline void oop_oop_iterate_elements_bounded(inlineArrayOop a, OopClosureType* closure, MemRegion mr);
+
+  template <typename T, class OopClosureType>
+  inline void oop_oop_iterate_elements_specialized_bounded(inlineArrayOop a, OopClosureType* closure, void* low, void* high);
+
+ public:
+  // Printing
+  void print_on(outputStream* st) const;
+  void print_value_on(outputStream* st) const;
+
+  void oop_print_value_on(oop obj, outputStream* st);
+#ifndef PRODUCT
+  void oop_print_on(oop obj, outputStream* st);
+#endif
+
+  // Verification
+  void verify_on(outputStream* st);
+  void oop_verify_on(oop obj, outputStream* st);
+};
+
+#endif
diff a/src/hotspot/share/oops/inlineArrayKlass.inline.hpp b/src/hotspot/share/oops/inlineArrayKlass.inline.hpp
--- /dev/null
+++ b/src/hotspot/share/oops/inlineArrayKlass.inline.hpp
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+#ifndef SHARE_VM_OOPS_INLINEARRAYKLASS_INLINE_HPP
+#define SHARE_VM_OOPS_INLINEARRAYKLASS_INLINE_HPP
+
+#include "memory/memRegion.hpp"
+#include "memory/iterator.hpp"
+#include "oops/arrayKlass.hpp"
+#include "oops/inlineArrayKlass.hpp"
+#include "oops/inlineArrayOop.hpp"
+#include "oops/inlineArrayOop.inline.hpp"
+#include "oops/inlineKlass.hpp"
+#include "oops/inlineKlass.inline.hpp"
+#include "oops/klass.hpp"
+#include "oops/oop.inline.hpp"
+#include "utilities/macros.hpp"
+
+/*
+ * Warning incomplete: requires embedded oops, not yet enabled, so consider this a "sketch-up" of oop iterators
+ */
+
+template <typename T, class OopClosureType>
+void InlineArrayKlass::oop_oop_iterate_elements_specialized(inlineArrayOop a,
+                                                            OopClosureType* closure) {
+  assert(contains_oops(), "Nothing to iterate");
+
+  const int shift = Klass::layout_helper_log2_element_size(layout_helper());
+  const int addr_incr = 1 << shift;
+  uintptr_t elem_addr = (uintptr_t) a->base();
+  const uintptr_t stop_addr = elem_addr + ((uintptr_t)a->length() << shift);
+  const int oop_offset = element_klass()->first_field_offset();
+
+  while (elem_addr < stop_addr) {
+    element_klass()->oop_iterate_specialized<T>((address)(elem_addr - oop_offset), closure);
+    elem_addr += addr_incr;
+  }
+}
+
+template <typename T, class OopClosureType>
+void InlineArrayKlass::oop_oop_iterate_elements_specialized_bounded(inlineArrayOop a,
+                                                                    OopClosureType* closure,
+                                                                    void* lo, void* hi) {
+  assert(contains_oops(), "Nothing to iterate");
+
+  const int shift = Klass::layout_helper_log2_element_size(layout_helper());
+  const int addr_incr = 1 << shift;
+  uintptr_t elem_addr = (uintptr_t)a->base();
+  uintptr_t stop_addr = elem_addr + ((uintptr_t)a->length() << shift);
+  const int oop_offset = element_klass()->first_field_offset();
+
+  if (elem_addr < (uintptr_t) lo) {
+    uintptr_t diff = ((uintptr_t) lo) - elem_addr;
+    elem_addr += (diff >> shift) << shift;
+  }
+  if (stop_addr > (uintptr_t) hi) {
+    uintptr_t diff = stop_addr - ((uintptr_t) hi);
+    stop_addr -= (diff >> shift) << shift;
+  }
+
+  const uintptr_t end = stop_addr;
+  while (elem_addr < end) {
+    element_klass()->oop_iterate_specialized_bounded<T>((address)(elem_addr - oop_offset), closure, lo, hi);
+    elem_addr += addr_incr;
+  }
+}
+
+template <typename T, class OopClosureType>
+void InlineArrayKlass::oop_oop_iterate_elements(inlineArrayOop a, OopClosureType* closure) {
+  if (contains_oops()) {
+    oop_oop_iterate_elements_specialized<T>(a, closure);
+  }
+}
+
+template <typename T, typename OopClosureType>
+void InlineArrayKlass::oop_oop_iterate(oop obj, OopClosureType* closure) {
+  assert(obj->is_inlineArray(),"must be an inline array");
+  inlineArrayOop a = inlineArrayOop(obj);
+
+  if (Devirtualizer::do_metadata(closure)) {
+    Devirtualizer::do_klass(closure, obj->klass());
+    Devirtualizer::do_klass(closure, InlineArrayKlass::cast(obj->klass())->element_klass());
+  }
+
+  oop_oop_iterate_elements<T>(a, closure);
+}
+
+template <typename T, typename OopClosureType>
+void InlineArrayKlass::oop_oop_iterate_reverse(oop obj, OopClosureType* closure) {
+  // TODO
+  oop_oop_iterate<T>(obj, closure);
+}
+
+template <typename T, class OopClosureType>
+void InlineArrayKlass::oop_oop_iterate_elements_bounded(inlineArrayOop a, OopClosureType* closure, MemRegion mr) {
+  if (contains_oops()) {
+    oop_oop_iterate_elements_specialized_bounded<T>(a, closure, mr.start(), mr.end());
+  }
+}
+
+
+template <typename T, typename OopClosureType>
+void InlineArrayKlass::oop_oop_iterate_bounded(oop obj, OopClosureType* closure, MemRegion mr) {
+  inlineArrayOop a = inlineArrayOop(obj);
+  if (Devirtualizer::do_metadata(closure)) {
+    Devirtualizer::do_klass(closure, a->klass());
+    Devirtualizer::do_klass(closure, InlineArrayKlass::cast(obj->klass())->element_klass());
+  }
+  oop_oop_iterate_elements_bounded<T>(a, closure, mr);
+}
+
+#endif // SHARE_VM_OOPS_INLINEARRAYKLASS_INLINE_HPP
diff a/src/hotspot/share/oops/inlineArrayOop.cpp b/src/hotspot/share/oops/inlineArrayOop.cpp
--- /dev/null
+++ b/src/hotspot/share/oops/inlineArrayOop.cpp
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+
+#include "inlineArrayOop.hpp"
+#include "inlineArrayKlass.inline.hpp"
+
diff a/src/hotspot/share/oops/inlineArrayOop.hpp b/src/hotspot/share/oops/inlineArrayOop.hpp
--- /dev/null
+++ b/src/hotspot/share/oops/inlineArrayOop.hpp
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef SHARE_VM_OOPS_INLINEARRAYOOP_HPP
+#define SHARE_VM_OOPS_INLINEARRAYOOP_HPP
+
+#include "oops/arrayOop.hpp"
+#include "oops/klass.hpp"
+
+// A inlineArrayOop is an array containing inline types (may include flatten embedded oop elements).
+
+class inlineArrayOopDesc : public arrayOopDesc {
+
+ public:
+  void*  base() const;
+  void* value_at_addr(int index, jint lh) const;
+
+  // Return a buffered element from index
+  static oop value_alloc_copy_from_index(inlineArrayHandle vah, int index, TRAPS);
+  void value_copy_from_index(int index, oop dst) const;
+  void value_copy_to_index(oop src, int index) const;
+
+  // Sizing
+  static size_t element_size(int lh, int nof_elements) {
+    size_t sz = (size_t) nof_elements;
+    return sz << Klass::layout_helper_log2_element_size(lh);
+  }
+
+  static int object_size(int lh, int length) {
+    julong size_in_bytes = header_size_in_bytes() + element_size(lh, length);
+    julong size_in_words = ((size_in_bytes + (HeapWordSize-1)) >> LogHeapWordSize);
+    assert(size_in_words <= (julong)max_jint, "no overflow");
+    return align_object_size((intptr_t)size_in_words);
+  }
+
+  int object_size() const;
+
+};
+
+#endif // SHARE_VM_OOPS_INLINEARRAYOOP_HPP
diff a/src/hotspot/share/oops/inlineArrayOop.inline.hpp b/src/hotspot/share/oops/inlineArrayOop.inline.hpp
--- /dev/null
+++ b/src/hotspot/share/oops/inlineArrayOop.inline.hpp
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef SHARE_VM_OOPS_INLINEARRAYOOP_INLINE_HPP
+#define SHARE_VM_OOPS_INLINEARRAYOOP_INLINE_HPP
+
+#include "oops/access.inline.hpp"
+#include "oops/arrayOop.inline.hpp"
+#include "oops/inlineArrayOop.hpp"
+#include "oops/inlineKlass.inline.hpp"
+#include "oops/oop.inline.hpp"
+#include "runtime/globals.hpp"
+
+inline void* inlineArrayOopDesc::base() const { return arrayOopDesc::base(T_INLINE_TYPE); }
+
+inline void* inlineArrayOopDesc::value_at_addr(int index, jint lh) const {
+  assert(is_within_bounds(index), "index out of bounds");
+
+  address addr = (address) base();
+  addr += (index << Klass::layout_helper_log2_element_size(lh));
+  return (void*) addr;
+}
+
+inline int inlineArrayOopDesc::object_size() const {
+  return object_size(klass()->layout_helper(), length());
+}
+
+inline oop inlineArrayOopDesc::value_alloc_copy_from_index(inlineArrayHandle vah, int index, TRAPS) {
+  InlineArrayKlass* vaklass = InlineArrayKlass::cast(vah->klass());
+  InlineKlass* vklass = vaklass->element_klass();
+  if (vklass->is_empty_inline_type()) {
+    return vklass->default_value();
+  } else {
+    oop buf = vklass->allocate_instance_buffer(CHECK_NULL);
+    vklass->inline_copy_payload_to_new_oop(vah->value_at_addr(index, vaklass->layout_helper()) ,buf);
+    return buf;
+  }
+}
+
+inline void inlineArrayOopDesc::value_copy_from_index(int index, oop dst) const {
+  InlineArrayKlass* vaklass = InlineArrayKlass::cast(klass());
+  InlineKlass* vklass = vaklass->element_klass();
+  if (vklass->is_empty_inline_type()) {
+    return; // Assumes dst was a new and clean buffer (OptoRuntime::load_unknown_value())
+  } else {
+    void* src = value_at_addr(index, vaklass->layout_helper());
+    return vklass->inline_copy_payload_to_new_oop(src ,dst);
+  }
+}
+
+inline void inlineArrayOopDesc::value_copy_to_index(oop src, int index) const {
+  InlineArrayKlass* vaklass = InlineArrayKlass::cast(klass());
+  InlineKlass* vklass = vaklass->element_klass();
+  if (vklass->is_empty_inline_type()) {
+    return;
+  }
+  void* dst = value_at_addr(index, vaklass->layout_helper());
+  vklass->inline_copy_oop_to_payload(src, dst);
+}
+
+
+
+#endif // SHARE_VM_OOPS_INLINEARRAYOOP_INLINE_HPP
diff a/src/hotspot/share/oops/inlineKlass.cpp b/src/hotspot/share/oops/inlineKlass.cpp
--- a/src/hotspot/share/oops/inlineKlass.cpp
+++ b/src/hotspot/share/oops/inlineKlass.cpp
@@ -31,16 +31,16 @@
 #include "memory/metaspaceClosure.hpp"
 #include "memory/metadataFactory.hpp"
 #include "oops/access.hpp"
 #include "oops/compressedOops.inline.hpp"
 #include "oops/fieldStreams.inline.hpp"
+#include "oops/inlineKlass.inline.hpp"
+#include "oops/inlineArrayKlass.hpp"
 #include "oops/instanceKlass.inline.hpp"
 #include "oops/method.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/objArrayKlass.hpp"
-#include "oops/inlineKlass.inline.hpp"
-#include "oops/valueArrayKlass.hpp"
 #include "runtime/fieldDescriptor.inline.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/safepointVerifiers.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/signature.hpp"
@@ -57,11 +57,11 @@
   *((address*)adr_pack_handler()) = NULL;
   *((address*)adr_pack_handler_jobject()) = NULL;
   *((address*)adr_unpack_handler()) = NULL;
   assert(pack_handler() == NULL, "pack handler not null");
   *((int*)adr_default_value_offset()) = 0;
-  *((Klass**)adr_value_array_klass()) = NULL;
+  *((Klass**)adr_inline_array_klass()) = NULL;
   set_prototype_header(markWord::always_locked_prototype());
   assert(is_inline_type_klass(), "invariant");
 }
 
 oop InlineKlass::default_value() {
@@ -176,11 +176,11 @@
 }
 
 // Arrays of...
 
 bool InlineKlass::flatten_array() {
-  if (!ValueArrayFlatten) {
+  if (!InlineArrayFlatten) {
     return false;
   }
   // Too big
   int elem_bytes = raw_value_byte_size();
   if ((InlineArrayElemMaxFlatSize >= 0) && (elem_bytes > InlineArrayElemMaxFlatSize)) {
@@ -208,67 +208,67 @@
   *((Array<VMRegPair>**)adr_return_regs()) = NULL;
   *((address*)adr_pack_handler()) = NULL;
   *((address*)adr_pack_handler_jobject()) = NULL;
   *((address*)adr_unpack_handler()) = NULL;
   assert(pack_handler() == NULL, "pack handler not null");
-  *((Klass**)adr_value_array_klass()) = NULL;
+  *((Klass**)adr_inline_array_klass()) = NULL;
 }
 
 void InlineKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS) {
   InstanceKlass::restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK);
 }
 
 
 Klass* InlineKlass::array_klass_impl(bool or_null, int n, TRAPS) {
   if (flatten_array()) {
-    return value_array_klass(or_null, n, THREAD);
+    return inline_array_klass(or_null, n, THREAD);
   } else {
     return InstanceKlass::array_klass_impl(or_null, n, THREAD);
   }
 }
 
 Klass* InlineKlass::array_klass_impl(bool or_null, TRAPS) {
   return array_klass_impl(or_null, 1, THREAD);
 }
 
-Klass* InlineKlass::value_array_klass(bool or_null, int rank, TRAPS) {
-  Klass* vak = acquire_value_array_klass();
+Klass* InlineKlass::inline_array_klass(bool or_null, int rank, TRAPS) {
+  Klass* vak = acquire_inline_array_klass();
   if (vak == NULL) {
     if (or_null) return NULL;
     ResourceMark rm;
     {
       // Atomic creation of array_klasses
       MutexLocker ma(THREAD, MultiArray_lock);
-      if (get_value_array_klass() == NULL) {
-        vak = allocate_value_array_klass(CHECK_NULL);
-        Atomic::release_store((Klass**)adr_value_array_klass(), vak);
+      if (get_inline_array_klass() == NULL) {
+        vak = allocate_inline_array_klass(CHECK_NULL);
+        Atomic::release_store((Klass**)adr_inline_array_klass(), vak);
       }
     }
   }
   if (or_null) {
     return vak->array_klass_or_null(rank);
   }
   return vak->array_klass(rank, THREAD);
 }
 
-Klass* InlineKlass::allocate_value_array_klass(TRAPS) {
+Klass* InlineKlass::allocate_inline_array_klass(TRAPS) {
   if (flatten_array()) {
-    return ValueArrayKlass::allocate_klass(this, THREAD);
+    return InlineArrayKlass::allocate_klass(this, THREAD);
   }
   return ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, THREAD);
 }
 
 void InlineKlass::array_klasses_do(void f(Klass* k, TRAPS), TRAPS) {
   InstanceKlass::array_klasses_do(f, THREAD);
-  if (get_value_array_klass() != NULL)
-    ArrayKlass::cast(get_value_array_klass())->array_klasses_do(f, THREAD);
+  if (get_inline_array_klass() != NULL)
+    ArrayKlass::cast(get_inline_array_klass())->array_klasses_do(f, THREAD);
 }
 
 void InlineKlass::array_klasses_do(void f(Klass* k)) {
   InstanceKlass::array_klasses_do(f);
-  if (get_value_array_klass() != NULL)
-    ArrayKlass::cast(get_value_array_klass())->array_klasses_do(f);
+  if (get_inline_array_klass() != NULL)
+    ArrayKlass::cast(get_inline_array_klass())->array_klasses_do(f);
 }
 
 // Inline type arguments are not passed by reference, instead each
 // field of the inline type is passed as an argument. This helper
 // function collects the inlined field (recursively)
diff a/src/hotspot/share/oops/inlineKlass.hpp b/src/hotspot/share/oops/inlineKlass.hpp
--- a/src/hotspot/share/oops/inlineKlass.hpp
+++ b/src/hotspot/share/oops/inlineKlass.hpp
@@ -98,24 +98,24 @@
   address adr_default_value_offset() const {
     assert(_adr_inlineklass_fixed_block != NULL, "Should have been initialized");
     return ((address)_adr_inlineklass_fixed_block) + in_bytes(default_value_offset_offset());
   }
 
-  address adr_value_array_klass() const {
+  address adr_inline_array_klass() const {
     assert(_adr_inlineklass_fixed_block != NULL, "Should have been initialized");
-    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _value_array_klass));
+    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _inline_array_klass));
   }
 
-  Klass* get_value_array_klass() const {
-    return *(Klass**)adr_value_array_klass();
+  Klass* get_inline_array_klass() const {
+    return *(Klass**)adr_inline_array_klass();
   }
 
-  Klass* acquire_value_array_klass() const {
-    return Atomic::load_acquire((Klass**)adr_value_array_klass());
+  Klass* acquire_inline_array_klass() const {
+    return Atomic::load_acquire((Klass**)adr_inline_array_klass());
   }
 
-  Klass* allocate_value_array_klass(TRAPS);
+  Klass* allocate_inline_array_klass(TRAPS);
 
   address adr_alignment() const {
     assert(_adr_inlineklass_fixed_block != NULL, "Should have been initialized");
     return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _alignment));
   }
@@ -175,11 +175,11 @@
 
   // Returns the array class with this class as element type
   Klass* array_klass_impl(bool or_null, TRAPS);
 
   // Specifically flat array klass
-  Klass* value_array_klass(bool or_null, int rank, TRAPS);
+  Klass* inline_array_klass(bool or_null, int rank, TRAPS);
 
  public:
   // Type testing
   bool is_inline_klass_slow() const        { return true; }
 
diff a/src/hotspot/share/oops/inlineKlass.inline.hpp b/src/hotspot/share/oops/inlineKlass.inline.hpp
--- a/src/hotspot/share/oops/inlineKlass.inline.hpp
+++ b/src/hotspot/share/oops/inlineKlass.inline.hpp
@@ -23,14 +23,14 @@
  */
 #ifndef SHARE_VM_OOPS_INLINEKLASS_INLINE_HPP
 #define SHARE_VM_OOPS_INLINEKLASS_INLINE_HPP
 
 #include "memory/iterator.hpp"
+#include "oops/inlineArrayKlass.hpp"
+#include "oops/inlineKlass.hpp"
 #include "oops/klass.hpp"
-#include "oops/valueArrayKlass.hpp"
 #include "oops/oop.inline.hpp"
-#include "oops/inlineKlass.hpp"
 #include "utilities/macros.hpp"
 
 inline InlineKlass* InlineKlass::cast(Klass* k) {
   assert(k->is_inline_klass(), "cast to InlineKlass");
   return (InlineKlass*) k;
diff a/src/hotspot/share/oops/instanceKlass.cpp b/src/hotspot/share/oops/instanceKlass.cpp
--- a/src/hotspot/share/oops/instanceKlass.cpp
+++ b/src/hotspot/share/oops/instanceKlass.cpp
@@ -54,20 +54,20 @@
 #include "memory/oopFactory.hpp"
 #include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
 #include "oops/fieldStreams.inline.hpp"
 #include "oops/constantPool.hpp"
+#include "oops/inlineKlass.hpp"
 #include "oops/instanceClassLoaderKlass.hpp"
 #include "oops/instanceKlass.inline.hpp"
 #include "oops/instanceMirrorKlass.hpp"
 #include "oops/instanceOop.hpp"
 #include "oops/klass.inline.hpp"
 #include "oops/method.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/recordComponent.hpp"
 #include "oops/symbol.hpp"
-#include "oops/inlineKlass.hpp"
 #include "prims/jvmtiExport.hpp"
 #include "prims/jvmtiRedefineClasses.hpp"
 #include "prims/jvmtiThreadState.hpp"
 #include "prims/methodComparator.hpp"
 #include "runtime/atomic.hpp"
diff a/src/hotspot/share/oops/instanceKlass.hpp b/src/hotspot/share/oops/instanceKlass.hpp
--- a/src/hotspot/share/oops/instanceKlass.hpp
+++ b/src/hotspot/share/oops/instanceKlass.hpp
@@ -143,11 +143,11 @@
   Array<VMRegPair>** _return_regs;
   address* _pack_handler;
   address* _pack_handler_jobject;
   address* _unpack_handler;
   int* _default_value_offset;
-  Klass** _value_array_klass;
+  Klass** _inline_array_klass;
   int _alignment;
   int _first_field_offset;
   int _exact_size_in_bytes;
 
   friend class InlineKlass;
diff a/src/hotspot/share/oops/klass.hpp b/src/hotspot/share/oops/klass.hpp
--- a/src/hotspot/share/oops/klass.hpp
+++ b/src/hotspot/share/oops/klass.hpp
@@ -43,11 +43,11 @@
   InstanceKlassID,
   InstanceRefKlassID,
   InstanceMirrorKlassID,
   InstanceClassLoaderKlassID,
   TypeArrayKlassID,
-  ValueArrayKlassID,
+  InlineArrayKlassID,
   ObjArrayKlassID
 };
 
 const uint KLASS_ID_COUNT = 7;
 
@@ -394,15 +394,15 @@
     return (juint) _lh_array_tag_type_value == (juint)(lh >> _lh_array_tag_shift);
   }
   static bool layout_helper_is_objArray(jint lh) {
     return (juint)_lh_array_tag_obj_value == (juint)(lh >> _lh_array_tag_shift);
   }
-  static bool layout_helper_is_valueArray(jint lh) {
+  static bool layout_helper_is_inlineArray(jint lh) {
     return (juint)_lh_array_tag_vt_value == (juint)(lh >> _lh_array_tag_shift);
   }
   static bool layout_helper_is_null_free(jint lh) {
-    assert(layout_helper_is_valueArray(lh) || layout_helper_is_objArray(lh), "must be array of inline types");
+    assert(layout_helper_is_inlineArray(lh) || layout_helper_is_objArray(lh), "must be array of inline types");
     return ((lh >> _lh_null_free_shift) & _lh_null_free_mask);
   }
   static jint layout_helper_set_null_free(jint lh) {
     lh |= (_lh_null_free_mask << _lh_null_free_shift);
     assert(layout_helper_is_null_free(lh), "Bad encoding");
@@ -600,11 +600,11 @@
  protected:
   virtual bool is_instance_klass_slow()     const { return false; }
   virtual bool is_array_klass_slow()        const { return false; }
   virtual bool is_objArray_klass_slow()     const { return false; }
   virtual bool is_typeArray_klass_slow()    const { return false; }
-  virtual bool is_valueArray_klass_slow()   const { return false; }
+  virtual bool is_inlineArray_klass_slow()  const { return false; }
 #endif // ASSERT
   // current implementation uses this method even in non debug builds
   virtual bool is_inline_klass_slow()       const { return false; }
  public:
 
@@ -630,13 +630,13 @@
                                                     is_objArray_klass_slow()); }
   inline  bool is_typeArray_klass()           const { return assert_same_query(
                                                     layout_helper_is_typeArray(layout_helper()),
                                                     is_typeArray_klass_slow()); }
   inline  bool is_inline_klass()              const { return is_inline_klass_slow(); } //temporary hack
-  inline  bool is_valueArray_klass()          const { return assert_same_query(
-                                                    layout_helper_is_valueArray(layout_helper()),
-                                                    is_valueArray_klass_slow()); }
+  inline  bool is_inlineArray_klass()         const { return assert_same_query(
+                                                    layout_helper_is_inlineArray(layout_helper()),
+                                                    is_inlineArray_klass_slow()); }
 
   #undef assert_same_query
 
   inline bool is_null_free_array_klass()      const { return layout_helper_is_null_free(layout_helper()); }
 
diff a/src/hotspot/share/oops/objArrayKlass.cpp b/src/hotspot/share/oops/objArrayKlass.cpp
--- a/src/hotspot/share/oops/objArrayKlass.cpp
+++ b/src/hotspot/share/oops/objArrayKlass.cpp
@@ -124,12 +124,12 @@
   set_element_klass(element_klass);
 
   Klass* bk;
   if (element_klass->is_objArray_klass()) {
     bk = ObjArrayKlass::cast(element_klass)->bottom_klass();
-  } else if (element_klass->is_valueArray_klass()) {
-    bk = ValueArrayKlass::cast(element_klass)->element_klass();
+  } else if (element_klass->is_inlineArray_klass()) {
+    bk = InlineArrayKlass::cast(element_klass)->element_klass();
   } else {
     bk = element_klass;
   }
   assert(bk != NULL && (bk->is_instance_klass() || bk->is_typeArray_klass()), "invalid bottom klass");
   set_bottom_klass(bk);
@@ -157,11 +157,11 @@
                                                        /* do_zero */ true, THREAD);
   if (populate_null_free) {
     assert(dimension() == 1, "Can only populate the final dimension");
     assert(element_klass()->is_inline_klass(), "Unexpected");
     assert(!element_klass()->is_array_klass(), "ArrayKlass unexpected here");
-    assert(!InlineKlass::cast(element_klass())->flatten_array(), "Expected valueArrayOop allocation");
+    assert(!InlineKlass::cast(element_klass())->flatten_array(), "Expected inlineArrayOop allocation");
     element_klass()->initialize(CHECK_NULL);
     // Populate default values...
     objArrayHandle array_h(THREAD, array);
     instanceOop value = (instanceOop) InlineKlass::cast(element_klass())->default_value();
     for (int i = 0; i < length; i++) {
@@ -171,13 +171,13 @@
   return array;
 }
 
 oop ObjArrayKlass::multi_allocate(int rank, jint* sizes, TRAPS) {
   int length = *sizes;
-  if (rank == 1) { // last dim may be valueArray, check if we have any special storage requirements
+  if (rank == 1) { // last dim may be inlineArray, check if we have any special storage requirements
     if (element_klass()->is_inline_klass()) {
-      return oopFactory::new_valueArray(element_klass(), length, CHECK_NULL);
+      return oopFactory::new_inlineArray(element_klass(), length, CHECK_NULL);
     } else {
       return oopFactory::new_objArray(element_klass(), length, CHECK_NULL);
     }
   }
   guarantee(rank > 1, "Rank below 1");
@@ -240,12 +240,12 @@
 void ObjArrayKlass::copy_array(arrayOop s, int src_pos, arrayOop d,
                                int dst_pos, int length, TRAPS) {
   assert(s->is_objArray(), "must be obj array");
 
   if (EnableValhalla) {
-    if (d->is_valueArray()) {
-      ValueArrayKlass::cast(d->klass())->copy_array(s, src_pos, d, dst_pos, length, THREAD);
+    if (d->is_inlineArray()) {
+      InlineArrayKlass::cast(d->klass())->copy_array(s, src_pos, d, dst_pos, length, THREAD);
       return;
     }
   }
 
   if (!d->is_objArray()) {
@@ -494,11 +494,11 @@
 void ObjArrayKlass::verify_on(outputStream* st) {
   ArrayKlass::verify_on(st);
   guarantee(element_klass()->is_klass(), "should be klass");
   guarantee(bottom_klass()->is_klass(), "should be klass");
   Klass* bk = bottom_klass();
-  guarantee(bk->is_instance_klass() || bk->is_typeArray_klass() || bk->is_valueArray_klass(),
+  guarantee(bk->is_instance_klass() || bk->is_typeArray_klass() || bk->is_inlineArray_klass(),
             "invalid bottom klass");
 }
 
 void ObjArrayKlass::oop_verify_on(oop obj, outputStream* st) {
   ArrayKlass::oop_verify_on(obj, st);
diff a/src/hotspot/share/oops/oop.cpp b/src/hotspot/share/oops/oop.cpp
--- a/src/hotspot/share/oops/oop.cpp
+++ b/src/hotspot/share/oops/oop.cpp
@@ -136,11 +136,11 @@
 bool oopDesc::is_instance_noinline()          const { return is_instance();            }
 bool oopDesc::is_array_noinline()             const { return is_array();               }
 bool oopDesc::is_objArray_noinline()          const { return is_objArray();            }
 bool oopDesc::is_typeArray_noinline()         const { return is_typeArray();           }
 bool oopDesc::is_value_noinline()             const { return is_inline_type();         }
-bool oopDesc::is_valueArray_noinline()        const { return is_valueArray();          }
+bool oopDesc::is_inlineArray_noinline()       const { return is_inlineArray();          }
 
 bool oopDesc::has_klass_gap() {
   // Only has a klass gap when compressed class pointers are used.
   return UseCompressedClassPointers;
 }
diff a/src/hotspot/share/oops/oop.hpp b/src/hotspot/share/oops/oop.hpp
--- a/src/hotspot/share/oops/oop.hpp
+++ b/src/hotspot/share/oops/oop.hpp
@@ -120,19 +120,19 @@
   inline bool is_instance()            const;
   inline bool is_array()               const;
   inline bool is_objArray()            const;
   inline bool is_typeArray()           const;
   inline bool is_inline_type()         const;
-  inline bool is_valueArray()          const;
+  inline bool is_inlineArray()         const;
 
   // type test operations that don't require inclusion of oop.inline.hpp.
   bool is_instance_noinline()          const;
   bool is_array_noinline()             const;
   bool is_objArray_noinline()          const;
   bool is_typeArray_noinline()         const;
   bool is_value_noinline()             const;
-  bool is_valueArray_noinline()        const;
+  bool is_inlineArray_noinline()       const;
 
  protected:
   inline oop        as_oop() const { return const_cast<oopDesc*>(this); }
 
  public:
diff a/src/hotspot/share/oops/oop.inline.hpp b/src/hotspot/share/oops/oop.inline.hpp
--- a/src/hotspot/share/oops/oop.inline.hpp
+++ b/src/hotspot/share/oops/oop.inline.hpp
@@ -244,11 +244,11 @@
 bool oopDesc::is_instance()  const { return klass()->is_instance_klass();  }
 bool oopDesc::is_array()     const { return klass()->is_array_klass();     }
 bool oopDesc::is_objArray()  const { return klass()->is_objArray_klass();  }
 bool oopDesc::is_typeArray() const { return klass()->is_typeArray_klass(); }
 bool oopDesc::is_inline_type() const { return klass()->is_inline_klass(); }
-bool oopDesc::is_valueArray()  const { return klass()->is_valueArray_klass(); }
+bool oopDesc::is_inlineArray() const { return klass()->is_inlineArray_klass(); }
 
 void*    oopDesc::field_addr_raw(int offset)     const { return reinterpret_cast<void*>(cast_from_oop<intptr_t>(as_oop()) + offset); }
 void*    oopDesc::field_addr(int offset)         const { return Access<>::resolve(as_oop())->field_addr_raw(offset); }
 
 template <class T>
diff a/src/hotspot/share/oops/oopsHierarchy.hpp b/src/hotspot/share/oops/oopsHierarchy.hpp
--- a/src/hotspot/share/oops/oopsHierarchy.hpp
+++ b/src/hotspot/share/oops/oopsHierarchy.hpp
@@ -45,11 +45,11 @@
 typedef class oopDesc*                    oop;
 typedef class   instanceOopDesc*            instanceOop;
 typedef class   arrayOopDesc*               arrayOop;
 typedef class     objArrayOopDesc*            objArrayOop;
 typedef class     typeArrayOopDesc*           typeArrayOop;
-typedef class     valueArrayOopDesc*          valueArrayOop;
+typedef class     inlineArrayOopDesc*         inlineArrayOop;
 
 #else
 
 // When CHECK_UNHANDLED_OOPS is defined, an "oop" is a class with a
 // carefully chosen set of constructors and conversion operators to go
@@ -143,11 +143,11 @@
 
 DEF_OOP(instance);
 DEF_OOP(array);
 DEF_OOP(objArray);
 DEF_OOP(typeArray);
-DEF_OOP(valueArray);
+DEF_OOP(inlineArray);
 
 #endif // CHECK_UNHANDLED_OOPS
 
 // For CHECK_UNHANDLED_OOPS, it is ambiguous C++ behavior to have the oop
 // structure contain explicit user defined conversions of both numerical
@@ -181,8 +181,8 @@
 class     InstanceRefKlass;
 class     InlineKlass;
 class   ArrayKlass;
 class     ObjArrayKlass;
 class     TypeArrayKlass;
-class     ValueArrayKlass;
+class     InlineArrayKlass;
 
 #endif // SHARE_OOPS_OOPSHIERARCHY_HPP
diff a/src/hotspot/share/oops/valueArrayKlass.cpp b/src/hotspot/share/oops/valueArrayKlass.cpp
--- a/src/hotspot/share/oops/valueArrayKlass.cpp
+++ /dev/null
@@ -1,501 +0,0 @@
-/*
- * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- *
- */
-
-#include "precompiled.hpp"
-#include "classfile/moduleEntry.hpp"
-#include "classfile/packageEntry.hpp"
-#include "classfile/symbolTable.hpp"
-#include "classfile/systemDictionary.hpp"
-#include "classfile/vmSymbols.hpp"
-#include "gc/shared/collectedHeap.inline.hpp"
-#include "memory/iterator.inline.hpp"
-#include "memory/metadataFactory.hpp"
-#include "memory/metaspaceClosure.hpp"
-#include "memory/oopFactory.hpp"
-#include "memory/resourceArea.hpp"
-#include "memory/universe.hpp"
-#include "oops/arrayKlass.inline.hpp"
-#include "oops/arrayOop.hpp"
-#include "oops/instanceKlass.hpp"
-#include "oops/klass.inline.hpp"
-#include "oops/objArrayKlass.hpp"
-#include "oops/objArrayOop.inline.hpp"
-#include "oops/oop.inline.hpp"
-#include "oops/inlineKlass.hpp"
-#include "oops/valueArrayOop.hpp"
-#include "oops/valueArrayOop.inline.hpp"
-#include "oops/verifyOopClosure.hpp"
-#include "runtime/handles.inline.hpp"
-#include "runtime/mutexLocker.hpp"
-#include "utilities/copy.hpp"
-#include "utilities/macros.hpp"
-
-#include "oops/valueArrayKlass.hpp"
-
-// Allocation...
-
-ValueArrayKlass::ValueArrayKlass(Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {
-  assert(element_klass->is_inline_klass(), "Expected Inline");
-
-  set_element_klass(InlineKlass::cast(element_klass));
-  set_class_loader_data(element_klass->class_loader_data());
-  set_layout_helper(array_layout_helper(InlineKlass::cast(element_klass)));
-
-  assert(is_array_klass(), "sanity");
-  assert(is_valueArray_klass(), "sanity");
-
-  CMH("tweak name symbol refcnt ?")
-#ifndef PRODUCT
-  if (PrintInlineArrayLayout) {
-    print();
-  }
-#endif
-}
-
-InlineKlass* ValueArrayKlass::element_klass() const {
-  return InlineKlass::cast(_element_klass);
-}
-
-void ValueArrayKlass::set_element_klass(Klass* k) {
-  _element_klass = k;
-}
-
-ValueArrayKlass* ValueArrayKlass::allocate_klass(Klass* element_klass, TRAPS) {
-  guarantee((!Universe::is_bootstrapping() || SystemDictionary::Object_klass_loaded()), "Really ?!");
-  assert(ValueArrayFlatten, "Flatten array required");
-  assert(InlineKlass::cast(element_klass)->is_naturally_atomic() || (!InlineArrayAtomicAccess), "Atomic by-default");
-
-  /*
-   *  MVT->LWorld, now need to allocate secondaries array types, just like objArrayKlass...
-   *  ...so now we are trying out covariant array types, just copy objArrayKlass
-   *  TODO refactor any remaining commonality
-   *
-   */
-  // Eagerly allocate the direct array supertype.
-  Klass* super_klass = NULL;
-  Klass* element_super = element_klass->super();
-  if (element_super != NULL) {
-    // The element type has a direct super.  E.g., String[] has direct super of Object[].
-    super_klass = element_super->array_klass_or_null();
-    bool supers_exist = super_klass != NULL;
-    // Also, see if the element has secondary supertypes.
-    // We need an array type for each.
-    const Array<Klass*>* element_supers = element_klass->secondary_supers();
-    for( int i = element_supers->length()-1; i >= 0; i-- ) {
-      Klass* elem_super = element_supers->at(i);
-      if (elem_super->array_klass_or_null() == NULL) {
-        supers_exist = false;
-        break;
-      }
-    }
-    if (!supers_exist) {
-      // Oops.  Not allocated yet.  Back out, allocate it, and retry.
-      Klass* ek = NULL;
-      {
-        MutexUnlocker mu(MultiArray_lock);
-        super_klass = element_super->array_klass(CHECK_NULL);
-        for( int i = element_supers->length()-1; i >= 0; i-- ) {
-          Klass* elem_super = element_supers->at(i);
-          elem_super->array_klass(CHECK_NULL);
-        }
-        // Now retry from the beginning
-        ek = element_klass->array_klass(CHECK_NULL);
-      }  // re-lock
-      return ValueArrayKlass::cast(ek);
-    }
-  }
-
-  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, CHECK_NULL);
-  ClassLoaderData* loader_data = element_klass->class_loader_data();
-  int size = ArrayKlass::static_size(ValueArrayKlass::header_size());
-  ValueArrayKlass* vak = new (loader_data, size, THREAD) ValueArrayKlass(element_klass, name);
-
-  ModuleEntry* module = vak->module();
-  assert(module != NULL, "No module entry for array");
-  complete_create_array_klass(vak, super_klass, module, CHECK_NULL);
-
-  loader_data->add_class(vak);
-
-  return vak;
-}
-
-void ValueArrayKlass::initialize(TRAPS) {
-  element_klass()->initialize(THREAD);
-}
-
-// Oops allocation...
-valueArrayOop ValueArrayKlass::allocate(int length, TRAPS) {
-  check_array_allocation_length(length, max_elements(), CHECK_NULL);
-  int size = valueArrayOopDesc::object_size(layout_helper(), length);
-  return (valueArrayOop) Universe::heap()->array_allocate(this, size, length, true, THREAD);
-}
-
-
-oop ValueArrayKlass::multi_allocate(int rank, jint* last_size, TRAPS) {
-  // For valueArrays this is only called for the last dimension
-  assert(rank == 1, "just checking");
-  int length = *last_size;
-  return allocate(length, THREAD);
-}
-
-jint ValueArrayKlass::array_layout_helper(InlineKlass* vk) {
-  BasicType etype = T_INLINE_TYPE;
-  int esize = upper_log2(vk->raw_value_byte_size());
-  int hsize = arrayOopDesc::base_offset_in_bytes(etype);
-
-  int lh = Klass::array_layout_helper(_lh_array_tag_vt_value, true, hsize, etype, esize);
-
-  assert(lh < (int)_lh_neutral_value, "must look like an array layout");
-  assert(layout_helper_is_array(lh), "correct kind");
-  assert(layout_helper_is_valueArray(lh), "correct kind");
-  assert(!layout_helper_is_typeArray(lh), "correct kind");
-  assert(!layout_helper_is_objArray(lh), "correct kind");
-  assert(layout_helper_is_null_free(lh), "correct kind");
-  assert(layout_helper_header_size(lh) == hsize, "correct decode");
-  assert(layout_helper_element_type(lh) == etype, "correct decode");
-  assert(layout_helper_log2_element_size(lh) == esize, "correct decode");
-  assert((1 << esize) < BytesPerLong || is_aligned(hsize, HeapWordsPerLong), "unaligned base");
-
-  return lh;
-}
-
-int ValueArrayKlass::oop_size(oop obj) const {
-  assert(obj->is_valueArray(),"must be a value array");
-  valueArrayOop array = valueArrayOop(obj);
-  return array->object_size();
-}
-
-// For now return the maximum number of array elements that will not exceed:
-// nof bytes = "max_jint * HeapWord" since the "oopDesc::oop_iterate_size"
-// returns "int" HeapWords, need fix for JDK-4718400 and JDK-8233189
-jint ValueArrayKlass::max_elements() const {
-  // Check the max number of heap words limit first (because of int32_t in oopDesc_oop_size() etc)
-  size_t max_size = max_jint;
-  max_size -= arrayOopDesc::header_size(T_INLINE_TYPE);
-  max_size = align_down(max_size, MinObjAlignment);
-  max_size <<= LogHeapWordSize;                                  // convert to max payload size in bytes
-  max_size >>= layout_helper_log2_element_size(_layout_helper);  // divide by element size (in bytes) = max elements
-  // Within int32_t heap words, still can't exceed Java array element limit
-  if (max_size > max_jint) {
-    max_size = max_jint;
-  }
-  assert((max_size >> LogHeapWordSize) <= max_jint, "Overflow");
-  return (jint) max_size;
-}
-
-oop ValueArrayKlass::protection_domain() const {
-  return element_klass()->protection_domain();
-}
-
-// Temp hack having this here: need to move towards Access API
-static bool needs_backwards_copy(arrayOop s, int src_pos,
-                                 arrayOop d, int dst_pos, int length) {
-  return (s == d) && (dst_pos > src_pos) && (dst_pos - src_pos) < length;
-}
-
-void ValueArrayKlass::copy_array(arrayOop s, int src_pos,
-                                 arrayOop d, int dst_pos, int length, TRAPS) {
-
-  assert(s->is_objArray() || s->is_valueArray(), "must be obj or value array");
-
-   // Check destination
-   if ((!d->is_valueArray()) && (!d->is_objArray())) {
-     THROW(vmSymbols::java_lang_ArrayStoreException());
-   }
-
-   // Check if all offsets and lengths are non negative
-   if (src_pos < 0 || dst_pos < 0 || length < 0) {
-     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
-   }
-   // Check if the ranges are valid
-   if  ( (((unsigned int) length + (unsigned int) src_pos) > (unsigned int) s->length())
-      || (((unsigned int) length + (unsigned int) dst_pos) > (unsigned int) d->length()) ) {
-     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
-   }
-   // Check zero copy
-   if (length == 0)
-     return;
-
-   ArrayKlass* sk = ArrayKlass::cast(s->klass());
-   ArrayKlass* dk = ArrayKlass::cast(d->klass());
-   Klass* d_elem_klass = dk->element_klass();
-   Klass* s_elem_klass = sk->element_klass();
-   /**** CMH: compare and contrast impl, re-factor once we find edge cases... ****/
-
-   if (sk->is_valueArray_klass()) {
-     assert(sk == this, "Unexpected call to copy_array");
-     // Check subtype, all src homogeneous, so just once
-     if (!s_elem_klass->is_subtype_of(d_elem_klass)) {
-       THROW(vmSymbols::java_lang_ArrayStoreException());
-     }
-
-     valueArrayOop sa = valueArrayOop(s);
-     InlineKlass* s_elem_vklass = element_klass();
-
-     // valueArray-to-valueArray
-     if (dk->is_valueArray_klass()) {
-       // element types MUST be exact, subtype check would be dangerous
-       if (dk != this) {
-         THROW(vmSymbols::java_lang_ArrayStoreException());
-       }
-
-       valueArrayOop da = valueArrayOop(d);
-       address dst = (address) da->value_at_addr(dst_pos, layout_helper());
-       address src = (address) sa->value_at_addr(src_pos, layout_helper());
-       if (contains_oops()) {
-         int elem_incr = 1 << log2_element_size();
-         address src_end = src + (length << log2_element_size());
-         if (needs_backwards_copy(s, src_pos, d, dst_pos, length)) {
-           swap(src, src_end);
-           dst = dst + (length << log2_element_size());
-           do {
-             src -= elem_incr;
-             dst -= elem_incr;
-             HeapAccess<>::value_copy(src, dst, s_elem_vklass);
-           } while (src > src_end);
-         } else {
-           address src_end = src + (length << log2_element_size());
-           while (src < src_end) {
-             HeapAccess<>::value_copy(src, dst, s_elem_vklass);
-             src += elem_incr;
-             dst += elem_incr;
-           }
-         }
-       } else {
-         // we are basically a type array...don't bother limiting element copy
-         // it would have to be a lot wasted space to be worth value_store() calls, need a setting here ?
-         Copy::conjoint_memory_atomic(src, dst, (size_t)length << log2_element_size());
-       }
-     }
-     else { // valueArray-to-objArray
-       assert(dk->is_objArray_klass(), "Expected objArray here");
-       // Need to allocate each new src elem payload -> dst oop
-       objArrayHandle dh(THREAD, (objArrayOop)d);
-       valueArrayHandle sh(THREAD, sa);
-       int dst_end = dst_pos + length;
-       while (dst_pos < dst_end) {
-         oop o = valueArrayOopDesc::value_alloc_copy_from_index(sh, src_pos, CHECK);
-         dh->obj_at_put(dst_pos, o);
-         dst_pos++;
-         src_pos++;
-       }
-     }
-   } else {
-     assert(s->is_objArray(), "Expected objArray");
-     objArrayOop sa = objArrayOop(s);
-     assert(d->is_valueArray(), "Excepted valueArray");  // objArray-to-valueArray
-     InlineKlass* d_elem_vklass = InlineKlass::cast(d_elem_klass);
-     valueArrayOop da = valueArrayOop(d);
-
-     int src_end = src_pos + length;
-     int delem_incr = 1 << dk->log2_element_size();
-     address dst = (address) da->value_at_addr(dst_pos, layout_helper());
-     while (src_pos < src_end) {
-       oop se = sa->obj_at(src_pos);
-       if (se == NULL) {
-         THROW(vmSymbols::java_lang_NullPointerException());
-       }
-       // Check exact type per element
-       if (se->klass() != d_elem_klass) {
-         THROW(vmSymbols::java_lang_ArrayStoreException());
-       }
-       d_elem_vklass->inline_copy_oop_to_payload(se, dst);
-       dst += delem_incr;
-       src_pos++;
-     }
-   }
-}
-
-
-Klass* ValueArrayKlass::array_klass_impl(bool or_null, int n, TRAPS) {
-  assert(dimension() <= n, "check order of chain");
-  int dim = dimension();
-  if (dim == n) return this;
-
-  if (higher_dimension_acquire() == NULL) {
-    if (or_null)  return NULL;
-
-    ResourceMark rm;
-    {
-      // Ensure atomic creation of higher dimensions
-      MutexLocker mu(THREAD, MultiArray_lock);
-
-      // Check if another thread beat us
-      if (higher_dimension() == NULL) {
-
-        // Create multi-dim klass object and link them together
-        Klass* k =
-          ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);
-        ObjArrayKlass* ak = ObjArrayKlass::cast(k);
-        ak->set_lower_dimension(this);
-        OrderAccess::storestore();
-        release_set_higher_dimension(ak);
-        assert(ak->is_objArray_klass(), "incorrect initialization of ObjArrayKlass");
-      }
-    }
-  } else {
-    CHECK_UNHANDLED_OOPS_ONLY(Thread::current()->clear_unhandled_oops());
-  }
-
-  ObjArrayKlass *ak = ObjArrayKlass::cast(higher_dimension());
-  if (or_null) {
-    return ak->array_klass_or_null(n);
-  }
-  return ak->array_klass(n, THREAD);
-}
-
-Klass* ValueArrayKlass::array_klass_impl(bool or_null, TRAPS) {
-  return array_klass_impl(or_null, dimension() +  1, THREAD);
-}
-
-ModuleEntry* ValueArrayKlass::module() const {
-  assert(element_klass() != NULL, "ValueArrayKlass returned unexpected NULL bottom_klass");
-  // The array is defined in the module of its bottom class
-  return element_klass()->module();
-}
-
-PackageEntry* ValueArrayKlass::package() const {
-  assert(element_klass() != NULL, "ValuerrayKlass returned unexpected NULL bottom_klass");
-  return element_klass()->package();
-}
-
-bool ValueArrayKlass::can_be_primary_super_slow() const {
-    return true;
-}
-
-GrowableArray<Klass*>* ValueArrayKlass::compute_secondary_supers(int num_extra_slots,
-                                                                 Array<InstanceKlass*>* transitive_interfaces) {
-  assert(transitive_interfaces == NULL, "sanity");
-  // interfaces = { cloneable_klass, serializable_klass, elemSuper[], ... };
-  Array<Klass*>* elem_supers = element_klass()->secondary_supers();
-  int num_elem_supers = elem_supers == NULL ? 0 : elem_supers->length();
-  int num_secondaries = num_extra_slots + 2 + num_elem_supers;
-  if (num_secondaries == 2) {
-    // Must share this for correct bootstrapping!
-    set_secondary_supers(Universe::the_array_interfaces_array());
-    return NULL;
-  } else {
-    GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(num_elem_supers+3);
-    secondaries->push(SystemDictionary::Cloneable_klass());
-    secondaries->push(SystemDictionary::Serializable_klass());
-    secondaries->push(SystemDictionary::IdentityObject_klass());
-    for (int i = 0; i < num_elem_supers; i++) {
-      Klass* elem_super = (Klass*) elem_supers->at(i);
-      Klass* array_super = elem_super->array_klass_or_null();
-      assert(array_super != NULL, "must already have been created");
-      secondaries->push(array_super);
-    }
-    return secondaries;
-  }
-}
-
-void ValueArrayKlass::print_on(outputStream* st) const {
-#ifndef PRODUCT
-  assert(!is_objArray_klass(), "Unimplemented");
-
-  st->print("Value Type Array: ");
-  Klass::print_on(st);
-
-  st->print(" - element klass: ");
-  element_klass()->print_value_on(st);
-  st->cr();
-
-  int elem_size = element_byte_size();
-  st->print(" - element size %i ", elem_size);
-  st->print("aligned layout size %i", 1 << layout_helper_log2_element_size(layout_helper()));
-  st->cr();
-#endif //PRODUCT
-}
-
-void ValueArrayKlass::print_value_on(outputStream* st) const {
-  assert(is_klass(), "must be klass");
-
-  element_klass()->print_value_on(st);
-  st->print("[]");
-}
-
-
-#ifndef PRODUCT
-void ValueArrayKlass::oop_print_on(oop obj, outputStream* st) {
-  ArrayKlass::oop_print_on(obj, st);
-  valueArrayOop va = valueArrayOop(obj);
-  InlineKlass* vk = element_klass();
-  int print_len = MIN2((intx) va->length(), MaxElementPrintSize);
-  for(int index = 0; index < print_len; index++) {
-    int off = (address) va->value_at_addr(index, layout_helper()) - cast_from_oop<address>(obj);
-    st->print_cr(" - Index %3d offset %3d: ", index, off);
-    oop obj = (oop) ((address)va->value_at_addr(index, layout_helper()) - vk->first_field_offset());
-    FieldPrinter print_field(st, obj);
-    vk->do_nonstatic_fields(&print_field);
-    st->cr();
-  }
-  int remaining = va->length() - print_len;
-  if (remaining > 0) {
-    st->print_cr(" - <%d more elements, increase MaxElementPrintSize to print>", remaining);
-  }
-}
-#endif //PRODUCT
-
-void ValueArrayKlass::oop_print_value_on(oop obj, outputStream* st) {
-  assert(obj->is_valueArray(), "must be valueArray");
-  st->print("a ");
-  element_klass()->print_value_on(st);
-  int len = valueArrayOop(obj)->length();
-  st->print("[%d] ", len);
-  obj->print_address_on(st);
-  if (PrintMiscellaneous && (WizardMode || Verbose)) {
-    int lh = layout_helper();
-    st->print("{");
-    for (int i = 0; i < len; i++) {
-      if (i > 4) {
-        st->print("..."); break;
-      }
-      st->print(" " INTPTR_FORMAT, (intptr_t)(void*)valueArrayOop(obj)->value_at_addr(i , lh));
-    }
-    st->print(" }");
-  }
-}
-
-// Verification
-class VerifyElementClosure: public BasicOopIterateClosure {
- public:
-  virtual void do_oop(oop* p)       { VerifyOopClosure::verify_oop.do_oop(p); }
-  virtual void do_oop(narrowOop* p) { VerifyOopClosure::verify_oop.do_oop(p); }
-};
-
-void ValueArrayKlass::oop_verify_on(oop obj, outputStream* st) {
-  ArrayKlass::oop_verify_on(obj, st);
-  guarantee(obj->is_valueArray(), "must be valueArray");
-
-  if (contains_oops()) {
-    valueArrayOop va = valueArrayOop(obj);
-    VerifyElementClosure ec;
-    va->oop_iterate(&ec);
-  }
-}
-
-void ValueArrayKlass::verify_on(outputStream* st) {
-  ArrayKlass::verify_on(st);
-  guarantee(element_klass()->is_inline_klass(), "should be inline type klass");
-}
diff a/src/hotspot/share/oops/valueArrayKlass.hpp b/src/hotspot/share/oops/valueArrayKlass.hpp
--- a/src/hotspot/share/oops/valueArrayKlass.hpp
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- *
- */
-
-#ifndef SHARE_VM_OOPS_VALUEARRAYKLASS_HPP
-#define SHARE_VM_OOPS_VALUEARRAYKLASS_HPP
-
-#include "classfile/classLoaderData.hpp"
-#include "oops/arrayKlass.hpp"
-#include "oops/inlineKlass.hpp"
-#include "utilities/macros.hpp"
-
-/**
- * Array of values, gives a layout of typeArrayOop, but needs oops iterators
- */
-class ValueArrayKlass : public ArrayKlass {
-  friend class VMStructs;
-
- public:
-  static const KlassID ID = ValueArrayKlassID;
-
- private:
-  // Constructor
-  ValueArrayKlass(Klass* element_klass, Symbol* name);
-
- protected:
-  // Returns the ArrayKlass for n'th dimension.
-  Klass* array_klass_impl(bool or_null, int n, TRAPS);
-
-  // Returns the array class with this class as element type.
-  Klass* array_klass_impl(bool or_null, TRAPS);
-
- public:
-
-  ValueArrayKlass() {}
-
-  virtual InlineKlass* element_klass() const;
-  virtual void set_element_klass(Klass* k);
-
-  // Casting from Klass*
-  static ValueArrayKlass* cast(Klass* k) {
-    assert(k->is_valueArray_klass(), "cast to ValueArrayKlass");
-    return (ValueArrayKlass*) k;
-  }
-
-  // klass allocation
-  static ValueArrayKlass* allocate_klass(Klass* element_klass, TRAPS);
-
-  void initialize(TRAPS);
-
-  ModuleEntry* module() const;
-  PackageEntry* package() const;
-
-  bool can_be_primary_super_slow() const;
-  GrowableArray<Klass*>* compute_secondary_supers(int num_extra_slots,
-                                                  Array<InstanceKlass*>* transitive_interfaces);
-
-  int element_byte_size() const { return 1 << layout_helper_log2_element_size(_layout_helper); }
-
-  bool is_valueArray_klass_slow() const { return true; }
-
-  bool contains_oops() {
-    return element_klass()->contains_oops();
-  }
-
-  // Override.
-  bool element_access_is_atomic() {
-    return element_klass()->is_atomic();
-  }
-
-  oop protection_domain() const;
-
-  static jint array_layout_helper(InlineKlass* vklass); // layout helper for values
-
-  // sizing
-  static int header_size()  { return sizeof(ValueArrayKlass)/HeapWordSize; }
-  int size() const          { return ArrayKlass::static_size(header_size()); }
-
-  jint max_elements() const;
-
-  int oop_size(oop obj) const;
-
-  // Oop Allocation
-  valueArrayOop allocate(int length, TRAPS);
-  oop multi_allocate(int rank, jint* sizes, TRAPS);
-
-  // Naming
-  const char* internal_name() const { return external_name(); }
-
-  // Copying
-  void copy_array(arrayOop s, int src_pos, arrayOop d, int dst_pos, int length, TRAPS);
-
-  // GC specific object visitors
-  //
-  // Mark Sweep
-  int oop_ms_adjust_pointers(oop obj);
-
-
-  template <typename T, typename OopClosureType>
-  inline void oop_oop_iterate(oop obj, OopClosureType* closure);
-
-  template <typename T, typename OopClosureType>
-  inline void oop_oop_iterate_reverse(oop obj, OopClosureType* closure);
-
-  template <typename T, typename OopClosureType>
-  inline void oop_oop_iterate_bounded(oop obj, OopClosureType* closure, MemRegion mr);
-
-  template <typename T, class OopClosureType>
-  inline void oop_oop_iterate_elements(valueArrayOop a, OopClosureType* closure);
-
-private:
-  template <typename T, class OopClosureType>
-  inline void oop_oop_iterate_elements_specialized(valueArrayOop a, OopClosureType* closure);
-
-  template <typename T, class OopClosureType>
-  inline void oop_oop_iterate_elements_bounded(valueArrayOop a, OopClosureType* closure, MemRegion mr);
-
-  template <typename T, class OopClosureType>
-  inline void oop_oop_iterate_elements_specialized_bounded(valueArrayOop a, OopClosureType* closure, void* low, void* high);
-
- public:
-  // Printing
-  void print_on(outputStream* st) const;
-  void print_value_on(outputStream* st) const;
-
-  void oop_print_value_on(oop obj, outputStream* st);
-#ifndef PRODUCT
-  void oop_print_on(oop obj, outputStream* st);
-#endif
-
-  // Verification
-  void verify_on(outputStream* st);
-  void oop_verify_on(oop obj, outputStream* st);
-};
-
-#endif
-
diff a/src/hotspot/share/oops/valueArrayKlass.inline.hpp b/src/hotspot/share/oops/valueArrayKlass.inline.hpp
--- a/src/hotspot/share/oops/valueArrayKlass.inline.hpp
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- *
- */
-#ifndef SHARE_VM_OOPS_VALUEARRAYKLASS_INLINE_HPP
-#define SHARE_VM_OOPS_VALUEARRAYKLASS_INLINE_HPP
-
-#include "memory/memRegion.hpp"
-#include "memory/iterator.hpp"
-#include "oops/arrayKlass.hpp"
-#include "oops/klass.hpp"
-#include "oops/oop.inline.hpp"
-#include "oops/valueArrayKlass.hpp"
-#include "oops/valueArrayOop.hpp"
-#include "oops/valueArrayOop.inline.hpp"
-#include "oops/inlineKlass.hpp"
-#include "oops/inlineKlass.inline.hpp"
-#include "utilities/macros.hpp"
-
-/*
- * Warning incomplete: requires embedded oops, not yet enabled, so consider this a "sketch-up" of oop iterators
- */
-
-template <typename T, class OopClosureType>
-void ValueArrayKlass::oop_oop_iterate_elements_specialized(valueArrayOop a,
-                                                           OopClosureType* closure) {
-  assert(contains_oops(), "Nothing to iterate");
-
-  const int shift = Klass::layout_helper_log2_element_size(layout_helper());
-  const int addr_incr = 1 << shift;
-  uintptr_t elem_addr = (uintptr_t) a->base();
-  const uintptr_t stop_addr = elem_addr + ((uintptr_t)a->length() << shift);
-  const int oop_offset = element_klass()->first_field_offset();
-
-  while (elem_addr < stop_addr) {
-    element_klass()->oop_iterate_specialized<T>((address)(elem_addr - oop_offset), closure);
-    elem_addr += addr_incr;
-  }
-}
-
-template <typename T, class OopClosureType>
-void ValueArrayKlass::oop_oop_iterate_elements_specialized_bounded(valueArrayOop a,
-                                                                   OopClosureType* closure,
-                                                                   void* lo, void* hi) {
-  assert(contains_oops(), "Nothing to iterate");
-
-  const int shift = Klass::layout_helper_log2_element_size(layout_helper());
-  const int addr_incr = 1 << shift;
-  uintptr_t elem_addr = (uintptr_t)a->base();
-  uintptr_t stop_addr = elem_addr + ((uintptr_t)a->length() << shift);
-  const int oop_offset = element_klass()->first_field_offset();
-
-  if (elem_addr < (uintptr_t) lo) {
-    uintptr_t diff = ((uintptr_t) lo) - elem_addr;
-    elem_addr += (diff >> shift) << shift;
-  }
-  if (stop_addr > (uintptr_t) hi) {
-    uintptr_t diff = stop_addr - ((uintptr_t) hi);
-    stop_addr -= (diff >> shift) << shift;
-  }
-
-  const uintptr_t end = stop_addr;
-  while (elem_addr < end) {
-    element_klass()->oop_iterate_specialized_bounded<T>((address)(elem_addr - oop_offset), closure, lo, hi);
-    elem_addr += addr_incr;
-  }
-}
-
-template <typename T, class OopClosureType>
-void ValueArrayKlass::oop_oop_iterate_elements(valueArrayOop a, OopClosureType* closure) {
-  if (contains_oops()) {
-    oop_oop_iterate_elements_specialized<T>(a, closure);
-  }
-}
-
-template <typename T, typename OopClosureType>
-void ValueArrayKlass::oop_oop_iterate(oop obj, OopClosureType* closure) {
-  assert(obj->is_valueArray(),"must be a value array");
-  valueArrayOop a = valueArrayOop(obj);
-
-  if (Devirtualizer::do_metadata(closure)) {
-    Devirtualizer::do_klass(closure, obj->klass());
-    Devirtualizer::do_klass(closure, ValueArrayKlass::cast(obj->klass())->element_klass());
-  }
-
-  oop_oop_iterate_elements<T>(a, closure);
-}
-
-template <typename T, typename OopClosureType>
-void ValueArrayKlass::oop_oop_iterate_reverse(oop obj, OopClosureType* closure) {
-  // TODO
-  oop_oop_iterate<T>(obj, closure);
-}
-
-template <typename T, class OopClosureType>
-void ValueArrayKlass::oop_oop_iterate_elements_bounded(valueArrayOop a, OopClosureType* closure, MemRegion mr) {
-  if (contains_oops()) {
-    oop_oop_iterate_elements_specialized_bounded<T>(a, closure, mr.start(), mr.end());
-  }
-}
-
-
-template <typename T, typename OopClosureType>
-void ValueArrayKlass::oop_oop_iterate_bounded(oop obj, OopClosureType* closure, MemRegion mr) {
-  valueArrayOop a = valueArrayOop(obj);
-  if (Devirtualizer::do_metadata(closure)) {
-    Devirtualizer::do_klass(closure, a->klass());
-    Devirtualizer::do_klass(closure, ValueArrayKlass::cast(obj->klass())->element_klass());
-  }
-  oop_oop_iterate_elements_bounded<T>(a, closure, mr);
-}
-
-#endif // SHARE_VM_OOPS_VALUEARRAYKLASS_INLINE_HPP
diff a/src/hotspot/share/oops/valueArrayOop.cpp b/src/hotspot/share/oops/valueArrayOop.cpp
--- a/src/hotspot/share/oops/valueArrayOop.cpp
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- *
- */
-
-#include "precompiled.hpp"
-
-#include "valueArrayOop.hpp"
-#include "valueArrayKlass.inline.hpp"
-
diff a/src/hotspot/share/oops/valueArrayOop.hpp b/src/hotspot/share/oops/valueArrayOop.hpp
--- a/src/hotspot/share/oops/valueArrayOop.hpp
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- *
- */
-
-#ifndef SHARE_VM_OOPS_VALUEARRAYOOP_HPP
-#define SHARE_VM_OOPS_VALUEARRAYOOP_HPP
-
-#include "oops/arrayOop.hpp"
-#include "oops/klass.hpp"
-
-// A valueArrayOop is an array containing value types (may include flatten embedded oop elements).
-
-class valueArrayOopDesc : public arrayOopDesc {
-
- public:
-  void*  base() const;
-  void* value_at_addr(int index, jint lh) const;
-
-  // Return a buffered element from index
-  static oop value_alloc_copy_from_index(valueArrayHandle vah, int index, TRAPS);
-  void value_copy_from_index(int index, oop dst) const;
-  void value_copy_to_index(oop src, int index) const;
-
-  // Sizing
-  static size_t element_size(int lh, int nof_elements) {
-    size_t sz = (size_t) nof_elements;
-    return sz << Klass::layout_helper_log2_element_size(lh);
-  }
-
-  static int object_size(int lh, int length) {
-    julong size_in_bytes = header_size_in_bytes() + element_size(lh, length);
-    julong size_in_words = ((size_in_bytes + (HeapWordSize-1)) >> LogHeapWordSize);
-    assert(size_in_words <= (julong)max_jint, "no overflow");
-    return align_object_size((intptr_t)size_in_words);
-  }
-
-  int object_size() const;
-
-};
-
-#endif // SHARE_VM_OOPS_VALUEARRAYOOP_HPP
diff a/src/hotspot/share/oops/valueArrayOop.inline.hpp b/src/hotspot/share/oops/valueArrayOop.inline.hpp
--- a/src/hotspot/share/oops/valueArrayOop.inline.hpp
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- *
- */
-
-#ifndef SHARE_VM_OOPS_VALUEARRAYOOP_INLINE_HPP
-#define SHARE_VM_OOPS_VALUEARRAYOOP_INLINE_HPP
-
-#include "oops/access.inline.hpp"
-#include "oops/arrayOop.inline.hpp"
-#include "oops/valueArrayOop.hpp"
-#include "oops/inlineKlass.inline.hpp"
-#include "oops/oop.inline.hpp"
-#include "runtime/globals.hpp"
-
-inline void* valueArrayOopDesc::base() const { return arrayOopDesc::base(T_INLINE_TYPE); }
-
-inline void* valueArrayOopDesc::value_at_addr(int index, jint lh) const {
-  assert(is_within_bounds(index), "index out of bounds");
-
-  address addr = (address) base();
-  addr += (index << Klass::layout_helper_log2_element_size(lh));
-  return (void*) addr;
-}
-
-inline int valueArrayOopDesc::object_size() const {
-  return object_size(klass()->layout_helper(), length());
-}
-
-inline oop valueArrayOopDesc::value_alloc_copy_from_index(valueArrayHandle vah, int index, TRAPS) {
-  ValueArrayKlass* vaklass = ValueArrayKlass::cast(vah->klass());
-  InlineKlass* vklass = vaklass->element_klass();
-  if (vklass->is_empty_inline_type()) {
-    return vklass->default_value();
-  } else {
-    oop buf = vklass->allocate_instance_buffer(CHECK_NULL);
-    vklass->inline_copy_payload_to_new_oop(vah->value_at_addr(index, vaklass->layout_helper()) ,buf);
-    return buf;
-  }
-}
-
-inline void valueArrayOopDesc::value_copy_from_index(int index, oop dst) const {
-  ValueArrayKlass* vaklass = ValueArrayKlass::cast(klass());
-  InlineKlass* vklass = vaklass->element_klass();
-  if (vklass->is_empty_inline_type()) {
-    return; // Assumes dst was a new and clean buffer (OptoRuntime::load_unknown_value())
-  } else {
-    void* src = value_at_addr(index, vaklass->layout_helper());
-    return vklass->inline_copy_payload_to_new_oop(src ,dst);
-  }
-}
-
-inline void valueArrayOopDesc::value_copy_to_index(oop src, int index) const {
-  ValueArrayKlass* vaklass = ValueArrayKlass::cast(klass());
-  InlineKlass* vklass = vaklass->element_klass();
-  if (vklass->is_empty_inline_type()) {
-    return;
-  }
-  void* dst = value_at_addr(index, vaklass->layout_helper());
-  vklass->inline_copy_oop_to_payload(src, dst);
-}
-
-
-
-#endif // SHARE_VM_OOPS_VALUEARRAYOOP_INLINE_HPP
diff a/src/hotspot/share/opto/arraycopynode.cpp b/src/hotspot/share/opto/arraycopynode.cpp
--- a/src/hotspot/share/opto/arraycopynode.cpp
+++ b/src/hotspot/share/opto/arraycopynode.cpp
@@ -140,11 +140,11 @@
       // cloning an array we'll do it element by element. If the
       // length input to ArrayCopyNode is constant, length of input
       // array must be too.
 
       assert((get_length_if_constant(phase) == -1) == !ary_src->size()->is_con() ||
-             (ValueArrayFlatten && ary_src->elem()->make_oopptr() != NULL && ary_src->elem()->make_oopptr()->can_be_value_type()) ||
+             (InlineArrayFlatten && ary_src->elem()->make_oopptr() != NULL && ary_src->elem()->make_oopptr()->can_be_value_type()) ||
              phase->is_IterGVN() || phase->C->inlining_incrementally() || StressReflectiveCode, "inconsistent");
       if (ary_src->size()->is_con()) {
         return ary_src->size()->get_con();
       }
       return -1;
diff a/src/hotspot/share/opto/graphKit.cpp b/src/hotspot/share/opto/graphKit.cpp
--- a/src/hotspot/share/opto/graphKit.cpp
+++ b/src/hotspot/share/opto/graphKit.cpp
@@ -3486,11 +3486,11 @@
   // Return final merged results
   set_control( _gvn.transform(region) );
   record_for_igvn(region);
 
   bool not_null_free = !toop->can_be_value_type();
-  bool not_flattenable = !ValueArrayFlatten || not_null_free || (toop->is_valuetypeptr() && !toop->value_klass()->flatten_array());
+  bool not_flattenable = !InlineArrayFlatten || not_null_free || (toop->is_valuetypeptr() && !toop->value_klass()->flatten_array());
   if (EnableValhalla && not_flattenable) {
     // Check if obj has been loaded from an array
     obj = obj->isa_DecodeN() ? obj->in(1) : obj;
     Node* array = NULL;
     if (obj->isa_Load()) {
@@ -3791,11 +3791,11 @@
   if (!StressReflectiveCode && inst_klass != NULL) {
     ciKlass* klass = inst_klass->klass();
     assert(klass != NULL, "klass should not be NULL");
     bool    xklass = inst_klass->klass_is_exact();
     bool can_be_flattened = false;
-    if (ValueArrayFlatten && klass->is_obj_array_klass()) {
+    if (InlineArrayFlatten && klass->is_obj_array_klass()) {
       ciKlass* elem = klass->as_obj_array_klass()->element_klass();
       can_be_flattened = elem->can_be_value_klass() && (!elem->is_valuetype() || elem->as_value_klass()->flatten_array());
     }
     if (xklass || (klass->is_array_klass() && !can_be_flattened)) {
       jint lhelper = klass->layout_helper();
@@ -4081,11 +4081,11 @@
   int   header_size_min  = arrayOopDesc::base_offset_in_bytes(T_BYTE);
   // (T_BYTE has the weakest alignment and size restrictions...)
   if (layout_is_con) {
     int       hsize  = Klass::layout_helper_header_size(layout_con);
     int       eshift = Klass::layout_helper_log2_element_size(layout_con);
-    bool is_value_array = Klass::layout_helper_is_valueArray(layout_con);
+    bool is_value_array = Klass::layout_helper_is_inlineArray(layout_con);
     if ((round_mask & ~right_n_bits(eshift)) == 0)
       round_mask = 0;  // strength-reduce it if it goes away completely
     assert(is_value_array || (hsize & right_n_bits(eshift)) == 0, "hsize is pre-rounded");
     assert(header_size_min <= hsize, "generic minimum is smallest");
     header_size_min = hsize;
diff a/src/hotspot/share/opto/library_call.cpp b/src/hotspot/share/opto/library_call.cpp
--- a/src/hotspot/share/opto/library_call.cpp
+++ b/src/hotspot/share/opto/library_call.cpp
@@ -221,11 +221,11 @@
   }
   Node* generate_typeArray_guard(Node* kls, RegionNode* region) {
     return generate_array_guard_common(kls, region, TypeArray);
   }
   Node* generate_valueArray_guard(Node* kls, RegionNode* region) {
-    assert(ValueArrayFlatten, "can never be flattened");
+    assert(InlineArrayFlatten, "can never be flattened");
     return generate_array_guard_common(kls, region, ValueArray);
   }
   Node* generate_array_guard_common(Node* kls, RegionNode* region, ArrayKind kind);
   Node* generate_virtual_guard(Node* obj_klass, RegionNode* slow_region);
   CallJavaNode* generate_method_call(vmIntrinsics::ID method_id,
@@ -3723,11 +3723,11 @@
     bool query = 0;
     switch(kind) {
       case ObjectArray:    query = Klass::layout_helper_is_objArray(layout_con); break;
       case NonObjectArray: query = !Klass::layout_helper_is_objArray(layout_con); break;
       case TypeArray:      query = Klass::layout_helper_is_typeArray(layout_con); break;
-      case ValueArray:     query = Klass::layout_helper_is_valueArray(layout_con); break;
+      case ValueArray:     query = Klass::layout_helper_is_inlineArray(layout_con); break;
       case AnyArray:       query = Klass::layout_helper_is_array(layout_con); break;
       case NonArray:       query = !Klass::layout_helper_is_array(layout_con); break;
       default:
         ShouldNotReachHere();
     }
@@ -3893,11 +3893,11 @@
   Node* end               = is_copyOfRange? argument(2): argument(1);
   Node* array_type_mirror = is_copyOfRange? argument(3): argument(2);
 
   const TypeAryPtr* original_t = _gvn.type(original)->isa_aryptr();
   const TypeInstPtr* mirror_t = _gvn.type(array_type_mirror)->isa_instptr();
-  if (EnableValhalla && ValueArrayFlatten &&
+  if (EnableValhalla && InlineArrayFlatten &&
       (original_t == NULL || mirror_t == NULL ||
        (mirror_t->java_mirror_type() == NULL &&
         (original_t->elem()->isa_valuetype() ||
          (original_t->elem()->make_oopptr() != NULL &&
           original_t->elem()->make_oopptr()->can_be_value_type()))))) {
@@ -3963,11 +3963,11 @@
           original_kls = load_object_klass(original);
         }
       }
     }
 
-    if (ValueArrayFlatten) {
+    if (InlineArrayFlatten) {
       // Either both or neither new array klass and original array
       // klass must be flattened
       Node* is_flat = generate_valueArray_guard(klass_node, NULL);
       if (!original_t->is_not_flat()) {
         generate_valueArray_guard(original_kls, bailout);
diff a/src/hotspot/share/opto/macroArrayCopy.cpp b/src/hotspot/share/opto/macroArrayCopy.cpp
--- a/src/hotspot/share/opto/macroArrayCopy.cpp
+++ b/src/hotspot/share/opto/macroArrayCopy.cpp
@@ -187,11 +187,11 @@
 
   return is_notp;
 }
 
 Node* PhaseMacroExpand::generate_flattened_array_guard(Node** ctrl, Node* mem, Node* obj_or_klass, RegionNode* region) {
-  assert(ValueArrayFlatten, "can never be flattened");
+  assert(InlineArrayFlatten, "can never be flattened");
   return generate_array_guard(ctrl, mem, obj_or_klass, region, Klass::_lh_array_tag_vt_value);
 }
 
 Node* PhaseMacroExpand::generate_object_array_guard(Node** ctrl, Node* mem, Node* obj_or_klass, RegionNode* region) {
   return generate_array_guard(ctrl, mem, obj_or_klass, region, Klass::_lh_array_tag_obj_value);
@@ -1309,11 +1309,11 @@
     }
 
     RegionNode* slow_region = new RegionNode(1);
     transform_later(slow_region);
 
-    if (ValueArrayFlatten && (top_dest == NULL || !top_dest->is_not_flat())) {
+    if (InlineArrayFlatten && (top_dest == NULL || !top_dest->is_not_flat())) {
       generate_flattened_array_guard(&ctrl, merge_mem, dest, slow_region);
     }
 
     // Call StubRoutines::generic_arraycopy stub.
     Node* mem = generate_arraycopy(ac, NULL, &ctrl, merge_mem, &io,
diff a/src/hotspot/share/opto/parse2.cpp b/src/hotspot/share/opto/parse2.cpp
--- a/src/hotspot/share/opto/parse2.cpp
+++ b/src/hotspot/share/opto/parse2.cpp
@@ -90,11 +90,11 @@
   } else if (elemptr != NULL && elemptr->is_valuetypeptr() && !elemptr->maybe_null()) {
     // Load from non-flattened but flattenable value type array (elements can never be null)
     bt = T_INLINE_TYPE;
   } else if (!ary_t->is_not_flat()) {
     // Cannot statically determine if array is flattened, emit runtime check
-    assert(ValueArrayFlatten && is_reference_type(bt) && elemptr->can_be_value_type() && !ary_t->klass_is_exact() && !ary_t->is_not_null_free() &&
+    assert(InlineArrayFlatten && is_reference_type(bt) && elemptr->can_be_value_type() && !ary_t->klass_is_exact() && !ary_t->is_not_null_free() &&
            (!elemptr->is_valuetypeptr() || elemptr->value_klass()->flatten_array()), "array can't be flattened");
     IdealKit ideal(this);
     IdealVariable res(ideal);
     ideal.declarations_done();
     ideal.if_then(is_non_flattened_array(ary)); {
@@ -296,11 +296,11 @@
         if (stopped()) return;
         dec_sp(3);
       }
     } else if (!ary_t->is_not_flat()) {
       // Array might be flattened, emit runtime checks
-      assert(ValueArrayFlatten && !not_flattenable && elemtype->is_oopptr()->can_be_value_type() &&
+      assert(InlineArrayFlatten && !not_flattenable && elemtype->is_oopptr()->can_be_value_type() &&
              !ary_t->klass_is_exact() && !ary_t->is_not_null_free(), "array can't be flattened");
       IdealKit ideal(this);
       ideal.if_then(is_non_flattened_array(ary)); {
         // non-flattened
         assert(ideal.ctrl()->in(0)->as_If()->is_non_flattened_array_check(&_gvn), "Should be found");
diff a/src/hotspot/share/opto/parse3.cpp b/src/hotspot/share/opto/parse3.cpp
--- a/src/hotspot/share/opto/parse3.cpp
+++ b/src/hotspot/share/opto/parse3.cpp
@@ -24,12 +24,12 @@
 
 #include "precompiled.hpp"
 #include "compiler/compileLog.hpp"
 #include "interpreter/linkResolver.hpp"
 #include "memory/universe.hpp"
+#include "oops/inlineArrayKlass.hpp"
 #include "oops/objArrayKlass.hpp"
-#include "oops/valueArrayKlass.hpp"
 #include "opto/addnode.hpp"
 #include "opto/castnode.hpp"
 #include "opto/memnode.hpp"
 #include "opto/parse.hpp"
 #include "opto/rootnode.hpp"
diff a/src/hotspot/share/opto/parseHelper.cpp b/src/hotspot/share/opto/parseHelper.cpp
--- a/src/hotspot/share/opto/parseHelper.cpp
+++ b/src/hotspot/share/opto/parseHelper.cpp
@@ -24,12 +24,12 @@
 
 #include "precompiled.hpp"
 #include "ci/ciValueKlass.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "compiler/compileLog.hpp"
+#include "oops/inlineArrayKlass.hpp"
 #include "oops/objArrayKlass.hpp"
-#include "oops/valueArrayKlass.hpp"
 #include "opto/addnode.hpp"
 #include "opto/castnode.hpp"
 #include "opto/memnode.hpp"
 #include "opto/mulnode.hpp"
 #include "opto/parse.hpp"
diff a/src/hotspot/share/opto/runtime.cpp b/src/hotspot/share/opto/runtime.cpp
--- a/src/hotspot/share/opto/runtime.cpp
+++ b/src/hotspot/share/opto/runtime.cpp
@@ -44,15 +44,15 @@
 #include "interpreter/linkResolver.hpp"
 #include "logging/log.hpp"
 #include "logging/logStream.hpp"
 #include "memory/oopFactory.hpp"
 #include "memory/resourceArea.hpp"
+#include "oops/inlineArrayKlass.hpp"
+#include "oops/inlineArrayOop.inline.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/typeArrayOop.inline.hpp"
-#include "oops/valueArrayKlass.hpp"
-#include "oops/valueArrayOop.inline.hpp"
 #include "opto/ad.hpp"
 #include "opto/addnode.hpp"
 #include "opto/callnode.hpp"
 #include "opto/cfgnode.hpp"
 #include "opto/graphKit.hpp"
@@ -245,13 +245,13 @@
   assert(check_compiled_frame(thread), "incorrect caller");
 
   // Scavenge and allocate an instance.
   oop result;
 
-  if (array_type->is_valueArray_klass()) {
-    Klass* elem_type = ValueArrayKlass::cast(array_type)->element_klass();
-    result = oopFactory::new_valueArray(elem_type, len, THREAD);
+  if (array_type->is_inlineArray_klass()) {
+    Klass* elem_type = InlineArrayKlass::cast(array_type)->element_klass();
+    result = oopFactory::new_inlineArray(elem_type, len, THREAD);
   } else if (array_type->is_typeArray_klass()) {
     // The oopFactory likes to work with the element type.
     // (We could bypass the oopFactory, since it doesn't add much value.)
     BasicType elem_type = TypeArrayKlass::cast(array_type)->element_type();
     result = oopFactory::new_typeArray(elem_type, len, THREAD);
@@ -1765,11 +1765,11 @@
   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1,fields);
 
   return TypeFunc::make(domain, range);
 }
 
-JRT_LEAF(void, OptoRuntime::load_unknown_value(valueArrayOopDesc* array, int index, instanceOopDesc* buffer))
+JRT_LEAF(void, OptoRuntime::load_unknown_value(inlineArrayOopDesc* array, int index, instanceOopDesc* buffer))
 {
   array->value_copy_from_index(index, buffer);
 }
 JRT_END
 
@@ -1790,11 +1790,11 @@
   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 
   return TypeFunc::make(domain, range);
 }
 
-JRT_LEAF(void, OptoRuntime::store_unknown_value(instanceOopDesc* buffer, valueArrayOopDesc* array, int index))
+JRT_LEAF(void, OptoRuntime::store_unknown_value(instanceOopDesc* buffer, inlineArrayOopDesc* array, int index))
 {
   assert(buffer != NULL, "can't store null into flat array");
   array->value_copy_to_index(buffer, index);
 }
 JRT_END
diff a/src/hotspot/share/opto/runtime.hpp b/src/hotspot/share/opto/runtime.hpp
--- a/src/hotspot/share/opto/runtime.hpp
+++ b/src/hotspot/share/opto/runtime.hpp
@@ -322,13 +322,13 @@
   static const TypeFunc* dtrace_object_alloc_Type();
 
   static const TypeFunc* store_value_type_fields_Type();
   static const TypeFunc* pack_value_type_Type();
 
-  static void load_unknown_value(valueArrayOopDesc* array, int index, instanceOopDesc* buffer);
+  static void load_unknown_value(inlineArrayOopDesc* array, int index, instanceOopDesc* buffer);
   static const TypeFunc *load_unknown_value_Type();
-  static void store_unknown_value(instanceOopDesc* buffer, valueArrayOopDesc* array, int index);
+  static void store_unknown_value(instanceOopDesc* buffer, inlineArrayOopDesc* array, int index);
   static const TypeFunc *store_unknown_value_Type();
 
  private:
  static NamedCounter * volatile _named_counters;
 
diff a/src/hotspot/share/opto/type.cpp b/src/hotspot/share/opto/type.cpp
--- a/src/hotspot/share/opto/type.cpp
+++ b/src/hotspot/share/opto/type.cpp
@@ -3477,11 +3477,11 @@
     if (etype->can_be_value_type()) {
       // Use exact type if element can be a value type
       exact_etype = TypeOopPtr::make_from_klass_common(klass->as_array_klass()->element_klass(), /* klass_change= */ true, /* try_for_exact= */ true);
     }
     bool not_null_free = !exact_etype->can_be_value_type();
-    bool not_flat = !ValueArrayFlatten || not_null_free || (exact_etype->is_valuetypeptr() && !exact_etype->value_klass()->flatten_array());
+    bool not_flat = !InlineArrayFlatten || not_null_free || (exact_etype->is_valuetypeptr() && !exact_etype->value_klass()->flatten_array());
 
     bool xk = etype->klass_is_exact();
     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);
     // We used to pass NotNull in here, asserting that the sub-arrays
     // are all not-null.  This is not true in generally, as code can
diff a/src/hotspot/share/prims/jni.cpp b/src/hotspot/share/prims/jni.cpp
--- a/src/hotspot/share/prims/jni.cpp
+++ b/src/hotspot/share/prims/jni.cpp
@@ -47,22 +47,22 @@
 #include "memory/oopFactory.hpp"
 #include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
 #include "oops/access.inline.hpp"
 #include "oops/arrayOop.inline.hpp"
+#include "oops/inlineArrayOop.inline.hpp"
+#include "oops/inlineKlass.inline.hpp"
 #include "oops/instanceKlass.inline.hpp"
 #include "oops/instanceOop.hpp"
 #include "oops/markWord.hpp"
 #include "oops/method.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "oops/objArrayOop.inline.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/symbol.hpp"
 #include "oops/typeArrayKlass.hpp"
 #include "oops/typeArrayOop.inline.hpp"
-#include "oops/valueArrayOop.inline.hpp"
-#include "oops/inlineKlass.inline.hpp"
 #include "prims/jniCheck.hpp"
 #include "prims/jniExport.hpp"
 #include "prims/jniFastGetField.hpp"
 #include "prims/jvm_misc.hpp"
 #include "prims/jvmtiExport.hpp"
@@ -2517,15 +2517,15 @@
   jobject ret = NULL;
   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&)ret);
   oop res = NULL;
   arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));
   if (arr->is_within_bounds(index)) {
-    if (arr->is_valueArray()) {
-      valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));
+    if (arr->is_inlineArray()) {
+      inlineArrayOop a = inlineArrayOop(JNIHandles::resolve_non_null(array));
       arrayHandle ah(THREAD, a);
-      valueArrayHandle vah(thread, a);
-      res = valueArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK_NULL);
+      inlineArrayHandle vah(thread, a);
+      res = inlineArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK_NULL);
       assert(res != NULL, "Must be set in one of two paths above");
     } else {
       assert(arr->is_objArray(), "If not a valueArray. must be an objArray");
       objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
       res = a->obj_at(index);
@@ -2551,21 +2551,21 @@
    bool oob = false;
    int length = -1;
    oop res = NULL;
    arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));
    if (arr->is_within_bounds(index)) {
-     if (arr->is_valueArray()) {
-       valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));
+     if (arr->is_inlineArray()) {
+       inlineArrayOop a = inlineArrayOop(JNIHandles::resolve_non_null(array));
        oop v = JNIHandles::resolve(value);
-       ValueArrayKlass* vaklass = ValueArrayKlass::cast(a->klass());
+       InlineArrayKlass* vaklass = InlineArrayKlass::cast(a->klass());
        InlineKlass* element_vklass = vaklass->element_klass();
        if (v != NULL && v->is_a(element_vklass)) {
          a->value_copy_to_index(v, index);
        } else {
          ResourceMark rm(THREAD);
          stringStream ss;
-         Klass *kl = ValueArrayKlass::cast(a->klass());
+         Klass *kl = InlineArrayKlass::cast(a->klass());
          ss.print("type mismatch: can not store %s to %s[%d]",
              v->klass()->external_name(),
              kl->external_name(),
              index);
          for (int dims = ArrayKlass::cast(a->klass())->dimension(); dims > 1; --dims) {
@@ -3392,19 +3392,19 @@
   }
   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));
   if (!ar->is_array()) {
     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "Not an array");
   }
-  if (!ar->is_valueArray()) {
+  if (!ar->is_inlineArray()) {
     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "Not a flattened array");
   }
-  ValueArrayKlass* vak = ValueArrayKlass::cast(ar->klass());
+  InlineArrayKlass* vak = InlineArrayKlass::cast(ar->klass());
   if (vak->contains_oops()) {
     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "Flattened array contains oops");
   }
   oop a = lock_gc_or_pin_object(thread, array);
-  valueArrayOop vap = valueArrayOop(a);
+  inlineArrayOop vap = inlineArrayOop(a);
   void* ret = vap->value_at_addr(0, vak->layout_helper());
   return ret;
 JNI_END
 
 JNI_ENTRY(void, jni_ReleaseFlattenedArrayElements(JNIEnv* env, jarray array, void* elem, jint mode))
@@ -3416,14 +3416,14 @@
   JNIWrapper("jni_GetFlattenedElementSize");
   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
   if (!a->is_array()) {
     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Not an array");
   }
-  if (!a->is_valueArray()) {
+  if (!a->is_inlineArray()) {
     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Not a flattened array");
   }
-  ValueArrayKlass* vak = ValueArrayKlass::cast(a->klass());
+  InlineArrayKlass* vak = InlineArrayKlass::cast(a->klass());
   jsize ret = vak->element_byte_size();
   return ret;
 }
 JNI_END
 
@@ -3431,14 +3431,14 @@
   JNIWrapper("jni_GetArrayElementClass");
   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
   if (!a->is_array()) {
     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "Not an array");
   }
-  if (!a->is_valueArray()) {
+  if (!a->is_inlineArray()) {
     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "Not a flattened array");
   }
-  ValueArrayKlass* vak = ValueArrayKlass::cast(a->klass());
+  InlineArrayKlass* vak = InlineArrayKlass::cast(a->klass());
   InlineKlass* vk = vak->element_klass();
   return (jclass) JNIHandles::make_local(vk->java_mirror());
 JNI_END
 
 JNI_ENTRY(jsize, jni_GetFieldOffsetInFlattenedLayout(JNIEnv* env, jclass clazz, const char *name, const char *signature, jboolean* is_inlined))
@@ -3480,11 +3480,11 @@
 
   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));
   if (!ar->is_array()) {
     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "Not an array");
   }
-  if (!ar->is_valueArray()) {
+  if (!ar->is_inlineArray()) {
     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "Not a flattened array");
   }
   Klass* ses_k = SystemDictionary::resolve_or_null(vmSymbols::jdk_internal_vm_jni_SubElementSelector(),
         Handle(THREAD, SystemDictionary::java_system_loader()), Handle(), CHECK_NULL);
   InstanceKlass* ses_ik = InstanceKlass::cast(ses_k);
@@ -3547,13 +3547,13 @@
 JNI_END
 
 JNI_ENTRY(jobject, jni_GetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index))
   JNIWrapper("jni_GetObjectSubElement");
 
-  valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);
+  inlineArrayOop ar =  (inlineArrayOop)JNIHandles::resolve_non_null(array);
   oop slct = JNIHandles::resolve_non_null(selector);
-  ValueArrayKlass* vak = ValueArrayKlass::cast(ar->klass());
+  InlineArrayKlass* vak = InlineArrayKlass::cast(ar->klass());
   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak->element_klass()->java_mirror()) {
     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "Array/Selector mismatch");
   }
   oop res = NULL;
   if (!jdk_internal_vm_jni_SubElementSelector::getIsInlined(slct)) {
@@ -3562,24 +3562,24 @@
     res = HeapAccess<ON_UNKNOWN_OOP_REF>::oop_load_at(ar, offset);
   } else {
     InlineKlass* fieldKlass = InlineKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));
     res = fieldKlass->allocate_instance_buffer(CHECK_NULL);
     // The array might have been moved by the GC, refreshing the arrayOop
-    ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);
+    ar =  (inlineArrayOop)JNIHandles::resolve_non_null(array);
     address addr = (address)ar->value_at_addr(index, vak->layout_helper())
               + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
     fieldKlass->inline_copy_payload_to_new_oop(addr, res);
   }
   return JNIHandles::make_local(res);
 JNI_END
 
 JNI_ENTRY(void, jni_SetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index, jobject value))
   JNIWrapper("jni_SetObjectSubElement");
 
-  valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);
+  inlineArrayOop ar =  (inlineArrayOop)JNIHandles::resolve_non_null(array);
   oop slct = JNIHandles::resolve_non_null(selector);
-  ValueArrayKlass* vak = ValueArrayKlass::cast(ar->klass());
+  InlineArrayKlass* vak = InlineArrayKlass::cast(ar->klass());
   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak->element_klass()->java_mirror()) {
     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), "Array/Selector mismatch");
   }
   oop val = JNIHandles::resolve(value);
   if (val == NULL) {
@@ -3606,13 +3606,13 @@
 #define DEFINE_GETSUBELEMENT(ElementType,Result,ElementBasicType) \
 \
 JNI_ENTRY(ElementType, \
           jni_Get##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index)) \
   JNIWrapper("Get" XSTR(Result) "SubElement"); \
-  valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \
+  inlineArrayOop ar = (inlineArrayOop)JNIHandles::resolve_non_null(array); \
   oop slct = JNIHandles::resolve_non_null(selector); \
-  ValueArrayKlass* vak = ValueArrayKlass::cast(ar->klass()); \
+  InlineArrayKlass* vak = InlineArrayKlass::cast(ar->klass()); \
   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak->element_klass()->java_mirror()) { \
     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Array/Selector mismatch"); \
   } \
   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \
     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Wrong SubElement type"); \
@@ -3635,13 +3635,13 @@
 #define DEFINE_SETSUBELEMENT(ElementType,Result,ElementBasicType) \
 \
 JNI_ENTRY(void, \
           jni_Set##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index, ElementType value)) \
   JNIWrapper("Get" XSTR(Result) "SubElement"); \
-  valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \
+  inlineArrayOop ar = (inlineArrayOop)JNIHandles::resolve_non_null(array); \
   oop slct = JNIHandles::resolve_non_null(selector); \
-  ValueArrayKlass* vak = ValueArrayKlass::cast(ar->klass()); \
+  InlineArrayKlass* vak = InlineArrayKlass::cast(ar->klass()); \
   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak->element_klass()->java_mirror()) { \
     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), "Array/Selector mismatch"); \
   } \
   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \
     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), "Wrong SubElement type"); \
diff a/src/hotspot/share/prims/jvm.cpp b/src/hotspot/share/prims/jvm.cpp
--- a/src/hotspot/share/prims/jvm.cpp
+++ b/src/hotspot/share/prims/jvm.cpp
@@ -49,17 +49,17 @@
 #include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
 #include "oops/access.inline.hpp"
 #include "oops/constantPool.hpp"
 #include "oops/fieldStreams.inline.hpp"
+#include "oops/inlineArrayKlass.hpp"
 #include "oops/instanceKlass.hpp"
 #include "oops/method.hpp"
 #include "oops/recordComponent.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "oops/objArrayOop.inline.hpp"
 #include "oops/oop.inline.hpp"
-#include "oops/valueArrayKlass.hpp"
 #include "prims/jvm_misc.hpp"
 #include "prims/jvmtiExport.hpp"
 #include "prims/jvmtiThreadState.hpp"
 #include "prims/nativeLookup.hpp"
 #include "prims/stackwalk.hpp"
@@ -2542,21 +2542,21 @@
   oop o = JNIHandles::resolve(array);
   Klass* k = o->klass();
   if ((o == NULL) || (!k->is_array_klass())) {
     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
   }
-  if (k->is_valueArray_klass()) {
-    ValueArrayKlass* vk = ValueArrayKlass::cast(k);
+  if (k->is_inlineArray_klass()) {
+    InlineArrayKlass* vk = InlineArrayKlass::cast(k);
     if (!vk->element_access_is_atomic()) {
       /**
        * Need to decide how to implement:
        *
        * 1) Change to objArrayOop layout, therefore oop->klass() differs so
        * then "<atomic>[Qfoo;" klass needs to subclass "[Qfoo;" to pass through
        * "checkcast" & "instanceof"
        *
-       * 2) Use extra header in the valueArrayOop to flag atomicity required and
+       * 2) Use extra header in the inlineArrayOop to flag atomicity required and
        * possibly per instance lock structure. Said info, could be placed in
        * "trailer" rather than disturb the current arrayOop
        */
       Unimplemented();
     }
diff a/src/hotspot/share/prims/unsafe.cpp b/src/hotspot/share/prims/unsafe.cpp
--- a/src/hotspot/share/prims/unsafe.cpp
+++ b/src/hotspot/share/prims/unsafe.cpp
@@ -34,17 +34,17 @@
 #include "memory/resourceArea.hpp"
 #include "logging/log.hpp"
 #include "logging/logStream.hpp"
 #include "oops/access.inline.hpp"
 #include "oops/fieldStreams.inline.hpp"
+#include "oops/inlineArrayKlass.hpp"
+#include "oops/inlineArrayOop.inline.hpp"
+#include "oops/inlineKlass.inline.hpp"
 #include "oops/instanceKlass.inline.hpp"
 #include "oops/objArrayOop.inline.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/typeArrayOop.inline.hpp"
-#include "oops/valueArrayKlass.hpp"
-#include "oops/valueArrayOop.inline.hpp"
-#include "oops/inlineKlass.inline.hpp"
 #include "prims/unsafe.hpp"
 #include "runtime/fieldDescriptor.inline.hpp"
 #include "runtime/globals.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
@@ -299,24 +299,24 @@
       if (log_is_enabled(Trace, valuetypes)) {
         log_trace(valuetypes)("not a field in %s at offset " SIZE_FORMAT_HEX,
                               p->klass()->external_name(), offset);
       }
     }
-  } else if (k->is_valueArray_klass()) {
-    ValueArrayKlass* vak = ValueArrayKlass::cast(k);
+  } else if (k->is_inlineArray_klass()) {
+    InlineArrayKlass* vak = InlineArrayKlass::cast(k);
     int index = (offset - vak->array_header_in_bytes()) / vak->element_byte_size();
-    address dest = (address)((valueArrayOop)p)->value_at_addr(index, vak->layout_helper());
+    address dest = (address)((inlineArrayOop)p)->value_at_addr(index, vak->layout_helper());
     assert(dest == (cast_from_oop<address>(p) + offset), "invalid offset");
   } else {
     ShouldNotReachHere();
   }
 #endif // ASSERT
   if (log_is_enabled(Trace, valuetypes)) {
-    if (k->is_valueArray_klass()) {
-      ValueArrayKlass* vak = ValueArrayKlass::cast(k);
+    if (k->is_inlineArray_klass()) {
+      InlineArrayKlass* vak = InlineArrayKlass::cast(k);
       int index = (offset - vak->array_header_in_bytes()) / vak->element_byte_size();
-      address dest = (address)((valueArrayOop)p)->value_at_addr(index, vak->layout_helper());
+      address dest = (address)((inlineArrayOop)p)->value_at_addr(index, vak->layout_helper());
       log_trace(valuetypes)("%s array type %s index %d element size %d offset " SIZE_FORMAT_HEX " at " INTPTR_FORMAT,
                             p->klass()->external_name(), vak->external_name(),
                             index, vak->element_byte_size(), offset, p2i(dest));
     } else {
       log_trace(valuetypes)("%s field type %s at offset " SIZE_FORMAT_HEX,
@@ -349,11 +349,11 @@
   return vk->first_field_offset();
 } UNSAFE_END
 
 UNSAFE_ENTRY(jboolean, Unsafe_IsFlattenedArray(JNIEnv *env, jobject unsafe, jclass c)) {
   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(c));
-  return k->is_valueArray_klass();
+  return k->is_inlineArray_klass();
 } UNSAFE_END
 
 UNSAFE_ENTRY(jobject, Unsafe_UninitializedDefaultValue(JNIEnv *env, jobject unsafe, jclass vc)) {
   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));
   InlineKlass* vk = InlineKlass::cast(k);
@@ -735,12 +735,12 @@
   } else if (k->is_typeArray_klass()) {
     TypeArrayKlass* tak = TypeArrayKlass::cast(k);
     base  = tak->array_header_in_bytes();
     assert(base == arrayOopDesc::base_offset_in_bytes(tak->element_type()), "array_header_size semantics ok");
     scale = (1 << tak->log2_element_size());
-  } else if (k->is_valueArray_klass()) {
-    ValueArrayKlass* vak = ValueArrayKlass::cast(k);
+  } else if (k->is_inlineArray_klass()) {
+    InlineArrayKlass* vak = InlineArrayKlass::cast(k);
     InlineKlass* vklass = vak->element_klass();
     base = vak->array_header_in_bytes();
     scale = vak->element_byte_size();
   } else {
     ShouldNotReachHere();
diff a/src/hotspot/share/runtime/deoptimization.cpp b/src/hotspot/share/runtime/deoptimization.cpp
--- a/src/hotspot/share/runtime/deoptimization.cpp
+++ b/src/hotspot/share/runtime/deoptimization.cpp
@@ -44,14 +44,14 @@
 #include "oops/method.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "oops/objArrayOop.inline.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/fieldStreams.inline.hpp"
-#include "oops/typeArrayOop.inline.hpp"
-#include "oops/valueArrayKlass.hpp"
-#include "oops/valueArrayOop.hpp"
+#include "oops/inlineArrayKlass.hpp"
+#include "oops/inlineArrayOop.hpp"
 #include "oops/inlineKlass.inline.hpp"
+#include "oops/typeArrayOop.inline.hpp"
 #include "oops/verifyOopClosure.hpp"
 #include "prims/jvmtiThreadState.hpp"
 #include "runtime/atomic.hpp"
 #include "runtime/biasedLocking.hpp"
 #include "runtime/deoptimization.hpp"
@@ -1032,12 +1032,12 @@
 #endif // INCLUDE_JVMCI || INCLUDE_AOT
       InstanceKlass* ik = InstanceKlass::cast(k);
       if (obj == NULL) {
         obj = ik->allocate_instance(THREAD);
       }
-    } else if (k->is_valueArray_klass()) {
-      ValueArrayKlass* ak = ValueArrayKlass::cast(k);
+    } else if (k->is_inlineArray_klass()) {
+      InlineArrayKlass* ak = InlineArrayKlass::cast(k);
       // Value type array must be zeroed because not all memory is reassigned
       obj = ak->allocate(sv->field_size(), THREAD);
     } else if (k->is_typeArray_klass()) {
       TypeArrayKlass* ak = TypeArrayKlass::cast(k);
       assert(sv->field_size() % type2size[ak->element_type()] == 0, "non-integral array length");
@@ -1390,11 +1390,11 @@
   }
   return svIndex;
 }
 
 // restore fields of an eliminated inline type array
-void Deoptimization::reassign_value_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, valueArrayOop obj, ValueArrayKlass* vak, TRAPS) {
+void Deoptimization::reassign_inline_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, inlineArrayOop obj, InlineArrayKlass* vak, TRAPS) {
   InlineKlass* vk = vak->element_klass();
   assert(vk->flatten_array(), "should only be used for flattened inline type arrays");
   // Adjust offset to omit oop header
   int base_offset = arrayOopDesc::base_offset_in_bytes(T_INLINE_TYPE) - InlineKlass::cast(vk)->first_field_offset();
   // Initialize all elements of the flattened inline type array
@@ -1425,13 +1425,13 @@
     }
 #endif // INCLUDE_JVMCI || INCLUDE_AOT
     if (k->is_instance_klass()) {
       InstanceKlass* ik = InstanceKlass::cast(k);
       reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal, 0, CHECK);
-    } else if (k->is_valueArray_klass()) {
-      ValueArrayKlass* vak = ValueArrayKlass::cast(k);
-      reassign_value_array_elements(fr, reg_map, sv, (valueArrayOop) obj(), vak, CHECK);
+    } else if (k->is_inlineArray_klass()) {
+      InlineArrayKlass* vak = InlineArrayKlass::cast(k);
+      reassign_inline_array_elements(fr, reg_map, sv, (inlineArrayOop) obj(), vak, CHECK);
     } else if (k->is_typeArray_klass()) {
       TypeArrayKlass* ak = TypeArrayKlass::cast(k);
       reassign_type_array_elements(fr, reg_map, sv, (typeArrayOop) obj(), ak->element_type());
     } else if (k->is_objArray_klass()) {
       reassign_object_array_elements(fr, reg_map, sv, (objArrayOop) obj());
diff a/src/hotspot/share/runtime/deoptimization.hpp b/src/hotspot/share/runtime/deoptimization.hpp
--- a/src/hotspot/share/runtime/deoptimization.hpp
+++ b/src/hotspot/share/runtime/deoptimization.hpp
@@ -171,11 +171,11 @@
   // Support for restoring non-escaping objects
   static bool realloc_objects(JavaThread* thread, frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, TRAPS);
   static bool realloc_inline_type_result(InlineKlass* vk, const RegisterMap& map, GrowableArray<Handle>& return_oops, TRAPS);
   static void reassign_type_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, typeArrayOop obj, BasicType type);
   static void reassign_object_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, objArrayOop obj);
-  static void reassign_value_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, valueArrayOop obj, ValueArrayKlass* vak, TRAPS);
+  static void reassign_inline_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, inlineArrayOop obj, InlineArrayKlass* vak, TRAPS);
   static void reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal, TRAPS);
   static void relock_objects(GrowableArray<MonitorInfo*>* monitors, JavaThread* thread, bool realloc_failures);
   static void pop_frames_failed_reallocs(JavaThread* thread, vframeArray* array);
 #ifndef PRODUCT
   static void print_objects(GrowableArray<ScopeValue*>* objects, bool realloc_failures);
diff a/src/hotspot/share/runtime/handles.hpp b/src/hotspot/share/runtime/handles.hpp
--- a/src/hotspot/share/runtime/handles.hpp
+++ b/src/hotspot/share/runtime/handles.hpp
@@ -123,11 +123,11 @@
 
 DEF_HANDLE(instance         , is_instance_noinline         )
 DEF_HANDLE(array            , is_array_noinline            )
 DEF_HANDLE(objArray         , is_objArray_noinline         )
 DEF_HANDLE(typeArray        , is_typeArray_noinline        )
-DEF_HANDLE(valueArray       , is_valueArray_noinline       )
+DEF_HANDLE(inlineArray      , is_inlineArray_noinline      )
 
 //------------------------------------------------------------------------------------------------------------------------
 
 // Metadata Handles.  Unlike oop Handles these are needed to prevent metadata
 // from being reclaimed by RedefineClasses.
diff a/src/hotspot/share/runtime/handles.inline.hpp b/src/hotspot/share/runtime/handles.inline.hpp
--- a/src/hotspot/share/runtime/handles.inline.hpp
+++ b/src/hotspot/share/runtime/handles.inline.hpp
@@ -50,11 +50,11 @@
 
 DEF_HANDLE_CONSTR(instance , is_instance_noinline )
 DEF_HANDLE_CONSTR(array    , is_array_noinline    )
 DEF_HANDLE_CONSTR(objArray , is_objArray_noinline )
 DEF_HANDLE_CONSTR(typeArray, is_typeArray_noinline)
-DEF_HANDLE_CONSTR(valueArray, is_valueArray_noinline)
+DEF_HANDLE_CONSTR(inlineArray, is_inlineArray_noinline)
 
 // Constructor for metadata handles
 #define DEF_METADATA_HANDLE_FN(name, type) \
 inline name##Handle::name##Handle(Thread* thread, type* obj) : _value(obj), _thread(thread) { \
   if (obj != NULL) {                                                   \
diff a/src/hotspot/share/runtime/reflection.cpp b/src/hotspot/share/runtime/reflection.cpp
--- a/src/hotspot/share/runtime/reflection.cpp
+++ b/src/hotspot/share/runtime/reflection.cpp
@@ -34,15 +34,15 @@
 #include "interpreter/linkResolver.hpp"
 #include "logging/log.hpp"
 #include "memory/oopFactory.hpp"
 #include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
+#include "oops/inlineKlass.inline.hpp"
 #include "oops/instanceKlass.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "oops/objArrayOop.inline.hpp"
 #include "oops/oop.inline.hpp"
-#include "oops/inlineKlass.inline.hpp"
 #include "oops/typeArrayOop.inline.hpp"
 #include "prims/jvmtiExport.hpp"
 #include "runtime/arguments.hpp"
 #include "runtime/fieldDescriptor.inline.hpp"
 #include "runtime/handles.inline.hpp"
@@ -347,11 +347,11 @@
     Klass* k = java_lang_Class::as_Klass(element_mirror);
     if (k->is_array_klass() && ArrayKlass::cast(k)->dimension() >= MAX_DIM) {
       THROW_0(vmSymbols::java_lang_IllegalArgumentException());
     }
     if (k->is_inline_klass()) {
-      return oopFactory::new_valueArray(k, length, THREAD);
+      return oopFactory::new_inlineArray(k, length, THREAD);
     } else {
       return oopFactory::new_objArray(k, length, THREAD);
     }
   }
 }
diff a/src/hotspot/share/utilities/globalDefinitions.hpp b/src/hotspot/share/utilities/globalDefinitions.hpp
--- a/src/hotspot/share/utilities/globalDefinitions.hpp
+++ b/src/hotspot/share/utilities/globalDefinitions.hpp
@@ -1212,8 +1212,8 @@
 // TEMP!!!!
 // This should be removed after LW2 arrays are implemented (JDK-8220790).
 // It's an alias to (EnableValhalla && (InlineArrayElemMaxFlatSize != 0)),
 // which is actually not 100% correct, but works for the current set of C1/C2
 // implementation and test cases.
-#define ValueArrayFlatten (EnableValhalla && (InlineArrayElemMaxFlatSize != 0))
+#define InlineArrayFlatten (EnableValhalla && (InlineArrayElemMaxFlatSize != 0))
 
 #endif // SHARE_UTILITIES_GLOBALDEFINITIONS_HPP

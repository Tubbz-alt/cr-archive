<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/runtime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/systemDictionary.hpp&quot;
  27 #include &quot;classfile/vmSymbols.hpp&quot;
  28 #include &quot;code/codeCache.hpp&quot;
  29 #include &quot;code/compiledMethod.inline.hpp&quot;
  30 #include &quot;code/compiledIC.hpp&quot;
  31 #include &quot;code/icBuffer.hpp&quot;
  32 #include &quot;code/nmethod.hpp&quot;
  33 #include &quot;code/pcDesc.hpp&quot;
  34 #include &quot;code/scopeDesc.hpp&quot;
  35 #include &quot;code/vtableStubs.hpp&quot;
  36 #include &quot;compiler/compileBroker.hpp&quot;
  37 #include &quot;compiler/oopMap.hpp&quot;
  38 #include &quot;gc/g1/heapRegion.hpp&quot;
  39 #include &quot;gc/shared/barrierSet.hpp&quot;
  40 #include &quot;gc/shared/collectedHeap.hpp&quot;
  41 #include &quot;gc/shared/gcLocker.hpp&quot;
  42 #include &quot;interpreter/bytecode.hpp&quot;
  43 #include &quot;interpreter/interpreter.hpp&quot;
  44 #include &quot;interpreter/linkResolver.hpp&quot;
  45 #include &quot;logging/log.hpp&quot;
  46 #include &quot;logging/logStream.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;oops/objArrayKlass.hpp&quot;
  50 #include &quot;oops/oop.inline.hpp&quot;
  51 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  52 #include &quot;oops/valueArrayKlass.hpp&quot;
  53 #include &quot;oops/valueArrayOop.inline.hpp&quot;
  54 #include &quot;opto/ad.hpp&quot;
  55 #include &quot;opto/addnode.hpp&quot;
  56 #include &quot;opto/callnode.hpp&quot;
  57 #include &quot;opto/cfgnode.hpp&quot;
  58 #include &quot;opto/graphKit.hpp&quot;
  59 #include &quot;opto/machnode.hpp&quot;
  60 #include &quot;opto/matcher.hpp&quot;
  61 #include &quot;opto/memnode.hpp&quot;
  62 #include &quot;opto/mulnode.hpp&quot;
  63 #include &quot;opto/output.hpp&quot;
  64 #include &quot;opto/runtime.hpp&quot;
  65 #include &quot;opto/subnode.hpp&quot;
  66 #include &quot;runtime/atomic.hpp&quot;
  67 #include &quot;runtime/frame.inline.hpp&quot;
  68 #include &quot;runtime/handles.inline.hpp&quot;
  69 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  70 #include &quot;runtime/javaCalls.hpp&quot;
  71 #include &quot;runtime/sharedRuntime.hpp&quot;
  72 #include &quot;runtime/signature.hpp&quot;
  73 #include &quot;runtime/threadCritical.hpp&quot;
  74 #include &quot;runtime/vframe.hpp&quot;
  75 #include &quot;runtime/vframeArray.hpp&quot;
  76 #include &quot;runtime/vframe_hp.hpp&quot;
  77 #include &quot;utilities/copy.hpp&quot;
  78 #include &quot;utilities/preserveException.hpp&quot;
  79 
  80 
  81 // For debugging purposes:
  82 //  To force FullGCALot inside a runtime function, add the following two lines
  83 //
  84 //  Universe::release_fullgc_alot_dummy();
  85 //  MarkSweep::invoke(0, &quot;Debugging&quot;);
  86 //
  87 // At command line specify the parameters: -XX:+FullGCALot -XX:FullGCALotStart=100000000
  88 
  89 
  90 
  91 
  92 // Compiled code entry points
  93 address OptoRuntime::_new_instance_Java                           = NULL;
  94 address OptoRuntime::_new_array_Java                              = NULL;
  95 address OptoRuntime::_new_array_nozero_Java                       = NULL;
  96 address OptoRuntime::_multianewarray2_Java                        = NULL;
  97 address OptoRuntime::_multianewarray3_Java                        = NULL;
  98 address OptoRuntime::_multianewarray4_Java                        = NULL;
  99 address OptoRuntime::_multianewarray5_Java                        = NULL;
 100 address OptoRuntime::_multianewarrayN_Java                        = NULL;
 101 address OptoRuntime::_vtable_must_compile_Java                    = NULL;
 102 address OptoRuntime::_complete_monitor_locking_Java               = NULL;
 103 address OptoRuntime::_monitor_notify_Java                         = NULL;
 104 address OptoRuntime::_monitor_notifyAll_Java                      = NULL;
 105 address OptoRuntime::_rethrow_Java                                = NULL;
 106 
 107 address OptoRuntime::_slow_arraycopy_Java                         = NULL;
 108 address OptoRuntime::_register_finalizer_Java                     = NULL;
 109 
 110 ExceptionBlob* OptoRuntime::_exception_blob;
 111 
 112 // This should be called in an assertion at the start of OptoRuntime routines
 113 // which are entered from compiled code (all of them)
 114 #ifdef ASSERT
 115 static bool check_compiled_frame(JavaThread* thread) {
 116   assert(thread-&gt;last_frame().is_runtime_frame(), &quot;cannot call runtime directly from compiled code&quot;);
 117   RegisterMap map(thread, false);
 118   frame caller = thread-&gt;last_frame().sender(&amp;map);
 119   assert(caller.is_compiled_frame(), &quot;not being called from compiled like code&quot;);
 120   return true;
 121 }
 122 #endif // ASSERT
 123 
 124 
 125 #define gen(env, var, type_func_gen, c_func, fancy_jump, pass_tls, save_arg_regs, return_pc) \
 126   var = generate_stub(env, type_func_gen, CAST_FROM_FN_PTR(address, c_func), #var, fancy_jump, pass_tls, save_arg_regs, return_pc); \
 127   if (var == NULL) { return false; }
 128 
 129 bool OptoRuntime::generate(ciEnv* env) {
 130 
 131   generate_exception_blob();
 132 
 133   // Note: tls: Means fetching the return oop out of the thread-local storage
 134   //
 135   //   variable/name                       type-function-gen              , runtime method                  ,fncy_jp, tls,save_args,retpc
 136   // -------------------------------------------------------------------------------------------------------------------------------
 137   gen(env, _new_instance_Java              , new_instance_Type            , new_instance_C                  ,    0 , true , false, false);
 138   gen(env, _new_array_Java                 , new_array_Type               , new_array_C                     ,    0 , true , false, false);
 139   gen(env, _new_array_nozero_Java          , new_array_Type               , new_array_nozero_C              ,    0 , true , false, false);
 140   gen(env, _multianewarray2_Java           , multianewarray2_Type         , multianewarray2_C               ,    0 , true , false, false);
 141   gen(env, _multianewarray3_Java           , multianewarray3_Type         , multianewarray3_C               ,    0 , true , false, false);
 142   gen(env, _multianewarray4_Java           , multianewarray4_Type         , multianewarray4_C               ,    0 , true , false, false);
 143   gen(env, _multianewarray5_Java           , multianewarray5_Type         , multianewarray5_C               ,    0 , true , false, false);
 144   gen(env, _multianewarrayN_Java           , multianewarrayN_Type         , multianewarrayN_C               ,    0 , true , false, false);
 145   gen(env, _complete_monitor_locking_Java  , complete_monitor_enter_Type  , SharedRuntime::complete_monitor_locking_C, 0, false, false, false);
 146   gen(env, _monitor_notify_Java            , monitor_notify_Type          , monitor_notify_C                ,    0 , false, false, false);
 147   gen(env, _monitor_notifyAll_Java         , monitor_notify_Type          , monitor_notifyAll_C             ,    0 , false, false, false);
 148   gen(env, _rethrow_Java                   , rethrow_Type                 , rethrow_C                       ,    2 , true , false, true );
 149 
 150   gen(env, _slow_arraycopy_Java            , slow_arraycopy_Type          , SharedRuntime::slow_arraycopy_C ,    0 , false, false, false);
 151   gen(env, _register_finalizer_Java        , register_finalizer_Type      , register_finalizer              ,    0 , false, false, false);
 152 
 153   return true;
 154 }
 155 
 156 #undef gen
 157 
 158 
 159 // Helper method to do generation of RunTimeStub&#39;s
 160 address OptoRuntime::generate_stub( ciEnv* env,
 161                                     TypeFunc_generator gen, address C_function,
 162                                     const char *name, int is_fancy_jump,
 163                                     bool pass_tls,
 164                                     bool save_argument_registers,
 165                                     bool return_pc) {
 166 
 167   // Matching the default directive, we currently have no method to match.
 168   DirectiveSet* directive = DirectivesStack::getDefaultDirective(CompileBroker::compiler(CompLevel_full_optimization));
 169   ResourceMark rm;
 170   Compile C( env, gen, C_function, name, is_fancy_jump, pass_tls, save_argument_registers, return_pc, directive);
 171   DirectivesStack::release(directive);
 172   return  C.stub_entry_point();
 173 }
 174 
 175 const char* OptoRuntime::stub_name(address entry) {
 176 #ifndef PRODUCT
 177   CodeBlob* cb = CodeCache::find_blob(entry);
 178   RuntimeStub* rs =(RuntimeStub *)cb;
 179   assert(rs != NULL &amp;&amp; rs-&gt;is_runtime_stub(), &quot;not a runtime stub&quot;);
 180   return rs-&gt;name();
 181 #else
 182   // Fast implementation for product mode (maybe it should be inlined too)
 183   return &quot;runtime stub&quot;;
 184 #endif
 185 }
 186 
 187 
 188 //=============================================================================
 189 // Opto compiler runtime routines
 190 //=============================================================================
 191 
 192 
 193 //=============================allocation======================================
 194 // We failed the fast-path allocation.  Now we need to do a scavenge or GC
 195 // and try allocation again.
 196 
 197 // object allocation
 198 JRT_BLOCK_ENTRY(void, OptoRuntime::new_instance_C(Klass* klass, bool is_larval, JavaThread* thread))
 199   JRT_BLOCK;
 200 #ifndef PRODUCT
 201   SharedRuntime::_new_instance_ctr++;         // new instance requires GC
 202 #endif
 203   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 204 
 205   // These checks are cheap to make and support reflective allocation.
 206   int lh = klass-&gt;layout_helper();
 207   if (Klass::layout_helper_needs_slow_path(lh) || !InstanceKlass::cast(klass)-&gt;is_initialized()) {
 208     Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 209     klass-&gt;check_valid_for_instantiation(false, THREAD);
 210     if (!HAS_PENDING_EXCEPTION) {
 211       InstanceKlass::cast(klass)-&gt;initialize(THREAD);
 212     }
 213   }
 214 
 215   if (!HAS_PENDING_EXCEPTION) {
 216     // Scavenge and allocate an instance.
 217     Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 218     instanceOop result = InstanceKlass::cast(klass)-&gt;allocate_instance(THREAD);
 219     if (is_larval) {
 220       // Check if this is a larval buffer allocation
 221       result-&gt;set_mark(result-&gt;mark().enter_larval_state());
 222     }
 223     thread-&gt;set_vm_result(result);
 224 
 225     // Pass oops back through thread local storage.  Our apparent type to Java
 226     // is that we return an oop, but we can block on exit from this routine and
 227     // a GC can trash the oop in C&#39;s return register.  The generated stub will
 228     // fetch the oop from TLS after any possible GC.
 229   }
 230 
 231   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 232   JRT_BLOCK_END;
 233 
 234   // inform GC that we won&#39;t do card marks for initializing writes.
 235   SharedRuntime::on_slowpath_allocation_exit(thread);
 236 JRT_END
 237 
 238 
 239 // array allocation
 240 JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_C(Klass* array_type, int len, JavaThread *thread))
 241   JRT_BLOCK;
 242 #ifndef PRODUCT
 243   SharedRuntime::_new_array_ctr++;            // new array requires GC
 244 #endif
 245   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 246 
 247   // Scavenge and allocate an instance.
 248   oop result;
 249 
 250   if (array_type-&gt;is_valueArray_klass()) {
 251     Klass* elem_type = ValueArrayKlass::cast(array_type)-&gt;element_klass();
 252     result = oopFactory::new_valueArray(elem_type, len, THREAD);
 253   } else if (array_type-&gt;is_typeArray_klass()) {
 254     // The oopFactory likes to work with the element type.
 255     // (We could bypass the oopFactory, since it doesn&#39;t add much value.)
 256     BasicType elem_type = TypeArrayKlass::cast(array_type)-&gt;element_type();
 257     result = oopFactory::new_typeArray(elem_type, len, THREAD);
 258   } else {
 259     Handle holder(THREAD, array_type-&gt;klass_holder()); // keep the array klass alive
 260     result = ObjArrayKlass::cast(array_type)-&gt;allocate(len, THREAD);
 261   }
 262 
 263   // Pass oops back through thread local storage.  Our apparent type to Java
 264   // is that we return an oop, but we can block on exit from this routine and
 265   // a GC can trash the oop in C&#39;s return register.  The generated stub will
 266   // fetch the oop from TLS after any possible GC.
 267   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 268   thread-&gt;set_vm_result(result);
 269   JRT_BLOCK_END;
 270 
 271   // inform GC that we won&#39;t do card marks for initializing writes.
 272   SharedRuntime::on_slowpath_allocation_exit(thread);
 273 JRT_END
 274 
 275 // array allocation without zeroing
 276 JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_nozero_C(Klass* array_type, int len, JavaThread *thread))
 277   JRT_BLOCK;
 278 #ifndef PRODUCT
 279   SharedRuntime::_new_array_ctr++;            // new array requires GC
 280 #endif
 281   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 282 
 283   // Scavenge and allocate an instance.
 284   oop result;
 285 
 286   assert(array_type-&gt;is_typeArray_klass(), &quot;should be called only for type array&quot;);
 287   // The oopFactory likes to work with the element type.
 288   BasicType elem_type = TypeArrayKlass::cast(array_type)-&gt;element_type();
 289   result = oopFactory::new_typeArray_nozero(elem_type, len, THREAD);
 290 
 291   // Pass oops back through thread local storage.  Our apparent type to Java
 292   // is that we return an oop, but we can block on exit from this routine and
 293   // a GC can trash the oop in C&#39;s return register.  The generated stub will
 294   // fetch the oop from TLS after any possible GC.
 295   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 296   thread-&gt;set_vm_result(result);
 297   JRT_BLOCK_END;
 298 
 299 
 300   // inform GC that we won&#39;t do card marks for initializing writes.
 301   SharedRuntime::on_slowpath_allocation_exit(thread);
 302 
 303   oop result = thread-&gt;vm_result();
 304   if ((len &gt; 0) &amp;&amp; (result != NULL) &amp;&amp;
 305       is_deoptimized_caller_frame(thread)) {
 306     // Zero array here if the caller is deoptimized.
 307     int size = ((typeArrayOop)result)-&gt;object_size();
 308     BasicType elem_type = TypeArrayKlass::cast(array_type)-&gt;element_type();
 309     const size_t hs = arrayOopDesc::header_size(elem_type);
 310     // Align to next 8 bytes to avoid trashing arrays&#39;s length.
 311     const size_t aligned_hs = align_object_offset(hs);
 312     HeapWord* obj = cast_from_oop&lt;HeapWord*&gt;(result);
 313     if (aligned_hs &gt; hs) {
 314       Copy::zero_to_words(obj+hs, aligned_hs-hs);
 315     }
 316     // Optimized zeroing.
 317     Copy::fill_to_aligned_words(obj+aligned_hs, size-aligned_hs);
 318   }
 319 
 320 JRT_END
 321 
 322 // Note: multianewarray for one dimension is handled inline by GraphKit::new_array.
 323 
 324 // multianewarray for 2 dimensions
 325 JRT_ENTRY(void, OptoRuntime::multianewarray2_C(Klass* elem_type, int len1, int len2, JavaThread *thread))
 326 #ifndef PRODUCT
 327   SharedRuntime::_multi2_ctr++;                // multianewarray for 1 dimension
 328 #endif
 329   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 330   assert(elem_type-&gt;is_klass(), &quot;not a class&quot;);
 331   jint dims[2];
 332   dims[0] = len1;
 333   dims[1] = len2;
 334   Handle holder(THREAD, elem_type-&gt;klass_holder()); // keep the klass alive
 335   oop obj = ArrayKlass::cast(elem_type)-&gt;multi_allocate(2, dims, THREAD);
 336   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 337   thread-&gt;set_vm_result(obj);
 338 JRT_END
 339 
 340 // multianewarray for 3 dimensions
 341 JRT_ENTRY(void, OptoRuntime::multianewarray3_C(Klass* elem_type, int len1, int len2, int len3, JavaThread *thread))
 342 #ifndef PRODUCT
 343   SharedRuntime::_multi3_ctr++;                // multianewarray for 1 dimension
 344 #endif
 345   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 346   assert(elem_type-&gt;is_klass(), &quot;not a class&quot;);
 347   jint dims[3];
 348   dims[0] = len1;
 349   dims[1] = len2;
 350   dims[2] = len3;
 351   Handle holder(THREAD, elem_type-&gt;klass_holder()); // keep the klass alive
 352   oop obj = ArrayKlass::cast(elem_type)-&gt;multi_allocate(3, dims, THREAD);
 353   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 354   thread-&gt;set_vm_result(obj);
 355 JRT_END
 356 
 357 // multianewarray for 4 dimensions
 358 JRT_ENTRY(void, OptoRuntime::multianewarray4_C(Klass* elem_type, int len1, int len2, int len3, int len4, JavaThread *thread))
 359 #ifndef PRODUCT
 360   SharedRuntime::_multi4_ctr++;                // multianewarray for 1 dimension
 361 #endif
 362   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 363   assert(elem_type-&gt;is_klass(), &quot;not a class&quot;);
 364   jint dims[4];
 365   dims[0] = len1;
 366   dims[1] = len2;
 367   dims[2] = len3;
 368   dims[3] = len4;
 369   Handle holder(THREAD, elem_type-&gt;klass_holder()); // keep the klass alive
 370   oop obj = ArrayKlass::cast(elem_type)-&gt;multi_allocate(4, dims, THREAD);
 371   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 372   thread-&gt;set_vm_result(obj);
 373 JRT_END
 374 
 375 // multianewarray for 5 dimensions
 376 JRT_ENTRY(void, OptoRuntime::multianewarray5_C(Klass* elem_type, int len1, int len2, int len3, int len4, int len5, JavaThread *thread))
 377 #ifndef PRODUCT
 378   SharedRuntime::_multi5_ctr++;                // multianewarray for 1 dimension
 379 #endif
 380   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 381   assert(elem_type-&gt;is_klass(), &quot;not a class&quot;);
 382   jint dims[5];
 383   dims[0] = len1;
 384   dims[1] = len2;
 385   dims[2] = len3;
 386   dims[3] = len4;
 387   dims[4] = len5;
 388   Handle holder(THREAD, elem_type-&gt;klass_holder()); // keep the klass alive
 389   oop obj = ArrayKlass::cast(elem_type)-&gt;multi_allocate(5, dims, THREAD);
 390   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 391   thread-&gt;set_vm_result(obj);
 392 JRT_END
 393 
 394 JRT_ENTRY(void, OptoRuntime::multianewarrayN_C(Klass* elem_type, arrayOopDesc* dims, JavaThread *thread))
 395   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 396   assert(elem_type-&gt;is_klass(), &quot;not a class&quot;);
 397   assert(oop(dims)-&gt;is_typeArray(), &quot;not an array&quot;);
 398 
 399   ResourceMark rm;
 400   jint len = dims-&gt;length();
 401   assert(len &gt; 0, &quot;Dimensions array should contain data&quot;);
 402   jint *c_dims = NEW_RESOURCE_ARRAY(jint, len);
 403   ArrayAccess&lt;&gt;::arraycopy_to_native&lt;&gt;(dims, typeArrayOopDesc::element_offset&lt;jint&gt;(0),
 404                                        c_dims, len);
 405 
 406   Handle holder(THREAD, elem_type-&gt;klass_holder()); // keep the klass alive
 407   oop obj = ArrayKlass::cast(elem_type)-&gt;multi_allocate(len, c_dims, THREAD);
 408   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 409   thread-&gt;set_vm_result(obj);
 410 JRT_END
 411 
 412 JRT_BLOCK_ENTRY(void, OptoRuntime::monitor_notify_C(oopDesc* obj, JavaThread *thread))
 413 
 414   // Very few notify/notifyAll operations find any threads on the waitset, so
 415   // the dominant fast-path is to simply return.
 416   // Relatedly, it&#39;s critical that notify/notifyAll be fast in order to
 417   // reduce lock hold times.
 418   if (!SafepointSynchronize::is_synchronizing()) {
 419     if (ObjectSynchronizer::quick_notify(obj, thread, false)) {
 420       return;
 421     }
 422   }
 423 
 424   // This is the case the fast-path above isn&#39;t provisioned to handle.
 425   // The fast-path is designed to handle frequently arising cases in an efficient manner.
 426   // (The fast-path is just a degenerate variant of the slow-path).
 427   // Perform the dreaded state transition and pass control into the slow-path.
 428   JRT_BLOCK;
 429   Handle h_obj(THREAD, obj);
 430   ObjectSynchronizer::notify(h_obj, CHECK);
 431   JRT_BLOCK_END;
 432 JRT_END
 433 
 434 JRT_BLOCK_ENTRY(void, OptoRuntime::monitor_notifyAll_C(oopDesc* obj, JavaThread *thread))
 435 
 436   if (!SafepointSynchronize::is_synchronizing() ) {
 437     if (ObjectSynchronizer::quick_notify(obj, thread, true)) {
 438       return;
 439     }
 440   }
 441 
 442   // This is the case the fast-path above isn&#39;t provisioned to handle.
 443   // The fast-path is designed to handle frequently arising cases in an efficient manner.
 444   // (The fast-path is just a degenerate variant of the slow-path).
 445   // Perform the dreaded state transition and pass control into the slow-path.
 446   JRT_BLOCK;
 447   Handle h_obj(THREAD, obj);
 448   ObjectSynchronizer::notifyall(h_obj, CHECK);
 449   JRT_BLOCK_END;
 450 JRT_END
 451 
 452 const TypeFunc *OptoRuntime::new_instance_Type() {
 453   // create input type (domain)
 454   const Type **fields = TypeTuple::fields(2);
 455   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // Klass to be allocated
 456   fields[TypeFunc::Parms+1] = TypeInt::BOOL;        // is_larval
 457   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 458 
 459   // create result type (range)
 460   fields = TypeTuple::fields(1);
 461   fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL; // Returned oop
 462 
 463   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 464 
 465   return TypeFunc::make(domain, range);
 466 }
 467 
 468 
 469 const TypeFunc *OptoRuntime::athrow_Type() {
 470   // create input type (domain)
 471   const Type **fields = TypeTuple::fields(1);
 472   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // Klass to be allocated
 473   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 474 
 475   // create result type (range)
 476   fields = TypeTuple::fields(0);
 477 
 478   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 479 
 480   return TypeFunc::make(domain, range);
 481 }
 482 
 483 
 484 const TypeFunc *OptoRuntime::new_array_Type() {
 485   // create input type (domain)
 486   const Type **fields = TypeTuple::fields(2);
 487   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;   // element klass
 488   fields[TypeFunc::Parms+1] = TypeInt::INT;       // array size
 489   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 490 
 491   // create result type (range)
 492   fields = TypeTuple::fields(1);
 493   fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL; // Returned oop
 494 
 495   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 496 
 497   return TypeFunc::make(domain, range);
 498 }
 499 
 500 const TypeFunc *OptoRuntime::multianewarray_Type(int ndim) {
 501   // create input type (domain)
 502   const int nargs = ndim + 1;
 503   const Type **fields = TypeTuple::fields(nargs);
 504   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;   // element klass
 505   for( int i = 1; i &lt; nargs; i++ )
 506     fields[TypeFunc::Parms + i] = TypeInt::INT;       // array size
 507   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+nargs, fields);
 508 
 509   // create result type (range)
 510   fields = TypeTuple::fields(1);
 511   fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL; // Returned oop
 512   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 513 
 514   return TypeFunc::make(domain, range);
 515 }
 516 
 517 const TypeFunc *OptoRuntime::multianewarray2_Type() {
 518   return multianewarray_Type(2);
 519 }
 520 
 521 const TypeFunc *OptoRuntime::multianewarray3_Type() {
 522   return multianewarray_Type(3);
 523 }
 524 
 525 const TypeFunc *OptoRuntime::multianewarray4_Type() {
 526   return multianewarray_Type(4);
 527 }
 528 
 529 const TypeFunc *OptoRuntime::multianewarray5_Type() {
 530   return multianewarray_Type(5);
 531 }
 532 
 533 const TypeFunc *OptoRuntime::multianewarrayN_Type() {
 534   // create input type (domain)
 535   const Type **fields = TypeTuple::fields(2);
 536   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;   // element klass
 537   fields[TypeFunc::Parms+1] = TypeInstPtr::NOTNULL;   // array of dim sizes
 538   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 539 
 540   // create result type (range)
 541   fields = TypeTuple::fields(1);
 542   fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL; // Returned oop
 543   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 544 
 545   return TypeFunc::make(domain, range);
 546 }
 547 
 548 const TypeFunc *OptoRuntime::uncommon_trap_Type() {
 549   // create input type (domain)
 550   const Type **fields = TypeTuple::fields(1);
 551   fields[TypeFunc::Parms+0] = TypeInt::INT; // trap_reason (deopt reason and action)
 552   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 553 
 554   // create result type (range)
 555   fields = TypeTuple::fields(0);
 556   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 557 
 558   return TypeFunc::make(domain, range);
 559 }
 560 
 561 //-----------------------------------------------------------------------------
 562 // Monitor Handling
 563 const TypeFunc *OptoRuntime::complete_monitor_enter_Type() {
 564   // create input type (domain)
 565   const Type **fields = TypeTuple::fields(2);
 566   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;  // Object to be Locked
 567   fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM;   // Address of stack location for lock
 568   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2,fields);
 569 
 570   // create result type (range)
 571   fields = TypeTuple::fields(0);
 572 
 573   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0,fields);
 574 
 575   return TypeFunc::make(domain, range);
 576 }
 577 
 578 
 579 //-----------------------------------------------------------------------------
 580 const TypeFunc *OptoRuntime::complete_monitor_exit_Type() {
 581   // create input type (domain)
 582   const Type **fields = TypeTuple::fields(3);
 583   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;  // Object to be Locked
 584   fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM;    // Address of stack location for lock - BasicLock
 585   fields[TypeFunc::Parms+2] = TypeRawPtr::BOTTOM;    // Thread pointer (Self)
 586   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+3, fields);
 587 
 588   // create result type (range)
 589   fields = TypeTuple::fields(0);
 590 
 591   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 592 
 593   return TypeFunc::make(domain, range);
 594 }
 595 
 596 const TypeFunc *OptoRuntime::monitor_notify_Type() {
 597   // create input type (domain)
 598   const Type **fields = TypeTuple::fields(1);
 599   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;  // Object to be Locked
 600   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 601 
 602   // create result type (range)
 603   fields = TypeTuple::fields(0);
 604   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 605   return TypeFunc::make(domain, range);
 606 }
 607 
 608 const TypeFunc* OptoRuntime::flush_windows_Type() {
 609   // create input type (domain)
 610   const Type** fields = TypeTuple::fields(1);
 611   fields[TypeFunc::Parms+0] = NULL; // void
 612   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms, fields);
 613 
 614   // create result type
 615   fields = TypeTuple::fields(1);
 616   fields[TypeFunc::Parms+0] = NULL; // void
 617   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);
 618 
 619   return TypeFunc::make(domain, range);
 620 }
 621 
 622 const TypeFunc* OptoRuntime::l2f_Type() {
 623   // create input type (domain)
 624   const Type **fields = TypeTuple::fields(2);
 625   fields[TypeFunc::Parms+0] = TypeLong::LONG;
 626   fields[TypeFunc::Parms+1] = Type::HALF;
 627   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 628 
 629   // create result type (range)
 630   fields = TypeTuple::fields(1);
 631   fields[TypeFunc::Parms+0] = Type::FLOAT;
 632   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 633 
 634   return TypeFunc::make(domain, range);
 635 }
 636 
 637 const TypeFunc* OptoRuntime::modf_Type() {
 638   const Type **fields = TypeTuple::fields(2);
 639   fields[TypeFunc::Parms+0] = Type::FLOAT;
 640   fields[TypeFunc::Parms+1] = Type::FLOAT;
 641   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 642 
 643   // create result type (range)
 644   fields = TypeTuple::fields(1);
 645   fields[TypeFunc::Parms+0] = Type::FLOAT;
 646 
 647   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 648 
 649   return TypeFunc::make(domain, range);
 650 }
 651 
 652 const TypeFunc *OptoRuntime::Math_D_D_Type() {
 653   // create input type (domain)
 654   const Type **fields = TypeTuple::fields(2);
 655   // Symbol* name of class to be loaded
 656   fields[TypeFunc::Parms+0] = Type::DOUBLE;
 657   fields[TypeFunc::Parms+1] = Type::HALF;
 658   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 659 
 660   // create result type (range)
 661   fields = TypeTuple::fields(2);
 662   fields[TypeFunc::Parms+0] = Type::DOUBLE;
 663   fields[TypeFunc::Parms+1] = Type::HALF;
 664   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+2, fields);
 665 
 666   return TypeFunc::make(domain, range);
 667 }
 668 
 669 const TypeFunc* OptoRuntime::Math_DD_D_Type() {
 670   const Type **fields = TypeTuple::fields(4);
 671   fields[TypeFunc::Parms+0] = Type::DOUBLE;
 672   fields[TypeFunc::Parms+1] = Type::HALF;
 673   fields[TypeFunc::Parms+2] = Type::DOUBLE;
 674   fields[TypeFunc::Parms+3] = Type::HALF;
 675   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+4, fields);
 676 
 677   // create result type (range)
 678   fields = TypeTuple::fields(2);
 679   fields[TypeFunc::Parms+0] = Type::DOUBLE;
 680   fields[TypeFunc::Parms+1] = Type::HALF;
 681   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+2, fields);
 682 
 683   return TypeFunc::make(domain, range);
 684 }
 685 
 686 //-------------- currentTimeMillis, currentTimeNanos, etc
 687 
 688 const TypeFunc* OptoRuntime::void_long_Type() {
 689   // create input type (domain)
 690   const Type **fields = TypeTuple::fields(0);
 691   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+0, fields);
 692 
 693   // create result type (range)
 694   fields = TypeTuple::fields(2);
 695   fields[TypeFunc::Parms+0] = TypeLong::LONG;
 696   fields[TypeFunc::Parms+1] = Type::HALF;
 697   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+2, fields);
 698 
 699   return TypeFunc::make(domain, range);
 700 }
 701 
 702 // arraycopy stub variations:
 703 enum ArrayCopyType {
 704   ac_fast,                      // void(ptr, ptr, size_t)
 705   ac_checkcast,                 //  int(ptr, ptr, size_t, size_t, ptr)
 706   ac_slow,                      // void(ptr, int, ptr, int, int)
 707   ac_generic                    //  int(ptr, int, ptr, int, int)
 708 };
 709 
 710 static const TypeFunc* make_arraycopy_Type(ArrayCopyType act) {
 711   // create input type (domain)
 712   int num_args      = (act == ac_fast ? 3 : 5);
 713   int num_size_args = (act == ac_fast ? 1 : act == ac_checkcast ? 2 : 0);
 714   int argcnt = num_args;
 715   LP64_ONLY(argcnt += num_size_args); // halfwords for lengths
 716   const Type** fields = TypeTuple::fields(argcnt);
 717   int argp = TypeFunc::Parms;
 718   fields[argp++] = TypePtr::NOTNULL;    // src
 719   if (num_size_args == 0) {
 720     fields[argp++] = TypeInt::INT;      // src_pos
 721   }
 722   fields[argp++] = TypePtr::NOTNULL;    // dest
 723   if (num_size_args == 0) {
 724     fields[argp++] = TypeInt::INT;      // dest_pos
 725     fields[argp++] = TypeInt::INT;      // length
 726   }
 727   while (num_size_args-- &gt; 0) {
 728     fields[argp++] = TypeX_X;               // size in whatevers (size_t)
 729     LP64_ONLY(fields[argp++] = Type::HALF); // other half of long length
 730   }
 731   if (act == ac_checkcast) {
 732     fields[argp++] = TypePtr::NOTNULL;  // super_klass
 733   }
 734   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding of act&quot;);
 735   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 736 
 737   // create result type if needed
 738   int retcnt = (act == ac_checkcast || act == ac_generic ? 1 : 0);
 739   fields = TypeTuple::fields(1);
 740   if (retcnt == 0)
 741     fields[TypeFunc::Parms+0] = NULL; // void
 742   else
 743     fields[TypeFunc::Parms+0] = TypeInt::INT; // status result, if needed
 744   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+retcnt, fields);
 745   return TypeFunc::make(domain, range);
 746 }
 747 
 748 const TypeFunc* OptoRuntime::fast_arraycopy_Type() {
 749   // This signature is simple:  Two base pointers and a size_t.
 750   return make_arraycopy_Type(ac_fast);
 751 }
 752 
 753 const TypeFunc* OptoRuntime::checkcast_arraycopy_Type() {
 754   // An extension of fast_arraycopy_Type which adds type checking.
 755   return make_arraycopy_Type(ac_checkcast);
 756 }
 757 
 758 const TypeFunc* OptoRuntime::slow_arraycopy_Type() {
 759   // This signature is exactly the same as System.arraycopy.
 760   // There are no intptr_t (int/long) arguments.
 761   return make_arraycopy_Type(ac_slow);
 762 }
 763 
 764 const TypeFunc* OptoRuntime::generic_arraycopy_Type() {
 765   // This signature is like System.arraycopy, except that it returns status.
 766   return make_arraycopy_Type(ac_generic);
 767 }
 768 
 769 
 770 const TypeFunc* OptoRuntime::array_fill_Type() {
 771   const Type** fields;
 772   int argp = TypeFunc::Parms;
 773   // create input type (domain): pointer, int, size_t
 774   fields = TypeTuple::fields(3 LP64_ONLY( + 1));
 775   fields[argp++] = TypePtr::NOTNULL;
 776   fields[argp++] = TypeInt::INT;
 777   fields[argp++] = TypeX_X;               // size in whatevers (size_t)
 778   LP64_ONLY(fields[argp++] = Type::HALF); // other half of long length
 779   const TypeTuple *domain = TypeTuple::make(argp, fields);
 780 
 781   // create result type
 782   fields = TypeTuple::fields(1);
 783   fields[TypeFunc::Parms+0] = NULL; // void
 784   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);
 785 
 786   return TypeFunc::make(domain, range);
 787 }
 788 
 789 // for aescrypt encrypt/decrypt operations, just three pointers returning void (length is constant)
 790 const TypeFunc* OptoRuntime::aescrypt_block_Type() {
 791   // create input type (domain)
 792   int num_args      = 3;
 793   if (Matcher::pass_original_key_for_aes()) {
 794     num_args = 4;
 795   }
 796   int argcnt = num_args;
 797   const Type** fields = TypeTuple::fields(argcnt);
 798   int argp = TypeFunc::Parms;
 799   fields[argp++] = TypePtr::NOTNULL;    // src
 800   fields[argp++] = TypePtr::NOTNULL;    // dest
 801   fields[argp++] = TypePtr::NOTNULL;    // k array
 802   if (Matcher::pass_original_key_for_aes()) {
 803     fields[argp++] = TypePtr::NOTNULL;    // original k array
 804   }
 805   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 806   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 807 
 808   // no result type needed
 809   fields = TypeTuple::fields(1);
 810   fields[TypeFunc::Parms+0] = NULL; // void
 811   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
 812   return TypeFunc::make(domain, range);
 813 }
 814 
 815 /**
 816  * int updateBytesCRC32(int crc, byte* b, int len)
 817  */
 818 const TypeFunc* OptoRuntime::updateBytesCRC32_Type() {
 819   // create input type (domain)
 820   int num_args      = 3;
 821   int argcnt = num_args;
 822   const Type** fields = TypeTuple::fields(argcnt);
 823   int argp = TypeFunc::Parms;
 824   fields[argp++] = TypeInt::INT;        // crc
 825   fields[argp++] = TypePtr::NOTNULL;    // src
 826   fields[argp++] = TypeInt::INT;        // len
 827   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 828   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 829 
 830   // result type needed
 831   fields = TypeTuple::fields(1);
 832   fields[TypeFunc::Parms+0] = TypeInt::INT; // crc result
 833   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
 834   return TypeFunc::make(domain, range);
 835 }
 836 
 837 /**
 838  * int updateBytesCRC32C(int crc, byte* buf, int len, int* table)
 839  */
 840 const TypeFunc* OptoRuntime::updateBytesCRC32C_Type() {
 841   // create input type (domain)
 842   int num_args      = 4;
 843   int argcnt = num_args;
 844   const Type** fields = TypeTuple::fields(argcnt);
 845   int argp = TypeFunc::Parms;
 846   fields[argp++] = TypeInt::INT;        // crc
 847   fields[argp++] = TypePtr::NOTNULL;    // buf
 848   fields[argp++] = TypeInt::INT;        // len
 849   fields[argp++] = TypePtr::NOTNULL;    // table
 850   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 851   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 852 
 853   // result type needed
 854   fields = TypeTuple::fields(1);
 855   fields[TypeFunc::Parms+0] = TypeInt::INT; // crc result
 856   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
 857   return TypeFunc::make(domain, range);
 858 }
 859 
 860 /**
 861 *  int updateBytesAdler32(int adler, bytes* b, int off, int len)
 862 */
 863 const TypeFunc* OptoRuntime::updateBytesAdler32_Type() {
 864   // create input type (domain)
 865   int num_args      = 3;
 866   int argcnt = num_args;
 867   const Type** fields = TypeTuple::fields(argcnt);
 868   int argp = TypeFunc::Parms;
 869   fields[argp++] = TypeInt::INT;        // crc
 870   fields[argp++] = TypePtr::NOTNULL;    // src + offset
 871   fields[argp++] = TypeInt::INT;        // len
 872   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 873   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 874 
 875   // result type needed
 876   fields = TypeTuple::fields(1);
 877   fields[TypeFunc::Parms+0] = TypeInt::INT; // crc result
 878   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
 879   return TypeFunc::make(domain, range);
 880 }
 881 
 882 // for cipherBlockChaining calls of aescrypt encrypt/decrypt, four pointers and a length, returning int
 883 const TypeFunc* OptoRuntime::cipherBlockChaining_aescrypt_Type() {
 884   // create input type (domain)
 885   int num_args      = 5;
 886   if (Matcher::pass_original_key_for_aes()) {
 887     num_args = 6;
 888   }
 889   int argcnt = num_args;
 890   const Type** fields = TypeTuple::fields(argcnt);
 891   int argp = TypeFunc::Parms;
 892   fields[argp++] = TypePtr::NOTNULL;    // src
 893   fields[argp++] = TypePtr::NOTNULL;    // dest
 894   fields[argp++] = TypePtr::NOTNULL;    // k array
 895   fields[argp++] = TypePtr::NOTNULL;    // r array
 896   fields[argp++] = TypeInt::INT;        // src len
 897   if (Matcher::pass_original_key_for_aes()) {
 898     fields[argp++] = TypePtr::NOTNULL;    // original k array
 899   }
 900   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 901   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 902 
 903   // returning cipher len (int)
 904   fields = TypeTuple::fields(1);
 905   fields[TypeFunc::Parms+0] = TypeInt::INT;
 906   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
 907   return TypeFunc::make(domain, range);
 908 }
 909 
 910 // for electronicCodeBook calls of aescrypt encrypt/decrypt, three pointers and a length, returning int
 911 const TypeFunc* OptoRuntime::electronicCodeBook_aescrypt_Type() {
 912   // create input type (domain)
 913   int num_args = 4;
 914   if (Matcher::pass_original_key_for_aes()) {
 915      num_args = 5;
 916   }
 917   int argcnt = num_args;
 918   const Type** fields = TypeTuple::fields(argcnt);
 919   int argp = TypeFunc::Parms;
 920   fields[argp++] = TypePtr::NOTNULL;    // src
 921   fields[argp++] = TypePtr::NOTNULL;    // dest
 922   fields[argp++] = TypePtr::NOTNULL;    // k array
 923   fields[argp++] = TypeInt::INT;        // src len
 924   if (Matcher::pass_original_key_for_aes()) {
 925      fields[argp++] = TypePtr::NOTNULL;    // original k array
 926   }
 927   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);
 928   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);
 929 
 930   // returning cipher len (int)
 931   fields = TypeTuple::fields(1);
 932   fields[TypeFunc::Parms + 0] = TypeInt::INT;
 933   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);
 934   return TypeFunc::make(domain, range);
 935 }
 936 
 937 //for counterMode calls of aescrypt encrypt/decrypt, four pointers and a length, returning int
 938 const TypeFunc* OptoRuntime::counterMode_aescrypt_Type() {
 939   // create input type (domain)
 940   int num_args = 7;
 941   if (Matcher::pass_original_key_for_aes()) {
 942     num_args = 8;
 943   }
 944   int argcnt = num_args;
 945   const Type** fields = TypeTuple::fields(argcnt);
 946   int argp = TypeFunc::Parms;
 947   fields[argp++] = TypePtr::NOTNULL; // src
 948   fields[argp++] = TypePtr::NOTNULL; // dest
 949   fields[argp++] = TypePtr::NOTNULL; // k array
 950   fields[argp++] = TypePtr::NOTNULL; // counter array
 951   fields[argp++] = TypeInt::INT; // src len
 952   fields[argp++] = TypePtr::NOTNULL; // saved_encCounter
 953   fields[argp++] = TypePtr::NOTNULL; // saved used addr
 954   if (Matcher::pass_original_key_for_aes()) {
 955     fields[argp++] = TypePtr::NOTNULL; // original k array
 956   }
 957   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);
 958   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);
 959   // returning cipher len (int)
 960   fields = TypeTuple::fields(1);
 961   fields[TypeFunc::Parms + 0] = TypeInt::INT;
 962   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);
 963   return TypeFunc::make(domain, range);
 964 }
 965 
 966 /*
 967  * void implCompress(byte[] buf, int ofs)
 968  */
 969 const TypeFunc* OptoRuntime::sha_implCompress_Type() {
 970   // create input type (domain)
 971   int num_args = 2;
 972   int argcnt = num_args;
 973   const Type** fields = TypeTuple::fields(argcnt);
 974   int argp = TypeFunc::Parms;
 975   fields[argp++] = TypePtr::NOTNULL; // buf
 976   fields[argp++] = TypePtr::NOTNULL; // state
 977   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 978   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 979 
 980   // no result type needed
 981   fields = TypeTuple::fields(1);
 982   fields[TypeFunc::Parms+0] = NULL; // void
 983   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
 984   return TypeFunc::make(domain, range);
 985 }
 986 
 987 /*
 988  * int implCompressMultiBlock(byte[] b, int ofs, int limit)
 989  */
 990 const TypeFunc* OptoRuntime::digestBase_implCompressMB_Type() {
 991   // create input type (domain)
 992   int num_args = 4;
 993   int argcnt = num_args;
 994   const Type** fields = TypeTuple::fields(argcnt);
 995   int argp = TypeFunc::Parms;
 996   fields[argp++] = TypePtr::NOTNULL; // buf
 997   fields[argp++] = TypePtr::NOTNULL; // state
 998   fields[argp++] = TypeInt::INT;     // ofs
 999   fields[argp++] = TypeInt::INT;     // limit
1000   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1001   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1002 
1003   // returning ofs (int)
1004   fields = TypeTuple::fields(1);
1005   fields[TypeFunc::Parms+0] = TypeInt::INT; // ofs
1006   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
1007   return TypeFunc::make(domain, range);
1008 }
1009 
1010 const TypeFunc* OptoRuntime::multiplyToLen_Type() {
1011   // create input type (domain)
1012   int num_args      = 6;
1013   int argcnt = num_args;
1014   const Type** fields = TypeTuple::fields(argcnt);
1015   int argp = TypeFunc::Parms;
1016   fields[argp++] = TypePtr::NOTNULL;    // x
1017   fields[argp++] = TypeInt::INT;        // xlen
1018   fields[argp++] = TypePtr::NOTNULL;    // y
1019   fields[argp++] = TypeInt::INT;        // ylen
1020   fields[argp++] = TypePtr::NOTNULL;    // z
1021   fields[argp++] = TypeInt::INT;        // zlen
1022   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1023   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1024 
1025   // no result type needed
1026   fields = TypeTuple::fields(1);
1027   fields[TypeFunc::Parms+0] = NULL;
1028   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1029   return TypeFunc::make(domain, range);
1030 }
1031 
1032 const TypeFunc* OptoRuntime::squareToLen_Type() {
1033   // create input type (domain)
1034   int num_args      = 4;
1035   int argcnt = num_args;
1036   const Type** fields = TypeTuple::fields(argcnt);
1037   int argp = TypeFunc::Parms;
1038   fields[argp++] = TypePtr::NOTNULL;    // x
1039   fields[argp++] = TypeInt::INT;        // len
1040   fields[argp++] = TypePtr::NOTNULL;    // z
1041   fields[argp++] = TypeInt::INT;        // zlen
1042   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1043   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1044 
1045   // no result type needed
1046   fields = TypeTuple::fields(1);
1047   fields[TypeFunc::Parms+0] = NULL;
1048   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1049   return TypeFunc::make(domain, range);
1050 }
1051 
1052 // for mulAdd calls, 2 pointers and 3 ints, returning int
1053 const TypeFunc* OptoRuntime::mulAdd_Type() {
1054   // create input type (domain)
1055   int num_args      = 5;
1056   int argcnt = num_args;
1057   const Type** fields = TypeTuple::fields(argcnt);
1058   int argp = TypeFunc::Parms;
1059   fields[argp++] = TypePtr::NOTNULL;    // out
1060   fields[argp++] = TypePtr::NOTNULL;    // in
1061   fields[argp++] = TypeInt::INT;        // offset
1062   fields[argp++] = TypeInt::INT;        // len
1063   fields[argp++] = TypeInt::INT;        // k
1064   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1065   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1066 
1067   // returning carry (int)
1068   fields = TypeTuple::fields(1);
1069   fields[TypeFunc::Parms+0] = TypeInt::INT;
1070   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
1071   return TypeFunc::make(domain, range);
1072 }
1073 
1074 const TypeFunc* OptoRuntime::montgomeryMultiply_Type() {
1075   // create input type (domain)
1076   int num_args      = 7;
1077   int argcnt = num_args;
1078   const Type** fields = TypeTuple::fields(argcnt);
1079   int argp = TypeFunc::Parms;
1080   fields[argp++] = TypePtr::NOTNULL;    // a
1081   fields[argp++] = TypePtr::NOTNULL;    // b
1082   fields[argp++] = TypePtr::NOTNULL;    // n
1083   fields[argp++] = TypeInt::INT;        // len
1084   fields[argp++] = TypeLong::LONG;      // inv
1085   fields[argp++] = Type::HALF;
1086   fields[argp++] = TypePtr::NOTNULL;    // result
1087   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1088   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1089 
1090   // result type needed
1091   fields = TypeTuple::fields(1);
1092   fields[TypeFunc::Parms+0] = TypePtr::NOTNULL;
1093 
1094   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1095   return TypeFunc::make(domain, range);
1096 }
1097 
1098 const TypeFunc* OptoRuntime::montgomerySquare_Type() {
1099   // create input type (domain)
1100   int num_args      = 6;
1101   int argcnt = num_args;
1102   const Type** fields = TypeTuple::fields(argcnt);
1103   int argp = TypeFunc::Parms;
1104   fields[argp++] = TypePtr::NOTNULL;    // a
1105   fields[argp++] = TypePtr::NOTNULL;    // n
1106   fields[argp++] = TypeInt::INT;        // len
1107   fields[argp++] = TypeLong::LONG;      // inv
1108   fields[argp++] = Type::HALF;
1109   fields[argp++] = TypePtr::NOTNULL;    // result
1110   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1111   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1112 
1113   // result type needed
1114   fields = TypeTuple::fields(1);
1115   fields[TypeFunc::Parms+0] = TypePtr::NOTNULL;
1116 
1117   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1118   return TypeFunc::make(domain, range);
1119 }
1120 
1121 const TypeFunc * OptoRuntime::bigIntegerShift_Type() {
1122   int argcnt = 5;
1123   const Type** fields = TypeTuple::fields(argcnt);
1124   int argp = TypeFunc::Parms;
1125   fields[argp++] = TypePtr::NOTNULL;    // newArr
1126   fields[argp++] = TypePtr::NOTNULL;    // oldArr
1127   fields[argp++] = TypeInt::INT;        // newIdx
1128   fields[argp++] = TypeInt::INT;        // shiftCount
1129   fields[argp++] = TypeInt::INT;        // numIter
1130   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);
1131   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);
1132 
1133   // no result type needed
1134   fields = TypeTuple::fields(1);
1135   fields[TypeFunc::Parms + 0] = NULL;
1136   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1137   return TypeFunc::make(domain, range);
1138 }
1139 
1140 const TypeFunc* OptoRuntime::vectorizedMismatch_Type() {
1141   // create input type (domain)
1142   int num_args = 4;
1143   int argcnt = num_args;
1144   const Type** fields = TypeTuple::fields(argcnt);
1145   int argp = TypeFunc::Parms;
1146   fields[argp++] = TypePtr::NOTNULL;    // obja
1147   fields[argp++] = TypePtr::NOTNULL;    // objb
1148   fields[argp++] = TypeInt::INT;        // length, number of elements
1149   fields[argp++] = TypeInt::INT;        // log2scale, element size
1150   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);
1151   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);
1152 
1153   //return mismatch index (int)
1154   fields = TypeTuple::fields(1);
1155   fields[TypeFunc::Parms + 0] = TypeInt::INT;
1156   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);
1157   return TypeFunc::make(domain, range);
1158 }
1159 
1160 // GHASH block processing
1161 const TypeFunc* OptoRuntime::ghash_processBlocks_Type() {
1162     int argcnt = 4;
1163 
1164     const Type** fields = TypeTuple::fields(argcnt);
1165     int argp = TypeFunc::Parms;
1166     fields[argp++] = TypePtr::NOTNULL;    // state
1167     fields[argp++] = TypePtr::NOTNULL;    // subkeyH
1168     fields[argp++] = TypePtr::NOTNULL;    // data
1169     fields[argp++] = TypeInt::INT;        // blocks
1170     assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1171     const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1172 
1173     // result type needed
1174     fields = TypeTuple::fields(1);
1175     fields[TypeFunc::Parms+0] = NULL; // void
1176     const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1177     return TypeFunc::make(domain, range);
1178 }
1179 // Base64 encode function
1180 const TypeFunc* OptoRuntime::base64_encodeBlock_Type() {
1181   int argcnt = 6;
1182 
1183   const Type** fields = TypeTuple::fields(argcnt);
1184   int argp = TypeFunc::Parms;
1185   fields[argp++] = TypePtr::NOTNULL;    // src array
1186   fields[argp++] = TypeInt::INT;        // offset
1187   fields[argp++] = TypeInt::INT;        // length
1188   fields[argp++] = TypePtr::NOTNULL;    // dest array
1189   fields[argp++] = TypeInt::INT;       // dp
1190   fields[argp++] = TypeInt::BOOL;       // isURL
1191   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);
1192   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1193 
1194   // result type needed
1195   fields = TypeTuple::fields(1);
1196   fields[TypeFunc::Parms + 0] = NULL; // void
1197   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1198   return TypeFunc::make(domain, range);
1199 }
1200 
1201 //------------- Interpreter state access for on stack replacement
1202 const TypeFunc* OptoRuntime::osr_end_Type() {
1203   // create input type (domain)
1204   const Type **fields = TypeTuple::fields(1);
1205   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM; // OSR temp buf
1206   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
1207 
1208   // create result type
1209   fields = TypeTuple::fields(1);
1210   // fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // locked oop
1211   fields[TypeFunc::Parms+0] = NULL; // void
1212   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);
1213   return TypeFunc::make(domain, range);
1214 }
1215 
1216 //-------------- methodData update helpers
1217 
1218 const TypeFunc* OptoRuntime::profile_receiver_type_Type() {
1219   // create input type (domain)
1220   const Type **fields = TypeTuple::fields(2);
1221   fields[TypeFunc::Parms+0] = TypeAryPtr::NOTNULL;    // methodData pointer
1222   fields[TypeFunc::Parms+1] = TypeInstPtr::BOTTOM;    // receiver oop
1223   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
1224 
1225   // create result type
1226   fields = TypeTuple::fields(1);
1227   fields[TypeFunc::Parms+0] = NULL; // void
1228   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);
1229   return TypeFunc::make(domain, range);
1230 }
1231 
1232 JRT_LEAF(void, OptoRuntime::profile_receiver_type_C(DataLayout* data, oopDesc* receiver))
1233   if (receiver == NULL) return;
1234   Klass* receiver_klass = receiver-&gt;klass();
1235 
1236   intptr_t* mdp = ((intptr_t*)(data)) + DataLayout::header_size_in_cells();
1237   int empty_row = -1;           // free row, if any is encountered
1238 
1239   // ReceiverTypeData* vc = new ReceiverTypeData(mdp);
1240   for (uint row = 0; row &lt; ReceiverTypeData::row_limit(); row++) {
1241     // if (vc-&gt;receiver(row) == receiver_klass)
1242     int receiver_off = ReceiverTypeData::receiver_cell_index(row);
1243     intptr_t row_recv = *(mdp + receiver_off);
1244     if (row_recv == (intptr_t) receiver_klass) {
1245       // vc-&gt;set_receiver_count(row, vc-&gt;receiver_count(row) + DataLayout::counter_increment);
1246       int count_off = ReceiverTypeData::receiver_count_cell_index(row);
1247       *(mdp + count_off) += DataLayout::counter_increment;
1248       return;
1249     } else if (row_recv == 0) {
1250       // else if (vc-&gt;receiver(row) == NULL)
1251       empty_row = (int) row;
1252     }
1253   }
1254 
1255   if (empty_row != -1) {
1256     int receiver_off = ReceiverTypeData::receiver_cell_index(empty_row);
1257     // vc-&gt;set_receiver(empty_row, receiver_klass);
1258     *(mdp + receiver_off) = (intptr_t) receiver_klass;
1259     // vc-&gt;set_receiver_count(empty_row, DataLayout::counter_increment);
1260     int count_off = ReceiverTypeData::receiver_count_cell_index(empty_row);
1261     *(mdp + count_off) = DataLayout::counter_increment;
1262   } else {
1263     // Receiver did not match any saved receiver and there is no empty row for it.
1264     // Increment total counter to indicate polymorphic case.
1265     intptr_t* count_p = (intptr_t*)(((uint8_t*)(data)) + in_bytes(CounterData::count_offset()));
1266     *count_p += DataLayout::counter_increment;
1267   }
1268 JRT_END
1269 
1270 //-------------------------------------------------------------------------------------
1271 // register policy
1272 
1273 bool OptoRuntime::is_callee_saved_register(MachRegisterNumbers reg) {
1274   assert(reg &gt;= 0 &amp;&amp; reg &lt; _last_Mach_Reg, &quot;must be a machine register&quot;);
1275   switch (register_save_policy[reg]) {
1276     case &#39;C&#39;: return false; //SOC
1277     case &#39;E&#39;: return true ; //SOE
1278     case &#39;N&#39;: return false; //NS
1279     case &#39;A&#39;: return false; //AS
1280   }
1281   ShouldNotReachHere();
1282   return false;
1283 }
1284 
1285 //-----------------------------------------------------------------------
1286 // Exceptions
1287 //
1288 
1289 static void trace_exception(outputStream* st, oop exception_oop, address exception_pc, const char* msg);
1290 
1291 // The method is an entry that is always called by a C++ method not
1292 // directly from compiled code. Compiled code will call the C++ method following.
1293 // We can&#39;t allow async exception to be installed during  exception processing.
1294 JRT_ENTRY_NO_ASYNC(address, OptoRuntime::handle_exception_C_helper(JavaThread* thread, nmethod* &amp;nm))
1295 
1296   // Do not confuse exception_oop with pending_exception. The exception_oop
1297   // is only used to pass arguments into the method. Not for general
1298   // exception handling.  DO NOT CHANGE IT to use pending_exception, since
1299   // the runtime stubs checks this on exit.
1300   assert(thread-&gt;exception_oop() != NULL, &quot;exception oop is found&quot;);
1301   address handler_address = NULL;
1302 
1303   Handle exception(thread, thread-&gt;exception_oop());
1304   address pc = thread-&gt;exception_pc();
1305 
1306   // Clear out the exception oop and pc since looking up an
1307   // exception handler can cause class loading, which might throw an
1308   // exception and those fields are expected to be clear during
1309   // normal bytecode execution.
1310   thread-&gt;clear_exception_oop_and_pc();
1311 
1312   LogTarget(Info, exceptions) lt;
1313   if (lt.is_enabled()) {
1314     ResourceMark rm;
1315     LogStream ls(lt);
1316     trace_exception(&amp;ls, exception(), pc, &quot;&quot;);
1317   }
1318 
1319   // for AbortVMOnException flag
1320   Exceptions::debug_check_abort(exception);
1321 
1322 #ifdef ASSERT
1323   if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
1324     // should throw an exception here
1325     ShouldNotReachHere();
1326   }
1327 #endif
1328 
1329   // new exception handling: this method is entered only from adapters
1330   // exceptions from compiled java methods are handled in compiled code
1331   // using rethrow node
1332 
1333   nm = CodeCache::find_nmethod(pc);
1334   assert(nm != NULL, &quot;No NMethod found&quot;);
1335   if (nm-&gt;is_native_method()) {
1336     fatal(&quot;Native method should not have path to exception handling&quot;);
1337   } else {
1338     // we are switching to old paradigm: search for exception handler in caller_frame
1339     // instead in exception handler of caller_frame.sender()
1340 
1341     if (JvmtiExport::can_post_on_exceptions()) {
1342       // &quot;Full-speed catching&quot; is not necessary here,
1343       // since we&#39;re notifying the VM on every catch.
1344       // Force deoptimization and the rest of the lookup
1345       // will be fine.
1346       deoptimize_caller_frame(thread);
1347     }
1348 
1349     // Check the stack guard pages.  If enabled, look for handler in this frame;
1350     // otherwise, forcibly unwind the frame.
1351     //
1352     // 4826555: use default current sp for reguard_stack instead of &amp;nm: it&#39;s more accurate.
1353     bool force_unwind = !thread-&gt;reguard_stack();
1354     bool deopting = false;
1355     if (nm-&gt;is_deopt_pc(pc)) {
1356       deopting = true;
1357       RegisterMap map(thread, false);
1358       frame deoptee = thread-&gt;last_frame().sender(&amp;map);
1359       assert(deoptee.is_deoptimized_frame(), &quot;must be deopted&quot;);
1360       // Adjust the pc back to the original throwing pc
1361       pc = deoptee.pc();
1362     }
1363 
1364     // If we are forcing an unwind because of stack overflow then deopt is
1365     // irrelevant since we are throwing the frame away anyway.
1366 
1367     if (deopting &amp;&amp; !force_unwind) {
1368       handler_address = SharedRuntime::deopt_blob()-&gt;unpack_with_exception();
1369     } else {
1370 
1371       handler_address =
1372         force_unwind ? NULL : nm-&gt;handler_for_exception_and_pc(exception, pc);
1373 
1374       if (handler_address == NULL) {
1375         bool recursive_exception = false;
1376         handler_address = SharedRuntime::compute_compiled_exc_handler(nm, pc, exception, force_unwind, true, recursive_exception);
1377         assert (handler_address != NULL, &quot;must have compiled handler&quot;);
1378         // Update the exception cache only when the unwind was not forced
1379         // and there didn&#39;t happen another exception during the computation of the
1380         // compiled exception handler. Checking for exception oop equality is not
1381         // sufficient because some exceptions are pre-allocated and reused.
1382         if (!force_unwind &amp;&amp; !recursive_exception) {
1383           nm-&gt;add_handler_for_exception_and_pc(exception,pc,handler_address);
1384         }
1385       } else {
1386 #ifdef ASSERT
1387         bool recursive_exception = false;
1388         address computed_address = SharedRuntime::compute_compiled_exc_handler(nm, pc, exception, force_unwind, true, recursive_exception);
1389         vmassert(recursive_exception || (handler_address == computed_address), &quot;Handler address inconsistency: &quot; PTR_FORMAT &quot; != &quot; PTR_FORMAT,
1390                  p2i(handler_address), p2i(computed_address));
1391 #endif
1392       }
1393     }
1394 
1395     thread-&gt;set_exception_pc(pc);
1396     thread-&gt;set_exception_handler_pc(handler_address);
1397 
1398     // Check if the exception PC is a MethodHandle call site.
1399     thread-&gt;set_is_method_handle_return(nm-&gt;is_method_handle_return(pc));
1400   }
1401 
1402   // Restore correct return pc.  Was saved above.
1403   thread-&gt;set_exception_oop(exception());
1404   return handler_address;
1405 
1406 JRT_END
1407 
1408 // We are entering here from exception_blob
1409 // If there is a compiled exception handler in this method, we will continue there;
1410 // otherwise we will unwind the stack and continue at the caller of top frame method
1411 // Note we enter without the usual JRT wrapper. We will call a helper routine that
1412 // will do the normal VM entry. We do it this way so that we can see if the nmethod
1413 // we looked up the handler for has been deoptimized in the meantime. If it has been
1414 // we must not use the handler and instead return the deopt blob.
1415 address OptoRuntime::handle_exception_C(JavaThread* thread) {
1416 //
1417 // We are in Java not VM and in debug mode we have a NoHandleMark
1418 //
1419 #ifndef PRODUCT
1420   SharedRuntime::_find_handler_ctr++;          // find exception handler
1421 #endif
1422   debug_only(NoHandleMark __hm;)
1423   nmethod* nm = NULL;
1424   address handler_address = NULL;
1425   {
1426     // Enter the VM
1427 
1428     ResetNoHandleMark rnhm;
1429     handler_address = handle_exception_C_helper(thread, nm);
1430   }
1431 
1432   // Back in java: Use no oops, DON&#39;T safepoint
1433 
1434   // Now check to see if the handler we are returning is in a now
1435   // deoptimized frame
1436 
1437   if (nm != NULL) {
1438     RegisterMap map(thread, false);
1439     frame caller = thread-&gt;last_frame().sender(&amp;map);
1440 #ifdef ASSERT
1441     assert(caller.is_compiled_frame(), &quot;must be&quot;);
1442 #endif // ASSERT
1443     if (caller.is_deoptimized_frame()) {
1444       handler_address = SharedRuntime::deopt_blob()-&gt;unpack_with_exception();
1445     }
1446   }
1447   return handler_address;
1448 }
1449 
1450 //------------------------------rethrow----------------------------------------
1451 // We get here after compiled code has executed a &#39;RethrowNode&#39;.  The callee
1452 // is either throwing or rethrowing an exception.  The callee-save registers
1453 // have been restored, synchronized objects have been unlocked and the callee
1454 // stack frame has been removed.  The return address was passed in.
1455 // Exception oop is passed as the 1st argument.  This routine is then called
1456 // from the stub.  On exit, we know where to jump in the caller&#39;s code.
1457 // After this C code exits, the stub will pop his frame and end in a jump
1458 // (instead of a return).  We enter the caller&#39;s default handler.
1459 //
1460 // This must be JRT_LEAF:
1461 //     - caller will not change its state as we cannot block on exit,
1462 //       therefore raw_exception_handler_for_return_address is all it takes
1463 //       to handle deoptimized blobs
1464 //
1465 // However, there needs to be a safepoint check in the middle!  So compiled
1466 // safepoints are completely watertight.
1467 //
1468 // Thus, it cannot be a leaf since it contains the NoSafepointVerifier.
1469 //
1470 // *THIS IS NOT RECOMMENDED PROGRAMMING STYLE*
1471 //
1472 address OptoRuntime::rethrow_C(oopDesc* exception, JavaThread* thread, address ret_pc) {
1473 #ifndef PRODUCT
1474   SharedRuntime::_rethrow_ctr++;               // count rethrows
1475 #endif
1476   assert (exception != NULL, &quot;should have thrown a NULLPointerException&quot;);
1477 #ifdef ASSERT
1478   if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
1479     // should throw an exception here
1480     ShouldNotReachHere();
1481   }
1482 #endif
1483 
1484   thread-&gt;set_vm_result(exception);
1485   // Frame not compiled (handles deoptimization blob)
1486   return SharedRuntime::raw_exception_handler_for_return_address(thread, ret_pc);
1487 }
1488 
1489 
1490 const TypeFunc *OptoRuntime::rethrow_Type() {
1491   // create input type (domain)
1492   const Type **fields = TypeTuple::fields(1);
1493   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // Exception oop
1494   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1,fields);
1495 
1496   // create result type (range)
1497   fields = TypeTuple::fields(1);
1498   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // Exception oop
1499   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
1500 
1501   return TypeFunc::make(domain, range);
1502 }
1503 
1504 
1505 void OptoRuntime::deoptimize_caller_frame(JavaThread *thread, bool doit) {
1506   // Deoptimize the caller before continuing, as the compiled
1507   // exception handler table may not be valid.
1508   if (!StressCompiledExceptionHandlers &amp;&amp; doit) {
1509     deoptimize_caller_frame(thread);
1510   }
1511 }
1512 
1513 void OptoRuntime::deoptimize_caller_frame(JavaThread *thread) {
1514   // Called from within the owner thread, so no need for safepoint
1515   RegisterMap reg_map(thread);
1516   frame stub_frame = thread-&gt;last_frame();
1517   assert(stub_frame.is_runtime_frame() || exception_blob()-&gt;contains(stub_frame.pc()), &quot;sanity check&quot;);
1518   frame caller_frame = stub_frame.sender(&amp;reg_map);
1519 
1520   // Deoptimize the caller frame.
1521   Deoptimization::deoptimize_frame(thread, caller_frame.id());
1522 }
1523 
1524 
1525 bool OptoRuntime::is_deoptimized_caller_frame(JavaThread *thread) {
1526   // Called from within the owner thread, so no need for safepoint
1527   RegisterMap reg_map(thread);
1528   frame stub_frame = thread-&gt;last_frame();
1529   assert(stub_frame.is_runtime_frame() || exception_blob()-&gt;contains(stub_frame.pc()), &quot;sanity check&quot;);
1530   frame caller_frame = stub_frame.sender(&amp;reg_map);
1531   return caller_frame.is_deoptimized_frame();
1532 }
1533 
1534 
1535 const TypeFunc *OptoRuntime::register_finalizer_Type() {
1536   // create input type (domain)
1537   const Type **fields = TypeTuple::fields(1);
1538   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;  // oop;          Receiver
1539   // // The JavaThread* is passed to each routine as the last argument
1540   // fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL;  // JavaThread *; Executing thread
1541   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1,fields);
1542 
1543   // create result type (range)
1544   fields = TypeTuple::fields(0);
1545 
1546   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0,fields);
1547 
1548   return TypeFunc::make(domain, range);
1549 }
1550 
1551 
1552 //-----------------------------------------------------------------------------
1553 // Dtrace support.  entry and exit probes have the same signature
1554 const TypeFunc *OptoRuntime::dtrace_method_entry_exit_Type() {
1555   // create input type (domain)
1556   const Type **fields = TypeTuple::fields(2);
1557   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM; // Thread-local storage
1558   fields[TypeFunc::Parms+1] = TypeMetadataPtr::BOTTOM;  // Method*;    Method we are entering
1559   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2,fields);
1560 
1561   // create result type (range)
1562   fields = TypeTuple::fields(0);
1563 
1564   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0,fields);
1565 
1566   return TypeFunc::make(domain, range);
1567 }
1568 
1569 const TypeFunc *OptoRuntime::dtrace_object_alloc_Type() {
1570   // create input type (domain)
1571   const Type **fields = TypeTuple::fields(2);
1572   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM; // Thread-local storage
1573   fields[TypeFunc::Parms+1] = TypeInstPtr::NOTNULL;  // oop;    newly allocated object
1574 
1575   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2,fields);
1576 
1577   // create result type (range)
1578   fields = TypeTuple::fields(0);
1579 
1580   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0,fields);
1581 
1582   return TypeFunc::make(domain, range);
1583 }
1584 
1585 
1586 JRT_ENTRY_NO_ASYNC(void, OptoRuntime::register_finalizer(oopDesc* obj, JavaThread* thread))
1587   assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
1588   assert(obj-&gt;klass()-&gt;has_finalizer(), &quot;shouldn&#39;t be here otherwise&quot;);
1589   InstanceKlass::register_finalizer(instanceOop(obj), CHECK);
1590 JRT_END
1591 
1592 //-----------------------------------------------------------------------------
1593 
1594 NamedCounter * volatile OptoRuntime::_named_counters = NULL;
1595 
1596 //
1597 // dump the collected NamedCounters.
1598 //
1599 void OptoRuntime::print_named_counters() {
1600   int total_lock_count = 0;
1601   int eliminated_lock_count = 0;
1602 
1603   NamedCounter* c = _named_counters;
1604   while (c) {
1605     if (c-&gt;tag() == NamedCounter::LockCounter || c-&gt;tag() == NamedCounter::EliminatedLockCounter) {
1606       int count = c-&gt;count();
1607       if (count &gt; 0) {
1608         bool eliminated = c-&gt;tag() == NamedCounter::EliminatedLockCounter;
1609         if (Verbose) {
1610           tty-&gt;print_cr(&quot;%d %s%s&quot;, count, c-&gt;name(), eliminated ? &quot; (eliminated)&quot; : &quot;&quot;);
1611         }
1612         total_lock_count += count;
1613         if (eliminated) {
1614           eliminated_lock_count += count;
1615         }
1616       }
1617     } else if (c-&gt;tag() == NamedCounter::BiasedLockingCounter) {
1618       BiasedLockingCounters* blc = ((BiasedLockingNamedCounter*)c)-&gt;counters();
1619       if (blc-&gt;nonzero()) {
1620         tty-&gt;print_cr(&quot;%s&quot;, c-&gt;name());
1621         blc-&gt;print_on(tty);
1622       }
1623 #if INCLUDE_RTM_OPT
1624     } else if (c-&gt;tag() == NamedCounter::RTMLockingCounter) {
1625       RTMLockingCounters* rlc = ((RTMLockingNamedCounter*)c)-&gt;counters();
1626       if (rlc-&gt;nonzero()) {
1627         tty-&gt;print_cr(&quot;%s&quot;, c-&gt;name());
1628         rlc-&gt;print_on(tty);
1629       }
1630 #endif
1631     }
1632     c = c-&gt;next();
1633   }
1634   if (total_lock_count &gt; 0) {
1635     tty-&gt;print_cr(&quot;dynamic locks: %d&quot;, total_lock_count);
1636     if (eliminated_lock_count) {
1637       tty-&gt;print_cr(&quot;eliminated locks: %d (%d%%)&quot;, eliminated_lock_count,
1638                     (int)(eliminated_lock_count * 100.0 / total_lock_count));
1639     }
1640   }
1641 }
1642 
1643 //
1644 //  Allocate a new NamedCounter.  The JVMState is used to generate the
1645 //  name which consists of method@line for the inlining tree.
1646 //
1647 
1648 NamedCounter* OptoRuntime::new_named_counter(JVMState* youngest_jvms, NamedCounter::CounterTag tag) {
1649   int max_depth = youngest_jvms-&gt;depth();
1650 
1651   // Visit scopes from youngest to oldest.
1652   bool first = true;
1653   stringStream st;
1654   for (int depth = max_depth; depth &gt;= 1; depth--) {
1655     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
1656     ciMethod* m = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
1657     if (!first) {
1658       st.print(&quot; &quot;);
1659     } else {
1660       first = false;
1661     }
1662     int bci = jvms-&gt;bci();
1663     if (bci &lt; 0) bci = 0;
1664     if (m != NULL) {
1665       st.print(&quot;%s.%s&quot;, m-&gt;holder()-&gt;name()-&gt;as_utf8(), m-&gt;name()-&gt;as_utf8());
1666     } else {
1667       st.print(&quot;no method&quot;);
1668     }
1669     st.print(&quot;@%d&quot;, bci);
1670     // To print linenumbers instead of bci use: m-&gt;line_number_from_bci(bci)
1671   }
1672   NamedCounter* c;
1673   if (tag == NamedCounter::BiasedLockingCounter) {
1674     c = new BiasedLockingNamedCounter(st.as_string());
1675   } else if (tag == NamedCounter::RTMLockingCounter) {
1676     c = new RTMLockingNamedCounter(st.as_string());
1677   } else {
1678     c = new NamedCounter(st.as_string(), tag);
1679   }
1680 
1681   // atomically add the new counter to the head of the list.  We only
1682   // add counters so this is safe.
1683   NamedCounter* head;
1684   do {
1685     c-&gt;set_next(NULL);
1686     head = _named_counters;
1687     c-&gt;set_next(head);
1688   } while (Atomic::cmpxchg(&amp;_named_counters, head, c) != head);
1689   return c;
1690 }
1691 
1692 int trace_exception_counter = 0;
1693 static void trace_exception(outputStream* st, oop exception_oop, address exception_pc, const char* msg) {
1694   trace_exception_counter++;
1695   stringStream tempst;
1696 
1697   tempst.print(&quot;%d [Exception (%s): &quot;, trace_exception_counter, msg);
1698   exception_oop-&gt;print_value_on(&amp;tempst);
1699   tempst.print(&quot; in &quot;);
1700   CodeBlob* blob = CodeCache::find_blob(exception_pc);
1701   if (blob-&gt;is_compiled()) {
1702     CompiledMethod* cm = blob-&gt;as_compiled_method_or_null();
1703     cm-&gt;method()-&gt;print_value_on(&amp;tempst);
1704   } else if (blob-&gt;is_runtime_stub()) {
1705     tempst.print(&quot;&lt;runtime-stub&gt;&quot;);
1706   } else {
1707     tempst.print(&quot;&lt;unknown&gt;&quot;);
1708   }
1709   tempst.print(&quot; at &quot; INTPTR_FORMAT,  p2i(exception_pc));
1710   tempst.print(&quot;]&quot;);
1711 
1712   st-&gt;print_raw_cr(tempst.as_string());
1713 }
1714 
1715 const TypeFunc *OptoRuntime::store_value_type_fields_Type() {
1716   // create input type (domain)
1717   uint total = SharedRuntime::java_return_convention_max_int + SharedRuntime::java_return_convention_max_float*2;
1718   const Type **fields = TypeTuple::fields(total);
1719   // We don&#39;t know the number of returned values and their
1720   // types. Assume all registers available to the return convention
1721   // are used.
1722   fields[TypeFunc::Parms] = TypePtr::BOTTOM;
1723   uint i = 1;
1724   for (; i &lt; SharedRuntime::java_return_convention_max_int; i++) {
1725     fields[TypeFunc::Parms+i] = TypeInt::INT;
1726   }
1727   for (; i &lt; total; i+=2) {
1728     fields[TypeFunc::Parms+i] = Type::DOUBLE;
1729     fields[TypeFunc::Parms+i+1] = Type::HALF;
1730   }
1731   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + total, fields);
1732 
1733   // create result type (range)
1734   fields = TypeTuple::fields(1);
1735   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;
1736 
1737   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1,fields);
1738 
1739   return TypeFunc::make(domain, range);
1740 }
1741 
1742 const TypeFunc *OptoRuntime::pack_value_type_Type() {
1743   // create input type (domain)
1744   uint total = 1 + SharedRuntime::java_return_convention_max_int + SharedRuntime::java_return_convention_max_float*2;
1745   const Type **fields = TypeTuple::fields(total);
1746   // We don&#39;t know the number of returned values and their
1747   // types. Assume all registers available to the return convention
1748   // are used.
1749   fields[TypeFunc::Parms] = TypeRawPtr::BOTTOM;
1750   fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM;
1751   uint i = 2;
1752   for (; i &lt; SharedRuntime::java_return_convention_max_int+1; i++) {
1753     fields[TypeFunc::Parms+i] = TypeInt::INT;
1754   }
1755   for (; i &lt; total; i+=2) {
1756     fields[TypeFunc::Parms+i] = Type::DOUBLE;
1757     fields[TypeFunc::Parms+i+1] = Type::HALF;
1758   }
1759   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + total, fields);
1760 
1761   // create result type (range)
1762   fields = TypeTuple::fields(1);
1763   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;
1764 
1765   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1,fields);
1766 
1767   return TypeFunc::make(domain, range);
1768 }
1769 
1770 JRT_LEAF(void, OptoRuntime::load_unknown_value(valueArrayOopDesc* array, int index, instanceOopDesc* buffer))
1771 {
1772   array-&gt;value_copy_from_index(index, buffer);
1773 }
1774 JRT_END
1775 
1776 const TypeFunc *OptoRuntime::load_unknown_value_Type() {
1777   // create input type (domain)
1778   const Type **fields = TypeTuple::fields(3);
1779   // We don&#39;t know the number of returned values and their
1780   // types. Assume all registers available to the return convention
1781   // are used.
1782   fields[TypeFunc::Parms] = TypeOopPtr::NOTNULL;
1783   fields[TypeFunc::Parms+1] = TypeInt::POS;
1784   fields[TypeFunc::Parms+2] = TypeInstPtr::NOTNULL;
1785 
1786   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+3, fields);
1787 
1788   // create result type (range)
1789   fields = TypeTuple::fields(0);
1790   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
1791 
1792   return TypeFunc::make(domain, range);
1793 }
1794 
1795 JRT_LEAF(void, OptoRuntime::store_unknown_value(instanceOopDesc* buffer, valueArrayOopDesc* array, int index))
1796 {
1797   assert(buffer != NULL, &quot;can&#39;t store null into flat array&quot;);
1798   array-&gt;value_copy_to_index(buffer, index);
1799 }
1800 JRT_END
1801 
1802 const TypeFunc *OptoRuntime::store_unknown_value_Type() {
1803   // create input type (domain)
1804   const Type **fields = TypeTuple::fields(3);
1805   // We don&#39;t know the number of returned values and their
1806   // types. Assume all registers available to the return convention
1807   // are used.
1808   fields[TypeFunc::Parms] = TypeInstPtr::NOTNULL;
1809   fields[TypeFunc::Parms+1] = TypeOopPtr::NOTNULL;
1810   fields[TypeFunc::Parms+2] = TypeInt::POS;
1811 
1812   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+3, fields);
1813 
1814   // create result type (range)
1815   fields = TypeTuple::fields(0);
1816   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
1817 
1818   return TypeFunc::make(domain, range);
1819 }
    </pre>
  </body>
</html>
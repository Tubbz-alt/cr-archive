<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jni.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../opto/type.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniCheck.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jni.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  32 #include &quot;classfile/classLoader.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/moduleEntry.hpp&quot;
  36 #include &quot;classfile/modules.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/vmSymbols.hpp&quot;
  40 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  41 #include &quot;interpreter/linkResolver.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/allocation.inline.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/access.inline.hpp&quot;
  51 #include &quot;oops/arrayOop.inline.hpp&quot;


  52 #include &quot;oops/instanceKlass.inline.hpp&quot;
  53 #include &quot;oops/instanceOop.hpp&quot;
  54 #include &quot;oops/markWord.hpp&quot;
  55 #include &quot;oops/method.hpp&quot;
  56 #include &quot;oops/objArrayKlass.hpp&quot;
  57 #include &quot;oops/objArrayOop.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/symbol.hpp&quot;
  60 #include &quot;oops/typeArrayKlass.hpp&quot;
  61 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<span class="line-removed">  62 #include &quot;oops/valueArrayOop.inline.hpp&quot;</span>
<span class="line-removed">  63 #include &quot;oops/inlineKlass.inline.hpp&quot;</span>
  64 #include &quot;prims/jniCheck.hpp&quot;
  65 #include &quot;prims/jniExport.hpp&quot;
  66 #include &quot;prims/jniFastGetField.hpp&quot;
  67 #include &quot;prims/jvm_misc.hpp&quot;
  68 #include &quot;prims/jvmtiExport.hpp&quot;
  69 #include &quot;prims/jvmtiThreadState.hpp&quot;
  70 #include &quot;runtime/atomic.hpp&quot;
  71 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  72 #include &quot;runtime/handles.inline.hpp&quot;
  73 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  74 #include &quot;runtime/java.hpp&quot;
  75 #include &quot;runtime/javaCalls.hpp&quot;
  76 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  77 #include &quot;runtime/jniHandles.inline.hpp&quot;
  78 #include &quot;runtime/reflection.hpp&quot;
  79 #include &quot;runtime/safepointVerifiers.hpp&quot;
  80 #include &quot;runtime/sharedRuntime.hpp&quot;
  81 #include &quot;runtime/signature.hpp&quot;
  82 #include &quot;runtime/thread.inline.hpp&quot;
  83 #include &quot;runtime/vmOperations.hpp&quot;
</pre>
<hr />
<pre>
2502   if (initial_value != NULL) {  // array already initialized with NULL
2503     for (int index = 0; index &lt; length; index++) {
2504       result-&gt;obj_at_put(index, initial_value);
2505     }
2506   }
2507   ret = (jobjectArray) JNIHandles::make_local(env, result);
2508   return ret;
2509 JNI_END
2510 
2511 DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject
2512                     , HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(_ret_ref));
2513 
2514 JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
2515   JNIWrapper(&quot;GetObjectArrayElement&quot;);
2516  HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
2517   jobject ret = NULL;
2518   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&amp;)ret);
2519   oop res = NULL;
2520   arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));
2521   if (arr-&gt;is_within_bounds(index)) {
<span class="line-modified">2522     if (arr-&gt;is_valueArray()) {</span>
<span class="line-modified">2523       valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));</span>
2524       arrayHandle ah(THREAD, a);
<span class="line-modified">2525       valueArrayHandle vah(thread, a);</span>
<span class="line-modified">2526       res = valueArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK_NULL);</span>
2527       assert(res != NULL, &quot;Must be set in one of two paths above&quot;);
2528     } else {
2529       assert(arr-&gt;is_objArray(), &quot;If not a valueArray. must be an objArray&quot;);
2530       objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2531       res = a-&gt;obj_at(index);
2532     }
2533   } else {
2534     ResourceMark rm(THREAD);
2535     stringStream ss;
2536     ss.print(&quot;Index %d out of bounds for length %d&quot;, index,arr-&gt;length());
2537     THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2538   }
2539   ret = JNIHandles::make_local(env, res);
2540   return ret;
2541 JNI_END
2542 
2543 DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
2544                          , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
2545 
2546 JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
2547   JNIWrapper(&quot;SetObjectArrayElement&quot;);
2548   HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);
2549   DT_VOID_RETURN_MARK(SetObjectArrayElement);
2550 
2551    bool oob = false;
2552    int length = -1;
2553    oop res = NULL;
2554    arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));
2555    if (arr-&gt;is_within_bounds(index)) {
<span class="line-modified">2556      if (arr-&gt;is_valueArray()) {</span>
<span class="line-modified">2557        valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));</span>
2558        oop v = JNIHandles::resolve(value);
<span class="line-modified">2559        ValueArrayKlass* vaklass = ValueArrayKlass::cast(a-&gt;klass());</span>
2560        InlineKlass* element_vklass = vaklass-&gt;element_klass();
2561        if (v != NULL &amp;&amp; v-&gt;is_a(element_vklass)) {
2562          a-&gt;value_copy_to_index(v, index);
2563        } else {
2564          ResourceMark rm(THREAD);
2565          stringStream ss;
<span class="line-modified">2566          Klass *kl = ValueArrayKlass::cast(a-&gt;klass());</span>
2567          ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,
2568              v-&gt;klass()-&gt;external_name(),
2569              kl-&gt;external_name(),
2570              index);
2571          for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {
2572            ss.print(&quot;[]&quot;);
2573          }
2574          THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
2575        }
2576      } else {
2577        assert(arr-&gt;is_objArray(), &quot;If not a valueArray. must be an objArray&quot;);
2578        objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2579        oop v = JNIHandles::resolve(value);
2580        if (v == NULL || v-&gt;is_a(ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass())) {
2581          a-&gt;obj_at_put(index, v);
2582        } else {
2583          ResourceMark rm(THREAD);
2584          stringStream ss;
2585          Klass *bottom_kl = ObjArrayKlass::cast(a-&gt;klass())-&gt;bottom_klass();
2586          ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,
</pre>
<hr />
<pre>
3377   HOTSPOT_JNI_GETJAVAVM_RETURN(JNI_OK);
3378   return JNI_OK;
3379 JNI_END
3380 
3381 
3382 JNI_ENTRY(jobject, jni_GetModule(JNIEnv* env, jclass clazz))
3383   JNIWrapper(&quot;GetModule&quot;);
3384   return Modules::get_module(clazz, THREAD);
3385 JNI_END
3386 
3387 
3388 JNI_ENTRY(void*, jni_GetFlattenedArrayElements(JNIEnv* env, jarray array, jboolean* isCopy))
3389   JNIWrapper(&quot;jni_GetFlattenedArrayElements&quot;);
3390   if (isCopy != NULL) {
3391     *isCopy = JNI_FALSE;
3392   }
3393   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));
3394   if (!ar-&gt;is_array()) {
3395     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3396   }
<span class="line-modified">3397   if (!ar-&gt;is_valueArray()) {</span>
3398     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3399   }
<span class="line-modified">3400   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());</span>
3401   if (vak-&gt;contains_oops()) {
3402     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Flattened array contains oops&quot;);
3403   }
3404   oop a = lock_gc_or_pin_object(thread, array);
<span class="line-modified">3405   valueArrayOop vap = valueArrayOop(a);</span>
3406   void* ret = vap-&gt;value_at_addr(0, vak-&gt;layout_helper());
3407   return ret;
3408 JNI_END
3409 
3410 JNI_ENTRY(void, jni_ReleaseFlattenedArrayElements(JNIEnv* env, jarray array, void* elem, jint mode))
3411   JNIWrapper(&quot;jni_ReleaseFlattenedArrayElements&quot;);
3412   unlock_gc_or_unpin_object(thread, array);
3413 JNI_END
3414 
3415 JNI_ENTRY(jsize, jni_GetFlattenedArrayElementSize(JNIEnv* env, jarray array)) {
3416   JNIWrapper(&quot;jni_GetFlattenedElementSize&quot;);
3417   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
3418   if (!a-&gt;is_array()) {
3419     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3420   }
<span class="line-modified">3421   if (!a-&gt;is_valueArray()) {</span>
3422     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3423   }
<span class="line-modified">3424   ValueArrayKlass* vak = ValueArrayKlass::cast(a-&gt;klass());</span>
3425   jsize ret = vak-&gt;element_byte_size();
3426   return ret;
3427 }
3428 JNI_END
3429 
3430 JNI_ENTRY(jclass, jni_GetFlattenedArrayElementClass(JNIEnv* env, jarray array))
3431   JNIWrapper(&quot;jni_GetArrayElementClass&quot;);
3432   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
3433   if (!a-&gt;is_array()) {
3434     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3435   }
<span class="line-modified">3436   if (!a-&gt;is_valueArray()) {</span>
3437     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3438   }
<span class="line-modified">3439   ValueArrayKlass* vak = ValueArrayKlass::cast(a-&gt;klass());</span>
3440   InlineKlass* vk = vak-&gt;element_klass();
3441   return (jclass) JNIHandles::make_local(vk-&gt;java_mirror());
3442 JNI_END
3443 
3444 JNI_ENTRY(jsize, jni_GetFieldOffsetInFlattenedLayout(JNIEnv* env, jclass clazz, const char *name, const char *signature, jboolean* is_inlined))
3445   JNIWrapper(&quot;jni_GetFieldOffsetInFlattenedLayout&quot;);
3446 
3447   oop mirror = JNIHandles::resolve_non_null(clazz);
3448   Klass* k = java_lang_Class::as_Klass(mirror);
3449   if (!k-&gt;is_inline_klass()) {
3450     ResourceMark rm;
3451         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;%s has not flattened layout&quot;, k-&gt;external_name()));
3452   }
3453   InlineKlass* vk = InlineKlass::cast(k);
3454 
3455   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
3456   TempNewSymbol signame = SymbolTable::probe(signature, (int)strlen(signature));
3457   if (fieldname == NULL || signame == NULL) {
3458     ResourceMark rm;
3459     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, vk-&gt;external_name(), name, signature));
</pre>
<hr />
<pre>
3465   if (!vk-&gt;is_instance_klass() ||
3466       !InstanceKlass::cast(vk)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
3467     ResourceMark rm;
3468     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, vk-&gt;external_name(), name, signature));
3469   }
3470 
3471   int offset = fd.offset() - vk-&gt;first_field_offset();
3472   if (is_inlined != NULL) {
3473     *is_inlined = fd.is_inlined();
3474   }
3475   return (jsize)offset;
3476 JNI_END
3477 
3478 JNI_ENTRY(jobject, jni_CreateSubElementSelector(JNIEnv* env, jarray array))
3479   JNIWrapper(&quot;jni_CreateSubElementSelector&quot;);
3480 
3481   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));
3482   if (!ar-&gt;is_array()) {
3483     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3484   }
<span class="line-modified">3485   if (!ar-&gt;is_valueArray()) {</span>
3486     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3487   }
3488   Klass* ses_k = SystemDictionary::resolve_or_null(vmSymbols::jdk_internal_vm_jni_SubElementSelector(),
3489         Handle(THREAD, SystemDictionary::java_system_loader()), Handle(), CHECK_NULL);
3490   InstanceKlass* ses_ik = InstanceKlass::cast(ses_k);
3491   ses_ik-&gt;initialize(CHECK_NULL);
3492   Klass* elementKlass = ArrayKlass::cast(ar-&gt;klass())-&gt;element_klass();
3493   oop ses = ses_ik-&gt;allocate_instance(CHECK_NULL);
3494   Handle ses_h(THREAD, ses);
3495   jdk_internal_vm_jni_SubElementSelector::setArrayElementType(ses_h(), elementKlass-&gt;java_mirror());
3496   jdk_internal_vm_jni_SubElementSelector::setSubElementType(ses_h(), elementKlass-&gt;java_mirror());
3497   jdk_internal_vm_jni_SubElementSelector::setOffset(ses_h(), 0);
3498   jdk_internal_vm_jni_SubElementSelector::setIsInlined(ses_h(), true);   // by definition, top element of a flattened array is inlined
3499   jdk_internal_vm_jni_SubElementSelector::setIsInlineType(ses_h(), true); // by definition, top element of a flattened array is an inline type
3500   return JNIHandles::make_local(ses_h());
3501 JNI_END
3502 
3503 JNI_ENTRY(jobject, jni_GetSubElementSelector(JNIEnv* env, jobject selector, jfieldID fieldID))
3504   JNIWrapper(&quot;jni_GetSubElementSelector&quot;);
3505 
</pre>
<hr />
<pre>
3532   Handle res_h(THREAD, res);
3533   jdk_internal_vm_jni_SubElementSelector::setArrayElementType(res_h(), arrayElementMirror());
3534   InstanceKlass* holder = fd.field_holder();
3535   BasicType bt = Signature::basic_type(fd.signature());
3536   if (is_java_primitive(bt)) {
3537     jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(), java_lang_Class::primitive_mirror(bt));
3538   } else {
3539     Klass* fieldKlass = SystemDictionary::resolve_or_fail(fd.signature(), Handle(THREAD, holder-&gt;class_loader()),
3540         Handle(THREAD, holder-&gt;protection_domain()), true, CHECK_NULL);
3541     jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(),fieldKlass-&gt;java_mirror());
3542   }
3543   jdk_internal_vm_jni_SubElementSelector::setOffset(res_h(), offset);
3544   jdk_internal_vm_jni_SubElementSelector::setIsInlined(res_h(), fd.is_inlined());
3545   jdk_internal_vm_jni_SubElementSelector::setIsInlineType(res_h(), fd.is_inline_type());
3546   return JNIHandles::make_local(res_h());
3547 JNI_END
3548 
3549 JNI_ENTRY(jobject, jni_GetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index))
3550   JNIWrapper(&quot;jni_GetObjectSubElement&quot;);
3551 
<span class="line-modified">3552   valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);</span>
3553   oop slct = JNIHandles::resolve_non_null(selector);
<span class="line-modified">3554   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());</span>
3555   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) {
3556     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;);
3557   }
3558   oop res = NULL;
3559   if (!jdk_internal_vm_jni_SubElementSelector::getIsInlined(slct)) {
3560     int offset = (address)ar-&gt;base() - cast_from_oop&lt;address&gt;(ar) + index * vak-&gt;element_byte_size()
3561                       + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3562     res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(ar, offset);
3563   } else {
3564     InlineKlass* fieldKlass = InlineKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));
3565     res = fieldKlass-&gt;allocate_instance_buffer(CHECK_NULL);
3566     // The array might have been moved by the GC, refreshing the arrayOop
<span class="line-modified">3567     ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);</span>
3568     address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper())
3569               + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3570     fieldKlass-&gt;inline_copy_payload_to_new_oop(addr, res);
3571   }
3572   return JNIHandles::make_local(res);
3573 JNI_END
3574 
3575 JNI_ENTRY(void, jni_SetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index, jobject value))
3576   JNIWrapper(&quot;jni_SetObjectSubElement&quot;);
3577 
<span class="line-modified">3578   valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);</span>
3579   oop slct = JNIHandles::resolve_non_null(selector);
<span class="line-modified">3580   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());</span>
3581   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) {
3582     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;);
3583   }
3584   oop val = JNIHandles::resolve(value);
3585   if (val == NULL) {
3586     if (jdk_internal_vm_jni_SubElementSelector::getIsInlineType(slct)) {
3587       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), &quot;null cannot be stored in a flattened array&quot;);
3588     }
3589   } else {
3590     if (!val-&gt;is_a(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)))) {
3591       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), &quot;type mismatch&quot;);
3592     }
3593   }
3594   if (!jdk_internal_vm_jni_SubElementSelector::getIsInlined(slct)) {
3595     int offset = (address)ar-&gt;base() - cast_from_oop&lt;address&gt;(ar) + index * vak-&gt;element_byte_size()
3596                   + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3597     HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(ar, offset, JNIHandles::resolve(value));
3598   } else {
3599     InlineKlass* fieldKlass = InlineKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));
3600     address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper())
3601                   + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3602     fieldKlass-&gt;inline_copy_oop_to_payload(JNIHandles::resolve_non_null(value), addr);
3603   }
3604 JNI_END
3605 
3606 #define DEFINE_GETSUBELEMENT(ElementType,Result,ElementBasicType) \
3607 \
3608 JNI_ENTRY(ElementType, \
3609           jni_Get##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index)) \
3610   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;SubElement&quot;); \
<span class="line-modified">3611   valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \</span>
3612   oop slct = JNIHandles::resolve_non_null(selector); \
<span class="line-modified">3613   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass()); \</span>
3614   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) { \
3615     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;); \
3616   } \
3617   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \
3618     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong SubElement type&quot;); \
3619   } \
3620   address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper()) \
3621                + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \
3622   ElementType result = *(ElementType*)addr; \
3623   return result; \
3624 JNI_END
3625 
3626 DEFINE_GETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)
3627 DEFINE_GETSUBELEMENT(jbyte, Byte, T_BYTE)
3628 DEFINE_GETSUBELEMENT(jshort, Short,T_SHORT)
3629 DEFINE_GETSUBELEMENT(jchar, Char,T_CHAR)
3630 DEFINE_GETSUBELEMENT(jint, Int,T_INT)
3631 DEFINE_GETSUBELEMENT(jlong, Long,T_LONG)
3632 DEFINE_GETSUBELEMENT(jfloat, Float,T_FLOAT)
3633 DEFINE_GETSUBELEMENT(jdouble, Double,T_DOUBLE)
3634 
3635 #define DEFINE_SETSUBELEMENT(ElementType,Result,ElementBasicType) \
3636 \
3637 JNI_ENTRY(void, \
3638           jni_Set##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index, ElementType value)) \
3639   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;SubElement&quot;); \
<span class="line-modified">3640   valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \</span>
3641   oop slct = JNIHandles::resolve_non_null(selector); \
<span class="line-modified">3642   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass()); \</span>
3643   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) { \
3644     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;); \
3645   } \
3646   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \
3647     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong SubElement type&quot;); \
3648   } \
3649   address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper()) \
3650                + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \
3651   *(ElementType*)addr = value; \
3652 JNI_END
3653 
3654 DEFINE_SETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)
3655 DEFINE_SETSUBELEMENT(jbyte, Byte, T_BYTE)
3656 DEFINE_SETSUBELEMENT(jshort, Short,T_SHORT)
3657 DEFINE_SETSUBELEMENT(jchar, Char,T_CHAR)
3658 DEFINE_SETSUBELEMENT(jint, Int,T_INT)
3659 DEFINE_SETSUBELEMENT(jlong, Long,T_LONG)
3660 DEFINE_SETSUBELEMENT(jfloat, Float,T_FLOAT)
3661 DEFINE_SETSUBELEMENT(jdouble, Double,T_DOUBLE)
3662 
</pre>
</td>
<td>
<hr />
<pre>
  32 #include &quot;classfile/classLoader.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/moduleEntry.hpp&quot;
  36 #include &quot;classfile/modules.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/vmSymbols.hpp&quot;
  40 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  41 #include &quot;interpreter/linkResolver.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/allocation.inline.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/access.inline.hpp&quot;
  51 #include &quot;oops/arrayOop.inline.hpp&quot;
<span class="line-added">  52 #include &quot;oops/inlineArrayOop.inline.hpp&quot;</span>
<span class="line-added">  53 #include &quot;oops/inlineKlass.inline.hpp&quot;</span>
  54 #include &quot;oops/instanceKlass.inline.hpp&quot;
  55 #include &quot;oops/instanceOop.hpp&quot;
  56 #include &quot;oops/markWord.hpp&quot;
  57 #include &quot;oops/method.hpp&quot;
  58 #include &quot;oops/objArrayKlass.hpp&quot;
  59 #include &quot;oops/objArrayOop.inline.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;oops/symbol.hpp&quot;
  62 #include &quot;oops/typeArrayKlass.hpp&quot;
  63 #include &quot;oops/typeArrayOop.inline.hpp&quot;


  64 #include &quot;prims/jniCheck.hpp&quot;
  65 #include &quot;prims/jniExport.hpp&quot;
  66 #include &quot;prims/jniFastGetField.hpp&quot;
  67 #include &quot;prims/jvm_misc.hpp&quot;
  68 #include &quot;prims/jvmtiExport.hpp&quot;
  69 #include &quot;prims/jvmtiThreadState.hpp&quot;
  70 #include &quot;runtime/atomic.hpp&quot;
  71 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  72 #include &quot;runtime/handles.inline.hpp&quot;
  73 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  74 #include &quot;runtime/java.hpp&quot;
  75 #include &quot;runtime/javaCalls.hpp&quot;
  76 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  77 #include &quot;runtime/jniHandles.inline.hpp&quot;
  78 #include &quot;runtime/reflection.hpp&quot;
  79 #include &quot;runtime/safepointVerifiers.hpp&quot;
  80 #include &quot;runtime/sharedRuntime.hpp&quot;
  81 #include &quot;runtime/signature.hpp&quot;
  82 #include &quot;runtime/thread.inline.hpp&quot;
  83 #include &quot;runtime/vmOperations.hpp&quot;
</pre>
<hr />
<pre>
2502   if (initial_value != NULL) {  // array already initialized with NULL
2503     for (int index = 0; index &lt; length; index++) {
2504       result-&gt;obj_at_put(index, initial_value);
2505     }
2506   }
2507   ret = (jobjectArray) JNIHandles::make_local(env, result);
2508   return ret;
2509 JNI_END
2510 
2511 DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject
2512                     , HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(_ret_ref));
2513 
2514 JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
2515   JNIWrapper(&quot;GetObjectArrayElement&quot;);
2516  HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
2517   jobject ret = NULL;
2518   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&amp;)ret);
2519   oop res = NULL;
2520   arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));
2521   if (arr-&gt;is_within_bounds(index)) {
<span class="line-modified">2522     if (arr-&gt;is_inlineArray()) {</span>
<span class="line-modified">2523       inlineArrayOop a = inlineArrayOop(JNIHandles::resolve_non_null(array));</span>
2524       arrayHandle ah(THREAD, a);
<span class="line-modified">2525       inlineArrayHandle vah(thread, a);</span>
<span class="line-modified">2526       res = inlineArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK_NULL);</span>
2527       assert(res != NULL, &quot;Must be set in one of two paths above&quot;);
2528     } else {
2529       assert(arr-&gt;is_objArray(), &quot;If not a valueArray. must be an objArray&quot;);
2530       objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2531       res = a-&gt;obj_at(index);
2532     }
2533   } else {
2534     ResourceMark rm(THREAD);
2535     stringStream ss;
2536     ss.print(&quot;Index %d out of bounds for length %d&quot;, index,arr-&gt;length());
2537     THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2538   }
2539   ret = JNIHandles::make_local(env, res);
2540   return ret;
2541 JNI_END
2542 
2543 DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
2544                          , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
2545 
2546 JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
2547   JNIWrapper(&quot;SetObjectArrayElement&quot;);
2548   HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);
2549   DT_VOID_RETURN_MARK(SetObjectArrayElement);
2550 
2551    bool oob = false;
2552    int length = -1;
2553    oop res = NULL;
2554    arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));
2555    if (arr-&gt;is_within_bounds(index)) {
<span class="line-modified">2556      if (arr-&gt;is_inlineArray()) {</span>
<span class="line-modified">2557        inlineArrayOop a = inlineArrayOop(JNIHandles::resolve_non_null(array));</span>
2558        oop v = JNIHandles::resolve(value);
<span class="line-modified">2559        InlineArrayKlass* vaklass = InlineArrayKlass::cast(a-&gt;klass());</span>
2560        InlineKlass* element_vklass = vaklass-&gt;element_klass();
2561        if (v != NULL &amp;&amp; v-&gt;is_a(element_vklass)) {
2562          a-&gt;value_copy_to_index(v, index);
2563        } else {
2564          ResourceMark rm(THREAD);
2565          stringStream ss;
<span class="line-modified">2566          Klass *kl = InlineArrayKlass::cast(a-&gt;klass());</span>
2567          ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,
2568              v-&gt;klass()-&gt;external_name(),
2569              kl-&gt;external_name(),
2570              index);
2571          for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {
2572            ss.print(&quot;[]&quot;);
2573          }
2574          THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
2575        }
2576      } else {
2577        assert(arr-&gt;is_objArray(), &quot;If not a valueArray. must be an objArray&quot;);
2578        objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2579        oop v = JNIHandles::resolve(value);
2580        if (v == NULL || v-&gt;is_a(ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass())) {
2581          a-&gt;obj_at_put(index, v);
2582        } else {
2583          ResourceMark rm(THREAD);
2584          stringStream ss;
2585          Klass *bottom_kl = ObjArrayKlass::cast(a-&gt;klass())-&gt;bottom_klass();
2586          ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,
</pre>
<hr />
<pre>
3377   HOTSPOT_JNI_GETJAVAVM_RETURN(JNI_OK);
3378   return JNI_OK;
3379 JNI_END
3380 
3381 
3382 JNI_ENTRY(jobject, jni_GetModule(JNIEnv* env, jclass clazz))
3383   JNIWrapper(&quot;GetModule&quot;);
3384   return Modules::get_module(clazz, THREAD);
3385 JNI_END
3386 
3387 
3388 JNI_ENTRY(void*, jni_GetFlattenedArrayElements(JNIEnv* env, jarray array, jboolean* isCopy))
3389   JNIWrapper(&quot;jni_GetFlattenedArrayElements&quot;);
3390   if (isCopy != NULL) {
3391     *isCopy = JNI_FALSE;
3392   }
3393   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));
3394   if (!ar-&gt;is_array()) {
3395     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3396   }
<span class="line-modified">3397   if (!ar-&gt;is_inlineArray()) {</span>
3398     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3399   }
<span class="line-modified">3400   InlineArrayKlass* vak = InlineArrayKlass::cast(ar-&gt;klass());</span>
3401   if (vak-&gt;contains_oops()) {
3402     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Flattened array contains oops&quot;);
3403   }
3404   oop a = lock_gc_or_pin_object(thread, array);
<span class="line-modified">3405   inlineArrayOop vap = inlineArrayOop(a);</span>
3406   void* ret = vap-&gt;value_at_addr(0, vak-&gt;layout_helper());
3407   return ret;
3408 JNI_END
3409 
3410 JNI_ENTRY(void, jni_ReleaseFlattenedArrayElements(JNIEnv* env, jarray array, void* elem, jint mode))
3411   JNIWrapper(&quot;jni_ReleaseFlattenedArrayElements&quot;);
3412   unlock_gc_or_unpin_object(thread, array);
3413 JNI_END
3414 
3415 JNI_ENTRY(jsize, jni_GetFlattenedArrayElementSize(JNIEnv* env, jarray array)) {
3416   JNIWrapper(&quot;jni_GetFlattenedElementSize&quot;);
3417   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
3418   if (!a-&gt;is_array()) {
3419     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3420   }
<span class="line-modified">3421   if (!a-&gt;is_inlineArray()) {</span>
3422     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3423   }
<span class="line-modified">3424   InlineArrayKlass* vak = InlineArrayKlass::cast(a-&gt;klass());</span>
3425   jsize ret = vak-&gt;element_byte_size();
3426   return ret;
3427 }
3428 JNI_END
3429 
3430 JNI_ENTRY(jclass, jni_GetFlattenedArrayElementClass(JNIEnv* env, jarray array))
3431   JNIWrapper(&quot;jni_GetArrayElementClass&quot;);
3432   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
3433   if (!a-&gt;is_array()) {
3434     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3435   }
<span class="line-modified">3436   if (!a-&gt;is_inlineArray()) {</span>
3437     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3438   }
<span class="line-modified">3439   InlineArrayKlass* vak = InlineArrayKlass::cast(a-&gt;klass());</span>
3440   InlineKlass* vk = vak-&gt;element_klass();
3441   return (jclass) JNIHandles::make_local(vk-&gt;java_mirror());
3442 JNI_END
3443 
3444 JNI_ENTRY(jsize, jni_GetFieldOffsetInFlattenedLayout(JNIEnv* env, jclass clazz, const char *name, const char *signature, jboolean* is_inlined))
3445   JNIWrapper(&quot;jni_GetFieldOffsetInFlattenedLayout&quot;);
3446 
3447   oop mirror = JNIHandles::resolve_non_null(clazz);
3448   Klass* k = java_lang_Class::as_Klass(mirror);
3449   if (!k-&gt;is_inline_klass()) {
3450     ResourceMark rm;
3451         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;%s has not flattened layout&quot;, k-&gt;external_name()));
3452   }
3453   InlineKlass* vk = InlineKlass::cast(k);
3454 
3455   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
3456   TempNewSymbol signame = SymbolTable::probe(signature, (int)strlen(signature));
3457   if (fieldname == NULL || signame == NULL) {
3458     ResourceMark rm;
3459     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, vk-&gt;external_name(), name, signature));
</pre>
<hr />
<pre>
3465   if (!vk-&gt;is_instance_klass() ||
3466       !InstanceKlass::cast(vk)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
3467     ResourceMark rm;
3468     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, vk-&gt;external_name(), name, signature));
3469   }
3470 
3471   int offset = fd.offset() - vk-&gt;first_field_offset();
3472   if (is_inlined != NULL) {
3473     *is_inlined = fd.is_inlined();
3474   }
3475   return (jsize)offset;
3476 JNI_END
3477 
3478 JNI_ENTRY(jobject, jni_CreateSubElementSelector(JNIEnv* env, jarray array))
3479   JNIWrapper(&quot;jni_CreateSubElementSelector&quot;);
3480 
3481   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));
3482   if (!ar-&gt;is_array()) {
3483     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3484   }
<span class="line-modified">3485   if (!ar-&gt;is_inlineArray()) {</span>
3486     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3487   }
3488   Klass* ses_k = SystemDictionary::resolve_or_null(vmSymbols::jdk_internal_vm_jni_SubElementSelector(),
3489         Handle(THREAD, SystemDictionary::java_system_loader()), Handle(), CHECK_NULL);
3490   InstanceKlass* ses_ik = InstanceKlass::cast(ses_k);
3491   ses_ik-&gt;initialize(CHECK_NULL);
3492   Klass* elementKlass = ArrayKlass::cast(ar-&gt;klass())-&gt;element_klass();
3493   oop ses = ses_ik-&gt;allocate_instance(CHECK_NULL);
3494   Handle ses_h(THREAD, ses);
3495   jdk_internal_vm_jni_SubElementSelector::setArrayElementType(ses_h(), elementKlass-&gt;java_mirror());
3496   jdk_internal_vm_jni_SubElementSelector::setSubElementType(ses_h(), elementKlass-&gt;java_mirror());
3497   jdk_internal_vm_jni_SubElementSelector::setOffset(ses_h(), 0);
3498   jdk_internal_vm_jni_SubElementSelector::setIsInlined(ses_h(), true);   // by definition, top element of a flattened array is inlined
3499   jdk_internal_vm_jni_SubElementSelector::setIsInlineType(ses_h(), true); // by definition, top element of a flattened array is an inline type
3500   return JNIHandles::make_local(ses_h());
3501 JNI_END
3502 
3503 JNI_ENTRY(jobject, jni_GetSubElementSelector(JNIEnv* env, jobject selector, jfieldID fieldID))
3504   JNIWrapper(&quot;jni_GetSubElementSelector&quot;);
3505 
</pre>
<hr />
<pre>
3532   Handle res_h(THREAD, res);
3533   jdk_internal_vm_jni_SubElementSelector::setArrayElementType(res_h(), arrayElementMirror());
3534   InstanceKlass* holder = fd.field_holder();
3535   BasicType bt = Signature::basic_type(fd.signature());
3536   if (is_java_primitive(bt)) {
3537     jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(), java_lang_Class::primitive_mirror(bt));
3538   } else {
3539     Klass* fieldKlass = SystemDictionary::resolve_or_fail(fd.signature(), Handle(THREAD, holder-&gt;class_loader()),
3540         Handle(THREAD, holder-&gt;protection_domain()), true, CHECK_NULL);
3541     jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(),fieldKlass-&gt;java_mirror());
3542   }
3543   jdk_internal_vm_jni_SubElementSelector::setOffset(res_h(), offset);
3544   jdk_internal_vm_jni_SubElementSelector::setIsInlined(res_h(), fd.is_inlined());
3545   jdk_internal_vm_jni_SubElementSelector::setIsInlineType(res_h(), fd.is_inline_type());
3546   return JNIHandles::make_local(res_h());
3547 JNI_END
3548 
3549 JNI_ENTRY(jobject, jni_GetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index))
3550   JNIWrapper(&quot;jni_GetObjectSubElement&quot;);
3551 
<span class="line-modified">3552   inlineArrayOop ar =  (inlineArrayOop)JNIHandles::resolve_non_null(array);</span>
3553   oop slct = JNIHandles::resolve_non_null(selector);
<span class="line-modified">3554   InlineArrayKlass* vak = InlineArrayKlass::cast(ar-&gt;klass());</span>
3555   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) {
3556     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;);
3557   }
3558   oop res = NULL;
3559   if (!jdk_internal_vm_jni_SubElementSelector::getIsInlined(slct)) {
3560     int offset = (address)ar-&gt;base() - cast_from_oop&lt;address&gt;(ar) + index * vak-&gt;element_byte_size()
3561                       + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3562     res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(ar, offset);
3563   } else {
3564     InlineKlass* fieldKlass = InlineKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));
3565     res = fieldKlass-&gt;allocate_instance_buffer(CHECK_NULL);
3566     // The array might have been moved by the GC, refreshing the arrayOop
<span class="line-modified">3567     ar =  (inlineArrayOop)JNIHandles::resolve_non_null(array);</span>
3568     address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper())
3569               + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3570     fieldKlass-&gt;inline_copy_payload_to_new_oop(addr, res);
3571   }
3572   return JNIHandles::make_local(res);
3573 JNI_END
3574 
3575 JNI_ENTRY(void, jni_SetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index, jobject value))
3576   JNIWrapper(&quot;jni_SetObjectSubElement&quot;);
3577 
<span class="line-modified">3578   inlineArrayOop ar =  (inlineArrayOop)JNIHandles::resolve_non_null(array);</span>
3579   oop slct = JNIHandles::resolve_non_null(selector);
<span class="line-modified">3580   InlineArrayKlass* vak = InlineArrayKlass::cast(ar-&gt;klass());</span>
3581   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) {
3582     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;);
3583   }
3584   oop val = JNIHandles::resolve(value);
3585   if (val == NULL) {
3586     if (jdk_internal_vm_jni_SubElementSelector::getIsInlineType(slct)) {
3587       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), &quot;null cannot be stored in a flattened array&quot;);
3588     }
3589   } else {
3590     if (!val-&gt;is_a(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)))) {
3591       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), &quot;type mismatch&quot;);
3592     }
3593   }
3594   if (!jdk_internal_vm_jni_SubElementSelector::getIsInlined(slct)) {
3595     int offset = (address)ar-&gt;base() - cast_from_oop&lt;address&gt;(ar) + index * vak-&gt;element_byte_size()
3596                   + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3597     HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(ar, offset, JNIHandles::resolve(value));
3598   } else {
3599     InlineKlass* fieldKlass = InlineKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));
3600     address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper())
3601                   + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3602     fieldKlass-&gt;inline_copy_oop_to_payload(JNIHandles::resolve_non_null(value), addr);
3603   }
3604 JNI_END
3605 
3606 #define DEFINE_GETSUBELEMENT(ElementType,Result,ElementBasicType) \
3607 \
3608 JNI_ENTRY(ElementType, \
3609           jni_Get##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index)) \
3610   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;SubElement&quot;); \
<span class="line-modified">3611   inlineArrayOop ar = (inlineArrayOop)JNIHandles::resolve_non_null(array); \</span>
3612   oop slct = JNIHandles::resolve_non_null(selector); \
<span class="line-modified">3613   InlineArrayKlass* vak = InlineArrayKlass::cast(ar-&gt;klass()); \</span>
3614   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) { \
3615     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;); \
3616   } \
3617   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \
3618     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong SubElement type&quot;); \
3619   } \
3620   address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper()) \
3621                + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \
3622   ElementType result = *(ElementType*)addr; \
3623   return result; \
3624 JNI_END
3625 
3626 DEFINE_GETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)
3627 DEFINE_GETSUBELEMENT(jbyte, Byte, T_BYTE)
3628 DEFINE_GETSUBELEMENT(jshort, Short,T_SHORT)
3629 DEFINE_GETSUBELEMENT(jchar, Char,T_CHAR)
3630 DEFINE_GETSUBELEMENT(jint, Int,T_INT)
3631 DEFINE_GETSUBELEMENT(jlong, Long,T_LONG)
3632 DEFINE_GETSUBELEMENT(jfloat, Float,T_FLOAT)
3633 DEFINE_GETSUBELEMENT(jdouble, Double,T_DOUBLE)
3634 
3635 #define DEFINE_SETSUBELEMENT(ElementType,Result,ElementBasicType) \
3636 \
3637 JNI_ENTRY(void, \
3638           jni_Set##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index, ElementType value)) \
3639   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;SubElement&quot;); \
<span class="line-modified">3640   inlineArrayOop ar = (inlineArrayOop)JNIHandles::resolve_non_null(array); \</span>
3641   oop slct = JNIHandles::resolve_non_null(selector); \
<span class="line-modified">3642   InlineArrayKlass* vak = InlineArrayKlass::cast(ar-&gt;klass()); \</span>
3643   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) { \
3644     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;); \
3645   } \
3646   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \
3647     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong SubElement type&quot;); \
3648   } \
3649   address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper()) \
3650                + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \
3651   *(ElementType*)addr = value; \
3652 JNI_END
3653 
3654 DEFINE_SETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)
3655 DEFINE_SETSUBELEMENT(jbyte, Byte, T_BYTE)
3656 DEFINE_SETSUBELEMENT(jshort, Short,T_SHORT)
3657 DEFINE_SETSUBELEMENT(jchar, Char,T_CHAR)
3658 DEFINE_SETSUBELEMENT(jint, Int,T_INT)
3659 DEFINE_SETSUBELEMENT(jlong, Long,T_LONG)
3660 DEFINE_SETSUBELEMENT(jfloat, Float,T_FLOAT)
3661 DEFINE_SETSUBELEMENT(jdouble, Double,T_DOUBLE)
3662 
</pre>
</td>
</tr>
</table>
<center><a href="../opto/type.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniCheck.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
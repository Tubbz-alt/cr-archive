diff a/src/hotspot/cpu/x86/templateTable_x86.cpp b/src/hotspot/cpu/x86/templateTable_x86.cpp
--- a/src/hotspot/cpu/x86/templateTable_x86.cpp
+++ b/src/hotspot/cpu/x86/templateTable_x86.cpp
@@ -4335,10 +4335,11 @@
 void TemplateTable::_new() {
   transition(vtos, atos);
   __ get_unsigned_2_byte_index_at_bcp(rdx, 1);
   Label slow_case;
   Label done;
+  Label is_not_value;
 
   __ get_cpool_and_tags(rcx, rax);
 
   // Make sure the class we're about to instantiate has been resolved.
   // This is done before loading InstanceKlass to be consistent with the order
@@ -4348,10 +4349,19 @@
   __ jcc(Assembler::notEqual, slow_case);
 
   // get InstanceKlass
   __ load_resolved_klass_at_index(rcx, rcx, rdx);
 
+  __ movl(rdx, Address(rcx, InstanceKlass::misc_flags_offset()));
+  __ andl(rdx, InstanceKlass::_misc_kind_field_mask);
+  __ cmpl(rdx, InstanceKlass::_misc_kind_value_type);
+  __ jcc(Assembler::notEqual, is_not_value);
+
+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_InstantiationError));
+
+  __ bind(is_not_value);
+
   // make sure klass is initialized & doesn't have finalizer
   __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
   __ jcc(Assembler::notEqual, slow_case);
 
   __ allocate_instance(rcx, rax, rdx, rbx, true, slow_case);
@@ -4375,10 +4385,11 @@
 void TemplateTable::defaultvalue() {
   transition(vtos, atos);
 
   Label slow_case;
   Label done;
+  Label is_value;
 
   __ get_unsigned_2_byte_index_at_bcp(rdx, 1);
   __ get_cpool_and_tags(rcx, rax);
 
   // Make sure the class we're about to instantiate has been resolved.
@@ -4389,10 +4400,20 @@
   __ jcc(Assembler::notEqual, slow_case);
 
   // get InstanceKlass
   __ load_resolved_klass_at_index(rcx, rcx, rdx);
 
+  __ movl(rdx, Address(rcx, InstanceKlass::misc_flags_offset()));
+  __ andl(rdx, InstanceKlass::_misc_kind_field_mask);
+  __ cmpl(rdx, InstanceKlass::_misc_kind_value_type);
+  __ jcc(Assembler::equal, is_value);
+
+  // in the future, defaultvalue will just return null instead of throwing an exception
+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_IncompatibleClassChangeError));
+
+  __ bind(is_value);
+
   // make sure klass is fully initialized
   __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
   __ jcc(Assembler::notEqual, slow_case);
 
   // have a resolved ValueKlass in rcx, return the default value oop from it

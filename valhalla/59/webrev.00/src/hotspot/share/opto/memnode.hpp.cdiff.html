<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/memnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="memnode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse2.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/memnode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 513,57 ***</span>
  };
  
  //------------------------------LoadKlassNode----------------------------------
  // Load a Klass from an object
  class LoadKlassNode : public LoadPNode {
<span class="line-removed">- private:</span>
<span class="line-removed">-   bool _clear_prop_bits; // Clear the ArrayStorageProperties bits</span>
  protected:
    // In most cases, LoadKlassNode does not have the control input set. If the control
    // input is set, it must not be removed (by LoadNode::Ideal()).
    virtual bool can_remove_control() const;
  public:
<span class="line-modified">!   LoadKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeKlassPtr *tk, MemOrd mo, bool clear_prop_bits)</span>
<span class="line-modified">!     : LoadPNode(c, mem, adr, at, tk, mo), _clear_prop_bits(clear_prop_bits) {}</span>
<span class="line-removed">-   virtual uint hash() const { return LoadPNode::hash() + _clear_prop_bits; }</span>
<span class="line-removed">-   virtual bool cmp(const Node &amp;n) const {</span>
<span class="line-removed">-     return (_clear_prop_bits == ((LoadKlassNode&amp;)n)._clear_prop_bits) &amp;&amp; LoadPNode::cmp(n);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   virtual uint size_of() const { return sizeof(*this); }</span>
    virtual int Opcode() const;
    virtual const Type* Value(PhaseGVN* phase) const;
    virtual Node* Identity(PhaseGVN* phase);
    virtual bool depends_only_on_test() const { return true; }
<span class="line-removed">-   bool clear_prop_bits() const { return _clear_prop_bits; }</span>
  
    // Polymorphic factory method:
    static Node* make(PhaseGVN&amp; gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at,
<span class="line-modified">!                     const TypeKlassPtr* tk = TypeKlassPtr::OBJECT, bool clear_prop_bits = false);</span>
  };
  
  //------------------------------LoadNKlassNode---------------------------------
  // Load a narrow Klass from an object.
  class LoadNKlassNode : public LoadNNode {
<span class="line-removed">- private:</span>
<span class="line-removed">-   bool _clear_prop_bits; // Clear the ArrayStorageProperties bits</span>
  public:
<span class="line-modified">!   LoadNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeNarrowKlass *tk, MemOrd mo, bool clear_prop_bits)</span>
<span class="line-modified">!     : LoadNNode(c, mem, adr, at, tk, mo), _clear_prop_bits(clear_prop_bits) {}</span>
<span class="line-removed">-   virtual uint hash() const { return LoadNNode::hash() + _clear_prop_bits; }</span>
<span class="line-removed">-   virtual bool cmp(const Node &amp;n) const {</span>
<span class="line-removed">-     return (_clear_prop_bits == ((LoadNKlassNode&amp;)n)._clear_prop_bits) &amp;&amp; LoadNNode::cmp(n);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   virtual uint size_of() const { return sizeof(*this); }</span>
    virtual int Opcode() const;
    virtual uint ideal_reg() const { return Op_RegN; }
    virtual int store_Opcode() const { return Op_StoreNKlass; }
    virtual BasicType memory_type() const { return T_NARROWKLASS; }
  
    virtual const Type* Value(PhaseGVN* phase) const;
    virtual Node* Identity(PhaseGVN* phase);
    virtual bool depends_only_on_test() const { return true; }
<span class="line-removed">-   bool clear_prop_bits() const { return _clear_prop_bits; }</span>
  };
  
  //------------------------------StoreNode--------------------------------------
  // Store value; requires Store, Address and Value
  class StoreNode : public MemNode {
<span class="line-new-header">--- 513,41 ---</span>
  };
  
  //------------------------------LoadKlassNode----------------------------------
  // Load a Klass from an object
  class LoadKlassNode : public LoadPNode {
  protected:
    // In most cases, LoadKlassNode does not have the control input set. If the control
    // input is set, it must not be removed (by LoadNode::Ideal()).
    virtual bool can_remove_control() const;
  public:
<span class="line-modified">!   LoadKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeKlassPtr *tk, MemOrd mo)</span>
<span class="line-modified">!     : LoadPNode(c, mem, adr, at, tk, mo) {}</span>
    virtual int Opcode() const;
    virtual const Type* Value(PhaseGVN* phase) const;
    virtual Node* Identity(PhaseGVN* phase);
    virtual bool depends_only_on_test() const { return true; }
  
    // Polymorphic factory method:
    static Node* make(PhaseGVN&amp; gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at,
<span class="line-modified">!                     const TypeKlassPtr* tk = TypeKlassPtr::OBJECT);</span>
  };
  
  //------------------------------LoadNKlassNode---------------------------------
  // Load a narrow Klass from an object.
  class LoadNKlassNode : public LoadNNode {
  public:
<span class="line-modified">!   LoadNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeNarrowKlass *tk, MemOrd mo)</span>
<span class="line-modified">!     : LoadNNode(c, mem, adr, at, tk, mo) {}</span>
    virtual int Opcode() const;
    virtual uint ideal_reg() const { return Op_RegN; }
    virtual int store_Opcode() const { return Op_StoreNKlass; }
    virtual BasicType memory_type() const { return T_NARROWKLASS; }
  
    virtual const Type* Value(PhaseGVN* phase) const;
    virtual Node* Identity(PhaseGVN* phase);
    virtual bool depends_only_on_test() const { return true; }
  };
  
  //------------------------------StoreNode--------------------------------------
  // Store value; requires Store, Address and Value
  class StoreNode : public MemNode {
</pre>
<center><a href="memnode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse2.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
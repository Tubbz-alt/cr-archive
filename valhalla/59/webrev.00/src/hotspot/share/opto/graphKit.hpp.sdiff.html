<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/graphKit.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="graphKit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/graphKit.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
325   Node* MaxI(Node* l, Node* r)                { return _gvn.transform(new MaxINode(l, r));       }
326   Node* MinI(Node* l, Node* r)                { return _gvn.transform(new MinINode(l, r));       }
327 
328   Node* LShiftI(Node* l, Node* r)             { return _gvn.transform(new LShiftINode(l, r));    }
329   Node* RShiftI(Node* l, Node* r)             { return _gvn.transform(new RShiftINode(l, r));    }
330   Node* URShiftI(Node* l, Node* r)            { return _gvn.transform(new URShiftINode(l, r));   }
331 
332   Node* CmpI(Node* l, Node* r)                { return _gvn.transform(new CmpINode(l, r));       }
333   Node* CmpL(Node* l, Node* r)                { return _gvn.transform(new CmpLNode(l, r));       }
334   Node* CmpP(Node* l, Node* r)                { return _gvn.transform(new CmpPNode(l, r));       }
335   Node* Bool(Node* cmp, BoolTest::mask relop) { return _gvn.transform(new BoolNode(cmp, relop)); }
336 
337   Node* AddP(Node* b, Node* a, Node* o)       { return _gvn.transform(new AddPNode(b, a, o));    }
338 
339   // Convert between int and long, and size_t.
340   // (See macros ConvI2X, etc., in type.hpp for ConvI2X, etc.)
341   Node* ConvI2L(Node* offset);
342   Node* ConvI2UL(Node* offset);
343   Node* ConvL2I(Node* offset);
344   // Find out the klass of an object.
<span class="line-modified">345   Node* load_object_klass(Node* object, bool clear_prop_bits = true);</span>
346   // Find out the length of an array.
347   Node* load_array_length(Node* array);
348 
349 
350   // Helper function to do a NULL pointer check or ZERO check based on type.
351   // Throw an exception if a given value is null.
352   // Return the value cast to not-null.
353   // Be clever about equivalent dominating null checks.
354   Node* null_check_common(Node* value, BasicType type,
355                           bool assert_null = false,
356                           Node* *null_control = NULL,
357                           bool speculative = false);
358   Node* null_check(Node* value, BasicType type = T_OBJECT) {
359     return null_check_common(value, type, false, NULL, !_gvn.type(value)-&gt;speculative_maybe_null());
360   }
361   Node* null_check_receiver() {
362     assert(argument(0)-&gt;bottom_type()-&gt;isa_ptr(), &quot;must be&quot;);
363     return null_check(argument(0));
364   }
365   Node* zero_check_int(Node* value) {
</pre>
</td>
<td>
<hr />
<pre>
325   Node* MaxI(Node* l, Node* r)                { return _gvn.transform(new MaxINode(l, r));       }
326   Node* MinI(Node* l, Node* r)                { return _gvn.transform(new MinINode(l, r));       }
327 
328   Node* LShiftI(Node* l, Node* r)             { return _gvn.transform(new LShiftINode(l, r));    }
329   Node* RShiftI(Node* l, Node* r)             { return _gvn.transform(new RShiftINode(l, r));    }
330   Node* URShiftI(Node* l, Node* r)            { return _gvn.transform(new URShiftINode(l, r));   }
331 
332   Node* CmpI(Node* l, Node* r)                { return _gvn.transform(new CmpINode(l, r));       }
333   Node* CmpL(Node* l, Node* r)                { return _gvn.transform(new CmpLNode(l, r));       }
334   Node* CmpP(Node* l, Node* r)                { return _gvn.transform(new CmpPNode(l, r));       }
335   Node* Bool(Node* cmp, BoolTest::mask relop) { return _gvn.transform(new BoolNode(cmp, relop)); }
336 
337   Node* AddP(Node* b, Node* a, Node* o)       { return _gvn.transform(new AddPNode(b, a, o));    }
338 
339   // Convert between int and long, and size_t.
340   // (See macros ConvI2X, etc., in type.hpp for ConvI2X, etc.)
341   Node* ConvI2L(Node* offset);
342   Node* ConvI2UL(Node* offset);
343   Node* ConvL2I(Node* offset);
344   // Find out the klass of an object.
<span class="line-modified">345   Node* load_object_klass(Node* object);</span>
346   // Find out the length of an array.
347   Node* load_array_length(Node* array);
348 
349 
350   // Helper function to do a NULL pointer check or ZERO check based on type.
351   // Throw an exception if a given value is null.
352   // Return the value cast to not-null.
353   // Be clever about equivalent dominating null checks.
354   Node* null_check_common(Node* value, BasicType type,
355                           bool assert_null = false,
356                           Node* *null_control = NULL,
357                           bool speculative = false);
358   Node* null_check(Node* value, BasicType type = T_OBJECT) {
359     return null_check_common(value, type, false, NULL, !_gvn.type(value)-&gt;speculative_maybe_null());
360   }
361   Node* null_check_receiver() {
362     assert(argument(0)-&gt;bottom_type()-&gt;isa_ptr(), &quot;must be&quot;);
363     return null_check(argument(0));
364   }
365   Node* zero_check_int(Node* value) {
</pre>
</td>
</tr>
</table>
<center><a href="graphKit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/memnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_MEMNODE_HPP
  26 #define SHARE_OPTO_MEMNODE_HPP
  27 
  28 #include &quot;opto/multnode.hpp&quot;
  29 #include &quot;opto/node.hpp&quot;
  30 #include &quot;opto/opcodes.hpp&quot;
  31 #include &quot;opto/type.hpp&quot;
  32 
  33 // Portions of code courtesy of Clifford Click
  34 
  35 class MultiNode;
  36 class PhaseCCP;
  37 class PhaseTransform;
  38 
  39 //------------------------------MemNode----------------------------------------
  40 // Load or Store, possibly throwing a NULL pointer exception
  41 class MemNode : public Node {
  42 private:
  43   bool _unaligned_access; // Unaligned access from unsafe
  44   bool _mismatched_access; // Mismatched access from unsafe: byte read in integer array for instance
  45   bool _unsafe_access;     // Access of unsafe origin.
  46   uint8_t _barrier; // Bit field with barrier information
  47 
  48 protected:
  49 #ifdef ASSERT
  50   const TypePtr* _adr_type;     // What kind of memory is being addressed?
  51 #endif
  52   virtual uint size_of() const;
  53 public:
  54   enum { Control,               // When is it safe to do this load?
  55          Memory,                // Chunk of memory is being loaded from
  56          Address,               // Actually address, derived from base
  57          ValueIn,               // Value to store
  58          OopStore               // Preceeding oop store, only in StoreCM
  59   };
  60   typedef enum { unordered = 0,
  61                  acquire,       // Load has to acquire or be succeeded by MemBarAcquire.
  62                  release,       // Store has to release or be preceded by MemBarRelease.
  63                  seqcst,        // LoadStore has to have both acquire and release semantics.
  64                  unset          // The memory ordering is not set (used for testing)
  65   } MemOrd;
  66 protected:
  67   MemNode( Node *c0, Node *c1, Node *c2, const TypePtr* at ) :
  68       Node(c0,c1,c2),
  69       _unaligned_access(false),
  70       _mismatched_access(false),
  71       _unsafe_access(false),
  72       _barrier(0) {
  73     init_class_id(Class_Mem);
  74     debug_only(_adr_type=at; adr_type();)
  75   }
  76   MemNode( Node *c0, Node *c1, Node *c2, const TypePtr* at, Node *c3 ) :
  77       Node(c0,c1,c2,c3),
  78       _unaligned_access(false),
  79       _mismatched_access(false),
  80       _unsafe_access(false),
  81       _barrier(0) {
  82     init_class_id(Class_Mem);
  83     debug_only(_adr_type=at; adr_type();)
  84   }
  85   MemNode( Node *c0, Node *c1, Node *c2, const TypePtr* at, Node *c3, Node *c4) :
  86       Node(c0,c1,c2,c3,c4),
  87       _unaligned_access(false),
  88       _mismatched_access(false),
  89       _unsafe_access(false),
  90       _barrier(0) {
  91     init_class_id(Class_Mem);
  92     debug_only(_adr_type=at; adr_type();)
  93   }
  94 
  95   virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*&amp; mem, bool can_see_stored_value) const { return NULL; }
  96   static bool check_if_adr_maybe_raw(Node* adr);
  97 
  98 public:
  99   // Helpers for the optimizer.  Documented in memnode.cpp.
 100   static bool detect_ptr_independence(Node* p1, AllocateNode* a1,
 101                                       Node* p2, AllocateNode* a2,
 102                                       PhaseTransform* phase);
 103   static bool adr_phi_is_loop_invariant(Node* adr_phi, Node* cast);
 104 
 105   static Node *optimize_simple_memory_chain(Node *mchain, const TypeOopPtr *t_oop, Node *load, PhaseGVN *phase);
 106   static Node *optimize_memory_chain(Node *mchain, const TypePtr *t_adr, Node *load, PhaseGVN *phase);
 107   // This one should probably be a phase-specific function:
 108   static bool all_controls_dominate(Node* dom, Node* sub);
 109 
 110   virtual const class TypePtr *adr_type() const;  // returns bottom_type of address
 111 
 112   // Shared code for Ideal methods:
 113   Node *Ideal_common(PhaseGVN *phase, bool can_reshape);  // Return -1 for short-circuit NULL.
 114 
 115   // Helper function for adr_type() implementations.
 116   static const TypePtr* calculate_adr_type(const Type* t, const TypePtr* cross_check = NULL);
 117 
 118   // Raw access function, to allow copying of adr_type efficiently in
 119   // product builds and retain the debug info for debug builds.
 120   const TypePtr *raw_adr_type() const {
 121 #ifdef ASSERT
 122     return _adr_type;
 123 #else
 124     return 0;
 125 #endif
 126   }
 127 
 128 #ifdef ASSERT
 129   void set_adr_type(const TypePtr* adr_type) { _adr_type = adr_type; }
 130 #endif
 131 
 132   // Map a load or store opcode to its corresponding store opcode.
 133   // (Return -1 if unknown.)
 134   virtual int store_Opcode() const { return -1; }
 135 
 136   // What is the type of the value in memory?  (T_VOID mean &quot;unspecified&quot;.)
 137   virtual BasicType memory_type() const = 0;
 138   virtual int memory_size() const {
 139 #ifdef ASSERT
 140     return type2aelembytes(memory_type(), true);
 141 #else
 142     return type2aelembytes(memory_type());
 143 #endif
 144   }
 145 
 146   uint8_t barrier_data() { return _barrier; }
 147   void set_barrier_data(uint8_t barrier_data) { _barrier = barrier_data; }
 148 
 149   // Search through memory states which precede this node (load or store).
 150   // Look for an exact match for the address, with no intervening
 151   // aliased stores.
 152   Node* find_previous_store(PhaseTransform* phase);
 153 
 154   // Can this node (load or store) accurately see a stored value in
 155   // the given memory state?  (The state may or may not be in(Memory).)
 156   Node* can_see_stored_value(Node* st, PhaseTransform* phase) const;
 157 
 158   void set_unaligned_access() { _unaligned_access = true; }
 159   bool is_unaligned_access() const { return _unaligned_access; }
 160   void set_mismatched_access() { _mismatched_access = true; }
 161   bool is_mismatched_access() const { return _mismatched_access; }
 162   void set_unsafe_access() { _unsafe_access = true; }
 163   bool is_unsafe_access() const { return _unsafe_access; }
 164 
 165 #ifndef PRODUCT
 166   static void dump_adr_type(const Node* mem, const TypePtr* adr_type, outputStream *st);
 167   virtual void dump_spec(outputStream *st) const;
 168 #endif
 169 };
 170 
 171 //------------------------------LoadNode---------------------------------------
 172 // Load value; requires Memory and Address
 173 class LoadNode : public MemNode {
 174 public:
 175   // Some loads (from unsafe) should be pinned: they don&#39;t depend only
 176   // on the dominating test.  The field _control_dependency below records
 177   // whether that node depends only on the dominating test.
 178   // Pinned and UnknownControl are similar, but differ in that Pinned
 179   // loads are not allowed to float across safepoints, whereas UnknownControl
 180   // loads are allowed to do that. Therefore, Pinned is stricter.
 181   enum ControlDependency {
 182     Pinned,
 183     UnknownControl,
 184     DependsOnlyOnTest
 185   };
 186 
 187 private:
 188   // LoadNode::hash() doesn&#39;t take the _control_dependency field
 189   // into account: If the graph already has a non-pinned LoadNode and
 190   // we add a pinned LoadNode with the same inputs, it&#39;s safe for GVN
 191   // to replace the pinned LoadNode with the non-pinned LoadNode,
 192   // otherwise it wouldn&#39;t be safe to have a non pinned LoadNode with
 193   // those inputs in the first place. If the graph already has a
 194   // pinned LoadNode and we add a non pinned LoadNode with the same
 195   // inputs, it&#39;s safe (but suboptimal) for GVN to replace the
 196   // non-pinned LoadNode by the pinned LoadNode.
 197   ControlDependency _control_dependency;
 198 
 199   // On platforms with weak memory ordering (e.g., PPC, Ia64) we distinguish
 200   // loads that can be reordered, and such requiring acquire semantics to
 201   // adhere to the Java specification.  The required behaviour is stored in
 202   // this field.
 203   const MemOrd _mo;
 204 
 205   AllocateNode* is_new_object_mark_load(PhaseGVN *phase) const;
 206 
 207 protected:
 208   virtual bool cmp(const Node &amp;n) const;
 209   virtual uint size_of() const; // Size is bigger
 210   // Should LoadNode::Ideal() attempt to remove control edges?
 211   virtual bool can_remove_control() const;
 212   const Type* const _type;      // What kind of value is loaded?
 213 
 214   virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*&amp; mem, bool can_see_stored_value) const;
 215 public:
 216 
 217   LoadNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const Type *rt, MemOrd mo, ControlDependency control_dependency)
 218     : MemNode(c,mem,adr,at), _control_dependency(control_dependency), _mo(mo), _type(rt) {
 219     init_class_id(Class_Load);
 220   }
 221   inline bool is_unordered() const { return !is_acquire(); }
 222   inline bool is_acquire() const {
 223     assert(_mo == unordered || _mo == acquire, &quot;unexpected&quot;);
 224     return _mo == acquire;
 225   }
 226   inline bool is_unsigned() const {
 227     int lop = Opcode();
 228     return (lop == Op_LoadUB) || (lop == Op_LoadUS);
 229   }
 230 
 231   // Polymorphic factory method:
 232   static Node* make(PhaseGVN&amp; gvn, Node *c, Node *mem, Node *adr,
 233                     const TypePtr* at, const Type *rt, BasicType bt,
 234                     MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,
 235                     bool unaligned = false, bool mismatched = false, bool unsafe = false,
 236                     uint8_t barrier_data = 0);
 237 
 238   virtual uint hash()   const;  // Check the type
 239 
 240   // Handle algebraic identities here.  If we have an identity, return the Node
 241   // we are equivalent to.  We look for Load of a Store.
 242   virtual Node* Identity(PhaseGVN* phase);
 243 
 244   // If the load is from Field memory and the pointer is non-null, it might be possible to
 245   // zero out the control input.
 246   // If the offset is constant and the base is an object allocation,
 247   // try to hook me up to the exact initializing store.
 248   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 249 
 250   // Split instance field load through Phi.
 251   Node* split_through_phi(PhaseGVN *phase);
 252 
 253   // Recover original value from boxed values
 254   Node *eliminate_autobox(PhaseGVN *phase);
 255 
 256   // Compute a new Type for this node.  Basically we just do the pre-check,
 257   // then call the virtual add() to set the type.
 258   virtual const Type* Value(PhaseGVN* phase) const;
 259 
 260   // Common methods for LoadKlass and LoadNKlass nodes.
 261   const Type* klass_value_common(PhaseGVN* phase) const;
 262   Node* klass_identity_common(PhaseGVN* phase);
 263 
 264   virtual uint ideal_reg() const;
 265   virtual const Type *bottom_type() const;
 266   // Following method is copied from TypeNode:
 267   void set_type(const Type* t) {
 268     assert(t != NULL, &quot;sanity&quot;);
 269     debug_only(uint check_hash = (VerifyHashTableKeys &amp;&amp; _hash_lock) ? hash() : NO_HASH);
 270     *(const Type**)&amp;_type = t;   // cast away const-ness
 271     // If this node is in the hash table, make sure it doesn&#39;t need a rehash.
 272     assert(check_hash == NO_HASH || check_hash == hash(), &quot;type change must preserve hash code&quot;);
 273   }
 274   const Type* type() const { assert(_type != NULL, &quot;sanity&quot;); return _type; };
 275 
 276   // Do not match memory edge
 277   virtual uint match_edge(uint idx) const;
 278 
 279   // Map a load opcode to its corresponding store opcode.
 280   virtual int store_Opcode() const = 0;
 281 
 282   // Check if the load&#39;s memory input is a Phi node with the same control.
 283   bool is_instance_field_load_with_local_phi(Node* ctrl);
 284 
 285   Node* convert_to_unsigned_load(PhaseGVN&amp; gvn);
 286   Node* convert_to_signed_load(PhaseGVN&amp; gvn);
 287 
 288   void pin() { _control_dependency = Pinned; }
 289   bool has_unknown_control_dependency() const { return _control_dependency == UnknownControl; }
 290 
 291 #ifndef PRODUCT
 292   virtual void dump_spec(outputStream *st) const;
 293 #endif
 294 #ifdef ASSERT
 295   // Helper function to allow a raw load without control edge for some cases
 296   static bool is_immutable_value(Node* adr);
 297 #endif
 298 protected:
 299   const Type* load_array_final_field(const TypeKlassPtr *tkls,
 300                                      ciKlass* klass) const;
 301 
 302   Node* can_see_arraycopy_value(Node* st, PhaseGVN* phase) const;
 303 
 304   // depends_only_on_test is almost always true, and needs to be almost always
 305   // true to enable key hoisting &amp; commoning optimizations.  However, for the
 306   // special case of RawPtr loads from TLS top &amp; end, and other loads performed by
 307   // GC barriers, the control edge carries the dependence preventing hoisting past
 308   // a Safepoint instead of the memory edge.  (An unfortunate consequence of having
 309   // Safepoints not set Raw Memory; itself an unfortunate consequence of having Nodes
 310   // which produce results (new raw memory state) inside of loops preventing all
 311   // manner of other optimizations).  Basically, it&#39;s ugly but so is the alternative.
 312   // See comment in macro.cpp, around line 125 expand_allocate_common().
 313   virtual bool depends_only_on_test() const {
 314     return adr_type() != TypeRawPtr::BOTTOM &amp;&amp; _control_dependency == DependsOnlyOnTest;
 315   }
 316 };
 317 
 318 //------------------------------LoadBNode--------------------------------------
 319 // Load a byte (8bits signed) from memory
 320 class LoadBNode : public LoadNode {
 321 public:
 322   LoadBNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeInt *ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 323     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 324   virtual int Opcode() const;
 325   virtual uint ideal_reg() const { return Op_RegI; }
 326   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 327   virtual const Type* Value(PhaseGVN* phase) const;
 328   virtual int store_Opcode() const { return Op_StoreB; }
 329   virtual BasicType memory_type() const { return T_BYTE; }
 330 };
 331 
 332 //------------------------------LoadUBNode-------------------------------------
 333 // Load a unsigned byte (8bits unsigned) from memory
 334 class LoadUBNode : public LoadNode {
 335 public:
 336   LoadUBNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeInt* ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 337     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 338   virtual int Opcode() const;
 339   virtual uint ideal_reg() const { return Op_RegI; }
 340   virtual Node* Ideal(PhaseGVN *phase, bool can_reshape);
 341   virtual const Type* Value(PhaseGVN* phase) const;
 342   virtual int store_Opcode() const { return Op_StoreB; }
 343   virtual BasicType memory_type() const { return T_BYTE; }
 344 };
 345 
 346 //------------------------------LoadUSNode-------------------------------------
 347 // Load an unsigned short/char (16bits unsigned) from memory
 348 class LoadUSNode : public LoadNode {
 349 public:
 350   LoadUSNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeInt *ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 351     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 352   virtual int Opcode() const;
 353   virtual uint ideal_reg() const { return Op_RegI; }
 354   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 355   virtual const Type* Value(PhaseGVN* phase) const;
 356   virtual int store_Opcode() const { return Op_StoreC; }
 357   virtual BasicType memory_type() const { return T_CHAR; }
 358 };
 359 
 360 //------------------------------LoadSNode--------------------------------------
 361 // Load a short (16bits signed) from memory
 362 class LoadSNode : public LoadNode {
 363 public:
 364   LoadSNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeInt *ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 365     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 366   virtual int Opcode() const;
 367   virtual uint ideal_reg() const { return Op_RegI; }
 368   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 369   virtual const Type* Value(PhaseGVN* phase) const;
 370   virtual int store_Opcode() const { return Op_StoreC; }
 371   virtual BasicType memory_type() const { return T_SHORT; }
 372 };
 373 
 374 //------------------------------LoadINode--------------------------------------
 375 // Load an integer from memory
 376 class LoadINode : public LoadNode {
 377 public:
 378   LoadINode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeInt *ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 379     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 380   virtual int Opcode() const;
 381   virtual uint ideal_reg() const { return Op_RegI; }
 382   virtual int store_Opcode() const { return Op_StoreI; }
 383   virtual BasicType memory_type() const { return T_INT; }
 384 };
 385 
 386 //------------------------------LoadRangeNode----------------------------------
 387 // Load an array length from the array
 388 class LoadRangeNode : public LoadINode {
 389 public:
 390   LoadRangeNode(Node *c, Node *mem, Node *adr, const TypeInt *ti = TypeInt::POS)
 391     : LoadINode(c, mem, adr, TypeAryPtr::RANGE, ti, MemNode::unordered) {}
 392   virtual int Opcode() const;
 393   virtual const Type* Value(PhaseGVN* phase) const;
 394   virtual Node* Identity(PhaseGVN* phase);
 395   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 396 };
 397 
 398 //------------------------------LoadLNode--------------------------------------
 399 // Load a long from memory
 400 class LoadLNode : public LoadNode {
 401   virtual uint hash() const { return LoadNode::hash() + _require_atomic_access; }
 402   virtual bool cmp( const Node &amp;n ) const {
 403     return _require_atomic_access == ((LoadLNode&amp;)n)._require_atomic_access
 404       &amp;&amp; LoadNode::cmp(n);
 405   }
 406   virtual uint size_of() const { return sizeof(*this); }
 407   const bool _require_atomic_access;  // is piecewise load forbidden?
 408 
 409 public:
 410   LoadLNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeLong *tl,
 411             MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest, bool require_atomic_access = false)
 412     : LoadNode(c, mem, adr, at, tl, mo, control_dependency), _require_atomic_access(require_atomic_access) {}
 413   virtual int Opcode() const;
 414   virtual uint ideal_reg() const { return Op_RegL; }
 415   virtual int store_Opcode() const { return Op_StoreL; }
 416   virtual BasicType memory_type() const { return T_LONG; }
 417   bool require_atomic_access() const { return _require_atomic_access; }
 418   static LoadLNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type,
 419                                 const Type* rt, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,
 420                                 bool unaligned = false, bool mismatched = false, bool unsafe = false, uint8_t barrier_data = 0);
 421 #ifndef PRODUCT
 422   virtual void dump_spec(outputStream *st) const {
 423     LoadNode::dump_spec(st);
 424     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 425   }
 426 #endif
 427 };
 428 
 429 //------------------------------LoadL_unalignedNode----------------------------
 430 // Load a long from unaligned memory
 431 class LoadL_unalignedNode : public LoadLNode {
 432 public:
 433   LoadL_unalignedNode(Node *c, Node *mem, Node *adr, const TypePtr* at, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 434     : LoadLNode(c, mem, adr, at, TypeLong::LONG, mo, control_dependency) {}
 435   virtual int Opcode() const;
 436 };
 437 
 438 //------------------------------LoadFNode--------------------------------------
 439 // Load a float (64 bits) from memory
 440 class LoadFNode : public LoadNode {
 441 public:
 442   LoadFNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const Type *t, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 443     : LoadNode(c, mem, adr, at, t, mo, control_dependency) {}
 444   virtual int Opcode() const;
 445   virtual uint ideal_reg() const { return Op_RegF; }
 446   virtual int store_Opcode() const { return Op_StoreF; }
 447   virtual BasicType memory_type() const { return T_FLOAT; }
 448 };
 449 
 450 //------------------------------LoadDNode--------------------------------------
 451 // Load a double (64 bits) from memory
 452 class LoadDNode : public LoadNode {
 453   virtual uint hash() const { return LoadNode::hash() + _require_atomic_access; }
 454   virtual bool cmp( const Node &amp;n ) const {
 455     return _require_atomic_access == ((LoadDNode&amp;)n)._require_atomic_access
 456       &amp;&amp; LoadNode::cmp(n);
 457   }
 458   virtual uint size_of() const { return sizeof(*this); }
 459   const bool _require_atomic_access;  // is piecewise load forbidden?
 460 
 461 public:
 462   LoadDNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const Type *t,
 463             MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest, bool require_atomic_access = false)
 464     : LoadNode(c, mem, adr, at, t, mo, control_dependency), _require_atomic_access(require_atomic_access) {}
 465   virtual int Opcode() const;
 466   virtual uint ideal_reg() const { return Op_RegD; }
 467   virtual int store_Opcode() const { return Op_StoreD; }
 468   virtual BasicType memory_type() const { return T_DOUBLE; }
 469   bool require_atomic_access() const { return _require_atomic_access; }
 470   static LoadDNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type,
 471                                 const Type* rt, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,
 472                                 bool unaligned = false, bool mismatched = false, bool unsafe = false, uint8_t barrier_data = 0);
 473 #ifndef PRODUCT
 474   virtual void dump_spec(outputStream *st) const {
 475     LoadNode::dump_spec(st);
 476     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 477   }
 478 #endif
 479 };
 480 
 481 //------------------------------LoadD_unalignedNode----------------------------
 482 // Load a double from unaligned memory
 483 class LoadD_unalignedNode : public LoadDNode {
 484 public:
 485   LoadD_unalignedNode(Node *c, Node *mem, Node *adr, const TypePtr* at, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 486     : LoadDNode(c, mem, adr, at, Type::DOUBLE, mo, control_dependency) {}
 487   virtual int Opcode() const;
 488 };
 489 
 490 //------------------------------LoadPNode--------------------------------------
 491 // Load a pointer from memory (either object or array)
 492 class LoadPNode : public LoadNode {
 493 public:
 494   LoadPNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypePtr* t, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 495     : LoadNode(c, mem, adr, at, t, mo, control_dependency) {}
 496   virtual int Opcode() const;
 497   virtual uint ideal_reg() const { return Op_RegP; }
 498   virtual int store_Opcode() const { return Op_StoreP; }
 499   virtual BasicType memory_type() const { return T_ADDRESS; }
 500 };
 501 
 502 
 503 //------------------------------LoadNNode--------------------------------------
 504 // Load a narrow oop from memory (either object or array)
 505 class LoadNNode : public LoadNode {
 506 public:
 507   LoadNNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const Type* t, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 508     : LoadNode(c, mem, adr, at, t, mo, control_dependency) {}
 509   virtual int Opcode() const;
 510   virtual uint ideal_reg() const { return Op_RegN; }
 511   virtual int store_Opcode() const { return Op_StoreN; }
 512   virtual BasicType memory_type() const { return T_NARROWOOP; }
 513 };
 514 
 515 //------------------------------LoadKlassNode----------------------------------
 516 // Load a Klass from an object
 517 class LoadKlassNode : public LoadPNode {
<a name="1" id="anc1"></a>

 518 protected:
 519   // In most cases, LoadKlassNode does not have the control input set. If the control
 520   // input is set, it must not be removed (by LoadNode::Ideal()).
 521   virtual bool can_remove_control() const;
 522 public:
<a name="2" id="anc2"></a><span class="line-modified"> 523   LoadKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeKlassPtr *tk, MemOrd mo)</span>
<span class="line-modified"> 524     : LoadPNode(c, mem, adr, at, tk, mo) {}</span>





 525   virtual int Opcode() const;
 526   virtual const Type* Value(PhaseGVN* phase) const;
 527   virtual Node* Identity(PhaseGVN* phase);
 528   virtual bool depends_only_on_test() const { return true; }
<a name="3" id="anc3"></a>
 529 
 530   // Polymorphic factory method:
 531   static Node* make(PhaseGVN&amp; gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at,
<a name="4" id="anc4"></a><span class="line-modified"> 532                     const TypeKlassPtr* tk = TypeKlassPtr::OBJECT);</span>
 533 };
 534 
 535 //------------------------------LoadNKlassNode---------------------------------
 536 // Load a narrow Klass from an object.
 537 class LoadNKlassNode : public LoadNNode {
<a name="5" id="anc5"></a>

 538 public:
<a name="6" id="anc6"></a><span class="line-modified"> 539   LoadNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeNarrowKlass *tk, MemOrd mo)</span>
<span class="line-modified"> 540     : LoadNNode(c, mem, adr, at, tk, mo) {}</span>





 541   virtual int Opcode() const;
 542   virtual uint ideal_reg() const { return Op_RegN; }
 543   virtual int store_Opcode() const { return Op_StoreNKlass; }
 544   virtual BasicType memory_type() const { return T_NARROWKLASS; }
 545 
 546   virtual const Type* Value(PhaseGVN* phase) const;
 547   virtual Node* Identity(PhaseGVN* phase);
 548   virtual bool depends_only_on_test() const { return true; }
<a name="7" id="anc7"></a>
 549 };
 550 
 551 //------------------------------StoreNode--------------------------------------
 552 // Store value; requires Store, Address and Value
 553 class StoreNode : public MemNode {
 554 private:
 555   // On platforms with weak memory ordering (e.g., PPC, Ia64) we distinguish
 556   // stores that can be reordered, and such requiring release semantics to
 557   // adhere to the Java specification.  The required behaviour is stored in
 558   // this field.
 559   const MemOrd _mo;
 560   // Needed for proper cloning.
 561   virtual uint size_of() const { return sizeof(*this); }
 562 protected:
 563   virtual bool cmp( const Node &amp;n ) const;
 564   virtual bool depends_only_on_test() const { return false; }
 565 
 566   Node *Ideal_masked_input       (PhaseGVN *phase, uint mask);
 567   Node *Ideal_sign_extended_input(PhaseGVN *phase, int  num_bits);
 568 
 569 public:
 570   // We must ensure that stores of object references will be visible
 571   // only after the object&#39;s initialization. So the callers of this
 572   // procedure must indicate that the store requires `release&#39;
 573   // semantics, if the stored value is an object reference that might
 574   // point to a new object and may become externally visible.
 575   StoreNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 576     : MemNode(c, mem, adr, at, val), _mo(mo) {
 577     init_class_id(Class_Store);
 578   }
 579   StoreNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, Node *oop_store, MemOrd mo)
 580     : MemNode(c, mem, adr, at, val, oop_store), _mo(mo) {
 581     init_class_id(Class_Store);
 582   }
 583 
 584   inline bool is_unordered() const { return !is_release(); }
 585   inline bool is_release() const {
 586     assert((_mo == unordered || _mo == release), &quot;unexpected&quot;);
 587     return _mo == release;
 588   }
 589 
 590   // Conservatively release stores of object references in order to
 591   // ensure visibility of object initialization.
 592   static inline MemOrd release_if_reference(const BasicType t) {
 593 #ifdef AARCH64
 594     // AArch64 doesn&#39;t need a release store here because object
 595     // initialization contains the necessary barriers.
 596     return unordered;
 597 #else
 598     const MemOrd mo = (t == T_ARRAY ||
 599                        t == T_ADDRESS || // Might be the address of an object reference (`boxing&#39;).
 600                        t == T_OBJECT) ? release : unordered;
 601     return mo;
 602 #endif
 603   }
 604 
 605   // Polymorphic factory method
 606   //
 607   // We must ensure that stores of object references will be visible
 608   // only after the object&#39;s initialization. So the callers of this
 609   // procedure must indicate that the store requires `release&#39;
 610   // semantics, if the stored value is an object reference that might
 611   // point to a new object and may become externally visible.
 612   static StoreNode* make(PhaseGVN&amp; gvn, Node *c, Node *mem, Node *adr,
 613                          const TypePtr* at, Node *val, BasicType bt, MemOrd mo);
 614 
 615   virtual uint hash() const;    // Check the type
 616 
 617   // If the store is to Field memory and the pointer is non-null, we can
 618   // zero out the control input.
 619   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 620 
 621   // Compute a new Type for this node.  Basically we just do the pre-check,
 622   // then call the virtual add() to set the type.
 623   virtual const Type* Value(PhaseGVN* phase) const;
 624 
 625   // Check for identity function on memory (Load then Store at same address)
 626   virtual Node* Identity(PhaseGVN* phase);
 627 
 628   // Do not match memory edge
 629   virtual uint match_edge(uint idx) const;
 630 
 631   virtual const Type *bottom_type() const;  // returns Type::MEMORY
 632 
 633   // Map a store opcode to its corresponding own opcode, trivially.
 634   virtual int store_Opcode() const { return Opcode(); }
 635 
 636   // have all possible loads of the value stored been optimized away?
 637   bool value_never_loaded(PhaseTransform *phase) const;
 638 
 639   MemBarNode* trailing_membar() const;
 640 };
 641 
 642 //------------------------------StoreBNode-------------------------------------
 643 // Store byte to memory
 644 class StoreBNode : public StoreNode {
 645 public:
 646   StoreBNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 647     : StoreNode(c, mem, adr, at, val, mo) {}
 648   virtual int Opcode() const;
 649   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 650   virtual BasicType memory_type() const { return T_BYTE; }
 651 };
 652 
 653 //------------------------------StoreCNode-------------------------------------
 654 // Store char/short to memory
 655 class StoreCNode : public StoreNode {
 656 public:
 657   StoreCNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 658     : StoreNode(c, mem, adr, at, val, mo) {}
 659   virtual int Opcode() const;
 660   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 661   virtual BasicType memory_type() const { return T_CHAR; }
 662 };
 663 
 664 //------------------------------StoreINode-------------------------------------
 665 // Store int to memory
 666 class StoreINode : public StoreNode {
 667 public:
 668   StoreINode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 669     : StoreNode(c, mem, adr, at, val, mo) {}
 670   virtual int Opcode() const;
 671   virtual BasicType memory_type() const { return T_INT; }
 672 };
 673 
 674 //------------------------------StoreLNode-------------------------------------
 675 // Store long to memory
 676 class StoreLNode : public StoreNode {
 677   virtual uint hash() const { return StoreNode::hash() + _require_atomic_access; }
 678   virtual bool cmp( const Node &amp;n ) const {
 679     return _require_atomic_access == ((StoreLNode&amp;)n)._require_atomic_access
 680       &amp;&amp; StoreNode::cmp(n);
 681   }
 682   virtual uint size_of() const { return sizeof(*this); }
 683   const bool _require_atomic_access;  // is piecewise store forbidden?
 684 
 685 public:
 686   StoreLNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo, bool require_atomic_access = false)
 687     : StoreNode(c, mem, adr, at, val, mo), _require_atomic_access(require_atomic_access) {}
 688   virtual int Opcode() const;
 689   virtual BasicType memory_type() const { return T_LONG; }
 690   bool require_atomic_access() const { return _require_atomic_access; }
 691   static StoreLNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo);
 692 #ifndef PRODUCT
 693   virtual void dump_spec(outputStream *st) const {
 694     StoreNode::dump_spec(st);
 695     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 696   }
 697 #endif
 698 };
 699 
 700 //------------------------------StoreFNode-------------------------------------
 701 // Store float to memory
 702 class StoreFNode : public StoreNode {
 703 public:
 704   StoreFNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 705     : StoreNode(c, mem, adr, at, val, mo) {}
 706   virtual int Opcode() const;
 707   virtual BasicType memory_type() const { return T_FLOAT; }
 708 };
 709 
 710 //------------------------------StoreDNode-------------------------------------
 711 // Store double to memory
 712 class StoreDNode : public StoreNode {
 713   virtual uint hash() const { return StoreNode::hash() + _require_atomic_access; }
 714   virtual bool cmp( const Node &amp;n ) const {
 715     return _require_atomic_access == ((StoreDNode&amp;)n)._require_atomic_access
 716       &amp;&amp; StoreNode::cmp(n);
 717   }
 718   virtual uint size_of() const { return sizeof(*this); }
 719   const bool _require_atomic_access;  // is piecewise store forbidden?
 720 public:
 721   StoreDNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val,
 722              MemOrd mo, bool require_atomic_access = false)
 723     : StoreNode(c, mem, adr, at, val, mo), _require_atomic_access(require_atomic_access) {}
 724   virtual int Opcode() const;
 725   virtual BasicType memory_type() const { return T_DOUBLE; }
 726   bool require_atomic_access() const { return _require_atomic_access; }
 727   static StoreDNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo);
 728 #ifndef PRODUCT
 729   virtual void dump_spec(outputStream *st) const {
 730     StoreNode::dump_spec(st);
 731     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 732   }
 733 #endif
 734 
 735 };
 736 
 737 //------------------------------StorePNode-------------------------------------
 738 // Store pointer to memory
 739 class StorePNode : public StoreNode {
 740 public:
 741   StorePNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 742     : StoreNode(c, mem, adr, at, val, mo) {}
 743   virtual int Opcode() const;
 744   virtual BasicType memory_type() const { return T_ADDRESS; }
 745 };
 746 
 747 //------------------------------StoreNNode-------------------------------------
 748 // Store narrow oop to memory
 749 class StoreNNode : public StoreNode {
 750 public:
 751   StoreNNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 752     : StoreNode(c, mem, adr, at, val, mo) {}
 753   virtual int Opcode() const;
 754   virtual BasicType memory_type() const { return T_NARROWOOP; }
 755 };
 756 
 757 //------------------------------StoreNKlassNode--------------------------------------
 758 // Store narrow klass to memory
 759 class StoreNKlassNode : public StoreNNode {
 760 public:
 761   StoreNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 762     : StoreNNode(c, mem, adr, at, val, mo) {}
 763   virtual int Opcode() const;
 764   virtual BasicType memory_type() const { return T_NARROWKLASS; }
 765 };
 766 
 767 //------------------------------StoreCMNode-----------------------------------
 768 // Store card-mark byte to memory for CM
 769 // The last StoreCM before a SafePoint must be preserved and occur after its &quot;oop&quot; store
 770 // Preceeding equivalent StoreCMs may be eliminated.
 771 class StoreCMNode : public StoreNode {
 772  private:
 773   virtual uint hash() const { return StoreNode::hash() + _oop_alias_idx; }
 774   virtual bool cmp( const Node &amp;n ) const {
 775     return _oop_alias_idx == ((StoreCMNode&amp;)n)._oop_alias_idx
 776       &amp;&amp; StoreNode::cmp(n);
 777   }
 778   virtual uint size_of() const { return sizeof(*this); }
 779   int _oop_alias_idx;   // The alias_idx of OopStore
 780 
 781 public:
 782   StoreCMNode( Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, Node *oop_store, int oop_alias_idx ) :
 783     StoreNode(c, mem, adr, at, val, oop_store, MemNode::release),
 784     _oop_alias_idx(oop_alias_idx) {
 785     assert(_oop_alias_idx &gt;= Compile::AliasIdxRaw ||
 786            _oop_alias_idx == Compile::AliasIdxBot &amp;&amp; Compile::current()-&gt;AliasLevel() == 0,
 787            &quot;bad oop alias idx&quot;);
 788   }
 789   virtual int Opcode() const;
 790   virtual Node* Identity(PhaseGVN* phase);
 791   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 792   virtual const Type* Value(PhaseGVN* phase) const;
 793   virtual BasicType memory_type() const { return T_VOID; } // unspecific
 794   int oop_alias_idx() const { return _oop_alias_idx; }
 795 };
 796 
 797 //------------------------------LoadPLockedNode---------------------------------
 798 // Load-locked a pointer from memory (either object or array).
 799 // On Sparc &amp; Intel this is implemented as a normal pointer load.
 800 // On PowerPC and friends it&#39;s a real load-locked.
 801 class LoadPLockedNode : public LoadPNode {
 802 public:
 803   LoadPLockedNode(Node *c, Node *mem, Node *adr, MemOrd mo)
 804     : LoadPNode(c, mem, adr, TypeRawPtr::BOTTOM, TypeRawPtr::BOTTOM, mo) {}
 805   virtual int Opcode() const;
 806   virtual int store_Opcode() const { return Op_StorePConditional; }
 807   virtual bool depends_only_on_test() const { return true; }
 808 };
 809 
 810 //------------------------------SCMemProjNode---------------------------------------
 811 // This class defines a projection of the memory  state of a store conditional node.
 812 // These nodes return a value, but also update memory.
 813 class SCMemProjNode : public ProjNode {
 814 public:
 815   enum {SCMEMPROJCON = (uint)-2};
 816   SCMemProjNode( Node *src) : ProjNode( src, SCMEMPROJCON) { }
 817   virtual int Opcode() const;
 818   virtual bool      is_CFG() const  { return false; }
 819   virtual const Type *bottom_type() const {return Type::MEMORY;}
 820   virtual const TypePtr *adr_type() const {
 821     Node* ctrl = in(0);
 822     if (ctrl == NULL)  return NULL; // node is dead
 823     return ctrl-&gt;in(MemNode::Memory)-&gt;adr_type();
 824   }
 825   virtual uint ideal_reg() const { return 0;} // memory projections don&#39;t have a register
 826   virtual const Type* Value(PhaseGVN* phase) const;
 827 #ifndef PRODUCT
 828   virtual void dump_spec(outputStream *st) const {};
 829 #endif
 830 };
 831 
 832 //------------------------------LoadStoreNode---------------------------
 833 // Note: is_Mem() method returns &#39;true&#39; for this class.
 834 class LoadStoreNode : public Node {
 835 private:
 836   const Type* const _type;      // What kind of value is loaded?
 837   const TypePtr* _adr_type;     // What kind of memory is being addressed?
 838   uint8_t _barrier; // Bit field with barrier information
 839   virtual uint size_of() const; // Size is bigger
 840 public:
 841   LoadStoreNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at, const Type* rt, uint required );
 842   virtual bool depends_only_on_test() const { return false; }
 843   virtual uint match_edge(uint idx) const { return idx == MemNode::Address || idx == MemNode::ValueIn; }
 844 
 845   virtual const Type *bottom_type() const { return _type; }
 846   virtual uint ideal_reg() const;
 847   virtual const class TypePtr *adr_type() const { return _adr_type; }  // returns bottom_type of address
 848 
 849   bool result_not_used() const;
 850   MemBarNode* trailing_membar() const;
 851 
 852   uint8_t barrier_data() { return _barrier; }
 853   void set_barrier_data(uint8_t barrier_data) { _barrier = barrier_data; }
 854 };
 855 
 856 class LoadStoreConditionalNode : public LoadStoreNode {
 857 public:
 858   enum {
 859     ExpectedIn = MemNode::ValueIn+1 // One more input than MemNode
 860   };
 861   LoadStoreConditionalNode(Node *c, Node *mem, Node *adr, Node *val, Node *ex);
 862 };
 863 
 864 //------------------------------StorePConditionalNode---------------------------
 865 // Conditionally store pointer to memory, if no change since prior
 866 // load-locked.  Sets flags for success or failure of the store.
 867 class StorePConditionalNode : public LoadStoreConditionalNode {
 868 public:
 869   StorePConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ll ) : LoadStoreConditionalNode(c, mem, adr, val, ll) { }
 870   virtual int Opcode() const;
 871   // Produces flags
 872   virtual uint ideal_reg() const { return Op_RegFlags; }
 873 };
 874 
 875 //------------------------------StoreIConditionalNode---------------------------
 876 // Conditionally store int to memory, if no change since prior
 877 // load-locked.  Sets flags for success or failure of the store.
 878 class StoreIConditionalNode : public LoadStoreConditionalNode {
 879 public:
 880   StoreIConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ii ) : LoadStoreConditionalNode(c, mem, adr, val, ii) { }
 881   virtual int Opcode() const;
 882   // Produces flags
 883   virtual uint ideal_reg() const { return Op_RegFlags; }
 884 };
 885 
 886 //------------------------------StoreLConditionalNode---------------------------
 887 // Conditionally store long to memory, if no change since prior
 888 // load-locked.  Sets flags for success or failure of the store.
 889 class StoreLConditionalNode : public LoadStoreConditionalNode {
 890 public:
 891   StoreLConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ll ) : LoadStoreConditionalNode(c, mem, adr, val, ll) { }
 892   virtual int Opcode() const;
 893   // Produces flags
 894   virtual uint ideal_reg() const { return Op_RegFlags; }
 895 };
 896 
 897 class CompareAndSwapNode : public LoadStoreConditionalNode {
 898 private:
 899   const MemNode::MemOrd _mem_ord;
 900 public:
 901   CompareAndSwapNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : LoadStoreConditionalNode(c, mem, adr, val, ex), _mem_ord(mem_ord) {}
 902   MemNode::MemOrd order() const {
 903     return _mem_ord;
 904   }
 905   virtual uint size_of() const { return sizeof(*this); }
 906 };
 907 
 908 class CompareAndExchangeNode : public LoadStoreNode {
 909 private:
 910   const MemNode::MemOrd _mem_ord;
 911 public:
 912   enum {
 913     ExpectedIn = MemNode::ValueIn+1 // One more input than MemNode
 914   };
 915   CompareAndExchangeNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord, const TypePtr* at, const Type* t) :
 916     LoadStoreNode(c, mem, adr, val, at, t, 5), _mem_ord(mem_ord) {
 917      init_req(ExpectedIn, ex );
 918   }
 919 
 920   MemNode::MemOrd order() const {
 921     return _mem_ord;
 922   }
 923   virtual uint size_of() const { return sizeof(*this); }
 924 };
 925 
 926 //------------------------------CompareAndSwapBNode---------------------------
 927 class CompareAndSwapBNode : public CompareAndSwapNode {
 928 public:
 929   CompareAndSwapBNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 930   virtual int Opcode() const;
 931 };
 932 
 933 //------------------------------CompareAndSwapSNode---------------------------
 934 class CompareAndSwapSNode : public CompareAndSwapNode {
 935 public:
 936   CompareAndSwapSNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 937   virtual int Opcode() const;
 938 };
 939 
 940 //------------------------------CompareAndSwapINode---------------------------
 941 class CompareAndSwapINode : public CompareAndSwapNode {
 942 public:
 943   CompareAndSwapINode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 944   virtual int Opcode() const;
 945 };
 946 
 947 //------------------------------CompareAndSwapLNode---------------------------
 948 class CompareAndSwapLNode : public CompareAndSwapNode {
 949 public:
 950   CompareAndSwapLNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 951   virtual int Opcode() const;
 952 };
 953 
 954 //------------------------------CompareAndSwapPNode---------------------------
 955 class CompareAndSwapPNode : public CompareAndSwapNode {
 956 public:
 957   CompareAndSwapPNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 958   virtual int Opcode() const;
 959 };
 960 
 961 //------------------------------CompareAndSwapNNode---------------------------
 962 class CompareAndSwapNNode : public CompareAndSwapNode {
 963 public:
 964   CompareAndSwapNNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 965   virtual int Opcode() const;
 966 };
 967 
 968 //------------------------------WeakCompareAndSwapBNode---------------------------
 969 class WeakCompareAndSwapBNode : public CompareAndSwapNode {
 970 public:
 971   WeakCompareAndSwapBNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 972   virtual int Opcode() const;
 973 };
 974 
 975 //------------------------------WeakCompareAndSwapSNode---------------------------
 976 class WeakCompareAndSwapSNode : public CompareAndSwapNode {
 977 public:
 978   WeakCompareAndSwapSNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 979   virtual int Opcode() const;
 980 };
 981 
 982 //------------------------------WeakCompareAndSwapINode---------------------------
 983 class WeakCompareAndSwapINode : public CompareAndSwapNode {
 984 public:
 985   WeakCompareAndSwapINode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 986   virtual int Opcode() const;
 987 };
 988 
 989 //------------------------------WeakCompareAndSwapLNode---------------------------
 990 class WeakCompareAndSwapLNode : public CompareAndSwapNode {
 991 public:
 992   WeakCompareAndSwapLNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 993   virtual int Opcode() const;
 994 };
 995 
 996 //------------------------------WeakCompareAndSwapPNode---------------------------
 997 class WeakCompareAndSwapPNode : public CompareAndSwapNode {
 998 public:
 999   WeakCompareAndSwapPNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
1000   virtual int Opcode() const;
1001 };
1002 
1003 //------------------------------WeakCompareAndSwapNNode---------------------------
1004 class WeakCompareAndSwapNNode : public CompareAndSwapNode {
1005 public:
1006   WeakCompareAndSwapNNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
1007   virtual int Opcode() const;
1008 };
1009 
1010 //------------------------------CompareAndExchangeBNode---------------------------
1011 class CompareAndExchangeBNode : public CompareAndExchangeNode {
1012 public:
1013   CompareAndExchangeBNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, TypeInt::BYTE) { }
1014   virtual int Opcode() const;
1015 };
1016 
1017 
1018 //------------------------------CompareAndExchangeSNode---------------------------
1019 class CompareAndExchangeSNode : public CompareAndExchangeNode {
1020 public:
1021   CompareAndExchangeSNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, TypeInt::SHORT) { }
1022   virtual int Opcode() const;
1023 };
1024 
1025 //------------------------------CompareAndExchangeLNode---------------------------
1026 class CompareAndExchangeLNode : public CompareAndExchangeNode {
1027 public:
1028   CompareAndExchangeLNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, TypeLong::LONG) { }
1029   virtual int Opcode() const;
1030 };
1031 
1032 
1033 //------------------------------CompareAndExchangeINode---------------------------
1034 class CompareAndExchangeINode : public CompareAndExchangeNode {
1035 public:
1036   CompareAndExchangeINode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, TypeInt::INT) { }
1037   virtual int Opcode() const;
1038 };
1039 
1040 
1041 //------------------------------CompareAndExchangePNode---------------------------
1042 class CompareAndExchangePNode : public CompareAndExchangeNode {
1043 public:
1044   CompareAndExchangePNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, const Type* t, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, t) { }
1045   virtual int Opcode() const;
1046 };
1047 
1048 //------------------------------CompareAndExchangeNNode---------------------------
1049 class CompareAndExchangeNNode : public CompareAndExchangeNode {
1050 public:
1051   CompareAndExchangeNNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, const Type* t, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, t) { }
1052   virtual int Opcode() const;
1053 };
1054 
1055 //------------------------------GetAndAddBNode---------------------------
1056 class GetAndAddBNode : public LoadStoreNode {
1057 public:
1058   GetAndAddBNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::BYTE, 4) { }
1059   virtual int Opcode() const;
1060 };
1061 
1062 //------------------------------GetAndAddSNode---------------------------
1063 class GetAndAddSNode : public LoadStoreNode {
1064 public:
1065   GetAndAddSNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::SHORT, 4) { }
1066   virtual int Opcode() const;
1067 };
1068 
1069 //------------------------------GetAndAddINode---------------------------
1070 class GetAndAddINode : public LoadStoreNode {
1071 public:
1072   GetAndAddINode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::INT, 4) { }
1073   virtual int Opcode() const;
1074 };
1075 
1076 //------------------------------GetAndAddLNode---------------------------
1077 class GetAndAddLNode : public LoadStoreNode {
1078 public:
1079   GetAndAddLNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeLong::LONG, 4) { }
1080   virtual int Opcode() const;
1081 };
1082 
1083 //------------------------------GetAndSetBNode---------------------------
1084 class GetAndSetBNode : public LoadStoreNode {
1085 public:
1086   GetAndSetBNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::BYTE, 4) { }
1087   virtual int Opcode() const;
1088 };
1089 
1090 //------------------------------GetAndSetSNode---------------------------
1091 class GetAndSetSNode : public LoadStoreNode {
1092 public:
1093   GetAndSetSNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::SHORT, 4) { }
1094   virtual int Opcode() const;
1095 };
1096 
1097 //------------------------------GetAndSetINode---------------------------
1098 class GetAndSetINode : public LoadStoreNode {
1099 public:
1100   GetAndSetINode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::INT, 4) { }
1101   virtual int Opcode() const;
1102 };
1103 
1104 //------------------------------GetAndSetLNode---------------------------
1105 class GetAndSetLNode : public LoadStoreNode {
1106 public:
1107   GetAndSetLNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeLong::LONG, 4) { }
1108   virtual int Opcode() const;
1109 };
1110 
1111 //------------------------------GetAndSetPNode---------------------------
1112 class GetAndSetPNode : public LoadStoreNode {
1113 public:
1114   GetAndSetPNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at, const Type* t ) : LoadStoreNode(c, mem, adr, val, at, t, 4) { }
1115   virtual int Opcode() const;
1116 };
1117 
1118 //------------------------------GetAndSetNNode---------------------------
1119 class GetAndSetNNode : public LoadStoreNode {
1120 public:
1121   GetAndSetNNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at, const Type* t ) : LoadStoreNode(c, mem, adr, val, at, t, 4) { }
1122   virtual int Opcode() const;
1123 };
1124 
1125 //------------------------------ClearArray-------------------------------------
1126 class ClearArrayNode: public Node {
1127 private:
1128   bool _is_large;
1129   bool _word_copy_only;
1130 public:
1131   ClearArrayNode( Node *ctrl, Node *arymem, Node *word_cnt, Node *base, Node* val, bool is_large)
1132     : Node(ctrl, arymem, word_cnt, base, val), _is_large(is_large),
1133       _word_copy_only(val-&gt;bottom_type()-&gt;isa_long() &amp;&amp; (!val-&gt;bottom_type()-&gt;is_long()-&gt;is_con() || val-&gt;bottom_type()-&gt;is_long()-&gt;get_con() != 0)) {
1134     init_class_id(Class_ClearArray);
1135   }
1136   virtual int         Opcode() const;
1137   virtual const Type *bottom_type() const { return Type::MEMORY; }
1138   // ClearArray modifies array elements, and so affects only the
1139   // array memory addressed by the bottom_type of its base address.
1140   virtual const class TypePtr *adr_type() const;
1141   virtual Node* Identity(PhaseGVN* phase);
1142   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1143   virtual uint match_edge(uint idx) const;
1144   bool is_large() const { return _is_large; }
1145   bool word_copy_only() const { return _word_copy_only; }
1146 
1147   // Clear the given area of an object or array.
1148   // The start offset must always be aligned mod BytesPerInt.
1149   // The end offset must always be aligned mod BytesPerLong.
1150   // Return the new memory.
1151   static Node* clear_memory(Node* control, Node* mem, Node* dest,
1152                             Node* val,
1153                             Node* raw_val,
1154                             intptr_t start_offset,
1155                             intptr_t end_offset,
1156                             PhaseGVN* phase);
1157   static Node* clear_memory(Node* control, Node* mem, Node* dest,
1158                             Node* val,
1159                             Node* raw_val,
1160                             intptr_t start_offset,
1161                             Node* end_offset,
1162                             PhaseGVN* phase);
1163   static Node* clear_memory(Node* control, Node* mem, Node* dest,
1164                             Node* raw_val,
1165                             Node* start_offset,
1166                             Node* end_offset,
1167                             PhaseGVN* phase);
1168   // Return allocation input memory edge if it is different instance
1169   // or itself if it is the one we are looking for.
1170   static bool step_through(Node** np, uint instance_id, PhaseTransform* phase);
1171 };
1172 
1173 //------------------------------MemBar-----------------------------------------
1174 // There are different flavors of Memory Barriers to match the Java Memory
1175 // Model.  Monitor-enter and volatile-load act as Aquires: no following ref
1176 // can be moved to before them.  We insert a MemBar-Acquire after a FastLock or
1177 // volatile-load.  Monitor-exit and volatile-store act as Release: no
1178 // preceding ref can be moved to after them.  We insert a MemBar-Release
1179 // before a FastUnlock or volatile-store.  All volatiles need to be
1180 // serialized, so we follow all volatile-stores with a MemBar-Volatile to
1181 // separate it from any following volatile-load.
1182 class MemBarNode: public MultiNode {
1183   virtual uint hash() const ;                  // { return NO_HASH; }
1184   virtual bool cmp( const Node &amp;n ) const ;    // Always fail, except on self
1185 
1186   virtual uint size_of() const { return sizeof(*this); }
1187   // Memory type this node is serializing.  Usually either rawptr or bottom.
1188   const TypePtr* _adr_type;
1189 
1190   // How is this membar related to a nearby memory access?
1191   enum {
1192     Standalone,
1193     TrailingLoad,
1194     TrailingStore,
1195     LeadingStore,
1196     TrailingLoadStore,
1197     LeadingLoadStore
1198   } _kind;
1199 
1200 #ifdef ASSERT
1201   uint _pair_idx;
1202 #endif
1203 
1204 public:
1205   enum {
1206     Precedent = TypeFunc::Parms  // optional edge to force precedence
1207   };
1208   MemBarNode(Compile* C, int alias_idx, Node* precedent);
1209   virtual int Opcode() const = 0;
1210   virtual const class TypePtr *adr_type() const { return _adr_type; }
1211   virtual const Type* Value(PhaseGVN* phase) const;
1212   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1213   virtual uint match_edge(uint idx) const { return 0; }
1214   virtual const Type *bottom_type() const { return TypeTuple::MEMBAR; }
1215   virtual Node *match(const ProjNode *proj, const Matcher *m, const RegMask* mask);
1216   // Factory method.  Builds a wide or narrow membar.
1217   // Optional &#39;precedent&#39; becomes an extra edge if not null.
1218   static MemBarNode* make(Compile* C, int opcode,
1219                           int alias_idx = Compile::AliasIdxBot,
1220                           Node* precedent = NULL);
1221 
1222   MemBarNode* trailing_membar() const;
1223   MemBarNode* leading_membar() const;
1224 
1225   void set_trailing_load() { _kind = TrailingLoad; }
1226   bool trailing_load() const { return _kind == TrailingLoad; }
1227   bool trailing_store() const { return _kind == TrailingStore; }
1228   bool leading_store() const { return _kind == LeadingStore; }
1229   bool trailing_load_store() const { return _kind == TrailingLoadStore; }
1230   bool leading_load_store() const { return _kind == LeadingLoadStore; }
1231   bool trailing() const { return _kind == TrailingLoad || _kind == TrailingStore || _kind == TrailingLoadStore; }
1232   bool leading() const { return _kind == LeadingStore || _kind == LeadingLoadStore; }
1233   bool standalone() const { return _kind == Standalone; }
1234 
1235   static void set_store_pair(MemBarNode* leading, MemBarNode* trailing);
1236   static void set_load_store_pair(MemBarNode* leading, MemBarNode* trailing);
1237 
1238   void remove(PhaseIterGVN *igvn);
1239 };
1240 
1241 // &quot;Acquire&quot; - no following ref can move before (but earlier refs can
1242 // follow, like an early Load stalled in cache).  Requires multi-cpu
1243 // visibility.  Inserted after a volatile load.
1244 class MemBarAcquireNode: public MemBarNode {
1245 public:
1246   MemBarAcquireNode(Compile* C, int alias_idx, Node* precedent)
1247     : MemBarNode(C, alias_idx, precedent) {}
1248   virtual int Opcode() const;
1249 };
1250 
1251 // &quot;Acquire&quot; - no following ref can move before (but earlier refs can
1252 // follow, like an early Load stalled in cache).  Requires multi-cpu
1253 // visibility.  Inserted independ of any load, as required
1254 // for intrinsic Unsafe.loadFence().
1255 class LoadFenceNode: public MemBarNode {
1256 public:
1257   LoadFenceNode(Compile* C, int alias_idx, Node* precedent)
1258     : MemBarNode(C, alias_idx, precedent) {}
1259   virtual int Opcode() const;
1260 };
1261 
1262 // &quot;Release&quot; - no earlier ref can move after (but later refs can move
1263 // up, like a speculative pipelined cache-hitting Load).  Requires
1264 // multi-cpu visibility.  Inserted before a volatile store.
1265 class MemBarReleaseNode: public MemBarNode {
1266 public:
1267   MemBarReleaseNode(Compile* C, int alias_idx, Node* precedent)
1268     : MemBarNode(C, alias_idx, precedent) {}
1269   virtual int Opcode() const;
1270 };
1271 
1272 // &quot;Release&quot; - no earlier ref can move after (but later refs can move
1273 // up, like a speculative pipelined cache-hitting Load).  Requires
1274 // multi-cpu visibility.  Inserted independent of any store, as required
1275 // for intrinsic Unsafe.storeFence().
1276 class StoreFenceNode: public MemBarNode {
1277 public:
1278   StoreFenceNode(Compile* C, int alias_idx, Node* precedent)
1279     : MemBarNode(C, alias_idx, precedent) {}
1280   virtual int Opcode() const;
1281 };
1282 
1283 // &quot;Acquire&quot; - no following ref can move before (but earlier refs can
1284 // follow, like an early Load stalled in cache).  Requires multi-cpu
1285 // visibility.  Inserted after a FastLock.
1286 class MemBarAcquireLockNode: public MemBarNode {
1287 public:
1288   MemBarAcquireLockNode(Compile* C, int alias_idx, Node* precedent)
1289     : MemBarNode(C, alias_idx, precedent) {}
1290   virtual int Opcode() const;
1291 };
1292 
1293 // &quot;Release&quot; - no earlier ref can move after (but later refs can move
1294 // up, like a speculative pipelined cache-hitting Load).  Requires
1295 // multi-cpu visibility.  Inserted before a FastUnLock.
1296 class MemBarReleaseLockNode: public MemBarNode {
1297 public:
1298   MemBarReleaseLockNode(Compile* C, int alias_idx, Node* precedent)
1299     : MemBarNode(C, alias_idx, precedent) {}
1300   virtual int Opcode() const;
1301 };
1302 
1303 class MemBarStoreStoreNode: public MemBarNode {
1304 public:
1305   MemBarStoreStoreNode(Compile* C, int alias_idx, Node* precedent)
1306     : MemBarNode(C, alias_idx, precedent) {
1307     init_class_id(Class_MemBarStoreStore);
1308   }
1309   virtual int Opcode() const;
1310 };
1311 
1312 // Ordering between a volatile store and a following volatile load.
1313 // Requires multi-CPU visibility?
1314 class MemBarVolatileNode: public MemBarNode {
1315 public:
1316   MemBarVolatileNode(Compile* C, int alias_idx, Node* precedent)
1317     : MemBarNode(C, alias_idx, precedent) {}
1318   virtual int Opcode() const;
1319 };
1320 
1321 // Ordering within the same CPU.  Used to order unsafe memory references
1322 // inside the compiler when we lack alias info.  Not needed &quot;outside&quot; the
1323 // compiler because the CPU does all the ordering for us.
1324 class MemBarCPUOrderNode: public MemBarNode {
1325 public:
1326   MemBarCPUOrderNode(Compile* C, int alias_idx, Node* precedent)
1327     : MemBarNode(C, alias_idx, precedent) {}
1328   virtual int Opcode() const;
1329   virtual uint ideal_reg() const { return 0; } // not matched in the AD file
1330 };
1331 
1332 class OnSpinWaitNode: public MemBarNode {
1333 public:
1334   OnSpinWaitNode(Compile* C, int alias_idx, Node* precedent)
1335     : MemBarNode(C, alias_idx, precedent) {}
1336   virtual int Opcode() const;
1337 };
1338 
1339 // Isolation of object setup after an AllocateNode and before next safepoint.
1340 // (See comment in memnode.cpp near InitializeNode::InitializeNode for semantics.)
1341 class InitializeNode: public MemBarNode {
1342   friend class AllocateNode;
1343 
1344   enum {
1345     Incomplete    = 0,
1346     Complete      = 1,
1347     WithArraycopy = 2
1348   };
1349   int _is_complete;
1350 
1351   bool _does_not_escape;
1352 
1353 public:
1354   enum {
1355     Control    = TypeFunc::Control,
1356     Memory     = TypeFunc::Memory,     // MergeMem for states affected by this op
1357     RawAddress = TypeFunc::Parms+0,    // the newly-allocated raw address
1358     RawStores  = TypeFunc::Parms+1     // zero or more stores (or TOP)
1359   };
1360 
1361   InitializeNode(Compile* C, int adr_type, Node* rawoop);
1362   virtual int Opcode() const;
1363   virtual uint size_of() const { return sizeof(*this); }
1364   virtual uint ideal_reg() const { return 0; } // not matched in the AD file
1365   virtual const RegMask &amp;in_RegMask(uint) const;  // mask for RawAddress
1366 
1367   // Manage incoming memory edges via a MergeMem on in(Memory):
1368   Node* memory(uint alias_idx);
1369 
1370   // The raw memory edge coming directly from the Allocation.
1371   // The contents of this memory are *always* all-zero-bits.
1372   Node* zero_memory() { return memory(Compile::AliasIdxRaw); }
1373 
1374   // Return the corresponding allocation for this initialization (or null if none).
1375   // (Note: Both InitializeNode::allocation and AllocateNode::initialization
1376   // are defined in graphKit.cpp, which sets up the bidirectional relation.)
1377   AllocateNode* allocation();
1378 
1379   // Anything other than zeroing in this init?
1380   bool is_non_zero();
1381 
1382   // An InitializeNode must completed before macro expansion is done.
1383   // Completion requires that the AllocateNode must be followed by
1384   // initialization of the new memory to zero, then to any initializers.
1385   bool is_complete() { return _is_complete != Incomplete; }
1386   bool is_complete_with_arraycopy() { return (_is_complete &amp; WithArraycopy) != 0; }
1387 
1388   // Mark complete.  (Must not yet be complete.)
1389   void set_complete(PhaseGVN* phase);
1390   void set_complete_with_arraycopy() { _is_complete = Complete | WithArraycopy; }
1391 
1392   bool does_not_escape() { return _does_not_escape; }
1393   void set_does_not_escape() { _does_not_escape = true; }
1394 
1395 #ifdef ASSERT
1396   // ensure all non-degenerate stores are ordered and non-overlapping
1397   bool stores_are_sane(PhaseTransform* phase);
1398 #endif //ASSERT
1399 
1400   // See if this store can be captured; return offset where it initializes.
1401   // Return 0 if the store cannot be moved (any sort of problem).
1402   intptr_t can_capture_store(StoreNode* st, PhaseGVN* phase, bool can_reshape);
1403 
1404   // Capture another store; reformat it to write my internal raw memory.
1405   // Return the captured copy, else NULL if there is some sort of problem.
1406   Node* capture_store(StoreNode* st, intptr_t start, PhaseGVN* phase, bool can_reshape);
1407 
1408   // Find captured store which corresponds to the range [start..start+size).
1409   // Return my own memory projection (meaning the initial zero bits)
1410   // if there is no such store.  Return NULL if there is a problem.
1411   Node* find_captured_store(intptr_t start, int size_in_bytes, PhaseTransform* phase);
1412 
1413   // Called when the associated AllocateNode is expanded into CFG.
1414   Node* complete_stores(Node* rawctl, Node* rawmem, Node* rawptr,
1415                         intptr_t header_size, Node* size_in_bytes,
1416                         PhaseIterGVN* phase);
1417 
1418  private:
1419   void remove_extra_zeroes();
1420 
1421   // Find out where a captured store should be placed (or already is placed).
1422   int captured_store_insertion_point(intptr_t start, int size_in_bytes,
1423                                      PhaseTransform* phase);
1424 
1425   static intptr_t get_store_offset(Node* st, PhaseTransform* phase);
1426 
1427   Node* make_raw_address(intptr_t offset, PhaseTransform* phase);
1428 
1429   bool detect_init_independence(Node* value, PhaseGVN* phase);
1430 
1431   void coalesce_subword_stores(intptr_t header_size, Node* size_in_bytes,
1432                                PhaseGVN* phase);
1433 
1434   intptr_t find_next_fullword_store(uint i, PhaseGVN* phase);
1435 };
1436 
1437 //------------------------------MergeMem---------------------------------------
1438 // (See comment in memnode.cpp near MergeMemNode::MergeMemNode for semantics.)
1439 class MergeMemNode: public Node {
1440   virtual uint hash() const ;                  // { return NO_HASH; }
1441   virtual bool cmp( const Node &amp;n ) const ;    // Always fail, except on self
1442   friend class MergeMemStream;
1443   MergeMemNode(Node* def);  // clients use MergeMemNode::make
1444 
1445 public:
1446   // If the input is a whole memory state, clone it with all its slices intact.
1447   // Otherwise, make a new memory state with just that base memory input.
1448   // In either case, the result is a newly created MergeMem.
1449   static MergeMemNode* make(Node* base_memory);
1450 
1451   virtual int Opcode() const;
1452   virtual Node* Identity(PhaseGVN* phase);
1453   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1454   virtual uint ideal_reg() const { return NotAMachineReg; }
1455   virtual uint match_edge(uint idx) const { return 0; }
1456   virtual const RegMask &amp;out_RegMask() const;
1457   virtual const Type *bottom_type() const { return Type::MEMORY; }
1458   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }
1459   // sparse accessors
1460   // Fetch the previously stored &quot;set_memory_at&quot;, or else the base memory.
1461   // (Caller should clone it if it is a phi-nest.)
1462   Node* memory_at(uint alias_idx) const;
1463   // set the memory, regardless of its previous value
1464   void set_memory_at(uint alias_idx, Node* n);
1465   // the &quot;base&quot; is the memory that provides the non-finite support
1466   Node* base_memory() const       { return in(Compile::AliasIdxBot); }
1467   // warning: setting the base can implicitly set any of the other slices too
1468   void set_base_memory(Node* def);
1469   // sentinel value which denotes a copy of the base memory:
1470   Node*   empty_memory() const    { return in(Compile::AliasIdxTop); }
1471   static Node* make_empty_memory(); // where the sentinel comes from
1472   bool is_empty_memory(Node* n) const { assert((n == empty_memory()) == n-&gt;is_top(), &quot;sanity&quot;); return n-&gt;is_top(); }
1473   // hook for the iterator, to perform any necessary setup
1474   void iteration_setup(const MergeMemNode* other = NULL);
1475   // push sentinels until I am at least as long as the other (semantic no-op)
1476   void grow_to_match(const MergeMemNode* other);
1477   bool verify_sparse() const PRODUCT_RETURN0;
1478 #ifndef PRODUCT
1479   virtual void dump_spec(outputStream *st) const;
1480 #endif
1481 };
1482 
1483 class MergeMemStream : public StackObj {
1484  private:
1485   MergeMemNode*       _mm;
1486   const MergeMemNode* _mm2;  // optional second guy, contributes non-empty iterations
1487   Node*               _mm_base;  // loop-invariant base memory of _mm
1488   int                 _idx;
1489   int                 _cnt;
1490   Node*               _mem;
1491   Node*               _mem2;
1492   int                 _cnt2;
1493 
1494   void init(MergeMemNode* mm, const MergeMemNode* mm2 = NULL) {
1495     // subsume_node will break sparseness at times, whenever a memory slice
1496     // folds down to a copy of the base (&quot;fat&quot;) memory.  In such a case,
1497     // the raw edge will update to base, although it should be top.
1498     // This iterator will recognize either top or base_memory as an
1499     // &quot;empty&quot; slice.  See is_empty, is_empty2, and next below.
1500     //
1501     // The sparseness property is repaired in MergeMemNode::Ideal.
1502     // As long as access to a MergeMem goes through this iterator
1503     // or the memory_at accessor, flaws in the sparseness will
1504     // never be observed.
1505     //
1506     // Also, iteration_setup repairs sparseness.
1507     assert(mm-&gt;verify_sparse(), &quot;please, no dups of base&quot;);
1508     assert(mm2==NULL || mm2-&gt;verify_sparse(), &quot;please, no dups of base&quot;);
1509 
1510     _mm  = mm;
1511     _mm_base = mm-&gt;base_memory();
1512     _mm2 = mm2;
1513     _cnt = mm-&gt;req();
1514     _idx = Compile::AliasIdxBot-1; // start at the base memory
1515     _mem = NULL;
1516     _mem2 = NULL;
1517   }
1518 
1519 #ifdef ASSERT
1520   Node* check_memory() const {
1521     if (at_base_memory())
1522       return _mm-&gt;base_memory();
1523     else if ((uint)_idx &lt; _mm-&gt;req() &amp;&amp; !_mm-&gt;in(_idx)-&gt;is_top())
1524       return _mm-&gt;memory_at(_idx);
1525     else
1526       return _mm_base;
1527   }
1528   Node* check_memory2() const {
1529     return at_base_memory()? _mm2-&gt;base_memory(): _mm2-&gt;memory_at(_idx);
1530   }
1531 #endif
1532 
1533   static bool match_memory(Node* mem, const MergeMemNode* mm, int idx) PRODUCT_RETURN0;
1534   void assert_synch() const {
1535     assert(!_mem || _idx &gt;= _cnt || match_memory(_mem, _mm, _idx),
1536            &quot;no side-effects except through the stream&quot;);
1537   }
1538 
1539  public:
1540 
1541   // expected usages:
1542   // for (MergeMemStream mms(mem-&gt;is_MergeMem()); next_non_empty(); ) { ... }
1543   // for (MergeMemStream mms(mem1, mem2); next_non_empty2(); ) { ... }
1544 
1545   // iterate over one merge
1546   MergeMemStream(MergeMemNode* mm) {
1547     mm-&gt;iteration_setup();
1548     init(mm);
1549     debug_only(_cnt2 = 999);
1550   }
1551   // iterate in parallel over two merges
1552   // only iterates through non-empty elements of mm2
1553   MergeMemStream(MergeMemNode* mm, const MergeMemNode* mm2) {
1554     assert(mm2, &quot;second argument must be a MergeMem also&quot;);
1555     ((MergeMemNode*)mm2)-&gt;iteration_setup();  // update hidden state
1556     mm-&gt;iteration_setup(mm2);
1557     init(mm, mm2);
1558     _cnt2 = mm2-&gt;req();
1559   }
1560 #ifdef ASSERT
1561   ~MergeMemStream() {
1562     assert_synch();
1563   }
1564 #endif
1565 
1566   MergeMemNode* all_memory() const {
1567     return _mm;
1568   }
1569   Node* base_memory() const {
1570     assert(_mm_base == _mm-&gt;base_memory(), &quot;no update to base memory, please&quot;);
1571     return _mm_base;
1572   }
1573   const MergeMemNode* all_memory2() const {
1574     assert(_mm2 != NULL, &quot;&quot;);
1575     return _mm2;
1576   }
1577   bool at_base_memory() const {
1578     return _idx == Compile::AliasIdxBot;
1579   }
1580   int alias_idx() const {
1581     assert(_mem, &quot;must call next 1st&quot;);
1582     return _idx;
1583   }
1584 
1585   const TypePtr* adr_type() const {
1586     return Compile::current()-&gt;get_adr_type(alias_idx());
1587   }
1588 
1589   const TypePtr* adr_type(Compile* C) const {
1590     return C-&gt;get_adr_type(alias_idx());
1591   }
1592   bool is_empty() const {
1593     assert(_mem, &quot;must call next 1st&quot;);
1594     assert(_mem-&gt;is_top() == (_mem==_mm-&gt;empty_memory()), &quot;correct sentinel&quot;);
1595     return _mem-&gt;is_top();
1596   }
1597   bool is_empty2() const {
1598     assert(_mem2, &quot;must call next 1st&quot;);
1599     assert(_mem2-&gt;is_top() == (_mem2==_mm2-&gt;empty_memory()), &quot;correct sentinel&quot;);
1600     return _mem2-&gt;is_top();
1601   }
1602   Node* memory() const {
1603     assert(!is_empty(), &quot;must not be empty&quot;);
1604     assert_synch();
1605     return _mem;
1606   }
1607   // get the current memory, regardless of empty or non-empty status
1608   Node* force_memory() const {
1609     assert(!is_empty() || !at_base_memory(), &quot;&quot;);
1610     // Use _mm_base to defend against updates to _mem-&gt;base_memory().
1611     Node *mem = _mem-&gt;is_top() ? _mm_base : _mem;
1612     assert(mem == check_memory(), &quot;&quot;);
1613     return mem;
1614   }
1615   Node* memory2() const {
1616     assert(_mem2 == check_memory2(), &quot;&quot;);
1617     return _mem2;
1618   }
1619   void set_memory(Node* mem) {
1620     if (at_base_memory()) {
1621       // Note that this does not change the invariant _mm_base.
1622       _mm-&gt;set_base_memory(mem);
1623     } else {
1624       _mm-&gt;set_memory_at(_idx, mem);
1625     }
1626     _mem = mem;
1627     assert_synch();
1628   }
1629 
1630   // Recover from a side effect to the MergeMemNode.
1631   void set_memory() {
1632     _mem = _mm-&gt;in(_idx);
1633   }
1634 
1635   bool next()  { return next(false); }
1636   bool next2() { return next(true); }
1637 
1638   bool next_non_empty()  { return next_non_empty(false); }
1639   bool next_non_empty2() { return next_non_empty(true); }
1640   // next_non_empty2 can yield states where is_empty() is true
1641 
1642  private:
1643   // find the next item, which might be empty
1644   bool next(bool have_mm2) {
1645     assert((_mm2 != NULL) == have_mm2, &quot;use other next&quot;);
1646     assert_synch();
1647     if (++_idx &lt; _cnt) {
1648       // Note:  This iterator allows _mm to be non-sparse.
1649       // It behaves the same whether _mem is top or base_memory.
1650       _mem = _mm-&gt;in(_idx);
1651       if (have_mm2)
1652         _mem2 = _mm2-&gt;in((_idx &lt; _cnt2) ? _idx : Compile::AliasIdxTop);
1653       return true;
1654     }
1655     return false;
1656   }
1657 
1658   // find the next non-empty item
1659   bool next_non_empty(bool have_mm2) {
1660     while (next(have_mm2)) {
1661       if (!is_empty()) {
1662         // make sure _mem2 is filled in sensibly
1663         if (have_mm2 &amp;&amp; _mem2-&gt;is_top())  _mem2 = _mm2-&gt;base_memory();
1664         return true;
1665       } else if (have_mm2 &amp;&amp; !is_empty2()) {
1666         return true;   // is_empty() == true
1667       }
1668     }
1669     return false;
1670   }
1671 };
1672 
1673 // cachewb node for guaranteeing writeback of the cache line at a
1674 // given address to (non-volatile) RAM
1675 class CacheWBNode : public Node {
1676 public:
1677   CacheWBNode(Node *ctrl, Node *mem, Node *addr) : Node(ctrl, mem, addr) {}
1678   virtual int Opcode() const;
1679   virtual uint ideal_reg() const { return NotAMachineReg; }
1680   virtual uint match_edge(uint idx) const { return (idx == 2); }
1681   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }
1682   virtual const Type *bottom_type() const { return Type::MEMORY; }
1683 };
1684 
1685 // cachewb pre sync node for ensuring that writebacks are serialised
1686 // relative to preceding or following stores
1687 class CacheWBPreSyncNode : public Node {
1688 public:
1689   CacheWBPreSyncNode(Node *ctrl, Node *mem) : Node(ctrl, mem) {}
1690   virtual int Opcode() const;
1691   virtual uint ideal_reg() const { return NotAMachineReg; }
1692   virtual uint match_edge(uint idx) const { return false; }
1693   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }
1694   virtual const Type *bottom_type() const { return Type::MEMORY; }
1695 };
1696 
1697 // cachewb pre sync node for ensuring that writebacks are serialised
1698 // relative to preceding or following stores
1699 class CacheWBPostSyncNode : public Node {
1700 public:
1701   CacheWBPostSyncNode(Node *ctrl, Node *mem) : Node(ctrl, mem) {}
1702   virtual int Opcode() const;
1703   virtual uint ideal_reg() const { return NotAMachineReg; }
1704   virtual uint match_edge(uint idx) const { return false; }
1705   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }
1706   virtual const Type *bottom_type() const { return Type::MEMORY; }
1707 };
1708 
1709 //------------------------------Prefetch---------------------------------------
1710 
1711 // Allocation prefetch which may fault, TLAB size have to be adjusted.
1712 class PrefetchAllocationNode : public Node {
1713 public:
1714   PrefetchAllocationNode(Node *mem, Node *adr) : Node(0,mem,adr) {}
1715   virtual int Opcode() const;
1716   virtual uint ideal_reg() const { return NotAMachineReg; }
1717   virtual uint match_edge(uint idx) const { return idx==2; }
1718   virtual const Type *bottom_type() const { return ( AllocatePrefetchStyle == 3 ) ? Type::MEMORY : Type::ABIO; }
1719 };
1720 
1721 #endif // SHARE_OPTO_MEMNODE_HPP
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/memnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="memnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse2.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/memnode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 498   virtual int store_Opcode() const { return Op_StoreP; }
 499   virtual BasicType memory_type() const { return T_ADDRESS; }
 500 };
 501 
 502 
 503 //------------------------------LoadNNode--------------------------------------
 504 // Load a narrow oop from memory (either object or array)
 505 class LoadNNode : public LoadNode {
 506 public:
 507   LoadNNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const Type* t, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 508     : LoadNode(c, mem, adr, at, t, mo, control_dependency) {}
 509   virtual int Opcode() const;
 510   virtual uint ideal_reg() const { return Op_RegN; }
 511   virtual int store_Opcode() const { return Op_StoreN; }
 512   virtual BasicType memory_type() const { return T_NARROWOOP; }
 513 };
 514 
 515 //------------------------------LoadKlassNode----------------------------------
 516 // Load a Klass from an object
 517 class LoadKlassNode : public LoadPNode {
<span class="line-removed"> 518 private:</span>
<span class="line-removed"> 519   bool _clear_prop_bits; // Clear the ArrayStorageProperties bits</span>
 520 protected:
 521   // In most cases, LoadKlassNode does not have the control input set. If the control
 522   // input is set, it must not be removed (by LoadNode::Ideal()).
 523   virtual bool can_remove_control() const;
 524 public:
<span class="line-modified"> 525   LoadKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeKlassPtr *tk, MemOrd mo, bool clear_prop_bits)</span>
<span class="line-modified"> 526     : LoadPNode(c, mem, adr, at, tk, mo), _clear_prop_bits(clear_prop_bits) {}</span>
<span class="line-removed"> 527   virtual uint hash() const { return LoadPNode::hash() + _clear_prop_bits; }</span>
<span class="line-removed"> 528   virtual bool cmp(const Node &amp;n) const {</span>
<span class="line-removed"> 529     return (_clear_prop_bits == ((LoadKlassNode&amp;)n)._clear_prop_bits) &amp;&amp; LoadPNode::cmp(n);</span>
<span class="line-removed"> 530   }</span>
<span class="line-removed"> 531   virtual uint size_of() const { return sizeof(*this); }</span>
 532   virtual int Opcode() const;
 533   virtual const Type* Value(PhaseGVN* phase) const;
 534   virtual Node* Identity(PhaseGVN* phase);
 535   virtual bool depends_only_on_test() const { return true; }
<span class="line-removed"> 536   bool clear_prop_bits() const { return _clear_prop_bits; }</span>
 537 
 538   // Polymorphic factory method:
 539   static Node* make(PhaseGVN&amp; gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at,
<span class="line-modified"> 540                     const TypeKlassPtr* tk = TypeKlassPtr::OBJECT, bool clear_prop_bits = false);</span>
 541 };
 542 
 543 //------------------------------LoadNKlassNode---------------------------------
 544 // Load a narrow Klass from an object.
 545 class LoadNKlassNode : public LoadNNode {
<span class="line-removed"> 546 private:</span>
<span class="line-removed"> 547   bool _clear_prop_bits; // Clear the ArrayStorageProperties bits</span>
 548 public:
<span class="line-modified"> 549   LoadNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeNarrowKlass *tk, MemOrd mo, bool clear_prop_bits)</span>
<span class="line-modified"> 550     : LoadNNode(c, mem, adr, at, tk, mo), _clear_prop_bits(clear_prop_bits) {}</span>
<span class="line-removed"> 551   virtual uint hash() const { return LoadNNode::hash() + _clear_prop_bits; }</span>
<span class="line-removed"> 552   virtual bool cmp(const Node &amp;n) const {</span>
<span class="line-removed"> 553     return (_clear_prop_bits == ((LoadNKlassNode&amp;)n)._clear_prop_bits) &amp;&amp; LoadNNode::cmp(n);</span>
<span class="line-removed"> 554   }</span>
<span class="line-removed"> 555   virtual uint size_of() const { return sizeof(*this); }</span>
 556   virtual int Opcode() const;
 557   virtual uint ideal_reg() const { return Op_RegN; }
 558   virtual int store_Opcode() const { return Op_StoreNKlass; }
 559   virtual BasicType memory_type() const { return T_NARROWKLASS; }
 560 
 561   virtual const Type* Value(PhaseGVN* phase) const;
 562   virtual Node* Identity(PhaseGVN* phase);
 563   virtual bool depends_only_on_test() const { return true; }
<span class="line-removed"> 564   bool clear_prop_bits() const { return _clear_prop_bits; }</span>
 565 };
 566 
 567 //------------------------------StoreNode--------------------------------------
 568 // Store value; requires Store, Address and Value
 569 class StoreNode : public MemNode {
 570 private:
 571   // On platforms with weak memory ordering (e.g., PPC, Ia64) we distinguish
 572   // stores that can be reordered, and such requiring release semantics to
 573   // adhere to the Java specification.  The required behaviour is stored in
 574   // this field.
 575   const MemOrd _mo;
 576   // Needed for proper cloning.
 577   virtual uint size_of() const { return sizeof(*this); }
 578 protected:
 579   virtual bool cmp( const Node &amp;n ) const;
 580   virtual bool depends_only_on_test() const { return false; }
 581 
 582   Node *Ideal_masked_input       (PhaseGVN *phase, uint mask);
 583   Node *Ideal_sign_extended_input(PhaseGVN *phase, int  num_bits);
 584 
</pre>
</td>
<td>
<hr />
<pre>
 498   virtual int store_Opcode() const { return Op_StoreP; }
 499   virtual BasicType memory_type() const { return T_ADDRESS; }
 500 };
 501 
 502 
 503 //------------------------------LoadNNode--------------------------------------
 504 // Load a narrow oop from memory (either object or array)
 505 class LoadNNode : public LoadNode {
 506 public:
 507   LoadNNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const Type* t, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 508     : LoadNode(c, mem, adr, at, t, mo, control_dependency) {}
 509   virtual int Opcode() const;
 510   virtual uint ideal_reg() const { return Op_RegN; }
 511   virtual int store_Opcode() const { return Op_StoreN; }
 512   virtual BasicType memory_type() const { return T_NARROWOOP; }
 513 };
 514 
 515 //------------------------------LoadKlassNode----------------------------------
 516 // Load a Klass from an object
 517 class LoadKlassNode : public LoadPNode {


 518 protected:
 519   // In most cases, LoadKlassNode does not have the control input set. If the control
 520   // input is set, it must not be removed (by LoadNode::Ideal()).
 521   virtual bool can_remove_control() const;
 522 public:
<span class="line-modified"> 523   LoadKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeKlassPtr *tk, MemOrd mo)</span>
<span class="line-modified"> 524     : LoadPNode(c, mem, adr, at, tk, mo) {}</span>





 525   virtual int Opcode() const;
 526   virtual const Type* Value(PhaseGVN* phase) const;
 527   virtual Node* Identity(PhaseGVN* phase);
 528   virtual bool depends_only_on_test() const { return true; }

 529 
 530   // Polymorphic factory method:
 531   static Node* make(PhaseGVN&amp; gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at,
<span class="line-modified"> 532                     const TypeKlassPtr* tk = TypeKlassPtr::OBJECT);</span>
 533 };
 534 
 535 //------------------------------LoadNKlassNode---------------------------------
 536 // Load a narrow Klass from an object.
 537 class LoadNKlassNode : public LoadNNode {


 538 public:
<span class="line-modified"> 539   LoadNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeNarrowKlass *tk, MemOrd mo)</span>
<span class="line-modified"> 540     : LoadNNode(c, mem, adr, at, tk, mo) {}</span>





 541   virtual int Opcode() const;
 542   virtual uint ideal_reg() const { return Op_RegN; }
 543   virtual int store_Opcode() const { return Op_StoreNKlass; }
 544   virtual BasicType memory_type() const { return T_NARROWKLASS; }
 545 
 546   virtual const Type* Value(PhaseGVN* phase) const;
 547   virtual Node* Identity(PhaseGVN* phase);
 548   virtual bool depends_only_on_test() const { return true; }

 549 };
 550 
 551 //------------------------------StoreNode--------------------------------------
 552 // Store value; requires Store, Address and Value
 553 class StoreNode : public MemNode {
 554 private:
 555   // On platforms with weak memory ordering (e.g., PPC, Ia64) we distinguish
 556   // stores that can be reordered, and such requiring release semantics to
 557   // adhere to the Java specification.  The required behaviour is stored in
 558   // this field.
 559   const MemOrd _mo;
 560   // Needed for proper cloning.
 561   virtual uint size_of() const { return sizeof(*this); }
 562 protected:
 563   virtual bool cmp( const Node &amp;n ) const;
 564   virtual bool depends_only_on_test() const { return false; }
 565 
 566   Node *Ideal_masked_input       (PhaseGVN *phase, uint mask);
 567   Node *Ideal_sign_extended_input(PhaseGVN *phase, int  num_bits);
 568 
</pre>
</td>
</tr>
</table>
<center><a href="memnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse2.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
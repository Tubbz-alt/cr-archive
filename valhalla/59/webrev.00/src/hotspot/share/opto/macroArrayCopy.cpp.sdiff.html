<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/macroArrayCopy.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macro.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memnode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/macroArrayCopy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 186   Node* is_notp = generate_guard(ctrl, bol_le, NULL, PROB_MIN);
 187 
 188   return is_notp;
 189 }
 190 
 191 Node* PhaseMacroExpand::generate_flattened_array_guard(Node** ctrl, Node* mem, Node* obj_or_klass, RegionNode* region) {
 192   assert(ValueArrayFlatten, &quot;can never be flattened&quot;);
 193   return generate_array_guard(ctrl, mem, obj_or_klass, region, Klass::_lh_array_tag_vt_value);
 194 }
 195 
 196 Node* PhaseMacroExpand::generate_object_array_guard(Node** ctrl, Node* mem, Node* obj_or_klass, RegionNode* region) {
 197   return generate_array_guard(ctrl, mem, obj_or_klass, region, Klass::_lh_array_tag_obj_value);
 198 }
 199 
 200 Node* PhaseMacroExpand::generate_array_guard(Node** ctrl, Node* mem, Node* obj_or_klass, RegionNode* region, jint lh_con) {
 201   if ((*ctrl)-&gt;is_top())  return NULL;
 202 
 203   Node* kls = NULL;
 204   if (_igvn.type(obj_or_klass)-&gt;isa_oopptr()) {
 205     Node* k_adr = basic_plus_adr(obj_or_klass, oopDesc::klass_offset_in_bytes());
<span class="line-modified"> 206     kls = transform_later(LoadKlassNode::make(_igvn, NULL, C-&gt;immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT, /* clear_prop_bits = */ true));</span>
 207   } else {
 208     assert(_igvn.type(obj_or_klass)-&gt;isa_klassptr(), &quot;what else?&quot;);
 209     kls = obj_or_klass;
 210   }
 211   Node* layout_val = make_load(NULL, mem, kls, in_bytes(Klass::layout_helper_offset()), TypeInt::INT, T_INT);
 212 
 213   layout_val = transform_later(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));
 214   Node* cmp = transform_later(new CmpINode(layout_val, intcon(lh_con)));
 215   Node* bol = transform_later(new BoolNode(cmp, BoolTest::eq));
 216 
 217   return generate_fair_guard(ctrl, bol, region);
 218 }
 219 
 220 void PhaseMacroExpand::finish_arraycopy_call(Node* call, Node** ctrl, MergeMemNode** mem, const TypePtr* adr_type) {
 221   transform_later(call);
 222 
 223   *ctrl = new ProjNode(call,TypeFunc::Control);
 224   transform_later(*ctrl);
 225   Node* newmem = new ProjNode(call, TypeFunc::Memory);
 226   transform_later(newmem);
</pre>
</td>
<td>
<hr />
<pre>
 186   Node* is_notp = generate_guard(ctrl, bol_le, NULL, PROB_MIN);
 187 
 188   return is_notp;
 189 }
 190 
 191 Node* PhaseMacroExpand::generate_flattened_array_guard(Node** ctrl, Node* mem, Node* obj_or_klass, RegionNode* region) {
 192   assert(ValueArrayFlatten, &quot;can never be flattened&quot;);
 193   return generate_array_guard(ctrl, mem, obj_or_klass, region, Klass::_lh_array_tag_vt_value);
 194 }
 195 
 196 Node* PhaseMacroExpand::generate_object_array_guard(Node** ctrl, Node* mem, Node* obj_or_klass, RegionNode* region) {
 197   return generate_array_guard(ctrl, mem, obj_or_klass, region, Klass::_lh_array_tag_obj_value);
 198 }
 199 
 200 Node* PhaseMacroExpand::generate_array_guard(Node** ctrl, Node* mem, Node* obj_or_klass, RegionNode* region, jint lh_con) {
 201   if ((*ctrl)-&gt;is_top())  return NULL;
 202 
 203   Node* kls = NULL;
 204   if (_igvn.type(obj_or_klass)-&gt;isa_oopptr()) {
 205     Node* k_adr = basic_plus_adr(obj_or_klass, oopDesc::klass_offset_in_bytes());
<span class="line-modified"> 206     kls = transform_later(LoadKlassNode::make(_igvn, NULL, C-&gt;immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));</span>
 207   } else {
 208     assert(_igvn.type(obj_or_klass)-&gt;isa_klassptr(), &quot;what else?&quot;);
 209     kls = obj_or_klass;
 210   }
 211   Node* layout_val = make_load(NULL, mem, kls, in_bytes(Klass::layout_helper_offset()), TypeInt::INT, T_INT);
 212 
 213   layout_val = transform_later(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));
 214   Node* cmp = transform_later(new CmpINode(layout_val, intcon(lh_con)));
 215   Node* bol = transform_later(new BoolNode(cmp, BoolTest::eq));
 216 
 217   return generate_fair_guard(ctrl, bol, region);
 218 }
 219 
 220 void PhaseMacroExpand::finish_arraycopy_call(Node* call, Node** ctrl, MergeMemNode** mem, const TypePtr* adr_type) {
 221   transform_later(call);
 222 
 223   *ctrl = new ProjNode(call,TypeFunc::Control);
 224   transform_later(*ctrl);
 225   Node* newmem = new ProjNode(call, TypeFunc::Memory);
 226   transform_later(newmem);
</pre>
</td>
</tr>
</table>
<center><a href="macro.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memnode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
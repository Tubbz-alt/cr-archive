<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/memnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_MEMNODE_HPP
  26 #define SHARE_OPTO_MEMNODE_HPP
  27 
  28 #include &quot;opto/multnode.hpp&quot;
  29 #include &quot;opto/node.hpp&quot;
  30 #include &quot;opto/opcodes.hpp&quot;
  31 #include &quot;opto/type.hpp&quot;
  32 
  33 // Portions of code courtesy of Clifford Click
  34 
  35 class MultiNode;
  36 class PhaseCCP;
  37 class PhaseTransform;
  38 
  39 //------------------------------MemNode----------------------------------------
  40 // Load or Store, possibly throwing a NULL pointer exception
  41 class MemNode : public Node {
  42 private:
  43   bool _unaligned_access; // Unaligned access from unsafe
  44   bool _mismatched_access; // Mismatched access from unsafe: byte read in integer array for instance
  45   bool _unsafe_access;     // Access of unsafe origin.
  46   uint8_t _barrier; // Bit field with barrier information
  47 
  48 protected:
  49 #ifdef ASSERT
  50   const TypePtr* _adr_type;     // What kind of memory is being addressed?
  51 #endif
  52   virtual uint size_of() const;
  53 public:
  54   enum { Control,               // When is it safe to do this load?
  55          Memory,                // Chunk of memory is being loaded from
  56          Address,               // Actually address, derived from base
  57          ValueIn,               // Value to store
  58          OopStore               // Preceeding oop store, only in StoreCM
  59   };
  60   typedef enum { unordered = 0,
  61                  acquire,       // Load has to acquire or be succeeded by MemBarAcquire.
  62                  release,       // Store has to release or be preceded by MemBarRelease.
  63                  seqcst,        // LoadStore has to have both acquire and release semantics.
  64                  unset          // The memory ordering is not set (used for testing)
  65   } MemOrd;
  66 protected:
  67   MemNode( Node *c0, Node *c1, Node *c2, const TypePtr* at ) :
  68       Node(c0,c1,c2),
  69       _unaligned_access(false),
  70       _mismatched_access(false),
  71       _unsafe_access(false),
  72       _barrier(0) {
  73     init_class_id(Class_Mem);
  74     debug_only(_adr_type=at; adr_type();)
  75   }
  76   MemNode( Node *c0, Node *c1, Node *c2, const TypePtr* at, Node *c3 ) :
  77       Node(c0,c1,c2,c3),
  78       _unaligned_access(false),
  79       _mismatched_access(false),
  80       _unsafe_access(false),
  81       _barrier(0) {
  82     init_class_id(Class_Mem);
  83     debug_only(_adr_type=at; adr_type();)
  84   }
  85   MemNode( Node *c0, Node *c1, Node *c2, const TypePtr* at, Node *c3, Node *c4) :
  86       Node(c0,c1,c2,c3,c4),
  87       _unaligned_access(false),
  88       _mismatched_access(false),
  89       _unsafe_access(false),
  90       _barrier(0) {
  91     init_class_id(Class_Mem);
  92     debug_only(_adr_type=at; adr_type();)
  93   }
  94 
  95   virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*&amp; mem, bool can_see_stored_value) const { return NULL; }
  96   static bool check_if_adr_maybe_raw(Node* adr);
  97 
  98 public:
  99   // Helpers for the optimizer.  Documented in memnode.cpp.
 100   static bool detect_ptr_independence(Node* p1, AllocateNode* a1,
 101                                       Node* p2, AllocateNode* a2,
 102                                       PhaseTransform* phase);
 103   static bool adr_phi_is_loop_invariant(Node* adr_phi, Node* cast);
 104 
 105   static Node *optimize_simple_memory_chain(Node *mchain, const TypeOopPtr *t_oop, Node *load, PhaseGVN *phase);
 106   static Node *optimize_memory_chain(Node *mchain, const TypePtr *t_adr, Node *load, PhaseGVN *phase);
 107   // This one should probably be a phase-specific function:
 108   static bool all_controls_dominate(Node* dom, Node* sub);
 109 
 110   virtual const class TypePtr *adr_type() const;  // returns bottom_type of address
 111 
 112   // Shared code for Ideal methods:
 113   Node *Ideal_common(PhaseGVN *phase, bool can_reshape);  // Return -1 for short-circuit NULL.
 114 
 115   // Helper function for adr_type() implementations.
 116   static const TypePtr* calculate_adr_type(const Type* t, const TypePtr* cross_check = NULL);
 117 
 118   // Raw access function, to allow copying of adr_type efficiently in
 119   // product builds and retain the debug info for debug builds.
 120   const TypePtr *raw_adr_type() const {
 121 #ifdef ASSERT
 122     return _adr_type;
 123 #else
 124     return 0;
 125 #endif
 126   }
 127 
 128 #ifdef ASSERT
 129   void set_adr_type(const TypePtr* adr_type) { _adr_type = adr_type; }
 130 #endif
 131 
 132   // Map a load or store opcode to its corresponding store opcode.
 133   // (Return -1 if unknown.)
 134   virtual int store_Opcode() const { return -1; }
 135 
 136   // What is the type of the value in memory?  (T_VOID mean &quot;unspecified&quot;.)
 137   virtual BasicType memory_type() const = 0;
 138   virtual int memory_size() const {
 139 #ifdef ASSERT
 140     return type2aelembytes(memory_type(), true);
 141 #else
 142     return type2aelembytes(memory_type());
 143 #endif
 144   }
 145 
 146   uint8_t barrier_data() { return _barrier; }
 147   void set_barrier_data(uint8_t barrier_data) { _barrier = barrier_data; }
 148 
 149   // Search through memory states which precede this node (load or store).
 150   // Look for an exact match for the address, with no intervening
 151   // aliased stores.
 152   Node* find_previous_store(PhaseTransform* phase);
 153 
 154   // Can this node (load or store) accurately see a stored value in
 155   // the given memory state?  (The state may or may not be in(Memory).)
 156   Node* can_see_stored_value(Node* st, PhaseTransform* phase) const;
 157 
 158   void set_unaligned_access() { _unaligned_access = true; }
 159   bool is_unaligned_access() const { return _unaligned_access; }
 160   void set_mismatched_access() { _mismatched_access = true; }
 161   bool is_mismatched_access() const { return _mismatched_access; }
 162   void set_unsafe_access() { _unsafe_access = true; }
 163   bool is_unsafe_access() const { return _unsafe_access; }
 164 
 165 #ifndef PRODUCT
 166   static void dump_adr_type(const Node* mem, const TypePtr* adr_type, outputStream *st);
 167   virtual void dump_spec(outputStream *st) const;
 168 #endif
 169 };
 170 
 171 //------------------------------LoadNode---------------------------------------
 172 // Load value; requires Memory and Address
 173 class LoadNode : public MemNode {
 174 public:
 175   // Some loads (from unsafe) should be pinned: they don&#39;t depend only
 176   // on the dominating test.  The field _control_dependency below records
 177   // whether that node depends only on the dominating test.
 178   // Pinned and UnknownControl are similar, but differ in that Pinned
 179   // loads are not allowed to float across safepoints, whereas UnknownControl
 180   // loads are allowed to do that. Therefore, Pinned is stricter.
 181   enum ControlDependency {
 182     Pinned,
 183     UnknownControl,
 184     DependsOnlyOnTest
 185   };
 186 
 187 private:
 188   // LoadNode::hash() doesn&#39;t take the _control_dependency field
 189   // into account: If the graph already has a non-pinned LoadNode and
 190   // we add a pinned LoadNode with the same inputs, it&#39;s safe for GVN
 191   // to replace the pinned LoadNode with the non-pinned LoadNode,
 192   // otherwise it wouldn&#39;t be safe to have a non pinned LoadNode with
 193   // those inputs in the first place. If the graph already has a
 194   // pinned LoadNode and we add a non pinned LoadNode with the same
 195   // inputs, it&#39;s safe (but suboptimal) for GVN to replace the
 196   // non-pinned LoadNode by the pinned LoadNode.
 197   ControlDependency _control_dependency;
 198 
 199   // On platforms with weak memory ordering (e.g., PPC, Ia64) we distinguish
 200   // loads that can be reordered, and such requiring acquire semantics to
 201   // adhere to the Java specification.  The required behaviour is stored in
 202   // this field.
 203   const MemOrd _mo;
 204 
 205   AllocateNode* is_new_object_mark_load(PhaseGVN *phase) const;
 206 
 207 protected:
 208   virtual bool cmp(const Node &amp;n) const;
 209   virtual uint size_of() const; // Size is bigger
 210   // Should LoadNode::Ideal() attempt to remove control edges?
 211   virtual bool can_remove_control() const;
 212   const Type* const _type;      // What kind of value is loaded?
 213 
 214   virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*&amp; mem, bool can_see_stored_value) const;
 215 public:
 216 
 217   LoadNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const Type *rt, MemOrd mo, ControlDependency control_dependency)
 218     : MemNode(c,mem,adr,at), _control_dependency(control_dependency), _mo(mo), _type(rt) {
 219     init_class_id(Class_Load);
 220   }
 221   inline bool is_unordered() const { return !is_acquire(); }
 222   inline bool is_acquire() const {
 223     assert(_mo == unordered || _mo == acquire, &quot;unexpected&quot;);
 224     return _mo == acquire;
 225   }
 226   inline bool is_unsigned() const {
 227     int lop = Opcode();
 228     return (lop == Op_LoadUB) || (lop == Op_LoadUS);
 229   }
 230 
 231   // Polymorphic factory method:
 232   static Node* make(PhaseGVN&amp; gvn, Node *c, Node *mem, Node *adr,
 233                     const TypePtr* at, const Type *rt, BasicType bt,
 234                     MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,
 235                     bool unaligned = false, bool mismatched = false, bool unsafe = false,
 236                     uint8_t barrier_data = 0);
 237 
 238   virtual uint hash()   const;  // Check the type
 239 
 240   // Handle algebraic identities here.  If we have an identity, return the Node
 241   // we are equivalent to.  We look for Load of a Store.
 242   virtual Node* Identity(PhaseGVN* phase);
 243 
 244   // If the load is from Field memory and the pointer is non-null, it might be possible to
 245   // zero out the control input.
 246   // If the offset is constant and the base is an object allocation,
 247   // try to hook me up to the exact initializing store.
 248   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 249 
 250   // Split instance field load through Phi.
 251   Node* split_through_phi(PhaseGVN *phase);
 252 
 253   // Recover original value from boxed values
 254   Node *eliminate_autobox(PhaseGVN *phase);
 255 
 256   // Compute a new Type for this node.  Basically we just do the pre-check,
 257   // then call the virtual add() to set the type.
 258   virtual const Type* Value(PhaseGVN* phase) const;
 259 
 260   // Common methods for LoadKlass and LoadNKlass nodes.
 261   const Type* klass_value_common(PhaseGVN* phase) const;
 262   Node* klass_identity_common(PhaseGVN* phase);
 263 
 264   virtual uint ideal_reg() const;
 265   virtual const Type *bottom_type() const;
 266   // Following method is copied from TypeNode:
 267   void set_type(const Type* t) {
 268     assert(t != NULL, &quot;sanity&quot;);
 269     debug_only(uint check_hash = (VerifyHashTableKeys &amp;&amp; _hash_lock) ? hash() : NO_HASH);
 270     *(const Type**)&amp;_type = t;   // cast away const-ness
 271     // If this node is in the hash table, make sure it doesn&#39;t need a rehash.
 272     assert(check_hash == NO_HASH || check_hash == hash(), &quot;type change must preserve hash code&quot;);
 273   }
 274   const Type* type() const { assert(_type != NULL, &quot;sanity&quot;); return _type; };
 275 
 276   // Do not match memory edge
 277   virtual uint match_edge(uint idx) const;
 278 
 279   // Map a load opcode to its corresponding store opcode.
 280   virtual int store_Opcode() const = 0;
 281 
 282   // Check if the load&#39;s memory input is a Phi node with the same control.
 283   bool is_instance_field_load_with_local_phi(Node* ctrl);
 284 
 285   Node* convert_to_unsigned_load(PhaseGVN&amp; gvn);
 286   Node* convert_to_signed_load(PhaseGVN&amp; gvn);
 287 
 288   void pin() { _control_dependency = Pinned; }
 289   bool has_unknown_control_dependency() const { return _control_dependency == UnknownControl; }
 290 
 291 #ifndef PRODUCT
 292   virtual void dump_spec(outputStream *st) const;
 293 #endif
 294 #ifdef ASSERT
 295   // Helper function to allow a raw load without control edge for some cases
 296   static bool is_immutable_value(Node* adr);
 297 #endif
 298 protected:
 299   const Type* load_array_final_field(const TypeKlassPtr *tkls,
 300                                      ciKlass* klass) const;
 301 
 302   Node* can_see_arraycopy_value(Node* st, PhaseGVN* phase) const;
 303 
 304   // depends_only_on_test is almost always true, and needs to be almost always
 305   // true to enable key hoisting &amp; commoning optimizations.  However, for the
 306   // special case of RawPtr loads from TLS top &amp; end, and other loads performed by
 307   // GC barriers, the control edge carries the dependence preventing hoisting past
 308   // a Safepoint instead of the memory edge.  (An unfortunate consequence of having
 309   // Safepoints not set Raw Memory; itself an unfortunate consequence of having Nodes
 310   // which produce results (new raw memory state) inside of loops preventing all
 311   // manner of other optimizations).  Basically, it&#39;s ugly but so is the alternative.
 312   // See comment in macro.cpp, around line 125 expand_allocate_common().
 313   virtual bool depends_only_on_test() const {
 314     return adr_type() != TypeRawPtr::BOTTOM &amp;&amp; _control_dependency == DependsOnlyOnTest;
 315   }
 316 };
 317 
 318 //------------------------------LoadBNode--------------------------------------
 319 // Load a byte (8bits signed) from memory
 320 class LoadBNode : public LoadNode {
 321 public:
 322   LoadBNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeInt *ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 323     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 324   virtual int Opcode() const;
 325   virtual uint ideal_reg() const { return Op_RegI; }
 326   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 327   virtual const Type* Value(PhaseGVN* phase) const;
 328   virtual int store_Opcode() const { return Op_StoreB; }
 329   virtual BasicType memory_type() const { return T_BYTE; }
 330 };
 331 
 332 //------------------------------LoadUBNode-------------------------------------
 333 // Load a unsigned byte (8bits unsigned) from memory
 334 class LoadUBNode : public LoadNode {
 335 public:
 336   LoadUBNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeInt* ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 337     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 338   virtual int Opcode() const;
 339   virtual uint ideal_reg() const { return Op_RegI; }
 340   virtual Node* Ideal(PhaseGVN *phase, bool can_reshape);
 341   virtual const Type* Value(PhaseGVN* phase) const;
 342   virtual int store_Opcode() const { return Op_StoreB; }
 343   virtual BasicType memory_type() const { return T_BYTE; }
 344 };
 345 
 346 //------------------------------LoadUSNode-------------------------------------
 347 // Load an unsigned short/char (16bits unsigned) from memory
 348 class LoadUSNode : public LoadNode {
 349 public:
 350   LoadUSNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeInt *ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 351     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 352   virtual int Opcode() const;
 353   virtual uint ideal_reg() const { return Op_RegI; }
 354   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 355   virtual const Type* Value(PhaseGVN* phase) const;
 356   virtual int store_Opcode() const { return Op_StoreC; }
 357   virtual BasicType memory_type() const { return T_CHAR; }
 358 };
 359 
 360 //------------------------------LoadSNode--------------------------------------
 361 // Load a short (16bits signed) from memory
 362 class LoadSNode : public LoadNode {
 363 public:
 364   LoadSNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeInt *ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 365     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 366   virtual int Opcode() const;
 367   virtual uint ideal_reg() const { return Op_RegI; }
 368   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 369   virtual const Type* Value(PhaseGVN* phase) const;
 370   virtual int store_Opcode() const { return Op_StoreC; }
 371   virtual BasicType memory_type() const { return T_SHORT; }
 372 };
 373 
 374 //------------------------------LoadINode--------------------------------------
 375 // Load an integer from memory
 376 class LoadINode : public LoadNode {
 377 public:
 378   LoadINode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeInt *ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 379     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 380   virtual int Opcode() const;
 381   virtual uint ideal_reg() const { return Op_RegI; }
 382   virtual int store_Opcode() const { return Op_StoreI; }
 383   virtual BasicType memory_type() const { return T_INT; }
 384 };
 385 
 386 //------------------------------LoadRangeNode----------------------------------
 387 // Load an array length from the array
 388 class LoadRangeNode : public LoadINode {
 389 public:
 390   LoadRangeNode(Node *c, Node *mem, Node *adr, const TypeInt *ti = TypeInt::POS)
 391     : LoadINode(c, mem, adr, TypeAryPtr::RANGE, ti, MemNode::unordered) {}
 392   virtual int Opcode() const;
 393   virtual const Type* Value(PhaseGVN* phase) const;
 394   virtual Node* Identity(PhaseGVN* phase);
 395   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 396 };
 397 
 398 //------------------------------LoadLNode--------------------------------------
 399 // Load a long from memory
 400 class LoadLNode : public LoadNode {
 401   virtual uint hash() const { return LoadNode::hash() + _require_atomic_access; }
 402   virtual bool cmp( const Node &amp;n ) const {
 403     return _require_atomic_access == ((LoadLNode&amp;)n)._require_atomic_access
 404       &amp;&amp; LoadNode::cmp(n);
 405   }
 406   virtual uint size_of() const { return sizeof(*this); }
 407   const bool _require_atomic_access;  // is piecewise load forbidden?
 408 
 409 public:
 410   LoadLNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeLong *tl,
 411             MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest, bool require_atomic_access = false)
 412     : LoadNode(c, mem, adr, at, tl, mo, control_dependency), _require_atomic_access(require_atomic_access) {}
 413   virtual int Opcode() const;
 414   virtual uint ideal_reg() const { return Op_RegL; }
 415   virtual int store_Opcode() const { return Op_StoreL; }
 416   virtual BasicType memory_type() const { return T_LONG; }
 417   bool require_atomic_access() const { return _require_atomic_access; }
 418   static LoadLNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type,
 419                                 const Type* rt, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,
 420                                 bool unaligned = false, bool mismatched = false, bool unsafe = false, uint8_t barrier_data = 0);
 421 #ifndef PRODUCT
 422   virtual void dump_spec(outputStream *st) const {
 423     LoadNode::dump_spec(st);
 424     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 425   }
 426 #endif
 427 };
 428 
 429 //------------------------------LoadL_unalignedNode----------------------------
 430 // Load a long from unaligned memory
 431 class LoadL_unalignedNode : public LoadLNode {
 432 public:
 433   LoadL_unalignedNode(Node *c, Node *mem, Node *adr, const TypePtr* at, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 434     : LoadLNode(c, mem, adr, at, TypeLong::LONG, mo, control_dependency) {}
 435   virtual int Opcode() const;
 436 };
 437 
 438 //------------------------------LoadFNode--------------------------------------
 439 // Load a float (64 bits) from memory
 440 class LoadFNode : public LoadNode {
 441 public:
 442   LoadFNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const Type *t, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 443     : LoadNode(c, mem, adr, at, t, mo, control_dependency) {}
 444   virtual int Opcode() const;
 445   virtual uint ideal_reg() const { return Op_RegF; }
 446   virtual int store_Opcode() const { return Op_StoreF; }
 447   virtual BasicType memory_type() const { return T_FLOAT; }
 448 };
 449 
 450 //------------------------------LoadDNode--------------------------------------
 451 // Load a double (64 bits) from memory
 452 class LoadDNode : public LoadNode {
 453   virtual uint hash() const { return LoadNode::hash() + _require_atomic_access; }
 454   virtual bool cmp( const Node &amp;n ) const {
 455     return _require_atomic_access == ((LoadDNode&amp;)n)._require_atomic_access
 456       &amp;&amp; LoadNode::cmp(n);
 457   }
 458   virtual uint size_of() const { return sizeof(*this); }
 459   const bool _require_atomic_access;  // is piecewise load forbidden?
 460 
 461 public:
 462   LoadDNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const Type *t,
 463             MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest, bool require_atomic_access = false)
 464     : LoadNode(c, mem, adr, at, t, mo, control_dependency), _require_atomic_access(require_atomic_access) {}
 465   virtual int Opcode() const;
 466   virtual uint ideal_reg() const { return Op_RegD; }
 467   virtual int store_Opcode() const { return Op_StoreD; }
 468   virtual BasicType memory_type() const { return T_DOUBLE; }
 469   bool require_atomic_access() const { return _require_atomic_access; }
 470   static LoadDNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type,
 471                                 const Type* rt, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,
 472                                 bool unaligned = false, bool mismatched = false, bool unsafe = false, uint8_t barrier_data = 0);
 473 #ifndef PRODUCT
 474   virtual void dump_spec(outputStream *st) const {
 475     LoadNode::dump_spec(st);
 476     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 477   }
 478 #endif
 479 };
 480 
 481 //------------------------------LoadD_unalignedNode----------------------------
 482 // Load a double from unaligned memory
 483 class LoadD_unalignedNode : public LoadDNode {
 484 public:
 485   LoadD_unalignedNode(Node *c, Node *mem, Node *adr, const TypePtr* at, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 486     : LoadDNode(c, mem, adr, at, Type::DOUBLE, mo, control_dependency) {}
 487   virtual int Opcode() const;
 488 };
 489 
 490 //------------------------------LoadPNode--------------------------------------
 491 // Load a pointer from memory (either object or array)
 492 class LoadPNode : public LoadNode {
 493 public:
 494   LoadPNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypePtr* t, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 495     : LoadNode(c, mem, adr, at, t, mo, control_dependency) {}
 496   virtual int Opcode() const;
 497   virtual uint ideal_reg() const { return Op_RegP; }
 498   virtual int store_Opcode() const { return Op_StoreP; }
 499   virtual BasicType memory_type() const { return T_ADDRESS; }
 500 };
 501 
 502 
 503 //------------------------------LoadNNode--------------------------------------
 504 // Load a narrow oop from memory (either object or array)
 505 class LoadNNode : public LoadNode {
 506 public:
 507   LoadNNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const Type* t, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 508     : LoadNode(c, mem, adr, at, t, mo, control_dependency) {}
 509   virtual int Opcode() const;
 510   virtual uint ideal_reg() const { return Op_RegN; }
 511   virtual int store_Opcode() const { return Op_StoreN; }
 512   virtual BasicType memory_type() const { return T_NARROWOOP; }
 513 };
 514 
 515 //------------------------------LoadKlassNode----------------------------------
 516 // Load a Klass from an object
 517 class LoadKlassNode : public LoadPNode {
<a name="1" id="anc1"></a><span class="line-removed"> 518 private:</span>
<span class="line-removed"> 519   bool _clear_prop_bits; // Clear the ArrayStorageProperties bits</span>
 520 protected:
 521   // In most cases, LoadKlassNode does not have the control input set. If the control
 522   // input is set, it must not be removed (by LoadNode::Ideal()).
 523   virtual bool can_remove_control() const;
 524 public:
<a name="2" id="anc2"></a><span class="line-modified"> 525   LoadKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeKlassPtr *tk, MemOrd mo, bool clear_prop_bits)</span>
<span class="line-modified"> 526     : LoadPNode(c, mem, adr, at, tk, mo), _clear_prop_bits(clear_prop_bits) {}</span>
<span class="line-removed"> 527   virtual uint hash() const { return LoadPNode::hash() + _clear_prop_bits; }</span>
<span class="line-removed"> 528   virtual bool cmp(const Node &amp;n) const {</span>
<span class="line-removed"> 529     return (_clear_prop_bits == ((LoadKlassNode&amp;)n)._clear_prop_bits) &amp;&amp; LoadPNode::cmp(n);</span>
<span class="line-removed"> 530   }</span>
<span class="line-removed"> 531   virtual uint size_of() const { return sizeof(*this); }</span>
 532   virtual int Opcode() const;
 533   virtual const Type* Value(PhaseGVN* phase) const;
 534   virtual Node* Identity(PhaseGVN* phase);
 535   virtual bool depends_only_on_test() const { return true; }
<a name="3" id="anc3"></a><span class="line-removed"> 536   bool clear_prop_bits() const { return _clear_prop_bits; }</span>
 537 
 538   // Polymorphic factory method:
 539   static Node* make(PhaseGVN&amp; gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at,
<a name="4" id="anc4"></a><span class="line-modified"> 540                     const TypeKlassPtr* tk = TypeKlassPtr::OBJECT, bool clear_prop_bits = false);</span>
 541 };
 542 
 543 //------------------------------LoadNKlassNode---------------------------------
 544 // Load a narrow Klass from an object.
 545 class LoadNKlassNode : public LoadNNode {
<a name="5" id="anc5"></a><span class="line-removed"> 546 private:</span>
<span class="line-removed"> 547   bool _clear_prop_bits; // Clear the ArrayStorageProperties bits</span>
 548 public:
<a name="6" id="anc6"></a><span class="line-modified"> 549   LoadNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeNarrowKlass *tk, MemOrd mo, bool clear_prop_bits)</span>
<span class="line-modified"> 550     : LoadNNode(c, mem, adr, at, tk, mo), _clear_prop_bits(clear_prop_bits) {}</span>
<span class="line-removed"> 551   virtual uint hash() const { return LoadNNode::hash() + _clear_prop_bits; }</span>
<span class="line-removed"> 552   virtual bool cmp(const Node &amp;n) const {</span>
<span class="line-removed"> 553     return (_clear_prop_bits == ((LoadNKlassNode&amp;)n)._clear_prop_bits) &amp;&amp; LoadNNode::cmp(n);</span>
<span class="line-removed"> 554   }</span>
<span class="line-removed"> 555   virtual uint size_of() const { return sizeof(*this); }</span>
 556   virtual int Opcode() const;
 557   virtual uint ideal_reg() const { return Op_RegN; }
 558   virtual int store_Opcode() const { return Op_StoreNKlass; }
 559   virtual BasicType memory_type() const { return T_NARROWKLASS; }
 560 
 561   virtual const Type* Value(PhaseGVN* phase) const;
 562   virtual Node* Identity(PhaseGVN* phase);
 563   virtual bool depends_only_on_test() const { return true; }
<a name="7" id="anc7"></a><span class="line-removed"> 564   bool clear_prop_bits() const { return _clear_prop_bits; }</span>
 565 };
 566 
 567 //------------------------------StoreNode--------------------------------------
 568 // Store value; requires Store, Address and Value
 569 class StoreNode : public MemNode {
 570 private:
 571   // On platforms with weak memory ordering (e.g., PPC, Ia64) we distinguish
 572   // stores that can be reordered, and such requiring release semantics to
 573   // adhere to the Java specification.  The required behaviour is stored in
 574   // this field.
 575   const MemOrd _mo;
 576   // Needed for proper cloning.
 577   virtual uint size_of() const { return sizeof(*this); }
 578 protected:
 579   virtual bool cmp( const Node &amp;n ) const;
 580   virtual bool depends_only_on_test() const { return false; }
 581 
 582   Node *Ideal_masked_input       (PhaseGVN *phase, uint mask);
 583   Node *Ideal_sign_extended_input(PhaseGVN *phase, int  num_bits);
 584 
 585 public:
 586   // We must ensure that stores of object references will be visible
 587   // only after the object&#39;s initialization. So the callers of this
 588   // procedure must indicate that the store requires `release&#39;
 589   // semantics, if the stored value is an object reference that might
 590   // point to a new object and may become externally visible.
 591   StoreNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 592     : MemNode(c, mem, adr, at, val), _mo(mo) {
 593     init_class_id(Class_Store);
 594   }
 595   StoreNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, Node *oop_store, MemOrd mo)
 596     : MemNode(c, mem, adr, at, val, oop_store), _mo(mo) {
 597     init_class_id(Class_Store);
 598   }
 599 
 600   inline bool is_unordered() const { return !is_release(); }
 601   inline bool is_release() const {
 602     assert((_mo == unordered || _mo == release), &quot;unexpected&quot;);
 603     return _mo == release;
 604   }
 605 
 606   // Conservatively release stores of object references in order to
 607   // ensure visibility of object initialization.
 608   static inline MemOrd release_if_reference(const BasicType t) {
 609 #ifdef AARCH64
 610     // AArch64 doesn&#39;t need a release store here because object
 611     // initialization contains the necessary barriers.
 612     return unordered;
 613 #else
 614     const MemOrd mo = (t == T_ARRAY ||
 615                        t == T_ADDRESS || // Might be the address of an object reference (`boxing&#39;).
 616                        t == T_OBJECT) ? release : unordered;
 617     return mo;
 618 #endif
 619   }
 620 
 621   // Polymorphic factory method
 622   //
 623   // We must ensure that stores of object references will be visible
 624   // only after the object&#39;s initialization. So the callers of this
 625   // procedure must indicate that the store requires `release&#39;
 626   // semantics, if the stored value is an object reference that might
 627   // point to a new object and may become externally visible.
 628   static StoreNode* make(PhaseGVN&amp; gvn, Node *c, Node *mem, Node *adr,
 629                          const TypePtr* at, Node *val, BasicType bt, MemOrd mo);
 630 
 631   virtual uint hash() const;    // Check the type
 632 
 633   // If the store is to Field memory and the pointer is non-null, we can
 634   // zero out the control input.
 635   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 636 
 637   // Compute a new Type for this node.  Basically we just do the pre-check,
 638   // then call the virtual add() to set the type.
 639   virtual const Type* Value(PhaseGVN* phase) const;
 640 
 641   // Check for identity function on memory (Load then Store at same address)
 642   virtual Node* Identity(PhaseGVN* phase);
 643 
 644   // Do not match memory edge
 645   virtual uint match_edge(uint idx) const;
 646 
 647   virtual const Type *bottom_type() const;  // returns Type::MEMORY
 648 
 649   // Map a store opcode to its corresponding own opcode, trivially.
 650   virtual int store_Opcode() const { return Opcode(); }
 651 
 652   // have all possible loads of the value stored been optimized away?
 653   bool value_never_loaded(PhaseTransform *phase) const;
 654 
 655   MemBarNode* trailing_membar() const;
 656 };
 657 
 658 //------------------------------StoreBNode-------------------------------------
 659 // Store byte to memory
 660 class StoreBNode : public StoreNode {
 661 public:
 662   StoreBNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 663     : StoreNode(c, mem, adr, at, val, mo) {}
 664   virtual int Opcode() const;
 665   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 666   virtual BasicType memory_type() const { return T_BYTE; }
 667 };
 668 
 669 //------------------------------StoreCNode-------------------------------------
 670 // Store char/short to memory
 671 class StoreCNode : public StoreNode {
 672 public:
 673   StoreCNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 674     : StoreNode(c, mem, adr, at, val, mo) {}
 675   virtual int Opcode() const;
 676   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 677   virtual BasicType memory_type() const { return T_CHAR; }
 678 };
 679 
 680 //------------------------------StoreINode-------------------------------------
 681 // Store int to memory
 682 class StoreINode : public StoreNode {
 683 public:
 684   StoreINode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 685     : StoreNode(c, mem, adr, at, val, mo) {}
 686   virtual int Opcode() const;
 687   virtual BasicType memory_type() const { return T_INT; }
 688 };
 689 
 690 //------------------------------StoreLNode-------------------------------------
 691 // Store long to memory
 692 class StoreLNode : public StoreNode {
 693   virtual uint hash() const { return StoreNode::hash() + _require_atomic_access; }
 694   virtual bool cmp( const Node &amp;n ) const {
 695     return _require_atomic_access == ((StoreLNode&amp;)n)._require_atomic_access
 696       &amp;&amp; StoreNode::cmp(n);
 697   }
 698   virtual uint size_of() const { return sizeof(*this); }
 699   const bool _require_atomic_access;  // is piecewise store forbidden?
 700 
 701 public:
 702   StoreLNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo, bool require_atomic_access = false)
 703     : StoreNode(c, mem, adr, at, val, mo), _require_atomic_access(require_atomic_access) {}
 704   virtual int Opcode() const;
 705   virtual BasicType memory_type() const { return T_LONG; }
 706   bool require_atomic_access() const { return _require_atomic_access; }
 707   static StoreLNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo);
 708 #ifndef PRODUCT
 709   virtual void dump_spec(outputStream *st) const {
 710     StoreNode::dump_spec(st);
 711     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 712   }
 713 #endif
 714 };
 715 
 716 //------------------------------StoreFNode-------------------------------------
 717 // Store float to memory
 718 class StoreFNode : public StoreNode {
 719 public:
 720   StoreFNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 721     : StoreNode(c, mem, adr, at, val, mo) {}
 722   virtual int Opcode() const;
 723   virtual BasicType memory_type() const { return T_FLOAT; }
 724 };
 725 
 726 //------------------------------StoreDNode-------------------------------------
 727 // Store double to memory
 728 class StoreDNode : public StoreNode {
 729   virtual uint hash() const { return StoreNode::hash() + _require_atomic_access; }
 730   virtual bool cmp( const Node &amp;n ) const {
 731     return _require_atomic_access == ((StoreDNode&amp;)n)._require_atomic_access
 732       &amp;&amp; StoreNode::cmp(n);
 733   }
 734   virtual uint size_of() const { return sizeof(*this); }
 735   const bool _require_atomic_access;  // is piecewise store forbidden?
 736 public:
 737   StoreDNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val,
 738              MemOrd mo, bool require_atomic_access = false)
 739     : StoreNode(c, mem, adr, at, val, mo), _require_atomic_access(require_atomic_access) {}
 740   virtual int Opcode() const;
 741   virtual BasicType memory_type() const { return T_DOUBLE; }
 742   bool require_atomic_access() const { return _require_atomic_access; }
 743   static StoreDNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo);
 744 #ifndef PRODUCT
 745   virtual void dump_spec(outputStream *st) const {
 746     StoreNode::dump_spec(st);
 747     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 748   }
 749 #endif
 750 
 751 };
 752 
 753 //------------------------------StorePNode-------------------------------------
 754 // Store pointer to memory
 755 class StorePNode : public StoreNode {
 756 public:
 757   StorePNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 758     : StoreNode(c, mem, adr, at, val, mo) {}
 759   virtual int Opcode() const;
 760   virtual BasicType memory_type() const { return T_ADDRESS; }
 761 };
 762 
 763 //------------------------------StoreNNode-------------------------------------
 764 // Store narrow oop to memory
 765 class StoreNNode : public StoreNode {
 766 public:
 767   StoreNNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 768     : StoreNode(c, mem, adr, at, val, mo) {}
 769   virtual int Opcode() const;
 770   virtual BasicType memory_type() const { return T_NARROWOOP; }
 771 };
 772 
 773 //------------------------------StoreNKlassNode--------------------------------------
 774 // Store narrow klass to memory
 775 class StoreNKlassNode : public StoreNNode {
 776 public:
 777   StoreNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 778     : StoreNNode(c, mem, adr, at, val, mo) {}
 779   virtual int Opcode() const;
 780   virtual BasicType memory_type() const { return T_NARROWKLASS; }
 781 };
 782 
 783 //------------------------------StoreCMNode-----------------------------------
 784 // Store card-mark byte to memory for CM
 785 // The last StoreCM before a SafePoint must be preserved and occur after its &quot;oop&quot; store
 786 // Preceeding equivalent StoreCMs may be eliminated.
 787 class StoreCMNode : public StoreNode {
 788  private:
 789   virtual uint hash() const { return StoreNode::hash() + _oop_alias_idx; }
 790   virtual bool cmp( const Node &amp;n ) const {
 791     return _oop_alias_idx == ((StoreCMNode&amp;)n)._oop_alias_idx
 792       &amp;&amp; StoreNode::cmp(n);
 793   }
 794   virtual uint size_of() const { return sizeof(*this); }
 795   int _oop_alias_idx;   // The alias_idx of OopStore
 796 
 797 public:
 798   StoreCMNode( Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, Node *oop_store, int oop_alias_idx ) :
 799     StoreNode(c, mem, adr, at, val, oop_store, MemNode::release),
 800     _oop_alias_idx(oop_alias_idx) {
 801     assert(_oop_alias_idx &gt;= Compile::AliasIdxRaw ||
 802            _oop_alias_idx == Compile::AliasIdxBot &amp;&amp; Compile::current()-&gt;AliasLevel() == 0,
 803            &quot;bad oop alias idx&quot;);
 804   }
 805   virtual int Opcode() const;
 806   virtual Node* Identity(PhaseGVN* phase);
 807   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 808   virtual const Type* Value(PhaseGVN* phase) const;
 809   virtual BasicType memory_type() const { return T_VOID; } // unspecific
 810   int oop_alias_idx() const { return _oop_alias_idx; }
 811 };
 812 
 813 //------------------------------LoadPLockedNode---------------------------------
 814 // Load-locked a pointer from memory (either object or array).
 815 // On Sparc &amp; Intel this is implemented as a normal pointer load.
 816 // On PowerPC and friends it&#39;s a real load-locked.
 817 class LoadPLockedNode : public LoadPNode {
 818 public:
 819   LoadPLockedNode(Node *c, Node *mem, Node *adr, MemOrd mo)
 820     : LoadPNode(c, mem, adr, TypeRawPtr::BOTTOM, TypeRawPtr::BOTTOM, mo) {}
 821   virtual int Opcode() const;
 822   virtual int store_Opcode() const { return Op_StorePConditional; }
 823   virtual bool depends_only_on_test() const { return true; }
 824 };
 825 
 826 //------------------------------SCMemProjNode---------------------------------------
 827 // This class defines a projection of the memory  state of a store conditional node.
 828 // These nodes return a value, but also update memory.
 829 class SCMemProjNode : public ProjNode {
 830 public:
 831   enum {SCMEMPROJCON = (uint)-2};
 832   SCMemProjNode( Node *src) : ProjNode( src, SCMEMPROJCON) { }
 833   virtual int Opcode() const;
 834   virtual bool      is_CFG() const  { return false; }
 835   virtual const Type *bottom_type() const {return Type::MEMORY;}
 836   virtual const TypePtr *adr_type() const {
 837     Node* ctrl = in(0);
 838     if (ctrl == NULL)  return NULL; // node is dead
 839     return ctrl-&gt;in(MemNode::Memory)-&gt;adr_type();
 840   }
 841   virtual uint ideal_reg() const { return 0;} // memory projections don&#39;t have a register
 842   virtual const Type* Value(PhaseGVN* phase) const;
 843 #ifndef PRODUCT
 844   virtual void dump_spec(outputStream *st) const {};
 845 #endif
 846 };
 847 
 848 //------------------------------LoadStoreNode---------------------------
 849 // Note: is_Mem() method returns &#39;true&#39; for this class.
 850 class LoadStoreNode : public Node {
 851 private:
 852   const Type* const _type;      // What kind of value is loaded?
 853   const TypePtr* _adr_type;     // What kind of memory is being addressed?
 854   uint8_t _barrier; // Bit field with barrier information
 855   virtual uint size_of() const; // Size is bigger
 856 public:
 857   LoadStoreNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at, const Type* rt, uint required );
 858   virtual bool depends_only_on_test() const { return false; }
 859   virtual uint match_edge(uint idx) const { return idx == MemNode::Address || idx == MemNode::ValueIn; }
 860 
 861   virtual const Type *bottom_type() const { return _type; }
 862   virtual uint ideal_reg() const;
 863   virtual const class TypePtr *adr_type() const { return _adr_type; }  // returns bottom_type of address
 864 
 865   bool result_not_used() const;
 866   MemBarNode* trailing_membar() const;
 867 
 868   uint8_t barrier_data() { return _barrier; }
 869   void set_barrier_data(uint8_t barrier_data) { _barrier = barrier_data; }
 870 };
 871 
 872 class LoadStoreConditionalNode : public LoadStoreNode {
 873 public:
 874   enum {
 875     ExpectedIn = MemNode::ValueIn+1 // One more input than MemNode
 876   };
 877   LoadStoreConditionalNode(Node *c, Node *mem, Node *adr, Node *val, Node *ex);
 878 };
 879 
 880 //------------------------------StorePConditionalNode---------------------------
 881 // Conditionally store pointer to memory, if no change since prior
 882 // load-locked.  Sets flags for success or failure of the store.
 883 class StorePConditionalNode : public LoadStoreConditionalNode {
 884 public:
 885   StorePConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ll ) : LoadStoreConditionalNode(c, mem, adr, val, ll) { }
 886   virtual int Opcode() const;
 887   // Produces flags
 888   virtual uint ideal_reg() const { return Op_RegFlags; }
 889 };
 890 
 891 //------------------------------StoreIConditionalNode---------------------------
 892 // Conditionally store int to memory, if no change since prior
 893 // load-locked.  Sets flags for success or failure of the store.
 894 class StoreIConditionalNode : public LoadStoreConditionalNode {
 895 public:
 896   StoreIConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ii ) : LoadStoreConditionalNode(c, mem, adr, val, ii) { }
 897   virtual int Opcode() const;
 898   // Produces flags
 899   virtual uint ideal_reg() const { return Op_RegFlags; }
 900 };
 901 
 902 //------------------------------StoreLConditionalNode---------------------------
 903 // Conditionally store long to memory, if no change since prior
 904 // load-locked.  Sets flags for success or failure of the store.
 905 class StoreLConditionalNode : public LoadStoreConditionalNode {
 906 public:
 907   StoreLConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ll ) : LoadStoreConditionalNode(c, mem, adr, val, ll) { }
 908   virtual int Opcode() const;
 909   // Produces flags
 910   virtual uint ideal_reg() const { return Op_RegFlags; }
 911 };
 912 
 913 class CompareAndSwapNode : public LoadStoreConditionalNode {
 914 private:
 915   const MemNode::MemOrd _mem_ord;
 916 public:
 917   CompareAndSwapNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : LoadStoreConditionalNode(c, mem, adr, val, ex), _mem_ord(mem_ord) {}
 918   MemNode::MemOrd order() const {
 919     return _mem_ord;
 920   }
 921   virtual uint size_of() const { return sizeof(*this); }
 922 };
 923 
 924 class CompareAndExchangeNode : public LoadStoreNode {
 925 private:
 926   const MemNode::MemOrd _mem_ord;
 927 public:
 928   enum {
 929     ExpectedIn = MemNode::ValueIn+1 // One more input than MemNode
 930   };
 931   CompareAndExchangeNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord, const TypePtr* at, const Type* t) :
 932     LoadStoreNode(c, mem, adr, val, at, t, 5), _mem_ord(mem_ord) {
 933      init_req(ExpectedIn, ex );
 934   }
 935 
 936   MemNode::MemOrd order() const {
 937     return _mem_ord;
 938   }
 939   virtual uint size_of() const { return sizeof(*this); }
 940 };
 941 
 942 //------------------------------CompareAndSwapBNode---------------------------
 943 class CompareAndSwapBNode : public CompareAndSwapNode {
 944 public:
 945   CompareAndSwapBNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 946   virtual int Opcode() const;
 947 };
 948 
 949 //------------------------------CompareAndSwapSNode---------------------------
 950 class CompareAndSwapSNode : public CompareAndSwapNode {
 951 public:
 952   CompareAndSwapSNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 953   virtual int Opcode() const;
 954 };
 955 
 956 //------------------------------CompareAndSwapINode---------------------------
 957 class CompareAndSwapINode : public CompareAndSwapNode {
 958 public:
 959   CompareAndSwapINode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 960   virtual int Opcode() const;
 961 };
 962 
 963 //------------------------------CompareAndSwapLNode---------------------------
 964 class CompareAndSwapLNode : public CompareAndSwapNode {
 965 public:
 966   CompareAndSwapLNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 967   virtual int Opcode() const;
 968 };
 969 
 970 //------------------------------CompareAndSwapPNode---------------------------
 971 class CompareAndSwapPNode : public CompareAndSwapNode {
 972 public:
 973   CompareAndSwapPNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 974   virtual int Opcode() const;
 975 };
 976 
 977 //------------------------------CompareAndSwapNNode---------------------------
 978 class CompareAndSwapNNode : public CompareAndSwapNode {
 979 public:
 980   CompareAndSwapNNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 981   virtual int Opcode() const;
 982 };
 983 
 984 //------------------------------WeakCompareAndSwapBNode---------------------------
 985 class WeakCompareAndSwapBNode : public CompareAndSwapNode {
 986 public:
 987   WeakCompareAndSwapBNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 988   virtual int Opcode() const;
 989 };
 990 
 991 //------------------------------WeakCompareAndSwapSNode---------------------------
 992 class WeakCompareAndSwapSNode : public CompareAndSwapNode {
 993 public:
 994   WeakCompareAndSwapSNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 995   virtual int Opcode() const;
 996 };
 997 
 998 //------------------------------WeakCompareAndSwapINode---------------------------
 999 class WeakCompareAndSwapINode : public CompareAndSwapNode {
1000 public:
1001   WeakCompareAndSwapINode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
1002   virtual int Opcode() const;
1003 };
1004 
1005 //------------------------------WeakCompareAndSwapLNode---------------------------
1006 class WeakCompareAndSwapLNode : public CompareAndSwapNode {
1007 public:
1008   WeakCompareAndSwapLNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
1009   virtual int Opcode() const;
1010 };
1011 
1012 //------------------------------WeakCompareAndSwapPNode---------------------------
1013 class WeakCompareAndSwapPNode : public CompareAndSwapNode {
1014 public:
1015   WeakCompareAndSwapPNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
1016   virtual int Opcode() const;
1017 };
1018 
1019 //------------------------------WeakCompareAndSwapNNode---------------------------
1020 class WeakCompareAndSwapNNode : public CompareAndSwapNode {
1021 public:
1022   WeakCompareAndSwapNNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
1023   virtual int Opcode() const;
1024 };
1025 
1026 //------------------------------CompareAndExchangeBNode---------------------------
1027 class CompareAndExchangeBNode : public CompareAndExchangeNode {
1028 public:
1029   CompareAndExchangeBNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, TypeInt::BYTE) { }
1030   virtual int Opcode() const;
1031 };
1032 
1033 
1034 //------------------------------CompareAndExchangeSNode---------------------------
1035 class CompareAndExchangeSNode : public CompareAndExchangeNode {
1036 public:
1037   CompareAndExchangeSNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, TypeInt::SHORT) { }
1038   virtual int Opcode() const;
1039 };
1040 
1041 //------------------------------CompareAndExchangeLNode---------------------------
1042 class CompareAndExchangeLNode : public CompareAndExchangeNode {
1043 public:
1044   CompareAndExchangeLNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, TypeLong::LONG) { }
1045   virtual int Opcode() const;
1046 };
1047 
1048 
1049 //------------------------------CompareAndExchangeINode---------------------------
1050 class CompareAndExchangeINode : public CompareAndExchangeNode {
1051 public:
1052   CompareAndExchangeINode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, TypeInt::INT) { }
1053   virtual int Opcode() const;
1054 };
1055 
1056 
1057 //------------------------------CompareAndExchangePNode---------------------------
1058 class CompareAndExchangePNode : public CompareAndExchangeNode {
1059 public:
1060   CompareAndExchangePNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, const Type* t, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, t) { }
1061   virtual int Opcode() const;
1062 };
1063 
1064 //------------------------------CompareAndExchangeNNode---------------------------
1065 class CompareAndExchangeNNode : public CompareAndExchangeNode {
1066 public:
1067   CompareAndExchangeNNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, const Type* t, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, t) { }
1068   virtual int Opcode() const;
1069 };
1070 
1071 //------------------------------GetAndAddBNode---------------------------
1072 class GetAndAddBNode : public LoadStoreNode {
1073 public:
1074   GetAndAddBNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::BYTE, 4) { }
1075   virtual int Opcode() const;
1076 };
1077 
1078 //------------------------------GetAndAddSNode---------------------------
1079 class GetAndAddSNode : public LoadStoreNode {
1080 public:
1081   GetAndAddSNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::SHORT, 4) { }
1082   virtual int Opcode() const;
1083 };
1084 
1085 //------------------------------GetAndAddINode---------------------------
1086 class GetAndAddINode : public LoadStoreNode {
1087 public:
1088   GetAndAddINode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::INT, 4) { }
1089   virtual int Opcode() const;
1090 };
1091 
1092 //------------------------------GetAndAddLNode---------------------------
1093 class GetAndAddLNode : public LoadStoreNode {
1094 public:
1095   GetAndAddLNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeLong::LONG, 4) { }
1096   virtual int Opcode() const;
1097 };
1098 
1099 //------------------------------GetAndSetBNode---------------------------
1100 class GetAndSetBNode : public LoadStoreNode {
1101 public:
1102   GetAndSetBNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::BYTE, 4) { }
1103   virtual int Opcode() const;
1104 };
1105 
1106 //------------------------------GetAndSetSNode---------------------------
1107 class GetAndSetSNode : public LoadStoreNode {
1108 public:
1109   GetAndSetSNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::SHORT, 4) { }
1110   virtual int Opcode() const;
1111 };
1112 
1113 //------------------------------GetAndSetINode---------------------------
1114 class GetAndSetINode : public LoadStoreNode {
1115 public:
1116   GetAndSetINode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::INT, 4) { }
1117   virtual int Opcode() const;
1118 };
1119 
1120 //------------------------------GetAndSetLNode---------------------------
1121 class GetAndSetLNode : public LoadStoreNode {
1122 public:
1123   GetAndSetLNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeLong::LONG, 4) { }
1124   virtual int Opcode() const;
1125 };
1126 
1127 //------------------------------GetAndSetPNode---------------------------
1128 class GetAndSetPNode : public LoadStoreNode {
1129 public:
1130   GetAndSetPNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at, const Type* t ) : LoadStoreNode(c, mem, adr, val, at, t, 4) { }
1131   virtual int Opcode() const;
1132 };
1133 
1134 //------------------------------GetAndSetNNode---------------------------
1135 class GetAndSetNNode : public LoadStoreNode {
1136 public:
1137   GetAndSetNNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at, const Type* t ) : LoadStoreNode(c, mem, adr, val, at, t, 4) { }
1138   virtual int Opcode() const;
1139 };
1140 
1141 //------------------------------ClearArray-------------------------------------
1142 class ClearArrayNode: public Node {
1143 private:
1144   bool _is_large;
1145   bool _word_copy_only;
1146 public:
1147   ClearArrayNode( Node *ctrl, Node *arymem, Node *word_cnt, Node *base, Node* val, bool is_large)
1148     : Node(ctrl, arymem, word_cnt, base, val), _is_large(is_large),
1149       _word_copy_only(val-&gt;bottom_type()-&gt;isa_long() &amp;&amp; (!val-&gt;bottom_type()-&gt;is_long()-&gt;is_con() || val-&gt;bottom_type()-&gt;is_long()-&gt;get_con() != 0)) {
1150     init_class_id(Class_ClearArray);
1151   }
1152   virtual int         Opcode() const;
1153   virtual const Type *bottom_type() const { return Type::MEMORY; }
1154   // ClearArray modifies array elements, and so affects only the
1155   // array memory addressed by the bottom_type of its base address.
1156   virtual const class TypePtr *adr_type() const;
1157   virtual Node* Identity(PhaseGVN* phase);
1158   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1159   virtual uint match_edge(uint idx) const;
1160   bool is_large() const { return _is_large; }
1161   bool word_copy_only() const { return _word_copy_only; }
1162 
1163   // Clear the given area of an object or array.
1164   // The start offset must always be aligned mod BytesPerInt.
1165   // The end offset must always be aligned mod BytesPerLong.
1166   // Return the new memory.
1167   static Node* clear_memory(Node* control, Node* mem, Node* dest,
1168                             Node* val,
1169                             Node* raw_val,
1170                             intptr_t start_offset,
1171                             intptr_t end_offset,
1172                             PhaseGVN* phase);
1173   static Node* clear_memory(Node* control, Node* mem, Node* dest,
1174                             Node* val,
1175                             Node* raw_val,
1176                             intptr_t start_offset,
1177                             Node* end_offset,
1178                             PhaseGVN* phase);
1179   static Node* clear_memory(Node* control, Node* mem, Node* dest,
1180                             Node* raw_val,
1181                             Node* start_offset,
1182                             Node* end_offset,
1183                             PhaseGVN* phase);
1184   // Return allocation input memory edge if it is different instance
1185   // or itself if it is the one we are looking for.
1186   static bool step_through(Node** np, uint instance_id, PhaseTransform* phase);
1187 };
1188 
1189 //------------------------------MemBar-----------------------------------------
1190 // There are different flavors of Memory Barriers to match the Java Memory
1191 // Model.  Monitor-enter and volatile-load act as Aquires: no following ref
1192 // can be moved to before them.  We insert a MemBar-Acquire after a FastLock or
1193 // volatile-load.  Monitor-exit and volatile-store act as Release: no
1194 // preceding ref can be moved to after them.  We insert a MemBar-Release
1195 // before a FastUnlock or volatile-store.  All volatiles need to be
1196 // serialized, so we follow all volatile-stores with a MemBar-Volatile to
1197 // separate it from any following volatile-load.
1198 class MemBarNode: public MultiNode {
1199   virtual uint hash() const ;                  // { return NO_HASH; }
1200   virtual bool cmp( const Node &amp;n ) const ;    // Always fail, except on self
1201 
1202   virtual uint size_of() const { return sizeof(*this); }
1203   // Memory type this node is serializing.  Usually either rawptr or bottom.
1204   const TypePtr* _adr_type;
1205 
1206   // How is this membar related to a nearby memory access?
1207   enum {
1208     Standalone,
1209     TrailingLoad,
1210     TrailingStore,
1211     LeadingStore,
1212     TrailingLoadStore,
1213     LeadingLoadStore
1214   } _kind;
1215 
1216 #ifdef ASSERT
1217   uint _pair_idx;
1218 #endif
1219 
1220 public:
1221   enum {
1222     Precedent = TypeFunc::Parms  // optional edge to force precedence
1223   };
1224   MemBarNode(Compile* C, int alias_idx, Node* precedent);
1225   virtual int Opcode() const = 0;
1226   virtual const class TypePtr *adr_type() const { return _adr_type; }
1227   virtual const Type* Value(PhaseGVN* phase) const;
1228   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1229   virtual uint match_edge(uint idx) const { return 0; }
1230   virtual const Type *bottom_type() const { return TypeTuple::MEMBAR; }
1231   virtual Node *match(const ProjNode *proj, const Matcher *m, const RegMask* mask);
1232   // Factory method.  Builds a wide or narrow membar.
1233   // Optional &#39;precedent&#39; becomes an extra edge if not null.
1234   static MemBarNode* make(Compile* C, int opcode,
1235                           int alias_idx = Compile::AliasIdxBot,
1236                           Node* precedent = NULL);
1237 
1238   MemBarNode* trailing_membar() const;
1239   MemBarNode* leading_membar() const;
1240 
1241   void set_trailing_load() { _kind = TrailingLoad; }
1242   bool trailing_load() const { return _kind == TrailingLoad; }
1243   bool trailing_store() const { return _kind == TrailingStore; }
1244   bool leading_store() const { return _kind == LeadingStore; }
1245   bool trailing_load_store() const { return _kind == TrailingLoadStore; }
1246   bool leading_load_store() const { return _kind == LeadingLoadStore; }
1247   bool trailing() const { return _kind == TrailingLoad || _kind == TrailingStore || _kind == TrailingLoadStore; }
1248   bool leading() const { return _kind == LeadingStore || _kind == LeadingLoadStore; }
1249   bool standalone() const { return _kind == Standalone; }
1250 
1251   static void set_store_pair(MemBarNode* leading, MemBarNode* trailing);
1252   static void set_load_store_pair(MemBarNode* leading, MemBarNode* trailing);
1253 
1254   void remove(PhaseIterGVN *igvn);
1255 };
1256 
1257 // &quot;Acquire&quot; - no following ref can move before (but earlier refs can
1258 // follow, like an early Load stalled in cache).  Requires multi-cpu
1259 // visibility.  Inserted after a volatile load.
1260 class MemBarAcquireNode: public MemBarNode {
1261 public:
1262   MemBarAcquireNode(Compile* C, int alias_idx, Node* precedent)
1263     : MemBarNode(C, alias_idx, precedent) {}
1264   virtual int Opcode() const;
1265 };
1266 
1267 // &quot;Acquire&quot; - no following ref can move before (but earlier refs can
1268 // follow, like an early Load stalled in cache).  Requires multi-cpu
1269 // visibility.  Inserted independ of any load, as required
1270 // for intrinsic Unsafe.loadFence().
1271 class LoadFenceNode: public MemBarNode {
1272 public:
1273   LoadFenceNode(Compile* C, int alias_idx, Node* precedent)
1274     : MemBarNode(C, alias_idx, precedent) {}
1275   virtual int Opcode() const;
1276 };
1277 
1278 // &quot;Release&quot; - no earlier ref can move after (but later refs can move
1279 // up, like a speculative pipelined cache-hitting Load).  Requires
1280 // multi-cpu visibility.  Inserted before a volatile store.
1281 class MemBarReleaseNode: public MemBarNode {
1282 public:
1283   MemBarReleaseNode(Compile* C, int alias_idx, Node* precedent)
1284     : MemBarNode(C, alias_idx, precedent) {}
1285   virtual int Opcode() const;
1286 };
1287 
1288 // &quot;Release&quot; - no earlier ref can move after (but later refs can move
1289 // up, like a speculative pipelined cache-hitting Load).  Requires
1290 // multi-cpu visibility.  Inserted independent of any store, as required
1291 // for intrinsic Unsafe.storeFence().
1292 class StoreFenceNode: public MemBarNode {
1293 public:
1294   StoreFenceNode(Compile* C, int alias_idx, Node* precedent)
1295     : MemBarNode(C, alias_idx, precedent) {}
1296   virtual int Opcode() const;
1297 };
1298 
1299 // &quot;Acquire&quot; - no following ref can move before (but earlier refs can
1300 // follow, like an early Load stalled in cache).  Requires multi-cpu
1301 // visibility.  Inserted after a FastLock.
1302 class MemBarAcquireLockNode: public MemBarNode {
1303 public:
1304   MemBarAcquireLockNode(Compile* C, int alias_idx, Node* precedent)
1305     : MemBarNode(C, alias_idx, precedent) {}
1306   virtual int Opcode() const;
1307 };
1308 
1309 // &quot;Release&quot; - no earlier ref can move after (but later refs can move
1310 // up, like a speculative pipelined cache-hitting Load).  Requires
1311 // multi-cpu visibility.  Inserted before a FastUnLock.
1312 class MemBarReleaseLockNode: public MemBarNode {
1313 public:
1314   MemBarReleaseLockNode(Compile* C, int alias_idx, Node* precedent)
1315     : MemBarNode(C, alias_idx, precedent) {}
1316   virtual int Opcode() const;
1317 };
1318 
1319 class MemBarStoreStoreNode: public MemBarNode {
1320 public:
1321   MemBarStoreStoreNode(Compile* C, int alias_idx, Node* precedent)
1322     : MemBarNode(C, alias_idx, precedent) {
1323     init_class_id(Class_MemBarStoreStore);
1324   }
1325   virtual int Opcode() const;
1326 };
1327 
1328 // Ordering between a volatile store and a following volatile load.
1329 // Requires multi-CPU visibility?
1330 class MemBarVolatileNode: public MemBarNode {
1331 public:
1332   MemBarVolatileNode(Compile* C, int alias_idx, Node* precedent)
1333     : MemBarNode(C, alias_idx, precedent) {}
1334   virtual int Opcode() const;
1335 };
1336 
1337 // Ordering within the same CPU.  Used to order unsafe memory references
1338 // inside the compiler when we lack alias info.  Not needed &quot;outside&quot; the
1339 // compiler because the CPU does all the ordering for us.
1340 class MemBarCPUOrderNode: public MemBarNode {
1341 public:
1342   MemBarCPUOrderNode(Compile* C, int alias_idx, Node* precedent)
1343     : MemBarNode(C, alias_idx, precedent) {}
1344   virtual int Opcode() const;
1345   virtual uint ideal_reg() const { return 0; } // not matched in the AD file
1346 };
1347 
1348 class OnSpinWaitNode: public MemBarNode {
1349 public:
1350   OnSpinWaitNode(Compile* C, int alias_idx, Node* precedent)
1351     : MemBarNode(C, alias_idx, precedent) {}
1352   virtual int Opcode() const;
1353 };
1354 
1355 // Isolation of object setup after an AllocateNode and before next safepoint.
1356 // (See comment in memnode.cpp near InitializeNode::InitializeNode for semantics.)
1357 class InitializeNode: public MemBarNode {
1358   friend class AllocateNode;
1359 
1360   enum {
1361     Incomplete    = 0,
1362     Complete      = 1,
1363     WithArraycopy = 2
1364   };
1365   int _is_complete;
1366 
1367   bool _does_not_escape;
1368 
1369 public:
1370   enum {
1371     Control    = TypeFunc::Control,
1372     Memory     = TypeFunc::Memory,     // MergeMem for states affected by this op
1373     RawAddress = TypeFunc::Parms+0,    // the newly-allocated raw address
1374     RawStores  = TypeFunc::Parms+1     // zero or more stores (or TOP)
1375   };
1376 
1377   InitializeNode(Compile* C, int adr_type, Node* rawoop);
1378   virtual int Opcode() const;
1379   virtual uint size_of() const { return sizeof(*this); }
1380   virtual uint ideal_reg() const { return 0; } // not matched in the AD file
1381   virtual const RegMask &amp;in_RegMask(uint) const;  // mask for RawAddress
1382 
1383   // Manage incoming memory edges via a MergeMem on in(Memory):
1384   Node* memory(uint alias_idx);
1385 
1386   // The raw memory edge coming directly from the Allocation.
1387   // The contents of this memory are *always* all-zero-bits.
1388   Node* zero_memory() { return memory(Compile::AliasIdxRaw); }
1389 
1390   // Return the corresponding allocation for this initialization (or null if none).
1391   // (Note: Both InitializeNode::allocation and AllocateNode::initialization
1392   // are defined in graphKit.cpp, which sets up the bidirectional relation.)
1393   AllocateNode* allocation();
1394 
1395   // Anything other than zeroing in this init?
1396   bool is_non_zero();
1397 
1398   // An InitializeNode must completed before macro expansion is done.
1399   // Completion requires that the AllocateNode must be followed by
1400   // initialization of the new memory to zero, then to any initializers.
1401   bool is_complete() { return _is_complete != Incomplete; }
1402   bool is_complete_with_arraycopy() { return (_is_complete &amp; WithArraycopy) != 0; }
1403 
1404   // Mark complete.  (Must not yet be complete.)
1405   void set_complete(PhaseGVN* phase);
1406   void set_complete_with_arraycopy() { _is_complete = Complete | WithArraycopy; }
1407 
1408   bool does_not_escape() { return _does_not_escape; }
1409   void set_does_not_escape() { _does_not_escape = true; }
1410 
1411 #ifdef ASSERT
1412   // ensure all non-degenerate stores are ordered and non-overlapping
1413   bool stores_are_sane(PhaseTransform* phase);
1414 #endif //ASSERT
1415 
1416   // See if this store can be captured; return offset where it initializes.
1417   // Return 0 if the store cannot be moved (any sort of problem).
1418   intptr_t can_capture_store(StoreNode* st, PhaseGVN* phase, bool can_reshape);
1419 
1420   // Capture another store; reformat it to write my internal raw memory.
1421   // Return the captured copy, else NULL if there is some sort of problem.
1422   Node* capture_store(StoreNode* st, intptr_t start, PhaseGVN* phase, bool can_reshape);
1423 
1424   // Find captured store which corresponds to the range [start..start+size).
1425   // Return my own memory projection (meaning the initial zero bits)
1426   // if there is no such store.  Return NULL if there is a problem.
1427   Node* find_captured_store(intptr_t start, int size_in_bytes, PhaseTransform* phase);
1428 
1429   // Called when the associated AllocateNode is expanded into CFG.
1430   Node* complete_stores(Node* rawctl, Node* rawmem, Node* rawptr,
1431                         intptr_t header_size, Node* size_in_bytes,
1432                         PhaseIterGVN* phase);
1433 
1434  private:
1435   void remove_extra_zeroes();
1436 
1437   // Find out where a captured store should be placed (or already is placed).
1438   int captured_store_insertion_point(intptr_t start, int size_in_bytes,
1439                                      PhaseTransform* phase);
1440 
1441   static intptr_t get_store_offset(Node* st, PhaseTransform* phase);
1442 
1443   Node* make_raw_address(intptr_t offset, PhaseTransform* phase);
1444 
1445   bool detect_init_independence(Node* value, PhaseGVN* phase);
1446 
1447   void coalesce_subword_stores(intptr_t header_size, Node* size_in_bytes,
1448                                PhaseGVN* phase);
1449 
1450   intptr_t find_next_fullword_store(uint i, PhaseGVN* phase);
1451 };
1452 
1453 //------------------------------MergeMem---------------------------------------
1454 // (See comment in memnode.cpp near MergeMemNode::MergeMemNode for semantics.)
1455 class MergeMemNode: public Node {
1456   virtual uint hash() const ;                  // { return NO_HASH; }
1457   virtual bool cmp( const Node &amp;n ) const ;    // Always fail, except on self
1458   friend class MergeMemStream;
1459   MergeMemNode(Node* def);  // clients use MergeMemNode::make
1460 
1461 public:
1462   // If the input is a whole memory state, clone it with all its slices intact.
1463   // Otherwise, make a new memory state with just that base memory input.
1464   // In either case, the result is a newly created MergeMem.
1465   static MergeMemNode* make(Node* base_memory);
1466 
1467   virtual int Opcode() const;
1468   virtual Node* Identity(PhaseGVN* phase);
1469   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1470   virtual uint ideal_reg() const { return NotAMachineReg; }
1471   virtual uint match_edge(uint idx) const { return 0; }
1472   virtual const RegMask &amp;out_RegMask() const;
1473   virtual const Type *bottom_type() const { return Type::MEMORY; }
1474   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }
1475   // sparse accessors
1476   // Fetch the previously stored &quot;set_memory_at&quot;, or else the base memory.
1477   // (Caller should clone it if it is a phi-nest.)
1478   Node* memory_at(uint alias_idx) const;
1479   // set the memory, regardless of its previous value
1480   void set_memory_at(uint alias_idx, Node* n);
1481   // the &quot;base&quot; is the memory that provides the non-finite support
1482   Node* base_memory() const       { return in(Compile::AliasIdxBot); }
1483   // warning: setting the base can implicitly set any of the other slices too
1484   void set_base_memory(Node* def);
1485   // sentinel value which denotes a copy of the base memory:
1486   Node*   empty_memory() const    { return in(Compile::AliasIdxTop); }
1487   static Node* make_empty_memory(); // where the sentinel comes from
1488   bool is_empty_memory(Node* n) const { assert((n == empty_memory()) == n-&gt;is_top(), &quot;sanity&quot;); return n-&gt;is_top(); }
1489   // hook for the iterator, to perform any necessary setup
1490   void iteration_setup(const MergeMemNode* other = NULL);
1491   // push sentinels until I am at least as long as the other (semantic no-op)
1492   void grow_to_match(const MergeMemNode* other);
1493   bool verify_sparse() const PRODUCT_RETURN0;
1494 #ifndef PRODUCT
1495   virtual void dump_spec(outputStream *st) const;
1496 #endif
1497 };
1498 
1499 class MergeMemStream : public StackObj {
1500  private:
1501   MergeMemNode*       _mm;
1502   const MergeMemNode* _mm2;  // optional second guy, contributes non-empty iterations
1503   Node*               _mm_base;  // loop-invariant base memory of _mm
1504   int                 _idx;
1505   int                 _cnt;
1506   Node*               _mem;
1507   Node*               _mem2;
1508   int                 _cnt2;
1509 
1510   void init(MergeMemNode* mm, const MergeMemNode* mm2 = NULL) {
1511     // subsume_node will break sparseness at times, whenever a memory slice
1512     // folds down to a copy of the base (&quot;fat&quot;) memory.  In such a case,
1513     // the raw edge will update to base, although it should be top.
1514     // This iterator will recognize either top or base_memory as an
1515     // &quot;empty&quot; slice.  See is_empty, is_empty2, and next below.
1516     //
1517     // The sparseness property is repaired in MergeMemNode::Ideal.
1518     // As long as access to a MergeMem goes through this iterator
1519     // or the memory_at accessor, flaws in the sparseness will
1520     // never be observed.
1521     //
1522     // Also, iteration_setup repairs sparseness.
1523     assert(mm-&gt;verify_sparse(), &quot;please, no dups of base&quot;);
1524     assert(mm2==NULL || mm2-&gt;verify_sparse(), &quot;please, no dups of base&quot;);
1525 
1526     _mm  = mm;
1527     _mm_base = mm-&gt;base_memory();
1528     _mm2 = mm2;
1529     _cnt = mm-&gt;req();
1530     _idx = Compile::AliasIdxBot-1; // start at the base memory
1531     _mem = NULL;
1532     _mem2 = NULL;
1533   }
1534 
1535 #ifdef ASSERT
1536   Node* check_memory() const {
1537     if (at_base_memory())
1538       return _mm-&gt;base_memory();
1539     else if ((uint)_idx &lt; _mm-&gt;req() &amp;&amp; !_mm-&gt;in(_idx)-&gt;is_top())
1540       return _mm-&gt;memory_at(_idx);
1541     else
1542       return _mm_base;
1543   }
1544   Node* check_memory2() const {
1545     return at_base_memory()? _mm2-&gt;base_memory(): _mm2-&gt;memory_at(_idx);
1546   }
1547 #endif
1548 
1549   static bool match_memory(Node* mem, const MergeMemNode* mm, int idx) PRODUCT_RETURN0;
1550   void assert_synch() const {
1551     assert(!_mem || _idx &gt;= _cnt || match_memory(_mem, _mm, _idx),
1552            &quot;no side-effects except through the stream&quot;);
1553   }
1554 
1555  public:
1556 
1557   // expected usages:
1558   // for (MergeMemStream mms(mem-&gt;is_MergeMem()); next_non_empty(); ) { ... }
1559   // for (MergeMemStream mms(mem1, mem2); next_non_empty2(); ) { ... }
1560 
1561   // iterate over one merge
1562   MergeMemStream(MergeMemNode* mm) {
1563     mm-&gt;iteration_setup();
1564     init(mm);
1565     debug_only(_cnt2 = 999);
1566   }
1567   // iterate in parallel over two merges
1568   // only iterates through non-empty elements of mm2
1569   MergeMemStream(MergeMemNode* mm, const MergeMemNode* mm2) {
1570     assert(mm2, &quot;second argument must be a MergeMem also&quot;);
1571     ((MergeMemNode*)mm2)-&gt;iteration_setup();  // update hidden state
1572     mm-&gt;iteration_setup(mm2);
1573     init(mm, mm2);
1574     _cnt2 = mm2-&gt;req();
1575   }
1576 #ifdef ASSERT
1577   ~MergeMemStream() {
1578     assert_synch();
1579   }
1580 #endif
1581 
1582   MergeMemNode* all_memory() const {
1583     return _mm;
1584   }
1585   Node* base_memory() const {
1586     assert(_mm_base == _mm-&gt;base_memory(), &quot;no update to base memory, please&quot;);
1587     return _mm_base;
1588   }
1589   const MergeMemNode* all_memory2() const {
1590     assert(_mm2 != NULL, &quot;&quot;);
1591     return _mm2;
1592   }
1593   bool at_base_memory() const {
1594     return _idx == Compile::AliasIdxBot;
1595   }
1596   int alias_idx() const {
1597     assert(_mem, &quot;must call next 1st&quot;);
1598     return _idx;
1599   }
1600 
1601   const TypePtr* adr_type() const {
1602     return Compile::current()-&gt;get_adr_type(alias_idx());
1603   }
1604 
1605   const TypePtr* adr_type(Compile* C) const {
1606     return C-&gt;get_adr_type(alias_idx());
1607   }
1608   bool is_empty() const {
1609     assert(_mem, &quot;must call next 1st&quot;);
1610     assert(_mem-&gt;is_top() == (_mem==_mm-&gt;empty_memory()), &quot;correct sentinel&quot;);
1611     return _mem-&gt;is_top();
1612   }
1613   bool is_empty2() const {
1614     assert(_mem2, &quot;must call next 1st&quot;);
1615     assert(_mem2-&gt;is_top() == (_mem2==_mm2-&gt;empty_memory()), &quot;correct sentinel&quot;);
1616     return _mem2-&gt;is_top();
1617   }
1618   Node* memory() const {
1619     assert(!is_empty(), &quot;must not be empty&quot;);
1620     assert_synch();
1621     return _mem;
1622   }
1623   // get the current memory, regardless of empty or non-empty status
1624   Node* force_memory() const {
1625     assert(!is_empty() || !at_base_memory(), &quot;&quot;);
1626     // Use _mm_base to defend against updates to _mem-&gt;base_memory().
1627     Node *mem = _mem-&gt;is_top() ? _mm_base : _mem;
1628     assert(mem == check_memory(), &quot;&quot;);
1629     return mem;
1630   }
1631   Node* memory2() const {
1632     assert(_mem2 == check_memory2(), &quot;&quot;);
1633     return _mem2;
1634   }
1635   void set_memory(Node* mem) {
1636     if (at_base_memory()) {
1637       // Note that this does not change the invariant _mm_base.
1638       _mm-&gt;set_base_memory(mem);
1639     } else {
1640       _mm-&gt;set_memory_at(_idx, mem);
1641     }
1642     _mem = mem;
1643     assert_synch();
1644   }
1645 
1646   // Recover from a side effect to the MergeMemNode.
1647   void set_memory() {
1648     _mem = _mm-&gt;in(_idx);
1649   }
1650 
1651   bool next()  { return next(false); }
1652   bool next2() { return next(true); }
1653 
1654   bool next_non_empty()  { return next_non_empty(false); }
1655   bool next_non_empty2() { return next_non_empty(true); }
1656   // next_non_empty2 can yield states where is_empty() is true
1657 
1658  private:
1659   // find the next item, which might be empty
1660   bool next(bool have_mm2) {
1661     assert((_mm2 != NULL) == have_mm2, &quot;use other next&quot;);
1662     assert_synch();
1663     if (++_idx &lt; _cnt) {
1664       // Note:  This iterator allows _mm to be non-sparse.
1665       // It behaves the same whether _mem is top or base_memory.
1666       _mem = _mm-&gt;in(_idx);
1667       if (have_mm2)
1668         _mem2 = _mm2-&gt;in((_idx &lt; _cnt2) ? _idx : Compile::AliasIdxTop);
1669       return true;
1670     }
1671     return false;
1672   }
1673 
1674   // find the next non-empty item
1675   bool next_non_empty(bool have_mm2) {
1676     while (next(have_mm2)) {
1677       if (!is_empty()) {
1678         // make sure _mem2 is filled in sensibly
1679         if (have_mm2 &amp;&amp; _mem2-&gt;is_top())  _mem2 = _mm2-&gt;base_memory();
1680         return true;
1681       } else if (have_mm2 &amp;&amp; !is_empty2()) {
1682         return true;   // is_empty() == true
1683       }
1684     }
1685     return false;
1686   }
1687 };
1688 
1689 // cachewb node for guaranteeing writeback of the cache line at a
1690 // given address to (non-volatile) RAM
1691 class CacheWBNode : public Node {
1692 public:
1693   CacheWBNode(Node *ctrl, Node *mem, Node *addr) : Node(ctrl, mem, addr) {}
1694   virtual int Opcode() const;
1695   virtual uint ideal_reg() const { return NotAMachineReg; }
1696   virtual uint match_edge(uint idx) const { return (idx == 2); }
1697   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }
1698   virtual const Type *bottom_type() const { return Type::MEMORY; }
1699 };
1700 
1701 // cachewb pre sync node for ensuring that writebacks are serialised
1702 // relative to preceding or following stores
1703 class CacheWBPreSyncNode : public Node {
1704 public:
1705   CacheWBPreSyncNode(Node *ctrl, Node *mem) : Node(ctrl, mem) {}
1706   virtual int Opcode() const;
1707   virtual uint ideal_reg() const { return NotAMachineReg; }
1708   virtual uint match_edge(uint idx) const { return false; }
1709   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }
1710   virtual const Type *bottom_type() const { return Type::MEMORY; }
1711 };
1712 
1713 // cachewb pre sync node for ensuring that writebacks are serialised
1714 // relative to preceding or following stores
1715 class CacheWBPostSyncNode : public Node {
1716 public:
1717   CacheWBPostSyncNode(Node *ctrl, Node *mem) : Node(ctrl, mem) {}
1718   virtual int Opcode() const;
1719   virtual uint ideal_reg() const { return NotAMachineReg; }
1720   virtual uint match_edge(uint idx) const { return false; }
1721   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }
1722   virtual const Type *bottom_type() const { return Type::MEMORY; }
1723 };
1724 
1725 //------------------------------Prefetch---------------------------------------
1726 
1727 // Allocation prefetch which may fault, TLAB size have to be adjusted.
1728 class PrefetchAllocationNode : public Node {
1729 public:
1730   PrefetchAllocationNode(Node *mem, Node *adr) : Node(0,mem,adr) {}
1731   virtual int Opcode() const;
1732   virtual uint ideal_reg() const { return NotAMachineReg; }
1733   virtual uint match_edge(uint idx) const { return idx==2; }
1734   virtual const Type *bottom_type() const { return ( AllocatePrefetchStyle == 3 ) ? Type::MEMORY : Type::ABIO; }
1735 };
1736 
1737 #endif // SHARE_OPTO_MEMNODE_HPP
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
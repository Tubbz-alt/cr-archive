<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
    1 //
    2 // Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // AMD64 Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // archtecture.
   31 
   32 register %{
   33 //----------Architecture Description Register Definitions----------------------
   34 // General Registers
   35 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   36 //                   ideal register type, encoding );
   37 // Register Save Types:
   38 //
   39 // NS  = No-Save:       The register allocator assumes that these registers
   40 //                      can be used without saving upon entry to the method, &amp;
   41 //                      that they do not need to be saved at call sites.
   42 //
   43 // SOC = Save-On-Call:  The register allocator assumes that these registers
   44 //                      can be used without saving upon entry to the method,
   45 //                      but that they must be saved at call sites.
   46 //
   47 // SOE = Save-On-Entry: The register allocator assumes that these registers
   48 //                      must be saved before using them upon entry to the
   49 //                      method, but they do not need to be saved at call
   50 //                      sites.
   51 //
   52 // AS  = Always-Save:   The register allocator assumes that these registers
   53 //                      must be saved before using them upon entry to the
   54 //                      method, &amp; that they must be saved at call sites.
   55 //
   56 // Ideal Register Type is used to determine how to save &amp; restore a
   57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   59 //
   60 // The encoding number is the actual bit-pattern placed into the opcodes.
   61 
   62 // General Registers
   63 // R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when
   64 // used as byte registers)
   65 
   66 // Previously set RBX, RSI, and RDI as save-on-entry for java code
   67 // Turn off SOE in java-code due to frequent use of uncommon-traps.
   68 // Now that allocator is better, turn on RSI and RDI as SOE registers.
   69 
   70 reg_def RAX  (SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg());
   71 reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg()-&gt;next());
   72 
   73 reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg());
   74 reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg()-&gt;next());
   75 
   76 reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg());
   77 reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg()-&gt;next());
   78 
   79 reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg());
   80 reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg()-&gt;next());
   81 
   82 reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg());
   83 reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg()-&gt;next());
   84 
   85 // now that adapter frames are gone RBP is always saved and restored by the prolog/epilog code
   86 reg_def RBP  (NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg());
   87 reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg()-&gt;next());
   88 
   89 #ifdef _WIN64
   90 
   91 reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg());
   92 reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
   93 
   94 reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg());
   95 reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
   96 
   97 #else
   98 
   99 reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg());
  100 reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
  101 
  102 reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg());
  103 reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
  104 
  105 #endif
  106 
  107 reg_def R8   (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg());
  108 reg_def R8_H (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg()-&gt;next());
  109 
  110 reg_def R9   (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg());
  111 reg_def R9_H (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg()-&gt;next());
  112 
  113 reg_def R10  (SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg());
  114 reg_def R10_H(SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg()-&gt;next());
  115 
  116 reg_def R11  (SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg());
  117 reg_def R11_H(SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg()-&gt;next());
  118 
  119 reg_def R12  (SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg());
  120 reg_def R12_H(SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg()-&gt;next());
  121 
  122 reg_def R13  (SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg());
  123 reg_def R13_H(SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg()-&gt;next());
  124 
  125 reg_def R14  (SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg());
  126 reg_def R14_H(SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg()-&gt;next());
  127 
  128 reg_def R15  (SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg());
  129 reg_def R15_H(SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg()-&gt;next());
  130 
  131 
  132 // Floating Point Registers
  133 
  134 // Specify priority of register selection within phases of register
  135 // allocation.  Highest priority is first.  A useful heuristic is to
  136 // give registers a low priority when they are required by machine
  137 // instructions, like EAX and EDX on I486, and choose no-save registers
  138 // before save-on-call, &amp; save-on-call before save-on-entry.  Registers
  139 // which participate in fixed calling sequences should come last.
  140 // Registers which are used as pairs must fall on an even boundary.
  141 
  142 alloc_class chunk0(R10,         R10_H,
  143                    R11,         R11_H,
  144                    R8,          R8_H,
  145                    R9,          R9_H,
  146                    R12,         R12_H,
  147                    RCX,         RCX_H,
  148                    RBX,         RBX_H,
  149                    RDI,         RDI_H,
  150                    RDX,         RDX_H,
  151                    RSI,         RSI_H,
  152                    RAX,         RAX_H,
  153                    RBP,         RBP_H,
  154                    R13,         R13_H,
  155                    R14,         R14_H,
  156                    R15,         R15_H,
  157                    RSP,         RSP_H);
  158 
  159 
  160 //----------Architecture Description Register Classes--------------------------
  161 // Several register classes are automatically defined based upon information in
  162 // this architecture description.
  163 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  164 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  165 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  166 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  167 //
  168 
  169 // Empty register class.
  170 reg_class no_reg();
  171 
  172 // Class for all pointer/long registers
  173 reg_class all_reg(RAX, RAX_H,
  174                   RDX, RDX_H,
  175                   RBP, RBP_H,
  176                   RDI, RDI_H,
  177                   RSI, RSI_H,
  178                   RCX, RCX_H,
  179                   RBX, RBX_H,
  180                   RSP, RSP_H,
  181                   R8,  R8_H,
  182                   R9,  R9_H,
  183                   R10, R10_H,
  184                   R11, R11_H,
  185                   R12, R12_H,
  186                   R13, R13_H,
  187                   R14, R14_H,
  188                   R15, R15_H);
  189 
  190 // Class for all int registers
  191 reg_class all_int_reg(RAX
  192                       RDX,
  193                       RBP,
  194                       RDI,
  195                       RSI,
  196                       RCX,
  197                       RBX,
  198                       R8,
  199                       R9,
  200                       R10,
  201                       R11,
  202                       R12,
  203                       R13,
  204                       R14);
  205 
  206 // Class for all pointer registers
  207 reg_class any_reg %{
  208   return _ANY_REG_mask;
  209 %}
  210 
  211 // Class for all pointer registers (excluding RSP)
  212 reg_class ptr_reg %{
  213   return _PTR_REG_mask;
  214 %}
  215 
  216 // Class for all pointer registers (excluding RSP and RBP)
  217 reg_class ptr_reg_no_rbp %{
  218   return _PTR_REG_NO_RBP_mask;
  219 %}
  220 
  221 // Class for all pointer registers (excluding RAX and RSP)
  222 reg_class ptr_no_rax_reg %{
  223   return _PTR_NO_RAX_REG_mask;
  224 %}
  225 
  226 // Class for all pointer registers (excluding RAX, RBX, and RSP)
  227 reg_class ptr_no_rax_rbx_reg %{
  228   return _PTR_NO_RAX_RBX_REG_mask;
  229 %}
  230 
  231 // Class for all long registers (excluding RSP)
  232 reg_class long_reg %{
  233   return _LONG_REG_mask;
  234 %}
  235 
  236 // Class for all long registers (excluding RAX, RDX and RSP)
  237 reg_class long_no_rax_rdx_reg %{
  238   return _LONG_NO_RAX_RDX_REG_mask;
  239 %}
  240 
  241 // Class for all long registers (excluding RCX and RSP)
  242 reg_class long_no_rcx_reg %{
  243   return _LONG_NO_RCX_REG_mask;
  244 %}
  245 
  246 // Class for all int registers (excluding RSP)
  247 reg_class int_reg %{
  248   return _INT_REG_mask;
  249 %}
  250 
  251 // Class for all int registers (excluding RAX, RDX, and RSP)
  252 reg_class int_no_rax_rdx_reg %{
  253   return _INT_NO_RAX_RDX_REG_mask;
  254 %}
  255 
  256 // Class for all int registers (excluding RCX and RSP)
  257 reg_class int_no_rcx_reg %{
  258   return _INT_NO_RCX_REG_mask;
  259 %}
  260 
  261 // Singleton class for RAX pointer register
  262 reg_class ptr_rax_reg(RAX, RAX_H);
  263 
  264 // Singleton class for RBX pointer register
  265 reg_class ptr_rbx_reg(RBX, RBX_H);
  266 
  267 // Singleton class for RSI pointer register
  268 reg_class ptr_rsi_reg(RSI, RSI_H);
  269 
  270 // Singleton class for RBP pointer register
  271 reg_class ptr_rbp_reg(RBP, RBP_H);
  272 
  273 // Singleton class for RDI pointer register
  274 reg_class ptr_rdi_reg(RDI, RDI_H);
  275 
  276 // Singleton class for stack pointer
  277 reg_class ptr_rsp_reg(RSP, RSP_H);
  278 
  279 // Singleton class for TLS pointer
  280 reg_class ptr_r15_reg(R15, R15_H);
  281 
  282 // Singleton class for RAX long register
  283 reg_class long_rax_reg(RAX, RAX_H);
  284 
  285 // Singleton class for RCX long register
  286 reg_class long_rcx_reg(RCX, RCX_H);
  287 
  288 // Singleton class for RDX long register
  289 reg_class long_rdx_reg(RDX, RDX_H);
  290 
  291 // Singleton class for RAX int register
  292 reg_class int_rax_reg(RAX);
  293 
  294 // Singleton class for RBX int register
  295 reg_class int_rbx_reg(RBX);
  296 
  297 // Singleton class for RCX int register
  298 reg_class int_rcx_reg(RCX);
  299 
  300 // Singleton class for RCX int register
  301 reg_class int_rdx_reg(RDX);
  302 
  303 // Singleton class for RCX int register
  304 reg_class int_rdi_reg(RDI);
  305 
  306 // Singleton class for instruction pointer
  307 // reg_class ip_reg(RIP);
  308 
  309 %}
  310 
  311 //----------SOURCE BLOCK-------------------------------------------------------
  312 // This is a block of C++ code which provides values, functions, and
  313 // definitions necessary in the rest of the architecture description
  314 source_hpp %{
  315 
  316 extern RegMask _ANY_REG_mask;
  317 extern RegMask _PTR_REG_mask;
  318 extern RegMask _PTR_REG_NO_RBP_mask;
  319 extern RegMask _PTR_NO_RAX_REG_mask;
  320 extern RegMask _PTR_NO_RAX_RBX_REG_mask;
  321 extern RegMask _LONG_REG_mask;
  322 extern RegMask _LONG_NO_RAX_RDX_REG_mask;
  323 extern RegMask _LONG_NO_RCX_REG_mask;
  324 extern RegMask _INT_REG_mask;
  325 extern RegMask _INT_NO_RAX_RDX_REG_mask;
  326 extern RegMask _INT_NO_RCX_REG_mask;
  327 
  328 extern RegMask _STACK_OR_PTR_REG_mask;
  329 extern RegMask _STACK_OR_LONG_REG_mask;
  330 extern RegMask _STACK_OR_INT_REG_mask;
  331 
  332 inline const RegMask&amp; STACK_OR_PTR_REG_mask()  { return _STACK_OR_PTR_REG_mask;  }
  333 inline const RegMask&amp; STACK_OR_LONG_REG_mask() { return _STACK_OR_LONG_REG_mask; }
  334 inline const RegMask&amp; STACK_OR_INT_REG_mask()  { return _STACK_OR_INT_REG_mask;  }
  335 
  336 %}
  337 
  338 source %{
  339 #define   RELOC_IMM64    Assembler::imm_operand
  340 #define   RELOC_DISP32   Assembler::disp32_operand
  341 
  342 #define __ _masm.
  343 
  344 RegMask _ANY_REG_mask;
  345 RegMask _PTR_REG_mask;
  346 RegMask _PTR_REG_NO_RBP_mask;
  347 RegMask _PTR_NO_RAX_REG_mask;
  348 RegMask _PTR_NO_RAX_RBX_REG_mask;
  349 RegMask _LONG_REG_mask;
  350 RegMask _LONG_NO_RAX_RDX_REG_mask;
  351 RegMask _LONG_NO_RCX_REG_mask;
  352 RegMask _INT_REG_mask;
  353 RegMask _INT_NO_RAX_RDX_REG_mask;
  354 RegMask _INT_NO_RCX_REG_mask;
  355 RegMask _STACK_OR_PTR_REG_mask;
  356 RegMask _STACK_OR_LONG_REG_mask;
  357 RegMask _STACK_OR_INT_REG_mask;
  358 
  359 static bool need_r12_heapbase() {
  360   return UseCompressedOops || UseCompressedClassPointers;
  361 }
  362 
  363 void reg_mask_init() {
  364   // _ALL_REG_mask is generated by adlc from the all_reg register class below.
  365   // We derive a number of subsets from it.
  366   _ANY_REG_mask = _ALL_REG_mask;
  367 
  368   if (PreserveFramePointer) {
  369     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  370     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  371   }
  372   if (need_r12_heapbase()) {
  373     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  374     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()-&gt;next()));
  375   }
  376 
  377   _PTR_REG_mask = _ANY_REG_mask;
  378   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()));
  379   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()-&gt;next()));
  380   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()));
  381   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()-&gt;next()));
  382 
  383   _STACK_OR_PTR_REG_mask = _PTR_REG_mask;
  384   _STACK_OR_PTR_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  385 
  386   _PTR_REG_NO_RBP_mask = _PTR_REG_mask;
  387   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  388   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  389 
  390   _PTR_NO_RAX_REG_mask = _PTR_REG_mask;
  391   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  392   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  393 
  394   _PTR_NO_RAX_RBX_REG_mask = _PTR_NO_RAX_REG_mask;
  395   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()));
  396   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()-&gt;next()));
  397 
  398   _LONG_REG_mask = _PTR_REG_mask;
  399   _STACK_OR_LONG_REG_mask = _LONG_REG_mask;
  400   _STACK_OR_LONG_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  401 
  402   _LONG_NO_RAX_RDX_REG_mask = _LONG_REG_mask;
  403   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  404   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  405   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  406   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()-&gt;next()));
  407 
  408   _LONG_NO_RCX_REG_mask = _LONG_REG_mask;
  409   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  410   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()-&gt;next()));
  411 
  412   _INT_REG_mask = _ALL_INT_REG_mask;
  413   if (PreserveFramePointer) {
  414     _INT_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  415   }
  416   if (need_r12_heapbase()) {
  417     _INT_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  418   }
  419 
  420   _STACK_OR_INT_REG_mask = _INT_REG_mask;
  421   _STACK_OR_INT_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  422 
  423   _INT_NO_RAX_RDX_REG_mask = _INT_REG_mask;
  424   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  425   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  426 
  427   _INT_NO_RCX_REG_mask = _INT_REG_mask;
  428   _INT_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  429 }
  430 
  431 static bool generate_vzeroupper(Compile* C) {
  432   return (VM_Version::supports_vzeroupper() &amp;&amp; (C-&gt;max_vector_size() &gt; 16 || C-&gt;clear_upper_avx() == true)) ? true: false;  // Generate vzeroupper
  433 }
  434 
  435 static int clear_avx_size() {
  436   return generate_vzeroupper(Compile::current()) ? 3: 0;  // vzeroupper
  437 }
  438 
  439 // !!!!! Special hack to get all types of calls to specify the byte offset
  440 //       from the start of the call to the point where the return address
  441 //       will point.
  442 int MachCallStaticJavaNode::ret_addr_offset()
  443 {
  444   int offset = 5; // 5 bytes from start of call to where return address points
  445   offset += clear_avx_size();
  446   return offset;
  447 }
  448 
  449 int MachCallDynamicJavaNode::ret_addr_offset()
  450 {
  451   int offset = 15; // 15 bytes from start of call to where return address points
  452   offset += clear_avx_size();
  453   return offset;
  454 }
  455 
  456 int MachCallRuntimeNode::ret_addr_offset() {
  457   int offset = 13; // movq r10,#addr; callq (r10)
  458   offset += clear_avx_size();
  459   return offset;
  460 }
  461 
  462 //
  463 // Compute padding required for nodes which need alignment
  464 //
  465 
  466 // The address of the call instruction needs to be 4-byte aligned to
  467 // ensure that it does not span a cache line so that it can be patched.
  468 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
  469 {
  470   current_offset += clear_avx_size(); // skip vzeroupper
  471   current_offset += 1; // skip call opcode byte
  472   return align_up(current_offset, alignment_required()) - current_offset;
  473 }
  474 
  475 // The address of the call instruction needs to be 4-byte aligned to
  476 // ensure that it does not span a cache line so that it can be patched.
  477 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
  478 {
  479   current_offset += clear_avx_size(); // skip vzeroupper
  480   current_offset += 11; // skip movq instruction + call opcode byte
  481   return align_up(current_offset, alignment_required()) - current_offset;
  482 }
  483 
  484 // EMIT_RM()
  485 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
  486   unsigned char c = (unsigned char) ((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
  487   cbuf.insts()-&gt;emit_int8(c);
  488 }
  489 
  490 // EMIT_CC()
  491 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
  492   unsigned char c = (unsigned char) (f1 | f2);
  493   cbuf.insts()-&gt;emit_int8(c);
  494 }
  495 
  496 // EMIT_OPCODE()
  497 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
  498   cbuf.insts()-&gt;emit_int8((unsigned char) code);
  499 }
  500 
  501 // EMIT_OPCODE() w/ relocation information
  502 void emit_opcode(CodeBuffer &amp;cbuf,
  503                  int code, relocInfo::relocType reloc, int offset, int format)
  504 {
  505   cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
  506   emit_opcode(cbuf, code);
  507 }
  508 
  509 // EMIT_D8()
  510 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
  511   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
  512 }
  513 
  514 // EMIT_D16()
  515 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
  516   cbuf.insts()-&gt;emit_int16(d16);
  517 }
  518 
  519 // EMIT_D32()
  520 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
  521   cbuf.insts()-&gt;emit_int32(d32);
  522 }
  523 
  524 // EMIT_D64()
  525 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
  526   cbuf.insts()-&gt;emit_int64(d64);
  527 }
  528 
  529 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  530 void emit_d32_reloc(CodeBuffer&amp; cbuf,
  531                     int d32,
  532                     relocInfo::relocType reloc,
  533                     int format)
  534 {
  535   assert(reloc != relocInfo::external_word_type, &quot;use 2-arg emit_d32_reloc&quot;);
  536   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  537   cbuf.insts()-&gt;emit_int32(d32);
  538 }
  539 
  540 // emit 32 bit value and construct relocation entry from RelocationHolder
  541 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
  542 #ifdef ASSERT
  543   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  544       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
  545     assert(Universe::heap()-&gt;is_in((address)(intptr_t)d32), &quot;should be real oop&quot;);
  546     assert(oopDesc::is_oop(cast_to_oop((intptr_t)d32)), &quot;cannot embed broken oops in code&quot;);
  547   }
  548 #endif
  549   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  550   cbuf.insts()-&gt;emit_int32(d32);
  551 }
  552 
  553 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
  554   address next_ip = cbuf.insts_end() + 4;
  555   emit_d32_reloc(cbuf, (int) (addr - next_ip),
  556                  external_word_Relocation::spec(addr),
  557                  RELOC_DISP32);
  558 }
  559 
  560 
  561 // emit 64 bit value and construct relocation entry from relocInfo::relocType
  562 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
  563   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  564   cbuf.insts()-&gt;emit_int64(d64);
  565 }
  566 
  567 // emit 64 bit value and construct relocation entry from RelocationHolder
  568 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
  569 #ifdef ASSERT
  570   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  571       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
  572     assert(Universe::heap()-&gt;is_in((address)d64), &quot;should be real oop&quot;);
  573     assert(oopDesc::is_oop(cast_to_oop(d64)), &quot;cannot embed broken oops in code&quot;);
  574   }
  575 #endif
  576   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  577   cbuf.insts()-&gt;emit_int64(d64);
  578 }
  579 
  580 // Access stack slot for load or store
  581 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
  582 {
  583   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
  584   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
  585     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
  586     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  587     emit_d8(cbuf, disp);     // Displacement  // R/M byte
  588   } else {
  589     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
  590     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  591     emit_d32(cbuf, disp);     // Displacement // R/M byte
  592   }
  593 }
  594 
  595    // rRegI ereg, memory mem) %{    // emit_reg_mem
  596 void encode_RegMem(CodeBuffer &amp;cbuf,
  597                    int reg,
  598                    int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)
  599 {
  600   assert(disp_reloc == relocInfo::none, &quot;cannot have disp&quot;);
  601   int regenc = reg &amp; 7;
  602   int baseenc = base &amp; 7;
  603   int indexenc = index &amp; 7;
  604 
  605   // There is no index &amp; no scale, use form without SIB byte
  606   if (index == 0x4 &amp;&amp; scale == 0 &amp;&amp; base != RSP_enc &amp;&amp; base != R12_enc) {
  607     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  608     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  609       emit_rm(cbuf, 0x0, regenc, baseenc); // *
  610     } else if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  611       // If 8-bit displacement, mode 0x1
  612       emit_rm(cbuf, 0x1, regenc, baseenc); // *
  613       emit_d8(cbuf, disp);
  614     } else {
  615       // If 32-bit displacement
  616       if (base == -1) { // Special flag for absolute address
  617         emit_rm(cbuf, 0x0, regenc, 0x5); // *
  618         if (disp_reloc != relocInfo::none) {
  619           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  620         } else {
  621           emit_d32(cbuf, disp);
  622         }
  623       } else {
  624         // Normal base + offset
  625         emit_rm(cbuf, 0x2, regenc, baseenc); // *
  626         if (disp_reloc != relocInfo::none) {
  627           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  628         } else {
  629           emit_d32(cbuf, disp);
  630         }
  631       }
  632     }
  633   } else {
  634     // Else, encode with the SIB byte
  635     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  636     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  637       // If no displacement
  638       emit_rm(cbuf, 0x0, regenc, 0x4); // *
  639       emit_rm(cbuf, scale, indexenc, baseenc);
  640     } else {
  641       if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  642         // If 8-bit displacement, mode 0x1
  643         emit_rm(cbuf, 0x1, regenc, 0x4); // *
  644         emit_rm(cbuf, scale, indexenc, baseenc);
  645         emit_d8(cbuf, disp);
  646       } else {
  647         // If 32-bit displacement
  648         if (base == 0x04 ) {
  649           emit_rm(cbuf, 0x2, regenc, 0x4);
  650           emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
  651         } else {
  652           emit_rm(cbuf, 0x2, regenc, 0x4);
  653           emit_rm(cbuf, scale, indexenc, baseenc); // *
  654         }
  655         if (disp_reloc != relocInfo::none) {
  656           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  657         } else {
  658           emit_d32(cbuf, disp);
  659         }
  660       }
  661     }
  662   }
  663 }
  664 
  665 // This could be in MacroAssembler but it&#39;s fairly C2 specific
  666 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
  667   Label exit;
  668   __ jccb(Assembler::noParity, exit);
  669   __ pushf();
  670   //
  671   // comiss/ucomiss instructions set ZF,PF,CF flags and
  672   // zero OF,AF,SF for NaN values.
  673   // Fixup flags by zeroing ZF,PF so that compare of NaN
  674   // values returns &#39;less than&#39; result (CF is set).
  675   // Leave the rest of flags unchanged.
  676   //
  677   //    7 6 5 4 3 2 1 0
  678   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  679   //    0 0 1 0 1 0 1 1   (0x2B)
  680   //
  681   __ andq(Address(rsp, 0), 0xffffff2b);
  682   __ popf();
  683   __ bind(exit);
  684 }
  685 
  686 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  687   Label done;
  688   __ movl(dst, -1);
  689   __ jcc(Assembler::parity, done);
  690   __ jcc(Assembler::below, done);
  691   __ setb(Assembler::notEqual, dst);
  692   __ movzbl(dst, dst);
  693   __ bind(done);
  694 }
  695 
  696 // Math.min()    # Math.max()
  697 // --------------------------
  698 // ucomis[s/d]   #
  699 // ja   -&gt; b     # a
  700 // jp   -&gt; NaN   # NaN
  701 // jb   -&gt; a     # b
  702 // je            #
  703 // |-jz -&gt; a | b # a &amp; b
  704 // |    -&gt; a     #
  705 void emit_fp_min_max(MacroAssembler&amp; _masm, XMMRegister dst,
  706                      XMMRegister a, XMMRegister b,
  707                      XMMRegister xmmt, Register rt,
  708                      bool min, bool single) {
  709 
  710   Label nan, zero, below, above, done;
  711 
  712   if (single)
  713     __ ucomiss(a, b);
  714   else
  715     __ ucomisd(a, b);
  716 
  717   if (dst-&gt;encoding() != (min ? b : a)-&gt;encoding())
  718     __ jccb(Assembler::above, above); // CF=0 &amp; ZF=0
  719   else
  720     __ jccb(Assembler::above, done);
  721 
  722   __ jccb(Assembler::parity, nan);  // PF=1
  723   __ jccb(Assembler::below, below); // CF=1
  724 
  725   // equal
  726   __ vpxor(xmmt, xmmt, xmmt, Assembler::AVX_128bit);
  727   if (single) {
  728     __ ucomiss(a, xmmt);
  729     __ jccb(Assembler::equal, zero);
  730 
  731     __ movflt(dst, a);
  732     __ jmp(done);
  733   }
  734   else {
  735     __ ucomisd(a, xmmt);
  736     __ jccb(Assembler::equal, zero);
  737 
  738     __ movdbl(dst, a);
  739     __ jmp(done);
  740   }
  741 
  742   __ bind(zero);
  743   if (min)
  744     __ vpor(dst, a, b, Assembler::AVX_128bit);
  745   else
  746     __ vpand(dst, a, b, Assembler::AVX_128bit);
  747 
  748   __ jmp(done);
  749 
  750   __ bind(above);
  751   if (single)
  752     __ movflt(dst, min ? b : a);
  753   else
  754     __ movdbl(dst, min ? b : a);
  755 
  756   __ jmp(done);
  757 
  758   __ bind(nan);
  759   if (single) {
  760     __ movl(rt, 0x7fc00000); // Float.NaN
  761     __ movdl(dst, rt);
  762   }
  763   else {
  764     __ mov64(rt, 0x7ff8000000000000L); // Double.NaN
  765     __ movdq(dst, rt);
  766   }
  767   __ jmp(done);
  768 
  769   __ bind(below);
  770   if (single)
  771     __ movflt(dst, min ? a : b);
  772   else
  773     __ movdbl(dst, min ? a : b);
  774 
  775   __ bind(done);
  776 }
  777 
  778 //=============================================================================
  779 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  780 
  781 int ConstantTable::calculate_table_base_offset() const {
  782   return 0;  // absolute addressing, no offset
  783 }
  784 
  785 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  786 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  787   ShouldNotReachHere();
  788 }
  789 
  790 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  791   // Empty encoding
  792 }
  793 
  794 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  795   return 0;
  796 }
  797 
  798 #ifndef PRODUCT
  799 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  800   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  801 }
  802 #endif
  803 
  804 
  805 //=============================================================================
  806 #ifndef PRODUCT
  807 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  808   Compile* C = ra_-&gt;C;
  809 
  810   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  811   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
  812   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  813   // Remove wordSize for return addr which is already pushed.
  814   framesize -= wordSize;
  815 
  816   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {
  817     framesize -= wordSize;
  818     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  819     st-&gt;print(&quot;\n\t&quot;);
  820     st-&gt;print(&quot;pushq   rbp\t# Save rbp&quot;);
  821     if (PreserveFramePointer) {
  822         st-&gt;print(&quot;\n\t&quot;);
  823         st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  824     }
  825     if (framesize) {
  826       st-&gt;print(&quot;\n\t&quot;);
  827       st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  828     }
  829   } else {
  830     st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  831     st-&gt;print(&quot;\n\t&quot;);
  832     framesize -= wordSize;
  833     st-&gt;print(&quot;movq    [rsp + #%d], rbp\t# Save rbp&quot;,framesize);
  834     if (PreserveFramePointer) {
  835       st-&gt;print(&quot;\n\t&quot;);
  836       st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  837       if (framesize &gt; 0) {
  838         st-&gt;print(&quot;\n\t&quot;);
  839         st-&gt;print(&quot;addq    rbp, #%d&quot;, framesize);
  840       }
  841     }
  842   }
  843 
  844   if (VerifyStackAtCalls) {
  845     st-&gt;print(&quot;\n\t&quot;);
  846     framesize -= wordSize;
  847     st-&gt;print(&quot;movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check&quot;,framesize);
  848 #ifdef ASSERT
  849     st-&gt;print(&quot;\n\t&quot;);
  850     st-&gt;print(&quot;# stack alignment check&quot;);
  851 #endif
  852   }
  853   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  854     st-&gt;print(&quot;\n\t&quot;);
  855     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  856     st-&gt;print(&quot;\n\t&quot;);
  857     st-&gt;print(&quot;je      fast_entry\t&quot;);
  858     st-&gt;print(&quot;\n\t&quot;);
  859     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  860     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  861   }
  862   st-&gt;cr();
  863 }
  864 #endif
  865 
  866 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  867   Compile* C = ra_-&gt;C;
  868   MacroAssembler _masm(&amp;cbuf);
  869 
  870   if (C-&gt;clinit_barrier_on_entry()) {
  871     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  872     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  873 
  874     Label L_skip_barrier;
  875     Register klass = rscratch1;
  876 
  877     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  878     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  879 
  880     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  881 
  882     __ bind(L_skip_barrier);
  883   }
  884 
  885   __ verified_entry(C);
  886   __ bind(*_verified_entry);
  887 
  888   if (C-&gt;stub_function() == NULL) {
  889     BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
  890     bs-&gt;nmethod_entry_barrier(&amp;_masm);
  891   }
  892 
  893   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  894 
  895   if (C-&gt;has_mach_constant_base_node()) {
  896     // NOTE: We set the table base offset here because users might be
  897     // emitted before MachConstantBaseNode.
  898     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  899     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  900   }
  901 }
  902 
  903 int MachPrologNode::reloc() const
  904 {
  905   return 0; // a large enough number
  906 }
  907 
  908 //=============================================================================
  909 #ifndef PRODUCT
  910 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  911 {
  912   Compile* C = ra_-&gt;C;
  913   if (generate_vzeroupper(C)) {
  914     st-&gt;print(&quot;vzeroupper&quot;);
  915     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  916   }
  917 
  918   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  919   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  920   // Remove word for return adr already pushed
  921   // and RBP
  922   framesize -= 2*wordSize;
  923 
  924   if (framesize) {
  925     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  926     st-&gt;print(&quot;\t&quot;);
  927   }
  928 
  929   st-&gt;print_cr(&quot;popq    rbp&quot;);
  930   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  931     st-&gt;print(&quot;\t&quot;);
  932     st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  933                  &quot;testl   rax, [rscratch1]\t&quot;
  934                  &quot;# Safepoint: poll for GC&quot;);
  935   }
  936 }
  937 #endif
  938 
  939 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  940 {
  941   Compile* C = ra_-&gt;C;
  942   MacroAssembler _masm(&amp;cbuf);
  943 
  944   if (generate_vzeroupper(C)) {
  945     // Clear upper bits of YMM registers when current compiled code uses
  946     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  947     __ vzeroupper();
  948   }
  949 
  950   // Subtract two words to account for return address and rbp
  951   int initial_framesize = C-&gt;output()-&gt;frame_size_in_bytes() - 2*wordSize;
  952   __ remove_frame(initial_framesize, C-&gt;needs_stack_repair(), C-&gt;output()-&gt;sp_inc_offset());
  953 
  954   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  955     __ reserved_stack_check();
  956   }
  957 
  958   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  959     MacroAssembler _masm(&amp;cbuf);
  960     __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  961     __ relocate(relocInfo::poll_return_type);
  962     __ testl(rax, Address(rscratch1, 0));
  963   }
  964 }
  965 
  966 int MachEpilogNode::reloc() const
  967 {
  968   return 2; // a large enough number
  969 }
  970 
  971 const Pipeline* MachEpilogNode::pipeline() const
  972 {
  973   return MachNode::pipeline_class();
  974 }
  975 
  976 //=============================================================================
  977 
  978 enum RC {
  979   rc_bad,
  980   rc_int,
  981   rc_float,
  982   rc_stack
  983 };
  984 
  985 static enum RC rc_class(OptoReg::Name reg)
  986 {
  987   if( !OptoReg::is_valid(reg)  ) return rc_bad;
  988 
  989   if (OptoReg::is_stack(reg)) return rc_stack;
  990 
  991   VMReg r = OptoReg::as_VMReg(reg);
  992 
  993   if (r-&gt;is_Register()) return rc_int;
  994 
  995   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
  996   return rc_float;
  997 }
  998 
  999 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
 1000 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
 1001                           int src_hi, int dst_hi, uint ireg, outputStream* st);
 1002 
 1003 int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
 1004                      int stack_offset, int reg, uint ireg, outputStream* st);
 1005 
 1006 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
 1007                                       int dst_offset, uint ireg, outputStream* st) {
 1008   if (cbuf) {
 1009     MacroAssembler _masm(cbuf);
 1010     switch (ireg) {
 1011     case Op_VecS:
 1012       __ movq(Address(rsp, -8), rax);
 1013       __ movl(rax, Address(rsp, src_offset));
 1014       __ movl(Address(rsp, dst_offset), rax);
 1015       __ movq(rax, Address(rsp, -8));
 1016       break;
 1017     case Op_VecD:
 1018       __ pushq(Address(rsp, src_offset));
 1019       __ popq (Address(rsp, dst_offset));
 1020       break;
 1021     case Op_VecX:
 1022       __ pushq(Address(rsp, src_offset));
 1023       __ popq (Address(rsp, dst_offset));
 1024       __ pushq(Address(rsp, src_offset+8));
 1025       __ popq (Address(rsp, dst_offset+8));
 1026       break;
 1027     case Op_VecY:
 1028       __ vmovdqu(Address(rsp, -32), xmm0);
 1029       __ vmovdqu(xmm0, Address(rsp, src_offset));
 1030       __ vmovdqu(Address(rsp, dst_offset), xmm0);
 1031       __ vmovdqu(xmm0, Address(rsp, -32));
 1032       break;
 1033     case Op_VecZ:
 1034       __ evmovdquq(Address(rsp, -64), xmm0, 2);
 1035       __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
 1036       __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
 1037       __ evmovdquq(xmm0, Address(rsp, -64), 2);
 1038       break;
 1039     default:
 1040       ShouldNotReachHere();
 1041     }
 1042 #ifndef PRODUCT
 1043   } else {
 1044     switch (ireg) {
 1045     case Op_VecS:
 1046       st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1047                 &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1048                 &quot;movl    [rsp + #%d], rax\n\t&quot;
 1049                 &quot;movq    rax, [rsp - #8]&quot;,
 1050                 src_offset, dst_offset);
 1051       break;
 1052     case Op_VecD:
 1053       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1054                 &quot;popq    [rsp + #%d]&quot;,
 1055                 src_offset, dst_offset);
 1056       break;
 1057      case Op_VecX:
 1058       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 128-bit mem-mem spill\n\t&quot;
 1059                 &quot;popq    [rsp + #%d]\n\t&quot;
 1060                 &quot;pushq   [rsp + #%d]\n\t&quot;
 1061                 &quot;popq    [rsp + #%d]&quot;,
 1062                 src_offset, dst_offset, src_offset+8, dst_offset+8);
 1063       break;
 1064     case Op_VecY:
 1065       st-&gt;print(&quot;vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t&quot;
 1066                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1067                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1068                 &quot;vmovdqu xmm0, [rsp - #32]&quot;,
 1069                 src_offset, dst_offset);
 1070       break;
 1071     case Op_VecZ:
 1072       st-&gt;print(&quot;vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t&quot;
 1073                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1074                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1075                 &quot;vmovdqu xmm0, [rsp - #64]&quot;,
 1076                 src_offset, dst_offset);
 1077       break;
 1078     default:
 1079       ShouldNotReachHere();
 1080     }
 1081 #endif
 1082   }
 1083 }
 1084 
 1085 uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
 1086                                        PhaseRegAlloc* ra_,
 1087                                        bool do_size,
 1088                                        outputStream* st) const {
 1089   assert(cbuf != NULL || st  != NULL, &quot;sanity&quot;);
 1090   // Get registers to move
 1091   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 1092   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 1093   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this);
 1094   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this);
 1095 
 1096   enum RC src_second_rc = rc_class(src_second);
 1097   enum RC src_first_rc = rc_class(src_first);
 1098   enum RC dst_second_rc = rc_class(dst_second);
 1099   enum RC dst_first_rc = rc_class(dst_first);
 1100 
 1101   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first),
 1102          &quot;must move at least 1 register&quot; );
 1103 
 1104   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
 1105     // Self copy, no move
 1106     return 0;
 1107   }
 1108   if (bottom_type()-&gt;isa_vect() != NULL) {
 1109     uint ireg = ideal_reg();
 1110     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), &quot;sanity&quot;);
 1111     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), &quot;sanity&quot;);
 1112     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1113       // mem -&gt; mem
 1114       int src_offset = ra_-&gt;reg2offset(src_first);
 1115       int dst_offset = ra_-&gt;reg2offset(dst_first);
 1116       vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
 1117     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
 1118       vec_mov_helper(cbuf, false, src_first, dst_first, src_second, dst_second, ireg, st);
 1119     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
 1120       int stack_offset = ra_-&gt;reg2offset(dst_first);
 1121       vec_spill_helper(cbuf, false, false, stack_offset, src_first, ireg, st);
 1122     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_float ) {
 1123       int stack_offset = ra_-&gt;reg2offset(src_first);
 1124       vec_spill_helper(cbuf, false, true,  stack_offset, dst_first, ireg, st);
 1125     } else {
 1126       ShouldNotReachHere();
 1127     }
 1128     return 0;
 1129   }
 1130   if (src_first_rc == rc_stack) {
 1131     // mem -&gt;
 1132     if (dst_first_rc == rc_stack) {
 1133       // mem -&gt; mem
 1134       assert(src_second != dst_first, &quot;overlap&quot;);
 1135       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1136           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1137         // 64-bit
 1138         int src_offset = ra_-&gt;reg2offset(src_first);
 1139         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1140         if (cbuf) {
 1141           MacroAssembler _masm(cbuf);
 1142           __ pushq(Address(rsp, src_offset));
 1143           __ popq (Address(rsp, dst_offset));
 1144 #ifndef PRODUCT
 1145         } else {
 1146           st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1147                     &quot;popq    [rsp + #%d]&quot;,
 1148                      src_offset, dst_offset);
 1149 #endif
 1150         }
 1151       } else {
 1152         // 32-bit
 1153         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1154         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1155         // No pushl/popl, so:
 1156         int src_offset = ra_-&gt;reg2offset(src_first);
 1157         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1158         if (cbuf) {
 1159           MacroAssembler _masm(cbuf);
 1160           __ movq(Address(rsp, -8), rax);
 1161           __ movl(rax, Address(rsp, src_offset));
 1162           __ movl(Address(rsp, dst_offset), rax);
 1163           __ movq(rax, Address(rsp, -8));
 1164 #ifndef PRODUCT
 1165         } else {
 1166           st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1167                     &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1168                     &quot;movl    [rsp + #%d], rax\n\t&quot;
 1169                     &quot;movq    rax, [rsp - #8]&quot;,
 1170                      src_offset, dst_offset);
 1171 #endif
 1172         }
 1173       }
 1174       return 0;
 1175     } else if (dst_first_rc == rc_int) {
 1176       // mem -&gt; gpr
 1177       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1178           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1179         // 64-bit
 1180         int offset = ra_-&gt;reg2offset(src_first);
 1181         if (cbuf) {
 1182           MacroAssembler _masm(cbuf);
 1183           __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1184 #ifndef PRODUCT
 1185         } else {
 1186           st-&gt;print(&quot;movq    %s, [rsp + #%d]\t# spill&quot;,
 1187                      Matcher::regName[dst_first],
 1188                      offset);
 1189 #endif
 1190         }
 1191       } else {
 1192         // 32-bit
 1193         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1194         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1195         int offset = ra_-&gt;reg2offset(src_first);
 1196         if (cbuf) {
 1197           MacroAssembler _masm(cbuf);
 1198           __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1199 #ifndef PRODUCT
 1200         } else {
 1201           st-&gt;print(&quot;movl    %s, [rsp + #%d]\t# spill&quot;,
 1202                      Matcher::regName[dst_first],
 1203                      offset);
 1204 #endif
 1205         }
 1206       }
 1207       return 0;
 1208     } else if (dst_first_rc == rc_float) {
 1209       // mem-&gt; xmm
 1210       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1211           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1212         // 64-bit
 1213         int offset = ra_-&gt;reg2offset(src_first);
 1214         if (cbuf) {
 1215           MacroAssembler _masm(cbuf);
 1216           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1217 #ifndef PRODUCT
 1218         } else {
 1219           st-&gt;print(&quot;%s  %s, [rsp + #%d]\t# spill&quot;,
 1220                      UseXmmLoadAndClearUpper ? &quot;movsd &quot; : &quot;movlpd&quot;,
 1221                      Matcher::regName[dst_first],
 1222                      offset);
 1223 #endif
 1224         }
 1225       } else {
 1226         // 32-bit
 1227         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1228         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1229         int offset = ra_-&gt;reg2offset(src_first);
 1230         if (cbuf) {
 1231           MacroAssembler _masm(cbuf);
 1232           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1233 #ifndef PRODUCT
 1234         } else {
 1235           st-&gt;print(&quot;movss   %s, [rsp + #%d]\t# spill&quot;,
 1236                      Matcher::regName[dst_first],
 1237                      offset);
 1238 #endif
 1239         }
 1240       }
 1241       return 0;
 1242     }
 1243   } else if (src_first_rc == rc_int) {
 1244     // gpr -&gt;
 1245     if (dst_first_rc == rc_stack) {
 1246       // gpr -&gt; mem
 1247       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1248           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1249         // 64-bit
 1250         int offset = ra_-&gt;reg2offset(dst_first);
 1251         if (cbuf) {
 1252           MacroAssembler _masm(cbuf);
 1253           __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1254 #ifndef PRODUCT
 1255         } else {
 1256           st-&gt;print(&quot;movq    [rsp + #%d], %s\t# spill&quot;,
 1257                      offset,
 1258                      Matcher::regName[src_first]);
 1259 #endif
 1260         }
 1261       } else {
 1262         // 32-bit
 1263         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1264         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1265         int offset = ra_-&gt;reg2offset(dst_first);
 1266         if (cbuf) {
 1267           MacroAssembler _masm(cbuf);
 1268           __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1269 #ifndef PRODUCT
 1270         } else {
 1271           st-&gt;print(&quot;movl    [rsp + #%d], %s\t# spill&quot;,
 1272                      offset,
 1273                      Matcher::regName[src_first]);
 1274 #endif
 1275         }
 1276       }
 1277       return 0;
 1278     } else if (dst_first_rc == rc_int) {
 1279       // gpr -&gt; gpr
 1280       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1281           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1282         // 64-bit
 1283         if (cbuf) {
 1284           MacroAssembler _masm(cbuf);
 1285           __ movq(as_Register(Matcher::_regEncode[dst_first]),
 1286                   as_Register(Matcher::_regEncode[src_first]));
 1287 #ifndef PRODUCT
 1288         } else {
 1289           st-&gt;print(&quot;movq    %s, %s\t# spill&quot;,
 1290                      Matcher::regName[dst_first],
 1291                      Matcher::regName[src_first]);
 1292 #endif
 1293         }
 1294         return 0;
 1295       } else {
 1296         // 32-bit
 1297         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1298         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1299         if (cbuf) {
 1300           MacroAssembler _masm(cbuf);
 1301           __ movl(as_Register(Matcher::_regEncode[dst_first]),
 1302                   as_Register(Matcher::_regEncode[src_first]));
 1303 #ifndef PRODUCT
 1304         } else {
 1305           st-&gt;print(&quot;movl    %s, %s\t# spill&quot;,
 1306                      Matcher::regName[dst_first],
 1307                      Matcher::regName[src_first]);
 1308 #endif
 1309         }
 1310         return 0;
 1311       }
 1312     } else if (dst_first_rc == rc_float) {
 1313       // gpr -&gt; xmm
 1314       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1315           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1316         // 64-bit
 1317         if (cbuf) {
 1318           MacroAssembler _masm(cbuf);
 1319           __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1320 #ifndef PRODUCT
 1321         } else {
 1322           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1323                      Matcher::regName[dst_first],
 1324                      Matcher::regName[src_first]);
 1325 #endif
 1326         }
 1327       } else {
 1328         // 32-bit
 1329         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1330         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1331         if (cbuf) {
 1332           MacroAssembler _masm(cbuf);
 1333           __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1334 #ifndef PRODUCT
 1335         } else {
 1336           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1337                      Matcher::regName[dst_first],
 1338                      Matcher::regName[src_first]);
 1339 #endif
 1340         }
 1341       }
 1342       return 0;
 1343     }
 1344   } else if (src_first_rc == rc_float) {
 1345     // xmm -&gt;
 1346     if (dst_first_rc == rc_stack) {
 1347       // xmm -&gt; mem
 1348       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1349           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1350         // 64-bit
 1351         int offset = ra_-&gt;reg2offset(dst_first);
 1352         if (cbuf) {
 1353           MacroAssembler _masm(cbuf);
 1354           __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1355 #ifndef PRODUCT
 1356         } else {
 1357           st-&gt;print(&quot;movsd   [rsp + #%d], %s\t# spill&quot;,
 1358                      offset,
 1359                      Matcher::regName[src_first]);
 1360 #endif
 1361         }
 1362       } else {
 1363         // 32-bit
 1364         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1365         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1366         int offset = ra_-&gt;reg2offset(dst_first);
 1367         if (cbuf) {
 1368           MacroAssembler _masm(cbuf);
 1369           __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1370 #ifndef PRODUCT
 1371         } else {
 1372           st-&gt;print(&quot;movss   [rsp + #%d], %s\t# spill&quot;,
 1373                      offset,
 1374                      Matcher::regName[src_first]);
 1375 #endif
 1376         }
 1377       }
 1378       return 0;
 1379     } else if (dst_first_rc == rc_int) {
 1380       // xmm -&gt; gpr
 1381       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1382           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1383         // 64-bit
 1384         if (cbuf) {
 1385           MacroAssembler _masm(cbuf);
 1386           __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1387 #ifndef PRODUCT
 1388         } else {
 1389           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1390                      Matcher::regName[dst_first],
 1391                      Matcher::regName[src_first]);
 1392 #endif
 1393         }
 1394       } else {
 1395         // 32-bit
 1396         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1397         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1398         if (cbuf) {
 1399           MacroAssembler _masm(cbuf);
 1400           __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1401 #ifndef PRODUCT
 1402         } else {
 1403           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1404                      Matcher::regName[dst_first],
 1405                      Matcher::regName[src_first]);
 1406 #endif
 1407         }
 1408       }
 1409       return 0;
 1410     } else if (dst_first_rc == rc_float) {
 1411       // xmm -&gt; xmm
 1412       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1413           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1414         // 64-bit
 1415         if (cbuf) {
 1416           MacroAssembler _masm(cbuf);
 1417           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1418 #ifndef PRODUCT
 1419         } else {
 1420           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1421                      UseXmmRegToRegMoveAll ? &quot;movapd&quot; : &quot;movsd &quot;,
 1422                      Matcher::regName[dst_first],
 1423                      Matcher::regName[src_first]);
 1424 #endif
 1425         }
 1426       } else {
 1427         // 32-bit
 1428         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1429         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1430         if (cbuf) {
 1431           MacroAssembler _masm(cbuf);
 1432           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1433 #ifndef PRODUCT
 1434         } else {
 1435           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1436                      UseXmmRegToRegMoveAll ? &quot;movaps&quot; : &quot;movss &quot;,
 1437                      Matcher::regName[dst_first],
 1438                      Matcher::regName[src_first]);
 1439 #endif
 1440         }
 1441       }
 1442       return 0;
 1443     }
 1444   }
 1445 
 1446   assert(0,&quot; foo &quot;);
 1447   Unimplemented();
 1448   return 0;
 1449 }
 1450 
 1451 #ifndef PRODUCT
 1452 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1453   implementation(NULL, ra_, false, st);
 1454 }
 1455 #endif
 1456 
 1457 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1458   implementation(&amp;cbuf, ra_, false, NULL);
 1459 }
 1460 
 1461 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1462   return MachNode::size(ra_);
 1463 }
 1464 
 1465 //=============================================================================
 1466 #ifndef PRODUCT
 1467 void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1468 {
 1469   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1470   int reg = ra_-&gt;get_reg_first(this);
 1471   st-&gt;print(&quot;leaq    %s, [rsp + #%d]\t# box lock&quot;,
 1472             Matcher::regName[reg], offset);
 1473 }
 1474 #endif
 1475 
 1476 void BoxLockNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1477 {
 1478   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1479   int reg = ra_-&gt;get_encode(this);
 1480   if (offset &gt;= 0x80) {
 1481     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1482     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1483     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1484     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1485     emit_d32(cbuf, offset);
 1486   } else {
 1487     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1488     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1489     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1490     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1491     emit_d8(cbuf, offset);
 1492   }
 1493 }
 1494 
 1495 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1496 {
 1497   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1498   return (offset &lt; 0x80) ? 5 : 8; // REX
 1499 }
 1500 
 1501 //=============================================================================
 1502 #ifndef PRODUCT
 1503 void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1504 {
 1505   st-&gt;print_cr(&quot;MachVEPNode&quot;);
 1506 }
 1507 #endif
 1508 
 1509 void MachVEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1510 {
 1511   MacroAssembler masm(&amp;cbuf);
 1512   if (!_verified) {  
 1513     uint insts_size = cbuf.insts_size();
 1514     if (UseCompressedClassPointers) {
 1515       masm.load_klass(rscratch1, j_rarg0);
 1516       masm.cmpptr(rax, rscratch1);
 1517     } else {
 1518       masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1519     }
 1520     masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1521   } else {
 1522     // Unpack value type args passed as oop and then jump to
 1523     // the verified entry point (skipping the unverified entry).
 1524     masm.unpack_value_args(ra_-&gt;C, _receiver_only);
 1525     masm.jmp(*_verified_entry);
 1526   }
 1527 }
 1528 
 1529 //=============================================================================
 1530 #ifndef PRODUCT
 1531 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1532 {
 1533   if (UseCompressedClassPointers) {
 1534     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1535     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1536     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1537   } else {
 1538     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1539                  &quot;# Inline cache check&quot;);
 1540   }
 1541   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1542   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1543 }
 1544 #endif
 1545 
 1546 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1547 {
 1548   MacroAssembler masm(&amp;cbuf);
 1549   uint insts_size = cbuf.insts_size();
 1550   if (UseCompressedClassPointers) {
 1551     masm.load_klass(rscratch1, j_rarg0);
 1552     masm.cmpptr(rax, rscratch1);
 1553   } else {
 1554     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1555   }
 1556 
 1557   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1558 
 1559   /* WARNING these NOPs are critical so that verified entry point is properly
 1560      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1561   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1562   if (OptoBreakpoint) {
 1563     // Leave space for int3
 1564     nops_cnt -= 1;
 1565   }
 1566   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1567   if (nops_cnt &gt; 0)
 1568     masm.nop(nops_cnt);
 1569 }
 1570 
 1571 //=============================================================================
 1572 
 1573 int Matcher::regnum_to_fpu_offset(int regnum)
 1574 {
 1575   return regnum - 32; // The FP registers are in the second chunk
 1576 }
 1577 
 1578 // This is UltraSparc specific, true just means we have fast l2f conversion
 1579 const bool Matcher::convL2FSupported(void) {
 1580   return true;
 1581 }
 1582 
 1583 // Is this branch offset short enough that a short branch can be used?
 1584 //
 1585 // NOTE: If the platform does not provide any short branch variants, then
 1586 //       this method should return false for offset 0.
 1587 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1588   // The passed offset is relative to address of the branch.
 1589   // On 86 a branch displacement is calculated relative to address
 1590   // of a next instruction.
 1591   offset -= br_size;
 1592 
 1593   // the short version of jmpConUCF2 contains multiple branches,
 1594   // making the reach slightly less
 1595   if (rule == jmpConUCF2_rule)
 1596     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
 1597   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
 1598 }
 1599 
 1600 const bool Matcher::isSimpleConstant64(jlong value) {
 1601   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1602   //return value == (int) value;  // Cf. storeImmL and immL32.
 1603 
 1604   // Probably always true, even if a temp register is required.
 1605   return true;
 1606 }
 1607 
 1608 // The ecx parameter to rep stosq for the ClearArray node is in words.
 1609 const bool Matcher::init_array_count_is_in_bytes = false;
 1610 
 1611 // No additional cost for CMOVL.
 1612 const int Matcher::long_cmove_cost() { return 0; }
 1613 
 1614 // No CMOVF/CMOVD with SSE2
 1615 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1616 
 1617 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1618 const bool Matcher::require_postalloc_expand = false;
 1619 
 1620 // Do we need to mask the count passed to shift instructions or does
 1621 // the cpu only look at the lower 5/6 bits anyway?
 1622 const bool Matcher::need_masked_shift_count = false;
 1623 
 1624 bool Matcher::narrow_oop_use_complex_address() {
 1625   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1626   return (LogMinObjAlignmentInBytes &lt;= 3);
 1627 }
 1628 
 1629 bool Matcher::narrow_klass_use_complex_address() {
 1630   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1631   return (LogKlassAlignmentInBytes &lt;= 3);
 1632 }
 1633 
 1634 bool Matcher::const_oop_prefer_decode() {
 1635   // Prefer ConN+DecodeN over ConP.
 1636   return true;
 1637 }
 1638 
 1639 bool Matcher::const_klass_prefer_decode() {
 1640   // TODO: Either support matching DecodeNKlass (heap-based) in operand
 1641   //       or condisider the following:
 1642   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 1643   //return CompressedKlassPointers::base() == NULL;
 1644   return true;
 1645 }
 1646 
 1647 // Is it better to copy float constants, or load them directly from
 1648 // memory?  Intel can load a float constant from a direct address,
 1649 // requiring no extra registers.  Most RISCs will have to materialize
 1650 // an address into a register first, so they would do better to copy
 1651 // the constant from stack.
 1652 const bool Matcher::rematerialize_float_constants = true; // XXX
 1653 
 1654 // If CPU can load and store mis-aligned doubles directly then no
 1655 // fixup is needed.  Else we split the double into 2 integer pieces
 1656 // and move it piece-by-piece.  Only happens when passing doubles into
 1657 // C code as the Java calling convention forces doubles to be aligned.
 1658 const bool Matcher::misaligned_doubles_ok = true;
 1659 
 1660 // No-op on amd64
 1661 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
 1662 
 1663 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1664 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1665 
 1666 // Are floats conerted to double when stored to stack during deoptimization?
 1667 // On x64 it is stored without convertion so we can use normal access.
 1668 bool Matcher::float_in_double() { return false; }
 1669 
 1670 // Do ints take an entire long register or just half?
 1671 const bool Matcher::int_in_long = true;
 1672 
 1673 // Return whether or not this register is ever used as an argument.
 1674 // This function is used on startup to build the trampoline stubs in
 1675 // generateOptoStub.  Registers not mentioned will be killed by the VM
 1676 // call in the trampoline, and arguments in those registers not be
 1677 // available to the callee.
 1678 bool Matcher::can_be_java_arg(int reg)
 1679 {
 1680   return
 1681     reg ==  RDI_num || reg == RDI_H_num ||
 1682     reg ==  RSI_num || reg == RSI_H_num ||
 1683     reg ==  RDX_num || reg == RDX_H_num ||
 1684     reg ==  RCX_num || reg == RCX_H_num ||
 1685     reg ==   R8_num || reg ==  R8_H_num ||
 1686     reg ==   R9_num || reg ==  R9_H_num ||
 1687     reg ==  R12_num || reg == R12_H_num ||
 1688     reg == XMM0_num || reg == XMM0b_num ||
 1689     reg == XMM1_num || reg == XMM1b_num ||
 1690     reg == XMM2_num || reg == XMM2b_num ||
 1691     reg == XMM3_num || reg == XMM3b_num ||
 1692     reg == XMM4_num || reg == XMM4b_num ||
 1693     reg == XMM5_num || reg == XMM5b_num ||
 1694     reg == XMM6_num || reg == XMM6b_num ||
 1695     reg == XMM7_num || reg == XMM7b_num;
 1696 }
 1697 
 1698 bool Matcher::is_spillable_arg(int reg)
 1699 {
 1700   return can_be_java_arg(reg);
 1701 }
 1702 
 1703 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1704   // In 64 bit mode a code which use multiply when
 1705   // devisor is constant is faster than hardware
 1706   // DIV instruction (it uses MulHiL).
 1707   return false;
 1708 }
 1709 
 1710 // Register for DIVI projection of divmodI
 1711 RegMask Matcher::divI_proj_mask() {
 1712   return INT_RAX_REG_mask();
 1713 }
 1714 
 1715 // Register for MODI projection of divmodI
 1716 RegMask Matcher::modI_proj_mask() {
 1717   return INT_RDX_REG_mask();
 1718 }
 1719 
 1720 // Register for DIVL projection of divmodL
 1721 RegMask Matcher::divL_proj_mask() {
 1722   return LONG_RAX_REG_mask();
 1723 }
 1724 
 1725 // Register for MODL projection of divmodL
 1726 RegMask Matcher::modL_proj_mask() {
 1727   return LONG_RDX_REG_mask();
 1728 }
 1729 
 1730 // Register for saving SP into on method handle invokes. Not used on x86_64.
 1731 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1732     return NO_REG_mask();
 1733 }
 1734 
 1735 %}
 1736 
 1737 //----------ENCODING BLOCK-----------------------------------------------------
 1738 // This block specifies the encoding classes used by the compiler to
 1739 // output byte streams.  Encoding classes are parameterized macros
 1740 // used by Machine Instruction Nodes in order to generate the bit
 1741 // encoding of the instruction.  Operands specify their base encoding
 1742 // interface with the interface keyword.  There are currently
 1743 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
 1744 // COND_INTER.  REG_INTER causes an operand to generate a function
 1745 // which returns its register number when queried.  CONST_INTER causes
 1746 // an operand to generate a function which returns the value of the
 1747 // constant when queried.  MEMORY_INTER causes an operand to generate
 1748 // four functions which return the Base Register, the Index Register,
 1749 // the Scale Value, and the Offset Value of the operand when queried.
 1750 // COND_INTER causes an operand to generate six functions which return
 1751 // the encoding code (ie - encoding bits for the instruction)
 1752 // associated with each basic boolean condition for a conditional
 1753 // instruction.
 1754 //
 1755 // Instructions specify two basic values for encoding.  Again, a
 1756 // function is available to check if the constant displacement is an
 1757 // oop. They use the ins_encode keyword to specify their encoding
 1758 // classes (which must be a sequence of enc_class names, and their
 1759 // parameters, specified in the encoding block), and they use the
 1760 // opcode keyword to specify, in order, their primary, secondary, and
 1761 // tertiary opcode.  Only the opcode sections which a particular
 1762 // instruction needs for encoding need to be specified.
 1763 encode %{
 1764   // Build emit functions for each basic byte or larger field in the
 1765   // intel encoding scheme (opcode, rm, sib, immediate), and call them
 1766   // from C++ code in the enc_class source block.  Emit functions will
 1767   // live in the main source block for now.  In future, we can
 1768   // generalize this by adding a syntax that specifies the sizes of
 1769   // fields in an order, so that the adlc can build the emit functions
 1770   // automagically
 1771 
 1772   // Emit primary opcode
 1773   enc_class OpcP
 1774   %{
 1775     emit_opcode(cbuf, $primary);
 1776   %}
 1777 
 1778   // Emit secondary opcode
 1779   enc_class OpcS
 1780   %{
 1781     emit_opcode(cbuf, $secondary);
 1782   %}
 1783 
 1784   // Emit tertiary opcode
 1785   enc_class OpcT
 1786   %{
 1787     emit_opcode(cbuf, $tertiary);
 1788   %}
 1789 
 1790   // Emit opcode directly
 1791   enc_class Opcode(immI d8)
 1792   %{
 1793     emit_opcode(cbuf, $d8$$constant);
 1794   %}
 1795 
 1796   // Emit size prefix
 1797   enc_class SizePrefix
 1798   %{
 1799     emit_opcode(cbuf, 0x66);
 1800   %}
 1801 
 1802   enc_class reg(rRegI reg)
 1803   %{
 1804     emit_rm(cbuf, 0x3, 0, $reg$$reg &amp; 7);
 1805   %}
 1806 
 1807   enc_class reg_reg(rRegI dst, rRegI src)
 1808   %{
 1809     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1810   %}
 1811 
 1812   enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)
 1813   %{
 1814     emit_opcode(cbuf, $opcode$$constant);
 1815     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1816   %}
 1817 
 1818   enc_class cdql_enc(no_rax_rdx_RegI div)
 1819   %{
 1820     // Full implementation of Java idiv and irem; checks for
 1821     // special case as described in JVM spec., p.243 &amp; p.271.
 1822     //
 1823     //         normal case                           special case
 1824     //
 1825     // input : rax: dividend                         min_int
 1826     //         reg: divisor                          -1
 1827     //
 1828     // output: rax: quotient  (= rax idiv reg)       min_int
 1829     //         rdx: remainder (= rax irem reg)       0
 1830     //
 1831     //  Code sequnce:
 1832     //
 1833     //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
 1834     //    5:   75 07/08                jne    e &lt;normal&gt;
 1835     //    7:   33 d2                   xor    %edx,%edx
 1836     //  [div &gt;= 8 -&gt; offset + 1]
 1837     //  [REX_B]
 1838     //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
 1839     //    c:   74 03/04                je     11 &lt;done&gt;
 1840     // 000000000000000e &lt;normal&gt;:
 1841     //    e:   99                      cltd
 1842     //  [div &gt;= 8 -&gt; offset + 1]
 1843     //  [REX_B]
 1844     //    f:   f7 f9                   idiv   $div
 1845     // 0000000000000011 &lt;done&gt;:
 1846 
 1847     // cmp    $0x80000000,%eax
 1848     emit_opcode(cbuf, 0x3d);
 1849     emit_d8(cbuf, 0x00);
 1850     emit_d8(cbuf, 0x00);
 1851     emit_d8(cbuf, 0x00);
 1852     emit_d8(cbuf, 0x80);
 1853 
 1854     // jne    e &lt;normal&gt;
 1855     emit_opcode(cbuf, 0x75);
 1856     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x07 : 0x08);
 1857 
 1858     // xor    %edx,%edx
 1859     emit_opcode(cbuf, 0x33);
 1860     emit_d8(cbuf, 0xD2);
 1861 
 1862     // cmp    $0xffffffffffffffff,%ecx
 1863     if ($div$$reg &gt;= 8) {
 1864       emit_opcode(cbuf, Assembler::REX_B);
 1865     }
 1866     emit_opcode(cbuf, 0x83);
 1867     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1868     emit_d8(cbuf, 0xFF);
 1869 
 1870     // je     11 &lt;done&gt;
 1871     emit_opcode(cbuf, 0x74);
 1872     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x03 : 0x04);
 1873 
 1874     // &lt;normal&gt;
 1875     // cltd
 1876     emit_opcode(cbuf, 0x99);
 1877 
 1878     // idivl (note: must be emitted by the user of this rule)
 1879     // &lt;done&gt;
 1880   %}
 1881 
 1882   enc_class cdqq_enc(no_rax_rdx_RegL div)
 1883   %{
 1884     // Full implementation of Java ldiv and lrem; checks for
 1885     // special case as described in JVM spec., p.243 &amp; p.271.
 1886     //
 1887     //         normal case                           special case
 1888     //
 1889     // input : rax: dividend                         min_long
 1890     //         reg: divisor                          -1
 1891     //
 1892     // output: rax: quotient  (= rax idiv reg)       min_long
 1893     //         rdx: remainder (= rax irem reg)       0
 1894     //
 1895     //  Code sequnce:
 1896     //
 1897     //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
 1898     //    7:   00 00 80
 1899     //    a:   48 39 d0                cmp    %rdx,%rax
 1900     //    d:   75 08                   jne    17 &lt;normal&gt;
 1901     //    f:   33 d2                   xor    %edx,%edx
 1902     //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
 1903     //   15:   74 05                   je     1c &lt;done&gt;
 1904     // 0000000000000017 &lt;normal&gt;:
 1905     //   17:   48 99                   cqto
 1906     //   19:   48 f7 f9                idiv   $div
 1907     // 000000000000001c &lt;done&gt;:
 1908 
 1909     // mov    $0x8000000000000000,%rdx
 1910     emit_opcode(cbuf, Assembler::REX_W);
 1911     emit_opcode(cbuf, 0xBA);
 1912     emit_d8(cbuf, 0x00);
 1913     emit_d8(cbuf, 0x00);
 1914     emit_d8(cbuf, 0x00);
 1915     emit_d8(cbuf, 0x00);
 1916     emit_d8(cbuf, 0x00);
 1917     emit_d8(cbuf, 0x00);
 1918     emit_d8(cbuf, 0x00);
 1919     emit_d8(cbuf, 0x80);
 1920 
 1921     // cmp    %rdx,%rax
 1922     emit_opcode(cbuf, Assembler::REX_W);
 1923     emit_opcode(cbuf, 0x39);
 1924     emit_d8(cbuf, 0xD0);
 1925 
 1926     // jne    17 &lt;normal&gt;
 1927     emit_opcode(cbuf, 0x75);
 1928     emit_d8(cbuf, 0x08);
 1929 
 1930     // xor    %edx,%edx
 1931     emit_opcode(cbuf, 0x33);
 1932     emit_d8(cbuf, 0xD2);
 1933 
 1934     // cmp    $0xffffffffffffffff,$div
 1935     emit_opcode(cbuf, $div$$reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WB);
 1936     emit_opcode(cbuf, 0x83);
 1937     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1938     emit_d8(cbuf, 0xFF);
 1939 
 1940     // je     1e &lt;done&gt;
 1941     emit_opcode(cbuf, 0x74);
 1942     emit_d8(cbuf, 0x05);
 1943 
 1944     // &lt;normal&gt;
 1945     // cqto
 1946     emit_opcode(cbuf, Assembler::REX_W);
 1947     emit_opcode(cbuf, 0x99);
 1948 
 1949     // idivq (note: must be emitted by the user of this rule)
 1950     // &lt;done&gt;
 1951   %}
 1952 
 1953   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
 1954   enc_class OpcSE(immI imm)
 1955   %{
 1956     // Emit primary opcode and set sign-extend bit
 1957     // Check for 8-bit immediate, and set sign extend bit in opcode
 1958     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1959       emit_opcode(cbuf, $primary | 0x02);
 1960     } else {
 1961       // 32-bit immediate
 1962       emit_opcode(cbuf, $primary);
 1963     }
 1964   %}
 1965 
 1966   enc_class OpcSErm(rRegI dst, immI imm)
 1967   %{
 1968     // OpcSEr/m
 1969     int dstenc = $dst$$reg;
 1970     if (dstenc &gt;= 8) {
 1971       emit_opcode(cbuf, Assembler::REX_B);
 1972       dstenc -= 8;
 1973     }
 1974     // Emit primary opcode and set sign-extend bit
 1975     // Check for 8-bit immediate, and set sign extend bit in opcode
 1976     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1977       emit_opcode(cbuf, $primary | 0x02);
 1978     } else {
 1979       // 32-bit immediate
 1980       emit_opcode(cbuf, $primary);
 1981     }
 1982     // Emit r/m byte with secondary opcode, after primary opcode.
 1983     emit_rm(cbuf, 0x3, $secondary, dstenc);
 1984   %}
 1985 
 1986   enc_class OpcSErm_wide(rRegL dst, immI imm)
 1987   %{
 1988     // OpcSEr/m
 1989     int dstenc = $dst$$reg;
 1990     if (dstenc &lt; 8) {
 1991       emit_opcode(cbuf, Assembler::REX_W);
 1992     } else {
 1993       emit_opcode(cbuf, Assembler::REX_WB);
 1994       dstenc -= 8;
 1995     }
 1996     // Emit primary opcode and set sign-extend bit
 1997     // Check for 8-bit immediate, and set sign extend bit in opcode
 1998     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1999       emit_opcode(cbuf, $primary | 0x02);
 2000     } else {
 2001       // 32-bit immediate
 2002       emit_opcode(cbuf, $primary);
 2003     }
 2004     // Emit r/m byte with secondary opcode, after primary opcode.
 2005     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2006   %}
 2007 
 2008   enc_class Con8or32(immI imm)
 2009   %{
 2010     // Check for 8-bit immediate, and set sign extend bit in opcode
 2011     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2012       $$$emit8$imm$$constant;
 2013     } else {
 2014       // 32-bit immediate
 2015       $$$emit32$imm$$constant;
 2016     }
 2017   %}
 2018 
 2019   enc_class opc2_reg(rRegI dst)
 2020   %{
 2021     // BSWAP
 2022     emit_cc(cbuf, $secondary, $dst$$reg);
 2023   %}
 2024 
 2025   enc_class opc3_reg(rRegI dst)
 2026   %{
 2027     // BSWAP
 2028     emit_cc(cbuf, $tertiary, $dst$$reg);
 2029   %}
 2030 
 2031   enc_class reg_opc(rRegI div)
 2032   %{
 2033     // INC, DEC, IDIV, IMOD, JMP indirect, ...
 2034     emit_rm(cbuf, 0x3, $secondary, $div$$reg &amp; 7);
 2035   %}
 2036 
 2037   enc_class enc_cmov(cmpOp cop)
 2038   %{
 2039     // CMOV
 2040     $$$emit8$primary;
 2041     emit_cc(cbuf, $secondary, $cop$$cmpcode);
 2042   %}
 2043 
 2044   enc_class enc_PartialSubtypeCheck()
 2045   %{
 2046     Register Rrdi = as_Register(RDI_enc); // result register
 2047     Register Rrax = as_Register(RAX_enc); // super class
 2048     Register Rrcx = as_Register(RCX_enc); // killed
 2049     Register Rrsi = as_Register(RSI_enc); // sub class
 2050     Label miss;
 2051     const bool set_cond_codes = true;
 2052 
 2053     MacroAssembler _masm(&amp;cbuf);
 2054     __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
 2055                                      NULL, &amp;miss,
 2056                                      /*set_cond_codes:*/ true);
 2057     if ($primary) {
 2058       __ xorptr(Rrdi, Rrdi);
 2059     }
 2060     __ bind(miss);
 2061   %}
 2062 
 2063   enc_class clear_avx %{
 2064     debug_only(int off0 = cbuf.insts_size());
 2065     if (generate_vzeroupper(Compile::current())) {
 2066       // Clear upper bits of YMM registers to avoid AVX &lt;-&gt; SSE transition penalty
 2067       // Clear upper bits of YMM registers when current compiled code uses
 2068       // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 2069       MacroAssembler _masm(&amp;cbuf);
 2070       __ vzeroupper();
 2071     }
 2072     debug_only(int off1 = cbuf.insts_size());
 2073     assert(off1 - off0 == clear_avx_size(), &quot;correct size prediction&quot;);
 2074   %}
 2075 
 2076   enc_class Java_To_Runtime(method meth) %{
 2077     // No relocation needed
 2078     MacroAssembler _masm(&amp;cbuf);
 2079     __ mov64(r10, (int64_t) $meth$$method);
 2080     __ call(r10);
 2081   %}
 2082 
 2083   enc_class Java_To_Interpreter(method meth)
 2084   %{
 2085     // CALL Java_To_Interpreter
 2086     // This is the instruction starting address for relocation info.
 2087     cbuf.set_insts_mark();
 2088     $$$emit8$primary;
 2089     // CALL directly to the runtime
 2090     emit_d32_reloc(cbuf,
 2091                    (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2092                    runtime_call_Relocation::spec(),
 2093                    RELOC_DISP32);
 2094   %}
 2095 
 2096   enc_class Java_Static_Call(method meth)
 2097   %{
 2098     // JAVA STATIC CALL
 2099     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
 2100     // determine who we intended to call.
 2101     cbuf.set_insts_mark();
 2102     $$$emit8$primary;
 2103 
 2104     if (!_method) {
 2105       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2106                      runtime_call_Relocation::spec(),
 2107                      RELOC_DISP32);
 2108     } else {
 2109       int method_index = resolved_method_index(cbuf);
 2110       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2111                                                   : static_call_Relocation::spec(method_index);
 2112       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2113                      rspec, RELOC_DISP32);
 2114       // Emit stubs for static call.
 2115       address mark = cbuf.insts_mark();
 2116       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, mark);
 2117       if (stub == NULL) {
 2118         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2119         return;
 2120       }
 2121 #if INCLUDE_AOT
 2122       CompiledStaticCall::emit_to_aot_stub(cbuf, mark);
 2123 #endif
 2124     }
 2125   %}
 2126 
 2127   enc_class Java_Dynamic_Call(method meth) %{
 2128     MacroAssembler _masm(&amp;cbuf);
 2129     __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
 2130   %}
 2131 
 2132   enc_class Java_Compiled_Call(method meth)
 2133   %{
 2134     // JAVA COMPILED CALL
 2135     int disp = in_bytes(Method:: from_compiled_offset());
 2136 
 2137     // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
 2138     // assert(-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80, &quot;compiled_code_offset isn&#39;t small&quot;);
 2139 
 2140     // callq *disp(%rax)
 2141     cbuf.set_insts_mark();
 2142     $$$emit8$primary;
 2143     if (disp &lt; 0x80) {
 2144       emit_rm(cbuf, 0x01, $secondary, RAX_enc); // R/M byte
 2145       emit_d8(cbuf, disp); // Displacement
 2146     } else {
 2147       emit_rm(cbuf, 0x02, $secondary, RAX_enc); // R/M byte
 2148       emit_d32(cbuf, disp); // Displacement
 2149     }
 2150   %}
 2151 
 2152   enc_class reg_opc_imm(rRegI dst, immI8 shift)
 2153   %{
 2154     // SAL, SAR, SHR
 2155     int dstenc = $dst$$reg;
 2156     if (dstenc &gt;= 8) {
 2157       emit_opcode(cbuf, Assembler::REX_B);
 2158       dstenc -= 8;
 2159     }
 2160     $$$emit8$primary;
 2161     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2162     $$$emit8$shift$$constant;
 2163   %}
 2164 
 2165   enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)
 2166   %{
 2167     // SAL, SAR, SHR
 2168     int dstenc = $dst$$reg;
 2169     if (dstenc &lt; 8) {
 2170       emit_opcode(cbuf, Assembler::REX_W);
 2171     } else {
 2172       emit_opcode(cbuf, Assembler::REX_WB);
 2173       dstenc -= 8;
 2174     }
 2175     $$$emit8$primary;
 2176     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2177     $$$emit8$shift$$constant;
 2178   %}
 2179 
 2180   enc_class load_immI(rRegI dst, immI src)
 2181   %{
 2182     int dstenc = $dst$$reg;
 2183     if (dstenc &gt;= 8) {
 2184       emit_opcode(cbuf, Assembler::REX_B);
 2185       dstenc -= 8;
 2186     }
 2187     emit_opcode(cbuf, 0xB8 | dstenc);
 2188     $$$emit32$src$$constant;
 2189   %}
 2190 
 2191   enc_class load_immL(rRegL dst, immL src)
 2192   %{
 2193     int dstenc = $dst$$reg;
 2194     if (dstenc &lt; 8) {
 2195       emit_opcode(cbuf, Assembler::REX_W);
 2196     } else {
 2197       emit_opcode(cbuf, Assembler::REX_WB);
 2198       dstenc -= 8;
 2199     }
 2200     emit_opcode(cbuf, 0xB8 | dstenc);
 2201     emit_d64(cbuf, $src$$constant);
 2202   %}
 2203 
 2204   enc_class load_immUL32(rRegL dst, immUL32 src)
 2205   %{
 2206     // same as load_immI, but this time we care about zeroes in the high word
 2207     int dstenc = $dst$$reg;
 2208     if (dstenc &gt;= 8) {
 2209       emit_opcode(cbuf, Assembler::REX_B);
 2210       dstenc -= 8;
 2211     }
 2212     emit_opcode(cbuf, 0xB8 | dstenc);
 2213     $$$emit32$src$$constant;
 2214   %}
 2215 
 2216   enc_class load_immL32(rRegL dst, immL32 src)
 2217   %{
 2218     int dstenc = $dst$$reg;
 2219     if (dstenc &lt; 8) {
 2220       emit_opcode(cbuf, Assembler::REX_W);
 2221     } else {
 2222       emit_opcode(cbuf, Assembler::REX_WB);
 2223       dstenc -= 8;
 2224     }
 2225     emit_opcode(cbuf, 0xC7);
 2226     emit_rm(cbuf, 0x03, 0x00, dstenc);
 2227     $$$emit32$src$$constant;
 2228   %}
 2229 
 2230   enc_class load_immP31(rRegP dst, immP32 src)
 2231   %{
 2232     // same as load_immI, but this time we care about zeroes in the high word
 2233     int dstenc = $dst$$reg;
 2234     if (dstenc &gt;= 8) {
 2235       emit_opcode(cbuf, Assembler::REX_B);
 2236       dstenc -= 8;
 2237     }
 2238     emit_opcode(cbuf, 0xB8 | dstenc);
 2239     $$$emit32$src$$constant;
 2240   %}
 2241 
 2242   enc_class load_immP(rRegP dst, immP src)
 2243   %{
 2244     int dstenc = $dst$$reg;
 2245     if (dstenc &lt; 8) {
 2246       emit_opcode(cbuf, Assembler::REX_W);
 2247     } else {
 2248       emit_opcode(cbuf, Assembler::REX_WB);
 2249       dstenc -= 8;
 2250     }
 2251     emit_opcode(cbuf, 0xB8 | dstenc);
 2252     // This next line should be generated from ADLC
 2253     if ($src-&gt;constant_reloc() != relocInfo::none) {
 2254       emit_d64_reloc(cbuf, $src$$constant, $src-&gt;constant_reloc(), RELOC_IMM64);
 2255     } else {
 2256       emit_d64(cbuf, $src$$constant);
 2257     }
 2258   %}
 2259 
 2260   enc_class Con32(immI src)
 2261   %{
 2262     // Output immediate
 2263     $$$emit32$src$$constant;
 2264   %}
 2265 
 2266   enc_class Con32F_as_bits(immF src)
 2267   %{
 2268     // Output Float immediate bits
 2269     jfloat jf = $src$$constant;
 2270     jint jf_as_bits = jint_cast(jf);
 2271     emit_d32(cbuf, jf_as_bits);
 2272   %}
 2273 
 2274   enc_class Con16(immI src)
 2275   %{
 2276     // Output immediate
 2277     $$$emit16$src$$constant;
 2278   %}
 2279 
 2280   // How is this different from Con32??? XXX
 2281   enc_class Con_d32(immI src)
 2282   %{
 2283     emit_d32(cbuf,$src$$constant);
 2284   %}
 2285 
 2286   enc_class conmemref (rRegP t1) %{    // Con32(storeImmI)
 2287     // Output immediate memory reference
 2288     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
 2289     emit_d32(cbuf, 0x00);
 2290   %}
 2291 
 2292   enc_class lock_prefix()
 2293   %{
 2294     emit_opcode(cbuf, 0xF0); // lock
 2295   %}
 2296 
 2297   enc_class REX_mem(memory mem)
 2298   %{
 2299     if ($mem$$base &gt;= 8) {
 2300       if ($mem$$index &lt; 8) {
 2301         emit_opcode(cbuf, Assembler::REX_B);
 2302       } else {
 2303         emit_opcode(cbuf, Assembler::REX_XB);
 2304       }
 2305     } else {
 2306       if ($mem$$index &gt;= 8) {
 2307         emit_opcode(cbuf, Assembler::REX_X);
 2308       }
 2309     }
 2310   %}
 2311 
 2312   enc_class REX_mem_wide(memory mem)
 2313   %{
 2314     if ($mem$$base &gt;= 8) {
 2315       if ($mem$$index &lt; 8) {
 2316         emit_opcode(cbuf, Assembler::REX_WB);
 2317       } else {
 2318         emit_opcode(cbuf, Assembler::REX_WXB);
 2319       }
 2320     } else {
 2321       if ($mem$$index &lt; 8) {
 2322         emit_opcode(cbuf, Assembler::REX_W);
 2323       } else {
 2324         emit_opcode(cbuf, Assembler::REX_WX);
 2325       }
 2326     }
 2327   %}
 2328 
 2329   // for byte regs
 2330   enc_class REX_breg(rRegI reg)
 2331   %{
 2332     if ($reg$$reg &gt;= 4) {
 2333       emit_opcode(cbuf, $reg$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2334     }
 2335   %}
 2336 
 2337   // for byte regs
 2338   enc_class REX_reg_breg(rRegI dst, rRegI src)
 2339   %{
 2340     if ($dst$$reg &lt; 8) {
 2341       if ($src$$reg &gt;= 4) {
 2342         emit_opcode(cbuf, $src$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2343       }
 2344     } else {
 2345       if ($src$$reg &lt; 8) {
 2346         emit_opcode(cbuf, Assembler::REX_R);
 2347       } else {
 2348         emit_opcode(cbuf, Assembler::REX_RB);
 2349       }
 2350     }
 2351   %}
 2352 
 2353   // for byte regs
 2354   enc_class REX_breg_mem(rRegI reg, memory mem)
 2355   %{
 2356     if ($reg$$reg &lt; 8) {
 2357       if ($mem$$base &lt; 8) {
 2358         if ($mem$$index &gt;= 8) {
 2359           emit_opcode(cbuf, Assembler::REX_X);
 2360         } else if ($reg$$reg &gt;= 4) {
 2361           emit_opcode(cbuf, Assembler::REX);
 2362         }
 2363       } else {
 2364         if ($mem$$index &lt; 8) {
 2365           emit_opcode(cbuf, Assembler::REX_B);
 2366         } else {
 2367           emit_opcode(cbuf, Assembler::REX_XB);
 2368         }
 2369       }
 2370     } else {
 2371       if ($mem$$base &lt; 8) {
 2372         if ($mem$$index &lt; 8) {
 2373           emit_opcode(cbuf, Assembler::REX_R);
 2374         } else {
 2375           emit_opcode(cbuf, Assembler::REX_RX);
 2376         }
 2377       } else {
 2378         if ($mem$$index &lt; 8) {
 2379           emit_opcode(cbuf, Assembler::REX_RB);
 2380         } else {
 2381           emit_opcode(cbuf, Assembler::REX_RXB);
 2382         }
 2383       }
 2384     }
 2385   %}
 2386 
 2387   enc_class REX_reg(rRegI reg)
 2388   %{
 2389     if ($reg$$reg &gt;= 8) {
 2390       emit_opcode(cbuf, Assembler::REX_B);
 2391     }
 2392   %}
 2393 
 2394   enc_class REX_reg_wide(rRegI reg)
 2395   %{
 2396     if ($reg$$reg &lt; 8) {
 2397       emit_opcode(cbuf, Assembler::REX_W);
 2398     } else {
 2399       emit_opcode(cbuf, Assembler::REX_WB);
 2400     }
 2401   %}
 2402 
 2403   enc_class REX_reg_reg(rRegI dst, rRegI src)
 2404   %{
 2405     if ($dst$$reg &lt; 8) {
 2406       if ($src$$reg &gt;= 8) {
 2407         emit_opcode(cbuf, Assembler::REX_B);
 2408       }
 2409     } else {
 2410       if ($src$$reg &lt; 8) {
 2411         emit_opcode(cbuf, Assembler::REX_R);
 2412       } else {
 2413         emit_opcode(cbuf, Assembler::REX_RB);
 2414       }
 2415     }
 2416   %}
 2417 
 2418   enc_class REX_reg_reg_wide(rRegI dst, rRegI src)
 2419   %{
 2420     if ($dst$$reg &lt; 8) {
 2421       if ($src$$reg &lt; 8) {
 2422         emit_opcode(cbuf, Assembler::REX_W);
 2423       } else {
 2424         emit_opcode(cbuf, Assembler::REX_WB);
 2425       }
 2426     } else {
 2427       if ($src$$reg &lt; 8) {
 2428         emit_opcode(cbuf, Assembler::REX_WR);
 2429       } else {
 2430         emit_opcode(cbuf, Assembler::REX_WRB);
 2431       }
 2432     }
 2433   %}
 2434 
 2435   enc_class REX_reg_mem(rRegI reg, memory mem)
 2436   %{
 2437     if ($reg$$reg &lt; 8) {
 2438       if ($mem$$base &lt; 8) {
 2439         if ($mem$$index &gt;= 8) {
 2440           emit_opcode(cbuf, Assembler::REX_X);
 2441         }
 2442       } else {
 2443         if ($mem$$index &lt; 8) {
 2444           emit_opcode(cbuf, Assembler::REX_B);
 2445         } else {
 2446           emit_opcode(cbuf, Assembler::REX_XB);
 2447         }
 2448       }
 2449     } else {
 2450       if ($mem$$base &lt; 8) {
 2451         if ($mem$$index &lt; 8) {
 2452           emit_opcode(cbuf, Assembler::REX_R);
 2453         } else {
 2454           emit_opcode(cbuf, Assembler::REX_RX);
 2455         }
 2456       } else {
 2457         if ($mem$$index &lt; 8) {
 2458           emit_opcode(cbuf, Assembler::REX_RB);
 2459         } else {
 2460           emit_opcode(cbuf, Assembler::REX_RXB);
 2461         }
 2462       }
 2463     }
 2464   %}
 2465 
 2466   enc_class REX_reg_mem_wide(rRegL reg, memory mem)
 2467   %{
 2468     if ($reg$$reg &lt; 8) {
 2469       if ($mem$$base &lt; 8) {
 2470         if ($mem$$index &lt; 8) {
 2471           emit_opcode(cbuf, Assembler::REX_W);
 2472         } else {
 2473           emit_opcode(cbuf, Assembler::REX_WX);
 2474         }
 2475       } else {
 2476         if ($mem$$index &lt; 8) {
 2477           emit_opcode(cbuf, Assembler::REX_WB);
 2478         } else {
 2479           emit_opcode(cbuf, Assembler::REX_WXB);
 2480         }
 2481       }
 2482     } else {
 2483       if ($mem$$base &lt; 8) {
 2484         if ($mem$$index &lt; 8) {
 2485           emit_opcode(cbuf, Assembler::REX_WR);
 2486         } else {
 2487           emit_opcode(cbuf, Assembler::REX_WRX);
 2488         }
 2489       } else {
 2490         if ($mem$$index &lt; 8) {
 2491           emit_opcode(cbuf, Assembler::REX_WRB);
 2492         } else {
 2493           emit_opcode(cbuf, Assembler::REX_WRXB);
 2494         }
 2495       }
 2496     }
 2497   %}
 2498 
 2499   enc_class reg_mem(rRegI ereg, memory mem)
 2500   %{
 2501     // High registers handle in encode_RegMem
 2502     int reg = $ereg$$reg;
 2503     int base = $mem$$base;
 2504     int index = $mem$$index;
 2505     int scale = $mem$$scale;
 2506     int disp = $mem$$disp;
 2507     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
 2508 
 2509     encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
 2510   %}
 2511 
 2512   enc_class RM_opc_mem(immI rm_opcode, memory mem)
 2513   %{
 2514     int rm_byte_opcode = $rm_opcode$$constant;
 2515 
 2516     // High registers handle in encode_RegMem
 2517     int base = $mem$$base;
 2518     int index = $mem$$index;
 2519     int scale = $mem$$scale;
 2520     int displace = $mem$$disp;
 2521 
 2522     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();       // disp-as-oop when
 2523                                             // working with static
 2524                                             // globals
 2525     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
 2526                   disp_reloc);
 2527   %}
 2528 
 2529   enc_class reg_lea(rRegI dst, rRegI src0, immI src1)
 2530   %{
 2531     int reg_encoding = $dst$$reg;
 2532     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
 2533     int index        = 0x04;            // 0x04 indicates no index
 2534     int scale        = 0x00;            // 0x00 indicates no scale
 2535     int displace     = $src1$$constant; // 0x00 indicates no displacement
 2536     relocInfo::relocType disp_reloc = relocInfo::none;
 2537     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
 2538                   disp_reloc);
 2539   %}
 2540 
 2541   enc_class neg_reg(rRegI dst)
 2542   %{
 2543     int dstenc = $dst$$reg;
 2544     if (dstenc &gt;= 8) {
 2545       emit_opcode(cbuf, Assembler::REX_B);
 2546       dstenc -= 8;
 2547     }
 2548     // NEG $dst
 2549     emit_opcode(cbuf, 0xF7);
 2550     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2551   %}
 2552 
 2553   enc_class neg_reg_wide(rRegI dst)
 2554   %{
 2555     int dstenc = $dst$$reg;
 2556     if (dstenc &lt; 8) {
 2557       emit_opcode(cbuf, Assembler::REX_W);
 2558     } else {
 2559       emit_opcode(cbuf, Assembler::REX_WB);
 2560       dstenc -= 8;
 2561     }
 2562     // NEG $dst
 2563     emit_opcode(cbuf, 0xF7);
 2564     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2565   %}
 2566 
 2567   enc_class setLT_reg(rRegI dst)
 2568   %{
 2569     int dstenc = $dst$$reg;
 2570     if (dstenc &gt;= 8) {
 2571       emit_opcode(cbuf, Assembler::REX_B);
 2572       dstenc -= 8;
 2573     } else if (dstenc &gt;= 4) {
 2574       emit_opcode(cbuf, Assembler::REX);
 2575     }
 2576     // SETLT $dst
 2577     emit_opcode(cbuf, 0x0F);
 2578     emit_opcode(cbuf, 0x9C);
 2579     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2580   %}
 2581 
 2582   enc_class setNZ_reg(rRegI dst)
 2583   %{
 2584     int dstenc = $dst$$reg;
 2585     if (dstenc &gt;= 8) {
 2586       emit_opcode(cbuf, Assembler::REX_B);
 2587       dstenc -= 8;
 2588     } else if (dstenc &gt;= 4) {
 2589       emit_opcode(cbuf, Assembler::REX);
 2590     }
 2591     // SETNZ $dst
 2592     emit_opcode(cbuf, 0x0F);
 2593     emit_opcode(cbuf, 0x95);
 2594     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2595   %}
 2596 
 2597 
 2598   // Compare the lonogs and set -1, 0, or 1 into dst
 2599   enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)
 2600   %{
 2601     int src1enc = $src1$$reg;
 2602     int src2enc = $src2$$reg;
 2603     int dstenc = $dst$$reg;
 2604 
 2605     // cmpq $src1, $src2
 2606     if (src1enc &lt; 8) {
 2607       if (src2enc &lt; 8) {
 2608         emit_opcode(cbuf, Assembler::REX_W);
 2609       } else {
 2610         emit_opcode(cbuf, Assembler::REX_WB);
 2611       }
 2612     } else {
 2613       if (src2enc &lt; 8) {
 2614         emit_opcode(cbuf, Assembler::REX_WR);
 2615       } else {
 2616         emit_opcode(cbuf, Assembler::REX_WRB);
 2617       }
 2618     }
 2619     emit_opcode(cbuf, 0x3B);
 2620     emit_rm(cbuf, 0x3, src1enc &amp; 7, src2enc &amp; 7);
 2621 
 2622     // movl $dst, -1
 2623     if (dstenc &gt;= 8) {
 2624       emit_opcode(cbuf, Assembler::REX_B);
 2625     }
 2626     emit_opcode(cbuf, 0xB8 | (dstenc &amp; 7));
 2627     emit_d32(cbuf, -1);
 2628 
 2629     // jl,s done
 2630     emit_opcode(cbuf, 0x7C);
 2631     emit_d8(cbuf, dstenc &lt; 4 ? 0x06 : 0x08);
 2632 
 2633     // setne $dst
 2634     if (dstenc &gt;= 4) {
 2635       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2636     }
 2637     emit_opcode(cbuf, 0x0F);
 2638     emit_opcode(cbuf, 0x95);
 2639     emit_opcode(cbuf, 0xC0 | (dstenc &amp; 7));
 2640 
 2641     // movzbl $dst, $dst
 2642     if (dstenc &gt;= 4) {
 2643       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_RB);
 2644     }
 2645     emit_opcode(cbuf, 0x0F);
 2646     emit_opcode(cbuf, 0xB6);
 2647     emit_rm(cbuf, 0x3, dstenc &amp; 7, dstenc &amp; 7);
 2648   %}
 2649 
 2650   enc_class Push_ResultXD(regD dst) %{
 2651     MacroAssembler _masm(&amp;cbuf);
 2652     __ fstp_d(Address(rsp, 0));
 2653     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
 2654     __ addptr(rsp, 8);
 2655   %}
 2656 
 2657   enc_class Push_SrcXD(regD src) %{
 2658     MacroAssembler _masm(&amp;cbuf);
 2659     __ subptr(rsp, 8);
 2660     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2661     __ fld_d(Address(rsp, 0));
 2662   %}
 2663 
 2664 
 2665   enc_class enc_rethrow()
 2666   %{
 2667     cbuf.set_insts_mark();
 2668     emit_opcode(cbuf, 0xE9); // jmp entry
 2669     emit_d32_reloc(cbuf,
 2670                    (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
 2671                    runtime_call_Relocation::spec(),
 2672                    RELOC_DISP32);
 2673   %}
 2674 
 2675 %}
 2676 
 2677 
 2678 
 2679 //----------FRAME--------------------------------------------------------------
 2680 // Definition of frame structure and management information.
 2681 //
 2682 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2683 //                             |   (to get allocators register number
 2684 //  G  Owned by    |        |  v    add OptoReg::stack0())
 2685 //  r   CALLER     |        |
 2686 //  o     |        +--------+      pad to even-align allocators stack-slot
 2687 //  w     V        |  pad0  |        numbers; owned by CALLER
 2688 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2689 //  h     ^        |   in   |  5
 2690 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2691 //  |     |        |        |  3
 2692 //  |     |        +--------+
 2693 //  V     |        | old out|      Empty on Intel, window on Sparc
 2694 //        |    old |preserve|      Must be even aligned.
 2695 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
 2696 //        |        |   in   |  3   area for Intel ret address
 2697 //     Owned by    |preserve|      Empty on Sparc.
 2698 //       SELF      +--------+
 2699 //        |        |  pad2  |  2   pad to align old SP
 2700 //        |        +--------+  1
 2701 //        |        | locks  |  0
 2702 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
 2703 //        |        |  pad1  | 11   pad to align new SP
 2704 //        |        +--------+
 2705 //        |        |        | 10
 2706 //        |        | spills |  9   spills
 2707 //        V        |        |  8   (pad0 slot for callee)
 2708 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 2709 //        ^        |  out   |  7
 2710 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 2711 //     Owned by    +--------+
 2712 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 2713 //        |    new |preserve|      Must be even-aligned.
 2714 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 2715 //        |        |        |
 2716 //
 2717 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 2718 //         known from SELF&#39;s arguments and the Java calling convention.
 2719 //         Region 6-7 is determined per call site.
 2720 // Note 2: If the calling convention leaves holes in the incoming argument
 2721 //         area, those holes are owned by SELF.  Holes in the outgoing area
 2722 //         are owned by the CALLEE.  Holes should not be nessecary in the
 2723 //         incoming area, as the Java calling convention is completely under
 2724 //         the control of the AD file.  Doubles can be sorted and packed to
 2725 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 2726 //         varargs C calling conventions.
 2727 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 2728 //         even aligned with pad0 as needed.
 2729 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 2730 //         region 6-11 is even aligned; it may be padded out more so that
 2731 //         the region from SP to FP meets the minimum stack alignment.
 2732 // Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
 2733 //         alignment.  Region 11, pad1, may be dynamically extended so that
 2734 //         SP meets the minimum alignment.
 2735 
 2736 frame
 2737 %{
 2738   // What direction does stack grow in (assumed to be same for C &amp; Java)
 2739   stack_direction(TOWARDS_LOW);
 2740 
 2741   // These three registers define part of the calling convention
 2742   // between compiled code and the interpreter.
 2743   inline_cache_reg(RAX);                // Inline Cache Register
 2744   interpreter_method_oop_reg(RBX);      // Method Oop Register when
 2745                                         // calling interpreter
 2746 
 2747   // Optional: name the operand used by cisc-spilling to access
 2748   // [stack_pointer + offset]
 2749   cisc_spilling_operand_name(indOffset32);
 2750 
 2751   // Number of stack slots consumed by locking an object
 2752   sync_stack_slots(2);
 2753 
 2754   // Compiled code&#39;s Frame Pointer
 2755   frame_pointer(RSP);
 2756 
 2757   // Interpreter stores its frame pointer in a register which is
 2758   // stored to the stack by I2CAdaptors.
 2759   // I2CAdaptors convert from interpreted java to compiled java.
 2760   interpreter_frame_pointer(RBP);
 2761 
 2762   // Stack alignment requirement
 2763   stack_alignment(StackAlignmentInBytes); // Alignment size in bytes (128-bit -&gt; 16 bytes)
 2764 
 2765   // Number of stack slots between incoming argument block and the start of
 2766   // a new frame.  The PROLOG must add this many slots to the stack.  The
 2767   // EPILOG must remove this many slots.  amd64 needs two slots for
 2768   // return address.
 2769   in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);
 2770 
 2771   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 2772   // for calls to C.  Supports the var-args backing area for register parms.
 2773   varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes/BytesPerInt);
 2774 
 2775   // The after-PROLOG location of the return address.  Location of
 2776   // return address specifies a type (REG or STACK) and a number
 2777   // representing the register number (i.e. - use a register name) or
 2778   // stack slot.
 2779   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 2780   // Otherwise, it is above the locks and verification slot and alignment word
 2781   return_addr(STACK - 2 +
 2782               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 2783                         Compile::current()-&gt;fixed_slots()),
 2784                        stack_alignment_in_slots()));
 2785 
 2786   // Body of function which returns an integer array locating
 2787   // arguments either in registers or in stack slots.  Passed an array
 2788   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 2789   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2790   // arguments for a CALLEE.  Incoming stack arguments are
 2791   // automatically biased by the preserve_stack_slots field above.
 2792 
 2793   calling_convention
 2794   %{
 2795     // No difference between ingoing/outgoing just pass false
 2796     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 2797   %}
 2798 
 2799   c_calling_convention
 2800   %{
 2801     // This is obviously always outgoing
 2802     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 2803   %}
 2804 
 2805   // Location of compiled Java return values.  Same as C for now.
 2806   return_value
 2807   %{
 2808     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
 2809            &quot;only return normal values&quot;);
 2810 
 2811     static const int lo[Op_RegL + 1] = {
 2812       0,
 2813       0,
 2814       RAX_num,  // Op_RegN
 2815       RAX_num,  // Op_RegI
 2816       RAX_num,  // Op_RegP
 2817       XMM0_num, // Op_RegF
 2818       XMM0_num, // Op_RegD
 2819       RAX_num   // Op_RegL
 2820     };
 2821     static const int hi[Op_RegL + 1] = {
 2822       0,
 2823       0,
 2824       OptoReg::Bad, // Op_RegN
 2825       OptoReg::Bad, // Op_RegI
 2826       RAX_H_num,    // Op_RegP
 2827       OptoReg::Bad, // Op_RegF
 2828       XMM0b_num,    // Op_RegD
 2829       RAX_H_num     // Op_RegL
 2830     };
 2831     // Excluded flags and vector registers.
 2832     assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, &quot;missing type&quot;);
 2833     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
 2834   %}
 2835 %}
 2836 
 2837 //----------ATTRIBUTES---------------------------------------------------------
 2838 //----------Operand Attributes-------------------------------------------------
 2839 op_attrib op_cost(0);        // Required cost attribute
 2840 
 2841 //----------Instruction Attributes---------------------------------------------
 2842 ins_attrib ins_cost(100);       // Required cost attribute
 2843 ins_attrib ins_size(8);         // Required size attribute (in bits)
 2844 ins_attrib ins_short_branch(0); // Required flag: is this instruction
 2845                                 // a non-matching short branch variant
 2846                                 // of some long branch?
 2847 ins_attrib ins_alignment(1);    // Required alignment attribute (must
 2848                                 // be a power of 2) specifies the
 2849                                 // alignment that some part of the
 2850                                 // instruction (not necessarily the
 2851                                 // start) requires.  If &gt; 1, a
 2852                                 // compute_padding() function must be
 2853                                 // provided for the instruction
 2854 
 2855 //----------OPERANDS-----------------------------------------------------------
 2856 // Operand definitions must precede instruction definitions for correct parsing
 2857 // in the ADLC because operands constitute user defined types which are used in
 2858 // instruction definitions.
 2859 
 2860 //----------Simple Operands----------------------------------------------------
 2861 // Immediate Operands
 2862 // Integer Immediate
 2863 operand immI()
 2864 %{
 2865   match(ConI);
 2866 
 2867   op_cost(10);
 2868   format %{ %}
 2869   interface(CONST_INTER);
 2870 %}
 2871 
 2872 // Constant for test vs zero
 2873 operand immI0()
 2874 %{
 2875   predicate(n-&gt;get_int() == 0);
 2876   match(ConI);
 2877 
 2878   op_cost(0);
 2879   format %{ %}
 2880   interface(CONST_INTER);
 2881 %}
 2882 
 2883 // Constant for increment
 2884 operand immI1()
 2885 %{
 2886   predicate(n-&gt;get_int() == 1);
 2887   match(ConI);
 2888 
 2889   op_cost(0);
 2890   format %{ %}
 2891   interface(CONST_INTER);
 2892 %}
 2893 
 2894 // Constant for decrement
 2895 operand immI_M1()
 2896 %{
 2897   predicate(n-&gt;get_int() == -1);
 2898   match(ConI);
 2899 
 2900   op_cost(0);
 2901   format %{ %}
 2902   interface(CONST_INTER);
 2903 %}
 2904 
 2905 // Valid scale values for addressing modes
 2906 operand immI2()
 2907 %{
 2908   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 2909   match(ConI);
 2910 
 2911   format %{ %}
 2912   interface(CONST_INTER);
 2913 %}
 2914 
 2915 operand immI8()
 2916 %{
 2917   predicate((-0x80 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 0x80));
 2918   match(ConI);
 2919 
 2920   op_cost(5);
 2921   format %{ %}
 2922   interface(CONST_INTER);
 2923 %}
 2924 
 2925 operand immU8()
 2926 %{
 2927   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 255));
 2928   match(ConI);
 2929 
 2930   op_cost(5);
 2931   format %{ %}
 2932   interface(CONST_INTER);
 2933 %}
 2934 
 2935 operand immI16()
 2936 %{
 2937   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 2938   match(ConI);
 2939 
 2940   op_cost(10);
 2941   format %{ %}
 2942   interface(CONST_INTER);
 2943 %}
 2944 
 2945 // Int Immediate non-negative
 2946 operand immU31()
 2947 %{
 2948   predicate(n-&gt;get_int() &gt;= 0);
 2949   match(ConI);
 2950 
 2951   op_cost(0);
 2952   format %{ %}
 2953   interface(CONST_INTER);
 2954 %}
 2955 
 2956 // Constant for long shifts
 2957 operand immI_32()
 2958 %{
 2959   predicate( n-&gt;get_int() == 32 );
 2960   match(ConI);
 2961 
 2962   op_cost(0);
 2963   format %{ %}
 2964   interface(CONST_INTER);
 2965 %}
 2966 
 2967 // Constant for long shifts
 2968 operand immI_64()
 2969 %{
 2970   predicate( n-&gt;get_int() == 64 );
 2971   match(ConI);
 2972 
 2973   op_cost(0);
 2974   format %{ %}
 2975   interface(CONST_INTER);
 2976 %}
 2977 
 2978 // Pointer Immediate
 2979 operand immP()
 2980 %{
 2981   match(ConP);
 2982 
 2983   op_cost(10);
 2984   format %{ %}
 2985   interface(CONST_INTER);
 2986 %}
 2987 
 2988 // NULL Pointer Immediate
 2989 operand immP0()
 2990 %{
 2991   predicate(n-&gt;get_ptr() == 0);
 2992   match(ConP);
 2993 
 2994   op_cost(5);
 2995   format %{ %}
 2996   interface(CONST_INTER);
 2997 %}
 2998 
 2999 // Pointer Immediate
 3000 operand immN() %{
 3001   match(ConN);
 3002 
 3003   op_cost(10);
 3004   format %{ %}
 3005   interface(CONST_INTER);
 3006 %}
 3007 
 3008 operand immNKlass() %{
 3009   match(ConNKlass);
 3010 
 3011   op_cost(10);
 3012   format %{ %}
 3013   interface(CONST_INTER);
 3014 %}
 3015 
 3016 // NULL Pointer Immediate
 3017 operand immN0() %{
 3018   predicate(n-&gt;get_narrowcon() == 0);
 3019   match(ConN);
 3020 
 3021   op_cost(5);
 3022   format %{ %}
 3023   interface(CONST_INTER);
 3024 %}
 3025 
 3026 operand immP31()
 3027 %{
 3028   predicate(n-&gt;as_Type()-&gt;type()-&gt;reloc() == relocInfo::none
 3029             &amp;&amp; (n-&gt;get_ptr() &gt;&gt; 31) == 0);
 3030   match(ConP);
 3031 
 3032   op_cost(5);
 3033   format %{ %}
 3034   interface(CONST_INTER);
 3035 %}
 3036 
 3037 
 3038 // Long Immediate
 3039 operand immL()
 3040 %{
 3041   match(ConL);
 3042 
 3043   op_cost(20);
 3044   format %{ %}
 3045   interface(CONST_INTER);
 3046 %}
 3047 
 3048 // Long Immediate 8-bit
 3049 operand immL8()
 3050 %{
 3051   predicate(-0x80L &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80L);
 3052   match(ConL);
 3053 
 3054   op_cost(5);
 3055   format %{ %}
 3056   interface(CONST_INTER);
 3057 %}
 3058 
 3059 // Long Immediate 32-bit unsigned
 3060 operand immUL32()
 3061 %{
 3062   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
 3063   match(ConL);
 3064 
 3065   op_cost(10);
 3066   format %{ %}
 3067   interface(CONST_INTER);
 3068 %}
 3069 
 3070 // Long Immediate 32-bit signed
 3071 operand immL32()
 3072 %{
 3073   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
 3074   match(ConL);
 3075 
 3076   op_cost(15);
 3077   format %{ %}
 3078   interface(CONST_INTER);
 3079 %}
 3080 
 3081 operand immL_Pow2()
 3082 %{
 3083   predicate(is_power_of_2((julong)n-&gt;get_long()));
 3084   match(ConL);
 3085 
 3086   op_cost(15);
 3087   format %{ %}
 3088   interface(CONST_INTER);
 3089 %}
 3090 
 3091 operand immL_NotPow2()
 3092 %{
 3093   predicate(is_power_of_2((julong)~n-&gt;get_long()));
 3094   match(ConL);
 3095 
 3096   op_cost(15);
 3097   format %{ %}
 3098   interface(CONST_INTER);
 3099 %}
 3100 
 3101 // Long Immediate zero
 3102 operand immL0()
 3103 %{
 3104   predicate(n-&gt;get_long() == 0L);
 3105   match(ConL);
 3106 
 3107   op_cost(10);
 3108   format %{ %}
 3109   interface(CONST_INTER);
 3110 %}
 3111 
 3112 // Constant for increment
 3113 operand immL1()
 3114 %{
 3115   predicate(n-&gt;get_long() == 1);
 3116   match(ConL);
 3117 
 3118   format %{ %}
 3119   interface(CONST_INTER);
 3120 %}
 3121 
 3122 // Constant for decrement
 3123 operand immL_M1()
 3124 %{
 3125   predicate(n-&gt;get_long() == -1);
 3126   match(ConL);
 3127 
 3128   format %{ %}
 3129   interface(CONST_INTER);
 3130 %}
 3131 
 3132 // Long Immediate: the value 10
 3133 operand immL10()
 3134 %{
 3135   predicate(n-&gt;get_long() == 10);
 3136   match(ConL);
 3137 
 3138   format %{ %}
 3139   interface(CONST_INTER);
 3140 %}
 3141 
 3142 // Long immediate from 0 to 127.
 3143 // Used for a shorter form of long mul by 10.
 3144 operand immL_127()
 3145 %{
 3146   predicate(0 &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80);
 3147   match(ConL);
 3148 
 3149   op_cost(10);
 3150   format %{ %}
 3151   interface(CONST_INTER);
 3152 %}
 3153 
 3154 // Long Immediate: low 32-bit mask
 3155 operand immL_32bits()
 3156 %{
 3157   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3158   match(ConL);
 3159   op_cost(20);
 3160 
 3161   format %{ %}
 3162   interface(CONST_INTER);
 3163 %}
 3164 
 3165 // Float Immediate zero
 3166 operand immF0()
 3167 %{
 3168   predicate(jint_cast(n-&gt;getf()) == 0);
 3169   match(ConF);
 3170 
 3171   op_cost(5);
 3172   format %{ %}
 3173   interface(CONST_INTER);
 3174 %}
 3175 
 3176 // Float Immediate
 3177 operand immF()
 3178 %{
 3179   match(ConF);
 3180 
 3181   op_cost(15);
 3182   format %{ %}
 3183   interface(CONST_INTER);
 3184 %}
 3185 
 3186 // Double Immediate zero
 3187 operand immD0()
 3188 %{
 3189   predicate(jlong_cast(n-&gt;getd()) == 0);
 3190   match(ConD);
 3191 
 3192   op_cost(5);
 3193   format %{ %}
 3194   interface(CONST_INTER);
 3195 %}
 3196 
 3197 // Double Immediate
 3198 operand immD()
 3199 %{
 3200   match(ConD);
 3201 
 3202   op_cost(15);
 3203   format %{ %}
 3204   interface(CONST_INTER);
 3205 %}
 3206 
 3207 // Immediates for special shifts (sign extend)
 3208 
 3209 // Constants for increment
 3210 operand immI_16()
 3211 %{
 3212   predicate(n-&gt;get_int() == 16);
 3213   match(ConI);
 3214 
 3215   format %{ %}
 3216   interface(CONST_INTER);
 3217 %}
 3218 
 3219 operand immI_24()
 3220 %{
 3221   predicate(n-&gt;get_int() == 24);
 3222   match(ConI);
 3223 
 3224   format %{ %}
 3225   interface(CONST_INTER);
 3226 %}
 3227 
 3228 // Constant for byte-wide masking
 3229 operand immI_255()
 3230 %{
 3231   predicate(n-&gt;get_int() == 255);
 3232   match(ConI);
 3233 
 3234   format %{ %}
 3235   interface(CONST_INTER);
 3236 %}
 3237 
 3238 // Constant for short-wide masking
 3239 operand immI_65535()
 3240 %{
 3241   predicate(n-&gt;get_int() == 65535);
 3242   match(ConI);
 3243 
 3244   format %{ %}
 3245   interface(CONST_INTER);
 3246 %}
 3247 
 3248 // Constant for byte-wide masking
 3249 operand immL_255()
 3250 %{
 3251   predicate(n-&gt;get_long() == 255);
 3252   match(ConL);
 3253 
 3254   format %{ %}
 3255   interface(CONST_INTER);
 3256 %}
 3257 
 3258 // Constant for short-wide masking
 3259 operand immL_65535()
 3260 %{
 3261   predicate(n-&gt;get_long() == 65535);
 3262   match(ConL);
 3263 
 3264   format %{ %}
 3265   interface(CONST_INTER);
 3266 %}
 3267 
 3268 // Register Operands
 3269 // Integer Register
 3270 operand rRegI()
 3271 %{
 3272   constraint(ALLOC_IN_RC(int_reg));
 3273   match(RegI);
 3274 
 3275   match(rax_RegI);
 3276   match(rbx_RegI);
 3277   match(rcx_RegI);
 3278   match(rdx_RegI);
 3279   match(rdi_RegI);
 3280 
 3281   format %{ %}
 3282   interface(REG_INTER);
 3283 %}
 3284 
 3285 // Special Registers
 3286 operand rax_RegI()
 3287 %{
 3288   constraint(ALLOC_IN_RC(int_rax_reg));
 3289   match(RegI);
 3290   match(rRegI);
 3291 
 3292   format %{ &quot;RAX&quot; %}
 3293   interface(REG_INTER);
 3294 %}
 3295 
 3296 // Special Registers
 3297 operand rbx_RegI()
 3298 %{
 3299   constraint(ALLOC_IN_RC(int_rbx_reg));
 3300   match(RegI);
 3301   match(rRegI);
 3302 
 3303   format %{ &quot;RBX&quot; %}
 3304   interface(REG_INTER);
 3305 %}
 3306 
 3307 operand rcx_RegI()
 3308 %{
 3309   constraint(ALLOC_IN_RC(int_rcx_reg));
 3310   match(RegI);
 3311   match(rRegI);
 3312 
 3313   format %{ &quot;RCX&quot; %}
 3314   interface(REG_INTER);
 3315 %}
 3316 
 3317 operand rdx_RegI()
 3318 %{
 3319   constraint(ALLOC_IN_RC(int_rdx_reg));
 3320   match(RegI);
 3321   match(rRegI);
 3322 
 3323   format %{ &quot;RDX&quot; %}
 3324   interface(REG_INTER);
 3325 %}
 3326 
 3327 operand rdi_RegI()
 3328 %{
 3329   constraint(ALLOC_IN_RC(int_rdi_reg));
 3330   match(RegI);
 3331   match(rRegI);
 3332 
 3333   format %{ &quot;RDI&quot; %}
 3334   interface(REG_INTER);
 3335 %}
 3336 
 3337 operand no_rcx_RegI()
 3338 %{
 3339   constraint(ALLOC_IN_RC(int_no_rcx_reg));
 3340   match(RegI);
 3341   match(rax_RegI);
 3342   match(rbx_RegI);
 3343   match(rdx_RegI);
 3344   match(rdi_RegI);
 3345 
 3346   format %{ %}
 3347   interface(REG_INTER);
 3348 %}
 3349 
 3350 operand no_rax_rdx_RegI()
 3351 %{
 3352   constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));
 3353   match(RegI);
 3354   match(rbx_RegI);
 3355   match(rcx_RegI);
 3356   match(rdi_RegI);
 3357 
 3358   format %{ %}
 3359   interface(REG_INTER);
 3360 %}
 3361 
 3362 // Pointer Register
 3363 operand any_RegP()
 3364 %{
 3365   constraint(ALLOC_IN_RC(any_reg));
 3366   match(RegP);
 3367   match(rax_RegP);
 3368   match(rbx_RegP);
 3369   match(rdi_RegP);
 3370   match(rsi_RegP);
 3371   match(rbp_RegP);
 3372   match(r15_RegP);
 3373   match(rRegP);
 3374 
 3375   format %{ %}
 3376   interface(REG_INTER);
 3377 %}
 3378 
 3379 operand rRegP()
 3380 %{
 3381   constraint(ALLOC_IN_RC(ptr_reg));
 3382   match(RegP);
 3383   match(rax_RegP);
 3384   match(rbx_RegP);
 3385   match(rdi_RegP);
 3386   match(rsi_RegP);
 3387   match(rbp_RegP);  // See Q&amp;A below about
 3388   match(r15_RegP);  // r15_RegP and rbp_RegP.
 3389 
 3390   format %{ %}
 3391   interface(REG_INTER);
 3392 %}
 3393 
 3394 operand rRegN() %{
 3395   constraint(ALLOC_IN_RC(int_reg));
 3396   match(RegN);
 3397 
 3398   format %{ %}
 3399   interface(REG_INTER);
 3400 %}
 3401 
 3402 // Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?
 3403 // Answer: Operand match rules govern the DFA as it processes instruction inputs.
 3404 // It&#39;s fine for an instruction input that expects rRegP to match a r15_RegP.
 3405 // The output of an instruction is controlled by the allocator, which respects
 3406 // register class masks, not match rules.  Unless an instruction mentions
 3407 // r15_RegP or any_RegP explicitly as its output, r15 will not be considered
 3408 // by the allocator as an input.
 3409 // The same logic applies to rbp_RegP being a match for rRegP: If PreserveFramePointer==true,
 3410 // the RBP is used as a proper frame pointer and is not included in ptr_reg. As a
 3411 // result, RBP is not included in the output of the instruction either.
 3412 
 3413 operand no_rax_RegP()
 3414 %{
 3415   constraint(ALLOC_IN_RC(ptr_no_rax_reg));
 3416   match(RegP);
 3417   match(rbx_RegP);
 3418   match(rsi_RegP);
 3419   match(rdi_RegP);
 3420 
 3421   format %{ %}
 3422   interface(REG_INTER);
 3423 %}
 3424 
 3425 // This operand is not allowed to use RBP even if
 3426 // RBP is not used to hold the frame pointer.
 3427 operand no_rbp_RegP()
 3428 %{
 3429   constraint(ALLOC_IN_RC(ptr_reg_no_rbp));
 3430   match(RegP);
 3431   match(rbx_RegP);
 3432   match(rsi_RegP);
 3433   match(rdi_RegP);
 3434 
 3435   format %{ %}
 3436   interface(REG_INTER);
 3437 %}
 3438 
 3439 operand no_rax_rbx_RegP()
 3440 %{
 3441   constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));
 3442   match(RegP);
 3443   match(rsi_RegP);
 3444   match(rdi_RegP);
 3445 
 3446   format %{ %}
 3447   interface(REG_INTER);
 3448 %}
 3449 
 3450 // Special Registers
 3451 // Return a pointer value
 3452 operand rax_RegP()
 3453 %{
 3454   constraint(ALLOC_IN_RC(ptr_rax_reg));
 3455   match(RegP);
 3456   match(rRegP);
 3457 
 3458   format %{ %}
 3459   interface(REG_INTER);
 3460 %}
 3461 
 3462 // Special Registers
 3463 // Return a compressed pointer value
 3464 operand rax_RegN()
 3465 %{
 3466   constraint(ALLOC_IN_RC(int_rax_reg));
 3467   match(RegN);
 3468   match(rRegN);
 3469 
 3470   format %{ %}
 3471   interface(REG_INTER);
 3472 %}
 3473 
 3474 // Used in AtomicAdd
 3475 operand rbx_RegP()
 3476 %{
 3477   constraint(ALLOC_IN_RC(ptr_rbx_reg));
 3478   match(RegP);
 3479   match(rRegP);
 3480 
 3481   format %{ %}
 3482   interface(REG_INTER);
 3483 %}
 3484 
 3485 operand rsi_RegP()
 3486 %{
 3487   constraint(ALLOC_IN_RC(ptr_rsi_reg));
 3488   match(RegP);
 3489   match(rRegP);
 3490 
 3491   format %{ %}
 3492   interface(REG_INTER);
 3493 %}
 3494 
 3495 operand rbp_RegP()
 3496 %{
 3497   constraint(ALLOC_IN_RC(ptr_rbp_reg));
 3498   match(RegP);
 3499   match(rRegP);
 3500 
 3501   format %{ %}
 3502   interface(REG_INTER);
 3503 %}
 3504 
 3505 // Used in rep stosq
 3506 operand rdi_RegP()
 3507 %{
 3508   constraint(ALLOC_IN_RC(ptr_rdi_reg));
 3509   match(RegP);
 3510   match(rRegP);
 3511 
 3512   format %{ %}
 3513   interface(REG_INTER);
 3514 %}
 3515 
 3516 operand r15_RegP()
 3517 %{
 3518   constraint(ALLOC_IN_RC(ptr_r15_reg));
 3519   match(RegP);
 3520   match(rRegP);
 3521 
 3522   format %{ %}
 3523   interface(REG_INTER);
 3524 %}
 3525 
 3526 operand rRegL()
 3527 %{
 3528   constraint(ALLOC_IN_RC(long_reg));
 3529   match(RegL);
 3530   match(rax_RegL);
 3531   match(rdx_RegL);
 3532 
 3533   format %{ %}
 3534   interface(REG_INTER);
 3535 %}
 3536 
 3537 // Special Registers
 3538 operand no_rax_rdx_RegL()
 3539 %{
 3540   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3541   match(RegL);
 3542   match(rRegL);
 3543 
 3544   format %{ %}
 3545   interface(REG_INTER);
 3546 %}
 3547 
 3548 operand no_rax_RegL()
 3549 %{
 3550   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3551   match(RegL);
 3552   match(rRegL);
 3553   match(rdx_RegL);
 3554 
 3555   format %{ %}
 3556   interface(REG_INTER);
 3557 %}
 3558 
 3559 operand no_rcx_RegL()
 3560 %{
 3561   constraint(ALLOC_IN_RC(long_no_rcx_reg));
 3562   match(RegL);
 3563   match(rRegL);
 3564 
 3565   format %{ %}
 3566   interface(REG_INTER);
 3567 %}
 3568 
 3569 operand rax_RegL()
 3570 %{
 3571   constraint(ALLOC_IN_RC(long_rax_reg));
 3572   match(RegL);
 3573   match(rRegL);
 3574 
 3575   format %{ &quot;RAX&quot; %}
 3576   interface(REG_INTER);
 3577 %}
 3578 
 3579 operand rcx_RegL()
 3580 %{
 3581   constraint(ALLOC_IN_RC(long_rcx_reg));
 3582   match(RegL);
 3583   match(rRegL);
 3584 
 3585   format %{ %}
 3586   interface(REG_INTER);
 3587 %}
 3588 
 3589 operand rdx_RegL()
 3590 %{
 3591   constraint(ALLOC_IN_RC(long_rdx_reg));
 3592   match(RegL);
 3593   match(rRegL);
 3594 
 3595   format %{ %}
 3596   interface(REG_INTER);
 3597 %}
 3598 
 3599 // Flags register, used as output of compare instructions
 3600 operand rFlagsReg()
 3601 %{
 3602   constraint(ALLOC_IN_RC(int_flags));
 3603   match(RegFlags);
 3604 
 3605   format %{ &quot;RFLAGS&quot; %}
 3606   interface(REG_INTER);
 3607 %}
 3608 
 3609 // Flags register, used as output of FLOATING POINT compare instructions
 3610 operand rFlagsRegU()
 3611 %{
 3612   constraint(ALLOC_IN_RC(int_flags));
 3613   match(RegFlags);
 3614 
 3615   format %{ &quot;RFLAGS_U&quot; %}
 3616   interface(REG_INTER);
 3617 %}
 3618 
 3619 operand rFlagsRegUCF() %{
 3620   constraint(ALLOC_IN_RC(int_flags));
 3621   match(RegFlags);
 3622   predicate(false);
 3623 
 3624   format %{ &quot;RFLAGS_U_CF&quot; %}
 3625   interface(REG_INTER);
 3626 %}
 3627 
 3628 // Float register operands
 3629 operand regF() %{
 3630    constraint(ALLOC_IN_RC(float_reg));
 3631    match(RegF);
 3632 
 3633    format %{ %}
 3634    interface(REG_INTER);
 3635 %}
 3636 
 3637 // Float register operands
 3638 operand legRegF() %{
 3639    constraint(ALLOC_IN_RC(float_reg_legacy));
 3640    match(RegF);
 3641 
 3642    format %{ %}
 3643    interface(REG_INTER);
 3644 %}
 3645 
 3646 // Float register operands
 3647 operand vlRegF() %{
 3648    constraint(ALLOC_IN_RC(float_reg_vl));
 3649    match(RegF);
 3650 
 3651    format %{ %}
 3652    interface(REG_INTER);
 3653 %}
 3654 
 3655 // Double register operands
 3656 operand regD() %{
 3657    constraint(ALLOC_IN_RC(double_reg));
 3658    match(RegD);
 3659 
 3660    format %{ %}
 3661    interface(REG_INTER);
 3662 %}
 3663 
 3664 // Double register operands
 3665 operand legRegD() %{
 3666    constraint(ALLOC_IN_RC(double_reg_legacy));
 3667    match(RegD);
 3668 
 3669    format %{ %}
 3670    interface(REG_INTER);
 3671 %}
 3672 
 3673 // Double register operands
 3674 operand vlRegD() %{
 3675    constraint(ALLOC_IN_RC(double_reg_vl));
 3676    match(RegD);
 3677 
 3678    format %{ %}
 3679    interface(REG_INTER);
 3680 %}
 3681 
 3682 //----------Memory Operands----------------------------------------------------
 3683 // Direct Memory Operand
 3684 // operand direct(immP addr)
 3685 // %{
 3686 //   match(addr);
 3687 
 3688 //   format %{ &quot;[$addr]&quot; %}
 3689 //   interface(MEMORY_INTER) %{
 3690 //     base(0xFFFFFFFF);
 3691 //     index(0x4);
 3692 //     scale(0x0);
 3693 //     disp($addr);
 3694 //   %}
 3695 // %}
 3696 
 3697 // Indirect Memory Operand
 3698 operand indirect(any_RegP reg)
 3699 %{
 3700   constraint(ALLOC_IN_RC(ptr_reg));
 3701   match(reg);
 3702 
 3703   format %{ &quot;[$reg]&quot; %}
 3704   interface(MEMORY_INTER) %{
 3705     base($reg);
 3706     index(0x4);
 3707     scale(0x0);
 3708     disp(0x0);
 3709   %}
 3710 %}
 3711 
 3712 // Indirect Memory Plus Short Offset Operand
 3713 operand indOffset8(any_RegP reg, immL8 off)
 3714 %{
 3715   constraint(ALLOC_IN_RC(ptr_reg));
 3716   match(AddP reg off);
 3717 
 3718   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3719   interface(MEMORY_INTER) %{
 3720     base($reg);
 3721     index(0x4);
 3722     scale(0x0);
 3723     disp($off);
 3724   %}
 3725 %}
 3726 
 3727 // Indirect Memory Plus Long Offset Operand
 3728 operand indOffset32(any_RegP reg, immL32 off)
 3729 %{
 3730   constraint(ALLOC_IN_RC(ptr_reg));
 3731   match(AddP reg off);
 3732 
 3733   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3734   interface(MEMORY_INTER) %{
 3735     base($reg);
 3736     index(0x4);
 3737     scale(0x0);
 3738     disp($off);
 3739   %}
 3740 %}
 3741 
 3742 // Indirect Memory Plus Index Register Plus Offset Operand
 3743 operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)
 3744 %{
 3745   constraint(ALLOC_IN_RC(ptr_reg));
 3746   match(AddP (AddP reg lreg) off);
 3747 
 3748   op_cost(10);
 3749   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3750   interface(MEMORY_INTER) %{
 3751     base($reg);
 3752     index($lreg);
 3753     scale(0x0);
 3754     disp($off);
 3755   %}
 3756 %}
 3757 
 3758 // Indirect Memory Plus Index Register Plus Offset Operand
 3759 operand indIndex(any_RegP reg, rRegL lreg)
 3760 %{
 3761   constraint(ALLOC_IN_RC(ptr_reg));
 3762   match(AddP reg lreg);
 3763 
 3764   op_cost(10);
 3765   format %{&quot;[$reg + $lreg]&quot; %}
 3766   interface(MEMORY_INTER) %{
 3767     base($reg);
 3768     index($lreg);
 3769     scale(0x0);
 3770     disp(0x0);
 3771   %}
 3772 %}
 3773 
 3774 // Indirect Memory Times Scale Plus Index Register
 3775 operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)
 3776 %{
 3777   constraint(ALLOC_IN_RC(ptr_reg));
 3778   match(AddP reg (LShiftL lreg scale));
 3779 
 3780   op_cost(10);
 3781   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3782   interface(MEMORY_INTER) %{
 3783     base($reg);
 3784     index($lreg);
 3785     scale($scale);
 3786     disp(0x0);
 3787   %}
 3788 %}
 3789 
 3790 operand indPosIndexScale(any_RegP reg, rRegI idx, immI2 scale)
 3791 %{
 3792   constraint(ALLOC_IN_RC(ptr_reg));
 3793   predicate(n-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3794   match(AddP reg (LShiftL (ConvI2L idx) scale));
 3795 
 3796   op_cost(10);
 3797   format %{&quot;[$reg + pos $idx &lt;&lt; $scale]&quot; %}
 3798   interface(MEMORY_INTER) %{
 3799     base($reg);
 3800     index($idx);
 3801     scale($scale);
 3802     disp(0x0);
 3803   %}
 3804 %}
 3805 
 3806 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3807 operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)
 3808 %{
 3809   constraint(ALLOC_IN_RC(ptr_reg));
 3810   match(AddP (AddP reg (LShiftL lreg scale)) off);
 3811 
 3812   op_cost(10);
 3813   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3814   interface(MEMORY_INTER) %{
 3815     base($reg);
 3816     index($lreg);
 3817     scale($scale);
 3818     disp($off);
 3819   %}
 3820 %}
 3821 
 3822 // Indirect Memory Plus Positive Index Register Plus Offset Operand
 3823 operand indPosIndexOffset(any_RegP reg, immL32 off, rRegI idx)
 3824 %{
 3825   constraint(ALLOC_IN_RC(ptr_reg));
 3826   predicate(n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3827   match(AddP (AddP reg (ConvI2L idx)) off);
 3828 
 3829   op_cost(10);
 3830   format %{&quot;[$reg + $off + $idx]&quot; %}
 3831   interface(MEMORY_INTER) %{
 3832     base($reg);
 3833     index($idx);
 3834     scale(0x0);
 3835     disp($off);
 3836   %}
 3837 %}
 3838 
 3839 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3840 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3841 %{
 3842   constraint(ALLOC_IN_RC(ptr_reg));
 3843   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3844   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3845 
 3846   op_cost(10);
 3847   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3848   interface(MEMORY_INTER) %{
 3849     base($reg);
 3850     index($idx);
 3851     scale($scale);
 3852     disp($off);
 3853   %}
 3854 %}
 3855 
 3856 // Indirect Narrow Oop Operand
 3857 operand indCompressedOop(rRegN reg) %{
 3858   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3859   constraint(ALLOC_IN_RC(ptr_reg));
 3860   match(DecodeN reg);
 3861 
 3862   op_cost(10);
 3863   format %{&quot;[R12 + $reg &lt;&lt; 3] (compressed oop addressing)&quot; %}
 3864   interface(MEMORY_INTER) %{
 3865     base(0xc); // R12
 3866     index($reg);
 3867     scale(0x3);
 3868     disp(0x0);
 3869   %}
 3870 %}
 3871 
 3872 // Indirect Narrow Oop Plus Offset Operand
 3873 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3874 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3875 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3876   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3877   constraint(ALLOC_IN_RC(ptr_reg));
 3878   match(AddP (DecodeN reg) off);
 3879 
 3880   op_cost(10);
 3881   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3882   interface(MEMORY_INTER) %{
 3883     base(0xc); // R12
 3884     index($reg);
 3885     scale(0x3);
 3886     disp($off);
 3887   %}
 3888 %}
 3889 
 3890 // Indirect Memory Operand
 3891 operand indirectNarrow(rRegN reg)
 3892 %{
 3893   predicate(CompressedOops::shift() == 0);
 3894   constraint(ALLOC_IN_RC(ptr_reg));
 3895   match(DecodeN reg);
 3896 
 3897   format %{ &quot;[$reg]&quot; %}
 3898   interface(MEMORY_INTER) %{
 3899     base($reg);
 3900     index(0x4);
 3901     scale(0x0);
 3902     disp(0x0);
 3903   %}
 3904 %}
 3905 
 3906 // Indirect Memory Plus Short Offset Operand
 3907 operand indOffset8Narrow(rRegN reg, immL8 off)
 3908 %{
 3909   predicate(CompressedOops::shift() == 0);
 3910   constraint(ALLOC_IN_RC(ptr_reg));
 3911   match(AddP (DecodeN reg) off);
 3912 
 3913   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3914   interface(MEMORY_INTER) %{
 3915     base($reg);
 3916     index(0x4);
 3917     scale(0x0);
 3918     disp($off);
 3919   %}
 3920 %}
 3921 
 3922 // Indirect Memory Plus Long Offset Operand
 3923 operand indOffset32Narrow(rRegN reg, immL32 off)
 3924 %{
 3925   predicate(CompressedOops::shift() == 0);
 3926   constraint(ALLOC_IN_RC(ptr_reg));
 3927   match(AddP (DecodeN reg) off);
 3928 
 3929   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3930   interface(MEMORY_INTER) %{
 3931     base($reg);
 3932     index(0x4);
 3933     scale(0x0);
 3934     disp($off);
 3935   %}
 3936 %}
 3937 
 3938 // Indirect Memory Plus Index Register Plus Offset Operand
 3939 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
 3940 %{
 3941   predicate(CompressedOops::shift() == 0);
 3942   constraint(ALLOC_IN_RC(ptr_reg));
 3943   match(AddP (AddP (DecodeN reg) lreg) off);
 3944 
 3945   op_cost(10);
 3946   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3947   interface(MEMORY_INTER) %{
 3948     base($reg);
 3949     index($lreg);
 3950     scale(0x0);
 3951     disp($off);
 3952   %}
 3953 %}
 3954 
 3955 // Indirect Memory Plus Index Register Plus Offset Operand
 3956 operand indIndexNarrow(rRegN reg, rRegL lreg)
 3957 %{
 3958   predicate(CompressedOops::shift() == 0);
 3959   constraint(ALLOC_IN_RC(ptr_reg));
 3960   match(AddP (DecodeN reg) lreg);
 3961 
 3962   op_cost(10);
 3963   format %{&quot;[$reg + $lreg]&quot; %}
 3964   interface(MEMORY_INTER) %{
 3965     base($reg);
 3966     index($lreg);
 3967     scale(0x0);
 3968     disp(0x0);
 3969   %}
 3970 %}
 3971 
 3972 // Indirect Memory Times Scale Plus Index Register
 3973 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
 3974 %{
 3975   predicate(CompressedOops::shift() == 0);
 3976   constraint(ALLOC_IN_RC(ptr_reg));
 3977   match(AddP (DecodeN reg) (LShiftL lreg scale));
 3978 
 3979   op_cost(10);
 3980   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3981   interface(MEMORY_INTER) %{
 3982     base($reg);
 3983     index($lreg);
 3984     scale($scale);
 3985     disp(0x0);
 3986   %}
 3987 %}
 3988 
 3989 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3990 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
 3991 %{
 3992   predicate(CompressedOops::shift() == 0);
 3993   constraint(ALLOC_IN_RC(ptr_reg));
 3994   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
 3995 
 3996   op_cost(10);
 3997   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3998   interface(MEMORY_INTER) %{
 3999     base($reg);
 4000     index($lreg);
 4001     scale($scale);
 4002     disp($off);
 4003   %}
 4004 %}
 4005 
 4006 // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
 4007 operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
 4008 %{
 4009   constraint(ALLOC_IN_RC(ptr_reg));
 4010   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4011   match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
 4012 
 4013   op_cost(10);
 4014   format %{&quot;[$reg + $off + $idx]&quot; %}
 4015   interface(MEMORY_INTER) %{
 4016     base($reg);
 4017     index($idx);
 4018     scale(0x0);
 4019     disp($off);
 4020   %}
 4021 %}
 4022 
 4023 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 4024 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
 4025 %{
 4026   constraint(ALLOC_IN_RC(ptr_reg));
 4027   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4028   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
 4029 
 4030   op_cost(10);
 4031   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 4032   interface(MEMORY_INTER) %{
 4033     base($reg);
 4034     index($idx);
 4035     scale($scale);
 4036     disp($off);
 4037   %}
 4038 %}
 4039 
 4040 //----------Special Memory Operands--------------------------------------------
 4041 // Stack Slot Operand - This operand is used for loading and storing temporary
 4042 //                      values on the stack where a match requires a value to
 4043 //                      flow through memory.
 4044 operand stackSlotP(sRegP reg)
 4045 %{
 4046   constraint(ALLOC_IN_RC(stack_slots));
 4047   // No match rule because this operand is only generated in matching
 4048 
 4049   format %{ &quot;[$reg]&quot; %}
 4050   interface(MEMORY_INTER) %{
 4051     base(0x4);   // RSP
 4052     index(0x4);  // No Index
 4053     scale(0x0);  // No Scale
 4054     disp($reg);  // Stack Offset
 4055   %}
 4056 %}
 4057 
 4058 operand stackSlotI(sRegI reg)
 4059 %{
 4060   constraint(ALLOC_IN_RC(stack_slots));
 4061   // No match rule because this operand is only generated in matching
 4062 
 4063   format %{ &quot;[$reg]&quot; %}
 4064   interface(MEMORY_INTER) %{
 4065     base(0x4);   // RSP
 4066     index(0x4);  // No Index
 4067     scale(0x0);  // No Scale
 4068     disp($reg);  // Stack Offset
 4069   %}
 4070 %}
 4071 
 4072 operand stackSlotF(sRegF reg)
 4073 %{
 4074   constraint(ALLOC_IN_RC(stack_slots));
 4075   // No match rule because this operand is only generated in matching
 4076 
 4077   format %{ &quot;[$reg]&quot; %}
 4078   interface(MEMORY_INTER) %{
 4079     base(0x4);   // RSP
 4080     index(0x4);  // No Index
 4081     scale(0x0);  // No Scale
 4082     disp($reg);  // Stack Offset
 4083   %}
 4084 %}
 4085 
 4086 operand stackSlotD(sRegD reg)
 4087 %{
 4088   constraint(ALLOC_IN_RC(stack_slots));
 4089   // No match rule because this operand is only generated in matching
 4090 
 4091   format %{ &quot;[$reg]&quot; %}
 4092   interface(MEMORY_INTER) %{
 4093     base(0x4);   // RSP
 4094     index(0x4);  // No Index
 4095     scale(0x0);  // No Scale
 4096     disp($reg);  // Stack Offset
 4097   %}
 4098 %}
 4099 operand stackSlotL(sRegL reg)
 4100 %{
 4101   constraint(ALLOC_IN_RC(stack_slots));
 4102   // No match rule because this operand is only generated in matching
 4103 
 4104   format %{ &quot;[$reg]&quot; %}
 4105   interface(MEMORY_INTER) %{
 4106     base(0x4);   // RSP
 4107     index(0x4);  // No Index
 4108     scale(0x0);  // No Scale
 4109     disp($reg);  // Stack Offset
 4110   %}
 4111 %}
 4112 
 4113 //----------Conditional Branch Operands----------------------------------------
 4114 // Comparison Op  - This is the operation of the comparison, and is limited to
 4115 //                  the following set of codes:
 4116 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4117 //
 4118 // Other attributes of the comparison, such as unsignedness, are specified
 4119 // by the comparison instruction that sets a condition code flags register.
 4120 // That result is represented by a flags operand whose subtype is appropriate
 4121 // to the unsignedness (etc.) of the comparison.
 4122 //
 4123 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4124 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4125 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4126 
 4127 // Comparision Code
 4128 operand cmpOp()
 4129 %{
 4130   match(Bool);
 4131 
 4132   format %{ &quot;&quot; %}
 4133   interface(COND_INTER) %{
 4134     equal(0x4, &quot;e&quot;);
 4135     not_equal(0x5, &quot;ne&quot;);
 4136     less(0xC, &quot;l&quot;);
 4137     greater_equal(0xD, &quot;ge&quot;);
 4138     less_equal(0xE, &quot;le&quot;);
 4139     greater(0xF, &quot;g&quot;);
 4140     overflow(0x0, &quot;o&quot;);
 4141     no_overflow(0x1, &quot;no&quot;);
 4142   %}
 4143 %}
 4144 
 4145 // Comparison Code, unsigned compare.  Used by FP also, with
 4146 // C2 (unordered) turned into GT or LT already.  The other bits
 4147 // C0 and C3 are turned into Carry &amp; Zero flags.
 4148 operand cmpOpU()
 4149 %{
 4150   match(Bool);
 4151 
 4152   format %{ &quot;&quot; %}
 4153   interface(COND_INTER) %{
 4154     equal(0x4, &quot;e&quot;);
 4155     not_equal(0x5, &quot;ne&quot;);
 4156     less(0x2, &quot;b&quot;);
 4157     greater_equal(0x3, &quot;nb&quot;);
 4158     less_equal(0x6, &quot;be&quot;);
 4159     greater(0x7, &quot;nbe&quot;);
 4160     overflow(0x0, &quot;o&quot;);
 4161     no_overflow(0x1, &quot;no&quot;);
 4162   %}
 4163 %}
 4164 
 4165 
 4166 // Floating comparisons that don&#39;t require any fixup for the unordered case
 4167 operand cmpOpUCF() %{
 4168   match(Bool);
 4169   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4170             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
 4171             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
 4172             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
 4173   format %{ &quot;&quot; %}
 4174   interface(COND_INTER) %{
 4175     equal(0x4, &quot;e&quot;);
 4176     not_equal(0x5, &quot;ne&quot;);
 4177     less(0x2, &quot;b&quot;);
 4178     greater_equal(0x3, &quot;nb&quot;);
 4179     less_equal(0x6, &quot;be&quot;);
 4180     greater(0x7, &quot;nbe&quot;);
 4181     overflow(0x0, &quot;o&quot;);
 4182     no_overflow(0x1, &quot;no&quot;);
 4183   %}
 4184 %}
 4185 
 4186 
 4187 // Floating comparisons that can be fixed up with extra conditional jumps
 4188 operand cmpOpUCF2() %{
 4189   match(Bool);
 4190   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4191             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4192   format %{ &quot;&quot; %}
 4193   interface(COND_INTER) %{
 4194     equal(0x4, &quot;e&quot;);
 4195     not_equal(0x5, &quot;ne&quot;);
 4196     less(0x2, &quot;b&quot;);
 4197     greater_equal(0x3, &quot;nb&quot;);
 4198     less_equal(0x6, &quot;be&quot;);
 4199     greater(0x7, &quot;nbe&quot;);
 4200     overflow(0x0, &quot;o&quot;);
 4201     no_overflow(0x1, &quot;no&quot;);
 4202   %}
 4203 %}
 4204 
 4205 //----------OPERAND CLASSES----------------------------------------------------
 4206 // Operand Classes are groups of operands that are used as to simplify
 4207 // instruction definitions by not requiring the AD writer to specify separate
 4208 // instructions for every form of operand when the instruction accepts
 4209 // multiple operand types with the same basic encoding and format.  The classic
 4210 // case of this is memory operands.
 4211 
 4212 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4213                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
 4214                indCompressedOop, indCompressedOopOffset,
 4215                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4216                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4217                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4218 
 4219 //----------PIPELINE-----------------------------------------------------------
 4220 // Rules which define the behavior of the target architectures pipeline.
 4221 pipeline %{
 4222 
 4223 //----------ATTRIBUTES---------------------------------------------------------
 4224 attributes %{
 4225   variable_size_instructions;        // Fixed size instructions
 4226   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4227   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4228   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4229   instruction_fetch_units = 1;       // of 16 bytes
 4230 
 4231   // List of nop instructions
 4232   nops( MachNop );
 4233 %}
 4234 
 4235 //----------RESOURCES----------------------------------------------------------
 4236 // Resources are the functional units available to the machine
 4237 
 4238 // Generic P2/P3 pipeline
 4239 // 3 decoders, only D0 handles big operands; a &quot;bundle&quot; is the limit of
 4240 // 3 instructions decoded per cycle.
 4241 // 2 load/store ops per cycle, 1 branch, 1 FPU,
 4242 // 3 ALU op, only ALU0 handles mul instructions.
 4243 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
 4244            MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,
 4245            BR, FPU,
 4246            ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);
 4247 
 4248 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4249 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4250 
 4251 // Generic P2/P3 pipeline
 4252 pipe_desc(S0, S1, S2, S3, S4, S5);
 4253 
 4254 //----------PIPELINE CLASSES---------------------------------------------------
 4255 // Pipeline Classes describe the stages in which input and output are
 4256 // referenced by the hardware pipeline.
 4257 
 4258 // Naming convention: ialu or fpu
 4259 // Then: _reg
 4260 // Then: _reg if there is a 2nd register
 4261 // Then: _long if it&#39;s a pair of instructions implementing a long
 4262 // Then: _fat if it requires the big decoder
 4263 //   Or: _mem if it requires the big decoder and a memory unit.
 4264 
 4265 // Integer ALU reg operation
 4266 pipe_class ialu_reg(rRegI dst)
 4267 %{
 4268     single_instruction;
 4269     dst    : S4(write);
 4270     dst    : S3(read);
 4271     DECODE : S0;        // any decoder
 4272     ALU    : S3;        // any alu
 4273 %}
 4274 
 4275 // Long ALU reg operation
 4276 pipe_class ialu_reg_long(rRegL dst)
 4277 %{
 4278     instruction_count(2);
 4279     dst    : S4(write);
 4280     dst    : S3(read);
 4281     DECODE : S0(2);     // any 2 decoders
 4282     ALU    : S3(2);     // both alus
 4283 %}
 4284 
 4285 // Integer ALU reg operation using big decoder
 4286 pipe_class ialu_reg_fat(rRegI dst)
 4287 %{
 4288     single_instruction;
 4289     dst    : S4(write);
 4290     dst    : S3(read);
 4291     D0     : S0;        // big decoder only
 4292     ALU    : S3;        // any alu
 4293 %}
 4294 
 4295 // Long ALU reg operation using big decoder
 4296 pipe_class ialu_reg_long_fat(rRegL dst)
 4297 %{
 4298     instruction_count(2);
 4299     dst    : S4(write);
 4300     dst    : S3(read);
 4301     D0     : S0(2);     // big decoder only; twice
 4302     ALU    : S3(2);     // any 2 alus
 4303 %}
 4304 
 4305 // Integer ALU reg-reg operation
 4306 pipe_class ialu_reg_reg(rRegI dst, rRegI src)
 4307 %{
 4308     single_instruction;
 4309     dst    : S4(write);
 4310     src    : S3(read);
 4311     DECODE : S0;        // any decoder
 4312     ALU    : S3;        // any alu
 4313 %}
 4314 
 4315 // Long ALU reg-reg operation
 4316 pipe_class ialu_reg_reg_long(rRegL dst, rRegL src)
 4317 %{
 4318     instruction_count(2);
 4319     dst    : S4(write);
 4320     src    : S3(read);
 4321     DECODE : S0(2);     // any 2 decoders
 4322     ALU    : S3(2);     // both alus
 4323 %}
 4324 
 4325 // Integer ALU reg-reg operation
 4326 pipe_class ialu_reg_reg_fat(rRegI dst, memory src)
 4327 %{
 4328     single_instruction;
 4329     dst    : S4(write);
 4330     src    : S3(read);
 4331     D0     : S0;        // big decoder only
 4332     ALU    : S3;        // any alu
 4333 %}
 4334 
 4335 // Long ALU reg-reg operation
 4336 pipe_class ialu_reg_reg_long_fat(rRegL dst, rRegL src)
 4337 %{
 4338     instruction_count(2);
 4339     dst    : S4(write);
 4340     src    : S3(read);
 4341     D0     : S0(2);     // big decoder only; twice
 4342     ALU    : S3(2);     // both alus
 4343 %}
 4344 
 4345 // Integer ALU reg-mem operation
 4346 pipe_class ialu_reg_mem(rRegI dst, memory mem)
 4347 %{
 4348     single_instruction;
 4349     dst    : S5(write);
 4350     mem    : S3(read);
 4351     D0     : S0;        // big decoder only
 4352     ALU    : S4;        // any alu
 4353     MEM    : S3;        // any mem
 4354 %}
 4355 
 4356 // Integer mem operation (prefetch)
 4357 pipe_class ialu_mem(memory mem)
 4358 %{
 4359     single_instruction;
 4360     mem    : S3(read);
 4361     D0     : S0;        // big decoder only
 4362     MEM    : S3;        // any mem
 4363 %}
 4364 
 4365 // Integer Store to Memory
 4366 pipe_class ialu_mem_reg(memory mem, rRegI src)
 4367 %{
 4368     single_instruction;
 4369     mem    : S3(read);
 4370     src    : S5(read);
 4371     D0     : S0;        // big decoder only
 4372     ALU    : S4;        // any alu
 4373     MEM    : S3;
 4374 %}
 4375 
 4376 // // Long Store to Memory
 4377 // pipe_class ialu_mem_long_reg(memory mem, rRegL src)
 4378 // %{
 4379 //     instruction_count(2);
 4380 //     mem    : S3(read);
 4381 //     src    : S5(read);
 4382 //     D0     : S0(2);          // big decoder only; twice
 4383 //     ALU    : S4(2);     // any 2 alus
 4384 //     MEM    : S3(2);  // Both mems
 4385 // %}
 4386 
 4387 // Integer Store to Memory
 4388 pipe_class ialu_mem_imm(memory mem)
 4389 %{
 4390     single_instruction;
 4391     mem    : S3(read);
 4392     D0     : S0;        // big decoder only
 4393     ALU    : S4;        // any alu
 4394     MEM    : S3;
 4395 %}
 4396 
 4397 // Integer ALU0 reg-reg operation
 4398 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)
 4399 %{
 4400     single_instruction;
 4401     dst    : S4(write);
 4402     src    : S3(read);
 4403     D0     : S0;        // Big decoder only
 4404     ALU0   : S3;        // only alu0
 4405 %}
 4406 
 4407 // Integer ALU0 reg-mem operation
 4408 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)
 4409 %{
 4410     single_instruction;
 4411     dst    : S5(write);
 4412     mem    : S3(read);
 4413     D0     : S0;        // big decoder only
 4414     ALU0   : S4;        // ALU0 only
 4415     MEM    : S3;        // any mem
 4416 %}
 4417 
 4418 // Integer ALU reg-reg operation
 4419 pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)
 4420 %{
 4421     single_instruction;
 4422     cr     : S4(write);
 4423     src1   : S3(read);
 4424     src2   : S3(read);
 4425     DECODE : S0;        // any decoder
 4426     ALU    : S3;        // any alu
 4427 %}
 4428 
 4429 // Integer ALU reg-imm operation
 4430 pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)
 4431 %{
 4432     single_instruction;
 4433     cr     : S4(write);
 4434     src1   : S3(read);
 4435     DECODE : S0;        // any decoder
 4436     ALU    : S3;        // any alu
 4437 %}
 4438 
 4439 // Integer ALU reg-mem operation
 4440 pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)
 4441 %{
 4442     single_instruction;
 4443     cr     : S4(write);
 4444     src1   : S3(read);
 4445     src2   : S3(read);
 4446     D0     : S0;        // big decoder only
 4447     ALU    : S4;        // any alu
 4448     MEM    : S3;
 4449 %}
 4450 
 4451 // Conditional move reg-reg
 4452 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)
 4453 %{
 4454     instruction_count(4);
 4455     y      : S4(read);
 4456     q      : S3(read);
 4457     p      : S3(read);
 4458     DECODE : S0(4);     // any decoder
 4459 %}
 4460 
 4461 // Conditional move reg-reg
 4462 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)
 4463 %{
 4464     single_instruction;
 4465     dst    : S4(write);
 4466     src    : S3(read);
 4467     cr     : S3(read);
 4468     DECODE : S0;        // any decoder
 4469 %}
 4470 
 4471 // Conditional move reg-mem
 4472 pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)
 4473 %{
 4474     single_instruction;
 4475     dst    : S4(write);
 4476     src    : S3(read);
 4477     cr     : S3(read);
 4478     DECODE : S0;        // any decoder
 4479     MEM    : S3;
 4480 %}
 4481 
 4482 // Conditional move reg-reg long
 4483 pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)
 4484 %{
 4485     single_instruction;
 4486     dst    : S4(write);
 4487     src    : S3(read);
 4488     cr     : S3(read);
 4489     DECODE : S0(2);     // any 2 decoders
 4490 %}
 4491 
 4492 // XXX
 4493 // // Conditional move double reg-reg
 4494 // pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)
 4495 // %{
 4496 //     single_instruction;
 4497 //     dst    : S4(write);
 4498 //     src    : S3(read);
 4499 //     cr     : S3(read);
 4500 //     DECODE : S0;     // any decoder
 4501 // %}
 4502 
 4503 // Float reg-reg operation
 4504 pipe_class fpu_reg(regD dst)
 4505 %{
 4506     instruction_count(2);
 4507     dst    : S3(read);
 4508     DECODE : S0(2);     // any 2 decoders
 4509     FPU    : S3;
 4510 %}
 4511 
 4512 // Float reg-reg operation
 4513 pipe_class fpu_reg_reg(regD dst, regD src)
 4514 %{
 4515     instruction_count(2);
 4516     dst    : S4(write);
 4517     src    : S3(read);
 4518     DECODE : S0(2);     // any 2 decoders
 4519     FPU    : S3;
 4520 %}
 4521 
 4522 // Float reg-reg operation
 4523 pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)
 4524 %{
 4525     instruction_count(3);
 4526     dst    : S4(write);
 4527     src1   : S3(read);
 4528     src2   : S3(read);
 4529     DECODE : S0(3);     // any 3 decoders
 4530     FPU    : S3(2);
 4531 %}
 4532 
 4533 // Float reg-reg operation
 4534 pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)
 4535 %{
 4536     instruction_count(4);
 4537     dst    : S4(write);
 4538     src1   : S3(read);
 4539     src2   : S3(read);
 4540     src3   : S3(read);
 4541     DECODE : S0(4);     // any 3 decoders
 4542     FPU    : S3(2);
 4543 %}
 4544 
 4545 // Float reg-reg operation
 4546 pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)
 4547 %{
 4548     instruction_count(4);
 4549     dst    : S4(write);
 4550     src1   : S3(read);
 4551     src2   : S3(read);
 4552     src3   : S3(read);
 4553     DECODE : S1(3);     // any 3 decoders
 4554     D0     : S0;        // Big decoder only
 4555     FPU    : S3(2);
 4556     MEM    : S3;
 4557 %}
 4558 
 4559 // Float reg-mem operation
 4560 pipe_class fpu_reg_mem(regD dst, memory mem)
 4561 %{
 4562     instruction_count(2);
 4563     dst    : S5(write);
 4564     mem    : S3(read);
 4565     D0     : S0;        // big decoder only
 4566     DECODE : S1;        // any decoder for FPU POP
 4567     FPU    : S4;
 4568     MEM    : S3;        // any mem
 4569 %}
 4570 
 4571 // Float reg-mem operation
 4572 pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)
 4573 %{
 4574     instruction_count(3);
 4575     dst    : S5(write);
 4576     src1   : S3(read);
 4577     mem    : S3(read);
 4578     D0     : S0;        // big decoder only
 4579     DECODE : S1(2);     // any decoder for FPU POP
 4580     FPU    : S4;
 4581     MEM    : S3;        // any mem
 4582 %}
 4583 
 4584 // Float mem-reg operation
 4585 pipe_class fpu_mem_reg(memory mem, regD src)
 4586 %{
 4587     instruction_count(2);
 4588     src    : S5(read);
 4589     mem    : S3(read);
 4590     DECODE : S0;        // any decoder for FPU PUSH
 4591     D0     : S1;        // big decoder only
 4592     FPU    : S4;
 4593     MEM    : S3;        // any mem
 4594 %}
 4595 
 4596 pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)
 4597 %{
 4598     instruction_count(3);
 4599     src1   : S3(read);
 4600     src2   : S3(read);
 4601     mem    : S3(read);
 4602     DECODE : S0(2);     // any decoder for FPU PUSH
 4603     D0     : S1;        // big decoder only
 4604     FPU    : S4;
 4605     MEM    : S3;        // any mem
 4606 %}
 4607 
 4608 pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)
 4609 %{
 4610     instruction_count(3);
 4611     src1   : S3(read);
 4612     src2   : S3(read);
 4613     mem    : S4(read);
 4614     DECODE : S0;        // any decoder for FPU PUSH
 4615     D0     : S0(2);     // big decoder only
 4616     FPU    : S4;
 4617     MEM    : S3(2);     // any mem
 4618 %}
 4619 
 4620 pipe_class fpu_mem_mem(memory dst, memory src1)
 4621 %{
 4622     instruction_count(2);
 4623     src1   : S3(read);
 4624     dst    : S4(read);
 4625     D0     : S0(2);     // big decoder only
 4626     MEM    : S3(2);     // any mem
 4627 %}
 4628 
 4629 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)
 4630 %{
 4631     instruction_count(3);
 4632     src1   : S3(read);
 4633     src2   : S3(read);
 4634     dst    : S4(read);
 4635     D0     : S0(3);     // big decoder only
 4636     FPU    : S4;
 4637     MEM    : S3(3);     // any mem
 4638 %}
 4639 
 4640 pipe_class fpu_mem_reg_con(memory mem, regD src1)
 4641 %{
 4642     instruction_count(3);
 4643     src1   : S4(read);
 4644     mem    : S4(read);
 4645     DECODE : S0;        // any decoder for FPU PUSH
 4646     D0     : S0(2);     // big decoder only
 4647     FPU    : S4;
 4648     MEM    : S3(2);     // any mem
 4649 %}
 4650 
 4651 // Float load constant
 4652 pipe_class fpu_reg_con(regD dst)
 4653 %{
 4654     instruction_count(2);
 4655     dst    : S5(write);
 4656     D0     : S0;        // big decoder only for the load
 4657     DECODE : S1;        // any decoder for FPU POP
 4658     FPU    : S4;
 4659     MEM    : S3;        // any mem
 4660 %}
 4661 
 4662 // Float load constant
 4663 pipe_class fpu_reg_reg_con(regD dst, regD src)
 4664 %{
 4665     instruction_count(3);
 4666     dst    : S5(write);
 4667     src    : S3(read);
 4668     D0     : S0;        // big decoder only for the load
 4669     DECODE : S1(2);     // any decoder for FPU POP
 4670     FPU    : S4;
 4671     MEM    : S3;        // any mem
 4672 %}
 4673 
 4674 // UnConditional branch
 4675 pipe_class pipe_jmp(label labl)
 4676 %{
 4677     single_instruction;
 4678     BR   : S3;
 4679 %}
 4680 
 4681 // Conditional branch
 4682 pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)
 4683 %{
 4684     single_instruction;
 4685     cr    : S1(read);
 4686     BR    : S3;
 4687 %}
 4688 
 4689 // Allocation idiom
 4690 pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)
 4691 %{
 4692     instruction_count(1); force_serialization;
 4693     fixed_latency(6);
 4694     heap_ptr : S3(read);
 4695     DECODE   : S0(3);
 4696     D0       : S2;
 4697     MEM      : S3;
 4698     ALU      : S3(2);
 4699     dst      : S5(write);
 4700     BR       : S5;
 4701 %}
 4702 
 4703 // Generic big/slow expanded idiom
 4704 pipe_class pipe_slow()
 4705 %{
 4706     instruction_count(10); multiple_bundles; force_serialization;
 4707     fixed_latency(100);
 4708     D0  : S0(2);
 4709     MEM : S3(2);
 4710 %}
 4711 
 4712 // The real do-nothing guy
 4713 pipe_class empty()
 4714 %{
 4715     instruction_count(0);
 4716 %}
 4717 
 4718 // Define the class for the Nop node
 4719 define
 4720 %{
 4721    MachNop = empty;
 4722 %}
 4723 
 4724 %}
 4725 
 4726 //----------INSTRUCTIONS-------------------------------------------------------
 4727 //
 4728 // match      -- States which machine-independent subtree may be replaced
 4729 //               by this instruction.
 4730 // ins_cost   -- The estimated cost of this instruction is used by instruction
 4731 //               selection to identify a minimum cost tree of machine
 4732 //               instructions that matches a tree of machine-independent
 4733 //               instructions.
 4734 // format     -- A string providing the disassembly for this instruction.
 4735 //               The value of an instruction&#39;s operand may be inserted
 4736 //               by referring to it with a &#39;$&#39; prefix.
 4737 // opcode     -- Three instruction opcodes may be provided.  These are referred
 4738 //               to within an encode class as $primary, $secondary, and $tertiary
 4739 //               rrspectively.  The primary opcode is commonly used to
 4740 //               indicate the type of machine instruction, while secondary
 4741 //               and tertiary are often used for prefix options or addressing
 4742 //               modes.
 4743 // ins_encode -- A list of encode classes with parameters. The encode class
 4744 //               name must have been defined in an &#39;enc_class&#39; specification
 4745 //               in the encode section of the architecture description.
 4746 
 4747 
 4748 //----------Load/Store/Move Instructions---------------------------------------
 4749 //----------Load Instructions--------------------------------------------------
 4750 
 4751 // Load Byte (8 bit signed)
 4752 instruct loadB(rRegI dst, memory mem)
 4753 %{
 4754   match(Set dst (LoadB mem));
 4755 
 4756   ins_cost(125);
 4757   format %{ &quot;movsbl  $dst, $mem\t# byte&quot; %}
 4758 
 4759   ins_encode %{
 4760     __ movsbl($dst$$Register, $mem$$Address);
 4761   %}
 4762 
 4763   ins_pipe(ialu_reg_mem);
 4764 %}
 4765 
 4766 // Load Byte (8 bit signed) into Long Register
 4767 instruct loadB2L(rRegL dst, memory mem)
 4768 %{
 4769   match(Set dst (ConvI2L (LoadB mem)));
 4770 
 4771   ins_cost(125);
 4772   format %{ &quot;movsbq  $dst, $mem\t# byte -&gt; long&quot; %}
 4773 
 4774   ins_encode %{
 4775     __ movsbq($dst$$Register, $mem$$Address);
 4776   %}
 4777 
 4778   ins_pipe(ialu_reg_mem);
 4779 %}
 4780 
 4781 // Load Unsigned Byte (8 bit UNsigned)
 4782 instruct loadUB(rRegI dst, memory mem)
 4783 %{
 4784   match(Set dst (LoadUB mem));
 4785 
 4786   ins_cost(125);
 4787   format %{ &quot;movzbl  $dst, $mem\t# ubyte&quot; %}
 4788 
 4789   ins_encode %{
 4790     __ movzbl($dst$$Register, $mem$$Address);
 4791   %}
 4792 
 4793   ins_pipe(ialu_reg_mem);
 4794 %}
 4795 
 4796 // Load Unsigned Byte (8 bit UNsigned) into Long Register
 4797 instruct loadUB2L(rRegL dst, memory mem)
 4798 %{
 4799   match(Set dst (ConvI2L (LoadUB mem)));
 4800 
 4801   ins_cost(125);
 4802   format %{ &quot;movzbq  $dst, $mem\t# ubyte -&gt; long&quot; %}
 4803 
 4804   ins_encode %{
 4805     __ movzbq($dst$$Register, $mem$$Address);
 4806   %}
 4807 
 4808   ins_pipe(ialu_reg_mem);
 4809 %}
 4810 
 4811 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
 4812 instruct loadUB2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4813   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 4814   effect(KILL cr);
 4815 
 4816   format %{ &quot;movzbq  $dst, $mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 4817             &quot;andl    $dst, right_n_bits($mask, 8)&quot; %}
 4818   ins_encode %{
 4819     Register Rdst = $dst$$Register;
 4820     __ movzbq(Rdst, $mem$$Address);
 4821     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
 4822   %}
 4823   ins_pipe(ialu_reg_mem);
 4824 %}
 4825 
 4826 // Load Short (16 bit signed)
 4827 instruct loadS(rRegI dst, memory mem)
 4828 %{
 4829   match(Set dst (LoadS mem));
 4830 
 4831   ins_cost(125);
 4832   format %{ &quot;movswl $dst, $mem\t# short&quot; %}
 4833 
 4834   ins_encode %{
 4835     __ movswl($dst$$Register, $mem$$Address);
 4836   %}
 4837 
 4838   ins_pipe(ialu_reg_mem);
 4839 %}
 4840 
 4841 // Load Short (16 bit signed) to Byte (8 bit signed)
 4842 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4843   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 4844 
 4845   ins_cost(125);
 4846   format %{ &quot;movsbl $dst, $mem\t# short -&gt; byte&quot; %}
 4847   ins_encode %{
 4848     __ movsbl($dst$$Register, $mem$$Address);
 4849   %}
 4850   ins_pipe(ialu_reg_mem);
 4851 %}
 4852 
 4853 // Load Short (16 bit signed) into Long Register
 4854 instruct loadS2L(rRegL dst, memory mem)
 4855 %{
 4856   match(Set dst (ConvI2L (LoadS mem)));
 4857 
 4858   ins_cost(125);
 4859   format %{ &quot;movswq $dst, $mem\t# short -&gt; long&quot; %}
 4860 
 4861   ins_encode %{
 4862     __ movswq($dst$$Register, $mem$$Address);
 4863   %}
 4864 
 4865   ins_pipe(ialu_reg_mem);
 4866 %}
 4867 
 4868 // Load Unsigned Short/Char (16 bit UNsigned)
 4869 instruct loadUS(rRegI dst, memory mem)
 4870 %{
 4871   match(Set dst (LoadUS mem));
 4872 
 4873   ins_cost(125);
 4874   format %{ &quot;movzwl  $dst, $mem\t# ushort/char&quot; %}
 4875 
 4876   ins_encode %{
 4877     __ movzwl($dst$$Register, $mem$$Address);
 4878   %}
 4879 
 4880   ins_pipe(ialu_reg_mem);
 4881 %}
 4882 
 4883 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 4884 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4885   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 4886 
 4887   ins_cost(125);
 4888   format %{ &quot;movsbl $dst, $mem\t# ushort -&gt; byte&quot; %}
 4889   ins_encode %{
 4890     __ movsbl($dst$$Register, $mem$$Address);
 4891   %}
 4892   ins_pipe(ialu_reg_mem);
 4893 %}
 4894 
 4895 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
 4896 instruct loadUS2L(rRegL dst, memory mem)
 4897 %{
 4898   match(Set dst (ConvI2L (LoadUS mem)));
 4899 
 4900   ins_cost(125);
 4901   format %{ &quot;movzwq  $dst, $mem\t# ushort/char -&gt; long&quot; %}
 4902 
 4903   ins_encode %{
 4904     __ movzwq($dst$$Register, $mem$$Address);
 4905   %}
 4906 
 4907   ins_pipe(ialu_reg_mem);
 4908 %}
 4909 
 4910 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
 4911 instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 4912   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4913 
 4914   format %{ &quot;movzbq  $dst, $mem\t# ushort/char &amp; 0xFF -&gt; long&quot; %}
 4915   ins_encode %{
 4916     __ movzbq($dst$$Register, $mem$$Address);
 4917   %}
 4918   ins_pipe(ialu_reg_mem);
 4919 %}
 4920 
 4921 // Load Unsigned Short/Char (16 bit UNsigned) with 32-bit mask into Long Register
 4922 instruct loadUS2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4923   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4924   effect(KILL cr);
 4925 
 4926   format %{ &quot;movzwq  $dst, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 4927             &quot;andl    $dst, right_n_bits($mask, 16)&quot; %}
 4928   ins_encode %{
 4929     Register Rdst = $dst$$Register;
 4930     __ movzwq(Rdst, $mem$$Address);
 4931     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
 4932   %}
 4933   ins_pipe(ialu_reg_mem);
 4934 %}
 4935 
 4936 // Load Integer
 4937 instruct loadI(rRegI dst, memory mem)
 4938 %{
 4939   match(Set dst (LoadI mem));
 4940 
 4941   ins_cost(125);
 4942   format %{ &quot;movl    $dst, $mem\t# int&quot; %}
 4943 
 4944   ins_encode %{
 4945     __ movl($dst$$Register, $mem$$Address);
 4946   %}
 4947 
 4948   ins_pipe(ialu_reg_mem);
 4949 %}
 4950 
 4951 // Load Integer (32 bit signed) to Byte (8 bit signed)
 4952 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4953   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 4954 
 4955   ins_cost(125);
 4956   format %{ &quot;movsbl  $dst, $mem\t# int -&gt; byte&quot; %}
 4957   ins_encode %{
 4958     __ movsbl($dst$$Register, $mem$$Address);
 4959   %}
 4960   ins_pipe(ialu_reg_mem);
 4961 %}
 4962 
 4963 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
 4964 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
 4965   match(Set dst (AndI (LoadI mem) mask));
 4966 
 4967   ins_cost(125);
 4968   format %{ &quot;movzbl  $dst, $mem\t# int -&gt; ubyte&quot; %}
 4969   ins_encode %{
 4970     __ movzbl($dst$$Register, $mem$$Address);
 4971   %}
 4972   ins_pipe(ialu_reg_mem);
 4973 %}
 4974 
 4975 // Load Integer (32 bit signed) to Short (16 bit signed)
 4976 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
 4977   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 4978 
 4979   ins_cost(125);
 4980   format %{ &quot;movswl  $dst, $mem\t# int -&gt; short&quot; %}
 4981   ins_encode %{
 4982     __ movswl($dst$$Register, $mem$$Address);
 4983   %}
 4984   ins_pipe(ialu_reg_mem);
 4985 %}
 4986 
 4987 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
 4988 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
 4989   match(Set dst (AndI (LoadI mem) mask));
 4990 
 4991   ins_cost(125);
 4992   format %{ &quot;movzwl  $dst, $mem\t# int -&gt; ushort/char&quot; %}
 4993   ins_encode %{
 4994     __ movzwl($dst$$Register, $mem$$Address);
 4995   %}
 4996   ins_pipe(ialu_reg_mem);
 4997 %}
 4998 
 4999 // Load Integer into Long Register
 5000 instruct loadI2L(rRegL dst, memory mem)
 5001 %{
 5002   match(Set dst (ConvI2L (LoadI mem)));
 5003 
 5004   ins_cost(125);
 5005   format %{ &quot;movslq  $dst, $mem\t# int -&gt; long&quot; %}
 5006 
 5007   ins_encode %{
 5008     __ movslq($dst$$Register, $mem$$Address);
 5009   %}
 5010 
 5011   ins_pipe(ialu_reg_mem);
 5012 %}
 5013 
 5014 // Load Integer with mask 0xFF into Long Register
 5015 instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 5016   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5017 
 5018   format %{ &quot;movzbq  $dst, $mem\t# int &amp; 0xFF -&gt; long&quot; %}
 5019   ins_encode %{
 5020     __ movzbq($dst$$Register, $mem$$Address);
 5021   %}
 5022   ins_pipe(ialu_reg_mem);
 5023 %}
 5024 
 5025 // Load Integer with mask 0xFFFF into Long Register
 5026 instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{
 5027   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5028 
 5029   format %{ &quot;movzwq  $dst, $mem\t# int &amp; 0xFFFF -&gt; long&quot; %}
 5030   ins_encode %{
 5031     __ movzwq($dst$$Register, $mem$$Address);
 5032   %}
 5033   ins_pipe(ialu_reg_mem);
 5034 %}
 5035 
 5036 // Load Integer with a 31-bit mask into Long Register
 5037 instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{
 5038   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5039   effect(KILL cr);
 5040 
 5041   format %{ &quot;movl    $dst, $mem\t# int &amp; 31-bit mask -&gt; long\n\t&quot;
 5042             &quot;andl    $dst, $mask&quot; %}
 5043   ins_encode %{
 5044     Register Rdst = $dst$$Register;
 5045     __ movl(Rdst, $mem$$Address);
 5046     __ andl(Rdst, $mask$$constant);
 5047   %}
 5048   ins_pipe(ialu_reg_mem);
 5049 %}
 5050 
 5051 // Load Unsigned Integer into Long Register
 5052 instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask)
 5053 %{
 5054   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5055 
 5056   ins_cost(125);
 5057   format %{ &quot;movl    $dst, $mem\t# uint -&gt; long&quot; %}
 5058 
 5059   ins_encode %{
 5060     __ movl($dst$$Register, $mem$$Address);
 5061   %}
 5062 
 5063   ins_pipe(ialu_reg_mem);
 5064 %}
 5065 
 5066 // Load Long
 5067 instruct loadL(rRegL dst, memory mem)
 5068 %{
 5069   match(Set dst (LoadL mem));
 5070 
 5071   ins_cost(125);
 5072   format %{ &quot;movq    $dst, $mem\t# long&quot; %}
 5073 
 5074   ins_encode %{
 5075     __ movq($dst$$Register, $mem$$Address);
 5076   %}
 5077 
 5078   ins_pipe(ialu_reg_mem); // XXX
 5079 %}
 5080 
 5081 // Load Range
 5082 instruct loadRange(rRegI dst, memory mem)
 5083 %{
 5084   match(Set dst (LoadRange mem));
 5085 
 5086   ins_cost(125); // XXX
 5087   format %{ &quot;movl    $dst, $mem\t# range&quot; %}
 5088   opcode(0x8B);
 5089   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
 5090   ins_pipe(ialu_reg_mem);
 5091 %}
 5092 
 5093 // Load Pointer
 5094 instruct loadP(rRegP dst, memory mem)
 5095 %{
 5096   match(Set dst (LoadP mem));
 5097   predicate(n-&gt;as_Load()-&gt;barrier_data() == 0);
 5098 
 5099   ins_cost(125); // XXX
 5100   format %{ &quot;movq    $dst, $mem\t# ptr&quot; %}
 5101   opcode(0x8B);
 5102   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5103   ins_pipe(ialu_reg_mem); // XXX
 5104 %}
 5105 
 5106 // Load Compressed Pointer
 5107 instruct loadN(rRegN dst, memory mem)
 5108 %{
 5109    match(Set dst (LoadN mem));
 5110 
 5111    ins_cost(125); // XXX
 5112    format %{ &quot;movl    $dst, $mem\t# compressed ptr&quot; %}
 5113    ins_encode %{
 5114      __ movl($dst$$Register, $mem$$Address);
 5115    %}
 5116    ins_pipe(ialu_reg_mem); // XXX
 5117 %}
 5118 
 5119 
 5120 // Load Klass Pointer
 5121 instruct loadKlass(rRegP dst, memory mem)
 5122 %{
 5123   match(Set dst (LoadKlass mem));
 5124 
 5125   ins_cost(125); // XXX
 5126   format %{ &quot;movq    $dst, $mem\t# class&quot; %}
 5127   opcode(0x8B);
 5128   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5129   ins_pipe(ialu_reg_mem); // XXX
 5130 %}
 5131 
 5132 // Load narrow Klass Pointer
 5133 instruct loadNKlass(rRegN dst, memory mem)
 5134 %{
 5135   match(Set dst (LoadNKlass mem));
 5136 
 5137   ins_cost(125); // XXX
 5138   format %{ &quot;movl    $dst, $mem\t# compressed klass ptr&quot; %}
 5139   ins_encode %{
 5140     __ movl($dst$$Register, $mem$$Address);
 5141   %}
 5142   ins_pipe(ialu_reg_mem); // XXX
 5143 %}
 5144 
 5145 // Load Float
 5146 instruct loadF(regF dst, memory mem)
 5147 %{
 5148   match(Set dst (LoadF mem));
 5149 
 5150   ins_cost(145); // XXX
 5151   format %{ &quot;movss   $dst, $mem\t# float&quot; %}
 5152   ins_encode %{
 5153     __ movflt($dst$$XMMRegister, $mem$$Address);
 5154   %}
 5155   ins_pipe(pipe_slow); // XXX
 5156 %}
 5157 
 5158 // Load Float
 5159 instruct MoveF2VL(vlRegF dst, regF src) %{
 5160   match(Set dst src);
 5161   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5162   ins_encode %{
 5163     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5164   %}
 5165   ins_pipe( fpu_reg_reg );
 5166 %}
 5167 
 5168 // Load Float
 5169 instruct MoveF2LEG(legRegF dst, regF src) %{
 5170   match(Set dst src);
 5171   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5172   ins_encode %{
 5173     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5174   %}
 5175   ins_pipe( fpu_reg_reg );
 5176 %}
 5177 
 5178 // Load Float
 5179 instruct MoveVL2F(regF dst, vlRegF src) %{
 5180   match(Set dst src);
 5181   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5182   ins_encode %{
 5183     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5184   %}
 5185   ins_pipe( fpu_reg_reg );
 5186 %}
 5187 
 5188 // Load Float
 5189 instruct MoveLEG2F(regF dst, legRegF src) %{
 5190   match(Set dst src);
 5191   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5192   ins_encode %{
 5193     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5194   %}
 5195   ins_pipe( fpu_reg_reg );
 5196 %}
 5197 
 5198 // Load Double
 5199 instruct loadD_partial(regD dst, memory mem)
 5200 %{
 5201   predicate(!UseXmmLoadAndClearUpper);
 5202   match(Set dst (LoadD mem));
 5203 
 5204   ins_cost(145); // XXX
 5205   format %{ &quot;movlpd  $dst, $mem\t# double&quot; %}
 5206   ins_encode %{
 5207     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5208   %}
 5209   ins_pipe(pipe_slow); // XXX
 5210 %}
 5211 
 5212 instruct loadD(regD dst, memory mem)
 5213 %{
 5214   predicate(UseXmmLoadAndClearUpper);
 5215   match(Set dst (LoadD mem));
 5216 
 5217   ins_cost(145); // XXX
 5218   format %{ &quot;movsd   $dst, $mem\t# double&quot; %}
 5219   ins_encode %{
 5220     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5221   %}
 5222   ins_pipe(pipe_slow); // XXX
 5223 %}
 5224 
 5225 // Load Double
 5226 instruct MoveD2VL(vlRegD dst, regD src) %{
 5227   match(Set dst src);
 5228   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5229   ins_encode %{
 5230     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5231   %}
 5232   ins_pipe( fpu_reg_reg );
 5233 %}
 5234 
 5235 // Load Double
 5236 instruct MoveD2LEG(legRegD dst, regD src) %{
 5237   match(Set dst src);
 5238   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5239   ins_encode %{
 5240     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5241   %}
 5242   ins_pipe( fpu_reg_reg );
 5243 %}
 5244 
 5245 // Load Double
 5246 instruct MoveVL2D(regD dst, vlRegD src) %{
 5247   match(Set dst src);
 5248   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5249   ins_encode %{
 5250     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5251   %}
 5252   ins_pipe( fpu_reg_reg );
 5253 %}
 5254 
 5255 // Load Double
 5256 instruct MoveLEG2D(regD dst, legRegD src) %{
 5257   match(Set dst src);
 5258   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5259   ins_encode %{
 5260     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5261   %}
 5262   ins_pipe( fpu_reg_reg );
 5263 %}
 5264 
 5265 // Following pseudo code describes the algorithm for max[FD]:
 5266 // Min algorithm is on similar lines
 5267 //  btmp = (b &lt; +0.0) ? a : b
 5268 //  atmp = (b &lt; +0.0) ? b : a
 5269 //  Tmp  = Max_Float(atmp , btmp)
 5270 //  Res  = (atmp == NaN) ? atmp : Tmp
 5271 
 5272 // max = java.lang.Math.max(float a, float b)
 5273 instruct maxF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5274   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5275   match(Set dst (MaxF a b));
 5276   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5277   format %{
 5278      &quot;blendvps         $btmp,$b,$a,$b           \n\t&quot;
 5279      &quot;blendvps         $atmp,$a,$b,$b           \n\t&quot;
 5280      &quot;vmaxss           $tmp,$atmp,$btmp         \n\t&quot;
 5281      &quot;cmpps.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5282      &quot;blendvps         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5283   %}
 5284   ins_encode %{
 5285     int vector_len = Assembler::AVX_128bit;
 5286     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5287     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5288     __ vmaxss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5289     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5290     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5291  %}
 5292   ins_pipe( pipe_slow );
 5293 %}
 5294 
 5295 instruct maxF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5296   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5297   match(Set dst (MaxF a b));
 5298   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5299 
 5300   format %{ &quot;$dst = max($a, $b)\t# intrinsic (float)&quot; %}
 5301   ins_encode %{
 5302     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5303                     false /*min*/, true /*single*/);
 5304   %}
 5305   ins_pipe( pipe_slow );
 5306 %}
 5307 
 5308 // max = java.lang.Math.max(double a, double b)
 5309 instruct maxD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5310   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5311   match(Set dst (MaxD a b));
 5312   effect(USE a, USE b, TEMP atmp, TEMP btmp, TEMP tmp);
 5313   format %{
 5314      &quot;blendvpd         $btmp,$b,$a,$b            \n\t&quot;
 5315      &quot;blendvpd         $atmp,$a,$b,$b            \n\t&quot;
 5316      &quot;vmaxsd           $tmp,$atmp,$btmp          \n\t&quot;
 5317      &quot;cmppd.unordered  $btmp,$atmp,$atmp         \n\t&quot;
 5318      &quot;blendvpd         $dst,$tmp,$atmp,$btmp     \n\t&quot;
 5319   %}
 5320   ins_encode %{
 5321     int vector_len = Assembler::AVX_128bit;
 5322     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5323     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5324     __ vmaxsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5325     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5326     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5327   %}
 5328   ins_pipe( pipe_slow );
 5329 %}
 5330 
 5331 instruct maxD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5332   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5333   match(Set dst (MaxD a b));
 5334   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5335 
 5336   format %{ &quot;$dst = max($a, $b)\t# intrinsic (double)&quot; %}
 5337   ins_encode %{
 5338     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5339                     false /*min*/, false /*single*/);
 5340   %}
 5341   ins_pipe( pipe_slow );
 5342 %}
 5343 
 5344 // min = java.lang.Math.min(float a, float b)
 5345 instruct minF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5346   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5347   match(Set dst (MinF a b));
 5348   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5349   format %{
 5350      &quot;blendvps         $atmp,$a,$b,$a             \n\t&quot;
 5351      &quot;blendvps         $btmp,$b,$a,$a             \n\t&quot;
 5352      &quot;vminss           $tmp,$atmp,$btmp           \n\t&quot;
 5353      &quot;cmpps.unordered  $btmp,$atmp,$atmp          \n\t&quot;
 5354      &quot;blendvps         $dst,$tmp,$atmp,$btmp      \n\t&quot;
 5355   %}
 5356   ins_encode %{
 5357     int vector_len = Assembler::AVX_128bit;
 5358     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5359     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5360     __ vminss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5361     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5362     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5363   %}
 5364   ins_pipe( pipe_slow );
 5365 %}
 5366 
 5367 instruct minF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5368   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5369   match(Set dst (MinF a b));
 5370   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5371 
 5372   format %{ &quot;$dst = min($a, $b)\t# intrinsic (float)&quot; %}
 5373   ins_encode %{
 5374     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5375                     true /*min*/, true /*single*/);
 5376   %}
 5377   ins_pipe( pipe_slow );
 5378 %}
 5379 
 5380 // min = java.lang.Math.min(double a, double b)
 5381 instruct minD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5382   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5383   match(Set dst (MinD a b));
 5384   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5385   format %{
 5386      &quot;blendvpd         $atmp,$a,$b,$a           \n\t&quot;
 5387      &quot;blendvpd         $btmp,$b,$a,$a           \n\t&quot;
 5388      &quot;vminsd           $tmp,$atmp,$btmp         \n\t&quot;
 5389      &quot;cmppd.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5390      &quot;blendvpd         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5391   %}
 5392   ins_encode %{
 5393     int vector_len = Assembler::AVX_128bit;
 5394     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5395     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5396     __ vminsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5397     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5398     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5399   %}
 5400   ins_pipe( pipe_slow );
 5401 %}
 5402 
 5403 instruct minD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5404   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5405   match(Set dst (MinD a b));
 5406   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5407 
 5408   format %{ &quot;$dst = min($a, $b)\t# intrinsic (double)&quot; %}
 5409   ins_encode %{
 5410     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5411                     true /*min*/, false /*single*/);
 5412   %}
 5413   ins_pipe( pipe_slow );
 5414 %}
 5415 
 5416 // Load Effective Address
 5417 instruct leaP8(rRegP dst, indOffset8 mem)
 5418 %{
 5419   match(Set dst mem);
 5420 
 5421   ins_cost(110); // XXX
 5422   format %{ &quot;leaq    $dst, $mem\t# ptr 8&quot; %}
 5423   opcode(0x8D);
 5424   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5425   ins_pipe(ialu_reg_reg_fat);
 5426 %}
 5427 
 5428 instruct leaP32(rRegP dst, indOffset32 mem)
 5429 %{
 5430   match(Set dst mem);
 5431 
 5432   ins_cost(110);
 5433   format %{ &quot;leaq    $dst, $mem\t# ptr 32&quot; %}
 5434   opcode(0x8D);
 5435   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5436   ins_pipe(ialu_reg_reg_fat);
 5437 %}
 5438 
 5439 // instruct leaPIdx(rRegP dst, indIndex mem)
 5440 // %{
 5441 //   match(Set dst mem);
 5442 
 5443 //   ins_cost(110);
 5444 //   format %{ &quot;leaq    $dst, $mem\t# ptr idx&quot; %}
 5445 //   opcode(0x8D);
 5446 //   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5447 //   ins_pipe(ialu_reg_reg_fat);
 5448 // %}
 5449 
 5450 instruct leaPIdxOff(rRegP dst, indIndexOffset mem)
 5451 %{
 5452   match(Set dst mem);
 5453 
 5454   ins_cost(110);
 5455   format %{ &quot;leaq    $dst, $mem\t# ptr idxoff&quot; %}
 5456   opcode(0x8D);
 5457   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5458   ins_pipe(ialu_reg_reg_fat);
 5459 %}
 5460 
 5461 instruct leaPIdxScale(rRegP dst, indIndexScale mem)
 5462 %{
 5463   match(Set dst mem);
 5464 
 5465   ins_cost(110);
 5466   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5467   opcode(0x8D);
 5468   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5469   ins_pipe(ialu_reg_reg_fat);
 5470 %}
 5471 
 5472 instruct leaPPosIdxScale(rRegP dst, indPosIndexScale mem)
 5473 %{
 5474   match(Set dst mem);
 5475 
 5476   ins_cost(110);
 5477   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5478   opcode(0x8D);
 5479   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5480   ins_pipe(ialu_reg_reg_fat);
 5481 %}
 5482 
 5483 instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)
 5484 %{
 5485   match(Set dst mem);
 5486 
 5487   ins_cost(110);
 5488   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoff&quot; %}
 5489   opcode(0x8D);
 5490   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5491   ins_pipe(ialu_reg_reg_fat);
 5492 %}
 5493 
 5494 instruct leaPPosIdxOff(rRegP dst, indPosIndexOffset mem)
 5495 %{
 5496   match(Set dst mem);
 5497 
 5498   ins_cost(110);
 5499   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoff&quot; %}
 5500   opcode(0x8D);
 5501   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5502   ins_pipe(ialu_reg_reg_fat);
 5503 %}
 5504 
 5505 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
 5506 %{
 5507   match(Set dst mem);
 5508 
 5509   ins_cost(110);
 5510   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoff&quot; %}
 5511   opcode(0x8D);
 5512   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5513   ins_pipe(ialu_reg_reg_fat);
 5514 %}
 5515 
 5516 // Load Effective Address which uses Narrow (32-bits) oop
 5517 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
 5518 %{
 5519   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() != 0));
 5520   match(Set dst mem);
 5521 
 5522   ins_cost(110);
 5523   format %{ &quot;leaq    $dst, $mem\t# ptr compressedoopoff32&quot; %}
 5524   opcode(0x8D);
 5525   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5526   ins_pipe(ialu_reg_reg_fat);
 5527 %}
 5528 
 5529 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
 5530 %{
 5531   predicate(CompressedOops::shift() == 0);
 5532   match(Set dst mem);
 5533 
 5534   ins_cost(110); // XXX
 5535   format %{ &quot;leaq    $dst, $mem\t# ptr off8narrow&quot; %}
 5536   opcode(0x8D);
 5537   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5538   ins_pipe(ialu_reg_reg_fat);
 5539 %}
 5540 
 5541 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
 5542 %{
 5543   predicate(CompressedOops::shift() == 0);
 5544   match(Set dst mem);
 5545 
 5546   ins_cost(110);
 5547   format %{ &quot;leaq    $dst, $mem\t# ptr off32narrow&quot; %}
 5548   opcode(0x8D);
 5549   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5550   ins_pipe(ialu_reg_reg_fat);
 5551 %}
 5552 
 5553 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
 5554 %{
 5555   predicate(CompressedOops::shift() == 0);
 5556   match(Set dst mem);
 5557 
 5558   ins_cost(110);
 5559   format %{ &quot;leaq    $dst, $mem\t# ptr idxoffnarrow&quot; %}
 5560   opcode(0x8D);
 5561   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5562   ins_pipe(ialu_reg_reg_fat);
 5563 %}
 5564 
 5565 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
 5566 %{
 5567   predicate(CompressedOops::shift() == 0);
 5568   match(Set dst mem);
 5569 
 5570   ins_cost(110);
 5571   format %{ &quot;leaq    $dst, $mem\t# ptr idxscalenarrow&quot; %}
 5572   opcode(0x8D);
 5573   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5574   ins_pipe(ialu_reg_reg_fat);
 5575 %}
 5576 
 5577 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
 5578 %{
 5579   predicate(CompressedOops::shift() == 0);
 5580   match(Set dst mem);
 5581 
 5582   ins_cost(110);
 5583   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoffnarrow&quot; %}
 5584   opcode(0x8D);
 5585   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5586   ins_pipe(ialu_reg_reg_fat);
 5587 %}
 5588 
 5589 instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
 5590 %{
 5591   predicate(CompressedOops::shift() == 0);
 5592   match(Set dst mem);
 5593 
 5594   ins_cost(110);
 5595   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoffnarrow&quot; %}
 5596   opcode(0x8D);
 5597   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5598   ins_pipe(ialu_reg_reg_fat);
 5599 %}
 5600 
 5601 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
 5602 %{
 5603   predicate(CompressedOops::shift() == 0);
 5604   match(Set dst mem);
 5605 
 5606   ins_cost(110);
 5607   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoffnarrow&quot; %}
 5608   opcode(0x8D);
 5609   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5610   ins_pipe(ialu_reg_reg_fat);
 5611 %}
 5612 
 5613 instruct loadConI(rRegI dst, immI src)
 5614 %{
 5615   match(Set dst src);
 5616 
 5617   format %{ &quot;movl    $dst, $src\t# int&quot; %}
 5618   ins_encode(load_immI(dst, src));
 5619   ins_pipe(ialu_reg_fat); // XXX
 5620 %}
 5621 
 5622 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
 5623 %{
 5624   match(Set dst src);
 5625   effect(KILL cr);
 5626 
 5627   ins_cost(50);
 5628   format %{ &quot;xorl    $dst, $dst\t# int&quot; %}
 5629   opcode(0x33); /* + rd */
 5630   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5631   ins_pipe(ialu_reg);
 5632 %}
 5633 
 5634 instruct loadConL(rRegL dst, immL src)
 5635 %{
 5636   match(Set dst src);
 5637 
 5638   ins_cost(150);
 5639   format %{ &quot;movq    $dst, $src\t# long&quot; %}
 5640   ins_encode(load_immL(dst, src));
 5641   ins_pipe(ialu_reg);
 5642 %}
 5643 
 5644 instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)
 5645 %{
 5646   match(Set dst src);
 5647   effect(KILL cr);
 5648 
 5649   ins_cost(50);
 5650   format %{ &quot;xorl    $dst, $dst\t# long&quot; %}
 5651   opcode(0x33); /* + rd */
 5652   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5653   ins_pipe(ialu_reg); // XXX
 5654 %}
 5655 
 5656 instruct loadConUL32(rRegL dst, immUL32 src)
 5657 %{
 5658   match(Set dst src);
 5659 
 5660   ins_cost(60);
 5661   format %{ &quot;movl    $dst, $src\t# long (unsigned 32-bit)&quot; %}
 5662   ins_encode(load_immUL32(dst, src));
 5663   ins_pipe(ialu_reg);
 5664 %}
 5665 
 5666 instruct loadConL32(rRegL dst, immL32 src)
 5667 %{
 5668   match(Set dst src);
 5669 
 5670   ins_cost(70);
 5671   format %{ &quot;movq    $dst, $src\t# long (32-bit)&quot; %}
 5672   ins_encode(load_immL32(dst, src));
 5673   ins_pipe(ialu_reg);
 5674 %}
 5675 
 5676 instruct loadConP(rRegP dst, immP con) %{
 5677   match(Set dst con);
 5678 
 5679   format %{ &quot;movq    $dst, $con\t# ptr&quot; %}
 5680   ins_encode(load_immP(dst, con));
 5681   ins_pipe(ialu_reg_fat); // XXX
 5682 %}
 5683 
 5684 instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)
 5685 %{
 5686   match(Set dst src);
 5687   effect(KILL cr);
 5688 
 5689   ins_cost(50);
 5690   format %{ &quot;xorl    $dst, $dst\t# ptr&quot; %}
 5691   opcode(0x33); /* + rd */
 5692   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5693   ins_pipe(ialu_reg);
 5694 %}
 5695 
 5696 instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)
 5697 %{
 5698   match(Set dst src);
 5699   effect(KILL cr);
 5700 
 5701   ins_cost(60);
 5702   format %{ &quot;movl    $dst, $src\t# ptr (positive 32-bit)&quot; %}
 5703   ins_encode(load_immP31(dst, src));
 5704   ins_pipe(ialu_reg);
 5705 %}
 5706 
 5707 instruct loadConF(regF dst, immF con) %{
 5708   match(Set dst con);
 5709   ins_cost(125);
 5710   format %{ &quot;movss   $dst, [$constantaddress]\t# load from constant table: float=$con&quot; %}
 5711   ins_encode %{
 5712     __ movflt($dst$$XMMRegister, $constantaddress($con));
 5713   %}
 5714   ins_pipe(pipe_slow);
 5715 %}
 5716 
 5717 instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{
 5718   match(Set dst src);
 5719   effect(KILL cr);
 5720   format %{ &quot;xorq    $dst, $src\t# compressed NULL ptr&quot; %}
 5721   ins_encode %{
 5722     __ xorq($dst$$Register, $dst$$Register);
 5723   %}
 5724   ins_pipe(ialu_reg);
 5725 %}
 5726 
 5727 instruct loadConN(rRegN dst, immN src) %{
 5728   match(Set dst src);
 5729 
 5730   ins_cost(125);
 5731   format %{ &quot;movl    $dst, $src\t# compressed ptr&quot; %}
 5732   ins_encode %{
 5733     address con = (address)$src$$constant;
 5734     if (con == NULL) {
 5735       ShouldNotReachHere();
 5736     } else {
 5737       __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);
 5738     }
 5739   %}
 5740   ins_pipe(ialu_reg_fat); // XXX
 5741 %}
 5742 
 5743 instruct loadConNKlass(rRegN dst, immNKlass src) %{
 5744   match(Set dst src);
 5745 
 5746   ins_cost(125);
 5747   format %{ &quot;movl    $dst, $src\t# compressed klass ptr&quot; %}
 5748   ins_encode %{
 5749     address con = (address)$src$$constant;
 5750     if (con == NULL) {
 5751       ShouldNotReachHere();
 5752     } else {
 5753       __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);
 5754     }
 5755   %}
 5756   ins_pipe(ialu_reg_fat); // XXX
 5757 %}
 5758 
 5759 instruct loadConF0(regF dst, immF0 src)
 5760 %{
 5761   match(Set dst src);
 5762   ins_cost(100);
 5763 
 5764   format %{ &quot;xorps   $dst, $dst\t# float 0.0&quot; %}
 5765   ins_encode %{
 5766     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
 5767   %}
 5768   ins_pipe(pipe_slow);
 5769 %}
 5770 
 5771 // Use the same format since predicate() can not be used here.
 5772 instruct loadConD(regD dst, immD con) %{
 5773   match(Set dst con);
 5774   ins_cost(125);
 5775   format %{ &quot;movsd   $dst, [$constantaddress]\t# load from constant table: double=$con&quot; %}
 5776   ins_encode %{
 5777     __ movdbl($dst$$XMMRegister, $constantaddress($con));
 5778   %}
 5779   ins_pipe(pipe_slow);
 5780 %}
 5781 
 5782 instruct loadConD0(regD dst, immD0 src)
 5783 %{
 5784   match(Set dst src);
 5785   ins_cost(100);
 5786 
 5787   format %{ &quot;xorpd   $dst, $dst\t# double 0.0&quot; %}
 5788   ins_encode %{
 5789     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
 5790   %}
 5791   ins_pipe(pipe_slow);
 5792 %}
 5793 
 5794 instruct loadSSI(rRegI dst, stackSlotI src)
 5795 %{
 5796   match(Set dst src);
 5797 
 5798   ins_cost(125);
 5799   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 5800   opcode(0x8B);
 5801   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 5802   ins_pipe(ialu_reg_mem);
 5803 %}
 5804 
 5805 instruct loadSSL(rRegL dst, stackSlotL src)
 5806 %{
 5807   match(Set dst src);
 5808 
 5809   ins_cost(125);
 5810   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 5811   opcode(0x8B);
 5812   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5813   ins_pipe(ialu_reg_mem);
 5814 %}
 5815 
 5816 instruct loadSSP(rRegP dst, stackSlotP src)
 5817 %{
 5818   match(Set dst src);
 5819 
 5820   ins_cost(125);
 5821   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 5822   opcode(0x8B);
 5823   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5824   ins_pipe(ialu_reg_mem);
 5825 %}
 5826 
 5827 instruct loadSSF(regF dst, stackSlotF src)
 5828 %{
 5829   match(Set dst src);
 5830 
 5831   ins_cost(125);
 5832   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 5833   ins_encode %{
 5834     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
 5835   %}
 5836   ins_pipe(pipe_slow); // XXX
 5837 %}
 5838 
 5839 // Use the same format since predicate() can not be used here.
 5840 instruct loadSSD(regD dst, stackSlotD src)
 5841 %{
 5842   match(Set dst src);
 5843 
 5844   ins_cost(125);
 5845   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 5846   ins_encode  %{
 5847     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
 5848   %}
 5849   ins_pipe(pipe_slow); // XXX
 5850 %}
 5851 
 5852 // Prefetch instructions for allocation.
 5853 // Must be safe to execute with invalid address (cannot fault).
 5854 
 5855 instruct prefetchAlloc( memory mem ) %{
 5856   predicate(AllocatePrefetchInstr==3);
 5857   match(PrefetchAllocation mem);
 5858   ins_cost(125);
 5859 
 5860   format %{ &quot;PREFETCHW $mem\t# Prefetch allocation into level 1 cache and mark modified&quot; %}
 5861   ins_encode %{
 5862     __ prefetchw($mem$$Address);
 5863   %}
 5864   ins_pipe(ialu_mem);
 5865 %}
 5866 
 5867 instruct prefetchAllocNTA( memory mem ) %{
 5868   predicate(AllocatePrefetchInstr==0);
 5869   match(PrefetchAllocation mem);
 5870   ins_cost(125);
 5871 
 5872   format %{ &quot;PREFETCHNTA $mem\t# Prefetch allocation to non-temporal cache for write&quot; %}
 5873   ins_encode %{
 5874     __ prefetchnta($mem$$Address);
 5875   %}
 5876   ins_pipe(ialu_mem);
 5877 %}
 5878 
 5879 instruct prefetchAllocT0( memory mem ) %{
 5880   predicate(AllocatePrefetchInstr==1);
 5881   match(PrefetchAllocation mem);
 5882   ins_cost(125);
 5883 
 5884   format %{ &quot;PREFETCHT0 $mem\t# Prefetch allocation to level 1 and 2 caches for write&quot; %}
 5885   ins_encode %{
 5886     __ prefetcht0($mem$$Address);
 5887   %}
 5888   ins_pipe(ialu_mem);
 5889 %}
 5890 
 5891 instruct prefetchAllocT2( memory mem ) %{
 5892   predicate(AllocatePrefetchInstr==2);
 5893   match(PrefetchAllocation mem);
 5894   ins_cost(125);
 5895 
 5896   format %{ &quot;PREFETCHT2 $mem\t# Prefetch allocation to level 2 cache for write&quot; %}
 5897   ins_encode %{
 5898     __ prefetcht2($mem$$Address);
 5899   %}
 5900   ins_pipe(ialu_mem);
 5901 %}
 5902 
 5903 //----------Store Instructions-------------------------------------------------
 5904 
 5905 // Store Byte
 5906 instruct storeB(memory mem, rRegI src)
 5907 %{
 5908   match(Set mem (StoreB mem src));
 5909 
 5910   ins_cost(125); // XXX
 5911   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 5912   opcode(0x88);
 5913   ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));
 5914   ins_pipe(ialu_mem_reg);
 5915 %}
 5916 
 5917 // Store Char/Short
 5918 instruct storeC(memory mem, rRegI src)
 5919 %{
 5920   match(Set mem (StoreC mem src));
 5921 
 5922   ins_cost(125); // XXX
 5923   format %{ &quot;movw    $mem, $src\t# char/short&quot; %}
 5924   opcode(0x89);
 5925   ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5926   ins_pipe(ialu_mem_reg);
 5927 %}
 5928 
 5929 // Store Integer
 5930 instruct storeI(memory mem, rRegI src)
 5931 %{
 5932   match(Set mem (StoreI mem src));
 5933 
 5934   ins_cost(125); // XXX
 5935   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 5936   opcode(0x89);
 5937   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5938   ins_pipe(ialu_mem_reg);
 5939 %}
 5940 
 5941 // Store Long
 5942 instruct storeL(memory mem, rRegL src)
 5943 %{
 5944   match(Set mem (StoreL mem src));
 5945 
 5946   ins_cost(125); // XXX
 5947   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 5948   opcode(0x89);
 5949   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5950   ins_pipe(ialu_mem_reg); // XXX
 5951 %}
 5952 
 5953 // Store Pointer
 5954 instruct storeP(memory mem, any_RegP src)
 5955 %{
 5956   match(Set mem (StoreP mem src));
 5957 
 5958   ins_cost(125); // XXX
 5959   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5960   opcode(0x89);
 5961   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5962   ins_pipe(ialu_mem_reg);
 5963 %}
 5964 
 5965 instruct storeImmP0(memory mem, immP0 zero)
 5966 %{
 5967   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 5968   match(Set mem (StoreP mem zero));
 5969 
 5970   ins_cost(125); // XXX
 5971   format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
 5972   ins_encode %{
 5973     __ movq($mem$$Address, r12);
 5974   %}
 5975   ins_pipe(ialu_mem_reg);
 5976 %}
 5977 
 5978 // Store NULL Pointer, mark word, or other simple pointer constant.
 5979 instruct storeImmP(memory mem, immP31 src)
 5980 %{
 5981   match(Set mem (StoreP mem src));
 5982 
 5983   ins_cost(150); // XXX
 5984   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5985   opcode(0xC7); /* C7 /0 */
 5986   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 5987   ins_pipe(ialu_mem_imm);
 5988 %}
 5989 
 5990 // Store Compressed Pointer
 5991 instruct storeN(memory mem, rRegN src)
 5992 %{
 5993   match(Set mem (StoreN mem src));
 5994 
 5995   ins_cost(125); // XXX
 5996   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 5997   ins_encode %{
 5998     __ movl($mem$$Address, $src$$Register);
 5999   %}
 6000   ins_pipe(ialu_mem_reg);
 6001 %}
 6002 
 6003 instruct storeNKlass(memory mem, rRegN src)
 6004 %{
 6005   match(Set mem (StoreNKlass mem src));
 6006 
 6007   ins_cost(125); // XXX
 6008   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6009   ins_encode %{
 6010     __ movl($mem$$Address, $src$$Register);
 6011   %}
 6012   ins_pipe(ialu_mem_reg);
 6013 %}
 6014 
 6015 instruct storeImmN0(memory mem, immN0 zero)
 6016 %{
 6017   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedKlassPointers::base() == NULL);
 6018   match(Set mem (StoreN mem zero));
 6019 
 6020   ins_cost(125); // XXX
 6021   format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
 6022   ins_encode %{
 6023     __ movl($mem$$Address, r12);
 6024   %}
 6025   ins_pipe(ialu_mem_reg);
 6026 %}
 6027 
 6028 instruct storeImmN(memory mem, immN src)
 6029 %{
 6030   match(Set mem (StoreN mem src));
 6031 
 6032   ins_cost(150); // XXX
 6033   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6034   ins_encode %{
 6035     address con = (address)$src$$constant;
 6036     if (con == NULL) {
 6037       __ movl($mem$$Address, (int32_t)0);
 6038     } else {
 6039       __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);
 6040     }
 6041   %}
 6042   ins_pipe(ialu_mem_imm);
 6043 %}
 6044 
 6045 instruct storeImmNKlass(memory mem, immNKlass src)
 6046 %{
 6047   match(Set mem (StoreNKlass mem src));
 6048 
 6049   ins_cost(150); // XXX
 6050   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6051   ins_encode %{
 6052     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
 6053   %}
 6054   ins_pipe(ialu_mem_imm);
 6055 %}
 6056 
 6057 // Store Integer Immediate
 6058 instruct storeImmI0(memory mem, immI0 zero)
 6059 %{
 6060   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6061   match(Set mem (StoreI mem zero));
 6062 
 6063   ins_cost(125); // XXX
 6064   format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
 6065   ins_encode %{
 6066     __ movl($mem$$Address, r12);
 6067   %}
 6068   ins_pipe(ialu_mem_reg);
 6069 %}
 6070 
 6071 instruct storeImmI(memory mem, immI src)
 6072 %{
 6073   match(Set mem (StoreI mem src));
 6074 
 6075   ins_cost(150);
 6076   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6077   opcode(0xC7); /* C7 /0 */
 6078   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6079   ins_pipe(ialu_mem_imm);
 6080 %}
 6081 
 6082 // Store Long Immediate
 6083 instruct storeImmL0(memory mem, immL0 zero)
 6084 %{
 6085   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6086   match(Set mem (StoreL mem zero));
 6087 
 6088   ins_cost(125); // XXX
 6089   format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
 6090   ins_encode %{
 6091     __ movq($mem$$Address, r12);
 6092   %}
 6093   ins_pipe(ialu_mem_reg);
 6094 %}
 6095 
 6096 instruct storeImmL(memory mem, immL32 src)
 6097 %{
 6098   match(Set mem (StoreL mem src));
 6099 
 6100   ins_cost(150);
 6101   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6102   opcode(0xC7); /* C7 /0 */
 6103   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6104   ins_pipe(ialu_mem_imm);
 6105 %}
 6106 
 6107 // Store Short/Char Immediate
 6108 instruct storeImmC0(memory mem, immI0 zero)
 6109 %{
 6110   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6111   match(Set mem (StoreC mem zero));
 6112 
 6113   ins_cost(125); // XXX
 6114   format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6115   ins_encode %{
 6116     __ movw($mem$$Address, r12);
 6117   %}
 6118   ins_pipe(ialu_mem_reg);
 6119 %}
 6120 
 6121 instruct storeImmI16(memory mem, immI16 src)
 6122 %{
 6123   predicate(UseStoreImmI16);
 6124   match(Set mem (StoreC mem src));
 6125 
 6126   ins_cost(150);
 6127   format %{ &quot;movw    $mem, $src\t# short/char&quot; %}
 6128   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
 6129   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
 6130   ins_pipe(ialu_mem_imm);
 6131 %}
 6132 
 6133 // Store Byte Immediate
 6134 instruct storeImmB0(memory mem, immI0 zero)
 6135 %{
 6136   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6137   match(Set mem (StoreB mem zero));
 6138 
 6139   ins_cost(125); // XXX
 6140   format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6141   ins_encode %{
 6142     __ movb($mem$$Address, r12);
 6143   %}
 6144   ins_pipe(ialu_mem_reg);
 6145 %}
 6146 
 6147 instruct storeImmB(memory mem, immI8 src)
 6148 %{
 6149   match(Set mem (StoreB mem src));
 6150 
 6151   ins_cost(150); // XXX
 6152   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6153   opcode(0xC6); /* C6 /0 */
 6154   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6155   ins_pipe(ialu_mem_imm);
 6156 %}
 6157 
 6158 // Store CMS card-mark Immediate
 6159 instruct storeImmCM0_reg(memory mem, immI0 zero)
 6160 %{
 6161   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6162   match(Set mem (StoreCM mem zero));
 6163 
 6164   ins_cost(125); // XXX
 6165   format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
 6166   ins_encode %{
 6167     __ movb($mem$$Address, r12);
 6168   %}
 6169   ins_pipe(ialu_mem_reg);
 6170 %}
 6171 
 6172 instruct storeImmCM0(memory mem, immI0 src)
 6173 %{
 6174   match(Set mem (StoreCM mem src));
 6175 
 6176   ins_cost(150); // XXX
 6177   format %{ &quot;movb    $mem, $src\t# CMS card-mark byte 0&quot; %}
 6178   opcode(0xC6); /* C6 /0 */
 6179   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6180   ins_pipe(ialu_mem_imm);
 6181 %}
 6182 
 6183 // Store Float
 6184 instruct storeF(memory mem, regF src)
 6185 %{
 6186   match(Set mem (StoreF mem src));
 6187 
 6188   ins_cost(95); // XXX
 6189   format %{ &quot;movss   $mem, $src\t# float&quot; %}
 6190   ins_encode %{
 6191     __ movflt($mem$$Address, $src$$XMMRegister);
 6192   %}
 6193   ins_pipe(pipe_slow); // XXX
 6194 %}
 6195 
 6196 // Store immediate Float value (it is faster than store from XMM register)
 6197 instruct storeF0(memory mem, immF0 zero)
 6198 %{
 6199   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6200   match(Set mem (StoreF mem zero));
 6201 
 6202   ins_cost(25); // XXX
 6203   format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
 6204   ins_encode %{
 6205     __ movl($mem$$Address, r12);
 6206   %}
 6207   ins_pipe(ialu_mem_reg);
 6208 %}
 6209 
 6210 instruct storeF_imm(memory mem, immF src)
 6211 %{
 6212   match(Set mem (StoreF mem src));
 6213 
 6214   ins_cost(50);
 6215   format %{ &quot;movl    $mem, $src\t# float&quot; %}
 6216   opcode(0xC7); /* C7 /0 */
 6217   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6218   ins_pipe(ialu_mem_imm);
 6219 %}
 6220 
 6221 // Store Double
 6222 instruct storeD(memory mem, regD src)
 6223 %{
 6224   match(Set mem (StoreD mem src));
 6225 
 6226   ins_cost(95); // XXX
 6227   format %{ &quot;movsd   $mem, $src\t# double&quot; %}
 6228   ins_encode %{
 6229     __ movdbl($mem$$Address, $src$$XMMRegister);
 6230   %}
 6231   ins_pipe(pipe_slow); // XXX
 6232 %}
 6233 
 6234 // Store immediate double 0.0 (it is faster than store from XMM register)
 6235 instruct storeD0_imm(memory mem, immD0 src)
 6236 %{
 6237   predicate(!UseCompressedOops || (CompressedOops::base() != NULL));
 6238   match(Set mem (StoreD mem src));
 6239 
 6240   ins_cost(50);
 6241   format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
 6242   opcode(0xC7); /* C7 /0 */
 6243   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6244   ins_pipe(ialu_mem_imm);
 6245 %}
 6246 
 6247 instruct storeD0(memory mem, immD0 zero)
 6248 %{
 6249   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6250   match(Set mem (StoreD mem zero));
 6251 
 6252   ins_cost(25); // XXX
 6253   format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
 6254   ins_encode %{
 6255     __ movq($mem$$Address, r12);
 6256   %}
 6257   ins_pipe(ialu_mem_reg);
 6258 %}
 6259 
 6260 instruct storeSSI(stackSlotI dst, rRegI src)
 6261 %{
 6262   match(Set dst src);
 6263 
 6264   ins_cost(100);
 6265   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6266   opcode(0x89);
 6267   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 6268   ins_pipe( ialu_mem_reg );
 6269 %}
 6270 
 6271 instruct storeSSL(stackSlotL dst, rRegL src)
 6272 %{
 6273   match(Set dst src);
 6274 
 6275   ins_cost(100);
 6276   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 6277   opcode(0x89);
 6278   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6279   ins_pipe(ialu_mem_reg);
 6280 %}
 6281 
 6282 instruct storeSSP(stackSlotP dst, rRegP src)
 6283 %{
 6284   match(Set dst src);
 6285 
 6286   ins_cost(100);
 6287   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 6288   opcode(0x89);
 6289   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6290   ins_pipe(ialu_mem_reg);
 6291 %}
 6292 
 6293 instruct storeSSF(stackSlotF dst, regF src)
 6294 %{
 6295   match(Set dst src);
 6296 
 6297   ins_cost(95); // XXX
 6298   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 6299   ins_encode %{
 6300     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6301   %}
 6302   ins_pipe(pipe_slow); // XXX
 6303 %}
 6304 
 6305 instruct storeSSD(stackSlotD dst, regD src)
 6306 %{
 6307   match(Set dst src);
 6308 
 6309   ins_cost(95); // XXX
 6310   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 6311   ins_encode %{
 6312     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6313   %}
 6314   ins_pipe(pipe_slow); // XXX
 6315 %}
 6316 
 6317 instruct cacheWB(indirect addr)
 6318 %{
 6319   predicate(VM_Version::supports_data_cache_line_flush());
 6320   match(CacheWB addr);
 6321 
 6322   ins_cost(100);
 6323   format %{&quot;cache wb $addr&quot; %}
 6324   ins_encode %{
 6325     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);
 6326     assert($addr$$disp == 0, &quot;should be&quot;);
 6327     __ cache_wb(Address($addr$$base$$Register, 0));
 6328   %}
 6329   ins_pipe(pipe_slow); // XXX
 6330 %}
 6331 
 6332 instruct cacheWBPreSync()
 6333 %{
 6334   predicate(VM_Version::supports_data_cache_line_flush());
 6335   match(CacheWBPreSync);
 6336 
 6337   ins_cost(100);
 6338   format %{&quot;cache wb presync&quot; %}
 6339   ins_encode %{
 6340     __ cache_wbsync(true);
 6341   %}
 6342   ins_pipe(pipe_slow); // XXX
 6343 %}
 6344 
 6345 instruct cacheWBPostSync()
 6346 %{
 6347   predicate(VM_Version::supports_data_cache_line_flush());
 6348   match(CacheWBPostSync);
 6349 
 6350   ins_cost(100);
 6351   format %{&quot;cache wb postsync&quot; %}
 6352   ins_encode %{
 6353     __ cache_wbsync(false);
 6354   %}
 6355   ins_pipe(pipe_slow); // XXX
 6356 %}
 6357 
 6358 //----------BSWAP Instructions-------------------------------------------------
 6359 instruct bytes_reverse_int(rRegI dst) %{
 6360   match(Set dst (ReverseBytesI dst));
 6361 
 6362   format %{ &quot;bswapl  $dst&quot; %}
 6363   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
 6364   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
 6365   ins_pipe( ialu_reg );
 6366 %}
 6367 
 6368 instruct bytes_reverse_long(rRegL dst) %{
 6369   match(Set dst (ReverseBytesL dst));
 6370 
 6371   format %{ &quot;bswapq  $dst&quot; %}
 6372   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
 6373   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
 6374   ins_pipe( ialu_reg);
 6375 %}
 6376 
 6377 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
 6378   match(Set dst (ReverseBytesUS dst));
 6379   effect(KILL cr);
 6380 
 6381   format %{ &quot;bswapl  $dst\n\t&quot;
 6382             &quot;shrl    $dst,16\n\t&quot; %}
 6383   ins_encode %{
 6384     __ bswapl($dst$$Register);
 6385     __ shrl($dst$$Register, 16);
 6386   %}
 6387   ins_pipe( ialu_reg );
 6388 %}
 6389 
 6390 instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{
 6391   match(Set dst (ReverseBytesS dst));
 6392   effect(KILL cr);
 6393 
 6394   format %{ &quot;bswapl  $dst\n\t&quot;
 6395             &quot;sar     $dst,16\n\t&quot; %}
 6396   ins_encode %{
 6397     __ bswapl($dst$$Register);
 6398     __ sarl($dst$$Register, 16);
 6399   %}
 6400   ins_pipe( ialu_reg );
 6401 %}
 6402 
 6403 //---------- Zeros Count Instructions ------------------------------------------
 6404 
 6405 instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6406   predicate(UseCountLeadingZerosInstruction);
 6407   match(Set dst (CountLeadingZerosI src));
 6408   effect(KILL cr);
 6409 
 6410   format %{ &quot;lzcntl  $dst, $src\t# count leading zeros (int)&quot; %}
 6411   ins_encode %{
 6412     __ lzcntl($dst$$Register, $src$$Register);
 6413   %}
 6414   ins_pipe(ialu_reg);
 6415 %}
 6416 
 6417 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{
 6418   predicate(!UseCountLeadingZerosInstruction);
 6419   match(Set dst (CountLeadingZerosI src));
 6420   effect(KILL cr);
 6421 
 6422   format %{ &quot;bsrl    $dst, $src\t# count leading zeros (int)\n\t&quot;
 6423             &quot;jnz     skip\n\t&quot;
 6424             &quot;movl    $dst, -1\n&quot;
 6425       &quot;skip:\n\t&quot;
 6426             &quot;negl    $dst\n\t&quot;
 6427             &quot;addl    $dst, 31&quot; %}
 6428   ins_encode %{
 6429     Register Rdst = $dst$$Register;
 6430     Register Rsrc = $src$$Register;
 6431     Label skip;
 6432     __ bsrl(Rdst, Rsrc);
 6433     __ jccb(Assembler::notZero, skip);
 6434     __ movl(Rdst, -1);
 6435     __ bind(skip);
 6436     __ negl(Rdst);
 6437     __ addl(Rdst, BitsPerInt - 1);
 6438   %}
 6439   ins_pipe(ialu_reg);
 6440 %}
 6441 
 6442 instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6443   predicate(UseCountLeadingZerosInstruction);
 6444   match(Set dst (CountLeadingZerosL src));
 6445   effect(KILL cr);
 6446 
 6447   format %{ &quot;lzcntq  $dst, $src\t# count leading zeros (long)&quot; %}
 6448   ins_encode %{
 6449     __ lzcntq($dst$$Register, $src$$Register);
 6450   %}
 6451   ins_pipe(ialu_reg);
 6452 %}
 6453 
 6454 instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{
 6455   predicate(!UseCountLeadingZerosInstruction);
 6456   match(Set dst (CountLeadingZerosL src));
 6457   effect(KILL cr);
 6458 
 6459   format %{ &quot;bsrq    $dst, $src\t# count leading zeros (long)\n\t&quot;
 6460             &quot;jnz     skip\n\t&quot;
 6461             &quot;movl    $dst, -1\n&quot;
 6462       &quot;skip:\n\t&quot;
 6463             &quot;negl    $dst\n\t&quot;
 6464             &quot;addl    $dst, 63&quot; %}
 6465   ins_encode %{
 6466     Register Rdst = $dst$$Register;
 6467     Register Rsrc = $src$$Register;
 6468     Label skip;
 6469     __ bsrq(Rdst, Rsrc);
 6470     __ jccb(Assembler::notZero, skip);
 6471     __ movl(Rdst, -1);
 6472     __ bind(skip);
 6473     __ negl(Rdst);
 6474     __ addl(Rdst, BitsPerLong - 1);
 6475   %}
 6476   ins_pipe(ialu_reg);
 6477 %}
 6478 
 6479 instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6480   predicate(UseCountTrailingZerosInstruction);
 6481   match(Set dst (CountTrailingZerosI src));
 6482   effect(KILL cr);
 6483 
 6484   format %{ &quot;tzcntl    $dst, $src\t# count trailing zeros (int)&quot; %}
 6485   ins_encode %{
 6486     __ tzcntl($dst$$Register, $src$$Register);
 6487   %}
 6488   ins_pipe(ialu_reg);
 6489 %}
 6490 
 6491 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{
 6492   predicate(!UseCountTrailingZerosInstruction);
 6493   match(Set dst (CountTrailingZerosI src));
 6494   effect(KILL cr);
 6495 
 6496   format %{ &quot;bsfl    $dst, $src\t# count trailing zeros (int)\n\t&quot;
 6497             &quot;jnz     done\n\t&quot;
 6498             &quot;movl    $dst, 32\n&quot;
 6499       &quot;done:&quot; %}
 6500   ins_encode %{
 6501     Register Rdst = $dst$$Register;
 6502     Label done;
 6503     __ bsfl(Rdst, $src$$Register);
 6504     __ jccb(Assembler::notZero, done);
 6505     __ movl(Rdst, BitsPerInt);
 6506     __ bind(done);
 6507   %}
 6508   ins_pipe(ialu_reg);
 6509 %}
 6510 
 6511 instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6512   predicate(UseCountTrailingZerosInstruction);
 6513   match(Set dst (CountTrailingZerosL src));
 6514   effect(KILL cr);
 6515 
 6516   format %{ &quot;tzcntq    $dst, $src\t# count trailing zeros (long)&quot; %}
 6517   ins_encode %{
 6518     __ tzcntq($dst$$Register, $src$$Register);
 6519   %}
 6520   ins_pipe(ialu_reg);
 6521 %}
 6522 
 6523 instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{
 6524   predicate(!UseCountTrailingZerosInstruction);
 6525   match(Set dst (CountTrailingZerosL src));
 6526   effect(KILL cr);
 6527 
 6528   format %{ &quot;bsfq    $dst, $src\t# count trailing zeros (long)\n\t&quot;
 6529             &quot;jnz     done\n\t&quot;
 6530             &quot;movl    $dst, 64\n&quot;
 6531       &quot;done:&quot; %}
 6532   ins_encode %{
 6533     Register Rdst = $dst$$Register;
 6534     Label done;
 6535     __ bsfq(Rdst, $src$$Register);
 6536     __ jccb(Assembler::notZero, done);
 6537     __ movl(Rdst, BitsPerLong);
 6538     __ bind(done);
 6539   %}
 6540   ins_pipe(ialu_reg);
 6541 %}
 6542 
 6543 
 6544 //---------- Population Count Instructions -------------------------------------
 6545 
 6546 instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6547   predicate(UsePopCountInstruction);
 6548   match(Set dst (PopCountI src));
 6549   effect(KILL cr);
 6550 
 6551   format %{ &quot;popcnt  $dst, $src&quot; %}
 6552   ins_encode %{
 6553     __ popcntl($dst$$Register, $src$$Register);
 6554   %}
 6555   ins_pipe(ialu_reg);
 6556 %}
 6557 
 6558 instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6559   predicate(UsePopCountInstruction);
 6560   match(Set dst (PopCountI (LoadI mem)));
 6561   effect(KILL cr);
 6562 
 6563   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6564   ins_encode %{
 6565     __ popcntl($dst$$Register, $mem$$Address);
 6566   %}
 6567   ins_pipe(ialu_reg);
 6568 %}
 6569 
 6570 // Note: Long.bitCount(long) returns an int.
 6571 instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6572   predicate(UsePopCountInstruction);
 6573   match(Set dst (PopCountL src));
 6574   effect(KILL cr);
 6575 
 6576   format %{ &quot;popcnt  $dst, $src&quot; %}
 6577   ins_encode %{
 6578     __ popcntq($dst$$Register, $src$$Register);
 6579   %}
 6580   ins_pipe(ialu_reg);
 6581 %}
 6582 
 6583 // Note: Long.bitCount(long) returns an int.
 6584 instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6585   predicate(UsePopCountInstruction);
 6586   match(Set dst (PopCountL (LoadL mem)));
 6587   effect(KILL cr);
 6588 
 6589   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6590   ins_encode %{
 6591     __ popcntq($dst$$Register, $mem$$Address);
 6592   %}
 6593   ins_pipe(ialu_reg);
 6594 %}
 6595 
 6596 
 6597 //----------MemBar Instructions-----------------------------------------------
 6598 // Memory barrier flavors
 6599 
 6600 instruct membar_acquire()
 6601 %{
 6602   match(MemBarAcquire);
 6603   match(LoadFence);
 6604   ins_cost(0);
 6605 
 6606   size(0);
 6607   format %{ &quot;MEMBAR-acquire ! (empty encoding)&quot; %}
 6608   ins_encode();
 6609   ins_pipe(empty);
 6610 %}
 6611 
 6612 instruct membar_acquire_lock()
 6613 %{
 6614   match(MemBarAcquireLock);
 6615   ins_cost(0);
 6616 
 6617   size(0);
 6618   format %{ &quot;MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)&quot; %}
 6619   ins_encode();
 6620   ins_pipe(empty);
 6621 %}
 6622 
 6623 instruct membar_release()
 6624 %{
 6625   match(MemBarRelease);
 6626   match(StoreFence);
 6627   ins_cost(0);
 6628 
 6629   size(0);
 6630   format %{ &quot;MEMBAR-release ! (empty encoding)&quot; %}
 6631   ins_encode();
 6632   ins_pipe(empty);
 6633 %}
 6634 
 6635 instruct membar_release_lock()
 6636 %{
 6637   match(MemBarReleaseLock);
 6638   ins_cost(0);
 6639 
 6640   size(0);
 6641   format %{ &quot;MEMBAR-release (a FastUnlock follows so empty encoding)&quot; %}
 6642   ins_encode();
 6643   ins_pipe(empty);
 6644 %}
 6645 
 6646 instruct membar_volatile(rFlagsReg cr) %{
 6647   match(MemBarVolatile);
 6648   effect(KILL cr);
 6649   ins_cost(400);
 6650 
 6651   format %{
 6652     $$template
 6653     $$emit$$&quot;lock addl [rsp + #0], 0\t! membar_volatile&quot;
 6654   %}
 6655   ins_encode %{
 6656     __ membar(Assembler::StoreLoad);
 6657   %}
 6658   ins_pipe(pipe_slow);
 6659 %}
 6660 
 6661 instruct unnecessary_membar_volatile()
 6662 %{
 6663   match(MemBarVolatile);
 6664   predicate(Matcher::post_store_load_barrier(n));
 6665   ins_cost(0);
 6666 
 6667   size(0);
 6668   format %{ &quot;MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6669   ins_encode();
 6670   ins_pipe(empty);
 6671 %}
 6672 
 6673 instruct membar_storestore() %{
 6674   match(MemBarStoreStore);
 6675   ins_cost(0);
 6676 
 6677   size(0);
 6678   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6679   ins_encode( );
 6680   ins_pipe(empty);
 6681 %}
 6682 
 6683 //----------Move Instructions--------------------------------------------------
 6684 
 6685 instruct castX2P(rRegP dst, rRegL src)
 6686 %{
 6687   match(Set dst (CastX2P src));
 6688 
 6689   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6690   ins_encode %{
 6691     if ($dst$$reg != $src$$reg) {
 6692       __ movptr($dst$$Register, $src$$Register);
 6693     }
 6694   %}
 6695   ins_pipe(ialu_reg_reg); // XXX
 6696 %}
 6697 
 6698 instruct castN2X(rRegL dst, rRegN src)
 6699 %{
 6700   match(Set dst (CastP2X src));
 6701 
 6702   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6703   ins_encode %{
 6704     if ($dst$$reg != $src$$reg) {
 6705       __ movptr($dst$$Register, $src$$Register);
 6706     }
 6707   %}
 6708   ins_pipe(ialu_reg_reg); // XXX
 6709 %}
 6710 
 6711 instruct castP2X(rRegL dst, rRegP src)
 6712 %{
 6713   match(Set dst (CastP2X src));
 6714 
 6715   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6716   ins_encode %{
 6717     if ($dst$$reg != $src$$reg) {
 6718       __ movptr($dst$$Register, $src$$Register);
 6719     }
 6720   %}
 6721   ins_pipe(ialu_reg_reg); // XXX
 6722 %}
 6723 
 6724 instruct castN2I(rRegI dst, rRegN src)
 6725 %{
 6726   match(Set dst (CastN2I src));
 6727 
 6728   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6729   ins_encode %{
 6730     if ($dst$$reg != $src$$reg) {
 6731       __ movl($dst$$Register, $src$$Register);
 6732     }
 6733   %}
 6734   ins_pipe(ialu_reg_reg); // XXX
 6735 %}
 6736 
 6737 instruct castI2N(rRegN dst, rRegI src)
 6738 %{
 6739   match(Set dst (CastI2N src));
 6740 
 6741   format %{ &quot;movl    $dst, $src\t# int -&gt; compressed ptr&quot; %}
 6742   ins_encode %{
 6743     if ($dst$$reg != $src$$reg) {
 6744       __ movl($dst$$Register, $src$$Register);
 6745     }
 6746   %}
 6747   ins_pipe(ialu_reg_reg); // XXX
 6748 %}
 6749 
 6750 
 6751 // Convert oop into int for vectors alignment masking
 6752 instruct convP2I(rRegI dst, rRegP src)
 6753 %{
 6754   match(Set dst (ConvL2I (CastP2X src)));
 6755 
 6756   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6757   ins_encode %{
 6758     __ movl($dst$$Register, $src$$Register);
 6759   %}
 6760   ins_pipe(ialu_reg_reg); // XXX
 6761 %}
 6762 
 6763 // Convert compressed oop into int for vectors alignment masking
 6764 // in case of 32bit oops (heap &lt; 4Gb).
 6765 instruct convN2I(rRegI dst, rRegN src)
 6766 %{
 6767   predicate(CompressedOops::shift() == 0);
 6768   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6769 
 6770   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6771   ins_encode %{
 6772     __ movl($dst$$Register, $src$$Register);
 6773   %}
 6774   ins_pipe(ialu_reg_reg); // XXX
 6775 %}
 6776 
 6777 // Convert oop pointer into compressed form
 6778 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
 6779   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 6780   match(Set dst (EncodeP src));
 6781   effect(KILL cr);
 6782   format %{ &quot;encode_heap_oop $dst,$src&quot; %}
 6783   ins_encode %{
 6784     Register s = $src$$Register;
 6785     Register d = $dst$$Register;
 6786     if (s != d) {
 6787       __ movq(d, s);
 6788     }
 6789     __ encode_heap_oop(d);
 6790   %}
 6791   ins_pipe(ialu_reg_long);
 6792 %}
 6793 
 6794 instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6795   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
 6796   match(Set dst (EncodeP src));
 6797   effect(KILL cr);
 6798   format %{ &quot;encode_heap_oop_not_null $dst,$src&quot; %}
 6799   ins_encode %{
 6800     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);
 6801   %}
 6802   ins_pipe(ialu_reg_long);
 6803 %}
 6804 
 6805 instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{
 6806   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 6807             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::Constant);
 6808   match(Set dst (DecodeN src));
 6809   effect(KILL cr);
 6810   format %{ &quot;decode_heap_oop $dst,$src&quot; %}
 6811   ins_encode %{
 6812     Register s = $src$$Register;
 6813     Register d = $dst$$Register;
 6814     if (s != d) {
 6815       __ movq(d, s);
 6816     }
 6817     __ decode_heap_oop(d);
 6818   %}
 6819   ins_pipe(ialu_reg_long);
 6820 %}
 6821 
 6822 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6823   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
 6824             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
 6825   match(Set dst (DecodeN src));
 6826   effect(KILL cr);
 6827   format %{ &quot;decode_heap_oop_not_null $dst,$src&quot; %}
 6828   ins_encode %{
 6829     Register s = $src$$Register;
 6830     Register d = $dst$$Register;
 6831     if (s != d) {
 6832       __ decode_heap_oop_not_null(d, s);
 6833     } else {
 6834       __ decode_heap_oop_not_null(d);
 6835     }
 6836   %}
 6837   ins_pipe(ialu_reg_long);
 6838 %}
 6839 
 6840 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6841   match(Set dst (EncodePKlass src));
 6842   effect(KILL cr);
 6843   format %{ &quot;encode_klass_not_null $dst,$src&quot; %}
 6844   ins_encode %{
 6845     __ encode_klass_not_null($dst$$Register, $src$$Register);
 6846   %}
 6847   ins_pipe(ialu_reg_long);
 6848 %}
 6849 
 6850 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6851   match(Set dst (DecodeNKlass src));
 6852   effect(KILL cr);
 6853   format %{ &quot;decode_klass_not_null $dst,$src&quot; %}
 6854   ins_encode %{
 6855     Register s = $src$$Register;
 6856     Register d = $dst$$Register;
 6857     if (s != d) {
 6858       __ decode_klass_not_null(d, s);
 6859     } else {
 6860       __ decode_klass_not_null(d);
 6861     }
 6862   %}
 6863   ins_pipe(ialu_reg_long);
 6864 %}
 6865 
 6866 
 6867 //----------Conditional Move---------------------------------------------------
 6868 // Jump
 6869 // dummy instruction for generating temp registers
 6870 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
 6871   match(Jump (LShiftL switch_val shift));
 6872   ins_cost(350);
 6873   predicate(false);
 6874   effect(TEMP dest);
 6875 
 6876   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6877             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t&quot; %}
 6878   ins_encode %{
 6879     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6880     // to do that and the compiler is using that register as one it can allocate.
 6881     // So we build it all by hand.
 6882     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
 6883     // ArrayAddress dispatch(table, index);
 6884     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
 6885     __ lea($dest$$Register, $constantaddress);
 6886     __ jmp(dispatch);
 6887   %}
 6888   ins_pipe(pipe_jmp);
 6889 %}
 6890 
 6891 instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{
 6892   match(Jump (AddL (LShiftL switch_val shift) offset));
 6893   ins_cost(350);
 6894   effect(TEMP dest);
 6895 
 6896   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6897             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift + $offset]\n\t&quot; %}
 6898   ins_encode %{
 6899     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6900     // to do that and the compiler is using that register as one it can allocate.
 6901     // So we build it all by hand.
 6902     // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6903     // ArrayAddress dispatch(table, index);
 6904     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6905     __ lea($dest$$Register, $constantaddress);
 6906     __ jmp(dispatch);
 6907   %}
 6908   ins_pipe(pipe_jmp);
 6909 %}
 6910 
 6911 instruct jumpXtnd(rRegL switch_val, rRegI dest) %{
 6912   match(Jump switch_val);
 6913   ins_cost(350);
 6914   effect(TEMP dest);
 6915 
 6916   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6917             &quot;jmp     [$dest + $switch_val]\n\t&quot; %}
 6918   ins_encode %{
 6919     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6920     // to do that and the compiler is using that register as one it can allocate.
 6921     // So we build it all by hand.
 6922     // Address index(noreg, switch_reg, Address::times_1);
 6923     // ArrayAddress dispatch(table, index);
 6924     Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);
 6925     __ lea($dest$$Register, $constantaddress);
 6926     __ jmp(dispatch);
 6927   %}
 6928   ins_pipe(pipe_jmp);
 6929 %}
 6930 
 6931 // Conditional move
 6932 instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)
 6933 %{
 6934   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6935 
 6936   ins_cost(200); // XXX
 6937   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6938   opcode(0x0F, 0x40);
 6939   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6940   ins_pipe(pipe_cmov_reg);
 6941 %}
 6942 
 6943 instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{
 6944   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6945 
 6946   ins_cost(200); // XXX
 6947   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6948   opcode(0x0F, 0x40);
 6949   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6950   ins_pipe(pipe_cmov_reg);
 6951 %}
 6952 
 6953 instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{
 6954   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6955   ins_cost(200);
 6956   expand %{
 6957     cmovI_regU(cop, cr, dst, src);
 6958   %}
 6959 %}
 6960 
 6961 // Conditional move
 6962 instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{
 6963   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6964 
 6965   ins_cost(250); // XXX
 6966   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6967   opcode(0x0F, 0x40);
 6968   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 6969   ins_pipe(pipe_cmov_mem);
 6970 %}
 6971 
 6972 // Conditional move
 6973 instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)
 6974 %{
 6975   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6976 
 6977   ins_cost(250); // XXX
 6978   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6979   opcode(0x0F, 0x40);
 6980   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 6981   ins_pipe(pipe_cmov_mem);
 6982 %}
 6983 
 6984 instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{
 6985   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6986   ins_cost(250);
 6987   expand %{
 6988     cmovI_memU(cop, cr, dst, src);
 6989   %}
 6990 %}
 6991 
 6992 // Conditional move
 6993 instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)
 6994 %{
 6995   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6996 
 6997   ins_cost(200); // XXX
 6998   format %{ &quot;cmovl$cop $dst, $src\t# signed, compressed ptr&quot; %}
 6999   opcode(0x0F, 0x40);
 7000   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7001   ins_pipe(pipe_cmov_reg);
 7002 %}
 7003 
 7004 // Conditional move
 7005 instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)
 7006 %{
 7007   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 7008 
 7009   ins_cost(200); // XXX
 7010   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, compressed ptr&quot; %}
 7011   opcode(0x0F, 0x40);
 7012   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7013   ins_pipe(pipe_cmov_reg);
 7014 %}
 7015 
 7016 instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{
 7017   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 7018   ins_cost(200);
 7019   expand %{
 7020     cmovN_regU(cop, cr, dst, src);
 7021   %}
 7022 %}
 7023 
 7024 // Conditional move
 7025 instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)
 7026 %{
 7027   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7028 
 7029   ins_cost(200); // XXX
 7030   format %{ &quot;cmovq$cop $dst, $src\t# signed, ptr&quot; %}
 7031   opcode(0x0F, 0x40);
 7032   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7033   ins_pipe(pipe_cmov_reg);  // XXX
 7034 %}
 7035 
 7036 // Conditional move
 7037 instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)
 7038 %{
 7039   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7040 
 7041   ins_cost(200); // XXX
 7042   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, ptr&quot; %}
 7043   opcode(0x0F, 0x40);
 7044   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7045   ins_pipe(pipe_cmov_reg); // XXX
 7046 %}
 7047 
 7048 instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{
 7049   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7050   ins_cost(200);
 7051   expand %{
 7052     cmovP_regU(cop, cr, dst, src);
 7053   %}
 7054 %}
 7055 
 7056 // DISABLED: Requires the ADLC to emit a bottom_type call that
 7057 // correctly meets the two pointer arguments; one is an incoming
 7058 // register but the other is a memory operand.  ALSO appears to
 7059 // be buggy with implicit null checks.
 7060 //
 7061 //// Conditional move
 7062 //instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src)
 7063 //%{
 7064 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7065 //  ins_cost(250);
 7066 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7067 //  opcode(0x0F,0x40);
 7068 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7069 //  ins_pipe( pipe_cmov_mem );
 7070 //%}
 7071 //
 7072 //// Conditional move
 7073 //instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)
 7074 //%{
 7075 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7076 //  ins_cost(250);
 7077 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7078 //  opcode(0x0F,0x40);
 7079 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7080 //  ins_pipe( pipe_cmov_mem );
 7081 //%}
 7082 
 7083 instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)
 7084 %{
 7085   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7086 
 7087   ins_cost(200); // XXX
 7088   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7089   opcode(0x0F, 0x40);
 7090   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7091   ins_pipe(pipe_cmov_reg);  // XXX
 7092 %}
 7093 
 7094 instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)
 7095 %{
 7096   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7097 
 7098   ins_cost(200); // XXX
 7099   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7100   opcode(0x0F, 0x40);
 7101   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7102   ins_pipe(pipe_cmov_mem);  // XXX
 7103 %}
 7104 
 7105 instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)
 7106 %{
 7107   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7108 
 7109   ins_cost(200); // XXX
 7110   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7111   opcode(0x0F, 0x40);
 7112   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7113   ins_pipe(pipe_cmov_reg); // XXX
 7114 %}
 7115 
 7116 instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{
 7117   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7118   ins_cost(200);
 7119   expand %{
 7120     cmovL_regU(cop, cr, dst, src);
 7121   %}
 7122 %}
 7123 
 7124 instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)
 7125 %{
 7126   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7127 
 7128   ins_cost(200); // XXX
 7129   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7130   opcode(0x0F, 0x40);
 7131   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7132   ins_pipe(pipe_cmov_mem); // XXX
 7133 %}
 7134 
 7135 instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{
 7136   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7137   ins_cost(200);
 7138   expand %{
 7139     cmovL_memU(cop, cr, dst, src);
 7140   %}
 7141 %}
 7142 
 7143 instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)
 7144 %{
 7145   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7146 
 7147   ins_cost(200); // XXX
 7148   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7149             &quot;movss     $dst, $src\n&quot;
 7150     &quot;skip:&quot; %}
 7151   ins_encode %{
 7152     Label Lskip;
 7153     // Invert sense of branch from sense of CMOV
 7154     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7155     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7156     __ bind(Lskip);
 7157   %}
 7158   ins_pipe(pipe_slow);
 7159 %}
 7160 
 7161 // instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)
 7162 // %{
 7163 //   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));
 7164 
 7165 //   ins_cost(200); // XXX
 7166 //   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7167 //             &quot;movss     $dst, $src\n&quot;
 7168 //     &quot;skip:&quot; %}
 7169 //   ins_encode(enc_cmovf_mem_branch(cop, dst, src));
 7170 //   ins_pipe(pipe_slow);
 7171 // %}
 7172 
 7173 instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)
 7174 %{
 7175   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7176 
 7177   ins_cost(200); // XXX
 7178   format %{ &quot;jn$cop    skip\t# unsigned cmove float\n\t&quot;
 7179             &quot;movss     $dst, $src\n&quot;
 7180     &quot;skip:&quot; %}
 7181   ins_encode %{
 7182     Label Lskip;
 7183     // Invert sense of branch from sense of CMOV
 7184     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7185     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7186     __ bind(Lskip);
 7187   %}
 7188   ins_pipe(pipe_slow);
 7189 %}
 7190 
 7191 instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{
 7192   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7193   ins_cost(200);
 7194   expand %{
 7195     cmovF_regU(cop, cr, dst, src);
 7196   %}
 7197 %}
 7198 
 7199 instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)
 7200 %{
 7201   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7202 
 7203   ins_cost(200); // XXX
 7204   format %{ &quot;jn$cop    skip\t# signed cmove double\n\t&quot;
 7205             &quot;movsd     $dst, $src\n&quot;
 7206     &quot;skip:&quot; %}
 7207   ins_encode %{
 7208     Label Lskip;
 7209     // Invert sense of branch from sense of CMOV
 7210     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7211     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7212     __ bind(Lskip);
 7213   %}
 7214   ins_pipe(pipe_slow);
 7215 %}
 7216 
 7217 instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)
 7218 %{
 7219   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7220 
 7221   ins_cost(200); // XXX
 7222   format %{ &quot;jn$cop    skip\t# unsigned cmove double\n\t&quot;
 7223             &quot;movsd     $dst, $src\n&quot;
 7224     &quot;skip:&quot; %}
 7225   ins_encode %{
 7226     Label Lskip;
 7227     // Invert sense of branch from sense of CMOV
 7228     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7229     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7230     __ bind(Lskip);
 7231   %}
 7232   ins_pipe(pipe_slow);
 7233 %}
 7234 
 7235 instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{
 7236   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7237   ins_cost(200);
 7238   expand %{
 7239     cmovD_regU(cop, cr, dst, src);
 7240   %}
 7241 %}
 7242 
 7243 //----------Arithmetic Instructions--------------------------------------------
 7244 //----------Addition Instructions----------------------------------------------
 7245 
 7246 instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 7247 %{
 7248   match(Set dst (AddI dst src));
 7249   effect(KILL cr);
 7250 
 7251   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7252   opcode(0x03);
 7253   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 7254   ins_pipe(ialu_reg_reg);
 7255 %}
 7256 
 7257 instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 7258 %{
 7259   match(Set dst (AddI dst src));
 7260   effect(KILL cr);
 7261 
 7262   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7263   opcode(0x81, 0x00); /* /0 id */
 7264   ins_encode(OpcSErm(dst, src), Con8or32(src));
 7265   ins_pipe( ialu_reg );
 7266 %}
 7267 
 7268 instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 7269 %{
 7270   match(Set dst (AddI dst (LoadI src)));
 7271   effect(KILL cr);
 7272 
 7273   ins_cost(125); // XXX
 7274   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7275   opcode(0x03);
 7276   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 7277   ins_pipe(ialu_reg_mem);
 7278 %}
 7279 
 7280 instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 7281 %{
 7282   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7283   effect(KILL cr);
 7284 
 7285   ins_cost(150); // XXX
 7286   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7287   opcode(0x01); /* Opcode 01 /r */
 7288   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 7289   ins_pipe(ialu_mem_reg);
 7290 %}
 7291 
 7292 instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)
 7293 %{
 7294   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7295   effect(KILL cr);
 7296 
 7297   ins_cost(125); // XXX
 7298   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7299   opcode(0x81); /* Opcode 81 /0 id */
 7300   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7301   ins_pipe(ialu_mem_imm);
 7302 %}
 7303 
 7304 instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
 7305 %{
 7306   predicate(UseIncDec);
 7307   match(Set dst (AddI dst src));
 7308   effect(KILL cr);
 7309 
 7310   format %{ &quot;incl    $dst\t# int&quot; %}
 7311   opcode(0xFF, 0x00); // FF /0
 7312   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7313   ins_pipe(ialu_reg);
 7314 %}
 7315 
 7316 instruct incI_mem(memory dst, immI1 src, rFlagsReg cr)
 7317 %{
 7318   predicate(UseIncDec);
 7319   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7320   effect(KILL cr);
 7321 
 7322   ins_cost(125); // XXX
 7323   format %{ &quot;incl    $dst\t# int&quot; %}
 7324   opcode(0xFF); /* Opcode FF /0 */
 7325   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));
 7326   ins_pipe(ialu_mem_imm);
 7327 %}
 7328 
 7329 // XXX why does that use AddI
 7330 instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)
 7331 %{
 7332   predicate(UseIncDec);
 7333   match(Set dst (AddI dst src));
 7334   effect(KILL cr);
 7335 
 7336   format %{ &quot;decl    $dst\t# int&quot; %}
 7337   opcode(0xFF, 0x01); // FF /1
 7338   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7339   ins_pipe(ialu_reg);
 7340 %}
 7341 
 7342 // XXX why does that use AddI
 7343 instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)
 7344 %{
 7345   predicate(UseIncDec);
 7346   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7347   effect(KILL cr);
 7348 
 7349   ins_cost(125); // XXX
 7350   format %{ &quot;decl    $dst\t# int&quot; %}
 7351   opcode(0xFF); /* Opcode FF /1 */
 7352   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));
 7353   ins_pipe(ialu_mem_imm);
 7354 %}
 7355 
 7356 instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)
 7357 %{
 7358   match(Set dst (AddI src0 src1));
 7359 
 7360   ins_cost(110);
 7361   format %{ &quot;addr32 leal $dst, [$src0 + $src1]\t# int&quot; %}
 7362   opcode(0x8D); /* 0x8D /r */
 7363   ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7364   ins_pipe(ialu_reg_reg);
 7365 %}
 7366 
 7367 instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 7368 %{
 7369   match(Set dst (AddL dst src));
 7370   effect(KILL cr);
 7371 
 7372   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7373   opcode(0x03);
 7374   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7375   ins_pipe(ialu_reg_reg);
 7376 %}
 7377 
 7378 instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 7379 %{
 7380   match(Set dst (AddL dst src));
 7381   effect(KILL cr);
 7382 
 7383   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7384   opcode(0x81, 0x00); /* /0 id */
 7385   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7386   ins_pipe( ialu_reg );
 7387 %}
 7388 
 7389 instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 7390 %{
 7391   match(Set dst (AddL dst (LoadL src)));
 7392   effect(KILL cr);
 7393 
 7394   ins_cost(125); // XXX
 7395   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7396   opcode(0x03);
 7397   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 7398   ins_pipe(ialu_reg_mem);
 7399 %}
 7400 
 7401 instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 7402 %{
 7403   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7404   effect(KILL cr);
 7405 
 7406   ins_cost(150); // XXX
 7407   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7408   opcode(0x01); /* Opcode 01 /r */
 7409   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 7410   ins_pipe(ialu_mem_reg);
 7411 %}
 7412 
 7413 instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 7414 %{
 7415   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7416   effect(KILL cr);
 7417 
 7418   ins_cost(125); // XXX
 7419   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7420   opcode(0x81); /* Opcode 81 /0 id */
 7421   ins_encode(REX_mem_wide(dst),
 7422              OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7423   ins_pipe(ialu_mem_imm);
 7424 %}
 7425 
 7426 instruct incL_rReg(rRegI dst, immL1 src, rFlagsReg cr)
 7427 %{
 7428   predicate(UseIncDec);
 7429   match(Set dst (AddL dst src));
 7430   effect(KILL cr);
 7431 
 7432   format %{ &quot;incq    $dst\t# long&quot; %}
 7433   opcode(0xFF, 0x00); // FF /0
 7434   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7435   ins_pipe(ialu_reg);
 7436 %}
 7437 
 7438 instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)
 7439 %{
 7440   predicate(UseIncDec);
 7441   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7442   effect(KILL cr);
 7443 
 7444   ins_cost(125); // XXX
 7445   format %{ &quot;incq    $dst\t# long&quot; %}
 7446   opcode(0xFF); /* Opcode FF /0 */
 7447   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));
 7448   ins_pipe(ialu_mem_imm);
 7449 %}
 7450 
 7451 // XXX why does that use AddL
 7452 instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)
 7453 %{
 7454   predicate(UseIncDec);
 7455   match(Set dst (AddL dst src));
 7456   effect(KILL cr);
 7457 
 7458   format %{ &quot;decq    $dst\t# long&quot; %}
 7459   opcode(0xFF, 0x01); // FF /1
 7460   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7461   ins_pipe(ialu_reg);
 7462 %}
 7463 
 7464 // XXX why does that use AddL
 7465 instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)
 7466 %{
 7467   predicate(UseIncDec);
 7468   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7469   effect(KILL cr);
 7470 
 7471   ins_cost(125); // XXX
 7472   format %{ &quot;decq    $dst\t# long&quot; %}
 7473   opcode(0xFF); /* Opcode FF /1 */
 7474   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));
 7475   ins_pipe(ialu_mem_imm);
 7476 %}
 7477 
 7478 instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)
 7479 %{
 7480   match(Set dst (AddL src0 src1));
 7481 
 7482   ins_cost(110);
 7483   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# long&quot; %}
 7484   opcode(0x8D); /* 0x8D /r */
 7485   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7486   ins_pipe(ialu_reg_reg);
 7487 %}
 7488 
 7489 instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)
 7490 %{
 7491   match(Set dst (AddP dst src));
 7492   effect(KILL cr);
 7493 
 7494   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7495   opcode(0x03);
 7496   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7497   ins_pipe(ialu_reg_reg);
 7498 %}
 7499 
 7500 instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
 7501 %{
 7502   match(Set dst (AddP dst src));
 7503   effect(KILL cr);
 7504 
 7505   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7506   opcode(0x81, 0x00); /* /0 id */
 7507   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7508   ins_pipe( ialu_reg );
 7509 %}
 7510 
 7511 // XXX addP mem ops ????
 7512 
 7513 instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)
 7514 %{
 7515   match(Set dst (AddP src0 src1));
 7516 
 7517   ins_cost(110);
 7518   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# ptr&quot; %}
 7519   opcode(0x8D); /* 0x8D /r */
 7520   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));// XXX
 7521   ins_pipe(ialu_reg_reg);
 7522 %}
 7523 
 7524 instruct checkCastPP(rRegP dst)
 7525 %{
 7526   match(Set dst (CheckCastPP dst));
 7527 
 7528   size(0);
 7529   format %{ &quot;# checkcastPP of $dst&quot; %}
 7530   ins_encode(/* empty encoding */);
 7531   ins_pipe(empty);
 7532 %}
 7533 
 7534 instruct castPP(rRegP dst)
 7535 %{
 7536   match(Set dst (CastPP dst));
 7537 
 7538   size(0);
 7539   format %{ &quot;# castPP of $dst&quot; %}
 7540   ins_encode(/* empty encoding */);
 7541   ins_pipe(empty);
 7542 %}
 7543 
 7544 instruct castII(rRegI dst)
 7545 %{
 7546   match(Set dst (CastII dst));
 7547 
 7548   size(0);
 7549   format %{ &quot;# castII of $dst&quot; %}
 7550   ins_encode(/* empty encoding */);
 7551   ins_cost(0);
 7552   ins_pipe(empty);
 7553 %}
 7554 
 7555 instruct castLL(rRegL dst)
 7556 %{
 7557   match(Set dst (CastLL dst));
 7558 
 7559   size(0);
 7560   format %{ &quot;# castLL of $dst&quot; %}
 7561   ins_encode(/* empty encoding */);
 7562   ins_cost(0);
 7563   ins_pipe(empty);
 7564 %}
 7565 
 7566 // LoadP-locked same as a regular LoadP when used with compare-swap
 7567 instruct loadPLocked(rRegP dst, memory mem)
 7568 %{
 7569   match(Set dst (LoadPLocked mem));
 7570 
 7571   ins_cost(125); // XXX
 7572   format %{ &quot;movq    $dst, $mem\t# ptr locked&quot; %}
 7573   opcode(0x8B);
 7574   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 7575   ins_pipe(ialu_reg_mem); // XXX
 7576 %}
 7577 
 7578 // Conditional-store of the updated heap-top.
 7579 // Used during allocation of the shared heap.
 7580 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7581 
 7582 instruct storePConditional(memory heap_top_ptr,
 7583                            rax_RegP oldval, rRegP newval,
 7584                            rFlagsReg cr)
 7585 %{
 7586   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7587   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7588 
 7589   format %{ &quot;cmpxchgq $heap_top_ptr, $newval\t# (ptr) &quot;
 7590             &quot;If rax == $heap_top_ptr then store $newval into $heap_top_ptr&quot; %}
 7591   opcode(0x0F, 0xB1);
 7592   ins_encode(lock_prefix,
 7593              REX_reg_mem_wide(newval, heap_top_ptr),
 7594              OpcP, OpcS,
 7595              reg_mem(newval, heap_top_ptr));
 7596   ins_pipe(pipe_cmpxchg);
 7597 %}
 7598 
 7599 // Conditional-store of an int value.
 7600 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7601 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
 7602 %{
 7603   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7604   effect(KILL oldval);
 7605 
 7606   format %{ &quot;cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7607   opcode(0x0F, 0xB1);
 7608   ins_encode(lock_prefix,
 7609              REX_reg_mem(newval, mem),
 7610              OpcP, OpcS,
 7611              reg_mem(newval, mem));
 7612   ins_pipe(pipe_cmpxchg);
 7613 %}
 7614 
 7615 // Conditional-store of a long value.
 7616 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7617 instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)
 7618 %{
 7619   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7620   effect(KILL oldval);
 7621 
 7622   format %{ &quot;cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7623   opcode(0x0F, 0xB1);
 7624   ins_encode(lock_prefix,
 7625              REX_reg_mem_wide(newval, mem),
 7626              OpcP, OpcS,
 7627              reg_mem(newval, mem));
 7628   ins_pipe(pipe_cmpxchg);
 7629 %}
 7630 
 7631 
 7632 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7633 instruct compareAndSwapP(rRegI res,
 7634                          memory mem_ptr,
 7635                          rax_RegP oldval, rRegP newval,
 7636                          rFlagsReg cr)
 7637 %{
 7638   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7639   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7640   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7641   effect(KILL cr, KILL oldval);
 7642 
 7643   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7644             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7645             &quot;sete    $res\n\t&quot;
 7646             &quot;movzbl  $res, $res&quot; %}
 7647   opcode(0x0F, 0xB1);
 7648   ins_encode(lock_prefix,
 7649              REX_reg_mem_wide(newval, mem_ptr),
 7650              OpcP, OpcS,
 7651              reg_mem(newval, mem_ptr),
 7652              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7653              REX_reg_breg(res, res), // movzbl
 7654              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7655   ins_pipe( pipe_cmpxchg );
 7656 %}
 7657 
 7658 instruct compareAndSwapL(rRegI res,
 7659                          memory mem_ptr,
 7660                          rax_RegL oldval, rRegL newval,
 7661                          rFlagsReg cr)
 7662 %{
 7663   predicate(VM_Version::supports_cx8());
 7664   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 7665   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 7666   effect(KILL cr, KILL oldval);
 7667 
 7668   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7669             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7670             &quot;sete    $res\n\t&quot;
 7671             &quot;movzbl  $res, $res&quot; %}
 7672   opcode(0x0F, 0xB1);
 7673   ins_encode(lock_prefix,
 7674              REX_reg_mem_wide(newval, mem_ptr),
 7675              OpcP, OpcS,
 7676              reg_mem(newval, mem_ptr),
 7677              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7678              REX_reg_breg(res, res), // movzbl
 7679              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7680   ins_pipe( pipe_cmpxchg );
 7681 %}
 7682 
 7683 instruct compareAndSwapI(rRegI res,
 7684                          memory mem_ptr,
 7685                          rax_RegI oldval, rRegI newval,
 7686                          rFlagsReg cr)
 7687 %{
 7688   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 7689   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 7690   effect(KILL cr, KILL oldval);
 7691 
 7692   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7693             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7694             &quot;sete    $res\n\t&quot;
 7695             &quot;movzbl  $res, $res&quot; %}
 7696   opcode(0x0F, 0xB1);
 7697   ins_encode(lock_prefix,
 7698              REX_reg_mem(newval, mem_ptr),
 7699              OpcP, OpcS,
 7700              reg_mem(newval, mem_ptr),
 7701              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7702              REX_reg_breg(res, res), // movzbl
 7703              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7704   ins_pipe( pipe_cmpxchg );
 7705 %}
 7706 
 7707 instruct compareAndSwapB(rRegI res,
 7708                          memory mem_ptr,
 7709                          rax_RegI oldval, rRegI newval,
 7710                          rFlagsReg cr)
 7711 %{
 7712   match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
 7713   match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));
 7714   effect(KILL cr, KILL oldval);
 7715 
 7716   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7717             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7718             &quot;sete    $res\n\t&quot;
 7719             &quot;movzbl  $res, $res&quot; %}
 7720   opcode(0x0F, 0xB0);
 7721   ins_encode(lock_prefix,
 7722              REX_breg_mem(newval, mem_ptr),
 7723              OpcP, OpcS,
 7724              reg_mem(newval, mem_ptr),
 7725              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7726              REX_reg_breg(res, res), // movzbl
 7727              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7728   ins_pipe( pipe_cmpxchg );
 7729 %}
 7730 
 7731 instruct compareAndSwapS(rRegI res,
 7732                          memory mem_ptr,
 7733                          rax_RegI oldval, rRegI newval,
 7734                          rFlagsReg cr)
 7735 %{
 7736   match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
 7737   match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));
 7738   effect(KILL cr, KILL oldval);
 7739 
 7740   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7741             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7742             &quot;sete    $res\n\t&quot;
 7743             &quot;movzbl  $res, $res&quot; %}
 7744   opcode(0x0F, 0xB1);
 7745   ins_encode(lock_prefix,
 7746              SizePrefix,
 7747              REX_reg_mem(newval, mem_ptr),
 7748              OpcP, OpcS,
 7749              reg_mem(newval, mem_ptr),
 7750              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7751              REX_reg_breg(res, res), // movzbl
 7752              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7753   ins_pipe( pipe_cmpxchg );
 7754 %}
 7755 
 7756 instruct compareAndSwapN(rRegI res,
 7757                           memory mem_ptr,
 7758                           rax_RegN oldval, rRegN newval,
 7759                           rFlagsReg cr) %{
 7760   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 7761   match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));
 7762   effect(KILL cr, KILL oldval);
 7763 
 7764   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7765             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7766             &quot;sete    $res\n\t&quot;
 7767             &quot;movzbl  $res, $res&quot; %}
 7768   opcode(0x0F, 0xB1);
 7769   ins_encode(lock_prefix,
 7770              REX_reg_mem(newval, mem_ptr),
 7771              OpcP, OpcS,
 7772              reg_mem(newval, mem_ptr),
 7773              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7774              REX_reg_breg(res, res), // movzbl
 7775              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7776   ins_pipe( pipe_cmpxchg );
 7777 %}
 7778 
 7779 instruct compareAndExchangeB(
 7780                          memory mem_ptr,
 7781                          rax_RegI oldval, rRegI newval,
 7782                          rFlagsReg cr)
 7783 %{
 7784   match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));
 7785   effect(KILL cr);
 7786 
 7787   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7788             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7789   opcode(0x0F, 0xB0);
 7790   ins_encode(lock_prefix,
 7791              REX_breg_mem(newval, mem_ptr),
 7792              OpcP, OpcS,
 7793              reg_mem(newval, mem_ptr) // lock cmpxchg
 7794              );
 7795   ins_pipe( pipe_cmpxchg );
 7796 %}
 7797 
 7798 instruct compareAndExchangeS(
 7799                          memory mem_ptr,
 7800                          rax_RegI oldval, rRegI newval,
 7801                          rFlagsReg cr)
 7802 %{
 7803   match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));
 7804   effect(KILL cr);
 7805 
 7806   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7807             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7808   opcode(0x0F, 0xB1);
 7809   ins_encode(lock_prefix,
 7810              SizePrefix,
 7811              REX_reg_mem(newval, mem_ptr),
 7812              OpcP, OpcS,
 7813              reg_mem(newval, mem_ptr) // lock cmpxchg
 7814              );
 7815   ins_pipe( pipe_cmpxchg );
 7816 %}
 7817 
 7818 instruct compareAndExchangeI(
 7819                          memory mem_ptr,
 7820                          rax_RegI oldval, rRegI newval,
 7821                          rFlagsReg cr)
 7822 %{
 7823   match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7824   effect(KILL cr);
 7825 
 7826   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7827             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7828   opcode(0x0F, 0xB1);
 7829   ins_encode(lock_prefix,
 7830              REX_reg_mem(newval, mem_ptr),
 7831              OpcP, OpcS,
 7832              reg_mem(newval, mem_ptr) // lock cmpxchg
 7833              );
 7834   ins_pipe( pipe_cmpxchg );
 7835 %}
 7836 
 7837 instruct compareAndExchangeL(
 7838                          memory mem_ptr,
 7839                          rax_RegL oldval, rRegL newval,
 7840                          rFlagsReg cr)
 7841 %{
 7842   predicate(VM_Version::supports_cx8());
 7843   match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7844   effect(KILL cr);
 7845 
 7846   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7847             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7848   opcode(0x0F, 0xB1);
 7849   ins_encode(lock_prefix,
 7850              REX_reg_mem_wide(newval, mem_ptr),
 7851              OpcP, OpcS,
 7852              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7853             );
 7854   ins_pipe( pipe_cmpxchg );
 7855 %}
 7856 
 7857 instruct compareAndExchangeN(
 7858                           memory mem_ptr,
 7859                           rax_RegN oldval, rRegN newval,
 7860                           rFlagsReg cr) %{
 7861   match(Set oldval (CompareAndExchangeN mem_ptr (Binary oldval newval)));
 7862   effect(KILL cr);
 7863 
 7864   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7865             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7866   opcode(0x0F, 0xB1);
 7867   ins_encode(lock_prefix,
 7868              REX_reg_mem(newval, mem_ptr),
 7869              OpcP, OpcS,
 7870              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7871           );
 7872   ins_pipe( pipe_cmpxchg );
 7873 %}
 7874 
 7875 instruct compareAndExchangeP(
 7876                          memory mem_ptr,
 7877                          rax_RegP oldval, rRegP newval,
 7878                          rFlagsReg cr)
 7879 %{
 7880   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7881   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7882   effect(KILL cr);
 7883 
 7884   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7885             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7886   opcode(0x0F, 0xB1);
 7887   ins_encode(lock_prefix,
 7888              REX_reg_mem_wide(newval, mem_ptr),
 7889              OpcP, OpcS,
 7890              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7891           );
 7892   ins_pipe( pipe_cmpxchg );
 7893 %}
 7894 
 7895 instruct xaddB_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7896   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7897   match(Set dummy (GetAndAddB mem add));
 7898   effect(KILL cr);
 7899   format %{ &quot;ADDB  [$mem],$add&quot; %}
 7900   ins_encode %{
 7901     __ lock();
 7902     __ addb($mem$$Address, $add$$constant);
 7903   %}
 7904   ins_pipe( pipe_cmpxchg );
 7905 %}
 7906 
 7907 instruct xaddB( memory mem, rRegI newval, rFlagsReg cr) %{
 7908   match(Set newval (GetAndAddB mem newval));
 7909   effect(KILL cr);
 7910   format %{ &quot;XADDB  [$mem],$newval&quot; %}
 7911   ins_encode %{
 7912     __ lock();
 7913     __ xaddb($mem$$Address, $newval$$Register);
 7914   %}
 7915   ins_pipe( pipe_cmpxchg );
 7916 %}
 7917 
 7918 instruct xaddS_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7919   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7920   match(Set dummy (GetAndAddS mem add));
 7921   effect(KILL cr);
 7922   format %{ &quot;ADDW  [$mem],$add&quot; %}
 7923   ins_encode %{
 7924     __ lock();
 7925     __ addw($mem$$Address, $add$$constant);
 7926   %}
 7927   ins_pipe( pipe_cmpxchg );
 7928 %}
 7929 
 7930 instruct xaddS( memory mem, rRegI newval, rFlagsReg cr) %{
 7931   match(Set newval (GetAndAddS mem newval));
 7932   effect(KILL cr);
 7933   format %{ &quot;XADDW  [$mem],$newval&quot; %}
 7934   ins_encode %{
 7935     __ lock();
 7936     __ xaddw($mem$$Address, $newval$$Register);
 7937   %}
 7938   ins_pipe( pipe_cmpxchg );
 7939 %}
 7940 
 7941 instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7942   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7943   match(Set dummy (GetAndAddI mem add));
 7944   effect(KILL cr);
 7945   format %{ &quot;ADDL  [$mem],$add&quot; %}
 7946   ins_encode %{
 7947     __ lock();
 7948     __ addl($mem$$Address, $add$$constant);
 7949   %}
 7950   ins_pipe( pipe_cmpxchg );
 7951 %}
 7952 
 7953 instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{
 7954   match(Set newval (GetAndAddI mem newval));
 7955   effect(KILL cr);
 7956   format %{ &quot;XADDL  [$mem],$newval&quot; %}
 7957   ins_encode %{
 7958     __ lock();
 7959     __ xaddl($mem$$Address, $newval$$Register);
 7960   %}
 7961   ins_pipe( pipe_cmpxchg );
 7962 %}
 7963 
 7964 instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{
 7965   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7966   match(Set dummy (GetAndAddL mem add));
 7967   effect(KILL cr);
 7968   format %{ &quot;ADDQ  [$mem],$add&quot; %}
 7969   ins_encode %{
 7970     __ lock();
 7971     __ addq($mem$$Address, $add$$constant);
 7972   %}
 7973   ins_pipe( pipe_cmpxchg );
 7974 %}
 7975 
 7976 instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{
 7977   match(Set newval (GetAndAddL mem newval));
 7978   effect(KILL cr);
 7979   format %{ &quot;XADDQ  [$mem],$newval&quot; %}
 7980   ins_encode %{
 7981     __ lock();
 7982     __ xaddq($mem$$Address, $newval$$Register);
 7983   %}
 7984   ins_pipe( pipe_cmpxchg );
 7985 %}
 7986 
 7987 instruct xchgB( memory mem, rRegI newval) %{
 7988   match(Set newval (GetAndSetB mem newval));
 7989   format %{ &quot;XCHGB  $newval,[$mem]&quot; %}
 7990   ins_encode %{
 7991     __ xchgb($newval$$Register, $mem$$Address);
 7992   %}
 7993   ins_pipe( pipe_cmpxchg );
 7994 %}
 7995 
 7996 instruct xchgS( memory mem, rRegI newval) %{
 7997   match(Set newval (GetAndSetS mem newval));
 7998   format %{ &quot;XCHGW  $newval,[$mem]&quot; %}
 7999   ins_encode %{
 8000     __ xchgw($newval$$Register, $mem$$Address);
 8001   %}
 8002   ins_pipe( pipe_cmpxchg );
 8003 %}
 8004 
 8005 instruct xchgI( memory mem, rRegI newval) %{
 8006   match(Set newval (GetAndSetI mem newval));
 8007   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 8008   ins_encode %{
 8009     __ xchgl($newval$$Register, $mem$$Address);
 8010   %}
 8011   ins_pipe( pipe_cmpxchg );
 8012 %}
 8013 
 8014 instruct xchgL( memory mem, rRegL newval) %{
 8015   match(Set newval (GetAndSetL mem newval));
 8016   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 8017   ins_encode %{
 8018     __ xchgq($newval$$Register, $mem$$Address);
 8019   %}
 8020   ins_pipe( pipe_cmpxchg );
 8021 %}
 8022 
 8023 instruct xchgP( memory mem, rRegP newval) %{
 8024   match(Set newval (GetAndSetP mem newval));
 8025   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 8026   format %{ &quot;XCHGQ  $newval,[$mem]&quot; %}
 8027   ins_encode %{
 8028     __ xchgq($newval$$Register, $mem$$Address);
 8029   %}
 8030   ins_pipe( pipe_cmpxchg );
 8031 %}
 8032 
 8033 instruct xchgN( memory mem, rRegN newval) %{
 8034   match(Set newval (GetAndSetN mem newval));
 8035   format %{ &quot;XCHGL  $newval,$mem]&quot; %}
 8036   ins_encode %{
 8037     __ xchgl($newval$$Register, $mem$$Address);
 8038   %}
 8039   ins_pipe( pipe_cmpxchg );
 8040 %}
 8041 
 8042 //----------Abs Instructions-------------------------------------------
 8043 
 8044 // Integer Absolute Instructions
 8045 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, rFlagsReg cr)
 8046 %{
 8047   match(Set dst (AbsI src));
 8048   effect(TEMP dst, TEMP tmp, KILL cr);
 8049   format %{ &quot;movl $tmp, $src\n\t&quot;
 8050             &quot;sarl $tmp, 31\n\t&quot;
 8051             &quot;movl $dst, $src\n\t&quot;
 8052             &quot;xorl $dst, $tmp\n\t&quot;
 8053             &quot;subl $dst, $tmp\n&quot;
 8054           %}
 8055   ins_encode %{
 8056     __ movl($tmp$$Register, $src$$Register);
 8057     __ sarl($tmp$$Register, 31);
 8058     __ movl($dst$$Register, $src$$Register);
 8059     __ xorl($dst$$Register, $tmp$$Register);
 8060     __ subl($dst$$Register, $tmp$$Register);
 8061   %}
 8062 
 8063   ins_pipe(ialu_reg_reg);
 8064 %}
 8065 
 8066 // Long Absolute Instructions
 8067 instruct absL_rReg(rRegL dst, rRegL src, rRegL tmp, rFlagsReg cr)
 8068 %{
 8069   match(Set dst (AbsL src));
 8070   effect(TEMP dst, TEMP tmp, KILL cr);
 8071   format %{ &quot;movq $tmp, $src\n\t&quot;
 8072             &quot;sarq $tmp, 63\n\t&quot;
 8073             &quot;movq $dst, $src\n\t&quot;
 8074             &quot;xorq $dst, $tmp\n\t&quot;
 8075             &quot;subq $dst, $tmp\n&quot;
 8076           %}
 8077   ins_encode %{
 8078     __ movq($tmp$$Register, $src$$Register);
 8079     __ sarq($tmp$$Register, 63);
 8080     __ movq($dst$$Register, $src$$Register);
 8081     __ xorq($dst$$Register, $tmp$$Register);
 8082     __ subq($dst$$Register, $tmp$$Register);
 8083   %}
 8084 
 8085   ins_pipe(ialu_reg_reg);
 8086 %}
 8087 
 8088 //----------Subtraction Instructions-------------------------------------------
 8089 
 8090 // Integer Subtraction Instructions
 8091 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8092 %{
 8093   match(Set dst (SubI dst src));
 8094   effect(KILL cr);
 8095 
 8096   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8097   opcode(0x2B);
 8098   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 8099   ins_pipe(ialu_reg_reg);
 8100 %}
 8101 
 8102 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 8103 %{
 8104   match(Set dst (SubI dst src));
 8105   effect(KILL cr);
 8106 
 8107   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8108   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8109   ins_encode(OpcSErm(dst, src), Con8or32(src));
 8110   ins_pipe(ialu_reg);
 8111 %}
 8112 
 8113 instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 8114 %{
 8115   match(Set dst (SubI dst (LoadI src)));
 8116   effect(KILL cr);
 8117 
 8118   ins_cost(125);
 8119   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8120   opcode(0x2B);
 8121   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 8122   ins_pipe(ialu_reg_mem);
 8123 %}
 8124 
 8125 instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 8126 %{
 8127   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8128   effect(KILL cr);
 8129 
 8130   ins_cost(150);
 8131   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8132   opcode(0x29); /* Opcode 29 /r */
 8133   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 8134   ins_pipe(ialu_mem_reg);
 8135 %}
 8136 
 8137 instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)
 8138 %{
 8139   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8140   effect(KILL cr);
 8141 
 8142   ins_cost(125); // XXX
 8143   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8144   opcode(0x81); /* Opcode 81 /5 id */
 8145   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8146   ins_pipe(ialu_mem_imm);
 8147 %}
 8148 
 8149 instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8150 %{
 8151   match(Set dst (SubL dst src));
 8152   effect(KILL cr);
 8153 
 8154   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8155   opcode(0x2B);
 8156   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8157   ins_pipe(ialu_reg_reg);
 8158 %}
 8159 
 8160 instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)
 8161 %{
 8162   match(Set dst (SubL dst src));
 8163   effect(KILL cr);
 8164 
 8165   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8166   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8167   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 8168   ins_pipe(ialu_reg);
 8169 %}
 8170 
 8171 instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 8172 %{
 8173   match(Set dst (SubL dst (LoadL src)));
 8174   effect(KILL cr);
 8175 
 8176   ins_cost(125);
 8177   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8178   opcode(0x2B);
 8179   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 8180   ins_pipe(ialu_reg_mem);
 8181 %}
 8182 
 8183 instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 8184 %{
 8185   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8186   effect(KILL cr);
 8187 
 8188   ins_cost(150);
 8189   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8190   opcode(0x29); /* Opcode 29 /r */
 8191   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 8192   ins_pipe(ialu_mem_reg);
 8193 %}
 8194 
 8195 instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 8196 %{
 8197   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8198   effect(KILL cr);
 8199 
 8200   ins_cost(125); // XXX
 8201   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8202   opcode(0x81); /* Opcode 81 /5 id */
 8203   ins_encode(REX_mem_wide(dst),
 8204              OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8205   ins_pipe(ialu_mem_imm);
 8206 %}
 8207 
 8208 // Subtract from a pointer
 8209 // XXX hmpf???
 8210 instruct subP_rReg(rRegP dst, rRegI src, immI0 zero, rFlagsReg cr)
 8211 %{
 8212   match(Set dst (AddP dst (SubI zero src)));
 8213   effect(KILL cr);
 8214 
 8215   format %{ &quot;subq    $dst, $src\t# ptr - int&quot; %}
 8216   opcode(0x2B);
 8217   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8218   ins_pipe(ialu_reg_reg);
 8219 %}
 8220 
 8221 instruct negI_rReg(rRegI dst, immI0 zero, rFlagsReg cr)
 8222 %{
 8223   match(Set dst (SubI zero dst));
 8224   effect(KILL cr);
 8225 
 8226   format %{ &quot;negl    $dst\t# int&quot; %}
 8227   opcode(0xF7, 0x03);  // Opcode F7 /3
 8228   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8229   ins_pipe(ialu_reg);
 8230 %}
 8231 
 8232 instruct negI_mem(memory dst, immI0 zero, rFlagsReg cr)
 8233 %{
 8234   match(Set dst (StoreI dst (SubI zero (LoadI dst))));
 8235   effect(KILL cr);
 8236 
 8237   format %{ &quot;negl    $dst\t# int&quot; %}
 8238   opcode(0xF7, 0x03);  // Opcode F7 /3
 8239   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8240   ins_pipe(ialu_reg);
 8241 %}
 8242 
 8243 instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)
 8244 %{
 8245   match(Set dst (SubL zero dst));
 8246   effect(KILL cr);
 8247 
 8248   format %{ &quot;negq    $dst\t# long&quot; %}
 8249   opcode(0xF7, 0x03);  // Opcode F7 /3
 8250   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8251   ins_pipe(ialu_reg);
 8252 %}
 8253 
 8254 instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)
 8255 %{
 8256   match(Set dst (StoreL dst (SubL zero (LoadL dst))));
 8257   effect(KILL cr);
 8258 
 8259   format %{ &quot;negq    $dst\t# long&quot; %}
 8260   opcode(0xF7, 0x03);  // Opcode F7 /3
 8261   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8262   ins_pipe(ialu_reg);
 8263 %}
 8264 
 8265 //----------Multiplication/Division Instructions-------------------------------
 8266 // Integer Multiplication Instructions
 8267 // Multiply Register
 8268 
 8269 instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8270 %{
 8271   match(Set dst (MulI dst src));
 8272   effect(KILL cr);
 8273 
 8274   ins_cost(300);
 8275   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8276   opcode(0x0F, 0xAF);
 8277   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8278   ins_pipe(ialu_reg_reg_alu0);
 8279 %}
 8280 
 8281 instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)
 8282 %{
 8283   match(Set dst (MulI src imm));
 8284   effect(KILL cr);
 8285 
 8286   ins_cost(300);
 8287   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8288   opcode(0x69); /* 69 /r id */
 8289   ins_encode(REX_reg_reg(dst, src),
 8290              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8291   ins_pipe(ialu_reg_reg_alu0);
 8292 %}
 8293 
 8294 instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)
 8295 %{
 8296   match(Set dst (MulI dst (LoadI src)));
 8297   effect(KILL cr);
 8298 
 8299   ins_cost(350);
 8300   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8301   opcode(0x0F, 0xAF);
 8302   ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8303   ins_pipe(ialu_reg_mem_alu0);
 8304 %}
 8305 
 8306 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)
 8307 %{
 8308   match(Set dst (MulI (LoadI src) imm));
 8309   effect(KILL cr);
 8310 
 8311   ins_cost(300);
 8312   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8313   opcode(0x69); /* 69 /r id */
 8314   ins_encode(REX_reg_mem(dst, src),
 8315              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8316   ins_pipe(ialu_reg_mem_alu0);
 8317 %}
 8318 
 8319 instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, rFlagsReg cr)
 8320 %{
 8321   match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));
 8322   effect(KILL cr, KILL src2);
 8323 
 8324   expand %{ mulI_rReg(dst, src1, cr);
 8325            mulI_rReg(src2, src3, cr);
 8326            addI_rReg(dst, src2, cr); %}
 8327 %}
 8328 
 8329 instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8330 %{
 8331   match(Set dst (MulL dst src));
 8332   effect(KILL cr);
 8333 
 8334   ins_cost(300);
 8335   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8336   opcode(0x0F, 0xAF);
 8337   ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8338   ins_pipe(ialu_reg_reg_alu0);
 8339 %}
 8340 
 8341 instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)
 8342 %{
 8343   match(Set dst (MulL src imm));
 8344   effect(KILL cr);
 8345 
 8346   ins_cost(300);
 8347   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8348   opcode(0x69); /* 69 /r id */
 8349   ins_encode(REX_reg_reg_wide(dst, src),
 8350              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8351   ins_pipe(ialu_reg_reg_alu0);
 8352 %}
 8353 
 8354 instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)
 8355 %{
 8356   match(Set dst (MulL dst (LoadL src)));
 8357   effect(KILL cr);
 8358 
 8359   ins_cost(350);
 8360   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8361   opcode(0x0F, 0xAF);
 8362   ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8363   ins_pipe(ialu_reg_mem_alu0);
 8364 %}
 8365 
 8366 instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)
 8367 %{
 8368   match(Set dst (MulL (LoadL src) imm));
 8369   effect(KILL cr);
 8370 
 8371   ins_cost(300);
 8372   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8373   opcode(0x69); /* 69 /r id */
 8374   ins_encode(REX_reg_mem_wide(dst, src),
 8375              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8376   ins_pipe(ialu_reg_mem_alu0);
 8377 %}
 8378 
 8379 instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8380 %{
 8381   match(Set dst (MulHiL src rax));
 8382   effect(USE_KILL rax, KILL cr);
 8383 
 8384   ins_cost(300);
 8385   format %{ &quot;imulq   RDX:RAX, RAX, $src\t# mulhi&quot; %}
 8386   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8387   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8388   ins_pipe(ialu_reg_reg_alu0);
 8389 %}
 8390 
 8391 instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8392                    rFlagsReg cr)
 8393 %{
 8394   match(Set rax (DivI rax div));
 8395   effect(KILL rdx, KILL cr);
 8396 
 8397   ins_cost(30*100+10*100); // XXX
 8398   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8399             &quot;jne,s   normal\n\t&quot;
 8400             &quot;xorl    rdx, rdx\n\t&quot;
 8401             &quot;cmpl    $div, -1\n\t&quot;
 8402             &quot;je,s    done\n&quot;
 8403     &quot;normal: cdql\n\t&quot;
 8404             &quot;idivl   $div\n&quot;
 8405     &quot;done:&quot;        %}
 8406   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8407   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8408   ins_pipe(ialu_reg_reg_alu0);
 8409 %}
 8410 
 8411 instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8412                    rFlagsReg cr)
 8413 %{
 8414   match(Set rax (DivL rax div));
 8415   effect(KILL rdx, KILL cr);
 8416 
 8417   ins_cost(30*100+10*100); // XXX
 8418   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8419             &quot;cmpq    rax, rdx\n\t&quot;
 8420             &quot;jne,s   normal\n\t&quot;
 8421             &quot;xorl    rdx, rdx\n\t&quot;
 8422             &quot;cmpq    $div, -1\n\t&quot;
 8423             &quot;je,s    done\n&quot;
 8424     &quot;normal: cdqq\n\t&quot;
 8425             &quot;idivq   $div\n&quot;
 8426     &quot;done:&quot;        %}
 8427   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8428   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8429   ins_pipe(ialu_reg_reg_alu0);
 8430 %}
 8431 
 8432 // Integer DIVMOD with Register, both quotient and mod results
 8433 instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8434                              rFlagsReg cr)
 8435 %{
 8436   match(DivModI rax div);
 8437   effect(KILL cr);
 8438 
 8439   ins_cost(30*100+10*100); // XXX
 8440   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8441             &quot;jne,s   normal\n\t&quot;
 8442             &quot;xorl    rdx, rdx\n\t&quot;
 8443             &quot;cmpl    $div, -1\n\t&quot;
 8444             &quot;je,s    done\n&quot;
 8445     &quot;normal: cdql\n\t&quot;
 8446             &quot;idivl   $div\n&quot;
 8447     &quot;done:&quot;        %}
 8448   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8449   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8450   ins_pipe(pipe_slow);
 8451 %}
 8452 
 8453 // Long DIVMOD with Register, both quotient and mod results
 8454 instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8455                              rFlagsReg cr)
 8456 %{
 8457   match(DivModL rax div);
 8458   effect(KILL cr);
 8459 
 8460   ins_cost(30*100+10*100); // XXX
 8461   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8462             &quot;cmpq    rax, rdx\n\t&quot;
 8463             &quot;jne,s   normal\n\t&quot;
 8464             &quot;xorl    rdx, rdx\n\t&quot;
 8465             &quot;cmpq    $div, -1\n\t&quot;
 8466             &quot;je,s    done\n&quot;
 8467     &quot;normal: cdqq\n\t&quot;
 8468             &quot;idivq   $div\n&quot;
 8469     &quot;done:&quot;        %}
 8470   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8471   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8472   ins_pipe(pipe_slow);
 8473 %}
 8474 
 8475 //----------- DivL-By-Constant-Expansions--------------------------------------
 8476 // DivI cases are handled by the compiler
 8477 
 8478 // Magic constant, reciprocal of 10
 8479 instruct loadConL_0x6666666666666667(rRegL dst)
 8480 %{
 8481   effect(DEF dst);
 8482 
 8483   format %{ &quot;movq    $dst, #0x666666666666667\t# Used in div-by-10&quot; %}
 8484   ins_encode(load_immL(dst, 0x6666666666666667));
 8485   ins_pipe(ialu_reg);
 8486 %}
 8487 
 8488 instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8489 %{
 8490   effect(DEF dst, USE src, USE_KILL rax, KILL cr);
 8491 
 8492   format %{ &quot;imulq   rdx:rax, rax, $src\t# Used in div-by-10&quot; %}
 8493   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8494   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8495   ins_pipe(ialu_reg_reg_alu0);
 8496 %}
 8497 
 8498 instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
 8499 %{
 8500   effect(USE_DEF dst, KILL cr);
 8501 
 8502   format %{ &quot;sarq    $dst, #63\t# Used in div-by-10&quot; %}
 8503   opcode(0xC1, 0x7); /* C1 /7 ib */
 8504   ins_encode(reg_opc_imm_wide(dst, 0x3F));
 8505   ins_pipe(ialu_reg);
 8506 %}
 8507 
 8508 instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
 8509 %{
 8510   effect(USE_DEF dst, KILL cr);
 8511 
 8512   format %{ &quot;sarq    $dst, #2\t# Used in div-by-10&quot; %}
 8513   opcode(0xC1, 0x7); /* C1 /7 ib */
 8514   ins_encode(reg_opc_imm_wide(dst, 0x2));
 8515   ins_pipe(ialu_reg);
 8516 %}
 8517 
 8518 instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
 8519 %{
 8520   match(Set dst (DivL src div));
 8521 
 8522   ins_cost((5+8)*100);
 8523   expand %{
 8524     rax_RegL rax;                     // Killed temp
 8525     rFlagsReg cr;                     // Killed
 8526     loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
 8527     mul_hi(dst, src, rax, cr);        // mulq  rdx:rax &lt;= rax * $src
 8528     sarL_rReg_63(src, cr);            // sarq  src, 63
 8529     sarL_rReg_2(dst, cr);             // sarq  rdx, 2
 8530     subL_rReg(dst, src, cr);          // subl  rdx, src
 8531   %}
 8532 %}
 8533 
 8534 //-----------------------------------------------------------------------------
 8535 
 8536 instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
 8537                    rFlagsReg cr)
 8538 %{
 8539   match(Set rdx (ModI rax div));
 8540   effect(KILL rax, KILL cr);
 8541 
 8542   ins_cost(300); // XXX
 8543   format %{ &quot;cmpl    rax, 0x80000000\t# irem\n\t&quot;
 8544             &quot;jne,s   normal\n\t&quot;
 8545             &quot;xorl    rdx, rdx\n\t&quot;
 8546             &quot;cmpl    $div, -1\n\t&quot;
 8547             &quot;je,s    done\n&quot;
 8548     &quot;normal: cdql\n\t&quot;
 8549             &quot;idivl   $div\n&quot;
 8550     &quot;done:&quot;        %}
 8551   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8552   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8553   ins_pipe(ialu_reg_reg_alu0);
 8554 %}
 8555 
 8556 instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
 8557                    rFlagsReg cr)
 8558 %{
 8559   match(Set rdx (ModL rax div));
 8560   effect(KILL rax, KILL cr);
 8561 
 8562   ins_cost(300); // XXX
 8563   format %{ &quot;movq    rdx, 0x8000000000000000\t# lrem\n\t&quot;
 8564             &quot;cmpq    rax, rdx\n\t&quot;
 8565             &quot;jne,s   normal\n\t&quot;
 8566             &quot;xorl    rdx, rdx\n\t&quot;
 8567             &quot;cmpq    $div, -1\n\t&quot;
 8568             &quot;je,s    done\n&quot;
 8569     &quot;normal: cdqq\n\t&quot;
 8570             &quot;idivq   $div\n&quot;
 8571     &quot;done:&quot;        %}
 8572   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8573   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8574   ins_pipe(ialu_reg_reg_alu0);
 8575 %}
 8576 
 8577 // Integer Shift Instructions
 8578 // Shift Left by one
 8579 instruct salI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8580 %{
 8581   match(Set dst (LShiftI dst shift));
 8582   effect(KILL cr);
 8583 
 8584   format %{ &quot;sall    $dst, $shift&quot; %}
 8585   opcode(0xD1, 0x4); /* D1 /4 */
 8586   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8587   ins_pipe(ialu_reg);
 8588 %}
 8589 
 8590 // Shift Left by one
 8591 instruct salI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8592 %{
 8593   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8594   effect(KILL cr);
 8595 
 8596   format %{ &quot;sall    $dst, $shift\t&quot; %}
 8597   opcode(0xD1, 0x4); /* D1 /4 */
 8598   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8599   ins_pipe(ialu_mem_imm);
 8600 %}
 8601 
 8602 // Shift Left by 8-bit immediate
 8603 instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8604 %{
 8605   match(Set dst (LShiftI dst shift));
 8606   effect(KILL cr);
 8607 
 8608   format %{ &quot;sall    $dst, $shift&quot; %}
 8609   opcode(0xC1, 0x4); /* C1 /4 ib */
 8610   ins_encode(reg_opc_imm(dst, shift));
 8611   ins_pipe(ialu_reg);
 8612 %}
 8613 
 8614 // Shift Left by 8-bit immediate
 8615 instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8616 %{
 8617   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8618   effect(KILL cr);
 8619 
 8620   format %{ &quot;sall    $dst, $shift&quot; %}
 8621   opcode(0xC1, 0x4); /* C1 /4 ib */
 8622   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8623   ins_pipe(ialu_mem_imm);
 8624 %}
 8625 
 8626 // Shift Left by variable
 8627 instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8628 %{
 8629   match(Set dst (LShiftI dst shift));
 8630   effect(KILL cr);
 8631 
 8632   format %{ &quot;sall    $dst, $shift&quot; %}
 8633   opcode(0xD3, 0x4); /* D3 /4 */
 8634   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8635   ins_pipe(ialu_reg_reg);
 8636 %}
 8637 
 8638 // Shift Left by variable
 8639 instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8640 %{
 8641   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8642   effect(KILL cr);
 8643 
 8644   format %{ &quot;sall    $dst, $shift&quot; %}
 8645   opcode(0xD3, 0x4); /* D3 /4 */
 8646   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8647   ins_pipe(ialu_mem_reg);
 8648 %}
 8649 
 8650 // Arithmetic shift right by one
 8651 instruct sarI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8652 %{
 8653   match(Set dst (RShiftI dst shift));
 8654   effect(KILL cr);
 8655 
 8656   format %{ &quot;sarl    $dst, $shift&quot; %}
 8657   opcode(0xD1, 0x7); /* D1 /7 */
 8658   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8659   ins_pipe(ialu_reg);
 8660 %}
 8661 
 8662 // Arithmetic shift right by one
 8663 instruct sarI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8664 %{
 8665   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8666   effect(KILL cr);
 8667 
 8668   format %{ &quot;sarl    $dst, $shift&quot; %}
 8669   opcode(0xD1, 0x7); /* D1 /7 */
 8670   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8671   ins_pipe(ialu_mem_imm);
 8672 %}
 8673 
 8674 // Arithmetic Shift Right by 8-bit immediate
 8675 instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8676 %{
 8677   match(Set dst (RShiftI dst shift));
 8678   effect(KILL cr);
 8679 
 8680   format %{ &quot;sarl    $dst, $shift&quot; %}
 8681   opcode(0xC1, 0x7); /* C1 /7 ib */
 8682   ins_encode(reg_opc_imm(dst, shift));
 8683   ins_pipe(ialu_mem_imm);
 8684 %}
 8685 
 8686 // Arithmetic Shift Right by 8-bit immediate
 8687 instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8688 %{
 8689   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8690   effect(KILL cr);
 8691 
 8692   format %{ &quot;sarl    $dst, $shift&quot; %}
 8693   opcode(0xC1, 0x7); /* C1 /7 ib */
 8694   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8695   ins_pipe(ialu_mem_imm);
 8696 %}
 8697 
 8698 // Arithmetic Shift Right by variable
 8699 instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8700 %{
 8701   match(Set dst (RShiftI dst shift));
 8702   effect(KILL cr);
 8703 
 8704   format %{ &quot;sarl    $dst, $shift&quot; %}
 8705   opcode(0xD3, 0x7); /* D3 /7 */
 8706   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8707   ins_pipe(ialu_reg_reg);
 8708 %}
 8709 
 8710 // Arithmetic Shift Right by variable
 8711 instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8712 %{
 8713   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8714   effect(KILL cr);
 8715 
 8716   format %{ &quot;sarl    $dst, $shift&quot; %}
 8717   opcode(0xD3, 0x7); /* D3 /7 */
 8718   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8719   ins_pipe(ialu_mem_reg);
 8720 %}
 8721 
 8722 // Logical shift right by one
 8723 instruct shrI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8724 %{
 8725   match(Set dst (URShiftI dst shift));
 8726   effect(KILL cr);
 8727 
 8728   format %{ &quot;shrl    $dst, $shift&quot; %}
 8729   opcode(0xD1, 0x5); /* D1 /5 */
 8730   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8731   ins_pipe(ialu_reg);
 8732 %}
 8733 
 8734 // Logical shift right by one
 8735 instruct shrI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8736 %{
 8737   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8738   effect(KILL cr);
 8739 
 8740   format %{ &quot;shrl    $dst, $shift&quot; %}
 8741   opcode(0xD1, 0x5); /* D1 /5 */
 8742   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8743   ins_pipe(ialu_mem_imm);
 8744 %}
 8745 
 8746 // Logical Shift Right by 8-bit immediate
 8747 instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8748 %{
 8749   match(Set dst (URShiftI dst shift));
 8750   effect(KILL cr);
 8751 
 8752   format %{ &quot;shrl    $dst, $shift&quot; %}
 8753   opcode(0xC1, 0x5); /* C1 /5 ib */
 8754   ins_encode(reg_opc_imm(dst, shift));
 8755   ins_pipe(ialu_reg);
 8756 %}
 8757 
 8758 // Logical Shift Right by 8-bit immediate
 8759 instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8760 %{
 8761   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8762   effect(KILL cr);
 8763 
 8764   format %{ &quot;shrl    $dst, $shift&quot; %}
 8765   opcode(0xC1, 0x5); /* C1 /5 ib */
 8766   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8767   ins_pipe(ialu_mem_imm);
 8768 %}
 8769 
 8770 // Logical Shift Right by variable
 8771 instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8772 %{
 8773   match(Set dst (URShiftI dst shift));
 8774   effect(KILL cr);
 8775 
 8776   format %{ &quot;shrl    $dst, $shift&quot; %}
 8777   opcode(0xD3, 0x5); /* D3 /5 */
 8778   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8779   ins_pipe(ialu_reg_reg);
 8780 %}
 8781 
 8782 // Logical Shift Right by variable
 8783 instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8784 %{
 8785   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8786   effect(KILL cr);
 8787 
 8788   format %{ &quot;shrl    $dst, $shift&quot; %}
 8789   opcode(0xD3, 0x5); /* D3 /5 */
 8790   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8791   ins_pipe(ialu_mem_reg);
 8792 %}
 8793 
 8794 // Long Shift Instructions
 8795 // Shift Left by one
 8796 instruct salL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8797 %{
 8798   match(Set dst (LShiftL dst shift));
 8799   effect(KILL cr);
 8800 
 8801   format %{ &quot;salq    $dst, $shift&quot; %}
 8802   opcode(0xD1, 0x4); /* D1 /4 */
 8803   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8804   ins_pipe(ialu_reg);
 8805 %}
 8806 
 8807 // Shift Left by one
 8808 instruct salL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8809 %{
 8810   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8811   effect(KILL cr);
 8812 
 8813   format %{ &quot;salq    $dst, $shift&quot; %}
 8814   opcode(0xD1, 0x4); /* D1 /4 */
 8815   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8816   ins_pipe(ialu_mem_imm);
 8817 %}
 8818 
 8819 // Shift Left by 8-bit immediate
 8820 instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8821 %{
 8822   match(Set dst (LShiftL dst shift));
 8823   effect(KILL cr);
 8824 
 8825   format %{ &quot;salq    $dst, $shift&quot; %}
 8826   opcode(0xC1, 0x4); /* C1 /4 ib */
 8827   ins_encode(reg_opc_imm_wide(dst, shift));
 8828   ins_pipe(ialu_reg);
 8829 %}
 8830 
 8831 // Shift Left by 8-bit immediate
 8832 instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8833 %{
 8834   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8835   effect(KILL cr);
 8836 
 8837   format %{ &quot;salq    $dst, $shift&quot; %}
 8838   opcode(0xC1, 0x4); /* C1 /4 ib */
 8839   ins_encode(REX_mem_wide(dst), OpcP,
 8840              RM_opc_mem(secondary, dst), Con8or32(shift));
 8841   ins_pipe(ialu_mem_imm);
 8842 %}
 8843 
 8844 // Shift Left by variable
 8845 instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8846 %{
 8847   match(Set dst (LShiftL dst shift));
 8848   effect(KILL cr);
 8849 
 8850   format %{ &quot;salq    $dst, $shift&quot; %}
 8851   opcode(0xD3, 0x4); /* D3 /4 */
 8852   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8853   ins_pipe(ialu_reg_reg);
 8854 %}
 8855 
 8856 // Shift Left by variable
 8857 instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8858 %{
 8859   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8860   effect(KILL cr);
 8861 
 8862   format %{ &quot;salq    $dst, $shift&quot; %}
 8863   opcode(0xD3, 0x4); /* D3 /4 */
 8864   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8865   ins_pipe(ialu_mem_reg);
 8866 %}
 8867 
 8868 // Arithmetic shift right by one
 8869 instruct sarL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8870 %{
 8871   match(Set dst (RShiftL dst shift));
 8872   effect(KILL cr);
 8873 
 8874   format %{ &quot;sarq    $dst, $shift&quot; %}
 8875   opcode(0xD1, 0x7); /* D1 /7 */
 8876   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8877   ins_pipe(ialu_reg);
 8878 %}
 8879 
 8880 // Arithmetic shift right by one
 8881 instruct sarL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8882 %{
 8883   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8884   effect(KILL cr);
 8885 
 8886   format %{ &quot;sarq    $dst, $shift&quot; %}
 8887   opcode(0xD1, 0x7); /* D1 /7 */
 8888   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8889   ins_pipe(ialu_mem_imm);
 8890 %}
 8891 
 8892 // Arithmetic Shift Right by 8-bit immediate
 8893 instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8894 %{
 8895   match(Set dst (RShiftL dst shift));
 8896   effect(KILL cr);
 8897 
 8898   format %{ &quot;sarq    $dst, $shift&quot; %}
 8899   opcode(0xC1, 0x7); /* C1 /7 ib */
 8900   ins_encode(reg_opc_imm_wide(dst, shift));
 8901   ins_pipe(ialu_mem_imm);
 8902 %}
 8903 
 8904 // Arithmetic Shift Right by 8-bit immediate
 8905 instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8906 %{
 8907   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8908   effect(KILL cr);
 8909 
 8910   format %{ &quot;sarq    $dst, $shift&quot; %}
 8911   opcode(0xC1, 0x7); /* C1 /7 ib */
 8912   ins_encode(REX_mem_wide(dst), OpcP,
 8913              RM_opc_mem(secondary, dst), Con8or32(shift));
 8914   ins_pipe(ialu_mem_imm);
 8915 %}
 8916 
 8917 // Arithmetic Shift Right by variable
 8918 instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8919 %{
 8920   match(Set dst (RShiftL dst shift));
 8921   effect(KILL cr);
 8922 
 8923   format %{ &quot;sarq    $dst, $shift&quot; %}
 8924   opcode(0xD3, 0x7); /* D3 /7 */
 8925   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8926   ins_pipe(ialu_reg_reg);
 8927 %}
 8928 
 8929 // Arithmetic Shift Right by variable
 8930 instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8931 %{
 8932   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8933   effect(KILL cr);
 8934 
 8935   format %{ &quot;sarq    $dst, $shift&quot; %}
 8936   opcode(0xD3, 0x7); /* D3 /7 */
 8937   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8938   ins_pipe(ialu_mem_reg);
 8939 %}
 8940 
 8941 // Logical shift right by one
 8942 instruct shrL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8943 %{
 8944   match(Set dst (URShiftL dst shift));
 8945   effect(KILL cr);
 8946 
 8947   format %{ &quot;shrq    $dst, $shift&quot; %}
 8948   opcode(0xD1, 0x5); /* D1 /5 */
 8949   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));
 8950   ins_pipe(ialu_reg);
 8951 %}
 8952 
 8953 // Logical shift right by one
 8954 instruct shrL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8955 %{
 8956   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8957   effect(KILL cr);
 8958 
 8959   format %{ &quot;shrq    $dst, $shift&quot; %}
 8960   opcode(0xD1, 0x5); /* D1 /5 */
 8961   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8962   ins_pipe(ialu_mem_imm);
 8963 %}
 8964 
 8965 // Logical Shift Right by 8-bit immediate
 8966 instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8967 %{
 8968   match(Set dst (URShiftL dst shift));
 8969   effect(KILL cr);
 8970 
 8971   format %{ &quot;shrq    $dst, $shift&quot; %}
 8972   opcode(0xC1, 0x5); /* C1 /5 ib */
 8973   ins_encode(reg_opc_imm_wide(dst, shift));
 8974   ins_pipe(ialu_reg);
 8975 %}
 8976 
 8977 
 8978 // Logical Shift Right by 8-bit immediate
 8979 instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8980 %{
 8981   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8982   effect(KILL cr);
 8983 
 8984   format %{ &quot;shrq    $dst, $shift&quot; %}
 8985   opcode(0xC1, 0x5); /* C1 /5 ib */
 8986   ins_encode(REX_mem_wide(dst), OpcP,
 8987              RM_opc_mem(secondary, dst), Con8or32(shift));
 8988   ins_pipe(ialu_mem_imm);
 8989 %}
 8990 
 8991 // Logical Shift Right by variable
 8992 instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8993 %{
 8994   match(Set dst (URShiftL dst shift));
 8995   effect(KILL cr);
 8996 
 8997   format %{ &quot;shrq    $dst, $shift&quot; %}
 8998   opcode(0xD3, 0x5); /* D3 /5 */
 8999   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9000   ins_pipe(ialu_reg_reg);
 9001 %}
 9002 
 9003 // Logical Shift Right by variable
 9004 instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 9005 %{
 9006   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 9007   effect(KILL cr);
 9008 
 9009   format %{ &quot;shrq    $dst, $shift&quot; %}
 9010   opcode(0xD3, 0x5); /* D3 /5 */
 9011   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 9012   ins_pipe(ialu_mem_reg);
 9013 %}
 9014 
 9015 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
 9016 // This idiom is used by the compiler for the i2b bytecode.
 9017 instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)
 9018 %{
 9019   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
 9020 
 9021   format %{ &quot;movsbl  $dst, $src\t# i2b&quot; %}
 9022   opcode(0x0F, 0xBE);
 9023   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9024   ins_pipe(ialu_reg_reg);
 9025 %}
 9026 
 9027 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
 9028 // This idiom is used by the compiler the i2s bytecode.
 9029 instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)
 9030 %{
 9031   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
 9032 
 9033   format %{ &quot;movswl  $dst, $src\t# i2s&quot; %}
 9034   opcode(0x0F, 0xBF);
 9035   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9036   ins_pipe(ialu_reg_reg);
 9037 %}
 9038 
 9039 // ROL/ROR instructions
 9040 
 9041 // ROL expand
 9042 instruct rolI_rReg_imm1(rRegI dst, rFlagsReg cr) %{
 9043   effect(KILL cr, USE_DEF dst);
 9044 
 9045   format %{ &quot;roll    $dst&quot; %}
 9046   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9047   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9048   ins_pipe(ialu_reg);
 9049 %}
 9050 
 9051 instruct rolI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr) %{
 9052   effect(USE_DEF dst, USE shift, KILL cr);
 9053 
 9054   format %{ &quot;roll    $dst, $shift&quot; %}
 9055   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9056   ins_encode( reg_opc_imm(dst, shift) );
 9057   ins_pipe(ialu_reg);
 9058 %}
 9059 
 9060 instruct rolI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9061 %{
 9062   effect(USE_DEF dst, USE shift, KILL cr);
 9063 
 9064   format %{ &quot;roll    $dst, $shift&quot; %}
 9065   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9066   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9067   ins_pipe(ialu_reg_reg);
 9068 %}
 9069 // end of ROL expand
 9070 
 9071 // Rotate Left by one
 9072 instruct rolI_rReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9073 %{
 9074   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9075 
 9076   expand %{
 9077     rolI_rReg_imm1(dst, cr);
 9078   %}
 9079 %}
 9080 
 9081 // Rotate Left by 8-bit immediate
 9082 instruct rolI_rReg_i8(rRegI dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9083 %{
 9084   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9085   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9086 
 9087   expand %{
 9088     rolI_rReg_imm8(dst, lshift, cr);
 9089   %}
 9090 %}
 9091 
 9092 // Rotate Left by variable
 9093 instruct rolI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9094 %{
 9095   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
 9096 
 9097   expand %{
 9098     rolI_rReg_CL(dst, shift, cr);
 9099   %}
 9100 %}
 9101 
 9102 // Rotate Left by variable
 9103 instruct rolI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9104 %{
 9105   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
 9106 
 9107   expand %{
 9108     rolI_rReg_CL(dst, shift, cr);
 9109   %}
 9110 %}
 9111 
 9112 // ROR expand
 9113 instruct rorI_rReg_imm1(rRegI dst, rFlagsReg cr)
 9114 %{
 9115   effect(USE_DEF dst, KILL cr);
 9116 
 9117   format %{ &quot;rorl    $dst&quot; %}
 9118   opcode(0xD1, 0x1); /* D1 /1 */
 9119   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9120   ins_pipe(ialu_reg);
 9121 %}
 9122 
 9123 instruct rorI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr)
 9124 %{
 9125   effect(USE_DEF dst, USE shift, KILL cr);
 9126 
 9127   format %{ &quot;rorl    $dst, $shift&quot; %}
 9128   opcode(0xC1, 0x1); /* C1 /1 ib */
 9129   ins_encode(reg_opc_imm(dst, shift));
 9130   ins_pipe(ialu_reg);
 9131 %}
 9132 
 9133 instruct rorI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9134 %{
 9135   effect(USE_DEF dst, USE shift, KILL cr);
 9136 
 9137   format %{ &quot;rorl    $dst, $shift&quot; %}
 9138   opcode(0xD3, 0x1); /* D3 /1 */
 9139   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9140   ins_pipe(ialu_reg_reg);
 9141 %}
 9142 // end of ROR expand
 9143 
 9144 // Rotate Right by one
 9145 instruct rorI_rReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9146 %{
 9147   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9148 
 9149   expand %{
 9150     rorI_rReg_imm1(dst, cr);
 9151   %}
 9152 %}
 9153 
 9154 // Rotate Right by 8-bit immediate
 9155 instruct rorI_rReg_i8(rRegI dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9156 %{
 9157   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9158   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9159 
 9160   expand %{
 9161     rorI_rReg_imm8(dst, rshift, cr);
 9162   %}
 9163 %}
 9164 
 9165 // Rotate Right by variable
 9166 instruct rorI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9167 %{
 9168   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
 9169 
 9170   expand %{
 9171     rorI_rReg_CL(dst, shift, cr);
 9172   %}
 9173 %}
 9174 
 9175 // Rotate Right by variable
 9176 instruct rorI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9177 %{
 9178   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
 9179 
 9180   expand %{
 9181     rorI_rReg_CL(dst, shift, cr);
 9182   %}
 9183 %}
 9184 
 9185 // for long rotate
 9186 // ROL expand
 9187 instruct rolL_rReg_imm1(rRegL dst, rFlagsReg cr) %{
 9188   effect(USE_DEF dst, KILL cr);
 9189 
 9190   format %{ &quot;rolq    $dst&quot; %}
 9191   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9192   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9193   ins_pipe(ialu_reg);
 9194 %}
 9195 
 9196 instruct rolL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr) %{
 9197   effect(USE_DEF dst, USE shift, KILL cr);
 9198 
 9199   format %{ &quot;rolq    $dst, $shift&quot; %}
 9200   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9201   ins_encode( reg_opc_imm_wide(dst, shift) );
 9202   ins_pipe(ialu_reg);
 9203 %}
 9204 
 9205 instruct rolL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9206 %{
 9207   effect(USE_DEF dst, USE shift, KILL cr);
 9208 
 9209   format %{ &quot;rolq    $dst, $shift&quot; %}
 9210   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9211   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9212   ins_pipe(ialu_reg_reg);
 9213 %}
 9214 // end of ROL expand
 9215 
 9216 // Rotate Left by one
 9217 instruct rolL_rReg_i1(rRegL dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9218 %{
 9219   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9220 
 9221   expand %{
 9222     rolL_rReg_imm1(dst, cr);
 9223   %}
 9224 %}
 9225 
 9226 // Rotate Left by 8-bit immediate
 9227 instruct rolL_rReg_i8(rRegL dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9228 %{
 9229   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9230   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9231 
 9232   expand %{
 9233     rolL_rReg_imm8(dst, lshift, cr);
 9234   %}
 9235 %}
 9236 
 9237 // Rotate Left by variable
 9238 instruct rolL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9239 %{
 9240   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI zero shift))));
 9241 
 9242   expand %{
 9243     rolL_rReg_CL(dst, shift, cr);
 9244   %}
 9245 %}
 9246 
 9247 // Rotate Left by variable
 9248 instruct rolL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9249 %{
 9250   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI c64 shift))));
 9251 
 9252   expand %{
 9253     rolL_rReg_CL(dst, shift, cr);
 9254   %}
 9255 %}
 9256 
 9257 // ROR expand
 9258 instruct rorL_rReg_imm1(rRegL dst, rFlagsReg cr)
 9259 %{
 9260   effect(USE_DEF dst, KILL cr);
 9261 
 9262   format %{ &quot;rorq    $dst&quot; %}
 9263   opcode(0xD1, 0x1); /* D1 /1 */
 9264   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9265   ins_pipe(ialu_reg);
 9266 %}
 9267 
 9268 instruct rorL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr)
 9269 %{
 9270   effect(USE_DEF dst, USE shift, KILL cr);
 9271 
 9272   format %{ &quot;rorq    $dst, $shift&quot; %}
 9273   opcode(0xC1, 0x1); /* C1 /1 ib */
 9274   ins_encode(reg_opc_imm_wide(dst, shift));
 9275   ins_pipe(ialu_reg);
 9276 %}
 9277 
 9278 instruct rorL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9279 %{
 9280   effect(USE_DEF dst, USE shift, KILL cr);
 9281 
 9282   format %{ &quot;rorq    $dst, $shift&quot; %}
 9283   opcode(0xD3, 0x1); /* D3 /1 */
 9284   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9285   ins_pipe(ialu_reg_reg);
 9286 %}
 9287 // end of ROR expand
 9288 
 9289 // Rotate Right by one
 9290 instruct rorL_rReg_i1(rRegL dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9291 %{
 9292   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9293 
 9294   expand %{
 9295     rorL_rReg_imm1(dst, cr);
 9296   %}
 9297 %}
 9298 
 9299 // Rotate Right by 8-bit immediate
 9300 instruct rorL_rReg_i8(rRegL dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9301 %{
 9302   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9303   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9304 
 9305   expand %{
 9306     rorL_rReg_imm8(dst, rshift, cr);
 9307   %}
 9308 %}
 9309 
 9310 // Rotate Right by variable
 9311 instruct rorL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9312 %{
 9313   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI zero shift))));
 9314 
 9315   expand %{
 9316     rorL_rReg_CL(dst, shift, cr);
 9317   %}
 9318 %}
 9319 
 9320 // Rotate Right by variable
 9321 instruct rorL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9322 %{
 9323   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI c64 shift))));
 9324 
 9325   expand %{
 9326     rorL_rReg_CL(dst, shift, cr);
 9327   %}
 9328 %}
 9329 
 9330 // Logical Instructions
 9331 
 9332 // Integer Logical Instructions
 9333 
 9334 // And Instructions
 9335 // And Register with Register
 9336 instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9337 %{
 9338   match(Set dst (AndI dst src));
 9339   effect(KILL cr);
 9340 
 9341   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9342   opcode(0x23);
 9343   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9344   ins_pipe(ialu_reg_reg);
 9345 %}
 9346 
 9347 // And Register with Immediate 255
 9348 instruct andI_rReg_imm255(rRegI dst, immI_255 src)
 9349 %{
 9350   match(Set dst (AndI dst src));
 9351 
 9352   format %{ &quot;movzbl  $dst, $dst\t# int &amp; 0xFF&quot; %}
 9353   opcode(0x0F, 0xB6);
 9354   ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9355   ins_pipe(ialu_reg);
 9356 %}
 9357 
 9358 // And Register with Immediate 255 and promote to long
 9359 instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)
 9360 %{
 9361   match(Set dst (ConvI2L (AndI src mask)));
 9362 
 9363   format %{ &quot;movzbl  $dst, $src\t# int &amp; 0xFF -&gt; long&quot; %}
 9364   opcode(0x0F, 0xB6);
 9365   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9366   ins_pipe(ialu_reg);
 9367 %}
 9368 
 9369 // And Register with Immediate 65535
 9370 instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)
 9371 %{
 9372   match(Set dst (AndI dst src));
 9373 
 9374   format %{ &quot;movzwl  $dst, $dst\t# int &amp; 0xFFFF&quot; %}
 9375   opcode(0x0F, 0xB7);
 9376   ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9377   ins_pipe(ialu_reg);
 9378 %}
 9379 
 9380 // And Register with Immediate 65535 and promote to long
 9381 instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)
 9382 %{
 9383   match(Set dst (ConvI2L (AndI src mask)));
 9384 
 9385   format %{ &quot;movzwl  $dst, $src\t# int &amp; 0xFFFF -&gt; long&quot; %}
 9386   opcode(0x0F, 0xB7);
 9387   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9388   ins_pipe(ialu_reg);
 9389 %}
 9390 
 9391 // And Register with Immediate
 9392 instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9393 %{
 9394   match(Set dst (AndI dst src));
 9395   effect(KILL cr);
 9396 
 9397   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9398   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9399   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9400   ins_pipe(ialu_reg);
 9401 %}
 9402 
 9403 // And Register with Memory
 9404 instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9405 %{
 9406   match(Set dst (AndI dst (LoadI src)));
 9407   effect(KILL cr);
 9408 
 9409   ins_cost(125);
 9410   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9411   opcode(0x23);
 9412   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9413   ins_pipe(ialu_reg_mem);
 9414 %}
 9415 
 9416 // And Memory with Register
 9417 instruct andB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9418 %{
 9419   match(Set dst (StoreB dst (AndI (LoadB dst) src)));
 9420   effect(KILL cr);
 9421 
 9422   ins_cost(150);
 9423   format %{ &quot;andb    $dst, $src\t# byte&quot; %}
 9424   opcode(0x20);
 9425   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9426   ins_pipe(ialu_mem_reg);
 9427 %}
 9428 
 9429 instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9430 %{
 9431   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9432   effect(KILL cr);
 9433 
 9434   ins_cost(150);
 9435   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9436   opcode(0x21); /* Opcode 21 /r */
 9437   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9438   ins_pipe(ialu_mem_reg);
 9439 %}
 9440 
 9441 // And Memory with Immediate
 9442 instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9443 %{
 9444   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9445   effect(KILL cr);
 9446 
 9447   ins_cost(125);
 9448   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9449   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9450   ins_encode(REX_mem(dst), OpcSE(src),
 9451              RM_opc_mem(secondary, dst), Con8or32(src));
 9452   ins_pipe(ialu_mem_imm);
 9453 %}
 9454 
 9455 // BMI1 instructions
 9456 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{
 9457   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));
 9458   predicate(UseBMI1Instructions);
 9459   effect(KILL cr);
 9460 
 9461   ins_cost(125);
 9462   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9463 
 9464   ins_encode %{
 9465     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
 9466   %}
 9467   ins_pipe(ialu_reg_mem);
 9468 %}
 9469 
 9470 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{
 9471   match(Set dst (AndI (XorI src1 minus_1) src2));
 9472   predicate(UseBMI1Instructions);
 9473   effect(KILL cr);
 9474 
 9475   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9476 
 9477   ins_encode %{
 9478     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
 9479   %}
 9480   ins_pipe(ialu_reg);
 9481 %}
 9482 
 9483 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, rFlagsReg cr) %{
 9484   match(Set dst (AndI (SubI imm_zero src) src));
 9485   predicate(UseBMI1Instructions);
 9486   effect(KILL cr);
 9487 
 9488   format %{ &quot;blsil  $dst, $src&quot; %}
 9489 
 9490   ins_encode %{
 9491     __ blsil($dst$$Register, $src$$Register);
 9492   %}
 9493   ins_pipe(ialu_reg);
 9494 %}
 9495 
 9496 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, rFlagsReg cr) %{
 9497   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
 9498   predicate(UseBMI1Instructions);
 9499   effect(KILL cr);
 9500 
 9501   ins_cost(125);
 9502   format %{ &quot;blsil  $dst, $src&quot; %}
 9503 
 9504   ins_encode %{
 9505     __ blsil($dst$$Register, $src$$Address);
 9506   %}
 9507   ins_pipe(ialu_reg_mem);
 9508 %}
 9509 
 9510 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9511 %{
 9512   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9513   predicate(UseBMI1Instructions);
 9514   effect(KILL cr);
 9515 
 9516   ins_cost(125);
 9517   format %{ &quot;blsmskl $dst, $src&quot; %}
 9518 
 9519   ins_encode %{
 9520     __ blsmskl($dst$$Register, $src$$Address);
 9521   %}
 9522   ins_pipe(ialu_reg_mem);
 9523 %}
 9524 
 9525 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9526 %{
 9527   match(Set dst (XorI (AddI src minus_1) src));
 9528   predicate(UseBMI1Instructions);
 9529   effect(KILL cr);
 9530 
 9531   format %{ &quot;blsmskl $dst, $src&quot; %}
 9532 
 9533   ins_encode %{
 9534     __ blsmskl($dst$$Register, $src$$Register);
 9535   %}
 9536 
 9537   ins_pipe(ialu_reg);
 9538 %}
 9539 
 9540 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9541 %{
 9542   match(Set dst (AndI (AddI src minus_1) src) );
 9543   predicate(UseBMI1Instructions);
 9544   effect(KILL cr);
 9545 
 9546   format %{ &quot;blsrl  $dst, $src&quot; %}
 9547 
 9548   ins_encode %{
 9549     __ blsrl($dst$$Register, $src$$Register);
 9550   %}
 9551 
 9552   ins_pipe(ialu_reg_mem);
 9553 %}
 9554 
 9555 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9556 %{
 9557   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9558   predicate(UseBMI1Instructions);
 9559   effect(KILL cr);
 9560 
 9561   ins_cost(125);
 9562   format %{ &quot;blsrl  $dst, $src&quot; %}
 9563 
 9564   ins_encode %{
 9565     __ blsrl($dst$$Register, $src$$Address);
 9566   %}
 9567 
 9568   ins_pipe(ialu_reg);
 9569 %}
 9570 
 9571 // Or Instructions
 9572 // Or Register with Register
 9573 instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9574 %{
 9575   match(Set dst (OrI dst src));
 9576   effect(KILL cr);
 9577 
 9578   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9579   opcode(0x0B);
 9580   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9581   ins_pipe(ialu_reg_reg);
 9582 %}
 9583 
 9584 // Or Register with Immediate
 9585 instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9586 %{
 9587   match(Set dst (OrI dst src));
 9588   effect(KILL cr);
 9589 
 9590   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9591   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9592   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9593   ins_pipe(ialu_reg);
 9594 %}
 9595 
 9596 // Or Register with Memory
 9597 instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9598 %{
 9599   match(Set dst (OrI dst (LoadI src)));
 9600   effect(KILL cr);
 9601 
 9602   ins_cost(125);
 9603   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9604   opcode(0x0B);
 9605   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9606   ins_pipe(ialu_reg_mem);
 9607 %}
 9608 
 9609 // Or Memory with Register
 9610 instruct orB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9611 %{
 9612   match(Set dst (StoreB dst (OrI (LoadB dst) src)));
 9613   effect(KILL cr);
 9614 
 9615   ins_cost(150);
 9616   format %{ &quot;orb    $dst, $src\t# byte&quot; %}
 9617   opcode(0x08);
 9618   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9619   ins_pipe(ialu_mem_reg);
 9620 %}
 9621 
 9622 instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9623 %{
 9624   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9625   effect(KILL cr);
 9626 
 9627   ins_cost(150);
 9628   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9629   opcode(0x09); /* Opcode 09 /r */
 9630   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9631   ins_pipe(ialu_mem_reg);
 9632 %}
 9633 
 9634 // Or Memory with Immediate
 9635 instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9636 %{
 9637   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9638   effect(KILL cr);
 9639 
 9640   ins_cost(125);
 9641   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9642   opcode(0x81, 0x1); /* Opcode 81 /1 id */
 9643   ins_encode(REX_mem(dst), OpcSE(src),
 9644              RM_opc_mem(secondary, dst), Con8or32(src));
 9645   ins_pipe(ialu_mem_imm);
 9646 %}
 9647 
 9648 // Xor Instructions
 9649 // Xor Register with Register
 9650 instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9651 %{
 9652   match(Set dst (XorI dst src));
 9653   effect(KILL cr);
 9654 
 9655   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9656   opcode(0x33);
 9657   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9658   ins_pipe(ialu_reg_reg);
 9659 %}
 9660 
 9661 // Xor Register with Immediate -1
 9662 instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{
 9663   match(Set dst (XorI dst imm));
 9664 
 9665   format %{ &quot;not    $dst&quot; %}
 9666   ins_encode %{
 9667      __ notl($dst$$Register);
 9668   %}
 9669   ins_pipe(ialu_reg);
 9670 %}
 9671 
 9672 // Xor Register with Immediate
 9673 instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9674 %{
 9675   match(Set dst (XorI dst src));
 9676   effect(KILL cr);
 9677 
 9678   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9679   opcode(0x81, 0x06); /* Opcode 81 /6 id */
 9680   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9681   ins_pipe(ialu_reg);
 9682 %}
 9683 
 9684 // Xor Register with Memory
 9685 instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9686 %{
 9687   match(Set dst (XorI dst (LoadI src)));
 9688   effect(KILL cr);
 9689 
 9690   ins_cost(125);
 9691   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9692   opcode(0x33);
 9693   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9694   ins_pipe(ialu_reg_mem);
 9695 %}
 9696 
 9697 // Xor Memory with Register
 9698 instruct xorB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9699 %{
 9700   match(Set dst (StoreB dst (XorI (LoadB dst) src)));
 9701   effect(KILL cr);
 9702 
 9703   ins_cost(150);
 9704   format %{ &quot;xorb    $dst, $src\t# byte&quot; %}
 9705   opcode(0x30);
 9706   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9707   ins_pipe(ialu_mem_reg);
 9708 %}
 9709 
 9710 instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9711 %{
 9712   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9713   effect(KILL cr);
 9714 
 9715   ins_cost(150);
 9716   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9717   opcode(0x31); /* Opcode 31 /r */
 9718   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9719   ins_pipe(ialu_mem_reg);
 9720 %}
 9721 
 9722 // Xor Memory with Immediate
 9723 instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9724 %{
 9725   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9726   effect(KILL cr);
 9727 
 9728   ins_cost(125);
 9729   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9730   opcode(0x81, 0x6); /* Opcode 81 /6 id */
 9731   ins_encode(REX_mem(dst), OpcSE(src),
 9732              RM_opc_mem(secondary, dst), Con8or32(src));
 9733   ins_pipe(ialu_mem_imm);
 9734 %}
 9735 
 9736 
 9737 // Long Logical Instructions
 9738 
 9739 // And Instructions
 9740 // And Register with Register
 9741 instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9742 %{
 9743   match(Set dst (AndL dst src));
 9744   effect(KILL cr);
 9745 
 9746   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9747   opcode(0x23);
 9748   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9749   ins_pipe(ialu_reg_reg);
 9750 %}
 9751 
 9752 // And Register with Immediate 255
 9753 instruct andL_rReg_imm255(rRegL dst, immL_255 src)
 9754 %{
 9755   match(Set dst (AndL dst src));
 9756 
 9757   format %{ &quot;movzbq  $dst, $dst\t# long &amp; 0xFF&quot; %}
 9758   opcode(0x0F, 0xB6);
 9759   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9760   ins_pipe(ialu_reg);
 9761 %}
 9762 
 9763 // And Register with Immediate 65535
 9764 instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)
 9765 %{
 9766   match(Set dst (AndL dst src));
 9767 
 9768   format %{ &quot;movzwq  $dst, $dst\t# long &amp; 0xFFFF&quot; %}
 9769   opcode(0x0F, 0xB7);
 9770   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9771   ins_pipe(ialu_reg);
 9772 %}
 9773 
 9774 // And Register with Immediate
 9775 instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9776 %{
 9777   match(Set dst (AndL dst src));
 9778   effect(KILL cr);
 9779 
 9780   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9781   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9782   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9783   ins_pipe(ialu_reg);
 9784 %}
 9785 
 9786 // And Register with Memory
 9787 instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9788 %{
 9789   match(Set dst (AndL dst (LoadL src)));
 9790   effect(KILL cr);
 9791 
 9792   ins_cost(125);
 9793   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9794   opcode(0x23);
 9795   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9796   ins_pipe(ialu_reg_mem);
 9797 %}
 9798 
 9799 // And Memory with Register
 9800 instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9801 %{
 9802   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9803   effect(KILL cr);
 9804 
 9805   ins_cost(150);
 9806   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9807   opcode(0x21); /* Opcode 21 /r */
 9808   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9809   ins_pipe(ialu_mem_reg);
 9810 %}
 9811 
 9812 // And Memory with Immediate
 9813 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9814 %{
 9815   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9816   effect(KILL cr);
 9817 
 9818   ins_cost(125);
 9819   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9820   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9821   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9822              RM_opc_mem(secondary, dst), Con8or32(src));
 9823   ins_pipe(ialu_mem_imm);
 9824 %}
 9825 
 9826 instruct btrL_mem_imm(memory dst, immL_NotPow2 con, rFlagsReg cr)
 9827 %{
 9828   // con should be a pure 64-bit immediate given that not(con) is a power of 2
 9829   // because AND/OR works well enough for 8/32-bit values.
 9830   predicate(log2_long(~n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 30);
 9831 
 9832   match(Set dst (StoreL dst (AndL (LoadL dst) con)));
 9833   effect(KILL cr);
 9834 
 9835   ins_cost(125);
 9836   format %{ &quot;btrq    $dst, log2(not($con))\t# long&quot; %}
 9837   ins_encode %{
 9838     __ btrq($dst$$Address, log2_long(~$con$$constant));
 9839   %}
 9840   ins_pipe(ialu_mem_imm);
 9841 %}
 9842 
 9843 // BMI1 instructions
 9844 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
 9845   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
 9846   predicate(UseBMI1Instructions);
 9847   effect(KILL cr);
 9848 
 9849   ins_cost(125);
 9850   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9851 
 9852   ins_encode %{
 9853     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
 9854   %}
 9855   ins_pipe(ialu_reg_mem);
 9856 %}
 9857 
 9858 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
 9859   match(Set dst (AndL (XorL src1 minus_1) src2));
 9860   predicate(UseBMI1Instructions);
 9861   effect(KILL cr);
 9862 
 9863   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9864 
 9865   ins_encode %{
 9866   __ andnq($dst$$Register, $src1$$Register, $src2$$Register);
 9867   %}
 9868   ins_pipe(ialu_reg_mem);
 9869 %}
 9870 
 9871 instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{
 9872   match(Set dst (AndL (SubL imm_zero src) src));
 9873   predicate(UseBMI1Instructions);
 9874   effect(KILL cr);
 9875 
 9876   format %{ &quot;blsiq  $dst, $src&quot; %}
 9877 
 9878   ins_encode %{
 9879     __ blsiq($dst$$Register, $src$$Register);
 9880   %}
 9881   ins_pipe(ialu_reg);
 9882 %}
 9883 
 9884 instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{
 9885   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
 9886   predicate(UseBMI1Instructions);
 9887   effect(KILL cr);
 9888 
 9889   ins_cost(125);
 9890   format %{ &quot;blsiq  $dst, $src&quot; %}
 9891 
 9892   ins_encode %{
 9893     __ blsiq($dst$$Register, $src$$Address);
 9894   %}
 9895   ins_pipe(ialu_reg_mem);
 9896 %}
 9897 
 9898 instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9899 %{
 9900   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );
 9901   predicate(UseBMI1Instructions);
 9902   effect(KILL cr);
 9903 
 9904   ins_cost(125);
 9905   format %{ &quot;blsmskq $dst, $src&quot; %}
 9906 
 9907   ins_encode %{
 9908     __ blsmskq($dst$$Register, $src$$Address);
 9909   %}
 9910   ins_pipe(ialu_reg_mem);
 9911 %}
 9912 
 9913 instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9914 %{
 9915   match(Set dst (XorL (AddL src minus_1) src));
 9916   predicate(UseBMI1Instructions);
 9917   effect(KILL cr);
 9918 
 9919   format %{ &quot;blsmskq $dst, $src&quot; %}
 9920 
 9921   ins_encode %{
 9922     __ blsmskq($dst$$Register, $src$$Register);
 9923   %}
 9924 
 9925   ins_pipe(ialu_reg);
 9926 %}
 9927 
 9928 instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9929 %{
 9930   match(Set dst (AndL (AddL src minus_1) src) );
 9931   predicate(UseBMI1Instructions);
 9932   effect(KILL cr);
 9933 
 9934   format %{ &quot;blsrq  $dst, $src&quot; %}
 9935 
 9936   ins_encode %{
 9937     __ blsrq($dst$$Register, $src$$Register);
 9938   %}
 9939 
 9940   ins_pipe(ialu_reg);
 9941 %}
 9942 
 9943 instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9944 %{
 9945   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );
 9946   predicate(UseBMI1Instructions);
 9947   effect(KILL cr);
 9948 
 9949   ins_cost(125);
 9950   format %{ &quot;blsrq  $dst, $src&quot; %}
 9951 
 9952   ins_encode %{
 9953     __ blsrq($dst$$Register, $src$$Address);
 9954   %}
 9955 
 9956   ins_pipe(ialu_reg);
 9957 %}
 9958 
 9959 // Or Instructions
 9960 // Or Register with Register
 9961 instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9962 %{
 9963   match(Set dst (OrL dst src));
 9964   effect(KILL cr);
 9965 
 9966   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9967   opcode(0x0B);
 9968   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9969   ins_pipe(ialu_reg_reg);
 9970 %}
 9971 
 9972 // Use any_RegP to match R15 (TLS register) without spilling.
 9973 instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{
 9974   match(Set dst (OrL dst (CastP2X src)));
 9975   effect(KILL cr);
 9976 
 9977   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9978   opcode(0x0B);
 9979   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9980   ins_pipe(ialu_reg_reg);
 9981 %}
 9982 
 9983 
 9984 // Or Register with Immediate
 9985 instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9986 %{
 9987   match(Set dst (OrL dst src));
 9988   effect(KILL cr);
 9989 
 9990   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9991   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9992   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9993   ins_pipe(ialu_reg);
 9994 %}
 9995 
 9996 // Or Register with Memory
 9997 instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9998 %{
 9999   match(Set dst (OrL dst (LoadL src)));
10000   effect(KILL cr);
10001 
10002   ins_cost(125);
10003   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10004   opcode(0x0B);
10005   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
10006   ins_pipe(ialu_reg_mem);
10007 %}
10008 
10009 // Or Memory with Register
10010 instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
10011 %{
10012   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
10013   effect(KILL cr);
10014 
10015   ins_cost(150);
10016   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10017   opcode(0x09); /* Opcode 09 /r */
10018   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10019   ins_pipe(ialu_mem_reg);
10020 %}
10021 
10022 // Or Memory with Immediate
10023 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10024 %{
10025   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
10026   effect(KILL cr);
10027 
10028   ins_cost(125);
10029   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10030   opcode(0x81, 0x1); /* Opcode 81 /1 id */
10031   ins_encode(REX_mem_wide(dst), OpcSE(src),
10032              RM_opc_mem(secondary, dst), Con8or32(src));
10033   ins_pipe(ialu_mem_imm);
10034 %}
10035 
10036 instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)
10037 %{
10038   // con should be a pure 64-bit power of 2 immediate
10039   // because AND/OR works well enough for 8/32-bit values.
10040   predicate(log2_long(n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 31);
10041 
10042   match(Set dst (StoreL dst (OrL (LoadL dst) con)));
10043   effect(KILL cr);
10044 
10045   ins_cost(125);
10046   format %{ &quot;btsq    $dst, log2($con)\t# long&quot; %}
10047   ins_encode %{
10048     __ btsq($dst$$Address, log2_long((julong)$con$$constant));
10049   %}
10050   ins_pipe(ialu_mem_imm);
10051 %}
10052 
10053 // Xor Instructions
10054 // Xor Register with Register
10055 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
10056 %{
10057   match(Set dst (XorL dst src));
10058   effect(KILL cr);
10059 
10060   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10061   opcode(0x33);
10062   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10063   ins_pipe(ialu_reg_reg);
10064 %}
10065 
10066 // Xor Register with Immediate -1
10067 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
10068   match(Set dst (XorL dst imm));
10069 
10070   format %{ &quot;notq   $dst&quot; %}
10071   ins_encode %{
10072      __ notq($dst$$Register);
10073   %}
10074   ins_pipe(ialu_reg);
10075 %}
10076 
10077 // Xor Register with Immediate
10078 instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
10079 %{
10080   match(Set dst (XorL dst src));
10081   effect(KILL cr);
10082 
10083   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10084   opcode(0x81, 0x06); /* Opcode 81 /6 id */
10085   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
10086   ins_pipe(ialu_reg);
10087 %}
10088 
10089 // Xor Register with Memory
10090 instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
10091 %{
10092   match(Set dst (XorL dst (LoadL src)));
10093   effect(KILL cr);
10094 
10095   ins_cost(125);
10096   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10097   opcode(0x33);
10098   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
10099   ins_pipe(ialu_reg_mem);
10100 %}
10101 
10102 // Xor Memory with Register
10103 instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
10104 %{
10105   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10106   effect(KILL cr);
10107 
10108   ins_cost(150);
10109   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10110   opcode(0x31); /* Opcode 31 /r */
10111   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10112   ins_pipe(ialu_mem_reg);
10113 %}
10114 
10115 // Xor Memory with Immediate
10116 instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10117 %{
10118   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10119   effect(KILL cr);
10120 
10121   ins_cost(125);
10122   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10123   opcode(0x81, 0x6); /* Opcode 81 /6 id */
10124   ins_encode(REX_mem_wide(dst), OpcSE(src),
10125              RM_opc_mem(secondary, dst), Con8or32(src));
10126   ins_pipe(ialu_mem_imm);
10127 %}
10128 
10129 // Convert Int to Boolean
10130 instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)
10131 %{
10132   match(Set dst (Conv2B src));
10133   effect(KILL cr);
10134 
10135   format %{ &quot;testl   $src, $src\t# ci2b\n\t&quot;
10136             &quot;setnz   $dst\n\t&quot;
10137             &quot;movzbl  $dst, $dst&quot; %}
10138   ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), // testl
10139              setNZ_reg(dst),
10140              REX_reg_breg(dst, dst), // movzbl
10141              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10142   ins_pipe(pipe_slow); // XXX
10143 %}
10144 
10145 // Convert Pointer to Boolean
10146 instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)
10147 %{
10148   match(Set dst (Conv2B src));
10149   effect(KILL cr);
10150 
10151   format %{ &quot;testq   $src, $src\t# cp2b\n\t&quot;
10152             &quot;setnz   $dst\n\t&quot;
10153             &quot;movzbl  $dst, $dst&quot; %}
10154   ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), // testq
10155              setNZ_reg(dst),
10156              REX_reg_breg(dst, dst), // movzbl
10157              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10158   ins_pipe(pipe_slow); // XXX
10159 %}
10160 
10161 instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)
10162 %{
10163   match(Set dst (CmpLTMask p q));
10164   effect(KILL cr);
10165 
10166   ins_cost(400);
10167   format %{ &quot;cmpl    $p, $q\t# cmpLTMask\n\t&quot;
10168             &quot;setlt   $dst\n\t&quot;
10169             &quot;movzbl  $dst, $dst\n\t&quot;
10170             &quot;negl    $dst&quot; %}
10171   ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), // cmpl
10172              setLT_reg(dst),
10173              REX_reg_breg(dst, dst), // movzbl
10174              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),
10175              neg_reg(dst));
10176   ins_pipe(pipe_slow);
10177 %}
10178 
10179 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
10180 %{
10181   match(Set dst (CmpLTMask dst zero));
10182   effect(KILL cr);
10183 
10184   ins_cost(100);
10185   format %{ &quot;sarl    $dst, #31\t# cmpLTMask0&quot; %}
10186   ins_encode %{
10187   __ sarl($dst$$Register, 31);
10188   %}
10189   ins_pipe(ialu_reg);
10190 %}
10191 
10192 /* Better to save a register than avoid a branch */
10193 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10194 %{
10195   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
10196   effect(KILL cr);
10197   ins_cost(300);
10198   format %{ &quot;subl    $p,$q\t# cadd_cmpLTMask\n\t&quot;
10199             &quot;jge     done\n\t&quot;
10200             &quot;addl    $p,$y\n&quot;
10201             &quot;done:   &quot; %}
10202   ins_encode %{
10203     Register Rp = $p$$Register;
10204     Register Rq = $q$$Register;
10205     Register Ry = $y$$Register;
10206     Label done;
10207     __ subl(Rp, Rq);
10208     __ jccb(Assembler::greaterEqual, done);
10209     __ addl(Rp, Ry);
10210     __ bind(done);
10211   %}
10212   ins_pipe(pipe_cmplt);
10213 %}
10214 
10215 /* Better to save a register than avoid a branch */
10216 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10217 %{
10218   match(Set y (AndI (CmpLTMask p q) y));
10219   effect(KILL cr);
10220 
10221   ins_cost(300);
10222 
10223   format %{ &quot;cmpl    $p, $q\t# and_cmpLTMask\n\t&quot;
10224             &quot;jlt     done\n\t&quot;
10225             &quot;xorl    $y, $y\n&quot;
10226             &quot;done:   &quot; %}
10227   ins_encode %{
10228     Register Rp = $p$$Register;
10229     Register Rq = $q$$Register;
10230     Register Ry = $y$$Register;
10231     Label done;
10232     __ cmpl(Rp, Rq);
10233     __ jccb(Assembler::less, done);
10234     __ xorl(Ry, Ry);
10235     __ bind(done);
10236   %}
10237   ins_pipe(pipe_cmplt);
10238 %}
10239 
10240 
10241 //---------- FP Instructions------------------------------------------------
10242 
10243 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
10244 %{
10245   match(Set cr (CmpF src1 src2));
10246 
10247   ins_cost(145);
10248   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10249             &quot;jnp,s   exit\n\t&quot;
10250             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10251             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10252             &quot;popfq\n&quot;
10253     &quot;exit:&quot; %}
10254   ins_encode %{
10255     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10256     emit_cmpfp_fixup(_masm);
10257   %}
10258   ins_pipe(pipe_slow);
10259 %}
10260 
10261 instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{
10262   match(Set cr (CmpF src1 src2));
10263 
10264   ins_cost(100);
10265   format %{ &quot;ucomiss $src1, $src2&quot; %}
10266   ins_encode %{
10267     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10268   %}
10269   ins_pipe(pipe_slow);
10270 %}
10271 
10272 instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)
10273 %{
10274   match(Set cr (CmpF src1 (LoadF src2)));
10275 
10276   ins_cost(145);
10277   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10278             &quot;jnp,s   exit\n\t&quot;
10279             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10280             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10281             &quot;popfq\n&quot;
10282     &quot;exit:&quot; %}
10283   ins_encode %{
10284     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10285     emit_cmpfp_fixup(_masm);
10286   %}
10287   ins_pipe(pipe_slow);
10288 %}
10289 
10290 instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{
10291   match(Set cr (CmpF src1 (LoadF src2)));
10292 
10293   ins_cost(100);
10294   format %{ &quot;ucomiss $src1, $src2&quot; %}
10295   ins_encode %{
10296     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10297   %}
10298   ins_pipe(pipe_slow);
10299 %}
10300 
10301 instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{
10302   match(Set cr (CmpF src con));
10303 
10304   ins_cost(145);
10305   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10306             &quot;jnp,s   exit\n\t&quot;
10307             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10308             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10309             &quot;popfq\n&quot;
10310     &quot;exit:&quot; %}
10311   ins_encode %{
10312     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10313     emit_cmpfp_fixup(_masm);
10314   %}
10315   ins_pipe(pipe_slow);
10316 %}
10317 
10318 instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{
10319   match(Set cr (CmpF src con));
10320   ins_cost(100);
10321   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con&quot; %}
10322   ins_encode %{
10323     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10324   %}
10325   ins_pipe(pipe_slow);
10326 %}
10327 
10328 instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)
10329 %{
10330   match(Set cr (CmpD src1 src2));
10331 
10332   ins_cost(145);
10333   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10334             &quot;jnp,s   exit\n\t&quot;
10335             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10336             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10337             &quot;popfq\n&quot;
10338     &quot;exit:&quot; %}
10339   ins_encode %{
10340     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10341     emit_cmpfp_fixup(_masm);
10342   %}
10343   ins_pipe(pipe_slow);
10344 %}
10345 
10346 instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{
10347   match(Set cr (CmpD src1 src2));
10348 
10349   ins_cost(100);
10350   format %{ &quot;ucomisd $src1, $src2 test&quot; %}
10351   ins_encode %{
10352     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10353   %}
10354   ins_pipe(pipe_slow);
10355 %}
10356 
10357 instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)
10358 %{
10359   match(Set cr (CmpD src1 (LoadD src2)));
10360 
10361   ins_cost(145);
10362   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10363             &quot;jnp,s   exit\n\t&quot;
10364             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10365             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10366             &quot;popfq\n&quot;
10367     &quot;exit:&quot; %}
10368   ins_encode %{
10369     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10370     emit_cmpfp_fixup(_masm);
10371   %}
10372   ins_pipe(pipe_slow);
10373 %}
10374 
10375 instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{
10376   match(Set cr (CmpD src1 (LoadD src2)));
10377 
10378   ins_cost(100);
10379   format %{ &quot;ucomisd $src1, $src2&quot; %}
10380   ins_encode %{
10381     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10382   %}
10383   ins_pipe(pipe_slow);
10384 %}
10385 
10386 instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{
10387   match(Set cr (CmpD src con));
10388 
10389   ins_cost(145);
10390   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10391             &quot;jnp,s   exit\n\t&quot;
10392             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10393             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10394             &quot;popfq\n&quot;
10395     &quot;exit:&quot; %}
10396   ins_encode %{
10397     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10398     emit_cmpfp_fixup(_masm);
10399   %}
10400   ins_pipe(pipe_slow);
10401 %}
10402 
10403 instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{
10404   match(Set cr (CmpD src con));
10405   ins_cost(100);
10406   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con&quot; %}
10407   ins_encode %{
10408     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10409   %}
10410   ins_pipe(pipe_slow);
10411 %}
10412 
10413 // Compare into -1,0,1
10414 instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)
10415 %{
10416   match(Set dst (CmpF3 src1 src2));
10417   effect(KILL cr);
10418 
10419   ins_cost(275);
10420   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10421             &quot;movl    $dst, #-1\n\t&quot;
10422             &quot;jp,s    done\n\t&quot;
10423             &quot;jb,s    done\n\t&quot;
10424             &quot;setne   $dst\n\t&quot;
10425             &quot;movzbl  $dst, $dst\n&quot;
10426     &quot;done:&quot; %}
10427   ins_encode %{
10428     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10429     emit_cmpfp3(_masm, $dst$$Register);
10430   %}
10431   ins_pipe(pipe_slow);
10432 %}
10433 
10434 // Compare into -1,0,1
10435 instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)
10436 %{
10437   match(Set dst (CmpF3 src1 (LoadF src2)));
10438   effect(KILL cr);
10439 
10440   ins_cost(275);
10441   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10442             &quot;movl    $dst, #-1\n\t&quot;
10443             &quot;jp,s    done\n\t&quot;
10444             &quot;jb,s    done\n\t&quot;
10445             &quot;setne   $dst\n\t&quot;
10446             &quot;movzbl  $dst, $dst\n&quot;
10447     &quot;done:&quot; %}
10448   ins_encode %{
10449     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10450     emit_cmpfp3(_masm, $dst$$Register);
10451   %}
10452   ins_pipe(pipe_slow);
10453 %}
10454 
10455 // Compare into -1,0,1
10456 instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{
10457   match(Set dst (CmpF3 src con));
10458   effect(KILL cr);
10459 
10460   ins_cost(275);
10461   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10462             &quot;movl    $dst, #-1\n\t&quot;
10463             &quot;jp,s    done\n\t&quot;
10464             &quot;jb,s    done\n\t&quot;
10465             &quot;setne   $dst\n\t&quot;
10466             &quot;movzbl  $dst, $dst\n&quot;
10467     &quot;done:&quot; %}
10468   ins_encode %{
10469     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10470     emit_cmpfp3(_masm, $dst$$Register);
10471   %}
10472   ins_pipe(pipe_slow);
10473 %}
10474 
10475 // Compare into -1,0,1
10476 instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)
10477 %{
10478   match(Set dst (CmpD3 src1 src2));
10479   effect(KILL cr);
10480 
10481   ins_cost(275);
10482   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10483             &quot;movl    $dst, #-1\n\t&quot;
10484             &quot;jp,s    done\n\t&quot;
10485             &quot;jb,s    done\n\t&quot;
10486             &quot;setne   $dst\n\t&quot;
10487             &quot;movzbl  $dst, $dst\n&quot;
10488     &quot;done:&quot; %}
10489   ins_encode %{
10490     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10491     emit_cmpfp3(_masm, $dst$$Register);
10492   %}
10493   ins_pipe(pipe_slow);
10494 %}
10495 
10496 // Compare into -1,0,1
10497 instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)
10498 %{
10499   match(Set dst (CmpD3 src1 (LoadD src2)));
10500   effect(KILL cr);
10501 
10502   ins_cost(275);
10503   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10504             &quot;movl    $dst, #-1\n\t&quot;
10505             &quot;jp,s    done\n\t&quot;
10506             &quot;jb,s    done\n\t&quot;
10507             &quot;setne   $dst\n\t&quot;
10508             &quot;movzbl  $dst, $dst\n&quot;
10509     &quot;done:&quot; %}
10510   ins_encode %{
10511     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10512     emit_cmpfp3(_masm, $dst$$Register);
10513   %}
10514   ins_pipe(pipe_slow);
10515 %}
10516 
10517 // Compare into -1,0,1
10518 instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{
10519   match(Set dst (CmpD3 src con));
10520   effect(KILL cr);
10521 
10522   ins_cost(275);
10523   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10524             &quot;movl    $dst, #-1\n\t&quot;
10525             &quot;jp,s    done\n\t&quot;
10526             &quot;jb,s    done\n\t&quot;
10527             &quot;setne   $dst\n\t&quot;
10528             &quot;movzbl  $dst, $dst\n&quot;
10529     &quot;done:&quot; %}
10530   ins_encode %{
10531     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10532     emit_cmpfp3(_masm, $dst$$Register);
10533   %}
10534   ins_pipe(pipe_slow);
10535 %}
10536 
10537 //----------Arithmetic Conversion Instructions---------------------------------
10538 
10539 instruct convF2D_reg_reg(regD dst, regF src)
10540 %{
10541   match(Set dst (ConvF2D src));
10542 
10543   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10544   ins_encode %{
10545     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10546   %}
10547   ins_pipe(pipe_slow); // XXX
10548 %}
10549 
10550 instruct convF2D_reg_mem(regD dst, memory src)
10551 %{
10552   match(Set dst (ConvF2D (LoadF src)));
10553 
10554   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10555   ins_encode %{
10556     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
10557   %}
10558   ins_pipe(pipe_slow); // XXX
10559 %}
10560 
10561 instruct convD2F_reg_reg(regF dst, regD src)
10562 %{
10563   match(Set dst (ConvD2F src));
10564 
10565   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10566   ins_encode %{
10567     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
10568   %}
10569   ins_pipe(pipe_slow); // XXX
10570 %}
10571 
10572 instruct convD2F_reg_mem(regF dst, memory src)
10573 %{
10574   match(Set dst (ConvD2F (LoadD src)));
10575 
10576   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10577   ins_encode %{
10578     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
10579   %}
10580   ins_pipe(pipe_slow); // XXX
10581 %}
10582 
10583 // XXX do mem variants
10584 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
10585 %{
10586   match(Set dst (ConvF2I src));
10587   effect(KILL cr);
10588   format %{ &quot;convert_f2i $dst,$src&quot; %}
10589   ins_encode %{
10590     __ convert_f2i($dst$$Register, $src$$XMMRegister);
10591   %}
10592   ins_pipe(pipe_slow);
10593 %}
10594 
10595 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
10596 %{
10597   match(Set dst (ConvF2L src));
10598   effect(KILL cr);
10599   format %{ &quot;convert_f2l $dst,$src&quot;%}
10600   ins_encode %{
10601     __ convert_f2l($dst$$Register, $src$$XMMRegister);
10602   %}
10603   ins_pipe(pipe_slow);
10604 %}
10605 
10606 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
10607 %{
10608   match(Set dst (ConvD2I src));
10609   effect(KILL cr);
10610   format %{ &quot;convert_d2i $dst,$src&quot;%}
10611   ins_encode %{
10612     __ convert_d2i($dst$$Register, $src$$XMMRegister);
10613   %}
10614   ins_pipe(pipe_slow);
10615 %}
10616 
10617 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
10618 %{
10619   match(Set dst (ConvD2L src));
10620   effect(KILL cr);
10621   format %{ &quot;convert_d2l $dst,$src&quot;%}
10622   ins_encode %{
10623     __ convert_d2l($dst$$Register, $src$$XMMRegister);
10624   %}
10625   ins_pipe(pipe_slow);
10626 %}
10627 
10628 instruct convI2F_reg_reg(regF dst, rRegI src)
10629 %{
10630   predicate(!UseXmmI2F);
10631   match(Set dst (ConvI2F src));
10632 
10633   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10634   ins_encode %{
10635     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
10636   %}
10637   ins_pipe(pipe_slow); // XXX
10638 %}
10639 
10640 instruct convI2F_reg_mem(regF dst, memory src)
10641 %{
10642   match(Set dst (ConvI2F (LoadI src)));
10643 
10644   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10645   ins_encode %{
10646     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);
10647   %}
10648   ins_pipe(pipe_slow); // XXX
10649 %}
10650 
10651 instruct convI2D_reg_reg(regD dst, rRegI src)
10652 %{
10653   predicate(!UseXmmI2D);
10654   match(Set dst (ConvI2D src));
10655 
10656   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10657   ins_encode %{
10658     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
10659   %}
10660   ins_pipe(pipe_slow); // XXX
10661 %}
10662 
10663 instruct convI2D_reg_mem(regD dst, memory src)
10664 %{
10665   match(Set dst (ConvI2D (LoadI src)));
10666 
10667   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10668   ins_encode %{
10669     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);
10670   %}
10671   ins_pipe(pipe_slow); // XXX
10672 %}
10673 
10674 instruct convXI2F_reg(regF dst, rRegI src)
10675 %{
10676   predicate(UseXmmI2F);
10677   match(Set dst (ConvI2F src));
10678 
10679   format %{ &quot;movdl $dst, $src\n\t&quot;
10680             &quot;cvtdq2psl $dst, $dst\t# i2f&quot; %}
10681   ins_encode %{
10682     __ movdl($dst$$XMMRegister, $src$$Register);
10683     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
10684   %}
10685   ins_pipe(pipe_slow); // XXX
10686 %}
10687 
10688 instruct convXI2D_reg(regD dst, rRegI src)
10689 %{
10690   predicate(UseXmmI2D);
10691   match(Set dst (ConvI2D src));
10692 
10693   format %{ &quot;movdl $dst, $src\n\t&quot;
10694             &quot;cvtdq2pdl $dst, $dst\t# i2d&quot; %}
10695   ins_encode %{
10696     __ movdl($dst$$XMMRegister, $src$$Register);
10697     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
10698   %}
10699   ins_pipe(pipe_slow); // XXX
10700 %}
10701 
10702 instruct convL2F_reg_reg(regF dst, rRegL src)
10703 %{
10704   match(Set dst (ConvL2F src));
10705 
10706   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10707   ins_encode %{
10708     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);
10709   %}
10710   ins_pipe(pipe_slow); // XXX
10711 %}
10712 
10713 instruct convL2F_reg_mem(regF dst, memory src)
10714 %{
10715   match(Set dst (ConvL2F (LoadL src)));
10716 
10717   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10718   ins_encode %{
10719     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);
10720   %}
10721   ins_pipe(pipe_slow); // XXX
10722 %}
10723 
10724 instruct convL2D_reg_reg(regD dst, rRegL src)
10725 %{
10726   match(Set dst (ConvL2D src));
10727 
10728   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10729   ins_encode %{
10730     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);
10731   %}
10732   ins_pipe(pipe_slow); // XXX
10733 %}
10734 
10735 instruct convL2D_reg_mem(regD dst, memory src)
10736 %{
10737   match(Set dst (ConvL2D (LoadL src)));
10738 
10739   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10740   ins_encode %{
10741     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);
10742   %}
10743   ins_pipe(pipe_slow); // XXX
10744 %}
10745 
10746 instruct convI2L_reg_reg(rRegL dst, rRegI src)
10747 %{
10748   match(Set dst (ConvI2L src));
10749 
10750   ins_cost(125);
10751   format %{ &quot;movslq  $dst, $src\t# i2l&quot; %}
10752   ins_encode %{
10753     __ movslq($dst$$Register, $src$$Register);
10754   %}
10755   ins_pipe(ialu_reg_reg);
10756 %}
10757 
10758 // instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)
10759 // %{
10760 //   match(Set dst (ConvI2L src));
10761 // //   predicate(_kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_lo &gt;= 0 &amp;&amp;
10762 // //             _kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_hi &gt;= 0);
10763 //   predicate(((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi ==
10764 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi &amp;&amp;
10765 //             ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo ==
10766 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo);
10767 
10768 //   format %{ &quot;movl    $dst, $src\t# unsigned i2l&quot; %}
10769 //   ins_encode(enc_copy(dst, src));
10770 // //   opcode(0x63); // needs REX.W
10771 // //   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
10772 //   ins_pipe(ialu_reg_reg);
10773 // %}
10774 
10775 // Zero-extend convert int to long
10776 instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)
10777 %{
10778   match(Set dst (AndL (ConvI2L src) mask));
10779 
10780   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10781   ins_encode %{
10782     if ($dst$$reg != $src$$reg) {
10783       __ movl($dst$$Register, $src$$Register);
10784     }
10785   %}
10786   ins_pipe(ialu_reg_reg);
10787 %}
10788 
10789 // Zero-extend convert int to long
10790 instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)
10791 %{
10792   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
10793 
10794   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10795   ins_encode %{
10796     __ movl($dst$$Register, $src$$Address);
10797   %}
10798   ins_pipe(ialu_reg_mem);
10799 %}
10800 
10801 instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)
10802 %{
10803   match(Set dst (AndL src mask));
10804 
10805   format %{ &quot;movl    $dst, $src\t# zero-extend long&quot; %}
10806   ins_encode %{
10807     __ movl($dst$$Register, $src$$Register);
10808   %}
10809   ins_pipe(ialu_reg_reg);
10810 %}
10811 
10812 instruct convL2I_reg_reg(rRegI dst, rRegL src)
10813 %{
10814   match(Set dst (ConvL2I src));
10815 
10816   format %{ &quot;movl    $dst, $src\t# l2i&quot; %}
10817   ins_encode %{
10818     __ movl($dst$$Register, $src$$Register);
10819   %}
10820   ins_pipe(ialu_reg_reg);
10821 %}
10822 
10823 
10824 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
10825   match(Set dst (MoveF2I src));
10826   effect(DEF dst, USE src);
10827 
10828   ins_cost(125);
10829   format %{ &quot;movl    $dst, $src\t# MoveF2I_stack_reg&quot; %}
10830   ins_encode %{
10831     __ movl($dst$$Register, Address(rsp, $src$$disp));
10832   %}
10833   ins_pipe(ialu_reg_mem);
10834 %}
10835 
10836 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
10837   match(Set dst (MoveI2F src));
10838   effect(DEF dst, USE src);
10839 
10840   ins_cost(125);
10841   format %{ &quot;movss   $dst, $src\t# MoveI2F_stack_reg&quot; %}
10842   ins_encode %{
10843     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
10844   %}
10845   ins_pipe(pipe_slow);
10846 %}
10847 
10848 instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{
10849   match(Set dst (MoveD2L src));
10850   effect(DEF dst, USE src);
10851 
10852   ins_cost(125);
10853   format %{ &quot;movq    $dst, $src\t# MoveD2L_stack_reg&quot; %}
10854   ins_encode %{
10855     __ movq($dst$$Register, Address(rsp, $src$$disp));
10856   %}
10857   ins_pipe(ialu_reg_mem);
10858 %}
10859 
10860 instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{
10861   predicate(!UseXmmLoadAndClearUpper);
10862   match(Set dst (MoveL2D src));
10863   effect(DEF dst, USE src);
10864 
10865   ins_cost(125);
10866   format %{ &quot;movlpd  $dst, $src\t# MoveL2D_stack_reg&quot; %}
10867   ins_encode %{
10868     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10869   %}
10870   ins_pipe(pipe_slow);
10871 %}
10872 
10873 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
10874   predicate(UseXmmLoadAndClearUpper);
10875   match(Set dst (MoveL2D src));
10876   effect(DEF dst, USE src);
10877 
10878   ins_cost(125);
10879   format %{ &quot;movsd   $dst, $src\t# MoveL2D_stack_reg&quot; %}
10880   ins_encode %{
10881     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10882   %}
10883   ins_pipe(pipe_slow);
10884 %}
10885 
10886 
10887 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
10888   match(Set dst (MoveF2I src));
10889   effect(DEF dst, USE src);
10890 
10891   ins_cost(95); // XXX
10892   format %{ &quot;movss   $dst, $src\t# MoveF2I_reg_stack&quot; %}
10893   ins_encode %{
10894     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
10895   %}
10896   ins_pipe(pipe_slow);
10897 %}
10898 
10899 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
10900   match(Set dst (MoveI2F src));
10901   effect(DEF dst, USE src);
10902 
10903   ins_cost(100);
10904   format %{ &quot;movl    $dst, $src\t# MoveI2F_reg_stack&quot; %}
10905   ins_encode %{
10906     __ movl(Address(rsp, $dst$$disp), $src$$Register);
10907   %}
10908   ins_pipe( ialu_mem_reg );
10909 %}
10910 
10911 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
10912   match(Set dst (MoveD2L src));
10913   effect(DEF dst, USE src);
10914 
10915   ins_cost(95); // XXX
10916   format %{ &quot;movsd   $dst, $src\t# MoveL2D_reg_stack&quot; %}
10917   ins_encode %{
10918     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
10919   %}
10920   ins_pipe(pipe_slow);
10921 %}
10922 
10923 instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{
10924   match(Set dst (MoveL2D src));
10925   effect(DEF dst, USE src);
10926 
10927   ins_cost(100);
10928   format %{ &quot;movq    $dst, $src\t# MoveL2D_reg_stack&quot; %}
10929   ins_encode %{
10930     __ movq(Address(rsp, $dst$$disp), $src$$Register);
10931   %}
10932   ins_pipe(ialu_mem_reg);
10933 %}
10934 
10935 instruct MoveF2I_reg_reg(rRegI dst, regF src) %{
10936   match(Set dst (MoveF2I src));
10937   effect(DEF dst, USE src);
10938   ins_cost(85);
10939   format %{ &quot;movd    $dst,$src\t# MoveF2I&quot; %}
10940   ins_encode %{
10941     __ movdl($dst$$Register, $src$$XMMRegister);
10942   %}
10943   ins_pipe( pipe_slow );
10944 %}
10945 
10946 instruct MoveD2L_reg_reg(rRegL dst, regD src) %{
10947   match(Set dst (MoveD2L src));
10948   effect(DEF dst, USE src);
10949   ins_cost(85);
10950   format %{ &quot;movd    $dst,$src\t# MoveD2L&quot; %}
10951   ins_encode %{
10952     __ movdq($dst$$Register, $src$$XMMRegister);
10953   %}
10954   ins_pipe( pipe_slow );
10955 %}
10956 
10957 instruct MoveI2F_reg_reg(regF dst, rRegI src) %{
10958   match(Set dst (MoveI2F src));
10959   effect(DEF dst, USE src);
10960   ins_cost(100);
10961   format %{ &quot;movd    $dst,$src\t# MoveI2F&quot; %}
10962   ins_encode %{
10963     __ movdl($dst$$XMMRegister, $src$$Register);
10964   %}
10965   ins_pipe( pipe_slow );
10966 %}
10967 
10968 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10969   match(Set dst (MoveL2D src));
10970   effect(DEF dst, USE src);
10971   ins_cost(100);
10972   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
10973   ins_encode %{
10974      __ movdq($dst$$XMMRegister, $src$$Register);
10975   %}
10976   ins_pipe( pipe_slow );
10977 %}
10978 
10979 
10980 // =======================================================================
10981 // fast clearing of an array
10982 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,
10983                   Universe dummy, rFlagsReg cr)
10984 %{
10985   predicate(!((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; !((ClearArrayNode*)n)-&gt;word_copy_only());
10986   match(Set dummy (ClearArray (Binary cnt base) val));
10987   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
10988 
10989   format %{ $$template
10990     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
10991     $$emit$$&quot;jg      LARGE\n\t&quot;
10992     $$emit$$&quot;dec     rcx\n\t&quot;
10993     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
10994     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
10995     $$emit$$&quot;dec     rcx\n\t&quot;
10996     $$emit$$&quot;jge     LOOP\n\t&quot;
10997     $$emit$$&quot;jmp     DONE\n\t&quot;
10998     $$emit$$&quot;# LARGE:\n\t&quot;
10999     if (UseFastStosb) {
11000        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
11001        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
11002     } else if (UseXMMForObjInit) {
11003        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
11004        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
11005        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
11006        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11007        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11008        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11009        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
11010        $$emit$$&quot;add     0x40,rax\n\t&quot;
11011        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11012        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11013        $$emit$$&quot;jge     L_loop\n\t&quot;
11014        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11015        $$emit$$&quot;jl      L_tail\n\t&quot;
11016        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11017        $$emit$$&quot;add     0x20,rax\n\t&quot;
11018        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11019        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11020        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11021        $$emit$$&quot;jle     L_end\n\t&quot;
11022        $$emit$$&quot;dec     rcx\n\t&quot;
11023        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11024        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11025        $$emit$$&quot;add     0x8,rax\n\t&quot;
11026        $$emit$$&quot;dec     rcx\n\t&quot;
11027        $$emit$$&quot;jge     L_sloop\n\t&quot;
11028        $$emit$$&quot;# L_end:\n\t&quot;
11029     } else {
11030        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
11031     }
11032     $$emit$$&quot;# DONE&quot;
11033   %}
11034   ins_encode %{
11035     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,
11036                  $tmp$$XMMRegister, false, false);
11037   %}
11038   ins_pipe(pipe_slow);
11039 %}
11040 
11041 instruct rep_stos_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,
11042                   Universe dummy, rFlagsReg cr)
11043 %{
11044   predicate(!((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; ((ClearArrayNode*)n)-&gt;word_copy_only());
11045   match(Set dummy (ClearArray (Binary cnt base) val));
11046   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
11047 
11048   format %{ $$template
11049     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
11050     $$emit$$&quot;jg      LARGE\n\t&quot;
11051     $$emit$$&quot;dec     rcx\n\t&quot;
11052     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
11053     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
11054     $$emit$$&quot;dec     rcx\n\t&quot;
11055     $$emit$$&quot;jge     LOOP\n\t&quot;
11056     $$emit$$&quot;jmp     DONE\n\t&quot;
11057     $$emit$$&quot;# LARGE:\n\t&quot;
11058     if (UseXMMForObjInit) {
11059        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
11060        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
11061        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
11062        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11063        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11064        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11065        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
11066        $$emit$$&quot;add     0x40,rax\n\t&quot;
11067        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11068        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11069        $$emit$$&quot;jge     L_loop\n\t&quot;
11070        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11071        $$emit$$&quot;jl      L_tail\n\t&quot;
11072        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11073        $$emit$$&quot;add     0x20,rax\n\t&quot;
11074        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11075        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11076        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11077        $$emit$$&quot;jle     L_end\n\t&quot;
11078        $$emit$$&quot;dec     rcx\n\t&quot;
11079        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11080        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11081        $$emit$$&quot;add     0x8,rax\n\t&quot;
11082        $$emit$$&quot;dec     rcx\n\t&quot;
11083        $$emit$$&quot;jge     L_sloop\n\t&quot;
11084        $$emit$$&quot;# L_end:\n\t&quot;
11085     } else {
11086        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
11087     }
11088     $$emit$$&quot;# DONE&quot;
11089   %}
11090   ins_encode %{
11091     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,
11092                  $tmp$$XMMRegister, false, true);
11093   %}
11094   ins_pipe(pipe_slow);
11095 %}
11096 
11097 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,
11098                         Universe dummy, rFlagsReg cr)
11099 %{
11100   predicate(((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; !((ClearArrayNode*)n)-&gt;word_copy_only());
11101   match(Set dummy (ClearArray (Binary cnt base) val));
11102   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
11103 
11104   format %{ $$template
11105     if (UseFastStosb) {
11106        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
11107        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
11108     } else if (UseXMMForObjInit) {
11109        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
11110        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
11111        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
11112        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11113        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11114        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11115        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
11116        $$emit$$&quot;add     0x40,rax\n\t&quot;
11117        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11118        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11119        $$emit$$&quot;jge     L_loop\n\t&quot;
11120        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11121        $$emit$$&quot;jl      L_tail\n\t&quot;
11122        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11123        $$emit$$&quot;add     0x20,rax\n\t&quot;
11124        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11125        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11126        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11127        $$emit$$&quot;jle     L_end\n\t&quot;
11128        $$emit$$&quot;dec     rcx\n\t&quot;
11129        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11130        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11131        $$emit$$&quot;add     0x8,rax\n\t&quot;
11132        $$emit$$&quot;dec     rcx\n\t&quot;
11133        $$emit$$&quot;jge     L_sloop\n\t&quot;
11134        $$emit$$&quot;# L_end:\n\t&quot;
11135     } else {
11136        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11137     }
11138   %}
11139   ins_encode %{
11140     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,
11141                  $tmp$$XMMRegister, true, false);
11142   %}
11143   ins_pipe(pipe_slow);
11144 %}
11145 
11146 instruct rep_stos_large_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val, 
11147                         Universe dummy, rFlagsReg cr)
11148 %{
11149   predicate(((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; ((ClearArrayNode*)n)-&gt;word_copy_only());
11150   match(Set dummy (ClearArray (Binary cnt base) val));
11151   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
11152 
11153   format %{ $$template
11154     if (UseXMMForObjInit) {
11155        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
11156        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
11157        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
11158        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11159        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11160        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11161        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
11162        $$emit$$&quot;add     0x40,rax\n\t&quot;
11163        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11164        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11165        $$emit$$&quot;jge     L_loop\n\t&quot;
11166        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11167        $$emit$$&quot;jl      L_tail\n\t&quot;
11168        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11169        $$emit$$&quot;add     0x20,rax\n\t&quot;
11170        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11171        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11172        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11173        $$emit$$&quot;jle     L_end\n\t&quot;
11174        $$emit$$&quot;dec     rcx\n\t&quot;
11175        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11176        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11177        $$emit$$&quot;add     0x8,rax\n\t&quot;
11178        $$emit$$&quot;dec     rcx\n\t&quot;
11179        $$emit$$&quot;jge     L_sloop\n\t&quot;
11180        $$emit$$&quot;# L_end:\n\t&quot;
11181     } else {
11182        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11183     }
11184   %}
11185   ins_encode %{
11186     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register, 
11187                  $tmp$$XMMRegister, true, true);
11188   %}
11189   ins_pipe(pipe_slow);
11190 %}
11191 
11192 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11193                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11194 %{
11195   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11196   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11197   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11198 
11199   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11200   ins_encode %{
11201     __ string_compare($str1$$Register, $str2$$Register,
11202                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11203                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11204   %}
11205   ins_pipe( pipe_slow );
11206 %}
11207 
11208 instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11209                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11210 %{
11211   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11212   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11213   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11214 
11215   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11216   ins_encode %{
11217     __ string_compare($str1$$Register, $str2$$Register,
11218                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11219                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11220   %}
11221   ins_pipe( pipe_slow );
11222 %}
11223 
11224 instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11225                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11226 %{
11227   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11228   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11229   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11230 
11231   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11232   ins_encode %{
11233     __ string_compare($str1$$Register, $str2$$Register,
11234                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11235                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11236   %}
11237   ins_pipe( pipe_slow );
11238 %}
11239 
11240 instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,
11241                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11242 %{
11243   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11244   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11245   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11246 
11247   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11248   ins_encode %{
11249     __ string_compare($str2$$Register, $str1$$Register,
11250                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11251                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11252   %}
11253   ins_pipe( pipe_slow );
11254 %}
11255 
11256 // fast search of substring with known size.
11257 instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11258                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11259 %{
11260   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11261   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11262   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11263 
11264   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11265   ins_encode %{
11266     int icnt2 = (int)$int_cnt2$$constant;
11267     if (icnt2 &gt;= 16) {
11268       // IndexOf for constant substrings with size &gt;= 16 elements
11269       // which don&#39;t need to be loaded through stack.
11270       __ string_indexofC8($str1$$Register, $str2$$Register,
11271                           $cnt1$$Register, $cnt2$$Register,
11272                           icnt2, $result$$Register,
11273                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11274     } else {
11275       // Small strings are loaded through stack if they cross page boundary.
11276       __ string_indexof($str1$$Register, $str2$$Register,
11277                         $cnt1$$Register, $cnt2$$Register,
11278                         icnt2, $result$$Register,
11279                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11280     }
11281   %}
11282   ins_pipe( pipe_slow );
11283 %}
11284 
11285 // fast search of substring with known size.
11286 instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11287                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11288 %{
11289   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11290   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11291   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11292 
11293   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11294   ins_encode %{
11295     int icnt2 = (int)$int_cnt2$$constant;
11296     if (icnt2 &gt;= 8) {
11297       // IndexOf for constant substrings with size &gt;= 8 elements
11298       // which don&#39;t need to be loaded through stack.
11299       __ string_indexofC8($str1$$Register, $str2$$Register,
11300                           $cnt1$$Register, $cnt2$$Register,
11301                           icnt2, $result$$Register,
11302                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11303     } else {
11304       // Small strings are loaded through stack if they cross page boundary.
11305       __ string_indexof($str1$$Register, $str2$$Register,
11306                         $cnt1$$Register, $cnt2$$Register,
11307                         icnt2, $result$$Register,
11308                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11309     }
11310   %}
11311   ins_pipe( pipe_slow );
11312 %}
11313 
11314 // fast search of substring with known size.
11315 instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11316                               rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11317 %{
11318   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11319   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11320   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11321 
11322   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11323   ins_encode %{
11324     int icnt2 = (int)$int_cnt2$$constant;
11325     if (icnt2 &gt;= 8) {
11326       // IndexOf for constant substrings with size &gt;= 8 elements
11327       // which don&#39;t need to be loaded through stack.
11328       __ string_indexofC8($str1$$Register, $str2$$Register,
11329                           $cnt1$$Register, $cnt2$$Register,
11330                           icnt2, $result$$Register,
11331                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11332     } else {
11333       // Small strings are loaded through stack if they cross page boundary.
11334       __ string_indexof($str1$$Register, $str2$$Register,
11335                         $cnt1$$Register, $cnt2$$Register,
11336                         icnt2, $result$$Register,
11337                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11338     }
11339   %}
11340   ins_pipe( pipe_slow );
11341 %}
11342 
11343 instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11344                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11345 %{
11346   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11347   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11348   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11349 
11350   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11351   ins_encode %{
11352     __ string_indexof($str1$$Register, $str2$$Register,
11353                       $cnt1$$Register, $cnt2$$Register,
11354                       (-1), $result$$Register,
11355                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11356   %}
11357   ins_pipe( pipe_slow );
11358 %}
11359 
11360 instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11361                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11362 %{
11363   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11364   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11365   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11366 
11367   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11368   ins_encode %{
11369     __ string_indexof($str1$$Register, $str2$$Register,
11370                       $cnt1$$Register, $cnt2$$Register,
11371                       (-1), $result$$Register,
11372                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11373   %}
11374   ins_pipe( pipe_slow );
11375 %}
11376 
11377 instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11378                           rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11379 %{
11380   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11381   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11382   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11383 
11384   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11385   ins_encode %{
11386     __ string_indexof($str1$$Register, $str2$$Register,
11387                       $cnt1$$Register, $cnt2$$Register,
11388                       (-1), $result$$Register,
11389                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11390   %}
11391   ins_pipe( pipe_slow );
11392 %}
11393 
11394 instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,
11395                               rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)
11396 %{
11397   predicate(UseSSE42Intrinsics);
11398   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11399   effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11400   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11401   ins_encode %{
11402     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11403                            $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);
11404   %}
11405   ins_pipe( pipe_slow );
11406 %}
11407 
11408 // fast string equals
11409 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
11410                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11411 %{
11412   match(Set result (StrEquals (Binary str1 str2) cnt));
11413   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11414 
11415   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11416   ins_encode %{
11417     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11418                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11419                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11420   %}
11421   ins_pipe( pipe_slow );
11422 %}
11423 
11424 // fast array equals
11425 instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11426                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11427 %{
11428   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11429   match(Set result (AryEq ary1 ary2));
11430   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11431 
11432   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11433   ins_encode %{
11434     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11435                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11436                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11437   %}
11438   ins_pipe( pipe_slow );
11439 %}
11440 
11441 instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11442                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11443 %{
11444   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11445   match(Set result (AryEq ary1 ary2));
11446   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11447 
11448   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11449   ins_encode %{
11450     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11451                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11452                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11453   %}
11454   ins_pipe( pipe_slow );
11455 %}
11456 
11457 instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,
11458                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11459 %{
11460   match(Set result (HasNegatives ary1 len));
11461   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11462 
11463   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11464   ins_encode %{
11465     __ has_negatives($ary1$$Register, $len$$Register,
11466                      $result$$Register, $tmp3$$Register,
11467                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11468   %}
11469   ins_pipe( pipe_slow );
11470 %}
11471 
11472 // fast char[] to byte[] compression
11473 instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11474                          rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11475   match(Set result (StrCompressedCopy src (Binary dst len)));
11476   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11477 
11478   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11479   ins_encode %{
11480     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11481                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11482                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11483   %}
11484   ins_pipe( pipe_slow );
11485 %}
11486 
11487 // fast byte[] to char[] inflation
11488 instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11489                         legRegD tmp1, rcx_RegI tmp2, rFlagsReg cr) %{
11490   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11491   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11492 
11493   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11494   ins_encode %{
11495     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11496                           $tmp1$$XMMRegister, $tmp2$$Register);
11497   %}
11498   ins_pipe( pipe_slow );
11499 %}
11500 
11501 // encode char[] to byte[] in ISO_8859_1
11502 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11503                           legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11504                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11505   match(Set result (EncodeISOArray src (Binary dst len)));
11506   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11507 
11508   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI &quot; %}
11509   ins_encode %{
11510     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11511                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11512                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11513   %}
11514   ins_pipe( pipe_slow );
11515 %}
11516 
11517 //----------Overflow Math Instructions-----------------------------------------
11518 
11519 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11520 %{
11521   match(Set cr (OverflowAddI op1 op2));
11522   effect(DEF cr, USE_KILL op1, USE op2);
11523 
11524   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11525 
11526   ins_encode %{
11527     __ addl($op1$$Register, $op2$$Register);
11528   %}
11529   ins_pipe(ialu_reg_reg);
11530 %}
11531 
11532 instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)
11533 %{
11534   match(Set cr (OverflowAddI op1 op2));
11535   effect(DEF cr, USE_KILL op1, USE op2);
11536 
11537   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11538 
11539   ins_encode %{
11540     __ addl($op1$$Register, $op2$$constant);
11541   %}
11542   ins_pipe(ialu_reg_reg);
11543 %}
11544 
11545 instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11546 %{
11547   match(Set cr (OverflowAddL op1 op2));
11548   effect(DEF cr, USE_KILL op1, USE op2);
11549 
11550   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11551   ins_encode %{
11552     __ addq($op1$$Register, $op2$$Register);
11553   %}
11554   ins_pipe(ialu_reg_reg);
11555 %}
11556 
11557 instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)
11558 %{
11559   match(Set cr (OverflowAddL op1 op2));
11560   effect(DEF cr, USE_KILL op1, USE op2);
11561 
11562   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11563   ins_encode %{
11564     __ addq($op1$$Register, $op2$$constant);
11565   %}
11566   ins_pipe(ialu_reg_reg);
11567 %}
11568 
11569 instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11570 %{
11571   match(Set cr (OverflowSubI op1 op2));
11572 
11573   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11574   ins_encode %{
11575     __ cmpl($op1$$Register, $op2$$Register);
11576   %}
11577   ins_pipe(ialu_reg_reg);
11578 %}
11579 
11580 instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11581 %{
11582   match(Set cr (OverflowSubI op1 op2));
11583 
11584   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11585   ins_encode %{
11586     __ cmpl($op1$$Register, $op2$$constant);
11587   %}
11588   ins_pipe(ialu_reg_reg);
11589 %}
11590 
11591 instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11592 %{
11593   match(Set cr (OverflowSubL op1 op2));
11594 
11595   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11596   ins_encode %{
11597     __ cmpq($op1$$Register, $op2$$Register);
11598   %}
11599   ins_pipe(ialu_reg_reg);
11600 %}
11601 
11602 instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11603 %{
11604   match(Set cr (OverflowSubL op1 op2));
11605 
11606   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11607   ins_encode %{
11608     __ cmpq($op1$$Register, $op2$$constant);
11609   %}
11610   ins_pipe(ialu_reg_reg);
11611 %}
11612 
11613 instruct overflowNegI_rReg(rFlagsReg cr, immI0 zero, rax_RegI op2)
11614 %{
11615   match(Set cr (OverflowSubI zero op2));
11616   effect(DEF cr, USE_KILL op2);
11617 
11618   format %{ &quot;negl    $op2\t# overflow check int&quot; %}
11619   ins_encode %{
11620     __ negl($op2$$Register);
11621   %}
11622   ins_pipe(ialu_reg_reg);
11623 %}
11624 
11625 instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)
11626 %{
11627   match(Set cr (OverflowSubL zero op2));
11628   effect(DEF cr, USE_KILL op2);
11629 
11630   format %{ &quot;negq    $op2\t# overflow check long&quot; %}
11631   ins_encode %{
11632     __ negq($op2$$Register);
11633   %}
11634   ins_pipe(ialu_reg_reg);
11635 %}
11636 
11637 instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11638 %{
11639   match(Set cr (OverflowMulI op1 op2));
11640   effect(DEF cr, USE_KILL op1, USE op2);
11641 
11642   format %{ &quot;imull    $op1, $op2\t# overflow check int&quot; %}
11643   ins_encode %{
11644     __ imull($op1$$Register, $op2$$Register);
11645   %}
11646   ins_pipe(ialu_reg_reg_alu0);
11647 %}
11648 
11649 instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
11650 %{
11651   match(Set cr (OverflowMulI op1 op2));
11652   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11653 
11654   format %{ &quot;imull    $tmp, $op1, $op2\t# overflow check int&quot; %}
11655   ins_encode %{
11656     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
11657   %}
11658   ins_pipe(ialu_reg_reg_alu0);
11659 %}
11660 
11661 instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11662 %{
11663   match(Set cr (OverflowMulL op1 op2));
11664   effect(DEF cr, USE_KILL op1, USE op2);
11665 
11666   format %{ &quot;imulq    $op1, $op2\t# overflow check long&quot; %}
11667   ins_encode %{
11668     __ imulq($op1$$Register, $op2$$Register);
11669   %}
11670   ins_pipe(ialu_reg_reg_alu0);
11671 %}
11672 
11673 instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)
11674 %{
11675   match(Set cr (OverflowMulL op1 op2));
11676   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11677 
11678   format %{ &quot;imulq    $tmp, $op1, $op2\t# overflow check long&quot; %}
11679   ins_encode %{
11680     __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);
11681   %}
11682   ins_pipe(ialu_reg_reg_alu0);
11683 %}
11684 
11685 
11686 //----------Control Flow Instructions------------------------------------------
11687 // Signed compare Instructions
11688 
11689 // XXX more variants!!
11690 instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11691 %{
11692   match(Set cr (CmpI op1 op2));
11693   effect(DEF cr, USE op1, USE op2);
11694 
11695   format %{ &quot;cmpl    $op1, $op2&quot; %}
11696   opcode(0x3B);  /* Opcode 3B /r */
11697   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11698   ins_pipe(ialu_cr_reg_reg);
11699 %}
11700 
11701 instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11702 %{
11703   match(Set cr (CmpI op1 op2));
11704 
11705   format %{ &quot;cmpl    $op1, $op2&quot; %}
11706   opcode(0x81, 0x07); /* Opcode 81 /7 */
11707   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11708   ins_pipe(ialu_cr_reg_imm);
11709 %}
11710 
11711 instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)
11712 %{
11713   match(Set cr (CmpI op1 (LoadI op2)));
11714 
11715   ins_cost(500); // XXX
11716   format %{ &quot;cmpl    $op1, $op2&quot; %}
11717   opcode(0x3B); /* Opcode 3B /r */
11718   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11719   ins_pipe(ialu_cr_reg_mem);
11720 %}
11721 
11722 instruct testI_reg(rFlagsReg cr, rRegI src, immI0 zero)
11723 %{
11724   match(Set cr (CmpI src zero));
11725 
11726   format %{ &quot;testl   $src, $src&quot; %}
11727   opcode(0x85);
11728   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11729   ins_pipe(ialu_cr_reg_imm);
11730 %}
11731 
11732 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11733 %{
11734   match(Set cr (CmpI (AndI src con) zero));
11735 
11736   format %{ &quot;testl   $src, $con&quot; %}
11737   opcode(0xF7, 0x00);
11738   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11739   ins_pipe(ialu_cr_reg_imm);
11740 %}
11741 
11742 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11743 %{
11744   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11745 
11746   format %{ &quot;testl   $src, $mem&quot; %}
11747   opcode(0x85);
11748   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11749   ins_pipe(ialu_cr_reg_mem);
11750 %}
11751 
11752 // Fold array properties check
11753 instruct testI_mem_imm(rFlagsReg cr, memory mem, immI con, immI0 zero)
11754 %{
11755   match(Set cr (CmpI (AndI (CastN2I (LoadNKlass mem)) con) zero));
11756 
11757   format %{ &quot;testl   $mem, $con&quot; %}
11758   opcode(0xF7, 0x00);
11759   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(con));
11760   ins_pipe(ialu_mem_imm);
11761 %}
11762 
11763 // Clear array property bits
11764 instruct clear_property_bits(rRegN dst, memory mem, immU31 mask, rFlagsReg cr)
11765 %{
11766   match(Set dst (CastI2N (AndI (CastN2I (LoadNKlass mem)) mask)));
11767   effect(KILL cr);
11768 
11769   format %{ &quot;movl    $dst, $mem\t# clear property bits\n\t&quot;
11770             &quot;andl    $dst, $mask&quot; %}
11771   ins_encode %{
11772     __ movl($dst$$Register, $mem$$Address);
11773     __ andl($dst$$Register, $mask$$constant);
11774   %}
11775   ins_pipe(ialu_reg_mem);
11776 %}
11777 
11778 // Unsigned compare Instructions; really, same as signed except they
11779 // produce an rFlagsRegU instead of rFlagsReg.
11780 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11781 %{
11782   match(Set cr (CmpU op1 op2));
11783 
11784   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11785   opcode(0x3B); /* Opcode 3B /r */
11786   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11787   ins_pipe(ialu_cr_reg_reg);
11788 %}
11789 
11790 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11791 %{
11792   match(Set cr (CmpU op1 op2));
11793 
11794   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11795   opcode(0x81,0x07); /* Opcode 81 /7 */
11796   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11797   ins_pipe(ialu_cr_reg_imm);
11798 %}
11799 
11800 instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)
11801 %{
11802   match(Set cr (CmpU op1 (LoadI op2)));
11803 
11804   ins_cost(500); // XXX
11805   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11806   opcode(0x3B); /* Opcode 3B /r */
11807   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11808   ins_pipe(ialu_cr_reg_mem);
11809 %}
11810 
11811 // // // Cisc-spilled version of cmpU_rReg
11812 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
11813 // //%{
11814 // //  match(Set cr (CmpU (LoadI op1) op2));
11815 // //
11816 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11817 // //  ins_cost(500);
11818 // //  opcode(0x39);  /* Opcode 39 /r */
11819 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11820 // //%}
11821 
11822 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
11823 %{
11824   match(Set cr (CmpU src zero));
11825 
11826   format %{ &quot;testl   $src, $src\t# unsigned&quot; %}
11827   opcode(0x85);
11828   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11829   ins_pipe(ialu_cr_reg_imm);
11830 %}
11831 
11832 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
11833 %{
11834   match(Set cr (CmpP op1 op2));
11835 
11836   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11837   opcode(0x3B); /* Opcode 3B /r */
11838   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11839   ins_pipe(ialu_cr_reg_reg);
11840 %}
11841 
11842 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
11843 %{
11844   match(Set cr (CmpP op1 (LoadP op2)));
11845   predicate(n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11846 
11847   ins_cost(500); // XXX
11848   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11849   opcode(0x3B); /* Opcode 3B /r */
11850   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11851   ins_pipe(ialu_cr_reg_mem);
11852 %}
11853 
11854 // // // Cisc-spilled version of cmpP_rReg
11855 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
11856 // //%{
11857 // //  match(Set cr (CmpP (LoadP op1) op2));
11858 // //
11859 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11860 // //  ins_cost(500);
11861 // //  opcode(0x39);  /* Opcode 39 /r */
11862 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11863 // //%}
11864 
11865 // XXX this is generalized by compP_rReg_mem???
11866 // Compare raw pointer (used in out-of-heap check).
11867 // Only works because non-oop pointers must be raw pointers
11868 // and raw pointers have no anti-dependencies.
11869 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
11870 %{
11871   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none &amp;&amp;
11872             n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11873   match(Set cr (CmpP op1 (LoadP op2)));
11874 
11875   format %{ &quot;cmpq    $op1, $op2\t# raw ptr&quot; %}
11876   opcode(0x3B); /* Opcode 3B /r */
11877   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11878   ins_pipe(ialu_cr_reg_mem);
11879 %}
11880 
11881 // This will generate a signed flags result. This should be OK since
11882 // any compare to a zero should be eq/neq.
11883 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
11884 %{
11885   match(Set cr (CmpP src zero));
11886 
11887   format %{ &quot;testq   $src, $src\t# ptr&quot; %}
11888   opcode(0x85);
11889   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11890   ins_pipe(ialu_cr_reg_imm);
11891 %}
11892 
11893 // This will generate a signed flags result. This should be OK since
11894 // any compare to a zero should be eq/neq.
11895 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11896 %{
11897   predicate((!UseCompressedOops || (CompressedOops::base() != NULL)) &amp;&amp;
11898             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11899   match(Set cr (CmpP (LoadP op) zero));
11900 
11901   ins_cost(500); // XXX
11902   format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
11903   opcode(0xF7); /* Opcode F7 /0 */
11904   ins_encode(REX_mem_wide(op),
11905              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11906   ins_pipe(ialu_cr_reg_imm);
11907 %}
11908 
11909 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11910 %{
11911   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp;
11912             (CompressedKlassPointers::base() == NULL) &amp;&amp;
11913             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11914   match(Set cr (CmpP (LoadP mem) zero));
11915 
11916   format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
11917   ins_encode %{
11918     __ cmpq(r12, $mem$$Address);
11919   %}
11920   ins_pipe(ialu_cr_reg_mem);
11921 %}
11922 
11923 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11924 %{
11925   match(Set cr (CmpN op1 op2));
11926 
11927   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11928   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11929   ins_pipe(ialu_cr_reg_reg);
11930 %}
11931 
11932 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
11933 %{
11934   match(Set cr (CmpN src (LoadN mem)));
11935 
11936   format %{ &quot;cmpl    $src, $mem\t# compressed ptr&quot; %}
11937   ins_encode %{
11938     __ cmpl($src$$Register, $mem$$Address);
11939   %}
11940   ins_pipe(ialu_cr_reg_mem);
11941 %}
11942 
11943 instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{
11944   match(Set cr (CmpN op1 op2));
11945 
11946   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11947   ins_encode %{
11948     __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);
11949   %}
11950   ins_pipe(ialu_cr_reg_imm);
11951 %}
11952 
11953 instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)
11954 %{
11955   match(Set cr (CmpN src (LoadN mem)));
11956 
11957   format %{ &quot;cmpl    $mem, $src\t# compressed ptr&quot; %}
11958   ins_encode %{
11959     __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);
11960   %}
11961   ins_pipe(ialu_cr_reg_mem);
11962 %}
11963 
11964 instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{
11965   match(Set cr (CmpN op1 op2));
11966 
11967   format %{ &quot;cmpl    $op1, $op2\t# compressed klass ptr&quot; %}
11968   ins_encode %{
11969     __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);
11970   %}
11971   ins_pipe(ialu_cr_reg_imm);
11972 %}
11973 
11974 instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)
11975 %{
11976   match(Set cr (CmpN src (LoadNKlass mem)));
11977 
11978   format %{ &quot;cmpl    $mem, $src\t# compressed klass ptr&quot; %}
11979   ins_encode %{
11980     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
11981   %}
11982   ins_pipe(ialu_cr_reg_mem);
11983 %}
11984 
11985 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
11986   match(Set cr (CmpN src zero));
11987 
11988   format %{ &quot;testl   $src, $src\t# compressed ptr&quot; %}
11989   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
11990   ins_pipe(ialu_cr_reg_imm);
11991 %}
11992 
11993 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
11994 %{
11995   predicate(CompressedOops::base() != NULL);
11996   match(Set cr (CmpN (LoadN mem) zero));
11997 
11998   ins_cost(500); // XXX
11999   format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
12000   ins_encode %{
12001     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
12002   %}
12003   ins_pipe(ialu_cr_reg_mem);
12004 %}
12005 
12006 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
12007 %{
12008   predicate(CompressedOops::base() == NULL &amp;&amp; (CompressedKlassPointers::base() == NULL));
12009   match(Set cr (CmpN (LoadN mem) zero));
12010 
12011   format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
12012   ins_encode %{
12013     __ cmpl(r12, $mem$$Address);
12014   %}
12015   ins_pipe(ialu_cr_reg_mem);
12016 %}
12017 
12018 // Yanked all unsigned pointer compare operations.
12019 // Pointer compares are done with CmpP which is already unsigned.
12020 
12021 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
12022 %{
12023   match(Set cr (CmpL op1 op2));
12024 
12025   format %{ &quot;cmpq    $op1, $op2&quot; %}
12026   opcode(0x3B);  /* Opcode 3B /r */
12027   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
12028   ins_pipe(ialu_cr_reg_reg);
12029 %}
12030 
12031 instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
12032 %{
12033   match(Set cr (CmpL op1 op2));
12034 
12035   format %{ &quot;cmpq    $op1, $op2&quot; %}
12036   opcode(0x81, 0x07); /* Opcode 81 /7 */
12037   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
12038   ins_pipe(ialu_cr_reg_imm);
12039 %}
12040 
12041 instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)
12042 %{
12043   match(Set cr (CmpL op1 (LoadL op2)));
12044 
12045   format %{ &quot;cmpq    $op1, $op2&quot; %}
12046   opcode(0x3B); /* Opcode 3B /r */
12047   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
12048   ins_pipe(ialu_cr_reg_mem);
12049 %}
12050 
12051 instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)
12052 %{
12053   match(Set cr (CmpL src zero));
12054 
12055   format %{ &quot;testq   $src, $src&quot; %}
12056   opcode(0x85);
12057   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
12058   ins_pipe(ialu_cr_reg_imm);
12059 %}
12060 
12061 instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)
12062 %{
12063   match(Set cr (CmpL (AndL src con) zero));
12064 
12065   format %{ &quot;testq   $src, $con\t# long&quot; %}
12066   opcode(0xF7, 0x00);
12067   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));
12068   ins_pipe(ialu_cr_reg_imm);
12069 %}
12070 
12071 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
12072 %{
12073   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
12074 
12075   format %{ &quot;testq   $src, $mem&quot; %}
12076   opcode(0x85);
12077   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12078   ins_pipe(ialu_cr_reg_mem);
12079 %}
12080 
12081 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
12082 %{
12083   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
12084 
12085   format %{ &quot;testq   $src, $mem&quot; %}
12086   opcode(0x85);
12087   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12088   ins_pipe(ialu_cr_reg_mem);
12089 %}
12090 
12091 // Fold array properties check
12092 instruct testL_reg_mem3(rFlagsReg cr, memory mem, rRegL src, immL0 zero)
12093 %{
12094   match(Set cr (CmpL (AndL (CastP2X (LoadKlass mem)) src) zero));
12095 
12096   format %{ &quot;testq   $src, $mem\t# test array properties&quot; %}
12097   opcode(0x85);
12098   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12099   ins_pipe(ialu_cr_reg_mem);
12100 %}
12101 
12102 // Manifest a CmpL result in an integer register.  Very painful.
12103 // This is the test to avoid.
12104 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
12105 %{
12106   match(Set dst (CmpL3 src1 src2));
12107   effect(KILL flags);
12108 
12109   ins_cost(275); // XXX
12110   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
12111             &quot;movl    $dst, -1\n\t&quot;
12112             &quot;jl,s    done\n\t&quot;
12113             &quot;setne   $dst\n\t&quot;
12114             &quot;movzbl  $dst, $dst\n\t&quot;
12115     &quot;done:&quot; %}
12116   ins_encode(cmpl3_flag(src1, src2, dst));
12117   ins_pipe(pipe_slow);
12118 %}
12119 
12120 // Unsigned long compare Instructions; really, same as signed long except they
12121 // produce an rFlagsRegU instead of rFlagsReg.
12122 instruct compUL_rReg(rFlagsRegU cr, rRegL op1, rRegL op2)
12123 %{
12124   match(Set cr (CmpUL op1 op2));
12125 
12126   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
12127   opcode(0x3B);  /* Opcode 3B /r */
12128   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
12129   ins_pipe(ialu_cr_reg_reg);
12130 %}
12131 
12132 instruct compUL_rReg_imm(rFlagsRegU cr, rRegL op1, immL32 op2)
12133 %{
12134   match(Set cr (CmpUL op1 op2));
12135 
12136   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
12137   opcode(0x81, 0x07); /* Opcode 81 /7 */
12138   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
12139   ins_pipe(ialu_cr_reg_imm);
12140 %}
12141 
12142 instruct compUL_rReg_mem(rFlagsRegU cr, rRegL op1, memory op2)
12143 %{
12144   match(Set cr (CmpUL op1 (LoadL op2)));
12145 
12146   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
12147   opcode(0x3B); /* Opcode 3B /r */
12148   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
12149   ins_pipe(ialu_cr_reg_mem);
12150 %}
12151 
12152 instruct testUL_reg(rFlagsRegU cr, rRegL src, immL0 zero)
12153 %{
12154   match(Set cr (CmpUL src zero));
12155 
12156   format %{ &quot;testq   $src, $src\t# unsigned&quot; %}
12157   opcode(0x85);
12158   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
12159   ins_pipe(ialu_cr_reg_imm);
12160 %}
12161 
12162 instruct compB_mem_imm(rFlagsReg cr, memory mem, immI8 imm)
12163 %{
12164   match(Set cr (CmpI (LoadB mem) imm));
12165 
12166   ins_cost(125);
12167   format %{ &quot;cmpb    $mem, $imm&quot; %}
12168   ins_encode %{ __ cmpb($mem$$Address, $imm$$constant); %}
12169   ins_pipe(ialu_cr_reg_mem);
12170 %}
12171 
12172 instruct testUB_mem_imm(rFlagsReg cr, memory mem, immU8 imm, immI0 zero)
12173 %{
12174   match(Set cr (CmpI (AndI (LoadUB mem) imm) zero));
12175 
12176   ins_cost(125);
12177   format %{ &quot;testb   $mem, $imm\t# ubyte&quot; %}
12178   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
12179   ins_pipe(ialu_cr_reg_mem);
12180 %}
12181 
12182 instruct testB_mem_imm(rFlagsReg cr, memory mem, immI8 imm, immI0 zero)
12183 %{
12184   match(Set cr (CmpI (AndI (LoadB mem) imm) zero));
12185 
12186   ins_cost(125);
12187   format %{ &quot;testb   $mem, $imm\t# byte&quot; %}
12188   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
12189   ins_pipe(ialu_cr_reg_mem);
12190 %}
12191 
12192 //----------Max and Min--------------------------------------------------------
12193 // Min Instructions
12194 
12195 instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)
12196 %{
12197   effect(USE_DEF dst, USE src, USE cr);
12198 
12199   format %{ &quot;cmovlgt $dst, $src\t# min&quot; %}
12200   opcode(0x0F, 0x4F);
12201   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12202   ins_pipe(pipe_cmov_reg);
12203 %}
12204 
12205 
12206 instruct minI_rReg(rRegI dst, rRegI src)
12207 %{
12208   match(Set dst (MinI dst src));
12209 
12210   ins_cost(200);
12211   expand %{
12212     rFlagsReg cr;
12213     compI_rReg(cr, dst, src);
12214     cmovI_reg_g(dst, src, cr);
12215   %}
12216 %}
12217 
12218 instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)
12219 %{
12220   effect(USE_DEF dst, USE src, USE cr);
12221 
12222   format %{ &quot;cmovllt $dst, $src\t# max&quot; %}
12223   opcode(0x0F, 0x4C);
12224   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12225   ins_pipe(pipe_cmov_reg);
12226 %}
12227 
12228 
12229 instruct maxI_rReg(rRegI dst, rRegI src)
12230 %{
12231   match(Set dst (MaxI dst src));
12232 
12233   ins_cost(200);
12234   expand %{
12235     rFlagsReg cr;
12236     compI_rReg(cr, dst, src);
12237     cmovI_reg_l(dst, src, cr);
12238   %}
12239 %}
12240 
12241 // ============================================================================
12242 // Branch Instructions
12243 
12244 // Jump Direct - Label defines a relative address from JMP+1
12245 instruct jmpDir(label labl)
12246 %{
12247   match(Goto);
12248   effect(USE labl);
12249 
12250   ins_cost(300);
12251   format %{ &quot;jmp     $labl&quot; %}
12252   size(5);
12253   ins_encode %{
12254     Label* L = $labl$$label;
12255     __ jmp(*L, false); // Always long jump
12256   %}
12257   ins_pipe(pipe_jmp);
12258 %}
12259 
12260 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12261 instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)
12262 %{
12263   match(If cop cr);
12264   effect(USE labl);
12265 
12266   ins_cost(300);
12267   format %{ &quot;j$cop     $labl&quot; %}
12268   size(6);
12269   ins_encode %{
12270     Label* L = $labl$$label;
12271     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12272   %}
12273   ins_pipe(pipe_jcc);
12274 %}
12275 
12276 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12277 instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)
12278 %{
12279   predicate(!n-&gt;has_vector_mask_set());
12280   match(CountedLoopEnd cop cr);
12281   effect(USE labl);
12282 
12283   ins_cost(300);
12284   format %{ &quot;j$cop     $labl\t# loop end&quot; %}
12285   size(6);
12286   ins_encode %{
12287     Label* L = $labl$$label;
12288     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12289   %}
12290   ins_pipe(pipe_jcc);
12291 %}
12292 
12293 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12294 instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12295   predicate(!n-&gt;has_vector_mask_set());
12296   match(CountedLoopEnd cop cmp);
12297   effect(USE labl);
12298 
12299   ins_cost(300);
12300   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12301   size(6);
12302   ins_encode %{
12303     Label* L = $labl$$label;
12304     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12305   %}
12306   ins_pipe(pipe_jcc);
12307 %}
12308 
12309 instruct jmpLoopEndUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12310   predicate(!n-&gt;has_vector_mask_set());
12311   match(CountedLoopEnd cop cmp);
12312   effect(USE labl);
12313 
12314   ins_cost(200);
12315   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12316   size(6);
12317   ins_encode %{
12318     Label* L = $labl$$label;
12319     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12320   %}
12321   ins_pipe(pipe_jcc);
12322 %}
12323 
12324 // mask version
12325 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12326 instruct jmpLoopEnd_and_restoreMask(cmpOp cop, rFlagsReg cr, label labl)
12327 %{
12328   predicate(n-&gt;has_vector_mask_set());
12329   match(CountedLoopEnd cop cr);
12330   effect(USE labl);
12331 
12332   ins_cost(400);
12333   format %{ &quot;j$cop     $labl\t# loop end\n\t&quot;
12334             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12335   size(10);
12336   ins_encode %{
12337     Label* L = $labl$$label;
12338     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12339     __ restorevectmask();
12340   %}
12341   ins_pipe(pipe_jcc);
12342 %}
12343 
12344 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12345 instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12346   predicate(n-&gt;has_vector_mask_set());
12347   match(CountedLoopEnd cop cmp);
12348   effect(USE labl);
12349 
12350   ins_cost(400);
12351   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12352             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12353   size(10);
12354   ins_encode %{
12355     Label* L = $labl$$label;
12356     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12357     __ restorevectmask();
12358   %}
12359   ins_pipe(pipe_jcc);
12360 %}
12361 
12362 instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12363   predicate(n-&gt;has_vector_mask_set());
12364   match(CountedLoopEnd cop cmp);
12365   effect(USE labl);
12366 
12367   ins_cost(300);
12368   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12369             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12370   size(10);
12371   ins_encode %{
12372     Label* L = $labl$$label;
12373     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12374     __ restorevectmask();
12375   %}
12376   ins_pipe(pipe_jcc);
12377 %}
12378 
12379 // Jump Direct Conditional - using unsigned comparison
12380 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12381   match(If cop cmp);
12382   effect(USE labl);
12383 
12384   ins_cost(300);
12385   format %{ &quot;j$cop,u   $labl&quot; %}
12386   size(6);
12387   ins_encode %{
12388     Label* L = $labl$$label;
12389     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12390   %}
12391   ins_pipe(pipe_jcc);
12392 %}
12393 
12394 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12395   match(If cop cmp);
12396   effect(USE labl);
12397 
12398   ins_cost(200);
12399   format %{ &quot;j$cop,u   $labl&quot; %}
12400   size(6);
12401   ins_encode %{
12402     Label* L = $labl$$label;
12403     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12404   %}
12405   ins_pipe(pipe_jcc);
12406 %}
12407 
12408 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12409   match(If cop cmp);
12410   effect(USE labl);
12411 
12412   ins_cost(200);
12413   format %{ $$template
12414     if ($cop$$cmpcode == Assembler::notEqual) {
12415       $$emit$$&quot;jp,u    $labl\n\t&quot;
12416       $$emit$$&quot;j$cop,u   $labl&quot;
12417     } else {
12418       $$emit$$&quot;jp,u    done\n\t&quot;
12419       $$emit$$&quot;j$cop,u   $labl\n\t&quot;
12420       $$emit$$&quot;done:&quot;
12421     }
12422   %}
12423   ins_encode %{
12424     Label* l = $labl$$label;
12425     if ($cop$$cmpcode == Assembler::notEqual) {
12426       __ jcc(Assembler::parity, *l, false);
12427       __ jcc(Assembler::notEqual, *l, false);
12428     } else if ($cop$$cmpcode == Assembler::equal) {
12429       Label done;
12430       __ jccb(Assembler::parity, done);
12431       __ jcc(Assembler::equal, *l, false);
12432       __ bind(done);
12433     } else {
12434        ShouldNotReachHere();
12435     }
12436   %}
12437   ins_pipe(pipe_jcc);
12438 %}
12439 
12440 // ============================================================================
12441 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary
12442 // superklass array for an instance of the superklass.  Set a hidden
12443 // internal cache on a hit (cache is checked with exposed code in
12444 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
12445 // encoding ALSO sets flags.
12446 
12447 instruct partialSubtypeCheck(rdi_RegP result,
12448                              rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12449                              rFlagsReg cr)
12450 %{
12451   match(Set result (PartialSubtypeCheck sub super));
12452   effect(KILL rcx, KILL cr);
12453 
12454   ins_cost(1100);  // slightly larger than the next version
12455   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12456             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12457             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12458             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while rcx--\n\t&quot;
12459             &quot;jne,s   miss\t\t# Missed: rdi not-zero\n\t&quot;
12460             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12461             &quot;xorq    $result, $result\t\t Hit: rdi zero\n\t&quot;
12462     &quot;miss:\t&quot; %}
12463 
12464   opcode(0x1); // Force a XOR of RDI
12465   ins_encode(enc_PartialSubtypeCheck());
12466   ins_pipe(pipe_slow);
12467 %}
12468 
12469 instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,
12470                                      rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12471                                      immP0 zero,
12472                                      rdi_RegP result)
12473 %{
12474   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
12475   effect(KILL rcx, KILL result);
12476 
12477   ins_cost(1000);
12478   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12479             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12480             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12481             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t&quot;
12482             &quot;jne,s   miss\t\t# Missed: flags nz\n\t&quot;
12483             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12484     &quot;miss:\t&quot; %}
12485 
12486   opcode(0x0); // No need to XOR RDI
12487   ins_encode(enc_PartialSubtypeCheck());
12488   ins_pipe(pipe_slow);
12489 %}
12490 
12491 // ============================================================================
12492 // Branch Instructions -- short offset versions
12493 //
12494 // These instructions are used to replace jumps of a long offset (the default
12495 // match) with jumps of a shorter offset.  These instructions are all tagged
12496 // with the ins_short_branch attribute, which causes the ADLC to suppress the
12497 // match rules in general matching.  Instead, the ADLC generates a conversion
12498 // method in the MachNode which can be used to do in-place replacement of the
12499 // long variant with the shorter variant.  The compiler will determine if a
12500 // branch can be taken by the is_short_branch_offset() predicate in the machine
12501 // specific code section of the file.
12502 
12503 // Jump Direct - Label defines a relative address from JMP+1
12504 instruct jmpDir_short(label labl) %{
12505   match(Goto);
12506   effect(USE labl);
12507 
12508   ins_cost(300);
12509   format %{ &quot;jmp,s   $labl&quot; %}
12510   size(2);
12511   ins_encode %{
12512     Label* L = $labl$$label;
12513     __ jmpb(*L);
12514   %}
12515   ins_pipe(pipe_jmp);
12516   ins_short_branch(1);
12517 %}
12518 
12519 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12520 instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{
12521   match(If cop cr);
12522   effect(USE labl);
12523 
12524   ins_cost(300);
12525   format %{ &quot;j$cop,s   $labl&quot; %}
12526   size(2);
12527   ins_encode %{
12528     Label* L = $labl$$label;
12529     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12530   %}
12531   ins_pipe(pipe_jcc);
12532   ins_short_branch(1);
12533 %}
12534 
12535 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12536 instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{
12537   match(CountedLoopEnd cop cr);
12538   effect(USE labl);
12539 
12540   ins_cost(300);
12541   format %{ &quot;j$cop,s   $labl\t# loop end&quot; %}
12542   size(2);
12543   ins_encode %{
12544     Label* L = $labl$$label;
12545     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12546   %}
12547   ins_pipe(pipe_jcc);
12548   ins_short_branch(1);
12549 %}
12550 
12551 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12552 instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12553   match(CountedLoopEnd cop cmp);
12554   effect(USE labl);
12555 
12556   ins_cost(300);
12557   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12558   size(2);
12559   ins_encode %{
12560     Label* L = $labl$$label;
12561     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12562   %}
12563   ins_pipe(pipe_jcc);
12564   ins_short_branch(1);
12565 %}
12566 
12567 instruct jmpLoopEndUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12568   match(CountedLoopEnd cop cmp);
12569   effect(USE labl);
12570 
12571   ins_cost(300);
12572   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12573   size(2);
12574   ins_encode %{
12575     Label* L = $labl$$label;
12576     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12577   %}
12578   ins_pipe(pipe_jcc);
12579   ins_short_branch(1);
12580 %}
12581 
12582 // Jump Direct Conditional - using unsigned comparison
12583 instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12584   match(If cop cmp);
12585   effect(USE labl);
12586 
12587   ins_cost(300);
12588   format %{ &quot;j$cop,us  $labl&quot; %}
12589   size(2);
12590   ins_encode %{
12591     Label* L = $labl$$label;
12592     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12593   %}
12594   ins_pipe(pipe_jcc);
12595   ins_short_branch(1);
12596 %}
12597 
12598 instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12599   match(If cop cmp);
12600   effect(USE labl);
12601 
12602   ins_cost(300);
12603   format %{ &quot;j$cop,us  $labl&quot; %}
12604   size(2);
12605   ins_encode %{
12606     Label* L = $labl$$label;
12607     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12608   %}
12609   ins_pipe(pipe_jcc);
12610   ins_short_branch(1);
12611 %}
12612 
12613 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12614   match(If cop cmp);
12615   effect(USE labl);
12616 
12617   ins_cost(300);
12618   format %{ $$template
12619     if ($cop$$cmpcode == Assembler::notEqual) {
12620       $$emit$$&quot;jp,u,s  $labl\n\t&quot;
12621       $$emit$$&quot;j$cop,u,s  $labl&quot;
12622     } else {
12623       $$emit$$&quot;jp,u,s  done\n\t&quot;
12624       $$emit$$&quot;j$cop,u,s  $labl\n\t&quot;
12625       $$emit$$&quot;done:&quot;
12626     }
12627   %}
12628   size(4);
12629   ins_encode %{
12630     Label* l = $labl$$label;
12631     if ($cop$$cmpcode == Assembler::notEqual) {
12632       __ jccb(Assembler::parity, *l);
12633       __ jccb(Assembler::notEqual, *l);
12634     } else if ($cop$$cmpcode == Assembler::equal) {
12635       Label done;
12636       __ jccb(Assembler::parity, done);
12637       __ jccb(Assembler::equal, *l);
12638       __ bind(done);
12639     } else {
12640        ShouldNotReachHere();
12641     }
12642   %}
12643   ins_pipe(pipe_jcc);
12644   ins_short_branch(1);
12645 %}
12646 
12647 // ============================================================================
12648 // inlined locking and unlocking
12649 
12650 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
12651   predicate(Compile::current()-&gt;use_rtm());
12652   match(Set cr (FastLock object box));
12653   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
12654   ins_cost(300);
12655   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
12656   ins_encode %{
12657     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12658                  $scr$$Register, $cx1$$Register, $cx2$$Register,
12659                  _counters, _rtm_counters, _stack_rtm_counters,
12660                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12661                  true, ra_-&gt;C-&gt;profile_rtm());
12662   %}
12663   ins_pipe(pipe_slow);
12664 %}
12665 
12666 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{
12667   predicate(!Compile::current()-&gt;use_rtm());
12668   match(Set cr (FastLock object box));
12669   effect(TEMP tmp, TEMP scr, USE_KILL box);
12670   ins_cost(300);
12671   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr&quot; %}
12672   ins_encode %{
12673     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12674                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
12675   %}
12676   ins_pipe(pipe_slow);
12677 %}
12678 
12679 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12680   match(Set cr (FastUnlock object box));
12681   effect(TEMP tmp, USE_KILL box);
12682   ins_cost(300);
12683   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12684   ins_encode %{
12685     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12686   %}
12687   ins_pipe(pipe_slow);
12688 %}
12689 
12690 
12691 // ============================================================================
12692 // Safepoint Instructions
12693 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12694 %{
12695   match(SafePoint poll);
12696   effect(KILL cr, USE poll);
12697 
12698   format %{ &quot;testl   rax, [$poll]\t&quot;
12699             &quot;# Safepoint: poll for GC&quot; %}
12700   ins_cost(125);
12701   size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
12702   ins_encode %{
12703     __ relocate(relocInfo::poll_type);
12704     address pre_pc = __ pc();
12705     __ testl(rax, Address($poll$$Register, 0));
12706     assert(nativeInstruction_at(pre_pc)-&gt;is_safepoint_poll(), &quot;must emit test %%eax [reg]&quot;);
12707   %}
12708   ins_pipe(ialu_reg_mem);
12709 %}
12710 
12711 // ============================================================================
12712 // Procedure Call/Return Instructions
12713 // Call Java Static Instruction
12714 // Note: If this code changes, the corresponding ret_addr_offset() and
12715 //       compute_padding() functions will have to be adjusted.
12716 instruct CallStaticJavaDirect(method meth) %{
12717   match(CallStaticJava);
12718   effect(USE meth);
12719 
12720   ins_cost(300);
12721   format %{ &quot;call,static &quot; %}
12722   opcode(0xE8); /* E8 cd */
12723   ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);
12724   ins_pipe(pipe_slow);
12725   ins_alignment(4);
12726 %}
12727 
12728 // Call Java Dynamic Instruction
12729 // Note: If this code changes, the corresponding ret_addr_offset() and
12730 //       compute_padding() functions will have to be adjusted.
12731 instruct CallDynamicJavaDirect(method meth)
12732 %{
12733   match(CallDynamicJava);
12734   effect(USE meth);
12735 
12736   ins_cost(300);
12737   format %{ &quot;movq    rax, #Universe::non_oop_word()\n\t&quot;
12738             &quot;call,dynamic &quot; %}
12739   ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);
12740   ins_pipe(pipe_slow);
12741   ins_alignment(4);
12742 %}
12743 
12744 // Call Runtime Instruction
12745 instruct CallRuntimeDirect(method meth)
12746 %{
12747   match(CallRuntime);
12748   effect(USE meth);
12749 
12750   ins_cost(300);
12751   format %{ &quot;call,runtime &quot; %}
12752   ins_encode(clear_avx, Java_To_Runtime(meth));
12753   ins_pipe(pipe_slow);
12754 %}
12755 
12756 // Call runtime without safepoint
12757 instruct CallLeafDirect(method meth)
12758 %{
12759   match(CallLeaf);
12760   effect(USE meth);
12761 
12762   ins_cost(300);
12763   format %{ &quot;call_leaf,runtime &quot; %}
12764   ins_encode(clear_avx, Java_To_Runtime(meth));
12765   ins_pipe(pipe_slow);
12766 %}
12767 
12768 // Call runtime without safepoint
12769 // entry point is null, target holds the address to call
12770 instruct CallLeafNoFPInDirect(rRegP target)
12771 %{
12772   predicate(n-&gt;as_Call()-&gt;entry_point() == NULL);
12773   match(CallLeafNoFP target);
12774 
12775   ins_cost(300);
12776   format %{ &quot;call_leaf_nofp,runtime indirect &quot; %}
12777   ins_encode %{
12778      __ call($target$$Register);
12779   %}
12780 
12781   ins_pipe(pipe_slow);
12782 %}
12783 
12784 instruct CallLeafNoFPDirect(method meth)
12785 %{
12786   predicate(n-&gt;as_Call()-&gt;entry_point() != NULL);
12787   match(CallLeafNoFP);
12788   effect(USE meth);
12789 
12790   ins_cost(300);
12791   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12792   ins_encode(clear_avx, Java_To_Runtime(meth));
12793   ins_pipe(pipe_slow);
12794 %}
12795 
12796 // Return Instruction
12797 // Remove the return address &amp; jump to it.
12798 // Notice: We always emit a nop after a ret to make sure there is room
12799 // for safepoint patching
12800 instruct Ret()
12801 %{
12802   match(Return);
12803 
12804   format %{ &quot;ret&quot; %}
12805   opcode(0xC3);
12806   ins_encode(OpcP);
12807   ins_pipe(pipe_jmp);
12808 %}
12809 
12810 // Tail Call; Jump from runtime stub to Java code.
12811 // Also known as an &#39;interprocedural jump&#39;.
12812 // Target of jump will eventually return to caller.
12813 // TailJump below removes the return address.
12814 instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_oop)
12815 %{
12816   match(TailCall jump_target method_oop);
12817 
12818   ins_cost(300);
12819   format %{ &quot;jmp     $jump_target\t# rbx holds method oop&quot; %}
12820   opcode(0xFF, 0x4); /* Opcode FF /4 */
12821   ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
12822   ins_pipe(pipe_jmp);
12823 %}
12824 
12825 // Tail Jump; remove the return address; jump to target.
12826 // TailCall above leaves the return address around.
12827 instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)
12828 %{
12829   match(TailJump jump_target ex_oop);
12830 
12831   ins_cost(300);
12832   format %{ &quot;popq    rdx\t# pop return address\n\t&quot;
12833             &quot;jmp     $jump_target&quot; %}
12834   opcode(0xFF, 0x4); /* Opcode FF /4 */
12835   ins_encode(Opcode(0x5a), // popq rdx
12836              REX_reg(jump_target), OpcP, reg_opc(jump_target));
12837   ins_pipe(pipe_jmp);
12838 %}
12839 
12840 // Create exception oop: created by stack-crawling runtime code.
12841 // Created exception is now available to this handler, and is setup
12842 // just prior to jumping to this handler.  No code emitted.
12843 instruct CreateException(rax_RegP ex_oop)
12844 %{
12845   match(Set ex_oop (CreateEx));
12846 
12847   size(0);
12848   // use the following format syntax
12849   format %{ &quot;# exception oop is in rax; no code emitted&quot; %}
12850   ins_encode();
12851   ins_pipe(empty);
12852 %}
12853 
12854 // Rethrow exception:
12855 // The exception oop will come in the first argument position.
12856 // Then JUMP (not call) to the rethrow stub code.
12857 instruct RethrowException()
12858 %{
12859   match(Rethrow);
12860 
12861   // use the following format syntax
12862   format %{ &quot;jmp     rethrow_stub&quot; %}
12863   ins_encode(enc_rethrow);
12864   ins_pipe(pipe_jmp);
12865 %}
12866 
12867 // ============================================================================
12868 // This name is KNOWN by the ADLC and cannot be changed.
12869 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
12870 // for this guy.
12871 instruct tlsLoadP(r15_RegP dst) %{
12872   match(Set dst (ThreadLocal));
12873   effect(DEF dst);
12874 
12875   size(0);
12876   format %{ &quot;# TLS is in R15&quot; %}
12877   ins_encode( /*empty encoding*/ );
12878   ins_pipe(ialu_reg_reg);
12879 %}
12880 
12881 
12882 //----------PEEPHOLE RULES-----------------------------------------------------
12883 // These must follow all instruction definitions as they use the names
12884 // defined in the instructions definitions.
12885 //
12886 // peepmatch ( root_instr_name [preceding_instruction]* );
12887 //
12888 // peepconstraint %{
12889 // (instruction_number.operand_name relational_op instruction_number.operand_name
12890 //  [, ...] );
12891 // // instruction numbers are zero-based using left to right order in peepmatch
12892 //
12893 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
12894 // // provide an instruction_number.operand_name for each operand that appears
12895 // // in the replacement instruction&#39;s match rule
12896 //
12897 // ---------VM FLAGS---------------------------------------------------------
12898 //
12899 // All peephole optimizations can be turned off using -XX:-OptoPeephole
12900 //
12901 // Each peephole rule is given an identifying number starting with zero and
12902 // increasing by one in the order seen by the parser.  An individual peephole
12903 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
12904 // on the command-line.
12905 //
12906 // ---------CURRENT LIMITATIONS----------------------------------------------
12907 //
12908 // Only match adjacent instructions in same basic block
12909 // Only equality constraints
12910 // Only constraints between operands, not (0.dest_reg == RAX_enc)
12911 // Only one replacement instruction
12912 //
12913 // ---------EXAMPLE----------------------------------------------------------
12914 //
12915 // // pertinent parts of existing instructions in architecture description
12916 // instruct movI(rRegI dst, rRegI src)
12917 // %{
12918 //   match(Set dst (CopyI src));
12919 // %}
12920 //
12921 // instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
12922 // %{
12923 //   match(Set dst (AddI dst src));
12924 //   effect(KILL cr);
12925 // %}
12926 //
12927 // // Change (inc mov) to lea
12928 // peephole %{
12929 //   // increment preceeded by register-register move
12930 //   peepmatch ( incI_rReg movI );
12931 //   // require that the destination register of the increment
12932 //   // match the destination register of the move
12933 //   peepconstraint ( 0.dst == 1.dst );
12934 //   // construct a replacement instruction that sets
12935 //   // the destination to ( move&#39;s source register + one )
12936 //   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );
12937 // %}
12938 //
12939 
12940 // Implementation no longer uses movX instructions since
12941 // machine-independent system no longer uses CopyX nodes.
12942 //
12943 // peephole
12944 // %{
12945 //   peepmatch (incI_rReg movI);
12946 //   peepconstraint (0.dst == 1.dst);
12947 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12948 // %}
12949 
12950 // peephole
12951 // %{
12952 //   peepmatch (decI_rReg movI);
12953 //   peepconstraint (0.dst == 1.dst);
12954 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12955 // %}
12956 
12957 // peephole
12958 // %{
12959 //   peepmatch (addI_rReg_imm movI);
12960 //   peepconstraint (0.dst == 1.dst);
12961 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12962 // %}
12963 
12964 // peephole
12965 // %{
12966 //   peepmatch (incL_rReg movL);
12967 //   peepconstraint (0.dst == 1.dst);
12968 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12969 // %}
12970 
12971 // peephole
12972 // %{
12973 //   peepmatch (decL_rReg movL);
12974 //   peepconstraint (0.dst == 1.dst);
12975 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12976 // %}
12977 
12978 // peephole
12979 // %{
12980 //   peepmatch (addL_rReg_imm movL);
12981 //   peepconstraint (0.dst == 1.dst);
12982 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12983 // %}
12984 
12985 // peephole
12986 // %{
12987 //   peepmatch (addP_rReg_imm movP);
12988 //   peepconstraint (0.dst == 1.dst);
12989 //   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));
12990 // %}
12991 
12992 // // Change load of spilled value to only a spill
12993 // instruct storeI(memory mem, rRegI src)
12994 // %{
12995 //   match(Set mem (StoreI mem src));
12996 // %}
12997 //
12998 // instruct loadI(rRegI dst, memory mem)
12999 // %{
13000 //   match(Set dst (LoadI mem));
13001 // %}
13002 //
13003 
13004 peephole
13005 %{
13006   peepmatch (loadI storeI);
13007   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
13008   peepreplace (storeI(1.mem 1.mem 1.src));
13009 %}
13010 
13011 peephole
13012 %{
13013   peepmatch (loadL storeL);
13014   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
13015   peepreplace (storeL(1.mem 1.mem 1.src));
13016 %}
13017 
13018 //----------SMARTSPILL RULES---------------------------------------------------
13019 // These must follow all instruction definitions as they use the names
13020 // defined in the instructions definitions.
    </pre>
  </body>
</html>
diff a/src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp b/src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp
--- a/src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp
+++ b/src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp
@@ -1398,11 +1398,10 @@
     // Load barrier has not yet been applied, so ZGC can't verify the oop here
     if (!UseZGC) {
       __ verify_oop(dest->as_register());
     }
   } else if (type == T_ADDRESS && addr->disp() == oopDesc::klass_offset_in_bytes()) {
-    // TODO remove clear_prop_bits bits stuff once the runtime does not set it anymore
 #ifdef _LP64
     if (UseCompressedClassPointers) {
       __ decode_klass_not_null(dest->as_register());
     }
 #endif
diff a/src/hotspot/cpu/x86/x86_64.ad b/src/hotspot/cpu/x86/x86_64.ad
--- a/src/hotspot/cpu/x86/x86_64.ad
+++ b/src/hotspot/cpu/x86/x86_64.ad
@@ -11758,25 +11758,10 @@
   opcode(0xF7, 0x00);
   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(con));
   ins_pipe(ialu_mem_imm);
 %}
 
-// Clear array property bits
-instruct clear_property_bits(rRegN dst, memory mem, immU31 mask, rFlagsReg cr)
-%{
-  match(Set dst (CastI2N (AndI (CastN2I (LoadNKlass mem)) mask)));
-  effect(KILL cr);
-
-  format %{ "movl    $dst, $mem\t# clear property bits\n\t"
-            "andl    $dst, $mask" %}
-  ins_encode %{
-    __ movl($dst$$Register, $mem$$Address);
-    __ andl($dst$$Register, $mask$$constant);
-  %}
-  ins_pipe(ialu_reg_mem);
-%}
-
 // Unsigned compare Instructions; really, same as signed except they
 // produce an rFlagsRegU instead of rFlagsReg.
 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
 %{
   match(Set cr (CmpU op1 op2));
diff a/src/hotspot/share/opto/graphKit.cpp b/src/hotspot/share/opto/graphKit.cpp
--- a/src/hotspot/share/opto/graphKit.cpp
+++ b/src/hotspot/share/opto/graphKit.cpp
@@ -1175,17 +1175,16 @@
   }
   return _gvn.transform( new ConvL2INode(offset));
 }
 
 //-------------------------load_object_klass-----------------------------------
-Node* GraphKit::load_object_klass(Node* obj, bool clear_prop_bits) {
+Node* GraphKit::load_object_klass(Node* obj) {
   // Special-case a fresh allocation to avoid building nodes:
   Node* akls = AllocateNode::Ideal_klass(obj, &_gvn);
   if (akls != NULL)  return akls;
   Node* k_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());
-  // TODO remove clear_prop_bits bits stuff once the runtime does not set it anymore
-  return _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT, clear_prop_bits));
+  return _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));
 }
 
 //-------------------------load_array_length-----------------------------------
 Node* GraphKit::load_array_length(Node* array) {
   // Special-case a fresh allocation to avoid building nodes:
diff a/src/hotspot/share/opto/graphKit.hpp b/src/hotspot/share/opto/graphKit.hpp
--- a/src/hotspot/share/opto/graphKit.hpp
+++ b/src/hotspot/share/opto/graphKit.hpp
@@ -340,11 +340,11 @@
   // (See macros ConvI2X, etc., in type.hpp for ConvI2X, etc.)
   Node* ConvI2L(Node* offset);
   Node* ConvI2UL(Node* offset);
   Node* ConvL2I(Node* offset);
   // Find out the klass of an object.
-  Node* load_object_klass(Node* object, bool clear_prop_bits = true);
+  Node* load_object_klass(Node* object);
   // Find out the length of an array.
   Node* load_array_length(Node* array);
 
 
   // Helper function to do a NULL pointer check or ZERO check based on type.
diff a/src/hotspot/share/opto/macro.cpp b/src/hotspot/share/opto/macro.cpp
--- a/src/hotspot/share/opto/macro.cpp
+++ b/src/hotspot/share/opto/macro.cpp
@@ -2862,11 +2862,11 @@
     Node* subklass = NULL;
     if (_igvn.type(obj_or_subklass)->isa_klassptr()) {
       subklass = obj_or_subklass;
     } else {
       Node* k_adr = basic_plus_adr(obj_or_subklass, oopDesc::klass_offset_in_bytes());
-      subklass = _igvn.transform(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT, true));
+      subklass = _igvn.transform(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));
     }
 
     Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &ctrl, NULL, _igvn);
 
     _igvn.replace_input_of(iff, 0, C->top());
diff a/src/hotspot/share/opto/macroArrayCopy.cpp b/src/hotspot/share/opto/macroArrayCopy.cpp
--- a/src/hotspot/share/opto/macroArrayCopy.cpp
+++ b/src/hotspot/share/opto/macroArrayCopy.cpp
@@ -201,11 +201,11 @@
   if ((*ctrl)->is_top())  return NULL;
 
   Node* kls = NULL;
   if (_igvn.type(obj_or_klass)->isa_oopptr()) {
     Node* k_adr = basic_plus_adr(obj_or_klass, oopDesc::klass_offset_in_bytes());
-    kls = transform_later(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT, /* clear_prop_bits = */ true));
+    kls = transform_later(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));
   } else {
     assert(_igvn.type(obj_or_klass)->isa_klassptr(), "what else?");
     kls = obj_or_klass;
   }
   Node* layout_val = make_load(NULL, mem, kls, in_bytes(Klass::layout_helper_offset()), TypeInt::INT, T_INT);
diff a/src/hotspot/share/opto/memnode.cpp b/src/hotspot/share/opto/memnode.cpp
--- a/src/hotspot/share/opto/memnode.cpp
+++ b/src/hotspot/share/opto/memnode.cpp
@@ -2182,23 +2182,23 @@
 
 //=============================================================================
 //----------------------------LoadKlassNode::make------------------------------
 // Polymorphic factory method:
 Node* LoadKlassNode::make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at,
-                          const TypeKlassPtr* tk, bool clear_prop_bits) {
+                          const TypeKlassPtr* tk) {
   // sanity check the alias category against the created node type
   const TypePtr *adr_type = adr->bottom_type()->isa_ptr();
   assert(adr_type != NULL, "expecting TypeKlassPtr");
 #ifdef _LP64
   if (adr_type->is_ptr_to_narrowklass()) {
     assert(UseCompressedClassPointers, "no compressed klasses");
-    Node* load_klass = gvn.transform(new LoadNKlassNode(ctl, mem, adr, at, tk->make_narrowklass(), MemNode::unordered, clear_prop_bits));
+    Node* load_klass = gvn.transform(new LoadNKlassNode(ctl, mem, adr, at, tk->make_narrowklass(), MemNode::unordered));
     return new DecodeNKlassNode(load_klass, load_klass->bottom_type()->make_ptr());
   }
 #endif
   assert(!adr_type->is_ptr_to_narrowklass() && !adr_type->is_ptr_to_narrowoop(), "should have got back a narrow oop");
-  return new LoadKlassNode(ctl, mem, adr, at, tk, MemNode::unordered, clear_prop_bits);
+  return new LoadKlassNode(ctl, mem, adr, at, tk, MemNode::unordered);
 }
 
 //------------------------------Value------------------------------------------
 const Type* LoadKlassNode::Value(PhaseGVN* phase) const {
   return klass_value_common(phase);
diff a/src/hotspot/share/opto/memnode.hpp b/src/hotspot/share/opto/memnode.hpp
--- a/src/hotspot/share/opto/memnode.hpp
+++ b/src/hotspot/share/opto/memnode.hpp
@@ -513,57 +513,41 @@
 };
 
 //------------------------------LoadKlassNode----------------------------------
 // Load a Klass from an object
 class LoadKlassNode : public LoadPNode {
-private:
-  bool _clear_prop_bits; // Clear the ArrayStorageProperties bits
 protected:
   // In most cases, LoadKlassNode does not have the control input set. If the control
   // input is set, it must not be removed (by LoadNode::Ideal()).
   virtual bool can_remove_control() const;
 public:
-  LoadKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeKlassPtr *tk, MemOrd mo, bool clear_prop_bits)
-    : LoadPNode(c, mem, adr, at, tk, mo), _clear_prop_bits(clear_prop_bits) {}
-  virtual uint hash() const { return LoadPNode::hash() + _clear_prop_bits; }
-  virtual bool cmp(const Node &n) const {
-    return (_clear_prop_bits == ((LoadKlassNode&)n)._clear_prop_bits) && LoadPNode::cmp(n);
-  }
-  virtual uint size_of() const { return sizeof(*this); }
+  LoadKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeKlassPtr *tk, MemOrd mo)
+    : LoadPNode(c, mem, adr, at, tk, mo) {}
   virtual int Opcode() const;
   virtual const Type* Value(PhaseGVN* phase) const;
   virtual Node* Identity(PhaseGVN* phase);
   virtual bool depends_only_on_test() const { return true; }
-  bool clear_prop_bits() const { return _clear_prop_bits; }
 
   // Polymorphic factory method:
   static Node* make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at,
-                    const TypeKlassPtr* tk = TypeKlassPtr::OBJECT, bool clear_prop_bits = false);
+                    const TypeKlassPtr* tk = TypeKlassPtr::OBJECT);
 };
 
 //------------------------------LoadNKlassNode---------------------------------
 // Load a narrow Klass from an object.
 class LoadNKlassNode : public LoadNNode {
-private:
-  bool _clear_prop_bits; // Clear the ArrayStorageProperties bits
 public:
-  LoadNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeNarrowKlass *tk, MemOrd mo, bool clear_prop_bits)
-    : LoadNNode(c, mem, adr, at, tk, mo), _clear_prop_bits(clear_prop_bits) {}
-  virtual uint hash() const { return LoadNNode::hash() + _clear_prop_bits; }
-  virtual bool cmp(const Node &n) const {
-    return (_clear_prop_bits == ((LoadNKlassNode&)n)._clear_prop_bits) && LoadNNode::cmp(n);
-  }
-  virtual uint size_of() const { return sizeof(*this); }
+  LoadNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeNarrowKlass *tk, MemOrd mo)
+    : LoadNNode(c, mem, adr, at, tk, mo) {}
   virtual int Opcode() const;
   virtual uint ideal_reg() const { return Op_RegN; }
   virtual int store_Opcode() const { return Op_StoreNKlass; }
   virtual BasicType memory_type() const { return T_NARROWKLASS; }
 
   virtual const Type* Value(PhaseGVN* phase) const;
   virtual Node* Identity(PhaseGVN* phase);
   virtual bool depends_only_on_test() const { return true; }
-  bool clear_prop_bits() const { return _clear_prop_bits; }
 };
 
 //------------------------------StoreNode--------------------------------------
 // Store value; requires Store, Address and Value
 class StoreNode : public MemNode {
diff a/src/hotspot/share/opto/parse2.cpp b/src/hotspot/share/opto/parse2.cpp
--- a/src/hotspot/share/opto/parse2.cpp
+++ b/src/hotspot/share/opto/parse2.cpp
@@ -2160,14 +2160,13 @@
       set_control(_gvn.transform(eq_region));
     }
     return;
   }
 
-  // Check if both operands are of the same class. We don't need to clear the array property
-  // bits in the klass pointer for the cmp because we know that the first operand is a value type.
-  Node* kls_a = load_object_klass(not_null_a, /* clear_prop_bits = */ false);
-  Node* kls_b = load_object_klass(not_null_b, /* clear_prop_bits = */ false);
+  // Check if both operands are of the same class.
+  Node* kls_a = load_object_klass(not_null_a);
+  Node* kls_b = load_object_klass(not_null_b);
   Node* kls_cmp = CmpP(kls_a, kls_b);
   Node* kls_bol = _gvn.transform(new BoolNode(kls_cmp, BoolTest::ne));
   IfNode* kls_iff = create_and_map_if(control(), kls_bol, PROB_FAIR, COUNT_UNKNOWN);
   Node* kls_ne = _gvn.transform(new IfTrueNode(kls_iff));
   set_control(_gvn.transform(new IfFalseNode(kls_iff)));
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java
@@ -785,11 +785,11 @@
             va[i] = MyValue1.createWithFieldsInline(rI, rL);
         }
         Object[] result = test33(va);
         for (int i = 0; i < len; ++i) {
             Asserts.assertEQ(((MyValue1)result[i]).hash(), ((MyValue1)va[i]).hash());
-            // Check that array has correct storage properties (null-ok)
+            // Check that array has correct properties (null-ok)
             result[i] = null;
         }
     }
 
     // clone() as series of loads/stores
@@ -820,22 +820,22 @@
     public void test34_verifier(boolean warmup) {
         test34(false);
         for (int i = 0; i < 10; i++) { // make sure we do deopt
             Object[] result = test34(true);
             verify(test34_orig, result);
-            // Check that array has correct storage properties (null-free)
+            // Check that array has correct properties (null-free)
             try {
                 result[0] = null;
                 throw new RuntimeException("Should throw NullPointerException");
             } catch (NullPointerException e) {
                 // Expected
             }
         }
         if (compile_and_run_again_if_deoptimized(warmup, "TestArrays::test34")) {
             Object[] result = test34(true);
             verify(test34_orig, result);
-            // Check that array has correct storage properties (null-free)
+            // Check that array has correct properties (null-free)
             try {
                 result[0] = null;
                 throw new RuntimeException("Should throw NullPointerException");
             } catch (NullPointerException e) {
                 // Expected
@@ -1748,11 +1748,11 @@
         test75_helper(42, va, oa);
         Object[] result = test75(va, oa);
 
         for (int i = 0; i < va.length; ++i) {
             Asserts.assertEQ(oa[i], result[i]);
-            // Check that array has correct storage properties (null-ok)
+            // Check that array has correct properties (null-ok)
             result[i] = null;
         }
     }
 
     @ForceInline
@@ -1786,11 +1786,11 @@
         }
         Integer[] oa = new Integer[len];
         test76_helper(42, va, oa);
         Object[] result = test76(va, oa);
         verify(verif, result);
-        // Check that array has correct storage properties (null-free)
+        // Check that array has correct properties (null-free)
         if (len > 0) {
             try {
                 result[0] = null;
                 throw new RuntimeException("Should throw NullPointerException");
             } catch (NullPointerException e) {
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java
@@ -2359,26 +2359,22 @@
                                 () -> { test88(src1, dst1, src2, dst2);
                                         Asserts.assertTrue(Arrays.equals(src1, dst1));
                                         Asserts.assertTrue(Arrays.equals(src2, dst2)); });
     }
 
-    // Verify that the storage property bits in the klass pointer are
-    // not cleared if we are comparing to a klass that can't be a inline
-    // type array klass anyway.
-    @Test(failOn = STORAGE_PROPERTY_CLEARING)
+    @Test
     public boolean test89(Object obj) {
         return obj.getClass() == Integer.class;
     }
 
     @DontCompile
     public void test89_verifier(boolean warmup) {
         Asserts.assertTrue(test89(new Integer(42)));
         Asserts.assertFalse(test89(new Object()));
     }
 
-    // Same as test89 but with a cast
-    @Test(failOn = STORAGE_PROPERTY_CLEARING)
+    @Test
     public Integer test90(Object obj) {
         return (Integer)obj;
     }
 
     @DontCompile
@@ -2390,13 +2386,11 @@
         } catch (ClassCastException e) {
             // Expected
         }
     }
 
-    // Same as test89 but bit clearing can not be removed because
-    // we are comparing to a inline type array klass.
-    @Test(match = {STORAGE_PROPERTY_CLEARING}, matchCount = { 1 })
+    @Test
     public boolean test91(Object obj) {
         return obj.getClass() == MyValue2[].class;
     }
 
     @DontCompile
@@ -2496,14 +2490,12 @@
         array[3] = 0x42;
         int result = test94(array);
         Asserts.assertEquals(result, 0x42 * 2);
     }
 
-    // Test that no code for clearing the array klass property bits is emitted for acmp
-    // because when loading the klass, we already know that the operand is a value type.
     @Warmup(10000)
-    @Test(failOn = STORAGE_PROPERTY_CLEARING)
+    @Test
     public boolean test95(Object o1, Object o2) {
         return o1 == o2;
     }
 
     @DontCompile
@@ -2514,13 +2506,12 @@
         Asserts.assertTrue(test95(null, null));
         Asserts.assertFalse(test95(o1, null));
         Asserts.assertFalse(test95(o1, o2));
     }
 
-    // Same as test95 but operands are never null
     @Warmup(10000)
-    @Test(failOn = STORAGE_PROPERTY_CLEARING)
+    @Test
     public boolean test96(Object o1, Object o2) {
         return o1 == o2;
     }
 
     @DontCompile
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableArrays.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableArrays.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableArrays.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableArrays.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -1931,11 +1931,11 @@
         test74_helper(42, va, oa);
         Object[] result = test74(va, oa);
 
         for (int i = 0; i < va.length; ++i) {
             Asserts.assertEQ(oa[i], result[i]);
-            // Check that array has correct storage properties (null-ok)
+            // Check that array has correct properties (null-ok)
             result[i] = null;
         }
     }
 
     @ForceInline
@@ -1970,11 +1970,11 @@
         Integer[] oa = new Integer[len];
         test75_helper(42, va, oa);
         Object[] result = test75(va, oa);
         verify(verif, result);
         if (len > 0) {
-            // Check that array has correct storage properties (null-ok)
+            // Check that array has correct properties (null-ok)
             result[0] = null;
         }
     }
 
     // Test mixing nullable and non-nullable arrays
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/ValueTypeTest.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/ValueTypeTest.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/ValueTypeTest.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/ValueTypeTest.java
@@ -217,11 +217,10 @@
     protected static final String STOREVALUETYPEFIELDS = START + "CallStaticJava" + MID + "store_value_type_fields" + END;
     protected static final String SCOBJ = "(.*# ScObj.*" + END;
     protected static final String LOAD_UNKNOWN_VALUE = "(.*call_leaf,runtime  load_unknown_value.*" + END;
     protected static final String STORE_UNKNOWN_VALUE = "(.*call_leaf,runtime  store_unknown_value.*" + END;
     protected static final String VALUE_ARRAY_NULL_GUARD = "(.*call,static  wrapper for: uncommon_trap.*reason='null_check' action='none'.*" + END;
-    protected static final String STORAGE_PROPERTY_CLEARING = "(.*((int:536870911)|(salq.*3\\R.*sarq.*3)).*" + END;
     protected static final String CLASS_CHECK_TRAP = START + "CallStaticJava" + MID + "uncommon_trap.*class_check" + END;
     protected static final String NULL_CHECK_TRAP = START + "CallStaticJava" + MID + "uncommon_trap.*null_check" + END;
     protected static final String RANGE_CHECK_TRAP = START + "CallStaticJava" + MID + "uncommon_trap.*range_check" + END;
     protected static final String UNHANDLED_TRAP = START + "CallStaticJava" + MID + "uncommon_trap.*unhandled" + END;
 

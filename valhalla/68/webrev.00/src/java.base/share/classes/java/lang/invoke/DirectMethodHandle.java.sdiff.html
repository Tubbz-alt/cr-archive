<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemberName.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  96                     LambdaForm lform = preparedLambdaForm(member, callerClass.isInterface());
  97                     return new Special(mtype, lform, member, true, callerClass);
  98                 }
  99                 case REF_invokeInterface: {
 100                     // for interfaces we always need the receiver typecheck,
 101                     // so we always pass &#39;true&#39; to ensure we adapt if needed
 102                     // to include the REF_invokeSpecial case
 103                     LambdaForm lform = preparedLambdaForm(member, true);
 104                     return new Interface(mtype, lform, member, true, refc);
 105                 }
 106                 default: {
 107                     LambdaForm lform = preparedLambdaForm(member);
 108                     return new DirectMethodHandle(mtype, lform, member, true);
 109                 }
 110             }
 111         } else {
 112             LambdaForm lform = preparedFieldLambdaForm(member);
 113             if (member.isStatic()) {
 114                 long offset = MethodHandleNatives.staticFieldOffset(member);
 115                 Object base = MethodHandleNatives.staticFieldBase(member);
<span class="line-modified"> 116                 return member.isIndirect() ? new IndirectStaticAccessor(mtype, lform, member, base, offset)</span>
<span class="line-modified"> 117                                            : new InlineStaticAccessor(mtype, lform, member, base, offset);</span>
 118             } else {
 119                 long offset = MethodHandleNatives.objectFieldOffset(member);
 120                 assert(offset == (int)offset);
<span class="line-modified"> 121                 return  member.isIndirect() ? new IndirectAccessor(mtype, lform, member, (int)offset)</span>
<span class="line-modified"> 122                                             : new InlineAccessor(mtype, lform, member, (int)offset);</span>
 123             }
 124         }
 125     }
 126     static DirectMethodHandle make(Class&lt;?&gt; refc, MemberName member) {
 127         byte refKind = member.getReferenceKind();
 128         if (refKind == REF_invokeSpecial)
 129             refKind =  REF_invokeVirtual;
 130         return make(refKind, refc, member, null /* no callerClass context */);
 131     }
 132     static DirectMethodHandle make(MemberName member) {
 133         if (member.isObjectConstructor() &amp;&amp; member.getReturnType() == void.class)
 134             return makeAllocator(member);
 135         return make(member.getDeclaringClass(), member);
 136     }
 137     private static DirectMethodHandle makeAllocator(MemberName ctor) {
 138         assert(ctor.isObjectConstructor() &amp;&amp; !ctor.getDeclaringClass().isInlineClass()) : ctor;
 139 
 140         Class&lt;?&gt; instanceClass = ctor.getDeclaringClass();
 141         ctor = ctor.asObjectConstructor();
 142         assert(ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;
</pre>
<hr />
<pre>
 505         @Override
 506         MethodHandle viewAsType(MethodType newType, boolean strict) {
 507             assert(viewAsTypeChecks(newType, strict));
 508             return new Constructor(newType, form, member, false, initMethod, instanceClass);
 509         }
 510     }
 511 
 512     /*non-public*/
 513     static Object constructorMethod(Object mh) {
 514         Constructor dmh = (Constructor)mh;
 515         return dmh.initMethod;
 516     }
 517 
 518     /*non-public*/
 519     static Object allocateInstance(Object mh) throws InstantiationException {
 520         Constructor dmh = (Constructor)mh;
 521         return UNSAFE.allocateInstance(dmh.instanceClass);
 522     }
 523 
 524     /** This subclass handles non-static field references. */
<span class="line-modified"> 525     static abstract class Accessor extends DirectMethodHandle {</span>
 526         final Class&lt;?&gt; fieldType;
 527         final int      fieldOffset;
 528         private Accessor(MethodType mtype, LambdaForm form, MemberName member,
 529                          boolean crackable, int fieldOffset) {
 530             super(mtype, form, member, crackable);
 531             this.fieldType   = member.getFieldType();
 532             this.fieldOffset = fieldOffset;
 533         }
<span class="line-removed"> 534         abstract Object checkCast(Object obj);</span>
<span class="line-removed"> 535         abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);</span>
<span class="line-removed"> 536     }</span>
<span class="line-removed"> 537 </span>
<span class="line-removed"> 538     /** This subclass handles non-static field references of indirect type */</span>
<span class="line-removed"> 539     static class IndirectAccessor extends Accessor {</span>
<span class="line-removed"> 540         private IndirectAccessor(MethodType mtype, LambdaForm form, MemberName member,</span>
<span class="line-removed"> 541                                  int fieldOffset) {</span>
<span class="line-removed"> 542             super(mtype, form, member, true, fieldOffset);</span>
<span class="line-removed"> 543         }</span>
 544 
 545         @Override Object checkCast(Object obj) {
 546             return fieldType.cast(obj);
 547         }
 548         @Override
 549         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified"> 550             return new IndirectAccessor(mt, lf, member, fieldOffset);</span>
 551         }
 552         @Override
 553         MethodHandle viewAsType(MethodType newType, boolean strict) {
 554             assert(viewAsTypeChecks(newType, strict));
<span class="line-modified"> 555             return new IndirectAccessor(newType, form, member, fieldOffset);</span>
 556         }
 557     }
 558 
 559     /** This subclass handles non-static field references of inline type */
 560     static class InlineAccessor extends Accessor {
 561         private InlineAccessor(MethodType mtype, LambdaForm form, MemberName member,
<span class="line-modified"> 562                                int fieldOffset) {</span>
<span class="line-modified"> 563             super(mtype, form, member, true, fieldOffset);</span>
 564         }
 565 
 566         @Override Object checkCast(Object obj) {
 567             return fieldType.cast(Objects.requireNonNull(obj));
 568         }
 569         @Override
 570         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified"> 571             return new InlineAccessor(mt, lf, member, fieldOffset);</span>





 572         }
 573     }
 574 
 575     @ForceInline
 576     /*non-public*/
 577     static long fieldOffset(Object accessorObj) {
 578         // Note: We return a long because that is what Unsafe.getObject likes.
 579         // We store a plain int because it is more compact.
 580         return ((Accessor)accessorObj).fieldOffset;
 581     }
 582 
 583     @ForceInline
 584     /*non-public*/
 585     static Object checkBase(Object obj) {
 586         // Note that the object&#39;s class has already been verified,
 587         // since the parameter type of the Accessor method handle
 588         // is either member.getDeclaringClass or a subclass.
 589         // This was verified in DirectMethodHandle.make.
 590         // Therefore, the only remaining check is for null.
 591         // Since this check is *not* guaranteed by Unsafe.getInt
 592         // and its siblings, we need to make an explicit one here.
 593         return Objects.requireNonNull(obj);
 594     }
 595 
<span class="line-modified"> 596     static abstract class StaticAccessor extends DirectMethodHandle {</span>
 597         final Class&lt;?&gt; fieldType;
 598         final Object staticBase;
 599         final long staticOffset;
 600 
 601         private StaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
 602                                boolean crackable, Object staticBase, long staticOffset) {
 603             super(mtype, form, member, crackable);
 604             this.fieldType    = member.getFieldType();
 605             this.staticBase   = staticBase;
 606             this.staticOffset = staticOffset;
 607         }
<span class="line-removed"> 608         abstract Object checkCast(Object obj);</span>
<span class="line-removed"> 609         abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);</span>
<span class="line-removed"> 610     }</span>
<span class="line-removed"> 611 </span>
<span class="line-removed"> 612     /** This subclass handles static field references of indirect type. */</span>
<span class="line-removed"> 613     static class IndirectStaticAccessor extends StaticAccessor {</span>
<span class="line-removed"> 614         private IndirectStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,</span>
<span class="line-removed"> 615                                      Object staticBase, long staticOffset) {</span>
<span class="line-removed"> 616             super(mtype, form, member, true, staticBase, staticOffset);</span>
<span class="line-removed"> 617         }</span>
 618 
<span class="line-removed"> 619         // indirect type is always nullable</span>
 620         @Override Object checkCast(Object obj) {
 621             return fieldType.cast(obj);
 622         }
 623         @Override
 624         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified"> 625             return new IndirectStaticAccessor(mt, lf, member, staticBase, staticOffset);</span>
 626         }
 627         @Override
 628         MethodHandle viewAsType(MethodType newType, boolean strict) {
 629             assert(viewAsTypeChecks(newType, strict));
<span class="line-modified"> 630             return new IndirectStaticAccessor(newType, form, member, staticBase, staticOffset);</span>
 631         }
 632     }
 633 
 634     /** This subclass handles static field references of inline type . */
 635     static class InlineStaticAccessor extends StaticAccessor {
 636         private InlineStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
<span class="line-modified"> 637                                      Object staticBase, long staticOffset) {</span>
<span class="line-modified"> 638             super(mtype, form, member, true, staticBase, staticOffset);</span>
 639         }
 640 
 641         // zero-default inline type is not-nullable
 642         @Override Object checkCast(Object obj) {
 643             assert fieldType.isInlineClass() : &quot;null-default inline type not yet supported&quot;;
 644             return fieldType.cast(Objects.requireNonNull(obj));
 645         }
 646         @Override
 647         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified"> 648             return new InlineStaticAccessor(mt, lf, member, staticBase, staticOffset);</span>





 649         }
 650     }
 651 
 652     @ForceInline
 653     /*non-public*/
 654     static Object nullCheck(Object obj) {
 655         return Objects.requireNonNull(obj);
 656     }
 657 
 658     @ForceInline
 659     /*non-public*/
 660     static Object staticBase(Object accessorObj) {
 661         return ((StaticAccessor)accessorObj).staticBase;
 662     }
 663 
 664     @ForceInline
 665     /*non-public*/
 666     static long staticOffset(Object accessorObj) {
 667         return ((StaticAccessor)accessorObj).staticOffset;
 668     }
</pre>
<hr />
<pre>
 723             return isValue ? FT_CHECKED_VALUE : FT_CHECKED_REF;
 724     }
 725 
 726     /**
 727      * Create a LF which can access the given field.
 728      * Cache and share this structure among all fields with
 729      * the same basicType and refKind.
 730      */
 731     private static LambdaForm preparedFieldLambdaForm(MemberName m) {
 732         Class&lt;?&gt; ftype = m.getFieldType();
 733         byte formOp;
 734         switch (m.getReferenceKind()) {
 735         case REF_getField:      formOp = AF_GETFIELD;    break;
 736         case REF_putField:      formOp = AF_PUTFIELD;    break;
 737         case REF_getStatic:     formOp = AF_GETSTATIC;   break;
 738         case REF_putStatic:     formOp = AF_PUTSTATIC;   break;
 739         default:  throw new InternalError(m.toString());
 740         }
 741         if (shouldBeInitialized(m)) {
 742             // precompute the barrier-free version:
<span class="line-modified"> 743             preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineable(), m.isFlattened(), ftype);</span>
 744             assert((AF_GETSTATIC_INIT - AF_GETSTATIC) ==
 745                    (AF_PUTSTATIC_INIT - AF_PUTSTATIC));
 746             formOp += (AF_GETSTATIC_INIT - AF_GETSTATIC);
 747         }
<span class="line-modified"> 748         LambdaForm lform = preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineable(), m.isFlattened(), ftype);</span>
 749         maybeCompile(lform, m);
 750         assert(lform.methodType().dropParameterTypes(0, 1)
 751                 .equals(m.getInvocationType().basicType()))
 752                 : Arrays.asList(m, m.getInvocationType().basicType(), lform, lform.methodType());
 753         return lform;
 754     }
 755 
 756     private static LambdaForm preparedFieldLambdaForm(byte formOp, boolean isVolatile, boolean isValue, boolean isFlatValue, Class&lt;?&gt; ftype) {
 757         int ftypeKind = ftypeKind(ftype, isValue);
 758         int afIndex = afIndex(formOp, isVolatile, isFlatValue, ftypeKind);
 759         LambdaForm lform = ACCESSOR_FORMS[afIndex];
 760         if (lform != null)  return lform;
 761         lform = makePreparedFieldLambdaForm(formOp, isVolatile, isValue, isFlatValue, ftypeKind);
 762         ACCESSOR_FORMS[afIndex] = lform;  // don&#39;t bother with a CAS
 763         return lform;
 764     }
 765 
 766     private static final Wrapper[] ALL_WRAPPERS = Wrapper.values();
 767 
 768     private static Kind getFieldKind(boolean isGetter, boolean isVolatile, boolean isFlatValue, Wrapper wrapper) {
</pre>
</td>
<td>
<hr />
<pre>
  96                     LambdaForm lform = preparedLambdaForm(member, callerClass.isInterface());
  97                     return new Special(mtype, lform, member, true, callerClass);
  98                 }
  99                 case REF_invokeInterface: {
 100                     // for interfaces we always need the receiver typecheck,
 101                     // so we always pass &#39;true&#39; to ensure we adapt if needed
 102                     // to include the REF_invokeSpecial case
 103                     LambdaForm lform = preparedLambdaForm(member, true);
 104                     return new Interface(mtype, lform, member, true, refc);
 105                 }
 106                 default: {
 107                     LambdaForm lform = preparedLambdaForm(member);
 108                     return new DirectMethodHandle(mtype, lform, member, true);
 109                 }
 110             }
 111         } else {
 112             LambdaForm lform = preparedFieldLambdaForm(member);
 113             if (member.isStatic()) {
 114                 long offset = MethodHandleNatives.staticFieldOffset(member);
 115                 Object base = MethodHandleNatives.staticFieldBase(member);
<span class="line-modified"> 116                 return member.isInlineableField() ? new InlineStaticAccessor(mtype, lform, member, true, base, offset)</span>
<span class="line-modified"> 117                                                   : new StaticAccessor(mtype, lform, member, true, base, offset);</span>
 118             } else {
 119                 long offset = MethodHandleNatives.objectFieldOffset(member);
 120                 assert(offset == (int)offset);
<span class="line-modified"> 121                 return  member.isInlineableField() ? new InlineAccessor(mtype, lform, member, true, (int)offset)</span>
<span class="line-modified"> 122                                                    : new Accessor(mtype, lform, member, true, (int)offset);</span>
 123             }
 124         }
 125     }
 126     static DirectMethodHandle make(Class&lt;?&gt; refc, MemberName member) {
 127         byte refKind = member.getReferenceKind();
 128         if (refKind == REF_invokeSpecial)
 129             refKind =  REF_invokeVirtual;
 130         return make(refKind, refc, member, null /* no callerClass context */);
 131     }
 132     static DirectMethodHandle make(MemberName member) {
 133         if (member.isObjectConstructor() &amp;&amp; member.getReturnType() == void.class)
 134             return makeAllocator(member);
 135         return make(member.getDeclaringClass(), member);
 136     }
 137     private static DirectMethodHandle makeAllocator(MemberName ctor) {
 138         assert(ctor.isObjectConstructor() &amp;&amp; !ctor.getDeclaringClass().isInlineClass()) : ctor;
 139 
 140         Class&lt;?&gt; instanceClass = ctor.getDeclaringClass();
 141         ctor = ctor.asObjectConstructor();
 142         assert(ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;
</pre>
<hr />
<pre>
 505         @Override
 506         MethodHandle viewAsType(MethodType newType, boolean strict) {
 507             assert(viewAsTypeChecks(newType, strict));
 508             return new Constructor(newType, form, member, false, initMethod, instanceClass);
 509         }
 510     }
 511 
 512     /*non-public*/
 513     static Object constructorMethod(Object mh) {
 514         Constructor dmh = (Constructor)mh;
 515         return dmh.initMethod;
 516     }
 517 
 518     /*non-public*/
 519     static Object allocateInstance(Object mh) throws InstantiationException {
 520         Constructor dmh = (Constructor)mh;
 521         return UNSAFE.allocateInstance(dmh.instanceClass);
 522     }
 523 
 524     /** This subclass handles non-static field references. */
<span class="line-modified"> 525     static class Accessor extends DirectMethodHandle {</span>
 526         final Class&lt;?&gt; fieldType;
 527         final int      fieldOffset;
 528         private Accessor(MethodType mtype, LambdaForm form, MemberName member,
 529                          boolean crackable, int fieldOffset) {
 530             super(mtype, form, member, crackable);
 531             this.fieldType   = member.getFieldType();
 532             this.fieldOffset = fieldOffset;
 533         }










 534 
 535         @Override Object checkCast(Object obj) {
 536             return fieldType.cast(obj);
 537         }
 538         @Override
 539         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified"> 540             return new Accessor(mt, lf, member, crackable, fieldOffset);</span>
 541         }
 542         @Override
 543         MethodHandle viewAsType(MethodType newType, boolean strict) {
 544             assert(viewAsTypeChecks(newType, strict));
<span class="line-modified"> 545             return new Accessor(newType, form, member, false, fieldOffset);</span>
 546         }
 547     }
 548 
 549     /** This subclass handles non-static field references of inline type */
 550     static class InlineAccessor extends Accessor {
 551         private InlineAccessor(MethodType mtype, LambdaForm form, MemberName member,
<span class="line-modified"> 552                                boolean crackable, int fieldOffset) {</span>
<span class="line-modified"> 553             super(mtype, form, member, crackable, fieldOffset);</span>
 554         }
 555 
 556         @Override Object checkCast(Object obj) {
 557             return fieldType.cast(Objects.requireNonNull(obj));
 558         }
 559         @Override
 560         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified"> 561             return new InlineAccessor(mt, lf, member, crackable, fieldOffset);</span>
<span class="line-added"> 562         }</span>
<span class="line-added"> 563         @Override</span>
<span class="line-added"> 564         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added"> 565             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added"> 566             return new InlineAccessor(newType, form, member, false, fieldOffset);</span>
 567         }
 568     }
 569 
 570     @ForceInline
 571     /*non-public*/
 572     static long fieldOffset(Object accessorObj) {
 573         // Note: We return a long because that is what Unsafe.getObject likes.
 574         // We store a plain int because it is more compact.
 575         return ((Accessor)accessorObj).fieldOffset;
 576     }
 577 
 578     @ForceInline
 579     /*non-public*/
 580     static Object checkBase(Object obj) {
 581         // Note that the object&#39;s class has already been verified,
 582         // since the parameter type of the Accessor method handle
 583         // is either member.getDeclaringClass or a subclass.
 584         // This was verified in DirectMethodHandle.make.
 585         // Therefore, the only remaining check is for null.
 586         // Since this check is *not* guaranteed by Unsafe.getInt
 587         // and its siblings, we need to make an explicit one here.
 588         return Objects.requireNonNull(obj);
 589     }
 590 
<span class="line-modified"> 591     static class StaticAccessor extends DirectMethodHandle {</span>
 592         final Class&lt;?&gt; fieldType;
 593         final Object staticBase;
 594         final long staticOffset;
 595 
 596         private StaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
 597                                boolean crackable, Object staticBase, long staticOffset) {
 598             super(mtype, form, member, crackable);
 599             this.fieldType    = member.getFieldType();
 600             this.staticBase   = staticBase;
 601             this.staticOffset = staticOffset;
 602         }










 603 

 604         @Override Object checkCast(Object obj) {
 605             return fieldType.cast(obj);
 606         }
 607         @Override
 608         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified"> 609             return new StaticAccessor(mt, lf, member, crackable, staticBase, staticOffset);</span>
 610         }
 611         @Override
 612         MethodHandle viewAsType(MethodType newType, boolean strict) {
 613             assert(viewAsTypeChecks(newType, strict));
<span class="line-modified"> 614             return new StaticAccessor(newType, form, member, false, staticBase, staticOffset);</span>
 615         }
 616     }
 617 
 618     /** This subclass handles static field references of inline type . */
 619     static class InlineStaticAccessor extends StaticAccessor {
 620         private InlineStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
<span class="line-modified"> 621                                      boolean crackable, Object staticBase, long staticOffset) {</span>
<span class="line-modified"> 622             super(mtype, form, member, crackable, staticBase, staticOffset);</span>
 623         }
 624 
 625         // zero-default inline type is not-nullable
 626         @Override Object checkCast(Object obj) {
 627             assert fieldType.isInlineClass() : &quot;null-default inline type not yet supported&quot;;
 628             return fieldType.cast(Objects.requireNonNull(obj));
 629         }
 630         @Override
 631         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified"> 632             return new InlineStaticAccessor(mt, lf, member, crackable, staticBase, staticOffset);</span>
<span class="line-added"> 633         }</span>
<span class="line-added"> 634         @Override</span>
<span class="line-added"> 635         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added"> 636             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added"> 637             return new InlineStaticAccessor(newType, form, member, false, staticBase, staticOffset);</span>
 638         }
 639     }
 640 
 641     @ForceInline
 642     /*non-public*/
 643     static Object nullCheck(Object obj) {
 644         return Objects.requireNonNull(obj);
 645     }
 646 
 647     @ForceInline
 648     /*non-public*/
 649     static Object staticBase(Object accessorObj) {
 650         return ((StaticAccessor)accessorObj).staticBase;
 651     }
 652 
 653     @ForceInline
 654     /*non-public*/
 655     static long staticOffset(Object accessorObj) {
 656         return ((StaticAccessor)accessorObj).staticOffset;
 657     }
</pre>
<hr />
<pre>
 712             return isValue ? FT_CHECKED_VALUE : FT_CHECKED_REF;
 713     }
 714 
 715     /**
 716      * Create a LF which can access the given field.
 717      * Cache and share this structure among all fields with
 718      * the same basicType and refKind.
 719      */
 720     private static LambdaForm preparedFieldLambdaForm(MemberName m) {
 721         Class&lt;?&gt; ftype = m.getFieldType();
 722         byte formOp;
 723         switch (m.getReferenceKind()) {
 724         case REF_getField:      formOp = AF_GETFIELD;    break;
 725         case REF_putField:      formOp = AF_PUTFIELD;    break;
 726         case REF_getStatic:     formOp = AF_GETSTATIC;   break;
 727         case REF_putStatic:     formOp = AF_PUTSTATIC;   break;
 728         default:  throw new InternalError(m.toString());
 729         }
 730         if (shouldBeInitialized(m)) {
 731             // precompute the barrier-free version:
<span class="line-modified"> 732             preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineableField(), m.isFlattened(), ftype);</span>
 733             assert((AF_GETSTATIC_INIT - AF_GETSTATIC) ==
 734                    (AF_PUTSTATIC_INIT - AF_PUTSTATIC));
 735             formOp += (AF_GETSTATIC_INIT - AF_GETSTATIC);
 736         }
<span class="line-modified"> 737         LambdaForm lform = preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineableField(), m.isFlattened(), ftype);</span>
 738         maybeCompile(lform, m);
 739         assert(lform.methodType().dropParameterTypes(0, 1)
 740                 .equals(m.getInvocationType().basicType()))
 741                 : Arrays.asList(m, m.getInvocationType().basicType(), lform, lform.methodType());
 742         return lform;
 743     }
 744 
 745     private static LambdaForm preparedFieldLambdaForm(byte formOp, boolean isVolatile, boolean isValue, boolean isFlatValue, Class&lt;?&gt; ftype) {
 746         int ftypeKind = ftypeKind(ftype, isValue);
 747         int afIndex = afIndex(formOp, isVolatile, isFlatValue, ftypeKind);
 748         LambdaForm lform = ACCESSOR_FORMS[afIndex];
 749         if (lform != null)  return lform;
 750         lform = makePreparedFieldLambdaForm(formOp, isVolatile, isValue, isFlatValue, ftypeKind);
 751         ACCESSOR_FORMS[afIndex] = lform;  // don&#39;t bother with a CAS
 752         return lform;
 753     }
 754 
 755     private static final Wrapper[] ALL_WRAPPERS = Wrapper.values();
 756 
 757     private static Kind getFieldKind(boolean isGetter, boolean isVolatile, boolean isFlatValue, Wrapper wrapper) {
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemberName.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
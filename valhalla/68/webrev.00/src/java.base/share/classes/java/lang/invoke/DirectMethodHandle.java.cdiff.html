<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemberName.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 111,17 ***</span>
          } else {
              LambdaForm lform = preparedFieldLambdaForm(member);
              if (member.isStatic()) {
                  long offset = MethodHandleNatives.staticFieldOffset(member);
                  Object base = MethodHandleNatives.staticFieldBase(member);
<span class="line-modified">!                 return member.isIndirect() ? new IndirectStaticAccessor(mtype, lform, member, base, offset)</span>
<span class="line-modified">!                                            : new InlineStaticAccessor(mtype, lform, member, base, offset);</span>
              } else {
                  long offset = MethodHandleNatives.objectFieldOffset(member);
                  assert(offset == (int)offset);
<span class="line-modified">!                 return  member.isIndirect() ? new IndirectAccessor(mtype, lform, member, (int)offset)</span>
<span class="line-modified">!                                             : new InlineAccessor(mtype, lform, member, (int)offset);</span>
              }
          }
      }
      static DirectMethodHandle make(Class&lt;?&gt; refc, MemberName member) {
          byte refKind = member.getReferenceKind();
<span class="line-new-header">--- 111,17 ---</span>
          } else {
              LambdaForm lform = preparedFieldLambdaForm(member);
              if (member.isStatic()) {
                  long offset = MethodHandleNatives.staticFieldOffset(member);
                  Object base = MethodHandleNatives.staticFieldBase(member);
<span class="line-modified">!                 return member.isInlineableField() ? new InlineStaticAccessor(mtype, lform, member, true, base, offset)</span>
<span class="line-modified">!                                                   : new StaticAccessor(mtype, lform, member, true, base, offset);</span>
              } else {
                  long offset = MethodHandleNatives.objectFieldOffset(member);
                  assert(offset == (int)offset);
<span class="line-modified">!                 return  member.isInlineableField() ? new InlineAccessor(mtype, lform, member, true, (int)offset)</span>
<span class="line-modified">!                                                    : new Accessor(mtype, lform, member, true, (int)offset);</span>
              }
          }
      }
      static DirectMethodHandle make(Class&lt;?&gt; refc, MemberName member) {
          byte refKind = member.getReferenceKind();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 520,57 ***</span>
          Constructor dmh = (Constructor)mh;
          return UNSAFE.allocateInstance(dmh.instanceClass);
      }
  
      /** This subclass handles non-static field references. */
<span class="line-modified">!     static abstract class Accessor extends DirectMethodHandle {</span>
          final Class&lt;?&gt; fieldType;
          final int      fieldOffset;
          private Accessor(MethodType mtype, LambdaForm form, MemberName member,
                           boolean crackable, int fieldOffset) {
              super(mtype, form, member, crackable);
              this.fieldType   = member.getFieldType();
              this.fieldOffset = fieldOffset;
          }
<span class="line-removed">-         abstract Object checkCast(Object obj);</span>
<span class="line-removed">-         abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** This subclass handles non-static field references of indirect type */</span>
<span class="line-removed">-     static class IndirectAccessor extends Accessor {</span>
<span class="line-removed">-         private IndirectAccessor(MethodType mtype, LambdaForm form, MemberName member,</span>
<span class="line-removed">-                                  int fieldOffset) {</span>
<span class="line-removed">-             super(mtype, form, member, true, fieldOffset);</span>
<span class="line-removed">-         }</span>
  
          @Override Object checkCast(Object obj) {
              return fieldType.cast(obj);
          }
          @Override
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified">!             return new IndirectAccessor(mt, lf, member, fieldOffset);</span>
          }
          @Override
          MethodHandle viewAsType(MethodType newType, boolean strict) {
              assert(viewAsTypeChecks(newType, strict));
<span class="line-modified">!             return new IndirectAccessor(newType, form, member, fieldOffset);</span>
          }
      }
  
      /** This subclass handles non-static field references of inline type */
      static class InlineAccessor extends Accessor {
          private InlineAccessor(MethodType mtype, LambdaForm form, MemberName member,
<span class="line-modified">!                                int fieldOffset) {</span>
<span class="line-modified">!             super(mtype, form, member, true, fieldOffset);</span>
          }
  
          @Override Object checkCast(Object obj) {
              return fieldType.cast(Objects.requireNonNull(obj));
          }
          @Override
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified">!             return new InlineAccessor(mt, lf, member, fieldOffset);</span>
          }
      }
  
      @ForceInline
      /*non-public*/
<span class="line-new-header">--- 520,52 ---</span>
          Constructor dmh = (Constructor)mh;
          return UNSAFE.allocateInstance(dmh.instanceClass);
      }
  
      /** This subclass handles non-static field references. */
<span class="line-modified">!     static class Accessor extends DirectMethodHandle {</span>
          final Class&lt;?&gt; fieldType;
          final int      fieldOffset;
          private Accessor(MethodType mtype, LambdaForm form, MemberName member,
                           boolean crackable, int fieldOffset) {
              super(mtype, form, member, crackable);
              this.fieldType   = member.getFieldType();
              this.fieldOffset = fieldOffset;
          }
  
          @Override Object checkCast(Object obj) {
              return fieldType.cast(obj);
          }
          @Override
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified">!             return new Accessor(mt, lf, member, crackable, fieldOffset);</span>
          }
          @Override
          MethodHandle viewAsType(MethodType newType, boolean strict) {
              assert(viewAsTypeChecks(newType, strict));
<span class="line-modified">!             return new Accessor(newType, form, member, false, fieldOffset);</span>
          }
      }
  
      /** This subclass handles non-static field references of inline type */
      static class InlineAccessor extends Accessor {
          private InlineAccessor(MethodType mtype, LambdaForm form, MemberName member,
<span class="line-modified">!                                boolean crackable, int fieldOffset) {</span>
<span class="line-modified">!             super(mtype, form, member, crackable, fieldOffset);</span>
          }
  
          @Override Object checkCast(Object obj) {
              return fieldType.cast(Objects.requireNonNull(obj));
          }
          @Override
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified">!             return new InlineAccessor(mt, lf, member, crackable, fieldOffset);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added">+             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added">+             return new InlineAccessor(newType, form, member, false, fieldOffset);</span>
          }
      }
  
      @ForceInline
      /*non-public*/
</pre>
<hr />
<pre>
<span class="line-old-header">*** 591,11 ***</span>
          // Since this check is *not* guaranteed by Unsafe.getInt
          // and its siblings, we need to make an explicit one here.
          return Objects.requireNonNull(obj);
      }
  
<span class="line-modified">!     static abstract class StaticAccessor extends DirectMethodHandle {</span>
          final Class&lt;?&gt; fieldType;
          final Object staticBase;
          final long staticOffset;
  
          private StaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
<span class="line-new-header">--- 586,11 ---</span>
          // Since this check is *not* guaranteed by Unsafe.getInt
          // and its siblings, we need to make an explicit one here.
          return Objects.requireNonNull(obj);
      }
  
<span class="line-modified">!     static class StaticAccessor extends DirectMethodHandle {</span>
          final Class&lt;?&gt; fieldType;
          final Object staticBase;
          final long staticOffset;
  
          private StaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 603,51 ***</span>
              super(mtype, form, member, crackable);
              this.fieldType    = member.getFieldType();
              this.staticBase   = staticBase;
              this.staticOffset = staticOffset;
          }
<span class="line-removed">-         abstract Object checkCast(Object obj);</span>
<span class="line-removed">-         abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** This subclass handles static field references of indirect type. */</span>
<span class="line-removed">-     static class IndirectStaticAccessor extends StaticAccessor {</span>
<span class="line-removed">-         private IndirectStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,</span>
<span class="line-removed">-                                      Object staticBase, long staticOffset) {</span>
<span class="line-removed">-             super(mtype, form, member, true, staticBase, staticOffset);</span>
<span class="line-removed">-         }</span>
  
<span class="line-removed">-         // indirect type is always nullable</span>
          @Override Object checkCast(Object obj) {
              return fieldType.cast(obj);
          }
          @Override
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified">!             return new IndirectStaticAccessor(mt, lf, member, staticBase, staticOffset);</span>
          }
          @Override
          MethodHandle viewAsType(MethodType newType, boolean strict) {
              assert(viewAsTypeChecks(newType, strict));
<span class="line-modified">!             return new IndirectStaticAccessor(newType, form, member, staticBase, staticOffset);</span>
          }
      }
  
      /** This subclass handles static field references of inline type . */
      static class InlineStaticAccessor extends StaticAccessor {
          private InlineStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
<span class="line-modified">!                                      Object staticBase, long staticOffset) {</span>
<span class="line-modified">!             super(mtype, form, member, true, staticBase, staticOffset);</span>
          }
  
          // zero-default inline type is not-nullable
          @Override Object checkCast(Object obj) {
              assert fieldType.isInlineClass() : &quot;null-default inline type not yet supported&quot;;
              return fieldType.cast(Objects.requireNonNull(obj));
          }
          @Override
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified">!             return new InlineStaticAccessor(mt, lf, member, staticBase, staticOffset);</span>
          }
      }
  
      @ForceInline
      /*non-public*/
<span class="line-new-header">--- 598,45 ---</span>
              super(mtype, form, member, crackable);
              this.fieldType    = member.getFieldType();
              this.staticBase   = staticBase;
              this.staticOffset = staticOffset;
          }
  
          @Override Object checkCast(Object obj) {
              return fieldType.cast(obj);
          }
          @Override
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified">!             return new StaticAccessor(mt, lf, member, crackable, staticBase, staticOffset);</span>
          }
          @Override
          MethodHandle viewAsType(MethodType newType, boolean strict) {
              assert(viewAsTypeChecks(newType, strict));
<span class="line-modified">!             return new StaticAccessor(newType, form, member, false, staticBase, staticOffset);</span>
          }
      }
  
      /** This subclass handles static field references of inline type . */
      static class InlineStaticAccessor extends StaticAccessor {
          private InlineStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
<span class="line-modified">!                                      boolean crackable, Object staticBase, long staticOffset) {</span>
<span class="line-modified">!             super(mtype, form, member, crackable, staticBase, staticOffset);</span>
          }
  
          // zero-default inline type is not-nullable
          @Override Object checkCast(Object obj) {
              assert fieldType.isInlineClass() : &quot;null-default inline type not yet supported&quot;;
              return fieldType.cast(Objects.requireNonNull(obj));
          }
          @Override
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified">!             return new InlineStaticAccessor(mt, lf, member, crackable, staticBase, staticOffset);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added">+             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added">+             return new InlineStaticAccessor(newType, form, member, false, staticBase, staticOffset);</span>
          }
      }
  
      @ForceInline
      /*non-public*/
</pre>
<hr />
<pre>
<span class="line-old-header">*** 738,16 ***</span>
          case REF_putStatic:     formOp = AF_PUTSTATIC;   break;
          default:  throw new InternalError(m.toString());
          }
          if (shouldBeInitialized(m)) {
              // precompute the barrier-free version:
<span class="line-modified">!             preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineable(), m.isFlattened(), ftype);</span>
              assert((AF_GETSTATIC_INIT - AF_GETSTATIC) ==
                     (AF_PUTSTATIC_INIT - AF_PUTSTATIC));
              formOp += (AF_GETSTATIC_INIT - AF_GETSTATIC);
          }
<span class="line-modified">!         LambdaForm lform = preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineable(), m.isFlattened(), ftype);</span>
          maybeCompile(lform, m);
          assert(lform.methodType().dropParameterTypes(0, 1)
                  .equals(m.getInvocationType().basicType()))
                  : Arrays.asList(m, m.getInvocationType().basicType(), lform, lform.methodType());
          return lform;
<span class="line-new-header">--- 727,16 ---</span>
          case REF_putStatic:     formOp = AF_PUTSTATIC;   break;
          default:  throw new InternalError(m.toString());
          }
          if (shouldBeInitialized(m)) {
              // precompute the barrier-free version:
<span class="line-modified">!             preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineableField(), m.isFlattened(), ftype);</span>
              assert((AF_GETSTATIC_INIT - AF_GETSTATIC) ==
                     (AF_PUTSTATIC_INIT - AF_PUTSTATIC));
              formOp += (AF_GETSTATIC_INIT - AF_GETSTATIC);
          }
<span class="line-modified">!         LambdaForm lform = preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineableField(), m.isFlattened(), ftype);</span>
          maybeCompile(lform, m);
          assert(lform.methodType().dropParameterTypes(0, 1)
                  .equals(m.getInvocationType().basicType()))
                  : Arrays.asList(m, m.getInvocationType().basicType(), lform, lform.methodType());
          return lform;
</pre>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemberName.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
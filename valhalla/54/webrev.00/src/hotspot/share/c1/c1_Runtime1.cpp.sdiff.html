<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_Runtime1.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/x86/templateTable_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../memory/oopFactory.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_Runtime1.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 444   thread-&gt;set_vm_result(obj);
 445 JRT_END
 446 
 447 
 448 static void profile_flat_array(JavaThread* thread) {
 449   ResourceMark rm(thread);
 450   vframeStream vfst(thread, true);
 451   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);
 452   int bci = vfst.bci();
 453   Method* method = vfst.method();
 454   MethodData* md = method-&gt;method_data();
 455   if (md != NULL) {
 456     ProfileData* data = md-&gt;bci_to_data(bci);
 457     assert(data != NULL &amp;&amp; data-&gt;is_ArrayLoadStoreData(), &quot;incorrect profiling entry&quot;);
 458     ArrayLoadStoreData* load_store = (ArrayLoadStoreData*)data;
 459     load_store-&gt;set_flat_array();
 460   }
 461 }
 462 
 463 JRT_ENTRY(void, Runtime1::load_flattened_array(JavaThread* thread, valueArrayOopDesc* array, int index))
<span class="line-modified"> 464   assert(ArrayKlass::cast(array-&gt;klass())-&gt;storage_properties().is_flattened(), &quot;should not be called&quot;);</span>
 465   profile_flat_array(thread);
 466 
 467   NOT_PRODUCT(_load_flattened_array_slowcase_cnt++;)
 468   assert(array-&gt;length() &gt; 0 &amp;&amp; index &lt; array-&gt;length(), &quot;already checked&quot;);
 469   valueArrayHandle vah(thread, array);
 470   oop obj = valueArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK);
 471   thread-&gt;set_vm_result(obj);
 472 JRT_END
 473 
 474 
 475 JRT_ENTRY(void, Runtime1::store_flattened_array(JavaThread* thread, valueArrayOopDesc* array, int index, oopDesc* value))
<span class="line-modified"> 476   if (ArrayKlass::cast(array-&gt;klass())-&gt;storage_properties().is_flattened()) {</span>
 477     profile_flat_array(thread);
 478   }
 479 
 480   NOT_PRODUCT(_store_flattened_array_slowcase_cnt++;)
 481   if (value == NULL) {
<span class="line-modified"> 482     assert(ArrayKlass::cast(array-&gt;klass())-&gt;storage_properties().is_flattened() || ArrayKlass::cast(array-&gt;klass())-&gt;storage_properties().is_null_free(), &quot;should not be called&quot;);</span>
 483     SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_NullPointerException());
 484   } else {
<span class="line-modified"> 485     assert(ArrayKlass::cast(array-&gt;klass())-&gt;storage_properties().is_flattened(), &quot;should not be called&quot;);</span>
 486     array-&gt;value_copy_to_index(value, index);
 487   }
 488 JRT_END
 489 
 490 
 491 JRT_ENTRY(int, Runtime1::substitutability_check(JavaThread* thread, oopDesc* left, oopDesc* right))
 492   NOT_PRODUCT(_substitutability_check_slowcase_cnt++;)
 493   JavaCallArguments args;
 494   args.push_oop(Handle(THREAD, left));
 495   args.push_oop(Handle(THREAD, right));
 496   JavaValue result(T_BOOLEAN);
 497   JavaCalls::call_static(&amp;result,
 498                          SystemDictionary::ValueBootstrapMethods_klass(),
 499                          vmSymbols::isSubstitutable_name(),
 500                          vmSymbols::object_object_boolean_signature(),
 501                          &amp;args, CHECK_0);
 502   return result.get_jboolean() ? 1 : 0;
 503 JRT_END
 504 
 505 
</pre>
<hr />
<pre>
1078             // Logically creates elements, ensure klass init
1079             k-&gt;initialize(CHECK);
1080           }
1081         }
1082         break;
1083       case Bytecodes::_instanceof:
1084         { Bytecode_instanceof io(caller_method(), caller_method-&gt;bcp_from(bci));
1085           k = caller_method-&gt;constants()-&gt;klass_at(io.index(), CHECK);
1086         }
1087         break;
1088       case Bytecodes::_checkcast:
1089         { Bytecode_checkcast cc(caller_method(), caller_method-&gt;bcp_from(bci));
1090           k = caller_method-&gt;constants()-&gt;klass_at(cc.index(), CHECK);
1091         }
1092         break;
1093       case Bytecodes::_anewarray:
1094         { Bytecode_anewarray anew(caller_method(), caller_method-&gt;bcp_from(bci));
1095           Klass* ek = caller_method-&gt;constants()-&gt;klass_at(anew.index(), CHECK);
1096           if (ek-&gt;is_value() &amp;&amp; caller_method-&gt;constants()-&gt;klass_at_noresolve(anew.index())-&gt;is_Q_signature()) {
1097             k = ek-&gt;array_klass(1, CHECK);
<span class="line-modified">1098             assert(ArrayKlass::cast(k)-&gt;storage_properties().is_null_free(), &quot;Expect a null-free array class here&quot;);</span>
1099           } else {
1100             k = ek-&gt;array_klass(CHECK);
1101           }
1102         }
1103         break;
1104       case Bytecodes::_ldc:
1105       case Bytecodes::_ldc_w:
1106         {
1107           Bytecode_loadconstant cc(caller_method, bci);
1108           oop m = cc.resolve_constant(CHECK);
1109           mirror = Handle(THREAD, m);
1110         }
1111         break;
1112       default: fatal(&quot;unexpected bytecode for load_klass_or_mirror_patch_id&quot;);
1113     }
1114     load_klass = k;
1115   } else if (stub_id == load_appendix_patching_id) {
1116     Bytecode_invoke bytecode(caller_method, bci);
1117     Bytecodes::Code bc = bytecode.invoke_code();
1118 
</pre>
</td>
<td>
<hr />
<pre>
 444   thread-&gt;set_vm_result(obj);
 445 JRT_END
 446 
 447 
 448 static void profile_flat_array(JavaThread* thread) {
 449   ResourceMark rm(thread);
 450   vframeStream vfst(thread, true);
 451   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);
 452   int bci = vfst.bci();
 453   Method* method = vfst.method();
 454   MethodData* md = method-&gt;method_data();
 455   if (md != NULL) {
 456     ProfileData* data = md-&gt;bci_to_data(bci);
 457     assert(data != NULL &amp;&amp; data-&gt;is_ArrayLoadStoreData(), &quot;incorrect profiling entry&quot;);
 458     ArrayLoadStoreData* load_store = (ArrayLoadStoreData*)data;
 459     load_store-&gt;set_flat_array();
 460   }
 461 }
 462 
 463 JRT_ENTRY(void, Runtime1::load_flattened_array(JavaThread* thread, valueArrayOopDesc* array, int index))
<span class="line-modified"> 464   assert(array-&gt;klass()-&gt;is_valueArray_klass(), &quot;should not be called&quot;);</span>
 465   profile_flat_array(thread);
 466 
 467   NOT_PRODUCT(_load_flattened_array_slowcase_cnt++;)
 468   assert(array-&gt;length() &gt; 0 &amp;&amp; index &lt; array-&gt;length(), &quot;already checked&quot;);
 469   valueArrayHandle vah(thread, array);
 470   oop obj = valueArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK);
 471   thread-&gt;set_vm_result(obj);
 472 JRT_END
 473 
 474 
 475 JRT_ENTRY(void, Runtime1::store_flattened_array(JavaThread* thread, valueArrayOopDesc* array, int index, oopDesc* value))
<span class="line-modified"> 476   if (array-&gt;klass()-&gt;is_valueArray_klass()) {</span>
 477     profile_flat_array(thread);
 478   }
 479 
 480   NOT_PRODUCT(_store_flattened_array_slowcase_cnt++;)
 481   if (value == NULL) {
<span class="line-modified"> 482     assert(array-&gt;klass()-&gt;is_valueArray_klass() || array-&gt;klass()-&gt;is_null_free_array_klass(), &quot;should not be called&quot;);</span>
 483     SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_NullPointerException());
 484   } else {
<span class="line-modified"> 485     assert(array-&gt;klass()-&gt;is_valueArray_klass(), &quot;should not be called&quot;);</span>
 486     array-&gt;value_copy_to_index(value, index);
 487   }
 488 JRT_END
 489 
 490 
 491 JRT_ENTRY(int, Runtime1::substitutability_check(JavaThread* thread, oopDesc* left, oopDesc* right))
 492   NOT_PRODUCT(_substitutability_check_slowcase_cnt++;)
 493   JavaCallArguments args;
 494   args.push_oop(Handle(THREAD, left));
 495   args.push_oop(Handle(THREAD, right));
 496   JavaValue result(T_BOOLEAN);
 497   JavaCalls::call_static(&amp;result,
 498                          SystemDictionary::ValueBootstrapMethods_klass(),
 499                          vmSymbols::isSubstitutable_name(),
 500                          vmSymbols::object_object_boolean_signature(),
 501                          &amp;args, CHECK_0);
 502   return result.get_jboolean() ? 1 : 0;
 503 JRT_END
 504 
 505 
</pre>
<hr />
<pre>
1078             // Logically creates elements, ensure klass init
1079             k-&gt;initialize(CHECK);
1080           }
1081         }
1082         break;
1083       case Bytecodes::_instanceof:
1084         { Bytecode_instanceof io(caller_method(), caller_method-&gt;bcp_from(bci));
1085           k = caller_method-&gt;constants()-&gt;klass_at(io.index(), CHECK);
1086         }
1087         break;
1088       case Bytecodes::_checkcast:
1089         { Bytecode_checkcast cc(caller_method(), caller_method-&gt;bcp_from(bci));
1090           k = caller_method-&gt;constants()-&gt;klass_at(cc.index(), CHECK);
1091         }
1092         break;
1093       case Bytecodes::_anewarray:
1094         { Bytecode_anewarray anew(caller_method(), caller_method-&gt;bcp_from(bci));
1095           Klass* ek = caller_method-&gt;constants()-&gt;klass_at(anew.index(), CHECK);
1096           if (ek-&gt;is_value() &amp;&amp; caller_method-&gt;constants()-&gt;klass_at_noresolve(anew.index())-&gt;is_Q_signature()) {
1097             k = ek-&gt;array_klass(1, CHECK);
<span class="line-modified">1098             assert(k-&gt;is_null_free_array_klass(), &quot;Expect a null-free array class here&quot;);</span>
1099           } else {
1100             k = ek-&gt;array_klass(CHECK);
1101           }
1102         }
1103         break;
1104       case Bytecodes::_ldc:
1105       case Bytecodes::_ldc_w:
1106         {
1107           Bytecode_loadconstant cc(caller_method, bci);
1108           oop m = cc.resolve_constant(CHECK);
1109           mirror = Handle(THREAD, m);
1110         }
1111         break;
1112       default: fatal(&quot;unexpected bytecode for load_klass_or_mirror_patch_id&quot;);
1113     }
1114     load_klass = k;
1115   } else if (stub_id == load_appendix_patching_id) {
1116     Bytecode_invoke bytecode(caller_method, bci);
1117     Bytecodes::Code bc = bytecode.invoke_code();
1118 
</pre>
</td>
</tr>
</table>
<center><a href="../../cpu/x86/templateTable_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../memory/oopFactory.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
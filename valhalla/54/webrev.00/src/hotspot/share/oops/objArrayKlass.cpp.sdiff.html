<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/objArrayKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="klass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueArrayKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/objArrayKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
122   this-&gt;set_dimension(n);
123   this-&gt;set_element_klass(element_klass);
124   // decrement refcount because object arrays are not explicitly freed.  The
125   // InstanceKlass array_name() keeps the name counted while the klass is
126   // loaded.
127   name-&gt;decrement_refcount();
128 
129   Klass* bk;
130   if (element_klass-&gt;is_objArray_klass()) {
131     bk = ObjArrayKlass::cast(element_klass)-&gt;bottom_klass();
132   } else if (element_klass-&gt;is_valueArray_klass()) {
133     bk = ValueArrayKlass::cast(element_klass)-&gt;element_klass();
134   } else {
135     bk = element_klass;
136   }
137   assert(bk != NULL &amp;&amp; (bk-&gt;is_instance_klass()
138       || bk-&gt;is_typeArray_klass()), &quot;invalid bottom klass&quot;);
139   this-&gt;set_bottom_klass(bk);
140   this-&gt;set_class_loader_data(bk-&gt;class_loader_data());
141 
<span class="line-modified">142   this-&gt;set_layout_helper(array_layout_helper(T_OBJECT));</span>




143   assert(this-&gt;is_array_klass(), &quot;sanity&quot;);
144   assert(this-&gt;is_objArray_klass(), &quot;sanity&quot;);
145 }
146 
147 int ObjArrayKlass::oop_size(oop obj) const {
148   assert(obj-&gt;is_objArray(), &quot;must be object array&quot;);
149   return objArrayOop(obj)-&gt;object_size();
150 }
151 
152 objArrayOop ObjArrayKlass::allocate(int length, TRAPS) {
153   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);
154   int size = objArrayOopDesc::object_size(length);
155   bool populate_null_free = storage_properties().is_null_free();
156   objArrayOop array =  (objArrayOop)Universe::heap()-&gt;array_allocate(this, size, length,
157                                                        /* do_zero */ true, THREAD);
158   if (populate_null_free) {
159     assert(dimension() == 1, &quot;Can only populate the final dimension&quot;);
160     assert(element_klass()-&gt;is_value(), &quot;Unexpected&quot;);
161     assert(!element_klass()-&gt;is_array_klass(), &quot;ArrayKlass unexpected here&quot;);
162     assert(!ValueKlass::cast(element_klass())-&gt;flatten_array(), &quot;Expected valueArrayOop allocation&quot;);
</pre>
<hr />
<pre>
206   }
207   return h_array();
208 }
209 
210 ArrayStorageProperties ObjArrayKlass::storage_properties() {
211   return name()-&gt;is_Q_singledim_array_signature() ? ArrayStorageProperties::null_free : ArrayStorageProperties::empty;
212 }
213 
214 // Either oop or narrowOop depending on UseCompressedOops.
215 void ObjArrayKlass::do_copy(arrayOop s, size_t src_offset,
216                             arrayOop d, size_t dst_offset, int length, TRAPS) {
217   if (s == d) {
218     // since source and destination are equal we do not need conversion checks.
219     assert(length &gt; 0, &quot;sanity check&quot;);
220     ArrayAccess&lt;&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
221   } else {
222     // We have to make sure all elements conform to the destination array
223     Klass* bound = ObjArrayKlass::cast(d-&gt;klass())-&gt;element_klass();
224     Klass* stype = ObjArrayKlass::cast(s-&gt;klass())-&gt;element_klass();
225     // Perform null check if dst is null-free but src has no such guarantee
<span class="line-modified">226     bool null_check = ((!ArrayKlass::cast(s-&gt;klass())-&gt;storage_properties().is_null_free()) &amp;&amp;</span>
<span class="line-modified">227         ArrayKlass::cast(d-&gt;klass())-&gt;storage_properties().is_null_free());</span>
228     if (stype == bound || stype-&gt;is_subtype_of(bound)) {
229       if (null_check) {
230         ArrayAccess&lt;ARRAYCOPY_DISJOINT | ARRAYCOPY_NOTNULL&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
231       } else {
232         ArrayAccess&lt;ARRAYCOPY_DISJOINT&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
233       }
234     } else {
235       if (null_check) {
236         ArrayAccess&lt;ARRAYCOPY_DISJOINT | ARRAYCOPY_CHECKCAST | ARRAYCOPY_NOTNULL&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
237       } else {
238         ArrayAccess&lt;ARRAYCOPY_DISJOINT | ARRAYCOPY_CHECKCAST&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
239       }
240     }
241   }
242 }
243 
244 void ObjArrayKlass::copy_array(arrayOop s, int src_pos, arrayOop d,
245                                int dst_pos, int length, TRAPS) {
246   assert(s-&gt;is_objArray(), &quot;must be obj array&quot;);
247 
</pre>
</td>
<td>
<hr />
<pre>
122   this-&gt;set_dimension(n);
123   this-&gt;set_element_klass(element_klass);
124   // decrement refcount because object arrays are not explicitly freed.  The
125   // InstanceKlass array_name() keeps the name counted while the klass is
126   // loaded.
127   name-&gt;decrement_refcount();
128 
129   Klass* bk;
130   if (element_klass-&gt;is_objArray_klass()) {
131     bk = ObjArrayKlass::cast(element_klass)-&gt;bottom_klass();
132   } else if (element_klass-&gt;is_valueArray_klass()) {
133     bk = ValueArrayKlass::cast(element_klass)-&gt;element_klass();
134   } else {
135     bk = element_klass;
136   }
137   assert(bk != NULL &amp;&amp; (bk-&gt;is_instance_klass()
138       || bk-&gt;is_typeArray_klass()), &quot;invalid bottom klass&quot;);
139   this-&gt;set_bottom_klass(bk);
140   this-&gt;set_class_loader_data(bk-&gt;class_loader_data());
141 
<span class="line-modified">142   jint lh = array_layout_helper(T_OBJECT);</span>
<span class="line-added">143   if (element_klass-&gt;is_value()) {</span>
<span class="line-added">144     lh = layout_helper_set_null_free(lh);</span>
<span class="line-added">145   }</span>
<span class="line-added">146   this-&gt;set_layout_helper(lh);</span>
147   assert(this-&gt;is_array_klass(), &quot;sanity&quot;);
148   assert(this-&gt;is_objArray_klass(), &quot;sanity&quot;);
149 }
150 
151 int ObjArrayKlass::oop_size(oop obj) const {
152   assert(obj-&gt;is_objArray(), &quot;must be object array&quot;);
153   return objArrayOop(obj)-&gt;object_size();
154 }
155 
156 objArrayOop ObjArrayKlass::allocate(int length, TRAPS) {
157   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);
158   int size = objArrayOopDesc::object_size(length);
159   bool populate_null_free = storage_properties().is_null_free();
160   objArrayOop array =  (objArrayOop)Universe::heap()-&gt;array_allocate(this, size, length,
161                                                        /* do_zero */ true, THREAD);
162   if (populate_null_free) {
163     assert(dimension() == 1, &quot;Can only populate the final dimension&quot;);
164     assert(element_klass()-&gt;is_value(), &quot;Unexpected&quot;);
165     assert(!element_klass()-&gt;is_array_klass(), &quot;ArrayKlass unexpected here&quot;);
166     assert(!ValueKlass::cast(element_klass())-&gt;flatten_array(), &quot;Expected valueArrayOop allocation&quot;);
</pre>
<hr />
<pre>
210   }
211   return h_array();
212 }
213 
214 ArrayStorageProperties ObjArrayKlass::storage_properties() {
215   return name()-&gt;is_Q_singledim_array_signature() ? ArrayStorageProperties::null_free : ArrayStorageProperties::empty;
216 }
217 
218 // Either oop or narrowOop depending on UseCompressedOops.
219 void ObjArrayKlass::do_copy(arrayOop s, size_t src_offset,
220                             arrayOop d, size_t dst_offset, int length, TRAPS) {
221   if (s == d) {
222     // since source and destination are equal we do not need conversion checks.
223     assert(length &gt; 0, &quot;sanity check&quot;);
224     ArrayAccess&lt;&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
225   } else {
226     // We have to make sure all elements conform to the destination array
227     Klass* bound = ObjArrayKlass::cast(d-&gt;klass())-&gt;element_klass();
228     Klass* stype = ObjArrayKlass::cast(s-&gt;klass())-&gt;element_klass();
229     // Perform null check if dst is null-free but src has no such guarantee
<span class="line-modified">230     bool null_check = ((!s-&gt;klass()-&gt;is_null_free_array_klass()) &amp;&amp;</span>
<span class="line-modified">231         d-&gt;klass()-&gt;is_null_free_array_klass());</span>
232     if (stype == bound || stype-&gt;is_subtype_of(bound)) {
233       if (null_check) {
234         ArrayAccess&lt;ARRAYCOPY_DISJOINT | ARRAYCOPY_NOTNULL&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
235       } else {
236         ArrayAccess&lt;ARRAYCOPY_DISJOINT&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
237       }
238     } else {
239       if (null_check) {
240         ArrayAccess&lt;ARRAYCOPY_DISJOINT | ARRAYCOPY_CHECKCAST | ARRAYCOPY_NOTNULL&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
241       } else {
242         ArrayAccess&lt;ARRAYCOPY_DISJOINT | ARRAYCOPY_CHECKCAST&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
243       }
244     }
245   }
246 }
247 
248 void ObjArrayKlass::copy_array(arrayOop s, int src_pos, arrayOop d,
249                                int dst_pos, int length, TRAPS) {
250   assert(s-&gt;is_objArray(), &quot;must be obj array&quot;);
251 
</pre>
</td>
</tr>
</table>
<center><a href="klass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueArrayKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/x86/macroAssembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef CPU_X86_MACROASSEMBLER_X86_HPP
  26 #define CPU_X86_MACROASSEMBLER_X86_HPP
  27 
  28 #include &quot;asm/assembler.hpp&quot;
  29 #include &quot;utilities/macros.hpp&quot;
  30 #include &quot;runtime/rtmLocking.hpp&quot;
  31 #include &quot;runtime/signature.hpp&quot;
  32 
  33 class ciValueKlass;
  34 
  35 // MacroAssembler extends Assembler by frequently used macros.
  36 //
  37 // Instructions for which a &#39;better&#39; code sequence exists depending
  38 // on arguments should also go in here.
  39 
  40 class MacroAssembler: public Assembler {
  41   friend class LIR_Assembler;
  42   friend class Runtime1;      // as_Address()
  43 
  44  public:
  45   // Support for VM calls
  46   //
  47   // This is the base routine called by the different versions of call_VM_leaf. The interpreter
  48   // may customize this version by overriding it for its purposes (e.g., to save/restore
  49   // additional registers when doing a VM call).
  50 
  51   virtual void call_VM_leaf_base(
  52     address entry_point,               // the entry point
  53     int     number_of_arguments        // the number of arguments to pop after the call
  54   );
  55 
  56  protected:
  57   // This is the base routine called by the different versions of call_VM. The interpreter
  58   // may customize this version by overriding it for its purposes (e.g., to save/restore
  59   // additional registers when doing a VM call).
  60   //
  61   // If no java_thread register is specified (noreg) than rdi will be used instead. call_VM_base
  62   // returns the register which contains the thread upon return. If a thread register has been
  63   // specified, the return value will correspond to that register. If no last_java_sp is specified
  64   // (noreg) than rsp will be used instead.
  65   virtual void call_VM_base(           // returns the register containing the thread upon return
  66     Register oop_result,               // where an oop-result ends up if any; use noreg otherwise
  67     Register java_thread,              // the thread if computed before     ; use noreg otherwise
  68     Register last_java_sp,             // to set up last_Java_frame in stubs; use noreg otherwise
  69     address  entry_point,              // the entry point
  70     int      number_of_arguments,      // the number of arguments (w/o thread) to pop after the call
  71     bool     check_exceptions          // whether to check for pending exceptions after return
  72   );
  73 
  74   void call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions = true);
  75 
  76   // helpers for FPU flag access
  77   // tmp is a temporary register, if none is available use noreg
  78   void save_rax   (Register tmp);
  79   void restore_rax(Register tmp);
  80 
  81  public:
  82   MacroAssembler(CodeBuffer* code) : Assembler(code) {}
  83 
  84  // These routines should emit JVMTI PopFrame and ForceEarlyReturn handling code.
  85  // The implementation is only non-empty for the InterpreterMacroAssembler,
  86  // as only the interpreter handles PopFrame and ForceEarlyReturn requests.
  87  virtual void check_and_handle_popframe(Register java_thread);
  88  virtual void check_and_handle_earlyret(Register java_thread);
  89 
  90   Address as_Address(AddressLiteral adr);
  91   Address as_Address(ArrayAddress adr);
  92 
  93   // Support for NULL-checks
  94   //
  95   // Generates code that causes a NULL OS exception if the content of reg is NULL.
  96   // If the accessed location is M[reg + offset] and the offset is known, provide the
  97   // offset. No explicit code generation is needed if the offset is within a certain
  98   // range (0 &lt;= offset &lt;= page_size).
  99 
 100   void null_check(Register reg, int offset = -1);
 101   static bool needs_explicit_null_check(intptr_t offset);
 102   static bool uses_implicit_null_check(void* address);
 103 
 104   // valueKlass queries, kills temp_reg
 105   void test_klass_is_value(Register klass, Register temp_reg, Label&amp; is_value);
 106   void test_klass_is_empty_value(Register klass, Register temp_reg, Label&amp; is_empty_value);
 107 
 108   // Get the default value oop for the given ValueKlass
 109   void get_default_value_oop(Register value_klass, Register temp_reg, Register obj);
 110   // The empty value oop, for the given ValueKlass (&quot;empty&quot; as in no instance fields)
 111   // get_default_value_oop with extra assertion for empty value klass
 112   void get_empty_value_oop(Register value_klass, Register temp_reg, Register obj);
 113 
 114   void test_field_is_flattenable(Register flags, Register temp_reg, Label&amp; is_flattenable);
 115   void test_field_is_not_flattenable(Register flags, Register temp_reg, Label&amp; notFlattenable);
 116   void test_field_is_flattened(Register flags, Register temp_reg, Label&amp; is_flattened);
 117 
 118   // Check oops array storage properties, i.e. flattened and/or null-free
 119   void test_flattened_array_oop(Register oop, Register temp_reg, Label&amp;is_flattened_array);
 120   void test_non_flattened_array_oop(Register oop, Register temp_reg, Label&amp;is_non_flattened_array);
 121   void test_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_null_free_array);
 122   void test_non_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_non_null_free_array);
 123 
 124   // Check array klass layout helper for flatten or null-free arrays...
 125   void test_flattened_array_layout(Register lh, Label&amp; is_flattened_array);
 126   void test_non_flattened_array_layout(Register lh, Label&amp; is_non_flattened_array);
 127   void test_null_free_array_layout(Register lh, Label&amp; is_null_free_array);
 128   void test_non_null_free_array_layout(Register lh, Label&amp; is_non_null_free_array);
 129 
 130   // Required platform-specific helpers for Label::patch_instructions.
 131   // They _shadow_ the declarations in AbstractAssembler, which are undefined.
 132   void pd_patch_instruction(address branch, address target, const char* file, int line) {
 133     unsigned char op = branch[0];
 134     assert(op == 0xE8 /* call */ ||
 135         op == 0xE9 /* jmp */ ||
 136         op == 0xEB /* short jmp */ ||
 137         (op &amp; 0xF0) == 0x70 /* short jcc */ ||
 138         op == 0x0F &amp;&amp; (branch[1] &amp; 0xF0) == 0x80 /* jcc */ ||
 139         op == 0xC7 &amp;&amp; branch[1] == 0xF8 /* xbegin */,
 140         &quot;Invalid opcode at patch point&quot;);
 141 
 142     if (op == 0xEB || (op &amp; 0xF0) == 0x70) {
 143       // short offset operators (jmp and jcc)
 144       char* disp = (char*) &amp;branch[1];
 145       int imm8 = target - (address) &amp;disp[1];
 146       guarantee(this-&gt;is8bit(imm8), &quot;Short forward jump exceeds 8-bit offset at %s:%d&quot;,
 147                 file == NULL ? &quot;&lt;NULL&gt;&quot; : file, line);
 148       *disp = imm8;
 149     } else {
 150       int* disp = (int*) &amp;branch[(op == 0x0F || op == 0xC7)? 2: 1];
 151       int imm32 = target - (address) &amp;disp[1];
 152       *disp = imm32;
 153     }
 154   }
 155 
 156   // The following 4 methods return the offset of the appropriate move instruction
 157 
 158   // Support for fast byte/short loading with zero extension (depending on particular CPU)
 159   int load_unsigned_byte(Register dst, Address src);
 160   int load_unsigned_short(Register dst, Address src);
 161 
 162   // Support for fast byte/short loading with sign extension (depending on particular CPU)
 163   int load_signed_byte(Register dst, Address src);
 164   int load_signed_short(Register dst, Address src);
 165 
 166   // Support for sign-extension (hi:lo = extend_sign(lo))
 167   void extend_sign(Register hi, Register lo);
 168 
 169   // Load and store values by size and signed-ness
 170   void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2 = noreg);
 171   void store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2 = noreg);
 172 
 173   // Support for inc/dec with optimal instruction selection depending on value
 174 
 175   void increment(Register reg, int value = 1) { LP64_ONLY(incrementq(reg, value)) NOT_LP64(incrementl(reg, value)) ; }
 176   void decrement(Register reg, int value = 1) { LP64_ONLY(decrementq(reg, value)) NOT_LP64(decrementl(reg, value)) ; }
 177 
 178   void decrementl(Address dst, int value = 1);
 179   void decrementl(Register reg, int value = 1);
 180 
 181   void decrementq(Register reg, int value = 1);
 182   void decrementq(Address dst, int value = 1);
 183 
 184   void incrementl(Address dst, int value = 1);
 185   void incrementl(Register reg, int value = 1);
 186 
 187   void incrementq(Register reg, int value = 1);
 188   void incrementq(Address dst, int value = 1);
 189 
 190   // Support optimal SSE move instructions.
 191   void movflt(XMMRegister dst, XMMRegister src) {
 192     if (dst-&gt; encoding() == src-&gt;encoding()) return;
 193     if (UseXmmRegToRegMoveAll) { movaps(dst, src); return; }
 194     else                       { movss (dst, src); return; }
 195   }
 196   void movflt(XMMRegister dst, Address src) { movss(dst, src); }
 197   void movflt(XMMRegister dst, AddressLiteral src);
 198   void movflt(Address dst, XMMRegister src) { movss(dst, src); }
 199 
 200   void movdbl(XMMRegister dst, XMMRegister src) {
 201     if (dst-&gt; encoding() == src-&gt;encoding()) return;
 202     if (UseXmmRegToRegMoveAll) { movapd(dst, src); return; }
 203     else                       { movsd (dst, src); return; }
 204   }
 205 
 206   void movdbl(XMMRegister dst, AddressLiteral src);
 207 
 208   void movdbl(XMMRegister dst, Address src) {
 209     if (UseXmmLoadAndClearUpper) { movsd (dst, src); return; }
 210     else                         { movlpd(dst, src); return; }
 211   }
 212   void movdbl(Address dst, XMMRegister src) { movsd(dst, src); }
 213 
 214   void incrementl(AddressLiteral dst);
 215   void incrementl(ArrayAddress dst);
 216 
 217   void incrementq(AddressLiteral dst);
 218 
 219   // Alignment
 220   void align(int modulus);
 221   void align(int modulus, int target);
 222 
 223   // A 5 byte nop that is safe for patching (see patch_verified_entry)
 224   void fat_nop();
 225 
 226   // Stack frame creation/removal
 227   void enter();
 228   void leave();
 229 
 230   // Support for getting the JavaThread pointer (i.e.; a reference to thread-local information)
 231   // The pointer will be loaded into the thread register.
 232   void get_thread(Register thread);
 233 
 234 
 235   // Support for VM calls
 236   //
 237   // It is imperative that all calls into the VM are handled via the call_VM macros.
 238   // They make sure that the stack linkage is setup correctly. call_VM&#39;s correspond
 239   // to ENTRY/ENTRY_X entry points while call_VM_leaf&#39;s correspond to LEAF entry points.
 240 
 241 
 242   void call_VM(Register oop_result,
 243                address entry_point,
 244                bool check_exceptions = true);
 245   void call_VM(Register oop_result,
 246                address entry_point,
 247                Register arg_1,
 248                bool check_exceptions = true);
 249   void call_VM(Register oop_result,
 250                address entry_point,
 251                Register arg_1, Register arg_2,
 252                bool check_exceptions = true);
 253   void call_VM(Register oop_result,
 254                address entry_point,
 255                Register arg_1, Register arg_2, Register arg_3,
 256                bool check_exceptions = true);
 257 
 258   // Overloadings with last_Java_sp
 259   void call_VM(Register oop_result,
 260                Register last_java_sp,
 261                address entry_point,
 262                int number_of_arguments = 0,
 263                bool check_exceptions = true);
 264   void call_VM(Register oop_result,
 265                Register last_java_sp,
 266                address entry_point,
 267                Register arg_1, bool
 268                check_exceptions = true);
 269   void call_VM(Register oop_result,
 270                Register last_java_sp,
 271                address entry_point,
 272                Register arg_1, Register arg_2,
 273                bool check_exceptions = true);
 274   void call_VM(Register oop_result,
 275                Register last_java_sp,
 276                address entry_point,
 277                Register arg_1, Register arg_2, Register arg_3,
 278                bool check_exceptions = true);
 279 
 280   void get_vm_result  (Register oop_result, Register thread);
 281   void get_vm_result_2(Register metadata_result, Register thread);
 282 
 283   // These always tightly bind to MacroAssembler::call_VM_base
 284   // bypassing the virtual implementation
 285   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, int number_of_arguments = 0, bool check_exceptions = true);
 286   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions = true);
 287   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, bool check_exceptions = true);
 288   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions = true);
 289   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4, bool check_exceptions = true);
 290 
 291   void call_VM_leaf0(address entry_point);
 292   void call_VM_leaf(address entry_point,
 293                     int number_of_arguments = 0);
 294   void call_VM_leaf(address entry_point,
 295                     Register arg_1);
 296   void call_VM_leaf(address entry_point,
 297                     Register arg_1, Register arg_2);
 298   void call_VM_leaf(address entry_point,
 299                     Register arg_1, Register arg_2, Register arg_3);
 300 
 301   // These always tightly bind to MacroAssembler::call_VM_leaf_base
 302   // bypassing the virtual implementation
 303   void super_call_VM_leaf(address entry_point);
 304   void super_call_VM_leaf(address entry_point, Register arg_1);
 305   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2);
 306   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3);
 307   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4);
 308 
 309   // last Java Frame (fills frame anchor)
 310   void set_last_Java_frame(Register thread,
 311                            Register last_java_sp,
 312                            Register last_java_fp,
 313                            address last_java_pc);
 314 
 315   // thread in the default location (r15_thread on 64bit)
 316   void set_last_Java_frame(Register last_java_sp,
 317                            Register last_java_fp,
 318                            address last_java_pc);
 319 
 320   void reset_last_Java_frame(Register thread, bool clear_fp);
 321 
 322   // thread in the default location (r15_thread on 64bit)
 323   void reset_last_Java_frame(bool clear_fp);
 324 
 325   // jobjects
 326   void clear_jweak_tag(Register possibly_jweak);
 327   void resolve_jobject(Register value, Register thread, Register tmp);
 328 
 329   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 330   void c2bool(Register x);
 331 
 332   // C++ bool manipulation
 333 
 334   void movbool(Register dst, Address src);
 335   void movbool(Address dst, bool boolconst);
 336   void movbool(Address dst, Register src);
 337   void testbool(Register dst);
 338 
 339   void resolve_oop_handle(Register result, Register tmp = rscratch2);
 340   void resolve_weak_handle(Register result, Register tmp);
 341   void load_mirror(Register mirror, Register method, Register tmp = rscratch2);
 342   void load_method_holder_cld(Register rresult, Register rmethod);
 343 
 344   void load_method_holder(Register holder, Register method);
 345 
 346   // oop manipulations
 347   void load_metadata(Register dst, Register src);
 348   void load_storage_props(Register dst, Register src);
 349   void load_klass(Register dst, Register src);
 350   void store_klass(Register dst, Register src);
 351 
 352   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 353                       Register tmp1, Register thread_tmp);
 354   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 355                        Register tmp1, Register tmp2, Register tmp3 = noreg);
 356 
 357   void access_value_copy(DecoratorSet decorators, Register src, Register dst, Register value_klass);
 358 
 359   // value type data payload offsets...
 360   void first_field_offset(Register value_klass, Register offset);
 361   void data_for_oop(Register oop, Register data, Register value_klass);
 362   // get data payload ptr a flat value array at index, kills rcx and index
 363   void data_for_value_array_index(Register array, Register array_klass,
 364                                   Register index, Register data);
 365 
 366 
 367   // Resolves obj access. Result is placed in the same register.
 368   // All other registers are preserved.
 369   void resolve(DecoratorSet decorators, Register obj);
 370 
 371   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 372                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 373   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 374                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 375   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
 376                       Register tmp2 = noreg, Register tmp3 = noreg, DecoratorSet decorators = 0);
 377 
 378   // Used for storing NULL. All other oop constants should be
 379   // stored using routines that take a jobject.
 380   void store_heap_oop_null(Address dst);
 381 
 382   void load_prototype_header(Register dst, Register src);
 383 
 384 #ifdef _LP64
 385   void store_klass_gap(Register dst, Register src);
 386 
 387   // This dummy is to prevent a call to store_heap_oop from
 388   // converting a zero (like NULL) into a Register by giving
 389   // the compiler two choices it can&#39;t resolve
 390 
 391   void store_heap_oop(Address dst, void* dummy);
 392 
 393   void encode_heap_oop(Register r);
 394   void decode_heap_oop(Register r);
 395   void encode_heap_oop_not_null(Register r);
 396   void decode_heap_oop_not_null(Register r);
 397   void encode_heap_oop_not_null(Register dst, Register src);
 398   void decode_heap_oop_not_null(Register dst, Register src);
 399 
 400   void set_narrow_oop(Register dst, jobject obj);
 401   void set_narrow_oop(Address dst, jobject obj);
 402   void cmp_narrow_oop(Register dst, jobject obj);
 403   void cmp_narrow_oop(Address dst, jobject obj);
 404 
 405   void encode_klass_not_null(Register r);
 406   void decode_klass_not_null(Register r);
 407   void encode_klass_not_null(Register dst, Register src);
 408   void decode_klass_not_null(Register dst, Register src);
 409   void set_narrow_klass(Register dst, Klass* k);
 410   void set_narrow_klass(Address dst, Klass* k);
 411   void cmp_narrow_klass(Register dst, Klass* k);
 412   void cmp_narrow_klass(Address dst, Klass* k);
 413 
 414   // Returns the byte size of the instructions generated by decode_klass_not_null()
 415   // when compressed klass pointers are being used.
 416   static int instr_size_for_decode_klass_not_null();
 417 
 418   // if heap base register is used - reinit it with the correct value
 419   void reinit_heapbase();
 420 
 421   DEBUG_ONLY(void verify_heapbase(const char* msg);)
 422 
 423 #endif // _LP64
 424 
 425   // Int division/remainder for Java
 426   // (as idivl, but checks for special case as described in JVM spec.)
 427   // returns idivl instruction offset for implicit exception handling
 428   int corrected_idivl(Register reg);
 429 
 430   // Long division/remainder for Java
 431   // (as idivq, but checks for special case as described in JVM spec.)
 432   // returns idivq instruction offset for implicit exception handling
 433   int corrected_idivq(Register reg);
 434 
 435   void int3();
 436 
 437   // Long operation macros for a 32bit cpu
 438   // Long negation for Java
 439   void lneg(Register hi, Register lo);
 440 
 441   // Long multiplication for Java
 442   // (destroys contents of eax, ebx, ecx and edx)
 443   void lmul(int x_rsp_offset, int y_rsp_offset); // rdx:rax = x * y
 444 
 445   // Long shifts for Java
 446   // (semantics as described in JVM spec.)
 447   void lshl(Register hi, Register lo);                               // hi:lo &lt;&lt; (rcx &amp; 0x3f)
 448   void lshr(Register hi, Register lo, bool sign_extension = false);  // hi:lo &gt;&gt; (rcx &amp; 0x3f)
 449 
 450   // Long compare for Java
 451   // (semantics as described in JVM spec.)
 452   void lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo); // x_hi = lcmp(x, y)
 453 
 454 
 455   // misc
 456 
 457   // Sign extension
 458   void sign_extend_short(Register reg);
 459   void sign_extend_byte(Register reg);
 460 
 461   // Division by power of 2, rounding towards 0
 462   void division_with_shift(Register reg, int shift_value);
 463 
 464 #ifndef _LP64
 465   // Compares the top-most stack entries on the FPU stack and sets the eflags as follows:
 466   //
 467   // CF (corresponds to C0) if x &lt; y
 468   // PF (corresponds to C2) if unordered
 469   // ZF (corresponds to C3) if x = y
 470   //
 471   // The arguments are in reversed order on the stack (i.e., top of stack is first argument).
 472   // tmp is a temporary register, if none is available use noreg (only matters for non-P6 code)
 473   void fcmp(Register tmp);
 474   // Variant of the above which allows y to be further down the stack
 475   // and which only pops x and y if specified. If pop_right is
 476   // specified then pop_left must also be specified.
 477   void fcmp(Register tmp, int index, bool pop_left, bool pop_right);
 478 
 479   // Floating-point comparison for Java
 480   // Compares the top-most stack entries on the FPU stack and stores the result in dst.
 481   // The arguments are in reversed order on the stack (i.e., top of stack is first argument).
 482   // (semantics as described in JVM spec.)
 483   void fcmp2int(Register dst, bool unordered_is_less);
 484   // Variant of the above which allows y to be further down the stack
 485   // and which only pops x and y if specified. If pop_right is
 486   // specified then pop_left must also be specified.
 487   void fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right);
 488 
 489   // Floating-point remainder for Java (ST0 = ST0 fremr ST1, ST1 is empty afterwards)
 490   // tmp is a temporary register, if none is available use noreg
 491   void fremr(Register tmp);
 492 
 493   // only if +VerifyFPU
 494   void verify_FPU(int stack_depth, const char* s = &quot;illegal FPU state&quot;);
 495 #endif // !LP64
 496 
 497   // dst = c = a * b + c
 498   void fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c);
 499   void fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c);
 500 
 501   void vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len);
 502   void vfmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len);
 503   void vfmad(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len);
 504   void vfmaf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len);
 505 
 506 
 507   // same as fcmp2int, but using SSE2
 508   void cmpss2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less);
 509   void cmpsd2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less);
 510 
 511   // branch to L if FPU flag C2 is set/not set
 512   // tmp is a temporary register, if none is available use noreg
 513   void jC2 (Register tmp, Label&amp; L);
 514   void jnC2(Register tmp, Label&amp; L);
 515 
 516   // Load float value from &#39;address&#39;. If UseSSE &gt;= 1, the value is loaded into
 517   // register xmm0. Otherwise, the value is loaded onto the FPU stack.
 518   void load_float(Address src);
 519 
 520   // Store float value to &#39;address&#39;. If UseSSE &gt;= 1, the value is stored
 521   // from register xmm0. Otherwise, the value is stored from the FPU stack.
 522   void store_float(Address dst);
 523 
 524   // Load double value from &#39;address&#39;. If UseSSE &gt;= 2, the value is loaded into
 525   // register xmm0. Otherwise, the value is loaded onto the FPU stack.
 526   void load_double(Address src);
 527 
 528   // Store double value to &#39;address&#39;. If UseSSE &gt;= 2, the value is stored
 529   // from register xmm0. Otherwise, the value is stored from the FPU stack.
 530   void store_double(Address dst);
 531 
 532 #ifndef _LP64
 533   // Pop ST (ffree &amp; fincstp combined)
 534   void fpop();
 535 
 536   void empty_FPU_stack();
 537 #endif // !_LP64
 538 
 539   void push_IU_state();
 540   void pop_IU_state();
 541 
 542   void push_FPU_state();
 543   void pop_FPU_state();
 544 
 545   void push_CPU_state();
 546   void pop_CPU_state();
 547 
 548   // Round up to a power of two
 549   void round_to(Register reg, int modulus);
 550 
 551   // Callee saved registers handling
 552   void push_callee_saved_registers();
 553   void pop_callee_saved_registers();
 554 
 555   // allocation
 556 
 557   // Object / value buffer allocation...
 558   // Allocate instance of klass, assumes klass initialized by caller
 559   // new_obj prefers to be rax
 560   // Kills t1 and t2, perserves klass, return allocation in new_obj (rsi on LP64)
 561   void allocate_instance(Register klass, Register new_obj,
 562                          Register t1, Register t2,
 563                          bool clear_fields, Label&amp; alloc_failed);
 564 
 565   void eden_allocate(
 566     Register thread,                   // Current thread
 567     Register obj,                      // result: pointer to object after successful allocation
 568     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 569     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 570     Register t1,                       // temp register
 571     Label&amp;   slow_case                 // continuation point if fast allocation fails
 572   );
 573   void tlab_allocate(
 574     Register thread,                   // Current thread
 575     Register obj,                      // result: pointer to object after successful allocation
 576     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 577     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 578     Register t1,                       // temp register
 579     Register t2,                       // temp register
 580     Label&amp;   slow_case                 // continuation point if fast allocation fails
 581   );
 582   void zero_memory(Register address, Register length_in_bytes, int offset_in_bytes, Register temp);
 583 
 584   // For field &quot;index&quot; within &quot;klass&quot;, return value_klass ...
 585   void get_value_field_klass(Register klass, Register index, Register value_klass);
 586 
 587   // interface method calling
 588   void lookup_interface_method(Register recv_klass,
 589                                Register intf_klass,
 590                                RegisterOrConstant itable_index,
 591                                Register method_result,
 592                                Register scan_temp,
 593                                Label&amp; no_such_interface,
 594                                bool return_method = true);
 595 
 596   // virtual method calling
 597   void lookup_virtual_method(Register recv_klass,
 598                              RegisterOrConstant vtable_index,
 599                              Register method_result);
 600 
 601   // Test sub_klass against super_klass, with fast and slow paths.
 602 
 603   // The fast path produces a tri-state answer: yes / no / maybe-slow.
 604   // One of the three labels can be NULL, meaning take the fall-through.
 605   // If super_check_offset is -1, the value is loaded up from super_klass.
 606   // No registers are killed, except temp_reg.
 607   void check_klass_subtype_fast_path(Register sub_klass,
 608                                      Register super_klass,
 609                                      Register temp_reg,
 610                                      Label* L_success,
 611                                      Label* L_failure,
 612                                      Label* L_slow_path,
 613                 RegisterOrConstant super_check_offset = RegisterOrConstant(-1));
 614 
 615   // The rest of the type check; must be wired to a corresponding fast path.
 616   // It does not repeat the fast path logic, so don&#39;t use it standalone.
 617   // The temp_reg and temp2_reg can be noreg, if no temps are available.
 618   // Updates the sub&#39;s secondary super cache as necessary.
 619   // If set_cond_codes, condition codes will be Z on success, NZ on failure.
 620   void check_klass_subtype_slow_path(Register sub_klass,
 621                                      Register super_klass,
 622                                      Register temp_reg,
 623                                      Register temp2_reg,
 624                                      Label* L_success,
 625                                      Label* L_failure,
 626                                      bool set_cond_codes = false);
 627 
 628   // Simplified, combined version, good for typical uses.
 629   // Falls through on failure.
 630   void check_klass_subtype(Register sub_klass,
 631                            Register super_klass,
 632                            Register temp_reg,
 633                            Label&amp; L_success);
 634 
 635   void clinit_barrier(Register klass,
 636                       Register thread,
 637                       Label* L_fast_path = NULL,
 638                       Label* L_slow_path = NULL);
 639 
 640   // method handles (JSR 292)
 641   Address argument_address(RegisterOrConstant arg_slot, int extra_slot_offset = 0);
 642 
 643   //----
 644   void set_word_if_not_zero(Register reg); // sets reg to 1 if not zero, otherwise 0
 645 
 646   // Debugging
 647 
 648   // only if +VerifyOops
 649   void _verify_oop(Register reg, const char* s, const char* file, int line);
 650   void _verify_oop_addr(Address addr, const char* s, const char* file, int line);
 651 
 652   // TODO: verify method and klass metadata (compare against vptr?)
 653   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
 654   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}
 655 
 656 #define verify_oop(reg) _verify_oop(reg, &quot;broken oop &quot; #reg, __FILE__, __LINE__)
 657 #define verify_oop_msg(reg, msg) _verify_oop(reg, &quot;broken oop &quot; #reg &quot;, &quot; #msg, __FILE__, __LINE__)
 658 #define verify_oop_addr(addr) _verify_oop_addr(addr, &quot;broken oop addr &quot; #addr, __FILE__, __LINE__)
 659 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
 660 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
 661 
 662   // Verify or restore cpu control state after JNI call
 663   void restore_cpu_control_state_after_jni();
 664 
 665   // prints msg, dumps registers and stops execution
 666   void stop(const char* msg);
 667 
 668   // prints msg and continues
 669   void warn(const char* msg);
 670 
 671   // dumps registers and other state
 672   void print_state();
 673 
 674   static void debug32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip, char* msg);
 675   static void debug64(char* msg, int64_t pc, int64_t regs[]);
 676   static void print_state32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip);
 677   static void print_state64(int64_t pc, int64_t regs[]);
 678 
 679   void os_breakpoint();
 680 
 681   void untested()                                { stop(&quot;untested&quot;); }
 682 
 683   void unimplemented(const char* what = &quot;&quot;);
 684 
 685   void should_not_reach_here()                   { stop(&quot;should not reach here&quot;); }
 686 
 687   void print_CPU_state();
 688 
 689   // Stack overflow checking
 690   void bang_stack_with_offset(int offset) {
 691     // stack grows down, caller passes positive offset
 692     assert(offset &gt; 0, &quot;must bang with negative offset&quot;);
 693     movl(Address(rsp, (-offset)), rax);
 694   }
 695 
 696   // Writes to stack successive pages until offset reached to check for
 697   // stack overflow + shadow pages.  Also, clobbers tmp
 698   void bang_stack_size(Register size, Register tmp);
 699 
 700   // Check for reserved stack access in method being exited (for JIT)
 701   void reserved_stack_check();
 702 
 703   virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,
 704                                                 Register tmp,
 705                                                 int offset);
 706 
 707   // If thread_reg is != noreg the code assumes the register passed contains
 708   // the thread (required on 64 bit).
 709   void safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg);
 710 
 711   void verify_tlab();
 712 
 713   // Biased locking support
 714   // lock_reg and obj_reg must be loaded up with the appropriate values.
 715   // swap_reg must be rax, and is killed.
 716   // tmp_reg is optional. If it is supplied (i.e., != noreg) it will
 717   // be killed; if not supplied, push/pop will be used internally to
 718   // allocate a temporary (inefficient, avoid if possible).
 719   // Optional slow case is for implementations (interpreter and C1) which branch to
 720   // slow case directly. Leaves condition codes set for C2&#39;s Fast_Lock node.
 721   // Returns offset of first potentially-faulting instruction for null
 722   // check info (currently consumed only by C1). If
 723   // swap_reg_contains_mark is true then returns -1 as it is assumed
 724   // the calling code has already passed any potential faults.
 725   int biased_locking_enter(Register lock_reg, Register obj_reg,
 726                            Register swap_reg, Register tmp_reg,
 727                            bool swap_reg_contains_mark,
 728                            Label&amp; done, Label* slow_case = NULL,
 729                            BiasedLockingCounters* counters = NULL);
 730   void biased_locking_exit (Register obj_reg, Register temp_reg, Label&amp; done);
 731 
 732   Condition negate_condition(Condition cond);
 733 
 734   // Instructions that use AddressLiteral operands. These instruction can handle 32bit/64bit
 735   // operands. In general the names are modified to avoid hiding the instruction in Assembler
 736   // so that we don&#39;t need to implement all the varieties in the Assembler with trivial wrappers
 737   // here in MacroAssembler. The major exception to this rule is call
 738 
 739   // Arithmetics
 740 
 741 
 742   void addptr(Address dst, int32_t src) { LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src)) ; }
 743   void addptr(Address dst, Register src);
 744 
 745   void addptr(Register dst, Address src) { LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src)); }
 746   void addptr(Register dst, int32_t src);
 747   void addptr(Register dst, Register src);
 748   void addptr(Register dst, RegisterOrConstant src) {
 749     if (src.is_constant()) addptr(dst, (int) src.as_constant());
 750     else                   addptr(dst,       src.as_register());
 751   }
 752 
 753   void andptr(Register dst, int32_t src);
 754   void andptr(Register src1, Register src2) { LP64_ONLY(andq(src1, src2)) NOT_LP64(andl(src1, src2)) ; }
 755 
 756   void cmp8(AddressLiteral src1, int imm);
 757 
 758   // renamed to drag out the casting of address to int32_t/intptr_t
 759   void cmp32(Register src1, int32_t imm);
 760 
 761   void cmp32(AddressLiteral src1, int32_t imm);
 762   // compare reg - mem, or reg - &amp;mem
 763   void cmp32(Register src1, AddressLiteral src2);
 764 
 765   void cmp32(Register src1, Address src2);
 766 
 767 #ifndef _LP64
 768   void cmpklass(Address dst, Metadata* obj);
 769   void cmpklass(Register dst, Metadata* obj);
 770   void cmpoop(Address dst, jobject obj);
 771   void cmpoop_raw(Address dst, jobject obj);
 772 #endif // _LP64
 773 
 774   void cmpoop(Register src1, Register src2);
 775   void cmpoop(Register src1, Address src2);
 776   void cmpoop(Register dst, jobject obj);
 777   void cmpoop_raw(Register dst, jobject obj);
 778 
 779   // NOTE src2 must be the lval. This is NOT an mem-mem compare
 780   void cmpptr(Address src1, AddressLiteral src2);
 781 
 782   void cmpptr(Register src1, AddressLiteral src2);
 783 
 784   void cmpptr(Register src1, Register src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 785   void cmpptr(Register src1, Address src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 786   // void cmpptr(Address src1, Register src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 787 
 788   void cmpptr(Register src1, int32_t src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 789   void cmpptr(Address src1, int32_t src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 790 
 791   // cmp64 to avoild hiding cmpq
 792   void cmp64(Register src1, AddressLiteral src);
 793 
 794   void cmpxchgptr(Register reg, Address adr);
 795 
 796   void locked_cmpxchgptr(Register reg, AddressLiteral adr);
 797 
 798 
 799   void imulptr(Register dst, Register src) { LP64_ONLY(imulq(dst, src)) NOT_LP64(imull(dst, src)); }
 800   void imulptr(Register dst, Register src, int imm32) { LP64_ONLY(imulq(dst, src, imm32)) NOT_LP64(imull(dst, src, imm32)); }
 801 
 802 
 803   void negptr(Register dst) { LP64_ONLY(negq(dst)) NOT_LP64(negl(dst)); }
 804 
 805   void notptr(Register dst) { LP64_ONLY(notq(dst)) NOT_LP64(notl(dst)); }
 806 
 807   void shlptr(Register dst, int32_t shift);
 808   void shlptr(Register dst) { LP64_ONLY(shlq(dst)) NOT_LP64(shll(dst)); }
 809 
 810   void shrptr(Register dst, int32_t shift);
 811   void shrptr(Register dst) { LP64_ONLY(shrq(dst)) NOT_LP64(shrl(dst)); }
 812 
 813   void sarptr(Register dst) { LP64_ONLY(sarq(dst)) NOT_LP64(sarl(dst)); }
 814   void sarptr(Register dst, int32_t src) { LP64_ONLY(sarq(dst, src)) NOT_LP64(sarl(dst, src)); }
 815 
 816   void subptr(Address dst, int32_t src) { LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src)); }
 817 
 818   void subptr(Register dst, Address src) { LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src)); }
 819   void subptr(Register dst, int32_t src);
 820   // Force generation of a 4 byte immediate value even if it fits into 8bit
 821   void subptr_imm32(Register dst, int32_t src);
 822   void subptr(Register dst, Register src);
 823   void subptr(Register dst, RegisterOrConstant src) {
 824     if (src.is_constant()) subptr(dst, (int) src.as_constant());
 825     else                   subptr(dst,       src.as_register());
 826   }
 827 
 828   void sbbptr(Address dst, int32_t src) { LP64_ONLY(sbbq(dst, src)) NOT_LP64(sbbl(dst, src)); }
 829   void sbbptr(Register dst, int32_t src) { LP64_ONLY(sbbq(dst, src)) NOT_LP64(sbbl(dst, src)); }
 830 
 831   void xchgptr(Register src1, Register src2) { LP64_ONLY(xchgq(src1, src2)) NOT_LP64(xchgl(src1, src2)) ; }
 832   void xchgptr(Register src1, Address src2) { LP64_ONLY(xchgq(src1, src2)) NOT_LP64(xchgl(src1, src2)) ; }
 833 
 834   void xaddptr(Address src1, Register src2) { LP64_ONLY(xaddq(src1, src2)) NOT_LP64(xaddl(src1, src2)) ; }
 835 
 836 
 837 
 838   // Helper functions for statistics gathering.
 839   // Conditionally (atomically, on MPs) increments passed counter address, preserving condition codes.
 840   void cond_inc32(Condition cond, AddressLiteral counter_addr);
 841   // Unconditional atomic increment.
 842   void atomic_incl(Address counter_addr);
 843   void atomic_incl(AddressLiteral counter_addr, Register scr = rscratch1);
 844 #ifdef _LP64
 845   void atomic_incq(Address counter_addr);
 846   void atomic_incq(AddressLiteral counter_addr, Register scr = rscratch1);
 847 #endif
 848   void atomic_incptr(AddressLiteral counter_addr, Register scr = rscratch1) { LP64_ONLY(atomic_incq(counter_addr, scr)) NOT_LP64(atomic_incl(counter_addr, scr)) ; }
 849   void atomic_incptr(Address counter_addr) { LP64_ONLY(atomic_incq(counter_addr)) NOT_LP64(atomic_incl(counter_addr)) ; }
 850 
 851   void lea(Register dst, AddressLiteral adr);
 852   void lea(Address dst, AddressLiteral adr);
 853   void lea(Register dst, Address adr) { Assembler::lea(dst, adr); }
 854 
 855   void leal32(Register dst, Address src) { leal(dst, src); }
 856 
 857   // Import other testl() methods from the parent class or else
 858   // they will be hidden by the following overriding declaration.
 859   using Assembler::testl;
 860   void testl(Register dst, AddressLiteral src);
 861 
 862   void orptr(Register dst, Address src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 863   void orptr(Register dst, Register src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 864   void orptr(Register dst, int32_t src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 865   void orptr(Address dst, int32_t imm32) { LP64_ONLY(orq(dst, imm32)) NOT_LP64(orl(dst, imm32)); }
 866 
 867   void testptr(Register src, int32_t imm32) {  LP64_ONLY(testq(src, imm32)) NOT_LP64(testl(src, imm32)); }
 868   void testptr(Register src1, Address src2) { LP64_ONLY(testq(src1, src2)) NOT_LP64(testl(src1, src2)); }
 869   void testptr(Register src1, Register src2);
 870 
 871   void xorptr(Register dst, Register src) { LP64_ONLY(xorq(dst, src)) NOT_LP64(xorl(dst, src)); }
 872   void xorptr(Register dst, Address src) { LP64_ONLY(xorq(dst, src)) NOT_LP64(xorl(dst, src)); }
 873 
 874   // Calls
 875 
 876   void call(Label&amp; L, relocInfo::relocType rtype);
 877   void call(Register entry);
 878 
 879   // NOTE: this call transfers to the effective address of entry NOT
 880   // the address contained by entry. This is because this is more natural
 881   // for jumps/calls.
 882   void call(AddressLiteral entry);
 883 
 884   // Emit the CompiledIC call idiom
 885   void ic_call(address entry, jint method_index = 0);
 886 
 887   // Jumps
 888 
 889   // NOTE: these jumps tranfer to the effective address of dst NOT
 890   // the address contained by dst. This is because this is more natural
 891   // for jumps/calls.
 892   void jump(AddressLiteral dst);
 893   void jump_cc(Condition cc, AddressLiteral dst);
 894 
 895   // 32bit can do a case table jump in one instruction but we no longer allow the base
 896   // to be installed in the Address class. This jump will tranfers to the address
 897   // contained in the location described by entry (not the address of entry)
 898   void jump(ArrayAddress entry);
 899 
 900   // Floating
 901 
 902   void andpd(XMMRegister dst, Address src) { Assembler::andpd(dst, src); }
 903   void andpd(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
 904   void andpd(XMMRegister dst, XMMRegister src) { Assembler::andpd(dst, src); }
 905 
 906   void andps(XMMRegister dst, XMMRegister src) { Assembler::andps(dst, src); }
 907   void andps(XMMRegister dst, Address src) { Assembler::andps(dst, src); }
 908   void andps(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
 909 
 910   void comiss(XMMRegister dst, XMMRegister src) { Assembler::comiss(dst, src); }
 911   void comiss(XMMRegister dst, Address src) { Assembler::comiss(dst, src); }
 912   void comiss(XMMRegister dst, AddressLiteral src);
 913 
 914   void comisd(XMMRegister dst, XMMRegister src) { Assembler::comisd(dst, src); }
 915   void comisd(XMMRegister dst, Address src) { Assembler::comisd(dst, src); }
 916   void comisd(XMMRegister dst, AddressLiteral src);
 917 
 918 #ifndef _LP64
 919   void fadd_s(Address src)        { Assembler::fadd_s(src); }
 920   void fadd_s(AddressLiteral src) { Assembler::fadd_s(as_Address(src)); }
 921 
 922   void fldcw(Address src) { Assembler::fldcw(src); }
 923   void fldcw(AddressLiteral src);
 924 
 925   void fld_s(int index)   { Assembler::fld_s(index); }
 926   void fld_s(Address src) { Assembler::fld_s(src); }
 927   void fld_s(AddressLiteral src);
 928 
 929   void fld_d(Address src) { Assembler::fld_d(src); }
 930   void fld_d(AddressLiteral src);
 931 
 932   void fld_x(Address src) { Assembler::fld_x(src); }
 933   void fld_x(AddressLiteral src);
 934 
 935   void fmul_s(Address src)        { Assembler::fmul_s(src); }
 936   void fmul_s(AddressLiteral src) { Assembler::fmul_s(as_Address(src)); }
 937 #endif // _LP64
 938 
 939   void ldmxcsr(Address src) { Assembler::ldmxcsr(src); }
 940   void ldmxcsr(AddressLiteral src);
 941 
 942 #ifdef _LP64
 943  private:
 944   void sha256_AVX2_one_round_compute(
 945     Register  reg_old_h,
 946     Register  reg_a,
 947     Register  reg_b,
 948     Register  reg_c,
 949     Register  reg_d,
 950     Register  reg_e,
 951     Register  reg_f,
 952     Register  reg_g,
 953     Register  reg_h,
 954     int iter);
 955   void sha256_AVX2_four_rounds_compute_first(int start);
 956   void sha256_AVX2_four_rounds_compute_last(int start);
 957   void sha256_AVX2_one_round_and_sched(
 958         XMMRegister xmm_0,     /* == ymm4 on 0, 1, 2, 3 iterations, then rotate 4 registers left on 4, 8, 12 iterations */
 959         XMMRegister xmm_1,     /* ymm5 */  /* full cycle is 16 iterations */
 960         XMMRegister xmm_2,     /* ymm6 */
 961         XMMRegister xmm_3,     /* ymm7 */
 962         Register    reg_a,      /* == eax on 0 iteration, then rotate 8 register right on each next iteration */
 963         Register    reg_b,      /* ebx */    /* full cycle is 8 iterations */
 964         Register    reg_c,      /* edi */
 965         Register    reg_d,      /* esi */
 966         Register    reg_e,      /* r8d */
 967         Register    reg_f,      /* r9d */
 968         Register    reg_g,      /* r10d */
 969         Register    reg_h,      /* r11d */
 970         int iter);
 971 
 972   void addm(int disp, Register r1, Register r2);
 973   void gfmul(XMMRegister tmp0, XMMRegister t);
 974   void schoolbookAAD(int i, Register subkeyH, XMMRegister data, XMMRegister tmp0,
 975                      XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3);
 976   void generateHtbl_one_block(Register htbl);
 977   void generateHtbl_eight_blocks(Register htbl);
 978  public:
 979   void sha256_AVX2(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
 980                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
 981                    Register buf, Register state, Register ofs, Register limit, Register rsp,
 982                    bool multi_block, XMMRegister shuf_mask);
 983   void avx_ghash(Register state, Register htbl, Register data, Register blocks);
 984 #endif
 985 
 986 #ifdef _LP64
 987  private:
 988   void sha512_AVX2_one_round_compute(Register old_h, Register a, Register b, Register c, Register d,
 989                                      Register e, Register f, Register g, Register h, int iteration);
 990 
 991   void sha512_AVX2_one_round_and_schedule(XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
 992                                           Register a, Register b, Register c, Register d, Register e, Register f,
 993                                           Register g, Register h, int iteration);
 994 
 995   void addmq(int disp, Register r1, Register r2);
 996  public:
 997   void sha512_AVX2(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
 998                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
 999                    Register buf, Register state, Register ofs, Register limit, Register rsp, bool multi_block,
1000                    XMMRegister shuf_mask);
1001 private:
1002   void roundEnc(XMMRegister key, int rnum);
1003   void lastroundEnc(XMMRegister key, int rnum);
1004   void roundDec(XMMRegister key, int rnum);
1005   void lastroundDec(XMMRegister key, int rnum);
1006   void ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask);
1007 
1008 public:
1009   void aesecb_encrypt(Register source_addr, Register dest_addr, Register key, Register len);
1010   void aesecb_decrypt(Register source_addr, Register dest_addr, Register key, Register len);
1011   void aesctr_encrypt(Register src_addr, Register dest_addr, Register key, Register counter,
1012                       Register len_reg, Register used, Register used_addr, Register saved_encCounter_start);
1013 
1014 #endif
1015 
1016   void fast_sha1(XMMRegister abcd, XMMRegister e0, XMMRegister e1, XMMRegister msg0,
1017                  XMMRegister msg1, XMMRegister msg2, XMMRegister msg3, XMMRegister shuf_mask,
1018                  Register buf, Register state, Register ofs, Register limit, Register rsp,
1019                  bool multi_block);
1020 
1021 #ifdef _LP64
1022   void fast_sha256(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
1023                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
1024                    Register buf, Register state, Register ofs, Register limit, Register rsp,
1025                    bool multi_block, XMMRegister shuf_mask);
1026 #else
1027   void fast_sha256(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
1028                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
1029                    Register buf, Register state, Register ofs, Register limit, Register rsp,
1030                    bool multi_block);
1031 #endif
1032 
1033   void fast_exp(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1034                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1035                 Register rax, Register rcx, Register rdx, Register tmp);
1036 
1037 #ifdef _LP64
1038   void fast_log(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1039                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1040                 Register rax, Register rcx, Register rdx, Register tmp1, Register tmp2);
1041 
1042   void fast_log10(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1043                   XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1044                   Register rax, Register rcx, Register rdx, Register r11);
1045 
1046   void fast_pow(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,
1047                 XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register rax, Register rcx,
1048                 Register rdx, Register tmp1, Register tmp2, Register tmp3, Register tmp4);
1049 
1050   void fast_sin(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1051                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1052                 Register rax, Register rbx, Register rcx, Register rdx, Register tmp1, Register tmp2,
1053                 Register tmp3, Register tmp4);
1054 
1055   void fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1056                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1057                 Register rax, Register rcx, Register rdx, Register tmp1,
1058                 Register tmp2, Register tmp3, Register tmp4);
1059   void fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1060                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1061                 Register rax, Register rcx, Register rdx, Register tmp1,
1062                 Register tmp2, Register tmp3, Register tmp4);
1063 #else
1064   void fast_log(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1065                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1066                 Register rax, Register rcx, Register rdx, Register tmp1);
1067 
1068   void fast_log10(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1069                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1070                 Register rax, Register rcx, Register rdx, Register tmp);
1071 
1072   void fast_pow(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,
1073                 XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register rax, Register rcx,
1074                 Register rdx, Register tmp);
1075 
1076   void fast_sin(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1077                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1078                 Register rax, Register rbx, Register rdx);
1079 
1080   void fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1081                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1082                 Register rax, Register rcx, Register rdx, Register tmp);
1083 
1084   void libm_sincos_huge(XMMRegister xmm0, XMMRegister xmm1, Register eax, Register ecx,
1085                         Register edx, Register ebx, Register esi, Register edi,
1086                         Register ebp, Register esp);
1087 
1088   void libm_reduce_pi04l(Register eax, Register ecx, Register edx, Register ebx,
1089                          Register esi, Register edi, Register ebp, Register esp);
1090 
1091   void libm_tancot_huge(XMMRegister xmm0, XMMRegister xmm1, Register eax, Register ecx,
1092                         Register edx, Register ebx, Register esi, Register edi,
1093                         Register ebp, Register esp);
1094 
1095   void fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1096                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1097                 Register rax, Register rcx, Register rdx, Register tmp);
1098 #endif
1099 
1100 private:
1101 
1102   // these are private because users should be doing movflt/movdbl
1103 
1104   void movss(XMMRegister dst, XMMRegister src) { Assembler::movss(dst, src); }
1105   void movss(Address dst, XMMRegister src)     { Assembler::movss(dst, src); }
1106   void movss(XMMRegister dst, Address src)     { Assembler::movss(dst, src); }
1107   void movss(XMMRegister dst, AddressLiteral src);
1108 
1109   void movlpd(XMMRegister dst, Address src)    {Assembler::movlpd(dst, src); }
1110   void movlpd(XMMRegister dst, AddressLiteral src);
1111 
1112 public:
1113 
1114   void addsd(XMMRegister dst, XMMRegister src)    { Assembler::addsd(dst, src); }
1115   void addsd(XMMRegister dst, Address src)        { Assembler::addsd(dst, src); }
1116   void addsd(XMMRegister dst, AddressLiteral src);
1117 
1118   void addss(XMMRegister dst, XMMRegister src)    { Assembler::addss(dst, src); }
1119   void addss(XMMRegister dst, Address src)        { Assembler::addss(dst, src); }
1120   void addss(XMMRegister dst, AddressLiteral src);
1121 
1122   void addpd(XMMRegister dst, XMMRegister src)    { Assembler::addpd(dst, src); }
1123   void addpd(XMMRegister dst, Address src)        { Assembler::addpd(dst, src); }
1124   void addpd(XMMRegister dst, AddressLiteral src);
1125 
1126   void divsd(XMMRegister dst, XMMRegister src)    { Assembler::divsd(dst, src); }
1127   void divsd(XMMRegister dst, Address src)        { Assembler::divsd(dst, src); }
1128   void divsd(XMMRegister dst, AddressLiteral src);
1129 
1130   void divss(XMMRegister dst, XMMRegister src)    { Assembler::divss(dst, src); }
1131   void divss(XMMRegister dst, Address src)        { Assembler::divss(dst, src); }
1132   void divss(XMMRegister dst, AddressLiteral src);
1133 
1134   // Move Unaligned Double Quadword
1135   void movdqu(Address     dst, XMMRegister src);
1136   void movdqu(XMMRegister dst, Address src);
1137   void movdqu(XMMRegister dst, XMMRegister src);
1138   void movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg = rscratch1);
1139   // AVX Unaligned forms
1140   void vmovdqu(Address     dst, XMMRegister src);
1141   void vmovdqu(XMMRegister dst, Address src);
1142   void vmovdqu(XMMRegister dst, XMMRegister src);
1143   void vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
1144   void evmovdquq(XMMRegister dst, Address src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1145   void evmovdquq(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1146   void evmovdquq(Address dst, XMMRegister src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1147   void evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch);
1148 
1149   // Move Aligned Double Quadword
1150   void movdqa(XMMRegister dst, Address src)       { Assembler::movdqa(dst, src); }
1151   void movdqa(XMMRegister dst, XMMRegister src)   { Assembler::movdqa(dst, src); }
1152   void movdqa(XMMRegister dst, AddressLiteral src);
1153 
1154   void movsd(XMMRegister dst, XMMRegister src) { Assembler::movsd(dst, src); }
1155   void movsd(Address dst, XMMRegister src)     { Assembler::movsd(dst, src); }
1156   void movsd(XMMRegister dst, Address src)     { Assembler::movsd(dst, src); }
1157   void movsd(XMMRegister dst, AddressLiteral src);
1158 
1159   void mulpd(XMMRegister dst, XMMRegister src)    { Assembler::mulpd(dst, src); }
1160   void mulpd(XMMRegister dst, Address src)        { Assembler::mulpd(dst, src); }
1161   void mulpd(XMMRegister dst, AddressLiteral src);
1162 
1163   void mulsd(XMMRegister dst, XMMRegister src)    { Assembler::mulsd(dst, src); }
1164   void mulsd(XMMRegister dst, Address src)        { Assembler::mulsd(dst, src); }
1165   void mulsd(XMMRegister dst, AddressLiteral src);
1166 
1167   void mulss(XMMRegister dst, XMMRegister src)    { Assembler::mulss(dst, src); }
1168   void mulss(XMMRegister dst, Address src)        { Assembler::mulss(dst, src); }
1169   void mulss(XMMRegister dst, AddressLiteral src);
1170 
1171   // Carry-Less Multiplication Quadword
1172   void pclmulldq(XMMRegister dst, XMMRegister src) {
1173     // 0x00 - multiply lower 64 bits [0:63]
1174     Assembler::pclmulqdq(dst, src, 0x00);
1175   }
1176   void pclmulhdq(XMMRegister dst, XMMRegister src) {
1177     // 0x11 - multiply upper 64 bits [64:127]
1178     Assembler::pclmulqdq(dst, src, 0x11);
1179   }
1180 
1181   void pcmpeqb(XMMRegister dst, XMMRegister src);
1182   void pcmpeqw(XMMRegister dst, XMMRegister src);
1183 
1184   void pcmpestri(XMMRegister dst, Address src, int imm8);
1185   void pcmpestri(XMMRegister dst, XMMRegister src, int imm8);
1186 
1187   void pmovzxbw(XMMRegister dst, XMMRegister src);
1188   void pmovzxbw(XMMRegister dst, Address src);
1189 
1190   void pmovmskb(Register dst, XMMRegister src);
1191 
1192   void ptest(XMMRegister dst, XMMRegister src);
1193 
1194   void sqrtsd(XMMRegister dst, XMMRegister src)    { Assembler::sqrtsd(dst, src); }
1195   void sqrtsd(XMMRegister dst, Address src)        { Assembler::sqrtsd(dst, src); }
1196   void sqrtsd(XMMRegister dst, AddressLiteral src);
1197 
1198   void roundsd(XMMRegister dst, XMMRegister src, int32_t rmode)    { Assembler::roundsd(dst, src, rmode); }
1199   void roundsd(XMMRegister dst, Address src, int32_t rmode)        { Assembler::roundsd(dst, src, rmode); }
1200   void roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register scratch_reg);
1201 
1202   void sqrtss(XMMRegister dst, XMMRegister src)    { Assembler::sqrtss(dst, src); }
1203   void sqrtss(XMMRegister dst, Address src)        { Assembler::sqrtss(dst, src); }
1204   void sqrtss(XMMRegister dst, AddressLiteral src);
1205 
1206   void subsd(XMMRegister dst, XMMRegister src)    { Assembler::subsd(dst, src); }
1207   void subsd(XMMRegister dst, Address src)        { Assembler::subsd(dst, src); }
1208   void subsd(XMMRegister dst, AddressLiteral src);
1209 
1210   void subss(XMMRegister dst, XMMRegister src)    { Assembler::subss(dst, src); }
1211   void subss(XMMRegister dst, Address src)        { Assembler::subss(dst, src); }
1212   void subss(XMMRegister dst, AddressLiteral src);
1213 
1214   void ucomiss(XMMRegister dst, XMMRegister src) { Assembler::ucomiss(dst, src); }
1215   void ucomiss(XMMRegister dst, Address src)     { Assembler::ucomiss(dst, src); }
1216   void ucomiss(XMMRegister dst, AddressLiteral src);
1217 
1218   void ucomisd(XMMRegister dst, XMMRegister src) { Assembler::ucomisd(dst, src); }
1219   void ucomisd(XMMRegister dst, Address src)     { Assembler::ucomisd(dst, src); }
1220   void ucomisd(XMMRegister dst, AddressLiteral src);
1221 
1222   // Bitwise Logical XOR of Packed Double-Precision Floating-Point Values
1223   void xorpd(XMMRegister dst, XMMRegister src);
1224   void xorpd(XMMRegister dst, Address src)     { Assembler::xorpd(dst, src); }
1225   void xorpd(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
1226 
1227   // Bitwise Logical XOR of Packed Single-Precision Floating-Point Values
1228   void xorps(XMMRegister dst, XMMRegister src);
1229   void xorps(XMMRegister dst, Address src)     { Assembler::xorps(dst, src); }
1230   void xorps(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
1231 
1232   // Shuffle Bytes
1233   void pshufb(XMMRegister dst, XMMRegister src) { Assembler::pshufb(dst, src); }
1234   void pshufb(XMMRegister dst, Address src)     { Assembler::pshufb(dst, src); }
1235   void pshufb(XMMRegister dst, AddressLiteral src);
1236   // AVX 3-operands instructions
1237 
1238   void vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vaddsd(dst, nds, src); }
1239   void vaddsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vaddsd(dst, nds, src); }
1240   void vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1241 
1242   void vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vaddss(dst, nds, src); }
1243   void vaddss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vaddss(dst, nds, src); }
1244   void vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1245 
1246   void vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len);
1247   void vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len);
1248 
1249   void vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1250   void vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1251 
1252   void vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1253   void vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1254 
1255   void vpaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vpaddd(dst, nds, src, vector_len); }
1256   void vpaddd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vpaddd(dst, nds, src, vector_len); }
1257   void vpaddd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch);
1258 
1259   void vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }
1260   void vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }
1261   void vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1262 
1263   void vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len);
1264   void vpbroadcastw(XMMRegister dst, Address src, int vector_len) { Assembler::vpbroadcastw(dst, src, vector_len); }
1265 
1266   void vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1267 
1268   void vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1269 
1270   void vpmovzxbw(XMMRegister dst, Address src, int vector_len);
1271   void vpmovzxbw(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::vpmovzxbw(dst, src, vector_len); }
1272 
1273   void vpmovmskb(Register dst, XMMRegister src);
1274 
1275   void vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1276   void vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1277 
1278   void vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1279   void vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1280 
1281   void vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1282   void vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1283 
1284   void vpsraw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1285   void vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1286 
1287   void evpsraq(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1288   void evpsraq(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1289 
1290   void vpsrlw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1291   void vpsrlw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1292 
1293   void vpsllw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1294   void vpsllw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1295 
1296   void vptest(XMMRegister dst, XMMRegister src);
1297 
1298   void punpcklbw(XMMRegister dst, XMMRegister src);
1299   void punpcklbw(XMMRegister dst, Address src) { Assembler::punpcklbw(dst, src); }
1300 
1301   void pshufd(XMMRegister dst, Address src, int mode);
1302   void pshufd(XMMRegister dst, XMMRegister src, int mode) { Assembler::pshufd(dst, src, mode); }
1303 
1304   void pshuflw(XMMRegister dst, XMMRegister src, int mode);
1305   void pshuflw(XMMRegister dst, Address src, int mode) { Assembler::pshuflw(dst, src, mode); }
1306 
1307   void vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vandpd(dst, nds, src, vector_len); }
1308   void vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len)     { Assembler::vandpd(dst, nds, src, vector_len); }
1309   void vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1310 
1311   void vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vandps(dst, nds, src, vector_len); }
1312   void vandps(XMMRegister dst, XMMRegister nds, Address src, int vector_len)     { Assembler::vandps(dst, nds, src, vector_len); }
1313   void vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1314 
1315   void vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vdivsd(dst, nds, src); }
1316   void vdivsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vdivsd(dst, nds, src); }
1317   void vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1318 
1319   void vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vdivss(dst, nds, src); }
1320   void vdivss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vdivss(dst, nds, src); }
1321   void vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1322 
1323   void vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vmulsd(dst, nds, src); }
1324   void vmulsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vmulsd(dst, nds, src); }
1325   void vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1326 
1327   void vmulss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vmulss(dst, nds, src); }
1328   void vmulss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vmulss(dst, nds, src); }
1329   void vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1330 
1331   void vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vsubsd(dst, nds, src); }
1332   void vsubsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vsubsd(dst, nds, src); }
1333   void vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1334 
1335   void vsubss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vsubss(dst, nds, src); }
1336   void vsubss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vsubss(dst, nds, src); }
1337   void vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1338 
1339   void vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1340   void vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1341 
1342   // AVX Vector instructions
1343 
1344   void vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }
1345   void vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }
1346   void vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1347 
1348   void vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }
1349   void vxorps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }
1350   void vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1351 
1352   void vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1353     if (UseAVX &gt; 1 || (vector_len &lt; 1)) // vpxor 256 bit is available only in AVX2
1354       Assembler::vpxor(dst, nds, src, vector_len);
1355     else
1356       Assembler::vxorpd(dst, nds, src, vector_len);
1357   }
1358   void vpxor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
1359     if (UseAVX &gt; 1 || (vector_len &lt; 1)) // vpxor 256 bit is available only in AVX2
1360       Assembler::vpxor(dst, nds, src, vector_len);
1361     else
1362       Assembler::vxorpd(dst, nds, src, vector_len);
1363   }
1364   void vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1365 
1366   // Simple version for AVX2 256bit vectors
1367   void vpxor(XMMRegister dst, XMMRegister src) { Assembler::vpxor(dst, dst, src, true); }
1368   void vpxor(XMMRegister dst, Address src) { Assembler::vpxor(dst, dst, src, true); }
1369 
1370   void vinserti128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
1371     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1372       Assembler::vinserti32x4(dst, dst, src, imm8);
1373     } else if (UseAVX &gt; 1) {
1374       // vinserti128 is available only in AVX2
1375       Assembler::vinserti128(dst, nds, src, imm8);
1376     } else {
1377       Assembler::vinsertf128(dst, nds, src, imm8);
1378     }
1379   }
1380 
1381   void vinserti128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
1382     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1383       Assembler::vinserti32x4(dst, dst, src, imm8);
1384     } else if (UseAVX &gt; 1) {
1385       // vinserti128 is available only in AVX2
1386       Assembler::vinserti128(dst, nds, src, imm8);
1387     } else {
1388       Assembler::vinsertf128(dst, nds, src, imm8);
1389     }
1390   }
1391 
1392   void vextracti128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
1393     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1394       Assembler::vextracti32x4(dst, src, imm8);
1395     } else if (UseAVX &gt; 1) {
1396       // vextracti128 is available only in AVX2
1397       Assembler::vextracti128(dst, src, imm8);
1398     } else {
1399       Assembler::vextractf128(dst, src, imm8);
1400     }
1401   }
1402 
1403   void vextracti128(Address dst, XMMRegister src, uint8_t imm8) {
1404     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1405       Assembler::vextracti32x4(dst, src, imm8);
1406     } else if (UseAVX &gt; 1) {
1407       // vextracti128 is available only in AVX2
1408       Assembler::vextracti128(dst, src, imm8);
1409     } else {
1410       Assembler::vextractf128(dst, src, imm8);
1411     }
1412   }
1413 
1414   // 128bit copy to/from high 128 bits of 256bit (YMM) vector registers
1415   void vinserti128_high(XMMRegister dst, XMMRegister src) {
1416     vinserti128(dst, dst, src, 1);
1417   }
1418   void vinserti128_high(XMMRegister dst, Address src) {
1419     vinserti128(dst, dst, src, 1);
1420   }
1421   void vextracti128_high(XMMRegister dst, XMMRegister src) {
1422     vextracti128(dst, src, 1);
1423   }
1424   void vextracti128_high(Address dst, XMMRegister src) {
1425     vextracti128(dst, src, 1);
1426   }
1427 
1428   void vinsertf128_high(XMMRegister dst, XMMRegister src) {
1429     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1430       Assembler::vinsertf32x4(dst, dst, src, 1);
1431     } else {
1432       Assembler::vinsertf128(dst, dst, src, 1);
1433     }
1434   }
1435 
1436   void vinsertf128_high(XMMRegister dst, Address src) {
1437     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1438       Assembler::vinsertf32x4(dst, dst, src, 1);
1439     } else {
1440       Assembler::vinsertf128(dst, dst, src, 1);
1441     }
1442   }
1443 
1444   void vextractf128_high(XMMRegister dst, XMMRegister src) {
1445     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1446       Assembler::vextractf32x4(dst, src, 1);
1447     } else {
1448       Assembler::vextractf128(dst, src, 1);
1449     }
1450   }
1451 
1452   void vextractf128_high(Address dst, XMMRegister src) {
1453     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1454       Assembler::vextractf32x4(dst, src, 1);
1455     } else {
1456       Assembler::vextractf128(dst, src, 1);
1457     }
1458   }
1459 
1460   // 256bit copy to/from high 256 bits of 512bit (ZMM) vector registers
1461   void vinserti64x4_high(XMMRegister dst, XMMRegister src) {
1462     Assembler::vinserti64x4(dst, dst, src, 1);
1463   }
1464   void vinsertf64x4_high(XMMRegister dst, XMMRegister src) {
1465     Assembler::vinsertf64x4(dst, dst, src, 1);
1466   }
1467   void vextracti64x4_high(XMMRegister dst, XMMRegister src) {
1468     Assembler::vextracti64x4(dst, src, 1);
1469   }
1470   void vextractf64x4_high(XMMRegister dst, XMMRegister src) {
1471     Assembler::vextractf64x4(dst, src, 1);
1472   }
1473   void vextractf64x4_high(Address dst, XMMRegister src) {
1474     Assembler::vextractf64x4(dst, src, 1);
1475   }
1476   void vinsertf64x4_high(XMMRegister dst, Address src) {
1477     Assembler::vinsertf64x4(dst, dst, src, 1);
1478   }
1479 
1480   // 128bit copy to/from low 128 bits of 256bit (YMM) vector registers
1481   void vinserti128_low(XMMRegister dst, XMMRegister src) {
1482     vinserti128(dst, dst, src, 0);
1483   }
1484   void vinserti128_low(XMMRegister dst, Address src) {
1485     vinserti128(dst, dst, src, 0);
1486   }
1487   void vextracti128_low(XMMRegister dst, XMMRegister src) {
1488     vextracti128(dst, src, 0);
1489   }
1490   void vextracti128_low(Address dst, XMMRegister src) {
1491     vextracti128(dst, src, 0);
1492   }
1493 
1494   void vinsertf128_low(XMMRegister dst, XMMRegister src) {
1495     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1496       Assembler::vinsertf32x4(dst, dst, src, 0);
1497     } else {
1498       Assembler::vinsertf128(dst, dst, src, 0);
1499     }
1500   }
1501 
1502   void vinsertf128_low(XMMRegister dst, Address src) {
1503     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1504       Assembler::vinsertf32x4(dst, dst, src, 0);
1505     } else {
1506       Assembler::vinsertf128(dst, dst, src, 0);
1507     }
1508   }
1509 
1510   void vextractf128_low(XMMRegister dst, XMMRegister src) {
1511     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1512       Assembler::vextractf32x4(dst, src, 0);
1513     } else {
1514       Assembler::vextractf128(dst, src, 0);
1515     }
1516   }
1517 
1518   void vextractf128_low(Address dst, XMMRegister src) {
1519     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1520       Assembler::vextractf32x4(dst, src, 0);
1521     } else {
1522       Assembler::vextractf128(dst, src, 0);
1523     }
1524   }
1525 
1526   // 256bit copy to/from low 256 bits of 512bit (ZMM) vector registers
1527   void vinserti64x4_low(XMMRegister dst, XMMRegister src) {
1528     Assembler::vinserti64x4(dst, dst, src, 0);
1529   }
1530   void vinsertf64x4_low(XMMRegister dst, XMMRegister src) {
1531     Assembler::vinsertf64x4(dst, dst, src, 0);
1532   }
1533   void vextracti64x4_low(XMMRegister dst, XMMRegister src) {
1534     Assembler::vextracti64x4(dst, src, 0);
1535   }
1536   void vextractf64x4_low(XMMRegister dst, XMMRegister src) {
1537     Assembler::vextractf64x4(dst, src, 0);
1538   }
1539   void vextractf64x4_low(Address dst, XMMRegister src) {
1540     Assembler::vextractf64x4(dst, src, 0);
1541   }
1542   void vinsertf64x4_low(XMMRegister dst, Address src) {
1543     Assembler::vinsertf64x4(dst, dst, src, 0);
1544   }
1545 
1546   // Carry-Less Multiplication Quadword
1547   void vpclmulldq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1548     // 0x00 - multiply lower 64 bits [0:63]
1549     Assembler::vpclmulqdq(dst, nds, src, 0x00);
1550   }
1551   void vpclmulhdq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1552     // 0x11 - multiply upper 64 bits [64:127]
1553     Assembler::vpclmulqdq(dst, nds, src, 0x11);
1554   }
1555   void vpclmullqhqdq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1556     // 0x10 - multiply nds[0:63] and src[64:127]
1557     Assembler::vpclmulqdq(dst, nds, src, 0x10);
1558   }
1559   void vpclmulhqlqdq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1560     //0x01 - multiply nds[64:127] and src[0:63]
1561     Assembler::vpclmulqdq(dst, nds, src, 0x01);
1562   }
1563 
1564   void evpclmulldq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1565     // 0x00 - multiply lower 64 bits [0:63]
1566     Assembler::evpclmulqdq(dst, nds, src, 0x00, vector_len);
1567   }
1568   void evpclmulhdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1569     // 0x11 - multiply upper 64 bits [64:127]
1570     Assembler::evpclmulqdq(dst, nds, src, 0x11, vector_len);
1571   }
1572 
1573   // Data
1574 
1575   void cmov32( Condition cc, Register dst, Address  src);
1576   void cmov32( Condition cc, Register dst, Register src);
1577 
1578   void cmov(   Condition cc, Register dst, Register src) { cmovptr(cc, dst, src); }
1579 
1580   void cmovptr(Condition cc, Register dst, Address  src) { LP64_ONLY(cmovq(cc, dst, src)) NOT_LP64(cmov32(cc, dst, src)); }
1581   void cmovptr(Condition cc, Register dst, Register src) { LP64_ONLY(cmovq(cc, dst, src)) NOT_LP64(cmov32(cc, dst, src)); }
1582 
1583   void movoop(Register dst, jobject obj);
1584   void movoop(Address dst, jobject obj);
1585 
1586   void mov_metadata(Register dst, Metadata* obj);
1587   void mov_metadata(Address dst, Metadata* obj);
1588 
1589   void movptr(ArrayAddress dst, Register src);
1590   // can this do an lea?
1591   void movptr(Register dst, ArrayAddress src);
1592 
1593   void movptr(Register dst, Address src);
1594 
1595 #ifdef _LP64
1596   void movptr(Register dst, AddressLiteral src, Register scratch=rscratch1);
1597 #else
1598   void movptr(Register dst, AddressLiteral src, Register scratch=noreg); // Scratch reg is ignored in 32-bit
1599 #endif
1600 
1601   void movptr(Register dst, intptr_t src);
1602   void movptr(Register dst, Register src);
1603   void movptr(Address dst, intptr_t src);
1604 
1605   void movptr(Address dst, Register src);
1606 
1607   void movptr(Register dst, RegisterOrConstant src) {
1608     if (src.is_constant()) movptr(dst, src.as_constant());
1609     else                   movptr(dst, src.as_register());
1610   }
1611 
1612 #ifdef _LP64
1613   // Generally the next two are only used for moving NULL
1614   // Although there are situations in initializing the mark word where
1615   // they could be used. They are dangerous.
1616 
1617   // They only exist on LP64 so that int32_t and intptr_t are not the same
1618   // and we have ambiguous declarations.
1619 
1620   void movptr(Address dst, int32_t imm32);
1621   void movptr(Register dst, int32_t imm32);
1622 #endif // _LP64
1623 
1624   // to avoid hiding movl
1625   void mov32(AddressLiteral dst, Register src);
1626   void mov32(Register dst, AddressLiteral src);
1627 
1628   // to avoid hiding movb
1629   void movbyte(ArrayAddress dst, int src);
1630 
1631   // Import other mov() methods from the parent class or else
1632   // they will be hidden by the following overriding declaration.
1633   using Assembler::movdl;
1634   using Assembler::movq;
1635   void movdl(XMMRegister dst, AddressLiteral src);
1636   void movq(XMMRegister dst, AddressLiteral src);
1637 
1638   // Can push value or effective address
1639   void pushptr(AddressLiteral src);
1640 
1641   void pushptr(Address src) { LP64_ONLY(pushq(src)) NOT_LP64(pushl(src)); }
1642   void popptr(Address src) { LP64_ONLY(popq(src)) NOT_LP64(popl(src)); }
1643 
1644   void pushoop(jobject obj);
1645   void pushklass(Metadata* obj);
1646 
1647   // sign extend as need a l to ptr sized element
1648   void movl2ptr(Register dst, Address src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(movl(dst, src)); }
1649   void movl2ptr(Register dst, Register src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(if (dst != src) movl(dst, src)); }
1650 
1651 
1652  public:
1653   // C2 compiled method&#39;s prolog code.
1654   void verified_entry(Compile* C, int sp_inc = 0);
1655 
1656   enum RegState {
1657     reg_readonly,
1658     reg_writable,
1659     reg_written
1660   };
1661 
1662   int store_value_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter = true);
1663 
1664   // Unpack all value type arguments passed as oops
1665   void unpack_value_args(Compile* C, bool receiver_only);
1666   bool move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset);
1667   bool unpack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to, int&amp; to_index,
1668                            RegState reg_state[], int ret_off, int extra_stack_offset);
1669   bool pack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,
1670                          VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],
1671                          int ret_off, int extra_stack_offset);
1672   void remove_frame(int initial_framesize, bool needs_stack_repair, int sp_inc_offset);
1673 
1674   void shuffle_value_args(bool is_packing, bool receiver_only, int extra_stack_offset,
1675                           BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,
1676                           int args_passed, int args_on_stack, VMRegPair* regs,
1677                           int args_passed_to, int args_on_stack_to, VMRegPair* regs_to, int sp_inc);
1678   bool shuffle_value_args_spill(bool is_packing,  const GrowableArray&lt;SigEntry&gt;* sig_cc, int sig_cc_index,
1679                                 VMRegPair* regs_from, int from_index, int regs_from_count,
1680                                 RegState* reg_state, int sp_inc, int extra_stack_offset);
1681   VMReg spill_reg_for(VMReg reg);
1682 
1683   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39;;
1684   // if &#39;is_large&#39; is set, do not try to produce short loop
1685   void clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only);
1686 
1687   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
1688   void xmm_clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp);
1689 
1690   // Fill primitive arrays
1691   void generate_fill(BasicType t, bool aligned,
1692                      Register to, Register value, Register count,
1693                      Register rtmp, XMMRegister xtmp);
1694 
1695   void encode_iso_array(Register src, Register dst, Register len,
1696                         XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3,
1697                         XMMRegister tmp4, Register tmp5, Register result);
1698 
1699 #ifdef _LP64
1700   void add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2);
1701   void multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
1702                              Register y, Register y_idx, Register z,
1703                              Register carry, Register product,
1704                              Register idx, Register kdx);
1705   void multiply_add_128_x_128(Register x_xstart, Register y, Register z,
1706                               Register yz_idx, Register idx,
1707                               Register carry, Register product, int offset);
1708   void multiply_128_x_128_bmi2_loop(Register y, Register z,
1709                                     Register carry, Register carry2,
1710                                     Register idx, Register jdx,
1711                                     Register yz_idx1, Register yz_idx2,
1712                                     Register tmp, Register tmp3, Register tmp4);
1713   void multiply_128_x_128_loop(Register x_xstart, Register y, Register z,
1714                                Register yz_idx, Register idx, Register jdx,
1715                                Register carry, Register product,
1716                                Register carry2);
1717   void multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,
1718                        Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5);
1719   void square_rshift(Register x, Register len, Register z, Register tmp1, Register tmp3,
1720                      Register tmp4, Register tmp5, Register rdxReg, Register raxReg);
1721   void multiply_add_64_bmi2(Register sum, Register op1, Register op2, Register carry,
1722                             Register tmp2);
1723   void multiply_add_64(Register sum, Register op1, Register op2, Register carry,
1724                        Register rdxReg, Register raxReg);
1725   void add_one_64(Register z, Register zlen, Register carry, Register tmp1);
1726   void lshift_by_1(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2,
1727                        Register tmp3, Register tmp4);
1728   void square_to_len(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2,
1729                      Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg);
1730 
1731   void mul_add_128_x_32_loop(Register out, Register in, Register offset, Register len, Register tmp1,
1732                Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg,
1733                Register raxReg);
1734   void mul_add(Register out, Register in, Register offset, Register len, Register k, Register tmp1,
1735                Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg,
1736                Register raxReg);
1737   void vectorized_mismatch(Register obja, Register objb, Register length, Register log2_array_indxscale,
1738                            Register result, Register tmp1, Register tmp2,
1739                            XMMRegister vec1, XMMRegister vec2, XMMRegister vec3);
1740 #endif
1741 
1742   // CRC32 code for java.util.zip.CRC32::updateBytes() intrinsic.
1743   void update_byte_crc32(Register crc, Register val, Register table);
1744   void kernel_crc32(Register crc, Register buf, Register len, Register table, Register tmp);
1745   // CRC32C code for java.util.zip.CRC32C::updateBytes() intrinsic
1746   // Note on a naming convention:
1747   // Prefix w = register only used on a Westmere+ architecture
1748   // Prefix n = register only used on a Nehalem architecture
1749 #ifdef _LP64
1750   void crc32c_ipl_alg4(Register in_out, uint32_t n,
1751                        Register tmp1, Register tmp2, Register tmp3);
1752 #else
1753   void crc32c_ipl_alg4(Register in_out, uint32_t n,
1754                        Register tmp1, Register tmp2, Register tmp3,
1755                        XMMRegister xtmp1, XMMRegister xtmp2);
1756 #endif
1757   void crc32c_pclmulqdq(XMMRegister w_xtmp1,
1758                         Register in_out,
1759                         uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
1760                         XMMRegister w_xtmp2,
1761                         Register tmp1,
1762                         Register n_tmp2, Register n_tmp3);
1763   void crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
1764                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
1765                        Register tmp1, Register tmp2,
1766                        Register n_tmp3);
1767   void crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
1768                          Register in_out1, Register in_out2, Register in_out3,
1769                          Register tmp1, Register tmp2, Register tmp3,
1770                          XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
1771                          Register tmp4, Register tmp5,
1772                          Register n_tmp6);
1773   void crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
1774                             Register tmp1, Register tmp2, Register tmp3,
1775                             Register tmp4, Register tmp5, Register tmp6,
1776                             XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
1777                             bool is_pclmulqdq_supported);
1778   // Fold 128-bit data chunk
1779   void fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset);
1780   void fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf);
1781   // Fold 8-bit data
1782   void fold_8bit_crc32(Register crc, Register table, Register tmp);
1783   void fold_8bit_crc32(XMMRegister crc, Register table, XMMRegister xtmp, Register tmp);
1784   void fold_128bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset);
1785 
1786   // Compress char[] array to byte[].
1787   void char_array_compress(Register src, Register dst, Register len,
1788                            XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3,
1789                            XMMRegister tmp4, Register tmp5, Register result);
1790 
1791   // Inflate byte[] array to char[].
1792   void byte_array_inflate(Register src, Register dst, Register len,
1793                           XMMRegister tmp1, Register tmp2);
1794 
1795 #ifdef _LP64
1796   void convert_f2i(Register dst, XMMRegister src);
1797   void convert_d2i(Register dst, XMMRegister src);
1798   void convert_f2l(Register dst, XMMRegister src);
1799   void convert_d2l(Register dst, XMMRegister src);
1800 
1801   void cache_wb(Address line);
1802   void cache_wbsync(bool is_pre);
1803 #endif // _LP64
1804 
1805   void vallones(XMMRegister dst, int vector_len);
1806 
1807   #include &quot;asm/macroAssembler_common.hpp&quot;
1808 };
1809 
1810 /**
1811  * class SkipIfEqual:
1812  *
1813  * Instantiating this class will result in assembly code being output that will
1814  * jump around any code emitted between the creation of the instance and it&#39;s
1815  * automatic destruction at the end of a scope block, depending on the value of
1816  * the flag passed to the constructor, which will be checked at run-time.
1817  */
1818 class SkipIfEqual {
1819  private:
1820   MacroAssembler* _masm;
1821   Label _label;
1822 
1823  public:
1824    SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value);
1825    ~SkipIfEqual();
1826 };
1827 
1828 #endif // CPU_X86_MACROASSEMBLER_X86_HPP
    </pre>
  </body>
</html>
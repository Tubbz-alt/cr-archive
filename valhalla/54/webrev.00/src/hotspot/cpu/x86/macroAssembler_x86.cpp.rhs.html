<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;asm/assembler.hpp&quot;
  28 #include &quot;asm/assembler.inline.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;memory/universe.hpp&quot;
  36 #include &quot;oops/accessDecorators.hpp&quot;
  37 #include &quot;oops/compressedOops.inline.hpp&quot;
  38 #include &quot;oops/klass.inline.hpp&quot;
  39 #include &quot;prims/methodHandles.hpp&quot;
  40 #include &quot;runtime/biasedLocking.hpp&quot;
  41 #include &quot;runtime/flags/flagSetting.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/objectMonitor.hpp&quot;
  44 #include &quot;runtime/os.hpp&quot;
  45 #include &quot;runtime/safepoint.hpp&quot;
  46 #include &quot;runtime/safepointMechanism.hpp&quot;
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #include &quot;runtime/signature_cc.hpp&quot;
  49 #include &quot;runtime/stubRoutines.hpp&quot;
  50 #include &quot;runtime/thread.hpp&quot;
  51 #include &quot;utilities/macros.hpp&quot;
  52 #include &quot;vmreg_x86.inline.hpp&quot;
  53 #include &quot;crc32c.h&quot;
  54 #ifdef COMPILER2
  55 #include &quot;opto/output.hpp&quot;
  56 #endif
  57 
  58 #ifdef PRODUCT
  59 #define BLOCK_COMMENT(str) /* nothing */
  60 #define STOP(error) stop(error)
  61 #else
  62 #define BLOCK_COMMENT(str) block_comment(str)
  63 #define STOP(error) block_comment(error); stop(error)
  64 #endif
  65 
  66 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  67 
  68 #ifdef ASSERT
  69 bool AbstractAssembler::pd_check_instruction_mark() { return true; }
  70 #endif
  71 
  72 static Assembler::Condition reverse[] = {
  73     Assembler::noOverflow     /* overflow      = 0x0 */ ,
  74     Assembler::overflow       /* noOverflow    = 0x1 */ ,
  75     Assembler::aboveEqual     /* carrySet      = 0x2, below         = 0x2 */ ,
  76     Assembler::below          /* aboveEqual    = 0x3, carryClear    = 0x3 */ ,
  77     Assembler::notZero        /* zero          = 0x4, equal         = 0x4 */ ,
  78     Assembler::zero           /* notZero       = 0x5, notEqual      = 0x5 */ ,
  79     Assembler::above          /* belowEqual    = 0x6 */ ,
  80     Assembler::belowEqual     /* above         = 0x7 */ ,
  81     Assembler::positive       /* negative      = 0x8 */ ,
  82     Assembler::negative       /* positive      = 0x9 */ ,
  83     Assembler::noParity       /* parity        = 0xa */ ,
  84     Assembler::parity         /* noParity      = 0xb */ ,
  85     Assembler::greaterEqual   /* less          = 0xc */ ,
  86     Assembler::less           /* greaterEqual  = 0xd */ ,
  87     Assembler::greater        /* lessEqual     = 0xe */ ,
  88     Assembler::lessEqual      /* greater       = 0xf, */
  89 
  90 };
  91 
  92 
  93 // Implementation of MacroAssembler
  94 
  95 // First all the versions that have distinct versions depending on 32/64 bit
  96 // Unless the difference is trivial (1 line or so).
  97 
  98 #ifndef _LP64
  99 
 100 // 32bit versions
 101 
 102 Address MacroAssembler::as_Address(AddressLiteral adr) {
 103   return Address(adr.target(), adr.rspec());
 104 }
 105 
 106 Address MacroAssembler::as_Address(ArrayAddress adr) {
 107   return Address::make_array(adr);
 108 }
 109 
 110 void MacroAssembler::call_VM_leaf_base(address entry_point,
 111                                        int number_of_arguments) {
 112   call(RuntimeAddress(entry_point));
 113   increment(rsp, number_of_arguments * wordSize);
 114 }
 115 
 116 void MacroAssembler::cmpklass(Address src1, Metadata* obj) {
 117   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 118 }
 119 
 120 void MacroAssembler::cmpklass(Register src1, Metadata* obj) {
 121   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 122 }
 123 
 124 void MacroAssembler::cmpoop_raw(Address src1, jobject obj) {
 125   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
 126 }
 127 
 128 void MacroAssembler::cmpoop_raw(Register src1, jobject obj) {
 129   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
 130 }
 131 
 132 void MacroAssembler::cmpoop(Address src1, jobject obj) {
 133   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 134   bs-&gt;obj_equals(this, src1, obj);
 135 }
 136 
 137 void MacroAssembler::cmpoop(Register src1, jobject obj) {
 138   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 139   bs-&gt;obj_equals(this, src1, obj);
 140 }
 141 
 142 void MacroAssembler::extend_sign(Register hi, Register lo) {
 143   // According to Intel Doc. AP-526, &quot;Integer Divide&quot;, p.18.
 144   if (VM_Version::is_P6() &amp;&amp; hi == rdx &amp;&amp; lo == rax) {
 145     cdql();
 146   } else {
 147     movl(hi, lo);
 148     sarl(hi, 31);
 149   }
 150 }
 151 
 152 void MacroAssembler::jC2(Register tmp, Label&amp; L) {
 153   // set parity bit if FPU flag C2 is set (via rax)
 154   save_rax(tmp);
 155   fwait(); fnstsw_ax();
 156   sahf();
 157   restore_rax(tmp);
 158   // branch
 159   jcc(Assembler::parity, L);
 160 }
 161 
 162 void MacroAssembler::jnC2(Register tmp, Label&amp; L) {
 163   // set parity bit if FPU flag C2 is set (via rax)
 164   save_rax(tmp);
 165   fwait(); fnstsw_ax();
 166   sahf();
 167   restore_rax(tmp);
 168   // branch
 169   jcc(Assembler::noParity, L);
 170 }
 171 
 172 // 32bit can do a case table jump in one instruction but we no longer allow the base
 173 // to be installed in the Address class
 174 void MacroAssembler::jump(ArrayAddress entry) {
 175   jmp(as_Address(entry));
 176 }
 177 
 178 // Note: y_lo will be destroyed
 179 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
 180   // Long compare for Java (semantics as described in JVM spec.)
 181   Label high, low, done;
 182 
 183   cmpl(x_hi, y_hi);
 184   jcc(Assembler::less, low);
 185   jcc(Assembler::greater, high);
 186   // x_hi is the return register
 187   xorl(x_hi, x_hi);
 188   cmpl(x_lo, y_lo);
 189   jcc(Assembler::below, low);
 190   jcc(Assembler::equal, done);
 191 
 192   bind(high);
 193   xorl(x_hi, x_hi);
 194   increment(x_hi);
 195   jmp(done);
 196 
 197   bind(low);
 198   xorl(x_hi, x_hi);
 199   decrementl(x_hi);
 200 
 201   bind(done);
 202 }
 203 
 204 void MacroAssembler::lea(Register dst, AddressLiteral src) {
 205     mov_literal32(dst, (int32_t)src.target(), src.rspec());
 206 }
 207 
 208 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
 209   // leal(dst, as_Address(adr));
 210   // see note in movl as to why we must use a move
 211   mov_literal32(dst, (int32_t) adr.target(), adr.rspec());
 212 }
 213 
 214 void MacroAssembler::leave() {
 215   mov(rsp, rbp);
 216   pop(rbp);
 217 }
 218 
 219 void MacroAssembler::lmul(int x_rsp_offset, int y_rsp_offset) {
 220   // Multiplication of two Java long values stored on the stack
 221   // as illustrated below. Result is in rdx:rax.
 222   //
 223   // rsp ---&gt; [  ??  ] \               \
 224   //            ....    | y_rsp_offset  |
 225   //          [ y_lo ] /  (in bytes)    | x_rsp_offset
 226   //          [ y_hi ]                  | (in bytes)
 227   //            ....                    |
 228   //          [ x_lo ]                 /
 229   //          [ x_hi ]
 230   //            ....
 231   //
 232   // Basic idea: lo(result) = lo(x_lo * y_lo)
 233   //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 234   Address x_hi(rsp, x_rsp_offset + wordSize); Address x_lo(rsp, x_rsp_offset);
 235   Address y_hi(rsp, y_rsp_offset + wordSize); Address y_lo(rsp, y_rsp_offset);
 236   Label quick;
 237   // load x_hi, y_hi and check if quick
 238   // multiplication is possible
 239   movl(rbx, x_hi);
 240   movl(rcx, y_hi);
 241   movl(rax, rbx);
 242   orl(rbx, rcx);                                 // rbx, = 0 &lt;=&gt; x_hi = 0 and y_hi = 0
 243   jcc(Assembler::zero, quick);                   // if rbx, = 0 do quick multiply
 244   // do full multiplication
 245   // 1st step
 246   mull(y_lo);                                    // x_hi * y_lo
 247   movl(rbx, rax);                                // save lo(x_hi * y_lo) in rbx,
 248   // 2nd step
 249   movl(rax, x_lo);
 250   mull(rcx);                                     // x_lo * y_hi
 251   addl(rbx, rax);                                // add lo(x_lo * y_hi) to rbx,
 252   // 3rd step
 253   bind(quick);                                   // note: rbx, = 0 if quick multiply!
 254   movl(rax, x_lo);
 255   mull(y_lo);                                    // x_lo * y_lo
 256   addl(rdx, rbx);                                // correct hi(x_lo * y_lo)
 257 }
 258 
 259 void MacroAssembler::lneg(Register hi, Register lo) {
 260   negl(lo);
 261   adcl(hi, 0);
 262   negl(hi);
 263 }
 264 
 265 void MacroAssembler::lshl(Register hi, Register lo) {
 266   // Java shift left long support (semantics as described in JVM spec., p.305)
 267   // (basic idea for shift counts s &gt;= n: x &lt;&lt; s == (x &lt;&lt; n) &lt;&lt; (s - n))
 268   // shift value is in rcx !
 269   assert(hi != rcx, &quot;must not use rcx&quot;);
 270   assert(lo != rcx, &quot;must not use rcx&quot;);
 271   const Register s = rcx;                        // shift count
 272   const int      n = BitsPerWord;
 273   Label L;
 274   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
 275   cmpl(s, n);                                    // if (s &lt; n)
 276   jcc(Assembler::less, L);                       // else (s &gt;= n)
 277   movl(hi, lo);                                  // x := x &lt;&lt; n
 278   xorl(lo, lo);
 279   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
 280   bind(L);                                       // s (mod n) &lt; n
 281   shldl(hi, lo);                                 // x := x &lt;&lt; s
 282   shll(lo);
 283 }
 284 
 285 
 286 void MacroAssembler::lshr(Register hi, Register lo, bool sign_extension) {
 287   // Java shift right long support (semantics as described in JVM spec., p.306 &amp; p.310)
 288   // (basic idea for shift counts s &gt;= n: x &gt;&gt; s == (x &gt;&gt; n) &gt;&gt; (s - n))
 289   assert(hi != rcx, &quot;must not use rcx&quot;);
 290   assert(lo != rcx, &quot;must not use rcx&quot;);
 291   const Register s = rcx;                        // shift count
 292   const int      n = BitsPerWord;
 293   Label L;
 294   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
 295   cmpl(s, n);                                    // if (s &lt; n)
 296   jcc(Assembler::less, L);                       // else (s &gt;= n)
 297   movl(lo, hi);                                  // x := x &gt;&gt; n
 298   if (sign_extension) sarl(hi, 31);
 299   else                xorl(hi, hi);
 300   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
 301   bind(L);                                       // s (mod n) &lt; n
 302   shrdl(lo, hi);                                 // x := x &gt;&gt; s
 303   if (sign_extension) sarl(hi);
 304   else                shrl(hi);
 305 }
 306 
 307 void MacroAssembler::movoop(Register dst, jobject obj) {
 308   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
 309 }
 310 
 311 void MacroAssembler::movoop(Address dst, jobject obj) {
 312   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
 313 }
 314 
 315 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
 316   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 317 }
 318 
 319 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
 320   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 321 }
 322 
 323 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
 324   // scratch register is not used,
 325   // it is defined to match parameters of 64-bit version of this method.
 326   if (src.is_lval()) {
 327     mov_literal32(dst, (intptr_t)src.target(), src.rspec());
 328   } else {
 329     movl(dst, as_Address(src));
 330   }
 331 }
 332 
 333 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
 334   movl(as_Address(dst), src);
 335 }
 336 
 337 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
 338   movl(dst, as_Address(src));
 339 }
 340 
 341 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
 342 void MacroAssembler::movptr(Address dst, intptr_t src) {
 343   movl(dst, src);
 344 }
 345 
 346 
 347 void MacroAssembler::pop_callee_saved_registers() {
 348   pop(rcx);
 349   pop(rdx);
 350   pop(rdi);
 351   pop(rsi);
 352 }
 353 
 354 void MacroAssembler::push_callee_saved_registers() {
 355   push(rsi);
 356   push(rdi);
 357   push(rdx);
 358   push(rcx);
 359 }
 360 
 361 void MacroAssembler::pushoop(jobject obj) {
 362   push_literal32((int32_t)obj, oop_Relocation::spec_for_immediate());
 363 }
 364 
 365 void MacroAssembler::pushklass(Metadata* obj) {
 366   push_literal32((int32_t)obj, metadata_Relocation::spec_for_immediate());
 367 }
 368 
 369 void MacroAssembler::pushptr(AddressLiteral src) {
 370   if (src.is_lval()) {
 371     push_literal32((int32_t)src.target(), src.rspec());
 372   } else {
 373     pushl(as_Address(src));
 374   }
 375 }
 376 
 377 void MacroAssembler::set_word_if_not_zero(Register dst) {
 378   xorl(dst, dst);
 379   set_byte_if_not_zero(dst);
 380 }
 381 
 382 static void pass_arg0(MacroAssembler* masm, Register arg) {
 383   masm-&gt;push(arg);
 384 }
 385 
 386 static void pass_arg1(MacroAssembler* masm, Register arg) {
 387   masm-&gt;push(arg);
 388 }
 389 
 390 static void pass_arg2(MacroAssembler* masm, Register arg) {
 391   masm-&gt;push(arg);
 392 }
 393 
 394 static void pass_arg3(MacroAssembler* masm, Register arg) {
 395   masm-&gt;push(arg);
 396 }
 397 
 398 #ifndef PRODUCT
 399 extern &quot;C&quot; void findpc(intptr_t x);
 400 #endif
 401 
 402 void MacroAssembler::debug32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip, char* msg) {
 403   // In order to get locks to work, we need to fake a in_VM state
 404   JavaThread* thread = JavaThread::current();
 405   JavaThreadState saved_state = thread-&gt;thread_state();
 406   thread-&gt;set_thread_state(_thread_in_vm);
 407   if (ShowMessageBoxOnError) {
 408     JavaThread* thread = JavaThread::current();
 409     JavaThreadState saved_state = thread-&gt;thread_state();
 410     thread-&gt;set_thread_state(_thread_in_vm);
 411     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
 412       ttyLocker ttyl;
 413       BytecodeCounter::print();
 414     }
 415     // To see where a verify_oop failed, get $ebx+40/X for this frame.
 416     // This is the value of eip which points to where verify_oop will return.
 417     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
 418       print_state32(rdi, rsi, rbp, rsp, rbx, rdx, rcx, rax, eip);
 419       BREAKPOINT;
 420     }
 421   }
 422   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
 423 }
 424 
 425 void MacroAssembler::print_state32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip) {
 426   ttyLocker ttyl;
 427   FlagSetting fs(Debugging, true);
 428   tty-&gt;print_cr(&quot;eip = 0x%08x&quot;, eip);
 429 #ifndef PRODUCT
 430   if ((WizardMode || Verbose) &amp;&amp; PrintMiscellaneous) {
 431     tty-&gt;cr();
 432     findpc(eip);
 433     tty-&gt;cr();
 434   }
 435 #endif
 436 #define PRINT_REG(rax) \
 437   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, rax); }
 438   PRINT_REG(rax);
 439   PRINT_REG(rbx);
 440   PRINT_REG(rcx);
 441   PRINT_REG(rdx);
 442   PRINT_REG(rdi);
 443   PRINT_REG(rsi);
 444   PRINT_REG(rbp);
 445   PRINT_REG(rsp);
 446 #undef PRINT_REG
 447   // Print some words near top of staack.
 448   int* dump_sp = (int*) rsp;
 449   for (int col1 = 0; col1 &lt; 8; col1++) {
 450     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 451     os::print_location(tty, *dump_sp++);
 452   }
 453   for (int row = 0; row &lt; 16; row++) {
 454     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 455     for (int col = 0; col &lt; 8; col++) {
 456       tty-&gt;print(&quot; 0x%08x&quot;, *dump_sp++);
 457     }
 458     tty-&gt;cr();
 459   }
 460   // Print some instructions around pc:
 461   Disassembler::decode((address)eip-64, (address)eip);
 462   tty-&gt;print_cr(&quot;--------&quot;);
 463   Disassembler::decode((address)eip, (address)eip+32);
 464 }
 465 
 466 void MacroAssembler::stop(const char* msg) {
 467   ExternalAddress message((address)msg);
 468   // push address of message
 469   pushptr(message.addr());
 470   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
 471   pusha();                                            // push registers
 472   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug32)));
 473   hlt();
 474 }
 475 
 476 void MacroAssembler::warn(const char* msg) {
 477   push_CPU_state();
 478 
 479   ExternalAddress message((address) msg);
 480   // push address of message
 481   pushptr(message.addr());
 482 
 483   call(RuntimeAddress(CAST_FROM_FN_PTR(address, warning)));
 484   addl(rsp, wordSize);       // discard argument
 485   pop_CPU_state();
 486 }
 487 
 488 void MacroAssembler::print_state() {
 489   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
 490   pusha();                                            // push registers
 491 
 492   push_CPU_state();
 493   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::print_state32)));
 494   pop_CPU_state();
 495 
 496   popa();
 497   addl(rsp, wordSize);
 498 }
 499 
 500 #else // _LP64
 501 
 502 // 64 bit versions
 503 
 504 Address MacroAssembler::as_Address(AddressLiteral adr) {
 505   // amd64 always does this as a pc-rel
 506   // we can be absolute or disp based on the instruction type
 507   // jmp/call are displacements others are absolute
 508   assert(!adr.is_lval(), &quot;must be rval&quot;);
 509   assert(reachable(adr), &quot;must be&quot;);
 510   return Address((int32_t)(intptr_t)(adr.target() - pc()), adr.target(), adr.reloc());
 511 
 512 }
 513 
 514 Address MacroAssembler::as_Address(ArrayAddress adr) {
 515   AddressLiteral base = adr.base();
 516   lea(rscratch1, base);
 517   Address index = adr.index();
 518   assert(index._disp == 0, &quot;must not have disp&quot;); // maybe it can?
 519   Address array(rscratch1, index._index, index._scale, index._disp);
 520   return array;
 521 }
 522 
 523 void MacroAssembler::call_VM_leaf_base(address entry_point, int num_args) {
 524   Label L, E;
 525 
 526 #ifdef _WIN64
 527   // Windows always allocates space for it&#39;s register args
 528   assert(num_args &lt;= 4, &quot;only register arguments supported&quot;);
 529   subq(rsp,  frame::arg_reg_save_area_bytes);
 530 #endif
 531 
 532   // Align stack if necessary
 533   testl(rsp, 15);
 534   jcc(Assembler::zero, L);
 535 
 536   subq(rsp, 8);
 537   {
 538     call(RuntimeAddress(entry_point));
 539   }
 540   addq(rsp, 8);
 541   jmp(E);
 542 
 543   bind(L);
 544   {
 545     call(RuntimeAddress(entry_point));
 546   }
 547 
 548   bind(E);
 549 
 550 #ifdef _WIN64
 551   // restore stack pointer
 552   addq(rsp, frame::arg_reg_save_area_bytes);
 553 #endif
 554 
 555 }
 556 
 557 void MacroAssembler::cmp64(Register src1, AddressLiteral src2) {
 558   assert(!src2.is_lval(), &quot;should use cmpptr&quot;);
 559 
 560   if (reachable(src2)) {
 561     cmpq(src1, as_Address(src2));
 562   } else {
 563     lea(rscratch1, src2);
 564     Assembler::cmpq(src1, Address(rscratch1, 0));
 565   }
 566 }
 567 
 568 int MacroAssembler::corrected_idivq(Register reg) {
 569   // Full implementation of Java ldiv and lrem; checks for special
 570   // case as described in JVM spec., p.243 &amp; p.271.  The function
 571   // returns the (pc) offset of the idivl instruction - may be needed
 572   // for implicit exceptions.
 573   //
 574   //         normal case                           special case
 575   //
 576   // input : rax: dividend                         min_long
 577   //         reg: divisor   (may not be eax/edx)   -1
 578   //
 579   // output: rax: quotient  (= rax idiv reg)       min_long
 580   //         rdx: remainder (= rax irem reg)       0
 581   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax or rdx register&quot;);
 582   static const int64_t min_long = 0x8000000000000000;
 583   Label normal_case, special_case;
 584 
 585   // check for special case
 586   cmp64(rax, ExternalAddress((address) &amp;min_long));
 587   jcc(Assembler::notEqual, normal_case);
 588   xorl(rdx, rdx); // prepare rdx for possible special case (where
 589                   // remainder = 0)
 590   cmpq(reg, -1);
 591   jcc(Assembler::equal, special_case);
 592 
 593   // handle normal case
 594   bind(normal_case);
 595   cdqq();
 596   int idivq_offset = offset();
 597   idivq(reg);
 598 
 599   // normal and special case exit
 600   bind(special_case);
 601 
 602   return idivq_offset;
 603 }
 604 
 605 void MacroAssembler::decrementq(Register reg, int value) {
 606   if (value == min_jint) { subq(reg, value); return; }
 607   if (value &lt;  0) { incrementq(reg, -value); return; }
 608   if (value == 0) {                        ; return; }
 609   if (value == 1 &amp;&amp; UseIncDec) { decq(reg) ; return; }
 610   /* else */      { subq(reg, value)       ; return; }
 611 }
 612 
 613 void MacroAssembler::decrementq(Address dst, int value) {
 614   if (value == min_jint) { subq(dst, value); return; }
 615   if (value &lt;  0) { incrementq(dst, -value); return; }
 616   if (value == 0) {                        ; return; }
 617   if (value == 1 &amp;&amp; UseIncDec) { decq(dst) ; return; }
 618   /* else */      { subq(dst, value)       ; return; }
 619 }
 620 
 621 void MacroAssembler::incrementq(AddressLiteral dst) {
 622   if (reachable(dst)) {
 623     incrementq(as_Address(dst));
 624   } else {
 625     lea(rscratch1, dst);
 626     incrementq(Address(rscratch1, 0));
 627   }
 628 }
 629 
 630 void MacroAssembler::incrementq(Register reg, int value) {
 631   if (value == min_jint) { addq(reg, value); return; }
 632   if (value &lt;  0) { decrementq(reg, -value); return; }
 633   if (value == 0) {                        ; return; }
 634   if (value == 1 &amp;&amp; UseIncDec) { incq(reg) ; return; }
 635   /* else */      { addq(reg, value)       ; return; }
 636 }
 637 
 638 void MacroAssembler::incrementq(Address dst, int value) {
 639   if (value == min_jint) { addq(dst, value); return; }
 640   if (value &lt;  0) { decrementq(dst, -value); return; }
 641   if (value == 0) {                        ; return; }
 642   if (value == 1 &amp;&amp; UseIncDec) { incq(dst) ; return; }
 643   /* else */      { addq(dst, value)       ; return; }
 644 }
 645 
 646 // 32bit can do a case table jump in one instruction but we no longer allow the base
 647 // to be installed in the Address class
 648 void MacroAssembler::jump(ArrayAddress entry) {
 649   lea(rscratch1, entry.base());
 650   Address dispatch = entry.index();
 651   assert(dispatch._base == noreg, &quot;must be&quot;);
 652   dispatch._base = rscratch1;
 653   jmp(dispatch);
 654 }
 655 
 656 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
 657   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
 658   cmpq(x_lo, y_lo);
 659 }
 660 
 661 void MacroAssembler::lea(Register dst, AddressLiteral src) {
 662     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
 663 }
 664 
 665 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
 666   mov_literal64(rscratch1, (intptr_t)adr.target(), adr.rspec());
 667   movptr(dst, rscratch1);
 668 }
 669 
 670 void MacroAssembler::leave() {
 671   // %%% is this really better? Why not on 32bit too?
 672   emit_int8((unsigned char)0xC9); // LEAVE
 673 }
 674 
 675 void MacroAssembler::lneg(Register hi, Register lo) {
 676   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
 677   negq(lo);
 678 }
 679 
 680 void MacroAssembler::movoop(Register dst, jobject obj) {
 681   mov_literal64(dst, (intptr_t)obj, oop_Relocation::spec_for_immediate());
 682 }
 683 
 684 void MacroAssembler::movoop(Address dst, jobject obj) {
 685   mov_literal64(rscratch1, (intptr_t)obj, oop_Relocation::spec_for_immediate());
 686   movq(dst, rscratch1);
 687 }
 688 
 689 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
 690   mov_literal64(dst, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
 691 }
 692 
 693 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
 694   mov_literal64(rscratch1, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
 695   movq(dst, rscratch1);
 696 }
 697 
 698 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
 699   if (src.is_lval()) {
 700     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
 701   } else {
 702     if (reachable(src)) {
 703       movq(dst, as_Address(src));
 704     } else {
 705       lea(scratch, src);
 706       movq(dst, Address(scratch, 0));
 707     }
 708   }
 709 }
 710 
 711 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
 712   movq(as_Address(dst), src);
 713 }
 714 
 715 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
 716   movq(dst, as_Address(src));
 717 }
 718 
 719 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
 720 void MacroAssembler::movptr(Address dst, intptr_t src) {
 721   mov64(rscratch1, src);
 722   movq(dst, rscratch1);
 723 }
 724 
 725 // These are mostly for initializing NULL
 726 void MacroAssembler::movptr(Address dst, int32_t src) {
 727   movslq(dst, src);
 728 }
 729 
 730 void MacroAssembler::movptr(Register dst, int32_t src) {
 731   mov64(dst, (intptr_t)src);
 732 }
 733 
 734 void MacroAssembler::pushoop(jobject obj) {
 735   movoop(rscratch1, obj);
 736   push(rscratch1);
 737 }
 738 
 739 void MacroAssembler::pushklass(Metadata* obj) {
 740   mov_metadata(rscratch1, obj);
 741   push(rscratch1);
 742 }
 743 
 744 void MacroAssembler::pushptr(AddressLiteral src) {
 745   lea(rscratch1, src);
 746   if (src.is_lval()) {
 747     push(rscratch1);
 748   } else {
 749     pushq(Address(rscratch1, 0));
 750   }
 751 }
 752 
 753 void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
 754   // we must set sp to zero to clear frame
 755   movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
 756   // must clear fp, so that compiled frames are not confused; it is
 757   // possible that we need it only for debugging
 758   if (clear_fp) {
 759     movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
 760   }
 761 
 762   // Always clear the pc because it could have been set by make_walkable()
 763   movptr(Address(r15_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
 764   vzeroupper();
 765 }
 766 
 767 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 768                                          Register last_java_fp,
 769                                          address  last_java_pc) {
 770   vzeroupper();
 771   // determine last_java_sp register
 772   if (!last_java_sp-&gt;is_valid()) {
 773     last_java_sp = rsp;
 774   }
 775 
 776   // last_java_fp is optional
 777   if (last_java_fp-&gt;is_valid()) {
 778     movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()),
 779            last_java_fp);
 780   }
 781 
 782   // last_java_pc is optional
 783   if (last_java_pc != NULL) {
 784     Address java_pc(r15_thread,
 785                     JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());
 786     lea(rscratch1, InternalAddress(last_java_pc));
 787     movptr(java_pc, rscratch1);
 788   }
 789 
 790   movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
 791 }
 792 
 793 static void pass_arg0(MacroAssembler* masm, Register arg) {
 794   if (c_rarg0 != arg ) {
 795     masm-&gt;mov(c_rarg0, arg);
 796   }
 797 }
 798 
 799 static void pass_arg1(MacroAssembler* masm, Register arg) {
 800   if (c_rarg1 != arg ) {
 801     masm-&gt;mov(c_rarg1, arg);
 802   }
 803 }
 804 
 805 static void pass_arg2(MacroAssembler* masm, Register arg) {
 806   if (c_rarg2 != arg ) {
 807     masm-&gt;mov(c_rarg2, arg);
 808   }
 809 }
 810 
 811 static void pass_arg3(MacroAssembler* masm, Register arg) {
 812   if (c_rarg3 != arg ) {
 813     masm-&gt;mov(c_rarg3, arg);
 814   }
 815 }
 816 
 817 void MacroAssembler::stop(const char* msg) {
 818   if (ShowMessageBoxOnError) {
 819     address rip = pc();
 820     pusha(); // get regs on stack
 821     lea(c_rarg1, InternalAddress(rip));
 822     movq(c_rarg2, rsp); // pass pointer to regs array
 823   }
 824   lea(c_rarg0, ExternalAddress((address) msg));
 825   andq(rsp, -16); // align stack as required by ABI
 826   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug64)));
 827   hlt();
 828 }
 829 
 830 void MacroAssembler::warn(const char* msg) {
 831   push(rbp);
 832   movq(rbp, rsp);
 833   andq(rsp, -16);     // align stack as required by push_CPU_state and call
 834   push_CPU_state();   // keeps alignment at 16 bytes
 835   lea(c_rarg0, ExternalAddress((address) msg));
 836   lea(rax, ExternalAddress(CAST_FROM_FN_PTR(address, warning)));
 837   call(rax);
 838   pop_CPU_state();
 839   mov(rsp, rbp);
 840   pop(rbp);
 841 }
 842 
 843 void MacroAssembler::print_state() {
 844   address rip = pc();
 845   pusha();            // get regs on stack
 846   push(rbp);
 847   movq(rbp, rsp);
 848   andq(rsp, -16);     // align stack as required by push_CPU_state and call
 849   push_CPU_state();   // keeps alignment at 16 bytes
 850 
 851   lea(c_rarg0, InternalAddress(rip));
 852   lea(c_rarg1, Address(rbp, wordSize)); // pass pointer to regs array
 853   call_VM_leaf(CAST_FROM_FN_PTR(address, MacroAssembler::print_state64), c_rarg0, c_rarg1);
 854 
 855   pop_CPU_state();
 856   mov(rsp, rbp);
 857   pop(rbp);
 858   popa();
 859 }
 860 
 861 #ifndef PRODUCT
 862 extern &quot;C&quot; void findpc(intptr_t x);
 863 #endif
 864 
 865 void MacroAssembler::debug64(char* msg, int64_t pc, int64_t regs[]) {
 866   // In order to get locks to work, we need to fake a in_VM state
 867   if (ShowMessageBoxOnError) {
 868     JavaThread* thread = JavaThread::current();
 869     JavaThreadState saved_state = thread-&gt;thread_state();
 870     thread-&gt;set_thread_state(_thread_in_vm);
 871 #ifndef PRODUCT
 872     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
 873       ttyLocker ttyl;
 874       BytecodeCounter::print();
 875     }
 876 #endif
 877     // To see where a verify_oop failed, get $ebx+40/X for this frame.
 878     // XXX correct this offset for amd64
 879     // This is the value of eip which points to where verify_oop will return.
 880     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
 881       print_state64(pc, regs);
 882       BREAKPOINT;
 883     }
 884   }
 885   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
 886 }
 887 
 888 void MacroAssembler::print_state64(int64_t pc, int64_t regs[]) {
 889   ttyLocker ttyl;
 890   FlagSetting fs(Debugging, true);
 891   tty-&gt;print_cr(&quot;rip = 0x%016lx&quot;, (intptr_t)pc);
 892 #ifndef PRODUCT
 893   tty-&gt;cr();
 894   findpc(pc);
 895   tty-&gt;cr();
 896 #endif
 897 #define PRINT_REG(rax, value) \
 898   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, value); }
 899   PRINT_REG(rax, regs[15]);
 900   PRINT_REG(rbx, regs[12]);
 901   PRINT_REG(rcx, regs[14]);
 902   PRINT_REG(rdx, regs[13]);
 903   PRINT_REG(rdi, regs[8]);
 904   PRINT_REG(rsi, regs[9]);
 905   PRINT_REG(rbp, regs[10]);
 906   PRINT_REG(rsp, regs[11]);
 907   PRINT_REG(r8 , regs[7]);
 908   PRINT_REG(r9 , regs[6]);
 909   PRINT_REG(r10, regs[5]);
 910   PRINT_REG(r11, regs[4]);
 911   PRINT_REG(r12, regs[3]);
 912   PRINT_REG(r13, regs[2]);
 913   PRINT_REG(r14, regs[1]);
 914   PRINT_REG(r15, regs[0]);
 915 #undef PRINT_REG
 916   // Print some words near top of staack.
 917   int64_t* rsp = (int64_t*) regs[11];
 918   int64_t* dump_sp = rsp;
 919   for (int col1 = 0; col1 &lt; 8; col1++) {
 920     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 921     os::print_location(tty, *dump_sp++);
 922   }
 923   for (int row = 0; row &lt; 25; row++) {
 924     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 925     for (int col = 0; col &lt; 4; col++) {
 926       tty-&gt;print(&quot; 0x%016lx&quot;, (intptr_t)*dump_sp++);
 927     }
 928     tty-&gt;cr();
 929   }
 930   // Print some instructions around pc:
 931   Disassembler::decode((address)pc-64, (address)pc);
 932   tty-&gt;print_cr(&quot;--------&quot;);
 933   Disassembler::decode((address)pc, (address)pc+32);
 934 }
 935 
 936 #endif // _LP64
 937 
 938 // Now versions that are common to 32/64 bit
 939 
 940 void MacroAssembler::addptr(Register dst, int32_t imm32) {
 941   LP64_ONLY(addq(dst, imm32)) NOT_LP64(addl(dst, imm32));
 942 }
 943 
 944 void MacroAssembler::addptr(Register dst, Register src) {
 945   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
 946 }
 947 
 948 void MacroAssembler::addptr(Address dst, Register src) {
 949   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
 950 }
 951 
 952 void MacroAssembler::addsd(XMMRegister dst, AddressLiteral src) {
 953   if (reachable(src)) {
 954     Assembler::addsd(dst, as_Address(src));
 955   } else {
 956     lea(rscratch1, src);
 957     Assembler::addsd(dst, Address(rscratch1, 0));
 958   }
 959 }
 960 
 961 void MacroAssembler::addss(XMMRegister dst, AddressLiteral src) {
 962   if (reachable(src)) {
 963     addss(dst, as_Address(src));
 964   } else {
 965     lea(rscratch1, src);
 966     addss(dst, Address(rscratch1, 0));
 967   }
 968 }
 969 
 970 void MacroAssembler::addpd(XMMRegister dst, AddressLiteral src) {
 971   if (reachable(src)) {
 972     Assembler::addpd(dst, as_Address(src));
 973   } else {
 974     lea(rscratch1, src);
 975     Assembler::addpd(dst, Address(rscratch1, 0));
 976   }
 977 }
 978 
 979 void MacroAssembler::align(int modulus) {
 980   align(modulus, offset());
 981 }
 982 
 983 void MacroAssembler::align(int modulus, int target) {
 984   if (target % modulus != 0) {
 985     nop(modulus - (target % modulus));
 986   }
 987 }
 988 
 989 void MacroAssembler::andpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
 990   // Used in sign-masking with aligned address.
 991   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
 992   if (reachable(src)) {
 993     Assembler::andpd(dst, as_Address(src));
 994   } else {
 995     lea(scratch_reg, src);
 996     Assembler::andpd(dst, Address(scratch_reg, 0));
 997   }
 998 }
 999 
1000 void MacroAssembler::andps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
1001   // Used in sign-masking with aligned address.
1002   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
1003   if (reachable(src)) {
1004     Assembler::andps(dst, as_Address(src));
1005   } else {
1006     lea(scratch_reg, src);
1007     Assembler::andps(dst, Address(scratch_reg, 0));
1008   }
1009 }
1010 
1011 void MacroAssembler::andptr(Register dst, int32_t imm32) {
1012   LP64_ONLY(andq(dst, imm32)) NOT_LP64(andl(dst, imm32));
1013 }
1014 
1015 void MacroAssembler::atomic_incl(Address counter_addr) {
1016   lock();
1017   incrementl(counter_addr);
1018 }
1019 
1020 void MacroAssembler::atomic_incl(AddressLiteral counter_addr, Register scr) {
1021   if (reachable(counter_addr)) {
1022     atomic_incl(as_Address(counter_addr));
1023   } else {
1024     lea(scr, counter_addr);
1025     atomic_incl(Address(scr, 0));
1026   }
1027 }
1028 
1029 #ifdef _LP64
1030 void MacroAssembler::atomic_incq(Address counter_addr) {
1031   lock();
1032   incrementq(counter_addr);
1033 }
1034 
1035 void MacroAssembler::atomic_incq(AddressLiteral counter_addr, Register scr) {
1036   if (reachable(counter_addr)) {
1037     atomic_incq(as_Address(counter_addr));
1038   } else {
1039     lea(scr, counter_addr);
1040     atomic_incq(Address(scr, 0));
1041   }
1042 }
1043 #endif
1044 
1045 // Writes to stack successive pages until offset reached to check for
1046 // stack overflow + shadow pages.  This clobbers tmp.
1047 void MacroAssembler::bang_stack_size(Register size, Register tmp) {
1048   movptr(tmp, rsp);
1049   // Bang stack for total size given plus shadow page size.
1050   // Bang one page at a time because large size can bang beyond yellow and
1051   // red zones.
1052   Label loop;
1053   bind(loop);
1054   movl(Address(tmp, (-os::vm_page_size())), size );
1055   subptr(tmp, os::vm_page_size());
1056   subl(size, os::vm_page_size());
1057   jcc(Assembler::greater, loop);
1058 
1059   // Bang down shadow pages too.
1060   // At this point, (tmp-0) is the last address touched, so don&#39;t
1061   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
1062   // was post-decremented.)  Skip this address by starting at i=1, and
1063   // touch a few more pages below.  N.B.  It is important to touch all
1064   // the way down including all pages in the shadow zone.
1065   for (int i = 1; i &lt; ((int)JavaThread::stack_shadow_zone_size() / os::vm_page_size()); i++) {
1066     // this could be any sized move but this is can be a debugging crumb
1067     // so the bigger the better.
1068     movptr(Address(tmp, (-i*os::vm_page_size())), size );
1069   }
1070 }
1071 
1072 void MacroAssembler::reserved_stack_check() {
1073     // testing if reserved zone needs to be enabled
1074     Label no_reserved_zone_enabling;
1075     Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
1076     NOT_LP64(get_thread(rsi);)
1077 
1078     cmpptr(rsp, Address(thread, JavaThread::reserved_stack_activation_offset()));
1079     jcc(Assembler::below, no_reserved_zone_enabling);
1080 
1081     call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), thread);
1082     jump(RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));
1083     should_not_reach_here();
1084 
1085     bind(no_reserved_zone_enabling);
1086 }
1087 
1088 int MacroAssembler::biased_locking_enter(Register lock_reg,
1089                                          Register obj_reg,
1090                                          Register swap_reg,
1091                                          Register tmp_reg,
1092                                          bool swap_reg_contains_mark,
1093                                          Label&amp; done,
1094                                          Label* slow_case,
1095                                          BiasedLockingCounters* counters) {
1096   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1097   assert(swap_reg == rax, &quot;swap_reg must be rax for cmpxchgq&quot;);
1098   assert(tmp_reg != noreg, &quot;tmp_reg must be supplied&quot;);
1099   assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg);
1100   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);
1101   Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());
1102   NOT_LP64( Address saved_mark_addr(lock_reg, 0); )
1103 
1104   if (PrintBiasedLockingStatistics &amp;&amp; counters == NULL) {
1105     counters = BiasedLocking::counters();
1106   }
1107   // Biased locking
1108   // See whether the lock is currently biased toward our thread and
1109   // whether the epoch is still valid
1110   // Note that the runtime guarantees sufficient alignment of JavaThread
1111   // pointers to allow age to be placed into low bits
1112   // First check to see whether biasing is even enabled for this object
1113   Label cas_label;
1114   int null_check_offset = -1;
1115   if (!swap_reg_contains_mark) {
1116     null_check_offset = offset();
1117     movptr(swap_reg, mark_addr);
1118   }
1119   movptr(tmp_reg, swap_reg);
1120   andptr(tmp_reg, markWord::biased_lock_mask_in_place);
1121   cmpptr(tmp_reg, markWord::biased_lock_pattern);
1122   jcc(Assembler::notEqual, cas_label);
1123   // The bias pattern is present in the object&#39;s header. Need to check
1124   // whether the bias owner and the epoch are both still current.
1125 #ifndef _LP64
1126   // Note that because there is no current thread register on x86_32 we
1127   // need to store off the mark word we read out of the object to
1128   // avoid reloading it and needing to recheck invariants below. This
1129   // store is unfortunate but it makes the overall code shorter and
1130   // simpler.
1131   movptr(saved_mark_addr, swap_reg);
1132 #endif
1133   if (swap_reg_contains_mark) {
1134     null_check_offset = offset();
1135   }
1136   load_prototype_header(tmp_reg, obj_reg);
1137 #ifdef _LP64
1138   orptr(tmp_reg, r15_thread);
1139   xorptr(tmp_reg, swap_reg);
1140   Register header_reg = tmp_reg;
1141 #else
1142   xorptr(tmp_reg, swap_reg);
1143   get_thread(swap_reg);
1144   xorptr(swap_reg, tmp_reg);
1145   Register header_reg = swap_reg;
1146 #endif
1147   andptr(header_reg, ~((int) markWord::age_mask_in_place));
1148   if (counters != NULL) {
1149     cond_inc32(Assembler::zero,
1150                ExternalAddress((address) counters-&gt;biased_lock_entry_count_addr()));
1151   }
1152   jcc(Assembler::equal, done);
1153 
1154   Label try_revoke_bias;
1155   Label try_rebias;
1156 
1157   // At this point we know that the header has the bias pattern and
1158   // that we are not the bias owner in the current epoch. We need to
1159   // figure out more details about the state of the header in order to
1160   // know what operations can be legally performed on the object&#39;s
1161   // header.
1162 
1163   // If the low three bits in the xor result aren&#39;t clear, that means
1164   // the prototype header is no longer biased and we have to revoke
1165   // the bias on this object.
1166   testptr(header_reg, markWord::biased_lock_mask_in_place);
1167   jccb(Assembler::notZero, try_revoke_bias);
1168 
1169   // Biasing is still enabled for this data type. See whether the
1170   // epoch of the current bias is still valid, meaning that the epoch
1171   // bits of the mark word are equal to the epoch bits of the
1172   // prototype header. (Note that the prototype header&#39;s epoch bits
1173   // only change at a safepoint.) If not, attempt to rebias the object
1174   // toward the current thread. Note that we must be absolutely sure
1175   // that the current epoch is invalid in order to do this because
1176   // otherwise the manipulations it performs on the mark word are
1177   // illegal.
1178   testptr(header_reg, markWord::epoch_mask_in_place);
1179   jccb(Assembler::notZero, try_rebias);
1180 
1181   // The epoch of the current bias is still valid but we know nothing
1182   // about the owner; it might be set or it might be clear. Try to
1183   // acquire the bias of the object using an atomic operation. If this
1184   // fails we will go in to the runtime to revoke the object&#39;s bias.
1185   // Note that we first construct the presumed unbiased header so we
1186   // don&#39;t accidentally blow away another thread&#39;s valid bias.
1187   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
1188   andptr(swap_reg,
1189          markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);
1190 #ifdef _LP64
1191   movptr(tmp_reg, swap_reg);
1192   orptr(tmp_reg, r15_thread);
1193 #else
1194   get_thread(tmp_reg);
1195   orptr(tmp_reg, swap_reg);
1196 #endif
1197   lock();
1198   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1199   // If the biasing toward our thread failed, this means that
1200   // another thread succeeded in biasing it toward itself and we
1201   // need to revoke that bias. The revocation will occur in the
1202   // interpreter runtime in the slow case.
1203   if (counters != NULL) {
1204     cond_inc32(Assembler::zero,
1205                ExternalAddress((address) counters-&gt;anonymously_biased_lock_entry_count_addr()));
1206   }
1207   if (slow_case != NULL) {
1208     jcc(Assembler::notZero, *slow_case);
1209   }
1210   jmp(done);
1211 
1212   bind(try_rebias);
1213   // At this point we know the epoch has expired, meaning that the
1214   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
1215   // circumstances _only_, we are allowed to use the current header&#39;s
1216   // value as the comparison value when doing the cas to acquire the
1217   // bias in the current epoch. In other words, we allow transfer of
1218   // the bias from one thread to another directly in this situation.
1219   //
1220   // FIXME: due to a lack of registers we currently blow away the age
1221   // bits in this situation. Should attempt to preserve them.
1222   load_prototype_header(tmp_reg, obj_reg);
1223 #ifdef _LP64
1224   orptr(tmp_reg, r15_thread);
1225 #else
1226   get_thread(swap_reg);
1227   orptr(tmp_reg, swap_reg);
1228   movptr(swap_reg, saved_mark_addr);
1229 #endif
1230   lock();
1231   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1232   // If the biasing toward our thread failed, then another thread
1233   // succeeded in biasing it toward itself and we need to revoke that
1234   // bias. The revocation will occur in the runtime in the slow case.
1235   if (counters != NULL) {
1236     cond_inc32(Assembler::zero,
1237                ExternalAddress((address) counters-&gt;rebiased_lock_entry_count_addr()));
1238   }
1239   if (slow_case != NULL) {
1240     jcc(Assembler::notZero, *slow_case);
1241   }
1242   jmp(done);
1243 
1244   bind(try_revoke_bias);
1245   // The prototype mark in the klass doesn&#39;t have the bias bit set any
1246   // more, indicating that objects of this data type are not supposed
1247   // to be biased any more. We are going to try to reset the mark of
1248   // this object to the prototype value and fall through to the
1249   // CAS-based locking scheme. Note that if our CAS fails, it means
1250   // that another thread raced us for the privilege of revoking the
1251   // bias of this particular object, so it&#39;s okay to continue in the
1252   // normal locking code.
1253   //
1254   // FIXME: due to a lack of registers we currently blow away the age
1255   // bits in this situation. Should attempt to preserve them.
1256   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
1257   load_prototype_header(tmp_reg, obj_reg);
1258   lock();
1259   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1260   // Fall through to the normal CAS-based lock, because no matter what
1261   // the result of the above CAS, some thread must have succeeded in
1262   // removing the bias bit from the object&#39;s header.
1263   if (counters != NULL) {
1264     cond_inc32(Assembler::zero,
1265                ExternalAddress((address) counters-&gt;revoked_lock_entry_count_addr()));
1266   }
1267 
1268   bind(cas_label);
1269 
1270   return null_check_offset;
1271 }
1272 
1273 void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label&amp; done) {
1274   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1275 
1276   // Check for biased locking unlock case, which is a no-op
1277   // Note: we do not have to check the thread ID for two reasons.
1278   // First, the interpreter checks for IllegalMonitorStateException at
1279   // a higher level. Second, if the bias was revoked while we held the
1280   // lock, the object could not be rebiased toward another thread, so
1281   // the bias bit would be clear.
1282   movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1283   andptr(temp_reg, markWord::biased_lock_mask_in_place);
1284   cmpptr(temp_reg, markWord::biased_lock_pattern);
1285   jcc(Assembler::equal, done);
1286 }
1287 
1288 void MacroAssembler::c2bool(Register x) {
1289   // implements x == 0 ? 0 : 1
1290   // note: must only look at least-significant byte of x
1291   //       since C-style booleans are stored in one byte
1292   //       only! (was bug)
1293   andl(x, 0xFF);
1294   setb(Assembler::notZero, x);
1295 }
1296 
1297 // Wouldn&#39;t need if AddressLiteral version had new name
1298 void MacroAssembler::call(Label&amp; L, relocInfo::relocType rtype) {
1299   Assembler::call(L, rtype);
1300 }
1301 
1302 void MacroAssembler::call(Register entry) {
1303   Assembler::call(entry);
1304 }
1305 
1306 void MacroAssembler::call(AddressLiteral entry) {
1307   if (reachable(entry)) {
1308     Assembler::call_literal(entry.target(), entry.rspec());
1309   } else {
1310     lea(rscratch1, entry);
1311     Assembler::call(rscratch1);
1312   }
1313 }
1314 
1315 void MacroAssembler::ic_call(address entry, jint method_index) {
1316   RelocationHolder rh = virtual_call_Relocation::spec(pc(), method_index);
1317   movptr(rax, (intptr_t)Universe::non_oop_word());
1318   call(AddressLiteral(entry, rh));
1319 }
1320 
1321 // Implementation of call_VM versions
1322 
1323 void MacroAssembler::call_VM(Register oop_result,
1324                              address entry_point,
1325                              bool check_exceptions) {
1326   Label C, E;
1327   call(C, relocInfo::none);
1328   jmp(E);
1329 
1330   bind(C);
1331   call_VM_helper(oop_result, entry_point, 0, check_exceptions);
1332   ret(0);
1333 
1334   bind(E);
1335 }
1336 
1337 void MacroAssembler::call_VM(Register oop_result,
1338                              address entry_point,
1339                              Register arg_1,
1340                              bool check_exceptions) {
1341   Label C, E;
1342   call(C, relocInfo::none);
1343   jmp(E);
1344 
1345   bind(C);
1346   pass_arg1(this, arg_1);
1347   call_VM_helper(oop_result, entry_point, 1, check_exceptions);
1348   ret(0);
1349 
1350   bind(E);
1351 }
1352 
1353 void MacroAssembler::call_VM(Register oop_result,
1354                              address entry_point,
1355                              Register arg_1,
1356                              Register arg_2,
1357                              bool check_exceptions) {
1358   Label C, E;
1359   call(C, relocInfo::none);
1360   jmp(E);
1361 
1362   bind(C);
1363 
1364   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1365 
1366   pass_arg2(this, arg_2);
1367   pass_arg1(this, arg_1);
1368   call_VM_helper(oop_result, entry_point, 2, check_exceptions);
1369   ret(0);
1370 
1371   bind(E);
1372 }
1373 
1374 void MacroAssembler::call_VM(Register oop_result,
1375                              address entry_point,
1376                              Register arg_1,
1377                              Register arg_2,
1378                              Register arg_3,
1379                              bool check_exceptions) {
1380   Label C, E;
1381   call(C, relocInfo::none);
1382   jmp(E);
1383 
1384   bind(C);
1385 
1386   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1387   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1388   pass_arg3(this, arg_3);
1389 
1390   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1391   pass_arg2(this, arg_2);
1392 
1393   pass_arg1(this, arg_1);
1394   call_VM_helper(oop_result, entry_point, 3, check_exceptions);
1395   ret(0);
1396 
1397   bind(E);
1398 }
1399 
1400 void MacroAssembler::call_VM(Register oop_result,
1401                              Register last_java_sp,
1402                              address entry_point,
1403                              int number_of_arguments,
1404                              bool check_exceptions) {
1405   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
1406   call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
1407 }
1408 
1409 void MacroAssembler::call_VM(Register oop_result,
1410                              Register last_java_sp,
1411                              address entry_point,
1412                              Register arg_1,
1413                              bool check_exceptions) {
1414   pass_arg1(this, arg_1);
1415   call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
1416 }
1417 
1418 void MacroAssembler::call_VM(Register oop_result,
1419                              Register last_java_sp,
1420                              address entry_point,
1421                              Register arg_1,
1422                              Register arg_2,
1423                              bool check_exceptions) {
1424 
1425   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1426   pass_arg2(this, arg_2);
1427   pass_arg1(this, arg_1);
1428   call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
1429 }
1430 
1431 void MacroAssembler::call_VM(Register oop_result,
1432                              Register last_java_sp,
1433                              address entry_point,
1434                              Register arg_1,
1435                              Register arg_2,
1436                              Register arg_3,
1437                              bool check_exceptions) {
1438   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1439   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1440   pass_arg3(this, arg_3);
1441   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1442   pass_arg2(this, arg_2);
1443   pass_arg1(this, arg_1);
1444   call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
1445 }
1446 
1447 void MacroAssembler::super_call_VM(Register oop_result,
1448                                    Register last_java_sp,
1449                                    address entry_point,
1450                                    int number_of_arguments,
1451                                    bool check_exceptions) {
1452   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
1453   MacroAssembler::call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
1454 }
1455 
1456 void MacroAssembler::super_call_VM(Register oop_result,
1457                                    Register last_java_sp,
1458                                    address entry_point,
1459                                    Register arg_1,
1460                                    bool check_exceptions) {
1461   pass_arg1(this, arg_1);
1462   super_call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
1463 }
1464 
1465 void MacroAssembler::super_call_VM(Register oop_result,
1466                                    Register last_java_sp,
1467                                    address entry_point,
1468                                    Register arg_1,
1469                                    Register arg_2,
1470                                    bool check_exceptions) {
1471 
1472   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1473   pass_arg2(this, arg_2);
1474   pass_arg1(this, arg_1);
1475   super_call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
1476 }
1477 
1478 void MacroAssembler::super_call_VM(Register oop_result,
1479                                    Register last_java_sp,
1480                                    address entry_point,
1481                                    Register arg_1,
1482                                    Register arg_2,
1483                                    Register arg_3,
1484                                    bool check_exceptions) {
1485   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1486   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1487   pass_arg3(this, arg_3);
1488   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1489   pass_arg2(this, arg_2);
1490   pass_arg1(this, arg_1);
1491   super_call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
1492 }
1493 
1494 void MacroAssembler::call_VM_base(Register oop_result,
1495                                   Register java_thread,
1496                                   Register last_java_sp,
1497                                   address  entry_point,
1498                                   int      number_of_arguments,
1499                                   bool     check_exceptions) {
1500   // determine java_thread register
1501   if (!java_thread-&gt;is_valid()) {
1502 #ifdef _LP64
1503     java_thread = r15_thread;
1504 #else
1505     java_thread = rdi;
1506     get_thread(java_thread);
1507 #endif // LP64
1508   }
1509   // determine last_java_sp register
1510   if (!last_java_sp-&gt;is_valid()) {
1511     last_java_sp = rsp;
1512   }
1513   // debugging support
1514   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
1515   LP64_ONLY(assert(java_thread == r15_thread, &quot;unexpected register&quot;));
1516 #ifdef ASSERT
1517   // TraceBytecodes does not use r12 but saves it over the call, so don&#39;t verify
1518   // r12 is the heapbase.
1519   LP64_ONLY(if ((UseCompressedOops || UseCompressedClassPointers) &amp;&amp; !TraceBytecodes) verify_heapbase(&quot;call_VM_base: heap base corrupted?&quot;);)
1520 #endif // ASSERT
1521 
1522   assert(java_thread != oop_result  , &quot;cannot use the same register for java_thread &amp; oop_result&quot;);
1523   assert(java_thread != last_java_sp, &quot;cannot use the same register for java_thread &amp; last_java_sp&quot;);
1524 
1525   // push java thread (becomes first argument of C function)
1526 
1527   NOT_LP64(push(java_thread); number_of_arguments++);
1528   LP64_ONLY(mov(c_rarg0, r15_thread));
1529 
1530   // set last Java frame before call
1531   assert(last_java_sp != rbp, &quot;can&#39;t use ebp/rbp&quot;);
1532 
1533   // Only interpreter should have to set fp
1534   set_last_Java_frame(java_thread, last_java_sp, rbp, NULL);
1535 
1536   // do the call, remove parameters
1537   MacroAssembler::call_VM_leaf_base(entry_point, number_of_arguments);
1538 
1539   // restore the thread (cannot use the pushed argument since arguments
1540   // may be overwritten by C code generated by an optimizing compiler);
1541   // however can use the register value directly if it is callee saved.
1542   if (LP64_ONLY(true ||) java_thread == rdi || java_thread == rsi) {
1543     // rdi &amp; rsi (also r15) are callee saved -&gt; nothing to do
1544 #ifdef ASSERT
1545     guarantee(java_thread != rax, &quot;change this code&quot;);
1546     push(rax);
1547     { Label L;
1548       get_thread(rax);
1549       cmpptr(java_thread, rax);
1550       jcc(Assembler::equal, L);
1551       STOP(&quot;MacroAssembler::call_VM_base: rdi not callee saved?&quot;);
1552       bind(L);
1553     }
1554     pop(rax);
1555 #endif
1556   } else {
1557     get_thread(java_thread);
1558   }
1559   // reset last Java frame
1560   // Only interpreter should have to clear fp
1561   reset_last_Java_frame(java_thread, true);
1562 
1563    // C++ interp handles this in the interpreter
1564   check_and_handle_popframe(java_thread);
1565   check_and_handle_earlyret(java_thread);
1566 
1567   if (check_exceptions) {
1568     // check for pending exceptions (java_thread is set upon return)
1569     cmpptr(Address(java_thread, Thread::pending_exception_offset()), (int32_t) NULL_WORD);
1570 #ifndef _LP64
1571     jump_cc(Assembler::notEqual,
1572             RuntimeAddress(StubRoutines::forward_exception_entry()));
1573 #else
1574     // This used to conditionally jump to forward_exception however it is
1575     // possible if we relocate that the branch will not reach. So we must jump
1576     // around so we can always reach
1577 
1578     Label ok;
1579     jcc(Assembler::equal, ok);
1580     jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
1581     bind(ok);
1582 #endif // LP64
1583   }
1584 
1585   // get oop result if there is one and reset the value in the thread
1586   if (oop_result-&gt;is_valid()) {
1587     get_vm_result(oop_result, java_thread);
1588   }
1589 }
1590 
1591 void MacroAssembler::call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions) {
1592 
1593   // Calculate the value for last_Java_sp
1594   // somewhat subtle. call_VM does an intermediate call
1595   // which places a return address on the stack just under the
1596   // stack pointer as the user finsihed with it. This allows
1597   // use to retrieve last_Java_pc from last_Java_sp[-1].
1598   // On 32bit we then have to push additional args on the stack to accomplish
1599   // the actual requested call. On 64bit call_VM only can use register args
1600   // so the only extra space is the return address that call_VM created.
1601   // This hopefully explains the calculations here.
1602 
1603 #ifdef _LP64
1604   // We&#39;ve pushed one address, correct last_Java_sp
1605   lea(rax, Address(rsp, wordSize));
1606 #else
1607   lea(rax, Address(rsp, (1 + number_of_arguments) * wordSize));
1608 #endif // LP64
1609 
1610   call_VM_base(oop_result, noreg, rax, entry_point, number_of_arguments, check_exceptions);
1611 
1612 }
1613 
1614 // Use this method when MacroAssembler version of call_VM_leaf_base() should be called from Interpreter.
1615 void MacroAssembler::call_VM_leaf0(address entry_point) {
1616   MacroAssembler::call_VM_leaf_base(entry_point, 0);
1617 }
1618 
1619 void MacroAssembler::call_VM_leaf(address entry_point, int number_of_arguments) {
1620   call_VM_leaf_base(entry_point, number_of_arguments);
1621 }
1622 
1623 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0) {
1624   pass_arg0(this, arg_0);
1625   call_VM_leaf(entry_point, 1);
1626 }
1627 
1628 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1629 
1630   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1631   pass_arg1(this, arg_1);
1632   pass_arg0(this, arg_0);
1633   call_VM_leaf(entry_point, 2);
1634 }
1635 
1636 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1637   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1638   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1639   pass_arg2(this, arg_2);
1640   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1641   pass_arg1(this, arg_1);
1642   pass_arg0(this, arg_0);
1643   call_VM_leaf(entry_point, 3);
1644 }
1645 
1646 void MacroAssembler::super_call_VM_leaf(address entry_point) {
1647   MacroAssembler::call_VM_leaf_base(entry_point, 1);
1648 }
1649 
1650 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0) {
1651   pass_arg0(this, arg_0);
1652   MacroAssembler::call_VM_leaf_base(entry_point, 1);
1653 }
1654 
1655 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1656 
1657   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1658   pass_arg1(this, arg_1);
1659   pass_arg0(this, arg_0);
1660   MacroAssembler::call_VM_leaf_base(entry_point, 2);
1661 }
1662 
1663 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1664   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1665   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1666   pass_arg2(this, arg_2);
1667   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1668   pass_arg1(this, arg_1);
1669   pass_arg0(this, arg_0);
1670   MacroAssembler::call_VM_leaf_base(entry_point, 3);
1671 }
1672 
1673 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2, Register arg_3) {
1674   LP64_ONLY(assert(arg_0 != c_rarg3, &quot;smashed arg&quot;));
1675   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1676   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1677   pass_arg3(this, arg_3);
1678   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1679   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1680   pass_arg2(this, arg_2);
1681   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1682   pass_arg1(this, arg_1);
1683   pass_arg0(this, arg_0);
1684   MacroAssembler::call_VM_leaf_base(entry_point, 4);
1685 }
1686 
1687 void MacroAssembler::get_vm_result(Register oop_result, Register java_thread) {
1688   movptr(oop_result, Address(java_thread, JavaThread::vm_result_offset()));
1689   movptr(Address(java_thread, JavaThread::vm_result_offset()), NULL_WORD);
1690   verify_oop_msg(oop_result, &quot;broken oop in call_VM_base&quot;);
1691 }
1692 
1693 void MacroAssembler::get_vm_result_2(Register metadata_result, Register java_thread) {
1694   movptr(metadata_result, Address(java_thread, JavaThread::vm_result_2_offset()));
1695   movptr(Address(java_thread, JavaThread::vm_result_2_offset()), NULL_WORD);
1696 }
1697 
1698 void MacroAssembler::check_and_handle_earlyret(Register java_thread) {
1699 }
1700 
1701 void MacroAssembler::check_and_handle_popframe(Register java_thread) {
1702 }
1703 
1704 void MacroAssembler::cmp32(AddressLiteral src1, int32_t imm) {
1705   if (reachable(src1)) {
1706     cmpl(as_Address(src1), imm);
1707   } else {
1708     lea(rscratch1, src1);
1709     cmpl(Address(rscratch1, 0), imm);
1710   }
1711 }
1712 
1713 void MacroAssembler::cmp32(Register src1, AddressLiteral src2) {
1714   assert(!src2.is_lval(), &quot;use cmpptr&quot;);
1715   if (reachable(src2)) {
1716     cmpl(src1, as_Address(src2));
1717   } else {
1718     lea(rscratch1, src2);
1719     cmpl(src1, Address(rscratch1, 0));
1720   }
1721 }
1722 
1723 void MacroAssembler::cmp32(Register src1, int32_t imm) {
1724   Assembler::cmpl(src1, imm);
1725 }
1726 
1727 void MacroAssembler::cmp32(Register src1, Address src2) {
1728   Assembler::cmpl(src1, src2);
1729 }
1730 
1731 void MacroAssembler::cmpsd2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
1732   ucomisd(opr1, opr2);
1733 
1734   Label L;
1735   if (unordered_is_less) {
1736     movl(dst, -1);
1737     jcc(Assembler::parity, L);
1738     jcc(Assembler::below , L);
1739     movl(dst, 0);
1740     jcc(Assembler::equal , L);
1741     increment(dst);
1742   } else { // unordered is greater
1743     movl(dst, 1);
1744     jcc(Assembler::parity, L);
1745     jcc(Assembler::above , L);
1746     movl(dst, 0);
1747     jcc(Assembler::equal , L);
1748     decrementl(dst);
1749   }
1750   bind(L);
1751 }
1752 
1753 void MacroAssembler::cmpss2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
1754   ucomiss(opr1, opr2);
1755 
1756   Label L;
1757   if (unordered_is_less) {
1758     movl(dst, -1);
1759     jcc(Assembler::parity, L);
1760     jcc(Assembler::below , L);
1761     movl(dst, 0);
1762     jcc(Assembler::equal , L);
1763     increment(dst);
1764   } else { // unordered is greater
1765     movl(dst, 1);
1766     jcc(Assembler::parity, L);
1767     jcc(Assembler::above , L);
1768     movl(dst, 0);
1769     jcc(Assembler::equal , L);
1770     decrementl(dst);
1771   }
1772   bind(L);
1773 }
1774 
1775 
1776 void MacroAssembler::cmp8(AddressLiteral src1, int imm) {
1777   if (reachable(src1)) {
1778     cmpb(as_Address(src1), imm);
1779   } else {
1780     lea(rscratch1, src1);
1781     cmpb(Address(rscratch1, 0), imm);
1782   }
1783 }
1784 
1785 void MacroAssembler::cmpptr(Register src1, AddressLiteral src2) {
1786 #ifdef _LP64
1787   if (src2.is_lval()) {
1788     movptr(rscratch1, src2);
1789     Assembler::cmpq(src1, rscratch1);
1790   } else if (reachable(src2)) {
1791     cmpq(src1, as_Address(src2));
1792   } else {
1793     lea(rscratch1, src2);
1794     Assembler::cmpq(src1, Address(rscratch1, 0));
1795   }
1796 #else
1797   if (src2.is_lval()) {
1798     cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
1799   } else {
1800     cmpl(src1, as_Address(src2));
1801   }
1802 #endif // _LP64
1803 }
1804 
1805 void MacroAssembler::cmpptr(Address src1, AddressLiteral src2) {
1806   assert(src2.is_lval(), &quot;not a mem-mem compare&quot;);
1807 #ifdef _LP64
1808   // moves src2&#39;s literal address
1809   movptr(rscratch1, src2);
1810   Assembler::cmpq(src1, rscratch1);
1811 #else
1812   cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
1813 #endif // _LP64
1814 }
1815 
1816 void MacroAssembler::cmpoop(Register src1, Register src2) {
1817   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1818   bs-&gt;obj_equals(this, src1, src2);
1819 }
1820 
1821 void MacroAssembler::cmpoop(Register src1, Address src2) {
1822   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1823   bs-&gt;obj_equals(this, src1, src2);
1824 }
1825 
1826 #ifdef _LP64
1827 void MacroAssembler::cmpoop(Register src1, jobject src2) {
1828   movoop(rscratch1, src2);
1829   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1830   bs-&gt;obj_equals(this, src1, rscratch1);
1831 }
1832 #endif
1833 
1834 void MacroAssembler::locked_cmpxchgptr(Register reg, AddressLiteral adr) {
1835   if (reachable(adr)) {
1836     lock();
1837     cmpxchgptr(reg, as_Address(adr));
1838   } else {
1839     lea(rscratch1, adr);
1840     lock();
1841     cmpxchgptr(reg, Address(rscratch1, 0));
1842   }
1843 }
1844 
1845 void MacroAssembler::cmpxchgptr(Register reg, Address adr) {
1846   LP64_ONLY(cmpxchgq(reg, adr)) NOT_LP64(cmpxchgl(reg, adr));
1847 }
1848 
1849 void MacroAssembler::comisd(XMMRegister dst, AddressLiteral src) {
1850   if (reachable(src)) {
1851     Assembler::comisd(dst, as_Address(src));
1852   } else {
1853     lea(rscratch1, src);
1854     Assembler::comisd(dst, Address(rscratch1, 0));
1855   }
1856 }
1857 
1858 void MacroAssembler::comiss(XMMRegister dst, AddressLiteral src) {
1859   if (reachable(src)) {
1860     Assembler::comiss(dst, as_Address(src));
1861   } else {
1862     lea(rscratch1, src);
1863     Assembler::comiss(dst, Address(rscratch1, 0));
1864   }
1865 }
1866 
1867 
1868 void MacroAssembler::cond_inc32(Condition cond, AddressLiteral counter_addr) {
1869   Condition negated_cond = negate_condition(cond);
1870   Label L;
1871   jcc(negated_cond, L);
1872   pushf(); // Preserve flags
1873   atomic_incl(counter_addr);
1874   popf();
1875   bind(L);
1876 }
1877 
1878 int MacroAssembler::corrected_idivl(Register reg) {
1879   // Full implementation of Java idiv and irem; checks for
1880   // special case as described in JVM spec., p.243 &amp; p.271.
1881   // The function returns the (pc) offset of the idivl
1882   // instruction - may be needed for implicit exceptions.
1883   //
1884   //         normal case                           special case
1885   //
1886   // input : rax,: dividend                         min_int
1887   //         reg: divisor   (may not be rax,/rdx)   -1
1888   //
1889   // output: rax,: quotient  (= rax, idiv reg)       min_int
1890   //         rdx: remainder (= rax, irem reg)       0
1891   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax, or rdx register&quot;);
1892   const int min_int = 0x80000000;
1893   Label normal_case, special_case;
1894 
1895   // check for special case
1896   cmpl(rax, min_int);
1897   jcc(Assembler::notEqual, normal_case);
1898   xorl(rdx, rdx); // prepare rdx for possible special case (where remainder = 0)
1899   cmpl(reg, -1);
1900   jcc(Assembler::equal, special_case);
1901 
1902   // handle normal case
1903   bind(normal_case);
1904   cdql();
1905   int idivl_offset = offset();
1906   idivl(reg);
1907 
1908   // normal and special case exit
1909   bind(special_case);
1910 
1911   return idivl_offset;
1912 }
1913 
1914 
1915 
1916 void MacroAssembler::decrementl(Register reg, int value) {
1917   if (value == min_jint) {subl(reg, value) ; return; }
1918   if (value &lt;  0) { incrementl(reg, -value); return; }
1919   if (value == 0) {                        ; return; }
1920   if (value == 1 &amp;&amp; UseIncDec) { decl(reg) ; return; }
1921   /* else */      { subl(reg, value)       ; return; }
1922 }
1923 
1924 void MacroAssembler::decrementl(Address dst, int value) {
1925   if (value == min_jint) {subl(dst, value) ; return; }
1926   if (value &lt;  0) { incrementl(dst, -value); return; }
1927   if (value == 0) {                        ; return; }
1928   if (value == 1 &amp;&amp; UseIncDec) { decl(dst) ; return; }
1929   /* else */      { subl(dst, value)       ; return; }
1930 }
1931 
1932 void MacroAssembler::division_with_shift (Register reg, int shift_value) {
1933   assert (shift_value &gt; 0, &quot;illegal shift value&quot;);
1934   Label _is_positive;
1935   testl (reg, reg);
1936   jcc (Assembler::positive, _is_positive);
1937   int offset = (1 &lt;&lt; shift_value) - 1 ;
1938 
1939   if (offset == 1) {
1940     incrementl(reg);
1941   } else {
1942     addl(reg, offset);
1943   }
1944 
1945   bind (_is_positive);
1946   sarl(reg, shift_value);
1947 }
1948 
1949 void MacroAssembler::divsd(XMMRegister dst, AddressLiteral src) {
1950   if (reachable(src)) {
1951     Assembler::divsd(dst, as_Address(src));
1952   } else {
1953     lea(rscratch1, src);
1954     Assembler::divsd(dst, Address(rscratch1, 0));
1955   }
1956 }
1957 
1958 void MacroAssembler::divss(XMMRegister dst, AddressLiteral src) {
1959   if (reachable(src)) {
1960     Assembler::divss(dst, as_Address(src));
1961   } else {
1962     lea(rscratch1, src);
1963     Assembler::divss(dst, Address(rscratch1, 0));
1964   }
1965 }
1966 
1967 void MacroAssembler::enter() {
1968   push(rbp);
1969   mov(rbp, rsp);
1970 }
1971 
1972 // A 5 byte nop that is safe for patching (see patch_verified_entry)
1973 void MacroAssembler::fat_nop() {
1974   if (UseAddressNop) {
1975     addr_nop_5();
1976   } else {
1977     emit_int8(0x26); // es:
1978     emit_int8(0x2e); // cs:
1979     emit_int8(0x64); // fs:
1980     emit_int8(0x65); // gs:
1981     emit_int8((unsigned char)0x90);
1982   }
1983 }
1984 
1985 #ifndef _LP64
1986 void MacroAssembler::fcmp(Register tmp) {
1987   fcmp(tmp, 1, true, true);
1988 }
1989 
1990 void MacroAssembler::fcmp(Register tmp, int index, bool pop_left, bool pop_right) {
1991   assert(!pop_right || pop_left, &quot;usage error&quot;);
1992   if (VM_Version::supports_cmov()) {
1993     assert(tmp == noreg, &quot;unneeded temp&quot;);
1994     if (pop_left) {
1995       fucomip(index);
1996     } else {
1997       fucomi(index);
1998     }
1999     if (pop_right) {
2000       fpop();
2001     }
2002   } else {
2003     assert(tmp != noreg, &quot;need temp&quot;);
2004     if (pop_left) {
2005       if (pop_right) {
2006         fcompp();
2007       } else {
2008         fcomp(index);
2009       }
2010     } else {
2011       fcom(index);
2012     }
2013     // convert FPU condition into eflags condition via rax,
2014     save_rax(tmp);
2015     fwait(); fnstsw_ax();
2016     sahf();
2017     restore_rax(tmp);
2018   }
2019   // condition codes set as follows:
2020   //
2021   // CF (corresponds to C0) if x &lt; y
2022   // PF (corresponds to C2) if unordered
2023   // ZF (corresponds to C3) if x = y
2024 }
2025 
2026 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less) {
2027   fcmp2int(dst, unordered_is_less, 1, true, true);
2028 }
2029 
2030 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right) {
2031   fcmp(VM_Version::supports_cmov() ? noreg : dst, index, pop_left, pop_right);
2032   Label L;
2033   if (unordered_is_less) {
2034     movl(dst, -1);
2035     jcc(Assembler::parity, L);
2036     jcc(Assembler::below , L);
2037     movl(dst, 0);
2038     jcc(Assembler::equal , L);
2039     increment(dst);
2040   } else { // unordered is greater
2041     movl(dst, 1);
2042     jcc(Assembler::parity, L);
2043     jcc(Assembler::above , L);
2044     movl(dst, 0);
2045     jcc(Assembler::equal , L);
2046     decrementl(dst);
2047   }
2048   bind(L);
2049 }
2050 
2051 void MacroAssembler::fld_d(AddressLiteral src) {
2052   fld_d(as_Address(src));
2053 }
2054 
2055 void MacroAssembler::fld_s(AddressLiteral src) {
2056   fld_s(as_Address(src));
2057 }
2058 
2059 void MacroAssembler::fld_x(AddressLiteral src) {
2060   Assembler::fld_x(as_Address(src));
2061 }
2062 
2063 void MacroAssembler::fldcw(AddressLiteral src) {
2064   Assembler::fldcw(as_Address(src));
2065 }
2066 
2067 void MacroAssembler::fpop() {
2068   ffree();
2069   fincstp();
2070 }
2071 
2072 void MacroAssembler::fremr(Register tmp) {
2073   save_rax(tmp);
2074   { Label L;
2075     bind(L);
2076     fprem();
2077     fwait(); fnstsw_ax();
2078     sahf();
2079     jcc(Assembler::parity, L);
2080   }
2081   restore_rax(tmp);
2082   // Result is in ST0.
2083   // Note: fxch &amp; fpop to get rid of ST1
2084   // (otherwise FPU stack could overflow eventually)
2085   fxch(1);
2086   fpop();
2087 }
2088 
2089 void MacroAssembler::empty_FPU_stack() {
2090   if (VM_Version::supports_mmx()) {
2091     emms();
2092   } else {
2093     for (int i = 8; i-- &gt; 0; ) ffree(i);
2094   }
2095 }
2096 #endif // !LP64
2097 
2098 void MacroAssembler::mulpd(XMMRegister dst, AddressLiteral src) {
2099   if (reachable(src)) {
2100     Assembler::mulpd(dst, as_Address(src));
2101   } else {
2102     lea(rscratch1, src);
2103     Assembler::mulpd(dst, Address(rscratch1, 0));
2104   }
2105 }
2106 
2107 void MacroAssembler::load_float(Address src) {
2108 #ifdef _LP64
2109   movflt(xmm0, src);
2110 #else
2111   if (UseSSE &gt;= 1) {
2112     movflt(xmm0, src);
2113   } else {
2114     fld_s(src);
2115   }
2116 #endif // LP64
2117 }
2118 
2119 void MacroAssembler::store_float(Address dst) {
2120 #ifdef _LP64
2121   movflt(dst, xmm0);
2122 #else
2123   if (UseSSE &gt;= 1) {
2124     movflt(dst, xmm0);
2125   } else {
2126     fstp_s(dst);
2127   }
2128 #endif // LP64
2129 }
2130 
2131 void MacroAssembler::load_double(Address src) {
2132 #ifdef _LP64
2133   movdbl(xmm0, src);
2134 #else
2135   if (UseSSE &gt;= 2) {
2136     movdbl(xmm0, src);
2137   } else {
2138     fld_d(src);
2139   }
2140 #endif // LP64
2141 }
2142 
2143 void MacroAssembler::store_double(Address dst) {
2144 #ifdef _LP64
2145   movdbl(dst, xmm0);
2146 #else
2147   if (UseSSE &gt;= 2) {
2148     movdbl(dst, xmm0);
2149   } else {
2150     fstp_d(dst);
2151   }
2152 #endif // LP64
2153 }
2154 
2155 // dst = c = a * b + c
2156 void MacroAssembler::fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
2157   Assembler::vfmadd231sd(c, a, b);
2158   if (dst != c) {
2159     movdbl(dst, c);
2160   }
2161 }
2162 
2163 // dst = c = a * b + c
2164 void MacroAssembler::fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
2165   Assembler::vfmadd231ss(c, a, b);
2166   if (dst != c) {
2167     movflt(dst, c);
2168   }
2169 }
2170 
2171 // dst = c = a * b + c
2172 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
2173   Assembler::vfmadd231pd(c, a, b, vector_len);
2174   if (dst != c) {
2175     vmovdqu(dst, c);
2176   }
2177 }
2178 
2179 // dst = c = a * b + c
2180 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
2181   Assembler::vfmadd231ps(c, a, b, vector_len);
2182   if (dst != c) {
2183     vmovdqu(dst, c);
2184   }
2185 }
2186 
2187 // dst = c = a * b + c
2188 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
2189   Assembler::vfmadd231pd(c, a, b, vector_len);
2190   if (dst != c) {
2191     vmovdqu(dst, c);
2192   }
2193 }
2194 
2195 // dst = c = a * b + c
2196 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
2197   Assembler::vfmadd231ps(c, a, b, vector_len);
2198   if (dst != c) {
2199     vmovdqu(dst, c);
2200   }
2201 }
2202 
2203 void MacroAssembler::incrementl(AddressLiteral dst) {
2204   if (reachable(dst)) {
2205     incrementl(as_Address(dst));
2206   } else {
2207     lea(rscratch1, dst);
2208     incrementl(Address(rscratch1, 0));
2209   }
2210 }
2211 
2212 void MacroAssembler::incrementl(ArrayAddress dst) {
2213   incrementl(as_Address(dst));
2214 }
2215 
2216 void MacroAssembler::incrementl(Register reg, int value) {
2217   if (value == min_jint) {addl(reg, value) ; return; }
2218   if (value &lt;  0) { decrementl(reg, -value); return; }
2219   if (value == 0) {                        ; return; }
2220   if (value == 1 &amp;&amp; UseIncDec) { incl(reg) ; return; }
2221   /* else */      { addl(reg, value)       ; return; }
2222 }
2223 
2224 void MacroAssembler::incrementl(Address dst, int value) {
2225   if (value == min_jint) {addl(dst, value) ; return; }
2226   if (value &lt;  0) { decrementl(dst, -value); return; }
2227   if (value == 0) {                        ; return; }
2228   if (value == 1 &amp;&amp; UseIncDec) { incl(dst) ; return; }
2229   /* else */      { addl(dst, value)       ; return; }
2230 }
2231 
2232 void MacroAssembler::jump(AddressLiteral dst) {
2233   if (reachable(dst)) {
2234     jmp_literal(dst.target(), dst.rspec());
2235   } else {
2236     lea(rscratch1, dst);
2237     jmp(rscratch1);
2238   }
2239 }
2240 
2241 void MacroAssembler::jump_cc(Condition cc, AddressLiteral dst) {
2242   if (reachable(dst)) {
2243     InstructionMark im(this);
2244     relocate(dst.reloc());
2245     const int short_size = 2;
2246     const int long_size = 6;
2247     int offs = (intptr_t)dst.target() - ((intptr_t)pc());
2248     if (dst.reloc() == relocInfo::none &amp;&amp; is8bit(offs - short_size)) {
2249       // 0111 tttn #8-bit disp
2250       emit_int8(0x70 | cc);
2251       emit_int8((offs - short_size) &amp; 0xFF);
2252     } else {
2253       // 0000 1111 1000 tttn #32-bit disp
2254       emit_int8(0x0F);
2255       emit_int8((unsigned char)(0x80 | cc));
2256       emit_int32(offs - long_size);
2257     }
2258   } else {
2259 #ifdef ASSERT
2260     warning(&quot;reversing conditional branch&quot;);
2261 #endif /* ASSERT */
2262     Label skip;
2263     jccb(reverse[cc], skip);
2264     lea(rscratch1, dst);
2265     Assembler::jmp(rscratch1);
2266     bind(skip);
2267   }
2268 }
2269 
2270 void MacroAssembler::ldmxcsr(AddressLiteral src) {
2271   if (reachable(src)) {
2272     Assembler::ldmxcsr(as_Address(src));
2273   } else {
2274     lea(rscratch1, src);
2275     Assembler::ldmxcsr(Address(rscratch1, 0));
2276   }
2277 }
2278 
2279 int MacroAssembler::load_signed_byte(Register dst, Address src) {
2280   int off;
2281   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2282     off = offset();
2283     movsbl(dst, src); // movsxb
2284   } else {
2285     off = load_unsigned_byte(dst, src);
2286     shll(dst, 24);
2287     sarl(dst, 24);
2288   }
2289   return off;
2290 }
2291 
2292 // Note: load_signed_short used to be called load_signed_word.
2293 // Although the &#39;w&#39; in x86 opcodes refers to the term &quot;word&quot; in the assembler
2294 // manual, which means 16 bits, that usage is found nowhere in HotSpot code.
2295 // The term &quot;word&quot; in HotSpot means a 32- or 64-bit machine word.
2296 int MacroAssembler::load_signed_short(Register dst, Address src) {
2297   int off;
2298   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2299     // This is dubious to me since it seems safe to do a signed 16 =&gt; 64 bit
2300     // version but this is what 64bit has always done. This seems to imply
2301     // that users are only using 32bits worth.
2302     off = offset();
2303     movswl(dst, src); // movsxw
2304   } else {
2305     off = load_unsigned_short(dst, src);
2306     shll(dst, 16);
2307     sarl(dst, 16);
2308   }
2309   return off;
2310 }
2311 
2312 int MacroAssembler::load_unsigned_byte(Register dst, Address src) {
2313   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
2314   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
2315   int off;
2316   if (LP64_ONLY(true || ) VM_Version::is_P6() || src.uses(dst)) {
2317     off = offset();
2318     movzbl(dst, src); // movzxb
2319   } else {
2320     xorl(dst, dst);
2321     off = offset();
2322     movb(dst, src);
2323   }
2324   return off;
2325 }
2326 
2327 // Note: load_unsigned_short used to be called load_unsigned_word.
2328 int MacroAssembler::load_unsigned_short(Register dst, Address src) {
2329   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
2330   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
2331   int off;
2332   if (LP64_ONLY(true ||) VM_Version::is_P6() || src.uses(dst)) {
2333     off = offset();
2334     movzwl(dst, src); // movzxw
2335   } else {
2336     xorl(dst, dst);
2337     off = offset();
2338     movw(dst, src);
2339   }
2340   return off;
2341 }
2342 
2343 void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2) {
2344   switch (size_in_bytes) {
2345 #ifndef _LP64
2346   case  8:
2347     assert(dst2 != noreg, &quot;second dest register required&quot;);
2348     movl(dst,  src);
2349     movl(dst2, src.plus_disp(BytesPerInt));
2350     break;
2351 #else
2352   case  8:  movq(dst, src); break;
2353 #endif
2354   case  4:  movl(dst, src); break;
2355   case  2:  is_signed ? load_signed_short(dst, src) : load_unsigned_short(dst, src); break;
2356   case  1:  is_signed ? load_signed_byte( dst, src) : load_unsigned_byte( dst, src); break;
2357   default:  ShouldNotReachHere();
2358   }
2359 }
2360 
2361 void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2) {
2362   switch (size_in_bytes) {
2363 #ifndef _LP64
2364   case  8:
2365     assert(src2 != noreg, &quot;second source register required&quot;);
2366     movl(dst,                        src);
2367     movl(dst.plus_disp(BytesPerInt), src2);
2368     break;
2369 #else
2370   case  8:  movq(dst, src); break;
2371 #endif
2372   case  4:  movl(dst, src); break;
2373   case  2:  movw(dst, src); break;
2374   case  1:  movb(dst, src); break;
2375   default:  ShouldNotReachHere();
2376   }
2377 }
2378 
2379 void MacroAssembler::mov32(AddressLiteral dst, Register src) {
2380   if (reachable(dst)) {
2381     movl(as_Address(dst), src);
2382   } else {
2383     lea(rscratch1, dst);
2384     movl(Address(rscratch1, 0), src);
2385   }
2386 }
2387 
2388 void MacroAssembler::mov32(Register dst, AddressLiteral src) {
2389   if (reachable(src)) {
2390     movl(dst, as_Address(src));
2391   } else {
2392     lea(rscratch1, src);
2393     movl(dst, Address(rscratch1, 0));
2394   }
2395 }
2396 
2397 // C++ bool manipulation
2398 
2399 void MacroAssembler::movbool(Register dst, Address src) {
2400   if(sizeof(bool) == 1)
2401     movb(dst, src);
2402   else if(sizeof(bool) == 2)
2403     movw(dst, src);
2404   else if(sizeof(bool) == 4)
2405     movl(dst, src);
2406   else
2407     // unsupported
2408     ShouldNotReachHere();
2409 }
2410 
2411 void MacroAssembler::movbool(Address dst, bool boolconst) {
2412   if(sizeof(bool) == 1)
2413     movb(dst, (int) boolconst);
2414   else if(sizeof(bool) == 2)
2415     movw(dst, (int) boolconst);
2416   else if(sizeof(bool) == 4)
2417     movl(dst, (int) boolconst);
2418   else
2419     // unsupported
2420     ShouldNotReachHere();
2421 }
2422 
2423 void MacroAssembler::movbool(Address dst, Register src) {
2424   if(sizeof(bool) == 1)
2425     movb(dst, src);
2426   else if(sizeof(bool) == 2)
2427     movw(dst, src);
2428   else if(sizeof(bool) == 4)
2429     movl(dst, src);
2430   else
2431     // unsupported
2432     ShouldNotReachHere();
2433 }
2434 
2435 void MacroAssembler::movbyte(ArrayAddress dst, int src) {
2436   movb(as_Address(dst), src);
2437 }
2438 
2439 void MacroAssembler::movdl(XMMRegister dst, AddressLiteral src) {
2440   if (reachable(src)) {
2441     movdl(dst, as_Address(src));
2442   } else {
2443     lea(rscratch1, src);
2444     movdl(dst, Address(rscratch1, 0));
2445   }
2446 }
2447 
2448 void MacroAssembler::movq(XMMRegister dst, AddressLiteral src) {
2449   if (reachable(src)) {
2450     movq(dst, as_Address(src));
2451   } else {
2452     lea(rscratch1, src);
2453     movq(dst, Address(rscratch1, 0));
2454   }
2455 }
2456 
2457 void MacroAssembler::movdbl(XMMRegister dst, AddressLiteral src) {
2458   if (reachable(src)) {
2459     if (UseXmmLoadAndClearUpper) {
2460       movsd (dst, as_Address(src));
2461     } else {
2462       movlpd(dst, as_Address(src));
2463     }
2464   } else {
2465     lea(rscratch1, src);
2466     if (UseXmmLoadAndClearUpper) {
2467       movsd (dst, Address(rscratch1, 0));
2468     } else {
2469       movlpd(dst, Address(rscratch1, 0));
2470     }
2471   }
2472 }
2473 
2474 void MacroAssembler::movflt(XMMRegister dst, AddressLiteral src) {
2475   if (reachable(src)) {
2476     movss(dst, as_Address(src));
2477   } else {
2478     lea(rscratch1, src);
2479     movss(dst, Address(rscratch1, 0));
2480   }
2481 }
2482 
2483 void MacroAssembler::movptr(Register dst, Register src) {
2484   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2485 }
2486 
2487 void MacroAssembler::movptr(Register dst, Address src) {
2488   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2489 }
2490 
2491 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
2492 void MacroAssembler::movptr(Register dst, intptr_t src) {
2493   LP64_ONLY(mov64(dst, src)) NOT_LP64(movl(dst, src));
2494 }
2495 
2496 void MacroAssembler::movptr(Address dst, Register src) {
2497   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2498 }
2499 
2500 void MacroAssembler::movdqu(Address dst, XMMRegister src) {
2501     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2502     Assembler::movdqu(dst, src);
2503 }
2504 
2505 void MacroAssembler::movdqu(XMMRegister dst, Address src) {
2506     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2507     Assembler::movdqu(dst, src);
2508 }
2509 
2510 void MacroAssembler::movdqu(XMMRegister dst, XMMRegister src) {
2511     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2512     Assembler::movdqu(dst, src);
2513 }
2514 
2515 void MacroAssembler::movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg) {
2516   if (reachable(src)) {
2517     movdqu(dst, as_Address(src));
2518   } else {
2519     lea(scratchReg, src);
2520     movdqu(dst, Address(scratchReg, 0));
2521   }
2522 }
2523 
2524 void MacroAssembler::vmovdqu(Address dst, XMMRegister src) {
2525     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2526     Assembler::vmovdqu(dst, src);
2527 }
2528 
2529 void MacroAssembler::vmovdqu(XMMRegister dst, Address src) {
2530     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2531     Assembler::vmovdqu(dst, src);
2532 }
2533 
2534 void MacroAssembler::vmovdqu(XMMRegister dst, XMMRegister src) {
2535     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2536     Assembler::vmovdqu(dst, src);
2537 }
2538 
2539 void MacroAssembler::vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2540   if (reachable(src)) {
2541     vmovdqu(dst, as_Address(src));
2542   }
2543   else {
2544     lea(scratch_reg, src);
2545     vmovdqu(dst, Address(scratch_reg, 0));
2546   }
2547 }
2548 
2549 void MacroAssembler::evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {
2550   if (reachable(src)) {
2551     Assembler::evmovdquq(dst, as_Address(src), vector_len);
2552   } else {
2553     lea(rscratch, src);
2554     Assembler::evmovdquq(dst, Address(rscratch, 0), vector_len);
2555   }
2556 }
2557 
2558 void MacroAssembler::movdqa(XMMRegister dst, AddressLiteral src) {
2559   if (reachable(src)) {
2560     Assembler::movdqa(dst, as_Address(src));
2561   } else {
2562     lea(rscratch1, src);
2563     Assembler::movdqa(dst, Address(rscratch1, 0));
2564   }
2565 }
2566 
2567 void MacroAssembler::movsd(XMMRegister dst, AddressLiteral src) {
2568   if (reachable(src)) {
2569     Assembler::movsd(dst, as_Address(src));
2570   } else {
2571     lea(rscratch1, src);
2572     Assembler::movsd(dst, Address(rscratch1, 0));
2573   }
2574 }
2575 
2576 void MacroAssembler::movss(XMMRegister dst, AddressLiteral src) {
2577   if (reachable(src)) {
2578     Assembler::movss(dst, as_Address(src));
2579   } else {
2580     lea(rscratch1, src);
2581     Assembler::movss(dst, Address(rscratch1, 0));
2582   }
2583 }
2584 
2585 void MacroAssembler::mulsd(XMMRegister dst, AddressLiteral src) {
2586   if (reachable(src)) {
2587     Assembler::mulsd(dst, as_Address(src));
2588   } else {
2589     lea(rscratch1, src);
2590     Assembler::mulsd(dst, Address(rscratch1, 0));
2591   }
2592 }
2593 
2594 void MacroAssembler::mulss(XMMRegister dst, AddressLiteral src) {
2595   if (reachable(src)) {
2596     Assembler::mulss(dst, as_Address(src));
2597   } else {
2598     lea(rscratch1, src);
2599     Assembler::mulss(dst, Address(rscratch1, 0));
2600   }
2601 }
2602 
2603 void MacroAssembler::null_check(Register reg, int offset) {
2604   if (needs_explicit_null_check(offset)) {
2605     // provoke OS NULL exception if reg = NULL by
2606     // accessing M[reg] w/o changing any (non-CC) registers
2607     // NOTE: cmpl is plenty here to provoke a segv
2608     cmpptr(rax, Address(reg, 0));
2609     // Note: should probably use testl(rax, Address(reg, 0));
2610     //       may be shorter code (however, this version of
2611     //       testl needs to be implemented first)
2612   } else {
2613     // nothing to do, (later) access of M[reg + offset]
2614     // will provoke OS NULL exception if reg = NULL
2615   }
2616 }
2617 
2618 void MacroAssembler::test_klass_is_value(Register klass, Register temp_reg, Label&amp; is_value) {
2619   movl(temp_reg, Address(klass, Klass::access_flags_offset()));
2620   testl(temp_reg, JVM_ACC_VALUE);
2621   jcc(Assembler::notZero, is_value);
2622 }
2623 
2624 void MacroAssembler::test_klass_is_empty_value(Register klass, Register temp_reg, Label&amp; is_empty_value) {
2625 #ifdef ASSERT
2626   {
2627     Label done_check;
2628     test_klass_is_value(klass, temp_reg, done_check);
<a name="1" id="anc1"></a><span class="line-modified">2629     stop(&quot;test_klass_is_empty_value with non value klass&quot;);</span>
2630     bind(done_check);
2631   }
2632 #endif
2633   movl(temp_reg, Address(klass, InstanceKlass::misc_flags_offset()));
2634   testl(temp_reg, InstanceKlass::misc_flags_is_empty_value());
2635   jcc(Assembler::notZero, is_empty_value);
2636 }
2637 
2638 void MacroAssembler::test_field_is_flattenable(Register flags, Register temp_reg, Label&amp; is_flattenable) {
2639   movl(temp_reg, flags);
2640   shrl(temp_reg, ConstantPoolCacheEntry::is_flattenable_field_shift);
2641   andl(temp_reg, 0x1);
2642   testl(temp_reg, temp_reg);
2643   jcc(Assembler::notZero, is_flattenable);
2644 }
2645 
2646 void MacroAssembler::test_field_is_not_flattenable(Register flags, Register temp_reg, Label&amp; notFlattenable) {
2647   movl(temp_reg, flags);
2648   shrl(temp_reg, ConstantPoolCacheEntry::is_flattenable_field_shift);
2649   andl(temp_reg, 0x1);
2650   testl(temp_reg, temp_reg);
2651   jcc(Assembler::zero, notFlattenable);
2652 }
2653 
2654 void MacroAssembler::test_field_is_flattened(Register flags, Register temp_reg, Label&amp; is_flattened) {
2655   movl(temp_reg, flags);
2656   shrl(temp_reg, ConstantPoolCacheEntry::is_flattened_field_shift);
2657   andl(temp_reg, 0x1);
2658   testl(temp_reg, temp_reg);
2659   jcc(Assembler::notZero, is_flattened);
2660 }
2661 
2662 void MacroAssembler::test_flattened_array_oop(Register oop, Register temp_reg,
2663                                               Label&amp;is_flattened_array) {
<a name="2" id="anc2"></a><span class="line-modified">2664   load_klass(temp_reg, oop);</span>
<span class="line-modified">2665   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));</span>
<span class="line-modified">2666   test_flattened_array_layout(temp_reg, is_flattened_array);</span>
2667 }
2668 
2669 void MacroAssembler::test_non_flattened_array_oop(Register oop, Register temp_reg,
2670                                                   Label&amp;is_non_flattened_array) {
<a name="3" id="anc3"></a><span class="line-modified">2671   load_klass(temp_reg, oop);</span>
<span class="line-modified">2672   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));</span>
<span class="line-modified">2673   test_non_flattened_array_layout(temp_reg, is_non_flattened_array);</span>
2674 }
2675 
2676 void MacroAssembler::test_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_null_free_array) {
<a name="4" id="anc4"></a><span class="line-modified">2677   load_klass(temp_reg, oop);</span>
<span class="line-modified">2678   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));</span>
<span class="line-modified">2679   test_null_free_array_layout(temp_reg, is_null_free_array);</span>
2680 }
2681 
2682 void MacroAssembler::test_non_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_non_null_free_array) {
<a name="5" id="anc5"></a><span class="line-modified">2683   load_klass(temp_reg, oop);</span>
<span class="line-modified">2684   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));</span>
<span class="line-added">2685   test_non_null_free_array_layout(temp_reg, is_non_null_free_array);</span>
<span class="line-added">2686 }</span>
<span class="line-added">2687 </span>
<span class="line-added">2688 void MacroAssembler::test_flattened_array_layout(Register lh, Label&amp; is_flattened_array) {</span>
<span class="line-added">2689   testl(lh, Klass::_lh_array_tag_vt_value_bit_inplace);</span>
<span class="line-added">2690   jcc(Assembler::notZero, is_flattened_array);</span>
<span class="line-added">2691 }</span>
<span class="line-added">2692 void MacroAssembler::test_non_flattened_array_layout(Register lh, Label&amp; is_non_flattened_array) {</span>
<span class="line-added">2693   testl(lh, Klass::_lh_array_tag_vt_value_bit_inplace);</span>
<span class="line-added">2694   jcc(Assembler::zero, is_non_flattened_array);</span>
<span class="line-added">2695 }</span>
<span class="line-added">2696 </span>
<span class="line-added">2697 void MacroAssembler::test_null_free_array_layout(Register lh, Label&amp; is_null_free_array) {</span>
<span class="line-added">2698   testl(lh, Klass::_lh_null_free_bit_inplace);</span>
<span class="line-added">2699   jcc(Assembler::notZero, is_null_free_array);</span>
<span class="line-added">2700 }</span>
<span class="line-added">2701 </span>
<span class="line-added">2702 void MacroAssembler::test_non_null_free_array_layout(Register lh, Label&amp; is_non_null_free_array) {</span>
<span class="line-added">2703   testl(lh, Klass::_lh_null_free_bit_inplace);</span>
2704   jcc(Assembler::zero, is_non_null_free_array);
2705 }
2706 
<a name="6" id="anc6"></a><span class="line-added">2707 </span>
2708 void MacroAssembler::os_breakpoint() {
2709   // instead of directly emitting a breakpoint, call os:breakpoint for better debugability
2710   // (e.g., MSVC can&#39;t call ps() otherwise)
2711   call(RuntimeAddress(CAST_FROM_FN_PTR(address, os::breakpoint)));
2712 }
2713 
2714 void MacroAssembler::unimplemented(const char* what) {
2715   const char* buf = NULL;
2716   {
2717     ResourceMark rm;
2718     stringStream ss;
2719     ss.print(&quot;unimplemented: %s&quot;, what);
2720     buf = code_string(ss.as_string());
2721   }
2722   stop(buf);
2723 }
2724 
2725 #ifdef _LP64
2726 #define XSTATE_BV 0x200
2727 #endif
2728 
2729 void MacroAssembler::pop_CPU_state() {
2730   pop_FPU_state();
2731   pop_IU_state();
2732 }
2733 
2734 void MacroAssembler::pop_FPU_state() {
2735 #ifndef _LP64
2736   frstor(Address(rsp, 0));
2737 #else
2738   fxrstor(Address(rsp, 0));
2739 #endif
2740   addptr(rsp, FPUStateSizeInWords * wordSize);
2741 }
2742 
2743 void MacroAssembler::pop_IU_state() {
2744   popa();
2745   LP64_ONLY(addq(rsp, 8));
2746   popf();
2747 }
2748 
2749 // Save Integer and Float state
2750 // Warning: Stack must be 16 byte aligned (64bit)
2751 void MacroAssembler::push_CPU_state() {
2752   push_IU_state();
2753   push_FPU_state();
2754 }
2755 
2756 void MacroAssembler::push_FPU_state() {
2757   subptr(rsp, FPUStateSizeInWords * wordSize);
2758 #ifndef _LP64
2759   fnsave(Address(rsp, 0));
2760   fwait();
2761 #else
2762   fxsave(Address(rsp, 0));
2763 #endif // LP64
2764 }
2765 
2766 void MacroAssembler::push_IU_state() {
2767   // Push flags first because pusha kills them
2768   pushf();
2769   // Make sure rsp stays 16-byte aligned
2770   LP64_ONLY(subq(rsp, 8));
2771   pusha();
2772 }
2773 
2774 void MacroAssembler::reset_last_Java_frame(Register java_thread, bool clear_fp) { // determine java_thread register
2775   if (!java_thread-&gt;is_valid()) {
2776     java_thread = rdi;
2777     get_thread(java_thread);
2778   }
2779   // we must set sp to zero to clear frame
2780   movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
2781   if (clear_fp) {
2782     movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
2783   }
2784 
2785   // Always clear the pc because it could have been set by make_walkable()
2786   movptr(Address(java_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
2787 
2788   vzeroupper();
2789 }
2790 
2791 void MacroAssembler::restore_rax(Register tmp) {
2792   if (tmp == noreg) pop(rax);
2793   else if (tmp != rax) mov(rax, tmp);
2794 }
2795 
2796 void MacroAssembler::round_to(Register reg, int modulus) {
2797   addptr(reg, modulus - 1);
2798   andptr(reg, -modulus);
2799 }
2800 
2801 void MacroAssembler::save_rax(Register tmp) {
2802   if (tmp == noreg) push(rax);
2803   else if (tmp != rax) mov(tmp, rax);
2804 }
2805 
2806 void MacroAssembler::safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg) {
2807 #ifdef _LP64
2808   assert(thread_reg == r15_thread, &quot;should be&quot;);
2809 #else
2810   if (thread_reg == noreg) {
2811     thread_reg = temp_reg;
2812     get_thread(thread_reg);
2813   }
2814 #endif
2815   testb(Address(thread_reg, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2816   jcc(Assembler::notZero, slow_path); // handshake bit set implies poll
2817 }
2818 
2819 // Calls to C land
2820 //
2821 // When entering C land, the rbp, &amp; rsp of the last Java frame have to be recorded
2822 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
2823 // has to be reset to 0. This is required to allow proper stack traversal.
2824 void MacroAssembler::set_last_Java_frame(Register java_thread,
2825                                          Register last_java_sp,
2826                                          Register last_java_fp,
2827                                          address  last_java_pc) {
2828   vzeroupper();
2829   // determine java_thread register
2830   if (!java_thread-&gt;is_valid()) {
2831     java_thread = rdi;
2832     get_thread(java_thread);
2833   }
2834   // determine last_java_sp register
2835   if (!last_java_sp-&gt;is_valid()) {
2836     last_java_sp = rsp;
2837   }
2838 
2839   // last_java_fp is optional
2840 
2841   if (last_java_fp-&gt;is_valid()) {
2842     movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), last_java_fp);
2843   }
2844 
2845   // last_java_pc is optional
2846 
2847   if (last_java_pc != NULL) {
2848     lea(Address(java_thread,
2849                  JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset()),
2850         InternalAddress(last_java_pc));
2851 
2852   }
2853   movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
2854 }
2855 
2856 void MacroAssembler::shlptr(Register dst, int imm8) {
2857   LP64_ONLY(shlq(dst, imm8)) NOT_LP64(shll(dst, imm8));
2858 }
2859 
2860 void MacroAssembler::shrptr(Register dst, int imm8) {
2861   LP64_ONLY(shrq(dst, imm8)) NOT_LP64(shrl(dst, imm8));
2862 }
2863 
2864 void MacroAssembler::sign_extend_byte(Register reg) {
2865   if (LP64_ONLY(true ||) (VM_Version::is_P6() &amp;&amp; reg-&gt;has_byte_register())) {
2866     movsbl(reg, reg); // movsxb
2867   } else {
2868     shll(reg, 24);
2869     sarl(reg, 24);
2870   }
2871 }
2872 
2873 void MacroAssembler::sign_extend_short(Register reg) {
2874   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2875     movswl(reg, reg); // movsxw
2876   } else {
2877     shll(reg, 16);
2878     sarl(reg, 16);
2879   }
2880 }
2881 
2882 void MacroAssembler::testl(Register dst, AddressLiteral src) {
2883   assert(reachable(src), &quot;Address should be reachable&quot;);
2884   testl(dst, as_Address(src));
2885 }
2886 
2887 void MacroAssembler::pcmpeqb(XMMRegister dst, XMMRegister src) {
2888   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2889   Assembler::pcmpeqb(dst, src);
2890 }
2891 
2892 void MacroAssembler::pcmpeqw(XMMRegister dst, XMMRegister src) {
2893   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2894   Assembler::pcmpeqw(dst, src);
2895 }
2896 
2897 void MacroAssembler::pcmpestri(XMMRegister dst, Address src, int imm8) {
2898   assert((dst-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2899   Assembler::pcmpestri(dst, src, imm8);
2900 }
2901 
2902 void MacroAssembler::pcmpestri(XMMRegister dst, XMMRegister src, int imm8) {
2903   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2904   Assembler::pcmpestri(dst, src, imm8);
2905 }
2906 
2907 void MacroAssembler::pmovzxbw(XMMRegister dst, XMMRegister src) {
2908   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2909   Assembler::pmovzxbw(dst, src);
2910 }
2911 
2912 void MacroAssembler::pmovzxbw(XMMRegister dst, Address src) {
2913   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2914   Assembler::pmovzxbw(dst, src);
2915 }
2916 
2917 void MacroAssembler::pmovmskb(Register dst, XMMRegister src) {
2918   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2919   Assembler::pmovmskb(dst, src);
2920 }
2921 
2922 void MacroAssembler::ptest(XMMRegister dst, XMMRegister src) {
2923   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2924   Assembler::ptest(dst, src);
2925 }
2926 
2927 void MacroAssembler::sqrtsd(XMMRegister dst, AddressLiteral src) {
2928   if (reachable(src)) {
2929     Assembler::sqrtsd(dst, as_Address(src));
2930   } else {
2931     lea(rscratch1, src);
2932     Assembler::sqrtsd(dst, Address(rscratch1, 0));
2933   }
2934 }
2935 
2936 void MacroAssembler::sqrtss(XMMRegister dst, AddressLiteral src) {
2937   if (reachable(src)) {
2938     Assembler::sqrtss(dst, as_Address(src));
2939   } else {
2940     lea(rscratch1, src);
2941     Assembler::sqrtss(dst, Address(rscratch1, 0));
2942   }
2943 }
2944 
2945 void MacroAssembler::subsd(XMMRegister dst, AddressLiteral src) {
2946   if (reachable(src)) {
2947     Assembler::subsd(dst, as_Address(src));
2948   } else {
2949     lea(rscratch1, src);
2950     Assembler::subsd(dst, Address(rscratch1, 0));
2951   }
2952 }
2953 
2954 void MacroAssembler::roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register scratch_reg) {
2955   if (reachable(src)) {
2956     Assembler::roundsd(dst, as_Address(src), rmode);
2957   } else {
2958     lea(scratch_reg, src);
2959     Assembler::roundsd(dst, Address(scratch_reg, 0), rmode);
2960   }
2961 }
2962 
2963 void MacroAssembler::subss(XMMRegister dst, AddressLiteral src) {
2964   if (reachable(src)) {
2965     Assembler::subss(dst, as_Address(src));
2966   } else {
2967     lea(rscratch1, src);
2968     Assembler::subss(dst, Address(rscratch1, 0));
2969   }
2970 }
2971 
2972 void MacroAssembler::ucomisd(XMMRegister dst, AddressLiteral src) {
2973   if (reachable(src)) {
2974     Assembler::ucomisd(dst, as_Address(src));
2975   } else {
2976     lea(rscratch1, src);
2977     Assembler::ucomisd(dst, Address(rscratch1, 0));
2978   }
2979 }
2980 
2981 void MacroAssembler::ucomiss(XMMRegister dst, AddressLiteral src) {
2982   if (reachable(src)) {
2983     Assembler::ucomiss(dst, as_Address(src));
2984   } else {
2985     lea(rscratch1, src);
2986     Assembler::ucomiss(dst, Address(rscratch1, 0));
2987   }
2988 }
2989 
2990 void MacroAssembler::xorpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2991   // Used in sign-bit flipping with aligned address.
2992   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
2993   if (reachable(src)) {
2994     Assembler::xorpd(dst, as_Address(src));
2995   } else {
2996     lea(scratch_reg, src);
2997     Assembler::xorpd(dst, Address(scratch_reg, 0));
2998   }
2999 }
3000 
3001 void MacroAssembler::xorpd(XMMRegister dst, XMMRegister src) {
3002   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
3003     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
3004   }
3005   else {
3006     Assembler::xorpd(dst, src);
3007   }
3008 }
3009 
3010 void MacroAssembler::xorps(XMMRegister dst, XMMRegister src) {
3011   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
3012     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
3013   } else {
3014     Assembler::xorps(dst, src);
3015   }
3016 }
3017 
3018 void MacroAssembler::xorps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
3019   // Used in sign-bit flipping with aligned address.
3020   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
3021   if (reachable(src)) {
3022     Assembler::xorps(dst, as_Address(src));
3023   } else {
3024     lea(scratch_reg, src);
3025     Assembler::xorps(dst, Address(scratch_reg, 0));
3026   }
3027 }
3028 
3029 void MacroAssembler::pshufb(XMMRegister dst, AddressLiteral src) {
3030   // Used in sign-bit flipping with aligned address.
3031   bool aligned_adr = (((intptr_t)src.target() &amp; 15) == 0);
3032   assert((UseAVX &gt; 0) || aligned_adr, &quot;SSE mode requires address alignment 16 bytes&quot;);
3033   if (reachable(src)) {
3034     Assembler::pshufb(dst, as_Address(src));
3035   } else {
3036     lea(rscratch1, src);
3037     Assembler::pshufb(dst, Address(rscratch1, 0));
3038   }
3039 }
3040 
3041 // AVX 3-operands instructions
3042 
3043 void MacroAssembler::vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3044   if (reachable(src)) {
3045     vaddsd(dst, nds, as_Address(src));
3046   } else {
3047     lea(rscratch1, src);
3048     vaddsd(dst, nds, Address(rscratch1, 0));
3049   }
3050 }
3051 
3052 void MacroAssembler::vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3053   if (reachable(src)) {
3054     vaddss(dst, nds, as_Address(src));
3055   } else {
3056     lea(rscratch1, src);
3057     vaddss(dst, nds, Address(rscratch1, 0));
3058   }
3059 }
3060 
3061 void MacroAssembler::vpaddd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {
3062   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
3063   if (reachable(src)) {
3064     Assembler::vpaddd(dst, nds, as_Address(src), vector_len);
3065   } else {
3066     lea(rscratch, src);
3067     Assembler::vpaddd(dst, nds, Address(rscratch, 0), vector_len);
3068   }
3069 }
3070 
3071 void MacroAssembler::vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
3072   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3073   vandps(dst, nds, negate_field, vector_len);
3074 }
3075 
3076 void MacroAssembler::vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
3077   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3078   vandpd(dst, nds, negate_field, vector_len);
3079 }
3080 
3081 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3082   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3083   Assembler::vpaddb(dst, nds, src, vector_len);
3084 }
3085 
3086 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3087   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3088   Assembler::vpaddb(dst, nds, src, vector_len);
3089 }
3090 
3091 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3092   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3093   Assembler::vpaddw(dst, nds, src, vector_len);
3094 }
3095 
3096 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3097   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3098   Assembler::vpaddw(dst, nds, src, vector_len);
3099 }
3100 
3101 void MacroAssembler::vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3102   if (reachable(src)) {
3103     Assembler::vpand(dst, nds, as_Address(src), vector_len);
3104   } else {
3105     lea(scratch_reg, src);
3106     Assembler::vpand(dst, nds, Address(scratch_reg, 0), vector_len);
3107   }
3108 }
3109 
3110 void MacroAssembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {
3111   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3112   Assembler::vpbroadcastw(dst, src, vector_len);
3113 }
3114 
3115 void MacroAssembler::vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3116   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3117   Assembler::vpcmpeqb(dst, nds, src, vector_len);
3118 }
3119 
3120 void MacroAssembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3121   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3122   Assembler::vpcmpeqw(dst, nds, src, vector_len);
3123 }
3124 
3125 void MacroAssembler::vpmovzxbw(XMMRegister dst, Address src, int vector_len) {
3126   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3127   Assembler::vpmovzxbw(dst, src, vector_len);
3128 }
3129 
3130 void MacroAssembler::vpmovmskb(Register dst, XMMRegister src) {
3131   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
3132   Assembler::vpmovmskb(dst, src);
3133 }
3134 
3135 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3136   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3137   Assembler::vpmullw(dst, nds, src, vector_len);
3138 }
3139 
3140 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3141   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3142   Assembler::vpmullw(dst, nds, src, vector_len);
3143 }
3144 
3145 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3146   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3147   Assembler::vpsubb(dst, nds, src, vector_len);
3148 }
3149 
3150 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3151   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3152   Assembler::vpsubb(dst, nds, src, vector_len);
3153 }
3154 
3155 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3156   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3157   Assembler::vpsubw(dst, nds, src, vector_len);
3158 }
3159 
3160 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3161   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3162   Assembler::vpsubw(dst, nds, src, vector_len);
3163 }
3164 
3165 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3166   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3167   Assembler::vpsraw(dst, nds, shift, vector_len);
3168 }
3169 
3170 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3171   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3172   Assembler::vpsraw(dst, nds, shift, vector_len);
3173 }
3174 
3175 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3176   assert(UseAVX &gt; 2,&quot;&quot;);
3177   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
3178      vector_len = 2;
3179   }
3180   Assembler::evpsraq(dst, nds, shift, vector_len);
3181 }
3182 
3183 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3184   assert(UseAVX &gt; 2,&quot;&quot;);
3185   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
3186      vector_len = 2;
3187   }
3188   Assembler::evpsraq(dst, nds, shift, vector_len);
3189 }
3190 
3191 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3192   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3193   Assembler::vpsrlw(dst, nds, shift, vector_len);
3194 }
3195 
3196 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3197   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3198   Assembler::vpsrlw(dst, nds, shift, vector_len);
3199 }
3200 
3201 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3202   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3203   Assembler::vpsllw(dst, nds, shift, vector_len);
3204 }
3205 
3206 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3207   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3208   Assembler::vpsllw(dst, nds, shift, vector_len);
3209 }
3210 
3211 void MacroAssembler::vptest(XMMRegister dst, XMMRegister src) {
3212   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
3213   Assembler::vptest(dst, src);
3214 }
3215 
3216 void MacroAssembler::punpcklbw(XMMRegister dst, XMMRegister src) {
3217   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3218   Assembler::punpcklbw(dst, src);
3219 }
3220 
3221 void MacroAssembler::pshufd(XMMRegister dst, Address src, int mode) {
3222   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
3223   Assembler::pshufd(dst, src, mode);
3224 }
3225 
3226 void MacroAssembler::pshuflw(XMMRegister dst, XMMRegister src, int mode) {
3227   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3228   Assembler::pshuflw(dst, src, mode);
3229 }
3230 
3231 void MacroAssembler::vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3232   if (reachable(src)) {
3233     vandpd(dst, nds, as_Address(src), vector_len);
3234   } else {
3235     lea(scratch_reg, src);
3236     vandpd(dst, nds, Address(scratch_reg, 0), vector_len);
3237   }
3238 }
3239 
3240 void MacroAssembler::vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3241   if (reachable(src)) {
3242     vandps(dst, nds, as_Address(src), vector_len);
3243   } else {
3244     lea(scratch_reg, src);
3245     vandps(dst, nds, Address(scratch_reg, 0), vector_len);
3246   }
3247 }
3248 
3249 void MacroAssembler::vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3250   if (reachable(src)) {
3251     vdivsd(dst, nds, as_Address(src));
3252   } else {
3253     lea(rscratch1, src);
3254     vdivsd(dst, nds, Address(rscratch1, 0));
3255   }
3256 }
3257 
3258 void MacroAssembler::vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3259   if (reachable(src)) {
3260     vdivss(dst, nds, as_Address(src));
3261   } else {
3262     lea(rscratch1, src);
3263     vdivss(dst, nds, Address(rscratch1, 0));
3264   }
3265 }
3266 
3267 void MacroAssembler::vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3268   if (reachable(src)) {
3269     vmulsd(dst, nds, as_Address(src));
3270   } else {
3271     lea(rscratch1, src);
3272     vmulsd(dst, nds, Address(rscratch1, 0));
3273   }
3274 }
3275 
3276 void MacroAssembler::vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3277   if (reachable(src)) {
3278     vmulss(dst, nds, as_Address(src));
3279   } else {
3280     lea(rscratch1, src);
3281     vmulss(dst, nds, Address(rscratch1, 0));
3282   }
3283 }
3284 
3285 void MacroAssembler::vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3286   if (reachable(src)) {
3287     vsubsd(dst, nds, as_Address(src));
3288   } else {
3289     lea(rscratch1, src);
3290     vsubsd(dst, nds, Address(rscratch1, 0));
3291   }
3292 }
3293 
3294 void MacroAssembler::vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3295   if (reachable(src)) {
3296     vsubss(dst, nds, as_Address(src));
3297   } else {
3298     lea(rscratch1, src);
3299     vsubss(dst, nds, Address(rscratch1, 0));
3300   }
3301 }
3302 
3303 void MacroAssembler::vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3304   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3305   vxorps(dst, nds, src, Assembler::AVX_128bit);
3306 }
3307 
3308 void MacroAssembler::vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3309   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3310   vxorpd(dst, nds, src, Assembler::AVX_128bit);
3311 }
3312 
3313 void MacroAssembler::vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3314   if (reachable(src)) {
3315     vxorpd(dst, nds, as_Address(src), vector_len);
3316   } else {
3317     lea(scratch_reg, src);
3318     vxorpd(dst, nds, Address(scratch_reg, 0), vector_len);
3319   }
3320 }
3321 
3322 void MacroAssembler::vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3323   if (reachable(src)) {
3324     vxorps(dst, nds, as_Address(src), vector_len);
3325   } else {
3326     lea(scratch_reg, src);
3327     vxorps(dst, nds, Address(scratch_reg, 0), vector_len);
3328   }
3329 }
3330 
3331 void MacroAssembler::vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3332   if (UseAVX &gt; 1 || (vector_len &lt; 1)) {
3333     if (reachable(src)) {
3334       Assembler::vpxor(dst, nds, as_Address(src), vector_len);
3335     } else {
3336       lea(scratch_reg, src);
3337       Assembler::vpxor(dst, nds, Address(scratch_reg, 0), vector_len);
3338     }
3339   }
3340   else {
3341     MacroAssembler::vxorpd(dst, nds, src, vector_len, scratch_reg);
3342   }
3343 }
3344 
3345 //-------------------------------------------------------------------------------------------
3346 
3347 void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {
3348   const int32_t inverted_jweak_mask = ~static_cast&lt;int32_t&gt;(JNIHandles::weak_tag_mask);
3349   STATIC_ASSERT(inverted_jweak_mask == -2); // otherwise check this code
3350   // The inverted mask is sign-extended
3351   andptr(possibly_jweak, inverted_jweak_mask);
3352 }
3353 
3354 void MacroAssembler::resolve_jobject(Register value,
3355                                      Register thread,
3356                                      Register tmp) {
3357   assert_different_registers(value, thread, tmp);
3358   Label done, not_weak;
3359   testptr(value, value);
3360   jcc(Assembler::zero, done);                // Use NULL as-is.
3361   testptr(value, JNIHandles::weak_tag_mask); // Test for jweak tag.
3362   jcc(Assembler::zero, not_weak);
3363   // Resolve jweak.
3364   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
3365                  value, Address(value, -JNIHandles::weak_tag_value), tmp, thread);
3366   verify_oop(value);
3367   jmp(done);
3368   bind(not_weak);
3369   // Resolve (untagged) jobject.
3370   access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);
3371   verify_oop(value);
3372   bind(done);
3373 }
3374 
3375 void MacroAssembler::subptr(Register dst, int32_t imm32) {
3376   LP64_ONLY(subq(dst, imm32)) NOT_LP64(subl(dst, imm32));
3377 }
3378 
3379 // Force generation of a 4 byte immediate value even if it fits into 8bit
3380 void MacroAssembler::subptr_imm32(Register dst, int32_t imm32) {
3381   LP64_ONLY(subq_imm32(dst, imm32)) NOT_LP64(subl_imm32(dst, imm32));
3382 }
3383 
3384 void MacroAssembler::subptr(Register dst, Register src) {
3385   LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src));
3386 }
3387 
3388 // C++ bool manipulation
3389 void MacroAssembler::testbool(Register dst) {
3390   if(sizeof(bool) == 1)
3391     testb(dst, 0xff);
3392   else if(sizeof(bool) == 2) {
3393     // testw implementation needed for two byte bools
3394     ShouldNotReachHere();
3395   } else if(sizeof(bool) == 4)
3396     testl(dst, dst);
3397   else
3398     // unsupported
3399     ShouldNotReachHere();
3400 }
3401 
3402 void MacroAssembler::testptr(Register dst, Register src) {
3403   LP64_ONLY(testq(dst, src)) NOT_LP64(testl(dst, src));
3404 }
3405 
3406 // Object / value buffer allocation...
3407 //
3408 // Kills klass and rsi on LP64
3409 void MacroAssembler::allocate_instance(Register klass, Register new_obj,
3410                                        Register t1, Register t2,
3411                                        bool clear_fields, Label&amp; alloc_failed)
3412 {
3413   Label done, initialize_header, initialize_object, slow_case, slow_case_no_pop;
3414   Register layout_size = t1;
3415   assert(new_obj == rax, &quot;needs to be rax, according to barrier asm eden_allocate&quot;);
3416   assert_different_registers(klass, new_obj, t1, t2);
3417 
3418 #ifdef ASSERT
3419   {
3420     Label L;
3421     cmpb(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
3422     jcc(Assembler::equal, L);
3423     stop(&quot;klass not initialized&quot;);
3424     bind(L);
3425   }
3426 #endif
3427 
3428   // get instance_size in InstanceKlass (scaled to a count of bytes)
3429   movl(layout_size, Address(klass, Klass::layout_helper_offset()));
3430   // test to see if it has a finalizer or is malformed in some way
3431   testl(layout_size, Klass::_lh_instance_slow_path_bit);
3432   jcc(Assembler::notZero, slow_case_no_pop);
3433 
3434   // Allocate the instance:
3435   //  If TLAB is enabled:
3436   //    Try to allocate in the TLAB.
3437   //    If fails, go to the slow path.
3438   //  Else If inline contiguous allocations are enabled:
3439   //    Try to allocate in eden.
3440   //    If fails due to heap end, go to slow path.
3441   //
3442   //  If TLAB is enabled OR inline contiguous is enabled:
3443   //    Initialize the allocation.
3444   //    Exit.
3445   //
3446   //  Go to slow path.
3447   const bool allow_shared_alloc =
3448     Universe::heap()-&gt;supports_inline_contig_alloc();
3449 
3450   push(klass);
3451   const Register thread = LP64_ONLY(r15_thread) NOT_LP64(klass);
3452 #ifndef _LP64
3453   if (UseTLAB || allow_shared_alloc) {
3454     get_thread(thread);
3455   }
3456 #endif // _LP64
3457 
3458   if (UseTLAB) {
3459     tlab_allocate(thread, new_obj, layout_size, 0, klass, t2, slow_case);
3460     if (ZeroTLAB || (!clear_fields)) {
3461       // the fields have been already cleared
3462       jmp(initialize_header);
3463     } else {
3464       // initialize both the header and fields
3465       jmp(initialize_object);
3466     }
3467   } else {
3468     // Allocation in the shared Eden, if allowed.
3469     //
3470     eden_allocate(thread, new_obj, layout_size, 0, t2, slow_case);
3471   }
3472 
3473   // If UseTLAB or allow_shared_alloc are true, the object is created above and
3474   // there is an initialize need. Otherwise, skip and go to the slow path.
3475   if (UseTLAB || allow_shared_alloc) {
3476     if (clear_fields) {
3477       // The object is initialized before the header.  If the object size is
3478       // zero, go directly to the header initialization.
3479       bind(initialize_object);
3480       decrement(layout_size, sizeof(oopDesc));
3481       jcc(Assembler::zero, initialize_header);
3482 
3483       // Initialize topmost object field, divide size by 8, check if odd and
3484       // test if zero.
3485       Register zero = klass;
3486       xorl(zero, zero);    // use zero reg to clear memory (shorter code)
3487       shrl(layout_size, LogBytesPerLong); // divide by 2*oopSize and set carry flag if odd
3488 
3489   #ifdef ASSERT
3490       // make sure instance_size was multiple of 8
3491       Label L;
3492       // Ignore partial flag stall after shrl() since it is debug VM
3493       jcc(Assembler::carryClear, L);
3494       stop(&quot;object size is not multiple of 2 - adjust this code&quot;);
3495       bind(L);
3496       // must be &gt; 0, no extra check needed here
3497   #endif
3498 
3499       // initialize remaining object fields: instance_size was a multiple of 8
3500       {
3501         Label loop;
3502         bind(loop);
3503         movptr(Address(new_obj, layout_size, Address::times_8, sizeof(oopDesc) - 1*oopSize), zero);
3504         NOT_LP64(movptr(Address(new_obj, layout_size, Address::times_8, sizeof(oopDesc) - 2*oopSize), zero));
3505         decrement(layout_size);
3506         jcc(Assembler::notZero, loop);
3507       }
3508     } // clear_fields
3509 
3510     // initialize object header only.
3511     bind(initialize_header);
3512     pop(klass);
3513     Register mark_word = t2;
3514     movptr(mark_word, Address(klass, Klass::prototype_header_offset()));
3515     movptr(Address(new_obj, oopDesc::mark_offset_in_bytes ()), mark_word);
3516 #ifdef _LP64
3517     xorl(rsi, rsi);                 // use zero reg to clear memory (shorter code)
3518     store_klass_gap(new_obj, rsi);  // zero klass gap for compressed oops
3519 #endif
3520     movptr(t2, klass);         // preserve klass
3521     store_klass(new_obj, t2);  // src klass reg is potentially compressed
3522 
3523     jmp(done);
3524   }
3525 
3526   bind(slow_case);
3527   pop(klass);
3528   bind(slow_case_no_pop);
3529   jmp(alloc_failed);
3530 
3531   bind(done);
3532 }
3533 
3534 // Defines obj, preserves var_size_in_bytes, okay for t2 == var_size_in_bytes.
3535 void MacroAssembler::tlab_allocate(Register thread, Register obj,
3536                                    Register var_size_in_bytes,
3537                                    int con_size_in_bytes,
3538                                    Register t1,
3539                                    Register t2,
3540                                    Label&amp; slow_case) {
3541   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3542   bs-&gt;tlab_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
3543 }
3544 
3545 // Defines obj, preserves var_size_in_bytes
3546 void MacroAssembler::eden_allocate(Register thread, Register obj,
3547                                    Register var_size_in_bytes,
3548                                    int con_size_in_bytes,
3549                                    Register t1,
3550                                    Label&amp; slow_case) {
3551   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3552   bs-&gt;eden_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
3553 }
3554 
3555 // Preserves the contents of address, destroys the contents length_in_bytes and temp.
3556 void MacroAssembler::zero_memory(Register address, Register length_in_bytes, int offset_in_bytes, Register temp) {
3557   assert(address != length_in_bytes &amp;&amp; address != temp &amp;&amp; temp != length_in_bytes, &quot;registers must be different&quot;);
3558   assert((offset_in_bytes &amp; (BytesPerWord - 1)) == 0, &quot;offset must be a multiple of BytesPerWord&quot;);
3559   Label done;
3560 
3561   testptr(length_in_bytes, length_in_bytes);
3562   jcc(Assembler::zero, done);
3563 
3564   // initialize topmost word, divide index by 2, check if odd and test if zero
3565   // note: for the remaining code to work, index must be a multiple of BytesPerWord
3566 #ifdef ASSERT
3567   {
3568     Label L;
3569     testptr(length_in_bytes, BytesPerWord - 1);
3570     jcc(Assembler::zero, L);
3571     stop(&quot;length must be a multiple of BytesPerWord&quot;);
3572     bind(L);
3573   }
3574 #endif
3575   Register index = length_in_bytes;
3576   xorptr(temp, temp);    // use _zero reg to clear memory (shorter code)
3577   if (UseIncDec) {
3578     shrptr(index, 3);  // divide by 8/16 and set carry flag if bit 2 was set
3579   } else {
3580     shrptr(index, 2);  // use 2 instructions to avoid partial flag stall
3581     shrptr(index, 1);
3582   }
3583 #ifndef _LP64
3584   // index could have not been a multiple of 8 (i.e., bit 2 was set)
3585   {
3586     Label even;
3587     // note: if index was a multiple of 8, then it cannot
3588     //       be 0 now otherwise it must have been 0 before
3589     //       =&gt; if it is even, we don&#39;t need to check for 0 again
3590     jcc(Assembler::carryClear, even);
3591     // clear topmost word (no jump would be needed if conditional assignment worked here)
3592     movptr(Address(address, index, Address::times_8, offset_in_bytes - 0*BytesPerWord), temp);
3593     // index could be 0 now, must check again
3594     jcc(Assembler::zero, done);
3595     bind(even);
3596   }
3597 #endif // !_LP64
3598   // initialize remaining object fields: index is a multiple of 2 now
3599   {
3600     Label loop;
3601     bind(loop);
3602     movptr(Address(address, index, Address::times_8, offset_in_bytes - 1*BytesPerWord), temp);
3603     NOT_LP64(movptr(Address(address, index, Address::times_8, offset_in_bytes - 2*BytesPerWord), temp);)
3604     decrement(index);
3605     jcc(Assembler::notZero, loop);
3606   }
3607 
3608   bind(done);
3609 }
3610 
3611 void MacroAssembler::get_value_field_klass(Register klass, Register index, Register value_klass) {
3612   movptr(value_klass, Address(klass, InstanceKlass::value_field_klasses_offset()));
3613 #ifdef ASSERT
3614   {
3615     Label done;
3616     cmpptr(value_klass, 0);
3617     jcc(Assembler::notEqual, done);
3618     stop(&quot;get_value_field_klass contains no inline klasses&quot;);
3619     bind(done);
3620   }
3621 #endif
3622   movptr(value_klass, Address(value_klass, index, Address::times_ptr));
3623 }
3624 
3625 void MacroAssembler::get_default_value_oop(Register value_klass, Register temp_reg, Register obj) {
3626 #ifdef ASSERT
3627   {
3628     Label done_check;
3629     test_klass_is_value(value_klass, temp_reg, done_check);
3630     stop(&quot;get_default_value_oop from non-value klass&quot;);
3631     bind(done_check);
3632   }
3633 #endif
3634   Register offset = temp_reg;
3635   // Getting the offset of the pre-allocated default value
3636   movptr(offset, Address(value_klass, in_bytes(InstanceKlass::adr_valueklass_fixed_block_offset())));
3637   movl(offset, Address(offset, in_bytes(ValueKlass::default_value_offset_offset())));
3638 
3639   // Getting the mirror
3640   movptr(obj, Address(value_klass, in_bytes(Klass::java_mirror_offset())));
3641   resolve_oop_handle(obj, value_klass);
3642 
3643   // Getting the pre-allocated default value from the mirror
3644   Address field(obj, offset, Address::times_1);
3645   load_heap_oop(obj, field);
3646 }
3647 
3648 void MacroAssembler::get_empty_value_oop(Register value_klass, Register temp_reg, Register obj) {
3649 #ifdef ASSERT
3650   {
3651     Label done_check;
3652     test_klass_is_empty_value(value_klass, temp_reg, done_check);
3653     stop(&quot;get_empty_value from non-empty value klass&quot;);
3654     bind(done_check);
3655   }
3656 #endif
3657   get_default_value_oop(value_klass, temp_reg, obj);
3658 }
3659 
3660 
3661 // Look up the method for a megamorphic invokeinterface call.
3662 // The target method is determined by &lt;intf_klass, itable_index&gt;.
3663 // The receiver klass is in recv_klass.
3664 // On success, the result will be in method_result, and execution falls through.
3665 // On failure, execution transfers to the given label.
3666 void MacroAssembler::lookup_interface_method(Register recv_klass,
3667                                              Register intf_klass,
3668                                              RegisterOrConstant itable_index,
3669                                              Register method_result,
3670                                              Register scan_temp,
3671                                              Label&amp; L_no_such_interface,
3672                                              bool return_method) {
3673   assert_different_registers(recv_klass, intf_klass, scan_temp);
3674   assert_different_registers(method_result, intf_klass, scan_temp);
3675   assert(recv_klass != method_result || !return_method,
3676          &quot;recv_klass can be destroyed when method isn&#39;t needed&quot;);
3677 
3678   assert(itable_index.is_constant() || itable_index.as_register() == method_result,
3679          &quot;caller must use same register for non-constant itable index as for method&quot;);
3680 
3681   // Compute start of first itableOffsetEntry (which is at the end of the vtable)
3682   int vtable_base = in_bytes(Klass::vtable_start_offset());
3683   int itentry_off = itableMethodEntry::method_offset_in_bytes();
3684   int scan_step   = itableOffsetEntry::size() * wordSize;
3685   int vte_size    = vtableEntry::size_in_bytes();
3686   Address::ScaleFactor times_vte_scale = Address::times_ptr;
3687   assert(vte_size == wordSize, &quot;else adjust times_vte_scale&quot;);
3688 
3689   movl(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));
3690 
3691   // %%% Could store the aligned, prescaled offset in the klassoop.
3692   lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base));
3693 
3694   if (return_method) {
3695     // Adjust recv_klass by scaled itable_index, so we can free itable_index.
3696     assert(itableMethodEntry::size() * wordSize == wordSize, &quot;adjust the scaling in the code below&quot;);
3697     lea(recv_klass, Address(recv_klass, itable_index, Address::times_ptr, itentry_off));
3698   }
3699 
3700   // for (scan = klass-&gt;itable(); scan-&gt;interface() != NULL; scan += scan_step) {
3701   //   if (scan-&gt;interface() == intf) {
3702   //     result = (klass + scan-&gt;offset() + itable_index);
3703   //   }
3704   // }
3705   Label search, found_method;
3706 
3707   for (int peel = 1; peel &gt;= 0; peel--) {
3708     movptr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));
3709     cmpptr(intf_klass, method_result);
3710 
3711     if (peel) {
3712       jccb(Assembler::equal, found_method);
3713     } else {
3714       jccb(Assembler::notEqual, search);
3715       // (invert the test to fall through to found_method...)
3716     }
3717 
3718     if (!peel)  break;
3719 
3720     bind(search);
3721 
3722     // Check that the previous entry is non-null.  A null entry means that
3723     // the receiver class doesn&#39;t implement the interface, and wasn&#39;t the
3724     // same as when the caller was compiled.
3725     testptr(method_result, method_result);
3726     jcc(Assembler::zero, L_no_such_interface);
3727     addptr(scan_temp, scan_step);
3728   }
3729 
3730   bind(found_method);
3731 
3732   if (return_method) {
3733     // Got a hit.
3734     movl(scan_temp, Address(scan_temp, itableOffsetEntry::offset_offset_in_bytes()));
3735     movptr(method_result, Address(recv_klass, scan_temp, Address::times_1));
3736   }
3737 }
3738 
3739 
3740 // virtual method calling
3741 void MacroAssembler::lookup_virtual_method(Register recv_klass,
3742                                            RegisterOrConstant vtable_index,
3743                                            Register method_result) {
3744   const int base = in_bytes(Klass::vtable_start_offset());
3745   assert(vtableEntry::size() * wordSize == wordSize, &quot;else adjust the scaling in the code below&quot;);
3746   Address vtable_entry_addr(recv_klass,
3747                             vtable_index, Address::times_ptr,
3748                             base + vtableEntry::method_offset_in_bytes());
3749   movptr(method_result, vtable_entry_addr);
3750 }
3751 
3752 
3753 void MacroAssembler::check_klass_subtype(Register sub_klass,
3754                            Register super_klass,
3755                            Register temp_reg,
3756                            Label&amp; L_success) {
3757   Label L_failure;
3758   check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &amp;L_success, &amp;L_failure, NULL);
3759   check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &amp;L_success, NULL);
3760   bind(L_failure);
3761 }
3762 
3763 
3764 void MacroAssembler::check_klass_subtype_fast_path(Register sub_klass,
3765                                                    Register super_klass,
3766                                                    Register temp_reg,
3767                                                    Label* L_success,
3768                                                    Label* L_failure,
3769                                                    Label* L_slow_path,
3770                                         RegisterOrConstant super_check_offset) {
3771   assert_different_registers(sub_klass, super_klass, temp_reg);
3772   bool must_load_sco = (super_check_offset.constant_or_zero() == -1);
3773   if (super_check_offset.is_register()) {
3774     assert_different_registers(sub_klass, super_klass,
3775                                super_check_offset.as_register());
3776   } else if (must_load_sco) {
3777     assert(temp_reg != noreg, &quot;supply either a temp or a register offset&quot;);
3778   }
3779 
3780   Label L_fallthrough;
3781   int label_nulls = 0;
3782   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
3783   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
3784   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
3785   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3786 
3787   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3788   int sco_offset = in_bytes(Klass::super_check_offset_offset());
3789   Address super_check_offset_addr(super_klass, sco_offset);
3790 
3791   // Hacked jcc, which &quot;knows&quot; that L_fallthrough, at least, is in
3792   // range of a jccb.  If this routine grows larger, reconsider at
3793   // least some of these.
3794 #define local_jcc(assembler_cond, label)                                \
3795   if (&amp;(label) == &amp;L_fallthrough)  jccb(assembler_cond, label);         \
3796   else                             jcc( assembler_cond, label) /*omit semi*/
3797 
3798   // Hacked jmp, which may only be used just before L_fallthrough.
3799 #define final_jmp(label)                                                \
3800   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
3801   else                            jmp(label)                /*omit semi*/
3802 
3803   // If the pointers are equal, we are done (e.g., String[] elements).
3804   // This self-check enables sharing of secondary supertype arrays among
3805   // non-primary types such as array-of-interface.  Otherwise, each such
3806   // type would need its own customized SSA.
3807   // We move this check to the front of the fast path because many
3808   // type checks are in fact trivially successful in this manner,
3809   // so we get a nicely predicted branch right at the start of the check.
3810   cmpptr(sub_klass, super_klass);
3811   local_jcc(Assembler::equal, *L_success);
3812 
3813   // Check the supertype display:
3814   if (must_load_sco) {
3815     // Positive movl does right thing on LP64.
3816     movl(temp_reg, super_check_offset_addr);
3817     super_check_offset = RegisterOrConstant(temp_reg);
3818   }
3819   Address super_check_addr(sub_klass, super_check_offset, Address::times_1, 0);
3820   cmpptr(super_klass, super_check_addr); // load displayed supertype
3821 
3822   // This check has worked decisively for primary supers.
3823   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
3824   // (Secondary supers are interfaces and very deeply nested subtypes.)
3825   // This works in the same check above because of a tricky aliasing
3826   // between the super_cache and the primary super display elements.
3827   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
3828   // Note that the cache is updated below if it does not help us find
3829   // what we need immediately.
3830   // So if it was a primary super, we can just fail immediately.
3831   // Otherwise, it&#39;s the slow path for us (no success at this point).
3832 
3833   if (super_check_offset.is_register()) {
3834     local_jcc(Assembler::equal, *L_success);
3835     cmpl(super_check_offset.as_register(), sc_offset);
3836     if (L_failure == &amp;L_fallthrough) {
3837       local_jcc(Assembler::equal, *L_slow_path);
3838     } else {
3839       local_jcc(Assembler::notEqual, *L_failure);
3840       final_jmp(*L_slow_path);
3841     }
3842   } else if (super_check_offset.as_constant() == sc_offset) {
3843     // Need a slow path; fast failure is impossible.
3844     if (L_slow_path == &amp;L_fallthrough) {
3845       local_jcc(Assembler::equal, *L_success);
3846     } else {
3847       local_jcc(Assembler::notEqual, *L_slow_path);
3848       final_jmp(*L_success);
3849     }
3850   } else {
3851     // No slow path; it&#39;s a fast decision.
3852     if (L_failure == &amp;L_fallthrough) {
3853       local_jcc(Assembler::equal, *L_success);
3854     } else {
3855       local_jcc(Assembler::notEqual, *L_failure);
3856       final_jmp(*L_success);
3857     }
3858   }
3859 
3860   bind(L_fallthrough);
3861 
3862 #undef local_jcc
3863 #undef final_jmp
3864 }
3865 
3866 
3867 void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,
3868                                                    Register super_klass,
3869                                                    Register temp_reg,
3870                                                    Register temp2_reg,
3871                                                    Label* L_success,
3872                                                    Label* L_failure,
3873                                                    bool set_cond_codes) {
3874   assert_different_registers(sub_klass, super_klass, temp_reg);
3875   if (temp2_reg != noreg)
3876     assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg);
3877 #define IS_A_TEMP(reg) ((reg) == temp_reg || (reg) == temp2_reg)
3878 
3879   Label L_fallthrough;
3880   int label_nulls = 0;
3881   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
3882   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
3883   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3884 
3885   // a couple of useful fields in sub_klass:
3886   int ss_offset = in_bytes(Klass::secondary_supers_offset());
3887   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3888   Address secondary_supers_addr(sub_klass, ss_offset);
3889   Address super_cache_addr(     sub_klass, sc_offset);
3890 
3891   // Do a linear scan of the secondary super-klass chain.
3892   // This code is rarely used, so simplicity is a virtue here.
3893   // The repne_scan instruction uses fixed registers, which we must spill.
3894   // Don&#39;t worry too much about pre-existing connections with the input regs.
3895 
3896   assert(sub_klass != rax, &quot;killed reg&quot;); // killed by mov(rax, super)
3897   assert(sub_klass != rcx, &quot;killed reg&quot;); // killed by lea(rcx, &amp;pst_counter)
3898 
3899   // Get super_klass value into rax (even if it was in rdi or rcx).
3900   bool pushed_rax = false, pushed_rcx = false, pushed_rdi = false;
3901   if (super_klass != rax || UseCompressedOops) {
3902     if (!IS_A_TEMP(rax)) { push(rax); pushed_rax = true; }
3903     mov(rax, super_klass);
3904   }
3905   if (!IS_A_TEMP(rcx)) { push(rcx); pushed_rcx = true; }
3906   if (!IS_A_TEMP(rdi)) { push(rdi); pushed_rdi = true; }
3907 
3908 #ifndef PRODUCT
3909   int* pst_counter = &amp;SharedRuntime::_partial_subtype_ctr;
3910   ExternalAddress pst_counter_addr((address) pst_counter);
3911   NOT_LP64(  incrementl(pst_counter_addr) );
3912   LP64_ONLY( lea(rcx, pst_counter_addr) );
3913   LP64_ONLY( incrementl(Address(rcx, 0)) );
3914 #endif //PRODUCT
3915 
3916   // We will consult the secondary-super array.
3917   movptr(rdi, secondary_supers_addr);
3918   // Load the array length.  (Positive movl does right thing on LP64.)
3919   movl(rcx, Address(rdi, Array&lt;Klass*&gt;::length_offset_in_bytes()));
3920   // Skip to start of data.
3921   addptr(rdi, Array&lt;Klass*&gt;::base_offset_in_bytes());
3922 
3923   // Scan RCX words at [RDI] for an occurrence of RAX.
3924   // Set NZ/Z based on last compare.
3925   // Z flag value will not be set by &#39;repne&#39; if RCX == 0 since &#39;repne&#39; does
3926   // not change flags (only scas instruction which is repeated sets flags).
3927   // Set Z = 0 (not equal) before &#39;repne&#39; to indicate that class was not found.
3928 
3929     testptr(rax,rax); // Set Z = 0
3930     repne_scan();
3931 
3932   // Unspill the temp. registers:
3933   if (pushed_rdi)  pop(rdi);
3934   if (pushed_rcx)  pop(rcx);
3935   if (pushed_rax)  pop(rax);
3936 
3937   if (set_cond_codes) {
3938     // Special hack for the AD files:  rdi is guaranteed non-zero.
3939     assert(!pushed_rdi, &quot;rdi must be left non-NULL&quot;);
3940     // Also, the condition codes are properly set Z/NZ on succeed/failure.
3941   }
3942 
3943   if (L_failure == &amp;L_fallthrough)
3944         jccb(Assembler::notEqual, *L_failure);
3945   else  jcc(Assembler::notEqual, *L_failure);
3946 
3947   // Success.  Cache the super we found and proceed in triumph.
3948   movptr(super_cache_addr, super_klass);
3949 
3950   if (L_success != &amp;L_fallthrough) {
3951     jmp(*L_success);
3952   }
3953 
3954 #undef IS_A_TEMP
3955 
3956   bind(L_fallthrough);
3957 }
3958 
3959 void MacroAssembler::clinit_barrier(Register klass, Register thread, Label* L_fast_path, Label* L_slow_path) {
3960   assert(L_fast_path != NULL || L_slow_path != NULL, &quot;at least one is required&quot;);
3961 
3962   Label L_fallthrough;
3963   if (L_fast_path == NULL) {
3964     L_fast_path = &amp;L_fallthrough;
3965   } else if (L_slow_path == NULL) {
3966     L_slow_path = &amp;L_fallthrough;
3967   }
3968 
3969   // Fast path check: class is fully initialized
3970   cmpb(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
3971   jcc(Assembler::equal, *L_fast_path);
3972 
3973   // Fast path check: current thread is initializer thread
3974   cmpptr(thread, Address(klass, InstanceKlass::init_thread_offset()));
3975   if (L_slow_path == &amp;L_fallthrough) {
3976     jcc(Assembler::equal, *L_fast_path);
3977     bind(*L_slow_path);
3978   } else if (L_fast_path == &amp;L_fallthrough) {
3979     jcc(Assembler::notEqual, *L_slow_path);
3980     bind(*L_fast_path);
3981   } else {
3982     Unimplemented();
3983   }
3984 }
3985 
3986 void MacroAssembler::cmov32(Condition cc, Register dst, Address src) {
3987   if (VM_Version::supports_cmov()) {
3988     cmovl(cc, dst, src);
3989   } else {
3990     Label L;
3991     jccb(negate_condition(cc), L);
3992     movl(dst, src);
3993     bind(L);
3994   }
3995 }
3996 
3997 void MacroAssembler::cmov32(Condition cc, Register dst, Register src) {
3998   if (VM_Version::supports_cmov()) {
3999     cmovl(cc, dst, src);
4000   } else {
4001     Label L;
4002     jccb(negate_condition(cc), L);
4003     movl(dst, src);
4004     bind(L);
4005   }
4006 }
4007 
4008 void MacroAssembler::_verify_oop(Register reg, const char* s, const char* file, int line) {
4009   if (!VerifyOops || VerifyAdapterSharing) {
4010     // Below address of the code string confuses VerifyAdapterSharing
4011     // because it may differ between otherwise equivalent adapters.
4012     return;
4013   }
4014 
4015   // Pass register number to verify_oop_subroutine
4016   const char* b = NULL;
4017   {
4018     ResourceMark rm;
4019     stringStream ss;
4020     ss.print(&quot;verify_oop: %s: %s (%s:%d)&quot;, reg-&gt;name(), s, file, line);
4021     b = code_string(ss.as_string());
4022   }
4023   BLOCK_COMMENT(&quot;verify_oop {&quot;);
4024 #ifdef _LP64
4025   push(rscratch1);                    // save r10, trashed by movptr()
4026 #endif
4027   push(rax);                          // save rax,
4028   push(reg);                          // pass register argument
4029   ExternalAddress buffer((address) b);
4030   // avoid using pushptr, as it modifies scratch registers
4031   // and our contract is not to modify anything
4032   movptr(rax, buffer.addr());
4033   push(rax);
4034   // call indirectly to solve generation ordering problem
4035   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
4036   call(rax);
4037   // Caller pops the arguments (oop, message) and restores rax, r10
4038   BLOCK_COMMENT(&quot;} verify_oop&quot;);
4039 }
4040 
4041 void MacroAssembler::vallones(XMMRegister dst, int vector_len) {
4042   if (UseAVX &gt; 2 &amp;&amp; (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl())) {
4043     vpternlogd(dst, 0xFF, dst, dst, vector_len);
4044   } else {
4045     assert(UseAVX &gt; 0, &quot;&quot;);
4046     vpcmpeqb(dst, dst, dst, vector_len);
4047   }
4048 }
4049 
4050 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
4051                                                       Register tmp,
4052                                                       int offset) {
4053   intptr_t value = *delayed_value_addr;
4054   if (value != 0)
4055     return RegisterOrConstant(value + offset);
4056 
4057   // load indirectly to solve generation ordering problem
4058   movptr(tmp, ExternalAddress((address) delayed_value_addr));
4059 
4060 #ifdef ASSERT
4061   { Label L;
4062     testptr(tmp, tmp);
4063     if (WizardMode) {
4064       const char* buf = NULL;
4065       {
4066         ResourceMark rm;
4067         stringStream ss;
4068         ss.print(&quot;DelayedValue=&quot; INTPTR_FORMAT, delayed_value_addr[1]);
4069         buf = code_string(ss.as_string());
4070       }
4071       jcc(Assembler::notZero, L);
4072       STOP(buf);
4073     } else {
4074       jccb(Assembler::notZero, L);
4075       hlt();
4076     }
4077     bind(L);
4078   }
4079 #endif
4080 
4081   if (offset != 0)
4082     addptr(tmp, offset);
4083 
4084   return RegisterOrConstant(tmp);
4085 }
4086 
4087 
4088 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
4089                                          int extra_slot_offset) {
4090   // cf. TemplateTable::prepare_invoke(), if (load_receiver).
4091   int stackElementSize = Interpreter::stackElementSize;
4092   int offset = Interpreter::expr_offset_in_bytes(extra_slot_offset+0);
4093 #ifdef ASSERT
4094   int offset1 = Interpreter::expr_offset_in_bytes(extra_slot_offset+1);
4095   assert(offset1 - offset == stackElementSize, &quot;correct arithmetic&quot;);
4096 #endif
4097   Register             scale_reg    = noreg;
4098   Address::ScaleFactor scale_factor = Address::no_scale;
4099   if (arg_slot.is_constant()) {
4100     offset += arg_slot.as_constant() * stackElementSize;
4101   } else {
4102     scale_reg    = arg_slot.as_register();
4103     scale_factor = Address::times(stackElementSize);
4104   }
4105   offset += wordSize;           // return PC is on stack
4106   return Address(rsp, scale_reg, scale_factor, offset);
4107 }
4108 
4109 
4110 void MacroAssembler::_verify_oop_addr(Address addr, const char* s, const char* file, int line) {
4111   if (!VerifyOops || VerifyAdapterSharing) {
4112     // Below address of the code string confuses VerifyAdapterSharing
4113     // because it may differ between otherwise equivalent adapters.
4114     return;
4115   }
4116 
4117   // Address adjust(addr.base(), addr.index(), addr.scale(), addr.disp() + BytesPerWord);
4118   // Pass register number to verify_oop_subroutine
4119   const char* b = NULL;
4120   {
4121     ResourceMark rm;
4122     stringStream ss;
4123     ss.print(&quot;verify_oop_addr: %s (%s:%d)&quot;, s, file, line);
4124     b = code_string(ss.as_string());
4125   }
4126 #ifdef _LP64
4127   push(rscratch1);                    // save r10, trashed by movptr()
4128 #endif
4129   push(rax);                          // save rax,
4130   // addr may contain rsp so we will have to adjust it based on the push
4131   // we just did (and on 64 bit we do two pushes)
4132   // NOTE: 64bit seemed to have had a bug in that it did movq(addr, rax); which
4133   // stores rax into addr which is backwards of what was intended.
4134   if (addr.uses(rsp)) {
4135     lea(rax, addr);
4136     pushptr(Address(rax, LP64_ONLY(2 *) BytesPerWord));
4137   } else {
4138     pushptr(addr);
4139   }
4140 
4141   ExternalAddress buffer((address) b);
4142   // pass msg argument
4143   // avoid using pushptr, as it modifies scratch registers
4144   // and our contract is not to modify anything
4145   movptr(rax, buffer.addr());
4146   push(rax);
4147 
4148   // call indirectly to solve generation ordering problem
4149   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
4150   call(rax);
4151   // Caller pops the arguments (addr, message) and restores rax, r10.
4152 }
4153 
4154 void MacroAssembler::verify_tlab() {
4155 #ifdef ASSERT
4156   if (UseTLAB &amp;&amp; VerifyOops) {
4157     Label next, ok;
4158     Register t1 = rsi;
4159     Register thread_reg = NOT_LP64(rbx) LP64_ONLY(r15_thread);
4160 
4161     push(t1);
4162     NOT_LP64(push(thread_reg));
4163     NOT_LP64(get_thread(thread_reg));
4164 
4165     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
4166     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_start_offset())));
4167     jcc(Assembler::aboveEqual, next);
4168     STOP(&quot;assert(top &gt;= start)&quot;);
4169     should_not_reach_here();
4170 
4171     bind(next);
4172     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_end_offset())));
4173     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
4174     jcc(Assembler::aboveEqual, ok);
4175     STOP(&quot;assert(top &lt;= end)&quot;);
4176     should_not_reach_here();
4177 
4178     bind(ok);
4179     NOT_LP64(pop(thread_reg));
4180     pop(t1);
4181   }
4182 #endif
4183 }
4184 
4185 class ControlWord {
4186  public:
4187   int32_t _value;
4188 
4189   int  rounding_control() const        { return  (_value &gt;&gt; 10) &amp; 3      ; }
4190   int  precision_control() const       { return  (_value &gt;&gt;  8) &amp; 3      ; }
4191   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
4192   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
4193   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
4194   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
4195   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
4196   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
4197 
4198   void print() const {
4199     // rounding control
4200     const char* rc;
4201     switch (rounding_control()) {
4202       case 0: rc = &quot;round near&quot;; break;
4203       case 1: rc = &quot;round down&quot;; break;
4204       case 2: rc = &quot;round up  &quot;; break;
4205       case 3: rc = &quot;chop      &quot;; break;
4206     };
4207     // precision control
4208     const char* pc;
4209     switch (precision_control()) {
4210       case 0: pc = &quot;24 bits &quot;; break;
4211       case 1: pc = &quot;reserved&quot;; break;
4212       case 2: pc = &quot;53 bits &quot;; break;
4213       case 3: pc = &quot;64 bits &quot;; break;
4214     };
4215     // flags
4216     char f[9];
4217     f[0] = &#39; &#39;;
4218     f[1] = &#39; &#39;;
4219     f[2] = (precision   ()) ? &#39;P&#39; : &#39;p&#39;;
4220     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;u&#39;;
4221     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;o&#39;;
4222     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;z&#39;;
4223     f[6] = (denormalized()) ? &#39;D&#39; : &#39;d&#39;;
4224     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;i&#39;;
4225     f[8] = &#39;\x0&#39;;
4226     // output
4227     printf(&quot;%04x  masks = %s, %s, %s&quot;, _value &amp; 0xFFFF, f, rc, pc);
4228   }
4229 
4230 };
4231 
4232 class StatusWord {
4233  public:
4234   int32_t _value;
4235 
4236   bool busy() const                    { return ((_value &gt;&gt; 15) &amp; 1) != 0; }
4237   bool C3() const                      { return ((_value &gt;&gt; 14) &amp; 1) != 0; }
4238   bool C2() const                      { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
4239   bool C1() const                      { return ((_value &gt;&gt;  9) &amp; 1) != 0; }
4240   bool C0() const                      { return ((_value &gt;&gt;  8) &amp; 1) != 0; }
4241   int  top() const                     { return  (_value &gt;&gt; 11) &amp; 7      ; }
4242   bool error_status() const            { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
4243   bool stack_fault() const             { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
4244   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
4245   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
4246   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
4247   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
4248   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
4249   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
4250 
4251   void print() const {
4252     // condition codes
4253     char c[5];
4254     c[0] = (C3()) ? &#39;3&#39; : &#39;-&#39;;
4255     c[1] = (C2()) ? &#39;2&#39; : &#39;-&#39;;
4256     c[2] = (C1()) ? &#39;1&#39; : &#39;-&#39;;
4257     c[3] = (C0()) ? &#39;0&#39; : &#39;-&#39;;
4258     c[4] = &#39;\x0&#39;;
4259     // flags
4260     char f[9];
4261     f[0] = (error_status()) ? &#39;E&#39; : &#39;-&#39;;
4262     f[1] = (stack_fault ()) ? &#39;S&#39; : &#39;-&#39;;
4263     f[2] = (precision   ()) ? &#39;P&#39; : &#39;-&#39;;
4264     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;-&#39;;
4265     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;-&#39;;
4266     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;-&#39;;
4267     f[6] = (denormalized()) ? &#39;D&#39; : &#39;-&#39;;
4268     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;-&#39;;
4269     f[8] = &#39;\x0&#39;;
4270     // output
4271     printf(&quot;%04x  flags = %s, cc =  %s, top = %d&quot;, _value &amp; 0xFFFF, f, c, top());
4272   }
4273 
4274 };
4275 
4276 class TagWord {
4277  public:
4278   int32_t _value;
4279 
4280   int tag_at(int i) const              { return (_value &gt;&gt; (i*2)) &amp; 3; }
4281 
4282   void print() const {
4283     printf(&quot;%04x&quot;, _value &amp; 0xFFFF);
4284   }
4285 
4286 };
4287 
4288 class FPU_Register {
4289  public:
4290   int32_t _m0;
4291   int32_t _m1;
4292   int16_t _ex;
4293 
4294   bool is_indefinite() const           {
4295     return _ex == -1 &amp;&amp; _m1 == (int32_t)0xC0000000 &amp;&amp; _m0 == 0;
4296   }
4297 
4298   void print() const {
4299     char  sign = (_ex &lt; 0) ? &#39;-&#39; : &#39;+&#39;;
4300     const char* kind = (_ex == 0x7FFF || _ex == (int16_t)-1) ? &quot;NaN&quot; : &quot;   &quot;;
4301     printf(&quot;%c%04hx.%08x%08x  %s&quot;, sign, _ex, _m1, _m0, kind);
4302   };
4303 
4304 };
4305 
4306 class FPU_State {
4307  public:
4308   enum {
4309     register_size       = 10,
4310     number_of_registers =  8,
4311     register_mask       =  7
4312   };
4313 
4314   ControlWord  _control_word;
4315   StatusWord   _status_word;
4316   TagWord      _tag_word;
4317   int32_t      _error_offset;
4318   int32_t      _error_selector;
4319   int32_t      _data_offset;
4320   int32_t      _data_selector;
4321   int8_t       _register[register_size * number_of_registers];
4322 
4323   int tag_for_st(int i) const          { return _tag_word.tag_at((_status_word.top() + i) &amp; register_mask); }
4324   FPU_Register* st(int i) const        { return (FPU_Register*)&amp;_register[register_size * i]; }
4325 
4326   const char* tag_as_string(int tag) const {
4327     switch (tag) {
4328       case 0: return &quot;valid&quot;;
4329       case 1: return &quot;zero&quot;;
4330       case 2: return &quot;special&quot;;
4331       case 3: return &quot;empty&quot;;
4332     }
4333     ShouldNotReachHere();
4334     return NULL;
4335   }
4336 
4337   void print() const {
4338     // print computation registers
4339     { int t = _status_word.top();
4340       for (int i = 0; i &lt; number_of_registers; i++) {
4341         int j = (i - t) &amp; register_mask;
4342         printf(&quot;%c r%d = ST%d = &quot;, (j == 0 ? &#39;*&#39; : &#39; &#39;), i, j);
4343         st(j)-&gt;print();
4344         printf(&quot; %s\n&quot;, tag_as_string(_tag_word.tag_at(i)));
4345       }
4346     }
4347     printf(&quot;\n&quot;);
4348     // print control registers
4349     printf(&quot;ctrl = &quot;); _control_word.print(); printf(&quot;\n&quot;);
4350     printf(&quot;stat = &quot;); _status_word .print(); printf(&quot;\n&quot;);
4351     printf(&quot;tags = &quot;); _tag_word    .print(); printf(&quot;\n&quot;);
4352   }
4353 
4354 };
4355 
4356 class Flag_Register {
4357  public:
4358   int32_t _value;
4359 
4360   bool overflow() const                { return ((_value &gt;&gt; 11) &amp; 1) != 0; }
4361   bool direction() const               { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
4362   bool sign() const                    { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
4363   bool zero() const                    { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
4364   bool auxiliary_carry() const         { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
4365   bool parity() const                  { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
4366   bool carry() const                   { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
4367 
4368   void print() const {
4369     // flags
4370     char f[8];
4371     f[0] = (overflow       ()) ? &#39;O&#39; : &#39;-&#39;;
4372     f[1] = (direction      ()) ? &#39;D&#39; : &#39;-&#39;;
4373     f[2] = (sign           ()) ? &#39;S&#39; : &#39;-&#39;;
4374     f[3] = (zero           ()) ? &#39;Z&#39; : &#39;-&#39;;
4375     f[4] = (auxiliary_carry()) ? &#39;A&#39; : &#39;-&#39;;
4376     f[5] = (parity         ()) ? &#39;P&#39; : &#39;-&#39;;
4377     f[6] = (carry          ()) ? &#39;C&#39; : &#39;-&#39;;
4378     f[7] = &#39;\x0&#39;;
4379     // output
4380     printf(&quot;%08x  flags = %s&quot;, _value, f);
4381   }
4382 
4383 };
4384 
4385 class IU_Register {
4386  public:
4387   int32_t _value;
4388 
4389   void print() const {
4390     printf(&quot;%08x  %11d&quot;, _value, _value);
4391   }
4392 
4393 };
4394 
4395 class IU_State {
4396  public:
4397   Flag_Register _eflags;
4398   IU_Register   _rdi;
4399   IU_Register   _rsi;
4400   IU_Register   _rbp;
4401   IU_Register   _rsp;
4402   IU_Register   _rbx;
4403   IU_Register   _rdx;
4404   IU_Register   _rcx;
4405   IU_Register   _rax;
4406 
4407   void print() const {
4408     // computation registers
4409     printf(&quot;rax,  = &quot;); _rax.print(); printf(&quot;\n&quot;);
4410     printf(&quot;rbx,  = &quot;); _rbx.print(); printf(&quot;\n&quot;);
4411     printf(&quot;rcx  = &quot;); _rcx.print(); printf(&quot;\n&quot;);
4412     printf(&quot;rdx  = &quot;); _rdx.print(); printf(&quot;\n&quot;);
4413     printf(&quot;rdi  = &quot;); _rdi.print(); printf(&quot;\n&quot;);
4414     printf(&quot;rsi  = &quot;); _rsi.print(); printf(&quot;\n&quot;);
4415     printf(&quot;rbp,  = &quot;); _rbp.print(); printf(&quot;\n&quot;);
4416     printf(&quot;rsp  = &quot;); _rsp.print(); printf(&quot;\n&quot;);
4417     printf(&quot;\n&quot;);
4418     // control registers
4419     printf(&quot;flgs = &quot;); _eflags.print(); printf(&quot;\n&quot;);
4420   }
4421 };
4422 
4423 
4424 class CPU_State {
4425  public:
4426   FPU_State _fpu_state;
4427   IU_State  _iu_state;
4428 
4429   void print() const {
4430     printf(&quot;--------------------------------------------------\n&quot;);
4431     _iu_state .print();
4432     printf(&quot;\n&quot;);
4433     _fpu_state.print();
4434     printf(&quot;--------------------------------------------------\n&quot;);
4435   }
4436 
4437 };
4438 
4439 
4440 static void _print_CPU_state(CPU_State* state) {
4441   state-&gt;print();
4442 };
4443 
4444 
4445 void MacroAssembler::print_CPU_state() {
4446   push_CPU_state();
4447   push(rsp);                // pass CPU state
4448   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _print_CPU_state)));
4449   addptr(rsp, wordSize);       // discard argument
4450   pop_CPU_state();
4451 }
4452 
4453 
4454 #ifndef _LP64
4455 static bool _verify_FPU(int stack_depth, char* s, CPU_State* state) {
4456   static int counter = 0;
4457   FPU_State* fs = &amp;state-&gt;_fpu_state;
4458   counter++;
4459   // For leaf calls, only verify that the top few elements remain empty.
4460   // We only need 1 empty at the top for C2 code.
4461   if( stack_depth &lt; 0 ) {
4462     if( fs-&gt;tag_for_st(7) != 3 ) {
4463       printf(&quot;FPR7 not empty\n&quot;);
4464       state-&gt;print();
4465       assert(false, &quot;error&quot;);
4466       return false;
4467     }
4468     return true;                // All other stack states do not matter
4469   }
4470 
4471   assert((fs-&gt;_control_word._value &amp; 0xffff) == StubRoutines::_fpu_cntrl_wrd_std,
4472          &quot;bad FPU control word&quot;);
4473 
4474   // compute stack depth
4475   int i = 0;
4476   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i)  &lt; 3) i++;
4477   int d = i;
4478   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i) == 3) i++;
4479   // verify findings
4480   if (i != FPU_State::number_of_registers) {
4481     // stack not contiguous
4482     printf(&quot;%s: stack not contiguous at ST%d\n&quot;, s, i);
4483     state-&gt;print();
4484     assert(false, &quot;error&quot;);
4485     return false;
4486   }
4487   // check if computed stack depth corresponds to expected stack depth
4488   if (stack_depth &lt; 0) {
4489     // expected stack depth is -stack_depth or less
4490     if (d &gt; -stack_depth) {
4491       // too many elements on the stack
4492       printf(&quot;%s: &lt;= %d stack elements expected but found %d\n&quot;, s, -stack_depth, d);
4493       state-&gt;print();
4494       assert(false, &quot;error&quot;);
4495       return false;
4496     }
4497   } else {
4498     // expected stack depth is stack_depth
4499     if (d != stack_depth) {
4500       // wrong stack depth
4501       printf(&quot;%s: %d stack elements expected but found %d\n&quot;, s, stack_depth, d);
4502       state-&gt;print();
4503       assert(false, &quot;error&quot;);
4504       return false;
4505     }
4506   }
4507   // everything is cool
4508   return true;
4509 }
4510 
4511 void MacroAssembler::verify_FPU(int stack_depth, const char* s) {
4512   if (!VerifyFPU) return;
4513   push_CPU_state();
4514   push(rsp);                // pass CPU state
4515   ExternalAddress msg((address) s);
4516   // pass message string s
4517   pushptr(msg.addr());
4518   push(stack_depth);        // pass stack depth
4519   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _verify_FPU)));
4520   addptr(rsp, 3 * wordSize);   // discard arguments
4521   // check for error
4522   { Label L;
4523     testl(rax, rax);
4524     jcc(Assembler::notZero, L);
4525     int3();                  // break if error condition
4526     bind(L);
4527   }
4528   pop_CPU_state();
4529 }
4530 #endif // _LP64
4531 
4532 void MacroAssembler::restore_cpu_control_state_after_jni() {
4533   // Either restore the MXCSR register after returning from the JNI Call
4534   // or verify that it wasn&#39;t changed (with -Xcheck:jni flag).
4535   if (VM_Version::supports_sse()) {
4536     if (RestoreMXCSROnJNICalls) {
4537       ldmxcsr(ExternalAddress(StubRoutines::addr_mxcsr_std()));
4538     } else if (CheckJNICalls) {
4539       call(RuntimeAddress(StubRoutines::x86::verify_mxcsr_entry()));
4540     }
4541   }
4542   // Clear upper bits of YMM registers to avoid SSE &lt;-&gt; AVX transition penalty.
4543   vzeroupper();
4544   // Reset k1 to 0xffff.
4545 
4546 #ifdef COMPILER2
4547   if (PostLoopMultiversioning &amp;&amp; VM_Version::supports_evex()) {
4548     push(rcx);
4549     movl(rcx, 0xffff);
4550     kmovwl(k1, rcx);
4551     pop(rcx);
4552   }
4553 #endif // COMPILER2
4554 
4555 #ifndef _LP64
4556   // Either restore the x87 floating pointer control word after returning
4557   // from the JNI call or verify that it wasn&#39;t changed.
4558   if (CheckJNICalls) {
4559     call(RuntimeAddress(StubRoutines::x86::verify_fpu_cntrl_wrd_entry()));
4560   }
4561 #endif // _LP64
4562 }
4563 
4564 // ((OopHandle)result).resolve();
4565 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
4566   assert_different_registers(result, tmp);
4567 
4568   // Only 64 bit platforms support GCs that require a tmp register
4569   // Only IN_HEAP loads require a thread_tmp register
4570   // OopHandle::resolve is an indirection like jobject.
4571   access_load_at(T_OBJECT, IN_NATIVE,
4572                  result, Address(result, 0), tmp, /*tmp_thread*/noreg);
4573 }
4574 
4575 // ((WeakHandle)result).resolve();
4576 void MacroAssembler::resolve_weak_handle(Register rresult, Register rtmp) {
4577   assert_different_registers(rresult, rtmp);
4578   Label resolved;
4579 
4580   // A null weak handle resolves to null.
4581   cmpptr(rresult, 0);
4582   jcc(Assembler::equal, resolved);
4583 
4584   // Only 64 bit platforms support GCs that require a tmp register
4585   // Only IN_HEAP loads require a thread_tmp register
4586   // WeakHandle::resolve is an indirection like jweak.
4587   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
4588                  rresult, Address(rresult, 0), rtmp, /*tmp_thread*/noreg);
4589   bind(resolved);
4590 }
4591 
4592 void MacroAssembler::load_mirror(Register mirror, Register method, Register tmp) {
4593   // get mirror
4594   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
4595   load_method_holder(mirror, method);
4596   movptr(mirror, Address(mirror, mirror_offset));
4597   resolve_oop_handle(mirror, tmp);
4598 }
4599 
4600 void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {
4601   load_method_holder(rresult, rmethod);
4602   movptr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));
4603 }
4604 
4605 void MacroAssembler::load_metadata(Register dst, Register src) {
4606   if (UseCompressedClassPointers) {
4607     movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));
4608   } else {
4609     movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
4610   }
4611 }
4612 
4613 void MacroAssembler::load_storage_props(Register dst, Register src) {
4614   load_metadata(dst, src);
4615   if (UseCompressedClassPointers) {
4616     shrl(dst, oopDesc::narrow_storage_props_shift);
4617   } else {
4618     shrq(dst, oopDesc::wide_storage_props_shift);
4619   }
4620 }
4621 
4622 void MacroAssembler::load_method_holder(Register holder, Register method) {
4623   movptr(holder, Address(method, Method::const_offset()));                      // ConstMethod*
4624   movptr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
4625   movptr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
4626 }
4627 
4628 void MacroAssembler::load_klass(Register dst, Register src) {
4629   load_metadata(dst, src);
4630 #ifdef _LP64
4631   if (UseCompressedClassPointers) {
4632     andl(dst, oopDesc::compressed_klass_mask());
4633     decode_klass_not_null(dst);
4634   } else
4635 #endif
4636   {
4637 #ifdef _LP64
4638     shlq(dst, oopDesc::storage_props_nof_bits);
4639     shrq(dst, oopDesc::storage_props_nof_bits);
4640 #else
4641     andl(dst, oopDesc::wide_klass_mask());
4642 #endif
4643   }
4644 }
4645 
4646 void MacroAssembler::load_prototype_header(Register dst, Register src) {
4647   load_klass(dst, src);
4648   movptr(dst, Address(dst, Klass::prototype_header_offset()));
4649 }
4650 
4651 void MacroAssembler::store_klass(Register dst, Register src) {
4652 #ifdef _LP64
4653   if (UseCompressedClassPointers) {
4654     encode_klass_not_null(src);
4655     movl(Address(dst, oopDesc::klass_offset_in_bytes()), src);
4656   } else
4657 #endif
4658     movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);
4659 }
4660 
4661 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
4662                                     Register tmp1, Register thread_tmp) {
4663   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4664   decorators = AccessInternal::decorator_fixup(decorators);
4665   bool as_raw = (decorators &amp; AS_RAW) != 0;
4666   if (as_raw) {
4667     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4668   } else {
4669     bs-&gt;load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4670   }
4671 }
4672 
4673 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
4674                                      Register tmp1, Register tmp2, Register tmp3) {
4675   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4676   decorators = AccessInternal::decorator_fixup(decorators);
4677   bool as_raw = (decorators &amp; AS_RAW) != 0;
4678   if (as_raw) {
4679     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);
4680   } else {
4681     bs-&gt;store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);
4682   }
4683 }
4684 
4685 void MacroAssembler::access_value_copy(DecoratorSet decorators, Register src, Register dst,
4686                                        Register value_klass) {
4687   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4688   bs-&gt;value_copy(this, decorators, src, dst, value_klass);
4689 }
4690 
4691 void MacroAssembler::first_field_offset(Register value_klass, Register offset) {
4692   movptr(offset, Address(value_klass, InstanceKlass::adr_valueklass_fixed_block_offset()));
4693   movl(offset, Address(offset, ValueKlass::first_field_offset_offset()));
4694 }
4695 
4696 void MacroAssembler::data_for_oop(Register oop, Register data, Register value_klass) {
4697   // ((address) (void*) o) + vk-&gt;first_field_offset();
4698   Register offset = (data == oop) ? rscratch1 : data;
4699   first_field_offset(value_klass, offset);
4700   if (data == oop) {
4701     addptr(data, offset);
4702   } else {
4703     lea(data, Address(oop, offset));
4704   }
4705 }
4706 
4707 void MacroAssembler::data_for_value_array_index(Register array, Register array_klass,
4708                                                 Register index, Register data) {
4709   assert(index != rcx, &quot;index needs to shift by rcx&quot;);
4710   assert_different_registers(array, array_klass, index);
4711   assert_different_registers(rcx, array, index);
4712 
4713   // array-&gt;base() + (index &lt;&lt; Klass::layout_helper_log2_element_size(lh));
4714   movl(rcx, Address(array_klass, Klass::layout_helper_offset()));
4715 
4716   // Klass::layout_helper_log2_element_size(lh)
4717   // (lh &gt;&gt; _lh_log2_element_size_shift) &amp; _lh_log2_element_size_mask;
4718   shrl(rcx, Klass::_lh_log2_element_size_shift);
4719   andl(rcx, Klass::_lh_log2_element_size_mask);
4720   shlptr(index); // index &lt;&lt; rcx
4721 
4722   lea(data, Address(array, index, Address::times_1, arrayOopDesc::base_offset_in_bytes(T_VALUETYPE)));
4723 }
4724 
4725 void MacroAssembler::resolve(DecoratorSet decorators, Register obj) {
4726   // Use stronger ACCESS_WRITE|ACCESS_READ by default.
4727   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {
4728     decorators |= ACCESS_READ | ACCESS_WRITE;
4729   }
4730   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4731   return bs-&gt;resolve(this, decorators, obj);
4732 }
4733 
4734 void MacroAssembler::load_heap_oop(Register dst, Address src, Register tmp1,
4735                                    Register thread_tmp, DecoratorSet decorators) {
4736   access_load_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);
4737 }
4738 
4739 // Doesn&#39;t do verfication, generates fixed size code
4740 void MacroAssembler::load_heap_oop_not_null(Register dst, Address src, Register tmp1,
4741                                             Register thread_tmp, DecoratorSet decorators) {
4742   access_load_at(T_OBJECT, IN_HEAP | IS_NOT_NULL | decorators, dst, src, tmp1, thread_tmp);
4743 }
4744 
4745 void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
4746                                     Register tmp2, Register tmp3, DecoratorSet decorators) {
4747   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2, tmp3);
4748 }
4749 
4750 // Used for storing NULLs.
4751 void MacroAssembler::store_heap_oop_null(Address dst) {
4752   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg, noreg);
4753 }
4754 
4755 #ifdef _LP64
4756 void MacroAssembler::store_klass_gap(Register dst, Register src) {
4757   if (UseCompressedClassPointers) {
4758     // Store to klass gap in destination
4759     movl(Address(dst, oopDesc::klass_gap_offset_in_bytes()), src);
4760   }
4761 }
4762 
4763 #ifdef ASSERT
4764 void MacroAssembler::verify_heapbase(const char* msg) {
4765   assert (UseCompressedOops, &quot;should be compressed&quot;);
4766   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4767   if (CheckCompressedOops) {
4768     Label ok;
4769     push(rscratch1); // cmpptr trashes rscratch1
4770     cmpptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
4771     jcc(Assembler::equal, ok);
4772     STOP(msg);
4773     bind(ok);
4774     pop(rscratch1);
4775   }
4776 }
4777 #endif
4778 
4779 // Algorithm must match oop.inline.hpp encode_heap_oop.
4780 void MacroAssembler::encode_heap_oop(Register r) {
4781 #ifdef ASSERT
4782   verify_heapbase(&quot;MacroAssembler::encode_heap_oop: heap base corrupted?&quot;);
4783 #endif
4784   verify_oop_msg(r, &quot;broken oop in encode_heap_oop&quot;);
4785   if (CompressedOops::base() == NULL) {
4786     if (CompressedOops::shift() != 0) {
4787       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4788       shrq(r, LogMinObjAlignmentInBytes);
4789     }
4790     return;
4791   }
4792   testq(r, r);
4793   cmovq(Assembler::equal, r, r12_heapbase);
4794   subq(r, r12_heapbase);
4795   shrq(r, LogMinObjAlignmentInBytes);
4796 }
4797 
4798 void MacroAssembler::encode_heap_oop_not_null(Register r) {
4799 #ifdef ASSERT
4800   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null: heap base corrupted?&quot;);
4801   if (CheckCompressedOops) {
4802     Label ok;
4803     testq(r, r);
4804     jcc(Assembler::notEqual, ok);
4805     STOP(&quot;null oop passed to encode_heap_oop_not_null&quot;);
4806     bind(ok);
4807   }
4808 #endif
4809   verify_oop_msg(r, &quot;broken oop in encode_heap_oop_not_null&quot;);
4810   if (CompressedOops::base() != NULL) {
4811     subq(r, r12_heapbase);
4812   }
4813   if (CompressedOops::shift() != 0) {
4814     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4815     shrq(r, LogMinObjAlignmentInBytes);
4816   }
4817 }
4818 
4819 void MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {
4820 #ifdef ASSERT
4821   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null2: heap base corrupted?&quot;);
4822   if (CheckCompressedOops) {
4823     Label ok;
4824     testq(src, src);
4825     jcc(Assembler::notEqual, ok);
4826     STOP(&quot;null oop passed to encode_heap_oop_not_null2&quot;);
4827     bind(ok);
4828   }
4829 #endif
4830   verify_oop_msg(src, &quot;broken oop in encode_heap_oop_not_null2&quot;);
4831   if (dst != src) {
4832     movq(dst, src);
4833   }
4834   if (CompressedOops::base() != NULL) {
4835     subq(dst, r12_heapbase);
4836   }
4837   if (CompressedOops::shift() != 0) {
4838     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4839     shrq(dst, LogMinObjAlignmentInBytes);
4840   }
4841 }
4842 
4843 void  MacroAssembler::decode_heap_oop(Register r) {
4844 #ifdef ASSERT
4845   verify_heapbase(&quot;MacroAssembler::decode_heap_oop: heap base corrupted?&quot;);
4846 #endif
4847   if (CompressedOops::base() == NULL) {
4848     if (CompressedOops::shift() != 0) {
4849       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4850       shlq(r, LogMinObjAlignmentInBytes);
4851     }
4852   } else {
4853     Label done;
4854     shlq(r, LogMinObjAlignmentInBytes);
4855     jccb(Assembler::equal, done);
4856     addq(r, r12_heapbase);
4857     bind(done);
4858   }
4859   verify_oop_msg(r, &quot;broken oop in decode_heap_oop&quot;);
4860 }
4861 
4862 void  MacroAssembler::decode_heap_oop_not_null(Register r) {
4863   // Note: it will change flags
4864   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4865   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4866   // Cannot assert, unverified entry point counts instructions (see .ad file)
4867   // vtableStubs also counts instructions in pd_code_size_limit.
4868   // Also do not verify_oop as this is called by verify_oop.
4869   if (CompressedOops::shift() != 0) {
4870     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4871     shlq(r, LogMinObjAlignmentInBytes);
4872     if (CompressedOops::base() != NULL) {
4873       addq(r, r12_heapbase);
4874     }
4875   } else {
4876     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
4877   }
4878 }
4879 
4880 void  MacroAssembler::decode_heap_oop_not_null(Register dst, Register src) {
4881   // Note: it will change flags
4882   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4883   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4884   // Cannot assert, unverified entry point counts instructions (see .ad file)
4885   // vtableStubs also counts instructions in pd_code_size_limit.
4886   // Also do not verify_oop as this is called by verify_oop.
4887   if (CompressedOops::shift() != 0) {
4888     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4889     if (LogMinObjAlignmentInBytes == Address::times_8) {
4890       leaq(dst, Address(r12_heapbase, src, Address::times_8, 0));
4891     } else {
4892       if (dst != src) {
4893         movq(dst, src);
4894       }
4895       shlq(dst, LogMinObjAlignmentInBytes);
4896       if (CompressedOops::base() != NULL) {
4897         addq(dst, r12_heapbase);
4898       }
4899     }
4900   } else {
4901     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
4902     if (dst != src) {
4903       movq(dst, src);
4904     }
4905   }
4906 }
4907 
4908 void MacroAssembler::encode_klass_not_null(Register r) {
4909   if (CompressedKlassPointers::base() != NULL) {
4910     // Use r12 as a scratch register in which to temporarily load the narrow_klass_base.
4911     assert(r != r12_heapbase, &quot;Encoding a klass in r12&quot;);
4912     mov64(r12_heapbase, (int64_t)CompressedKlassPointers::base());
4913     subq(r, r12_heapbase);
4914   }
4915   if (CompressedKlassPointers::shift() != 0) {
4916     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4917     shrq(r, LogKlassAlignmentInBytes);
4918   }
4919   if (CompressedKlassPointers::base() != NULL) {
4920     reinit_heapbase();
4921   }
4922 }
4923 
4924 void MacroAssembler::encode_klass_not_null(Register dst, Register src) {
4925   if (dst == src) {
4926     encode_klass_not_null(src);
4927   } else {
4928     if (CompressedKlassPointers::base() != NULL) {
4929       mov64(dst, (int64_t)CompressedKlassPointers::base());
4930       negq(dst);
4931       addq(dst, src);
4932     } else {
4933       movptr(dst, src);
4934     }
4935     if (CompressedKlassPointers::shift() != 0) {
4936       assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4937       shrq(dst, LogKlassAlignmentInBytes);
4938     }
4939   }
4940 }
4941 
4942 // Function instr_size_for_decode_klass_not_null() counts the instructions
4943 // generated by decode_klass_not_null(register r) and reinit_heapbase(),
4944 // when (Universe::heap() != NULL).  Hence, if the instructions they
4945 // generate change, then this method needs to be updated.
4946 int MacroAssembler::instr_size_for_decode_klass_not_null() {
4947   assert (UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
4948   if (CompressedKlassPointers::base() != NULL) {
4949     // mov64 + addq + shlq? + mov64  (for reinit_heapbase()).
4950     return (CompressedKlassPointers::shift() == 0 ? 20 : 24);
4951   } else {
4952     // longest load decode klass function, mov64, leaq
4953     return 16;
4954   }
4955 }
4956 
4957 // !!! If the instructions that get generated here change then function
4958 // instr_size_for_decode_klass_not_null() needs to get updated.
4959 void  MacroAssembler::decode_klass_not_null(Register r) {
4960   // Note: it will change flags
4961   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4962   assert(r != r12_heapbase, &quot;Decoding a klass in r12&quot;);
4963   // Cannot assert, unverified entry point counts instructions (see .ad file)
4964   // vtableStubs also counts instructions in pd_code_size_limit.
4965   // Also do not verify_oop as this is called by verify_oop.
4966   if (CompressedKlassPointers::shift() != 0) {
4967     assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4968     shlq(r, LogKlassAlignmentInBytes);
4969   }
4970   // Use r12 as a scratch register in which to temporarily load the narrow_klass_base.
4971   if (CompressedKlassPointers::base() != NULL) {
4972     mov64(r12_heapbase, (int64_t)CompressedKlassPointers::base());
4973     addq(r, r12_heapbase);
4974     reinit_heapbase();
4975   }
4976 }
4977 
4978 void  MacroAssembler::decode_klass_not_null(Register dst, Register src) {
4979   // Note: it will change flags
4980   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4981   if (dst == src) {
4982     decode_klass_not_null(dst);
4983   } else {
4984     // Cannot assert, unverified entry point counts instructions (see .ad file)
4985     // vtableStubs also counts instructions in pd_code_size_limit.
4986     // Also do not verify_oop as this is called by verify_oop.
4987     mov64(dst, (int64_t)CompressedKlassPointers::base());
4988     if (CompressedKlassPointers::shift() != 0) {
4989       assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4990       assert(LogKlassAlignmentInBytes == Address::times_8, &quot;klass not aligned on 64bits?&quot;);
4991       leaq(dst, Address(dst, src, Address::times_8, 0));
4992     } else {
4993       addq(dst, src);
4994     }
4995   }
4996 }
4997 
4998 void  MacroAssembler::set_narrow_oop(Register dst, jobject obj) {
4999   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
5000   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
5001   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5002   int oop_index = oop_recorder()-&gt;find_index(obj);
5003   RelocationHolder rspec = oop_Relocation::spec(oop_index);
5004   mov_narrow_oop(dst, oop_index, rspec);
5005 }
5006 
5007 void  MacroAssembler::set_narrow_oop(Address dst, jobject obj) {
5008   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
5009   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
5010   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5011   int oop_index = oop_recorder()-&gt;find_index(obj);
5012   RelocationHolder rspec = oop_Relocation::spec(oop_index);
5013   mov_narrow_oop(dst, oop_index, rspec);
5014 }
5015 
5016 void  MacroAssembler::set_narrow_klass(Register dst, Klass* k) {
5017   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
5018   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5019   int klass_index = oop_recorder()-&gt;find_index(k);
5020   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
5021   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
5022 }
5023 
5024 void  MacroAssembler::set_narrow_klass(Address dst, Klass* k) {
5025   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
5026   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5027   int klass_index = oop_recorder()-&gt;find_index(k);
5028   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
5029   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
5030 }
5031 
5032 void  MacroAssembler::cmp_narrow_oop(Register dst, jobject obj) {
5033   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
5034   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
5035   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5036   int oop_index = oop_recorder()-&gt;find_index(obj);
5037   RelocationHolder rspec = oop_Relocation::spec(oop_index);
5038   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
5039 }
5040 
5041 void  MacroAssembler::cmp_narrow_oop(Address dst, jobject obj) {
5042   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
5043   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
5044   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5045   int oop_index = oop_recorder()-&gt;find_index(obj);
5046   RelocationHolder rspec = oop_Relocation::spec(oop_index);
5047   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
5048 }
5049 
5050 void  MacroAssembler::cmp_narrow_klass(Register dst, Klass* k) {
5051   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
5052   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5053   int klass_index = oop_recorder()-&gt;find_index(k);
5054   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
5055   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
5056 }
5057 
5058 void  MacroAssembler::cmp_narrow_klass(Address dst, Klass* k) {
5059   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
5060   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5061   int klass_index = oop_recorder()-&gt;find_index(k);
5062   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
5063   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
5064 }
5065 
5066 void MacroAssembler::reinit_heapbase() {
5067   if (UseCompressedOops || UseCompressedClassPointers) {
5068     if (Universe::heap() != NULL) {
5069       if (CompressedOops::base() == NULL) {
5070         MacroAssembler::xorptr(r12_heapbase, r12_heapbase);
5071       } else {
5072         mov64(r12_heapbase, (int64_t)CompressedOops::ptrs_base());
5073       }
5074     } else {
5075       movptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
5076     }
5077   }
5078 }
5079 
5080 #endif // _LP64
5081 
5082 // C2 compiled method&#39;s prolog code.
5083 void MacroAssembler::verified_entry(Compile* C, int sp_inc) {
5084   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
5085   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
5086   bool fp_mode_24b = false;
5087   int stack_bang_size = C-&gt;output()-&gt;need_stack_bang(bangsize) ? bangsize : 0;
5088 
5089   // WARNING: Initial instruction MUST be 5 bytes or longer so that
5090   // NativeJump::patch_verified_entry will be able to patch out the entry
5091   // code safely. The push to verify stack depth is ok at 5 bytes,
5092   // the frame allocation can be either 3 or 6 bytes. So if we don&#39;t do
5093   // stack bang then we must use the 6 byte frame allocation even if
5094   // we have no frame. :-(
5095   assert(stack_bang_size &gt;= framesize || stack_bang_size &lt;= 0, &quot;stack bang size incorrect&quot;);
5096 
5097   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
5098   // Remove word for return addr
5099   framesize -= wordSize;
5100   stack_bang_size -= wordSize;
5101 
5102   // Calls to C2R adapters often do not accept exceptional returns.
5103   // We require that their callers must bang for them.  But be careful, because
5104   // some VM calls (such as call site linkage) can use several kilobytes of
5105   // stack.  But the stack safety zone should account for that.
5106   // See bugs 4446381, 4468289, 4497237.
5107   if (stack_bang_size &gt; 0) {
5108     generate_stack_overflow_check(stack_bang_size);
5109 
5110     // We always push rbp, so that on return to interpreter rbp, will be
5111     // restored correctly and we can correct the stack.
5112     push(rbp);
5113     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
5114     if (PreserveFramePointer) {
5115       mov(rbp, rsp);
5116     }
5117     // Remove word for ebp
5118     framesize -= wordSize;
5119 
5120     // Create frame
5121     if (framesize) {
5122       subptr(rsp, framesize);
5123     }
5124   } else {
5125     // Create frame (force generation of a 4 byte immediate value)
5126     subptr_imm32(rsp, framesize);
5127 
5128     // Save RBP register now.
5129     framesize -= wordSize;
5130     movptr(Address(rsp, framesize), rbp);
5131     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
5132     if (PreserveFramePointer) {
5133       movptr(rbp, rsp);
5134       if (framesize &gt; 0) {
5135         addptr(rbp, framesize);
5136       }
5137     }
5138   }
5139 
5140   if (C-&gt;needs_stack_repair()) {
5141     // Save stack increment (also account for fixed framesize and rbp)
5142     assert((sp_inc &amp; (StackAlignmentInBytes-1)) == 0, &quot;stack increment not aligned&quot;);
5143     movptr(Address(rsp, C-&gt;output()-&gt;sp_inc_offset()), sp_inc + framesize + wordSize);
5144   }
5145 
5146   if (VerifyStackAtCalls) { // Majik cookie to verify stack depth
5147     framesize -= wordSize;
5148     movptr(Address(rsp, framesize), (int32_t)0xbadb100d);
5149   }
5150 
5151 #ifndef _LP64
5152   // If method sets FPU control word do it now
5153   if (fp_mode_24b) {
5154     fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
5155   }
5156   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
5157     verify_FPU(0, &quot;FPU stack must be clean on entry&quot;);
5158   }
5159 #endif
5160 
5161 #ifdef ASSERT
5162   if (VerifyStackAtCalls) {
5163     Label L;
5164     push(rax);
5165     mov(rax, rsp);
5166     andptr(rax, StackAlignmentInBytes-1);
5167     cmpptr(rax, StackAlignmentInBytes-wordSize);
5168     pop(rax);
5169     jcc(Assembler::equal, L);
5170     STOP(&quot;Stack is not properly aligned!&quot;);
5171     bind(L);
5172   }
5173 #endif
5174 }
5175 
5176 // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
5177 void MacroAssembler::xmm_clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp) {
5178   // cnt - number of qwords (8-byte words).
5179   // base - start address, qword aligned.
5180   Label L_zero_64_bytes, L_loop, L_sloop, L_tail, L_end;
5181   movdq(xtmp, val);
5182   if (UseAVX &gt;= 2) {
5183     punpcklqdq(xtmp, xtmp);
5184     vinserti128_high(xtmp, xtmp);
5185   } else {
5186     punpcklqdq(xtmp, xtmp);
5187   }
5188   jmp(L_zero_64_bytes);
5189 
5190   BIND(L_loop);
5191   if (UseAVX &gt;= 2) {
5192     vmovdqu(Address(base,  0), xtmp);
5193     vmovdqu(Address(base, 32), xtmp);
5194   } else {
5195     movdqu(Address(base,  0), xtmp);
5196     movdqu(Address(base, 16), xtmp);
5197     movdqu(Address(base, 32), xtmp);
5198     movdqu(Address(base, 48), xtmp);
5199   }
5200   addptr(base, 64);
5201 
5202   BIND(L_zero_64_bytes);
5203   subptr(cnt, 8);
5204   jccb(Assembler::greaterEqual, L_loop);
5205   addptr(cnt, 4);
5206   jccb(Assembler::less, L_tail);
5207   // Copy trailing 32 bytes
5208   if (UseAVX &gt;= 2) {
5209     vmovdqu(Address(base, 0), xtmp);
5210   } else {
5211     movdqu(Address(base,  0), xtmp);
5212     movdqu(Address(base, 16), xtmp);
5213   }
5214   addptr(base, 32);
5215   subptr(cnt, 4);
5216 
5217   BIND(L_tail);
5218   addptr(cnt, 4);
5219   jccb(Assembler::lessEqual, L_end);
5220   decrement(cnt);
5221 
5222   BIND(L_sloop);
5223   movq(Address(base, 0), xtmp);
5224   addptr(base, 8);
5225   decrement(cnt);
5226   jccb(Assembler::greaterEqual, L_sloop);
5227   BIND(L_end);
5228 }
5229 
5230 int MacroAssembler::store_value_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter) {
5231   // A value type might be returned. If fields are in registers we
5232   // need to allocate a value type instance and initialize it with
5233   // the value of the fields.
5234   Label skip;
5235   // We only need a new buffered value if a new one is not returned
5236   testptr(rax, 1);
5237   jcc(Assembler::zero, skip);
5238   int call_offset = -1;
5239 
5240 #ifdef _LP64
5241   Label slow_case;
5242 
5243   // Try to allocate a new buffered value (from the heap)
5244   if (UseTLAB) {
5245     // FIXME -- for smaller code, the inline allocation (and the slow case) should be moved inside the pack handler.
5246     if (vk != NULL) {
5247       // Called from C1, where the return type is statically known.
5248       movptr(rbx, (intptr_t)vk-&gt;get_ValueKlass());
5249       jint lh = vk-&gt;layout_helper();
5250       assert(lh != Klass::_lh_neutral_value, &quot;inline class in return type must have been resolved&quot;);
5251       movl(r14, lh);
5252     } else {
5253       // Call from interpreter. RAX contains ((the ValueKlass* of the return type) | 0x01)
5254       mov(rbx, rax);
5255       andptr(rbx, -2);
5256       movl(r14, Address(rbx, Klass::layout_helper_offset()));
5257     }
5258 
5259     movptr(r13, Address(r15_thread, in_bytes(JavaThread::tlab_top_offset())));
5260     lea(r14, Address(r13, r14, Address::times_1));
5261     cmpptr(r14, Address(r15_thread, in_bytes(JavaThread::tlab_end_offset())));
5262     jcc(Assembler::above, slow_case);
5263     movptr(Address(r15_thread, in_bytes(JavaThread::tlab_top_offset())), r14);
5264     movptr(Address(r13, oopDesc::mark_offset_in_bytes()), (intptr_t)markWord::always_locked_prototype().value());
5265 
5266     xorl(rax, rax); // use zero reg to clear memory (shorter code)
5267     store_klass_gap(r13, rax);  // zero klass gap for compressed oops
5268 
5269     if (vk == NULL) {
5270       // store_klass corrupts rbx, so save it in rax for later use (interpreter case only).
5271       mov(rax, rbx);
5272     }
5273     store_klass(r13, rbx);  // klass
5274 
5275     // We have our new buffered value, initialize its fields with a
5276     // value class specific handler
5277     if (vk != NULL) {
5278       // FIXME -- do the packing in-line to avoid the runtime call
5279       mov(rax, r13);
5280       call(RuntimeAddress(vk-&gt;pack_handler())); // no need for call info as this will not safepoint.
5281     } else {
5282       movptr(rbx, Address(rax, InstanceKlass::adr_valueklass_fixed_block_offset()));
5283       movptr(rbx, Address(rbx, ValueKlass::pack_handler_offset()));
5284       mov(rax, r13);
5285       call(rbx);
5286     }
5287     jmp(skip);
5288   }
5289 
5290   bind(slow_case);
5291   // We failed to allocate a new value, fall back to a runtime
5292   // call. Some oop field may be live in some registers but we can&#39;t
5293   // tell. That runtime call will take care of preserving them
5294   // across a GC if there&#39;s one.
5295 #endif
5296 
5297   if (from_interpreter) {
5298     super_call_VM_leaf(StubRoutines::store_value_type_fields_to_buf());
5299   } else {
5300     call(RuntimeAddress(StubRoutines::store_value_type_fields_to_buf()));
5301     call_offset = offset();
5302   }
5303 
5304   bind(skip);
5305   return call_offset;
5306 }
5307 
5308 
5309 // Move a value between registers/stack slots and update the reg_state
5310 bool MacroAssembler::move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset) {
5311   if (reg_state[to-&gt;value()] == reg_written) {
5312     return true; // Already written
5313   }
5314   if (from != to &amp;&amp; bt != T_VOID) {
5315     if (reg_state[to-&gt;value()] == reg_readonly) {
5316       return false; // Not yet writable
5317     }
5318     if (from-&gt;is_reg()) {
5319       if (to-&gt;is_reg()) {
5320         if (from-&gt;is_XMMRegister()) {
5321           if (bt == T_DOUBLE) {
5322             movdbl(to-&gt;as_XMMRegister(), from-&gt;as_XMMRegister());
5323           } else {
5324             assert(bt == T_FLOAT, &quot;must be float&quot;);
5325             movflt(to-&gt;as_XMMRegister(), from-&gt;as_XMMRegister());
5326           }
5327         } else {
5328           movq(to-&gt;as_Register(), from-&gt;as_Register());
5329         }
5330       } else {
5331         int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5332         assert(st_off != ret_off, &quot;overwriting return address at %d&quot;, st_off);
5333         Address to_addr = Address(rsp, st_off);
5334         if (from-&gt;is_XMMRegister()) {
5335           if (bt == T_DOUBLE) {
5336             movdbl(to_addr, from-&gt;as_XMMRegister());
5337           } else {
5338             assert(bt == T_FLOAT, &quot;must be float&quot;);
5339             movflt(to_addr, from-&gt;as_XMMRegister());
5340           }
5341         } else {
5342           movq(to_addr, from-&gt;as_Register());
5343         }
5344       }
5345     } else {
5346       Address from_addr = Address(rsp, from-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset);
5347       if (to-&gt;is_reg()) {
5348         if (to-&gt;is_XMMRegister()) {
5349           if (bt == T_DOUBLE) {
5350             movdbl(to-&gt;as_XMMRegister(), from_addr);
5351           } else {
5352             assert(bt == T_FLOAT, &quot;must be float&quot;);
5353             movflt(to-&gt;as_XMMRegister(), from_addr);
5354           }
5355         } else {
5356           movq(to-&gt;as_Register(), from_addr);
5357         }
5358       } else {
5359         int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5360         assert(st_off != ret_off, &quot;overwriting return address at %d&quot;, st_off);
5361         movq(r13, from_addr);
5362         movq(Address(rsp, st_off), r13);
5363       }
5364     }
5365   }
5366   // Update register states
5367   reg_state[from-&gt;value()] = reg_writable;
5368   reg_state[to-&gt;value()] = reg_written;
5369   return true;
5370 }
5371 
5372 // Read all fields from a value type oop and store the values in registers/stack slots
5373 bool MacroAssembler::unpack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to,
5374                                          int&amp; to_index, RegState reg_state[], int ret_off, int extra_stack_offset) {
5375   Register fromReg = from-&gt;is_reg() ? from-&gt;as_Register() : noreg;
5376   assert(sig-&gt;at(sig_index)._bt == T_VOID, &quot;should be at end delimiter&quot;);
5377 
5378   int vt = 1;
5379   bool done = true;
5380   bool mark_done = true;
5381   do {
5382     sig_index--;
5383     BasicType bt = sig-&gt;at(sig_index)._bt;
5384     if (bt == T_VALUETYPE) {
5385       vt--;
5386     } else if (bt == T_VOID &amp;&amp;
5387                sig-&gt;at(sig_index-1)._bt != T_LONG &amp;&amp;
5388                sig-&gt;at(sig_index-1)._bt != T_DOUBLE) {
5389       vt++;
5390     } else if (SigEntry::is_reserved_entry(sig, sig_index)) {
5391       to_index--; // Ignore this
5392     } else {
5393       assert(to_index &gt;= 0, &quot;invalid to_index&quot;);
5394       VMRegPair pair_to = regs_to[to_index--];
5395       VMReg to = pair_to.first();
5396 
5397       if (bt == T_VOID) continue;
5398 
5399       int idx = (int)to-&gt;value();
5400       if (reg_state[idx] == reg_readonly) {
5401          if (idx != from-&gt;value()) {
5402            mark_done = false;
5403          }
5404          done = false;
5405          continue;
5406       } else if (reg_state[idx] == reg_written) {
5407         continue;
5408       } else {
5409         assert(reg_state[idx] == reg_writable, &quot;must be writable&quot;);
5410         reg_state[idx] = reg_written;
5411        }
5412 
5413       if (fromReg == noreg) {
5414         int st_off = from-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5415         movq(r10, Address(rsp, st_off));
5416         fromReg = r10;
5417       }
5418 
5419       int off = sig-&gt;at(sig_index)._offset;
5420       assert(off &gt; 0, &quot;offset in object should be positive&quot;);
5421       bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);
5422 
5423       Address fromAddr = Address(fromReg, off);
5424       bool is_signed = (bt != T_CHAR) &amp;&amp; (bt != T_BOOLEAN);
5425       if (!to-&gt;is_XMMRegister()) {
5426         Register dst = to-&gt;is_stack() ? r13 : to-&gt;as_Register();
5427         if (is_oop) {
5428           load_heap_oop(dst, fromAddr);
5429         } else {
5430           load_sized_value(dst, fromAddr, type2aelembytes(bt), is_signed);
5431         }
5432         if (to-&gt;is_stack()) {
5433           int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5434           assert(st_off != ret_off, &quot;overwriting return address at %d&quot;, st_off);
5435           movq(Address(rsp, st_off), dst);
5436         }
5437       } else {
5438         if (bt == T_DOUBLE) {
5439           movdbl(to-&gt;as_XMMRegister(), fromAddr);
5440         } else {
5441           assert(bt == T_FLOAT, &quot;must be float&quot;);
5442           movflt(to-&gt;as_XMMRegister(), fromAddr);
5443         }
5444       }
5445     }
5446   } while (vt != 0);
5447   if (mark_done &amp;&amp; reg_state[from-&gt;value()] != reg_written) {
5448     // This is okay because no one else will write to that slot
5449     reg_state[from-&gt;value()] = reg_writable;
5450   }
5451   return done;
5452 }
5453 
5454 // Pack fields back into a value type oop
5455 bool MacroAssembler::pack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,
5456                                        VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],
5457                                        int ret_off, int extra_stack_offset) {
5458   assert(sig-&gt;at(sig_index)._bt == T_VALUETYPE, &quot;should be at end delimiter&quot;);
5459   assert(to-&gt;is_valid(), &quot;must be&quot;);
5460 
5461   if (reg_state[to-&gt;value()] == reg_written) {
5462     skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);
5463     return true; // Already written
5464   }
5465 
5466   Register val_array = rax;
5467   Register val_obj_tmp = r11;
5468   Register from_reg_tmp = r14; // Be careful with r14 because it&#39;s used for spilling
5469   Register tmp1 = r10;
5470   Register tmp2 = r13;
5471   Register tmp3 = rbx;
5472   Register val_obj = to-&gt;is_stack() ? val_obj_tmp : to-&gt;as_Register();
5473 
5474   if (reg_state[to-&gt;value()] == reg_readonly) {
5475     if (!is_reg_in_unpacked_fields(sig, sig_index, to, regs_from, regs_from_count, from_index)) {
5476       skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);
5477       return false; // Not yet writable
5478     }
5479     val_obj = val_obj_tmp;
5480   }
5481 
5482   int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + vtarg_index * type2aelembytes(T_VALUETYPE);
5483   load_heap_oop(val_obj, Address(val_array, index));
5484 
5485   ScalarizedValueArgsStream stream(sig, sig_index, regs_from, regs_from_count, from_index);
5486   VMRegPair from_pair;
5487   BasicType bt;
5488   while (stream.next(from_pair, bt)) {
5489     int off = sig-&gt;at(stream.sig_cc_index())._offset;
5490     assert(off &gt; 0, &quot;offset in object should be positive&quot;);
5491     bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);
5492     size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;
5493 
5494     VMReg from_r1 = from_pair.first();
5495     VMReg from_r2 = from_pair.second();
5496 
5497     // Pack the scalarized field into the value object.
5498     Address dst(val_obj, off);
5499     if (!from_r1-&gt;is_XMMRegister()) {
5500       Register from_reg;
5501       if (from_r1-&gt;is_stack()) {
5502         from_reg = from_reg_tmp;
5503         int ld_off = from_r1-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5504         load_sized_value(from_reg, Address(rsp, ld_off), size_in_bytes, /* is_signed */ false);
5505       } else {
5506         from_reg = from_r1-&gt;as_Register();
5507       }
5508       assert_different_registers(dst.base(), from_reg, tmp1, tmp2, tmp3, val_array);
5509       if (is_oop) {
5510         store_heap_oop(dst, from_reg, tmp1, tmp2, tmp3, IN_HEAP | ACCESS_WRITE | IS_DEST_UNINITIALIZED);
5511       } else {
5512         store_sized_value(dst, from_reg, size_in_bytes);
5513       }
5514     } else {
5515       if (from_r2-&gt;is_valid()) {
5516         movdbl(dst, from_r1-&gt;as_XMMRegister());
5517       } else {
5518         movflt(dst, from_r1-&gt;as_XMMRegister());
5519       }
5520     }
5521     reg_state[from_r1-&gt;value()] = reg_writable;
5522   }
5523   sig_index = stream.sig_cc_index();
5524   from_index = stream.regs_cc_index();
5525 
5526   assert(reg_state[to-&gt;value()] == reg_writable, &quot;must have already been read&quot;);
5527   bool success = move_helper(val_obj-&gt;as_VMReg(), to, T_OBJECT, reg_state, ret_off, extra_stack_offset);
5528   assert(success, &quot;to register must be writeable&quot;);
5529 
5530   return true;
5531 }
5532 
5533 // Unpack all value type arguments passed as oops
5534 void MacroAssembler::unpack_value_args(Compile* C, bool receiver_only) {
5535   int sp_inc = unpack_value_args_common(C, receiver_only);
5536   // Emit code for verified entry and save increment for stack repair on return
5537   verified_entry(C, sp_inc);
5538 }
5539 
5540 void MacroAssembler::shuffle_value_args(bool is_packing, bool receiver_only, int extra_stack_offset,
5541                                         BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,
5542                                         int args_passed, int args_on_stack, VMRegPair* regs,
5543                                         int args_passed_to, int args_on_stack_to, VMRegPair* regs_to, int sp_inc) {
5544   // Check if we need to extend the stack for packing/unpacking
5545   if (sp_inc &gt; 0 &amp;&amp; !is_packing) {
5546     // Save the return address, adjust the stack (make sure it is properly
5547     // 16-byte aligned) and copy the return address to the new top of the stack.
5548     // (Note: C1 does this in C1_MacroAssembler::scalarized_entry).
5549     pop(r13);
5550     subptr(rsp, sp_inc);
5551     push(r13);
5552   }
5553 
5554   int ret_off; // make sure we don&#39;t overwrite the return address
5555   if (is_packing) {
5556     // For C1 code, the VVEP doesn&#39;t have reserved slots, so we store the returned address at
5557     // rsp[0] during shuffling.
5558     ret_off = 0;
5559   } else {
5560     // C2 code ensures that sp_inc is a reserved slot.
5561     ret_off = sp_inc;
5562   }
5563 
5564   shuffle_value_args_common(is_packing, receiver_only, extra_stack_offset,
5565                             sig_bt, sig_cc,
5566                             args_passed, args_on_stack, regs,
5567                             args_passed_to, args_on_stack_to, regs_to,
5568                             sp_inc, ret_off);
5569 }
5570 
5571 VMReg MacroAssembler::spill_reg_for(VMReg reg) {
5572   return reg-&gt;is_XMMRegister() ? xmm8-&gt;as_VMReg() : r14-&gt;as_VMReg();
5573 }
5574 
5575 void MacroAssembler::remove_frame(int initial_framesize, bool needs_stack_repair, int sp_inc_offset) {
5576   assert((initial_framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
5577   if (needs_stack_repair) {
5578     movq(rbp, Address(rsp, initial_framesize));
5579     addq(rsp, Address(rsp, sp_inc_offset));
5580   } else {
5581     if (initial_framesize &gt; 0) {
5582       addq(rsp, initial_framesize);
5583     }
5584     pop(rbp);
5585   }
5586 }
5587 
5588 void MacroAssembler::clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only) {
5589   // cnt - number of qwords (8-byte words).
5590   // base - start address, qword aligned.
5591   // is_large - if optimizers know cnt is larger than InitArrayShortSize
5592   assert(base==rdi, &quot;base register must be edi for rep stos&quot;);
5593   assert(val==rax,   &quot;tmp register must be eax for rep stos&quot;);
5594   assert(cnt==rcx,   &quot;cnt register must be ecx for rep stos&quot;);
5595   assert(InitArrayShortSize % BytesPerLong == 0,
5596     &quot;InitArrayShortSize should be the multiple of BytesPerLong&quot;);
5597 
5598   Label DONE;
5599 
5600   if (!is_large) {
5601     Label LOOP, LONG;
5602     cmpptr(cnt, InitArrayShortSize/BytesPerLong);
5603     jccb(Assembler::greater, LONG);
5604 
5605     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
5606 
5607     decrement(cnt);
5608     jccb(Assembler::negative, DONE); // Zero length
5609 
5610     // Use individual pointer-sized stores for small counts:
5611     BIND(LOOP);
5612     movptr(Address(base, cnt, Address::times_ptr), val);
5613     decrement(cnt);
5614     jccb(Assembler::greaterEqual, LOOP);
5615     jmpb(DONE);
5616 
5617     BIND(LONG);
5618   }
5619 
5620   // Use longer rep-prefixed ops for non-small counts:
5621   if (UseFastStosb &amp;&amp; !word_copy_only) {
5622     shlptr(cnt, 3); // convert to number of bytes
5623     rep_stosb();
5624   } else if (UseXMMForObjInit) {
5625     xmm_clear_mem(base, cnt, val, xtmp);
5626   } else {
5627     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
5628     rep_stos();
5629   }
5630 
5631   BIND(DONE);
5632 }
5633 
5634 void MacroAssembler::generate_fill(BasicType t, bool aligned,
5635                                    Register to, Register value, Register count,
5636                                    Register rtmp, XMMRegister xtmp) {
5637   ShortBranchVerifier sbv(this);
5638   assert_different_registers(to, value, count, rtmp);
5639   Label L_exit;
5640   Label L_fill_2_bytes, L_fill_4_bytes;
5641 
5642   int shift = -1;
5643   switch (t) {
5644     case T_BYTE:
5645       shift = 2;
5646       break;
5647     case T_SHORT:
5648       shift = 1;
5649       break;
5650     case T_INT:
5651       shift = 0;
5652       break;
5653     default: ShouldNotReachHere();
5654   }
5655 
5656   if (t == T_BYTE) {
5657     andl(value, 0xff);
5658     movl(rtmp, value);
5659     shll(rtmp, 8);
5660     orl(value, rtmp);
5661   }
5662   if (t == T_SHORT) {
5663     andl(value, 0xffff);
5664   }
5665   if (t == T_BYTE || t == T_SHORT) {
5666     movl(rtmp, value);
5667     shll(rtmp, 16);
5668     orl(value, rtmp);
5669   }
5670 
5671   cmpl(count, 2&lt;&lt;shift); // Short arrays (&lt; 8 bytes) fill by element
5672   jcc(Assembler::below, L_fill_4_bytes); // use unsigned cmp
5673   if (!UseUnalignedLoadStores &amp;&amp; !aligned &amp;&amp; (t == T_BYTE || t == T_SHORT)) {
5674     Label L_skip_align2;
5675     // align source address at 4 bytes address boundary
5676     if (t == T_BYTE) {
5677       Label L_skip_align1;
5678       // One byte misalignment happens only for byte arrays
5679       testptr(to, 1);
5680       jccb(Assembler::zero, L_skip_align1);
5681       movb(Address(to, 0), value);
5682       increment(to);
5683       decrement(count);
5684       BIND(L_skip_align1);
5685     }
5686     // Two bytes misalignment happens only for byte and short (char) arrays
5687     testptr(to, 2);
5688     jccb(Assembler::zero, L_skip_align2);
5689     movw(Address(to, 0), value);
5690     addptr(to, 2);
5691     subl(count, 1&lt;&lt;(shift-1));
5692     BIND(L_skip_align2);
5693   }
5694   if (UseSSE &lt; 2) {
5695     Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
5696     // Fill 32-byte chunks
5697     subl(count, 8 &lt;&lt; shift);
5698     jcc(Assembler::less, L_check_fill_8_bytes);
5699     align(16);
5700 
5701     BIND(L_fill_32_bytes_loop);
5702 
5703     for (int i = 0; i &lt; 32; i += 4) {
5704       movl(Address(to, i), value);
5705     }
5706 
5707     addptr(to, 32);
5708     subl(count, 8 &lt;&lt; shift);
5709     jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
5710     BIND(L_check_fill_8_bytes);
5711     addl(count, 8 &lt;&lt; shift);
5712     jccb(Assembler::zero, L_exit);
5713     jmpb(L_fill_8_bytes);
5714 
5715     //
5716     // length is too short, just fill qwords
5717     //
5718     BIND(L_fill_8_bytes_loop);
5719     movl(Address(to, 0), value);
5720     movl(Address(to, 4), value);
5721     addptr(to, 8);
5722     BIND(L_fill_8_bytes);
5723     subl(count, 1 &lt;&lt; (shift + 1));
5724     jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
5725     // fall through to fill 4 bytes
5726   } else {
5727     Label L_fill_32_bytes;
5728     if (!UseUnalignedLoadStores) {
5729       // align to 8 bytes, we know we are 4 byte aligned to start
5730       testptr(to, 4);
5731       jccb(Assembler::zero, L_fill_32_bytes);
5732       movl(Address(to, 0), value);
5733       addptr(to, 4);
5734       subl(count, 1&lt;&lt;shift);
5735     }
5736     BIND(L_fill_32_bytes);
5737     {
5738       assert( UseSSE &gt;= 2, &quot;supported cpu only&quot; );
5739       Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
5740       movdl(xtmp, value);
5741       if (UseAVX &gt;= 2 &amp;&amp; UseUnalignedLoadStores) {
5742         Label L_check_fill_32_bytes;
5743         if (UseAVX &gt; 2) {
5744           // Fill 64-byte chunks
5745           Label L_fill_64_bytes_loop_avx3, L_check_fill_64_bytes_avx2;
5746 
5747           // If number of bytes to fill &lt; AVX3Threshold, perform fill using AVX2
5748           cmpl(count, AVX3Threshold);
5749           jccb(Assembler::below, L_check_fill_64_bytes_avx2);
5750 
5751           vpbroadcastd(xtmp, xtmp, Assembler::AVX_512bit);
5752 
5753           subl(count, 16 &lt;&lt; shift);
5754           jccb(Assembler::less, L_check_fill_32_bytes);
5755           align(16);
5756 
5757           BIND(L_fill_64_bytes_loop_avx3);
5758           evmovdqul(Address(to, 0), xtmp, Assembler::AVX_512bit);
5759           addptr(to, 64);
5760           subl(count, 16 &lt;&lt; shift);
5761           jcc(Assembler::greaterEqual, L_fill_64_bytes_loop_avx3);
5762           jmpb(L_check_fill_32_bytes);
5763 
5764           BIND(L_check_fill_64_bytes_avx2);
5765         }
5766         // Fill 64-byte chunks
5767         Label L_fill_64_bytes_loop;
5768         vpbroadcastd(xtmp, xtmp, Assembler::AVX_256bit);
5769 
5770         subl(count, 16 &lt;&lt; shift);
5771         jcc(Assembler::less, L_check_fill_32_bytes);
5772         align(16);
5773 
5774         BIND(L_fill_64_bytes_loop);
5775         vmovdqu(Address(to, 0), xtmp);
5776         vmovdqu(Address(to, 32), xtmp);
5777         addptr(to, 64);
5778         subl(count, 16 &lt;&lt; shift);
5779         jcc(Assembler::greaterEqual, L_fill_64_bytes_loop);
5780 
5781         BIND(L_check_fill_32_bytes);
5782         addl(count, 8 &lt;&lt; shift);
5783         jccb(Assembler::less, L_check_fill_8_bytes);
5784         vmovdqu(Address(to, 0), xtmp);
5785         addptr(to, 32);
5786         subl(count, 8 &lt;&lt; shift);
5787 
5788         BIND(L_check_fill_8_bytes);
5789         // clean upper bits of YMM registers
5790         movdl(xtmp, value);
5791         pshufd(xtmp, xtmp, 0);
5792       } else {
5793         // Fill 32-byte chunks
5794         pshufd(xtmp, xtmp, 0);
5795 
5796         subl(count, 8 &lt;&lt; shift);
5797         jcc(Assembler::less, L_check_fill_8_bytes);
5798         align(16);
5799 
5800         BIND(L_fill_32_bytes_loop);
5801 
5802         if (UseUnalignedLoadStores) {
5803           movdqu(Address(to, 0), xtmp);
5804           movdqu(Address(to, 16), xtmp);
5805         } else {
5806           movq(Address(to, 0), xtmp);
5807           movq(Address(to, 8), xtmp);
5808           movq(Address(to, 16), xtmp);
5809           movq(Address(to, 24), xtmp);
5810         }
5811 
5812         addptr(to, 32);
5813         subl(count, 8 &lt;&lt; shift);
5814         jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
5815 
5816         BIND(L_check_fill_8_bytes);
5817       }
5818       addl(count, 8 &lt;&lt; shift);
5819       jccb(Assembler::zero, L_exit);
5820       jmpb(L_fill_8_bytes);
5821 
5822       //
5823       // length is too short, just fill qwords
5824       //
5825       BIND(L_fill_8_bytes_loop);
5826       movq(Address(to, 0), xtmp);
5827       addptr(to, 8);
5828       BIND(L_fill_8_bytes);
5829       subl(count, 1 &lt;&lt; (shift + 1));
5830       jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
5831     }
5832   }
5833   // fill trailing 4 bytes
5834   BIND(L_fill_4_bytes);
5835   testl(count, 1&lt;&lt;shift);
5836   jccb(Assembler::zero, L_fill_2_bytes);
5837   movl(Address(to, 0), value);
5838   if (t == T_BYTE || t == T_SHORT) {
5839     Label L_fill_byte;
5840     addptr(to, 4);
5841     BIND(L_fill_2_bytes);
5842     // fill trailing 2 bytes
5843     testl(count, 1&lt;&lt;(shift-1));
5844     jccb(Assembler::zero, L_fill_byte);
5845     movw(Address(to, 0), value);
5846     if (t == T_BYTE) {
5847       addptr(to, 2);
5848       BIND(L_fill_byte);
5849       // fill trailing byte
5850       testl(count, 1);
5851       jccb(Assembler::zero, L_exit);
5852       movb(Address(to, 0), value);
5853     } else {
5854       BIND(L_fill_byte);
5855     }
5856   } else {
5857     BIND(L_fill_2_bytes);
5858   }
5859   BIND(L_exit);
5860 }
5861 
5862 // encode char[] to byte[] in ISO_8859_1
5863    //@HotSpotIntrinsicCandidate
5864    //private static int implEncodeISOArray(byte[] sa, int sp,
5865    //byte[] da, int dp, int len) {
5866    //  int i = 0;
5867    //  for (; i &lt; len; i++) {
5868    //    char c = StringUTF16.getChar(sa, sp++);
5869    //    if (c &gt; &#39;\u00FF&#39;)
5870    //      break;
5871    //    da[dp++] = (byte)c;
5872    //  }
5873    //  return i;
5874    //}
5875 void MacroAssembler::encode_iso_array(Register src, Register dst, Register len,
5876   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
5877   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
5878   Register tmp5, Register result) {
5879 
5880   // rsi: src
5881   // rdi: dst
5882   // rdx: len
5883   // rcx: tmp5
5884   // rax: result
5885   ShortBranchVerifier sbv(this);
5886   assert_different_registers(src, dst, len, tmp5, result);
5887   Label L_done, L_copy_1_char, L_copy_1_char_exit;
5888 
5889   // set result
5890   xorl(result, result);
5891   // check for zero length
5892   testl(len, len);
5893   jcc(Assembler::zero, L_done);
5894 
5895   movl(result, len);
5896 
5897   // Setup pointers
5898   lea(src, Address(src, len, Address::times_2)); // char[]
5899   lea(dst, Address(dst, len, Address::times_1)); // byte[]
5900   negptr(len);
5901 
5902   if (UseSSE42Intrinsics || UseAVX &gt;= 2) {
5903     Label L_copy_8_chars, L_copy_8_chars_exit;
5904     Label L_chars_16_check, L_copy_16_chars, L_copy_16_chars_exit;
5905 
5906     if (UseAVX &gt;= 2) {
5907       Label L_chars_32_check, L_copy_32_chars, L_copy_32_chars_exit;
5908       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
5909       movdl(tmp1Reg, tmp5);
5910       vpbroadcastd(tmp1Reg, tmp1Reg, Assembler::AVX_256bit);
5911       jmp(L_chars_32_check);
5912 
5913       bind(L_copy_32_chars);
5914       vmovdqu(tmp3Reg, Address(src, len, Address::times_2, -64));
5915       vmovdqu(tmp4Reg, Address(src, len, Address::times_2, -32));
5916       vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
5917       vptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
5918       jccb(Assembler::notZero, L_copy_32_chars_exit);
5919       vpackuswb(tmp3Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
5920       vpermq(tmp4Reg, tmp3Reg, 0xD8, /* vector_len */ 1);
5921       vmovdqu(Address(dst, len, Address::times_1, -32), tmp4Reg);
5922 
5923       bind(L_chars_32_check);
5924       addptr(len, 32);
5925       jcc(Assembler::lessEqual, L_copy_32_chars);
5926 
5927       bind(L_copy_32_chars_exit);
5928       subptr(len, 16);
5929       jccb(Assembler::greater, L_copy_16_chars_exit);
5930 
5931     } else if (UseSSE42Intrinsics) {
5932       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
5933       movdl(tmp1Reg, tmp5);
5934       pshufd(tmp1Reg, tmp1Reg, 0);
5935       jmpb(L_chars_16_check);
5936     }
5937 
5938     bind(L_copy_16_chars);
5939     if (UseAVX &gt;= 2) {
5940       vmovdqu(tmp2Reg, Address(src, len, Address::times_2, -32));
5941       vptest(tmp2Reg, tmp1Reg);
5942       jcc(Assembler::notZero, L_copy_16_chars_exit);
5943       vpackuswb(tmp2Reg, tmp2Reg, tmp1Reg, /* vector_len */ 1);
5944       vpermq(tmp3Reg, tmp2Reg, 0xD8, /* vector_len */ 1);
5945     } else {
5946       if (UseAVX &gt; 0) {
5947         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
5948         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
5949         vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 0);
5950       } else {
5951         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
5952         por(tmp2Reg, tmp3Reg);
5953         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
5954         por(tmp2Reg, tmp4Reg);
5955       }
5956       ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
5957       jccb(Assembler::notZero, L_copy_16_chars_exit);
5958       packuswb(tmp3Reg, tmp4Reg);
5959     }
5960     movdqu(Address(dst, len, Address::times_1, -16), tmp3Reg);
5961 
5962     bind(L_chars_16_check);
5963     addptr(len, 16);
5964     jcc(Assembler::lessEqual, L_copy_16_chars);
5965 
5966     bind(L_copy_16_chars_exit);
5967     if (UseAVX &gt;= 2) {
5968       // clean upper bits of YMM registers
5969       vpxor(tmp2Reg, tmp2Reg);
5970       vpxor(tmp3Reg, tmp3Reg);
5971       vpxor(tmp4Reg, tmp4Reg);
5972       movdl(tmp1Reg, tmp5);
5973       pshufd(tmp1Reg, tmp1Reg, 0);
5974     }
5975     subptr(len, 8);
5976     jccb(Assembler::greater, L_copy_8_chars_exit);
5977 
5978     bind(L_copy_8_chars);
5979     movdqu(tmp3Reg, Address(src, len, Address::times_2, -16));
5980     ptest(tmp3Reg, tmp1Reg);
5981     jccb(Assembler::notZero, L_copy_8_chars_exit);
5982     packuswb(tmp3Reg, tmp1Reg);
5983     movq(Address(dst, len, Address::times_1, -8), tmp3Reg);
5984     addptr(len, 8);
5985     jccb(Assembler::lessEqual, L_copy_8_chars);
5986 
5987     bind(L_copy_8_chars_exit);
5988     subptr(len, 8);
5989     jccb(Assembler::zero, L_done);
5990   }
5991 
5992   bind(L_copy_1_char);
5993   load_unsigned_short(tmp5, Address(src, len, Address::times_2, 0));
5994   testl(tmp5, 0xff00);      // check if Unicode char
5995   jccb(Assembler::notZero, L_copy_1_char_exit);
5996   movb(Address(dst, len, Address::times_1, 0), tmp5);
5997   addptr(len, 1);
5998   jccb(Assembler::less, L_copy_1_char);
5999 
6000   bind(L_copy_1_char_exit);
6001   addptr(result, len); // len is negative count of not processed elements
6002 
6003   bind(L_done);
6004 }
6005 
6006 #ifdef _LP64
6007 /**
6008  * Helper for multiply_to_len().
6009  */
6010 void MacroAssembler::add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2) {
6011   addq(dest_lo, src1);
6012   adcq(dest_hi, 0);
6013   addq(dest_lo, src2);
6014   adcq(dest_hi, 0);
6015 }
6016 
6017 /**
6018  * Multiply 64 bit by 64 bit first loop.
6019  */
6020 void MacroAssembler::multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
6021                                            Register y, Register y_idx, Register z,
6022                                            Register carry, Register product,
6023                                            Register idx, Register kdx) {
6024   //
6025   //  jlong carry, x[], y[], z[];
6026   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
6027   //    huge_128 product = y[idx] * x[xstart] + carry;
6028   //    z[kdx] = (jlong)product;
6029   //    carry  = (jlong)(product &gt;&gt;&gt; 64);
6030   //  }
6031   //  z[xstart] = carry;
6032   //
6033 
6034   Label L_first_loop, L_first_loop_exit;
6035   Label L_one_x, L_one_y, L_multiply;
6036 
6037   decrementl(xstart);
6038   jcc(Assembler::negative, L_one_x);
6039 
6040   movq(x_xstart, Address(x, xstart, Address::times_4,  0));
6041   rorq(x_xstart, 32); // convert big-endian to little-endian
6042 
6043   bind(L_first_loop);
6044   decrementl(idx);
6045   jcc(Assembler::negative, L_first_loop_exit);
6046   decrementl(idx);
6047   jcc(Assembler::negative, L_one_y);
6048   movq(y_idx, Address(y, idx, Address::times_4,  0));
6049   rorq(y_idx, 32); // convert big-endian to little-endian
6050   bind(L_multiply);
6051   movq(product, x_xstart);
6052   mulq(y_idx); // product(rax) * y_idx -&gt; rdx:rax
6053   addq(product, carry);
6054   adcq(rdx, 0);
6055   subl(kdx, 2);
6056   movl(Address(z, kdx, Address::times_4,  4), product);
6057   shrq(product, 32);
6058   movl(Address(z, kdx, Address::times_4,  0), product);
6059   movq(carry, rdx);
6060   jmp(L_first_loop);
6061 
6062   bind(L_one_y);
6063   movl(y_idx, Address(y,  0));
6064   jmp(L_multiply);
6065 
6066   bind(L_one_x);
6067   movl(x_xstart, Address(x,  0));
6068   jmp(L_first_loop);
6069 
6070   bind(L_first_loop_exit);
6071 }
6072 
6073 /**
6074  * Multiply 64 bit by 64 bit and add 128 bit.
6075  */
6076 void MacroAssembler::multiply_add_128_x_128(Register x_xstart, Register y, Register z,
6077                                             Register yz_idx, Register idx,
6078                                             Register carry, Register product, int offset) {
6079   //     huge_128 product = (y[idx] * x_xstart) + z[kdx] + carry;
6080   //     z[kdx] = (jlong)product;
6081 
6082   movq(yz_idx, Address(y, idx, Address::times_4,  offset));
6083   rorq(yz_idx, 32); // convert big-endian to little-endian
6084   movq(product, x_xstart);
6085   mulq(yz_idx);     // product(rax) * yz_idx -&gt; rdx:product(rax)
6086   movq(yz_idx, Address(z, idx, Address::times_4,  offset));
6087   rorq(yz_idx, 32); // convert big-endian to little-endian
6088 
6089   add2_with_carry(rdx, product, carry, yz_idx);
6090 
6091   movl(Address(z, idx, Address::times_4,  offset+4), product);
6092   shrq(product, 32);
6093   movl(Address(z, idx, Address::times_4,  offset), product);
6094 
6095 }
6096 
6097 /**
6098  * Multiply 128 bit by 128 bit. Unrolled inner loop.
6099  */
6100 void MacroAssembler::multiply_128_x_128_loop(Register x_xstart, Register y, Register z,
6101                                              Register yz_idx, Register idx, Register jdx,
6102                                              Register carry, Register product,
6103                                              Register carry2) {
6104   //   jlong carry, x[], y[], z[];
6105   //   int kdx = ystart+1;
6106   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
6107   //     huge_128 product = (y[idx+1] * x_xstart) + z[kdx+idx+1] + carry;
6108   //     z[kdx+idx+1] = (jlong)product;
6109   //     jlong carry2  = (jlong)(product &gt;&gt;&gt; 64);
6110   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry2;
6111   //     z[kdx+idx] = (jlong)product;
6112   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
6113   //   }
6114   //   idx += 2;
6115   //   if (idx &gt; 0) {
6116   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry;
6117   //     z[kdx+idx] = (jlong)product;
6118   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
6119   //   }
6120   //
6121 
6122   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
6123 
6124   movl(jdx, idx);
6125   andl(jdx, 0xFFFFFFFC);
6126   shrl(jdx, 2);
6127 
6128   bind(L_third_loop);
6129   subl(jdx, 1);
6130   jcc(Assembler::negative, L_third_loop_exit);
6131   subl(idx, 4);
6132 
6133   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 8);
6134   movq(carry2, rdx);
6135 
6136   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry2, product, 0);
6137   movq(carry, rdx);
6138   jmp(L_third_loop);
6139 
6140   bind (L_third_loop_exit);
6141 
6142   andl (idx, 0x3);
6143   jcc(Assembler::zero, L_post_third_loop_done);
6144 
6145   Label L_check_1;
6146   subl(idx, 2);
6147   jcc(Assembler::negative, L_check_1);
6148 
6149   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 0);
6150   movq(carry, rdx);
6151 
6152   bind (L_check_1);
6153   addl (idx, 0x2);
6154   andl (idx, 0x1);
6155   subl(idx, 1);
6156   jcc(Assembler::negative, L_post_third_loop_done);
6157 
6158   movl(yz_idx, Address(y, idx, Address::times_4,  0));
6159   movq(product, x_xstart);
6160   mulq(yz_idx); // product(rax) * yz_idx -&gt; rdx:product(rax)
6161   movl(yz_idx, Address(z, idx, Address::times_4,  0));
6162 
6163   add2_with_carry(rdx, product, yz_idx, carry);
6164 
6165   movl(Address(z, idx, Address::times_4,  0), product);
6166   shrq(product, 32);
6167 
6168   shlq(rdx, 32);
6169   orq(product, rdx);
6170   movq(carry, product);
6171 
6172   bind(L_post_third_loop_done);
6173 }
6174 
6175 /**
6176  * Multiply 128 bit by 128 bit using BMI2. Unrolled inner loop.
6177  *
6178  */
6179 void MacroAssembler::multiply_128_x_128_bmi2_loop(Register y, Register z,
6180                                                   Register carry, Register carry2,
6181                                                   Register idx, Register jdx,
6182                                                   Register yz_idx1, Register yz_idx2,
6183                                                   Register tmp, Register tmp3, Register tmp4) {
6184   assert(UseBMI2Instructions, &quot;should be used only when BMI2 is available&quot;);
6185 
6186   //   jlong carry, x[], y[], z[];
6187   //   int kdx = ystart+1;
6188   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
6189   //     huge_128 tmp3 = (y[idx+1] * rdx) + z[kdx+idx+1] + carry;
6190   //     jlong carry2  = (jlong)(tmp3 &gt;&gt;&gt; 64);
6191   //     huge_128 tmp4 = (y[idx]   * rdx) + z[kdx+idx] + carry2;
6192   //     carry  = (jlong)(tmp4 &gt;&gt;&gt; 64);
6193   //     z[kdx+idx+1] = (jlong)tmp3;
6194   //     z[kdx+idx] = (jlong)tmp4;
6195   //   }
6196   //   idx += 2;
6197   //   if (idx &gt; 0) {
6198   //     yz_idx1 = (y[idx] * rdx) + z[kdx+idx] + carry;
6199   //     z[kdx+idx] = (jlong)yz_idx1;
6200   //     carry  = (jlong)(yz_idx1 &gt;&gt;&gt; 64);
6201   //   }
6202   //
6203 
6204   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
6205 
6206   movl(jdx, idx);
6207   andl(jdx, 0xFFFFFFFC);
6208   shrl(jdx, 2);
6209 
6210   bind(L_third_loop);
6211   subl(jdx, 1);
6212   jcc(Assembler::negative, L_third_loop_exit);
6213   subl(idx, 4);
6214 
6215   movq(yz_idx1,  Address(y, idx, Address::times_4,  8));
6216   rorxq(yz_idx1, yz_idx1, 32); // convert big-endian to little-endian
6217   movq(yz_idx2, Address(y, idx, Address::times_4,  0));
6218   rorxq(yz_idx2, yz_idx2, 32);
6219 
6220   mulxq(tmp4, tmp3, yz_idx1);  //  yz_idx1 * rdx -&gt; tmp4:tmp3
6221   mulxq(carry2, tmp, yz_idx2); //  yz_idx2 * rdx -&gt; carry2:tmp
6222 
6223   movq(yz_idx1,  Address(z, idx, Address::times_4,  8));
6224   rorxq(yz_idx1, yz_idx1, 32);
6225   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
6226   rorxq(yz_idx2, yz_idx2, 32);
6227 
6228   if (VM_Version::supports_adx()) {
6229     adcxq(tmp3, carry);
6230     adoxq(tmp3, yz_idx1);
6231 
6232     adcxq(tmp4, tmp);
6233     adoxq(tmp4, yz_idx2);
6234 
6235     movl(carry, 0); // does not affect flags
6236     adcxq(carry2, carry);
6237     adoxq(carry2, carry);
6238   } else {
6239     add2_with_carry(tmp4, tmp3, carry, yz_idx1);
6240     add2_with_carry(carry2, tmp4, tmp, yz_idx2);
6241   }
6242   movq(carry, carry2);
6243 
6244   movl(Address(z, idx, Address::times_4, 12), tmp3);
6245   shrq(tmp3, 32);
6246   movl(Address(z, idx, Address::times_4,  8), tmp3);
6247 
6248   movl(Address(z, idx, Address::times_4,  4), tmp4);
6249   shrq(tmp4, 32);
6250   movl(Address(z, idx, Address::times_4,  0), tmp4);
6251 
6252   jmp(L_third_loop);
6253 
6254   bind (L_third_loop_exit);
6255 
6256   andl (idx, 0x3);
6257   jcc(Assembler::zero, L_post_third_loop_done);
6258 
6259   Label L_check_1;
6260   subl(idx, 2);
6261   jcc(Assembler::negative, L_check_1);
6262 
6263   movq(yz_idx1, Address(y, idx, Address::times_4,  0));
6264   rorxq(yz_idx1, yz_idx1, 32);
6265   mulxq(tmp4, tmp3, yz_idx1); //  yz_idx1 * rdx -&gt; tmp4:tmp3
6266   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
6267   rorxq(yz_idx2, yz_idx2, 32);
6268 
6269   add2_with_carry(tmp4, tmp3, carry, yz_idx2);
6270 
6271   movl(Address(z, idx, Address::times_4,  4), tmp3);
6272   shrq(tmp3, 32);
6273   movl(Address(z, idx, Address::times_4,  0), tmp3);
6274   movq(carry, tmp4);
6275 
6276   bind (L_check_1);
6277   addl (idx, 0x2);
6278   andl (idx, 0x1);
6279   subl(idx, 1);
6280   jcc(Assembler::negative, L_post_third_loop_done);
6281   movl(tmp4, Address(y, idx, Address::times_4,  0));
6282   mulxq(carry2, tmp3, tmp4);  //  tmp4 * rdx -&gt; carry2:tmp3
6283   movl(tmp4, Address(z, idx, Address::times_4,  0));
6284 
6285   add2_with_carry(carry2, tmp3, tmp4, carry);
6286 
6287   movl(Address(z, idx, Address::times_4,  0), tmp3);
6288   shrq(tmp3, 32);
6289 
6290   shlq(carry2, 32);
6291   orq(tmp3, carry2);
6292   movq(carry, tmp3);
6293 
6294   bind(L_post_third_loop_done);
6295 }
6296 
6297 /**
6298  * Code for BigInteger::multiplyToLen() instrinsic.
6299  *
6300  * rdi: x
6301  * rax: xlen
6302  * rsi: y
6303  * rcx: ylen
6304  * r8:  z
6305  * r11: zlen
6306  * r12: tmp1
6307  * r13: tmp2
6308  * r14: tmp3
6309  * r15: tmp4
6310  * rbx: tmp5
6311  *
6312  */
6313 void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,
6314                                      Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5) {
6315   ShortBranchVerifier sbv(this);
6316   assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, rdx);
6317 
6318   push(tmp1);
6319   push(tmp2);
6320   push(tmp3);
6321   push(tmp4);
6322   push(tmp5);
6323 
6324   push(xlen);
6325   push(zlen);
6326 
6327   const Register idx = tmp1;
6328   const Register kdx = tmp2;
6329   const Register xstart = tmp3;
6330 
6331   const Register y_idx = tmp4;
6332   const Register carry = tmp5;
6333   const Register product  = xlen;
6334   const Register x_xstart = zlen;  // reuse register
6335 
6336   // First Loop.
6337   //
6338   //  final static long LONG_MASK = 0xffffffffL;
6339   //  int xstart = xlen - 1;
6340   //  int ystart = ylen - 1;
6341   //  long carry = 0;
6342   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
6343   //    long product = (y[idx] &amp; LONG_MASK) * (x[xstart] &amp; LONG_MASK) + carry;
6344   //    z[kdx] = (int)product;
6345   //    carry = product &gt;&gt;&gt; 32;
6346   //  }
6347   //  z[xstart] = (int)carry;
6348   //
6349 
6350   movl(idx, ylen);      // idx = ylen;
6351   movl(kdx, zlen);      // kdx = xlen+ylen;
6352   xorq(carry, carry);   // carry = 0;
6353 
6354   Label L_done;
6355 
6356   movl(xstart, xlen);
6357   decrementl(xstart);
6358   jcc(Assembler::negative, L_done);
6359 
6360   multiply_64_x_64_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);
6361 
6362   Label L_second_loop;
6363   testl(kdx, kdx);
6364   jcc(Assembler::zero, L_second_loop);
6365 
6366   Label L_carry;
6367   subl(kdx, 1);
6368   jcc(Assembler::zero, L_carry);
6369 
6370   movl(Address(z, kdx, Address::times_4,  0), carry);
6371   shrq(carry, 32);
6372   subl(kdx, 1);
6373 
6374   bind(L_carry);
6375   movl(Address(z, kdx, Address::times_4,  0), carry);
6376 
6377   // Second and third (nested) loops.
6378   //
6379   // for (int i = xstart-1; i &gt;= 0; i--) { // Second loop
6380   //   carry = 0;
6381   //   for (int jdx=ystart, k=ystart+1+i; jdx &gt;= 0; jdx--, k--) { // Third loop
6382   //     long product = (y[jdx] &amp; LONG_MASK) * (x[i] &amp; LONG_MASK) +
6383   //                    (z[k] &amp; LONG_MASK) + carry;
6384   //     z[k] = (int)product;
6385   //     carry = product &gt;&gt;&gt; 32;
6386   //   }
6387   //   z[i] = (int)carry;
6388   // }
6389   //
6390   // i = xlen, j = tmp1, k = tmp2, carry = tmp5, x[i] = rdx
6391 
6392   const Register jdx = tmp1;
6393 
6394   bind(L_second_loop);
6395   xorl(carry, carry);    // carry = 0;
6396   movl(jdx, ylen);       // j = ystart+1
6397 
6398   subl(xstart, 1);       // i = xstart-1;
6399   jcc(Assembler::negative, L_done);
6400 
6401   push (z);
6402 
6403   Label L_last_x;
6404   lea(z, Address(z, xstart, Address::times_4, 4)); // z = z + k - j
6405   subl(xstart, 1);       // i = xstart-1;
6406   jcc(Assembler::negative, L_last_x);
6407 
6408   if (UseBMI2Instructions) {
6409     movq(rdx,  Address(x, xstart, Address::times_4,  0));
6410     rorxq(rdx, rdx, 32); // convert big-endian to little-endian
6411   } else {
6412     movq(x_xstart, Address(x, xstart, Address::times_4,  0));
6413     rorq(x_xstart, 32);  // convert big-endian to little-endian
6414   }
6415 
6416   Label L_third_loop_prologue;
6417   bind(L_third_loop_prologue);
6418 
6419   push (x);
6420   push (xstart);
6421   push (ylen);
6422 
6423 
6424   if (UseBMI2Instructions) {
6425     multiply_128_x_128_bmi2_loop(y, z, carry, x, jdx, ylen, product, tmp2, x_xstart, tmp3, tmp4);
6426   } else { // !UseBMI2Instructions
6427     multiply_128_x_128_loop(x_xstart, y, z, y_idx, jdx, ylen, carry, product, x);
6428   }
6429 
6430   pop(ylen);
6431   pop(xlen);
6432   pop(x);
6433   pop(z);
6434 
6435   movl(tmp3, xlen);
6436   addl(tmp3, 1);
6437   movl(Address(z, tmp3, Address::times_4,  0), carry);
6438   subl(tmp3, 1);
6439   jccb(Assembler::negative, L_done);
6440 
6441   shrq(carry, 32);
6442   movl(Address(z, tmp3, Address::times_4,  0), carry);
6443   jmp(L_second_loop);
6444 
6445   // Next infrequent code is moved outside loops.
6446   bind(L_last_x);
6447   if (UseBMI2Instructions) {
6448     movl(rdx, Address(x,  0));
6449   } else {
6450     movl(x_xstart, Address(x,  0));
6451   }
6452   jmp(L_third_loop_prologue);
6453 
6454   bind(L_done);
6455 
6456   pop(zlen);
6457   pop(xlen);
6458 
6459   pop(tmp5);
6460   pop(tmp4);
6461   pop(tmp3);
6462   pop(tmp2);
6463   pop(tmp1);
6464 }
6465 
6466 void MacroAssembler::vectorized_mismatch(Register obja, Register objb, Register length, Register log2_array_indxscale,
6467   Register result, Register tmp1, Register tmp2, XMMRegister rymm0, XMMRegister rymm1, XMMRegister rymm2){
6468   assert(UseSSE42Intrinsics, &quot;SSE4.2 must be enabled.&quot;);
6469   Label VECTOR16_LOOP, VECTOR8_LOOP, VECTOR4_LOOP;
6470   Label VECTOR8_TAIL, VECTOR4_TAIL;
6471   Label VECTOR32_NOT_EQUAL, VECTOR16_NOT_EQUAL, VECTOR8_NOT_EQUAL, VECTOR4_NOT_EQUAL;
6472   Label SAME_TILL_END, DONE;
6473   Label BYTES_LOOP, BYTES_TAIL, BYTES_NOT_EQUAL;
6474 
6475   //scale is in rcx in both Win64 and Unix
6476   ShortBranchVerifier sbv(this);
6477 
6478   shlq(length);
6479   xorq(result, result);
6480 
6481   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp;
6482       VM_Version::supports_avx512vlbw()) {
6483     Label VECTOR64_LOOP, VECTOR64_NOT_EQUAL, VECTOR32_TAIL;
6484 
6485     cmpq(length, 64);
6486     jcc(Assembler::less, VECTOR32_TAIL);
6487 
6488     movq(tmp1, length);
6489     andq(tmp1, 0x3F);      // tail count
6490     andq(length, ~(0x3F)); //vector count
6491 
6492     bind(VECTOR64_LOOP);
6493     // AVX512 code to compare 64 byte vectors.
6494     evmovdqub(rymm0, Address(obja, result), Assembler::AVX_512bit);
6495     evpcmpeqb(k7, rymm0, Address(objb, result), Assembler::AVX_512bit);
6496     kortestql(k7, k7);
6497     jcc(Assembler::aboveEqual, VECTOR64_NOT_EQUAL);     // mismatch
6498     addq(result, 64);
6499     subq(length, 64);
6500     jccb(Assembler::notZero, VECTOR64_LOOP);
6501 
6502     //bind(VECTOR64_TAIL);
6503     testq(tmp1, tmp1);
6504     jcc(Assembler::zero, SAME_TILL_END);
6505 
6506     //bind(VECTOR64_TAIL);
6507     // AVX512 code to compare upto 63 byte vectors.
6508     mov64(tmp2, 0xFFFFFFFFFFFFFFFF);
6509     shlxq(tmp2, tmp2, tmp1);
6510     notq(tmp2);
6511     kmovql(k3, tmp2);
6512 
6513     evmovdqub(rymm0, k3, Address(obja, result), Assembler::AVX_512bit);
6514     evpcmpeqb(k7, k3, rymm0, Address(objb, result), Assembler::AVX_512bit);
6515 
6516     ktestql(k7, k3);
6517     jcc(Assembler::below, SAME_TILL_END);     // not mismatch
6518 
6519     bind(VECTOR64_NOT_EQUAL);
6520     kmovql(tmp1, k7);
6521     notq(tmp1);
6522     tzcntq(tmp1, tmp1);
6523     addq(result, tmp1);
6524     shrq(result);
6525     jmp(DONE);
6526     bind(VECTOR32_TAIL);
6527   }
6528 
6529   cmpq(length, 8);
6530   jcc(Assembler::equal, VECTOR8_LOOP);
6531   jcc(Assembler::less, VECTOR4_TAIL);
6532 
6533   if (UseAVX &gt;= 2) {
6534     Label VECTOR16_TAIL, VECTOR32_LOOP;
6535 
6536     cmpq(length, 16);
6537     jcc(Assembler::equal, VECTOR16_LOOP);
6538     jcc(Assembler::less, VECTOR8_LOOP);
6539 
6540     cmpq(length, 32);
6541     jccb(Assembler::less, VECTOR16_TAIL);
6542 
6543     subq(length, 32);
6544     bind(VECTOR32_LOOP);
6545     vmovdqu(rymm0, Address(obja, result));
6546     vmovdqu(rymm1, Address(objb, result));
6547     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_256bit);
6548     vptest(rymm2, rymm2);
6549     jcc(Assembler::notZero, VECTOR32_NOT_EQUAL);//mismatch found
6550     addq(result, 32);
6551     subq(length, 32);
6552     jcc(Assembler::greaterEqual, VECTOR32_LOOP);
6553     addq(length, 32);
6554     jcc(Assembler::equal, SAME_TILL_END);
6555     //falling through if less than 32 bytes left //close the branch here.
6556 
6557     bind(VECTOR16_TAIL);
6558     cmpq(length, 16);
6559     jccb(Assembler::less, VECTOR8_TAIL);
6560     bind(VECTOR16_LOOP);
6561     movdqu(rymm0, Address(obja, result));
6562     movdqu(rymm1, Address(objb, result));
6563     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_128bit);
6564     ptest(rymm2, rymm2);
6565     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
6566     addq(result, 16);
6567     subq(length, 16);
6568     jcc(Assembler::equal, SAME_TILL_END);
6569     //falling through if less than 16 bytes left
6570   } else {//regular intrinsics
6571 
6572     cmpq(length, 16);
6573     jccb(Assembler::less, VECTOR8_TAIL);
6574 
6575     subq(length, 16);
6576     bind(VECTOR16_LOOP);
6577     movdqu(rymm0, Address(obja, result));
6578     movdqu(rymm1, Address(objb, result));
6579     pxor(rymm0, rymm1);
6580     ptest(rymm0, rymm0);
6581     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
6582     addq(result, 16);
6583     subq(length, 16);
6584     jccb(Assembler::greaterEqual, VECTOR16_LOOP);
6585     addq(length, 16);
6586     jcc(Assembler::equal, SAME_TILL_END);
6587     //falling through if less than 16 bytes left
6588   }
6589 
6590   bind(VECTOR8_TAIL);
6591   cmpq(length, 8);
6592   jccb(Assembler::less, VECTOR4_TAIL);
6593   bind(VECTOR8_LOOP);
6594   movq(tmp1, Address(obja, result));
6595   movq(tmp2, Address(objb, result));
6596   xorq(tmp1, tmp2);
6597   testq(tmp1, tmp1);
6598   jcc(Assembler::notZero, VECTOR8_NOT_EQUAL);//mismatch found
6599   addq(result, 8);
6600   subq(length, 8);
6601   jcc(Assembler::equal, SAME_TILL_END);
6602   //falling through if less than 8 bytes left
6603 
6604   bind(VECTOR4_TAIL);
6605   cmpq(length, 4);
6606   jccb(Assembler::less, BYTES_TAIL);
6607   bind(VECTOR4_LOOP);
6608   movl(tmp1, Address(obja, result));
6609   xorl(tmp1, Address(objb, result));
6610   testl(tmp1, tmp1);
6611   jcc(Assembler::notZero, VECTOR4_NOT_EQUAL);//mismatch found
6612   addq(result, 4);
6613   subq(length, 4);
6614   jcc(Assembler::equal, SAME_TILL_END);
6615   //falling through if less than 4 bytes left
6616 
6617   bind(BYTES_TAIL);
6618   bind(BYTES_LOOP);
6619   load_unsigned_byte(tmp1, Address(obja, result));
6620   load_unsigned_byte(tmp2, Address(objb, result));
6621   xorl(tmp1, tmp2);
6622   testl(tmp1, tmp1);
6623   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
6624   decq(length);
6625   jcc(Assembler::zero, SAME_TILL_END);
6626   incq(result);
6627   load_unsigned_byte(tmp1, Address(obja, result));
6628   load_unsigned_byte(tmp2, Address(objb, result));
6629   xorl(tmp1, tmp2);
6630   testl(tmp1, tmp1);
6631   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
6632   decq(length);
6633   jcc(Assembler::zero, SAME_TILL_END);
6634   incq(result);
6635   load_unsigned_byte(tmp1, Address(obja, result));
6636   load_unsigned_byte(tmp2, Address(objb, result));
6637   xorl(tmp1, tmp2);
6638   testl(tmp1, tmp1);
6639   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
6640   jmp(SAME_TILL_END);
6641 
6642   if (UseAVX &gt;= 2) {
6643     bind(VECTOR32_NOT_EQUAL);
6644     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_256bit);
6645     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_256bit);
6646     vpxor(rymm0, rymm0, rymm2, Assembler::AVX_256bit);
6647     vpmovmskb(tmp1, rymm0);
6648     bsfq(tmp1, tmp1);
6649     addq(result, tmp1);
6650     shrq(result);
6651     jmp(DONE);
6652   }
6653 
6654   bind(VECTOR16_NOT_EQUAL);
6655   if (UseAVX &gt;= 2) {
6656     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_128bit);
6657     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_128bit);
6658     pxor(rymm0, rymm2);
6659   } else {
6660     pcmpeqb(rymm2, rymm2);
6661     pxor(rymm0, rymm1);
6662     pcmpeqb(rymm0, rymm1);
6663     pxor(rymm0, rymm2);
6664   }
6665   pmovmskb(tmp1, rymm0);
6666   bsfq(tmp1, tmp1);
6667   addq(result, tmp1);
6668   shrq(result);
6669   jmpb(DONE);
6670 
6671   bind(VECTOR8_NOT_EQUAL);
6672   bind(VECTOR4_NOT_EQUAL);
6673   bsfq(tmp1, tmp1);
6674   shrq(tmp1, 3);
6675   addq(result, tmp1);
6676   bind(BYTES_NOT_EQUAL);
6677   shrq(result);
6678   jmpb(DONE);
6679 
6680   bind(SAME_TILL_END);
6681   mov64(result, -1);
6682 
6683   bind(DONE);
6684 }
6685 
6686 //Helper functions for square_to_len()
6687 
6688 /**
6689  * Store the squares of x[], right shifted one bit (divided by 2) into z[]
6690  * Preserves x and z and modifies rest of the registers.
6691  */
6692 void MacroAssembler::square_rshift(Register x, Register xlen, Register z, Register tmp1, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6693   // Perform square and right shift by 1
6694   // Handle odd xlen case first, then for even xlen do the following
6695   // jlong carry = 0;
6696   // for (int j=0, i=0; j &lt; xlen; j+=2, i+=4) {
6697   //     huge_128 product = x[j:j+1] * x[j:j+1];
6698   //     z[i:i+1] = (carry &lt;&lt; 63) | (jlong)(product &gt;&gt;&gt; 65);
6699   //     z[i+2:i+3] = (jlong)(product &gt;&gt;&gt; 1);
6700   //     carry = (jlong)product;
6701   // }
6702 
6703   xorq(tmp5, tmp5);     // carry
6704   xorq(rdxReg, rdxReg);
6705   xorl(tmp1, tmp1);     // index for x
6706   xorl(tmp4, tmp4);     // index for z
6707 
6708   Label L_first_loop, L_first_loop_exit;
6709 
6710   testl(xlen, 1);
6711   jccb(Assembler::zero, L_first_loop); //jump if xlen is even
6712 
6713   // Square and right shift by 1 the odd element using 32 bit multiply
6714   movl(raxReg, Address(x, tmp1, Address::times_4, 0));
6715   imulq(raxReg, raxReg);
6716   shrq(raxReg, 1);
6717   adcq(tmp5, 0);
6718   movq(Address(z, tmp4, Address::times_4, 0), raxReg);
6719   incrementl(tmp1);
6720   addl(tmp4, 2);
6721 
6722   // Square and  right shift by 1 the rest using 64 bit multiply
6723   bind(L_first_loop);
6724   cmpptr(tmp1, xlen);
6725   jccb(Assembler::equal, L_first_loop_exit);
6726 
6727   // Square
6728   movq(raxReg, Address(x, tmp1, Address::times_4,  0));
6729   rorq(raxReg, 32);    // convert big-endian to little-endian
6730   mulq(raxReg);        // 64-bit multiply rax * rax -&gt; rdx:rax
6731 
6732   // Right shift by 1 and save carry
6733   shrq(tmp5, 1);       // rdx:rax:tmp5 = (tmp5:rdx:rax) &gt;&gt;&gt; 1
6734   rcrq(rdxReg, 1);
6735   rcrq(raxReg, 1);
6736   adcq(tmp5, 0);
6737 
6738   // Store result in z
6739   movq(Address(z, tmp4, Address::times_4, 0), rdxReg);
6740   movq(Address(z, tmp4, Address::times_4, 8), raxReg);
6741 
6742   // Update indices for x and z
6743   addl(tmp1, 2);
6744   addl(tmp4, 4);
6745   jmp(L_first_loop);
6746 
6747   bind(L_first_loop_exit);
6748 }
6749 
6750 
6751 /**
6752  * Perform the following multiply add operation using BMI2 instructions
6753  * carry:sum = sum + op1*op2 + carry
6754  * op2 should be in rdx
6755  * op2 is preserved, all other registers are modified
6756  */
6757 void MacroAssembler::multiply_add_64_bmi2(Register sum, Register op1, Register op2, Register carry, Register tmp2) {
6758   // assert op2 is rdx
6759   mulxq(tmp2, op1, op1);  //  op1 * op2 -&gt; tmp2:op1
6760   addq(sum, carry);
6761   adcq(tmp2, 0);
6762   addq(sum, op1);
6763   adcq(tmp2, 0);
6764   movq(carry, tmp2);
6765 }
6766 
6767 /**
6768  * Perform the following multiply add operation:
6769  * carry:sum = sum + op1*op2 + carry
6770  * Preserves op1, op2 and modifies rest of registers
6771  */
6772 void MacroAssembler::multiply_add_64(Register sum, Register op1, Register op2, Register carry, Register rdxReg, Register raxReg) {
6773   // rdx:rax = op1 * op2
6774   movq(raxReg, op2);
6775   mulq(op1);
6776 
6777   //  rdx:rax = sum + carry + rdx:rax
6778   addq(sum, carry);
6779   adcq(rdxReg, 0);
6780   addq(sum, raxReg);
6781   adcq(rdxReg, 0);
6782 
6783   // carry:sum = rdx:sum
6784   movq(carry, rdxReg);
6785 }
6786 
6787 /**
6788  * Add 64 bit long carry into z[] with carry propogation.
6789  * Preserves z and carry register values and modifies rest of registers.
6790  *
6791  */
6792 void MacroAssembler::add_one_64(Register z, Register zlen, Register carry, Register tmp1) {
6793   Label L_fourth_loop, L_fourth_loop_exit;
6794 
6795   movl(tmp1, 1);
6796   subl(zlen, 2);
6797   addq(Address(z, zlen, Address::times_4, 0), carry);
6798 
6799   bind(L_fourth_loop);
6800   jccb(Assembler::carryClear, L_fourth_loop_exit);
6801   subl(zlen, 2);
6802   jccb(Assembler::negative, L_fourth_loop_exit);
6803   addq(Address(z, zlen, Address::times_4, 0), tmp1);
6804   jmp(L_fourth_loop);
6805   bind(L_fourth_loop_exit);
6806 }
6807 
6808 /**
6809  * Shift z[] left by 1 bit.
6810  * Preserves x, len, z and zlen registers and modifies rest of the registers.
6811  *
6812  */
6813 void MacroAssembler::lshift_by_1(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4) {
6814 
6815   Label L_fifth_loop, L_fifth_loop_exit;
6816 
6817   // Fifth loop
6818   // Perform primitiveLeftShift(z, zlen, 1)
6819 
6820   const Register prev_carry = tmp1;
6821   const Register new_carry = tmp4;
6822   const Register value = tmp2;
6823   const Register zidx = tmp3;
6824 
6825   // int zidx, carry;
6826   // long value;
6827   // carry = 0;
6828   // for (zidx = zlen-2; zidx &gt;=0; zidx -= 2) {
6829   //    (carry:value)  = (z[i] &lt;&lt; 1) | carry ;
6830   //    z[i] = value;
6831   // }
6832 
6833   movl(zidx, zlen);
6834   xorl(prev_carry, prev_carry); // clear carry flag and prev_carry register
6835 
6836   bind(L_fifth_loop);
6837   decl(zidx);  // Use decl to preserve carry flag
6838   decl(zidx);
6839   jccb(Assembler::negative, L_fifth_loop_exit);
6840 
6841   if (UseBMI2Instructions) {
6842      movq(value, Address(z, zidx, Address::times_4, 0));
6843      rclq(value, 1);
6844      rorxq(value, value, 32);
6845      movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
6846   }
6847   else {
6848     // clear new_carry
6849     xorl(new_carry, new_carry);
6850 
6851     // Shift z[i] by 1, or in previous carry and save new carry
6852     movq(value, Address(z, zidx, Address::times_4, 0));
6853     shlq(value, 1);
6854     adcl(new_carry, 0);
6855 
6856     orq(value, prev_carry);
6857     rorq(value, 0x20);
6858     movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
6859 
6860     // Set previous carry = new carry
6861     movl(prev_carry, new_carry);
6862   }
6863   jmp(L_fifth_loop);
6864 
6865   bind(L_fifth_loop_exit);
6866 }
6867 
6868 
6869 /**
6870  * Code for BigInteger::squareToLen() intrinsic
6871  *
6872  * rdi: x
6873  * rsi: len
6874  * r8:  z
6875  * rcx: zlen
6876  * r12: tmp1
6877  * r13: tmp2
6878  * r14: tmp3
6879  * r15: tmp4
6880  * rbx: tmp5
6881  *
6882  */
6883 void MacroAssembler::square_to_len(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6884 
6885   Label L_second_loop, L_second_loop_exit, L_third_loop, L_third_loop_exit, L_last_x, L_multiply;
6886   push(tmp1);
6887   push(tmp2);
6888   push(tmp3);
6889   push(tmp4);
6890   push(tmp5);
6891 
6892   // First loop
6893   // Store the squares, right shifted one bit (i.e., divided by 2).
6894   square_rshift(x, len, z, tmp1, tmp3, tmp4, tmp5, rdxReg, raxReg);
6895 
6896   // Add in off-diagonal sums.
6897   //
6898   // Second, third (nested) and fourth loops.
6899   // zlen +=2;
6900   // for (int xidx=len-2,zidx=zlen-4; xidx &gt; 0; xidx-=2,zidx-=4) {
6901   //    carry = 0;
6902   //    long op2 = x[xidx:xidx+1];
6903   //    for (int j=xidx-2,k=zidx; j &gt;= 0; j-=2) {
6904   //       k -= 2;
6905   //       long op1 = x[j:j+1];
6906   //       long sum = z[k:k+1];
6907   //       carry:sum = multiply_add_64(sum, op1, op2, carry, tmp_regs);
6908   //       z[k:k+1] = sum;
6909   //    }
6910   //    add_one_64(z, k, carry, tmp_regs);
6911   // }
6912 
6913   const Register carry = tmp5;
6914   const Register sum = tmp3;
6915   const Register op1 = tmp4;
6916   Register op2 = tmp2;
6917 
6918   push(zlen);
6919   push(len);
6920   addl(zlen,2);
6921   bind(L_second_loop);
6922   xorq(carry, carry);
6923   subl(zlen, 4);
6924   subl(len, 2);
6925   push(zlen);
6926   push(len);
6927   cmpl(len, 0);
6928   jccb(Assembler::lessEqual, L_second_loop_exit);
6929 
6930   // Multiply an array by one 64 bit long.
6931   if (UseBMI2Instructions) {
6932     op2 = rdxReg;
6933     movq(op2, Address(x, len, Address::times_4,  0));
6934     rorxq(op2, op2, 32);
6935   }
6936   else {
6937     movq(op2, Address(x, len, Address::times_4,  0));
6938     rorq(op2, 32);
6939   }
6940 
6941   bind(L_third_loop);
6942   decrementl(len);
6943   jccb(Assembler::negative, L_third_loop_exit);
6944   decrementl(len);
6945   jccb(Assembler::negative, L_last_x);
6946 
6947   movq(op1, Address(x, len, Address::times_4,  0));
6948   rorq(op1, 32);
6949 
6950   bind(L_multiply);
6951   subl(zlen, 2);
6952   movq(sum, Address(z, zlen, Address::times_4,  0));
6953 
6954   // Multiply 64 bit by 64 bit and add 64 bits lower half and upper 64 bits as carry.
6955   if (UseBMI2Instructions) {
6956     multiply_add_64_bmi2(sum, op1, op2, carry, tmp2);
6957   }
6958   else {
6959     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6960   }
6961 
6962   movq(Address(z, zlen, Address::times_4, 0), sum);
6963 
6964   jmp(L_third_loop);
6965   bind(L_third_loop_exit);
6966 
6967   // Fourth loop
6968   // Add 64 bit long carry into z with carry propogation.
6969   // Uses offsetted zlen.
6970   add_one_64(z, zlen, carry, tmp1);
6971 
6972   pop(len);
6973   pop(zlen);
6974   jmp(L_second_loop);
6975 
6976   // Next infrequent code is moved outside loops.
6977   bind(L_last_x);
6978   movl(op1, Address(x, 0));
6979   jmp(L_multiply);
6980 
6981   bind(L_second_loop_exit);
6982   pop(len);
6983   pop(zlen);
6984   pop(len);
6985   pop(zlen);
6986 
6987   // Fifth loop
6988   // Shift z left 1 bit.
6989   lshift_by_1(x, len, z, zlen, tmp1, tmp2, tmp3, tmp4);
6990 
6991   // z[zlen-1] |= x[len-1] &amp; 1;
6992   movl(tmp3, Address(x, len, Address::times_4, -4));
6993   andl(tmp3, 1);
6994   orl(Address(z, zlen, Address::times_4,  -4), tmp3);
6995 
6996   pop(tmp5);
6997   pop(tmp4);
6998   pop(tmp3);
6999   pop(tmp2);
7000   pop(tmp1);
7001 }
7002 
7003 /**
7004  * Helper function for mul_add()
7005  * Multiply the in[] by int k and add to out[] starting at offset offs using
7006  * 128 bit by 32 bit multiply and return the carry in tmp5.
7007  * Only quad int aligned length of in[] is operated on in this function.
7008  * k is in rdxReg for BMI2Instructions, for others it is in tmp2.
7009  * This function preserves out, in and k registers.
7010  * len and offset point to the appropriate index in &quot;in&quot; &amp; &quot;out&quot; correspondingly
7011  * tmp5 has the carry.
7012  * other registers are temporary and are modified.
7013  *
7014  */
7015 void MacroAssembler::mul_add_128_x_32_loop(Register out, Register in,
7016   Register offset, Register len, Register tmp1, Register tmp2, Register tmp3,
7017   Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
7018 
7019   Label L_first_loop, L_first_loop_exit;
7020 
7021   movl(tmp1, len);
7022   shrl(tmp1, 2);
7023 
7024   bind(L_first_loop);
7025   subl(tmp1, 1);
7026   jccb(Assembler::negative, L_first_loop_exit);
7027 
7028   subl(len, 4);
7029   subl(offset, 4);
7030 
7031   Register op2 = tmp2;
7032   const Register sum = tmp3;
7033   const Register op1 = tmp4;
7034   const Register carry = tmp5;
7035 
7036   if (UseBMI2Instructions) {
7037     op2 = rdxReg;
7038   }
7039 
7040   movq(op1, Address(in, len, Address::times_4,  8));
7041   rorq(op1, 32);
7042   movq(sum, Address(out, offset, Address::times_4,  8));
7043   rorq(sum, 32);
7044   if (UseBMI2Instructions) {
7045     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
7046   }
7047   else {
7048     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
7049   }
7050   // Store back in big endian from little endian
7051   rorq(sum, 0x20);
7052   movq(Address(out, offset, Address::times_4,  8), sum);
7053 
7054   movq(op1, Address(in, len, Address::times_4,  0));
7055   rorq(op1, 32);
7056   movq(sum, Address(out, offset, Address::times_4,  0));
7057   rorq(sum, 32);
7058   if (UseBMI2Instructions) {
7059     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
7060   }
7061   else {
7062     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
7063   }
7064   // Store back in big endian from little endian
7065   rorq(sum, 0x20);
7066   movq(Address(out, offset, Address::times_4,  0), sum);
7067 
7068   jmp(L_first_loop);
7069   bind(L_first_loop_exit);
7070 }
7071 
7072 /**
7073  * Code for BigInteger::mulAdd() intrinsic
7074  *
7075  * rdi: out
7076  * rsi: in
7077  * r11: offs (out.length - offset)
7078  * rcx: len
7079  * r8:  k
7080  * r12: tmp1
7081  * r13: tmp2
7082  * r14: tmp3
7083  * r15: tmp4
7084  * rbx: tmp5
7085  * Multiply the in[] by word k and add to out[], return the carry in rax
7086  */
7087 void MacroAssembler::mul_add(Register out, Register in, Register offs,
7088    Register len, Register k, Register tmp1, Register tmp2, Register tmp3,
7089    Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
7090 
7091   Label L_carry, L_last_in, L_done;
7092 
7093 // carry = 0;
7094 // for (int j=len-1; j &gt;= 0; j--) {
7095 //    long product = (in[j] &amp; LONG_MASK) * kLong +
7096 //                   (out[offs] &amp; LONG_MASK) + carry;
7097 //    out[offs--] = (int)product;
7098 //    carry = product &gt;&gt;&gt; 32;
7099 // }
7100 //
7101   push(tmp1);
7102   push(tmp2);
7103   push(tmp3);
7104   push(tmp4);
7105   push(tmp5);
7106 
7107   Register op2 = tmp2;
7108   const Register sum = tmp3;
7109   const Register op1 = tmp4;
7110   const Register carry =  tmp5;
7111 
7112   if (UseBMI2Instructions) {
7113     op2 = rdxReg;
7114     movl(op2, k);
7115   }
7116   else {
7117     movl(op2, k);
7118   }
7119 
7120   xorq(carry, carry);
7121 
7122   //First loop
7123 
7124   //Multiply in[] by k in a 4 way unrolled loop using 128 bit by 32 bit multiply
7125   //The carry is in tmp5
7126   mul_add_128_x_32_loop(out, in, offs, len, tmp1, tmp2, tmp3, tmp4, tmp5, rdxReg, raxReg);
7127 
7128   //Multiply the trailing in[] entry using 64 bit by 32 bit, if any
7129   decrementl(len);
7130   jccb(Assembler::negative, L_carry);
7131   decrementl(len);
7132   jccb(Assembler::negative, L_last_in);
7133 
7134   movq(op1, Address(in, len, Address::times_4,  0));
7135   rorq(op1, 32);
7136 
7137   subl(offs, 2);
7138   movq(sum, Address(out, offs, Address::times_4,  0));
7139   rorq(sum, 32);
7140 
7141   if (UseBMI2Instructions) {
7142     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
7143   }
7144   else {
7145     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
7146   }
7147 
7148   // Store back in big endian from little endian
7149   rorq(sum, 0x20);
7150   movq(Address(out, offs, Address::times_4,  0), sum);
7151 
7152   testl(len, len);
7153   jccb(Assembler::zero, L_carry);
7154 
7155   //Multiply the last in[] entry, if any
7156   bind(L_last_in);
7157   movl(op1, Address(in, 0));
7158   movl(sum, Address(out, offs, Address::times_4,  -4));
7159 
7160   movl(raxReg, k);
7161   mull(op1); //tmp4 * eax -&gt; edx:eax
7162   addl(sum, carry);
7163   adcl(rdxReg, 0);
7164   addl(sum, raxReg);
7165   adcl(rdxReg, 0);
7166   movl(carry, rdxReg);
7167 
7168   movl(Address(out, offs, Address::times_4,  -4), sum);
7169 
7170   bind(L_carry);
7171   //return tmp5/carry as carry in rax
7172   movl(rax, carry);
7173 
7174   bind(L_done);
7175   pop(tmp5);
7176   pop(tmp4);
7177   pop(tmp3);
7178   pop(tmp2);
7179   pop(tmp1);
7180 }
7181 #endif
7182 
7183 /**
7184  * Emits code to update CRC-32 with a byte value according to constants in table
7185  *
7186  * @param [in,out]crc   Register containing the crc.
7187  * @param [in]val       Register containing the byte to fold into the CRC.
7188  * @param [in]table     Register containing the table of crc constants.
7189  *
7190  * uint32_t crc;
7191  * val = crc_table[(val ^ crc) &amp; 0xFF];
7192  * crc = val ^ (crc &gt;&gt; 8);
7193  *
7194  */
7195 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
7196   xorl(val, crc);
7197   andl(val, 0xFF);
7198   shrl(crc, 8); // unsigned shift
7199   xorl(crc, Address(table, val, Address::times_4, 0));
7200 }
7201 
7202 /**
7203 * Fold four 128-bit data chunks
7204 */
7205 void MacroAssembler::fold_128bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {
7206   evpclmulhdq(xtmp, xK, xcrc, Assembler::AVX_512bit); // [123:64]
7207   evpclmulldq(xcrc, xK, xcrc, Assembler::AVX_512bit); // [63:0]
7208   evpxorq(xcrc, xcrc, Address(buf, offset), Assembler::AVX_512bit /* vector_len */);
7209   evpxorq(xcrc, xcrc, xtmp, Assembler::AVX_512bit /* vector_len */);
7210 }
7211 
7212 /**
7213  * Fold 128-bit data chunk
7214  */
7215 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {
7216   if (UseAVX &gt; 0) {
7217     vpclmulhdq(xtmp, xK, xcrc); // [123:64]
7218     vpclmulldq(xcrc, xK, xcrc); // [63:0]
7219     vpxor(xcrc, xcrc, Address(buf, offset), 0 /* vector_len */);
7220     pxor(xcrc, xtmp);
7221   } else {
7222     movdqa(xtmp, xcrc);
7223     pclmulhdq(xtmp, xK);   // [123:64]
7224     pclmulldq(xcrc, xK);   // [63:0]
7225     pxor(xcrc, xtmp);
7226     movdqu(xtmp, Address(buf, offset));
7227     pxor(xcrc, xtmp);
7228   }
7229 }
7230 
7231 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf) {
7232   if (UseAVX &gt; 0) {
7233     vpclmulhdq(xtmp, xK, xcrc);
7234     vpclmulldq(xcrc, xK, xcrc);
7235     pxor(xcrc, xbuf);
7236     pxor(xcrc, xtmp);
7237   } else {
7238     movdqa(xtmp, xcrc);
7239     pclmulhdq(xtmp, xK);
7240     pclmulldq(xcrc, xK);
7241     pxor(xcrc, xbuf);
7242     pxor(xcrc, xtmp);
7243   }
7244 }
7245 
7246 /**
7247  * 8-bit folds to compute 32-bit CRC
7248  *
7249  * uint64_t xcrc;
7250  * timesXtoThe32[xcrc &amp; 0xFF] ^ (xcrc &gt;&gt; 8);
7251  */
7252 void MacroAssembler::fold_8bit_crc32(XMMRegister xcrc, Register table, XMMRegister xtmp, Register tmp) {
7253   movdl(tmp, xcrc);
7254   andl(tmp, 0xFF);
7255   movdl(xtmp, Address(table, tmp, Address::times_4, 0));
7256   psrldq(xcrc, 1); // unsigned shift one byte
7257   pxor(xcrc, xtmp);
7258 }
7259 
7260 /**
7261  * uint32_t crc;
7262  * timesXtoThe32[crc &amp; 0xFF] ^ (crc &gt;&gt; 8);
7263  */
7264 void MacroAssembler::fold_8bit_crc32(Register crc, Register table, Register tmp) {
7265   movl(tmp, crc);
7266   andl(tmp, 0xFF);
7267   shrl(crc, 8);
7268   xorl(crc, Address(table, tmp, Address::times_4, 0));
7269 }
7270 
7271 /**
7272  * @param crc   register containing existing CRC (32-bit)
7273  * @param buf   register pointing to input byte buffer (byte*)
7274  * @param len   register containing number of bytes
7275  * @param table register that will contain address of CRC table
7276  * @param tmp   scratch register
7277  */
7278 void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len, Register table, Register tmp) {
7279   assert_different_registers(crc, buf, len, table, tmp, rax);
7280 
7281   Label L_tail, L_tail_restore, L_tail_loop, L_exit, L_align_loop, L_aligned;
7282   Label L_fold_tail, L_fold_128b, L_fold_512b, L_fold_512b_loop, L_fold_tail_loop;
7283 
7284   // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge
7285   // context for the registers used, where all instructions below are using 128-bit mode
7286   // On EVEX without VL and BW, these instructions will all be AVX.
7287   lea(table, ExternalAddress(StubRoutines::crc_table_addr()));
7288   notl(crc); // ~crc
7289   cmpl(len, 16);
7290   jcc(Assembler::less, L_tail);
7291 
7292   // Align buffer to 16 bytes
7293   movl(tmp, buf);
7294   andl(tmp, 0xF);
7295   jccb(Assembler::zero, L_aligned);
7296   subl(tmp,  16);
7297   addl(len, tmp);
7298 
7299   align(4);
7300   BIND(L_align_loop);
7301   movsbl(rax, Address(buf, 0)); // load byte with sign extension
7302   update_byte_crc32(crc, rax, table);
7303   increment(buf);
7304   incrementl(tmp);
7305   jccb(Assembler::less, L_align_loop);
7306 
7307   BIND(L_aligned);
7308   movl(tmp, len); // save
7309   shrl(len, 4);
7310   jcc(Assembler::zero, L_tail_restore);
7311 
7312   // Fold crc into first bytes of vector
7313   movdqa(xmm1, Address(buf, 0));
7314   movdl(rax, xmm1);
7315   xorl(crc, rax);
7316   if (VM_Version::supports_sse4_1()) {
7317     pinsrd(xmm1, crc, 0);
7318   } else {
7319     pinsrw(xmm1, crc, 0);
7320     shrl(crc, 16);
7321     pinsrw(xmm1, crc, 1);
7322   }
7323   addptr(buf, 16);
7324   subl(len, 4); // len &gt; 0
7325   jcc(Assembler::less, L_fold_tail);
7326 
7327   movdqa(xmm2, Address(buf,  0));
7328   movdqa(xmm3, Address(buf, 16));
7329   movdqa(xmm4, Address(buf, 32));
7330   addptr(buf, 48);
7331   subl(len, 3);
7332   jcc(Assembler::lessEqual, L_fold_512b);
7333 
7334   // Fold total 512 bits of polynomial on each iteration,
7335   // 128 bits per each of 4 parallel streams.
7336   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 32));
7337 
7338   align(32);
7339   BIND(L_fold_512b_loop);
7340   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
7341   fold_128bit_crc32(xmm2, xmm0, xmm5, buf, 16);
7342   fold_128bit_crc32(xmm3, xmm0, xmm5, buf, 32);
7343   fold_128bit_crc32(xmm4, xmm0, xmm5, buf, 48);
7344   addptr(buf, 64);
7345   subl(len, 4);
7346   jcc(Assembler::greater, L_fold_512b_loop);
7347 
7348   // Fold 512 bits to 128 bits.
7349   BIND(L_fold_512b);
7350   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
7351   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm2);
7352   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm3);
7353   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm4);
7354 
7355   // Fold the rest of 128 bits data chunks
7356   BIND(L_fold_tail);
7357   addl(len, 3);
7358   jccb(Assembler::lessEqual, L_fold_128b);
7359   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
7360 
7361   BIND(L_fold_tail_loop);
7362   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
7363   addptr(buf, 16);
7364   decrementl(len);
7365   jccb(Assembler::greater, L_fold_tail_loop);
7366 
7367   // Fold 128 bits in xmm1 down into 32 bits in crc register.
7368   BIND(L_fold_128b);
7369   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr()));
7370   if (UseAVX &gt; 0) {
7371     vpclmulqdq(xmm2, xmm0, xmm1, 0x1);
7372     vpand(xmm3, xmm0, xmm2, 0 /* vector_len */);
7373     vpclmulqdq(xmm0, xmm0, xmm3, 0x1);
7374   } else {
7375     movdqa(xmm2, xmm0);
7376     pclmulqdq(xmm2, xmm1, 0x1);
7377     movdqa(xmm3, xmm0);
7378     pand(xmm3, xmm2);
7379     pclmulqdq(xmm0, xmm3, 0x1);
7380   }
7381   psrldq(xmm1, 8);
7382   psrldq(xmm2, 4);
7383   pxor(xmm0, xmm1);
7384   pxor(xmm0, xmm2);
7385 
7386   // 8 8-bit folds to compute 32-bit CRC.
7387   for (int j = 0; j &lt; 4; j++) {
7388     fold_8bit_crc32(xmm0, table, xmm1, rax);
7389   }
7390   movdl(crc, xmm0); // mov 32 bits to general register
7391   for (int j = 0; j &lt; 4; j++) {
7392     fold_8bit_crc32(crc, table, rax);
7393   }
7394 
7395   BIND(L_tail_restore);
7396   movl(len, tmp); // restore
7397   BIND(L_tail);
7398   andl(len, 0xf);
7399   jccb(Assembler::zero, L_exit);
7400 
7401   // Fold the rest of bytes
7402   align(4);
7403   BIND(L_tail_loop);
7404   movsbl(rax, Address(buf, 0)); // load byte with sign extension
7405   update_byte_crc32(crc, rax, table);
7406   increment(buf);
7407   decrementl(len);
7408   jccb(Assembler::greater, L_tail_loop);
7409 
7410   BIND(L_exit);
7411   notl(crc); // ~c
7412 }
7413 
7414 #ifdef _LP64
7415 // S. Gueron / Information Processing Letters 112 (2012) 184
7416 // Algorithm 4: Computing carry-less multiplication using a precomputed lookup table.
7417 // Input: A 32 bit value B = [byte3, byte2, byte1, byte0].
7418 // Output: the 64-bit carry-less product of B * CONST
7419 void MacroAssembler::crc32c_ipl_alg4(Register in, uint32_t n,
7420                                      Register tmp1, Register tmp2, Register tmp3) {
7421   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
7422   if (n &gt; 0) {
7423     addq(tmp3, n * 256 * 8);
7424   }
7425   //    Q1 = TABLEExt[n][B &amp; 0xFF];
7426   movl(tmp1, in);
7427   andl(tmp1, 0x000000FF);
7428   shll(tmp1, 3);
7429   addq(tmp1, tmp3);
7430   movq(tmp1, Address(tmp1, 0));
7431 
7432   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
7433   movl(tmp2, in);
7434   shrl(tmp2, 8);
7435   andl(tmp2, 0x000000FF);
7436   shll(tmp2, 3);
7437   addq(tmp2, tmp3);
7438   movq(tmp2, Address(tmp2, 0));
7439 
7440   shlq(tmp2, 8);
7441   xorq(tmp1, tmp2);
7442 
7443   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
7444   movl(tmp2, in);
7445   shrl(tmp2, 16);
7446   andl(tmp2, 0x000000FF);
7447   shll(tmp2, 3);
7448   addq(tmp2, tmp3);
7449   movq(tmp2, Address(tmp2, 0));
7450 
7451   shlq(tmp2, 16);
7452   xorq(tmp1, tmp2);
7453 
7454   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
7455   shrl(in, 24);
7456   andl(in, 0x000000FF);
7457   shll(in, 3);
7458   addq(in, tmp3);
7459   movq(in, Address(in, 0));
7460 
7461   shlq(in, 24);
7462   xorq(in, tmp1);
7463   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
7464 }
7465 
7466 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
7467                                       Register in_out,
7468                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
7469                                       XMMRegister w_xtmp2,
7470                                       Register tmp1,
7471                                       Register n_tmp2, Register n_tmp3) {
7472   if (is_pclmulqdq_supported) {
7473     movdl(w_xtmp1, in_out); // modified blindly
7474 
7475     movl(tmp1, const_or_pre_comp_const_index);
7476     movdl(w_xtmp2, tmp1);
7477     pclmulqdq(w_xtmp1, w_xtmp2, 0);
7478 
7479     movdq(in_out, w_xtmp1);
7480   } else {
7481     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3);
7482   }
7483 }
7484 
7485 // Recombination Alternative 2: No bit-reflections
7486 // T1 = (CRC_A * U1) &lt;&lt; 1
7487 // T2 = (CRC_B * U2) &lt;&lt; 1
7488 // C1 = T1 &gt;&gt; 32
7489 // C2 = T2 &gt;&gt; 32
7490 // T1 = T1 &amp; 0xFFFFFFFF
7491 // T2 = T2 &amp; 0xFFFFFFFF
7492 // T1 = CRC32(0, T1)
7493 // T2 = CRC32(0, T2)
7494 // C1 = C1 ^ T1
7495 // C2 = C2 ^ T2
7496 // CRC = C1 ^ C2 ^ CRC_C
7497 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
7498                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7499                                      Register tmp1, Register tmp2,
7500                                      Register n_tmp3) {
7501   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7502   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7503   shlq(in_out, 1);
7504   movl(tmp1, in_out);
7505   shrq(in_out, 32);
7506   xorl(tmp2, tmp2);
7507   crc32(tmp2, tmp1, 4);
7508   xorl(in_out, tmp2); // we don&#39;t care about upper 32 bit contents here
7509   shlq(in1, 1);
7510   movl(tmp1, in1);
7511   shrq(in1, 32);
7512   xorl(tmp2, tmp2);
7513   crc32(tmp2, tmp1, 4);
7514   xorl(in1, tmp2);
7515   xorl(in_out, in1);
7516   xorl(in_out, in2);
7517 }
7518 
7519 // Set N to predefined value
7520 // Subtract from a lenght of a buffer
7521 // execute in a loop:
7522 // CRC_A = 0xFFFFFFFF, CRC_B = 0, CRC_C = 0
7523 // for i = 1 to N do
7524 //  CRC_A = CRC32(CRC_A, A[i])
7525 //  CRC_B = CRC32(CRC_B, B[i])
7526 //  CRC_C = CRC32(CRC_C, C[i])
7527 // end for
7528 // Recombine
7529 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
7530                                        Register in_out1, Register in_out2, Register in_out3,
7531                                        Register tmp1, Register tmp2, Register tmp3,
7532                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7533                                        Register tmp4, Register tmp5,
7534                                        Register n_tmp6) {
7535   Label L_processPartitions;
7536   Label L_processPartition;
7537   Label L_exit;
7538 
7539   bind(L_processPartitions);
7540   cmpl(in_out1, 3 * size);
7541   jcc(Assembler::less, L_exit);
7542     xorl(tmp1, tmp1);
7543     xorl(tmp2, tmp2);
7544     movq(tmp3, in_out2);
7545     addq(tmp3, size);
7546 
7547     bind(L_processPartition);
7548       crc32(in_out3, Address(in_out2, 0), 8);
7549       crc32(tmp1, Address(in_out2, size), 8);
7550       crc32(tmp2, Address(in_out2, size * 2), 8);
7551       addq(in_out2, 8);
7552       cmpq(in_out2, tmp3);
7553       jcc(Assembler::less, L_processPartition);
7554     crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
7555             w_xtmp1, w_xtmp2, w_xtmp3,
7556             tmp4, tmp5,
7557             n_tmp6);
7558     addq(in_out2, 2 * size);
7559     subl(in_out1, 3 * size);
7560     jmp(L_processPartitions);
7561 
7562   bind(L_exit);
7563 }
7564 #else
7565 void MacroAssembler::crc32c_ipl_alg4(Register in_out, uint32_t n,
7566                                      Register tmp1, Register tmp2, Register tmp3,
7567                                      XMMRegister xtmp1, XMMRegister xtmp2) {
7568   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
7569   if (n &gt; 0) {
7570     addl(tmp3, n * 256 * 8);
7571   }
7572   //    Q1 = TABLEExt[n][B &amp; 0xFF];
7573   movl(tmp1, in_out);
7574   andl(tmp1, 0x000000FF);
7575   shll(tmp1, 3);
7576   addl(tmp1, tmp3);
7577   movq(xtmp1, Address(tmp1, 0));
7578 
7579   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
7580   movl(tmp2, in_out);
7581   shrl(tmp2, 8);
7582   andl(tmp2, 0x000000FF);
7583   shll(tmp2, 3);
7584   addl(tmp2, tmp3);
7585   movq(xtmp2, Address(tmp2, 0));
7586 
7587   psllq(xtmp2, 8);
7588   pxor(xtmp1, xtmp2);
7589 
7590   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
7591   movl(tmp2, in_out);
7592   shrl(tmp2, 16);
7593   andl(tmp2, 0x000000FF);
7594   shll(tmp2, 3);
7595   addl(tmp2, tmp3);
7596   movq(xtmp2, Address(tmp2, 0));
7597 
7598   psllq(xtmp2, 16);
7599   pxor(xtmp1, xtmp2);
7600 
7601   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
7602   shrl(in_out, 24);
7603   andl(in_out, 0x000000FF);
7604   shll(in_out, 3);
7605   addl(in_out, tmp3);
7606   movq(xtmp2, Address(in_out, 0));
7607 
7608   psllq(xtmp2, 24);
7609   pxor(xtmp1, xtmp2); // Result in CXMM
7610   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
7611 }
7612 
7613 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
7614                                       Register in_out,
7615                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
7616                                       XMMRegister w_xtmp2,
7617                                       Register tmp1,
7618                                       Register n_tmp2, Register n_tmp3) {
7619   if (is_pclmulqdq_supported) {
7620     movdl(w_xtmp1, in_out);
7621 
7622     movl(tmp1, const_or_pre_comp_const_index);
7623     movdl(w_xtmp2, tmp1);
7624     pclmulqdq(w_xtmp1, w_xtmp2, 0);
7625     // Keep result in XMM since GPR is 32 bit in length
7626   } else {
7627     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3, w_xtmp1, w_xtmp2);
7628   }
7629 }
7630 
7631 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
7632                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7633                                      Register tmp1, Register tmp2,
7634                                      Register n_tmp3) {
7635   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7636   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7637 
7638   psllq(w_xtmp1, 1);
7639   movdl(tmp1, w_xtmp1);
7640   psrlq(w_xtmp1, 32);
7641   movdl(in_out, w_xtmp1);
7642 
7643   xorl(tmp2, tmp2);
7644   crc32(tmp2, tmp1, 4);
7645   xorl(in_out, tmp2);
7646 
7647   psllq(w_xtmp2, 1);
7648   movdl(tmp1, w_xtmp2);
7649   psrlq(w_xtmp2, 32);
7650   movdl(in1, w_xtmp2);
7651 
7652   xorl(tmp2, tmp2);
7653   crc32(tmp2, tmp1, 4);
7654   xorl(in1, tmp2);
7655   xorl(in_out, in1);
7656   xorl(in_out, in2);
7657 }
7658 
7659 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
7660                                        Register in_out1, Register in_out2, Register in_out3,
7661                                        Register tmp1, Register tmp2, Register tmp3,
7662                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7663                                        Register tmp4, Register tmp5,
7664                                        Register n_tmp6) {
7665   Label L_processPartitions;
7666   Label L_processPartition;
7667   Label L_exit;
7668 
7669   bind(L_processPartitions);
7670   cmpl(in_out1, 3 * size);
7671   jcc(Assembler::less, L_exit);
7672     xorl(tmp1, tmp1);
7673     xorl(tmp2, tmp2);
7674     movl(tmp3, in_out2);
7675     addl(tmp3, size);
7676 
7677     bind(L_processPartition);
7678       crc32(in_out3, Address(in_out2, 0), 4);
7679       crc32(tmp1, Address(in_out2, size), 4);
7680       crc32(tmp2, Address(in_out2, size*2), 4);
7681       crc32(in_out3, Address(in_out2, 0+4), 4);
7682       crc32(tmp1, Address(in_out2, size+4), 4);
7683       crc32(tmp2, Address(in_out2, size*2+4), 4);
7684       addl(in_out2, 8);
7685       cmpl(in_out2, tmp3);
7686       jcc(Assembler::less, L_processPartition);
7687 
7688         push(tmp3);
7689         push(in_out1);
7690         push(in_out2);
7691         tmp4 = tmp3;
7692         tmp5 = in_out1;
7693         n_tmp6 = in_out2;
7694 
7695       crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
7696             w_xtmp1, w_xtmp2, w_xtmp3,
7697             tmp4, tmp5,
7698             n_tmp6);
7699 
7700         pop(in_out2);
7701         pop(in_out1);
7702         pop(tmp3);
7703 
7704     addl(in_out2, 2 * size);
7705     subl(in_out1, 3 * size);
7706     jmp(L_processPartitions);
7707 
7708   bind(L_exit);
7709 }
7710 #endif //LP64
7711 
7712 #ifdef _LP64
7713 // Algorithm 2: Pipelined usage of the CRC32 instruction.
7714 // Input: A buffer I of L bytes.
7715 // Output: the CRC32C value of the buffer.
7716 // Notations:
7717 // Write L = 24N + r, with N = floor (L/24).
7718 // r = L mod 24 (0 &lt;= r &lt; 24).
7719 // Consider I as the concatenation of A|B|C|R, where A, B, C, each,
7720 // N quadwords, and R consists of r bytes.
7721 // A[j] = I [8j+7:8j], j= 0, 1, ..., N-1
7722 // B[j] = I [N + 8j+7:N + 8j], j= 0, 1, ..., N-1
7723 // C[j] = I [2N + 8j+7:2N + 8j], j= 0, 1, ..., N-1
7724 // if r &gt; 0 R[j] = I [3N +j], j= 0, 1, ...,r-1
7725 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
7726                                           Register tmp1, Register tmp2, Register tmp3,
7727                                           Register tmp4, Register tmp5, Register tmp6,
7728                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7729                                           bool is_pclmulqdq_supported) {
7730   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
7731   Label L_wordByWord;
7732   Label L_byteByByteProlog;
7733   Label L_byteByByte;
7734   Label L_exit;
7735 
7736   if (is_pclmulqdq_supported ) {
7737     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
7738     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr+1);
7739 
7740     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
7741     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
7742 
7743     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
7744     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
7745     assert((CRC32C_NUM_PRECOMPUTED_CONSTANTS - 1 ) == 5, &quot;Checking whether you declared all of the constants based on the number of \&quot;chunks\&quot;&quot;);
7746   } else {
7747     const_or_pre_comp_const_index[0] = 1;
7748     const_or_pre_comp_const_index[1] = 0;
7749 
7750     const_or_pre_comp_const_index[2] = 3;
7751     const_or_pre_comp_const_index[3] = 2;
7752 
7753     const_or_pre_comp_const_index[4] = 5;
7754     const_or_pre_comp_const_index[5] = 4;
7755    }
7756   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
7757                     in2, in1, in_out,
7758                     tmp1, tmp2, tmp3,
7759                     w_xtmp1, w_xtmp2, w_xtmp3,
7760                     tmp4, tmp5,
7761                     tmp6);
7762   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
7763                     in2, in1, in_out,
7764                     tmp1, tmp2, tmp3,
7765                     w_xtmp1, w_xtmp2, w_xtmp3,
7766                     tmp4, tmp5,
7767                     tmp6);
7768   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
7769                     in2, in1, in_out,
7770                     tmp1, tmp2, tmp3,
7771                     w_xtmp1, w_xtmp2, w_xtmp3,
7772                     tmp4, tmp5,
7773                     tmp6);
7774   movl(tmp1, in2);
7775   andl(tmp1, 0x00000007);
7776   negl(tmp1);
7777   addl(tmp1, in2);
7778   addq(tmp1, in1);
7779 
7780   BIND(L_wordByWord);
7781   cmpq(in1, tmp1);
7782   jcc(Assembler::greaterEqual, L_byteByByteProlog);
7783     crc32(in_out, Address(in1, 0), 4);
7784     addq(in1, 4);
7785     jmp(L_wordByWord);
7786 
7787   BIND(L_byteByByteProlog);
7788   andl(in2, 0x00000007);
7789   movl(tmp2, 1);
7790 
7791   BIND(L_byteByByte);
7792   cmpl(tmp2, in2);
7793   jccb(Assembler::greater, L_exit);
7794     crc32(in_out, Address(in1, 0), 1);
7795     incq(in1);
7796     incl(tmp2);
7797     jmp(L_byteByByte);
7798 
7799   BIND(L_exit);
7800 }
7801 #else
7802 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
7803                                           Register tmp1, Register  tmp2, Register tmp3,
7804                                           Register tmp4, Register  tmp5, Register tmp6,
7805                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7806                                           bool is_pclmulqdq_supported) {
7807   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
7808   Label L_wordByWord;
7809   Label L_byteByByteProlog;
7810   Label L_byteByByte;
7811   Label L_exit;
7812 
7813   if (is_pclmulqdq_supported) {
7814     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
7815     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 1);
7816 
7817     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
7818     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
7819 
7820     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
7821     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
7822   } else {
7823     const_or_pre_comp_const_index[0] = 1;
7824     const_or_pre_comp_const_index[1] = 0;
7825 
7826     const_or_pre_comp_const_index[2] = 3;
7827     const_or_pre_comp_const_index[3] = 2;
7828 
7829     const_or_pre_comp_const_index[4] = 5;
7830     const_or_pre_comp_const_index[5] = 4;
7831   }
7832   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
7833                     in2, in1, in_out,
7834                     tmp1, tmp2, tmp3,
7835                     w_xtmp1, w_xtmp2, w_xtmp3,
7836                     tmp4, tmp5,
7837                     tmp6);
7838   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
7839                     in2, in1, in_out,
7840                     tmp1, tmp2, tmp3,
7841                     w_xtmp1, w_xtmp2, w_xtmp3,
7842                     tmp4, tmp5,
7843                     tmp6);
7844   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
7845                     in2, in1, in_out,
7846                     tmp1, tmp2, tmp3,
7847                     w_xtmp1, w_xtmp2, w_xtmp3,
7848                     tmp4, tmp5,
7849                     tmp6);
7850   movl(tmp1, in2);
7851   andl(tmp1, 0x00000007);
7852   negl(tmp1);
7853   addl(tmp1, in2);
7854   addl(tmp1, in1);
7855 
7856   BIND(L_wordByWord);
7857   cmpl(in1, tmp1);
7858   jcc(Assembler::greaterEqual, L_byteByByteProlog);
7859     crc32(in_out, Address(in1,0), 4);
7860     addl(in1, 4);
7861     jmp(L_wordByWord);
7862 
7863   BIND(L_byteByByteProlog);
7864   andl(in2, 0x00000007);
7865   movl(tmp2, 1);
7866 
7867   BIND(L_byteByByte);
7868   cmpl(tmp2, in2);
7869   jccb(Assembler::greater, L_exit);
7870     movb(tmp1, Address(in1, 0));
7871     crc32(in_out, tmp1, 1);
7872     incl(in1);
7873     incl(tmp2);
7874     jmp(L_byteByByte);
7875 
7876   BIND(L_exit);
7877 }
7878 #endif // LP64
7879 #undef BIND
7880 #undef BLOCK_COMMENT
7881 
7882 // Compress char[] array to byte[].
7883 //   ..\jdk\src\java.base\share\classes\java\lang\StringUTF16.java
7884 //   @HotSpotIntrinsicCandidate
7885 //   private static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {
7886 //     for (int i = 0; i &lt; len; i++) {
7887 //       int c = src[srcOff++];
7888 //       if (c &gt;&gt;&gt; 8 != 0) {
7889 //         return 0;
7890 //       }
7891 //       dst[dstOff++] = (byte)c;
7892 //     }
7893 //     return len;
7894 //   }
7895 void MacroAssembler::char_array_compress(Register src, Register dst, Register len,
7896   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
7897   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
7898   Register tmp5, Register result) {
7899   Label copy_chars_loop, return_length, return_zero, done;
7900 
7901   // rsi: src
7902   // rdi: dst
7903   // rdx: len
7904   // rcx: tmp5
7905   // rax: result
7906 
7907   // rsi holds start addr of source char[] to be compressed
7908   // rdi holds start addr of destination byte[]
7909   // rdx holds length
7910 
7911   assert(len != result, &quot;&quot;);
7912 
7913   // save length for return
7914   push(len);
7915 
7916   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp; // AVX512
7917     VM_Version::supports_avx512vlbw() &amp;&amp;
7918     VM_Version::supports_bmi2()) {
7919 
7920     Label copy_32_loop, copy_loop_tail, below_threshold;
7921 
7922     // alignment
7923     Label post_alignment;
7924 
7925     // if length of the string is less than 16, handle it in an old fashioned way
7926     testl(len, -32);
7927     jcc(Assembler::zero, below_threshold);
7928 
7929     // First check whether a character is compressable ( &lt;= 0xFF).
7930     // Create mask to test for Unicode chars inside zmm vector
7931     movl(result, 0x00FF);
7932     evpbroadcastw(tmp2Reg, result, Assembler::AVX_512bit);
7933 
7934     testl(len, -64);
7935     jcc(Assembler::zero, post_alignment);
7936 
7937     movl(tmp5, dst);
7938     andl(tmp5, (32 - 1));
7939     negl(tmp5);
7940     andl(tmp5, (32 - 1));
7941 
7942     // bail out when there is nothing to be done
7943     testl(tmp5, 0xFFFFFFFF);
7944     jcc(Assembler::zero, post_alignment);
7945 
7946     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
7947     movl(result, 0xFFFFFFFF);
7948     shlxl(result, result, tmp5);
7949     notl(result);
7950     kmovdl(k3, result);
7951 
7952     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
7953     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
7954     ktestd(k2, k3);
7955     jcc(Assembler::carryClear, return_zero);
7956 
7957     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
7958 
7959     addptr(src, tmp5);
7960     addptr(src, tmp5);
7961     addptr(dst, tmp5);
7962     subl(len, tmp5);
7963 
7964     bind(post_alignment);
7965     // end of alignment
7966 
7967     movl(tmp5, len);
7968     andl(tmp5, (32 - 1));    // tail count (in chars)
7969     andl(len, ~(32 - 1));    // vector count (in chars)
7970     jcc(Assembler::zero, copy_loop_tail);
7971 
7972     lea(src, Address(src, len, Address::times_2));
7973     lea(dst, Address(dst, len, Address::times_1));
7974     negptr(len);
7975 
7976     bind(copy_32_loop);
7977     evmovdquw(tmp1Reg, Address(src, len, Address::times_2), Assembler::AVX_512bit);
7978     evpcmpuw(k2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
7979     kortestdl(k2, k2);
7980     jcc(Assembler::carryClear, return_zero);
7981 
7982     // All elements in current processed chunk are valid candidates for
7983     // compression. Write a truncated byte elements to the memory.
7984     evpmovwb(Address(dst, len, Address::times_1), tmp1Reg, Assembler::AVX_512bit);
7985     addptr(len, 32);
7986     jcc(Assembler::notZero, copy_32_loop);
7987 
7988     bind(copy_loop_tail);
7989     // bail out when there is nothing to be done
7990     testl(tmp5, 0xFFFFFFFF);
7991     jcc(Assembler::zero, return_length);
7992 
7993     movl(len, tmp5);
7994 
7995     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
7996     movl(result, 0xFFFFFFFF);
7997     shlxl(result, result, len);
7998     notl(result);
7999 
8000     kmovdl(k3, result);
8001 
8002     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
8003     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
8004     ktestd(k2, k3);
8005     jcc(Assembler::carryClear, return_zero);
8006 
8007     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
8008     jmp(return_length);
8009 
8010     bind(below_threshold);
8011   }
8012 
8013   if (UseSSE42Intrinsics) {
8014     Label copy_32_loop, copy_16, copy_tail;
8015 
8016     movl(result, len);
8017 
8018     movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vectors
8019 
8020     // vectored compression
8021     andl(len, 0xfffffff0);    // vector count (in chars)
8022     andl(result, 0x0000000f);    // tail count (in chars)
8023     testl(len, len);
8024     jcc(Assembler::zero, copy_16);
8025 
8026     // compress 16 chars per iter
8027     movdl(tmp1Reg, tmp5);
8028     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
8029     pxor(tmp4Reg, tmp4Reg);
8030 
8031     lea(src, Address(src, len, Address::times_2));
8032     lea(dst, Address(dst, len, Address::times_1));
8033     negptr(len);
8034 
8035     bind(copy_32_loop);
8036     movdqu(tmp2Reg, Address(src, len, Address::times_2));     // load 1st 8 characters
8037     por(tmp4Reg, tmp2Reg);
8038     movdqu(tmp3Reg, Address(src, len, Address::times_2, 16)); // load next 8 characters
8039     por(tmp4Reg, tmp3Reg);
8040     ptest(tmp4Reg, tmp1Reg);       // check for Unicode chars in next vector
8041     jcc(Assembler::notZero, return_zero);
8042     packuswb(tmp2Reg, tmp3Reg);    // only ASCII chars; compress each to 1 byte
8043     movdqu(Address(dst, len, Address::times_1), tmp2Reg);
8044     addptr(len, 16);
8045     jcc(Assembler::notZero, copy_32_loop);
8046 
8047     // compress next vector of 8 chars (if any)
8048     bind(copy_16);
8049     movl(len, result);
8050     andl(len, 0xfffffff8);    // vector count (in chars)
8051     andl(result, 0x00000007);    // tail count (in chars)
8052     testl(len, len);
8053     jccb(Assembler::zero, copy_tail);
8054 
8055     movdl(tmp1Reg, tmp5);
8056     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
8057     pxor(tmp3Reg, tmp3Reg);
8058 
8059     movdqu(tmp2Reg, Address(src, 0));
8060     ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in vector
8061     jccb(Assembler::notZero, return_zero);
8062     packuswb(tmp2Reg, tmp3Reg);    // only LATIN1 chars; compress each to 1 byte
8063     movq(Address(dst, 0), tmp2Reg);
8064     addptr(src, 16);
8065     addptr(dst, 8);
8066 
8067     bind(copy_tail);
8068     movl(len, result);
8069   }
8070   // compress 1 char per iter
8071   testl(len, len);
8072   jccb(Assembler::zero, return_length);
8073   lea(src, Address(src, len, Address::times_2));
8074   lea(dst, Address(dst, len, Address::times_1));
8075   negptr(len);
8076 
8077   bind(copy_chars_loop);
8078   load_unsigned_short(result, Address(src, len, Address::times_2));
8079   testl(result, 0xff00);      // check if Unicode char
8080   jccb(Assembler::notZero, return_zero);
8081   movb(Address(dst, len, Address::times_1), result);  // ASCII char; compress to 1 byte
8082   increment(len);
8083   jcc(Assembler::notZero, copy_chars_loop);
8084 
8085   // if compression succeeded, return length
8086   bind(return_length);
8087   pop(result);
8088   jmpb(done);
8089 
8090   // if compression failed, return 0
8091   bind(return_zero);
8092   xorl(result, result);
8093   addptr(rsp, wordSize);
8094 
8095   bind(done);
8096 }
8097 
8098 // Inflate byte[] array to char[].
8099 //   ..\jdk\src\java.base\share\classes\java\lang\StringLatin1.java
8100 //   @HotSpotIntrinsicCandidate
8101 //   private static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len) {
8102 //     for (int i = 0; i &lt; len; i++) {
8103 //       dst[dstOff++] = (char)(src[srcOff++] &amp; 0xff);
8104 //     }
8105 //   }
8106 void MacroAssembler::byte_array_inflate(Register src, Register dst, Register len,
8107   XMMRegister tmp1, Register tmp2) {
8108   Label copy_chars_loop, done, below_threshold, avx3_threshold;
8109   // rsi: src
8110   // rdi: dst
8111   // rdx: len
8112   // rcx: tmp2
8113 
8114   // rsi holds start addr of source byte[] to be inflated
8115   // rdi holds start addr of destination char[]
8116   // rdx holds length
8117   assert_different_registers(src, dst, len, tmp2);
8118   movl(tmp2, len);
8119   if ((UseAVX &gt; 2) &amp;&amp; // AVX512
8120     VM_Version::supports_avx512vlbw() &amp;&amp;
8121     VM_Version::supports_bmi2()) {
8122 
8123     Label copy_32_loop, copy_tail;
8124     Register tmp3_aliased = len;
8125 
8126     // if length of the string is less than 16, handle it in an old fashioned way
8127     testl(len, -16);
8128     jcc(Assembler::zero, below_threshold);
8129 
8130     testl(len, -1 * AVX3Threshold);
8131     jcc(Assembler::zero, avx3_threshold);
8132 
8133     // In order to use only one arithmetic operation for the main loop we use
8134     // this pre-calculation
8135     andl(tmp2, (32 - 1)); // tail count (in chars), 32 element wide loop
8136     andl(len, -32);     // vector count
8137     jccb(Assembler::zero, copy_tail);
8138 
8139     lea(src, Address(src, len, Address::times_1));
8140     lea(dst, Address(dst, len, Address::times_2));
8141     negptr(len);
8142 
8143 
8144     // inflate 32 chars per iter
8145     bind(copy_32_loop);
8146     vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_512bit);
8147     evmovdquw(Address(dst, len, Address::times_2), tmp1, Assembler::AVX_512bit);
8148     addptr(len, 32);
8149     jcc(Assembler::notZero, copy_32_loop);
8150 
8151     bind(copy_tail);
8152     // bail out when there is nothing to be done
8153     testl(tmp2, -1); // we don&#39;t destroy the contents of tmp2 here
8154     jcc(Assembler::zero, done);
8155 
8156     // ~(~0 &lt;&lt; length), where length is the # of remaining elements to process
8157     movl(tmp3_aliased, -1);
8158     shlxl(tmp3_aliased, tmp3_aliased, tmp2);
8159     notl(tmp3_aliased);
8160     kmovdl(k2, tmp3_aliased);
8161     evpmovzxbw(tmp1, k2, Address(src, 0), Assembler::AVX_512bit);
8162     evmovdquw(Address(dst, 0), k2, tmp1, Assembler::AVX_512bit);
8163 
8164     jmp(done);
8165     bind(avx3_threshold);
8166   }
8167   if (UseSSE42Intrinsics) {
8168     Label copy_16_loop, copy_8_loop, copy_bytes, copy_new_tail, copy_tail;
8169 
8170     if (UseAVX &gt; 1) {
8171       andl(tmp2, (16 - 1));
8172       andl(len, -16);
8173       jccb(Assembler::zero, copy_new_tail);
8174     } else {
8175       andl(tmp2, 0x00000007);   // tail count (in chars)
8176       andl(len, 0xfffffff8);    // vector count (in chars)
8177       jccb(Assembler::zero, copy_tail);
8178     }
8179 
8180     // vectored inflation
8181     lea(src, Address(src, len, Address::times_1));
8182     lea(dst, Address(dst, len, Address::times_2));
8183     negptr(len);
8184 
8185     if (UseAVX &gt; 1) {
8186       bind(copy_16_loop);
8187       vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_256bit);
8188       vmovdqu(Address(dst, len, Address::times_2), tmp1);
8189       addptr(len, 16);
8190       jcc(Assembler::notZero, copy_16_loop);
8191 
8192       bind(below_threshold);
8193       bind(copy_new_tail);
8194       movl(len, tmp2);
8195       andl(tmp2, 0x00000007);
8196       andl(len, 0xFFFFFFF8);
8197       jccb(Assembler::zero, copy_tail);
8198 
8199       pmovzxbw(tmp1, Address(src, 0));
8200       movdqu(Address(dst, 0), tmp1);
8201       addptr(src, 8);
8202       addptr(dst, 2 * 8);
8203 
8204       jmp(copy_tail, true);
8205     }
8206 
8207     // inflate 8 chars per iter
8208     bind(copy_8_loop);
8209     pmovzxbw(tmp1, Address(src, len, Address::times_1));  // unpack to 8 words
8210     movdqu(Address(dst, len, Address::times_2), tmp1);
8211     addptr(len, 8);
8212     jcc(Assembler::notZero, copy_8_loop);
8213 
8214     bind(copy_tail);
8215     movl(len, tmp2);
8216 
8217     cmpl(len, 4);
8218     jccb(Assembler::less, copy_bytes);
8219 
8220     movdl(tmp1, Address(src, 0));  // load 4 byte chars
8221     pmovzxbw(tmp1, tmp1);
8222     movq(Address(dst, 0), tmp1);
8223     subptr(len, 4);
8224     addptr(src, 4);
8225     addptr(dst, 8);
8226 
8227     bind(copy_bytes);
8228   } else {
8229     bind(below_threshold);
8230   }
8231 
8232   testl(len, len);
8233   jccb(Assembler::zero, done);
8234   lea(src, Address(src, len, Address::times_1));
8235   lea(dst, Address(dst, len, Address::times_2));
8236   negptr(len);
8237 
8238   // inflate 1 char per iter
8239   bind(copy_chars_loop);
8240   load_unsigned_byte(tmp2, Address(src, len, Address::times_1));  // load byte char
8241   movw(Address(dst, len, Address::times_2), tmp2);  // inflate byte char to word
8242   increment(len);
8243   jcc(Assembler::notZero, copy_chars_loop);
8244 
8245   bind(done);
8246 }
8247 
8248 #ifdef _LP64
8249 void MacroAssembler::convert_f2i(Register dst, XMMRegister src) {
8250   Label done;
8251   cvttss2sil(dst, src);
8252   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
8253   cmpl(dst, 0x80000000); // float_sign_flip
8254   jccb(Assembler::notEqual, done);
8255   subptr(rsp, 8);
8256   movflt(Address(rsp, 0), src);
8257   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));
8258   pop(dst);
8259   bind(done);
8260 }
8261 
8262 void MacroAssembler::convert_d2i(Register dst, XMMRegister src) {
8263   Label done;
8264   cvttsd2sil(dst, src);
8265   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
8266   cmpl(dst, 0x80000000); // float_sign_flip
8267   jccb(Assembler::notEqual, done);
8268   subptr(rsp, 8);
8269   movdbl(Address(rsp, 0), src);
8270   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));
8271   pop(dst);
8272   bind(done);
8273 }
8274 
8275 void MacroAssembler::convert_f2l(Register dst, XMMRegister src) {
8276   Label done;
8277   cvttss2siq(dst, src);
8278   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
8279   jccb(Assembler::notEqual, done);
8280   subptr(rsp, 8);
8281   movflt(Address(rsp, 0), src);
8282   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));
8283   pop(dst);
8284   bind(done);
8285 }
8286 
8287 void MacroAssembler::convert_d2l(Register dst, XMMRegister src) {
8288   Label done;
8289   cvttsd2siq(dst, src);
8290   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
8291   jccb(Assembler::notEqual, done);
8292   subptr(rsp, 8);
8293   movdbl(Address(rsp, 0), src);
8294   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));
8295   pop(dst);
8296   bind(done);
8297 }
8298 
8299 void MacroAssembler::cache_wb(Address line)
8300 {
8301   // 64 bit cpus always support clflush
8302   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
8303   bool optimized = VM_Version::supports_clflushopt();
8304   bool no_evict = VM_Version::supports_clwb();
8305 
8306   // prefer clwb (writeback without evict) otherwise
8307   // prefer clflushopt (potentially parallel writeback with evict)
8308   // otherwise fallback on clflush (serial writeback with evict)
8309 
8310   if (optimized) {
8311     if (no_evict) {
8312       clwb(line);
8313     } else {
8314       clflushopt(line);
8315     }
8316   } else {
8317     // no need for fence when using CLFLUSH
8318     clflush(line);
8319   }
8320 }
8321 
8322 void MacroAssembler::cache_wbsync(bool is_pre)
8323 {
8324   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
8325   bool optimized = VM_Version::supports_clflushopt();
8326   bool no_evict = VM_Version::supports_clwb();
8327 
8328   // pick the correct implementation
8329 
8330   if (!is_pre &amp;&amp; (optimized || no_evict)) {
8331     // need an sfence for post flush when using clflushopt or clwb
8332     // otherwise no no need for any synchroniaztion
8333 
8334     sfence();
8335   }
8336 }
8337 #endif // _LP64
8338 
8339 Assembler::Condition MacroAssembler::negate_condition(Assembler::Condition cond) {
8340   switch (cond) {
8341     // Note some conditions are synonyms for others
8342     case Assembler::zero:         return Assembler::notZero;
8343     case Assembler::notZero:      return Assembler::zero;
8344     case Assembler::less:         return Assembler::greaterEqual;
8345     case Assembler::lessEqual:    return Assembler::greater;
8346     case Assembler::greater:      return Assembler::lessEqual;
8347     case Assembler::greaterEqual: return Assembler::less;
8348     case Assembler::below:        return Assembler::aboveEqual;
8349     case Assembler::belowEqual:   return Assembler::above;
8350     case Assembler::above:        return Assembler::belowEqual;
8351     case Assembler::aboveEqual:   return Assembler::below;
8352     case Assembler::overflow:     return Assembler::noOverflow;
8353     case Assembler::noOverflow:   return Assembler::overflow;
8354     case Assembler::negative:     return Assembler::positive;
8355     case Assembler::positive:     return Assembler::negative;
8356     case Assembler::parity:       return Assembler::noParity;
8357     case Assembler::noParity:     return Assembler::parity;
8358   }
8359   ShouldNotReachHere(); return Assembler::overflow;
8360 }
8361 
8362 SkipIfEqual::SkipIfEqual(
8363     MacroAssembler* masm, const bool* flag_addr, bool value) {
8364   _masm = masm;
8365   _masm-&gt;cmp8(ExternalAddress((address)flag_addr), value);
8366   _masm-&gt;jcc(Assembler::equal, _label);
8367 }
8368 
8369 SkipIfEqual::~SkipIfEqual() {
8370   _masm-&gt;bind(_label);
8371 }
8372 
8373 // 32-bit Windows has its own fast-path implementation
8374 // of get_thread
8375 #if !defined(WIN32) || defined(_LP64)
8376 
8377 // This is simply a call to Thread::current()
8378 void MacroAssembler::get_thread(Register thread) {
8379   if (thread != rax) {
8380     push(rax);
8381   }
8382   LP64_ONLY(push(rdi);)
8383   LP64_ONLY(push(rsi);)
8384   push(rdx);
8385   push(rcx);
8386 #ifdef _LP64
8387   push(r8);
8388   push(r9);
8389   push(r10);
8390   push(r11);
8391 #endif
8392 
8393   MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, Thread::current), 0);
8394 
8395 #ifdef _LP64
8396   pop(r11);
8397   pop(r10);
8398   pop(r9);
8399   pop(r8);
8400 #endif
8401   pop(rcx);
8402   pop(rdx);
8403   LP64_ONLY(pop(rsi);)
8404   LP64_ONLY(pop(rdi);)
8405   if (thread != rax) {
8406     mov(thread, rax);
8407     pop(rax);
8408   }
8409 }
8410 
8411 #endif // !WIN32 || _LP64
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
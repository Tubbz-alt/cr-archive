<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2609     // Note: should probably use testl(rax, Address(reg, 0));
2610     //       may be shorter code (however, this version of
2611     //       testl needs to be implemented first)
2612   } else {
2613     // nothing to do, (later) access of M[reg + offset]
2614     // will provoke OS NULL exception if reg = NULL
2615   }
2616 }
2617 
2618 void MacroAssembler::test_klass_is_value(Register klass, Register temp_reg, Label&amp; is_value) {
2619   movl(temp_reg, Address(klass, Klass::access_flags_offset()));
2620   testl(temp_reg, JVM_ACC_VALUE);
2621   jcc(Assembler::notZero, is_value);
2622 }
2623 
2624 void MacroAssembler::test_klass_is_empty_value(Register klass, Register temp_reg, Label&amp; is_empty_value) {
2625 #ifdef ASSERT
2626   {
2627     Label done_check;
2628     test_klass_is_value(klass, temp_reg, done_check);
<span class="line-modified">2629     stop(&quot;test_klass_is_empty_value with none value klass&quot;);</span>
2630     bind(done_check);
2631   }
2632 #endif
2633   movl(temp_reg, Address(klass, InstanceKlass::misc_flags_offset()));
2634   testl(temp_reg, InstanceKlass::misc_flags_is_empty_value());
2635   jcc(Assembler::notZero, is_empty_value);
2636 }
2637 
2638 void MacroAssembler::test_field_is_flattenable(Register flags, Register temp_reg, Label&amp; is_flattenable) {
2639   movl(temp_reg, flags);
2640   shrl(temp_reg, ConstantPoolCacheEntry::is_flattenable_field_shift);
2641   andl(temp_reg, 0x1);
2642   testl(temp_reg, temp_reg);
2643   jcc(Assembler::notZero, is_flattenable);
2644 }
2645 
2646 void MacroAssembler::test_field_is_not_flattenable(Register flags, Register temp_reg, Label&amp; notFlattenable) {
2647   movl(temp_reg, flags);
2648   shrl(temp_reg, ConstantPoolCacheEntry::is_flattenable_field_shift);
2649   andl(temp_reg, 0x1);
2650   testl(temp_reg, temp_reg);
2651   jcc(Assembler::zero, notFlattenable);
2652 }
2653 
2654 void MacroAssembler::test_field_is_flattened(Register flags, Register temp_reg, Label&amp; is_flattened) {
2655   movl(temp_reg, flags);
2656   shrl(temp_reg, ConstantPoolCacheEntry::is_flattened_field_shift);
2657   andl(temp_reg, 0x1);
2658   testl(temp_reg, temp_reg);
2659   jcc(Assembler::notZero, is_flattened);
2660 }
2661 
2662 void MacroAssembler::test_flattened_array_oop(Register oop, Register temp_reg,
2663                                               Label&amp;is_flattened_array) {
<span class="line-modified">2664   load_storage_props(temp_reg, oop);</span>
<span class="line-modified">2665   testb(temp_reg, ArrayStorageProperties::flattened_value);</span>
<span class="line-modified">2666   jcc(Assembler::notZero, is_flattened_array);</span>
2667 }
2668 
2669 void MacroAssembler::test_non_flattened_array_oop(Register oop, Register temp_reg,
2670                                                   Label&amp;is_non_flattened_array) {
<span class="line-modified">2671   load_storage_props(temp_reg, oop);</span>
<span class="line-modified">2672   testb(temp_reg, ArrayStorageProperties::flattened_value);</span>
<span class="line-modified">2673   jcc(Assembler::zero, is_non_flattened_array);</span>
2674 }
2675 
2676 void MacroAssembler::test_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_null_free_array) {
<span class="line-modified">2677   load_storage_props(temp_reg, oop);</span>
<span class="line-modified">2678   testb(temp_reg, ArrayStorageProperties::null_free_value);</span>
<span class="line-modified">2679   jcc(Assembler::notZero, is_null_free_array);</span>
2680 }
2681 
2682 void MacroAssembler::test_non_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_non_null_free_array) {
<span class="line-modified">2683   load_storage_props(temp_reg, oop);</span>
<span class="line-modified">2684   testb(temp_reg, ArrayStorageProperties::null_free_value);</span>



















2685   jcc(Assembler::zero, is_non_null_free_array);
2686 }
2687 

2688 void MacroAssembler::os_breakpoint() {
2689   // instead of directly emitting a breakpoint, call os:breakpoint for better debugability
2690   // (e.g., MSVC can&#39;t call ps() otherwise)
2691   call(RuntimeAddress(CAST_FROM_FN_PTR(address, os::breakpoint)));
2692 }
2693 
2694 void MacroAssembler::unimplemented(const char* what) {
2695   const char* buf = NULL;
2696   {
2697     ResourceMark rm;
2698     stringStream ss;
2699     ss.print(&quot;unimplemented: %s&quot;, what);
2700     buf = code_string(ss.as_string());
2701   }
2702   stop(buf);
2703 }
2704 
2705 #ifdef _LP64
2706 #define XSTATE_BV 0x200
2707 #endif
</pre>
</td>
<td>
<hr />
<pre>
2609     // Note: should probably use testl(rax, Address(reg, 0));
2610     //       may be shorter code (however, this version of
2611     //       testl needs to be implemented first)
2612   } else {
2613     // nothing to do, (later) access of M[reg + offset]
2614     // will provoke OS NULL exception if reg = NULL
2615   }
2616 }
2617 
2618 void MacroAssembler::test_klass_is_value(Register klass, Register temp_reg, Label&amp; is_value) {
2619   movl(temp_reg, Address(klass, Klass::access_flags_offset()));
2620   testl(temp_reg, JVM_ACC_VALUE);
2621   jcc(Assembler::notZero, is_value);
2622 }
2623 
2624 void MacroAssembler::test_klass_is_empty_value(Register klass, Register temp_reg, Label&amp; is_empty_value) {
2625 #ifdef ASSERT
2626   {
2627     Label done_check;
2628     test_klass_is_value(klass, temp_reg, done_check);
<span class="line-modified">2629     stop(&quot;test_klass_is_empty_value with non value klass&quot;);</span>
2630     bind(done_check);
2631   }
2632 #endif
2633   movl(temp_reg, Address(klass, InstanceKlass::misc_flags_offset()));
2634   testl(temp_reg, InstanceKlass::misc_flags_is_empty_value());
2635   jcc(Assembler::notZero, is_empty_value);
2636 }
2637 
2638 void MacroAssembler::test_field_is_flattenable(Register flags, Register temp_reg, Label&amp; is_flattenable) {
2639   movl(temp_reg, flags);
2640   shrl(temp_reg, ConstantPoolCacheEntry::is_flattenable_field_shift);
2641   andl(temp_reg, 0x1);
2642   testl(temp_reg, temp_reg);
2643   jcc(Assembler::notZero, is_flattenable);
2644 }
2645 
2646 void MacroAssembler::test_field_is_not_flattenable(Register flags, Register temp_reg, Label&amp; notFlattenable) {
2647   movl(temp_reg, flags);
2648   shrl(temp_reg, ConstantPoolCacheEntry::is_flattenable_field_shift);
2649   andl(temp_reg, 0x1);
2650   testl(temp_reg, temp_reg);
2651   jcc(Assembler::zero, notFlattenable);
2652 }
2653 
2654 void MacroAssembler::test_field_is_flattened(Register flags, Register temp_reg, Label&amp; is_flattened) {
2655   movl(temp_reg, flags);
2656   shrl(temp_reg, ConstantPoolCacheEntry::is_flattened_field_shift);
2657   andl(temp_reg, 0x1);
2658   testl(temp_reg, temp_reg);
2659   jcc(Assembler::notZero, is_flattened);
2660 }
2661 
2662 void MacroAssembler::test_flattened_array_oop(Register oop, Register temp_reg,
2663                                               Label&amp;is_flattened_array) {
<span class="line-modified">2664   load_klass(temp_reg, oop);</span>
<span class="line-modified">2665   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));</span>
<span class="line-modified">2666   test_flattened_array_layout(temp_reg, is_flattened_array);</span>
2667 }
2668 
2669 void MacroAssembler::test_non_flattened_array_oop(Register oop, Register temp_reg,
2670                                                   Label&amp;is_non_flattened_array) {
<span class="line-modified">2671   load_klass(temp_reg, oop);</span>
<span class="line-modified">2672   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));</span>
<span class="line-modified">2673   test_non_flattened_array_layout(temp_reg, is_non_flattened_array);</span>
2674 }
2675 
2676 void MacroAssembler::test_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_null_free_array) {
<span class="line-modified">2677   load_klass(temp_reg, oop);</span>
<span class="line-modified">2678   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));</span>
<span class="line-modified">2679   test_null_free_array_layout(temp_reg, is_null_free_array);</span>
2680 }
2681 
2682 void MacroAssembler::test_non_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_non_null_free_array) {
<span class="line-modified">2683   load_klass(temp_reg, oop);</span>
<span class="line-modified">2684   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));</span>
<span class="line-added">2685   test_non_null_free_array_layout(temp_reg, is_non_null_free_array);</span>
<span class="line-added">2686 }</span>
<span class="line-added">2687 </span>
<span class="line-added">2688 void MacroAssembler::test_flattened_array_layout(Register lh, Label&amp; is_flattened_array) {</span>
<span class="line-added">2689   testl(lh, Klass::_lh_array_tag_vt_value_bit_inplace);</span>
<span class="line-added">2690   jcc(Assembler::notZero, is_flattened_array);</span>
<span class="line-added">2691 }</span>
<span class="line-added">2692 void MacroAssembler::test_non_flattened_array_layout(Register lh, Label&amp; is_non_flattened_array) {</span>
<span class="line-added">2693   testl(lh, Klass::_lh_array_tag_vt_value_bit_inplace);</span>
<span class="line-added">2694   jcc(Assembler::zero, is_non_flattened_array);</span>
<span class="line-added">2695 }</span>
<span class="line-added">2696 </span>
<span class="line-added">2697 void MacroAssembler::test_null_free_array_layout(Register lh, Label&amp; is_null_free_array) {</span>
<span class="line-added">2698   testl(lh, Klass::_lh_null_free_bit_inplace);</span>
<span class="line-added">2699   jcc(Assembler::notZero, is_null_free_array);</span>
<span class="line-added">2700 }</span>
<span class="line-added">2701 </span>
<span class="line-added">2702 void MacroAssembler::test_non_null_free_array_layout(Register lh, Label&amp; is_non_null_free_array) {</span>
<span class="line-added">2703   testl(lh, Klass::_lh_null_free_bit_inplace);</span>
2704   jcc(Assembler::zero, is_non_null_free_array);
2705 }
2706 
<span class="line-added">2707 </span>
2708 void MacroAssembler::os_breakpoint() {
2709   // instead of directly emitting a breakpoint, call os:breakpoint for better debugability
2710   // (e.g., MSVC can&#39;t call ps() otherwise)
2711   call(RuntimeAddress(CAST_FROM_FN_PTR(address, os::breakpoint)));
2712 }
2713 
2714 void MacroAssembler::unimplemented(const char* what) {
2715   const char* buf = NULL;
2716   {
2717     ResourceMark rm;
2718     stringStream ss;
2719     ss.print(&quot;unimplemented: %s&quot;, what);
2720     buf = code_string(ss.as_string());
2721   }
2722   stop(buf);
2723 }
2724 
2725 #ifdef _LP64
2726 #define XSTATE_BV 0x200
2727 #endif
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
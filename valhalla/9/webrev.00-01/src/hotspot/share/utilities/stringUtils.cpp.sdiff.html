<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/stringUtils.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/hotspot/share/utilities/stringUtils.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 58   for (size_t i = 0; i &lt; len1 - 1; i++) {
 59     for (size_t j = 0; j &lt; len2 - 1; j++) {
 60       if ((str1[i] == str2[j]) &amp;&amp; (str1[i+1] == str2[j+1])) {
 61         ++hit;
 62         break;
 63       }
 64     }
 65   }
 66 
 67   return 2.0 * (double) hit / (double) total;
 68 }
 69 
 70 class StringMatcher {
 71  public:
 72   typedef int getc_function_t(const char* &amp;source, const char* limit);
 73 
 74  private:
 75   // These do not get properly inlined.
 76   // For full performance, this should be a template class
 77   // parameterized by two function arguments.
<span class="line-modified"> 78   const getc_function_t* _pattern_getc;</span>
<span class="line-modified"> 79   const getc_function_t* _string_getc;</span>
 80 
 81  public:
 82   StringMatcher(getc_function_t pattern_getc,
 83                 getc_function_t string_getc)
 84     : _pattern_getc(pattern_getc),
 85       _string_getc(string_getc)
 86   { }
 87 
 88   enum {  // special results from _pattern_getc
 89     string_match_comma  = -0x100 + &#39;,&#39;,
 90     string_match_star   = -0x100 + &#39;*&#39;,
 91     string_match_eos    = -0x100 + &#39;\0&#39;
 92   };
 93 
 94  private:
 95   const char*
 96   skip_anchor_word(const char* match,
 97                    const char* match_end,
 98                    int anchor_length,
 99                    const char* pattern,
</pre>
<hr />
<pre>
292     assert(!StringUtils::class_list_match(pat, str), &quot;%s !~ %s&quot;, pat, str);
293   }
294 }
295 
296 static bool class_list_match_sane() {
297   static bool done = false;
298   if (done)  return true;
299   done = true;
300   class_list_match_sane(&quot;foo&quot;, &quot;foo&quot;);
301   class_list_match_sane(&quot;foo,&quot;, &quot;foo&quot;);
302   class_list_match_sane(&quot;,foo,&quot;, &quot;foo&quot;);
303   class_list_match_sane(&quot;bar,foo&quot;, &quot;foo&quot;);
304   class_list_match_sane(&quot;bar,foo,&quot;, &quot;foo&quot;);
305   class_list_match_sane(&quot;*&quot;, &quot;foo&quot;);
306   class_list_match_sane(&quot;foo.bar&quot;, &quot;foo/bar&quot;);
307   class_list_match_sane(&quot;foo/bar&quot;, &quot;foo.bar&quot;);
308   class_list_match_sane(&quot;\\foo&quot;, &quot;foo&quot;);
309   class_list_match_sane(&quot;\\*foo&quot;, &quot;*foo&quot;);
310   const char* foo = &quot;foo!&quot;;
311   char buf[100], buf2[100];
<span class="line-modified">312   const int m = strlen(foo);</span>
313   for (int n = 0; n &lt;= 1; n++) {  // neg: 0=&gt;pos
314     for (int a = -1; a &lt;= 1; a++) {  // alt: -1/X,T 0/T 1/T,Y
315       for (int i = 0; i &lt;= m; i++) {  // 1st substring [i:j]
316         for (int j = i; j &lt;= m; j++) {
317           if (j == i &amp;&amp; j &gt; 0)  continue; // only take 1st empty
318           for (int k = j; k &lt;= m; k++) {  // 2nd substring [k:l]
319             if (k == j &amp;&amp; k &gt; i)  continue; // only take 1st empty
320             for (int l = k; l &lt;= m; l++) {
321               if (l == k &amp;&amp; l &gt; j)  continue; // only take 1st empty
322               char* bp = &amp;buf[0];
323               strncpy(bp, foo + 0, i - 0); bp += i - 0;
324               *bp++ = &#39;*&#39;;
325               strncpy(bp, foo + j, k - j); bp += k - j;
326               *bp++ = &#39;*&#39;;
327               strncpy(bp, foo + l, m - l); bp += m - l;
328               if (n) {
329                 *bp++ = &#39;N&#39;;  // make it fail
330               }
331               *bp++ = &#39;\0&#39;;
332               if (a != 0) {
</pre>
</td>
<td>
<hr />
<pre>
 58   for (size_t i = 0; i &lt; len1 - 1; i++) {
 59     for (size_t j = 0; j &lt; len2 - 1; j++) {
 60       if ((str1[i] == str2[j]) &amp;&amp; (str1[i+1] == str2[j+1])) {
 61         ++hit;
 62         break;
 63       }
 64     }
 65   }
 66 
 67   return 2.0 * (double) hit / (double) total;
 68 }
 69 
 70 class StringMatcher {
 71  public:
 72   typedef int getc_function_t(const char* &amp;source, const char* limit);
 73 
 74  private:
 75   // These do not get properly inlined.
 76   // For full performance, this should be a template class
 77   // parameterized by two function arguments.
<span class="line-modified"> 78   getc_function_t* _pattern_getc;</span>
<span class="line-modified"> 79   getc_function_t* _string_getc;</span>
 80 
 81  public:
 82   StringMatcher(getc_function_t pattern_getc,
 83                 getc_function_t string_getc)
 84     : _pattern_getc(pattern_getc),
 85       _string_getc(string_getc)
 86   { }
 87 
 88   enum {  // special results from _pattern_getc
 89     string_match_comma  = -0x100 + &#39;,&#39;,
 90     string_match_star   = -0x100 + &#39;*&#39;,
 91     string_match_eos    = -0x100 + &#39;\0&#39;
 92   };
 93 
 94  private:
 95   const char*
 96   skip_anchor_word(const char* match,
 97                    const char* match_end,
 98                    int anchor_length,
 99                    const char* pattern,
</pre>
<hr />
<pre>
292     assert(!StringUtils::class_list_match(pat, str), &quot;%s !~ %s&quot;, pat, str);
293   }
294 }
295 
296 static bool class_list_match_sane() {
297   static bool done = false;
298   if (done)  return true;
299   done = true;
300   class_list_match_sane(&quot;foo&quot;, &quot;foo&quot;);
301   class_list_match_sane(&quot;foo,&quot;, &quot;foo&quot;);
302   class_list_match_sane(&quot;,foo,&quot;, &quot;foo&quot;);
303   class_list_match_sane(&quot;bar,foo&quot;, &quot;foo&quot;);
304   class_list_match_sane(&quot;bar,foo,&quot;, &quot;foo&quot;);
305   class_list_match_sane(&quot;*&quot;, &quot;foo&quot;);
306   class_list_match_sane(&quot;foo.bar&quot;, &quot;foo/bar&quot;);
307   class_list_match_sane(&quot;foo/bar&quot;, &quot;foo.bar&quot;);
308   class_list_match_sane(&quot;\\foo&quot;, &quot;foo&quot;);
309   class_list_match_sane(&quot;\\*foo&quot;, &quot;*foo&quot;);
310   const char* foo = &quot;foo!&quot;;
311   char buf[100], buf2[100];
<span class="line-modified">312   const int m = (int)strlen(foo);</span>
313   for (int n = 0; n &lt;= 1; n++) {  // neg: 0=&gt;pos
314     for (int a = -1; a &lt;= 1; a++) {  // alt: -1/X,T 0/T 1/T,Y
315       for (int i = 0; i &lt;= m; i++) {  // 1st substring [i:j]
316         for (int j = i; j &lt;= m; j++) {
317           if (j == i &amp;&amp; j &gt; 0)  continue; // only take 1st empty
318           for (int k = j; k &lt;= m; k++) {  // 2nd substring [k:l]
319             if (k == j &amp;&amp; k &gt; i)  continue; // only take 1st empty
320             for (int l = k; l &lt;= m; l++) {
321               if (l == k &amp;&amp; l &gt; j)  continue; // only take 1st empty
322               char* bp = &amp;buf[0];
323               strncpy(bp, foo + 0, i - 0); bp += i - 0;
324               *bp++ = &#39;*&#39;;
325               strncpy(bp, foo + j, k - j); bp += k - j;
326               *bp++ = &#39;*&#39;;
327               strncpy(bp, foo + l, m - l); bp += m - l;
328               if (n) {
329                 *bp++ = &#39;N&#39;;  // make it fail
330               }
331               *bp++ = &#39;\0&#39;;
332               if (a != 0) {
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
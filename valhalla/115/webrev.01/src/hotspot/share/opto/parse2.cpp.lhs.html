<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/parse2.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciMethodData.hpp&quot;
  27 #include &quot;classfile/systemDictionary.hpp&quot;
  28 #include &quot;classfile/vmSymbols.hpp&quot;
  29 #include &quot;compiler/compileLog.hpp&quot;
  30 #include &quot;interpreter/linkResolver.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;memory/universe.hpp&quot;
  33 #include &quot;oops/oop.inline.hpp&quot;
  34 #include &quot;opto/addnode.hpp&quot;
  35 #include &quot;opto/castnode.hpp&quot;
  36 #include &quot;opto/convertnode.hpp&quot;
  37 #include &quot;opto/divnode.hpp&quot;
  38 #include &quot;opto/idealGraphPrinter.hpp&quot;
  39 #include &quot;opto/idealKit.hpp&quot;
  40 #include &quot;opto/matcher.hpp&quot;
  41 #include &quot;opto/memnode.hpp&quot;
  42 #include &quot;opto/mulnode.hpp&quot;
  43 #include &quot;opto/opaquenode.hpp&quot;
  44 #include &quot;opto/parse.hpp&quot;
  45 #include &quot;opto/runtime.hpp&quot;
  46 #include &quot;opto/valuetypenode.hpp&quot;
  47 #include &quot;runtime/deoptimization.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 
  50 #ifndef PRODUCT
  51 extern int explicit_null_checks_inserted,
  52            explicit_null_checks_elided;
  53 #endif
  54 
  55 Node* Parse::record_profile_for_speculation_at_array_load(Node* ld) {
  56   // Feed unused profile data to type speculation
  57   if (UseTypeSpeculation &amp;&amp; UseArrayLoadStoreProfile) {
  58     ciKlass* array_type = NULL;
  59     ciKlass* element_type = NULL;
  60     ProfilePtrKind element_ptr = ProfileMaybeNull;
  61     bool flat_array = true;
  62     bool null_free_array = true;
  63     method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);
  64     if (element_type != NULL || element_ptr != ProfileMaybeNull) {
  65       ld = record_profile_for_speculation(ld, element_type, element_ptr);
  66     }
  67   }
  68   return ld;
  69 }
  70 
  71 
  72 //---------------------------------array_load----------------------------------
  73 void Parse::array_load(BasicType bt) {
  74   const Type* elemtype = Type::TOP;
  75   Node* adr = array_addressing(bt, 0, elemtype);
  76   if (stopped())  return;     // guaranteed null or range check
  77 
  78   Node* idx = pop();
  79   Node* ary = pop();
  80 
  81   // Handle value type arrays
  82   const TypeOopPtr* elemptr = elemtype-&gt;make_oopptr();
  83   const TypeAryPtr* ary_t = _gvn.type(ary)-&gt;is_aryptr();
  84   if (elemtype-&gt;isa_valuetype() != NULL) {
  85     C-&gt;set_flattened_accesses();
  86     // Load from flattened value type array
  87     Node* vt = ValueTypeNode::make_from_flattened(this, elemtype-&gt;value_klass(), ary, adr);
  88     push(vt);
  89     return;
  90   } else if (elemptr != NULL &amp;&amp; elemptr-&gt;is_valuetypeptr() &amp;&amp; !elemptr-&gt;maybe_null()) {
  91     // Load from non-flattened but flattenable value type array (elements can never be null)
  92     bt = T_INLINE_TYPE;
  93   } else if (!ary_t-&gt;is_not_flat()) {
  94     // Cannot statically determine if array is flattened, emit runtime check
<a name="1" id="anc1"></a><span class="line-modified">  95     assert(ValueArrayFlatten &amp;&amp; is_reference_type(bt) &amp;&amp; elemptr-&gt;can_be_value_type() &amp;&amp; !ary_t-&gt;klass_is_exact() &amp;&amp; !ary_t-&gt;is_not_null_free() &amp;&amp;</span>
  96            (!elemptr-&gt;is_valuetypeptr() || elemptr-&gt;value_klass()-&gt;flatten_array()), &quot;array can&#39;t be flattened&quot;);
  97     IdealKit ideal(this);
  98     IdealVariable res(ideal);
  99     ideal.declarations_done();
 100     ideal.if_then(is_non_flattened_array(ary)); {
 101       // non-flattened
 102       assert(ideal.ctrl()-&gt;in(0)-&gt;as_If()-&gt;is_non_flattened_array_check(&amp;_gvn), &quot;Should be found&quot;);
 103       sync_kit(ideal);
 104       const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
 105       Node* ld = access_load_at(ary, adr, adr_type, elemptr, bt,
 106                                 IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD);
 107       ideal.sync_kit(this);
 108       ideal.set(res, ld);
 109     } ideal.else_(); {
 110       // flattened
 111       sync_kit(ideal);
 112       if (elemptr-&gt;is_valuetypeptr()) {
 113         // Element type is known, cast and load from flattened representation
 114         ciValueKlass* vk = elemptr-&gt;value_klass();
 115         assert(vk-&gt;flatten_array() &amp;&amp; elemptr-&gt;maybe_null(), &quot;must be a flattenable and nullable array&quot;);
 116         ciArrayKlass* array_klass = ciArrayKlass::make(vk);
 117         const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)-&gt;isa_aryptr();
 118         Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, arytype));
 119         Node* casted_adr = array_element_address(cast, idx, T_INLINE_TYPE, ary_t-&gt;size(), control());
 120         // Re-execute flattened array load if buffering triggers deoptimization
 121         PreserveReexecuteState preexecs(this);
 122         jvms()-&gt;set_should_reexecute(true);
 123         inc_sp(2);
 124         Node* vt = ValueTypeNode::make_from_flattened(this, vk, cast, casted_adr)-&gt;buffer(this, false);
 125         ideal.set(res, vt);
 126         ideal.sync_kit(this);
 127       } else {
 128         // Element type is unknown, emit runtime call
 129         Node* kls = load_object_klass(ary);
 130         Node* k_adr = basic_plus_adr(kls, in_bytes(ArrayKlass::element_klass_offset()));
 131         Node* elem_klass = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS));
 132         Node* obj_size  = NULL;
 133         kill_dead_locals();
 134         // Re-execute flattened array load if buffering triggers deoptimization
 135         PreserveReexecuteState preexecs(this);
 136         jvms()-&gt;set_bci(_bci);
 137         jvms()-&gt;set_should_reexecute(true);
 138         inc_sp(2);
 139         Node* alloc_obj = new_instance(elem_klass, NULL, &amp;obj_size, /*deoptimize_on_exception=*/true);
 140 
 141         AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_obj, &amp;_gvn);
 142         assert(alloc-&gt;maybe_set_complete(&amp;_gvn), &quot;&quot;);
 143         alloc-&gt;initialization()-&gt;set_complete_with_arraycopy();
 144 
 145         // This membar keeps this access to an unknown flattened array
 146         // correctly ordered with other unknown and known flattened
 147         // array accesses.
 148         insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::VALUES));
 149 
 150         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 151         // Unknown value type might contain reference fields
 152         if (false &amp;&amp; !bs-&gt;array_copy_requires_gc_barriers(false, T_OBJECT, false, BarrierSetC2::Parsing)) {
 153           // FIXME 8230656 also merge changes from 8238759 in
 154           int base_off = sizeof(instanceOopDesc);
 155           Node* dst_base = basic_plus_adr(alloc_obj, base_off);
 156           Node* countx = obj_size;
 157           countx = _gvn.transform(new SubXNode(countx, MakeConX(base_off)));
 158           countx = _gvn.transform(new URShiftXNode(countx, intcon(LogBytesPerLong)));
 159 
 160           assert(Klass::_lh_log2_element_size_shift == 0, &quot;use shift in place&quot;);
 161           Node* lhp = basic_plus_adr(kls, in_bytes(Klass::layout_helper_offset()));
 162           Node* elem_shift = make_load(NULL, lhp, TypeInt::INT, T_INT, MemNode::unordered);
 163           uint header = arrayOopDesc::base_offset_in_bytes(T_INLINE_TYPE);
 164           Node* base  = basic_plus_adr(ary, header);
 165           idx = Compile::conv_I2X_index(&amp;_gvn, idx, TypeInt::POS, control());
 166           Node* scale = _gvn.transform(new LShiftXNode(idx, elem_shift));
 167           Node* adr = basic_plus_adr(ary, base, scale);
 168 
 169           access_clone(adr, dst_base, countx, false);
 170         } else {
 171           ideal.sync_kit(this);
 172           ideal.make_leaf_call(OptoRuntime::load_unknown_value_Type(),
 173                                CAST_FROM_FN_PTR(address, OptoRuntime::load_unknown_value),
 174                                &quot;load_unknown_value&quot;,
 175                                ary, idx, alloc_obj);
 176           sync_kit(ideal);
 177         }
 178 
 179         // This makes sure no other thread sees a partially initialized buffered value
 180         insert_mem_bar_volatile(Op_MemBarStoreStore, Compile::AliasIdxRaw, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
 181 
 182         // Same as MemBarCPUOrder above: keep this unknown flattened
 183         // array access correctly ordered with other flattened array
 184         // access
 185         insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::VALUES));
 186 
 187         // Prevent any use of the newly allocated value before it is
 188         // fully initialized
 189         alloc_obj = new CastPPNode(alloc_obj, _gvn.type(alloc_obj), true);
 190         alloc_obj-&gt;set_req(0, control());
 191         alloc_obj = _gvn.transform(alloc_obj);
 192 
 193         const Type* unknown_value = elemptr-&gt;is_instptr()-&gt;cast_to_flat_array();
 194         alloc_obj = _gvn.transform(new CheckCastPPNode(control(), alloc_obj, unknown_value));
 195 
 196         ideal.sync_kit(this);
 197         ideal.set(res, alloc_obj);
 198       }
 199     } ideal.end_if();
 200     sync_kit(ideal);
 201     Node* ld = _gvn.transform(ideal.value(res));
 202     ld = record_profile_for_speculation_at_array_load(ld);
 203     push_node(bt, ld);
 204     return;
 205   }
 206 
 207   if (elemtype == TypeInt::BOOL) {
 208     bt = T_BOOLEAN;
 209   }
 210   const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
 211   Node* ld = access_load_at(ary, adr, adr_type, elemtype, bt,
 212                             IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD);
 213   if (bt == T_INLINE_TYPE) {
 214     // Loading a non-flattened (but flattenable) value type from an array
 215     assert(!gvn().type(ld)-&gt;maybe_null(), &quot;value type array elements should never be null&quot;);
 216     if (elemptr-&gt;value_klass()-&gt;is_scalarizable()) {
 217       ld = ValueTypeNode::make_from_oop(this, ld, elemptr-&gt;value_klass());
 218     }
 219   }
 220   if (!ld-&gt;is_ValueType()) {
 221     ld = record_profile_for_speculation_at_array_load(ld);
 222   }
 223 
 224   push_node(bt, ld);
 225 }
 226 
 227 
 228 //--------------------------------array_store----------------------------------
 229 void Parse::array_store(BasicType bt) {
 230   const Type* elemtype = Type::TOP;
 231   Node* adr = array_addressing(bt, type2size[bt], elemtype);
 232   if (stopped())  return;     // guaranteed null or range check
 233   Node* cast_val = NULL;
 234   if (bt == T_OBJECT) {
 235     cast_val = array_store_check();
 236     if (stopped()) return;
 237   }
 238   Node* val = pop_node(bt); // Value to store
 239   Node* idx = pop();        // Index in the array
 240   Node* ary = pop();        // The array itself
 241 
 242   const TypeAryPtr* ary_t = _gvn.type(ary)-&gt;is_aryptr();
 243   const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
 244 
 245   if (elemtype == TypeInt::BOOL) {
 246     bt = T_BOOLEAN;
 247   } else if (bt == T_OBJECT) {
 248     elemtype = elemtype-&gt;make_oopptr();
 249     const Type* tval = _gvn.type(cast_val);
 250     // We may have lost type information for &#39;val&#39; here due to the casts
 251     // emitted by the array_store_check code (see JDK-6312651)
 252     // TODO Remove this code once JDK-6312651 is in.
 253     const Type* tval_init = _gvn.type(val);
 254     bool can_be_value_type = tval-&gt;isa_valuetype() || (tval != TypePtr::NULL_PTR &amp;&amp; tval_init-&gt;is_oopptr()-&gt;can_be_value_type() &amp;&amp; tval-&gt;is_oopptr()-&gt;can_be_value_type());
 255     bool not_flattenable = !can_be_value_type || ((tval_init-&gt;is_valuetypeptr() || tval_init-&gt;isa_valuetype()) &amp;&amp; !tval_init-&gt;value_klass()-&gt;flatten_array());
 256 
 257     if (!ary_t-&gt;is_not_null_free() &amp;&amp; !can_be_value_type &amp;&amp; (!tval-&gt;maybe_null() || !tval_init-&gt;maybe_null())) {
 258       // Storing a non-inline-type, mark array as not null-free.
 259       // This is only legal for non-null stores because the array_store_check passes for null.
 260       ary_t = ary_t-&gt;cast_to_not_null_free();
 261       Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));
 262       replace_in_map(ary, cast);
 263       ary = cast;
 264     } else if (!ary_t-&gt;is_not_flat() &amp;&amp; not_flattenable) {
 265       // Storing a non-flattenable value, mark array as not flat.
 266       ary_t = ary_t-&gt;cast_to_not_flat();
 267       if (tval != TypePtr::NULL_PTR) {
 268         // For NULL, this transformation is only valid after the null guard below
 269         Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));
 270         replace_in_map(ary, cast);
 271         ary = cast;
 272       }
 273     }
 274 
 275     if (ary_t-&gt;elem()-&gt;isa_valuetype() != NULL) {
 276       // Store to flattened value type array
 277       C-&gt;set_flattened_accesses();
 278       if (!cast_val-&gt;is_ValueType()) {
 279         inc_sp(3);
 280         cast_val = null_check(cast_val);
 281         if (stopped()) return;
 282         dec_sp(3);
 283         cast_val = ValueTypeNode::make_from_oop(this, cast_val, ary_t-&gt;elem()-&gt;value_klass());
 284       }
 285       // Re-execute flattened array store if buffering triggers deoptimization
 286       PreserveReexecuteState preexecs(this);
 287       inc_sp(3);
 288       jvms()-&gt;set_should_reexecute(true);
 289       cast_val-&gt;as_ValueType()-&gt;store_flattened(this, ary, adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);
 290       return;
 291     } else if (elemtype-&gt;is_valuetypeptr() &amp;&amp; !elemtype-&gt;maybe_null()) {
 292       // Store to non-flattened but flattenable value type array (elements can never be null)
 293       if (!cast_val-&gt;is_ValueType() &amp;&amp; tval-&gt;maybe_null()) {
 294         inc_sp(3);
 295         cast_val = null_check(cast_val);
 296         if (stopped()) return;
 297         dec_sp(3);
 298       }
 299     } else if (!ary_t-&gt;is_not_flat()) {
 300       // Array might be flattened, emit runtime checks
<a name="2" id="anc2"></a><span class="line-modified"> 301       assert(ValueArrayFlatten &amp;&amp; !not_flattenable &amp;&amp; elemtype-&gt;is_oopptr()-&gt;can_be_value_type() &amp;&amp;</span>
 302              !ary_t-&gt;klass_is_exact() &amp;&amp; !ary_t-&gt;is_not_null_free(), &quot;array can&#39;t be flattened&quot;);
 303       IdealKit ideal(this);
 304       ideal.if_then(is_non_flattened_array(ary)); {
 305         // non-flattened
 306         assert(ideal.ctrl()-&gt;in(0)-&gt;as_If()-&gt;is_non_flattened_array_check(&amp;_gvn), &quot;Should be found&quot;);
 307         sync_kit(ideal);
 308         gen_value_array_null_guard(ary, cast_val, 3);
 309         inc_sp(3);
 310         access_store_at(ary, adr, adr_type, cast_val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY, false);
 311         dec_sp(3);
 312         ideal.sync_kit(this);
 313       } ideal.else_(); {
 314         Node* val = cast_val;
 315         // flattened
 316         if (!val-&gt;is_ValueType() &amp;&amp; tval-&gt;maybe_null()) {
 317           // Add null check
 318           sync_kit(ideal);
 319           Node* null_ctl = top();
 320           val = null_check_oop(val, &amp;null_ctl);
 321           if (null_ctl != top()) {
 322             PreserveJVMState pjvms(this);
 323             inc_sp(3);
 324             set_control(null_ctl);
 325             uncommon_trap(Deoptimization::Reason_null_check, Deoptimization::Action_none);
 326             dec_sp(3);
 327           }
 328           ideal.sync_kit(this);
 329         }
 330         // Try to determine the value klass
 331         ciValueKlass* vk = NULL;
 332         if (tval-&gt;isa_valuetype() || tval-&gt;is_valuetypeptr()) {
 333           vk = tval-&gt;value_klass();
 334         } else if (tval_init-&gt;isa_valuetype() || tval_init-&gt;is_valuetypeptr()) {
 335           vk = tval_init-&gt;value_klass();
 336         } else if (elemtype-&gt;is_valuetypeptr()) {
 337           vk = elemtype-&gt;value_klass();
 338         }
 339         Node* casted_ary = ary;
 340         if (vk != NULL &amp;&amp; !stopped()) {
 341           // Element type is known, cast and store to flattened representation
 342           sync_kit(ideal);
 343           assert(vk-&gt;flatten_array() &amp;&amp; elemtype-&gt;maybe_null(), &quot;must be a flattenable and nullable array&quot;);
 344           ciArrayKlass* array_klass = ciArrayKlass::make(vk);
 345           const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)-&gt;isa_aryptr();
 346           casted_ary = _gvn.transform(new CheckCastPPNode(control(), casted_ary, arytype));
 347           Node* casted_adr = array_element_address(casted_ary, idx, T_OBJECT, arytype-&gt;size(), control());
 348           if (!val-&gt;is_ValueType()) {
 349             assert(!gvn().type(val)-&gt;maybe_null(), &quot;value type array elements should never be null&quot;);
 350             val = ValueTypeNode::make_from_oop(this, val, vk);
 351           }
 352           // Re-execute flattened array store if buffering triggers deoptimization
 353           PreserveReexecuteState preexecs(this);
 354           inc_sp(3);
 355           jvms()-&gt;set_should_reexecute(true);
 356           val-&gt;as_ValueType()-&gt;store_flattened(this, casted_ary, casted_adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);
 357           ideal.sync_kit(this);
 358         } else if (!ideal.ctrl()-&gt;is_top()) {
 359           // Element type is unknown, emit runtime call
 360           sync_kit(ideal);
 361 
 362           // This membar keeps this access to an unknown flattened
 363           // array correctly ordered with other unknown and known
 364           // flattened array accesses.
 365           insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::VALUES));
 366           ideal.sync_kit(this);
 367 
 368           ideal.make_leaf_call(OptoRuntime::store_unknown_value_Type(),
 369                                CAST_FROM_FN_PTR(address, OptoRuntime::store_unknown_value),
 370                                &quot;store_unknown_value&quot;,
 371                                val, casted_ary, idx);
 372 
 373           sync_kit(ideal);
 374           // Same as MemBarCPUOrder above: keep this unknown
 375           // flattened array access correctly ordered with other
 376           // flattened array accesses.
 377           insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::VALUES));
 378           ideal.sync_kit(this);
 379         }
 380       }
 381       ideal.end_if();
 382       sync_kit(ideal);
 383       return;
 384     } else if (!ary_t-&gt;is_not_null_free()) {
 385       // Array is not flattened but may be null free
 386       assert(elemtype-&gt;is_oopptr()-&gt;can_be_value_type() &amp;&amp; !ary_t-&gt;klass_is_exact(), &quot;array can&#39;t be null free&quot;);
 387       ary = gen_value_array_null_guard(ary, cast_val, 3, true);
 388     }
 389   }
 390   inc_sp(3);
 391   access_store_at(ary, adr, adr_type, val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY);
 392   dec_sp(3);
 393 }
 394 
 395 
 396 //------------------------------array_addressing-------------------------------
 397 // Pull array and index from the stack.  Compute pointer-to-element.
 398 Node* Parse::array_addressing(BasicType type, int vals, const Type*&amp; elemtype) {
 399   Node *idx   = peek(0+vals);   // Get from stack without popping
 400   Node *ary   = peek(1+vals);   // in case of exception
 401 
 402   // Null check the array base, with correct stack contents
 403   ary = null_check(ary, T_ARRAY);
 404   // Compile-time detect of null-exception?
 405   if (stopped())  return top();
 406 
 407   const TypeAryPtr* arytype  = _gvn.type(ary)-&gt;is_aryptr();
 408   const TypeInt*    sizetype = arytype-&gt;size();
 409   elemtype = arytype-&gt;elem();
 410 
 411   if (UseUniqueSubclasses) {
 412     const Type* el = elemtype-&gt;make_ptr();
 413     if (el &amp;&amp; el-&gt;isa_instptr()) {
 414       const TypeInstPtr* toop = el-&gt;is_instptr();
 415       if (toop-&gt;klass()-&gt;as_instance_klass()-&gt;unique_concrete_subklass()) {
 416         // If we load from &quot;AbstractClass[]&quot; we must see &quot;ConcreteSubClass&quot;.
 417         const Type* subklass = Type::get_const_type(toop-&gt;klass());
 418         elemtype = subklass-&gt;join_speculative(el);
 419       }
 420     }
 421   }
 422 
 423   // Check for big class initializers with all constant offsets
 424   // feeding into a known-size array.
 425   const TypeInt* idxtype = _gvn.type(idx)-&gt;is_int();
 426   // See if the highest idx value is less than the lowest array bound,
 427   // and if the idx value cannot be negative:
 428   bool need_range_check = true;
 429   if (idxtype-&gt;_hi &lt; sizetype-&gt;_lo &amp;&amp; idxtype-&gt;_lo &gt;= 0) {
 430     need_range_check = false;
 431     if (C-&gt;log() != NULL)   C-&gt;log()-&gt;elem(&quot;observe that=&#39;!need_range_check&#39;&quot;);
 432   }
 433 
 434   ciKlass * arytype_klass = arytype-&gt;klass();
 435   if ((arytype_klass != NULL) &amp;&amp; (!arytype_klass-&gt;is_loaded())) {
 436     // Only fails for some -Xcomp runs
 437     // The class is unloaded.  We have to run this bytecode in the interpreter.
 438     uncommon_trap(Deoptimization::Reason_unloaded,
 439                   Deoptimization::Action_reinterpret,
 440                   arytype-&gt;klass(), &quot;!loaded array&quot;);
 441     return top();
 442   }
 443 
 444   // Do the range check
 445   if (GenerateRangeChecks &amp;&amp; need_range_check) {
 446     Node* tst;
 447     if (sizetype-&gt;_hi &lt;= 0) {
 448       // The greatest array bound is negative, so we can conclude that we&#39;re
 449       // compiling unreachable code, but the unsigned compare trick used below
 450       // only works with non-negative lengths.  Instead, hack &quot;tst&quot; to be zero so
 451       // the uncommon_trap path will always be taken.
 452       tst = _gvn.intcon(0);
 453     } else {
 454       // Range is constant in array-oop, so we can use the original state of mem
 455       Node* len = load_array_length(ary);
 456 
 457       // Test length vs index (standard trick using unsigned compare)
 458       Node* chk = _gvn.transform( new CmpUNode(idx, len) );
 459       BoolTest::mask btest = BoolTest::lt;
 460       tst = _gvn.transform( new BoolNode(chk, btest) );
 461     }
 462     RangeCheckNode* rc = new RangeCheckNode(control(), tst, PROB_MAX, COUNT_UNKNOWN);
 463     _gvn.set_type(rc, rc-&gt;Value(&amp;_gvn));
 464     if (!tst-&gt;is_Con()) {
 465       record_for_igvn(rc);
 466     }
 467     set_control(_gvn.transform(new IfTrueNode(rc)));
 468     // Branch to failure if out of bounds
 469     {
 470       PreserveJVMState pjvms(this);
 471       set_control(_gvn.transform(new IfFalseNode(rc)));
 472       if (C-&gt;allow_range_check_smearing()) {
 473         // Do not use builtin_throw, since range checks are sometimes
 474         // made more stringent by an optimistic transformation.
 475         // This creates &quot;tentative&quot; range checks at this point,
 476         // which are not guaranteed to throw exceptions.
 477         // See IfNode::Ideal, is_range_check, adjust_check.
 478         uncommon_trap(Deoptimization::Reason_range_check,
 479                       Deoptimization::Action_make_not_entrant,
 480                       NULL, &quot;range_check&quot;);
 481       } else {
 482         // If we have already recompiled with the range-check-widening
 483         // heroic optimization turned off, then we must really be throwing
 484         // range check exceptions.
 485         builtin_throw(Deoptimization::Reason_range_check, idx);
 486       }
 487     }
 488   }
 489   // Check for always knowing you are throwing a range-check exception
 490   if (stopped())  return top();
 491 
 492   // This could be an access to a value array. We can&#39;t tell if it&#39;s
 493   // flat or not. Speculating it&#39;s not leads to a much simpler graph
 494   // shape. Check profiling.
 495   // For aastore, by the time we&#39;re here, the array store check should
 496   // have already taken advantage of profiling to cast the array to an
 497   // exact type reported by profiling
 498   const TypeOopPtr* elemptr = elemtype-&gt;make_oopptr();
 499   if (elemtype-&gt;isa_valuetype() == NULL &amp;&amp;
 500       (elemptr == NULL || !elemptr-&gt;is_valuetypeptr() || elemptr-&gt;maybe_null()) &amp;&amp;
 501       !arytype-&gt;is_not_flat()) {
 502     assert(is_reference_type(type), &quot;Only references&quot;);
 503     // First check the speculative type
 504     Deoptimization::DeoptReason reason = Deoptimization::Reason_speculate_class_check;
 505     ciKlass* array_type = arytype-&gt;speculative_type();
 506     if (too_many_traps_or_recompiles(reason) || array_type == NULL) {
 507       // No speculative type, check profile data at this bci
 508       array_type = NULL;
 509       reason = Deoptimization::Reason_class_check;
 510       if (UseArrayLoadStoreProfile &amp;&amp; !too_many_traps_or_recompiles(reason)) {
 511         ciKlass* element_type = NULL;
 512         ProfilePtrKind element_ptr = ProfileMaybeNull;
 513         bool flat_array = true;
 514         bool null_free_array = true;
 515         method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);
 516       }
 517     }
 518     if (array_type != NULL) {
 519       // Speculate that this array has the exact type reported by profile data
 520       Node* better_ary = NULL;
 521       Node* slow_ctl = type_check_receiver(ary, array_type, 1.0, &amp;better_ary);
 522       { PreserveJVMState pjvms(this);
 523         set_control(slow_ctl);
 524         uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);
 525       }
 526       replace_in_map(ary, better_ary);
 527       ary = better_ary;
 528       arytype  = _gvn.type(ary)-&gt;is_aryptr();
 529       elemtype = arytype-&gt;elem();
 530     }
 531   } else if (UseTypeSpeculation &amp;&amp; UseArrayLoadStoreProfile) {
 532     // No need to speculate: feed profile data at this bci for the
 533     // array to type speculation
 534     ciKlass* array_type = NULL;
 535     ciKlass* element_type = NULL;
 536     ProfilePtrKind element_ptr = ProfileMaybeNull;
 537     bool flat_array = true;
 538     bool null_free_array = true;
 539     method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);
 540     if (array_type != NULL) {
 541       record_profile_for_speculation(ary, array_type, ProfileMaybeNull);
 542     }
 543   }
 544 
 545   // We have no exact array type from profile data. Check profile data
 546   // for a non null free or non flat array. Non null free implies non
 547   // flat so check this one first. Speculating on a non null free
 548   // array doesn&#39;t help aaload but could be profitable for a
 549   // subsequent aastore.
 550   elemptr = elemtype-&gt;make_oopptr();
 551   if (!arytype-&gt;is_not_null_free() &amp;&amp;
 552       elemtype-&gt;isa_valuetype() == NULL &amp;&amp;
 553       (elemptr == NULL || !elemptr-&gt;is_valuetypeptr()) &amp;&amp;
 554       UseArrayLoadStoreProfile) {
 555     assert(is_reference_type(type), &quot;&quot;);
 556     bool null_free_array = true;
 557     Deoptimization::DeoptReason reason = Deoptimization::Reason_none;
 558     if (arytype-&gt;speculative() != NULL &amp;&amp;
 559         arytype-&gt;speculative()-&gt;is_aryptr()-&gt;is_not_null_free() &amp;&amp;
 560         !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {
 561       null_free_array = false;
 562       reason = Deoptimization::Reason_speculate_class_check;
 563     } else if (!too_many_traps_or_recompiles(Deoptimization::Reason_class_check)) {
 564       ciKlass* array_type = NULL;
 565       ciKlass* element_type = NULL;
 566       ProfilePtrKind element_ptr = ProfileMaybeNull;
 567       bool flat_array = true;
 568       method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);
 569       reason = Deoptimization::Reason_class_check;
 570     }
 571     if (!null_free_array) {
 572       { // Deoptimize if null-free array
 573         BuildCutout unless(this, is_nullable_array(ary), PROB_MAX);
 574         uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);
 575       }
 576       Node* better_ary = _gvn.transform(new CheckCastPPNode(control(), ary, arytype-&gt;cast_to_not_null_free()));
 577       replace_in_map(ary, better_ary);
 578       ary = better_ary;
 579       arytype = _gvn.type(ary)-&gt;is_aryptr();
 580     }
 581   }
 582 
 583   if (!arytype-&gt;is_not_flat() &amp;&amp; elemtype-&gt;isa_valuetype() == NULL) {
 584     assert(is_reference_type(type), &quot;&quot;);
 585     bool flat_array = true;
 586     Deoptimization::DeoptReason reason = Deoptimization::Reason_none;
 587     if (arytype-&gt;speculative() != NULL &amp;&amp;
 588         arytype-&gt;speculative()-&gt;is_aryptr()-&gt;is_not_flat() &amp;&amp;
 589         !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {
 590       flat_array = false;
 591       reason = Deoptimization::Reason_speculate_class_check;
 592     } else if (UseArrayLoadStoreProfile &amp;&amp; !too_many_traps_or_recompiles(reason)) {
 593       ciKlass* array_type = NULL;
 594       ciKlass* element_type = NULL;
 595       ProfilePtrKind element_ptr = ProfileMaybeNull;
 596       bool null_free_array = true;
 597       method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);
 598       reason = Deoptimization::Reason_class_check;
 599     }
 600     if (!flat_array) {
 601       { // Deoptimize if flat array
 602         BuildCutout unless(this, is_non_flattened_array(ary), PROB_MAX);
 603         uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);
 604       }
 605       Node* better_ary = _gvn.transform(new CheckCastPPNode(control(), ary, arytype-&gt;cast_to_not_flat()));
 606       replace_in_map(ary, better_ary);
 607       ary = better_ary;
 608       arytype = _gvn.type(ary)-&gt;is_aryptr();
 609     }
 610   }
 611 
 612   // Make array address computation control dependent to prevent it
 613   // from floating above the range check during loop optimizations.
 614   Node* ptr = array_element_address(ary, idx, type, sizetype, control());
 615   assert(ptr != top(), &quot;top should go hand-in-hand with stopped&quot;);
 616 
 617   return ptr;
 618 }
 619 
 620 
 621 // returns IfNode
 622 IfNode* Parse::jump_if_fork_int(Node* a, Node* b, BoolTest::mask mask, float prob, float cnt) {
 623   Node   *cmp = _gvn.transform(new CmpINode(a, b)); // two cases: shiftcount &gt; 32 and shiftcount &lt;= 32
 624   Node   *tst = _gvn.transform(new BoolNode(cmp, mask));
 625   IfNode *iff = create_and_map_if(control(), tst, prob, cnt);
 626   return iff;
 627 }
 628 
 629 // return Region node
 630 Node* Parse::jump_if_join(Node* iffalse, Node* iftrue) {
 631   Node *region  = new RegionNode(3); // 2 results
 632   record_for_igvn(region);
 633   region-&gt;init_req(1, iffalse);
 634   region-&gt;init_req(2, iftrue );
 635   _gvn.set_type(region, Type::CONTROL);
 636   region = _gvn.transform(region);
 637   set_control (region);
 638   return region;
 639 }
 640 
 641 // sentinel value for the target bci to mark never taken branches
 642 // (according to profiling)
 643 static const int never_reached = INT_MAX;
 644 
 645 //------------------------------helper for tableswitch-------------------------
 646 void Parse::jump_if_true_fork(IfNode *iff, int dest_bci_if_true, int prof_table_index, bool unc) {
 647   // True branch, use existing map info
 648   { PreserveJVMState pjvms(this);
 649     Node *iftrue  = _gvn.transform( new IfTrueNode (iff) );
 650     set_control( iftrue );
 651     if (unc) {
 652       repush_if_args();
 653       uncommon_trap(Deoptimization::Reason_unstable_if,
 654                     Deoptimization::Action_reinterpret,
 655                     NULL,
 656                     &quot;taken always&quot;);
 657     } else {
 658       assert(dest_bci_if_true != never_reached, &quot;inconsistent dest&quot;);
 659       profile_switch_case(prof_table_index);
 660       merge_new_path(dest_bci_if_true);
 661     }
 662   }
 663 
 664   // False branch
 665   Node *iffalse = _gvn.transform( new IfFalseNode(iff) );
 666   set_control( iffalse );
 667 }
 668 
 669 void Parse::jump_if_false_fork(IfNode *iff, int dest_bci_if_true, int prof_table_index, bool unc) {
 670   // True branch, use existing map info
 671   { PreserveJVMState pjvms(this);
 672     Node *iffalse  = _gvn.transform( new IfFalseNode (iff) );
 673     set_control( iffalse );
 674     if (unc) {
 675       repush_if_args();
 676       uncommon_trap(Deoptimization::Reason_unstable_if,
 677                     Deoptimization::Action_reinterpret,
 678                     NULL,
 679                     &quot;taken never&quot;);
 680     } else {
 681       assert(dest_bci_if_true != never_reached, &quot;inconsistent dest&quot;);
 682       profile_switch_case(prof_table_index);
 683       merge_new_path(dest_bci_if_true);
 684     }
 685   }
 686 
 687   // False branch
 688   Node *iftrue = _gvn.transform( new IfTrueNode(iff) );
 689   set_control( iftrue );
 690 }
 691 
 692 void Parse::jump_if_always_fork(int dest_bci, int prof_table_index, bool unc) {
 693   // False branch, use existing map and control()
 694   if (unc) {
 695     repush_if_args();
 696     uncommon_trap(Deoptimization::Reason_unstable_if,
 697                   Deoptimization::Action_reinterpret,
 698                   NULL,
 699                   &quot;taken never&quot;);
 700   } else {
 701     assert(dest_bci != never_reached, &quot;inconsistent dest&quot;);
 702     profile_switch_case(prof_table_index);
 703     merge_new_path(dest_bci);
 704   }
 705 }
 706 
 707 
 708 extern &quot;C&quot; {
 709   static int jint_cmp(const void *i, const void *j) {
 710     int a = *(jint *)i;
 711     int b = *(jint *)j;
 712     return a &gt; b ? 1 : a &lt; b ? -1 : 0;
 713   }
 714 }
 715 
 716 
 717 // Default value for methodData switch indexing. Must be a negative value to avoid
 718 // conflict with any legal switch index.
 719 #define NullTableIndex -1
 720 
 721 class SwitchRange : public StackObj {
 722   // a range of integers coupled with a bci destination
 723   jint _lo;                     // inclusive lower limit
 724   jint _hi;                     // inclusive upper limit
 725   int _dest;
 726   int _table_index;             // index into method data table
 727   float _cnt;                   // how many times this range was hit according to profiling
 728 
 729 public:
 730   jint lo() const              { return _lo;   }
 731   jint hi() const              { return _hi;   }
 732   int  dest() const            { return _dest; }
 733   int  table_index() const     { return _table_index; }
 734   bool is_singleton() const    { return _lo == _hi; }
 735   float cnt() const            { return _cnt; }
 736 
 737   void setRange(jint lo, jint hi, int dest, int table_index, float cnt) {
 738     assert(lo &lt;= hi, &quot;must be a non-empty range&quot;);
 739     _lo = lo, _hi = hi; _dest = dest; _table_index = table_index; _cnt = cnt;
 740     assert(_cnt &gt;= 0, &quot;&quot;);
 741   }
 742   bool adjoinRange(jint lo, jint hi, int dest, int table_index, float cnt, bool trim_ranges) {
 743     assert(lo &lt;= hi, &quot;must be a non-empty range&quot;);
 744     if (lo == _hi+1 &amp;&amp; table_index == _table_index) {
 745       // see merge_ranges() comment below
 746       if (trim_ranges) {
 747         if (cnt == 0) {
 748           if (_cnt != 0) {
 749             return false;
 750           }
 751           if (dest != _dest) {
 752             _dest = never_reached;
 753           }
 754         } else {
 755           if (_cnt == 0) {
 756             return false;
 757           }
 758           if (dest != _dest) {
 759             return false;
 760           }
 761         }
 762       } else {
 763         if (dest != _dest) {
 764           return false;
 765         }
 766       }
 767       _hi = hi;
 768       _cnt += cnt;
 769       return true;
 770     }
 771     return false;
 772   }
 773 
 774   void set (jint value, int dest, int table_index, float cnt) {
 775     setRange(value, value, dest, table_index, cnt);
 776   }
 777   bool adjoin(jint value, int dest, int table_index, float cnt, bool trim_ranges) {
 778     return adjoinRange(value, value, dest, table_index, cnt, trim_ranges);
 779   }
 780   bool adjoin(SwitchRange&amp; other) {
 781     return adjoinRange(other._lo, other._hi, other._dest, other._table_index, other._cnt, false);
 782   }
 783 
 784   void print() {
 785     if (is_singleton())
 786       tty-&gt;print(&quot; {%d}=&gt;%d (cnt=%f)&quot;, lo(), dest(), cnt());
 787     else if (lo() == min_jint)
 788       tty-&gt;print(&quot; {..%d}=&gt;%d (cnt=%f)&quot;, hi(), dest(), cnt());
 789     else if (hi() == max_jint)
 790       tty-&gt;print(&quot; {%d..}=&gt;%d (cnt=%f)&quot;, lo(), dest(), cnt());
 791     else
 792       tty-&gt;print(&quot; {%d..%d}=&gt;%d (cnt=%f)&quot;, lo(), hi(), dest(), cnt());
 793   }
 794 };
 795 
 796 // We try to minimize the number of ranges and the size of the taken
 797 // ones using profiling data. When ranges are created,
 798 // SwitchRange::adjoinRange() only allows 2 adjoining ranges to merge
 799 // if both were never hit or both were hit to build longer unreached
 800 // ranges. Here, we now merge adjoining ranges with the same
 801 // destination and finally set destination of unreached ranges to the
 802 // special value never_reached because it can help minimize the number
 803 // of tests that are necessary.
 804 //
 805 // For instance:
 806 // [0, 1] to target1 sometimes taken
 807 // [1, 2] to target1 never taken
 808 // [2, 3] to target2 never taken
 809 // would lead to:
 810 // [0, 1] to target1 sometimes taken
 811 // [1, 3] never taken
 812 //
 813 // (first 2 ranges to target1 are not merged)
 814 static void merge_ranges(SwitchRange* ranges, int&amp; rp) {
 815   if (rp == 0) {
 816     return;
 817   }
 818   int shift = 0;
 819   for (int j = 0; j &lt; rp; j++) {
 820     SwitchRange&amp; r1 = ranges[j-shift];
 821     SwitchRange&amp; r2 = ranges[j+1];
 822     if (r1.adjoin(r2)) {
 823       shift++;
 824     } else if (shift &gt; 0) {
 825       ranges[j+1-shift] = r2;
 826     }
 827   }
 828   rp -= shift;
 829   for (int j = 0; j &lt;= rp; j++) {
 830     SwitchRange&amp; r = ranges[j];
 831     if (r.cnt() == 0 &amp;&amp; r.dest() != never_reached) {
 832       r.setRange(r.lo(), r.hi(), never_reached, r.table_index(), r.cnt());
 833     }
 834   }
 835 }
 836 
 837 //-------------------------------do_tableswitch--------------------------------
 838 void Parse::do_tableswitch() {
 839   Node* lookup = pop();
 840   // Get information about tableswitch
 841   int default_dest = iter().get_dest_table(0);
 842   int lo_index     = iter().get_int_table(1);
 843   int hi_index     = iter().get_int_table(2);
 844   int len          = hi_index - lo_index + 1;
 845 
 846   if (len &lt; 1) {
 847     // If this is a backward branch, add safepoint
 848     maybe_add_safepoint(default_dest);
 849     merge(default_dest);
 850     return;
 851   }
 852 
 853   ciMethodData* methodData = method()-&gt;method_data();
 854   ciMultiBranchData* profile = NULL;
 855   if (methodData-&gt;is_mature() &amp;&amp; UseSwitchProfiling) {
 856     ciProfileData* data = methodData-&gt;bci_to_data(bci());
 857     if (data != NULL &amp;&amp; data-&gt;is_MultiBranchData()) {
 858       profile = (ciMultiBranchData*)data;
 859     }
 860   }
 861   bool trim_ranges = !method_data_update() &amp;&amp; !C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);
 862 
 863   // generate decision tree, using trichotomy when possible
 864   int rnum = len+2;
 865   bool makes_backward_branch = false;
 866   SwitchRange* ranges = NEW_RESOURCE_ARRAY(SwitchRange, rnum);
 867   int rp = -1;
 868   if (lo_index != min_jint) {
 869     uint cnt = 1;
 870     if (profile != NULL) {
 871       cnt = profile-&gt;default_count() / (hi_index != max_jint ? 2 : 1);
 872     }
 873     ranges[++rp].setRange(min_jint, lo_index-1, default_dest, NullTableIndex, cnt);
 874   }
 875   for (int j = 0; j &lt; len; j++) {
 876     jint match_int = lo_index+j;
 877     int  dest      = iter().get_dest_table(j+3);
 878     makes_backward_branch |= (dest &lt;= bci());
 879     int  table_index = method_data_update() ? j : NullTableIndex;
 880     uint cnt = 1;
 881     if (profile != NULL) {
 882       cnt = profile-&gt;count_at(j);
 883     }
 884     if (rp &lt; 0 || !ranges[rp].adjoin(match_int, dest, table_index, cnt, trim_ranges)) {
 885       ranges[++rp].set(match_int, dest, table_index, cnt);
 886     }
 887   }
 888   jint highest = lo_index+(len-1);
 889   assert(ranges[rp].hi() == highest, &quot;&quot;);
 890   if (highest != max_jint) {
 891     uint cnt = 1;
 892     if (profile != NULL) {
 893       cnt = profile-&gt;default_count() / (lo_index != min_jint ? 2 : 1);
 894     }
 895     if (!ranges[rp].adjoinRange(highest+1, max_jint, default_dest, NullTableIndex, cnt, trim_ranges)) {
 896       ranges[++rp].setRange(highest+1, max_jint, default_dest, NullTableIndex, cnt);
 897     }
 898   }
 899   assert(rp &lt; len+2, &quot;not too many ranges&quot;);
 900 
 901   if (trim_ranges) {
 902     merge_ranges(ranges, rp);
 903   }
 904 
 905   // Safepoint in case if backward branch observed
 906   if( makes_backward_branch &amp;&amp; UseLoopSafepoints )
 907     add_safepoint();
 908 
 909   jump_switch_ranges(lookup, &amp;ranges[0], &amp;ranges[rp]);
 910 }
 911 
 912 
 913 //------------------------------do_lookupswitch--------------------------------
 914 void Parse::do_lookupswitch() {
 915   Node *lookup = pop();         // lookup value
 916   // Get information about lookupswitch
 917   int default_dest = iter().get_dest_table(0);
 918   int len          = iter().get_int_table(1);
 919 
 920   if (len &lt; 1) {    // If this is a backward branch, add safepoint
 921     maybe_add_safepoint(default_dest);
 922     merge(default_dest);
 923     return;
 924   }
 925 
 926   ciMethodData* methodData = method()-&gt;method_data();
 927   ciMultiBranchData* profile = NULL;
 928   if (methodData-&gt;is_mature() &amp;&amp; UseSwitchProfiling) {
 929     ciProfileData* data = methodData-&gt;bci_to_data(bci());
 930     if (data != NULL &amp;&amp; data-&gt;is_MultiBranchData()) {
 931       profile = (ciMultiBranchData*)data;
 932     }
 933   }
 934   bool trim_ranges = !method_data_update() &amp;&amp; !C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);
 935 
 936   // generate decision tree, using trichotomy when possible
 937   jint* table = NEW_RESOURCE_ARRAY(jint, len*3);
 938   {
 939     for (int j = 0; j &lt; len; j++) {
 940       table[3*j+0] = iter().get_int_table(2+2*j);
 941       table[3*j+1] = iter().get_dest_table(2+2*j+1);
 942       table[3*j+2] = profile == NULL ? 1 : profile-&gt;count_at(j);
 943     }
 944     qsort(table, len, 3*sizeof(table[0]), jint_cmp);
 945   }
 946 
 947   float defaults = 0;
 948   jint prev = min_jint;
 949   for (int j = 0; j &lt; len; j++) {
 950     jint match_int = table[3*j+0];
 951     if (match_int != prev) {
 952       defaults += (float)match_int - prev;
 953     }
 954     prev = match_int+1;
 955   }
 956   if (prev-1 != max_jint) {
 957     defaults += (float)max_jint - prev + 1;
 958   }
 959   float default_cnt = 1;
 960   if (profile != NULL) {
 961     default_cnt = profile-&gt;default_count()/defaults;
 962   }
 963 
 964   int rnum = len*2+1;
 965   bool makes_backward_branch = false;
 966   SwitchRange* ranges = NEW_RESOURCE_ARRAY(SwitchRange, rnum);
 967   int rp = -1;
 968   for (int j = 0; j &lt; len; j++) {
 969     jint match_int   = table[3*j+0];
 970     int  dest        = table[3*j+1];
 971     int  cnt         = table[3*j+2];
 972     int  next_lo     = rp &lt; 0 ? min_jint : ranges[rp].hi()+1;
 973     int  table_index = method_data_update() ? j : NullTableIndex;
 974     makes_backward_branch |= (dest &lt;= bci());
 975     float c = default_cnt * ((float)match_int - next_lo);
 976     if (match_int != next_lo &amp;&amp; (rp &lt; 0 || !ranges[rp].adjoinRange(next_lo, match_int-1, default_dest, NullTableIndex, c, trim_ranges))) {
 977       assert(default_dest != never_reached, &quot;sentinel value for dead destinations&quot;);
 978       ranges[++rp].setRange(next_lo, match_int-1, default_dest, NullTableIndex, c);
 979     }
 980     if (rp &lt; 0 || !ranges[rp].adjoin(match_int, dest, table_index, cnt, trim_ranges)) {
 981       assert(dest != never_reached, &quot;sentinel value for dead destinations&quot;);
 982       ranges[++rp].set(match_int, dest, table_index, cnt);
 983     }
 984   }
 985   jint highest = table[3*(len-1)];
 986   assert(ranges[rp].hi() == highest, &quot;&quot;);
 987   if (highest != max_jint &amp;&amp;
 988       !ranges[rp].adjoinRange(highest+1, max_jint, default_dest, NullTableIndex, default_cnt * ((float)max_jint - highest), trim_ranges)) {
 989     ranges[++rp].setRange(highest+1, max_jint, default_dest, NullTableIndex, default_cnt * ((float)max_jint - highest));
 990   }
 991   assert(rp &lt; rnum, &quot;not too many ranges&quot;);
 992 
 993   if (trim_ranges) {
 994     merge_ranges(ranges, rp);
 995   }
 996 
 997   // Safepoint in case backward branch observed
 998   if (makes_backward_branch &amp;&amp; UseLoopSafepoints)
 999     add_safepoint();
1000 
1001   jump_switch_ranges(lookup, &amp;ranges[0], &amp;ranges[rp]);
1002 }
1003 
1004 static float if_prob(float taken_cnt, float total_cnt) {
1005   assert(taken_cnt &lt;= total_cnt, &quot;&quot;);
1006   if (total_cnt == 0) {
1007     return PROB_FAIR;
1008   }
1009   float p = taken_cnt / total_cnt;
1010   return clamp(p, PROB_MIN, PROB_MAX);
1011 }
1012 
1013 static float if_cnt(float cnt) {
1014   if (cnt == 0) {
1015     return COUNT_UNKNOWN;
1016   }
1017   return cnt;
1018 }
1019 
1020 static float sum_of_cnts(SwitchRange *lo, SwitchRange *hi) {
1021   float total_cnt = 0;
1022   for (SwitchRange* sr = lo; sr &lt;= hi; sr++) {
1023     total_cnt += sr-&gt;cnt();
1024   }
1025   return total_cnt;
1026 }
1027 
1028 class SwitchRanges : public ResourceObj {
1029 public:
1030   SwitchRange* _lo;
1031   SwitchRange* _hi;
1032   SwitchRange* _mid;
1033   float _cost;
1034 
1035   enum {
1036     Start,
1037     LeftDone,
1038     RightDone,
1039     Done
1040   } _state;
1041 
1042   SwitchRanges(SwitchRange *lo, SwitchRange *hi)
1043     : _lo(lo), _hi(hi), _mid(NULL),
1044       _cost(0), _state(Start) {
1045   }
1046 
1047   SwitchRanges()
1048     : _lo(NULL), _hi(NULL), _mid(NULL),
1049       _cost(0), _state(Start) {}
1050 };
1051 
1052 // Estimate cost of performing a binary search on lo..hi
1053 static float compute_tree_cost(SwitchRange *lo, SwitchRange *hi, float total_cnt) {
1054   GrowableArray&lt;SwitchRanges&gt; tree;
1055   SwitchRanges root(lo, hi);
1056   tree.push(root);
1057 
1058   float cost = 0;
1059   do {
1060     SwitchRanges&amp; r = *tree.adr_at(tree.length()-1);
1061     if (r._hi != r._lo) {
1062       if (r._mid == NULL) {
1063         float r_cnt = sum_of_cnts(r._lo, r._hi);
1064 
1065         if (r_cnt == 0) {
1066           tree.pop();
1067           cost = 0;
1068           continue;
1069         }
1070 
1071         SwitchRange* mid = NULL;
1072         mid = r._lo;
1073         for (float cnt = 0; ; ) {
1074           assert(mid &lt;= r._hi, &quot;out of bounds&quot;);
1075           cnt += mid-&gt;cnt();
1076           if (cnt &gt; r_cnt / 2) {
1077             break;
1078           }
1079           mid++;
1080         }
1081         assert(mid &lt;= r._hi, &quot;out of bounds&quot;);
1082         r._mid = mid;
1083         r._cost = r_cnt / total_cnt;
1084       }
1085       r._cost += cost;
1086       if (r._state &lt; SwitchRanges::LeftDone &amp;&amp; r._mid &gt; r._lo) {
1087         cost = 0;
1088         r._state = SwitchRanges::LeftDone;
1089         tree.push(SwitchRanges(r._lo, r._mid-1));
1090       } else if (r._state &lt; SwitchRanges::RightDone) {
1091         cost = 0;
1092         r._state = SwitchRanges::RightDone;
1093         tree.push(SwitchRanges(r._mid == r._lo ? r._mid+1 : r._mid, r._hi));
1094       } else {
1095         tree.pop();
1096         cost = r._cost;
1097       }
1098     } else {
1099       tree.pop();
1100       cost = r._cost;
1101     }
1102   } while (tree.length() &gt; 0);
1103 
1104 
1105   return cost;
1106 }
1107 
1108 // It sometimes pays off to test most common ranges before the binary search
1109 void Parse::linear_search_switch_ranges(Node* key_val, SwitchRange*&amp; lo, SwitchRange*&amp; hi) {
1110   uint nr = hi - lo + 1;
1111   float total_cnt = sum_of_cnts(lo, hi);
1112 
1113   float min = compute_tree_cost(lo, hi, total_cnt);
1114   float extra = 1;
1115   float sub = 0;
1116 
1117   SwitchRange* array1 = lo;
1118   SwitchRange* array2 = NEW_RESOURCE_ARRAY(SwitchRange, nr);
1119 
1120   SwitchRange* ranges = NULL;
1121 
1122   while (nr &gt;= 2) {
1123     assert(lo == array1 || lo == array2, &quot;one the 2 already allocated arrays&quot;);
1124     ranges = (lo == array1) ? array2 : array1;
1125 
1126     // Find highest frequency range
1127     SwitchRange* candidate = lo;
1128     for (SwitchRange* sr = lo+1; sr &lt;= hi; sr++) {
1129       if (sr-&gt;cnt() &gt; candidate-&gt;cnt()) {
1130         candidate = sr;
1131       }
1132     }
1133     SwitchRange most_freq = *candidate;
1134     if (most_freq.cnt() == 0) {
1135       break;
1136     }
1137 
1138     // Copy remaining ranges into another array
1139     int shift = 0;
1140     for (uint i = 0; i &lt; nr; i++) {
1141       SwitchRange* sr = &amp;lo[i];
1142       if (sr != candidate) {
1143         ranges[i-shift] = *sr;
1144       } else {
1145         shift++;
1146         if (i &gt; 0 &amp;&amp; i &lt; nr-1) {
1147           SwitchRange prev = lo[i-1];
1148           prev.setRange(prev.lo(), sr-&gt;hi(), prev.dest(), prev.table_index(), prev.cnt());
1149           if (prev.adjoin(lo[i+1])) {
1150             shift++;
1151             i++;
1152           }
1153           ranges[i-shift] = prev;
1154         }
1155       }
1156     }
1157     nr -= shift;
1158 
1159     // Evaluate cost of testing the most common range and performing a
1160     // binary search on the other ranges
1161     float cost = extra + compute_tree_cost(&amp;ranges[0], &amp;ranges[nr-1], total_cnt);
1162     if (cost &gt;= min) {
1163       break;
1164     }
1165     // swap arrays
1166     lo = &amp;ranges[0];
1167     hi = &amp;ranges[nr-1];
1168 
1169     // It pays off: emit the test for the most common range
1170     assert(most_freq.cnt() &gt; 0, &quot;must be taken&quot;);
1171     Node* val = _gvn.transform(new SubINode(key_val, _gvn.intcon(most_freq.lo())));
1172     Node* cmp = _gvn.transform(new CmpUNode(val, _gvn.intcon(most_freq.hi() - most_freq.lo())));
1173     Node* tst = _gvn.transform(new BoolNode(cmp, BoolTest::le));
1174     IfNode* iff = create_and_map_if(control(), tst, if_prob(most_freq.cnt(), total_cnt), if_cnt(most_freq.cnt()));
1175     jump_if_true_fork(iff, most_freq.dest(), most_freq.table_index(), false);
1176 
1177     sub += most_freq.cnt() / total_cnt;
1178     extra += 1 - sub;
1179     min = cost;
1180   }
1181 }
1182 
1183 //----------------------------create_jump_tables-------------------------------
1184 bool Parse::create_jump_tables(Node* key_val, SwitchRange* lo, SwitchRange* hi) {
1185   // Are jumptables enabled
1186   if (!UseJumpTables)  return false;
1187 
1188   // Are jumptables supported
1189   if (!Matcher::has_match_rule(Op_Jump))  return false;
1190 
1191   // Don&#39;t make jump table if profiling
1192   if (method_data_update())  return false;
1193 
1194   bool trim_ranges = !C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);
1195 
1196   // Decide if a guard is needed to lop off big ranges at either (or
1197   // both) end(s) of the input set. We&#39;ll call this the default target
1198   // even though we can&#39;t be sure that it is the true &quot;default&quot;.
1199 
1200   bool needs_guard = false;
1201   int default_dest;
1202   int64_t total_outlier_size = 0;
1203   int64_t hi_size = ((int64_t)hi-&gt;hi()) - ((int64_t)hi-&gt;lo()) + 1;
1204   int64_t lo_size = ((int64_t)lo-&gt;hi()) - ((int64_t)lo-&gt;lo()) + 1;
1205 
1206   if (lo-&gt;dest() == hi-&gt;dest()) {
1207     total_outlier_size = hi_size + lo_size;
1208     default_dest = lo-&gt;dest();
1209   } else if (lo_size &gt; hi_size) {
1210     total_outlier_size = lo_size;
1211     default_dest = lo-&gt;dest();
1212   } else {
1213     total_outlier_size = hi_size;
1214     default_dest = hi-&gt;dest();
1215   }
1216 
1217   float total = sum_of_cnts(lo, hi);
1218   float cost = compute_tree_cost(lo, hi, total);
1219 
1220   // If a guard test will eliminate very sparse end ranges, then
1221   // it is worth the cost of an extra jump.
1222   float trimmed_cnt = 0;
1223   if (total_outlier_size &gt; (MaxJumpTableSparseness * 4)) {
1224     needs_guard = true;
1225     if (default_dest == lo-&gt;dest()) {
1226       trimmed_cnt += lo-&gt;cnt();
1227       lo++;
1228     }
1229     if (default_dest == hi-&gt;dest()) {
1230       trimmed_cnt += hi-&gt;cnt();
1231       hi--;
1232     }
1233   }
1234 
1235   // Find the total number of cases and ranges
1236   int64_t num_cases = ((int64_t)hi-&gt;hi()) - ((int64_t)lo-&gt;lo()) + 1;
1237   int num_range = hi - lo + 1;
1238 
1239   // Don&#39;t create table if: too large, too small, or too sparse.
1240   if (num_cases &gt; MaxJumpTableSize)
1241     return false;
1242   if (UseSwitchProfiling) {
1243     // MinJumpTableSize is set so with a well balanced binary tree,
1244     // when the number of ranges is MinJumpTableSize, it&#39;s cheaper to
1245     // go through a JumpNode that a tree of IfNodes. Average cost of a
1246     // tree of IfNodes with MinJumpTableSize is
1247     // log2f(MinJumpTableSize) comparisons. So if the cost computed
1248     // from profile data is less than log2f(MinJumpTableSize) then
1249     // going with the binary search is cheaper.
1250     if (cost &lt; log2f(MinJumpTableSize)) {
1251       return false;
1252     }
1253   } else {
1254     if (num_cases &lt; MinJumpTableSize)
1255       return false;
1256   }
1257   if (num_cases &gt; (MaxJumpTableSparseness * num_range))
1258     return false;
1259 
1260   // Normalize table lookups to zero
1261   int lowval = lo-&gt;lo();
1262   key_val = _gvn.transform( new SubINode(key_val, _gvn.intcon(lowval)) );
1263 
1264   // Generate a guard to protect against input keyvals that aren&#39;t
1265   // in the switch domain.
1266   if (needs_guard) {
1267     Node*   size = _gvn.intcon(num_cases);
1268     Node*   cmp = _gvn.transform(new CmpUNode(key_val, size));
1269     Node*   tst = _gvn.transform(new BoolNode(cmp, BoolTest::ge));
1270     IfNode* iff = create_and_map_if(control(), tst, if_prob(trimmed_cnt, total), if_cnt(trimmed_cnt));
1271     jump_if_true_fork(iff, default_dest, NullTableIndex, trim_ranges &amp;&amp; trimmed_cnt == 0);
1272 
1273     total -= trimmed_cnt;
1274   }
1275 
1276   // Create an ideal node JumpTable that has projections
1277   // of all possible ranges for a switch statement
1278   // The key_val input must be converted to a pointer offset and scaled.
1279   // Compare Parse::array_addressing above.
1280 
1281   // Clean the 32-bit int into a real 64-bit offset.
1282   // Otherwise, the jint value 0 might turn into an offset of 0x0800000000.
1283   const TypeInt* ikeytype = TypeInt::make(0, num_cases, Type::WidenMin);
1284   // Make I2L conversion control dependent to prevent it from
1285   // floating above the range check during loop optimizations.
1286   key_val = C-&gt;conv_I2X_index(&amp;_gvn, key_val, ikeytype, control());
1287 
1288   // Shift the value by wordsize so we have an index into the table, rather
1289   // than a switch value
1290   Node *shiftWord = _gvn.MakeConX(wordSize);
1291   key_val = _gvn.transform( new MulXNode( key_val, shiftWord));
1292 
1293   // Create the JumpNode
1294   Arena* arena = C-&gt;comp_arena();
1295   float* probs = (float*)arena-&gt;Amalloc(sizeof(float)*num_cases);
1296   int i = 0;
1297   if (total == 0) {
1298     for (SwitchRange* r = lo; r &lt;= hi; r++) {
1299       for (int64_t j = r-&gt;lo(); j &lt;= r-&gt;hi(); j++, i++) {
1300         probs[i] = 1.0F / num_cases;
1301       }
1302     }
1303   } else {
1304     for (SwitchRange* r = lo; r &lt;= hi; r++) {
1305       float prob = r-&gt;cnt()/total;
1306       for (int64_t j = r-&gt;lo(); j &lt;= r-&gt;hi(); j++, i++) {
1307         probs[i] = prob / (r-&gt;hi() - r-&gt;lo() + 1);
1308       }
1309     }
1310   }
1311 
1312   ciMethodData* methodData = method()-&gt;method_data();
1313   ciMultiBranchData* profile = NULL;
1314   if (methodData-&gt;is_mature()) {
1315     ciProfileData* data = methodData-&gt;bci_to_data(bci());
1316     if (data != NULL &amp;&amp; data-&gt;is_MultiBranchData()) {
1317       profile = (ciMultiBranchData*)data;
1318     }
1319   }
1320 
1321   Node* jtn = _gvn.transform(new JumpNode(control(), key_val, num_cases, probs, profile == NULL ? COUNT_UNKNOWN : total));
1322 
1323   // These are the switch destinations hanging off the jumpnode
1324   i = 0;
1325   for (SwitchRange* r = lo; r &lt;= hi; r++) {
1326     for (int64_t j = r-&gt;lo(); j &lt;= r-&gt;hi(); j++, i++) {
1327       Node* input = _gvn.transform(new JumpProjNode(jtn, i, r-&gt;dest(), (int)(j - lowval)));
1328       {
1329         PreserveJVMState pjvms(this);
1330         set_control(input);
1331         jump_if_always_fork(r-&gt;dest(), r-&gt;table_index(), trim_ranges &amp;&amp; r-&gt;cnt() == 0);
1332       }
1333     }
1334   }
1335   assert(i == num_cases, &quot;miscount of cases&quot;);
1336   stop_and_kill_map();  // no more uses for this JVMS
1337   return true;
1338 }
1339 
1340 //----------------------------jump_switch_ranges-------------------------------
1341 void Parse::jump_switch_ranges(Node* key_val, SwitchRange *lo, SwitchRange *hi, int switch_depth) {
1342   Block* switch_block = block();
1343   bool trim_ranges = !method_data_update() &amp;&amp; !C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);
1344 
1345   if (switch_depth == 0) {
1346     // Do special processing for the top-level call.
1347     assert(lo-&gt;lo() == min_jint, &quot;initial range must exhaust Type::INT&quot;);
1348     assert(hi-&gt;hi() == max_jint, &quot;initial range must exhaust Type::INT&quot;);
1349 
1350     // Decrement pred-numbers for the unique set of nodes.
1351 #ifdef ASSERT
1352     if (!trim_ranges) {
1353       // Ensure that the block&#39;s successors are a (duplicate-free) set.
1354       int successors_counted = 0;  // block occurrences in [hi..lo]
1355       int unique_successors = switch_block-&gt;num_successors();
1356       for (int i = 0; i &lt; unique_successors; i++) {
1357         Block* target = switch_block-&gt;successor_at(i);
1358 
1359         // Check that the set of successors is the same in both places.
1360         int successors_found = 0;
1361         for (SwitchRange* p = lo; p &lt;= hi; p++) {
1362           if (p-&gt;dest() == target-&gt;start())  successors_found++;
1363         }
1364         assert(successors_found &gt; 0, &quot;successor must be known&quot;);
1365         successors_counted += successors_found;
1366       }
1367       assert(successors_counted == (hi-lo)+1, &quot;no unexpected successors&quot;);
1368     }
1369 #endif
1370 
1371     // Maybe prune the inputs, based on the type of key_val.
1372     jint min_val = min_jint;
1373     jint max_val = max_jint;
1374     const TypeInt* ti = key_val-&gt;bottom_type()-&gt;isa_int();
1375     if (ti != NULL) {
1376       min_val = ti-&gt;_lo;
1377       max_val = ti-&gt;_hi;
1378       assert(min_val &lt;= max_val, &quot;invalid int type&quot;);
1379     }
1380     while (lo-&gt;hi() &lt; min_val) {
1381       lo++;
1382     }
1383     if (lo-&gt;lo() &lt; min_val)  {
1384       lo-&gt;setRange(min_val, lo-&gt;hi(), lo-&gt;dest(), lo-&gt;table_index(), lo-&gt;cnt());
1385     }
1386     while (hi-&gt;lo() &gt; max_val) {
1387       hi--;
1388     }
1389     if (hi-&gt;hi() &gt; max_val) {
1390       hi-&gt;setRange(hi-&gt;lo(), max_val, hi-&gt;dest(), hi-&gt;table_index(), hi-&gt;cnt());
1391     }
1392 
1393     linear_search_switch_ranges(key_val, lo, hi);
1394   }
1395 
1396 #ifndef PRODUCT
1397   if (switch_depth == 0) {
1398     _max_switch_depth = 0;
1399     _est_switch_depth = log2_intptr((hi-lo+1)-1)+1;
1400   }
1401 #endif
1402 
1403   assert(lo &lt;= hi, &quot;must be a non-empty set of ranges&quot;);
1404   if (lo == hi) {
1405     jump_if_always_fork(lo-&gt;dest(), lo-&gt;table_index(), trim_ranges &amp;&amp; lo-&gt;cnt() == 0);
1406   } else {
1407     assert(lo-&gt;hi() == (lo+1)-&gt;lo()-1, &quot;contiguous ranges&quot;);
1408     assert(hi-&gt;lo() == (hi-1)-&gt;hi()+1, &quot;contiguous ranges&quot;);
1409 
1410     if (create_jump_tables(key_val, lo, hi)) return;
1411 
1412     SwitchRange* mid = NULL;
1413     float total_cnt = sum_of_cnts(lo, hi);
1414 
1415     int nr = hi - lo + 1;
1416     if (UseSwitchProfiling) {
1417       // Don&#39;t keep the binary search tree balanced: pick up mid point
1418       // that split frequencies in half.
1419       float cnt = 0;
1420       for (SwitchRange* sr = lo; sr &lt;= hi; sr++) {
1421         cnt += sr-&gt;cnt();
1422         if (cnt &gt;= total_cnt / 2) {
1423           mid = sr;
1424           break;
1425         }
1426       }
1427     } else {
1428       mid = lo + nr/2;
1429 
1430       // if there is an easy choice, pivot at a singleton:
1431       if (nr &gt; 3 &amp;&amp; !mid-&gt;is_singleton() &amp;&amp; (mid-1)-&gt;is_singleton())  mid--;
1432 
1433       assert(lo &lt; mid &amp;&amp; mid &lt;= hi, &quot;good pivot choice&quot;);
1434       assert(nr != 2 || mid == hi,   &quot;should pick higher of 2&quot;);
1435       assert(nr != 3 || mid == hi-1, &quot;should pick middle of 3&quot;);
1436     }
1437 
1438 
1439     Node *test_val = _gvn.intcon(mid == lo ? mid-&gt;hi() : mid-&gt;lo());
1440 
1441     if (mid-&gt;is_singleton()) {
1442       IfNode *iff_ne = jump_if_fork_int(key_val, test_val, BoolTest::ne, 1-if_prob(mid-&gt;cnt(), total_cnt), if_cnt(mid-&gt;cnt()));
1443       jump_if_false_fork(iff_ne, mid-&gt;dest(), mid-&gt;table_index(), trim_ranges &amp;&amp; mid-&gt;cnt() == 0);
1444 
1445       // Special Case:  If there are exactly three ranges, and the high
1446       // and low range each go to the same place, omit the &quot;gt&quot; test,
1447       // since it will not discriminate anything.
1448       bool eq_test_only = (hi == lo+2 &amp;&amp; hi-&gt;dest() == lo-&gt;dest() &amp;&amp; mid == hi-1) || mid == lo;
1449 
1450       // if there is a higher range, test for it and process it:
1451       if (mid &lt; hi &amp;&amp; !eq_test_only) {
1452         // two comparisons of same values--should enable 1 test for 2 branches
1453         // Use BoolTest::lt instead of BoolTest::gt
1454         float cnt = sum_of_cnts(lo, mid-1);
1455         IfNode *iff_lt  = jump_if_fork_int(key_val, test_val, BoolTest::lt, if_prob(cnt, total_cnt), if_cnt(cnt));
1456         Node   *iftrue  = _gvn.transform( new IfTrueNode(iff_lt) );
1457         Node   *iffalse = _gvn.transform( new IfFalseNode(iff_lt) );
1458         { PreserveJVMState pjvms(this);
1459           set_control(iffalse);
1460           jump_switch_ranges(key_val, mid+1, hi, switch_depth+1);
1461         }
1462         set_control(iftrue);
1463       }
1464 
1465     } else {
1466       // mid is a range, not a singleton, so treat mid..hi as a unit
1467       float cnt = sum_of_cnts(mid == lo ? mid+1 : mid, hi);
1468       IfNode *iff_ge = jump_if_fork_int(key_val, test_val, mid == lo ? BoolTest::gt : BoolTest::ge, if_prob(cnt, total_cnt), if_cnt(cnt));
1469 
1470       // if there is a higher range, test for it and process it:
1471       if (mid == hi) {
1472         jump_if_true_fork(iff_ge, mid-&gt;dest(), mid-&gt;table_index(), trim_ranges &amp;&amp; cnt == 0);
1473       } else {
1474         Node *iftrue  = _gvn.transform( new IfTrueNode(iff_ge) );
1475         Node *iffalse = _gvn.transform( new IfFalseNode(iff_ge) );
1476         { PreserveJVMState pjvms(this);
1477           set_control(iftrue);
1478           jump_switch_ranges(key_val, mid == lo ? mid+1 : mid, hi, switch_depth+1);
1479         }
1480         set_control(iffalse);
1481       }
1482     }
1483 
1484     // in any case, process the lower range
1485     if (mid == lo) {
1486       if (mid-&gt;is_singleton()) {
1487         jump_switch_ranges(key_val, lo+1, hi, switch_depth+1);
1488       } else {
1489         jump_if_always_fork(lo-&gt;dest(), lo-&gt;table_index(), trim_ranges &amp;&amp; lo-&gt;cnt() == 0);
1490       }
1491     } else {
1492       jump_switch_ranges(key_val, lo, mid-1, switch_depth+1);
1493     }
1494   }
1495 
1496   // Decrease pred_count for each successor after all is done.
1497   if (switch_depth == 0) {
1498     int unique_successors = switch_block-&gt;num_successors();
1499     for (int i = 0; i &lt; unique_successors; i++) {
1500       Block* target = switch_block-&gt;successor_at(i);
1501       // Throw away the pre-allocated path for each unique successor.
1502       target-&gt;next_path_num();
1503     }
1504   }
1505 
1506 #ifndef PRODUCT
1507   _max_switch_depth = MAX2(switch_depth, _max_switch_depth);
1508   if (TraceOptoParse &amp;&amp; Verbose &amp;&amp; WizardMode &amp;&amp; switch_depth == 0) {
1509     SwitchRange* r;
1510     int nsing = 0;
1511     for( r = lo; r &lt;= hi; r++ ) {
1512       if( r-&gt;is_singleton() )  nsing++;
1513     }
1514     tty-&gt;print(&quot;&gt;&gt;&gt; &quot;);
1515     _method-&gt;print_short_name();
1516     tty-&gt;print_cr(&quot; switch decision tree&quot;);
1517     tty-&gt;print_cr(&quot;    %d ranges (%d singletons), max_depth=%d, est_depth=%d&quot;,
1518                   (int) (hi-lo+1), nsing, _max_switch_depth, _est_switch_depth);
1519     if (_max_switch_depth &gt; _est_switch_depth) {
1520       tty-&gt;print_cr(&quot;******** BAD SWITCH DEPTH ********&quot;);
1521     }
1522     tty-&gt;print(&quot;   &quot;);
1523     for( r = lo; r &lt;= hi; r++ ) {
1524       r-&gt;print();
1525     }
1526     tty-&gt;cr();
1527   }
1528 #endif
1529 }
1530 
1531 void Parse::modf() {
1532   Node *f2 = pop();
1533   Node *f1 = pop();
1534   Node* c = make_runtime_call(RC_LEAF, OptoRuntime::modf_Type(),
1535                               CAST_FROM_FN_PTR(address, SharedRuntime::frem),
1536                               &quot;frem&quot;, NULL, //no memory effects
1537                               f1, f2);
1538   Node* res = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 0));
1539 
1540   push(res);
1541 }
1542 
1543 void Parse::modd() {
1544   Node *d2 = pop_pair();
1545   Node *d1 = pop_pair();
1546   Node* c = make_runtime_call(RC_LEAF, OptoRuntime::Math_DD_D_Type(),
1547                               CAST_FROM_FN_PTR(address, SharedRuntime::drem),
1548                               &quot;drem&quot;, NULL, //no memory effects
1549                               d1, top(), d2, top());
1550   Node* res_d   = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 0));
1551 
1552 #ifdef ASSERT
1553   Node* res_top = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 1));
1554   assert(res_top == top(), &quot;second value must be top&quot;);
1555 #endif
1556 
1557   push_pair(res_d);
1558 }
1559 
1560 void Parse::l2f() {
1561   Node* f2 = pop();
1562   Node* f1 = pop();
1563   Node* c = make_runtime_call(RC_LEAF, OptoRuntime::l2f_Type(),
1564                               CAST_FROM_FN_PTR(address, SharedRuntime::l2f),
1565                               &quot;l2f&quot;, NULL, //no memory effects
1566                               f1, f2);
1567   Node* res = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 0));
1568 
1569   push(res);
1570 }
1571 
1572 void Parse::do_irem() {
1573   // Must keep both values on the expression-stack during null-check
1574   zero_check_int(peek());
1575   // Compile-time detect of null-exception?
1576   if (stopped())  return;
1577 
1578   Node* b = pop();
1579   Node* a = pop();
1580 
1581   const Type *t = _gvn.type(b);
1582   if (t != Type::TOP) {
1583     const TypeInt *ti = t-&gt;is_int();
1584     if (ti-&gt;is_con()) {
1585       int divisor = ti-&gt;get_con();
1586       // check for positive power of 2
1587       if (divisor &gt; 0 &amp;&amp;
1588           (divisor &amp; ~(divisor-1)) == divisor) {
1589         // yes !
1590         Node *mask = _gvn.intcon((divisor - 1));
1591         // Sigh, must handle negative dividends
1592         Node *zero = _gvn.intcon(0);
1593         IfNode *ifff = jump_if_fork_int(a, zero, BoolTest::lt, PROB_FAIR, COUNT_UNKNOWN);
1594         Node *iff = _gvn.transform( new IfFalseNode(ifff) );
1595         Node *ift = _gvn.transform( new IfTrueNode (ifff) );
1596         Node *reg = jump_if_join(ift, iff);
1597         Node *phi = PhiNode::make(reg, NULL, TypeInt::INT);
1598         // Negative path; negate/and/negate
1599         Node *neg = _gvn.transform( new SubINode(zero, a) );
1600         Node *andn= _gvn.transform( new AndINode(neg, mask) );
1601         Node *negn= _gvn.transform( new SubINode(zero, andn) );
1602         phi-&gt;init_req(1, negn);
1603         // Fast positive case
1604         Node *andx = _gvn.transform( new AndINode(a, mask) );
1605         phi-&gt;init_req(2, andx);
1606         // Push the merge
1607         push( _gvn.transform(phi) );
1608         return;
1609       }
1610     }
1611   }
1612   // Default case
1613   push( _gvn.transform( new ModINode(control(),a,b) ) );
1614 }
1615 
1616 // Handle jsr and jsr_w bytecode
1617 void Parse::do_jsr() {
1618   assert(bc() == Bytecodes::_jsr || bc() == Bytecodes::_jsr_w, &quot;wrong bytecode&quot;);
1619 
1620   // Store information about current state, tagged with new _jsr_bci
1621   int return_bci = iter().next_bci();
1622   int jsr_bci    = (bc() == Bytecodes::_jsr) ? iter().get_dest() : iter().get_far_dest();
1623 
1624   // Update method data
1625   profile_taken_branch(jsr_bci);
1626 
1627   // The way we do things now, there is only one successor block
1628   // for the jsr, because the target code is cloned by ciTypeFlow.
1629   Block* target = successor_for_bci(jsr_bci);
1630 
1631   // What got pushed?
1632   const Type* ret_addr = target-&gt;peek();
1633   assert(ret_addr-&gt;singleton(), &quot;must be a constant (cloned jsr body)&quot;);
1634 
1635   // Effect on jsr on stack
1636   push(_gvn.makecon(ret_addr));
1637 
1638   // Flow to the jsr.
1639   merge(jsr_bci);
1640 }
1641 
1642 // Handle ret bytecode
1643 void Parse::do_ret() {
1644   // Find to whom we return.
1645   assert(block()-&gt;num_successors() == 1, &quot;a ret can only go one place now&quot;);
1646   Block* target = block()-&gt;successor_at(0);
1647   assert(!target-&gt;is_ready(), &quot;our arrival must be expected&quot;);
1648   profile_ret(target-&gt;flow()-&gt;start());
1649   int pnum = target-&gt;next_path_num();
1650   merge_common(target, pnum);
1651 }
1652 
1653 static bool has_injected_profile(BoolTest::mask btest, Node* test, int&amp; taken, int&amp; not_taken) {
1654   if (btest != BoolTest::eq &amp;&amp; btest != BoolTest::ne) {
1655     // Only ::eq and ::ne are supported for profile injection.
1656     return false;
1657   }
1658   if (test-&gt;is_Cmp() &amp;&amp;
1659       test-&gt;in(1)-&gt;Opcode() == Op_ProfileBoolean) {
1660     ProfileBooleanNode* profile = (ProfileBooleanNode*)test-&gt;in(1);
1661     int false_cnt = profile-&gt;false_count();
1662     int  true_cnt = profile-&gt;true_count();
1663 
1664     // Counts matching depends on the actual test operation (::eq or ::ne).
1665     // No need to scale the counts because profile injection was designed
1666     // to feed exact counts into VM.
1667     taken     = (btest == BoolTest::eq) ? false_cnt :  true_cnt;
1668     not_taken = (btest == BoolTest::eq) ?  true_cnt : false_cnt;
1669 
1670     profile-&gt;consume();
1671     return true;
1672   }
1673   return false;
1674 }
1675 //--------------------------dynamic_branch_prediction--------------------------
1676 // Try to gather dynamic branch prediction behavior.  Return a probability
1677 // of the branch being taken and set the &quot;cnt&quot; field.  Returns a -1.0
1678 // if we need to use static prediction for some reason.
1679 float Parse::dynamic_branch_prediction(float &amp;cnt, BoolTest::mask btest, Node* test) {
1680   ResourceMark rm;
1681 
1682   cnt  = COUNT_UNKNOWN;
1683 
1684   int     taken = 0;
1685   int not_taken = 0;
1686 
1687   bool use_mdo = !has_injected_profile(btest, test, taken, not_taken);
1688 
1689   if (use_mdo) {
1690     // Use MethodData information if it is available
1691     // FIXME: free the ProfileData structure
1692     ciMethodData* methodData = method()-&gt;method_data();
1693     if (!methodData-&gt;is_mature())  return PROB_UNKNOWN;
1694     ciProfileData* data = methodData-&gt;bci_to_data(bci());
1695     if (data == NULL) {
1696       return PROB_UNKNOWN;
1697     }
1698     if (!data-&gt;is_JumpData())  return PROB_UNKNOWN;
1699 
1700     // get taken and not taken values
1701     taken = data-&gt;as_JumpData()-&gt;taken();
1702     not_taken = 0;
1703     if (data-&gt;is_BranchData()) {
1704       not_taken = data-&gt;as_BranchData()-&gt;not_taken();
1705     }
1706 
1707     // scale the counts to be commensurate with invocation counts:
1708     taken = method()-&gt;scale_count(taken);
1709     not_taken = method()-&gt;scale_count(not_taken);
1710   }
1711 
1712   // Give up if too few (or too many, in which case the sum will overflow) counts to be meaningful.
1713   // We also check that individual counters are positive first, otherwise the sum can become positive.
1714   if (taken &lt; 0 || not_taken &lt; 0 || taken + not_taken &lt; 40) {
1715     if (C-&gt;log() != NULL) {
1716       C-&gt;log()-&gt;elem(&quot;branch target_bci=&#39;%d&#39; taken=&#39;%d&#39; not_taken=&#39;%d&#39;&quot;, iter().get_dest(), taken, not_taken);
1717     }
1718     return PROB_UNKNOWN;
1719   }
1720 
1721   // Compute frequency that we arrive here
1722   float sum = taken + not_taken;
1723   // Adjust, if this block is a cloned private block but the
1724   // Jump counts are shared.  Taken the private counts for
1725   // just this path instead of the shared counts.
1726   if( block()-&gt;count() &gt; 0 )
1727     sum = block()-&gt;count();
1728   cnt = sum / FreqCountInvocations;
1729 
1730   // Pin probability to sane limits
1731   float prob;
1732   if( !taken )
1733     prob = (0+PROB_MIN) / 2;
1734   else if( !not_taken )
1735     prob = (1+PROB_MAX) / 2;
1736   else {                         // Compute probability of true path
1737     prob = (float)taken / (float)(taken + not_taken);
1738     if (prob &gt; PROB_MAX)  prob = PROB_MAX;
1739     if (prob &lt; PROB_MIN)   prob = PROB_MIN;
1740   }
1741 
1742   assert((cnt &gt; 0.0f) &amp;&amp; (prob &gt; 0.0f),
1743          &quot;Bad frequency assignment in if&quot;);
1744 
1745   if (C-&gt;log() != NULL) {
1746     const char* prob_str = NULL;
1747     if (prob &gt;= PROB_MAX)  prob_str = (prob == PROB_MAX) ? &quot;max&quot; : &quot;always&quot;;
1748     if (prob &lt;= PROB_MIN)  prob_str = (prob == PROB_MIN) ? &quot;min&quot; : &quot;never&quot;;
1749     char prob_str_buf[30];
1750     if (prob_str == NULL) {
1751       jio_snprintf(prob_str_buf, sizeof(prob_str_buf), &quot;%20.2f&quot;, prob);
1752       prob_str = prob_str_buf;
1753     }
1754     C-&gt;log()-&gt;elem(&quot;branch target_bci=&#39;%d&#39; taken=&#39;%d&#39; not_taken=&#39;%d&#39; cnt=&#39;%f&#39; prob=&#39;%s&#39;&quot;,
1755                    iter().get_dest(), taken, not_taken, cnt, prob_str);
1756   }
1757   return prob;
1758 }
1759 
1760 //-----------------------------branch_prediction-------------------------------
1761 float Parse::branch_prediction(float&amp; cnt,
1762                                BoolTest::mask btest,
1763                                int target_bci,
1764                                Node* test) {
1765   float prob = dynamic_branch_prediction(cnt, btest, test);
1766   // If prob is unknown, switch to static prediction
1767   if (prob != PROB_UNKNOWN)  return prob;
1768 
1769   prob = PROB_FAIR;                   // Set default value
1770   if (btest == BoolTest::eq)          // Exactly equal test?
1771     prob = PROB_STATIC_INFREQUENT;    // Assume its relatively infrequent
1772   else if (btest == BoolTest::ne)
1773     prob = PROB_STATIC_FREQUENT;      // Assume its relatively frequent
1774 
1775   // If this is a conditional test guarding a backwards branch,
1776   // assume its a loop-back edge.  Make it a likely taken branch.
1777   if (target_bci &lt; bci()) {
1778     if (is_osr_parse()) {    // Could be a hot OSR&#39;d loop; force deopt
1779       // Since it&#39;s an OSR, we probably have profile data, but since
1780       // branch_prediction returned PROB_UNKNOWN, the counts are too small.
1781       // Let&#39;s make a special check here for completely zero counts.
1782       ciMethodData* methodData = method()-&gt;method_data();
1783       if (!methodData-&gt;is_empty()) {
1784         ciProfileData* data = methodData-&gt;bci_to_data(bci());
1785         // Only stop for truly zero counts, which mean an unknown part
1786         // of the OSR-ed method, and we want to deopt to gather more stats.
1787         // If you have ANY counts, then this loop is simply &#39;cold&#39; relative
1788         // to the OSR loop.
1789         if (data == NULL ||
1790             (data-&gt;as_BranchData()-&gt;taken() +  data-&gt;as_BranchData()-&gt;not_taken() == 0)) {
1791           // This is the only way to return PROB_UNKNOWN:
1792           return PROB_UNKNOWN;
1793         }
1794       }
1795     }
1796     prob = PROB_STATIC_FREQUENT;     // Likely to take backwards branch
1797   }
1798 
1799   assert(prob != PROB_UNKNOWN, &quot;must have some guess at this point&quot;);
1800   return prob;
1801 }
1802 
1803 // The magic constants are chosen so as to match the output of
1804 // branch_prediction() when the profile reports a zero taken count.
1805 // It is important to distinguish zero counts unambiguously, because
1806 // some branches (e.g., _213_javac.Assembler.eliminate) validly produce
1807 // very small but nonzero probabilities, which if confused with zero
1808 // counts would keep the program recompiling indefinitely.
1809 bool Parse::seems_never_taken(float prob) const {
1810   return prob &lt; PROB_MIN;
1811 }
1812 
1813 // True if the comparison seems to be the kind that will not change its
1814 // statistics from true to false.  See comments in adjust_map_after_if.
1815 // This question is only asked along paths which are already
1816 // classifed as untaken (by seems_never_taken), so really,
1817 // if a path is never taken, its controlling comparison is
1818 // already acting in a stable fashion.  If the comparison
1819 // seems stable, we will put an expensive uncommon trap
1820 // on the untaken path.
1821 bool Parse::seems_stable_comparison() const {
1822   if (C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if)) {
1823     return false;
1824   }
1825   return true;
1826 }
1827 
1828 //-------------------------------repush_if_args--------------------------------
1829 // Push arguments of an &quot;if&quot; bytecode back onto the stack by adjusting _sp.
1830 inline int Parse::repush_if_args() {
1831   if (PrintOpto &amp;&amp; WizardMode) {
1832     tty-&gt;print(&quot;defending against excessive implicit null exceptions on %s @%d in &quot;,
1833                Bytecodes::name(iter().cur_bc()), iter().cur_bci());
1834     method()-&gt;print_name(); tty-&gt;cr();
1835   }
1836   int bc_depth = - Bytecodes::depth(iter().cur_bc());
1837   assert(bc_depth == 1 || bc_depth == 2, &quot;only two kinds of branches&quot;);
1838   DEBUG_ONLY(sync_jvms());   // argument(n) requires a synced jvms
1839   assert(argument(0) != NULL, &quot;must exist&quot;);
1840   assert(bc_depth == 1 || argument(1) != NULL, &quot;two must exist&quot;);
1841   inc_sp(bc_depth);
1842   return bc_depth;
1843 }
1844 
1845 //----------------------------------do_ifnull----------------------------------
1846 void Parse::do_ifnull(BoolTest::mask btest, Node *c) {
1847   int target_bci = iter().get_dest();
1848 
1849   Block* branch_block = successor_for_bci(target_bci);
1850   Block* next_block   = successor_for_bci(iter().next_bci());
1851 
1852   float cnt;
1853   float prob = branch_prediction(cnt, btest, target_bci, c);
1854   if (prob == PROB_UNKNOWN) {
1855     // (An earlier version of do_ifnull omitted this trap for OSR methods.)
1856     if (PrintOpto &amp;&amp; Verbose) {
1857       tty-&gt;print_cr(&quot;Never-taken edge stops compilation at bci %d&quot;, bci());
1858     }
1859     repush_if_args(); // to gather stats on loop
1860     // We need to mark this branch as taken so that if we recompile we will
1861     // see that it is possible. In the tiered system the interpreter doesn&#39;t
1862     // do profiling and by the time we get to the lower tier from the interpreter
1863     // the path may be cold again. Make sure it doesn&#39;t look untaken
1864     profile_taken_branch(target_bci, !ProfileInterpreter);
1865     uncommon_trap(Deoptimization::Reason_unreached,
1866                   Deoptimization::Action_reinterpret,
1867                   NULL, &quot;cold&quot;);
1868     if (C-&gt;eliminate_boxing()) {
1869       // Mark the successor blocks as parsed
1870       branch_block-&gt;next_path_num();
1871       next_block-&gt;next_path_num();
1872     }
1873     return;
1874   }
1875 
1876   NOT_PRODUCT(explicit_null_checks_inserted++);
1877 
1878   // Generate real control flow
1879   Node   *tst = _gvn.transform( new BoolNode( c, btest ) );
1880 
1881   // Sanity check the probability value
1882   assert(prob &gt; 0.0f,&quot;Bad probability in Parser&quot;);
1883  // Need xform to put node in hash table
1884   IfNode *iff = create_and_xform_if( control(), tst, prob, cnt );
1885   assert(iff-&gt;_prob &gt; 0.0f,&quot;Optimizer made bad probability in parser&quot;);
1886   // True branch
1887   { PreserveJVMState pjvms(this);
1888     Node* iftrue  = _gvn.transform( new IfTrueNode (iff) );
1889     set_control(iftrue);
1890 
1891     if (stopped()) {            // Path is dead?
1892       NOT_PRODUCT(explicit_null_checks_elided++);
1893       if (C-&gt;eliminate_boxing()) {
1894         // Mark the successor block as parsed
1895         branch_block-&gt;next_path_num();
1896       }
1897     } else {                    // Path is live.
1898       // Update method data
1899       profile_taken_branch(target_bci);
1900       adjust_map_after_if(btest, c, prob, branch_block);
1901       if (!stopped()) {
1902         merge(target_bci);
1903       }
1904     }
1905   }
1906 
1907   // False branch
1908   Node* iffalse = _gvn.transform( new IfFalseNode(iff) );
1909   set_control(iffalse);
1910 
1911   if (stopped()) {              // Path is dead?
1912     NOT_PRODUCT(explicit_null_checks_elided++);
1913     if (C-&gt;eliminate_boxing()) {
1914       // Mark the successor block as parsed
1915       next_block-&gt;next_path_num();
1916     }
1917   } else  {                     // Path is live.
1918     // Update method data
1919     profile_not_taken_branch();
1920     adjust_map_after_if(BoolTest(btest).negate(), c, 1.0-prob, next_block);
1921   }
1922 }
1923 
1924 //------------------------------------do_if------------------------------------
1925 void Parse::do_if(BoolTest::mask btest, Node* c, bool new_path, Node** ctrl_taken) {
1926   int target_bci = iter().get_dest();
1927 
1928   Block* branch_block = successor_for_bci(target_bci);
1929   Block* next_block   = successor_for_bci(iter().next_bci());
1930 
1931   float cnt;
1932   float prob = branch_prediction(cnt, btest, target_bci, c);
1933   float untaken_prob = 1.0 - prob;
1934 
1935   if (prob == PROB_UNKNOWN) {
1936     if (PrintOpto &amp;&amp; Verbose) {
1937       tty-&gt;print_cr(&quot;Never-taken edge stops compilation at bci %d&quot;, bci());
1938     }
1939     repush_if_args(); // to gather stats on loop
1940     // We need to mark this branch as taken so that if we recompile we will
1941     // see that it is possible. In the tiered system the interpreter doesn&#39;t
1942     // do profiling and by the time we get to the lower tier from the interpreter
1943     // the path may be cold again. Make sure it doesn&#39;t look untaken
1944     profile_taken_branch(target_bci, !ProfileInterpreter);
1945     uncommon_trap(Deoptimization::Reason_unreached,
1946                   Deoptimization::Action_reinterpret,
1947                   NULL, &quot;cold&quot;);
1948     if (C-&gt;eliminate_boxing()) {
1949       // Mark the successor blocks as parsed
1950       branch_block-&gt;next_path_num();
1951       next_block-&gt;next_path_num();
1952     }
1953     return;
1954   }
1955 
1956   // Sanity check the probability value
1957   assert(0.0f &lt; prob &amp;&amp; prob &lt; 1.0f,&quot;Bad probability in Parser&quot;);
1958 
1959   bool taken_if_true = true;
1960   // Convert BoolTest to canonical form:
1961   if (!BoolTest(btest).is_canonical()) {
1962     btest         = BoolTest(btest).negate();
1963     taken_if_true = false;
1964     // prob is NOT updated here; it remains the probability of the taken
1965     // path (as opposed to the prob of the path guarded by an &#39;IfTrueNode&#39;).
1966   }
1967   assert(btest != BoolTest::eq, &quot;!= is the only canonical exact test&quot;);
1968 
1969   Node* tst0 = new BoolNode(c, btest);
1970   Node* tst = _gvn.transform(tst0);
1971   BoolTest::mask taken_btest   = BoolTest::illegal;
1972   BoolTest::mask untaken_btest = BoolTest::illegal;
1973 
1974   if (tst-&gt;is_Bool()) {
1975     // Refresh c from the transformed bool node, since it may be
1976     // simpler than the original c.  Also re-canonicalize btest.
1977     // This wins when (Bool ne (Conv2B p) 0) =&gt; (Bool ne (CmpP p NULL)).
1978     // That can arise from statements like: if (x instanceof C) ...
1979     if (tst != tst0) {
1980       // Canonicalize one more time since transform can change it.
1981       btest = tst-&gt;as_Bool()-&gt;_test._test;
1982       if (!BoolTest(btest).is_canonical()) {
1983         // Reverse edges one more time...
1984         tst   = _gvn.transform( tst-&gt;as_Bool()-&gt;negate(&amp;_gvn) );
1985         btest = tst-&gt;as_Bool()-&gt;_test._test;
1986         assert(BoolTest(btest).is_canonical(), &quot;sanity&quot;);
1987         taken_if_true = !taken_if_true;
1988       }
1989       c = tst-&gt;in(1);
1990     }
1991     BoolTest::mask neg_btest = BoolTest(btest).negate();
1992     taken_btest   = taken_if_true ?     btest : neg_btest;
1993     untaken_btest = taken_if_true ? neg_btest :     btest;
1994   }
1995 
1996   // Generate real control flow
1997   float true_prob = (taken_if_true ? prob : untaken_prob);
1998   IfNode* iff = create_and_map_if(control(), tst, true_prob, cnt);
1999   assert(iff-&gt;_prob &gt; 0.0f,&quot;Optimizer made bad probability in parser&quot;);
2000   Node* taken_branch   = new IfTrueNode(iff);
2001   Node* untaken_branch = new IfFalseNode(iff);
2002   if (!taken_if_true) {  // Finish conversion to canonical form
2003     Node* tmp      = taken_branch;
2004     taken_branch   = untaken_branch;
2005     untaken_branch = tmp;
2006   }
2007 
2008   // Branch is taken:
2009   { PreserveJVMState pjvms(this);
2010     taken_branch = _gvn.transform(taken_branch);
2011     set_control(taken_branch);
2012 
2013     if (stopped()) {
2014       if (C-&gt;eliminate_boxing() &amp;&amp; !new_path) {
2015         // Mark the successor block as parsed (if we haven&#39;t created a new path)
2016         branch_block-&gt;next_path_num();
2017       }
2018     } else {
2019       // Update method data
2020       profile_taken_branch(target_bci);
2021       adjust_map_after_if(taken_btest, c, prob, branch_block);
2022       if (!stopped()) {
2023         if (new_path) {
2024           // Merge by using a new path
2025           merge_new_path(target_bci);
2026         } else if (ctrl_taken != NULL) {
2027           // Don&#39;t merge but save taken branch to be wired by caller
2028           *ctrl_taken = control();
2029         } else {
2030           merge(target_bci);
2031         }
2032       }
2033     }
2034   }
2035 
2036   untaken_branch = _gvn.transform(untaken_branch);
2037   set_control(untaken_branch);
2038 
2039   // Branch not taken.
2040   if (stopped() &amp;&amp; ctrl_taken == NULL) {
2041     if (C-&gt;eliminate_boxing()) {
2042       // Mark the successor block as parsed (if caller does not re-wire control flow)
2043       next_block-&gt;next_path_num();
2044     }
2045   } else {
2046     // Update method data
2047     profile_not_taken_branch();
2048     adjust_map_after_if(untaken_btest, c, untaken_prob, next_block);
2049   }
2050 }
2051 
2052 void Parse::do_acmp(BoolTest::mask btest, Node* a, Node* b) {
2053   ciMethod* subst_method = ciEnv::current()-&gt;ValueBootstrapMethods_klass()-&gt;find_method(ciSymbol::isSubstitutable_name(), ciSymbol::object_object_boolean_signature());
2054   // If current method is ValueBootstrapMethods::isSubstitutable(),
2055   // compile the acmp as a regular pointer comparison otherwise we
2056   // could call ValueBootstrapMethods::isSubstitutable() back
2057   if (!EnableValhalla || (method() == subst_method)) {
2058     Node* cmp = CmpP(a, b);
2059     cmp = optimize_cmp_with_klass(cmp);
2060     do_if(btest, cmp);
2061     return;
2062   }
2063 
2064   // Allocate value type operands and re-execute on deoptimization
2065   if (a-&gt;is_ValueType()) {
2066     PreserveReexecuteState preexecs(this);
2067     inc_sp(2);
2068     jvms()-&gt;set_should_reexecute(true);
2069     a = a-&gt;as_ValueType()-&gt;buffer(this)-&gt;get_oop();
2070   }
2071   if (b-&gt;is_ValueType()) {
2072     PreserveReexecuteState preexecs(this);
2073     inc_sp(2);
2074     jvms()-&gt;set_should_reexecute(true);
2075     b = b-&gt;as_ValueType()-&gt;buffer(this)-&gt;get_oop();
2076   }
2077 
2078   // First, do a normal pointer comparison
2079   const TypeOopPtr* ta = _gvn.type(a)-&gt;isa_oopptr();
2080   const TypeOopPtr* tb = _gvn.type(b)-&gt;isa_oopptr();
2081   Node* cmp = CmpP(a, b);
2082   cmp = optimize_cmp_with_klass(cmp);
2083   if (ta == NULL || !ta-&gt;can_be_value_type() ||
2084       tb == NULL || !tb-&gt;can_be_value_type()) {
2085     // This is sufficient, if one of the operands can&#39;t be a value type
2086     do_if(btest, cmp);
2087     return;
2088   }
2089   Node* eq_region = NULL;
2090   if (btest == BoolTest::eq) {
2091     do_if(btest, cmp, true);
2092     if (stopped()) {
2093       return;
2094     }
2095   } else {
2096     assert(btest == BoolTest::ne, &quot;only eq or ne&quot;);
2097     Node* is_not_equal = NULL;
2098     eq_region = new RegionNode(3);
2099     {
2100       PreserveJVMState pjvms(this);
2101       do_if(btest, cmp, false, &amp;is_not_equal);
2102       if (!stopped()) {
2103         eq_region-&gt;init_req(1, control());
2104       }
2105     }
2106     if (is_not_equal == NULL || is_not_equal-&gt;is_top()) {
2107       record_for_igvn(eq_region);
2108       set_control(_gvn.transform(eq_region));
2109       return;
2110     }
2111     set_control(is_not_equal);
2112   }
2113 
2114   // Pointers are not equal, check if first operand is non-null
2115   Node* ne_region = new RegionNode(6);
2116   inc_sp(2);
2117   Node* null_ctl = top();
2118   Node* not_null_a = null_check_oop(a, &amp;null_ctl, !too_many_traps(Deoptimization::Reason_null_check), false, false);
2119   dec_sp(2);
2120   ne_region-&gt;init_req(1, null_ctl);
2121   if (stopped()) {
2122     record_for_igvn(ne_region);
2123     set_control(_gvn.transform(ne_region));
2124     if (btest == BoolTest::ne) {
2125       {
2126         PreserveJVMState pjvms(this);
2127         int target_bci = iter().get_dest();
2128         merge(target_bci);
2129       }
2130       record_for_igvn(eq_region);
2131       set_control(_gvn.transform(eq_region));
2132     }
2133     return;
2134   }
2135 
2136   // First operand is non-null, check if it is a value type
2137   Node* is_value = is_value_type(not_null_a);
2138   IfNode* is_value_iff = create_and_map_if(control(), is_value, PROB_FAIR, COUNT_UNKNOWN);
2139   Node* not_value = _gvn.transform(new IfFalseNode(is_value_iff));
2140   ne_region-&gt;init_req(2, not_value);
2141   set_control(_gvn.transform(new IfTrueNode(is_value_iff)));
2142 
2143   // The first operand is a value type, check if the second operand is non-null
2144   inc_sp(2);
2145   null_ctl = top();
2146   Node* not_null_b = null_check_oop(b, &amp;null_ctl, !too_many_traps(Deoptimization::Reason_null_check), false, false);
2147   dec_sp(2);
2148   ne_region-&gt;init_req(3, null_ctl);
2149   if (stopped()) {
2150     record_for_igvn(ne_region);
2151     set_control(_gvn.transform(ne_region));
2152     if (btest == BoolTest::ne) {
2153       {
2154         PreserveJVMState pjvms(this);
2155         int target_bci = iter().get_dest();
2156         merge(target_bci);
2157       }
2158       record_for_igvn(eq_region);
2159       set_control(_gvn.transform(eq_region));
2160     }
2161     return;
2162   }
2163 
2164   // Check if both operands are of the same class.
2165   Node* kls_a = load_object_klass(not_null_a);
2166   Node* kls_b = load_object_klass(not_null_b);
2167   Node* kls_cmp = CmpP(kls_a, kls_b);
2168   Node* kls_bol = _gvn.transform(new BoolNode(kls_cmp, BoolTest::ne));
2169   IfNode* kls_iff = create_and_map_if(control(), kls_bol, PROB_FAIR, COUNT_UNKNOWN);
2170   Node* kls_ne = _gvn.transform(new IfTrueNode(kls_iff));
2171   set_control(_gvn.transform(new IfFalseNode(kls_iff)));
2172   ne_region-&gt;init_req(4, kls_ne);
2173 
2174   if (stopped()) {
2175     record_for_igvn(ne_region);
2176     set_control(_gvn.transform(ne_region));
2177     if (btest == BoolTest::ne) {
2178       {
2179         PreserveJVMState pjvms(this);
2180         int target_bci = iter().get_dest();
2181         merge(target_bci);
2182       }
2183       record_for_igvn(eq_region);
2184       set_control(_gvn.transform(eq_region));
2185     }
2186     return;
2187   }
2188 
2189   // Both operands are values types of the same class, we need to perform a
2190   // substitutability test. Delegate to ValueBootstrapMethods::isSubstitutable().
2191   Node* ne_io_phi = PhiNode::make(ne_region, i_o());
2192   Node* mem = reset_memory();
2193   Node* ne_mem_phi = PhiNode::make(ne_region, mem);
2194 
2195   Node* eq_io_phi = NULL;
2196   Node* eq_mem_phi = NULL;
2197   if (eq_region != NULL) {
2198     eq_io_phi = PhiNode::make(eq_region, i_o());
2199     eq_mem_phi = PhiNode::make(eq_region, mem);
2200   }
2201 
2202   set_all_memory(mem);
2203 
2204   kill_dead_locals();
2205   CallStaticJavaNode *call = new CallStaticJavaNode(C, TypeFunc::make(subst_method), SharedRuntime::get_resolve_static_call_stub(), subst_method, bci());
2206   call-&gt;set_override_symbolic_info(true);
2207   call-&gt;init_req(TypeFunc::Parms, not_null_a);
2208   call-&gt;init_req(TypeFunc::Parms+1, not_null_b);
2209   inc_sp(2);
2210   set_edges_for_java_call(call, false, false);
2211   Node* ret = set_results_for_java_call(call, false, true);
2212   dec_sp(2);
2213 
2214   // Test the return value of ValueBootstrapMethods::isSubstitutable()
2215   Node* subst_cmp = _gvn.transform(new CmpINode(ret, intcon(1)));
2216   Node* ctl = C-&gt;top();
2217   if (btest == BoolTest::eq) {
2218     PreserveJVMState pjvms(this);
2219     do_if(btest, subst_cmp);
2220     if (!stopped()) {
2221       ctl = control();
2222     }
2223   } else {
2224     assert(btest == BoolTest::ne, &quot;only eq or ne&quot;);
2225     PreserveJVMState pjvms(this);
2226     do_if(btest, subst_cmp, false, &amp;ctl);
2227     if (!stopped()) {
2228       eq_region-&gt;init_req(2, control());
2229       eq_io_phi-&gt;init_req(2, i_o());
2230       eq_mem_phi-&gt;init_req(2, reset_memory());
2231     }
2232   }
2233   ne_region-&gt;init_req(5, ctl);
2234   ne_io_phi-&gt;init_req(5, i_o());
2235   ne_mem_phi-&gt;init_req(5, reset_memory());
2236 
2237   record_for_igvn(ne_region);
2238   set_control(_gvn.transform(ne_region));
2239   set_i_o(_gvn.transform(ne_io_phi));
2240   set_all_memory(_gvn.transform(ne_mem_phi));
2241 
2242   if (btest == BoolTest::ne) {
2243     {
2244       PreserveJVMState pjvms(this);
2245       int target_bci = iter().get_dest();
2246       merge(target_bci);
2247     }
2248 
2249     record_for_igvn(eq_region);
2250     set_control(_gvn.transform(eq_region));
2251     set_i_o(_gvn.transform(eq_io_phi));
2252     set_all_memory(_gvn.transform(eq_mem_phi));
2253   }
2254 }
2255 
2256 bool Parse::path_is_suitable_for_uncommon_trap(float prob) const {
2257   // Don&#39;t want to speculate on uncommon traps when running with -Xcomp
2258   if (!UseInterpreter) {
2259     return false;
2260   }
2261   return (seems_never_taken(prob) &amp;&amp; seems_stable_comparison());
2262 }
2263 
2264 void Parse::maybe_add_predicate_after_if(Block* path) {
2265   if (path-&gt;is_SEL_head() &amp;&amp; path-&gt;preds_parsed() == 0) {
2266     // Add predicates at bci of if dominating the loop so traps can be
2267     // recorded on the if&#39;s profile data
2268     int bc_depth = repush_if_args();
2269     add_empty_predicates();
2270     dec_sp(bc_depth);
2271     path-&gt;set_has_predicates();
2272   }
2273 }
2274 
2275 
2276 //----------------------------adjust_map_after_if------------------------------
2277 // Adjust the JVM state to reflect the result of taking this path.
2278 // Basically, it means inspecting the CmpNode controlling this
2279 // branch, seeing how it constrains a tested value, and then
2280 // deciding if it&#39;s worth our while to encode this constraint
2281 // as graph nodes in the current abstract interpretation map.
2282 void Parse::adjust_map_after_if(BoolTest::mask btest, Node* c, float prob, Block* path) {
2283   if (!c-&gt;is_Cmp()) {
2284     maybe_add_predicate_after_if(path);
2285     return;
2286   }
2287 
2288   if (stopped() || btest == BoolTest::illegal) {
2289     return;                             // nothing to do
2290   }
2291 
2292   bool is_fallthrough = (path == successor_for_bci(iter().next_bci()));
2293 
2294   if (path_is_suitable_for_uncommon_trap(prob)) {
2295     repush_if_args();
2296     uncommon_trap(Deoptimization::Reason_unstable_if,
2297                   Deoptimization::Action_reinterpret,
2298                   NULL,
2299                   (is_fallthrough ? &quot;taken always&quot; : &quot;taken never&quot;));
2300     return;
2301   }
2302 
2303   Node* val = c-&gt;in(1);
2304   Node* con = c-&gt;in(2);
2305   const Type* tcon = _gvn.type(con);
2306   const Type* tval = _gvn.type(val);
2307   bool have_con = tcon-&gt;singleton();
2308   if (tval-&gt;singleton()) {
2309     if (!have_con) {
2310       // Swap, so constant is in con.
2311       con  = val;
2312       tcon = tval;
2313       val  = c-&gt;in(2);
2314       tval = _gvn.type(val);
2315       btest = BoolTest(btest).commute();
2316       have_con = true;
2317     } else {
2318       // Do we have two constants?  Then leave well enough alone.
2319       have_con = false;
2320     }
2321   }
2322   if (!have_con) {                        // remaining adjustments need a con
2323     maybe_add_predicate_after_if(path);
2324     return;
2325   }
2326 
2327   sharpen_type_after_if(btest, con, tcon, val, tval);
2328   maybe_add_predicate_after_if(path);
2329 }
2330 
2331 
2332 static Node* extract_obj_from_klass_load(PhaseGVN* gvn, Node* n) {
2333   Node* ldk;
2334   if (n-&gt;is_DecodeNKlass()) {
2335     if (n-&gt;in(1)-&gt;Opcode() != Op_LoadNKlass) {
2336       return NULL;
2337     } else {
2338       ldk = n-&gt;in(1);
2339     }
2340   } else if (n-&gt;Opcode() != Op_LoadKlass) {
2341     return NULL;
2342   } else {
2343     ldk = n;
2344   }
2345   assert(ldk != NULL &amp;&amp; ldk-&gt;is_Load(), &quot;should have found a LoadKlass or LoadNKlass node&quot;);
2346 
2347   Node* adr = ldk-&gt;in(MemNode::Address);
2348   intptr_t off = 0;
2349   Node* obj = AddPNode::Ideal_base_and_offset(adr, gvn, off);
2350   if (obj == NULL || off != oopDesc::klass_offset_in_bytes()) // loading oopDesc::_klass?
2351     return NULL;
2352   const TypePtr* tp = gvn-&gt;type(obj)-&gt;is_ptr();
2353   if (tp == NULL || !(tp-&gt;isa_instptr() || tp-&gt;isa_aryptr())) // is obj a Java object ptr?
2354     return NULL;
2355 
2356   return obj;
2357 }
2358 
2359 void Parse::sharpen_type_after_if(BoolTest::mask btest,
2360                                   Node* con, const Type* tcon,
2361                                   Node* val, const Type* tval) {
2362   // Look for opportunities to sharpen the type of a node
2363   // whose klass is compared with a constant klass.
2364   if (btest == BoolTest::eq &amp;&amp; tcon-&gt;isa_klassptr()) {
2365     Node* obj = extract_obj_from_klass_load(&amp;_gvn, val);
2366     const TypeOopPtr* con_type = tcon-&gt;isa_klassptr()-&gt;as_instance_type();
2367     if (obj != NULL &amp;&amp; (con_type-&gt;isa_instptr() || con_type-&gt;isa_aryptr())) {
2368        // Found:
2369        //   Bool(CmpP(LoadKlass(obj._klass), ConP(Foo.klass)), [eq])
2370        // or the narrowOop equivalent.
2371        const Type* obj_type = _gvn.type(obj);
2372        const TypeOopPtr* tboth = obj_type-&gt;join_speculative(con_type)-&gt;isa_oopptr();
2373        if (tboth != NULL &amp;&amp; tboth-&gt;klass_is_exact() &amp;&amp; tboth != obj_type &amp;&amp;
2374            tboth-&gt;higher_equal(obj_type)) {
2375           // obj has to be of the exact type Foo if the CmpP succeeds.
2376           int obj_in_map = map()-&gt;find_edge(obj);
2377           JVMState* jvms = this-&gt;jvms();
2378           if (obj_in_map &gt;= 0 &amp;&amp;
2379               (jvms-&gt;is_loc(obj_in_map) || jvms-&gt;is_stk(obj_in_map))) {
2380             TypeNode* ccast = new CheckCastPPNode(control(), obj, tboth);
2381             const Type* tcc = ccast-&gt;as_Type()-&gt;type();
2382             assert(tcc != obj_type &amp;&amp; tcc-&gt;higher_equal(obj_type), &quot;must improve&quot;);
2383             // Delay transform() call to allow recovery of pre-cast value
2384             // at the control merge.
2385             _gvn.set_type_bottom(ccast);
2386             record_for_igvn(ccast);
2387             // Here&#39;s the payoff.
2388             replace_in_map(obj, ccast);
2389           }
2390        }
2391     }
2392   }
2393 
2394   int val_in_map = map()-&gt;find_edge(val);
2395   if (val_in_map &lt; 0)  return;          // replace_in_map would be useless
2396   {
2397     JVMState* jvms = this-&gt;jvms();
2398     if (!(jvms-&gt;is_loc(val_in_map) ||
2399           jvms-&gt;is_stk(val_in_map)))
2400       return;                           // again, it would be useless
2401   }
2402 
2403   // Check for a comparison to a constant, and &quot;know&quot; that the compared
2404   // value is constrained on this path.
2405   assert(tcon-&gt;singleton(), &quot;&quot;);
2406   ConstraintCastNode* ccast = NULL;
2407   Node* cast = NULL;
2408 
2409   switch (btest) {
2410   case BoolTest::eq:                    // Constant test?
2411     {
2412       const Type* tboth = tcon-&gt;join_speculative(tval);
2413       if (tboth == tval)  break;        // Nothing to gain.
2414       if (tcon-&gt;isa_int()) {
2415         ccast = new CastIINode(val, tboth);
2416       } else if (tcon == TypePtr::NULL_PTR) {
2417         // Cast to null, but keep the pointer identity temporarily live.
2418         ccast = new CastPPNode(val, tboth);
2419       } else {
2420         const TypeF* tf = tcon-&gt;isa_float_constant();
2421         const TypeD* td = tcon-&gt;isa_double_constant();
2422         // Exclude tests vs float/double 0 as these could be
2423         // either +0 or -0.  Just because you are equal to +0
2424         // doesn&#39;t mean you ARE +0!
2425         // Note, following code also replaces Long and Oop values.
2426         if ((!tf || tf-&gt;_f != 0.0) &amp;&amp;
2427             (!td || td-&gt;_d != 0.0))
2428           cast = con;                   // Replace non-constant val by con.
2429       }
2430     }
2431     break;
2432 
2433   case BoolTest::ne:
2434     if (tcon == TypePtr::NULL_PTR) {
2435       cast = cast_not_null(val, false);
2436     }
2437     break;
2438 
2439   default:
2440     // (At this point we could record int range types with CastII.)
2441     break;
2442   }
2443 
2444   if (ccast != NULL) {
2445     const Type* tcc = ccast-&gt;as_Type()-&gt;type();
2446     assert(tcc != tval &amp;&amp; tcc-&gt;higher_equal(tval), &quot;must improve&quot;);
2447     // Delay transform() call to allow recovery of pre-cast value
2448     // at the control merge.
2449     ccast-&gt;set_req(0, control());
2450     _gvn.set_type_bottom(ccast);
2451     record_for_igvn(ccast);
2452     cast = ccast;
2453   }
2454 
2455   if (cast != NULL) {                   // Here&#39;s the payoff.
2456     replace_in_map(val, cast);
2457   }
2458 }
2459 
2460 /**
2461  * Use speculative type to optimize CmpP node: if comparison is
2462  * against the low level class, cast the object to the speculative
2463  * type if any. CmpP should then go away.
2464  *
2465  * @param c  expected CmpP node
2466  * @return   result of CmpP on object casted to speculative type
2467  *
2468  */
2469 Node* Parse::optimize_cmp_with_klass(Node* c) {
2470   // If this is transformed by the _gvn to a comparison with the low
2471   // level klass then we may be able to use speculation
2472   if (c-&gt;Opcode() == Op_CmpP &amp;&amp;
2473       (c-&gt;in(1)-&gt;Opcode() == Op_LoadKlass || c-&gt;in(1)-&gt;Opcode() == Op_DecodeNKlass) &amp;&amp;
2474       c-&gt;in(2)-&gt;is_Con()) {
2475     Node* load_klass = NULL;
2476     Node* decode = NULL;
2477     if (c-&gt;in(1)-&gt;Opcode() == Op_DecodeNKlass) {
2478       decode = c-&gt;in(1);
2479       load_klass = c-&gt;in(1)-&gt;in(1);
2480     } else {
2481       load_klass = c-&gt;in(1);
2482     }
2483     if (load_klass-&gt;in(2)-&gt;is_AddP()) {
2484       Node* addp = load_klass-&gt;in(2);
2485       Node* obj = addp-&gt;in(AddPNode::Address);
2486       const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();
2487       if (obj_type-&gt;speculative_type_not_null() != NULL) {
2488         ciKlass* k = obj_type-&gt;speculative_type();
2489         inc_sp(2);
2490         obj = maybe_cast_profiled_obj(obj, k);
2491         dec_sp(2);
2492         if (obj-&gt;is_ValueType()) {
2493           assert(obj-&gt;as_ValueType()-&gt;is_allocated(&amp;_gvn), &quot;must be allocated&quot;);
2494           obj = obj-&gt;as_ValueType()-&gt;get_oop();
2495         }
2496         // Make the CmpP use the casted obj
2497         addp = basic_plus_adr(obj, addp-&gt;in(AddPNode::Offset));
2498         load_klass = load_klass-&gt;clone();
2499         load_klass-&gt;set_req(2, addp);
2500         load_klass = _gvn.transform(load_klass);
2501         if (decode != NULL) {
2502           decode = decode-&gt;clone();
2503           decode-&gt;set_req(1, load_klass);
2504           load_klass = _gvn.transform(decode);
2505         }
2506         c = c-&gt;clone();
2507         c-&gt;set_req(1, load_klass);
2508         c = _gvn.transform(c);
2509       }
2510     }
2511   }
2512   return c;
2513 }
2514 
2515 //------------------------------do_one_bytecode--------------------------------
2516 // Parse this bytecode, and alter the Parsers JVM-&gt;Node mapping
2517 void Parse::do_one_bytecode() {
2518   Node *a, *b, *c, *d;          // Handy temps
2519   BoolTest::mask btest;
2520   int i;
2521 
2522   assert(!has_exceptions(), &quot;bytecode entry state must be clear of throws&quot;);
2523 
2524   if (C-&gt;check_node_count(NodeLimitFudgeFactor * 5,
2525                           &quot;out of nodes parsing method&quot;)) {
2526     return;
2527   }
2528 
2529 #ifdef ASSERT
2530   // for setting breakpoints
2531   if (TraceOptoParse) {
2532     tty-&gt;print(&quot; @&quot;);
2533     dump_bci(bci());
2534     tty-&gt;cr();
2535   }
2536 #endif
2537 
2538   switch (bc()) {
2539   case Bytecodes::_nop:
2540     // do nothing
2541     break;
2542   case Bytecodes::_lconst_0:
2543     push_pair(longcon(0));
2544     break;
2545 
2546   case Bytecodes::_lconst_1:
2547     push_pair(longcon(1));
2548     break;
2549 
2550   case Bytecodes::_fconst_0:
2551     push(zerocon(T_FLOAT));
2552     break;
2553 
2554   case Bytecodes::_fconst_1:
2555     push(makecon(TypeF::ONE));
2556     break;
2557 
2558   case Bytecodes::_fconst_2:
2559     push(makecon(TypeF::make(2.0f)));
2560     break;
2561 
2562   case Bytecodes::_dconst_0:
2563     push_pair(zerocon(T_DOUBLE));
2564     break;
2565 
2566   case Bytecodes::_dconst_1:
2567     push_pair(makecon(TypeD::ONE));
2568     break;
2569 
2570   case Bytecodes::_iconst_m1:push(intcon(-1)); break;
2571   case Bytecodes::_iconst_0: push(intcon( 0)); break;
2572   case Bytecodes::_iconst_1: push(intcon( 1)); break;
2573   case Bytecodes::_iconst_2: push(intcon( 2)); break;
2574   case Bytecodes::_iconst_3: push(intcon( 3)); break;
2575   case Bytecodes::_iconst_4: push(intcon( 4)); break;
2576   case Bytecodes::_iconst_5: push(intcon( 5)); break;
2577   case Bytecodes::_bipush:   push(intcon(iter().get_constant_u1())); break;
2578   case Bytecodes::_sipush:   push(intcon(iter().get_constant_u2())); break;
2579   case Bytecodes::_aconst_null: push(null());  break;
2580   case Bytecodes::_ldc:
2581   case Bytecodes::_ldc_w:
2582   case Bytecodes::_ldc2_w:
2583     // If the constant is unresolved, run this BC once in the interpreter.
2584     {
2585       ciConstant constant = iter().get_constant();
2586       if (!constant.is_valid() ||
2587           (constant.basic_type() == T_OBJECT &amp;&amp;
2588            !constant.as_object()-&gt;is_loaded())) {
2589         int index = iter().get_constant_pool_index();
2590         constantTag tag = iter().get_constant_pool_tag(index);
2591         uncommon_trap(Deoptimization::make_trap_request
2592                       (Deoptimization::Reason_unloaded,
2593                        Deoptimization::Action_reinterpret,
2594                        index),
2595                       NULL, tag.internal_name());
2596         break;
2597       }
2598       assert(constant.basic_type() != T_OBJECT || constant.as_object()-&gt;is_instance(),
2599              &quot;must be java_mirror of klass&quot;);
2600       const Type* con_type = Type::make_from_constant(constant);
2601       if (con_type != NULL) {
2602         push_node(con_type-&gt;basic_type(), makecon(con_type));
2603       }
2604     }
2605 
2606     break;
2607 
2608   case Bytecodes::_aload_0:
2609     push( local(0) );
2610     break;
2611   case Bytecodes::_aload_1:
2612     push( local(1) );
2613     break;
2614   case Bytecodes::_aload_2:
2615     push( local(2) );
2616     break;
2617   case Bytecodes::_aload_3:
2618     push( local(3) );
2619     break;
2620   case Bytecodes::_aload:
2621     push( local(iter().get_index()) );
2622     break;
2623 
2624   case Bytecodes::_fload_0:
2625   case Bytecodes::_iload_0:
2626     push( local(0) );
2627     break;
2628   case Bytecodes::_fload_1:
2629   case Bytecodes::_iload_1:
2630     push( local(1) );
2631     break;
2632   case Bytecodes::_fload_2:
2633   case Bytecodes::_iload_2:
2634     push( local(2) );
2635     break;
2636   case Bytecodes::_fload_3:
2637   case Bytecodes::_iload_3:
2638     push( local(3) );
2639     break;
2640   case Bytecodes::_fload:
2641   case Bytecodes::_iload:
2642     push( local(iter().get_index()) );
2643     break;
2644   case Bytecodes::_lload_0:
2645     push_pair_local( 0 );
2646     break;
2647   case Bytecodes::_lload_1:
2648     push_pair_local( 1 );
2649     break;
2650   case Bytecodes::_lload_2:
2651     push_pair_local( 2 );
2652     break;
2653   case Bytecodes::_lload_3:
2654     push_pair_local( 3 );
2655     break;
2656   case Bytecodes::_lload:
2657     push_pair_local( iter().get_index() );
2658     break;
2659 
2660   case Bytecodes::_dload_0:
2661     push_pair_local(0);
2662     break;
2663   case Bytecodes::_dload_1:
2664     push_pair_local(1);
2665     break;
2666   case Bytecodes::_dload_2:
2667     push_pair_local(2);
2668     break;
2669   case Bytecodes::_dload_3:
2670     push_pair_local(3);
2671     break;
2672   case Bytecodes::_dload:
2673     push_pair_local(iter().get_index());
2674     break;
2675   case Bytecodes::_fstore_0:
2676   case Bytecodes::_istore_0:
2677   case Bytecodes::_astore_0:
2678     set_local( 0, pop() );
2679     break;
2680   case Bytecodes::_fstore_1:
2681   case Bytecodes::_istore_1:
2682   case Bytecodes::_astore_1:
2683     set_local( 1, pop() );
2684     break;
2685   case Bytecodes::_fstore_2:
2686   case Bytecodes::_istore_2:
2687   case Bytecodes::_astore_2:
2688     set_local( 2, pop() );
2689     break;
2690   case Bytecodes::_fstore_3:
2691   case Bytecodes::_istore_3:
2692   case Bytecodes::_astore_3:
2693     set_local( 3, pop() );
2694     break;
2695   case Bytecodes::_fstore:
2696   case Bytecodes::_istore:
2697   case Bytecodes::_astore:
2698     set_local( iter().get_index(), pop() );
2699     break;
2700   // long stores
2701   case Bytecodes::_lstore_0:
2702     set_pair_local( 0, pop_pair() );
2703     break;
2704   case Bytecodes::_lstore_1:
2705     set_pair_local( 1, pop_pair() );
2706     break;
2707   case Bytecodes::_lstore_2:
2708     set_pair_local( 2, pop_pair() );
2709     break;
2710   case Bytecodes::_lstore_3:
2711     set_pair_local( 3, pop_pair() );
2712     break;
2713   case Bytecodes::_lstore:
2714     set_pair_local( iter().get_index(), pop_pair() );
2715     break;
2716 
2717   // double stores
2718   case Bytecodes::_dstore_0:
2719     set_pair_local( 0, dstore_rounding(pop_pair()) );
2720     break;
2721   case Bytecodes::_dstore_1:
2722     set_pair_local( 1, dstore_rounding(pop_pair()) );
2723     break;
2724   case Bytecodes::_dstore_2:
2725     set_pair_local( 2, dstore_rounding(pop_pair()) );
2726     break;
2727   case Bytecodes::_dstore_3:
2728     set_pair_local( 3, dstore_rounding(pop_pair()) );
2729     break;
2730   case Bytecodes::_dstore:
2731     set_pair_local( iter().get_index(), dstore_rounding(pop_pair()) );
2732     break;
2733 
2734   case Bytecodes::_pop:  dec_sp(1);   break;
2735   case Bytecodes::_pop2: dec_sp(2);   break;
2736   case Bytecodes::_swap:
2737     a = pop();
2738     b = pop();
2739     push(a);
2740     push(b);
2741     break;
2742   case Bytecodes::_dup:
2743     a = pop();
2744     push(a);
2745     push(a);
2746     break;
2747   case Bytecodes::_dup_x1:
2748     a = pop();
2749     b = pop();
2750     push( a );
2751     push( b );
2752     push( a );
2753     break;
2754   case Bytecodes::_dup_x2:
2755     a = pop();
2756     b = pop();
2757     c = pop();
2758     push( a );
2759     push( c );
2760     push( b );
2761     push( a );
2762     break;
2763   case Bytecodes::_dup2:
2764     a = pop();
2765     b = pop();
2766     push( b );
2767     push( a );
2768     push( b );
2769     push( a );
2770     break;
2771 
2772   case Bytecodes::_dup2_x1:
2773     // before: .. c, b, a
2774     // after:  .. b, a, c, b, a
2775     // not tested
2776     a = pop();
2777     b = pop();
2778     c = pop();
2779     push( b );
2780     push( a );
2781     push( c );
2782     push( b );
2783     push( a );
2784     break;
2785   case Bytecodes::_dup2_x2:
2786     // before: .. d, c, b, a
2787     // after:  .. b, a, d, c, b, a
2788     // not tested
2789     a = pop();
2790     b = pop();
2791     c = pop();
2792     d = pop();
2793     push( b );
2794     push( a );
2795     push( d );
2796     push( c );
2797     push( b );
2798     push( a );
2799     break;
2800 
2801   case Bytecodes::_arraylength: {
2802     // Must do null-check with value on expression stack
2803     Node *ary = null_check(peek(), T_ARRAY);
2804     // Compile-time detect of null-exception?
2805     if (stopped())  return;
2806     a = pop();
2807     push(load_array_length(a));
2808     break;
2809   }
2810 
2811   case Bytecodes::_baload:  array_load(T_BYTE);    break;
2812   case Bytecodes::_caload:  array_load(T_CHAR);    break;
2813   case Bytecodes::_iaload:  array_load(T_INT);     break;
2814   case Bytecodes::_saload:  array_load(T_SHORT);   break;
2815   case Bytecodes::_faload:  array_load(T_FLOAT);   break;
2816   case Bytecodes::_aaload:  array_load(T_OBJECT);  break;
2817   case Bytecodes::_laload:  array_load(T_LONG);    break;
2818   case Bytecodes::_daload:  array_load(T_DOUBLE);  break;
2819   case Bytecodes::_bastore: array_store(T_BYTE);   break;
2820   case Bytecodes::_castore: array_store(T_CHAR);   break;
2821   case Bytecodes::_iastore: array_store(T_INT);    break;
2822   case Bytecodes::_sastore: array_store(T_SHORT);  break;
2823   case Bytecodes::_fastore: array_store(T_FLOAT);  break;
2824   case Bytecodes::_aastore: array_store(T_OBJECT); break;
2825   case Bytecodes::_lastore: array_store(T_LONG);   break;
2826   case Bytecodes::_dastore: array_store(T_DOUBLE); break;
2827 
2828   case Bytecodes::_getfield:
2829     do_getfield();
2830     break;
2831 
2832   case Bytecodes::_getstatic:
2833     do_getstatic();
2834     break;
2835 
2836   case Bytecodes::_putfield:
2837     do_putfield();
2838     break;
2839 
2840   case Bytecodes::_putstatic:
2841     do_putstatic();
2842     break;
2843 
2844   case Bytecodes::_irem:
2845     do_irem();
2846     break;
2847   case Bytecodes::_idiv:
2848     // Must keep both values on the expression-stack during null-check
2849     zero_check_int(peek());
2850     // Compile-time detect of null-exception?
2851     if (stopped())  return;
2852     b = pop();
2853     a = pop();
2854     push( _gvn.transform( new DivINode(control(),a,b) ) );
2855     break;
2856   case Bytecodes::_imul:
2857     b = pop(); a = pop();
2858     push( _gvn.transform( new MulINode(a,b) ) );
2859     break;
2860   case Bytecodes::_iadd:
2861     b = pop(); a = pop();
2862     push( _gvn.transform( new AddINode(a,b) ) );
2863     break;
2864   case Bytecodes::_ineg:
2865     a = pop();
2866     push( _gvn.transform( new SubINode(_gvn.intcon(0),a)) );
2867     break;
2868   case Bytecodes::_isub:
2869     b = pop(); a = pop();
2870     push( _gvn.transform( new SubINode(a,b) ) );
2871     break;
2872   case Bytecodes::_iand:
2873     b = pop(); a = pop();
2874     push( _gvn.transform( new AndINode(a,b) ) );
2875     break;
2876   case Bytecodes::_ior:
2877     b = pop(); a = pop();
2878     push( _gvn.transform( new OrINode(a,b) ) );
2879     break;
2880   case Bytecodes::_ixor:
2881     b = pop(); a = pop();
2882     push( _gvn.transform( new XorINode(a,b) ) );
2883     break;
2884   case Bytecodes::_ishl:
2885     b = pop(); a = pop();
2886     push( _gvn.transform( new LShiftINode(a,b) ) );
2887     break;
2888   case Bytecodes::_ishr:
2889     b = pop(); a = pop();
2890     push( _gvn.transform( new RShiftINode(a,b) ) );
2891     break;
2892   case Bytecodes::_iushr:
2893     b = pop(); a = pop();
2894     push( _gvn.transform( new URShiftINode(a,b) ) );
2895     break;
2896 
2897   case Bytecodes::_fneg:
2898     a = pop();
2899     b = _gvn.transform(new NegFNode (a));
2900     push(b);
2901     break;
2902 
2903   case Bytecodes::_fsub:
2904     b = pop();
2905     a = pop();
2906     c = _gvn.transform( new SubFNode(a,b) );
2907     d = precision_rounding(c);
2908     push( d );
2909     break;
2910 
2911   case Bytecodes::_fadd:
2912     b = pop();
2913     a = pop();
2914     c = _gvn.transform( new AddFNode(a,b) );
2915     d = precision_rounding(c);
2916     push( d );
2917     break;
2918 
2919   case Bytecodes::_fmul:
2920     b = pop();
2921     a = pop();
2922     c = _gvn.transform( new MulFNode(a,b) );
2923     d = precision_rounding(c);
2924     push( d );
2925     break;
2926 
2927   case Bytecodes::_fdiv:
2928     b = pop();
2929     a = pop();
2930     c = _gvn.transform( new DivFNode(0,a,b) );
2931     d = precision_rounding(c);
2932     push( d );
2933     break;
2934 
2935   case Bytecodes::_frem:
2936     if (Matcher::has_match_rule(Op_ModF)) {
2937       // Generate a ModF node.
2938       b = pop();
2939       a = pop();
2940       c = _gvn.transform( new ModFNode(0,a,b) );
2941       d = precision_rounding(c);
2942       push( d );
2943     }
2944     else {
2945       // Generate a call.
2946       modf();
2947     }
2948     break;
2949 
2950   case Bytecodes::_fcmpl:
2951     b = pop();
2952     a = pop();
2953     c = _gvn.transform( new CmpF3Node( a, b));
2954     push(c);
2955     break;
2956   case Bytecodes::_fcmpg:
2957     b = pop();
2958     a = pop();
2959 
2960     // Same as fcmpl but need to flip the unordered case.  Swap the inputs,
2961     // which negates the result sign except for unordered.  Flip the unordered
2962     // as well by using CmpF3 which implements unordered-lesser instead of
2963     // unordered-greater semantics.  Finally, commute the result bits.  Result
2964     // is same as using a CmpF3Greater except we did it with CmpF3 alone.
2965     c = _gvn.transform( new CmpF3Node( b, a));
2966     c = _gvn.transform( new SubINode(_gvn.intcon(0),c) );
2967     push(c);
2968     break;
2969 
2970   case Bytecodes::_f2i:
2971     a = pop();
2972     push(_gvn.transform(new ConvF2INode(a)));
2973     break;
2974 
2975   case Bytecodes::_d2i:
2976     a = pop_pair();
2977     b = _gvn.transform(new ConvD2INode(a));
2978     push( b );
2979     break;
2980 
2981   case Bytecodes::_f2d:
2982     a = pop();
2983     b = _gvn.transform( new ConvF2DNode(a));
2984     push_pair( b );
2985     break;
2986 
2987   case Bytecodes::_d2f:
2988     a = pop_pair();
2989     b = _gvn.transform( new ConvD2FNode(a));
2990     // This breaks _227_mtrt (speed &amp; correctness) and _222_mpegaudio (speed)
2991     //b = _gvn.transform(new RoundFloatNode(0, b) );
2992     push( b );
2993     break;
2994 
2995   case Bytecodes::_l2f:
2996     if (Matcher::convL2FSupported()) {
2997       a = pop_pair();
2998       b = _gvn.transform( new ConvL2FNode(a));
2999       // For i486.ad, FILD doesn&#39;t restrict precision to 24 or 53 bits.
3000       // Rather than storing the result into an FP register then pushing
3001       // out to memory to round, the machine instruction that implements
3002       // ConvL2D is responsible for rounding.
3003       // c = precision_rounding(b);
3004       c = _gvn.transform(b);
3005       push(c);
3006     } else {
3007       l2f();
3008     }
3009     break;
3010 
3011   case Bytecodes::_l2d:
3012     a = pop_pair();
3013     b = _gvn.transform( new ConvL2DNode(a));
3014     // For i486.ad, rounding is always necessary (see _l2f above).
3015     // c = dprecision_rounding(b);
3016     c = _gvn.transform(b);
3017     push_pair(c);
3018     break;
3019 
3020   case Bytecodes::_f2l:
3021     a = pop();
3022     b = _gvn.transform( new ConvF2LNode(a));
3023     push_pair(b);
3024     break;
3025 
3026   case Bytecodes::_d2l:
3027     a = pop_pair();
3028     b = _gvn.transform( new ConvD2LNode(a));
3029     push_pair(b);
3030     break;
3031 
3032   case Bytecodes::_dsub:
3033     b = pop_pair();
3034     a = pop_pair();
3035     c = _gvn.transform( new SubDNode(a,b) );
3036     d = dprecision_rounding(c);
3037     push_pair( d );
3038     break;
3039 
3040   case Bytecodes::_dadd:
3041     b = pop_pair();
3042     a = pop_pair();
3043     c = _gvn.transform( new AddDNode(a,b) );
3044     d = dprecision_rounding(c);
3045     push_pair( d );
3046     break;
3047 
3048   case Bytecodes::_dmul:
3049     b = pop_pair();
3050     a = pop_pair();
3051     c = _gvn.transform( new MulDNode(a,b) );
3052     d = dprecision_rounding(c);
3053     push_pair( d );
3054     break;
3055 
3056   case Bytecodes::_ddiv:
3057     b = pop_pair();
3058     a = pop_pair();
3059     c = _gvn.transform( new DivDNode(0,a,b) );
3060     d = dprecision_rounding(c);
3061     push_pair( d );
3062     break;
3063 
3064   case Bytecodes::_dneg:
3065     a = pop_pair();
3066     b = _gvn.transform(new NegDNode (a));
3067     push_pair(b);
3068     break;
3069 
3070   case Bytecodes::_drem:
3071     if (Matcher::has_match_rule(Op_ModD)) {
3072       // Generate a ModD node.
3073       b = pop_pair();
3074       a = pop_pair();
3075       // a % b
3076 
3077       c = _gvn.transform( new ModDNode(0,a,b) );
3078       d = dprecision_rounding(c);
3079       push_pair( d );
3080     }
3081     else {
3082       // Generate a call.
3083       modd();
3084     }
3085     break;
3086 
3087   case Bytecodes::_dcmpl:
3088     b = pop_pair();
3089     a = pop_pair();
3090     c = _gvn.transform( new CmpD3Node( a, b));
3091     push(c);
3092     break;
3093 
3094   case Bytecodes::_dcmpg:
3095     b = pop_pair();
3096     a = pop_pair();
3097     // Same as dcmpl but need to flip the unordered case.
3098     // Commute the inputs, which negates the result sign except for unordered.
3099     // Flip the unordered as well by using CmpD3 which implements
3100     // unordered-lesser instead of unordered-greater semantics.
3101     // Finally, negate the result bits.  Result is same as using a
3102     // CmpD3Greater except we did it with CmpD3 alone.
3103     c = _gvn.transform( new CmpD3Node( b, a));
3104     c = _gvn.transform( new SubINode(_gvn.intcon(0),c) );
3105     push(c);
3106     break;
3107 
3108 
3109     // Note for longs -&gt; lo word is on TOS, hi word is on TOS - 1
3110   case Bytecodes::_land:
3111     b = pop_pair();
3112     a = pop_pair();
3113     c = _gvn.transform( new AndLNode(a,b) );
3114     push_pair(c);
3115     break;
3116   case Bytecodes::_lor:
3117     b = pop_pair();
3118     a = pop_pair();
3119     c = _gvn.transform( new OrLNode(a,b) );
3120     push_pair(c);
3121     break;
3122   case Bytecodes::_lxor:
3123     b = pop_pair();
3124     a = pop_pair();
3125     c = _gvn.transform( new XorLNode(a,b) );
3126     push_pair(c);
3127     break;
3128 
3129   case Bytecodes::_lshl:
3130     b = pop();                  // the shift count
3131     a = pop_pair();             // value to be shifted
3132     c = _gvn.transform( new LShiftLNode(a,b) );
3133     push_pair(c);
3134     break;
3135   case Bytecodes::_lshr:
3136     b = pop();                  // the shift count
3137     a = pop_pair();             // value to be shifted
3138     c = _gvn.transform( new RShiftLNode(a,b) );
3139     push_pair(c);
3140     break;
3141   case Bytecodes::_lushr:
3142     b = pop();                  // the shift count
3143     a = pop_pair();             // value to be shifted
3144     c = _gvn.transform( new URShiftLNode(a,b) );
3145     push_pair(c);
3146     break;
3147   case Bytecodes::_lmul:
3148     b = pop_pair();
3149     a = pop_pair();
3150     c = _gvn.transform( new MulLNode(a,b) );
3151     push_pair(c);
3152     break;
3153 
3154   case Bytecodes::_lrem:
3155     // Must keep both values on the expression-stack during null-check
3156     assert(peek(0) == top(), &quot;long word order&quot;);
3157     zero_check_long(peek(1));
3158     // Compile-time detect of null-exception?
3159     if (stopped())  return;
3160     b = pop_pair();
3161     a = pop_pair();
3162     c = _gvn.transform( new ModLNode(control(),a,b) );
3163     push_pair(c);
3164     break;
3165 
3166   case Bytecodes::_ldiv:
3167     // Must keep both values on the expression-stack during null-check
3168     assert(peek(0) == top(), &quot;long word order&quot;);
3169     zero_check_long(peek(1));
3170     // Compile-time detect of null-exception?
3171     if (stopped())  return;
3172     b = pop_pair();
3173     a = pop_pair();
3174     c = _gvn.transform( new DivLNode(control(),a,b) );
3175     push_pair(c);
3176     break;
3177 
3178   case Bytecodes::_ladd:
3179     b = pop_pair();
3180     a = pop_pair();
3181     c = _gvn.transform( new AddLNode(a,b) );
3182     push_pair(c);
3183     break;
3184   case Bytecodes::_lsub:
3185     b = pop_pair();
3186     a = pop_pair();
3187     c = _gvn.transform( new SubLNode(a,b) );
3188     push_pair(c);
3189     break;
3190   case Bytecodes::_lcmp:
3191     // Safepoints are now inserted _before_ branches.  The long-compare
3192     // bytecode painfully produces a 3-way value (-1,0,+1) which requires a
3193     // slew of control flow.  These are usually followed by a CmpI vs zero and
3194     // a branch; this pattern then optimizes to the obvious long-compare and
3195     // branch.  However, if the branch is backwards there&#39;s a Safepoint
3196     // inserted.  The inserted Safepoint captures the JVM state at the
3197     // pre-branch point, i.e. it captures the 3-way value.  Thus if a
3198     // long-compare is used to control a loop the debug info will force
3199     // computation of the 3-way value, even though the generated code uses a
3200     // long-compare and branch.  We try to rectify the situation by inserting
3201     // a SafePoint here and have it dominate and kill the safepoint added at a
3202     // following backwards branch.  At this point the JVM state merely holds 2
3203     // longs but not the 3-way value.
3204     if( UseLoopSafepoints ) {
3205       switch( iter().next_bc() ) {
3206       case Bytecodes::_ifgt:
3207       case Bytecodes::_iflt:
3208       case Bytecodes::_ifge:
3209       case Bytecodes::_ifle:
3210       case Bytecodes::_ifne:
3211       case Bytecodes::_ifeq:
3212         // If this is a backwards branch in the bytecodes, add Safepoint
3213         maybe_add_safepoint(iter().next_get_dest());
3214       default:
3215         break;
3216       }
3217     }
3218     b = pop_pair();
3219     a = pop_pair();
3220     c = _gvn.transform( new CmpL3Node( a, b ));
3221     push(c);
3222     break;
3223 
3224   case Bytecodes::_lneg:
3225     a = pop_pair();
3226     b = _gvn.transform( new SubLNode(longcon(0),a));
3227     push_pair(b);
3228     break;
3229   case Bytecodes::_l2i:
3230     a = pop_pair();
3231     push( _gvn.transform( new ConvL2INode(a)));
3232     break;
3233   case Bytecodes::_i2l:
3234     a = pop();
3235     b = _gvn.transform( new ConvI2LNode(a));
3236     push_pair(b);
3237     break;
3238   case Bytecodes::_i2b:
3239     // Sign extend
3240     a = pop();
3241     a = _gvn.transform( new LShiftINode(a,_gvn.intcon(24)) );
3242     a = _gvn.transform( new RShiftINode(a,_gvn.intcon(24)) );
3243     push( a );
3244     break;
3245   case Bytecodes::_i2s:
3246     a = pop();
3247     a = _gvn.transform( new LShiftINode(a,_gvn.intcon(16)) );
3248     a = _gvn.transform( new RShiftINode(a,_gvn.intcon(16)) );
3249     push( a );
3250     break;
3251   case Bytecodes::_i2c:
3252     a = pop();
3253     push( _gvn.transform( new AndINode(a,_gvn.intcon(0xFFFF)) ) );
3254     break;
3255 
3256   case Bytecodes::_i2f:
3257     a = pop();
3258     b = _gvn.transform( new ConvI2FNode(a) ) ;
3259     c = precision_rounding(b);
3260     push (b);
3261     break;
3262 
3263   case Bytecodes::_i2d:
3264     a = pop();
3265     b = _gvn.transform( new ConvI2DNode(a));
3266     push_pair(b);
3267     break;
3268 
3269   case Bytecodes::_iinc:        // Increment local
3270     i = iter().get_index();     // Get local index
3271     set_local( i, _gvn.transform( new AddINode( _gvn.intcon(iter().get_iinc_con()), local(i) ) ) );
3272     break;
3273 
3274   // Exit points of synchronized methods must have an unlock node
3275   case Bytecodes::_return:
3276     return_current(NULL);
3277     break;
3278 
3279   case Bytecodes::_ireturn:
3280   case Bytecodes::_areturn:
3281   case Bytecodes::_freturn:
3282     return_current(pop());
3283     break;
3284   case Bytecodes::_lreturn:
3285     return_current(pop_pair());
3286     break;
3287   case Bytecodes::_dreturn:
3288     return_current(pop_pair());
3289     break;
3290 
3291   case Bytecodes::_athrow:
3292     // null exception oop throws NULL pointer exception
3293     null_check(peek());
3294     if (stopped())  return;
3295     // Hook the thrown exception directly to subsequent handlers.
3296     if (BailoutToInterpreterForThrows) {
3297       // Keep method interpreted from now on.
3298       uncommon_trap(Deoptimization::Reason_unhandled,
3299                     Deoptimization::Action_make_not_compilable);
3300       return;
3301     }
3302     if (env()-&gt;jvmti_can_post_on_exceptions()) {
3303       // check if we must post exception events, take uncommon trap if so (with must_throw = false)
3304       uncommon_trap_if_should_post_on_exceptions(Deoptimization::Reason_unhandled, false);
3305     }
3306     // Here if either can_post_on_exceptions or should_post_on_exceptions is false
3307     add_exception_state(make_exception_state(peek()));
3308     break;
3309 
3310   case Bytecodes::_goto:   // fall through
3311   case Bytecodes::_goto_w: {
3312     int target_bci = (bc() == Bytecodes::_goto) ? iter().get_dest() : iter().get_far_dest();
3313 
3314     // If this is a backwards branch in the bytecodes, add Safepoint
3315     maybe_add_safepoint(target_bci);
3316 
3317     // Update method data
3318     profile_taken_branch(target_bci);
3319 
3320     // Merge the current control into the target basic block
3321     merge(target_bci);
3322 
3323     // See if we can get some profile data and hand it off to the next block
3324     Block *target_block = block()-&gt;successor_for_bci(target_bci);
3325     if (target_block-&gt;pred_count() != 1)  break;
3326     ciMethodData* methodData = method()-&gt;method_data();
3327     if (!methodData-&gt;is_mature())  break;
3328     ciProfileData* data = methodData-&gt;bci_to_data(bci());
3329     assert(data != NULL &amp;&amp; data-&gt;is_JumpData(), &quot;need JumpData for taken branch&quot;);
3330     int taken = ((ciJumpData*)data)-&gt;taken();
3331     taken = method()-&gt;scale_count(taken);
3332     target_block-&gt;set_count(taken);
3333     break;
3334   }
3335 
3336   case Bytecodes::_ifnull:    btest = BoolTest::eq; goto handle_if_null;
3337   case Bytecodes::_ifnonnull: btest = BoolTest::ne; goto handle_if_null;
3338   handle_if_null:
3339     // If this is a backwards branch in the bytecodes, add Safepoint
3340     maybe_add_safepoint(iter().get_dest());
3341     a = null();
3342     b = pop();
3343     if (b-&gt;is_ValueType()) {
3344       // Return constant false because &#39;b&#39; is always non-null
3345       c = _gvn.makecon(TypeInt::CC_GT);
3346     } else {
3347       if (!_gvn.type(b)-&gt;speculative_maybe_null() &amp;&amp;
3348           !too_many_traps(Deoptimization::Reason_speculate_null_check)) {
3349         inc_sp(1);
3350         Node* null_ctl = top();
3351         b = null_check_oop(b, &amp;null_ctl, true, true, true);
3352         assert(null_ctl-&gt;is_top(), &quot;no null control here&quot;);
3353         dec_sp(1);
3354       } else if (_gvn.type(b)-&gt;speculative_always_null() &amp;&amp;
3355                  !too_many_traps(Deoptimization::Reason_speculate_null_assert)) {
3356         inc_sp(1);
3357         b = null_assert(b);
3358         dec_sp(1);
3359       }
3360       c = _gvn.transform( new CmpPNode(b, a) );
3361     }
3362     do_ifnull(btest, c);
3363     break;
3364 
3365   case Bytecodes::_if_acmpeq: btest = BoolTest::eq; goto handle_if_acmp;
3366   case Bytecodes::_if_acmpne: btest = BoolTest::ne; goto handle_if_acmp;
3367   handle_if_acmp:
3368     // If this is a backwards branch in the bytecodes, add Safepoint
3369     maybe_add_safepoint(iter().get_dest());
3370     a = pop();
3371     b = pop();
3372     do_acmp(btest, a, b);
3373     break;
3374 
3375   case Bytecodes::_ifeq: btest = BoolTest::eq; goto handle_ifxx;
3376   case Bytecodes::_ifne: btest = BoolTest::ne; goto handle_ifxx;
3377   case Bytecodes::_iflt: btest = BoolTest::lt; goto handle_ifxx;
3378   case Bytecodes::_ifle: btest = BoolTest::le; goto handle_ifxx;
3379   case Bytecodes::_ifgt: btest = BoolTest::gt; goto handle_ifxx;
3380   case Bytecodes::_ifge: btest = BoolTest::ge; goto handle_ifxx;
3381   handle_ifxx:
3382     // If this is a backwards branch in the bytecodes, add Safepoint
3383     maybe_add_safepoint(iter().get_dest());
3384     a = _gvn.intcon(0);
3385     b = pop();
3386     c = _gvn.transform( new CmpINode(b, a) );
3387     do_if(btest, c);
3388     break;
3389 
3390   case Bytecodes::_if_icmpeq: btest = BoolTest::eq; goto handle_if_icmp;
3391   case Bytecodes::_if_icmpne: btest = BoolTest::ne; goto handle_if_icmp;
3392   case Bytecodes::_if_icmplt: btest = BoolTest::lt; goto handle_if_icmp;
3393   case Bytecodes::_if_icmple: btest = BoolTest::le; goto handle_if_icmp;
3394   case Bytecodes::_if_icmpgt: btest = BoolTest::gt; goto handle_if_icmp;
3395   case Bytecodes::_if_icmpge: btest = BoolTest::ge; goto handle_if_icmp;
3396   handle_if_icmp:
3397     // If this is a backwards branch in the bytecodes, add Safepoint
3398     maybe_add_safepoint(iter().get_dest());
3399     a = pop();
3400     b = pop();
3401     c = _gvn.transform( new CmpINode( b, a ) );
3402     do_if(btest, c);
3403     break;
3404 
3405   case Bytecodes::_tableswitch:
3406     do_tableswitch();
3407     break;
3408 
3409   case Bytecodes::_lookupswitch:
3410     do_lookupswitch();
3411     break;
3412 
3413   case Bytecodes::_invokestatic:
3414   case Bytecodes::_invokedynamic:
3415   case Bytecodes::_invokespecial:
3416   case Bytecodes::_invokevirtual:
3417   case Bytecodes::_invokeinterface:
3418     do_call();
3419     break;
3420   case Bytecodes::_checkcast:
3421     do_checkcast();
3422     break;
3423   case Bytecodes::_instanceof:
3424     do_instanceof();
3425     break;
3426   case Bytecodes::_anewarray:
3427     do_newarray();
3428     break;
3429   case Bytecodes::_newarray:
3430     do_newarray((BasicType)iter().get_index());
3431     break;
3432   case Bytecodes::_multianewarray:
3433     do_multianewarray();
3434     break;
3435   case Bytecodes::_new:
3436     do_new();
3437     break;
3438   case Bytecodes::_defaultvalue:
3439     do_defaultvalue();
3440     break;
3441   case Bytecodes::_withfield:
3442     do_withfield();
3443     break;
3444 
3445   case Bytecodes::_jsr:
3446   case Bytecodes::_jsr_w:
3447     do_jsr();
3448     break;
3449 
3450   case Bytecodes::_ret:
3451     do_ret();
3452     break;
3453 
3454 
3455   case Bytecodes::_monitorenter:
3456     do_monitor_enter();
3457     break;
3458 
3459   case Bytecodes::_monitorexit:
3460     do_monitor_exit();
3461     break;
3462 
3463   case Bytecodes::_breakpoint:
3464     // Breakpoint set concurrently to compile
3465     // %%% use an uncommon trap?
3466     C-&gt;record_failure(&quot;breakpoint in method&quot;);
3467     return;
3468 
3469   default:
3470 #ifndef PRODUCT
3471     map()-&gt;dump(99);
3472 #endif
3473     tty-&gt;print(&quot;\nUnhandled bytecode %s\n&quot;, Bytecodes::name(bc()) );
3474     ShouldNotReachHere();
3475   }
3476 
3477 #ifndef PRODUCT
3478   if (C-&gt;should_print(1)) {
3479     IdealGraphPrinter* printer = C-&gt;printer();
3480     char buffer[256];
3481     jio_snprintf(buffer, sizeof(buffer), &quot;Bytecode %d: %s&quot;, bci(), Bytecodes::name(bc()));
3482     bool old = printer-&gt;traverse_outs();
3483     printer-&gt;set_traverse_outs(true);
3484     printer-&gt;print_method(buffer, 4);
3485     printer-&gt;set_traverse_outs(old);
3486   }
3487 #endif
3488 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
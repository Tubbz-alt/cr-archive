<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jniCheck.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jni.h&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;logging/log.hpp&quot;
  32 #include &quot;logging/logTag.hpp&quot;
  33 #include &quot;memory/allocation.inline.hpp&quot;
  34 #include &quot;memory/guardedMemory.hpp&quot;
  35 #include &quot;oops/instanceKlass.hpp&quot;
  36 #include &quot;oops/oop.inline.hpp&quot;
  37 #include &quot;oops/symbol.hpp&quot;
  38 #include &quot;prims/jniCheck.hpp&quot;
  39 #include &quot;prims/jvm_misc.hpp&quot;
  40 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  41 #include &quot;runtime/handles.inline.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  44 #include &quot;runtime/jniHandles.inline.hpp&quot;
  45 #include &quot;runtime/thread.inline.hpp&quot;
  46 #include &quot;utilities/utf8.hpp&quot;
  47 
  48 // Complain every extra number of unplanned local refs
  49 #define CHECK_JNI_LOCAL_REF_CAP_WARN_THRESHOLD 32
  50 
  51 // Heap objects are allowed to be directly referenced only in VM code,
  52 // not in native code.
  53 
  54 #define ASSERT_OOPS_ALLOWED                                          \
  55     assert(JavaThread::current()-&gt;thread_state() == _thread_in_vm,   \
  56            &quot;jniCheck examining oops in bad state.&quot;)
  57 
  58 
  59 // Execute the given block of source code with the thread in VM state.
  60 // To do this, transition from the NATIVE state to the VM state, execute
  61 // the code, and transtition back.  The ThreadInVMfromNative constructor
  62 // performs the transition to VM state, its destructor restores the
  63 // NATIVE state.
  64 
  65 #define IN_VM(source_code)   {                                         \
  66     {                                                                  \
  67       ThreadInVMfromNative __tiv(thr);                                 \
  68       source_code                                                      \
  69     }                                                                  \
  70   }
  71 
  72 
  73 /*
  74  * DECLARATIONS
  75  */
  76 
  77 static struct JNINativeInterface_ * unchecked_jni_NativeInterface;
  78 
  79 
  80 /*
  81  * MACRO DEFINITIONS
  82  */
  83 
  84 // All JNI checked functions here use JNI_ENTRY_CHECKED() instead of the
  85 // QUICK_ENTRY or LEAF variants found in jni.cpp.  This allows handles
  86 // to be created if a fatal error should occur.
  87 
  88 // Check for thread not attached to VM;  need to catch this before
  89 // assertions in the wrapper routines might fire
  90 
  91 // Check for env being the one value appropriate for this thread.
  92 
  93 #define JNI_ENTRY_CHECKED(result_type, header)                           \
  94 extern &quot;C&quot; {                                                             \
  95   result_type JNICALL header {                                           \
  96     JavaThread* thr = (JavaThread*) Thread::current_or_null();           \
  97     if (thr == NULL || !thr-&gt;is_Java_thread()) {                         \
  98       tty-&gt;print_cr(&quot;%s&quot;, fatal_using_jnienv_in_nonjava);                \
  99       os::abort(true);                                                   \
 100     }                                                                    \
 101     JNIEnv* xenv = thr-&gt;jni_environment();                               \
 102     if (env != xenv) {                                                   \
 103       NativeReportJNIFatalError(thr, warn_wrong_jnienv);                 \
 104     }                                                                    \
 105     VM_ENTRY_BASE(result_type, header, thr)
 106 
 107 
 108 #define UNCHECKED() (unchecked_jni_NativeInterface)
 109 
 110 static const char * warn_wrong_jnienv = &quot;Using JNIEnv in the wrong thread&quot;;
 111 static const char * warn_bad_class_descriptor1 = &quot;JNI FindClass received a bad class descriptor \&quot;&quot;;
 112 static const char * warn_bad_class_descriptor2 = &quot;\&quot;.  A correct class descriptor &quot; \
 113   &quot;has no leading \&quot;L\&quot; or trailing \&quot;;\&quot;.  Incorrect descriptors will not be accepted in future releases.&quot;;
 114 static const char * fatal_using_jnienv_in_nonjava = &quot;FATAL ERROR in native method: Using JNIEnv in non-Java thread&quot;;
 115 static const char * warn_other_function_in_critical = &quot;Warning: Calling other JNI functions in the scope of &quot; \
 116   &quot;Get/ReleasePrimitiveArrayCritical or Get/ReleaseStringCritical&quot;;
 117 static const char * fatal_bad_ref_to_jni = &quot;Bad global or local ref passed to JNI&quot;;
 118 static const char * fatal_received_null_class = &quot;JNI received a null class&quot;;
 119 static const char * fatal_class_not_a_class = &quot;JNI received a class argument that is not a class&quot;;
 120 static const char * fatal_class_not_a_throwable_class = &quot;JNI Throw or ThrowNew received a class argument that is not a Throwable or Throwable subclass&quot;;
 121 static const char * fatal_wrong_class_or_method = &quot;Wrong object class or methodID passed to JNI call&quot;;
 122 static const char * fatal_non_weak_method = &quot;non-weak methodID passed to JNI call&quot;;
 123 static const char * fatal_unknown_array_object = &quot;Unknown array object passed to JNI array operations&quot;;
 124 static const char * fatal_object_array_expected = &quot;Object array expected but not received for JNI array operation&quot;;
 125 static const char * fatal_prim_type_array_expected = &quot;Primitive type array expected but not received for JNI array operation&quot;;
 126 static const char * fatal_non_array  = &quot;Non-array passed to JNI array operations&quot;;
 127 static const char * fatal_element_type_mismatch = &quot;Array element type mismatch in JNI&quot;;
 128 static const char * fatal_should_be_static = &quot;Non-static field ID passed to JNI&quot;;
 129 static const char * fatal_wrong_static_field = &quot;Wrong static field ID passed to JNI&quot;;
 130 static const char * fatal_static_field_not_found = &quot;Static field not found in JNI get/set field operations&quot;;
 131 static const char * fatal_static_field_mismatch = &quot;Field type (static) mismatch in JNI get/set field operations&quot;;
 132 static const char * fatal_should_be_nonstatic = &quot;Static field ID passed to JNI&quot;;
 133 static const char * fatal_null_object = &quot;Null object passed to JNI&quot;;
 134 static const char * fatal_wrong_field = &quot;Wrong field ID passed to JNI&quot;;
 135 static const char * fatal_instance_field_not_found = &quot;Instance field not found in JNI get/set field operations&quot;;
 136 static const char * fatal_instance_field_mismatch = &quot;Field type (instance) mismatch in JNI get/set field operations&quot;;
 137 static const char * fatal_non_string = &quot;JNI string operation received a non-string&quot;;
 138 static const char * fatal_non_utf8_class_name1 = &quot;JNI class name is not a valid UTF8 string \&quot;&quot;;
 139 static const char * fatal_non_utf8_class_name2 = &quot;\&quot;&quot;;
 140 
 141 
 142 // When in VM state:
 143 static void ReportJNIWarning(JavaThread* thr, const char *msg) {
 144   tty-&gt;print_cr(&quot;WARNING in native method: %s&quot;, msg);
 145   thr-&gt;print_stack();
 146 }
 147 
 148 // When in NATIVE state:
 149 static void NativeReportJNIFatalError(JavaThread* thr, const char *msg) {
 150   IN_VM(
 151     ReportJNIFatalError(thr, msg);
 152   )
 153 }
 154 
 155 static void NativeReportJNIWarning(JavaThread* thr, const char *msg) {
 156   IN_VM(
 157     ReportJNIWarning(thr, msg);
 158   )
 159 }
 160 
 161 
 162 
 163 
 164 /*
 165  * SUPPORT FUNCTIONS
 166  */
 167 
 168 /**
 169  * Check whether or not a programmer has actually checked for exceptions. According
 170  * to the JNI Specification (&quot;jni/spec/design.html#java_exceptions&quot;):
 171  *
 172  * There are two cases where the programmer needs to check for exceptions without
 173  * being able to first check an error code:
 174  *
 175  * - The JNI functions that invoke a Java method return the result of the Java method.
 176  * The programmer must call ExceptionOccurred() to check for possible exceptions
 177  * that occurred during the execution of the Java method.
 178  *
 179  * - Some of the JNI array access functions do not return an error code, but may
 180  * throw an ArrayIndexOutOfBoundsException or ArrayStoreException.
 181  *
 182  * In all other cases, a non-error return value guarantees that no exceptions have been thrown.
 183  *
 184  * Programmers often defend against ArrayIndexOutOfBoundsException, so warning
 185  * for these functions would be pedantic.
 186  */
 187 static inline void
 188 check_pending_exception(JavaThread* thr) {
 189   if (thr-&gt;has_pending_exception()) {
 190     NativeReportJNIWarning(thr, &quot;JNI call made with exception pending&quot;);
 191   }
 192   if (thr-&gt;is_pending_jni_exception_check()) {
 193     IN_VM(
 194       tty-&gt;print_cr(&quot;WARNING in native method: JNI call made without checking exceptions when required to from %s&quot;,
 195         thr-&gt;get_pending_jni_exception_check());
 196       thr-&gt;print_stack();
 197     )
 198     thr-&gt;clear_pending_jni_exception_check(); // Just complain once
 199   }
 200 }
 201 
 202 /**
 203  * Add to the planned number of handles. I.e. plus current live &amp; warning threshold
 204  */
 205 static inline void
 206 add_planned_handle_capacity(JNIHandleBlock* handles, size_t capacity) {
 207   handles-&gt;set_planned_capacity(capacity +
 208                                 handles-&gt;get_number_of_live_handles() +
 209                                 CHECK_JNI_LOCAL_REF_CAP_WARN_THRESHOLD);
 210 }
 211 
 212 
 213 static inline void
 214 functionEnterCritical(JavaThread* thr)
 215 {
 216   check_pending_exception(thr);
 217 }
 218 
 219 static inline void
 220 functionEnterCriticalExceptionAllowed(JavaThread* thr)
 221 {
 222 }
 223 
 224 static inline void
 225 functionEnter(JavaThread* thr)
 226 {
 227   if (thr-&gt;in_critical()) {
 228     tty-&gt;print_cr(&quot;%s&quot;, warn_other_function_in_critical);
 229   }
 230   check_pending_exception(thr);
 231 }
 232 
 233 static inline void
 234 functionEnterExceptionAllowed(JavaThread* thr)
 235 {
 236   if (thr-&gt;in_critical()) {
 237     tty-&gt;print_cr(&quot;%s&quot;, warn_other_function_in_critical);
 238   }
 239 }
 240 
 241 static inline void
 242 functionExit(JavaThread* thr)
 243 {
 244   JNIHandleBlock* handles = thr-&gt;active_handles();
 245   size_t planned_capacity = handles-&gt;get_planned_capacity();
 246   size_t live_handles = handles-&gt;get_number_of_live_handles();
 247   if (live_handles &gt; planned_capacity) {
 248     IN_VM(
 249       tty-&gt;print_cr(&quot;WARNING: JNI local refs: &quot; SIZE_FORMAT &quot;, exceeds capacity: &quot; SIZE_FORMAT,
 250                     live_handles, planned_capacity);
 251       thr-&gt;print_stack();
 252     )
 253     // Complain just the once, reset to current + warn threshold
 254     add_planned_handle_capacity(handles, 0);
 255   }
 256 }
 257 
 258 static inline void
 259 checkStaticFieldID(JavaThread* thr, jfieldID fid, jclass cls, int ftype)
 260 {
 261   fieldDescriptor fd;
 262 
 263   /* make sure it is a static field */
 264   if (!jfieldIDWorkaround::is_static_jfieldID(fid))
 265     ReportJNIFatalError(thr, fatal_should_be_static);
 266 
 267   /* validate the class being passed */
 268   ASSERT_OOPS_ALLOWED;
 269   Klass* k_oop = jniCheck::validate_class(thr, cls, false);
 270 
 271   /* check for proper subclass hierarchy */
 272   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fid);
 273   Klass* f_oop = id-&gt;holder();
 274   if (!k_oop-&gt;is_subtype_of(f_oop))
 275     ReportJNIFatalError(thr, fatal_wrong_static_field);
 276 
 277   /* check for proper field type */
 278   if (!id-&gt;find_local_field(&amp;fd))
 279     ReportJNIFatalError(thr, fatal_static_field_not_found);
 280   if ((fd.field_type() != ftype) &amp;&amp;
 281       !(fd.field_type() == T_ARRAY &amp;&amp; ftype == T_OBJECT) &amp;&amp;
 282       !(fd.field_type() == T_INLINE_TYPE &amp;&amp; ftype == T_OBJECT)) {
 283     ReportJNIFatalError(thr, fatal_static_field_mismatch);
 284   }
 285 }
 286 
 287 static inline void
 288 checkInstanceFieldID(JavaThread* thr, jfieldID fid, jobject obj, int ftype)
 289 {
 290   fieldDescriptor fd;
 291 
 292   /* make sure it is an instance field */
 293   if (jfieldIDWorkaround::is_static_jfieldID(fid))
 294     ReportJNIFatalError(thr, fatal_should_be_nonstatic);
 295 
 296   /* validate the object being passed and then get its class */
 297   ASSERT_OOPS_ALLOWED;
 298   oop oopObj = jniCheck::validate_object(thr, obj);
 299   if (oopObj == NULL) {
 300     ReportJNIFatalError(thr, fatal_null_object);
 301   }
 302   Klass* k_oop = oopObj-&gt;klass();
 303 
 304   if (!jfieldIDWorkaround::is_valid_jfieldID(k_oop, fid)) {
 305     ReportJNIFatalError(thr, fatal_wrong_field);
 306   }
 307 
 308   /* make sure the field exists */
 309   int offset = jfieldIDWorkaround::from_instance_jfieldID(k_oop, fid);
 310   if (!InstanceKlass::cast(k_oop)-&gt;contains_field_offset(offset))
 311     ReportJNIFatalError(thr, fatal_wrong_field);
 312 
 313   /* check for proper field type */
 314   if (!InstanceKlass::cast(k_oop)-&gt;find_field_from_offset(offset,
 315                                                               false, &amp;fd))
 316     ReportJNIFatalError(thr, fatal_instance_field_not_found);
 317 
 318   if ((fd.field_type() != ftype) &amp;&amp;
 319       !(fd.field_type() == T_ARRAY &amp;&amp; ftype == T_OBJECT) &amp;&amp;
 320       !(fd.field_type() == T_INLINE_TYPE &amp;&amp; ftype == T_OBJECT)) {
 321     ReportJNIFatalError(thr, fatal_instance_field_mismatch);
 322   }
 323 }
 324 
 325 static inline void
 326 checkString(JavaThread* thr, jstring js)
 327 {
 328   ASSERT_OOPS_ALLOWED;
 329   oop s = jniCheck::validate_object(thr, js);
 330   if ((s == NULL) || !java_lang_String::is_instance(s))
 331     ReportJNIFatalError(thr, fatal_non_string);
 332 }
 333 
 334 static inline arrayOop
 335 check_is_array(JavaThread* thr, jarray jArray)
 336 {
 337   ASSERT_OOPS_ALLOWED;
 338   arrayOop aOop;
 339 
 340   aOop = (arrayOop)jniCheck::validate_object(thr, jArray);
 341   if (aOop == NULL || !aOop-&gt;is_array()) {
 342     ReportJNIFatalError(thr, fatal_non_array);
 343   }
 344   return aOop;
 345 }
 346 
 347 static inline arrayOop
 348 check_is_primitive_array(JavaThread* thr, jarray jArray) {
 349   arrayOop aOop = check_is_array(thr, jArray);
 350 
 351   if (!aOop-&gt;is_typeArray()) {
 352      ReportJNIFatalError(thr, fatal_prim_type_array_expected);
 353   }
 354   return aOop;
 355 }
 356 
 357 static inline void
 358 check_primitive_array_type(JavaThread* thr, jarray jArray, BasicType elementType)
 359 {
 360   BasicType array_type;
 361   arrayOop aOop;
 362 
 363   aOop = check_is_primitive_array(thr, jArray);
 364   array_type = TypeArrayKlass::cast(aOop-&gt;klass())-&gt;element_type();
 365   if (array_type != elementType) {
 366     ReportJNIFatalError(thr, fatal_element_type_mismatch);
 367   }
 368 }
 369 
 370 static inline void
 371 check_is_obj_or_inline_array(JavaThread* thr, jarray jArray) {
 372   arrayOop aOop = check_is_array(thr, jArray);
<a name="1" id="anc1"></a><span class="line-modified"> 373   if (!aOop-&gt;is_objArray() &amp;&amp; !aOop-&gt;is_valueArray()) {</span>
 374     ReportJNIFatalError(thr, fatal_object_array_expected);
 375   }
 376 }
 377 
 378 /*
 379  * Copy and wrap array elements for bounds checking.
 380  * Remember the original elements (GuardedMemory::get_tag())
 381  */
 382 static void* check_jni_wrap_copy_array(JavaThread* thr, jarray array,
 383     void* orig_elements) {
 384   void* result;
 385   IN_VM(
 386     oop a = JNIHandles::resolve_non_null(array);
 387     size_t len = arrayOop(a)-&gt;length() &lt;&lt;
 388         TypeArrayKlass::cast(a-&gt;klass())-&gt;log2_element_size();
 389     result = GuardedMemory::wrap_copy(orig_elements, len, orig_elements);
 390   )
 391   return result;
 392 }
 393 
 394 static void* check_wrapped_array(JavaThread* thr, const char* fn_name,
 395     void* obj, void* carray, size_t* rsz) {
 396   if (carray == NULL) {
 397     tty-&gt;print_cr(&quot;%s: elements vector NULL&quot; PTR_FORMAT, fn_name, p2i(obj));
 398     NativeReportJNIFatalError(thr, &quot;Elements vector NULL&quot;);
 399   }
 400   GuardedMemory guarded(carray);
 401   void* orig_result = guarded.get_tag();
 402   if (!guarded.verify_guards()) {
 403     tty-&gt;print_cr(&quot;ReleasePrimitiveArrayCritical: release array failed bounds &quot;
 404         &quot;check, incorrect pointer returned ? array: &quot; PTR_FORMAT &quot; carray: &quot;
 405         PTR_FORMAT, p2i(obj), p2i(carray));
 406     guarded.print_on(tty);
 407     NativeReportJNIFatalError(thr, &quot;ReleasePrimitiveArrayCritical: &quot;
 408         &quot;failed bounds check&quot;);
 409   }
 410   if (orig_result == NULL) {
 411     tty-&gt;print_cr(&quot;ReleasePrimitiveArrayCritical: unrecognized elements. array: &quot;
 412         PTR_FORMAT &quot; carray: &quot; PTR_FORMAT, p2i(obj), p2i(carray));
 413     guarded.print_on(tty);
 414     NativeReportJNIFatalError(thr, &quot;ReleasePrimitiveArrayCritical: &quot;
 415         &quot;unrecognized elements&quot;);
 416   }
 417   if (rsz != NULL) {
 418     *rsz = guarded.get_user_size();
 419   }
 420   return orig_result;
 421 }
 422 
 423 static void* check_wrapped_array_release(JavaThread* thr, const char* fn_name,
 424     void* obj, void* carray, jint mode) {
 425   size_t sz;
 426   void* orig_result = check_wrapped_array(thr, fn_name, obj, carray, &amp;sz);
 427   switch (mode) {
 428   // As we never make copies, mode 0 and JNI_COMMIT are the same.
 429   case 0:
 430   case JNI_COMMIT:
 431     memcpy(orig_result, carray, sz);
 432     break;
 433   case JNI_ABORT:
 434     break;
 435   default:
 436     tty-&gt;print_cr(&quot;%s: Unrecognized mode %i releasing array &quot;
 437         PTR_FORMAT &quot; elements &quot; PTR_FORMAT, fn_name, mode, p2i(obj), p2i(carray));
 438     NativeReportJNIFatalError(thr, &quot;Unrecognized array release mode&quot;);
 439   }
 440   // We always need to release the copy we made with GuardedMemory
 441   GuardedMemory::free_copy(carray);
 442   return orig_result;
 443 }
 444 
 445 oop jniCheck::validate_handle(JavaThread* thr, jobject obj) {
 446   if ((obj != NULL) &amp;&amp; (JNIHandles::handle_type(thr, obj) != JNIInvalidRefType)) {
 447     ASSERT_OOPS_ALLOWED;
 448     return JNIHandles::resolve_external_guard(obj);
 449   }
 450   ReportJNIFatalError(thr, fatal_bad_ref_to_jni);
 451   return NULL;
 452 }
 453 
 454 
 455 Method* jniCheck::validate_jmethod_id(JavaThread* thr, jmethodID method_id) {
 456   ASSERT_OOPS_ALLOWED;
 457   // do the fast jmethodID check first
 458   Method* m = Method::checked_resolve_jmethod_id(method_id);
 459   if (m == NULL) {
 460     ReportJNIFatalError(thr, fatal_wrong_class_or_method);
 461   }
 462   // jmethodIDs are handles in the class loader data,
 463   // but that can be expensive so check it last
 464   else if (!Method::is_method_id(method_id)) {
 465     ReportJNIFatalError(thr, fatal_non_weak_method);
 466   }
 467   return m;
 468 }
 469 
 470 
 471 oop jniCheck::validate_object(JavaThread* thr, jobject obj) {
 472   if (obj == NULL) return NULL;
 473   ASSERT_OOPS_ALLOWED;
 474   oop oopObj = jniCheck::validate_handle(thr, obj);
 475   if (oopObj == NULL) {
 476     ReportJNIFatalError(thr, fatal_bad_ref_to_jni);
 477   }
 478   return oopObj;
 479 }
 480 
 481 // Warn if a class descriptor is in decorated form; class descriptors
 482 // passed to JNI findClass should not be decorated unless they are
 483 // array descriptors.
 484 void jniCheck::validate_class_descriptor(JavaThread* thr, const char* name) {
 485   if (name == NULL) return;  // implementation accepts NULL so just return
 486 
 487   size_t len = strlen(name);
 488 
 489   if (len &gt;= 2 &amp;&amp;
 490       (name[0] == JVM_SIGNATURE_CLASS || name[0] == JVM_SIGNATURE_INLINE_TYPE) &amp;&amp; // &#39;L&#39; or &#39;Q&#39;
 491       name[len-1] == JVM_SIGNATURE_ENDCLASS ) {    // &#39;;&#39;
 492     char msg[JVM_MAXPATHLEN];
 493     jio_snprintf(msg, JVM_MAXPATHLEN, &quot;%s%s%s&quot;,
 494                  warn_bad_class_descriptor1, name, warn_bad_class_descriptor2);
 495     ReportJNIWarning(thr, msg);
 496   }
 497 
 498   // Verify that the class name given is a valid utf8 string
 499   if (!UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false)) {
 500     char msg[JVM_MAXPATHLEN];
 501     jio_snprintf(msg, JVM_MAXPATHLEN, &quot;%s%s%s&quot;, fatal_non_utf8_class_name1, name, fatal_non_utf8_class_name2);
 502     ReportJNIFatalError(thr, msg);
 503   }
 504 }
 505 
 506 Klass* jniCheck::validate_class(JavaThread* thr, jclass clazz, bool allow_primitive) {
 507   ASSERT_OOPS_ALLOWED;
 508   oop mirror = jniCheck::validate_handle(thr, clazz);
 509   if (mirror == NULL) {
 510     ReportJNIFatalError(thr, fatal_received_null_class);
 511   }
 512 
 513   if (mirror-&gt;klass() != SystemDictionary::Class_klass()) {
 514     ReportJNIFatalError(thr, fatal_class_not_a_class);
 515   }
 516 
 517   Klass* k = java_lang_Class::as_Klass(mirror);
 518   // Make allowances for primitive classes ...
 519   if (!(k != NULL || (allow_primitive &amp;&amp; java_lang_Class::is_primitive(mirror)))) {
 520     ReportJNIFatalError(thr, fatal_class_not_a_class);
 521   }
 522   return k;
 523 }
 524 
 525 void jniCheck::validate_throwable_klass(JavaThread* thr, Klass* klass) {
 526   ASSERT_OOPS_ALLOWED;
 527   assert(klass != NULL, &quot;klass argument must have a value&quot;);
 528 
 529   if (!klass-&gt;is_instance_klass() ||
 530       !klass-&gt;is_subclass_of(SystemDictionary::Throwable_klass())) {
 531     ReportJNIFatalError(thr, fatal_class_not_a_throwable_class);
 532   }
 533 }
 534 
 535 void jniCheck::validate_call(JavaThread* thr, jclass clazz, jmethodID method_id, jobject obj) {
 536   ASSERT_OOPS_ALLOWED;
 537   Method* m = jniCheck::validate_jmethod_id(thr, method_id);
 538   InstanceKlass* holder = m-&gt;method_holder();
 539 
 540   if (clazz != NULL) {
 541     Klass* k = jniCheck::validate_class(thr, clazz, false);
 542     // Check that method is in the class, must be InstanceKlass
 543     if (!InstanceKlass::cast(k)-&gt;is_subtype_of(holder)) {
 544       ReportJNIFatalError(thr, fatal_wrong_class_or_method);
 545     }
 546   }
 547 
 548   if (obj != NULL) {
 549     oop recv = jniCheck::validate_object(thr, obj);
 550     assert(recv != NULL, &quot;validate_object checks that&quot;);
 551     Klass* rk = recv-&gt;klass();
 552 
 553     // Check that the object is a subtype of method holder too.
 554     if (!rk-&gt;is_subtype_of(holder)) {
 555       ReportJNIFatalError(thr, fatal_wrong_class_or_method);
 556     }
 557   }
 558 }
 559 
 560 
 561 /*
 562  * IMPLEMENTATION OF FUNCTIONS IN CHECKED TABLE
 563  */
 564 
 565 JNI_ENTRY_CHECKED(jclass,
 566   checked_jni_DefineClass(JNIEnv *env,
 567                           const char *name,
 568                           jobject loader,
 569                           const jbyte *buf,
 570                           jsize len))
 571     functionEnter(thr);
 572     IN_VM(
 573       jniCheck::validate_object(thr, loader);
 574     )
 575     jclass result = UNCHECKED()-&gt;DefineClass(env, name, loader, buf, len);
 576     functionExit(thr);
 577     return result;
 578 JNI_END
 579 
 580 JNI_ENTRY_CHECKED(jclass,
 581   checked_jni_FindClass(JNIEnv *env,
 582                         const char *name))
 583     functionEnter(thr);
 584     IN_VM(
 585       jniCheck::validate_class_descriptor(thr, name);
 586     )
 587     jclass result = UNCHECKED()-&gt;FindClass(env, name);
 588     functionExit(thr);
 589     return result;
 590 JNI_END
 591 
 592 JNI_ENTRY_CHECKED(jmethodID,
 593   checked_jni_FromReflectedMethod(JNIEnv *env,
 594                                   jobject method))
 595     functionEnter(thr);
 596     IN_VM(
 597       jniCheck::validate_object(thr, method);
 598     )
 599     jmethodID result = UNCHECKED()-&gt;FromReflectedMethod(env, method);
 600     functionExit(thr);
 601     return result;
 602 JNI_END
 603 
 604 JNI_ENTRY_CHECKED(jfieldID,
 605   checked_jni_FromReflectedField(JNIEnv *env,
 606                                  jobject field))
 607     functionEnter(thr);
 608     IN_VM(
 609       jniCheck::validate_object(thr, field);
 610     )
 611     jfieldID result = UNCHECKED()-&gt;FromReflectedField(env, field);
 612     functionExit(thr);
 613     return result;
 614 JNI_END
 615 
 616 JNI_ENTRY_CHECKED(jobject,
 617   checked_jni_ToReflectedMethod(JNIEnv *env,
 618                                 jclass cls,
 619                                 jmethodID methodID,
 620                                 jboolean isStatic))
 621     functionEnter(thr);
 622     IN_VM(
 623       jniCheck::validate_call(thr, cls, methodID);
 624     )
 625     jobject result = UNCHECKED()-&gt;ToReflectedMethod(env, cls, methodID,
 626                                                     isStatic);
 627     functionExit(thr);
 628     return result;
 629 JNI_END
 630 
 631 JNI_ENTRY_CHECKED(jclass,
 632   checked_jni_GetSuperclass(JNIEnv *env,
 633                             jclass sub))
 634     functionEnter(thr);
 635     IN_VM(
 636       jniCheck::validate_class(thr, sub, true);
 637     )
 638     jclass result = UNCHECKED()-&gt;GetSuperclass(env, sub);
 639     functionExit(thr);
 640     return result;
 641 JNI_END
 642 
 643 JNI_ENTRY_CHECKED(jboolean,
 644   checked_jni_IsAssignableFrom(JNIEnv *env,
 645                                jclass sub,
 646                                jclass sup))
 647     functionEnter(thr);
 648     IN_VM(
 649       jniCheck::validate_class(thr, sub, true);
 650       jniCheck::validate_class(thr, sup, true);
 651     )
 652     jboolean result = UNCHECKED()-&gt;IsAssignableFrom(env, sub, sup);
 653     functionExit(thr);
 654     return result;
 655 JNI_END
 656 
 657 JNI_ENTRY_CHECKED(jobject,
 658   checked_jni_ToReflectedField(JNIEnv *env,
 659                                jclass cls,
 660                                jfieldID fieldID,
 661                                jboolean isStatic))
 662     functionEnter(thr);
 663     IN_VM(
 664       jniCheck::validate_class(thr, cls, false);
 665     )
 666     jobject result = UNCHECKED()-&gt;ToReflectedField(env, cls, fieldID,
 667                                                    isStatic);
 668     functionExit(thr);
 669     return result;
 670 JNI_END
 671 
 672 JNI_ENTRY_CHECKED(jint,
 673   checked_jni_Throw(JNIEnv *env,
 674                     jthrowable obj))
 675     functionEnter(thr);
 676     IN_VM(
 677       oop oopObj = jniCheck::validate_object(thr, obj);
 678       if (oopObj == NULL) {
 679         // Unchecked Throw tolerates a NULL obj, so just warn
 680         ReportJNIWarning(thr, &quot;JNI Throw called with NULL throwable&quot;);
 681       } else {
 682         jniCheck::validate_throwable_klass(thr, oopObj-&gt;klass());
 683       }
 684     )
 685     jint result = UNCHECKED()-&gt;Throw(env, obj);
 686     functionExit(thr);
 687     return result;
 688 JNI_END
 689 
 690 JNI_ENTRY_CHECKED(jint,
 691   checked_jni_ThrowNew(JNIEnv *env,
 692                        jclass clazz,
 693                        const char *msg))
 694     functionEnter(thr);
 695     IN_VM(
 696       Klass* k = jniCheck::validate_class(thr, clazz, false);
 697       assert(k != NULL, &quot;validate_class shouldn&#39;t return NULL Klass*&quot;);
 698       jniCheck::validate_throwable_klass(thr, k);
 699     )
 700     jint result = UNCHECKED()-&gt;ThrowNew(env, clazz, msg);
 701     functionExit(thr);
 702     return result;
 703 JNI_END
 704 
 705 JNI_ENTRY_CHECKED(jthrowable,
 706   checked_jni_ExceptionOccurred(JNIEnv *env))
 707     thr-&gt;clear_pending_jni_exception_check();
 708     functionEnterExceptionAllowed(thr);
 709     jthrowable result = UNCHECKED()-&gt;ExceptionOccurred(env);
 710     functionExit(thr);
 711     return result;
 712 JNI_END
 713 
 714 JNI_ENTRY_CHECKED(void,
 715   checked_jni_ExceptionDescribe(JNIEnv *env))
 716     functionEnterExceptionAllowed(thr);
 717     UNCHECKED()-&gt;ExceptionDescribe(env);
 718     functionExit(thr);
 719 JNI_END
 720 
 721 JNI_ENTRY_CHECKED(void,
 722   checked_jni_ExceptionClear(JNIEnv *env))
 723     thr-&gt;clear_pending_jni_exception_check();
 724     functionEnterExceptionAllowed(thr);
 725     UNCHECKED()-&gt;ExceptionClear(env);
 726     functionExit(thr);
 727 JNI_END
 728 
 729 JNI_ENTRY_CHECKED(void,
 730   checked_jni_FatalError(JNIEnv *env,
 731                          const char *msg))
 732     thr-&gt;clear_pending_jni_exception_check();
 733     functionEnter(thr);
 734     UNCHECKED()-&gt;FatalError(env, msg);
 735     functionExit(thr);
 736 JNI_END
 737 
 738 JNI_ENTRY_CHECKED(jint,
 739   checked_jni_PushLocalFrame(JNIEnv *env,
 740                              jint capacity))
 741     functionEnterExceptionAllowed(thr);
 742     if (capacity &lt; 0)
 743       NativeReportJNIFatalError(thr, &quot;negative capacity&quot;);
 744     jint result = UNCHECKED()-&gt;PushLocalFrame(env, capacity);
 745     if (result == JNI_OK) {
 746       add_planned_handle_capacity(thr-&gt;active_handles(), capacity);
 747     }
 748     functionExit(thr);
 749     return result;
 750 JNI_END
 751 
 752 JNI_ENTRY_CHECKED(jobject,
 753   checked_jni_PopLocalFrame(JNIEnv *env,
 754                             jobject result))
 755     functionEnterExceptionAllowed(thr);
 756     jobject res = UNCHECKED()-&gt;PopLocalFrame(env, result);
 757     functionExit(thr);
 758     return res;
 759 JNI_END
 760 
 761 JNI_ENTRY_CHECKED(jobject,
 762   checked_jni_NewGlobalRef(JNIEnv *env,
 763                            jobject lobj))
 764     functionEnter(thr);
 765     IN_VM(
 766       if (lobj != NULL) {
 767         jniCheck::validate_handle(thr, lobj);
 768       }
 769     )
 770     jobject result = UNCHECKED()-&gt;NewGlobalRef(env,lobj);
 771     functionExit(thr);
 772     return result;
 773 JNI_END
 774 
 775 JNI_ENTRY_CHECKED(void,
 776   checked_jni_DeleteGlobalRef(JNIEnv *env,
 777                               jobject gref))
 778     functionEnterExceptionAllowed(thr);
 779     IN_VM(
 780       jniCheck::validate_object(thr, gref);
 781       if (gref &amp;&amp; !JNIHandles::is_global_handle(gref)) {
 782         ReportJNIFatalError(thr,
 783             &quot;Invalid global JNI handle passed to DeleteGlobalRef&quot;);
 784       }
 785     )
 786     UNCHECKED()-&gt;DeleteGlobalRef(env,gref);
 787     functionExit(thr);
 788 JNI_END
 789 
 790 JNI_ENTRY_CHECKED(void,
 791   checked_jni_DeleteLocalRef(JNIEnv *env,
 792                              jobject obj))
 793     functionEnterExceptionAllowed(thr);
 794     IN_VM(
 795       jniCheck::validate_object(thr, obj);
 796       if (obj &amp;&amp; !(JNIHandles::is_local_handle(thr, obj) ||
 797                    JNIHandles::is_frame_handle(thr, obj)))
 798         ReportJNIFatalError(thr,
 799             &quot;Invalid local JNI handle passed to DeleteLocalRef&quot;);
 800     )
 801     UNCHECKED()-&gt;DeleteLocalRef(env, obj);
 802     functionExit(thr);
 803 JNI_END
 804 
 805 JNI_ENTRY_CHECKED(jboolean,
 806   checked_jni_IsSameObject(JNIEnv *env,
 807                            jobject obj1,
 808                            jobject obj2))
 809     functionEnterExceptionAllowed(thr);
 810     IN_VM(
 811       /* This JNI function can be used to compare weak global references
 812        * to NULL objects. If the handles are valid, but contain NULL,
 813        * then don&#39;t attempt to validate the object.
 814        */
 815       if (obj1 != NULL &amp;&amp; jniCheck::validate_handle(thr, obj1) != NULL) {
 816         jniCheck::validate_object(thr, obj1);
 817       }
 818       if (obj2 != NULL &amp;&amp; jniCheck::validate_handle(thr, obj2) != NULL) {
 819         jniCheck::validate_object(thr, obj2);
 820       }
 821     )
 822     jboolean result = UNCHECKED()-&gt;IsSameObject(env,obj1,obj2);
 823     functionExit(thr);
 824     return result;
 825 JNI_END
 826 
 827 JNI_ENTRY_CHECKED(jobject,
 828   checked_jni_NewLocalRef(JNIEnv *env,
 829                           jobject ref))
 830     functionEnter(thr);
 831     IN_VM(
 832       if (ref != NULL) {
 833         jniCheck::validate_handle(thr, ref);
 834       }
 835     )
 836     jobject result = UNCHECKED()-&gt;NewLocalRef(env, ref);
 837     functionExit(thr);
 838     return result;
 839 JNI_END
 840 
 841 JNI_ENTRY_CHECKED(jint,
 842   checked_jni_EnsureLocalCapacity(JNIEnv *env,
 843                                   jint capacity))
 844     functionEnter(thr);
 845     if (capacity &lt; 0) {
 846       NativeReportJNIFatalError(thr, &quot;negative capacity&quot;);
 847     }
 848     jint result = UNCHECKED()-&gt;EnsureLocalCapacity(env, capacity);
 849     if (result == JNI_OK) {
 850       // increase local ref capacity if needed
 851       if ((size_t)capacity &gt; thr-&gt;active_handles()-&gt;get_planned_capacity()) {
 852         add_planned_handle_capacity(thr-&gt;active_handles(), capacity);
 853       }
 854     }
 855     functionExit(thr);
 856     return result;
 857 JNI_END
 858 
 859 JNI_ENTRY_CHECKED(jobject,
 860   checked_jni_AllocObject(JNIEnv *env,
 861                           jclass clazz))
 862     functionEnter(thr);
 863     IN_VM(
 864       jniCheck::validate_class(thr, clazz, false);
 865     )
 866     jobject result = UNCHECKED()-&gt;AllocObject(env,clazz);
 867     functionExit(thr);
 868     return result;
 869 JNI_END
 870 
 871 JNI_ENTRY_CHECKED(jobject,
 872   checked_jni_NewObject(JNIEnv *env,
 873                         jclass clazz,
 874                         jmethodID methodID,
 875                         ...))
 876     functionEnter(thr);
 877     va_list args;
 878     IN_VM(
 879       jniCheck::validate_call(thr, clazz, methodID);
 880     )
 881     va_start(args, methodID);
 882     jobject result = UNCHECKED()-&gt;NewObjectV(env,clazz,methodID,args);
 883     va_end(args);
 884     functionExit(thr);
 885     return result;
 886 JNI_END
 887 
 888 JNI_ENTRY_CHECKED(jobject,
 889   checked_jni_NewObjectV(JNIEnv *env,
 890                          jclass clazz,
 891                          jmethodID methodID,
 892                          va_list args))
 893     functionEnter(thr);
 894     IN_VM(
 895       jniCheck::validate_call(thr, clazz, methodID);
 896     )
 897     jobject result = UNCHECKED()-&gt;NewObjectV(env,clazz,methodID,args);
 898     functionExit(thr);
 899     return result;
 900 JNI_END
 901 
 902 JNI_ENTRY_CHECKED(jobject,
 903   checked_jni_NewObjectA(JNIEnv *env,
 904                          jclass clazz,
 905                          jmethodID methodID,
 906                          const jvalue *args))
 907     functionEnter(thr);
 908     IN_VM(
 909       jniCheck::validate_call(thr, clazz, methodID);
 910     )
 911     jobject result = UNCHECKED()-&gt;NewObjectA(env,clazz,methodID,args);
 912     functionExit(thr);
 913     return result;
 914 JNI_END
 915 
 916 JNI_ENTRY_CHECKED(jclass,
 917   checked_jni_GetObjectClass(JNIEnv *env,
 918                              jobject obj))
 919     functionEnter(thr);
 920     IN_VM(
 921       jniCheck::validate_object(thr, obj);
 922     )
 923     jclass result = UNCHECKED()-&gt;GetObjectClass(env,obj);
 924     functionExit(thr);
 925     return result;
 926 JNI_END
 927 
 928 JNI_ENTRY_CHECKED(jboolean,
 929   checked_jni_IsInstanceOf(JNIEnv *env,
 930                            jobject obj,
 931                            jclass clazz))
 932     functionEnter(thr);
 933     IN_VM(
 934       jniCheck::validate_object(thr, obj);
 935       jniCheck::validate_class(thr, clazz, true);
 936     )
 937     jboolean result = UNCHECKED()-&gt;IsInstanceOf(env,obj,clazz);
 938     functionExit(thr);
 939     return result;
 940 JNI_END
 941 
 942 JNI_ENTRY_CHECKED(jmethodID,
 943   checked_jni_GetMethodID(JNIEnv *env,
 944                           jclass clazz,
 945                           const char *name,
 946                           const char *sig))
 947     functionEnter(thr);
 948     IN_VM(
 949       jniCheck::validate_class(thr, clazz, false);
 950     )
 951     jmethodID result = UNCHECKED()-&gt;GetMethodID(env,clazz,name,sig);
 952     functionExit(thr);
 953     return result;
 954 JNI_END
 955 
 956 #define WRAPPER_CallMethod(ResultType, Result) \
 957 JNI_ENTRY_CHECKED(ResultType,  \
 958   checked_jni_Call##Result##Method(JNIEnv *env, \
 959                                    jobject obj, \
 960                                    jmethodID methodID, \
 961                                    ...)) \
 962     functionEnter(thr); \
 963     va_list args; \
 964     IN_VM( \
 965       jniCheck::validate_call(thr, NULL, methodID, obj); \
 966     ) \
 967     va_start(args,methodID); \
 968     ResultType result =UNCHECKED()-&gt;Call##Result##MethodV(env, obj, methodID, \
 969                                                           args); \
 970     va_end(args); \
 971     thr-&gt;set_pending_jni_exception_check(&quot;Call&quot;#Result&quot;Method&quot;); \
 972     functionExit(thr); \
 973     return result; \
 974 JNI_END \
 975 \
 976 JNI_ENTRY_CHECKED(ResultType,  \
 977   checked_jni_Call##Result##MethodV(JNIEnv *env, \
 978                                     jobject obj, \
 979                                     jmethodID methodID, \
 980                                     va_list args)) \
 981     functionEnter(thr); \
 982     IN_VM(\
 983       jniCheck::validate_call(thr, NULL, methodID, obj); \
 984     ) \
 985     ResultType result = UNCHECKED()-&gt;Call##Result##MethodV(env, obj, methodID,\
 986                                                            args); \
 987     thr-&gt;set_pending_jni_exception_check(&quot;Call&quot;#Result&quot;MethodV&quot;); \
 988     functionExit(thr); \
 989     return result; \
 990 JNI_END \
 991 \
 992 JNI_ENTRY_CHECKED(ResultType,  \
 993   checked_jni_Call##Result##MethodA(JNIEnv *env, \
 994                                     jobject obj, \
 995                                     jmethodID methodID, \
 996                                     const jvalue * args)) \
 997     functionEnter(thr); \
 998     IN_VM( \
 999       jniCheck::validate_call(thr, NULL, methodID, obj); \
1000     ) \
1001     ResultType result = UNCHECKED()-&gt;Call##Result##MethodA(env, obj, methodID,\
1002                                                            args); \
1003     thr-&gt;set_pending_jni_exception_check(&quot;Call&quot;#Result&quot;MethodA&quot;); \
1004     functionExit(thr); \
1005     return result; \
1006 JNI_END
1007 
1008 WRAPPER_CallMethod(jobject,Object)
1009 WRAPPER_CallMethod(jboolean,Boolean)
1010 WRAPPER_CallMethod(jbyte,Byte)
1011 WRAPPER_CallMethod(jshort,Short)
1012 WRAPPER_CallMethod(jchar,Char)
1013 WRAPPER_CallMethod(jint,Int)
1014 WRAPPER_CallMethod(jlong,Long)
1015 WRAPPER_CallMethod(jfloat,Float)
1016 WRAPPER_CallMethod(jdouble,Double)
1017 
1018 JNI_ENTRY_CHECKED(void,
1019   checked_jni_CallVoidMethod(JNIEnv *env, \
1020                              jobject obj, \
1021                              jmethodID methodID, \
1022                              ...))
1023     functionEnter(thr);
1024     va_list args;
1025     IN_VM(
1026       jniCheck::validate_call(thr, NULL, methodID, obj);
1027     )
1028     va_start(args,methodID);
1029     UNCHECKED()-&gt;CallVoidMethodV(env,obj,methodID,args);
1030     va_end(args);
1031     thr-&gt;set_pending_jni_exception_check(&quot;CallVoidMethod&quot;);
1032     functionExit(thr);
1033 JNI_END
1034 
1035 JNI_ENTRY_CHECKED(void,
1036   checked_jni_CallVoidMethodV(JNIEnv *env,
1037                               jobject obj,
1038                               jmethodID methodID,
1039                               va_list args))
1040     functionEnter(thr);
1041     IN_VM(
1042       jniCheck::validate_call(thr, NULL, methodID, obj);
1043     )
1044     UNCHECKED()-&gt;CallVoidMethodV(env,obj,methodID,args);
1045     thr-&gt;set_pending_jni_exception_check(&quot;CallVoidMethodV&quot;);
1046     functionExit(thr);
1047 JNI_END
1048 
1049 JNI_ENTRY_CHECKED(void,
1050   checked_jni_CallVoidMethodA(JNIEnv *env,
1051                               jobject obj,
1052                               jmethodID methodID,
1053                               const jvalue * args))
1054     functionEnter(thr);
1055     IN_VM(
1056       jniCheck::validate_call(thr, NULL, methodID, obj);
1057     )
1058     UNCHECKED()-&gt;CallVoidMethodA(env,obj,methodID,args);
1059     thr-&gt;set_pending_jni_exception_check(&quot;CallVoidMethodA&quot;);
1060     functionExit(thr);
1061 JNI_END
1062 
1063 #define WRAPPER_CallNonvirtualMethod(ResultType, Result) \
1064 JNI_ENTRY_CHECKED(ResultType,  \
1065   checked_jni_CallNonvirtual##Result##Method(JNIEnv *env, \
1066                                              jobject obj, \
1067                                              jclass clazz, \
1068                                              jmethodID methodID, \
1069                                              ...)) \
1070     functionEnter(thr); \
1071     va_list args; \
1072     IN_VM( \
1073       jniCheck::validate_call(thr, clazz, methodID, obj); \
1074     ) \
1075     va_start(args,methodID); \
1076     ResultType result = UNCHECKED()-&gt;CallNonvirtual##Result##MethodV(env, \
1077                                                                      obj, \
1078                                                                      clazz, \
1079                                                                      methodID,\
1080                                                                      args); \
1081     va_end(args); \
1082     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtual&quot;#Result&quot;Method&quot;); \
1083     functionExit(thr); \
1084     return result; \
1085 JNI_END \
1086 \
1087 JNI_ENTRY_CHECKED(ResultType,  \
1088   checked_jni_CallNonvirtual##Result##MethodV(JNIEnv *env, \
1089                                               jobject obj, \
1090                                               jclass clazz, \
1091                                               jmethodID methodID, \
1092                                               va_list args)) \
1093     functionEnter(thr); \
1094     IN_VM( \
1095       jniCheck::validate_call(thr, clazz, methodID, obj); \
1096     ) \
1097     ResultType result = UNCHECKED()-&gt;CallNonvirtual##Result##MethodV(env, \
1098                                                                      obj, \
1099                                                                      clazz, \
1100                                                                      methodID,\
1101                                                                      args); \
1102     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtual&quot;#Result&quot;MethodV&quot;); \
1103     functionExit(thr); \
1104     return result; \
1105 JNI_END \
1106 \
1107 JNI_ENTRY_CHECKED(ResultType,  \
1108   checked_jni_CallNonvirtual##Result##MethodA(JNIEnv *env, \
1109                                               jobject obj, \
1110                                               jclass clazz, \
1111                                               jmethodID methodID, \
1112                                               const jvalue * args)) \
1113     functionEnter(thr); \
1114     IN_VM( \
1115       jniCheck::validate_call(thr, clazz, methodID, obj); \
1116     ) \
1117     ResultType result = UNCHECKED()-&gt;CallNonvirtual##Result##MethodA(env, \
1118                                                                      obj, \
1119                                                                      clazz, \
1120                                                                      methodID,\
1121                                                                      args); \
1122     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtual&quot;#Result&quot;MethodA&quot;); \
1123     functionExit(thr); \
1124     return result; \
1125 JNI_END
1126 
1127 WRAPPER_CallNonvirtualMethod(jobject,Object)
1128 WRAPPER_CallNonvirtualMethod(jboolean,Boolean)
1129 WRAPPER_CallNonvirtualMethod(jbyte,Byte)
1130 WRAPPER_CallNonvirtualMethod(jshort,Short)
1131 WRAPPER_CallNonvirtualMethod(jchar,Char)
1132 WRAPPER_CallNonvirtualMethod(jint,Int)
1133 WRAPPER_CallNonvirtualMethod(jlong,Long)
1134 WRAPPER_CallNonvirtualMethod(jfloat,Float)
1135 WRAPPER_CallNonvirtualMethod(jdouble,Double)
1136 
1137 JNI_ENTRY_CHECKED(void,
1138   checked_jni_CallNonvirtualVoidMethod(JNIEnv *env,
1139                                        jobject obj,
1140                                        jclass clazz,
1141                                        jmethodID methodID,
1142                                        ...))
1143     functionEnter(thr);
1144     va_list args;
1145     IN_VM(
1146       jniCheck::validate_call(thr, clazz, methodID, obj);
1147     )
1148     va_start(args,methodID);
1149     UNCHECKED()-&gt;CallNonvirtualVoidMethodV(env,obj,clazz,methodID,args);
1150     va_end(args);
1151     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtualVoidMethod&quot;);
1152     functionExit(thr);
1153 JNI_END
1154 
1155 JNI_ENTRY_CHECKED(void,
1156   checked_jni_CallNonvirtualVoidMethodV(JNIEnv *env,
1157                                         jobject obj,
1158                                         jclass clazz,
1159                                         jmethodID methodID,
1160                                         va_list args))
1161     functionEnter(thr);
1162     IN_VM(
1163       jniCheck::validate_call(thr, clazz, methodID, obj);
1164     )
1165     UNCHECKED()-&gt;CallNonvirtualVoidMethodV(env,obj,clazz,methodID,args);
1166     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtualVoidMethodV&quot;);
1167     functionExit(thr);
1168 JNI_END
1169 
1170 JNI_ENTRY_CHECKED(void,
1171   checked_jni_CallNonvirtualVoidMethodA(JNIEnv *env,
1172                                         jobject obj,
1173                                         jclass clazz,
1174                                         jmethodID methodID,
1175                                         const jvalue * args))
1176     functionEnter(thr);
1177     IN_VM(
1178       jniCheck::validate_call(thr, clazz, methodID, obj);
1179     )
1180     UNCHECKED()-&gt;CallNonvirtualVoidMethodA(env,obj,clazz,methodID,args);
1181     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtualVoidMethodA&quot;);
1182     functionExit(thr);
1183 JNI_END
1184 
1185 JNI_ENTRY_CHECKED(jfieldID,
1186   checked_jni_GetFieldID(JNIEnv *env,
1187                          jclass clazz,
1188                          const char *name,
1189                          const char *sig))
1190     functionEnter(thr);
1191     IN_VM(
1192       jniCheck::validate_class(thr, clazz, false);
1193     )
1194     jfieldID result = UNCHECKED()-&gt;GetFieldID(env,clazz,name,sig);
1195     functionExit(thr);
1196     return result;
1197 JNI_END
1198 
1199 #define WRAPPER_GetField(ReturnType,Result,FieldType) \
1200 JNI_ENTRY_CHECKED(ReturnType,  \
1201   checked_jni_Get##Result##Field(JNIEnv *env, \
1202                                  jobject obj, \
1203                                  jfieldID fieldID)) \
1204     functionEnter(thr); \
1205     IN_VM( \
1206       checkInstanceFieldID(thr, fieldID, obj, FieldType); \
1207     ) \
1208     ReturnType result = UNCHECKED()-&gt;Get##Result##Field(env,obj,fieldID); \
1209     functionExit(thr); \
1210     return result; \
1211 JNI_END
1212 
1213 WRAPPER_GetField(jobject,  Object,  T_OBJECT)
1214 WRAPPER_GetField(jboolean, Boolean, T_BOOLEAN)
1215 WRAPPER_GetField(jbyte,    Byte,    T_BYTE)
1216 WRAPPER_GetField(jshort,   Short,   T_SHORT)
1217 WRAPPER_GetField(jchar,    Char,    T_CHAR)
1218 WRAPPER_GetField(jint,     Int,     T_INT)
1219 WRAPPER_GetField(jlong,    Long,    T_LONG)
1220 WRAPPER_GetField(jfloat,   Float,   T_FLOAT)
1221 WRAPPER_GetField(jdouble,  Double,  T_DOUBLE)
1222 
1223 #define WRAPPER_SetField(ValueType,Result,FieldType) \
1224 JNI_ENTRY_CHECKED(void,  \
1225   checked_jni_Set##Result##Field(JNIEnv *env, \
1226                                  jobject obj, \
1227                                  jfieldID fieldID, \
1228                                  ValueType val)) \
1229     functionEnter(thr); \
1230     IN_VM( \
1231       checkInstanceFieldID(thr, fieldID, obj, FieldType); \
1232     ) \
1233     UNCHECKED()-&gt;Set##Result##Field(env,obj,fieldID,val); \
1234     functionExit(thr); \
1235 JNI_END
1236 
1237 WRAPPER_SetField(jobject,  Object,  T_OBJECT)
1238 WRAPPER_SetField(jboolean, Boolean, T_BOOLEAN)
1239 WRAPPER_SetField(jbyte,    Byte,    T_BYTE)
1240 WRAPPER_SetField(jshort,   Short,   T_SHORT)
1241 WRAPPER_SetField(jchar,    Char,    T_CHAR)
1242 WRAPPER_SetField(jint,     Int,     T_INT)
1243 WRAPPER_SetField(jlong,    Long,    T_LONG)
1244 WRAPPER_SetField(jfloat,   Float,   T_FLOAT)
1245 WRAPPER_SetField(jdouble,  Double,  T_DOUBLE)
1246 
1247 
1248 JNI_ENTRY_CHECKED(jmethodID,
1249   checked_jni_GetStaticMethodID(JNIEnv *env,
1250                                 jclass clazz,
1251                                 const char *name,
1252                                 const char *sig))
1253     functionEnter(thr);
1254     IN_VM(
1255       jniCheck::validate_class(thr, clazz, false);
1256     )
1257     jmethodID result = UNCHECKED()-&gt;GetStaticMethodID(env,clazz,name,sig);
1258     functionExit(thr);
1259     return result;
1260 JNI_END
1261 
1262 #define WRAPPER_CallStaticMethod(ReturnType,Result) \
1263 JNI_ENTRY_CHECKED(ReturnType,  \
1264   checked_jni_CallStatic##Result##Method(JNIEnv *env, \
1265                                          jclass clazz, \
1266                                          jmethodID methodID, \
1267                                          ...)) \
1268     functionEnter(thr); \
1269     va_list args; \
1270     IN_VM( \
1271       jniCheck::validate_call(thr, clazz, methodID); \
1272     ) \
1273     va_start(args,methodID); \
1274     ReturnType result = UNCHECKED()-&gt;CallStatic##Result##MethodV(env, \
1275                                                                  clazz, \
1276                                                                  methodID, \
1277                                                                  args); \
1278     va_end(args); \
1279     thr-&gt;set_pending_jni_exception_check(&quot;CallStatic&quot;#Result&quot;Method&quot;); \
1280     functionExit(thr); \
1281     return result; \
1282 JNI_END \
1283 \
1284 JNI_ENTRY_CHECKED(ReturnType,  \
1285   checked_jni_CallStatic##Result##MethodV(JNIEnv *env, \
1286                                           jclass clazz, \
1287                                           jmethodID methodID,\
1288                                           va_list args)) \
1289     functionEnter(thr); \
1290     IN_VM( \
1291       jniCheck::validate_call(thr, clazz, methodID); \
1292     ) \
1293     ReturnType result = UNCHECKED()-&gt;CallStatic##Result##MethodV(env, \
1294                                                                  clazz, \
1295                                                                  methodID, \
1296                                                                  args); \
1297     thr-&gt;set_pending_jni_exception_check(&quot;CallStatic&quot;#Result&quot;MethodV&quot;); \
1298     functionExit(thr); \
1299     return result; \
1300 JNI_END \
1301 \
1302 JNI_ENTRY_CHECKED(ReturnType,  \
1303   checked_jni_CallStatic##Result##MethodA(JNIEnv *env, \
1304                                           jclass clazz, \
1305                                           jmethodID methodID, \
1306                                           const jvalue *args)) \
1307     functionEnter(thr); \
1308     IN_VM( \
1309       jniCheck::validate_call(thr, clazz, methodID); \
1310     ) \
1311     ReturnType result = UNCHECKED()-&gt;CallStatic##Result##MethodA(env, \
1312                                                                  clazz, \
1313                                                                  methodID, \
1314                                                                  args); \
1315     thr-&gt;set_pending_jni_exception_check(&quot;CallStatic&quot;#Result&quot;MethodA&quot;); \
1316     functionExit(thr); \
1317     return result; \
1318 JNI_END
1319 
1320 WRAPPER_CallStaticMethod(jobject,Object)
1321 WRAPPER_CallStaticMethod(jboolean,Boolean)
1322 WRAPPER_CallStaticMethod(jbyte,Byte)
1323 WRAPPER_CallStaticMethod(jshort,Short)
1324 WRAPPER_CallStaticMethod(jchar,Char)
1325 WRAPPER_CallStaticMethod(jint,Int)
1326 WRAPPER_CallStaticMethod(jlong,Long)
1327 WRAPPER_CallStaticMethod(jfloat,Float)
1328 WRAPPER_CallStaticMethod(jdouble,Double)
1329 
1330 JNI_ENTRY_CHECKED(void,
1331   checked_jni_CallStaticVoidMethod(JNIEnv *env,
1332                                    jclass cls,
1333                                    jmethodID methodID,
1334                                    ...))
1335     functionEnter(thr);
1336     va_list args;
1337     IN_VM(
1338       jniCheck::validate_call(thr, cls, methodID);
1339     )
1340     va_start(args,methodID);
1341     UNCHECKED()-&gt;CallStaticVoidMethodV(env,cls,methodID,args);
1342     va_end(args);
1343     thr-&gt;set_pending_jni_exception_check(&quot;CallStaticVoidMethod&quot;);
1344     functionExit(thr);
1345 JNI_END
1346 
1347 JNI_ENTRY_CHECKED(void,
1348   checked_jni_CallStaticVoidMethodV(JNIEnv *env,
1349                                     jclass cls,
1350                                     jmethodID methodID,
1351                                     va_list args))
1352     functionEnter(thr);
1353     IN_VM(
1354       jniCheck::validate_call(thr, cls, methodID);
1355     )
1356     UNCHECKED()-&gt;CallStaticVoidMethodV(env,cls,methodID,args);
1357     thr-&gt;set_pending_jni_exception_check(&quot;CallStaticVoidMethodV&quot;);
1358     functionExit(thr);
1359 JNI_END
1360 
1361 JNI_ENTRY_CHECKED(void,
1362   checked_jni_CallStaticVoidMethodA(JNIEnv *env,
1363                                     jclass cls,
1364                                     jmethodID methodID,
1365                                     const jvalue * args))
1366     functionEnter(thr);
1367     IN_VM(
1368       jniCheck::validate_call(thr, cls, methodID);
1369     )
1370     UNCHECKED()-&gt;CallStaticVoidMethodA(env,cls,methodID,args);
1371     thr-&gt;set_pending_jni_exception_check(&quot;CallStaticVoidMethodA&quot;);
1372     functionExit(thr);
1373 JNI_END
1374 
1375 JNI_ENTRY_CHECKED(jfieldID,
1376   checked_jni_GetStaticFieldID(JNIEnv *env,
1377                                jclass clazz,
1378                                const char *name,
1379                                const char *sig))
1380     functionEnter(thr);
1381     IN_VM(
1382       jniCheck::validate_class(thr, clazz, false);
1383     )
1384     jfieldID result = UNCHECKED()-&gt;GetStaticFieldID(env,clazz,name,sig);
1385     functionExit(thr);
1386     return result;
1387 JNI_END
1388 
1389 #define WRAPPER_GetStaticField(ReturnType,Result,FieldType) \
1390 JNI_ENTRY_CHECKED(ReturnType,  \
1391   checked_jni_GetStatic##Result##Field(JNIEnv *env, \
1392                                        jclass clazz, \
1393                                        jfieldID fieldID)) \
1394     functionEnter(thr); \
1395     IN_VM( \
1396       jniCheck::validate_class(thr, clazz, false); \
1397       checkStaticFieldID(thr, fieldID, clazz, FieldType); \
1398     ) \
1399     ReturnType result = UNCHECKED()-&gt;GetStatic##Result##Field(env, \
1400                                                               clazz, \
1401                                                               fieldID); \
1402     functionExit(thr); \
1403     return result; \
1404 JNI_END
1405 
1406 WRAPPER_GetStaticField(jobject,  Object,  T_OBJECT)
1407 WRAPPER_GetStaticField(jboolean, Boolean, T_BOOLEAN)
1408 WRAPPER_GetStaticField(jbyte,    Byte,    T_BYTE)
1409 WRAPPER_GetStaticField(jshort,   Short,   T_SHORT)
1410 WRAPPER_GetStaticField(jchar,    Char,    T_CHAR)
1411 WRAPPER_GetStaticField(jint,     Int,     T_INT)
1412 WRAPPER_GetStaticField(jlong,    Long,    T_LONG)
1413 WRAPPER_GetStaticField(jfloat,   Float,   T_FLOAT)
1414 WRAPPER_GetStaticField(jdouble,  Double,  T_DOUBLE)
1415 
1416 #define WRAPPER_SetStaticField(ValueType,Result,FieldType) \
1417 JNI_ENTRY_CHECKED(void,  \
1418   checked_jni_SetStatic##Result##Field(JNIEnv *env, \
1419                                        jclass clazz, \
1420                                        jfieldID fieldID, \
1421                                        ValueType value)) \
1422     functionEnter(thr); \
1423     IN_VM( \
1424       jniCheck::validate_class(thr, clazz, false); \
1425       checkStaticFieldID(thr, fieldID, clazz, FieldType); \
1426     ) \
1427     UNCHECKED()-&gt;SetStatic##Result##Field(env,clazz,fieldID,value); \
1428     functionExit(thr); \
1429 JNI_END
1430 
1431 WRAPPER_SetStaticField(jobject,  Object,  T_OBJECT)
1432 WRAPPER_SetStaticField(jboolean, Boolean, T_BOOLEAN)
1433 WRAPPER_SetStaticField(jbyte,    Byte,    T_BYTE)
1434 WRAPPER_SetStaticField(jshort,   Short,   T_SHORT)
1435 WRAPPER_SetStaticField(jchar,    Char,    T_CHAR)
1436 WRAPPER_SetStaticField(jint,     Int,     T_INT)
1437 WRAPPER_SetStaticField(jlong,    Long,    T_LONG)
1438 WRAPPER_SetStaticField(jfloat,   Float,   T_FLOAT)
1439 WRAPPER_SetStaticField(jdouble,  Double,  T_DOUBLE)
1440 
1441 
1442 JNI_ENTRY_CHECKED(jstring,
1443   checked_jni_NewString(JNIEnv *env,
1444                         const jchar *unicode,
1445                         jsize len))
1446     functionEnter(thr);
1447     jstring result = UNCHECKED()-&gt;NewString(env,unicode,len);
1448     functionExit(thr);
1449     return result;
1450 JNI_END
1451 
1452 JNI_ENTRY_CHECKED(jsize,
1453   checked_jni_GetStringLength(JNIEnv *env,
1454                               jstring str))
1455     functionEnter(thr);
1456     IN_VM(
1457       checkString(thr, str);
1458     )
1459     jsize result = UNCHECKED()-&gt;GetStringLength(env,str);
1460     functionExit(thr);
1461     return result;
1462 JNI_END
1463 
1464 // Arbitrary (but well-known) tag
1465 const void* STRING_TAG = (void*)0x47114711;
1466 
1467 JNI_ENTRY_CHECKED(const jchar *,
1468   checked_jni_GetStringChars(JNIEnv *env,
1469                              jstring str,
1470                              jboolean *isCopy))
1471     functionEnter(thr);
1472     IN_VM(
1473       checkString(thr, str);
1474     )
1475     jchar* new_result = NULL;
1476     const jchar *result = UNCHECKED()-&gt;GetStringChars(env,str,isCopy);
1477     assert (isCopy == NULL || *isCopy == JNI_TRUE, &quot;GetStringChars didn&#39;t return a copy as expected&quot;);
1478     if (result != NULL) {
1479       size_t len = UNCHECKED()-&gt;GetStringLength(env,str) + 1; // + 1 for NULL termination
1480       len *= sizeof(jchar);
1481       new_result = (jchar*) GuardedMemory::wrap_copy(result, len, STRING_TAG);
1482       if (new_result == NULL) {
1483         vm_exit_out_of_memory(len, OOM_MALLOC_ERROR, &quot;checked_jni_GetStringChars&quot;);
1484       }
1485       // Avoiding call to UNCHECKED()-&gt;ReleaseStringChars() since that will fire unexpected dtrace probes
1486       // Note that the dtrace arguments for the allocated memory will not match up with this solution.
1487       FreeHeap((char*)result);
1488     }
1489     functionExit(thr);
1490     return new_result;
1491 JNI_END
1492 
1493 JNI_ENTRY_CHECKED(void,
1494   checked_jni_ReleaseStringChars(JNIEnv *env,
1495                                  jstring str,
1496                                  const jchar *chars))
1497     functionEnterExceptionAllowed(thr);
1498     IN_VM(
1499       checkString(thr, str);
1500     )
1501     if (chars == NULL) {
1502        // still do the unchecked call to allow dtrace probes
1503        UNCHECKED()-&gt;ReleaseStringChars(env,str,chars);
1504     }
1505     else {
1506       GuardedMemory guarded((void*)chars);
1507       if (!guarded.verify_guards()) {
1508         tty-&gt;print_cr(&quot;ReleaseStringChars: release chars failed bounds check. &quot;
1509             &quot;string: &quot; PTR_FORMAT &quot; chars: &quot; PTR_FORMAT, p2i(str), p2i(chars));
1510         guarded.print_on(tty);
1511         NativeReportJNIFatalError(thr, &quot;ReleaseStringChars: &quot;
1512             &quot;release chars failed bounds check.&quot;);
1513       }
1514       if (guarded.get_tag() != STRING_TAG) {
1515         tty-&gt;print_cr(&quot;ReleaseStringChars: called on something not allocated &quot;
1516             &quot;by GetStringChars. string: &quot; PTR_FORMAT &quot; chars: &quot; PTR_FORMAT,
1517             p2i(str), p2i(chars));
1518         NativeReportJNIFatalError(thr, &quot;ReleaseStringChars called on something &quot;
1519             &quot;not allocated by GetStringChars&quot;);
1520       }
1521        UNCHECKED()-&gt;ReleaseStringChars(env, str,
1522            (const jchar*) guarded.release_for_freeing());
1523     }
1524     functionExit(thr);
1525 JNI_END
1526 
1527 JNI_ENTRY_CHECKED(jstring,
1528   checked_jni_NewStringUTF(JNIEnv *env,
1529                            const char *utf))
1530     functionEnter(thr);
1531     jstring result = UNCHECKED()-&gt;NewStringUTF(env,utf);
1532     functionExit(thr);
1533     return result;
1534 JNI_END
1535 
1536 JNI_ENTRY_CHECKED(jsize,
1537   checked_jni_GetStringUTFLength(JNIEnv *env,
1538                                  jstring str))
1539     functionEnter(thr);
1540     IN_VM(
1541       checkString(thr, str);
1542     )
1543     jsize result = UNCHECKED()-&gt;GetStringUTFLength(env,str);
1544     functionExit(thr);
1545     return result;
1546 JNI_END
1547 
1548 // Arbitrary (but well-known) tag - different than GetStringChars
1549 const void* STRING_UTF_TAG = (void*) 0x48124812;
1550 
1551 JNI_ENTRY_CHECKED(const char *,
1552   checked_jni_GetStringUTFChars(JNIEnv *env,
1553                                 jstring str,
1554                                 jboolean *isCopy))
1555     functionEnter(thr);
1556     IN_VM(
1557       checkString(thr, str);
1558     )
1559     char* new_result = NULL;
1560     const char *result = UNCHECKED()-&gt;GetStringUTFChars(env,str,isCopy);
1561     assert (isCopy == NULL || *isCopy == JNI_TRUE, &quot;GetStringUTFChars didn&#39;t return a copy as expected&quot;);
1562     if (result != NULL) {
1563       size_t len = strlen(result) + 1; // + 1 for NULL termination
1564       new_result = (char*) GuardedMemory::wrap_copy(result, len, STRING_UTF_TAG);
1565       if (new_result == NULL) {
1566         vm_exit_out_of_memory(len, OOM_MALLOC_ERROR, &quot;checked_jni_GetStringUTFChars&quot;);
1567       }
1568       // Avoiding call to UNCHECKED()-&gt;ReleaseStringUTFChars() since that will fire unexpected dtrace probes
1569       // Note that the dtrace arguments for the allocated memory will not match up with this solution.
1570       FreeHeap((char*)result);
1571     }
1572     functionExit(thr);
1573     return new_result;
1574 JNI_END
1575 
1576 JNI_ENTRY_CHECKED(void,
1577   checked_jni_ReleaseStringUTFChars(JNIEnv *env,
1578                                     jstring str,
1579                                     const char* chars))
1580     functionEnterExceptionAllowed(thr);
1581     IN_VM(
1582       checkString(thr, str);
1583     )
1584     if (chars == NULL) {
1585        // still do the unchecked call to allow dtrace probes
1586        UNCHECKED()-&gt;ReleaseStringUTFChars(env,str,chars);
1587     }
1588     else {
1589       GuardedMemory guarded((void*)chars);
1590       if (!guarded.verify_guards()) {
1591         tty-&gt;print_cr(&quot;ReleaseStringUTFChars: release chars failed bounds check. &quot;
1592             &quot;string: &quot; PTR_FORMAT &quot; chars: &quot; PTR_FORMAT, p2i(str), p2i(chars));
1593         guarded.print_on(tty);
1594         NativeReportJNIFatalError(thr, &quot;ReleaseStringUTFChars: &quot;
1595             &quot;release chars failed bounds check.&quot;);
1596       }
1597       if (guarded.get_tag() != STRING_UTF_TAG) {
1598         tty-&gt;print_cr(&quot;ReleaseStringUTFChars: called on something not &quot;
1599             &quot;allocated by GetStringUTFChars. string: &quot; PTR_FORMAT &quot; chars: &quot;
1600             PTR_FORMAT, p2i(str), p2i(chars));
1601         NativeReportJNIFatalError(thr, &quot;ReleaseStringUTFChars &quot;
1602             &quot;called on something not allocated by GetStringUTFChars&quot;);
1603       }
1604       UNCHECKED()-&gt;ReleaseStringUTFChars(env, str,
1605           (const char*) guarded.release_for_freeing());
1606     }
1607     functionExit(thr);
1608 JNI_END
1609 
1610 JNI_ENTRY_CHECKED(jsize,
1611   checked_jni_GetArrayLength(JNIEnv *env,
1612                              jarray array))
1613     functionEnter(thr);
1614     IN_VM(
1615       check_is_array(thr, array);
1616     )
1617     jsize result = UNCHECKED()-&gt;GetArrayLength(env,array);
1618     functionExit(thr);
1619     return result;
1620 JNI_END
1621 
1622 JNI_ENTRY_CHECKED(jobjectArray,
1623   checked_jni_NewObjectArray(JNIEnv *env,
1624                              jsize len,
1625                              jclass clazz,
1626                              jobject init))
1627     functionEnter(thr);
1628     jobjectArray result = UNCHECKED()-&gt;NewObjectArray(env,len,clazz,init);
1629     functionExit(thr);
1630     return result;
1631 JNI_END
1632 
1633 JNI_ENTRY_CHECKED(jobject,
1634   checked_jni_GetObjectArrayElement(JNIEnv *env,
1635                                     jobjectArray array,
1636                                     jsize index))
1637     functionEnter(thr);
1638     IN_VM(
1639       check_is_obj_or_inline_array(thr, array);
1640     )
1641     jobject result = UNCHECKED()-&gt;GetObjectArrayElement(env,array,index);
1642     functionExit(thr);
1643     return result;
1644 JNI_END
1645 
1646 JNI_ENTRY_CHECKED(void,
1647   checked_jni_SetObjectArrayElement(JNIEnv *env,
1648                                     jobjectArray array,
1649                                     jsize index,
1650                                     jobject val))
1651     functionEnter(thr);
1652     IN_VM(
1653       check_is_obj_or_inline_array(thr, array);
1654     )
1655     UNCHECKED()-&gt;SetObjectArrayElement(env,array,index,val);
1656     functionExit(thr);
1657 JNI_END
1658 
1659 #define WRAPPER_NewScalarArray(Return, Result) \
1660 JNI_ENTRY_CHECKED(Return, \
1661   checked_jni_New##Result##Array(JNIEnv *env, \
1662                                  jsize len)) \
1663     functionEnter(thr); \
1664     Return result = UNCHECKED()-&gt;New##Result##Array(env,len); \
1665     functionExit(thr); \
1666     return (Return) result; \
1667 JNI_END
1668 
1669 WRAPPER_NewScalarArray(jbooleanArray, Boolean)
1670 WRAPPER_NewScalarArray(jbyteArray, Byte)
1671 WRAPPER_NewScalarArray(jshortArray, Short)
1672 WRAPPER_NewScalarArray(jcharArray, Char)
1673 WRAPPER_NewScalarArray(jintArray, Int)
1674 WRAPPER_NewScalarArray(jlongArray, Long)
1675 WRAPPER_NewScalarArray(jfloatArray, Float)
1676 WRAPPER_NewScalarArray(jdoubleArray, Double)
1677 
1678 #define WRAPPER_GetScalarArrayElements(ElementTag,ElementType,Result) \
1679 JNI_ENTRY_CHECKED(ElementType *,  \
1680   checked_jni_Get##Result##ArrayElements(JNIEnv *env, \
1681                                          ElementType##Array array, \
1682                                          jboolean *isCopy)) \
1683     functionEnter(thr); \
1684     IN_VM( \
1685       check_primitive_array_type(thr, array, ElementTag); \
1686     ) \
1687     ElementType *result = UNCHECKED()-&gt;Get##Result##ArrayElements(env, \
1688                                                                   array, \
1689                                                                   isCopy); \
1690     if (result != NULL) { \
1691       result = (ElementType *) check_jni_wrap_copy_array(thr, array, result); \
1692     } \
1693     functionExit(thr); \
1694     return result; \
1695 JNI_END
1696 
1697 WRAPPER_GetScalarArrayElements(T_BOOLEAN, jboolean, Boolean)
1698 WRAPPER_GetScalarArrayElements(T_BYTE,    jbyte,    Byte)
1699 WRAPPER_GetScalarArrayElements(T_SHORT,   jshort,   Short)
1700 WRAPPER_GetScalarArrayElements(T_CHAR,    jchar,    Char)
1701 WRAPPER_GetScalarArrayElements(T_INT,     jint,     Int)
1702 WRAPPER_GetScalarArrayElements(T_LONG,    jlong,    Long)
1703 WRAPPER_GetScalarArrayElements(T_FLOAT,   jfloat,   Float)
1704 WRAPPER_GetScalarArrayElements(T_DOUBLE,  jdouble,  Double)
1705 
1706 #define WRAPPER_ReleaseScalarArrayElements(ElementTag,ElementType,Result,Tag) \
1707 JNI_ENTRY_CHECKED(void,  \
1708   checked_jni_Release##Result##ArrayElements(JNIEnv *env, \
1709                                              ElementType##Array array, \
1710                                              ElementType *elems, \
1711                                              jint mode)) \
1712     functionEnterExceptionAllowed(thr); \
1713     IN_VM( \
1714       check_primitive_array_type(thr, array, ElementTag); \
1715       ASSERT_OOPS_ALLOWED; \
1716       typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
1717     ) \
1718     ElementType* orig_result = (ElementType *) check_wrapped_array_release( \
1719         thr, &quot;checked_jni_Release&quot;#Result&quot;ArrayElements&quot;, array, elems, mode); \
1720     UNCHECKED()-&gt;Release##Result##ArrayElements(env, array, orig_result, mode); \
1721     functionExit(thr); \
1722 JNI_END
1723 
1724 WRAPPER_ReleaseScalarArrayElements(T_BOOLEAN,jboolean, Boolean, bool)
1725 WRAPPER_ReleaseScalarArrayElements(T_BYTE,   jbyte,    Byte,    byte)
1726 WRAPPER_ReleaseScalarArrayElements(T_SHORT,  jshort,   Short,   short)
1727 WRAPPER_ReleaseScalarArrayElements(T_CHAR,   jchar,    Char,    char)
1728 WRAPPER_ReleaseScalarArrayElements(T_INT,    jint,     Int,     int)
1729 WRAPPER_ReleaseScalarArrayElements(T_LONG,   jlong,    Long,    long)
1730 WRAPPER_ReleaseScalarArrayElements(T_FLOAT,  jfloat,   Float,   float)
1731 WRAPPER_ReleaseScalarArrayElements(T_DOUBLE, jdouble,  Double,  double)
1732 
1733 #define WRAPPER_GetScalarArrayRegion(ElementTag,ElementType,Result) \
1734 JNI_ENTRY_CHECKED(void,  \
1735   checked_jni_Get##Result##ArrayRegion(JNIEnv *env, \
1736                                        ElementType##Array array, \
1737                                        jsize start, \
1738                                        jsize len, \
1739                                        ElementType *buf)) \
1740     functionEnter(thr); \
1741     IN_VM( \
1742       check_primitive_array_type(thr, array, ElementTag); \
1743     ) \
1744     UNCHECKED()-&gt;Get##Result##ArrayRegion(env,array,start,len,buf); \
1745     functionExit(thr); \
1746 JNI_END
1747 
1748 WRAPPER_GetScalarArrayRegion(T_BOOLEAN, jboolean, Boolean)
1749 WRAPPER_GetScalarArrayRegion(T_BYTE,    jbyte,    Byte)
1750 WRAPPER_GetScalarArrayRegion(T_SHORT,   jshort,   Short)
1751 WRAPPER_GetScalarArrayRegion(T_CHAR,    jchar,    Char)
1752 WRAPPER_GetScalarArrayRegion(T_INT,     jint,     Int)
1753 WRAPPER_GetScalarArrayRegion(T_LONG,    jlong,    Long)
1754 WRAPPER_GetScalarArrayRegion(T_FLOAT,   jfloat,   Float)
1755 WRAPPER_GetScalarArrayRegion(T_DOUBLE,  jdouble,  Double)
1756 
1757 #define WRAPPER_SetScalarArrayRegion(ElementTag,ElementType,Result) \
1758 JNI_ENTRY_CHECKED(void,  \
1759   checked_jni_Set##Result##ArrayRegion(JNIEnv *env, \
1760                                        ElementType##Array array, \
1761                                        jsize start, \
1762                                        jsize len, \
1763                                        const ElementType *buf)) \
1764     functionEnter(thr); \
1765     IN_VM( \
1766       check_primitive_array_type(thr, array, ElementTag); \
1767     ) \
1768     UNCHECKED()-&gt;Set##Result##ArrayRegion(env,array,start,len,buf); \
1769     functionExit(thr); \
1770 JNI_END
1771 
1772 WRAPPER_SetScalarArrayRegion(T_BOOLEAN, jboolean, Boolean)
1773 WRAPPER_SetScalarArrayRegion(T_BYTE,    jbyte,    Byte)
1774 WRAPPER_SetScalarArrayRegion(T_SHORT,   jshort,   Short)
1775 WRAPPER_SetScalarArrayRegion(T_CHAR,    jchar,    Char)
1776 WRAPPER_SetScalarArrayRegion(T_INT,     jint,     Int)
1777 WRAPPER_SetScalarArrayRegion(T_LONG,    jlong,    Long)
1778 WRAPPER_SetScalarArrayRegion(T_FLOAT,   jfloat,   Float)
1779 WRAPPER_SetScalarArrayRegion(T_DOUBLE,  jdouble,  Double)
1780 
1781 JNI_ENTRY_CHECKED(jint,
1782   checked_jni_RegisterNatives(JNIEnv *env,
1783                               jclass clazz,
1784                               const JNINativeMethod *methods,
1785                               jint nMethods))
1786     functionEnter(thr);
1787     jint result = UNCHECKED()-&gt;RegisterNatives(env,clazz,methods,nMethods);
1788     functionExit(thr);
1789     return result;
1790 JNI_END
1791 
1792 JNI_ENTRY_CHECKED(jint,
1793   checked_jni_UnregisterNatives(JNIEnv *env,
1794                                 jclass clazz))
1795     functionEnter(thr);
1796     jint result = UNCHECKED()-&gt;UnregisterNatives(env,clazz);
1797     functionExit(thr);
1798     return result;
1799 JNI_END
1800 
1801 JNI_ENTRY_CHECKED(jint,
1802   checked_jni_MonitorEnter(JNIEnv *env,
1803                            jobject obj))
1804     functionEnter(thr);
1805     IN_VM(
1806       jniCheck::validate_object(thr, obj);
1807     )
1808     jint result = UNCHECKED()-&gt;MonitorEnter(env,obj);
1809     functionExit(thr);
1810     return result;
1811 JNI_END
1812 
1813 JNI_ENTRY_CHECKED(jint,
1814   checked_jni_MonitorExit(JNIEnv *env,
1815                           jobject obj))
1816     functionEnterExceptionAllowed(thr);
1817     IN_VM(
1818       jniCheck::validate_object(thr, obj);
1819     )
1820     jint result = UNCHECKED()-&gt;MonitorExit(env,obj);
1821     functionExit(thr);
1822     return result;
1823 JNI_END
1824 
1825 JNI_ENTRY_CHECKED(jint,
1826   checked_jni_GetJavaVM(JNIEnv *env,
1827                         JavaVM **vm))
1828     functionEnter(thr);
1829     jint result = UNCHECKED()-&gt;GetJavaVM(env,vm);
1830     functionExit(thr);
1831     return result;
1832 JNI_END
1833 
1834 JNI_ENTRY_CHECKED(void,
1835   checked_jni_GetStringRegion(JNIEnv *env,
1836                               jstring str,
1837                               jsize start,
1838                               jsize len,
1839                               jchar *buf))
1840     functionEnter(thr);
1841     IN_VM(
1842       checkString(thr, str);
1843     )
1844     UNCHECKED()-&gt;GetStringRegion(env, str, start, len, buf);
1845     functionExit(thr);
1846 JNI_END
1847 
1848 JNI_ENTRY_CHECKED(void,
1849   checked_jni_GetStringUTFRegion(JNIEnv *env,
1850                                  jstring str,
1851                                  jsize start,
1852                                  jsize len,
1853                                  char *buf))
1854     functionEnter(thr);
1855     IN_VM(
1856       checkString(thr, str);
1857     )
1858     UNCHECKED()-&gt;GetStringUTFRegion(env, str, start, len, buf);
1859     functionExit(thr);
1860 JNI_END
1861 
1862 JNI_ENTRY_CHECKED(void *,
1863   checked_jni_GetPrimitiveArrayCritical(JNIEnv *env,
1864                                         jarray array,
1865                                         jboolean *isCopy))
1866     functionEnterCritical(thr);
1867     IN_VM(
1868       check_is_primitive_array(thr, array);
1869     )
1870     void *result = UNCHECKED()-&gt;GetPrimitiveArrayCritical(env, array, isCopy);
1871     if (result != NULL) {
1872       result = check_jni_wrap_copy_array(thr, array, result);
1873     }
1874     functionExit(thr);
1875     return result;
1876 JNI_END
1877 
1878 JNI_ENTRY_CHECKED(void,
1879   checked_jni_ReleasePrimitiveArrayCritical(JNIEnv *env,
1880                                             jarray array,
1881                                             void *carray,
1882                                             jint mode))
1883     functionEnterCriticalExceptionAllowed(thr);
1884     IN_VM(
1885       check_is_primitive_array(thr, array);
1886     )
1887     // Check the element array...
1888     void* orig_result = check_wrapped_array_release(thr, &quot;ReleasePrimitiveArrayCritical&quot;, array, carray, mode);
1889     UNCHECKED()-&gt;ReleasePrimitiveArrayCritical(env, array, orig_result, mode);
1890     functionExit(thr);
1891 JNI_END
1892 
1893 JNI_ENTRY_CHECKED(const jchar*,
1894   checked_jni_GetStringCritical(JNIEnv *env,
1895                                 jstring string,
1896                                 jboolean *isCopy))
1897     functionEnterCritical(thr);
1898     IN_VM(
1899       checkString(thr, string);
1900     )
1901     const jchar *result = UNCHECKED()-&gt;GetStringCritical(env, string, isCopy);
1902     functionExit(thr);
1903     return result;
1904 JNI_END
1905 
1906 JNI_ENTRY_CHECKED(void,
1907   checked_jni_ReleaseStringCritical(JNIEnv *env,
1908                                     jstring str,
1909                                     const jchar *chars))
1910     functionEnterCriticalExceptionAllowed(thr);
1911     IN_VM(
1912       checkString(thr, str);
1913     )
1914     /* The Hotspot JNI code does not use the parameters, so just check the
1915      * string parameter as a minor sanity check
1916      */
1917     UNCHECKED()-&gt;ReleaseStringCritical(env, str, chars);
1918     functionExit(thr);
1919 JNI_END
1920 
1921 JNI_ENTRY_CHECKED(jweak,
1922   checked_jni_NewWeakGlobalRef(JNIEnv *env,
1923                                jobject obj))
1924     functionEnter(thr);
1925     IN_VM(
1926       if (obj != NULL) {
1927         jniCheck::validate_handle(thr, obj);
1928       }
1929     )
1930     jweak result = UNCHECKED()-&gt;NewWeakGlobalRef(env, obj);
1931     functionExit(thr);
1932     return result;
1933 JNI_END
1934 
1935 JNI_ENTRY_CHECKED(void,
1936   checked_jni_DeleteWeakGlobalRef(JNIEnv *env,
1937                                   jweak ref))
1938     functionEnterExceptionAllowed(thr);
1939     IN_VM(
1940       if (ref &amp;&amp; !JNIHandles::is_weak_global_handle(ref)) {
1941         ReportJNIFatalError(thr,
1942              &quot;Invalid weak global JNI handle passed to DeleteWeakGlobalRef&quot;);
1943       }
1944     )
1945     UNCHECKED()-&gt;DeleteWeakGlobalRef(env, ref);
1946     functionExit(thr);
1947 JNI_END
1948 
1949 JNI_ENTRY_CHECKED(jboolean,
1950   checked_jni_ExceptionCheck(JNIEnv *env))
1951     thr-&gt;clear_pending_jni_exception_check();
1952     functionEnterExceptionAllowed(thr);
1953     jboolean result = UNCHECKED()-&gt;ExceptionCheck(env);
1954     functionExit(thr);
1955     return result;
1956 JNI_END
1957 
1958 JNI_ENTRY_CHECKED(jobject,
1959   checked_jni_NewDirectByteBuffer(JNIEnv *env,
1960                                   void *address,
1961                                   jlong capacity))
1962     functionEnter(thr);
1963     jobject result = UNCHECKED()-&gt;NewDirectByteBuffer(env, address, capacity);
1964     functionExit(thr);
1965     return result;
1966 JNI_END
1967 
1968 JNI_ENTRY_CHECKED(void *,
1969   checked_jni_GetDirectBufferAddress(JNIEnv *env,
1970                                      jobject buf))
1971     functionEnter(thr);
1972     void* result = UNCHECKED()-&gt;GetDirectBufferAddress(env, buf);
1973     functionExit(thr);
1974     return result;
1975 JNI_END
1976 
1977 JNI_ENTRY_CHECKED(jlong,
1978   checked_jni_GetDirectBufferCapacity(JNIEnv *env,
1979                                       jobject buf))
1980     functionEnter(thr);
1981     jlong result = UNCHECKED()-&gt;GetDirectBufferCapacity(env, buf);
1982     functionExit(thr);
1983     return result;
1984 JNI_END
1985 
1986 JNI_ENTRY_CHECKED(jobjectRefType,
1987   checked_jni_GetObjectRefType(JNIEnv *env,
1988                                jobject obj))
1989     functionEnter(thr);
1990     /* validate the object being passed */
1991     IN_VM(
1992       jniCheck::validate_object(thr, obj);
1993     )
1994     jobjectRefType result = UNCHECKED()-&gt;GetObjectRefType(env, obj);
1995     functionExit(thr);
1996     return result;
1997 JNI_END
1998 
1999 
2000 JNI_ENTRY_CHECKED(jint,
2001   checked_jni_GetVersion(JNIEnv *env))
2002     functionEnter(thr);
2003     jint result = UNCHECKED()-&gt;GetVersion(env);
2004     functionExit(thr);
2005     return result;
2006 JNI_END
2007 
2008 JNI_ENTRY_CHECKED(jobject,
2009   checked_jni_GetModule(JNIEnv *env,
2010                         jclass clazz))
2011     functionEnter(thr);
2012     jobject result = UNCHECKED()-&gt;GetModule(env,clazz);
2013     functionExit(thr);
2014     return result;
2015 JNI_END
2016 
2017 JNI_ENTRY_CHECKED(void*,
2018     checked_jni_GetFlattenedArrayElements(JNIEnv* env, jarray array, jboolean* isCopy))
2019     functionEnter(thr);
2020     void* result = UNCHECKED()-&gt;GetFlattenedArrayElements(env, array, isCopy);
2021     functionExit(thr);
2022     return result;
2023 
2024 JNI_END
2025 
2026 JNI_ENTRY_CHECKED(void,
2027     checked_jni_ReleaseFlattenedArrayElements(JNIEnv* env, jarray array, void* elem, jint mode))
2028     functionEnter(thr);
2029     UNCHECKED()-&gt;ReleaseFlattenedArrayElements(env, array, elem, mode);
2030     functionExit(thr);
2031     return;
2032 JNI_END
2033 
2034 JNI_ENTRY_CHECKED(jclass,
2035     checked_jni_GetFlattenedArrayElementClass(JNIEnv* env, jarray array))
2036     functionEnter(thr);
2037     jclass clazz = UNCHECKED()-&gt;GetFlattenedArrayElementClass(env, array);
2038     functionExit(thr);
2039     return clazz;
2040 JNI_END
2041 
2042 JNI_ENTRY_CHECKED(jsize,
2043     checked_jni_GetFlattenedArrayElementSize(JNIEnv* env, jarray array))
2044     functionEnter(thr);
2045     jsize size = UNCHECKED()-&gt;GetFlattenedArrayElementSize(env, array);
2046     functionExit(thr);
2047     return size;
2048 JNI_END
2049 
2050 JNI_ENTRY_CHECKED(jsize,
2051     checked_jni_GetFieldOffsetInFlattenedLayout(JNIEnv* env, jclass clazz, const char *name, const char *signature, jboolean* isFlattened))
2052     functionEnter(thr);
2053     jsize offset = UNCHECKED()-&gt;GetFieldOffsetInFlattenedLayout(env, clazz, name, signature, isFlattened);
2054     functionExit(thr);
2055     return offset;
2056 JNI_END
2057 
2058 JNI_ENTRY_CHECKED(jobject,
2059     checked_jni_CreateSubElementSelector(JNIEnv* env, jarray array))
2060     functionEnter(thr);
2061     jobject selector = UNCHECKED()-&gt;CreateSubElementSelector(env, array);
2062     functionExit(thr);
2063     return selector;
2064 JNI_END
2065 
2066 JNI_ENTRY_CHECKED(jobject,
2067     checked_jni_GetSubElementSelector(JNIEnv* env, jobject selector, jfieldID fieldID))
2068     functionEnter(thr);
2069     jobject res = UNCHECKED()-&gt;GetSubElementSelector(env, selector, fieldID);
2070     functionExit(thr);
2071     return res;
2072 JNI_END
2073 
2074 JNI_ENTRY_CHECKED(jobject,
2075     checked_jni_GetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index))
2076     functionEnter(thr);
2077     jobject res = UNCHECKED()-&gt;GetObjectSubElement(env, array, selector, index);
2078     functionExit(thr);
2079     return res;
2080 JNI_END
2081 
2082 JNI_ENTRY_CHECKED(void,
2083     checked_jni_SetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index, jobject value))
2084     functionEnter(thr);
2085     UNCHECKED()-&gt;SetObjectSubElement(env, array, selector, index, value);
2086     functionExit(thr);
2087     return;
2088 JNI_END
2089 
2090 JNI_ENTRY_CHECKED(jboolean,
2091     checked_jni_GetBooleanSubElement(JNIEnv* env, jarray array, jobject selector, int index))
2092     functionEnter(thr);
2093     jboolean res = UNCHECKED()-&gt;GetBooleanSubElement(env, array, selector, index);
2094     functionExit(thr);
2095     return res;
2096 JNI_END
2097 
2098 JNI_ENTRY_CHECKED(void,
2099     checked_jni_SetBooleanSubElement(JNIEnv* env, jarray array, jobject selector, int index, jboolean value))
2100     functionEnter(thr);
2101     UNCHECKED()-&gt;SetBooleanSubElement(env, array, selector, index, value);
2102     functionExit(thr);
2103     return;
2104 JNI_END
2105 
2106 JNI_ENTRY_CHECKED(jbyte,
2107     checked_jni_GetByteSubElement(JNIEnv* env, jarray array, jobject selector, int index))
2108     functionEnter(thr);
2109     jbyte res = UNCHECKED()-&gt;GetByteSubElement(env, array, selector, index);
2110     functionExit(thr);
2111     return res;
2112 JNI_END
2113 
2114 JNI_ENTRY_CHECKED(void,
2115     checked_jni_SetByteSubElement(JNIEnv* env, jarray array, jobject selector, int index, jbyte value))
2116     functionEnter(thr);
2117     UNCHECKED()-&gt;SetByteSubElement(env, array, selector, index, value);
2118     functionExit(thr);
2119     return;
2120 JNI_END
2121 
2122 JNI_ENTRY_CHECKED(jshort,
2123     checked_jni_GetShortSubElement(JNIEnv* env, jarray array, jobject selector, int index))
2124     functionEnter(thr);
2125     jshort res = UNCHECKED()-&gt;GetShortSubElement(env, array, selector, index);
2126     functionExit(thr);
2127     return res;
2128 JNI_END
2129 
2130 JNI_ENTRY_CHECKED(void,
2131     checked_jni_SetShortSubElement(JNIEnv* env, jarray array, jobject selector, int index, jshort value))
2132     functionEnter(thr);
2133     UNCHECKED()-&gt;SetShortSubElement(env, array, selector, index, value);
2134     functionExit(thr);
2135     return;
2136 JNI_END
2137 
2138 JNI_ENTRY_CHECKED(jchar,
2139     checked_jni_GetCharSubElement(JNIEnv* env, jarray array, jobject selector, int index))
2140     functionEnter(thr);
2141     jchar res = UNCHECKED()-&gt;GetCharSubElement(env, array, selector, index);
2142     functionExit(thr);
2143     return res;
2144 JNI_END
2145 
2146 JNI_ENTRY_CHECKED(void,
2147     checked_jni_SetCharSubElement(JNIEnv* env, jarray array, jobject selector, int index, jchar value))
2148     functionEnter(thr);
2149     UNCHECKED()-&gt;SetCharSubElement(env, array, selector, index, value);
2150     functionExit(thr);
2151     return;
2152 JNI_END
2153 
2154 JNI_ENTRY_CHECKED(jint,
2155     checked_jni_GetIntSubElement(JNIEnv* env, jarray array, jobject selector, int index))
2156     functionEnter(thr);
2157     jint res = UNCHECKED()-&gt;GetIntSubElement(env, array, selector, index);
2158     functionExit(thr);
2159     return res;
2160 JNI_END
2161 
2162 JNI_ENTRY_CHECKED(void,
2163     checked_jni_SetIntSubElement(JNIEnv* env, jarray array, jobject selector, int index, jint value))
2164     functionEnter(thr);
2165     UNCHECKED()-&gt;SetIntSubElement(env, array, selector, index, value);
2166     functionExit(thr);
2167     return;
2168 JNI_END
2169 
2170 JNI_ENTRY_CHECKED(jlong,
2171     checked_jni_GetLongSubElement(JNIEnv* env, jarray array, jobject selector, int index))
2172     functionEnter(thr);
2173     jlong res = UNCHECKED()-&gt;GetLongSubElement(env, array, selector, index);
2174     functionExit(thr);
2175     return res;
2176 JNI_END
2177 
2178 JNI_ENTRY_CHECKED(void,
2179     checked_jni_SetLongSubElement(JNIEnv* env, jarray array, jobject selector, int index, jlong value))
2180     functionEnter(thr);
2181     UNCHECKED()-&gt;SetLongSubElement(env, array, selector, index, value);
2182     functionExit(thr);
2183     return;
2184 JNI_END
2185 
2186 JNI_ENTRY_CHECKED(jfloat,
2187     checked_jni_GetFloatSubElement(JNIEnv* env, jarray array, jobject selector, int index))
2188     functionEnter(thr);
2189     jfloat res = UNCHECKED()-&gt;GetFloatSubElement(env, array, selector, index);
2190     functionExit(thr);
2191     return res;
2192 JNI_END
2193 
2194 JNI_ENTRY_CHECKED(void,
2195     checked_jni_SetFloatSubElement(JNIEnv* env, jarray array, jobject selector, int index, jfloat value))
2196     functionEnter(thr);
2197     UNCHECKED()-&gt;SetFloatSubElement(env, array, selector, index, value);
2198     functionExit(thr);
2199     return;
2200 JNI_END
2201 
2202 JNI_ENTRY_CHECKED(jdouble,
2203     checked_jni_GetDoubleSubElement(JNIEnv* env, jarray array, jobject selector, int index))
2204     functionEnter(thr);
2205     jdouble res = UNCHECKED()-&gt;GetDoubleSubElement(env, array, selector, index);
2206     functionExit(thr);
2207     return res;
2208 JNI_END
2209 
2210 JNI_ENTRY_CHECKED(void,
2211     checked_jni_SetDoubleSubElement(JNIEnv* env, jarray array, jobject selector, int index, jdouble value))
2212     functionEnter(thr);
2213     UNCHECKED()-&gt;SetDoubleSubElement(env, array, selector, index, value);
2214     functionExit(thr);
2215     return;
2216 JNI_END
2217 
2218 /*
2219  * Structure containing all checked jni functions
2220  */
2221 struct JNINativeInterface_  checked_jni_NativeInterface = {
2222     NULL,
2223     NULL,
2224     NULL,
2225 
2226     NULL,
2227 
2228     checked_jni_GetVersion,
2229 
2230     checked_jni_DefineClass,
2231     checked_jni_FindClass,
2232 
2233     checked_jni_FromReflectedMethod,
2234     checked_jni_FromReflectedField,
2235 
2236     checked_jni_ToReflectedMethod,
2237 
2238     checked_jni_GetSuperclass,
2239     checked_jni_IsAssignableFrom,
2240 
2241     checked_jni_ToReflectedField,
2242 
2243     checked_jni_Throw,
2244     checked_jni_ThrowNew,
2245     checked_jni_ExceptionOccurred,
2246     checked_jni_ExceptionDescribe,
2247     checked_jni_ExceptionClear,
2248     checked_jni_FatalError,
2249 
2250     checked_jni_PushLocalFrame,
2251     checked_jni_PopLocalFrame,
2252 
2253     checked_jni_NewGlobalRef,
2254     checked_jni_DeleteGlobalRef,
2255     checked_jni_DeleteLocalRef,
2256     checked_jni_IsSameObject,
2257 
2258     checked_jni_NewLocalRef,
2259     checked_jni_EnsureLocalCapacity,
2260 
2261     checked_jni_AllocObject,
2262     checked_jni_NewObject,
2263     checked_jni_NewObjectV,
2264     checked_jni_NewObjectA,
2265 
2266     checked_jni_GetObjectClass,
2267     checked_jni_IsInstanceOf,
2268 
2269     checked_jni_GetMethodID,
2270 
2271     checked_jni_CallObjectMethod,
2272     checked_jni_CallObjectMethodV,
2273     checked_jni_CallObjectMethodA,
2274     checked_jni_CallBooleanMethod,
2275     checked_jni_CallBooleanMethodV,
2276     checked_jni_CallBooleanMethodA,
2277     checked_jni_CallByteMethod,
2278     checked_jni_CallByteMethodV,
2279     checked_jni_CallByteMethodA,
2280     checked_jni_CallCharMethod,
2281     checked_jni_CallCharMethodV,
2282     checked_jni_CallCharMethodA,
2283     checked_jni_CallShortMethod,
2284     checked_jni_CallShortMethodV,
2285     checked_jni_CallShortMethodA,
2286     checked_jni_CallIntMethod,
2287     checked_jni_CallIntMethodV,
2288     checked_jni_CallIntMethodA,
2289     checked_jni_CallLongMethod,
2290     checked_jni_CallLongMethodV,
2291     checked_jni_CallLongMethodA,
2292     checked_jni_CallFloatMethod,
2293     checked_jni_CallFloatMethodV,
2294     checked_jni_CallFloatMethodA,
2295     checked_jni_CallDoubleMethod,
2296     checked_jni_CallDoubleMethodV,
2297     checked_jni_CallDoubleMethodA,
2298     checked_jni_CallVoidMethod,
2299     checked_jni_CallVoidMethodV,
2300     checked_jni_CallVoidMethodA,
2301 
2302     checked_jni_CallNonvirtualObjectMethod,
2303     checked_jni_CallNonvirtualObjectMethodV,
2304     checked_jni_CallNonvirtualObjectMethodA,
2305     checked_jni_CallNonvirtualBooleanMethod,
2306     checked_jni_CallNonvirtualBooleanMethodV,
2307     checked_jni_CallNonvirtualBooleanMethodA,
2308     checked_jni_CallNonvirtualByteMethod,
2309     checked_jni_CallNonvirtualByteMethodV,
2310     checked_jni_CallNonvirtualByteMethodA,
2311     checked_jni_CallNonvirtualCharMethod,
2312     checked_jni_CallNonvirtualCharMethodV,
2313     checked_jni_CallNonvirtualCharMethodA,
2314     checked_jni_CallNonvirtualShortMethod,
2315     checked_jni_CallNonvirtualShortMethodV,
2316     checked_jni_CallNonvirtualShortMethodA,
2317     checked_jni_CallNonvirtualIntMethod,
2318     checked_jni_CallNonvirtualIntMethodV,
2319     checked_jni_CallNonvirtualIntMethodA,
2320     checked_jni_CallNonvirtualLongMethod,
2321     checked_jni_CallNonvirtualLongMethodV,
2322     checked_jni_CallNonvirtualLongMethodA,
2323     checked_jni_CallNonvirtualFloatMethod,
2324     checked_jni_CallNonvirtualFloatMethodV,
2325     checked_jni_CallNonvirtualFloatMethodA,
2326     checked_jni_CallNonvirtualDoubleMethod,
2327     checked_jni_CallNonvirtualDoubleMethodV,
2328     checked_jni_CallNonvirtualDoubleMethodA,
2329     checked_jni_CallNonvirtualVoidMethod,
2330     checked_jni_CallNonvirtualVoidMethodV,
2331     checked_jni_CallNonvirtualVoidMethodA,
2332 
2333     checked_jni_GetFieldID,
2334 
2335     checked_jni_GetObjectField,
2336     checked_jni_GetBooleanField,
2337     checked_jni_GetByteField,
2338     checked_jni_GetCharField,
2339     checked_jni_GetShortField,
2340     checked_jni_GetIntField,
2341     checked_jni_GetLongField,
2342     checked_jni_GetFloatField,
2343     checked_jni_GetDoubleField,
2344 
2345     checked_jni_SetObjectField,
2346     checked_jni_SetBooleanField,
2347     checked_jni_SetByteField,
2348     checked_jni_SetCharField,
2349     checked_jni_SetShortField,
2350     checked_jni_SetIntField,
2351     checked_jni_SetLongField,
2352     checked_jni_SetFloatField,
2353     checked_jni_SetDoubleField,
2354 
2355     checked_jni_GetStaticMethodID,
2356 
2357     checked_jni_CallStaticObjectMethod,
2358     checked_jni_CallStaticObjectMethodV,
2359     checked_jni_CallStaticObjectMethodA,
2360     checked_jni_CallStaticBooleanMethod,
2361     checked_jni_CallStaticBooleanMethodV,
2362     checked_jni_CallStaticBooleanMethodA,
2363     checked_jni_CallStaticByteMethod,
2364     checked_jni_CallStaticByteMethodV,
2365     checked_jni_CallStaticByteMethodA,
2366     checked_jni_CallStaticCharMethod,
2367     checked_jni_CallStaticCharMethodV,
2368     checked_jni_CallStaticCharMethodA,
2369     checked_jni_CallStaticShortMethod,
2370     checked_jni_CallStaticShortMethodV,
2371     checked_jni_CallStaticShortMethodA,
2372     checked_jni_CallStaticIntMethod,
2373     checked_jni_CallStaticIntMethodV,
2374     checked_jni_CallStaticIntMethodA,
2375     checked_jni_CallStaticLongMethod,
2376     checked_jni_CallStaticLongMethodV,
2377     checked_jni_CallStaticLongMethodA,
2378     checked_jni_CallStaticFloatMethod,
2379     checked_jni_CallStaticFloatMethodV,
2380     checked_jni_CallStaticFloatMethodA,
2381     checked_jni_CallStaticDoubleMethod,
2382     checked_jni_CallStaticDoubleMethodV,
2383     checked_jni_CallStaticDoubleMethodA,
2384     checked_jni_CallStaticVoidMethod,
2385     checked_jni_CallStaticVoidMethodV,
2386     checked_jni_CallStaticVoidMethodA,
2387 
2388     checked_jni_GetStaticFieldID,
2389 
2390     checked_jni_GetStaticObjectField,
2391     checked_jni_GetStaticBooleanField,
2392     checked_jni_GetStaticByteField,
2393     checked_jni_GetStaticCharField,
2394     checked_jni_GetStaticShortField,
2395     checked_jni_GetStaticIntField,
2396     checked_jni_GetStaticLongField,
2397     checked_jni_GetStaticFloatField,
2398     checked_jni_GetStaticDoubleField,
2399 
2400     checked_jni_SetStaticObjectField,
2401     checked_jni_SetStaticBooleanField,
2402     checked_jni_SetStaticByteField,
2403     checked_jni_SetStaticCharField,
2404     checked_jni_SetStaticShortField,
2405     checked_jni_SetStaticIntField,
2406     checked_jni_SetStaticLongField,
2407     checked_jni_SetStaticFloatField,
2408     checked_jni_SetStaticDoubleField,
2409 
2410     checked_jni_NewString,
2411     checked_jni_GetStringLength,
2412     checked_jni_GetStringChars,
2413     checked_jni_ReleaseStringChars,
2414 
2415     checked_jni_NewStringUTF,
2416     checked_jni_GetStringUTFLength,
2417     checked_jni_GetStringUTFChars,
2418     checked_jni_ReleaseStringUTFChars,
2419 
2420     checked_jni_GetArrayLength,
2421 
2422     checked_jni_NewObjectArray,
2423     checked_jni_GetObjectArrayElement,
2424     checked_jni_SetObjectArrayElement,
2425 
2426     checked_jni_NewBooleanArray,
2427     checked_jni_NewByteArray,
2428     checked_jni_NewCharArray,
2429     checked_jni_NewShortArray,
2430     checked_jni_NewIntArray,
2431     checked_jni_NewLongArray,
2432     checked_jni_NewFloatArray,
2433     checked_jni_NewDoubleArray,
2434 
2435     checked_jni_GetBooleanArrayElements,
2436     checked_jni_GetByteArrayElements,
2437     checked_jni_GetCharArrayElements,
2438     checked_jni_GetShortArrayElements,
2439     checked_jni_GetIntArrayElements,
2440     checked_jni_GetLongArrayElements,
2441     checked_jni_GetFloatArrayElements,
2442     checked_jni_GetDoubleArrayElements,
2443 
2444     checked_jni_ReleaseBooleanArrayElements,
2445     checked_jni_ReleaseByteArrayElements,
2446     checked_jni_ReleaseCharArrayElements,
2447     checked_jni_ReleaseShortArrayElements,
2448     checked_jni_ReleaseIntArrayElements,
2449     checked_jni_ReleaseLongArrayElements,
2450     checked_jni_ReleaseFloatArrayElements,
2451     checked_jni_ReleaseDoubleArrayElements,
2452 
2453     checked_jni_GetBooleanArrayRegion,
2454     checked_jni_GetByteArrayRegion,
2455     checked_jni_GetCharArrayRegion,
2456     checked_jni_GetShortArrayRegion,
2457     checked_jni_GetIntArrayRegion,
2458     checked_jni_GetLongArrayRegion,
2459     checked_jni_GetFloatArrayRegion,
2460     checked_jni_GetDoubleArrayRegion,
2461 
2462     checked_jni_SetBooleanArrayRegion,
2463     checked_jni_SetByteArrayRegion,
2464     checked_jni_SetCharArrayRegion,
2465     checked_jni_SetShortArrayRegion,
2466     checked_jni_SetIntArrayRegion,
2467     checked_jni_SetLongArrayRegion,
2468     checked_jni_SetFloatArrayRegion,
2469     checked_jni_SetDoubleArrayRegion,
2470 
2471     checked_jni_RegisterNatives,
2472     checked_jni_UnregisterNatives,
2473 
2474     checked_jni_MonitorEnter,
2475     checked_jni_MonitorExit,
2476 
2477     checked_jni_GetJavaVM,
2478 
2479     checked_jni_GetStringRegion,
2480     checked_jni_GetStringUTFRegion,
2481 
2482     checked_jni_GetPrimitiveArrayCritical,
2483     checked_jni_ReleasePrimitiveArrayCritical,
2484 
2485     checked_jni_GetStringCritical,
2486     checked_jni_ReleaseStringCritical,
2487 
2488     checked_jni_NewWeakGlobalRef,
2489     checked_jni_DeleteWeakGlobalRef,
2490 
2491     checked_jni_ExceptionCheck,
2492 
2493     checked_jni_NewDirectByteBuffer,
2494     checked_jni_GetDirectBufferAddress,
2495     checked_jni_GetDirectBufferCapacity,
2496 
2497     // New 1.6 Features
2498 
2499     checked_jni_GetObjectRefType,
2500 
2501     // Module Features
2502 
2503     checked_jni_GetModule,
2504 
2505     // Flattened arrays Features
2506     checked_jni_GetFlattenedArrayElements,
2507     checked_jni_ReleaseFlattenedArrayElements,
2508     checked_jni_GetFlattenedArrayElementClass,
2509     checked_jni_GetFlattenedArrayElementSize,
2510     checked_jni_GetFieldOffsetInFlattenedLayout,
2511 
2512     checked_jni_CreateSubElementSelector,
2513     checked_jni_GetSubElementSelector,
2514     checked_jni_GetObjectSubElement,
2515     checked_jni_SetObjectSubElement,
2516 
2517     checked_jni_GetBooleanSubElement,
2518     checked_jni_GetByteSubElement,
2519     checked_jni_GetShortSubElement,
2520     checked_jni_GetCharSubElement,
2521     checked_jni_GetIntSubElement,
2522     checked_jni_GetLongSubElement,
2523     checked_jni_GetFloatSubElement,
2524     checked_jni_GetDoubleSubElement,
2525 
2526     checked_jni_SetBooleanSubElement,
2527     checked_jni_SetByteSubElement,
2528     checked_jni_SetShortSubElement,
2529     checked_jni_SetCharSubElement,
2530     checked_jni_SetIntSubElement,
2531     checked_jni_SetLongSubElement,
2532     checked_jni_SetFloatSubElement,
2533     checked_jni_SetDoubleSubElement
2534 };
2535 
2536 
2537 // Returns the function structure
2538 struct JNINativeInterface_* jni_functions_check() {
2539 
2540   unchecked_jni_NativeInterface = jni_functions_nocheck();
2541 
2542   // make sure the last pointer in the checked table is not null, indicating
2543   // an addition to the JNINativeInterface_ structure without initializing
2544   // it in the checked table.
2545   debug_only(int *lastPtr = (int *)((char *)&amp;checked_jni_NativeInterface + \
2546              sizeof(*unchecked_jni_NativeInterface) - sizeof(char *));)
2547   assert(*lastPtr != 0,
2548          &quot;Mismatched JNINativeInterface tables, check for new entries&quot;);
2549 
2550   // with -verbose:jni this message will print
2551   log_debug(jni, resolve)(&quot;Checked JNI functions are being used to validate JNI usage&quot;);
2552 
2553   return &amp;checked_jni_NativeInterface;
2554 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
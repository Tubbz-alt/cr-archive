<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/macroArrayCopy.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;opto/arraycopynode.hpp&quot;
  28 #include &quot;oops/objArrayKlass.hpp&quot;
  29 #include &quot;opto/convertnode.hpp&quot;
  30 #include &quot;opto/graphKit.hpp&quot;
  31 #include &quot;opto/macro.hpp&quot;
  32 #include &quot;opto/runtime.hpp&quot;
  33 #include &quot;utilities/align.hpp&quot;
  34 #include &quot;utilities/powerOfTwo.hpp&quot;
  35 
  36 void PhaseMacroExpand::insert_mem_bar(Node** ctrl, Node** mem, int opcode, Node* precedent) {
  37   MemBarNode* mb = MemBarNode::make(C, opcode, Compile::AliasIdxBot, precedent);
  38   mb-&gt;init_req(TypeFunc::Control, *ctrl);
  39   mb-&gt;init_req(TypeFunc::Memory, *mem);
  40   transform_later(mb);
  41   *ctrl = new ProjNode(mb,TypeFunc::Control);
  42   transform_later(*ctrl);
  43   Node* mem_proj = new ProjNode(mb,TypeFunc::Memory);
  44   transform_later(mem_proj);
  45   *mem = mem_proj;
  46 }
  47 
  48 Node* PhaseMacroExpand::array_element_address(Node* ary, Node* idx, BasicType elembt) {
  49   uint shift  = exact_log2(type2aelembytes(elembt));
  50   uint header = arrayOopDesc::base_offset_in_bytes(elembt);
  51   Node* base =  basic_plus_adr(ary, header);
  52 #ifdef _LP64
  53   // see comment in GraphKit::array_element_address
  54   int index_max = max_jint - 1;  // array size is max_jint, index is one less
  55   const TypeLong* lidxtype = TypeLong::make(CONST64(0), index_max, Type::WidenMax);
  56   idx = transform_later( new ConvI2LNode(idx, lidxtype) );
  57 #endif
  58   Node* scale = new LShiftXNode(idx, intcon(shift));
  59   transform_later(scale);
  60   return basic_plus_adr(ary, base, scale);
  61 }
  62 
  63 Node* PhaseMacroExpand::ConvI2L(Node* offset) {
  64   return transform_later(new ConvI2LNode(offset));
  65 }
  66 
  67 Node* PhaseMacroExpand::make_leaf_call(Node* ctrl, Node* mem,
  68                                        const TypeFunc* call_type, address call_addr,
  69                                        const char* call_name,
  70                                        const TypePtr* adr_type,
  71                                        Node* parm0, Node* parm1,
  72                                        Node* parm2, Node* parm3,
  73                                        Node* parm4, Node* parm5,
  74                                        Node* parm6, Node* parm7) {
  75   Node* call = new CallLeafNoFPNode(call_type, call_addr, call_name, adr_type);
  76   call-&gt;init_req(TypeFunc::Control, ctrl);
  77   call-&gt;init_req(TypeFunc::I_O    , top());
  78   call-&gt;init_req(TypeFunc::Memory , mem);
  79   call-&gt;init_req(TypeFunc::ReturnAdr, top());
  80   call-&gt;init_req(TypeFunc::FramePtr, top());
  81 
  82   // Hook each parm in order.  Stop looking at the first NULL.
  83   if (parm0 != NULL) { call-&gt;init_req(TypeFunc::Parms+0, parm0);
  84   if (parm1 != NULL) { call-&gt;init_req(TypeFunc::Parms+1, parm1);
  85   if (parm2 != NULL) { call-&gt;init_req(TypeFunc::Parms+2, parm2);
  86   if (parm3 != NULL) { call-&gt;init_req(TypeFunc::Parms+3, parm3);
  87   if (parm4 != NULL) { call-&gt;init_req(TypeFunc::Parms+4, parm4);
  88   if (parm5 != NULL) { call-&gt;init_req(TypeFunc::Parms+5, parm5);
  89   if (parm6 != NULL) { call-&gt;init_req(TypeFunc::Parms+6, parm6);
  90   if (parm7 != NULL) { call-&gt;init_req(TypeFunc::Parms+7, parm7);
  91     /* close each nested if ===&gt; */  } } } } } } } }
  92   assert(call-&gt;in(call-&gt;req()-1) != NULL, &quot;must initialize all parms&quot;);
  93 
  94   return call;
  95 }
  96 
  97 
  98 //------------------------------generate_guard---------------------------
  99 // Helper function for generating guarded fast-slow graph structures.
 100 // The given &#39;test&#39;, if true, guards a slow path.  If the test fails
 101 // then a fast path can be taken.  (We generally hope it fails.)
 102 // In all cases, GraphKit::control() is updated to the fast path.
 103 // The returned value represents the control for the slow path.
 104 // The return value is never &#39;top&#39;; it is either a valid control
 105 // or NULL if it is obvious that the slow path can never be taken.
 106 // Also, if region and the slow control are not NULL, the slow edge
 107 // is appended to the region.
 108 Node* PhaseMacroExpand::generate_guard(Node** ctrl, Node* test, RegionNode* region, float true_prob) {
 109   if ((*ctrl)-&gt;is_top()) {
 110     // Already short circuited.
 111     return NULL;
 112   }
 113   // Build an if node and its projections.
 114   // If test is true we take the slow path, which we assume is uncommon.
 115   if (_igvn.type(test) == TypeInt::ZERO) {
 116     // The slow branch is never taken.  No need to build this guard.
 117     return NULL;
 118   }
 119 
 120   IfNode* iff = new IfNode(*ctrl, test, true_prob, COUNT_UNKNOWN);
 121   transform_later(iff);
 122 
 123   Node* if_slow = new IfTrueNode(iff);
 124   transform_later(if_slow);
 125 
 126   if (region != NULL) {
 127     region-&gt;add_req(if_slow);
 128   }
 129 
 130   Node* if_fast = new IfFalseNode(iff);
 131   transform_later(if_fast);
 132 
 133   *ctrl = if_fast;
 134 
 135   return if_slow;
 136 }
 137 
 138 Node* PhaseMacroExpand::generate_slow_guard(Node** ctrl, Node* test, RegionNode* region) {
 139   return generate_guard(ctrl, test, region, PROB_UNLIKELY_MAG(3));
 140 }
 141 
 142 inline Node* PhaseMacroExpand::generate_fair_guard(Node** ctrl, Node* test, RegionNode* region) {
 143   return generate_guard(ctrl, test, region, PROB_FAIR);
 144 }
 145 
 146 void PhaseMacroExpand::generate_negative_guard(Node** ctrl, Node* index, RegionNode* region) {
 147   if ((*ctrl)-&gt;is_top())
 148     return;                // already stopped
 149   if (_igvn.type(index)-&gt;higher_equal(TypeInt::POS)) // [0,maxint]
 150     return;                // index is already adequately typed
 151   Node* cmp_lt = new CmpINode(index, intcon(0));
 152   transform_later(cmp_lt);
 153   Node* bol_lt = new BoolNode(cmp_lt, BoolTest::lt);
 154   transform_later(bol_lt);
 155   generate_guard(ctrl, bol_lt, region, PROB_MIN);
 156 }
 157 
 158 void PhaseMacroExpand::generate_limit_guard(Node** ctrl, Node* offset, Node* subseq_length, Node* array_length, RegionNode* region) {
 159   if ((*ctrl)-&gt;is_top())
 160     return;                // already stopped
 161   bool zero_offset = _igvn.type(offset) == TypeInt::ZERO;
 162   if (zero_offset &amp;&amp; subseq_length-&gt;eqv_uncast(array_length))
 163     return;                // common case of whole-array copy
 164   Node* last = subseq_length;
 165   if (!zero_offset) {            // last += offset
 166     last = new AddINode(last, offset);
 167     transform_later(last);
 168   }
 169   Node* cmp_lt = new CmpUNode(array_length, last);
 170   transform_later(cmp_lt);
 171   Node* bol_lt = new BoolNode(cmp_lt, BoolTest::lt);
 172   transform_later(bol_lt);
 173   generate_guard(ctrl, bol_lt, region, PROB_MIN);
 174 }
 175 
 176 Node* PhaseMacroExpand::generate_nonpositive_guard(Node** ctrl, Node* index, bool never_negative) {
 177   if ((*ctrl)-&gt;is_top())  return NULL;
 178 
 179   if (_igvn.type(index)-&gt;higher_equal(TypeInt::POS1)) // [1,maxint]
 180     return NULL;                // index is already adequately typed
 181   Node* cmp_le = new CmpINode(index, intcon(0));
 182   transform_later(cmp_le);
 183   BoolTest::mask le_or_eq = (never_negative ? BoolTest::eq : BoolTest::le);
 184   Node* bol_le = new BoolNode(cmp_le, le_or_eq);
 185   transform_later(bol_le);
 186   Node* is_notp = generate_guard(ctrl, bol_le, NULL, PROB_MIN);
 187 
 188   return is_notp;
 189 }
 190 
 191 Node* PhaseMacroExpand::generate_flattened_array_guard(Node** ctrl, Node* mem, Node* obj_or_klass, RegionNode* region) {
 192   assert(FlatArrayFlatten, &quot;can never be flattened&quot;);
 193   return generate_array_guard(ctrl, mem, obj_or_klass, region, Klass::_lh_array_tag_vt_value);
 194 }
 195 
 196 Node* PhaseMacroExpand::generate_object_array_guard(Node** ctrl, Node* mem, Node* obj_or_klass, RegionNode* region) {
 197   return generate_array_guard(ctrl, mem, obj_or_klass, region, Klass::_lh_array_tag_obj_value);
 198 }
 199 
 200 Node* PhaseMacroExpand::generate_array_guard(Node** ctrl, Node* mem, Node* obj_or_klass, RegionNode* region, jint lh_con) {
 201   if ((*ctrl)-&gt;is_top())  return NULL;
 202 
 203   Node* kls = NULL;
 204   if (_igvn.type(obj_or_klass)-&gt;isa_oopptr()) {
 205     Node* k_adr = basic_plus_adr(obj_or_klass, oopDesc::klass_offset_in_bytes());
 206     kls = transform_later(LoadKlassNode::make(_igvn, NULL, C-&gt;immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));
 207   } else {
 208     assert(_igvn.type(obj_or_klass)-&gt;isa_klassptr(), &quot;what else?&quot;);
 209     kls = obj_or_klass;
 210   }
 211   Node* layout_val = make_load(NULL, mem, kls, in_bytes(Klass::layout_helper_offset()), TypeInt::INT, T_INT);
 212 
 213   layout_val = transform_later(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));
 214   Node* cmp = transform_later(new CmpINode(layout_val, intcon(lh_con)));
 215   Node* bol = transform_later(new BoolNode(cmp, BoolTest::eq));
 216 
 217   return generate_fair_guard(ctrl, bol, region);
 218 }
 219 
 220 void PhaseMacroExpand::finish_arraycopy_call(Node* call, Node** ctrl, MergeMemNode** mem, const TypePtr* adr_type) {
 221   transform_later(call);
 222 
 223   *ctrl = new ProjNode(call,TypeFunc::Control);
 224   transform_later(*ctrl);
 225   Node* newmem = new ProjNode(call, TypeFunc::Memory);
 226   transform_later(newmem);
 227 
 228   uint alias_idx = C-&gt;get_alias_index(adr_type);
 229   if (alias_idx != Compile::AliasIdxBot) {
 230     *mem = MergeMemNode::make(*mem);
 231     (*mem)-&gt;set_memory_at(alias_idx, newmem);
 232   } else {
 233     *mem = MergeMemNode::make(newmem);
 234   }
 235   transform_later(*mem);
 236 }
 237 
 238 address PhaseMacroExpand::basictype2arraycopy(BasicType t,
 239                                               Node* src_offset,
 240                                               Node* dest_offset,
 241                                               bool disjoint_bases,
 242                                               const char* &amp;name,
 243                                               bool dest_uninitialized) {
 244   const TypeInt* src_offset_inttype  = _igvn.find_int_type(src_offset);;
 245   const TypeInt* dest_offset_inttype = _igvn.find_int_type(dest_offset);;
 246 
 247   bool aligned = false;
 248   bool disjoint = disjoint_bases;
 249 
 250   // if the offsets are the same, we can treat the memory regions as
 251   // disjoint, because either the memory regions are in different arrays,
 252   // or they are identical (which we can treat as disjoint.)  We can also
 253   // treat a copy with a destination index  less that the source index
 254   // as disjoint since a low-&gt;high copy will work correctly in this case.
 255   if (src_offset_inttype != NULL &amp;&amp; src_offset_inttype-&gt;is_con() &amp;&amp;
 256       dest_offset_inttype != NULL &amp;&amp; dest_offset_inttype-&gt;is_con()) {
 257     // both indices are constants
 258     int s_offs = src_offset_inttype-&gt;get_con();
 259     int d_offs = dest_offset_inttype-&gt;get_con();
 260     int element_size = type2aelembytes(t);
 261     aligned = ((arrayOopDesc::base_offset_in_bytes(t) + s_offs * element_size) % HeapWordSize == 0) &amp;&amp;
 262               ((arrayOopDesc::base_offset_in_bytes(t) + d_offs * element_size) % HeapWordSize == 0);
 263     if (s_offs &gt;= d_offs)  disjoint = true;
 264   } else if (src_offset == dest_offset &amp;&amp; src_offset != NULL) {
 265     // This can occur if the offsets are identical non-constants.
 266     disjoint = true;
 267   }
 268 
 269   return StubRoutines::select_arraycopy_function(t, aligned, disjoint, name, dest_uninitialized);
 270 }
 271 
 272 bool PhaseMacroExpand::can_try_zeroing_elimination(AllocateArrayNode* alloc,
 273                                                    Node* src,
 274                                                    Node* dest) const {
 275   const TypeAryPtr* top_dest = _igvn.type(dest)-&gt;isa_aryptr();
 276 
 277   if (top_dest != NULL) {
 278     if (top_dest-&gt;klass() == NULL) {
 279       return false;
 280     }
 281   }
 282 
 283   return ReduceBulkZeroing
 284     &amp;&amp; !(UseTLAB &amp;&amp; ZeroTLAB) // pointless if already zeroed
 285     &amp;&amp; !src-&gt;eqv_uncast(dest)
 286     &amp;&amp; alloc != NULL
 287     &amp;&amp; _igvn.find_int_con(alloc-&gt;in(AllocateNode::ALength), 1) &gt; 0
 288     &amp;&amp; alloc-&gt;maybe_set_complete(&amp;_igvn);
 289 }
 290 
 291 #define XTOP LP64_ONLY(COMMA top())
 292 
 293 // Generate an optimized call to arraycopy.
 294 // Caller must guard against non-arrays.
 295 // Caller must determine a common array basic-type for both arrays.
 296 // Caller must validate offsets against array bounds.
 297 // The slow_region has already collected guard failure paths
 298 // (such as out of bounds length or non-conformable array types).
 299 // The generated code has this shape, in general:
 300 //
 301 //     if (length == 0)  return   // via zero_path
 302 //     slowval = -1
 303 //     if (types unknown) {
 304 //       slowval = call generic copy loop
 305 //       if (slowval == 0)  return  // via checked_path
 306 //     } else if (indexes in bounds) {
 307 //       if ((is object array) &amp;&amp; !(array type check)) {
 308 //         slowval = call checked copy loop
 309 //         if (slowval == 0)  return  // via checked_path
 310 //       } else {
 311 //         call bulk copy loop
 312 //         return  // via fast_path
 313 //       }
 314 //     }
 315 //     // adjust params for remaining work:
 316 //     if (slowval != -1) {
 317 //       n = -1^slowval; src_offset += n; dest_offset += n; length -= n
 318 //     }
 319 //   slow_region:
 320 //     call slow arraycopy(src, src_offset, dest, dest_offset, length)
 321 //     return  // via slow_call_path
 322 //
 323 // This routine is used from several intrinsics:  System.arraycopy,
 324 // Object.clone (the array subcase), and Arrays.copyOf[Range].
 325 //
 326 Node* PhaseMacroExpand::generate_arraycopy(ArrayCopyNode *ac, AllocateArrayNode* alloc,
 327                                            Node** ctrl, MergeMemNode* mem, Node** io,
 328                                            const TypePtr* adr_type,
 329                                            BasicType basic_elem_type,
 330                                            Node* src,  Node* src_offset,
 331                                            Node* dest, Node* dest_offset,
 332                                            Node* copy_length,
 333                                            Node* dest_length,
 334                                            bool disjoint_bases,
 335                                            bool length_never_negative,
 336                                            RegionNode* slow_region) {
 337   if (slow_region == NULL) {
 338     slow_region = new RegionNode(1);
 339     transform_later(slow_region);
 340   }
 341 
 342   bool  dest_uninitialized = false;
 343   Node* default_value = NULL;
 344   Node* raw_default_value = NULL;
 345 
 346   // See if this is the initialization of a newly-allocated array.
 347   // If so, we will take responsibility here for initializing it to zero.
 348   // (Note:  Because tightly_coupled_allocation performs checks on the
 349   // out-edges of the dest, we need to avoid making derived pointers
 350   // from it until we have checked its uses.)
 351   if (can_try_zeroing_elimination(alloc, src, dest) &amp;&amp;
 352       basic_elem_type != T_CONFLICT /* avoid corner case */) {
 353     // &quot;You break it, you buy it.&quot;
 354     InitializeNode* init = alloc-&gt;initialization();
 355     assert(init-&gt;is_complete(), &quot;we just did this&quot;);
 356     init-&gt;set_complete_with_arraycopy();
 357     assert(dest-&gt;is_CheckCastPP(), &quot;sanity&quot;);
 358     assert(dest-&gt;in(0)-&gt;in(0) == init, &quot;dest pinned&quot;);
 359     adr_type = TypeRawPtr::BOTTOM;  // all initializations are into raw memory
 360     // From this point on, every exit path is responsible for
 361     // initializing any non-copied parts of the object to zero.
 362     // Also, if this flag is set we make sure that arraycopy interacts properly
 363     // with G1, eliding pre-barriers. See CR 6627983.
 364     dest_uninitialized = true;
 365     default_value = alloc-&gt;in(AllocateNode::DefaultValue);
 366     raw_default_value = alloc-&gt;in(AllocateNode::RawDefaultValue);
 367   } else {
 368     // No zeroing elimination here.
 369     alloc             = NULL;
 370   }
 371 
 372   uint alias_idx = C-&gt;get_alias_index(adr_type);
 373 
 374   // Results are placed here:
 375   enum { fast_path        = 1,  // normal void-returning assembly stub
 376          checked_path     = 2,  // special assembly stub with cleanup
 377          slow_call_path   = 3,  // something went wrong; call the VM
 378          zero_path        = 4,  // bypass when length of copy is zero
 379          bcopy_path       = 5,  // copy primitive array by 64-bit blocks
 380          PATH_LIMIT       = 6
 381   };
 382   RegionNode* result_region = new RegionNode(PATH_LIMIT);
 383   PhiNode*    result_i_o    = new PhiNode(result_region, Type::ABIO);
 384   PhiNode*    result_memory = new PhiNode(result_region, Type::MEMORY, adr_type);
 385   assert(adr_type != TypePtr::BOTTOM, &quot;must be RawMem or a T[] slice&quot;);
 386   transform_later(result_region);
 387   transform_later(result_i_o);
 388   transform_later(result_memory);
 389 
 390   // The slow_control path:
 391   Node* slow_control;
 392   Node* slow_i_o = *io;
 393   Node* slow_mem = mem-&gt;memory_at(alias_idx);
 394   DEBUG_ONLY(slow_control = (Node*) badAddress);
 395 
 396   // Checked control path:
 397   Node* checked_control = top();
 398   Node* checked_mem     = NULL;
 399   Node* checked_i_o     = NULL;
 400   Node* checked_value   = NULL;
 401 
 402   if (basic_elem_type == T_CONFLICT) {
 403     assert(!dest_uninitialized, &quot;&quot;);
 404     Node* cv = generate_generic_arraycopy(ctrl, &amp;mem,
 405                                           adr_type,
 406                                           src, src_offset, dest, dest_offset,
 407                                           copy_length, dest_uninitialized);
 408     if (cv == NULL)  cv = intcon(-1);  // failure (no stub available)
 409     checked_control = *ctrl;
 410     checked_i_o     = *io;
 411     checked_mem     = mem-&gt;memory_at(alias_idx);
 412     checked_value   = cv;
 413     *ctrl = top();
 414   }
 415 
 416   Node* not_pos = generate_nonpositive_guard(ctrl, copy_length, length_never_negative);
 417   if (not_pos != NULL) {
 418     Node* local_ctrl = not_pos, *local_io = *io;
 419     MergeMemNode* local_mem = MergeMemNode::make(mem);
 420     transform_later(local_mem);
 421 
 422     // (6) length must not be negative.
 423     if (!length_never_negative) {
 424       generate_negative_guard(&amp;local_ctrl, copy_length, slow_region);
 425     }
 426 
 427     // copy_length is 0.
 428     if (dest_uninitialized) {
 429       assert(!local_ctrl-&gt;is_top(), &quot;no ctrl?&quot;);
 430       if (copy_length-&gt;eqv_uncast(dest_length)
 431           || _igvn.find_int_con(dest_length, 1) &lt;= 0) {
 432         // There is no zeroing to do. No need for a secondary raw memory barrier.
 433       } else {
 434         // Clear the whole thing since there are no source elements to copy.
 435         generate_clear_array(local_ctrl, local_mem,
 436                              adr_type, dest,
 437                              default_value, raw_default_value,
 438                              basic_elem_type,
 439                              intcon(0), NULL,
 440                              alloc-&gt;in(AllocateNode::AllocSize));
 441         // Use a secondary InitializeNode as raw memory barrier.
 442         // Currently it is needed only on this path since other
 443         // paths have stub or runtime calls as raw memory barriers.
 444         MemBarNode* mb = MemBarNode::make(C, Op_Initialize,
 445                                           Compile::AliasIdxRaw,
 446                                           top());
 447         transform_later(mb);
 448         mb-&gt;set_req(TypeFunc::Control,local_ctrl);
 449         mb-&gt;set_req(TypeFunc::Memory, local_mem-&gt;memory_at(Compile::AliasIdxRaw));
 450         local_ctrl = transform_later(new ProjNode(mb, TypeFunc::Control));
 451         local_mem-&gt;set_memory_at(Compile::AliasIdxRaw, transform_later(new ProjNode(mb, TypeFunc::Memory)));
 452 
 453         InitializeNode* init = mb-&gt;as_Initialize();
 454         init-&gt;set_complete(&amp;_igvn);  // (there is no corresponding AllocateNode)
 455       }
 456     }
 457 
 458     // Present the results of the fast call.
 459     result_region-&gt;init_req(zero_path, local_ctrl);
 460     result_i_o   -&gt;init_req(zero_path, local_io);
 461     result_memory-&gt;init_req(zero_path, local_mem-&gt;memory_at(alias_idx));
 462   }
 463 
 464   if (!(*ctrl)-&gt;is_top() &amp;&amp; dest_uninitialized) {
 465     // We have to initialize the *uncopied* part of the array to zero.
 466     // The copy destination is the slice dest[off..off+len].  The other slices
 467     // are dest_head = dest[0..off] and dest_tail = dest[off+len..dest.length].
 468     Node* dest_size   = alloc-&gt;in(AllocateNode::AllocSize);
 469     Node* dest_tail   = transform_later( new AddINode(dest_offset, copy_length));
 470 
 471     // If there is a head section that needs zeroing, do it now.
 472     if (_igvn.find_int_con(dest_offset, -1) != 0) {
 473       generate_clear_array(*ctrl, mem,
 474                            adr_type, dest,
 475                            default_value, raw_default_value,
 476                            basic_elem_type,
 477                            intcon(0), dest_offset,
 478                            NULL);
 479     }
 480 
 481     // Next, perform a dynamic check on the tail length.
 482     // It is often zero, and we can win big if we prove this.
 483     // There are two wins:  Avoid generating the ClearArray
 484     // with its attendant messy index arithmetic, and upgrade
 485     // the copy to a more hardware-friendly word size of 64 bits.
 486     Node* tail_ctl = NULL;
 487     if (!(*ctrl)-&gt;is_top() &amp;&amp; !dest_tail-&gt;eqv_uncast(dest_length)) {
 488       Node* cmp_lt   = transform_later( new CmpINode(dest_tail, dest_length) );
 489       Node* bol_lt   = transform_later( new BoolNode(cmp_lt, BoolTest::lt) );
 490       tail_ctl = generate_slow_guard(ctrl, bol_lt, NULL);
 491       assert(tail_ctl != NULL || !(*ctrl)-&gt;is_top(), &quot;must be an outcome&quot;);
 492     }
 493 
 494     // At this point, let&#39;s assume there is no tail.
 495     if (!(*ctrl)-&gt;is_top() &amp;&amp; alloc != NULL &amp;&amp; basic_elem_type != T_OBJECT) {
 496       // There is no tail.  Try an upgrade to a 64-bit copy.
 497       bool didit = false;
 498       {
 499         Node* local_ctrl = *ctrl, *local_io = *io;
 500         MergeMemNode* local_mem = MergeMemNode::make(mem);
 501         transform_later(local_mem);
 502 
 503         didit = generate_block_arraycopy(&amp;local_ctrl, &amp;local_mem, local_io,
 504                                          adr_type, basic_elem_type, alloc,
 505                                          src, src_offset, dest, dest_offset,
 506                                          dest_size, dest_uninitialized);
 507         if (didit) {
 508           // Present the results of the block-copying fast call.
 509           result_region-&gt;init_req(bcopy_path, local_ctrl);
 510           result_i_o   -&gt;init_req(bcopy_path, local_io);
 511           result_memory-&gt;init_req(bcopy_path, local_mem-&gt;memory_at(alias_idx));
 512         }
 513       }
 514       if (didit) {
 515         *ctrl = top();     // no regular fast path
 516       }
 517     }
 518 
 519     // Clear the tail, if any.
 520     if (tail_ctl != NULL) {
 521       Node* notail_ctl = (*ctrl)-&gt;is_top() ? NULL : *ctrl;
 522       *ctrl = tail_ctl;
 523       if (notail_ctl == NULL) {
 524         generate_clear_array(*ctrl, mem,
 525                              adr_type, dest,
 526                              default_value, raw_default_value,
 527                              basic_elem_type,
 528                              dest_tail, NULL,
 529                              dest_size);
 530       } else {
 531         // Make a local merge.
 532         Node* done_ctl = transform_later(new RegionNode(3));
 533         Node* done_mem = transform_later(new PhiNode(done_ctl, Type::MEMORY, adr_type));
 534         done_ctl-&gt;init_req(1, notail_ctl);
 535         done_mem-&gt;init_req(1, mem-&gt;memory_at(alias_idx));
 536         generate_clear_array(*ctrl, mem,
 537                              adr_type, dest,
 538                              default_value, raw_default_value,
 539                              basic_elem_type,
 540                              dest_tail, NULL,
 541                              dest_size);
 542         done_ctl-&gt;init_req(2, *ctrl);
 543         done_mem-&gt;init_req(2, mem-&gt;memory_at(alias_idx));
 544         *ctrl = done_ctl;
 545         mem-&gt;set_memory_at(alias_idx, done_mem);
 546       }
 547     }
 548   }
 549 
 550   BasicType copy_type = basic_elem_type;
 551   assert(basic_elem_type != T_ARRAY, &quot;caller must fix this&quot;);
 552   if (!(*ctrl)-&gt;is_top() &amp;&amp; copy_type == T_OBJECT) {
 553     // If src and dest have compatible element types, we can copy bits.
 554     // Types S[] and D[] are compatible if D is a supertype of S.
 555     //
 556     // If they are not, we will use checked_oop_disjoint_arraycopy,
 557     // which performs a fast optimistic per-oop check, and backs off
 558     // further to JVM_ArrayCopy on the first per-oop check that fails.
 559     // (Actually, we don&#39;t move raw bits only; the GC requires card marks.)
 560 
 561     // We don&#39;t need a subtype check for validated copies and Object[].clone()
 562     bool skip_subtype_check = ac-&gt;is_arraycopy_validated() || ac-&gt;is_copyof_validated() ||
 563                               ac-&gt;is_copyofrange_validated() || ac-&gt;is_clone_oop_array();
 564     if (!skip_subtype_check) {
 565       // Get the klass* for both src and dest
 566       Node* src_klass  = ac-&gt;in(ArrayCopyNode::SrcKlass);
 567       Node* dest_klass = ac-&gt;in(ArrayCopyNode::DestKlass);
 568 
 569       assert(src_klass != NULL &amp;&amp; dest_klass != NULL, &quot;should have klasses&quot;);
 570 
 571       // Generate the subtype check.
 572       // This might fold up statically, or then again it might not.
 573       //
 574       // Non-static example:  Copying List&lt;String&gt;.elements to a new String[].
 575       // The backing store for a List&lt;String&gt; is always an Object[],
 576       // but its elements are always type String, if the generic types
 577       // are correct at the source level.
 578       //
 579       // Test S[] against D[], not S against D, because (probably)
 580       // the secondary supertype cache is less busy for S[] than S.
 581       // This usually only matters when D is an interface.
 582       Node* not_subtype_ctrl = Phase::gen_subtype_check(src_klass, dest_klass, ctrl, mem, _igvn);
 583       // Plug failing path into checked_oop_disjoint_arraycopy
 584       if (not_subtype_ctrl != top()) {
 585         Node* local_ctrl = not_subtype_ctrl;
 586         MergeMemNode* local_mem = MergeMemNode::make(mem);
 587         transform_later(local_mem);
 588 
 589         // (At this point we can assume disjoint_bases, since types differ.)
 590         int ek_offset = in_bytes(ObjArrayKlass::element_klass_offset());
 591         Node* p1 = basic_plus_adr(dest_klass, ek_offset);
 592         Node* n1 = LoadKlassNode::make(_igvn, NULL, C-&gt;immutable_memory(), p1, TypeRawPtr::BOTTOM);
 593         Node* dest_elem_klass = transform_later(n1);
 594         Node* cv = generate_checkcast_arraycopy(&amp;local_ctrl, &amp;local_mem,
 595                                                 adr_type,
 596                                                 dest_elem_klass,
 597                                                 src, src_offset, dest, dest_offset,
 598                                                 ConvI2X(copy_length), dest_uninitialized);
 599         if (cv == NULL)  cv = intcon(-1);  // failure (no stub available)
 600         checked_control = local_ctrl;
 601         checked_i_o     = *io;
 602         checked_mem     = local_mem-&gt;memory_at(alias_idx);
 603         checked_value   = cv;
 604       }
 605     }
 606     // At this point we know we do not need type checks on oop stores.
 607 
 608     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 609     if (!bs-&gt;array_copy_requires_gc_barriers(alloc != NULL, copy_type, false, BarrierSetC2::Expansion)) {
 610       // If we do not need gc barriers, copy using the jint or jlong stub.
 611       copy_type = LP64_ONLY(UseCompressedOops ? T_INT : T_LONG) NOT_LP64(T_INT);
 612       assert(type2aelembytes(basic_elem_type) == type2aelembytes(copy_type),
 613              &quot;sizes agree&quot;);
 614     }
 615   }
 616 
 617   if (!(*ctrl)-&gt;is_top()) {
 618     // Generate the fast path, if possible.
 619     Node* local_ctrl = *ctrl;
 620     MergeMemNode* local_mem = MergeMemNode::make(mem);
 621     transform_later(local_mem);
 622 
 623     generate_unchecked_arraycopy(&amp;local_ctrl, &amp;local_mem,
 624                                  adr_type, copy_type, disjoint_bases,
 625                                  src, src_offset, dest, dest_offset,
 626                                  ConvI2X(copy_length), dest_uninitialized);
 627 
 628     // Present the results of the fast call.
 629     result_region-&gt;init_req(fast_path, local_ctrl);
 630     result_i_o   -&gt;init_req(fast_path, *io);
 631     result_memory-&gt;init_req(fast_path, local_mem-&gt;memory_at(alias_idx));
 632   }
 633 
 634   // Here are all the slow paths up to this point, in one bundle:
 635   assert(slow_region != NULL, &quot;allocated on entry&quot;);
 636   slow_control = slow_region;
 637   DEBUG_ONLY(slow_region = (RegionNode*)badAddress);
 638 
 639   *ctrl = checked_control;
 640   if (!(*ctrl)-&gt;is_top()) {
 641     // Clean up after the checked call.
 642     // The returned value is either 0 or -1^K,
 643     // where K = number of partially transferred array elements.
 644     Node* cmp = new CmpINode(checked_value, intcon(0));
 645     transform_later(cmp);
 646     Node* bol = new BoolNode(cmp, BoolTest::eq);
 647     transform_later(bol);
 648     IfNode* iff = new IfNode(*ctrl, bol, PROB_MAX, COUNT_UNKNOWN);
 649     transform_later(iff);
 650 
 651     // If it is 0, we are done, so transfer to the end.
 652     Node* checks_done = new IfTrueNode(iff);
 653     transform_later(checks_done);
 654     result_region-&gt;init_req(checked_path, checks_done);
 655     result_i_o   -&gt;init_req(checked_path, checked_i_o);
 656     result_memory-&gt;init_req(checked_path, checked_mem);
 657 
 658     // If it is not zero, merge into the slow call.
 659     *ctrl = new IfFalseNode(iff);
 660     transform_later(*ctrl);
 661     RegionNode* slow_reg2 = new RegionNode(3);
 662     PhiNode*    slow_i_o2 = new PhiNode(slow_reg2, Type::ABIO);
 663     PhiNode*    slow_mem2 = new PhiNode(slow_reg2, Type::MEMORY, adr_type);
 664     transform_later(slow_reg2);
 665     transform_later(slow_i_o2);
 666     transform_later(slow_mem2);
 667     slow_reg2  -&gt;init_req(1, slow_control);
 668     slow_i_o2  -&gt;init_req(1, slow_i_o);
 669     slow_mem2  -&gt;init_req(1, slow_mem);
 670     slow_reg2  -&gt;init_req(2, *ctrl);
 671     slow_i_o2  -&gt;init_req(2, checked_i_o);
 672     slow_mem2  -&gt;init_req(2, checked_mem);
 673 
 674     slow_control = slow_reg2;
 675     slow_i_o     = slow_i_o2;
 676     slow_mem     = slow_mem2;
 677 
 678     if (alloc != NULL) {
 679       // We&#39;ll restart from the very beginning, after zeroing the whole thing.
 680       // This can cause double writes, but that&#39;s OK since dest is brand new.
 681       // So we ignore the low 31 bits of the value returned from the stub.
 682     } else {
 683       // We must continue the copy exactly where it failed, or else
 684       // another thread might see the wrong number of writes to dest.
 685       Node* checked_offset = new XorINode(checked_value, intcon(-1));
 686       Node* slow_offset    = new PhiNode(slow_reg2, TypeInt::INT);
 687       transform_later(checked_offset);
 688       transform_later(slow_offset);
 689       slow_offset-&gt;init_req(1, intcon(0));
 690       slow_offset-&gt;init_req(2, checked_offset);
 691 
 692       // Adjust the arguments by the conditionally incoming offset.
 693       Node* src_off_plus  = new AddINode(src_offset,  slow_offset);
 694       transform_later(src_off_plus);
 695       Node* dest_off_plus = new AddINode(dest_offset, slow_offset);
 696       transform_later(dest_off_plus);
 697       Node* length_minus  = new SubINode(copy_length, slow_offset);
 698       transform_later(length_minus);
 699 
 700       // Tweak the node variables to adjust the code produced below:
 701       src_offset  = src_off_plus;
 702       dest_offset = dest_off_plus;
 703       copy_length = length_minus;
 704     }
 705   }
 706   *ctrl = slow_control;
 707   if (!(*ctrl)-&gt;is_top()) {
 708     Node* local_ctrl = *ctrl, *local_io = slow_i_o;
 709     MergeMemNode* local_mem = MergeMemNode::make(mem);
 710     transform_later(local_mem);
 711 
 712     // Generate the slow path, if needed.
 713     local_mem-&gt;set_memory_at(alias_idx, slow_mem);
 714 
 715     if (dest_uninitialized) {
 716       generate_clear_array(local_ctrl, local_mem,
 717                            adr_type, dest,
 718                            default_value, raw_default_value,
 719                            basic_elem_type,
 720                            intcon(0), NULL,
 721                            alloc-&gt;in(AllocateNode::AllocSize));
 722     }
 723 
 724     local_mem = generate_slow_arraycopy(ac,
 725                                         &amp;local_ctrl, local_mem, &amp;local_io,
 726                                         adr_type,
 727                                         src, src_offset, dest, dest_offset,
 728                                         copy_length, /*dest_uninitialized*/false);
 729 
 730     result_region-&gt;init_req(slow_call_path, local_ctrl);
 731     result_i_o   -&gt;init_req(slow_call_path, local_io);
 732     result_memory-&gt;init_req(slow_call_path, local_mem-&gt;memory_at(alias_idx));
 733   } else {
 734     ShouldNotReachHere(); // no call to generate_slow_arraycopy:
 735                           // projections were not extracted
 736   }
 737 
 738   // Remove unused edges.
 739   for (uint i = 1; i &lt; result_region-&gt;req(); i++) {
 740     if (result_region-&gt;in(i) == NULL) {
 741       result_region-&gt;init_req(i, top());
 742     }
 743   }
 744 
 745   // Finished; return the combined state.
 746   *ctrl = result_region;
 747   *io = result_i_o;
 748   mem-&gt;set_memory_at(alias_idx, result_memory);
 749 
 750   // mem no longer guaranteed to stay a MergeMemNode
 751   Node* out_mem = mem;
 752   DEBUG_ONLY(mem = NULL);
 753 
 754   // The memory edges above are precise in order to model effects around
 755   // array copies accurately to allow value numbering of field loads around
 756   // arraycopy.  Such field loads, both before and after, are common in Java
 757   // collections and similar classes involving header/array data structures.
 758   //
 759   // But with low number of register or when some registers are used or killed
 760   // by arraycopy calls it causes registers spilling on stack. See 6544710.
 761   // The next memory barrier is added to avoid it. If the arraycopy can be
 762   // optimized away (which it can, sometimes) then we can manually remove
 763   // the membar also.
 764   //
 765   // Do not let reads from the cloned object float above the arraycopy.
 766   if (alloc != NULL &amp;&amp; !alloc-&gt;initialization()-&gt;does_not_escape()) {
 767     // Do not let stores that initialize this object be reordered with
 768     // a subsequent store that would make this object accessible by
 769     // other threads.
 770     insert_mem_bar(ctrl, &amp;out_mem, Op_MemBarStoreStore);
 771   } else if (InsertMemBarAfterArraycopy) {
 772     insert_mem_bar(ctrl, &amp;out_mem, Op_MemBarCPUOrder);
 773   } else if (adr_type == TypeRawPtr::BOTTOM) {
 774     // Do not let reads from the destination float above the arraycopy.
 775     // Since we cannot type the arrays, we don&#39;t know which slices
 776     // might be affected.  We could restrict this barrier only to those
 777     // memory slices which pertain to array elements--but don&#39;t bother.
 778     insert_mem_bar(ctrl, &amp;out_mem, Op_MemBarCPUOrder);
 779   }
 780 
 781   _igvn.replace_node(_memproj_fallthrough, out_mem);
 782   _igvn.replace_node(_ioproj_fallthrough, *io);
 783   _igvn.replace_node(_fallthroughcatchproj, *ctrl);
 784 
 785 #ifdef ASSERT
 786   const TypeOopPtr* dest_t = _igvn.type(dest)-&gt;is_oopptr();
 787   if (dest_t-&gt;is_known_instance()) {
 788     ArrayCopyNode* ac = NULL;
 789     assert(ArrayCopyNode::may_modify(dest_t, (*ctrl)-&gt;in(0)-&gt;as_MemBar(), &amp;_igvn, ac), &quot;dependency on arraycopy lost&quot;);
 790     assert(ac == NULL, &quot;no arraycopy anymore&quot;);
 791   }
 792 #endif
 793 
 794   return out_mem;
 795 }
 796 
 797 // Helper for initialization of arrays, creating a ClearArray.
 798 // It writes zero bits in [start..end), within the body of an array object.
 799 // The memory effects are all chained onto the &#39;adr_type&#39; alias category.
 800 //
 801 // Since the object is otherwise uninitialized, we are free
 802 // to put a little &quot;slop&quot; around the edges of the cleared area,
 803 // as long as it does not go back into the array&#39;s header,
 804 // or beyond the array end within the heap.
 805 //
 806 // The lower edge can be rounded down to the nearest jint and the
 807 // upper edge can be rounded up to the nearest MinObjAlignmentInBytes.
 808 //
 809 // Arguments:
 810 //   adr_type           memory slice where writes are generated
 811 //   dest               oop of the destination array
 812 //   basic_elem_type    element type of the destination
 813 //   slice_idx          array index of first element to store
 814 //   slice_len          number of elements to store (or NULL)
 815 //   dest_size          total size in bytes of the array object
 816 //
 817 // Exactly one of slice_len or dest_size must be non-NULL.
 818 // If dest_size is non-NULL, zeroing extends to the end of the object.
 819 // If slice_len is non-NULL, the slice_idx value must be a constant.
 820 void PhaseMacroExpand::generate_clear_array(Node* ctrl, MergeMemNode* merge_mem,
 821                                             const TypePtr* adr_type,
 822                                             Node* dest,
 823                                             Node* val,
 824                                             Node* raw_val,
 825                                             BasicType basic_elem_type,
 826                                             Node* slice_idx,
 827                                             Node* slice_len,
 828                                             Node* dest_size) {
 829   // one or the other but not both of slice_len and dest_size:
 830   assert((slice_len != NULL? 1: 0) + (dest_size != NULL? 1: 0) == 1, &quot;&quot;);
 831   if (slice_len == NULL)  slice_len = top();
 832   if (dest_size == NULL)  dest_size = top();
 833 
 834   uint alias_idx = C-&gt;get_alias_index(adr_type);
 835 
 836   // operate on this memory slice:
 837   Node* mem = merge_mem-&gt;memory_at(alias_idx); // memory slice to operate on
 838 
 839   // scaling and rounding of indexes:
 840   assert(basic_elem_type != T_INLINE_TYPE, &quot;should have been converted to a basic type copy&quot;);
 841   int scale = exact_log2(type2aelembytes(basic_elem_type));
 842   int abase = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
 843   int clear_low = (-1 &lt;&lt; scale) &amp; (BytesPerInt  - 1);
 844   int bump_bit  = (-1 &lt;&lt; scale) &amp; BytesPerInt;
 845 
 846   // determine constant starts and ends
 847   const intptr_t BIG_NEG = -128;
 848   assert(BIG_NEG + 2*abase &lt; 0, &quot;neg enough&quot;);
 849   intptr_t slice_idx_con = (intptr_t) _igvn.find_int_con(slice_idx, BIG_NEG);
 850   intptr_t slice_len_con = (intptr_t) _igvn.find_int_con(slice_len, BIG_NEG);
 851   if (slice_len_con == 0) {
 852     return;                     // nothing to do here
 853   }
 854   intptr_t start_con = (abase + (slice_idx_con &lt;&lt; scale)) &amp; ~clear_low;
 855   intptr_t end_con   = _igvn.find_intptr_t_con(dest_size, -1);
 856   if (slice_idx_con &gt;= 0 &amp;&amp; slice_len_con &gt;= 0) {
 857     assert(end_con &lt; 0, &quot;not two cons&quot;);
 858     end_con = align_up(abase + ((slice_idx_con + slice_len_con) &lt;&lt; scale),
 859                        BytesPerLong);
 860   }
 861 
 862   if (start_con &gt;= 0 &amp;&amp; end_con &gt;= 0) {
 863     // Constant start and end.  Simple.
 864     mem = ClearArrayNode::clear_memory(ctrl, mem, dest, val, raw_val,
 865                                        start_con, end_con, &amp;_igvn);
 866   } else if (start_con &gt;= 0 &amp;&amp; dest_size != top()) {
 867     // Constant start, pre-rounded end after the tail of the array.
 868     Node* end = dest_size;
 869     mem = ClearArrayNode::clear_memory(ctrl, mem, dest, val, raw_val,
 870                                        start_con, end, &amp;_igvn);
 871   } else if (start_con &gt;= 0 &amp;&amp; slice_len != top()) {
 872     // Constant start, non-constant end.  End needs rounding up.
 873     // End offset = round_up(abase + ((slice_idx_con + slice_len) &lt;&lt; scale), 8)
 874     intptr_t end_base  = abase + (slice_idx_con &lt;&lt; scale);
 875     int      end_round = (-1 &lt;&lt; scale) &amp; (BytesPerLong  - 1);
 876     Node*    end       = ConvI2X(slice_len);
 877     if (scale != 0)
 878       end = transform_later(new LShiftXNode(end, intcon(scale) ));
 879     end_base += end_round;
 880     end = transform_later(new AddXNode(end, MakeConX(end_base)) );
 881     end = transform_later(new AndXNode(end, MakeConX(~end_round)) );
 882     mem = ClearArrayNode::clear_memory(ctrl, mem, dest, val, raw_val,
 883                                        start_con, end, &amp;_igvn);
 884   } else if (start_con &lt; 0 &amp;&amp; dest_size != top()) {
 885     // Non-constant start, pre-rounded end after the tail of the array.
 886     // This is almost certainly a &quot;round-to-end&quot; operation.
 887     Node* start = slice_idx;
 888     start = ConvI2X(start);
 889     if (scale != 0)
 890       start = transform_later(new LShiftXNode( start, intcon(scale) ));
 891     start = transform_later(new AddXNode(start, MakeConX(abase)) );
 892     if ((bump_bit | clear_low) != 0) {
 893       int to_clear = (bump_bit | clear_low);
 894       // Align up mod 8, then store a jint zero unconditionally
 895       // just before the mod-8 boundary.
 896       if (((abase + bump_bit) &amp; ~to_clear) - bump_bit
 897           &lt; arrayOopDesc::length_offset_in_bytes() + BytesPerInt) {
 898         bump_bit = 0;
 899         assert((abase &amp; to_clear) == 0, &quot;array base must be long-aligned&quot;);
 900       } else {
 901         // Bump &#39;start&#39; up to (or past) the next jint boundary:
 902         start = transform_later( new AddXNode(start, MakeConX(bump_bit)) );
 903         assert((abase &amp; clear_low) == 0, &quot;array base must be int-aligned&quot;);
 904       }
 905       // Round bumped &#39;start&#39; down to jlong boundary in body of array.
 906       start = transform_later(new AndXNode(start, MakeConX(~to_clear)) );
 907       if (bump_bit != 0) {
 908         // Store a zero to the immediately preceding jint:
 909         Node* x1 = transform_later(new AddXNode(start, MakeConX(-bump_bit)) );
 910         Node* p1 = basic_plus_adr(dest, x1);
 911         if (val == NULL) {
 912           assert(raw_val == NULL, &quot;val may not be null&quot;);
 913           mem = StoreNode::make(_igvn, ctrl, mem, p1, adr_type, intcon(0), T_INT, MemNode::unordered);
 914         } else {
 915           assert(_igvn.type(val)-&gt;isa_narrowoop(), &quot;should be narrow oop&quot;);
 916           mem = new StoreNNode(ctrl, mem, p1, adr_type, val, MemNode::unordered);
 917         }
 918         mem = transform_later(mem);
 919       }
 920     }
 921     Node* end = dest_size; // pre-rounded
 922     mem = ClearArrayNode::clear_memory(ctrl, mem, dest, raw_val,
 923                                        start, end, &amp;_igvn);
 924   } else {
 925     // Non-constant start, unrounded non-constant end.
 926     // (Nobody zeroes a random midsection of an array using this routine.)
 927     ShouldNotReachHere();       // fix caller
 928   }
 929 
 930   // Done.
 931   merge_mem-&gt;set_memory_at(alias_idx, mem);
 932 }
 933 
 934 bool PhaseMacroExpand::generate_block_arraycopy(Node** ctrl, MergeMemNode** mem, Node* io,
 935                                                 const TypePtr* adr_type,
 936                                                 BasicType basic_elem_type,
 937                                                 AllocateNode* alloc,
 938                                                 Node* src,  Node* src_offset,
 939                                                 Node* dest, Node* dest_offset,
 940                                                 Node* dest_size, bool dest_uninitialized) {
 941   // See if there is an advantage from block transfer.
 942   int scale = exact_log2(type2aelembytes(basic_elem_type));
 943   if (scale &gt;= LogBytesPerLong)
 944     return false;               // it is already a block transfer
 945 
 946   // Look at the alignment of the starting offsets.
 947   int abase = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
 948 
 949   intptr_t src_off_con  = (intptr_t) _igvn.find_int_con(src_offset, -1);
 950   intptr_t dest_off_con = (intptr_t) _igvn.find_int_con(dest_offset, -1);
 951   if (src_off_con &lt; 0 || dest_off_con &lt; 0) {
 952     // At present, we can only understand constants.
 953     return false;
 954   }
 955 
 956   intptr_t src_off  = abase + (src_off_con  &lt;&lt; scale);
 957   intptr_t dest_off = abase + (dest_off_con &lt;&lt; scale);
 958 
 959   if (((src_off | dest_off) &amp; (BytesPerLong-1)) != 0) {
 960     // Non-aligned; too bad.
 961     // One more chance:  Pick off an initial 32-bit word.
 962     // This is a common case, since abase can be odd mod 8.
 963     if (((src_off | dest_off) &amp; (BytesPerLong-1)) == BytesPerInt &amp;&amp;
 964         ((src_off ^ dest_off) &amp; (BytesPerLong-1)) == 0) {
 965       Node* sptr = basic_plus_adr(src,  src_off);
 966       Node* dptr = basic_plus_adr(dest, dest_off);
 967       const TypePtr* s_adr_type = _igvn.type(sptr)-&gt;is_ptr();
 968       assert(s_adr_type-&gt;isa_aryptr(), &quot;impossible slice&quot;);
 969       uint s_alias_idx = C-&gt;get_alias_index(s_adr_type);
 970       uint d_alias_idx = C-&gt;get_alias_index(adr_type);
 971       bool is_mismatched = (basic_elem_type != T_INT);
 972       Node* sval = transform_later(
 973           LoadNode::make(_igvn, *ctrl, (*mem)-&gt;memory_at(s_alias_idx), sptr, s_adr_type,
 974                          TypeInt::INT, T_INT, MemNode::unordered, LoadNode::DependsOnlyOnTest,
 975                          false /*unaligned*/, is_mismatched));
 976       Node* st = transform_later(
 977           StoreNode::make(_igvn, *ctrl, (*mem)-&gt;memory_at(d_alias_idx), dptr, adr_type,
 978                           sval, T_INT, MemNode::unordered));
 979       if (is_mismatched) {
 980         st-&gt;as_Store()-&gt;set_mismatched_access();
 981       }
 982       (*mem)-&gt;set_memory_at(d_alias_idx, st);
 983       src_off += BytesPerInt;
 984       dest_off += BytesPerInt;
 985     } else {
 986       return false;
 987     }
 988   }
 989   assert(src_off % BytesPerLong == 0, &quot;&quot;);
 990   assert(dest_off % BytesPerLong == 0, &quot;&quot;);
 991 
 992   // Do this copy by giant steps.
 993   Node* sptr  = basic_plus_adr(src,  src_off);
 994   Node* dptr  = basic_plus_adr(dest, dest_off);
 995   Node* countx = dest_size;
 996   countx = transform_later(new SubXNode(countx, MakeConX(dest_off)));
 997   countx = transform_later(new URShiftXNode(countx, intcon(LogBytesPerLong)));
 998 
 999   bool disjoint_bases = true;   // since alloc != NULL
1000   generate_unchecked_arraycopy(ctrl, mem,
1001                                adr_type, T_LONG, disjoint_bases,
1002                                sptr, NULL, dptr, NULL, countx, dest_uninitialized);
1003 
1004   return true;
1005 }
1006 
1007 // Helper function; generates code for the slow case.
1008 // We make a call to a runtime method which emulates the native method,
1009 // but without the native wrapper overhead.
1010 MergeMemNode* PhaseMacroExpand::generate_slow_arraycopy(ArrayCopyNode *ac,
1011                                                         Node** ctrl, Node* mem, Node** io,
1012                                                         const TypePtr* adr_type,
1013                                                         Node* src,  Node* src_offset,
1014                                                         Node* dest, Node* dest_offset,
1015                                                         Node* copy_length, bool dest_uninitialized) {
1016   assert(!dest_uninitialized, &quot;Invariant&quot;);
1017 
1018   const TypeFunc* call_type = OptoRuntime::slow_arraycopy_Type();
1019   CallNode* call = new CallStaticJavaNode(call_type, OptoRuntime::slow_arraycopy_Java(),
1020                                           &quot;slow_arraycopy&quot;,
1021                                           ac-&gt;jvms()-&gt;bci(), TypePtr::BOTTOM);
1022 
1023   call-&gt;init_req(TypeFunc::Control, *ctrl);
1024   call-&gt;init_req(TypeFunc::I_O    , *io);
1025   call-&gt;init_req(TypeFunc::Memory , mem);
1026   call-&gt;init_req(TypeFunc::ReturnAdr, top());
1027   call-&gt;init_req(TypeFunc::FramePtr, top());
1028   call-&gt;init_req(TypeFunc::Parms+0, src);
1029   call-&gt;init_req(TypeFunc::Parms+1, src_offset);
1030   call-&gt;init_req(TypeFunc::Parms+2, dest);
1031   call-&gt;init_req(TypeFunc::Parms+3, dest_offset);
1032   call-&gt;init_req(TypeFunc::Parms+4, copy_length);
1033   call-&gt;copy_call_debug_info(&amp;_igvn, ac);
1034 
1035   call-&gt;set_cnt(PROB_UNLIKELY_MAG(4));  // Same effect as RC_UNCOMMON.
1036   _igvn.replace_node(ac, call);
1037   transform_later(call);
1038 
1039   extract_call_projections(call);
1040   *ctrl = _fallthroughcatchproj-&gt;clone();
1041   transform_later(*ctrl);
1042 
1043   Node* m = _memproj_fallthrough-&gt;clone();
1044   transform_later(m);
1045 
1046   uint alias_idx = C-&gt;get_alias_index(adr_type);
1047   MergeMemNode* out_mem;
1048   if (alias_idx != Compile::AliasIdxBot) {
1049     out_mem = MergeMemNode::make(mem);
1050     out_mem-&gt;set_memory_at(alias_idx, m);
1051   } else {
1052     out_mem = MergeMemNode::make(m);
1053   }
1054   transform_later(out_mem);
1055 
1056   *io = _ioproj_fallthrough-&gt;clone();
1057   transform_later(*io);
1058 
1059   return out_mem;
1060 }
1061 
1062 // Helper function; generates code for cases requiring runtime checks.
1063 Node* PhaseMacroExpand::generate_checkcast_arraycopy(Node** ctrl, MergeMemNode** mem,
1064                                                      const TypePtr* adr_type,
1065                                                      Node* dest_elem_klass,
1066                                                      Node* src,  Node* src_offset,
1067                                                      Node* dest, Node* dest_offset,
1068                                                      Node* copy_length, bool dest_uninitialized) {
1069   if ((*ctrl)-&gt;is_top())  return NULL;
1070 
1071   address copyfunc_addr = StubRoutines::checkcast_arraycopy(dest_uninitialized);
1072   if (copyfunc_addr == NULL) { // Stub was not generated, go slow path.
1073     return NULL;
1074   }
1075 
1076   // Pick out the parameters required to perform a store-check
1077   // for the target array.  This is an optimistic check.  It will
1078   // look in each non-null element&#39;s class, at the desired klass&#39;s
1079   // super_check_offset, for the desired klass.
1080   int sco_offset = in_bytes(Klass::super_check_offset_offset());
1081   Node* p3 = basic_plus_adr(dest_elem_klass, sco_offset);
1082   Node* n3 = new LoadINode(NULL, *mem /*memory(p3)*/, p3, _igvn.type(p3)-&gt;is_ptr(), TypeInt::INT, MemNode::unordered);
1083   Node* check_offset = ConvI2X(transform_later(n3));
1084   Node* check_value  = dest_elem_klass;
1085 
1086   Node* src_start  = array_element_address(src,  src_offset,  T_OBJECT);
1087   Node* dest_start = array_element_address(dest, dest_offset, T_OBJECT);
1088 
1089   const TypeFunc* call_type = OptoRuntime::checkcast_arraycopy_Type();
1090   Node* call = make_leaf_call(*ctrl, *mem, call_type, copyfunc_addr, &quot;checkcast_arraycopy&quot;, adr_type,
1091                               src_start, dest_start, copy_length XTOP, check_offset XTOP, check_value);
1092 
1093   finish_arraycopy_call(call, ctrl, mem, adr_type);
1094 
1095   Node* proj =  new ProjNode(call, TypeFunc::Parms);
1096   transform_later(proj);
1097 
1098   return proj;
1099 }
1100 
1101 // Helper function; generates code for cases requiring runtime checks.
1102 Node* PhaseMacroExpand::generate_generic_arraycopy(Node** ctrl, MergeMemNode** mem,
1103                                                    const TypePtr* adr_type,
1104                                                    Node* src,  Node* src_offset,
1105                                                    Node* dest, Node* dest_offset,
1106                                                    Node* copy_length, bool dest_uninitialized) {
1107   if ((*ctrl)-&gt;is_top()) return NULL;
1108   assert(!dest_uninitialized, &quot;Invariant&quot;);
1109 
1110   address copyfunc_addr = StubRoutines::generic_arraycopy();
1111   if (copyfunc_addr == NULL) { // Stub was not generated, go slow path.
1112     return NULL;
1113   }
1114 
1115   const TypeFunc* call_type = OptoRuntime::generic_arraycopy_Type();
1116   Node* call = make_leaf_call(*ctrl, *mem, call_type, copyfunc_addr, &quot;generic_arraycopy&quot;, adr_type,
1117                               src, src_offset, dest, dest_offset, copy_length);
1118 
1119   finish_arraycopy_call(call, ctrl, mem, adr_type);
1120 
1121   Node* proj =  new ProjNode(call, TypeFunc::Parms);
1122   transform_later(proj);
1123 
1124   return proj;
1125 }
1126 
1127 // Helper function; generates the fast out-of-line call to an arraycopy stub.
1128 void PhaseMacroExpand::generate_unchecked_arraycopy(Node** ctrl, MergeMemNode** mem,
1129                                                     const TypePtr* adr_type,
1130                                                     BasicType basic_elem_type,
1131                                                     bool disjoint_bases,
1132                                                     Node* src,  Node* src_offset,
1133                                                     Node* dest, Node* dest_offset,
1134                                                     Node* copy_length, bool dest_uninitialized) {
1135   if ((*ctrl)-&gt;is_top()) return;
1136 
1137   Node* src_start  = src;
1138   Node* dest_start = dest;
1139   if (src_offset != NULL || dest_offset != NULL) {
1140     src_start =  array_element_address(src, src_offset, basic_elem_type);
1141     dest_start = array_element_address(dest, dest_offset, basic_elem_type);
1142   }
1143 
1144   // Figure out which arraycopy runtime method to call.
1145   const char* copyfunc_name = &quot;arraycopy&quot;;
1146   address     copyfunc_addr =
1147       basictype2arraycopy(basic_elem_type, src_offset, dest_offset,
1148                           disjoint_bases, copyfunc_name, dest_uninitialized);
1149 
1150   const TypeFunc* call_type = OptoRuntime::fast_arraycopy_Type();
1151   Node* call = make_leaf_call(*ctrl, *mem, call_type, copyfunc_addr, copyfunc_name, adr_type,
1152                               src_start, dest_start, copy_length XTOP);
1153 
1154   finish_arraycopy_call(call, ctrl, mem, adr_type);
1155 }
1156 
1157 const TypePtr* PhaseMacroExpand::adjust_parameters_for_vt(const TypeAryPtr* top_dest, Node*&amp; src_offset,
1158                                                           Node*&amp; dest_offset, Node*&amp; length, BasicType&amp; dest_elem,
1159                                                           Node*&amp; dest_length) {
1160   assert(top_dest-&gt;klass()-&gt;is_value_array_klass(), &quot;inconsistent&quot;);
1161   int elem_size = ((ciValueArrayKlass*)top_dest-&gt;klass())-&gt;element_byte_size();
1162   if (elem_size &gt;= 8) {
1163     if (elem_size &gt; 8) {
1164       // treat as array of long but scale length, src offset and dest offset
1165       assert((elem_size % 8) == 0, &quot;not a power of 2?&quot;);
1166       int factor = elem_size / 8;
1167       length = transform_later(new MulINode(length, intcon(factor)));
1168       src_offset = transform_later(new MulINode(src_offset, intcon(factor)));
1169       dest_offset = transform_later(new MulINode(dest_offset, intcon(factor)));
1170       if (dest_length != NULL) {
1171         dest_length = transform_later(new MulINode(dest_length, intcon(factor)));
1172       }
1173       elem_size = 8;
1174     }
1175     dest_elem = T_LONG;
1176   } else if (elem_size == 4) {
1177     dest_elem = T_INT;
1178   } else if (elem_size == 2) {
1179     dest_elem = T_CHAR;
1180   } else if (elem_size == 1) {
1181     dest_elem = T_BYTE;
1182   } else {
1183     ShouldNotReachHere();
1184   }
1185   return TypeRawPtr::BOTTOM;
1186 }
1187 
1188 void PhaseMacroExpand::expand_arraycopy_node(ArrayCopyNode *ac) {
1189   Node* ctrl = ac-&gt;in(TypeFunc::Control);
1190   Node* io = ac-&gt;in(TypeFunc::I_O);
1191   Node* src = ac-&gt;in(ArrayCopyNode::Src);
1192   Node* src_offset = ac-&gt;in(ArrayCopyNode::SrcPos);
1193   Node* dest = ac-&gt;in(ArrayCopyNode::Dest);
1194   Node* dest_offset = ac-&gt;in(ArrayCopyNode::DestPos);
1195   Node* length = ac-&gt;in(ArrayCopyNode::Length);
1196   MergeMemNode* merge_mem = NULL;
1197 
1198   if (ac-&gt;is_clonebasic()) {
1199     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1200     bs-&gt;clone_at_expansion(this, ac);
1201     return;
1202   } else if (ac-&gt;is_copyof() || ac-&gt;is_copyofrange() || ac-&gt;is_clone_oop_array()) {
1203     const Type* dest_type = _igvn.type(dest);
1204     const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
1205     BasicType dest_elem = T_OBJECT;
1206     if (top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL) {
1207       dest_elem = top_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
1208     }
1209     if (dest_elem == T_ARRAY || (dest_elem == T_INLINE_TYPE &amp;&amp; top_dest-&gt;klass()-&gt;is_obj_array_klass())) {
1210       dest_elem = T_OBJECT;
1211     }
1212 
1213     Node* mem = ac-&gt;in(TypeFunc::Memory);
1214     merge_mem = MergeMemNode::make(mem);
1215     transform_later(merge_mem);
1216 
1217     AllocateArrayNode* alloc = NULL;
1218     if (ac-&gt;is_alloc_tightly_coupled()) {
1219       alloc = AllocateArrayNode::Ideal_array_allocation(dest, &amp;_igvn);
1220       assert(alloc != NULL, &quot;expect alloc&quot;);
1221     }
1222     assert(dest_elem != T_INLINE_TYPE || alloc != NULL, &quot;unsupported&quot;);
1223     Node* dest_length = (alloc != NULL) ? alloc-&gt;in(AllocateNode::ALength) : NULL;
1224 
1225     const TypePtr* adr_type = NULL;
1226     if (dest_elem == T_INLINE_TYPE) {
1227       adr_type = adjust_parameters_for_vt(top_dest, src_offset, dest_offset, length, dest_elem, dest_length);
1228     } else {
1229       adr_type = dest_type-&gt;is_oopptr()-&gt;add_offset(Type::OffsetBot);
1230       if (ac-&gt;_dest_type != TypeOopPtr::BOTTOM) {
1231         adr_type = ac-&gt;_dest_type-&gt;add_offset(Type::OffsetBot)-&gt;is_ptr();
1232       }
1233       if (ac-&gt;_src_type != ac-&gt;_dest_type) {
1234         adr_type = TypeRawPtr::BOTTOM;
1235       }
1236     }
1237     generate_arraycopy(ac, alloc, &amp;ctrl, merge_mem, &amp;io,
1238                        adr_type, dest_elem,
1239                        src, src_offset, dest, dest_offset, length,
1240                        dest_length,
1241                        true, !ac-&gt;is_copyofrange());
1242 
1243     return;
1244   }
1245 
1246   AllocateArrayNode* alloc = NULL;
1247   if (ac-&gt;is_alloc_tightly_coupled()) {
1248     alloc = AllocateArrayNode::Ideal_array_allocation(dest, &amp;_igvn);
1249     assert(alloc != NULL, &quot;expect alloc&quot;);
1250   }
1251 
1252   assert(ac-&gt;is_arraycopy() || ac-&gt;is_arraycopy_validated(), &quot;should be an arraycopy&quot;);
1253 
1254   // Compile time checks.  If any of these checks cannot be verified at compile time,
1255   // we do not make a fast path for this call.  Instead, we let the call remain as it
1256   // is.  The checks we choose to mandate at compile time are:
1257   //
1258   // (1) src and dest are arrays.
1259   const Type* src_type = src-&gt;Value(&amp;_igvn);
1260   const Type* dest_type = dest-&gt;Value(&amp;_igvn);
1261   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
1262   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
1263 
1264   BasicType src_elem = T_CONFLICT;
1265   BasicType dest_elem = T_CONFLICT;
1266 
1267   if (top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL) {
1268     dest_elem = top_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
1269   }
1270   if (top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL) {
1271     src_elem = top_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
1272   }
1273   if (src_elem == T_ARRAY) {
1274     src_elem = T_OBJECT;
1275   } else if (src_elem == T_INLINE_TYPE &amp;&amp; top_src-&gt;klass()-&gt;is_obj_array_klass()) {
1276     if (top_src-&gt;klass_is_exact()) {
1277       src_elem = T_OBJECT;
1278     } else {
1279       assert(!top_src-&gt;klass()-&gt;is_valuetype(), &quot;klass should be exact&quot;);
1280       src_elem = T_CONFLICT; // either flattened or not
1281     }
1282   }
1283   if (dest_elem == T_ARRAY) {
1284     dest_elem = T_OBJECT;
1285   } else if (dest_elem == T_INLINE_TYPE &amp;&amp; top_dest-&gt;klass()-&gt;is_obj_array_klass()) {
1286     if (top_dest-&gt;klass_is_exact()) {
1287       dest_elem = T_OBJECT;
1288     } else {
1289       assert(!top_dest-&gt;klass()-&gt;is_valuetype(), &quot;klass should be exact&quot;);
1290       dest_elem = T_CONFLICT; // either flattened or not
1291     }
1292   }
1293 
1294   if (ac-&gt;is_arraycopy_validated() &amp;&amp;
1295       dest_elem != T_CONFLICT &amp;&amp;
1296       src_elem == T_CONFLICT) {
1297     src_elem = dest_elem;
1298   }
1299 
1300   if (src_elem == T_CONFLICT || dest_elem == T_CONFLICT) {
1301     // Conservatively insert a memory barrier on all memory slices.
1302     // Do not let writes into the source float below the arraycopy.
1303     {
1304       Node* mem = ac-&gt;in(TypeFunc::Memory);
1305       insert_mem_bar(&amp;ctrl, &amp;mem, Op_MemBarCPUOrder);
1306 
1307       merge_mem = MergeMemNode::make(mem);
1308       transform_later(merge_mem);
1309     }
1310 
1311     RegionNode* slow_region = new RegionNode(1);
1312     transform_later(slow_region);
1313 
1314     if (FlatArrayFlatten &amp;&amp; (top_dest == NULL || !top_dest-&gt;is_not_flat())) {
1315       generate_flattened_array_guard(&amp;ctrl, merge_mem, dest, slow_region);
1316     }
1317 
1318     // Call StubRoutines::generic_arraycopy stub.
1319     Node* mem = generate_arraycopy(ac, NULL, &amp;ctrl, merge_mem, &amp;io,
1320                                    TypeRawPtr::BOTTOM, T_CONFLICT,
1321                                    src, src_offset, dest, dest_offset, length,
1322                                    NULL,
1323                                    // If a  negative length guard was generated for the ArrayCopyNode,
1324                                    // the length of the array can never be negative.
1325                                    false, ac-&gt;has_negative_length_guard(),
1326                                    slow_region);
1327 
1328     return;
1329   }
1330 
1331   assert(!ac-&gt;is_arraycopy_validated() || (src_elem == dest_elem &amp;&amp; dest_elem != T_VOID), &quot;validated but different basic types&quot;);
1332 
1333   // (2) src and dest arrays must have elements of the same BasicType
1334   // Figure out the size and type of the elements we will be copying.
1335   //
1336   // We have no stub to copy flattened value type arrays with oop
1337   // fields if we need to emit write barriers.
1338   //
1339   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1340   if (src_elem != dest_elem || dest_elem == T_VOID) {
1341     // The component types are not the same or are not recognized.  Punt.
1342     // (But, avoid the native method wrapper to JVM_ArrayCopy.)
1343     {
1344       Node* mem = ac-&gt;in(TypeFunc::Memory);
1345       merge_mem = generate_slow_arraycopy(ac, &amp;ctrl, mem, &amp;io, TypePtr::BOTTOM, src, src_offset, dest, dest_offset, length, false);
1346     }
1347 
1348     _igvn.replace_node(_memproj_fallthrough, merge_mem);
1349     _igvn.replace_node(_ioproj_fallthrough, io);
1350     _igvn.replace_node(_fallthroughcatchproj, ctrl);
1351     return;
1352   }
1353 
1354   //---------------------------------------------------------------------------
1355   // We will make a fast path for this call to arraycopy.
1356 
1357   // We have the following tests left to perform:
1358   //
1359   // (3) src and dest must not be null.
1360   // (4) src_offset must not be negative.
1361   // (5) dest_offset must not be negative.
1362   // (6) length must not be negative.
1363   // (7) src_offset + length must not exceed length of src.
1364   // (8) dest_offset + length must not exceed length of dest.
1365   // (9) each element of an oop array must be assignable
1366 
1367   Node* mem = ac-&gt;in(TypeFunc::Memory);
1368   if (dest_elem == T_INLINE_TYPE) {
1369     // copy modifies more than 1 slice
1370     insert_mem_bar(&amp;ctrl, &amp;mem, Op_MemBarCPUOrder);
1371   }
1372 
1373   merge_mem = MergeMemNode::make(mem);
1374   transform_later(merge_mem);
1375 
1376   RegionNode* slow_region = new RegionNode(1);
1377   transform_later(slow_region);
1378 
1379   if (!ac-&gt;is_arraycopy_validated()) {
1380     // (3) operands must not be null
1381     // We currently perform our null checks with the null_check routine.
1382     // This means that the null exceptions will be reported in the caller
1383     // rather than (correctly) reported inside of the native arraycopy call.
1384     // This should be corrected, given time.  We do our null check with the
1385     // stack pointer restored.
1386     // null checks done library_call.cpp
1387 
1388     // (4) src_offset must not be negative.
1389     generate_negative_guard(&amp;ctrl, src_offset, slow_region);
1390 
1391     // (5) dest_offset must not be negative.
1392     generate_negative_guard(&amp;ctrl, dest_offset, slow_region);
1393 
1394     // (6) length must not be negative (moved to generate_arraycopy()).
1395     // generate_negative_guard(length, slow_region);
1396 
1397     // (7) src_offset + length must not exceed length of src.
1398     Node* alen = ac-&gt;in(ArrayCopyNode::SrcLen);
1399     assert(alen != NULL, &quot;need src len&quot;);
1400     generate_limit_guard(&amp;ctrl,
1401                          src_offset, length,
1402                          alen,
1403                          slow_region);
1404 
1405     // (8) dest_offset + length must not exceed length of dest.
1406     alen = ac-&gt;in(ArrayCopyNode::DestLen);
1407     assert(alen != NULL, &quot;need dest len&quot;);
1408     generate_limit_guard(&amp;ctrl,
1409                          dest_offset, length,
1410                          alen,
1411                          slow_region);
1412 
1413     // (9) each element of an oop array must be assignable
1414     // The generate_arraycopy subroutine checks this.
1415 
1416     if (dest_elem == T_OBJECT &amp;&amp; !top_dest-&gt;elem()-&gt;isa_valuetype() &amp;&amp; !top_dest-&gt;is_not_flat()) {
1417       generate_flattened_array_guard(&amp;ctrl, merge_mem, dest, slow_region);
1418     }
1419 
1420     if (src_elem == T_OBJECT &amp;&amp; !top_src-&gt;elem()-&gt;isa_valuetype() &amp;&amp; !top_src-&gt;is_not_flat()) {
1421       generate_flattened_array_guard(&amp;ctrl, merge_mem, src, slow_region);
1422     }
1423   }
1424 
1425   // This is where the memory effects are placed:
1426   const TypePtr* adr_type = NULL;
1427 
1428   Node* dest_length = alloc != NULL ? alloc-&gt;in(AllocateNode::ALength) : NULL;
1429 
1430   if (dest_elem == T_INLINE_TYPE) {
1431     adr_type = adjust_parameters_for_vt(top_dest, src_offset, dest_offset, length, dest_elem, dest_length);
1432   } else if (ac-&gt;_dest_type != TypeOopPtr::BOTTOM) {
1433     adr_type = ac-&gt;_dest_type-&gt;add_offset(Type::OffsetBot)-&gt;is_ptr();
1434   } else {
1435     adr_type = TypeAryPtr::get_array_body_type(dest_elem);
1436   }
1437 
1438   generate_arraycopy(ac, alloc, &amp;ctrl, merge_mem, &amp;io,
1439                      adr_type, dest_elem,
1440                      src, src_offset, dest, dest_offset, length,
1441                      dest_length,
1442                      // If a  negative length guard was generated for the ArrayCopyNode,
1443                      // the length of the array can never be negative.
1444                      false, ac-&gt;has_negative_length_guard(),
1445                      slow_region);
1446 }
    </pre>
  </body>
</html>
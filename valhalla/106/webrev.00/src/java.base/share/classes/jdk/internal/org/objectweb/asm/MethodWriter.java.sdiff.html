<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/org/objectweb/asm/MethodWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Opcodes.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/org/objectweb/asm/MethodWriter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 294         NA, // putfield = 181 (0xb5)
 295         NA, // invokevirtual = 182 (0xb6)
 296         NA, // invokespecial = 183 (0xb7)
 297         NA, // invokestatic = 184 (0xb8)
 298         NA, // invokeinterface = 185 (0xb9)
 299         NA, // invokedynamic = 186 (0xba)
 300         1, // new = 187 (0xbb)
 301         0, // newarray = 188 (0xbc)
 302         0, // anewarray = 189 (0xbd)
 303         0, // arraylength = 190 (0xbe)
 304         NA, // athrow = 191 (0xbf)
 305         0, // checkcast = 192 (0xc0)
 306         0, // instanceof = 193 (0xc1)
 307         -1, // monitorenter = 194 (0xc2)
 308         -1, // monitorexit = 195 (0xc3)
 309         NA, // wide = 196 (0xc4)
 310         NA, // multianewarray = 197 (0xc5)
 311         -1, // ifnull = 198 (0xc6)
 312         -1, // ifnonnull = 199 (0xc7)
 313         NA, // goto_w = 200 (0xc8)
<span class="line-modified"> 314         NA // jsr_w = 201 (0xc9)</span>



 315     };
 316 
 317     /** Where the constants used in this MethodWriter must be stored. */
 318     private final SymbolTable symbolTable;
 319 
 320     // Note: fields are ordered as in the method_info structure, and those related to attributes are
 321     // ordered as in Section 4.7 of the JVMS.
 322 
 323     /**
 324       * The access_flags field of the method_info JVMS structure. This field can contain ASM specific
 325       * access flags, such as {@link Opcodes#ACC_DEPRECATED}, which are removed when generating the
 326       * ClassFile structure.
 327       */
 328     private final int accessFlags;
 329 
 330     /** The name_index field of the method_info JVMS structure. */
 331     private final int nameIndex;
 332 
 333     /** The name of this method. */
 334     private final String name;
</pre>
<hr />
<pre>
 989             // theory, a basic block (since execution can jump from this instruction to the exception
 990             // handler). As a consequence, the local variable types at the beginning of the handler
 991             // block should be the merge of the local variable types at all the instructions within the
 992             // handler range. However, instead of creating a basic block for each instruction, we can
 993             // get the same result in a more efficient way. Namely, by starting a new basic block after
 994             // each xSTORE instruction, which is what we do here.
 995             visitLabel(new Label());
 996         }
 997     }
 998 
 999     @Override
1000     public void visitTypeInsn(final int opcode, final String type) {
1001         lastBytecodeOffset = code.length;
1002         // Add the instruction to the bytecode of the method.
1003         Symbol typeSymbol = symbolTable.addConstantClass(type);
1004         code.put12(opcode, typeSymbol.index);
1005         // If needed, update the maximum stack size and number of locals, and stack map frames.
1006         if (currentBasicBlock != null) {
1007             if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {
1008                 currentBasicBlock.frame.execute(opcode, lastBytecodeOffset, typeSymbol, symbolTable);
<span class="line-modified">1009             } else if (opcode == Opcodes.NEW) {</span>
1010                 // The stack size delta is 1 for NEW, and 0 for ANEWARRAY, CHECKCAST, or INSTANCEOF.
1011                 int size = relativeStackSize + 1;
1012                 if (size &gt; maxRelativeStackSize) {
1013                     maxRelativeStackSize = size;
1014                 }
1015                 relativeStackSize = size;
1016             }
1017         }
1018     }
1019 
1020     @Override
1021     public void visitFieldInsn(
1022             final int opcode, final String owner, final String name, final String descriptor) {
1023         lastBytecodeOffset = code.length;
1024         // Add the instruction to the bytecode of the method.
1025         Symbol fieldrefSymbol = symbolTable.addConstantFieldref(owner, name, descriptor);
1026         code.put12(opcode, fieldrefSymbol.index);
1027         // If needed, update the maximum stack size and number of locals, and stack map frames.
1028         if (currentBasicBlock != null) {
1029             if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {
1030                 currentBasicBlock.frame.execute(opcode, 0, fieldrefSymbol, symbolTable);
1031             } else {
1032                 int size;
1033                 char firstDescChar = descriptor.charAt(0);
1034                 switch (opcode) {



1035                     case Opcodes.GETSTATIC:
1036                         size = relativeStackSize + (firstDescChar == &#39;D&#39; || firstDescChar == &#39;J&#39; ? 2 : 1);
1037                         break;
1038                     case Opcodes.PUTSTATIC:
1039                         size = relativeStackSize + (firstDescChar == &#39;D&#39; || firstDescChar == &#39;J&#39; ? -2 : -1);
1040                         break;
1041                     case Opcodes.GETFIELD:
1042                         size = relativeStackSize + (firstDescChar == &#39;D&#39; || firstDescChar == &#39;J&#39; ? 1 : 0);
1043                         break;
1044                     case Opcodes.PUTFIELD:
1045                     default:
1046                         size = relativeStackSize + (firstDescChar == &#39;D&#39; || firstDescChar == &#39;J&#39; ? -3 : -2);
1047                         break;
1048                 }
1049                 if (size &gt; maxRelativeStackSize) {
1050                     maxRelativeStackSize = size;
1051                 }
1052                 relativeStackSize = size;
1053             }
1054         }
</pre>
</td>
<td>
<hr />
<pre>
 294         NA, // putfield = 181 (0xb5)
 295         NA, // invokevirtual = 182 (0xb6)
 296         NA, // invokespecial = 183 (0xb7)
 297         NA, // invokestatic = 184 (0xb8)
 298         NA, // invokeinterface = 185 (0xb9)
 299         NA, // invokedynamic = 186 (0xba)
 300         1, // new = 187 (0xbb)
 301         0, // newarray = 188 (0xbc)
 302         0, // anewarray = 189 (0xbd)
 303         0, // arraylength = 190 (0xbe)
 304         NA, // athrow = 191 (0xbf)
 305         0, // checkcast = 192 (0xc0)
 306         0, // instanceof = 193 (0xc1)
 307         -1, // monitorenter = 194 (0xc2)
 308         -1, // monitorexit = 195 (0xc3)
 309         NA, // wide = 196 (0xc4)
 310         NA, // multianewarray = 197 (0xc5)
 311         -1, // ifnull = 198 (0xc6)
 312         -1, // ifnonnull = 199 (0xc7)
 313         NA, // goto_w = 200 (0xc8)
<span class="line-modified"> 314         NA, // jsr_w = 201 (0xc9)</span>
<span class="line-added"> 315         NA, // breakpoint = 202 (0xca)</span>
<span class="line-added"> 316         NA, // default = 203 (0xcb)</span>
<span class="line-added"> 317         NA, // withfield = 204 (0xcc)</span>
 318     };
 319 
 320     /** Where the constants used in this MethodWriter must be stored. */
 321     private final SymbolTable symbolTable;
 322 
 323     // Note: fields are ordered as in the method_info structure, and those related to attributes are
 324     // ordered as in Section 4.7 of the JVMS.
 325 
 326     /**
 327       * The access_flags field of the method_info JVMS structure. This field can contain ASM specific
 328       * access flags, such as {@link Opcodes#ACC_DEPRECATED}, which are removed when generating the
 329       * ClassFile structure.
 330       */
 331     private final int accessFlags;
 332 
 333     /** The name_index field of the method_info JVMS structure. */
 334     private final int nameIndex;
 335 
 336     /** The name of this method. */
 337     private final String name;
</pre>
<hr />
<pre>
 992             // theory, a basic block (since execution can jump from this instruction to the exception
 993             // handler). As a consequence, the local variable types at the beginning of the handler
 994             // block should be the merge of the local variable types at all the instructions within the
 995             // handler range. However, instead of creating a basic block for each instruction, we can
 996             // get the same result in a more efficient way. Namely, by starting a new basic block after
 997             // each xSTORE instruction, which is what we do here.
 998             visitLabel(new Label());
 999         }
1000     }
1001 
1002     @Override
1003     public void visitTypeInsn(final int opcode, final String type) {
1004         lastBytecodeOffset = code.length;
1005         // Add the instruction to the bytecode of the method.
1006         Symbol typeSymbol = symbolTable.addConstantClass(type);
1007         code.put12(opcode, typeSymbol.index);
1008         // If needed, update the maximum stack size and number of locals, and stack map frames.
1009         if (currentBasicBlock != null) {
1010             if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {
1011                 currentBasicBlock.frame.execute(opcode, lastBytecodeOffset, typeSymbol, symbolTable);
<span class="line-modified">1012             } else if (opcode == Opcodes.NEW || opcode == Opcodes.DEFAULT) {</span>
1013                 // The stack size delta is 1 for NEW, and 0 for ANEWARRAY, CHECKCAST, or INSTANCEOF.
1014                 int size = relativeStackSize + 1;
1015                 if (size &gt; maxRelativeStackSize) {
1016                     maxRelativeStackSize = size;
1017                 }
1018                 relativeStackSize = size;
1019             }
1020         }
1021     }
1022 
1023     @Override
1024     public void visitFieldInsn(
1025             final int opcode, final String owner, final String name, final String descriptor) {
1026         lastBytecodeOffset = code.length;
1027         // Add the instruction to the bytecode of the method.
1028         Symbol fieldrefSymbol = symbolTable.addConstantFieldref(owner, name, descriptor);
1029         code.put12(opcode, fieldrefSymbol.index);
1030         // If needed, update the maximum stack size and number of locals, and stack map frames.
1031         if (currentBasicBlock != null) {
1032             if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {
1033                 currentBasicBlock.frame.execute(opcode, 0, fieldrefSymbol, symbolTable);
1034             } else {
1035                 int size;
1036                 char firstDescChar = descriptor.charAt(0);
1037                 switch (opcode) {
<span class="line-added">1038                     case Opcodes.WITHFIELD:</span>
<span class="line-added">1039                         size = relativeStackSize + (firstDescChar == &#39;D&#39; || firstDescChar == &#39;J&#39; ? -2 : -1);</span>
<span class="line-added">1040                         break;</span>
1041                     case Opcodes.GETSTATIC:
1042                         size = relativeStackSize + (firstDescChar == &#39;D&#39; || firstDescChar == &#39;J&#39; ? 2 : 1);
1043                         break;
1044                     case Opcodes.PUTSTATIC:
1045                         size = relativeStackSize + (firstDescChar == &#39;D&#39; || firstDescChar == &#39;J&#39; ? -2 : -1);
1046                         break;
1047                     case Opcodes.GETFIELD:
1048                         size = relativeStackSize + (firstDescChar == &#39;D&#39; || firstDescChar == &#39;J&#39; ? 1 : 0);
1049                         break;
1050                     case Opcodes.PUTFIELD:
1051                     default:
1052                         size = relativeStackSize + (firstDescChar == &#39;D&#39; || firstDescChar == &#39;J&#39; ? -3 : -2);
1053                         break;
1054                 }
1055                 if (size &gt; maxRelativeStackSize) {
1056                     maxRelativeStackSize = size;
1057                 }
1058                 relativeStackSize = size;
1059             }
1060         }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Opcodes.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
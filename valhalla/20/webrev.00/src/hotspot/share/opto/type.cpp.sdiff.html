<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/hotspot/share/opto/type.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 872   }
 873   if (t_spec != NULL &amp;&amp; interface_vs_oop_helper(t_spec)) {
 874     return true;
 875   }
 876   return false;
 877 }
 878 
 879 #endif
 880 
 881 void Type::check_symmetrical(const Type *t, const Type *mt) const {
 882 #ifdef ASSERT
 883   assert(mt == t-&gt;xmeet(this), &quot;meet not commutative&quot;);
 884   const Type* dual_join = mt-&gt;_dual;
 885   const Type *t2t    = dual_join-&gt;xmeet(t-&gt;_dual);
 886   const Type *t2this = dual_join-&gt;xmeet(this-&gt;_dual);
 887 
 888   // Interface meet Oop is Not Symmetric:
 889   // Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull
 890   // Interface:NotNull meet Oop:NotNull == java/lang/Object:NotNull
 891 
<span class="line-modified"> 892   // JDK-8242269: merge issue, disabled for now</span>
<span class="line-removed"> 893   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this-&gt;_dual) &amp;&amp; false) {</span>
 894     tty-&gt;print_cr(&quot;=== Meet Not Symmetric ===&quot;);
 895     tty-&gt;print(&quot;t   =                   &quot;);              t-&gt;dump(); tty-&gt;cr();
 896     tty-&gt;print(&quot;this=                   &quot;);                 dump(); tty-&gt;cr();
 897     tty-&gt;print(&quot;mt=(t meet this)=       &quot;);             mt-&gt;dump(); tty-&gt;cr();
 898 
 899     tty-&gt;print(&quot;t_dual=                 &quot;);       t-&gt;_dual-&gt;dump(); tty-&gt;cr();
 900     tty-&gt;print(&quot;this_dual=              &quot;);          _dual-&gt;dump(); tty-&gt;cr();
 901     tty-&gt;print(&quot;mt_dual=                &quot;);      mt-&gt;_dual-&gt;dump(); tty-&gt;cr();
 902 
 903     tty-&gt;print(&quot;mt_dual meet t_dual=    &quot;); t2t           -&gt;dump(); tty-&gt;cr();
 904     tty-&gt;print(&quot;mt_dual meet this_dual= &quot;); t2this        -&gt;dump(); tty-&gt;cr();
 905 
 906     fatal(&quot;meet not symmetric&quot; );
 907   }
 908 #endif
 909 }
 910 
 911 //------------------------------meet-------------------------------------------
 912 // Compute the MEET of two types.  NOT virtual.  It enforces that meet is
 913 // commutative and the lattice is symmetric.
</pre>
<hr />
<pre>
4179 
4180     // Now, reorder the above list; observe that both-down+subtype is also
4181     // &quot;fall hard&quot;; &quot;fall hard&quot; becomes the default case:
4182     // If we split one up &amp; one down AND they subtype, take the down man.
4183     // If both are up and they subtype, take the subtype class.
4184 
4185     // If both are down and they subtype, &quot;fall hard&quot;.
4186     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
4187     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
4188     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
4189 
4190     // If a proper subtype is exact, and we return it, we return it exactly.
4191     // If a proper supertype is exact, there can be no subtyping relationship!
4192     // If both types are equal to the subtype, exactness is and-ed below the
4193     // centerline and or-ed above it.  (N.B. Constants are always exact.)
4194 
4195     // Check for subtyping:
4196     ciKlass *subtype = NULL;
4197     bool subtype_exact = false;
4198     bool flat_array = false;
<span class="line-modified">4199     if( tinst_klass-&gt;equals(this_klass) ) {</span>
4200       subtype = this_klass;
4201       subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
4202       flat_array = below_centerline(ptr) ? (this_flat_array &amp;&amp; tinst_flat_array) : (this_flat_array || tinst_flat_array);
<span class="line-modified">4203     } else if( !tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of( tinst_klass ) ) {</span>
4204       subtype = this_klass;     // Pick subtyping class
4205       subtype_exact = this_xk;
4206       flat_array = this_flat_array;
<span class="line-modified">4207     } else if( !this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of( this_klass ) ) {</span>
4208       subtype = tinst_klass;    // Pick subtyping class
4209       subtype_exact = tinst_xk;
4210       flat_array = tinst_flat_array;
4211     }
4212 
<span class="line-modified">4213     if( subtype ) {</span>
<span class="line-modified">4214       if( above_centerline(ptr) ) { // both are up?</span>
4215         this_klass = tinst_klass = subtype;
4216         this_xk = tinst_xk = subtype_exact;
4217         this_flat_array = tinst_flat_array = flat_array;
<span class="line-modified">4218       } else if( above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr) ) {</span>
4219         this_klass = tinst_klass; // tinst is down; keep down man
4220         this_xk = tinst_xk;
4221         this_flat_array = tinst_flat_array;
<span class="line-modified">4222       } else if( above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr) ) {</span>
4223         tinst_klass = this_klass; // this is down; keep down man
4224         tinst_xk = this_xk;
4225         tinst_flat_array = this_flat_array;
4226       } else {
4227         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
4228         this_flat_array = flat_array;
4229       }
4230     }
4231 
4232     // Check for classes now being equal
4233     if (tinst_klass-&gt;equals(this_klass)) {
4234       // If the klasses are equal, the constants may still differ.  Fall to
4235       // NotNull if they do (neither constant is NULL; that is a special case
4236       // handled elsewhere).
4237       ciObject* o = NULL;             // Assume not constant when done
4238       ciObject* this_oop  = const_oop();
4239       ciObject* tinst_oop = tinst-&gt;const_oop();
4240       if( ptr == Constant ) {
4241         if (this_oop != NULL &amp;&amp; tinst_oop != NULL &amp;&amp;
4242             this_oop-&gt;equals(tinst_oop) )
</pre>
<hr />
<pre>
4252     } // Else classes are not equal
4253 
4254     // Since klasses are different, we require a LCA in the Java
4255     // class hierarchy - which means we have to fall to at least NotNull.
4256     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
4257       ptr = NotNull;
4258 
4259     instance_id = InstanceBot;
4260 
4261     // Now we find the LCA of Java classes
4262     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
4263     return make(ptr, k, false, NULL, off, false, instance_id, speculative, depth);
4264   } // End of case InstPtr
4265 
4266   case ValueType: {
4267     const TypeValueType* tv = t-&gt;is_valuetype();
4268     if (above_centerline(ptr())) {
4269       if (tv-&gt;value_klass()-&gt;is_subtype_of(_klass)) {
4270         return t;
4271       } else {
<span class="line-modified">4272         return TypeInstPtr::make(NotNull, _klass);</span>
4273       }
4274     } else {
4275       PTR ptr = this-&gt;_ptr;
4276       if (ptr == Constant) {
4277         ptr = NotNull;
4278       }
4279       if (tv-&gt;value_klass()-&gt;is_subtype_of(_klass)) {
4280         return TypeInstPtr::make(ptr, _klass);
4281       } else {
4282         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());
4283       }
4284     }
4285   }
4286 
4287   } // End of switch
4288   return this;                  // Return the double constant
4289 }
4290 
4291 
4292 //------------------------java_mirror_type--------------------------------------
</pre>
<hr />
<pre>
4685     Offset field_off = meet_field_offset(tap-&gt;field_offset());
4686     const TypeAry *tary = _ary-&gt;meet_speculative(tap-&gt;_ary)-&gt;is_ary();
4687     PTR ptr = meet_ptr(tap-&gt;ptr());
4688     int instance_id = meet_instance_id(tap-&gt;instance_id());
4689     const TypePtr* speculative = xmeet_speculative(tap);
4690     int depth = meet_inline_depth(tap-&gt;inline_depth());
4691     ciKlass* lazy_klass = NULL;
4692     if (tary-&gt;_elem-&gt;isa_int()) {
4693       // Integral array element types have irrelevant lattice relations.
4694       // It is the klass that determines array layout, not the element type.
4695       if (_klass == NULL)
4696         lazy_klass = tap-&gt;_klass;
4697       else if (tap-&gt;_klass == NULL || tap-&gt;_klass == _klass) {
4698         lazy_klass = _klass;
4699       } else {
4700         // Something like byte[int+] meets char[int+].
4701         // This must fall to bottom, not (int[-128..65535])[int+].
4702         instance_id = InstanceBot;
4703         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4704       }
<span class="line-removed">4705     } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp;</span>
<span class="line-removed">4706                klass()-&gt;as_array_klass()-&gt;storage_properties().value() != tap-&gt;klass()-&gt;as_array_klass()-&gt;storage_properties().value()) {</span>
<span class="line-removed">4707       // Meeting value type arrays with conflicting storage properties</span>
<span class="line-removed">4708       if (tary-&gt;_elem-&gt;isa_valuetype()) {</span>
<span class="line-removed">4709         // Result is flattened</span>
<span class="line-removed">4710         off = Offset(elem()-&gt;isa_valuetype() ? offset() : tap-&gt;offset());</span>
<span class="line-removed">4711         field_off = elem()-&gt;isa_valuetype() ? field_offset() : tap-&gt;field_offset();</span>
<span class="line-removed">4712       } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {</span>
<span class="line-removed">4713         // Result is non-flattened</span>
<span class="line-removed">4714         off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));</span>
<span class="line-removed">4715         field_off = Offset::bottom;</span>
<span class="line-removed">4716       }</span>
4717     } else // Non integral arrays.
4718       // Must fall to bottom if exact klasses in upper lattice
4719       // are not equal or super klass is exact.
4720       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4721           // meet with top[] and bottom[] are processed further down:
4722           tap-&gt;_klass != NULL &amp;&amp; this-&gt;_klass != NULL &amp;&amp;
4723           // both are exact and not equal:
4724           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4725            // &#39;tap&#39; is exact and super or unrelated:
4726            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4727            // &#39;this&#39; is exact and super or unrelated:
4728            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4729       if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
4730         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4731       }
4732       return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);












4733     }
4734 
4735     bool xk = false;
4736     switch (tap-&gt;ptr()) {
4737     case AnyNull:
4738     case TopPTR:
4739       // Compute new klass on demand, do not use tap-&gt;_klass
4740       if (below_centerline(this-&gt;_ptr)) {
4741         xk = this-&gt;_klass_is_exact;
4742       } else {
4743         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4744       }
4745       return make(ptr, const_oop(), tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4746     case Constant: {
4747       ciObject* o = const_oop();
4748       if( _ptr == Constant ) {
4749         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
4750           xk = (klass() == tap-&gt;klass());
4751           ptr = NotNull;
4752           o = NULL;
</pre>
<hr />
<pre>
4807         // For instances when a subclass meets a superclass we fall
4808         // below the centerline when the superclass is exact. We need
4809         // to do the same here.
4810         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {
4811           // that is, my array type is a subtype of &#39;tp&#39; klass
4812           return make(ptr, (ptr == Constant ? const_oop() : NULL),
4813                       _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4814         }
4815       }
4816       // The other case cannot happen, since t cannot be a subtype of an array.
4817       // The meet falls down to Object class below centerline.
4818       if( ptr == Constant )
4819          ptr = NotNull;
4820       instance_id = InstanceBot;
4821       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4822     default: typerr(t);
4823     }
4824   }
4825 
4826   case ValueType: {
<span class="line-modified">4827     // All value types inherit from Object</span>
<span class="line-modified">4828     PTR ptr = this-&gt;_ptr;</span>
<span class="line-modified">4829     if (ptr == Constant) {</span>
<span class="line-modified">4830       ptr = NotNull;</span>





4831     }
<span class="line-removed">4832     return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());</span>
4833   }
<span class="line-removed">4834 </span>
4835   }
4836   return this;                  // Lint noise
4837 }
4838 
4839 //------------------------------xdual------------------------------------------
4840 // Dual: compute field-by-field dual
4841 const Type *TypeAryPtr::xdual() const {
4842   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(), _klass, _klass_is_exact, dual_offset(), dual_field_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());
4843 }
4844 
4845 Type::Offset TypeAryPtr::meet_field_offset(const Type::Offset offset) const {
4846   return _field_offset.meet(offset);
4847 }
4848 
4849 //------------------------------dual_offset------------------------------------
4850 Type::Offset TypeAryPtr::dual_field_offset() const {
4851   return _field_offset.dual();
4852 }
4853 
4854 //----------------------interface_vs_oop---------------------------------------
</pre>
</td>
<td>
<hr />
<pre>
 872   }
 873   if (t_spec != NULL &amp;&amp; interface_vs_oop_helper(t_spec)) {
 874     return true;
 875   }
 876   return false;
 877 }
 878 
 879 #endif
 880 
 881 void Type::check_symmetrical(const Type *t, const Type *mt) const {
 882 #ifdef ASSERT
 883   assert(mt == t-&gt;xmeet(this), &quot;meet not commutative&quot;);
 884   const Type* dual_join = mt-&gt;_dual;
 885   const Type *t2t    = dual_join-&gt;xmeet(t-&gt;_dual);
 886   const Type *t2this = dual_join-&gt;xmeet(this-&gt;_dual);
 887 
 888   // Interface meet Oop is Not Symmetric:
 889   // Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull
 890   // Interface:NotNull meet Oop:NotNull == java/lang/Object:NotNull
 891 
<span class="line-modified"> 892   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this-&gt;_dual)) {</span>

 893     tty-&gt;print_cr(&quot;=== Meet Not Symmetric ===&quot;);
 894     tty-&gt;print(&quot;t   =                   &quot;);              t-&gt;dump(); tty-&gt;cr();
 895     tty-&gt;print(&quot;this=                   &quot;);                 dump(); tty-&gt;cr();
 896     tty-&gt;print(&quot;mt=(t meet this)=       &quot;);             mt-&gt;dump(); tty-&gt;cr();
 897 
 898     tty-&gt;print(&quot;t_dual=                 &quot;);       t-&gt;_dual-&gt;dump(); tty-&gt;cr();
 899     tty-&gt;print(&quot;this_dual=              &quot;);          _dual-&gt;dump(); tty-&gt;cr();
 900     tty-&gt;print(&quot;mt_dual=                &quot;);      mt-&gt;_dual-&gt;dump(); tty-&gt;cr();
 901 
 902     tty-&gt;print(&quot;mt_dual meet t_dual=    &quot;); t2t           -&gt;dump(); tty-&gt;cr();
 903     tty-&gt;print(&quot;mt_dual meet this_dual= &quot;); t2this        -&gt;dump(); tty-&gt;cr();
 904 
 905     fatal(&quot;meet not symmetric&quot; );
 906   }
 907 #endif
 908 }
 909 
 910 //------------------------------meet-------------------------------------------
 911 // Compute the MEET of two types.  NOT virtual.  It enforces that meet is
 912 // commutative and the lattice is symmetric.
</pre>
<hr />
<pre>
4178 
4179     // Now, reorder the above list; observe that both-down+subtype is also
4180     // &quot;fall hard&quot;; &quot;fall hard&quot; becomes the default case:
4181     // If we split one up &amp; one down AND they subtype, take the down man.
4182     // If both are up and they subtype, take the subtype class.
4183 
4184     // If both are down and they subtype, &quot;fall hard&quot;.
4185     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
4186     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
4187     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
4188 
4189     // If a proper subtype is exact, and we return it, we return it exactly.
4190     // If a proper supertype is exact, there can be no subtyping relationship!
4191     // If both types are equal to the subtype, exactness is and-ed below the
4192     // centerline and or-ed above it.  (N.B. Constants are always exact.)
4193 
4194     // Check for subtyping:
4195     ciKlass *subtype = NULL;
4196     bool subtype_exact = false;
4197     bool flat_array = false;
<span class="line-modified">4198     if (tinst_klass-&gt;equals(this_klass)) {</span>
4199       subtype = this_klass;
4200       subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
4201       flat_array = below_centerline(ptr) ? (this_flat_array &amp;&amp; tinst_flat_array) : (this_flat_array || tinst_flat_array);
<span class="line-modified">4202     } else if(!tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of(tinst_klass) &amp;&amp; (!tinst_flat_array || this_flat_array)) {</span>
4203       subtype = this_klass;     // Pick subtyping class
4204       subtype_exact = this_xk;
4205       flat_array = this_flat_array;
<span class="line-modified">4206     } else if(!this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of(this_klass) &amp;&amp; (!this_flat_array || tinst_flat_array)) {</span>
4207       subtype = tinst_klass;    // Pick subtyping class
4208       subtype_exact = tinst_xk;
4209       flat_array = tinst_flat_array;
4210     }
4211 
<span class="line-modified">4212     if (subtype) {</span>
<span class="line-modified">4213       if (above_centerline(ptr)) { // both are up?</span>
4214         this_klass = tinst_klass = subtype;
4215         this_xk = tinst_xk = subtype_exact;
4216         this_flat_array = tinst_flat_array = flat_array;
<span class="line-modified">4217       } else if (above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr)) {</span>
4218         this_klass = tinst_klass; // tinst is down; keep down man
4219         this_xk = tinst_xk;
4220         this_flat_array = tinst_flat_array;
<span class="line-modified">4221       } else if (above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr)) {</span>
4222         tinst_klass = this_klass; // this is down; keep down man
4223         tinst_xk = this_xk;
4224         tinst_flat_array = this_flat_array;
4225       } else {
4226         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
4227         this_flat_array = flat_array;
4228       }
4229     }
4230 
4231     // Check for classes now being equal
4232     if (tinst_klass-&gt;equals(this_klass)) {
4233       // If the klasses are equal, the constants may still differ.  Fall to
4234       // NotNull if they do (neither constant is NULL; that is a special case
4235       // handled elsewhere).
4236       ciObject* o = NULL;             // Assume not constant when done
4237       ciObject* this_oop  = const_oop();
4238       ciObject* tinst_oop = tinst-&gt;const_oop();
4239       if( ptr == Constant ) {
4240         if (this_oop != NULL &amp;&amp; tinst_oop != NULL &amp;&amp;
4241             this_oop-&gt;equals(tinst_oop) )
</pre>
<hr />
<pre>
4251     } // Else classes are not equal
4252 
4253     // Since klasses are different, we require a LCA in the Java
4254     // class hierarchy - which means we have to fall to at least NotNull.
4255     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
4256       ptr = NotNull;
4257 
4258     instance_id = InstanceBot;
4259 
4260     // Now we find the LCA of Java classes
4261     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
4262     return make(ptr, k, false, NULL, off, false, instance_id, speculative, depth);
4263   } // End of case InstPtr
4264 
4265   case ValueType: {
4266     const TypeValueType* tv = t-&gt;is_valuetype();
4267     if (above_centerline(ptr())) {
4268       if (tv-&gt;value_klass()-&gt;is_subtype_of(_klass)) {
4269         return t;
4270       } else {
<span class="line-modified">4271         return TypeInstPtr::NOTNULL;</span>
4272       }
4273     } else {
4274       PTR ptr = this-&gt;_ptr;
4275       if (ptr == Constant) {
4276         ptr = NotNull;
4277       }
4278       if (tv-&gt;value_klass()-&gt;is_subtype_of(_klass)) {
4279         return TypeInstPtr::make(ptr, _klass);
4280       } else {
4281         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());
4282       }
4283     }
4284   }
4285 
4286   } // End of switch
4287   return this;                  // Return the double constant
4288 }
4289 
4290 
4291 //------------------------java_mirror_type--------------------------------------
</pre>
<hr />
<pre>
4684     Offset field_off = meet_field_offset(tap-&gt;field_offset());
4685     const TypeAry *tary = _ary-&gt;meet_speculative(tap-&gt;_ary)-&gt;is_ary();
4686     PTR ptr = meet_ptr(tap-&gt;ptr());
4687     int instance_id = meet_instance_id(tap-&gt;instance_id());
4688     const TypePtr* speculative = xmeet_speculative(tap);
4689     int depth = meet_inline_depth(tap-&gt;inline_depth());
4690     ciKlass* lazy_klass = NULL;
4691     if (tary-&gt;_elem-&gt;isa_int()) {
4692       // Integral array element types have irrelevant lattice relations.
4693       // It is the klass that determines array layout, not the element type.
4694       if (_klass == NULL)
4695         lazy_klass = tap-&gt;_klass;
4696       else if (tap-&gt;_klass == NULL || tap-&gt;_klass == _klass) {
4697         lazy_klass = _klass;
4698       } else {
4699         // Something like byte[int+] meets char[int+].
4700         // This must fall to bottom, not (int[-128..65535])[int+].
4701         instance_id = InstanceBot;
4702         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4703       }












4704     } else // Non integral arrays.
4705       // Must fall to bottom if exact klasses in upper lattice
4706       // are not equal or super klass is exact.
4707       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4708           // meet with top[] and bottom[] are processed further down:
4709           tap-&gt;_klass != NULL &amp;&amp; this-&gt;_klass != NULL &amp;&amp;
4710           // both are exact and not equal:
4711           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4712            // &#39;tap&#39; is exact and super or unrelated:
4713            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4714            // &#39;this&#39; is exact and super or unrelated:
4715            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4716       if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
4717         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4718       }
4719       return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);
<span class="line-added">4720     } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp;</span>
<span class="line-added">4721                klass()-&gt;as_array_klass()-&gt;storage_properties().value() != tap-&gt;klass()-&gt;as_array_klass()-&gt;storage_properties().value()) {</span>
<span class="line-added">4722       // Meeting value type arrays with conflicting storage properties</span>
<span class="line-added">4723       if (tary-&gt;_elem-&gt;isa_valuetype()) {</span>
<span class="line-added">4724         // Result is flattened</span>
<span class="line-added">4725         off = Offset(elem()-&gt;isa_valuetype() ? offset() : tap-&gt;offset());</span>
<span class="line-added">4726         field_off = elem()-&gt;isa_valuetype() ? field_offset() : tap-&gt;field_offset();</span>
<span class="line-added">4727       } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {</span>
<span class="line-added">4728         // Result is non-flattened</span>
<span class="line-added">4729         off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));</span>
<span class="line-added">4730         field_off = Offset::bottom;</span>
<span class="line-added">4731       }</span>
4732     }
4733 
4734     bool xk = false;
4735     switch (tap-&gt;ptr()) {
4736     case AnyNull:
4737     case TopPTR:
4738       // Compute new klass on demand, do not use tap-&gt;_klass
4739       if (below_centerline(this-&gt;_ptr)) {
4740         xk = this-&gt;_klass_is_exact;
4741       } else {
4742         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4743       }
4744       return make(ptr, const_oop(), tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4745     case Constant: {
4746       ciObject* o = const_oop();
4747       if( _ptr == Constant ) {
4748         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
4749           xk = (klass() == tap-&gt;klass());
4750           ptr = NotNull;
4751           o = NULL;
</pre>
<hr />
<pre>
4806         // For instances when a subclass meets a superclass we fall
4807         // below the centerline when the superclass is exact. We need
4808         // to do the same here.
4809         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {
4810           // that is, my array type is a subtype of &#39;tp&#39; klass
4811           return make(ptr, (ptr == Constant ? const_oop() : NULL),
4812                       _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4813         }
4814       }
4815       // The other case cannot happen, since t cannot be a subtype of an array.
4816       // The meet falls down to Object class below centerline.
4817       if( ptr == Constant )
4818          ptr = NotNull;
4819       instance_id = InstanceBot;
4820       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4821     default: typerr(t);
4822     }
4823   }
4824 
4825   case ValueType: {
<span class="line-modified">4826     const TypeValueType* tv = t-&gt;is_valuetype();</span>
<span class="line-modified">4827     if (above_centerline(ptr())) {</span>
<span class="line-modified">4828       return TypeInstPtr::NOTNULL;</span>
<span class="line-modified">4829     } else {</span>
<span class="line-added">4830       PTR ptr = this-&gt;_ptr;</span>
<span class="line-added">4831       if (ptr == Constant) {</span>
<span class="line-added">4832         ptr = NotNull;</span>
<span class="line-added">4833       }</span>
<span class="line-added">4834       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());</span>
4835     }

4836   }

4837   }
4838   return this;                  // Lint noise
4839 }
4840 
4841 //------------------------------xdual------------------------------------------
4842 // Dual: compute field-by-field dual
4843 const Type *TypeAryPtr::xdual() const {
4844   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(), _klass, _klass_is_exact, dual_offset(), dual_field_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());
4845 }
4846 
4847 Type::Offset TypeAryPtr::meet_field_offset(const Type::Offset offset) const {
4848   return _field_offset.meet(offset);
4849 }
4850 
4851 //------------------------------dual_offset------------------------------------
4852 Type::Offset TypeAryPtr::dual_field_offset() const {
4853   return _field_offset.dual();
4854 }
4855 
4856 //----------------------interface_vs_oop---------------------------------------
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
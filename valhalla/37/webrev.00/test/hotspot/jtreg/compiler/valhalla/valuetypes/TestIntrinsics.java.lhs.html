<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package compiler.valhalla.valuetypes;
  25 
  26 import java.lang.reflect.Array;
  27 import java.lang.reflect.Field;
  28 import java.util.Arrays;
  29 import java.util.List;
  30 
  31 import jdk.test.lib.Asserts;
  32 import jdk.internal.misc.Unsafe;
  33 
  34 /*
  35  * @test
  36  * @summary Test intrinsic support for value types
  37  * @library /testlibrary /test/lib /compiler/whitebox /
  38  * @modules java.base/jdk.internal.misc
  39  * @requires (os.simpleArch == &quot;x64&quot; | os.simpleArch == &quot;aarch64&quot;)
  40  * @compile TestIntrinsics.java
  41  * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
  42  * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
  43  *                               -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI
  44  *                               compiler.valhalla.valuetypes.ValueTypeTest
  45  *                               compiler.valhalla.valuetypes.TestIntrinsics
  46  */
  47 public class TestIntrinsics extends ValueTypeTest {
  48     // Extra VM parameters for some test scenarios. See ValueTypeTest.getVMParameters()
  49     @Override
  50     public String[] getExtraVMParameters(int scenario) {
  51         switch (scenario) {
  52         case 3: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:ValueArrayElemMaxFlatSize=-1&quot;};
  53         case 4: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;};
  54         }
  55         return null;
  56     }
  57 
  58     public static void main(String[] args) throws Throwable {
  59         TestIntrinsics test = new TestIntrinsics();
  60         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class);
  61     }
  62 
  63     // Test correctness of the Class::isAssignableFrom intrinsic
  64     @Test()
  65     public boolean test1(Class&lt;?&gt; supercls, Class&lt;?&gt; subcls) {
  66         return supercls.isAssignableFrom(subcls);
  67     }
  68 
  69     public void test1_verifier(boolean warmup) {
  70         Asserts.assertTrue(test1(java.util.AbstractList.class, java.util.ArrayList.class), &quot;test1_1 failed&quot;);
  71         Asserts.assertTrue(test1(MyValue1.class.asIndirectType(), MyValue1.class.asIndirectType()), &quot;test1_2 failed&quot;);
  72         Asserts.assertTrue(test1(MyValue1.class, MyValue1.class), &quot;test1_3 failed&quot;);
  73         Asserts.assertTrue(test1(MyValue1.class.asIndirectType(), MyValue1.class), &quot;test1_4 failed&quot;);
  74         Asserts.assertFalse(test1(MyValue1.class, MyValue1.class.asIndirectType()), &quot;test1_5 failed&quot;);
  75         Asserts.assertTrue(test1(Object.class, java.util.ArrayList.class), &quot;test1_6 failed&quot;);
  76         Asserts.assertTrue(test1(Object.class, MyValue1.class.asIndirectType()), &quot;test1_7 failed&quot;);
  77         Asserts.assertTrue(test1(Object.class, MyValue1.class), &quot;test1_8 failed&quot;);
  78         Asserts.assertTrue(!test1(MyValue1.class.asIndirectType(), Object.class), &quot;test1_9 failed&quot;);
  79         Asserts.assertTrue(!test1(MyValue1.class, Object.class), &quot;test1_10 failed&quot;);
  80     }
  81 
  82     // Verify that Class::isAssignableFrom checks with statically known classes are folded
  83     @Test(failOn = LOADK)
  84     public boolean test2() {
  85         boolean check1 = java.util.AbstractList.class.isAssignableFrom(java.util.ArrayList.class);
  86         boolean check2 = MyValue1.class.asIndirectType().isAssignableFrom(MyValue1.class.asIndirectType());
  87         boolean check3 = MyValue1.class.isAssignableFrom(MyValue1.class);
  88         boolean check4 = MyValue1.class.asIndirectType().isAssignableFrom(MyValue1.class);
  89         boolean check5 = !MyValue1.class.isAssignableFrom(MyValue1.class.asIndirectType());
  90         boolean check6 = Object.class.isAssignableFrom(java.util.ArrayList.class);
  91         boolean check7 = Object.class.isAssignableFrom(MyValue1.class.asIndirectType());
  92         boolean check8 = Object.class.isAssignableFrom(MyValue1.class);
  93         boolean check9 = !MyValue1.class.asIndirectType().isAssignableFrom(Object.class);
  94         boolean check10 = !MyValue1.class.isAssignableFrom(Object.class);
  95         return check1 &amp;&amp; check2 &amp;&amp; check3 &amp;&amp; check4 &amp;&amp; check5 &amp;&amp; check6 &amp;&amp; check7 &amp;&amp; check8 &amp;&amp; check9 &amp;&amp; check10;
  96     }
  97 
  98     public void test2_verifier(boolean warmup) {
  99         Asserts.assertTrue(test2(), &quot;test2 failed&quot;);
 100     }
 101 
 102     // Test correctness of the Class::getSuperclass intrinsic
 103     @Test()
 104     public Class&lt;?&gt; test3(Class&lt;?&gt; cls) {
 105         return cls.getSuperclass();
 106     }
 107 
 108     public void test3_verifier(boolean warmup) {
 109         Asserts.assertTrue(test3(Object.class) == null, &quot;test3_1 failed&quot;);
<a name="1" id="anc1"></a><span class="line-modified"> 110 </span>
<span class="line-modified"> 111         Asserts.assertTrue(test3(MyValue1.class.asIndirectType()) == MyAbstract.class, &quot;test3_2 failed&quot;);</span>
<span class="line-removed"> 112         Asserts.assertTrue(test3(MyValue1.class.asPrimaryType()) == MyAbstract.class, &quot;test3_3 failed&quot;);</span>
 113         Asserts.assertTrue(test3(Class.class) == Object.class, &quot;test3_4 failed&quot;);
 114     }
 115 
 116     // Verify that Class::getSuperclass checks with statically known classes are folded
 117     @Test(failOn = LOADK)
 118     public boolean test4() {
 119         boolean check1 = Object.class.getSuperclass() == null;
<a name="2" id="anc2"></a><span class="line-removed"> 120 </span>
 121         // TODO Remove cast as workaround once javac is fixed
<a name="3" id="anc3"></a><span class="line-modified"> 122         boolean check2 = (Class&lt;?&gt;)MyValue1.class.asIndirectType().getSuperclass() == MyAbstract.class;</span>
 123         // TODO Remove cast as workaround once javac is fixed
<a name="4" id="anc4"></a><span class="line-modified"> 124         boolean check3 = (Class&lt;?&gt;)MyValue1.class.asPrimaryType().getSuperclass() == MyAbstract.class;</span>
 125         boolean check4 = Class.class.getSuperclass() == Object.class;
 126         return check1 &amp;&amp; check2 &amp;&amp; check3 &amp;&amp; check4;
 127     }
 128 
 129     public void test4_verifier(boolean warmup) {
 130         Asserts.assertTrue(test4(), &quot;test4 failed&quot;);
 131     }
 132 
 133     // Test toString() method
 134     @Test()
 135     public String test5(MyValue1 v) {
 136         return v.toString();
 137     }
 138 
 139     @DontCompile
 140     public void test5_verifier(boolean warmup) {
 141         MyValue1 v = MyValue1.createDefaultInline();
 142         test5(v);
 143     }
 144 
 145     // Test hashCode() method
 146     @Test()
 147     public int test6(MyValue1 v) {
 148         return v.hashCode();
 149     }
 150 
 151     @DontCompile
 152     public void test6_verifier(boolean warmup) {
 153         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 154         int res = test6(v);
 155         Asserts.assertEQ(res, v.hashCode());
 156     }
 157 
 158     // Test default value type array creation via reflection
 159     @Test()
 160     public Object[] test7(Class&lt;?&gt; componentType, int len) {
 161         Object[] va = (Object[])Array.newInstance(componentType, len);
 162         return va;
 163     }
 164 
 165     @DontCompile
 166     public void test7_verifier(boolean warmup) {
 167         int len = Math.abs(rI) % 42;
 168         long hash = MyValue1.createDefaultDontInline().hashPrimitive();
 169         Object[] va = test7(MyValue1.class, len);
 170         for (int i = 0; i &lt; len; ++i) {
 171             Asserts.assertEQ(((MyValue1)va[i]).hashPrimitive(), hash);
 172         }
 173     }
 174 
 175     // Class.isInstance
 176     @Test()
 177     public boolean test8(Class c, MyValue1 vt) {
 178         return c.isInstance(vt);
 179     }
 180 
 181     @DontCompile
 182     public void test8_verifier(boolean warmup) {
 183         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 184         boolean result = test8(MyValue1.class, vt);
 185         Asserts.assertTrue(result);
 186         result = test8(MyValue1.class.asIndirectType(), vt);
 187         Asserts.assertTrue(result);
 188     }
 189 
 190     @Test()
 191     public boolean test9(Class c, MyValue1 vt) {
 192         return c.isInstance(vt);
 193     }
 194 
 195     @DontCompile
 196     public void test9_verifier(boolean warmup) {
 197         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 198         boolean result = test9(MyValue2.class, vt);
 199         Asserts.assertFalse(result);
 200         result = test9(MyValue2.class.asIndirectType(), vt);
 201         Asserts.assertFalse(result);
 202     }
 203 
 204     // Class.cast
 205     @Test()
 206     public Object test10(Class c, MyValue1 vt) {
 207         return c.cast(vt);
 208     }
 209 
 210     @DontCompile
 211     public void test10_verifier(boolean warmup) {
 212         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 213         Object result = test10(MyValue1.class, vt);
 214         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 215     }
 216 
 217     @Test()
 218     public Object test11(Class c, MyValue1 vt) {
 219         return c.cast(vt);
 220     }
 221 
 222     @DontCompile
 223     public void test11_verifier(boolean warmup) {
 224         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 225         try {
 226             test11(MyValue2.class, vt);
 227             throw new RuntimeException(&quot;should have thrown&quot;);
 228         } catch (ClassCastException cce) {
 229         }
 230     }
 231 
 232     @Test()
 233     public Object test12(MyValue1 vt) {
 234         return MyValue1.class.cast(vt);
 235     }
 236 
 237     @DontCompile
 238     public void test12_verifier(boolean warmup) {
 239         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 240         Object result = test12(vt);
 241         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 242     }
 243 
 244     @Test()
 245     public Object test13(MyValue1 vt) {
 246         return MyValue2.class.cast(vt);
 247     }
 248 
 249     @DontCompile
 250     public void test13_verifier(boolean warmup) {
 251         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 252         try {
 253             test13(vt);
 254             throw new RuntimeException(&quot;should have thrown&quot;);
 255         } catch (ClassCastException cce) {
 256         }
 257     }
 258 
 259     // value type array creation via reflection
 260     @Test()
 261     public void test14(int len, long hash) {
 262         Object[] va = (Object[])Array.newInstance(MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType(), len);
 263         for (int i = 0; i &lt; len; ++i) {
 264             Asserts.assertEQ(((MyValue1)va[i]).hashPrimitive(), hash);
 265         }
 266     }
 267 
 268     @DontCompile
 269     public void test14_verifier(boolean warmup) {
 270         int len = Math.abs(rI) % 42;
 271         long hash = MyValue1.createDefaultDontInline().hashPrimitive();
 272         test14(len, hash);
 273     }
 274 
 275     // Test hashCode() method
 276     @Test()
 277     public int test15(Object v) {
 278         return v.hashCode();
 279     }
 280 
 281     @DontCompile
 282     public void test15_verifier(boolean warmup) {
 283         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 284         int res = test15(v);
 285         Asserts.assertEQ(res, v.hashCode());
 286     }
 287 
 288     @Test()
 289     public int test16(Object v) {
 290         return System.identityHashCode(v);
 291     }
 292 
 293     @DontCompile
 294     public void test16_verifier(boolean warmup) {
 295         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 296         int res = test16(v);
 297         Asserts.assertEQ(res, System.identityHashCode((Object)v));
 298     }
 299 
 300     @Test()
 301     public int test17(Object v) {
 302         return System.identityHashCode(v);
 303     }
 304 
 305     @DontCompile
 306     public void test17_verifier(boolean warmup) {
 307         Integer v = new Integer(rI);
 308         int res = test17(v);
 309         Asserts.assertEQ(res, System.identityHashCode(v));
 310     }
 311 
 312     @Test()
 313     public int test18(Object v) {
 314         return System.identityHashCode(v);
 315     }
 316 
 317     @DontCompile
 318     public void test18_verifier(boolean warmup) {
 319         Object v = null;
 320         int res = test18(v);
 321         Asserts.assertEQ(res, System.identityHashCode(v));
 322     }
 323 
 324     // hashCode() and toString() with different value types
 325     @Test()
 326     public int test19(MyValue1 vt1, MyValue1 vt2, boolean b) {
 327         MyValue1 res = b ? vt1 : vt2;
 328         return res.hashCode();
 329     }
 330 
 331     @DontCompile
 332     public void test19_verifier(boolean warmup) {
 333         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 334         int res = test19(vt, vt, true);
 335         Asserts.assertEQ(res, vt.hashCode());
 336         res = test19(vt, vt, false);
 337         Asserts.assertEQ(res, vt.hashCode());
 338     }
 339 
 340     @Test()
 341     public String test20(MyValue1 vt1, MyValue1 vt2, boolean b) {
 342         MyValue1 res = b ? vt1 : vt2;
 343         return res.toString();
 344     }
 345 
 346     @DontCompile
 347     public void test20_verifier(boolean warmup) {
 348         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 349         String res = test20(vt, vt, true);
 350         Asserts.assertEQ(res, vt.toString());
 351         res = test20(vt, vt, false);
 352         Asserts.assertEQ(res, vt.toString());
 353     }
 354 
 355     private static final Unsafe U = Unsafe.getUnsafe();
 356     private static final long X_OFFSET;
 357     private static final long Y_OFFSET;
 358     private static final long V1_OFFSET;
 359     private static final boolean V1_FLATTENED;
 360     static {
 361         try {
 362             Field xField = MyValue1.class.getDeclaredField(&quot;x&quot;);
 363             X_OFFSET = U.objectFieldOffset(xField);
 364             Field yField = MyValue1.class.getDeclaredField(&quot;y&quot;);
 365             Y_OFFSET = U.objectFieldOffset(yField);
 366             Field v1Field = MyValue1.class.getDeclaredField(&quot;v1&quot;);
 367             V1_OFFSET = U.objectFieldOffset(v1Field);
 368             V1_FLATTENED = U.isFlattened(v1Field);
 369         } catch (Exception e) {
 370             throw new RuntimeException(e);
 371         }
 372     }
 373 
 374     protected static final String CALL_Unsafe = START + &quot;CallStaticJava&quot; + MID + &quot;# Static  jdk.internal.misc.Unsafe::&quot; + END;
 375 
 376     @Test(failOn=CALL_Unsafe)
 377     public int test21(MyValue1 v) {
 378        return U.getInt(v, X_OFFSET);
 379     }
 380 
 381     @DontCompile
 382     public void test21_verifier(boolean warmup) {
 383         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 384         int res = test21(v);
 385         Asserts.assertEQ(res, v.x);
 386     }
 387 
 388     MyValue1 test22_vt;
 389     @Test(failOn=CALL_Unsafe + ALLOC)
 390     public void test22(MyValue1 v) {
 391         v = U.makePrivateBuffer(v);
 392         U.putInt(v, X_OFFSET, rI);
 393         v = U.finishPrivateBuffer(v);
 394         test22_vt = v;
 395     }
 396 
 397     @DontCompile
 398     public void test22_verifier(boolean warmup) {
 399         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 400         test22(v.setX(v, 0));
 401         Asserts.assertEQ(test22_vt.hash(), v.hash());
 402     }
 403 
 404     @Test(failOn=CALL_Unsafe)
 405     public int test23(MyValue1 v, long offset) {
 406         return U.getInt(v, offset);
 407     }
 408 
 409     @DontCompile
 410     public void test23_verifier(boolean warmup) {
 411         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 412         int res = test23(v, X_OFFSET);
 413         Asserts.assertEQ(res, v.x);
 414     }
 415 
 416     MyValue1 test24_vt = MyValue1.createWithFieldsInline(rI, rL);
 417 
 418     @Test(failOn=CALL_Unsafe)
 419     public int test24(long offset) {
 420         return U.getInt(test24_vt, offset);
 421     }
 422 
 423     @DontCompile
 424     public void test24_verifier(boolean warmup) {
 425         int res = test24(X_OFFSET);
 426         Asserts.assertEQ(res, test24_vt.x);
 427     }
 428 
 429     // Test copyOf intrinsic with allocated value type in it&#39;s debug information
 430     final inline class Test25Value {
 431         final int x;
 432         public Test25Value() {
 433             this.x = 42;
 434         }
 435     }
 436 
 437     final Test25Value[] test25Array = new Test25Value[10];
 438 
 439     @Test
 440     public Test25Value[] test25(Test25Value element) {
 441         // TODO Remove cast as workaround once javac is fixed
 442         Test25Value[] newArray = (Test25Value[])Arrays.copyOf(test25Array, test25Array.length + 1);
 443         newArray[test25Array.length] = element;
 444         return newArray;
 445     }
 446 
 447     @DontCompile
 448     public void test25_verifier(boolean warmup) {
 449         Test25Value vt = new Test25Value();
 450         test25(vt);
 451     }
 452 
 453     @Test
 454     public Object test26() {
 455         Class&lt;?&gt;[] ca = new Class&lt;?&gt;[1];
 456         for (int i = 0; i &lt; 1; ++i) {
 457           // Folds during loop opts
 458           ca[i] = MyValue1.class.asPrimaryType();
 459         }
 460         return Array.newInstance(ca[0], 1);
 461     }
 462 
 463     @DontCompile
 464     public void test26_verifier(boolean warmup) {
 465         Object[] res = (Object[])test26();
 466         Asserts.assertEQ(((MyValue1)res[0]).hashPrimitive(), MyValue1.createDefaultInline().hashPrimitive());
 467     }
 468 
 469     // Load non-flattenable value type field with unsafe
 470     MyValue1.ref test27_vt = MyValue1.createWithFieldsInline(rI, rL);
 471     private static final long TEST27_OFFSET;
 472     static {
 473         try {
 474             Field field = TestIntrinsics.class.getDeclaredField(&quot;test27_vt&quot;);
 475             TEST27_OFFSET = U.objectFieldOffset(field);
 476         } catch (Exception e) {
 477             throw new RuntimeException(e);
 478         }
 479     }
 480 
 481     @Test(failOn=CALL_Unsafe)
 482     public MyValue1 test27() {
 483         return (MyValue1)U.getReference(this, TEST27_OFFSET);
 484     }
 485 
 486     @DontCompile
 487     public void test27_verifier(boolean warmup) {
 488         MyValue1 res = test27();
 489         Asserts.assertEQ(res.hash(), test24_vt.hash());
 490     }
 491 
 492     // Mismatched type
 493     @Test(failOn=CALL_Unsafe)
 494     public int test28(MyValue1 v) {
 495         return U.getByte(v, X_OFFSET);
 496     }
 497 
 498     @DontCompile
 499     public void test28_verifier(boolean warmup) {
 500         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 501         int res = test28(v);
 502         if (java.nio.ByteOrder.nativeOrder() == java.nio.ByteOrder.LITTLE_ENDIAN) {
 503             Asserts.assertEQ(res, (int)((byte)v.x));
 504         } else {
 505             Asserts.assertEQ(res, (int)((byte)Integer.reverseBytes(v.x)));
 506         }
 507     }
 508 
 509     // Wrong alignment
 510     @Test(failOn=CALL_Unsafe)
 511     public long test29(MyValue1 v) {
 512         // Read the field that&#39;s guaranteed to not be last in the
 513         // value so we don&#39;t read out of the value
 514         if (X_OFFSET &lt; Y_OFFSET) {
 515             return U.getInt(v, X_OFFSET+1);
 516         }
 517         return U.getLong(v, Y_OFFSET+1);
 518     }
 519 
 520     @DontCompile
 521     public void test29_verifier(boolean warmup) {
 522         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 523         long res = test29(v);
 524         if (java.nio.ByteOrder.nativeOrder() == java.nio.ByteOrder.LITTLE_ENDIAN) {
 525             if (X_OFFSET &lt; Y_OFFSET) {
 526                 Asserts.assertEQ(((int)res) &lt;&lt; 8, (v.x &gt;&gt; 8) &lt;&lt; 8);
 527             } else {
 528                 Asserts.assertEQ(res &lt;&lt; 8, (v.y &gt;&gt; 8) &lt;&lt; 8);
 529             }
 530         } else {
 531             if (X_OFFSET &lt; Y_OFFSET) {
 532                 Asserts.assertEQ(((int)res), v.x &gt;&gt;&gt; 8);
 533             } else {
 534                 Asserts.assertEQ(res, v.y &gt;&gt;&gt; 8);
 535             }
 536         }
 537     }
 538 
 539     // getValue to retrieve flattened field from value
 540     @Test(failOn=CALL_Unsafe)
 541     public MyValue2 test30(MyValue1 v) {
 542         if (V1_FLATTENED) {
 543             return U.getValue(v, V1_OFFSET, MyValue2.class.asPrimaryType().asIndirectType().asPrimaryType());
 544         }
 545         return (MyValue2)U.getReference(v, V1_OFFSET);
 546     }
 547 
 548     @DontCompile
 549     public void test30_verifier(boolean warmup) {
 550         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 551         MyValue2 res = test30(v);
 552         Asserts.assertEQ(res.hash(), v.v1.hash());
 553     }
 554 
 555     MyValue1 test31_vt;
 556     private static final long TEST31_VT_OFFSET;
 557     private static final boolean TEST31_VT_FLATTENED;
 558     static {
 559         try {
 560             Field test31_vt_Field = TestIntrinsics.class.getDeclaredField(&quot;test31_vt&quot;);
 561             TEST31_VT_OFFSET = U.objectFieldOffset(test31_vt_Field);
 562             TEST31_VT_FLATTENED = U.isFlattened(test31_vt_Field);
 563         } catch (Exception e) {
 564             throw new RuntimeException(e);
 565         }
 566     }
 567 
 568     // getValue to retrieve flattened field from object
 569     @Test(failOn=CALL_Unsafe)
 570     public MyValue1 test31() {
 571         if (TEST31_VT_FLATTENED) {
 572             return U.getValue(this, TEST31_VT_OFFSET, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType());
 573         }
 574         return (MyValue1)U.getReference(this, TEST31_VT_OFFSET);
 575     }
 576 
 577     @DontCompile
 578     public void test31_verifier(boolean warmup) {
 579         test31_vt = MyValue1.createWithFieldsInline(rI, rL);
 580         MyValue1 res = test31();
 581         Asserts.assertEQ(res.hash(), test31_vt.hash());
 582     }
 583 
 584     // putValue to set flattened field in object
 585     @Test(failOn=CALL_Unsafe)
 586     public void test32(MyValue1 vt) {
 587         if (TEST31_VT_FLATTENED) {
 588             U.putValue(this, TEST31_VT_OFFSET, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType(), vt);
 589         } else {
 590             U.putReference(this, TEST31_VT_OFFSET, vt);
 591         }
 592     }
 593 
 594     @DontCompile
 595     public void test32_verifier(boolean warmup) {
 596         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 597         test31_vt = MyValue1.createDefaultInline();
 598         test32(vt);
 599         Asserts.assertEQ(vt.hash(), test31_vt.hash());
 600     }
 601 
 602     private static final int TEST33_BASE_OFFSET;
 603     private static final int TEST33_INDEX_SCALE;
 604     private static final boolean TEST33_FLATTENED_ARRAY;
 605     static {
 606         try {
 607             TEST33_BASE_OFFSET = U.arrayBaseOffset(MyValue1[].class);
 608             TEST33_INDEX_SCALE = U.arrayIndexScale(MyValue1[].class);
 609             TEST33_FLATTENED_ARRAY = U.isFlattenedArray(MyValue1[].class);
 610         } catch (Exception e) {
 611             throw new RuntimeException(e);
 612         }
 613     }
 614     // getValue to retrieve flattened field from array
 615     @Test(failOn=CALL_Unsafe)
 616     public MyValue1 test33(MyValue1[] arr) {
 617         if (TEST33_FLATTENED_ARRAY) {
 618             return U.getValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType());
 619         }
 620         return (MyValue1)U.getReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE);
 621     }
 622 
 623     @DontCompile
 624     public void test33_verifier(boolean warmup) {
 625         MyValue1[] arr = new MyValue1[2];
 626         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 627         arr[1] = vt;
 628         MyValue1 res = test33(arr);
 629         Asserts.assertEQ(res.hash(), vt.hash());
 630     }
 631 
 632     // putValue to set flattened field in array
 633     @Test(failOn=CALL_Unsafe)
 634     public void test34(MyValue1[] arr, MyValue1 vt) {
 635         if (TEST33_FLATTENED_ARRAY) {
 636             U.putValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType(), vt);
 637         } else {
 638             U.putReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, vt);
 639         }
 640     }
 641 
 642     @DontCompile
 643     public void test34_verifier(boolean warmup) {
 644         MyValue1[] arr = new MyValue1[2];
 645         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 646         test34(arr, vt);
 647         Asserts.assertEQ(arr[1].hash(), vt.hash());
 648     }
 649 
 650     // getValue to retrieve flattened field from object with unknown
 651     // container type
 652     @Test(failOn=CALL_Unsafe)
 653     public MyValue1 test35(Object o) {
 654         if (TEST31_VT_FLATTENED) {
 655             return U.getValue(o, TEST31_VT_OFFSET, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType());
 656         }
 657         return (MyValue1)U.getReference(o, TEST31_VT_OFFSET);
 658     }
 659 
 660     @DontCompile
 661     public void test35_verifier(boolean warmup) {
 662         test31_vt = MyValue1.createWithFieldsInline(rI, rL);
 663         MyValue1 res = test35(this);
 664         Asserts.assertEQ(res.hash(), test31_vt.hash());
 665     }
 666 
 667     // getValue to retrieve flattened field from object at unknown
 668     // offset
 669     @Test(failOn=CALL_Unsafe)
 670     public MyValue1 test36(long offset) {
 671         if (TEST31_VT_FLATTENED) {
 672             return U.getValue(this, offset, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType());
 673         }
 674         return (MyValue1)U.getReference(this, offset);
 675     }
 676 
 677     @DontCompile
 678     public void test36_verifier(boolean warmup) {
 679         test31_vt = MyValue1.createWithFieldsInline(rI, rL);
 680         MyValue1 res = test36(TEST31_VT_OFFSET);
 681         Asserts.assertEQ(res.hash(), test31_vt.hash());
 682     }
 683 
 684     // putValue to set flattened field in object with unknown
 685     // container
 686     @Test(failOn=CALL_Unsafe)
 687     public void test37(Object o, MyValue1 vt) {
 688         if (TEST31_VT_FLATTENED) {
 689             U.putValue(o, TEST31_VT_OFFSET, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType(), vt);
 690         } else {
 691             U.putReference(o, TEST31_VT_OFFSET, vt);
 692         }
 693     }
 694 
 695     @DontCompile
 696     public void test37_verifier(boolean warmup) {
 697         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 698         test31_vt = MyValue1.createDefaultInline();
 699         test37(this, vt);
 700         Asserts.assertEQ(vt.hash(), test31_vt.hash());
 701     }
 702 
 703     // putValue to set flattened field in object, non value argument
 704     // to store
 705     @Test(match = { CALL_Unsafe }, matchCount = { 1 })
 706     public void test38(Object o) {
 707         if (TEST31_VT_FLATTENED) {
 708             U.putValue(this, TEST31_VT_OFFSET, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType(), o);
 709         } else {
 710             U.putReference(this, TEST31_VT_OFFSET, o);
 711         }
 712     }
 713 
 714     @DontCompile
 715     public void test38_verifier(boolean warmup) {
 716         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 717         test31_vt = MyValue1.createDefaultInline();
 718         test38(vt);
 719         Asserts.assertEQ(vt.hash(), test31_vt.hash());
 720     }
 721 
 722     @Test(failOn=CALL_Unsafe)
 723     public MyValue1 test39(MyValue1 v) {
 724         v = U.makePrivateBuffer(v);
 725         U.putInt(v, X_OFFSET, rI);
 726         v = U.finishPrivateBuffer(v);
 727         return v;
 728     }
 729 
 730     @DontCompile
 731     public void test39_verifier(boolean warmup) {
 732         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 733         MyValue1 res = test39(v.setX(v, 0));
 734         Asserts.assertEQ(res.hash(), v.hash());
 735     }
 736 
 737     // Test default value type array creation via reflection
 738     @Test()
 739     public Object[] test40(Class&lt;?&gt; componentType, int len) {
 740         Object[] va = (Object[])Array.newInstance(componentType, len);
 741         return va;
 742     }
 743 
 744     @DontCompile
 745     public void test40_verifier(boolean warmup) {
 746         int len = Math.abs(rI) % 42;
 747         Object[] va = test40(MyValue1.class.asIndirectType(), len);
 748         for (int i = 0; i &lt; len; ++i) {
 749             Asserts.assertEQ(va[i], null);
 750         }
 751     }
 752 
 753     // Class.isInstance
 754     @Test()
 755     public boolean test41(Class c, MyValue1.ref vt) {
 756         return c.isInstance(vt);
 757     }
 758 
 759     @DontCompile
 760     public void test41_verifier(boolean warmup) {
 761         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 762         boolean result = test41(MyValue1.class.asIndirectType(), vt);
 763         Asserts.assertTrue(result);
 764         result = test41(MyValue1.class, vt);
 765         Asserts.assertTrue(result);
 766     }
 767 
 768     @Test()
 769     public boolean test42(Class c, MyValue1.ref vt) {
 770         return c.isInstance(vt);
 771     }
 772 
 773     @DontCompile
 774     public void test42_verifier(boolean warmup) {
 775         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 776         boolean result = test42(MyValue2.class.asIndirectType(), vt);
 777         Asserts.assertFalse(result);
 778         result = test42(MyValue2.class, vt);
 779         Asserts.assertFalse(result);
 780     }
 781 
 782     // Class.cast
 783     @Test()
 784     public Object test43(Class c, MyValue1.ref vt) {
 785         return c.cast(vt);
 786     }
 787 
 788     @DontCompile
 789     public void test43_verifier(boolean warmup) {
 790         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 791         Object result = test43(MyValue1.class.asIndirectType(), vt);
 792         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 793         result = test43(MyValue1.class.asIndirectType(), null);
 794         Asserts.assertEQ(result, null);
 795     }
 796 
 797     @Test()
 798     public Object test44(Class c, MyValue1.ref vt) {
 799         return c.cast(vt);
 800     }
 801 
 802     @DontCompile
 803     public void test44_verifier(boolean warmup) {
 804         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 805         try {
 806             test44(MyValue2.class.asIndirectType(), vt);
 807             throw new RuntimeException(&quot;should have thrown&quot;);
 808         } catch (ClassCastException cce) {
 809         }
 810     }
 811 
 812     @Test()
 813     public Object test45(MyValue1.ref vt) {
 814         return MyValue1.class.asIndirectType().cast(vt);
 815     }
 816 
 817     @DontCompile
 818     public void test45_verifier(boolean warmup) {
 819         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 820         Object result = test45(vt);
 821         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 822         result = test45(null);
 823         Asserts.assertEQ(result, null);
 824     }
 825 
 826     @Test()
 827     public Object test46(MyValue1.ref vt) {
 828         return MyValue2.class.asIndirectType().cast(vt);
 829     }
 830 
 831     @DontCompile
 832     public void test46_verifier(boolean warmup) {
 833         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 834         test46(null);
 835         try {
 836             test46(vt);
 837             throw new RuntimeException(&quot;should have thrown&quot;);
 838         } catch (ClassCastException cce) {
 839         }
 840     }
 841 
 842     @Test()
 843     public Object test47(MyValue1.ref vt) {
 844         return MyValue1.class.asPrimaryType().cast(vt);
 845     }
 846 
 847     @DontCompile
 848     public void test47_verifier(boolean warmup) {
 849         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 850         Object result = test47(vt);
 851         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 852         try {
 853             test47(null);
 854             throw new RuntimeException(&quot;should have thrown&quot;);
 855         } catch (NullPointerException npe) {
 856         }
 857     }
 858 
 859     @Test()
 860     public Object test48(Class c, MyValue1.ref vt) {
 861         return c.cast(vt);
 862     }
 863 
 864     @DontCompile
 865     public void test48_verifier(boolean warmup) {
 866         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 867         Object result = test48(MyValue1.class, vt);
 868         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 869         try {
 870             test48(MyValue1.class, null);
 871             throw new RuntimeException(&quot;should have thrown&quot;);
 872         } catch (NullPointerException npe) {
 873         }
 874     }
 875 
 876     @Test()
 877     public Object test49(MyValue1 vt) {
 878         return MyValue1.class.asIndirectType().cast(vt);
 879     }
 880 
 881     @DontCompile
 882     public void test49_verifier(boolean warmup) {
 883         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 884         Object result = test49(vt);
 885         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 886     }
 887 
 888     @Test()
 889     public Object test50(Class c, Object obj) {
 890         return c.cast(obj);
 891     }
 892 
 893     @DontCompile
 894     public void test50_verifier(boolean warmup) {
 895         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 896         MyValue1[] va  = new MyValue1[42];
 897         MyValue1.ref[] vba = new MyValue1.ref[42];
 898         Object result = test50(MyValue1.class, vt);
 899         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 900         result = test50(MyValue1.class.asIndirectType(), vt);
 901         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 902         result = test50(MyValue1[].class, va);
 903         Asserts.assertEQ(result, va);
 904         result = test50(MyValue1.ref[].class, vba);
 905         Asserts.assertEQ(result, vba);
 906         result = test50(MyValue1.ref[].class, va);
 907         Asserts.assertEQ(result, va);
 908         try {
 909             test50(MyValue1.class, null);
 910             throw new RuntimeException(&quot;should have thrown&quot;);
 911         } catch (NullPointerException npe) {
 912         }
 913         try {
 914             test50(MyValue1[].class, vba);
 915             throw new RuntimeException(&quot;should have thrown&quot;);
 916         } catch (ClassCastException cce) {
 917         }
 918     }
 919 
 920     // value type array creation via reflection
 921     @Test()
 922     public void test51(int len) {
 923         Object[] va = (Object[])Array.newInstance(MyValue1.class.asIndirectType().asPrimaryType().asIndirectType(), len);
 924         for (int i = 0; i &lt; len; ++i) {
 925             Asserts.assertEQ(va[i], null);
 926         }
 927     }
 928 
 929     @DontCompile
 930     public void test51_verifier(boolean warmup) {
 931         int len = Math.abs(rI) % 42;
 932         test51(len);
 933     }
 934 
 935     // multidimensional value type array creation via reflection
 936     @Test()
 937     public Object[][] test52(int len, int val) {
 938         MyValue1[][] va1 = (MyValue1[][])Array.newInstance(MyValue1[].class, len);
 939         MyValue1.ref[][] va2 = (MyValue1.ref[][])Array.newInstance(MyValue1.ref[].class, len);
 940         Object[][] result;
 941         if (val == 1) {
 942             va1[0] = new MyValue1[1];
 943             result = va1;
 944         } else {
 945             va2[0] = new MyValue1.ref[1];
 946             result = va2;
 947         }
 948         if (val == 1) {
 949             Asserts.assertEQ(va1[0][0].hash(), ((MyValue1)result[0][0]).hash());
 950         } else {
 951             Asserts.assertEQ(result[0][0], null);
 952             result[0][0] = null;
 953         }
 954         return result;
 955     }
 956 
 957     @DontCompile
 958     public void test52_verifier(boolean warmup) {
 959         test52(1, 1);
 960         test52(1, 2);
 961     }
 962 
 963     @Test()
 964     public Object[][] test53(Class&lt;?&gt; c1, Class&lt;?&gt; c2, int len, int val) {
 965         MyValue1[][] va1 = (MyValue1[][])Array.newInstance(MyValue1[].class, len);
 966         MyValue1.ref[][] va2 = (MyValue1.ref[][])Array.newInstance(MyValue1.ref[].class, len);
 967         Object[][] va3 = (Object[][])Array.newInstance(c1, len);
 968         Object[][] va4 = (Object[][])Array.newInstance(c2, len);
 969         for (int i = 0; i &lt; len; ++i) {
 970             Asserts.assertEQ(va1[i], null);
 971             Asserts.assertEQ(va2[i], null);
 972             Asserts.assertEQ(va3[i], null);
 973             Asserts.assertEQ(va4[i], null);
 974             va1[i] = new MyValue1[1];
 975             va2[i] = new MyValue1.ref[1];
 976             va3[i] = new MyValue1[1];
 977             va4[i] = new MyValue1.ref[1];
 978             Asserts.assertEQ(va1[i][0].hash(), ((MyValue1)va3[i][0]).hash());
 979             Asserts.assertEQ(va2[i][0], null);
 980             Asserts.assertEQ(va4[i][0], null);
 981         }
 982         Object[][] result;
 983         if (val == 1) {
 984             result = va1;
 985         } else if (val == 2) {
 986             result = va2;
 987         } else if (val == 3) {
 988             result = va3;
 989         } else {
 990             result = va4;
 991         }
 992         if ((val == 1 || val == 3) &amp;&amp; len &gt; 0) {
 993             Asserts.assertEQ(va1[0][0].hash(), ((MyValue1)result[0][0]).hash());
 994         } else if (len &gt; 0) {
 995             Asserts.assertEQ(result[0][0], null);
 996             result[0][0] = null;
 997         }
 998         return result;
 999     }
1000 
1001     @DontCompile
1002     public void test53_verifier(boolean warmup) {
1003         int len = Math.abs(rI) % 42;
1004         test53(MyValue1[].class, MyValue1.ref[].class, len, 1);
1005         test53(MyValue1[].class, MyValue1.ref[].class, len, 2);
1006         test53(MyValue1[].class, MyValue1.ref[].class, len, 3);
1007         test53(MyValue1[].class, MyValue1.ref[].class, len, 4);
1008     }
1009 
1010     // Test asIndirectType intrinsic with non-value mirror
1011     @Test()
1012     public Class&lt;?&gt; test54(Class&lt;?&gt; c) {
1013         if (c.asIndirectType() != Integer.class) {
1014             throw new RuntimeException(&quot;Unexpected class&quot;);
1015         }
1016         return Integer.class.asIndirectType();
1017     }
1018 
1019     @DontCompile
1020     public void test54_verifier(boolean warmup) {
1021         Class&lt;?&gt; result = test54(Integer.class);
1022         Asserts.assertEQ(result, Integer.class);
1023     }
1024 
1025     // Test asPrimaryType intrinsic with non-value mirror
1026     @Test()
1027     public Class&lt;?&gt; test55(Class&lt;?&gt; c) {
1028         if (c.asPrimaryType() != Integer.class) {
1029             throw new RuntimeException(&quot;Unexpected class&quot;);
1030         }
1031         return Integer.class.asPrimaryType();
1032     }
1033 
1034     @DontCompile
1035     public void test55_verifier(boolean warmup) {
1036         Class&lt;?&gt; result = test55(Integer.class);
1037         Asserts.assertEQ(result, Integer.class);
1038     }
1039 
1040     // Same as test39 but Unsafe.putInt to buffer is not intrinsified/compiled
1041     @DontCompile
1042     public void test56_callee(MyValue1.ref v) { // Use .ref here to make sure the argument is not scalarized (otherwise larval information is lost)
1043         U.putInt(v, X_OFFSET, rI);
1044     }
1045 
1046     @Test()
1047     @Warmup(10000) // Fill up the TLAB to trigger slow path allocation
1048     public MyValue1 test56(MyValue1 v) {
1049         v = U.makePrivateBuffer(v);
1050         test56_callee(v);
1051         v = U.finishPrivateBuffer(v);
1052         return v;
1053     }
1054 
1055     @DontCompile
1056     public void test56_verifier(boolean warmup) {
1057         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
1058         MyValue1 res = test56(v.setX(v, 0));
1059         Asserts.assertEQ(res.hash(), v.hash());
1060     }
1061 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/oops/instanceKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_INSTANCEKLASS_HPP
  26 #define SHARE_OOPS_INSTANCEKLASS_HPP
  27 
  28 #include &quot;classfile/classLoaderData.hpp&quot;
  29 #include &quot;code/vmreg.hpp&quot;
  30 #include &quot;memory/referenceType.hpp&quot;
  31 #include &quot;oops/annotations.hpp&quot;
  32 #include &quot;oops/constMethod.hpp&quot;
  33 #include &quot;oops/fieldInfo.hpp&quot;
  34 #include &quot;oops/instanceOop.hpp&quot;
  35 #include &quot;oops/klassVtable.hpp&quot;
  36 #include &quot;runtime/handles.hpp&quot;
  37 #include &quot;runtime/os.hpp&quot;
  38 #include &quot;utilities/accessFlags.hpp&quot;
  39 #include &quot;utilities/align.hpp&quot;
  40 #include &quot;utilities/macros.hpp&quot;
  41 #if INCLUDE_JFR
  42 #include &quot;jfr/support/jfrKlassExtension.hpp&quot;
  43 #endif
  44 
  45 class RecordComponent;
  46 
  47 // An InstanceKlass is the VM level representation of a Java class.
  48 // It contains all information needed for at class at execution runtime.
  49 
  50 //  InstanceKlass embedded field layout (after declared fields):
  51 //    [EMBEDDED Java vtable             ] size in words = vtable_len
  52 //    [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size
  53 //      The embedded nonstatic oop-map blocks are short pairs (offset, length)
  54 //      indicating where oops are located in instances of this klass.
  55 //    [EMBEDDED implementor of the interface] only exist for interface
  56 //    [EMBEDDED unsafe_anonymous_host klass] only exist for an unsafe anonymous class (JSR 292 enabled)
  57 //    [EMBEDDED fingerprint       ] only if should_store_fingerprint()==true
  58 //    [EMBEDDED inline_type_field_klasses] only if has_inline_fields() == true
  59 //    [EMBEDDED InlineKlassFixedBlock] only if is a InlineKlass instance
  60 
  61 
  62 // forward declaration for class -- see below for definition
  63 #if INCLUDE_JVMTI
  64 class BreakpointInfo;
  65 #endif
  66 class ClassFileParser;
  67 class ClassFileStream;
  68 class KlassDepChange;
  69 class DependencyContext;
  70 class fieldDescriptor;
  71 class jniIdMapBase;
  72 class JNIid;
  73 class JvmtiCachedClassFieldMap;
  74 class nmethodBucket;
  75 class OopMapCache;
  76 class BufferedValueTypeBlob;
  77 class InterpreterOopMap;
  78 class PackageEntry;
  79 class ModuleEntry;
  80 
  81 // This is used in iterators below.
  82 class FieldClosure: public StackObj {
  83 public:
  84   virtual void do_field(fieldDescriptor* fd) = 0;
  85 };
  86 
  87 #ifndef PRODUCT
  88 // Print fields.
  89 // If &quot;obj&quot; argument to constructor is NULL, prints static fields, otherwise prints non-static fields.
  90 class FieldPrinter: public FieldClosure {
  91    oop _obj;
  92    outputStream* _st;
  93  public:
  94    FieldPrinter(outputStream* st, oop obj = NULL) : _obj(obj), _st(st) {}
  95    void do_field(fieldDescriptor* fd);
  96 };
  97 #endif  // !PRODUCT
  98 
  99 // Describes where oops are located in instances of this klass.
 100 class OopMapBlock {
 101  public:
 102   // Byte offset of the first oop mapped by this block.
 103   int offset() const          { return _offset; }
 104   void set_offset(int offset) { _offset = offset; }
 105 
 106   // Number of oops in this block.
 107   uint count() const         { return _count; }
 108   void set_count(uint count) { _count = count; }
 109 
 110   void increment_count(int diff) { _count += diff; }
 111 
 112   int offset_span() const { return _count * heapOopSize; }
 113 
 114   int end_offset() const {
 115     return offset() + offset_span();
 116   }
 117 
 118   bool is_contiguous(int another_offset) const {
 119     return another_offset == end_offset();
 120   }
 121 
 122   // sizeof(OopMapBlock) in words.
 123   static const int size_in_words() {
 124     return align_up((int)sizeof(OopMapBlock), wordSize) &gt;&gt;
 125       LogBytesPerWord;
 126   }
 127 
 128   static int compare_offset(const OopMapBlock* a, const OopMapBlock* b) {
 129     return a-&gt;offset() - b-&gt;offset();
 130   }
 131 
 132  private:
 133   int  _offset;
 134   uint _count;
 135 };
 136 
 137 struct JvmtiCachedClassFileData;
 138 
 139 class SigEntry;
 140 
 141 class InlineKlassFixedBlock {
 142   Array&lt;SigEntry&gt;** _extended_sig;
 143   Array&lt;VMRegPair&gt;** _return_regs;
 144   address* _pack_handler;
 145   address* _pack_handler_jobject;
 146   address* _unpack_handler;
 147   int* _default_value_offset;
 148   Klass** _flat_array_klass;
 149   int _alignment;
 150   int _first_field_offset;
 151   int _exact_size_in_bytes;
 152 
 153   friend class InlineKlass;
 154 };
 155 
 156 class InstanceKlass: public Klass {
 157   friend class VMStructs;
 158   friend class JVMCIVMStructs;
 159   friend class ClassFileParser;
 160   friend class CompileReplay;
 161   friend class TemplateTable;
 162 
 163  public:
 164   static const KlassID ID = InstanceKlassID;
 165 
 166  protected:
 167   InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id = ID);
 168 
 169  public:
 170   InstanceKlass() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for CDS&quot;); }
 171 
 172   // See &quot;The Java Virtual Machine Specification&quot; section 2.16.2-5 for a detailed description
 173   // of the class loading &amp; initialization procedure, and the use of the states.
 174   enum ClassState {
 175     allocated,                          // allocated (but not yet linked)
 176     loaded,                             // loaded and inserted in class hierarchy (but not linked yet)
 177     linked,                             // successfully linked/verified (but not initialized yet)
 178     being_initialized,                  // currently running class initializer
 179     fully_initialized,                  // initialized (successful final state)
 180     initialization_error                // error happened during initialization
 181   };
 182 
 183  private:
 184   static InstanceKlass* allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS);
 185 
 186  protected:
 187   // If you add a new field that points to any metaspace object, you
 188   // must add this field to InstanceKlass::metaspace_pointers_do().
 189 
 190   // Annotations for this class
 191   Annotations*    _annotations;
 192   // Package this class is defined in
 193   PackageEntry*   _package_entry;
 194   // Array classes holding elements of this class.
 195   ObjArrayKlass* volatile _array_klasses;
 196   // Constant pool for this class.
 197   ConstantPool* _constants;
 198   // The InnerClasses attribute and EnclosingMethod attribute. The
 199   // _inner_classes is an array of shorts. If the class has InnerClasses
 200   // attribute, then the _inner_classes array begins with 4-tuples of shorts
 201   // [inner_class_info_index, outer_class_info_index,
 202   // inner_name_index, inner_class_access_flags] for the InnerClasses
 203   // attribute. If the EnclosingMethod attribute exists, it occupies the
 204   // last two shorts [class_index, method_index] of the array. If only
 205   // the InnerClasses attribute exists, the _inner_classes array length is
 206   // number_of_inner_classes * 4. If the class has both InnerClasses
 207   // and EnclosingMethod attributes the _inner_classes array length is
 208   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 209   Array&lt;jushort&gt;* _inner_classes;
 210 
 211   // The NestMembers attribute. An array of shorts, where each is a
 212   // class info index for the class that is a nest member. This data
 213   // has not been validated.
 214   Array&lt;jushort&gt;* _nest_members;
 215 
 216   // Resolved nest-host klass: either true nest-host or self if we are not
 217   // nested, or an error occurred resolving or validating the nominated
 218   // nest-host. Can also be set directly by JDK API&#39;s that establish nest
 219   // relationships.
 220   // By always being set it makes nest-member access checks simpler.
 221   InstanceKlass* _nest_host;
 222 
 223   // The PermittedSubclasses attribute. An array of shorts, where each is a
 224   // class info index for the class that is a permitted subclass.
 225   Array&lt;jushort&gt;* _permitted_subclasses;
 226 
 227   // The contents of the Record attribute.
 228   Array&lt;RecordComponent*&gt;* _record_components;
 229 
 230   // the source debug extension for this klass, NULL if not specified.
 231   // Specified as UTF-8 string without terminating zero byte in the classfile,
 232   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 233   const char*     _source_debug_extension;
 234 
 235   // Number of heapOopSize words used by non-static fields in this klass
 236   // (including inherited fields but after header_size()).
 237   int             _nonstatic_field_size;
 238   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 239 
 240   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 241   int             _itable_len;           // length of Java itable (in words)
 242 
 243   // The NestHost attribute. The class info index for the class
 244   // that is the nest-host of this class. This data has not been validated.
 245   u2              _nest_host_index;
 246   u2              _this_class_index;              // constant pool entry
 247 
 248   u2              _static_oop_field_count;// number of static oop fields in this klass
 249   u2              _java_fields_count;    // The number of declared Java fields
 250 
 251   volatile u2     _idnum_allocated_count;         // JNI/JVMTI: increments with the addition of methods, old ids don&#39;t change
 252 
 253   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 254   // _misc_flags.
 255   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
 256 
 257   // Class states are defined as ClassState (see above).
 258   // Place the _init_state here to utilize the unused 2-byte after
 259   // _idnum_allocated_count.
 260   u1              _init_state;                    // state of class
 261 
 262   // This can be used to quickly discriminate among the five kinds of
 263   // InstanceKlass. This should be an enum (?)
 264   static const unsigned _kind_other        = 0; // concrete InstanceKlass
 265   static const unsigned _kind_reference    = 1; // InstanceRefKlass
 266   static const unsigned _kind_class_loader = 2; // InstanceClassLoaderKlass
 267   static const unsigned _kind_mirror       = 3; // InstanceMirrorKlass
 268   static const unsigned _kind_inline_type  = 4; // InlineKlass
 269 
 270   u1              _reference_type;                // reference type
 271   u1              _kind;                          // kind of InstanceKlass
 272 
 273   enum {
 274     _misc_rewritten                           = 1 &lt;&lt; 0,  // methods rewritten.
 275     _misc_has_nonstatic_fields                = 1 &lt;&lt; 1,  // for sizing with UseCompressedOops
 276     _misc_should_verify_class                 = 1 &lt;&lt; 2,  // allow caching of preverification
 277     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 3,  // has embedded _unsafe_anonymous_host field
 278     _misc_is_contended                        = 1 &lt;&lt; 4,  // marked with contended annotation
 279     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 5,  // class/superclass/implemented interfaces has non-static, concrete methods
 280     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 6,  // directly declares non-static, concrete methods
 281     _misc_has_been_redefined                  = 1 &lt;&lt; 7,  // class has been redefined
 282     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 8,  // when this class was loaded, the fingerprint computed from its
 283                                                          // code source was found to be matching the value recorded by AOT.
 284     _misc_is_scratch_class                    = 1 &lt;&lt; 9,  // class is the redefined scratch class
 285     _misc_is_shared_boot_class                = 1 &lt;&lt; 10, // defining class loader is boot class loader
 286     _misc_is_shared_platform_class            = 1 &lt;&lt; 11, // defining class loader is platform class loader
 287     _misc_is_shared_app_class                 = 1 &lt;&lt; 12, // defining class loader is app class loader
 288     _misc_has_resolved_methods                = 1 &lt;&lt; 13, // resolved methods table entries added for this class
 289     _misc_is_being_redefined                  = 1 &lt;&lt; 14, // used for locking redefinition
 290     _misc_has_contended_annotations           = 1 &lt;&lt; 15,  // has @Contended annotation
 291     _misc_has_inline_type_fields              = 1 &lt;&lt; 16, // has inline fields and related embedded section is not empty
 292     _misc_is_empty_inline_type                = 1 &lt;&lt; 17, // empty inline type
 293     _misc_is_naturally_atomic                 = 1 &lt;&lt; 18, // loaded/stored in one instruction
 294     _misc_is_declared_atomic                  = 1 &lt;&lt; 19, // implements jl.NonTearable
 295     _misc_invalid_inline_super                = 1 &lt;&lt; 20, // invalid super type for an inline type
 296     _misc_invalid_identity_super              = 1 &lt;&lt; 21, // invalid super type for an identity type
 297     _misc_has_injected_identityObject         = 1 &lt;&lt; 22  // IdentityObject has been injected by the JVM
 298   };
 299   u2 shared_loader_type_bits() const {
 300     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 301   }
 302   u4              _misc_flags;           // There is more space in access_flags for more flags.
 303 
 304   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)
 305   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 306   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 307   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 308   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 309   uint64_t        volatile _dep_context_last_cleaned;
 310   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 311 #if INCLUDE_JVMTI
 312   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 313   // Linked instanceKlasses of previous versions
 314   InstanceKlass* _previous_versions;
 315   // JVMTI fields can be moved to their own structure - see 6315920
 316   // JVMTI: cached class file, before retransformable agent modified it in CFLH
 317   JvmtiCachedClassFileData* _cached_class_file;
 318 #endif
 319 
 320 #if INCLUDE_JVMTI
 321   JvmtiCachedClassFieldMap* _jvmti_cached_class_field_map;  // JVMTI: used during heap iteration
 322 #endif
 323 
 324   NOT_PRODUCT(int _verify_count;)  // to avoid redundant verifies
 325 
 326   // Method array.
 327   Array&lt;Method*&gt;* _methods;
 328   // Default Method Array, concrete methods inherited from interfaces
 329   Array&lt;Method*&gt;* _default_methods;
 330   // Interfaces (InstanceKlass*s) this class declares locally to implement.
 331   Array&lt;InstanceKlass*&gt;* _local_interfaces;
 332   // Interfaces (InstanceKlass*s) this class implements transitively.
 333   Array&lt;InstanceKlass*&gt;* _transitive_interfaces;
 334   // Int array containing the original order of method in the class file (for JVMTI).
 335   Array&lt;int&gt;*     _method_ordering;
 336   // Int array containing the vtable_indices for default_methods
 337   // offset matches _default_methods offset
 338   Array&lt;int&gt;*     _default_vtable_indices;
 339 
 340   // Instance and static variable information, starts with 6-tuples of shorts
 341   // [access, name index, sig index, initval index, low_offset, high_offset]
 342   // for all fields, followed by the generic signature data at the end of
 343   // the array. Only fields with generic signature attributes have the generic
 344   // signature data set in the array. The fields array looks like following:
 345   //
 346   // f1: [access, name index, sig index, initial value index, low_offset, high_offset]
 347   // f2: [access, name index, sig index, initial value index, low_offset, high_offset]
 348   //      ...
 349   // fn: [access, name index, sig index, initial value index, low_offset, high_offset]
 350   //     [generic signature index]
 351   //     [generic signature index]
 352   //     ...
 353   Array&lt;u2&gt;*      _fields;
 354   const Klass**   _inline_type_field_klasses; // For &quot;inline class&quot; fields, NULL if none present
 355 
 356   const InlineKlassFixedBlock* _adr_inlineklass_fixed_block;
 357 
 358   // embedded Java vtable follows here
 359   // embedded Java itables follows here
 360   // embedded static fields follows here
 361   // embedded nonstatic oop-map blocks follows here
 362   // embedded implementor of this interface follows here
 363   //   The embedded implementor only exists if the current klass is an
 364   //   iterface. The possible values of the implementor fall into following
 365   //   three cases:
 366   //     NULL: no implementor.
 367   //     A Klass* that&#39;s not itself: one implementor.
 368   //     Itself: more than one implementors.
 369   // embedded unsafe_anonymous_host klass follows here
 370   //   The embedded host klass only exists in an unsafe anonymous class for
 371   //   dynamic language support (JSR 292 enabled). The host class grants
 372   //   its access privileges to this class also. The host class is either
 373   //   named, or a previously loaded unsafe anonymous class. A non-anonymous class
 374   //   or an anonymous class loaded through normal classloading does not
 375   //   have this embedded field.
 376   //
 377 
 378   friend class SystemDictionary;
 379 
 380   static bool _disable_method_binary_search;
 381 
 382  public:
 383   // The three BUILTIN class loader types
 384   bool is_shared_boot_class() const {
 385     return (_misc_flags &amp; _misc_is_shared_boot_class) != 0;
 386   }
 387   bool is_shared_platform_class() const {
 388     return (_misc_flags &amp; _misc_is_shared_platform_class) != 0;
 389   }
 390   bool is_shared_app_class() const {
 391     return (_misc_flags &amp; _misc_is_shared_app_class) != 0;
 392   }
 393   // The UNREGISTERED class loader type
 394   bool is_shared_unregistered_class() const {
 395     return (_misc_flags &amp; shared_loader_type_bits()) == 0;
 396   }
 397 
 398   void clear_shared_class_loader_type() {
 399     _misc_flags &amp;= ~shared_loader_type_bits();
 400   }
 401 
 402   void set_shared_class_loader_type(s2 loader_type);
 403 
 404   void assign_class_loader_type();
 405 
 406   bool has_nonstatic_fields() const        {
 407     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 408   }
 409   void set_has_nonstatic_fields(bool b)    {
 410     if (b) {
 411       _misc_flags |= _misc_has_nonstatic_fields;
 412     } else {
 413       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 414     }
 415   }
 416 
 417   bool has_inline_type_fields() const          {
 418     return (_misc_flags &amp; _misc_has_inline_type_fields) != 0;
 419   }
 420   void set_has_inline_type_fields()  {
 421     _misc_flags |= _misc_has_inline_type_fields;
 422   }
 423 
 424   bool is_empty_inline_type() const {
 425     return (_misc_flags &amp; _misc_is_empty_inline_type) != 0;
 426   }
 427   void set_is_empty_inline_type() {
 428     _misc_flags |= _misc_is_empty_inline_type;
 429   }
 430 
 431   // Note:  The naturally_atomic property only applies to
 432   // inline classes; it is never true on identity classes.
 433   // The bit is placed on instanceKlass for convenience.
 434 
 435   // Query if h/w provides atomic load/store for instances.
 436   bool is_naturally_atomic() const {
 437     return (_misc_flags &amp; _misc_is_naturally_atomic) != 0;
 438   }
 439   // Initialized in the class file parser, not changed later.
 440   void set_is_naturally_atomic() {
 441     _misc_flags |= _misc_is_naturally_atomic;
 442   }
 443 
 444   // Query if this class implements jl.NonTearable or was
 445   // mentioned in the JVM option AlwaysAtomicValueTypes.
 446   // This bit can occur anywhere, but is only significant
 447   // for inline classes *and* their super types.
 448   // It inherits from supers along with NonTearable.
 449   bool is_declared_atomic() const {
 450     return (_misc_flags &amp; _misc_is_declared_atomic) != 0;
 451   }
 452   // Initialized in the class file parser, not changed later.
 453   void set_is_declared_atomic() {
 454     _misc_flags |= _misc_is_declared_atomic;
 455   }
 456 
 457   // Query if class is an invalid super class for an inline type.
 458   bool invalid_inline_super() const {
 459     return (_misc_flags &amp; _misc_invalid_inline_super) != 0;
 460   }
 461   // Initialized in the class file parser, not changed later.
 462   void set_invalid_inline_super() {
 463     _misc_flags |= _misc_invalid_inline_super;
 464   }
 465   // Query if class is an invalid super class for an identity type.
 466   bool invalid_identity_super() const {
 467     return (_misc_flags &amp; _misc_invalid_identity_super) != 0;
 468   }
 469   // Initialized in the class file parser, not changed later.
 470   void set_invalid_identity_super() {
 471     _misc_flags |= _misc_invalid_identity_super;
 472   }
 473 
 474   bool has_injected_identityObject() const {
 475     return (_misc_flags &amp; _misc_has_injected_identityObject);
 476   }
 477 
 478   void set_has_injected_identityObject() {
 479     _misc_flags |= _misc_has_injected_identityObject;
 480   }
 481 
 482   // field sizes
 483   int nonstatic_field_size() const         { return _nonstatic_field_size; }
 484   void set_nonstatic_field_size(int size)  { _nonstatic_field_size = size; }
 485 
 486   int static_field_size() const            { return _static_field_size; }
 487   void set_static_field_size(int size)     { _static_field_size = size; }
 488 
 489   int static_oop_field_count() const       { return (int)_static_oop_field_count; }
 490   void set_static_oop_field_count(u2 size) { _static_oop_field_count = size; }
 491 
 492   // Java itable
 493   int  itable_length() const               { return _itable_len; }
 494   void set_itable_length(int len)          { _itable_len = len; }
 495 
 496   // array klasses
 497   ObjArrayKlass* array_klasses() const     { return _array_klasses; }
 498   inline ObjArrayKlass* array_klasses_acquire() const; // load with acquire semantics
 499   void set_array_klasses(ObjArrayKlass* k) { _array_klasses = k; }
 500   inline void release_set_array_klasses(ObjArrayKlass* k); // store with release semantics
 501 
 502   // methods
 503   Array&lt;Method*&gt;* methods() const          { return _methods; }
 504   void set_methods(Array&lt;Method*&gt;* a)      { _methods = a; }
 505   Method* method_with_idnum(int idnum);
 506   Method* method_with_orig_idnum(int idnum);
 507   Method* method_with_orig_idnum(int idnum, int version);
 508 
 509   // method ordering
 510   Array&lt;int&gt;* method_ordering() const     { return _method_ordering; }
 511   void set_method_ordering(Array&lt;int&gt;* m) { _method_ordering = m; }
 512   void copy_method_ordering(const intArray* m, TRAPS);
 513 
 514   // default_methods
 515   Array&lt;Method*&gt;* default_methods() const  { return _default_methods; }
 516   void set_default_methods(Array&lt;Method*&gt;* a) { _default_methods = a; }
 517 
 518   // default method vtable_indices
 519   Array&lt;int&gt;* default_vtable_indices() const { return _default_vtable_indices; }
 520   void set_default_vtable_indices(Array&lt;int&gt;* v) { _default_vtable_indices = v; }
 521   Array&lt;int&gt;* create_new_default_vtable_indices(int len, TRAPS);
 522 
 523   // interfaces
 524   Array&lt;InstanceKlass*&gt;* local_interfaces() const          { return _local_interfaces; }
 525   void set_local_interfaces(Array&lt;InstanceKlass*&gt;* a)      {
 526     guarantee(_local_interfaces == NULL || a == NULL, &quot;Just checking&quot;);
 527     _local_interfaces = a; }
 528 
 529   Array&lt;InstanceKlass*&gt;* transitive_interfaces() const     { return _transitive_interfaces; }
 530   void set_transitive_interfaces(Array&lt;InstanceKlass*&gt;* a) {
 531     guarantee(_transitive_interfaces == NULL || a == NULL, &quot;Just checking&quot;);
 532     _transitive_interfaces = a;
 533   }
 534 
 535  private:
 536   friend class fieldDescriptor;
 537   FieldInfo* field(int index) const { return FieldInfo::from_field_array(_fields, index); }
 538 
 539  public:
 540   int     field_offset      (int index) const { return field(index)-&gt;offset(); }
 541   int     field_access_flags(int index) const { return field(index)-&gt;access_flags(); }
 542   Symbol* field_name        (int index) const { return field(index)-&gt;name(constants()); }
 543   Symbol* field_signature   (int index) const { return field(index)-&gt;signature(constants()); }
 544   bool    field_is_inlined(int index) const { return field(index)-&gt;is_inlined(); }
 545   bool    field_is_inline_type(int index) const;
 546 
 547   // Number of Java declared fields
 548   int java_fields_count() const           { return (int)_java_fields_count; }
 549 
 550   Array&lt;u2&gt;* fields() const            { return _fields; }
 551   void set_fields(Array&lt;u2&gt;* f, u2 java_fields_count) {
 552     guarantee(_fields == NULL || f == NULL, &quot;Just checking&quot;);
 553     _fields = f;
 554     _java_fields_count = java_fields_count;
 555   }
 556 
 557   // inner classes
 558   Array&lt;u2&gt;* inner_classes() const       { return _inner_classes; }
 559   void set_inner_classes(Array&lt;u2&gt;* f)   { _inner_classes = f; }
 560 
 561   // nest members
 562   Array&lt;u2&gt;* nest_members() const     { return _nest_members; }
 563   void set_nest_members(Array&lt;u2&gt;* m) { _nest_members = m; }
 564 
 565   // nest-host index
 566   jushort nest_host_index() const { return _nest_host_index; }
 567   void set_nest_host_index(u2 i)  { _nest_host_index = i; }
 568   // dynamic nest member support
 569   void set_nest_host(InstanceKlass* host, TRAPS);
 570 
 571   // record components
 572   Array&lt;RecordComponent*&gt;* record_components() const { return _record_components; }
 573   void set_record_components(Array&lt;RecordComponent*&gt;* record_components) {
 574     _record_components = record_components;
 575   }
 576   bool is_record() const { return _record_components != NULL; }
 577 
 578   // permitted subclasses
 579   Array&lt;u2&gt;* permitted_subclasses() const     { return _permitted_subclasses; }
 580   void set_permitted_subclasses(Array&lt;u2&gt;* s) { _permitted_subclasses = s; }
 581 
 582 private:
 583   // Called to verify that k is a member of this nest - does not look at k&#39;s nest-host
 584   bool has_nest_member(InstanceKlass* k, TRAPS) const;
 585 
 586 public:
 587   // Used to construct informative IllegalAccessError messages at a higher level,
 588   // if there was an issue resolving or validating the nest host.
 589   // Returns NULL if there was no error.
 590   const char* nest_host_error(TRAPS);
 591   // Returns nest-host class, resolving and validating it if needed.
 592   // Returns NULL if resolution is not possible from the calling context.
 593   InstanceKlass* nest_host(TRAPS);
 594   // Check if this klass is a nestmate of k - resolves this nest-host and k&#39;s
 595   bool has_nestmate_access_to(InstanceKlass* k, TRAPS);
 596 
 597   // Called to verify that k is a permitted subclass of this class
 598   bool has_as_permitted_subclass(const InstanceKlass* k) const;
 599 
 600   enum InnerClassAttributeOffset {
 601     // From http://mirror.eng/products/jdk/1.1/docs/guide/innerclasses/spec/innerclasses.doc10.html#18814
 602     inner_class_inner_class_info_offset = 0,
 603     inner_class_outer_class_info_offset = 1,
 604     inner_class_inner_name_offset = 2,
 605     inner_class_access_flags_offset = 3,
 606     inner_class_next_offset = 4
 607   };
 608 
 609   enum EnclosingMethodAttributeOffset {
 610     enclosing_method_class_index_offset = 0,
 611     enclosing_method_method_index_offset = 1,
 612     enclosing_method_attribute_size = 2
 613   };
 614 
 615   // method override check
 616   bool is_override(const methodHandle&amp; super_method, Handle targetclassloader, Symbol* targetclassname, TRAPS);
 617 
 618   // package
 619   PackageEntry* package() const     { return _package_entry; }
 620   ModuleEntry* module() const;
 621   bool in_unnamed_package() const   { return (_package_entry == NULL); }
 622   void set_package(ClassLoaderData* loader_data, PackageEntry* pkg_entry, TRAPS);
 623   // If the package for the InstanceKlass is in the boot loader&#39;s package entry
 624   // table then sets the classpath_index field so that
 625   // get_system_package() will know to return a non-null value for the
 626   // package&#39;s location.  And, so that the package will be added to the list of
 627   // packages returned by get_system_packages().
 628   // For packages whose classes are loaded from the boot loader class path, the
 629   // classpath_index indicates which entry on the boot loader class path.
 630   void set_classpath_index(s2 path_index, TRAPS);
 631   bool is_same_class_package(const Klass* class2) const;
 632   bool is_same_class_package(oop other_class_loader, const Symbol* other_class_name) const;
 633 
 634   // find an enclosing class
 635   InstanceKlass* compute_enclosing_class(bool* inner_is_member, TRAPS) const;
 636 
 637   // Find InnerClasses attribute and return outer_class_info_index &amp; inner_name_index.
 638   bool find_inner_classes_attr(int* ooff, int* noff, TRAPS) const;
 639 
 640  private:
 641   // Check prohibited package (&quot;java/&quot; only loadable by boot or platform loaders)
 642   static void check_prohibited_package(Symbol* class_name,
 643                                        ClassLoaderData* loader_data,
 644                                        TRAPS);
 645  public:
 646   // initialization state
 647   bool is_loaded() const                   { return _init_state &gt;= loaded; }
 648   bool is_linked() const                   { return _init_state &gt;= linked; }
 649   bool is_initialized() const              { return _init_state == fully_initialized; }
 650   bool is_not_initialized() const          { return _init_state &lt;  being_initialized; }
 651   bool is_being_initialized() const        { return _init_state == being_initialized; }
 652   bool is_in_error_state() const           { return _init_state == initialization_error; }
 653   bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }
 654   ClassState  init_state()                 { return (ClassState)_init_state; }
 655   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 656 
 657   // is this a sealed class
 658   bool is_sealed() const;
 659 
 660   // defineClass specified verification
 661   bool should_verify_class() const         {
 662     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 663   }
 664   void set_should_verify_class(bool value) {
 665     if (value) {
 666       _misc_flags |= _misc_should_verify_class;
 667     } else {
 668       _misc_flags &amp;= ~_misc_should_verify_class;
 669     }
 670   }
 671 
 672   // marking
 673   bool is_marked_dependent() const         { return _is_marked_dependent; }
 674   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 675 
 676   static ByteSize kind_offset() { return in_ByteSize(offset_of(InstanceKlass, _kind)); }
 677   static ByteSize misc_flags_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_flags)); }
 678   static u4 misc_flags_is_empty_inline_type() { return _misc_is_empty_inline_type; }
 679 
 680   // initialization (virtuals from Klass)
 681   bool should_be_initialized() const;  // means that initialize should be called
 682   void initialize(TRAPS);
 683   void link_class(TRAPS);
 684   bool link_class_or_fail(TRAPS); // returns false on failure
 685   void rewrite_class(TRAPS);
 686   void link_methods(TRAPS);
 687   Method* class_initializer() const;
 688 
 689   // set the class to initialized if no static initializer is present
 690   void eager_initialize(Thread *thread);
 691 
 692   // reference type
 693   ReferenceType reference_type() const     { return (ReferenceType)_reference_type; }
 694   void set_reference_type(ReferenceType t) {
 695     assert(t == (u1)t, &quot;overflow&quot;);
 696     _reference_type = (u1)t;
 697   }
 698 
 699   // this class cp index
 700   u2 this_class_index() const             { return _this_class_index; }
 701   void set_this_class_index(u2 index)     { _this_class_index = index; }
 702 
 703   static ByteSize reference_type_offset() { return in_ByteSize(offset_of(InstanceKlass, _reference_type)); }
 704 
 705   // find local field, returns true if found
 706   bool find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 707   // find field in direct superinterfaces, returns the interface in which the field is defined
 708   Klass* find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 709   // find field according to JVM spec 5.4.3.2, returns the klass in which the field is defined
 710   Klass* find_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 711   // find instance or static fields according to JVM spec 5.4.3.2, returns the klass in which the field is defined
 712   Klass* find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const;
 713 
 714   // find a non-static or static field given its offset within the class.
 715   bool contains_field_offset(int offset);
 716 
 717   bool find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
 718   bool find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
 719 
 720  private:
 721   inline static int quick_search(const Array&lt;Method*&gt;* methods, const Symbol* name);
 722 
 723  public:
 724   static void disable_method_binary_search() {
 725     _disable_method_binary_search = true;
 726   }
 727 
 728   // find a local method (returns NULL if not found)
 729   Method* find_method(const Symbol* name, const Symbol* signature) const;
 730   static Method* find_method(const Array&lt;Method*&gt;* methods,
 731                              const Symbol* name,
 732                              const Symbol* signature);
 733 
 734   // find a local method, but skip static methods
 735   Method* find_instance_method(const Symbol* name, const Symbol* signature,
 736                                PrivateLookupMode private_mode) const;
 737   static Method* find_instance_method(const Array&lt;Method*&gt;* methods,
 738                                       const Symbol* name,
 739                                       const Symbol* signature,
 740                                       PrivateLookupMode private_mode);
 741 
 742   // find a local method (returns NULL if not found)
 743   Method* find_local_method(const Symbol* name,
 744                             const Symbol* signature,
 745                             OverpassLookupMode overpass_mode,
 746                             StaticLookupMode static_mode,
 747                             PrivateLookupMode private_mode) const;
 748 
 749   // find a local method from given methods array (returns NULL if not found)
 750   static Method* find_local_method(const Array&lt;Method*&gt;* methods,
 751                                    const Symbol* name,
 752                                    const Symbol* signature,
 753                                    OverpassLookupMode overpass_mode,
 754                                    StaticLookupMode static_mode,
 755                                    PrivateLookupMode private_mode);
 756 
 757   // find a local method index in methods or default_methods (returns -1 if not found)
 758   static int find_method_index(const Array&lt;Method*&gt;* methods,
 759                                const Symbol* name,
 760                                const Symbol* signature,
 761                                OverpassLookupMode overpass_mode,
 762                                StaticLookupMode static_mode,
 763                                PrivateLookupMode private_mode);
 764 
 765   // lookup operation (returns NULL if not found)
 766   Method* uncached_lookup_method(const Symbol* name,
 767                                  const Symbol* signature,
 768                                  OverpassLookupMode overpass_mode,
 769                                  PrivateLookupMode private_mode = find_private) const;
 770 
 771   // lookup a method in all the interfaces that this class implements
 772   // (returns NULL if not found)
 773   Method* lookup_method_in_all_interfaces(Symbol* name, Symbol* signature, DefaultsLookupMode defaults_mode) const;
 774 
 775   // lookup a method in local defaults then in all interfaces
 776   // (returns NULL if not found)
 777   Method* lookup_method_in_ordered_interfaces(Symbol* name, Symbol* signature) const;
 778 
 779   // Find method indices by name.  If a method with the specified name is
 780   // found the index to the first method is returned, and &#39;end&#39; is filled in
 781   // with the index of first non-name-matching method.  If no method is found
 782   // -1 is returned.
 783   int find_method_by_name(const Symbol* name, int* end) const;
 784   static int find_method_by_name(const Array&lt;Method*&gt;* methods,
 785                                  const Symbol* name, int* end);
 786 
 787   // constant pool
 788   ConstantPool* constants() const        { return _constants; }
 789   void set_constants(ConstantPool* c)    { _constants = c; }
 790 
 791   // protection domain
 792   oop protection_domain() const;
 793 
 794   // signers
 795   objArrayOop signers() const;
 796 
 797   // host class
 798   InstanceKlass* unsafe_anonymous_host() const {
 799     InstanceKlass** hk = adr_unsafe_anonymous_host();
 800     if (hk == NULL) {
 801       assert(!is_unsafe_anonymous(), &quot;Unsafe anonymous classes have host klasses&quot;);
 802       return NULL;
 803     } else {
 804       assert(*hk != NULL, &quot;host klass should always be set if the address is not null&quot;);
 805       assert(is_unsafe_anonymous(), &quot;Only unsafe anonymous classes have host klasses&quot;);
 806       return *hk;
 807     }
 808   }
 809   void set_unsafe_anonymous_host(const InstanceKlass* host) {
 810     assert(is_unsafe_anonymous(), &quot;not unsafe anonymous&quot;);
 811     const InstanceKlass** addr = (const InstanceKlass **)adr_unsafe_anonymous_host();
 812     assert(addr != NULL, &quot;no reversed space&quot;);
 813     if (addr != NULL) {
 814       *addr = host;
 815     }
 816   }
 817   bool is_unsafe_anonymous() const                {
 818     return (_misc_flags &amp; _misc_is_unsafe_anonymous) != 0;
 819   }
 820   void set_is_unsafe_anonymous(bool value)        {
 821     if (value) {
 822       _misc_flags |= _misc_is_unsafe_anonymous;
 823     } else {
 824       _misc_flags &amp;= ~_misc_is_unsafe_anonymous;
 825     }
 826   }
 827 
 828   bool is_contended() const                {
 829     return (_misc_flags &amp; _misc_is_contended) != 0;
 830   }
 831   void set_is_contended(bool value)        {
 832     if (value) {
 833       _misc_flags |= _misc_is_contended;
 834     } else {
 835       _misc_flags &amp;= ~_misc_is_contended;
 836     }
 837   }
 838 
 839   // source file name
 840   Symbol* source_file_name() const               { return _constants-&gt;source_file_name(); }
 841   u2 source_file_name_index() const              { return _constants-&gt;source_file_name_index(); }
 842   void set_source_file_name_index(u2 sourcefile_index) { _constants-&gt;set_source_file_name_index(sourcefile_index); }
 843 
 844   // minor and major version numbers of class file
 845   u2 minor_version() const                 { return _constants-&gt;minor_version(); }
 846   void set_minor_version(u2 minor_version) { _constants-&gt;set_minor_version(minor_version); }
 847   u2 major_version() const                 { return _constants-&gt;major_version(); }
 848   void set_major_version(u2 major_version) { _constants-&gt;set_major_version(major_version); }
 849 
 850   // source debug extension
 851   const char* source_debug_extension() const { return _source_debug_extension; }
 852   void set_source_debug_extension(const char* array, int length);
 853 
 854   // nonstatic oop-map blocks
 855   static int nonstatic_oop_map_size(unsigned int oop_map_count) {
 856     return oop_map_count * OopMapBlock::size_in_words();
 857   }
 858   unsigned int nonstatic_oop_map_count() const {
 859     return _nonstatic_oop_map_size / OopMapBlock::size_in_words();
 860   }
 861   int nonstatic_oop_map_size() const { return _nonstatic_oop_map_size; }
 862   void set_nonstatic_oop_map_size(int words) {
 863     _nonstatic_oop_map_size = words;
 864   }
 865 
 866   bool has_contended_annotations() const {
 867     return ((_misc_flags &amp; _misc_has_contended_annotations) != 0);
 868   }
 869   void set_has_contended_annotations(bool value)  {
 870     if (value) {
 871       _misc_flags |= _misc_has_contended_annotations;
 872     } else {
 873       _misc_flags &amp;= ~_misc_has_contended_annotations;
 874     }
 875   }
 876 
 877 #if INCLUDE_JVMTI
 878   // Redefinition locking.  Class can only be redefined by one thread at a time.
 879 
 880   bool is_being_redefined() const          {
 881     return (_misc_flags &amp; _misc_is_being_redefined);
 882   }
 883   void set_is_being_redefined(bool value)  {
 884     if (value) {
 885       _misc_flags |= _misc_is_being_redefined;
 886     } else {
 887       _misc_flags &amp;= ~_misc_is_being_redefined;
 888     }
 889   }
 890 
 891   // RedefineClasses() support for previous versions:
 892   void add_previous_version(InstanceKlass* ik, int emcp_method_count);
 893   void purge_previous_version_list();
 894 
 895   InstanceKlass* previous_versions() const { return _previous_versions; }
 896 #else
 897   InstanceKlass* previous_versions() const { return NULL; }
 898 #endif
 899 
 900   InstanceKlass* get_klass_version(int version) {
 901     for (InstanceKlass* ik = this; ik != NULL; ik = ik-&gt;previous_versions()) {
 902       if (ik-&gt;constants()-&gt;version() == version) {
 903         return ik;
 904       }
 905     }
 906     return NULL;
 907   }
 908 
 909   bool has_been_redefined() const {
 910     return (_misc_flags &amp; _misc_has_been_redefined) != 0;
 911   }
 912   void set_has_been_redefined() {
 913     _misc_flags |= _misc_has_been_redefined;
 914   }
 915 
 916   bool has_passed_fingerprint_check() const {
 917     return (_misc_flags &amp; _misc_has_passed_fingerprint_check) != 0;
 918   }
 919   void set_has_passed_fingerprint_check(bool b) {
 920     if (b) {
 921       _misc_flags |= _misc_has_passed_fingerprint_check;
 922     } else {
 923       _misc_flags &amp;= ~_misc_has_passed_fingerprint_check;
 924     }
 925   }
 926   bool supers_have_passed_fingerprint_checks();
 927 
 928   static bool should_store_fingerprint(bool is_hidden_or_anonymous);
 929   bool should_store_fingerprint() const { return should_store_fingerprint(is_hidden() || is_unsafe_anonymous()); }
 930   bool has_stored_fingerprint() const;
 931   uint64_t get_stored_fingerprint() const;
 932   void store_fingerprint(uint64_t fingerprint);
 933 
 934   bool is_scratch_class() const {
 935     return (_misc_flags &amp; _misc_is_scratch_class) != 0;
 936   }
 937 
 938   void set_is_scratch_class() {
 939     _misc_flags |= _misc_is_scratch_class;
 940   }
 941 
 942   bool has_resolved_methods() const {
 943     return (_misc_flags &amp; _misc_has_resolved_methods) != 0;
 944   }
 945 
 946   void set_has_resolved_methods() {
 947     _misc_flags |= _misc_has_resolved_methods;
 948   }
 949 private:
 950 
 951   void set_kind(unsigned kind) {
 952     _kind = (u1)kind;
 953   }
 954 
 955   bool is_kind(unsigned desired) const {
 956     return _kind == (u1)desired;
 957   }
 958 
 959 public:
 960 
 961   // Other is anything that is not one of the more specialized kinds of InstanceKlass.
 962   bool is_other_instance_klass() const        { return is_kind(_kind_other); }
 963   bool is_reference_instance_klass() const    { return is_kind(_kind_reference); }
 964   bool is_mirror_instance_klass() const       { return is_kind(_kind_mirror); }
 965   bool is_class_loader_instance_klass() const { return is_kind(_kind_class_loader); }
 966   bool is_inline_type_klass()           const { return is_kind(_kind_inline_type); }
 967 
 968 #if INCLUDE_JVMTI
 969 
 970   void init_previous_versions() {
 971     _previous_versions = NULL;
 972   }
 973 
 974  private:
 975   static bool  _has_previous_versions;
 976  public:
 977   static void purge_previous_versions(InstanceKlass* ik) {
 978     if (ik-&gt;has_been_redefined()) {
 979       ik-&gt;purge_previous_version_list();
 980     }
 981   }
 982 
 983   static bool has_previous_versions_and_reset();
 984   static bool has_previous_versions() { return _has_previous_versions; }
 985 
 986   // JVMTI: Support for caching a class file before it is modified by an agent that can do retransformation
 987   void set_cached_class_file(JvmtiCachedClassFileData *data) {
 988     _cached_class_file = data;
 989   }
 990   JvmtiCachedClassFileData * get_cached_class_file();
 991   jint get_cached_class_file_len();
 992   unsigned char * get_cached_class_file_bytes();
 993 
 994   // JVMTI: Support for caching of field indices, types, and offsets
 995   void set_jvmti_cached_class_field_map(JvmtiCachedClassFieldMap* descriptor) {
 996     _jvmti_cached_class_field_map = descriptor;
 997   }
 998   JvmtiCachedClassFieldMap* jvmti_cached_class_field_map() const {
 999     return _jvmti_cached_class_field_map;
1000   }
1001 #else // INCLUDE_JVMTI
1002 
1003   static void purge_previous_versions(InstanceKlass* ik) { return; };
1004   static bool has_previous_versions_and_reset() { return false; }
1005 
1006   void set_cached_class_file(JvmtiCachedClassFileData *data) {
1007     assert(data == NULL, &quot;unexpected call with JVMTI disabled&quot;);
1008   }
1009   JvmtiCachedClassFileData * get_cached_class_file() { return (JvmtiCachedClassFileData *)NULL; }
1010 
1011 #endif // INCLUDE_JVMTI
1012 
1013   bool has_nonstatic_concrete_methods() const {
1014     return (_misc_flags &amp; _misc_has_nonstatic_concrete_methods) != 0;
1015   }
1016   void set_has_nonstatic_concrete_methods(bool b) {
1017     if (b) {
1018       _misc_flags |= _misc_has_nonstatic_concrete_methods;
1019     } else {
1020       _misc_flags &amp;= ~_misc_has_nonstatic_concrete_methods;
1021     }
1022   }
1023 
1024   bool declares_nonstatic_concrete_methods() const {
1025     return (_misc_flags &amp; _misc_declares_nonstatic_concrete_methods) != 0;
1026   }
1027   void set_declares_nonstatic_concrete_methods(bool b) {
1028     if (b) {
1029       _misc_flags |= _misc_declares_nonstatic_concrete_methods;
1030     } else {
1031       _misc_flags &amp;= ~_misc_declares_nonstatic_concrete_methods;
1032     }
1033   }
1034 
1035   // for adding methods, ConstMethod::UNSET_IDNUM means no more ids available
1036   inline u2 next_method_idnum();
1037   void set_initial_method_idnum(u2 value)             { _idnum_allocated_count = value; }
1038 
1039   // generics support
1040   Symbol* generic_signature() const                   { return _constants-&gt;generic_signature(); }
1041   u2 generic_signature_index() const                  { return _constants-&gt;generic_signature_index(); }
1042   void set_generic_signature_index(u2 sig_index)      { _constants-&gt;set_generic_signature_index(sig_index); }
1043 
1044   u2 enclosing_method_data(int offset) const;
1045   u2 enclosing_method_class_index() const {
1046     return enclosing_method_data(enclosing_method_class_index_offset);
1047   }
1048   u2 enclosing_method_method_index() {
1049     return enclosing_method_data(enclosing_method_method_index_offset);
1050   }
1051   void set_enclosing_method_indices(u2 class_index,
1052                                     u2 method_index);
1053 
1054   // jmethodID support
1055   jmethodID get_jmethod_id(const methodHandle&amp; method_h);
1056   jmethodID get_jmethod_id_fetch_or_update(size_t idnum,
1057                      jmethodID new_id, jmethodID* new_jmeths,
1058                      jmethodID* to_dealloc_id_p,
1059                      jmethodID** to_dealloc_jmeths_p);
1060   static void get_jmethod_id_length_value(jmethodID* cache, size_t idnum,
1061                 size_t *length_p, jmethodID* id_p);
1062   void ensure_space_for_methodids(int start_offset = 0);
1063   jmethodID jmethod_id_or_null(Method* method);
1064 
1065   // annotations support
1066   Annotations* annotations() const          { return _annotations; }
1067   void set_annotations(Annotations* anno)   { _annotations = anno; }
1068 
1069   AnnotationArray* class_annotations() const {
1070     return (_annotations != NULL) ? _annotations-&gt;class_annotations() : NULL;
1071   }
1072   Array&lt;AnnotationArray*&gt;* fields_annotations() const {
1073     return (_annotations != NULL) ? _annotations-&gt;fields_annotations() : NULL;
1074   }
1075   AnnotationArray* class_type_annotations() const {
1076     return (_annotations != NULL) ? _annotations-&gt;class_type_annotations() : NULL;
1077   }
1078   Array&lt;AnnotationArray*&gt;* fields_type_annotations() const {
1079     return (_annotations != NULL) ? _annotations-&gt;fields_type_annotations() : NULL;
1080   }
1081   // allocation
1082   instanceOop allocate_instance(TRAPS);
1083   static instanceOop allocate_instance(oop cls, TRAPS);
1084 
1085   // additional member function to return a handle
1086   instanceHandle allocate_instance_handle(TRAPS);
1087 
1088   objArrayOop allocate_objArray(int n, int length, TRAPS);
1089   // Helper function
1090   static instanceOop register_finalizer(instanceOop i, TRAPS);
1091 
1092   // Check whether reflection/jni/jvm code is allowed to instantiate this class;
1093   // if not, throw either an Error or an Exception.
1094   virtual void check_valid_for_instantiation(bool throwError, TRAPS);
1095 
1096   // initialization
1097   void call_class_initializer(TRAPS);
1098   void set_initialization_state_and_notify(ClassState state, TRAPS);
1099 
1100   // OopMapCache support
1101   OopMapCache* oop_map_cache()               { return _oop_map_cache; }
1102   void set_oop_map_cache(OopMapCache *cache) { _oop_map_cache = cache; }
1103   void mask_for(const methodHandle&amp; method, int bci, InterpreterOopMap* entry);
1104 
1105   // JNI identifier support (for static fields - for jni performance)
1106   JNIid* jni_ids()                               { return _jni_ids; }
1107   void set_jni_ids(JNIid* ids)                   { _jni_ids = ids; }
1108   JNIid* jni_id_for(int offset);
1109 
1110   // maintenance of deoptimization dependencies
1111   inline DependencyContext dependencies();
1112   int  mark_dependent_nmethods(KlassDepChange&amp; changes);
1113   void add_dependent_nmethod(nmethod* nm);
1114   void remove_dependent_nmethod(nmethod* nm);
1115   void clean_dependency_context();
1116 
1117   // On-stack replacement support
1118   nmethod* osr_nmethods_head() const         { return _osr_nmethods_head; };
1119   void set_osr_nmethods_head(nmethod* h)     { _osr_nmethods_head = h; };
1120   void add_osr_nmethod(nmethod* n);
1121   bool remove_osr_nmethod(nmethod* n);
1122   int mark_osr_nmethods(const Method* m);
1123   nmethod* lookup_osr_nmethod(const Method* m, int bci, int level, bool match_level) const;
1124 
1125 #if INCLUDE_JVMTI
1126   // Breakpoint support (see methods on Method* for details)
1127   BreakpointInfo* breakpoints() const       { return _breakpoints; };
1128   void set_breakpoints(BreakpointInfo* bps) { _breakpoints = bps; };
1129 #endif
1130 
1131   // support for stub routines
1132   static ByteSize init_state_offset()  { return in_ByteSize(offset_of(InstanceKlass, _init_state)); }
1133   JFR_ONLY(DEFINE_KLASS_TRACE_ID_OFFSET;)
1134   static ByteSize init_thread_offset() { return in_ByteSize(offset_of(InstanceKlass, _init_thread)); }
1135 
1136   static ByteSize inline_type_field_klasses_offset() { return in_ByteSize(offset_of(InstanceKlass, _inline_type_field_klasses)); }
1137   static ByteSize adr_inlineklass_fixed_block_offset() { return in_ByteSize(offset_of(InstanceKlass, _adr_inlineklass_fixed_block)); }
1138 
1139   // subclass/subinterface checks
1140   bool implements_interface(Klass* k) const;
1141   bool is_same_or_direct_interface(Klass* k) const;
1142 
1143 #ifdef ASSERT
1144   // check whether this class or one of its superclasses was redefined
1145   bool has_redefined_this_or_super() const;
1146 #endif
1147 
1148   // Access to the implementor of an interface.
1149   Klass* implementor() const;
1150   void set_implementor(Klass* k);
1151   int  nof_implementors() const;
1152   void add_implementor(Klass* k);  // k is a new class that implements this interface
1153   void init_implementor();           // initialize
1154 
1155   // link this class into the implementors list of every interface it implements
1156   void process_interfaces(Thread *thread);
1157 
1158   // virtual operations from Klass
1159   GrowableArray&lt;Klass*&gt;* compute_secondary_supers(int num_extra_slots,
1160                                                   Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1161   bool can_be_primary_super_slow() const;
1162   int oop_size(oop obj)  const             { return size_helper(); }
1163   // slow because it&#39;s a virtual call and used for verifying the layout_helper.
1164   // Using the layout_helper bits, we can call is_instance_klass without a virtual call.
1165   DEBUG_ONLY(bool is_instance_klass_slow() const      { return true; })
1166 
1167   // Iterators
1168   void do_local_static_fields(FieldClosure* cl);
1169   void do_nonstatic_fields(FieldClosure* cl); // including inherited fields
1170   void do_local_static_fields(void f(fieldDescriptor*, Handle, TRAPS), Handle, TRAPS);
1171 
1172   void methods_do(void f(Method* method));
1173   virtual void array_klasses_do(void f(Klass* k));
1174   virtual void array_klasses_do(void f(Klass* k, TRAPS), TRAPS);
1175 
1176   static InstanceKlass* cast(Klass* k) {
1177     return const_cast&lt;InstanceKlass*&gt;(cast(const_cast&lt;const Klass*&gt;(k)));
1178   }
1179 
1180   static const InstanceKlass* cast(const Klass* k) {
1181     assert(k != NULL, &quot;k should not be null&quot;);
1182     assert(k-&gt;is_instance_klass(), &quot;cast to InstanceKlass&quot;);
1183     return static_cast&lt;const InstanceKlass*&gt;(k);
1184   }
1185 
1186   virtual InstanceKlass* java_super() const {
1187     return (super() == NULL) ? NULL : cast(super());
1188   }
1189 
1190   // Sizing (in words)
1191   static int header_size()            { return sizeof(InstanceKlass)/wordSize; }
1192 
1193   static int size(int vtable_length, int itable_length,
1194                   int nonstatic_oop_map_size,
1195                   bool is_interface, bool is_unsafe_anonymous, bool has_stored_fingerprint,
1196                   int java_fields, bool is_inline_type) {
1197     return align_metadata_size(header_size() +
1198            vtable_length +
1199            itable_length +
1200            nonstatic_oop_map_size +
1201            (is_interface ? (int)sizeof(Klass*)/wordSize : 0) +
1202            (is_unsafe_anonymous ? (int)sizeof(Klass*)/wordSize : 0) +
1203            (has_stored_fingerprint ? (int)sizeof(uint64_t*)/wordSize : 0) +
1204            (java_fields * (int)sizeof(Klass*)/wordSize) +
1205            (is_inline_type ? (int)sizeof(InlineKlassFixedBlock) : 0));
1206   }
1207   int size() const                    { return size(vtable_length(),
1208                                                itable_length(),
1209                                                nonstatic_oop_map_size(),
1210                                                is_interface(),
1211                                                is_unsafe_anonymous(),
1212                                                has_stored_fingerprint(),
1213                                                has_inline_type_fields() ? java_fields_count() : 0,
1214                                                is_inline_klass());
1215   }
1216 
1217   intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }
1218   intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }
1219 
1220   int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }
1221 
1222   oop static_field_base_raw() { return java_mirror(); }
1223 
1224   bool bounds_check(address addr, bool edge_ok = false, intptr_t size_in_bytes = -1) const PRODUCT_RETURN0;
1225 
1226   OopMapBlock* start_of_nonstatic_oop_maps() const {
1227     return (OopMapBlock*)(start_of_itable() + itable_length());
1228   }
1229 
1230   Klass** end_of_nonstatic_oop_maps() const {
1231     return (Klass**)(start_of_nonstatic_oop_maps() +
1232                      nonstatic_oop_map_count());
1233   }
1234 
1235   Klass* volatile* adr_implementor() const {
1236     if (is_interface()) {
1237       return (Klass* volatile*)end_of_nonstatic_oop_maps();
1238     } else {
1239       return NULL;
1240     }
1241   };
1242 
1243   InstanceKlass** adr_unsafe_anonymous_host() const {
1244     if (is_unsafe_anonymous()) {
1245       InstanceKlass** adr_impl = (InstanceKlass**)adr_implementor();
1246       if (adr_impl != NULL) {
1247         return adr_impl + 1;
1248       } else {
1249         return (InstanceKlass **)end_of_nonstatic_oop_maps();
1250       }
1251     } else {
1252       return NULL;
1253     }
1254   }
1255 
1256   address adr_fingerprint() const {
1257     if (has_stored_fingerprint()) {
1258       InstanceKlass** adr_host = adr_unsafe_anonymous_host();
1259       if (adr_host != NULL) {
1260         return (address)(adr_host + 1);
1261       }
1262 
1263       Klass* volatile* adr_impl = adr_implementor();
1264       if (adr_impl != NULL) {
1265         return (address)(adr_impl + 1);
1266       }
1267 
1268       return (address)end_of_nonstatic_oop_maps();
1269     } else {
1270       return NULL;
1271     }
1272   }
1273 
1274   address adr_inline_type_field_klasses() const {
1275     if (has_inline_type_fields()) {
1276       address adr_fing = adr_fingerprint();
1277       if (adr_fing != NULL) {
1278         return adr_fingerprint() + sizeof(u8);
1279       }
1280 
1281       InstanceKlass** adr_host = adr_unsafe_anonymous_host();
1282       if (adr_host != NULL) {
1283         return (address)(adr_host + 1);
1284       }
1285 
1286       Klass* volatile* adr_impl = adr_implementor();
1287       if (adr_impl != NULL) {
1288         return (address)(adr_impl + 1);
1289       }
1290 
1291       return (address)end_of_nonstatic_oop_maps();
1292     } else {
1293       return NULL;
1294     }
1295   }
1296 
1297   Klass* get_inline_type_field_klass(int idx) const {
1298     assert(has_inline_type_fields(), &quot;Sanity checking&quot;);
1299     assert(idx &lt; java_fields_count(), &quot;IOOB&quot;);
1300     Klass* k = ((Klass**)adr_inline_type_field_klasses())[idx];
1301     assert(k != NULL, &quot;Should always be set before being read&quot;);
1302     assert(k-&gt;is_inline_klass(), &quot;Must be a inline type&quot;);
1303     return k;
1304   }
1305 
1306   Klass* get_inline_type_field_klass_or_null(int idx) const {
1307     assert(has_inline_type_fields(), &quot;Sanity checking&quot;);
1308     assert(idx &lt; java_fields_count(), &quot;IOOB&quot;);
1309     Klass* k = ((Klass**)adr_inline_type_field_klasses())[idx];
1310     assert(k == NULL || k-&gt;is_inline_klass(), &quot;Must be a inline type&quot;);
1311     return k;
1312   }
1313 
1314   void set_inline_type_field_klass(int idx, Klass* k) {
1315     assert(has_inline_type_fields(), &quot;Sanity checking&quot;);
1316     assert(idx &lt; java_fields_count(), &quot;IOOB&quot;);
1317     assert(k != NULL, &quot;Should not be set to NULL&quot;);
1318     assert(((Klass**)adr_inline_type_field_klasses())[idx] == NULL, &quot;Should not be set twice&quot;);
1319     ((Klass**)adr_inline_type_field_klasses())[idx] = k;
1320   }
1321 
1322   void reset_inline_type_field_klass(int idx) {
1323     assert(has_inline_type_fields(), &quot;Sanity checking&quot;);
1324     assert(idx &lt; java_fields_count(), &quot;IOOB&quot;);
1325     ((Klass**)adr_inline_type_field_klasses())[idx] = NULL;
1326   }
1327 
1328   // Use this to return the size of an instance in heap words:
1329   virtual int size_helper() const {
1330     return layout_helper_to_size_helper(layout_helper());
1331   }
1332 
1333   // This bit is initialized in classFileParser.cpp.
1334   // It is false under any of the following conditions:
1335   //  - the class is abstract (including any interface)
1336   //  - the class has a finalizer (if !RegisterFinalizersAtInit)
1337   //  - the class size is larger than FastAllocateSizeLimit
1338   //  - the class is java/lang/Class, which cannot be allocated directly
1339   bool can_be_fastpath_allocated() const {
1340     return !layout_helper_needs_slow_path(layout_helper());
1341   }
1342 
1343   // Java itable
1344   klassItable itable() const;        // return klassItable wrapper
1345   Method* method_at_itable(Klass* holder, int index, TRAPS);
1346 
1347 #if INCLUDE_JVMTI
1348   void adjust_default_methods(bool* trace_name_printed);
1349 #endif // INCLUDE_JVMTI
1350 
1351   void clean_weak_instanceklass_links();
1352  private:
1353   void clean_implementors_list();
1354   void clean_method_data();
1355 
1356  public:
1357   // Explicit metaspace deallocation of fields
1358   // For RedefineClasses and class file parsing errors, we need to deallocate
1359   // instanceKlasses and the metadata they point to.
1360   void deallocate_contents(ClassLoaderData* loader_data);
1361   static void deallocate_methods(ClassLoaderData* loader_data,
1362                                  Array&lt;Method*&gt;* methods);
1363   void static deallocate_interfaces(ClassLoaderData* loader_data,
1364                                     const Klass* super_klass,
1365                                     Array&lt;InstanceKlass*&gt;* local_interfaces,
1366                                     Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1367   void static deallocate_record_components(ClassLoaderData* loader_data,
1368                                            Array&lt;RecordComponent*&gt;* record_component);
1369 
1370   // The constant pool is on stack if any of the methods are executing or
1371   // referenced by handles.
1372   bool on_stack() const { return _constants-&gt;on_stack(); }
1373 
1374   // callbacks for actions during class unloading
1375   static void unload_class(InstanceKlass* ik);
1376 
1377   virtual void release_C_heap_structures();
1378 
1379   // Naming
1380   const char* signature_name() const;
1381 
1382   // Oop fields (and metadata) iterators
1383   //
1384   // The InstanceKlass iterators also visits the Object&#39;s klass.
1385 
1386   // Forward iteration
1387  public:
1388   // Iterate over all oop fields in the oop maps.
1389   template &lt;typename T, class OopClosureType&gt;
1390   inline void oop_oop_iterate_oop_maps(oop obj, OopClosureType* closure);
1391 
1392   // Iterate over all oop fields and metadata.
1393   template &lt;typename T, class OopClosureType&gt;
1394   inline void oop_oop_iterate(oop obj, OopClosureType* closure);
1395 
1396   // Iterate over all oop fields in one oop map.
1397   template &lt;typename T, class OopClosureType&gt;
1398   inline void oop_oop_iterate_oop_map(OopMapBlock* map, oop obj, OopClosureType* closure);
1399 
1400 
1401   // Reverse iteration
1402   // Iterate over all oop fields and metadata.
1403   template &lt;typename T, class OopClosureType&gt;
1404   inline void oop_oop_iterate_reverse(oop obj, OopClosureType* closure);
1405 
1406  private:
1407   // Iterate over all oop fields in the oop maps.
1408   template &lt;typename T, class OopClosureType&gt;
1409   inline void oop_oop_iterate_oop_maps_reverse(oop obj, OopClosureType* closure);
1410 
1411   // Iterate over all oop fields in one oop map.
1412   template &lt;typename T, class OopClosureType&gt;
1413   inline void oop_oop_iterate_oop_map_reverse(OopMapBlock* map, oop obj, OopClosureType* closure);
1414 
1415 
1416   // Bounded range iteration
1417  public:
1418   // Iterate over all oop fields in the oop maps.
1419   template &lt;typename T, class OopClosureType&gt;
1420   inline void oop_oop_iterate_oop_maps_bounded(oop obj, OopClosureType* closure, MemRegion mr);
1421 
1422   // Iterate over all oop fields and metadata.
1423   template &lt;typename T, class OopClosureType&gt;
1424   inline void oop_oop_iterate_bounded(oop obj, OopClosureType* closure, MemRegion mr);
1425 
1426  private:
1427   // Iterate over all oop fields in one oop map.
1428   template &lt;typename T, class OopClosureType&gt;
1429   inline void oop_oop_iterate_oop_map_bounded(OopMapBlock* map, oop obj, OopClosureType* closure, MemRegion mr);
1430 
1431 
1432  public:
1433   u2 idnum_allocated_count() const      { return _idnum_allocated_count; }
1434 
1435 private:
1436   // initialization state
1437   void set_init_state(ClassState state);
1438   void set_rewritten()                  { _misc_flags |= _misc_rewritten; }
1439   void set_init_thread(Thread *thread)  { _init_thread = thread; }
1440 
1441   // The RedefineClasses() API can cause new method idnums to be needed
1442   // which will cause the caches to grow. Safety requires different
1443   // cache management logic if the caches can grow instead of just
1444   // going from NULL to non-NULL.
1445   bool idnum_can_increment() const      { return has_been_redefined(); }
1446   inline jmethodID* methods_jmethod_ids_acquire() const;
1447   inline void release_set_methods_jmethod_ids(jmethodID* jmeths);
1448 
1449   // Lock during initialization
1450 public:
1451   // Lock for (1) initialization; (2) access to the ConstantPool of this class.
1452   // Must be one per class and it has to be a VM internal object so java code
1453   // cannot lock it (like the mirror).
1454   // It has to be an object not a Mutex because it&#39;s held through java calls.
1455   oop init_lock() const;
1456 private:
1457   void fence_and_clear_init_lock();
1458 
1459   bool link_class_impl                           (TRAPS);
1460   bool verify_code                               (TRAPS);
1461   void initialize_impl                           (TRAPS);
1462   void initialize_super_interfaces               (TRAPS);
1463   void eager_initialize_impl                     ();
1464   /* jni_id_for_impl for jfieldID only */
1465   JNIid* jni_id_for_impl                         (int offset);
1466 protected:
1467   // Returns the array class for the n&#39;th dimension
1468   virtual Klass* array_klass_impl(bool or_null, int n, TRAPS);
1469 
1470   // Returns the array class with this class as element type
1471   virtual Klass* array_klass_impl(bool or_null, TRAPS);
1472 
1473 private:
1474 
1475   // find a local method (returns NULL if not found)
1476   Method* find_method_impl(const Symbol* name,
1477                            const Symbol* signature,
1478                            OverpassLookupMode overpass_mode,
1479                            StaticLookupMode static_mode,
1480                            PrivateLookupMode private_mode) const;
1481 
1482   static Method* find_method_impl(const Array&lt;Method*&gt;* methods,
1483                                   const Symbol* name,
1484                                   const Symbol* signature,
1485                                   OverpassLookupMode overpass_mode,
1486                                   StaticLookupMode static_mode,
1487                                   PrivateLookupMode private_mode);
1488 
1489   // Free CHeap allocated fields.
1490   void release_C_heap_structures_internal();
1491 
1492 #if INCLUDE_JVMTI
1493   // RedefineClasses support
1494   void link_previous_versions(InstanceKlass* pv) { _previous_versions = pv; }
1495   void mark_newly_obsolete_methods(Array&lt;Method*&gt;* old_methods, int emcp_method_count);
1496 #endif
1497 public:
1498   // CDS support - remove and restore oops from metadata. Oops are not shared.
1499   virtual void remove_unshareable_info();
1500   virtual void remove_java_mirror();
1501   virtual void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS);
1502 
1503   // jvm support
1504   jint compute_modifier_flags(TRAPS) const;
1505 
1506 public:
1507   // JVMTI support
1508   jint jvmti_class_status() const;
1509 
1510   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
1511 
1512  public:
1513   // Printing
1514 #ifndef PRODUCT
1515   void print_on(outputStream* st) const;
1516 #endif
1517   void print_value_on(outputStream* st) const;
1518 
1519   void oop_print_value_on(oop obj, outputStream* st);
1520 
1521 #ifndef PRODUCT
1522   void oop_print_on      (oop obj, outputStream* st);
1523 
1524   void print_dependent_nmethods(bool verbose = false);
1525   bool is_dependent_nmethod(nmethod* nm);
1526   bool verify_itable_index(int index);
1527 #endif
1528 
1529   const char* internal_name() const;
1530 
1531   // Verification
1532   void verify_on(outputStream* st);
1533 
1534   void oop_verify_on(oop obj, outputStream* st);
1535 
1536   // Logging
1537   void print_class_load_logging(ClassLoaderData* loader_data,
1538                                 const char* module_name,
1539                                 const ClassFileStream* cfs) const;
1540 };
1541 
1542 // for adding methods
1543 // UNSET_IDNUM return means no more ids available
1544 inline u2 InstanceKlass::next_method_idnum() {
1545   if (_idnum_allocated_count == ConstMethod::MAX_IDNUM) {
1546     return ConstMethod::UNSET_IDNUM; // no more ids available
1547   } else {
1548     return _idnum_allocated_count++;
1549   }
1550 }
1551 
1552 
1553 /* JNIid class for jfieldIDs only */
1554 class JNIid: public CHeapObj&lt;mtClass&gt; {
1555   friend class VMStructs;
1556  private:
1557   Klass*             _holder;
1558   JNIid*             _next;
1559   int                _offset;
1560 #ifdef ASSERT
1561   bool               _is_static_field_id;
1562 #endif
1563 
1564  public:
1565   // Accessors
1566   Klass* holder() const           { return _holder; }
1567   int offset() const              { return _offset; }
1568   JNIid* next()                   { return _next; }
1569   // Constructor
1570   JNIid(Klass* holder, int offset, JNIid* next);
1571   // Identifier lookup
1572   JNIid* find(int offset);
1573 
1574   bool find_local_field(fieldDescriptor* fd) {
1575     return InstanceKlass::cast(holder())-&gt;find_local_field_from_offset(offset(), true, fd);
1576   }
1577 
1578   static void deallocate(JNIid* id);
1579   // Debugging
1580 #ifdef ASSERT
1581   bool is_static_field_id() const { return _is_static_field_id; }
1582   void set_is_static_field_id()   { _is_static_field_id = true; }
1583 #endif
1584   void verify(Klass* holder);
1585 };
1586 
1587 // An iterator that&#39;s used to access the inner classes indices in the
1588 // InstanceKlass::_inner_classes array.
1589 class InnerClassesIterator : public StackObj {
1590  private:
1591   Array&lt;jushort&gt;* _inner_classes;
1592   int _length;
1593   int _idx;
1594  public:
1595 
1596   InnerClassesIterator(const InstanceKlass* k) {
1597     _inner_classes = k-&gt;inner_classes();
1598     if (k-&gt;inner_classes() != NULL) {
1599       _length = _inner_classes-&gt;length();
1600       // The inner class array&#39;s length should be the multiple of
1601       // inner_class_next_offset if it only contains the InnerClasses
1602       // attribute data, or it should be
1603       // n*inner_class_next_offset+enclosing_method_attribute_size
1604       // if it also contains the EnclosingMethod data.
1605       assert((_length % InstanceKlass::inner_class_next_offset == 0 ||
1606               _length % InstanceKlass::inner_class_next_offset == InstanceKlass::enclosing_method_attribute_size),
1607              &quot;just checking&quot;);
1608       // Remove the enclosing_method portion if exists.
1609       if (_length % InstanceKlass::inner_class_next_offset == InstanceKlass::enclosing_method_attribute_size) {
1610         _length -= InstanceKlass::enclosing_method_attribute_size;
1611       }
1612     } else {
1613       _length = 0;
1614     }
1615     _idx = 0;
1616   }
1617 
1618   int length() const {
1619     return _length;
1620   }
1621 
1622   void next() {
1623     _idx += InstanceKlass::inner_class_next_offset;
1624   }
1625 
1626   bool done() const {
1627     return (_idx &gt;= _length);
1628   }
1629 
1630   u2 inner_class_info_index() const {
1631     return _inner_classes-&gt;at(
1632                _idx + InstanceKlass::inner_class_inner_class_info_offset);
1633   }
1634 
1635   void set_inner_class_info_index(u2 index) {
1636     _inner_classes-&gt;at_put(
1637                _idx + InstanceKlass::inner_class_inner_class_info_offset, index);
1638   }
1639 
1640   u2 outer_class_info_index() const {
1641     return _inner_classes-&gt;at(
1642                _idx + InstanceKlass::inner_class_outer_class_info_offset);
1643   }
1644 
1645   void set_outer_class_info_index(u2 index) {
1646     _inner_classes-&gt;at_put(
1647                _idx + InstanceKlass::inner_class_outer_class_info_offset, index);
1648   }
1649 
1650   u2 inner_name_index() const {
1651     return _inner_classes-&gt;at(
1652                _idx + InstanceKlass::inner_class_inner_name_offset);
1653   }
1654 
1655   void set_inner_name_index(u2 index) {
1656     _inner_classes-&gt;at_put(
1657                _idx + InstanceKlass::inner_class_inner_name_offset, index);
1658   }
1659 
1660   u2 inner_access_flags() const {
1661     return _inner_classes-&gt;at(
1662                _idx + InstanceKlass::inner_class_access_flags_offset);
1663   }
1664 };
1665 
1666 #endif // SHARE_OOPS_INSTANCEKLASS_HPP
    </pre>
  </body>
</html>
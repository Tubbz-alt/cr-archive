<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../tree/TreeMaker.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1604         @Override
1605         public void visitWildcard(JCWildcard tree) {
1606             if (tree.inner != null)
1607                 validateTree(tree.inner, true, isOuter);
1608         }
1609 
1610         @Override
1611         public void visitSelect(JCFieldAccess tree) {
1612             if (tree.type.hasTag(CLASS)) {
1613                 visitSelectInternal(tree);
1614 
1615                 // Check that this type is either fully parameterized, or
1616                 // not parameterized at all.
1617                 if (tree.selected.type.isParameterized() &amp;&amp; tree.type.tsym.type.getTypeArguments().nonEmpty())
1618                     log.error(tree.pos(), Errors.ImproperlyFormedTypeParamMissing);
1619             }
1620         }
1621 
1622         public void visitSelectInternal(JCFieldAccess tree) {
1623             if (tree.type.tsym.isStatic() &amp;&amp;
<span class="line-modified">1624                 tree.selected.type.isParameterized()) {</span>

1625                 // The enclosing type is not a class, so we are
1626                 // looking at a static member type.  However, the
1627                 // qualifying expression is parameterized.


1628                 log.error(tree.pos(), Errors.CantSelectStaticClassFromParamType);
1629             } else {
1630                 // otherwise validate the rest of the expression
1631                 tree.selected.accept(this);
1632             }
1633         }
1634 
1635         @Override
1636         public void visitAnnotatedType(JCAnnotatedType tree) {
1637             tree.underlyingType.accept(this);
1638         }
1639 
1640         @Override
1641         public void visitTypeIdent(JCPrimitiveTypeTree that) {
1642             if (that.type.hasTag(TypeTag.VOID)) {
1643                 log.error(that.pos(), Errors.VoidNotAllowedHere);
1644             }
1645             super.visitTypeIdent(that);
1646         }
1647 
</pre>
</td>
<td>
<hr />
<pre>
1604         @Override
1605         public void visitWildcard(JCWildcard tree) {
1606             if (tree.inner != null)
1607                 validateTree(tree.inner, true, isOuter);
1608         }
1609 
1610         @Override
1611         public void visitSelect(JCFieldAccess tree) {
1612             if (tree.type.hasTag(CLASS)) {
1613                 visitSelectInternal(tree);
1614 
1615                 // Check that this type is either fully parameterized, or
1616                 // not parameterized at all.
1617                 if (tree.selected.type.isParameterized() &amp;&amp; tree.type.tsym.type.getTypeArguments().nonEmpty())
1618                     log.error(tree.pos(), Errors.ImproperlyFormedTypeParamMissing);
1619             }
1620         }
1621 
1622         public void visitSelectInternal(JCFieldAccess tree) {
1623             if (tree.type.tsym.isStatic() &amp;&amp;
<span class="line-modified">1624                 tree.selected.type.isParameterized() &amp;&amp;</span>
<span class="line-added">1625                     (tree.name != names.ref || !tree.type.isReferenceProjection())) {</span>
1626                 // The enclosing type is not a class, so we are
1627                 // looking at a static member type.  However, the
1628                 // qualifying expression is parameterized.
<span class="line-added">1629                 // Tolerate the pseudo-select V.ref: V&lt;T&gt;.ref will be static if V&lt;T&gt; is and</span>
<span class="line-added">1630                 // should not be confused as selecting a static member of a parameterized type.</span>
1631                 log.error(tree.pos(), Errors.CantSelectStaticClassFromParamType);
1632             } else {
1633                 // otherwise validate the rest of the expression
1634                 tree.selected.accept(this);
1635             }
1636         }
1637 
1638         @Override
1639         public void visitAnnotatedType(JCAnnotatedType tree) {
1640             tree.underlyingType.accept(this);
1641         }
1642 
1643         @Override
1644         public void visitTypeIdent(JCPrimitiveTypeTree that) {
1645             if (that.type.hasTag(TypeTag.VOID)) {
1646                 log.error(that.pos(), Errors.VoidNotAllowedHere);
1647             }
1648             super.visitTypeIdent(that);
1649         }
1650 
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../tree/TreeMaker.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/valuetypenode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="type.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valuetypenode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/valuetypenode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
175 
176 uint ValueTypeBaseNode::field_index(int offset) const {
177   uint i = 0;
178   for (; i &lt; field_count() &amp;&amp; field_offset(i) != offset; i++) { }
179   assert(i &lt; field_count(), &quot;field not found&quot;);
180   return i;
181 }
182 
183 ciType* ValueTypeBaseNode::field_type(uint index) const {
184   assert(index &lt; field_count(), &quot;index out of bounds&quot;);
185   return value_klass()-&gt;declared_nonstatic_field_at(index)-&gt;type();
186 }
187 
188 bool ValueTypeBaseNode::field_is_flattened(uint index) const {
189   assert(index &lt; field_count(), &quot;index out of bounds&quot;);
190   ciField* field = value_klass()-&gt;declared_nonstatic_field_at(index);
191   assert(!field-&gt;is_flattened() || field-&gt;type()-&gt;is_valuetype(), &quot;must be a value type&quot;);
192   return field-&gt;is_flattened();
193 }
194 
<span class="line-removed">195 bool ValueTypeBaseNode::field_is_flattenable(uint index) const {</span>
<span class="line-removed">196   assert(index &lt; field_count(), &quot;index out of bounds&quot;);</span>
<span class="line-removed">197   ciField* field = value_klass()-&gt;declared_nonstatic_field_at(index);</span>
<span class="line-removed">198   assert(!field-&gt;is_flattenable() || field-&gt;type()-&gt;is_valuetype(), &quot;must be a value type&quot;);</span>
<span class="line-removed">199   return field-&gt;is_flattenable();</span>
<span class="line-removed">200 }</span>
<span class="line-removed">201 </span>
202 int ValueTypeBaseNode::make_scalar_in_safepoint(PhaseIterGVN* igvn, Unique_Node_List&amp; worklist, SafePointNode* sfpt) {
203   ciValueKlass* vk = value_klass();
204   uint nfields = vk-&gt;nof_nonstatic_fields();
205   JVMState* jvms = sfpt-&gt;jvms();
206   int start = jvms-&gt;debug_start();
207   int end   = jvms-&gt;debug_end();
208   // Replace safepoint edge by SafePointScalarObjectNode and add field values
209   assert(jvms != NULL, &quot;missing JVMS&quot;);
210   uint first_ind = (sfpt-&gt;req() - jvms-&gt;scloff());
211   SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(value_ptr(),
212 #ifdef ASSERT
213                                                                   NULL,
214 #endif
215                                                                   first_ind, nfields);
216   sobj-&gt;init_req(0, igvn-&gt;C-&gt;root());
217   // Iterate over the value type fields in order of increasing
218   // offset and add the field values to the safepoint.
219   for (uint j = 0; j &lt; nfields; ++j) {
220     int offset = vk-&gt;nonstatic_field_at(j)-&gt;offset();
221     Node* value = field_value_by_offset(offset, true /* include flattened value type fields */);
</pre>
<hr />
<pre>
263   if ((decorators &amp; C2_MISMATCHED) != 0) {
264     adr_type = TypeRawPtr::BOTTOM;
265   } else if (is_array) {
266     // In the case of a flattened value type array, each field has its own slice
267     adr_type = ary_type-&gt;with_field_offset(offset)-&gt;add_offset(Type::OffsetBot);
268   } else {
269     ciField* field = holder-&gt;get_field_by_offset(offset, false);
270     assert(field != NULL, &quot;field not found&quot;);
271     adr_type = gvn.C-&gt;alias_type(field)-&gt;adr_type();
272   }
273   return adr_type;
274 }
275 
276 void ValueTypeBaseNode::load(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {
277   // Initialize the value type by loading its field values from
278   // memory and adding the values as input edges to the node.
279   for (uint i = 0; i &lt; field_count(); ++i) {
280     int offset = holder_offset + field_offset(i);
281     Node* value = NULL;
282     ciType* ft = field_type(i);
<span class="line-removed">283     bool is_flattenable = field_is_flattenable(i);</span>
284     if (field_is_flattened(i)) {
285       // Recursively load the flattened value type field
286       value = ValueTypeNode::make_from_flattened(kit, ft-&gt;as_value_klass(), base, ptr, holder, offset, decorators);
287     } else {
288       const TypeOopPtr* oop_ptr = kit-&gt;gvn().type(base)-&gt;isa_oopptr();
289       bool is_array = (oop_ptr-&gt;isa_aryptr() != NULL);
290       if (base-&gt;is_Con() &amp;&amp; !is_array) {
291         // If the oop to the value type is constant (static final field), we can
292         // also treat the fields as constants because the value type is immutable.
293         ciObject* constant_oop = oop_ptr-&gt;const_oop();
294         ciField* field = holder-&gt;get_field_by_offset(offset, false);
295         assert(field != NULL, &quot;field not found&quot;);
296         ciConstant constant = constant_oop-&gt;as_instance()-&gt;field_value(field);
297         const Type* con_type = Type::make_from_constant(constant, /*require_const=*/ true);
298         assert(con_type != NULL, &quot;type not found&quot;);
299         value = kit-&gt;gvn().transform(kit-&gt;makecon(con_type));
<span class="line-modified">300         // Check type of constant which might be more precise</span>
<span class="line-modified">301         if (con_type-&gt;is_valuetypeptr() &amp;&amp; !con_type-&gt;is_zero_type()) {</span>
<span class="line-modified">302           // Null-free, treat as flattenable</span>
303           ft = con_type-&gt;value_klass();
<span class="line-removed">304           is_flattenable = true;</span>
305         }
306       } else {
307         // Load field value from memory
308         const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit-&gt;gvn());
309         Node* adr = kit-&gt;basic_plus_adr(base, ptr, offset);
310         BasicType bt = type2field[ft-&gt;basic_type()];
311         assert(is_java_primitive(bt) || adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() == UseCompressedOops, &quot;inconsistent&quot;);
312         const Type* val_type = Type::get_const_type(ft);
313         if (is_array) {
314           decorators |= IS_ARRAY;
315         }
316         value = kit-&gt;access_load_at(base, adr, adr_type, val_type, bt, decorators);
317       }
<span class="line-modified">318       if (is_flattenable) {</span>
<span class="line-modified">319         // Loading a non-flattened but flattenable value type from memory</span>
320         if (ft-&gt;as_value_klass()-&gt;is_scalarizable()) {
321           value = ValueTypeNode::make_from_oop(kit, value, ft-&gt;as_value_klass());
322         } else {
323           value = kit-&gt;null2default(value, ft-&gt;as_value_klass());
324         }
325       }
326     }
327     set_field_value(i, value);
328   }
329 }
330 
331 void ValueTypeBaseNode::store_flattened(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {
332   // The value type is embedded into the object without an oop header. Subtract the
333   // offset of the first field to account for the missing header when storing the values.
334   if (holder == NULL) {
335     holder = value_klass();
336   }
337   holder_offset -= value_klass()-&gt;first_field_offset();
338   store(kit, base, ptr, holder, holder_offset, decorators);
339 }
340 
341 void ValueTypeBaseNode::store(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {
342   // Write field values to memory
343   for (uint i = 0; i &lt; field_count(); ++i) {
344     int offset = holder_offset + field_offset(i);
345     Node* value = field_value(i);
346     ciType* ft = field_type(i);
347     if (field_is_flattened(i)) {
348       // Recursively store the flattened value type field
349       if (!value-&gt;is_ValueType()) {
<span class="line-modified">350         assert(!kit-&gt;gvn().type(value)-&gt;maybe_null(), &quot;should never be null&quot;);</span>
351         value = ValueTypeNode::make_from_oop(kit, value, ft-&gt;as_value_klass());
352       }
353       value-&gt;as_ValueType()-&gt;store_flattened(kit, base, ptr, holder, offset, decorators);
354     } else {
355       // Store field value to memory
356       const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit-&gt;gvn());
357       Node* adr = kit-&gt;basic_plus_adr(base, ptr, offset);
358       BasicType bt = type2field[ft-&gt;basic_type()];
359       assert(is_java_primitive(bt) || adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() == UseCompressedOops, &quot;inconsistent&quot;);
360       const Type* val_type = Type::get_const_type(ft);
361       const TypeAryPtr* ary_type = kit-&gt;gvn().type(base)-&gt;isa_aryptr();
362       if (ary_type != NULL) {
363         decorators |= IS_ARRAY;
364       }
365       kit-&gt;access_store_at(base, adr, adr_type, value, val_type, bt, decorators);
366     }
367   }
368 }
369 
370 ValueTypePtrNode* ValueTypeBaseNode::buffer(GraphKit* kit, bool safe_for_replace) {
</pre>
<hr />
<pre>
493   return vt;
494 }
495 
496 ValueTypeNode* ValueTypeNode::make_uninitialized(PhaseGVN&amp; gvn, ciValueKlass* vk) {
497   // Create a new ValueTypeNode with uninitialized values and NULL oop
498   Node* oop = vk-&gt;is_empty() ? default_oop(gvn, vk) : gvn.zerocon(T_INLINE_TYPE);
499   return new ValueTypeNode(vk, oop);
500 }
501 
502 Node* ValueTypeNode::default_oop(PhaseGVN&amp; gvn, ciValueKlass* vk) {
503   // Returns the constant oop of the default value type allocation
504   return gvn.makecon(TypeInstPtr::make(vk-&gt;default_value_instance()));
505 }
506 
507 ValueTypeNode* ValueTypeNode::make_default(PhaseGVN&amp; gvn, ciValueKlass* vk) {
508   // Create a new ValueTypeNode with default values
509   ValueTypeNode* vt = new ValueTypeNode(vk, default_oop(gvn, vk));
510   for (uint i = 0; i &lt; vt-&gt;field_count(); ++i) {
511     ciType* field_type = vt-&gt;field_type(i);
512     Node* value = NULL;
<span class="line-modified">513     if (field_type-&gt;is_valuetype() &amp;&amp; vt-&gt;field_is_flattenable(i)) {</span>
514       ciValueKlass* field_klass = field_type-&gt;as_value_klass();
515       if (field_klass-&gt;is_scalarizable() || vt-&gt;field_is_flattened(i)) {
516         value = ValueTypeNode::make_default(gvn, field_klass);
517       } else {
518         value = default_oop(gvn, field_klass);
519       }
520     } else {
521       value = gvn.zerocon(field_type-&gt;basic_type());
522     }
523     vt-&gt;set_field_value(i, value);
524   }
525   vt = gvn.transform(vt)-&gt;as_ValueType();
526   assert(vt-&gt;is_default(gvn), &quot;must be the default value type&quot;);
527   return vt;
528 }
529 
530 bool ValueTypeNode::is_default(PhaseGVN&amp; gvn) const {
531   for (uint i = 0; i &lt; field_count(); ++i) {
532     Node* value = field_value(i);
533     if (!gvn.type(value)-&gt;is_zero_type() &amp;&amp;
</pre>
<hr />
<pre>
747   for (uint i = 0; i &lt; field_count(); i++) {
748     int sig_offset = (*sig)._offset;
749     uint idx = field_index(sig_offset - base_offset);
750     ciType* type = field_type(idx);
751 
752     Node* parm = NULL;
753     if (field_is_flattened(idx)) {
754       // Flattened value type field
755       ValueTypeNode* vt = ValueTypeNode::make_uninitialized(gvn, type-&gt;as_value_klass());
756       vt-&gt;initialize_fields(kit, multi, sig, base_input, sig_offset - type-&gt;as_value_klass()-&gt;first_field_offset(), in);
757       parm = gvn.transform(vt);
758     } else {
759       if (multi-&gt;is_Start()) {
760         assert(in, &quot;return from start?&quot;);
761         parm = gvn.transform(new ParmNode(multi-&gt;as_Start(), base_input));
762       } else if (in) {
763         parm = multi-&gt;as_Call()-&gt;in(base_input);
764       } else {
765         parm = gvn.transform(new ProjNode(multi-&gt;as_Call(), base_input));
766       }
<span class="line-modified">767       if (field_is_flattenable(idx)) {</span>
<span class="line-modified">768         // Non-flattened but flattenable value type</span>
769         if (type-&gt;as_value_klass()-&gt;is_scalarizable()) {
770           parm = ValueTypeNode::make_from_oop(kit, parm, type-&gt;as_value_klass());
771         } else {
772           parm = kit-&gt;null2default(parm, type-&gt;as_value_klass());
773         }
774       }
775       base_input += type2size[type-&gt;basic_type()];
776       // Skip reserved arguments
777       BasicType bt = type-&gt;basic_type();
778       while (SigEntry::next_is_reserved(sig, bt)) {
779         base_input += type2size[bt];
780       }
781     }
782     assert(parm != NULL, &quot;should never be null&quot;);
783     set_field_value(idx, parm);
784     gvn.record_for_igvn(parm);
785   }
786 }
787 
788 Node* ValueTypeNode::Ideal(PhaseGVN* phase, bool can_reshape) {
</pre>
</td>
<td>
<hr />
<pre>
175 
176 uint ValueTypeBaseNode::field_index(int offset) const {
177   uint i = 0;
178   for (; i &lt; field_count() &amp;&amp; field_offset(i) != offset; i++) { }
179   assert(i &lt; field_count(), &quot;field not found&quot;);
180   return i;
181 }
182 
183 ciType* ValueTypeBaseNode::field_type(uint index) const {
184   assert(index &lt; field_count(), &quot;index out of bounds&quot;);
185   return value_klass()-&gt;declared_nonstatic_field_at(index)-&gt;type();
186 }
187 
188 bool ValueTypeBaseNode::field_is_flattened(uint index) const {
189   assert(index &lt; field_count(), &quot;index out of bounds&quot;);
190   ciField* field = value_klass()-&gt;declared_nonstatic_field_at(index);
191   assert(!field-&gt;is_flattened() || field-&gt;type()-&gt;is_valuetype(), &quot;must be a value type&quot;);
192   return field-&gt;is_flattened();
193 }
194 







195 int ValueTypeBaseNode::make_scalar_in_safepoint(PhaseIterGVN* igvn, Unique_Node_List&amp; worklist, SafePointNode* sfpt) {
196   ciValueKlass* vk = value_klass();
197   uint nfields = vk-&gt;nof_nonstatic_fields();
198   JVMState* jvms = sfpt-&gt;jvms();
199   int start = jvms-&gt;debug_start();
200   int end   = jvms-&gt;debug_end();
201   // Replace safepoint edge by SafePointScalarObjectNode and add field values
202   assert(jvms != NULL, &quot;missing JVMS&quot;);
203   uint first_ind = (sfpt-&gt;req() - jvms-&gt;scloff());
204   SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(value_ptr(),
205 #ifdef ASSERT
206                                                                   NULL,
207 #endif
208                                                                   first_ind, nfields);
209   sobj-&gt;init_req(0, igvn-&gt;C-&gt;root());
210   // Iterate over the value type fields in order of increasing
211   // offset and add the field values to the safepoint.
212   for (uint j = 0; j &lt; nfields; ++j) {
213     int offset = vk-&gt;nonstatic_field_at(j)-&gt;offset();
214     Node* value = field_value_by_offset(offset, true /* include flattened value type fields */);
</pre>
<hr />
<pre>
256   if ((decorators &amp; C2_MISMATCHED) != 0) {
257     adr_type = TypeRawPtr::BOTTOM;
258   } else if (is_array) {
259     // In the case of a flattened value type array, each field has its own slice
260     adr_type = ary_type-&gt;with_field_offset(offset)-&gt;add_offset(Type::OffsetBot);
261   } else {
262     ciField* field = holder-&gt;get_field_by_offset(offset, false);
263     assert(field != NULL, &quot;field not found&quot;);
264     adr_type = gvn.C-&gt;alias_type(field)-&gt;adr_type();
265   }
266   return adr_type;
267 }
268 
269 void ValueTypeBaseNode::load(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {
270   // Initialize the value type by loading its field values from
271   // memory and adding the values as input edges to the node.
272   for (uint i = 0; i &lt; field_count(); ++i) {
273     int offset = holder_offset + field_offset(i);
274     Node* value = NULL;
275     ciType* ft = field_type(i);

276     if (field_is_flattened(i)) {
277       // Recursively load the flattened value type field
278       value = ValueTypeNode::make_from_flattened(kit, ft-&gt;as_value_klass(), base, ptr, holder, offset, decorators);
279     } else {
280       const TypeOopPtr* oop_ptr = kit-&gt;gvn().type(base)-&gt;isa_oopptr();
281       bool is_array = (oop_ptr-&gt;isa_aryptr() != NULL);
282       if (base-&gt;is_Con() &amp;&amp; !is_array) {
283         // If the oop to the value type is constant (static final field), we can
284         // also treat the fields as constants because the value type is immutable.
285         ciObject* constant_oop = oop_ptr-&gt;const_oop();
286         ciField* field = holder-&gt;get_field_by_offset(offset, false);
287         assert(field != NULL, &quot;field not found&quot;);
288         ciConstant constant = constant_oop-&gt;as_instance()-&gt;field_value(field);
289         const Type* con_type = Type::make_from_constant(constant, /*require_const=*/ true);
290         assert(con_type != NULL, &quot;type not found&quot;);
291         value = kit-&gt;gvn().transform(kit-&gt;makecon(con_type));
<span class="line-modified">292         // Check type of constant which might be more precise than the static field type</span>
<span class="line-modified">293         if (con_type-&gt;is_valuetypeptr()) {</span>
<span class="line-modified">294           assert(!con_type-&gt;is_zero_type(), &quot;Value types are null-free&quot;);</span>
295           ft = con_type-&gt;value_klass();

296         }
297       } else {
298         // Load field value from memory
299         const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit-&gt;gvn());
300         Node* adr = kit-&gt;basic_plus_adr(base, ptr, offset);
301         BasicType bt = type2field[ft-&gt;basic_type()];
302         assert(is_java_primitive(bt) || adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() == UseCompressedOops, &quot;inconsistent&quot;);
303         const Type* val_type = Type::get_const_type(ft);
304         if (is_array) {
305           decorators |= IS_ARRAY;
306         }
307         value = kit-&gt;access_load_at(base, adr, adr_type, val_type, bt, decorators);
308       }
<span class="line-modified">309       if (ft-&gt;is_valuetype()) {</span>
<span class="line-modified">310         // Loading a non-flattened value type from memory</span>
311         if (ft-&gt;as_value_klass()-&gt;is_scalarizable()) {
312           value = ValueTypeNode::make_from_oop(kit, value, ft-&gt;as_value_klass());
313         } else {
314           value = kit-&gt;null2default(value, ft-&gt;as_value_klass());
315         }
316       }
317     }
318     set_field_value(i, value);
319   }
320 }
321 
322 void ValueTypeBaseNode::store_flattened(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {
323   // The value type is embedded into the object without an oop header. Subtract the
324   // offset of the first field to account for the missing header when storing the values.
325   if (holder == NULL) {
326     holder = value_klass();
327   }
328   holder_offset -= value_klass()-&gt;first_field_offset();
329   store(kit, base, ptr, holder, holder_offset, decorators);
330 }
331 
332 void ValueTypeBaseNode::store(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {
333   // Write field values to memory
334   for (uint i = 0; i &lt; field_count(); ++i) {
335     int offset = holder_offset + field_offset(i);
336     Node* value = field_value(i);
337     ciType* ft = field_type(i);
338     if (field_is_flattened(i)) {
339       // Recursively store the flattened value type field
340       if (!value-&gt;is_ValueType()) {
<span class="line-modified">341         assert(!kit-&gt;gvn().type(value)-&gt;maybe_null(), &quot;Inline types are null-free&quot;);</span>
342         value = ValueTypeNode::make_from_oop(kit, value, ft-&gt;as_value_klass());
343       }
344       value-&gt;as_ValueType()-&gt;store_flattened(kit, base, ptr, holder, offset, decorators);
345     } else {
346       // Store field value to memory
347       const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit-&gt;gvn());
348       Node* adr = kit-&gt;basic_plus_adr(base, ptr, offset);
349       BasicType bt = type2field[ft-&gt;basic_type()];
350       assert(is_java_primitive(bt) || adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() == UseCompressedOops, &quot;inconsistent&quot;);
351       const Type* val_type = Type::get_const_type(ft);
352       const TypeAryPtr* ary_type = kit-&gt;gvn().type(base)-&gt;isa_aryptr();
353       if (ary_type != NULL) {
354         decorators |= IS_ARRAY;
355       }
356       kit-&gt;access_store_at(base, adr, adr_type, value, val_type, bt, decorators);
357     }
358   }
359 }
360 
361 ValueTypePtrNode* ValueTypeBaseNode::buffer(GraphKit* kit, bool safe_for_replace) {
</pre>
<hr />
<pre>
484   return vt;
485 }
486 
487 ValueTypeNode* ValueTypeNode::make_uninitialized(PhaseGVN&amp; gvn, ciValueKlass* vk) {
488   // Create a new ValueTypeNode with uninitialized values and NULL oop
489   Node* oop = vk-&gt;is_empty() ? default_oop(gvn, vk) : gvn.zerocon(T_INLINE_TYPE);
490   return new ValueTypeNode(vk, oop);
491 }
492 
493 Node* ValueTypeNode::default_oop(PhaseGVN&amp; gvn, ciValueKlass* vk) {
494   // Returns the constant oop of the default value type allocation
495   return gvn.makecon(TypeInstPtr::make(vk-&gt;default_value_instance()));
496 }
497 
498 ValueTypeNode* ValueTypeNode::make_default(PhaseGVN&amp; gvn, ciValueKlass* vk) {
499   // Create a new ValueTypeNode with default values
500   ValueTypeNode* vt = new ValueTypeNode(vk, default_oop(gvn, vk));
501   for (uint i = 0; i &lt; vt-&gt;field_count(); ++i) {
502     ciType* field_type = vt-&gt;field_type(i);
503     Node* value = NULL;
<span class="line-modified">504     if (field_type-&gt;is_valuetype()) {</span>
505       ciValueKlass* field_klass = field_type-&gt;as_value_klass();
506       if (field_klass-&gt;is_scalarizable() || vt-&gt;field_is_flattened(i)) {
507         value = ValueTypeNode::make_default(gvn, field_klass);
508       } else {
509         value = default_oop(gvn, field_klass);
510       }
511     } else {
512       value = gvn.zerocon(field_type-&gt;basic_type());
513     }
514     vt-&gt;set_field_value(i, value);
515   }
516   vt = gvn.transform(vt)-&gt;as_ValueType();
517   assert(vt-&gt;is_default(gvn), &quot;must be the default value type&quot;);
518   return vt;
519 }
520 
521 bool ValueTypeNode::is_default(PhaseGVN&amp; gvn) const {
522   for (uint i = 0; i &lt; field_count(); ++i) {
523     Node* value = field_value(i);
524     if (!gvn.type(value)-&gt;is_zero_type() &amp;&amp;
</pre>
<hr />
<pre>
738   for (uint i = 0; i &lt; field_count(); i++) {
739     int sig_offset = (*sig)._offset;
740     uint idx = field_index(sig_offset - base_offset);
741     ciType* type = field_type(idx);
742 
743     Node* parm = NULL;
744     if (field_is_flattened(idx)) {
745       // Flattened value type field
746       ValueTypeNode* vt = ValueTypeNode::make_uninitialized(gvn, type-&gt;as_value_klass());
747       vt-&gt;initialize_fields(kit, multi, sig, base_input, sig_offset - type-&gt;as_value_klass()-&gt;first_field_offset(), in);
748       parm = gvn.transform(vt);
749     } else {
750       if (multi-&gt;is_Start()) {
751         assert(in, &quot;return from start?&quot;);
752         parm = gvn.transform(new ParmNode(multi-&gt;as_Start(), base_input));
753       } else if (in) {
754         parm = multi-&gt;as_Call()-&gt;in(base_input);
755       } else {
756         parm = gvn.transform(new ProjNode(multi-&gt;as_Call(), base_input));
757       }
<span class="line-modified">758       if (type-&gt;is_valuetype()) {</span>
<span class="line-modified">759         // Non-flattened value type field</span>
760         if (type-&gt;as_value_klass()-&gt;is_scalarizable()) {
761           parm = ValueTypeNode::make_from_oop(kit, parm, type-&gt;as_value_klass());
762         } else {
763           parm = kit-&gt;null2default(parm, type-&gt;as_value_klass());
764         }
765       }
766       base_input += type2size[type-&gt;basic_type()];
767       // Skip reserved arguments
768       BasicType bt = type-&gt;basic_type();
769       while (SigEntry::next_is_reserved(sig, bt)) {
770         base_input += type2size[bt];
771       }
772     }
773     assert(parm != NULL, &quot;should never be null&quot;);
774     set_field_value(idx, parm);
775     gvn.record_for_igvn(parm);
776   }
777 }
778 
779 Node* ValueTypeNode::Ideal(PhaseGVN* phase, bool can_reshape) {
</pre>
</td>
</tr>
</table>
<center><a href="type.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valuetypenode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciTypeFlow.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciType.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciTypeFlow.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciTypeFlow.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 259 // ciTypeFlow::StateVector::type_meet
 260 //
 261 // Meet two types.
 262 //
 263 // The semi-lattice of types use by this analysis are modeled on those
 264 // of the verifier.  The lattice is as follows:
 265 //
 266 //        top_type() &gt;= all non-extremal types &gt;= bottom_type
 267 //                             and
 268 //   Every primitive type is comparable only with itself.  The meet of
 269 //   reference types is determined by their kind: instance class,
 270 //   interface, or array class.  The meet of two types of the same
 271 //   kind is their least common ancestor.  The meet of two types of
 272 //   different kinds is always java.lang.Object.
 273 ciType* ciTypeFlow::StateVector::type_meet_internal(ciType* t1, ciType* t2, ciTypeFlow* analyzer) {
 274   assert(t1 != t2, &quot;checked in caller&quot;);
 275   if (t1-&gt;equals(top_type())) {
 276     return t2;
 277   } else if (t2-&gt;equals(top_type())) {
 278     return t1;
<span class="line-modified"> 279   }</span>
<span class="line-removed"> 280 </span>
<span class="line-removed"> 281   // Unwrap after saving nullness information and handling top meets</span>
<span class="line-removed"> 282   bool never_null1 = t1-&gt;is_never_null();</span>
<span class="line-removed"> 283   bool never_null2 = t2-&gt;is_never_null();</span>
<span class="line-removed"> 284   if (t1-&gt;unwrap() == t2-&gt;unwrap() &amp;&amp; never_null1 == never_null2) {</span>
<span class="line-removed"> 285     return t1;</span>
<span class="line-removed"> 286   }</span>
<span class="line-removed"> 287   t1 = t1-&gt;unwrap();</span>
<span class="line-removed"> 288   t2 = t2-&gt;unwrap();</span>
<span class="line-removed"> 289 </span>
<span class="line-removed"> 290   if (t1-&gt;is_primitive_type() || t2-&gt;is_primitive_type()) {</span>
 291     // Special case null_type.  null_type meet any reference type T
<span class="line-modified"> 292     // is T.  null_type meet null_type is null_type.</span>
 293     if (t1-&gt;equals(null_type())) {
<span class="line-modified"> 294       if (!t2-&gt;is_primitive_type() || t2-&gt;equals(null_type())) {</span>



 295         return t2;
 296       }
 297     } else if (t2-&gt;equals(null_type())) {
<span class="line-modified"> 298       if (!t1-&gt;is_primitive_type()) {</span>



 299         return t1;
 300       }
 301     }
 302 
 303     // At least one of the two types is a non-top primitive type.
 304     // The other type is not equal to it.  Fall to bottom.
 305     return bottom_type();
 306   }
 307 
 308   // Both types are non-top non-primitive types.  That is,
 309   // both types are either instanceKlasses or arrayKlasses.
 310   ciKlass* object_klass = analyzer-&gt;env()-&gt;Object_klass();
 311   ciKlass* k1 = t1-&gt;as_klass();
 312   ciKlass* k2 = t2-&gt;as_klass();
 313   if (k1-&gt;equals(object_klass) || k2-&gt;equals(object_klass)) {
 314     return object_klass;
 315   } else if (!k1-&gt;is_loaded() || !k2-&gt;is_loaded()) {
 316     // Unloaded classes fall to java.lang.Object at a merge.
 317     return object_klass;
 318   } else if (k1-&gt;is_interface() != k2-&gt;is_interface()) {
</pre>
<hr />
<pre>
 332       if (elem1 != elem2) {
 333         elem = type_meet_internal(elem1, elem2, analyzer)-&gt;as_klass();
 334       }
 335       // Do an easy shortcut if one type is a super of the other.
 336       if (elem == elem1) {
 337         assert(k1 == ciArrayKlass::make(elem), &quot;shortcut is OK&quot;);
 338         return k1;
 339       } else if (elem == elem2) {
 340         assert(k2 == ciArrayKlass::make(elem), &quot;shortcut is OK&quot;);
 341         return k2;
 342       } else {
 343         return ciArrayKlass::make(elem);
 344       }
 345     } else {
 346       return object_klass;
 347     }
 348   } else {
 349     // Must be two plain old instance klasses.
 350     assert(k1-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);
 351     assert(k2-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);
<span class="line-modified"> 352     ciType* result = k1-&gt;least_common_ancestor(k2);</span>
<span class="line-removed"> 353     if (never_null1 &amp;&amp; never_null2 &amp;&amp; result-&gt;is_valuetype()) {</span>
<span class="line-removed"> 354       // Both value types are never null, mark the result as never null</span>
<span class="line-removed"> 355       result = analyzer-&gt;mark_as_never_null(result);</span>
<span class="line-removed"> 356     }</span>
<span class="line-removed"> 357     return result;</span>
 358   }
 359 }
 360 
 361 
 362 // ------------------------------------------------------------------
 363 // ciTypeFlow::StateVector::StateVector
 364 //
 365 // Build a new state vector
 366 ciTypeFlow::StateVector::StateVector(ciTypeFlow* analyzer) {
 367   _outer = analyzer;
 368   _stack_size = -1;
 369   _monitor_count = -1;
 370   // Allocate the _types array
 371   int max_cells = analyzer-&gt;max_cells();
 372   _types = (ciType**)analyzer-&gt;arena()-&gt;Amalloc(sizeof(ciType*) * max_cells);
 373   for (int i=0; i&lt;max_cells; i++) {
 374     _types[i] = top_type();
 375   }
 376   _trap_bci = -1;
 377   _trap_index = 0;
</pre>
<hr />
<pre>
 399     }
 400     // load up the non-OSR state at this point
 401     non_osr_block-&gt;copy_state_into(state);
 402     int non_osr_start = non_osr_block-&gt;start();
 403     if (non_osr_start != start_bci()) {
 404       // must flow forward from it
 405       if (CITraceTypeFlow) {
 406         tty-&gt;print_cr(&quot;&gt;&gt; Interpreting pre-OSR block %d:&quot;, non_osr_start);
 407       }
 408       Block* block = block_at(non_osr_start, jsrs);
 409       assert(block-&gt;limit() == start_bci(), &quot;must flow forward to start&quot;);
 410       flow_block(block, state, jsrs);
 411     }
 412     return state;
 413     // Note:  The code below would be an incorrect for an OSR flow,
 414     // even if it were possible for an OSR entry point to be at bci zero.
 415   }
 416   // &quot;Push&quot; the method signature into the first few locals.
 417   state-&gt;set_stack_size(-max_locals());
 418   if (!method()-&gt;is_static()) {
<span class="line-modified"> 419     ciType* holder = method()-&gt;holder();</span>
<span class="line-removed"> 420     if (holder-&gt;is_valuetype()) {</span>
<span class="line-removed"> 421       // The receiver is never null</span>
<span class="line-removed"> 422       holder = mark_as_never_null(holder);</span>
<span class="line-removed"> 423     }</span>
<span class="line-removed"> 424     state-&gt;push(holder);</span>
 425     assert(state-&gt;tos() == state-&gt;local(0), &quot;&quot;);
 426   }
 427   for (ciSignatureStream str(method()-&gt;signature());
 428        !str.at_return_type();
 429        str.next()) {
<span class="line-modified"> 430     ciType* arg = str.type();</span>
<span class="line-removed"> 431     if (str.is_never_null()) {</span>
<span class="line-removed"> 432       arg = mark_as_never_null(arg);</span>
<span class="line-removed"> 433     }</span>
<span class="line-removed"> 434     state-&gt;push_translate(arg);</span>
 435   }
 436   // Set the rest of the locals to bottom.
 437   Cell cell = state-&gt;next_cell(state-&gt;tos());
 438   state-&gt;set_stack_size(0);
 439   int limit = state-&gt;limit_cell();
 440   for (; cell &lt; limit; cell = state-&gt;next_cell(cell)) {
 441     state-&gt;set_type_at(cell, state-&gt;bottom_type());
 442   }
 443   // Lock an object, if necessary.
 444   state-&gt;set_monitor_count(method()-&gt;is_synchronized() ? 1 : 0);
 445   return state;
 446 }
 447 
 448 // ------------------------------------------------------------------
 449 // ciTypeFlow::StateVector::copy_into
 450 //
 451 // Copy our value into some other StateVector
 452 void ciTypeFlow::StateVector::copy_into(ciTypeFlow::StateVector* copy)
 453 const {
 454   copy-&gt;set_stack_size(stack_size());
</pre>
<hr />
<pre>
 590     // (The compiler will generate an unconditional exception here.)
 591     push(null_type());
 592     return;
 593   }
 594   if (!array_klass-&gt;is_loaded()) {
 595     // Only fails for some -Xcomp runs
 596     trap(str, array_klass,
 597          Deoptimization::make_trap_request
 598          (Deoptimization::Reason_unloaded,
 599           Deoptimization::Action_reinterpret));
 600     return;
 601   }
 602   ciKlass* element_klass = array_klass-&gt;element_klass();
 603   if (!element_klass-&gt;is_loaded() &amp;&amp; element_klass-&gt;is_instance_klass()) {
 604     Untested(&quot;unloaded array element class in ciTypeFlow&quot;);
 605     trap(str, element_klass,
 606          Deoptimization::make_trap_request
 607          (Deoptimization::Reason_unloaded,
 608           Deoptimization::Action_reinterpret));
 609   } else {
<span class="line-modified"> 610     if (element_klass-&gt;is_valuetype()) {</span>
<span class="line-removed"> 611       // Value type array elements are never null</span>
<span class="line-removed"> 612       push(outer()-&gt;mark_as_never_null(element_klass));</span>
<span class="line-removed"> 613     } else {</span>
<span class="line-removed"> 614       push_object(element_klass);</span>
<span class="line-removed"> 615     }</span>
 616   }
 617 }
 618 
 619 
 620 // ------------------------------------------------------------------
 621 // ciTypeFlow::StateVector::do_checkcast
 622 void ciTypeFlow::StateVector::do_checkcast(ciBytecodeStream* str) {
 623   bool will_link;
 624   ciKlass* klass = str-&gt;get_klass(will_link);
<span class="line-removed"> 625   bool never_null = str-&gt;is_klass_never_null();</span>
 626   if (!will_link) {
<span class="line-modified"> 627     if (never_null) {</span>
 628       trap(str, klass,
 629            Deoptimization::make_trap_request
 630            (Deoptimization::Reason_unloaded,
 631             Deoptimization::Action_reinterpret));
 632     } else {
 633       // VM&#39;s interpreter will not load &#39;klass&#39; if object is NULL.
 634       // Type flow after this block may still be needed in two situations:
 635       // 1) C2 uses do_null_assert() and continues compilation for later blocks
 636       // 2) C2 does an OSR compile in a later block (see bug 4778368).
 637       pop_object();
 638       do_null_assert(klass);
 639     }
 640   } else {
<span class="line-modified"> 641     ciType* type = pop_value();</span>
<span class="line-modified"> 642     if (klass-&gt;is_valuetype() &amp;&amp; (never_null || type-&gt;is_never_null())) {</span>
<span class="line-removed"> 643       // Casting to a Q-Type contains a NULL check</span>
<span class="line-removed"> 644       push(outer()-&gt;mark_as_never_null(klass));</span>
<span class="line-removed"> 645     } else {</span>
<span class="line-removed"> 646       push_object(klass);</span>
<span class="line-removed"> 647     }</span>
 648   }
 649 }
 650 
 651 // ------------------------------------------------------------------
 652 // ciTypeFlow::StateVector::do_getfield
 653 void ciTypeFlow::StateVector::do_getfield(ciBytecodeStream* str) {
 654   // could add assert here for type of object.
 655   pop_object();
 656   do_getstatic(str);
 657 }
 658 
 659 // ------------------------------------------------------------------
 660 // ciTypeFlow::StateVector::do_getstatic
 661 void ciTypeFlow::StateVector::do_getstatic(ciBytecodeStream* str) {
 662   bool will_link;
 663   ciField* field = str-&gt;get_field(will_link);
 664   if (!will_link) {
 665     trap(str, field-&gt;holder(), str-&gt;get_field_holder_index());
 666   } else {
 667     ciType* field_type = field-&gt;type();
</pre>
<hr />
<pre>
 669       // Normally, we need the field&#39;s type to be loaded if we are to
 670       // do anything interesting with its value.
 671       // We used to do this:  trap(str, str-&gt;get_field_signature_index());
 672       //
 673       // There is one good reason not to trap here.  Execution can
 674       // get past this &quot;getfield&quot; or &quot;getstatic&quot; if the value of
 675       // the field is null.  As long as the value is null, the class
 676       // does not need to be loaded!  The compiler must assume that
 677       // the value of the unloaded class reference is null; if the code
 678       // ever sees a non-null value, loading has occurred.
 679       //
 680       // This actually happens often enough to be annoying.  If the
 681       // compiler throws an uncommon trap at this bytecode, you can
 682       // get an endless loop of recompilations, when all the code
 683       // needs to do is load a series of null values.  Also, a trap
 684       // here can make an OSR entry point unreachable, triggering the
 685       // assert on non_osr_block in ciTypeFlow::get_start_state.
 686       // (See bug 4379915.)
 687       do_null_assert(field_type-&gt;as_klass());
 688     } else {
<span class="line-removed"> 689       if (field-&gt;is_flattenable()) {</span>
<span class="line-removed"> 690         // A flattenable field is never null</span>
<span class="line-removed"> 691         field_type = outer()-&gt;mark_as_never_null(field_type);</span>
<span class="line-removed"> 692       }</span>
 693       push_translate(field_type);
 694     }
 695   }
 696 }
 697 
 698 // ------------------------------------------------------------------
 699 // ciTypeFlow::StateVector::do_invoke
 700 void ciTypeFlow::StateVector::do_invoke(ciBytecodeStream* str,
 701                                         bool has_receiver) {
 702   bool will_link;
 703   ciSignature* declared_signature = NULL;
 704   ciMethod* callee = str-&gt;get_method(will_link, &amp;declared_signature);
 705   assert(declared_signature != NULL, &quot;cannot be null&quot;);
 706   if (!will_link) {
 707     // We weren&#39;t able to find the method.
 708     if (str-&gt;cur_bc() == Bytecodes::_invokedynamic) {
 709       trap(str, NULL,
 710            Deoptimization::make_trap_request
 711            (Deoptimization::Reason_uninitialized,
 712             Deoptimization::Action_reinterpret));
</pre>
<hr />
<pre>
 740       // Check this?
 741       pop_object();
 742     }
 743     assert(!sigstr.is_done(), &quot;must have return type&quot;);
 744     ciType* return_type = sigstr.type();
 745     if (!return_type-&gt;is_void()) {
 746       if (!return_type-&gt;is_loaded()) {
 747         // As in do_getstatic(), generally speaking, we need the return type to
 748         // be loaded if we are to do anything interesting with its value.
 749         // We used to do this:  trap(str, str-&gt;get_method_signature_index());
 750         //
 751         // We do not trap here since execution can get past this invoke if
 752         // the return value is null.  As long as the value is null, the class
 753         // does not need to be loaded!  The compiler must assume that
 754         // the value of the unloaded class reference is null; if the code
 755         // ever sees a non-null value, loading has occurred.
 756         //
 757         // See do_getstatic() for similar explanation, as well as bug 4684993.
 758         do_null_assert(return_type-&gt;as_klass());
 759       } else {
<span class="line-removed"> 760         if (sigstr.is_never_null()) {</span>
<span class="line-removed"> 761           return_type = outer()-&gt;mark_as_never_null(return_type);</span>
<span class="line-removed"> 762         }</span>
 763         push_translate(return_type);
 764       }
 765     }
 766   }
 767 }
 768 
 769 // ------------------------------------------------------------------
 770 // ciTypeFlow::StateVector::do_jsr
 771 void ciTypeFlow::StateVector::do_jsr(ciBytecodeStream* str) {
 772   push(ciReturnAddress::make(str-&gt;next_bci()));
 773 }
 774 
 775 // ------------------------------------------------------------------
 776 // ciTypeFlow::StateVector::do_ldc
 777 void ciTypeFlow::StateVector::do_ldc(ciBytecodeStream* str) {
 778   ciConstant con = str-&gt;get_constant();
 779   BasicType basic_type = con.basic_type();
 780   if (basic_type == T_ILLEGAL) {
 781     // OutOfMemoryError in the CI while loading constant
 782     push_null();
 783     outer()-&gt;record_failure(&quot;ldc did not link&quot;);
 784     return;
 785   }
 786   if (is_reference_type(basic_type)) {
 787     ciObject* obj = con.as_object();
 788     if (obj-&gt;is_null_object()) {
 789       push_null();
 790     } else {
 791       assert(obj-&gt;is_instance() || obj-&gt;is_array(), &quot;must be java_mirror of klass&quot;);
<span class="line-modified"> 792       ciType* type = obj-&gt;klass();</span>
<span class="line-removed"> 793       if (type-&gt;is_valuetype()) {</span>
<span class="line-removed"> 794         type = outer()-&gt;mark_as_never_null(type);</span>
<span class="line-removed"> 795       }</span>
<span class="line-removed"> 796       push(type);</span>
 797     }
 798   } else {
 799     push_translate(ciType::make(basic_type));
 800   }
 801 }
 802 
 803 // ------------------------------------------------------------------
 804 // ciTypeFlow::StateVector::do_multianewarray
 805 void ciTypeFlow::StateVector::do_multianewarray(ciBytecodeStream* str) {
 806   int dimensions = str-&gt;get_dimensions();
 807   bool will_link;
 808   ciArrayKlass* array_klass = str-&gt;get_klass(will_link)-&gt;as_array_klass();
 809   if (!will_link) {
 810     trap(str, array_klass, str-&gt;get_klass_index());
 811   } else {
 812     for (int i = 0; i &lt; dimensions; i++) {
 813       pop_int();
 814     }
 815     push_object(array_klass);
 816   }
</pre>
<hr />
<pre>
 819 // ------------------------------------------------------------------
 820 // ciTypeFlow::StateVector::do_new
 821 void ciTypeFlow::StateVector::do_new(ciBytecodeStream* str) {
 822   bool will_link;
 823   ciKlass* klass = str-&gt;get_klass(will_link);
 824   if (!will_link || str-&gt;is_unresolved_klass()) {
 825     trap(str, klass, str-&gt;get_klass_index());
 826   } else {
 827     push_object(klass);
 828   }
 829 }
 830 
 831 // ------------------------------------------------------------------
 832 // ciTypeFlow::StateVector::do_defaultvalue
 833 void ciTypeFlow::StateVector::do_defaultvalue(ciBytecodeStream* str) {
 834   bool will_link;
 835   ciKlass* klass = str-&gt;get_klass(will_link);
 836   if (!will_link) {
 837     trap(str, klass, str-&gt;get_klass_index());
 838   } else {
<span class="line-modified"> 839     // The default value type is never null</span>
<span class="line-modified"> 840     push(outer()-&gt;mark_as_never_null(klass));</span>
 841   }
 842 }
 843 
 844 // ------------------------------------------------------------------
 845 // ciTypeFlow::StateVector::do_withfield
 846 void ciTypeFlow::StateVector::do_withfield(ciBytecodeStream* str) {
 847   bool will_link;
 848   ciField* field = str-&gt;get_field(will_link);
 849   ciKlass* klass = field-&gt;holder();
 850   if (!will_link) {
 851     trap(str, klass, str-&gt;get_field_holder_index());
 852   } else {
 853     ciType* type = pop_value();
 854     ciType* field_type = field-&gt;type();
 855     assert(field_type-&gt;is_loaded(), &quot;field type must be loaded&quot;);
 856     if (field_type-&gt;is_two_word()) {
 857       ciType* type2 = pop_value();
 858       assert(type2-&gt;is_two_word(), &quot;must be 2nd half&quot;);
 859       assert(type == half_type(type2), &quot;must be 2nd half&quot;);
 860     }
 861     pop_object();
<span class="line-modified"> 862     // The newly created value type can never be null</span>
<span class="line-modified"> 863     push(outer()-&gt;mark_as_never_null(klass));</span>
 864   }
 865 }
 866 
 867 // ------------------------------------------------------------------
 868 // ciTypeFlow::StateVector::do_newarray
 869 void ciTypeFlow::StateVector::do_newarray(ciBytecodeStream* str) {
 870   pop_int();
 871   ciKlass* klass = ciTypeArrayKlass::make((BasicType)str-&gt;get_index());
 872   push_object(klass);
 873 }
 874 
 875 // ------------------------------------------------------------------
 876 // ciTypeFlow::StateVector::do_putfield
 877 void ciTypeFlow::StateVector::do_putfield(ciBytecodeStream* str) {
 878   do_putstatic(str);
 879   if (_trap_bci != -1)  return;  // unloaded field holder, etc.
 880   // could add assert here for type of object.
 881   pop_object();
 882 }
 883 
</pre>
<hr />
<pre>
3062 
3063 // ------------------------------------------------------------------
3064 // ciTypeFlow::record_failure()
3065 // The ciTypeFlow object keeps track of failure reasons separately from the ciEnv.
3066 // This is required because there is not a 1-1 relation between the ciEnv and
3067 // the TypeFlow passes within a compilation task.  For example, if the compiler
3068 // is considering inlining a method, it will request a TypeFlow.  If that fails,
3069 // the compilation as a whole may continue without the inlining.  Some TypeFlow
3070 // requests are not optional; if they fail the requestor is responsible for
3071 // copying the failure reason up to the ciEnv.  (See Parse::Parse.)
3072 void ciTypeFlow::record_failure(const char* reason) {
3073   if (env()-&gt;log() != NULL) {
3074     env()-&gt;log()-&gt;elem(&quot;failure reason=&#39;%s&#39; phase=&#39;typeflow&#39;&quot;, reason);
3075   }
3076   if (_failure_reason == NULL) {
3077     // Record the first failure reason.
3078     _failure_reason = reason;
3079   }
3080 }
3081 
<span class="line-removed">3082 ciType* ciTypeFlow::mark_as_never_null(ciType* type) {</span>
<span class="line-removed">3083   // Wrap the type to carry the information that it is never null</span>
<span class="line-removed">3084   return env()-&gt;make_never_null_wrapper(type);</span>
<span class="line-removed">3085 }</span>
<span class="line-removed">3086 </span>
3087 #ifndef PRODUCT
3088 // ------------------------------------------------------------------
3089 // ciTypeFlow::print_on
3090 void ciTypeFlow::print_on(outputStream* st) const {
3091   // Walk through CI blocks
3092   st-&gt;print_cr(&quot;********************************************************&quot;);
3093   st-&gt;print   (&quot;TypeFlow for &quot;);
3094   method()-&gt;name()-&gt;print_symbol_on(st);
3095   int limit_bci = code_size();
3096   st-&gt;print_cr(&quot;  %d bytes&quot;, limit_bci);
3097   ciMethodBlocks  *mblks = _methodBlocks;
3098   ciBlock* current = NULL;
3099   for (int bci = 0; bci &lt; limit_bci; bci++) {
3100     ciBlock* blk = mblks-&gt;block_containing(bci);
3101     if (blk != NULL &amp;&amp; blk != current) {
3102       current = blk;
3103       current-&gt;print_on(st);
3104 
3105       GrowableArray&lt;Block*&gt;* blocks = _idx_to_blocklist[blk-&gt;index()];
3106       int num_blocks = (blocks == NULL) ? 0 : blocks-&gt;length();
</pre>
</td>
<td>
<hr />
<pre>
 259 // ciTypeFlow::StateVector::type_meet
 260 //
 261 // Meet two types.
 262 //
 263 // The semi-lattice of types use by this analysis are modeled on those
 264 // of the verifier.  The lattice is as follows:
 265 //
 266 //        top_type() &gt;= all non-extremal types &gt;= bottom_type
 267 //                             and
 268 //   Every primitive type is comparable only with itself.  The meet of
 269 //   reference types is determined by their kind: instance class,
 270 //   interface, or array class.  The meet of two types of the same
 271 //   kind is their least common ancestor.  The meet of two types of
 272 //   different kinds is always java.lang.Object.
 273 ciType* ciTypeFlow::StateVector::type_meet_internal(ciType* t1, ciType* t2, ciTypeFlow* analyzer) {
 274   assert(t1 != t2, &quot;checked in caller&quot;);
 275   if (t1-&gt;equals(top_type())) {
 276     return t2;
 277   } else if (t2-&gt;equals(top_type())) {
 278     return t1;
<span class="line-modified"> 279   } else if (t1-&gt;is_primitive_type() || t2-&gt;is_primitive_type()) {</span>











 280     // Special case null_type.  null_type meet any reference type T
<span class="line-modified"> 281     // is T (except for inline types).  null_type meet null_type is null_type.</span>
 282     if (t1-&gt;equals(null_type())) {
<span class="line-modified"> 283       if (t2-&gt;is_valuetype()) {</span>
<span class="line-added"> 284         // Inline types are null-free, return the super type</span>
<span class="line-added"> 285         return t2-&gt;as_value_klass()-&gt;super();</span>
<span class="line-added"> 286       } else if (!t2-&gt;is_primitive_type() || t2-&gt;equals(null_type())) {</span>
 287         return t2;
 288       }
 289     } else if (t2-&gt;equals(null_type())) {
<span class="line-modified"> 290       if (t1-&gt;is_valuetype()) {</span>
<span class="line-added"> 291         // Inline types are null-free, return the super type</span>
<span class="line-added"> 292         return t1-&gt;as_value_klass()-&gt;super();</span>
<span class="line-added"> 293       } else if (!t1-&gt;is_primitive_type()) {</span>
 294         return t1;
 295       }
 296     }
 297 
 298     // At least one of the two types is a non-top primitive type.
 299     // The other type is not equal to it.  Fall to bottom.
 300     return bottom_type();
 301   }
 302 
 303   // Both types are non-top non-primitive types.  That is,
 304   // both types are either instanceKlasses or arrayKlasses.
 305   ciKlass* object_klass = analyzer-&gt;env()-&gt;Object_klass();
 306   ciKlass* k1 = t1-&gt;as_klass();
 307   ciKlass* k2 = t2-&gt;as_klass();
 308   if (k1-&gt;equals(object_klass) || k2-&gt;equals(object_klass)) {
 309     return object_klass;
 310   } else if (!k1-&gt;is_loaded() || !k2-&gt;is_loaded()) {
 311     // Unloaded classes fall to java.lang.Object at a merge.
 312     return object_klass;
 313   } else if (k1-&gt;is_interface() != k2-&gt;is_interface()) {
</pre>
<hr />
<pre>
 327       if (elem1 != elem2) {
 328         elem = type_meet_internal(elem1, elem2, analyzer)-&gt;as_klass();
 329       }
 330       // Do an easy shortcut if one type is a super of the other.
 331       if (elem == elem1) {
 332         assert(k1 == ciArrayKlass::make(elem), &quot;shortcut is OK&quot;);
 333         return k1;
 334       } else if (elem == elem2) {
 335         assert(k2 == ciArrayKlass::make(elem), &quot;shortcut is OK&quot;);
 336         return k2;
 337       } else {
 338         return ciArrayKlass::make(elem);
 339       }
 340     } else {
 341       return object_klass;
 342     }
 343   } else {
 344     // Must be two plain old instance klasses.
 345     assert(k1-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);
 346     assert(k2-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);
<span class="line-modified"> 347     return k1-&gt;least_common_ancestor(k2);</span>





 348   }
 349 }
 350 
 351 
 352 // ------------------------------------------------------------------
 353 // ciTypeFlow::StateVector::StateVector
 354 //
 355 // Build a new state vector
 356 ciTypeFlow::StateVector::StateVector(ciTypeFlow* analyzer) {
 357   _outer = analyzer;
 358   _stack_size = -1;
 359   _monitor_count = -1;
 360   // Allocate the _types array
 361   int max_cells = analyzer-&gt;max_cells();
 362   _types = (ciType**)analyzer-&gt;arena()-&gt;Amalloc(sizeof(ciType*) * max_cells);
 363   for (int i=0; i&lt;max_cells; i++) {
 364     _types[i] = top_type();
 365   }
 366   _trap_bci = -1;
 367   _trap_index = 0;
</pre>
<hr />
<pre>
 389     }
 390     // load up the non-OSR state at this point
 391     non_osr_block-&gt;copy_state_into(state);
 392     int non_osr_start = non_osr_block-&gt;start();
 393     if (non_osr_start != start_bci()) {
 394       // must flow forward from it
 395       if (CITraceTypeFlow) {
 396         tty-&gt;print_cr(&quot;&gt;&gt; Interpreting pre-OSR block %d:&quot;, non_osr_start);
 397       }
 398       Block* block = block_at(non_osr_start, jsrs);
 399       assert(block-&gt;limit() == start_bci(), &quot;must flow forward to start&quot;);
 400       flow_block(block, state, jsrs);
 401     }
 402     return state;
 403     // Note:  The code below would be an incorrect for an OSR flow,
 404     // even if it were possible for an OSR entry point to be at bci zero.
 405   }
 406   // &quot;Push&quot; the method signature into the first few locals.
 407   state-&gt;set_stack_size(-max_locals());
 408   if (!method()-&gt;is_static()) {
<span class="line-modified"> 409     state-&gt;push(method()-&gt;holder());</span>





 410     assert(state-&gt;tos() == state-&gt;local(0), &quot;&quot;);
 411   }
 412   for (ciSignatureStream str(method()-&gt;signature());
 413        !str.at_return_type();
 414        str.next()) {
<span class="line-modified"> 415     state-&gt;push_translate(str.type());</span>




 416   }
 417   // Set the rest of the locals to bottom.
 418   Cell cell = state-&gt;next_cell(state-&gt;tos());
 419   state-&gt;set_stack_size(0);
 420   int limit = state-&gt;limit_cell();
 421   for (; cell &lt; limit; cell = state-&gt;next_cell(cell)) {
 422     state-&gt;set_type_at(cell, state-&gt;bottom_type());
 423   }
 424   // Lock an object, if necessary.
 425   state-&gt;set_monitor_count(method()-&gt;is_synchronized() ? 1 : 0);
 426   return state;
 427 }
 428 
 429 // ------------------------------------------------------------------
 430 // ciTypeFlow::StateVector::copy_into
 431 //
 432 // Copy our value into some other StateVector
 433 void ciTypeFlow::StateVector::copy_into(ciTypeFlow::StateVector* copy)
 434 const {
 435   copy-&gt;set_stack_size(stack_size());
</pre>
<hr />
<pre>
 571     // (The compiler will generate an unconditional exception here.)
 572     push(null_type());
 573     return;
 574   }
 575   if (!array_klass-&gt;is_loaded()) {
 576     // Only fails for some -Xcomp runs
 577     trap(str, array_klass,
 578          Deoptimization::make_trap_request
 579          (Deoptimization::Reason_unloaded,
 580           Deoptimization::Action_reinterpret));
 581     return;
 582   }
 583   ciKlass* element_klass = array_klass-&gt;element_klass();
 584   if (!element_klass-&gt;is_loaded() &amp;&amp; element_klass-&gt;is_instance_klass()) {
 585     Untested(&quot;unloaded array element class in ciTypeFlow&quot;);
 586     trap(str, element_klass,
 587          Deoptimization::make_trap_request
 588          (Deoptimization::Reason_unloaded,
 589           Deoptimization::Action_reinterpret));
 590   } else {
<span class="line-modified"> 591     push_object(element_klass);</span>





 592   }
 593 }
 594 
 595 
 596 // ------------------------------------------------------------------
 597 // ciTypeFlow::StateVector::do_checkcast
 598 void ciTypeFlow::StateVector::do_checkcast(ciBytecodeStream* str) {
 599   bool will_link;
 600   ciKlass* klass = str-&gt;get_klass(will_link);

 601   if (!will_link) {
<span class="line-modified"> 602     if (str-&gt;is_inline_klass()) {</span>
 603       trap(str, klass,
 604            Deoptimization::make_trap_request
 605            (Deoptimization::Reason_unloaded,
 606             Deoptimization::Action_reinterpret));
 607     } else {
 608       // VM&#39;s interpreter will not load &#39;klass&#39; if object is NULL.
 609       // Type flow after this block may still be needed in two situations:
 610       // 1) C2 uses do_null_assert() and continues compilation for later blocks
 611       // 2) C2 does an OSR compile in a later block (see bug 4778368).
 612       pop_object();
 613       do_null_assert(klass);
 614     }
 615   } else {
<span class="line-modified"> 616     pop_object();</span>
<span class="line-modified"> 617     push_object(klass);</span>





 618   }
 619 }
 620 
 621 // ------------------------------------------------------------------
 622 // ciTypeFlow::StateVector::do_getfield
 623 void ciTypeFlow::StateVector::do_getfield(ciBytecodeStream* str) {
 624   // could add assert here for type of object.
 625   pop_object();
 626   do_getstatic(str);
 627 }
 628 
 629 // ------------------------------------------------------------------
 630 // ciTypeFlow::StateVector::do_getstatic
 631 void ciTypeFlow::StateVector::do_getstatic(ciBytecodeStream* str) {
 632   bool will_link;
 633   ciField* field = str-&gt;get_field(will_link);
 634   if (!will_link) {
 635     trap(str, field-&gt;holder(), str-&gt;get_field_holder_index());
 636   } else {
 637     ciType* field_type = field-&gt;type();
</pre>
<hr />
<pre>
 639       // Normally, we need the field&#39;s type to be loaded if we are to
 640       // do anything interesting with its value.
 641       // We used to do this:  trap(str, str-&gt;get_field_signature_index());
 642       //
 643       // There is one good reason not to trap here.  Execution can
 644       // get past this &quot;getfield&quot; or &quot;getstatic&quot; if the value of
 645       // the field is null.  As long as the value is null, the class
 646       // does not need to be loaded!  The compiler must assume that
 647       // the value of the unloaded class reference is null; if the code
 648       // ever sees a non-null value, loading has occurred.
 649       //
 650       // This actually happens often enough to be annoying.  If the
 651       // compiler throws an uncommon trap at this bytecode, you can
 652       // get an endless loop of recompilations, when all the code
 653       // needs to do is load a series of null values.  Also, a trap
 654       // here can make an OSR entry point unreachable, triggering the
 655       // assert on non_osr_block in ciTypeFlow::get_start_state.
 656       // (See bug 4379915.)
 657       do_null_assert(field_type-&gt;as_klass());
 658     } else {




 659       push_translate(field_type);
 660     }
 661   }
 662 }
 663 
 664 // ------------------------------------------------------------------
 665 // ciTypeFlow::StateVector::do_invoke
 666 void ciTypeFlow::StateVector::do_invoke(ciBytecodeStream* str,
 667                                         bool has_receiver) {
 668   bool will_link;
 669   ciSignature* declared_signature = NULL;
 670   ciMethod* callee = str-&gt;get_method(will_link, &amp;declared_signature);
 671   assert(declared_signature != NULL, &quot;cannot be null&quot;);
 672   if (!will_link) {
 673     // We weren&#39;t able to find the method.
 674     if (str-&gt;cur_bc() == Bytecodes::_invokedynamic) {
 675       trap(str, NULL,
 676            Deoptimization::make_trap_request
 677            (Deoptimization::Reason_uninitialized,
 678             Deoptimization::Action_reinterpret));
</pre>
<hr />
<pre>
 706       // Check this?
 707       pop_object();
 708     }
 709     assert(!sigstr.is_done(), &quot;must have return type&quot;);
 710     ciType* return_type = sigstr.type();
 711     if (!return_type-&gt;is_void()) {
 712       if (!return_type-&gt;is_loaded()) {
 713         // As in do_getstatic(), generally speaking, we need the return type to
 714         // be loaded if we are to do anything interesting with its value.
 715         // We used to do this:  trap(str, str-&gt;get_method_signature_index());
 716         //
 717         // We do not trap here since execution can get past this invoke if
 718         // the return value is null.  As long as the value is null, the class
 719         // does not need to be loaded!  The compiler must assume that
 720         // the value of the unloaded class reference is null; if the code
 721         // ever sees a non-null value, loading has occurred.
 722         //
 723         // See do_getstatic() for similar explanation, as well as bug 4684993.
 724         do_null_assert(return_type-&gt;as_klass());
 725       } else {



 726         push_translate(return_type);
 727       }
 728     }
 729   }
 730 }
 731 
 732 // ------------------------------------------------------------------
 733 // ciTypeFlow::StateVector::do_jsr
 734 void ciTypeFlow::StateVector::do_jsr(ciBytecodeStream* str) {
 735   push(ciReturnAddress::make(str-&gt;next_bci()));
 736 }
 737 
 738 // ------------------------------------------------------------------
 739 // ciTypeFlow::StateVector::do_ldc
 740 void ciTypeFlow::StateVector::do_ldc(ciBytecodeStream* str) {
 741   ciConstant con = str-&gt;get_constant();
 742   BasicType basic_type = con.basic_type();
 743   if (basic_type == T_ILLEGAL) {
 744     // OutOfMemoryError in the CI while loading constant
 745     push_null();
 746     outer()-&gt;record_failure(&quot;ldc did not link&quot;);
 747     return;
 748   }
 749   if (is_reference_type(basic_type)) {
 750     ciObject* obj = con.as_object();
 751     if (obj-&gt;is_null_object()) {
 752       push_null();
 753     } else {
 754       assert(obj-&gt;is_instance() || obj-&gt;is_array(), &quot;must be java_mirror of klass&quot;);
<span class="line-modified"> 755       push_object(obj-&gt;klass());</span>




 756     }
 757   } else {
 758     push_translate(ciType::make(basic_type));
 759   }
 760 }
 761 
 762 // ------------------------------------------------------------------
 763 // ciTypeFlow::StateVector::do_multianewarray
 764 void ciTypeFlow::StateVector::do_multianewarray(ciBytecodeStream* str) {
 765   int dimensions = str-&gt;get_dimensions();
 766   bool will_link;
 767   ciArrayKlass* array_klass = str-&gt;get_klass(will_link)-&gt;as_array_klass();
 768   if (!will_link) {
 769     trap(str, array_klass, str-&gt;get_klass_index());
 770   } else {
 771     for (int i = 0; i &lt; dimensions; i++) {
 772       pop_int();
 773     }
 774     push_object(array_klass);
 775   }
</pre>
<hr />
<pre>
 778 // ------------------------------------------------------------------
 779 // ciTypeFlow::StateVector::do_new
 780 void ciTypeFlow::StateVector::do_new(ciBytecodeStream* str) {
 781   bool will_link;
 782   ciKlass* klass = str-&gt;get_klass(will_link);
 783   if (!will_link || str-&gt;is_unresolved_klass()) {
 784     trap(str, klass, str-&gt;get_klass_index());
 785   } else {
 786     push_object(klass);
 787   }
 788 }
 789 
 790 // ------------------------------------------------------------------
 791 // ciTypeFlow::StateVector::do_defaultvalue
 792 void ciTypeFlow::StateVector::do_defaultvalue(ciBytecodeStream* str) {
 793   bool will_link;
 794   ciKlass* klass = str-&gt;get_klass(will_link);
 795   if (!will_link) {
 796     trap(str, klass, str-&gt;get_klass_index());
 797   } else {
<span class="line-modified"> 798     assert(klass-&gt;is_valuetype(), &quot;should be value type&quot;);</span>
<span class="line-modified"> 799     push_object(klass);</span>
 800   }
 801 }
 802 
 803 // ------------------------------------------------------------------
 804 // ciTypeFlow::StateVector::do_withfield
 805 void ciTypeFlow::StateVector::do_withfield(ciBytecodeStream* str) {
 806   bool will_link;
 807   ciField* field = str-&gt;get_field(will_link);
 808   ciKlass* klass = field-&gt;holder();
 809   if (!will_link) {
 810     trap(str, klass, str-&gt;get_field_holder_index());
 811   } else {
 812     ciType* type = pop_value();
 813     ciType* field_type = field-&gt;type();
 814     assert(field_type-&gt;is_loaded(), &quot;field type must be loaded&quot;);
 815     if (field_type-&gt;is_two_word()) {
 816       ciType* type2 = pop_value();
 817       assert(type2-&gt;is_two_word(), &quot;must be 2nd half&quot;);
 818       assert(type == half_type(type2), &quot;must be 2nd half&quot;);
 819     }
 820     pop_object();
<span class="line-modified"> 821     assert(klass-&gt;is_valuetype(), &quot;should be value type&quot;);</span>
<span class="line-modified"> 822     push_object(klass);</span>
 823   }
 824 }
 825 
 826 // ------------------------------------------------------------------
 827 // ciTypeFlow::StateVector::do_newarray
 828 void ciTypeFlow::StateVector::do_newarray(ciBytecodeStream* str) {
 829   pop_int();
 830   ciKlass* klass = ciTypeArrayKlass::make((BasicType)str-&gt;get_index());
 831   push_object(klass);
 832 }
 833 
 834 // ------------------------------------------------------------------
 835 // ciTypeFlow::StateVector::do_putfield
 836 void ciTypeFlow::StateVector::do_putfield(ciBytecodeStream* str) {
 837   do_putstatic(str);
 838   if (_trap_bci != -1)  return;  // unloaded field holder, etc.
 839   // could add assert here for type of object.
 840   pop_object();
 841 }
 842 
</pre>
<hr />
<pre>
3021 
3022 // ------------------------------------------------------------------
3023 // ciTypeFlow::record_failure()
3024 // The ciTypeFlow object keeps track of failure reasons separately from the ciEnv.
3025 // This is required because there is not a 1-1 relation between the ciEnv and
3026 // the TypeFlow passes within a compilation task.  For example, if the compiler
3027 // is considering inlining a method, it will request a TypeFlow.  If that fails,
3028 // the compilation as a whole may continue without the inlining.  Some TypeFlow
3029 // requests are not optional; if they fail the requestor is responsible for
3030 // copying the failure reason up to the ciEnv.  (See Parse::Parse.)
3031 void ciTypeFlow::record_failure(const char* reason) {
3032   if (env()-&gt;log() != NULL) {
3033     env()-&gt;log()-&gt;elem(&quot;failure reason=&#39;%s&#39; phase=&#39;typeflow&#39;&quot;, reason);
3034   }
3035   if (_failure_reason == NULL) {
3036     // Record the first failure reason.
3037     _failure_reason = reason;
3038   }
3039 }
3040 





3041 #ifndef PRODUCT
3042 // ------------------------------------------------------------------
3043 // ciTypeFlow::print_on
3044 void ciTypeFlow::print_on(outputStream* st) const {
3045   // Walk through CI blocks
3046   st-&gt;print_cr(&quot;********************************************************&quot;);
3047   st-&gt;print   (&quot;TypeFlow for &quot;);
3048   method()-&gt;name()-&gt;print_symbol_on(st);
3049   int limit_bci = code_size();
3050   st-&gt;print_cr(&quot;  %d bytes&quot;, limit_bci);
3051   ciMethodBlocks  *mblks = _methodBlocks;
3052   ciBlock* current = NULL;
3053   for (int bci = 0; bci &lt; limit_bci; bci++) {
3054     ciBlock* blk = mblks-&gt;block_containing(bci);
3055     if (blk != NULL &amp;&amp; blk != current) {
3056       current = blk;
3057       current-&gt;print_on(st);
3058 
3059       GrowableArray&lt;Block*&gt;* blocks = _idx_to_blocklist[blk-&gt;index()];
3060       int num_blocks = (blocks == NULL) ? 0 : blocks-&gt;length();
</pre>
</td>
</tr>
</table>
<center><a href="ciType.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciTypeFlow.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
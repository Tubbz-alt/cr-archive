<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_Instruction.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_C1_C1_INSTRUCTION_HPP
  26 #define SHARE_C1_C1_INSTRUCTION_HPP
  27 
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIR.hpp&quot;
  30 #include &quot;c1/c1_ValueType.hpp&quot;
  31 #include &quot;ci/ciField.hpp&quot;
  32 
  33 // Predefined classes
  34 class ciField;
  35 class ValueStack;
  36 class InstructionPrinter;
  37 class IRScope;
  38 class LIR_OprDesc;
  39 typedef LIR_OprDesc* LIR_Opr;
  40 
  41 
  42 // Instruction class hierarchy
  43 //
  44 // All leaf classes in the class hierarchy are concrete classes
  45 // (i.e., are instantiated). All other classes are abstract and
  46 // serve factoring.
  47 
  48 class Instruction;
  49 class   Phi;
  50 class   Local;
  51 class   Constant;
  52 class   AccessField;
  53 class     LoadField;
  54 class     StoreField;
  55 class   AccessArray;
  56 class     ArrayLength;
  57 class     AccessIndexed;
  58 class       LoadIndexed;
  59 class       StoreIndexed;
  60 class   NegateOp;
  61 class   Op2;
  62 class     ArithmeticOp;
  63 class     ShiftOp;
  64 class     LogicOp;
  65 class     CompareOp;
  66 class     IfOp;
  67 class   Convert;
  68 class   NullCheck;
  69 class   TypeCast;
  70 class   OsrEntry;
  71 class   ExceptionObject;
  72 class   StateSplit;
  73 class     Invoke;
  74 class     NewInstance;
  75 class     NewValueTypeInstance;
  76 class     NewArray;
  77 class       NewTypeArray;
  78 class       NewObjectArray;
  79 class       NewMultiArray;
  80 class     WithField;
  81 class     DefaultValue;
  82 class     TypeCheck;
  83 class       CheckCast;
  84 class       InstanceOf;
  85 class     AccessMonitor;
  86 class       MonitorEnter;
  87 class       MonitorExit;
  88 class     Intrinsic;
  89 class     BlockBegin;
  90 class     BlockEnd;
  91 class       Goto;
  92 class       If;
  93 class       IfInstanceOf;
  94 class       Switch;
  95 class         TableSwitch;
  96 class         LookupSwitch;
  97 class       Return;
  98 class       Throw;
  99 class       Base;
 100 class   RoundFP;
 101 class   UnsafeOp;
 102 class     UnsafeRawOp;
 103 class       UnsafeGetRaw;
 104 class       UnsafePutRaw;
 105 class     UnsafeObjectOp;
 106 class       UnsafeGetObject;
 107 class       UnsafePutObject;
 108 class         UnsafeGetAndSetObject;
 109 class   ProfileCall;
 110 class   ProfileReturnType;
 111 class   ProfileInvoke;
 112 class   RuntimeCall;
 113 class   MemBar;
 114 class   RangeCheckPredicate;
 115 #ifdef ASSERT
 116 class   Assert;
 117 #endif
 118 
 119 // A Value is a reference to the instruction creating the value
 120 typedef Instruction* Value;
 121 typedef GrowableArray&lt;Value&gt; Values;
 122 typedef GrowableArray&lt;ValueStack*&gt; ValueStackStack;
 123 
 124 // BlockClosure is the base class for block traversal/iteration.
 125 
 126 class BlockClosure: public CompilationResourceObj {
 127  public:
 128   virtual void block_do(BlockBegin* block)       = 0;
 129 };
 130 
 131 
 132 // A simple closure class for visiting the values of an Instruction
 133 class ValueVisitor: public StackObj {
 134  public:
 135   virtual void visit(Value* v) = 0;
 136 };
 137 
 138 
 139 // Some array and list classes
 140 typedef GrowableArray&lt;BlockBegin*&gt; BlockBeginArray;
 141 
 142 class BlockList: public GrowableArray&lt;BlockBegin*&gt; {
 143  public:
 144   BlockList(): GrowableArray&lt;BlockBegin*&gt;() {}
 145   BlockList(const int size): GrowableArray&lt;BlockBegin*&gt;(size) {}
 146   BlockList(const int size, BlockBegin* init): GrowableArray&lt;BlockBegin*&gt;(size, size, init) {}
 147 
 148   void iterate_forward(BlockClosure* closure);
 149   void iterate_backward(BlockClosure* closure);
 150   void blocks_do(void f(BlockBegin*));
 151   void values_do(ValueVisitor* f);
 152   void print(bool cfg_only = false, bool live_only = false) PRODUCT_RETURN;
 153 };
 154 
 155 
 156 // InstructionVisitors provide type-based dispatch for instructions.
 157 // For each concrete Instruction class X, a virtual function do_X is
 158 // provided. Functionality that needs to be implemented for all classes
 159 // (e.g., printing, code generation) is factored out into a specialised
 160 // visitor instead of added to the Instruction classes itself.
 161 
 162 class InstructionVisitor: public StackObj {
 163  public:
 164   virtual void do_Phi            (Phi*             x) = 0;
 165   virtual void do_Local          (Local*           x) = 0;
 166   virtual void do_Constant       (Constant*        x) = 0;
 167   virtual void do_LoadField      (LoadField*       x) = 0;
 168   virtual void do_StoreField     (StoreField*      x) = 0;
 169   virtual void do_ArrayLength    (ArrayLength*     x) = 0;
 170   virtual void do_LoadIndexed    (LoadIndexed*     x) = 0;
 171   virtual void do_StoreIndexed   (StoreIndexed*    x) = 0;
 172   virtual void do_NegateOp       (NegateOp*        x) = 0;
 173   virtual void do_ArithmeticOp   (ArithmeticOp*    x) = 0;
 174   virtual void do_ShiftOp        (ShiftOp*         x) = 0;
 175   virtual void do_LogicOp        (LogicOp*         x) = 0;
 176   virtual void do_CompareOp      (CompareOp*       x) = 0;
 177   virtual void do_IfOp           (IfOp*            x) = 0;
 178   virtual void do_Convert        (Convert*         x) = 0;
 179   virtual void do_NullCheck      (NullCheck*       x) = 0;
 180   virtual void do_TypeCast       (TypeCast*        x) = 0;
 181   virtual void do_Invoke         (Invoke*          x) = 0;
 182   virtual void do_NewInstance    (NewInstance*     x) = 0;
 183   virtual void do_NewValueTypeInstance(NewValueTypeInstance* x) = 0;
 184   virtual void do_NewTypeArray   (NewTypeArray*    x) = 0;
 185   virtual void do_NewObjectArray (NewObjectArray*  x) = 0;
 186   virtual void do_NewMultiArray  (NewMultiArray*   x) = 0;
 187   virtual void do_WithField      (WithField*       x) = 0;
 188   virtual void do_DefaultValue   (DefaultValue*    x) = 0;
 189   virtual void do_CheckCast      (CheckCast*       x) = 0;
 190   virtual void do_InstanceOf     (InstanceOf*      x) = 0;
 191   virtual void do_MonitorEnter   (MonitorEnter*    x) = 0;
 192   virtual void do_MonitorExit    (MonitorExit*     x) = 0;
 193   virtual void do_Intrinsic      (Intrinsic*       x) = 0;
 194   virtual void do_BlockBegin     (BlockBegin*      x) = 0;
 195   virtual void do_Goto           (Goto*            x) = 0;
 196   virtual void do_If             (If*              x) = 0;
 197   virtual void do_IfInstanceOf   (IfInstanceOf*    x) = 0;
 198   virtual void do_TableSwitch    (TableSwitch*     x) = 0;
 199   virtual void do_LookupSwitch   (LookupSwitch*    x) = 0;
 200   virtual void do_Return         (Return*          x) = 0;
 201   virtual void do_Throw          (Throw*           x) = 0;
 202   virtual void do_Base           (Base*            x) = 0;
 203   virtual void do_OsrEntry       (OsrEntry*        x) = 0;
 204   virtual void do_ExceptionObject(ExceptionObject* x) = 0;
 205   virtual void do_RoundFP        (RoundFP*         x) = 0;
 206   virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x) = 0;
 207   virtual void do_UnsafePutRaw   (UnsafePutRaw*    x) = 0;
 208   virtual void do_UnsafeGetObject(UnsafeGetObject* x) = 0;
 209   virtual void do_UnsafePutObject(UnsafePutObject* x) = 0;
 210   virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) = 0;
 211   virtual void do_ProfileCall    (ProfileCall*     x) = 0;
 212   virtual void do_ProfileReturnType (ProfileReturnType*  x) = 0;
 213   virtual void do_ProfileInvoke  (ProfileInvoke*   x) = 0;
 214   virtual void do_RuntimeCall    (RuntimeCall*     x) = 0;
 215   virtual void do_MemBar         (MemBar*          x) = 0;
 216   virtual void do_RangeCheckPredicate(RangeCheckPredicate* x) = 0;
 217 #ifdef ASSERT
 218   virtual void do_Assert         (Assert*          x) = 0;
 219 #endif
 220 };
 221 
 222 
 223 // Hashing support
 224 //
 225 // Note: This hash functions affect the performance
 226 //       of ValueMap - make changes carefully!
 227 
 228 #define HASH1(x1            )                    ((intx)(x1))
 229 #define HASH2(x1, x2        )                    ((HASH1(x1            ) &lt;&lt; 7) ^ HASH1(x2))
 230 #define HASH3(x1, x2, x3    )                    ((HASH2(x1, x2        ) &lt;&lt; 7) ^ HASH1(x3))
 231 #define HASH4(x1, x2, x3, x4)                    ((HASH3(x1, x2, x3    ) &lt;&lt; 7) ^ HASH1(x4))
 232 #define HASH5(x1, x2, x3, x4, x5)                ((HASH4(x1, x2, x3, x4) &lt;&lt; 7) ^ HASH1(x5))
 233 
 234 
 235 // The following macros are used to implement instruction-specific hashing.
 236 // By default, each instruction implements hash() and is_equal(Value), used
 237 // for value numbering/common subexpression elimination. The default imple-
 238 // mentation disables value numbering. Each instruction which can be value-
 239 // numbered, should define corresponding hash() and is_equal(Value) functions
 240 // via the macros below. The f arguments specify all the values/op codes, etc.
 241 // that need to be identical for two instructions to be identical.
 242 //
 243 // Note: The default implementation of hash() returns 0 in order to indicate
 244 //       that the instruction should not be considered for value numbering.
 245 //       The currently used hash functions do not guarantee that never a 0
 246 //       is produced. While this is still correct, it may be a performance
 247 //       bug (no value numbering for that node). However, this situation is
 248 //       so unlikely, that we are not going to handle it specially.
 249 
 250 #define HASHING1(class_name, enabled, f1)             \
 251   virtual intx hash() const {                         \
 252     return (enabled) ? HASH2(name(), f1) : 0;         \
 253   }                                                   \
 254   virtual bool is_equal(Value v) const {              \
 255     if (!(enabled)  ) return false;                   \
 256     class_name* _v = v-&gt;as_##class_name();            \
 257     if (_v == NULL  ) return false;                   \
 258     if (f1 != _v-&gt;f1) return false;                   \
 259     return true;                                      \
 260   }                                                   \
 261 
 262 
 263 #define HASHING2(class_name, enabled, f1, f2)         \
 264   virtual intx hash() const {                         \
 265     return (enabled) ? HASH3(name(), f1, f2) : 0;     \
 266   }                                                   \
 267   virtual bool is_equal(Value v) const {              \
 268     if (!(enabled)  ) return false;                   \
 269     class_name* _v = v-&gt;as_##class_name();            \
 270     if (_v == NULL  ) return false;                   \
 271     if (f1 != _v-&gt;f1) return false;                   \
 272     if (f2 != _v-&gt;f2) return false;                   \
 273     return true;                                      \
 274   }                                                   \
 275 
 276 
 277 #define HASHING3(class_name, enabled, f1, f2, f3)     \
 278   virtual intx hash() const {                         \
 279     return (enabled) ? HASH4(name(), f1, f2, f3) : 0; \
 280   }                                                   \
 281   virtual bool is_equal(Value v) const {              \
 282     if (!(enabled)  ) return false;                   \
 283     class_name* _v = v-&gt;as_##class_name();            \
 284     if (_v == NULL  ) return false;                   \
 285     if (f1 != _v-&gt;f1) return false;                   \
 286     if (f2 != _v-&gt;f2) return false;                   \
 287     if (f3 != _v-&gt;f3) return false;                   \
 288     return true;                                      \
 289   }                                                   \
 290 
 291 #define HASHING4(class_name, enabled, f1, f2, f3, f4) \
 292   virtual intx hash() const {                         \
 293     return (enabled) ? HASH5(name(), f1, f2, f3, f4) : 0; \
 294   }                                                   \
 295   virtual bool is_equal(Value v) const {              \
 296     if (!(enabled)  ) return false;                   \
 297     class_name* _v = v-&gt;as_##class_name();            \
 298     if (_v == NULL  ) return false;                   \
 299     if (f1 != _v-&gt;f1) return false;                   \
 300     if (f2 != _v-&gt;f2) return false;                   \
 301     if (f3 != _v-&gt;f3) return false;                   \
 302     if (f4 != _v-&gt;f4) return false;                   \
 303     return true;                                      \
 304   }                                                   \
 305 
 306 
 307 // The mother of all instructions...
 308 
 309 class Instruction: public CompilationResourceObj {
 310  private:
 311   int          _id;                              // the unique instruction id
 312 #ifndef PRODUCT
 313   int          _printable_bci;                   // the bci of the instruction for printing
 314 #endif
 315   int          _use_count;                       // the number of instructions refering to this value (w/o prev/next); only roots can have use count = 0 or &gt; 1
 316   int          _pin_state;                       // set of PinReason describing the reason for pinning
 317   ValueType*   _type;                            // the instruction value type
 318   Instruction* _next;                            // the next instruction if any (NULL for BlockEnd instructions)
 319   Instruction* _subst;                           // the substitution instruction if any
 320   LIR_Opr      _operand;                         // LIR specific information
 321   unsigned int _flags;                           // Flag bits
 322 
 323   ValueStack*  _state_before;                    // Copy of state with input operands still on stack (or NULL)
 324   ValueStack*  _exception_state;                 // Copy of state for exception handling
 325   XHandlers*   _exception_handlers;              // Flat list of exception handlers covering this instruction
 326 
 327   friend class UseCountComputer;
 328 
 329   void update_exception_state(ValueStack* state);
 330 
 331  protected:
 332   BlockBegin*  _block;                           // Block that contains this instruction
 333 
 334   void set_type(ValueType* type) {
 335     assert(type != NULL, &quot;type must exist&quot;);
 336     _type = type;
 337   }
 338 
 339   // Helper class to keep track of which arguments need a null check
 340   class ArgsNonNullState {
 341   private:
 342     int _nonnull_state; // mask identifying which args are nonnull
 343   public:
 344     ArgsNonNullState()
 345       : _nonnull_state(AllBits) {}
 346 
 347     // Does argument number i needs a null check?
 348     bool arg_needs_null_check(int i) const {
 349       // No data is kept for arguments starting at position 33 so
 350       // conservatively assume that they need a null check.
 351       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 352         return is_set_nth_bit(_nonnull_state, i);
 353       }
 354       return true;
 355     }
 356 
 357     // Set whether argument number i needs a null check or not
 358     void set_arg_needs_null_check(int i, bool check) {
 359       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 360         if (check) {
 361           _nonnull_state |= nth_bit(i);
 362         } else {
 363           _nonnull_state &amp;= ~(nth_bit(i));
 364         }
 365       }
 366     }
 367   };
 368 
 369  public:
 370   void* operator new(size_t size) throw() {
 371     Compilation* c = Compilation::current();
 372     void* res = c-&gt;arena()-&gt;Amalloc(size);
 373     return res;
 374   }
 375 
 376   static const int no_bci = -99;
 377 
 378   enum InstructionFlag {
 379     NeedsNullCheckFlag = 0,
 380     NeverNullFlag,          // For &quot;Q&quot; signatures
 381     CanTrapFlag,
 382     DirectCompareFlag,
 383     IsEliminatedFlag,
 384     IsSafepointFlag,
 385     IsStaticFlag,
 386     IsStrictfpFlag,
 387     NeedsStoreCheckFlag,
 388     NeedsWriteBarrierFlag,
 389     PreservesStateFlag,
 390     TargetIsFinalFlag,
 391     TargetIsLoadedFlag,
 392     TargetIsStrictfpFlag,
 393     UnorderedIsTrueFlag,
 394     NeedsPatchingFlag,
 395     ThrowIncompatibleClassChangeErrorFlag,
 396     InvokeSpecialReceiverCheckFlag,
 397     ProfileMDOFlag,
 398     IsLinkedInBlockFlag,
 399     NeedsRangeCheckFlag,
 400     InWorkListFlag,
 401     DeoptimizeOnException,
 402     InstructionLastFlag
 403   };
 404 
 405  public:
 406   bool check_flag(InstructionFlag id) const      { return (_flags &amp; (1 &lt;&lt; id)) != 0;    }
 407   void set_flag(InstructionFlag id, bool f)      { _flags = f ? (_flags | (1 &lt;&lt; id)) : (_flags &amp; ~(1 &lt;&lt; id)); };
 408 
 409   // &#39;globally&#39; used condition values
 410   enum Condition {
 411     eql, neq, lss, leq, gtr, geq, aeq, beq
 412   };
 413 
 414   // Instructions may be pinned for many reasons and under certain conditions
 415   // with enough knowledge it&#39;s possible to safely unpin them.
 416   enum PinReason {
 417       PinUnknown           = 1 &lt;&lt; 0
 418     , PinExplicitNullCheck = 1 &lt;&lt; 3
 419     , PinStackForStateSplit= 1 &lt;&lt; 12
 420     , PinStateSplitConstructor= 1 &lt;&lt; 13
 421     , PinGlobalValueNumbering= 1 &lt;&lt; 14
 422   };
 423 
 424   static Condition mirror(Condition cond);
 425   static Condition negate(Condition cond);
 426 
 427   // initialization
 428   static int number_of_instructions() {
 429     return Compilation::current()-&gt;number_of_instructions();
 430   }
 431 
 432   // creation
 433   Instruction(ValueType* type, ValueStack* state_before = NULL, bool type_is_constant = false)
 434   : _id(Compilation::current()-&gt;get_next_id()),
 435 #ifndef PRODUCT
 436   _printable_bci(-99),
 437 #endif
 438     _use_count(0)
 439   , _pin_state(0)
 440   , _type(type)
 441   , _next(NULL)
 442   , _subst(NULL)
 443   , _operand(LIR_OprFact::illegalOpr)
 444   , _flags(0)
 445   , _state_before(state_before)
 446   , _exception_handlers(NULL)
 447   , _block(NULL)
 448   {
 449     check_state(state_before);
 450     assert(type != NULL &amp;&amp; (!type-&gt;is_constant() || type_is_constant), &quot;type must exist&quot;);
 451     update_exception_state(_state_before);
 452   }
 453 
 454   // accessors
 455   int id() const                                 { return _id; }
 456 #ifndef PRODUCT
 457   bool has_printable_bci() const                 { return _printable_bci != -99; }
 458   int printable_bci() const                      { assert(has_printable_bci(), &quot;_printable_bci should have been set&quot;); return _printable_bci; }
 459   void set_printable_bci(int bci)                { _printable_bci = bci; }
 460 #endif
 461   int dominator_depth();
 462   int use_count() const                          { return _use_count; }
 463   int pin_state() const                          { return _pin_state; }
 464   bool is_pinned() const                         { return _pin_state != 0 || PinAllInstructions; }
 465   ValueType* type() const                        { return _type; }
 466   BlockBegin *block() const                      { return _block; }
 467   Instruction* prev();                           // use carefully, expensive operation
 468   Instruction* next() const                      { return _next; }
 469   bool has_subst() const                         { return _subst != NULL; }
 470   Instruction* subst()                           { return _subst == NULL ? this : _subst-&gt;subst(); }
 471   LIR_Opr operand() const                        { return _operand; }
 472 
 473   void set_needs_null_check(bool f)              { set_flag(NeedsNullCheckFlag, f); }
 474   bool needs_null_check() const                  { return check_flag(NeedsNullCheckFlag); }
 475   void set_never_null(bool f)                    { set_flag(NeverNullFlag, f); }
 476   bool is_never_null() const                     { return check_flag(NeverNullFlag); }
 477   bool is_linked() const                         { return check_flag(IsLinkedInBlockFlag); }
 478   bool can_be_linked()                           { return as_Local() == NULL &amp;&amp; as_Phi() == NULL; }
 479 
 480   bool is_null_obj()                             { return as_Constant() != NULL &amp;&amp; type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object(); }
 481 
 482   bool has_uses() const                          { return use_count() &gt; 0; }
 483   ValueStack* state_before() const               { return _state_before; }
 484   ValueStack* exception_state() const            { return _exception_state; }
 485   virtual bool needs_exception_state() const     { return true; }
 486   XHandlers* exception_handlers() const          { return _exception_handlers; }
 487   ciKlass* as_loaded_klass_or_null() const;
 488 
 489   // withfield optimization
 490   virtual void set_escaped()                     { }
 491   virtual void set_local_index(int index)        { }
 492   virtual bool is_optimizable_for_withfield() const { return false; }
 493 
 494 
 495   // manipulation
 496   void pin(PinReason reason)                     { _pin_state |= reason; }
 497   void pin()                                     { _pin_state |= PinUnknown; }
 498   // DANGEROUS: only used by EliminateStores
 499   void unpin(PinReason reason)                   { assert((reason &amp; PinUnknown) == 0, &quot;can&#39;t unpin unknown state&quot;); _pin_state &amp;= ~reason; }
 500 
 501   Instruction* set_next(Instruction* next) {
 502     assert(next-&gt;has_printable_bci(), &quot;_printable_bci should have been set&quot;);
 503     assert(next != NULL, &quot;must not be NULL&quot;);
 504     assert(as_BlockEnd() == NULL, &quot;BlockEnd instructions must have no next&quot;);
 505     assert(next-&gt;can_be_linked(), &quot;shouldn&#39;t link these instructions into list&quot;);
 506 
 507     BlockBegin *block = this-&gt;block();
 508     next-&gt;_block = block;
 509 
 510     next-&gt;set_flag(Instruction::IsLinkedInBlockFlag, true);
 511     _next = next;
 512     return next;
 513   }
 514 
 515   Instruction* set_next(Instruction* next, int bci) {
 516 #ifndef PRODUCT
 517     next-&gt;set_printable_bci(bci);
 518 #endif
 519     return set_next(next);
 520   }
 521 
 522   // when blocks are merged
 523   void fixup_block_pointers() {
 524     Instruction *cur = next()-&gt;next(); // next()&#39;s block is set in set_next
 525     while (cur &amp;&amp; cur-&gt;_block != block()) {
 526       cur-&gt;_block = block();
 527       cur = cur-&gt;next();
 528     }
 529   }
 530 
 531   Instruction *insert_after(Instruction *i) {
 532     Instruction* n = _next;
 533     set_next(i);
 534     i-&gt;set_next(n);
 535     return _next;
 536   }
 537 
 538   bool is_loaded_flattened_array() const;
 539   bool maybe_flattened_array();
 540   bool maybe_null_free_array();
 541 
 542   Instruction *insert_after_same_bci(Instruction *i) {
 543 #ifndef PRODUCT
 544     i-&gt;set_printable_bci(printable_bci());
 545 #endif
 546     return insert_after(i);
 547   }
 548 
 549   void set_subst(Instruction* subst)             {
 550     assert(subst == NULL ||
 551            type()-&gt;base() == subst-&gt;type()-&gt;base() ||
 552            subst-&gt;type()-&gt;base() == illegalType, &quot;type can&#39;t change&quot;);
 553     _subst = subst;
 554   }
 555   void set_exception_handlers(XHandlers *xhandlers) { _exception_handlers = xhandlers; }
 556   void set_exception_state(ValueStack* s)        { check_state(s); _exception_state = s; }
 557   void set_state_before(ValueStack* s)           { check_state(s); _state_before = s; }
 558 
 559   // machine-specifics
 560   void set_operand(LIR_Opr operand)              { assert(operand != LIR_OprFact::illegalOpr, &quot;operand must exist&quot;); _operand = operand; }
 561   void clear_operand()                           { _operand = LIR_OprFact::illegalOpr; }
 562 
 563   // generic
 564   virtual Instruction*      as_Instruction()     { return this; } // to satisfy HASHING1 macro
 565   virtual Phi*              as_Phi()             { return NULL; }
 566   virtual Local*            as_Local()           { return NULL; }
 567   virtual Constant*         as_Constant()        { return NULL; }
 568   virtual AccessField*      as_AccessField()     { return NULL; }
 569   virtual LoadField*        as_LoadField()       { return NULL; }
 570   virtual StoreField*       as_StoreField()      { return NULL; }
 571   virtual AccessArray*      as_AccessArray()     { return NULL; }
 572   virtual ArrayLength*      as_ArrayLength()     { return NULL; }
 573   virtual AccessIndexed*    as_AccessIndexed()   { return NULL; }
 574   virtual LoadIndexed*      as_LoadIndexed()     { return NULL; }
 575   virtual StoreIndexed*     as_StoreIndexed()    { return NULL; }
 576   virtual NegateOp*         as_NegateOp()        { return NULL; }
 577   virtual Op2*              as_Op2()             { return NULL; }
 578   virtual ArithmeticOp*     as_ArithmeticOp()    { return NULL; }
 579   virtual ShiftOp*          as_ShiftOp()         { return NULL; }
 580   virtual LogicOp*          as_LogicOp()         { return NULL; }
 581   virtual CompareOp*        as_CompareOp()       { return NULL; }
 582   virtual IfOp*             as_IfOp()            { return NULL; }
 583   virtual Convert*          as_Convert()         { return NULL; }
 584   virtual NullCheck*        as_NullCheck()       { return NULL; }
 585   virtual OsrEntry*         as_OsrEntry()        { return NULL; }
 586   virtual StateSplit*       as_StateSplit()      { return NULL; }
 587   virtual Invoke*           as_Invoke()          { return NULL; }
 588   virtual NewInstance*      as_NewInstance()     { return NULL; }
 589   virtual NewValueTypeInstance* as_NewValueTypeInstance() { return NULL; }
 590   virtual NewArray*         as_NewArray()        { return NULL; }
 591   virtual NewTypeArray*     as_NewTypeArray()    { return NULL; }
 592   virtual NewObjectArray*   as_NewObjectArray()  { return NULL; }
 593   virtual NewMultiArray*    as_NewMultiArray()   { return NULL; }
 594   virtual WithField*        as_WithField()       { return NULL; }
 595   virtual DefaultValue*     as_DefaultValue()    { return NULL; }
 596   virtual TypeCheck*        as_TypeCheck()       { return NULL; }
 597   virtual CheckCast*        as_CheckCast()       { return NULL; }
 598   virtual InstanceOf*       as_InstanceOf()      { return NULL; }
 599   virtual TypeCast*         as_TypeCast()        { return NULL; }
 600   virtual AccessMonitor*    as_AccessMonitor()   { return NULL; }
 601   virtual MonitorEnter*     as_MonitorEnter()    { return NULL; }
 602   virtual MonitorExit*      as_MonitorExit()     { return NULL; }
 603   virtual Intrinsic*        as_Intrinsic()       { return NULL; }
 604   virtual BlockBegin*       as_BlockBegin()      { return NULL; }
 605   virtual BlockEnd*         as_BlockEnd()        { return NULL; }
 606   virtual Goto*             as_Goto()            { return NULL; }
 607   virtual If*               as_If()              { return NULL; }
 608   virtual IfInstanceOf*     as_IfInstanceOf()    { return NULL; }
 609   virtual TableSwitch*      as_TableSwitch()     { return NULL; }
 610   virtual LookupSwitch*     as_LookupSwitch()    { return NULL; }
 611   virtual Return*           as_Return()          { return NULL; }
 612   virtual Throw*            as_Throw()           { return NULL; }
 613   virtual Base*             as_Base()            { return NULL; }
 614   virtual RoundFP*          as_RoundFP()         { return NULL; }
 615   virtual ExceptionObject*  as_ExceptionObject() { return NULL; }
 616   virtual UnsafeOp*         as_UnsafeOp()        { return NULL; }
 617   virtual ProfileInvoke*    as_ProfileInvoke()   { return NULL; }
 618   virtual RangeCheckPredicate* as_RangeCheckPredicate() { return NULL; }
 619 
 620 #ifdef ASSERT
 621   virtual Assert*           as_Assert()          { return NULL; }
 622 #endif
 623 
 624   virtual void visit(InstructionVisitor* v)      = 0;
 625 
 626   virtual bool can_trap() const                  { return false; }
 627 
 628   virtual void input_values_do(ValueVisitor* f)   = 0;
 629   virtual void state_values_do(ValueVisitor* f);
 630   virtual void other_values_do(ValueVisitor* f)   { /* usually no other - override on demand */ }
 631           void       values_do(ValueVisitor* f)   { input_values_do(f); state_values_do(f); other_values_do(f); }
 632 
 633   virtual ciType* exact_type() const;
 634   virtual ciType* declared_type() const          { return NULL; }
 635 
 636   // hashing
 637   virtual const char* name() const               = 0;
 638   HASHING1(Instruction, false, id())             // hashing disabled by default
 639 
 640   // debugging
 641   static void check_state(ValueStack* state)     PRODUCT_RETURN;
 642   void print()                                   PRODUCT_RETURN;
 643   void print_line()                              PRODUCT_RETURN;
 644   void print(InstructionPrinter&amp; ip)             PRODUCT_RETURN;
 645 };
 646 
 647 
 648 // The following macros are used to define base (i.e., non-leaf)
 649 // and leaf instruction classes. They define class-name related
 650 // generic functionality in one place.
 651 
 652 #define BASE(class_name, super_class_name)       \
 653   class class_name: public super_class_name {    \
 654    public:                                       \
 655     virtual class_name* as_##class_name()        { return this; }              \
 656 
 657 
 658 #define LEAF(class_name, super_class_name)       \
 659   BASE(class_name, super_class_name)             \
 660    public:                                       \
 661     virtual const char* name() const             { return #class_name; }       \
 662     virtual void visit(InstructionVisitor* v)    { v-&gt;do_##class_name(this); } \
 663 
 664 
 665 // Debugging support
 666 
 667 
 668 #ifdef ASSERT
 669 class AssertValues: public ValueVisitor {
 670   void visit(Value* x)             { assert((*x) != NULL, &quot;value must exist&quot;); }
 671 };
 672   #define ASSERT_VALUES                          { AssertValues assert_value; values_do(&amp;assert_value); }
 673 #else
 674   #define ASSERT_VALUES
 675 #endif // ASSERT
 676 
 677 
 678 // A Phi is a phi function in the sense of SSA form. It stands for
 679 // the value of a local variable at the beginning of a join block.
 680 // A Phi consists of n operands, one for every incoming branch.
 681 
 682 LEAF(Phi, Instruction)
 683  private:
 684   int         _pf_flags; // the flags of the phi function
 685   int         _index;    // to value on operand stack (index &lt; 0) or to local
 686  public:
 687   // creation
 688   Phi(ValueType* type, BlockBegin* b, int index)
 689   : Instruction(type-&gt;base())
 690   , _pf_flags(0)
 691   , _index(index)
 692   {
 693     _block = b;
 694     NOT_PRODUCT(set_printable_bci(Value(b)-&gt;printable_bci()));
 695     if (type-&gt;is_illegal()) {
 696       make_illegal();
 697     }
 698   }
 699 
 700   // flags
 701   enum Flag {
 702     no_flag         = 0,
 703     visited         = 1 &lt;&lt; 0,
 704     cannot_simplify = 1 &lt;&lt; 1
 705   };
 706 
 707   // accessors
 708   bool  is_local() const          { return _index &gt;= 0; }
 709   bool  is_on_stack() const       { return !is_local(); }
 710   int   local_index() const       { assert(is_local(), &quot;&quot;); return _index; }
 711   int   stack_index() const       { assert(is_on_stack(), &quot;&quot;); return -(_index+1); }
 712 
 713   Value operand_at(int i) const;
 714   int   operand_count() const;
 715 
 716   void   set(Flag f)              { _pf_flags |=  f; }
 717   void   clear(Flag f)            { _pf_flags &amp;= ~f; }
 718   bool   is_set(Flag f) const     { return (_pf_flags &amp; f) != 0; }
 719 
 720   // Invalidates phis corresponding to merges of locals of two different types
 721   // (these should never be referenced, otherwise the bytecodes are illegal)
 722   void   make_illegal() {
 723     set(cannot_simplify);
 724     set_type(illegalType);
 725   }
 726 
 727   bool is_illegal() const {
 728     return type()-&gt;is_illegal();
 729   }
 730 
 731   // generic
 732   virtual void input_values_do(ValueVisitor* f) {
 733   }
 734 };
 735 
 736 
 737 // A local is a placeholder for an incoming argument to a function call.
 738 LEAF(Local, Instruction)
 739  private:
 740   int      _java_index;                          // the local index within the method to which the local belongs
 741   bool     _is_receiver;                         // if local variable holds the receiver: &quot;this&quot; for non-static methods
 742   ciType*  _declared_type;
 743  public:
 744   // creation
 745   Local(ciType* declared, ValueType* type, int index, bool receiver, bool never_null)
 746     : Instruction(type)
 747     , _java_index(index)
 748     , _is_receiver(receiver)
 749     , _declared_type(declared)
 750   {
 751     set_never_null(never_null);
 752     NOT_PRODUCT(set_printable_bci(-1));
 753   }
 754 
 755   // accessors
 756   int java_index() const                         { return _java_index; }
 757   bool is_receiver() const                       { return _is_receiver; }
 758 
 759   virtual ciType* declared_type() const          { return _declared_type; }
 760 
 761   // generic
 762   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 763 };
 764 
 765 
 766 LEAF(Constant, Instruction)
 767  public:
 768   // creation
 769   Constant(ValueType* type):
 770       Instruction(type, NULL, /*type_is_constant*/ true)
 771   {
 772     assert(type-&gt;is_constant(), &quot;must be a constant&quot;);
 773   }
 774 
 775   Constant(ValueType* type, ValueStack* state_before):
 776     Instruction(type, state_before, /*type_is_constant*/ true)
 777   {
 778     assert(state_before != NULL, &quot;only used for constants which need patching&quot;);
 779     assert(type-&gt;is_constant(), &quot;must be a constant&quot;);
 780     // since it&#39;s patching it needs to be pinned
 781     pin();
 782   }
 783 
 784   // generic
 785   virtual bool can_trap() const                  { return state_before() != NULL; }
 786   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 787 
 788   virtual intx hash() const;
 789   virtual bool is_equal(Value v) const;
 790 
 791   virtual ciType* exact_type() const;
 792 
 793   enum CompareResult { not_comparable = -1, cond_false, cond_true };
 794 
 795   virtual CompareResult compare(Instruction::Condition condition, Value right) const;
 796   BlockBegin* compare(Instruction::Condition cond, Value right,
 797                       BlockBegin* true_sux, BlockBegin* false_sux) const {
 798     switch (compare(cond, right)) {
 799     case not_comparable:
 800       return NULL;
 801     case cond_false:
 802       return false_sux;
 803     case cond_true:
 804       return true_sux;
 805     default:
 806       ShouldNotReachHere();
 807       return NULL;
 808     }
 809   }
 810 };
 811 
 812 
 813 BASE(AccessField, Instruction)
 814  private:
 815   Value       _obj;
 816   int         _offset;
 817   ciField*    _field;
 818   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 819 
 820  public:
 821   // creation
 822   AccessField(Value obj, int offset, ciField* field, bool is_static,
 823               ValueStack* state_before, bool needs_patching)
 824   : Instruction(as_ValueType(field-&gt;type()-&gt;basic_type()), state_before)
 825   , _obj(obj)
 826   , _offset(offset)
 827   , _field(field)
 828   , _explicit_null_check(NULL)
 829   {
 830     set_needs_null_check(!is_static);
 831     set_flag(IsStaticFlag, is_static);
 832     set_flag(NeedsPatchingFlag, needs_patching);
 833     ASSERT_VALUES
 834     // pin of all instructions with memory access
 835     pin();
 836   }
 837 
 838   // accessors
 839   Value obj() const                              { return _obj; }
 840   int offset() const                             { return _offset; }
 841   ciField* field() const                         { return _field; }
 842   BasicType field_type() const                   { return _field-&gt;type()-&gt;basic_type(); }
 843   bool is_static() const                         { return check_flag(IsStaticFlag); }
 844   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 845   bool needs_patching() const                    { return check_flag(NeedsPatchingFlag); }
 846 
 847   // Unresolved getstatic and putstatic can cause initialization.
 848   // Technically it occurs at the Constant that materializes the base
 849   // of the static fields but it&#39;s simpler to model it here.
 850   bool is_init_point() const                     { return is_static() &amp;&amp; (needs_patching() || !_field-&gt;holder()-&gt;is_initialized()); }
 851 
 852   // manipulation
 853 
 854   // Under certain circumstances, if a previous NullCheck instruction
 855   // proved the target object non-null, we can eliminate the explicit
 856   // null check and do an implicit one, simply specifying the debug
 857   // information from the NullCheck. This field should only be consulted
 858   // if needs_null_check() is true.
 859   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 860 
 861   // generic
 862   virtual bool can_trap() const                  { return needs_null_check() || needs_patching(); }
 863   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
 864 };
 865 
 866 
 867 LEAF(LoadField, AccessField)
 868  public:
 869   // creation
 870   LoadField(Value obj, int offset, ciField* field, bool is_static,
 871             ValueStack* state_before, bool needs_patching,
 872             ciValueKlass* value_klass = NULL, Value default_value = NULL )
 873   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
<a name="1" id="anc1"></a><span class="line-modified"> 874   {}</span>


 875 
 876   ciType* declared_type() const;
 877 
 878   // generic; cannot be eliminated if needs patching or if volatile.
 879   HASHING3(LoadField, !needs_patching() &amp;&amp; !field()-&gt;is_volatile(), obj()-&gt;subst(), offset(), declared_type())
 880 };
 881 
 882 
 883 LEAF(StoreField, AccessField)
 884  private:
 885   Value _value;
 886 
 887  public:
 888   // creation
 889   StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,
 890              ValueStack* state_before, bool needs_patching)
 891   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 892   , _value(value)
 893   {
 894     set_flag(NeedsWriteBarrierFlag, as_ValueType(field_type())-&gt;is_object());
 895     ASSERT_VALUES
 896     pin();
 897   }
 898 
 899   // accessors
 900   Value value() const                            { return _value; }
 901   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
 902 
 903   // generic
 904   virtual void input_values_do(ValueVisitor* f)   { AccessField::input_values_do(f); f-&gt;visit(&amp;_value); }
 905 };
 906 
 907 
 908 BASE(AccessArray, Instruction)
 909  private:
 910   Value       _array;
 911 
 912  public:
 913   // creation
 914   AccessArray(ValueType* type, Value array, ValueStack* state_before)
 915   : Instruction(type, state_before)
 916   , _array(array)
 917   {
 918     set_needs_null_check(true);
 919     ASSERT_VALUES
 920     pin(); // instruction with side effect (null exception or range check throwing)
 921   }
 922 
 923   Value array() const                            { return _array; }
 924 
 925   // generic
 926   virtual bool can_trap() const                  { return needs_null_check(); }
 927   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_array); }
 928 };
 929 
 930 
 931 LEAF(ArrayLength, AccessArray)
 932  private:
 933   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 934 
 935  public:
 936   // creation
 937   ArrayLength(Value array, ValueStack* state_before)
 938   : AccessArray(intType, array, state_before)
 939   , _explicit_null_check(NULL) {}
 940 
 941   // accessors
 942   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 943 
 944   // setters
 945   // See LoadField::set_explicit_null_check for documentation
 946   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 947 
 948   // generic
 949   HASHING1(ArrayLength, true, array()-&gt;subst())
 950 };
 951 
 952 
 953 BASE(AccessIndexed, AccessArray)
 954  private:
 955   Value     _index;
 956   Value     _length;
 957   BasicType _elt_type;
 958   bool      _mismatched;
 959   ciMethod* _profiled_method;
 960   int       _profiled_bci;
 961 
 962  public:
 963   // creation
 964   AccessIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched)
 965   : AccessArray(as_ValueType(elt_type), array, state_before)
 966   , _index(index)
 967   , _length(length)
 968   , _elt_type(elt_type)
 969   , _mismatched(mismatched)
 970   , _profiled_method(NULL), _profiled_bci(0)
 971   {
 972     set_flag(Instruction::NeedsRangeCheckFlag, true);
 973     ASSERT_VALUES
 974   }
 975 
 976   // accessors
 977   Value index() const                            { return _index; }
 978   Value length() const                           { return _length; }
 979   BasicType elt_type() const                     { return _elt_type; }
 980   bool mismatched() const                        { return _mismatched; }
 981 
 982   void clear_length()                            { _length = NULL; }
 983   // perform elimination of range checks involving constants
 984   bool compute_needs_range_check();
 985 
 986   // Helpers for MethodData* profiling
 987   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
 988   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
 989   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
 990   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
 991   ciMethod* profiled_method() const                  { return _profiled_method;     }
 992   int       profiled_bci() const                     { return _profiled_bci;        }
 993 
 994 
 995 // generic
 996   virtual void input_values_do(ValueVisitor* f)   { AccessArray::input_values_do(f); f-&gt;visit(&amp;_index); if (_length != NULL) f-&gt;visit(&amp;_length); }
 997 };
 998 
 999 
1000 LEAF(LoadIndexed, AccessIndexed)
1001  private:
1002   NullCheck*  _explicit_null_check;              // For explicit null check elimination
1003   NewValueTypeInstance* _vt;
1004 
1005  public:
1006   // creation
1007   LoadIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched = false)
1008   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
1009   , _explicit_null_check(NULL), _vt(NULL) {}
1010 
1011   // accessors
1012   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
1013 
1014   // setters
1015   // See LoadField::set_explicit_null_check for documentation
1016   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
1017 
1018   ciType* exact_type() const;
1019   ciType* declared_type() const;
1020 
1021   NewValueTypeInstance* vt() const { return _vt; }
1022   void set_vt(NewValueTypeInstance* vt) { _vt = vt; }
1023 
1024   // generic
1025   HASHING4(LoadIndexed, !should_profile(), type()-&gt;tag(), array()-&gt;subst(), index()-&gt;subst(), vt())
1026 };
1027 
1028 
1029 LEAF(StoreIndexed, AccessIndexed)
1030  private:
1031   Value       _value;
1032 
1033   bool      _check_boolean;
1034 
1035  public:
1036   // creation
1037   StoreIndexed(Value array, Value index, Value length, BasicType elt_type, Value value, ValueStack* state_before,
1038                bool check_boolean, bool mismatched = false)
1039   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
1040   , _value(value), _check_boolean(check_boolean)
1041   {
1042     set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)-&gt;is_object()));
1043     set_flag(NeedsStoreCheckFlag, (as_ValueType(elt_type)-&gt;is_object()));
1044     ASSERT_VALUES
1045     pin();
1046   }
1047 
1048   // accessors
1049   Value value() const                            { return _value; }
1050   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
1051   bool needs_store_check() const                 { return check_flag(NeedsStoreCheckFlag); }
1052   bool check_boolean() const                     { return _check_boolean; }
1053 
1054   // Flattened array support
1055   bool is_exact_flattened_array_store() const;
1056   // generic
1057   virtual void input_values_do(ValueVisitor* f)   { AccessIndexed::input_values_do(f); f-&gt;visit(&amp;_value); }
1058 };
1059 
1060 
1061 LEAF(NegateOp, Instruction)
1062  private:
1063   Value _x;
1064 
1065  public:
1066   // creation
1067   NegateOp(Value x) : Instruction(x-&gt;type()-&gt;base()), _x(x) {
1068     ASSERT_VALUES
1069   }
1070 
1071   // accessors
1072   Value x() const                                { return _x; }
1073 
1074   // generic
1075   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); }
1076 };
1077 
1078 
1079 BASE(Op2, Instruction)
1080  private:
1081   Bytecodes::Code _op;
1082   Value           _x;
1083   Value           _y;
1084 
1085  public:
1086   // creation
1087   Op2(ValueType* type, Bytecodes::Code op, Value x, Value y, ValueStack* state_before = NULL)
1088   : Instruction(type, state_before)
1089   , _op(op)
1090   , _x(x)
1091   , _y(y)
1092   {
1093     ASSERT_VALUES
1094   }
1095 
1096   // accessors
1097   Bytecodes::Code op() const                     { return _op; }
1098   Value x() const                                { return _x; }
1099   Value y() const                                { return _y; }
1100 
1101   // manipulators
1102   void swap_operands() {
1103     assert(is_commutative(), &quot;operation must be commutative&quot;);
1104     Value t = _x; _x = _y; _y = t;
1105   }
1106 
1107   // generic
1108   virtual bool is_commutative() const            { return false; }
1109   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
1110 };
1111 
1112 
1113 LEAF(ArithmeticOp, Op2)
1114  public:
1115   // creation
1116   ArithmeticOp(Bytecodes::Code op, Value x, Value y, bool is_strictfp, ValueStack* state_before)
1117   : Op2(x-&gt;type()-&gt;meet(y-&gt;type()), op, x, y, state_before)
1118   {
1119     set_flag(IsStrictfpFlag, is_strictfp);
1120     if (can_trap()) pin();
1121   }
1122 
1123   // accessors
1124   bool        is_strictfp() const                { return check_flag(IsStrictfpFlag); }
1125 
1126   // generic
1127   virtual bool is_commutative() const;
1128   virtual bool can_trap() const;
1129   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1130 };
1131 
1132 
1133 LEAF(ShiftOp, Op2)
1134  public:
1135   // creation
1136   ShiftOp(Bytecodes::Code op, Value x, Value s) : Op2(x-&gt;type()-&gt;base(), op, x, s) {}
1137 
1138   // generic
1139   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1140 };
1141 
1142 
1143 LEAF(LogicOp, Op2)
1144  public:
1145   // creation
1146   LogicOp(Bytecodes::Code op, Value x, Value y) : Op2(x-&gt;type()-&gt;meet(y-&gt;type()), op, x, y) {}
1147 
1148   // generic
1149   virtual bool is_commutative() const;
1150   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1151 };
1152 
1153 
1154 LEAF(CompareOp, Op2)
1155  public:
1156   // creation
1157   CompareOp(Bytecodes::Code op, Value x, Value y, ValueStack* state_before)
1158   : Op2(intType, op, x, y, state_before)
1159   {}
1160 
1161   // generic
1162   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1163 };
1164 
1165 
1166 LEAF(IfOp, Op2)
1167  private:
1168   Value _tval;
1169   Value _fval;
1170   bool _substitutability_check;
1171 
1172  public:
1173   // creation
1174   IfOp(Value x, Condition cond, Value y, Value tval, Value fval, ValueStack* state_before, bool substitutability_check)
1175   : Op2(tval-&gt;type()-&gt;meet(fval-&gt;type()), (Bytecodes::Code)cond, x, y)
1176   , _tval(tval)
1177   , _fval(fval)
1178   , _substitutability_check(substitutability_check)
1179   {
1180     ASSERT_VALUES
1181     assert(tval-&gt;type()-&gt;tag() == fval-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1182     set_state_before(state_before);
1183   }
1184 
1185   // accessors
1186   virtual bool is_commutative() const;
1187   Bytecodes::Code op() const                     { ShouldNotCallThis(); return Bytecodes::_illegal; }
1188   Condition cond() const                         { return (Condition)Op2::op(); }
1189   Value tval() const                             { return _tval; }
1190   Value fval() const                             { return _fval; }
1191   bool substitutability_check() const             { return _substitutability_check; }
1192   // generic
1193   virtual void input_values_do(ValueVisitor* f)   { Op2::input_values_do(f); f-&gt;visit(&amp;_tval); f-&gt;visit(&amp;_fval); }
1194 };
1195 
1196 
1197 LEAF(Convert, Instruction)
1198  private:
1199   Bytecodes::Code _op;
1200   Value           _value;
1201 
1202  public:
1203   // creation
1204   Convert(Bytecodes::Code op, Value value, ValueType* to_type) : Instruction(to_type), _op(op), _value(value) {
1205     ASSERT_VALUES
1206   }
1207 
1208   // accessors
1209   Bytecodes::Code op() const                     { return _op; }
1210   Value value() const                            { return _value; }
1211 
1212   // generic
1213   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_value); }
1214   HASHING2(Convert, true, op(), value()-&gt;subst())
1215 };
1216 
1217 
1218 LEAF(NullCheck, Instruction)
1219  private:
1220   Value       _obj;
1221 
1222  public:
1223   // creation
1224   NullCheck(Value obj, ValueStack* state_before)
1225   : Instruction(obj-&gt;type()-&gt;base(), state_before)
1226   , _obj(obj)
1227   {
1228     ASSERT_VALUES
1229     set_can_trap(true);
1230     assert(_obj-&gt;type()-&gt;is_object(), &quot;null check must be applied to objects only&quot;);
1231     pin(Instruction::PinExplicitNullCheck);
1232   }
1233 
1234   // accessors
1235   Value obj() const                              { return _obj; }
1236 
1237   // setters
1238   void set_can_trap(bool can_trap)               { set_flag(CanTrapFlag, can_trap); }
1239 
1240   // generic
1241   virtual bool can_trap() const                  { return check_flag(CanTrapFlag); /* null-check elimination sets to false */ }
1242   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
1243   HASHING1(NullCheck, true, obj()-&gt;subst())
1244 };
1245 
1246 
1247 // This node is supposed to cast the type of another node to a more precise
1248 // declared type.
1249 LEAF(TypeCast, Instruction)
1250  private:
1251   ciType* _declared_type;
1252   Value   _obj;
1253 
1254  public:
1255   // The type of this node is the same type as the object type (and it might be constant).
1256   TypeCast(ciType* type, Value obj, ValueStack* state_before)
1257   : Instruction(obj-&gt;type(), state_before, obj-&gt;type()-&gt;is_constant()),
1258     _declared_type(type),
1259     _obj(obj) {}
1260 
1261   // accessors
1262   ciType* declared_type() const                  { return _declared_type; }
1263   Value   obj() const                            { return _obj; }
1264 
1265   // generic
1266   virtual void input_values_do(ValueVisitor* f)  { f-&gt;visit(&amp;_obj); }
1267 };
1268 
1269 
1270 BASE(StateSplit, Instruction)
1271  private:
1272   ValueStack* _state;
1273 
1274  protected:
1275   static void substitute(BlockList&amp; list, BlockBegin* old_block, BlockBegin* new_block);
1276 
1277  public:
1278   // creation
1279   StateSplit(ValueType* type, ValueStack* state_before = NULL)
1280   : Instruction(type, state_before)
1281   , _state(NULL)
1282   {
1283     pin(PinStateSplitConstructor);
1284   }
1285 
1286   // accessors
1287   ValueStack* state() const                      { return _state; }
1288   IRScope* scope() const;                        // the state&#39;s scope
1289 
1290   // manipulation
1291   void set_state(ValueStack* state)              { assert(_state == NULL, &quot;overwriting existing state&quot;); check_state(state); _state = state; }
1292 
1293   // generic
1294   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
1295   virtual void state_values_do(ValueVisitor* f);
1296 };
1297 
1298 
1299 LEAF(Invoke, StateSplit)
1300  private:
1301   Bytecodes::Code _code;
1302   Value           _recv;
1303   Values*         _args;
1304   BasicTypeList*  _signature;
1305   int             _vtable_index;
1306   ciMethod*       _target;
1307 
1308  public:
1309   // creation
1310   Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
1311          int vtable_index, ciMethod* target, ValueStack* state_before, bool never_null);
1312 
1313   // accessors
1314   Bytecodes::Code code() const                   { return _code; }
1315   Value receiver() const                         { return _recv; }
1316   bool has_receiver() const                      { return receiver() != NULL; }
1317   int number_of_arguments() const                { return _args-&gt;length(); }
1318   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1319   int vtable_index() const                       { return _vtable_index; }
1320   BasicTypeList* signature() const               { return _signature; }
1321   ciMethod* target() const                       { return _target; }
1322 
1323   ciType* declared_type() const;
1324 
1325   // Returns false if target is not loaded
1326   bool target_is_final() const                   { return check_flag(TargetIsFinalFlag); }
1327   bool target_is_loaded() const                  { return check_flag(TargetIsLoadedFlag); }
1328   // Returns false if target is not loaded
1329   bool target_is_strictfp() const                { return check_flag(TargetIsStrictfpFlag); }
1330 
1331   // JSR 292 support
1332   bool is_invokedynamic() const                  { return code() == Bytecodes::_invokedynamic; }
1333   bool is_method_handle_intrinsic() const        { return target()-&gt;is_method_handle_intrinsic(); }
1334 
1335   virtual bool needs_exception_state() const     { return false; }
1336 
1337   // generic
1338   virtual bool can_trap() const                  { return true; }
1339   virtual void input_values_do(ValueVisitor* f) {
1340     StateSplit::input_values_do(f);
1341     if (has_receiver()) f-&gt;visit(&amp;_recv);
1342     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
1343   }
1344   virtual void state_values_do(ValueVisitor *f);
1345 };
1346 
1347 
1348 LEAF(NewInstance, StateSplit)
1349  private:
1350   ciInstanceKlass* _klass;
1351   bool _is_unresolved;
1352 
1353  public:
1354   // creation
1355   NewInstance(ciInstanceKlass* klass, ValueStack* state_before, bool is_unresolved)
1356   : StateSplit(instanceType, state_before)
1357   , _klass(klass), _is_unresolved(is_unresolved)
1358   {}
1359 
1360   // accessors
1361   ciInstanceKlass* klass() const                 { return _klass; }
1362   bool is_unresolved() const                     { return _is_unresolved; }
1363 
1364   virtual bool needs_exception_state() const     { return false; }
1365 
1366   // generic
1367   virtual bool can_trap() const                  { return true; }
1368   ciType* exact_type() const;
1369   ciType* declared_type() const;
1370 };
1371 
1372 LEAF(NewValueTypeInstance, StateSplit)
1373   bool _is_unresolved;
1374   ciValueKlass* _klass;
1375   Value _depends_on;      // Link to instance on with withfield was called on
1376   bool _is_optimizable_for_withfield;
1377   int _first_local_index;
1378 public:
1379 
1380   // Default creation, always allocated for now
1381   NewValueTypeInstance(ciValueKlass* klass, ValueStack* state_before, bool is_unresolved, Value depends_on = NULL, bool from_default_value = false)
1382   : StateSplit(instanceType, state_before)
1383    , _is_unresolved(is_unresolved)
1384    , _klass(klass)
1385    , _is_optimizable_for_withfield(from_default_value)
1386    , _first_local_index(-1)
1387   {
1388     if (depends_on == NULL) {
1389       _depends_on = this;
1390     } else {
1391       _depends_on = depends_on;
1392     }
1393     set_never_null(true);
1394   }
1395 
1396   // accessors
1397   bool is_unresolved() const                     { return _is_unresolved; }
1398   Value depends_on();
1399 
1400   ciValueKlass* klass() const { return _klass; }
1401 
1402   virtual bool needs_exception_state() const     { return false; }
1403 
1404   // generic
1405   virtual bool can_trap() const                  { return true; }
1406   ciType* exact_type() const;
1407   ciType* declared_type() const;
1408 
1409   // Only done in LIR Generator -&gt; map everything to object
1410   void set_to_object_type() { set_type(instanceType); }
1411 
1412   // withfield optimization
1413   virtual void set_escaped() {
1414     _is_optimizable_for_withfield = false;
1415   }
1416   virtual void set_local_index(int index) {
1417     if (_first_local_index != index) {
1418       if (_first_local_index == -1) {
1419         _first_local_index = index;
1420       } else {
1421         _is_optimizable_for_withfield = false;
1422       }
1423     }
1424   }
1425   virtual bool is_optimizable_for_withfield() const {  return _is_optimizable_for_withfield; }
1426 };
1427 
1428 BASE(NewArray, StateSplit)
1429  private:
1430   Value       _length;
1431 
1432  public:
1433   // creation
1434   NewArray(Value length, ValueStack* state_before)
1435   : StateSplit(objectType, state_before)
1436   , _length(length)
1437   {
1438     // Do not ASSERT_VALUES since length is NULL for NewMultiArray
1439   }
1440 
1441   // accessors
1442   Value length() const                           { return _length; }
1443 
1444   virtual bool needs_exception_state() const     { return false; }
1445 
1446   ciType* exact_type() const                     { return NULL; }
1447   ciType* declared_type() const;
1448 
1449   // generic
1450   virtual bool can_trap() const                  { return true; }
1451   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_length); }
1452 };
1453 
1454 
1455 LEAF(NewTypeArray, NewArray)
1456  private:
1457   BasicType _elt_type;
1458 
1459  public:
1460   // creation
1461   NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before)
1462   : NewArray(length, state_before)
1463   , _elt_type(elt_type)
1464   {}
1465 
1466   // accessors
1467   BasicType elt_type() const                     { return _elt_type; }
1468   ciType* exact_type() const;
1469 };
1470 
1471 
1472 LEAF(NewObjectArray, NewArray)
1473  private:
1474   ciKlass* _klass;
1475 
1476  public:
1477   // creation
1478   NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before, bool never_null)
1479   : NewArray(length, state_before), _klass(klass) {
1480     set_never_null(never_null);
1481   }
1482 
1483   // accessors
1484   ciKlass* klass() const                         { return _klass; }
1485   ciType* exact_type() const;
1486 };
1487 
1488 
1489 LEAF(NewMultiArray, NewArray)
1490  private:
1491   ciKlass* _klass;
1492   Values*  _dims;
1493 
1494  public:
1495   // creation
1496   NewMultiArray(ciKlass* klass, Values* dims, ValueStack* state_before) : NewArray(NULL, state_before), _klass(klass), _dims(dims) {
1497     ASSERT_VALUES
1498   }
1499 
1500   // accessors
1501   ciKlass* klass() const                         { return _klass; }
1502   Values* dims() const                           { return _dims; }
1503   int rank() const                               { return dims()-&gt;length(); }
1504 
1505   // generic
1506   virtual void input_values_do(ValueVisitor* f) {
1507     // NOTE: we do not call NewArray::input_values_do since &quot;length&quot;
1508     // is meaningless for a multi-dimensional array; passing the
1509     // zeroth element down to NewArray as its length is a bad idea
1510     // since there will be a copy in the &quot;dims&quot; array which doesn&#39;t
1511     // get updated, and the value must not be traversed twice. Was bug
1512     // - kbr 4/10/2001
1513     StateSplit::input_values_do(f);
1514     for (int i = 0; i &lt; _dims-&gt;length(); i++) f-&gt;visit(_dims-&gt;adr_at(i));
1515   }
1516 
1517   ciType* exact_type() const;
1518 };
1519 
1520 LEAF(WithField, StateSplit)
1521  public:
1522   // creation
1523   WithField(ValueStack* state_before)
1524   : StateSplit(objectType, state_before) {}
1525 };
1526 
1527 LEAF(DefaultValue, StateSplit)
1528  public:
1529   // creation
1530   DefaultValue(ValueStack* state_before)
1531   : StateSplit(objectType, state_before) {}
1532 };
1533 
1534 BASE(TypeCheck, StateSplit)
1535  private:
1536   ciKlass*    _klass;
1537   Value       _obj;
1538 
1539   ciMethod* _profiled_method;
1540   int       _profiled_bci;
1541 
1542  public:
1543   // creation
1544   TypeCheck(ciKlass* klass, Value obj, ValueType* type, ValueStack* state_before)
1545   : StateSplit(type, state_before), _klass(klass), _obj(obj),
1546     _profiled_method(NULL), _profiled_bci(0) {
1547     ASSERT_VALUES
1548     set_direct_compare(false);
1549   }
1550 
1551   // accessors
1552   ciKlass* klass() const                         { return _klass; }
1553   Value obj() const                              { return _obj; }
1554   bool is_loaded() const                         { return klass() != NULL; }
1555   bool direct_compare() const                    { return check_flag(DirectCompareFlag); }
1556 
1557   // manipulation
1558   void set_direct_compare(bool flag)             { set_flag(DirectCompareFlag, flag); }
1559 
1560   // generic
1561   virtual bool can_trap() const                  { return true; }
1562   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1563 
1564   // Helpers for MethodData* profiling
1565   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
1566   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
1567   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
1568   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
1569   ciMethod* profiled_method() const                  { return _profiled_method;     }
1570   int       profiled_bci() const                     { return _profiled_bci;        }
1571 };
1572 
1573 
1574 LEAF(CheckCast, TypeCheck)
1575  public:
1576   // creation
1577   CheckCast(ciKlass* klass, Value obj, ValueStack* state_before, bool never_null = false)
1578   : TypeCheck(klass, obj, objectType, state_before) {
1579     set_never_null(never_null);
1580   }
1581 
1582   void set_incompatible_class_change_check() {
1583     set_flag(ThrowIncompatibleClassChangeErrorFlag, true);
1584   }
1585   bool is_incompatible_class_change_check() const {
1586     return check_flag(ThrowIncompatibleClassChangeErrorFlag);
1587   }
1588   void set_invokespecial_receiver_check() {
1589     set_flag(InvokeSpecialReceiverCheckFlag, true);
1590   }
1591   bool is_invokespecial_receiver_check() const {
1592     return check_flag(InvokeSpecialReceiverCheckFlag);
1593   }
1594 
1595   virtual bool needs_exception_state() const {
1596     return !is_invokespecial_receiver_check();
1597   }
1598 
1599   ciType* declared_type() const;
1600 };
1601 
1602 
1603 LEAF(InstanceOf, TypeCheck)
1604  public:
1605   // creation
1606   InstanceOf(ciKlass* klass, Value obj, ValueStack* state_before) : TypeCheck(klass, obj, intType, state_before) {}
1607 
1608   virtual bool needs_exception_state() const     { return false; }
1609 };
1610 
1611 
1612 BASE(AccessMonitor, StateSplit)
1613  private:
1614   Value       _obj;
1615   int         _monitor_no;
1616 
1617  public:
1618   // creation
1619   AccessMonitor(Value obj, int monitor_no, ValueStack* state_before = NULL)
1620   : StateSplit(illegalType, state_before)
1621   , _obj(obj)
1622   , _monitor_no(monitor_no)
1623   {
1624     set_needs_null_check(true);
1625     ASSERT_VALUES
1626   }
1627 
1628   // accessors
1629   Value obj() const                              { return _obj; }
1630   int monitor_no() const                         { return _monitor_no; }
1631 
1632   // generic
1633   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1634 };
1635 
1636 
1637 LEAF(MonitorEnter, AccessMonitor)
1638   bool _maybe_valuetype;
1639  public:
1640   // creation
1641   MonitorEnter(Value obj, int monitor_no, ValueStack* state_before, bool maybe_valuetype)
1642   : AccessMonitor(obj, monitor_no, state_before)
1643   , _maybe_valuetype(maybe_valuetype)
1644   {
1645     ASSERT_VALUES
1646   }
1647 
1648   // accessors
1649   bool maybe_valuetype() const                   { return _maybe_valuetype; }
1650 
1651   // generic
1652   virtual bool can_trap() const                  { return true; }
1653 };
1654 
1655 
1656 LEAF(MonitorExit, AccessMonitor)
1657  public:
1658   // creation
1659   MonitorExit(Value obj, int monitor_no)
1660   : AccessMonitor(obj, monitor_no, NULL)
1661   {
1662     ASSERT_VALUES
1663   }
1664 };
1665 
1666 
1667 LEAF(Intrinsic, StateSplit)
1668  private:
1669   vmIntrinsics::ID _id;
1670   Values*          _args;
1671   Value            _recv;
1672   ArgsNonNullState _nonnull_state;
1673 
1674  public:
1675   // preserves_state can be set to true for Intrinsics
1676   // which are guaranteed to preserve register state across any slow
1677   // cases; setting it to true does not mean that the Intrinsic can
1678   // not trap, only that if we continue execution in the same basic
1679   // block after the Intrinsic, all of the registers are intact. This
1680   // allows load elimination and common expression elimination to be
1681   // performed across the Intrinsic.  The default value is false.
1682   Intrinsic(ValueType* type,
1683             vmIntrinsics::ID id,
1684             Values* args,
1685             bool has_receiver,
1686             ValueStack* state_before,
1687             bool preserves_state,
1688             bool cantrap = true)
1689   : StateSplit(type, state_before)
1690   , _id(id)
1691   , _args(args)
1692   , _recv(NULL)
1693   {
1694     assert(args != NULL, &quot;args must exist&quot;);
1695     ASSERT_VALUES
1696     set_flag(PreservesStateFlag, preserves_state);
1697     set_flag(CanTrapFlag,        cantrap);
1698     if (has_receiver) {
1699       _recv = argument_at(0);
1700     }
1701     set_needs_null_check(has_receiver);
1702 
1703     // some intrinsics can&#39;t trap, so don&#39;t force them to be pinned
1704     if (!can_trap() &amp;&amp; !vmIntrinsics::should_be_pinned(_id)) {
1705       unpin(PinStateSplitConstructor);
1706     }
1707   }
1708 
1709   // accessors
1710   vmIntrinsics::ID id() const                    { return _id; }
1711   int number_of_arguments() const                { return _args-&gt;length(); }
1712   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1713 
1714   bool has_receiver() const                      { return (_recv != NULL); }
1715   Value receiver() const                         { assert(has_receiver(), &quot;must have receiver&quot;); return _recv; }
1716   bool preserves_state() const                   { return check_flag(PreservesStateFlag); }
1717 
1718   bool arg_needs_null_check(int i) const {
1719     return _nonnull_state.arg_needs_null_check(i);
1720   }
1721 
1722   void set_arg_needs_null_check(int i, bool check) {
1723     _nonnull_state.set_arg_needs_null_check(i, check);
1724   }
1725 
1726   // generic
1727   virtual bool can_trap() const                  { return check_flag(CanTrapFlag); }
1728   virtual void input_values_do(ValueVisitor* f) {
1729     StateSplit::input_values_do(f);
1730     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
1731   }
1732 };
1733 
1734 
1735 class LIR_List;
1736 
1737 LEAF(BlockBegin, StateSplit)
1738  private:
1739   int        _block_id;                          // the unique block id
1740   int        _bci;                               // start-bci of block
1741   int        _depth_first_number;                // number of this block in a depth-first ordering
1742   int        _linear_scan_number;                // number of this block in linear-scan ordering
1743   int        _dominator_depth;
1744   int        _loop_depth;                        // the loop nesting level of this block
1745   int        _loop_index;                        // number of the innermost loop of this block
1746   int        _flags;                             // the flags associated with this block
1747 
1748   // fields used by BlockListBuilder
1749   int            _total_preds;                   // number of predecessors found by BlockListBuilder
1750   ResourceBitMap _stores_to_locals;              // bit is set when a local variable is stored in the block
1751 
1752   // SSA specific fields: (factor out later)
1753   BlockList   _successors;                       // the successors of this block
1754   BlockList   _predecessors;                     // the predecessors of this block
1755   BlockList   _dominates;                        // list of blocks that are dominated by this block
1756   BlockBegin* _dominator;                        // the dominator of this block
1757   // SSA specific ends
1758   BlockEnd*  _end;                               // the last instruction of this block
1759   BlockList  _exception_handlers;                // the exception handlers potentially invoked by this block
1760   ValueStackStack* _exception_states;            // only for xhandler entries: states of all instructions that have an edge to this xhandler
1761   int        _exception_handler_pco;             // if this block is the start of an exception handler,
1762                                                  // this records the PC offset in the assembly code of the
1763                                                  // first instruction in this block
1764   Label      _label;                             // the label associated with this block
1765   LIR_List*  _lir;                               // the low level intermediate representation for this block
1766 
1767   ResourceBitMap _live_in;                       // set of live LIR_Opr registers at entry to this block
1768   ResourceBitMap _live_out;                      // set of live LIR_Opr registers at exit from this block
1769   ResourceBitMap _live_gen;                      // set of registers used before any redefinition in this block
1770   ResourceBitMap _live_kill;                     // set of registers defined in this block
1771 
1772   ResourceBitMap _fpu_register_usage;
1773   intArray*      _fpu_stack_state;               // For x86 FPU code generation with UseLinearScan
1774   int            _first_lir_instruction_id;      // ID of first LIR instruction in this block
1775   int            _last_lir_instruction_id;       // ID of last LIR instruction in this block
1776 
1777   void iterate_preorder (boolArray&amp; mark, BlockClosure* closure);
1778   void iterate_postorder(boolArray&amp; mark, BlockClosure* closure);
1779 
1780   friend class SuxAndWeightAdjuster;
1781 
1782  public:
1783    void* operator new(size_t size) throw() {
1784     Compilation* c = Compilation::current();
1785     void* res = c-&gt;arena()-&gt;Amalloc(size);
1786     return res;
1787   }
1788 
1789   // initialization/counting
1790   static int  number_of_blocks() {
1791     return Compilation::current()-&gt;number_of_blocks();
1792   }
1793 
1794   // creation
1795   BlockBegin(int bci)
1796   : StateSplit(illegalType)
1797   , _block_id(Compilation::current()-&gt;get_next_block_id())
1798   , _bci(bci)
1799   , _depth_first_number(-1)
1800   , _linear_scan_number(-1)
1801   , _dominator_depth(-1)
1802   , _loop_depth(0)
1803   , _loop_index(-1)
1804   , _flags(0)
1805   , _total_preds(0)
1806   , _stores_to_locals()
1807   , _successors(2)
1808   , _predecessors(2)
1809   , _dominates(2)
1810   , _dominator(NULL)
1811   , _end(NULL)
1812   , _exception_handlers(1)
1813   , _exception_states(NULL)
1814   , _exception_handler_pco(-1)
1815   , _lir(NULL)
1816   , _live_in()
1817   , _live_out()
1818   , _live_gen()
1819   , _live_kill()
1820   , _fpu_register_usage()
1821   , _fpu_stack_state(NULL)
1822   , _first_lir_instruction_id(-1)
1823   , _last_lir_instruction_id(-1)
1824   {
1825     _block = this;
1826 #ifndef PRODUCT
1827     set_printable_bci(bci);
1828 #endif
1829   }
1830 
1831   // accessors
1832   int block_id() const                           { return _block_id; }
1833   int bci() const                                { return _bci; }
1834   BlockList* successors()                        { return &amp;_successors; }
1835   BlockList* dominates()                         { return &amp;_dominates; }
1836   BlockBegin* dominator() const                  { return _dominator; }
1837   int loop_depth() const                         { return _loop_depth; }
1838   int dominator_depth() const                    { return _dominator_depth; }
1839   int depth_first_number() const                 { return _depth_first_number; }
1840   int linear_scan_number() const                 { return _linear_scan_number; }
1841   BlockEnd* end() const                          { return _end; }
1842   Label* label()                                 { return &amp;_label; }
1843   LIR_List* lir() const                          { return _lir; }
1844   int exception_handler_pco() const              { return _exception_handler_pco; }
1845   ResourceBitMap&amp; live_in()                      { return _live_in;        }
1846   ResourceBitMap&amp; live_out()                     { return _live_out;       }
1847   ResourceBitMap&amp; live_gen()                     { return _live_gen;       }
1848   ResourceBitMap&amp; live_kill()                    { return _live_kill;      }
1849   ResourceBitMap&amp; fpu_register_usage()           { return _fpu_register_usage; }
1850   intArray* fpu_stack_state() const              { return _fpu_stack_state;    }
1851   int first_lir_instruction_id() const           { return _first_lir_instruction_id; }
1852   int last_lir_instruction_id() const            { return _last_lir_instruction_id; }
1853   int total_preds() const                        { return _total_preds; }
1854   BitMap&amp; stores_to_locals()                     { return _stores_to_locals; }
1855 
1856   // manipulation
1857   void set_dominator(BlockBegin* dom)            { _dominator = dom; }
1858   void set_loop_depth(int d)                     { _loop_depth = d; }
1859   void set_dominator_depth(int d)                { _dominator_depth = d; }
1860   void set_depth_first_number(int dfn)           { _depth_first_number = dfn; }
1861   void set_linear_scan_number(int lsn)           { _linear_scan_number = lsn; }
1862   void set_end(BlockEnd* end);
1863   void clear_end();
1864   void disconnect_from_graph();
1865   static void disconnect_edge(BlockBegin* from, BlockBegin* to);
1866   BlockBegin* insert_block_between(BlockBegin* sux);
1867   void substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux);
1868   void set_lir(LIR_List* lir)                    { _lir = lir; }
1869   void set_exception_handler_pco(int pco)        { _exception_handler_pco = pco; }
1870   void set_live_in  (const ResourceBitMap&amp; map)  { _live_in = map;   }
1871   void set_live_out (const ResourceBitMap&amp; map)  { _live_out = map;  }
1872   void set_live_gen (const ResourceBitMap&amp; map)  { _live_gen = map;  }
1873   void set_live_kill(const ResourceBitMap&amp; map)  { _live_kill = map; }
1874   void set_fpu_register_usage(const ResourceBitMap&amp; map) { _fpu_register_usage = map; }
1875   void set_fpu_stack_state(intArray* state)      { _fpu_stack_state = state;  }
1876   void set_first_lir_instruction_id(int id)      { _first_lir_instruction_id = id;  }
1877   void set_last_lir_instruction_id(int id)       { _last_lir_instruction_id = id;  }
1878   void increment_total_preds(int n = 1)          { _total_preds += n; }
1879   void init_stores_to_locals(int locals_count)   { _stores_to_locals.initialize(locals_count); }
1880 
1881   // generic
1882   virtual void state_values_do(ValueVisitor* f);
1883 
1884   // successors and predecessors
1885   int number_of_sux() const;
1886   BlockBegin* sux_at(int i) const;
1887   void add_successor(BlockBegin* sux);
1888   void remove_successor(BlockBegin* pred);
1889   bool is_successor(BlockBegin* sux) const       { return _successors.contains(sux); }
1890 
1891   void add_predecessor(BlockBegin* pred);
1892   void remove_predecessor(BlockBegin* pred);
1893   bool is_predecessor(BlockBegin* pred) const    { return _predecessors.contains(pred); }
1894   int number_of_preds() const                    { return _predecessors.length(); }
1895   BlockBegin* pred_at(int i) const               { return _predecessors.at(i); }
1896 
1897   // exception handlers potentially invoked by this block
1898   void add_exception_handler(BlockBegin* b);
1899   bool is_exception_handler(BlockBegin* b) const { return _exception_handlers.contains(b); }
1900   int  number_of_exception_handlers() const      { return _exception_handlers.length(); }
1901   BlockBegin* exception_handler_at(int i) const  { return _exception_handlers.at(i); }
1902 
1903   // states of the instructions that have an edge to this exception handler
1904   int number_of_exception_states()               { assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;); return _exception_states == NULL ? 0 : _exception_states-&gt;length(); }
1905   ValueStack* exception_state_at(int idx) const  { assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;); return _exception_states-&gt;at(idx); }
1906   int add_exception_state(ValueStack* state);
1907 
1908   // flags
1909   enum Flag {
1910     no_flag                       = 0,
1911     std_entry_flag                = 1 &lt;&lt; 0,
1912     osr_entry_flag                = 1 &lt;&lt; 1,
1913     exception_entry_flag          = 1 &lt;&lt; 2,
1914     subroutine_entry_flag         = 1 &lt;&lt; 3,
1915     backward_branch_target_flag   = 1 &lt;&lt; 4,
1916     is_on_work_list_flag          = 1 &lt;&lt; 5,
1917     was_visited_flag              = 1 &lt;&lt; 6,
1918     parser_loop_header_flag       = 1 &lt;&lt; 7,  // set by parser to identify blocks where phi functions can not be created on demand
1919     critical_edge_split_flag      = 1 &lt;&lt; 8, // set for all blocks that are introduced when critical edges are split
1920     linear_scan_loop_header_flag  = 1 &lt;&lt; 9, // set during loop-detection for LinearScan
1921     linear_scan_loop_end_flag     = 1 &lt;&lt; 10, // set during loop-detection for LinearScan
1922     donot_eliminate_range_checks  = 1 &lt;&lt; 11  // Should be try to eliminate range checks in this block
1923   };
1924 
1925   void set(Flag f)                               { _flags |= f; }
1926   void clear(Flag f)                             { _flags &amp;= ~f; }
1927   bool is_set(Flag f) const                      { return (_flags &amp; f) != 0; }
1928   bool is_entry_block() const {
1929     const int entry_mask = std_entry_flag | osr_entry_flag | exception_entry_flag;
1930     return (_flags &amp; entry_mask) != 0;
1931   }
1932 
1933   // iteration
1934   void iterate_preorder   (BlockClosure* closure);
1935   void iterate_postorder  (BlockClosure* closure);
1936 
1937   void block_values_do(ValueVisitor* f);
1938 
1939   // loops
1940   void set_loop_index(int ix)                    { _loop_index = ix;        }
1941   int  loop_index() const                        { return _loop_index;      }
1942 
1943   // merging
1944   bool try_merge(ValueStack* state);             // try to merge states at block begin
1945   void merge(ValueStack* state)                  { bool b = try_merge(state); assert(b, &quot;merge failed&quot;); }
1946 
1947   // debugging
1948   void print_block()                             PRODUCT_RETURN;
1949   void print_block(InstructionPrinter&amp; ip, bool live_only = false) PRODUCT_RETURN;
1950 };
1951 
1952 
1953 BASE(BlockEnd, StateSplit)
1954  private:
1955   BlockList*  _sux;
1956 
1957  protected:
1958   BlockList* sux() const                         { return _sux; }
1959 
1960   void set_sux(BlockList* sux) {
1961 #ifdef ASSERT
1962     assert(sux != NULL, &quot;sux must exist&quot;);
1963     for (int i = sux-&gt;length() - 1; i &gt;= 0; i--) assert(sux-&gt;at(i) != NULL, &quot;sux must exist&quot;);
1964 #endif
1965     _sux = sux;
1966   }
1967 
1968  public:
1969   // creation
1970   BlockEnd(ValueType* type, ValueStack* state_before, bool is_safepoint)
1971   : StateSplit(type, state_before)
1972   , _sux(NULL)
1973   {
1974     set_flag(IsSafepointFlag, is_safepoint);
1975   }
1976 
1977   // accessors
1978   bool is_safepoint() const                      { return check_flag(IsSafepointFlag); }
1979   // For compatibility with old code, for new code use block()
1980   BlockBegin* begin() const                      { return _block; }
1981 
1982   // manipulation
1983   void set_begin(BlockBegin* begin);
1984 
1985   // successors
1986   int number_of_sux() const                      { return _sux != NULL ? _sux-&gt;length() : 0; }
1987   BlockBegin* sux_at(int i) const                { return _sux-&gt;at(i); }
1988   BlockBegin* default_sux() const                { return sux_at(number_of_sux() - 1); }
1989   BlockBegin** addr_sux_at(int i) const          { return _sux-&gt;adr_at(i); }
1990   int sux_index(BlockBegin* sux) const           { return _sux-&gt;find(sux); }
1991   void substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux);
1992 };
1993 
1994 
1995 LEAF(Goto, BlockEnd)
1996  public:
1997   enum Direction {
1998     none,            // Just a regular goto
1999     taken, not_taken // Goto produced from If
2000   };
2001  private:
2002   ciMethod*   _profiled_method;
2003   int         _profiled_bci;
2004   Direction   _direction;
2005  public:
2006   // creation
2007   Goto(BlockBegin* sux, ValueStack* state_before, bool is_safepoint = false)
2008     : BlockEnd(illegalType, state_before, is_safepoint)
2009     , _profiled_method(NULL)
2010     , _profiled_bci(0)
2011     , _direction(none) {
2012     BlockList* s = new BlockList(1);
2013     s-&gt;append(sux);
2014     set_sux(s);
2015   }
2016 
2017   Goto(BlockBegin* sux, bool is_safepoint) : BlockEnd(illegalType, NULL, is_safepoint)
2018                                            , _profiled_method(NULL)
2019                                            , _profiled_bci(0)
2020                                            , _direction(none) {
2021     BlockList* s = new BlockList(1);
2022     s-&gt;append(sux);
2023     set_sux(s);
2024   }
2025 
2026   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
2027   ciMethod* profiled_method() const              { return _profiled_method; } // set only for profiled branches
2028   int profiled_bci() const                       { return _profiled_bci; }
2029   Direction direction() const                    { return _direction; }
2030 
2031   void set_should_profile(bool value)            { set_flag(ProfileMDOFlag, value); }
2032   void set_profiled_method(ciMethod* method)     { _profiled_method = method; }
2033   void set_profiled_bci(int bci)                 { _profiled_bci = bci; }
2034   void set_direction(Direction d)                { _direction = d; }
2035 };
2036 
2037 #ifdef ASSERT
2038 LEAF(Assert, Instruction)
2039   private:
2040   Value       _x;
2041   Condition   _cond;
2042   Value       _y;
2043   char        *_message;
2044 
2045  public:
2046   // creation
2047   // unordered_is_true is valid for float/double compares only
2048    Assert(Value x, Condition cond, bool unordered_is_true, Value y);
2049 
2050   // accessors
2051   Value x() const                                { return _x; }
2052   Condition cond() const                         { return _cond; }
2053   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2054   Value y() const                                { return _y; }
2055   const char *message() const                    { return _message; }
2056 
2057   // generic
2058   virtual void input_values_do(ValueVisitor* f)  { f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2059 };
2060 #endif
2061 
2062 LEAF(RangeCheckPredicate, StateSplit)
2063  private:
2064   Value       _x;
2065   Condition   _cond;
2066   Value       _y;
2067 
2068   void check_state();
2069 
2070  public:
2071   // creation
2072   // unordered_is_true is valid for float/double compares only
2073    RangeCheckPredicate(Value x, Condition cond, bool unordered_is_true, Value y, ValueStack* state) : StateSplit(illegalType)
2074   , _x(x)
2075   , _cond(cond)
2076   , _y(y)
2077   {
2078     ASSERT_VALUES
2079     set_flag(UnorderedIsTrueFlag, unordered_is_true);
2080     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
2081     this-&gt;set_state(state);
2082     check_state();
2083   }
2084 
2085   // Always deoptimize
2086   RangeCheckPredicate(ValueStack* state) : StateSplit(illegalType)
2087   {
2088     this-&gt;set_state(state);
2089     _x = _y = NULL;
2090     check_state();
2091   }
2092 
2093   // accessors
2094   Value x() const                                { return _x; }
2095   Condition cond() const                         { return _cond; }
2096   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2097   Value y() const                                { return _y; }
2098 
2099   void always_fail()                             { _x = _y = NULL; }
2100 
2101   // generic
2102   virtual void input_values_do(ValueVisitor* f)  { StateSplit::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2103   HASHING3(RangeCheckPredicate, true, x()-&gt;subst(), y()-&gt;subst(), cond())
2104 };
2105 
2106 LEAF(If, BlockEnd)
2107  private:
2108   Value       _x;
2109   Condition   _cond;
2110   Value       _y;
2111   ciMethod*   _profiled_method;
2112   int         _profiled_bci; // Canonicalizer may alter bci of If node
2113   bool        _swapped;      // Is the order reversed with respect to the original If in the
2114                              // bytecode stream?
2115   bool        _substitutability_check;
2116  public:
2117   // creation
2118   // unordered_is_true is valid for float/double compares only
2119   If(Value x, Condition cond, bool unordered_is_true, Value y, BlockBegin* tsux, BlockBegin* fsux, ValueStack* state_before, bool is_safepoint, bool substitutability_check=false)
2120     : BlockEnd(illegalType, state_before, is_safepoint)
2121   , _x(x)
2122   , _cond(cond)
2123   , _y(y)
2124   , _profiled_method(NULL)
2125   , _profiled_bci(0)
2126   , _swapped(false)
2127   , _substitutability_check(substitutability_check)
2128   {
2129     ASSERT_VALUES
2130     set_flag(UnorderedIsTrueFlag, unordered_is_true);
2131     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
2132     BlockList* s = new BlockList(2);
2133     s-&gt;append(tsux);
2134     s-&gt;append(fsux);
2135     set_sux(s);
2136   }
2137 
2138   // accessors
2139   Value x() const                                { return _x; }
2140   Condition cond() const                         { return _cond; }
2141   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2142   Value y() const                                { return _y; }
2143   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2144   BlockBegin* tsux() const                       { return sux_for(true); }
2145   BlockBegin* fsux() const                       { return sux_for(false); }
2146   BlockBegin* usux() const                       { return sux_for(unordered_is_true()); }
2147   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
2148   ciMethod* profiled_method() const              { return _profiled_method; } // set only for profiled branches
2149   int profiled_bci() const                       { return _profiled_bci; }    // set for profiled branches and tiered
2150   bool is_swapped() const                        { return _swapped; }
2151 
2152   // manipulation
2153   void swap_operands() {
2154     Value t = _x; _x = _y; _y = t;
2155     _cond = mirror(_cond);
2156   }
2157 
2158   void swap_sux() {
2159     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2160     BlockList* s = sux();
2161     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2162     _cond = negate(_cond);
2163     set_flag(UnorderedIsTrueFlag, !check_flag(UnorderedIsTrueFlag));
2164   }
2165 
2166   void set_should_profile(bool value)             { set_flag(ProfileMDOFlag, value); }
2167   void set_profiled_method(ciMethod* method)      { _profiled_method = method; }
2168   void set_profiled_bci(int bci)                  { _profiled_bci = bci;       }
2169   void set_swapped(bool value)                    { _swapped = value;         }
2170   bool substitutability_check() const              { return _substitutability_check; }
2171   // generic
2172   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2173 };
2174 
2175 
2176 LEAF(IfInstanceOf, BlockEnd)
2177  private:
2178   ciKlass* _klass;
2179   Value    _obj;
2180   bool     _test_is_instance;                    // jump if instance
2181   int      _instanceof_bci;
2182 
2183  public:
2184   IfInstanceOf(ciKlass* klass, Value obj, bool test_is_instance, int instanceof_bci, BlockBegin* tsux, BlockBegin* fsux)
2185   : BlockEnd(illegalType, NULL, false) // temporary set to false
2186   , _klass(klass)
2187   , _obj(obj)
2188   , _test_is_instance(test_is_instance)
2189   , _instanceof_bci(instanceof_bci)
2190   {
2191     ASSERT_VALUES
2192     assert(instanceof_bci &gt;= 0, &quot;illegal bci&quot;);
2193     BlockList* s = new BlockList(2);
2194     s-&gt;append(tsux);
2195     s-&gt;append(fsux);
2196     set_sux(s);
2197   }
2198 
2199   // accessors
2200   //
2201   // Note 1: If test_is_instance() is true, IfInstanceOf tests if obj *is* an
2202   //         instance of klass; otherwise it tests if it is *not* and instance
2203   //         of klass.
2204   //
2205   // Note 2: IfInstanceOf instructions are created by combining an InstanceOf
2206   //         and an If instruction. The IfInstanceOf bci() corresponds to the
2207   //         bci that the If would have had; the (this-&gt;) instanceof_bci() is
2208   //         the bci of the original InstanceOf instruction.
2209   ciKlass* klass() const                         { return _klass; }
2210   Value obj() const                              { return _obj; }
2211   int instanceof_bci() const                     { return _instanceof_bci; }
2212   bool test_is_instance() const                  { return _test_is_instance; }
2213   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2214   BlockBegin* tsux() const                       { return sux_for(true); }
2215   BlockBegin* fsux() const                       { return sux_for(false); }
2216 
2217   // manipulation
2218   void swap_sux() {
2219     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2220     BlockList* s = sux();
2221     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2222     _test_is_instance = !_test_is_instance;
2223   }
2224 
2225   // generic
2226   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_obj); }
2227 };
2228 
2229 
2230 BASE(Switch, BlockEnd)
2231  private:
2232   Value       _tag;
2233 
2234  public:
2235   // creation
2236   Switch(Value tag, BlockList* sux, ValueStack* state_before, bool is_safepoint)
2237   : BlockEnd(illegalType, state_before, is_safepoint)
2238   , _tag(tag) {
2239     ASSERT_VALUES
2240     set_sux(sux);
2241   }
2242 
2243   // accessors
2244   Value tag() const                              { return _tag; }
2245   int length() const                             { return number_of_sux() - 1; }
2246 
2247   virtual bool needs_exception_state() const     { return false; }
2248 
2249   // generic
2250   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_tag); }
2251 };
2252 
2253 
2254 LEAF(TableSwitch, Switch)
2255  private:
2256   int _lo_key;
2257 
2258  public:
2259   // creation
2260   TableSwitch(Value tag, BlockList* sux, int lo_key, ValueStack* state_before, bool is_safepoint)
2261     : Switch(tag, sux, state_before, is_safepoint)
2262   , _lo_key(lo_key) { assert(_lo_key &lt;= hi_key(), &quot;integer overflow&quot;); }
2263 
2264   // accessors
2265   int lo_key() const                             { return _lo_key; }
2266   int hi_key() const                             { return _lo_key + (length() - 1); }
2267 };
2268 
2269 
2270 LEAF(LookupSwitch, Switch)
2271  private:
2272   intArray* _keys;
2273 
2274  public:
2275   // creation
2276   LookupSwitch(Value tag, BlockList* sux, intArray* keys, ValueStack* state_before, bool is_safepoint)
2277   : Switch(tag, sux, state_before, is_safepoint)
2278   , _keys(keys) {
2279     assert(keys != NULL, &quot;keys must exist&quot;);
2280     assert(keys-&gt;length() == length(), &quot;sux &amp; keys have incompatible lengths&quot;);
2281   }
2282 
2283   // accessors
2284   int key_at(int i) const                        { return _keys-&gt;at(i); }
2285 };
2286 
2287 
2288 LEAF(Return, BlockEnd)
2289  private:
2290   Value _result;
2291 
2292  public:
2293   // creation
2294   Return(Value result) :
2295     BlockEnd(result == NULL ? voidType : result-&gt;type()-&gt;base(), NULL, true),
2296     _result(result) {}
2297 
2298   // accessors
2299   Value result() const                           { return _result; }
2300   bool has_result() const                        { return result() != NULL; }
2301 
2302   // generic
2303   virtual void input_values_do(ValueVisitor* f) {
2304     BlockEnd::input_values_do(f);
2305     if (has_result()) f-&gt;visit(&amp;_result);
2306   }
2307 };
2308 
2309 
2310 LEAF(Throw, BlockEnd)
2311  private:
2312   Value _exception;
2313 
2314  public:
2315   // creation
2316   Throw(Value exception, ValueStack* state_before) : BlockEnd(illegalType, state_before, true), _exception(exception) {
2317     ASSERT_VALUES
2318   }
2319 
2320   // accessors
2321   Value exception() const                        { return _exception; }
2322 
2323   // generic
2324   virtual bool can_trap() const                  { return true; }
2325   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_exception); }
2326 };
2327 
2328 
2329 LEAF(Base, BlockEnd)
2330  public:
2331   // creation
2332   Base(BlockBegin* std_entry, BlockBegin* osr_entry) : BlockEnd(illegalType, NULL, false) {
2333     assert(std_entry-&gt;is_set(BlockBegin::std_entry_flag), &quot;std entry must be flagged&quot;);
2334     assert(osr_entry == NULL || osr_entry-&gt;is_set(BlockBegin::osr_entry_flag), &quot;osr entry must be flagged&quot;);
2335     BlockList* s = new BlockList(2);
2336     if (osr_entry != NULL) s-&gt;append(osr_entry);
2337     s-&gt;append(std_entry); // must be default sux!
2338     set_sux(s);
2339   }
2340 
2341   // accessors
2342   BlockBegin* std_entry() const                  { return default_sux(); }
2343   BlockBegin* osr_entry() const                  { return number_of_sux() &lt; 2 ? NULL : sux_at(0); }
2344 };
2345 
2346 
2347 LEAF(OsrEntry, Instruction)
2348  public:
2349   // creation
2350 #ifdef _LP64
2351   OsrEntry() : Instruction(longType) { pin(); }
2352 #else
2353   OsrEntry() : Instruction(intType)  { pin(); }
2354 #endif
2355 
2356   // generic
2357   virtual void input_values_do(ValueVisitor* f)   { }
2358 };
2359 
2360 
2361 // Models the incoming exception at a catch site
2362 LEAF(ExceptionObject, Instruction)
2363  public:
2364   // creation
2365   ExceptionObject() : Instruction(objectType) {
2366     pin();
2367   }
2368 
2369   // generic
2370   virtual void input_values_do(ValueVisitor* f)   { }
2371 };
2372 
2373 
2374 // Models needed rounding for floating-point values on Intel.
2375 // Currently only used to represent rounding of double-precision
2376 // values stored into local variables, but could be used to model
2377 // intermediate rounding of single-precision values as well.
2378 LEAF(RoundFP, Instruction)
2379  private:
2380   Value _input;             // floating-point value to be rounded
2381 
2382  public:
2383   RoundFP(Value input)
2384   : Instruction(input-&gt;type()) // Note: should not be used for constants
2385   , _input(input)
2386   {
2387     ASSERT_VALUES
2388   }
2389 
2390   // accessors
2391   Value input() const                            { return _input; }
2392 
2393   // generic
2394   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_input); }
2395 };
2396 
2397 
2398 BASE(UnsafeOp, Instruction)
2399  private:
2400   BasicType _basic_type;    // ValueType can not express byte-sized integers
2401 
2402  protected:
2403   // creation
2404   UnsafeOp(BasicType basic_type, bool is_put)
2405   : Instruction(is_put ? voidType : as_ValueType(basic_type))
2406   , _basic_type(basic_type)
2407   {
2408     //Note:  Unsafe ops are not not guaranteed to throw NPE.
2409     // Convservatively, Unsafe operations must be pinned though we could be
2410     // looser about this if we wanted to..
2411     pin();
2412   }
2413 
2414  public:
2415   // accessors
2416   BasicType basic_type()                         { return _basic_type; }
2417 
2418   // generic
2419   virtual void input_values_do(ValueVisitor* f)   { }
2420 };
2421 
2422 
2423 BASE(UnsafeRawOp, UnsafeOp)
2424  private:
2425   Value _base;                                   // Base address (a Java long)
2426   Value _index;                                  // Index if computed by optimizer; initialized to NULL
2427   int   _log2_scale;                             // Scale factor: 0, 1, 2, or 3.
2428                                                  // Indicates log2 of number of bytes (1, 2, 4, or 8)
2429                                                  // to scale index by.
2430 
2431  protected:
2432   UnsafeRawOp(BasicType basic_type, Value addr, bool is_put)
2433   : UnsafeOp(basic_type, is_put)
2434   , _base(addr)
2435   , _index(NULL)
2436   , _log2_scale(0)
2437   {
2438     // Can not use ASSERT_VALUES because index may be NULL
2439     assert(addr != NULL &amp;&amp; addr-&gt;type()-&gt;is_long(), &quot;just checking&quot;);
2440   }
2441 
2442   UnsafeRawOp(BasicType basic_type, Value base, Value index, int log2_scale, bool is_put)
2443   : UnsafeOp(basic_type, is_put)
2444   , _base(base)
2445   , _index(index)
2446   , _log2_scale(log2_scale)
2447   {
2448   }
2449 
2450  public:
2451   // accessors
2452   Value base()                                   { return _base; }
2453   Value index()                                  { return _index; }
2454   bool  has_index()                              { return (_index != NULL); }
2455   int   log2_scale()                             { return _log2_scale; }
2456 
2457   // setters
2458   void set_base (Value base)                     { _base  = base; }
2459   void set_index(Value index)                    { _index = index; }
2460   void set_log2_scale(int log2_scale)            { _log2_scale = log2_scale; }
2461 
2462   // generic
2463   virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);
2464                                                    f-&gt;visit(&amp;_base);
2465                                                    if (has_index()) f-&gt;visit(&amp;_index); }
2466 };
2467 
2468 
2469 LEAF(UnsafeGetRaw, UnsafeRawOp)
2470  private:
2471  bool _may_be_unaligned, _is_wide;  // For OSREntry
2472 
2473  public:
2474  UnsafeGetRaw(BasicType basic_type, Value addr, bool may_be_unaligned, bool is_wide = false)
2475   : UnsafeRawOp(basic_type, addr, false) {
2476     _may_be_unaligned = may_be_unaligned;
2477     _is_wide = is_wide;
2478   }
2479 
2480  UnsafeGetRaw(BasicType basic_type, Value base, Value index, int log2_scale, bool may_be_unaligned, bool is_wide = false)
2481   : UnsafeRawOp(basic_type, base, index, log2_scale, false) {
2482     _may_be_unaligned = may_be_unaligned;
2483     _is_wide = is_wide;
2484   }
2485 
2486   bool may_be_unaligned()                         { return _may_be_unaligned; }
2487   bool is_wide()                                  { return _is_wide; }
2488 };
2489 
2490 
2491 LEAF(UnsafePutRaw, UnsafeRawOp)
2492  private:
2493   Value _value;                                  // Value to be stored
2494 
2495  public:
2496   UnsafePutRaw(BasicType basic_type, Value addr, Value value)
2497   : UnsafeRawOp(basic_type, addr, true)
2498   , _value(value)
2499   {
2500     assert(value != NULL, &quot;just checking&quot;);
2501     ASSERT_VALUES
2502   }
2503 
2504   UnsafePutRaw(BasicType basic_type, Value base, Value index, int log2_scale, Value value)
2505   : UnsafeRawOp(basic_type, base, index, log2_scale, true)
2506   , _value(value)
2507   {
2508     assert(value != NULL, &quot;just checking&quot;);
2509     ASSERT_VALUES
2510   }
2511 
2512   // accessors
2513   Value value()                                  { return _value; }
2514 
2515   // generic
2516   virtual void input_values_do(ValueVisitor* f)   { UnsafeRawOp::input_values_do(f);
2517                                                    f-&gt;visit(&amp;_value); }
2518 };
2519 
2520 
2521 BASE(UnsafeObjectOp, UnsafeOp)
2522  private:
2523   Value _object;                                 // Object to be fetched from or mutated
2524   Value _offset;                                 // Offset within object
2525   bool  _is_volatile;                            // true if volatile - dl/JSR166
2526  public:
2527   UnsafeObjectOp(BasicType basic_type, Value object, Value offset, bool is_put, bool is_volatile)
2528     : UnsafeOp(basic_type, is_put), _object(object), _offset(offset), _is_volatile(is_volatile)
2529   {
2530   }
2531 
2532   // accessors
2533   Value object()                                 { return _object; }
2534   Value offset()                                 { return _offset; }
2535   bool  is_volatile()                            { return _is_volatile; }
2536   // generic
2537   virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);
2538                                                    f-&gt;visit(&amp;_object);
2539                                                    f-&gt;visit(&amp;_offset); }
2540 };
2541 
2542 
2543 LEAF(UnsafeGetObject, UnsafeObjectOp)
2544  public:
2545   UnsafeGetObject(BasicType basic_type, Value object, Value offset, bool is_volatile)
2546   : UnsafeObjectOp(basic_type, object, offset, false, is_volatile)
2547   {
2548     ASSERT_VALUES
2549   }
2550 };
2551 
2552 
2553 LEAF(UnsafePutObject, UnsafeObjectOp)
2554  private:
2555   Value _value;                                  // Value to be stored
2556  public:
2557   UnsafePutObject(BasicType basic_type, Value object, Value offset, Value value, bool is_volatile)
2558   : UnsafeObjectOp(basic_type, object, offset, true, is_volatile)
2559     , _value(value)
2560   {
2561     ASSERT_VALUES
2562   }
2563 
2564   // accessors
2565   Value value()                                  { return _value; }
2566 
2567   // generic
2568   virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);
2569                                                    f-&gt;visit(&amp;_value); }
2570 };
2571 
2572 LEAF(UnsafeGetAndSetObject, UnsafeObjectOp)
2573  private:
2574   Value _value;                                  // Value to be stored
2575   bool  _is_add;
2576  public:
2577   UnsafeGetAndSetObject(BasicType basic_type, Value object, Value offset, Value value, bool is_add)
2578   : UnsafeObjectOp(basic_type, object, offset, false, false)
2579     , _value(value)
2580     , _is_add(is_add)
2581   {
2582     ASSERT_VALUES
2583   }
2584 
2585   // accessors
2586   bool is_add() const                            { return _is_add; }
2587   Value value()                                  { return _value; }
2588 
2589   // generic
2590   virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);
2591                                                    f-&gt;visit(&amp;_value); }
2592 };
2593 
2594 LEAF(ProfileCall, Instruction)
2595  private:
2596   ciMethod*        _method;
2597   int              _bci_of_invoke;
2598   ciMethod*        _callee;         // the method that is called at the given bci
2599   Value            _recv;
2600   ciKlass*         _known_holder;
2601   Values*          _obj_args;       // arguments for type profiling
2602   ArgsNonNullState _nonnull_state;  // Do we know whether some arguments are never null?
2603   bool             _inlined;        // Are we profiling a call that is inlined
2604 
2605  public:
2606   ProfileCall(ciMethod* method, int bci, ciMethod* callee, Value recv, ciKlass* known_holder, Values* obj_args, bool inlined)
2607     : Instruction(voidType)
2608     , _method(method)
2609     , _bci_of_invoke(bci)
2610     , _callee(callee)
2611     , _recv(recv)
2612     , _known_holder(known_holder)
2613     , _obj_args(obj_args)
2614     , _inlined(inlined)
2615   {
2616     // The ProfileCall has side-effects and must occur precisely where located
2617     pin();
2618   }
2619 
2620   ciMethod* method()             const { return _method; }
2621   int bci_of_invoke()            const { return _bci_of_invoke; }
2622   ciMethod* callee()             const { return _callee; }
2623   Value recv()                   const { return _recv; }
2624   ciKlass* known_holder()        const { return _known_holder; }
2625   int nb_profiled_args()         const { return _obj_args == NULL ? 0 : _obj_args-&gt;length(); }
2626   Value profiled_arg_at(int i)   const { return _obj_args-&gt;at(i); }
2627   bool arg_needs_null_check(int i) const {
2628     return _nonnull_state.arg_needs_null_check(i);
2629   }
2630   bool inlined()                 const { return _inlined; }
2631 
2632   void set_arg_needs_null_check(int i, bool check) {
2633     _nonnull_state.set_arg_needs_null_check(i, check);
2634   }
2635 
2636   virtual void input_values_do(ValueVisitor* f)   {
2637     if (_recv != NULL) {
2638       f-&gt;visit(&amp;_recv);
2639     }
2640     for (int i = 0; i &lt; nb_profiled_args(); i++) {
2641       f-&gt;visit(_obj_args-&gt;adr_at(i));
2642     }
2643   }
2644 };
2645 
2646 LEAF(ProfileReturnType, Instruction)
2647  private:
2648   ciMethod*        _method;
2649   ciMethod*        _callee;
2650   int              _bci_of_invoke;
2651   Value            _ret;
2652 
2653  public:
2654   ProfileReturnType(ciMethod* method, int bci, ciMethod* callee, Value ret)
2655     : Instruction(voidType)
2656     , _method(method)
2657     , _callee(callee)
2658     , _bci_of_invoke(bci)
2659     , _ret(ret)
2660   {
2661     set_needs_null_check(true);
2662     // The ProfileType has side-effects and must occur precisely where located
2663     pin();
2664   }
2665 
2666   ciMethod* method()             const { return _method; }
2667   ciMethod* callee()             const { return _callee; }
2668   int bci_of_invoke()            const { return _bci_of_invoke; }
2669   Value ret()                    const { return _ret; }
2670 
2671   virtual void input_values_do(ValueVisitor* f)   {
2672     if (_ret != NULL) {
2673       f-&gt;visit(&amp;_ret);
2674     }
2675   }
2676 };
2677 
2678 // Call some C runtime function that doesn&#39;t safepoint,
2679 // optionally passing the current thread as the first argument.
2680 LEAF(RuntimeCall, Instruction)
2681  private:
2682   const char* _entry_name;
2683   address     _entry;
2684   Values*     _args;
2685   bool        _pass_thread;  // Pass the JavaThread* as an implicit first argument
2686 
2687  public:
2688   RuntimeCall(ValueType* type, const char* entry_name, address entry, Values* args, bool pass_thread = true)
2689     : Instruction(type)
2690     , _entry_name(entry_name)
2691     , _entry(entry)
2692     , _args(args)
2693     , _pass_thread(pass_thread) {
2694     ASSERT_VALUES
2695     pin();
2696   }
2697 
2698   const char* entry_name() const  { return _entry_name; }
2699   address entry() const           { return _entry; }
2700   int number_of_arguments() const { return _args-&gt;length(); }
2701   Value argument_at(int i) const  { return _args-&gt;at(i); }
2702   bool pass_thread() const        { return _pass_thread; }
2703 
2704   virtual void input_values_do(ValueVisitor* f)   {
2705     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
2706   }
2707 };
2708 
2709 // Use to trip invocation counter of an inlined method
2710 
2711 LEAF(ProfileInvoke, Instruction)
2712  private:
2713   ciMethod*   _inlinee;
2714   ValueStack* _state;
2715 
2716  public:
2717   ProfileInvoke(ciMethod* inlinee,  ValueStack* state)
2718     : Instruction(voidType)
2719     , _inlinee(inlinee)
2720     , _state(state)
2721   {
2722     // The ProfileInvoke has side-effects and must occur precisely where located QQQ???
2723     pin();
2724   }
2725 
2726   ciMethod* inlinee()      { return _inlinee; }
2727   ValueStack* state()      { return _state; }
2728   virtual void input_values_do(ValueVisitor*)   {}
2729   virtual void state_values_do(ValueVisitor*);
2730 };
2731 
2732 LEAF(MemBar, Instruction)
2733  private:
2734   LIR_Code _code;
2735 
2736  public:
2737   MemBar(LIR_Code code)
2738     : Instruction(voidType)
2739     , _code(code)
2740   {
2741     pin();
2742   }
2743 
2744   LIR_Code code()           { return _code; }
2745 
2746   virtual void input_values_do(ValueVisitor*)   {}
2747 };
2748 
2749 class BlockPair: public CompilationResourceObj {
2750  private:
2751   BlockBegin* _from;
2752   BlockBegin* _to;
2753  public:
2754   BlockPair(BlockBegin* from, BlockBegin* to): _from(from), _to(to) {}
2755   BlockBegin* from() const { return _from; }
2756   BlockBegin* to() const   { return _to;   }
2757   bool is_same(BlockBegin* from, BlockBegin* to) const { return  _from == from &amp;&amp; _to == to; }
2758   bool is_same(BlockPair* p) const { return  _from == p-&gt;from() &amp;&amp; _to == p-&gt;to(); }
2759   void set_to(BlockBegin* b)   { _to = b; }
2760   void set_from(BlockBegin* b) { _from = b; }
2761 };
2762 
2763 typedef GrowableArray&lt;BlockPair*&gt; BlockPairList;
2764 
2765 inline int         BlockBegin::number_of_sux() const            { assert(_end == NULL || _end-&gt;number_of_sux() == _successors.length(), &quot;mismatch&quot;); return _successors.length(); }
2766 inline BlockBegin* BlockBegin::sux_at(int i) const              { assert(_end == NULL || _end-&gt;sux_at(i) == _successors.at(i), &quot;mismatch&quot;);          return _successors.at(i); }
2767 inline void        BlockBegin::add_successor(BlockBegin* sux)   { assert(_end == NULL, &quot;Would create mismatch with successors of BlockEnd&quot;);         _successors.append(sux); }
2768 
2769 #undef ASSERT_VALUES
2770 
2771 #endif // SHARE_C1_C1_INSTRUCTION_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
diff a/src/hotspot/share/c1/c1_LIRGenerator.cpp b/src/hotspot/share/c1/c1_LIRGenerator.cpp
--- a/src/hotspot/share/c1/c1_LIRGenerator.cpp
+++ b/src/hotspot/share/c1/c1_LIRGenerator.cpp
@@ -1552,11 +1552,11 @@
 #endif
 
   if (x->needs_null_check() &&
       (needs_patching ||
        MacroAssembler::needs_explicit_null_check(x->offset()))) {
-    if (needs_patching && x->field()->is_flattenable()) {
+    if (needs_patching && x->field()->signature()->is_Q_signature()) {
       // We are storing a field of type "QT;" into holder class H, but H is not yet
       // loaded. (If H had been loaded, then T must also have already been loaded
       // due to the "Q" signature, and needs_patching would be false).
       assert(!x->field()->holder()->is_loaded(), "must be");
       // We don't know the offset of this field. Let's deopt and recompile.
@@ -1691,11 +1691,11 @@
   if (x->elt_type() == T_OBJECT && x->array()->maybe_flattened_array()) {
     ciType* type = x->value()->declared_type();
     if (type != NULL && type->is_klass()) {
       ciKlass* klass = type->as_klass();
       if (!klass->can_be_value_klass() || (klass->is_valuetype() && !klass->as_value_klass()->flatten_array())) {
-        // This is known to be a non-flattenable object. If the array is flattened,
+        // This is known to be a non-flattened object. If the array is flattened,
         // it will be caught by the code generated by array_store_check().
         return false;
       }
     }
     // We're not 100% sure, so let's do the flattened_array_store_check.
@@ -1898,11 +1898,11 @@
   }
 
   return _barrier_set->resolve(this, decorators, obj);
 }
 
-Constant* LIRGenerator::flattenable_load_field_prolog(LoadField* x, CodeEmitInfo* info) {
+Constant* LIRGenerator::flattened_field_load_prolog(LoadField* x, CodeEmitInfo* info) {
   ciField* field = x->field();
   ciInstanceKlass* holder = field->holder();
   Constant* default_value = NULL;
 
   // Unloaded "QV;" klasses are represented by a ciInstanceKlass
@@ -2002,12 +2002,12 @@
                   x->is_static() ?  "static" : "field", x->printable_bci());
   }
 #endif
 
   Constant* default_value = NULL;
-  if (x->field()->is_flattenable()) {
-    default_value = flattenable_load_field_prolog(x, info);
+  if (x->field()->signature()->is_Q_signature()) {
+    default_value = flattened_field_load_prolog(x, info);
   }
 
   bool stress_deopt = StressLoopInvariantCodeMotion && info && info->deoptimize_on_exception();
   if (x->needs_null_check() &&
       (needs_patching ||

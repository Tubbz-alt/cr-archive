<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/parseHelper.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="parse3.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/parseHelper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 52   // Get method
 53   const TypePtr* method_type = TypeMetadataPtr::make(method);
 54   Node *method_node = _gvn.transform(ConNode::make(method_type));
 55 
 56   kill_dead_locals();
 57 
 58   // For some reason, this call reads only raw memory.
 59   const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;
 60   make_runtime_call(RC_LEAF | RC_NARROW_MEM,
 61                     call_type, call_address,
 62                     call_name, raw_adr_type,
 63                     thread, method_node);
 64 }
 65 
 66 
 67 //=============================================================================
 68 //------------------------------do_checkcast-----------------------------------
 69 void Parse::do_checkcast() {
 70   bool will_link;
 71   ciKlass* klass = iter().get_klass(will_link);
<span class="line-removed"> 72   bool never_null = iter().is_klass_never_null();</span>
<span class="line-removed"> 73 </span>
 74   Node *obj = peek();
 75 
 76   // Throw uncommon trap if class is not loaded or the value we are casting
 77   // _from_ is not loaded, and value is not null.  If the value _is_ NULL,
 78   // then the checkcast does nothing.
 79   const TypeOopPtr *tp = _gvn.type(obj)-&gt;isa_oopptr();
 80   if (!will_link || (tp &amp;&amp; tp-&gt;klass() &amp;&amp; !tp-&gt;klass()-&gt;is_loaded())) {
<span class="line-modified"> 81     assert(!never_null, &quot;Null-free value type should be loaded&quot;);</span>
 82     if (C-&gt;log() != NULL) {
 83       if (!will_link) {
 84         C-&gt;log()-&gt;elem(&quot;assert_null reason=&#39;checkcast&#39; klass=&#39;%d&#39;&quot;,
 85                        C-&gt;log()-&gt;identify(klass));
 86       }
 87       if (tp &amp;&amp; tp-&gt;klass() &amp;&amp; !tp-&gt;klass()-&gt;is_loaded()) {
 88         // %%% Cannot happen?
 89         C-&gt;log()-&gt;elem(&quot;assert_null reason=&#39;checkcast source&#39; klass=&#39;%d&#39;&quot;,
 90                        C-&gt;log()-&gt;identify(tp-&gt;klass()));
 91       }
 92     }
 93     null_assert(obj);
 94     assert( stopped() || _gvn.type(peek())-&gt;higher_equal(TypePtr::NULL_PTR), &quot;what&#39;s left behind is null&quot; );
 95     if (!stopped()) {
 96       profile_null_checkcast();
 97     }
 98     return;
 99   }
100 
<span class="line-modified">101   Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass)), NULL, never_null);</span>
102   if (stopped()) {
103     return;
104   }
105 
106   // Pop from stack AFTER gen_checkcast because it can uncommon trap and
107   // the debug info has to be correct.
108   pop();
109   push(res);
110 }
111 
112 
113 //------------------------------do_instanceof----------------------------------
114 void Parse::do_instanceof() {
115   if (stopped())  return;
116   // We would like to return false if class is not loaded, emitting a
117   // dependency, but Java requires instanceof to load its operand.
118 
119   // Throw uncommon trap if class is not loaded
120   bool will_link;
121   ciKlass* klass = iter().get_klass(will_link);
</pre>
<hr />
<pre>
340 
341   ValueTypeNode* vt = ValueTypeNode::make_default(_gvn, vk);
342   if (vk-&gt;is_scalarizable()) {
343     push(vt);
344   } else {
345     push(vt-&gt;get_oop());
346   }
347 }
348 
349 //------------------------------do_withfield------------------------------------
350 void Parse::do_withfield() {
351   bool will_link;
352   ciField* field = iter().get_field(will_link);
353   assert(will_link, &quot;withfield: typeflow responsibility&quot;);
354   Node* val = pop_node(field-&gt;layout_type());
355   ciValueKlass* holder_klass = field-&gt;holder()-&gt;as_value_klass();
356   Node* holder = pop();
357   int nargs = 1 + field-&gt;type()-&gt;size();
358 
359   if (!holder-&gt;is_ValueType()) {
<span class="line-modified">360     // Null check and scalarize value type holder</span>
<span class="line-modified">361     inc_sp(nargs);</span>
<span class="line-removed">362     holder = null_check(holder);</span>
<span class="line-removed">363     dec_sp(nargs);</span>
<span class="line-removed">364     if (stopped()) return;</span>
365     holder = ValueTypeNode::make_from_oop(this, holder, holder_klass);
366   }
<span class="line-modified">367   if (!val-&gt;is_ValueType() &amp;&amp; field-&gt;is_flattenable()) {</span>
<span class="line-modified">368     // Null check and scalarize value type field value</span>
<span class="line-modified">369     inc_sp(nargs);</span>
<span class="line-removed">370     val = null_check(val);</span>
<span class="line-removed">371     dec_sp(nargs);</span>
<span class="line-removed">372     if (stopped()) return;</span>
373     val = ValueTypeNode::make_from_oop(this, val, gvn().type(val)-&gt;value_klass());
<span class="line-modified">374   } else if (val-&gt;is_ValueType() &amp;&amp; !field-&gt;is_flattenable()) {</span>
<span class="line-modified">375     // Non-flattenable field value needs to be allocated because it can be merged</span>
<span class="line-modified">376     // with an oop. Re-execute withfield if buffering triggers deoptimization.</span>
377     PreserveReexecuteState preexecs(this);
378     jvms()-&gt;set_should_reexecute(true);
379     inc_sp(nargs);
380     val = val-&gt;as_ValueType()-&gt;buffer(this);
381   }
382 
383   // Clone the value type node and set the new field value
384   ValueTypeNode* new_vt = holder-&gt;clone()-&gt;as_ValueType();
385   new_vt-&gt;set_oop(_gvn.zerocon(T_INLINE_TYPE));
386   gvn().set_type(new_vt, new_vt-&gt;bottom_type());
387   new_vt-&gt;set_field_value_by_offset(field-&gt;offset(), val);
388   Node* res = new_vt;
389 
390   if (!holder_klass-&gt;is_scalarizable()) {
391     // Re-execute withfield if buffering triggers deoptimization
392     PreserveReexecuteState preexecs(this);
393     jvms()-&gt;set_should_reexecute(true);
394     inc_sp(nargs);
395     res = new_vt-&gt;buffer(this)-&gt;get_oop();
396   }
</pre>
</td>
<td>
<hr />
<pre>
 52   // Get method
 53   const TypePtr* method_type = TypeMetadataPtr::make(method);
 54   Node *method_node = _gvn.transform(ConNode::make(method_type));
 55 
 56   kill_dead_locals();
 57 
 58   // For some reason, this call reads only raw memory.
 59   const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;
 60   make_runtime_call(RC_LEAF | RC_NARROW_MEM,
 61                     call_type, call_address,
 62                     call_name, raw_adr_type,
 63                     thread, method_node);
 64 }
 65 
 66 
 67 //=============================================================================
 68 //------------------------------do_checkcast-----------------------------------
 69 void Parse::do_checkcast() {
 70   bool will_link;
 71   ciKlass* klass = iter().get_klass(will_link);


 72   Node *obj = peek();
 73 
 74   // Throw uncommon trap if class is not loaded or the value we are casting
 75   // _from_ is not loaded, and value is not null.  If the value _is_ NULL,
 76   // then the checkcast does nothing.
 77   const TypeOopPtr *tp = _gvn.type(obj)-&gt;isa_oopptr();
 78   if (!will_link || (tp &amp;&amp; tp-&gt;klass() &amp;&amp; !tp-&gt;klass()-&gt;is_loaded())) {
<span class="line-modified"> 79     assert(!iter().is_inline_klass(), &quot;Inline type should be loaded&quot;);</span>
 80     if (C-&gt;log() != NULL) {
 81       if (!will_link) {
 82         C-&gt;log()-&gt;elem(&quot;assert_null reason=&#39;checkcast&#39; klass=&#39;%d&#39;&quot;,
 83                        C-&gt;log()-&gt;identify(klass));
 84       }
 85       if (tp &amp;&amp; tp-&gt;klass() &amp;&amp; !tp-&gt;klass()-&gt;is_loaded()) {
 86         // %%% Cannot happen?
 87         C-&gt;log()-&gt;elem(&quot;assert_null reason=&#39;checkcast source&#39; klass=&#39;%d&#39;&quot;,
 88                        C-&gt;log()-&gt;identify(tp-&gt;klass()));
 89       }
 90     }
 91     null_assert(obj);
 92     assert( stopped() || _gvn.type(peek())-&gt;higher_equal(TypePtr::NULL_PTR), &quot;what&#39;s left behind is null&quot; );
 93     if (!stopped()) {
 94       profile_null_checkcast();
 95     }
 96     return;
 97   }
 98 
<span class="line-modified"> 99   Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass)));</span>
100   if (stopped()) {
101     return;
102   }
103 
104   // Pop from stack AFTER gen_checkcast because it can uncommon trap and
105   // the debug info has to be correct.
106   pop();
107   push(res);
108 }
109 
110 
111 //------------------------------do_instanceof----------------------------------
112 void Parse::do_instanceof() {
113   if (stopped())  return;
114   // We would like to return false if class is not loaded, emitting a
115   // dependency, but Java requires instanceof to load its operand.
116 
117   // Throw uncommon trap if class is not loaded
118   bool will_link;
119   ciKlass* klass = iter().get_klass(will_link);
</pre>
<hr />
<pre>
338 
339   ValueTypeNode* vt = ValueTypeNode::make_default(_gvn, vk);
340   if (vk-&gt;is_scalarizable()) {
341     push(vt);
342   } else {
343     push(vt-&gt;get_oop());
344   }
345 }
346 
347 //------------------------------do_withfield------------------------------------
348 void Parse::do_withfield() {
349   bool will_link;
350   ciField* field = iter().get_field(will_link);
351   assert(will_link, &quot;withfield: typeflow responsibility&quot;);
352   Node* val = pop_node(field-&gt;layout_type());
353   ciValueKlass* holder_klass = field-&gt;holder()-&gt;as_value_klass();
354   Node* holder = pop();
355   int nargs = 1 + field-&gt;type()-&gt;size();
356 
357   if (!holder-&gt;is_ValueType()) {
<span class="line-modified">358     // Scalarize value type holder</span>
<span class="line-modified">359     assert(!gvn().type(holder)-&gt;maybe_null(), &quot;Inline types are null-free&quot;);</span>



360     holder = ValueTypeNode::make_from_oop(this, holder, holder_klass);
361   }
<span class="line-modified">362   if (!val-&gt;is_ValueType() &amp;&amp; field-&gt;type()-&gt;is_valuetype()) {</span>
<span class="line-modified">363     // Scalarize value type field value</span>
<span class="line-modified">364     assert(!gvn().type(holder)-&gt;maybe_null(), &quot;Inline types are null-free&quot;);</span>



365     val = ValueTypeNode::make_from_oop(this, val, gvn().type(val)-&gt;value_klass());
<span class="line-modified">366   } else if (val-&gt;is_ValueType() &amp;&amp; !field-&gt;type()-&gt;is_valuetype()) {</span>
<span class="line-modified">367     // Field value needs to be allocated because it can be merged with an oop.</span>
<span class="line-modified">368     // Re-execute withfield if buffering triggers deoptimization.</span>
369     PreserveReexecuteState preexecs(this);
370     jvms()-&gt;set_should_reexecute(true);
371     inc_sp(nargs);
372     val = val-&gt;as_ValueType()-&gt;buffer(this);
373   }
374 
375   // Clone the value type node and set the new field value
376   ValueTypeNode* new_vt = holder-&gt;clone()-&gt;as_ValueType();
377   new_vt-&gt;set_oop(_gvn.zerocon(T_INLINE_TYPE));
378   gvn().set_type(new_vt, new_vt-&gt;bottom_type());
379   new_vt-&gt;set_field_value_by_offset(field-&gt;offset(), val);
380   Node* res = new_vt;
381 
382   if (!holder_klass-&gt;is_scalarizable()) {
383     // Re-execute withfield if buffering triggers deoptimization
384     PreserveReexecuteState preexecs(this);
385     jvms()-&gt;set_should_reexecute(true);
386     inc_sp(nargs);
387     res = new_vt-&gt;buffer(this)-&gt;get_oop();
388   }
</pre>
</td>
</tr>
</table>
<center><a href="parse3.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
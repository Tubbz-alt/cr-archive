<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/ci/ciTypeFlow.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciConstant.hpp&quot;
  27 #include &quot;ci/ciField.hpp&quot;
  28 #include &quot;ci/ciMethod.hpp&quot;
  29 #include &quot;ci/ciMethodData.hpp&quot;
  30 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  31 #include &quot;ci/ciStreams.hpp&quot;
  32 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  33 #include &quot;ci/ciTypeFlow.hpp&quot;
  34 #include &quot;ci/ciValueKlass.hpp&quot;
  35 #include &quot;compiler/compileLog.hpp&quot;
  36 #include &quot;interpreter/bytecode.hpp&quot;
  37 #include &quot;interpreter/bytecodes.hpp&quot;
  38 #include &quot;memory/allocation.inline.hpp&quot;
  39 #include &quot;memory/resourceArea.hpp&quot;
  40 #include &quot;oops/oop.inline.hpp&quot;
  41 #include &quot;opto/compile.hpp&quot;
  42 #include &quot;opto/node.hpp&quot;
  43 #include &quot;runtime/deoptimization.hpp&quot;
  44 #include &quot;utilities/growableArray.hpp&quot;
  45 
  46 // ciTypeFlow::JsrSet
  47 //
  48 // A JsrSet represents some set of JsrRecords.  This class
  49 // is used to record a set of all jsr routines which we permit
  50 // execution to return (ret) from.
  51 //
  52 // During abstract interpretation, JsrSets are used to determine
  53 // whether two paths which reach a given block are unique, and
  54 // should be cloned apart, or are compatible, and should merge
  55 // together.
  56 
  57 // ------------------------------------------------------------------
  58 // ciTypeFlow::JsrSet::JsrSet
  59 ciTypeFlow::JsrSet::JsrSet(Arena* arena, int default_len) {
  60   if (arena != NULL) {
  61     // Allocate growable array in Arena.
  62     _set = new (arena) GrowableArray&lt;JsrRecord*&gt;(arena, default_len, 0, NULL);
  63   } else {
  64     // Allocate growable array in current ResourceArea.
  65     _set = new GrowableArray&lt;JsrRecord*&gt;(4, 0, NULL);
  66   }
  67 }
  68 
  69 // ------------------------------------------------------------------
  70 // ciTypeFlow::JsrSet::copy_into
  71 void ciTypeFlow::JsrSet::copy_into(JsrSet* jsrs) {
  72   int len = size();
  73   jsrs-&gt;_set-&gt;clear();
  74   for (int i = 0; i &lt; len; i++) {
  75     jsrs-&gt;_set-&gt;append(_set-&gt;at(i));
  76   }
  77 }
  78 
  79 // ------------------------------------------------------------------
  80 // ciTypeFlow::JsrSet::is_compatible_with
  81 //
  82 // !!!! MISGIVINGS ABOUT THIS... disregard
  83 //
  84 // Is this JsrSet compatible with some other JsrSet?
  85 //
  86 // In set-theoretic terms, a JsrSet can be viewed as a partial function
  87 // from entry addresses to return addresses.  Two JsrSets A and B are
  88 // compatible iff
  89 //
  90 //   For any x,
  91 //   A(x) defined and B(x) defined implies A(x) == B(x)
  92 //
  93 // Less formally, two JsrSets are compatible when they have identical
  94 // return addresses for any entry addresses they share in common.
  95 bool ciTypeFlow::JsrSet::is_compatible_with(JsrSet* other) {
  96   // Walk through both sets in parallel.  If the same entry address
  97   // appears in both sets, then the return address must match for
  98   // the sets to be compatible.
  99   int size1 = size();
 100   int size2 = other-&gt;size();
 101 
 102   // Special case.  If nothing is on the jsr stack, then there can
 103   // be no ret.
 104   if (size2 == 0) {
 105     return true;
 106   } else if (size1 != size2) {
 107     return false;
 108   } else {
 109     for (int i = 0; i &lt; size1; i++) {
 110       JsrRecord* record1 = record_at(i);
 111       JsrRecord* record2 = other-&gt;record_at(i);
 112       if (record1-&gt;entry_address() != record2-&gt;entry_address() ||
 113           record1-&gt;return_address() != record2-&gt;return_address()) {
 114         return false;
 115       }
 116     }
 117     return true;
 118   }
 119 
 120 #if 0
 121   int pos1 = 0;
 122   int pos2 = 0;
 123   int size1 = size();
 124   int size2 = other-&gt;size();
 125   while (pos1 &lt; size1 &amp;&amp; pos2 &lt; size2) {
 126     JsrRecord* record1 = record_at(pos1);
 127     JsrRecord* record2 = other-&gt;record_at(pos2);
 128     int entry1 = record1-&gt;entry_address();
 129     int entry2 = record2-&gt;entry_address();
 130     if (entry1 &lt; entry2) {
 131       pos1++;
 132     } else if (entry1 &gt; entry2) {
 133       pos2++;
 134     } else {
 135       if (record1-&gt;return_address() == record2-&gt;return_address()) {
 136         pos1++;
 137         pos2++;
 138       } else {
 139         // These two JsrSets are incompatible.
 140         return false;
 141       }
 142     }
 143   }
 144   // The two JsrSets agree.
 145   return true;
 146 #endif
 147 }
 148 
 149 // ------------------------------------------------------------------
 150 // ciTypeFlow::JsrSet::insert_jsr_record
 151 //
 152 // Insert the given JsrRecord into the JsrSet, maintaining the order
 153 // of the set and replacing any element with the same entry address.
 154 void ciTypeFlow::JsrSet::insert_jsr_record(JsrRecord* record) {
 155   int len = size();
 156   int entry = record-&gt;entry_address();
 157   int pos = 0;
 158   for ( ; pos &lt; len; pos++) {
 159     JsrRecord* current = record_at(pos);
 160     if (entry == current-&gt;entry_address()) {
 161       // Stomp over this entry.
 162       _set-&gt;at_put(pos, record);
 163       assert(size() == len, &quot;must be same size&quot;);
 164       return;
 165     } else if (entry &lt; current-&gt;entry_address()) {
 166       break;
 167     }
 168   }
 169 
 170   // Insert the record into the list.
 171   JsrRecord* swap = record;
 172   JsrRecord* temp = NULL;
 173   for ( ; pos &lt; len; pos++) {
 174     temp = _set-&gt;at(pos);
 175     _set-&gt;at_put(pos, swap);
 176     swap = temp;
 177   }
 178   _set-&gt;append(swap);
 179   assert(size() == len+1, &quot;must be larger&quot;);
 180 }
 181 
 182 // ------------------------------------------------------------------
 183 // ciTypeFlow::JsrSet::remove_jsr_record
 184 //
 185 // Remove the JsrRecord with the given return address from the JsrSet.
 186 void ciTypeFlow::JsrSet::remove_jsr_record(int return_address) {
 187   int len = size();
 188   for (int i = 0; i &lt; len; i++) {
 189     if (record_at(i)-&gt;return_address() == return_address) {
 190       // We have found the proper entry.  Remove it from the
 191       // JsrSet and exit.
 192       for (int j = i+1; j &lt; len ; j++) {
 193         _set-&gt;at_put(j-1, _set-&gt;at(j));
 194       }
 195       _set-&gt;trunc_to(len-1);
 196       assert(size() == len-1, &quot;must be smaller&quot;);
 197       return;
 198     }
 199   }
 200   assert(false, &quot;verify: returning from invalid subroutine&quot;);
 201 }
 202 
 203 // ------------------------------------------------------------------
 204 // ciTypeFlow::JsrSet::apply_control
 205 //
 206 // Apply the effect of a control-flow bytecode on the JsrSet.  The
 207 // only bytecodes that modify the JsrSet are jsr and ret.
 208 void ciTypeFlow::JsrSet::apply_control(ciTypeFlow* analyzer,
 209                                        ciBytecodeStream* str,
 210                                        ciTypeFlow::StateVector* state) {
 211   Bytecodes::Code code = str-&gt;cur_bc();
 212   if (code == Bytecodes::_jsr) {
 213     JsrRecord* record =
 214       analyzer-&gt;make_jsr_record(str-&gt;get_dest(), str-&gt;next_bci());
 215     insert_jsr_record(record);
 216   } else if (code == Bytecodes::_jsr_w) {
 217     JsrRecord* record =
 218       analyzer-&gt;make_jsr_record(str-&gt;get_far_dest(), str-&gt;next_bci());
 219     insert_jsr_record(record);
 220   } else if (code == Bytecodes::_ret) {
 221     Cell local = state-&gt;local(str-&gt;get_index());
 222     ciType* return_address = state-&gt;type_at(local);
 223     assert(return_address-&gt;is_return_address(), &quot;verify: wrong type&quot;);
 224     if (size() == 0) {
 225       // Ret-state underflow:  Hit a ret w/o any previous jsrs.  Bail out.
 226       // This can happen when a loop is inside a finally clause (4614060).
 227       analyzer-&gt;record_failure(&quot;OSR in finally clause&quot;);
 228       return;
 229     }
 230     remove_jsr_record(return_address-&gt;as_return_address()-&gt;bci());
 231   }
 232 }
 233 
 234 #ifndef PRODUCT
 235 // ------------------------------------------------------------------
 236 // ciTypeFlow::JsrSet::print_on
 237 void ciTypeFlow::JsrSet::print_on(outputStream* st) const {
 238   st-&gt;print(&quot;{ &quot;);
 239   int num_elements = size();
 240   if (num_elements &gt; 0) {
 241     int i = 0;
 242     for( ; i &lt; num_elements - 1; i++) {
 243       _set-&gt;at(i)-&gt;print_on(st);
 244       st-&gt;print(&quot;, &quot;);
 245     }
 246     _set-&gt;at(i)-&gt;print_on(st);
 247     st-&gt;print(&quot; &quot;);
 248   }
 249   st-&gt;print(&quot;}&quot;);
 250 }
 251 #endif
 252 
 253 // ciTypeFlow::StateVector
 254 //
 255 // A StateVector summarizes the type information at some point in
 256 // the program.
 257 
 258 // ------------------------------------------------------------------
 259 // ciTypeFlow::StateVector::type_meet
 260 //
 261 // Meet two types.
 262 //
 263 // The semi-lattice of types use by this analysis are modeled on those
 264 // of the verifier.  The lattice is as follows:
 265 //
 266 //        top_type() &gt;= all non-extremal types &gt;= bottom_type
 267 //                             and
 268 //   Every primitive type is comparable only with itself.  The meet of
 269 //   reference types is determined by their kind: instance class,
 270 //   interface, or array class.  The meet of two types of the same
 271 //   kind is their least common ancestor.  The meet of two types of
 272 //   different kinds is always java.lang.Object.
 273 ciType* ciTypeFlow::StateVector::type_meet_internal(ciType* t1, ciType* t2, ciTypeFlow* analyzer) {
 274   assert(t1 != t2, &quot;checked in caller&quot;);
 275   if (t1-&gt;equals(top_type())) {
 276     return t2;
 277   } else if (t2-&gt;equals(top_type())) {
 278     return t1;
<a name="1" id="anc1"></a><span class="line-modified"> 279   }</span>
<span class="line-removed"> 280 </span>
<span class="line-removed"> 281   // Unwrap after saving nullness information and handling top meets</span>
<span class="line-removed"> 282   bool never_null1 = t1-&gt;is_never_null();</span>
<span class="line-removed"> 283   bool never_null2 = t2-&gt;is_never_null();</span>
<span class="line-removed"> 284   if (t1-&gt;unwrap() == t2-&gt;unwrap() &amp;&amp; never_null1 == never_null2) {</span>
<span class="line-removed"> 285     return t1;</span>
<span class="line-removed"> 286   }</span>
<span class="line-removed"> 287   t1 = t1-&gt;unwrap();</span>
<span class="line-removed"> 288   t2 = t2-&gt;unwrap();</span>
<span class="line-removed"> 289 </span>
<span class="line-removed"> 290   if (t1-&gt;is_primitive_type() || t2-&gt;is_primitive_type()) {</span>
 291     // Special case null_type.  null_type meet any reference type T
<a name="2" id="anc2"></a><span class="line-modified"> 292     // is T.  null_type meet null_type is null_type.</span>
 293     if (t1-&gt;equals(null_type())) {
<a name="3" id="anc3"></a><span class="line-modified"> 294       if (!t2-&gt;is_primitive_type() || t2-&gt;equals(null_type())) {</span>



 295         return t2;
 296       }
 297     } else if (t2-&gt;equals(null_type())) {
<a name="4" id="anc4"></a><span class="line-modified"> 298       if (!t1-&gt;is_primitive_type()) {</span>



 299         return t1;
 300       }
 301     }
 302 
 303     // At least one of the two types is a non-top primitive type.
 304     // The other type is not equal to it.  Fall to bottom.
 305     return bottom_type();
 306   }
 307 
 308   // Both types are non-top non-primitive types.  That is,
 309   // both types are either instanceKlasses or arrayKlasses.
 310   ciKlass* object_klass = analyzer-&gt;env()-&gt;Object_klass();
 311   ciKlass* k1 = t1-&gt;as_klass();
 312   ciKlass* k2 = t2-&gt;as_klass();
 313   if (k1-&gt;equals(object_klass) || k2-&gt;equals(object_klass)) {
 314     return object_klass;
 315   } else if (!k1-&gt;is_loaded() || !k2-&gt;is_loaded()) {
 316     // Unloaded classes fall to java.lang.Object at a merge.
 317     return object_klass;
 318   } else if (k1-&gt;is_interface() != k2-&gt;is_interface()) {
 319     // When an interface meets a non-interface, we get Object;
 320     // This is what the verifier does.
 321     return object_klass;
 322   } else if (k1-&gt;is_array_klass() || k2-&gt;is_array_klass()) {
 323     // When an array meets a non-array, we get Object.
 324     // When (obj/value)Array meets typeArray, we also get Object.
 325     // And when typeArray meets different typeArray, we again get Object.
 326     // But when (obj/value)Array meets (obj/value)Array, we look carefully at element types.
 327     if ((k1-&gt;is_obj_array_klass() || k1-&gt;is_value_array_klass()) &amp;&amp;
 328         (k2-&gt;is_obj_array_klass() || k2-&gt;is_value_array_klass())) {
 329       ciType* elem1 = k1-&gt;as_array_klass()-&gt;element_klass();
 330       ciType* elem2 = k2-&gt;as_array_klass()-&gt;element_klass();
 331       ciType* elem = elem1;
 332       if (elem1 != elem2) {
 333         elem = type_meet_internal(elem1, elem2, analyzer)-&gt;as_klass();
 334       }
 335       // Do an easy shortcut if one type is a super of the other.
 336       if (elem == elem1) {
 337         assert(k1 == ciArrayKlass::make(elem), &quot;shortcut is OK&quot;);
 338         return k1;
 339       } else if (elem == elem2) {
 340         assert(k2 == ciArrayKlass::make(elem), &quot;shortcut is OK&quot;);
 341         return k2;
 342       } else {
 343         return ciArrayKlass::make(elem);
 344       }
 345     } else {
 346       return object_klass;
 347     }
 348   } else {
 349     // Must be two plain old instance klasses.
 350     assert(k1-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);
 351     assert(k2-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);
<a name="5" id="anc5"></a><span class="line-modified"> 352     ciType* result = k1-&gt;least_common_ancestor(k2);</span>
<span class="line-removed"> 353     if (never_null1 &amp;&amp; never_null2 &amp;&amp; result-&gt;is_valuetype()) {</span>
<span class="line-removed"> 354       // Both value types are never null, mark the result as never null</span>
<span class="line-removed"> 355       result = analyzer-&gt;mark_as_never_null(result);</span>
<span class="line-removed"> 356     }</span>
<span class="line-removed"> 357     return result;</span>
 358   }
 359 }
 360 
 361 
 362 // ------------------------------------------------------------------
 363 // ciTypeFlow::StateVector::StateVector
 364 //
 365 // Build a new state vector
 366 ciTypeFlow::StateVector::StateVector(ciTypeFlow* analyzer) {
 367   _outer = analyzer;
 368   _stack_size = -1;
 369   _monitor_count = -1;
 370   // Allocate the _types array
 371   int max_cells = analyzer-&gt;max_cells();
 372   _types = (ciType**)analyzer-&gt;arena()-&gt;Amalloc(sizeof(ciType*) * max_cells);
 373   for (int i=0; i&lt;max_cells; i++) {
 374     _types[i] = top_type();
 375   }
 376   _trap_bci = -1;
 377   _trap_index = 0;
 378   _def_locals.clear();
 379 }
 380 
 381 
 382 // ------------------------------------------------------------------
 383 // ciTypeFlow::get_start_state
 384 //
 385 // Set this vector to the method entry state.
 386 const ciTypeFlow::StateVector* ciTypeFlow::get_start_state() {
 387   StateVector* state = new StateVector(this);
 388   if (is_osr_flow()) {
 389     ciTypeFlow* non_osr_flow = method()-&gt;get_flow_analysis();
 390     if (non_osr_flow-&gt;failing()) {
 391       record_failure(non_osr_flow-&gt;failure_reason());
 392       return NULL;
 393     }
 394     JsrSet* jsrs = new JsrSet(NULL, 16);
 395     Block* non_osr_block = non_osr_flow-&gt;existing_block_at(start_bci(), jsrs);
 396     if (non_osr_block == NULL) {
 397       record_failure(&quot;cannot reach OSR point&quot;);
 398       return NULL;
 399     }
 400     // load up the non-OSR state at this point
 401     non_osr_block-&gt;copy_state_into(state);
 402     int non_osr_start = non_osr_block-&gt;start();
 403     if (non_osr_start != start_bci()) {
 404       // must flow forward from it
 405       if (CITraceTypeFlow) {
 406         tty-&gt;print_cr(&quot;&gt;&gt; Interpreting pre-OSR block %d:&quot;, non_osr_start);
 407       }
 408       Block* block = block_at(non_osr_start, jsrs);
 409       assert(block-&gt;limit() == start_bci(), &quot;must flow forward to start&quot;);
 410       flow_block(block, state, jsrs);
 411     }
 412     return state;
 413     // Note:  The code below would be an incorrect for an OSR flow,
 414     // even if it were possible for an OSR entry point to be at bci zero.
 415   }
 416   // &quot;Push&quot; the method signature into the first few locals.
 417   state-&gt;set_stack_size(-max_locals());
 418   if (!method()-&gt;is_static()) {
<a name="6" id="anc6"></a><span class="line-modified"> 419     ciType* holder = method()-&gt;holder();</span>
<span class="line-removed"> 420     if (holder-&gt;is_valuetype()) {</span>
<span class="line-removed"> 421       // The receiver is never null</span>
<span class="line-removed"> 422       holder = mark_as_never_null(holder);</span>
<span class="line-removed"> 423     }</span>
<span class="line-removed"> 424     state-&gt;push(holder);</span>
 425     assert(state-&gt;tos() == state-&gt;local(0), &quot;&quot;);
 426   }
 427   for (ciSignatureStream str(method()-&gt;signature());
 428        !str.at_return_type();
 429        str.next()) {
<a name="7" id="anc7"></a><span class="line-modified"> 430     ciType* arg = str.type();</span>
<span class="line-removed"> 431     if (str.is_never_null()) {</span>
<span class="line-removed"> 432       arg = mark_as_never_null(arg);</span>
<span class="line-removed"> 433     }</span>
<span class="line-removed"> 434     state-&gt;push_translate(arg);</span>
 435   }
 436   // Set the rest of the locals to bottom.
 437   Cell cell = state-&gt;next_cell(state-&gt;tos());
 438   state-&gt;set_stack_size(0);
 439   int limit = state-&gt;limit_cell();
 440   for (; cell &lt; limit; cell = state-&gt;next_cell(cell)) {
 441     state-&gt;set_type_at(cell, state-&gt;bottom_type());
 442   }
 443   // Lock an object, if necessary.
 444   state-&gt;set_monitor_count(method()-&gt;is_synchronized() ? 1 : 0);
 445   return state;
 446 }
 447 
 448 // ------------------------------------------------------------------
 449 // ciTypeFlow::StateVector::copy_into
 450 //
 451 // Copy our value into some other StateVector
 452 void ciTypeFlow::StateVector::copy_into(ciTypeFlow::StateVector* copy)
 453 const {
 454   copy-&gt;set_stack_size(stack_size());
 455   copy-&gt;set_monitor_count(monitor_count());
 456   Cell limit = limit_cell();
 457   for (Cell c = start_cell(); c &lt; limit; c = next_cell(c)) {
 458     copy-&gt;set_type_at(c, type_at(c));
 459   }
 460 }
 461 
 462 // ------------------------------------------------------------------
 463 // ciTypeFlow::StateVector::meet
 464 //
 465 // Meets this StateVector with another, destructively modifying this
 466 // one.  Returns true if any modification takes place.
 467 bool ciTypeFlow::StateVector::meet(const ciTypeFlow::StateVector* incoming) {
 468   if (monitor_count() == -1) {
 469     set_monitor_count(incoming-&gt;monitor_count());
 470   }
 471   assert(monitor_count() == incoming-&gt;monitor_count(), &quot;monitors must match&quot;);
 472 
 473   if (stack_size() == -1) {
 474     set_stack_size(incoming-&gt;stack_size());
 475     Cell limit = limit_cell();
 476     #ifdef ASSERT
 477     { for (Cell c = start_cell(); c &lt; limit; c = next_cell(c)) {
 478         assert(type_at(c) == top_type(), &quot;&quot;);
 479     } }
 480     #endif
 481     // Make a simple copy of the incoming state.
 482     for (Cell c = start_cell(); c &lt; limit; c = next_cell(c)) {
 483       set_type_at(c, incoming-&gt;type_at(c));
 484     }
 485     return true;  // it is always different the first time
 486   }
 487 #ifdef ASSERT
 488   if (stack_size() != incoming-&gt;stack_size()) {
 489     _outer-&gt;method()-&gt;print_codes();
 490     tty-&gt;print_cr(&quot;!!!! Stack size conflict&quot;);
 491     tty-&gt;print_cr(&quot;Current state:&quot;);
 492     print_on(tty);
 493     tty-&gt;print_cr(&quot;Incoming state:&quot;);
 494     ((StateVector*)incoming)-&gt;print_on(tty);
 495   }
 496 #endif
 497   assert(stack_size() == incoming-&gt;stack_size(), &quot;sanity&quot;);
 498 
 499   bool different = false;
 500   Cell limit = limit_cell();
 501   for (Cell c = start_cell(); c &lt; limit; c = next_cell(c)) {
 502     ciType* t1 = type_at(c);
 503     ciType* t2 = incoming-&gt;type_at(c);
 504     if (!t1-&gt;equals(t2)) {
 505       ciType* new_type = type_meet(t1, t2);
 506       if (!t1-&gt;equals(new_type)) {
 507         set_type_at(c, new_type);
 508         different = true;
 509       }
 510     }
 511   }
 512   return different;
 513 }
 514 
 515 // ------------------------------------------------------------------
 516 // ciTypeFlow::StateVector::meet_exception
 517 //
 518 // Meets this StateVector with another, destructively modifying this
 519 // one.  The incoming state is coming via an exception.  Returns true
 520 // if any modification takes place.
 521 bool ciTypeFlow::StateVector::meet_exception(ciInstanceKlass* exc,
 522                                      const ciTypeFlow::StateVector* incoming) {
 523   if (monitor_count() == -1) {
 524     set_monitor_count(incoming-&gt;monitor_count());
 525   }
 526   assert(monitor_count() == incoming-&gt;monitor_count(), &quot;monitors must match&quot;);
 527 
 528   if (stack_size() == -1) {
 529     set_stack_size(1);
 530   }
 531 
 532   assert(stack_size() ==  1, &quot;must have one-element stack&quot;);
 533 
 534   bool different = false;
 535 
 536   // Meet locals from incoming array.
 537   Cell limit = local(_outer-&gt;max_locals()-1);
 538   for (Cell c = start_cell(); c &lt;= limit; c = next_cell(c)) {
 539     ciType* t1 = type_at(c);
 540     ciType* t2 = incoming-&gt;type_at(c);
 541     if (!t1-&gt;equals(t2)) {
 542       ciType* new_type = type_meet(t1, t2);
 543       if (!t1-&gt;equals(new_type)) {
 544         set_type_at(c, new_type);
 545         different = true;
 546       }
 547     }
 548   }
 549 
 550   // Handle stack separately.  When an exception occurs, the
 551   // only stack entry is the exception instance.
 552   ciType* tos_type = type_at_tos();
 553   if (!tos_type-&gt;equals(exc)) {
 554     ciType* new_type = type_meet(tos_type, exc);
 555     if (!tos_type-&gt;equals(new_type)) {
 556       set_type_at_tos(new_type);
 557       different = true;
 558     }
 559   }
 560 
 561   return different;
 562 }
 563 
 564 // ------------------------------------------------------------------
 565 // ciTypeFlow::StateVector::push_translate
 566 void ciTypeFlow::StateVector::push_translate(ciType* type) {
 567   BasicType basic_type = type-&gt;basic_type();
 568   if (basic_type == T_BOOLEAN || basic_type == T_CHAR ||
 569       basic_type == T_BYTE    || basic_type == T_SHORT) {
 570     push_int();
 571   } else {
 572     push(type);
 573     if (type-&gt;is_two_word()) {
 574       push(half_type(type));
 575     }
 576   }
 577 }
 578 
 579 // ------------------------------------------------------------------
 580 // ciTypeFlow::StateVector::do_aload
 581 void ciTypeFlow::StateVector::do_aload(ciBytecodeStream* str) {
 582   pop_int();
 583   ciArrayKlass* array_klass = pop_objOrValueArray();
 584   if (array_klass == NULL) {
 585     // Did aload on a null reference; push a null and ignore the exception.
 586     // This instruction will never continue normally.  All we have to do
 587     // is report a value that will meet correctly with any downstream
 588     // reference types on paths that will truly be executed.  This null type
 589     // meets with any reference type to yield that same reference type.
 590     // (The compiler will generate an unconditional exception here.)
 591     push(null_type());
 592     return;
 593   }
 594   if (!array_klass-&gt;is_loaded()) {
 595     // Only fails for some -Xcomp runs
 596     trap(str, array_klass,
 597          Deoptimization::make_trap_request
 598          (Deoptimization::Reason_unloaded,
 599           Deoptimization::Action_reinterpret));
 600     return;
 601   }
 602   ciKlass* element_klass = array_klass-&gt;element_klass();
 603   if (!element_klass-&gt;is_loaded() &amp;&amp; element_klass-&gt;is_instance_klass()) {
 604     Untested(&quot;unloaded array element class in ciTypeFlow&quot;);
 605     trap(str, element_klass,
 606          Deoptimization::make_trap_request
 607          (Deoptimization::Reason_unloaded,
 608           Deoptimization::Action_reinterpret));
 609   } else {
<a name="8" id="anc8"></a><span class="line-modified"> 610     if (element_klass-&gt;is_valuetype()) {</span>
<span class="line-removed"> 611       // Value type array elements are never null</span>
<span class="line-removed"> 612       push(outer()-&gt;mark_as_never_null(element_klass));</span>
<span class="line-removed"> 613     } else {</span>
<span class="line-removed"> 614       push_object(element_klass);</span>
<span class="line-removed"> 615     }</span>
 616   }
 617 }
 618 
 619 
 620 // ------------------------------------------------------------------
 621 // ciTypeFlow::StateVector::do_checkcast
 622 void ciTypeFlow::StateVector::do_checkcast(ciBytecodeStream* str) {
 623   bool will_link;
 624   ciKlass* klass = str-&gt;get_klass(will_link);
<a name="9" id="anc9"></a><span class="line-removed"> 625   bool never_null = str-&gt;is_klass_never_null();</span>
 626   if (!will_link) {
<a name="10" id="anc10"></a><span class="line-modified"> 627     if (never_null) {</span>
 628       trap(str, klass,
 629            Deoptimization::make_trap_request
 630            (Deoptimization::Reason_unloaded,
 631             Deoptimization::Action_reinterpret));
 632     } else {
 633       // VM&#39;s interpreter will not load &#39;klass&#39; if object is NULL.
 634       // Type flow after this block may still be needed in two situations:
 635       // 1) C2 uses do_null_assert() and continues compilation for later blocks
 636       // 2) C2 does an OSR compile in a later block (see bug 4778368).
 637       pop_object();
 638       do_null_assert(klass);
 639     }
 640   } else {
<a name="11" id="anc11"></a><span class="line-modified"> 641     ciType* type = pop_value();</span>
<span class="line-modified"> 642     if (klass-&gt;is_valuetype() &amp;&amp; (never_null || type-&gt;is_never_null())) {</span>
<span class="line-removed"> 643       // Casting to a Q-Type contains a NULL check</span>
<span class="line-removed"> 644       push(outer()-&gt;mark_as_never_null(klass));</span>
<span class="line-removed"> 645     } else {</span>
<span class="line-removed"> 646       push_object(klass);</span>
<span class="line-removed"> 647     }</span>
 648   }
 649 }
 650 
 651 // ------------------------------------------------------------------
 652 // ciTypeFlow::StateVector::do_getfield
 653 void ciTypeFlow::StateVector::do_getfield(ciBytecodeStream* str) {
 654   // could add assert here for type of object.
 655   pop_object();
 656   do_getstatic(str);
 657 }
 658 
 659 // ------------------------------------------------------------------
 660 // ciTypeFlow::StateVector::do_getstatic
 661 void ciTypeFlow::StateVector::do_getstatic(ciBytecodeStream* str) {
 662   bool will_link;
 663   ciField* field = str-&gt;get_field(will_link);
 664   if (!will_link) {
 665     trap(str, field-&gt;holder(), str-&gt;get_field_holder_index());
 666   } else {
 667     ciType* field_type = field-&gt;type();
 668     if (!field_type-&gt;is_loaded()) {
 669       // Normally, we need the field&#39;s type to be loaded if we are to
 670       // do anything interesting with its value.
 671       // We used to do this:  trap(str, str-&gt;get_field_signature_index());
 672       //
 673       // There is one good reason not to trap here.  Execution can
 674       // get past this &quot;getfield&quot; or &quot;getstatic&quot; if the value of
 675       // the field is null.  As long as the value is null, the class
 676       // does not need to be loaded!  The compiler must assume that
 677       // the value of the unloaded class reference is null; if the code
 678       // ever sees a non-null value, loading has occurred.
 679       //
 680       // This actually happens often enough to be annoying.  If the
 681       // compiler throws an uncommon trap at this bytecode, you can
 682       // get an endless loop of recompilations, when all the code
 683       // needs to do is load a series of null values.  Also, a trap
 684       // here can make an OSR entry point unreachable, triggering the
 685       // assert on non_osr_block in ciTypeFlow::get_start_state.
 686       // (See bug 4379915.)
 687       do_null_assert(field_type-&gt;as_klass());
 688     } else {
<a name="12" id="anc12"></a><span class="line-removed"> 689       if (field-&gt;is_flattenable()) {</span>
<span class="line-removed"> 690         // A flattenable field is never null</span>
<span class="line-removed"> 691         field_type = outer()-&gt;mark_as_never_null(field_type);</span>
<span class="line-removed"> 692       }</span>
 693       push_translate(field_type);
 694     }
 695   }
 696 }
 697 
 698 // ------------------------------------------------------------------
 699 // ciTypeFlow::StateVector::do_invoke
 700 void ciTypeFlow::StateVector::do_invoke(ciBytecodeStream* str,
 701                                         bool has_receiver) {
 702   bool will_link;
 703   ciSignature* declared_signature = NULL;
 704   ciMethod* callee = str-&gt;get_method(will_link, &amp;declared_signature);
 705   assert(declared_signature != NULL, &quot;cannot be null&quot;);
 706   if (!will_link) {
 707     // We weren&#39;t able to find the method.
 708     if (str-&gt;cur_bc() == Bytecodes::_invokedynamic) {
 709       trap(str, NULL,
 710            Deoptimization::make_trap_request
 711            (Deoptimization::Reason_uninitialized,
 712             Deoptimization::Action_reinterpret));
 713     } else {
 714       ciKlass* unloaded_holder = callee-&gt;holder();
 715       trap(str, unloaded_holder, str-&gt;get_method_holder_index());
 716     }
 717   } else {
 718     // We are using the declared signature here because it might be
 719     // different from the callee signature (Cf. invokedynamic and
 720     // invokehandle).
 721     ciSignatureStream sigstr(declared_signature);
 722     const int arg_size = declared_signature-&gt;size();
 723     const int stack_base = stack_size() - arg_size;
 724     int i = 0;
 725     for( ; !sigstr.at_return_type(); sigstr.next()) {
 726       ciType* type = sigstr.type();
 727       ciType* stack_type = type_at(stack(stack_base + i++));
 728       // Do I want to check this type?
 729       // assert(stack_type-&gt;is_subtype_of(type), &quot;bad type for field value&quot;);
 730       if (type-&gt;is_two_word()) {
 731         ciType* stack_type2 = type_at(stack(stack_base + i++));
 732         assert(stack_type2-&gt;equals(half_type(type)), &quot;must be 2nd half&quot;);
 733       }
 734     }
 735     assert(arg_size == i, &quot;must match&quot;);
 736     for (int j = 0; j &lt; arg_size; j++) {
 737       pop();
 738     }
 739     if (has_receiver) {
 740       // Check this?
 741       pop_object();
 742     }
 743     assert(!sigstr.is_done(), &quot;must have return type&quot;);
 744     ciType* return_type = sigstr.type();
 745     if (!return_type-&gt;is_void()) {
 746       if (!return_type-&gt;is_loaded()) {
 747         // As in do_getstatic(), generally speaking, we need the return type to
 748         // be loaded if we are to do anything interesting with its value.
 749         // We used to do this:  trap(str, str-&gt;get_method_signature_index());
 750         //
 751         // We do not trap here since execution can get past this invoke if
 752         // the return value is null.  As long as the value is null, the class
 753         // does not need to be loaded!  The compiler must assume that
 754         // the value of the unloaded class reference is null; if the code
 755         // ever sees a non-null value, loading has occurred.
 756         //
 757         // See do_getstatic() for similar explanation, as well as bug 4684993.
 758         do_null_assert(return_type-&gt;as_klass());
 759       } else {
<a name="13" id="anc13"></a><span class="line-removed"> 760         if (sigstr.is_never_null()) {</span>
<span class="line-removed"> 761           return_type = outer()-&gt;mark_as_never_null(return_type);</span>
<span class="line-removed"> 762         }</span>
 763         push_translate(return_type);
 764       }
 765     }
 766   }
 767 }
 768 
 769 // ------------------------------------------------------------------
 770 // ciTypeFlow::StateVector::do_jsr
 771 void ciTypeFlow::StateVector::do_jsr(ciBytecodeStream* str) {
 772   push(ciReturnAddress::make(str-&gt;next_bci()));
 773 }
 774 
 775 // ------------------------------------------------------------------
 776 // ciTypeFlow::StateVector::do_ldc
 777 void ciTypeFlow::StateVector::do_ldc(ciBytecodeStream* str) {
 778   ciConstant con = str-&gt;get_constant();
 779   BasicType basic_type = con.basic_type();
 780   if (basic_type == T_ILLEGAL) {
 781     // OutOfMemoryError in the CI while loading constant
 782     push_null();
 783     outer()-&gt;record_failure(&quot;ldc did not link&quot;);
 784     return;
 785   }
 786   if (is_reference_type(basic_type)) {
 787     ciObject* obj = con.as_object();
 788     if (obj-&gt;is_null_object()) {
 789       push_null();
 790     } else {
 791       assert(obj-&gt;is_instance() || obj-&gt;is_array(), &quot;must be java_mirror of klass&quot;);
<a name="14" id="anc14"></a><span class="line-modified"> 792       ciType* type = obj-&gt;klass();</span>
<span class="line-removed"> 793       if (type-&gt;is_valuetype()) {</span>
<span class="line-removed"> 794         type = outer()-&gt;mark_as_never_null(type);</span>
<span class="line-removed"> 795       }</span>
<span class="line-removed"> 796       push(type);</span>
 797     }
 798   } else {
 799     push_translate(ciType::make(basic_type));
 800   }
 801 }
 802 
 803 // ------------------------------------------------------------------
 804 // ciTypeFlow::StateVector::do_multianewarray
 805 void ciTypeFlow::StateVector::do_multianewarray(ciBytecodeStream* str) {
 806   int dimensions = str-&gt;get_dimensions();
 807   bool will_link;
 808   ciArrayKlass* array_klass = str-&gt;get_klass(will_link)-&gt;as_array_klass();
 809   if (!will_link) {
 810     trap(str, array_klass, str-&gt;get_klass_index());
 811   } else {
 812     for (int i = 0; i &lt; dimensions; i++) {
 813       pop_int();
 814     }
 815     push_object(array_klass);
 816   }
 817 }
 818 
 819 // ------------------------------------------------------------------
 820 // ciTypeFlow::StateVector::do_new
 821 void ciTypeFlow::StateVector::do_new(ciBytecodeStream* str) {
 822   bool will_link;
 823   ciKlass* klass = str-&gt;get_klass(will_link);
 824   if (!will_link || str-&gt;is_unresolved_klass()) {
 825     trap(str, klass, str-&gt;get_klass_index());
 826   } else {
 827     push_object(klass);
 828   }
 829 }
 830 
 831 // ------------------------------------------------------------------
 832 // ciTypeFlow::StateVector::do_defaultvalue
 833 void ciTypeFlow::StateVector::do_defaultvalue(ciBytecodeStream* str) {
 834   bool will_link;
 835   ciKlass* klass = str-&gt;get_klass(will_link);
 836   if (!will_link) {
 837     trap(str, klass, str-&gt;get_klass_index());
 838   } else {
<a name="15" id="anc15"></a><span class="line-modified"> 839     // The default value type is never null</span>
<span class="line-modified"> 840     push(outer()-&gt;mark_as_never_null(klass));</span>
 841   }
 842 }
 843 
 844 // ------------------------------------------------------------------
 845 // ciTypeFlow::StateVector::do_withfield
 846 void ciTypeFlow::StateVector::do_withfield(ciBytecodeStream* str) {
 847   bool will_link;
 848   ciField* field = str-&gt;get_field(will_link);
 849   ciKlass* klass = field-&gt;holder();
 850   if (!will_link) {
 851     trap(str, klass, str-&gt;get_field_holder_index());
 852   } else {
 853     ciType* type = pop_value();
 854     ciType* field_type = field-&gt;type();
 855     assert(field_type-&gt;is_loaded(), &quot;field type must be loaded&quot;);
 856     if (field_type-&gt;is_two_word()) {
 857       ciType* type2 = pop_value();
 858       assert(type2-&gt;is_two_word(), &quot;must be 2nd half&quot;);
 859       assert(type == half_type(type2), &quot;must be 2nd half&quot;);
 860     }
 861     pop_object();
<a name="16" id="anc16"></a><span class="line-modified"> 862     // The newly created value type can never be null</span>
<span class="line-modified"> 863     push(outer()-&gt;mark_as_never_null(klass));</span>
 864   }
 865 }
 866 
 867 // ------------------------------------------------------------------
 868 // ciTypeFlow::StateVector::do_newarray
 869 void ciTypeFlow::StateVector::do_newarray(ciBytecodeStream* str) {
 870   pop_int();
 871   ciKlass* klass = ciTypeArrayKlass::make((BasicType)str-&gt;get_index());
 872   push_object(klass);
 873 }
 874 
 875 // ------------------------------------------------------------------
 876 // ciTypeFlow::StateVector::do_putfield
 877 void ciTypeFlow::StateVector::do_putfield(ciBytecodeStream* str) {
 878   do_putstatic(str);
 879   if (_trap_bci != -1)  return;  // unloaded field holder, etc.
 880   // could add assert here for type of object.
 881   pop_object();
 882 }
 883 
 884 // ------------------------------------------------------------------
 885 // ciTypeFlow::StateVector::do_putstatic
 886 void ciTypeFlow::StateVector::do_putstatic(ciBytecodeStream* str) {
 887   bool will_link;
 888   ciField* field = str-&gt;get_field(will_link);
 889   if (!will_link) {
 890     trap(str, field-&gt;holder(), str-&gt;get_field_holder_index());
 891   } else {
 892     ciType* field_type = field-&gt;type();
 893     ciType* type = pop_value();
 894     // Do I want to check this type?
 895     //      assert(type-&gt;is_subtype_of(field_type), &quot;bad type for field value&quot;);
 896     if (field_type-&gt;is_two_word()) {
 897       ciType* type2 = pop_value();
 898       assert(type2-&gt;is_two_word(), &quot;must be 2nd half&quot;);
 899       assert(type == half_type(type2), &quot;must be 2nd half&quot;);
 900     }
 901   }
 902 }
 903 
 904 // ------------------------------------------------------------------
 905 // ciTypeFlow::StateVector::do_ret
 906 void ciTypeFlow::StateVector::do_ret(ciBytecodeStream* str) {
 907   Cell index = local(str-&gt;get_index());
 908 
 909   ciType* address = type_at(index);
 910   assert(address-&gt;is_return_address(), &quot;bad return address&quot;);
 911   set_type_at(index, bottom_type());
 912 }
 913 
 914 // ------------------------------------------------------------------
 915 // ciTypeFlow::StateVector::trap
 916 //
 917 // Stop interpretation of this path with a trap.
 918 void ciTypeFlow::StateVector::trap(ciBytecodeStream* str, ciKlass* klass, int index) {
 919   _trap_bci = str-&gt;cur_bci();
 920   _trap_index = index;
 921 
 922   // Log information about this trap:
 923   CompileLog* log = outer()-&gt;env()-&gt;log();
 924   if (log != NULL) {
 925     int mid = log-&gt;identify(outer()-&gt;method());
 926     int kid = (klass == NULL)? -1: log-&gt;identify(klass);
 927     log-&gt;begin_elem(&quot;uncommon_trap method=&#39;%d&#39; bci=&#39;%d&#39;&quot;, mid, str-&gt;cur_bci());
 928     char buf[100];
 929     log-&gt;print(&quot; %s&quot;, Deoptimization::format_trap_request(buf, sizeof(buf),
 930                                                           index));
 931     if (kid &gt;= 0)
 932       log-&gt;print(&quot; klass=&#39;%d&#39;&quot;, kid);
 933     log-&gt;end_elem();
 934   }
 935 }
 936 
 937 // ------------------------------------------------------------------
 938 // ciTypeFlow::StateVector::do_null_assert
 939 // Corresponds to graphKit::do_null_assert.
 940 void ciTypeFlow::StateVector::do_null_assert(ciKlass* unloaded_klass) {
 941   if (unloaded_klass-&gt;is_loaded()) {
 942     // We failed to link, but we can still compute with this class,
 943     // since it is loaded somewhere.  The compiler will uncommon_trap
 944     // if the object is not null, but the typeflow pass can not assume
 945     // that the object will be null, otherwise it may incorrectly tell
 946     // the parser that an object is known to be null. 4761344, 4807707
 947     push_object(unloaded_klass);
 948   } else {
 949     // The class is not loaded anywhere.  It is safe to model the
 950     // null in the typestates, because we can compile in a null check
 951     // which will deoptimize us if someone manages to load the
 952     // class later.
 953     push_null();
 954   }
 955 }
 956 
 957 
 958 // ------------------------------------------------------------------
 959 // ciTypeFlow::StateVector::apply_one_bytecode
 960 //
 961 // Apply the effect of one bytecode to this StateVector
 962 bool ciTypeFlow::StateVector::apply_one_bytecode(ciBytecodeStream* str) {
 963   _trap_bci = -1;
 964   _trap_index = 0;
 965 
 966   if (CITraceTypeFlow) {
 967     tty-&gt;print_cr(&quot;&gt;&gt; Interpreting bytecode %d:%s&quot;, str-&gt;cur_bci(),
 968                   Bytecodes::name(str-&gt;cur_bc()));
 969   }
 970 
 971   switch(str-&gt;cur_bc()) {
 972   case Bytecodes::_aaload: do_aload(str);                           break;
 973 
 974   case Bytecodes::_aastore:
 975     {
 976       pop_object();
 977       pop_int();
 978       pop_objOrValueArray();
 979       break;
 980     }
 981   case Bytecodes::_aconst_null:
 982     {
 983       push_null();
 984       break;
 985     }
 986   case Bytecodes::_aload:   load_local_object(str-&gt;get_index());    break;
 987   case Bytecodes::_aload_0: load_local_object(0);                   break;
 988   case Bytecodes::_aload_1: load_local_object(1);                   break;
 989   case Bytecodes::_aload_2: load_local_object(2);                   break;
 990   case Bytecodes::_aload_3: load_local_object(3);                   break;
 991 
 992   case Bytecodes::_anewarray:
 993     {
 994       pop_int();
 995       bool will_link;
 996       ciKlass* element_klass = str-&gt;get_klass(will_link);
 997       if (!will_link) {
 998         trap(str, element_klass, str-&gt;get_klass_index());
 999       } else {
1000         push_object(ciArrayKlass::make(element_klass));
1001       }
1002       break;
1003     }
1004   case Bytecodes::_areturn:
1005   case Bytecodes::_ifnonnull:
1006   case Bytecodes::_ifnull:
1007     {
1008       pop_object();
1009       break;
1010     }
1011   case Bytecodes::_monitorenter:
1012     {
1013       pop_object();
1014       set_monitor_count(monitor_count() + 1);
1015       break;
1016     }
1017   case Bytecodes::_monitorexit:
1018     {
1019       pop_object();
1020       assert(monitor_count() &gt; 0, &quot;must be a monitor to exit from&quot;);
1021       set_monitor_count(monitor_count() - 1);
1022       break;
1023     }
1024   case Bytecodes::_arraylength:
1025     {
1026       pop_array();
1027       push_int();
1028       break;
1029     }
1030   case Bytecodes::_astore:   store_local_object(str-&gt;get_index());  break;
1031   case Bytecodes::_astore_0: store_local_object(0);                 break;
1032   case Bytecodes::_astore_1: store_local_object(1);                 break;
1033   case Bytecodes::_astore_2: store_local_object(2);                 break;
1034   case Bytecodes::_astore_3: store_local_object(3);                 break;
1035 
1036   case Bytecodes::_athrow:
1037     {
1038       NEEDS_CLEANUP;
1039       pop_object();
1040       break;
1041     }
1042   case Bytecodes::_baload:
1043   case Bytecodes::_caload:
1044   case Bytecodes::_iaload:
1045   case Bytecodes::_saload:
1046     {
1047       pop_int();
1048       ciTypeArrayKlass* array_klass = pop_typeArray();
1049       // Put assert here for right type?
1050       push_int();
1051       break;
1052     }
1053   case Bytecodes::_bastore:
1054   case Bytecodes::_castore:
1055   case Bytecodes::_iastore:
1056   case Bytecodes::_sastore:
1057     {
1058       pop_int();
1059       pop_int();
1060       pop_typeArray();
1061       // assert here?
1062       break;
1063     }
1064   case Bytecodes::_bipush:
1065   case Bytecodes::_iconst_m1:
1066   case Bytecodes::_iconst_0:
1067   case Bytecodes::_iconst_1:
1068   case Bytecodes::_iconst_2:
1069   case Bytecodes::_iconst_3:
1070   case Bytecodes::_iconst_4:
1071   case Bytecodes::_iconst_5:
1072   case Bytecodes::_sipush:
1073     {
1074       push_int();
1075       break;
1076     }
1077   case Bytecodes::_checkcast: do_checkcast(str);                  break;
1078 
1079   case Bytecodes::_d2f:
1080     {
1081       pop_double();
1082       push_float();
1083       break;
1084     }
1085   case Bytecodes::_d2i:
1086     {
1087       pop_double();
1088       push_int();
1089       break;
1090     }
1091   case Bytecodes::_d2l:
1092     {
1093       pop_double();
1094       push_long();
1095       break;
1096     }
1097   case Bytecodes::_dadd:
1098   case Bytecodes::_ddiv:
1099   case Bytecodes::_dmul:
1100   case Bytecodes::_drem:
1101   case Bytecodes::_dsub:
1102     {
1103       pop_double();
1104       pop_double();
1105       push_double();
1106       break;
1107     }
1108   case Bytecodes::_daload:
1109     {
1110       pop_int();
1111       ciTypeArrayKlass* array_klass = pop_typeArray();
1112       // Put assert here for right type?
1113       push_double();
1114       break;
1115     }
1116   case Bytecodes::_dastore:
1117     {
1118       pop_double();
1119       pop_int();
1120       pop_typeArray();
1121       // assert here?
1122       break;
1123     }
1124   case Bytecodes::_dcmpg:
1125   case Bytecodes::_dcmpl:
1126     {
1127       pop_double();
1128       pop_double();
1129       push_int();
1130       break;
1131     }
1132   case Bytecodes::_dconst_0:
1133   case Bytecodes::_dconst_1:
1134     {
1135       push_double();
1136       break;
1137     }
1138   case Bytecodes::_dload:   load_local_double(str-&gt;get_index());    break;
1139   case Bytecodes::_dload_0: load_local_double(0);                   break;
1140   case Bytecodes::_dload_1: load_local_double(1);                   break;
1141   case Bytecodes::_dload_2: load_local_double(2);                   break;
1142   case Bytecodes::_dload_3: load_local_double(3);                   break;
1143 
1144   case Bytecodes::_dneg:
1145     {
1146       pop_double();
1147       push_double();
1148       break;
1149     }
1150   case Bytecodes::_dreturn:
1151     {
1152       pop_double();
1153       break;
1154     }
1155   case Bytecodes::_dstore:   store_local_double(str-&gt;get_index());  break;
1156   case Bytecodes::_dstore_0: store_local_double(0);                 break;
1157   case Bytecodes::_dstore_1: store_local_double(1);                 break;
1158   case Bytecodes::_dstore_2: store_local_double(2);                 break;
1159   case Bytecodes::_dstore_3: store_local_double(3);                 break;
1160 
1161   case Bytecodes::_dup:
1162     {
1163       push(type_at_tos());
1164       break;
1165     }
1166   case Bytecodes::_dup_x1:
1167     {
1168       ciType* value1 = pop_value();
1169       ciType* value2 = pop_value();
1170       push(value1);
1171       push(value2);
1172       push(value1);
1173       break;
1174     }
1175   case Bytecodes::_dup_x2:
1176     {
1177       ciType* value1 = pop_value();
1178       ciType* value2 = pop_value();
1179       ciType* value3 = pop_value();
1180       push(value1);
1181       push(value3);
1182       push(value2);
1183       push(value1);
1184       break;
1185     }
1186   case Bytecodes::_dup2:
1187     {
1188       ciType* value1 = pop_value();
1189       ciType* value2 = pop_value();
1190       push(value2);
1191       push(value1);
1192       push(value2);
1193       push(value1);
1194       break;
1195     }
1196   case Bytecodes::_dup2_x1:
1197     {
1198       ciType* value1 = pop_value();
1199       ciType* value2 = pop_value();
1200       ciType* value3 = pop_value();
1201       push(value2);
1202       push(value1);
1203       push(value3);
1204       push(value2);
1205       push(value1);
1206       break;
1207     }
1208   case Bytecodes::_dup2_x2:
1209     {
1210       ciType* value1 = pop_value();
1211       ciType* value2 = pop_value();
1212       ciType* value3 = pop_value();
1213       ciType* value4 = pop_value();
1214       push(value2);
1215       push(value1);
1216       push(value4);
1217       push(value3);
1218       push(value2);
1219       push(value1);
1220       break;
1221     }
1222   case Bytecodes::_f2d:
1223     {
1224       pop_float();
1225       push_double();
1226       break;
1227     }
1228   case Bytecodes::_f2i:
1229     {
1230       pop_float();
1231       push_int();
1232       break;
1233     }
1234   case Bytecodes::_f2l:
1235     {
1236       pop_float();
1237       push_long();
1238       break;
1239     }
1240   case Bytecodes::_fadd:
1241   case Bytecodes::_fdiv:
1242   case Bytecodes::_fmul:
1243   case Bytecodes::_frem:
1244   case Bytecodes::_fsub:
1245     {
1246       pop_float();
1247       pop_float();
1248       push_float();
1249       break;
1250     }
1251   case Bytecodes::_faload:
1252     {
1253       pop_int();
1254       ciTypeArrayKlass* array_klass = pop_typeArray();
1255       // Put assert here.
1256       push_float();
1257       break;
1258     }
1259   case Bytecodes::_fastore:
1260     {
1261       pop_float();
1262       pop_int();
1263       ciTypeArrayKlass* array_klass = pop_typeArray();
1264       // Put assert here.
1265       break;
1266     }
1267   case Bytecodes::_fcmpg:
1268   case Bytecodes::_fcmpl:
1269     {
1270       pop_float();
1271       pop_float();
1272       push_int();
1273       break;
1274     }
1275   case Bytecodes::_fconst_0:
1276   case Bytecodes::_fconst_1:
1277   case Bytecodes::_fconst_2:
1278     {
1279       push_float();
1280       break;
1281     }
1282   case Bytecodes::_fload:   load_local_float(str-&gt;get_index());     break;
1283   case Bytecodes::_fload_0: load_local_float(0);                    break;
1284   case Bytecodes::_fload_1: load_local_float(1);                    break;
1285   case Bytecodes::_fload_2: load_local_float(2);                    break;
1286   case Bytecodes::_fload_3: load_local_float(3);                    break;
1287 
1288   case Bytecodes::_fneg:
1289     {
1290       pop_float();
1291       push_float();
1292       break;
1293     }
1294   case Bytecodes::_freturn:
1295     {
1296       pop_float();
1297       break;
1298     }
1299   case Bytecodes::_fstore:    store_local_float(str-&gt;get_index());   break;
1300   case Bytecodes::_fstore_0:  store_local_float(0);                  break;
1301   case Bytecodes::_fstore_1:  store_local_float(1);                  break;
1302   case Bytecodes::_fstore_2:  store_local_float(2);                  break;
1303   case Bytecodes::_fstore_3:  store_local_float(3);                  break;
1304 
1305   case Bytecodes::_getfield:  do_getfield(str);                      break;
1306   case Bytecodes::_getstatic: do_getstatic(str);                     break;
1307 
1308   case Bytecodes::_goto:
1309   case Bytecodes::_goto_w:
1310   case Bytecodes::_nop:
1311   case Bytecodes::_return:
1312     {
1313       // do nothing.
1314       break;
1315     }
1316   case Bytecodes::_i2b:
1317   case Bytecodes::_i2c:
1318   case Bytecodes::_i2s:
1319   case Bytecodes::_ineg:
1320     {
1321       pop_int();
1322       push_int();
1323       break;
1324     }
1325   case Bytecodes::_i2d:
1326     {
1327       pop_int();
1328       push_double();
1329       break;
1330     }
1331   case Bytecodes::_i2f:
1332     {
1333       pop_int();
1334       push_float();
1335       break;
1336     }
1337   case Bytecodes::_i2l:
1338     {
1339       pop_int();
1340       push_long();
1341       break;
1342     }
1343   case Bytecodes::_iadd:
1344   case Bytecodes::_iand:
1345   case Bytecodes::_idiv:
1346   case Bytecodes::_imul:
1347   case Bytecodes::_ior:
1348   case Bytecodes::_irem:
1349   case Bytecodes::_ishl:
1350   case Bytecodes::_ishr:
1351   case Bytecodes::_isub:
1352   case Bytecodes::_iushr:
1353   case Bytecodes::_ixor:
1354     {
1355       pop_int();
1356       pop_int();
1357       push_int();
1358       break;
1359     }
1360   case Bytecodes::_if_acmpeq:
1361   case Bytecodes::_if_acmpne:
1362     {
1363       pop_object();
1364       pop_object();
1365       break;
1366     }
1367   case Bytecodes::_if_icmpeq:
1368   case Bytecodes::_if_icmpge:
1369   case Bytecodes::_if_icmpgt:
1370   case Bytecodes::_if_icmple:
1371   case Bytecodes::_if_icmplt:
1372   case Bytecodes::_if_icmpne:
1373     {
1374       pop_int();
1375       pop_int();
1376       break;
1377     }
1378   case Bytecodes::_ifeq:
1379   case Bytecodes::_ifle:
1380   case Bytecodes::_iflt:
1381   case Bytecodes::_ifge:
1382   case Bytecodes::_ifgt:
1383   case Bytecodes::_ifne:
1384   case Bytecodes::_ireturn:
1385   case Bytecodes::_lookupswitch:
1386   case Bytecodes::_tableswitch:
1387     {
1388       pop_int();
1389       break;
1390     }
1391   case Bytecodes::_iinc:
1392     {
1393       int lnum = str-&gt;get_index();
1394       check_int(local(lnum));
1395       store_to_local(lnum);
1396       break;
1397     }
1398   case Bytecodes::_iload:   load_local_int(str-&gt;get_index()); break;
1399   case Bytecodes::_iload_0: load_local_int(0);                      break;
1400   case Bytecodes::_iload_1: load_local_int(1);                      break;
1401   case Bytecodes::_iload_2: load_local_int(2);                      break;
1402   case Bytecodes::_iload_3: load_local_int(3);                      break;
1403 
1404   case Bytecodes::_instanceof:
1405     {
1406       // Check for uncommon trap:
1407       do_checkcast(str);
1408       pop_object();
1409       push_int();
1410       break;
1411     }
1412   case Bytecodes::_invokeinterface: do_invoke(str, true);           break;
1413   case Bytecodes::_invokespecial:   do_invoke(str, true);           break;
1414   case Bytecodes::_invokestatic:    do_invoke(str, false);          break;
1415   case Bytecodes::_invokevirtual:   do_invoke(str, true);           break;
1416   case Bytecodes::_invokedynamic:   do_invoke(str, false);          break;
1417 
1418   case Bytecodes::_istore:   store_local_int(str-&gt;get_index());     break;
1419   case Bytecodes::_istore_0: store_local_int(0);                    break;
1420   case Bytecodes::_istore_1: store_local_int(1);                    break;
1421   case Bytecodes::_istore_2: store_local_int(2);                    break;
1422   case Bytecodes::_istore_3: store_local_int(3);                    break;
1423 
1424   case Bytecodes::_jsr:
1425   case Bytecodes::_jsr_w: do_jsr(str);                              break;
1426 
1427   case Bytecodes::_l2d:
1428     {
1429       pop_long();
1430       push_double();
1431       break;
1432     }
1433   case Bytecodes::_l2f:
1434     {
1435       pop_long();
1436       push_float();
1437       break;
1438     }
1439   case Bytecodes::_l2i:
1440     {
1441       pop_long();
1442       push_int();
1443       break;
1444     }
1445   case Bytecodes::_ladd:
1446   case Bytecodes::_land:
1447   case Bytecodes::_ldiv:
1448   case Bytecodes::_lmul:
1449   case Bytecodes::_lor:
1450   case Bytecodes::_lrem:
1451   case Bytecodes::_lsub:
1452   case Bytecodes::_lxor:
1453     {
1454       pop_long();
1455       pop_long();
1456       push_long();
1457       break;
1458     }
1459   case Bytecodes::_laload:
1460     {
1461       pop_int();
1462       ciTypeArrayKlass* array_klass = pop_typeArray();
1463       // Put assert here for right type?
1464       push_long();
1465       break;
1466     }
1467   case Bytecodes::_lastore:
1468     {
1469       pop_long();
1470       pop_int();
1471       pop_typeArray();
1472       // assert here?
1473       break;
1474     }
1475   case Bytecodes::_lcmp:
1476     {
1477       pop_long();
1478       pop_long();
1479       push_int();
1480       break;
1481     }
1482   case Bytecodes::_lconst_0:
1483   case Bytecodes::_lconst_1:
1484     {
1485       push_long();
1486       break;
1487     }
1488   case Bytecodes::_ldc:
1489   case Bytecodes::_ldc_w:
1490   case Bytecodes::_ldc2_w:
1491     {
1492       do_ldc(str);
1493       break;
1494     }
1495 
1496   case Bytecodes::_lload:   load_local_long(str-&gt;get_index());      break;
1497   case Bytecodes::_lload_0: load_local_long(0);                     break;
1498   case Bytecodes::_lload_1: load_local_long(1);                     break;
1499   case Bytecodes::_lload_2: load_local_long(2);                     break;
1500   case Bytecodes::_lload_3: load_local_long(3);                     break;
1501 
1502   case Bytecodes::_lneg:
1503     {
1504       pop_long();
1505       push_long();
1506       break;
1507     }
1508   case Bytecodes::_lreturn:
1509     {
1510       pop_long();
1511       break;
1512     }
1513   case Bytecodes::_lshl:
1514   case Bytecodes::_lshr:
1515   case Bytecodes::_lushr:
1516     {
1517       pop_int();
1518       pop_long();
1519       push_long();
1520       break;
1521     }
1522   case Bytecodes::_lstore:   store_local_long(str-&gt;get_index());    break;
1523   case Bytecodes::_lstore_0: store_local_long(0);                   break;
1524   case Bytecodes::_lstore_1: store_local_long(1);                   break;
1525   case Bytecodes::_lstore_2: store_local_long(2);                   break;
1526   case Bytecodes::_lstore_3: store_local_long(3);                   break;
1527 
1528   case Bytecodes::_multianewarray: do_multianewarray(str);          break;
1529 
1530   case Bytecodes::_new:      do_new(str);                           break;
1531 
1532   case Bytecodes::_defaultvalue: do_defaultvalue(str);              break;
1533   case Bytecodes::_withfield: do_withfield(str);                    break;
1534 
1535   case Bytecodes::_newarray: do_newarray(str);                      break;
1536 
1537   case Bytecodes::_pop:
1538     {
1539       pop();
1540       break;
1541     }
1542   case Bytecodes::_pop2:
1543     {
1544       pop();
1545       pop();
1546       break;
1547     }
1548 
1549   case Bytecodes::_putfield:       do_putfield(str);                 break;
1550   case Bytecodes::_putstatic:      do_putstatic(str);                break;
1551 
1552   case Bytecodes::_ret: do_ret(str);                                 break;
1553 
1554   case Bytecodes::_swap:
1555     {
1556       ciType* value1 = pop_value();
1557       ciType* value2 = pop_value();
1558       push(value1);
1559       push(value2);
1560       break;
1561     }
1562 
1563   case Bytecodes::_wide:
1564   default:
1565     {
1566       // The iterator should skip this.
1567       ShouldNotReachHere();
1568       break;
1569     }
1570   }
1571 
1572   if (CITraceTypeFlow) {
1573     print_on(tty);
1574   }
1575 
1576   return (_trap_bci != -1);
1577 }
1578 
1579 #ifndef PRODUCT
1580 // ------------------------------------------------------------------
1581 // ciTypeFlow::StateVector::print_cell_on
1582 void ciTypeFlow::StateVector::print_cell_on(outputStream* st, Cell c) const {
1583   ciType* type = type_at(c);
1584   if (type == top_type()) {
1585     st-&gt;print(&quot;top&quot;);
1586   } else if (type == bottom_type()) {
1587     st-&gt;print(&quot;bottom&quot;);
1588   } else if (type == null_type()) {
1589     st-&gt;print(&quot;null&quot;);
1590   } else if (type == long2_type()) {
1591     st-&gt;print(&quot;long2&quot;);
1592   } else if (type == double2_type()) {
1593     st-&gt;print(&quot;double2&quot;);
1594   } else if (is_int(type)) {
1595     st-&gt;print(&quot;int&quot;);
1596   } else if (is_long(type)) {
1597     st-&gt;print(&quot;long&quot;);
1598   } else if (is_float(type)) {
1599     st-&gt;print(&quot;float&quot;);
1600   } else if (is_double(type)) {
1601     st-&gt;print(&quot;double&quot;);
1602   } else if (type-&gt;is_return_address()) {
1603     st-&gt;print(&quot;address(%d)&quot;, type-&gt;as_return_address()-&gt;bci());
1604   } else {
1605     if (type-&gt;is_klass()) {
1606       type-&gt;as_klass()-&gt;name()-&gt;print_symbol_on(st);
1607     } else {
1608       st-&gt;print(&quot;UNEXPECTED TYPE&quot;);
1609       type-&gt;print();
1610     }
1611   }
1612 }
1613 
1614 // ------------------------------------------------------------------
1615 // ciTypeFlow::StateVector::print_on
1616 void ciTypeFlow::StateVector::print_on(outputStream* st) const {
1617   int num_locals   = _outer-&gt;max_locals();
1618   int num_stack    = stack_size();
1619   int num_monitors = monitor_count();
1620   st-&gt;print_cr(&quot;  State : locals %d, stack %d, monitors %d&quot;, num_locals, num_stack, num_monitors);
1621   if (num_stack &gt;= 0) {
1622     int i;
1623     for (i = 0; i &lt; num_locals; i++) {
1624       st-&gt;print(&quot;    local %2d : &quot;, i);
1625       print_cell_on(st, local(i));
1626       st-&gt;cr();
1627     }
1628     for (i = 0; i &lt; num_stack; i++) {
1629       st-&gt;print(&quot;    stack %2d : &quot;, i);
1630       print_cell_on(st, stack(i));
1631       st-&gt;cr();
1632     }
1633   }
1634 }
1635 #endif
1636 
1637 
1638 // ------------------------------------------------------------------
1639 // ciTypeFlow::SuccIter::next
1640 //
1641 void ciTypeFlow::SuccIter::next() {
1642   int succ_ct = _pred-&gt;successors()-&gt;length();
1643   int next = _index + 1;
1644   if (next &lt; succ_ct) {
1645     _index = next;
1646     _succ = _pred-&gt;successors()-&gt;at(next);
1647     return;
1648   }
1649   for (int i = next - succ_ct; i &lt; _pred-&gt;exceptions()-&gt;length(); i++) {
1650     // Do not compile any code for unloaded exception types.
1651     // Following compiler passes are responsible for doing this also.
1652     ciInstanceKlass* exception_klass = _pred-&gt;exc_klasses()-&gt;at(i);
1653     if (exception_klass-&gt;is_loaded()) {
1654       _index = next;
1655       _succ = _pred-&gt;exceptions()-&gt;at(i);
1656       return;
1657     }
1658     next++;
1659   }
1660   _index = -1;
1661   _succ = NULL;
1662 }
1663 
1664 // ------------------------------------------------------------------
1665 // ciTypeFlow::SuccIter::set_succ
1666 //
1667 void ciTypeFlow::SuccIter::set_succ(Block* succ) {
1668   int succ_ct = _pred-&gt;successors()-&gt;length();
1669   if (_index &lt; succ_ct) {
1670     _pred-&gt;successors()-&gt;at_put(_index, succ);
1671   } else {
1672     int idx = _index - succ_ct;
1673     _pred-&gt;exceptions()-&gt;at_put(idx, succ);
1674   }
1675 }
1676 
1677 // ciTypeFlow::Block
1678 //
1679 // A basic block.
1680 
1681 // ------------------------------------------------------------------
1682 // ciTypeFlow::Block::Block
1683 ciTypeFlow::Block::Block(ciTypeFlow* outer,
1684                          ciBlock *ciblk,
1685                          ciTypeFlow::JsrSet* jsrs) {
1686   _ciblock = ciblk;
1687   _exceptions = NULL;
1688   _exc_klasses = NULL;
1689   _successors = NULL;
1690   _predecessors = new (outer-&gt;arena()) GrowableArray&lt;Block*&gt;(outer-&gt;arena(), 1, 0, NULL);
1691   _state = new (outer-&gt;arena()) StateVector(outer);
1692   JsrSet* new_jsrs =
1693     new (outer-&gt;arena()) JsrSet(outer-&gt;arena(), jsrs-&gt;size());
1694   jsrs-&gt;copy_into(new_jsrs);
1695   _jsrs = new_jsrs;
1696   _next = NULL;
1697   _on_work_list = false;
1698   _backedge_copy = false;
1699   _has_monitorenter = false;
1700   _trap_bci = -1;
1701   _trap_index = 0;
1702   df_init();
1703 
1704   if (CITraceTypeFlow) {
1705     tty-&gt;print_cr(&quot;&gt;&gt; Created new block&quot;);
1706     print_on(tty);
1707   }
1708 
1709   assert(this-&gt;outer() == outer, &quot;outer link set up&quot;);
1710   assert(!outer-&gt;have_block_count(), &quot;must not have mapped blocks yet&quot;);
1711 }
1712 
1713 // ------------------------------------------------------------------
1714 // ciTypeFlow::Block::df_init
1715 void ciTypeFlow::Block::df_init() {
1716   _pre_order = -1; assert(!has_pre_order(), &quot;&quot;);
1717   _post_order = -1; assert(!has_post_order(), &quot;&quot;);
1718   _loop = NULL;
1719   _irreducible_entry = false;
1720   _rpo_next = NULL;
1721 }
1722 
1723 // ------------------------------------------------------------------
1724 // ciTypeFlow::Block::successors
1725 //
1726 // Get the successors for this Block.
1727 GrowableArray&lt;ciTypeFlow::Block*&gt;*
1728 ciTypeFlow::Block::successors(ciBytecodeStream* str,
1729                               ciTypeFlow::StateVector* state,
1730                               ciTypeFlow::JsrSet* jsrs) {
1731   if (_successors == NULL) {
1732     if (CITraceTypeFlow) {
1733       tty-&gt;print(&quot;&gt;&gt; Computing successors for block &quot;);
1734       print_value_on(tty);
1735       tty-&gt;cr();
1736     }
1737 
1738     ciTypeFlow* analyzer = outer();
1739     Arena* arena = analyzer-&gt;arena();
1740     Block* block = NULL;
1741     bool has_successor = !has_trap() &amp;&amp;
1742                          (control() != ciBlock::fall_through_bci || limit() &lt; analyzer-&gt;code_size());
1743     if (!has_successor) {
1744       _successors =
1745         new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1746       // No successors
1747     } else if (control() == ciBlock::fall_through_bci) {
1748       assert(str-&gt;cur_bci() == limit(), &quot;bad block end&quot;);
1749       // This block simply falls through to the next.
1750       _successors =
1751         new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1752 
1753       Block* block = analyzer-&gt;block_at(limit(), _jsrs);
1754       assert(_successors-&gt;length() == FALL_THROUGH, &quot;&quot;);
1755       _successors-&gt;append(block);
1756     } else {
1757       int current_bci = str-&gt;cur_bci();
1758       int next_bci = str-&gt;next_bci();
1759       int branch_bci = -1;
1760       Block* target = NULL;
1761       assert(str-&gt;next_bci() == limit(), &quot;bad block end&quot;);
1762       // This block is not a simple fall-though.  Interpret
1763       // the current bytecode to find our successors.
1764       switch (str-&gt;cur_bc()) {
1765       case Bytecodes::_ifeq:         case Bytecodes::_ifne:
1766       case Bytecodes::_iflt:         case Bytecodes::_ifge:
1767       case Bytecodes::_ifgt:         case Bytecodes::_ifle:
1768       case Bytecodes::_if_icmpeq:    case Bytecodes::_if_icmpne:
1769       case Bytecodes::_if_icmplt:    case Bytecodes::_if_icmpge:
1770       case Bytecodes::_if_icmpgt:    case Bytecodes::_if_icmple:
1771       case Bytecodes::_if_acmpeq:    case Bytecodes::_if_acmpne:
1772       case Bytecodes::_ifnull:       case Bytecodes::_ifnonnull:
1773         // Our successors are the branch target and the next bci.
1774         branch_bci = str-&gt;get_dest();
1775         _successors =
1776           new (arena) GrowableArray&lt;Block*&gt;(arena, 2, 0, NULL);
1777         assert(_successors-&gt;length() == IF_NOT_TAKEN, &quot;&quot;);
1778         _successors-&gt;append(analyzer-&gt;block_at(next_bci, jsrs));
1779         assert(_successors-&gt;length() == IF_TAKEN, &quot;&quot;);
1780         _successors-&gt;append(analyzer-&gt;block_at(branch_bci, jsrs));
1781         break;
1782 
1783       case Bytecodes::_goto:
1784         branch_bci = str-&gt;get_dest();
1785         _successors =
1786           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1787         assert(_successors-&gt;length() == GOTO_TARGET, &quot;&quot;);
1788         _successors-&gt;append(analyzer-&gt;block_at(branch_bci, jsrs));
1789         break;
1790 
1791       case Bytecodes::_jsr:
1792         branch_bci = str-&gt;get_dest();
1793         _successors =
1794           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1795         assert(_successors-&gt;length() == GOTO_TARGET, &quot;&quot;);
1796         _successors-&gt;append(analyzer-&gt;block_at(branch_bci, jsrs));
1797         break;
1798 
1799       case Bytecodes::_goto_w:
1800       case Bytecodes::_jsr_w:
1801         _successors =
1802           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1803         assert(_successors-&gt;length() == GOTO_TARGET, &quot;&quot;);
1804         _successors-&gt;append(analyzer-&gt;block_at(str-&gt;get_far_dest(), jsrs));
1805         break;
1806 
1807       case Bytecodes::_tableswitch:  {
1808         Bytecode_tableswitch tableswitch(str);
1809 
1810         int len = tableswitch.length();
1811         _successors =
1812           new (arena) GrowableArray&lt;Block*&gt;(arena, len+1, 0, NULL);
1813         int bci = current_bci + tableswitch.default_offset();
1814         Block* block = analyzer-&gt;block_at(bci, jsrs);
1815         assert(_successors-&gt;length() == SWITCH_DEFAULT, &quot;&quot;);
1816         _successors-&gt;append(block);
1817         while (--len &gt;= 0) {
1818           int bci = current_bci + tableswitch.dest_offset_at(len);
1819           block = analyzer-&gt;block_at(bci, jsrs);
1820           assert(_successors-&gt;length() &gt;= SWITCH_CASES, &quot;&quot;);
1821           _successors-&gt;append_if_missing(block);
1822         }
1823         break;
1824       }
1825 
1826       case Bytecodes::_lookupswitch: {
1827         Bytecode_lookupswitch lookupswitch(str);
1828 
1829         int npairs = lookupswitch.number_of_pairs();
1830         _successors =
1831           new (arena) GrowableArray&lt;Block*&gt;(arena, npairs+1, 0, NULL);
1832         int bci = current_bci + lookupswitch.default_offset();
1833         Block* block = analyzer-&gt;block_at(bci, jsrs);
1834         assert(_successors-&gt;length() == SWITCH_DEFAULT, &quot;&quot;);
1835         _successors-&gt;append(block);
1836         while(--npairs &gt;= 0) {
1837           LookupswitchPair pair = lookupswitch.pair_at(npairs);
1838           int bci = current_bci + pair.offset();
1839           Block* block = analyzer-&gt;block_at(bci, jsrs);
1840           assert(_successors-&gt;length() &gt;= SWITCH_CASES, &quot;&quot;);
1841           _successors-&gt;append_if_missing(block);
1842         }
1843         break;
1844       }
1845 
1846       case Bytecodes::_athrow:
1847       case Bytecodes::_ireturn:
1848       case Bytecodes::_lreturn:
1849       case Bytecodes::_freturn:
1850       case Bytecodes::_dreturn:
1851       case Bytecodes::_areturn:
1852       case Bytecodes::_return:
1853         _successors =
1854           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1855         // No successors
1856         break;
1857 
1858       case Bytecodes::_ret: {
1859         _successors =
1860           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1861 
1862         Cell local = state-&gt;local(str-&gt;get_index());
1863         ciType* return_address = state-&gt;type_at(local);
1864         assert(return_address-&gt;is_return_address(), &quot;verify: wrong type&quot;);
1865         int bci = return_address-&gt;as_return_address()-&gt;bci();
1866         assert(_successors-&gt;length() == GOTO_TARGET, &quot;&quot;);
1867         _successors-&gt;append(analyzer-&gt;block_at(bci, jsrs));
1868         break;
1869       }
1870 
1871       case Bytecodes::_wide:
1872       default:
1873         ShouldNotReachHere();
1874         break;
1875       }
1876     }
1877 
1878     // Set predecessor information
1879     for (int i = 0; i &lt; _successors-&gt;length(); i++) {
1880       Block* block = _successors-&gt;at(i);
1881       block-&gt;predecessors()-&gt;append(this);
1882     }
1883   }
1884   return _successors;
1885 }
1886 
1887 // ------------------------------------------------------------------
1888 // ciTypeFlow::Block:compute_exceptions
1889 //
1890 // Compute the exceptional successors and types for this Block.
1891 void ciTypeFlow::Block::compute_exceptions() {
1892   assert(_exceptions == NULL &amp;&amp; _exc_klasses == NULL, &quot;repeat&quot;);
1893 
1894   if (CITraceTypeFlow) {
1895     tty-&gt;print(&quot;&gt;&gt; Computing exceptions for block &quot;);
1896     print_value_on(tty);
1897     tty-&gt;cr();
1898   }
1899 
1900   ciTypeFlow* analyzer = outer();
1901   Arena* arena = analyzer-&gt;arena();
1902 
1903   // Any bci in the block will do.
1904   ciExceptionHandlerStream str(analyzer-&gt;method(), start());
1905 
1906   // Allocate our growable arrays.
1907   int exc_count = str.count();
1908   _exceptions = new (arena) GrowableArray&lt;Block*&gt;(arena, exc_count, 0, NULL);
1909   _exc_klasses = new (arena) GrowableArray&lt;ciInstanceKlass*&gt;(arena, exc_count,
1910                                                              0, NULL);
1911 
1912   for ( ; !str.is_done(); str.next()) {
1913     ciExceptionHandler* handler = str.handler();
1914     int bci = handler-&gt;handler_bci();
1915     ciInstanceKlass* klass = NULL;
1916     if (bci == -1) {
1917       // There is no catch all.  It is possible to exit the method.
1918       break;
1919     }
1920     if (handler-&gt;is_catch_all()) {
1921       klass = analyzer-&gt;env()-&gt;Throwable_klass();
1922     } else {
1923       klass = handler-&gt;catch_klass();
1924     }
1925     Block* block = analyzer-&gt;block_at(bci, _jsrs);
1926     _exceptions-&gt;append(block);
1927     block-&gt;predecessors()-&gt;append(this);
1928     _exc_klasses-&gt;append(klass);
1929   }
1930 }
1931 
1932 // ------------------------------------------------------------------
1933 // ciTypeFlow::Block::set_backedge_copy
1934 // Use this only to make a pre-existing public block into a backedge copy.
1935 void ciTypeFlow::Block::set_backedge_copy(bool z) {
1936   assert(z || (z == is_backedge_copy()), &quot;cannot make a backedge copy public&quot;);
1937   _backedge_copy = z;
1938 }
1939 
1940 // ------------------------------------------------------------------
1941 // ciTypeFlow::Block::is_clonable_exit
1942 //
1943 // At most 2 normal successors, one of which continues looping,
1944 // and all exceptional successors must exit.
1945 bool ciTypeFlow::Block::is_clonable_exit(ciTypeFlow::Loop* lp) {
1946   int normal_cnt  = 0;
1947   int in_loop_cnt = 0;
1948   for (SuccIter iter(this); !iter.done(); iter.next()) {
1949     Block* succ = iter.succ();
1950     if (iter.is_normal_ctrl()) {
1951       if (++normal_cnt &gt; 2) return false;
1952       if (lp-&gt;contains(succ-&gt;loop())) {
1953         if (++in_loop_cnt &gt; 1) return false;
1954       }
1955     } else {
1956       if (lp-&gt;contains(succ-&gt;loop())) return false;
1957     }
1958   }
1959   return in_loop_cnt == 1;
1960 }
1961 
1962 // ------------------------------------------------------------------
1963 // ciTypeFlow::Block::looping_succ
1964 //
1965 ciTypeFlow::Block* ciTypeFlow::Block::looping_succ(ciTypeFlow::Loop* lp) {
1966   assert(successors()-&gt;length() &lt;= 2, &quot;at most 2 normal successors&quot;);
1967   for (SuccIter iter(this); !iter.done(); iter.next()) {
1968     Block* succ = iter.succ();
1969     if (lp-&gt;contains(succ-&gt;loop())) {
1970       return succ;
1971     }
1972   }
1973   return NULL;
1974 }
1975 
1976 #ifndef PRODUCT
1977 // ------------------------------------------------------------------
1978 // ciTypeFlow::Block::print_value_on
1979 void ciTypeFlow::Block::print_value_on(outputStream* st) const {
1980   if (has_pre_order()) st-&gt;print(&quot;#%-2d &quot;, pre_order());
1981   if (has_rpo())       st-&gt;print(&quot;rpo#%-2d &quot;, rpo());
1982   st-&gt;print(&quot;[%d - %d)&quot;, start(), limit());
1983   if (is_loop_head()) st-&gt;print(&quot; lphd&quot;);
1984   if (is_irreducible_entry()) st-&gt;print(&quot; irred&quot;);
1985   if (_jsrs-&gt;size() &gt; 0) { st-&gt;print(&quot;/&quot;);  _jsrs-&gt;print_on(st); }
1986   if (is_backedge_copy())  st-&gt;print(&quot;/backedge_copy&quot;);
1987 }
1988 
1989 // ------------------------------------------------------------------
1990 // ciTypeFlow::Block::print_on
1991 void ciTypeFlow::Block::print_on(outputStream* st) const {
1992   if ((Verbose || WizardMode) &amp;&amp; (limit() &gt;= 0)) {
1993     // Don&#39;t print &#39;dummy&#39; blocks (i.e. blocks with limit() &#39;-1&#39;)
1994     outer()-&gt;method()-&gt;print_codes_on(start(), limit(), st);
1995   }
1996   st-&gt;print_cr(&quot;  ====================================================  &quot;);
1997   st-&gt;print (&quot;  &quot;);
1998   print_value_on(st);
1999   st-&gt;print(&quot; Stored locals: &quot;); def_locals()-&gt;print_on(st, outer()-&gt;method()-&gt;max_locals()); tty-&gt;cr();
2000   if (loop() &amp;&amp; loop()-&gt;parent() != NULL) {
2001     st-&gt;print(&quot; loops:&quot;);
2002     Loop* lp = loop();
2003     do {
2004       st-&gt;print(&quot; %d&lt;-%d&quot;, lp-&gt;head()-&gt;pre_order(),lp-&gt;tail()-&gt;pre_order());
2005       if (lp-&gt;is_irreducible()) st-&gt;print(&quot;(ir)&quot;);
2006       lp = lp-&gt;parent();
2007     } while (lp-&gt;parent() != NULL);
2008   }
2009   st-&gt;cr();
2010   _state-&gt;print_on(st);
2011   if (_successors == NULL) {
2012     st-&gt;print_cr(&quot;  No successor information&quot;);
2013   } else {
2014     int num_successors = _successors-&gt;length();
2015     st-&gt;print_cr(&quot;  Successors : %d&quot;, num_successors);
2016     for (int i = 0; i &lt; num_successors; i++) {
2017       Block* successor = _successors-&gt;at(i);
2018       st-&gt;print(&quot;    &quot;);
2019       successor-&gt;print_value_on(st);
2020       st-&gt;cr();
2021     }
2022   }
2023   if (_predecessors == NULL) {
2024     st-&gt;print_cr(&quot;  No predecessor information&quot;);
2025   } else {
2026     int num_predecessors = _predecessors-&gt;length();
2027     st-&gt;print_cr(&quot;  Predecessors : %d&quot;, num_predecessors);
2028     for (int i = 0; i &lt; num_predecessors; i++) {
2029       Block* predecessor = _predecessors-&gt;at(i);
2030       st-&gt;print(&quot;    &quot;);
2031       predecessor-&gt;print_value_on(st);
2032       st-&gt;cr();
2033     }
2034   }
2035   if (_exceptions == NULL) {
2036     st-&gt;print_cr(&quot;  No exception information&quot;);
2037   } else {
2038     int num_exceptions = _exceptions-&gt;length();
2039     st-&gt;print_cr(&quot;  Exceptions : %d&quot;, num_exceptions);
2040     for (int i = 0; i &lt; num_exceptions; i++) {
2041       Block* exc_succ = _exceptions-&gt;at(i);
2042       ciInstanceKlass* exc_klass = _exc_klasses-&gt;at(i);
2043       st-&gt;print(&quot;    &quot;);
2044       exc_succ-&gt;print_value_on(st);
2045       st-&gt;print(&quot; -- &quot;);
2046       exc_klass-&gt;name()-&gt;print_symbol_on(st);
2047       st-&gt;cr();
2048     }
2049   }
2050   if (has_trap()) {
2051     st-&gt;print_cr(&quot;  Traps on %d with trap index %d&quot;, trap_bci(), trap_index());
2052   }
2053   st-&gt;print_cr(&quot;  ====================================================  &quot;);
2054 }
2055 #endif
2056 
2057 #ifndef PRODUCT
2058 // ------------------------------------------------------------------
2059 // ciTypeFlow::LocalSet::print_on
2060 void ciTypeFlow::LocalSet::print_on(outputStream* st, int limit) const {
2061   st-&gt;print(&quot;{&quot;);
2062   for (int i = 0; i &lt; max; i++) {
2063     if (test(i)) st-&gt;print(&quot; %d&quot;, i);
2064   }
2065   if (limit &gt; max) {
2066     st-&gt;print(&quot; %d..%d &quot;, max, limit);
2067   }
2068   st-&gt;print(&quot; }&quot;);
2069 }
2070 #endif
2071 
2072 // ciTypeFlow
2073 //
2074 // This is a pass over the bytecodes which computes the following:
2075 //   basic block structure
2076 //   interpreter type-states (a la the verifier)
2077 
2078 // ------------------------------------------------------------------
2079 // ciTypeFlow::ciTypeFlow
2080 ciTypeFlow::ciTypeFlow(ciEnv* env, ciMethod* method, int osr_bci) {
2081   _env = env;
2082   _method = method;
2083   _methodBlocks = method-&gt;get_method_blocks();
2084   _max_locals = method-&gt;max_locals();
2085   _max_stack = method-&gt;max_stack();
2086   _code_size = method-&gt;code_size();
2087   _has_irreducible_entry = false;
2088   _osr_bci = osr_bci;
2089   _failure_reason = NULL;
2090   assert(0 &lt;= start_bci() &amp;&amp; start_bci() &lt; code_size() , &quot;correct osr_bci argument: 0 &lt;= %d &lt; %d&quot;, start_bci(), code_size());
2091   _work_list = NULL;
2092 
2093   _ciblock_count = _methodBlocks-&gt;num_blocks();
2094   _idx_to_blocklist = NEW_ARENA_ARRAY(arena(), GrowableArray&lt;Block*&gt;*, _ciblock_count);
2095   for (int i = 0; i &lt; _ciblock_count; i++) {
2096     _idx_to_blocklist[i] = NULL;
2097   }
2098   _block_map = NULL;  // until all blocks are seen
2099   _jsr_count = 0;
2100   _jsr_records = NULL;
2101 }
2102 
2103 // ------------------------------------------------------------------
2104 // ciTypeFlow::work_list_next
2105 //
2106 // Get the next basic block from our work list.
2107 ciTypeFlow::Block* ciTypeFlow::work_list_next() {
2108   assert(!work_list_empty(), &quot;work list must not be empty&quot;);
2109   Block* next_block = _work_list;
2110   _work_list = next_block-&gt;next();
2111   next_block-&gt;set_next(NULL);
2112   next_block-&gt;set_on_work_list(false);
2113   return next_block;
2114 }
2115 
2116 // ------------------------------------------------------------------
2117 // ciTypeFlow::add_to_work_list
2118 //
2119 // Add a basic block to our work list.
2120 // List is sorted by decreasing postorder sort (same as increasing RPO)
2121 void ciTypeFlow::add_to_work_list(ciTypeFlow::Block* block) {
2122   assert(!block-&gt;is_on_work_list(), &quot;must not already be on work list&quot;);
2123 
2124   if (CITraceTypeFlow) {
2125     tty-&gt;print(&quot;&gt;&gt; Adding block &quot;);
2126     block-&gt;print_value_on(tty);
2127     tty-&gt;print_cr(&quot; to the work list : &quot;);
2128   }
2129 
2130   block-&gt;set_on_work_list(true);
2131 
2132   // decreasing post order sort
2133 
2134   Block* prev = NULL;
2135   Block* current = _work_list;
2136   int po = block-&gt;post_order();
2137   while (current != NULL) {
2138     if (!current-&gt;has_post_order() || po &gt; current-&gt;post_order())
2139       break;
2140     prev = current;
2141     current = current-&gt;next();
2142   }
2143   if (prev == NULL) {
2144     block-&gt;set_next(_work_list);
2145     _work_list = block;
2146   } else {
2147     block-&gt;set_next(current);
2148     prev-&gt;set_next(block);
2149   }
2150 
2151   if (CITraceTypeFlow) {
2152     tty-&gt;cr();
2153   }
2154 }
2155 
2156 // ------------------------------------------------------------------
2157 // ciTypeFlow::block_at
2158 //
2159 // Return the block beginning at bci which has a JsrSet compatible
2160 // with jsrs.
2161 ciTypeFlow::Block* ciTypeFlow::block_at(int bci, ciTypeFlow::JsrSet* jsrs, CreateOption option) {
2162   // First find the right ciBlock.
2163   if (CITraceTypeFlow) {
2164     tty-&gt;print(&quot;&gt;&gt; Requesting block for %d/&quot;, bci);
2165     jsrs-&gt;print_on(tty);
2166     tty-&gt;cr();
2167   }
2168 
2169   ciBlock* ciblk = _methodBlocks-&gt;block_containing(bci);
2170   assert(ciblk-&gt;start_bci() == bci, &quot;bad ciBlock boundaries&quot;);
2171   Block* block = get_block_for(ciblk-&gt;index(), jsrs, option);
2172 
2173   assert(block == NULL? (option == no_create): block-&gt;is_backedge_copy() == (option == create_backedge_copy), &quot;create option consistent with result&quot;);
2174 
2175   if (CITraceTypeFlow) {
2176     if (block != NULL) {
2177       tty-&gt;print(&quot;&gt;&gt; Found block &quot;);
2178       block-&gt;print_value_on(tty);
2179       tty-&gt;cr();
2180     } else {
2181       tty-&gt;print_cr(&quot;&gt;&gt; No such block.&quot;);
2182     }
2183   }
2184 
2185   return block;
2186 }
2187 
2188 // ------------------------------------------------------------------
2189 // ciTypeFlow::make_jsr_record
2190 //
2191 // Make a JsrRecord for a given (entry, return) pair, if such a record
2192 // does not already exist.
2193 ciTypeFlow::JsrRecord* ciTypeFlow::make_jsr_record(int entry_address,
2194                                                    int return_address) {
2195   if (_jsr_records == NULL) {
2196     _jsr_records = new (arena()) GrowableArray&lt;JsrRecord*&gt;(arena(),
2197                                                            _jsr_count,
2198                                                            0,
2199                                                            NULL);
2200   }
2201   JsrRecord* record = NULL;
2202   int len = _jsr_records-&gt;length();
2203   for (int i = 0; i &lt; len; i++) {
2204     JsrRecord* record = _jsr_records-&gt;at(i);
2205     if (record-&gt;entry_address() == entry_address &amp;&amp;
2206         record-&gt;return_address() == return_address) {
2207       return record;
2208     }
2209   }
2210 
2211   record = new (arena()) JsrRecord(entry_address, return_address);
2212   _jsr_records-&gt;append(record);
2213   return record;
2214 }
2215 
2216 // ------------------------------------------------------------------
2217 // ciTypeFlow::flow_exceptions
2218 //
2219 // Merge the current state into all exceptional successors at the
2220 // current point in the code.
2221 void ciTypeFlow::flow_exceptions(GrowableArray&lt;ciTypeFlow::Block*&gt;* exceptions,
2222                                  GrowableArray&lt;ciInstanceKlass*&gt;* exc_klasses,
2223                                  ciTypeFlow::StateVector* state) {
2224   int len = exceptions-&gt;length();
2225   assert(exc_klasses-&gt;length() == len, &quot;must have same length&quot;);
2226   for (int i = 0; i &lt; len; i++) {
2227     Block* block = exceptions-&gt;at(i);
2228     ciInstanceKlass* exception_klass = exc_klasses-&gt;at(i);
2229 
2230     if (!exception_klass-&gt;is_loaded()) {
2231       // Do not compile any code for unloaded exception types.
2232       // Following compiler passes are responsible for doing this also.
2233       continue;
2234     }
2235 
2236     if (block-&gt;meet_exception(exception_klass, state)) {
2237       // Block was modified and has PO.  Add it to the work list.
2238       if (block-&gt;has_post_order() &amp;&amp;
2239           !block-&gt;is_on_work_list()) {
2240         add_to_work_list(block);
2241       }
2242     }
2243   }
2244 }
2245 
2246 // ------------------------------------------------------------------
2247 // ciTypeFlow::flow_successors
2248 //
2249 // Merge the current state into all successors at the current point
2250 // in the code.
2251 void ciTypeFlow::flow_successors(GrowableArray&lt;ciTypeFlow::Block*&gt;* successors,
2252                                  ciTypeFlow::StateVector* state) {
2253   int len = successors-&gt;length();
2254   for (int i = 0; i &lt; len; i++) {
2255     Block* block = successors-&gt;at(i);
2256     if (block-&gt;meet(state)) {
2257       // Block was modified and has PO.  Add it to the work list.
2258       if (block-&gt;has_post_order() &amp;&amp;
2259           !block-&gt;is_on_work_list()) {
2260         add_to_work_list(block);
2261       }
2262     }
2263   }
2264 }
2265 
2266 // ------------------------------------------------------------------
2267 // ciTypeFlow::can_trap
2268 //
2269 // Tells if a given instruction is able to generate an exception edge.
2270 bool ciTypeFlow::can_trap(ciBytecodeStream&amp; str) {
2271   // Cf. GenerateOopMap::do_exception_edge.
2272   if (!Bytecodes::can_trap(str.cur_bc()))  return false;
2273 
2274   switch (str.cur_bc()) {
2275     // %%% FIXME: ldc of Class can generate an exception
2276     case Bytecodes::_ldc:
2277     case Bytecodes::_ldc_w:
2278     case Bytecodes::_ldc2_w:
2279     case Bytecodes::_aload_0:
2280       // These bytecodes can trap for rewriting.  We need to assume that
2281       // they do not throw exceptions to make the monitor analysis work.
2282       return false;
2283 
2284     case Bytecodes::_ireturn:
2285     case Bytecodes::_lreturn:
2286     case Bytecodes::_freturn:
2287     case Bytecodes::_dreturn:
2288     case Bytecodes::_areturn:
2289     case Bytecodes::_return:
2290       // We can assume the monitor stack is empty in this analysis.
2291       return false;
2292 
2293     case Bytecodes::_monitorexit:
2294       // We can assume monitors are matched in this analysis.
2295       return false;
2296 
2297     default:
2298       return true;
2299   }
2300 }
2301 
2302 // ------------------------------------------------------------------
2303 // ciTypeFlow::clone_loop_heads
2304 //
2305 // Clone the loop heads
2306 bool ciTypeFlow::clone_loop_heads(Loop* lp, StateVector* temp_vector, JsrSet* temp_set) {
2307   bool rslt = false;
2308   for (PreorderLoops iter(loop_tree_root()); !iter.done(); iter.next()) {
2309     lp = iter.current();
2310     Block* head = lp-&gt;head();
2311     if (lp == loop_tree_root() ||
2312         lp-&gt;is_irreducible() ||
2313         !head-&gt;is_clonable_exit(lp))
2314       continue;
2315 
2316     // Avoid BoxLock merge.
2317     if (EliminateNestedLocks &amp;&amp; head-&gt;has_monitorenter())
2318       continue;
2319 
2320     // check not already cloned
2321     if (head-&gt;backedge_copy_count() != 0)
2322       continue;
2323 
2324     // Don&#39;t clone head of OSR loop to get correct types in start block.
2325     if (is_osr_flow() &amp;&amp; head-&gt;start() == start_bci())
2326       continue;
2327 
2328     // check _no_ shared head below us
2329     Loop* ch;
2330     for (ch = lp-&gt;child(); ch != NULL &amp;&amp; ch-&gt;head() != head; ch = ch-&gt;sibling());
2331     if (ch != NULL)
2332       continue;
2333 
2334     // Clone head
2335     Block* new_head = head-&gt;looping_succ(lp);
2336     Block* clone = clone_loop_head(lp, temp_vector, temp_set);
2337     // Update lp&#39;s info
2338     clone-&gt;set_loop(lp);
2339     lp-&gt;set_head(new_head);
2340     lp-&gt;set_tail(clone);
2341     // And move original head into outer loop
2342     head-&gt;set_loop(lp-&gt;parent());
2343 
2344     rslt = true;
2345   }
2346   return rslt;
2347 }
2348 
2349 // ------------------------------------------------------------------
2350 // ciTypeFlow::clone_loop_head
2351 //
2352 // Clone lp&#39;s head and replace tail&#39;s successors with clone.
2353 //
2354 //  |
2355 //  v
2356 // head &lt;-&gt; body
2357 //  |
2358 //  v
2359 // exit
2360 //
2361 // new_head
2362 //
2363 //  |
2364 //  v
2365 // head ----------\
2366 //  |             |
2367 //  |             v
2368 //  |  clone &lt;-&gt; body
2369 //  |    |
2370 //  | /--/
2371 //  | |
2372 //  v v
2373 // exit
2374 //
2375 ciTypeFlow::Block* ciTypeFlow::clone_loop_head(Loop* lp, StateVector* temp_vector, JsrSet* temp_set) {
2376   Block* head = lp-&gt;head();
2377   Block* tail = lp-&gt;tail();
2378   if (CITraceTypeFlow) {
2379     tty-&gt;print(&quot;&gt;&gt; Requesting clone of loop head &quot;); head-&gt;print_value_on(tty);
2380     tty-&gt;print(&quot;  for predecessor &quot;);                tail-&gt;print_value_on(tty);
2381     tty-&gt;cr();
2382   }
2383   Block* clone = block_at(head-&gt;start(), head-&gt;jsrs(), create_backedge_copy);
2384   assert(clone-&gt;backedge_copy_count() == 1, &quot;one backedge copy for all back edges&quot;);
2385 
2386   assert(!clone-&gt;has_pre_order(), &quot;just created&quot;);
2387   clone-&gt;set_next_pre_order();
2388 
2389   // Insert clone after (orig) tail in reverse post order
2390   clone-&gt;set_rpo_next(tail-&gt;rpo_next());
2391   tail-&gt;set_rpo_next(clone);
2392 
2393   // tail-&gt;head becomes tail-&gt;clone
2394   for (SuccIter iter(tail); !iter.done(); iter.next()) {
2395     if (iter.succ() == head) {
2396       iter.set_succ(clone);
2397       // Update predecessor information
2398       head-&gt;predecessors()-&gt;remove(tail);
2399       clone-&gt;predecessors()-&gt;append(tail);
2400     }
2401   }
2402   flow_block(tail, temp_vector, temp_set);
2403   if (head == tail) {
2404     // For self-loops, clone-&gt;head becomes clone-&gt;clone
2405     flow_block(clone, temp_vector, temp_set);
2406     for (SuccIter iter(clone); !iter.done(); iter.next()) {
2407       if (iter.succ() == head) {
2408         iter.set_succ(clone);
2409         // Update predecessor information
2410         head-&gt;predecessors()-&gt;remove(clone);
2411         clone-&gt;predecessors()-&gt;append(clone);
2412         break;
2413       }
2414     }
2415   }
2416   flow_block(clone, temp_vector, temp_set);
2417 
2418   return clone;
2419 }
2420 
2421 // ------------------------------------------------------------------
2422 // ciTypeFlow::flow_block
2423 //
2424 // Interpret the effects of the bytecodes on the incoming state
2425 // vector of a basic block.  Push the changed state to succeeding
2426 // basic blocks.
2427 void ciTypeFlow::flow_block(ciTypeFlow::Block* block,
2428                             ciTypeFlow::StateVector* state,
2429                             ciTypeFlow::JsrSet* jsrs) {
2430   if (CITraceTypeFlow) {
2431     tty-&gt;print(&quot;\n&gt;&gt; ANALYZING BLOCK : &quot;);
2432     tty-&gt;cr();
2433     block-&gt;print_on(tty);
2434   }
2435   assert(block-&gt;has_pre_order(), &quot;pre-order is assigned before 1st flow&quot;);
2436 
2437   int start = block-&gt;start();
2438   int limit = block-&gt;limit();
2439   int control = block-&gt;control();
2440   if (control != ciBlock::fall_through_bci) {
2441     limit = control;
2442   }
2443 
2444   // Grab the state from the current block.
2445   block-&gt;copy_state_into(state);
2446   state-&gt;def_locals()-&gt;clear();
2447 
2448   GrowableArray&lt;Block*&gt;*           exceptions = block-&gt;exceptions();
2449   GrowableArray&lt;ciInstanceKlass*&gt;* exc_klasses = block-&gt;exc_klasses();
2450   bool has_exceptions = exceptions-&gt;length() &gt; 0;
2451 
2452   bool exceptions_used = false;
2453 
2454   ciBytecodeStream str(method());
2455   str.reset_to_bci(start);
2456   Bytecodes::Code code;
2457   while ((code = str.next()) != ciBytecodeStream::EOBC() &amp;&amp;
2458          str.cur_bci() &lt; limit) {
2459     // Check for exceptional control flow from this point.
2460     if (has_exceptions &amp;&amp; can_trap(str)) {
2461       flow_exceptions(exceptions, exc_klasses, state);
2462       exceptions_used = true;
2463     }
2464     // Apply the effects of the current bytecode to our state.
2465     bool res = state-&gt;apply_one_bytecode(&amp;str);
2466 
2467     // Watch for bailouts.
2468     if (failing())  return;
2469 
2470     if (str.cur_bc() == Bytecodes::_monitorenter) {
2471       block-&gt;set_has_monitorenter();
2472     }
2473 
2474     if (res) {
2475 
2476       // We have encountered a trap.  Record it in this block.
2477       block-&gt;set_trap(state-&gt;trap_bci(), state-&gt;trap_index());
2478 
2479       if (CITraceTypeFlow) {
2480         tty-&gt;print_cr(&quot;&gt;&gt; Found trap&quot;);
2481         block-&gt;print_on(tty);
2482       }
2483 
2484       // Save set of locals defined in this block
2485       block-&gt;def_locals()-&gt;add(state-&gt;def_locals());
2486 
2487       // Record (no) successors.
2488       block-&gt;successors(&amp;str, state, jsrs);
2489 
2490       assert(!has_exceptions || exceptions_used, &quot;Not removing exceptions&quot;);
2491 
2492       // Discontinue interpretation of this Block.
2493       return;
2494     }
2495   }
2496 
2497   GrowableArray&lt;Block*&gt;* successors = NULL;
2498   if (control != ciBlock::fall_through_bci) {
2499     // Check for exceptional control flow from this point.
2500     if (has_exceptions &amp;&amp; can_trap(str)) {
2501       flow_exceptions(exceptions, exc_klasses, state);
2502       exceptions_used = true;
2503     }
2504 
2505     // Fix the JsrSet to reflect effect of the bytecode.
2506     block-&gt;copy_jsrs_into(jsrs);
2507     jsrs-&gt;apply_control(this, &amp;str, state);
2508 
2509     // Find successor edges based on old state and new JsrSet.
2510     successors = block-&gt;successors(&amp;str, state, jsrs);
2511 
2512     // Apply the control changes to the state.
2513     state-&gt;apply_one_bytecode(&amp;str);
2514   } else {
2515     // Fall through control
2516     successors = block-&gt;successors(&amp;str, NULL, NULL);
2517   }
2518 
2519   // Save set of locals defined in this block
2520   block-&gt;def_locals()-&gt;add(state-&gt;def_locals());
2521 
2522   // Remove untaken exception paths
2523   if (!exceptions_used)
2524     exceptions-&gt;clear();
2525 
2526   // Pass our state to successors.
2527   flow_successors(successors, state);
2528 }
2529 
2530 // ------------------------------------------------------------------
2531 // ciTypeFlow::PreOrderLoops::next
2532 //
2533 // Advance to next loop tree using a preorder, left-to-right traversal.
2534 void ciTypeFlow::PreorderLoops::next() {
2535   assert(!done(), &quot;must not be done.&quot;);
2536   if (_current-&gt;child() != NULL) {
2537     _current = _current-&gt;child();
2538   } else if (_current-&gt;sibling() != NULL) {
2539     _current = _current-&gt;sibling();
2540   } else {
2541     while (_current != _root &amp;&amp; _current-&gt;sibling() == NULL) {
2542       _current = _current-&gt;parent();
2543     }
2544     if (_current == _root) {
2545       _current = NULL;
2546       assert(done(), &quot;must be done.&quot;);
2547     } else {
2548       assert(_current-&gt;sibling() != NULL, &quot;must be more to do&quot;);
2549       _current = _current-&gt;sibling();
2550     }
2551   }
2552 }
2553 
2554 // ------------------------------------------------------------------
2555 // ciTypeFlow::Loop::sorted_merge
2556 //
2557 // Merge the branch lp into this branch, sorting on the loop head
2558 // pre_orders. Returns the leaf of the merged branch.
2559 // Child and sibling pointers will be setup later.
2560 // Sort is (looking from leaf towards the root)
2561 //  descending on primary key: loop head&#39;s pre_order, and
2562 //  ascending  on secondary key: loop tail&#39;s pre_order.
2563 ciTypeFlow::Loop* ciTypeFlow::Loop::sorted_merge(Loop* lp) {
2564   Loop* leaf = this;
2565   Loop* prev = NULL;
2566   Loop* current = leaf;
2567   while (lp != NULL) {
2568     int lp_pre_order = lp-&gt;head()-&gt;pre_order();
2569     // Find insertion point for &quot;lp&quot;
2570     while (current != NULL) {
2571       if (current == lp)
2572         return leaf; // Already in list
2573       if (current-&gt;head()-&gt;pre_order() &lt; lp_pre_order)
2574         break;
2575       if (current-&gt;head()-&gt;pre_order() == lp_pre_order &amp;&amp;
2576           current-&gt;tail()-&gt;pre_order() &gt; lp-&gt;tail()-&gt;pre_order()) {
2577         break;
2578       }
2579       prev = current;
2580       current = current-&gt;parent();
2581     }
2582     Loop* next_lp = lp-&gt;parent(); // Save future list of items to insert
2583     // Insert lp before current
2584     lp-&gt;set_parent(current);
2585     if (prev != NULL) {
2586       prev-&gt;set_parent(lp);
2587     } else {
2588       leaf = lp;
2589     }
2590     prev = lp;     // Inserted item is new prev[ious]
2591     lp = next_lp;  // Next item to insert
2592   }
2593   return leaf;
2594 }
2595 
2596 // ------------------------------------------------------------------
2597 // ciTypeFlow::build_loop_tree
2598 //
2599 // Incrementally build loop tree.
2600 void ciTypeFlow::build_loop_tree(Block* blk) {
2601   assert(!blk-&gt;is_post_visited(), &quot;precondition&quot;);
2602   Loop* innermost = NULL; // merge of loop tree branches over all successors
2603 
2604   for (SuccIter iter(blk); !iter.done(); iter.next()) {
2605     Loop*  lp   = NULL;
2606     Block* succ = iter.succ();
2607     if (!succ-&gt;is_post_visited()) {
2608       // Found backedge since predecessor post visited, but successor is not
2609       assert(succ-&gt;pre_order() &lt;= blk-&gt;pre_order(), &quot;should be backedge&quot;);
2610 
2611       // Create a LoopNode to mark this loop.
2612       lp = new (arena()) Loop(succ, blk);
2613       if (succ-&gt;loop() == NULL)
2614         succ-&gt;set_loop(lp);
2615       // succ-&gt;loop will be updated to innermost loop on a later call, when blk==succ
2616 
2617     } else {  // Nested loop
2618       lp = succ-&gt;loop();
2619 
2620       // If succ is loop head, find outer loop.
2621       while (lp != NULL &amp;&amp; lp-&gt;head() == succ) {
2622         lp = lp-&gt;parent();
2623       }
2624       if (lp == NULL) {
2625         // Infinite loop, it&#39;s parent is the root
2626         lp = loop_tree_root();
2627       }
2628     }
2629 
2630     // Check for irreducible loop.
2631     // Successor has already been visited. If the successor&#39;s loop head
2632     // has already been post-visited, then this is another entry into the loop.
2633     while (lp-&gt;head()-&gt;is_post_visited() &amp;&amp; lp != loop_tree_root()) {
2634       _has_irreducible_entry = true;
2635       lp-&gt;set_irreducible(succ);
2636       if (!succ-&gt;is_on_work_list()) {
2637         // Assume irreducible entries need more data flow
2638         add_to_work_list(succ);
2639       }
2640       Loop* plp = lp-&gt;parent();
2641       if (plp == NULL) {
2642         // This only happens for some irreducible cases.  The parent
2643         // will be updated during a later pass.
2644         break;
2645       }
2646       lp = plp;
2647     }
2648 
2649     // Merge loop tree branch for all successors.
2650     innermost = innermost == NULL ? lp : innermost-&gt;sorted_merge(lp);
2651 
2652   } // end loop
2653 
2654   if (innermost == NULL) {
2655     assert(blk-&gt;successors()-&gt;length() == 0, &quot;CFG exit&quot;);
2656     blk-&gt;set_loop(loop_tree_root());
2657   } else if (innermost-&gt;head() == blk) {
2658     // If loop header, complete the tree pointers
2659     if (blk-&gt;loop() != innermost) {
2660 #ifdef ASSERT
2661       assert(blk-&gt;loop()-&gt;head() == innermost-&gt;head(), &quot;same head&quot;);
2662       Loop* dl;
2663       for (dl = innermost; dl != NULL &amp;&amp; dl != blk-&gt;loop(); dl = dl-&gt;parent());
2664       assert(dl == blk-&gt;loop(), &quot;blk-&gt;loop() already in innermost list&quot;);
2665 #endif
2666       blk-&gt;set_loop(innermost);
2667     }
2668     innermost-&gt;def_locals()-&gt;add(blk-&gt;def_locals());
2669     Loop* l = innermost;
2670     Loop* p = l-&gt;parent();
2671     while (p &amp;&amp; l-&gt;head() == blk) {
2672       l-&gt;set_sibling(p-&gt;child());  // Put self on parents &#39;next child&#39;
2673       p-&gt;set_child(l);             // Make self the first child of parent
2674       p-&gt;def_locals()-&gt;add(l-&gt;def_locals());
2675       l = p;                       // Walk up the parent chain
2676       p = l-&gt;parent();
2677     }
2678   } else {
2679     blk-&gt;set_loop(innermost);
2680     innermost-&gt;def_locals()-&gt;add(blk-&gt;def_locals());
2681   }
2682 }
2683 
2684 // ------------------------------------------------------------------
2685 // ciTypeFlow::Loop::contains
2686 //
2687 // Returns true if lp is nested loop.
2688 bool ciTypeFlow::Loop::contains(ciTypeFlow::Loop* lp) const {
2689   assert(lp != NULL, &quot;&quot;);
2690   if (this == lp || head() == lp-&gt;head()) return true;
2691   int depth1 = depth();
2692   int depth2 = lp-&gt;depth();
2693   if (depth1 &gt; depth2)
2694     return false;
2695   while (depth1 &lt; depth2) {
2696     depth2--;
2697     lp = lp-&gt;parent();
2698   }
2699   return this == lp;
2700 }
2701 
2702 // ------------------------------------------------------------------
2703 // ciTypeFlow::Loop::depth
2704 //
2705 // Loop depth
2706 int ciTypeFlow::Loop::depth() const {
2707   int dp = 0;
2708   for (Loop* lp = this-&gt;parent(); lp != NULL; lp = lp-&gt;parent())
2709     dp++;
2710   return dp;
2711 }
2712 
2713 #ifndef PRODUCT
2714 // ------------------------------------------------------------------
2715 // ciTypeFlow::Loop::print
2716 void ciTypeFlow::Loop::print(outputStream* st, int indent) const {
2717   for (int i = 0; i &lt; indent; i++) st-&gt;print(&quot; &quot;);
2718   st-&gt;print(&quot;%d&lt;-%d %s&quot;,
2719             is_root() ? 0 : this-&gt;head()-&gt;pre_order(),
2720             is_root() ? 0 : this-&gt;tail()-&gt;pre_order(),
2721             is_irreducible()?&quot; irr&quot;:&quot;&quot;);
2722   st-&gt;print(&quot; defs: &quot;);
2723   def_locals()-&gt;print_on(st, _head-&gt;outer()-&gt;method()-&gt;max_locals());
2724   st-&gt;cr();
2725   for (Loop* ch = child(); ch != NULL; ch = ch-&gt;sibling())
2726     ch-&gt;print(st, indent+2);
2727 }
2728 #endif
2729 
2730 // ------------------------------------------------------------------
2731 // ciTypeFlow::df_flow_types
2732 //
2733 // Perform the depth first type flow analysis. Helper for flow_types.
2734 void ciTypeFlow::df_flow_types(Block* start,
2735                                bool do_flow,
2736                                StateVector* temp_vector,
2737                                JsrSet* temp_set) {
2738   int dft_len = 100;
2739   GrowableArray&lt;Block*&gt; stk(dft_len);
2740 
2741   ciBlock* dummy = _methodBlocks-&gt;make_dummy_block();
2742   JsrSet* root_set = new JsrSet(NULL, 0);
2743   Block* root_head = new (arena()) Block(this, dummy, root_set);
2744   Block* root_tail = new (arena()) Block(this, dummy, root_set);
2745   root_head-&gt;set_pre_order(0);
2746   root_head-&gt;set_post_order(0);
2747   root_tail-&gt;set_pre_order(max_jint);
2748   root_tail-&gt;set_post_order(max_jint);
2749   set_loop_tree_root(new (arena()) Loop(root_head, root_tail));
2750 
2751   stk.push(start);
2752 
2753   _next_pre_order = 0;  // initialize pre_order counter
2754   _rpo_list = NULL;
2755   int next_po = 0;      // initialize post_order counter
2756 
2757   // Compute RPO and the control flow graph
2758   int size;
2759   while ((size = stk.length()) &gt; 0) {
2760     Block* blk = stk.top(); // Leave node on stack
2761     if (!blk-&gt;is_visited()) {
2762       // forward arc in graph
2763       assert (!blk-&gt;has_pre_order(), &quot;&quot;);
2764       blk-&gt;set_next_pre_order();
2765 
2766       if (_next_pre_order &gt;= (int)Compile::current()-&gt;max_node_limit() / 2) {
2767         // Too many basic blocks.  Bail out.
2768         // This can happen when try/finally constructs are nested to depth N,
2769         // and there is O(2**N) cloning of jsr bodies.  See bug 4697245!
2770         // &quot;MaxNodeLimit / 2&quot; is used because probably the parser will
2771         // generate at least twice that many nodes and bail out.
2772         record_failure(&quot;too many basic blocks&quot;);
2773         return;
2774       }
2775       if (do_flow) {
2776         flow_block(blk, temp_vector, temp_set);
2777         if (failing()) return; // Watch for bailouts.
2778       }
2779     } else if (!blk-&gt;is_post_visited()) {
2780       // cross or back arc
2781       for (SuccIter iter(blk); !iter.done(); iter.next()) {
2782         Block* succ = iter.succ();
2783         if (!succ-&gt;is_visited()) {
2784           stk.push(succ);
2785         }
2786       }
2787       if (stk.length() == size) {
2788         // There were no additional children, post visit node now
2789         stk.pop(); // Remove node from stack
2790 
2791         build_loop_tree(blk);
2792         blk-&gt;set_post_order(next_po++);   // Assign post order
2793         prepend_to_rpo_list(blk);
2794         assert(blk-&gt;is_post_visited(), &quot;&quot;);
2795 
2796         if (blk-&gt;is_loop_head() &amp;&amp; !blk-&gt;is_on_work_list()) {
2797           // Assume loop heads need more data flow
2798           add_to_work_list(blk);
2799         }
2800       }
2801     } else {
2802       stk.pop(); // Remove post-visited node from stack
2803     }
2804   }
2805 }
2806 
2807 // ------------------------------------------------------------------
2808 // ciTypeFlow::flow_types
2809 //
2810 // Perform the type flow analysis, creating and cloning Blocks as
2811 // necessary.
2812 void ciTypeFlow::flow_types() {
2813   ResourceMark rm;
2814   StateVector* temp_vector = new StateVector(this);
2815   JsrSet* temp_set = new JsrSet(NULL, 16);
2816 
2817   // Create the method entry block.
2818   Block* start = block_at(start_bci(), temp_set);
2819 
2820   // Load the initial state into it.
2821   const StateVector* start_state = get_start_state();
2822   if (failing())  return;
2823   start-&gt;meet(start_state);
2824 
2825   // Depth first visit
2826   df_flow_types(start, true /*do flow*/, temp_vector, temp_set);
2827 
2828   if (failing())  return;
2829   assert(_rpo_list == start, &quot;must be start&quot;);
2830 
2831   // Any loops found?
2832   if (loop_tree_root()-&gt;child() != NULL &amp;&amp;
2833       env()-&gt;comp_level() &gt;= CompLevel_full_optimization) {
2834       // Loop optimizations are not performed on Tier1 compiles.
2835 
2836     bool changed = clone_loop_heads(loop_tree_root(), temp_vector, temp_set);
2837 
2838     // If some loop heads were cloned, recompute postorder and loop tree
2839     if (changed) {
2840       loop_tree_root()-&gt;set_child(NULL);
2841       for (Block* blk = _rpo_list; blk != NULL;) {
2842         Block* next = blk-&gt;rpo_next();
2843         blk-&gt;df_init();
2844         blk = next;
2845       }
2846       df_flow_types(start, false /*no flow*/, temp_vector, temp_set);
2847     }
2848   }
2849 
2850   if (CITraceTypeFlow) {
2851     tty-&gt;print_cr(&quot;\nLoop tree&quot;);
2852     loop_tree_root()-&gt;print();
2853   }
2854 
2855   // Continue flow analysis until fixed point reached
2856 
2857   debug_only(int max_block = _next_pre_order;)
2858 
2859   while (!work_list_empty()) {
2860     Block* blk = work_list_next();
2861     assert (blk-&gt;has_post_order(), &quot;post order assigned above&quot;);
2862 
2863     flow_block(blk, temp_vector, temp_set);
2864 
2865     assert (max_block == _next_pre_order, &quot;no new blocks&quot;);
2866     assert (!failing(), &quot;no more bailouts&quot;);
2867   }
2868 }
2869 
2870 // ------------------------------------------------------------------
2871 // ciTypeFlow::map_blocks
2872 //
2873 // Create the block map, which indexes blocks in reverse post-order.
2874 void ciTypeFlow::map_blocks() {
2875   assert(_block_map == NULL, &quot;single initialization&quot;);
2876   int block_ct = _next_pre_order;
2877   _block_map = NEW_ARENA_ARRAY(arena(), Block*, block_ct);
2878   assert(block_ct == block_count(), &quot;&quot;);
2879 
2880   Block* blk = _rpo_list;
2881   for (int m = 0; m &lt; block_ct; m++) {
2882     int rpo = blk-&gt;rpo();
2883     assert(rpo == m, &quot;should be sequential&quot;);
2884     _block_map[rpo] = blk;
2885     blk = blk-&gt;rpo_next();
2886   }
2887   assert(blk == NULL, &quot;should be done&quot;);
2888 
2889   for (int j = 0; j &lt; block_ct; j++) {
2890     assert(_block_map[j] != NULL, &quot;must not drop any blocks&quot;);
2891     Block* block = _block_map[j];
2892     // Remove dead blocks from successor lists:
2893     for (int e = 0; e &lt;= 1; e++) {
2894       GrowableArray&lt;Block*&gt;* l = e? block-&gt;exceptions(): block-&gt;successors();
2895       for (int k = 0; k &lt; l-&gt;length(); k++) {
2896         Block* s = l-&gt;at(k);
2897         if (!s-&gt;has_post_order()) {
2898           if (CITraceTypeFlow) {
2899             tty-&gt;print(&quot;Removing dead %s successor of #%d: &quot;, (e? &quot;exceptional&quot;:  &quot;normal&quot;), block-&gt;pre_order());
2900             s-&gt;print_value_on(tty);
2901             tty-&gt;cr();
2902           }
2903           l-&gt;remove(s);
2904           --k;
2905         }
2906       }
2907     }
2908   }
2909 }
2910 
2911 // ------------------------------------------------------------------
2912 // ciTypeFlow::get_block_for
2913 //
2914 // Find a block with this ciBlock which has a compatible JsrSet.
2915 // If no such block exists, create it, unless the option is no_create.
2916 // If the option is create_backedge_copy, always create a fresh backedge copy.
2917 ciTypeFlow::Block* ciTypeFlow::get_block_for(int ciBlockIndex, ciTypeFlow::JsrSet* jsrs, CreateOption option) {
2918   Arena* a = arena();
2919   GrowableArray&lt;Block*&gt;* blocks = _idx_to_blocklist[ciBlockIndex];
2920   if (blocks == NULL) {
2921     // Query only?
2922     if (option == no_create)  return NULL;
2923 
2924     // Allocate the growable array.
2925     blocks = new (a) GrowableArray&lt;Block*&gt;(a, 4, 0, NULL);
2926     _idx_to_blocklist[ciBlockIndex] = blocks;
2927   }
2928 
2929   if (option != create_backedge_copy) {
2930     int len = blocks-&gt;length();
2931     for (int i = 0; i &lt; len; i++) {
2932       Block* block = blocks-&gt;at(i);
2933       if (!block-&gt;is_backedge_copy() &amp;&amp; block-&gt;is_compatible_with(jsrs)) {
2934         return block;
2935       }
2936     }
2937   }
2938 
2939   // Query only?
2940   if (option == no_create)  return NULL;
2941 
2942   // We did not find a compatible block.  Create one.
2943   Block* new_block = new (a) Block(this, _methodBlocks-&gt;block(ciBlockIndex), jsrs);
2944   if (option == create_backedge_copy)  new_block-&gt;set_backedge_copy(true);
2945   blocks-&gt;append(new_block);
2946   return new_block;
2947 }
2948 
2949 // ------------------------------------------------------------------
2950 // ciTypeFlow::backedge_copy_count
2951 //
2952 int ciTypeFlow::backedge_copy_count(int ciBlockIndex, ciTypeFlow::JsrSet* jsrs) const {
2953   GrowableArray&lt;Block*&gt;* blocks = _idx_to_blocklist[ciBlockIndex];
2954 
2955   if (blocks == NULL) {
2956     return 0;
2957   }
2958 
2959   int count = 0;
2960   int len = blocks-&gt;length();
2961   for (int i = 0; i &lt; len; i++) {
2962     Block* block = blocks-&gt;at(i);
2963     if (block-&gt;is_backedge_copy() &amp;&amp; block-&gt;is_compatible_with(jsrs)) {
2964       count++;
2965     }
2966   }
2967 
2968   return count;
2969 }
2970 
2971 // ------------------------------------------------------------------
2972 // ciTypeFlow::do_flow
2973 //
2974 // Perform type inference flow analysis.
2975 void ciTypeFlow::do_flow() {
2976   if (CITraceTypeFlow) {
2977     tty-&gt;print_cr(&quot;\nPerforming flow analysis on method&quot;);
2978     method()-&gt;print();
2979     if (is_osr_flow())  tty-&gt;print(&quot; at OSR bci %d&quot;, start_bci());
2980     tty-&gt;cr();
2981     method()-&gt;print_codes();
2982   }
2983   if (CITraceTypeFlow) {
2984     tty-&gt;print_cr(&quot;Initial CI Blocks&quot;);
2985     print_on(tty);
2986   }
2987   flow_types();
2988   // Watch for bailouts.
2989   if (failing()) {
2990     return;
2991   }
2992 
2993   map_blocks();
2994 
2995   if (CIPrintTypeFlow || CITraceTypeFlow) {
2996     rpo_print_on(tty);
2997   }
2998 }
2999 
3000 // ------------------------------------------------------------------
3001 // ciTypeFlow::is_dominated_by
3002 //
3003 // Determine if the instruction at bci is dominated by the instruction at dom_bci.
3004 bool ciTypeFlow::is_dominated_by(int bci, int dom_bci) {
3005   assert(!method()-&gt;has_jsrs(), &quot;jsrs are not supported&quot;);
3006 
3007   ResourceMark rm;
3008   JsrSet* jsrs = new ciTypeFlow::JsrSet(NULL);
3009   int        index = _methodBlocks-&gt;block_containing(bci)-&gt;index();
3010   int    dom_index = _methodBlocks-&gt;block_containing(dom_bci)-&gt;index();
3011   Block*     block = get_block_for(index, jsrs, ciTypeFlow::no_create);
3012   Block* dom_block = get_block_for(dom_index, jsrs, ciTypeFlow::no_create);
3013 
3014   // Start block dominates all other blocks
3015   if (start_block()-&gt;rpo() == dom_block-&gt;rpo()) {
3016     return true;
3017   }
3018 
3019   // Dominated[i] is true if block i is dominated by dom_block
3020   int num_blocks = block_count();
3021   bool* dominated = NEW_RESOURCE_ARRAY(bool, num_blocks);
3022   for (int i = 0; i &lt; num_blocks; ++i) {
3023     dominated[i] = true;
3024   }
3025   dominated[start_block()-&gt;rpo()] = false;
3026 
3027   // Iterative dominator algorithm
3028   bool changed = true;
3029   while (changed) {
3030     changed = false;
3031     // Use reverse postorder iteration
3032     for (Block* blk = _rpo_list; blk != NULL; blk = blk-&gt;rpo_next()) {
3033       if (blk-&gt;is_start()) {
3034         // Ignore start block
3035         continue;
3036       }
3037       // The block is dominated if it is the dominating block
3038       // itself or if all predecessors are dominated.
3039       int index = blk-&gt;rpo();
3040       bool dom = (index == dom_block-&gt;rpo());
3041       if (!dom) {
3042         // Check if all predecessors are dominated
3043         dom = true;
3044         for (int i = 0; i &lt; blk-&gt;predecessors()-&gt;length(); ++i) {
3045           Block* pred = blk-&gt;predecessors()-&gt;at(i);
3046           if (!dominated[pred-&gt;rpo()]) {
3047             dom = false;
3048             break;
3049           }
3050         }
3051       }
3052       // Update dominator information
3053       if (dominated[index] != dom) {
3054         changed = true;
3055         dominated[index] = dom;
3056       }
3057     }
3058   }
3059   // block dominated by dom_block?
3060   return dominated[block-&gt;rpo()];
3061 }
3062 
3063 // ------------------------------------------------------------------
3064 // ciTypeFlow::record_failure()
3065 // The ciTypeFlow object keeps track of failure reasons separately from the ciEnv.
3066 // This is required because there is not a 1-1 relation between the ciEnv and
3067 // the TypeFlow passes within a compilation task.  For example, if the compiler
3068 // is considering inlining a method, it will request a TypeFlow.  If that fails,
3069 // the compilation as a whole may continue without the inlining.  Some TypeFlow
3070 // requests are not optional; if they fail the requestor is responsible for
3071 // copying the failure reason up to the ciEnv.  (See Parse::Parse.)
3072 void ciTypeFlow::record_failure(const char* reason) {
3073   if (env()-&gt;log() != NULL) {
3074     env()-&gt;log()-&gt;elem(&quot;failure reason=&#39;%s&#39; phase=&#39;typeflow&#39;&quot;, reason);
3075   }
3076   if (_failure_reason == NULL) {
3077     // Record the first failure reason.
3078     _failure_reason = reason;
3079   }
3080 }
3081 
<a name="17" id="anc17"></a><span class="line-removed">3082 ciType* ciTypeFlow::mark_as_never_null(ciType* type) {</span>
<span class="line-removed">3083   // Wrap the type to carry the information that it is never null</span>
<span class="line-removed">3084   return env()-&gt;make_never_null_wrapper(type);</span>
<span class="line-removed">3085 }</span>
<span class="line-removed">3086 </span>
3087 #ifndef PRODUCT
3088 // ------------------------------------------------------------------
3089 // ciTypeFlow::print_on
3090 void ciTypeFlow::print_on(outputStream* st) const {
3091   // Walk through CI blocks
3092   st-&gt;print_cr(&quot;********************************************************&quot;);
3093   st-&gt;print   (&quot;TypeFlow for &quot;);
3094   method()-&gt;name()-&gt;print_symbol_on(st);
3095   int limit_bci = code_size();
3096   st-&gt;print_cr(&quot;  %d bytes&quot;, limit_bci);
3097   ciMethodBlocks  *mblks = _methodBlocks;
3098   ciBlock* current = NULL;
3099   for (int bci = 0; bci &lt; limit_bci; bci++) {
3100     ciBlock* blk = mblks-&gt;block_containing(bci);
3101     if (blk != NULL &amp;&amp; blk != current) {
3102       current = blk;
3103       current-&gt;print_on(st);
3104 
3105       GrowableArray&lt;Block*&gt;* blocks = _idx_to_blocklist[blk-&gt;index()];
3106       int num_blocks = (blocks == NULL) ? 0 : blocks-&gt;length();
3107 
3108       if (num_blocks == 0) {
3109         st-&gt;print_cr(&quot;  No Blocks&quot;);
3110       } else {
3111         for (int i = 0; i &lt; num_blocks; i++) {
3112           Block* block = blocks-&gt;at(i);
3113           block-&gt;print_on(st);
3114         }
3115       }
3116       st-&gt;print_cr(&quot;--------------------------------------------------------&quot;);
3117       st-&gt;cr();
3118     }
3119   }
3120   st-&gt;print_cr(&quot;********************************************************&quot;);
3121   st-&gt;cr();
3122 }
3123 
3124 void ciTypeFlow::rpo_print_on(outputStream* st) const {
3125   st-&gt;print_cr(&quot;********************************************************&quot;);
3126   st-&gt;print   (&quot;TypeFlow for &quot;);
3127   method()-&gt;name()-&gt;print_symbol_on(st);
3128   int limit_bci = code_size();
3129   st-&gt;print_cr(&quot;  %d bytes&quot;, limit_bci);
3130   for (Block* blk = _rpo_list; blk != NULL; blk = blk-&gt;rpo_next()) {
3131     blk-&gt;print_on(st);
3132     st-&gt;print_cr(&quot;--------------------------------------------------------&quot;);
3133     st-&gt;cr();
3134   }
3135   st-&gt;print_cr(&quot;********************************************************&quot;);
3136   st-&gt;cr();
3137 }
3138 #endif
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
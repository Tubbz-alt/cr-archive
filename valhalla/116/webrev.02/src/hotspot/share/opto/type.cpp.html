<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciField.hpp&quot;
  27 #include &quot;ci/ciMethodData.hpp&quot;
  28 #include &quot;ci/ciTypeFlow.hpp&quot;
  29 #include &quot;ci/ciValueKlass.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;compiler/compileLog.hpp&quot;
  33 #include &quot;libadt/dict.hpp&quot;
  34 #include &quot;memory/oopFactory.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;oops/instanceKlass.hpp&quot;
  37 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  38 #include &quot;oops/objArrayKlass.hpp&quot;
  39 #include &quot;oops/typeArrayKlass.hpp&quot;
  40 #include &quot;opto/matcher.hpp&quot;
  41 #include &quot;opto/node.hpp&quot;
  42 #include &quot;opto/opcodes.hpp&quot;
  43 #include &quot;opto/type.hpp&quot;
  44 #include &quot;utilities/powerOfTwo.hpp&quot;
  45 
  46 // Portions of code courtesy of Clifford Click
  47 
  48 // Optimization - Graph Style
  49 
  50 // Dictionary of types shared among compilations.
  51 Dict* Type::_shared_type_dict = NULL;
  52 const Type::Offset Type::Offset::top(Type::OffsetTop);
  53 const Type::Offset Type::Offset::bottom(Type::OffsetBot);
  54 
  55 const Type::Offset Type::Offset::meet(const Type::Offset other) const {
  56   // Either is &#39;TOP&#39; offset?  Return the other offset!
  57   int offset = other._offset;
  58   if (_offset == OffsetTop) return Offset(offset);
  59   if (offset == OffsetTop) return Offset(_offset);
  60   // If either is different, return &#39;BOTTOM&#39; offset
  61   if (_offset != offset) return bottom;
  62   return Offset(_offset);
  63 }
  64 
  65 const Type::Offset Type::Offset::dual() const {
  66   if (_offset == OffsetTop) return bottom;// Map &#39;TOP&#39; into &#39;BOTTOM&#39;
  67   if (_offset == OffsetBot) return top;// Map &#39;BOTTOM&#39; into &#39;TOP&#39;
  68   return Offset(_offset);               // Map everything else into self
  69 }
  70 
  71 const Type::Offset Type::Offset::add(intptr_t offset) const {
  72   // Adding to &#39;TOP&#39; offset?  Return &#39;TOP&#39;!
  73   if (_offset == OffsetTop || offset == OffsetTop) return top;
  74   // Adding to &#39;BOTTOM&#39; offset?  Return &#39;BOTTOM&#39;!
  75   if (_offset == OffsetBot || offset == OffsetBot) return bottom;
  76   // Addition overflows or &quot;accidentally&quot; equals to OffsetTop? Return &#39;BOTTOM&#39;!
  77   offset += (intptr_t)_offset;
  78   if (offset != (int)offset || offset == OffsetTop) return bottom;
  79 
  80   // assert( _offset &gt;= 0 &amp;&amp; _offset+offset &gt;= 0, &quot;&quot; );
  81   // It is possible to construct a negative offset during PhaseCCP
  82 
  83   return Offset((int)offset);        // Sum valid offsets
  84 }
  85 
  86 void Type::Offset::dump2(outputStream *st) const {
  87   if (_offset == 0) {
  88     return;
  89   } else if (_offset == OffsetTop) {
  90     st-&gt;print(&quot;+top&quot;);
  91   }
  92   else if (_offset == OffsetBot) {
  93     st-&gt;print(&quot;+bot&quot;);
  94   } else if (_offset) {
  95     st-&gt;print(&quot;+%d&quot;, _offset);
  96   }
  97 }
  98 
  99 // Array which maps compiler types to Basic Types
 100 const Type::TypeInfo Type::_type_info[Type::lastype] = {
 101   { Bad,             T_ILLEGAL,    &quot;bad&quot;,           false, Node::NotAMachineReg, relocInfo::none          },  // Bad
 102   { Control,         T_ILLEGAL,    &quot;control&quot;,       false, 0,                    relocInfo::none          },  // Control
 103   { Bottom,          T_VOID,       &quot;top&quot;,           false, 0,                    relocInfo::none          },  // Top
 104   { Bad,             T_INT,        &quot;int:&quot;,          false, Op_RegI,              relocInfo::none          },  // Int
 105   { Bad,             T_LONG,       &quot;long:&quot;,         false, Op_RegL,              relocInfo::none          },  // Long
 106   { Half,            T_VOID,       &quot;half&quot;,          false, 0,                    relocInfo::none          },  // Half
 107   { Bad,             T_NARROWOOP,  &quot;narrowoop:&quot;,    false, Op_RegN,              relocInfo::none          },  // NarrowOop
 108   { Bad,             T_NARROWKLASS,&quot;narrowklass:&quot;,  false, Op_RegN,              relocInfo::none          },  // NarrowKlass
 109   { Bad,             T_ILLEGAL,    &quot;tuple:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Tuple
 110   { Bad,             T_ARRAY,      &quot;array:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Array
 111 
 112 #if defined(PPC64)
 113   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 114   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 115   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 116   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 117   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 118 #elif defined(S390)
 119   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 120   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 121   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
 122   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 123   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 124 #else // all other
 125   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, Op_VecS,              relocInfo::none          },  // VectorS
 126   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
 127   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 128   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
 129   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
 130 #endif
 131   { Bad,             T_INLINE_TYPE, &quot;value:&quot;,       false, Node::NotAMachineReg, relocInfo::none          },  // ValueType
 132   { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
 133   { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
 134   { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
 135   { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
 136   { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
 137   { Bad,             T_METADATA,   &quot;metadata:&quot;,     false, Op_RegP,              relocInfo::metadata_type },  // MetadataPtr
 138   { Bad,             T_METADATA,   &quot;klass:&quot;,        false, Op_RegP,              relocInfo::metadata_type },  // KlassPtr
 139   { Bad,             T_OBJECT,     &quot;func&quot;,          false, 0,                    relocInfo::none          },  // Function
 140   { Abio,            T_ILLEGAL,    &quot;abIO&quot;,          false, 0,                    relocInfo::none          },  // Abio
 141   { Return_Address,  T_ADDRESS,    &quot;return_address&quot;,false, Op_RegP,              relocInfo::none          },  // Return_Address
 142   { Memory,          T_ILLEGAL,    &quot;memory&quot;,        false, 0,                    relocInfo::none          },  // Memory
 143   { FloatBot,        T_FLOAT,      &quot;float_top&quot;,     false, Op_RegF,              relocInfo::none          },  // FloatTop
 144   { FloatCon,        T_FLOAT,      &quot;ftcon:&quot;,        false, Op_RegF,              relocInfo::none          },  // FloatCon
 145   { FloatTop,        T_FLOAT,      &quot;float&quot;,         false, Op_RegF,              relocInfo::none          },  // FloatBot
 146   { DoubleBot,       T_DOUBLE,     &quot;double_top&quot;,    false, Op_RegD,              relocInfo::none          },  // DoubleTop
 147   { DoubleCon,       T_DOUBLE,     &quot;dblcon:&quot;,       false, Op_RegD,              relocInfo::none          },  // DoubleCon
 148   { DoubleTop,       T_DOUBLE,     &quot;double&quot;,        false, Op_RegD,              relocInfo::none          },  // DoubleBot
 149   { Top,             T_ILLEGAL,    &quot;bottom&quot;,        false, 0,                    relocInfo::none          }   // Bottom
 150 };
 151 
 152 // Map ideal registers (machine types) to ideal types
 153 const Type *Type::mreg2type[_last_machine_leaf];
 154 
 155 // Map basic types to canonical Type* pointers.
 156 const Type* Type::     _const_basic_type[T_CONFLICT+1];
 157 
 158 // Map basic types to constant-zero Types.
 159 const Type* Type::            _zero_type[T_CONFLICT+1];
 160 
 161 // Map basic types to array-body alias types.
 162 const TypeAryPtr* TypeAryPtr::_array_body_type[T_CONFLICT+1];
 163 
 164 //=============================================================================
 165 // Convenience common pre-built types.
 166 const Type *Type::ABIO;         // State-of-machine only
 167 const Type *Type::BOTTOM;       // All values
 168 const Type *Type::CONTROL;      // Control only
 169 const Type *Type::DOUBLE;       // All doubles
 170 const Type *Type::FLOAT;        // All floats
 171 const Type *Type::HALF;         // Placeholder half of doublewide type
 172 const Type *Type::MEMORY;       // Abstract store only
 173 const Type *Type::RETURN_ADDRESS;
 174 const Type *Type::TOP;          // No values in set
 175 
 176 //------------------------------get_const_type---------------------------
 177 const Type* Type::get_const_type(ciType* type) {
 178   if (type == NULL) {
 179     return NULL;
 180   } else if (type-&gt;is_primitive_type()) {
 181     return get_const_basic_type(type-&gt;basic_type());
 182   } else {
 183     return TypeOopPtr::make_from_klass(type-&gt;as_klass());
 184   }
 185 }
 186 
 187 //---------------------------array_element_basic_type---------------------------------
 188 // Mapping to the array element&#39;s basic type.
 189 BasicType Type::array_element_basic_type() const {
 190   BasicType bt = basic_type();
 191   if (bt == T_INT) {
 192     if (this == TypeInt::INT)   return T_INT;
 193     if (this == TypeInt::CHAR)  return T_CHAR;
 194     if (this == TypeInt::BYTE)  return T_BYTE;
 195     if (this == TypeInt::BOOL)  return T_BOOLEAN;
 196     if (this == TypeInt::SHORT) return T_SHORT;
 197     return T_VOID;
 198   }
 199   return bt;
 200 }
 201 
 202 // For two instance arrays of same dimension, return the base element types.
 203 // Otherwise or if the arrays have different dimensions, return NULL.
 204 void Type::get_arrays_base_elements(const Type *a1, const Type *a2,
 205                                     const TypeInstPtr **e1, const TypeInstPtr **e2) {
 206 
 207   if (e1) *e1 = NULL;
 208   if (e2) *e2 = NULL;
 209   const TypeAryPtr* a1tap = (a1 == NULL) ? NULL : a1-&gt;isa_aryptr();
 210   const TypeAryPtr* a2tap = (a2 == NULL) ? NULL : a2-&gt;isa_aryptr();
 211 
 212   if (a1tap != NULL &amp;&amp; a2tap != NULL) {
 213     // Handle multidimensional arrays
 214     const TypePtr* a1tp = a1tap-&gt;elem()-&gt;make_ptr();
 215     const TypePtr* a2tp = a2tap-&gt;elem()-&gt;make_ptr();
 216     while (a1tp &amp;&amp; a1tp-&gt;isa_aryptr() &amp;&amp; a2tp &amp;&amp; a2tp-&gt;isa_aryptr()) {
 217       a1tap = a1tp-&gt;is_aryptr();
 218       a2tap = a2tp-&gt;is_aryptr();
 219       a1tp = a1tap-&gt;elem()-&gt;make_ptr();
 220       a2tp = a2tap-&gt;elem()-&gt;make_ptr();
 221     }
 222     if (a1tp &amp;&amp; a1tp-&gt;isa_instptr() &amp;&amp; a2tp &amp;&amp; a2tp-&gt;isa_instptr()) {
 223       if (e1) *e1 = a1tp-&gt;is_instptr();
 224       if (e2) *e2 = a2tp-&gt;is_instptr();
 225     }
 226   }
 227 }
 228 
 229 //---------------------------get_typeflow_type---------------------------------
 230 // Import a type produced by ciTypeFlow.
 231 const Type* Type::get_typeflow_type(ciType* type) {
 232   switch (type-&gt;basic_type()) {
 233 
 234   case ciTypeFlow::StateVector::T_BOTTOM:
 235     assert(type == ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 236     return Type::BOTTOM;
 237 
 238   case ciTypeFlow::StateVector::T_TOP:
 239     assert(type == ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 240     return Type::TOP;
 241 
 242   case ciTypeFlow::StateVector::T_NULL:
 243     assert(type == ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 244     return TypePtr::NULL_PTR;
 245 
 246   case ciTypeFlow::StateVector::T_LONG2:
 247     // The ciTypeFlow pass pushes a long, then the half.
 248     // We do the same.
 249     assert(type == ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 250     return TypeInt::TOP;
 251 
 252   case ciTypeFlow::StateVector::T_DOUBLE2:
 253     // The ciTypeFlow pass pushes double, then the half.
 254     // Our convention is the same.
 255     assert(type == ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 256     return Type::TOP;
 257 
 258   case T_ADDRESS:
 259     assert(type-&gt;is_return_address(), &quot;&quot;);
 260     return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
 261 
 262   case T_INLINE_TYPE: {
 263     ciValueKlass* vk = type-&gt;as_value_klass();
 264     if (vk-&gt;is_scalarizable()) {
 265       return TypeValueType::make(vk);
 266     } else {
 267       return TypeOopPtr::make_from_klass(vk)-&gt;join_speculative(TypePtr::NOTNULL);
 268     }
 269   }
 270 
 271   default:
 272     // make sure we did not mix up the cases:
 273     assert(type != ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 274     assert(type != ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 275     assert(type != ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 276     assert(type != ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 277     assert(type != ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 278     assert(!type-&gt;is_return_address(), &quot;&quot;);
 279 
 280     return Type::get_const_type(type);
 281   }
 282 }
 283 
 284 
 285 //-----------------------make_from_constant------------------------------------
 286 const Type* Type::make_from_constant(ciConstant constant, bool require_constant,
 287                                      int stable_dimension, bool is_narrow_oop,
 288                                      bool is_autobox_cache) {
 289   switch (constant.basic_type()) {
 290     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
 291     case T_CHAR:     return TypeInt::make(constant.as_char());
 292     case T_BYTE:     return TypeInt::make(constant.as_byte());
 293     case T_SHORT:    return TypeInt::make(constant.as_short());
 294     case T_INT:      return TypeInt::make(constant.as_int());
 295     case T_LONG:     return TypeLong::make(constant.as_long());
 296     case T_FLOAT:    return TypeF::make(constant.as_float());
 297     case T_DOUBLE:   return TypeD::make(constant.as_double());
 298     case T_ARRAY:
 299     case T_INLINE_TYPE:
 300     case T_OBJECT: {
 301         const Type* con_type = NULL;
 302         ciObject* oop_constant = constant.as_object();
 303         if (oop_constant-&gt;is_null_object()) {
 304           con_type = Type::get_zero_type(T_OBJECT);
 305         } else {
 306           guarantee(require_constant || oop_constant-&gt;should_be_constant(), &quot;con_type must get computed&quot;);
 307           con_type = TypeOopPtr::make_from_constant(oop_constant, require_constant);
 308           if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; is_autobox_cache) {
 309             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_autobox_cache(true);
 310           }
 311           if (stable_dimension &gt; 0) {
 312             assert(FoldStableValues, &quot;sanity&quot;);
 313             assert(!con_type-&gt;is_zero_type(), &quot;default value for stable field&quot;);
 314             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_stable(true, stable_dimension);
 315           }
 316         }
 317         if (is_narrow_oop) {
 318           con_type = con_type-&gt;make_narrowoop();
 319         }
 320         return con_type;
 321       }
 322     case T_ILLEGAL:
 323       // Invalid ciConstant returned due to OutOfMemoryError in the CI
 324       assert(Compile::current()-&gt;env()-&gt;failing(), &quot;otherwise should not see this&quot;);
 325       return NULL;
 326     default:
 327       // Fall through to failure
 328       return NULL;
 329   }
 330 }
 331 
 332 static ciConstant check_mismatched_access(ciConstant con, BasicType loadbt, bool is_unsigned) {
 333   BasicType conbt = con.basic_type();
 334   switch (conbt) {
 335     case T_BOOLEAN: conbt = T_BYTE;   break;
 336     case T_ARRAY:   conbt = T_OBJECT; break;
 337     case T_INLINE_TYPE: conbt = T_OBJECT; break;
 338     default:                          break;
 339   }
 340   switch (loadbt) {
 341     case T_BOOLEAN:   loadbt = T_BYTE;   break;
 342     case T_NARROWOOP: loadbt = T_OBJECT; break;
 343     case T_ARRAY:     loadbt = T_OBJECT; break;
 344     case T_INLINE_TYPE: loadbt = T_OBJECT; break;
 345     case T_ADDRESS:   loadbt = T_OBJECT; break;
 346     default:                             break;
 347   }
 348   if (conbt == loadbt) {
 349     if (is_unsigned &amp;&amp; conbt == T_BYTE) {
 350       // LoadB (T_BYTE) with a small mask (&lt;=8-bit) is converted to LoadUB (T_BYTE).
 351       return ciConstant(T_INT, con.as_int() &amp; 0xFF);
 352     } else {
 353       return con;
 354     }
 355   }
 356   if (conbt == T_SHORT &amp;&amp; loadbt == T_CHAR) {
 357     // LoadS (T_SHORT) with a small mask (&lt;=16-bit) is converted to LoadUS (T_CHAR).
 358     return ciConstant(T_INT, con.as_int() &amp; 0xFFFF);
 359   }
 360   return ciConstant(); // T_ILLEGAL
 361 }
 362 
 363 // Try to constant-fold a stable array element.
 364 const Type* Type::make_constant_from_array_element(ciArray* array, int off, int stable_dimension,
 365                                                    BasicType loadbt, bool is_unsigned_load) {
 366   // Decode the results of GraphKit::array_element_address.
 367   ciConstant element_value = array-&gt;element_value_by_offset(off);
 368   if (element_value.basic_type() == T_ILLEGAL) {
 369     return NULL; // wrong offset
 370   }
 371   ciConstant con = check_mismatched_access(element_value, loadbt, is_unsigned_load);
 372 
 373   assert(con.basic_type() != T_ILLEGAL, &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 374          type2name(element_value.basic_type()), type2name(loadbt), is_unsigned_load);
 375 
 376   if (con.is_valid() &amp;&amp;          // not a mismatched access
 377       !con.is_null_or_zero()) {  // not a default value
 378     bool is_narrow_oop = (loadbt == T_NARROWOOP);
 379     return Type::make_from_constant(con, /*require_constant=*/true, stable_dimension, is_narrow_oop, /*is_autobox_cache=*/false);
 380   }
 381   return NULL;
 382 }
 383 
 384 const Type* Type::make_constant_from_field(ciInstance* holder, int off, bool is_unsigned_load, BasicType loadbt) {
 385   ciField* field;
 386   ciType* type = holder-&gt;java_mirror_type();
 387   if (type != NULL &amp;&amp; type-&gt;is_instance_klass() &amp;&amp; off &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
 388     // Static field
 389     field = type-&gt;as_instance_klass()-&gt;get_field_by_offset(off, /*is_static=*/true);
 390   } else {
 391     // Instance field
 392     field = holder-&gt;klass()-&gt;as_instance_klass()-&gt;get_field_by_offset(off, /*is_static=*/false);
 393   }
 394   if (field == NULL) {
 395     return NULL; // Wrong offset
 396   }
 397   return Type::make_constant_from_field(field, holder, loadbt, is_unsigned_load);
 398 }
 399 
 400 const Type* Type::make_constant_from_field(ciField* field, ciInstance* holder,
 401                                            BasicType loadbt, bool is_unsigned_load) {
 402   if (!field-&gt;is_constant()) {
 403     return NULL; // Non-constant field
 404   }
 405   ciConstant field_value;
 406   if (field-&gt;is_static()) {
 407     // final static field
 408     field_value = field-&gt;constant_value();
 409   } else if (holder != NULL) {
 410     // final or stable non-static field
 411     // Treat final non-static fields of trusted classes (classes in
 412     // java.lang.invoke and sun.invoke packages and subpackages) as
 413     // compile time constants.
 414     field_value = field-&gt;constant_value_of(holder);
 415   }
 416   if (!field_value.is_valid()) {
 417     return NULL; // Not a constant
 418   }
 419 
 420   ciConstant con = check_mismatched_access(field_value, loadbt, is_unsigned_load);
 421 
 422   assert(con.is_valid(), &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 423          type2name(field_value.basic_type()), type2name(loadbt), is_unsigned_load);
 424 
 425   bool is_stable_array = FoldStableValues &amp;&amp; field-&gt;is_stable() &amp;&amp; field-&gt;type()-&gt;is_array_klass();
 426   int stable_dimension = (is_stable_array ? field-&gt;type()-&gt;as_array_klass()-&gt;dimension() : 0);
 427   bool is_narrow_oop = (loadbt == T_NARROWOOP);
 428 
 429   const Type* con_type = make_from_constant(con, /*require_constant=*/ true,
 430                                             stable_dimension, is_narrow_oop,
 431                                             field-&gt;is_autobox_cache());
 432   if (con_type != NULL &amp;&amp; field-&gt;is_call_site_target()) {
 433     ciCallSite* call_site = holder-&gt;as_call_site();
 434     if (!call_site-&gt;is_fully_initialized_constant_call_site()) {
 435       ciMethodHandle* target = con.as_object()-&gt;as_method_handle();
 436       Compile::current()-&gt;dependencies()-&gt;assert_call_site_target_value(call_site, target);
 437     }
 438   }
 439   return con_type;
 440 }
 441 
 442 //------------------------------make-------------------------------------------
 443 // Create a simple Type, with default empty symbol sets.  Then hashcons it
 444 // and look for an existing copy in the type dictionary.
 445 const Type *Type::make( enum TYPES t ) {
 446   return (new Type(t))-&gt;hashcons();
 447 }
 448 
 449 //------------------------------cmp--------------------------------------------
 450 int Type::cmp( const Type *const t1, const Type *const t2 ) {
 451   if( t1-&gt;_base != t2-&gt;_base )
 452     return 1;                   // Missed badly
 453   assert(t1 != t2 || t1-&gt;eq(t2), &quot;eq must be reflexive&quot;);
 454   return !t1-&gt;eq(t2);           // Return ZERO if equal
 455 }
 456 
 457 const Type* Type::maybe_remove_speculative(bool include_speculative) const {
 458   if (!include_speculative) {
 459     return remove_speculative();
 460   }
 461   return this;
 462 }
 463 
 464 //------------------------------hash-------------------------------------------
 465 int Type::uhash( const Type *const t ) {
 466   return t-&gt;hash();
 467 }
 468 
 469 #define SMALLINT ((juint)3)  // a value too insignificant to consider widening
 470 #define POSITIVE_INFINITE_F 0x7f800000 // hex representation for IEEE 754 single precision positive infinite
 471 #define POSITIVE_INFINITE_D 0x7ff0000000000000 // hex representation for IEEE 754 double precision positive infinite
 472 
 473 //--------------------------Initialize_shared----------------------------------
 474 void Type::Initialize_shared(Compile* current) {
 475   // This method does not need to be locked because the first system
 476   // compilations (stub compilations) occur serially.  If they are
 477   // changed to proceed in parallel, then this section will need
 478   // locking.
 479 
 480   Arena* save = current-&gt;type_arena();
 481   Arena* shared_type_arena = new (mtCompiler)Arena(mtCompiler);
 482 
 483   current-&gt;set_type_arena(shared_type_arena);
 484   _shared_type_dict =
 485     new (shared_type_arena) Dict( (CmpKey)Type::cmp, (Hash)Type::uhash,
 486                                   shared_type_arena, 128 );
 487   current-&gt;set_type_dict(_shared_type_dict);
 488 
 489   // Make shared pre-built types.
 490   CONTROL = make(Control);      // Control only
 491   TOP     = make(Top);          // No values in set
 492   MEMORY  = make(Memory);       // Abstract store only
 493   ABIO    = make(Abio);         // State-of-machine only
 494   RETURN_ADDRESS=make(Return_Address);
 495   FLOAT   = make(FloatBot);     // All floats
 496   DOUBLE  = make(DoubleBot);    // All doubles
 497   BOTTOM  = make(Bottom);       // Everything
 498   HALF    = make(Half);         // Placeholder half of doublewide type
 499 
 500   TypeF::ZERO = TypeF::make(0.0); // Float 0 (positive zero)
 501   TypeF::ONE  = TypeF::make(1.0); // Float 1
 502   TypeF::POS_INF = TypeF::make(jfloat_cast(POSITIVE_INFINITE_F));
 503   TypeF::NEG_INF = TypeF::make(-jfloat_cast(POSITIVE_INFINITE_F));
 504 
 505   TypeD::ZERO = TypeD::make(0.0); // Double 0 (positive zero)
 506   TypeD::ONE  = TypeD::make(1.0); // Double 1
 507   TypeD::POS_INF = TypeD::make(jdouble_cast(POSITIVE_INFINITE_D));
 508   TypeD::NEG_INF = TypeD::make(-jdouble_cast(POSITIVE_INFINITE_D));
 509 
 510   TypeInt::MINUS_1 = TypeInt::make(-1);  // -1
 511   TypeInt::ZERO    = TypeInt::make( 0);  //  0
 512   TypeInt::ONE     = TypeInt::make( 1);  //  1
 513   TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  // 0 or 1, FALSE or TRUE.
 514   TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  // -1, 0 or 1, condition codes
 515   TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  // == TypeInt::MINUS_1
 516   TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  // == TypeInt::ONE
 517   TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  // == TypeInt::ZERO
 518   TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);
 519   TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  // == TypeInt::BOOL
 520   TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); // Bytes
 521   TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); // Unsigned Bytes
 522   TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); // Java chars
 523   TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); // Java shorts
 524   TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); // Non-neg values
 525   TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); // Positive values
 526   TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); // 32-bit integers
 527   TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); // symmetric range
 528   TypeInt::TYPE_DOMAIN  = TypeInt::INT;
 529   // CmpL is overloaded both as the bytecode computation returning
 530   // a trinary (-1,0,+1) integer result AND as an efficient long
 531   // compare returning optimizer ideal-type flags.
 532   assert( TypeInt::CC_LT == TypeInt::MINUS_1, &quot;types must match for CmpL to work&quot; );
 533   assert( TypeInt::CC_GT == TypeInt::ONE,     &quot;types must match for CmpL to work&quot; );
 534   assert( TypeInt::CC_EQ == TypeInt::ZERO,    &quot;types must match for CmpL to work&quot; );
 535   assert( TypeInt::CC_GE == TypeInt::BOOL,    &quot;types must match for CmpL to work&quot; );
 536   assert( (juint)(TypeInt::CC-&gt;_hi - TypeInt::CC-&gt;_lo) &lt;= SMALLINT, &quot;CC is truly small&quot;);
 537 
 538   TypeLong::MINUS_1 = TypeLong::make(-1);        // -1
 539   TypeLong::ZERO    = TypeLong::make( 0);        //  0
 540   TypeLong::ONE     = TypeLong::make( 1);        //  1
 541   TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin); // Non-neg values
 542   TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax); // 64-bit integers
 543   TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin);
 544   TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin);
 545   TypeLong::TYPE_DOMAIN  = TypeLong::LONG;
 546 
 547   const Type **fboth =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 548   fboth[0] = Type::CONTROL;
 549   fboth[1] = Type::CONTROL;
 550   TypeTuple::IFBOTH = TypeTuple::make( 2, fboth );
 551 
 552   const Type **ffalse =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 553   ffalse[0] = Type::CONTROL;
 554   ffalse[1] = Type::TOP;
 555   TypeTuple::IFFALSE = TypeTuple::make( 2, ffalse );
 556 
 557   const Type **fneither =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 558   fneither[0] = Type::TOP;
 559   fneither[1] = Type::TOP;
 560   TypeTuple::IFNEITHER = TypeTuple::make( 2, fneither );
 561 
 562   const Type **ftrue =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 563   ftrue[0] = Type::TOP;
 564   ftrue[1] = Type::CONTROL;
 565   TypeTuple::IFTRUE = TypeTuple::make( 2, ftrue );
 566 
 567   const Type **floop =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 568   floop[0] = Type::CONTROL;
 569   floop[1] = TypeInt::INT;
 570   TypeTuple::LOOPBODY = TypeTuple::make( 2, floop );
 571 
 572   TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, Offset(0));
 573   TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, Offset::bottom);
 574   TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, Offset::bottom);
 575 
 576   TypeRawPtr::BOTTOM = TypeRawPtr::make( TypePtr::BotPTR );
 577   TypeRawPtr::NOTNULL= TypeRawPtr::make( TypePtr::NotNull );
 578 
 579   const Type **fmembar = TypeTuple::fields(0);
 580   TypeTuple::MEMBAR = TypeTuple::make(TypeFunc::Parms+0, fmembar);
 581 
 582   const Type **fsc = (const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 583   fsc[0] = TypeInt::CC;
 584   fsc[1] = Type::MEMORY;
 585   TypeTuple::STORECONDITIONAL = TypeTuple::make(2, fsc);
 586 
 587   TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
 588   TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
 589   TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
 590   TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 591                                            false, 0, Offset(oopDesc::mark_offset_in_bytes()), false);
 592   TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 593                                            false, 0, Offset(oopDesc::klass_offset_in_bytes()), false);
 594   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, Offset::bottom, TypeOopPtr::InstanceBot);
 595 
 596   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, Offset::bottom);
 597 
 598   TypeValueType::BOTTOM = TypeValueType::make(NULL);
 599 
 600   TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
 601   TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
 602 
 603   TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
 604 
 605   mreg2type[Op_Node] = Type::BOTTOM;
 606   mreg2type[Op_Set ] = 0;
 607   mreg2type[Op_RegN] = TypeNarrowOop::BOTTOM;
 608   mreg2type[Op_RegI] = TypeInt::INT;
 609   mreg2type[Op_RegP] = TypePtr::BOTTOM;
 610   mreg2type[Op_RegF] = Type::FLOAT;
 611   mreg2type[Op_RegD] = Type::DOUBLE;
 612   mreg2type[Op_RegL] = TypeLong::LONG;
 613   mreg2type[Op_RegFlags] = TypeInt::CC;
 614 
 615   TypeAryPtr::RANGE   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL /* current-&gt;env()-&gt;Object_klass() */, false, Offset(arrayOopDesc::length_offset_in_bytes()));
 616 
 617   TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);
 618 
 619 #ifdef _LP64
 620   if (UseCompressedOops) {
 621     assert(TypeAryPtr::NARROWOOPS-&gt;is_ptr_to_narrowoop(), &quot;array of narrow oops must be ptr to narrow oop&quot;);
 622     TypeAryPtr::OOPS  = TypeAryPtr::NARROWOOPS;
 623   } else
 624 #endif
 625   {
 626     // There is no shared klass for Object[].  See note in TypeAryPtr::klass().
 627     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);
 628   }
 629   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Offset::bottom);
 630   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Offset::bottom);
 631   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Offset::bottom);
 632   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);
 633   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);
 634   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);
 635   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);
 636   TypeAryPtr::VALUES  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeValueType::BOTTOM,TypeInt::POS), NULL, false,  Offset::bottom);
 637 
 638   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 639   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 640   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
 641   TypeAryPtr::_array_body_type[T_INLINE_TYPE] = TypeAryPtr::OOPS;
 642   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 643   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 644   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 645   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 646   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 647   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 648   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 649   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 650   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 651 
 652   TypeKlassPtr::OBJECT = TypeKlassPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), Offset(0), false);
 653   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make(TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), Offset(0), false);
 654 
 655   const Type **fi2c = TypeTuple::fields(2);
 656   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
 657   fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
 658   TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
 659 
 660   const Type **intpair = TypeTuple::fields(2);
 661   intpair[0] = TypeInt::INT;
 662   intpair[1] = TypeInt::INT;
 663   TypeTuple::INT_PAIR = TypeTuple::make(2, intpair);
 664 
 665   const Type **longpair = TypeTuple::fields(2);
 666   longpair[0] = TypeLong::LONG;
 667   longpair[1] = TypeLong::LONG;
 668   TypeTuple::LONG_PAIR = TypeTuple::make(2, longpair);
 669 
 670   const Type **intccpair = TypeTuple::fields(2);
 671   intccpair[0] = TypeInt::INT;
 672   intccpair[1] = TypeInt::CC;
 673   TypeTuple::INT_CC_PAIR = TypeTuple::make(2, intccpair);
 674 
 675   const Type **longccpair = TypeTuple::fields(2);
 676   longccpair[0] = TypeLong::LONG;
 677   longccpair[1] = TypeInt::CC;
 678   TypeTuple::LONG_CC_PAIR = TypeTuple::make(2, longccpair);
 679 
 680   _const_basic_type[T_NARROWOOP]   = TypeNarrowOop::BOTTOM;
 681   _const_basic_type[T_NARROWKLASS] = Type::BOTTOM;
 682   _const_basic_type[T_BOOLEAN]     = TypeInt::BOOL;
 683   _const_basic_type[T_CHAR]        = TypeInt::CHAR;
 684   _const_basic_type[T_BYTE]        = TypeInt::BYTE;
 685   _const_basic_type[T_SHORT]       = TypeInt::SHORT;
 686   _const_basic_type[T_INT]         = TypeInt::INT;
 687   _const_basic_type[T_LONG]        = TypeLong::LONG;
 688   _const_basic_type[T_FLOAT]       = Type::FLOAT;
 689   _const_basic_type[T_DOUBLE]      = Type::DOUBLE;
 690   _const_basic_type[T_OBJECT]      = TypeInstPtr::BOTTOM;
 691   _const_basic_type[T_ARRAY]       = TypeInstPtr::BOTTOM; // there is no separate bottom for arrays
 692   _const_basic_type[T_INLINE_TYPE] = TypeInstPtr::BOTTOM;
 693   _const_basic_type[T_VOID]        = TypePtr::NULL_PTR;   // reflection represents void this way
 694   _const_basic_type[T_ADDRESS]     = TypeRawPtr::BOTTOM;  // both interpreter return addresses &amp; random raw ptrs
 695   _const_basic_type[T_CONFLICT]    = Type::BOTTOM;        // why not?
 696 
 697   _zero_type[T_NARROWOOP]   = TypeNarrowOop::NULL_PTR;
 698   _zero_type[T_NARROWKLASS] = TypeNarrowKlass::NULL_PTR;
 699   _zero_type[T_BOOLEAN]     = TypeInt::ZERO;     // false == 0
 700   _zero_type[T_CHAR]        = TypeInt::ZERO;     // &#39;\0&#39; == 0
 701   _zero_type[T_BYTE]        = TypeInt::ZERO;     // 0x00 == 0
 702   _zero_type[T_SHORT]       = TypeInt::ZERO;     // 0x0000 == 0
 703   _zero_type[T_INT]         = TypeInt::ZERO;
 704   _zero_type[T_LONG]        = TypeLong::ZERO;
 705   _zero_type[T_FLOAT]       = TypeF::ZERO;
 706   _zero_type[T_DOUBLE]      = TypeD::ZERO;
 707   _zero_type[T_OBJECT]      = TypePtr::NULL_PTR;
 708   _zero_type[T_ARRAY]       = TypePtr::NULL_PTR; // null array is null oop
 709   _zero_type[T_INLINE_TYPE] = TypePtr::NULL_PTR;
 710   _zero_type[T_ADDRESS]     = TypePtr::NULL_PTR; // raw pointers use the same null
 711   _zero_type[T_VOID]        = Type::TOP;         // the only void value is no value at all
 712 
 713   // get_zero_type() should not happen for T_CONFLICT
 714   _zero_type[T_CONFLICT]= NULL;
 715 
 716   // Vector predefined types, it needs initialized _const_basic_type[].
 717   if (Matcher::vector_size_supported(T_BYTE,4)) {
 718     TypeVect::VECTS = TypeVect::make(T_BYTE,4);
 719   }
 720   if (Matcher::vector_size_supported(T_FLOAT,2)) {
 721     TypeVect::VECTD = TypeVect::make(T_FLOAT,2);
 722   }
 723   if (Matcher::vector_size_supported(T_FLOAT,4)) {
 724     TypeVect::VECTX = TypeVect::make(T_FLOAT,4);
 725   }
 726   if (Matcher::vector_size_supported(T_FLOAT,8)) {
 727     TypeVect::VECTY = TypeVect::make(T_FLOAT,8);
 728   }
 729   if (Matcher::vector_size_supported(T_FLOAT,16)) {
 730     TypeVect::VECTZ = TypeVect::make(T_FLOAT,16);
 731   }
 732   mreg2type[Op_VecS] = TypeVect::VECTS;
 733   mreg2type[Op_VecD] = TypeVect::VECTD;
 734   mreg2type[Op_VecX] = TypeVect::VECTX;
 735   mreg2type[Op_VecY] = TypeVect::VECTY;
 736   mreg2type[Op_VecZ] = TypeVect::VECTZ;
 737 
 738   // Restore working type arena.
 739   current-&gt;set_type_arena(save);
 740   current-&gt;set_type_dict(NULL);
 741 }
 742 
 743 //------------------------------Initialize-------------------------------------
 744 void Type::Initialize(Compile* current) {
 745   assert(current-&gt;type_arena() != NULL, &quot;must have created type arena&quot;);
 746 
 747   if (_shared_type_dict == NULL) {
 748     Initialize_shared(current);
 749   }
 750 
 751   Arena* type_arena = current-&gt;type_arena();
 752 
 753   // Create the hash-cons&#39;ing dictionary with top-level storage allocation
 754   Dict *tdic = new (type_arena) Dict( (CmpKey)Type::cmp,(Hash)Type::uhash, type_arena, 128 );
 755   current-&gt;set_type_dict(tdic);
 756 
 757   // Transfer the shared types.
 758   DictI i(_shared_type_dict);
 759   for( ; i.test(); ++i ) {
 760     Type* t = (Type*)i._value;
 761     tdic-&gt;Insert(t,t);  // New Type, insert into Type table
 762   }
 763 }
 764 
 765 //------------------------------hashcons---------------------------------------
 766 // Do the hash-cons trick.  If the Type already exists in the type table,
 767 // delete the current Type and return the existing Type.  Otherwise stick the
 768 // current Type in the Type table.
 769 const Type *Type::hashcons(void) {
 770   debug_only(base());           // Check the assertion in Type::base().
 771   // Look up the Type in the Type dictionary
 772   Dict *tdic = type_dict();
 773   Type* old = (Type*)(tdic-&gt;Insert(this, this, false));
 774   if( old ) {                   // Pre-existing Type?
 775     if( old != this )           // Yes, this guy is not the pre-existing?
 776       delete this;              // Yes, Nuke this guy
 777     assert( old-&gt;_dual, &quot;&quot; );
 778     return old;                 // Return pre-existing
 779   }
 780 
 781   // Every type has a dual (to make my lattice symmetric).
 782   // Since we just discovered a new Type, compute its dual right now.
 783   assert( !_dual, &quot;&quot; );         // No dual yet
 784   _dual = xdual();              // Compute the dual
 785   if (cmp(this, _dual) == 0) {  // Handle self-symmetric
 786     if (_dual != this) {
 787       delete _dual;
 788       _dual = this;
 789     }
 790     return this;
 791   }
 792   assert( !_dual-&gt;_dual, &quot;&quot; );  // No reverse dual yet
 793   assert( !(*tdic)[_dual], &quot;&quot; ); // Dual not in type system either
 794   // New Type, insert into Type table
 795   tdic-&gt;Insert((void*)_dual,(void*)_dual);
 796   ((Type*)_dual)-&gt;_dual = this; // Finish up being symmetric
 797 #ifdef ASSERT
 798   Type *dual_dual = (Type*)_dual-&gt;xdual();
 799   assert( eq(dual_dual), &quot;xdual(xdual()) should be identity&quot; );
 800   delete dual_dual;
 801 #endif
 802   return this;                  // Return new Type
 803 }
 804 
 805 //------------------------------eq---------------------------------------------
 806 // Structural equality check for Type representations
 807 bool Type::eq( const Type * ) const {
 808   return true;                  // Nothing else can go wrong
 809 }
 810 
 811 //------------------------------hash-------------------------------------------
 812 // Type-specific hashing function.
 813 int Type::hash(void) const {
 814   return _base;
 815 }
 816 
 817 //------------------------------is_finite--------------------------------------
 818 // Has a finite value
 819 bool Type::is_finite() const {
 820   return false;
 821 }
 822 
 823 //------------------------------is_nan-----------------------------------------
 824 // Is not a number (NaN)
 825 bool Type::is_nan()    const {
 826   return false;
 827 }
 828 
 829 //----------------------interface_vs_oop---------------------------------------
 830 #ifdef ASSERT
 831 bool Type::interface_vs_oop_helper(const Type *t) const {
 832   bool result = false;
 833 
 834   const TypePtr* this_ptr = this-&gt;make_ptr(); // In case it is narrow_oop
 835   const TypePtr*    t_ptr =    t-&gt;make_ptr();
 836   if( this_ptr == NULL || t_ptr == NULL )
 837     return result;
 838 
 839   const TypeInstPtr* this_inst = this_ptr-&gt;isa_instptr();
 840   const TypeInstPtr*    t_inst =    t_ptr-&gt;isa_instptr();
 841   if( this_inst &amp;&amp; this_inst-&gt;is_loaded() &amp;&amp; t_inst &amp;&amp; t_inst-&gt;is_loaded() ) {
 842     bool this_interface = this_inst-&gt;klass()-&gt;is_interface();
 843     bool    t_interface =    t_inst-&gt;klass()-&gt;is_interface();
 844     result = this_interface ^ t_interface;
 845   }
 846 
 847   return result;
 848 }
 849 
 850 bool Type::interface_vs_oop(const Type *t) const {
 851   if (interface_vs_oop_helper(t)) {
 852     return true;
 853   }
 854   // Now check the speculative parts as well
 855   const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()-&gt;speculative() : NULL;
 856   const TypePtr* t_spec = t-&gt;isa_ptr() != NULL ? t-&gt;is_ptr()-&gt;speculative() : NULL;
 857   if (this_spec != NULL &amp;&amp; t_spec != NULL) {
 858     if (this_spec-&gt;interface_vs_oop_helper(t_spec)) {
 859       return true;
 860     }
 861     return false;
 862   }
 863   if (this_spec != NULL &amp;&amp; this_spec-&gt;interface_vs_oop_helper(t)) {
 864     return true;
 865   }
 866   if (t_spec != NULL &amp;&amp; interface_vs_oop_helper(t_spec)) {
 867     return true;
 868   }
 869   return false;
 870 }
 871 
 872 #endif
 873 
 874 void Type::check_symmetrical(const Type *t, const Type *mt) const {
 875 #ifdef ASSERT
 876   assert(mt == t-&gt;xmeet(this), &quot;meet not commutative&quot;);
 877   const Type* dual_join = mt-&gt;_dual;
 878   const Type *t2t    = dual_join-&gt;xmeet(t-&gt;_dual);
 879   const Type *t2this = dual_join-&gt;xmeet(this-&gt;_dual);
 880 
 881   // Interface meet Oop is Not Symmetric:
 882   // Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull
 883   // Interface:NotNull meet Oop:NotNull == java/lang/Object:NotNull
 884 
 885   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this-&gt;_dual)) {
 886     tty-&gt;print_cr(&quot;=== Meet Not Symmetric ===&quot;);
 887     tty-&gt;print(&quot;t   =                   &quot;);              t-&gt;dump(); tty-&gt;cr();
 888     tty-&gt;print(&quot;this=                   &quot;);                 dump(); tty-&gt;cr();
 889     tty-&gt;print(&quot;mt=(t meet this)=       &quot;);             mt-&gt;dump(); tty-&gt;cr();
 890 
 891     tty-&gt;print(&quot;t_dual=                 &quot;);       t-&gt;_dual-&gt;dump(); tty-&gt;cr();
 892     tty-&gt;print(&quot;this_dual=              &quot;);          _dual-&gt;dump(); tty-&gt;cr();
 893     tty-&gt;print(&quot;mt_dual=                &quot;);      mt-&gt;_dual-&gt;dump(); tty-&gt;cr();
 894 
 895     tty-&gt;print(&quot;mt_dual meet t_dual=    &quot;); t2t           -&gt;dump(); tty-&gt;cr();
 896     tty-&gt;print(&quot;mt_dual meet this_dual= &quot;); t2this        -&gt;dump(); tty-&gt;cr();
 897 
 898     fatal(&quot;meet not symmetric&quot; );
 899   }
 900 #endif
 901 }
 902 
 903 //------------------------------meet-------------------------------------------
 904 // Compute the MEET of two types.  NOT virtual.  It enforces that meet is
 905 // commutative and the lattice is symmetric.
 906 const Type *Type::meet_helper(const Type *t, bool include_speculative) const {
 907   if (isa_narrowoop() &amp;&amp; t-&gt;isa_narrowoop()) {
 908     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);
 909     return result-&gt;make_narrowoop();
 910   }
 911   if (isa_narrowklass() &amp;&amp; t-&gt;isa_narrowklass()) {
 912     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);
 913     return result-&gt;make_narrowklass();
 914   }
 915 
 916   const Type *this_t = maybe_remove_speculative(include_speculative);
 917   t = t-&gt;maybe_remove_speculative(include_speculative);
 918 
 919   const Type *mt = this_t-&gt;xmeet(t);
 920 #ifdef ASSERT
 921   if (isa_narrowoop() || t-&gt;isa_narrowoop()) return mt;
 922   if (isa_narrowklass() || t-&gt;isa_narrowklass()) return mt;
 923   Compile* C = Compile::current();
 924   if (!C-&gt;_type_verify_symmetry) {
 925     return mt;
 926   }
 927   this_t-&gt;check_symmetrical(t, mt);
 928   // In the case of an array, computing the meet above, caused the
 929   // computation of the meet of the elements which at verification
 930   // time caused the computation of the meet of the dual of the
 931   // elements. Computing the meet of the dual of the arrays here
 932   // causes the meet of the dual of the elements to be computed which
 933   // would cause the meet of the dual of the dual of the elements,
 934   // that is the meet of the elements already computed above to be
 935   // computed. Avoid redundant computations by requesting no
 936   // verification.
 937   C-&gt;_type_verify_symmetry = false;
 938   const Type *mt_dual = this_t-&gt;_dual-&gt;xmeet(t-&gt;_dual);
 939   this_t-&gt;_dual-&gt;check_symmetrical(t-&gt;_dual, mt_dual);
 940   assert(!C-&gt;_type_verify_symmetry, &quot;shouldn&#39;t have changed&quot;);
 941   C-&gt;_type_verify_symmetry = true;
 942 #endif
 943   return mt;
 944 }
 945 
 946 //------------------------------xmeet------------------------------------------
 947 // Compute the MEET of two types.  It returns a new Type object.
 948 const Type *Type::xmeet( const Type *t ) const {
 949   // Perform a fast test for common case; meeting the same types together.
 950   if( this == t ) return this;  // Meeting same type-rep?
 951 
 952   // Meeting TOP with anything?
 953   if( _base == Top ) return t;
 954 
 955   // Meeting BOTTOM with anything?
 956   if( _base == Bottom ) return BOTTOM;
 957 
 958   // Current &quot;this-&gt;_base&quot; is one of: Bad, Multi, Control, Top,
 959   // Abio, Abstore, Floatxxx, Doublexxx, Bottom, lastype.
 960   switch (t-&gt;base()) {  // Switch on original type
 961 
 962   // Cut in half the number of cases I must handle.  Only need cases for when
 963   // the given enum &quot;t-&gt;type&quot; is less than or equal to the local enum &quot;type&quot;.
 964   case FloatCon:
 965   case DoubleCon:
 966   case Int:
 967   case Long:
 968     return t-&gt;xmeet(this);
 969 
 970   case OopPtr:
 971     return t-&gt;xmeet(this);
 972 
 973   case InstPtr:
 974     return t-&gt;xmeet(this);
 975 
 976   case MetadataPtr:
 977   case KlassPtr:
 978     return t-&gt;xmeet(this);
 979 
 980   case AryPtr:
 981     return t-&gt;xmeet(this);
 982 
 983   case NarrowOop:
 984     return t-&gt;xmeet(this);
 985 
 986   case NarrowKlass:
 987     return t-&gt;xmeet(this);
 988 
 989   case ValueType:
 990     return t-&gt;xmeet(this);
 991 
 992   case Bad:                     // Type check
 993   default:                      // Bogus type not in lattice
 994     typerr(t);
 995     return Type::BOTTOM;
 996 
 997   case Bottom:                  // Ye Olde Default
 998     return t;
 999 
1000   case FloatTop:
1001     if( _base == FloatTop ) return this;
1002   case FloatBot:                // Float
1003     if( _base == FloatBot || _base == FloatTop ) return FLOAT;
1004     if( _base == DoubleTop || _base == DoubleBot ) return Type::BOTTOM;
1005     typerr(t);
1006     return Type::BOTTOM;
1007 
1008   case DoubleTop:
1009     if( _base == DoubleTop ) return this;
1010   case DoubleBot:               // Double
1011     if( _base == DoubleBot || _base == DoubleTop ) return DOUBLE;
1012     if( _base == FloatTop || _base == FloatBot ) return Type::BOTTOM;
1013     typerr(t);
1014     return Type::BOTTOM;
1015 
1016   // These next few cases must match exactly or it is a compile-time error.
1017   case Control:                 // Control of code
1018   case Abio:                    // State of world outside of program
1019   case Memory:
1020     if( _base == t-&gt;_base )  return this;
1021     typerr(t);
1022     return Type::BOTTOM;
1023 
1024   case Top:                     // Top of the lattice
1025     return this;
1026   }
1027 
1028   // The type is unchanged
1029   return this;
1030 }
1031 
1032 //-----------------------------filter------------------------------------------
1033 const Type *Type::filter_helper(const Type *kills, bool include_speculative) const {
1034   const Type* ft = join_helper(kills, include_speculative);
1035   if (ft-&gt;empty())
1036     return Type::TOP;           // Canonical empty value
1037   return ft;
1038 }
1039 
1040 //------------------------------xdual------------------------------------------
1041 // Compute dual right now.
1042 const Type::TYPES Type::dual_type[Type::lastype] = {
1043   Bad,          // Bad
1044   Control,      // Control
1045   Bottom,       // Top
1046   Bad,          // Int - handled in v-call
1047   Bad,          // Long - handled in v-call
1048   Half,         // Half
1049   Bad,          // NarrowOop - handled in v-call
1050   Bad,          // NarrowKlass - handled in v-call
1051 
1052   Bad,          // Tuple - handled in v-call
1053   Bad,          // Array - handled in v-call
1054   Bad,          // VectorS - handled in v-call
1055   Bad,          // VectorD - handled in v-call
1056   Bad,          // VectorX - handled in v-call
1057   Bad,          // VectorY - handled in v-call
1058   Bad,          // VectorZ - handled in v-call
1059   Bad,          // ValueType - handled in v-call
1060 
1061   Bad,          // AnyPtr - handled in v-call
1062   Bad,          // RawPtr - handled in v-call
1063   Bad,          // OopPtr - handled in v-call
1064   Bad,          // InstPtr - handled in v-call
1065   Bad,          // AryPtr - handled in v-call
1066 
1067   Bad,          //  MetadataPtr - handled in v-call
1068   Bad,          // KlassPtr - handled in v-call
1069 
1070   Bad,          // Function - handled in v-call
1071   Abio,         // Abio
1072   Return_Address,// Return_Address
1073   Memory,       // Memory
1074   FloatBot,     // FloatTop
1075   FloatCon,     // FloatCon
1076   FloatTop,     // FloatBot
1077   DoubleBot,    // DoubleTop
1078   DoubleCon,    // DoubleCon
1079   DoubleTop,    // DoubleBot
1080   Top           // Bottom
1081 };
1082 
1083 const Type *Type::xdual() const {
1084   // Note: the base() accessor asserts the sanity of _base.
1085   assert(_type_info[base()].dual_type != Bad, &quot;implement with v-call&quot;);
1086   return new Type(_type_info[_base].dual_type);
1087 }
1088 
1089 //------------------------------has_memory-------------------------------------
1090 bool Type::has_memory() const {
1091   Type::TYPES tx = base();
1092   if (tx == Memory) return true;
1093   if (tx == Tuple) {
1094     const TypeTuple *t = is_tuple();
1095     for (uint i=0; i &lt; t-&gt;cnt(); i++) {
1096       tx = t-&gt;field_at(i)-&gt;base();
1097       if (tx == Memory)  return true;
1098     }
1099   }
1100   return false;
1101 }
1102 
1103 #ifndef PRODUCT
1104 //------------------------------dump2------------------------------------------
1105 void Type::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1106   st-&gt;print(&quot;%s&quot;, _type_info[_base].msg);
1107 }
1108 
1109 //------------------------------dump-------------------------------------------
1110 void Type::dump_on(outputStream *st) const {
1111   ResourceMark rm;
1112   Dict d(cmpkey,hashkey);       // Stop recursive type dumping
1113   dump2(d,1, st);
1114   if (is_ptr_to_narrowoop()) {
1115     st-&gt;print(&quot; [narrow]&quot;);
1116   } else if (is_ptr_to_narrowklass()) {
1117     st-&gt;print(&quot; [narrowklass]&quot;);
1118   }
1119 }
1120 
1121 //-----------------------------------------------------------------------------
1122 const char* Type::str(const Type* t) {
1123   stringStream ss;
1124   t-&gt;dump_on(&amp;ss);
1125   return ss.as_string();
1126 }
1127 #endif
1128 
1129 //------------------------------singleton--------------------------------------
1130 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1131 // constants (Ldi nodes).  Singletons are integer, float or double constants.
1132 bool Type::singleton(void) const {
1133   return _base == Top || _base == Half;
1134 }
1135 
1136 //------------------------------empty------------------------------------------
1137 // TRUE if Type is a type with no values, FALSE otherwise.
1138 bool Type::empty(void) const {
1139   switch (_base) {
1140   case DoubleTop:
1141   case FloatTop:
1142   case Top:
1143     return true;
1144 
1145   case Half:
1146   case Abio:
1147   case Return_Address:
1148   case Memory:
1149   case Bottom:
1150   case FloatBot:
1151   case DoubleBot:
1152     return false;  // never a singleton, therefore never empty
1153 
1154   default:
1155     ShouldNotReachHere();
1156     return false;
1157   }
1158 }
1159 
1160 //------------------------------dump_stats-------------------------------------
1161 // Dump collected statistics to stderr
1162 #ifndef PRODUCT
1163 void Type::dump_stats() {
1164   tty-&gt;print(&quot;Types made: %d\n&quot;, type_dict()-&gt;Size());
1165 }
1166 #endif
1167 
1168 //------------------------------typerr-----------------------------------------
1169 void Type::typerr( const Type *t ) const {
1170 #ifndef PRODUCT
1171   tty-&gt;print(&quot;\nError mixing types: &quot;);
1172   dump();
1173   tty-&gt;print(&quot; and &quot;);
1174   t-&gt;dump();
1175   tty-&gt;print(&quot;\n&quot;);
1176 #endif
1177   ShouldNotReachHere();
1178 }
1179 
1180 
1181 //=============================================================================
1182 // Convenience common pre-built types.
1183 const TypeF *TypeF::ZERO;       // Floating point zero
1184 const TypeF *TypeF::ONE;        // Floating point one
1185 const TypeF *TypeF::POS_INF;    // Floating point positive infinity
1186 const TypeF *TypeF::NEG_INF;    // Floating point negative infinity
1187 
1188 //------------------------------make-------------------------------------------
1189 // Create a float constant
1190 const TypeF *TypeF::make(float f) {
1191   return (TypeF*)(new TypeF(f))-&gt;hashcons();
1192 }
1193 
1194 //------------------------------meet-------------------------------------------
1195 // Compute the MEET of two types.  It returns a new Type object.
1196 const Type *TypeF::xmeet( const Type *t ) const {
1197   // Perform a fast test for common case; meeting the same types together.
1198   if( this == t ) return this;  // Meeting same type-rep?
1199 
1200   // Current &quot;this-&gt;_base&quot; is FloatCon
1201   switch (t-&gt;base()) {          // Switch on original type
1202   case AnyPtr:                  // Mixing with oops happens when javac
1203   case RawPtr:                  // reuses local variables
1204   case OopPtr:
1205   case InstPtr:
1206   case AryPtr:
1207   case MetadataPtr:
1208   case KlassPtr:
1209   case NarrowOop:
1210   case NarrowKlass:
1211   case Int:
1212   case Long:
1213   case DoubleTop:
1214   case DoubleCon:
1215   case DoubleBot:
1216   case Bottom:                  // Ye Olde Default
1217     return Type::BOTTOM;
1218 
1219   case FloatBot:
1220     return t;
1221 
1222   default:                      // All else is a mistake
1223     typerr(t);
1224 
1225   case FloatCon:                // Float-constant vs Float-constant?
1226     if( jint_cast(_f) != jint_cast(t-&gt;getf()) )         // unequal constants?
1227                                 // must compare bitwise as positive zero, negative zero and NaN have
1228                                 // all the same representation in C++
1229       return FLOAT;             // Return generic float
1230                                 // Equal constants
1231   case Top:
1232   case FloatTop:
1233     break;                      // Return the float constant
1234   }
1235   return this;                  // Return the float constant
1236 }
1237 
1238 //------------------------------xdual------------------------------------------
1239 // Dual: symmetric
1240 const Type *TypeF::xdual() const {
1241   return this;
1242 }
1243 
1244 //------------------------------eq---------------------------------------------
1245 // Structural equality check for Type representations
1246 bool TypeF::eq(const Type *t) const {
1247   // Bitwise comparison to distinguish between +/-0. These values must be treated
1248   // as different to be consistent with C1 and the interpreter.
1249   return (jint_cast(_f) == jint_cast(t-&gt;getf()));
1250 }
1251 
1252 //------------------------------hash-------------------------------------------
1253 // Type-specific hashing function.
1254 int TypeF::hash(void) const {
1255   return *(int*)(&amp;_f);
1256 }
1257 
1258 //------------------------------is_finite--------------------------------------
1259 // Has a finite value
1260 bool TypeF::is_finite() const {
1261   return g_isfinite(getf()) != 0;
1262 }
1263 
1264 //------------------------------is_nan-----------------------------------------
1265 // Is not a number (NaN)
1266 bool TypeF::is_nan()    const {
1267   return g_isnan(getf()) != 0;
1268 }
1269 
1270 //------------------------------dump2------------------------------------------
1271 // Dump float constant Type
1272 #ifndef PRODUCT
1273 void TypeF::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1274   Type::dump2(d,depth, st);
1275   st-&gt;print(&quot;%f&quot;, _f);
1276 }
1277 #endif
1278 
1279 //------------------------------singleton--------------------------------------
1280 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1281 // constants (Ldi nodes).  Singletons are integer, float or double constants
1282 // or a single symbol.
1283 bool TypeF::singleton(void) const {
1284   return true;                  // Always a singleton
1285 }
1286 
1287 bool TypeF::empty(void) const {
1288   return false;                 // always exactly a singleton
1289 }
1290 
1291 //=============================================================================
1292 // Convenience common pre-built types.
1293 const TypeD *TypeD::ZERO;       // Floating point zero
1294 const TypeD *TypeD::ONE;        // Floating point one
1295 const TypeD *TypeD::POS_INF;    // Floating point positive infinity
1296 const TypeD *TypeD::NEG_INF;    // Floating point negative infinity
1297 
1298 //------------------------------make-------------------------------------------
1299 const TypeD *TypeD::make(double d) {
1300   return (TypeD*)(new TypeD(d))-&gt;hashcons();
1301 }
1302 
1303 //------------------------------meet-------------------------------------------
1304 // Compute the MEET of two types.  It returns a new Type object.
1305 const Type *TypeD::xmeet( const Type *t ) const {
1306   // Perform a fast test for common case; meeting the same types together.
1307   if( this == t ) return this;  // Meeting same type-rep?
1308 
1309   // Current &quot;this-&gt;_base&quot; is DoubleCon
1310   switch (t-&gt;base()) {          // Switch on original type
1311   case AnyPtr:                  // Mixing with oops happens when javac
1312   case RawPtr:                  // reuses local variables
1313   case OopPtr:
1314   case InstPtr:
1315   case AryPtr:
1316   case MetadataPtr:
1317   case KlassPtr:
1318   case NarrowOop:
1319   case NarrowKlass:
1320   case Int:
1321   case Long:
1322   case FloatTop:
1323   case FloatCon:
1324   case FloatBot:
1325   case Bottom:                  // Ye Olde Default
1326     return Type::BOTTOM;
1327 
1328   case DoubleBot:
1329     return t;
1330 
1331   default:                      // All else is a mistake
1332     typerr(t);
1333 
1334   case DoubleCon:               // Double-constant vs Double-constant?
1335     if( jlong_cast(_d) != jlong_cast(t-&gt;getd()) )       // unequal constants? (see comment in TypeF::xmeet)
1336       return DOUBLE;            // Return generic double
1337   case Top:
1338   case DoubleTop:
1339     break;
1340   }
1341   return this;                  // Return the double constant
1342 }
1343 
1344 //------------------------------xdual------------------------------------------
1345 // Dual: symmetric
1346 const Type *TypeD::xdual() const {
1347   return this;
1348 }
1349 
1350 //------------------------------eq---------------------------------------------
1351 // Structural equality check for Type representations
1352 bool TypeD::eq(const Type *t) const {
1353   // Bitwise comparison to distinguish between +/-0. These values must be treated
1354   // as different to be consistent with C1 and the interpreter.
1355   return (jlong_cast(_d) == jlong_cast(t-&gt;getd()));
1356 }
1357 
1358 //------------------------------hash-------------------------------------------
1359 // Type-specific hashing function.
1360 int TypeD::hash(void) const {
1361   return *(int*)(&amp;_d);
1362 }
1363 
1364 //------------------------------is_finite--------------------------------------
1365 // Has a finite value
1366 bool TypeD::is_finite() const {
1367   return g_isfinite(getd()) != 0;
1368 }
1369 
1370 //------------------------------is_nan-----------------------------------------
1371 // Is not a number (NaN)
1372 bool TypeD::is_nan()    const {
1373   return g_isnan(getd()) != 0;
1374 }
1375 
1376 //------------------------------dump2------------------------------------------
1377 // Dump double constant Type
1378 #ifndef PRODUCT
1379 void TypeD::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1380   Type::dump2(d,depth,st);
1381   st-&gt;print(&quot;%f&quot;, _d);
1382 }
1383 #endif
1384 
1385 //------------------------------singleton--------------------------------------
1386 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1387 // constants (Ldi nodes).  Singletons are integer, float or double constants
1388 // or a single symbol.
1389 bool TypeD::singleton(void) const {
1390   return true;                  // Always a singleton
1391 }
1392 
1393 bool TypeD::empty(void) const {
1394   return false;                 // always exactly a singleton
1395 }
1396 
1397 //=============================================================================
1398 // Convience common pre-built types.
1399 const TypeInt *TypeInt::MINUS_1;// -1
1400 const TypeInt *TypeInt::ZERO;   // 0
1401 const TypeInt *TypeInt::ONE;    // 1
1402 const TypeInt *TypeInt::BOOL;   // 0 or 1, FALSE or TRUE.
1403 const TypeInt *TypeInt::CC;     // -1,0 or 1, condition codes
1404 const TypeInt *TypeInt::CC_LT;  // [-1]  == MINUS_1
1405 const TypeInt *TypeInt::CC_GT;  // [1]   == ONE
1406 const TypeInt *TypeInt::CC_EQ;  // [0]   == ZERO
1407 const TypeInt *TypeInt::CC_LE;  // [-1,0]
1408 const TypeInt *TypeInt::CC_GE;  // [0,1] == BOOL (!)
1409 const TypeInt *TypeInt::BYTE;   // Bytes, -128 to 127
1410 const TypeInt *TypeInt::UBYTE;  // Unsigned Bytes, 0 to 255
1411 const TypeInt *TypeInt::CHAR;   // Java chars, 0-65535
1412 const TypeInt *TypeInt::SHORT;  // Java shorts, -32768-32767
1413 const TypeInt *TypeInt::POS;    // Positive 32-bit integers or zero
1414 const TypeInt *TypeInt::POS1;   // Positive 32-bit integers
1415 const TypeInt *TypeInt::INT;    // 32-bit integers
1416 const TypeInt *TypeInt::SYMINT; // symmetric range [-max_jint..max_jint]
1417 const TypeInt *TypeInt::TYPE_DOMAIN; // alias for TypeInt::INT
1418 
1419 //------------------------------TypeInt----------------------------------------
1420 TypeInt::TypeInt( jint lo, jint hi, int w ) : Type(Int), _lo(lo), _hi(hi), _widen(w) {
1421 }
1422 
1423 //------------------------------make-------------------------------------------
1424 const TypeInt *TypeInt::make( jint lo ) {
1425   return (TypeInt*)(new TypeInt(lo,lo,WidenMin))-&gt;hashcons();
1426 }
1427 
1428 static int normalize_int_widen( jint lo, jint hi, int w ) {
1429   // Certain normalizations keep us sane when comparing types.
1430   // The &#39;SMALLINT&#39; covers constants and also CC and its relatives.
1431   if (lo &lt;= hi) {
1432     if (((juint)hi - lo) &lt;= SMALLINT)  w = Type::WidenMin;
1433     if (((juint)hi - lo) &gt;= max_juint) w = Type::WidenMax; // TypeInt::INT
1434   } else {
1435     if (((juint)lo - hi) &lt;= SMALLINT)  w = Type::WidenMin;
1436     if (((juint)lo - hi) &gt;= max_juint) w = Type::WidenMin; // dual TypeInt::INT
1437   }
1438   return w;
1439 }
1440 
1441 const TypeInt *TypeInt::make( jint lo, jint hi, int w ) {
1442   w = normalize_int_widen(lo, hi, w);
1443   return (TypeInt*)(new TypeInt(lo,hi,w))-&gt;hashcons();
1444 }
1445 
1446 //------------------------------meet-------------------------------------------
1447 // Compute the MEET of two types.  It returns a new Type representation object
1448 // with reference count equal to the number of Types pointing at it.
1449 // Caller should wrap a Types around it.
1450 const Type *TypeInt::xmeet( const Type *t ) const {
1451   // Perform a fast test for common case; meeting the same types together.
1452   if( this == t ) return this;  // Meeting same type?
1453 
1454   // Currently &quot;this-&gt;_base&quot; is a TypeInt
1455   switch (t-&gt;base()) {          // Switch on original type
1456   case AnyPtr:                  // Mixing with oops happens when javac
1457   case RawPtr:                  // reuses local variables
1458   case OopPtr:
1459   case InstPtr:
1460   case AryPtr:
1461   case MetadataPtr:
1462   case KlassPtr:
1463   case NarrowOop:
1464   case NarrowKlass:
1465   case Long:
1466   case FloatTop:
1467   case FloatCon:
1468   case FloatBot:
1469   case DoubleTop:
1470   case DoubleCon:
1471   case DoubleBot:
1472   case Bottom:                  // Ye Olde Default
1473     return Type::BOTTOM;
1474   default:                      // All else is a mistake
1475     typerr(t);
1476   case Top:                     // No change
1477     return this;
1478   case Int:                     // Int vs Int?
1479     break;
1480   }
1481 
1482   // Expand covered set
1483   const TypeInt *r = t-&gt;is_int();
1484   return make( MIN2(_lo,r-&gt;_lo), MAX2(_hi,r-&gt;_hi), MAX2(_widen,r-&gt;_widen) );
1485 }
1486 
1487 //------------------------------xdual------------------------------------------
1488 // Dual: reverse hi &amp; lo; flip widen
1489 const Type *TypeInt::xdual() const {
1490   int w = normalize_int_widen(_hi,_lo, WidenMax-_widen);
1491   return new TypeInt(_hi,_lo,w);
1492 }
1493 
1494 //------------------------------widen------------------------------------------
1495 // Only happens for optimistic top-down optimizations.
1496 const Type *TypeInt::widen( const Type *old, const Type* limit ) const {
1497   // Coming from TOP or such; no widening
1498   if( old-&gt;base() != Int ) return this;
1499   const TypeInt *ot = old-&gt;is_int();
1500 
1501   // If new guy is equal to old guy, no widening
1502   if( _lo == ot-&gt;_lo &amp;&amp; _hi == ot-&gt;_hi )
1503     return old;
1504 
1505   // If new guy contains old, then we widened
1506   if( _lo &lt;= ot-&gt;_lo &amp;&amp; _hi &gt;= ot-&gt;_hi ) {
1507     // New contains old
1508     // If new guy is already wider than old, no widening
1509     if( _widen &gt; ot-&gt;_widen ) return this;
1510     // If old guy was a constant, do not bother
1511     if (ot-&gt;_lo == ot-&gt;_hi)  return this;
1512     // Now widen new guy.
1513     // Check for widening too far
1514     if (_widen == WidenMax) {
1515       int max = max_jint;
1516       int min = min_jint;
1517       if (limit-&gt;isa_int()) {
1518         max = limit-&gt;is_int()-&gt;_hi;
1519         min = limit-&gt;is_int()-&gt;_lo;
1520       }
1521       if (min &lt; _lo &amp;&amp; _hi &lt; max) {
1522         // If neither endpoint is extremal yet, push out the endpoint
1523         // which is closer to its respective limit.
1524         if (_lo &gt;= 0 ||                 // easy common case
1525             (juint)(_lo - min) &gt;= (juint)(max - _hi)) {
1526           // Try to widen to an unsigned range type of 31 bits:
1527           return make(_lo, max, WidenMax);
1528         } else {
1529           return make(min, _hi, WidenMax);
1530         }
1531       }
1532       return TypeInt::INT;
1533     }
1534     // Returned widened new guy
1535     return make(_lo,_hi,_widen+1);
1536   }
1537 
1538   // If old guy contains new, then we probably widened too far &amp; dropped to
1539   // bottom.  Return the wider fellow.
1540   if ( ot-&gt;_lo &lt;= _lo &amp;&amp; ot-&gt;_hi &gt;= _hi )
1541     return old;
1542 
1543   //fatal(&quot;Integer value range is not subset&quot;);
1544   //return this;
1545   return TypeInt::INT;
1546 }
1547 
1548 //------------------------------narrow---------------------------------------
1549 // Only happens for pessimistic optimizations.
1550 const Type *TypeInt::narrow( const Type *old ) const {
1551   if (_lo &gt;= _hi)  return this;   // already narrow enough
1552   if (old == NULL)  return this;
1553   const TypeInt* ot = old-&gt;isa_int();
1554   if (ot == NULL)  return this;
1555   jint olo = ot-&gt;_lo;
1556   jint ohi = ot-&gt;_hi;
1557 
1558   // If new guy is equal to old guy, no narrowing
1559   if (_lo == olo &amp;&amp; _hi == ohi)  return old;
1560 
1561   // If old guy was maximum range, allow the narrowing
1562   if (olo == min_jint &amp;&amp; ohi == max_jint)  return this;
1563 
1564   if (_lo &lt; olo || _hi &gt; ohi)
1565     return this;                // doesn&#39;t narrow; pretty wierd
1566 
1567   // The new type narrows the old type, so look for a &quot;death march&quot;.
1568   // See comments on PhaseTransform::saturate.
1569   juint nrange = (juint)_hi - _lo;
1570   juint orange = (juint)ohi - olo;
1571   if (nrange &lt; max_juint - 1 &amp;&amp; nrange &gt; (orange &gt;&gt; 1) + (SMALLINT*2)) {
1572     // Use the new type only if the range shrinks a lot.
1573     // We do not want the optimizer computing 2^31 point by point.
1574     return old;
1575   }
1576 
1577   return this;
1578 }
1579 
1580 //-----------------------------filter------------------------------------------
1581 const Type *TypeInt::filter_helper(const Type *kills, bool include_speculative) const {
1582   const TypeInt* ft = join_helper(kills, include_speculative)-&gt;isa_int();
1583   if (ft == NULL || ft-&gt;empty())
1584     return Type::TOP;           // Canonical empty value
1585   if (ft-&gt;_widen &lt; this-&gt;_widen) {
1586     // Do not allow the value of kill-&gt;_widen to affect the outcome.
1587     // The widen bits must be allowed to run freely through the graph.
1588     ft = TypeInt::make(ft-&gt;_lo, ft-&gt;_hi, this-&gt;_widen);
1589   }
1590   return ft;
1591 }
1592 
1593 //------------------------------eq---------------------------------------------
1594 // Structural equality check for Type representations
1595 bool TypeInt::eq( const Type *t ) const {
1596   const TypeInt *r = t-&gt;is_int(); // Handy access
1597   return r-&gt;_lo == _lo &amp;&amp; r-&gt;_hi == _hi &amp;&amp; r-&gt;_widen == _widen;
1598 }
1599 
1600 //------------------------------hash-------------------------------------------
1601 // Type-specific hashing function.
1602 int TypeInt::hash(void) const {
1603   return java_add(java_add(_lo, _hi), java_add((jint)_widen, (jint)Type::Int));
1604 }
1605 
1606 //------------------------------is_finite--------------------------------------
1607 // Has a finite value
1608 bool TypeInt::is_finite() const {
1609   return true;
1610 }
1611 
1612 //------------------------------dump2------------------------------------------
1613 // Dump TypeInt
1614 #ifndef PRODUCT
1615 static const char* intname(char* buf, jint n) {
1616   if (n == min_jint)
1617     return &quot;min&quot;;
1618   else if (n &lt; min_jint + 10000)
1619     sprintf(buf, &quot;min+&quot; INT32_FORMAT, n - min_jint);
1620   else if (n == max_jint)
1621     return &quot;max&quot;;
1622   else if (n &gt; max_jint - 10000)
1623     sprintf(buf, &quot;max-&quot; INT32_FORMAT, max_jint - n);
1624   else
1625     sprintf(buf, INT32_FORMAT, n);
1626   return buf;
1627 }
1628 
1629 void TypeInt::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1630   char buf[40], buf2[40];
1631   if (_lo == min_jint &amp;&amp; _hi == max_jint)
1632     st-&gt;print(&quot;int&quot;);
1633   else if (is_con())
1634     st-&gt;print(&quot;int:%s&quot;, intname(buf, get_con()));
1635   else if (_lo == BOOL-&gt;_lo &amp;&amp; _hi == BOOL-&gt;_hi)
1636     st-&gt;print(&quot;bool&quot;);
1637   else if (_lo == BYTE-&gt;_lo &amp;&amp; _hi == BYTE-&gt;_hi)
1638     st-&gt;print(&quot;byte&quot;);
1639   else if (_lo == CHAR-&gt;_lo &amp;&amp; _hi == CHAR-&gt;_hi)
1640     st-&gt;print(&quot;char&quot;);
1641   else if (_lo == SHORT-&gt;_lo &amp;&amp; _hi == SHORT-&gt;_hi)
1642     st-&gt;print(&quot;short&quot;);
1643   else if (_hi == max_jint)
1644     st-&gt;print(&quot;int:&gt;=%s&quot;, intname(buf, _lo));
1645   else if (_lo == min_jint)
1646     st-&gt;print(&quot;int:&lt;=%s&quot;, intname(buf, _hi));
1647   else
1648     st-&gt;print(&quot;int:%s..%s&quot;, intname(buf, _lo), intname(buf2, _hi));
1649 
1650   if (_widen != 0 &amp;&amp; this != TypeInt::INT)
1651     st-&gt;print(&quot;:%.*s&quot;, _widen, &quot;wwww&quot;);
1652 }
1653 #endif
1654 
1655 //------------------------------singleton--------------------------------------
1656 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1657 // constants.
1658 bool TypeInt::singleton(void) const {
1659   return _lo &gt;= _hi;
1660 }
1661 
1662 bool TypeInt::empty(void) const {
1663   return _lo &gt; _hi;
1664 }
1665 
1666 //=============================================================================
1667 // Convenience common pre-built types.
1668 const TypeLong *TypeLong::MINUS_1;// -1
1669 const TypeLong *TypeLong::ZERO; // 0
1670 const TypeLong *TypeLong::ONE;  // 1
1671 const TypeLong *TypeLong::POS;  // &gt;=0
1672 const TypeLong *TypeLong::LONG; // 64-bit integers
1673 const TypeLong *TypeLong::INT;  // 32-bit subrange
1674 const TypeLong *TypeLong::UINT; // 32-bit unsigned subrange
1675 const TypeLong *TypeLong::TYPE_DOMAIN; // alias for TypeLong::LONG
1676 
1677 //------------------------------TypeLong---------------------------------------
1678 TypeLong::TypeLong( jlong lo, jlong hi, int w ) : Type(Long), _lo(lo), _hi(hi), _widen(w) {
1679 }
1680 
1681 //------------------------------make-------------------------------------------
1682 const TypeLong *TypeLong::make( jlong lo ) {
1683   return (TypeLong*)(new TypeLong(lo,lo,WidenMin))-&gt;hashcons();
1684 }
1685 
1686 static int normalize_long_widen( jlong lo, jlong hi, int w ) {
1687   // Certain normalizations keep us sane when comparing types.
1688   // The &#39;SMALLINT&#39; covers constants.
1689   if (lo &lt;= hi) {
1690     if (((julong)hi - lo) &lt;= SMALLINT)   w = Type::WidenMin;
1691     if (((julong)hi - lo) &gt;= max_julong) w = Type::WidenMax; // TypeLong::LONG
1692   } else {
1693     if (((julong)lo - hi) &lt;= SMALLINT)   w = Type::WidenMin;
1694     if (((julong)lo - hi) &gt;= max_julong) w = Type::WidenMin; // dual TypeLong::LONG
1695   }
1696   return w;
1697 }
1698 
1699 const TypeLong *TypeLong::make( jlong lo, jlong hi, int w ) {
1700   w = normalize_long_widen(lo, hi, w);
1701   return (TypeLong*)(new TypeLong(lo,hi,w))-&gt;hashcons();
1702 }
1703 
1704 
1705 //------------------------------meet-------------------------------------------
1706 // Compute the MEET of two types.  It returns a new Type representation object
1707 // with reference count equal to the number of Types pointing at it.
1708 // Caller should wrap a Types around it.
1709 const Type *TypeLong::xmeet( const Type *t ) const {
1710   // Perform a fast test for common case; meeting the same types together.
1711   if( this == t ) return this;  // Meeting same type?
1712 
1713   // Currently &quot;this-&gt;_base&quot; is a TypeLong
1714   switch (t-&gt;base()) {          // Switch on original type
1715   case AnyPtr:                  // Mixing with oops happens when javac
1716   case RawPtr:                  // reuses local variables
1717   case OopPtr:
1718   case InstPtr:
1719   case AryPtr:
1720   case MetadataPtr:
1721   case KlassPtr:
1722   case NarrowOop:
1723   case NarrowKlass:
1724   case Int:
1725   case FloatTop:
1726   case FloatCon:
1727   case FloatBot:
1728   case DoubleTop:
1729   case DoubleCon:
1730   case DoubleBot:
1731   case Bottom:                  // Ye Olde Default
1732     return Type::BOTTOM;
1733   default:                      // All else is a mistake
1734     typerr(t);
1735   case Top:                     // No change
1736     return this;
1737   case Long:                    // Long vs Long?
1738     break;
1739   }
1740 
1741   // Expand covered set
1742   const TypeLong *r = t-&gt;is_long(); // Turn into a TypeLong
1743   return make( MIN2(_lo,r-&gt;_lo), MAX2(_hi,r-&gt;_hi), MAX2(_widen,r-&gt;_widen) );
1744 }
1745 
1746 //------------------------------xdual------------------------------------------
1747 // Dual: reverse hi &amp; lo; flip widen
1748 const Type *TypeLong::xdual() const {
1749   int w = normalize_long_widen(_hi,_lo, WidenMax-_widen);
1750   return new TypeLong(_hi,_lo,w);
1751 }
1752 
1753 //------------------------------widen------------------------------------------
1754 // Only happens for optimistic top-down optimizations.
1755 const Type *TypeLong::widen( const Type *old, const Type* limit ) const {
1756   // Coming from TOP or such; no widening
1757   if( old-&gt;base() != Long ) return this;
1758   const TypeLong *ot = old-&gt;is_long();
1759 
1760   // If new guy is equal to old guy, no widening
1761   if( _lo == ot-&gt;_lo &amp;&amp; _hi == ot-&gt;_hi )
1762     return old;
1763 
1764   // If new guy contains old, then we widened
1765   if( _lo &lt;= ot-&gt;_lo &amp;&amp; _hi &gt;= ot-&gt;_hi ) {
1766     // New contains old
1767     // If new guy is already wider than old, no widening
1768     if( _widen &gt; ot-&gt;_widen ) return this;
1769     // If old guy was a constant, do not bother
1770     if (ot-&gt;_lo == ot-&gt;_hi)  return this;
1771     // Now widen new guy.
1772     // Check for widening too far
1773     if (_widen == WidenMax) {
1774       jlong max = max_jlong;
1775       jlong min = min_jlong;
1776       if (limit-&gt;isa_long()) {
1777         max = limit-&gt;is_long()-&gt;_hi;
1778         min = limit-&gt;is_long()-&gt;_lo;
1779       }
1780       if (min &lt; _lo &amp;&amp; _hi &lt; max) {
1781         // If neither endpoint is extremal yet, push out the endpoint
1782         // which is closer to its respective limit.
1783         if (_lo &gt;= 0 ||                 // easy common case
1784             ((julong)_lo - min) &gt;= ((julong)max - _hi)) {
1785           // Try to widen to an unsigned range type of 32/63 bits:
1786           if (max &gt;= max_juint &amp;&amp; _hi &lt; max_juint)
1787             return make(_lo, max_juint, WidenMax);
1788           else
1789             return make(_lo, max, WidenMax);
1790         } else {
1791           return make(min, _hi, WidenMax);
1792         }
1793       }
1794       return TypeLong::LONG;
1795     }
1796     // Returned widened new guy
1797     return make(_lo,_hi,_widen+1);
1798   }
1799 
1800   // If old guy contains new, then we probably widened too far &amp; dropped to
1801   // bottom.  Return the wider fellow.
1802   if ( ot-&gt;_lo &lt;= _lo &amp;&amp; ot-&gt;_hi &gt;= _hi )
1803     return old;
1804 
1805   //  fatal(&quot;Long value range is not subset&quot;);
1806   // return this;
1807   return TypeLong::LONG;
1808 }
1809 
1810 //------------------------------narrow----------------------------------------
1811 // Only happens for pessimistic optimizations.
1812 const Type *TypeLong::narrow( const Type *old ) const {
1813   if (_lo &gt;= _hi)  return this;   // already narrow enough
1814   if (old == NULL)  return this;
1815   const TypeLong* ot = old-&gt;isa_long();
1816   if (ot == NULL)  return this;
1817   jlong olo = ot-&gt;_lo;
1818   jlong ohi = ot-&gt;_hi;
1819 
1820   // If new guy is equal to old guy, no narrowing
1821   if (_lo == olo &amp;&amp; _hi == ohi)  return old;
1822 
1823   // If old guy was maximum range, allow the narrowing
1824   if (olo == min_jlong &amp;&amp; ohi == max_jlong)  return this;
1825 
1826   if (_lo &lt; olo || _hi &gt; ohi)
1827     return this;                // doesn&#39;t narrow; pretty wierd
1828 
1829   // The new type narrows the old type, so look for a &quot;death march&quot;.
1830   // See comments on PhaseTransform::saturate.
1831   julong nrange = _hi - _lo;
1832   julong orange = ohi - olo;
1833   if (nrange &lt; max_julong - 1 &amp;&amp; nrange &gt; (orange &gt;&gt; 1) + (SMALLINT*2)) {
1834     // Use the new type only if the range shrinks a lot.
1835     // We do not want the optimizer computing 2^31 point by point.
1836     return old;
1837   }
1838 
1839   return this;
1840 }
1841 
1842 //-----------------------------filter------------------------------------------
1843 const Type *TypeLong::filter_helper(const Type *kills, bool include_speculative) const {
1844   const TypeLong* ft = join_helper(kills, include_speculative)-&gt;isa_long();
1845   if (ft == NULL || ft-&gt;empty())
1846     return Type::TOP;           // Canonical empty value
1847   if (ft-&gt;_widen &lt; this-&gt;_widen) {
1848     // Do not allow the value of kill-&gt;_widen to affect the outcome.
1849     // The widen bits must be allowed to run freely through the graph.
1850     ft = TypeLong::make(ft-&gt;_lo, ft-&gt;_hi, this-&gt;_widen);
1851   }
1852   return ft;
1853 }
1854 
1855 //------------------------------eq---------------------------------------------
1856 // Structural equality check for Type representations
1857 bool TypeLong::eq( const Type *t ) const {
1858   const TypeLong *r = t-&gt;is_long(); // Handy access
1859   return r-&gt;_lo == _lo &amp;&amp;  r-&gt;_hi == _hi  &amp;&amp; r-&gt;_widen == _widen;
1860 }
1861 
1862 //------------------------------hash-------------------------------------------
1863 // Type-specific hashing function.
1864 int TypeLong::hash(void) const {
1865   return (int)(_lo+_hi+_widen+(int)Type::Long);
1866 }
1867 
1868 //------------------------------is_finite--------------------------------------
1869 // Has a finite value
1870 bool TypeLong::is_finite() const {
1871   return true;
1872 }
1873 
1874 //------------------------------dump2------------------------------------------
1875 // Dump TypeLong
1876 #ifndef PRODUCT
1877 static const char* longnamenear(jlong x, const char* xname, char* buf, jlong n) {
1878   if (n &gt; x) {
1879     if (n &gt;= x + 10000)  return NULL;
1880     sprintf(buf, &quot;%s+&quot; JLONG_FORMAT, xname, n - x);
1881   } else if (n &lt; x) {
1882     if (n &lt;= x - 10000)  return NULL;
1883     sprintf(buf, &quot;%s-&quot; JLONG_FORMAT, xname, x - n);
1884   } else {
1885     return xname;
1886   }
1887   return buf;
1888 }
1889 
1890 static const char* longname(char* buf, jlong n) {
1891   const char* str;
1892   if (n == min_jlong)
1893     return &quot;min&quot;;
1894   else if (n &lt; min_jlong + 10000)
1895     sprintf(buf, &quot;min+&quot; JLONG_FORMAT, n - min_jlong);
1896   else if (n == max_jlong)
1897     return &quot;max&quot;;
1898   else if (n &gt; max_jlong - 10000)
1899     sprintf(buf, &quot;max-&quot; JLONG_FORMAT, max_jlong - n);
1900   else if ((str = longnamenear(max_juint, &quot;maxuint&quot;, buf, n)) != NULL)
1901     return str;
1902   else if ((str = longnamenear(max_jint, &quot;maxint&quot;, buf, n)) != NULL)
1903     return str;
1904   else if ((str = longnamenear(min_jint, &quot;minint&quot;, buf, n)) != NULL)
1905     return str;
1906   else
1907     sprintf(buf, JLONG_FORMAT, n);
1908   return buf;
1909 }
1910 
1911 void TypeLong::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1912   char buf[80], buf2[80];
1913   if (_lo == min_jlong &amp;&amp; _hi == max_jlong)
1914     st-&gt;print(&quot;long&quot;);
1915   else if (is_con())
1916     st-&gt;print(&quot;long:%s&quot;, longname(buf, get_con()));
1917   else if (_hi == max_jlong)
1918     st-&gt;print(&quot;long:&gt;=%s&quot;, longname(buf, _lo));
1919   else if (_lo == min_jlong)
1920     st-&gt;print(&quot;long:&lt;=%s&quot;, longname(buf, _hi));
1921   else
1922     st-&gt;print(&quot;long:%s..%s&quot;, longname(buf, _lo), longname(buf2, _hi));
1923 
1924   if (_widen != 0 &amp;&amp; this != TypeLong::LONG)
1925     st-&gt;print(&quot;:%.*s&quot;, _widen, &quot;wwww&quot;);
1926 }
1927 #endif
1928 
1929 //------------------------------singleton--------------------------------------
1930 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1931 // constants
1932 bool TypeLong::singleton(void) const {
1933   return _lo &gt;= _hi;
1934 }
1935 
1936 bool TypeLong::empty(void) const {
1937   return _lo &gt; _hi;
1938 }
1939 
1940 //=============================================================================
1941 // Convenience common pre-built types.
1942 const TypeTuple *TypeTuple::IFBOTH;     // Return both arms of IF as reachable
1943 const TypeTuple *TypeTuple::IFFALSE;
1944 const TypeTuple *TypeTuple::IFTRUE;
1945 const TypeTuple *TypeTuple::IFNEITHER;
1946 const TypeTuple *TypeTuple::LOOPBODY;
1947 const TypeTuple *TypeTuple::MEMBAR;
1948 const TypeTuple *TypeTuple::STORECONDITIONAL;
1949 const TypeTuple *TypeTuple::START_I2C;
1950 const TypeTuple *TypeTuple::INT_PAIR;
1951 const TypeTuple *TypeTuple::LONG_PAIR;
1952 const TypeTuple *TypeTuple::INT_CC_PAIR;
1953 const TypeTuple *TypeTuple::LONG_CC_PAIR;
1954 
1955 static void collect_value_fields(ciValueKlass* vk, const Type** field_array, uint&amp; pos, ExtendedSignature&amp; sig_cc) {
1956   for (int j = 0; j &lt; vk-&gt;nof_nonstatic_fields(); j++) {
1957     ciField* field = vk-&gt;nonstatic_field_at(j);
1958     BasicType bt = field-&gt;type()-&gt;basic_type();
1959     const Type* ft = Type::get_const_type(field-&gt;type());
1960     field_array[pos++] = ft;
1961     if (type2size[bt] == 2) {
1962       field_array[pos++] = Type::HALF;
1963     }
1964     // Skip reserved arguments
1965     while (SigEntry::next_is_reserved(sig_cc, bt)) {
1966       field_array[pos++] = Type::get_const_basic_type(bt);
1967       if (type2size[bt] == 2) {
1968         field_array[pos++] = Type::HALF;
1969       }
1970     }
1971   }
1972 }
1973 
1974 //------------------------------make-------------------------------------------
1975 // Make a TypeTuple from the range of a method signature
1976 const TypeTuple *TypeTuple::make_range(ciSignature* sig, bool ret_vt_fields) {
1977   ciType* return_type = sig-&gt;return_type();
1978   uint arg_cnt = return_type-&gt;size();
1979   if (ret_vt_fields) {
1980     arg_cnt = return_type-&gt;as_value_klass()-&gt;value_arg_slots() + 1;
1981   }
1982 
1983   const Type **field_array = fields(arg_cnt);
1984   switch (return_type-&gt;basic_type()) {
1985   case T_LONG:
1986     field_array[TypeFunc::Parms]   = TypeLong::LONG;
1987     field_array[TypeFunc::Parms+1] = Type::HALF;
1988     break;
1989   case T_DOUBLE:
1990     field_array[TypeFunc::Parms]   = Type::DOUBLE;
1991     field_array[TypeFunc::Parms+1] = Type::HALF;
1992     break;
1993   case T_OBJECT:
1994   case T_ARRAY:
1995   case T_BOOLEAN:
1996   case T_CHAR:
1997   case T_FLOAT:
1998   case T_BYTE:
1999   case T_SHORT:
2000   case T_INT:
2001     field_array[TypeFunc::Parms] = get_const_type(return_type);
2002     break;
2003   case T_INLINE_TYPE:
2004     if (ret_vt_fields) {
2005       uint pos = TypeFunc::Parms;
2006       field_array[pos] = TypePtr::BOTTOM;
2007       pos++;
2008       ExtendedSignature sig = ExtendedSignature(NULL, SigEntryFilter());
2009       collect_value_fields(return_type-&gt;as_value_klass(), field_array, pos, sig);
2010     } else {
2011       field_array[TypeFunc::Parms] = get_const_type(return_type)-&gt;join_speculative(TypePtr::NOTNULL);
2012     }
2013     break;
2014   case T_VOID:
2015     break;
2016   default:
2017     ShouldNotReachHere();
2018   }
2019   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
2020 }
2021 
2022 // Make a TypeTuple from the domain of a method signature
2023 const TypeTuple *TypeTuple::make_domain(ciMethod* method, bool vt_fields_as_args) {
2024   ciSignature* sig = method-&gt;signature();
2025   ExtendedSignature sig_cc = ExtendedSignature(vt_fields_as_args ? method-&gt;get_sig_cc() : NULL, SigEntryFilter());
2026 
2027   uint arg_cnt = sig-&gt;size() + (method-&gt;is_static() ? 0 : 1);
2028   if (vt_fields_as_args) {
2029     for (arg_cnt = 0; !sig_cc.at_end(); ++sig_cc) {
2030       arg_cnt += type2size[(*sig_cc)._bt];
2031     }
2032     sig_cc = ExtendedSignature(method-&gt;get_sig_cc(), SigEntryFilter());
2033   }
2034 
2035   uint pos = TypeFunc::Parms;
2036   const Type** field_array = fields(arg_cnt);
2037   if (!method-&gt;is_static()) {
2038     ciInstanceKlass* recv = method-&gt;holder();
2039     if (vt_fields_as_args &amp;&amp; recv-&gt;is_valuetype() &amp;&amp; recv-&gt;as_value_klass()-&gt;can_be_passed_as_fields()) {
2040       collect_value_fields(recv-&gt;as_value_klass(), field_array, pos, sig_cc);
2041     } else {
2042       field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);
2043       if (vt_fields_as_args) {
2044         ++sig_cc;
2045       }
2046     }
2047   }
2048 
2049   int i = 0;
2050   while (pos &lt; TypeFunc::Parms + arg_cnt) {
2051     ciType* type = sig-&gt;type_at(i);
2052     BasicType bt = type-&gt;basic_type();
2053     bool is_flattened = false;
2054 
2055     switch (bt) {
2056     case T_LONG:
2057       field_array[pos++] = TypeLong::LONG;
2058       field_array[pos++] = Type::HALF;
2059       break;
2060     case T_DOUBLE:
2061       field_array[pos++] = Type::DOUBLE;
2062       field_array[pos++] = Type::HALF;
2063       break;
2064     case T_OBJECT:
2065     case T_ARRAY:
2066     case T_FLOAT:
2067     case T_INT:
2068       field_array[pos++] = get_const_type(type);
2069       break;
2070     case T_BOOLEAN:
2071     case T_CHAR:
2072     case T_BYTE:
2073     case T_SHORT:
2074       field_array[pos++] = TypeInt::INT;
2075       break;
2076     case T_INLINE_TYPE: {
2077       if (vt_fields_as_args &amp;&amp; type-&gt;as_value_klass()-&gt;can_be_passed_as_fields()) {
2078         is_flattened = true;
2079         collect_value_fields(type-&gt;as_value_klass(), field_array, pos, sig_cc);
2080       } else {
2081         field_array[pos++] = get_const_type(type)-&gt;join_speculative(TypePtr::NOTNULL);
2082       }
2083       break;
2084     }
2085     default:
2086       ShouldNotReachHere();
2087     }
2088     // Skip reserved arguments
2089     while (!is_flattened &amp;&amp; SigEntry::next_is_reserved(sig_cc, bt)) {
2090       field_array[pos++] = Type::get_const_basic_type(bt);
2091       if (type2size[bt] == 2) {
2092         field_array[pos++] = Type::HALF;
2093       }
2094     }
2095     i++;
2096   }
2097   assert(pos == TypeFunc::Parms + arg_cnt, &quot;wrong number of arguments&quot;);
2098 
2099   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
2100 }
2101 
2102 const TypeTuple *TypeTuple::make( uint cnt, const Type **fields ) {
2103   return (TypeTuple*)(new TypeTuple(cnt,fields))-&gt;hashcons();
2104 }
2105 
2106 //------------------------------fields-----------------------------------------
2107 // Subroutine call type with space allocated for argument types
2108 // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
2109 const Type **TypeTuple::fields( uint arg_cnt ) {
2110   const Type **flds = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4((TypeFunc::Parms+arg_cnt)*sizeof(Type*) ));
2111   flds[TypeFunc::Control  ] = Type::CONTROL;
2112   flds[TypeFunc::I_O      ] = Type::ABIO;
2113   flds[TypeFunc::Memory   ] = Type::MEMORY;
2114   flds[TypeFunc::FramePtr ] = TypeRawPtr::BOTTOM;
2115   flds[TypeFunc::ReturnAdr] = Type::RETURN_ADDRESS;
2116 
2117   return flds;
2118 }
2119 
2120 //------------------------------meet-------------------------------------------
2121 // Compute the MEET of two types.  It returns a new Type object.
2122 const Type *TypeTuple::xmeet( const Type *t ) const {
2123   // Perform a fast test for common case; meeting the same types together.
2124   if( this == t ) return this;  // Meeting same type-rep?
2125 
2126   // Current &quot;this-&gt;_base&quot; is Tuple
2127   switch (t-&gt;base()) {          // switch on original type
2128 
2129   case Bottom:                  // Ye Olde Default
2130     return t;
2131 
2132   default:                      // All else is a mistake
2133     typerr(t);
2134 
2135   case Tuple: {                 // Meeting 2 signatures?
2136     const TypeTuple *x = t-&gt;is_tuple();
2137     assert( _cnt == x-&gt;_cnt, &quot;&quot; );
2138     const Type **fields = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4( _cnt*sizeof(Type*) ));
2139     for( uint i=0; i&lt;_cnt; i++ )
2140       fields[i] = field_at(i)-&gt;xmeet( x-&gt;field_at(i) );
2141     return TypeTuple::make(_cnt,fields);
2142   }
2143   case Top:
2144     break;
2145   }
2146   return this;                  // Return the double constant
2147 }
2148 
2149 //------------------------------xdual------------------------------------------
2150 // Dual: compute field-by-field dual
2151 const Type *TypeTuple::xdual() const {
2152   const Type **fields = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4( _cnt*sizeof(Type*) ));
2153   for( uint i=0; i&lt;_cnt; i++ )
2154     fields[i] = _fields[i]-&gt;dual();
2155   return new TypeTuple(_cnt,fields);
2156 }
2157 
2158 //------------------------------eq---------------------------------------------
2159 // Structural equality check for Type representations
2160 bool TypeTuple::eq( const Type *t ) const {
2161   const TypeTuple *s = (const TypeTuple *)t;
2162   if (_cnt != s-&gt;_cnt)  return false;  // Unequal field counts
2163   for (uint i = 0; i &lt; _cnt; i++)
2164     if (field_at(i) != s-&gt;field_at(i)) // POINTER COMPARE!  NO RECURSION!
2165       return false;             // Missed
2166   return true;
2167 }
2168 
2169 //------------------------------hash-------------------------------------------
2170 // Type-specific hashing function.
2171 int TypeTuple::hash(void) const {
2172   intptr_t sum = _cnt;
2173   for( uint i=0; i&lt;_cnt; i++ )
2174     sum += (intptr_t)_fields[i];     // Hash on pointers directly
2175   return sum;
2176 }
2177 
2178 //------------------------------dump2------------------------------------------
2179 // Dump signature Type
2180 #ifndef PRODUCT
2181 void TypeTuple::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2182   st-&gt;print(&quot;{&quot;);
2183   if( !depth || d[this] ) {     // Check for recursive print
2184     st-&gt;print(&quot;...}&quot;);
2185     return;
2186   }
2187   d.Insert((void*)this, (void*)this);   // Stop recursion
2188   if( _cnt ) {
2189     uint i;
2190     for( i=0; i&lt;_cnt-1; i++ ) {
2191       st-&gt;print(&quot;%d:&quot;, i);
2192       _fields[i]-&gt;dump2(d, depth-1, st);
2193       st-&gt;print(&quot;, &quot;);
2194     }
2195     st-&gt;print(&quot;%d:&quot;, i);
2196     _fields[i]-&gt;dump2(d, depth-1, st);
2197   }
2198   st-&gt;print(&quot;}&quot;);
2199 }
2200 #endif
2201 
2202 //------------------------------singleton--------------------------------------
2203 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2204 // constants (Ldi nodes).  Singletons are integer, float or double constants
2205 // or a single symbol.
2206 bool TypeTuple::singleton(void) const {
2207   return false;                 // Never a singleton
2208 }
2209 
2210 bool TypeTuple::empty(void) const {
2211   for( uint i=0; i&lt;_cnt; i++ ) {
2212     if (_fields[i]-&gt;empty())  return true;
2213   }
2214   return false;
2215 }
2216 
2217 //=============================================================================
2218 // Convenience common pre-built types.
2219 
2220 inline const TypeInt* normalize_array_size(const TypeInt* size) {
2221   // Certain normalizations keep us sane when comparing types.
2222   // We do not want arrayOop variables to differ only by the wideness
2223   // of their index types.  Pick minimum wideness, since that is the
2224   // forced wideness of small ranges anyway.
2225   if (size-&gt;_widen != Type::WidenMin)
2226     return TypeInt::make(size-&gt;_lo, size-&gt;_hi, Type::WidenMin);
2227   else
2228     return size;
2229 }
2230 
2231 //------------------------------make-------------------------------------------
2232 const TypeAry* TypeAry::make(const Type* elem, const TypeInt* size, bool stable,
2233                              bool not_flat, bool not_null_free) {
2234   if (UseCompressedOops &amp;&amp; elem-&gt;isa_oopptr()) {
2235     elem = elem-&gt;make_narrowoop();
2236   }
2237   size = normalize_array_size(size);
2238   return (TypeAry*)(new TypeAry(elem, size, stable, not_flat, not_null_free))-&gt;hashcons();
2239 }
2240 
2241 //------------------------------meet-------------------------------------------
2242 // Compute the MEET of two types.  It returns a new Type object.
2243 const Type *TypeAry::xmeet( const Type *t ) const {
2244   // Perform a fast test for common case; meeting the same types together.
2245   if( this == t ) return this;  // Meeting same type-rep?
2246 
2247   // Current &quot;this-&gt;_base&quot; is Ary
2248   switch (t-&gt;base()) {          // switch on original type
2249 
2250   case Bottom:                  // Ye Olde Default
2251     return t;
2252 
2253   default:                      // All else is a mistake
2254     typerr(t);
2255 
2256   case Array: {                 // Meeting 2 arrays?
2257     const TypeAry *a = t-&gt;is_ary();
2258     return TypeAry::make(_elem-&gt;meet_speculative(a-&gt;_elem),
2259                          _size-&gt;xmeet(a-&gt;_size)-&gt;is_int(),
2260                          _stable &amp;&amp; a-&gt;_stable,
2261                          _not_flat &amp;&amp; a-&gt;_not_flat,
2262                          _not_null_free &amp;&amp; a-&gt;_not_null_free);
2263   }
2264   case Top:
2265     break;
2266   }
2267   return this;                  // Return the double constant
2268 }
2269 
2270 //------------------------------xdual------------------------------------------
2271 // Dual: compute field-by-field dual
2272 const Type *TypeAry::xdual() const {
2273   const TypeInt* size_dual = _size-&gt;dual()-&gt;is_int();
2274   size_dual = normalize_array_size(size_dual);
2275   return new TypeAry(_elem-&gt;dual(), size_dual, !_stable, !_not_flat, !_not_null_free);
2276 }
2277 
2278 //------------------------------eq---------------------------------------------
2279 // Structural equality check for Type representations
2280 bool TypeAry::eq( const Type *t ) const {
2281   const TypeAry *a = (const TypeAry*)t;
2282   return _elem == a-&gt;_elem &amp;&amp;
2283     _stable == a-&gt;_stable &amp;&amp;
2284     _size == a-&gt;_size &amp;&amp;
2285     _not_flat == a-&gt;_not_flat &amp;&amp;
2286     _not_null_free == a-&gt;_not_null_free;
2287 
2288 }
2289 
2290 //------------------------------hash-------------------------------------------
2291 // Type-specific hashing function.
2292 int TypeAry::hash(void) const {
2293   return (intptr_t)_elem + (intptr_t)_size + (_stable ? 43 : 0);
2294 }
2295 
2296 /**
2297  * Return same type without a speculative part in the element
2298  */
2299 const Type* TypeAry::remove_speculative() const {
2300   return make(_elem-&gt;remove_speculative(), _size, _stable, _not_flat, _not_null_free);
2301 }
2302 
2303 /**
2304  * Return same type with cleaned up speculative part of element
2305  */
2306 const Type* TypeAry::cleanup_speculative() const {
2307   return make(_elem-&gt;cleanup_speculative(), _size, _stable, _not_flat, _not_null_free);
2308 }
2309 
2310 /**
2311  * Return same type but with a different inline depth (used for speculation)
2312  *
2313  * @param depth  depth to meet with
2314  */
2315 const TypePtr* TypePtr::with_inline_depth(int depth) const {
2316   if (!UseInlineDepthForSpeculativeTypes) {
2317     return this;
2318   }
2319   return make(AnyPtr, _ptr, _offset, _speculative, depth);
2320 }
2321 
2322 //----------------------interface_vs_oop---------------------------------------
2323 #ifdef ASSERT
2324 bool TypeAry::interface_vs_oop(const Type *t) const {
2325   const TypeAry* t_ary = t-&gt;is_ary();
2326   if (t_ary) {
2327     const TypePtr* this_ptr = _elem-&gt;make_ptr(); // In case we have narrow_oops
2328     const TypePtr*    t_ptr = t_ary-&gt;_elem-&gt;make_ptr();
2329     if(this_ptr != NULL &amp;&amp; t_ptr != NULL) {
2330       return this_ptr-&gt;interface_vs_oop(t_ptr);
2331     }
2332   }
2333   return false;
2334 }
2335 #endif
2336 
2337 //------------------------------dump2------------------------------------------
2338 #ifndef PRODUCT
2339 void TypeAry::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2340   if (_stable)  st-&gt;print(&quot;stable:&quot;);
2341   if (Verbose) {
2342     if (_not_flat) st-&gt;print(&quot;not flat:&quot;);
2343     if (_not_null_free) st-&gt;print(&quot;not null free:&quot;);
2344   }
2345   _elem-&gt;dump2(d, depth, st);
2346   st-&gt;print(&quot;[&quot;);
2347   _size-&gt;dump2(d, depth, st);
2348   st-&gt;print(&quot;]&quot;);
2349 }
2350 #endif
2351 
2352 //------------------------------singleton--------------------------------------
2353 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2354 // constants (Ldi nodes).  Singletons are integer, float or double constants
2355 // or a single symbol.
2356 bool TypeAry::singleton(void) const {
2357   return false;                 // Never a singleton
2358 }
2359 
2360 bool TypeAry::empty(void) const {
2361   return _elem-&gt;empty() || _size-&gt;empty();
2362 }
2363 
2364 //--------------------------ary_must_be_exact----------------------------------
2365 bool TypeAry::ary_must_be_exact() const {
2366   if (!UseExactTypes)       return false;
2367   // This logic looks at the element type of an array, and returns true
2368   // if the element type is either a primitive or a final instance class.
2369   // In such cases, an array built on this ary must have no subclasses.
2370   if (_elem == BOTTOM)      return false;  // general array not exact
2371   if (_elem == TOP   )      return false;  // inverted general array not exact
2372   const TypeOopPtr*  toop = NULL;
2373   if (UseCompressedOops &amp;&amp; _elem-&gt;isa_narrowoop()) {
2374     toop = _elem-&gt;make_ptr()-&gt;isa_oopptr();
2375   } else {
2376     toop = _elem-&gt;isa_oopptr();
2377   }
2378   if (!toop)                return true;   // a primitive type, like int
2379   ciKlass* tklass = toop-&gt;klass();
2380   if (tklass == NULL)       return false;  // unloaded class
2381   if (!tklass-&gt;is_loaded()) return false;  // unloaded class
2382   const TypeInstPtr* tinst;
2383   if (_elem-&gt;isa_narrowoop())
2384     tinst = _elem-&gt;make_ptr()-&gt;isa_instptr();
2385   else
2386     tinst = _elem-&gt;isa_instptr();
2387   if (tinst)
2388     return tklass-&gt;as_instance_klass()-&gt;is_final();
2389   const TypeAryPtr*  tap;
2390   if (_elem-&gt;isa_narrowoop())
2391     tap = _elem-&gt;make_ptr()-&gt;isa_aryptr();
2392   else
2393     tap = _elem-&gt;isa_aryptr();
2394   if (tap)
2395     return tap-&gt;ary()-&gt;ary_must_be_exact();
2396   return false;
2397 }
2398 
2399 //==============================TypeValueType=======================================
2400 
2401 const TypeValueType *TypeValueType::BOTTOM;
2402 
2403 //------------------------------make-------------------------------------------
2404 const TypeValueType* TypeValueType::make(ciValueKlass* vk, bool larval) {
2405   return (TypeValueType*)(new TypeValueType(vk, larval))-&gt;hashcons();
2406 }
2407 
2408 //------------------------------meet-------------------------------------------
2409 // Compute the MEET of two types.  It returns a new Type object.
2410 const Type* TypeValueType::xmeet(const Type* t) const {
2411   // Perform a fast test for common case; meeting the same types together.
2412   if(this == t) return this;  // Meeting same type-rep?
2413 
2414   // Current &quot;this-&gt;_base&quot; is ValueType
2415   switch (t-&gt;base()) {          // switch on original type
2416 
2417   case Int:
2418   case Long:
2419   case FloatTop:
2420   case FloatCon:
2421   case FloatBot:
2422   case DoubleTop:
2423   case DoubleCon:
2424   case DoubleBot:
2425   case NarrowKlass:
2426   case Bottom:
2427     return Type::BOTTOM;
2428 
2429   case OopPtr:
2430   case MetadataPtr:
2431   case KlassPtr:
2432   case RawPtr:
2433     return TypePtr::BOTTOM;
2434 
2435   case Top:
2436     return this;
2437 
2438   case NarrowOop: {
2439     const Type* res = t-&gt;make_ptr()-&gt;xmeet(this);
2440     if (res-&gt;isa_ptr()) {
2441       return res-&gt;make_narrowoop();
2442     }
2443     return res;
2444   }
2445 
2446   case AryPtr:
2447   case InstPtr: {
2448     return t-&gt;xmeet(this);
2449   }
2450 
2451   case ValueType: {
2452     // All value types inherit from Object
2453     const TypeValueType* other = t-&gt;is_valuetype();
2454     if (_vk == NULL) {
2455       return this;
2456     } else if (other-&gt;_vk == NULL) {
2457       return other;
2458     } else if (_vk == other-&gt;_vk) {
2459       if (_larval == other-&gt;_larval ||
2460           !_larval) {
2461         return this;
2462       } else {
2463         return t;
2464       }
2465     }
2466     return TypeInstPtr::NOTNULL;
2467   }
2468 
2469   default:                      // All else is a mistake
2470     typerr(t);
2471 
2472   }
2473   return this;
2474 }
2475 
2476 //------------------------------xdual------------------------------------------
2477 const Type* TypeValueType::xdual() const {
2478   return this;
2479 }
2480 
2481 //------------------------------eq---------------------------------------------
2482 // Structural equality check for Type representations
2483 bool TypeValueType::eq(const Type* t) const {
2484   const TypeValueType* vt = t-&gt;is_valuetype();
2485   return (_vk == vt-&gt;value_klass() &amp;&amp; _larval == vt-&gt;larval());
2486 }
2487 
2488 //------------------------------hash-------------------------------------------
2489 // Type-specific hashing function.
2490 int TypeValueType::hash(void) const {
2491   return (intptr_t)_vk;
2492 }
2493 
2494 //------------------------------singleton--------------------------------------
2495 // TRUE if Type is a singleton type, FALSE otherwise. Singletons are simple constants.
2496 bool TypeValueType::singleton(void) const {
2497   return false;
2498 }
2499 
2500 //------------------------------empty------------------------------------------
2501 // TRUE if Type is a type with no values, FALSE otherwise.
2502 bool TypeValueType::empty(void) const {
2503   return false;
2504 }
2505 
2506 //------------------------------dump2------------------------------------------
2507 #ifndef PRODUCT
2508 void TypeValueType::dump2(Dict &amp;d, uint depth, outputStream* st) const {
2509   if (_vk == NULL) {
2510     st-&gt;print(&quot;BOTTOM valuetype&quot;);
2511     return;
2512   }
2513   int count = _vk-&gt;nof_declared_nonstatic_fields();
2514   st-&gt;print(&quot;valuetype[%d]:{&quot;, count);
2515   st-&gt;print(&quot;%s&quot;, count != 0 ? _vk-&gt;declared_nonstatic_field_at(0)-&gt;type()-&gt;name() : &quot;empty&quot;);
2516   for (int i = 1; i &lt; count; ++i) {
2517     st-&gt;print(&quot;, %s&quot;, _vk-&gt;declared_nonstatic_field_at(i)-&gt;type()-&gt;name());
2518   }
2519   st-&gt;print(&quot;}%s&quot;, _larval?&quot; : larval&quot;:&quot;&quot;);
2520 }
2521 #endif
2522 
2523 //==============================TypeVect=======================================
2524 // Convenience common pre-built types.
2525 const TypeVect *TypeVect::VECTS = NULL; //  32-bit vectors
2526 const TypeVect *TypeVect::VECTD = NULL; //  64-bit vectors
2527 const TypeVect *TypeVect::VECTX = NULL; // 128-bit vectors
2528 const TypeVect *TypeVect::VECTY = NULL; // 256-bit vectors
2529 const TypeVect *TypeVect::VECTZ = NULL; // 512-bit vectors
2530 
2531 //------------------------------make-------------------------------------------
2532 const TypeVect* TypeVect::make(const Type *elem, uint length) {
2533   BasicType elem_bt = elem-&gt;array_element_basic_type();
2534   assert(is_java_primitive(elem_bt), &quot;only primitive types in vector&quot;);
2535   assert(length &gt; 1 &amp;&amp; is_power_of_2(length), &quot;vector length is power of 2&quot;);
2536   assert(Matcher::vector_size_supported(elem_bt, length), &quot;length in range&quot;);
2537   int size = length * type2aelembytes(elem_bt);
2538   switch (Matcher::vector_ideal_reg(size)) {
2539   case Op_VecS:
2540     return (TypeVect*)(new TypeVectS(elem, length))-&gt;hashcons();
2541   case Op_RegL:
2542   case Op_VecD:
2543   case Op_RegD:
2544     return (TypeVect*)(new TypeVectD(elem, length))-&gt;hashcons();
2545   case Op_VecX:
2546     return (TypeVect*)(new TypeVectX(elem, length))-&gt;hashcons();
2547   case Op_VecY:
2548     return (TypeVect*)(new TypeVectY(elem, length))-&gt;hashcons();
2549   case Op_VecZ:
2550     return (TypeVect*)(new TypeVectZ(elem, length))-&gt;hashcons();
2551   }
2552  ShouldNotReachHere();
2553   return NULL;
2554 }
2555 
2556 //------------------------------meet-------------------------------------------
2557 // Compute the MEET of two types.  It returns a new Type object.
2558 const Type *TypeVect::xmeet( const Type *t ) const {
2559   // Perform a fast test for common case; meeting the same types together.
2560   if( this == t ) return this;  // Meeting same type-rep?
2561 
2562   // Current &quot;this-&gt;_base&quot; is Vector
2563   switch (t-&gt;base()) {          // switch on original type
2564 
2565   case Bottom:                  // Ye Olde Default
2566     return t;
2567 
2568   default:                      // All else is a mistake
2569     typerr(t);
2570 
2571   case VectorS:
2572   case VectorD:
2573   case VectorX:
2574   case VectorY:
2575   case VectorZ: {                // Meeting 2 vectors?
2576     const TypeVect* v = t-&gt;is_vect();
2577     assert(  base() == v-&gt;base(), &quot;&quot;);
2578     assert(length() == v-&gt;length(), &quot;&quot;);
2579     assert(element_basic_type() == v-&gt;element_basic_type(), &quot;&quot;);
2580     return TypeVect::make(_elem-&gt;xmeet(v-&gt;_elem), _length);
2581   }
2582   case Top:
2583     break;
2584   }
2585   return this;
2586 }
2587 
2588 //------------------------------xdual------------------------------------------
2589 // Dual: compute field-by-field dual
2590 const Type *TypeVect::xdual() const {
2591   return new TypeVect(base(), _elem-&gt;dual(), _length);
2592 }
2593 
2594 //------------------------------eq---------------------------------------------
2595 // Structural equality check for Type representations
2596 bool TypeVect::eq(const Type *t) const {
2597   const TypeVect *v = t-&gt;is_vect();
2598   return (_elem == v-&gt;_elem) &amp;&amp; (_length == v-&gt;_length);
2599 }
2600 
2601 //------------------------------hash-------------------------------------------
2602 // Type-specific hashing function.
2603 int TypeVect::hash(void) const {
2604   return (intptr_t)_elem + (intptr_t)_length;
2605 }
2606 
2607 //------------------------------singleton--------------------------------------
2608 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2609 // constants (Ldi nodes).  Vector is singleton if all elements are the same
2610 // constant value (when vector is created with Replicate code).
2611 bool TypeVect::singleton(void) const {
2612 // There is no Con node for vectors yet.
2613 //  return _elem-&gt;singleton();
2614   return false;
2615 }
2616 
2617 bool TypeVect::empty(void) const {
2618   return _elem-&gt;empty();
2619 }
2620 
2621 //------------------------------dump2------------------------------------------
2622 #ifndef PRODUCT
2623 void TypeVect::dump2(Dict &amp;d, uint depth, outputStream *st) const {
2624   switch (base()) {
2625   case VectorS:
2626     st-&gt;print(&quot;vectors[&quot;); break;
2627   case VectorD:
2628     st-&gt;print(&quot;vectord[&quot;); break;
2629   case VectorX:
2630     st-&gt;print(&quot;vectorx[&quot;); break;
2631   case VectorY:
2632     st-&gt;print(&quot;vectory[&quot;); break;
2633   case VectorZ:
2634     st-&gt;print(&quot;vectorz[&quot;); break;
2635   default:
2636     ShouldNotReachHere();
2637   }
2638   st-&gt;print(&quot;%d]:{&quot;, _length);
2639   _elem-&gt;dump2(d, depth, st);
2640   st-&gt;print(&quot;}&quot;);
2641 }
2642 #endif
2643 
2644 
2645 //=============================================================================
2646 // Convenience common pre-built types.
2647 const TypePtr *TypePtr::NULL_PTR;
2648 const TypePtr *TypePtr::NOTNULL;
2649 const TypePtr *TypePtr::BOTTOM;
2650 
2651 //------------------------------meet-------------------------------------------
2652 // Meet over the PTR enum
2653 const TypePtr::PTR TypePtr::ptr_meet[TypePtr::lastPTR][TypePtr::lastPTR] = {
2654   //              TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,
2655   { /* Top     */ TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,},
2656   { /* AnyNull */ AnyNull,   AnyNull,   Constant, BotPTR, NotNull, BotPTR,},
2657   { /* Constant*/ Constant,  Constant,  Constant, BotPTR, NotNull, BotPTR,},
2658   { /* Null    */ Null,      BotPTR,    BotPTR,   Null,   BotPTR,  BotPTR,},
2659   { /* NotNull */ NotNull,   NotNull,   NotNull,  BotPTR, NotNull, BotPTR,},
2660   { /* BotPTR  */ BotPTR,    BotPTR,    BotPTR,   BotPTR, BotPTR,  BotPTR,}
2661 };
2662 
2663 //------------------------------make-------------------------------------------
2664 const TypePtr* TypePtr::make(TYPES t, enum PTR ptr, Offset offset, const TypePtr* speculative, int inline_depth) {
2665   return (TypePtr*)(new TypePtr(t,ptr,offset, speculative, inline_depth))-&gt;hashcons();
2666 }
2667 
2668 //------------------------------cast_to_ptr_type-------------------------------
2669 const Type *TypePtr::cast_to_ptr_type(PTR ptr) const {
2670   assert(_base == AnyPtr, &quot;subclass must override cast_to_ptr_type&quot;);
2671   if( ptr == _ptr ) return this;
2672   return make(_base, ptr, _offset, _speculative, _inline_depth);
2673 }
2674 
2675 //------------------------------get_con----------------------------------------
2676 intptr_t TypePtr::get_con() const {
2677   assert( _ptr == Null, &quot;&quot; );
2678   return offset();
2679 }
2680 
2681 //------------------------------meet-------------------------------------------
2682 // Compute the MEET of two types.  It returns a new Type object.
2683 const Type *TypePtr::xmeet(const Type *t) const {
2684   const Type* res = xmeet_helper(t);
2685   if (res-&gt;isa_ptr() == NULL) {
2686     return res;
2687   }
2688 
2689   const TypePtr* res_ptr = res-&gt;is_ptr();
2690   if (res_ptr-&gt;speculative() != NULL) {
2691     // type-&gt;speculative() == NULL means that speculation is no better
2692     // than type, i.e. type-&gt;speculative() == type. So there are 2
2693     // ways to represent the fact that we have no useful speculative
2694     // data and we should use a single one to be able to test for
2695     // equality between types. Check whether type-&gt;speculative() ==
2696     // type and set speculative to NULL if it is the case.
2697     if (res_ptr-&gt;remove_speculative() == res_ptr-&gt;speculative()) {
2698       return res_ptr-&gt;remove_speculative();
2699     }
2700   }
2701 
2702   return res;
2703 }
2704 
2705 const Type *TypePtr::xmeet_helper(const Type *t) const {
2706   // Perform a fast test for common case; meeting the same types together.
2707   if( this == t ) return this;  // Meeting same type-rep?
2708 
2709   // Current &quot;this-&gt;_base&quot; is AnyPtr
2710   switch (t-&gt;base()) {          // switch on original type
2711   case Int:                     // Mixing ints &amp; oops happens when javac
2712   case Long:                    // reuses local variables
2713   case FloatTop:
2714   case FloatCon:
2715   case FloatBot:
2716   case DoubleTop:
2717   case DoubleCon:
2718   case DoubleBot:
2719   case NarrowOop:
2720   case NarrowKlass:
2721   case Bottom:                  // Ye Olde Default
2722     return Type::BOTTOM;
2723   case Top:
2724     return this;
2725 
2726   case AnyPtr: {                // Meeting to AnyPtrs
2727     const TypePtr *tp = t-&gt;is_ptr();
2728     const TypePtr* speculative = xmeet_speculative(tp);
2729     int depth = meet_inline_depth(tp-&gt;inline_depth());
2730     return make(AnyPtr, meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), speculative, depth);
2731   }
2732   case RawPtr:                  // For these, flip the call around to cut down
2733   case OopPtr:
2734   case InstPtr:                 // on the cases I have to handle.
2735   case AryPtr:
2736   case MetadataPtr:
2737   case KlassPtr:
2738     return t-&gt;xmeet(this);      // Call in reverse direction
2739   default:                      // All else is a mistake
2740     typerr(t);
2741 
2742   }
2743   return this;
2744 }
2745 
2746 //------------------------------meet_offset------------------------------------
2747 Type::Offset TypePtr::meet_offset(int offset) const {
2748   return _offset.meet(Offset(offset));
2749 }
2750 
2751 //------------------------------dual_offset------------------------------------
2752 Type::Offset TypePtr::dual_offset() const {
2753   return _offset.dual();
2754 }
2755 
2756 //------------------------------xdual------------------------------------------
2757 // Dual: compute field-by-field dual
2758 const TypePtr::PTR TypePtr::ptr_dual[TypePtr::lastPTR] = {
2759   BotPTR, NotNull, Constant, Null, AnyNull, TopPTR
2760 };
2761 const Type *TypePtr::xdual() const {
2762   return new TypePtr(AnyPtr, dual_ptr(), dual_offset(), dual_speculative(), dual_inline_depth());
2763 }
2764 
2765 //------------------------------xadd_offset------------------------------------
2766 Type::Offset TypePtr::xadd_offset(intptr_t offset) const {
2767   return _offset.add(offset);
2768 }
2769 
2770 //------------------------------add_offset-------------------------------------
2771 const TypePtr *TypePtr::add_offset( intptr_t offset ) const {
2772   return make(AnyPtr, _ptr, xadd_offset(offset), _speculative, _inline_depth);
2773 }
2774 
2775 //------------------------------eq---------------------------------------------
2776 // Structural equality check for Type representations
2777 bool TypePtr::eq( const Type *t ) const {
2778   const TypePtr *a = (const TypePtr*)t;
2779   return _ptr == a-&gt;ptr() &amp;&amp; _offset == a-&gt;_offset &amp;&amp; eq_speculative(a) &amp;&amp; _inline_depth == a-&gt;_inline_depth;
2780 }
2781 
2782 //------------------------------hash-------------------------------------------
2783 // Type-specific hashing function.
2784 int TypePtr::hash(void) const {
2785   return java_add(java_add((jint)_ptr, (jint)offset()), java_add((jint)hash_speculative(), (jint)_inline_depth));
2786 ;
2787 }
2788 
2789 /**
2790  * Return same type without a speculative part
2791  */
2792 const Type* TypePtr::remove_speculative() const {
2793   if (_speculative == NULL) {
2794     return this;
2795   }
2796   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
2797   return make(AnyPtr, _ptr, _offset, NULL, _inline_depth);
2798 }
2799 
2800 /**
2801  * Return same type but drop speculative part if we know we won&#39;t use
2802  * it
2803  */
2804 const Type* TypePtr::cleanup_speculative() const {
2805   if (speculative() == NULL) {
2806     return this;
2807   }
2808   const Type* no_spec = remove_speculative();
2809   // If this is NULL_PTR then we don&#39;t need the speculative type
2810   // (with_inline_depth in case the current type inline depth is
2811   // InlineDepthTop)
2812   if (no_spec == NULL_PTR-&gt;with_inline_depth(inline_depth())) {
2813     return no_spec;
2814   }
2815   if (above_centerline(speculative()-&gt;ptr())) {
2816     return no_spec;
2817   }
2818   const TypeOopPtr* spec_oopptr = speculative()-&gt;isa_oopptr();
2819   // If the speculative may be null and is an inexact klass then it
2820   // doesn&#39;t help
2821   if (speculative() != TypePtr::NULL_PTR &amp;&amp; speculative()-&gt;maybe_null() &amp;&amp;
2822       (spec_oopptr == NULL || !spec_oopptr-&gt;klass_is_exact())) {
2823     return no_spec;
2824   }
2825   return this;
2826 }
2827 
2828 /**
2829  * dual of the speculative part of the type
2830  */
2831 const TypePtr* TypePtr::dual_speculative() const {
2832   if (_speculative == NULL) {
2833     return NULL;
2834   }
2835   return _speculative-&gt;dual()-&gt;is_ptr();
2836 }
2837 
2838 /**
2839  * meet of the speculative parts of 2 types
2840  *
2841  * @param other  type to meet with
2842  */
2843 const TypePtr* TypePtr::xmeet_speculative(const TypePtr* other) const {
2844   bool this_has_spec = (_speculative != NULL);
2845   bool other_has_spec = (other-&gt;speculative() != NULL);
2846 
2847   if (!this_has_spec &amp;&amp; !other_has_spec) {
2848     return NULL;
2849   }
2850 
2851   // If we are at a point where control flow meets and one branch has
2852   // a speculative type and the other has not, we meet the speculative
2853   // type of one branch with the actual type of the other. If the
2854   // actual type is exact and the speculative is as well, then the
2855   // result is a speculative type which is exact and we can continue
2856   // speculation further.
2857   const TypePtr* this_spec = _speculative;
2858   const TypePtr* other_spec = other-&gt;speculative();
2859 
2860   if (!this_has_spec) {
2861     this_spec = this;
2862   }
2863 
2864   if (!other_has_spec) {
2865     other_spec = other;
2866   }
2867 
2868   return this_spec-&gt;meet(other_spec)-&gt;is_ptr();
2869 }
2870 
2871 /**
2872  * dual of the inline depth for this type (used for speculation)
2873  */
2874 int TypePtr::dual_inline_depth() const {
2875   return -inline_depth();
2876 }
2877 
2878 /**
2879  * meet of 2 inline depths (used for speculation)
2880  *
2881  * @param depth  depth to meet with
2882  */
2883 int TypePtr::meet_inline_depth(int depth) const {
2884   return MAX2(inline_depth(), depth);
2885 }
2886 
2887 /**
2888  * Are the speculative parts of 2 types equal?
2889  *
2890  * @param other  type to compare this one to
2891  */
2892 bool TypePtr::eq_speculative(const TypePtr* other) const {
2893   if (_speculative == NULL || other-&gt;speculative() == NULL) {
2894     return _speculative == other-&gt;speculative();
2895   }
2896 
2897   if (_speculative-&gt;base() != other-&gt;speculative()-&gt;base()) {
2898     return false;
2899   }
2900 
2901   return _speculative-&gt;eq(other-&gt;speculative());
2902 }
2903 
2904 /**
2905  * Hash of the speculative part of the type
2906  */
2907 int TypePtr::hash_speculative() const {
2908   if (_speculative == NULL) {
2909     return 0;
2910   }
2911 
2912   return _speculative-&gt;hash();
2913 }
2914 
2915 /**
2916  * add offset to the speculative part of the type
2917  *
2918  * @param offset  offset to add
2919  */
2920 const TypePtr* TypePtr::add_offset_speculative(intptr_t offset) const {
2921   if (_speculative == NULL) {
2922     return NULL;
2923   }
2924   return _speculative-&gt;add_offset(offset)-&gt;is_ptr();
2925 }
2926 
2927 /**
2928  * return exact klass from the speculative type if there&#39;s one
2929  */
2930 ciKlass* TypePtr::speculative_type() const {
2931   if (_speculative != NULL &amp;&amp; _speculative-&gt;isa_oopptr()) {
2932     const TypeOopPtr* speculative = _speculative-&gt;join(this)-&gt;is_oopptr();
2933     if (speculative-&gt;klass_is_exact()) {
2934       return speculative-&gt;klass();
2935     }
2936   }
2937   return NULL;
2938 }
2939 
2940 /**
2941  * return true if speculative type may be null
2942  */
2943 bool TypePtr::speculative_maybe_null() const {
2944   if (_speculative != NULL) {
2945     const TypePtr* speculative = _speculative-&gt;join(this)-&gt;is_ptr();
2946     return speculative-&gt;maybe_null();
2947   }
2948   return true;
2949 }
2950 
2951 bool TypePtr::speculative_always_null() const {
2952   if (_speculative != NULL) {
2953     const TypePtr* speculative = _speculative-&gt;join(this)-&gt;is_ptr();
2954     return speculative == TypePtr::NULL_PTR;
2955   }
2956   return false;
2957 }
2958 
2959 /**
2960  * Same as TypePtr::speculative_type() but return the klass only if
2961  * the speculative tells us is not null
2962  */
2963 ciKlass* TypePtr::speculative_type_not_null() const {
2964   if (speculative_maybe_null()) {
2965     return NULL;
2966   }
2967   return speculative_type();
2968 }
2969 
2970 /**
2971  * Check whether new profiling would improve speculative type
2972  *
2973  * @param   exact_kls    class from profiling
2974  * @param   inline_depth inlining depth of profile point
2975  *
2976  * @return  true if type profile is valuable
2977  */
2978 bool TypePtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
2979   // no profiling?
2980   if (exact_kls == NULL) {
2981     return false;
2982   }
2983   if (speculative() == TypePtr::NULL_PTR) {
2984     return false;
2985   }
2986   // no speculative type or non exact speculative type?
2987   if (speculative_type() == NULL) {
2988     return true;
2989   }
2990   // If the node already has an exact speculative type keep it,
2991   // unless it was provided by profiling that is at a deeper
2992   // inlining level. Profiling at a higher inlining depth is
2993   // expected to be less accurate.
2994   if (_speculative-&gt;inline_depth() == InlineDepthBottom) {
2995     return false;
2996   }
2997   assert(_speculative-&gt;inline_depth() != InlineDepthTop, &quot;can&#39;t do the comparison&quot;);
2998   return inline_depth &lt; _speculative-&gt;inline_depth();
2999 }
3000 
3001 /**
3002  * Check whether new profiling would improve ptr (= tells us it is non
3003  * null)
3004  *
3005  * @param   ptr_kind always null or not null?
3006  *
3007  * @return  true if ptr profile is valuable
3008  */
3009 bool TypePtr::would_improve_ptr(ProfilePtrKind ptr_kind) const {
3010   // profiling doesn&#39;t tell us anything useful
3011   if (ptr_kind != ProfileAlwaysNull &amp;&amp; ptr_kind != ProfileNeverNull) {
3012     return false;
3013   }
3014   // We already know this is not null
3015   if (!this-&gt;maybe_null()) {
3016     return false;
3017   }
3018   // We already know the speculative type cannot be null
3019   if (!speculative_maybe_null()) {
3020     return false;
3021   }
3022   // We already know this is always null
3023   if (this == TypePtr::NULL_PTR) {
3024     return false;
3025   }
3026   // We already know the speculative type is always null
3027   if (speculative_always_null()) {
3028     return false;
3029   }
3030   if (ptr_kind == ProfileAlwaysNull &amp;&amp; speculative() != NULL &amp;&amp; speculative()-&gt;isa_oopptr()) {
3031     return false;
3032   }
3033   return true;
3034 }
3035 
3036 //------------------------------dump2------------------------------------------
3037 const char *const TypePtr::ptr_msg[TypePtr::lastPTR] = {
3038   &quot;TopPTR&quot;,&quot;AnyNull&quot;,&quot;Constant&quot;,&quot;NULL&quot;,&quot;NotNull&quot;,&quot;BotPTR&quot;
3039 };
3040 
3041 #ifndef PRODUCT
3042 void TypePtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3043   if( _ptr == Null ) st-&gt;print(&quot;NULL&quot;);
3044   else st-&gt;print(&quot;%s *&quot;, ptr_msg[_ptr]);
3045   _offset.dump2(st);
3046   dump_inline_depth(st);
3047   dump_speculative(st);
3048 }
3049 
3050 /**
3051  *dump the speculative part of the type
3052  */
3053 void TypePtr::dump_speculative(outputStream *st) const {
3054   if (_speculative != NULL) {
3055     st-&gt;print(&quot; (speculative=&quot;);
3056     _speculative-&gt;dump_on(st);
3057     st-&gt;print(&quot;)&quot;);
3058   }
3059 }
3060 
3061 /**
3062  *dump the inline depth of the type
3063  */
3064 void TypePtr::dump_inline_depth(outputStream *st) const {
3065   if (_inline_depth != InlineDepthBottom) {
3066     if (_inline_depth == InlineDepthTop) {
3067       st-&gt;print(&quot; (inline_depth=InlineDepthTop)&quot;);
3068     } else {
3069       st-&gt;print(&quot; (inline_depth=%d)&quot;, _inline_depth);
3070     }
3071   }
3072 }
3073 #endif
3074 
3075 //------------------------------singleton--------------------------------------
3076 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3077 // constants
3078 bool TypePtr::singleton(void) const {
3079   // TopPTR, Null, AnyNull, Constant are all singletons
3080   return (_offset != Offset::bottom) &amp;&amp; !below_centerline(_ptr);
3081 }
3082 
3083 bool TypePtr::empty(void) const {
3084   return (_offset == Offset::top) || above_centerline(_ptr);
3085 }
3086 
3087 //=============================================================================
3088 // Convenience common pre-built types.
3089 const TypeRawPtr *TypeRawPtr::BOTTOM;
3090 const TypeRawPtr *TypeRawPtr::NOTNULL;
3091 
3092 //------------------------------make-------------------------------------------
3093 const TypeRawPtr *TypeRawPtr::make( enum PTR ptr ) {
3094   assert( ptr != Constant, &quot;what is the constant?&quot; );
3095   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
3096   return (TypeRawPtr*)(new TypeRawPtr(ptr,0))-&gt;hashcons();
3097 }
3098 
3099 const TypeRawPtr *TypeRawPtr::make( address bits ) {
3100   assert( bits, &quot;Use TypePtr for NULL&quot; );
3101   return (TypeRawPtr*)(new TypeRawPtr(Constant,bits))-&gt;hashcons();
3102 }
3103 
3104 //------------------------------cast_to_ptr_type-------------------------------
3105 const Type *TypeRawPtr::cast_to_ptr_type(PTR ptr) const {
3106   assert( ptr != Constant, &quot;what is the constant?&quot; );
3107   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
3108   assert( _bits==0, &quot;Why cast a constant address?&quot;);
3109   if( ptr == _ptr ) return this;
3110   return make(ptr);
3111 }
3112 
3113 //------------------------------get_con----------------------------------------
3114 intptr_t TypeRawPtr::get_con() const {
3115   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
3116   return (intptr_t)_bits;
3117 }
3118 
3119 //------------------------------meet-------------------------------------------
3120 // Compute the MEET of two types.  It returns a new Type object.
3121 const Type *TypeRawPtr::xmeet( const Type *t ) const {
3122   // Perform a fast test for common case; meeting the same types together.
3123   if( this == t ) return this;  // Meeting same type-rep?
3124 
3125   // Current &quot;this-&gt;_base&quot; is RawPtr
3126   switch( t-&gt;base() ) {         // switch on original type
3127   case Bottom:                  // Ye Olde Default
3128     return t;
3129   case Top:
3130     return this;
3131   case AnyPtr:                  // Meeting to AnyPtrs
3132     break;
3133   case RawPtr: {                // might be top, bot, any/not or constant
3134     enum PTR tptr = t-&gt;is_ptr()-&gt;ptr();
3135     enum PTR ptr = meet_ptr( tptr );
3136     if( ptr == Constant ) {     // Cannot be equal constants, so...
3137       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
3138       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
3139       ptr = NotNull;            // Fall down in lattice
3140     }
3141     return make( ptr );
3142   }
3143 
3144   case OopPtr:
3145   case InstPtr:
3146   case AryPtr:
3147   case MetadataPtr:
3148   case KlassPtr:
3149     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
3150   default:                      // All else is a mistake
3151     typerr(t);
3152   }
3153 
3154   // Found an AnyPtr type vs self-RawPtr type
3155   const TypePtr *tp = t-&gt;is_ptr();
3156   switch (tp-&gt;ptr()) {
3157   case TypePtr::TopPTR:  return this;
3158   case TypePtr::BotPTR:  return t;
3159   case TypePtr::Null:
3160     if( _ptr == TypePtr::TopPTR ) return t;
3161     return TypeRawPtr::BOTTOM;
3162   case TypePtr::NotNull: return TypePtr::make(AnyPtr, meet_ptr(TypePtr::NotNull), tp-&gt;meet_offset(0), tp-&gt;speculative(), tp-&gt;inline_depth());
3163   case TypePtr::AnyNull:
3164     if( _ptr == TypePtr::Constant) return this;
3165     return make( meet_ptr(TypePtr::AnyNull) );
3166   default: ShouldNotReachHere();
3167   }
3168   return this;
3169 }
3170 
3171 //------------------------------xdual------------------------------------------
3172 // Dual: compute field-by-field dual
3173 const Type *TypeRawPtr::xdual() const {
3174   return new TypeRawPtr( dual_ptr(), _bits );
3175 }
3176 
3177 //------------------------------add_offset-------------------------------------
3178 const TypePtr *TypeRawPtr::add_offset( intptr_t offset ) const {
3179   if( offset == OffsetTop ) return BOTTOM; // Undefined offset-&gt; undefined pointer
3180   if( offset == OffsetBot ) return BOTTOM; // Unknown offset-&gt; unknown pointer
3181   if( offset == 0 ) return this; // No change
3182   switch (_ptr) {
3183   case TypePtr::TopPTR:
3184   case TypePtr::BotPTR:
3185   case TypePtr::NotNull:
3186     return this;
3187   case TypePtr::Null:
3188   case TypePtr::Constant: {
3189     address bits = _bits+offset;
3190     if ( bits == 0 ) return TypePtr::NULL_PTR;
3191     return make( bits );
3192   }
3193   default:  ShouldNotReachHere();
3194   }
3195   return NULL;                  // Lint noise
3196 }
3197 
3198 //------------------------------eq---------------------------------------------
3199 // Structural equality check for Type representations
3200 bool TypeRawPtr::eq( const Type *t ) const {
3201   const TypeRawPtr *a = (const TypeRawPtr*)t;
3202   return _bits == a-&gt;_bits &amp;&amp; TypePtr::eq(t);
3203 }
3204 
3205 //------------------------------hash-------------------------------------------
3206 // Type-specific hashing function.
3207 int TypeRawPtr::hash(void) const {
3208   return (intptr_t)_bits + TypePtr::hash();
3209 }
3210 
3211 //------------------------------dump2------------------------------------------
3212 #ifndef PRODUCT
3213 void TypeRawPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3214   if( _ptr == Constant )
3215     st-&gt;print(INTPTR_FORMAT, p2i(_bits));
3216   else
3217     st-&gt;print(&quot;rawptr:%s&quot;, ptr_msg[_ptr]);
3218 }
3219 #endif
3220 
3221 //=============================================================================
3222 // Convenience common pre-built type.
3223 const TypeOopPtr *TypeOopPtr::BOTTOM;
3224 
3225 //------------------------------TypeOopPtr-------------------------------------
3226 TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset, Offset field_offset,
3227                        int instance_id, const TypePtr* speculative, int inline_depth)
3228   : TypePtr(t, ptr, offset, speculative, inline_depth),
3229     _const_oop(o), _klass(k),
3230     _klass_is_exact(xk),
3231     _is_ptr_to_narrowoop(false),
3232     _is_ptr_to_narrowklass(false),
3233     _is_ptr_to_boxed_value(false),
3234     _instance_id(instance_id) {
3235   if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; (t == InstPtr) &amp;&amp;
3236       (offset.get() &gt; 0) &amp;&amp; xk &amp;&amp; (k != 0) &amp;&amp; k-&gt;is_instance_klass()) {
3237     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset.get());
3238   }
3239 #ifdef _LP64
3240   if (this-&gt;offset() &gt; 0 || this-&gt;offset() == Type::OffsetTop || this-&gt;offset() == Type::OffsetBot) {
3241     if (this-&gt;offset() == oopDesc::klass_offset_in_bytes()) {
3242       _is_ptr_to_narrowklass = UseCompressedClassPointers;
3243     } else if (klass() == NULL) {
3244       // Array with unknown body type
3245       assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
3246       _is_ptr_to_narrowoop = UseCompressedOops;
3247     } else if (UseCompressedOops &amp;&amp; this-&gt;isa_aryptr() &amp;&amp; this-&gt;offset() != arrayOopDesc::length_offset_in_bytes()) {
3248       if (klass()-&gt;is_obj_array_klass()) {
3249         _is_ptr_to_narrowoop = true;
3250       } else if (klass()-&gt;is_value_array_klass() &amp;&amp; field_offset != Offset::top &amp;&amp; field_offset != Offset::bottom) {
3251         // Check if the field of the value type array element contains oops
3252         ciValueKlass* vk = klass()-&gt;as_value_array_klass()-&gt;element_klass()-&gt;as_value_klass();
3253         int foffset = field_offset.get() + vk-&gt;first_field_offset();
3254         ciField* field = vk-&gt;get_field_by_offset(foffset, false);
3255         assert(field != NULL, &quot;missing field&quot;);
3256         BasicType bt = field-&gt;layout_type();
3257         _is_ptr_to_narrowoop = (bt == T_OBJECT || bt == T_ARRAY || T_INLINE_TYPE);
3258       }
3259     } else if (klass()-&gt;is_instance_klass()) {
3260       if (this-&gt;isa_klassptr()) {
3261         // Perm objects don&#39;t use compressed references
3262       } else if (_offset == Offset::bottom || _offset == Offset::top) {
3263         // unsafe access
3264         _is_ptr_to_narrowoop = UseCompressedOops;
3265       } else { // exclude unsafe ops
3266         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3267         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3268             (this-&gt;offset() == java_lang_Class::klass_offset() ||
3269              this-&gt;offset() == java_lang_Class::array_klass_offset())) {
3270           // Special hidden fields from the Class.
3271           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3272           _is_ptr_to_narrowoop = false;
3273         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3274                    this-&gt;offset() &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
3275           // Static fields
3276           assert(o != NULL, &quot;must be constant&quot;);
3277           ciInstanceKlass* ik = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
3278           BasicType basic_elem_type;
3279           if (ik-&gt;is_valuetype() &amp;&amp; this-&gt;offset() == ik-&gt;as_value_klass()-&gt;default_value_offset()) {
3280             // Special hidden field that contains the oop of the default value type
3281             basic_elem_type = T_INLINE_TYPE;
3282           } else {
3283             ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), true);
3284             assert(field != NULL, &quot;missing field&quot;);
3285             basic_elem_type = field-&gt;layout_type();
3286           }
3287           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3288         } else {
3289           // Instance fields which contains a compressed oop references.
3290           ciInstanceKlass* ik = klass()-&gt;as_instance_klass();
3291           ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), false);
3292           if (field != NULL) {
3293             BasicType basic_elem_type = field-&gt;layout_type();
3294             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3295           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3296             // Compile::find_alias_type() cast exactness on all types to verify
3297             // that it does not affect alias type.
3298             _is_ptr_to_narrowoop = UseCompressedOops;
3299           } else {
3300             // Type for the copy start in LibraryCallKit::inline_native_clone().
3301             _is_ptr_to_narrowoop = UseCompressedOops;
3302           }
3303         }
3304       }
3305     }
3306   }
3307 #endif
3308 }
3309 
3310 //------------------------------make-------------------------------------------
3311 const TypeOopPtr *TypeOopPtr::make(PTR ptr, Offset offset, int instance_id,
3312                                    const TypePtr* speculative, int inline_depth) {
3313   assert(ptr != Constant, &quot;no constant generic pointers&quot;);
3314   ciKlass*  k = Compile::current()-&gt;env()-&gt;Object_klass();
3315   bool      xk = false;
3316   ciObject* o = NULL;
3317   return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, Offset::bottom, instance_id, speculative, inline_depth))-&gt;hashcons();
3318 }
3319 
3320 
3321 //------------------------------cast_to_ptr_type-------------------------------
3322 const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {
3323   assert(_base == OopPtr, &quot;subclass must override cast_to_ptr_type&quot;);
3324   if( ptr == _ptr ) return this;
3325   return make(ptr, _offset, _instance_id, _speculative, _inline_depth);
3326 }
3327 
3328 //-----------------------------cast_to_instance_id----------------------------
3329 const TypeOopPtr *TypeOopPtr::cast_to_instance_id(int instance_id) const {
3330   // There are no instances of a general oop.
3331   // Return self unchanged.
3332   return this;
3333 }
3334 
3335 //-----------------------------cast_to_exactness-------------------------------
3336 const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {
3337   // There is no such thing as an exact general oop.
3338   // Return self unchanged.
3339   return this;
3340 }
3341 
3342 
3343 //------------------------------as_klass_type----------------------------------
3344 // Return the klass type corresponding to this instance or array type.
3345 // It is the type that is loaded from an object of this type.
3346 const TypeKlassPtr* TypeOopPtr::as_klass_type() const {
3347   ciKlass* k = klass();
3348   bool    xk = klass_is_exact();
3349   if (k == NULL)
3350     return TypeKlassPtr::OBJECT;
3351   else
3352     return TypeKlassPtr::make(xk? Constant: NotNull, k, Offset(0), isa_instptr() &amp;&amp; is_instptr()-&gt;flat_array());
3353 }
3354 
3355 //------------------------------meet-------------------------------------------
3356 // Compute the MEET of two types.  It returns a new Type object.
3357 const Type *TypeOopPtr::xmeet_helper(const Type *t) const {
3358   // Perform a fast test for common case; meeting the same types together.
3359   if( this == t ) return this;  // Meeting same type-rep?
3360 
3361   // Current &quot;this-&gt;_base&quot; is OopPtr
3362   switch (t-&gt;base()) {          // switch on original type
3363 
3364   case Int:                     // Mixing ints &amp; oops happens when javac
3365   case Long:                    // reuses local variables
3366   case FloatTop:
3367   case FloatCon:
3368   case FloatBot:
3369   case DoubleTop:
3370   case DoubleCon:
3371   case DoubleBot:
3372   case NarrowOop:
3373   case NarrowKlass:
3374   case Bottom:                  // Ye Olde Default
3375     return Type::BOTTOM;
3376   case Top:
3377     return this;
3378 
3379   default:                      // All else is a mistake
3380     typerr(t);
3381 
3382   case RawPtr:
3383   case MetadataPtr:
3384   case KlassPtr:
3385     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
3386 
3387   case AnyPtr: {
3388     // Found an AnyPtr type vs self-OopPtr type
3389     const TypePtr *tp = t-&gt;is_ptr();
3390     Offset offset = meet_offset(tp-&gt;offset());
3391     PTR ptr = meet_ptr(tp-&gt;ptr());
3392     const TypePtr* speculative = xmeet_speculative(tp);
3393     int depth = meet_inline_depth(tp-&gt;inline_depth());
3394     switch (tp-&gt;ptr()) {
3395     case Null:
3396       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3397       // else fall through:
3398     case TopPTR:
3399     case AnyNull: {
3400       int instance_id = meet_instance_id(InstanceTop);
3401       return make(ptr, offset, instance_id, speculative, depth);
3402     }
3403     case BotPTR:
3404     case NotNull:
3405       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3406     default: typerr(t);
3407     }
3408   }
3409 
3410   case OopPtr: {                 // Meeting to other OopPtrs
3411     const TypeOopPtr *tp = t-&gt;is_oopptr();
3412     int instance_id = meet_instance_id(tp-&gt;instance_id());
3413     const TypePtr* speculative = xmeet_speculative(tp);
3414     int depth = meet_inline_depth(tp-&gt;inline_depth());
3415     return make(meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), instance_id, speculative, depth);
3416   }
3417 
3418   case InstPtr:                  // For these, flip the call around to cut down
3419   case AryPtr:
3420     return t-&gt;xmeet(this);      // Call in reverse direction
3421 
3422   } // End of switch
3423   return this;                  // Return the double constant
3424 }
3425 
3426 
3427 //------------------------------xdual------------------------------------------
3428 // Dual of a pure heap pointer.  No relevant klass or oop information.
3429 const Type *TypeOopPtr::xdual() const {
3430   assert(klass() == Compile::current()-&gt;env()-&gt;Object_klass(), &quot;no klasses here&quot;);
3431   assert(const_oop() == NULL,             &quot;no constants here&quot;);
3432   return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), Offset::bottom, dual_instance_id(), dual_speculative(), dual_inline_depth());
3433 }
3434 
3435 //--------------------------make_from_klass_common-----------------------------
3436 // Computes the element-type given a klass.
3437 const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {
3438   if (klass-&gt;is_instance_klass() || klass-&gt;is_valuetype()) {
3439     Compile* C = Compile::current();
3440     Dependencies* deps = C-&gt;dependencies();
3441     assert((deps != NULL) == (C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;code_size() &gt; 0), &quot;sanity&quot;);
3442     // Element is an instance
3443     bool klass_is_exact = false;
3444     if (klass-&gt;is_loaded()) {
3445       // Try to set klass_is_exact.
3446       ciInstanceKlass* ik = klass-&gt;as_instance_klass();
3447       klass_is_exact = ik-&gt;is_final();
3448       if (!klass_is_exact &amp;&amp; klass_change
3449           &amp;&amp; deps != NULL &amp;&amp; UseUniqueSubclasses) {
3450         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3451         if (sub != NULL) {
3452           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3453           klass = ik = sub;
3454           klass_is_exact = sub-&gt;is_final();
3455         }
3456       }
3457       if (!klass_is_exact &amp;&amp; try_for_exact
3458           &amp;&amp; deps != NULL &amp;&amp; UseExactTypes) {
3459         if (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3460           // Add a dependence; if concrete subclass added we need to recompile
3461           deps-&gt;assert_leaf_type(ik);
3462           klass_is_exact = true;
3463         }
3464       }
3465     }
3466     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0), klass-&gt;flatten_array());
3467   } else if (klass-&gt;is_obj_array_klass()) {
3468     // Element is an object or value array. Recursively call ourself.
3469     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ false, try_for_exact);
3470     if (etype-&gt;is_valuetypeptr()) {
3471       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3472     }
3473     // Determine null-free/flattened properties
3474     const TypeOopPtr* exact_etype = etype;
3475     if (etype-&gt;can_be_value_type()) {
3476       // Use exact type if element can be a value type
3477       exact_etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ true, /* try_for_exact= */ true);
3478     }
3479     bool not_null_free = !exact_etype-&gt;can_be_value_type();
3480     bool not_flat = !UseFlatArray || not_null_free || (exact_etype-&gt;is_valuetypeptr() &amp;&amp; !exact_etype-&gt;value_klass()-&gt;flatten_array());
3481 
3482     bool xk = etype-&gt;klass_is_exact();
3483     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);
3484     // We used to pass NotNull in here, asserting that the sub-arrays
3485     // are all not-null.  This is not true in generally, as code can
3486     // slam NULLs down in the subarrays.
3487     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, Offset(0));
3488     return arr;
3489   } else if (klass-&gt;is_type_array_klass()) {
3490     // Element is an typeArray
3491     const Type* etype = get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3492     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS,
3493                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);
3494     // We used to pass NotNull in here, asserting that the array pointer
3495     // is not-null. That was not true in general.
3496     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
3497     return arr;
3498   } else if (klass-&gt;is_value_array_klass()) {
3499     ciValueKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_value_klass();
3500     const TypeAry* arr0 = TypeAry::make(TypeValueType::make(vk), TypeInt::POS);
3501     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
3502     return arr;
3503   } else {
3504     ShouldNotReachHere();
3505     return NULL;
3506   }
3507 }
3508 
3509 //------------------------------make_from_constant-----------------------------
3510 // Make a java pointer from an oop constant
3511 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3512   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3513 
3514   const bool make_constant = require_constant || o-&gt;should_be_constant();
3515 
3516   ciKlass* klass = o-&gt;klass();
3517   if (klass-&gt;is_instance_klass() || klass-&gt;is_valuetype()) {
3518     // Element is an instance or value type
3519     if (make_constant) {
3520       return TypeInstPtr::make(o);
3521     } else {
3522       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0), klass-&gt;flatten_array());
3523     }
3524   } else if (klass-&gt;is_obj_array_klass()) {
3525     // Element is an object array. Recursively call ourself.
3526     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass-&gt;as_array_klass()-&gt;element_klass());
3527     bool null_free = false;
3528     if (etype-&gt;is_valuetypeptr()) {
3529       null_free = true;
3530       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3531     }
3532     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
3533                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ !null_free);
3534     // We used to pass NotNull in here, asserting that the sub-arrays
3535     // are all not-null.  This is not true in generally, as code can
3536     // slam NULLs down in the subarrays.
3537     if (make_constant) {
3538       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3539     } else {
3540       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3541     }
3542   } else if (klass-&gt;is_type_array_klass()) {
3543     // Element is an typeArray
3544     const Type* etype = (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3545     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
3546                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);
3547     // We used to pass NotNull in here, asserting that the array pointer
3548     // is not-null. That was not true in general.
3549     if (make_constant) {
3550       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3551     } else {
3552       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3553     }
3554   } else if (klass-&gt;is_value_array_klass()) {
3555     ciValueKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_value_klass();
3556     const TypeAry* arr0 = TypeAry::make(TypeValueType::make(vk), TypeInt::make(o-&gt;as_array()-&gt;length()));
3557     // We used to pass NotNull in here, asserting that the sub-arrays
3558     // are all not-null.  This is not true in generally, as code can
3559     // slam NULLs down in the subarrays.
3560     if (make_constant) {
3561       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3562     } else {
3563       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3564     }
3565   }
3566 
3567   fatal(&quot;unhandled object type&quot;);
3568   return NULL;
3569 }
3570 
3571 //------------------------------get_con----------------------------------------
3572 intptr_t TypeOopPtr::get_con() const {
3573   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
3574   assert(offset() &gt;= 0, &quot;&quot;);
3575 
3576   if (offset() != 0) {
3577     // After being ported to the compiler interface, the compiler no longer
3578     // directly manipulates the addresses of oops.  Rather, it only has a pointer
3579     // to a handle at compile time.  This handle is embedded in the generated
3580     // code and dereferenced at the time the nmethod is made.  Until that time,
3581     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
3582     // have access to the addresses!).  This does not seem to currently happen,
3583     // but this assertion here is to help prevent its occurence.
3584     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
3585     ShouldNotReachHere();
3586   }
3587 
3588   return (intptr_t)const_oop()-&gt;constant_encoding();
3589 }
3590 
3591 
3592 //-----------------------------filter------------------------------------------
3593 // Do not allow interface-vs.-noninterface joins to collapse to top.
3594 const Type *TypeOopPtr::filter_helper(const Type *kills, bool include_speculative) const {
3595 
3596   const Type* ft = join_helper(kills, include_speculative);
3597   const TypeInstPtr* ftip = ft-&gt;isa_instptr();
3598   const TypeInstPtr* ktip = kills-&gt;isa_instptr();
3599 
3600   if (ft-&gt;empty()) {
3601     // Check for evil case of &#39;this&#39; being a class and &#39;kills&#39; expecting an
3602     // interface.  This can happen because the bytecodes do not contain
3603     // enough type info to distinguish a Java-level interface variable
3604     // from a Java-level object variable.  If we meet 2 classes which
3605     // both implement interface I, but their meet is at &#39;j/l/O&#39; which
3606     // doesn&#39;t implement I, we have no way to tell if the result should
3607     // be &#39;I&#39; or &#39;j/l/O&#39;.  Thus we&#39;ll pick &#39;j/l/O&#39;.  If this then flows
3608     // into a Phi which &quot;knows&quot; it&#39;s an Interface type we&#39;ll have to
3609     // uplift the type.
3610     if (!empty()) {
3611       if (ktip != NULL &amp;&amp; ktip-&gt;is_loaded() &amp;&amp; ktip-&gt;klass()-&gt;is_interface()) {
3612         return kills;           // Uplift to interface
3613       }
3614       // Also check for evil cases of &#39;this&#39; being a class array
3615       // and &#39;kills&#39; expecting an array of interfaces.
3616       Type::get_arrays_base_elements(ft, kills, NULL, &amp;ktip);
3617       if (ktip != NULL &amp;&amp; ktip-&gt;is_loaded() &amp;&amp; ktip-&gt;klass()-&gt;is_interface()) {
3618         return kills;           // Uplift to array of interface
3619       }
3620     }
3621 
3622     return Type::TOP;           // Canonical empty value
3623   }
3624 
3625   // If we have an interface-typed Phi or cast and we narrow to a class type,
3626   // the join should report back the class.  However, if we have a J/L/Object
3627   // class-typed Phi and an interface flows in, it&#39;s possible that the meet &amp;
3628   // join report an interface back out.  This isn&#39;t possible but happens
3629   // because the type system doesn&#39;t interact well with interfaces.
3630   if (ftip != NULL &amp;&amp; ktip != NULL &amp;&amp;
3631       ftip-&gt;is_loaded() &amp;&amp;  ftip-&gt;klass()-&gt;is_interface() &amp;&amp;
3632       ktip-&gt;is_loaded() &amp;&amp; !ktip-&gt;klass()-&gt;is_interface()) {
3633     assert(!ftip-&gt;klass_is_exact(), &quot;interface could not be exact&quot;);
3634     return ktip-&gt;cast_to_ptr_type(ftip-&gt;ptr());
3635   }
3636 
3637   return ft;
3638 }
3639 
3640 //------------------------------eq---------------------------------------------
3641 // Structural equality check for Type representations
3642 bool TypeOopPtr::eq( const Type *t ) const {
3643   const TypeOopPtr *a = (const TypeOopPtr*)t;
3644   if (_klass_is_exact != a-&gt;_klass_is_exact ||
3645       _instance_id != a-&gt;_instance_id)  return false;
3646   ciObject* one = const_oop();
3647   ciObject* two = a-&gt;const_oop();
3648   if (one == NULL || two == NULL) {
3649     return (one == two) &amp;&amp; TypePtr::eq(t);
3650   } else {
3651     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
3652   }
3653 }
3654 
3655 //------------------------------hash-------------------------------------------
3656 // Type-specific hashing function.
3657 int TypeOopPtr::hash(void) const {
3658   return
3659     java_add(java_add((jint)(const_oop() ? const_oop()-&gt;hash() : 0), (jint)_klass_is_exact),
3660              java_add((jint)_instance_id, (jint)TypePtr::hash()));
3661 }
3662 
3663 //------------------------------dump2------------------------------------------
3664 #ifndef PRODUCT
3665 void TypeOopPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3666   st-&gt;print(&quot;oopptr:%s&quot;, ptr_msg[_ptr]);
3667   if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3668   if( const_oop() ) st-&gt;print(INTPTR_FORMAT, p2i(const_oop()));
3669   _offset.dump2(st);
3670   if (_instance_id == InstanceTop)
3671     st-&gt;print(&quot;,iid=top&quot;);
3672   else if (_instance_id != InstanceBot)
3673     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
3674 
3675   dump_inline_depth(st);
3676   dump_speculative(st);
3677 }
3678 #endif
3679 
3680 //------------------------------singleton--------------------------------------
3681 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3682 // constants
3683 bool TypeOopPtr::singleton(void) const {
3684   // detune optimizer to not generate constant oop + constant offset as a constant!
3685   // TopPTR, Null, AnyNull, Constant are all singletons
3686   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);
3687 }
3688 
3689 //------------------------------add_offset-------------------------------------
3690 const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {
3691   return make(_ptr, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
3692 }
3693 
3694 /**
3695  * Return same type without a speculative part
3696  */
3697 const Type* TypeOopPtr::remove_speculative() const {
3698   if (_speculative == NULL) {
3699     return this;
3700   }
3701   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
3702   return make(_ptr, _offset, _instance_id, NULL, _inline_depth);
3703 }
3704 
3705 /**
3706  * Return same type but drop speculative part if we know we won&#39;t use
3707  * it
3708  */
3709 const Type* TypeOopPtr::cleanup_speculative() const {
3710   // If the klass is exact and the ptr is not null then there&#39;s
3711   // nothing that the speculative type can help us with
3712   if (klass_is_exact() &amp;&amp; !maybe_null()) {
3713     return remove_speculative();
3714   }
3715   return TypePtr::cleanup_speculative();
3716 }
3717 
3718 /**
3719  * Return same type but with a different inline depth (used for speculation)
3720  *
3721  * @param depth  depth to meet with
3722  */
3723 const TypePtr* TypeOopPtr::with_inline_depth(int depth) const {
3724   if (!UseInlineDepthForSpeculativeTypes) {
3725     return this;
3726   }
3727   return make(_ptr, _offset, _instance_id, _speculative, depth);
3728 }
3729 
3730 //------------------------------with_instance_id--------------------------------
3731 const TypePtr* TypeOopPtr::with_instance_id(int instance_id) const {
3732   assert(_instance_id != -1, &quot;should be known&quot;);
3733   return make(_ptr, _offset, instance_id, _speculative, _inline_depth);
3734 }
3735 
3736 //------------------------------meet_instance_id--------------------------------
3737 int TypeOopPtr::meet_instance_id( int instance_id ) const {
3738   // Either is &#39;TOP&#39; instance?  Return the other instance!
3739   if( _instance_id == InstanceTop ) return  instance_id;
3740   if(  instance_id == InstanceTop ) return _instance_id;
3741   // If either is different, return &#39;BOTTOM&#39; instance
3742   if( _instance_id != instance_id ) return InstanceBot;
3743   return _instance_id;
3744 }
3745 
3746 //------------------------------dual_instance_id--------------------------------
3747 int TypeOopPtr::dual_instance_id( ) const {
3748   if( _instance_id == InstanceTop ) return InstanceBot; // Map TOP into BOTTOM
3749   if( _instance_id == InstanceBot ) return InstanceTop; // Map BOTTOM into TOP
3750   return _instance_id;              // Map everything else into self
3751 }
3752 
3753 /**
3754  * Check whether new profiling would improve speculative type
3755  *
3756  * @param   exact_kls    class from profiling
3757  * @param   inline_depth inlining depth of profile point
3758  *
3759  * @return  true if type profile is valuable
3760  */
3761 bool TypeOopPtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
3762   // no way to improve an already exact type
3763   if (klass_is_exact()) {
3764     return false;
3765   }
3766   return TypePtr::would_improve_type(exact_kls, inline_depth);
3767 }
3768 
3769 //=============================================================================
3770 // Convenience common pre-built types.
3771 const TypeInstPtr *TypeInstPtr::NOTNULL;
3772 const TypeInstPtr *TypeInstPtr::BOTTOM;
3773 const TypeInstPtr *TypeInstPtr::MIRROR;
3774 const TypeInstPtr *TypeInstPtr::MARK;
3775 const TypeInstPtr *TypeInstPtr::KLASS;
3776 
3777 //------------------------------TypeInstPtr-------------------------------------
3778 TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset off,
3779                          bool flat_array, int instance_id, const TypePtr* speculative,
3780                          int inline_depth)
3781   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),
3782     _name(k-&gt;name()), _flat_array(flat_array) {
3783    assert(k != NULL &amp;&amp;
3784           (k-&gt;is_loaded() || o == NULL),
3785           &quot;cannot have constants with non-loaded klass&quot;);
3786    assert(!klass()-&gt;is_valuetype() || !klass()-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);
3787    assert(!flat_array || can_be_value_type(), &quot;incorrect flatten array bit&quot;);
3788 };
3789 
3790 //------------------------------make-------------------------------------------
3791 const TypeInstPtr *TypeInstPtr::make(PTR ptr,
3792                                      ciKlass* k,
3793                                      bool xk,
3794                                      ciObject* o,
3795                                      Offset offset,
3796                                      bool flat_array,
3797                                      int instance_id,
3798                                      const TypePtr* speculative,
3799                                      int inline_depth) {
3800   assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
3801   // Either const_oop() is NULL or else ptr is Constant
3802   assert( (!o &amp;&amp; ptr != Constant) || (o &amp;&amp; ptr == Constant),
3803           &quot;constant pointers must have a value supplied&quot; );
3804   // Ptr is never Null
3805   assert( ptr != Null, &quot;NULL pointers are not typed&quot; );
3806 
3807   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
3808   if (!UseExactTypes)  xk = false;
3809   if (ptr == Constant) {
3810     // Note:  This case includes meta-object constants, such as methods.
3811     xk = true;
3812   } else if (k-&gt;is_loaded()) {
3813     ciInstanceKlass* ik = k-&gt;as_instance_klass();
3814     if (!xk &amp;&amp; ik-&gt;is_final())     xk = true;   // no inexact final klass
3815     if (xk &amp;&amp; ik-&gt;is_interface())  xk = false;  // no exact interface
3816   }
3817 
3818   // Now hash this baby
3819   TypeInstPtr *result =
3820     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, flat_array, instance_id, speculative, inline_depth))-&gt;hashcons();
3821 
3822   return result;
3823 }
3824 
3825 /**
3826  *  Create constant type for a constant boxed value
3827  */
3828 const Type* TypeInstPtr::get_const_boxed_value() const {
3829   assert(is_ptr_to_boxed_value(), &quot;should be called only for boxed value&quot;);
3830   assert((const_oop() != NULL), &quot;should be called only for constant object&quot;);
3831   ciConstant constant = const_oop()-&gt;as_instance()-&gt;field_value_by_offset(offset());
3832   BasicType bt = constant.basic_type();
3833   switch (bt) {
3834     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
3835     case T_INT:      return TypeInt::make(constant.as_int());
3836     case T_CHAR:     return TypeInt::make(constant.as_char());
3837     case T_BYTE:     return TypeInt::make(constant.as_byte());
3838     case T_SHORT:    return TypeInt::make(constant.as_short());
3839     case T_FLOAT:    return TypeF::make(constant.as_float());
3840     case T_DOUBLE:   return TypeD::make(constant.as_double());
3841     case T_LONG:     return TypeLong::make(constant.as_long());
3842     default:         break;
3843   }
3844   fatal(&quot;Invalid boxed value type &#39;%s&#39;&quot;, type2name(bt));
3845   return NULL;
3846 }
3847 
3848 //------------------------------cast_to_ptr_type-------------------------------
3849 const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
3850   if( ptr == _ptr ) return this;
3851   // Reconstruct _sig info here since not a problem with later lazy
3852   // construction, _sig will show up on demand.
3853   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);
3854 }
3855 
3856 
3857 //-----------------------------cast_to_exactness-------------------------------
3858 const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
3859   if( klass_is_exact == _klass_is_exact ) return this;
3860   if (!UseExactTypes)  return this;
3861   if (!_klass-&gt;is_loaded())  return this;
3862   ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
3863   if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
3864   if( ik-&gt;is_interface() )              return this;  // cannot set xk
3865   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);
3866 }
3867 
3868 //-----------------------------cast_to_instance_id----------------------------
3869 const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
3870   if( instance_id == _instance_id ) return this;
3871   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, _flat_array, instance_id, _speculative, _inline_depth);
3872 }
3873 
3874 //------------------------------xmeet_unloaded---------------------------------
3875 // Compute the MEET of two InstPtrs when at least one is unloaded.
3876 // Assume classes are different since called after check for same name/class-loader
3877 const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
3878     Offset off = meet_offset(tinst-&gt;offset());
3879     PTR ptr = meet_ptr(tinst-&gt;ptr());
3880     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3881     const TypePtr* speculative = xmeet_speculative(tinst);
3882     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3883 
3884     const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;
3885     const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;
3886     if( loaded-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) ) {
3887       //
3888       // Meet unloaded class with java/lang/Object
3889       //
3890       // Meet
3891       //          |                     Unloaded Class
3892       //  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |
3893       //  ===================================================================
3894       //   TOP    | ..........................Unloaded......................|
3895       //  AnyNull |  U-AN    |................Unloaded......................|
3896       // Constant | ... O-NN .................................. |   O-BOT   |
3897       //  NotNull | ... O-NN .................................. |   O-BOT   |
3898       //  BOTTOM  | ........................Object-BOTTOM ..................|
3899       //
3900       assert(loaded-&gt;ptr() != TypePtr::Null, &quot;insanity check&quot;);
3901       //
3902       if(      loaded-&gt;ptr() == TypePtr::TopPTR ) { return unloaded; }
3903       else if (loaded-&gt;ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded-&gt;klass(), false, NULL, off, false, instance_id, speculative, depth); }
3904       else if (loaded-&gt;ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }
3905       else if (loaded-&gt;ptr() == TypePtr::Constant || loaded-&gt;ptr() == TypePtr::NotNull) {
3906         if (unloaded-&gt;ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }
3907         else                                      { return TypeInstPtr::NOTNULL; }
3908       }
3909       else if( unloaded-&gt;ptr() == TypePtr::TopPTR )  { return unloaded; }
3910 
3911       return unloaded-&gt;cast_to_ptr_type(TypePtr::AnyNull)-&gt;is_instptr();
3912     }
3913 
3914     // Both are unloaded, not the same class, not Object
3915     // Or meet unloaded with a different loaded class, not java/lang/Object
3916     if( ptr != TypePtr::BotPTR ) {
3917       return TypeInstPtr::NOTNULL;
3918     }
3919     return TypeInstPtr::BOTTOM;
3920 }
3921 
3922 
3923 //------------------------------meet-------------------------------------------
3924 // Compute the MEET of two types.  It returns a new Type object.
3925 const Type *TypeInstPtr::xmeet_helper(const Type *t) const {
3926   // Perform a fast test for common case; meeting the same types together.
3927   if( this == t ) return this;  // Meeting same type-rep?
3928 
3929   // Current &quot;this-&gt;_base&quot; is Pointer
3930   switch (t-&gt;base()) {          // switch on original type
3931 
3932   case Int:                     // Mixing ints &amp; oops happens when javac
3933   case Long:                    // reuses local variables
3934   case FloatTop:
3935   case FloatCon:
3936   case FloatBot:
3937   case DoubleTop:
3938   case DoubleCon:
3939   case DoubleBot:
3940   case NarrowOop:
3941   case NarrowKlass:
3942   case Bottom:                  // Ye Olde Default
3943     return Type::BOTTOM;
3944   case Top:
3945     return this;
3946 
3947   default:                      // All else is a mistake
3948     typerr(t);
3949 
3950   case MetadataPtr:
3951   case KlassPtr:
3952   case RawPtr: return TypePtr::BOTTOM;
3953 
3954   case AryPtr: {                // All arrays inherit from Object class
3955     const TypeAryPtr *tp = t-&gt;is_aryptr();
3956     Offset offset = meet_offset(tp-&gt;offset());
3957     PTR ptr = meet_ptr(tp-&gt;ptr());
3958     int instance_id = meet_instance_id(tp-&gt;instance_id());
3959     const TypePtr* speculative = xmeet_speculative(tp);
3960     int depth = meet_inline_depth(tp-&gt;inline_depth());
3961     switch (ptr) {
3962     case TopPTR:
3963     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
3964       // For instances when a subclass meets a superclass we fall
3965       // below the centerline when the superclass is exact. We need to
3966       // do the same here.
3967       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flat_array()) {
3968         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
3969       } else {
3970         // cannot subclass, so the meet has to fall badly below the centerline
3971         ptr = NotNull;
3972         instance_id = InstanceBot;
3973         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
3974       }
3975     case Constant:
3976     case NotNull:
3977     case BotPTR:                // Fall down to object klass
3978       // LCA is object_klass, but if we subclass from the top we can do better
3979       if( above_centerline(_ptr) ) { // if( _ptr == TopPTR || _ptr == AnyNull )
3980         // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
3981         // then we can subclass in the Java class hierarchy.
3982         // For instances when a subclass meets a superclass we fall
3983         // below the centerline when the superclass is exact. We need
3984         // to do the same here.
3985         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flat_array()) {
3986           // that is, tp&#39;s array type is a subtype of my klass
3987           return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
3988                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
3989         }
3990       }
3991       // The other case cannot happen, since I cannot be a subtype of an array.
3992       // The meet falls down to Object class below centerline.
3993       if( ptr == Constant )
3994          ptr = NotNull;
3995       instance_id = InstanceBot;
3996       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
3997     default: typerr(t);
3998     }
3999   }
4000 
4001   case OopPtr: {                // Meeting to OopPtrs
4002     // Found a OopPtr type vs self-InstPtr type
4003     const TypeOopPtr *tp = t-&gt;is_oopptr();
4004     Offset offset = meet_offset(tp-&gt;offset());
4005     PTR ptr = meet_ptr(tp-&gt;ptr());
4006     switch (tp-&gt;ptr()) {
4007     case TopPTR:
4008     case AnyNull: {
4009       int instance_id = meet_instance_id(InstanceTop);
4010       const TypePtr* speculative = xmeet_speculative(tp);
4011       int depth = meet_inline_depth(tp-&gt;inline_depth());
4012       return make(ptr, klass(), klass_is_exact(),
4013                   (ptr == Constant ? const_oop() : NULL), offset, flat_array(), instance_id, speculative, depth);
4014     }
4015     case NotNull:
4016     case BotPTR: {
4017       int instance_id = meet_instance_id(tp-&gt;instance_id());
4018       const TypePtr* speculative = xmeet_speculative(tp);
4019       int depth = meet_inline_depth(tp-&gt;inline_depth());
4020       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4021     }
4022     default: typerr(t);
4023     }
4024   }
4025 
4026   case AnyPtr: {                // Meeting to AnyPtrs
4027     // Found an AnyPtr type vs self-InstPtr type
4028     const TypePtr *tp = t-&gt;is_ptr();
4029     Offset offset = meet_offset(tp-&gt;offset());
4030     PTR ptr = meet_ptr(tp-&gt;ptr());
4031     int instance_id = meet_instance_id(InstanceTop);
4032     const TypePtr* speculative = xmeet_speculative(tp);
4033     int depth = meet_inline_depth(tp-&gt;inline_depth());
4034     switch (tp-&gt;ptr()) {
4035     case Null:
4036       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4037       // else fall through to AnyNull
4038     case TopPTR:
4039     case AnyNull: {
4040       return make(ptr, klass(), klass_is_exact(),
4041                   (ptr == Constant ? const_oop() : NULL), offset, flat_array(), instance_id, speculative, depth);
4042     }
4043     case NotNull:
4044     case BotPTR:
4045       return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
4046     default: typerr(t);
4047     }
4048   }
4049 
4050   /*
4051                  A-top         }
4052                /   |   \       }  Tops
4053            B-top A-any C-top   }
4054               | /  |  \ |      }  Any-nulls
4055            B-any   |   C-any   }
4056               |    |    |
4057            B-con A-con C-con   } constants; not comparable across classes
4058               |    |    |
4059            B-not   |   C-not   }
4060               | \  |  / |      }  not-nulls
4061            B-bot A-not C-bot   }
4062                \   |   /       }  Bottoms
4063                  A-bot         }
4064   */
4065 
4066   case InstPtr: {                // Meeting 2 Oops?
4067     // Found an InstPtr sub-type vs self-InstPtr type
4068     const TypeInstPtr *tinst = t-&gt;is_instptr();
4069     Offset off = meet_offset( tinst-&gt;offset() );
4070     PTR ptr = meet_ptr( tinst-&gt;ptr() );
4071     int instance_id = meet_instance_id(tinst-&gt;instance_id());
4072     const TypePtr* speculative = xmeet_speculative(tinst);
4073     int depth = meet_inline_depth(tinst-&gt;inline_depth());
4074 
4075     // Check for easy case; klasses are equal (and perhaps not loaded!)
4076     // If we have constants, then we created oops so classes are loaded
4077     // and we can handle the constants further down.  This case handles
4078     // both-not-loaded or both-loaded classes
4079     if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact() &amp;&amp;
4080         flat_array() == tinst-&gt;flat_array()) {
4081       return make(ptr, klass(), klass_is_exact(), NULL, off, flat_array(), instance_id, speculative, depth);
4082     }
4083 
4084     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
4085     ciKlass* tinst_klass = tinst-&gt;klass();
4086     ciKlass* this_klass  = this-&gt;klass();
4087     bool tinst_xk = tinst-&gt;klass_is_exact();
4088     bool this_xk  = this-&gt;klass_is_exact();
4089     bool tinst_flat_array = tinst-&gt;flat_array();
4090     bool this_flat_array  = this-&gt;flat_array();
4091     if (!tinst_klass-&gt;is_loaded() || !this_klass-&gt;is_loaded() ) {
4092       // One of these classes has not been loaded
4093       const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
4094 #ifndef PRODUCT
4095       if( PrintOpto &amp;&amp; Verbose ) {
4096         tty-&gt;print(&quot;meet of unloaded classes resulted in: &quot;); unloaded_meet-&gt;dump(); tty-&gt;cr();
4097         tty-&gt;print(&quot;  this == &quot;); this-&gt;dump(); tty-&gt;cr();
4098         tty-&gt;print(&quot; tinst == &quot;); tinst-&gt;dump(); tty-&gt;cr();
4099       }
4100 #endif
4101       return unloaded_meet;
4102     }
4103 
4104     // Handle mixing oops and interfaces first.
4105     if( this_klass-&gt;is_interface() &amp;&amp; !(tinst_klass-&gt;is_interface() ||
4106                                         tinst_klass == ciEnv::current()-&gt;Object_klass())) {
4107       ciKlass *tmp = tinst_klass; // Swap interface around
4108       tinst_klass = this_klass;
4109       this_klass = tmp;
4110       bool tmp2 = tinst_xk;
4111       tinst_xk = this_xk;
4112       this_xk = tmp2;
4113       tmp2 = tinst_flat_array;
4114       tinst_flat_array = this_flat_array;
4115       this_flat_array = tmp2;
4116     }
4117     if (tinst_klass-&gt;is_interface() &amp;&amp;
4118         !(this_klass-&gt;is_interface() ||
4119           // Treat java/lang/Object as an honorary interface,
4120           // because we need a bottom for the interface hierarchy.
4121           this_klass == ciEnv::current()-&gt;Object_klass())) {
4122       // Oop meets interface!
4123 
4124       // See if the oop subtypes (implements) interface.
4125       ciKlass *k;
4126       bool xk;
4127       bool flat_array;
4128       if( this_klass-&gt;is_subtype_of( tinst_klass ) ) {
4129         // Oop indeed subtypes.  Now keep oop or interface depending
4130         // on whether we are both above the centerline or either is
4131         // below the centerline.  If we are on the centerline
4132         // (e.g., Constant vs. AnyNull interface), use the constant.
4133         k  = below_centerline(ptr) ? tinst_klass : this_klass;
4134         // If we are keeping this_klass, keep its exactness too.
4135         xk = below_centerline(ptr) ? tinst_xk    : this_xk;
4136         flat_array = below_centerline(ptr) ? tinst_flat_array    : this_flat_array;
4137       } else {                  // Does not implement, fall to Object
4138         // Oop does not implement interface, so mixing falls to Object
4139         // just like the verifier does (if both are above the
4140         // centerline fall to interface)
4141         k = above_centerline(ptr) ? tinst_klass : ciEnv::current()-&gt;Object_klass();
4142         xk = above_centerline(ptr) ? tinst_xk : false;
4143         flat_array = above_centerline(ptr) ? tinst_flat_array : false;
4144         // Watch out for Constant vs. AnyNull interface.
4145         if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
4146         instance_id = InstanceBot;
4147       }
4148       ciObject* o = NULL;  // the Constant value, if any
4149       if (ptr == Constant) {
4150         // Find out which constant.
4151         o = (this_klass == klass()) ? const_oop() : tinst-&gt;const_oop();
4152       }
4153       return make(ptr, k, xk, o, off, flat_array, instance_id, speculative, depth);
4154     }
4155 
4156     // Either oop vs oop or interface vs interface or interface vs Object
4157 
4158     // !!! Here&#39;s how the symmetry requirement breaks down into invariants:
4159     // If we split one up &amp; one down AND they subtype, take the down man.
4160     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
4161     // If both are up and they subtype, take the subtype class.
4162     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
4163     // If both are down and they subtype, take the supertype class.
4164     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
4165     // Constants treated as down.
4166 
4167     // Now, reorder the above list; observe that both-down+subtype is also
4168     // &quot;fall hard&quot;; &quot;fall hard&quot; becomes the default case:
4169     // If we split one up &amp; one down AND they subtype, take the down man.
4170     // If both are up and they subtype, take the subtype class.
4171 
4172     // If both are down and they subtype, &quot;fall hard&quot;.
4173     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
4174     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
4175     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
4176 
4177     // If a proper subtype is exact, and we return it, we return it exactly.
4178     // If a proper supertype is exact, there can be no subtyping relationship!
4179     // If both types are equal to the subtype, exactness is and-ed below the
4180     // centerline and or-ed above it.  (N.B. Constants are always exact.)
4181 
4182     // Check for subtyping:
4183     ciKlass *subtype = NULL;
4184     bool subtype_exact = false;
4185     bool flat_array = false;
4186     if (tinst_klass-&gt;equals(this_klass)) {
4187       subtype = this_klass;
4188       subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
4189       flat_array = below_centerline(ptr) ? (this_flat_array &amp;&amp; tinst_flat_array) : (this_flat_array || tinst_flat_array);
4190     } else if(!tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of(tinst_klass) &amp;&amp; (!tinst_flat_array || this_flat_array)) {
4191       subtype = this_klass;     // Pick subtyping class
4192       subtype_exact = this_xk;
4193       flat_array = this_flat_array;
4194     } else if(!this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of(this_klass) &amp;&amp; (!this_flat_array || tinst_flat_array)) {
4195       subtype = tinst_klass;    // Pick subtyping class
4196       subtype_exact = tinst_xk;
4197       flat_array = tinst_flat_array;
4198     }
4199 
4200     if (subtype) {
4201       if (above_centerline(ptr)) { // both are up?
4202         this_klass = tinst_klass = subtype;
4203         this_xk = tinst_xk = subtype_exact;
4204         this_flat_array = tinst_flat_array = flat_array;
4205       } else if (above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr)) {
4206         this_klass = tinst_klass; // tinst is down; keep down man
4207         this_xk = tinst_xk;
4208         this_flat_array = tinst_flat_array;
4209       } else if (above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr)) {
4210         tinst_klass = this_klass; // this is down; keep down man
4211         tinst_xk = this_xk;
4212         tinst_flat_array = this_flat_array;
4213       } else {
4214         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
4215         this_flat_array = flat_array;
4216       }
4217     }
4218 
4219     // Check for classes now being equal
4220     if (tinst_klass-&gt;equals(this_klass)) {
4221       // If the klasses are equal, the constants may still differ.  Fall to
4222       // NotNull if they do (neither constant is NULL; that is a special case
4223       // handled elsewhere).
4224       ciObject* o = NULL;             // Assume not constant when done
4225       ciObject* this_oop  = const_oop();
4226       ciObject* tinst_oop = tinst-&gt;const_oop();
4227       if( ptr == Constant ) {
4228         if (this_oop != NULL &amp;&amp; tinst_oop != NULL &amp;&amp;
4229             this_oop-&gt;equals(tinst_oop) )
4230           o = this_oop;
4231         else if (above_centerline(this -&gt;_ptr))
4232           o = tinst_oop;
4233         else if (above_centerline(tinst -&gt;_ptr))
4234           o = this_oop;
4235         else
4236           ptr = NotNull;
4237       }
4238       return make(ptr, this_klass, this_xk, o, off, this_flat_array, instance_id, speculative, depth);
4239     } // Else classes are not equal
4240 
4241     // Since klasses are different, we require a LCA in the Java
4242     // class hierarchy - which means we have to fall to at least NotNull.
4243     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
4244       ptr = NotNull;
4245 
4246     instance_id = InstanceBot;
4247 
4248     // Now we find the LCA of Java classes
4249     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
4250     return make(ptr, k, false, NULL, off, false, instance_id, speculative, depth);
4251   } // End of case InstPtr
4252 
4253   case ValueType: {
4254     const TypeValueType* tv = t-&gt;is_valuetype();
4255     if (above_centerline(ptr())) {
4256       if (tv-&gt;value_klass()-&gt;is_subtype_of(_klass)) {
4257         return t;
4258       } else {
4259         return TypeInstPtr::NOTNULL;
4260       }
4261     } else {
4262       PTR ptr = this-&gt;_ptr;
4263       if (ptr == Constant) {
4264         ptr = NotNull;
4265       }
4266       if (tv-&gt;value_klass()-&gt;is_subtype_of(_klass)) {
4267         return TypeInstPtr::make(ptr, _klass);
4268       } else {
4269         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());
4270       }
4271     }
4272   }
4273 
4274   } // End of switch
4275   return this;                  // Return the double constant
4276 }
4277 
4278 
4279 //------------------------java_mirror_type--------------------------------------
4280 ciType* TypeInstPtr::java_mirror_type() const {
4281   // must be a singleton type
4282   if( const_oop() == NULL )  return NULL;
4283 
4284   // must be of type java.lang.Class
4285   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;
4286   return const_oop()-&gt;as_instance()-&gt;java_mirror_type();
4287 }
4288 
4289 
4290 //------------------------------xdual------------------------------------------
4291 // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
4292 // inheritance mechanism.
4293 const Type *TypeInstPtr::xdual() const {
4294   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), flat_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());
4295 }
4296 
4297 //------------------------------eq---------------------------------------------
4298 // Structural equality check for Type representations
4299 bool TypeInstPtr::eq( const Type *t ) const {
4300   const TypeInstPtr *p = t-&gt;is_instptr();
4301   return
4302     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
4303     flat_array() == p-&gt;flat_array() &amp;&amp;
4304     TypeOopPtr::eq(p);          // Check sub-type stuff
4305 }
4306 
4307 //------------------------------hash-------------------------------------------
4308 // Type-specific hashing function.
4309 int TypeInstPtr::hash(void) const {
4310   int hash = java_add(java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash()), (jint)flat_array());
4311   return hash;
4312 }
4313 
4314 //------------------------------dump2------------------------------------------
4315 // Dump oop Type
4316 #ifndef PRODUCT
4317 void TypeInstPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4318   // Print the name of the klass.
4319   klass()-&gt;print_name_on(st);
4320 
4321   switch( _ptr ) {
4322   case Constant:
4323     // TO DO: Make CI print the hex address of the underlying oop.
4324     if (WizardMode || Verbose) {
4325       const_oop()-&gt;print_oop(st);
4326     }
4327   case BotPTR:
4328     if (!WizardMode &amp;&amp; !Verbose) {
4329       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4330       break;
4331     }
4332   case TopPTR:
4333   case AnyNull:
4334   case NotNull:
4335     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4336     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4337     break;
4338   default:
4339     break;
4340   }
4341 
4342   _offset.dump2(st);
4343 
4344   st-&gt;print(&quot; *&quot;);
4345 
4346   if (flat_array() &amp;&amp; !klass()-&gt;is_valuetype()) {
4347     st-&gt;print(&quot; (flatten array)&quot;);
4348   }
4349 
4350   if (_instance_id == InstanceTop)
4351     st-&gt;print(&quot;,iid=top&quot;);
4352   else if (_instance_id != InstanceBot)
4353     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4354 
4355   dump_inline_depth(st);
4356   dump_speculative(st);
4357 }
4358 #endif
4359 
4360 //------------------------------add_offset-------------------------------------
4361 const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
4362   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset), flat_array(),
4363               _instance_id, add_offset_speculative(offset), _inline_depth);
4364 }
4365 
4366 const Type *TypeInstPtr::remove_speculative() const {
4367   if (_speculative == NULL) {
4368     return this;
4369   }
4370   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
4371   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(),
4372               _instance_id, NULL, _inline_depth);
4373 }
4374 
4375 const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
4376   if (!UseInlineDepthForSpeculativeTypes) {
4377     return this;
4378   }
4379   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), _instance_id, _speculative, depth);
4380 }
4381 
4382 const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
4383   assert(is_known_instance(), &quot;should be known&quot;);
4384   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), instance_id, _speculative, _inline_depth);
4385 }
4386 
4387 const TypeInstPtr *TypeInstPtr::cast_to_flat_array() const {
4388   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, true, _instance_id, _speculative, _inline_depth);
4389 }
4390 
4391 
4392 //=============================================================================
4393 // Convenience common pre-built types.
4394 const TypeAryPtr *TypeAryPtr::RANGE;
4395 const TypeAryPtr *TypeAryPtr::OOPS;
4396 const TypeAryPtr *TypeAryPtr::NARROWOOPS;
4397 const TypeAryPtr *TypeAryPtr::BYTES;
4398 const TypeAryPtr *TypeAryPtr::SHORTS;
4399 const TypeAryPtr *TypeAryPtr::CHARS;
4400 const TypeAryPtr *TypeAryPtr::INTS;
4401 const TypeAryPtr *TypeAryPtr::LONGS;
4402 const TypeAryPtr *TypeAryPtr::FLOATS;
4403 const TypeAryPtr *TypeAryPtr::DOUBLES;
4404 const TypeAryPtr *TypeAryPtr::VALUES;
4405 
4406 //------------------------------make-------------------------------------------
4407 const TypeAryPtr* TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,
4408                                    int instance_id, const TypePtr* speculative, int inline_depth) {
4409   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4410          &quot;integral arrays must be pre-equipped with a class&quot;);
4411   if (!xk) xk = ary-&gt;ary_must_be_exact();
4412   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4413   if (!UseExactTypes)  xk = (ptr == Constant);
4414   return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, field_offset, instance_id, false, speculative, inline_depth))-&gt;hashcons();
4415 }
4416 
4417 //------------------------------make-------------------------------------------
4418 const TypeAryPtr* TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,
4419                                    int instance_id, const TypePtr* speculative, int inline_depth,
4420                                    bool is_autobox_cache) {
4421   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4422          &quot;integral arrays must be pre-equipped with a class&quot;);
4423   assert( (ptr==Constant &amp;&amp; o) || (ptr!=Constant &amp;&amp; !o), &quot;&quot; );
4424   if (!xk)  xk = (o != NULL) || ary-&gt;ary_must_be_exact();
4425   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4426   if (!UseExactTypes)  xk = (ptr == Constant);
4427   return (TypeAryPtr*)(new TypeAryPtr(ptr, o, ary, k, xk, offset, field_offset, instance_id, is_autobox_cache, speculative, inline_depth))-&gt;hashcons();
4428 }
4429 
4430 //------------------------------cast_to_ptr_type-------------------------------
4431 const Type *TypeAryPtr::cast_to_ptr_type(PTR ptr) const {
4432   if( ptr == _ptr ) return this;
4433   return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4434 }
4435 
4436 
4437 //-----------------------------cast_to_exactness-------------------------------
4438 const Type *TypeAryPtr::cast_to_exactness(bool klass_is_exact) const {
4439   if( klass_is_exact == _klass_is_exact ) return this;
4440   if (!UseExactTypes)  return this;
4441   if (_ary-&gt;ary_must_be_exact())  return this;  // cannot clear xk
4442 
4443   const TypeAry* new_ary = _ary;
4444   if (klass() != NULL &amp;&amp; klass()-&gt;is_obj_array_klass() &amp;&amp; klass_is_exact) {
4445     // An object array can&#39;t be flat or null-free if the klass is exact
4446     new_ary = TypeAry::make(elem(), size(), is_stable(), /* not_flat= */ true, /* not_null_free= */ true);
4447   }
4448   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact, _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4449 }
4450 
4451 //-----------------------------cast_to_instance_id----------------------------
4452 const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {
4453   if( instance_id == _instance_id ) return this;
4454   return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, _field_offset, instance_id, _speculative, _inline_depth, _is_autobox_cache);
4455 }
4456 
4457 
4458 //-----------------------------max_array_length-------------------------------
4459 // A wrapper around arrayOopDesc::max_array_length(etype) with some input normalization.
4460 jint TypeAryPtr::max_array_length(BasicType etype) {
4461   if (!is_java_primitive(etype) &amp;&amp; !is_reference_type(etype)) {
4462     if (etype == T_NARROWOOP) {
4463       etype = T_OBJECT;
4464     } else if (etype == T_ILLEGAL) { // bottom[]
4465       etype = T_BYTE; // will produce conservatively high value
4466     } else {
4467       fatal(&quot;not an element type: %s&quot;, type2name(etype));
4468     }
4469   }
4470   return arrayOopDesc::max_array_length(etype);
4471 }
4472 
4473 //-----------------------------narrow_size_type-------------------------------
4474 // Narrow the given size type to the index range for the given array base type.
4475 // Return NULL if the resulting int type becomes empty.
4476 const TypeInt* TypeAryPtr::narrow_size_type(const TypeInt* size) const {
4477   jint hi = size-&gt;_hi;
4478   jint lo = size-&gt;_lo;
4479   jint min_lo = 0;
4480   jint max_hi = max_array_length(elem()-&gt;basic_type());
4481   //if (index_not_size)  --max_hi;     // type of a valid array index, FTR
4482   bool chg = false;
4483   if (lo &lt; min_lo) {
4484     lo = min_lo;
4485     if (size-&gt;is_con()) {
4486       hi = lo;
4487     }
4488     chg = true;
4489   }
4490   if (hi &gt; max_hi) {
4491     hi = max_hi;
4492     if (size-&gt;is_con()) {
4493       lo = hi;
4494     }
4495     chg = true;
4496   }
4497   // Negative length arrays will produce weird intermediate dead fast-path code
4498   if (lo &gt; hi)
4499     return TypeInt::ZERO;
4500   if (!chg)
4501     return size;
4502   return TypeInt::make(lo, hi, Type::WidenMin);
4503 }
4504 
4505 //-------------------------------cast_to_size----------------------------------
4506 const TypeAryPtr* TypeAryPtr::cast_to_size(const TypeInt* new_size) const {
4507   assert(new_size != NULL, &quot;&quot;);
4508   new_size = narrow_size_type(new_size);
4509   if (new_size == size())  return this;
4510   const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable(), is_not_flat(), is_not_null_free());
4511   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4512 }
4513 
4514 //-------------------------------cast_to_not_flat------------------------------
4515 const TypeAryPtr* TypeAryPtr::cast_to_not_flat(bool not_flat) const {
4516   if (not_flat == is_not_flat()) {
4517     return this;
4518   }
4519   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_flat, is_not_null_free());
4520   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4521 }
4522 
4523 //-------------------------------cast_to_not_null_free-------------------------
4524 const TypeAryPtr* TypeAryPtr::cast_to_not_null_free(bool not_null_free) const {
4525   if (not_null_free == is_not_null_free()) {
4526     return this;
4527   }
4528   // Not null free implies not flat
4529   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_null_free ? true : is_not_flat(), not_null_free);
4530   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4531 }
4532 
4533 //------------------------------cast_to_stable---------------------------------
4534 const TypeAryPtr* TypeAryPtr::cast_to_stable(bool stable, int stable_dimension) const {
4535   if (stable_dimension &lt;= 0 || (stable_dimension == 1 &amp;&amp; stable == this-&gt;is_stable()))
4536     return this;
4537 
4538   const Type* elem = this-&gt;elem();
4539   const TypePtr* elem_ptr = elem-&gt;make_ptr();
4540 
4541   if (stable_dimension &gt; 1 &amp;&amp; elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr()) {
4542     // If this is widened from a narrow oop, TypeAry::make will re-narrow it.
4543     elem = elem_ptr = elem_ptr-&gt;is_aryptr()-&gt;cast_to_stable(stable, stable_dimension - 1);
4544   }
4545 
4546   const TypeAry* new_ary = TypeAry::make(elem, size(), stable, is_not_flat(), is_not_null_free());
4547 
4548   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4549 }
4550 
4551 //-----------------------------stable_dimension--------------------------------
4552 int TypeAryPtr::stable_dimension() const {
4553   if (!is_stable())  return 0;
4554   int dim = 1;
4555   const TypePtr* elem_ptr = elem()-&gt;make_ptr();
4556   if (elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr())
4557     dim += elem_ptr-&gt;is_aryptr()-&gt;stable_dimension();
4558   return dim;
4559 }
4560 
4561 //----------------------cast_to_autobox_cache-----------------------------------
4562 const TypeAryPtr* TypeAryPtr::cast_to_autobox_cache(bool cache) const {
4563   if (is_autobox_cache() == cache)  return this;
4564   const TypeOopPtr* etype = elem()-&gt;make_oopptr();
4565   if (etype == NULL)  return this;
4566   // The pointers in the autobox arrays are always non-null.
4567   TypePtr::PTR ptr_type = cache ? TypePtr::NotNull : TypePtr::AnyNull;
4568   etype = etype-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
4569   const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable(), is_not_flat(), is_not_null_free());
4570   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, cache);
4571 }
4572 
4573 //------------------------------eq---------------------------------------------
4574 // Structural equality check for Type representations
4575 bool TypeAryPtr::eq( const Type *t ) const {
4576   const TypeAryPtr *p = t-&gt;is_aryptr();
4577   return
4578     _ary == p-&gt;_ary &amp;&amp;  // Check array
4579     TypeOopPtr::eq(p) &amp;&amp;// Check sub-parts
4580     _field_offset == p-&gt;_field_offset;
4581 }
4582 
4583 //------------------------------hash-------------------------------------------
4584 // Type-specific hashing function.
4585 int TypeAryPtr::hash(void) const {
4586   return (intptr_t)_ary + TypeOopPtr::hash() + _field_offset.get();
4587 }
4588 
4589 //------------------------------meet-------------------------------------------
4590 // Compute the MEET of two types.  It returns a new Type object.
4591 const Type *TypeAryPtr::xmeet_helper(const Type *t) const {
4592   // Perform a fast test for common case; meeting the same types together.
4593   if( this == t ) return this;  // Meeting same type-rep?
4594   // Current &quot;this-&gt;_base&quot; is Pointer
4595   switch (t-&gt;base()) {          // switch on original type
4596 
4597   // Mixing ints &amp; oops happens when javac reuses local variables
4598   case Int:
4599   case Long:
4600   case FloatTop:
4601   case FloatCon:
4602   case FloatBot:
4603   case DoubleTop:
4604   case DoubleCon:
4605   case DoubleBot:
4606   case NarrowOop:
4607   case NarrowKlass:
4608   case Bottom:                  // Ye Olde Default
4609     return Type::BOTTOM;
4610   case Top:
4611     return this;
4612 
4613   default:                      // All else is a mistake
4614     typerr(t);
4615 
4616   case OopPtr: {                // Meeting to OopPtrs
4617     // Found a OopPtr type vs self-AryPtr type
4618     const TypeOopPtr *tp = t-&gt;is_oopptr();
4619     Offset offset = meet_offset(tp-&gt;offset());
4620     PTR ptr = meet_ptr(tp-&gt;ptr());
4621     int depth = meet_inline_depth(tp-&gt;inline_depth());
4622     const TypePtr* speculative = xmeet_speculative(tp);
4623     switch (tp-&gt;ptr()) {
4624     case TopPTR:
4625     case AnyNull: {
4626       int instance_id = meet_instance_id(InstanceTop);
4627       return make(ptr, (ptr == Constant ? const_oop() : NULL),
4628                   _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4629     }
4630     case BotPTR:
4631     case NotNull: {
4632       int instance_id = meet_instance_id(tp-&gt;instance_id());
4633       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4634     }
4635     default: ShouldNotReachHere();
4636     }
4637   }
4638 
4639   case AnyPtr: {                // Meeting two AnyPtrs
4640     // Found an AnyPtr type vs self-AryPtr type
4641     const TypePtr *tp = t-&gt;is_ptr();
4642     Offset offset = meet_offset(tp-&gt;offset());
4643     PTR ptr = meet_ptr(tp-&gt;ptr());
4644     const TypePtr* speculative = xmeet_speculative(tp);
4645     int depth = meet_inline_depth(tp-&gt;inline_depth());
4646     switch (tp-&gt;ptr()) {
4647     case TopPTR:
4648       return this;
4649     case BotPTR:
4650     case NotNull:
4651       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4652     case Null:
4653       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4654       // else fall through to AnyNull
4655     case AnyNull: {
4656       int instance_id = meet_instance_id(InstanceTop);
4657       return make(ptr, (ptr == Constant ? const_oop() : NULL),
4658                   _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4659     }
4660     default: ShouldNotReachHere();
4661     }
4662   }
4663 
4664   case MetadataPtr:
4665   case KlassPtr:
4666   case RawPtr: return TypePtr::BOTTOM;
4667 
4668   case AryPtr: {                // Meeting 2 references?
4669     const TypeAryPtr *tap = t-&gt;is_aryptr();
4670     Offset off = meet_offset(tap-&gt;offset());
4671     Offset field_off = meet_field_offset(tap-&gt;field_offset());
4672     const TypeAry *tary = _ary-&gt;meet_speculative(tap-&gt;_ary)-&gt;is_ary();
4673     PTR ptr = meet_ptr(tap-&gt;ptr());
4674     int instance_id = meet_instance_id(tap-&gt;instance_id());
4675     const TypePtr* speculative = xmeet_speculative(tap);
4676     int depth = meet_inline_depth(tap-&gt;inline_depth());
4677     ciKlass* lazy_klass = NULL;
4678     if (tary-&gt;_elem-&gt;isa_int()) {
4679       // Integral array element types have irrelevant lattice relations.
4680       // It is the klass that determines array layout, not the element type.
4681       if (_klass == NULL)
4682         lazy_klass = tap-&gt;_klass;
4683       else if (tap-&gt;_klass == NULL || tap-&gt;_klass == _klass) {
4684         lazy_klass = _klass;
4685       } else {
4686         // Something like byte[int+] meets char[int+].
4687         // This must fall to bottom, not (int[-128..65535])[int+].
4688         instance_id = InstanceBot;
4689         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4690       }
4691     } else // Non integral arrays.
4692       // Must fall to bottom if exact klasses in upper lattice
4693       // are not equal or super klass is exact.
4694       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4695           // meet with top[] and bottom[] are processed further down:
4696           tap-&gt;_klass != NULL &amp;&amp; this-&gt;_klass != NULL &amp;&amp;
4697           // both are exact and not equal:
4698           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4699            // &#39;tap&#39; is exact and super or unrelated:
4700            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4701            // &#39;this&#39; is exact and super or unrelated:
4702            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4703       if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
4704         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4705       }
4706       return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);
4707     } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp; klass()-&gt;is_value_array_klass() != tap-&gt;klass()-&gt;is_value_array_klass()) {
4708       // Meeting flattened value type array with non-flattened array. Adjust (field) offset accordingly.
4709       if (tary-&gt;_elem-&gt;isa_valuetype()) {
4710         // Result is flattened
4711         off = Offset(elem()-&gt;isa_valuetype() ? offset() : tap-&gt;offset());
4712         field_off = elem()-&gt;isa_valuetype() ? field_offset() : tap-&gt;field_offset();
4713       } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {
4714         // Result is non-flattened
4715         off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));
4716         field_off = Offset::bottom;
4717       }
4718     }
4719 
4720     bool xk = false;
4721     switch (tap-&gt;ptr()) {
4722     case AnyNull:
4723     case TopPTR:
4724       // Compute new klass on demand, do not use tap-&gt;_klass
4725       if (below_centerline(this-&gt;_ptr)) {
4726         xk = this-&gt;_klass_is_exact;
4727       } else {
4728         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4729       }
4730       return make(ptr, const_oop(), tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4731     case Constant: {
4732       ciObject* o = const_oop();
4733       if( _ptr == Constant ) {
4734         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
4735           xk = (klass() == tap-&gt;klass());
4736           ptr = NotNull;
4737           o = NULL;
4738           instance_id = InstanceBot;
4739         } else {
4740           xk = true;
4741         }
4742       } else if(above_centerline(_ptr)) {
4743         o = tap-&gt;const_oop();
4744         xk = true;
4745       } else {
4746         // Only precise for identical arrays
4747         xk = this-&gt;_klass_is_exact &amp;&amp; (klass() == tap-&gt;klass());
4748       }
4749       return TypeAryPtr::make(ptr, o, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4750     }
4751     case NotNull:
4752     case BotPTR:
4753       // Compute new klass on demand, do not use tap-&gt;_klass
4754       if (above_centerline(this-&gt;_ptr))
4755             xk = tap-&gt;_klass_is_exact;
4756       else  xk = (tap-&gt;_klass_is_exact &amp; this-&gt;_klass_is_exact) &amp;&amp;
4757               (klass() == tap-&gt;klass()); // Only precise for identical arrays
4758       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4759     default: ShouldNotReachHere();
4760     }
4761   }
4762 
4763   // All arrays inherit from Object class
4764   case InstPtr: {
4765     const TypeInstPtr *tp = t-&gt;is_instptr();
4766     Offset offset = meet_offset(tp-&gt;offset());
4767     PTR ptr = meet_ptr(tp-&gt;ptr());
4768     int instance_id = meet_instance_id(tp-&gt;instance_id());
4769     const TypePtr* speculative = xmeet_speculative(tp);
4770     int depth = meet_inline_depth(tp-&gt;inline_depth());
4771     switch (ptr) {
4772     case TopPTR:
4773     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
4774       // For instances when a subclass meets a superclass we fall
4775       // below the centerline when the superclass is exact. We need to
4776       // do the same here.
4777       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flat_array()) {
4778         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4779       } else {
4780         // cannot subclass, so the meet has to fall badly below the centerline
4781         ptr = NotNull;
4782         instance_id = InstanceBot;
4783         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4784       }
4785     case Constant:
4786     case NotNull:
4787     case BotPTR:                // Fall down to object klass
4788       // LCA is object_klass, but if we subclass from the top we can do better
4789       if (above_centerline(tp-&gt;ptr())) {
4790         // If &#39;tp&#39;  is above the centerline and it is Object class
4791         // then we can subclass in the Java class hierarchy.
4792         // For instances when a subclass meets a superclass we fall
4793         // below the centerline when the superclass is exact. We need
4794         // to do the same here.
4795         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flat_array()) {
4796           // that is, my array type is a subtype of &#39;tp&#39; klass
4797           return make(ptr, (ptr == Constant ? const_oop() : NULL),
4798                       _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4799         }
4800       }
4801       // The other case cannot happen, since t cannot be a subtype of an array.
4802       // The meet falls down to Object class below centerline.
4803       if( ptr == Constant )
4804          ptr = NotNull;
4805       instance_id = InstanceBot;
4806       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4807     default: typerr(t);
4808     }
4809   }
4810 
4811   case ValueType: {
4812     const TypeValueType* tv = t-&gt;is_valuetype();
4813     if (above_centerline(ptr())) {
4814       return TypeInstPtr::NOTNULL;
4815     } else {
4816       PTR ptr = this-&gt;_ptr;
4817       if (ptr == Constant) {
4818         ptr = NotNull;
4819       }
4820       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());
4821     }
4822   }
4823   }
4824   return this;                  // Lint noise
4825 }
4826 
4827 //------------------------------xdual------------------------------------------
4828 // Dual: compute field-by-field dual
4829 const Type *TypeAryPtr::xdual() const {
4830   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(), _klass, _klass_is_exact, dual_offset(), dual_field_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());
4831 }
4832 
4833 Type::Offset TypeAryPtr::meet_field_offset(const Type::Offset offset) const {
4834   return _field_offset.meet(offset);
4835 }
4836 
4837 //------------------------------dual_offset------------------------------------
4838 Type::Offset TypeAryPtr::dual_field_offset() const {
4839   return _field_offset.dual();
4840 }
4841 
4842 //----------------------interface_vs_oop---------------------------------------
4843 #ifdef ASSERT
4844 bool TypeAryPtr::interface_vs_oop(const Type *t) const {
4845   const TypeAryPtr* t_aryptr = t-&gt;isa_aryptr();
4846   if (t_aryptr) {
4847     return _ary-&gt;interface_vs_oop(t_aryptr-&gt;_ary);
4848   }
4849   return false;
4850 }
4851 #endif
4852 
4853 //------------------------------dump2------------------------------------------
4854 #ifndef PRODUCT
4855 void TypeAryPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4856   _ary-&gt;dump2(d,depth,st);
4857   switch( _ptr ) {
4858   case Constant:
4859     const_oop()-&gt;print(st);
4860     break;
4861   case BotPTR:
4862     if (!WizardMode &amp;&amp; !Verbose) {
4863       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4864       break;
4865     }
4866   case TopPTR:
4867   case AnyNull:
4868   case NotNull:
4869     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4870     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4871     break;
4872   default:
4873     break;
4874   }
4875 
4876   if (elem()-&gt;isa_valuetype()) {
4877     st-&gt;print(&quot;(&quot;);
4878     _field_offset.dump2(st);
4879     st-&gt;print(&quot;)&quot;);
4880   }
4881   if (offset() != 0) {
4882     int header_size = objArrayOopDesc::header_size() * wordSize;
4883     if( _offset == Offset::top )       st-&gt;print(&quot;+undefined&quot;);
4884     else if( _offset == Offset::bottom )  st-&gt;print(&quot;+any&quot;);
4885     else if( offset() &lt; header_size ) st-&gt;print(&quot;+%d&quot;, offset());
4886     else {
4887       BasicType basic_elem_type = elem()-&gt;basic_type();
4888       int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
4889       int elem_size = type2aelembytes(basic_elem_type);
4890       st-&gt;print(&quot;[%d]&quot;, (offset() - array_base)/elem_size);
4891     }
4892   }
4893   st-&gt;print(&quot; *&quot;);
4894   if (_instance_id == InstanceTop)
4895     st-&gt;print(&quot;,iid=top&quot;);
4896   else if (_instance_id != InstanceBot)
4897     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4898 
4899   dump_inline_depth(st);
4900   dump_speculative(st);
4901 }
4902 #endif
4903 
4904 bool TypeAryPtr::empty(void) const {
4905   if (_ary-&gt;empty())       return true;
4906   return TypeOopPtr::empty();
4907 }
4908 
4909 //------------------------------add_offset-------------------------------------
4910 const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {
4911   return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, xadd_offset(offset), _field_offset, _instance_id, add_offset_speculative(offset), _inline_depth, _is_autobox_cache);
4912 }
4913 
4914 const Type *TypeAryPtr::remove_speculative() const {
4915   if (_speculative == NULL) {
4916     return this;
4917   }
4918   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
4919   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, NULL, _inline_depth, _is_autobox_cache);
4920 }
4921 
4922 const Type* TypeAryPtr::cleanup_speculative() const {
4923   if (speculative() == NULL) {
4924     return this;
4925   }
4926   // Keep speculative part if it contains information about flat-/nullability
4927   const TypeAryPtr* spec_aryptr = speculative()-&gt;isa_aryptr();
4928   if (spec_aryptr != NULL &amp;&amp; (spec_aryptr-&gt;is_not_flat() || spec_aryptr-&gt;is_not_null_free())) {
4929     return this;
4930   }
4931   return TypeOopPtr::cleanup_speculative();
4932 }
4933 
4934 const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {
4935   if (!UseInlineDepthForSpeculativeTypes) {
4936     return this;
4937   }
4938   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, _speculative, depth, _is_autobox_cache);
4939 }
4940 
4941 const TypeAryPtr* TypeAryPtr::with_field_offset(int offset) const {
4942   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, Offset(offset), _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4943 }
4944 
4945 const TypePtr* TypeAryPtr::add_field_offset_and_offset(intptr_t offset) const {
4946   int adj = 0;
4947   if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop) {
4948     const Type* elemtype = elem();
4949     if (elemtype-&gt;isa_valuetype()) {
4950       if (_offset.get() != OffsetBot &amp;&amp; _offset.get() != OffsetTop) {
4951         adj = _offset.get();
4952         offset += _offset.get();
4953       }
4954       uint header = arrayOopDesc::base_offset_in_bytes(T_OBJECT);
4955       if (_field_offset.get() != OffsetBot &amp;&amp; _field_offset.get() != OffsetTop) {
4956         offset += _field_offset.get();
4957         if (_offset.get() == OffsetBot || _offset.get() == OffsetTop) {
4958           offset += header;
4959         }
4960       }
4961       if (offset &gt;= (intptr_t)header || offset &lt; 0) {
4962         // Try to get the field of the value type array element we are pointing to
4963         ciKlass* arytype_klass = klass();
4964         ciValueArrayKlass* vak = arytype_klass-&gt;as_value_array_klass();
4965         ciValueKlass* vk = vak-&gt;element_klass()-&gt;as_value_klass();
4966         int shift = vak-&gt;log2_element_size();
4967         int mask = (1 &lt;&lt; shift) - 1;
4968         intptr_t field_offset = ((offset - header) &amp; mask);
4969         ciField* field = vk-&gt;get_field_by_offset(field_offset + vk-&gt;first_field_offset(), false);
4970         if (field == NULL) {
4971           // This may happen with nested AddP(base, AddP(base, base, offset), longcon(16))
4972           return add_offset(offset);
4973         } else {
4974           return with_field_offset(field_offset)-&gt;add_offset(offset - field_offset - adj);
4975         }
4976       }
4977     }
4978   }
4979   return add_offset(offset - adj);
4980 }
4981 
4982 // Return offset incremented by field_offset for flattened value type arrays
4983 const int TypeAryPtr::flattened_offset() const {
4984   int offset = _offset.get();
4985   if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop &amp;&amp;
4986       _field_offset != Offset::bottom &amp;&amp; _field_offset != Offset::top) {
4987     offset += _field_offset.get();
4988   }
4989   return offset;
4990 }
4991 
4992 const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {
4993   assert(is_known_instance(), &quot;should be known&quot;);
4994   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, instance_id, _speculative, _inline_depth);
4995 }
4996 
4997 //=============================================================================
4998 
4999 
5000 //------------------------------hash-------------------------------------------
5001 // Type-specific hashing function.
5002 int TypeNarrowPtr::hash(void) const {
5003   return _ptrtype-&gt;hash() + 7;
5004 }
5005 
5006 bool TypeNarrowPtr::singleton(void) const {    // TRUE if type is a singleton
5007   return _ptrtype-&gt;singleton();
5008 }
5009 
5010 bool TypeNarrowPtr::empty(void) const {
5011   return _ptrtype-&gt;empty();
5012 }
5013 
5014 intptr_t TypeNarrowPtr::get_con() const {
5015   return _ptrtype-&gt;get_con();
5016 }
5017 
5018 bool TypeNarrowPtr::eq( const Type *t ) const {
5019   const TypeNarrowPtr* tc = isa_same_narrowptr(t);
5020   if (tc != NULL) {
5021     if (_ptrtype-&gt;base() != tc-&gt;_ptrtype-&gt;base()) {
5022       return false;
5023     }
5024     return tc-&gt;_ptrtype-&gt;eq(_ptrtype);
5025   }
5026   return false;
5027 }
5028 
5029 const Type *TypeNarrowPtr::xdual() const {    // Compute dual right now.
5030   const TypePtr* odual = _ptrtype-&gt;dual()-&gt;is_ptr();
5031   return make_same_narrowptr(odual);
5032 }
5033 
5034 
5035 const Type *TypeNarrowPtr::filter_helper(const Type *kills, bool include_speculative) const {
5036   if (isa_same_narrowptr(kills)) {
5037     const Type* ft =_ptrtype-&gt;filter_helper(is_same_narrowptr(kills)-&gt;_ptrtype, include_speculative);
5038     if (ft-&gt;empty())
5039       return Type::TOP;           // Canonical empty value
5040     if (ft-&gt;isa_ptr()) {
5041       return make_hash_same_narrowptr(ft-&gt;isa_ptr());
5042     }
5043     return ft;
5044   } else if (kills-&gt;isa_ptr()) {
5045     const Type* ft = _ptrtype-&gt;join_helper(kills, include_speculative);
5046     if (ft-&gt;empty())
5047       return Type::TOP;           // Canonical empty value
5048     return ft;
5049   } else {
5050     return Type::TOP;
5051   }
5052 }
5053 
5054 //------------------------------xmeet------------------------------------------
5055 // Compute the MEET of two types.  It returns a new Type object.
5056 const Type *TypeNarrowPtr::xmeet( const Type *t ) const {
5057   // Perform a fast test for common case; meeting the same types together.
5058   if( this == t ) return this;  // Meeting same type-rep?
5059 
5060   if (t-&gt;base() == base()) {
5061     const Type* result = _ptrtype-&gt;xmeet(t-&gt;make_ptr());
5062     if (result-&gt;isa_ptr()) {
5063       return make_hash_same_narrowptr(result-&gt;is_ptr());
5064     }
5065     return result;
5066   }
5067 
5068   // Current &quot;this-&gt;_base&quot; is NarrowKlass or NarrowOop
5069   switch (t-&gt;base()) {          // switch on original type
5070 
5071   case Int:                     // Mixing ints &amp; oops happens when javac
5072   case Long:                    // reuses local variables
5073   case FloatTop:
5074   case FloatCon:
5075   case FloatBot:
5076   case DoubleTop:
5077   case DoubleCon:
5078   case DoubleBot:
5079   case AnyPtr:
5080   case RawPtr:
5081   case OopPtr:
5082   case InstPtr:
5083   case AryPtr:
5084   case MetadataPtr:
5085   case KlassPtr:
5086   case NarrowOop:
5087   case NarrowKlass:
5088   case Bottom:                  // Ye Olde Default
5089     return Type::BOTTOM;
5090   case Top:
5091     return this;
5092 
5093   case ValueType:
5094     return t-&gt;xmeet(this);
5095 
5096   default:                      // All else is a mistake
5097     typerr(t);
5098 
5099   } // End of switch
5100 
5101   return this;
5102 }
5103 
5104 #ifndef PRODUCT
5105 void TypeNarrowPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5106   _ptrtype-&gt;dump2(d, depth, st);
5107 }
5108 #endif
5109 
5110 const TypeNarrowOop *TypeNarrowOop::BOTTOM;
5111 const TypeNarrowOop *TypeNarrowOop::NULL_PTR;
5112 
5113 
5114 const TypeNarrowOop* TypeNarrowOop::make(const TypePtr* type) {
5115   return (const TypeNarrowOop*)(new TypeNarrowOop(type))-&gt;hashcons();
5116 }
5117 
5118 const Type* TypeNarrowOop::remove_speculative() const {
5119   return make(_ptrtype-&gt;remove_speculative()-&gt;is_ptr());
5120 }
5121 
5122 const Type* TypeNarrowOop::cleanup_speculative() const {
5123   return make(_ptrtype-&gt;cleanup_speculative()-&gt;is_ptr());
5124 }
5125 
5126 #ifndef PRODUCT
5127 void TypeNarrowOop::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5128   st-&gt;print(&quot;narrowoop: &quot;);
5129   TypeNarrowPtr::dump2(d, depth, st);
5130 }
5131 #endif
5132 
5133 const TypeNarrowKlass *TypeNarrowKlass::NULL_PTR;
5134 
5135 const TypeNarrowKlass* TypeNarrowKlass::make(const TypePtr* type) {
5136   return (const TypeNarrowKlass*)(new TypeNarrowKlass(type))-&gt;hashcons();
5137 }
5138 
5139 #ifndef PRODUCT
5140 void TypeNarrowKlass::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5141   st-&gt;print(&quot;narrowklass: &quot;);
5142   TypeNarrowPtr::dump2(d, depth, st);
5143 }
5144 #endif
5145 
5146 
5147 //------------------------------eq---------------------------------------------
5148 // Structural equality check for Type representations
5149 bool TypeMetadataPtr::eq( const Type *t ) const {
5150   const TypeMetadataPtr *a = (const TypeMetadataPtr*)t;
5151   ciMetadata* one = metadata();
5152   ciMetadata* two = a-&gt;metadata();
5153   if (one == NULL || two == NULL) {
5154     return (one == two) &amp;&amp; TypePtr::eq(t);
5155   } else {
5156     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
5157   }
5158 }
5159 
5160 //------------------------------hash-------------------------------------------
5161 // Type-specific hashing function.
5162 int TypeMetadataPtr::hash(void) const {
5163   return
5164     (metadata() ? metadata()-&gt;hash() : 0) +
5165     TypePtr::hash();
5166 }
5167 
5168 //------------------------------singleton--------------------------------------
5169 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5170 // constants
5171 bool TypeMetadataPtr::singleton(void) const {
5172   // detune optimizer to not generate constant metadata + constant offset as a constant!
5173   // TopPTR, Null, AnyNull, Constant are all singletons
5174   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);
5175 }
5176 
5177 //------------------------------add_offset-------------------------------------
5178 const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {
5179   return make( _ptr, _metadata, xadd_offset(offset));
5180 }
5181 
5182 //-----------------------------filter------------------------------------------
5183 // Do not allow interface-vs.-noninterface joins to collapse to top.
5184 const Type *TypeMetadataPtr::filter_helper(const Type *kills, bool include_speculative) const {
5185   const TypeMetadataPtr* ft = join_helper(kills, include_speculative)-&gt;isa_metadataptr();
5186   if (ft == NULL || ft-&gt;empty())
5187     return Type::TOP;           // Canonical empty value
5188   return ft;
5189 }
5190 
5191  //------------------------------get_con----------------------------------------
5192 intptr_t TypeMetadataPtr::get_con() const {
5193   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
5194   assert(offset() &gt;= 0, &quot;&quot;);
5195 
5196   if (offset() != 0) {
5197     // After being ported to the compiler interface, the compiler no longer
5198     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5199     // to a handle at compile time.  This handle is embedded in the generated
5200     // code and dereferenced at the time the nmethod is made.  Until that time,
5201     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5202     // have access to the addresses!).  This does not seem to currently happen,
5203     // but this assertion here is to help prevent its occurence.
5204     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5205     ShouldNotReachHere();
5206   }
5207 
5208   return (intptr_t)metadata()-&gt;constant_encoding();
5209 }
5210 
5211 //------------------------------cast_to_ptr_type-------------------------------
5212 const Type *TypeMetadataPtr::cast_to_ptr_type(PTR ptr) const {
5213   if( ptr == _ptr ) return this;
5214   return make(ptr, metadata(), _offset);
5215 }
5216 
5217 //------------------------------meet-------------------------------------------
5218 // Compute the MEET of two types.  It returns a new Type object.
5219 const Type *TypeMetadataPtr::xmeet( const Type *t ) const {
5220   // Perform a fast test for common case; meeting the same types together.
5221   if( this == t ) return this;  // Meeting same type-rep?
5222 
5223   // Current &quot;this-&gt;_base&quot; is OopPtr
5224   switch (t-&gt;base()) {          // switch on original type
5225 
5226   case Int:                     // Mixing ints &amp; oops happens when javac
5227   case Long:                    // reuses local variables
5228   case FloatTop:
5229   case FloatCon:
5230   case FloatBot:
5231   case DoubleTop:
5232   case DoubleCon:
5233   case DoubleBot:
5234   case NarrowOop:
5235   case NarrowKlass:
5236   case Bottom:                  // Ye Olde Default
5237     return Type::BOTTOM;
5238   case Top:
5239     return this;
5240 
5241   default:                      // All else is a mistake
5242     typerr(t);
5243 
5244   case AnyPtr: {
5245     // Found an AnyPtr type vs self-OopPtr type
5246     const TypePtr *tp = t-&gt;is_ptr();
5247     Offset offset = meet_offset(tp-&gt;offset());
5248     PTR ptr = meet_ptr(tp-&gt;ptr());
5249     switch (tp-&gt;ptr()) {
5250     case Null:
5251       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5252       // else fall through:
5253     case TopPTR:
5254     case AnyNull: {
5255       return make(ptr, _metadata, offset);
5256     }
5257     case BotPTR:
5258     case NotNull:
5259       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5260     default: typerr(t);
5261     }
5262   }
5263 
5264   case RawPtr:
5265   case KlassPtr:
5266   case OopPtr:
5267   case InstPtr:
5268   case AryPtr:
5269     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
5270 
5271   case MetadataPtr: {
5272     const TypeMetadataPtr *tp = t-&gt;is_metadataptr();
5273     Offset offset = meet_offset(tp-&gt;offset());
5274     PTR tptr = tp-&gt;ptr();
5275     PTR ptr = meet_ptr(tptr);
5276     ciMetadata* md = (tptr == TopPTR) ? metadata() : tp-&gt;metadata();
5277     if (tptr == TopPTR || _ptr == TopPTR ||
5278         metadata()-&gt;equals(tp-&gt;metadata())) {
5279       return make(ptr, md, offset);
5280     }
5281     // metadata is different
5282     if( ptr == Constant ) {  // Cannot be equal constants, so...
5283       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
5284       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
5285       ptr = NotNull;            // Fall down in lattice
5286     }
5287     return make(ptr, NULL, offset);
5288     break;
5289   }
5290   } // End of switch
5291   return this;                  // Return the double constant
5292 }
5293 
5294 
5295 //------------------------------xdual------------------------------------------
5296 // Dual of a pure metadata pointer.
5297 const Type *TypeMetadataPtr::xdual() const {
5298   return new TypeMetadataPtr(dual_ptr(), metadata(), dual_offset());
5299 }
5300 
5301 //------------------------------dump2------------------------------------------
5302 #ifndef PRODUCT
5303 void TypeMetadataPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
5304   st-&gt;print(&quot;metadataptr:%s&quot;, ptr_msg[_ptr]);
5305   if( metadata() ) st-&gt;print(INTPTR_FORMAT, p2i(metadata()));
5306   switch (offset()) {
5307   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
5308   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
5309   case         0: break;
5310   default:        st-&gt;print(&quot;+%d&quot;,offset()); break;
5311   }
5312 }
5313 #endif
5314 
5315 
5316 //=============================================================================
5317 // Convenience common pre-built type.
5318 const TypeMetadataPtr *TypeMetadataPtr::BOTTOM;
5319 
5320 TypeMetadataPtr::TypeMetadataPtr(PTR ptr, ciMetadata* metadata, Offset offset):
5321   TypePtr(MetadataPtr, ptr, offset), _metadata(metadata) {
5322 }
5323 
5324 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethod* m) {
5325   return make(Constant, m, Offset(0));
5326 }
5327 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethodData* m) {
5328   return make(Constant, m, Offset(0));
5329 }
5330 
5331 //------------------------------make-------------------------------------------
5332 // Create a meta data constant
5333 const TypeMetadataPtr* TypeMetadataPtr::make(PTR ptr, ciMetadata* m, Offset offset) {
5334   assert(m == NULL || !m-&gt;is_klass(), &quot;wrong type&quot;);
5335   return (TypeMetadataPtr*)(new TypeMetadataPtr(ptr, m, offset))-&gt;hashcons();
5336 }
5337 
5338 
5339 //=============================================================================
5340 // Convenience common pre-built types.
5341 
5342 // Not-null object klass or below
5343 const TypeKlassPtr *TypeKlassPtr::OBJECT;
5344 const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
5345 
5346 //------------------------------TypeKlassPtr-----------------------------------
5347 TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array)
5348   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant), _flat_array(flat_array) {
5349    assert(!klass-&gt;is_valuetype() || !klass-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);
5350    assert(!flat_array || can_be_value_type(), &quot;incorrect flatten array bit&quot;);
5351 }
5352 
5353 //------------------------------make-------------------------------------------
5354 // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
5355 const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flat_array) {
5356   assert(k == NULL || k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);
5357   return (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset, flat_array))-&gt;hashcons();
5358 }
5359 
5360 //------------------------------eq---------------------------------------------
5361 // Structural equality check for Type representations
5362 bool TypeKlassPtr::eq( const Type *t ) const {
5363   const TypeKlassPtr *p = t-&gt;is_klassptr();
5364   return klass() == p-&gt;klass() &amp;&amp; TypePtr::eq(p) &amp;&amp; flat_array() == p-&gt;flat_array();
5365 }
5366 
5367 //------------------------------hash-------------------------------------------
5368 // Type-specific hashing function.
5369 int TypeKlassPtr::hash(void) const {
5370   return java_add(java_add(klass() != NULL ? klass()-&gt;hash() : (jint)0, (jint)TypePtr::hash()), (jint)flat_array());
5371 }
5372 
5373 //------------------------------singleton--------------------------------------
5374 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5375 // constants
5376 bool TypeKlassPtr::singleton(void) const {
5377   // detune optimizer to not generate constant klass + constant offset as a constant!
5378   // TopPTR, Null, AnyNull, Constant are all singletons
5379   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);
5380 }
5381 
5382 // Do not allow interface-vs.-noninterface joins to collapse to top.
5383 const Type *TypeKlassPtr::filter_helper(const Type *kills, bool include_speculative) const {
5384   // logic here mirrors the one from TypeOopPtr::filter. See comments
5385   // there.
5386   const Type* ft = join_helper(kills, include_speculative);
5387   const TypeKlassPtr* ftkp = ft-&gt;isa_klassptr();
5388   const TypeKlassPtr* ktkp = kills-&gt;isa_klassptr();
5389 
5390   if (ft-&gt;empty()) {
5391     if (!empty() &amp;&amp; ktkp != NULL &amp;&amp; ktkp-&gt;is_loaded() &amp;&amp; ktkp-&gt;klass()-&gt;is_interface())
5392       return kills;             // Uplift to interface
5393 
5394     return Type::TOP;           // Canonical empty value
5395   }
5396 
5397   // Interface klass type could be exact in opposite to interface type,
5398   // return it here instead of incorrect Constant ptr J/L/Object (6894807).
5399   if (ftkp != NULL &amp;&amp; ktkp != NULL &amp;&amp;
5400       ftkp-&gt;is_loaded() &amp;&amp;  ftkp-&gt;klass()-&gt;is_interface() &amp;&amp;
5401       !ftkp-&gt;klass_is_exact() &amp;&amp; // Keep exact interface klass
5402       ktkp-&gt;is_loaded() &amp;&amp; !ktkp-&gt;klass()-&gt;is_interface()) {
5403     return ktkp-&gt;cast_to_ptr_type(ftkp-&gt;ptr());
5404   }
5405 
5406   return ft;
5407 }
5408 
5409 //----------------------compute_klass------------------------------------------
5410 // Compute the defining klass for this class
5411 ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {
5412   // Compute _klass based on element type.
5413   ciKlass* k_ary = NULL;
5414   const TypeAryPtr *tary;
5415   const Type* el = elem();
5416   if (el-&gt;isa_narrowoop()) {
5417     el = el-&gt;make_ptr();
5418   }
5419 
5420   // Get element klass
5421   if (el-&gt;isa_instptr()) {
5422     // Compute object array klass from element klass
5423     k_ary = ciArrayKlass::make(el-&gt;is_oopptr()-&gt;klass());
5424   } else if (el-&gt;isa_valuetype()) {
5425     // If element type is TypeValueType::BOTTOM, value_klass() will be null.
5426     if (el-&gt;value_klass() != NULL) {
5427       k_ary = ciArrayKlass::make(el-&gt;value_klass());
5428     }
5429   } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
5430     // Compute array klass from element klass
5431     ciKlass* k_elem = tary-&gt;klass();
5432     // If element type is something like bottom[], k_elem will be null.
5433     if (k_elem != NULL)
5434       k_ary = ciObjArrayKlass::make(k_elem);
5435   } else if ((el-&gt;base() == Type::Top) ||
5436              (el-&gt;base() == Type::Bottom)) {
5437     // element type of Bottom occurs from meet of basic type
5438     // and object; Top occurs when doing join on Bottom.
5439     // Leave k_ary at NULL.
5440   } else {
5441     // Cannot compute array klass directly from basic type,
5442     // since subtypes of TypeInt all have basic type T_INT.
5443 #ifdef ASSERT
5444     if (verify &amp;&amp; el-&gt;isa_int()) {
5445       // Check simple cases when verifying klass.
5446       BasicType bt = T_ILLEGAL;
5447       if (el == TypeInt::BYTE) {
5448         bt = T_BYTE;
5449       } else if (el == TypeInt::SHORT) {
5450         bt = T_SHORT;
5451       } else if (el == TypeInt::CHAR) {
5452         bt = T_CHAR;
5453       } else if (el == TypeInt::INT) {
5454         bt = T_INT;
5455       } else {
5456         return _klass; // just return specified klass
5457       }
5458       return ciTypeArrayKlass::make(bt);
5459     }
5460 #endif
5461     assert(!el-&gt;isa_int(),
5462            &quot;integral arrays must be pre-equipped with a class&quot;);
5463     // Compute array klass directly from basic type
5464     k_ary = ciTypeArrayKlass::make(el-&gt;basic_type());
5465   }
5466   return k_ary;
5467 }
5468 
5469 //------------------------------klass------------------------------------------
5470 // Return the defining klass for this class
5471 ciKlass* TypeAryPtr::klass() const {
5472   if( _klass ) return _klass;   // Return cached value, if possible
5473 
5474   // Oops, need to compute _klass and cache it
5475   ciKlass* k_ary = compute_klass();
5476 
5477   if( this != TypeAryPtr::OOPS &amp;&amp; this-&gt;dual() != TypeAryPtr::OOPS ) {
5478     // The _klass field acts as a cache of the underlying
5479     // ciKlass for this array type.  In order to set the field,
5480     // we need to cast away const-ness.
5481     //
5482     // IMPORTANT NOTE: we *never* set the _klass field for the
5483     // type TypeAryPtr::OOPS.  This Type is shared between all
5484     // active compilations.  However, the ciKlass which represents
5485     // this Type is *not* shared between compilations, so caching
5486     // this value would result in fetching a dangling pointer.
5487     //
5488     // Recomputing the underlying ciKlass for each request is
5489     // a bit less efficient than caching, but calls to
5490     // TypeAryPtr::OOPS-&gt;klass() are not common enough to matter.
5491     ((TypeAryPtr*)this)-&gt;_klass = k_ary;
5492     if (UseCompressedOops &amp;&amp; k_ary != NULL &amp;&amp; k_ary-&gt;is_obj_array_klass() &amp;&amp;
5493         offset() != 0 &amp;&amp; offset() != arrayOopDesc::length_offset_in_bytes()) {
5494       ((TypeAryPtr*)this)-&gt;_is_ptr_to_narrowoop = true;
5495     }
5496   }
5497   return k_ary;
5498 }
5499 
5500 
5501 //------------------------------add_offset-------------------------------------
5502 // Access internals of klass object
5503 const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
5504   return make(_ptr, klass(), xadd_offset(offset), flat_array());
5505 }
5506 
5507 //------------------------------cast_to_ptr_type-------------------------------
5508 const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
5509   assert(_base == KlassPtr, &quot;subclass must override cast_to_ptr_type&quot;);
5510   if( ptr == _ptr ) return this;
5511   return make(ptr, _klass, _offset, _flat_array);
5512 }
5513 
5514 
5515 //-----------------------------cast_to_exactness-------------------------------
5516 const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
5517   if( klass_is_exact == _klass_is_exact ) return this;
5518   if (!UseExactTypes)  return this;
5519   return make(klass_is_exact ? Constant : NotNull, _klass, _offset, _flat_array);
5520 }
5521 
5522 
5523 //-----------------------------as_instance_type--------------------------------
5524 // Corresponding type for an instance of the given class.
5525 // It will be NotNull, and exact if and only if the klass type is exact.
5526 const TypeOopPtr* TypeKlassPtr::as_instance_type() const {
5527   ciKlass* k = klass();
5528   assert(k != NULL, &quot;klass should not be NULL&quot;);
5529   bool    xk = klass_is_exact();
5530   //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
5531   const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
5532   guarantee(toop != NULL, &quot;need type for given klass&quot;);
5533   toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
5534   if (flat_array() &amp;&amp; !klass()-&gt;is_valuetype()) {
5535     toop = toop-&gt;is_instptr()-&gt;cast_to_flat_array();
5536   }
5537   return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
5538 }
5539 
5540 
5541 //------------------------------xmeet------------------------------------------
5542 // Compute the MEET of two types, return a new Type object.
5543 const Type    *TypeKlassPtr::xmeet( const Type *t ) const {
5544   // Perform a fast test for common case; meeting the same types together.
5545   if( this == t ) return this;  // Meeting same type-rep?
5546 
5547   // Current &quot;this-&gt;_base&quot; is Pointer
5548   switch (t-&gt;base()) {          // switch on original type
5549 
5550   case Int:                     // Mixing ints &amp; oops happens when javac
5551   case Long:                    // reuses local variables
5552   case FloatTop:
5553   case FloatCon:
5554   case FloatBot:
5555   case DoubleTop:
5556   case DoubleCon:
5557   case DoubleBot:
5558   case NarrowOop:
5559   case NarrowKlass:
5560   case Bottom:                  // Ye Olde Default
5561     return Type::BOTTOM;
5562   case Top:
5563     return this;
5564 
5565   default:                      // All else is a mistake
5566     typerr(t);
5567 
5568   case AnyPtr: {                // Meeting to AnyPtrs
5569     // Found an AnyPtr type vs self-KlassPtr type
5570     const TypePtr *tp = t-&gt;is_ptr();
5571     Offset offset = meet_offset(tp-&gt;offset());
5572     PTR ptr = meet_ptr(tp-&gt;ptr());
5573     switch (tp-&gt;ptr()) {
5574     case TopPTR:
5575       return this;
5576     case Null:
5577       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5578     case AnyNull:
5579       return make(ptr, klass(), offset, flat_array());
5580     case BotPTR:
5581     case NotNull:
5582       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5583     default: typerr(t);
5584     }
5585   }
5586 
5587   case RawPtr:
5588   case MetadataPtr:
5589   case OopPtr:
5590   case AryPtr:                  // Meet with AryPtr
5591   case InstPtr:                 // Meet with InstPtr
5592     return TypePtr::BOTTOM;
5593 
5594   //
5595   //             A-top         }
5596   //           /   |   \       }  Tops
5597   //       B-top A-any C-top   }
5598   //          | /  |  \ |      }  Any-nulls
5599   //       B-any   |   C-any   }
5600   //          |    |    |
5601   //       B-con A-con C-con   } constants; not comparable across classes
5602   //          |    |    |
5603   //       B-not   |   C-not   }
5604   //          | \  |  / |      }  not-nulls
5605   //       B-bot A-not C-bot   }
5606   //           \   |   /       }  Bottoms
5607   //             A-bot         }
5608   //
5609 
5610   case KlassPtr: {  // Meet two KlassPtr types
5611     const TypeKlassPtr *tkls = t-&gt;is_klassptr();
5612     Offset  off  = meet_offset(tkls-&gt;offset());
5613     PTR  ptr     = meet_ptr(tkls-&gt;ptr());
5614 
5615     if (klass() == NULL || tkls-&gt;klass() == NULL) {
5616       ciKlass* k = NULL;
5617       if (ptr == Constant) {
5618         k = (klass() == NULL) ? tkls-&gt;klass() : klass();
5619       }
5620       return make(ptr, k, off, false);
5621     }
5622 
5623     // Check for easy case; klasses are equal (and perhaps not loaded!)
5624     // If we have constants, then we created oops so classes are loaded
5625     // and we can handle the constants further down.  This case handles
5626     // not-loaded classes
5627     if (ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) &amp;&amp; flat_array() == tkls-&gt;flat_array()) {
5628       return make(ptr, klass(), off, flat_array());
5629     }
5630 
5631     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
5632     ciKlass* tkls_klass = tkls-&gt;klass();
5633     ciKlass* this_klass = this-&gt;klass();
5634     assert( tkls_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5635     assert( this_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5636     bool tkls_flat_array = tkls-&gt;flat_array();
5637     bool this_flat_array  = this-&gt;flat_array();
5638     bool flat_array = below_centerline(ptr) ? (this_flat_array &amp;&amp; tkls_flat_array) : (this_flat_array || tkls_flat_array);
5639 
5640     // If &#39;this&#39; type is above the centerline and is a superclass of the
5641     // other, we can treat &#39;this&#39; as having the same type as the other.
5642     if ((above_centerline(this-&gt;ptr())) &amp;&amp;
5643         tkls_klass-&gt;is_subtype_of(this_klass)) {
5644       this_klass = tkls_klass;
5645     }
5646     // If &#39;tinst&#39; type is above the centerline and is a superclass of the
5647     // other, we can treat &#39;tinst&#39; as having the same type as the other.
5648     if ((above_centerline(tkls-&gt;ptr())) &amp;&amp;
5649         this_klass-&gt;is_subtype_of(tkls_klass)) {
5650       tkls_klass = this_klass;
5651     }
5652 
5653     // Check for classes now being equal
5654     if (tkls_klass-&gt;equals(this_klass)) {
5655       // If the klasses are equal, the constants may still differ.  Fall to
5656       // NotNull if they do (neither constant is NULL; that is a special case
5657       // handled elsewhere).
5658       if( ptr == Constant ) {
5659         if (this-&gt;_ptr == Constant &amp;&amp; tkls-&gt;_ptr == Constant &amp;&amp;
5660             this-&gt;klass()-&gt;equals(tkls-&gt;klass()));
5661         else if (above_centerline(this-&gt;ptr()));
5662         else if (above_centerline(tkls-&gt;ptr()));
5663         else
5664           ptr = NotNull;
5665       }
5666       return make(ptr, this_klass, off, flat_array);
5667     } // Else classes are not equal
5668 
5669     // Since klasses are different, we require the LCA in the Java
5670     // class hierarchy - which means we have to fall to at least NotNull.
5671     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
5672       ptr = NotNull;
5673     // Now we find the LCA of Java classes
5674     ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
5675     return   make(ptr, k, off, k-&gt;is_valuetype() &amp;&amp; k-&gt;flatten_array());
5676   } // End of case KlassPtr
5677 
5678   } // End of switch
5679   return this;                  // Return the double constant
5680 }
5681 
5682 //------------------------------xdual------------------------------------------
5683 // Dual: compute field-by-field dual
5684 const Type    *TypeKlassPtr::xdual() const {
5685   return new TypeKlassPtr(dual_ptr(), klass(), dual_offset(), flat_array());
5686 }
5687 
5688 //------------------------------get_con----------------------------------------
5689 intptr_t TypeKlassPtr::get_con() const {
5690   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
5691   assert(offset() &gt;= 0, &quot;&quot;);
5692 
5693   if (offset() != 0) {
5694     // After being ported to the compiler interface, the compiler no longer
5695     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5696     // to a handle at compile time.  This handle is embedded in the generated
5697     // code and dereferenced at the time the nmethod is made.  Until that time,
5698     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5699     // have access to the addresses!).  This does not seem to currently happen,
5700     // but this assertion here is to help prevent its occurence.
5701     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5702     ShouldNotReachHere();
5703   }
5704 
5705   return (intptr_t)klass()-&gt;constant_encoding();
5706 }
5707 //------------------------------dump2------------------------------------------
5708 // Dump Klass Type
5709 #ifndef PRODUCT
5710 void TypeKlassPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5711   switch( _ptr ) {
5712   case Constant:
5713     st-&gt;print(&quot;precise &quot;);
5714   case NotNull:
5715     {
5716       if (klass() != NULL) {
5717         const char* name = klass()-&gt;name()-&gt;as_utf8();
5718         st-&gt;print(&quot;klass %s: &quot; INTPTR_FORMAT, name, p2i(klass()));
5719       } else {
5720         st-&gt;print(&quot;klass BOTTOM&quot;);
5721       }
5722     }
5723   case BotPTR:
5724     if( !WizardMode &amp;&amp; !Verbose &amp;&amp; !_klass_is_exact ) break;
5725   case TopPTR:
5726   case AnyNull:
5727     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
5728     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
5729     break;
5730   default:
5731     break;
5732   }
5733 
5734   _offset.dump2(st);
5735 
5736   st-&gt;print(&quot; *&quot;);
5737 }
5738 #endif
5739 
5740 
5741 
5742 //=============================================================================
5743 // Convenience common pre-built types.
5744 
5745 //------------------------------make-------------------------------------------
5746 const TypeFunc *TypeFunc::make(const TypeTuple *domain_sig, const TypeTuple* domain_cc,
5747                                const TypeTuple *range_sig, const TypeTuple *range_cc) {
5748   return (TypeFunc*)(new TypeFunc(domain_sig, domain_cc, range_sig, range_cc))-&gt;hashcons();
5749 }
5750 
5751 const TypeFunc *TypeFunc::make(const TypeTuple *domain, const TypeTuple *range) {
5752   return make(domain, domain, range, range);
5753 }
5754 
5755 //------------------------------osr_domain-----------------------------
5756 const TypeTuple* osr_domain() {
5757   const Type **fields = TypeTuple::fields(2);
5758   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM;  // address of osr buffer
5759   return TypeTuple::make(TypeFunc::Parms+1, fields);
5760 }
5761 
5762 //------------------------------make-------------------------------------------
5763 const TypeFunc* TypeFunc::make(ciMethod* method, bool is_osr_compilation) {
5764   Compile* C = Compile::current();
5765   const TypeFunc* tf = NULL;
5766   if (!is_osr_compilation) {
5767     tf = C-&gt;last_tf(method); // check cache
5768     if (tf != NULL)  return tf;  // The hit rate here is almost 50%.
5769   }
5770   // Value types are not passed/returned by reference, instead each field of
5771   // the value type is passed/returned as an argument. We maintain two views of
5772   // the argument/return list here: one based on the signature (with a value
5773   // type argument/return as a single slot), one based on the actual calling
5774   // convention (with a value type argument/return as a list of its fields).
5775   bool has_scalar_args = method-&gt;has_scalarized_args() &amp;&amp; !is_osr_compilation;
5776   const TypeTuple* domain_sig = is_osr_compilation ? osr_domain() : TypeTuple::make_domain(method, false);
5777   const TypeTuple* domain_cc = has_scalar_args ? TypeTuple::make_domain(method, true) : domain_sig;
5778   ciSignature* sig = method-&gt;signature();
5779   bool has_scalar_ret = sig-&gt;return_type()-&gt;is_valuetype() &amp;&amp; sig-&gt;return_type()-&gt;as_value_klass()-&gt;can_be_returned_as_fields();
5780   const TypeTuple* range_sig = TypeTuple::make_range(sig, false);
5781   const TypeTuple* range_cc = has_scalar_ret ? TypeTuple::make_range(sig, true) : range_sig;
5782   tf = TypeFunc::make(domain_sig, domain_cc, range_sig, range_cc);
5783   if (!is_osr_compilation) {
5784     C-&gt;set_last_tf(method, tf);  // fill cache
5785   }
5786   return tf;
5787 }
5788 
5789 //------------------------------meet-------------------------------------------
5790 // Compute the MEET of two types.  It returns a new Type object.
5791 const Type *TypeFunc::xmeet( const Type *t ) const {
5792   // Perform a fast test for common case; meeting the same types together.
5793   if( this == t ) return this;  // Meeting same type-rep?
5794 
5795   // Current &quot;this-&gt;_base&quot; is Func
5796   switch (t-&gt;base()) {          // switch on original type
5797 
5798   case Bottom:                  // Ye Olde Default
5799     return t;
5800 
5801   default:                      // All else is a mistake
5802     typerr(t);
5803 
5804   case Top:
5805     break;
5806   }
5807   return this;                  // Return the double constant
5808 }
5809 
5810 //------------------------------xdual------------------------------------------
5811 // Dual: compute field-by-field dual
5812 const Type *TypeFunc::xdual() const {
5813   return this;
5814 }
5815 
5816 //------------------------------eq---------------------------------------------
5817 // Structural equality check for Type representations
5818 bool TypeFunc::eq( const Type *t ) const {
5819   const TypeFunc *a = (const TypeFunc*)t;
5820   return _domain_sig == a-&gt;_domain_sig &amp;&amp;
5821     _domain_cc == a-&gt;_domain_cc &amp;&amp;
5822     _range_sig == a-&gt;_range_sig &amp;&amp;
5823     _range_cc == a-&gt;_range_cc;
5824 }
5825 
5826 //------------------------------hash-------------------------------------------
5827 // Type-specific hashing function.
5828 int TypeFunc::hash(void) const {
5829   return (intptr_t)_domain_sig + (intptr_t)_domain_cc + (intptr_t)_range_sig + (intptr_t)_range_cc;
5830 }
5831 
5832 //------------------------------dump2------------------------------------------
5833 // Dump Function Type
5834 #ifndef PRODUCT
5835 void TypeFunc::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
5836   if( _range_sig-&gt;cnt() &lt;= Parms )
5837     st-&gt;print(&quot;void&quot;);
5838   else {
5839     uint i;
5840     for (i = Parms; i &lt; _range_sig-&gt;cnt()-1; i++) {
5841       _range_sig-&gt;field_at(i)-&gt;dump2(d,depth,st);
5842       st-&gt;print(&quot;/&quot;);
5843     }
5844     _range_sig-&gt;field_at(i)-&gt;dump2(d,depth,st);
5845   }
5846   st-&gt;print(&quot; &quot;);
5847   st-&gt;print(&quot;( &quot;);
5848   if( !depth || d[this] ) {     // Check for recursive dump
5849     st-&gt;print(&quot;...)&quot;);
5850     return;
5851   }
5852   d.Insert((void*)this,(void*)this);    // Stop recursion
5853   if (Parms &lt; _domain_sig-&gt;cnt())
5854     _domain_sig-&gt;field_at(Parms)-&gt;dump2(d,depth-1,st);
5855   for (uint i = Parms+1; i &lt; _domain_sig-&gt;cnt(); i++) {
5856     st-&gt;print(&quot;, &quot;);
5857     _domain_sig-&gt;field_at(i)-&gt;dump2(d,depth-1,st);
5858   }
5859   st-&gt;print(&quot; )&quot;);
5860 }
5861 #endif
5862 
5863 //------------------------------singleton--------------------------------------
5864 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5865 // constants (Ldi nodes).  Singletons are integer, float or double constants
5866 // or a single symbol.
5867 bool TypeFunc::singleton(void) const {
5868   return false;                 // Never a singleton
5869 }
5870 
5871 bool TypeFunc::empty(void) const {
5872   return false;                 // Never empty
5873 }
5874 
5875 
5876 BasicType TypeFunc::return_type() const{
5877   if (range_sig()-&gt;cnt() == TypeFunc::Parms) {
5878     return T_VOID;
5879   }
5880   return range_sig()-&gt;field_at(TypeFunc::Parms)-&gt;basic_type();
5881 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/AbstractValidatingLambdaMetafactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="InnerClassLambdaMetafactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/AbstractValidatingLambdaMetafactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
349                 // both are primitive: widening
350                 Wrapper wto = forPrimitiveType(toType);
351                 return wto.isConvertibleFrom(wfrom);
352             } else {
353                 // from primitive to reference: boxing
354                 return toType.isAssignableFrom(wfrom.wrapperType());
355             }
356         } else {
357             if (toType.isPrimitive()) {
358                 // from reference to primitive: unboxing
359                 Wrapper wfrom;
360                 if (isWrapperType(fromType) &amp;&amp; (wfrom = forWrapperType(fromType)).primitiveType().isPrimitive()) {
361                     // fromType is a primitive wrapper; unbox+widen
362                     Wrapper wto = forPrimitiveType(toType);
363                     return wto.isConvertibleFrom(wfrom);
364                 } else {
365                     // must be convertible to primitive
366                     return !strict;
367                 }
368             } else {
<span class="line-modified">369                 // both are reference types: fromType should be a superclass of toType.</span>
<span class="line-modified">370                 return !strict || toType.isAssignableFrom(fromType);</span>

371             }
372         }
373     }
374 











































375     /**
376      * Check type adaptability for return types --
377      * special handling of void type) and parameterized fromType
378      * @return True if &#39;fromType&#39; can be converted to &#39;toType&#39;
379      */
380     private boolean isAdaptableToAsReturn(Class&lt;?&gt; fromType, Class&lt;?&gt; toType) {
381         return toType.equals(void.class)
382                || !fromType.equals(void.class) &amp;&amp; isAdaptableTo(fromType, toType, false);
383     }
384     private boolean isAdaptableToAsReturnStrict(Class&lt;?&gt; fromType, Class&lt;?&gt; toType) {
385         if (fromType.equals(void.class) || toType.equals(void.class)) return fromType.equals(toType);
386         else return isAdaptableTo(fromType, toType, true);
387     }
388 
389 
390     /*********** Logging support -- for debugging only, uncomment as needed
391     static final Executor logPool = Executors.newSingleThreadExecutor();
392     protected static void log(final String s) {
393         MethodHandleProxyLambdaMetafactory.logPool.execute(new Runnable() {
394             @Override
</pre>
</td>
<td>
<hr />
<pre>
349                 // both are primitive: widening
350                 Wrapper wto = forPrimitiveType(toType);
351                 return wto.isConvertibleFrom(wfrom);
352             } else {
353                 // from primitive to reference: boxing
354                 return toType.isAssignableFrom(wfrom.wrapperType());
355             }
356         } else {
357             if (toType.isPrimitive()) {
358                 // from reference to primitive: unboxing
359                 Wrapper wfrom;
360                 if (isWrapperType(fromType) &amp;&amp; (wfrom = forWrapperType(fromType)).primitiveType().isPrimitive()) {
361                     // fromType is a primitive wrapper; unbox+widen
362                     Wrapper wto = forPrimitiveType(toType);
363                     return wto.isConvertibleFrom(wfrom);
364                 } else {
365                     // must be convertible to primitive
366                     return !strict;
367                 }
368             } else {
<span class="line-modified">369                 // inline types: fromType and toType are projection types of the same inline class</span>
<span class="line-modified">370                 // identity types: fromType should be a superclass of toType.</span>
<span class="line-added">371                 return !strict || canConvert(fromType, toType);</span>
372             }
373         }
374     }
375 
<span class="line-added">376     /**</span>
<span class="line-added">377      * Tests if {@code fromType} can be converted to {@code toType}</span>
<span class="line-added">378      * via an identity conversion, via a widening reference conversion or</span>
<span class="line-added">379      * via inline narrowing and widening conversions.</span>
<span class="line-added">380      * &lt;p&gt;</span>
<span class="line-added">381      * If {@code fromType} represents a class or interface, this method</span>
<span class="line-added">382      * returns {@code true} if {@code toType} is the same as,</span>
<span class="line-added">383      * or is a superclass or superinterface of, {@code fromType}.</span>
<span class="line-added">384      * &lt;p&gt;</span>
<span class="line-added">385      * If {@code fromType} is an inline class, this method returns {@code true}</span>
<span class="line-added">386      * if {@code toType} is the {@linkplain Class#referenceType() reference projection type}</span>
<span class="line-added">387      * of {@code fromType}.</span>
<span class="line-added">388      * If {@code toType} is an inline class, this method returns {@code true}</span>
<span class="line-added">389      * if {@code toType} is the {@linkplain Class#valueType() value projection type}</span>
<span class="line-added">390      * of {@code fromType}.</span>
<span class="line-added">391      * &lt;p&gt;</span>
<span class="line-added">392      * Otherwise, this method returns {@code false}.</span>
<span class="line-added">393      *</span>
<span class="line-added">394      * @param     fromType the {@code Class} object to be converted from</span>
<span class="line-added">395      * @param     toType the {@code Class} object to be converted to</span>
<span class="line-added">396      * @return    {@code true} if {@code fromType} can be converted to {@code toType}</span>
<span class="line-added">397      */</span>
<span class="line-added">398     private boolean canConvert(Class&lt;?&gt; fromType, Class&lt;?&gt; toType) {</span>
<span class="line-added">399         if (toType.isAssignableFrom(fromType)) {</span>
<span class="line-added">400             return true;</span>
<span class="line-added">401         }</span>
<span class="line-added">402 </span>
<span class="line-added">403         if (!fromType.isInlineClass() &amp;&amp; !toType.isInlineClass()) {</span>
<span class="line-added">404             return false;</span>
<span class="line-added">405         }</span>
<span class="line-added">406 </span>
<span class="line-added">407         Class&lt;?&gt; valType = fromType.valueType().orElse(null);</span>
<span class="line-added">408         Class&lt;?&gt; refType = fromType.referenceType().orElse(null);</span>
<span class="line-added">409         if (fromType.isInlineClass()) {</span>
<span class="line-added">410             return refType == toType;</span>
<span class="line-added">411         }</span>
<span class="line-added">412         if (toType.isInlineClass()) {</span>
<span class="line-added">413             return valType == toType;</span>
<span class="line-added">414         }</span>
<span class="line-added">415 </span>
<span class="line-added">416         return false;</span>
<span class="line-added">417     }</span>
<span class="line-added">418 </span>
419     /**
420      * Check type adaptability for return types --
421      * special handling of void type) and parameterized fromType
422      * @return True if &#39;fromType&#39; can be converted to &#39;toType&#39;
423      */
424     private boolean isAdaptableToAsReturn(Class&lt;?&gt; fromType, Class&lt;?&gt; toType) {
425         return toType.equals(void.class)
426                || !fromType.equals(void.class) &amp;&amp; isAdaptableTo(fromType, toType, false);
427     }
428     private boolean isAdaptableToAsReturnStrict(Class&lt;?&gt; fromType, Class&lt;?&gt; toType) {
429         if (fromType.equals(void.class) || toType.equals(void.class)) return fromType.equals(toType);
430         else return isAdaptableTo(fromType, toType, true);
431     }
432 
433 
434     /*********** Logging support -- for debugging only, uncomment as needed
435     static final Executor logPool = Executors.newSingleThreadExecutor();
436     protected static void log(final String s) {
437         MethodHandleProxyLambdaMetafactory.logPool.execute(new Runnable() {
438             @Override
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="InnerClassLambdaMetafactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/instanceKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_INSTANCEKLASS_HPP
  26 #define SHARE_OOPS_INSTANCEKLASS_HPP
  27 
  28 #include &quot;classfile/classLoaderData.hpp&quot;
  29 #include &quot;code/vmreg.hpp&quot;
  30 #include &quot;memory/referenceType.hpp&quot;
  31 #include &quot;oops/annotations.hpp&quot;
  32 #include &quot;oops/constMethod.hpp&quot;
  33 #include &quot;oops/fieldInfo.hpp&quot;
  34 #include &quot;oops/instanceOop.hpp&quot;
  35 #include &quot;oops/klassVtable.hpp&quot;
  36 #include &quot;runtime/handles.hpp&quot;
  37 #include &quot;runtime/os.hpp&quot;
  38 #include &quot;utilities/accessFlags.hpp&quot;
  39 #include &quot;utilities/align.hpp&quot;
  40 #include &quot;utilities/macros.hpp&quot;
  41 #if INCLUDE_JFR
  42 #include &quot;jfr/support/jfrKlassExtension.hpp&quot;
  43 #endif
  44 
  45 class RecordComponent;
  46 
  47 // An InstanceKlass is the VM level representation of a Java class.
  48 // It contains all information needed for at class at execution runtime.
  49 
  50 //  InstanceKlass embedded field layout (after declared fields):
  51 //    [EMBEDDED Java vtable             ] size in words = vtable_len
  52 //    [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size
  53 //      The embedded nonstatic oop-map blocks are short pairs (offset, length)
  54 //      indicating where oops are located in instances of this klass.
  55 //    [EMBEDDED implementor of the interface] only exist for interface
  56 //    [EMBEDDED unsafe_anonymous_host klass] only exist for an unsafe anonymous class (JSR 292 enabled)
  57 //    [EMBEDDED fingerprint       ] only if should_store_fingerprint()==true
  58 //    [EMBEDDED ValueKlassFixedBlock] only if is a ValueKlass instance
  59 
  60 
  61 // forward declaration for class -- see below for definition
  62 #if INCLUDE_JVMTI
  63 class BreakpointInfo;
  64 #endif
  65 class ClassFileParser;
  66 class ClassFileStream;
  67 class KlassDepChange;
  68 class DependencyContext;
  69 class fieldDescriptor;
  70 class jniIdMapBase;
  71 class JNIid;
  72 class JvmtiCachedClassFieldMap;
  73 class nmethodBucket;
  74 class OopMapCache;
  75 class BufferedValueTypeBlob;
  76 class InterpreterOopMap;
  77 class PackageEntry;
  78 class ModuleEntry;
  79 
  80 // This is used in iterators below.
  81 class FieldClosure: public StackObj {
  82 public:
  83   virtual void do_field(fieldDescriptor* fd) = 0;
  84 };
  85 
  86 #ifndef PRODUCT
  87 // Print fields.
  88 // If &quot;obj&quot; argument to constructor is NULL, prints static fields, otherwise prints non-static fields.
  89 class FieldPrinter: public FieldClosure {
  90    oop _obj;
  91    outputStream* _st;
  92  public:
  93    FieldPrinter(outputStream* st, oop obj = NULL) : _obj(obj), _st(st) {}
  94    void do_field(fieldDescriptor* fd);
  95 };
  96 #endif  // !PRODUCT
  97 
  98 // Describes where oops are located in instances of this klass.
  99 class OopMapBlock {
 100  public:
 101   // Byte offset of the first oop mapped by this block.
 102   int offset() const          { return _offset; }
 103   void set_offset(int offset) { _offset = offset; }
 104 
 105   // Number of oops in this block.
 106   uint count() const         { return _count; }
 107   void set_count(uint count) { _count = count; }
 108 
 109   void increment_count(int diff) { _count += diff; }
 110 
 111   int offset_span() const { return _count * heapOopSize; }
 112 
 113   int end_offset() const {
 114     return offset() + offset_span();
 115   }
 116 
 117   bool is_contiguous(int another_offset) const {
 118     return another_offset == end_offset();
 119   }
 120 
 121   // sizeof(OopMapBlock) in words.
 122   static const int size_in_words() {
 123     return align_up((int)sizeof(OopMapBlock), wordSize) &gt;&gt;
 124       LogBytesPerWord;
 125   }
 126 
 127   static int compare_offset(const OopMapBlock* a, const OopMapBlock* b) {
 128     return a-&gt;offset() - b-&gt;offset();
 129   }
 130 
 131  private:
 132   int  _offset;
 133   uint _count;
 134 };
 135 
 136 struct JvmtiCachedClassFileData;
 137 
 138 class SigEntry;
 139 
 140 class ValueKlassFixedBlock {
 141   Array&lt;SigEntry&gt;** _extended_sig;
 142   Array&lt;VMRegPair&gt;** _return_regs;
 143   address* _pack_handler;
 144   address* _pack_handler_jobject;
 145   address* _unpack_handler;
 146   int* _default_value_offset;
 147   Klass** _value_array_klass;
 148   int _alignment;
 149   int _first_field_offset;
 150   int _exact_size_in_bytes;
 151 
 152   friend class ValueKlass;
 153 };
 154 
 155 class ValueTypes {
 156 public:
 157   u2 _class_info_index;
 158   Symbol* _class_name;
 159 };
 160 
 161 class InstanceKlass: public Klass {
 162   friend class VMStructs;
 163   friend class JVMCIVMStructs;
 164   friend class ClassFileParser;
 165   friend class CompileReplay;
 166   friend class TemplateTable;
 167 
 168  public:
 169   static const KlassID ID = InstanceKlassID;
 170 
 171  protected:
 172   InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id = ID);
 173 
 174  public:
 175   InstanceKlass() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for CDS&quot;); }
 176 
 177   // See &quot;The Java Virtual Machine Specification&quot; section 2.16.2-5 for a detailed description
 178   // of the class loading &amp; initialization procedure, and the use of the states.
 179   enum ClassState {
 180     allocated,                          // allocated (but not yet linked)
 181     loaded,                             // loaded and inserted in class hierarchy (but not linked yet)
 182     linked,                             // successfully linked/verified (but not initialized yet)
 183     being_initialized,                  // currently running class initializer
 184     fully_initialized,                  // initialized (successful final state)
 185     initialization_error                // error happened during initialization
 186   };
 187 
 188  private:
 189   static InstanceKlass* allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS);
 190 
 191  protected:
 192   // If you add a new field that points to any metaspace object, you
 193   // must add this field to InstanceKlass::metaspace_pointers_do().
 194 
 195   // Annotations for this class
 196   Annotations*    _annotations;
 197   // Package this class is defined in
 198   PackageEntry*   _package_entry;
 199   // Array classes holding elements of this class.
 200   Klass* volatile _array_klasses;
 201   // Constant pool for this class.
 202   ConstantPool* _constants;
 203   // The InnerClasses attribute and EnclosingMethod attribute. The
 204   // _inner_classes is an array of shorts. If the class has InnerClasses
 205   // attribute, then the _inner_classes array begins with 4-tuples of shorts
 206   // [inner_class_info_index, outer_class_info_index,
 207   // inner_name_index, inner_class_access_flags] for the InnerClasses
 208   // attribute. If the EnclosingMethod attribute exists, it occupies the
 209   // last two shorts [class_index, method_index] of the array. If only
 210   // the InnerClasses attribute exists, the _inner_classes array length is
 211   // number_of_inner_classes * 4. If the class has both InnerClasses
 212   // and EnclosingMethod attributes the _inner_classes array length is
 213   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 214   Array&lt;jushort&gt;* _inner_classes;
 215 
 216   // The NestMembers attribute. An array of shorts, where each is a
 217   // class info index for the class that is a nest member. This data
 218   // has not been validated.
 219   Array&lt;jushort&gt;* _nest_members;
 220 
 221   // The NestHost attribute. The class info index for the class
 222   // that is the nest-host of this class. This data has not been validated.
 223   jushort _nest_host_index;
 224 
 225   // Resolved nest-host klass: either true nest-host or self if we are not nested.
 226   // By always being set it makes nest-member access checks simpler.
 227   InstanceKlass* _nest_host;
 228 
 229   Array&lt;ValueTypes&gt;* _value_types;
 230 
 231   // The contents of the Record attribute.
 232   Array&lt;RecordComponent*&gt;* _record_components;
 233 
 234   // the source debug extension for this klass, NULL if not specified.
 235   // Specified as UTF-8 string without terminating zero byte in the classfile,
 236   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 237   const char*     _source_debug_extension;
 238   // Array name derived from this class which needs unreferencing
 239   // if this class is unloaded.
 240   Symbol*         _array_name;
 241 
 242   // Number of heapOopSize words used by non-static fields in this klass
 243   // (including inherited fields but after header_size()).
 244   int             _nonstatic_field_size;
 245   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 246   // Constant pool index to the utf8 entry of the Generic signature,
 247   // or 0 if none.
 248   u2              _generic_signature_index;
 249   // Constant pool index to the utf8 entry for the name of source file
 250   // containing this klass, 0 if not specified.
 251   u2              _source_file_name_index;
 252   u2              _static_oop_field_count;// number of static oop fields in this klass
 253   u2              _java_fields_count;    // The number of declared Java fields
 254   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 255 
 256   int             _itable_len;           // length of Java itable (in words)
 257   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 258   // _misc_flags.
 259   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
 260 
<a name="1" id="anc1"></a><span class="line-removed"> 261   bool _invalid_inline_super;   // if true, invalid super type for an inline type.</span>
<span class="line-removed"> 262   bool _invalid_identity_super; // if true, invalid super type for an identity type.</span>
<span class="line-removed"> 263 </span>
 264   // The low three bits of _misc_flags contains the kind field.
 265   // This can be used to quickly discriminate among the five kinds of
 266   // InstanceKlass.
 267 
 268   static const unsigned _misc_kind_field_size = 3;
 269   static const unsigned _misc_kind_field_pos  = 0;
 270   static const unsigned _misc_kind_field_mask = (1u &lt;&lt; _misc_kind_field_size) - 1u;
 271 
 272   static const unsigned _misc_kind_other        = 0; // concrete InstanceKlass
 273   static const unsigned _misc_kind_reference    = 1; // InstanceRefKlass
 274   static const unsigned _misc_kind_class_loader = 2; // InstanceClassLoaderKlass
 275   static const unsigned _misc_kind_mirror       = 3; // InstanceMirrorKlass
 276   static const unsigned _misc_kind_value_type   = 4; // ValueKlass
 277 
 278   // Start after _misc_kind field.
 279   enum {
 280     _misc_rewritten                           = 1 &lt;&lt; 3,  // methods rewritten.
 281     _misc_has_nonstatic_fields                = 1 &lt;&lt; 4,  // for sizing with UseCompressedOops
 282     _misc_should_verify_class                 = 1 &lt;&lt; 5,  // allow caching of preverification
 283     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 6,  // has embedded _unsafe_anonymous_host field
 284     _misc_is_contended                        = 1 &lt;&lt; 7,  // marked with contended annotation
 285     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 8,  // class/superclass/implemented interfaces has non-static, concrete methods
 286     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 9,  // directly declares non-static, concrete methods
 287     _misc_has_been_redefined                  = 1 &lt;&lt; 10,  // class has been redefined
 288     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 11, // when this class was loaded, the fingerprint computed from its
 289                                                          // code source was found to be matching the value recorded by AOT.
 290     _misc_is_scratch_class                    = 1 &lt;&lt; 12, // class is the redefined scratch class
 291     _misc_is_shared_boot_class                = 1 &lt;&lt; 13, // defining class loader is boot class loader
 292     _misc_is_shared_platform_class            = 1 &lt;&lt; 14, // defining class loader is platform class loader
 293     _misc_is_shared_app_class                 = 1 &lt;&lt; 15, // defining class loader is app class loader
 294     _misc_has_resolved_methods                = 1 &lt;&lt; 16, // resolved methods table entries added for this class
 295     _misc_is_being_redefined                  = 1 &lt;&lt; 17, // used for locking redefinition
 296     _misc_has_contended_annotations           = 1 &lt;&lt; 18, // has @Contended annotation
 297     _misc_has_value_fields                    = 1 &lt;&lt; 19, // has value fields and related embedded section is not empty
 298     _misc_is_empty_value                      = 1 &lt;&lt; 20, // empty value type
 299     _misc_is_naturally_atomic                 = 1 &lt;&lt; 21, // loaded/stored in one instruction
<a name="2" id="anc2"></a><span class="line-modified"> 300     _misc_is_declared_atomic                  = 1 &lt;&lt; 22  // implements jl.NonTearable</span>


 301   };
 302   u2 shared_loader_type_bits() const {
 303     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 304   }
 305   u4              _misc_flags;
 306   u2              _minor_version;        // minor version number of class file
 307   u2              _major_version;        // major version number of class file
 308   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)
 309   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 310   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 311   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 312   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 313   uint64_t        volatile _dep_context_last_cleaned;
 314   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 315 #if INCLUDE_JVMTI
 316   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 317   // Linked instanceKlasses of previous versions
 318   InstanceKlass* _previous_versions;
 319   // JVMTI fields can be moved to their own structure - see 6315920
 320   // JVMTI: cached class file, before retransformable agent modified it in CFLH
 321   JvmtiCachedClassFileData* _cached_class_file;
 322 #endif
 323 
 324   volatile u2     _idnum_allocated_count;         // JNI/JVMTI: increments with the addition of methods, old ids don&#39;t change
 325 
 326   // Class states are defined as ClassState (see above).
 327   // Place the _init_state here to utilize the unused 2-byte after
 328   // _idnum_allocated_count.
 329   u1              _init_state;                    // state of class
 330   u1              _reference_type;                // reference type
 331 
 332   u2              _this_class_index;              // constant pool entry
 333 #if INCLUDE_JVMTI
 334   JvmtiCachedClassFieldMap* _jvmti_cached_class_field_map;  // JVMTI: used during heap iteration
 335 #endif
 336 
 337   NOT_PRODUCT(int _verify_count;)  // to avoid redundant verifies
 338 
 339   // Method array.
 340   Array&lt;Method*&gt;* _methods;
 341   // Default Method Array, concrete methods inherited from interfaces
 342   Array&lt;Method*&gt;* _default_methods;
 343   // Interfaces (InstanceKlass*s) this class declares locally to implement.
 344   Array&lt;InstanceKlass*&gt;* _local_interfaces;
 345   // Interfaces (InstanceKlass*s) this class implements transitively.
 346   Array&lt;InstanceKlass*&gt;* _transitive_interfaces;
 347   // Int array containing the original order of method in the class file (for JVMTI).
 348   Array&lt;int&gt;*     _method_ordering;
 349   // Int array containing the vtable_indices for default_methods
 350   // offset matches _default_methods offset
 351   Array&lt;int&gt;*     _default_vtable_indices;
 352 
 353   // Instance and static variable information, starts with 6-tuples of shorts
 354   // [access, name index, sig index, initval index, low_offset, high_offset]
 355   // for all fields, followed by the generic signature data at the end of
 356   // the array. Only fields with generic signature attributes have the generic
 357   // signature data set in the array. The fields array looks like following:
 358   //
 359   // f1: [access, name index, sig index, initial value index, low_offset, high_offset]
 360   // f2: [access, name index, sig index, initial value index, low_offset, high_offset]
 361   //      ...
 362   // fn: [access, name index, sig index, initial value index, low_offset, high_offset]
 363   //     [generic signature index]
 364   //     [generic signature index]
 365   //     ...
 366   Array&lt;u2&gt;*      _fields;
 367   const Klass**   _value_field_klasses; // For &quot;inline class&quot; fields, NULL if none present
 368 
 369   const ValueKlassFixedBlock* _adr_valueklass_fixed_block;
 370 
 371   // embedded Java vtable follows here
 372   // embedded Java itables follows here
 373   // embedded static fields follows here
 374   // embedded nonstatic oop-map blocks follows here
 375   // embedded implementor of this interface follows here
 376   //   The embedded implementor only exists if the current klass is an
 377   //   iterface. The possible values of the implementor fall into following
 378   //   three cases:
 379   //     NULL: no implementor.
 380   //     A Klass* that&#39;s not itself: one implementor.
 381   //     Itself: more than one implementors.
 382   // embedded unsafe_anonymous_host klass follows here
 383   //   The embedded host klass only exists in an unsafe anonymous class for
 384   //   dynamic language support (JSR 292 enabled). The host class grants
 385   //   its access privileges to this class also. The host class is either
 386   //   named, or a previously loaded unsafe anonymous class. A non-anonymous class
 387   //   or an anonymous class loaded through normal classloading does not
 388   //   have this embedded field.
 389   //
 390 
 391   friend class SystemDictionary;
 392 
 393   static bool _disable_method_binary_search;
 394 
 395  public:
 396   // The three BUILTIN class loader types
 397   bool is_shared_boot_class() const {
 398     return (_misc_flags &amp; _misc_is_shared_boot_class) != 0;
 399   }
 400   bool is_shared_platform_class() const {
 401     return (_misc_flags &amp; _misc_is_shared_platform_class) != 0;
 402   }
 403   bool is_shared_app_class() const {
 404     return (_misc_flags &amp; _misc_is_shared_app_class) != 0;
 405   }
 406   // The UNREGISTERED class loader type
 407   bool is_shared_unregistered_class() const {
 408     return (_misc_flags &amp; shared_loader_type_bits()) == 0;
 409   }
 410 
 411   void clear_shared_class_loader_type() {
 412     _misc_flags &amp;= ~shared_loader_type_bits();
 413   }
 414 
 415   void set_shared_class_loader_type(s2 loader_type);
 416 
 417   bool has_nonstatic_fields() const        {
 418     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 419   }
 420   void set_has_nonstatic_fields(bool b)    {
 421     if (b) {
 422       _misc_flags |= _misc_has_nonstatic_fields;
 423     } else {
 424       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 425     }
 426   }
 427 
 428   bool has_value_fields() const          {
 429     return (_misc_flags &amp; _misc_has_value_fields) != 0;
 430   }
 431   void set_has_value_fields()  {
 432     _misc_flags |= _misc_has_value_fields;
 433   }
 434 
 435   bool is_empty_value() const {
 436     return (_misc_flags &amp; _misc_is_empty_value) != 0;
 437   }
 438   void set_is_empty_value() {
 439     _misc_flags |= _misc_is_empty_value;
 440   }
 441 
 442   // Note:  The naturally_atomic property only applies to
 443   // inline classes; it is never true on identity classes.
 444   // The bit is placed on instanceKlass for convenience.
 445 
 446   // Query if h/w provides atomic load/store for instances.
 447   bool is_naturally_atomic() const {
 448     return (_misc_flags &amp; _misc_is_naturally_atomic) != 0;
 449   }
 450   // Initialized in the class file parser, not changed later.
 451   void set_is_naturally_atomic() {
 452     _misc_flags |= _misc_is_naturally_atomic;
 453   }
 454 
 455   // Query if this class implements jl.NonTearable or was
 456   // mentioned in the JVM option AlwaysAtomicValueTypes.
 457   // This bit can occur anywhere, but is only significant
 458   // for inline classes *and* their super types.
 459   // It inherits from supers along with NonTearable.
 460   bool is_declared_atomic() const {
 461     return (_misc_flags &amp; _misc_is_declared_atomic) != 0;
 462   }
 463   // Initialized in the class file parser, not changed later.
 464   void set_is_declared_atomic() {
 465     _misc_flags |= _misc_is_declared_atomic;
 466   }
 467 
<a name="3" id="anc3"></a>
















 468   // field sizes
 469   int nonstatic_field_size() const         { return _nonstatic_field_size; }
 470   void set_nonstatic_field_size(int size)  { _nonstatic_field_size = size; }
 471 
 472   int static_field_size() const            { return _static_field_size; }
 473   void set_static_field_size(int size)     { _static_field_size = size; }
 474 
 475   int static_oop_field_count() const       { return (int)_static_oop_field_count; }
 476   void set_static_oop_field_count(u2 size) { _static_oop_field_count = size; }
 477 
 478   // Java itable
 479   int  itable_length() const               { return _itable_len; }
 480   void set_itable_length(int len)          { _itable_len = len; }
 481 
 482   // array klasses
 483   Klass* array_klasses() const             { return _array_klasses; }
 484   inline Klass* array_klasses_acquire() const; // load with acquire semantics
 485   void set_array_klasses(Klass* k)         { _array_klasses = k; }
 486   inline void release_set_array_klasses(Klass* k); // store with release semantics
 487 
 488   // methods
 489   Array&lt;Method*&gt;* methods() const          { return _methods; }
 490   void set_methods(Array&lt;Method*&gt;* a)      { _methods = a; }
 491   Method* method_with_idnum(int idnum);
 492   Method* method_with_orig_idnum(int idnum);
 493   Method* method_with_orig_idnum(int idnum, int version);
 494 
 495   // method ordering
 496   Array&lt;int&gt;* method_ordering() const     { return _method_ordering; }
 497   void set_method_ordering(Array&lt;int&gt;* m) { _method_ordering = m; }
 498   void copy_method_ordering(const intArray* m, TRAPS);
 499 
 500   // default_methods
 501   Array&lt;Method*&gt;* default_methods() const  { return _default_methods; }
 502   void set_default_methods(Array&lt;Method*&gt;* a) { _default_methods = a; }
 503 
 504   // default method vtable_indices
 505   Array&lt;int&gt;* default_vtable_indices() const { return _default_vtable_indices; }
 506   void set_default_vtable_indices(Array&lt;int&gt;* v) { _default_vtable_indices = v; }
 507   Array&lt;int&gt;* create_new_default_vtable_indices(int len, TRAPS);
 508 
 509   // interfaces
 510   Array&lt;InstanceKlass*&gt;* local_interfaces() const          { return _local_interfaces; }
 511   void set_local_interfaces(Array&lt;InstanceKlass*&gt;* a)      {
 512     guarantee(_local_interfaces == NULL || a == NULL, &quot;Just checking&quot;);
 513     _local_interfaces = a; }
 514 
 515   Array&lt;InstanceKlass*&gt;* transitive_interfaces() const     { return _transitive_interfaces; }
 516   void set_transitive_interfaces(Array&lt;InstanceKlass*&gt;* a) {
 517     guarantee(_transitive_interfaces == NULL || a == NULL, &quot;Just checking&quot;);
 518     _transitive_interfaces = a;
 519   }
 520 
 521  private:
 522   friend class fieldDescriptor;
 523   FieldInfo* field(int index) const { return FieldInfo::from_field_array(_fields, index); }
 524 
 525  public:
 526   int     field_offset      (int index) const { return field(index)-&gt;offset(); }
 527   int     field_access_flags(int index) const { return field(index)-&gt;access_flags(); }
 528   Symbol* field_name        (int index) const { return field(index)-&gt;name(constants()); }
 529   Symbol* field_signature   (int index) const { return field(index)-&gt;signature(constants()); }
 530   bool    field_is_flattened(int index) const { return field(index)-&gt;is_flattened(); }
 531   bool    field_is_flattenable(int index) const { return field(index)-&gt;is_flattenable(); }
 532 
 533   // Number of Java declared fields
 534   int java_fields_count() const           { return (int)_java_fields_count; }
 535 
 536   Array&lt;u2&gt;* fields() const            { return _fields; }
 537   void set_fields(Array&lt;u2&gt;* f, u2 java_fields_count) {
 538     guarantee(_fields == NULL || f == NULL, &quot;Just checking&quot;);
 539     _fields = f;
 540     _java_fields_count = java_fields_count;
 541   }
 542 
 543   // inner classes
 544   Array&lt;u2&gt;* inner_classes() const       { return _inner_classes; }
 545   void set_inner_classes(Array&lt;u2&gt;* f)   { _inner_classes = f; }
 546 
 547   // nest members
 548   Array&lt;u2&gt;* nest_members() const     { return _nest_members; }
 549   void set_nest_members(Array&lt;u2&gt;* m) { _nest_members = m; }
 550 
 551   // nest-host index
 552   jushort nest_host_index() const { return _nest_host_index; }
 553   void set_nest_host_index(u2 i)  { _nest_host_index = i; }
 554 
 555   // record components
 556   Array&lt;RecordComponent*&gt;* record_components() const { return _record_components; }
 557   void set_record_components(Array&lt;RecordComponent*&gt;* record_components) {
 558     _record_components = record_components;
 559   }
 560   bool is_record() const { return _record_components != NULL; }
 561 
 562 private:
 563   // Called to verify that k is a member of this nest - does not look at k&#39;s nest-host
 564   bool has_nest_member(InstanceKlass* k, TRAPS) const;
 565 
 566 public:
 567   // Returns nest-host class, resolving and validating it if needed
 568   // Returns NULL if an exception occurs during loading, or validation fails
 569   InstanceKlass* nest_host(Symbol* validationException, TRAPS);
 570   // Check if this klass is a nestmate of k - resolves this nest-host and k&#39;s
 571   bool has_nestmate_access_to(InstanceKlass* k, TRAPS);
 572 
 573   enum InnerClassAttributeOffset {
 574     // From http://mirror.eng/products/jdk/1.1/docs/guide/innerclasses/spec/innerclasses.doc10.html#18814
 575     inner_class_inner_class_info_offset = 0,
 576     inner_class_outer_class_info_offset = 1,
 577     inner_class_inner_name_offset = 2,
 578     inner_class_access_flags_offset = 3,
 579     inner_class_next_offset = 4
 580   };
 581 
 582   enum EnclosingMethodAttributeOffset {
 583     enclosing_method_class_index_offset = 0,
 584     enclosing_method_method_index_offset = 1,
 585     enclosing_method_attribute_size = 2
 586   };
 587 
 588   // method override check
 589   bool is_override(const methodHandle&amp; super_method, Handle targetclassloader, Symbol* targetclassname, TRAPS);
 590 
 591   // package
 592   PackageEntry* package() const     { return _package_entry; }
 593   ModuleEntry* module() const;
 594   bool in_unnamed_package() const   { return (_package_entry == NULL); }
 595   void set_package(PackageEntry* p) { _package_entry = p; }
 596   void set_package(ClassLoaderData* loader_data, PackageEntry* pkg_entry, TRAPS);
 597   bool is_same_class_package(const Klass* class2) const;
 598   bool is_same_class_package(oop other_class_loader, const Symbol* other_class_name) const;
 599 
 600   // find an enclosing class
 601   InstanceKlass* compute_enclosing_class(bool* inner_is_member, TRAPS) const;
 602 
 603   // Find InnerClasses attribute and return outer_class_info_index &amp; inner_name_index.
 604   bool find_inner_classes_attr(int* ooff, int* noff, TRAPS) const;
 605 
 606  private:
 607   // Check prohibited package (&quot;java/&quot; only loadable by boot or platform loaders)
 608   static void check_prohibited_package(Symbol* class_name,
 609                                        ClassLoaderData* loader_data,
 610                                        TRAPS);
 611  public:
 612   // initialization state
 613   bool is_loaded() const                   { return _init_state &gt;= loaded; }
 614   bool is_linked() const                   { return _init_state &gt;= linked; }
 615   bool is_initialized() const              { return _init_state == fully_initialized; }
 616   bool is_not_initialized() const          { return _init_state &lt;  being_initialized; }
 617   bool is_being_initialized() const        { return _init_state == being_initialized; }
 618   bool is_in_error_state() const           { return _init_state == initialization_error; }
 619   bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }
 620   ClassState  init_state()                 { return (ClassState)_init_state; }
 621   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 622 
 623   // defineClass specified verification
 624   bool should_verify_class() const         {
 625     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 626   }
 627   void set_should_verify_class(bool value) {
 628     if (value) {
 629       _misc_flags |= _misc_should_verify_class;
 630     } else {
 631       _misc_flags &amp;= ~_misc_should_verify_class;
 632     }
 633   }
 634 
 635   // marking
 636   bool is_marked_dependent() const         { return _is_marked_dependent; }
 637   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 638 
<a name="4" id="anc4"></a><span class="line-removed"> 639   bool invalid_inline_super() const { return _invalid_inline_super; }</span>
<span class="line-removed"> 640   void set_invalid_inline_super(bool set_invalid_inline_super) {</span>
<span class="line-removed"> 641     _invalid_inline_super = set_invalid_inline_super;</span>
<span class="line-removed"> 642   }</span>
<span class="line-removed"> 643   bool invalid_identity_super() const { return _invalid_identity_super; }</span>
<span class="line-removed"> 644   void set_invalid_identity_super(bool set_invalid_identity_super) {</span>
<span class="line-removed"> 645     _invalid_identity_super = set_invalid_identity_super;</span>
<span class="line-removed"> 646   }</span>
<span class="line-removed"> 647 </span>
 648   static ByteSize misc_flags_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_flags)); }
 649   static u4 misc_flags_is_empty_value() { return _misc_is_empty_value; }
 650 
 651   // initialization (virtuals from Klass)
 652   bool should_be_initialized() const;  // means that initialize should be called
 653   void initialize(TRAPS);
 654   void link_class(TRAPS);
 655   bool link_class_or_fail(TRAPS); // returns false on failure
 656   void rewrite_class(TRAPS);
 657   void link_methods(TRAPS);
 658   Method* class_initializer() const;
 659 
 660   // set the class to initialized if no static initializer is present
 661   void eager_initialize(Thread *thread);
 662 
 663   // reference type
 664   ReferenceType reference_type() const     { return (ReferenceType)_reference_type; }
 665   void set_reference_type(ReferenceType t) {
 666     assert(t == (u1)t, &quot;overflow&quot;);
 667     _reference_type = (u1)t;
 668   }
 669 
 670   // this class cp index
 671   u2 this_class_index() const             { return _this_class_index; }
 672   void set_this_class_index(u2 index)     { _this_class_index = index; }
 673 
 674   static ByteSize reference_type_offset() { return in_ByteSize(offset_of(InstanceKlass, _reference_type)); }
 675 
 676   // find local field, returns true if found
 677   bool find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 678   // find field in direct superinterfaces, returns the interface in which the field is defined
 679   Klass* find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 680   // find field according to JVM spec 5.4.3.2, returns the klass in which the field is defined
 681   Klass* find_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 682   // find instance or static fields according to JVM spec 5.4.3.2, returns the klass in which the field is defined
 683   Klass* find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const;
 684 
 685   // find a non-static or static field given its offset within the class.
 686   bool contains_field_offset(int offset);
 687 
 688   bool find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
 689   bool find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
 690 
 691  private:
 692   inline static int quick_search(const Array&lt;Method*&gt;* methods, const Symbol* name);
 693 
 694  public:
 695   static void disable_method_binary_search() {
 696     _disable_method_binary_search = true;
 697   }
 698 
 699   // find a local method (returns NULL if not found)
 700   Method* find_method(const Symbol* name, const Symbol* signature) const;
 701   static Method* find_method(const Array&lt;Method*&gt;* methods,
 702                              const Symbol* name,
 703                              const Symbol* signature);
 704 
 705   // find a local method, but skip static methods
 706   Method* find_instance_method(const Symbol* name, const Symbol* signature,
 707                                PrivateLookupMode private_mode) const;
 708   static Method* find_instance_method(const Array&lt;Method*&gt;* methods,
 709                                       const Symbol* name,
 710                                       const Symbol* signature,
 711                                       PrivateLookupMode private_mode);
 712 
 713   // find a local method (returns NULL if not found)
 714   Method* find_local_method(const Symbol* name,
 715                             const Symbol* signature,
 716                             OverpassLookupMode overpass_mode,
 717                             StaticLookupMode static_mode,
 718                             PrivateLookupMode private_mode) const;
 719 
 720   // find a local method from given methods array (returns NULL if not found)
 721   static Method* find_local_method(const Array&lt;Method*&gt;* methods,
 722                                    const Symbol* name,
 723                                    const Symbol* signature,
 724                                    OverpassLookupMode overpass_mode,
 725                                    StaticLookupMode static_mode,
 726                                    PrivateLookupMode private_mode);
 727 
 728   // find a local method index in methods or default_methods (returns -1 if not found)
 729   static int find_method_index(const Array&lt;Method*&gt;* methods,
 730                                const Symbol* name,
 731                                const Symbol* signature,
 732                                OverpassLookupMode overpass_mode,
 733                                StaticLookupMode static_mode,
 734                                PrivateLookupMode private_mode);
 735 
 736   // lookup operation (returns NULL if not found)
 737   Method* uncached_lookup_method(const Symbol* name,
 738                                  const Symbol* signature,
 739                                  OverpassLookupMode overpass_mode,
 740                                  PrivateLookupMode private_mode = find_private) const;
 741 
 742   // lookup a method in all the interfaces that this class implements
 743   // (returns NULL if not found)
 744   Method* lookup_method_in_all_interfaces(Symbol* name, Symbol* signature, DefaultsLookupMode defaults_mode) const;
 745 
 746   // lookup a method in local defaults then in all interfaces
 747   // (returns NULL if not found)
 748   Method* lookup_method_in_ordered_interfaces(Symbol* name, Symbol* signature) const;
 749 
 750   // Find method indices by name.  If a method with the specified name is
 751   // found the index to the first method is returned, and &#39;end&#39; is filled in
 752   // with the index of first non-name-matching method.  If no method is found
 753   // -1 is returned.
 754   int find_method_by_name(const Symbol* name, int* end) const;
 755   static int find_method_by_name(const Array&lt;Method*&gt;* methods,
 756                                  const Symbol* name, int* end);
 757 
 758   // constant pool
 759   ConstantPool* constants() const        { return _constants; }
 760   void set_constants(ConstantPool* c)    { _constants = c; }
 761 
 762   // protection domain
 763   oop protection_domain() const;
 764 
 765   // signers
 766   objArrayOop signers() const;
 767 
 768   // host class
 769   InstanceKlass* unsafe_anonymous_host() const {
 770     InstanceKlass** hk = adr_unsafe_anonymous_host();
 771     if (hk == NULL) {
 772       assert(!is_unsafe_anonymous(), &quot;Unsafe anonymous classes have host klasses&quot;);
 773       return NULL;
 774     } else {
 775       assert(*hk != NULL, &quot;host klass should always be set if the address is not null&quot;);
 776       assert(is_unsafe_anonymous(), &quot;Only unsafe anonymous classes have host klasses&quot;);
 777       return *hk;
 778     }
 779   }
 780   void set_unsafe_anonymous_host(const InstanceKlass* host) {
 781     assert(is_unsafe_anonymous(), &quot;not unsafe anonymous&quot;);
 782     const InstanceKlass** addr = (const InstanceKlass **)adr_unsafe_anonymous_host();
 783     assert(addr != NULL, &quot;no reversed space&quot;);
 784     if (addr != NULL) {
 785       *addr = host;
 786     }
 787   }
 788   bool is_unsafe_anonymous() const                {
 789     return (_misc_flags &amp; _misc_is_unsafe_anonymous) != 0;
 790   }
 791   void set_is_unsafe_anonymous(bool value)        {
 792     if (value) {
 793       _misc_flags |= _misc_is_unsafe_anonymous;
 794     } else {
 795       _misc_flags &amp;= ~_misc_is_unsafe_anonymous;
 796     }
 797   }
 798 
 799   bool is_contended() const                {
 800     return (_misc_flags &amp; _misc_is_contended) != 0;
 801   }
 802   void set_is_contended(bool value)        {
 803     if (value) {
 804       _misc_flags |= _misc_is_contended;
 805     } else {
 806       _misc_flags &amp;= ~_misc_is_contended;
 807     }
 808   }
 809 
 810   // source file name
 811   Symbol* source_file_name() const               {
 812     return (_source_file_name_index == 0) ?
 813       (Symbol*)NULL : _constants-&gt;symbol_at(_source_file_name_index);
 814   }
 815   u2 source_file_name_index() const              {
 816     return _source_file_name_index;
 817   }
 818   void set_source_file_name_index(u2 sourcefile_index) {
 819     _source_file_name_index = sourcefile_index;
 820   }
 821 
 822   // minor and major version numbers of class file
 823   u2 minor_version() const                 { return _minor_version; }
 824   void set_minor_version(u2 minor_version) { _minor_version = minor_version; }
 825   u2 major_version() const                 { return _major_version; }
 826   void set_major_version(u2 major_version) { _major_version = major_version; }
 827 
 828   // source debug extension
 829   const char* source_debug_extension() const { return _source_debug_extension; }
 830   void set_source_debug_extension(const char* array, int length);
 831 
 832   // symbol unloading support (refcount already added)
 833   Symbol* array_name()                     { return _array_name; }
 834   void set_array_name(Symbol* name)        { assert(_array_name == NULL  || name == NULL, &quot;name already created&quot;); _array_name = name; }
 835 
 836   // nonstatic oop-map blocks
 837   static int nonstatic_oop_map_size(unsigned int oop_map_count) {
 838     return oop_map_count * OopMapBlock::size_in_words();
 839   }
 840   unsigned int nonstatic_oop_map_count() const {
 841     return _nonstatic_oop_map_size / OopMapBlock::size_in_words();
 842   }
 843   int nonstatic_oop_map_size() const { return _nonstatic_oop_map_size; }
 844   void set_nonstatic_oop_map_size(int words) {
 845     _nonstatic_oop_map_size = words;
 846   }
 847 
 848   bool has_contended_annotations() const {
 849     return ((_misc_flags &amp; _misc_has_contended_annotations) != 0);
 850   }
 851   void set_has_contended_annotations(bool value)  {
 852     if (value) {
 853       _misc_flags |= _misc_has_contended_annotations;
 854     } else {
 855       _misc_flags &amp;= ~_misc_has_contended_annotations;
 856     }
 857   }
 858 
 859 #if INCLUDE_JVMTI
 860   // Redefinition locking.  Class can only be redefined by one thread at a time.
 861 
 862   bool is_being_redefined() const          {
 863     return (_misc_flags &amp; _misc_is_being_redefined);
 864   }
 865   void set_is_being_redefined(bool value)  {
 866     if (value) {
 867       _misc_flags |= _misc_is_being_redefined;
 868     } else {
 869       _misc_flags &amp;= ~_misc_is_being_redefined;
 870     }
 871   }
 872 
 873   // RedefineClasses() support for previous versions:
 874   void add_previous_version(InstanceKlass* ik, int emcp_method_count);
 875   void purge_previous_version_list();
 876 
 877   InstanceKlass* previous_versions() const { return _previous_versions; }
 878 #else
 879   InstanceKlass* previous_versions() const { return NULL; }
 880 #endif
 881 
 882   InstanceKlass* get_klass_version(int version) {
 883     for (InstanceKlass* ik = this; ik != NULL; ik = ik-&gt;previous_versions()) {
 884       if (ik-&gt;constants()-&gt;version() == version) {
 885         return ik;
 886       }
 887     }
 888     return NULL;
 889   }
 890 
 891   bool has_been_redefined() const {
 892     return (_misc_flags &amp; _misc_has_been_redefined) != 0;
 893   }
 894   void set_has_been_redefined() {
 895     _misc_flags |= _misc_has_been_redefined;
 896   }
 897 
 898   bool has_passed_fingerprint_check() const {
 899     return (_misc_flags &amp; _misc_has_passed_fingerprint_check) != 0;
 900   }
 901   void set_has_passed_fingerprint_check(bool b) {
 902     if (b) {
 903       _misc_flags |= _misc_has_passed_fingerprint_check;
 904     } else {
 905       _misc_flags &amp;= ~_misc_has_passed_fingerprint_check;
 906     }
 907   }
 908   bool supers_have_passed_fingerprint_checks();
 909 
 910   static bool should_store_fingerprint(bool is_unsafe_anonymous);
 911   bool should_store_fingerprint() const { return should_store_fingerprint(is_unsafe_anonymous()); }
 912   bool has_stored_fingerprint() const;
 913   uint64_t get_stored_fingerprint() const;
 914   void store_fingerprint(uint64_t fingerprint);
 915 
 916   bool is_scratch_class() const {
 917     return (_misc_flags &amp; _misc_is_scratch_class) != 0;
 918   }
 919 
 920   void set_is_scratch_class() {
 921     _misc_flags |= _misc_is_scratch_class;
 922   }
 923 
 924   bool has_resolved_methods() const {
 925     return (_misc_flags &amp; _misc_has_resolved_methods) != 0;
 926   }
 927 
 928   void set_has_resolved_methods() {
 929     _misc_flags |= _misc_has_resolved_methods;
 930   }
 931 private:
 932 
 933   void set_kind(unsigned kind) {
 934     assert(kind &lt;= _misc_kind_field_mask, &quot;Invalid InstanceKlass kind&quot;);
 935     unsigned fmask = _misc_kind_field_mask &lt;&lt; _misc_kind_field_pos;
 936     unsigned flags = _misc_flags &amp; ~fmask;
 937     _misc_flags = (flags | (kind &lt;&lt; _misc_kind_field_pos));
 938   }
 939 
 940   bool is_kind(unsigned desired) const {
 941     unsigned kind = (_misc_flags &gt;&gt; _misc_kind_field_pos) &amp; _misc_kind_field_mask;
 942     return kind == desired;
 943   }
 944 
 945 public:
 946 
 947   // Other is anything that is not one of the more specialized kinds of InstanceKlass.
 948   bool is_other_instance_klass() const        { return is_kind(_misc_kind_other); }
 949   bool is_reference_instance_klass() const    { return is_kind(_misc_kind_reference); }
 950   bool is_mirror_instance_klass() const       { return is_kind(_misc_kind_mirror); }
 951   bool is_class_loader_instance_klass() const { return is_kind(_misc_kind_class_loader); }
 952   bool is_value_type_klass()            const { return is_kind(_misc_kind_value_type); }
 953 
 954 #if INCLUDE_JVMTI
 955 
 956   void init_previous_versions() {
 957     _previous_versions = NULL;
 958   }
 959 
 960  private:
 961   static bool  _has_previous_versions;
 962  public:
 963   static void purge_previous_versions(InstanceKlass* ik) {
 964     if (ik-&gt;has_been_redefined()) {
 965       ik-&gt;purge_previous_version_list();
 966     }
 967   }
 968 
 969   static bool has_previous_versions_and_reset();
 970   static bool has_previous_versions() { return _has_previous_versions; }
 971 
 972   // JVMTI: Support for caching a class file before it is modified by an agent that can do retransformation
 973   void set_cached_class_file(JvmtiCachedClassFileData *data) {
 974     _cached_class_file = data;
 975   }
 976   JvmtiCachedClassFileData * get_cached_class_file();
 977   jint get_cached_class_file_len();
 978   unsigned char * get_cached_class_file_bytes();
 979 
 980   // JVMTI: Support for caching of field indices, types, and offsets
 981   void set_jvmti_cached_class_field_map(JvmtiCachedClassFieldMap* descriptor) {
 982     _jvmti_cached_class_field_map = descriptor;
 983   }
 984   JvmtiCachedClassFieldMap* jvmti_cached_class_field_map() const {
 985     return _jvmti_cached_class_field_map;
 986   }
 987 #else // INCLUDE_JVMTI
 988 
 989   static void purge_previous_versions(InstanceKlass* ik) { return; };
 990   static bool has_previous_versions_and_reset() { return false; }
 991 
 992   void set_cached_class_file(JvmtiCachedClassFileData *data) {
 993     assert(data == NULL, &quot;unexpected call with JVMTI disabled&quot;);
 994   }
 995   JvmtiCachedClassFileData * get_cached_class_file() { return (JvmtiCachedClassFileData *)NULL; }
 996 
 997 #endif // INCLUDE_JVMTI
 998 
 999   bool has_nonstatic_concrete_methods() const {
1000     return (_misc_flags &amp; _misc_has_nonstatic_concrete_methods) != 0;
1001   }
1002   void set_has_nonstatic_concrete_methods(bool b) {
1003     if (b) {
1004       _misc_flags |= _misc_has_nonstatic_concrete_methods;
1005     } else {
1006       _misc_flags &amp;= ~_misc_has_nonstatic_concrete_methods;
1007     }
1008   }
1009 
1010   bool declares_nonstatic_concrete_methods() const {
1011     return (_misc_flags &amp; _misc_declares_nonstatic_concrete_methods) != 0;
1012   }
1013   void set_declares_nonstatic_concrete_methods(bool b) {
1014     if (b) {
1015       _misc_flags |= _misc_declares_nonstatic_concrete_methods;
1016     } else {
1017       _misc_flags &amp;= ~_misc_declares_nonstatic_concrete_methods;
1018     }
1019   }
1020 
1021   // for adding methods, ConstMethod::UNSET_IDNUM means no more ids available
1022   inline u2 next_method_idnum();
1023   void set_initial_method_idnum(u2 value)             { _idnum_allocated_count = value; }
1024 
1025   // generics support
1026   Symbol* generic_signature() const                   {
1027     return (_generic_signature_index == 0) ?
1028       (Symbol*)NULL : _constants-&gt;symbol_at(_generic_signature_index);
1029   }
1030   u2 generic_signature_index() const                  {
1031     return _generic_signature_index;
1032   }
1033   void set_generic_signature_index(u2 sig_index)      {
1034     _generic_signature_index = sig_index;
1035   }
1036 
1037   u2 enclosing_method_data(int offset) const;
1038   u2 enclosing_method_class_index() const {
1039     return enclosing_method_data(enclosing_method_class_index_offset);
1040   }
1041   u2 enclosing_method_method_index() {
1042     return enclosing_method_data(enclosing_method_method_index_offset);
1043   }
1044   void set_enclosing_method_indices(u2 class_index,
1045                                     u2 method_index);
1046 
1047   // jmethodID support
1048   jmethodID get_jmethod_id(const methodHandle&amp; method_h);
1049   jmethodID get_jmethod_id_fetch_or_update(size_t idnum,
1050                      jmethodID new_id, jmethodID* new_jmeths,
1051                      jmethodID* to_dealloc_id_p,
1052                      jmethodID** to_dealloc_jmeths_p);
1053   static void get_jmethod_id_length_value(jmethodID* cache, size_t idnum,
1054                 size_t *length_p, jmethodID* id_p);
1055   void ensure_space_for_methodids(int start_offset = 0);
1056   jmethodID jmethod_id_or_null(Method* method);
1057 
1058   // annotations support
1059   Annotations* annotations() const          { return _annotations; }
1060   void set_annotations(Annotations* anno)   { _annotations = anno; }
1061 
1062   AnnotationArray* class_annotations() const {
1063     return (_annotations != NULL) ? _annotations-&gt;class_annotations() : NULL;
1064   }
1065   Array&lt;AnnotationArray*&gt;* fields_annotations() const {
1066     return (_annotations != NULL) ? _annotations-&gt;fields_annotations() : NULL;
1067   }
1068   AnnotationArray* class_type_annotations() const {
1069     return (_annotations != NULL) ? _annotations-&gt;class_type_annotations() : NULL;
1070   }
1071   Array&lt;AnnotationArray*&gt;* fields_type_annotations() const {
1072     return (_annotations != NULL) ? _annotations-&gt;fields_type_annotations() : NULL;
1073   }
1074   // allocation
1075   instanceOop allocate_instance(TRAPS);
1076 
1077   // additional member function to return a handle
1078   instanceHandle allocate_instance_handle(TRAPS);
1079 
1080   objArrayOop allocate_objArray(int n, int length, TRAPS);
1081   // Helper function
1082   static instanceOop register_finalizer(instanceOop i, TRAPS);
1083 
1084   // Check whether reflection/jni/jvm code is allowed to instantiate this class;
1085   // if not, throw either an Error or an Exception.
1086   virtual void check_valid_for_instantiation(bool throwError, TRAPS);
1087 
1088   // initialization
1089   void call_class_initializer(TRAPS);
1090   void set_initialization_state_and_notify(ClassState state, TRAPS);
1091 
1092   // OopMapCache support
1093   OopMapCache* oop_map_cache()               { return _oop_map_cache; }
1094   void set_oop_map_cache(OopMapCache *cache) { _oop_map_cache = cache; }
1095   void mask_for(const methodHandle&amp; method, int bci, InterpreterOopMap* entry);
1096 
1097   // JNI identifier support (for static fields - for jni performance)
1098   JNIid* jni_ids()                               { return _jni_ids; }
1099   void set_jni_ids(JNIid* ids)                   { _jni_ids = ids; }
1100   JNIid* jni_id_for(int offset);
1101 
1102   // maintenance of deoptimization dependencies
1103   inline DependencyContext dependencies();
1104   int  mark_dependent_nmethods(KlassDepChange&amp; changes);
1105   void add_dependent_nmethod(nmethod* nm);
1106   void remove_dependent_nmethod(nmethod* nm);
1107   void clean_dependency_context();
1108 
1109   // On-stack replacement support
1110   nmethod* osr_nmethods_head() const         { return _osr_nmethods_head; };
1111   void set_osr_nmethods_head(nmethod* h)     { _osr_nmethods_head = h; };
1112   void add_osr_nmethod(nmethod* n);
1113   bool remove_osr_nmethod(nmethod* n);
1114   int mark_osr_nmethods(const Method* m);
1115   nmethod* lookup_osr_nmethod(const Method* m, int bci, int level, bool match_level) const;
1116 
1117 #if INCLUDE_JVMTI
1118   // Breakpoint support (see methods on Method* for details)
1119   BreakpointInfo* breakpoints() const       { return _breakpoints; };
1120   void set_breakpoints(BreakpointInfo* bps) { _breakpoints = bps; };
1121 #endif
1122 
1123   // support for stub routines
1124   static ByteSize init_state_offset()  { return in_ByteSize(offset_of(InstanceKlass, _init_state)); }
1125   JFR_ONLY(DEFINE_KLASS_TRACE_ID_OFFSET;)
1126   static ByteSize init_thread_offset() { return in_ByteSize(offset_of(InstanceKlass, _init_thread)); }
1127 
1128   static ByteSize value_field_klasses_offset() { return in_ByteSize(offset_of(InstanceKlass, _value_field_klasses)); }
1129   static ByteSize adr_valueklass_fixed_block_offset() { return in_ByteSize(offset_of(InstanceKlass, _adr_valueklass_fixed_block)); }
1130 
1131   // subclass/subinterface checks
1132   bool implements_interface(Klass* k) const;
1133   bool is_same_or_direct_interface(Klass* k) const;
1134 
1135 #ifdef ASSERT
1136   // check whether this class or one of its superclasses was redefined
1137   bool has_redefined_this_or_super() const;
1138 #endif
1139 
1140   // Access to the implementor of an interface.
1141   Klass* implementor() const;
1142   void set_implementor(Klass* k);
1143   int  nof_implementors() const;
1144   void add_implementor(Klass* k);  // k is a new class that implements this interface
1145   void init_implementor();           // initialize
1146 
1147   // link this class into the implementors list of every interface it implements
1148   void process_interfaces(Thread *thread);
1149 
1150   // virtual operations from Klass
1151   GrowableArray&lt;Klass*&gt;* compute_secondary_supers(int num_extra_slots,
1152                                                   Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1153   bool can_be_primary_super_slow() const;
1154   int oop_size(oop obj)  const             { return size_helper(); }
1155   // slow because it&#39;s a virtual call and used for verifying the layout_helper.
1156   // Using the layout_helper bits, we can call is_instance_klass without a virtual call.
1157   DEBUG_ONLY(bool is_instance_klass_slow() const      { return true; })
1158 
1159   // Iterators
1160   void do_local_static_fields(FieldClosure* cl);
1161   void do_nonstatic_fields(FieldClosure* cl); // including inherited fields
1162   void do_local_static_fields(void f(fieldDescriptor*, Handle, TRAPS), Handle, TRAPS);
1163 
1164   void methods_do(void f(Method* method));
1165   virtual void array_klasses_do(void f(Klass* k));
1166 
1167   static InstanceKlass* cast(Klass* k) {
1168     return const_cast&lt;InstanceKlass*&gt;(cast(const_cast&lt;const Klass*&gt;(k)));
1169   }
1170 
1171   static const InstanceKlass* cast(const Klass* k) {
1172     assert(k != NULL, &quot;k should not be null&quot;);
1173     assert(k-&gt;is_instance_klass(), &quot;cast to InstanceKlass&quot;);
1174     return static_cast&lt;const InstanceKlass*&gt;(k);
1175   }
1176 
1177   virtual InstanceKlass* java_super() const {
1178     return (super() == NULL) ? NULL : cast(super());
1179   }
1180 
1181   // Sizing (in words)
1182   static int header_size()            { return sizeof(InstanceKlass)/wordSize; }
1183 
1184   static int size(int vtable_length, int itable_length,
1185                   int nonstatic_oop_map_size,
1186                   bool is_interface, bool is_unsafe_anonymous, bool has_stored_fingerprint,
1187                   int java_fields, bool is_value_type) {
1188     return align_metadata_size(header_size() +
1189            vtable_length +
1190            itable_length +
1191            nonstatic_oop_map_size +
1192            (is_interface ? (int)sizeof(Klass*)/wordSize : 0) +
1193            (is_unsafe_anonymous ? (int)sizeof(Klass*)/wordSize : 0) +
1194            (has_stored_fingerprint ? (int)sizeof(uint64_t*)/wordSize : 0) +
1195            (java_fields * (int)sizeof(Klass*)/wordSize) +
1196            (is_value_type ? (int)sizeof(ValueKlassFixedBlock) : 0));
1197   }
1198   int size() const                    { return size(vtable_length(),
1199                                                itable_length(),
1200                                                nonstatic_oop_map_size(),
1201                                                is_interface(),
1202                                                is_unsafe_anonymous(),
1203                                                has_stored_fingerprint(),
1204                                                has_value_fields() ? java_fields_count() : 0,
1205                                                is_value());
1206   }
1207 
1208   intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }
1209   intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }
1210 
1211   int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }
1212 
1213   oop static_field_base_raw() { return java_mirror(); }
1214 
1215   bool bounds_check(address addr, bool edge_ok = false, intptr_t size_in_bytes = -1) const PRODUCT_RETURN0;
1216 
1217   OopMapBlock* start_of_nonstatic_oop_maps() const {
1218     return (OopMapBlock*)(start_of_itable() + itable_length());
1219   }
1220 
1221   Klass** end_of_nonstatic_oop_maps() const {
1222     return (Klass**)(start_of_nonstatic_oop_maps() +
1223                      nonstatic_oop_map_count());
1224   }
1225 
1226   Klass* volatile* adr_implementor() const {
1227     if (is_interface()) {
1228       return (Klass* volatile*)end_of_nonstatic_oop_maps();
1229     } else {
1230       return NULL;
1231     }
1232   };
1233 
1234   InstanceKlass** adr_unsafe_anonymous_host() const {
1235     if (is_unsafe_anonymous()) {
1236       InstanceKlass** adr_impl = (InstanceKlass**)adr_implementor();
1237       if (adr_impl != NULL) {
1238         return adr_impl + 1;
1239       } else {
1240         return (InstanceKlass **)end_of_nonstatic_oop_maps();
1241       }
1242     } else {
1243       return NULL;
1244     }
1245   }
1246 
1247   address adr_fingerprint() const {
1248     if (has_stored_fingerprint()) {
1249       InstanceKlass** adr_host = adr_unsafe_anonymous_host();
1250       if (adr_host != NULL) {
1251         return (address)(adr_host + 1);
1252       }
1253 
1254       Klass* volatile* adr_impl = adr_implementor();
1255       if (adr_impl != NULL) {
1256         return (address)(adr_impl + 1);
1257       }
1258 
1259       return (address)end_of_nonstatic_oop_maps();
1260     } else {
1261       return NULL;
1262     }
1263   }
1264 
1265   address adr_value_fields_klasses() const {
1266     if (has_value_fields()) {
1267       address adr_fing = adr_fingerprint();
1268       if (adr_fing != NULL) {
1269         return adr_fingerprint() + sizeof(u8);
1270       }
1271 
1272       InstanceKlass** adr_host = adr_unsafe_anonymous_host();
1273       if (adr_host != NULL) {
1274         return (address)(adr_host + 1);
1275       }
1276 
1277       Klass* volatile* adr_impl = adr_implementor();
1278       if (adr_impl != NULL) {
1279         return (address)(adr_impl + 1);
1280       }
1281 
1282       return (address)end_of_nonstatic_oop_maps();
1283     } else {
1284       return NULL;
1285     }
1286   }
1287 
1288   Klass* get_value_field_klass(int idx) const {
1289     assert(has_value_fields(), &quot;Sanity checking&quot;);
1290     Klass* k = ((Klass**)adr_value_fields_klasses())[idx];
1291     assert(k != NULL, &quot;Should always be set before being read&quot;);
1292     assert(k-&gt;is_value(), &quot;Must be a value type&quot;);
1293     return k;
1294   }
1295 
1296   Klass* get_value_field_klass_or_null(int idx) const {
1297     assert(has_value_fields(), &quot;Sanity checking&quot;);
1298     Klass* k = ((Klass**)adr_value_fields_klasses())[idx];
1299     assert(k == NULL || k-&gt;is_value(), &quot;Must be a value type&quot;);
1300     return k;
1301   }
1302 
1303   void set_value_field_klass(int idx, Klass* k) {
1304     assert(has_value_fields(), &quot;Sanity checking&quot;);
1305     assert(k != NULL, &quot;Should not be set to NULL&quot;);
1306     assert(((Klass**)adr_value_fields_klasses())[idx] == NULL, &quot;Should not be set twice&quot;);
1307     ((Klass**)adr_value_fields_klasses())[idx] = k;
1308   }
1309 
1310   // Use this to return the size of an instance in heap words:
1311   virtual int size_helper() const {
1312     return layout_helper_to_size_helper(layout_helper());
1313   }
1314 
1315   // This bit is initialized in classFileParser.cpp.
1316   // It is false under any of the following conditions:
1317   //  - the class is abstract (including any interface)
1318   //  - the class has a finalizer (if !RegisterFinalizersAtInit)
1319   //  - the class size is larger than FastAllocateSizeLimit
1320   //  - the class is java/lang/Class, which cannot be allocated directly
1321   bool can_be_fastpath_allocated() const {
1322     return !layout_helper_needs_slow_path(layout_helper());
1323   }
1324 
1325   // Java itable
1326   klassItable itable() const;        // return klassItable wrapper
1327   Method* method_at_itable(Klass* holder, int index, TRAPS);
1328 
1329 #if INCLUDE_JVMTI
1330   void adjust_default_methods(bool* trace_name_printed);
1331 #endif // INCLUDE_JVMTI
1332 
1333   void clean_weak_instanceklass_links();
1334  private:
1335   void clean_implementors_list();
1336   void clean_method_data();
1337 
1338  public:
1339   // Explicit metaspace deallocation of fields
1340   // For RedefineClasses and class file parsing errors, we need to deallocate
1341   // instanceKlasses and the metadata they point to.
1342   void deallocate_contents(ClassLoaderData* loader_data);
1343   static void deallocate_methods(ClassLoaderData* loader_data,
1344                                  Array&lt;Method*&gt;* methods);
1345   void static deallocate_interfaces(ClassLoaderData* loader_data,
1346                                     const Klass* super_klass,
1347                                     Array&lt;InstanceKlass*&gt;* local_interfaces,
1348                                     Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1349   void static deallocate_record_components(ClassLoaderData* loader_data,
1350                                            Array&lt;RecordComponent*&gt;* record_component);
1351 
1352   // The constant pool is on stack if any of the methods are executing or
1353   // referenced by handles.
1354   bool on_stack() const { return _constants-&gt;on_stack(); }
1355 
1356   // callbacks for actions during class unloading
1357   static void unload_class(InstanceKlass* ik);
1358   static void release_C_heap_structures(InstanceKlass* ik);
1359 
1360   // Naming
1361   const char* signature_name() const;
1362   const char* signature_name_of(char c) const;
1363 
1364   // Oop fields (and metadata) iterators
1365   //
1366   // The InstanceKlass iterators also visits the Object&#39;s klass.
1367 
1368   // Forward iteration
1369  public:
1370   // Iterate over all oop fields in the oop maps.
1371   template &lt;typename T, class OopClosureType&gt;
1372   inline void oop_oop_iterate_oop_maps(oop obj, OopClosureType* closure);
1373 
1374   // Iterate over all oop fields and metadata.
1375   template &lt;typename T, class OopClosureType&gt;
1376   inline void oop_oop_iterate(oop obj, OopClosureType* closure);
1377 
1378   // Iterate over all oop fields in one oop map.
1379   template &lt;typename T, class OopClosureType&gt;
1380   inline void oop_oop_iterate_oop_map(OopMapBlock* map, oop obj, OopClosureType* closure);
1381 
1382 
1383   // Reverse iteration
1384   // Iterate over all oop fields and metadata.
1385   template &lt;typename T, class OopClosureType&gt;
1386   inline void oop_oop_iterate_reverse(oop obj, OopClosureType* closure);
1387 
1388  private:
1389   // Iterate over all oop fields in the oop maps.
1390   template &lt;typename T, class OopClosureType&gt;
1391   inline void oop_oop_iterate_oop_maps_reverse(oop obj, OopClosureType* closure);
1392 
1393   // Iterate over all oop fields in one oop map.
1394   template &lt;typename T, class OopClosureType&gt;
1395   inline void oop_oop_iterate_oop_map_reverse(OopMapBlock* map, oop obj, OopClosureType* closure);
1396 
1397 
1398   // Bounded range iteration
1399  public:
1400   // Iterate over all oop fields in the oop maps.
1401   template &lt;typename T, class OopClosureType&gt;
1402   inline void oop_oop_iterate_oop_maps_bounded(oop obj, OopClosureType* closure, MemRegion mr);
1403 
1404   // Iterate over all oop fields and metadata.
1405   template &lt;typename T, class OopClosureType&gt;
1406   inline void oop_oop_iterate_bounded(oop obj, OopClosureType* closure, MemRegion mr);
1407 
1408  private:
1409   // Iterate over all oop fields in one oop map.
1410   template &lt;typename T, class OopClosureType&gt;
1411   inline void oop_oop_iterate_oop_map_bounded(OopMapBlock* map, oop obj, OopClosureType* closure, MemRegion mr);
1412 
1413 
1414  public:
1415   u2 idnum_allocated_count() const      { return _idnum_allocated_count; }
1416 
1417 private:
1418   // initialization state
1419   void set_init_state(ClassState state);
1420   void set_rewritten()                  { _misc_flags |= _misc_rewritten; }
1421   void set_init_thread(Thread *thread)  { _init_thread = thread; }
1422 
1423   // The RedefineClasses() API can cause new method idnums to be needed
1424   // which will cause the caches to grow. Safety requires different
1425   // cache management logic if the caches can grow instead of just
1426   // going from NULL to non-NULL.
1427   bool idnum_can_increment() const      { return has_been_redefined(); }
1428   inline jmethodID* methods_jmethod_ids_acquire() const;
1429   inline void release_set_methods_jmethod_ids(jmethodID* jmeths);
1430 
1431   // Lock during initialization
1432 public:
1433   // Lock for (1) initialization; (2) access to the ConstantPool of this class.
1434   // Must be one per class and it has to be a VM internal object so java code
1435   // cannot lock it (like the mirror).
1436   // It has to be an object not a Mutex because it&#39;s held through java calls.
1437   oop init_lock() const;
1438 private:
1439   void fence_and_clear_init_lock();
1440 
1441   bool link_class_impl                           (TRAPS);
1442   bool verify_code                               (TRAPS);
1443   void initialize_impl                           (TRAPS);
1444   void initialize_super_interfaces               (TRAPS);
1445   void eager_initialize_impl                     ();
1446   /* jni_id_for_impl for jfieldID only */
1447   JNIid* jni_id_for_impl                         (int offset);
1448 protected:
1449   // Returns the array class for the n&#39;th dimension
1450   virtual Klass* array_klass_impl(ArrayStorageProperties storage_props, bool or_null, int n, TRAPS);
1451 
1452   // Returns the array class with this class as element type
1453   virtual Klass* array_klass_impl(ArrayStorageProperties storage_props, bool or_null, TRAPS);
1454 
1455 private:
1456 
1457   // find a local method (returns NULL if not found)
1458   Method* find_method_impl(const Symbol* name,
1459                            const Symbol* signature,
1460                            OverpassLookupMode overpass_mode,
1461                            StaticLookupMode static_mode,
1462                            PrivateLookupMode private_mode) const;
1463 
1464   static Method* find_method_impl(const Array&lt;Method*&gt;* methods,
1465                                   const Symbol* name,
1466                                   const Symbol* signature,
1467                                   OverpassLookupMode overpass_mode,
1468                                   StaticLookupMode static_mode,
1469                                   PrivateLookupMode private_mode);
1470 
1471   // Free CHeap allocated fields.
1472   void release_C_heap_structures();
1473 
1474 #if INCLUDE_JVMTI
1475   // RedefineClasses support
1476   void link_previous_versions(InstanceKlass* pv) { _previous_versions = pv; }
1477   void mark_newly_obsolete_methods(Array&lt;Method*&gt;* old_methods, int emcp_method_count);
1478 #endif
1479 public:
1480   // CDS support - remove and restore oops from metadata. Oops are not shared.
1481   virtual void remove_unshareable_info();
1482   virtual void remove_java_mirror();
1483   virtual void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS);
1484 
1485   // jvm support
1486   jint compute_modifier_flags(TRAPS) const;
1487 
1488 public:
1489   // JVMTI support
1490   jint jvmti_class_status() const;
1491 
1492   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
1493 
1494  public:
1495   // Printing
1496 #ifndef PRODUCT
1497   void print_on(outputStream* st) const;
1498 #endif
1499   void print_value_on(outputStream* st) const;
1500 
1501   void oop_print_value_on(oop obj, outputStream* st);
1502 
1503 #ifndef PRODUCT
1504   void oop_print_on      (oop obj, outputStream* st);
1505 
1506   void print_dependent_nmethods(bool verbose = false);
1507   bool is_dependent_nmethod(nmethod* nm);
1508   bool verify_itable_index(int index);
1509 #endif
1510 
1511   const char* internal_name() const;
1512 
1513   // Verification
1514   void verify_on(outputStream* st);
1515 
1516   void oop_verify_on(oop obj, outputStream* st);
1517 
1518   // Logging
1519   void print_class_load_logging(ClassLoaderData* loader_data,
1520                                 const char* module_name,
1521                                 const ClassFileStream* cfs) const;
1522 };
1523 
1524 // for adding methods
1525 // UNSET_IDNUM return means no more ids available
1526 inline u2 InstanceKlass::next_method_idnum() {
1527   if (_idnum_allocated_count == ConstMethod::MAX_IDNUM) {
1528     return ConstMethod::UNSET_IDNUM; // no more ids available
1529   } else {
1530     return _idnum_allocated_count++;
1531   }
1532 }
1533 
1534 
1535 /* JNIid class for jfieldIDs only */
1536 class JNIid: public CHeapObj&lt;mtClass&gt; {
1537   friend class VMStructs;
1538  private:
1539   Klass*             _holder;
1540   JNIid*             _next;
1541   int                _offset;
1542 #ifdef ASSERT
1543   bool               _is_static_field_id;
1544 #endif
1545 
1546  public:
1547   // Accessors
1548   Klass* holder() const           { return _holder; }
1549   int offset() const              { return _offset; }
1550   JNIid* next()                   { return _next; }
1551   // Constructor
1552   JNIid(Klass* holder, int offset, JNIid* next);
1553   // Identifier lookup
1554   JNIid* find(int offset);
1555 
1556   bool find_local_field(fieldDescriptor* fd) {
1557     return InstanceKlass::cast(holder())-&gt;find_local_field_from_offset(offset(), true, fd);
1558   }
1559 
1560   static void deallocate(JNIid* id);
1561   // Debugging
1562 #ifdef ASSERT
1563   bool is_static_field_id() const { return _is_static_field_id; }
1564   void set_is_static_field_id()   { _is_static_field_id = true; }
1565 #endif
1566   void verify(Klass* holder);
1567 };
1568 
1569 // An iterator that&#39;s used to access the inner classes indices in the
1570 // InstanceKlass::_inner_classes array.
1571 class InnerClassesIterator : public StackObj {
1572  private:
1573   Array&lt;jushort&gt;* _inner_classes;
1574   int _length;
1575   int _idx;
1576  public:
1577 
1578   InnerClassesIterator(const InstanceKlass* k) {
1579     _inner_classes = k-&gt;inner_classes();
1580     if (k-&gt;inner_classes() != NULL) {
1581       _length = _inner_classes-&gt;length();
1582       // The inner class array&#39;s length should be the multiple of
1583       // inner_class_next_offset if it only contains the InnerClasses
1584       // attribute data, or it should be
1585       // n*inner_class_next_offset+enclosing_method_attribute_size
1586       // if it also contains the EnclosingMethod data.
1587       assert((_length % InstanceKlass::inner_class_next_offset == 0 ||
1588               _length % InstanceKlass::inner_class_next_offset == InstanceKlass::enclosing_method_attribute_size),
1589              &quot;just checking&quot;);
1590       // Remove the enclosing_method portion if exists.
1591       if (_length % InstanceKlass::inner_class_next_offset == InstanceKlass::enclosing_method_attribute_size) {
1592         _length -= InstanceKlass::enclosing_method_attribute_size;
1593       }
1594     } else {
1595       _length = 0;
1596     }
1597     _idx = 0;
1598   }
1599 
1600   int length() const {
1601     return _length;
1602   }
1603 
1604   void next() {
1605     _idx += InstanceKlass::inner_class_next_offset;
1606   }
1607 
1608   bool done() const {
1609     return (_idx &gt;= _length);
1610   }
1611 
1612   u2 inner_class_info_index() const {
1613     return _inner_classes-&gt;at(
1614                _idx + InstanceKlass::inner_class_inner_class_info_offset);
1615   }
1616 
1617   void set_inner_class_info_index(u2 index) {
1618     _inner_classes-&gt;at_put(
1619                _idx + InstanceKlass::inner_class_inner_class_info_offset, index);
1620   }
1621 
1622   u2 outer_class_info_index() const {
1623     return _inner_classes-&gt;at(
1624                _idx + InstanceKlass::inner_class_outer_class_info_offset);
1625   }
1626 
1627   void set_outer_class_info_index(u2 index) {
1628     _inner_classes-&gt;at_put(
1629                _idx + InstanceKlass::inner_class_outer_class_info_offset, index);
1630   }
1631 
1632   u2 inner_name_index() const {
1633     return _inner_classes-&gt;at(
1634                _idx + InstanceKlass::inner_class_inner_name_offset);
1635   }
1636 
1637   void set_inner_name_index(u2 index) {
1638     _inner_classes-&gt;at_put(
1639                _idx + InstanceKlass::inner_class_inner_name_offset, index);
1640   }
1641 
1642   u2 inner_access_flags() const {
1643     return _inner_classes-&gt;at(
1644                _idx + InstanceKlass::inner_class_access_flags_offset);
1645   }
1646 };
1647 
1648 #endif // SHARE_OOPS_INSTANCEKLASS_HPP
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
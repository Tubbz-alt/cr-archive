<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../classfile/classFileParser.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/vmStructs.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 241 
 242   // Number of heapOopSize words used by non-static fields in this klass
 243   // (including inherited fields but after header_size()).
 244   int             _nonstatic_field_size;
 245   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 246   // Constant pool index to the utf8 entry of the Generic signature,
 247   // or 0 if none.
 248   u2              _generic_signature_index;
 249   // Constant pool index to the utf8 entry for the name of source file
 250   // containing this klass, 0 if not specified.
 251   u2              _source_file_name_index;
 252   u2              _static_oop_field_count;// number of static oop fields in this klass
 253   u2              _java_fields_count;    // The number of declared Java fields
 254   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 255 
 256   int             _itable_len;           // length of Java itable (in words)
 257   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 258   // _misc_flags.
 259   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
 260 
<span class="line-removed"> 261   bool _invalid_inline_super;   // if true, invalid super type for an inline type.</span>
<span class="line-removed"> 262   bool _invalid_identity_super; // if true, invalid super type for an identity type.</span>
<span class="line-removed"> 263 </span>
 264   // The low three bits of _misc_flags contains the kind field.
 265   // This can be used to quickly discriminate among the five kinds of
 266   // InstanceKlass.
 267 
 268   static const unsigned _misc_kind_field_size = 3;
 269   static const unsigned _misc_kind_field_pos  = 0;
 270   static const unsigned _misc_kind_field_mask = (1u &lt;&lt; _misc_kind_field_size) - 1u;
 271 
 272   static const unsigned _misc_kind_other        = 0; // concrete InstanceKlass
 273   static const unsigned _misc_kind_reference    = 1; // InstanceRefKlass
 274   static const unsigned _misc_kind_class_loader = 2; // InstanceClassLoaderKlass
 275   static const unsigned _misc_kind_mirror       = 3; // InstanceMirrorKlass
 276   static const unsigned _misc_kind_value_type   = 4; // ValueKlass
 277 
 278   // Start after _misc_kind field.
 279   enum {
 280     _misc_rewritten                           = 1 &lt;&lt; 3,  // methods rewritten.
 281     _misc_has_nonstatic_fields                = 1 &lt;&lt; 4,  // for sizing with UseCompressedOops
 282     _misc_should_verify_class                 = 1 &lt;&lt; 5,  // allow caching of preverification
 283     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 6,  // has embedded _unsafe_anonymous_host field
 284     _misc_is_contended                        = 1 &lt;&lt; 7,  // marked with contended annotation
 285     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 8,  // class/superclass/implemented interfaces has non-static, concrete methods
 286     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 9,  // directly declares non-static, concrete methods
 287     _misc_has_been_redefined                  = 1 &lt;&lt; 10,  // class has been redefined
 288     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 11, // when this class was loaded, the fingerprint computed from its
 289                                                          // code source was found to be matching the value recorded by AOT.
 290     _misc_is_scratch_class                    = 1 &lt;&lt; 12, // class is the redefined scratch class
 291     _misc_is_shared_boot_class                = 1 &lt;&lt; 13, // defining class loader is boot class loader
 292     _misc_is_shared_platform_class            = 1 &lt;&lt; 14, // defining class loader is platform class loader
 293     _misc_is_shared_app_class                 = 1 &lt;&lt; 15, // defining class loader is app class loader
 294     _misc_has_resolved_methods                = 1 &lt;&lt; 16, // resolved methods table entries added for this class
 295     _misc_is_being_redefined                  = 1 &lt;&lt; 17, // used for locking redefinition
 296     _misc_has_contended_annotations           = 1 &lt;&lt; 18, // has @Contended annotation
 297     _misc_has_value_fields                    = 1 &lt;&lt; 19, // has value fields and related embedded section is not empty
 298     _misc_is_empty_value                      = 1 &lt;&lt; 20, // empty value type
 299     _misc_is_naturally_atomic                 = 1 &lt;&lt; 21, // loaded/stored in one instruction
<span class="line-modified"> 300     _misc_is_declared_atomic                  = 1 &lt;&lt; 22  // implements jl.NonTearable</span>


 301   };
 302   u2 shared_loader_type_bits() const {
 303     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 304   }
 305   u4              _misc_flags;
 306   u2              _minor_version;        // minor version number of class file
 307   u2              _major_version;        // major version number of class file
 308   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)
 309   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 310   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 311   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 312   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 313   uint64_t        volatile _dep_context_last_cleaned;
 314   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 315 #if INCLUDE_JVMTI
 316   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 317   // Linked instanceKlasses of previous versions
 318   InstanceKlass* _previous_versions;
 319   // JVMTI fields can be moved to their own structure - see 6315920
 320   // JVMTI: cached class file, before retransformable agent modified it in CFLH
</pre>
<hr />
<pre>
 448     return (_misc_flags &amp; _misc_is_naturally_atomic) != 0;
 449   }
 450   // Initialized in the class file parser, not changed later.
 451   void set_is_naturally_atomic() {
 452     _misc_flags |= _misc_is_naturally_atomic;
 453   }
 454 
 455   // Query if this class implements jl.NonTearable or was
 456   // mentioned in the JVM option AlwaysAtomicValueTypes.
 457   // This bit can occur anywhere, but is only significant
 458   // for inline classes *and* their super types.
 459   // It inherits from supers along with NonTearable.
 460   bool is_declared_atomic() const {
 461     return (_misc_flags &amp; _misc_is_declared_atomic) != 0;
 462   }
 463   // Initialized in the class file parser, not changed later.
 464   void set_is_declared_atomic() {
 465     _misc_flags |= _misc_is_declared_atomic;
 466   }
 467 

















 468   // field sizes
 469   int nonstatic_field_size() const         { return _nonstatic_field_size; }
 470   void set_nonstatic_field_size(int size)  { _nonstatic_field_size = size; }
 471 
 472   int static_field_size() const            { return _static_field_size; }
 473   void set_static_field_size(int size)     { _static_field_size = size; }
 474 
 475   int static_oop_field_count() const       { return (int)_static_oop_field_count; }
 476   void set_static_oop_field_count(u2 size) { _static_oop_field_count = size; }
 477 
 478   // Java itable
 479   int  itable_length() const               { return _itable_len; }
 480   void set_itable_length(int len)          { _itable_len = len; }
 481 
 482   // array klasses
 483   Klass* array_klasses() const             { return _array_klasses; }
 484   inline Klass* array_klasses_acquire() const; // load with acquire semantics
 485   void set_array_klasses(Klass* k)         { _array_klasses = k; }
 486   inline void release_set_array_klasses(Klass* k); // store with release semantics
 487 
</pre>
<hr />
<pre>
 619   bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }
 620   ClassState  init_state()                 { return (ClassState)_init_state; }
 621   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 622 
 623   // defineClass specified verification
 624   bool should_verify_class() const         {
 625     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 626   }
 627   void set_should_verify_class(bool value) {
 628     if (value) {
 629       _misc_flags |= _misc_should_verify_class;
 630     } else {
 631       _misc_flags &amp;= ~_misc_should_verify_class;
 632     }
 633   }
 634 
 635   // marking
 636   bool is_marked_dependent() const         { return _is_marked_dependent; }
 637   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 638 
<span class="line-removed"> 639   bool invalid_inline_super() const { return _invalid_inline_super; }</span>
<span class="line-removed"> 640   void set_invalid_inline_super(bool set_invalid_inline_super) {</span>
<span class="line-removed"> 641     _invalid_inline_super = set_invalid_inline_super;</span>
<span class="line-removed"> 642   }</span>
<span class="line-removed"> 643   bool invalid_identity_super() const { return _invalid_identity_super; }</span>
<span class="line-removed"> 644   void set_invalid_identity_super(bool set_invalid_identity_super) {</span>
<span class="line-removed"> 645     _invalid_identity_super = set_invalid_identity_super;</span>
<span class="line-removed"> 646   }</span>
<span class="line-removed"> 647 </span>
 648   static ByteSize misc_flags_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_flags)); }
 649   static u4 misc_flags_is_empty_value() { return _misc_is_empty_value; }
 650 
 651   // initialization (virtuals from Klass)
 652   bool should_be_initialized() const;  // means that initialize should be called
 653   void initialize(TRAPS);
 654   void link_class(TRAPS);
 655   bool link_class_or_fail(TRAPS); // returns false on failure
 656   void rewrite_class(TRAPS);
 657   void link_methods(TRAPS);
 658   Method* class_initializer() const;
 659 
 660   // set the class to initialized if no static initializer is present
 661   void eager_initialize(Thread *thread);
 662 
 663   // reference type
 664   ReferenceType reference_type() const     { return (ReferenceType)_reference_type; }
 665   void set_reference_type(ReferenceType t) {
 666     assert(t == (u1)t, &quot;overflow&quot;);
 667     _reference_type = (u1)t;
</pre>
</td>
<td>
<hr />
<pre>
 241 
 242   // Number of heapOopSize words used by non-static fields in this klass
 243   // (including inherited fields but after header_size()).
 244   int             _nonstatic_field_size;
 245   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 246   // Constant pool index to the utf8 entry of the Generic signature,
 247   // or 0 if none.
 248   u2              _generic_signature_index;
 249   // Constant pool index to the utf8 entry for the name of source file
 250   // containing this klass, 0 if not specified.
 251   u2              _source_file_name_index;
 252   u2              _static_oop_field_count;// number of static oop fields in this klass
 253   u2              _java_fields_count;    // The number of declared Java fields
 254   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 255 
 256   int             _itable_len;           // length of Java itable (in words)
 257   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 258   // _misc_flags.
 259   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
 260 



 261   // The low three bits of _misc_flags contains the kind field.
 262   // This can be used to quickly discriminate among the five kinds of
 263   // InstanceKlass.
 264 
 265   static const unsigned _misc_kind_field_size = 3;
 266   static const unsigned _misc_kind_field_pos  = 0;
 267   static const unsigned _misc_kind_field_mask = (1u &lt;&lt; _misc_kind_field_size) - 1u;
 268 
 269   static const unsigned _misc_kind_other        = 0; // concrete InstanceKlass
 270   static const unsigned _misc_kind_reference    = 1; // InstanceRefKlass
 271   static const unsigned _misc_kind_class_loader = 2; // InstanceClassLoaderKlass
 272   static const unsigned _misc_kind_mirror       = 3; // InstanceMirrorKlass
 273   static const unsigned _misc_kind_value_type   = 4; // ValueKlass
 274 
 275   // Start after _misc_kind field.
 276   enum {
 277     _misc_rewritten                           = 1 &lt;&lt; 3,  // methods rewritten.
 278     _misc_has_nonstatic_fields                = 1 &lt;&lt; 4,  // for sizing with UseCompressedOops
 279     _misc_should_verify_class                 = 1 &lt;&lt; 5,  // allow caching of preverification
 280     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 6,  // has embedded _unsafe_anonymous_host field
 281     _misc_is_contended                        = 1 &lt;&lt; 7,  // marked with contended annotation
 282     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 8,  // class/superclass/implemented interfaces has non-static, concrete methods
 283     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 9,  // directly declares non-static, concrete methods
 284     _misc_has_been_redefined                  = 1 &lt;&lt; 10,  // class has been redefined
 285     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 11, // when this class was loaded, the fingerprint computed from its
 286                                                          // code source was found to be matching the value recorded by AOT.
 287     _misc_is_scratch_class                    = 1 &lt;&lt; 12, // class is the redefined scratch class
 288     _misc_is_shared_boot_class                = 1 &lt;&lt; 13, // defining class loader is boot class loader
 289     _misc_is_shared_platform_class            = 1 &lt;&lt; 14, // defining class loader is platform class loader
 290     _misc_is_shared_app_class                 = 1 &lt;&lt; 15, // defining class loader is app class loader
 291     _misc_has_resolved_methods                = 1 &lt;&lt; 16, // resolved methods table entries added for this class
 292     _misc_is_being_redefined                  = 1 &lt;&lt; 17, // used for locking redefinition
 293     _misc_has_contended_annotations           = 1 &lt;&lt; 18, // has @Contended annotation
 294     _misc_has_value_fields                    = 1 &lt;&lt; 19, // has value fields and related embedded section is not empty
 295     _misc_is_empty_value                      = 1 &lt;&lt; 20, // empty value type
 296     _misc_is_naturally_atomic                 = 1 &lt;&lt; 21, // loaded/stored in one instruction
<span class="line-modified"> 297     _misc_is_declared_atomic                  = 1 &lt;&lt; 22, // implements jl.NonTearable</span>
<span class="line-added"> 298     _misc_invalid_inline_super                = 1 &lt;&lt; 23, // invalid super type for an inline type</span>
<span class="line-added"> 299     _misc_invalid_identity_super              = 1 &lt;&lt; 24  // invalid super type for an identity type</span>
 300   };
 301   u2 shared_loader_type_bits() const {
 302     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 303   }
 304   u4              _misc_flags;
 305   u2              _minor_version;        // minor version number of class file
 306   u2              _major_version;        // major version number of class file
 307   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)
 308   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 309   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 310   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 311   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 312   uint64_t        volatile _dep_context_last_cleaned;
 313   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 314 #if INCLUDE_JVMTI
 315   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 316   // Linked instanceKlasses of previous versions
 317   InstanceKlass* _previous_versions;
 318   // JVMTI fields can be moved to their own structure - see 6315920
 319   // JVMTI: cached class file, before retransformable agent modified it in CFLH
</pre>
<hr />
<pre>
 447     return (_misc_flags &amp; _misc_is_naturally_atomic) != 0;
 448   }
 449   // Initialized in the class file parser, not changed later.
 450   void set_is_naturally_atomic() {
 451     _misc_flags |= _misc_is_naturally_atomic;
 452   }
 453 
 454   // Query if this class implements jl.NonTearable or was
 455   // mentioned in the JVM option AlwaysAtomicValueTypes.
 456   // This bit can occur anywhere, but is only significant
 457   // for inline classes *and* their super types.
 458   // It inherits from supers along with NonTearable.
 459   bool is_declared_atomic() const {
 460     return (_misc_flags &amp; _misc_is_declared_atomic) != 0;
 461   }
 462   // Initialized in the class file parser, not changed later.
 463   void set_is_declared_atomic() {
 464     _misc_flags |= _misc_is_declared_atomic;
 465   }
 466 
<span class="line-added"> 467   // Query if class is an invalid super class for an inline type.</span>
<span class="line-added"> 468   bool invalid_inline_super() const {</span>
<span class="line-added"> 469     return (_misc_flags &amp; _misc_invalid_inline_super) != 0;</span>
<span class="line-added"> 470   }</span>
<span class="line-added"> 471   // Initialized in the class file parser, not changed later.</span>
<span class="line-added"> 472   void set_invalid_inline_super() {</span>
<span class="line-added"> 473     _misc_flags |= _misc_invalid_inline_super;</span>
<span class="line-added"> 474   }</span>
<span class="line-added"> 475   // Query if class is an invalid super class for an identity type.</span>
<span class="line-added"> 476   bool invalid_identity_super() const {</span>
<span class="line-added"> 477     return (_misc_flags &amp; _misc_invalid_identity_super) != 0;</span>
<span class="line-added"> 478   }</span>
<span class="line-added"> 479   // Initialized in the class file parser, not changed later.</span>
<span class="line-added"> 480   void set_invalid_identity_super() {</span>
<span class="line-added"> 481     _misc_flags |= _misc_invalid_identity_super;</span>
<span class="line-added"> 482   }</span>
<span class="line-added"> 483 </span>
 484   // field sizes
 485   int nonstatic_field_size() const         { return _nonstatic_field_size; }
 486   void set_nonstatic_field_size(int size)  { _nonstatic_field_size = size; }
 487 
 488   int static_field_size() const            { return _static_field_size; }
 489   void set_static_field_size(int size)     { _static_field_size = size; }
 490 
 491   int static_oop_field_count() const       { return (int)_static_oop_field_count; }
 492   void set_static_oop_field_count(u2 size) { _static_oop_field_count = size; }
 493 
 494   // Java itable
 495   int  itable_length() const               { return _itable_len; }
 496   void set_itable_length(int len)          { _itable_len = len; }
 497 
 498   // array klasses
 499   Klass* array_klasses() const             { return _array_klasses; }
 500   inline Klass* array_klasses_acquire() const; // load with acquire semantics
 501   void set_array_klasses(Klass* k)         { _array_klasses = k; }
 502   inline void release_set_array_klasses(Klass* k); // store with release semantics
 503 
</pre>
<hr />
<pre>
 635   bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }
 636   ClassState  init_state()                 { return (ClassState)_init_state; }
 637   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 638 
 639   // defineClass specified verification
 640   bool should_verify_class() const         {
 641     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 642   }
 643   void set_should_verify_class(bool value) {
 644     if (value) {
 645       _misc_flags |= _misc_should_verify_class;
 646     } else {
 647       _misc_flags &amp;= ~_misc_should_verify_class;
 648     }
 649   }
 650 
 651   // marking
 652   bool is_marked_dependent() const         { return _is_marked_dependent; }
 653   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 654 









 655   static ByteSize misc_flags_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_flags)); }
 656   static u4 misc_flags_is_empty_value() { return _misc_is_empty_value; }
 657 
 658   // initialization (virtuals from Klass)
 659   bool should_be_initialized() const;  // means that initialize should be called
 660   void initialize(TRAPS);
 661   void link_class(TRAPS);
 662   bool link_class_or_fail(TRAPS); // returns false on failure
 663   void rewrite_class(TRAPS);
 664   void link_methods(TRAPS);
 665   Method* class_initializer() const;
 666 
 667   // set the class to initialized if no static initializer is present
 668   void eager_initialize(Thread *thread);
 669 
 670   // reference type
 671   ReferenceType reference_type() const     { return (ReferenceType)_reference_type; }
 672   void set_reference_type(ReferenceType t) {
 673     assert(t == (u1)t, &quot;overflow&quot;);
 674     _reference_type = (u1)t;
</pre>
</td>
</tr>
</table>
<center><a href="../classfile/classFileParser.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/vmStructs.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
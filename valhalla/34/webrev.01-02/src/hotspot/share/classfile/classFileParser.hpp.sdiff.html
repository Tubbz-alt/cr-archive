<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
194   bool _relax_verify;
195 
196   bool _has_nonstatic_concrete_methods;
197   bool _declares_nonstatic_concrete_methods;
198   bool _has_final_method;
199   bool _has_contended_fields;
200 
201   bool _has_flattenable_fields;
202   bool _is_empty_value;
203   bool _is_naturally_atomic;
204   bool _is_declared_atomic;
205   bool _invalid_inline_super;   // if true, invalid super type for an inline type.
206   bool _invalid_identity_super; // if true, invalid super type for an identity type.
207 
208   // precomputed flags
209   bool _has_finalizer;
210   bool _has_empty_finalizer;
211   bool _has_vanilla_constructor;
212   int _max_bootstrap_specifier_index;  // detects BSS values
213 
<span class="line-removed">214   bool is_invalid_super_for_inline_type(const InstanceKlass* ik);</span>
<span class="line-removed">215 </span>
216   void parse_stream(const ClassFileStream* const stream, TRAPS);
217 
218   void post_process_parsed_stream(const ClassFileStream* const stream,
219                                   ConstantPool* cp,
220                                   TRAPS);
221 
222   void prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS);
223   void fix_unsafe_anonymous_class_name(TRAPS);
224 
225   void fill_instance_klass(InstanceKlass* ik, bool cf_changed_in_CFLH, TRAPS);
226   void set_klass(InstanceKlass* instance);
227 
228   void set_class_bad_constant_seen(short bad_constant);
229   short class_bad_constant_seen() { return  _bad_constant_seen; }
230   void set_class_synthetic_flag(bool x)        { _synthetic_flag = x; }
231   void set_class_sourcefile_index(u2 x)        { _sourcefile_index = x; }
232   void set_class_generic_signature_index(u2 x) { _generic_signature_index = x; }
233   void set_class_sde_buffer(const char* x, int len)  { _sde_buffer = x; _sde_length = len; }
234 
235   void create_combined_annotations(TRAPS);
</pre>
<hr />
<pre>
576 
577   const ClassFileStream* clone_stream() const;
578 
579   void set_klass_to_deallocate(InstanceKlass* klass);
580 
581   int static_field_size() const;
582   int total_oop_map_count() const;
583   jint layout_size() const;
584 
585   int vtable_size() const { return _vtable_size; }
586   int itable_size() const { return _itable_size; }
587 
588   u2 this_class_index() const { return _this_class_index; }
589 
590   bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }
591   bool is_interface() const { return _access_flags.is_interface(); }
592   bool is_value_type() const { return _access_flags.is_value_type(); }
593   bool is_value_capable_class() const;
594   bool has_flattenable_fields() const { return _has_flattenable_fields; }
595   bool invalid_inline_super() const { return _invalid_inline_super; }

596   bool invalid_identity_super() const { return _invalid_identity_super; }
<span class="line-modified">597   void set_invalid_inline_super(bool set_invalid_inline_super) {</span>
<span class="line-removed">598     _invalid_inline_super = set_invalid_inline_super;</span>
<span class="line-removed">599   }</span>
<span class="line-removed">600   void set_invalid_identity_super(bool set_invalid_identity_super) {</span>
<span class="line-removed">601     _invalid_identity_super = set_invalid_identity_super;</span>
<span class="line-removed">602   }</span>
603 
604   u2 java_fields_count() const { return _java_fields_count; }
605 
606   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
607   const GrowableArray&lt;Handle&gt;* cp_patches() const { return _cp_patches; }
608   ClassLoaderData* loader_data() const { return _loader_data; }
609   const Symbol* class_name() const { return _class_name; }
610   const InstanceKlass* super_klass() const { return _super_klass; }
611 
612   ReferenceType reference_type() const { return _rt; }
613   AccessFlags access_flags() const { return _access_flags; }
614 
615   bool is_internal() const { return INTERNAL == _pub_level; }
616 
617   static bool verify_unqualified_name(const char* name, unsigned int length, int type);
618 
619 #ifdef ASSERT
620   static bool is_internal_format(Symbol* class_name);
621 #endif
622 
</pre>
</td>
<td>
<hr />
<pre>
194   bool _relax_verify;
195 
196   bool _has_nonstatic_concrete_methods;
197   bool _declares_nonstatic_concrete_methods;
198   bool _has_final_method;
199   bool _has_contended_fields;
200 
201   bool _has_flattenable_fields;
202   bool _is_empty_value;
203   bool _is_naturally_atomic;
204   bool _is_declared_atomic;
205   bool _invalid_inline_super;   // if true, invalid super type for an inline type.
206   bool _invalid_identity_super; // if true, invalid super type for an identity type.
207 
208   // precomputed flags
209   bool _has_finalizer;
210   bool _has_empty_finalizer;
211   bool _has_vanilla_constructor;
212   int _max_bootstrap_specifier_index;  // detects BSS values
213 


214   void parse_stream(const ClassFileStream* const stream, TRAPS);
215 
216   void post_process_parsed_stream(const ClassFileStream* const stream,
217                                   ConstantPool* cp,
218                                   TRAPS);
219 
220   void prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS);
221   void fix_unsafe_anonymous_class_name(TRAPS);
222 
223   void fill_instance_klass(InstanceKlass* ik, bool cf_changed_in_CFLH, TRAPS);
224   void set_klass(InstanceKlass* instance);
225 
226   void set_class_bad_constant_seen(short bad_constant);
227   short class_bad_constant_seen() { return  _bad_constant_seen; }
228   void set_class_synthetic_flag(bool x)        { _synthetic_flag = x; }
229   void set_class_sourcefile_index(u2 x)        { _sourcefile_index = x; }
230   void set_class_generic_signature_index(u2 x) { _generic_signature_index = x; }
231   void set_class_sde_buffer(const char* x, int len)  { _sde_buffer = x; _sde_length = len; }
232 
233   void create_combined_annotations(TRAPS);
</pre>
<hr />
<pre>
574 
575   const ClassFileStream* clone_stream() const;
576 
577   void set_klass_to_deallocate(InstanceKlass* klass);
578 
579   int static_field_size() const;
580   int total_oop_map_count() const;
581   jint layout_size() const;
582 
583   int vtable_size() const { return _vtable_size; }
584   int itable_size() const { return _itable_size; }
585 
586   u2 this_class_index() const { return _this_class_index; }
587 
588   bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }
589   bool is_interface() const { return _access_flags.is_interface(); }
590   bool is_value_type() const { return _access_flags.is_value_type(); }
591   bool is_value_capable_class() const;
592   bool has_flattenable_fields() const { return _has_flattenable_fields; }
593   bool invalid_inline_super() const { return _invalid_inline_super; }
<span class="line-added">594   void set_invalid_inline_super() { _invalid_inline_super = true; }</span>
595   bool invalid_identity_super() const { return _invalid_identity_super; }
<span class="line-modified">596   void set_invalid_identity_super() { _invalid_identity_super = true; }</span>





597 
598   u2 java_fields_count() const { return _java_fields_count; }
599 
600   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
601   const GrowableArray&lt;Handle&gt;* cp_patches() const { return _cp_patches; }
602   ClassLoaderData* loader_data() const { return _loader_data; }
603   const Symbol* class_name() const { return _class_name; }
604   const InstanceKlass* super_klass() const { return _super_klass; }
605 
606   ReferenceType reference_type() const { return _rt; }
607   AccessFlags access_flags() const { return _access_flags; }
608 
609   bool is_internal() const { return INTERNAL == _pub_level; }
610 
611   static bool verify_unqualified_name(const char* name, unsigned int length, int type);
612 
613 #ifdef ASSERT
614   static bool is_internal_format(Symbol* class_name);
615 #endif
616 
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
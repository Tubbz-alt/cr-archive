diff a/src/hotspot/share/classfile/classFileParser.cpp b/src/hotspot/share/classfile/classFileParser.cpp
--- a/src/hotspot/share/classfile/classFileParser.cpp
+++ b/src/hotspot/share/classfile/classFileParser.cpp
@@ -1012,11 +1012,11 @@
           "Inline type %s attempts to implement interface java.lang.IdentityObject",
           _class_name->as_klass_external_name());
         return;
       }
       if (ik->invalid_inline_super()) {
-        set_invalid_inline_super(true);
+        set_invalid_inline_super();
       }
       if (ik->has_nonstatic_concrete_methods()) {
         *has_nonstatic_concrete_methods = true;
       }
       if (ik->is_declared_atomic()) {
@@ -6072,10 +6072,45 @@
   }
 
   return ik;
 }
 
+// Return true if the specified class is not a valid super class for an inline type.
+// A valid super class for an inline type is abstract, has no instance fields,
+// does not implement interface java.lang.IdentityObject (checked elsewhere), has
+// an empty body-less no-arg constructor, and no synchronized instance methods.
+// This function doesn't check if the class's super types are invalid.  Those checks
+// are done elsewhere.  The final determination of whether or not a class is an
+// invalid super type for an inline class is done in fill_instance_klass().
+static bool is_invalid_super_for_inline_type(const InstanceKlass* ik) {
+  if (ik->name() == vmSymbols::java_lang_IdentityObject()) {
+    return true;
+  }
+  if (ik->is_interface() || ik->name() == vmSymbols::java_lang_Object()) {
+    return false;
+  }
+  if (!ik->is_abstract() || ik->has_nonstatic_fields()) {
+    return true;
+  } else {
+    Array<Method*>* methods = ik->methods();
+    // Look at each method.
+    for (int x = 0; x < methods->length(); x++) {
+      const Method* const method = methods->at(x);
+      if (method->is_synchronized() && !method->is_static()) {
+        return true;
+
+      } else if (method->name() == vmSymbols::object_initializer_name()) {
+        if (method->signature() != vmSymbols::void_method_signature() ||
+            !method->is_vanilla_constructor()) {
+          return true;
+        }
+      }
+    }
+  }
+  return false;
+}
+
 void ClassFileParser::fill_instance_klass(InstanceKlass* ik, bool changed_by_loadhook, TRAPS) {
   assert(ik != NULL, "invariant");
 
   // Set name and CLD before adding to CLD
   ik->set_class_loader_data(_loader_data);
@@ -6340,11 +6375,11 @@
   // if super is marked invalid, or if is_invalid_super_for_inline_type()
   // returns true
   if (invalid_inline_super() ||
       (_super_klass != NULL && _super_klass->invalid_inline_super()) ||
       is_invalid_super_for_inline_type(ik)) {
-    ik->set_invalid_inline_super(true);
+    ik->set_invalid_inline_super();
   }
 
   JFR_ONLY(INIT_ID(ik);)
 
   // If we reach here, all is well.
@@ -6896,42 +6931,10 @@
                      CHECK);
 
   // all bytes in stream read and parsed
 }
 
-// Return true if the specified class is not a valid super class for an inline type.
-// A valid super class for an inline type is abstract, has no instance fields,
-// does not implement interface java.lang.IdentityObject (checked elsewhere), has
-// an empty body-less no-arg constructor, and no synchronized instance methods.
-bool ClassFileParser::is_invalid_super_for_inline_type(const InstanceKlass* ik) {
-  if (ik->name() == vmSymbols::java_lang_IdentityObject()) {
-    return true;
-  }
-  if (ik->is_interface() || ik->name() == vmSymbols::java_lang_Object()) {
-    return false;
-  }
-  if (!ik->is_abstract() || ik->has_nonstatic_fields()) {
-    return true;
-  } else {
-    Array<Method*>* methods = ik->methods();
-    // Look at each method.
-    for (int x = 0; x < methods->length(); x++) {
-      const Method* const method = methods->at(x);
-      if (method->is_synchronized() && !method->is_static()) {
-        return true;
-
-      } else if (method->name() == vmSymbols::object_initializer_name()) {
-        if (method->signature() != vmSymbols::void_method_signature() ||
-            !method->is_vanilla_constructor()) {
-          return true;
-        }
-      }
-    }
-  }
-  return false;
-}
-
 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
                                                  ConstantPool* cp,
                                                  TRAPS) {
   assert(stream != NULL, "invariant");
   assert(stream->at_eos(), "invariant");

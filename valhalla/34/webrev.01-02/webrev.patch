diff a/src/hotspot/share/classfile/classFileParser.cpp b/src/hotspot/share/classfile/classFileParser.cpp
--- a/src/hotspot/share/classfile/classFileParser.cpp
+++ b/src/hotspot/share/classfile/classFileParser.cpp
@@ -1012,11 +1012,11 @@
           "Inline type %s attempts to implement interface java.lang.IdentityObject",
           _class_name->as_klass_external_name());
         return;
       }
       if (ik->invalid_inline_super()) {
-        set_invalid_inline_super(true);
+        set_invalid_inline_super();
       }
       if (ik->has_nonstatic_concrete_methods()) {
         *has_nonstatic_concrete_methods = true;
       }
       if (ik->is_declared_atomic()) {
@@ -6072,10 +6072,45 @@
   }
 
   return ik;
 }
 
+// Return true if the specified class is not a valid super class for an inline type.
+// A valid super class for an inline type is abstract, has no instance fields,
+// does not implement interface java.lang.IdentityObject (checked elsewhere), has
+// an empty body-less no-arg constructor, and no synchronized instance methods.
+// This function doesn't check if the class's super types are invalid.  Those checks
+// are done elsewhere.  The final determination of whether or not a class is an
+// invalid super type for an inline class is done in fill_instance_klass().
+static bool is_invalid_super_for_inline_type(const InstanceKlass* ik) {
+  if (ik->name() == vmSymbols::java_lang_IdentityObject()) {
+    return true;
+  }
+  if (ik->is_interface() || ik->name() == vmSymbols::java_lang_Object()) {
+    return false;
+  }
+  if (!ik->is_abstract() || ik->has_nonstatic_fields()) {
+    return true;
+  } else {
+    Array<Method*>* methods = ik->methods();
+    // Look at each method.
+    for (int x = 0; x < methods->length(); x++) {
+      const Method* const method = methods->at(x);
+      if (method->is_synchronized() && !method->is_static()) {
+        return true;
+
+      } else if (method->name() == vmSymbols::object_initializer_name()) {
+        if (method->signature() != vmSymbols::void_method_signature() ||
+            !method->is_vanilla_constructor()) {
+          return true;
+        }
+      }
+    }
+  }
+  return false;
+}
+
 void ClassFileParser::fill_instance_klass(InstanceKlass* ik, bool changed_by_loadhook, TRAPS) {
   assert(ik != NULL, "invariant");
 
   // Set name and CLD before adding to CLD
   ik->set_class_loader_data(_loader_data);
@@ -6340,11 +6375,11 @@
   // if super is marked invalid, or if is_invalid_super_for_inline_type()
   // returns true
   if (invalid_inline_super() ||
       (_super_klass != NULL && _super_klass->invalid_inline_super()) ||
       is_invalid_super_for_inline_type(ik)) {
-    ik->set_invalid_inline_super(true);
+    ik->set_invalid_inline_super();
   }
 
   JFR_ONLY(INIT_ID(ik);)
 
   // If we reach here, all is well.
@@ -6896,42 +6931,10 @@
                      CHECK);
 
   // all bytes in stream read and parsed
 }
 
-// Return true if the specified class is not a valid super class for an inline type.
-// A valid super class for an inline type is abstract, has no instance fields,
-// does not implement interface java.lang.IdentityObject (checked elsewhere), has
-// an empty body-less no-arg constructor, and no synchronized instance methods.
-bool ClassFileParser::is_invalid_super_for_inline_type(const InstanceKlass* ik) {
-  if (ik->name() == vmSymbols::java_lang_IdentityObject()) {
-    return true;
-  }
-  if (ik->is_interface() || ik->name() == vmSymbols::java_lang_Object()) {
-    return false;
-  }
-  if (!ik->is_abstract() || ik->has_nonstatic_fields()) {
-    return true;
-  } else {
-    Array<Method*>* methods = ik->methods();
-    // Look at each method.
-    for (int x = 0; x < methods->length(); x++) {
-      const Method* const method = methods->at(x);
-      if (method->is_synchronized() && !method->is_static()) {
-        return true;
-
-      } else if (method->name() == vmSymbols::object_initializer_name()) {
-        if (method->signature() != vmSymbols::void_method_signature() ||
-            !method->is_vanilla_constructor()) {
-          return true;
-        }
-      }
-    }
-  }
-  return false;
-}
-
 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
                                                  ConstantPool* cp,
                                                  TRAPS) {
   assert(stream != NULL, "invariant");
   assert(stream->at_eos(), "invariant");
diff a/src/hotspot/share/classfile/classFileParser.hpp b/src/hotspot/share/classfile/classFileParser.hpp
--- a/src/hotspot/share/classfile/classFileParser.hpp
+++ b/src/hotspot/share/classfile/classFileParser.hpp
@@ -209,12 +209,10 @@
   bool _has_finalizer;
   bool _has_empty_finalizer;
   bool _has_vanilla_constructor;
   int _max_bootstrap_specifier_index;  // detects BSS values
 
-  bool is_invalid_super_for_inline_type(const InstanceKlass* ik);
-
   void parse_stream(const ClassFileStream* const stream, TRAPS);
 
   void post_process_parsed_stream(const ClassFileStream* const stream,
                                   ConstantPool* cp,
                                   TRAPS);
@@ -591,17 +589,13 @@
   bool is_interface() const { return _access_flags.is_interface(); }
   bool is_value_type() const { return _access_flags.is_value_type(); }
   bool is_value_capable_class() const;
   bool has_flattenable_fields() const { return _has_flattenable_fields; }
   bool invalid_inline_super() const { return _invalid_inline_super; }
+  void set_invalid_inline_super() { _invalid_inline_super = true; }
   bool invalid_identity_super() const { return _invalid_identity_super; }
-  void set_invalid_inline_super(bool set_invalid_inline_super) {
-    _invalid_inline_super = set_invalid_inline_super;
-  }
-  void set_invalid_identity_super(bool set_invalid_identity_super) {
-    _invalid_identity_super = set_invalid_identity_super;
-  }
+  void set_invalid_identity_super() { _invalid_identity_super = true; }
 
   u2 java_fields_count() const { return _java_fields_count; }
 
   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
   const GrowableArray<Handle>* cp_patches() const { return _cp_patches; }
diff a/src/hotspot/share/oops/instanceKlass.hpp b/src/hotspot/share/oops/instanceKlass.hpp
--- a/src/hotspot/share/oops/instanceKlass.hpp
+++ b/src/hotspot/share/oops/instanceKlass.hpp
@@ -256,13 +256,10 @@
   int             _itable_len;           // length of Java itable (in words)
   // _is_marked_dependent can be set concurrently, thus cannot be part of the
   // _misc_flags.
   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
 
-  bool _invalid_inline_super;   // if true, invalid super type for an inline type.
-  bool _invalid_identity_super; // if true, invalid super type for an identity type.
-
   // The low three bits of _misc_flags contains the kind field.
   // This can be used to quickly discriminate among the five kinds of
   // InstanceKlass.
 
   static const unsigned _misc_kind_field_size = 3;
@@ -295,11 +292,13 @@
     _misc_is_being_redefined                  = 1 << 17, // used for locking redefinition
     _misc_has_contended_annotations           = 1 << 18, // has @Contended annotation
     _misc_has_value_fields                    = 1 << 19, // has value fields and related embedded section is not empty
     _misc_is_empty_value                      = 1 << 20, // empty value type
     _misc_is_naturally_atomic                 = 1 << 21, // loaded/stored in one instruction
-    _misc_is_declared_atomic                  = 1 << 22  // implements jl.NonTearable
+    _misc_is_declared_atomic                  = 1 << 22, // implements jl.NonTearable
+    _misc_invalid_inline_super                = 1 << 23, // invalid super type for an inline type
+    _misc_invalid_identity_super              = 1 << 24  // invalid super type for an identity type
   };
   u2 shared_loader_type_bits() const {
     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
   }
   u4              _misc_flags;
@@ -463,10 +462,27 @@
   // Initialized in the class file parser, not changed later.
   void set_is_declared_atomic() {
     _misc_flags |= _misc_is_declared_atomic;
   }
 
+  // Query if class is an invalid super class for an inline type.
+  bool invalid_inline_super() const {
+    return (_misc_flags & _misc_invalid_inline_super) != 0;
+  }
+  // Initialized in the class file parser, not changed later.
+  void set_invalid_inline_super() {
+    _misc_flags |= _misc_invalid_inline_super;
+  }
+  // Query if class is an invalid super class for an identity type.
+  bool invalid_identity_super() const {
+    return (_misc_flags & _misc_invalid_identity_super) != 0;
+  }
+  // Initialized in the class file parser, not changed later.
+  void set_invalid_identity_super() {
+    _misc_flags |= _misc_invalid_identity_super;
+  }
+
   // field sizes
   int nonstatic_field_size() const         { return _nonstatic_field_size; }
   void set_nonstatic_field_size(int size)  { _nonstatic_field_size = size; }
 
   int static_field_size() const            { return _static_field_size; }
@@ -634,19 +650,10 @@
 
   // marking
   bool is_marked_dependent() const         { return _is_marked_dependent; }
   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 
-  bool invalid_inline_super() const { return _invalid_inline_super; }
-  void set_invalid_inline_super(bool set_invalid_inline_super) {
-    _invalid_inline_super = set_invalid_inline_super;
-  }
-  bool invalid_identity_super() const { return _invalid_identity_super; }
-  void set_invalid_identity_super(bool set_invalid_identity_super) {
-    _invalid_identity_super = set_invalid_identity_super;
-  }
-
   static ByteSize misc_flags_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_flags)); }
   static u4 misc_flags_is_empty_value() { return _misc_is_empty_value; }
 
   // initialization (virtuals from Klass)
   bool should_be_initialized() const;  // means that initialize should be called
diff a/src/hotspot/share/runtime/vmStructs.cpp b/src/hotspot/share/runtime/vmStructs.cpp
--- a/src/hotspot/share/runtime/vmStructs.cpp
+++ b/src/hotspot/share/runtime/vmStructs.cpp
@@ -228,12 +228,10 @@
   nonstatic_field(InstanceKlass,               _nonstatic_field_size,                         int)                                   \
   nonstatic_field(InstanceKlass,               _static_field_size,                            int)                                   \
   nonstatic_field(InstanceKlass,               _static_oop_field_count,                       u2)                                    \
   nonstatic_field(InstanceKlass,               _nonstatic_oop_map_size,                       int)                                   \
   nonstatic_field(InstanceKlass,               _is_marked_dependent,                          bool)                                  \
-  nonstatic_field(InstanceKlass,               _invalid_inline_super,                         bool)                                  \
-  nonstatic_field(InstanceKlass,               _invalid_identity_super,                       bool)                                  \
   nonstatic_field(InstanceKlass,               _misc_flags,                                   u4)                                    \
   nonstatic_field(InstanceKlass,               _minor_version,                                u2)                                    \
   nonstatic_field(InstanceKlass,               _major_version,                                u2)                                    \
   nonstatic_field(InstanceKlass,               _init_state,                                   u1)                                    \
   nonstatic_field(InstanceKlass,               _init_thread,                                  Thread*)                               \
@@ -2300,10 +2298,12 @@
   declare_constant(InstanceKlass::_misc_has_passed_fingerprint_check)     \
   declare_constant(InstanceKlass::_misc_is_scratch_class)                 \
   declare_constant(InstanceKlass::_misc_is_shared_boot_class)             \
   declare_constant(InstanceKlass::_misc_is_shared_platform_class)         \
   declare_constant(InstanceKlass::_misc_is_shared_app_class)              \
+  declare_constant(InstanceKlass::_misc_invalid_inline_super)             \
+  declare_constant(InstanceKlass::_misc_invalid_identity_super)           \
                                                                           \
   /*********************************/                                     \
   /* Symbol* - symbol max length */                                       \
   /*********************************/                                     \
                                                                           \

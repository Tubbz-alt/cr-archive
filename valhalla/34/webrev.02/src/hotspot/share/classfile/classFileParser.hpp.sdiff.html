<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
185 
186   u2 _major_version;
187   u2 _minor_version;
188   u2 _this_class_index;
189   u2 _super_class_index;
190   u2 _itfs_len;
191   u2 _java_fields_count;
192 
193   bool _need_verify;
194   bool _relax_verify;
195 
196   bool _has_nonstatic_concrete_methods;
197   bool _declares_nonstatic_concrete_methods;
198   bool _has_final_method;
199   bool _has_contended_fields;
200 
201   bool _has_flattenable_fields;
202   bool _is_empty_value;
203   bool _is_naturally_atomic;
204   bool _is_declared_atomic;


205 
206   // precomputed flags
207   bool _has_finalizer;
208   bool _has_empty_finalizer;
209   bool _has_vanilla_constructor;
210   int _max_bootstrap_specifier_index;  // detects BSS values
211 
212   void parse_stream(const ClassFileStream* const stream, TRAPS);
213 
214   void post_process_parsed_stream(const ClassFileStream* const stream,
215                                   ConstantPool* cp,
216                                   TRAPS);
217 
218   void prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS);
219   void fix_unsafe_anonymous_class_name(TRAPS);
220 
221   void fill_instance_klass(InstanceKlass* ik, bool cf_changed_in_CFLH, TRAPS);
222   void set_klass(InstanceKlass* instance);
223 
224   void set_class_bad_constant_seen(short bad_constant);
</pre>
<hr />
<pre>
231   void create_combined_annotations(TRAPS);
232   void apply_parsed_class_attributes(InstanceKlass* k);  // update k
233   void apply_parsed_class_metadata(InstanceKlass* k, int fields_count, TRAPS);
234   void clear_class_metadata();
235 
236   // Constant pool parsing
237   void parse_constant_pool_entries(const ClassFileStream* const stream,
238                                    ConstantPool* cp,
239                                    const int length,
240                                    TRAPS);
241 
242   void parse_constant_pool(const ClassFileStream* const cfs,
243                            ConstantPool* const cp,
244                            const int length,
245                            TRAPS);
246 
247   // Interface parsing
248   void parse_interfaces(const ClassFileStream* const stream,
249                         const int itfs_len,
250                         ConstantPool* const cp,

251                         bool* has_nonstatic_concrete_methods,
252                         bool* is_declared_atomic,
253                         TRAPS);
254 
255   const InstanceKlass* parse_super_class(ConstantPool* const cp,
256                                          const int super_class_index,
257                                          const bool need_verify,
258                                          TRAPS);
259 
260   // Field parsing
261   void parse_field_attributes(const ClassFileStream* const cfs,
262                               u2 attributes_count,
263                               bool is_static,
264                               u2 signature_index,
265                               u2* const constantvalue_index_addr,
266                               bool* const is_synthetic_addr,
267                               u2* const generic_signature_index_addr,
268                               FieldAnnotationCollector* parsed_annotations,
269                               TRAPS);
270 
</pre>
<hr />
<pre>
570   InstanceKlass* create_instance_klass(bool cf_changed_in_CFLH, TRAPS);
571 
572   const ClassFileStream* clone_stream() const;
573 
574   void set_klass_to_deallocate(InstanceKlass* klass);
575 
576   int static_field_size() const;
577   int total_oop_map_count() const;
578   jint layout_size() const;
579 
580   int vtable_size() const { return _vtable_size; }
581   int itable_size() const { return _itable_size; }
582 
583   u2 this_class_index() const { return _this_class_index; }
584 
585   bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }
586   bool is_interface() const { return _access_flags.is_interface(); }
587   bool is_value_type() const { return _access_flags.is_value_type(); }
588   bool is_value_capable_class() const;
589   bool has_flattenable_fields() const { return _has_flattenable_fields; }




590 
591   u2 java_fields_count() const { return _java_fields_count; }
592 
593   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
594   const GrowableArray&lt;Handle&gt;* cp_patches() const { return _cp_patches; }
595   ClassLoaderData* loader_data() const { return _loader_data; }
596   const Symbol* class_name() const { return _class_name; }
597   const InstanceKlass* super_klass() const { return _super_klass; }
598 
599   ReferenceType reference_type() const { return _rt; }
600   AccessFlags access_flags() const { return _access_flags; }
601 
602   bool is_internal() const { return INTERNAL == _pub_level; }
603 
604   static bool verify_unqualified_name(const char* name, unsigned int length, int type);
605 
606 #ifdef ASSERT
607   static bool is_internal_format(Symbol* class_name);
608 #endif
609 
</pre>
</td>
<td>
<hr />
<pre>
185 
186   u2 _major_version;
187   u2 _minor_version;
188   u2 _this_class_index;
189   u2 _super_class_index;
190   u2 _itfs_len;
191   u2 _java_fields_count;
192 
193   bool _need_verify;
194   bool _relax_verify;
195 
196   bool _has_nonstatic_concrete_methods;
197   bool _declares_nonstatic_concrete_methods;
198   bool _has_final_method;
199   bool _has_contended_fields;
200 
201   bool _has_flattenable_fields;
202   bool _is_empty_value;
203   bool _is_naturally_atomic;
204   bool _is_declared_atomic;
<span class="line-added">205   bool _invalid_inline_super;   // if true, invalid super type for an inline type.</span>
<span class="line-added">206   bool _invalid_identity_super; // if true, invalid super type for an identity type.</span>
207 
208   // precomputed flags
209   bool _has_finalizer;
210   bool _has_empty_finalizer;
211   bool _has_vanilla_constructor;
212   int _max_bootstrap_specifier_index;  // detects BSS values
213 
214   void parse_stream(const ClassFileStream* const stream, TRAPS);
215 
216   void post_process_parsed_stream(const ClassFileStream* const stream,
217                                   ConstantPool* cp,
218                                   TRAPS);
219 
220   void prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS);
221   void fix_unsafe_anonymous_class_name(TRAPS);
222 
223   void fill_instance_klass(InstanceKlass* ik, bool cf_changed_in_CFLH, TRAPS);
224   void set_klass(InstanceKlass* instance);
225 
226   void set_class_bad_constant_seen(short bad_constant);
</pre>
<hr />
<pre>
233   void create_combined_annotations(TRAPS);
234   void apply_parsed_class_attributes(InstanceKlass* k);  // update k
235   void apply_parsed_class_metadata(InstanceKlass* k, int fields_count, TRAPS);
236   void clear_class_metadata();
237 
238   // Constant pool parsing
239   void parse_constant_pool_entries(const ClassFileStream* const stream,
240                                    ConstantPool* cp,
241                                    const int length,
242                                    TRAPS);
243 
244   void parse_constant_pool(const ClassFileStream* const cfs,
245                            ConstantPool* const cp,
246                            const int length,
247                            TRAPS);
248 
249   // Interface parsing
250   void parse_interfaces(const ClassFileStream* const stream,
251                         const int itfs_len,
252                         ConstantPool* const cp,
<span class="line-added">253                         bool is_inline_type,</span>
254                         bool* has_nonstatic_concrete_methods,
255                         bool* is_declared_atomic,
256                         TRAPS);
257 
258   const InstanceKlass* parse_super_class(ConstantPool* const cp,
259                                          const int super_class_index,
260                                          const bool need_verify,
261                                          TRAPS);
262 
263   // Field parsing
264   void parse_field_attributes(const ClassFileStream* const cfs,
265                               u2 attributes_count,
266                               bool is_static,
267                               u2 signature_index,
268                               u2* const constantvalue_index_addr,
269                               bool* const is_synthetic_addr,
270                               u2* const generic_signature_index_addr,
271                               FieldAnnotationCollector* parsed_annotations,
272                               TRAPS);
273 
</pre>
<hr />
<pre>
573   InstanceKlass* create_instance_klass(bool cf_changed_in_CFLH, TRAPS);
574 
575   const ClassFileStream* clone_stream() const;
576 
577   void set_klass_to_deallocate(InstanceKlass* klass);
578 
579   int static_field_size() const;
580   int total_oop_map_count() const;
581   jint layout_size() const;
582 
583   int vtable_size() const { return _vtable_size; }
584   int itable_size() const { return _itable_size; }
585 
586   u2 this_class_index() const { return _this_class_index; }
587 
588   bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }
589   bool is_interface() const { return _access_flags.is_interface(); }
590   bool is_value_type() const { return _access_flags.is_value_type(); }
591   bool is_value_capable_class() const;
592   bool has_flattenable_fields() const { return _has_flattenable_fields; }
<span class="line-added">593   bool invalid_inline_super() const { return _invalid_inline_super; }</span>
<span class="line-added">594   void set_invalid_inline_super() { _invalid_inline_super = true; }</span>
<span class="line-added">595   bool invalid_identity_super() const { return _invalid_identity_super; }</span>
<span class="line-added">596   void set_invalid_identity_super() { _invalid_identity_super = true; }</span>
597 
598   u2 java_fields_count() const { return _java_fields_count; }
599 
600   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
601   const GrowableArray&lt;Handle&gt;* cp_patches() const { return _cp_patches; }
602   ClassLoaderData* loader_data() const { return _loader_data; }
603   const Symbol* class_name() const { return _class_name; }
604   const InstanceKlass* super_klass() const { return _super_klass; }
605 
606   ReferenceType reference_type() const { return _rt; }
607   AccessFlags access_flags() const { return _access_flags; }
608 
609   bool is_internal() const { return INTERNAL == _pub_level; }
610 
611   static bool verify_unqualified_name(const char* name, unsigned int length, int type);
612 
613 #ifdef ASSERT
614   static bool is_internal_format(Symbol* class_name);
615 #endif
616 
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
185 
186   u2 _major_version;
187   u2 _minor_version;
188   u2 _this_class_index;
189   u2 _super_class_index;
190   u2 _itfs_len;
191   u2 _java_fields_count;
192 
193   bool _need_verify;
194   bool _relax_verify;
195 
196   bool _has_nonstatic_concrete_methods;
197   bool _declares_nonstatic_concrete_methods;
198   bool _has_final_method;
199   bool _has_contended_fields;
200 
201   bool _has_flattenable_fields;
202   bool _is_empty_value;
203   bool _is_naturally_atomic;
204   bool _is_declared_atomic;


205 
206   // precomputed flags
207   bool _has_finalizer;
208   bool _has_empty_finalizer;
209   bool _has_vanilla_constructor;
210   int _max_bootstrap_specifier_index;  // detects BSS values
211 


212   void parse_stream(const ClassFileStream* const stream, TRAPS);
213 
214   void post_process_parsed_stream(const ClassFileStream* const stream,
215                                   ConstantPool* cp,
216                                   TRAPS);
217 
218   void prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS);
219   void fix_unsafe_anonymous_class_name(TRAPS);
220 
221   void fill_instance_klass(InstanceKlass* ik, bool cf_changed_in_CFLH, TRAPS);
222   void set_klass(InstanceKlass* instance);
223 
224   void set_class_bad_constant_seen(short bad_constant);
225   short class_bad_constant_seen() { return  _bad_constant_seen; }
226   void set_class_synthetic_flag(bool x)        { _synthetic_flag = x; }
227   void set_class_sourcefile_index(u2 x)        { _sourcefile_index = x; }
228   void set_class_generic_signature_index(u2 x) { _generic_signature_index = x; }
229   void set_class_sde_buffer(const char* x, int len)  { _sde_buffer = x; _sde_length = len; }
230 
231   void create_combined_annotations(TRAPS);
232   void apply_parsed_class_attributes(InstanceKlass* k);  // update k
233   void apply_parsed_class_metadata(InstanceKlass* k, int fields_count, TRAPS);
234   void clear_class_metadata();
235 
236   // Constant pool parsing
237   void parse_constant_pool_entries(const ClassFileStream* const stream,
238                                    ConstantPool* cp,
239                                    const int length,
240                                    TRAPS);
241 
242   void parse_constant_pool(const ClassFileStream* const cfs,
243                            ConstantPool* const cp,
244                            const int length,
245                            TRAPS);
246 
247   // Interface parsing
248   void parse_interfaces(const ClassFileStream* const stream,
249                         const int itfs_len,
250                         ConstantPool* const cp,

251                         bool* has_nonstatic_concrete_methods,
252                         bool* is_declared_atomic,
253                         TRAPS);
254 
255   const InstanceKlass* parse_super_class(ConstantPool* const cp,
256                                          const int super_class_index,
257                                          const bool need_verify,
258                                          TRAPS);
259 
260   // Field parsing
261   void parse_field_attributes(const ClassFileStream* const cfs,
262                               u2 attributes_count,
263                               bool is_static,
264                               u2 signature_index,
265                               u2* const constantvalue_index_addr,
266                               bool* const is_synthetic_addr,
267                               u2* const generic_signature_index_addr,
268                               FieldAnnotationCollector* parsed_annotations,
269                               TRAPS);
270 
</pre>
<hr />
<pre>
570   InstanceKlass* create_instance_klass(bool cf_changed_in_CFLH, TRAPS);
571 
572   const ClassFileStream* clone_stream() const;
573 
574   void set_klass_to_deallocate(InstanceKlass* klass);
575 
576   int static_field_size() const;
577   int total_oop_map_count() const;
578   jint layout_size() const;
579 
580   int vtable_size() const { return _vtable_size; }
581   int itable_size() const { return _itable_size; }
582 
583   u2 this_class_index() const { return _this_class_index; }
584 
585   bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }
586   bool is_interface() const { return _access_flags.is_interface(); }
587   bool is_value_type() const { return _access_flags.is_value_type(); }
588   bool is_value_capable_class() const;
589   bool has_flattenable_fields() const { return _has_flattenable_fields; }








590 
591   u2 java_fields_count() const { return _java_fields_count; }
592 
593   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
594   const GrowableArray&lt;Handle&gt;* cp_patches() const { return _cp_patches; }
595   ClassLoaderData* loader_data() const { return _loader_data; }
596   const Symbol* class_name() const { return _class_name; }
597   const InstanceKlass* super_klass() const { return _super_klass; }
598 
599   ReferenceType reference_type() const { return _rt; }
600   AccessFlags access_flags() const { return _access_flags; }
601 
602   bool is_internal() const { return INTERNAL == _pub_level; }
603 
604   static bool verify_unqualified_name(const char* name, unsigned int length, int type);
605 
606 #ifdef ASSERT
607   static bool is_internal_format(Symbol* class_name);
608 #endif
609 
</pre>
</td>
<td>
<hr />
<pre>
185 
186   u2 _major_version;
187   u2 _minor_version;
188   u2 _this_class_index;
189   u2 _super_class_index;
190   u2 _itfs_len;
191   u2 _java_fields_count;
192 
193   bool _need_verify;
194   bool _relax_verify;
195 
196   bool _has_nonstatic_concrete_methods;
197   bool _declares_nonstatic_concrete_methods;
198   bool _has_final_method;
199   bool _has_contended_fields;
200 
201   bool _has_flattenable_fields;
202   bool _is_empty_value;
203   bool _is_naturally_atomic;
204   bool _is_declared_atomic;
<span class="line-added">205   bool _invalid_inline_super;   // if true, invalid super type for an inline type.</span>
<span class="line-added">206   bool _invalid_identity_super; // if true, invalid super type for an identity type.</span>
207 
208   // precomputed flags
209   bool _has_finalizer;
210   bool _has_empty_finalizer;
211   bool _has_vanilla_constructor;
212   int _max_bootstrap_specifier_index;  // detects BSS values
213 
<span class="line-added">214   bool is_invalid_super_for_inline_type(const InstanceKlass* ik);</span>
<span class="line-added">215 </span>
216   void parse_stream(const ClassFileStream* const stream, TRAPS);
217 
218   void post_process_parsed_stream(const ClassFileStream* const stream,
219                                   ConstantPool* cp,
220                                   TRAPS);
221 
222   void prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS);
223   void fix_unsafe_anonymous_class_name(TRAPS);
224 
225   void fill_instance_klass(InstanceKlass* ik, bool cf_changed_in_CFLH, TRAPS);
226   void set_klass(InstanceKlass* instance);
227 
228   void set_class_bad_constant_seen(short bad_constant);
229   short class_bad_constant_seen() { return  _bad_constant_seen; }
230   void set_class_synthetic_flag(bool x)        { _synthetic_flag = x; }
231   void set_class_sourcefile_index(u2 x)        { _sourcefile_index = x; }
232   void set_class_generic_signature_index(u2 x) { _generic_signature_index = x; }
233   void set_class_sde_buffer(const char* x, int len)  { _sde_buffer = x; _sde_length = len; }
234 
235   void create_combined_annotations(TRAPS);
236   void apply_parsed_class_attributes(InstanceKlass* k);  // update k
237   void apply_parsed_class_metadata(InstanceKlass* k, int fields_count, TRAPS);
238   void clear_class_metadata();
239 
240   // Constant pool parsing
241   void parse_constant_pool_entries(const ClassFileStream* const stream,
242                                    ConstantPool* cp,
243                                    const int length,
244                                    TRAPS);
245 
246   void parse_constant_pool(const ClassFileStream* const cfs,
247                            ConstantPool* const cp,
248                            const int length,
249                            TRAPS);
250 
251   // Interface parsing
252   void parse_interfaces(const ClassFileStream* const stream,
253                         const int itfs_len,
254                         ConstantPool* const cp,
<span class="line-added">255                         bool is_inline_type,</span>
256                         bool* has_nonstatic_concrete_methods,
257                         bool* is_declared_atomic,
258                         TRAPS);
259 
260   const InstanceKlass* parse_super_class(ConstantPool* const cp,
261                                          const int super_class_index,
262                                          const bool need_verify,
263                                          TRAPS);
264 
265   // Field parsing
266   void parse_field_attributes(const ClassFileStream* const cfs,
267                               u2 attributes_count,
268                               bool is_static,
269                               u2 signature_index,
270                               u2* const constantvalue_index_addr,
271                               bool* const is_synthetic_addr,
272                               u2* const generic_signature_index_addr,
273                               FieldAnnotationCollector* parsed_annotations,
274                               TRAPS);
275 
</pre>
<hr />
<pre>
575   InstanceKlass* create_instance_klass(bool cf_changed_in_CFLH, TRAPS);
576 
577   const ClassFileStream* clone_stream() const;
578 
579   void set_klass_to_deallocate(InstanceKlass* klass);
580 
581   int static_field_size() const;
582   int total_oop_map_count() const;
583   jint layout_size() const;
584 
585   int vtable_size() const { return _vtable_size; }
586   int itable_size() const { return _itable_size; }
587 
588   u2 this_class_index() const { return _this_class_index; }
589 
590   bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }
591   bool is_interface() const { return _access_flags.is_interface(); }
592   bool is_value_type() const { return _access_flags.is_value_type(); }
593   bool is_value_capable_class() const;
594   bool has_flattenable_fields() const { return _has_flattenable_fields; }
<span class="line-added">595   bool invalid_inline_super() const { return _invalid_inline_super; }</span>
<span class="line-added">596   bool invalid_identity_super() const { return _invalid_identity_super; }</span>
<span class="line-added">597   void set_invalid_inline_super(bool set_invalid_inline_super) {</span>
<span class="line-added">598     _invalid_inline_super = set_invalid_inline_super;</span>
<span class="line-added">599   }</span>
<span class="line-added">600   void set_invalid_identity_super(bool set_invalid_identity_super) {</span>
<span class="line-added">601     _invalid_identity_super = set_invalid_identity_super;</span>
<span class="line-added">602   }</span>
603 
604   u2 java_fields_count() const { return _java_fields_count; }
605 
606   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
607   const GrowableArray&lt;Handle&gt;* cp_patches() const { return _cp_patches; }
608   ClassLoaderData* loader_data() const { return _loader_data; }
609   const Symbol* class_name() const { return _class_name; }
610   const InstanceKlass* super_klass() const { return _super_klass; }
611 
612   ReferenceType reference_type() const { return _rt; }
613   AccessFlags access_flags() const { return _access_flags; }
614 
615   bool is_internal() const { return INTERNAL == _pub_level; }
616 
617   static bool verify_unqualified_name(const char* name, unsigned int length, int type);
618 
619 #ifdef ASSERT
620   static bool is_internal_format(Symbol* class_name);
621 #endif
622 
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
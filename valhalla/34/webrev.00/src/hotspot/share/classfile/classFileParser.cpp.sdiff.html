<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
6857   }
6858 
6859   // Additional attributes/annotations
6860   _parsed_annotations = new ClassAnnotationCollector();
6861   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6862 
6863   assert(_inner_classes != NULL, &quot;invariant&quot;);
6864 
6865   // Finalize the Annotations metadata object,
6866   // now that all annotation arrays have been created.
6867   create_combined_annotations(CHECK);
6868 
6869   // Make sure this is the end of class file stream
6870   guarantee_property(stream-&gt;at_eos(),
6871                      &quot;Extra bytes at the end of class file %s&quot;,
6872                      CHECK);
6873 
6874   // all bytes in stream read and parsed
6875 }
6876 












































6877 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6878                                                  ConstantPool* cp,
6879                                                  TRAPS) {
6880   assert(stream != NULL, &quot;invariant&quot;);
6881   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6882   assert(cp != NULL, &quot;invariant&quot;);
6883   assert(_loader_data != NULL, &quot;invariant&quot;);
6884 
6885   if (_class_name == vmSymbols::java_lang_Object()) {
6886     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),
6887                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,
6888                    CHECK);
6889   }
6890   // We check super class after class file is parsed and format is checked
6891   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6892     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
6893     if (is_interface()) {
6894       // Before attempting to resolve the superclass, check for class format
6895       // errors not checked yet.
6896       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
</pre>
<hr />
<pre>
6913     }
6914     if (_super_klass-&gt;is_declared_atomic()) {
6915       _is_declared_atomic = true;
6916     }
6917 
6918     if (_super_klass-&gt;is_interface()) {
6919       ResourceMark rm(THREAD);
6920       Exceptions::fthrow(
6921         THREAD_AND_LOCATION,
6922         vmSymbols::java_lang_IncompatibleClassChangeError(),
6923         &quot;class %s has interface %s as super class&quot;,
6924         _class_name-&gt;as_klass_external_name(),
6925         _super_klass-&gt;external_name()
6926       );
6927       return;
6928     }
6929 
6930     // For an inline class, only java/lang/Object or special abstract classes
6931     // are acceptable super classes.
6932     if (_access_flags.get_flags() &amp; JVM_ACC_VALUE) {
<span class="line-modified">6933       if (_super_klass-&gt;name() != vmSymbols::java_lang_Object()) {</span>
<span class="line-modified">6934         guarantee_property(_super_klass-&gt;is_abstract(),</span>
<span class="line-modified">6935           &quot;Inline type must have java.lang.Object or an abstract class as its superclass, class file %s&quot;,</span>
<span class="line-modified">6936           CHECK);</span>

6937       }
6938     }
6939 
6940     // Make sure super class is not final
6941     if (_super_klass-&gt;is_final()) {
6942       THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
6943     }
6944   }
6945 
6946   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {
6947     // This is the original source of this condition.
6948     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.
6949     _is_declared_atomic = true;
6950   } else if (*ForceNonTearable != &#39;\0&#39;) {
6951     // Allow a command line switch to force the same atomicity property:
6952     const char* class_name_str = _class_name-&gt;as_C_string();
6953     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {
6954       _is_declared_atomic = true;
6955     }
6956   }
</pre>
</td>
<td>
<hr />
<pre>
6857   }
6858 
6859   // Additional attributes/annotations
6860   _parsed_annotations = new ClassAnnotationCollector();
6861   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6862 
6863   assert(_inner_classes != NULL, &quot;invariant&quot;);
6864 
6865   // Finalize the Annotations metadata object,
6866   // now that all annotation arrays have been created.
6867   create_combined_annotations(CHECK);
6868 
6869   // Make sure this is the end of class file stream
6870   guarantee_property(stream-&gt;at_eos(),
6871                      &quot;Extra bytes at the end of class file %s&quot;,
6872                      CHECK);
6873 
6874   // all bytes in stream read and parsed
6875 }
6876 
<span class="line-added">6877 // Check that super class of an inline type is abstract, has no instance fields,</span>
<span class="line-added">6878 // has an empty body-less no-arg constructor, and no synchronized instance methods.</span>
<span class="line-added">6879 // Otherwise, throw ICCE.</span>
<span class="line-added">6880 void ClassFileParser::check_super_of_inline_type(const InstanceKlass* super_klass, TRAPS) {</span>
<span class="line-added">6881   const char* icce_msg = NULL;</span>
<span class="line-added">6882 </span>
<span class="line-added">6883   if (!super_klass-&gt;is_abstract()) {</span>
<span class="line-added">6884     icce_msg = &quot;that is not abstract&quot;;</span>
<span class="line-added">6885 </span>
<span class="line-added">6886   } else if (super_klass-&gt;has_nonstatic_fields()) {</span>
<span class="line-added">6887     icce_msg = &quot;containing instance fields&quot;;</span>
<span class="line-added">6888 </span>
<span class="line-added">6889   } else {</span>
<span class="line-added">6890     Array&lt;Method*&gt;* methods = super_klass-&gt;methods();</span>
<span class="line-added">6891     // Look at each method.</span>
<span class="line-added">6892     for (int x = 0; x &lt; methods-&gt;length(); x++) {</span>
<span class="line-added">6893       const Method* const method = methods-&gt;at(x);</span>
<span class="line-added">6894       if (method-&gt;is_synchronized() &amp;&amp; !method-&gt;is_static()) {</span>
<span class="line-added">6895         icce_msg = &quot;containing a synchronized instance method&quot;;</span>
<span class="line-added">6896         break;</span>
<span class="line-added">6897 </span>
<span class="line-added">6898       } else if (method-&gt;name() == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">6899         if (method-&gt;signature() != vmSymbols::void_method_signature()) {</span>
<span class="line-added">6900           icce_msg = &quot;containing a constructor with a non-void signature&quot;;</span>
<span class="line-added">6901           break;</span>
<span class="line-added">6902         } else if (!method-&gt;is_vanilla_constructor()) {</span>
<span class="line-added">6903           icce_msg = &quot;containing a non-empty constructor&quot;;</span>
<span class="line-added">6904           break;</span>
<span class="line-added">6905         }</span>
<span class="line-added">6906       }</span>
<span class="line-added">6907     }</span>
<span class="line-added">6908   }</span>
<span class="line-added">6909   if (icce_msg != NULL) {</span>
<span class="line-added">6910     ResourceMark rm(THREAD);</span>
<span class="line-added">6911     Exceptions::fthrow(</span>
<span class="line-added">6912       THREAD_AND_LOCATION,</span>
<span class="line-added">6913       vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">6914       &quot;inline class %s has a super class %s %s&quot;,</span>
<span class="line-added">6915       _class_name-&gt;as_klass_external_name(),</span>
<span class="line-added">6916       super_klass-&gt;external_name(),</span>
<span class="line-added">6917       icce_msg);</span>
<span class="line-added">6918   }</span>
<span class="line-added">6919 }</span>
<span class="line-added">6920 </span>
6921 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6922                                                  ConstantPool* cp,
6923                                                  TRAPS) {
6924   assert(stream != NULL, &quot;invariant&quot;);
6925   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6926   assert(cp != NULL, &quot;invariant&quot;);
6927   assert(_loader_data != NULL, &quot;invariant&quot;);
6928 
6929   if (_class_name == vmSymbols::java_lang_Object()) {
6930     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),
6931                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,
6932                    CHECK);
6933   }
6934   // We check super class after class file is parsed and format is checked
6935   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6936     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
6937     if (is_interface()) {
6938       // Before attempting to resolve the superclass, check for class format
6939       // errors not checked yet.
6940       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
</pre>
<hr />
<pre>
6957     }
6958     if (_super_klass-&gt;is_declared_atomic()) {
6959       _is_declared_atomic = true;
6960     }
6961 
6962     if (_super_klass-&gt;is_interface()) {
6963       ResourceMark rm(THREAD);
6964       Exceptions::fthrow(
6965         THREAD_AND_LOCATION,
6966         vmSymbols::java_lang_IncompatibleClassChangeError(),
6967         &quot;class %s has interface %s as super class&quot;,
6968         _class_name-&gt;as_klass_external_name(),
6969         _super_klass-&gt;external_name()
6970       );
6971       return;
6972     }
6973 
6974     // For an inline class, only java/lang/Object or special abstract classes
6975     // are acceptable super classes.
6976     if (_access_flags.get_flags() &amp; JVM_ACC_VALUE) {
<span class="line-modified">6977       const InstanceKlass* super_ik = _super_klass;</span>
<span class="line-modified">6978       while (super_ik-&gt;name() != vmSymbols::java_lang_Object()) {</span>
<span class="line-modified">6979         check_super_of_inline_type(super_ik, CHECK);</span>
<span class="line-modified">6980         super_ik = super_ik-&gt;java_super();</span>
<span class="line-added">6981         assert(super_ik != NULL, &quot;Unexpected NULL super class&quot;);</span>
6982       }
6983     }
6984 
6985     // Make sure super class is not final
6986     if (_super_klass-&gt;is_final()) {
6987       THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
6988     }
6989   }
6990 
6991   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {
6992     // This is the original source of this condition.
6993     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.
6994     _is_declared_atomic = true;
6995   } else if (*ForceNonTearable != &#39;\0&#39;) {
6996     // Allow a command line switch to force the same atomicity property:
6997     const char* class_name_str = _class_name-&gt;as_C_string();
6998     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {
6999       _is_declared_atomic = true;
7000     }
7001   }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
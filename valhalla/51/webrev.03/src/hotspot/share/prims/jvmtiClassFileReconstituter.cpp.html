<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/prims/jvmtiClassFileReconstituter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/symbolTable.hpp&quot;
  27 #include &quot;interpreter/bytecodeStream.hpp&quot;
  28 #include &quot;memory/universe.hpp&quot;
  29 #include &quot;oops/fieldStreams.inline.hpp&quot;
  30 #include &quot;oops/recordComponent.hpp&quot;
  31 #include &quot;prims/jvmtiClassFileReconstituter.hpp&quot;
  32 #include &quot;runtime/handles.inline.hpp&quot;
  33 #include &quot;runtime/signature.hpp&quot;
  34 #include &quot;utilities/bytes.hpp&quot;
  35 
  36 // FIXME: add Deprecated attribute
  37 // FIXME: fix Synthetic attribute
  38 // FIXME: per Serguei, add error return handling for ConstantPool::copy_cpool_bytes()
  39 
  40 JvmtiConstantPoolReconstituter::JvmtiConstantPoolReconstituter(InstanceKlass* ik) {
  41   set_error(JVMTI_ERROR_NONE);
  42   _ik = ik;
  43   _cpool = constantPoolHandle(Thread::current(), ik-&gt;constants());
  44   _symmap = new SymbolHashMap();
  45   _classmap = new SymbolHashMap();
  46   _cpool_size = _cpool-&gt;hash_entries_to(_symmap, _classmap);
  47   if (_cpool_size == 0) {
  48     set_error(JVMTI_ERROR_OUT_OF_MEMORY);
  49   } else if (_cpool_size &lt; 0) {
  50     set_error(JVMTI_ERROR_INTERNAL);
  51   }
  52 }
  53 
  54 // Write the field information portion of ClassFile structure
  55 // JVMSpec|     u2 fields_count;
  56 // JVMSpec|     field_info fields[fields_count];
  57 void JvmtiClassFileReconstituter::write_field_infos() {
  58   HandleMark hm(thread());
  59   Array&lt;AnnotationArray*&gt;* fields_anno = ik()-&gt;fields_annotations();
  60   Array&lt;AnnotationArray*&gt;* fields_type_anno = ik()-&gt;fields_type_annotations();
  61 
  62   // Compute the real number of Java fields
  63   int java_fields = ik()-&gt;java_fields_count();
  64 
  65   write_u2(java_fields);
  66   for (JavaFieldStream fs(ik()); !fs.done(); fs.next()) {
  67     AccessFlags access_flags = fs.access_flags();
  68     int name_index = fs.name_index();
  69     int signature_index = fs.signature_index();
  70     int initial_value_index = fs.initval_index();
  71     guarantee(name_index != 0 &amp;&amp; signature_index != 0, &quot;bad constant pool index for field&quot;);
  72     // int offset = ik()-&gt;field_offset( index );
  73     int generic_signature_index = fs.generic_signature_index();
  74     AnnotationArray* anno = fields_anno == NULL ? NULL : fields_anno-&gt;at(fs.index());
  75     AnnotationArray* type_anno = fields_type_anno == NULL ? NULL : fields_type_anno-&gt;at(fs.index());
  76 
  77     // JVMSpec|   field_info {
  78     // JVMSpec|         u2 access_flags;
  79     // JVMSpec|         u2 name_index;
  80     // JVMSpec|         u2 descriptor_index;
  81     // JVMSpec|         u2 attributes_count;
  82     // JVMSpec|         attribute_info attributes[attributes_count];
  83     // JVMSpec|   }
  84 
  85     write_u2(access_flags.as_int() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS);
  86     write_u2(name_index);
  87     write_u2(signature_index);
  88     int attr_count = 0;
  89     if (initial_value_index != 0) {
  90       ++attr_count;
  91     }
  92     if (access_flags.is_synthetic()) {
  93       // ++attr_count;
  94     }
  95     if (generic_signature_index != 0) {
  96       ++attr_count;
  97     }
  98     if (anno != NULL) {
  99       ++attr_count;     // has RuntimeVisibleAnnotations attribute
 100     }
 101     if (type_anno != NULL) {
 102       ++attr_count;     // has RuntimeVisibleTypeAnnotations attribute
 103     }
 104 
 105     write_u2(attr_count);
 106 
 107     if (initial_value_index != 0) {
 108       write_attribute_name_index(&quot;ConstantValue&quot;);
 109       write_u4(2); //length always 2
 110       write_u2(initial_value_index);
 111     }
 112     if (access_flags.is_synthetic()) {
 113       // write_synthetic_attribute();
 114     }
 115     if (generic_signature_index != 0) {
 116       write_signature_attribute(generic_signature_index);
 117     }
 118     if (anno != NULL) {
 119       write_annotations_attribute(&quot;RuntimeVisibleAnnotations&quot;, anno);
 120     }
 121     if (type_anno != NULL) {
 122       write_annotations_attribute(&quot;RuntimeVisibleTypeAnnotations&quot;, type_anno);
 123     }
 124   }
 125 }
 126 
 127 // Write Code attribute
 128 // JVMSpec|   Code_attribute {
 129 // JVMSpec|     u2 attribute_name_index;
 130 // JVMSpec|     u4 attribute_length;
 131 // JVMSpec|     u2 max_stack;
 132 // JVMSpec|     u2 max_locals;
 133 // JVMSpec|     u4 code_length;
 134 // JVMSpec|     u1 code[code_length];
 135 // JVMSpec|     u2 exception_table_length;
 136 // JVMSpec|     {       u2 start_pc;
 137 // JVMSpec|             u2 end_pc;
 138 // JVMSpec|             u2  handler_pc;
 139 // JVMSpec|             u2  catch_type;
 140 // JVMSpec|     }       exception_table[exception_table_length];
 141 // JVMSpec|     u2 attributes_count;
 142 // JVMSpec|     attribute_info attributes[attributes_count];
 143 // JVMSpec|   }
 144 void JvmtiClassFileReconstituter::write_code_attribute(const methodHandle&amp; method) {
 145   ConstMethod* const_method = method-&gt;constMethod();
 146   u2 line_num_cnt = 0;
 147   int stackmap_len = 0;
 148   int local_variable_table_length = 0;
 149   int local_variable_type_table_length = 0;
 150 
 151   // compute number and length of attributes
 152   int attr_count = 0;
 153   int attr_size = 0;
 154   if (const_method-&gt;has_linenumber_table()) {
 155     line_num_cnt = line_number_table_entries(method);
 156     if (line_num_cnt != 0) {
 157       ++attr_count;
 158       // Compute the complete size of the line number table attribute:
 159       //      LineNumberTable_attribute {
 160       //        u2 attribute_name_index;
 161       //        u4 attribute_length;
 162       //        u2 line_number_table_length;
 163       //        {  u2 start_pc;
 164       //           u2 line_number;
 165       //        } line_number_table[line_number_table_length];
 166       //      }
 167       attr_size += 2 + 4 + 2 + line_num_cnt * (2 + 2);
 168     }
 169   }
 170   if (method-&gt;has_stackmap_table()) {
 171     stackmap_len = method-&gt;stackmap_data()-&gt;length();
 172     if (stackmap_len != 0) {
 173       ++attr_count;
 174       // Compute the  size of the stack map table attribute (VM stores raw):
 175       //      StackMapTable_attribute {
 176       //        u2 attribute_name_index;
 177       //        u4 attribute_length;
 178       //        u2 number_of_entries;
 179       //        stack_map_frame_entries[number_of_entries];
 180       //      }
 181       attr_size += 2 + 4 + stackmap_len;
 182     }
 183   }
 184   if (method-&gt;has_localvariable_table()) {
 185     local_variable_table_length = method-&gt;localvariable_table_length();
 186     if (local_variable_table_length != 0) {
 187       ++attr_count;
 188       // Compute the size of the local variable table attribute (VM stores raw):
 189       // LocalVariableTable_attribute {
 190       //   u2 attribute_name_index;
 191       //   u4 attribute_length;
 192       //   u2 local_variable_table_length;
 193       //   {
 194       //     u2 start_pc;
 195       //     u2 length;
 196       //     u2 name_index;
 197       //     u2 descriptor_index;
 198       //     u2 index;
 199       //   }
 200       attr_size += 2 + 4 + 2 + local_variable_table_length * (2 + 2 + 2 + 2 + 2);
 201 
 202       // Local variables with generic signatures must have LVTT entries
 203       LocalVariableTableElement *elem = method-&gt;localvariable_table_start();
 204       for (int idx = 0; idx &lt; local_variable_table_length; idx++) {
 205         if (elem[idx].signature_cp_index != 0) {
 206           local_variable_type_table_length++;
 207         }
 208       }
 209 
 210       if (local_variable_type_table_length != 0) {
 211         ++attr_count;
 212         // Compute the size of the local variable type table attribute (VM stores raw):
 213         // LocalVariableTypeTable_attribute {
 214         //   u2 attribute_name_index;
 215         //   u4 attribute_length;
 216         //   u2 local_variable_type_table_length;
 217         //   {
 218         //     u2 start_pc;
 219         //     u2 length;
 220         //     u2 name_index;
 221         //     u2 signature_index;
 222         //     u2 index;
 223         //   }
 224         attr_size += 2 + 4 + 2 + local_variable_type_table_length * (2 + 2 + 2 + 2 + 2);
 225       }
 226     }
 227   }
 228 
 229   ExceptionTable exception_table(method());
 230   int exception_table_length = exception_table.length();
 231   int code_size = const_method-&gt;code_size();
 232   int size =
 233     2+2+4 +                                // max_stack, max_locals, code_length
 234     code_size +                            // code
 235     2 +                                    // exception_table_length
 236     (2+2+2+2) * exception_table_length +   // exception_table
 237     2 +                                    // attributes_count
 238     attr_size;                             // attributes
 239 
 240   write_attribute_name_index(&quot;Code&quot;);
 241   write_u4(size);
 242   write_u2(method-&gt;verifier_max_stack());
 243   write_u2(method-&gt;max_locals());
 244   write_u4(code_size);
 245   copy_bytecodes(method, (unsigned char*)writeable_address(code_size));
 246   write_u2(exception_table_length);
 247   for (int index = 0; index &lt; exception_table_length; index++) {
 248     write_u2(exception_table.start_pc(index));
 249     write_u2(exception_table.end_pc(index));
 250     write_u2(exception_table.handler_pc(index));
 251     write_u2(exception_table.catch_type_index(index));
 252   }
 253   write_u2(attr_count);
 254   if (line_num_cnt != 0) {
 255     write_line_number_table_attribute(method, line_num_cnt);
 256   }
 257   if (stackmap_len != 0) {
 258     write_stackmap_table_attribute(method, stackmap_len);
 259   }
 260   if (local_variable_table_length != 0) {
 261     write_local_variable_table_attribute(method, local_variable_table_length);
 262   }
 263   if (local_variable_type_table_length != 0) {
 264     write_local_variable_type_table_attribute(method, local_variable_type_table_length);
 265   }
 266 }
 267 
 268 // Write Exceptions attribute
 269 // JVMSpec|   Exceptions_attribute {
 270 // JVMSpec|     u2 attribute_name_index;
 271 // JVMSpec|     u4 attribute_length;
 272 // JVMSpec|     u2 number_of_exceptions;
 273 // JVMSpec|     u2 exception_index_table[number_of_exceptions];
 274 // JVMSpec|   }
 275 void JvmtiClassFileReconstituter::write_exceptions_attribute(ConstMethod* const_method) {
 276   CheckedExceptionElement* checked_exceptions = const_method-&gt;checked_exceptions_start();
 277   int checked_exceptions_length = const_method-&gt;checked_exceptions_length();
 278   int size =
 279     2 +                                    // number_of_exceptions
 280     2 * checked_exceptions_length;         // exception_index_table
 281 
 282   write_attribute_name_index(&quot;Exceptions&quot;);
 283   write_u4(size);
 284   write_u2(checked_exceptions_length);
 285   for (int index = 0; index &lt; checked_exceptions_length; index++) {
 286     write_u2(checked_exceptions[index].class_cp_index);
 287   }
 288 }
 289 
 290 // Write SourceFile attribute
 291 // JVMSpec|   SourceFile_attribute {
 292 // JVMSpec|     u2 attribute_name_index;
 293 // JVMSpec|     u4 attribute_length;
 294 // JVMSpec|     u2 sourcefile_index;
 295 // JVMSpec|   }
 296 void JvmtiClassFileReconstituter::write_source_file_attribute() {
 297   assert(ik()-&gt;source_file_name() != NULL, &quot;caller must check&quot;);
 298 
 299   write_attribute_name_index(&quot;SourceFile&quot;);
 300   write_u4(2);  // always length 2
 301   write_u2(symbol_to_cpool_index(ik()-&gt;source_file_name()));
 302 }
 303 
 304 // Write SourceDebugExtension attribute
 305 // JSR45|   SourceDebugExtension_attribute {
 306 // JSR45|       u2 attribute_name_index;
 307 // JSR45|       u4 attribute_length;
 308 // JSR45|       u1 debug_extension[attribute_length];
 309 // JSR45|   }
 310 void JvmtiClassFileReconstituter::write_source_debug_extension_attribute() {
 311   assert(ik()-&gt;source_debug_extension() != NULL, &quot;caller must check&quot;);
 312 
 313   write_attribute_name_index(&quot;SourceDebugExtension&quot;);
 314   int len = (int)strlen(ik()-&gt;source_debug_extension());
 315   write_u4(len);
 316   u1* ext = (u1*)ik()-&gt;source_debug_extension();
 317   for (int i=0; i&lt;len; i++) {
 318     write_u1(ext[i]);
 319   }
 320 }
 321 
 322 // Write (generic) Signature attribute
 323 // JVMSpec|   Signature_attribute {
 324 // JVMSpec|     u2 attribute_name_index;
 325 // JVMSpec|     u4 attribute_length;
 326 // JVMSpec|     u2 signature_index;
 327 // JVMSpec|   }
 328 void JvmtiClassFileReconstituter::write_signature_attribute(u2 generic_signature_index) {
 329   write_attribute_name_index(&quot;Signature&quot;);
 330   write_u4(2);  // always length 2
 331   write_u2(generic_signature_index);
 332 }
 333 
 334 // Compute the number of entries in the InnerClasses attribute
 335 u2 JvmtiClassFileReconstituter::inner_classes_attribute_length() {
 336   InnerClassesIterator iter(ik());
 337   return iter.length();
 338 }
 339 
 340 // Write an annotation attribute.  The VM stores them in raw form, so all we need
 341 // to do is add the attrubute name and fill in the length.
 342 // JSR202|   *Annotations_attribute {
 343 // JSR202|     u2 attribute_name_index;
 344 // JSR202|     u4 attribute_length;
 345 // JSR202|     ...
 346 // JSR202|   }
 347 void JvmtiClassFileReconstituter::write_annotations_attribute(const char* attr_name,
 348                                                               AnnotationArray* annos) {
 349   u4 length = annos-&gt;length();
 350   write_attribute_name_index(attr_name);
 351   write_u4(length);
 352   memcpy(writeable_address(length), annos-&gt;adr_at(0), length);
 353 }
 354 
 355 //  BootstrapMethods_attribute {
 356 //    u2 attribute_name_index;
 357 //    u4 attribute_length;
 358 //    u2 num_bootstrap_methods;
 359 //    {   u2 bootstrap_method_ref;
 360 //        u2 num_bootstrap_arguments;
 361 //        u2 bootstrap_arguments[num_bootstrap_arguments];
 362 //    } bootstrap_methods[num_bootstrap_methods];
 363 //  }
 364 void JvmtiClassFileReconstituter::write_bootstrapmethod_attribute() {
 365   Array&lt;u2&gt;* operands = cpool()-&gt;operands();
 366   write_attribute_name_index(&quot;BootstrapMethods&quot;);
 367   int num_bootstrap_methods = ConstantPool::operand_array_length(operands);
 368 
 369   // calculate length of attribute
 370   int length = sizeof(u2); // num_bootstrap_methods
 371   for (int n = 0; n &lt; num_bootstrap_methods; n++) {
 372     u2 num_bootstrap_arguments = cpool()-&gt;operand_argument_count_at(n);
 373     length += sizeof(u2); // bootstrap_method_ref
 374     length += sizeof(u2); // num_bootstrap_arguments
 375     length += sizeof(u2) * num_bootstrap_arguments; // bootstrap_arguments[num_bootstrap_arguments]
 376   }
 377   write_u4(length);
 378 
 379   // write attribute
 380   write_u2(num_bootstrap_methods);
 381   for (int n = 0; n &lt; num_bootstrap_methods; n++) {
 382     u2 bootstrap_method_ref = cpool()-&gt;operand_bootstrap_method_ref_index_at(n);
 383     u2 num_bootstrap_arguments = cpool()-&gt;operand_argument_count_at(n);
 384     write_u2(bootstrap_method_ref);
 385     write_u2(num_bootstrap_arguments);
 386     for (int arg = 0; arg &lt; num_bootstrap_arguments; arg++) {
 387       u2 bootstrap_argument = cpool()-&gt;operand_argument_index_at(n, arg);
 388       write_u2(bootstrap_argument);
 389     }
 390   }
 391 }
 392 
 393 //  NestHost_attribute {
 394 //    u2 attribute_name_index;
 395 //    u4 attribute_length;
 396 //    u2 host_class_index;
 397 //  }
 398 void JvmtiClassFileReconstituter::write_nest_host_attribute() {
 399   int length = sizeof(u2);
 400   int host_class_index = ik()-&gt;nest_host_index();
 401 
 402   write_attribute_name_index(&quot;NestHost&quot;);
 403   write_u4(length);
 404   write_u2(host_class_index);
 405 }
 406 
 407 //  NestMembers_attribute {
 408 //    u2 attribute_name_index;
 409 //    u4 attribute_length;
 410 //    u2 number_of_classes;
 411 //    u2 classes[number_of_classes];
 412 //  }
 413 void JvmtiClassFileReconstituter::write_nest_members_attribute() {
 414   Array&lt;u2&gt;* nest_members = ik()-&gt;nest_members();
 415   int number_of_classes = nest_members-&gt;length();
 416   int length = sizeof(u2) * (1 + number_of_classes);
 417 
 418   write_attribute_name_index(&quot;NestMembers&quot;);
 419   write_u4(length);
 420   write_u2(number_of_classes);
 421   for (int i = 0; i &lt; number_of_classes; i++) {
 422     u2 class_cp_index = nest_members-&gt;at(i);
 423     write_u2(class_cp_index);
 424   }
 425 }
 426 
 427 //  Record {
 428 //    u2 attribute_name_index;
 429 //    u4 attribute_length;
 430 //    u2 components_count;
 431 //    component_info components[components_count];
 432 //  }
 433 //  component_info {
 434 //    u2 name_index;
 435 //    u2 descriptor_index
 436 //    u2 attributes_count;
 437 //    attribute_info_attributes[attributes_count];
 438 //  }
 439 void JvmtiClassFileReconstituter::write_record_attribute() {
 440   Array&lt;RecordComponent*&gt;* components = ik()-&gt;record_components();
 441   int number_of_components = components-&gt;length();
 442 
 443   // Each component has a u2 for name, descr, attribute count
 444   int length = sizeof(u2) + (sizeof(u2) * 3 * number_of_components);
 445   for (int x = 0; x &lt; number_of_components; x++) {
 446     RecordComponent* component = components-&gt;at(x);
 447     if (component-&gt;generic_signature_index() != 0) {
 448       length += 8; // Signature attribute size
 449       assert(component-&gt;attributes_count() &gt; 0, &quot;Bad component attributes count&quot;);
 450     }
 451     if (component-&gt;annotations() != NULL) {
 452       length += 6 + component-&gt;annotations()-&gt;length();
 453     }
 454     if (component-&gt;type_annotations() != NULL) {
 455       length += 6 + component-&gt;type_annotations()-&gt;length();
 456     }
 457   }
 458 
 459   write_attribute_name_index(&quot;Record&quot;);
 460   write_u4(length);
 461   write_u2(number_of_components);
 462   for (int i = 0; i &lt; number_of_components; i++) {
 463     RecordComponent* component = components-&gt;at(i);
 464     write_u2(component-&gt;name_index());
 465     write_u2(component-&gt;descriptor_index());
 466     write_u2(component-&gt;attributes_count());
 467     if (component-&gt;generic_signature_index() != 0) {
 468       write_signature_attribute(component-&gt;generic_signature_index());
 469     }
 470     if (component-&gt;annotations() != NULL) {
 471       write_annotations_attribute(&quot;RuntimeVisibleAnnotations&quot;, component-&gt;annotations());
 472     }
 473     if (component-&gt;type_annotations() != NULL) {
 474       write_annotations_attribute(&quot;RuntimeVisibleTypeAnnotations&quot;, component-&gt;type_annotations());
 475     }
 476   }
 477 }
 478 
 479 // Write InnerClasses attribute
 480 // JVMSpec|   InnerClasses_attribute {
 481 // JVMSpec|     u2 attribute_name_index;
 482 // JVMSpec|     u4 attribute_length;
 483 // JVMSpec|     u2 number_of_classes;
 484 // JVMSpec|     {  u2 inner_class_info_index;
 485 // JVMSpec|        u2 outer_class_info_index;
 486 // JVMSpec|        u2 inner_name_index;
 487 // JVMSpec|        u2 inner_class_access_flags;
 488 // JVMSpec|     } classes[number_of_classes];
 489 // JVMSpec|   }
 490 void JvmtiClassFileReconstituter::write_inner_classes_attribute(int length) {
 491   InnerClassesIterator iter(ik());
 492   guarantee(iter.length() != 0 &amp;&amp; iter.length() == length,
 493             &quot;caller must check&quot;);
 494   u2 entry_count = length / InstanceKlass::inner_class_next_offset;
 495   u4 size = 2 + entry_count * (2+2+2+2);
 496 
 497   write_attribute_name_index(&quot;InnerClasses&quot;);
 498   write_u4(size);
 499   write_u2(entry_count);
 500   for (; !iter.done(); iter.next()) {
 501     write_u2(iter.inner_class_info_index());
 502     write_u2(iter.outer_class_info_index());
 503     write_u2(iter.inner_name_index());
 504     write_u2(iter.inner_access_flags());
 505   }
 506 }
 507 
 508 // Write Synthetic attribute
 509 // JVMSpec|   Synthetic_attribute {
 510 // JVMSpec|     u2 attribute_name_index;
 511 // JVMSpec|     u4 attribute_length;
 512 // JVMSpec|   }
 513 void JvmtiClassFileReconstituter::write_synthetic_attribute() {
 514   write_attribute_name_index(&quot;Synthetic&quot;);
 515   write_u4(0); //length always zero
 516 }
 517 
 518 // Compute size of LineNumberTable
 519 u2 JvmtiClassFileReconstituter::line_number_table_entries(const methodHandle&amp; method) {
 520   // The line number table is compressed so we don&#39;t know how big it is until decompressed.
 521   // Decompression is really fast so we just do it twice.
 522   u2 num_entries = 0;
 523   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
 524   while (stream.read_pair()) {
 525     num_entries++;
 526   }
 527   return num_entries;
 528 }
 529 
 530 // Write LineNumberTable attribute
 531 // JVMSpec|   LineNumberTable_attribute {
 532 // JVMSpec|     u2 attribute_name_index;
 533 // JVMSpec|     u4 attribute_length;
 534 // JVMSpec|     u2 line_number_table_length;
 535 // JVMSpec|     {  u2 start_pc;
 536 // JVMSpec|        u2 line_number;
 537 // JVMSpec|     } line_number_table[line_number_table_length];
 538 // JVMSpec|   }
 539 void JvmtiClassFileReconstituter::write_line_number_table_attribute(const methodHandle&amp; method,
 540                                                                     u2 num_entries) {
 541 
 542   write_attribute_name_index(&quot;LineNumberTable&quot;);
 543   write_u4(2 + num_entries * (2 + 2));
 544   write_u2(num_entries);
 545 
 546   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
 547   while (stream.read_pair()) {
 548     write_u2(stream.bci());
 549     write_u2(stream.line());
 550   }
 551 }
 552 
 553 // Write LocalVariableTable attribute
 554 // JVMSpec|   LocalVariableTable_attribute {
 555 // JVMSpec|     u2 attribute_name_index;
 556 // JVMSpec|     u4 attribute_length;
 557 // JVMSpec|     u2 local_variable_table_length;
 558 // JVMSpec|     {  u2 start_pc;
 559 // JVMSpec|       u2 length;
 560 // JVMSpec|       u2 name_index;
 561 // JVMSpec|       u2 descriptor_index;
 562 // JVMSpec|       u2 index;
 563 // JVMSpec|     } local_variable_table[local_variable_table_length];
 564 // JVMSpec|   }
 565 void JvmtiClassFileReconstituter::write_local_variable_table_attribute(const methodHandle&amp; method, u2 num_entries) {
 566     write_attribute_name_index(&quot;LocalVariableTable&quot;);
 567     write_u4(2 + num_entries * (2 + 2 + 2 + 2 + 2));
 568     write_u2(num_entries);
 569 
 570     assert(method-&gt;localvariable_table_length() == num_entries, &quot;just checking&quot;);
 571 
 572     LocalVariableTableElement *elem = method-&gt;localvariable_table_start();
 573     for (int j=0; j&lt;method-&gt;localvariable_table_length(); j++) {
 574       write_u2(elem-&gt;start_bci);
 575       write_u2(elem-&gt;length);
 576       write_u2(elem-&gt;name_cp_index);
 577       write_u2(elem-&gt;descriptor_cp_index);
 578       write_u2(elem-&gt;slot);
 579       elem++;
 580     }
 581 }
 582 
 583 // Write LocalVariableTypeTable attribute
 584 // JVMSpec|   LocalVariableTypeTable_attribute {
 585 // JVMSpec|     u2 attribute_name_index;
 586 // JVMSpec|     u4 attribute_length;
 587 // JVMSpec|     u2 local_variable_type_table_length;
 588 // JVMSpec|     { u2 start_pc;
 589 // JVMSpec|       u2 length;
 590 // JVMSpec|       u2 name_index;
 591 // JVMSpec|       u2 signature_index;
 592 // JVMSpec|       u2 index;
 593 // JVMSpec|     } local_variable_type_table[local_variable_type_table_length];
 594 // JVMSpec|   }
 595 void JvmtiClassFileReconstituter::write_local_variable_type_table_attribute(const methodHandle&amp; method, u2 num_entries) {
 596     write_attribute_name_index(&quot;LocalVariableTypeTable&quot;);
 597     write_u4(2 + num_entries * (2 + 2 + 2 + 2 + 2));
 598     write_u2(num_entries);
 599 
 600     LocalVariableTableElement *elem = method-&gt;localvariable_table_start();
 601     for (int j=0; j&lt;method-&gt;localvariable_table_length(); j++) {
 602       if (elem-&gt;signature_cp_index &gt; 0) {
 603         // Local variable has a generic signature - write LVTT attribute entry
 604         write_u2(elem-&gt;start_bci);
 605         write_u2(elem-&gt;length);
 606         write_u2(elem-&gt;name_cp_index);
 607         write_u2(elem-&gt;signature_cp_index);
 608         write_u2(elem-&gt;slot);
 609         num_entries--;
 610       }
 611       elem++;
 612     }
 613     assert(num_entries == 0, &quot;just checking&quot;);
 614 }
 615 
 616 // Write stack map table attribute
 617 // JSR-202|   StackMapTable_attribute {
 618 // JSR-202|     u2 attribute_name_index;
 619 // JSR-202|     u4 attribute_length;
 620 // JSR-202|     u2 number_of_entries;
 621 // JSR-202|     stack_map_frame_entries[number_of_entries];
 622 // JSR-202|   }
 623 void JvmtiClassFileReconstituter::write_stackmap_table_attribute(const methodHandle&amp; method,
 624                                                                  int stackmap_len) {
 625 
 626   write_attribute_name_index(&quot;StackMapTable&quot;);
 627   write_u4(stackmap_len);
 628   memcpy(
 629     writeable_address(stackmap_len),
 630     (void*)(method-&gt;stackmap_data()-&gt;adr_at(0)),
 631     stackmap_len);
 632 }
 633 
 634 // Write one method_info structure
 635 // JVMSpec|   method_info {
 636 // JVMSpec|     u2 access_flags;
 637 // JVMSpec|     u2 name_index;
 638 // JVMSpec|     u2 descriptor_index;
 639 // JVMSpec|     u2 attributes_count;
 640 // JVMSpec|     attribute_info attributes[attributes_count];
 641 // JVMSpec|   }
 642 void JvmtiClassFileReconstituter::write_method_info(const methodHandle&amp; method) {
 643   AccessFlags access_flags = method-&gt;access_flags();
 644   ConstMethod* const_method = method-&gt;constMethod();
 645   u2 generic_signature_index = const_method-&gt;generic_signature_index();
 646   AnnotationArray* anno = method-&gt;annotations();
 647   AnnotationArray* param_anno = method-&gt;parameter_annotations();
 648   AnnotationArray* default_anno = method-&gt;annotation_default();
 649   AnnotationArray* type_anno = method-&gt;type_annotations();
 650 
 651   // skip generated default interface methods
 652   if (method-&gt;is_overpass()) {
 653     return;
 654   }
 655 
 656   write_u2(access_flags.get_flags() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
 657   write_u2(const_method-&gt;name_index());
 658   write_u2(const_method-&gt;signature_index());
 659 
 660   // write attributes in the same order javac does, so we can test with byte for
 661   // byte comparison
 662   int attr_count = 0;
 663   if (const_method-&gt;code_size() != 0) {
 664     ++attr_count;     // has Code attribute
 665   }
 666   if (const_method-&gt;has_checked_exceptions()) {
 667     ++attr_count;     // has Exceptions attribute
 668   }
 669   if (default_anno != NULL) {
 670     ++attr_count;     // has AnnotationDefault attribute
 671   }
 672   // Deprecated attribute would go here
 673   if (access_flags.is_synthetic()) { // FIXME
 674     // ++attr_count;
 675   }
 676   if (generic_signature_index != 0) {
 677     ++attr_count;
 678   }
 679   if (anno != NULL) {
 680     ++attr_count;     // has RuntimeVisibleAnnotations attribute
 681   }
 682   if (param_anno != NULL) {
 683     ++attr_count;     // has RuntimeVisibleParameterAnnotations attribute
 684   }
 685   if (type_anno != NULL) {
 686     ++attr_count;     // has RuntimeVisibleTypeAnnotations attribute
 687   }
 688 
 689   write_u2(attr_count);
 690   if (const_method-&gt;code_size() &gt; 0) {
 691     write_code_attribute(method);
 692   }
 693   if (const_method-&gt;has_checked_exceptions()) {
 694     write_exceptions_attribute(const_method);
 695   }
 696   if (default_anno != NULL) {
 697     write_annotations_attribute(&quot;AnnotationDefault&quot;, default_anno);
 698   }
 699   // Deprecated attribute would go here
 700   if (access_flags.is_synthetic()) {
 701     // write_synthetic_attribute();
 702   }
 703   if (generic_signature_index != 0) {
 704     write_signature_attribute(generic_signature_index);
 705   }
 706   if (anno != NULL) {
 707     write_annotations_attribute(&quot;RuntimeVisibleAnnotations&quot;, anno);
 708   }
 709   if (param_anno != NULL) {
 710     write_annotations_attribute(&quot;RuntimeVisibleParameterAnnotations&quot;, param_anno);
 711   }
 712   if (type_anno != NULL) {
 713     write_annotations_attribute(&quot;RuntimeVisibleTypeAnnotations&quot;, type_anno);
 714   }
 715 }
 716 
 717 // Write the class attributes portion of ClassFile structure
 718 // JVMSpec|     u2 attributes_count;
 719 // JVMSpec|     attribute_info attributes[attributes_count];
 720 void JvmtiClassFileReconstituter::write_class_attributes() {
 721   u2 inner_classes_length = inner_classes_attribute_length();
 722   Symbol* generic_signature = ik()-&gt;generic_signature();
 723   AnnotationArray* anno = ik()-&gt;class_annotations();
 724   AnnotationArray* type_anno = ik()-&gt;class_type_annotations();
 725 
 726   int attr_count = 0;
 727   if (generic_signature != NULL) {
 728     ++attr_count;
 729   }
 730   if (ik()-&gt;source_file_name() != NULL) {
 731     ++attr_count;
 732   }
 733   if (ik()-&gt;source_debug_extension() != NULL) {
 734     ++attr_count;
 735   }
 736   if (inner_classes_length &gt; 0) {
 737     ++attr_count;
 738   }
 739   if (anno != NULL) {
 740     ++attr_count;     // has RuntimeVisibleAnnotations attribute
 741   }
 742   if (type_anno != NULL) {
 743     ++attr_count;     // has RuntimeVisibleTypeAnnotations attribute
 744   }
 745   if (cpool()-&gt;operands() != NULL) {
 746     ++attr_count;
 747   }
 748   if (ik()-&gt;nest_host_index() != 0) {
 749     ++attr_count;
 750   }
 751   if (ik()-&gt;nest_members() != Universe::the_empty_short_array()) {
 752     ++attr_count;
 753   }
 754   if (ik()-&gt;record_components() != NULL) {
 755     ++attr_count;
 756   }
 757 
 758   write_u2(attr_count);
 759 
 760   if (generic_signature != NULL) {
 761     write_signature_attribute(symbol_to_cpool_index(generic_signature));
 762   }
 763   if (ik()-&gt;source_file_name() != NULL) {
 764     write_source_file_attribute();
 765   }
 766   if (ik()-&gt;source_debug_extension() != NULL) {
 767     write_source_debug_extension_attribute();
 768   }
 769   if (inner_classes_length &gt; 0) {
 770     write_inner_classes_attribute(inner_classes_length);
 771   }
 772   if (anno != NULL) {
 773     write_annotations_attribute(&quot;RuntimeVisibleAnnotations&quot;, anno);
 774   }
 775   if (type_anno != NULL) {
 776     write_annotations_attribute(&quot;RuntimeVisibleTypeAnnotations&quot;, type_anno);
 777   }
 778   if (cpool()-&gt;operands() != NULL) {
 779     write_bootstrapmethod_attribute();
 780   }
 781   if (ik()-&gt;nest_host_index() != 0) {
 782     write_nest_host_attribute();
 783   }
 784   if (ik()-&gt;nest_members() != Universe::the_empty_short_array()) {
 785     write_nest_members_attribute();
 786   }
 787   if (ik()-&gt;record_components() != NULL) {
 788     write_record_attribute();
 789   }
 790 }
 791 
 792 // Write the method information portion of ClassFile structure
 793 // JVMSpec|     u2 methods_count;
 794 // JVMSpec|     method_info methods[methods_count];
 795 void JvmtiClassFileReconstituter::write_method_infos() {
 796   HandleMark hm(thread());
 797   Array&lt;Method*&gt;* methods = ik()-&gt;methods();
 798   int num_methods = methods-&gt;length();
 799   int num_overpass = 0;
 800 
 801   // count the generated default interface methods
 802   // these will not be re-created by write_method_info
 803   // and should not be included in the total count
 804   for (int index = 0; index &lt; num_methods; index++) {
 805     Method* method = methods-&gt;at(index);
 806     if (method-&gt;is_overpass()) {
 807       num_overpass++;
 808     }
 809   }
 810 
 811   write_u2(num_methods - num_overpass);
 812   if (JvmtiExport::can_maintain_original_method_order()) {
 813     int index;
 814     int original_index;
 815     intArray method_order(num_methods, num_methods, 0);
 816 
 817     // invert the method order mapping
 818     for (index = 0; index &lt; num_methods; index++) {
 819       original_index = ik()-&gt;method_ordering()-&gt;at(index);
 820       assert(original_index &gt;= 0 &amp;&amp; original_index &lt; num_methods,
 821              &quot;invalid original method index&quot;);
 822       method_order.at_put(original_index, index);
 823     }
 824 
 825     // write in original order
 826     for (original_index = 0; original_index &lt; num_methods; original_index++) {
 827       index = method_order.at(original_index);
 828       methodHandle method(thread(), methods-&gt;at(index));
 829       write_method_info(method);
 830     }
 831   } else {
 832     // method order not preserved just dump the method infos
 833     for (int index = 0; index &lt; num_methods; index++) {
 834       methodHandle method(thread(), methods-&gt;at(index));
 835       write_method_info(method);
 836     }
 837   }
 838 }
 839 
 840 void JvmtiClassFileReconstituter::write_class_file_format() {
 841   ReallocMark();
 842 
 843   // JVMSpec|   ClassFile {
 844   // JVMSpec|           u4 magic;
 845   write_u4(0xCAFEBABE);
 846 
 847   // JVMSpec|           u2 minor_version;
 848   // JVMSpec|           u2 major_version;
 849   write_u2(ik()-&gt;minor_version());
 850   u2 major = ik()-&gt;major_version();
 851   write_u2(major);
 852 
 853   // JVMSpec|           u2 constant_pool_count;
 854   // JVMSpec|           cp_info constant_pool[constant_pool_count-1];
 855   write_u2(cpool()-&gt;length());
 856   copy_cpool_bytes(writeable_address(cpool_size()));
 857 
 858   // JVMSpec|           u2 access_flags;
 859   write_u2(ik()-&gt;access_flags().get_flags() &amp; JVM_RECOGNIZED_CLASS_MODIFIERS);
 860 
 861   // JVMSpec|           u2 this_class;
 862   // JVMSpec|           u2 super_class;
 863   write_u2(class_symbol_to_cpool_index(ik()-&gt;name()));
 864   Klass* super_class = ik()-&gt;super();
 865   write_u2(super_class == NULL? 0 :  // zero for java.lang.Object
 866                 class_symbol_to_cpool_index(super_class-&gt;name()));
 867 
 868   // JVMSpec|           u2 interfaces_count;
 869   // JVMSpec|           u2 interfaces[interfaces_count];
 870   Array&lt;InstanceKlass*&gt;* interfaces =  ik()-&gt;local_interfaces();
 871   int num_interfaces = interfaces-&gt;length();
 872   write_u2(num_interfaces - (ik()-&gt;has_injected_identityObject() ? 1 : 0) );
 873   for (int index = 0; index &lt; num_interfaces; index++) {
 874     HandleMark hm(thread());
 875     InstanceKlass* iik = interfaces-&gt;at(index);
 876     if (!ik()-&gt;has_injected_identityObject() || iik != SystemDictionary::IdentityObject_klass()) {
 877       write_u2(class_symbol_to_cpool_index(iik-&gt;name()));
 878     }
 879   }
 880 
 881   // JVMSpec|           u2 fields_count;
 882   // JVMSpec|           field_info fields[fields_count];
 883   write_field_infos();
 884 
 885   // JVMSpec|           u2 methods_count;
 886   // JVMSpec|           method_info methods[methods_count];
 887   write_method_infos();
 888 
 889   // JVMSpec|           u2 attributes_count;
 890   // JVMSpec|           attribute_info attributes[attributes_count];
 891   // JVMSpec|   } /* end ClassFile 8?
 892   write_class_attributes();
 893 }
 894 
 895 address JvmtiClassFileReconstituter::writeable_address(size_t size) {
 896   size_t used_size = _buffer_ptr - _buffer;
 897   if (size + used_size &gt;= _buffer_size) {
 898     // compute the new buffer size: must be at least twice as big as before
 899     // plus whatever new is being used; then convert to nice clean block boundary
 900     size_t new_buffer_size = (size + _buffer_size*2 + 1) / initial_buffer_size
 901                                                          * initial_buffer_size;
 902 
 903     // VM goes belly-up if the memory isn&#39;t available, so cannot do OOM processing
 904     _buffer = REALLOC_RESOURCE_ARRAY(u1, _buffer, _buffer_size, new_buffer_size);
 905     _buffer_size = new_buffer_size;
 906     _buffer_ptr = _buffer + used_size;
 907   }
 908   u1* ret_ptr = _buffer_ptr;
 909   _buffer_ptr += size;
 910   return ret_ptr;
 911 }
 912 
 913 void JvmtiClassFileReconstituter::write_attribute_name_index(const char* name) {
 914   TempNewSymbol sym = SymbolTable::probe(name, (int)strlen(name));
 915   assert(sym != NULL, &quot;attribute name symbol not found&quot;);
 916   u2 attr_name_index = symbol_to_cpool_index(sym);
 917   assert(attr_name_index != 0, &quot;attribute name symbol not in constant pool&quot;);
 918   write_u2(attr_name_index);
 919 }
 920 
 921 void JvmtiClassFileReconstituter::write_u1(u1 x) {
 922   *writeable_address(1) = x;
 923 }
 924 
 925 void JvmtiClassFileReconstituter::write_u2(u2 x) {
 926   Bytes::put_Java_u2(writeable_address(2), x);
 927 }
 928 
 929 void JvmtiClassFileReconstituter::write_u4(u4 x) {
 930   Bytes::put_Java_u4(writeable_address(4), x);
 931 }
 932 
 933 void JvmtiClassFileReconstituter::write_u8(u8 x) {
 934   Bytes::put_Java_u8(writeable_address(8), x);
 935 }
 936 
 937 void JvmtiClassFileReconstituter::copy_bytecodes(const methodHandle&amp; mh,
 938                                                  unsigned char* bytecodes) {
 939   // use a BytecodeStream to iterate over the bytecodes. JVM/fast bytecodes
 940   // and the breakpoint bytecode are converted to their original bytecodes.
 941 
 942   BytecodeStream bs(mh);
 943 
 944   unsigned char* p = bytecodes;
 945   Bytecodes::Code code;
 946   bool is_rewritten = mh-&gt;method_holder()-&gt;is_rewritten();
 947 
 948   while ((code = bs.next()) &gt;= 0) {
 949     assert(Bytecodes::is_java_code(code), &quot;sanity check&quot;);
 950     assert(code != Bytecodes::_breakpoint, &quot;sanity check&quot;);
 951 
 952     // length of bytecode (mnemonic + operands)
 953     address bcp = bs.bcp();
 954     int     len = bs.instruction_size();
 955     assert(len &gt; 0, &quot;length must be &gt; 0&quot;);
 956 
 957     // copy the bytecodes
 958     *p = (unsigned char) (bs.is_wide()? Bytecodes::_wide : code);
 959     if (len &gt; 1) {
 960       memcpy(p+1, bcp+1, len-1);
 961     }
 962 
 963     // During linking the get/put and invoke instructions are rewritten
 964     // with an index into the constant pool cache. The original constant
 965     // pool index must be returned to caller.  Rewrite the index.
 966     if (is_rewritten &amp;&amp; len &gt; 1) {
 967       bool is_wide = false;
 968       switch (code) {
 969       case Bytecodes::_getstatic       :  // fall through
 970       case Bytecodes::_putstatic       :  // fall through
 971       case Bytecodes::_getfield        :  // fall through
 972       case Bytecodes::_putfield        :  // fall through
 973       case Bytecodes::_invokevirtual   :  // fall through
 974       case Bytecodes::_invokespecial   :  // fall through
 975       case Bytecodes::_invokestatic    :  // fall through
 976       case Bytecodes::_invokedynamic   :  // fall through
 977       case Bytecodes::_invokeinterface : {
 978         assert(len == 3 ||
 979                (code == Bytecodes::_invokeinterface &amp;&amp; len == 5) ||
 980                (code == Bytecodes::_invokedynamic   &amp;&amp; len == 5),
 981                &quot;sanity check&quot;);
 982 
 983         int cpci = Bytes::get_native_u2(bcp+1);
 984         bool is_invokedynamic = (code == Bytecodes::_invokedynamic);
 985         ConstantPoolCacheEntry* entry;
 986         if (is_invokedynamic) {
 987           cpci = Bytes::get_native_u4(bcp+1);
 988           entry = mh-&gt;constants()-&gt;invokedynamic_cp_cache_entry_at(cpci);
 989         } else {
 990         // cache cannot be pre-fetched since some classes won&#39;t have it yet
 991           entry = mh-&gt;constants()-&gt;cache()-&gt;entry_at(cpci);
 992         }
 993         int i = entry-&gt;constant_pool_index();
 994         assert(i &lt; mh-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
 995         Bytes::put_Java_u2((address)(p+1), (u2)i);     // java byte ordering
 996         if (is_invokedynamic)  *(p+3) = *(p+4) = 0;
 997         break;
 998       }
 999       case Bytecodes::_ldc_w:
1000         is_wide = true; // fall through
1001       case Bytecodes::_ldc: {
1002         if (bs.raw_code() == Bytecodes::_fast_aldc || bs.raw_code() == Bytecodes::_fast_aldc_w) {
1003           int cpci = is_wide ? Bytes::get_native_u2(bcp+1) : (u1)(*(bcp+1));
1004           int i = mh-&gt;constants()-&gt;object_to_cp_index(cpci);
1005           assert(i &lt; mh-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
1006           if (is_wide) {
1007             Bytes::put_Java_u2((address)(p+1), (u2)i);     // java byte ordering
1008           } else {
1009             *(p+1) = (u1)i;
1010           }
1011         }
1012         break;
1013         }
1014       default:
1015         break;
1016       }
1017     }
1018 
1019     p += len;
1020   }
1021 }
    </pre>
  </body>
</html>
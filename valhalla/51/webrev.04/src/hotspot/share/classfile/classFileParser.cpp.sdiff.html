<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 945 
 946 // Side-effects: populates the _local_interfaces field
 947 void ClassFileParser::parse_interfaces(const ClassFileStream* stream,
 948                                        int itfs_len,
 949                                        ConstantPool* cp,
 950                                        bool is_inline_type,
 951                                        bool* const has_nonstatic_concrete_methods,
 952                                        // FIXME: lots of these functions
 953                                        // declare their parameters as const,
 954                                        // which adds only noise to the code.
 955                                        // Remove the spurious const modifiers.
 956                                        // Many are of the form &quot;const int x&quot;
 957                                        // or &quot;T* const x&quot;.
 958                                        bool* const is_declared_atomic,
 959                                        TRAPS) {
 960   assert(stream != NULL, &quot;invariant&quot;);
 961   assert(cp != NULL, &quot;invariant&quot;);
 962   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 963 
 964   if (itfs_len == 0) {
<span class="line-modified"> 965     _local_interfaces = Universe::the_empty_instance_klass_array();</span>
 966   } else {
 967     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<span class="line-modified"> 968     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);</span>
<span class="line-modified"> 969 </span>
<span class="line-removed"> 970     int index;</span>
 971     for (index = 0; index &lt; itfs_len; index++) {
 972       const u2 interface_index = stream-&gt;get_u2(CHECK);
 973       Klass* interf;
 974       check_property(
 975         valid_klass_reference_at(interface_index),
 976         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 977         interface_index, CHECK);
 978       if (cp-&gt;tag_at(interface_index).is_klass()) {
 979         interf = cp-&gt;resolved_klass_at(interface_index);
 980       } else {
 981         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 982 
 983         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 984         // But need to make sure it&#39;s not an array type.
 985         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 986                            &quot;Bad interface name in class file %s&quot;, CHECK);
 987 
<span class="line-modified"> 988         // Call resolve_super so classcircularity is checked</span>
 989         interf = SystemDictionary::resolve_super_or_fail(
 990                                                   _class_name,
 991                                                   unresolved_klass,
 992                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 993                                                   _protection_domain,
 994                                                   false,
 995                                                   CHECK);
 996       }
 997 
 998       if (!interf-&gt;is_interface()) {
 999         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
1000                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
1001                           _class_name-&gt;as_klass_external_name(),
1002                           interf-&gt;external_name(),
1003                           interf-&gt;class_in_module_of_loader()));
1004       }
1005 
1006       InstanceKlass* ik = InstanceKlass::cast(interf);
1007       if (is_inline_type &amp;&amp; ik-&gt;invalid_inline_super()) {
1008         ResourceMark rm(THREAD);
1009         Exceptions::fthrow(
1010           THREAD_AND_LOCATION,
1011           vmSymbols::java_lang_IncompatibleClassChangeError(),
1012           &quot;Inline type %s attempts to implement interface java.lang.IdentityObject&quot;,
1013           _class_name-&gt;as_klass_external_name());
1014         return;
1015       }
1016       if (ik-&gt;invalid_inline_super()) {
1017         set_invalid_inline_super();
1018       }
1019       if (ik-&gt;has_nonstatic_concrete_methods()) {
1020         *has_nonstatic_concrete_methods = true;
1021       }
1022       if (ik-&gt;is_declared_atomic()) {
1023         *is_declared_atomic = true;
1024       }
<span class="line-modified">1025       _local_interfaces-&gt;at_put(index, ik);</span>



1026     }
1027 
1028     if (!_need_verify || itfs_len &lt;= 1) {
1029       return;
1030     }
1031 
1032     // Check if there&#39;s any duplicates in interfaces
1033     ResourceMark rm(THREAD);
1034     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1035                                                                  NameSigHash*,
1036                                                                  HASH_ROW_SIZE);
1037     initialize_hashtable(interface_names);
1038     bool dup = false;
1039     const Symbol* name = NULL;
1040     {
1041       debug_only(NoSafepointVerifier nsv;)
1042       for (index = 0; index &lt; itfs_len; index++) {
<span class="line-modified">1043         const InstanceKlass* const k = _local_interfaces-&gt;at(index);</span>
1044         name = k-&gt;name();
1045         // If no duplicates, add (name, NULL) in hashtable interface_names.
1046         if (!put_after_lookup(name, NULL, interface_names)) {
1047           dup = true;
1048           break;
1049         }
1050       }
1051     }
1052     if (dup) {
1053       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1054                              name-&gt;as_C_string(), CHECK);
1055     }
1056   }
1057 }
1058 
1059 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1060                                            int constantvalue_index,
1061                                            int signature_index,
1062                                            TRAPS) const {
1063   // Make sure the constant pool entry is of a type appropriate to this field
</pre>
<hr />
<pre>
1822                       0);
1823     const BasicType type = Signature::basic_type(vmSymbols::object_signature());
1824     const FieldAllocationType atype = fac-&gt;update(true, type, false);
1825     field-&gt;set_allocation_type(atype);
1826     index++;
1827   }
1828 
1829   if (is_value_type &amp;&amp; instance_fields_count == 0) {
1830     _is_empty_value = true;
1831     FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1832     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1833         vmSymbols::empty_marker_name_enum,
1834         vmSymbols::byte_signature_enum,
1835         0);
1836     const BasicType type = Signature::basic_type(vmSymbols::byte_signature());
1837     const FieldAllocationType atype = fac-&gt;update(false, type, false);
1838     field-&gt;set_allocation_type(atype);
1839     index++;
1840   }
1841 




1842   assert(NULL == _fields, &quot;invariant&quot;);
1843 
1844   _fields =
1845     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1846                                    index * FieldInfo::field_slots + num_generic_signature,
1847                                    CHECK);
1848   // Sometimes injected fields already exist in the Java source so
1849   // the fields array could be too long.  In that case the
1850   // fields array is trimed. Also unused slots that were reserved
1851   // for generic signature indexes are discarded.
1852   {
1853     int i = 0;
1854     for (; i &lt; index * FieldInfo::field_slots; i++) {
1855       _fields-&gt;at_put(i, fa[i]);
1856     }
1857     for (int j = total_fields * FieldInfo::field_slots;
1858          j &lt; generic_signature_slot; j++) {
1859       _fields-&gt;at_put(i++, fa[j]);
1860     }
1861     assert(_fields-&gt;length() == i, &quot;&quot;);
</pre>
<hr />
<pre>
5010   // Add superclass transitive interfaces size
5011   if (super != NULL) {
5012     super_size = super-&gt;transitive_interfaces()-&gt;length();
5013     max_transitive_size += super_size;
5014   }
5015   // Add local interfaces&#39; super interfaces
5016   const int local_size = local_ifs-&gt;length();
5017   for (int i = 0; i &lt; local_size; i++) {
5018     InstanceKlass* const l = local_ifs-&gt;at(i);
5019     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
5020   }
5021   // Finally add local interfaces
5022   max_transitive_size += local_size;
5023   // Construct array
5024   if (max_transitive_size == 0) {
5025     // no interfaces, use canonicalized array
5026     return Universe::the_empty_instance_klass_array();
5027   } else if (max_transitive_size == super_size) {
5028     // no new local interfaces added, share superklass&#39; transitive interface array
5029     return super-&gt;transitive_interfaces();
<span class="line-modified">5030   } else if (max_transitive_size == local_size) {</span>
<span class="line-modified">5031     // only local interfaces added, share local interface array</span>
<span class="line-modified">5032     return local_ifs;</span>

5033   } else {
5034     ResourceMark rm;
5035     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
5036 
5037     // Copy down from superclass
5038     if (super != NULL) {
5039       append_interfaces(result, super-&gt;transitive_interfaces());
5040     }
5041 
5042     // Copy down from local interfaces&#39; superinterfaces
5043     for (int i = 0; i &lt; local_size; i++) {
5044       InstanceKlass* const l = local_ifs-&gt;at(i);
5045       append_interfaces(result, l-&gt;transitive_interfaces());
5046     }
5047     // Finally add local interfaces
5048     append_interfaces(result, local_ifs);
5049 
5050     // length will be less than the max_transitive_size if duplicates were removed
5051     const int length = result-&gt;length();
5052     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
</pre>
<hr />
<pre>
6064                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
6065     }
6066   }
6067 
6068   if (ik-&gt;is_value()) {
6069     ValueKlass* vk = ValueKlass::cast(ik);
6070     oop val = ik-&gt;allocate_instance(CHECK_NULL);
6071     vk-&gt;set_default_value(val);
6072   }
6073 
6074   return ik;
6075 }
6076 
6077 // Return true if the specified class is not a valid super class for an inline type.
6078 // A valid super class for an inline type is abstract, has no instance fields,
6079 // does not implement interface java.lang.IdentityObject (checked elsewhere), has
6080 // an empty body-less no-arg constructor, and no synchronized instance methods.
6081 // This function doesn&#39;t check if the class&#39;s super types are invalid.  Those checks
6082 // are done elsewhere.  The final determination of whether or not a class is an
6083 // invalid super type for an inline class is done in fill_instance_klass().
<span class="line-modified">6084 static bool is_invalid_super_for_inline_type(const InstanceKlass* ik) {</span>
<span class="line-modified">6085   if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {</span>
6086     return true;
6087   }
<span class="line-modified">6088   if (ik-&gt;is_interface() || ik-&gt;name() == vmSymbols::java_lang_Object()) {</span>
6089     return false;
6090   }
<span class="line-modified">6091   if (!ik-&gt;is_abstract() || ik-&gt;has_nonstatic_fields()) {</span>
6092     return true;
6093   } else {
<span class="line-modified">6094     Array&lt;Method*&gt;* methods = ik-&gt;methods();</span>
<span class="line-modified">6095     // Look at each method.</span>
<span class="line-modified">6096     for (int x = 0; x &lt; methods-&gt;length(); x++) {</span>
<span class="line-removed">6097       const Method* const method = methods-&gt;at(x);</span>
6098       if (method-&gt;is_synchronized() &amp;&amp; !method-&gt;is_static()) {
6099         return true;
6100 
6101       } else if (method-&gt;name() == vmSymbols::object_initializer_name()) {
6102         if (method-&gt;signature() != vmSymbols::void_method_signature() ||
6103             !method-&gt;is_vanilla_constructor()) {
6104           return true;
6105         }
6106       }
6107     }
6108   }
6109   return false;
6110 }
6111 
6112 void ClassFileParser::fill_instance_klass(InstanceKlass* ik, bool changed_by_loadhook, TRAPS) {
6113   assert(ik != NULL, &quot;invariant&quot;);
6114 
6115   // Set name and CLD before adding to CLD
6116   ik-&gt;set_class_loader_data(_loader_data);
6117   ik-&gt;set_name(_class_name);
</pre>
<hr />
<pre>
6127   assert(_field_info != NULL, &quot;invariant&quot;);
6128   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
6129   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
6130          &quot;sanity&quot;);
6131 
6132   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
6133   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
6134 
6135   // Fill in information already parsed
6136   ik-&gt;set_should_verify_class(_need_verify);
6137 
6138   // Not yet: supers are done below to support the new subtype-checking fields
6139   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
6140   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
6141   if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_value()) {
6142     ik-&gt;set_is_naturally_atomic();
6143   }
6144   if (_is_empty_value) {
6145     ik-&gt;set_is_empty_value();
6146   }









6147   assert(_fac != NULL, &quot;invariant&quot;);
6148   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);
6149 
6150   // this transfers ownership of a lot of arrays from
6151   // the parser onto the InstanceKlass*
6152   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6153 
6154   // note that is not safe to use the fields in the parser from this point on
6155   assert(NULL == _cp, &quot;invariant&quot;);
6156   assert(NULL == _fields, &quot;invariant&quot;);
6157   assert(NULL == _methods, &quot;invariant&quot;);
6158   assert(NULL == _inner_classes, &quot;invariant&quot;);
6159   assert(NULL == _nest_members, &quot;invariant&quot;);
6160   assert(NULL == _local_interfaces, &quot;invariant&quot;);
6161   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6162   assert(NULL == _record_components, &quot;invariant&quot;);
6163 
6164   if (_has_final_method) {
6165     ik-&gt;set_has_final_method();
6166   }
</pre>
<hr />
<pre>
6354       // print out the superclass.
6355       const char * from = ik-&gt;external_name();
6356       if (ik-&gt;java_super() != NULL) {
6357         log_debug(class, resolve)(&quot;%s %s (super)&quot;,
6358                    from,
6359                    ik-&gt;java_super()-&gt;external_name());
6360       }
6361       // print out each of the interface classes referred to by this class.
6362       const Array&lt;InstanceKlass*&gt;* const local_interfaces = ik-&gt;local_interfaces();
6363       if (local_interfaces != NULL) {
6364         const int length = local_interfaces-&gt;length();
6365         for (int i = 0; i &lt; length; i++) {
6366           const InstanceKlass* const k = local_interfaces-&gt;at(i);
6367           const char * to = k-&gt;external_name();
6368           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
6369         }
6370       }
6371     }
6372   }
6373 
<span class="line-removed">6374   // Set ik-&gt;invalid_inline_super field to TRUE if already marked as invalid,</span>
<span class="line-removed">6375   // if super is marked invalid, or if is_invalid_super_for_inline_type()</span>
<span class="line-removed">6376   // returns true</span>
<span class="line-removed">6377   if (invalid_inline_super() ||</span>
<span class="line-removed">6378       (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||</span>
<span class="line-removed">6379       is_invalid_super_for_inline_type(ik)) {</span>
<span class="line-removed">6380     ik-&gt;set_invalid_inline_super();</span>
<span class="line-removed">6381   }</span>
<span class="line-removed">6382 </span>
6383   JFR_ONLY(INIT_ID(ik);)
6384 
6385   // If we reach here, all is well.
6386   // Now remove the InstanceKlass* from the _klass_to_deallocate field
6387   // in order for it to not be destroyed in the ClassFileParser destructor.
6388   set_klass_to_deallocate(NULL);
6389 
6390   // it&#39;s official
6391   set_klass(ik);
6392 
6393   debug_only(ik-&gt;verify();)
6394 }
6395 
6396 void ClassFileParser::update_class_name(Symbol* new_class_name) {
6397   // Decrement the refcount in the old name, since we&#39;re clobbering it.
6398   _class_name-&gt;decrement_refcount();
6399 
6400   _class_name = new_class_name;
6401   // Increment the refcount of the new name.
6402   // Now the ClassFileParser owns this name and will decrement in
</pre>
<hr />
<pre>
6476                                  Publicity pub_level,
6477                                  TRAPS) :
6478   _stream(stream),
6479   _requested_name(name),
6480   _class_name(NULL),
6481   _loader_data(loader_data),
6482   _unsafe_anonymous_host(unsafe_anonymous_host),
6483   _cp_patches(cp_patches),
6484   _num_patched_klasses(0),
6485   _max_num_patched_klasses(0),
6486   _orig_cp_size(0),
6487   _first_patched_klass_resolved_index(0),
6488   _super_klass(),
6489   _cp(NULL),
6490   _fields(NULL),
6491   _methods(NULL),
6492   _inner_classes(NULL),
6493   _nest_members(NULL),
6494   _nest_host(0),
6495   _record_components(NULL),

6496   _local_interfaces(NULL),
6497   _transitive_interfaces(NULL),
6498   _combined_annotations(NULL),
6499   _class_annotations(NULL),
6500   _class_type_annotations(NULL),
6501   _fields_annotations(NULL),
6502   _fields_type_annotations(NULL),
6503   _klass(NULL),
6504   _klass_to_deallocate(NULL),
6505   _parsed_annotations(NULL),
6506   _fac(NULL),
6507   _field_info(NULL),
6508   _method_ordering(NULL),
6509   _all_mirandas(NULL),
6510   _vtable_size(0),
6511   _itable_size(0),
6512   _num_miranda_methods(0),
6513   _rt(REF_NONE),
6514   _protection_domain(protection_domain),
6515   _access_flags(),
6516   _pub_level(pub_level),
6517   _bad_constant_seen(0),
6518   _synthetic_flag(false),
6519   _sde_length(false),
6520   _sde_buffer(NULL),
6521   _sourcefile_index(0),
6522   _generic_signature_index(0),
6523   _major_version(0),
6524   _minor_version(0),
6525   _this_class_index(0),
6526   _super_class_index(0),
6527   _itfs_len(0),
6528   _java_fields_count(0),
6529   _need_verify(false),
6530   _relax_verify(false),
6531   _has_nonstatic_concrete_methods(false),
6532   _declares_nonstatic_concrete_methods(false),
6533   _has_final_method(false),
6534   _has_contended_fields(false),
6535   _has_flattenable_fields(false),

6536   _is_empty_value(false),
6537   _is_naturally_atomic(false),
6538   _is_declared_atomic(false),
6539   _invalid_inline_super(false),
6540   _invalid_identity_super(false),


6541   _has_finalizer(false),
6542   _has_empty_finalizer(false),
6543   _has_vanilla_constructor(false),
6544   _max_bootstrap_specifier_index(-1) {
6545 
6546   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6547   _class_name-&gt;increment_refcount();
6548 
6549   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6550   assert(_loader_data != NULL, &quot;invariant&quot;);
6551   assert(stream != NULL, &quot;invariant&quot;);
6552   assert(_stream != NULL, &quot;invariant&quot;);
6553   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6554   assert(_class_name != NULL, &quot;invariant&quot;);
6555   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6556 
6557   // Figure out whether we can skip format checking (matching classic VM behavior)
6558   if (DumpSharedSpaces) {
6559     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6560     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
6864 #endif
6865   }
6866 
6867   // SUPERKLASS
6868   _super_class_index = stream-&gt;get_u2_fast();
6869   _super_klass = parse_super_class(cp,
6870                                    _super_class_index,
6871                                    _need_verify,
6872                                    CHECK);
6873 
6874   // Interfaces
6875   _itfs_len = stream-&gt;get_u2_fast();
6876   parse_interfaces(stream,
6877                    _itfs_len,
6878                    cp,
6879                    is_value_type(),
6880                    &amp;_has_nonstatic_concrete_methods,
6881                    &amp;_is_declared_atomic,
6882                    CHECK);
6883 
<span class="line-modified">6884   assert(_local_interfaces != NULL, &quot;invariant&quot;);</span>
6885 
6886   // Fields (offsets are filled in later)
6887   _fac = new FieldAllocationCount();
6888   parse_fields(stream,
6889                is_interface(),
6890                is_value_type(),
6891                _fac,
6892                cp,
6893                cp_size,
6894                &amp;_java_fields_count,
6895                CHECK);
6896 
6897   assert(_fields != NULL, &quot;invariant&quot;);
6898 
6899   // Methods
6900   AccessFlags promoted_flags;
6901   parse_methods(stream,
6902                 is_interface(),
6903                 is_value_type(),
6904                 &amp;promoted_flags,
</pre>
<hr />
<pre>
6925   // now that all annotation arrays have been created.
6926   create_combined_annotations(CHECK);
6927 
6928   // Make sure this is the end of class file stream
6929   guarantee_property(stream-&gt;at_eos(),
6930                      &quot;Extra bytes at the end of class file %s&quot;,
6931                      CHECK);
6932 
6933   // all bytes in stream read and parsed
6934 }
6935 
6936 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6937                                                  ConstantPool* cp,
6938                                                  TRAPS) {
6939   assert(stream != NULL, &quot;invariant&quot;);
6940   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6941   assert(cp != NULL, &quot;invariant&quot;);
6942   assert(_loader_data != NULL, &quot;invariant&quot;);
6943 
6944   if (_class_name == vmSymbols::java_lang_Object()) {
<span class="line-modified">6945     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),</span>
<span class="line-modified">6946                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,</span>
<span class="line-modified">6947                    CHECK);</span>
6948   }
6949   // We check super class after class file is parsed and format is checked
6950   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6951     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
6952     if (is_interface()) {
6953       // Before attempting to resolve the superclass, check for class format
6954       // errors not checked yet.
6955       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6956         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6957         CHECK);
6958     }
6959     Handle loader(THREAD, _loader_data-&gt;class_loader());
6960     _super_klass = (const InstanceKlass*)
6961                        SystemDictionary::resolve_super_or_fail(_class_name,
6962                                                                super_class_name,
6963                                                                loader,
6964                                                                _protection_domain,
6965                                                                true,
6966                                                                CHECK);
6967   }
</pre>
<hr />
<pre>
7003           &quot;inline class %s has an invalid super class %s&quot;,
7004           _class_name-&gt;as_klass_external_name(),
7005           _super_klass-&gt;external_name());
7006         return;
7007       }
7008     }
7009   }
7010 
7011   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {
7012     // This is the original source of this condition.
7013     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.
7014     _is_declared_atomic = true;
7015   } else if (*ForceNonTearable != &#39;\0&#39;) {
7016     // Allow a command line switch to force the same atomicity property:
7017     const char* class_name_str = _class_name-&gt;as_C_string();
7018     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {
7019       _is_declared_atomic = true;
7020     }
7021   }
7022 


























7023   // Compute the transitive list of all unique interfaces implemented by this class
7024   _transitive_interfaces =
7025     compute_transitive_interfaces(_super_klass,
7026                                   _local_interfaces,
7027                                   _loader_data,
7028                                   CHECK);
7029 
7030   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
7031 
7032   // sort methods
7033   _method_ordering = sort_methods(_methods);
7034 
7035   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
7036 
7037   Handle loader(THREAD, _loader_data-&gt;class_loader());
7038   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
7039                                                     &amp;_num_miranda_methods,
7040                                                     _all_mirandas,
7041                                                     _super_klass,
7042                                                     _methods,
</pre>
</td>
<td>
<hr />
<pre>
 945 
 946 // Side-effects: populates the _local_interfaces field
 947 void ClassFileParser::parse_interfaces(const ClassFileStream* stream,
 948                                        int itfs_len,
 949                                        ConstantPool* cp,
 950                                        bool is_inline_type,
 951                                        bool* const has_nonstatic_concrete_methods,
 952                                        // FIXME: lots of these functions
 953                                        // declare their parameters as const,
 954                                        // which adds only noise to the code.
 955                                        // Remove the spurious const modifiers.
 956                                        // Many are of the form &quot;const int x&quot;
 957                                        // or &quot;T* const x&quot;.
 958                                        bool* const is_declared_atomic,
 959                                        TRAPS) {
 960   assert(stream != NULL, &quot;invariant&quot;);
 961   assert(cp != NULL, &quot;invariant&quot;);
 962   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 963 
 964   if (itfs_len == 0) {
<span class="line-modified"> 965     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(0);</span>
 966   } else {
 967     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<span class="line-modified"> 968     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(itfs_len);</span>
<span class="line-modified"> 969     int index = 0;</span>

 970     for (index = 0; index &lt; itfs_len; index++) {
 971       const u2 interface_index = stream-&gt;get_u2(CHECK);
 972       Klass* interf;
 973       check_property(
 974         valid_klass_reference_at(interface_index),
 975         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 976         interface_index, CHECK);
 977       if (cp-&gt;tag_at(interface_index).is_klass()) {
 978         interf = cp-&gt;resolved_klass_at(interface_index);
 979       } else {
 980         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 981 
 982         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 983         // But need to make sure it&#39;s not an array type.
 984         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 985                            &quot;Bad interface name in class file %s&quot;, CHECK);
 986 
<span class="line-modified"> 987         // Call resolve_super so class circularity is checked</span>
 988         interf = SystemDictionary::resolve_super_or_fail(
 989                                                   _class_name,
 990                                                   unresolved_klass,
 991                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 992                                                   _protection_domain,
 993                                                   false,
 994                                                   CHECK);
 995       }
 996 
 997       if (!interf-&gt;is_interface()) {
 998         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 999                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
1000                           _class_name-&gt;as_klass_external_name(),
1001                           interf-&gt;external_name(),
1002                           interf-&gt;class_in_module_of_loader()));
1003       }
1004 
1005       InstanceKlass* ik = InstanceKlass::cast(interf);
1006       if (is_inline_type &amp;&amp; ik-&gt;invalid_inline_super()) {
1007         ResourceMark rm(THREAD);
1008         Exceptions::fthrow(
1009           THREAD_AND_LOCATION,
1010           vmSymbols::java_lang_IncompatibleClassChangeError(),
1011           &quot;Inline type %s attempts to implement interface java.lang.IdentityObject&quot;,
1012           _class_name-&gt;as_klass_external_name());
1013         return;
1014       }
1015       if (ik-&gt;invalid_inline_super()) {
1016         set_invalid_inline_super();
1017       }
1018       if (ik-&gt;has_nonstatic_concrete_methods()) {
1019         *has_nonstatic_concrete_methods = true;
1020       }
1021       if (ik-&gt;is_declared_atomic()) {
1022         *is_declared_atomic = true;
1023       }
<span class="line-modified">1024       if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">1025         _implements_identityObject = true;</span>
<span class="line-added">1026       }</span>
<span class="line-added">1027       _temp_local_interfaces-&gt;append(ik);</span>
1028     }
1029 
1030     if (!_need_verify || itfs_len &lt;= 1) {
1031       return;
1032     }
1033 
1034     // Check if there&#39;s any duplicates in interfaces
1035     ResourceMark rm(THREAD);
1036     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1037                                                                  NameSigHash*,
1038                                                                  HASH_ROW_SIZE);
1039     initialize_hashtable(interface_names);
1040     bool dup = false;
1041     const Symbol* name = NULL;
1042     {
1043       debug_only(NoSafepointVerifier nsv;)
1044       for (index = 0; index &lt; itfs_len; index++) {
<span class="line-modified">1045         const InstanceKlass* const k = _temp_local_interfaces-&gt;at(index);</span>
1046         name = k-&gt;name();
1047         // If no duplicates, add (name, NULL) in hashtable interface_names.
1048         if (!put_after_lookup(name, NULL, interface_names)) {
1049           dup = true;
1050           break;
1051         }
1052       }
1053     }
1054     if (dup) {
1055       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1056                              name-&gt;as_C_string(), CHECK);
1057     }
1058   }
1059 }
1060 
1061 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1062                                            int constantvalue_index,
1063                                            int signature_index,
1064                                            TRAPS) const {
1065   // Make sure the constant pool entry is of a type appropriate to this field
</pre>
<hr />
<pre>
1824                       0);
1825     const BasicType type = Signature::basic_type(vmSymbols::object_signature());
1826     const FieldAllocationType atype = fac-&gt;update(true, type, false);
1827     field-&gt;set_allocation_type(atype);
1828     index++;
1829   }
1830 
1831   if (is_value_type &amp;&amp; instance_fields_count == 0) {
1832     _is_empty_value = true;
1833     FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1834     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1835         vmSymbols::empty_marker_name_enum,
1836         vmSymbols::byte_signature_enum,
1837         0);
1838     const BasicType type = Signature::basic_type(vmSymbols::byte_signature());
1839     const FieldAllocationType atype = fac-&gt;update(false, type, false);
1840     field-&gt;set_allocation_type(atype);
1841     index++;
1842   }
1843 
<span class="line-added">1844   if (instance_fields_count &gt; 0) {</span>
<span class="line-added">1845     _has_nonstatic_fields = true;</span>
<span class="line-added">1846   }</span>
<span class="line-added">1847 </span>
1848   assert(NULL == _fields, &quot;invariant&quot;);
1849 
1850   _fields =
1851     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1852                                    index * FieldInfo::field_slots + num_generic_signature,
1853                                    CHECK);
1854   // Sometimes injected fields already exist in the Java source so
1855   // the fields array could be too long.  In that case the
1856   // fields array is trimed. Also unused slots that were reserved
1857   // for generic signature indexes are discarded.
1858   {
1859     int i = 0;
1860     for (; i &lt; index * FieldInfo::field_slots; i++) {
1861       _fields-&gt;at_put(i, fa[i]);
1862     }
1863     for (int j = total_fields * FieldInfo::field_slots;
1864          j &lt; generic_signature_slot; j++) {
1865       _fields-&gt;at_put(i++, fa[j]);
1866     }
1867     assert(_fields-&gt;length() == i, &quot;&quot;);
</pre>
<hr />
<pre>
5016   // Add superclass transitive interfaces size
5017   if (super != NULL) {
5018     super_size = super-&gt;transitive_interfaces()-&gt;length();
5019     max_transitive_size += super_size;
5020   }
5021   // Add local interfaces&#39; super interfaces
5022   const int local_size = local_ifs-&gt;length();
5023   for (int i = 0; i &lt; local_size; i++) {
5024     InstanceKlass* const l = local_ifs-&gt;at(i);
5025     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
5026   }
5027   // Finally add local interfaces
5028   max_transitive_size += local_size;
5029   // Construct array
5030   if (max_transitive_size == 0) {
5031     // no interfaces, use canonicalized array
5032     return Universe::the_empty_instance_klass_array();
5033   } else if (max_transitive_size == super_size) {
5034     // no new local interfaces added, share superklass&#39; transitive interface array
5035     return super-&gt;transitive_interfaces();
<span class="line-modified">5036     // The three lines below are commented to work around bug JDK-8245487</span>
<span class="line-modified">5037 //  } else if (max_transitive_size == local_size) {</span>
<span class="line-modified">5038 //    // only local interfaces added, share local interface array</span>
<span class="line-added">5039 //    return local_ifs;</span>
5040   } else {
5041     ResourceMark rm;
5042     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
5043 
5044     // Copy down from superclass
5045     if (super != NULL) {
5046       append_interfaces(result, super-&gt;transitive_interfaces());
5047     }
5048 
5049     // Copy down from local interfaces&#39; superinterfaces
5050     for (int i = 0; i &lt; local_size; i++) {
5051       InstanceKlass* const l = local_ifs-&gt;at(i);
5052       append_interfaces(result, l-&gt;transitive_interfaces());
5053     }
5054     // Finally add local interfaces
5055     append_interfaces(result, local_ifs);
5056 
5057     // length will be less than the max_transitive_size if duplicates were removed
5058     const int length = result-&gt;length();
5059     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
</pre>
<hr />
<pre>
6071                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
6072     }
6073   }
6074 
6075   if (ik-&gt;is_value()) {
6076     ValueKlass* vk = ValueKlass::cast(ik);
6077     oop val = ik-&gt;allocate_instance(CHECK_NULL);
6078     vk-&gt;set_default_value(val);
6079   }
6080 
6081   return ik;
6082 }
6083 
6084 // Return true if the specified class is not a valid super class for an inline type.
6085 // A valid super class for an inline type is abstract, has no instance fields,
6086 // does not implement interface java.lang.IdentityObject (checked elsewhere), has
6087 // an empty body-less no-arg constructor, and no synchronized instance methods.
6088 // This function doesn&#39;t check if the class&#39;s super types are invalid.  Those checks
6089 // are done elsewhere.  The final determination of whether or not a class is an
6090 // invalid super type for an inline class is done in fill_instance_klass().
<span class="line-modified">6091 bool ClassFileParser::is_invalid_super_for_inline_type() {</span>
<span class="line-modified">6092   if (class_name() == vmSymbols::java_lang_IdentityObject()) {</span>
6093     return true;
6094   }
<span class="line-modified">6095   if (is_interface() || class_name() == vmSymbols::java_lang_Object()) {</span>
6096     return false;
6097   }
<span class="line-modified">6098   if (!access_flags().is_abstract() || _has_nonstatic_fields) {</span>
6099     return true;
6100   } else {
<span class="line-modified">6101     // Look at each method</span>
<span class="line-modified">6102     for (int x = 0; x &lt; _methods-&gt;length(); x++) {</span>
<span class="line-modified">6103       const Method* const method = _methods-&gt;at(x);</span>

6104       if (method-&gt;is_synchronized() &amp;&amp; !method-&gt;is_static()) {
6105         return true;
6106 
6107       } else if (method-&gt;name() == vmSymbols::object_initializer_name()) {
6108         if (method-&gt;signature() != vmSymbols::void_method_signature() ||
6109             !method-&gt;is_vanilla_constructor()) {
6110           return true;
6111         }
6112       }
6113     }
6114   }
6115   return false;
6116 }
6117 
6118 void ClassFileParser::fill_instance_klass(InstanceKlass* ik, bool changed_by_loadhook, TRAPS) {
6119   assert(ik != NULL, &quot;invariant&quot;);
6120 
6121   // Set name and CLD before adding to CLD
6122   ik-&gt;set_class_loader_data(_loader_data);
6123   ik-&gt;set_name(_class_name);
</pre>
<hr />
<pre>
6133   assert(_field_info != NULL, &quot;invariant&quot;);
6134   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
6135   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
6136          &quot;sanity&quot;);
6137 
6138   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
6139   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
6140 
6141   // Fill in information already parsed
6142   ik-&gt;set_should_verify_class(_need_verify);
6143 
6144   // Not yet: supers are done below to support the new subtype-checking fields
6145   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
6146   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
6147   if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_value()) {
6148     ik-&gt;set_is_naturally_atomic();
6149   }
6150   if (_is_empty_value) {
6151     ik-&gt;set_is_empty_value();
6152   }
<span class="line-added">6153 </span>
<span class="line-added">6154   if (this-&gt;_invalid_inline_super) {</span>
<span class="line-added">6155     ik-&gt;set_invalid_inline_super();</span>
<span class="line-added">6156   }</span>
<span class="line-added">6157 </span>
<span class="line-added">6158   if (_has_injected_identityObject) {</span>
<span class="line-added">6159     ik-&gt;set_has_injected_identityObject();</span>
<span class="line-added">6160   }</span>
<span class="line-added">6161 </span>
6162   assert(_fac != NULL, &quot;invariant&quot;);
6163   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);
6164 
6165   // this transfers ownership of a lot of arrays from
6166   // the parser onto the InstanceKlass*
6167   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6168 
6169   // note that is not safe to use the fields in the parser from this point on
6170   assert(NULL == _cp, &quot;invariant&quot;);
6171   assert(NULL == _fields, &quot;invariant&quot;);
6172   assert(NULL == _methods, &quot;invariant&quot;);
6173   assert(NULL == _inner_classes, &quot;invariant&quot;);
6174   assert(NULL == _nest_members, &quot;invariant&quot;);
6175   assert(NULL == _local_interfaces, &quot;invariant&quot;);
6176   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6177   assert(NULL == _record_components, &quot;invariant&quot;);
6178 
6179   if (_has_final_method) {
6180     ik-&gt;set_has_final_method();
6181   }
</pre>
<hr />
<pre>
6369       // print out the superclass.
6370       const char * from = ik-&gt;external_name();
6371       if (ik-&gt;java_super() != NULL) {
6372         log_debug(class, resolve)(&quot;%s %s (super)&quot;,
6373                    from,
6374                    ik-&gt;java_super()-&gt;external_name());
6375       }
6376       // print out each of the interface classes referred to by this class.
6377       const Array&lt;InstanceKlass*&gt;* const local_interfaces = ik-&gt;local_interfaces();
6378       if (local_interfaces != NULL) {
6379         const int length = local_interfaces-&gt;length();
6380         for (int i = 0; i &lt; length; i++) {
6381           const InstanceKlass* const k = local_interfaces-&gt;at(i);
6382           const char * to = k-&gt;external_name();
6383           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
6384         }
6385       }
6386     }
6387   }
6388 









6389   JFR_ONLY(INIT_ID(ik);)
6390 
6391   // If we reach here, all is well.
6392   // Now remove the InstanceKlass* from the _klass_to_deallocate field
6393   // in order for it to not be destroyed in the ClassFileParser destructor.
6394   set_klass_to_deallocate(NULL);
6395 
6396   // it&#39;s official
6397   set_klass(ik);
6398 
6399   debug_only(ik-&gt;verify();)
6400 }
6401 
6402 void ClassFileParser::update_class_name(Symbol* new_class_name) {
6403   // Decrement the refcount in the old name, since we&#39;re clobbering it.
6404   _class_name-&gt;decrement_refcount();
6405 
6406   _class_name = new_class_name;
6407   // Increment the refcount of the new name.
6408   // Now the ClassFileParser owns this name and will decrement in
</pre>
<hr />
<pre>
6482                                  Publicity pub_level,
6483                                  TRAPS) :
6484   _stream(stream),
6485   _requested_name(name),
6486   _class_name(NULL),
6487   _loader_data(loader_data),
6488   _unsafe_anonymous_host(unsafe_anonymous_host),
6489   _cp_patches(cp_patches),
6490   _num_patched_klasses(0),
6491   _max_num_patched_klasses(0),
6492   _orig_cp_size(0),
6493   _first_patched_klass_resolved_index(0),
6494   _super_klass(),
6495   _cp(NULL),
6496   _fields(NULL),
6497   _methods(NULL),
6498   _inner_classes(NULL),
6499   _nest_members(NULL),
6500   _nest_host(0),
6501   _record_components(NULL),
<span class="line-added">6502   _temp_local_interfaces(NULL),</span>
6503   _local_interfaces(NULL),
6504   _transitive_interfaces(NULL),
6505   _combined_annotations(NULL),
6506   _class_annotations(NULL),
6507   _class_type_annotations(NULL),
6508   _fields_annotations(NULL),
6509   _fields_type_annotations(NULL),
6510   _klass(NULL),
6511   _klass_to_deallocate(NULL),
6512   _parsed_annotations(NULL),
6513   _fac(NULL),
6514   _field_info(NULL),
6515   _method_ordering(NULL),
6516   _all_mirandas(NULL),
6517   _vtable_size(0),
6518   _itable_size(0),
6519   _num_miranda_methods(0),
6520   _rt(REF_NONE),
6521   _protection_domain(protection_domain),
6522   _access_flags(),
6523   _pub_level(pub_level),
6524   _bad_constant_seen(0),
6525   _synthetic_flag(false),
6526   _sde_length(false),
6527   _sde_buffer(NULL),
6528   _sourcefile_index(0),
6529   _generic_signature_index(0),
6530   _major_version(0),
6531   _minor_version(0),
6532   _this_class_index(0),
6533   _super_class_index(0),
6534   _itfs_len(0),
6535   _java_fields_count(0),
6536   _need_verify(false),
6537   _relax_verify(false),
6538   _has_nonstatic_concrete_methods(false),
6539   _declares_nonstatic_concrete_methods(false),
6540   _has_final_method(false),
6541   _has_contended_fields(false),
6542   _has_flattenable_fields(false),
<span class="line-added">6543   _has_nonstatic_fields(false),</span>
6544   _is_empty_value(false),
6545   _is_naturally_atomic(false),
6546   _is_declared_atomic(false),
6547   _invalid_inline_super(false),
6548   _invalid_identity_super(false),
<span class="line-added">6549   _implements_identityObject(false),</span>
<span class="line-added">6550   _has_injected_identityObject(false),</span>
6551   _has_finalizer(false),
6552   _has_empty_finalizer(false),
6553   _has_vanilla_constructor(false),
6554   _max_bootstrap_specifier_index(-1) {
6555 
6556   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6557   _class_name-&gt;increment_refcount();
6558 
6559   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6560   assert(_loader_data != NULL, &quot;invariant&quot;);
6561   assert(stream != NULL, &quot;invariant&quot;);
6562   assert(_stream != NULL, &quot;invariant&quot;);
6563   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6564   assert(_class_name != NULL, &quot;invariant&quot;);
6565   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6566 
6567   // Figure out whether we can skip format checking (matching classic VM behavior)
6568   if (DumpSharedSpaces) {
6569     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6570     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
6874 #endif
6875   }
6876 
6877   // SUPERKLASS
6878   _super_class_index = stream-&gt;get_u2_fast();
6879   _super_klass = parse_super_class(cp,
6880                                    _super_class_index,
6881                                    _need_verify,
6882                                    CHECK);
6883 
6884   // Interfaces
6885   _itfs_len = stream-&gt;get_u2_fast();
6886   parse_interfaces(stream,
6887                    _itfs_len,
6888                    cp,
6889                    is_value_type(),
6890                    &amp;_has_nonstatic_concrete_methods,
6891                    &amp;_is_declared_atomic,
6892                    CHECK);
6893 
<span class="line-modified">6894   assert(_temp_local_interfaces != NULL, &quot;invariant&quot;);</span>
6895 
6896   // Fields (offsets are filled in later)
6897   _fac = new FieldAllocationCount();
6898   parse_fields(stream,
6899                is_interface(),
6900                is_value_type(),
6901                _fac,
6902                cp,
6903                cp_size,
6904                &amp;_java_fields_count,
6905                CHECK);
6906 
6907   assert(_fields != NULL, &quot;invariant&quot;);
6908 
6909   // Methods
6910   AccessFlags promoted_flags;
6911   parse_methods(stream,
6912                 is_interface(),
6913                 is_value_type(),
6914                 &amp;promoted_flags,
</pre>
<hr />
<pre>
6935   // now that all annotation arrays have been created.
6936   create_combined_annotations(CHECK);
6937 
6938   // Make sure this is the end of class file stream
6939   guarantee_property(stream-&gt;at_eos(),
6940                      &quot;Extra bytes at the end of class file %s&quot;,
6941                      CHECK);
6942 
6943   // all bytes in stream read and parsed
6944 }
6945 
6946 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6947                                                  ConstantPool* cp,
6948                                                  TRAPS) {
6949   assert(stream != NULL, &quot;invariant&quot;);
6950   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6951   assert(cp != NULL, &quot;invariant&quot;);
6952   assert(_loader_data != NULL, &quot;invariant&quot;);
6953 
6954   if (_class_name == vmSymbols::java_lang_Object()) {
<span class="line-modified">6955     check_property(_temp_local_interfaces-&gt;length() == 0,</span>
<span class="line-modified">6956         &quot;java.lang.Object cannot implement an interface in class file %s&quot;,</span>
<span class="line-modified">6957         CHECK);</span>
6958   }
6959   // We check super class after class file is parsed and format is checked
6960   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6961     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
6962     if (is_interface()) {
6963       // Before attempting to resolve the superclass, check for class format
6964       // errors not checked yet.
6965       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6966         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6967         CHECK);
6968     }
6969     Handle loader(THREAD, _loader_data-&gt;class_loader());
6970     _super_klass = (const InstanceKlass*)
6971                        SystemDictionary::resolve_super_or_fail(_class_name,
6972                                                                super_class_name,
6973                                                                loader,
6974                                                                _protection_domain,
6975                                                                true,
6976                                                                CHECK);
6977   }
</pre>
<hr />
<pre>
7013           &quot;inline class %s has an invalid super class %s&quot;,
7014           _class_name-&gt;as_klass_external_name(),
7015           _super_klass-&gt;external_name());
7016         return;
7017       }
7018     }
7019   }
7020 
7021   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {
7022     // This is the original source of this condition.
7023     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.
7024     _is_declared_atomic = true;
7025   } else if (*ForceNonTearable != &#39;\0&#39;) {
7026     // Allow a command line switch to force the same atomicity property:
7027     const char* class_name_str = _class_name-&gt;as_C_string();
7028     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {
7029       _is_declared_atomic = true;
7030     }
7031   }
7032 
<span class="line-added">7033   // Set ik-&gt;invalid_inline_super field to TRUE if already marked as invalid,</span>
<span class="line-added">7034   // if super is marked invalid, or if is_invalid_super_for_inline_type()</span>
<span class="line-added">7035   // returns true</span>
<span class="line-added">7036   if (invalid_inline_super() ||</span>
<span class="line-added">7037       (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||</span>
<span class="line-added">7038       is_invalid_super_for_inline_type()) {</span>
<span class="line-added">7039     set_invalid_inline_super();</span>
<span class="line-added">7040   }</span>
<span class="line-added">7041 </span>
<span class="line-added">7042   if (!is_value_type() &amp;&amp; invalid_inline_super() &amp;&amp; (_super_klass == NULL || !_super_klass-&gt;invalid_inline_super())</span>
<span class="line-added">7043       &amp;&amp; !_implements_identityObject &amp;&amp; class_name() != vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">7044     _temp_local_interfaces-&gt;append(SystemDictionary::IdentityObject_klass());</span>
<span class="line-added">7045     _has_injected_identityObject = true;</span>
<span class="line-added">7046   }</span>
<span class="line-added">7047   int itfs_len = _temp_local_interfaces-&gt;length();</span>
<span class="line-added">7048   if (itfs_len == 0) {</span>
<span class="line-added">7049     _local_interfaces = Universe::the_empty_instance_klass_array();</span>
<span class="line-added">7050   } else {</span>
<span class="line-added">7051     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);</span>
<span class="line-added">7052     for (int i = 0; i &lt; itfs_len; i++) {</span>
<span class="line-added">7053       _local_interfaces-&gt;at_put(i, _temp_local_interfaces-&gt;at(i));</span>
<span class="line-added">7054     }</span>
<span class="line-added">7055   }</span>
<span class="line-added">7056   _temp_local_interfaces = NULL;</span>
<span class="line-added">7057   assert(_local_interfaces != NULL, &quot;invariant&quot;);</span>
<span class="line-added">7058 </span>
7059   // Compute the transitive list of all unique interfaces implemented by this class
7060   _transitive_interfaces =
7061     compute_transitive_interfaces(_super_klass,
7062                                   _local_interfaces,
7063                                   _loader_data,
7064                                   CHECK);
7065 
7066   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
7067 
7068   // sort methods
7069   _method_ordering = sort_methods(_methods);
7070 
7071   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
7072 
7073   Handle loader(THREAD, _loader_data-&gt;class_loader());
7074   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
7075                                                     &amp;_num_miranda_methods,
7076                                                     _all_mirandas,
7077                                                     _super_klass,
7078                                                     _methods,
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jvm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 945 
 946 // Side-effects: populates the _local_interfaces field
 947 void ClassFileParser::parse_interfaces(const ClassFileStream* stream,
 948                                        int itfs_len,
 949                                        ConstantPool* cp,
 950                                        bool is_inline_type,
 951                                        bool* const has_nonstatic_concrete_methods,
 952                                        // FIXME: lots of these functions
 953                                        // declare their parameters as const,
 954                                        // which adds only noise to the code.
 955                                        // Remove the spurious const modifiers.
 956                                        // Many are of the form &quot;const int x&quot;
 957                                        // or &quot;T* const x&quot;.
 958                                        bool* const is_declared_atomic,
 959                                        TRAPS) {
 960   assert(stream != NULL, &quot;invariant&quot;);
 961   assert(cp != NULL, &quot;invariant&quot;);
 962   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 963 
 964   if (itfs_len == 0) {
<span class="line-modified"> 965     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(1);</span>
 966   } else {
 967     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<span class="line-modified"> 968     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(itfs_len+1);</span>
 969     int index = 0;
 970     for (index = 0; index &lt; itfs_len; index++) {
 971       const u2 interface_index = stream-&gt;get_u2(CHECK);
 972       Klass* interf;
 973       check_property(
 974         valid_klass_reference_at(interface_index),
 975         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 976         interface_index, CHECK);
 977       if (cp-&gt;tag_at(interface_index).is_klass()) {
 978         interf = cp-&gt;resolved_klass_at(interface_index);
 979       } else {
 980         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 981 
 982         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 983         // But need to make sure it&#39;s not an array type.
 984         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 985                            &quot;Bad interface name in class file %s&quot;, CHECK);
 986 
 987         // Call resolve_super so class circularity is checked
 988         interf = SystemDictionary::resolve_super_or_fail(
</pre>
<hr />
<pre>
1007         ResourceMark rm(THREAD);
1008         Exceptions::fthrow(
1009           THREAD_AND_LOCATION,
1010           vmSymbols::java_lang_IncompatibleClassChangeError(),
1011           &quot;Inline type %s attempts to implement interface java.lang.IdentityObject&quot;,
1012           _class_name-&gt;as_klass_external_name());
1013         return;
1014       }
1015       if (ik-&gt;invalid_inline_super()) {
1016         set_invalid_inline_super();
1017       }
1018       if (ik-&gt;has_nonstatic_concrete_methods()) {
1019         *has_nonstatic_concrete_methods = true;
1020       }
1021       if (ik-&gt;is_declared_atomic()) {
1022         *is_declared_atomic = true;
1023       }
1024       if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {
1025         _implements_identityObject = true;
1026       }
<span class="line-modified">1027       _temp_local_interfaces-&gt;at_put_grow(index, ik);</span>
1028     }
1029 
1030     if (!_need_verify || itfs_len &lt;= 1) {
1031       return;
1032     }
1033 
1034     // Check if there&#39;s any duplicates in interfaces
1035     ResourceMark rm(THREAD);
1036     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1037                                                                  NameSigHash*,
1038                                                                  HASH_ROW_SIZE);
1039     initialize_hashtable(interface_names);
1040     bool dup = false;
1041     const Symbol* name = NULL;
1042     {
1043       debug_only(NoSafepointVerifier nsv;)
1044       for (index = 0; index &lt; itfs_len; index++) {
1045         const InstanceKlass* const k = _temp_local_interfaces-&gt;at(index);
1046         name = k-&gt;name();
1047         // If no duplicates, add (name, NULL) in hashtable interface_names.
</pre>
<hr />
<pre>
5016   // Add superclass transitive interfaces size
5017   if (super != NULL) {
5018     super_size = super-&gt;transitive_interfaces()-&gt;length();
5019     max_transitive_size += super_size;
5020   }
5021   // Add local interfaces&#39; super interfaces
5022   const int local_size = local_ifs-&gt;length();
5023   for (int i = 0; i &lt; local_size; i++) {
5024     InstanceKlass* const l = local_ifs-&gt;at(i);
5025     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
5026   }
5027   // Finally add local interfaces
5028   max_transitive_size += local_size;
5029   // Construct array
5030   if (max_transitive_size == 0) {
5031     // no interfaces, use canonicalized array
5032     return Universe::the_empty_instance_klass_array();
5033   } else if (max_transitive_size == super_size) {
5034     // no new local interfaces added, share superklass&#39; transitive interface array
5035     return super-&gt;transitive_interfaces();
<span class="line-modified">5036   } else if (max_transitive_size == local_size) {</span>
<span class="line-modified">5037     // only local interfaces added, share local interface array</span>
<span class="line-modified">5038     return local_ifs;</span>

5039   } else {
5040     ResourceMark rm;
5041     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
5042 
5043     // Copy down from superclass
5044     if (super != NULL) {
5045       append_interfaces(result, super-&gt;transitive_interfaces());
5046     }
5047 
5048     // Copy down from local interfaces&#39; superinterfaces
5049     for (int i = 0; i &lt; local_size; i++) {
5050       InstanceKlass* const l = local_ifs-&gt;at(i);
5051       append_interfaces(result, l-&gt;transitive_interfaces());
5052     }
5053     // Finally add local interfaces
5054     append_interfaces(result, local_ifs);
5055 
5056     // length will be less than the max_transitive_size if duplicates were removed
5057     const int length = result-&gt;length();
5058     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
</pre>
<hr />
<pre>
6481                                  Publicity pub_level,
6482                                  TRAPS) :
6483   _stream(stream),
6484   _requested_name(name),
6485   _class_name(NULL),
6486   _loader_data(loader_data),
6487   _unsafe_anonymous_host(unsafe_anonymous_host),
6488   _cp_patches(cp_patches),
6489   _num_patched_klasses(0),
6490   _max_num_patched_klasses(0),
6491   _orig_cp_size(0),
6492   _first_patched_klass_resolved_index(0),
6493   _super_klass(),
6494   _cp(NULL),
6495   _fields(NULL),
6496   _methods(NULL),
6497   _inner_classes(NULL),
6498   _nest_members(NULL),
6499   _nest_host(0),
6500   _record_components(NULL),

6501   _local_interfaces(NULL),
6502   _transitive_interfaces(NULL),
6503   _combined_annotations(NULL),
6504   _class_annotations(NULL),
6505   _class_type_annotations(NULL),
6506   _fields_annotations(NULL),
6507   _fields_type_annotations(NULL),
6508   _klass(NULL),
6509   _klass_to_deallocate(NULL),
6510   _parsed_annotations(NULL),
6511   _fac(NULL),
6512   _field_info(NULL),
6513   _method_ordering(NULL),
6514   _all_mirandas(NULL),
6515   _vtable_size(0),
6516   _itable_size(0),
6517   _num_miranda_methods(0),
6518   _rt(REF_NONE),
6519   _protection_domain(protection_domain),
6520   _access_flags(),
</pre>
<hr />
<pre>
7022     _is_declared_atomic = true;
7023   } else if (*ForceNonTearable != &#39;\0&#39;) {
7024     // Allow a command line switch to force the same atomicity property:
7025     const char* class_name_str = _class_name-&gt;as_C_string();
7026     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {
7027       _is_declared_atomic = true;
7028     }
7029   }
7030 
7031   // Set ik-&gt;invalid_inline_super field to TRUE if already marked as invalid,
7032   // if super is marked invalid, or if is_invalid_super_for_inline_type()
7033   // returns true
7034   if (invalid_inline_super() ||
7035       (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||
7036       is_invalid_super_for_inline_type()) {
7037     set_invalid_inline_super();
7038   }
7039 
7040   if (!is_value_type() &amp;&amp; invalid_inline_super() &amp;&amp; (_super_klass == NULL || !_super_klass-&gt;invalid_inline_super())
7041       &amp;&amp; !_implements_identityObject &amp;&amp; class_name() != vmSymbols::java_lang_IdentityObject()) {
<span class="line-modified">7042     _temp_local_interfaces-&gt;at_put_grow(_temp_local_interfaces-&gt;length(), SystemDictionary::IdentityObject_klass());</span>
7043     _has_injected_identityObject = true;
7044   }
7045   int itfs_len = _temp_local_interfaces-&gt;length();
7046   if (itfs_len == 0) {
7047     _local_interfaces = Universe::the_empty_instance_klass_array();
7048   } else {
7049     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);
7050     for (int i = 0; i &lt; itfs_len; i++) {
7051       _local_interfaces-&gt;at_put(i, _temp_local_interfaces-&gt;at(i));
7052     }
7053   }


7054 
7055   // Compute the transitive list of all unique interfaces implemented by this class
7056   _transitive_interfaces =
7057     compute_transitive_interfaces(_super_klass,
7058                                   _local_interfaces,
7059                                   _loader_data,
7060                                   CHECK);
7061 
7062   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
7063 
7064   // sort methods
7065   _method_ordering = sort_methods(_methods);
7066 
7067   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
7068 
7069   Handle loader(THREAD, _loader_data-&gt;class_loader());
7070   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
7071                                                     &amp;_num_miranda_methods,
7072                                                     _all_mirandas,
7073                                                     _super_klass,
</pre>
</td>
<td>
<hr />
<pre>
 945 
 946 // Side-effects: populates the _local_interfaces field
 947 void ClassFileParser::parse_interfaces(const ClassFileStream* stream,
 948                                        int itfs_len,
 949                                        ConstantPool* cp,
 950                                        bool is_inline_type,
 951                                        bool* const has_nonstatic_concrete_methods,
 952                                        // FIXME: lots of these functions
 953                                        // declare their parameters as const,
 954                                        // which adds only noise to the code.
 955                                        // Remove the spurious const modifiers.
 956                                        // Many are of the form &quot;const int x&quot;
 957                                        // or &quot;T* const x&quot;.
 958                                        bool* const is_declared_atomic,
 959                                        TRAPS) {
 960   assert(stream != NULL, &quot;invariant&quot;);
 961   assert(cp != NULL, &quot;invariant&quot;);
 962   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 963 
 964   if (itfs_len == 0) {
<span class="line-modified"> 965     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(0);</span>
 966   } else {
 967     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<span class="line-modified"> 968     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(itfs_len);</span>
 969     int index = 0;
 970     for (index = 0; index &lt; itfs_len; index++) {
 971       const u2 interface_index = stream-&gt;get_u2(CHECK);
 972       Klass* interf;
 973       check_property(
 974         valid_klass_reference_at(interface_index),
 975         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 976         interface_index, CHECK);
 977       if (cp-&gt;tag_at(interface_index).is_klass()) {
 978         interf = cp-&gt;resolved_klass_at(interface_index);
 979       } else {
 980         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 981 
 982         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 983         // But need to make sure it&#39;s not an array type.
 984         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 985                            &quot;Bad interface name in class file %s&quot;, CHECK);
 986 
 987         // Call resolve_super so class circularity is checked
 988         interf = SystemDictionary::resolve_super_or_fail(
</pre>
<hr />
<pre>
1007         ResourceMark rm(THREAD);
1008         Exceptions::fthrow(
1009           THREAD_AND_LOCATION,
1010           vmSymbols::java_lang_IncompatibleClassChangeError(),
1011           &quot;Inline type %s attempts to implement interface java.lang.IdentityObject&quot;,
1012           _class_name-&gt;as_klass_external_name());
1013         return;
1014       }
1015       if (ik-&gt;invalid_inline_super()) {
1016         set_invalid_inline_super();
1017       }
1018       if (ik-&gt;has_nonstatic_concrete_methods()) {
1019         *has_nonstatic_concrete_methods = true;
1020       }
1021       if (ik-&gt;is_declared_atomic()) {
1022         *is_declared_atomic = true;
1023       }
1024       if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {
1025         _implements_identityObject = true;
1026       }
<span class="line-modified">1027       _temp_local_interfaces-&gt;append(ik);</span>
1028     }
1029 
1030     if (!_need_verify || itfs_len &lt;= 1) {
1031       return;
1032     }
1033 
1034     // Check if there&#39;s any duplicates in interfaces
1035     ResourceMark rm(THREAD);
1036     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1037                                                                  NameSigHash*,
1038                                                                  HASH_ROW_SIZE);
1039     initialize_hashtable(interface_names);
1040     bool dup = false;
1041     const Symbol* name = NULL;
1042     {
1043       debug_only(NoSafepointVerifier nsv;)
1044       for (index = 0; index &lt; itfs_len; index++) {
1045         const InstanceKlass* const k = _temp_local_interfaces-&gt;at(index);
1046         name = k-&gt;name();
1047         // If no duplicates, add (name, NULL) in hashtable interface_names.
</pre>
<hr />
<pre>
5016   // Add superclass transitive interfaces size
5017   if (super != NULL) {
5018     super_size = super-&gt;transitive_interfaces()-&gt;length();
5019     max_transitive_size += super_size;
5020   }
5021   // Add local interfaces&#39; super interfaces
5022   const int local_size = local_ifs-&gt;length();
5023   for (int i = 0; i &lt; local_size; i++) {
5024     InstanceKlass* const l = local_ifs-&gt;at(i);
5025     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
5026   }
5027   // Finally add local interfaces
5028   max_transitive_size += local_size;
5029   // Construct array
5030   if (max_transitive_size == 0) {
5031     // no interfaces, use canonicalized array
5032     return Universe::the_empty_instance_klass_array();
5033   } else if (max_transitive_size == super_size) {
5034     // no new local interfaces added, share superklass&#39; transitive interface array
5035     return super-&gt;transitive_interfaces();
<span class="line-modified">5036     // The three lines below are commented to work around bug JDK-8245487</span>
<span class="line-modified">5037 //  } else if (max_transitive_size == local_size) {</span>
<span class="line-modified">5038 //    // only local interfaces added, share local interface array</span>
<span class="line-added">5039 //    return local_ifs;</span>
5040   } else {
5041     ResourceMark rm;
5042     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
5043 
5044     // Copy down from superclass
5045     if (super != NULL) {
5046       append_interfaces(result, super-&gt;transitive_interfaces());
5047     }
5048 
5049     // Copy down from local interfaces&#39; superinterfaces
5050     for (int i = 0; i &lt; local_size; i++) {
5051       InstanceKlass* const l = local_ifs-&gt;at(i);
5052       append_interfaces(result, l-&gt;transitive_interfaces());
5053     }
5054     // Finally add local interfaces
5055     append_interfaces(result, local_ifs);
5056 
5057     // length will be less than the max_transitive_size if duplicates were removed
5058     const int length = result-&gt;length();
5059     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
</pre>
<hr />
<pre>
6482                                  Publicity pub_level,
6483                                  TRAPS) :
6484   _stream(stream),
6485   _requested_name(name),
6486   _class_name(NULL),
6487   _loader_data(loader_data),
6488   _unsafe_anonymous_host(unsafe_anonymous_host),
6489   _cp_patches(cp_patches),
6490   _num_patched_klasses(0),
6491   _max_num_patched_klasses(0),
6492   _orig_cp_size(0),
6493   _first_patched_klass_resolved_index(0),
6494   _super_klass(),
6495   _cp(NULL),
6496   _fields(NULL),
6497   _methods(NULL),
6498   _inner_classes(NULL),
6499   _nest_members(NULL),
6500   _nest_host(0),
6501   _record_components(NULL),
<span class="line-added">6502   _temp_local_interfaces(NULL),</span>
6503   _local_interfaces(NULL),
6504   _transitive_interfaces(NULL),
6505   _combined_annotations(NULL),
6506   _class_annotations(NULL),
6507   _class_type_annotations(NULL),
6508   _fields_annotations(NULL),
6509   _fields_type_annotations(NULL),
6510   _klass(NULL),
6511   _klass_to_deallocate(NULL),
6512   _parsed_annotations(NULL),
6513   _fac(NULL),
6514   _field_info(NULL),
6515   _method_ordering(NULL),
6516   _all_mirandas(NULL),
6517   _vtable_size(0),
6518   _itable_size(0),
6519   _num_miranda_methods(0),
6520   _rt(REF_NONE),
6521   _protection_domain(protection_domain),
6522   _access_flags(),
</pre>
<hr />
<pre>
7024     _is_declared_atomic = true;
7025   } else if (*ForceNonTearable != &#39;\0&#39;) {
7026     // Allow a command line switch to force the same atomicity property:
7027     const char* class_name_str = _class_name-&gt;as_C_string();
7028     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {
7029       _is_declared_atomic = true;
7030     }
7031   }
7032 
7033   // Set ik-&gt;invalid_inline_super field to TRUE if already marked as invalid,
7034   // if super is marked invalid, or if is_invalid_super_for_inline_type()
7035   // returns true
7036   if (invalid_inline_super() ||
7037       (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||
7038       is_invalid_super_for_inline_type()) {
7039     set_invalid_inline_super();
7040   }
7041 
7042   if (!is_value_type() &amp;&amp; invalid_inline_super() &amp;&amp; (_super_klass == NULL || !_super_klass-&gt;invalid_inline_super())
7043       &amp;&amp; !_implements_identityObject &amp;&amp; class_name() != vmSymbols::java_lang_IdentityObject()) {
<span class="line-modified">7044     _temp_local_interfaces-&gt;append(SystemDictionary::IdentityObject_klass());</span>
7045     _has_injected_identityObject = true;
7046   }
7047   int itfs_len = _temp_local_interfaces-&gt;length();
7048   if (itfs_len == 0) {
7049     _local_interfaces = Universe::the_empty_instance_klass_array();
7050   } else {
7051     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);
7052     for (int i = 0; i &lt; itfs_len; i++) {
7053       _local_interfaces-&gt;at_put(i, _temp_local_interfaces-&gt;at(i));
7054     }
7055   }
<span class="line-added">7056   _temp_local_interfaces = NULL;</span>
<span class="line-added">7057   assert(_local_interfaces != NULL, &quot;invariant&quot;);</span>
7058 
7059   // Compute the transitive list of all unique interfaces implemented by this class
7060   _transitive_interfaces =
7061     compute_transitive_interfaces(_super_klass,
7062                                   _local_interfaces,
7063                                   _loader_data,
7064                                   CHECK);
7065 
7066   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
7067 
7068   // sort methods
7069   _method_ordering = sort_methods(_methods);
7070 
7071   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
7072 
7073   Handle loader(THREAD, _loader_data-&gt;class_loader());
7074   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
7075                                                     &amp;_num_miranda_methods,
7076                                                     _all_mirandas,
7077                                                     _super_klass,
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jvm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
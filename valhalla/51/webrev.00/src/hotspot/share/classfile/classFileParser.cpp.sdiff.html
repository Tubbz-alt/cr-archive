<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 945 
 946 // Side-effects: populates the _local_interfaces field
 947 void ClassFileParser::parse_interfaces(const ClassFileStream* stream,
 948                                        int itfs_len,
 949                                        ConstantPool* cp,
 950                                        bool is_inline_type,
 951                                        bool* const has_nonstatic_concrete_methods,
 952                                        // FIXME: lots of these functions
 953                                        // declare their parameters as const,
 954                                        // which adds only noise to the code.
 955                                        // Remove the spurious const modifiers.
 956                                        // Many are of the form &quot;const int x&quot;
 957                                        // or &quot;T* const x&quot;.
 958                                        bool* const is_declared_atomic,
 959                                        TRAPS) {
 960   assert(stream != NULL, &quot;invariant&quot;);
 961   assert(cp != NULL, &quot;invariant&quot;);
 962   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 963 
 964   if (itfs_len == 0) {
<span class="line-modified"> 965     _local_interfaces = Universe::the_empty_instance_klass_array();</span>
 966   } else {
 967     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<span class="line-modified"> 968     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);</span>
<span class="line-modified"> 969 </span>
<span class="line-removed"> 970     int index;</span>
 971     for (index = 0; index &lt; itfs_len; index++) {
 972       const u2 interface_index = stream-&gt;get_u2(CHECK);
 973       Klass* interf;
 974       check_property(
 975         valid_klass_reference_at(interface_index),
 976         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 977         interface_index, CHECK);
 978       if (cp-&gt;tag_at(interface_index).is_klass()) {
 979         interf = cp-&gt;resolved_klass_at(interface_index);
 980       } else {
 981         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 982 
 983         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 984         // But need to make sure it&#39;s not an array type.
 985         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 986                            &quot;Bad interface name in class file %s&quot;, CHECK);
 987 
<span class="line-modified"> 988         // Call resolve_super so classcircularity is checked</span>
 989         interf = SystemDictionary::resolve_super_or_fail(
 990                                                   _class_name,
 991                                                   unresolved_klass,
 992                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 993                                                   _protection_domain,
 994                                                   false,
 995                                                   CHECK);
 996       }
 997 
 998       if (!interf-&gt;is_interface()) {
 999         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
1000                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
1001                           _class_name-&gt;as_klass_external_name(),
1002                           interf-&gt;external_name(),
1003                           interf-&gt;class_in_module_of_loader()));
1004       }
1005 
1006       InstanceKlass* ik = InstanceKlass::cast(interf);
1007       if (is_inline_type &amp;&amp; ik-&gt;invalid_inline_super()) {
1008         ResourceMark rm(THREAD);
1009         Exceptions::fthrow(
1010           THREAD_AND_LOCATION,
1011           vmSymbols::java_lang_IncompatibleClassChangeError(),
1012           &quot;Inline type %s attempts to implement interface java.lang.IdentityObject&quot;,
1013           _class_name-&gt;as_klass_external_name());
1014         return;
1015       }
1016       if (ik-&gt;invalid_inline_super()) {
1017         set_invalid_inline_super();
1018       }
1019       if (ik-&gt;has_nonstatic_concrete_methods()) {
1020         *has_nonstatic_concrete_methods = true;
1021       }
1022       if (ik-&gt;is_declared_atomic()) {
1023         *is_declared_atomic = true;
1024       }
<span class="line-modified">1025       _local_interfaces-&gt;at_put(index, ik);</span>



1026     }
1027 
1028     if (!_need_verify || itfs_len &lt;= 1) {
1029       return;
1030     }
1031 
1032     // Check if there&#39;s any duplicates in interfaces
1033     ResourceMark rm(THREAD);
1034     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1035                                                                  NameSigHash*,
1036                                                                  HASH_ROW_SIZE);
1037     initialize_hashtable(interface_names);
1038     bool dup = false;
1039     const Symbol* name = NULL;
1040     {
1041       debug_only(NoSafepointVerifier nsv;)
1042       for (index = 0; index &lt; itfs_len; index++) {
<span class="line-modified">1043         const InstanceKlass* const k = _local_interfaces-&gt;at(index);</span>
1044         name = k-&gt;name();
1045         // If no duplicates, add (name, NULL) in hashtable interface_names.
1046         if (!put_after_lookup(name, NULL, interface_names)) {
1047           dup = true;
1048           break;
1049         }
1050       }
1051     }
1052     if (dup) {
1053       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1054                              name-&gt;as_C_string(), CHECK);
1055     }
1056   }
1057 }
1058 
1059 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1060                                            int constantvalue_index,
1061                                            int signature_index,
1062                                            TRAPS) const {
1063   // Make sure the constant pool entry is of a type appropriate to this field
</pre>
<hr />
<pre>
1822                       0);
1823     const BasicType type = Signature::basic_type(vmSymbols::object_signature());
1824     const FieldAllocationType atype = fac-&gt;update(true, type, false);
1825     field-&gt;set_allocation_type(atype);
1826     index++;
1827   }
1828 
1829   if (is_value_type &amp;&amp; instance_fields_count == 0) {
1830     _is_empty_value = true;
1831     FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1832     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1833         vmSymbols::empty_marker_name_enum,
1834         vmSymbols::byte_signature_enum,
1835         0);
1836     const BasicType type = Signature::basic_type(vmSymbols::byte_signature());
1837     const FieldAllocationType atype = fac-&gt;update(false, type, false);
1838     field-&gt;set_allocation_type(atype);
1839     index++;
1840   }
1841 




1842   assert(NULL == _fields, &quot;invariant&quot;);
1843 
1844   _fields =
1845     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1846                                    index * FieldInfo::field_slots + num_generic_signature,
1847                                    CHECK);
1848   // Sometimes injected fields already exist in the Java source so
1849   // the fields array could be too long.  In that case the
1850   // fields array is trimed. Also unused slots that were reserved
1851   // for generic signature indexes are discarded.
1852   {
1853     int i = 0;
1854     for (; i &lt; index * FieldInfo::field_slots; i++) {
1855       _fields-&gt;at_put(i, fa[i]);
1856     }
1857     for (int j = total_fields * FieldInfo::field_slots;
1858          j &lt; generic_signature_slot; j++) {
1859       _fields-&gt;at_put(i++, fa[j]);
1860     }
1861     assert(_fields-&gt;length() == i, &quot;&quot;);
</pre>
<hr />
<pre>
6064                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
6065     }
6066   }
6067 
6068   if (ik-&gt;is_value()) {
6069     ValueKlass* vk = ValueKlass::cast(ik);
6070     oop val = ik-&gt;allocate_instance(CHECK_NULL);
6071     vk-&gt;set_default_value(val);
6072   }
6073 
6074   return ik;
6075 }
6076 
6077 // Return true if the specified class is not a valid super class for an inline type.
6078 // A valid super class for an inline type is abstract, has no instance fields,
6079 // does not implement interface java.lang.IdentityObject (checked elsewhere), has
6080 // an empty body-less no-arg constructor, and no synchronized instance methods.
6081 // This function doesn&#39;t check if the class&#39;s super types are invalid.  Those checks
6082 // are done elsewhere.  The final determination of whether or not a class is an
6083 // invalid super type for an inline class is done in fill_instance_klass().
<span class="line-modified">6084 static bool is_invalid_super_for_inline_type(const InstanceKlass* ik) {</span>
<span class="line-modified">6085   if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {</span>
6086     return true;
6087   }
<span class="line-modified">6088   if (ik-&gt;is_interface() || ik-&gt;name() == vmSymbols::java_lang_Object()) {</span>
6089     return false;
6090   }
<span class="line-modified">6091   if (!ik-&gt;is_abstract() || ik-&gt;has_nonstatic_fields()) {</span>
6092     return true;
6093   } else {
<span class="line-modified">6094     Array&lt;Method*&gt;* methods = ik-&gt;methods();</span>
<span class="line-modified">6095     // Look at each method.</span>
<span class="line-modified">6096     for (int x = 0; x &lt; methods-&gt;length(); x++) {</span>
<span class="line-removed">6097       const Method* const method = methods-&gt;at(x);</span>
6098       if (method-&gt;is_synchronized() &amp;&amp; !method-&gt;is_static()) {
6099         return true;
6100 
6101       } else if (method-&gt;name() == vmSymbols::object_initializer_name()) {
6102         if (method-&gt;signature() != vmSymbols::void_method_signature() ||
6103             !method-&gt;is_vanilla_constructor()) {
6104           return true;
6105         }
6106       }
6107     }
6108   }
6109   return false;
6110 }
6111 
6112 void ClassFileParser::fill_instance_klass(InstanceKlass* ik, bool changed_by_loadhook, TRAPS) {
6113   assert(ik != NULL, &quot;invariant&quot;);
6114 
6115   // Set name and CLD before adding to CLD
6116   ik-&gt;set_class_loader_data(_loader_data);
6117   ik-&gt;set_name(_class_name);
</pre>
<hr />
<pre>
6127   assert(_field_info != NULL, &quot;invariant&quot;);
6128   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
6129   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
6130          &quot;sanity&quot;);
6131 
6132   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
6133   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
6134 
6135   // Fill in information already parsed
6136   ik-&gt;set_should_verify_class(_need_verify);
6137 
6138   // Not yet: supers are done below to support the new subtype-checking fields
6139   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
6140   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
6141   if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_value()) {
6142     ik-&gt;set_is_naturally_atomic();
6143   }
6144   if (_is_empty_value) {
6145     ik-&gt;set_is_empty_value();
6146   }









6147   assert(_fac != NULL, &quot;invariant&quot;);
6148   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);
6149 
6150   // this transfers ownership of a lot of arrays from
6151   // the parser onto the InstanceKlass*
6152   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6153 
6154   // note that is not safe to use the fields in the parser from this point on
6155   assert(NULL == _cp, &quot;invariant&quot;);
6156   assert(NULL == _fields, &quot;invariant&quot;);
6157   assert(NULL == _methods, &quot;invariant&quot;);
6158   assert(NULL == _inner_classes, &quot;invariant&quot;);
6159   assert(NULL == _nest_members, &quot;invariant&quot;);
6160   assert(NULL == _local_interfaces, &quot;invariant&quot;);
6161   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6162   assert(NULL == _record_components, &quot;invariant&quot;);
6163 
6164   if (_has_final_method) {
6165     ik-&gt;set_has_final_method();
6166   }
</pre>
<hr />
<pre>
6354       // print out the superclass.
6355       const char * from = ik-&gt;external_name();
6356       if (ik-&gt;java_super() != NULL) {
6357         log_debug(class, resolve)(&quot;%s %s (super)&quot;,
6358                    from,
6359                    ik-&gt;java_super()-&gt;external_name());
6360       }
6361       // print out each of the interface classes referred to by this class.
6362       const Array&lt;InstanceKlass*&gt;* const local_interfaces = ik-&gt;local_interfaces();
6363       if (local_interfaces != NULL) {
6364         const int length = local_interfaces-&gt;length();
6365         for (int i = 0; i &lt; length; i++) {
6366           const InstanceKlass* const k = local_interfaces-&gt;at(i);
6367           const char * to = k-&gt;external_name();
6368           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
6369         }
6370       }
6371     }
6372   }
6373 
<span class="line-removed">6374   // Set ik-&gt;invalid_inline_super field to TRUE if already marked as invalid,</span>
<span class="line-removed">6375   // if super is marked invalid, or if is_invalid_super_for_inline_type()</span>
<span class="line-removed">6376   // returns true</span>
<span class="line-removed">6377   if (invalid_inline_super() ||</span>
<span class="line-removed">6378       (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||</span>
<span class="line-removed">6379       is_invalid_super_for_inline_type(ik)) {</span>
<span class="line-removed">6380     ik-&gt;set_invalid_inline_super();</span>
<span class="line-removed">6381   }</span>
<span class="line-removed">6382 </span>
6383   JFR_ONLY(INIT_ID(ik);)
6384 
6385   // If we reach here, all is well.
6386   // Now remove the InstanceKlass* from the _klass_to_deallocate field
6387   // in order for it to not be destroyed in the ClassFileParser destructor.
6388   set_klass_to_deallocate(NULL);
6389 
6390   // it&#39;s official
6391   set_klass(ik);
6392 
6393   debug_only(ik-&gt;verify();)
6394 }
6395 
6396 void ClassFileParser::update_class_name(Symbol* new_class_name) {
6397   // Decrement the refcount in the old name, since we&#39;re clobbering it.
6398   _class_name-&gt;decrement_refcount();
6399 
6400   _class_name = new_class_name;
6401   // Increment the refcount of the new name.
6402   // Now the ClassFileParser owns this name and will decrement in
</pre>
<hr />
<pre>
6516   _pub_level(pub_level),
6517   _bad_constant_seen(0),
6518   _synthetic_flag(false),
6519   _sde_length(false),
6520   _sde_buffer(NULL),
6521   _sourcefile_index(0),
6522   _generic_signature_index(0),
6523   _major_version(0),
6524   _minor_version(0),
6525   _this_class_index(0),
6526   _super_class_index(0),
6527   _itfs_len(0),
6528   _java_fields_count(0),
6529   _need_verify(false),
6530   _relax_verify(false),
6531   _has_nonstatic_concrete_methods(false),
6532   _declares_nonstatic_concrete_methods(false),
6533   _has_final_method(false),
6534   _has_contended_fields(false),
6535   _has_flattenable_fields(false),

6536   _is_empty_value(false),
6537   _is_naturally_atomic(false),
6538   _is_declared_atomic(false),
6539   _invalid_inline_super(false),
6540   _invalid_identity_super(false),


6541   _has_finalizer(false),
6542   _has_empty_finalizer(false),
6543   _has_vanilla_constructor(false),
6544   _max_bootstrap_specifier_index(-1) {
6545 
6546   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6547   _class_name-&gt;increment_refcount();
6548 
6549   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6550   assert(_loader_data != NULL, &quot;invariant&quot;);
6551   assert(stream != NULL, &quot;invariant&quot;);
6552   assert(_stream != NULL, &quot;invariant&quot;);
6553   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6554   assert(_class_name != NULL, &quot;invariant&quot;);
6555   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6556 
6557   // Figure out whether we can skip format checking (matching classic VM behavior)
6558   if (DumpSharedSpaces) {
6559     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6560     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
6864 #endif
6865   }
6866 
6867   // SUPERKLASS
6868   _super_class_index = stream-&gt;get_u2_fast();
6869   _super_klass = parse_super_class(cp,
6870                                    _super_class_index,
6871                                    _need_verify,
6872                                    CHECK);
6873 
6874   // Interfaces
6875   _itfs_len = stream-&gt;get_u2_fast();
6876   parse_interfaces(stream,
6877                    _itfs_len,
6878                    cp,
6879                    is_value_type(),
6880                    &amp;_has_nonstatic_concrete_methods,
6881                    &amp;_is_declared_atomic,
6882                    CHECK);
6883 
<span class="line-modified">6884   assert(_local_interfaces != NULL, &quot;invariant&quot;);</span>
6885 
6886   // Fields (offsets are filled in later)
6887   _fac = new FieldAllocationCount();
6888   parse_fields(stream,
6889                is_interface(),
6890                is_value_type(),
6891                _fac,
6892                cp,
6893                cp_size,
6894                &amp;_java_fields_count,
6895                CHECK);
6896 
6897   assert(_fields != NULL, &quot;invariant&quot;);
6898 
6899   // Methods
6900   AccessFlags promoted_flags;
6901   parse_methods(stream,
6902                 is_interface(),
6903                 is_value_type(),
6904                 &amp;promoted_flags,
</pre>
<hr />
<pre>
6925   // now that all annotation arrays have been created.
6926   create_combined_annotations(CHECK);
6927 
6928   // Make sure this is the end of class file stream
6929   guarantee_property(stream-&gt;at_eos(),
6930                      &quot;Extra bytes at the end of class file %s&quot;,
6931                      CHECK);
6932 
6933   // all bytes in stream read and parsed
6934 }
6935 
6936 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6937                                                  ConstantPool* cp,
6938                                                  TRAPS) {
6939   assert(stream != NULL, &quot;invariant&quot;);
6940   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6941   assert(cp != NULL, &quot;invariant&quot;);
6942   assert(_loader_data != NULL, &quot;invariant&quot;);
6943 
6944   if (_class_name == vmSymbols::java_lang_Object()) {
<span class="line-modified">6945     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),</span>
<span class="line-modified">6946                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,</span>
<span class="line-modified">6947                    CHECK);</span>
6948   }
6949   // We check super class after class file is parsed and format is checked
6950   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6951     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
6952     if (is_interface()) {
6953       // Before attempting to resolve the superclass, check for class format
6954       // errors not checked yet.
6955       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6956         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6957         CHECK);
6958     }
6959     Handle loader(THREAD, _loader_data-&gt;class_loader());
6960     _super_klass = (const InstanceKlass*)
6961                        SystemDictionary::resolve_super_or_fail(_class_name,
6962                                                                super_class_name,
6963                                                                loader,
6964                                                                _protection_domain,
6965                                                                true,
6966                                                                CHECK);
6967   }
</pre>
<hr />
<pre>
7003           &quot;inline class %s has an invalid super class %s&quot;,
7004           _class_name-&gt;as_klass_external_name(),
7005           _super_klass-&gt;external_name());
7006         return;
7007       }
7008     }
7009   }
7010 
7011   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {
7012     // This is the original source of this condition.
7013     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.
7014     _is_declared_atomic = true;
7015   } else if (*ForceNonTearable != &#39;\0&#39;) {
7016     // Allow a command line switch to force the same atomicity property:
7017     const char* class_name_str = _class_name-&gt;as_C_string();
7018     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {
7019       _is_declared_atomic = true;
7020     }
7021   }
7022 
























7023   // Compute the transitive list of all unique interfaces implemented by this class
7024   _transitive_interfaces =
7025     compute_transitive_interfaces(_super_klass,
7026                                   _local_interfaces,
7027                                   _loader_data,
7028                                   CHECK);
7029 
7030   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
7031 
7032   // sort methods
7033   _method_ordering = sort_methods(_methods);
7034 
7035   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
7036 
7037   Handle loader(THREAD, _loader_data-&gt;class_loader());
7038   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
7039                                                     &amp;_num_miranda_methods,
7040                                                     _all_mirandas,
7041                                                     _super_klass,
7042                                                     _methods,
</pre>
</td>
<td>
<hr />
<pre>
 945 
 946 // Side-effects: populates the _local_interfaces field
 947 void ClassFileParser::parse_interfaces(const ClassFileStream* stream,
 948                                        int itfs_len,
 949                                        ConstantPool* cp,
 950                                        bool is_inline_type,
 951                                        bool* const has_nonstatic_concrete_methods,
 952                                        // FIXME: lots of these functions
 953                                        // declare their parameters as const,
 954                                        // which adds only noise to the code.
 955                                        // Remove the spurious const modifiers.
 956                                        // Many are of the form &quot;const int x&quot;
 957                                        // or &quot;T* const x&quot;.
 958                                        bool* const is_declared_atomic,
 959                                        TRAPS) {
 960   assert(stream != NULL, &quot;invariant&quot;);
 961   assert(cp != NULL, &quot;invariant&quot;);
 962   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 963 
 964   if (itfs_len == 0) {
<span class="line-modified"> 965     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(1);</span>
 966   } else {
 967     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<span class="line-modified"> 968     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(itfs_len+1);</span>
<span class="line-modified"> 969     int index = 0;</span>

 970     for (index = 0; index &lt; itfs_len; index++) {
 971       const u2 interface_index = stream-&gt;get_u2(CHECK);
 972       Klass* interf;
 973       check_property(
 974         valid_klass_reference_at(interface_index),
 975         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 976         interface_index, CHECK);
 977       if (cp-&gt;tag_at(interface_index).is_klass()) {
 978         interf = cp-&gt;resolved_klass_at(interface_index);
 979       } else {
 980         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 981 
 982         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 983         // But need to make sure it&#39;s not an array type.
 984         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 985                            &quot;Bad interface name in class file %s&quot;, CHECK);
 986 
<span class="line-modified"> 987         // Call resolve_super so class circularity is checked</span>
 988         interf = SystemDictionary::resolve_super_or_fail(
 989                                                   _class_name,
 990                                                   unresolved_klass,
 991                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 992                                                   _protection_domain,
 993                                                   false,
 994                                                   CHECK);
 995       }
 996 
 997       if (!interf-&gt;is_interface()) {
 998         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 999                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
1000                           _class_name-&gt;as_klass_external_name(),
1001                           interf-&gt;external_name(),
1002                           interf-&gt;class_in_module_of_loader()));
1003       }
1004 
1005       InstanceKlass* ik = InstanceKlass::cast(interf);
1006       if (is_inline_type &amp;&amp; ik-&gt;invalid_inline_super()) {
1007         ResourceMark rm(THREAD);
1008         Exceptions::fthrow(
1009           THREAD_AND_LOCATION,
1010           vmSymbols::java_lang_IncompatibleClassChangeError(),
1011           &quot;Inline type %s attempts to implement interface java.lang.IdentityObject&quot;,
1012           _class_name-&gt;as_klass_external_name());
1013         return;
1014       }
1015       if (ik-&gt;invalid_inline_super()) {
1016         set_invalid_inline_super();
1017       }
1018       if (ik-&gt;has_nonstatic_concrete_methods()) {
1019         *has_nonstatic_concrete_methods = true;
1020       }
1021       if (ik-&gt;is_declared_atomic()) {
1022         *is_declared_atomic = true;
1023       }
<span class="line-modified">1024       if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">1025         _implements_identityObject = true;</span>
<span class="line-added">1026       }</span>
<span class="line-added">1027       _temp_local_interfaces-&gt;at_put_grow(index, ik);</span>
1028     }
1029 
1030     if (!_need_verify || itfs_len &lt;= 1) {
1031       return;
1032     }
1033 
1034     // Check if there&#39;s any duplicates in interfaces
1035     ResourceMark rm(THREAD);
1036     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1037                                                                  NameSigHash*,
1038                                                                  HASH_ROW_SIZE);
1039     initialize_hashtable(interface_names);
1040     bool dup = false;
1041     const Symbol* name = NULL;
1042     {
1043       debug_only(NoSafepointVerifier nsv;)
1044       for (index = 0; index &lt; itfs_len; index++) {
<span class="line-modified">1045         const InstanceKlass* const k = _temp_local_interfaces-&gt;at(index);</span>
1046         name = k-&gt;name();
1047         // If no duplicates, add (name, NULL) in hashtable interface_names.
1048         if (!put_after_lookup(name, NULL, interface_names)) {
1049           dup = true;
1050           break;
1051         }
1052       }
1053     }
1054     if (dup) {
1055       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1056                              name-&gt;as_C_string(), CHECK);
1057     }
1058   }
1059 }
1060 
1061 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1062                                            int constantvalue_index,
1063                                            int signature_index,
1064                                            TRAPS) const {
1065   // Make sure the constant pool entry is of a type appropriate to this field
</pre>
<hr />
<pre>
1824                       0);
1825     const BasicType type = Signature::basic_type(vmSymbols::object_signature());
1826     const FieldAllocationType atype = fac-&gt;update(true, type, false);
1827     field-&gt;set_allocation_type(atype);
1828     index++;
1829   }
1830 
1831   if (is_value_type &amp;&amp; instance_fields_count == 0) {
1832     _is_empty_value = true;
1833     FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1834     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1835         vmSymbols::empty_marker_name_enum,
1836         vmSymbols::byte_signature_enum,
1837         0);
1838     const BasicType type = Signature::basic_type(vmSymbols::byte_signature());
1839     const FieldAllocationType atype = fac-&gt;update(false, type, false);
1840     field-&gt;set_allocation_type(atype);
1841     index++;
1842   }
1843 
<span class="line-added">1844   if (instance_fields_count &gt; 0) {</span>
<span class="line-added">1845     _has_nonstatic_fields = true;</span>
<span class="line-added">1846   }</span>
<span class="line-added">1847 </span>
1848   assert(NULL == _fields, &quot;invariant&quot;);
1849 
1850   _fields =
1851     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1852                                    index * FieldInfo::field_slots + num_generic_signature,
1853                                    CHECK);
1854   // Sometimes injected fields already exist in the Java source so
1855   // the fields array could be too long.  In that case the
1856   // fields array is trimed. Also unused slots that were reserved
1857   // for generic signature indexes are discarded.
1858   {
1859     int i = 0;
1860     for (; i &lt; index * FieldInfo::field_slots; i++) {
1861       _fields-&gt;at_put(i, fa[i]);
1862     }
1863     for (int j = total_fields * FieldInfo::field_slots;
1864          j &lt; generic_signature_slot; j++) {
1865       _fields-&gt;at_put(i++, fa[j]);
1866     }
1867     assert(_fields-&gt;length() == i, &quot;&quot;);
</pre>
<hr />
<pre>
6070                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
6071     }
6072   }
6073 
6074   if (ik-&gt;is_value()) {
6075     ValueKlass* vk = ValueKlass::cast(ik);
6076     oop val = ik-&gt;allocate_instance(CHECK_NULL);
6077     vk-&gt;set_default_value(val);
6078   }
6079 
6080   return ik;
6081 }
6082 
6083 // Return true if the specified class is not a valid super class for an inline type.
6084 // A valid super class for an inline type is abstract, has no instance fields,
6085 // does not implement interface java.lang.IdentityObject (checked elsewhere), has
6086 // an empty body-less no-arg constructor, and no synchronized instance methods.
6087 // This function doesn&#39;t check if the class&#39;s super types are invalid.  Those checks
6088 // are done elsewhere.  The final determination of whether or not a class is an
6089 // invalid super type for an inline class is done in fill_instance_klass().
<span class="line-modified">6090 bool ClassFileParser::is_invalid_super_for_inline_type() {</span>
<span class="line-modified">6091   if (class_name() == vmSymbols::java_lang_IdentityObject()) {</span>
6092     return true;
6093   }
<span class="line-modified">6094   if (is_interface() || class_name() == vmSymbols::java_lang_Object()) {</span>
6095     return false;
6096   }
<span class="line-modified">6097   if (!access_flags().is_abstract() || _has_nonstatic_fields) {</span>
6098     return true;
6099   } else {
<span class="line-modified">6100     // Look at each method</span>
<span class="line-modified">6101     for (int x = 0; x &lt; _methods-&gt;length(); x++) {</span>
<span class="line-modified">6102       const Method* const method = _methods-&gt;at(x);</span>

6103       if (method-&gt;is_synchronized() &amp;&amp; !method-&gt;is_static()) {
6104         return true;
6105 
6106       } else if (method-&gt;name() == vmSymbols::object_initializer_name()) {
6107         if (method-&gt;signature() != vmSymbols::void_method_signature() ||
6108             !method-&gt;is_vanilla_constructor()) {
6109           return true;
6110         }
6111       }
6112     }
6113   }
6114   return false;
6115 }
6116 
6117 void ClassFileParser::fill_instance_klass(InstanceKlass* ik, bool changed_by_loadhook, TRAPS) {
6118   assert(ik != NULL, &quot;invariant&quot;);
6119 
6120   // Set name and CLD before adding to CLD
6121   ik-&gt;set_class_loader_data(_loader_data);
6122   ik-&gt;set_name(_class_name);
</pre>
<hr />
<pre>
6132   assert(_field_info != NULL, &quot;invariant&quot;);
6133   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
6134   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
6135          &quot;sanity&quot;);
6136 
6137   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
6138   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
6139 
6140   // Fill in information already parsed
6141   ik-&gt;set_should_verify_class(_need_verify);
6142 
6143   // Not yet: supers are done below to support the new subtype-checking fields
6144   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
6145   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
6146   if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_value()) {
6147     ik-&gt;set_is_naturally_atomic();
6148   }
6149   if (_is_empty_value) {
6150     ik-&gt;set_is_empty_value();
6151   }
<span class="line-added">6152 </span>
<span class="line-added">6153   if (this-&gt;_invalid_inline_super) {</span>
<span class="line-added">6154     ik-&gt;set_invalid_inline_super();</span>
<span class="line-added">6155   }</span>
<span class="line-added">6156 </span>
<span class="line-added">6157   if (_has_injected_identityObject) {</span>
<span class="line-added">6158     ik-&gt;set_has_injected_identityObject();</span>
<span class="line-added">6159   }</span>
<span class="line-added">6160 </span>
6161   assert(_fac != NULL, &quot;invariant&quot;);
6162   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);
6163 
6164   // this transfers ownership of a lot of arrays from
6165   // the parser onto the InstanceKlass*
6166   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6167 
6168   // note that is not safe to use the fields in the parser from this point on
6169   assert(NULL == _cp, &quot;invariant&quot;);
6170   assert(NULL == _fields, &quot;invariant&quot;);
6171   assert(NULL == _methods, &quot;invariant&quot;);
6172   assert(NULL == _inner_classes, &quot;invariant&quot;);
6173   assert(NULL == _nest_members, &quot;invariant&quot;);
6174   assert(NULL == _local_interfaces, &quot;invariant&quot;);
6175   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6176   assert(NULL == _record_components, &quot;invariant&quot;);
6177 
6178   if (_has_final_method) {
6179     ik-&gt;set_has_final_method();
6180   }
</pre>
<hr />
<pre>
6368       // print out the superclass.
6369       const char * from = ik-&gt;external_name();
6370       if (ik-&gt;java_super() != NULL) {
6371         log_debug(class, resolve)(&quot;%s %s (super)&quot;,
6372                    from,
6373                    ik-&gt;java_super()-&gt;external_name());
6374       }
6375       // print out each of the interface classes referred to by this class.
6376       const Array&lt;InstanceKlass*&gt;* const local_interfaces = ik-&gt;local_interfaces();
6377       if (local_interfaces != NULL) {
6378         const int length = local_interfaces-&gt;length();
6379         for (int i = 0; i &lt; length; i++) {
6380           const InstanceKlass* const k = local_interfaces-&gt;at(i);
6381           const char * to = k-&gt;external_name();
6382           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
6383         }
6384       }
6385     }
6386   }
6387 









6388   JFR_ONLY(INIT_ID(ik);)
6389 
6390   // If we reach here, all is well.
6391   // Now remove the InstanceKlass* from the _klass_to_deallocate field
6392   // in order for it to not be destroyed in the ClassFileParser destructor.
6393   set_klass_to_deallocate(NULL);
6394 
6395   // it&#39;s official
6396   set_klass(ik);
6397 
6398   debug_only(ik-&gt;verify();)
6399 }
6400 
6401 void ClassFileParser::update_class_name(Symbol* new_class_name) {
6402   // Decrement the refcount in the old name, since we&#39;re clobbering it.
6403   _class_name-&gt;decrement_refcount();
6404 
6405   _class_name = new_class_name;
6406   // Increment the refcount of the new name.
6407   // Now the ClassFileParser owns this name and will decrement in
</pre>
<hr />
<pre>
6521   _pub_level(pub_level),
6522   _bad_constant_seen(0),
6523   _synthetic_flag(false),
6524   _sde_length(false),
6525   _sde_buffer(NULL),
6526   _sourcefile_index(0),
6527   _generic_signature_index(0),
6528   _major_version(0),
6529   _minor_version(0),
6530   _this_class_index(0),
6531   _super_class_index(0),
6532   _itfs_len(0),
6533   _java_fields_count(0),
6534   _need_verify(false),
6535   _relax_verify(false),
6536   _has_nonstatic_concrete_methods(false),
6537   _declares_nonstatic_concrete_methods(false),
6538   _has_final_method(false),
6539   _has_contended_fields(false),
6540   _has_flattenable_fields(false),
<span class="line-added">6541   _has_nonstatic_fields(false),</span>
6542   _is_empty_value(false),
6543   _is_naturally_atomic(false),
6544   _is_declared_atomic(false),
6545   _invalid_inline_super(false),
6546   _invalid_identity_super(false),
<span class="line-added">6547   _implements_identityObject(false),</span>
<span class="line-added">6548   _has_injected_identityObject(false),</span>
6549   _has_finalizer(false),
6550   _has_empty_finalizer(false),
6551   _has_vanilla_constructor(false),
6552   _max_bootstrap_specifier_index(-1) {
6553 
6554   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6555   _class_name-&gt;increment_refcount();
6556 
6557   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6558   assert(_loader_data != NULL, &quot;invariant&quot;);
6559   assert(stream != NULL, &quot;invariant&quot;);
6560   assert(_stream != NULL, &quot;invariant&quot;);
6561   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6562   assert(_class_name != NULL, &quot;invariant&quot;);
6563   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6564 
6565   // Figure out whether we can skip format checking (matching classic VM behavior)
6566   if (DumpSharedSpaces) {
6567     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6568     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
6872 #endif
6873   }
6874 
6875   // SUPERKLASS
6876   _super_class_index = stream-&gt;get_u2_fast();
6877   _super_klass = parse_super_class(cp,
6878                                    _super_class_index,
6879                                    _need_verify,
6880                                    CHECK);
6881 
6882   // Interfaces
6883   _itfs_len = stream-&gt;get_u2_fast();
6884   parse_interfaces(stream,
6885                    _itfs_len,
6886                    cp,
6887                    is_value_type(),
6888                    &amp;_has_nonstatic_concrete_methods,
6889                    &amp;_is_declared_atomic,
6890                    CHECK);
6891 
<span class="line-modified">6892   assert(_temp_local_interfaces != NULL, &quot;invariant&quot;);</span>
6893 
6894   // Fields (offsets are filled in later)
6895   _fac = new FieldAllocationCount();
6896   parse_fields(stream,
6897                is_interface(),
6898                is_value_type(),
6899                _fac,
6900                cp,
6901                cp_size,
6902                &amp;_java_fields_count,
6903                CHECK);
6904 
6905   assert(_fields != NULL, &quot;invariant&quot;);
6906 
6907   // Methods
6908   AccessFlags promoted_flags;
6909   parse_methods(stream,
6910                 is_interface(),
6911                 is_value_type(),
6912                 &amp;promoted_flags,
</pre>
<hr />
<pre>
6933   // now that all annotation arrays have been created.
6934   create_combined_annotations(CHECK);
6935 
6936   // Make sure this is the end of class file stream
6937   guarantee_property(stream-&gt;at_eos(),
6938                      &quot;Extra bytes at the end of class file %s&quot;,
6939                      CHECK);
6940 
6941   // all bytes in stream read and parsed
6942 }
6943 
6944 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6945                                                  ConstantPool* cp,
6946                                                  TRAPS) {
6947   assert(stream != NULL, &quot;invariant&quot;);
6948   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6949   assert(cp != NULL, &quot;invariant&quot;);
6950   assert(_loader_data != NULL, &quot;invariant&quot;);
6951 
6952   if (_class_name == vmSymbols::java_lang_Object()) {
<span class="line-modified">6953     check_property(_temp_local_interfaces-&gt;length() == 0,</span>
<span class="line-modified">6954         &quot;java.lang.Object cannot implement an interface in class file %s&quot;,</span>
<span class="line-modified">6955         CHECK);</span>
6956   }
6957   // We check super class after class file is parsed and format is checked
6958   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6959     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
6960     if (is_interface()) {
6961       // Before attempting to resolve the superclass, check for class format
6962       // errors not checked yet.
6963       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6964         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6965         CHECK);
6966     }
6967     Handle loader(THREAD, _loader_data-&gt;class_loader());
6968     _super_klass = (const InstanceKlass*)
6969                        SystemDictionary::resolve_super_or_fail(_class_name,
6970                                                                super_class_name,
6971                                                                loader,
6972                                                                _protection_domain,
6973                                                                true,
6974                                                                CHECK);
6975   }
</pre>
<hr />
<pre>
7011           &quot;inline class %s has an invalid super class %s&quot;,
7012           _class_name-&gt;as_klass_external_name(),
7013           _super_klass-&gt;external_name());
7014         return;
7015       }
7016     }
7017   }
7018 
7019   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {
7020     // This is the original source of this condition.
7021     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.
7022     _is_declared_atomic = true;
7023   } else if (*ForceNonTearable != &#39;\0&#39;) {
7024     // Allow a command line switch to force the same atomicity property:
7025     const char* class_name_str = _class_name-&gt;as_C_string();
7026     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {
7027       _is_declared_atomic = true;
7028     }
7029   }
7030 
<span class="line-added">7031   // Set ik-&gt;invalid_inline_super field to TRUE if already marked as invalid,</span>
<span class="line-added">7032   // if super is marked invalid, or if is_invalid_super_for_inline_type()</span>
<span class="line-added">7033   // returns true</span>
<span class="line-added">7034   if (invalid_inline_super() ||</span>
<span class="line-added">7035       (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||</span>
<span class="line-added">7036       is_invalid_super_for_inline_type()) {</span>
<span class="line-added">7037     set_invalid_inline_super();</span>
<span class="line-added">7038   }</span>
<span class="line-added">7039 </span>
<span class="line-added">7040   if (!is_value_type() &amp;&amp; invalid_inline_super() &amp;&amp; (_super_klass == NULL || !_super_klass-&gt;invalid_inline_super())</span>
<span class="line-added">7041       &amp;&amp; !_implements_identityObject &amp;&amp; class_name() != vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">7042     _temp_local_interfaces-&gt;at_put_grow(_temp_local_interfaces-&gt;length(), SystemDictionary::IdentityObject_klass());</span>
<span class="line-added">7043     _has_injected_identityObject = true;</span>
<span class="line-added">7044   }</span>
<span class="line-added">7045   int itfs_len = _temp_local_interfaces-&gt;length();</span>
<span class="line-added">7046   if (itfs_len == 0) {</span>
<span class="line-added">7047     _local_interfaces = Universe::the_empty_instance_klass_array();</span>
<span class="line-added">7048   } else {</span>
<span class="line-added">7049     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);</span>
<span class="line-added">7050     for (int i = 0; i &lt; itfs_len; i++) {</span>
<span class="line-added">7051       _local_interfaces-&gt;at_put(i, _temp_local_interfaces-&gt;at(i));</span>
<span class="line-added">7052     }</span>
<span class="line-added">7053   }</span>
<span class="line-added">7054 </span>
7055   // Compute the transitive list of all unique interfaces implemented by this class
7056   _transitive_interfaces =
7057     compute_transitive_interfaces(_super_klass,
7058                                   _local_interfaces,
7059                                   _loader_data,
7060                                   CHECK);
7061 
7062   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
7063 
7064   // sort methods
7065   _method_ordering = sort_methods(_methods);
7066 
7067   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
7068 
7069   Handle loader(THREAD, _loader_data-&gt;class_loader());
7070   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
7071                                                     &amp;_num_miranda_methods,
7072                                                     _all_mirandas,
7073                                                     _super_klass,
7074                                                     _methods,
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
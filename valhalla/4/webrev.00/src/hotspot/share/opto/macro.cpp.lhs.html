<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/macro.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  28 #include &quot;libadt/vectset.hpp&quot;
  29 #include &quot;memory/universe.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/arraycopynode.hpp&quot;
  32 #include &quot;opto/callnode.hpp&quot;
  33 #include &quot;opto/castnode.hpp&quot;
  34 #include &quot;opto/cfgnode.hpp&quot;
  35 #include &quot;opto/compile.hpp&quot;
  36 #include &quot;opto/convertnode.hpp&quot;
  37 #include &quot;opto/graphKit.hpp&quot;
  38 #include &quot;opto/intrinsicnode.hpp&quot;
  39 #include &quot;opto/locknode.hpp&quot;
  40 #include &quot;opto/loopnode.hpp&quot;
  41 #include &quot;opto/macro.hpp&quot;
  42 #include &quot;opto/memnode.hpp&quot;
  43 #include &quot;opto/narrowptrnode.hpp&quot;
  44 #include &quot;opto/node.hpp&quot;
  45 #include &quot;opto/opaquenode.hpp&quot;
  46 #include &quot;opto/phaseX.hpp&quot;
  47 #include &quot;opto/rootnode.hpp&quot;
  48 #include &quot;opto/runtime.hpp&quot;
  49 #include &quot;opto/subnode.hpp&quot;
  50 #include &quot;opto/subtypenode.hpp&quot;
  51 #include &quot;opto/type.hpp&quot;
  52 #include &quot;opto/valuetypenode.hpp&quot;
  53 #include &quot;runtime/sharedRuntime.hpp&quot;
  54 #include &quot;utilities/macros.hpp&quot;
  55 #include &quot;utilities/powerOfTwo.hpp&quot;
  56 #if INCLUDE_G1GC
  57 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  58 #endif // INCLUDE_G1GC
  59 #if INCLUDE_SHENANDOAHGC
  60 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  61 #endif
  62 
  63 
  64 //
  65 // Replace any references to &quot;oldref&quot; in inputs to &quot;use&quot; with &quot;newref&quot;.
  66 // Returns the number of replacements made.
  67 //
  68 int PhaseMacroExpand::replace_input(Node *use, Node *oldref, Node *newref) {
  69   int nreplacements = 0;
  70   uint req = use-&gt;req();
  71   for (uint j = 0; j &lt; use-&gt;len(); j++) {
  72     Node *uin = use-&gt;in(j);
  73     if (uin == oldref) {
  74       if (j &lt; req)
  75         use-&gt;set_req(j, newref);
  76       else
  77         use-&gt;set_prec(j, newref);
  78       nreplacements++;
  79     } else if (j &gt;= req &amp;&amp; uin == NULL) {
  80       break;
  81     }
  82   }
  83   return nreplacements;
  84 }
  85 
<a name="1" id="anc1"></a><span class="line-removed">  86 void PhaseMacroExpand::migrate_outs(Node *old, Node *target) {</span>
<span class="line-removed">  87   assert(old != NULL, &quot;sanity&quot;);</span>
<span class="line-removed">  88   for (DUIterator_Fast imax, i = old-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">  89     Node* use = old-&gt;fast_out(i);</span>
<span class="line-removed">  90     _igvn.rehash_node_delayed(use);</span>
<span class="line-removed">  91     imax -= replace_input(use, old, target);</span>
<span class="line-removed">  92     // back up iterator</span>
<span class="line-removed">  93     --i;</span>
<span class="line-removed">  94   }</span>
<span class="line-removed">  95   assert(old-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);</span>
<span class="line-removed">  96 }</span>
<span class="line-removed">  97 </span>
  98 Node* PhaseMacroExpand::opt_bits_test(Node* ctrl, Node* region, int edge, Node* word, int mask, int bits, bool return_fast_path) {
  99   Node* cmp;
 100   if (mask != 0) {
 101     Node* and_node = transform_later(new AndXNode(word, MakeConX(mask)));
 102     cmp = transform_later(new CmpXNode(and_node, MakeConX(bits)));
 103   } else {
 104     cmp = word;
 105   }
 106   Node* bol = transform_later(new BoolNode(cmp, BoolTest::ne));
 107   IfNode* iff = new IfNode( ctrl, bol, PROB_MIN, COUNT_UNKNOWN );
 108   transform_later(iff);
 109 
 110   // Fast path taken.
 111   Node *fast_taken = transform_later(new IfFalseNode(iff));
 112 
 113   // Fast path not-taken, i.e. slow path
 114   Node *slow_taken = transform_later(new IfTrueNode(iff));
 115 
 116   if (return_fast_path) {
 117     region-&gt;init_req(edge, slow_taken); // Capture slow-control
 118     return fast_taken;
 119   } else {
 120     region-&gt;init_req(edge, fast_taken); // Capture fast-control
 121     return slow_taken;
 122   }
 123 }
 124 
 125 //--------------------copy_predefined_input_for_runtime_call--------------------
 126 void PhaseMacroExpand::copy_predefined_input_for_runtime_call(Node * ctrl, CallNode* oldcall, CallNode* call) {
 127   // Set fixed predefined input arguments
 128   call-&gt;init_req( TypeFunc::Control, ctrl );
 129   call-&gt;init_req( TypeFunc::I_O    , oldcall-&gt;in( TypeFunc::I_O) );
 130   call-&gt;init_req( TypeFunc::Memory , oldcall-&gt;in( TypeFunc::Memory ) ); // ?????
 131   call-&gt;init_req( TypeFunc::ReturnAdr, oldcall-&gt;in( TypeFunc::ReturnAdr ) );
 132   call-&gt;init_req( TypeFunc::FramePtr, oldcall-&gt;in( TypeFunc::FramePtr ) );
 133 }
 134 
 135 //------------------------------make_slow_call---------------------------------
 136 CallNode* PhaseMacroExpand::make_slow_call(CallNode *oldcall, const TypeFunc* slow_call_type,
 137                                            address slow_call, const char* leaf_name, Node* slow_path,
 138                                            Node* parm0, Node* parm1, Node* parm2) {
 139 
 140   // Slow-path call
 141  CallNode *call = leaf_name
 142    ? (CallNode*)new CallLeafNode      ( slow_call_type, slow_call, leaf_name, TypeRawPtr::BOTTOM )
 143    : (CallNode*)new CallStaticJavaNode( slow_call_type, slow_call, OptoRuntime::stub_name(slow_call), oldcall-&gt;jvms()-&gt;bci(), TypeRawPtr::BOTTOM );
 144 
 145   // Slow path call has no side-effects, uses few values
 146   copy_predefined_input_for_runtime_call(slow_path, oldcall, call );
 147   if (parm0 != NULL)  call-&gt;init_req(TypeFunc::Parms+0, parm0);
 148   if (parm1 != NULL)  call-&gt;init_req(TypeFunc::Parms+1, parm1);
 149   if (parm2 != NULL)  call-&gt;init_req(TypeFunc::Parms+2, parm2);
 150   call-&gt;copy_call_debug_info(&amp;_igvn, oldcall);
 151   call-&gt;set_cnt(PROB_UNLIKELY_MAG(4));  // Same effect as RC_UNCOMMON.
 152   _igvn.replace_node(oldcall, call);
 153   transform_later(call);
 154 
 155   return call;
 156 }
 157 
 158 void PhaseMacroExpand::extract_call_projections(CallNode *call) {
 159   _fallthroughproj = NULL;
 160   _fallthroughcatchproj = NULL;
 161   _ioproj_fallthrough = NULL;
 162   _ioproj_catchall = NULL;
 163   _catchallcatchproj = NULL;
 164   _memproj_fallthrough = NULL;
 165   _memproj_catchall = NULL;
 166   _resproj = NULL;
 167   for (DUIterator_Fast imax, i = call-&gt;fast_outs(imax); i &lt; imax; i++) {
 168     ProjNode *pn = call-&gt;fast_out(i)-&gt;as_Proj();
 169     switch (pn-&gt;_con) {
 170       case TypeFunc::Control:
 171       {
 172         // For Control (fallthrough) and I_O (catch_all_index) we have CatchProj -&gt; Catch -&gt; Proj
 173         _fallthroughproj = pn;
 174         DUIterator_Fast jmax, j = pn-&gt;fast_outs(jmax);
 175         const Node *cn = pn-&gt;fast_out(j);
 176         if (cn-&gt;is_Catch()) {
 177           ProjNode *cpn = NULL;
 178           for (DUIterator_Fast kmax, k = cn-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 179             cpn = cn-&gt;fast_out(k)-&gt;as_Proj();
 180             assert(cpn-&gt;is_CatchProj(), &quot;must be a CatchProjNode&quot;);
 181             if (cpn-&gt;_con == CatchProjNode::fall_through_index)
 182               _fallthroughcatchproj = cpn;
 183             else {
 184               assert(cpn-&gt;_con == CatchProjNode::catch_all_index, &quot;must be correct index.&quot;);
 185               _catchallcatchproj = cpn;
 186             }
 187           }
 188         }
 189         break;
 190       }
 191       case TypeFunc::I_O:
 192         if (pn-&gt;_is_io_use)
 193           _ioproj_catchall = pn;
 194         else
 195           _ioproj_fallthrough = pn;
 196         break;
 197       case TypeFunc::Memory:
 198         if (pn-&gt;_is_io_use)
 199           _memproj_catchall = pn;
 200         else
 201           _memproj_fallthrough = pn;
 202         break;
 203       case TypeFunc::Parms:
 204         _resproj = pn;
 205         break;
 206       default:
 207         assert(false, &quot;unexpected projection from allocation node.&quot;);
 208     }
 209   }
 210 
 211 }
 212 
 213 void PhaseMacroExpand::eliminate_gc_barrier(Node* p2x) {
 214   BarrierSetC2 *bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 215   bs-&gt;eliminate_gc_barrier(this, p2x);
 216 }
 217 
 218 // Search for a memory operation for the specified memory slice.
 219 static Node *scan_mem_chain(Node *mem, int alias_idx, int offset, Node *start_mem, Node *alloc, PhaseGVN *phase) {
 220   Node *orig_mem = mem;
 221   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 222   const TypeOopPtr *tinst = phase-&gt;C-&gt;get_adr_type(alias_idx)-&gt;isa_oopptr();
 223   while (true) {
 224     if (mem == alloc_mem || mem == start_mem ) {
 225       return mem;  // hit one of our sentinels
 226     } else if (mem-&gt;is_MergeMem()) {
 227       mem = mem-&gt;as_MergeMem()-&gt;memory_at(alias_idx);
 228     } else if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;as_Proj()-&gt;_con == TypeFunc::Memory) {
 229       Node *in = mem-&gt;in(0);
 230       // we can safely skip over safepoints, calls, locks and membars because we
 231       // already know that the object is safe to eliminate.
 232       if (in-&gt;is_Initialize() &amp;&amp; in-&gt;as_Initialize()-&gt;allocation() == alloc) {
 233         return in;
 234       } else if (in-&gt;is_Call()) {
 235         CallNode *call = in-&gt;as_Call();
 236         if (call-&gt;may_modify(tinst, phase)) {
 237           assert(call-&gt;is_ArrayCopy(), &quot;ArrayCopy is the only call node that doesn&#39;t make allocation escape&quot;);
 238           if (call-&gt;as_ArrayCopy()-&gt;modifies(offset, offset, phase, false)) {
 239             return in;
 240           }
 241         }
 242         mem = in-&gt;in(TypeFunc::Memory);
 243       } else if (in-&gt;is_MemBar()) {
 244         ArrayCopyNode* ac = NULL;
 245         if (ArrayCopyNode::may_modify(tinst, in-&gt;as_MemBar(), phase, ac)) {
 246           assert(ac != NULL &amp;&amp; ac-&gt;is_clonebasic(), &quot;Only basic clone is a non escaping clone&quot;);
 247           return ac;
 248         }
 249         mem = in-&gt;in(TypeFunc::Memory);
 250       } else {
 251         assert(false, &quot;unexpected projection&quot;);
 252       }
 253     } else if (mem-&gt;is_Store()) {
 254       const TypePtr* atype = mem-&gt;as_Store()-&gt;adr_type();
 255       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 256       if (adr_idx == alias_idx) {
 257         assert(atype-&gt;isa_oopptr(), &quot;address type must be oopptr&quot;);
 258         int adr_offset = atype-&gt;flattened_offset();
 259         uint adr_iid = atype-&gt;is_oopptr()-&gt;instance_id();
 260         // Array elements references have the same alias_idx
 261         // but different offset and different instance_id.
 262         if (adr_offset == offset &amp;&amp; adr_iid == alloc-&gt;_idx)
 263           return mem;
 264       } else {
 265         assert(adr_idx == Compile::AliasIdxRaw, &quot;address must match or be raw&quot;);
 266       }
 267       mem = mem-&gt;in(MemNode::Memory);
 268     } else if (mem-&gt;is_ClearArray()) {
 269       if (!ClearArrayNode::step_through(&amp;mem, alloc-&gt;_idx, phase)) {
 270         // Can not bypass initialization of the instance
 271         // we are looking.
 272         debug_only(intptr_t offset;)
 273         assert(alloc == AllocateNode::Ideal_allocation(mem-&gt;in(3), phase, offset), &quot;sanity&quot;);
 274         InitializeNode* init = alloc-&gt;as_Allocate()-&gt;initialization();
 275         // We are looking for stored value, return Initialize node
 276         // or memory edge from Allocate node.
 277         if (init != NULL)
 278           return init;
 279         else
 280           return alloc-&gt;in(TypeFunc::Memory); // It will produce zero value (see callers).
 281       }
 282       // Otherwise skip it (the call updated &#39;mem&#39; value).
 283     } else if (mem-&gt;Opcode() == Op_SCMemProj) {
 284       mem = mem-&gt;in(0);
 285       Node* adr = NULL;
 286       if (mem-&gt;is_LoadStore()) {
 287         adr = mem-&gt;in(MemNode::Address);
 288       } else {
 289         assert(mem-&gt;Opcode() == Op_EncodeISOArray ||
 290                mem-&gt;Opcode() == Op_StrCompressedCopy, &quot;sanity&quot;);
 291         adr = mem-&gt;in(3); // Destination array
 292       }
 293       const TypePtr* atype = adr-&gt;bottom_type()-&gt;is_ptr();
 294       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 295       if (adr_idx == alias_idx) {
 296         DEBUG_ONLY(mem-&gt;dump();)
 297         assert(false, &quot;Object is not scalar replaceable if a LoadStore node accesses its field&quot;);
 298         return NULL;
 299       }
 300       mem = mem-&gt;in(MemNode::Memory);
 301     } else if (mem-&gt;Opcode() == Op_StrInflatedCopy) {
 302       Node* adr = mem-&gt;in(3); // Destination array
 303       const TypePtr* atype = adr-&gt;bottom_type()-&gt;is_ptr();
 304       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 305       if (adr_idx == alias_idx) {
 306         DEBUG_ONLY(mem-&gt;dump();)
 307         assert(false, &quot;Object is not scalar replaceable if a StrInflatedCopy node accesses its field&quot;);
 308         return NULL;
 309       }
 310       mem = mem-&gt;in(MemNode::Memory);
 311     } else {
 312       return mem;
 313     }
 314     assert(mem != orig_mem, &quot;dead memory loop&quot;);
 315   }
 316 }
 317 
 318 // Generate loads from source of the arraycopy for fields of
 319 // destination needed at a deoptimization point
 320 Node* PhaseMacroExpand::make_arraycopy_load(ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc) {
 321   BasicType bt = ft;
 322   const Type *type = ftype;
 323   if (ft == T_NARROWOOP) {
 324     bt = T_OBJECT;
 325     type = ftype-&gt;make_oopptr();
 326   }
 327   Node* res = NULL;
 328   if (ac-&gt;is_clonebasic()) {
 329     assert(ac-&gt;in(ArrayCopyNode::Src) != ac-&gt;in(ArrayCopyNode::Dest), &quot;clone source equals destination&quot;);
 330     Node* base = ac-&gt;in(ArrayCopyNode::Src)-&gt;in(AddPNode::Base);
 331     Node* adr = _igvn.transform(new AddPNode(base, base, MakeConX(offset)));
 332     const TypePtr* adr_type = _igvn.type(base)-&gt;is_ptr()-&gt;add_offset(offset);
 333     res = LoadNode::make(_igvn, ctl, mem, adr, adr_type, type, bt, MemNode::unordered, LoadNode::UnknownControl);
 334   } else {
 335     if (ac-&gt;modifies(offset, offset, &amp;_igvn, true)) {
 336       assert(ac-&gt;in(ArrayCopyNode::Dest) == alloc-&gt;result_cast(), &quot;arraycopy destination should be allocation&#39;s result&quot;);
 337       uint shift = exact_log2(type2aelembytes(bt));
 338       Node* src_pos = ac-&gt;in(ArrayCopyNode::SrcPos);
 339       Node* dest_pos = ac-&gt;in(ArrayCopyNode::DestPos);
 340       const TypeInt* src_pos_t = _igvn.type(src_pos)-&gt;is_int();
 341       const TypeInt* dest_pos_t = _igvn.type(dest_pos)-&gt;is_int();
 342 
 343       Node* adr = NULL;
 344       Node* base = ac-&gt;in(ArrayCopyNode::Src);
 345       const TypePtr* adr_type = _igvn.type(base)-&gt;is_ptr();
 346       assert(adr_type-&gt;isa_aryptr(), &quot;only arrays here&quot;);
 347       if (src_pos_t-&gt;is_con() &amp;&amp; dest_pos_t-&gt;is_con()) {
 348         intptr_t off = ((src_pos_t-&gt;get_con() - dest_pos_t-&gt;get_con()) &lt;&lt; shift) + offset;
 349         adr = _igvn.transform(new AddPNode(base, base, MakeConX(off)));
 350         adr_type = _igvn.type(adr)-&gt;is_ptr();
 351         assert(adr_type == _igvn.type(base)-&gt;is_aryptr()-&gt;add_field_offset_and_offset(off), &quot;incorrect address type&quot;);
 352         if (ac-&gt;in(ArrayCopyNode::Src) == ac-&gt;in(ArrayCopyNode::Dest)) {
 353           // Don&#39;t emit a new load from src if src == dst but try to get the value from memory instead
 354           return value_from_mem(ac-&gt;in(TypeFunc::Memory), ctl, ft, ftype, adr_type-&gt;isa_oopptr(), alloc);
 355         }
 356       } else {
 357         if (ac-&gt;in(ArrayCopyNode::Src) == ac-&gt;in(ArrayCopyNode::Dest)) {
 358           // Non constant offset in the array: we can&#39;t statically
 359           // determine the value
 360           return NULL;
 361         }
 362         Node* diff = _igvn.transform(new SubINode(ac-&gt;in(ArrayCopyNode::SrcPos), ac-&gt;in(ArrayCopyNode::DestPos)));
 363 #ifdef _LP64
 364         diff = _igvn.transform(new ConvI2LNode(diff));
 365 #endif
 366         diff = _igvn.transform(new LShiftXNode(diff, intcon(shift)));
 367 
 368         Node* off = _igvn.transform(new AddXNode(MakeConX(offset), diff));
 369         adr = _igvn.transform(new AddPNode(base, base, off));
 370         // In the case of a flattened value type array, each field has its
 371         // own slice so we need to extract the field being accessed from
 372         // the address computation
 373         adr_type = adr_type-&gt;is_aryptr()-&gt;add_field_offset_and_offset(offset)-&gt;add_offset(Type::OffsetBot);
 374         adr = _igvn.transform(new CastPPNode(adr, adr_type));
 375       }
 376       res = LoadNode::make(_igvn, ctl, mem, adr, adr_type, type, bt, MemNode::unordered, LoadNode::UnknownControl);
 377     }
 378   }
 379   if (res != NULL) {
 380     res = _igvn.transform(res);
 381     if (ftype-&gt;isa_narrowoop()) {
 382       // PhaseMacroExpand::scalar_replacement adds DecodeN nodes
 383       assert(res-&gt;isa_DecodeN(), &quot;should be narrow oop&quot;);
 384       res = _igvn.transform(new EncodePNode(res, ftype));
 385     }
 386     return res;
 387   }
 388   return NULL;
 389 }
 390 
 391 //
 392 // Given a Memory Phi, compute a value Phi containing the values from stores
 393 // on the input paths.
 394 // Note: this function is recursive, its depth is limited by the &quot;level&quot; argument
 395 // Returns the computed Phi, or NULL if it cannot compute it.
 396 Node *PhaseMacroExpand::value_from_mem_phi(Node *mem, BasicType ft, const Type *phi_type, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level) {
 397   assert(mem-&gt;is_Phi(), &quot;sanity&quot;);
 398   int alias_idx = C-&gt;get_alias_index(adr_t);
 399   int offset = adr_t-&gt;flattened_offset();
 400   int instance_id = adr_t-&gt;instance_id();
 401 
 402   // Check if an appropriate value phi already exists.
 403   Node* region = mem-&gt;in(0);
 404   for (DUIterator_Fast kmax, k = region-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 405     Node* phi = region-&gt;fast_out(k);
 406     if (phi-&gt;is_Phi() &amp;&amp; phi != mem &amp;&amp;
 407         phi-&gt;as_Phi()-&gt;is_same_inst_field(phi_type, (int)mem-&gt;_idx, instance_id, alias_idx, offset)) {
 408       return phi;
 409     }
 410   }
 411   // Check if an appropriate new value phi already exists.
 412   Node* new_phi = value_phis-&gt;find(mem-&gt;_idx);
 413   if (new_phi != NULL)
 414     return new_phi;
 415 
 416   if (level &lt;= 0) {
 417     return NULL; // Give up: phi tree too deep
 418   }
 419   Node *start_mem = C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);
 420   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 421 
 422   uint length = mem-&gt;req();
 423   GrowableArray &lt;Node *&gt; values(length, length, NULL, false);
 424 
 425   // create a new Phi for the value
 426   PhiNode *phi = new PhiNode(mem-&gt;in(0), phi_type, NULL, mem-&gt;_idx, instance_id, alias_idx, offset);
 427   transform_later(phi);
 428   value_phis-&gt;push(phi, mem-&gt;_idx);
 429 
 430   for (uint j = 1; j &lt; length; j++) {
 431     Node *in = mem-&gt;in(j);
 432     if (in == NULL || in-&gt;is_top()) {
 433       values.at_put(j, in);
 434     } else  {
 435       Node *val = scan_mem_chain(in, alias_idx, offset, start_mem, alloc, &amp;_igvn);
 436       if (val == start_mem || val == alloc_mem) {
 437         // hit a sentinel, return appropriate 0 value
 438         Node* default_value = alloc-&gt;in(AllocateNode::DefaultValue);
 439         if (default_value != NULL) {
 440           values.at_put(j, default_value);
 441         } else {
 442           assert(alloc-&gt;in(AllocateNode::RawDefaultValue) == NULL, &quot;default value may not be null&quot;);
 443           values.at_put(j, _igvn.zerocon(ft));
 444         }
 445         continue;
 446       }
 447       if (val-&gt;is_Initialize()) {
 448         val = val-&gt;as_Initialize()-&gt;find_captured_store(offset, type2aelembytes(ft), &amp;_igvn);
 449       }
 450       if (val == NULL) {
 451         return NULL;  // can&#39;t find a value on this path
 452       }
 453       if (val == mem) {
 454         values.at_put(j, mem);
 455       } else if (val-&gt;is_Store()) {
 456         Node* n = val-&gt;in(MemNode::ValueIn);
 457         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 458         n = bs-&gt;step_over_gc_barrier(n);
 459         values.at_put(j, n);
 460       } else if(val-&gt;is_Proj() &amp;&amp; val-&gt;in(0) == alloc) {
 461         Node* default_value = alloc-&gt;in(AllocateNode::DefaultValue);
 462         if (default_value != NULL) {
 463           values.at_put(j, default_value);
 464         } else {
 465           assert(alloc-&gt;in(AllocateNode::RawDefaultValue) == NULL, &quot;default value may not be null&quot;);
 466           values.at_put(j, _igvn.zerocon(ft));
 467         }
 468       } else if (val-&gt;is_Phi()) {
 469         val = value_from_mem_phi(val, ft, phi_type, adr_t, alloc, value_phis, level-1);
 470         if (val == NULL) {
 471           return NULL;
 472         }
 473         values.at_put(j, val);
 474       } else if (val-&gt;Opcode() == Op_SCMemProj) {
 475         assert(val-&gt;in(0)-&gt;is_LoadStore() ||
 476                val-&gt;in(0)-&gt;Opcode() == Op_EncodeISOArray ||
 477                val-&gt;in(0)-&gt;Opcode() == Op_StrCompressedCopy, &quot;sanity&quot;);
 478         assert(false, &quot;Object is not scalar replaceable if a LoadStore node accesses its field&quot;);
 479         return NULL;
 480       } else if (val-&gt;is_ArrayCopy()) {
 481         Node* res = make_arraycopy_load(val-&gt;as_ArrayCopy(), offset, val-&gt;in(0), val-&gt;in(TypeFunc::Memory), ft, phi_type, alloc);
 482         if (res == NULL) {
 483           return NULL;
 484         }
 485         values.at_put(j, res);
 486       } else {
 487 #ifdef ASSERT
 488         val-&gt;dump();
 489         assert(false, &quot;unknown node on this path&quot;);
 490 #endif
 491         return NULL;  // unknown node on this path
 492       }
 493     }
 494   }
 495   // Set Phi&#39;s inputs
 496   for (uint j = 1; j &lt; length; j++) {
 497     if (values.at(j) == mem) {
 498       phi-&gt;init_req(j, phi);
 499     } else {
 500       phi-&gt;init_req(j, values.at(j));
 501     }
 502   }
 503   return phi;
 504 }
 505 
 506 // Search the last value stored into the object&#39;s field.
 507 Node *PhaseMacroExpand::value_from_mem(Node *sfpt_mem, Node *sfpt_ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc) {
 508   assert(adr_t-&gt;is_known_instance_field(), &quot;instance required&quot;);
 509   int instance_id = adr_t-&gt;instance_id();
 510   assert((uint)instance_id == alloc-&gt;_idx, &quot;wrong allocation&quot;);
 511 
 512   int alias_idx = C-&gt;get_alias_index(adr_t);
 513   int offset = adr_t-&gt;flattened_offset();
 514   Node *start_mem = C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);
 515   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 516   Arena *a = Thread::current()-&gt;resource_area();
 517   VectorSet visited(a);
 518 
 519   bool done = sfpt_mem == alloc_mem;
 520   Node *mem = sfpt_mem;
 521   while (!done) {
 522     if (visited.test_set(mem-&gt;_idx)) {
 523       return NULL;  // found a loop, give up
 524     }
 525     mem = scan_mem_chain(mem, alias_idx, offset, start_mem, alloc, &amp;_igvn);
 526     if (mem == start_mem || mem == alloc_mem) {
 527       done = true;  // hit a sentinel, return appropriate 0 value
 528     } else if (mem-&gt;is_Initialize()) {
 529       mem = mem-&gt;as_Initialize()-&gt;find_captured_store(offset, type2aelembytes(ft), &amp;_igvn);
 530       if (mem == NULL) {
 531         done = true; // Something went wrong.
 532       } else if (mem-&gt;is_Store()) {
 533         const TypePtr* atype = mem-&gt;as_Store()-&gt;adr_type();
 534         assert(C-&gt;get_alias_index(atype) == Compile::AliasIdxRaw, &quot;store is correct memory slice&quot;);
 535         done = true;
 536       }
 537     } else if (mem-&gt;is_Store()) {
 538       const TypeOopPtr* atype = mem-&gt;as_Store()-&gt;adr_type()-&gt;isa_oopptr();
 539       assert(atype != NULL, &quot;address type must be oopptr&quot;);
 540       assert(C-&gt;get_alias_index(atype) == alias_idx &amp;&amp;
 541              atype-&gt;is_known_instance_field() &amp;&amp; atype-&gt;flattened_offset() == offset &amp;&amp;
 542              atype-&gt;instance_id() == instance_id, &quot;store is correct memory slice&quot;);
 543       done = true;
 544     } else if (mem-&gt;is_Phi()) {
 545       // try to find a phi&#39;s unique input
 546       Node *unique_input = NULL;
 547       Node *top = C-&gt;top();
 548       for (uint i = 1; i &lt; mem-&gt;req(); i++) {
 549         Node *n = scan_mem_chain(mem-&gt;in(i), alias_idx, offset, start_mem, alloc, &amp;_igvn);
 550         if (n == NULL || n == top || n == mem) {
 551           continue;
 552         } else if (unique_input == NULL) {
 553           unique_input = n;
 554         } else if (unique_input != n) {
 555           unique_input = top;
 556           break;
 557         }
 558       }
 559       if (unique_input != NULL &amp;&amp; unique_input != top) {
 560         mem = unique_input;
 561       } else {
 562         done = true;
 563       }
 564     } else if (mem-&gt;is_ArrayCopy()) {
 565       done = true;
 566     } else {
 567       assert(false, &quot;unexpected node&quot;);
 568     }
 569   }
 570   if (mem != NULL) {
 571     if (mem == start_mem || mem == alloc_mem) {
 572       // hit a sentinel, return appropriate 0 value
 573       Node* default_value = alloc-&gt;in(AllocateNode::DefaultValue);
 574       if (default_value != NULL) {
 575         return default_value;
 576       }
 577       assert(alloc-&gt;in(AllocateNode::RawDefaultValue) == NULL, &quot;default value may not be null&quot;);
 578       return _igvn.zerocon(ft);
 579     } else if (mem-&gt;is_Store()) {
 580       Node* n = mem-&gt;in(MemNode::ValueIn);
 581       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 582       n = bs-&gt;step_over_gc_barrier(n);
 583       return n;
 584     } else if (mem-&gt;is_Phi()) {
 585       // attempt to produce a Phi reflecting the values on the input paths of the Phi
 586       Node_Stack value_phis(a, 8);
 587       Node * phi = value_from_mem_phi(mem, ft, ftype, adr_t, alloc, &amp;value_phis, ValueSearchLimit);
 588       if (phi != NULL) {
 589         return phi;
 590       } else {
 591         // Kill all new Phis
 592         while(value_phis.is_nonempty()) {
 593           Node* n = value_phis.node();
 594           _igvn.replace_node(n, C-&gt;top());
 595           value_phis.pop();
 596         }
 597       }
 598     } else if (mem-&gt;is_ArrayCopy()) {
 599       Node* ctl = mem-&gt;in(0);
 600       Node* m = mem-&gt;in(TypeFunc::Memory);
 601       if (sfpt_ctl-&gt;is_Proj() &amp;&amp; sfpt_ctl-&gt;as_Proj()-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none)) {
 602         // pin the loads in the uncommon trap path
 603         ctl = sfpt_ctl;
 604         m = sfpt_mem;
 605       }
 606       return make_arraycopy_load(mem-&gt;as_ArrayCopy(), offset, ctl, m, ft, ftype, alloc);
 607     }
 608   }
 609   // Something went wrong.
 610   return NULL;
 611 }
 612 
 613 // Search the last value stored into the value type&#39;s fields.
 614 Node* PhaseMacroExpand::value_type_from_mem(Node* mem, Node* ctl, ciValueKlass* vk, const TypeAryPtr* adr_type, int offset, AllocateNode* alloc) {
 615   // Subtract the offset of the first field to account for the missing oop header
 616   offset -= vk-&gt;first_field_offset();
 617   // Create a new ValueTypeNode and retrieve the field values from memory
 618   ValueTypeNode* vt = ValueTypeNode::make_uninitialized(_igvn, vk)-&gt;as_ValueType();
 619   for (int i = 0; i &lt; vk-&gt;nof_declared_nonstatic_fields(); ++i) {
 620     ciType* field_type = vt-&gt;field_type(i);
 621     int field_offset = offset + vt-&gt;field_offset(i);
 622     // Each value type field has its own memory slice
 623     adr_type = adr_type-&gt;with_field_offset(field_offset);
 624     Node* value = NULL;
 625     if (vt-&gt;field_is_flattened(i)) {
 626       value = value_type_from_mem(mem, ctl, field_type-&gt;as_value_klass(), adr_type, field_offset, alloc);
 627     } else {
 628       const Type* ft = Type::get_const_type(field_type);
 629       BasicType bt = field_type-&gt;basic_type();
 630       if (UseCompressedOops &amp;&amp; !is_java_primitive(bt)) {
 631         ft = ft-&gt;make_narrowoop();
 632         bt = T_NARROWOOP;
 633       }
 634       value = value_from_mem(mem, ctl, bt, ft, adr_type, alloc);
 635       if (value != NULL &amp;&amp; ft-&gt;isa_narrowoop()) {
 636         assert(UseCompressedOops, &quot;unexpected narrow oop&quot;);
 637         value = transform_later(new DecodeNNode(value, value-&gt;get_ptr_type()));
 638       }
 639     }
 640     if (value != NULL) {
 641       vt-&gt;set_field_value(i, value);
 642     } else {
 643       // We might have reached the TrackedInitializationLimit
 644       return NULL;
 645     }
 646   }
 647   return transform_later(vt);
 648 }
 649 
 650 // Check the possibility of scalar replacement.
 651 bool PhaseMacroExpand::can_eliminate_allocation(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints) {
 652   //  Scan the uses of the allocation to check for anything that would
 653   //  prevent us from eliminating it.
 654   NOT_PRODUCT( const char* fail_eliminate = NULL; )
 655   DEBUG_ONLY( Node* disq_node = NULL; )
 656   bool  can_eliminate = true;
 657 
 658   Node* res = alloc-&gt;result_cast();
 659   const TypeOopPtr* res_type = NULL;
 660   if (res == NULL) {
 661     // All users were eliminated.
 662   } else if (!res-&gt;is_CheckCastPP()) {
 663     NOT_PRODUCT(fail_eliminate = &quot;Allocation does not have unique CheckCastPP&quot;;)
 664     can_eliminate = false;
 665   } else {
 666     res_type = _igvn.type(res)-&gt;isa_oopptr();
 667     if (res_type == NULL) {
 668       NOT_PRODUCT(fail_eliminate = &quot;Neither instance or array allocation&quot;;)
 669       can_eliminate = false;
 670     } else if (res_type-&gt;isa_aryptr()) {
 671       int length = alloc-&gt;in(AllocateNode::ALength)-&gt;find_int_con(-1);
 672       if (length &lt; 0) {
 673         NOT_PRODUCT(fail_eliminate = &quot;Array&#39;s size is not constant&quot;;)
 674         can_eliminate = false;
 675       }
 676     }
 677   }
 678 
 679   if (can_eliminate &amp;&amp; res != NULL) {
 680     for (DUIterator_Fast jmax, j = res-&gt;fast_outs(jmax);
 681                                j &lt; jmax &amp;&amp; can_eliminate; j++) {
 682       Node* use = res-&gt;fast_out(j);
 683 
 684       if (use-&gt;is_AddP()) {
 685         const TypePtr* addp_type = _igvn.type(use)-&gt;is_ptr();
 686         int offset = addp_type-&gt;offset();
 687 
 688         if (offset == Type::OffsetTop || offset == Type::OffsetBot) {
 689           NOT_PRODUCT(fail_eliminate = &quot;Undefined field referrence&quot;;)
 690           can_eliminate = false;
 691           break;
 692         }
 693         for (DUIterator_Fast kmax, k = use-&gt;fast_outs(kmax);
 694                                    k &lt; kmax &amp;&amp; can_eliminate; k++) {
 695           Node* n = use-&gt;fast_out(k);
 696           if (!n-&gt;is_Store() &amp;&amp; n-&gt;Opcode() != Op_CastP2X &amp;&amp;
 697               SHENANDOAHGC_ONLY((!UseShenandoahGC || !ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(n)) &amp;&amp;)
 698               !(n-&gt;is_ArrayCopy() &amp;&amp;
 699                 n-&gt;as_ArrayCopy()-&gt;is_clonebasic() &amp;&amp;
 700                 n-&gt;in(ArrayCopyNode::Dest) == use)) {
 701             DEBUG_ONLY(disq_node = n;)
 702             if (n-&gt;is_Load() || n-&gt;is_LoadStore()) {
 703               NOT_PRODUCT(fail_eliminate = &quot;Field load&quot;;)
 704             } else {
 705               NOT_PRODUCT(fail_eliminate = &quot;Not store field reference&quot;;)
 706             }
 707             can_eliminate = false;
 708           }
 709         }
 710       } else if (use-&gt;is_ArrayCopy() &amp;&amp;
 711                  (use-&gt;as_ArrayCopy()-&gt;is_arraycopy_validated() ||
 712                   use-&gt;as_ArrayCopy()-&gt;is_copyof_validated() ||
 713                   use-&gt;as_ArrayCopy()-&gt;is_copyofrange_validated()) &amp;&amp;
 714                  use-&gt;in(ArrayCopyNode::Dest) == res) {
 715         // ok to eliminate
 716       } else if (use-&gt;is_SafePoint()) {
 717         SafePointNode* sfpt = use-&gt;as_SafePoint();
 718         if (sfpt-&gt;is_Call() &amp;&amp; sfpt-&gt;as_Call()-&gt;has_non_debug_use(res)) {
 719           // Object is passed as argument.
 720           DEBUG_ONLY(disq_node = use;)
 721           NOT_PRODUCT(fail_eliminate = &quot;Object is passed as argument&quot;;)
 722           can_eliminate = false;
 723         }
 724         Node* sfptMem = sfpt-&gt;memory();
 725         if (sfptMem == NULL || sfptMem-&gt;is_top()) {
 726           DEBUG_ONLY(disq_node = use;)
 727           NOT_PRODUCT(fail_eliminate = &quot;NULL or TOP memory&quot;;)
 728           can_eliminate = false;
 729         } else {
 730           safepoints.append_if_missing(sfpt);
 731         }
 732       } else if (use-&gt;is_ValueType() &amp;&amp; use-&gt;isa_ValueType()-&gt;get_oop() == res) {
 733         // ok to eliminate
 734       } else if (use-&gt;Opcode() == Op_StoreX &amp;&amp; use-&gt;in(MemNode::Address) == res) {
 735         // store to mark work
 736       } else if (use-&gt;Opcode() != Op_CastP2X) { // CastP2X is used by card mark
 737         if (use-&gt;is_Phi()) {
 738           if (use-&gt;outcnt() == 1 &amp;&amp; use-&gt;unique_out()-&gt;Opcode() == Op_Return) {
 739             NOT_PRODUCT(fail_eliminate = &quot;Object is return value&quot;;)
 740           } else {
 741             NOT_PRODUCT(fail_eliminate = &quot;Object is referenced by Phi&quot;;)
 742           }
 743           DEBUG_ONLY(disq_node = use;)
 744         } else {
 745           if (use-&gt;Opcode() == Op_Return) {
 746             NOT_PRODUCT(fail_eliminate = &quot;Object is return value&quot;;)
 747           } else {
 748             NOT_PRODUCT(fail_eliminate = &quot;Object is referenced by node&quot;;)
 749           }
 750           DEBUG_ONLY(disq_node = use;)
 751         }
 752         can_eliminate = false;
 753       } else {
 754         assert(use-&gt;Opcode() == Op_CastP2X, &quot;should be&quot;);
 755         assert(!use-&gt;has_out_with(Op_OrL), &quot;should have been removed because oop is never null&quot;);
 756       }
 757     }
 758   }
 759 
 760 #ifndef PRODUCT
 761   if (PrintEliminateAllocations) {
 762     if (can_eliminate) {
 763       tty-&gt;print(&quot;Scalar &quot;);
 764       if (res == NULL)
 765         alloc-&gt;dump();
 766       else
 767         res-&gt;dump();
 768     } else if (alloc-&gt;_is_scalar_replaceable) {
 769       tty-&gt;print(&quot;NotScalar (%s)&quot;, fail_eliminate);
 770       if (res == NULL)
 771         alloc-&gt;dump();
 772       else
 773         res-&gt;dump();
 774 #ifdef ASSERT
 775       if (disq_node != NULL) {
 776           tty-&gt;print(&quot;  &gt;&gt;&gt;&gt; &quot;);
 777           disq_node-&gt;dump();
 778       }
 779 #endif /*ASSERT*/
 780     }
 781   }
 782 #endif
 783   return can_eliminate;
 784 }
 785 
 786 // Do scalar replacement.
 787 bool PhaseMacroExpand::scalar_replacement(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints) {
 788   GrowableArray &lt;SafePointNode *&gt; safepoints_done;
 789 
 790   ciKlass* klass = NULL;
 791   ciInstanceKlass* iklass = NULL;
 792   int nfields = 0;
 793   int array_base = 0;
 794   int element_size = 0;
 795   BasicType basic_elem_type = T_ILLEGAL;
 796   ciType* elem_type = NULL;
 797 
 798   Node* res = alloc-&gt;result_cast();
 799   assert(res == NULL || res-&gt;is_CheckCastPP(), &quot;unexpected AllocateNode result&quot;);
 800   const TypeOopPtr* res_type = NULL;
 801   if (res != NULL) { // Could be NULL when there are no users
 802     res_type = _igvn.type(res)-&gt;isa_oopptr();
 803   }
 804 
 805   if (res != NULL) {
 806     klass = res_type-&gt;klass();
 807     if (res_type-&gt;isa_instptr()) {
 808       // find the fields of the class which will be needed for safepoint debug information
 809       assert(klass-&gt;is_instance_klass(), &quot;must be an instance klass.&quot;);
 810       iklass = klass-&gt;as_instance_klass();
 811       nfields = iklass-&gt;nof_nonstatic_fields();
 812     } else {
 813       // find the array&#39;s elements which will be needed for safepoint debug information
 814       nfields = alloc-&gt;in(AllocateNode::ALength)-&gt;find_int_con(-1);
 815       assert(klass-&gt;is_array_klass() &amp;&amp; nfields &gt;= 0, &quot;must be an array klass.&quot;);
 816       elem_type = klass-&gt;as_array_klass()-&gt;element_type();
 817       basic_elem_type = elem_type-&gt;basic_type();
 818       if (elem_type-&gt;is_valuetype() &amp;&amp; !klass-&gt;is_value_array_klass()) {
 819         assert(basic_elem_type == T_VALUETYPE, &quot;unexpected element basic type&quot;);
 820         basic_elem_type = T_OBJECT;
 821       }
 822       array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
 823       element_size = type2aelembytes(basic_elem_type);
 824       if (klass-&gt;is_value_array_klass()) {
 825         // Flattened value type array
 826         element_size = klass-&gt;as_value_array_klass()-&gt;element_byte_size();
 827       }
 828     }
 829   }
 830   //
 831   // Process the safepoint uses
 832   //
 833   Unique_Node_List value_worklist;
 834   while (safepoints.length() &gt; 0) {
 835     SafePointNode* sfpt = safepoints.pop();
 836     Node* mem = sfpt-&gt;memory();
 837     Node* ctl = sfpt-&gt;control();
 838     assert(sfpt-&gt;jvms() != NULL, &quot;missed JVMS&quot;);
 839     // Fields of scalar objs are referenced only at the end
 840     // of regular debuginfo at the last (youngest) JVMS.
 841     // Record relative start index.
 842     uint first_ind = (sfpt-&gt;req() - sfpt-&gt;jvms()-&gt;scloff());
 843     SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(res_type,
 844 #ifdef ASSERT
 845                                                  alloc,
 846 #endif
 847                                                  first_ind, nfields);
 848     sobj-&gt;init_req(0, C-&gt;root());
 849     transform_later(sobj);
 850 
 851     // Scan object&#39;s fields adding an input to the safepoint for each field.
 852     for (int j = 0; j &lt; nfields; j++) {
 853       intptr_t offset;
 854       ciField* field = NULL;
 855       if (iklass != NULL) {
 856         field = iklass-&gt;nonstatic_field_at(j);
 857         offset = field-&gt;offset();
 858         elem_type = field-&gt;type();
 859         basic_elem_type = field-&gt;layout_type();
 860         assert(!field-&gt;is_flattened(), &quot;flattened value type fields should not have safepoint uses&quot;);
 861       } else {
 862         offset = array_base + j * (intptr_t)element_size;
 863       }
 864 
 865       const Type *field_type;
 866       // The next code is taken from Parse::do_get_xxx().
 867       if (is_reference_type(basic_elem_type)) {
 868         if (!elem_type-&gt;is_loaded()) {
 869           field_type = TypeInstPtr::BOTTOM;
 870         } else if (field != NULL &amp;&amp; field-&gt;is_static_constant()) {
 871           // This can happen if the constant oop is non-perm.
 872           ciObject* con = field-&gt;constant_value().as_object();
 873           // Do not &quot;join&quot; in the previous type; it doesn&#39;t add value,
 874           // and may yield a vacuous result if the field is of interface type.
 875           field_type = TypeOopPtr::make_from_constant(con)-&gt;isa_oopptr();
 876           assert(field_type != NULL, &quot;field singleton type must be consistent&quot;);
 877         } else {
 878           field_type = TypeOopPtr::make_from_klass(elem_type-&gt;as_klass());
 879         }
 880         if (UseCompressedOops) {
 881           field_type = field_type-&gt;make_narrowoop();
 882           basic_elem_type = T_NARROWOOP;
 883         }
 884       } else {
 885         field_type = Type::get_const_basic_type(basic_elem_type);
 886       }
 887 
 888       Node* field_val = NULL;
 889       const TypeOopPtr* field_addr_type = res_type-&gt;add_offset(offset)-&gt;isa_oopptr();
 890       if (klass-&gt;is_value_array_klass()) {
 891         ciValueKlass* vk = elem_type-&gt;as_value_klass();
 892         assert(vk-&gt;flatten_array(), &quot;must be flattened&quot;);
 893         field_val = value_type_from_mem(mem, ctl, vk, field_addr_type-&gt;isa_aryptr(), 0, alloc);
 894       } else {
 895         field_val = value_from_mem(mem, ctl, basic_elem_type, field_type, field_addr_type, alloc);
 896       }
 897       if (field_val == NULL) {
 898         // We weren&#39;t able to find a value for this field,
 899         // give up on eliminating this allocation.
 900 
 901         // Remove any extra entries we added to the safepoint.
 902         uint last = sfpt-&gt;req() - 1;
 903         for (int k = 0;  k &lt; j; k++) {
 904           sfpt-&gt;del_req(last--);
 905         }
 906         _igvn._worklist.push(sfpt);
 907         // rollback processed safepoints
 908         while (safepoints_done.length() &gt; 0) {
 909           SafePointNode* sfpt_done = safepoints_done.pop();
 910           // remove any extra entries we added to the safepoint
 911           last = sfpt_done-&gt;req() - 1;
 912           for (int k = 0;  k &lt; nfields; k++) {
 913             sfpt_done-&gt;del_req(last--);
 914           }
 915           JVMState *jvms = sfpt_done-&gt;jvms();
 916           jvms-&gt;set_endoff(sfpt_done-&gt;req());
 917           // Now make a pass over the debug information replacing any references
 918           // to SafePointScalarObjectNode with the allocated object.
 919           int start = jvms-&gt;debug_start();
 920           int end   = jvms-&gt;debug_end();
 921           for (int i = start; i &lt; end; i++) {
 922             if (sfpt_done-&gt;in(i)-&gt;is_SafePointScalarObject()) {
 923               SafePointScalarObjectNode* scobj = sfpt_done-&gt;in(i)-&gt;as_SafePointScalarObject();
 924               if (scobj-&gt;first_index(jvms) == sfpt_done-&gt;req() &amp;&amp;
 925                   scobj-&gt;n_fields() == (uint)nfields) {
 926                 assert(scobj-&gt;alloc() == alloc, &quot;sanity&quot;);
 927                 sfpt_done-&gt;set_req(i, res);
 928               }
 929             }
 930           }
 931           _igvn._worklist.push(sfpt_done);
 932         }
 933 #ifndef PRODUCT
 934         if (PrintEliminateAllocations) {
 935           if (field != NULL) {
 936             tty-&gt;print(&quot;=== At SafePoint node %d can&#39;t find value of Field: &quot;,
 937                        sfpt-&gt;_idx);
 938             field-&gt;print();
 939             int field_idx = C-&gt;get_alias_index(field_addr_type);
 940             tty-&gt;print(&quot; (alias_idx=%d)&quot;, field_idx);
 941           } else { // Array&#39;s element
 942             tty-&gt;print(&quot;=== At SafePoint node %d can&#39;t find value of array element [%d]&quot;,
 943                        sfpt-&gt;_idx, j);
 944           }
 945           tty-&gt;print(&quot;, which prevents elimination of: &quot;);
 946           if (res == NULL)
 947             alloc-&gt;dump();
 948           else
 949             res-&gt;dump();
 950         }
 951 #endif
 952         return false;
 953       }
 954       if (field_val-&gt;is_ValueType()) {
 955         // Keep track of value types to scalarize them later
 956         value_worklist.push(field_val);
 957       } else if (UseCompressedOops &amp;&amp; field_type-&gt;isa_narrowoop()) {
 958         // Enable &quot;DecodeN(EncodeP(Allocate)) --&gt; Allocate&quot; transformation
 959         // to be able scalar replace the allocation.
 960         if (field_val-&gt;is_EncodeP()) {
 961           field_val = field_val-&gt;in(1);
 962         } else {
 963           field_val = transform_later(new DecodeNNode(field_val, field_val-&gt;get_ptr_type()));
 964         }
 965       }
 966       sfpt-&gt;add_req(field_val);
 967     }
 968     JVMState *jvms = sfpt-&gt;jvms();
 969     jvms-&gt;set_endoff(sfpt-&gt;req());
 970     // Now make a pass over the debug information replacing any references
 971     // to the allocated object with &quot;sobj&quot;
 972     int start = jvms-&gt;debug_start();
 973     int end   = jvms-&gt;debug_end();
 974     sfpt-&gt;replace_edges_in_range(res, sobj, start, end);
 975     _igvn._worklist.push(sfpt);
 976     safepoints_done.append_if_missing(sfpt); // keep it for rollback
 977   }
 978   // Scalarize value types that were added to the safepoint
 979   for (uint i = 0; i &lt; value_worklist.size(); ++i) {
 980     Node* vt = value_worklist.at(i);
 981     vt-&gt;as_ValueType()-&gt;make_scalar_in_safepoints(&amp;_igvn);
 982   }
 983   return true;
 984 }
 985 
 986 static void disconnect_projections(MultiNode* n, PhaseIterGVN&amp; igvn) {
 987   Node* ctl_proj = n-&gt;proj_out_or_null(TypeFunc::Control);
 988   Node* mem_proj = n-&gt;proj_out_or_null(TypeFunc::Memory);
 989   if (ctl_proj != NULL) {
 990     igvn.replace_node(ctl_proj, n-&gt;in(0));
 991   }
 992   if (mem_proj != NULL) {
 993     igvn.replace_node(mem_proj, n-&gt;in(TypeFunc::Memory));
 994   }
 995 }
 996 
 997 // Process users of eliminated allocation.
 998 void PhaseMacroExpand::process_users_of_allocation(CallNode *alloc) {
 999   Node* res = alloc-&gt;result_cast();
1000   if (res != NULL) {
1001     for (DUIterator_Last jmin, j = res-&gt;last_outs(jmin); j &gt;= jmin; ) {
1002       Node *use = res-&gt;last_out(j);
1003       uint oc1 = res-&gt;outcnt();
1004 
1005       if (use-&gt;is_AddP()) {
1006         for (DUIterator_Last kmin, k = use-&gt;last_outs(kmin); k &gt;= kmin; ) {
1007           Node *n = use-&gt;last_out(k);
1008           uint oc2 = use-&gt;outcnt();
1009           if (n-&gt;is_Store()) {
1010 #ifdef ASSERT
1011             // Verify that there is no dependent MemBarVolatile nodes,
1012             // they should be removed during IGVN, see MemBarNode::Ideal().
1013             for (DUIterator_Fast pmax, p = n-&gt;fast_outs(pmax);
1014                                        p &lt; pmax; p++) {
1015               Node* mb = n-&gt;fast_out(p);
1016               assert(mb-&gt;is_Initialize() || !mb-&gt;is_MemBar() ||
1017                      mb-&gt;req() &lt;= MemBarNode::Precedent ||
1018                      mb-&gt;in(MemBarNode::Precedent) != n,
1019                      &quot;MemBarVolatile should be eliminated for non-escaping object&quot;);
1020             }
1021 #endif
1022             _igvn.replace_node(n, n-&gt;in(MemNode::Memory));
1023           } else if (n-&gt;is_ArrayCopy()) {
1024             // Disconnect ArrayCopy node
1025             ArrayCopyNode* ac = n-&gt;as_ArrayCopy();
1026             assert(ac-&gt;is_clonebasic(), &quot;unexpected array copy kind&quot;);
1027             Node* membar_after = ac-&gt;proj_out(TypeFunc::Control)-&gt;unique_ctrl_out();
1028             disconnect_projections(ac, _igvn);
1029             assert(alloc-&gt;in(0)-&gt;is_Proj() &amp;&amp; alloc-&gt;in(0)-&gt;in(0)-&gt;Opcode() == Op_MemBarCPUOrder, &quot;mem barrier expected before allocation&quot;);
1030             Node* membar_before = alloc-&gt;in(0)-&gt;in(0);
1031             disconnect_projections(membar_before-&gt;as_MemBar(), _igvn);
1032             if (membar_after-&gt;is_MemBar()) {
1033               disconnect_projections(membar_after-&gt;as_MemBar(), _igvn);
1034             }
1035           } else {
1036             eliminate_gc_barrier(n);
1037           }
1038           k -= (oc2 - use-&gt;outcnt());
1039         }
1040         _igvn.remove_dead_node(use);
1041       } else if (use-&gt;is_ArrayCopy()) {
1042         // Disconnect ArrayCopy node
1043         ArrayCopyNode* ac = use-&gt;as_ArrayCopy();
1044         assert(ac-&gt;is_arraycopy_validated() ||
1045                ac-&gt;is_copyof_validated() ||
1046                ac-&gt;is_copyofrange_validated(), &quot;unsupported&quot;);
1047         CallProjections* callprojs = ac-&gt;extract_projections(true);
1048 
1049         _igvn.replace_node(callprojs-&gt;fallthrough_ioproj, ac-&gt;in(TypeFunc::I_O));
1050         _igvn.replace_node(callprojs-&gt;fallthrough_memproj, ac-&gt;in(TypeFunc::Memory));
1051         _igvn.replace_node(callprojs-&gt;fallthrough_catchproj, ac-&gt;in(TypeFunc::Control));
1052 
1053         // Set control to top. IGVN will remove the remaining projections
1054         ac-&gt;set_req(0, top());
1055         ac-&gt;replace_edge(res, top());
1056 
1057         // Disconnect src right away: it can help find new
1058         // opportunities for allocation elimination
1059         Node* src = ac-&gt;in(ArrayCopyNode::Src);
1060         ac-&gt;replace_edge(src, top());
1061         // src can be top at this point if src and dest of the
1062         // arraycopy were the same
1063         if (src-&gt;outcnt() == 0 &amp;&amp; !src-&gt;is_top()) {
1064           _igvn.remove_dead_node(src);
1065         }
1066 
1067         _igvn._worklist.push(ac);
1068       } else if (use-&gt;is_ValueType()) {
1069         assert(use-&gt;isa_ValueType()-&gt;get_oop() == res, &quot;unexpected value type use&quot;);
1070          _igvn.rehash_node_delayed(use);
1071         use-&gt;isa_ValueType()-&gt;set_oop(_igvn.zerocon(T_VALUETYPE));
1072       } else if (use-&gt;is_Store()) {
1073         _igvn.replace_node(use, use-&gt;in(MemNode::Memory));
1074       } else {
1075         eliminate_gc_barrier(use);
1076       }
1077       j -= (oc1 - res-&gt;outcnt());
1078     }
1079     assert(res-&gt;outcnt() == 0, &quot;all uses of allocated objects must be deleted&quot;);
1080     _igvn.remove_dead_node(res);
1081   }
1082 
1083   //
1084   // Process other users of allocation&#39;s projections
1085   //
1086   if (_resproj != NULL &amp;&amp; _resproj-&gt;outcnt() != 0) {
1087     // First disconnect stores captured by Initialize node.
1088     // If Initialize node is eliminated first in the following code,
1089     // it will kill such stores and DUIterator_Last will assert.
1090     for (DUIterator_Fast jmax, j = _resproj-&gt;fast_outs(jmax);  j &lt; jmax; j++) {
1091       Node *use = _resproj-&gt;fast_out(j);
1092       if (use-&gt;is_AddP()) {
1093         // raw memory addresses used only by the initialization
1094         _igvn.replace_node(use, C-&gt;top());
1095         --j; --jmax;
1096       }
1097     }
1098     for (DUIterator_Last jmin, j = _resproj-&gt;last_outs(jmin); j &gt;= jmin; ) {
1099       Node *use = _resproj-&gt;last_out(j);
1100       uint oc1 = _resproj-&gt;outcnt();
1101       if (use-&gt;is_Initialize()) {
1102         // Eliminate Initialize node.
1103         InitializeNode *init = use-&gt;as_Initialize();
1104         assert(init-&gt;outcnt() &lt;= 2, &quot;only a control and memory projection expected&quot;);
1105         Node *ctrl_proj = init-&gt;proj_out_or_null(TypeFunc::Control);
1106         if (ctrl_proj != NULL) {
1107           _igvn.replace_node(ctrl_proj, init-&gt;in(TypeFunc::Control));
1108 #ifdef ASSERT
1109           Node* tmp = init-&gt;in(TypeFunc::Control);
1110           assert(tmp == _fallthroughcatchproj, &quot;allocation control projection&quot;);
1111 #endif
1112         }
1113         Node *mem_proj = init-&gt;proj_out_or_null(TypeFunc::Memory);
1114         if (mem_proj != NULL) {
1115           Node *mem = init-&gt;in(TypeFunc::Memory);
1116 #ifdef ASSERT
1117           if (mem-&gt;is_MergeMem()) {
1118             assert(mem-&gt;in(TypeFunc::Memory) == _memproj_fallthrough, &quot;allocation memory projection&quot;);
1119           } else {
1120             assert(mem == _memproj_fallthrough, &quot;allocation memory projection&quot;);
1121           }
1122 #endif
1123           _igvn.replace_node(mem_proj, mem);
1124         }
1125       } else  {
1126         assert(false, &quot;only Initialize or AddP expected&quot;);
1127       }
1128       j -= (oc1 - _resproj-&gt;outcnt());
1129     }
1130   }
1131   if (_fallthroughcatchproj != NULL) {
1132     _igvn.replace_node(_fallthroughcatchproj, alloc-&gt;in(TypeFunc::Control));
1133   }
1134   if (_memproj_fallthrough != NULL) {
1135     _igvn.replace_node(_memproj_fallthrough, alloc-&gt;in(TypeFunc::Memory));
1136   }
1137   if (_memproj_catchall != NULL) {
1138     _igvn.replace_node(_memproj_catchall, C-&gt;top());
1139   }
1140   if (_ioproj_fallthrough != NULL) {
1141     _igvn.replace_node(_ioproj_fallthrough, alloc-&gt;in(TypeFunc::I_O));
1142   }
1143   if (_ioproj_catchall != NULL) {
1144     _igvn.replace_node(_ioproj_catchall, C-&gt;top());
1145   }
1146   if (_catchallcatchproj != NULL) {
1147     _igvn.replace_node(_catchallcatchproj, C-&gt;top());
1148   }
1149 }
1150 
1151 bool PhaseMacroExpand::eliminate_allocate_node(AllocateNode *alloc) {
1152   // Don&#39;t do scalar replacement if the frame can be popped by JVMTI:
1153   // if reallocation fails during deoptimization we&#39;ll pop all
1154   // interpreter frames for this compiled frame and that won&#39;t play
1155   // nice with JVMTI popframe.
1156   if (!EliminateAllocations || JvmtiExport::can_pop_frame() || !alloc-&gt;_is_non_escaping) {
1157     return false;
1158   }
1159   Node* klass = alloc-&gt;in(AllocateNode::KlassNode);
1160   const TypeKlassPtr* tklass = _igvn.type(klass)-&gt;is_klassptr();
1161   Node* res = alloc-&gt;result_cast();
1162   // Eliminate boxing allocations which are not used
1163   // regardless scalar replacable status.
1164   bool boxing_alloc = C-&gt;eliminate_boxing() &amp;&amp;
1165                       tklass-&gt;klass()-&gt;is_instance_klass()  &amp;&amp;
1166                       tklass-&gt;klass()-&gt;as_instance_klass()-&gt;is_box_klass();
1167   if (!alloc-&gt;_is_scalar_replaceable &amp;&amp; (!boxing_alloc || (res != NULL))) {
1168     return false;
1169   }
1170 
1171   extract_call_projections(alloc);
1172 
1173   GrowableArray &lt;SafePointNode *&gt; safepoints;
1174   if (!can_eliminate_allocation(alloc, safepoints)) {
1175     return false;
1176   }
1177 
1178   if (!alloc-&gt;_is_scalar_replaceable) {
1179     assert(res == NULL, &quot;sanity&quot;);
1180     // We can only eliminate allocation if all debug info references
1181     // are already replaced with SafePointScalarObject because
1182     // we can&#39;t search for a fields value without instance_id.
1183     if (safepoints.length() &gt; 0) {
1184       return false;
1185     }
1186   }
1187 
1188   if (!scalar_replacement(alloc, safepoints)) {
1189     return false;
1190   }
1191 
1192   CompileLog* log = C-&gt;log();
1193   if (log != NULL) {
1194     log-&gt;head(&quot;eliminate_allocation type=&#39;%d&#39;&quot;,
1195               log-&gt;identify(tklass-&gt;klass()));
1196     JVMState* p = alloc-&gt;jvms();
1197     while (p != NULL) {
1198       log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
1199       p = p-&gt;caller();
1200     }
1201     log-&gt;tail(&quot;eliminate_allocation&quot;);
1202   }
1203 
1204   process_users_of_allocation(alloc);
1205 
1206 #ifndef PRODUCT
1207   if (PrintEliminateAllocations) {
1208     if (alloc-&gt;is_AllocateArray())
1209       tty-&gt;print_cr(&quot;++++ Eliminated: %d AllocateArray&quot;, alloc-&gt;_idx);
1210     else
1211       tty-&gt;print_cr(&quot;++++ Eliminated: %d Allocate&quot;, alloc-&gt;_idx);
1212   }
1213 #endif
1214 
1215   return true;
1216 }
1217 
1218 bool PhaseMacroExpand::eliminate_boxing_node(CallStaticJavaNode *boxing) {
1219   // EA should remove all uses of non-escaping boxing node.
1220   if (!C-&gt;eliminate_boxing() || boxing-&gt;proj_out_or_null(TypeFunc::Parms) != NULL) {
1221     return false;
1222   }
1223 
1224   assert(boxing-&gt;result_cast() == NULL, &quot;unexpected boxing node result&quot;);
1225 
1226   extract_call_projections(boxing);
1227 
1228   const TypeTuple* r = boxing-&gt;tf()-&gt;range_sig();
1229   assert(r-&gt;cnt() &gt; TypeFunc::Parms, &quot;sanity&quot;);
1230   const TypeInstPtr* t = r-&gt;field_at(TypeFunc::Parms)-&gt;isa_instptr();
1231   assert(t != NULL, &quot;sanity&quot;);
1232 
1233   CompileLog* log = C-&gt;log();
1234   if (log != NULL) {
1235     log-&gt;head(&quot;eliminate_boxing type=&#39;%d&#39;&quot;,
1236               log-&gt;identify(t-&gt;klass()));
1237     JVMState* p = boxing-&gt;jvms();
1238     while (p != NULL) {
1239       log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
1240       p = p-&gt;caller();
1241     }
1242     log-&gt;tail(&quot;eliminate_boxing&quot;);
1243   }
1244 
1245   process_users_of_allocation(boxing);
1246 
1247 #ifndef PRODUCT
1248   if (PrintEliminateAllocations) {
1249     tty-&gt;print(&quot;++++ Eliminated: %d &quot;, boxing-&gt;_idx);
1250     boxing-&gt;method()-&gt;print_short_name(tty);
1251     tty-&gt;cr();
1252   }
1253 #endif
1254 
1255   return true;
1256 }
1257 
1258 //---------------------------set_eden_pointers-------------------------
1259 void PhaseMacroExpand::set_eden_pointers(Node* &amp;eden_top_adr, Node* &amp;eden_end_adr) {
1260   if (UseTLAB) {                // Private allocation: load from TLS
1261     Node* thread = transform_later(new ThreadLocalNode());
1262     int tlab_top_offset = in_bytes(JavaThread::tlab_top_offset());
1263     int tlab_end_offset = in_bytes(JavaThread::tlab_end_offset());
1264     eden_top_adr = basic_plus_adr(top()/*not oop*/, thread, tlab_top_offset);
1265     eden_end_adr = basic_plus_adr(top()/*not oop*/, thread, tlab_end_offset);
1266   } else {                      // Shared allocation: load from globals
1267     CollectedHeap* ch = Universe::heap();
1268     address top_adr = (address)ch-&gt;top_addr();
1269     address end_adr = (address)ch-&gt;end_addr();
1270     eden_top_adr = makecon(TypeRawPtr::make(top_adr));
1271     eden_end_adr = basic_plus_adr(eden_top_adr, end_adr - top_adr);
1272   }
1273 }
1274 
1275 
1276 Node* PhaseMacroExpand::make_load(Node* ctl, Node* mem, Node* base, int offset, const Type* value_type, BasicType bt) {
1277   Node* adr = basic_plus_adr(base, offset);
1278   const TypePtr* adr_type = adr-&gt;bottom_type()-&gt;is_ptr();
1279   Node* value = LoadNode::make(_igvn, ctl, mem, adr, adr_type, value_type, bt, MemNode::unordered);
1280   transform_later(value);
1281   return value;
1282 }
1283 
1284 
1285 Node* PhaseMacroExpand::make_store(Node* ctl, Node* mem, Node* base, int offset, Node* value, BasicType bt) {
1286   Node* adr = basic_plus_adr(base, offset);
1287   mem = StoreNode::make(_igvn, ctl, mem, adr, NULL, value, bt, MemNode::unordered);
1288   transform_later(mem);
1289   return mem;
1290 }
1291 
1292 //=============================================================================
1293 //
1294 //                              A L L O C A T I O N
1295 //
1296 // Allocation attempts to be fast in the case of frequent small objects.
1297 // It breaks down like this:
1298 //
1299 // 1) Size in doublewords is computed.  This is a constant for objects and
1300 // variable for most arrays.  Doubleword units are used to avoid size
1301 // overflow of huge doubleword arrays.  We need doublewords in the end for
1302 // rounding.
1303 //
1304 // 2) Size is checked for being &#39;too large&#39;.  Too-large allocations will go
1305 // the slow path into the VM.  The slow path can throw any required
1306 // exceptions, and does all the special checks for very large arrays.  The
1307 // size test can constant-fold away for objects.  For objects with
1308 // finalizers it constant-folds the otherway: you always go slow with
1309 // finalizers.
1310 //
1311 // 3) If NOT using TLABs, this is the contended loop-back point.
1312 // Load-Locked the heap top.  If using TLABs normal-load the heap top.
1313 //
1314 // 4) Check that heap top + size*8 &lt; max.  If we fail go the slow ` route.
1315 // NOTE: &quot;top+size*8&quot; cannot wrap the 4Gig line!  Here&#39;s why: for largish
1316 // &quot;size*8&quot; we always enter the VM, where &quot;largish&quot; is a constant picked small
1317 // enough that there&#39;s always space between the eden max and 4Gig (old space is
1318 // there so it&#39;s quite large) and large enough that the cost of entering the VM
1319 // is dwarfed by the cost to initialize the space.
1320 //
1321 // 5) If NOT using TLABs, Store-Conditional the adjusted heap top back
1322 // down.  If contended, repeat at step 3.  If using TLABs normal-store
1323 // adjusted heap top back down; there is no contention.
1324 //
1325 // 6) If !ZeroTLAB then Bulk-clear the object/array.  Fill in klass &amp; mark
1326 // fields.
1327 //
1328 // 7) Merge with the slow-path; cast the raw memory pointer to the correct
1329 // oop flavor.
1330 //
1331 //=============================================================================
1332 // FastAllocateSizeLimit value is in DOUBLEWORDS.
1333 // Allocations bigger than this always go the slow route.
1334 // This value must be small enough that allocation attempts that need to
1335 // trigger exceptions go the slow route.  Also, it must be small enough so
1336 // that heap_top + size_in_bytes does not wrap around the 4Gig limit.
1337 //=============================================================================j//
1338 // %%% Here is an old comment from parseHelper.cpp; is it outdated?
1339 // The allocator will coalesce int-&gt;oop copies away.  See comment in
1340 // coalesce.cpp about how this works.  It depends critically on the exact
1341 // code shape produced here, so if you are changing this code shape
1342 // make sure the GC info for the heap-top is correct in and around the
1343 // slow-path call.
1344 //
1345 
1346 void PhaseMacroExpand::expand_allocate_common(
1347             AllocateNode* alloc, // allocation node to be expanded
1348             Node* length,  // array length for an array allocation
1349             const TypeFunc* slow_call_type, // Type of slow call
1350             address slow_call_address  // Address of slow call
1351     )
1352 {
1353   Node* ctrl = alloc-&gt;in(TypeFunc::Control);
1354   Node* mem  = alloc-&gt;in(TypeFunc::Memory);
1355   Node* i_o  = alloc-&gt;in(TypeFunc::I_O);
1356   Node* size_in_bytes     = alloc-&gt;in(AllocateNode::AllocSize);
1357   Node* klass_node        = alloc-&gt;in(AllocateNode::KlassNode);
1358   Node* initial_slow_test = alloc-&gt;in(AllocateNode::InitialTest);
1359   assert(ctrl != NULL, &quot;must have control&quot;);
1360 
1361   // We need a Region and corresponding Phi&#39;s to merge the slow-path and fast-path results.
1362   // they will not be used if &quot;always_slow&quot; is set
1363   enum { slow_result_path = 1, fast_result_path = 2 };
1364   Node *result_region = NULL;
1365   Node *result_phi_rawmem = NULL;
1366   Node *result_phi_rawoop = NULL;
1367   Node *result_phi_i_o = NULL;
1368 
1369   // The initial slow comparison is a size check, the comparison
1370   // we want to do is a BoolTest::gt
1371   bool expand_fast_path = true;
1372   int tv = _igvn.find_int_con(initial_slow_test, -1);
1373   if (tv &gt;= 0) {
1374     // InitialTest has constant result
1375     //   0 - can fit in TLAB
1376     //   1 - always too big or negative
1377     assert(tv &lt;= 1, &quot;0 or 1 if a constant&quot;);
1378     expand_fast_path = (tv == 0);
1379     initial_slow_test = NULL;
1380   } else {
1381     initial_slow_test = BoolNode::make_predicate(initial_slow_test, &amp;_igvn);
1382   }
1383 
1384   if (C-&gt;env()-&gt;dtrace_alloc_probes() ||
1385       (!UseTLAB &amp;&amp; !Universe::heap()-&gt;supports_inline_contig_alloc())) {
1386     // Force slow-path allocation
1387     expand_fast_path = false;
1388     initial_slow_test = NULL;
1389   }
1390 
1391   bool allocation_has_use = (alloc-&gt;result_cast() != NULL);
1392   if (!allocation_has_use) {
1393     InitializeNode* init = alloc-&gt;initialization();
1394     if (init != NULL) {
1395       init-&gt;remove(&amp;_igvn);
1396     }
1397     if (expand_fast_path &amp;&amp; (initial_slow_test == NULL)) {
1398       // Remove allocation node and return.
1399       // Size is a non-negative constant -&gt; no initial check needed -&gt; directly to fast path.
1400       // Also, no usages -&gt; empty fast path -&gt; no fall out to slow path -&gt; nothing left.
1401 #ifndef PRODUCT
1402       if (PrintEliminateAllocations) {
1403         tty-&gt;print(&quot;NotUsed &quot;);
1404         Node* res = alloc-&gt;proj_out_or_null(TypeFunc::Parms);
1405         if (res != NULL) {
1406           res-&gt;dump();
1407         } else {
1408           alloc-&gt;dump();
1409         }
1410       }
1411 #endif
1412       yank_alloc_node(alloc);
1413       return;
1414     }
1415   }
1416 
1417   enum { too_big_or_final_path = 1, need_gc_path = 2 };
1418   Node *slow_region = NULL;
1419   Node *toobig_false = ctrl;
1420 
1421   // generate the initial test if necessary
1422   if (initial_slow_test != NULL ) {
1423     assert (expand_fast_path, &quot;Only need test if there is a fast path&quot;);
1424     slow_region = new RegionNode(3);
1425 
1426     // Now make the initial failure test.  Usually a too-big test but
1427     // might be a TRUE for finalizers or a fancy class check for
1428     // newInstance0.
1429     IfNode* toobig_iff = new IfNode(ctrl, initial_slow_test, PROB_MIN, COUNT_UNKNOWN);
1430     transform_later(toobig_iff);
1431     // Plug the failing-too-big test into the slow-path region
1432     Node* toobig_true = new IfTrueNode(toobig_iff);
1433     transform_later(toobig_true);
1434     slow_region    -&gt;init_req( too_big_or_final_path, toobig_true );
1435     toobig_false = new IfFalseNode(toobig_iff);
1436     transform_later(toobig_false);
1437   } else {
1438     // No initial test, just fall into next case
1439     assert(allocation_has_use || !expand_fast_path, &quot;Should already have been handled&quot;);
1440     toobig_false = ctrl;
1441     debug_only(slow_region = NodeSentinel);
1442   }
1443 
1444   // If we are here there are several possibilities
1445   // - expand_fast_path is false - then only a slow path is expanded. That&#39;s it.
1446   // no_initial_check means a constant allocation.
1447   // - If check always evaluates to false -&gt; expand_fast_path is false (see above)
1448   // - If check always evaluates to true -&gt; directly into fast path (but may bailout to slowpath)
1449   // if !allocation_has_use the fast path is empty
1450   // if !allocation_has_use &amp;&amp; no_initial_check
1451   // - Then there are no fastpath that can fall out to slowpath -&gt; no allocation code at all.
1452   //   removed by yank_alloc_node above.
1453 
1454   Node *slow_mem = mem;  // save the current memory state for slow path
1455   // generate the fast allocation code unless we know that the initial test will always go slow
1456   if (expand_fast_path) {
1457     // Fast path modifies only raw memory.
1458     if (mem-&gt;is_MergeMem()) {
1459       mem = mem-&gt;as_MergeMem()-&gt;memory_at(Compile::AliasIdxRaw);
1460     }
1461 
1462     // allocate the Region and Phi nodes for the result
1463     result_region = new RegionNode(3);
1464     result_phi_rawmem = new PhiNode(result_region, Type::MEMORY, TypeRawPtr::BOTTOM);
1465     result_phi_i_o    = new PhiNode(result_region, Type::ABIO); // I/O is used for Prefetch
1466 
1467     // Grab regular I/O before optional prefetch may change it.
1468     // Slow-path does no I/O so just set it to the original I/O.
1469     result_phi_i_o-&gt;init_req(slow_result_path, i_o);
1470 
1471     // Name successful fast-path variables
1472     Node* fast_oop_ctrl;
1473     Node* fast_oop_rawmem;
1474 
1475     if (allocation_has_use) {
1476       Node* needgc_ctrl = NULL;
1477       result_phi_rawoop = new PhiNode(result_region, TypeRawPtr::BOTTOM);
1478 
1479       intx prefetch_lines = length != NULL ? AllocatePrefetchLines : AllocateInstancePrefetchLines;
1480       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1481       Node* fast_oop = bs-&gt;obj_allocate(this, ctrl, mem, toobig_false, size_in_bytes, i_o, needgc_ctrl,
1482                                         fast_oop_ctrl, fast_oop_rawmem,
1483                                         prefetch_lines);
1484 
1485       if (initial_slow_test != NULL) {
1486         // This completes all paths into the slow merge point
1487         slow_region-&gt;init_req(need_gc_path, needgc_ctrl);
1488         transform_later(slow_region);
1489       } else {
1490         // No initial slow path needed!
1491         // Just fall from the need-GC path straight into the VM call.
1492         slow_region = needgc_ctrl;
1493       }
1494 
1495       InitializeNode* init = alloc-&gt;initialization();
1496       fast_oop_rawmem = initialize_object(alloc,
1497                                           fast_oop_ctrl, fast_oop_rawmem, fast_oop,
1498                                           klass_node, length, size_in_bytes);
1499       expand_initialize_membar(alloc, init, fast_oop_ctrl, fast_oop_rawmem);
1500       expand_dtrace_alloc_probe(alloc, fast_oop, fast_oop_ctrl, fast_oop_rawmem);
1501 
1502       result_phi_rawoop-&gt;init_req(fast_result_path, fast_oop);
1503     } else {
1504       assert (initial_slow_test != NULL, &quot;sanity&quot;);
1505       fast_oop_ctrl   = toobig_false;
1506       fast_oop_rawmem = mem;
1507       transform_later(slow_region);
1508     }
1509 
1510     // Plug in the successful fast-path into the result merge point
1511     result_region    -&gt;init_req(fast_result_path, fast_oop_ctrl);
1512     result_phi_i_o   -&gt;init_req(fast_result_path, i_o);
1513     result_phi_rawmem-&gt;init_req(fast_result_path, fast_oop_rawmem);
1514   } else {
1515     slow_region = ctrl;
1516     result_phi_i_o = i_o; // Rename it to use in the following code.
1517   }
1518 
1519   // Generate slow-path call
1520   CallNode *call = new CallStaticJavaNode(slow_call_type, slow_call_address,
1521                                OptoRuntime::stub_name(slow_call_address),
1522                                alloc-&gt;jvms()-&gt;bci(),
1523                                TypePtr::BOTTOM);
1524   call-&gt;init_req(TypeFunc::Control,   slow_region);
1525   call-&gt;init_req(TypeFunc::I_O,       top());    // does no i/o
1526   call-&gt;init_req(TypeFunc::Memory,    slow_mem); // may gc ptrs
1527   call-&gt;init_req(TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr));
1528   call-&gt;init_req(TypeFunc::FramePtr,  alloc-&gt;in(TypeFunc::FramePtr));
1529 
1530   call-&gt;init_req(TypeFunc::Parms+0, klass_node);
1531   if (length != NULL) {
1532     call-&gt;init_req(TypeFunc::Parms+1, length);
1533   } else {
1534     // Let the runtime know if this is a larval allocation
1535     call-&gt;init_req(TypeFunc::Parms+1, _igvn.intcon(alloc-&gt;_larval));
1536   }
1537 
1538   // Copy debug information and adjust JVMState information, then replace
1539   // allocate node with the call
1540   call-&gt;copy_call_debug_info(&amp;_igvn, alloc);
1541   if (expand_fast_path) {
1542     call-&gt;set_cnt(PROB_UNLIKELY_MAG(4));  // Same effect as RC_UNCOMMON.
1543   } else {
1544     // Hook i_o projection to avoid its elimination during allocation
1545     // replacement (when only a slow call is generated).
1546     call-&gt;set_req(TypeFunc::I_O, result_phi_i_o);
1547   }
1548   _igvn.replace_node(alloc, call);
1549   transform_later(call);
1550 
1551   // Identify the output projections from the allocate node and
1552   // adjust any references to them.
1553   // The control and io projections look like:
1554   //
1555   //        v---Proj(ctrl) &lt;-----+   v---CatchProj(ctrl)
1556   //  Allocate                   Catch
1557   //        ^---Proj(io) &lt;-------+   ^---CatchProj(io)
1558   //
1559   //  We are interested in the CatchProj nodes.
1560   //
1561   extract_call_projections(call);
1562 
1563   // An allocate node has separate memory projections for the uses on
1564   // the control and i_o paths. Replace the control memory projection with
1565   // result_phi_rawmem (unless we are only generating a slow call when
1566   // both memory projections are combined)
1567   if (expand_fast_path &amp;&amp; _memproj_fallthrough != NULL) {
<a name="2" id="anc2"></a><span class="line-modified">1568     migrate_outs(_memproj_fallthrough, result_phi_rawmem);</span>
1569   }
1570   // Now change uses of _memproj_catchall to use _memproj_fallthrough and delete
1571   // _memproj_catchall so we end up with a call that has only 1 memory projection.
1572   if (_memproj_catchall != NULL) {
1573     if (_memproj_fallthrough == NULL) {
1574       _memproj_fallthrough = new ProjNode(call, TypeFunc::Memory);
1575       transform_later(_memproj_fallthrough);
1576     }
<a name="3" id="anc3"></a><span class="line-modified">1577     migrate_outs(_memproj_catchall, _memproj_fallthrough);</span>
1578     _igvn.remove_dead_node(_memproj_catchall);
1579   }
1580 
1581   // An allocate node has separate i_o projections for the uses on the control
1582   // and i_o paths. Always replace the control i_o projection with result i_o
1583   // otherwise incoming i_o become dead when only a slow call is generated
1584   // (it is different from memory projections where both projections are
1585   // combined in such case).
1586   if (_ioproj_fallthrough != NULL) {
<a name="4" id="anc4"></a><span class="line-modified">1587     migrate_outs(_ioproj_fallthrough, result_phi_i_o);</span>
1588   }
1589   // Now change uses of _ioproj_catchall to use _ioproj_fallthrough and delete
1590   // _ioproj_catchall so we end up with a call that has only 1 i_o projection.
1591   if (_ioproj_catchall != NULL) {
1592     if (_ioproj_fallthrough == NULL) {
1593       _ioproj_fallthrough = new ProjNode(call, TypeFunc::I_O);
1594       transform_later(_ioproj_fallthrough);
1595     }
<a name="5" id="anc5"></a><span class="line-modified">1596     migrate_outs(_ioproj_catchall, _ioproj_fallthrough);</span>
1597     _igvn.remove_dead_node(_ioproj_catchall);
1598   }
1599 
1600   // if we generated only a slow call, we are done
1601   if (!expand_fast_path) {
1602     // Now we can unhook i_o.
1603     if (result_phi_i_o-&gt;outcnt() &gt; 1) {
1604       call-&gt;set_req(TypeFunc::I_O, top());
1605     } else {
1606       assert(result_phi_i_o-&gt;unique_ctrl_out() == call, &quot;sanity&quot;);
1607       // Case of new array with negative size known during compilation.
1608       // AllocateArrayNode::Ideal() optimization disconnect unreachable
1609       // following code since call to runtime will throw exception.
1610       // As result there will be no users of i_o after the call.
1611       // Leave i_o attached to this call to avoid problems in preceding graph.
1612     }
1613     return;
1614   }
1615 
1616   if (_fallthroughcatchproj != NULL) {
1617     ctrl = _fallthroughcatchproj-&gt;clone();
1618     transform_later(ctrl);
1619     _igvn.replace_node(_fallthroughcatchproj, result_region);
1620   } else {
1621     ctrl = top();
1622   }
1623   Node *slow_result;
1624   if (_resproj == NULL) {
1625     // no uses of the allocation result
1626     slow_result = top();
1627   } else {
1628     slow_result = _resproj-&gt;clone();
1629     transform_later(slow_result);
1630     _igvn.replace_node(_resproj, result_phi_rawoop);
1631   }
1632 
1633   // Plug slow-path into result merge point
1634   result_region-&gt;init_req( slow_result_path, ctrl);
1635   transform_later(result_region);
1636   if (allocation_has_use) {
1637     result_phi_rawoop-&gt;init_req(slow_result_path, slow_result);
1638     transform_later(result_phi_rawoop);
1639   }
1640   result_phi_rawmem-&gt;init_req(slow_result_path, _memproj_fallthrough);
1641   transform_later(result_phi_rawmem);
1642   transform_later(result_phi_i_o);
1643   // This completes all paths into the result merge point
1644 }
1645 
1646 // Remove alloc node that has no uses.
1647 void PhaseMacroExpand::yank_alloc_node(AllocateNode* alloc) {
1648   Node* ctrl = alloc-&gt;in(TypeFunc::Control);
1649   Node* mem  = alloc-&gt;in(TypeFunc::Memory);
1650   Node* i_o  = alloc-&gt;in(TypeFunc::I_O);
1651 
1652   extract_call_projections(alloc);
1653   if (_resproj != NULL) {
1654     for (DUIterator_Fast imax, i = _resproj-&gt;fast_outs(imax); i &lt; imax; i++) {
1655       Node* use = _resproj-&gt;fast_out(i);
1656       use-&gt;isa_MemBar()-&gt;remove(&amp;_igvn);
1657       --imax;
1658       --i; // back up iterator
1659     }
1660     assert(_resproj-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);
1661     _igvn.remove_dead_node(_resproj);
1662   }
1663   if (_fallthroughcatchproj != NULL) {
<a name="6" id="anc6"></a><span class="line-modified">1664     migrate_outs(_fallthroughcatchproj, ctrl);</span>
1665     _igvn.remove_dead_node(_fallthroughcatchproj);
1666   }
1667   if (_catchallcatchproj != NULL) {
1668     _igvn.rehash_node_delayed(_catchallcatchproj);
1669     _catchallcatchproj-&gt;set_req(0, top());
1670   }
1671   if (_fallthroughproj != NULL) {
1672     Node* catchnode = _fallthroughproj-&gt;unique_ctrl_out();
1673     _igvn.remove_dead_node(catchnode);
1674     _igvn.remove_dead_node(_fallthroughproj);
1675   }
1676   if (_memproj_fallthrough != NULL) {
<a name="7" id="anc7"></a><span class="line-modified">1677     migrate_outs(_memproj_fallthrough, mem);</span>
1678     _igvn.remove_dead_node(_memproj_fallthrough);
1679   }
1680   if (_ioproj_fallthrough != NULL) {
<a name="8" id="anc8"></a><span class="line-modified">1681     migrate_outs(_ioproj_fallthrough, i_o);</span>
1682     _igvn.remove_dead_node(_ioproj_fallthrough);
1683   }
1684   if (_memproj_catchall != NULL) {
1685     _igvn.rehash_node_delayed(_memproj_catchall);
1686     _memproj_catchall-&gt;set_req(0, top());
1687   }
1688   if (_ioproj_catchall != NULL) {
1689     _igvn.rehash_node_delayed(_ioproj_catchall);
1690     _ioproj_catchall-&gt;set_req(0, top());
1691   }
1692 #ifndef PRODUCT
1693   if (PrintEliminateAllocations) {
1694     if (alloc-&gt;is_AllocateArray()) {}
1695       tty-&gt;print_cr(&quot;++++ Eliminated: %d AllocateArray&quot;, alloc-&gt;_idx);
1696     } else {
1697       tty-&gt;print_cr(&quot;++++ Eliminated: %d Allocate&quot;, alloc-&gt;_idx);
1698     }
1699 #endif
1700   _igvn.remove_dead_node(alloc);
1701 }
1702 
1703 void PhaseMacroExpand::expand_initialize_membar(AllocateNode* alloc, InitializeNode* init,
1704                                                 Node*&amp; fast_oop_ctrl, Node*&amp; fast_oop_rawmem) {
1705   // If initialization is performed by an array copy, any required
1706   // MemBarStoreStore was already added. If the object does not
1707   // escape no need for a MemBarStoreStore. If the object does not
1708   // escape in its initializer and memory barrier (MemBarStoreStore or
1709   // stronger) is already added at exit of initializer, also no need
1710   // for a MemBarStoreStore. Otherwise we need a MemBarStoreStore
1711   // so that stores that initialize this object can&#39;t be reordered
1712   // with a subsequent store that makes this object accessible by
1713   // other threads.
1714   // Other threads include java threads and JVM internal threads
1715   // (for example concurrent GC threads). Current concurrent GC
1716   // implementation: G1 will not scan newly created object,
1717   // so it&#39;s safe to skip storestore barrier when allocation does
1718   // not escape.
1719   if (!alloc-&gt;does_not_escape_thread() &amp;&amp;
1720     !alloc-&gt;is_allocation_MemBar_redundant() &amp;&amp;
1721     (init == NULL || !init-&gt;is_complete_with_arraycopy())) {
1722     if (init == NULL || init-&gt;req() &lt; InitializeNode::RawStores) {
1723       // No InitializeNode or no stores captured by zeroing
1724       // elimination. Simply add the MemBarStoreStore after object
1725       // initialization.
1726       MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);
1727       transform_later(mb);
1728 
1729       mb-&gt;init_req(TypeFunc::Memory, fast_oop_rawmem);
1730       mb-&gt;init_req(TypeFunc::Control, fast_oop_ctrl);
1731       fast_oop_ctrl = new ProjNode(mb, TypeFunc::Control);
1732       transform_later(fast_oop_ctrl);
1733       fast_oop_rawmem = new ProjNode(mb, TypeFunc::Memory);
1734       transform_later(fast_oop_rawmem);
1735     } else {
1736       // Add the MemBarStoreStore after the InitializeNode so that
1737       // all stores performing the initialization that were moved
1738       // before the InitializeNode happen before the storestore
1739       // barrier.
1740 
1741       Node* init_ctrl = init-&gt;proj_out_or_null(TypeFunc::Control);
1742       Node* init_mem = init-&gt;proj_out_or_null(TypeFunc::Memory);
1743 
1744       MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);
1745       transform_later(mb);
1746 
1747       Node* ctrl = new ProjNode(init, TypeFunc::Control);
1748       transform_later(ctrl);
1749       Node* mem = new ProjNode(init, TypeFunc::Memory);
1750       transform_later(mem);
1751 
1752       // The MemBarStoreStore depends on control and memory coming
1753       // from the InitializeNode
1754       mb-&gt;init_req(TypeFunc::Memory, mem);
1755       mb-&gt;init_req(TypeFunc::Control, ctrl);
1756 
1757       ctrl = new ProjNode(mb, TypeFunc::Control);
1758       transform_later(ctrl);
1759       mem = new ProjNode(mb, TypeFunc::Memory);
1760       transform_later(mem);
1761 
1762       // All nodes that depended on the InitializeNode for control
1763       // and memory must now depend on the MemBarNode that itself
1764       // depends on the InitializeNode
1765       if (init_ctrl != NULL) {
1766         _igvn.replace_node(init_ctrl, ctrl);
1767       }
1768       if (init_mem != NULL) {
1769         _igvn.replace_node(init_mem, mem);
1770       }
1771     }
1772   }
1773 }
1774 
1775 void PhaseMacroExpand::expand_dtrace_alloc_probe(AllocateNode* alloc, Node* oop,
1776                                                 Node*&amp; ctrl, Node*&amp; rawmem) {
1777   if (C-&gt;env()-&gt;dtrace_extended_probes()) {
1778     // Slow-path call
1779     int size = TypeFunc::Parms + 2;
1780     CallLeafNode *call = new CallLeafNode(OptoRuntime::dtrace_object_alloc_Type(),
1781                                           CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc_base),
1782                                           &quot;dtrace_object_alloc&quot;,
1783                                           TypeRawPtr::BOTTOM);
1784 
1785     // Get base of thread-local storage area
1786     Node* thread = new ThreadLocalNode();
1787     transform_later(thread);
1788 
1789     call-&gt;init_req(TypeFunc::Parms + 0, thread);
1790     call-&gt;init_req(TypeFunc::Parms + 1, oop);
1791     call-&gt;init_req(TypeFunc::Control, ctrl);
1792     call-&gt;init_req(TypeFunc::I_O    , top()); // does no i/o
1793     call-&gt;init_req(TypeFunc::Memory , ctrl);
1794     call-&gt;init_req(TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr));
1795     call-&gt;init_req(TypeFunc::FramePtr, alloc-&gt;in(TypeFunc::FramePtr));
1796     transform_later(call);
1797     ctrl = new ProjNode(call, TypeFunc::Control);
1798     transform_later(ctrl);
1799     rawmem = new ProjNode(call, TypeFunc::Memory);
1800     transform_later(rawmem);
1801   }
1802 }
1803 
1804 // Helper for PhaseMacroExpand::expand_allocate_common.
1805 // Initializes the newly-allocated storage.
1806 Node* PhaseMacroExpand::initialize_object(AllocateNode* alloc,
1807                                           Node* control, Node* rawmem, Node* object,
1808                                           Node* klass_node, Node* length,
1809                                           Node* size_in_bytes) {
1810   InitializeNode* init = alloc-&gt;initialization();
1811   // Store the klass &amp; mark bits
1812   Node* mark_node = alloc-&gt;make_ideal_mark(&amp;_igvn, control, rawmem);
1813   if (!mark_node-&gt;is_Con()) {
1814     transform_later(mark_node);
1815   }
1816   rawmem = make_store(control, rawmem, object, oopDesc::mark_offset_in_bytes(), mark_node, TypeX_X-&gt;basic_type());
1817 
1818   BasicType bt = T_METADATA;
1819   Node* metadata = klass_node;
1820   Node* properties = alloc-&gt;in(AllocateNode::StorageProperties);
1821   if (properties != NULL) {
1822     // Encode array storage properties into klass pointer
1823     assert(EnableValhalla, &quot;array storage properties not supported&quot;);
1824     if (UseCompressedClassPointers) {
1825       // Compress the klass pointer before inserting the storage properties value
1826       metadata = transform_later(new EncodePKlassNode(metadata, metadata-&gt;bottom_type()-&gt;make_narrowklass()));
1827       metadata = transform_later(new CastN2INode(metadata));
1828       metadata = transform_later(new OrINode(metadata, transform_later(new ConvL2INode(properties))));
1829       bt = T_INT;
1830     } else {
1831       metadata = transform_later(new CastP2XNode(NULL, metadata));
1832       metadata = transform_later(new OrXNode(metadata, properties));
1833       bt = T_LONG;
1834     }
1835   }
1836   rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), metadata, bt);
1837 
1838   int header_size = alloc-&gt;minimum_header_size();  // conservatively small
1839 
1840   // Array length
1841   if (length != NULL) {         // Arrays need length field
1842     rawmem = make_store(control, rawmem, object, arrayOopDesc::length_offset_in_bytes(), length, T_INT);
1843     // conservatively small header size:
1844     header_size = arrayOopDesc::base_offset_in_bytes(T_BYTE);
1845     ciKlass* k = _igvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
1846     if (k-&gt;is_array_klass())    // we know the exact header size in most cases:
1847       header_size = Klass::layout_helper_header_size(k-&gt;layout_helper());
1848   }
1849 
1850   // Clear the object body, if necessary.
1851   if (init == NULL) {
1852     // The init has somehow disappeared; be cautious and clear everything.
1853     //
1854     // This can happen if a node is allocated but an uncommon trap occurs
1855     // immediately.  In this case, the Initialize gets associated with the
1856     // trap, and may be placed in a different (outer) loop, if the Allocate
1857     // is in a loop.  If (this is rare) the inner loop gets unrolled, then
1858     // there can be two Allocates to one Initialize.  The answer in all these
1859     // edge cases is safety first.  It is always safe to clear immediately
1860     // within an Allocate, and then (maybe or maybe not) clear some more later.
1861     if (!(UseTLAB &amp;&amp; ZeroTLAB)) {
1862       rawmem = ClearArrayNode::clear_memory(control, rawmem, object,
1863                                             alloc-&gt;in(AllocateNode::DefaultValue),
1864                                             alloc-&gt;in(AllocateNode::RawDefaultValue),
1865                                             header_size, size_in_bytes,
1866                                             &amp;_igvn);
1867     }
1868   } else {
1869     if (!init-&gt;is_complete()) {
1870       // Try to win by zeroing only what the init does not store.
1871       // We can also try to do some peephole optimizations,
1872       // such as combining some adjacent subword stores.
1873       rawmem = init-&gt;complete_stores(control, rawmem, object,
1874                                      header_size, size_in_bytes, &amp;_igvn);
1875     }
1876     // We have no more use for this link, since the AllocateNode goes away:
1877     init-&gt;set_req(InitializeNode::RawAddress, top());
1878     // (If we keep the link, it just confuses the register allocator,
1879     // who thinks he sees a real use of the address by the membar.)
1880   }
1881 
1882   return rawmem;
1883 }
1884 
1885 // Generate prefetch instructions for next allocations.
1886 Node* PhaseMacroExpand::prefetch_allocation(Node* i_o, Node*&amp; needgc_false,
1887                                         Node*&amp; contended_phi_rawmem,
1888                                         Node* old_eden_top, Node* new_eden_top,
1889                                         intx lines) {
1890    enum { fall_in_path = 1, pf_path = 2 };
1891    if( UseTLAB &amp;&amp; AllocatePrefetchStyle == 2 ) {
1892       // Generate prefetch allocation with watermark check.
1893       // As an allocation hits the watermark, we will prefetch starting
1894       // at a &quot;distance&quot; away from watermark.
1895 
1896       Node *pf_region = new RegionNode(3);
1897       Node *pf_phi_rawmem = new PhiNode( pf_region, Type::MEMORY,
1898                                                 TypeRawPtr::BOTTOM );
1899       // I/O is used for Prefetch
1900       Node *pf_phi_abio = new PhiNode( pf_region, Type::ABIO );
1901 
1902       Node *thread = new ThreadLocalNode();
1903       transform_later(thread);
1904 
1905       Node *eden_pf_adr = new AddPNode( top()/*not oop*/, thread,
1906                    _igvn.MakeConX(in_bytes(JavaThread::tlab_pf_top_offset())) );
1907       transform_later(eden_pf_adr);
1908 
1909       Node *old_pf_wm = new LoadPNode(needgc_false,
1910                                    contended_phi_rawmem, eden_pf_adr,
1911                                    TypeRawPtr::BOTTOM, TypeRawPtr::BOTTOM,
1912                                    MemNode::unordered);
1913       transform_later(old_pf_wm);
1914 
1915       // check against new_eden_top
1916       Node *need_pf_cmp = new CmpPNode( new_eden_top, old_pf_wm );
1917       transform_later(need_pf_cmp);
1918       Node *need_pf_bol = new BoolNode( need_pf_cmp, BoolTest::ge );
1919       transform_later(need_pf_bol);
1920       IfNode *need_pf_iff = new IfNode( needgc_false, need_pf_bol,
1921                                        PROB_UNLIKELY_MAG(4), COUNT_UNKNOWN );
1922       transform_later(need_pf_iff);
1923 
1924       // true node, add prefetchdistance
1925       Node *need_pf_true = new IfTrueNode( need_pf_iff );
1926       transform_later(need_pf_true);
1927 
1928       Node *need_pf_false = new IfFalseNode( need_pf_iff );
1929       transform_later(need_pf_false);
1930 
1931       Node *new_pf_wmt = new AddPNode( top(), old_pf_wm,
1932                                     _igvn.MakeConX(AllocatePrefetchDistance) );
1933       transform_later(new_pf_wmt );
1934       new_pf_wmt-&gt;set_req(0, need_pf_true);
1935 
1936       Node *store_new_wmt = new StorePNode(need_pf_true,
1937                                        contended_phi_rawmem, eden_pf_adr,
1938                                        TypeRawPtr::BOTTOM, new_pf_wmt,
1939                                        MemNode::unordered);
1940       transform_later(store_new_wmt);
1941 
1942       // adding prefetches
1943       pf_phi_abio-&gt;init_req( fall_in_path, i_o );
1944 
1945       Node *prefetch_adr;
1946       Node *prefetch;
1947       uint step_size = AllocatePrefetchStepSize;
1948       uint distance = 0;
1949 
1950       for ( intx i = 0; i &lt; lines; i++ ) {
1951         prefetch_adr = new AddPNode( old_pf_wm, new_pf_wmt,
1952                                             _igvn.MakeConX(distance) );
1953         transform_later(prefetch_adr);
1954         prefetch = new PrefetchAllocationNode( i_o, prefetch_adr );
1955         transform_later(prefetch);
1956         distance += step_size;
1957         i_o = prefetch;
1958       }
1959       pf_phi_abio-&gt;set_req( pf_path, i_o );
1960 
1961       pf_region-&gt;init_req( fall_in_path, need_pf_false );
1962       pf_region-&gt;init_req( pf_path, need_pf_true );
1963 
1964       pf_phi_rawmem-&gt;init_req( fall_in_path, contended_phi_rawmem );
1965       pf_phi_rawmem-&gt;init_req( pf_path, store_new_wmt );
1966 
1967       transform_later(pf_region);
1968       transform_later(pf_phi_rawmem);
1969       transform_later(pf_phi_abio);
1970 
1971       needgc_false = pf_region;
1972       contended_phi_rawmem = pf_phi_rawmem;
1973       i_o = pf_phi_abio;
1974    } else if( UseTLAB &amp;&amp; AllocatePrefetchStyle == 3 ) {
1975       // Insert a prefetch instruction for each allocation.
1976       // This code is used to generate 1 prefetch instruction per cache line.
1977 
1978       // Generate several prefetch instructions.
1979       uint step_size = AllocatePrefetchStepSize;
1980       uint distance = AllocatePrefetchDistance;
1981 
1982       // Next cache address.
1983       Node *cache_adr = new AddPNode(old_eden_top, old_eden_top,
1984                                      _igvn.MakeConX(step_size + distance));
1985       transform_later(cache_adr);
1986       cache_adr = new CastP2XNode(needgc_false, cache_adr);
1987       transform_later(cache_adr);
1988       // Address is aligned to execute prefetch to the beginning of cache line size
1989       // (it is important when BIS instruction is used on SPARC as prefetch).
1990       Node* mask = _igvn.MakeConX(~(intptr_t)(step_size-1));
1991       cache_adr = new AndXNode(cache_adr, mask);
1992       transform_later(cache_adr);
1993       cache_adr = new CastX2PNode(cache_adr);
1994       transform_later(cache_adr);
1995 
1996       // Prefetch
1997       Node *prefetch = new PrefetchAllocationNode( contended_phi_rawmem, cache_adr );
1998       prefetch-&gt;set_req(0, needgc_false);
1999       transform_later(prefetch);
2000       contended_phi_rawmem = prefetch;
2001       Node *prefetch_adr;
2002       distance = step_size;
2003       for ( intx i = 1; i &lt; lines; i++ ) {
2004         prefetch_adr = new AddPNode( cache_adr, cache_adr,
2005                                             _igvn.MakeConX(distance) );
2006         transform_later(prefetch_adr);
2007         prefetch = new PrefetchAllocationNode( contended_phi_rawmem, prefetch_adr );
2008         transform_later(prefetch);
2009         distance += step_size;
2010         contended_phi_rawmem = prefetch;
2011       }
2012    } else if( AllocatePrefetchStyle &gt; 0 ) {
2013       // Insert a prefetch for each allocation only on the fast-path
2014       Node *prefetch_adr;
2015       Node *prefetch;
2016       // Generate several prefetch instructions.
2017       uint step_size = AllocatePrefetchStepSize;
2018       uint distance = AllocatePrefetchDistance;
2019       for ( intx i = 0; i &lt; lines; i++ ) {
2020         prefetch_adr = new AddPNode( old_eden_top, new_eden_top,
2021                                             _igvn.MakeConX(distance) );
2022         transform_later(prefetch_adr);
2023         prefetch = new PrefetchAllocationNode( i_o, prefetch_adr );
2024         // Do not let it float too high, since if eden_top == eden_end,
2025         // both might be null.
2026         if( i == 0 ) { // Set control for first prefetch, next follows it
2027           prefetch-&gt;init_req(0, needgc_false);
2028         }
2029         transform_later(prefetch);
2030         distance += step_size;
2031         i_o = prefetch;
2032       }
2033    }
2034    return i_o;
2035 }
2036 
2037 
2038 void PhaseMacroExpand::expand_allocate(AllocateNode *alloc) {
2039   expand_allocate_common(alloc, NULL,
2040                          OptoRuntime::new_instance_Type(),
2041                          OptoRuntime::new_instance_Java());
2042 }
2043 
2044 void PhaseMacroExpand::expand_allocate_array(AllocateArrayNode *alloc) {
2045   Node* length = alloc-&gt;in(AllocateNode::ALength);
2046   InitializeNode* init = alloc-&gt;initialization();
2047   Node* klass_node = alloc-&gt;in(AllocateNode::KlassNode);
2048   ciKlass* k = _igvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
2049   address slow_call_address;  // Address of slow call
2050   if (init != NULL &amp;&amp; init-&gt;is_complete_with_arraycopy() &amp;&amp;
2051       k-&gt;is_type_array_klass()) {
2052     // Don&#39;t zero type array during slow allocation in VM since
2053     // it will be initialized later by arraycopy in compiled code.
2054     slow_call_address = OptoRuntime::new_array_nozero_Java();
2055   } else {
2056     slow_call_address = OptoRuntime::new_array_Java();
2057   }
2058   expand_allocate_common(alloc, length,
2059                          OptoRuntime::new_array_Type(),
2060                          slow_call_address);
2061 }
2062 
2063 //-------------------mark_eliminated_box----------------------------------
2064 //
2065 // During EA obj may point to several objects but after few ideal graph
2066 // transformations (CCP) it may point to only one non escaping object
2067 // (but still using phi), corresponding locks and unlocks will be marked
2068 // for elimination. Later obj could be replaced with a new node (new phi)
2069 // and which does not have escape information. And later after some graph
2070 // reshape other locks and unlocks (which were not marked for elimination
2071 // before) are connected to this new obj (phi) but they still will not be
2072 // marked for elimination since new obj has no escape information.
2073 // Mark all associated (same box and obj) lock and unlock nodes for
2074 // elimination if some of them marked already.
2075 void PhaseMacroExpand::mark_eliminated_box(Node* oldbox, Node* obj) {
2076   if (oldbox-&gt;as_BoxLock()-&gt;is_eliminated())
2077     return; // This BoxLock node was processed already.
2078 
2079   // New implementation (EliminateNestedLocks) has separate BoxLock
2080   // node for each locked region so mark all associated locks/unlocks as
2081   // eliminated even if different objects are referenced in one locked region
2082   // (for example, OSR compilation of nested loop inside locked scope).
2083   if (EliminateNestedLocks ||
2084       oldbox-&gt;as_BoxLock()-&gt;is_simple_lock_region(NULL, obj)) {
2085     // Box is used only in one lock region. Mark this box as eliminated.
2086     _igvn.hash_delete(oldbox);
2087     oldbox-&gt;as_BoxLock()-&gt;set_eliminated(); // This changes box&#39;s hash value
2088      _igvn.hash_insert(oldbox);
2089 
2090     for (uint i = 0; i &lt; oldbox-&gt;outcnt(); i++) {
2091       Node* u = oldbox-&gt;raw_out(i);
2092       if (u-&gt;is_AbstractLock() &amp;&amp; !u-&gt;as_AbstractLock()-&gt;is_non_esc_obj()) {
2093         AbstractLockNode* alock = u-&gt;as_AbstractLock();
2094         // Check lock&#39;s box since box could be referenced by Lock&#39;s debug info.
2095         if (alock-&gt;box_node() == oldbox) {
2096           // Mark eliminated all related locks and unlocks.
2097 #ifdef ASSERT
2098           alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_set_non_esc4&quot;);
2099 #endif
2100           alock-&gt;set_non_esc_obj();
2101         }
2102       }
2103     }
2104     return;
2105   }
2106 
2107   // Create new &quot;eliminated&quot; BoxLock node and use it in monitor debug info
2108   // instead of oldbox for the same object.
2109   BoxLockNode* newbox = oldbox-&gt;clone()-&gt;as_BoxLock();
2110 
2111   // Note: BoxLock node is marked eliminated only here and it is used
2112   // to indicate that all associated lock and unlock nodes are marked
2113   // for elimination.
2114   newbox-&gt;set_eliminated();
2115   transform_later(newbox);
2116 
2117   // Replace old box node with new box for all users of the same object.
2118   for (uint i = 0; i &lt; oldbox-&gt;outcnt();) {
2119     bool next_edge = true;
2120 
2121     Node* u = oldbox-&gt;raw_out(i);
2122     if (u-&gt;is_AbstractLock()) {
2123       AbstractLockNode* alock = u-&gt;as_AbstractLock();
2124       if (alock-&gt;box_node() == oldbox &amp;&amp; alock-&gt;obj_node()-&gt;eqv_uncast(obj)) {
2125         // Replace Box and mark eliminated all related locks and unlocks.
2126 #ifdef ASSERT
2127         alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_set_non_esc5&quot;);
2128 #endif
2129         alock-&gt;set_non_esc_obj();
2130         _igvn.rehash_node_delayed(alock);
2131         alock-&gt;set_box_node(newbox);
2132         next_edge = false;
2133       }
2134     }
2135     if (u-&gt;is_FastLock() &amp;&amp; u-&gt;as_FastLock()-&gt;obj_node()-&gt;eqv_uncast(obj)) {
2136       FastLockNode* flock = u-&gt;as_FastLock();
2137       assert(flock-&gt;box_node() == oldbox, &quot;sanity&quot;);
2138       _igvn.rehash_node_delayed(flock);
2139       flock-&gt;set_box_node(newbox);
2140       next_edge = false;
2141     }
2142 
2143     // Replace old box in monitor debug info.
2144     if (u-&gt;is_SafePoint() &amp;&amp; u-&gt;as_SafePoint()-&gt;jvms()) {
2145       SafePointNode* sfn = u-&gt;as_SafePoint();
2146       JVMState* youngest_jvms = sfn-&gt;jvms();
2147       int max_depth = youngest_jvms-&gt;depth();
2148       for (int depth = 1; depth &lt;= max_depth; depth++) {
2149         JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
2150         int num_mon  = jvms-&gt;nof_monitors();
2151         // Loop over monitors
2152         for (int idx = 0; idx &lt; num_mon; idx++) {
2153           Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
2154           Node* box_node = sfn-&gt;monitor_box(jvms, idx);
2155           if (box_node == oldbox &amp;&amp; obj_node-&gt;eqv_uncast(obj)) {
2156             int j = jvms-&gt;monitor_box_offset(idx);
2157             _igvn.replace_input_of(u, j, newbox);
2158             next_edge = false;
2159           }
2160         }
2161       }
2162     }
2163     if (next_edge) i++;
2164   }
2165 }
2166 
2167 //-----------------------mark_eliminated_locking_nodes-----------------------
2168 void PhaseMacroExpand::mark_eliminated_locking_nodes(AbstractLockNode *alock) {
2169   if (EliminateNestedLocks) {
2170     if (alock-&gt;is_nested()) {
2171        assert(alock-&gt;box_node()-&gt;as_BoxLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2172        return;
2173     } else if (!alock-&gt;is_non_esc_obj()) { // Not eliminated or coarsened
2174       // Only Lock node has JVMState needed here.
2175       // Not that preceding claim is documented anywhere else.
2176       if (alock-&gt;jvms() != NULL) {
2177         if (alock-&gt;as_Lock()-&gt;is_nested_lock_region()) {
2178           // Mark eliminated related nested locks and unlocks.
2179           Node* obj = alock-&gt;obj_node();
2180           BoxLockNode* box_node = alock-&gt;box_node()-&gt;as_BoxLock();
2181           assert(!box_node-&gt;is_eliminated(), &quot;should not be marked yet&quot;);
2182           // Note: BoxLock node is marked eliminated only here
2183           // and it is used to indicate that all associated lock
2184           // and unlock nodes are marked for elimination.
2185           box_node-&gt;set_eliminated(); // Box&#39;s hash is always NO_HASH here
2186           for (uint i = 0; i &lt; box_node-&gt;outcnt(); i++) {
2187             Node* u = box_node-&gt;raw_out(i);
2188             if (u-&gt;is_AbstractLock()) {
2189               alock = u-&gt;as_AbstractLock();
2190               if (alock-&gt;box_node() == box_node) {
2191                 // Verify that this Box is referenced only by related locks.
2192                 assert(alock-&gt;obj_node()-&gt;eqv_uncast(obj), &quot;&quot;);
2193                 // Mark all related locks and unlocks.
2194 #ifdef ASSERT
2195                 alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_set_nested&quot;);
2196 #endif
2197                 alock-&gt;set_nested();
2198               }
2199             }
2200           }
2201         } else {
2202 #ifdef ASSERT
2203           alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_NOT_nested_lock_region&quot;);
2204           if (C-&gt;log() != NULL)
2205             alock-&gt;as_Lock()-&gt;is_nested_lock_region(C); // rerun for debugging output
2206 #endif
2207         }
2208       }
2209       return;
2210     }
2211     // Process locks for non escaping object
2212     assert(alock-&gt;is_non_esc_obj(), &quot;&quot;);
2213   } // EliminateNestedLocks
2214 
2215   if (alock-&gt;is_non_esc_obj()) { // Lock is used for non escaping object
2216     // Look for all locks of this object and mark them and
2217     // corresponding BoxLock nodes as eliminated.
2218     Node* obj = alock-&gt;obj_node();
2219     for (uint j = 0; j &lt; obj-&gt;outcnt(); j++) {
2220       Node* o = obj-&gt;raw_out(j);
2221       if (o-&gt;is_AbstractLock() &amp;&amp;
2222           o-&gt;as_AbstractLock()-&gt;obj_node()-&gt;eqv_uncast(obj)) {
2223         alock = o-&gt;as_AbstractLock();
2224         Node* box = alock-&gt;box_node();
2225         // Replace old box node with new eliminated box for all users
2226         // of the same object and mark related locks as eliminated.
2227         mark_eliminated_box(box, obj);
2228       }
2229     }
2230   }
2231 }
2232 
2233 // we have determined that this lock/unlock can be eliminated, we simply
2234 // eliminate the node without expanding it.
2235 //
2236 // Note:  The membar&#39;s associated with the lock/unlock are currently not
2237 //        eliminated.  This should be investigated as a future enhancement.
2238 //
2239 bool PhaseMacroExpand::eliminate_locking_node(AbstractLockNode *alock) {
2240 
2241   if (!alock-&gt;is_eliminated()) {
2242     return false;
2243   }
2244 #ifdef ASSERT
2245   const Type* obj_type = _igvn.type(alock-&gt;obj_node());
2246   assert(!obj_type-&gt;isa_valuetype() &amp;&amp; !obj_type-&gt;is_valuetypeptr(), &quot;Eliminating lock on value type&quot;);
2247   if (!alock-&gt;is_coarsened()) {
2248     // Check that new &quot;eliminated&quot; BoxLock node is created.
2249     BoxLockNode* oldbox = alock-&gt;box_node()-&gt;as_BoxLock();
2250     assert(oldbox-&gt;is_eliminated(), &quot;should be done already&quot;);
2251   }
2252 #endif
2253 
2254   alock-&gt;log_lock_optimization(C, &quot;eliminate_lock&quot;);
2255 
2256 #ifndef PRODUCT
2257   if (PrintEliminateLocks) {
2258     if (alock-&gt;is_Lock()) {
2259       tty-&gt;print_cr(&quot;++++ Eliminated: %d Lock&quot;, alock-&gt;_idx);
2260     } else {
2261       tty-&gt;print_cr(&quot;++++ Eliminated: %d Unlock&quot;, alock-&gt;_idx);
2262     }
2263   }
2264 #endif
2265 
2266   Node* mem  = alock-&gt;in(TypeFunc::Memory);
2267   Node* ctrl = alock-&gt;in(TypeFunc::Control);
2268   guarantee(ctrl != NULL, &quot;missing control projection, cannot replace_node() with NULL&quot;);
2269 
2270   extract_call_projections(alock);
2271   // There are 2 projections from the lock.  The lock node will
2272   // be deleted when its last use is subsumed below.
2273   assert(alock-&gt;outcnt() == 2 &amp;&amp;
2274          _fallthroughproj != NULL &amp;&amp;
2275          _memproj_fallthrough != NULL,
2276          &quot;Unexpected projections from Lock/Unlock&quot;);
2277 
2278   Node* fallthroughproj = _fallthroughproj;
2279   Node* memproj_fallthrough = _memproj_fallthrough;
2280 
2281   // The memory projection from a lock/unlock is RawMem
2282   // The input to a Lock is merged memory, so extract its RawMem input
2283   // (unless the MergeMem has been optimized away.)
2284   if (alock-&gt;is_Lock()) {
2285     // Seach for MemBarAcquireLock node and delete it also.
2286     MemBarNode* membar = fallthroughproj-&gt;unique_ctrl_out()-&gt;as_MemBar();
2287     assert(membar != NULL &amp;&amp; membar-&gt;Opcode() == Op_MemBarAcquireLock, &quot;&quot;);
2288     Node* ctrlproj = membar-&gt;proj_out(TypeFunc::Control);
2289     Node* memproj = membar-&gt;proj_out(TypeFunc::Memory);
2290     _igvn.replace_node(ctrlproj, fallthroughproj);
2291     _igvn.replace_node(memproj, memproj_fallthrough);
2292 
2293     // Delete FastLock node also if this Lock node is unique user
2294     // (a loop peeling may clone a Lock node).
2295     Node* flock = alock-&gt;as_Lock()-&gt;fastlock_node();
2296     if (flock-&gt;outcnt() == 1) {
2297       assert(flock-&gt;unique_out() == alock, &quot;sanity&quot;);
2298       _igvn.replace_node(flock, top());
2299     }
2300   }
2301 
2302   // Seach for MemBarReleaseLock node and delete it also.
2303   if (alock-&gt;is_Unlock() &amp;&amp; ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_MemBar()) {
2304     MemBarNode* membar = ctrl-&gt;in(0)-&gt;as_MemBar();
2305     assert(membar-&gt;Opcode() == Op_MemBarReleaseLock &amp;&amp;
2306            mem-&gt;is_Proj() &amp;&amp; membar == mem-&gt;in(0), &quot;&quot;);
2307     _igvn.replace_node(fallthroughproj, ctrl);
2308     _igvn.replace_node(memproj_fallthrough, mem);
2309     fallthroughproj = ctrl;
2310     memproj_fallthrough = mem;
2311     ctrl = membar-&gt;in(TypeFunc::Control);
2312     mem  = membar-&gt;in(TypeFunc::Memory);
2313   }
2314 
2315   _igvn.replace_node(fallthroughproj, ctrl);
2316   _igvn.replace_node(memproj_fallthrough, mem);
2317   return true;
2318 }
2319 
2320 
2321 //------------------------------expand_lock_node----------------------
2322 void PhaseMacroExpand::expand_lock_node(LockNode *lock) {
2323 
2324   Node* ctrl = lock-&gt;in(TypeFunc::Control);
2325   Node* mem = lock-&gt;in(TypeFunc::Memory);
2326   Node* obj = lock-&gt;obj_node();
2327   Node* box = lock-&gt;box_node();
2328   Node* flock = lock-&gt;fastlock_node();
2329 
2330   assert(!box-&gt;as_BoxLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2331 
2332   // Make the merge point
2333   Node *region;
2334   Node *mem_phi;
2335   Node *slow_path;
2336 
2337   if (UseOptoBiasInlining) {
2338     /*
2339      *  See the full description in MacroAssembler::biased_locking_enter().
2340      *
2341      *  if( (mark_word &amp; biased_lock_mask) == biased_lock_pattern ) {
2342      *    // The object is biased.
2343      *    proto_node = klass-&gt;prototype_header;
2344      *    o_node = thread | proto_node;
2345      *    x_node = o_node ^ mark_word;
2346      *    if( (x_node &amp; ~age_mask) == 0 ) { // Biased to the current thread ?
2347      *      // Done.
2348      *    } else {
2349      *      if( (x_node &amp; biased_lock_mask) != 0 ) {
2350      *        // The klass&#39;s prototype header is no longer biased.
2351      *        cas(&amp;mark_word, mark_word, proto_node)
2352      *        goto cas_lock;
2353      *      } else {
2354      *        // The klass&#39;s prototype header is still biased.
2355      *        if( (x_node &amp; epoch_mask) != 0 ) { // Expired epoch?
2356      *          old = mark_word;
2357      *          new = o_node;
2358      *        } else {
2359      *          // Different thread or anonymous biased.
2360      *          old = mark_word &amp; (epoch_mask | age_mask | biased_lock_mask);
2361      *          new = thread | old;
2362      *        }
2363      *        // Try to rebias.
2364      *        if( cas(&amp;mark_word, old, new) == 0 ) {
2365      *          // Done.
2366      *        } else {
2367      *          goto slow_path; // Failed.
2368      *        }
2369      *      }
2370      *    }
2371      *  } else {
2372      *    // The object is not biased.
2373      *    cas_lock:
2374      *    if( FastLock(obj) == 0 ) {
2375      *      // Done.
2376      *    } else {
2377      *      slow_path:
2378      *      OptoRuntime::complete_monitor_locking_Java(obj);
2379      *    }
2380      *  }
2381      */
2382 
2383     region  = new RegionNode(5);
2384     // create a Phi for the memory state
2385     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2386 
2387     Node* fast_lock_region  = new RegionNode(3);
2388     Node* fast_lock_mem_phi = new PhiNode( fast_lock_region, Type::MEMORY, TypeRawPtr::BOTTOM);
2389 
2390     // First, check mark word for the biased lock pattern.
2391     Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X-&gt;basic_type());
2392 
2393     // Get fast path - mark word has the biased lock pattern.
2394     ctrl = opt_bits_test(ctrl, fast_lock_region, 1, mark_node,
2395                          markWord::biased_lock_mask_in_place,
2396                          markWord::biased_lock_pattern, true);
2397     // fast_lock_region-&gt;in(1) is set to slow path.
2398     fast_lock_mem_phi-&gt;init_req(1, mem);
2399 
2400     // Now check that the lock is biased to the current thread and has
2401     // the same epoch and bias as Klass::_prototype_header.
2402 
2403     // Special-case a fresh allocation to avoid building nodes:
2404     Node* klass_node = AllocateNode::Ideal_klass(obj, &amp;_igvn);
2405     if (klass_node == NULL) {
2406       Node* k_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());
2407       klass_node = transform_later(LoadKlassNode::make(_igvn, NULL, mem, k_adr, _igvn.type(k_adr)-&gt;is_ptr()));
2408 #ifdef _LP64
2409       if (UseCompressedClassPointers &amp;&amp; klass_node-&gt;is_DecodeNKlass()) {
2410         assert(klass_node-&gt;in(1)-&gt;Opcode() == Op_LoadNKlass, &quot;sanity&quot;);
2411         klass_node-&gt;in(1)-&gt;init_req(0, ctrl);
2412       } else
2413 #endif
2414       klass_node-&gt;init_req(0, ctrl);
2415     }
2416     Node *proto_node = make_load(ctrl, mem, klass_node, in_bytes(Klass::prototype_header_offset()), TypeX_X, TypeX_X-&gt;basic_type());
2417 
2418     Node* thread = transform_later(new ThreadLocalNode());
2419     Node* cast_thread = transform_later(new CastP2XNode(ctrl, thread));
2420     Node* o_node = transform_later(new OrXNode(cast_thread, proto_node));
2421     Node* x_node = transform_later(new XorXNode(o_node, mark_node));
2422 
2423     // Get slow path - mark word does NOT match the value.
2424     STATIC_ASSERT(markWord::age_mask_in_place &lt;= INT_MAX);
2425     Node* not_biased_ctrl =  opt_bits_test(ctrl, region, 3, x_node,
2426                                       (~(int)markWord::age_mask_in_place), 0);
2427     // region-&gt;in(3) is set to fast path - the object is biased to the current thread.
2428     mem_phi-&gt;init_req(3, mem);
2429 
2430 
2431     // Mark word does NOT match the value (thread | Klass::_prototype_header).
2432 
2433 
2434     // First, check biased pattern.
2435     // Get fast path - _prototype_header has the same biased lock pattern.
2436     ctrl =  opt_bits_test(not_biased_ctrl, fast_lock_region, 2, x_node,
2437                           markWord::biased_lock_mask_in_place, 0, true);
2438 
2439     not_biased_ctrl = fast_lock_region-&gt;in(2); // Slow path
2440     // fast_lock_region-&gt;in(2) - the prototype header is no longer biased
2441     // and we have to revoke the bias on this object.
2442     // We are going to try to reset the mark of this object to the prototype
2443     // value and fall through to the CAS-based locking scheme.
2444     Node* adr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());
2445     Node* cas = new StoreXConditionalNode(not_biased_ctrl, mem, adr,
2446                                           proto_node, mark_node);
2447     transform_later(cas);
2448     Node* proj = transform_later(new SCMemProjNode(cas));
2449     fast_lock_mem_phi-&gt;init_req(2, proj);
2450 
2451 
2452     // Second, check epoch bits.
2453     Node* rebiased_region  = new RegionNode(3);
2454     Node* old_phi = new PhiNode( rebiased_region, TypeX_X);
2455     Node* new_phi = new PhiNode( rebiased_region, TypeX_X);
2456 
2457     // Get slow path - mark word does NOT match epoch bits.
2458     Node* epoch_ctrl =  opt_bits_test(ctrl, rebiased_region, 1, x_node,
2459                                       markWord::epoch_mask_in_place, 0);
2460     // The epoch of the current bias is not valid, attempt to rebias the object
2461     // toward the current thread.
2462     rebiased_region-&gt;init_req(2, epoch_ctrl);
2463     old_phi-&gt;init_req(2, mark_node);
2464     new_phi-&gt;init_req(2, o_node);
2465 
2466     // rebiased_region-&gt;in(1) is set to fast path.
2467     // The epoch of the current bias is still valid but we know
2468     // nothing about the owner; it might be set or it might be clear.
2469     Node* cmask   = MakeConX(markWord::biased_lock_mask_in_place |
2470                              markWord::age_mask_in_place |
2471                              markWord::epoch_mask_in_place);
2472     Node* old = transform_later(new AndXNode(mark_node, cmask));
2473     cast_thread = transform_later(new CastP2XNode(ctrl, thread));
2474     Node* new_mark = transform_later(new OrXNode(cast_thread, old));
2475     old_phi-&gt;init_req(1, old);
2476     new_phi-&gt;init_req(1, new_mark);
2477 
2478     transform_later(rebiased_region);
2479     transform_later(old_phi);
2480     transform_later(new_phi);
2481 
2482     // Try to acquire the bias of the object using an atomic operation.
2483     // If this fails we will go in to the runtime to revoke the object&#39;s bias.
2484     cas = new StoreXConditionalNode(rebiased_region, mem, adr, new_phi, old_phi);
2485     transform_later(cas);
2486     proj = transform_later(new SCMemProjNode(cas));
2487 
2488     // Get slow path - Failed to CAS.
2489     not_biased_ctrl = opt_bits_test(rebiased_region, region, 4, cas, 0, 0);
2490     mem_phi-&gt;init_req(4, proj);
2491     // region-&gt;in(4) is set to fast path - the object is rebiased to the current thread.
2492 
2493     // Failed to CAS.
2494     slow_path  = new RegionNode(3);
2495     Node *slow_mem = new PhiNode( slow_path, Type::MEMORY, TypeRawPtr::BOTTOM);
2496 
2497     slow_path-&gt;init_req(1, not_biased_ctrl); // Capture slow-control
2498     slow_mem-&gt;init_req(1, proj);
2499 
2500     // Call CAS-based locking scheme (FastLock node).
2501 
2502     transform_later(fast_lock_region);
2503     transform_later(fast_lock_mem_phi);
2504 
2505     // Get slow path - FastLock failed to lock the object.
2506     ctrl = opt_bits_test(fast_lock_region, region, 2, flock, 0, 0);
2507     mem_phi-&gt;init_req(2, fast_lock_mem_phi);
2508     // region-&gt;in(2) is set to fast path - the object is locked to the current thread.
2509 
2510     slow_path-&gt;init_req(2, ctrl); // Capture slow-control
2511     slow_mem-&gt;init_req(2, fast_lock_mem_phi);
2512 
2513     transform_later(slow_path);
2514     transform_later(slow_mem);
2515     // Reset lock&#39;s memory edge.
2516     lock-&gt;set_req(TypeFunc::Memory, slow_mem);
2517 
2518   } else {
2519     region  = new RegionNode(3);
2520     // create a Phi for the memory state
2521     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2522 
2523     // Optimize test; set region slot 2
2524     slow_path = opt_bits_test(ctrl, region, 2, flock, 0, 0);
2525     mem_phi-&gt;init_req(2, mem);
2526   }
2527 
2528   const TypeOopPtr* objptr = _igvn.type(obj)-&gt;make_oopptr();
2529   if (objptr-&gt;can_be_value_type()) {
2530     // Deoptimize and re-execute if a value
2531     assert(EnableValhalla, &quot;should only be used if value types are enabled&quot;);
2532     Node* mark = make_load(slow_path, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X-&gt;basic_type());
2533     Node* value_mask = _igvn.MakeConX(markWord::always_locked_pattern);
2534     Node* is_value = _igvn.transform(new AndXNode(mark, value_mask));
2535     Node* cmp = _igvn.transform(new CmpXNode(is_value, value_mask));
2536     Node* bol = _igvn.transform(new BoolNode(cmp, BoolTest::eq));
2537     Node* unc_ctrl = generate_slow_guard(&amp;slow_path, bol, NULL);
2538 
2539     int trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_class_check, Deoptimization::Action_none);
2540     address call_addr = SharedRuntime::uncommon_trap_blob()-&gt;entry_point();
2541     const TypePtr* no_memory_effects = NULL;
2542     JVMState* jvms = lock-&gt;jvms();
2543     CallNode* unc = new CallStaticJavaNode(OptoRuntime::uncommon_trap_Type(), call_addr, &quot;uncommon_trap&quot;,
2544                                            jvms-&gt;bci(), no_memory_effects);
2545 
2546     unc-&gt;init_req(TypeFunc::Control, unc_ctrl);
2547     unc-&gt;init_req(TypeFunc::I_O, lock-&gt;i_o());
2548     unc-&gt;init_req(TypeFunc::Memory, mem); // may gc ptrs
2549     unc-&gt;init_req(TypeFunc::FramePtr,  lock-&gt;in(TypeFunc::FramePtr));
2550     unc-&gt;init_req(TypeFunc::ReturnAdr, lock-&gt;in(TypeFunc::ReturnAdr));
2551     unc-&gt;init_req(TypeFunc::Parms+0, _igvn.intcon(trap_request));
2552     unc-&gt;set_cnt(PROB_UNLIKELY_MAG(4));
2553     unc-&gt;copy_call_debug_info(&amp;_igvn, lock);
2554 
2555     assert(unc-&gt;peek_monitor_box() == box, &quot;wrong monitor&quot;);
2556     assert(unc-&gt;peek_monitor_obj() == obj, &quot;wrong monitor&quot;);
2557 
2558     // pop monitor and push obj back on stack: we trap before the monitorenter
2559     unc-&gt;pop_monitor();
2560     unc-&gt;grow_stack(unc-&gt;jvms(), 1);
2561     unc-&gt;set_stack(unc-&gt;jvms(), unc-&gt;jvms()-&gt;stk_size()-1, obj);
2562 
2563     _igvn.register_new_node_with_optimizer(unc);
2564 
2565     Node* ctrl = _igvn.transform(new ProjNode(unc, TypeFunc::Control));
2566     Node* halt = _igvn.transform(new HaltNode(ctrl, lock-&gt;in(TypeFunc::FramePtr), &quot;monitor enter on value-type&quot;));
2567     C-&gt;root()-&gt;add_req(halt);
2568   }
2569 
2570   // Make slow path call
2571   CallNode *call = make_slow_call((CallNode *) lock, OptoRuntime::complete_monitor_enter_Type(),
2572                                   OptoRuntime::complete_monitor_locking_Java(), NULL, slow_path,
2573                                   obj, box, NULL);
2574 
2575   extract_call_projections(call);
2576 
2577   // Slow path can only throw asynchronous exceptions, which are always
2578   // de-opted.  So the compiler thinks the slow-call can never throw an
2579   // exception.  If it DOES throw an exception we would need the debug
2580   // info removed first (since if it throws there is no monitor).
2581   assert ( _ioproj_fallthrough == NULL &amp;&amp; _ioproj_catchall == NULL &amp;&amp;
2582            _memproj_catchall == NULL &amp;&amp; _catchallcatchproj == NULL, &quot;Unexpected projection from Lock&quot;);
2583 
2584   // Capture slow path
2585   // disconnect fall-through projection from call and create a new one
2586   // hook up users of fall-through projection to region
2587   Node *slow_ctrl = _fallthroughproj-&gt;clone();
2588   transform_later(slow_ctrl);
2589   _igvn.hash_delete(_fallthroughproj);
2590   _fallthroughproj-&gt;disconnect_inputs(NULL, C);
2591   region-&gt;init_req(1, slow_ctrl);
2592   // region inputs are now complete
2593   transform_later(region);
2594   _igvn.replace_node(_fallthroughproj, region);
2595 
2596   Node *memproj = transform_later(new ProjNode(call, TypeFunc::Memory));
2597   mem_phi-&gt;init_req(1, memproj );
2598   transform_later(mem_phi);
2599   _igvn.replace_node(_memproj_fallthrough, mem_phi);
2600 }
2601 
2602 //------------------------------expand_unlock_node----------------------
2603 void PhaseMacroExpand::expand_unlock_node(UnlockNode *unlock) {
2604 
2605   Node* ctrl = unlock-&gt;in(TypeFunc::Control);
2606   Node* mem = unlock-&gt;in(TypeFunc::Memory);
2607   Node* obj = unlock-&gt;obj_node();
2608   Node* box = unlock-&gt;box_node();
2609 
2610   assert(!box-&gt;as_BoxLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2611 
2612   // No need for a null check on unlock
2613 
2614   // Make the merge point
2615   Node *region;
2616   Node *mem_phi;
2617 
2618   if (UseOptoBiasInlining) {
2619     // Check for biased locking unlock case, which is a no-op.
2620     // See the full description in MacroAssembler::biased_locking_exit().
2621     region  = new RegionNode(4);
2622     // create a Phi for the memory state
2623     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2624     mem_phi-&gt;init_req(3, mem);
2625 
2626     Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X-&gt;basic_type());
2627     ctrl = opt_bits_test(ctrl, region, 3, mark_node,
2628                          markWord::biased_lock_mask_in_place,
2629                          markWord::biased_lock_pattern);
2630   } else {
2631     region  = new RegionNode(3);
2632     // create a Phi for the memory state
2633     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2634   }
2635 
2636   FastUnlockNode *funlock = new FastUnlockNode( ctrl, obj, box );
2637   funlock = transform_later( funlock )-&gt;as_FastUnlock();
2638   // Optimize test; set region slot 2
2639   Node *slow_path = opt_bits_test(ctrl, region, 2, funlock, 0, 0);
2640   Node *thread = transform_later(new ThreadLocalNode());
2641 
2642   CallNode *call = make_slow_call((CallNode *) unlock, OptoRuntime::complete_monitor_exit_Type(),
2643                                   CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C),
2644                                   &quot;complete_monitor_unlocking_C&quot;, slow_path, obj, box, thread);
2645 
2646   extract_call_projections(call);
2647 
2648   assert ( _ioproj_fallthrough == NULL &amp;&amp; _ioproj_catchall == NULL &amp;&amp;
2649            _memproj_catchall == NULL &amp;&amp; _catchallcatchproj == NULL, &quot;Unexpected projection from Lock&quot;);
2650 
2651   // No exceptions for unlocking
2652   // Capture slow path
2653   // disconnect fall-through projection from call and create a new one
2654   // hook up users of fall-through projection to region
2655   Node *slow_ctrl = _fallthroughproj-&gt;clone();
2656   transform_later(slow_ctrl);
2657   _igvn.hash_delete(_fallthroughproj);
2658   _fallthroughproj-&gt;disconnect_inputs(NULL, C);
2659   region-&gt;init_req(1, slow_ctrl);
2660   // region inputs are now complete
2661   transform_later(region);
2662   _igvn.replace_node(_fallthroughproj, region);
2663 
2664   Node *memproj = transform_later(new ProjNode(call, TypeFunc::Memory) );
2665   mem_phi-&gt;init_req(1, memproj );
2666   mem_phi-&gt;init_req(2, mem);
2667   transform_later(mem_phi);
2668   _igvn.replace_node(_memproj_fallthrough, mem_phi);
2669 }
2670 
2671 // A value type might be returned from the call but we don&#39;t know its
2672 // type. Either we get a buffered value (and nothing needs to be done)
2673 // or one of the values being returned is the klass of the value type
2674 // and we need to allocate a value type instance of that type and
2675 // initialize it with other values being returned. In that case, we
2676 // first try a fast path allocation and initialize the value with the
2677 // value klass&#39;s pack handler or we fall back to a runtime call.
2678 void PhaseMacroExpand::expand_mh_intrinsic_return(CallStaticJavaNode* call) {
2679   assert(call-&gt;method()-&gt;is_method_handle_intrinsic(), &quot;must be a method handle intrinsic call&quot;);
2680   Node* ret = call-&gt;proj_out_or_null(TypeFunc::Parms);
2681   if (ret == NULL) {
2682     return;
2683   }
2684   const TypeFunc* tf = call-&gt;_tf;
2685   const TypeTuple* domain = OptoRuntime::store_value_type_fields_Type()-&gt;domain_cc();
2686   const TypeFunc* new_tf = TypeFunc::make(tf-&gt;domain_sig(), tf-&gt;domain_cc(), tf-&gt;range_sig(), domain);
2687   call-&gt;_tf = new_tf;
2688   // Make sure the change of type is applied before projections are processed by igvn
2689   _igvn.set_type(call, call-&gt;Value(&amp;_igvn));
2690   _igvn.set_type(ret, ret-&gt;Value(&amp;_igvn));
2691 
2692   // Before any new projection is added:
2693   CallProjections* projs = call-&gt;extract_projections(true, true);
2694 
2695   Node* ctl = new Node(1);
2696   Node* mem = new Node(1);
2697   Node* io = new Node(1);
2698   Node* ex_ctl = new Node(1);
2699   Node* ex_mem = new Node(1);
2700   Node* ex_io = new Node(1);
2701   Node* res = new Node(1);
2702 
2703   Node* cast = transform_later(new CastP2XNode(ctl, res));
2704   Node* mask = MakeConX(0x1);
2705   Node* masked = transform_later(new AndXNode(cast, mask));
2706   Node* cmp = transform_later(new CmpXNode(masked, mask));
2707   Node* bol = transform_later(new BoolNode(cmp, BoolTest::eq));
2708   IfNode* allocation_iff = new IfNode(ctl, bol, PROB_MAX, COUNT_UNKNOWN);
2709   transform_later(allocation_iff);
2710   Node* allocation_ctl = transform_later(new IfTrueNode(allocation_iff));
2711   Node* no_allocation_ctl = transform_later(new IfFalseNode(allocation_iff));
2712 
2713   Node* no_allocation_res = transform_later(new CheckCastPPNode(no_allocation_ctl, res, TypeInstPtr::BOTTOM));
2714 
2715   Node* mask2 = MakeConX(-2);
2716   Node* masked2 = transform_later(new AndXNode(cast, mask2));
2717   Node* rawklassptr = transform_later(new CastX2PNode(masked2));
2718   Node* klass_node = transform_later(new CheckCastPPNode(allocation_ctl, rawklassptr, TypeKlassPtr::OBJECT_OR_NULL));
2719 
2720   Node* slowpath_bol = NULL;
2721   Node* top_adr = NULL;
2722   Node* old_top = NULL;
2723   Node* new_top = NULL;
2724   if (UseTLAB) {
2725     Node* end_adr = NULL;
2726     set_eden_pointers(top_adr, end_adr);
2727     Node* end = make_load(ctl, mem, end_adr, 0, TypeRawPtr::BOTTOM, T_ADDRESS);
2728     old_top = new LoadPNode(ctl, mem, top_adr, TypeRawPtr::BOTTOM, TypeRawPtr::BOTTOM, MemNode::unordered);
2729     transform_later(old_top);
2730     Node* layout_val = make_load(NULL, mem, klass_node, in_bytes(Klass::layout_helper_offset()), TypeInt::INT, T_INT);
2731     Node* size_in_bytes = ConvI2X(layout_val);
2732     new_top = new AddPNode(top(), old_top, size_in_bytes);
2733     transform_later(new_top);
2734     Node* slowpath_cmp = new CmpPNode(new_top, end);
2735     transform_later(slowpath_cmp);
2736     slowpath_bol = new BoolNode(slowpath_cmp, BoolTest::ge);
2737     transform_later(slowpath_bol);
2738   } else {
2739     slowpath_bol = intcon(1);
2740     top_adr = top();
2741     old_top = top();
2742     new_top = top();
2743   }
2744   IfNode* slowpath_iff = new IfNode(allocation_ctl, slowpath_bol, PROB_UNLIKELY_MAG(4), COUNT_UNKNOWN);
2745   transform_later(slowpath_iff);
2746 
2747   Node* slowpath_true = new IfTrueNode(slowpath_iff);
2748   transform_later(slowpath_true);
2749 
2750   CallStaticJavaNode* slow_call = new CallStaticJavaNode(OptoRuntime::store_value_type_fields_Type(),
2751                                                          StubRoutines::store_value_type_fields_to_buf(),
2752                                                          &quot;store_value_type_fields&quot;,
2753                                                          call-&gt;jvms()-&gt;bci(),
2754                                                          TypePtr::BOTTOM);
2755   slow_call-&gt;init_req(TypeFunc::Control, slowpath_true);
2756   slow_call-&gt;init_req(TypeFunc::Memory, mem);
2757   slow_call-&gt;init_req(TypeFunc::I_O, io);
2758   slow_call-&gt;init_req(TypeFunc::FramePtr, call-&gt;in(TypeFunc::FramePtr));
2759   slow_call-&gt;init_req(TypeFunc::ReturnAdr, call-&gt;in(TypeFunc::ReturnAdr));
2760   slow_call-&gt;init_req(TypeFunc::Parms, res);
2761 
2762   Node* slow_ctl = transform_later(new ProjNode(slow_call, TypeFunc::Control));
2763   Node* slow_mem = transform_later(new ProjNode(slow_call, TypeFunc::Memory));
2764   Node* slow_io = transform_later(new ProjNode(slow_call, TypeFunc::I_O));
2765   Node* slow_res = transform_later(new ProjNode(slow_call, TypeFunc::Parms));
2766   Node* slow_catc = transform_later(new CatchNode(slow_ctl, slow_io, 2));
2767   Node* slow_norm = transform_later(new CatchProjNode(slow_catc, CatchProjNode::fall_through_index, CatchProjNode::no_handler_bci));
2768   Node* slow_excp = transform_later(new CatchProjNode(slow_catc, CatchProjNode::catch_all_index,    CatchProjNode::no_handler_bci));
2769 
2770   Node* ex_r = new RegionNode(3);
2771   Node* ex_mem_phi = new PhiNode(ex_r, Type::MEMORY, TypePtr::BOTTOM);
2772   Node* ex_io_phi = new PhiNode(ex_r, Type::ABIO);
2773   ex_r-&gt;init_req(1, slow_excp);
2774   ex_mem_phi-&gt;init_req(1, slow_mem);
2775   ex_io_phi-&gt;init_req(1, slow_io);
2776   ex_r-&gt;init_req(2, ex_ctl);
2777   ex_mem_phi-&gt;init_req(2, ex_mem);
2778   ex_io_phi-&gt;init_req(2, ex_io);
2779 
2780   transform_later(ex_r);
2781   transform_later(ex_mem_phi);
2782   transform_later(ex_io_phi);
2783 
2784   Node* slowpath_false = new IfFalseNode(slowpath_iff);
2785   transform_later(slowpath_false);
2786   Node* rawmem = new StorePNode(slowpath_false, mem, top_adr, TypeRawPtr::BOTTOM, new_top, MemNode::unordered);
2787   transform_later(rawmem);
2788   Node* mark_node = makecon(TypeRawPtr::make((address)markWord::always_locked_prototype().value()));
2789   rawmem = make_store(slowpath_false, rawmem, old_top, oopDesc::mark_offset_in_bytes(), mark_node, T_ADDRESS);
2790   rawmem = make_store(slowpath_false, rawmem, old_top, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);
2791   if (UseCompressedClassPointers) {
2792     rawmem = make_store(slowpath_false, rawmem, old_top, oopDesc::klass_gap_offset_in_bytes(), intcon(0), T_INT);
2793   }
2794   Node* fixed_block  = make_load(slowpath_false, rawmem, klass_node, in_bytes(InstanceKlass::adr_valueklass_fixed_block_offset()), TypeRawPtr::BOTTOM, T_ADDRESS);
2795   Node* pack_handler = make_load(slowpath_false, rawmem, fixed_block, in_bytes(ValueKlass::pack_handler_offset()), TypeRawPtr::BOTTOM, T_ADDRESS);
2796 
2797   CallLeafNoFPNode* handler_call = new CallLeafNoFPNode(OptoRuntime::pack_value_type_Type(),
2798                                                         NULL,
2799                                                         &quot;pack handler&quot;,
2800                                                         TypeRawPtr::BOTTOM);
2801   handler_call-&gt;init_req(TypeFunc::Control, slowpath_false);
2802   handler_call-&gt;init_req(TypeFunc::Memory, rawmem);
2803   handler_call-&gt;init_req(TypeFunc::I_O, top());
2804   handler_call-&gt;init_req(TypeFunc::FramePtr, call-&gt;in(TypeFunc::FramePtr));
2805   handler_call-&gt;init_req(TypeFunc::ReturnAdr, top());
2806   handler_call-&gt;init_req(TypeFunc::Parms, pack_handler);
2807   handler_call-&gt;init_req(TypeFunc::Parms+1, old_top);
2808 
2809   // We don&#39;t know how many values are returned. This assumes the
2810   // worst case, that all available registers are used.
2811   for (uint i = TypeFunc::Parms+1; i &lt; domain-&gt;cnt(); i++) {
2812     if (domain-&gt;field_at(i) == Type::HALF) {
2813       slow_call-&gt;init_req(i, top());
2814       handler_call-&gt;init_req(i+1, top());
2815       continue;
2816     }
2817     Node* proj = transform_later(new ProjNode(call, i));
2818     slow_call-&gt;init_req(i, proj);
2819     handler_call-&gt;init_req(i+1, proj);
2820   }
2821 
2822   // We can safepoint at that new call
2823   slow_call-&gt;copy_call_debug_info(&amp;_igvn, call);
2824   transform_later(slow_call);
2825   transform_later(handler_call);
2826 
2827   Node* handler_ctl = transform_later(new ProjNode(handler_call, TypeFunc::Control));
2828   rawmem = transform_later(new ProjNode(handler_call, TypeFunc::Memory));
2829   Node* slowpath_false_res = transform_later(new ProjNode(handler_call, TypeFunc::Parms));
2830 
2831   MergeMemNode* slowpath_false_mem = MergeMemNode::make(mem);
2832   slowpath_false_mem-&gt;set_memory_at(Compile::AliasIdxRaw, rawmem);
2833   transform_later(slowpath_false_mem);
2834 
2835   Node* r = new RegionNode(4);
2836   Node* mem_phi = new PhiNode(r, Type::MEMORY, TypePtr::BOTTOM);
2837   Node* io_phi = new PhiNode(r, Type::ABIO);
2838   Node* res_phi = new PhiNode(r, TypeInstPtr::BOTTOM);
2839 
2840   r-&gt;init_req(1, no_allocation_ctl);
2841   mem_phi-&gt;init_req(1, mem);
2842   io_phi-&gt;init_req(1, io);
2843   res_phi-&gt;init_req(1, no_allocation_res);
2844   r-&gt;init_req(2, slow_norm);
2845   mem_phi-&gt;init_req(2, slow_mem);
2846   io_phi-&gt;init_req(2, slow_io);
2847   res_phi-&gt;init_req(2, slow_res);
2848   r-&gt;init_req(3, handler_ctl);
2849   mem_phi-&gt;init_req(3, slowpath_false_mem);
2850   io_phi-&gt;init_req(3, io);
2851   res_phi-&gt;init_req(3, slowpath_false_res);
2852 
2853   transform_later(r);
2854   transform_later(mem_phi);
2855   transform_later(io_phi);
2856   transform_later(res_phi);
2857 
2858   assert(projs-&gt;nb_resproj == 1, &quot;unexpected number of results&quot;);
2859   _igvn.replace_in_uses(projs-&gt;fallthrough_catchproj, r);
2860   _igvn.replace_in_uses(projs-&gt;fallthrough_memproj, mem_phi);
2861   _igvn.replace_in_uses(projs-&gt;fallthrough_ioproj, io_phi);
2862   _igvn.replace_in_uses(projs-&gt;resproj[0], res_phi);
2863   _igvn.replace_in_uses(projs-&gt;catchall_catchproj, ex_r);
2864   _igvn.replace_in_uses(projs-&gt;catchall_memproj, ex_mem_phi);
2865   _igvn.replace_in_uses(projs-&gt;catchall_ioproj, ex_io_phi);
2866 
2867   _igvn.replace_node(ctl, projs-&gt;fallthrough_catchproj);
2868   _igvn.replace_node(mem, projs-&gt;fallthrough_memproj);
2869   _igvn.replace_node(io, projs-&gt;fallthrough_ioproj);
2870   _igvn.replace_node(res, projs-&gt;resproj[0]);
2871   _igvn.replace_node(ex_ctl, projs-&gt;catchall_catchproj);
2872   _igvn.replace_node(ex_mem, projs-&gt;catchall_memproj);
2873   _igvn.replace_node(ex_io, projs-&gt;catchall_ioproj);
2874  }
2875 
2876 void PhaseMacroExpand::expand_subtypecheck_node(SubTypeCheckNode *check) {
2877   assert(check-&gt;in(SubTypeCheckNode::Control) == NULL, &quot;should be pinned&quot;);
2878   Node* bol = check-&gt;unique_out();
2879   Node* obj_or_subklass = check-&gt;in(SubTypeCheckNode::ObjOrSubKlass);
2880   Node* superklass = check-&gt;in(SubTypeCheckNode::SuperKlass);
2881   assert(bol-&gt;is_Bool() &amp;&amp; bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne, &quot;unexpected bool node&quot;);
2882 
2883   for (DUIterator_Last imin, i = bol-&gt;last_outs(imin); i &gt;= imin; --i) {
2884     Node* iff = bol-&gt;last_out(i);
2885     assert(iff-&gt;is_If(), &quot;where&#39;s the if?&quot;);
2886 
2887     if (iff-&gt;in(0)-&gt;is_top()) {
2888       _igvn.replace_input_of(iff, 1, C-&gt;top());
2889       continue;
2890     }
2891 
2892     Node* iftrue = iff-&gt;as_If()-&gt;proj_out(1);
2893     Node* iffalse = iff-&gt;as_If()-&gt;proj_out(0);
2894     Node* ctrl = iff-&gt;in(0);
2895 
2896     Node* subklass = NULL;
2897     if (_igvn.type(obj_or_subklass)-&gt;isa_klassptr()) {
2898       subklass = obj_or_subklass;
2899     } else {
2900       Node* k_adr = basic_plus_adr(obj_or_subklass, oopDesc::klass_offset_in_bytes());
2901       subklass = _igvn.transform(LoadKlassNode::make(_igvn, NULL, C-&gt;immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT, true));
2902     }
2903 
2904     Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &amp;ctrl, NULL, _igvn);
2905 
2906     _igvn.replace_input_of(iff, 0, C-&gt;top());
2907     _igvn.replace_node(iftrue, not_subtype_ctrl);
2908     _igvn.replace_node(iffalse, ctrl);
2909   }
2910   _igvn.replace_node(check, C-&gt;top());
2911 }
2912 
2913 //---------------------------eliminate_macro_nodes----------------------
2914 // Eliminate scalar replaced allocations and associated locks.
2915 void PhaseMacroExpand::eliminate_macro_nodes() {
2916   if (C-&gt;macro_count() == 0)
2917     return;
2918 
2919   // First, attempt to eliminate locks
2920   int cnt = C-&gt;macro_count();
2921   for (int i=0; i &lt; cnt; i++) {
2922     Node *n = C-&gt;macro_node(i);
2923     if (n-&gt;is_AbstractLock()) { // Lock and Unlock nodes
2924       // Before elimination mark all associated (same box and obj)
2925       // lock and unlock nodes.
2926       mark_eliminated_locking_nodes(n-&gt;as_AbstractLock());
2927     }
2928   }
2929   bool progress = true;
2930   while (progress) {
2931     progress = false;
2932     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2933       Node * n = C-&gt;macro_node(i-1);
2934       bool success = false;
2935       debug_only(int old_macro_count = C-&gt;macro_count(););
2936       if (n-&gt;is_AbstractLock()) {
2937         success = eliminate_locking_node(n-&gt;as_AbstractLock());
2938       }
2939       assert(success == (C-&gt;macro_count() &lt; old_macro_count), &quot;elimination reduces macro count&quot;);
2940       progress = progress || success;
2941     }
2942   }
2943   // Next, attempt to eliminate allocations
2944   _has_locks = false;
2945   progress = true;
2946   while (progress) {
2947     progress = false;
2948     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2949       Node * n = C-&gt;macro_node(i-1);
2950       bool success = false;
2951       debug_only(int old_macro_count = C-&gt;macro_count(););
2952       switch (n-&gt;class_id()) {
2953       case Node::Class_Allocate:
2954       case Node::Class_AllocateArray:
2955         success = eliminate_allocate_node(n-&gt;as_Allocate());
2956         break;
2957       case Node::Class_CallStaticJava: {
2958         CallStaticJavaNode* call = n-&gt;as_CallStaticJava();
2959         if (!call-&gt;method()-&gt;is_method_handle_intrinsic()) {
2960           success = eliminate_boxing_node(n-&gt;as_CallStaticJava());
2961         }
2962         break;
2963       }
2964       case Node::Class_Lock:
2965       case Node::Class_Unlock:
2966         assert(!n-&gt;as_AbstractLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2967         _has_locks = true;
2968         break;
2969       case Node::Class_ArrayCopy:
2970         break;
2971       case Node::Class_OuterStripMinedLoop:
2972         break;
2973       case Node::Class_SubTypeCheck:
2974         break;
2975       default:
2976         assert(n-&gt;Opcode() == Op_LoopLimit ||
2977                n-&gt;Opcode() == Op_Opaque1   ||
2978                n-&gt;Opcode() == Op_Opaque2   ||
2979                n-&gt;Opcode() == Op_Opaque3   ||
2980                BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(n),
2981                &quot;unknown node type in macro list&quot;);
2982       }
2983       assert(success == (C-&gt;macro_count() &lt; old_macro_count), &quot;elimination reduces macro count&quot;);
2984       progress = progress || success;
2985     }
2986   }
2987 }
2988 
2989 //------------------------------expand_macro_nodes----------------------
2990 //  Returns true if a failure occurred.
2991 bool PhaseMacroExpand::expand_macro_nodes() {
2992   // Last attempt to eliminate macro nodes.
2993   eliminate_macro_nodes();
2994 
2995   // Make sure expansion will not cause node limit to be exceeded.
2996   // Worst case is a macro node gets expanded into about 200 nodes.
2997   // Allow 50% more for optimization.
2998   if (C-&gt;check_node_count(C-&gt;macro_count() * 300, &quot;out of nodes before macro expansion&quot; ) )
2999     return true;
3000 
3001   // Eliminate Opaque and LoopLimit nodes. Do it after all loop optimizations.
3002   bool progress = true;
3003   while (progress) {
3004     progress = false;
3005     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
3006       Node* n = C-&gt;macro_node(i-1);
3007       bool success = false;
3008       debug_only(int old_macro_count = C-&gt;macro_count(););
3009       if (n-&gt;Opcode() == Op_LoopLimit) {
3010         // Remove it from macro list and put on IGVN worklist to optimize.
3011         C-&gt;remove_macro_node(n);
3012         _igvn._worklist.push(n);
3013         success = true;
3014       } else if (n-&gt;Opcode() == Op_CallStaticJava) {
3015         CallStaticJavaNode* call = n-&gt;as_CallStaticJava();
3016         if (!call-&gt;method()-&gt;is_method_handle_intrinsic()) {
3017           // Remove it from macro list and put on IGVN worklist to optimize.
3018           C-&gt;remove_macro_node(n);
3019           _igvn._worklist.push(n);
3020           success = true;
3021         }
3022       } else if (n-&gt;Opcode() == Op_Opaque1 || n-&gt;Opcode() == Op_Opaque2) {
3023         _igvn.replace_node(n, n-&gt;in(1));
3024         success = true;
3025 #if INCLUDE_RTM_OPT
3026       } else if ((n-&gt;Opcode() == Op_Opaque3) &amp;&amp; ((Opaque3Node*)n)-&gt;rtm_opt()) {
3027         assert(C-&gt;profile_rtm(), &quot;should be used only in rtm deoptimization code&quot;);
3028         assert((n-&gt;outcnt() == 1) &amp;&amp; n-&gt;unique_out()-&gt;is_Cmp(), &quot;&quot;);
3029         Node* cmp = n-&gt;unique_out();
3030 #ifdef ASSERT
3031         // Validate graph.
3032         assert((cmp-&gt;outcnt() == 1) &amp;&amp; cmp-&gt;unique_out()-&gt;is_Bool(), &quot;&quot;);
3033         BoolNode* bol = cmp-&gt;unique_out()-&gt;as_Bool();
3034         assert((bol-&gt;outcnt() == 1) &amp;&amp; bol-&gt;unique_out()-&gt;is_If() &amp;&amp;
3035                (bol-&gt;_test._test == BoolTest::ne), &quot;&quot;);
3036         IfNode* ifn = bol-&gt;unique_out()-&gt;as_If();
3037         assert((ifn-&gt;outcnt() == 2) &amp;&amp;
3038                ifn-&gt;proj_out(1)-&gt;is_uncommon_trap_proj(Deoptimization::Reason_rtm_state_change) != NULL, &quot;&quot;);
3039 #endif
3040         Node* repl = n-&gt;in(1);
3041         if (!_has_locks) {
3042           // Remove RTM state check if there are no locks in the code.
3043           // Replace input to compare the same value.
3044           repl = (cmp-&gt;in(1) == n) ? cmp-&gt;in(2) : cmp-&gt;in(1);
3045         }
3046         _igvn.replace_node(n, repl);
3047         success = true;
3048 #endif
3049       } else if (n-&gt;Opcode() == Op_OuterStripMinedLoop) {
3050         n-&gt;as_OuterStripMinedLoop()-&gt;adjust_strip_mined_loop(&amp;_igvn);
3051         C-&gt;remove_macro_node(n);
3052         success = true;
3053       }
3054       assert(!success || (C-&gt;macro_count() == (old_macro_count - 1)), &quot;elimination must have deleted one node from macro list&quot;);
3055       progress = progress || success;
3056     }
3057   }
3058 
3059   // expand arraycopy &quot;macro&quot; nodes first
3060   // For ReduceBulkZeroing, we must first process all arraycopy nodes
3061   // before the allocate nodes are expanded.
3062   for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
3063     Node* n = C-&gt;macro_node(i-1);
3064     assert(n-&gt;is_macro(), &quot;only macro nodes expected here&quot;);
3065     if (_igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
3066       // node is unreachable, so don&#39;t try to expand it
3067       C-&gt;remove_macro_node(n);
3068       continue;
3069     }
3070     debug_only(int old_macro_count = C-&gt;macro_count(););
3071     switch (n-&gt;class_id()) {
3072     case Node::Class_Lock:
3073       expand_lock_node(n-&gt;as_Lock());
3074       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3075       break;
3076     case Node::Class_Unlock:
3077       expand_unlock_node(n-&gt;as_Unlock());
3078       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3079       break;
3080     case Node::Class_ArrayCopy:
3081       expand_arraycopy_node(n-&gt;as_ArrayCopy());
3082       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3083       break;
3084     case Node::Class_SubTypeCheck:
3085       expand_subtypecheck_node(n-&gt;as_SubTypeCheck());
3086       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3087       break;
3088     }
3089     if (C-&gt;failing())  return true;
3090   }
3091 
3092   // All nodes except Allocate nodes are expanded now. There could be
3093   // new optimization opportunities (such as folding newly created
3094   // load from a just allocated object). Run IGVN.
3095   _igvn.set_delay_transform(false);
3096   _igvn.optimize();
3097   if (C-&gt;failing())  return true;
3098 
3099   _igvn.set_delay_transform(true);
3100 
3101   // expand &quot;macro&quot; nodes
3102   // nodes are removed from the macro list as they are processed
3103   while (C-&gt;macro_count() &gt; 0) {
3104     int macro_count = C-&gt;macro_count();
3105     Node * n = C-&gt;macro_node(macro_count-1);
3106     assert(n-&gt;is_macro(), &quot;only macro nodes expected here&quot;);
3107     if (_igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
3108       // node is unreachable, so don&#39;t try to expand it
3109       C-&gt;remove_macro_node(n);
3110       continue;
3111     }
3112     switch (n-&gt;class_id()) {
3113     case Node::Class_Allocate:
3114       expand_allocate(n-&gt;as_Allocate());
3115       break;
3116     case Node::Class_AllocateArray:
3117       expand_allocate_array(n-&gt;as_AllocateArray());
3118       break;
3119     case Node::Class_CallStaticJava:
3120       expand_mh_intrinsic_return(n-&gt;as_CallStaticJava());
3121       C-&gt;remove_macro_node(n);
3122       break;
3123     default:
3124       assert(false, &quot;unknown node type in macro list&quot;);
3125     }
3126     assert(C-&gt;macro_count() &lt; macro_count, &quot;must have deleted a node from macro list&quot;);
3127     if (C-&gt;failing())  return true;
3128   }
3129 
3130   _igvn.set_delay_transform(false);
3131   _igvn.optimize();
3132   if (C-&gt;failing())  return true;
3133   return false;
3134 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
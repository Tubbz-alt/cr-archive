<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/macro.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macro.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="phaseX.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/macro.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
182   Node* generate_generic_arraycopy(Node** ctrl, MergeMemNode** mem,
183                                    const TypePtr* adr_type,
184                                    Node* src,  Node* src_offset,
185                                    Node* dest, Node* dest_offset,
186                                    Node* copy_length, bool dest_uninitialized);
187   void generate_unchecked_arraycopy(Node** ctrl, MergeMemNode** mem,
188                                     const TypePtr* adr_type,
189                                     BasicType basic_elem_type,
190                                     bool disjoint_bases,
191                                     Node* src,  Node* src_offset,
192                                     Node* dest, Node* dest_offset,
193                                     Node* copy_length, bool dest_uninitialized);
194   const TypePtr* adjust_parameters_for_vt(const TypeAryPtr* top_dest, Node*&amp; src_offset,
195                                           Node*&amp; dest_offset, Node*&amp; length, BasicType&amp; dest_elem,
196                                           Node*&amp; dest_length);
197   void expand_arraycopy_node(ArrayCopyNode *ac);
198 
199   void expand_subtypecheck_node(SubTypeCheckNode *check);
200 
201   int replace_input(Node *use, Node *oldref, Node *newref);
<span class="line-removed">202   void migrate_outs(Node *old, Node *target);</span>
203   Node* opt_bits_test(Node* ctrl, Node* region, int edge, Node* word, int mask, int bits, bool return_fast_path = false);
204   void copy_predefined_input_for_runtime_call(Node * ctrl, CallNode* oldcall, CallNode* call);
205   CallNode* make_slow_call(CallNode *oldcall, const TypeFunc* slow_call_type, address slow_call,
206                            const char* leaf_name, Node* slow_path, Node* parm0, Node* parm1,
207                            Node* parm2);
208   void extract_call_projections(CallNode *call);
209 
210   Node* initialize_object(AllocateNode* alloc,
211                           Node* control, Node* rawmem, Node* object,
212                           Node* klass_node, Node* length,
213                           Node* size_in_bytes);
214 
215   Node* make_arraycopy_load(ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc);
216 
217   bool can_try_zeroing_elimination(AllocateArrayNode* alloc, Node* src, Node* dest) const;
218 
219 public:
220   PhaseMacroExpand(PhaseIterGVN &amp;igvn) : Phase(Macro_Expand), _igvn(igvn), _has_locks(false) {
221     _igvn.set_delay_transform(true);
222   }
</pre>
</td>
<td>
<hr />
<pre>
182   Node* generate_generic_arraycopy(Node** ctrl, MergeMemNode** mem,
183                                    const TypePtr* adr_type,
184                                    Node* src,  Node* src_offset,
185                                    Node* dest, Node* dest_offset,
186                                    Node* copy_length, bool dest_uninitialized);
187   void generate_unchecked_arraycopy(Node** ctrl, MergeMemNode** mem,
188                                     const TypePtr* adr_type,
189                                     BasicType basic_elem_type,
190                                     bool disjoint_bases,
191                                     Node* src,  Node* src_offset,
192                                     Node* dest, Node* dest_offset,
193                                     Node* copy_length, bool dest_uninitialized);
194   const TypePtr* adjust_parameters_for_vt(const TypeAryPtr* top_dest, Node*&amp; src_offset,
195                                           Node*&amp; dest_offset, Node*&amp; length, BasicType&amp; dest_elem,
196                                           Node*&amp; dest_length);
197   void expand_arraycopy_node(ArrayCopyNode *ac);
198 
199   void expand_subtypecheck_node(SubTypeCheckNode *check);
200 
201   int replace_input(Node *use, Node *oldref, Node *newref);

202   Node* opt_bits_test(Node* ctrl, Node* region, int edge, Node* word, int mask, int bits, bool return_fast_path = false);
203   void copy_predefined_input_for_runtime_call(Node * ctrl, CallNode* oldcall, CallNode* call);
204   CallNode* make_slow_call(CallNode *oldcall, const TypeFunc* slow_call_type, address slow_call,
205                            const char* leaf_name, Node* slow_path, Node* parm0, Node* parm1,
206                            Node* parm2);
207   void extract_call_projections(CallNode *call);
208 
209   Node* initialize_object(AllocateNode* alloc,
210                           Node* control, Node* rawmem, Node* object,
211                           Node* klass_node, Node* length,
212                           Node* size_in_bytes);
213 
214   Node* make_arraycopy_load(ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc);
215 
216   bool can_try_zeroing_elimination(AllocateArrayNode* alloc, Node* src, Node* dest) const;
217 
218 public:
219   PhaseMacroExpand(PhaseIterGVN &amp;igvn) : Phase(Macro_Expand), _igvn(igvn), _has_locks(false) {
220     _igvn.set_delay_transform(true);
221   }
</pre>
</td>
</tr>
</table>
<center><a href="macro.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="phaseX.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
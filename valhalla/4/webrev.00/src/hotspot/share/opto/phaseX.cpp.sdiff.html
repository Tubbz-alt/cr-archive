<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/phaseX.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macro.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/hotspot/share/opto/phaseX.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1479   }
1480 
1481   // Smash all inputs to &#39;old&#39;, isolating him completely
1482   Node *temp = new Node(1);
1483   temp-&gt;init_req(0,nn);     // Add a use to nn to prevent him from dying
1484   remove_dead_node( old );
1485   temp-&gt;del_req(0);         // Yank bogus edge
1486 #ifndef PRODUCT
1487   if( VerifyIterativeGVN ) {
1488     for ( int i = 0; i &lt; _verify_window_size; i++ ) {
1489       if ( _verify_window[i] == old )
1490         _verify_window[i] = nn;
1491     }
1492   }
1493 #endif
1494   _worklist.remove(temp);   // this can be necessary
1495   temp-&gt;destruct();         // reuse the _idx of this little guy
1496 }
1497 
1498 void PhaseIterGVN::replace_in_uses(Node* n, Node* m) {

1499   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1500     Node* u = n-&gt;fast_out(i);
1501     if (u != n) {
1502       rehash_node_delayed(u);
1503       int nb = u-&gt;replace_edge(n, m);
1504       --i, imax -= nb;
1505     }
1506   }

1507 }
1508 
1509 //------------------------------add_users_to_worklist--------------------------
1510 void PhaseIterGVN::add_users_to_worklist0( Node *n ) {
1511   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1512     _worklist.push(n-&gt;fast_out(i));  // Push on worklist
1513   }
1514 }
1515 
1516 // Return counted loop Phi if as a counted loop exit condition, cmp
1517 // compares the the induction variable with n
1518 static PhiNode* countedloop_phi_from_cmp(CmpINode* cmp, Node* n) {
1519   for (DUIterator_Fast imax, i = cmp-&gt;fast_outs(imax); i &lt; imax; i++) {
1520     Node* bol = cmp-&gt;fast_out(i);
1521     for (DUIterator_Fast i2max, i2 = bol-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1522       Node* iff = bol-&gt;fast_out(i2);
1523       if (iff-&gt;is_CountedLoopEnd()) {
1524         CountedLoopEndNode* cle = iff-&gt;as_CountedLoopEnd();
1525         if (cle-&gt;limit() == n) {
1526           PhiNode* phi = cle-&gt;phi();
</pre>
</td>
<td>
<hr />
<pre>
1479   }
1480 
1481   // Smash all inputs to &#39;old&#39;, isolating him completely
1482   Node *temp = new Node(1);
1483   temp-&gt;init_req(0,nn);     // Add a use to nn to prevent him from dying
1484   remove_dead_node( old );
1485   temp-&gt;del_req(0);         // Yank bogus edge
1486 #ifndef PRODUCT
1487   if( VerifyIterativeGVN ) {
1488     for ( int i = 0; i &lt; _verify_window_size; i++ ) {
1489       if ( _verify_window[i] == old )
1490         _verify_window[i] = nn;
1491     }
1492   }
1493 #endif
1494   _worklist.remove(temp);   // this can be necessary
1495   temp-&gt;destruct();         // reuse the _idx of this little guy
1496 }
1497 
1498 void PhaseIterGVN::replace_in_uses(Node* n, Node* m) {
<span class="line-added">1499   assert(n != NULL, &quot;sanity&quot;);</span>
1500   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1501     Node* u = n-&gt;fast_out(i);
1502     if (u != n) {
1503       rehash_node_delayed(u);
1504       int nb = u-&gt;replace_edge(n, m);
1505       --i, imax -= nb;
1506     }
1507   }
<span class="line-added">1508   assert(n-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);</span>
1509 }
1510 
1511 //------------------------------add_users_to_worklist--------------------------
1512 void PhaseIterGVN::add_users_to_worklist0( Node *n ) {
1513   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1514     _worklist.push(n-&gt;fast_out(i));  // Push on worklist
1515   }
1516 }
1517 
1518 // Return counted loop Phi if as a counted loop exit condition, cmp
1519 // compares the the induction variable with n
1520 static PhiNode* countedloop_phi_from_cmp(CmpINode* cmp, Node* n) {
1521   for (DUIterator_Fast imax, i = cmp-&gt;fast_outs(imax); i &lt; imax; i++) {
1522     Node* bol = cmp-&gt;fast_out(i);
1523     for (DUIterator_Fast i2max, i2 = bol-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1524       Node* iff = bol-&gt;fast_out(i2);
1525       if (iff-&gt;is_CountedLoopEnd()) {
1526         CountedLoopEndNode* cle = iff-&gt;as_CountedLoopEnd();
1527         if (cle-&gt;limit() == n) {
1528           PhiNode* phi = cle-&gt;phi();
</pre>
</td>
</tr>
</table>
<center><a href="macro.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
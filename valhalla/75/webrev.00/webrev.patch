diff a/src/hotspot/share/c1/c1_GraphBuilder.cpp b/src/hotspot/share/c1/c1_GraphBuilder.cpp
--- a/src/hotspot/share/c1/c1_GraphBuilder.cpp
+++ b/src/hotspot/share/c1/c1_GraphBuilder.cpp
@@ -1812,11 +1812,16 @@
       if (field->is_constant() && !field->is_flattened() && obj_type->is_constant() && !PatchALot) {
         ciObject* const_oop = obj_type->constant_value();
         if (!const_oop->is_null_object() && const_oop->is_loaded()) {
           ciConstant field_value = field->constant_value_of(const_oop);
           if (field_value.is_valid()) {
-            constant = make_constant(field_value, field);
+            if (field->is_flattenable() && field_value.is_null_or_zero()) {
+              // Non-flattened but flattenable inline type field. Replace null by the default value.
+              constant = new Constant(new InstanceConstant(field->type()->as_value_klass()->default_value_instance()));
+            } else {
+              constant = make_constant(field_value, field);
+            }
             // For CallSite objects add a dependency for invalidation of the optimization.
             if (field->is_call_site_target()) {
               ciCallSite* call_site = const_oop->as_call_site();
               if (!call_site->is_fully_initialized_constant_call_site()) {
                 ciMethodHandle* target = field_value.as_object()->as_method_handle();
diff a/src/hotspot/share/ci/ciField.cpp b/src/hotspot/share/ci/ciField.cpp
--- a/src/hotspot/share/ci/ciField.cpp
+++ b/src/hotspot/share/ci/ciField.cpp
@@ -227,11 +227,12 @@
   _offset = offset;
   // Copy remaining fields
   _name = field->_name;
   _signature = field->_signature;
   _type = field->_type;
-  _is_constant = field->_is_constant;
+  // Trust final flattened fields
+  _is_constant = is_final;
   _known_to_link_with_put = field->_known_to_link_with_put;
   _known_to_link_with_get = field->_known_to_link_with_get;
   _constant_value = field->_constant_value;
   assert(!field->is_flattened(), "field must not be flattened");
   _is_flattened = false;
@@ -252,10 +253,13 @@
   // Trust hidden classes and VM unsafe anonymous classes. They are created via
   // Lookup.defineHiddenClass or the private jdk.internal.misc.Unsafe API and
   // can't be serialized, so there is no hacking of finals going on with them.
   if (holder->is_hidden() || holder->is_unsafe_anonymous())
     return true;
+  // Trust final fields in inline type buffers
+  if (holder->is_valuetype())
+    return true;
   // Trust final fields in all boxed classes
   if (holder->is_box_klass())
     return true;
   // Trust final fields in String
   if (holder->name() == ciSymbol::java_lang_String())
diff a/src/hotspot/share/opto/graphKit.cpp b/src/hotspot/share/opto/graphKit.cpp
--- a/src/hotspot/share/opto/graphKit.cpp
+++ b/src/hotspot/share/opto/graphKit.cpp
@@ -4579,11 +4579,12 @@
   }
   const Type* con_type = Type::make_constant_from_field(field, holder, field->layout_type(),
                                                         /*is_unsigned_load=*/false);
   if (con_type != NULL) {
     Node* con = makecon(con_type);
-    if (field->layout_type() == T_VALUETYPE && field->type()->as_value_klass()->is_scalarizable() && !con_type->maybe_null()) {
+    assert(!field->is_flattenable() || (field->is_static() && !con_type->is_zero_type()), "sanity");
+    if (field->layout_type() == T_VALUETYPE && field->type()->as_value_klass()->is_scalarizable()) {
       // Load value type from constant oop
       con = ValueTypeNode::make_from_oop(this, con, field->type()->as_value_klass());
     }
     return con;
   }

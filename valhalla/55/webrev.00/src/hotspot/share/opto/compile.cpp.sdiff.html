<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/compile.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3370   case Op_LoadUS:
3371   case Op_LoadI:
3372   case Op_LoadKlass:
3373   case Op_LoadNKlass:
3374   case Op_LoadL:
3375   case Op_LoadL_unaligned:
3376   case Op_LoadPLocked:
3377   case Op_LoadP:
3378   case Op_LoadN:
3379   case Op_LoadRange:
3380   case Op_LoadS: {
3381   handle_mem:
3382 #ifdef ASSERT
3383     if( VerifyOptoOopOffsets ) {
3384       MemNode* mem  = n-&gt;as_Mem();
3385       // Check to see if address types have grounded out somehow.
3386       const TypeInstPtr *tp = mem-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;isa_instptr();
3387       assert( !tp || oop_offset_is_sane(tp), &quot;&quot; );
3388     }
3389 #endif

3390     if (EnableValhalla &amp;&amp;
3391         ((nop == Op_LoadKlass &amp;&amp; ((LoadKlassNode*)n)-&gt;clear_prop_bits()) ||
3392          (nop == Op_LoadNKlass &amp;&amp; ((LoadNKlassNode*)n)-&gt;clear_prop_bits()))) {
3393       const TypeKlassPtr* tk = n-&gt;bottom_type()-&gt;make_ptr()-&gt;is_klassptr();
3394       assert(!tk-&gt;klass_is_exact(), &quot;should have been folded&quot;);
3395       assert(n-&gt;as_Mem()-&gt;adr_type()-&gt;offset() == oopDesc::klass_offset_in_bytes(), &quot;unexpected LoadKlass&quot;);
3396       if (tk-&gt;klass()-&gt;can_be_value_array_klass()) {
<span class="line-modified">3397         // Array load klass needs to filter out property bits (but not</span>
<span class="line-removed">3398         // GetNullFreePropertyNode or GetFlattenedPropertyNode which</span>
<span class="line-removed">3399         // needs to extract the storage property bits)</span>
3400         uint last = unique();
3401         Node* pointer = NULL;
3402         if (nop == Op_LoadKlass) {
3403           Node* cast = new CastP2XNode(NULL, n);
3404           Node* masked = new LShiftXNode(cast, new ConINode(TypeInt::make(oopDesc::storage_props_nof_bits)));
3405           masked = new RShiftXNode(masked, new ConINode(TypeInt::make(oopDesc::storage_props_nof_bits)));
3406           pointer = new CastX2PNode(masked);
3407           pointer = new CheckCastPPNode(NULL, pointer, n-&gt;bottom_type());
3408         } else {
3409           Node* cast = new CastN2INode(n);
3410           Node* masked = new AndINode(cast, new ConINode(TypeInt::make(oopDesc::compressed_klass_mask())));
3411           pointer = new CastI2NNode(masked, n-&gt;bottom_type());
3412         }
3413         for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3414           Node* u = n-&gt;fast_out(i);
<span class="line-modified">3415           if (u-&gt;_idx &lt; last &amp;&amp; u-&gt;Opcode() != Op_GetNullFreeProperty &amp;&amp; u-&gt;Opcode() != Op_GetFlattenedProperty) {</span>
3416             // If user is a comparison with a klass that can&#39;t be a value type
3417             // array klass, we don&#39;t need to clear the storage property bits.
3418             Node* cmp = (u-&gt;is_DecodeNKlass() &amp;&amp; u-&gt;outcnt() == 1) ? u-&gt;unique_out() : u;
3419             if (cmp-&gt;is_Cmp()) {
3420               const TypeKlassPtr* kp1 = cmp-&gt;in(1)-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_klassptr();
3421               const TypeKlassPtr* kp2 = cmp-&gt;in(2)-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_klassptr();
3422               if ((kp1 != NULL &amp;&amp; !kp1-&gt;klass()-&gt;can_be_value_array_klass()) ||
3423                   (kp2 != NULL &amp;&amp; !kp2-&gt;klass()-&gt;can_be_value_array_klass())) {
3424                 continue;
3425               }
3426             }
3427             int nb = u-&gt;replace_edge(n, pointer);
3428             --i, imax -= nb;
3429           }
3430         }
3431       }
3432     }
3433     break;
3434   }
3435 
</pre>
<hr />
<pre>
3937     if (!Matcher::has_match_rule(Op_CmpUL)) {
3938       // No support for unsigned long comparisons
3939       ConINode* sign_pos = new ConINode(TypeInt::make(BitsPerLong - 1));
3940       Node* sign_bit_mask = new RShiftLNode(n-&gt;in(1), sign_pos);
3941       Node* orl = new OrLNode(n-&gt;in(1), sign_bit_mask);
3942       ConLNode* remove_sign_mask = new ConLNode(TypeLong::make(max_jlong));
3943       Node* andl = new AndLNode(orl, remove_sign_mask);
3944       Node* cmp = new CmpLNode(andl, n-&gt;in(2));
3945       n-&gt;subsume_by(cmp, this);
3946     }
3947     break;
3948   }
3949 #ifdef ASSERT
3950   case Op_ValueTypePtr:
3951   case Op_ValueType: {
3952     n-&gt;dump(-1);
3953     assert(false, &quot;value type node was not removed&quot;);
3954     break;
3955   }
3956 #endif
<span class="line-removed">3957   case Op_GetNullFreeProperty:</span>
<span class="line-removed">3958   case Op_GetFlattenedProperty: {</span>
<span class="line-removed">3959     // Extract the null free bits</span>
<span class="line-removed">3960     uint last = unique();</span>
<span class="line-removed">3961     Node* null_free = NULL;</span>
<span class="line-removed">3962     int bit = nop == Op_GetNullFreeProperty ? ArrayStorageProperties::null_free_bit : ArrayStorageProperties::flattened_bit;</span>
<span class="line-removed">3963     if (n-&gt;in(1)-&gt;Opcode() == Op_LoadKlass) {</span>
<span class="line-removed">3964       Node* cast = new CastP2XNode(NULL, n-&gt;in(1));</span>
<span class="line-removed">3965       null_free = new AndLNode(cast, new ConLNode(TypeLong::make(((jlong)1)&lt;&lt;(oopDesc::wide_storage_props_shift + bit))));</span>
<span class="line-removed">3966     } else {</span>
<span class="line-removed">3967       assert(n-&gt;in(1)-&gt;Opcode() == Op_LoadNKlass, &quot;not a compressed klass?&quot;);</span>
<span class="line-removed">3968       Node* cast = new CastN2INode(n-&gt;in(1));</span>
<span class="line-removed">3969       null_free = new AndINode(cast, new ConINode(TypeInt::make(1&lt;&lt;(oopDesc::narrow_storage_props_shift + bit))));</span>
<span class="line-removed">3970     }</span>
<span class="line-removed">3971     n-&gt;subsume_by(null_free, this);</span>
<span class="line-removed">3972     break;</span>
<span class="line-removed">3973   }</span>
3974   default:
3975     assert(!n-&gt;is_Call(), &quot;&quot;);
3976     assert(!n-&gt;is_Mem(), &quot;&quot;);
3977     assert(nop != Op_ProfileBoolean, &quot;should be eliminated during IGVN&quot;);
3978     break;
3979   }
3980 }
3981 
3982 //------------------------------final_graph_reshaping_walk---------------------
3983 // Replacing Opaque nodes with their input in final_graph_reshaping_impl(),
3984 // requires that the walk visits a node&#39;s inputs before visiting the node.
3985 void Compile::final_graph_reshaping_walk( Node_Stack &amp;nstack, Node *root, Final_Reshape_Counts &amp;frc ) {
3986   ResourceArea *area = Thread::current()-&gt;resource_area();
3987   Unique_Node_List sfpt(area);
3988 
3989   frc._visited.set(root-&gt;_idx); // first, mark node as visited
3990   uint cnt = root-&gt;req();
3991   Node *n = root;
3992   uint  i = 0;
3993   while (true) {
</pre>
<hr />
<pre>
4457   if (superk == env()-&gt;Object_klass()) {
4458     return SSC_always_true;     // (0) this test cannot fail
4459   }
4460 
4461   ciType* superelem = superk;
4462   if (superelem-&gt;is_array_klass()) {
4463     ciArrayKlass* ak = superelem-&gt;as_array_klass();
4464     superelem = superelem-&gt;as_array_klass()-&gt;base_element_type();
4465   }
4466 
4467   if (!subk-&gt;is_interface()) {  // cannot trust static interface types yet
4468     if (subk-&gt;is_subtype_of(superk)) {
4469       return SSC_always_true;   // (1) false path dead; no dynamic test needed
4470     }
4471     if (!(superelem-&gt;is_klass() &amp;&amp; superelem-&gt;as_klass()-&gt;is_interface()) &amp;&amp;
4472         !superk-&gt;is_subtype_of(subk)) {
4473       return SSC_always_false;
4474     }
4475   }
4476 
<span class="line-removed">4477   // Do not fold the subtype check to an array klass pointer comparison for [V? arrays.</span>
<span class="line-removed">4478   // [V is a subtype of [V? but the klass for [V is not equal to the klass for [V?. Perform a full test.</span>
<span class="line-removed">4479   if (superk-&gt;is_obj_array_klass() &amp;&amp; !superk-&gt;as_array_klass()-&gt;storage_properties().is_null_free() &amp;&amp; superk-&gt;as_array_klass()-&gt;element_klass()-&gt;is_valuetype()) {</span>
<span class="line-removed">4480     return SSC_full_test;</span>
<span class="line-removed">4481   }</span>
4482   // If casting to an instance klass, it must have no subtypes
4483   if (superk-&gt;is_interface()) {
4484     // Cannot trust interfaces yet.
4485     // %%% S.B. superk-&gt;nof_implementors() == 1
4486   } else if (superelem-&gt;is_instance_klass()) {
4487     ciInstanceKlass* ik = superelem-&gt;as_instance_klass();
4488     if (!ik-&gt;has_subklass() &amp;&amp; !ik-&gt;is_interface()) {
4489       if (!ik-&gt;is_final()) {
4490         // Add a dependency if there is a chance of a later subclass.
4491         dependencies()-&gt;assert_leaf_type(ik);
4492       }
4493       return SSC_easy_test;     // (3) caller can do a simple ptr comparison
4494     }
4495   } else {
4496     // A primitive array type has no subtypes.
4497     return SSC_easy_test;       // (3) caller can do a simple ptr comparison
4498   }
4499 
4500   return SSC_full_test;
4501 }
</pre>
</td>
<td>
<hr />
<pre>
3370   case Op_LoadUS:
3371   case Op_LoadI:
3372   case Op_LoadKlass:
3373   case Op_LoadNKlass:
3374   case Op_LoadL:
3375   case Op_LoadL_unaligned:
3376   case Op_LoadPLocked:
3377   case Op_LoadP:
3378   case Op_LoadN:
3379   case Op_LoadRange:
3380   case Op_LoadS: {
3381   handle_mem:
3382 #ifdef ASSERT
3383     if( VerifyOptoOopOffsets ) {
3384       MemNode* mem  = n-&gt;as_Mem();
3385       // Check to see if address types have grounded out somehow.
3386       const TypeInstPtr *tp = mem-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;isa_instptr();
3387       assert( !tp || oop_offset_is_sane(tp), &quot;&quot; );
3388     }
3389 #endif
<span class="line-added">3390     // TODO remove clear_prop_bits bits stuff once the runtime does not set it anymore</span>
3391     if (EnableValhalla &amp;&amp;
3392         ((nop == Op_LoadKlass &amp;&amp; ((LoadKlassNode*)n)-&gt;clear_prop_bits()) ||
3393          (nop == Op_LoadNKlass &amp;&amp; ((LoadNKlassNode*)n)-&gt;clear_prop_bits()))) {
3394       const TypeKlassPtr* tk = n-&gt;bottom_type()-&gt;make_ptr()-&gt;is_klassptr();
3395       assert(!tk-&gt;klass_is_exact(), &quot;should have been folded&quot;);
3396       assert(n-&gt;as_Mem()-&gt;adr_type()-&gt;offset() == oopDesc::klass_offset_in_bytes(), &quot;unexpected LoadKlass&quot;);
3397       if (tk-&gt;klass()-&gt;can_be_value_array_klass()) {
<span class="line-modified">3398         // Array load klass needs to filter out property bits</span>


3399         uint last = unique();
3400         Node* pointer = NULL;
3401         if (nop == Op_LoadKlass) {
3402           Node* cast = new CastP2XNode(NULL, n);
3403           Node* masked = new LShiftXNode(cast, new ConINode(TypeInt::make(oopDesc::storage_props_nof_bits)));
3404           masked = new RShiftXNode(masked, new ConINode(TypeInt::make(oopDesc::storage_props_nof_bits)));
3405           pointer = new CastX2PNode(masked);
3406           pointer = new CheckCastPPNode(NULL, pointer, n-&gt;bottom_type());
3407         } else {
3408           Node* cast = new CastN2INode(n);
3409           Node* masked = new AndINode(cast, new ConINode(TypeInt::make(oopDesc::compressed_klass_mask())));
3410           pointer = new CastI2NNode(masked, n-&gt;bottom_type());
3411         }
3412         for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3413           Node* u = n-&gt;fast_out(i);
<span class="line-modified">3414           if (u-&gt;_idx &lt; last) {</span>
3415             // If user is a comparison with a klass that can&#39;t be a value type
3416             // array klass, we don&#39;t need to clear the storage property bits.
3417             Node* cmp = (u-&gt;is_DecodeNKlass() &amp;&amp; u-&gt;outcnt() == 1) ? u-&gt;unique_out() : u;
3418             if (cmp-&gt;is_Cmp()) {
3419               const TypeKlassPtr* kp1 = cmp-&gt;in(1)-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_klassptr();
3420               const TypeKlassPtr* kp2 = cmp-&gt;in(2)-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_klassptr();
3421               if ((kp1 != NULL &amp;&amp; !kp1-&gt;klass()-&gt;can_be_value_array_klass()) ||
3422                   (kp2 != NULL &amp;&amp; !kp2-&gt;klass()-&gt;can_be_value_array_klass())) {
3423                 continue;
3424               }
3425             }
3426             int nb = u-&gt;replace_edge(n, pointer);
3427             --i, imax -= nb;
3428           }
3429         }
3430       }
3431     }
3432     break;
3433   }
3434 
</pre>
<hr />
<pre>
3936     if (!Matcher::has_match_rule(Op_CmpUL)) {
3937       // No support for unsigned long comparisons
3938       ConINode* sign_pos = new ConINode(TypeInt::make(BitsPerLong - 1));
3939       Node* sign_bit_mask = new RShiftLNode(n-&gt;in(1), sign_pos);
3940       Node* orl = new OrLNode(n-&gt;in(1), sign_bit_mask);
3941       ConLNode* remove_sign_mask = new ConLNode(TypeLong::make(max_jlong));
3942       Node* andl = new AndLNode(orl, remove_sign_mask);
3943       Node* cmp = new CmpLNode(andl, n-&gt;in(2));
3944       n-&gt;subsume_by(cmp, this);
3945     }
3946     break;
3947   }
3948 #ifdef ASSERT
3949   case Op_ValueTypePtr:
3950   case Op_ValueType: {
3951     n-&gt;dump(-1);
3952     assert(false, &quot;value type node was not removed&quot;);
3953     break;
3954   }
3955 #endif

















3956   default:
3957     assert(!n-&gt;is_Call(), &quot;&quot;);
3958     assert(!n-&gt;is_Mem(), &quot;&quot;);
3959     assert(nop != Op_ProfileBoolean, &quot;should be eliminated during IGVN&quot;);
3960     break;
3961   }
3962 }
3963 
3964 //------------------------------final_graph_reshaping_walk---------------------
3965 // Replacing Opaque nodes with their input in final_graph_reshaping_impl(),
3966 // requires that the walk visits a node&#39;s inputs before visiting the node.
3967 void Compile::final_graph_reshaping_walk( Node_Stack &amp;nstack, Node *root, Final_Reshape_Counts &amp;frc ) {
3968   ResourceArea *area = Thread::current()-&gt;resource_area();
3969   Unique_Node_List sfpt(area);
3970 
3971   frc._visited.set(root-&gt;_idx); // first, mark node as visited
3972   uint cnt = root-&gt;req();
3973   Node *n = root;
3974   uint  i = 0;
3975   while (true) {
</pre>
<hr />
<pre>
4439   if (superk == env()-&gt;Object_klass()) {
4440     return SSC_always_true;     // (0) this test cannot fail
4441   }
4442 
4443   ciType* superelem = superk;
4444   if (superelem-&gt;is_array_klass()) {
4445     ciArrayKlass* ak = superelem-&gt;as_array_klass();
4446     superelem = superelem-&gt;as_array_klass()-&gt;base_element_type();
4447   }
4448 
4449   if (!subk-&gt;is_interface()) {  // cannot trust static interface types yet
4450     if (subk-&gt;is_subtype_of(superk)) {
4451       return SSC_always_true;   // (1) false path dead; no dynamic test needed
4452     }
4453     if (!(superelem-&gt;is_klass() &amp;&amp; superelem-&gt;as_klass()-&gt;is_interface()) &amp;&amp;
4454         !superk-&gt;is_subtype_of(subk)) {
4455       return SSC_always_false;
4456     }
4457   }
4458 





4459   // If casting to an instance klass, it must have no subtypes
4460   if (superk-&gt;is_interface()) {
4461     // Cannot trust interfaces yet.
4462     // %%% S.B. superk-&gt;nof_implementors() == 1
4463   } else if (superelem-&gt;is_instance_klass()) {
4464     ciInstanceKlass* ik = superelem-&gt;as_instance_klass();
4465     if (!ik-&gt;has_subklass() &amp;&amp; !ik-&gt;is_interface()) {
4466       if (!ik-&gt;is_final()) {
4467         // Add a dependency if there is a chance of a later subclass.
4468         dependencies()-&gt;assert_leaf_type(ik);
4469       }
4470       return SSC_easy_test;     // (3) caller can do a simple ptr comparison
4471     }
4472   } else {
4473     // A primitive array type has no subtypes.
4474     return SSC_easy_test;       // (3) caller can do a simple ptr comparison
4475   }
4476 
4477   return SSC_full_test;
4478 }
</pre>
</td>
</tr>
</table>
<center><a href="classes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
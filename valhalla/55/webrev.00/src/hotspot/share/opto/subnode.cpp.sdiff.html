<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/subnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="parse3.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/subnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1068         superklass-&gt;is_abstract()) {
1069       // Make it come out always false:
1070       this-&gt;set_req(2, phase-&gt;makecon(TypePtr::NULL_PTR));
1071       return this;
1072     }
1073   }
1074 
1075   // Check for a LoadKlass from primary supertype array.
1076   // Any nested loadklass from loadklass+con must be from the p.s. array.
1077   if (ldk2-&gt;is_DecodeNKlass()) {
1078     // Keep ldk2 as DecodeN since it could be used in CmpP below.
1079     if (ldk2-&gt;in(1)-&gt;Opcode() != Op_LoadNKlass )
1080       return NULL;
1081   } else if (ldk2-&gt;Opcode() != Op_LoadKlass)
1082     return NULL;
1083 
1084   // Verify that we understand the situation
1085   if (con2 != (intptr_t) superklass-&gt;super_check_offset())
1086     return NULL;                // Might be element-klass loading from array klass
1087 
<span class="line-removed">1088   // Do not fold the subtype check to an array klass pointer comparison for [V? arrays.</span>
<span class="line-removed">1089   // [V is a subtype of [V? but the klass for [V is not equal to the klass for [V?. Perform a full test.</span>
<span class="line-removed">1090   if (superklass-&gt;is_obj_array_klass()) {</span>
<span class="line-removed">1091     ciObjArrayKlass* ak = superklass-&gt;as_obj_array_klass();</span>
<span class="line-removed">1092     if (!ak-&gt;storage_properties().is_null_free() &amp;&amp; ak-&gt;element_klass()-&gt;is_valuetype()) {</span>
<span class="line-removed">1093       // Do not bypass the klass load from the primary supertype array</span>
<span class="line-removed">1094       return NULL;</span>
<span class="line-removed">1095     }</span>
<span class="line-removed">1096   }</span>
<span class="line-removed">1097 </span>
1098   // If &#39;superklass&#39; has no subklasses and is not an interface, then we are
1099   // assured that the only input which will pass the type check is
1100   // &#39;superklass&#39; itself.
1101   //
1102   // We could be more liberal here, and allow the optimization on interfaces
1103   // which have a single implementor.  This would require us to increase the
1104   // expressiveness of the add_dependency() mechanism.
1105   // %%% Do this after we fix TypeOopPtr:  Deps are expressive enough now.
1106 
1107   // Object arrays must have their base element have no subtypes
1108   while (superklass-&gt;is_obj_array_klass()) {
1109     ciType* elem = superklass-&gt;as_obj_array_klass()-&gt;element_type();
1110     superklass = elem-&gt;as_klass();
1111   }
1112   if (superklass-&gt;is_instance_klass()) {
1113     ciInstanceKlass* ik = superklass-&gt;as_instance_klass();
1114     if (ik-&gt;has_subklass() || ik-&gt;is_interface())  return NULL;
1115     // Add a dependency if there is a chance that a subclass will be added later.
1116     if (!ik-&gt;is_final()) {
1117       phase-&gt;C-&gt;dependencies()-&gt;assert_leaf_type(ik);
</pre>
</td>
<td>
<hr />
<pre>
1068         superklass-&gt;is_abstract()) {
1069       // Make it come out always false:
1070       this-&gt;set_req(2, phase-&gt;makecon(TypePtr::NULL_PTR));
1071       return this;
1072     }
1073   }
1074 
1075   // Check for a LoadKlass from primary supertype array.
1076   // Any nested loadklass from loadklass+con must be from the p.s. array.
1077   if (ldk2-&gt;is_DecodeNKlass()) {
1078     // Keep ldk2 as DecodeN since it could be used in CmpP below.
1079     if (ldk2-&gt;in(1)-&gt;Opcode() != Op_LoadNKlass )
1080       return NULL;
1081   } else if (ldk2-&gt;Opcode() != Op_LoadKlass)
1082     return NULL;
1083 
1084   // Verify that we understand the situation
1085   if (con2 != (intptr_t) superklass-&gt;super_check_offset())
1086     return NULL;                // Might be element-klass loading from array klass
1087 










1088   // If &#39;superklass&#39; has no subklasses and is not an interface, then we are
1089   // assured that the only input which will pass the type check is
1090   // &#39;superklass&#39; itself.
1091   //
1092   // We could be more liberal here, and allow the optimization on interfaces
1093   // which have a single implementor.  This would require us to increase the
1094   // expressiveness of the add_dependency() mechanism.
1095   // %%% Do this after we fix TypeOopPtr:  Deps are expressive enough now.
1096 
1097   // Object arrays must have their base element have no subtypes
1098   while (superklass-&gt;is_obj_array_klass()) {
1099     ciType* elem = superklass-&gt;as_obj_array_klass()-&gt;element_type();
1100     superklass = elem-&gt;as_klass();
1101   }
1102   if (superklass-&gt;is_instance_klass()) {
1103     ciInstanceKlass* ik = superklass-&gt;as_instance_klass();
1104     if (ik-&gt;has_subklass() || ik-&gt;is_interface())  return NULL;
1105     // Add a dependency if there is a chance that a subclass will be added later.
1106     if (!ik-&gt;is_final()) {
1107       phase-&gt;C-&gt;dependencies()-&gt;assert_leaf_type(ik);
</pre>
</td>
</tr>
</table>
<center><a href="parse3.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/graphKit.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/graphKit.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1165   Node* conv = _gvn.transform( new ConvI2LNode(offset));
1166   Node* mask = _gvn.transform(ConLNode::make((julong) max_juint));
1167   return _gvn.transform( new AndLNode(conv, mask) );
1168 }
1169 
1170 Node* GraphKit::ConvL2I(Node* offset) {
1171   // short-circuit a common case
1172   jlong offset_con = find_long_con(offset, (jlong)Type::OffsetBot);
1173   if (offset_con != (jlong)Type::OffsetBot) {
1174     return intcon((int) offset_con);
1175   }
1176   return _gvn.transform( new ConvL2INode(offset));
1177 }
1178 
1179 //-------------------------load_object_klass-----------------------------------
1180 Node* GraphKit::load_object_klass(Node* obj, bool clear_prop_bits) {
1181   // Special-case a fresh allocation to avoid building nodes:
1182   Node* akls = AllocateNode::Ideal_klass(obj, &amp;_gvn);
1183   if (akls != NULL)  return akls;
1184   Node* k_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());

1185   return _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT, clear_prop_bits));
1186 }
1187 
1188 //-------------------------load_array_length-----------------------------------
1189 Node* GraphKit::load_array_length(Node* array) {
1190   // Special-case a fresh allocation to avoid building nodes:
1191   AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(array, &amp;_gvn);
1192   Node *alen;
1193   if (alloc == NULL) {
1194     Node *r_adr = basic_plus_adr(array, arrayOopDesc::length_offset_in_bytes());
1195     alen = _gvn.transform( new LoadRangeNode(0, immutable_memory(), r_adr, TypeInt::POS));
1196   } else {
1197     alen = alloc-&gt;Ideal_length();
1198     Node* ccast = alloc-&gt;make_ideal_length(_gvn.type(array)-&gt;is_oopptr(), &amp;_gvn);
1199     if (ccast != alen) {
1200       alen = _gvn.transform(ccast);
1201     }
1202   }
1203   return alen;
1204 }
</pre>
<hr />
<pre>
3485     // references to it.  FIX THIS WHEN UNION TYPES APPEAR!
3486   //  replace_in_map( obj, res );
3487 
3488   // Return final merged results
3489   set_control( _gvn.transform(region) );
3490   record_for_igvn(region);
3491 
3492   bool not_null_free = !toop-&gt;can_be_value_type();
3493   bool not_flattenable = !ValueArrayFlatten || not_null_free || (toop-&gt;is_valuetypeptr() &amp;&amp; !toop-&gt;value_klass()-&gt;flatten_array());
3494   if (EnableValhalla &amp;&amp; not_flattenable) {
3495     // Check if obj has been loaded from an array
3496     obj = obj-&gt;isa_DecodeN() ? obj-&gt;in(1) : obj;
3497     Node* array = NULL;
3498     if (obj-&gt;isa_Load()) {
3499       Node* address = obj-&gt;in(MemNode::Address);
3500       if (address-&gt;isa_AddP()) {
3501         array = address-&gt;as_AddP()-&gt;in(AddPNode::Base);
3502       }
3503     } else if (obj-&gt;is_Phi()) {
3504       Node* region = obj-&gt;in(0);
<span class="line-modified">3505       if (region-&gt;req() == 3 &amp;&amp; region-&gt;in(1) != NULL &amp;&amp; region-&gt;in(1)-&gt;in(0) != NULL) {</span>
<span class="line-modified">3506         IfNode* iff = region-&gt;in(1)-&gt;in(0)-&gt;isa_If();</span>

3507         if (iff != NULL) {
<span class="line-modified">3508           iff-&gt;is_flattened_array_check(&amp;_gvn, array);</span>
3509         }
3510       }
3511     }
3512     if (array != NULL) {
3513       const TypeAryPtr* ary_t = _gvn.type(array)-&gt;isa_aryptr();
3514       if (ary_t != NULL) {
3515         if (!ary_t-&gt;is_not_null_free() &amp;&amp; not_null_free) {
3516           // Casting array element to a non-inline-type, mark array as not null-free.
3517           Node* cast = _gvn.transform(new CheckCastPPNode(control(), array, ary_t-&gt;cast_to_not_null_free()));
3518           replace_in_map(array, cast);
3519         } else if (!ary_t-&gt;is_not_flat()) {
3520           // Casting array element to a non-flattenable type, mark array as not flat.
3521           Node* cast = _gvn.transform(new CheckCastPPNode(control(), array, ary_t-&gt;cast_to_not_flat()));
3522           replace_in_map(array, cast);
3523         }
3524       }
3525     }
3526   }
3527 
3528   if (!is_value) {
3529     res = record_profiled_receiver_for_speculation(res);
3530     if (toop-&gt;is_valuetypeptr() &amp;&amp; toop-&gt;value_klass()-&gt;is_scalarizable() &amp;&amp; !gvn().type(res)-&gt;maybe_null()) {
3531       res = ValueTypeNode::make_from_oop(this, res, toop-&gt;value_klass());
3532     }
3533   }
3534   return res;
3535 }
3536 
<span class="line-modified">3537 Node* GraphKit::is_always_locked(Node* obj) {</span>

3538   Node* mark_addr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());
3539   Node* mark = make_load(NULL, mark_addr, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
3540   Node* mask = _gvn.MakeConX(markWord::always_locked_pattern);
3541   Node* andx = _gvn.transform(new AndXNode(mark, mask));
3542   Node* cmp = _gvn.transform(new CmpXNode(andx, mask));
3543   return _gvn.transform(new BoolNode(cmp, BoolTest::eq));
3544 }
3545 
<span class="line-modified">3546 Node* GraphKit::is_value_mirror(Node* mirror) {</span>
<span class="line-modified">3547   Node* p = basic_plus_adr(mirror, java_lang_Class::inline_mirror_offset_in_bytes());</span>
<span class="line-modified">3548   Node* inline_mirror = access_load_at(mirror, p, _gvn.type(p)-&gt;is_ptr(), TypeInstPtr::MIRROR-&gt;cast_to_ptr_type(TypePtr::BotPTR), T_OBJECT, IN_HEAP);</span>
<span class="line-modified">3549   Node* cmp = _gvn.transform(new CmpPNode(mirror, inline_mirror));</span>
<span class="line-modified">3550   return _gvn.transform(new BoolNode(cmp, BoolTest::eq));</span>

3551 }
3552 
<span class="line-modified">3553 // Check if &#39;ary&#39; is a null-free value type array</span>
<span class="line-modified">3554 Node* GraphKit::gen_null_free_array_check(Node* ary) {</span>
<span class="line-modified">3555   assert(EnableValhalla, &quot;should only be used if value types are enabled&quot;);</span>
<span class="line-modified">3556   // Extract null free property from klass pointer</span>
<span class="line-modified">3557   Node* k_adr = basic_plus_adr(ary, oopDesc::klass_offset_in_bytes());</span>
<span class="line-modified">3558   const TypePtr* k_adr_type = k_adr-&gt;bottom_type()-&gt;isa_ptr();</span>
<span class="line-modified">3559   Node* klass = NULL;</span>
<span class="line-modified">3560   if (k_adr_type-&gt;is_ptr_to_narrowklass()) {</span>
<span class="line-removed">3561     klass = _gvn.transform(new LoadNKlassNode(NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT-&gt;make_narrowklass(), MemNode::unordered, true));</span>
<span class="line-removed">3562   } else {</span>
<span class="line-removed">3563     klass = _gvn.transform(new LoadKlassNode(NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT, MemNode::unordered, true));</span>
<span class="line-removed">3564   }</span>
<span class="line-removed">3565   Node* null_free = _gvn.transform(new GetNullFreePropertyNode(klass));</span>
<span class="line-removed">3566   Node* cmp = NULL;</span>
<span class="line-removed">3567   if (_gvn.type(klass)-&gt;isa_klassptr()) {</span>
<span class="line-removed">3568     cmp = _gvn.transform(new CmpLNode(null_free, zerocon(T_LONG)));</span>
<span class="line-removed">3569   } else {</span>
<span class="line-removed">3570     cmp = _gvn.transform(new CmpINode(null_free, zerocon(T_INT)));</span>
<span class="line-removed">3571   }</span>
3572   return _gvn.transform(new BoolNode(cmp, BoolTest::eq));
3573 }
3574 
<span class="line-removed">3575 Node* GraphKit::gen_flattened_array_test(Node* ary) {</span>
<span class="line-removed">3576   assert(EnableValhalla, &quot;should only be used if value types are enabled&quot;);</span>
<span class="line-removed">3577   // Extract flattened property from klass pointer</span>
<span class="line-removed">3578   Node* k_adr = basic_plus_adr(ary, oopDesc::klass_offset_in_bytes());</span>
<span class="line-removed">3579   const TypePtr* k_adr_type = k_adr-&gt;bottom_type()-&gt;isa_ptr();</span>
<span class="line-removed">3580   Node* klass = NULL;</span>
<span class="line-removed">3581   if (k_adr_type-&gt;is_ptr_to_narrowklass()) {</span>
<span class="line-removed">3582     klass = _gvn.transform(new LoadNKlassNode(NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT-&gt;make_narrowklass(), MemNode::unordered, true));</span>
<span class="line-removed">3583   } else {</span>
<span class="line-removed">3584     klass = _gvn.transform(new LoadKlassNode(NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT, MemNode::unordered, true));</span>
<span class="line-removed">3585   }</span>
<span class="line-removed">3586   return _gvn.transform(new GetFlattenedPropertyNode(klass));</span>
<span class="line-removed">3587 }</span>
<span class="line-removed">3588 </span>
3589 // Deoptimize if &#39;ary&#39; is a null-free value type array and &#39;val&#39; is null
3590 Node* GraphKit::gen_value_array_null_guard(Node* ary, Node* val, int nargs, bool safe_for_replace) {
3591   const Type* val_t = _gvn.type(val);
3592   if (val-&gt;is_ValueType() || !TypePtr::NULL_PTR-&gt;higher_equal(val_t)) {
3593     return ary; // Never null
3594   }
3595   RegionNode* region = new RegionNode(3);
3596   Node* null_ctl = top();
3597   null_check_oop(val, &amp;null_ctl);
3598   if (null_ctl != top()) {
3599     PreserveJVMState pjvms(this);
3600     set_control(null_ctl);
<span class="line-modified">3601     // Deoptimize if null-free array</span>
<span class="line-modified">3602     Node* bol = gen_null_free_array_check(ary);</span>
<span class="line-modified">3603     { BuildCutout unless(this, bol, PROB_MAX);</span>
3604       inc_sp(nargs);
3605       uncommon_trap(Deoptimization::Reason_null_check,
3606                     Deoptimization::Action_none);
3607     }
3608     region-&gt;init_req(1, control());
3609   }
3610   region-&gt;init_req(2, control());
3611   set_control(_gvn.transform(region));
3612   record_for_igvn(region);
3613   const TypeAryPtr* ary_t = _gvn.type(ary)-&gt;is_aryptr();
3614   if (val_t == TypePtr::NULL_PTR &amp;&amp; !ary_t-&gt;is_not_null_free()) {
3615     // Since we were just successfully storing null, the array can&#39;t be null free.
3616     ary_t = ary_t-&gt;cast_to_not_null_free();
3617     Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));
3618     if (safe_for_replace) {
3619       replace_in_map(ary, cast);
3620     }
3621     ary = cast;
3622   }
3623   return ary;
3624 }
3625 
3626 Node* GraphKit::load_lh_array_tag(Node* kls) {
3627   Node* lhp = basic_plus_adr(kls, in_bytes(Klass::layout_helper_offset()));
3628   Node* layout_val = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), lhp, lhp-&gt;bottom_type()-&gt;is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));
<span class="line-removed">3629 </span>
3630   return _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));
3631 }
3632 
<span class="line-removed">3633 </span>
3634 Node* GraphKit::gen_lh_array_test(Node* kls, unsigned int lh_value) {
3635   Node* layout_val = load_lh_array_tag(kls);
3636   Node* cmp = _gvn.transform(new CmpINode(layout_val, intcon(lh_value)));
3637   return cmp;
3638 }
3639 
<span class="line-removed">3640 </span>
3641 //------------------------------next_monitor-----------------------------------
3642 // What number should be given to the next monitor?
3643 int GraphKit::next_monitor() {
3644   int current = jvms()-&gt;monitor_depth()* C-&gt;sync_stack_slots();
3645   int next = current + C-&gt;sync_stack_slots();
3646   // Keep the toplevel high water mark current:
3647   if (C-&gt;fixed_slots() &lt; next)  C-&gt;set_fixed_slots(next);
3648   return current;
3649 }
3650 
3651 //------------------------------insert_mem_bar---------------------------------
3652 // Memory barrier to avoid floating things around
3653 // The membar serves as a pinch point between both control and all memory slices.
3654 Node* GraphKit::insert_mem_bar(int opcode, Node* precedent) {
3655   MemBarNode* mb = MemBarNode::make(C, opcode, Compile::AliasIdxBot, precedent);
3656   mb-&gt;init_req(TypeFunc::Control, control());
3657   mb-&gt;init_req(TypeFunc::Memory,  reset_memory());
3658   Node* membar = _gvn.transform(mb);
3659   set_control(_gvn.transform(new ProjNode(membar, TypeFunc::Control)));
3660   set_all_memory_call(membar);
</pre>
<hr />
<pre>
4042 
4043   return set_output_for_allocation(alloc, oop_type, deoptimize_on_exception);
4044 }
4045 
4046 // With compressed oops, the 64 bit init value for non flattened value
4047 // arrays is built from 2 32 bit compressed oops
4048 static Node* raw_default_for_coops(Node* default_value, GraphKit&amp; kit) {
4049   Node* lower = kit.gvn().transform(new CastP2XNode(kit.control(), default_value));
4050   Node* upper = kit.gvn().transform(new LShiftLNode(lower, kit.intcon(32)));
4051   return kit.gvn().transform(new OrLNode(lower, upper));
4052 }
4053 
4054 //-------------------------------new_array-------------------------------------
4055 // helper for newarray and anewarray
4056 // The &#39;length&#39; parameter is (obviously) the length of the array.
4057 // See comments on new_instance for the meaning of the other arguments.
4058 Node* GraphKit::new_array(Node* klass_node,     // array klass (maybe variable)
4059                           Node* length,         // number of array elements
4060                           int   nargs,          // number of arguments to push back for uncommon trap
4061                           Node* *return_size_val,
<span class="line-modified">4062                           bool deoptimize_on_exception,</span>
<span class="line-removed">4063                           Node* elem_mirror) {</span>
4064   jint  layout_con = Klass::_lh_neutral_value;
4065   Node* layout_val = get_layout_helper(klass_node, layout_con);
4066   bool  layout_is_con = (layout_val == NULL);
4067 
4068   if (!layout_is_con &amp;&amp; !StressReflectiveCode &amp;&amp;
4069       !too_many_traps(Deoptimization::Reason_class_check)) {
4070     // This is a reflective array creation site.
4071     // Optimistically assume that it is a subtype of Object[],
4072     // so that we can fold up all the address arithmetic.
4073     layout_con = Klass::array_layout_helper(T_OBJECT);
4074     Node* cmp_lh = _gvn.transform( new CmpINode(layout_val, intcon(layout_con)) );
4075     Node* bol_lh = _gvn.transform( new BoolNode(cmp_lh, BoolTest::eq) );
4076     { BuildCutout unless(this, bol_lh, PROB_MAX);
4077       inc_sp(nargs);
4078       uncommon_trap(Deoptimization::Reason_class_check,
4079                     Deoptimization::Action_maybe_recompile);
4080     }
4081     layout_val = NULL;
4082     layout_is_con = true;
4083   }
</pre>
<hr />
<pre>
4190   }
4191   // else if round_mask == 0, the size computation is self-rounding
4192 
4193   if (return_size_val != NULL) {
4194     // This is the size
4195     (*return_size_val) = size;
4196   }
4197 
4198   // Now generate allocation code
4199 
4200   // The entire memory state is needed for slow path of the allocation
4201   // since GC and deoptimization can happen.
4202   Node *mem = reset_memory();
4203   set_all_memory(mem); // Create new memory state
4204 
4205   if (initial_slow_test-&gt;is_Bool()) {
4206     // Hide it behind a CMoveI, or else PhaseIdealLoop::split_up will get sick.
4207     initial_slow_test = initial_slow_test-&gt;as_Bool()-&gt;as_int_value(&amp;_gvn);
4208   }
4209 
<span class="line-modified">4210   const TypeOopPtr* ary_type = _gvn.type(klass_node)-&gt;is_klassptr()-&gt;as_instance_type();</span>

4211   const TypeAryPtr* ary_ptr = ary_type-&gt;isa_aryptr();
<span class="line-modified">4212   const Type* elem = NULL;</span>
<span class="line-modified">4213   ciKlass* elem_klass = NULL;</span>
<span class="line-modified">4214 </span>
<span class="line-modified">4215   // Compute default value and storage properties for value type arrays:</span>
<span class="line-modified">4216   // - null-ok:              MyValue.box[] (ciObjArrayKlass &quot;[LMyValue&quot;)</span>
<span class="line-modified">4217   // - null-free:            MyValue.val[] (ciObjArrayKlass &quot;[QMyValue&quot;)</span>
<span class="line-modified">4218   // - null-free, flattened: MyValue.val[] (ciValueArrayKlass &quot;[QMyValue&quot;)</span>
<span class="line-removed">4219   Node* storage_properties = NULL;</span>
4220   Node* default_value = NULL;
4221   Node* raw_default_value = NULL;
<span class="line-removed">4222   int props_shift = UseCompressedClassPointers ? oopDesc::narrow_storage_props_shift : oopDesc::wide_storage_props_shift;</span>
4223   if (ary_ptr != NULL &amp;&amp; ary_ptr-&gt;klass_is_exact()) {
4224     // Array type is known
<span class="line-modified">4225     elem = ary_ptr-&gt;elem();</span>
<span class="line-modified">4226     ciArrayKlass* ary_klass = ary_ptr-&gt;klass()-&gt;as_array_klass();</span>
<span class="line-modified">4227     elem_klass = ary_klass-&gt;element_klass();</span>
<span class="line-modified">4228 </span>
<span class="line-modified">4229     ArrayStorageProperties props = ary_klass-&gt;storage_properties();</span>
<span class="line-modified">4230     if (!props.is_empty() &amp;&amp; elem_klass-&gt;is_valuetype()) {</span>
<span class="line-modified">4231       if (props.is_null_free() &amp;&amp; !props.is_flattened()) {</span>
<span class="line-removed">4232         default_value = ValueTypeNode::default_oop(gvn(), elem_klass-&gt;as_value_klass());</span>
<span class="line-removed">4233         if (elem-&gt;isa_narrowoop()) {</span>
<span class="line-removed">4234           default_value = _gvn.transform(new EncodePNode(default_value, elem));</span>
4235           raw_default_value = raw_default_for_coops(default_value, *this);
4236         } else {
4237           raw_default_value = _gvn.transform(new CastP2XNode(control(), default_value));
4238         }
4239       }
<span class="line-removed">4240       storage_properties = MakeConX(props.encode&lt;NOT_LP64(jint) LP64_ONLY(jlong)&gt;(props_shift));</span>
4241     }
<span class="line-modified">4242   }</span>
<span class="line-modified">4243 </span>
<span class="line-modified">4244   if (EnableValhalla &amp;&amp; (elem == NULL || (elem_klass != NULL &amp;&amp; (elem_klass-&gt;is_java_lang_Object() || elem_klass-&gt;is_valuetype()) &amp;&amp;</span>
<span class="line-removed">4245                                           !ary_type-&gt;klass_is_exact()))) {</span>
<span class="line-removed">4246     // Array type is not known, compute default value and storage properties for initialization.</span>
<span class="line-removed">4247     assert(default_value == NULL &amp;&amp; raw_default_value == NULL &amp;&amp; storage_properties == NULL, &quot;shouldn&#39;t be set yet&quot;);</span>
<span class="line-removed">4248     assert(elem_mirror != NULL, &quot;should not be null&quot;);</span>
<span class="line-removed">4249 </span>
4250     Node* r = new RegionNode(4);
4251     default_value = new PhiNode(r, TypeInstPtr::BOTTOM);
<span class="line-removed">4252     storage_properties = new PhiNode(r, TypeX_X);</span>
<span class="line-removed">4253 </span>
<span class="line-removed">4254     Node* empty     = MakeConX(ArrayStorageProperties::empty.encode&lt;NOT_LP64(jint) LP64_ONLY(jlong)&gt;(props_shift));</span>
<span class="line-removed">4255     Node* null_free = MakeConX(ArrayStorageProperties::null_free.encode&lt;NOT_LP64(jint) LP64_ONLY(jlong)&gt;(props_shift));</span>
<span class="line-removed">4256     Node* flat      = MakeConX(ArrayStorageProperties::flattened_and_null_free.encode&lt;NOT_LP64(jint) LP64_ONLY(jlong)&gt;(props_shift));</span>
4257 
<span class="line-modified">4258     // Check if element mirror is a value mirror</span>
<span class="line-modified">4259     IfNode* iff = create_and_map_if(control(), is_value_mirror(elem_mirror), PROB_FAIR, COUNT_UNKNOWN);</span>


4260 
<span class="line-modified">4261     // Not a value mirror but a box mirror or not a value type array, initialize with all zero</span>
4262     r-&gt;init_req(1, _gvn.transform(new IfFalseNode(iff)));
4263     default_value-&gt;init_req(1, null());
<span class="line-removed">4264     storage_properties-&gt;init_req(1, empty);</span>
4265 
<span class="line-modified">4266     // Value mirror (= null-free), check if flattened</span>
4267     set_control(_gvn.transform(new IfTrueNode(iff)));
<span class="line-modified">4268     Node* cmp = gen_lh_array_test(klass_node, Klass::_lh_array_tag_vt_value);</span>
<span class="line-modified">4269     Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));</span>




4270     iff = create_and_map_if(control(), bol, PROB_FAIR, COUNT_UNKNOWN);
4271 
<span class="line-modified">4272     // Flattened, initialize with all zero</span>
<span class="line-modified">4273     r-&gt;init_req(2, _gvn.transform(new IfTrueNode(iff)));</span>
4274     default_value-&gt;init_req(2, null());
<span class="line-removed">4275     storage_properties-&gt;init_req(2, flat);</span>
4276 
<span class="line-modified">4277     // Non-flattened, initialize with the default value</span>
<span class="line-modified">4278     set_control(_gvn.transform(new IfFalseNode(iff)));</span>
4279     Node* p = basic_plus_adr(klass_node, in_bytes(ArrayKlass::element_klass_offset()));
4280     Node* eklass = _gvn.transform(LoadKlassNode::make(_gvn, control(), immutable_memory(), p, TypeInstPtr::KLASS));
4281     Node* adr_fixed_block_addr = basic_plus_adr(eklass, in_bytes(InstanceKlass::adr_valueklass_fixed_block_offset()));
4282     Node* adr_fixed_block = make_load(control(), adr_fixed_block_addr, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);
4283     Node* default_value_offset_addr = basic_plus_adr(adr_fixed_block, in_bytes(ValueKlass::default_value_offset_offset()));
4284     Node* default_value_offset = make_load(control(), default_value_offset_addr, TypeInt::INT, T_INT, MemNode::unordered);

4285     Node* default_value_addr = basic_plus_adr(elem_mirror, ConvI2X(default_value_offset));
4286     Node* val = access_load_at(elem_mirror, default_value_addr, _gvn.type(default_value_addr)-&gt;is_ptr(), TypeInstPtr::BOTTOM, T_OBJECT, IN_HEAP);
4287     r-&gt;init_req(3, control());
4288     default_value-&gt;init_req(3, val);
<span class="line-removed">4289     storage_properties-&gt;init_req(3, null_free);</span>
4290 
4291     set_control(_gvn.transform(r));
4292     default_value = _gvn.transform(default_value);
<span class="line-removed">4293     storage_properties = _gvn.transform(storage_properties);</span>
4294     if (UseCompressedOops) {
4295       default_value = _gvn.transform(new EncodePNode(default_value, default_value-&gt;bottom_type()-&gt;make_narrowoop()));
4296       raw_default_value = raw_default_for_coops(default_value, *this);
4297     } else {
4298       raw_default_value = _gvn.transform(new CastP2XNode(control(), default_value));
4299     }
4300   }
4301 
4302   // Create the AllocateArrayNode and its result projections
4303   AllocateArrayNode* alloc = new AllocateArrayNode(C, AllocateArrayNode::alloc_type(TypeInt::INT),
4304                                                    control(), mem, i_o(),
4305                                                    size, klass_node,
4306                                                    initial_slow_test,
4307                                                    length, default_value,
<span class="line-modified">4308                                                    raw_default_value,</span>
<span class="line-removed">4309                                                    storage_properties);</span>
4310 
4311   // Cast to correct type.  Note that the klass_node may be constant or not,
4312   // and in the latter case the actual array type will be inexact also.
4313   // (This happens via a non-constant argument to inline_native_newArray.)
4314   // In any case, the value of klass_node provides the desired array type.
4315   const TypeInt* length_type = _gvn.find_int_type(length);
4316   if (ary_type-&gt;isa_aryptr() &amp;&amp; length_type != NULL) {
4317     // Try to get a better type than POS for the size
4318     ary_type = ary_type-&gt;is_aryptr()-&gt;cast_to_size(length_type);
4319   }
4320 
4321   Node* javaoop = set_output_for_allocation(alloc, ary_type, deoptimize_on_exception);
4322 
4323   // Cast length on remaining path to be as narrow as possible
4324   if (map()-&gt;find_edge(length) &gt;= 0) {
4325     Node* ccast = alloc-&gt;make_ideal_length(ary_type, &amp;_gvn);
4326     if (ccast != length) {
4327       _gvn.set_type_bottom(ccast);
4328       record_for_igvn(ccast);
4329       replace_in_map(length, ccast);
</pre>
</td>
<td>
<hr />
<pre>
1165   Node* conv = _gvn.transform( new ConvI2LNode(offset));
1166   Node* mask = _gvn.transform(ConLNode::make((julong) max_juint));
1167   return _gvn.transform( new AndLNode(conv, mask) );
1168 }
1169 
1170 Node* GraphKit::ConvL2I(Node* offset) {
1171   // short-circuit a common case
1172   jlong offset_con = find_long_con(offset, (jlong)Type::OffsetBot);
1173   if (offset_con != (jlong)Type::OffsetBot) {
1174     return intcon((int) offset_con);
1175   }
1176   return _gvn.transform( new ConvL2INode(offset));
1177 }
1178 
1179 //-------------------------load_object_klass-----------------------------------
1180 Node* GraphKit::load_object_klass(Node* obj, bool clear_prop_bits) {
1181   // Special-case a fresh allocation to avoid building nodes:
1182   Node* akls = AllocateNode::Ideal_klass(obj, &amp;_gvn);
1183   if (akls != NULL)  return akls;
1184   Node* k_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());
<span class="line-added">1185   // TODO remove clear_prop_bits bits stuff once the runtime does not set it anymore</span>
1186   return _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT, clear_prop_bits));
1187 }
1188 
1189 //-------------------------load_array_length-----------------------------------
1190 Node* GraphKit::load_array_length(Node* array) {
1191   // Special-case a fresh allocation to avoid building nodes:
1192   AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(array, &amp;_gvn);
1193   Node *alen;
1194   if (alloc == NULL) {
1195     Node *r_adr = basic_plus_adr(array, arrayOopDesc::length_offset_in_bytes());
1196     alen = _gvn.transform( new LoadRangeNode(0, immutable_memory(), r_adr, TypeInt::POS));
1197   } else {
1198     alen = alloc-&gt;Ideal_length();
1199     Node* ccast = alloc-&gt;make_ideal_length(_gvn.type(array)-&gt;is_oopptr(), &amp;_gvn);
1200     if (ccast != alen) {
1201       alen = _gvn.transform(ccast);
1202     }
1203   }
1204   return alen;
1205 }
</pre>
<hr />
<pre>
3486     // references to it.  FIX THIS WHEN UNION TYPES APPEAR!
3487   //  replace_in_map( obj, res );
3488 
3489   // Return final merged results
3490   set_control( _gvn.transform(region) );
3491   record_for_igvn(region);
3492 
3493   bool not_null_free = !toop-&gt;can_be_value_type();
3494   bool not_flattenable = !ValueArrayFlatten || not_null_free || (toop-&gt;is_valuetypeptr() &amp;&amp; !toop-&gt;value_klass()-&gt;flatten_array());
3495   if (EnableValhalla &amp;&amp; not_flattenable) {
3496     // Check if obj has been loaded from an array
3497     obj = obj-&gt;isa_DecodeN() ? obj-&gt;in(1) : obj;
3498     Node* array = NULL;
3499     if (obj-&gt;isa_Load()) {
3500       Node* address = obj-&gt;in(MemNode::Address);
3501       if (address-&gt;isa_AddP()) {
3502         array = address-&gt;as_AddP()-&gt;in(AddPNode::Base);
3503       }
3504     } else if (obj-&gt;is_Phi()) {
3505       Node* region = obj-&gt;in(0);
<span class="line-modified">3506       // TODO make this more robust (see JDK-8231346)</span>
<span class="line-modified">3507       if (region-&gt;req() == 3 &amp;&amp; region-&gt;in(2) != NULL &amp;&amp; region-&gt;in(2)-&gt;in(0) != NULL) {</span>
<span class="line-added">3508         IfNode* iff = region-&gt;in(2)-&gt;in(0)-&gt;isa_If();</span>
3509         if (iff != NULL) {
<span class="line-modified">3510           iff-&gt;is_non_flattened_array_check(&amp;_gvn, &amp;array);</span>
3511         }
3512       }
3513     }
3514     if (array != NULL) {
3515       const TypeAryPtr* ary_t = _gvn.type(array)-&gt;isa_aryptr();
3516       if (ary_t != NULL) {
3517         if (!ary_t-&gt;is_not_null_free() &amp;&amp; not_null_free) {
3518           // Casting array element to a non-inline-type, mark array as not null-free.
3519           Node* cast = _gvn.transform(new CheckCastPPNode(control(), array, ary_t-&gt;cast_to_not_null_free()));
3520           replace_in_map(array, cast);
3521         } else if (!ary_t-&gt;is_not_flat()) {
3522           // Casting array element to a non-flattenable type, mark array as not flat.
3523           Node* cast = _gvn.transform(new CheckCastPPNode(control(), array, ary_t-&gt;cast_to_not_flat()));
3524           replace_in_map(array, cast);
3525         }
3526       }
3527     }
3528   }
3529 
3530   if (!is_value) {
3531     res = record_profiled_receiver_for_speculation(res);
3532     if (toop-&gt;is_valuetypeptr() &amp;&amp; toop-&gt;value_klass()-&gt;is_scalarizable() &amp;&amp; !gvn().type(res)-&gt;maybe_null()) {
3533       res = ValueTypeNode::make_from_oop(this, res, toop-&gt;value_klass());
3534     }
3535   }
3536   return res;
3537 }
3538 
<span class="line-modified">3539 // Check if &#39;obj&#39; is a value type by checking if it has the always_locked markWord pattern set.</span>
<span class="line-added">3540 Node* GraphKit::is_value_type(Node* obj) {</span>
3541   Node* mark_addr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());
3542   Node* mark = make_load(NULL, mark_addr, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
3543   Node* mask = _gvn.MakeConX(markWord::always_locked_pattern);
3544   Node* andx = _gvn.transform(new AndXNode(mark, mask));
3545   Node* cmp = _gvn.transform(new CmpXNode(andx, mask));
3546   return _gvn.transform(new BoolNode(cmp, BoolTest::eq));
3547 }
3548 
<span class="line-modified">3549 // Check if &#39;ary&#39; is a non-flattened array</span>
<span class="line-modified">3550 Node* GraphKit::is_non_flattened_array(Node* ary) {</span>
<span class="line-modified">3551   Node* kls = load_object_klass(ary);</span>
<span class="line-modified">3552   Node* tag = load_lh_array_tag(kls);</span>
<span class="line-modified">3553   Node* cmp = gen_lh_array_test(kls, Klass::_lh_array_tag_vt_value);</span>
<span class="line-added">3554   return _gvn.transform(new BoolNode(cmp, BoolTest::ne));</span>
3555 }
3556 
<span class="line-modified">3557 // Check if &#39;ary&#39; is a nullable array</span>
<span class="line-modified">3558 Node* GraphKit::is_nullable_array(Node* ary) {</span>
<span class="line-modified">3559   Node* kls = load_object_klass(ary);</span>
<span class="line-modified">3560   Node* lhp = basic_plus_adr(kls, in_bytes(Klass::layout_helper_offset()));</span>
<span class="line-modified">3561   Node* layout_val = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), lhp, lhp-&gt;bottom_type()-&gt;is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));</span>
<span class="line-modified">3562   Node* null_free = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_null_free_shift)));</span>
<span class="line-modified">3563   null_free = _gvn.transform(new AndINode(null_free, intcon(Klass::_lh_null_free_mask)));</span>
<span class="line-modified">3564   Node* cmp = _gvn.transform(new CmpINode(null_free, intcon(0)));</span>











3565   return _gvn.transform(new BoolNode(cmp, BoolTest::eq));
3566 }
3567 














3568 // Deoptimize if &#39;ary&#39; is a null-free value type array and &#39;val&#39; is null
3569 Node* GraphKit::gen_value_array_null_guard(Node* ary, Node* val, int nargs, bool safe_for_replace) {
3570   const Type* val_t = _gvn.type(val);
3571   if (val-&gt;is_ValueType() || !TypePtr::NULL_PTR-&gt;higher_equal(val_t)) {
3572     return ary; // Never null
3573   }
3574   RegionNode* region = new RegionNode(3);
3575   Node* null_ctl = top();
3576   null_check_oop(val, &amp;null_ctl);
3577   if (null_ctl != top()) {
3578     PreserveJVMState pjvms(this);
3579     set_control(null_ctl);
<span class="line-modified">3580     {</span>
<span class="line-modified">3581       // Deoptimize if null-free array</span>
<span class="line-modified">3582       BuildCutout unless(this, is_nullable_array(ary), PROB_MAX);</span>
3583       inc_sp(nargs);
3584       uncommon_trap(Deoptimization::Reason_null_check,
3585                     Deoptimization::Action_none);
3586     }
3587     region-&gt;init_req(1, control());
3588   }
3589   region-&gt;init_req(2, control());
3590   set_control(_gvn.transform(region));
3591   record_for_igvn(region);
3592   const TypeAryPtr* ary_t = _gvn.type(ary)-&gt;is_aryptr();
3593   if (val_t == TypePtr::NULL_PTR &amp;&amp; !ary_t-&gt;is_not_null_free()) {
3594     // Since we were just successfully storing null, the array can&#39;t be null free.
3595     ary_t = ary_t-&gt;cast_to_not_null_free();
3596     Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));
3597     if (safe_for_replace) {
3598       replace_in_map(ary, cast);
3599     }
3600     ary = cast;
3601   }
3602   return ary;
3603 }
3604 
3605 Node* GraphKit::load_lh_array_tag(Node* kls) {
3606   Node* lhp = basic_plus_adr(kls, in_bytes(Klass::layout_helper_offset()));
3607   Node* layout_val = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), lhp, lhp-&gt;bottom_type()-&gt;is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));

3608   return _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));
3609 }
3610 

3611 Node* GraphKit::gen_lh_array_test(Node* kls, unsigned int lh_value) {
3612   Node* layout_val = load_lh_array_tag(kls);
3613   Node* cmp = _gvn.transform(new CmpINode(layout_val, intcon(lh_value)));
3614   return cmp;
3615 }
3616 

3617 //------------------------------next_monitor-----------------------------------
3618 // What number should be given to the next monitor?
3619 int GraphKit::next_monitor() {
3620   int current = jvms()-&gt;monitor_depth()* C-&gt;sync_stack_slots();
3621   int next = current + C-&gt;sync_stack_slots();
3622   // Keep the toplevel high water mark current:
3623   if (C-&gt;fixed_slots() &lt; next)  C-&gt;set_fixed_slots(next);
3624   return current;
3625 }
3626 
3627 //------------------------------insert_mem_bar---------------------------------
3628 // Memory barrier to avoid floating things around
3629 // The membar serves as a pinch point between both control and all memory slices.
3630 Node* GraphKit::insert_mem_bar(int opcode, Node* precedent) {
3631   MemBarNode* mb = MemBarNode::make(C, opcode, Compile::AliasIdxBot, precedent);
3632   mb-&gt;init_req(TypeFunc::Control, control());
3633   mb-&gt;init_req(TypeFunc::Memory,  reset_memory());
3634   Node* membar = _gvn.transform(mb);
3635   set_control(_gvn.transform(new ProjNode(membar, TypeFunc::Control)));
3636   set_all_memory_call(membar);
</pre>
<hr />
<pre>
4018 
4019   return set_output_for_allocation(alloc, oop_type, deoptimize_on_exception);
4020 }
4021 
4022 // With compressed oops, the 64 bit init value for non flattened value
4023 // arrays is built from 2 32 bit compressed oops
4024 static Node* raw_default_for_coops(Node* default_value, GraphKit&amp; kit) {
4025   Node* lower = kit.gvn().transform(new CastP2XNode(kit.control(), default_value));
4026   Node* upper = kit.gvn().transform(new LShiftLNode(lower, kit.intcon(32)));
4027   return kit.gvn().transform(new OrLNode(lower, upper));
4028 }
4029 
4030 //-------------------------------new_array-------------------------------------
4031 // helper for newarray and anewarray
4032 // The &#39;length&#39; parameter is (obviously) the length of the array.
4033 // See comments on new_instance for the meaning of the other arguments.
4034 Node* GraphKit::new_array(Node* klass_node,     // array klass (maybe variable)
4035                           Node* length,         // number of array elements
4036                           int   nargs,          // number of arguments to push back for uncommon trap
4037                           Node* *return_size_val,
<span class="line-modified">4038                           bool deoptimize_on_exception) {</span>

4039   jint  layout_con = Klass::_lh_neutral_value;
4040   Node* layout_val = get_layout_helper(klass_node, layout_con);
4041   bool  layout_is_con = (layout_val == NULL);
4042 
4043   if (!layout_is_con &amp;&amp; !StressReflectiveCode &amp;&amp;
4044       !too_many_traps(Deoptimization::Reason_class_check)) {
4045     // This is a reflective array creation site.
4046     // Optimistically assume that it is a subtype of Object[],
4047     // so that we can fold up all the address arithmetic.
4048     layout_con = Klass::array_layout_helper(T_OBJECT);
4049     Node* cmp_lh = _gvn.transform( new CmpINode(layout_val, intcon(layout_con)) );
4050     Node* bol_lh = _gvn.transform( new BoolNode(cmp_lh, BoolTest::eq) );
4051     { BuildCutout unless(this, bol_lh, PROB_MAX);
4052       inc_sp(nargs);
4053       uncommon_trap(Deoptimization::Reason_class_check,
4054                     Deoptimization::Action_maybe_recompile);
4055     }
4056     layout_val = NULL;
4057     layout_is_con = true;
4058   }
</pre>
<hr />
<pre>
4165   }
4166   // else if round_mask == 0, the size computation is self-rounding
4167 
4168   if (return_size_val != NULL) {
4169     // This is the size
4170     (*return_size_val) = size;
4171   }
4172 
4173   // Now generate allocation code
4174 
4175   // The entire memory state is needed for slow path of the allocation
4176   // since GC and deoptimization can happen.
4177   Node *mem = reset_memory();
4178   set_all_memory(mem); // Create new memory state
4179 
4180   if (initial_slow_test-&gt;is_Bool()) {
4181     // Hide it behind a CMoveI, or else PhaseIdealLoop::split_up will get sick.
4182     initial_slow_test = initial_slow_test-&gt;as_Bool()-&gt;as_int_value(&amp;_gvn);
4183   }
4184 
<span class="line-modified">4185   const TypeKlassPtr* ary_klass = _gvn.type(klass_node)-&gt;isa_klassptr();</span>
<span class="line-added">4186   const TypeOopPtr* ary_type = ary_klass-&gt;as_instance_type();</span>
4187   const TypeAryPtr* ary_ptr = ary_type-&gt;isa_aryptr();
<span class="line-modified">4188 </span>
<span class="line-modified">4189   // Value type array variants:</span>
<span class="line-modified">4190   // - null-ok:              MyValue.ref[] (ciObjArrayKlass &quot;[LMyValue$ref&quot;)</span>
<span class="line-modified">4191   // - null-free:            MyValue.val[] (ciObjArrayKlass &quot;[QMyValue$val&quot;)</span>
<span class="line-modified">4192   // - null-free, flattened: MyValue.val[] (ciValueArrayKlass &quot;[QMyValue$val&quot;)</span>
<span class="line-modified">4193   // Check if array is a null-free, non-flattened value type array</span>
<span class="line-modified">4194   // that needs to be initialized with the default value type.</span>

4195   Node* default_value = NULL;
4196   Node* raw_default_value = NULL;

4197   if (ary_ptr != NULL &amp;&amp; ary_ptr-&gt;klass_is_exact()) {
4198     // Array type is known
<span class="line-modified">4199     ciKlass* elem_klass = ary_ptr-&gt;klass()-&gt;as_array_klass()-&gt;element_klass();</span>
<span class="line-modified">4200     if (elem_klass != NULL &amp;&amp; elem_klass-&gt;is_valuetype()) {</span>
<span class="line-modified">4201       ciValueKlass* vk = elem_klass-&gt;as_value_klass();</span>
<span class="line-modified">4202       if (!vk-&gt;flatten_array()) {</span>
<span class="line-modified">4203         default_value = ValueTypeNode::default_oop(gvn(), vk);</span>
<span class="line-modified">4204         if (UseCompressedOops) {</span>
<span class="line-modified">4205           default_value = _gvn.transform(new EncodePNode(default_value, default_value-&gt;bottom_type()-&gt;make_narrowoop()));</span>



4206           raw_default_value = raw_default_for_coops(default_value, *this);
4207         } else {
4208           raw_default_value = _gvn.transform(new CastP2XNode(control(), default_value));
4209         }
4210       }

4211     }
<span class="line-modified">4212   } else if (ary_klass-&gt;klass()-&gt;can_be_value_array_klass()) {</span>
<span class="line-modified">4213     // Array type is not known, add runtime checks</span>
<span class="line-modified">4214     assert(!ary_klass-&gt;klass_is_exact(), &quot;unexpected exact type&quot;);</span>





4215     Node* r = new RegionNode(4);
4216     default_value = new PhiNode(r, TypeInstPtr::BOTTOM);





4217 
<span class="line-modified">4218     // Check if array is an object array</span>
<span class="line-modified">4219     Node* cmp = gen_lh_array_test(klass_node, Klass::_lh_array_tag_obj_value);</span>
<span class="line-added">4220     Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));</span>
<span class="line-added">4221     IfNode* iff = create_and_map_if(control(), bol, PROB_FAIR, COUNT_UNKNOWN);</span>
4222 
<span class="line-modified">4223     // Not an object array, initialize with all zero</span>
4224     r-&gt;init_req(1, _gvn.transform(new IfFalseNode(iff)));
4225     default_value-&gt;init_req(1, null());

4226 
<span class="line-modified">4227     // Object array, check if null-free</span>
4228     set_control(_gvn.transform(new IfTrueNode(iff)));
<span class="line-modified">4229     Node* lhp = basic_plus_adr(klass_node, in_bytes(Klass::layout_helper_offset()));</span>
<span class="line-modified">4230     Node* layout_val = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), lhp, lhp-&gt;bottom_type()-&gt;is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));</span>
<span class="line-added">4231     Node* null_free = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_null_free_shift)));</span>
<span class="line-added">4232     null_free = _gvn.transform(new AndINode(null_free, intcon(Klass::_lh_null_free_mask)));</span>
<span class="line-added">4233     cmp = _gvn.transform(new CmpINode(null_free, intcon(0)));</span>
<span class="line-added">4234     bol = _gvn.transform(new BoolNode(cmp, BoolTest::ne));</span>
4235     iff = create_and_map_if(control(), bol, PROB_FAIR, COUNT_UNKNOWN);
4236 
<span class="line-modified">4237     // Not null-free, initialize with all zero</span>
<span class="line-modified">4238     r-&gt;init_req(2, _gvn.transform(new IfFalseNode(iff)));</span>
4239     default_value-&gt;init_req(2, null());

4240 
<span class="line-modified">4241     // Null-free, non-flattened value array, initialize with the default value</span>
<span class="line-modified">4242     set_control(_gvn.transform(new IfTrueNode(iff)));</span>
4243     Node* p = basic_plus_adr(klass_node, in_bytes(ArrayKlass::element_klass_offset()));
4244     Node* eklass = _gvn.transform(LoadKlassNode::make(_gvn, control(), immutable_memory(), p, TypeInstPtr::KLASS));
4245     Node* adr_fixed_block_addr = basic_plus_adr(eklass, in_bytes(InstanceKlass::adr_valueklass_fixed_block_offset()));
4246     Node* adr_fixed_block = make_load(control(), adr_fixed_block_addr, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);
4247     Node* default_value_offset_addr = basic_plus_adr(adr_fixed_block, in_bytes(ValueKlass::default_value_offset_offset()));
4248     Node* default_value_offset = make_load(control(), default_value_offset_addr, TypeInt::INT, T_INT, MemNode::unordered);
<span class="line-added">4249     Node* elem_mirror = load_mirror_from_klass(eklass);</span>
4250     Node* default_value_addr = basic_plus_adr(elem_mirror, ConvI2X(default_value_offset));
4251     Node* val = access_load_at(elem_mirror, default_value_addr, _gvn.type(default_value_addr)-&gt;is_ptr(), TypeInstPtr::BOTTOM, T_OBJECT, IN_HEAP);
4252     r-&gt;init_req(3, control());
4253     default_value-&gt;init_req(3, val);

4254 
4255     set_control(_gvn.transform(r));
4256     default_value = _gvn.transform(default_value);

4257     if (UseCompressedOops) {
4258       default_value = _gvn.transform(new EncodePNode(default_value, default_value-&gt;bottom_type()-&gt;make_narrowoop()));
4259       raw_default_value = raw_default_for_coops(default_value, *this);
4260     } else {
4261       raw_default_value = _gvn.transform(new CastP2XNode(control(), default_value));
4262     }
4263   }
4264 
4265   // Create the AllocateArrayNode and its result projections
4266   AllocateArrayNode* alloc = new AllocateArrayNode(C, AllocateArrayNode::alloc_type(TypeInt::INT),
4267                                                    control(), mem, i_o(),
4268                                                    size, klass_node,
4269                                                    initial_slow_test,
4270                                                    length, default_value,
<span class="line-modified">4271                                                    raw_default_value);</span>

4272 
4273   // Cast to correct type.  Note that the klass_node may be constant or not,
4274   // and in the latter case the actual array type will be inexact also.
4275   // (This happens via a non-constant argument to inline_native_newArray.)
4276   // In any case, the value of klass_node provides the desired array type.
4277   const TypeInt* length_type = _gvn.find_int_type(length);
4278   if (ary_type-&gt;isa_aryptr() &amp;&amp; length_type != NULL) {
4279     // Try to get a better type than POS for the size
4280     ary_type = ary_type-&gt;is_aryptr()-&gt;cast_to_size(length_type);
4281   }
4282 
4283   Node* javaoop = set_output_for_allocation(alloc, ary_type, deoptimize_on_exception);
4284 
4285   // Cast length on remaining path to be as narrow as possible
4286   if (map()-&gt;find_edge(length) &gt;= 0) {
4287     Node* ccast = alloc-&gt;make_ideal_length(ary_type, &amp;_gvn);
4288     if (ccast != length) {
4289       _gvn.set_type_bottom(ccast);
4290       record_for_igvn(ccast);
4291       replace_in_map(length, ccast);
</pre>
</td>
</tr>
</table>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/ifnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciTypeFlow.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;memory/resourceArea.hpp&quot;
  29 #include &quot;opto/addnode.hpp&quot;
  30 #include &quot;opto/castnode.hpp&quot;
  31 #include &quot;opto/cfgnode.hpp&quot;
  32 #include &quot;opto/connode.hpp&quot;
  33 #include &quot;opto/loopnode.hpp&quot;
  34 #include &quot;opto/phaseX.hpp&quot;
  35 #include &quot;opto/runtime.hpp&quot;
  36 #include &quot;opto/rootnode.hpp&quot;
  37 #include &quot;opto/subnode.hpp&quot;
  38 
  39 // Portions of code courtesy of Clifford Click
  40 
  41 // Optimization - Graph Style
  42 
  43 
  44 #ifndef PRODUCT
  45 extern int explicit_null_checks_elided;
  46 #endif
  47 
  48 //=============================================================================
  49 //------------------------------Value------------------------------------------
  50 // Return a tuple for whichever arm of the IF is reachable
  51 const Type* IfNode::Value(PhaseGVN* phase) const {
  52   if( !in(0) ) return Type::TOP;
  53   if( phase-&gt;type(in(0)) == Type::TOP )
  54     return Type::TOP;
  55   const Type *t = phase-&gt;type(in(1));
  56   if( t == Type::TOP )          // data is undefined
  57     return TypeTuple::IFNEITHER; // unreachable altogether
  58   if( t == TypeInt::ZERO )      // zero, or false
  59     return TypeTuple::IFFALSE;  // only false branch is reachable
  60   if( t == TypeInt::ONE )       // 1, or true
  61     return TypeTuple::IFTRUE;   // only true branch is reachable
  62   assert( t == TypeInt::BOOL, &quot;expected boolean type&quot; );
  63 
  64   return TypeTuple::IFBOTH;     // No progress
  65 }
  66 
  67 const RegMask &amp;IfNode::out_RegMask() const {
  68   return RegMask::Empty;
  69 }
  70 
  71 //------------------------------split_if---------------------------------------
  72 // Look for places where we merge constants, then test on the merged value.
  73 // If the IF test will be constant folded on the path with the constant, we
  74 // win by splitting the IF to before the merge point.
  75 static Node* split_if(IfNode *iff, PhaseIterGVN *igvn) {
  76   // I could be a lot more general here, but I&#39;m trying to squeeze this
  77   // in before the Christmas &#39;98 break so I&#39;m gonna be kinda restrictive
  78   // on the patterns I accept.  CNC
  79 
  80   // Look for a compare of a constant and a merged value
  81   Node *i1 = iff-&gt;in(1);
  82   if( !i1-&gt;is_Bool() ) return NULL;
  83   BoolNode *b = i1-&gt;as_Bool();
  84   Node *cmp = b-&gt;in(1);
  85   if( !cmp-&gt;is_Cmp() ) return NULL;
  86   i1 = cmp-&gt;in(1);
  87   if( i1 == NULL || !i1-&gt;is_Phi() ) return NULL;
  88   PhiNode *phi = i1-&gt;as_Phi();
  89   if( phi-&gt;is_copy() ) return NULL;
  90   Node *con2 = cmp-&gt;in(2);
  91   if( !con2-&gt;is_Con() ) return NULL;
  92   // See that the merge point contains some constants
  93   Node *con1=NULL;
  94   uint i4;
  95   for( i4 = 1; i4 &lt; phi-&gt;req(); i4++ ) {
  96     con1 = phi-&gt;in(i4);
  97     if( !con1 ) return NULL;    // Do not optimize partially collapsed merges
  98     if( con1-&gt;is_Con() ) break; // Found a constant
  99     // Also allow null-vs-not-null checks
 100     const TypePtr *tp = igvn-&gt;type(con1)-&gt;isa_ptr();
 101     if( tp &amp;&amp; tp-&gt;_ptr == TypePtr::NotNull )
 102       break;
 103   }
 104   if( i4 &gt;= phi-&gt;req() ) return NULL; // Found no constants
 105 
 106   igvn-&gt;C-&gt;set_has_split_ifs(true); // Has chance for split-if
 107 
 108   // Make sure that the compare can be constant folded away
 109   Node *cmp2 = cmp-&gt;clone();
 110   cmp2-&gt;set_req(1,con1);
 111   cmp2-&gt;set_req(2,con2);
 112   const Type *t = cmp2-&gt;Value(igvn);
 113   // This compare is dead, so whack it!
 114   igvn-&gt;remove_dead_node(cmp2);
 115   if( !t-&gt;singleton() ) return NULL;
 116 
 117   // No intervening control, like a simple Call
 118   Node *r = iff-&gt;in(0);
 119   if( !r-&gt;is_Region() ) return NULL;
 120   if (r-&gt;is_Loop()) return NULL;
 121   if( phi-&gt;region() != r ) return NULL;
 122   // No other users of the cmp/bool
 123   if (b-&gt;outcnt() != 1 || cmp-&gt;outcnt() != 1) {
 124     //tty-&gt;print_cr(&quot;many users of cmp/bool&quot;);
 125     return NULL;
 126   }
 127 
 128   // Make sure we can determine where all the uses of merged values go
 129   for (DUIterator_Fast jmax, j = r-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 130     Node* u = r-&gt;fast_out(j);
 131     if( u == r ) continue;
 132     if( u == iff ) continue;
 133     if( u-&gt;outcnt() == 0 ) continue; // use is dead &amp; ignorable
 134     if( !u-&gt;is_Phi() ) {
 135       /*
 136       if( u-&gt;is_Start() ) {
 137         tty-&gt;print_cr(&quot;Region has inlined start use&quot;);
 138       } else {
 139         tty-&gt;print_cr(&quot;Region has odd use&quot;);
 140         u-&gt;dump(2);
 141       }*/
 142       return NULL;
 143     }
 144     if( u != phi ) {
 145       // CNC - do not allow any other merged value
 146       //tty-&gt;print_cr(&quot;Merging another value&quot;);
 147       //u-&gt;dump(2);
 148       return NULL;
 149     }
 150     // Make sure we can account for all Phi uses
 151     for (DUIterator_Fast kmax, k = u-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 152       Node* v = u-&gt;fast_out(k); // User of the phi
 153       // CNC - Allow only really simple patterns.
 154       // In particular I disallow AddP of the Phi, a fairly common pattern
 155       if (v == cmp) continue;  // The compare is OK
 156       if (v-&gt;is_ConstraintCast()) {
 157         // If the cast is derived from data flow edges, it may not have a control edge.
 158         // If so, it should be safe to split. But follow-up code can not deal with
 159         // this (l. 359). So skip.
 160         if (v-&gt;in(0) == NULL) {
 161           return NULL;
 162         }
 163         if (v-&gt;in(0)-&gt;in(0) == iff) {
 164           continue;               // CastPP/II of the IfNode is OK
 165         }
 166       }
 167       // Disabled following code because I cannot tell if exactly one
 168       // path dominates without a real dominator check. CNC 9/9/1999
 169       //uint vop = v-&gt;Opcode();
 170       //if( vop == Op_Phi ) {     // Phi from another merge point might be OK
 171       //  Node *r = v-&gt;in(0);     // Get controlling point
 172       //  if( !r ) return NULL;   // Degraded to a copy
 173       //  // Find exactly one path in (either True or False doms, but not IFF)
 174       //  int cnt = 0;
 175       //  for( uint i = 1; i &lt; r-&gt;req(); i++ )
 176       //    if( r-&gt;in(i) &amp;&amp; r-&gt;in(i)-&gt;in(0) == iff )
 177       //      cnt++;
 178       //  if( cnt == 1 ) continue; // Exactly one of True or False guards Phi
 179       //}
 180       if( !v-&gt;is_Call() ) {
 181         /*
 182         if( v-&gt;Opcode() == Op_AddP ) {
 183           tty-&gt;print_cr(&quot;Phi has AddP use&quot;);
 184         } else if( v-&gt;Opcode() == Op_CastPP ) {
 185           tty-&gt;print_cr(&quot;Phi has CastPP use&quot;);
 186         } else if( v-&gt;Opcode() == Op_CastII ) {
 187           tty-&gt;print_cr(&quot;Phi has CastII use&quot;);
 188         } else {
 189           tty-&gt;print_cr(&quot;Phi has use I cant be bothered with&quot;);
 190         }
 191         */
 192       }
 193       return NULL;
 194 
 195       /* CNC - Cut out all the fancy acceptance tests
 196       // Can we clone this use when doing the transformation?
 197       // If all uses are from Phis at this merge or constants, then YES.
 198       if( !v-&gt;in(0) &amp;&amp; v != cmp ) {
 199         tty-&gt;print_cr(&quot;Phi has free-floating use&quot;);
 200         v-&gt;dump(2);
 201         return NULL;
 202       }
 203       for( uint l = 1; l &lt; v-&gt;req(); l++ ) {
 204         if( (!v-&gt;in(l)-&gt;is_Phi() || v-&gt;in(l)-&gt;in(0) != r) &amp;&amp;
 205             !v-&gt;in(l)-&gt;is_Con() ) {
 206           tty-&gt;print_cr(&quot;Phi has use&quot;);
 207           v-&gt;dump(2);
 208           return NULL;
 209         } // End of if Phi-use input is neither Phi nor Constant
 210       } // End of for all inputs to Phi-use
 211       */
 212     } // End of for all uses of Phi
 213   } // End of for all uses of Region
 214 
 215   // Only do this if the IF node is in a sane state
 216   if (iff-&gt;outcnt() != 2)
 217     return NULL;
 218 
 219   // Got a hit!  Do the Mondo Hack!
 220   //
 221   //ABC  a1c   def   ghi            B     1     e     h   A C   a c   d f   g i
 222   // R - Phi - Phi - Phi            Rc - Phi - Phi - Phi   Rx - Phi - Phi - Phi
 223   //     cmp - 2                         cmp - 2               cmp - 2
 224   //       bool                            bool_c                bool_x
 225   //       if                               if_c                  if_x
 226   //      T  F                              T  F                  T  F
 227   // ..s..    ..t ..                   ..s..    ..t..        ..s..    ..t..
 228   //
 229   // Split the paths coming into the merge point into 2 separate groups of
 230   // merges.  On the left will be all the paths feeding constants into the
 231   // Cmp&#39;s Phi.  On the right will be the remaining paths.  The Cmp&#39;s Phi
 232   // will fold up into a constant; this will let the Cmp fold up as well as
 233   // all the control flow.  Below the original IF we have 2 control
 234   // dependent regions, &#39;s&#39; and &#39;t&#39;.  Now we will merge the two paths
 235   // just prior to &#39;s&#39; and &#39;t&#39; from the two IFs.  At least 1 path (and quite
 236   // likely 2 or more) will promptly constant fold away.
 237   PhaseGVN *phase = igvn;
 238 
 239   // Make a region merging constants and a region merging the rest
 240   uint req_c = 0;
 241   for (uint ii = 1; ii &lt; r-&gt;req(); ii++) {
 242     if (phi-&gt;in(ii) == con1) {
 243       req_c++;
 244     }
 245     Node* proj = PhaseIdealLoop::find_predicate(r-&gt;in(ii));
 246     if (proj != NULL) {
 247       return NULL;
 248     }
 249   }
 250 
 251   // If all the defs of the phi are the same constant, we already have the desired end state.
 252   // Skip the split that would create empty phi and region nodes.
 253   if((r-&gt;req() - req_c) == 1) {
 254     return NULL;
 255   }
 256 
 257   Node *region_c = new RegionNode(req_c + 1);
 258   Node *phi_c    = con1;
 259   uint  len      = r-&gt;req();
 260   Node *region_x = new RegionNode(len - req_c);
 261   Node *phi_x    = PhiNode::make_blank(region_x, phi);
 262   for (uint i = 1, i_c = 1, i_x = 1; i &lt; len; i++) {
 263     if (phi-&gt;in(i) == con1) {
 264       region_c-&gt;init_req( i_c++, r  -&gt;in(i) );
 265     } else {
 266       region_x-&gt;init_req( i_x,   r  -&gt;in(i) );
 267       phi_x   -&gt;init_req( i_x++, phi-&gt;in(i) );
 268     }
 269   }
 270 
 271   // Register the new RegionNodes but do not transform them.  Cannot
 272   // transform until the entire Region/Phi conglomerate has been hacked
 273   // as a single huge transform.
 274   igvn-&gt;register_new_node_with_optimizer( region_c );
 275   igvn-&gt;register_new_node_with_optimizer( region_x );
 276   // Prevent the untimely death of phi_x.  Currently he has no uses.  He is
 277   // about to get one.  If this only use goes away, then phi_x will look dead.
 278   // However, he will be picking up some more uses down below.
 279   Node *hook = new Node(4);
 280   hook-&gt;init_req(0, phi_x);
 281   hook-&gt;init_req(1, phi_c);
 282   phi_x = phase-&gt;transform( phi_x );
 283 
 284   // Make the compare
 285   Node *cmp_c = phase-&gt;makecon(t);
 286   Node *cmp_x = cmp-&gt;clone();
 287   cmp_x-&gt;set_req(1,phi_x);
 288   cmp_x-&gt;set_req(2,con2);
 289   cmp_x = phase-&gt;transform(cmp_x);
 290   // Make the bool
 291   Node *b_c = phase-&gt;transform(new BoolNode(cmp_c,b-&gt;_test._test));
 292   Node *b_x = phase-&gt;transform(new BoolNode(cmp_x,b-&gt;_test._test));
 293   // Make the IfNode
 294   IfNode* iff_c = iff-&gt;clone()-&gt;as_If();
 295   iff_c-&gt;set_req(0, region_c);
 296   iff_c-&gt;set_req(1, b_c);
 297   igvn-&gt;set_type_bottom(iff_c);
 298   igvn-&gt;_worklist.push(iff_c);
 299   hook-&gt;init_req(2, iff_c);
 300 
 301   IfNode* iff_x = iff-&gt;clone()-&gt;as_If();
 302   iff_x-&gt;set_req(0, region_x);
 303   iff_x-&gt;set_req(1, b_x);
 304   igvn-&gt;set_type_bottom(iff_x);
 305   igvn-&gt;_worklist.push(iff_x);
 306   hook-&gt;init_req(3, iff_x);
 307 
 308   // Make the true/false arms
 309   Node *iff_c_t = phase-&gt;transform(new IfTrueNode (iff_c));
 310   Node *iff_c_f = phase-&gt;transform(new IfFalseNode(iff_c));
 311   Node *iff_x_t = phase-&gt;transform(new IfTrueNode (iff_x));
 312   Node *iff_x_f = phase-&gt;transform(new IfFalseNode(iff_x));
 313 
 314   // Merge the TRUE paths
 315   Node *region_s = new RegionNode(3);
 316   igvn-&gt;_worklist.push(region_s);
 317   region_s-&gt;init_req(1, iff_c_t);
 318   region_s-&gt;init_req(2, iff_x_t);
 319   igvn-&gt;register_new_node_with_optimizer( region_s );
 320 
 321   // Merge the FALSE paths
 322   Node *region_f = new RegionNode(3);
 323   igvn-&gt;_worklist.push(region_f);
 324   region_f-&gt;init_req(1, iff_c_f);
 325   region_f-&gt;init_req(2, iff_x_f);
 326   igvn-&gt;register_new_node_with_optimizer( region_f );
 327 
 328   igvn-&gt;hash_delete(cmp);// Remove soon-to-be-dead node from hash table.
 329   cmp-&gt;set_req(1,NULL);  // Whack the inputs to cmp because it will be dead
 330   cmp-&gt;set_req(2,NULL);
 331   // Check for all uses of the Phi and give them a new home.
 332   // The &#39;cmp&#39; got cloned, but CastPP/IIs need to be moved.
 333   Node *phi_s = NULL;     // do not construct unless needed
 334   Node *phi_f = NULL;     // do not construct unless needed
 335   for (DUIterator_Last i2min, i2 = phi-&gt;last_outs(i2min); i2 &gt;= i2min; --i2) {
 336     Node* v = phi-&gt;last_out(i2);// User of the phi
 337     igvn-&gt;rehash_node_delayed(v); // Have to fixup other Phi users
 338     uint vop = v-&gt;Opcode();
 339     Node *proj = NULL;
 340     if( vop == Op_Phi ) {       // Remote merge point
 341       Node *r = v-&gt;in(0);
 342       for (uint i3 = 1; i3 &lt; r-&gt;req(); i3++)
 343         if (r-&gt;in(i3) &amp;&amp; r-&gt;in(i3)-&gt;in(0) == iff) {
 344           proj = r-&gt;in(i3);
 345           break;
 346         }
 347     } else if( v-&gt;is_ConstraintCast() ) {
 348       proj = v-&gt;in(0);          // Controlling projection
 349     } else {
 350       assert( 0, &quot;do not know how to handle this guy&quot; );
 351     }
 352     guarantee(proj != NULL, &quot;sanity&quot;);
 353 
 354     Node *proj_path_data, *proj_path_ctrl;
 355     if( proj-&gt;Opcode() == Op_IfTrue ) {
 356       if( phi_s == NULL ) {
 357         // Only construct phi_s if needed, otherwise provides
 358         // interfering use.
 359         phi_s = PhiNode::make_blank(region_s,phi);
 360         phi_s-&gt;init_req( 1, phi_c );
 361         phi_s-&gt;init_req( 2, phi_x );
 362         hook-&gt;add_req(phi_s);
 363         phi_s = phase-&gt;transform(phi_s);
 364       }
 365       proj_path_data = phi_s;
 366       proj_path_ctrl = region_s;
 367     } else {
 368       if( phi_f == NULL ) {
 369         // Only construct phi_f if needed, otherwise provides
 370         // interfering use.
 371         phi_f = PhiNode::make_blank(region_f,phi);
 372         phi_f-&gt;init_req( 1, phi_c );
 373         phi_f-&gt;init_req( 2, phi_x );
 374         hook-&gt;add_req(phi_f);
 375         phi_f = phase-&gt;transform(phi_f);
 376       }
 377       proj_path_data = phi_f;
 378       proj_path_ctrl = region_f;
 379     }
 380 
 381     // Fixup &#39;v&#39; for for the split
 382     if( vop == Op_Phi ) {       // Remote merge point
 383       uint i;
 384       for( i = 1; i &lt; v-&gt;req(); i++ )
 385         if( v-&gt;in(i) == phi )
 386           break;
 387       v-&gt;set_req(i, proj_path_data );
 388     } else if( v-&gt;is_ConstraintCast() ) {
 389       v-&gt;set_req(0, proj_path_ctrl );
 390       v-&gt;set_req(1, proj_path_data );
 391     } else
 392       ShouldNotReachHere();
 393   }
 394 
 395   // Now replace the original iff&#39;s True/False with region_s/region_t.
 396   // This makes the original iff go dead.
 397   for (DUIterator_Last i3min, i3 = iff-&gt;last_outs(i3min); i3 &gt;= i3min; --i3) {
 398     Node* p = iff-&gt;last_out(i3);
 399     assert( p-&gt;Opcode() == Op_IfTrue || p-&gt;Opcode() == Op_IfFalse, &quot;&quot; );
 400     Node *u = (p-&gt;Opcode() == Op_IfTrue) ? region_s : region_f;
 401     // Replace p with u
 402     igvn-&gt;add_users_to_worklist(p);
 403     for (DUIterator_Last lmin, l = p-&gt;last_outs(lmin); l &gt;= lmin;) {
 404       Node* x = p-&gt;last_out(l);
 405       igvn-&gt;hash_delete(x);
 406       uint uses_found = 0;
 407       for( uint j = 0; j &lt; x-&gt;req(); j++ ) {
 408         if( x-&gt;in(j) == p ) {
 409           x-&gt;set_req(j, u);
 410           uses_found++;
 411         }
 412       }
 413       l -= uses_found;    // we deleted 1 or more copies of this edge
 414     }
 415     igvn-&gt;remove_dead_node(p);
 416   }
 417 
 418   // Force the original merge dead
 419   igvn-&gt;hash_delete(r);
 420   // First, remove region&#39;s dead users.
 421   for (DUIterator_Last lmin, l = r-&gt;last_outs(lmin); l &gt;= lmin;) {
 422     Node* u = r-&gt;last_out(l);
 423     if( u == r ) {
 424       r-&gt;set_req(0, NULL);
 425     } else {
 426       assert(u-&gt;outcnt() == 0, &quot;only dead users&quot;);
 427       igvn-&gt;remove_dead_node(u);
 428     }
 429     l -= 1;
 430   }
 431   igvn-&gt;remove_dead_node(r);
 432 
 433   // Now remove the bogus extra edges used to keep things alive
 434   igvn-&gt;remove_dead_node( hook );
 435 
 436   // Must return either the original node (now dead) or a new node
 437   // (Do not return a top here, since that would break the uniqueness of top.)
 438   return new ConINode(TypeInt::ZERO);
 439 }
 440 
 441 // if this IfNode follows a range check pattern return the projection
 442 // for the failed path
 443 ProjNode* IfNode::range_check_trap_proj(int&amp; flip_test, Node*&amp; l, Node*&amp; r) {
 444   if (outcnt() != 2) {
 445     return NULL;
 446   }
 447   Node* b = in(1);
 448   if (b == NULL || !b-&gt;is_Bool())  return NULL;
 449   BoolNode* bn = b-&gt;as_Bool();
 450   Node* cmp = bn-&gt;in(1);
 451   if (cmp == NULL)  return NULL;
 452   if (cmp-&gt;Opcode() != Op_CmpU)  return NULL;
 453 
 454   l = cmp-&gt;in(1);
 455   r = cmp-&gt;in(2);
 456   flip_test = 1;
 457   if (bn-&gt;_test._test == BoolTest::le) {
 458     l = cmp-&gt;in(2);
 459     r = cmp-&gt;in(1);
 460     flip_test = 2;
 461   } else if (bn-&gt;_test._test != BoolTest::lt) {
 462     return NULL;
 463   }
 464   if (l-&gt;is_top())  return NULL;   // Top input means dead test
 465   if (r-&gt;Opcode() != Op_LoadRange &amp;&amp; !is_RangeCheck())  return NULL;
 466 
 467   // We have recognized one of these forms:
 468   //  Flip 1:  If (Bool[&lt;] CmpU(l, LoadRange)) ...
 469   //  Flip 2:  If (Bool[&lt;=] CmpU(LoadRange, l)) ...
 470 
 471   ProjNode* iftrap = proj_out_or_null(flip_test == 2 ? true : false);
 472   return iftrap;
 473 }
 474 
 475 
 476 //------------------------------is_range_check---------------------------------
 477 // Return 0 if not a range check.  Return 1 if a range check and set index and
 478 // offset.  Return 2 if we had to negate the test.  Index is NULL if the check
 479 // is versus a constant.
 480 int RangeCheckNode::is_range_check(Node* &amp;range, Node* &amp;index, jint &amp;offset) {
 481   int flip_test = 0;
 482   Node* l = NULL;
 483   Node* r = NULL;
 484   ProjNode* iftrap = range_check_trap_proj(flip_test, l, r);
 485 
 486   if (iftrap == NULL) {
 487     return 0;
 488   }
 489 
 490   // Make sure it&#39;s a real range check by requiring an uncommon trap
 491   // along the OOB path.  Otherwise, it&#39;s possible that the user wrote
 492   // something which optimized to look like a range check but behaves
 493   // in some other way.
 494   if (iftrap-&gt;is_uncommon_trap_proj(Deoptimization::Reason_range_check) == NULL) {
 495     return 0;
 496   }
 497 
 498   // Look for index+offset form
 499   Node* ind = l;
 500   jint  off = 0;
 501   if (l-&gt;is_top()) {
 502     return 0;
 503   } else if (l-&gt;Opcode() == Op_AddI) {
 504     if ((off = l-&gt;in(1)-&gt;find_int_con(0)) != 0) {
 505       ind = l-&gt;in(2)-&gt;uncast();
 506     } else if ((off = l-&gt;in(2)-&gt;find_int_con(0)) != 0) {
 507       ind = l-&gt;in(1)-&gt;uncast();
 508     }
 509   } else if ((off = l-&gt;find_int_con(-1)) &gt;= 0) {
 510     // constant offset with no variable index
 511     ind = NULL;
 512   } else {
 513     // variable index with no constant offset (or dead negative index)
 514     off = 0;
 515   }
 516 
 517   // Return all the values:
 518   index  = ind;
 519   offset = off;
 520   range  = r;
 521   return flip_test;
 522 }
 523 
 524 //------------------------------adjust_check-----------------------------------
 525 // Adjust (widen) a prior range check
 526 static void adjust_check(Node* proj, Node* range, Node* index,
 527                          int flip, jint off_lo, PhaseIterGVN* igvn) {
 528   PhaseGVN *gvn = igvn;
 529   // Break apart the old check
 530   Node *iff = proj-&gt;in(0);
 531   Node *bol = iff-&gt;in(1);
 532   if( bol-&gt;is_top() ) return;   // In case a partially dead range check appears
 533   // bail (or bomb[ASSERT/DEBUG]) if NOT projection--&gt;IfNode--&gt;BoolNode
 534   DEBUG_ONLY( if( !bol-&gt;is_Bool() ) { proj-&gt;dump(3); fatal(&quot;Expect projection--&gt;IfNode--&gt;BoolNode&quot;); } )
 535   if( !bol-&gt;is_Bool() ) return;
 536 
 537   Node *cmp = bol-&gt;in(1);
 538   // Compute a new check
 539   Node *new_add = gvn-&gt;intcon(off_lo);
 540   if( index ) {
 541     new_add = off_lo ? gvn-&gt;transform(new AddINode( index, new_add )) : index;
 542   }
 543   Node *new_cmp = (flip == 1)
 544     ? new CmpUNode( new_add, range )
 545     : new CmpUNode( range, new_add );
 546   new_cmp = gvn-&gt;transform(new_cmp);
 547   // See if no need to adjust the existing check
 548   if( new_cmp == cmp ) return;
 549   // Else, adjust existing check
 550   Node *new_bol = gvn-&gt;transform( new BoolNode( new_cmp, bol-&gt;as_Bool()-&gt;_test._test ) );
 551   igvn-&gt;rehash_node_delayed( iff );
 552   iff-&gt;set_req_X( 1, new_bol, igvn );
 553 }
 554 
 555 //------------------------------up_one_dom-------------------------------------
 556 // Walk up the dominator tree one step.  Return NULL at root or true
 557 // complex merges.  Skips through small diamonds.
 558 Node* IfNode::up_one_dom(Node *curr, bool linear_only) {
 559   Node *dom = curr-&gt;in(0);
 560   if( !dom )                    // Found a Region degraded to a copy?
 561     return curr-&gt;nonnull_req(); // Skip thru it
 562 
 563   if( curr != dom )             // Normal walk up one step?
 564     return dom;
 565 
 566   // Use linear_only if we are still parsing, since we cannot
 567   // trust the regions to be fully filled in.
 568   if (linear_only)
 569     return NULL;
 570 
 571   if( dom-&gt;is_Root() )
 572     return NULL;
 573 
 574   // Else hit a Region.  Check for a loop header
 575   if( dom-&gt;is_Loop() )
 576     return dom-&gt;in(1);          // Skip up thru loops
 577 
 578   // Check for small diamonds
 579   Node *din1, *din2, *din3, *din4;
 580   if( dom-&gt;req() == 3 &amp;&amp;        // 2-path merge point
 581       (din1 = dom -&gt;in(1)) &amp;&amp;   // Left  path exists
 582       (din2 = dom -&gt;in(2)) &amp;&amp;   // Right path exists
 583       (din3 = din1-&gt;in(0)) &amp;&amp;   // Left  path up one
 584       (din4 = din2-&gt;in(0)) ) {  // Right path up one
 585     if( din3-&gt;is_Call() &amp;&amp;      // Handle a slow-path call on either arm
 586         (din3 = din3-&gt;in(0)) )
 587       din3 = din3-&gt;in(0);
 588     if( din4-&gt;is_Call() &amp;&amp;      // Handle a slow-path call on either arm
 589         (din4 = din4-&gt;in(0)) )
 590       din4 = din4-&gt;in(0);
 591     if (din3 != NULL &amp;&amp; din3 == din4 &amp;&amp; din3-&gt;is_If()) // Regions not degraded to a copy
 592       return din3;              // Skip around diamonds
 593   }
 594 
 595   // Give up the search at true merges
 596   return NULL;                  // Dead loop?  Or hit root?
 597 }
 598 
 599 
 600 //------------------------------filtered_int_type--------------------------------
 601 // Return a possibly more restrictive type for val based on condition control flow for an if
 602 const TypeInt* IfNode::filtered_int_type(PhaseGVN* gvn, Node* val, Node* if_proj) {
 603   assert(if_proj &amp;&amp;
 604          (if_proj-&gt;Opcode() == Op_IfTrue || if_proj-&gt;Opcode() == Op_IfFalse), &quot;expecting an if projection&quot;);
 605   if (if_proj-&gt;in(0) &amp;&amp; if_proj-&gt;in(0)-&gt;is_If()) {
 606     IfNode* iff = if_proj-&gt;in(0)-&gt;as_If();
 607     if (iff-&gt;in(1) &amp;&amp; iff-&gt;in(1)-&gt;is_Bool()) {
 608       BoolNode* bol = iff-&gt;in(1)-&gt;as_Bool();
 609       if (bol-&gt;in(1) &amp;&amp; bol-&gt;in(1)-&gt;is_Cmp()) {
 610         const CmpNode* cmp  = bol-&gt;in(1)-&gt;as_Cmp();
 611         if (cmp-&gt;in(1) == val) {
 612           const TypeInt* cmp2_t = gvn-&gt;type(cmp-&gt;in(2))-&gt;isa_int();
 613           if (cmp2_t != NULL) {
 614             jint lo = cmp2_t-&gt;_lo;
 615             jint hi = cmp2_t-&gt;_hi;
 616             BoolTest::mask msk = if_proj-&gt;Opcode() == Op_IfTrue ? bol-&gt;_test._test : bol-&gt;_test.negate();
 617             switch (msk) {
 618             case BoolTest::ne: {
 619               // If val is compared to its lower or upper bound, we can narrow the type
 620               const TypeInt* val_t = gvn-&gt;type(val)-&gt;isa_int();
 621               if (val_t != NULL &amp;&amp; !val_t-&gt;singleton() &amp;&amp; cmp2_t-&gt;is_con()) {
 622                 if (val_t-&gt;_lo == lo) {
 623                   return TypeInt::make(val_t-&gt;_lo + 1, val_t-&gt;_hi, val_t-&gt;_widen);
 624                 } else if (val_t-&gt;_hi == hi) {
 625                   return TypeInt::make(val_t-&gt;_lo, val_t-&gt;_hi - 1, val_t-&gt;_widen);
 626                 }
 627               }
 628               // Can&#39;t refine type
 629               return NULL;
 630             }
 631             case BoolTest::eq:
 632               return cmp2_t;
 633             case BoolTest::lt:
 634               lo = TypeInt::INT-&gt;_lo;
 635               if (hi - 1 &lt; hi) {
 636                 hi = hi - 1;
 637               }
 638               break;
 639             case BoolTest::le:
 640               lo = TypeInt::INT-&gt;_lo;
 641               break;
 642             case BoolTest::gt:
 643               if (lo + 1 &gt; lo) {
 644                 lo = lo + 1;
 645               }
 646               hi = TypeInt::INT-&gt;_hi;
 647               break;
 648             case BoolTest::ge:
 649               // lo unchanged
 650               hi = TypeInt::INT-&gt;_hi;
 651               break;
 652             default:
 653               break;
 654             }
 655             const TypeInt* rtn_t = TypeInt::make(lo, hi, cmp2_t-&gt;_widen);
 656             return rtn_t;
 657           }
 658         }
 659       }
 660     }
 661   }
 662   return NULL;
 663 }
 664 
 665 //------------------------------fold_compares----------------------------
 666 // See if a pair of CmpIs can be converted into a CmpU.  In some cases
 667 // the direction of this if is determined by the preceding if so it
 668 // can be eliminate entirely.
 669 //
 670 // Given an if testing (CmpI n v) check for an immediately control
 671 // dependent if that is testing (CmpI n v2) and has one projection
 672 // leading to this if and the other projection leading to a region
 673 // that merges one of this ifs control projections.
 674 //
 675 //                   If
 676 //                  / |
 677 //                 /  |
 678 //                /   |
 679 //              If    |
 680 //              /\    |
 681 //             /  \   |
 682 //            /    \  |
 683 //           /    Region
 684 //
 685 // Or given an if testing (CmpI n v) check for a dominating if that is
 686 // testing (CmpI n v2), both having one projection leading to an
 687 // uncommon trap. Allow Another independent guard in between to cover
 688 // an explicit range check:
 689 // if (index &lt; 0 || index &gt;= array.length) {
 690 // which may need a null check to guard the LoadRange
 691 //
 692 //                   If
 693 //                  / \
 694 //                 /   \
 695 //                /     \
 696 //              If      unc
 697 //              /\
 698 //             /  \
 699 //            /    \
 700 //           /      unc
 701 //
 702 
 703 // Is the comparison for this If suitable for folding?
 704 bool IfNode::cmpi_folds(PhaseIterGVN* igvn, bool fold_ne) {
 705   return in(1) != NULL &amp;&amp;
 706     in(1)-&gt;is_Bool() &amp;&amp;
 707     in(1)-&gt;in(1) != NULL &amp;&amp;
 708     in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpI &amp;&amp;
 709     in(1)-&gt;in(1)-&gt;in(2) != NULL &amp;&amp;
 710     in(1)-&gt;in(1)-&gt;in(2) != igvn-&gt;C-&gt;top() &amp;&amp;
 711     (in(1)-&gt;as_Bool()-&gt;_test.is_less() ||
 712      in(1)-&gt;as_Bool()-&gt;_test.is_greater() ||
 713      (fold_ne &amp;&amp; in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne));
 714 }
 715 
 716 // Is a dominating control suitable for folding with this if?
 717 bool IfNode::is_ctrl_folds(Node* ctrl, PhaseIterGVN* igvn) {
 718   return ctrl != NULL &amp;&amp;
 719     ctrl-&gt;is_Proj() &amp;&amp;
 720     ctrl-&gt;in(0) != NULL &amp;&amp;
 721     ctrl-&gt;in(0)-&gt;Opcode() == Op_If &amp;&amp;
 722     ctrl-&gt;in(0)-&gt;outcnt() == 2 &amp;&amp;
 723     ctrl-&gt;in(0)-&gt;as_If()-&gt;cmpi_folds(igvn, true) &amp;&amp;
 724     // Must compare same value
 725     ctrl-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;
 726     ctrl-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == in(1)-&gt;in(1)-&gt;in(1);
 727 }
 728 
 729 // Do this If and the dominating If share a region?
 730 bool IfNode::has_shared_region(ProjNode* proj, ProjNode*&amp; success, ProjNode*&amp; fail) {
 731   ProjNode* otherproj = proj-&gt;other_if_proj();
 732   Node* otherproj_ctrl_use = otherproj-&gt;unique_ctrl_out();
 733   RegionNode* region = (otherproj_ctrl_use != NULL &amp;&amp; otherproj_ctrl_use-&gt;is_Region()) ? otherproj_ctrl_use-&gt;as_Region() : NULL;
 734   success = NULL;
 735   fail = NULL;
 736 
 737   if (otherproj-&gt;outcnt() == 1 &amp;&amp; region != NULL &amp;&amp; !region-&gt;has_phi()) {
 738     for (int i = 0; i &lt; 2; i++) {
 739       ProjNode* proj = proj_out(i);
 740       if (success == NULL &amp;&amp; proj-&gt;outcnt() == 1 &amp;&amp; proj-&gt;unique_out() == region) {
 741         success = proj;
 742       } else if (fail == NULL) {
 743         fail = proj;
 744       } else {
 745         success = fail = NULL;
 746       }
 747     }
 748   }
 749   return success != NULL &amp;&amp; fail != NULL;
 750 }
 751 
 752 bool IfNode::is_dominator_unc(CallStaticJavaNode* dom_unc, CallStaticJavaNode* unc) {
 753   // Different methods and methods containing jsrs are not supported.
 754   ciMethod* method = unc-&gt;jvms()-&gt;method();
 755   ciMethod* dom_method = dom_unc-&gt;jvms()-&gt;method();
 756   if (method != dom_method || method-&gt;has_jsrs()) {
 757     return false;
 758   }
 759   // Check that both traps are in the same activation of the method (instead
 760   // of two activations being inlined through different call sites) by verifying
 761   // that the call stacks are equal for both JVMStates.
 762   JVMState* dom_caller = dom_unc-&gt;jvms()-&gt;caller();
 763   JVMState* caller = unc-&gt;jvms()-&gt;caller();
 764   if ((dom_caller == NULL) != (caller == NULL)) {
 765     // The current method must either be inlined into both dom_caller and
 766     // caller or must not be inlined at all (top method). Bail out otherwise.
 767     return false;
 768   } else if (dom_caller != NULL &amp;&amp; !dom_caller-&gt;same_calls_as(caller)) {
 769     return false;
 770   }
 771   // Check that the bci of the dominating uncommon trap dominates the bci
 772   // of the dominated uncommon trap. Otherwise we may not re-execute
 773   // the dominated check after deoptimization from the merged uncommon trap.
 774   ciTypeFlow* flow = dom_method-&gt;get_flow_analysis();
 775   int bci = unc-&gt;jvms()-&gt;bci();
 776   int dom_bci = dom_unc-&gt;jvms()-&gt;bci();
 777   if (!flow-&gt;is_dominated_by(bci, dom_bci)) {
 778     return false;
 779   }
 780 
 781   return true;
 782 }
 783 
 784 // Return projection that leads to an uncommon trap if any
 785 ProjNode* IfNode::uncommon_trap_proj(CallStaticJavaNode*&amp; call) const {
 786   for (int i = 0; i &lt; 2; i++) {
 787     call = proj_out(i)-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none);
 788     if (call != NULL) {
 789       return proj_out(i);
 790     }
 791   }
 792   return NULL;
 793 }
 794 
 795 // Do this If and the dominating If both branch out to an uncommon trap
 796 bool IfNode::has_only_uncommon_traps(ProjNode* proj, ProjNode*&amp; success, ProjNode*&amp; fail, PhaseIterGVN* igvn) {
 797   ProjNode* otherproj = proj-&gt;other_if_proj();
 798   CallStaticJavaNode* dom_unc = otherproj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none);
 799 
 800   if (otherproj-&gt;outcnt() == 1 &amp;&amp; dom_unc != NULL) {
 801     // We need to re-execute the folded Ifs after deoptimization from the merged traps
 802     if (!dom_unc-&gt;jvms()-&gt;should_reexecute()) {
 803       return false;
 804     }
 805 
 806     CallStaticJavaNode* unc = NULL;
 807     ProjNode* unc_proj = uncommon_trap_proj(unc);
 808     if (unc_proj != NULL &amp;&amp; unc_proj-&gt;outcnt() == 1) {
 809       if (dom_unc == unc) {
 810         // Allow the uncommon trap to be shared through a region
 811         RegionNode* r = unc-&gt;in(0)-&gt;as_Region();
 812         if (r-&gt;outcnt() != 2 || r-&gt;req() != 3 || r-&gt;find_edge(otherproj) == -1 || r-&gt;find_edge(unc_proj) == -1) {
 813           return false;
 814         }
 815         assert(r-&gt;has_phi() == NULL, &quot;simple region shouldn&#39;t have a phi&quot;);
 816       } else if (dom_unc-&gt;in(0) != otherproj || unc-&gt;in(0) != unc_proj) {
 817         return false;
 818       }
 819 
 820       if (!is_dominator_unc(dom_unc, unc)) {
 821         return false;
 822       }
 823 
 824       // See merge_uncommon_traps: the reason of the uncommon trap
 825       // will be changed and the state of the dominating If will be
 826       // used. Checked that we didn&#39;t apply this transformation in a
 827       // previous compilation and it didn&#39;t cause too many traps
 828       ciMethod* dom_method = dom_unc-&gt;jvms()-&gt;method();
 829       int dom_bci = dom_unc-&gt;jvms()-&gt;bci();
 830       if (!igvn-&gt;C-&gt;too_many_traps(dom_method, dom_bci, Deoptimization::Reason_unstable_fused_if) &amp;&amp;
 831           !igvn-&gt;C-&gt;too_many_traps(dom_method, dom_bci, Deoptimization::Reason_range_check)) {
 832         success = unc_proj;
 833         fail = unc_proj-&gt;other_if_proj();
 834         return true;
 835       }
 836     }
 837   }
 838   return false;
 839 }
 840 
 841 // Check that the 2 CmpI can be folded into as single CmpU and proceed with the folding
 842 bool IfNode::fold_compares_helper(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn) {
 843   Node* this_cmp = in(1)-&gt;in(1);
 844   BoolNode* this_bool = in(1)-&gt;as_Bool();
 845   IfNode* dom_iff = proj-&gt;in(0)-&gt;as_If();
 846   BoolNode* dom_bool = dom_iff-&gt;in(1)-&gt;as_Bool();
 847   Node* lo = dom_iff-&gt;in(1)-&gt;in(1)-&gt;in(2);
 848   Node* hi = this_cmp-&gt;in(2);
 849   Node* n = this_cmp-&gt;in(1);
 850   ProjNode* otherproj = proj-&gt;other_if_proj();
 851 
 852   const TypeInt* lo_type = IfNode::filtered_int_type(igvn, n, otherproj);
 853   const TypeInt* hi_type = IfNode::filtered_int_type(igvn, n, success);
 854 
 855   BoolTest::mask lo_test = dom_bool-&gt;_test._test;
 856   BoolTest::mask hi_test = this_bool-&gt;_test._test;
 857   BoolTest::mask cond = hi_test;
 858 
 859   // convert:
 860   //
 861   //          dom_bool = x {&lt;,&lt;=,&gt;,&gt;=} a
 862   //                           / \
 863   //     proj = {True,False}  /   \ otherproj = {False,True}
 864   //                         /
 865   //        this_bool = x {&lt;,&lt;=} b
 866   //                       / \
 867   //  fail = {True,False} /   \ success = {False,True}
 868   //                     /
 869   //
 870   // (Second test guaranteed canonicalized, first one may not have
 871   // been canonicalized yet)
 872   //
 873   // into:
 874   //
 875   // cond = (x - lo) {&lt;u,&lt;=u,&gt;u,&gt;=u} adjusted_lim
 876   //                       / \
 877   //                 fail /   \ success
 878   //                     /
 879   //
 880 
 881   // Figure out which of the two tests sets the upper bound and which
 882   // sets the lower bound if any.
 883   Node* adjusted_lim = NULL;
 884   if (lo_type != NULL &amp;&amp; hi_type != NULL &amp;&amp; hi_type-&gt;_lo &gt; lo_type-&gt;_hi &amp;&amp;
 885       hi_type-&gt;_hi == max_jint &amp;&amp; lo_type-&gt;_lo == min_jint &amp;&amp; lo_test != BoolTest::ne) {
 886     assert((dom_bool-&gt;_test.is_less() &amp;&amp; !proj-&gt;_con) ||
 887            (dom_bool-&gt;_test.is_greater() &amp;&amp; proj-&gt;_con), &quot;incorrect test&quot;);
 888     // this test was canonicalized
 889     assert(this_bool-&gt;_test.is_less() &amp;&amp; fail-&gt;_con, &quot;incorrect test&quot;);
 890 
 891     // this_bool = &lt;
 892     //   dom_bool = &gt;= (proj = True) or dom_bool = &lt; (proj = False)
 893     //     x in [a, b[ on the fail (= True) projection, b &gt; a-1 (because of hi_type-&gt;_lo &gt; lo_type-&gt;_hi test above):
 894     //     lo = a, hi = b, adjusted_lim = b-a, cond = &lt;u
 895     //   dom_bool = &gt; (proj = True) or dom_bool = &lt;= (proj = False)
 896     //     x in ]a, b[ on the fail (= True) projection, b &gt; a:
 897     //     lo = a+1, hi = b, adjusted_lim = b-a-1, cond = &lt;u
 898     // this_bool = &lt;=
 899     //   dom_bool = &gt;= (proj = True) or dom_bool = &lt; (proj = False)
 900     //     x in [a, b] on the fail (= True) projection, b+1 &gt; a-1:
 901     //     lo = a, hi = b, adjusted_lim = b-a+1, cond = &lt;u
 902     //     lo = a, hi = b, adjusted_lim = b-a, cond = &lt;=u doesn&#39;t work because b = a - 1 is possible, then b-a = -1
 903     //   dom_bool = &gt; (proj = True) or dom_bool = &lt;= (proj = False)
 904     //     x in ]a, b] on the fail (= True) projection b+1 &gt; a:
 905     //     lo = a+1, hi = b, adjusted_lim = b-a, cond = &lt;u
 906     //     lo = a+1, hi = b, adjusted_lim = b-a-1, cond = &lt;=u doesn&#39;t work because a = b is possible, then b-a-1 = -1
 907 
 908     if (hi_test == BoolTest::lt) {
 909       if (lo_test == BoolTest::gt || lo_test == BoolTest::le) {
 910         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 911       }
 912     } else {
 913       assert(hi_test == BoolTest::le, &quot;bad test&quot;);
 914       if (lo_test == BoolTest::ge || lo_test == BoolTest::lt) {
 915         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 916         adjusted_lim = igvn-&gt;transform(new AddINode(adjusted_lim, igvn-&gt;intcon(1)));
 917         cond = BoolTest::lt;
 918       } else {
 919         assert(lo_test == BoolTest::gt || lo_test == BoolTest::le, &quot;bad test&quot;);
 920         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 921         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 922         cond = BoolTest::lt;
 923       }
 924     }
 925   } else if (lo_type != NULL &amp;&amp; hi_type != NULL &amp;&amp; lo_type-&gt;_lo &gt; hi_type-&gt;_hi &amp;&amp;
 926              lo_type-&gt;_hi == max_jint &amp;&amp; hi_type-&gt;_lo == min_jint &amp;&amp; lo_test != BoolTest::ne) {
 927 
 928     // this_bool = &lt;
 929     //   dom_bool = &lt; (proj = True) or dom_bool = &gt;= (proj = False)
 930     //     x in [b, a[ on the fail (= False) projection, a &gt; b-1 (because of lo_type-&gt;_lo &gt; hi_type-&gt;_hi above):
 931     //     lo = b, hi = a, adjusted_lim = a-b, cond = &gt;=u
 932     //   dom_bool = &lt;= (proj = True) or dom_bool = &gt; (proj = False)
 933     //     x in [b, a] on the fail (= False) projection, a+1 &gt; b-1:
 934     //     lo = b, hi = a, adjusted_lim = a-b+1, cond = &gt;=u
 935     //     lo = b, hi = a, adjusted_lim = a-b, cond = &gt;u doesn&#39;t work because a = b - 1 is possible, then b-a = -1
 936     // this_bool = &lt;=
 937     //   dom_bool = &lt; (proj = True) or dom_bool = &gt;= (proj = False)
 938     //     x in ]b, a[ on the fail (= False) projection, a &gt; b:
 939     //     lo = b+1, hi = a, adjusted_lim = a-b-1, cond = &gt;=u
 940     //   dom_bool = &lt;= (proj = True) or dom_bool = &gt; (proj = False)
 941     //     x in ]b, a] on the fail (= False) projection, a+1 &gt; b:
 942     //     lo = b+1, hi = a, adjusted_lim = a-b, cond = &gt;=u
 943     //     lo = b+1, hi = a, adjusted_lim = a-b-1, cond = &gt;u doesn&#39;t work because a = b is possible, then b-a-1 = -1
 944 
 945     swap(lo, hi);
 946     swap(lo_type, hi_type);
 947     swap(lo_test, hi_test);
 948 
 949     assert((dom_bool-&gt;_test.is_less() &amp;&amp; proj-&gt;_con) ||
 950            (dom_bool-&gt;_test.is_greater() &amp;&amp; !proj-&gt;_con), &quot;incorrect test&quot;);
 951     // this test was canonicalized
 952     assert(this_bool-&gt;_test.is_less() &amp;&amp; !fail-&gt;_con, &quot;incorrect test&quot;);
 953 
 954     cond = (hi_test == BoolTest::le || hi_test == BoolTest::gt) ? BoolTest::gt : BoolTest::ge;
 955 
 956     if (lo_test == BoolTest::lt) {
 957       if (hi_test == BoolTest::lt || hi_test == BoolTest::ge) {
 958         cond = BoolTest::ge;
 959       } else {
 960         assert(hi_test == BoolTest::le || hi_test == BoolTest::gt, &quot;bad test&quot;);
 961         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 962         adjusted_lim = igvn-&gt;transform(new AddINode(adjusted_lim, igvn-&gt;intcon(1)));
 963         cond = BoolTest::ge;
 964       }
 965     } else if (lo_test == BoolTest::le) {
 966       if (hi_test == BoolTest::lt || hi_test == BoolTest::ge) {
 967         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 968         cond = BoolTest::ge;
 969       } else {
 970         assert(hi_test == BoolTest::le || hi_test == BoolTest::gt, &quot;bad test&quot;);
 971         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 972         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 973         cond = BoolTest::ge;
 974       }
 975     }
 976   } else {
 977     const TypeInt* failtype = filtered_int_type(igvn, n, proj);
 978     if (failtype != NULL) {
 979       const TypeInt* type2 = filtered_int_type(igvn, n, fail);
 980       if (type2 != NULL) {
 981         failtype = failtype-&gt;join(type2)-&gt;is_int();
 982         if (failtype-&gt;_lo &gt; failtype-&gt;_hi) {
 983           // previous if determines the result of this if so
 984           // replace Bool with constant
 985           igvn-&gt;_worklist.push(in(1));
 986           igvn-&gt;replace_input_of(this, 1, igvn-&gt;intcon(success-&gt;_con));
 987           return true;
 988         }
 989       }
 990     }
 991     lo = NULL;
 992     hi = NULL;
 993   }
 994 
 995   if (lo &amp;&amp; hi) {
 996     // Merge the two compares into a single unsigned compare by building (CmpU (n - lo) (hi - lo))
 997     Node* adjusted_val = igvn-&gt;transform(new SubINode(n,  lo));
 998     if (adjusted_lim == NULL) {
 999       adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
1000     }
1001     Node* newcmp = igvn-&gt;transform(new CmpUNode(adjusted_val, adjusted_lim));
1002     Node* newbool = igvn-&gt;transform(new BoolNode(newcmp, cond));
1003 
1004     igvn-&gt;replace_input_of(dom_iff, 1, igvn-&gt;intcon(proj-&gt;_con));
1005     igvn-&gt;_worklist.push(in(1));
1006     igvn-&gt;replace_input_of(this, 1, newbool);
1007 
1008     return true;
1009   }
1010   return false;
1011 }
1012 
1013 // Merge the branches that trap for this If and the dominating If into
1014 // a single region that branches to the uncommon trap for the
1015 // dominating If
1016 Node* IfNode::merge_uncommon_traps(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn) {
1017   Node* res = this;
1018   assert(success-&gt;in(0) == this, &quot;bad projection&quot;);
1019 
1020   ProjNode* otherproj = proj-&gt;other_if_proj();
1021 
1022   CallStaticJavaNode* unc = success-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none);
1023   CallStaticJavaNode* dom_unc = otherproj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none);
1024 
1025   if (unc != dom_unc) {
1026     Node* r = new RegionNode(3);
1027 
1028     r-&gt;set_req(1, otherproj);
1029     r-&gt;set_req(2, success);
1030     r = igvn-&gt;transform(r);
1031     assert(r-&gt;is_Region(), &quot;can&#39;t go away&quot;);
1032 
1033     // Make both If trap at the state of the first If: once the CmpI
1034     // nodes are merged, if we trap we don&#39;t know which of the CmpI
1035     // nodes would have caused the trap so we have to restart
1036     // execution at the first one
1037     igvn-&gt;replace_input_of(dom_unc, 0, r);
1038     igvn-&gt;replace_input_of(unc, 0, igvn-&gt;C-&gt;top());
1039   }
1040   int trap_request = dom_unc-&gt;uncommon_trap_request();
1041   Deoptimization::DeoptReason reason = Deoptimization::trap_request_reason(trap_request);
1042   Deoptimization::DeoptAction action = Deoptimization::trap_request_action(trap_request);
1043 
1044   int flip_test = 0;
1045   Node* l = NULL;
1046   Node* r = NULL;
1047 
1048   if (success-&gt;in(0)-&gt;as_If()-&gt;range_check_trap_proj(flip_test, l, r) != NULL) {
1049     // If this looks like a range check, change the trap to
1050     // Reason_range_check so the compiler recognizes it as a range
1051     // check and applies the corresponding optimizations
1052     trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_range_check, action);
1053 
1054     improve_address_types(l, r, fail, igvn);
1055 
1056     res = igvn-&gt;transform(new RangeCheckNode(in(0), in(1), _prob, _fcnt));
1057   } else if (unc != dom_unc) {
1058     // If we trap we won&#39;t know what CmpI would have caused the trap
1059     // so use a special trap reason to mark this pair of CmpI nodes as
1060     // bad candidate for folding. On recompilation we won&#39;t fold them
1061     // and we may trap again but this time we&#39;ll know what branch
1062     // traps
1063     trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_unstable_fused_if, action);
1064   }
1065   igvn-&gt;replace_input_of(dom_unc, TypeFunc::Parms, igvn-&gt;intcon(trap_request));
1066   return res;
1067 }
1068 
1069 // If we are turning 2 CmpI nodes into a CmpU that follows the pattern
1070 // of a rangecheck on index i, on 64 bit the compares may be followed
1071 // by memory accesses using i as index. In that case, the CmpU tells
1072 // us something about the values taken by i that can help the compiler
1073 // (see Compile::conv_I2X_index())
1074 void IfNode::improve_address_types(Node* l, Node* r, ProjNode* fail, PhaseIterGVN* igvn) {
1075 #ifdef _LP64
1076   ResourceMark rm;
1077   Node_Stack stack(2);
1078 
1079   assert(r-&gt;Opcode() == Op_LoadRange, &quot;unexpected range check&quot;);
1080   const TypeInt* array_size = igvn-&gt;type(r)-&gt;is_int();
1081 
1082   stack.push(l, 0);
1083 
1084   while(stack.size() &gt; 0) {
1085     Node* n = stack.node();
1086     uint start = stack.index();
1087 
1088     uint i = start;
1089     for (; i &lt; n-&gt;outcnt(); i++) {
1090       Node* use = n-&gt;raw_out(i);
1091       if (stack.size() == 1) {
1092         if (use-&gt;Opcode() == Op_ConvI2L) {
1093           const TypeLong* bounds = use-&gt;as_Type()-&gt;type()-&gt;is_long();
1094           if (bounds-&gt;_lo &lt;= array_size-&gt;_lo &amp;&amp; bounds-&gt;_hi &gt;= array_size-&gt;_hi &amp;&amp;
1095               (bounds-&gt;_lo != array_size-&gt;_lo || bounds-&gt;_hi != array_size-&gt;_hi)) {
1096             stack.set_index(i+1);
1097             stack.push(use, 0);
1098             break;
1099           }
1100         }
1101       } else if (use-&gt;is_Mem()) {
1102         Node* ctrl = use-&gt;in(0);
1103         for (int i = 0; i &lt; 10 &amp;&amp; ctrl != NULL &amp;&amp; ctrl != fail; i++) {
1104           ctrl = up_one_dom(ctrl);
1105         }
1106         if (ctrl == fail) {
1107           Node* init_n = stack.node_at(1);
1108           assert(init_n-&gt;Opcode() == Op_ConvI2L, &quot;unexpected first node&quot;);
1109           // Create a new narrow ConvI2L node that is dependent on the range check
1110           Node* new_n = igvn-&gt;C-&gt;conv_I2X_index(igvn, l, array_size, fail);
1111 
1112           // The type of the ConvI2L may be widen and so the new
1113           // ConvI2L may not be better than an existing ConvI2L
1114           if (new_n != init_n) {
1115             for (uint j = 2; j &lt; stack.size(); j++) {
1116               Node* n = stack.node_at(j);
1117               Node* clone = n-&gt;clone();
1118               int rep = clone-&gt;replace_edge(init_n, new_n);
1119               assert(rep &gt; 0, &quot;can&#39;t find expected node?&quot;);
1120               clone = igvn-&gt;transform(clone);
1121               init_n = n;
1122               new_n = clone;
1123             }
1124             igvn-&gt;hash_delete(use);
1125             int rep = use-&gt;replace_edge(init_n, new_n);
1126             assert(rep &gt; 0, &quot;can&#39;t find expected node?&quot;);
1127             igvn-&gt;transform(use);
1128             if (init_n-&gt;outcnt() == 0) {
1129               igvn-&gt;_worklist.push(init_n);
1130             }
1131           }
1132         }
1133       } else if (use-&gt;in(0) == NULL &amp;&amp; (igvn-&gt;type(use)-&gt;isa_long() ||
1134                                         igvn-&gt;type(use)-&gt;isa_ptr())) {
1135         stack.set_index(i+1);
1136         stack.push(use, 0);
1137         break;
1138       }
1139     }
1140     if (i == n-&gt;outcnt()) {
1141       stack.pop();
1142     }
1143   }
1144 #endif
1145 }
1146 
1147 bool IfNode::is_cmp_with_loadrange(ProjNode* proj) {
1148   if (in(1) != NULL &amp;&amp;
1149       in(1)-&gt;in(1) != NULL &amp;&amp;
1150       in(1)-&gt;in(1)-&gt;in(2) != NULL) {
1151     Node* other = in(1)-&gt;in(1)-&gt;in(2);
1152     if (other-&gt;Opcode() == Op_LoadRange &amp;&amp;
1153         ((other-&gt;in(0) != NULL &amp;&amp; other-&gt;in(0) == proj) ||
1154          (other-&gt;in(0) == NULL &amp;&amp;
1155           other-&gt;in(2) != NULL &amp;&amp;
1156           other-&gt;in(2)-&gt;is_AddP() &amp;&amp;
1157           other-&gt;in(2)-&gt;in(1) != NULL &amp;&amp;
1158           other-&gt;in(2)-&gt;in(1)-&gt;Opcode() == Op_CastPP &amp;&amp;
1159           other-&gt;in(2)-&gt;in(1)-&gt;in(0) == proj))) {
1160       return true;
1161     }
1162   }
1163   return false;
1164 }
1165 
1166 bool IfNode::is_null_check(ProjNode* proj, PhaseIterGVN* igvn) {
1167   Node* other = in(1)-&gt;in(1)-&gt;in(2);
1168   if (other-&gt;in(MemNode::Address) != NULL &amp;&amp;
1169       proj-&gt;in(0)-&gt;in(1) != NULL &amp;&amp;
1170       proj-&gt;in(0)-&gt;in(1)-&gt;is_Bool() &amp;&amp;
1171       proj-&gt;in(0)-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;
1172       proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;
1173       proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2) != NULL &amp;&amp;
1174       proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == other-&gt;in(MemNode::Address)-&gt;in(AddPNode::Address)-&gt;uncast() &amp;&amp;
1175       igvn-&gt;type(proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)) == TypePtr::NULL_PTR) {
1176     return true;
1177   }
1178   return false;
1179 }
1180 
<a name="1" id="anc1"></a><span class="line-modified">1181 // Returns true if this IfNode belongs to a non-flattened array check</span>
1182 // and returns the corresponding array in the &#39;array&#39; parameter.
<a name="2" id="anc2"></a><span class="line-modified">1183 bool IfNode::is_non_flattened_array_check(PhaseTransform* phase, Node** array) {</span>
1184   Node* bol = in(1);
<a name="3" id="anc3"></a><span class="line-modified">1185   if (!bol-&gt;is_Bool()) {</span>
1186     return false;
1187   }
1188   Node* cmp = bol-&gt;in(1);
<a name="4" id="anc4"></a><span class="line-modified">1189   if (cmp-&gt;Opcode() != Op_CmpI) {</span>
1190     return false;
1191   }
1192   Node* cmp_in1 = cmp-&gt;in(1);
1193   Node* cmp_in2 = cmp-&gt;in(2);
<a name="5" id="anc5"></a><span class="line-modified">1194   if ((unsigned int)cmp_in2-&gt;find_int_con(0) != Klass::_lh_array_tag_vt_value) {</span>

1195     return false;
1196   }
<a name="6" id="anc6"></a><span class="line-modified">1197   if (cmp_in1-&gt;Opcode() != Op_RShiftI) {</span>
<span class="line-modified">1198     return false;</span>




1199   }
<a name="7" id="anc7"></a><span class="line-modified">1200   Node* shift_in1 = cmp_in1-&gt;in(1);</span>
<span class="line-modified">1201   Node* shift_in2 = cmp_in1-&gt;in(2);</span>
<span class="line-added">1202   if ((unsigned int)shift_in2-&gt;find_int_con(0) != Klass::_lh_array_tag_shift) {</span>
1203     return false;
1204   }
<a name="8" id="anc8"></a><span class="line-modified">1205   if (shift_in1-&gt;Opcode() != Op_LoadI) {</span>
<span class="line-modified">1206     return false;</span>
<span class="line-modified">1207   }</span>
<span class="line-modified">1208   intptr_t offset;</span>
<span class="line-added">1209   Node* ptr = shift_in1-&gt;in(MemNode::Address);</span>
<span class="line-added">1210   Node* addr = AddPNode::Ideal_base_and_offset(ptr, phase, offset);</span>
<span class="line-added">1211   if (addr == NULL || offset != in_bytes(Klass::layout_helper_offset())) {</span>
<span class="line-added">1212     return false;</span>
<span class="line-added">1213   }</span>
<span class="line-added">1214   if (!phase-&gt;type(addr)-&gt;isa_klassptr()) {</span>
<span class="line-added">1215     return false;</span>
<span class="line-added">1216   }</span>
<span class="line-added">1217   Node* klass_load = ptr-&gt;as_AddP()-&gt;in(AddPNode::Base)-&gt;uncast();</span>
<span class="line-added">1218   if (klass_load-&gt;is_DecodeNKlass()) {</span>
<span class="line-added">1219     klass_load = klass_load-&gt;in(1);</span>
<span class="line-added">1220   }</span>
<span class="line-added">1221   if (array != NULL &amp;&amp; klass_load-&gt;is_Load()) {</span>
1222     Node* address = klass_load-&gt;in(MemNode::Address);
<a name="9" id="anc9"></a><span class="line-modified">1223     *array = address-&gt;as_AddP()-&gt;in(AddPNode::Base);</span>
1224   }
<a name="10" id="anc10"></a><span class="line-added">1225   assert(bol-&gt;isa_Bool()-&gt;_test._test == BoolTest::ne, &quot;IfTrue proj must point to non-flattened array&quot;);</span>
1226   return true;
1227 }
1228 
1229 // Check that the If that is in between the 2 integer comparisons has
1230 // no side effect
1231 bool IfNode::is_side_effect_free_test(ProjNode* proj, PhaseIterGVN* igvn) {
1232   if (proj == NULL) {
1233     return false;
1234   }
1235   CallStaticJavaNode* unc = proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1236   if (unc != NULL &amp;&amp; proj-&gt;outcnt() &lt;= 2) {
1237     if (proj-&gt;outcnt() == 1 ||
1238         // Allow simple null check from LoadRange
1239         (is_cmp_with_loadrange(proj) &amp;&amp; is_null_check(proj, igvn))) {
1240       CallStaticJavaNode* unc = proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1241       CallStaticJavaNode* dom_unc = proj-&gt;in(0)-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1242       assert(dom_unc != NULL, &quot;is_uncommon_trap_if_pattern returned NULL&quot;);
1243 
1244       // reroute_side_effect_free_unc changes the state of this
1245       // uncommon trap to restart execution at the previous
1246       // CmpI. Check that this change in a previous compilation didn&#39;t
1247       // cause too many traps.
1248       int trap_request = unc-&gt;uncommon_trap_request();
1249       Deoptimization::DeoptReason reason = Deoptimization::trap_request_reason(trap_request);
1250 
1251       if (igvn-&gt;C-&gt;too_many_traps(dom_unc-&gt;jvms()-&gt;method(), dom_unc-&gt;jvms()-&gt;bci(), reason)) {
1252         return false;
1253       }
1254 
1255       if (!is_dominator_unc(dom_unc, unc)) {
1256         return false;
1257       }
1258 
1259       return true;
1260     }
1261   }
1262   return false;
1263 }
1264 
1265 // Make the If between the 2 integer comparisons trap at the state of
1266 // the first If: the last CmpI is the one replaced by a CmpU and the
1267 // first CmpI is eliminated, so the test between the 2 CmpI nodes
1268 // won&#39;t be guarded by the first CmpI anymore. It can trap in cases
1269 // where the first CmpI would have prevented it from executing: on a
1270 // trap, we need to restart execution at the state of the first CmpI
1271 void IfNode::reroute_side_effect_free_unc(ProjNode* proj, ProjNode* dom_proj, PhaseIterGVN* igvn) {
1272   CallStaticJavaNode* dom_unc = dom_proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1273   ProjNode* otherproj = proj-&gt;other_if_proj();
1274   CallStaticJavaNode* unc = proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1275   Node* call_proj = dom_unc-&gt;unique_ctrl_out();
1276   Node* halt = call_proj-&gt;unique_ctrl_out();
1277 
1278   Node* new_unc = dom_unc-&gt;clone();
1279   call_proj = call_proj-&gt;clone();
1280   halt = halt-&gt;clone();
1281   Node* c = otherproj-&gt;clone();
1282 
1283   c = igvn-&gt;transform(c);
1284   new_unc-&gt;set_req(TypeFunc::Parms, unc-&gt;in(TypeFunc::Parms));
1285   new_unc-&gt;set_req(0, c);
1286   new_unc = igvn-&gt;transform(new_unc);
1287   call_proj-&gt;set_req(0, new_unc);
1288   call_proj = igvn-&gt;transform(call_proj);
1289   halt-&gt;set_req(0, call_proj);
1290   halt = igvn-&gt;transform(halt);
1291 
1292   igvn-&gt;replace_node(otherproj, igvn-&gt;C-&gt;top());
1293   igvn-&gt;C-&gt;root()-&gt;add_req(halt);
1294 }
1295 
1296 Node* IfNode::fold_compares(PhaseIterGVN* igvn) {
1297   if (Opcode() != Op_If) return NULL;
1298 
1299   if (cmpi_folds(igvn)) {
1300     Node* ctrl = in(0);
1301     if (is_ctrl_folds(ctrl, igvn) &amp;&amp; ctrl-&gt;outcnt() == 1) {
1302       // A integer comparison immediately dominated by another integer
1303       // comparison
1304       ProjNode* success = NULL;
1305       ProjNode* fail = NULL;
1306       ProjNode* dom_cmp = ctrl-&gt;as_Proj();
1307       if (has_shared_region(dom_cmp, success, fail) &amp;&amp;
1308           // Next call modifies graph so must be last
1309           fold_compares_helper(dom_cmp, success, fail, igvn)) {
1310         return this;
1311       }
1312       if (has_only_uncommon_traps(dom_cmp, success, fail, igvn) &amp;&amp;
1313           // Next call modifies graph so must be last
1314           fold_compares_helper(dom_cmp, success, fail, igvn)) {
1315         return merge_uncommon_traps(dom_cmp, success, fail, igvn);
1316       }
1317       return NULL;
1318     } else if (ctrl-&gt;in(0) != NULL &amp;&amp;
1319                ctrl-&gt;in(0)-&gt;in(0) != NULL) {
1320       ProjNode* success = NULL;
1321       ProjNode* fail = NULL;
1322       Node* dom = ctrl-&gt;in(0)-&gt;in(0);
1323       ProjNode* dom_cmp = dom-&gt;isa_Proj();
1324       ProjNode* other_cmp = ctrl-&gt;isa_Proj();
1325 
1326       // Check if it&#39;s an integer comparison dominated by another
1327       // integer comparison with another test in between
1328       if (is_ctrl_folds(dom, igvn) &amp;&amp;
1329           has_only_uncommon_traps(dom_cmp, success, fail, igvn) &amp;&amp;
1330           is_side_effect_free_test(other_cmp, igvn) &amp;&amp;
1331           // Next call modifies graph so must be last
1332           fold_compares_helper(dom_cmp, success, fail, igvn)) {
1333         reroute_side_effect_free_unc(other_cmp, dom_cmp, igvn);
1334         return merge_uncommon_traps(dom_cmp, success, fail, igvn);
1335       }
1336     }
1337   }
1338   return NULL;
1339 }
1340 
1341 //------------------------------remove_useless_bool----------------------------
1342 // Check for people making a useless boolean: things like
1343 // if( (x &lt; y ? true : false) ) { ... }
1344 // Replace with if( x &lt; y ) { ... }
1345 static Node *remove_useless_bool(IfNode *iff, PhaseGVN *phase) {
1346   Node *i1 = iff-&gt;in(1);
1347   if( !i1-&gt;is_Bool() ) return NULL;
1348   BoolNode *bol = i1-&gt;as_Bool();
1349 
1350   Node *cmp = bol-&gt;in(1);
1351   if( cmp-&gt;Opcode() != Op_CmpI ) return NULL;
1352 
1353   // Must be comparing against a bool
1354   const Type *cmp2_t = phase-&gt;type( cmp-&gt;in(2) );
1355   if( cmp2_t != TypeInt::ZERO &amp;&amp;
1356       cmp2_t != TypeInt::ONE )
1357     return NULL;
1358 
1359   // Find a prior merge point merging the boolean
1360   i1 = cmp-&gt;in(1);
1361   if( !i1-&gt;is_Phi() ) return NULL;
1362   PhiNode *phi = i1-&gt;as_Phi();
1363   if( phase-&gt;type( phi ) != TypeInt::BOOL )
1364     return NULL;
1365 
1366   // Check for diamond pattern
1367   int true_path = phi-&gt;is_diamond_phi();
1368   if( true_path == 0 ) return NULL;
1369 
1370   // Make sure that iff and the control of the phi are different. This
1371   // should really only happen for dead control flow since it requires
1372   // an illegal cycle.
1373   if (phi-&gt;in(0)-&gt;in(1)-&gt;in(0) == iff) return NULL;
1374 
1375   // phi-&gt;region-&gt;if_proj-&gt;ifnode-&gt;bool-&gt;cmp
1376   BoolNode *bol2 = phi-&gt;in(0)-&gt;in(1)-&gt;in(0)-&gt;in(1)-&gt;as_Bool();
1377 
1378   // Now get the &#39;sense&#39; of the test correct so we can plug in
1379   // either iff2-&gt;in(1) or its complement.
1380   int flip = 0;
1381   if( bol-&gt;_test._test == BoolTest::ne ) flip = 1-flip;
1382   else if( bol-&gt;_test._test != BoolTest::eq ) return NULL;
1383   if( cmp2_t == TypeInt::ZERO ) flip = 1-flip;
1384 
1385   const Type *phi1_t = phase-&gt;type( phi-&gt;in(1) );
1386   const Type *phi2_t = phase-&gt;type( phi-&gt;in(2) );
1387   // Check for Phi(0,1) and flip
1388   if( phi1_t == TypeInt::ZERO ) {
1389     if( phi2_t != TypeInt::ONE ) return NULL;
1390     flip = 1-flip;
1391   } else {
1392     // Check for Phi(1,0)
1393     if( phi1_t != TypeInt::ONE  ) return NULL;
1394     if( phi2_t != TypeInt::ZERO ) return NULL;
1395   }
1396   if( true_path == 2 ) {
1397     flip = 1-flip;
1398   }
1399 
1400   Node* new_bol = (flip ? phase-&gt;transform( bol2-&gt;negate(phase) ) : bol2);
1401   assert(new_bol != iff-&gt;in(1), &quot;must make progress&quot;);
1402   iff-&gt;set_req(1, new_bol);
1403   // Intervening diamond probably goes dead
1404   phase-&gt;C-&gt;set_major_progress();
1405   return iff;
1406 }
1407 
1408 static IfNode* idealize_test(PhaseGVN* phase, IfNode* iff);
1409 
1410 struct RangeCheck {
1411   Node* ctl;
1412   jint off;
1413 };
1414 
1415 Node* IfNode::Ideal_common(PhaseGVN *phase, bool can_reshape) {
1416   if (remove_dead_region(phase, can_reshape))  return this;
1417   // No Def-Use info?
1418   if (!can_reshape)  return NULL;
1419 
1420   // Don&#39;t bother trying to transform a dead if
1421   if (in(0)-&gt;is_top())  return NULL;
1422   // Don&#39;t bother trying to transform an if with a dead test
1423   if (in(1)-&gt;is_top())  return NULL;
1424   // Another variation of a dead test
1425   if (in(1)-&gt;is_Con())  return NULL;
1426   // Another variation of a dead if
1427   if (outcnt() &lt; 2)  return NULL;
1428 
1429   // Canonicalize the test.
1430   Node* idt_if = idealize_test(phase, this);
1431   if (idt_if != NULL)  return idt_if;
1432 
1433   // Try to split the IF
1434   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1435   Node *s = split_if(this, igvn);
1436   if (s != NULL)  return s;
1437 
1438   return NodeSentinel;
1439 }
1440 
1441 //------------------------------Ideal------------------------------------------
1442 // Return a node which is more &quot;ideal&quot; than the current node.  Strip out
1443 // control copies
1444 Node* IfNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1445   Node* res = Ideal_common(phase, can_reshape);
1446   if (res != NodeSentinel) {
1447     return res;
1448   }
1449 
1450   // Check for people making a useless boolean: things like
1451   // if( (x &lt; y ? true : false) ) { ... }
1452   // Replace with if( x &lt; y ) { ... }
1453   Node* bol2 = remove_useless_bool(this, phase);
1454   if (bol2) return bol2;
1455 
1456   if (in(0) == NULL) return NULL;     // Dead loop?
1457 
1458   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
1459   Node* result = fold_compares(igvn);
1460   if (result != NULL) {
1461     return result;
1462   }
1463 
1464   // Scan for an equivalent test
1465   int dist = 4;               // Cutoff limit for search
1466   if (is_If() &amp;&amp; in(1)-&gt;is_Bool()) {
1467     Node* cmp = in(1)-&gt;in(1);
1468     if (cmp-&gt;Opcode() == Op_CmpP &amp;&amp;
1469         cmp-&gt;in(2) != NULL &amp;&amp; // make sure cmp is not already dead
1470         cmp-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {
1471       dist = 64;              // Limit for null-pointer scans
1472     }
1473   }
1474 
1475   Node* prev_dom = search_identical(dist);
1476 
1477   if (prev_dom != NULL) {
1478     // Replace dominated IfNode
1479     return dominated_by(prev_dom, igvn);
1480   }
1481 
1482   return simple_subsuming(igvn);
1483 }
1484 
1485 //------------------------------dominated_by-----------------------------------
1486 Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN *igvn) {
1487 #ifndef PRODUCT
1488   if (TraceIterativeGVN) {
1489     tty-&gt;print(&quot;   Removing IfNode: &quot;); this-&gt;dump();
1490   }
1491 #endif
1492 
1493   igvn-&gt;hash_delete(this);      // Remove self to prevent spurious V-N
1494   Node *idom = in(0);
1495   // Need opcode to decide which way &#39;this&#39; test goes
1496   int prev_op = prev_dom-&gt;Opcode();
1497   Node *top = igvn-&gt;C-&gt;top(); // Shortcut to top
1498 
1499   // Loop predicates may have depending checks which should not
1500   // be skipped. For example, range check predicate has two checks
1501   // for lower and upper bounds.
1502   ProjNode* unc_proj = proj_out(1 - prev_dom-&gt;as_Proj()-&gt;_con)-&gt;as_Proj();
1503   if (unc_proj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_predicate) != NULL ||
1504       unc_proj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != NULL) {
1505     prev_dom = idom;
1506   }
1507 
1508   // Now walk the current IfNode&#39;s projections.
1509   // Loop ends when &#39;this&#39; has no more uses.
1510   for (DUIterator_Last imin, i = last_outs(imin); i &gt;= imin; --i) {
1511     Node *ifp = last_out(i);     // Get IfTrue/IfFalse
1512     igvn-&gt;add_users_to_worklist(ifp);
1513     // Check which projection it is and set target.
1514     // Data-target is either the dominating projection of the same type
1515     // or TOP if the dominating projection is of opposite type.
1516     // Data-target will be used as the new control edge for the non-CFG
1517     // nodes like Casts and Loads.
1518     Node *data_target = (ifp-&gt;Opcode() == prev_op) ? prev_dom : top;
1519     // Control-target is just the If&#39;s immediate dominator or TOP.
1520     Node *ctrl_target = (ifp-&gt;Opcode() == prev_op) ?     idom : top;
1521 
1522     // For each child of an IfTrue/IfFalse projection, reroute.
1523     // Loop ends when projection has no more uses.
1524     for (DUIterator_Last jmin, j = ifp-&gt;last_outs(jmin); j &gt;= jmin; --j) {
1525       Node* s = ifp-&gt;last_out(j);   // Get child of IfTrue/IfFalse
1526       if( !s-&gt;depends_only_on_test() ) {
1527         // Find the control input matching this def-use edge.
1528         // For Regions it may not be in slot 0.
1529         uint l;
1530         for( l = 0; s-&gt;in(l) != ifp; l++ ) { }
1531         igvn-&gt;replace_input_of(s, l, ctrl_target);
1532       } else {                      // Else, for control producers,
1533         igvn-&gt;replace_input_of(s, 0, data_target); // Move child to data-target
1534       }
1535     } // End for each child of a projection
1536 
1537     igvn-&gt;remove_dead_node(ifp);
1538   } // End for each IfTrue/IfFalse child of If
1539 
1540   // Kill the IfNode
1541   igvn-&gt;remove_dead_node(this);
1542 
1543   // Must return either the original node (now dead) or a new node
1544   // (Do not return a top here, since that would break the uniqueness of top.)
1545   return new ConINode(TypeInt::ZERO);
1546 }
1547 
1548 Node* IfNode::search_identical(int dist) {
1549   // Setup to scan up the CFG looking for a dominating test
1550   Node* dom = in(0);
1551   Node* prev_dom = this;
1552   int op = Opcode();
1553   // Search up the dominator tree for an If with an identical test
1554   while (dom-&gt;Opcode() != op    ||  // Not same opcode?
1555          dom-&gt;in(1)    != in(1) ||  // Not same input 1?
1556          prev_dom-&gt;in(0) != dom) {  // One path of test does not dominate?
1557     if (dist &lt; 0) return NULL;
1558 
1559     dist--;
1560     prev_dom = dom;
1561     dom = up_one_dom(dom);
1562     if (!dom) return NULL;
1563   }
1564 
1565   // Check that we did not follow a loop back to ourselves
1566   if (this == dom) {
1567     return NULL;
1568   }
1569 
1570 #ifndef PRODUCT
1571   if (dist &gt; 2) { // Add to count of NULL checks elided
1572     explicit_null_checks_elided++;
1573   }
1574 #endif
1575 
1576   return prev_dom;
1577 }
1578 
1579 
1580 static int subsuming_bool_test_encode(Node*);
1581 
1582 // Check if dominating test is subsuming &#39;this&#39; one.
1583 //
1584 //              cmp
1585 //              / \
1586 //     (r1)  bool  \
1587 //            /    bool (r2)
1588 //    (dom) if       \
1589 //            \       )
1590 //    (pre)  if[TF]  /
1591 //               \  /
1592 //                if (this)
1593 //   \r1
1594 //  r2\  eqT  eqF  neT  neF  ltT  ltF  leT  leF  gtT  gtF  geT  geF
1595 //  eq    t    f    f    t    f    -    -    f    f    -    -    f
1596 //  ne    f    t    t    f    t    -    -    t    t    -    -    t
1597 //  lt    f    -    -    f    t    f    -    f    f    -    f    t
1598 //  le    t    -    -    t    t    -    t    f    f    t    -    t
1599 //  gt    f    -    -    f    f    -    f    t    t    f    -    f
1600 //  ge    t    -    -    t    f    t    -    t    t    -    t    f
1601 //
1602 Node* IfNode::simple_subsuming(PhaseIterGVN* igvn) {
1603   // Table encoding: N/A (na), True-branch (tb), False-branch (fb).
1604   static enum { na, tb, fb } s_short_circuit_map[6][12] = {
1605   /*rel: eq+T eq+F ne+T ne+F lt+T lt+F le+T le+F gt+T gt+F ge+T ge+F*/
1606   /*eq*/{ tb,  fb,  fb,  tb,  fb,  na,  na,  fb,  fb,  na,  na,  fb },
1607   /*ne*/{ fb,  tb,  tb,  fb,  tb,  na,  na,  tb,  tb,  na,  na,  tb },
1608   /*lt*/{ fb,  na,  na,  fb,  tb,  fb,  na,  fb,  fb,  na,  fb,  tb },
1609   /*le*/{ tb,  na,  na,  tb,  tb,  na,  tb,  fb,  fb,  tb,  na,  tb },
1610   /*gt*/{ fb,  na,  na,  fb,  fb,  na,  fb,  tb,  tb,  fb,  na,  fb },
1611   /*ge*/{ tb,  na,  na,  tb,  fb,  tb,  na,  tb,  tb,  na,  tb,  fb }};
1612 
1613   Node* pre = in(0);
1614   if (!pre-&gt;is_IfTrue() &amp;&amp; !pre-&gt;is_IfFalse()) {
1615     return NULL;
1616   }
1617   Node* dom = pre-&gt;in(0);
1618   if (!dom-&gt;is_If()) {
1619     return NULL;
1620   }
1621   Node* bol = in(1);
1622   if (!bol-&gt;is_Bool()) {
1623     return NULL;
1624   }
1625   Node* cmp = in(1)-&gt;in(1);
1626   if (!cmp-&gt;is_Cmp()) {
1627     return NULL;
1628   }
1629 
1630   if (!dom-&gt;in(1)-&gt;is_Bool()) {
1631     return NULL;
1632   }
1633   if (dom-&gt;in(1)-&gt;in(1) != cmp) {  // Not same cond?
1634     return NULL;
1635   }
1636 
1637   int drel = subsuming_bool_test_encode(dom-&gt;in(1));
1638   int trel = subsuming_bool_test_encode(bol);
1639   int bout = pre-&gt;is_IfFalse() ? 1 : 0;
1640 
1641   if (drel &lt; 0 || trel &lt; 0) {
1642     return NULL;
1643   }
1644   int br = s_short_circuit_map[trel][2*drel+bout];
1645   if (br == na) {
1646     return NULL;
1647   }
1648 #ifndef PRODUCT
1649   if (TraceIterativeGVN) {
1650     tty-&gt;print(&quot;   Subsumed IfNode: &quot;); dump();
1651   }
1652 #endif
1653   // Replace condition with constant True(1)/False(0).
1654   set_req(1, igvn-&gt;intcon(br == tb ? 1 : 0));
1655 
1656   if (bol-&gt;outcnt() == 0) {
1657     igvn-&gt;remove_dead_node(bol);    // Kill the BoolNode.
1658   }
1659   return this;
1660 }
1661 
1662 // Map BoolTest to local table encoding. The BoolTest (e)numerals
1663 //   { eq = 0, ne = 4, le = 5, ge = 7, lt = 3, gt = 1 }
1664 // are mapped to table indices, while the remaining (e)numerals in BoolTest
1665 //   { overflow = 2, no_overflow = 6, never = 8, illegal = 9 }
1666 // are ignored (these are not modeled in the table).
1667 //
1668 static int subsuming_bool_test_encode(Node* node) {
1669   precond(node-&gt;is_Bool());
1670   BoolTest::mask x = node-&gt;as_Bool()-&gt;_test._test;
1671   switch (x) {
1672     case BoolTest::eq: return 0;
1673     case BoolTest::ne: return 1;
1674     case BoolTest::lt: return 2;
1675     case BoolTest::le: return 3;
1676     case BoolTest::gt: return 4;
1677     case BoolTest::ge: return 5;
1678     case BoolTest::overflow:
1679     case BoolTest::no_overflow:
1680     case BoolTest::never:
1681     case BoolTest::illegal:
1682     default:
1683       return -1;
1684   }
1685 }
1686 
1687 //------------------------------Identity---------------------------------------
1688 // If the test is constant &amp; we match, then we are the input Control
1689 Node* IfProjNode::Identity(PhaseGVN* phase) {
1690   // Can only optimize if cannot go the other way
1691   const TypeTuple *t = phase-&gt;type(in(0))-&gt;is_tuple();
1692   if (t == TypeTuple::IFNEITHER || (always_taken(t) &amp;&amp;
1693        // During parsing (GVN) we don&#39;t remove dead code aggressively.
1694        // Cut off dead branch and let PhaseRemoveUseless take care of it.
1695       (!phase-&gt;is_IterGVN() ||
1696        // During IGVN, first wait for the dead branch to be killed.
1697        // Otherwise, the IfNode&#39;s control will have two control uses (the IfNode
1698        // that doesn&#39;t go away because it still has uses and this branch of the
1699        // If) which breaks other optimizations. Node::has_special_unique_user()
1700        // will cause this node to be reprocessed once the dead branch is killed.
1701        in(0)-&gt;outcnt() == 1))) {
1702     // IfNode control
1703     return in(0)-&gt;in(0);
1704   }
1705   // no progress
1706   return this;
1707 }
1708 
1709 #ifndef PRODUCT
1710 //-------------------------------related---------------------------------------
1711 // An IfProjNode&#39;s related node set consists of its input (an IfNode) including
1712 // the IfNode&#39;s condition, plus all of its outputs at level 1. In compact mode,
1713 // the restrictions for IfNode apply (see IfNode::rel).
1714 void IfProjNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
1715   Node* ifNode = this-&gt;in(0);
1716   in_rel-&gt;append(ifNode);
1717   if (compact) {
1718     ifNode-&gt;collect_nodes(in_rel, 3, false, true);
1719   } else {
1720     ifNode-&gt;collect_nodes_in_all_data(in_rel, false);
1721   }
1722   this-&gt;collect_nodes(out_rel, -1, false, false);
1723 }
1724 
1725 //------------------------------dump_spec--------------------------------------
1726 void IfNode::dump_spec(outputStream *st) const {
1727   st-&gt;print(&quot;P=%f, C=%f&quot;,_prob,_fcnt);
1728 }
1729 
1730 //-------------------------------related---------------------------------------
1731 // For an IfNode, the set of related output nodes is just the output nodes till
1732 // depth 2, i.e, the IfTrue/IfFalse projection nodes plus the nodes they refer.
1733 // The related input nodes contain no control nodes, but all data nodes
1734 // pertaining to the condition. In compact mode, the input nodes are collected
1735 // up to a depth of 3.
1736 void IfNode::related(GrowableArray &lt;Node *&gt; *in_rel, GrowableArray &lt;Node *&gt; *out_rel, bool compact) const {
1737   if (compact) {
1738     this-&gt;collect_nodes(in_rel, 3, false, true);
1739   } else {
1740     this-&gt;collect_nodes_in_all_data(in_rel, false);
1741   }
1742   this-&gt;collect_nodes(out_rel, -2, false, false);
1743 }
1744 #endif
1745 
1746 //------------------------------idealize_test----------------------------------
1747 // Try to canonicalize tests better.  Peek at the Cmp/Bool/If sequence and
1748 // come up with a canonical sequence.  Bools getting &#39;eq&#39;, &#39;gt&#39; and &#39;ge&#39; forms
1749 // converted to &#39;ne&#39;, &#39;le&#39; and &#39;lt&#39; forms.  IfTrue/IfFalse get swapped as
1750 // needed.
1751 static IfNode* idealize_test(PhaseGVN* phase, IfNode* iff) {
1752   assert(iff-&gt;in(0) != NULL, &quot;If must be live&quot;);
1753 
1754   if (iff-&gt;outcnt() != 2)  return NULL; // Malformed projections.
1755   Node* old_if_f = iff-&gt;proj_out(false);
1756   Node* old_if_t = iff-&gt;proj_out(true);
1757 
1758   // CountedLoopEnds want the back-control test to be TRUE, irregardless of
1759   // whether they are testing a &#39;gt&#39; or &#39;lt&#39; condition.  The &#39;gt&#39; condition
1760   // happens in count-down loops
1761   if (iff-&gt;is_CountedLoopEnd())  return NULL;
1762   if (!iff-&gt;in(1)-&gt;is_Bool())  return NULL; // Happens for partially optimized IF tests
1763   BoolNode *b = iff-&gt;in(1)-&gt;as_Bool();
1764   BoolTest bt = b-&gt;_test;
1765   // Test already in good order?
1766   if( bt.is_canonical() )
1767     return NULL;
1768 
1769   // Flip test to be canonical.  Requires flipping the IfFalse/IfTrue and
1770   // cloning the IfNode.
1771   Node* new_b = phase-&gt;transform( new BoolNode(b-&gt;in(1), bt.negate()) );
1772   if( !new_b-&gt;is_Bool() ) return NULL;
1773   b = new_b-&gt;as_Bool();
1774 
1775   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1776   assert( igvn, &quot;Test is not canonical in parser?&quot; );
1777 
1778   // The IF node never really changes, but it needs to be cloned
1779   iff = iff-&gt;clone()-&gt;as_If();
1780   iff-&gt;set_req(1, b);
1781   iff-&gt;_prob = 1.0-iff-&gt;_prob;
1782 
1783   Node *prior = igvn-&gt;hash_find_insert(iff);
1784   if( prior ) {
1785     igvn-&gt;remove_dead_node(iff);
1786     iff = (IfNode*)prior;
1787   } else {
1788     // Cannot call transform on it just yet
1789     igvn-&gt;set_type_bottom(iff);
1790   }
1791   igvn-&gt;_worklist.push(iff);
1792 
1793   // Now handle projections.  Cloning not required.
1794   Node* new_if_f = (Node*)(new IfFalseNode( iff ));
1795   Node* new_if_t = (Node*)(new IfTrueNode ( iff ));
1796 
1797   igvn-&gt;register_new_node_with_optimizer(new_if_f);
1798   igvn-&gt;register_new_node_with_optimizer(new_if_t);
1799   // Flip test, so flip trailing control
1800   igvn-&gt;replace_node(old_if_f, new_if_t);
1801   igvn-&gt;replace_node(old_if_t, new_if_f);
1802 
1803   // Progress
1804   return iff;
1805 }
1806 
1807 Node* RangeCheckNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1808   Node* res = Ideal_common(phase, can_reshape);
1809   if (res != NodeSentinel) {
1810     return res;
1811   }
1812 
1813   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1814   // Setup to scan up the CFG looking for a dominating test
1815   Node* prev_dom = this;
1816 
1817   // Check for range-check vs other kinds of tests
1818   Node* index1;
1819   Node* range1;
1820   jint offset1;
1821   int flip1 = is_range_check(range1, index1, offset1);
1822   if (flip1) {
1823     Node* dom = in(0);
1824     // Try to remove extra range checks.  All &#39;up_one_dom&#39; gives up at merges
1825     // so all checks we inspect post-dominate the top-most check we find.
1826     // If we are going to fail the current check and we reach the top check
1827     // then we are guaranteed to fail, so just start interpreting there.
1828     // We &#39;expand&#39; the top 3 range checks to include all post-dominating
1829     // checks.
1830 
1831     // The top 3 range checks seen
1832     const int NRC = 3;
1833     RangeCheck prev_checks[NRC];
1834     int nb_checks = 0;
1835 
1836     // Low and high offsets seen so far
1837     jint off_lo = offset1;
1838     jint off_hi = offset1;
1839 
1840     bool found_immediate_dominator = false;
1841 
1842     // Scan for the top checks and collect range of offsets
1843     for (int dist = 0; dist &lt; 999; dist++) { // Range-Check scan limit
1844       if (dom-&gt;Opcode() == Op_RangeCheck &amp;&amp;  // Not same opcode?
1845           prev_dom-&gt;in(0) == dom) { // One path of test does dominate?
1846         if (dom == this) return NULL; // dead loop
1847         // See if this is a range check
1848         Node* index2;
1849         Node* range2;
1850         jint offset2;
1851         int flip2 = dom-&gt;as_RangeCheck()-&gt;is_range_check(range2, index2, offset2);
1852         // See if this is a _matching_ range check, checking against
1853         // the same array bounds.
1854         if (flip2 == flip1 &amp;&amp; range2 == range1 &amp;&amp; index2 == index1 &amp;&amp;
1855             dom-&gt;outcnt() == 2) {
1856           if (nb_checks == 0 &amp;&amp; dom-&gt;in(1) == in(1)) {
1857             // Found an immediately dominating test at the same offset.
1858             // This kind of back-to-back test can be eliminated locally,
1859             // and there is no need to search further for dominating tests.
1860             assert(offset2 == offset1, &quot;Same test but different offsets&quot;);
1861             found_immediate_dominator = true;
1862             break;
1863           }
1864           // Gather expanded bounds
1865           off_lo = MIN2(off_lo,offset2);
1866           off_hi = MAX2(off_hi,offset2);
1867           // Record top NRC range checks
1868           prev_checks[nb_checks%NRC].ctl = prev_dom;
1869           prev_checks[nb_checks%NRC].off = offset2;
1870           nb_checks++;
1871         }
1872       }
1873       prev_dom = dom;
1874       dom = up_one_dom(dom);
1875       if (!dom) break;
1876     }
1877 
1878     if (!found_immediate_dominator) {
1879       // Attempt to widen the dominating range check to cover some later
1880       // ones.  Since range checks &quot;fail&quot; by uncommon-trapping to the
1881       // interpreter, widening a check can make us speculatively enter
1882       // the interpreter.  If we see range-check deopt&#39;s, do not widen!
1883       if (!phase-&gt;C-&gt;allow_range_check_smearing())  return NULL;
1884 
1885       // Didn&#39;t find prior covering check, so cannot remove anything.
1886       if (nb_checks == 0) {
1887         return NULL;
1888       }
1889       // Constant indices only need to check the upper bound.
1890       // Non-constant indices must check both low and high.
1891       int chk0 = (nb_checks - 1) % NRC;
1892       if (index1) {
1893         if (nb_checks == 1) {
1894           return NULL;
1895         } else {
1896           // If the top range check&#39;s constant is the min or max of
1897           // all constants we widen the next one to cover the whole
1898           // range of constants.
1899           RangeCheck rc0 = prev_checks[chk0];
1900           int chk1 = (nb_checks - 2) % NRC;
1901           RangeCheck rc1 = prev_checks[chk1];
1902           if (rc0.off == off_lo) {
1903             adjust_check(rc1.ctl, range1, index1, flip1, off_hi, igvn);
1904             prev_dom = rc1.ctl;
1905           } else if (rc0.off == off_hi) {
1906             adjust_check(rc1.ctl, range1, index1, flip1, off_lo, igvn);
1907             prev_dom = rc1.ctl;
1908           } else {
1909             // If the top test&#39;s constant is not the min or max of all
1910             // constants, we need 3 range checks. We must leave the
1911             // top test unchanged because widening it would allow the
1912             // accesses it protects to successfully read/write out of
1913             // bounds.
1914             if (nb_checks == 2) {
1915               return NULL;
1916             }
1917             int chk2 = (nb_checks - 3) % NRC;
1918             RangeCheck rc2 = prev_checks[chk2];
1919             // The top range check a+i covers interval: -a &lt;= i &lt; length-a
1920             // The second range check b+i covers interval: -b &lt;= i &lt; length-b
1921             if (rc1.off &lt;= rc0.off) {
1922               // if b &lt;= a, we change the second range check to:
1923               // -min_of_all_constants &lt;= i &lt; length-min_of_all_constants
1924               // Together top and second range checks now cover:
1925               // -min_of_all_constants &lt;= i &lt; length-a
1926               // which is more restrictive than -b &lt;= i &lt; length-b:
1927               // -b &lt;= -min_of_all_constants &lt;= i &lt; length-a &lt;= length-b
1928               // The third check is then changed to:
1929               // -max_of_all_constants &lt;= i &lt; length-max_of_all_constants
1930               // so 2nd and 3rd checks restrict allowed values of i to:
1931               // -min_of_all_constants &lt;= i &lt; length-max_of_all_constants
1932               adjust_check(rc1.ctl, range1, index1, flip1, off_lo, igvn);
1933               adjust_check(rc2.ctl, range1, index1, flip1, off_hi, igvn);
1934             } else {
1935               // if b &gt; a, we change the second range check to:
1936               // -max_of_all_constants &lt;= i &lt; length-max_of_all_constants
1937               // Together top and second range checks now cover:
1938               // -a &lt;= i &lt; length-max_of_all_constants
1939               // which is more restrictive than -b &lt;= i &lt; length-b:
1940               // -b &lt; -a &lt;= i &lt; length-max_of_all_constants &lt;= length-b
1941               // The third check is then changed to:
1942               // -max_of_all_constants &lt;= i &lt; length-max_of_all_constants
1943               // so 2nd and 3rd checks restrict allowed values of i to:
1944               // -min_of_all_constants &lt;= i &lt; length-max_of_all_constants
1945               adjust_check(rc1.ctl, range1, index1, flip1, off_hi, igvn);
1946               adjust_check(rc2.ctl, range1, index1, flip1, off_lo, igvn);
1947             }
1948             prev_dom = rc2.ctl;
1949           }
1950         }
1951       } else {
1952         RangeCheck rc0 = prev_checks[chk0];
1953         // &#39;Widen&#39; the offset of the 1st and only covering check
1954         adjust_check(rc0.ctl, range1, index1, flip1, off_hi, igvn);
1955         // Test is now covered by prior checks, dominate it out
1956         prev_dom = rc0.ctl;
1957       }
1958     }
1959   } else {
1960     prev_dom = search_identical(4);
1961 
1962     if (prev_dom == NULL) {
1963       return NULL;
1964     }
1965   }
1966 
1967   // Replace dominated IfNode
1968   return dominated_by(prev_dom, igvn);
1969 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
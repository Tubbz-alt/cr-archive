<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/loopnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopUnswitch.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopnode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1207                                         Node_List &amp;old_new,
1208                                         int opcode,
1209                                         CloneLoopMode mode);
1210 
1211   // Clone a loop and return the clone head (clone_loop_head).
1212   // Added nodes include int(1), int(0) - disconnected, If, IfTrue, IfFalse,
1213   // This routine was created for usage in CountedLoopReserveKit.
1214   //
1215   //    int(1) -&gt; If -&gt; IfTrue -&gt; original_loop_head
1216   //              |
1217   //              V
1218   //           IfFalse -&gt; clone_loop_head (returned by function pointer)
1219   //
1220   LoopNode* create_reserve_version_of_loop(IdealLoopTree *loop, CountedLoopReserveKit* lk);
1221   // Clone loop with an invariant test (that does not exit) and
1222   // insert a clone of the test that selects which version to
1223   // execute.
1224   void do_unswitching (IdealLoopTree *loop, Node_List &amp;old_new);
1225 
1226   // Find candidate &quot;if&quot; for unswitching
<span class="line-modified">1227   IfNode* find_unswitching_candidate(const IdealLoopTree *loop, Node_List&amp; flattened_checks) const;</span>
1228 
1229   // Range Check Elimination uses this function!
1230   // Constrain the main loop iterations so the affine function:
1231   //    low_limit &lt;= scale_con * I + offset  &lt;  upper_limit
1232   // always holds true.  That is, either increase the number of iterations in
1233   // the pre-loop or the post-loop until the condition holds true in the main
1234   // loop.  Scale_con, offset and limit are all loop invariant.
1235   void add_constraint( int stride_con, int scale_con, Node *offset, Node *low_limit, Node *upper_limit, Node *pre_ctrl, Node **pre_limit, Node **main_limit );
1236   // Helper function for add_constraint().
1237   Node* adjust_limit(int stride_con, Node * scale, Node *offset, Node *rc_limit, Node *loop_limit, Node *pre_ctrl, bool round_up);
1238 
1239   // Partially peel loop up through last_peel node.
1240   bool partial_peel( IdealLoopTree *loop, Node_List &amp;old_new );
1241 
1242   // Create a scheduled list of nodes control dependent on ctrl set.
1243   void scheduled_nodelist( IdealLoopTree *loop, VectorSet&amp; ctrl, Node_List &amp;sched );
1244   // Has a use in the vector set
1245   bool has_use_in_set( Node* n, VectorSet&amp; vset );
1246   // Has use internal to the vector set (ie. not in a phi at the loop head)
1247   bool has_use_internal_to_set( Node* n, VectorSet&amp; vset, IdealLoopTree *loop );
</pre>
</td>
<td>
<hr />
<pre>
1207                                         Node_List &amp;old_new,
1208                                         int opcode,
1209                                         CloneLoopMode mode);
1210 
1211   // Clone a loop and return the clone head (clone_loop_head).
1212   // Added nodes include int(1), int(0) - disconnected, If, IfTrue, IfFalse,
1213   // This routine was created for usage in CountedLoopReserveKit.
1214   //
1215   //    int(1) -&gt; If -&gt; IfTrue -&gt; original_loop_head
1216   //              |
1217   //              V
1218   //           IfFalse -&gt; clone_loop_head (returned by function pointer)
1219   //
1220   LoopNode* create_reserve_version_of_loop(IdealLoopTree *loop, CountedLoopReserveKit* lk);
1221   // Clone loop with an invariant test (that does not exit) and
1222   // insert a clone of the test that selects which version to
1223   // execute.
1224   void do_unswitching (IdealLoopTree *loop, Node_List &amp;old_new);
1225 
1226   // Find candidate &quot;if&quot; for unswitching
<span class="line-modified">1227   IfNode* find_unswitching_candidate(const IdealLoopTree *loop, Node_List&amp; unswitch_iffs) const;</span>
1228 
1229   // Range Check Elimination uses this function!
1230   // Constrain the main loop iterations so the affine function:
1231   //    low_limit &lt;= scale_con * I + offset  &lt;  upper_limit
1232   // always holds true.  That is, either increase the number of iterations in
1233   // the pre-loop or the post-loop until the condition holds true in the main
1234   // loop.  Scale_con, offset and limit are all loop invariant.
1235   void add_constraint( int stride_con, int scale_con, Node *offset, Node *low_limit, Node *upper_limit, Node *pre_ctrl, Node **pre_limit, Node **main_limit );
1236   // Helper function for add_constraint().
1237   Node* adjust_limit(int stride_con, Node * scale, Node *offset, Node *rc_limit, Node *loop_limit, Node *pre_ctrl, bool round_up);
1238 
1239   // Partially peel loop up through last_peel node.
1240   bool partial_peel( IdealLoopTree *loop, Node_List &amp;old_new );
1241 
1242   // Create a scheduled list of nodes control dependent on ctrl set.
1243   void scheduled_nodelist( IdealLoopTree *loop, VectorSet&amp; ctrl, Node_List &amp;sched );
1244   // Has a use in the vector set
1245   bool has_use_in_set( Node* n, VectorSet&amp; vset );
1246   // Has use internal to the vector set (ie. not in a phi at the loop head)
1247   bool has_use_internal_to_set( Node* n, VectorSet&amp; vset, IdealLoopTree *loop );
</pre>
</td>
</tr>
</table>
<center><a href="loopUnswitch.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
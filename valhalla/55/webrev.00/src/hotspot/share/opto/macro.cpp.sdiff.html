<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/macro.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroArrayCopy.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/macro.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1783     transform_later(ctrl);
1784     rawmem = new ProjNode(call, TypeFunc::Memory);
1785     transform_later(rawmem);
1786   }
1787 }
1788 
1789 // Helper for PhaseMacroExpand::expand_allocate_common.
1790 // Initializes the newly-allocated storage.
1791 Node* PhaseMacroExpand::initialize_object(AllocateNode* alloc,
1792                                           Node* control, Node* rawmem, Node* object,
1793                                           Node* klass_node, Node* length,
1794                                           Node* size_in_bytes) {
1795   InitializeNode* init = alloc-&gt;initialization();
1796   // Store the klass &amp; mark bits
1797   Node* mark_node = alloc-&gt;make_ideal_mark(&amp;_igvn, control, rawmem);
1798   if (!mark_node-&gt;is_Con()) {
1799     transform_later(mark_node);
1800   }
1801   rawmem = make_store(control, rawmem, object, oopDesc::mark_offset_in_bytes(), mark_node, TypeX_X-&gt;basic_type());
1802 
<span class="line-modified">1803   BasicType bt = T_METADATA;</span>
<span class="line-removed">1804   Node* metadata = klass_node;</span>
<span class="line-removed">1805   Node* properties = alloc-&gt;in(AllocateNode::StorageProperties);</span>
<span class="line-removed">1806   if (properties != NULL) {</span>
<span class="line-removed">1807     // Encode array storage properties into klass pointer</span>
<span class="line-removed">1808     assert(EnableValhalla, &quot;array storage properties not supported&quot;);</span>
<span class="line-removed">1809     if (UseCompressedClassPointers) {</span>
<span class="line-removed">1810       // Compress the klass pointer before inserting the storage properties value</span>
<span class="line-removed">1811       metadata = transform_later(new EncodePKlassNode(metadata, metadata-&gt;bottom_type()-&gt;make_narrowklass()));</span>
<span class="line-removed">1812       metadata = transform_later(new CastN2INode(metadata));</span>
<span class="line-removed">1813       metadata = transform_later(new OrINode(metadata, transform_later(new ConvL2INode(properties))));</span>
<span class="line-removed">1814       bt = T_INT;</span>
<span class="line-removed">1815     } else {</span>
<span class="line-removed">1816       metadata = transform_later(new CastP2XNode(NULL, metadata));</span>
<span class="line-removed">1817       metadata = transform_later(new OrXNode(metadata, properties));</span>
<span class="line-removed">1818       bt = T_LONG;</span>
<span class="line-removed">1819     }</span>
<span class="line-removed">1820   }</span>
<span class="line-removed">1821   rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), metadata, bt);</span>
<span class="line-removed">1822 </span>
1823   int header_size = alloc-&gt;minimum_header_size();  // conservatively small
1824 
1825   // Array length
1826   if (length != NULL) {         // Arrays need length field
1827     rawmem = make_store(control, rawmem, object, arrayOopDesc::length_offset_in_bytes(), length, T_INT);
1828     // conservatively small header size:
1829     header_size = arrayOopDesc::base_offset_in_bytes(T_BYTE);
1830     ciKlass* k = _igvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
1831     if (k-&gt;is_array_klass())    // we know the exact header size in most cases:
1832       header_size = Klass::layout_helper_header_size(k-&gt;layout_helper());
1833   }
1834 
1835   // Clear the object body, if necessary.
1836   if (init == NULL) {
1837     // The init has somehow disappeared; be cautious and clear everything.
1838     //
1839     // This can happen if a node is allocated but an uncommon trap occurs
1840     // immediately.  In this case, the Initialize gets associated with the
1841     // trap, and may be placed in a different (outer) loop, if the Allocate
1842     // is in a loop.  If (this is rare) the inner loop gets unrolled, then
</pre>
</td>
<td>
<hr />
<pre>
1783     transform_later(ctrl);
1784     rawmem = new ProjNode(call, TypeFunc::Memory);
1785     transform_later(rawmem);
1786   }
1787 }
1788 
1789 // Helper for PhaseMacroExpand::expand_allocate_common.
1790 // Initializes the newly-allocated storage.
1791 Node* PhaseMacroExpand::initialize_object(AllocateNode* alloc,
1792                                           Node* control, Node* rawmem, Node* object,
1793                                           Node* klass_node, Node* length,
1794                                           Node* size_in_bytes) {
1795   InitializeNode* init = alloc-&gt;initialization();
1796   // Store the klass &amp; mark bits
1797   Node* mark_node = alloc-&gt;make_ideal_mark(&amp;_igvn, control, rawmem);
1798   if (!mark_node-&gt;is_Con()) {
1799     transform_later(mark_node);
1800   }
1801   rawmem = make_store(control, rawmem, object, oopDesc::mark_offset_in_bytes(), mark_node, TypeX_X-&gt;basic_type());
1802 
<span class="line-modified">1803   rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);</span>



















1804   int header_size = alloc-&gt;minimum_header_size();  // conservatively small
1805 
1806   // Array length
1807   if (length != NULL) {         // Arrays need length field
1808     rawmem = make_store(control, rawmem, object, arrayOopDesc::length_offset_in_bytes(), length, T_INT);
1809     // conservatively small header size:
1810     header_size = arrayOopDesc::base_offset_in_bytes(T_BYTE);
1811     ciKlass* k = _igvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
1812     if (k-&gt;is_array_klass())    // we know the exact header size in most cases:
1813       header_size = Klass::layout_helper_header_size(k-&gt;layout_helper());
1814   }
1815 
1816   // Clear the object body, if necessary.
1817   if (init == NULL) {
1818     // The init has somehow disappeared; be cautious and clear everything.
1819     //
1820     // This can happen if a node is allocated but an uncommon trap occurs
1821     // immediately.  In this case, the Initialize gets associated with the
1822     // trap, and may be placed in a different (outer) loop, if the Allocate
1823     // is in a loop.  If (this is rare) the inner loop gets unrolled, then
</pre>
</td>
</tr>
</table>
<center><a href="loopnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroArrayCopy.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
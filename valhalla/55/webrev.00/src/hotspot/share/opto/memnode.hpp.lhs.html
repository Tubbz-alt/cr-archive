<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/memnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_MEMNODE_HPP
  26 #define SHARE_OPTO_MEMNODE_HPP
  27 
  28 #include &quot;opto/multnode.hpp&quot;
  29 #include &quot;opto/node.hpp&quot;
  30 #include &quot;opto/opcodes.hpp&quot;
  31 #include &quot;opto/type.hpp&quot;
  32 
  33 // Portions of code courtesy of Clifford Click
  34 
  35 class MultiNode;
  36 class PhaseCCP;
  37 class PhaseTransform;
  38 
  39 //------------------------------MemNode----------------------------------------
  40 // Load or Store, possibly throwing a NULL pointer exception
  41 class MemNode : public Node {
  42 private:
  43   bool _unaligned_access; // Unaligned access from unsafe
  44   bool _mismatched_access; // Mismatched access from unsafe: byte read in integer array for instance
  45   bool _unsafe_access;     // Access of unsafe origin.
  46   uint8_t _barrier; // Bit field with barrier information
  47 
  48 protected:
  49 #ifdef ASSERT
  50   const TypePtr* _adr_type;     // What kind of memory is being addressed?
  51 #endif
  52   virtual uint size_of() const;
  53 public:
  54   enum { Control,               // When is it safe to do this load?
  55          Memory,                // Chunk of memory is being loaded from
  56          Address,               // Actually address, derived from base
  57          ValueIn,               // Value to store
  58          OopStore               // Preceeding oop store, only in StoreCM
  59   };
  60   typedef enum { unordered = 0,
  61                  acquire,       // Load has to acquire or be succeeded by MemBarAcquire.
  62                  release,       // Store has to release or be preceded by MemBarRelease.
  63                  seqcst,        // LoadStore has to have both acquire and release semantics.
  64                  unset          // The memory ordering is not set (used for testing)
  65   } MemOrd;
  66 protected:
  67   MemNode( Node *c0, Node *c1, Node *c2, const TypePtr* at ) :
  68       Node(c0,c1,c2),
  69       _unaligned_access(false),
  70       _mismatched_access(false),
  71       _unsafe_access(false),
  72       _barrier(0) {
  73     init_class_id(Class_Mem);
  74     debug_only(_adr_type=at; adr_type();)
  75   }
  76   MemNode( Node *c0, Node *c1, Node *c2, const TypePtr* at, Node *c3 ) :
  77       Node(c0,c1,c2,c3),
  78       _unaligned_access(false),
  79       _mismatched_access(false),
  80       _unsafe_access(false),
  81       _barrier(0) {
  82     init_class_id(Class_Mem);
  83     debug_only(_adr_type=at; adr_type();)
  84   }
  85   MemNode( Node *c0, Node *c1, Node *c2, const TypePtr* at, Node *c3, Node *c4) :
  86       Node(c0,c1,c2,c3,c4),
  87       _unaligned_access(false),
  88       _mismatched_access(false),
  89       _unsafe_access(false),
  90       _barrier(0) {
  91     init_class_id(Class_Mem);
  92     debug_only(_adr_type=at; adr_type();)
  93   }
  94 
  95   virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*&amp; mem, bool can_see_stored_value) const { return NULL; }
  96   static bool check_if_adr_maybe_raw(Node* adr);
  97 
  98 public:
  99   // Helpers for the optimizer.  Documented in memnode.cpp.
 100   static bool detect_ptr_independence(Node* p1, AllocateNode* a1,
 101                                       Node* p2, AllocateNode* a2,
 102                                       PhaseTransform* phase);
 103   static bool adr_phi_is_loop_invariant(Node* adr_phi, Node* cast);
 104 
 105   static Node *optimize_simple_memory_chain(Node *mchain, const TypeOopPtr *t_oop, Node *load, PhaseGVN *phase);
 106   static Node *optimize_memory_chain(Node *mchain, const TypePtr *t_adr, Node *load, PhaseGVN *phase);
 107   // This one should probably be a phase-specific function:
 108   static bool all_controls_dominate(Node* dom, Node* sub);
 109 
 110   virtual const class TypePtr *adr_type() const;  // returns bottom_type of address
 111 
 112   // Shared code for Ideal methods:
 113   Node *Ideal_common(PhaseGVN *phase, bool can_reshape);  // Return -1 for short-circuit NULL.
 114 
 115   // Helper function for adr_type() implementations.
 116   static const TypePtr* calculate_adr_type(const Type* t, const TypePtr* cross_check = NULL);
 117 
 118   // Raw access function, to allow copying of adr_type efficiently in
 119   // product builds and retain the debug info for debug builds.
 120   const TypePtr *raw_adr_type() const {
 121 #ifdef ASSERT
 122     return _adr_type;
 123 #else
 124     return 0;
 125 #endif
 126   }
 127 
 128 #ifdef ASSERT
 129   void set_adr_type(const TypePtr* adr_type) { _adr_type = adr_type; }
 130 #endif
 131 
 132   // Map a load or store opcode to its corresponding store opcode.
 133   // (Return -1 if unknown.)
 134   virtual int store_Opcode() const { return -1; }
 135 
 136   // What is the type of the value in memory?  (T_VOID mean &quot;unspecified&quot;.)
 137   virtual BasicType memory_type() const = 0;
 138   virtual int memory_size() const {
 139 #ifdef ASSERT
 140     return type2aelembytes(memory_type(), true);
 141 #else
 142     return type2aelembytes(memory_type());
 143 #endif
 144   }
 145 
 146   uint8_t barrier_data() { return _barrier; }
 147   void set_barrier_data(uint8_t barrier_data) { _barrier = barrier_data; }
 148 
 149   // Search through memory states which precede this node (load or store).
 150   // Look for an exact match for the address, with no intervening
 151   // aliased stores.
 152   Node* find_previous_store(PhaseTransform* phase);
 153 
 154   // Can this node (load or store) accurately see a stored value in
 155   // the given memory state?  (The state may or may not be in(Memory).)
 156   Node* can_see_stored_value(Node* st, PhaseTransform* phase) const;
 157 
 158   void set_unaligned_access() { _unaligned_access = true; }
 159   bool is_unaligned_access() const { return _unaligned_access; }
 160   void set_mismatched_access() { _mismatched_access = true; }
 161   bool is_mismatched_access() const { return _mismatched_access; }
 162   void set_unsafe_access() { _unsafe_access = true; }
 163   bool is_unsafe_access() const { return _unsafe_access; }
 164 
 165 #ifndef PRODUCT
 166   static void dump_adr_type(const Node* mem, const TypePtr* adr_type, outputStream *st);
 167   virtual void dump_spec(outputStream *st) const;
 168 #endif
 169 };
 170 
 171 //------------------------------LoadNode---------------------------------------
 172 // Load value; requires Memory and Address
 173 class LoadNode : public MemNode {
 174 public:
 175   // Some loads (from unsafe) should be pinned: they don&#39;t depend only
 176   // on the dominating test.  The field _control_dependency below records
 177   // whether that node depends only on the dominating test.
 178   // Pinned and UnknownControl are similar, but differ in that Pinned
 179   // loads are not allowed to float across safepoints, whereas UnknownControl
 180   // loads are allowed to do that. Therefore, Pinned is stricter.
 181   enum ControlDependency {
 182     Pinned,
 183     UnknownControl,
 184     DependsOnlyOnTest
 185   };
 186 
 187 private:
 188   // LoadNode::hash() doesn&#39;t take the _control_dependency field
 189   // into account: If the graph already has a non-pinned LoadNode and
 190   // we add a pinned LoadNode with the same inputs, it&#39;s safe for GVN
 191   // to replace the pinned LoadNode with the non-pinned LoadNode,
 192   // otherwise it wouldn&#39;t be safe to have a non pinned LoadNode with
 193   // those inputs in the first place. If the graph already has a
 194   // pinned LoadNode and we add a non pinned LoadNode with the same
 195   // inputs, it&#39;s safe (but suboptimal) for GVN to replace the
 196   // non-pinned LoadNode by the pinned LoadNode.
 197   ControlDependency _control_dependency;
 198 
 199   // On platforms with weak memory ordering (e.g., PPC, Ia64) we distinguish
 200   // loads that can be reordered, and such requiring acquire semantics to
 201   // adhere to the Java specification.  The required behaviour is stored in
 202   // this field.
 203   const MemOrd _mo;
 204 
 205   AllocateNode* is_new_object_mark_load(PhaseGVN *phase) const;
 206 
 207 protected:
 208   virtual bool cmp(const Node &amp;n) const;
 209   virtual uint size_of() const; // Size is bigger
 210   // Should LoadNode::Ideal() attempt to remove control edges?
 211   virtual bool can_remove_control() const;
 212   const Type* const _type;      // What kind of value is loaded?
 213 
 214   virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*&amp; mem, bool can_see_stored_value) const;
 215 public:
 216 
 217   LoadNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const Type *rt, MemOrd mo, ControlDependency control_dependency)
 218     : MemNode(c,mem,adr,at), _control_dependency(control_dependency), _mo(mo), _type(rt) {
 219     init_class_id(Class_Load);
 220   }
 221   inline bool is_unordered() const { return !is_acquire(); }
 222   inline bool is_acquire() const {
 223     assert(_mo == unordered || _mo == acquire, &quot;unexpected&quot;);
 224     return _mo == acquire;
 225   }
 226   inline bool is_unsigned() const {
 227     int lop = Opcode();
 228     return (lop == Op_LoadUB) || (lop == Op_LoadUS);
 229   }
 230 
 231   // Polymorphic factory method:
 232   static Node* make(PhaseGVN&amp; gvn, Node *c, Node *mem, Node *adr,
 233                     const TypePtr* at, const Type *rt, BasicType bt,
 234                     MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,
 235                     bool unaligned = false, bool mismatched = false, bool unsafe = false,
 236                     uint8_t barrier_data = 0);
 237 
 238   virtual uint hash()   const;  // Check the type
 239 
 240   // Handle algebraic identities here.  If we have an identity, return the Node
 241   // we are equivalent to.  We look for Load of a Store.
 242   virtual Node* Identity(PhaseGVN* phase);
 243 
 244   // If the load is from Field memory and the pointer is non-null, it might be possible to
 245   // zero out the control input.
 246   // If the offset is constant and the base is an object allocation,
 247   // try to hook me up to the exact initializing store.
 248   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 249 
 250   // Split instance field load through Phi.
 251   Node* split_through_phi(PhaseGVN *phase);
 252 
 253   // Recover original value from boxed values
 254   Node *eliminate_autobox(PhaseGVN *phase);
 255 
 256   // Compute a new Type for this node.  Basically we just do the pre-check,
 257   // then call the virtual add() to set the type.
 258   virtual const Type* Value(PhaseGVN* phase) const;
 259 
 260   // Common methods for LoadKlass and LoadNKlass nodes.
 261   const Type* klass_value_common(PhaseGVN* phase) const;
 262   Node* klass_identity_common(PhaseGVN* phase);
 263 
 264   virtual uint ideal_reg() const;
 265   virtual const Type *bottom_type() const;
 266   // Following method is copied from TypeNode:
 267   void set_type(const Type* t) {
 268     assert(t != NULL, &quot;sanity&quot;);
 269     debug_only(uint check_hash = (VerifyHashTableKeys &amp;&amp; _hash_lock) ? hash() : NO_HASH);
 270     *(const Type**)&amp;_type = t;   // cast away const-ness
 271     // If this node is in the hash table, make sure it doesn&#39;t need a rehash.
 272     assert(check_hash == NO_HASH || check_hash == hash(), &quot;type change must preserve hash code&quot;);
 273   }
 274   const Type* type() const { assert(_type != NULL, &quot;sanity&quot;); return _type; };
 275 
 276   // Do not match memory edge
 277   virtual uint match_edge(uint idx) const;
 278 
 279   // Map a load opcode to its corresponding store opcode.
 280   virtual int store_Opcode() const = 0;
 281 
 282   // Check if the load&#39;s memory input is a Phi node with the same control.
 283   bool is_instance_field_load_with_local_phi(Node* ctrl);
 284 
 285   Node* convert_to_unsigned_load(PhaseGVN&amp; gvn);
 286   Node* convert_to_signed_load(PhaseGVN&amp; gvn);
 287 
 288   void pin() { _control_dependency = Pinned; }
 289   bool has_unknown_control_dependency() const { return _control_dependency == UnknownControl; }
 290 
 291 #ifndef PRODUCT
 292   virtual void dump_spec(outputStream *st) const;
 293 #endif
 294 #ifdef ASSERT
 295   // Helper function to allow a raw load without control edge for some cases
 296   static bool is_immutable_value(Node* adr);
 297 #endif
 298 protected:
 299   const Type* load_array_final_field(const TypeKlassPtr *tkls,
 300                                      ciKlass* klass) const;
 301 
 302   Node* can_see_arraycopy_value(Node* st, PhaseGVN* phase) const;
 303 
 304   // depends_only_on_test is almost always true, and needs to be almost always
 305   // true to enable key hoisting &amp; commoning optimizations.  However, for the
 306   // special case of RawPtr loads from TLS top &amp; end, and other loads performed by
 307   // GC barriers, the control edge carries the dependence preventing hoisting past
 308   // a Safepoint instead of the memory edge.  (An unfortunate consequence of having
 309   // Safepoints not set Raw Memory; itself an unfortunate consequence of having Nodes
 310   // which produce results (new raw memory state) inside of loops preventing all
 311   // manner of other optimizations).  Basically, it&#39;s ugly but so is the alternative.
 312   // See comment in macro.cpp, around line 125 expand_allocate_common().
 313   virtual bool depends_only_on_test() const {
 314     return adr_type() != TypeRawPtr::BOTTOM &amp;&amp; _control_dependency == DependsOnlyOnTest;
 315   }
 316 };
 317 
 318 //------------------------------LoadBNode--------------------------------------
 319 // Load a byte (8bits signed) from memory
 320 class LoadBNode : public LoadNode {
 321 public:
 322   LoadBNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeInt *ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 323     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 324   virtual int Opcode() const;
 325   virtual uint ideal_reg() const { return Op_RegI; }
 326   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 327   virtual const Type* Value(PhaseGVN* phase) const;
 328   virtual int store_Opcode() const { return Op_StoreB; }
 329   virtual BasicType memory_type() const { return T_BYTE; }
 330 };
 331 
 332 //------------------------------LoadUBNode-------------------------------------
 333 // Load a unsigned byte (8bits unsigned) from memory
 334 class LoadUBNode : public LoadNode {
 335 public:
 336   LoadUBNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeInt* ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 337     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 338   virtual int Opcode() const;
 339   virtual uint ideal_reg() const { return Op_RegI; }
 340   virtual Node* Ideal(PhaseGVN *phase, bool can_reshape);
 341   virtual const Type* Value(PhaseGVN* phase) const;
 342   virtual int store_Opcode() const { return Op_StoreB; }
 343   virtual BasicType memory_type() const { return T_BYTE; }
 344 };
 345 
 346 //------------------------------LoadUSNode-------------------------------------
 347 // Load an unsigned short/char (16bits unsigned) from memory
 348 class LoadUSNode : public LoadNode {
 349 public:
 350   LoadUSNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeInt *ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 351     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 352   virtual int Opcode() const;
 353   virtual uint ideal_reg() const { return Op_RegI; }
 354   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 355   virtual const Type* Value(PhaseGVN* phase) const;
 356   virtual int store_Opcode() const { return Op_StoreC; }
 357   virtual BasicType memory_type() const { return T_CHAR; }
 358 };
 359 
 360 //------------------------------LoadSNode--------------------------------------
 361 // Load a short (16bits signed) from memory
 362 class LoadSNode : public LoadNode {
 363 public:
 364   LoadSNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeInt *ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 365     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 366   virtual int Opcode() const;
 367   virtual uint ideal_reg() const { return Op_RegI; }
 368   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 369   virtual const Type* Value(PhaseGVN* phase) const;
 370   virtual int store_Opcode() const { return Op_StoreC; }
 371   virtual BasicType memory_type() const { return T_SHORT; }
 372 };
 373 
 374 //------------------------------LoadINode--------------------------------------
 375 // Load an integer from memory
 376 class LoadINode : public LoadNode {
 377 public:
 378   LoadINode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeInt *ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 379     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 380   virtual int Opcode() const;
 381   virtual uint ideal_reg() const { return Op_RegI; }
 382   virtual int store_Opcode() const { return Op_StoreI; }
 383   virtual BasicType memory_type() const { return T_INT; }
 384 };
 385 
 386 //------------------------------LoadRangeNode----------------------------------
 387 // Load an array length from the array
 388 class LoadRangeNode : public LoadINode {
 389 public:
 390   LoadRangeNode(Node *c, Node *mem, Node *adr, const TypeInt *ti = TypeInt::POS)
 391     : LoadINode(c, mem, adr, TypeAryPtr::RANGE, ti, MemNode::unordered) {}
 392   virtual int Opcode() const;
 393   virtual const Type* Value(PhaseGVN* phase) const;
 394   virtual Node* Identity(PhaseGVN* phase);
 395   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 396 };
 397 
 398 //------------------------------LoadLNode--------------------------------------
 399 // Load a long from memory
 400 class LoadLNode : public LoadNode {
 401   virtual uint hash() const { return LoadNode::hash() + _require_atomic_access; }
 402   virtual bool cmp( const Node &amp;n ) const {
 403     return _require_atomic_access == ((LoadLNode&amp;)n)._require_atomic_access
 404       &amp;&amp; LoadNode::cmp(n);
 405   }
 406   virtual uint size_of() const { return sizeof(*this); }
 407   const bool _require_atomic_access;  // is piecewise load forbidden?
 408 
 409 public:
 410   LoadLNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeLong *tl,
 411             MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest, bool require_atomic_access = false)
 412     : LoadNode(c, mem, adr, at, tl, mo, control_dependency), _require_atomic_access(require_atomic_access) {}
 413   virtual int Opcode() const;
 414   virtual uint ideal_reg() const { return Op_RegL; }
 415   virtual int store_Opcode() const { return Op_StoreL; }
 416   virtual BasicType memory_type() const { return T_LONG; }
 417   bool require_atomic_access() const { return _require_atomic_access; }
 418   static LoadLNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type,
 419                                 const Type* rt, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,
 420                                 bool unaligned = false, bool mismatched = false, bool unsafe = false, uint8_t barrier_data = 0);
 421 #ifndef PRODUCT
 422   virtual void dump_spec(outputStream *st) const {
 423     LoadNode::dump_spec(st);
 424     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 425   }
 426 #endif
 427 };
 428 
 429 //------------------------------LoadL_unalignedNode----------------------------
 430 // Load a long from unaligned memory
 431 class LoadL_unalignedNode : public LoadLNode {
 432 public:
 433   LoadL_unalignedNode(Node *c, Node *mem, Node *adr, const TypePtr* at, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 434     : LoadLNode(c, mem, adr, at, TypeLong::LONG, mo, control_dependency) {}
 435   virtual int Opcode() const;
 436 };
 437 
 438 //------------------------------LoadFNode--------------------------------------
 439 // Load a float (64 bits) from memory
 440 class LoadFNode : public LoadNode {
 441 public:
 442   LoadFNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const Type *t, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 443     : LoadNode(c, mem, adr, at, t, mo, control_dependency) {}
 444   virtual int Opcode() const;
 445   virtual uint ideal_reg() const { return Op_RegF; }
 446   virtual int store_Opcode() const { return Op_StoreF; }
 447   virtual BasicType memory_type() const { return T_FLOAT; }
 448 };
 449 
 450 //------------------------------LoadDNode--------------------------------------
 451 // Load a double (64 bits) from memory
 452 class LoadDNode : public LoadNode {
 453   virtual uint hash() const { return LoadNode::hash() + _require_atomic_access; }
 454   virtual bool cmp( const Node &amp;n ) const {
 455     return _require_atomic_access == ((LoadDNode&amp;)n)._require_atomic_access
 456       &amp;&amp; LoadNode::cmp(n);
 457   }
 458   virtual uint size_of() const { return sizeof(*this); }
 459   const bool _require_atomic_access;  // is piecewise load forbidden?
 460 
 461 public:
 462   LoadDNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const Type *t,
 463             MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest, bool require_atomic_access = false)
 464     : LoadNode(c, mem, adr, at, t, mo, control_dependency), _require_atomic_access(require_atomic_access) {}
 465   virtual int Opcode() const;
 466   virtual uint ideal_reg() const { return Op_RegD; }
 467   virtual int store_Opcode() const { return Op_StoreD; }
 468   virtual BasicType memory_type() const { return T_DOUBLE; }
 469   bool require_atomic_access() const { return _require_atomic_access; }
 470   static LoadDNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type,
 471                                 const Type* rt, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,
 472                                 bool unaligned = false, bool mismatched = false, bool unsafe = false, uint8_t barrier_data = 0);
 473 #ifndef PRODUCT
 474   virtual void dump_spec(outputStream *st) const {
 475     LoadNode::dump_spec(st);
 476     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 477   }
 478 #endif
 479 };
 480 
 481 //------------------------------LoadD_unalignedNode----------------------------
 482 // Load a double from unaligned memory
 483 class LoadD_unalignedNode : public LoadDNode {
 484 public:
 485   LoadD_unalignedNode(Node *c, Node *mem, Node *adr, const TypePtr* at, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 486     : LoadDNode(c, mem, adr, at, Type::DOUBLE, mo, control_dependency) {}
 487   virtual int Opcode() const;
 488 };
 489 
 490 //------------------------------LoadPNode--------------------------------------
 491 // Load a pointer from memory (either object or array)
 492 class LoadPNode : public LoadNode {
 493 public:
 494   LoadPNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypePtr* t, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 495     : LoadNode(c, mem, adr, at, t, mo, control_dependency) {}
 496   virtual int Opcode() const;
 497   virtual uint ideal_reg() const { return Op_RegP; }
 498   virtual int store_Opcode() const { return Op_StoreP; }
 499   virtual BasicType memory_type() const { return T_ADDRESS; }
 500 };
 501 
 502 
 503 //------------------------------LoadNNode--------------------------------------
 504 // Load a narrow oop from memory (either object or array)
 505 class LoadNNode : public LoadNode {
 506 public:
 507   LoadNNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const Type* t, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 508     : LoadNode(c, mem, adr, at, t, mo, control_dependency) {}
 509   virtual int Opcode() const;
 510   virtual uint ideal_reg() const { return Op_RegN; }
 511   virtual int store_Opcode() const { return Op_StoreN; }
 512   virtual BasicType memory_type() const { return T_NARROWOOP; }
 513 };
 514 
 515 //------------------------------LoadKlassNode----------------------------------
 516 // Load a Klass from an object
 517 class LoadKlassNode : public LoadPNode {
 518 private:
 519   bool _clear_prop_bits; // Clear the ArrayStorageProperties bits
 520 protected:
 521   // In most cases, LoadKlassNode does not have the control input set. If the control
 522   // input is set, it must not be removed (by LoadNode::Ideal()).
 523   virtual bool can_remove_control() const;
 524 public:
 525   LoadKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeKlassPtr *tk, MemOrd mo, bool clear_prop_bits)
 526     : LoadPNode(c, mem, adr, at, tk, mo), _clear_prop_bits(clear_prop_bits) {}
 527   virtual uint hash() const { return LoadPNode::hash() + _clear_prop_bits; }
 528   virtual bool cmp(const Node &amp;n) const {
 529     return (_clear_prop_bits == ((LoadKlassNode&amp;)n)._clear_prop_bits) &amp;&amp; LoadPNode::cmp(n);
 530   }
 531   virtual uint size_of() const { return sizeof(*this); }
 532   virtual int Opcode() const;
 533   virtual const Type* Value(PhaseGVN* phase) const;
 534   virtual Node* Identity(PhaseGVN* phase);
 535   virtual bool depends_only_on_test() const { return true; }
 536   bool clear_prop_bits() const { return _clear_prop_bits; }
 537 
 538   // Polymorphic factory method:
 539   static Node* make(PhaseGVN&amp; gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at,
 540                     const TypeKlassPtr* tk = TypeKlassPtr::OBJECT, bool clear_prop_bits = false);
 541 };
 542 
 543 //------------------------------LoadNKlassNode---------------------------------
 544 // Load a narrow Klass from an object.
 545 class LoadNKlassNode : public LoadNNode {
 546 private:
 547   bool _clear_prop_bits; // Clear the ArrayStorageProperties bits
 548 public:
 549   LoadNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeNarrowKlass *tk, MemOrd mo, bool clear_prop_bits)
 550     : LoadNNode(c, mem, adr, at, tk, mo), _clear_prop_bits(clear_prop_bits) {}
 551   virtual uint hash() const { return LoadNNode::hash() + _clear_prop_bits; }
 552   virtual bool cmp(const Node &amp;n) const {
 553     return (_clear_prop_bits == ((LoadNKlassNode&amp;)n)._clear_prop_bits) &amp;&amp; LoadNNode::cmp(n);
 554   }
 555   virtual uint size_of() const { return sizeof(*this); }
 556   virtual int Opcode() const;
 557   virtual uint ideal_reg() const { return Op_RegN; }
 558   virtual int store_Opcode() const { return Op_StoreNKlass; }
 559   virtual BasicType memory_type() const { return T_NARROWKLASS; }
 560 
 561   virtual const Type* Value(PhaseGVN* phase) const;
 562   virtual Node* Identity(PhaseGVN* phase);
 563   virtual bool depends_only_on_test() const { return true; }
 564   bool clear_prop_bits() const { return _clear_prop_bits; }
 565 };
 566 
<a name="1" id="anc1"></a><span class="line-removed"> 567 // Retrieve the null free/flattened property from an array klass. This</span>
<span class="line-removed"> 568 // is treated a bit like a field that would be read from the klass</span>
<span class="line-removed"> 569 // structure at runtime except, the implementation encodes the</span>
<span class="line-removed"> 570 // property as a bit in the klass header field of the array. This</span>
<span class="line-removed"> 571 // implementation detail is hidden under this node so it doesn&#39;t make</span>
<span class="line-removed"> 572 // a difference for high level optimizations. At final graph reshaping</span>
<span class="line-removed"> 573 // time, this node is turned into the actual logical operations that</span>
<span class="line-removed"> 574 // extract the property from the klass pointer. For this to work</span>
<span class="line-removed"> 575 // correctly, GeStoragePropertyNodes must take a LoadKlass/LoadNKlass</span>
<span class="line-removed"> 576 // input. The Ideal transformation splits the GetStoragePropertyNode</span>
<span class="line-removed"> 577 // through phis, Value returns a constant if the node&#39;s input is a</span>
<span class="line-removed"> 578 // constant. These 2 should guarantee GetStoragePropertyNode does</span>
<span class="line-removed"> 579 // indeed have a LoadKlass/LoadNKlass input at final graph reshaping</span>
<span class="line-removed"> 580 // time.</span>
<span class="line-removed"> 581 class GetStoragePropertyNode : public Node {</span>
<span class="line-removed"> 582 protected:</span>
<span class="line-removed"> 583   GetStoragePropertyNode(Node* klass) : Node(NULL, klass) {}</span>
<span class="line-removed"> 584 public:</span>
<span class="line-removed"> 585   virtual const Type* Value(PhaseGVN* phase) const;</span>
<span class="line-removed"> 586   virtual Node* Ideal(PhaseGVN *phase, bool can_reshape);</span>
<span class="line-removed"> 587   virtual const Type* bottom_type() const {</span>
<span class="line-removed"> 588     if (in(1)-&gt;bottom_type()-&gt;isa_klassptr()) {</span>
<span class="line-removed"> 589       return TypeLong::LONG;</span>
<span class="line-removed"> 590     }</span>
<span class="line-removed"> 591     return TypeInt::INT;</span>
<span class="line-removed"> 592   }</span>
<span class="line-removed"> 593 };</span>
<span class="line-removed"> 594 </span>
<span class="line-removed"> 595 </span>
<span class="line-removed"> 596 class GetNullFreePropertyNode : public GetStoragePropertyNode {</span>
<span class="line-removed"> 597 public:</span>
<span class="line-removed"> 598   GetNullFreePropertyNode(Node* klass) : GetStoragePropertyNode(klass) {}</span>
<span class="line-removed"> 599   virtual int Opcode() const;</span>
<span class="line-removed"> 600 };</span>
<span class="line-removed"> 601 </span>
<span class="line-removed"> 602 class GetFlattenedPropertyNode : public GetStoragePropertyNode {</span>
<span class="line-removed"> 603 public:</span>
<span class="line-removed"> 604   GetFlattenedPropertyNode(Node* klass) : GetStoragePropertyNode(klass) {}</span>
<span class="line-removed"> 605   virtual int Opcode() const;</span>
<span class="line-removed"> 606 };</span>
<span class="line-removed"> 607 </span>
 608 //------------------------------StoreNode--------------------------------------
 609 // Store value; requires Store, Address and Value
 610 class StoreNode : public MemNode {
 611 private:
 612   // On platforms with weak memory ordering (e.g., PPC, Ia64) we distinguish
 613   // stores that can be reordered, and such requiring release semantics to
 614   // adhere to the Java specification.  The required behaviour is stored in
 615   // this field.
 616   const MemOrd _mo;
 617   // Needed for proper cloning.
 618   virtual uint size_of() const { return sizeof(*this); }
 619 protected:
 620   virtual bool cmp( const Node &amp;n ) const;
 621   virtual bool depends_only_on_test() const { return false; }
 622 
 623   Node *Ideal_masked_input       (PhaseGVN *phase, uint mask);
 624   Node *Ideal_sign_extended_input(PhaseGVN *phase, int  num_bits);
 625 
 626 public:
 627   // We must ensure that stores of object references will be visible
 628   // only after the object&#39;s initialization. So the callers of this
 629   // procedure must indicate that the store requires `release&#39;
 630   // semantics, if the stored value is an object reference that might
 631   // point to a new object and may become externally visible.
 632   StoreNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 633     : MemNode(c, mem, adr, at, val), _mo(mo) {
 634     init_class_id(Class_Store);
 635   }
 636   StoreNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, Node *oop_store, MemOrd mo)
 637     : MemNode(c, mem, adr, at, val, oop_store), _mo(mo) {
 638     init_class_id(Class_Store);
 639   }
 640 
 641   inline bool is_unordered() const { return !is_release(); }
 642   inline bool is_release() const {
 643     assert((_mo == unordered || _mo == release), &quot;unexpected&quot;);
 644     return _mo == release;
 645   }
 646 
 647   // Conservatively release stores of object references in order to
 648   // ensure visibility of object initialization.
 649   static inline MemOrd release_if_reference(const BasicType t) {
 650 #ifdef AARCH64
 651     // AArch64 doesn&#39;t need a release store here because object
 652     // initialization contains the necessary barriers.
 653     return unordered;
 654 #else
 655     const MemOrd mo = (t == T_ARRAY ||
 656                        t == T_ADDRESS || // Might be the address of an object reference (`boxing&#39;).
 657                        t == T_OBJECT) ? release : unordered;
 658     return mo;
 659 #endif
 660   }
 661 
 662   // Polymorphic factory method
 663   //
 664   // We must ensure that stores of object references will be visible
 665   // only after the object&#39;s initialization. So the callers of this
 666   // procedure must indicate that the store requires `release&#39;
 667   // semantics, if the stored value is an object reference that might
 668   // point to a new object and may become externally visible.
 669   static StoreNode* make(PhaseGVN&amp; gvn, Node *c, Node *mem, Node *adr,
 670                          const TypePtr* at, Node *val, BasicType bt, MemOrd mo);
 671 
 672   virtual uint hash() const;    // Check the type
 673 
 674   // If the store is to Field memory and the pointer is non-null, we can
 675   // zero out the control input.
 676   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 677 
 678   // Compute a new Type for this node.  Basically we just do the pre-check,
 679   // then call the virtual add() to set the type.
 680   virtual const Type* Value(PhaseGVN* phase) const;
 681 
 682   // Check for identity function on memory (Load then Store at same address)
 683   virtual Node* Identity(PhaseGVN* phase);
 684 
 685   // Do not match memory edge
 686   virtual uint match_edge(uint idx) const;
 687 
 688   virtual const Type *bottom_type() const;  // returns Type::MEMORY
 689 
 690   // Map a store opcode to its corresponding own opcode, trivially.
 691   virtual int store_Opcode() const { return Opcode(); }
 692 
 693   // have all possible loads of the value stored been optimized away?
 694   bool value_never_loaded(PhaseTransform *phase) const;
 695 
 696   MemBarNode* trailing_membar() const;
 697 };
 698 
 699 //------------------------------StoreBNode-------------------------------------
 700 // Store byte to memory
 701 class StoreBNode : public StoreNode {
 702 public:
 703   StoreBNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 704     : StoreNode(c, mem, adr, at, val, mo) {}
 705   virtual int Opcode() const;
 706   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 707   virtual BasicType memory_type() const { return T_BYTE; }
 708 };
 709 
 710 //------------------------------StoreCNode-------------------------------------
 711 // Store char/short to memory
 712 class StoreCNode : public StoreNode {
 713 public:
 714   StoreCNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 715     : StoreNode(c, mem, adr, at, val, mo) {}
 716   virtual int Opcode() const;
 717   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 718   virtual BasicType memory_type() const { return T_CHAR; }
 719 };
 720 
 721 //------------------------------StoreINode-------------------------------------
 722 // Store int to memory
 723 class StoreINode : public StoreNode {
 724 public:
 725   StoreINode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 726     : StoreNode(c, mem, adr, at, val, mo) {}
 727   virtual int Opcode() const;
 728   virtual BasicType memory_type() const { return T_INT; }
 729 };
 730 
 731 //------------------------------StoreLNode-------------------------------------
 732 // Store long to memory
 733 class StoreLNode : public StoreNode {
 734   virtual uint hash() const { return StoreNode::hash() + _require_atomic_access; }
 735   virtual bool cmp( const Node &amp;n ) const {
 736     return _require_atomic_access == ((StoreLNode&amp;)n)._require_atomic_access
 737       &amp;&amp; StoreNode::cmp(n);
 738   }
 739   virtual uint size_of() const { return sizeof(*this); }
 740   const bool _require_atomic_access;  // is piecewise store forbidden?
 741 
 742 public:
 743   StoreLNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo, bool require_atomic_access = false)
 744     : StoreNode(c, mem, adr, at, val, mo), _require_atomic_access(require_atomic_access) {}
 745   virtual int Opcode() const;
 746   virtual BasicType memory_type() const { return T_LONG; }
 747   bool require_atomic_access() const { return _require_atomic_access; }
 748   static StoreLNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo);
 749 #ifndef PRODUCT
 750   virtual void dump_spec(outputStream *st) const {
 751     StoreNode::dump_spec(st);
 752     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 753   }
 754 #endif
 755 };
 756 
 757 //------------------------------StoreFNode-------------------------------------
 758 // Store float to memory
 759 class StoreFNode : public StoreNode {
 760 public:
 761   StoreFNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 762     : StoreNode(c, mem, adr, at, val, mo) {}
 763   virtual int Opcode() const;
 764   virtual BasicType memory_type() const { return T_FLOAT; }
 765 };
 766 
 767 //------------------------------StoreDNode-------------------------------------
 768 // Store double to memory
 769 class StoreDNode : public StoreNode {
 770   virtual uint hash() const { return StoreNode::hash() + _require_atomic_access; }
 771   virtual bool cmp( const Node &amp;n ) const {
 772     return _require_atomic_access == ((StoreDNode&amp;)n)._require_atomic_access
 773       &amp;&amp; StoreNode::cmp(n);
 774   }
 775   virtual uint size_of() const { return sizeof(*this); }
 776   const bool _require_atomic_access;  // is piecewise store forbidden?
 777 public:
 778   StoreDNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val,
 779              MemOrd mo, bool require_atomic_access = false)
 780     : StoreNode(c, mem, adr, at, val, mo), _require_atomic_access(require_atomic_access) {}
 781   virtual int Opcode() const;
 782   virtual BasicType memory_type() const { return T_DOUBLE; }
 783   bool require_atomic_access() const { return _require_atomic_access; }
 784   static StoreDNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo);
 785 #ifndef PRODUCT
 786   virtual void dump_spec(outputStream *st) const {
 787     StoreNode::dump_spec(st);
 788     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 789   }
 790 #endif
 791 
 792 };
 793 
 794 //------------------------------StorePNode-------------------------------------
 795 // Store pointer to memory
 796 class StorePNode : public StoreNode {
 797 public:
 798   StorePNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 799     : StoreNode(c, mem, adr, at, val, mo) {}
 800   virtual int Opcode() const;
 801   virtual BasicType memory_type() const { return T_ADDRESS; }
 802 };
 803 
 804 //------------------------------StoreNNode-------------------------------------
 805 // Store narrow oop to memory
 806 class StoreNNode : public StoreNode {
 807 public:
 808   StoreNNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 809     : StoreNode(c, mem, adr, at, val, mo) {}
 810   virtual int Opcode() const;
 811   virtual BasicType memory_type() const { return T_NARROWOOP; }
 812 };
 813 
 814 //------------------------------StoreNKlassNode--------------------------------------
 815 // Store narrow klass to memory
 816 class StoreNKlassNode : public StoreNNode {
 817 public:
 818   StoreNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 819     : StoreNNode(c, mem, adr, at, val, mo) {}
 820   virtual int Opcode() const;
 821   virtual BasicType memory_type() const { return T_NARROWKLASS; }
 822 };
 823 
 824 //------------------------------StoreCMNode-----------------------------------
 825 // Store card-mark byte to memory for CM
 826 // The last StoreCM before a SafePoint must be preserved and occur after its &quot;oop&quot; store
 827 // Preceeding equivalent StoreCMs may be eliminated.
 828 class StoreCMNode : public StoreNode {
 829  private:
 830   virtual uint hash() const { return StoreNode::hash() + _oop_alias_idx; }
 831   virtual bool cmp( const Node &amp;n ) const {
 832     return _oop_alias_idx == ((StoreCMNode&amp;)n)._oop_alias_idx
 833       &amp;&amp; StoreNode::cmp(n);
 834   }
 835   virtual uint size_of() const { return sizeof(*this); }
 836   int _oop_alias_idx;   // The alias_idx of OopStore
 837 
 838 public:
 839   StoreCMNode( Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, Node *oop_store, int oop_alias_idx ) :
 840     StoreNode(c, mem, adr, at, val, oop_store, MemNode::release),
 841     _oop_alias_idx(oop_alias_idx) {
 842     assert(_oop_alias_idx &gt;= Compile::AliasIdxRaw ||
 843            _oop_alias_idx == Compile::AliasIdxBot &amp;&amp; Compile::current()-&gt;AliasLevel() == 0,
 844            &quot;bad oop alias idx&quot;);
 845   }
 846   virtual int Opcode() const;
 847   virtual Node* Identity(PhaseGVN* phase);
 848   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 849   virtual const Type* Value(PhaseGVN* phase) const;
 850   virtual BasicType memory_type() const { return T_VOID; } // unspecific
 851   int oop_alias_idx() const { return _oop_alias_idx; }
 852 };
 853 
 854 //------------------------------LoadPLockedNode---------------------------------
 855 // Load-locked a pointer from memory (either object or array).
 856 // On Sparc &amp; Intel this is implemented as a normal pointer load.
 857 // On PowerPC and friends it&#39;s a real load-locked.
 858 class LoadPLockedNode : public LoadPNode {
 859 public:
 860   LoadPLockedNode(Node *c, Node *mem, Node *adr, MemOrd mo)
 861     : LoadPNode(c, mem, adr, TypeRawPtr::BOTTOM, TypeRawPtr::BOTTOM, mo) {}
 862   virtual int Opcode() const;
 863   virtual int store_Opcode() const { return Op_StorePConditional; }
 864   virtual bool depends_only_on_test() const { return true; }
 865 };
 866 
 867 //------------------------------SCMemProjNode---------------------------------------
 868 // This class defines a projection of the memory  state of a store conditional node.
 869 // These nodes return a value, but also update memory.
 870 class SCMemProjNode : public ProjNode {
 871 public:
 872   enum {SCMEMPROJCON = (uint)-2};
 873   SCMemProjNode( Node *src) : ProjNode( src, SCMEMPROJCON) { }
 874   virtual int Opcode() const;
 875   virtual bool      is_CFG() const  { return false; }
 876   virtual const Type *bottom_type() const {return Type::MEMORY;}
 877   virtual const TypePtr *adr_type() const {
 878     Node* ctrl = in(0);
 879     if (ctrl == NULL)  return NULL; // node is dead
 880     return ctrl-&gt;in(MemNode::Memory)-&gt;adr_type();
 881   }
 882   virtual uint ideal_reg() const { return 0;} // memory projections don&#39;t have a register
 883   virtual const Type* Value(PhaseGVN* phase) const;
 884 #ifndef PRODUCT
 885   virtual void dump_spec(outputStream *st) const {};
 886 #endif
 887 };
 888 
 889 //------------------------------LoadStoreNode---------------------------
 890 // Note: is_Mem() method returns &#39;true&#39; for this class.
 891 class LoadStoreNode : public Node {
 892 private:
 893   const Type* const _type;      // What kind of value is loaded?
 894   const TypePtr* _adr_type;     // What kind of memory is being addressed?
 895   uint8_t _barrier; // Bit field with barrier information
 896   virtual uint size_of() const; // Size is bigger
 897 public:
 898   LoadStoreNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at, const Type* rt, uint required );
 899   virtual bool depends_only_on_test() const { return false; }
 900   virtual uint match_edge(uint idx) const { return idx == MemNode::Address || idx == MemNode::ValueIn; }
 901 
 902   virtual const Type *bottom_type() const { return _type; }
 903   virtual uint ideal_reg() const;
 904   virtual const class TypePtr *adr_type() const { return _adr_type; }  // returns bottom_type of address
 905 
 906   bool result_not_used() const;
 907   MemBarNode* trailing_membar() const;
 908 
 909   uint8_t barrier_data() { return _barrier; }
 910   void set_barrier_data(uint8_t barrier_data) { _barrier = barrier_data; }
 911 };
 912 
 913 class LoadStoreConditionalNode : public LoadStoreNode {
 914 public:
 915   enum {
 916     ExpectedIn = MemNode::ValueIn+1 // One more input than MemNode
 917   };
 918   LoadStoreConditionalNode(Node *c, Node *mem, Node *adr, Node *val, Node *ex);
 919 };
 920 
 921 //------------------------------StorePConditionalNode---------------------------
 922 // Conditionally store pointer to memory, if no change since prior
 923 // load-locked.  Sets flags for success or failure of the store.
 924 class StorePConditionalNode : public LoadStoreConditionalNode {
 925 public:
 926   StorePConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ll ) : LoadStoreConditionalNode(c, mem, adr, val, ll) { }
 927   virtual int Opcode() const;
 928   // Produces flags
 929   virtual uint ideal_reg() const { return Op_RegFlags; }
 930 };
 931 
 932 //------------------------------StoreIConditionalNode---------------------------
 933 // Conditionally store int to memory, if no change since prior
 934 // load-locked.  Sets flags for success or failure of the store.
 935 class StoreIConditionalNode : public LoadStoreConditionalNode {
 936 public:
 937   StoreIConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ii ) : LoadStoreConditionalNode(c, mem, adr, val, ii) { }
 938   virtual int Opcode() const;
 939   // Produces flags
 940   virtual uint ideal_reg() const { return Op_RegFlags; }
 941 };
 942 
 943 //------------------------------StoreLConditionalNode---------------------------
 944 // Conditionally store long to memory, if no change since prior
 945 // load-locked.  Sets flags for success or failure of the store.
 946 class StoreLConditionalNode : public LoadStoreConditionalNode {
 947 public:
 948   StoreLConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ll ) : LoadStoreConditionalNode(c, mem, adr, val, ll) { }
 949   virtual int Opcode() const;
 950   // Produces flags
 951   virtual uint ideal_reg() const { return Op_RegFlags; }
 952 };
 953 
 954 class CompareAndSwapNode : public LoadStoreConditionalNode {
 955 private:
 956   const MemNode::MemOrd _mem_ord;
 957 public:
 958   CompareAndSwapNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : LoadStoreConditionalNode(c, mem, adr, val, ex), _mem_ord(mem_ord) {}
 959   MemNode::MemOrd order() const {
 960     return _mem_ord;
 961   }
 962   virtual uint size_of() const { return sizeof(*this); }
 963 };
 964 
 965 class CompareAndExchangeNode : public LoadStoreNode {
 966 private:
 967   const MemNode::MemOrd _mem_ord;
 968 public:
 969   enum {
 970     ExpectedIn = MemNode::ValueIn+1 // One more input than MemNode
 971   };
 972   CompareAndExchangeNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord, const TypePtr* at, const Type* t) :
 973     LoadStoreNode(c, mem, adr, val, at, t, 5), _mem_ord(mem_ord) {
 974      init_req(ExpectedIn, ex );
 975   }
 976 
 977   MemNode::MemOrd order() const {
 978     return _mem_ord;
 979   }
 980   virtual uint size_of() const { return sizeof(*this); }
 981 };
 982 
 983 //------------------------------CompareAndSwapBNode---------------------------
 984 class CompareAndSwapBNode : public CompareAndSwapNode {
 985 public:
 986   CompareAndSwapBNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 987   virtual int Opcode() const;
 988 };
 989 
 990 //------------------------------CompareAndSwapSNode---------------------------
 991 class CompareAndSwapSNode : public CompareAndSwapNode {
 992 public:
 993   CompareAndSwapSNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 994   virtual int Opcode() const;
 995 };
 996 
 997 //------------------------------CompareAndSwapINode---------------------------
 998 class CompareAndSwapINode : public CompareAndSwapNode {
 999 public:
1000   CompareAndSwapINode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
1001   virtual int Opcode() const;
1002 };
1003 
1004 //------------------------------CompareAndSwapLNode---------------------------
1005 class CompareAndSwapLNode : public CompareAndSwapNode {
1006 public:
1007   CompareAndSwapLNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
1008   virtual int Opcode() const;
1009 };
1010 
1011 //------------------------------CompareAndSwapPNode---------------------------
1012 class CompareAndSwapPNode : public CompareAndSwapNode {
1013 public:
1014   CompareAndSwapPNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
1015   virtual int Opcode() const;
1016 };
1017 
1018 //------------------------------CompareAndSwapNNode---------------------------
1019 class CompareAndSwapNNode : public CompareAndSwapNode {
1020 public:
1021   CompareAndSwapNNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
1022   virtual int Opcode() const;
1023 };
1024 
1025 //------------------------------WeakCompareAndSwapBNode---------------------------
1026 class WeakCompareAndSwapBNode : public CompareAndSwapNode {
1027 public:
1028   WeakCompareAndSwapBNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
1029   virtual int Opcode() const;
1030 };
1031 
1032 //------------------------------WeakCompareAndSwapSNode---------------------------
1033 class WeakCompareAndSwapSNode : public CompareAndSwapNode {
1034 public:
1035   WeakCompareAndSwapSNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
1036   virtual int Opcode() const;
1037 };
1038 
1039 //------------------------------WeakCompareAndSwapINode---------------------------
1040 class WeakCompareAndSwapINode : public CompareAndSwapNode {
1041 public:
1042   WeakCompareAndSwapINode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
1043   virtual int Opcode() const;
1044 };
1045 
1046 //------------------------------WeakCompareAndSwapLNode---------------------------
1047 class WeakCompareAndSwapLNode : public CompareAndSwapNode {
1048 public:
1049   WeakCompareAndSwapLNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
1050   virtual int Opcode() const;
1051 };
1052 
1053 //------------------------------WeakCompareAndSwapPNode---------------------------
1054 class WeakCompareAndSwapPNode : public CompareAndSwapNode {
1055 public:
1056   WeakCompareAndSwapPNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
1057   virtual int Opcode() const;
1058 };
1059 
1060 //------------------------------WeakCompareAndSwapNNode---------------------------
1061 class WeakCompareAndSwapNNode : public CompareAndSwapNode {
1062 public:
1063   WeakCompareAndSwapNNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
1064   virtual int Opcode() const;
1065 };
1066 
1067 //------------------------------CompareAndExchangeBNode---------------------------
1068 class CompareAndExchangeBNode : public CompareAndExchangeNode {
1069 public:
1070   CompareAndExchangeBNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, TypeInt::BYTE) { }
1071   virtual int Opcode() const;
1072 };
1073 
1074 
1075 //------------------------------CompareAndExchangeSNode---------------------------
1076 class CompareAndExchangeSNode : public CompareAndExchangeNode {
1077 public:
1078   CompareAndExchangeSNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, TypeInt::SHORT) { }
1079   virtual int Opcode() const;
1080 };
1081 
1082 //------------------------------CompareAndExchangeLNode---------------------------
1083 class CompareAndExchangeLNode : public CompareAndExchangeNode {
1084 public:
1085   CompareAndExchangeLNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, TypeLong::LONG) { }
1086   virtual int Opcode() const;
1087 };
1088 
1089 
1090 //------------------------------CompareAndExchangeINode---------------------------
1091 class CompareAndExchangeINode : public CompareAndExchangeNode {
1092 public:
1093   CompareAndExchangeINode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, TypeInt::INT) { }
1094   virtual int Opcode() const;
1095 };
1096 
1097 
1098 //------------------------------CompareAndExchangePNode---------------------------
1099 class CompareAndExchangePNode : public CompareAndExchangeNode {
1100 public:
1101   CompareAndExchangePNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, const Type* t, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, t) { }
1102   virtual int Opcode() const;
1103 };
1104 
1105 //------------------------------CompareAndExchangeNNode---------------------------
1106 class CompareAndExchangeNNode : public CompareAndExchangeNode {
1107 public:
1108   CompareAndExchangeNNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, const Type* t, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, t) { }
1109   virtual int Opcode() const;
1110 };
1111 
1112 //------------------------------GetAndAddBNode---------------------------
1113 class GetAndAddBNode : public LoadStoreNode {
1114 public:
1115   GetAndAddBNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::BYTE, 4) { }
1116   virtual int Opcode() const;
1117 };
1118 
1119 //------------------------------GetAndAddSNode---------------------------
1120 class GetAndAddSNode : public LoadStoreNode {
1121 public:
1122   GetAndAddSNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::SHORT, 4) { }
1123   virtual int Opcode() const;
1124 };
1125 
1126 //------------------------------GetAndAddINode---------------------------
1127 class GetAndAddINode : public LoadStoreNode {
1128 public:
1129   GetAndAddINode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::INT, 4) { }
1130   virtual int Opcode() const;
1131 };
1132 
1133 //------------------------------GetAndAddLNode---------------------------
1134 class GetAndAddLNode : public LoadStoreNode {
1135 public:
1136   GetAndAddLNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeLong::LONG, 4) { }
1137   virtual int Opcode() const;
1138 };
1139 
1140 //------------------------------GetAndSetBNode---------------------------
1141 class GetAndSetBNode : public LoadStoreNode {
1142 public:
1143   GetAndSetBNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::BYTE, 4) { }
1144   virtual int Opcode() const;
1145 };
1146 
1147 //------------------------------GetAndSetSNode---------------------------
1148 class GetAndSetSNode : public LoadStoreNode {
1149 public:
1150   GetAndSetSNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::SHORT, 4) { }
1151   virtual int Opcode() const;
1152 };
1153 
1154 //------------------------------GetAndSetINode---------------------------
1155 class GetAndSetINode : public LoadStoreNode {
1156 public:
1157   GetAndSetINode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::INT, 4) { }
1158   virtual int Opcode() const;
1159 };
1160 
1161 //------------------------------GetAndSetLNode---------------------------
1162 class GetAndSetLNode : public LoadStoreNode {
1163 public:
1164   GetAndSetLNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeLong::LONG, 4) { }
1165   virtual int Opcode() const;
1166 };
1167 
1168 //------------------------------GetAndSetPNode---------------------------
1169 class GetAndSetPNode : public LoadStoreNode {
1170 public:
1171   GetAndSetPNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at, const Type* t ) : LoadStoreNode(c, mem, adr, val, at, t, 4) { }
1172   virtual int Opcode() const;
1173 };
1174 
1175 //------------------------------GetAndSetNNode---------------------------
1176 class GetAndSetNNode : public LoadStoreNode {
1177 public:
1178   GetAndSetNNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at, const Type* t ) : LoadStoreNode(c, mem, adr, val, at, t, 4) { }
1179   virtual int Opcode() const;
1180 };
1181 
1182 //------------------------------ClearArray-------------------------------------
1183 class ClearArrayNode: public Node {
1184 private:
1185   bool _is_large;
1186   bool _word_copy_only;
1187 public:
1188   ClearArrayNode( Node *ctrl, Node *arymem, Node *word_cnt, Node *base, Node* val, bool is_large)
1189     : Node(ctrl, arymem, word_cnt, base, val), _is_large(is_large),
1190       _word_copy_only(val-&gt;bottom_type()-&gt;isa_long() &amp;&amp; (!val-&gt;bottom_type()-&gt;is_long()-&gt;is_con() || val-&gt;bottom_type()-&gt;is_long()-&gt;get_con() != 0)) {
1191     init_class_id(Class_ClearArray);
1192   }
1193   virtual int         Opcode() const;
1194   virtual const Type *bottom_type() const { return Type::MEMORY; }
1195   // ClearArray modifies array elements, and so affects only the
1196   // array memory addressed by the bottom_type of its base address.
1197   virtual const class TypePtr *adr_type() const;
1198   virtual Node* Identity(PhaseGVN* phase);
1199   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1200   virtual uint match_edge(uint idx) const;
1201   bool is_large() const { return _is_large; }
1202   bool word_copy_only() const { return _word_copy_only; }
1203 
1204   // Clear the given area of an object or array.
1205   // The start offset must always be aligned mod BytesPerInt.
1206   // The end offset must always be aligned mod BytesPerLong.
1207   // Return the new memory.
1208   static Node* clear_memory(Node* control, Node* mem, Node* dest,
1209                             Node* val,
1210                             Node* raw_val,
1211                             intptr_t start_offset,
1212                             intptr_t end_offset,
1213                             PhaseGVN* phase);
1214   static Node* clear_memory(Node* control, Node* mem, Node* dest,
1215                             Node* val,
1216                             Node* raw_val,
1217                             intptr_t start_offset,
1218                             Node* end_offset,
1219                             PhaseGVN* phase);
1220   static Node* clear_memory(Node* control, Node* mem, Node* dest,
1221                             Node* raw_val,
1222                             Node* start_offset,
1223                             Node* end_offset,
1224                             PhaseGVN* phase);
1225   // Return allocation input memory edge if it is different instance
1226   // or itself if it is the one we are looking for.
1227   static bool step_through(Node** np, uint instance_id, PhaseTransform* phase);
1228 };
1229 
1230 //------------------------------MemBar-----------------------------------------
1231 // There are different flavors of Memory Barriers to match the Java Memory
1232 // Model.  Monitor-enter and volatile-load act as Aquires: no following ref
1233 // can be moved to before them.  We insert a MemBar-Acquire after a FastLock or
1234 // volatile-load.  Monitor-exit and volatile-store act as Release: no
1235 // preceding ref can be moved to after them.  We insert a MemBar-Release
1236 // before a FastUnlock or volatile-store.  All volatiles need to be
1237 // serialized, so we follow all volatile-stores with a MemBar-Volatile to
1238 // separate it from any following volatile-load.
1239 class MemBarNode: public MultiNode {
1240   virtual uint hash() const ;                  // { return NO_HASH; }
1241   virtual bool cmp( const Node &amp;n ) const ;    // Always fail, except on self
1242 
1243   virtual uint size_of() const { return sizeof(*this); }
1244   // Memory type this node is serializing.  Usually either rawptr or bottom.
1245   const TypePtr* _adr_type;
1246 
1247   // How is this membar related to a nearby memory access?
1248   enum {
1249     Standalone,
1250     TrailingLoad,
1251     TrailingStore,
1252     LeadingStore,
1253     TrailingLoadStore,
1254     LeadingLoadStore
1255   } _kind;
1256 
1257 #ifdef ASSERT
1258   uint _pair_idx;
1259 #endif
1260 
1261 public:
1262   enum {
1263     Precedent = TypeFunc::Parms  // optional edge to force precedence
1264   };
1265   MemBarNode(Compile* C, int alias_idx, Node* precedent);
1266   virtual int Opcode() const = 0;
1267   virtual const class TypePtr *adr_type() const { return _adr_type; }
1268   virtual const Type* Value(PhaseGVN* phase) const;
1269   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1270   virtual uint match_edge(uint idx) const { return 0; }
1271   virtual const Type *bottom_type() const { return TypeTuple::MEMBAR; }
1272   virtual Node *match(const ProjNode *proj, const Matcher *m, const RegMask* mask);
1273   // Factory method.  Builds a wide or narrow membar.
1274   // Optional &#39;precedent&#39; becomes an extra edge if not null.
1275   static MemBarNode* make(Compile* C, int opcode,
1276                           int alias_idx = Compile::AliasIdxBot,
1277                           Node* precedent = NULL);
1278 
1279   MemBarNode* trailing_membar() const;
1280   MemBarNode* leading_membar() const;
1281 
1282   void set_trailing_load() { _kind = TrailingLoad; }
1283   bool trailing_load() const { return _kind == TrailingLoad; }
1284   bool trailing_store() const { return _kind == TrailingStore; }
1285   bool leading_store() const { return _kind == LeadingStore; }
1286   bool trailing_load_store() const { return _kind == TrailingLoadStore; }
1287   bool leading_load_store() const { return _kind == LeadingLoadStore; }
1288   bool trailing() const { return _kind == TrailingLoad || _kind == TrailingStore || _kind == TrailingLoadStore; }
1289   bool leading() const { return _kind == LeadingStore || _kind == LeadingLoadStore; }
1290   bool standalone() const { return _kind == Standalone; }
1291 
1292   static void set_store_pair(MemBarNode* leading, MemBarNode* trailing);
1293   static void set_load_store_pair(MemBarNode* leading, MemBarNode* trailing);
1294 
1295   void remove(PhaseIterGVN *igvn);
1296 };
1297 
1298 // &quot;Acquire&quot; - no following ref can move before (but earlier refs can
1299 // follow, like an early Load stalled in cache).  Requires multi-cpu
1300 // visibility.  Inserted after a volatile load.
1301 class MemBarAcquireNode: public MemBarNode {
1302 public:
1303   MemBarAcquireNode(Compile* C, int alias_idx, Node* precedent)
1304     : MemBarNode(C, alias_idx, precedent) {}
1305   virtual int Opcode() const;
1306 };
1307 
1308 // &quot;Acquire&quot; - no following ref can move before (but earlier refs can
1309 // follow, like an early Load stalled in cache).  Requires multi-cpu
1310 // visibility.  Inserted independ of any load, as required
1311 // for intrinsic Unsafe.loadFence().
1312 class LoadFenceNode: public MemBarNode {
1313 public:
1314   LoadFenceNode(Compile* C, int alias_idx, Node* precedent)
1315     : MemBarNode(C, alias_idx, precedent) {}
1316   virtual int Opcode() const;
1317 };
1318 
1319 // &quot;Release&quot; - no earlier ref can move after (but later refs can move
1320 // up, like a speculative pipelined cache-hitting Load).  Requires
1321 // multi-cpu visibility.  Inserted before a volatile store.
1322 class MemBarReleaseNode: public MemBarNode {
1323 public:
1324   MemBarReleaseNode(Compile* C, int alias_idx, Node* precedent)
1325     : MemBarNode(C, alias_idx, precedent) {}
1326   virtual int Opcode() const;
1327 };
1328 
1329 // &quot;Release&quot; - no earlier ref can move after (but later refs can move
1330 // up, like a speculative pipelined cache-hitting Load).  Requires
1331 // multi-cpu visibility.  Inserted independent of any store, as required
1332 // for intrinsic Unsafe.storeFence().
1333 class StoreFenceNode: public MemBarNode {
1334 public:
1335   StoreFenceNode(Compile* C, int alias_idx, Node* precedent)
1336     : MemBarNode(C, alias_idx, precedent) {}
1337   virtual int Opcode() const;
1338 };
1339 
1340 // &quot;Acquire&quot; - no following ref can move before (but earlier refs can
1341 // follow, like an early Load stalled in cache).  Requires multi-cpu
1342 // visibility.  Inserted after a FastLock.
1343 class MemBarAcquireLockNode: public MemBarNode {
1344 public:
1345   MemBarAcquireLockNode(Compile* C, int alias_idx, Node* precedent)
1346     : MemBarNode(C, alias_idx, precedent) {}
1347   virtual int Opcode() const;
1348 };
1349 
1350 // &quot;Release&quot; - no earlier ref can move after (but later refs can move
1351 // up, like a speculative pipelined cache-hitting Load).  Requires
1352 // multi-cpu visibility.  Inserted before a FastUnLock.
1353 class MemBarReleaseLockNode: public MemBarNode {
1354 public:
1355   MemBarReleaseLockNode(Compile* C, int alias_idx, Node* precedent)
1356     : MemBarNode(C, alias_idx, precedent) {}
1357   virtual int Opcode() const;
1358 };
1359 
1360 class MemBarStoreStoreNode: public MemBarNode {
1361 public:
1362   MemBarStoreStoreNode(Compile* C, int alias_idx, Node* precedent)
1363     : MemBarNode(C, alias_idx, precedent) {
1364     init_class_id(Class_MemBarStoreStore);
1365   }
1366   virtual int Opcode() const;
1367 };
1368 
1369 // Ordering between a volatile store and a following volatile load.
1370 // Requires multi-CPU visibility?
1371 class MemBarVolatileNode: public MemBarNode {
1372 public:
1373   MemBarVolatileNode(Compile* C, int alias_idx, Node* precedent)
1374     : MemBarNode(C, alias_idx, precedent) {}
1375   virtual int Opcode() const;
1376 };
1377 
1378 // Ordering within the same CPU.  Used to order unsafe memory references
1379 // inside the compiler when we lack alias info.  Not needed &quot;outside&quot; the
1380 // compiler because the CPU does all the ordering for us.
1381 class MemBarCPUOrderNode: public MemBarNode {
1382 public:
1383   MemBarCPUOrderNode(Compile* C, int alias_idx, Node* precedent)
1384     : MemBarNode(C, alias_idx, precedent) {}
1385   virtual int Opcode() const;
1386   virtual uint ideal_reg() const { return 0; } // not matched in the AD file
1387 };
1388 
1389 class OnSpinWaitNode: public MemBarNode {
1390 public:
1391   OnSpinWaitNode(Compile* C, int alias_idx, Node* precedent)
1392     : MemBarNode(C, alias_idx, precedent) {}
1393   virtual int Opcode() const;
1394 };
1395 
1396 // Isolation of object setup after an AllocateNode and before next safepoint.
1397 // (See comment in memnode.cpp near InitializeNode::InitializeNode for semantics.)
1398 class InitializeNode: public MemBarNode {
1399   friend class AllocateNode;
1400 
1401   enum {
1402     Incomplete    = 0,
1403     Complete      = 1,
1404     WithArraycopy = 2
1405   };
1406   int _is_complete;
1407 
1408   bool _does_not_escape;
1409 
1410 public:
1411   enum {
1412     Control    = TypeFunc::Control,
1413     Memory     = TypeFunc::Memory,     // MergeMem for states affected by this op
1414     RawAddress = TypeFunc::Parms+0,    // the newly-allocated raw address
1415     RawStores  = TypeFunc::Parms+1     // zero or more stores (or TOP)
1416   };
1417 
1418   InitializeNode(Compile* C, int adr_type, Node* rawoop);
1419   virtual int Opcode() const;
1420   virtual uint size_of() const { return sizeof(*this); }
1421   virtual uint ideal_reg() const { return 0; } // not matched in the AD file
1422   virtual const RegMask &amp;in_RegMask(uint) const;  // mask for RawAddress
1423 
1424   // Manage incoming memory edges via a MergeMem on in(Memory):
1425   Node* memory(uint alias_idx);
1426 
1427   // The raw memory edge coming directly from the Allocation.
1428   // The contents of this memory are *always* all-zero-bits.
1429   Node* zero_memory() { return memory(Compile::AliasIdxRaw); }
1430 
1431   // Return the corresponding allocation for this initialization (or null if none).
1432   // (Note: Both InitializeNode::allocation and AllocateNode::initialization
1433   // are defined in graphKit.cpp, which sets up the bidirectional relation.)
1434   AllocateNode* allocation();
1435 
1436   // Anything other than zeroing in this init?
1437   bool is_non_zero();
1438 
1439   // An InitializeNode must completed before macro expansion is done.
1440   // Completion requires that the AllocateNode must be followed by
1441   // initialization of the new memory to zero, then to any initializers.
1442   bool is_complete() { return _is_complete != Incomplete; }
1443   bool is_complete_with_arraycopy() { return (_is_complete &amp; WithArraycopy) != 0; }
1444 
1445   // Mark complete.  (Must not yet be complete.)
1446   void set_complete(PhaseGVN* phase);
1447   void set_complete_with_arraycopy() { _is_complete = Complete | WithArraycopy; }
1448 
1449   bool does_not_escape() { return _does_not_escape; }
1450   void set_does_not_escape() { _does_not_escape = true; }
1451 
1452 #ifdef ASSERT
1453   // ensure all non-degenerate stores are ordered and non-overlapping
1454   bool stores_are_sane(PhaseTransform* phase);
1455 #endif //ASSERT
1456 
1457   // See if this store can be captured; return offset where it initializes.
1458   // Return 0 if the store cannot be moved (any sort of problem).
1459   intptr_t can_capture_store(StoreNode* st, PhaseGVN* phase, bool can_reshape);
1460 
1461   // Capture another store; reformat it to write my internal raw memory.
1462   // Return the captured copy, else NULL if there is some sort of problem.
1463   Node* capture_store(StoreNode* st, intptr_t start, PhaseGVN* phase, bool can_reshape);
1464 
1465   // Find captured store which corresponds to the range [start..start+size).
1466   // Return my own memory projection (meaning the initial zero bits)
1467   // if there is no such store.  Return NULL if there is a problem.
1468   Node* find_captured_store(intptr_t start, int size_in_bytes, PhaseTransform* phase);
1469 
1470   // Called when the associated AllocateNode is expanded into CFG.
1471   Node* complete_stores(Node* rawctl, Node* rawmem, Node* rawptr,
1472                         intptr_t header_size, Node* size_in_bytes,
1473                         PhaseIterGVN* phase);
1474 
1475  private:
1476   void remove_extra_zeroes();
1477 
1478   // Find out where a captured store should be placed (or already is placed).
1479   int captured_store_insertion_point(intptr_t start, int size_in_bytes,
1480                                      PhaseTransform* phase);
1481 
1482   static intptr_t get_store_offset(Node* st, PhaseTransform* phase);
1483 
1484   Node* make_raw_address(intptr_t offset, PhaseTransform* phase);
1485 
1486   bool detect_init_independence(Node* value, PhaseGVN* phase);
1487 
1488   void coalesce_subword_stores(intptr_t header_size, Node* size_in_bytes,
1489                                PhaseGVN* phase);
1490 
1491   intptr_t find_next_fullword_store(uint i, PhaseGVN* phase);
1492 };
1493 
1494 //------------------------------MergeMem---------------------------------------
1495 // (See comment in memnode.cpp near MergeMemNode::MergeMemNode for semantics.)
1496 class MergeMemNode: public Node {
1497   virtual uint hash() const ;                  // { return NO_HASH; }
1498   virtual bool cmp( const Node &amp;n ) const ;    // Always fail, except on self
1499   friend class MergeMemStream;
1500   MergeMemNode(Node* def);  // clients use MergeMemNode::make
1501 
1502 public:
1503   // If the input is a whole memory state, clone it with all its slices intact.
1504   // Otherwise, make a new memory state with just that base memory input.
1505   // In either case, the result is a newly created MergeMem.
1506   static MergeMemNode* make(Node* base_memory);
1507 
1508   virtual int Opcode() const;
1509   virtual Node* Identity(PhaseGVN* phase);
1510   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1511   virtual uint ideal_reg() const { return NotAMachineReg; }
1512   virtual uint match_edge(uint idx) const { return 0; }
1513   virtual const RegMask &amp;out_RegMask() const;
1514   virtual const Type *bottom_type() const { return Type::MEMORY; }
1515   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }
1516   // sparse accessors
1517   // Fetch the previously stored &quot;set_memory_at&quot;, or else the base memory.
1518   // (Caller should clone it if it is a phi-nest.)
1519   Node* memory_at(uint alias_idx) const;
1520   // set the memory, regardless of its previous value
1521   void set_memory_at(uint alias_idx, Node* n);
1522   // the &quot;base&quot; is the memory that provides the non-finite support
1523   Node* base_memory() const       { return in(Compile::AliasIdxBot); }
1524   // warning: setting the base can implicitly set any of the other slices too
1525   void set_base_memory(Node* def);
1526   // sentinel value which denotes a copy of the base memory:
1527   Node*   empty_memory() const    { return in(Compile::AliasIdxTop); }
1528   static Node* make_empty_memory(); // where the sentinel comes from
1529   bool is_empty_memory(Node* n) const { assert((n == empty_memory()) == n-&gt;is_top(), &quot;sanity&quot;); return n-&gt;is_top(); }
1530   // hook for the iterator, to perform any necessary setup
1531   void iteration_setup(const MergeMemNode* other = NULL);
1532   // push sentinels until I am at least as long as the other (semantic no-op)
1533   void grow_to_match(const MergeMemNode* other);
1534   bool verify_sparse() const PRODUCT_RETURN0;
1535 #ifndef PRODUCT
1536   virtual void dump_spec(outputStream *st) const;
1537 #endif
1538 };
1539 
1540 class MergeMemStream : public StackObj {
1541  private:
1542   MergeMemNode*       _mm;
1543   const MergeMemNode* _mm2;  // optional second guy, contributes non-empty iterations
1544   Node*               _mm_base;  // loop-invariant base memory of _mm
1545   int                 _idx;
1546   int                 _cnt;
1547   Node*               _mem;
1548   Node*               _mem2;
1549   int                 _cnt2;
1550 
1551   void init(MergeMemNode* mm, const MergeMemNode* mm2 = NULL) {
1552     // subsume_node will break sparseness at times, whenever a memory slice
1553     // folds down to a copy of the base (&quot;fat&quot;) memory.  In such a case,
1554     // the raw edge will update to base, although it should be top.
1555     // This iterator will recognize either top or base_memory as an
1556     // &quot;empty&quot; slice.  See is_empty, is_empty2, and next below.
1557     //
1558     // The sparseness property is repaired in MergeMemNode::Ideal.
1559     // As long as access to a MergeMem goes through this iterator
1560     // or the memory_at accessor, flaws in the sparseness will
1561     // never be observed.
1562     //
1563     // Also, iteration_setup repairs sparseness.
1564     assert(mm-&gt;verify_sparse(), &quot;please, no dups of base&quot;);
1565     assert(mm2==NULL || mm2-&gt;verify_sparse(), &quot;please, no dups of base&quot;);
1566 
1567     _mm  = mm;
1568     _mm_base = mm-&gt;base_memory();
1569     _mm2 = mm2;
1570     _cnt = mm-&gt;req();
1571     _idx = Compile::AliasIdxBot-1; // start at the base memory
1572     _mem = NULL;
1573     _mem2 = NULL;
1574   }
1575 
1576 #ifdef ASSERT
1577   Node* check_memory() const {
1578     if (at_base_memory())
1579       return _mm-&gt;base_memory();
1580     else if ((uint)_idx &lt; _mm-&gt;req() &amp;&amp; !_mm-&gt;in(_idx)-&gt;is_top())
1581       return _mm-&gt;memory_at(_idx);
1582     else
1583       return _mm_base;
1584   }
1585   Node* check_memory2() const {
1586     return at_base_memory()? _mm2-&gt;base_memory(): _mm2-&gt;memory_at(_idx);
1587   }
1588 #endif
1589 
1590   static bool match_memory(Node* mem, const MergeMemNode* mm, int idx) PRODUCT_RETURN0;
1591   void assert_synch() const {
1592     assert(!_mem || _idx &gt;= _cnt || match_memory(_mem, _mm, _idx),
1593            &quot;no side-effects except through the stream&quot;);
1594   }
1595 
1596  public:
1597 
1598   // expected usages:
1599   // for (MergeMemStream mms(mem-&gt;is_MergeMem()); next_non_empty(); ) { ... }
1600   // for (MergeMemStream mms(mem1, mem2); next_non_empty2(); ) { ... }
1601 
1602   // iterate over one merge
1603   MergeMemStream(MergeMemNode* mm) {
1604     mm-&gt;iteration_setup();
1605     init(mm);
1606     debug_only(_cnt2 = 999);
1607   }
1608   // iterate in parallel over two merges
1609   // only iterates through non-empty elements of mm2
1610   MergeMemStream(MergeMemNode* mm, const MergeMemNode* mm2) {
1611     assert(mm2, &quot;second argument must be a MergeMem also&quot;);
1612     ((MergeMemNode*)mm2)-&gt;iteration_setup();  // update hidden state
1613     mm-&gt;iteration_setup(mm2);
1614     init(mm, mm2);
1615     _cnt2 = mm2-&gt;req();
1616   }
1617 #ifdef ASSERT
1618   ~MergeMemStream() {
1619     assert_synch();
1620   }
1621 #endif
1622 
1623   MergeMemNode* all_memory() const {
1624     return _mm;
1625   }
1626   Node* base_memory() const {
1627     assert(_mm_base == _mm-&gt;base_memory(), &quot;no update to base memory, please&quot;);
1628     return _mm_base;
1629   }
1630   const MergeMemNode* all_memory2() const {
1631     assert(_mm2 != NULL, &quot;&quot;);
1632     return _mm2;
1633   }
1634   bool at_base_memory() const {
1635     return _idx == Compile::AliasIdxBot;
1636   }
1637   int alias_idx() const {
1638     assert(_mem, &quot;must call next 1st&quot;);
1639     return _idx;
1640   }
1641 
1642   const TypePtr* adr_type() const {
1643     return Compile::current()-&gt;get_adr_type(alias_idx());
1644   }
1645 
1646   const TypePtr* adr_type(Compile* C) const {
1647     return C-&gt;get_adr_type(alias_idx());
1648   }
1649   bool is_empty() const {
1650     assert(_mem, &quot;must call next 1st&quot;);
1651     assert(_mem-&gt;is_top() == (_mem==_mm-&gt;empty_memory()), &quot;correct sentinel&quot;);
1652     return _mem-&gt;is_top();
1653   }
1654   bool is_empty2() const {
1655     assert(_mem2, &quot;must call next 1st&quot;);
1656     assert(_mem2-&gt;is_top() == (_mem2==_mm2-&gt;empty_memory()), &quot;correct sentinel&quot;);
1657     return _mem2-&gt;is_top();
1658   }
1659   Node* memory() const {
1660     assert(!is_empty(), &quot;must not be empty&quot;);
1661     assert_synch();
1662     return _mem;
1663   }
1664   // get the current memory, regardless of empty or non-empty status
1665   Node* force_memory() const {
1666     assert(!is_empty() || !at_base_memory(), &quot;&quot;);
1667     // Use _mm_base to defend against updates to _mem-&gt;base_memory().
1668     Node *mem = _mem-&gt;is_top() ? _mm_base : _mem;
1669     assert(mem == check_memory(), &quot;&quot;);
1670     return mem;
1671   }
1672   Node* memory2() const {
1673     assert(_mem2 == check_memory2(), &quot;&quot;);
1674     return _mem2;
1675   }
1676   void set_memory(Node* mem) {
1677     if (at_base_memory()) {
1678       // Note that this does not change the invariant _mm_base.
1679       _mm-&gt;set_base_memory(mem);
1680     } else {
1681       _mm-&gt;set_memory_at(_idx, mem);
1682     }
1683     _mem = mem;
1684     assert_synch();
1685   }
1686 
1687   // Recover from a side effect to the MergeMemNode.
1688   void set_memory() {
1689     _mem = _mm-&gt;in(_idx);
1690   }
1691 
1692   bool next()  { return next(false); }
1693   bool next2() { return next(true); }
1694 
1695   bool next_non_empty()  { return next_non_empty(false); }
1696   bool next_non_empty2() { return next_non_empty(true); }
1697   // next_non_empty2 can yield states where is_empty() is true
1698 
1699  private:
1700   // find the next item, which might be empty
1701   bool next(bool have_mm2) {
1702     assert((_mm2 != NULL) == have_mm2, &quot;use other next&quot;);
1703     assert_synch();
1704     if (++_idx &lt; _cnt) {
1705       // Note:  This iterator allows _mm to be non-sparse.
1706       // It behaves the same whether _mem is top or base_memory.
1707       _mem = _mm-&gt;in(_idx);
1708       if (have_mm2)
1709         _mem2 = _mm2-&gt;in((_idx &lt; _cnt2) ? _idx : Compile::AliasIdxTop);
1710       return true;
1711     }
1712     return false;
1713   }
1714 
1715   // find the next non-empty item
1716   bool next_non_empty(bool have_mm2) {
1717     while (next(have_mm2)) {
1718       if (!is_empty()) {
1719         // make sure _mem2 is filled in sensibly
1720         if (have_mm2 &amp;&amp; _mem2-&gt;is_top())  _mem2 = _mm2-&gt;base_memory();
1721         return true;
1722       } else if (have_mm2 &amp;&amp; !is_empty2()) {
1723         return true;   // is_empty() == true
1724       }
1725     }
1726     return false;
1727   }
1728 };
1729 
1730 // cachewb node for guaranteeing writeback of the cache line at a
1731 // given address to (non-volatile) RAM
1732 class CacheWBNode : public Node {
1733 public:
1734   CacheWBNode(Node *ctrl, Node *mem, Node *addr) : Node(ctrl, mem, addr) {}
1735   virtual int Opcode() const;
1736   virtual uint ideal_reg() const { return NotAMachineReg; }
1737   virtual uint match_edge(uint idx) const { return (idx == 2); }
1738   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }
1739   virtual const Type *bottom_type() const { return Type::MEMORY; }
1740 };
1741 
1742 // cachewb pre sync node for ensuring that writebacks are serialised
1743 // relative to preceding or following stores
1744 class CacheWBPreSyncNode : public Node {
1745 public:
1746   CacheWBPreSyncNode(Node *ctrl, Node *mem) : Node(ctrl, mem) {}
1747   virtual int Opcode() const;
1748   virtual uint ideal_reg() const { return NotAMachineReg; }
1749   virtual uint match_edge(uint idx) const { return false; }
1750   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }
1751   virtual const Type *bottom_type() const { return Type::MEMORY; }
1752 };
1753 
1754 // cachewb pre sync node for ensuring that writebacks are serialised
1755 // relative to preceding or following stores
1756 class CacheWBPostSyncNode : public Node {
1757 public:
1758   CacheWBPostSyncNode(Node *ctrl, Node *mem) : Node(ctrl, mem) {}
1759   virtual int Opcode() const;
1760   virtual uint ideal_reg() const { return NotAMachineReg; }
1761   virtual uint match_edge(uint idx) const { return false; }
1762   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }
1763   virtual const Type *bottom_type() const { return Type::MEMORY; }
1764 };
1765 
1766 //------------------------------Prefetch---------------------------------------
1767 
1768 // Allocation prefetch which may fault, TLAB size have to be adjusted.
1769 class PrefetchAllocationNode : public Node {
1770 public:
1771   PrefetchAllocationNode(Node *mem, Node *adr) : Node(0,mem,adr) {}
1772   virtual int Opcode() const;
1773   virtual uint ideal_reg() const { return NotAMachineReg; }
1774   virtual uint match_edge(uint idx) const { return idx==2; }
1775   virtual const Type *bottom_type() const { return ( AllocatePrefetchStyle == 3 ) ? Type::MEMORY : Type::ABIO; }
1776 };
1777 
1778 #endif // SHARE_OPTO_MEMNODE_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
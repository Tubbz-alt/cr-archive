<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="subnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/type.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2375   // This logic looks at the element type of an array, and returns true
2376   // if the element type is either a primitive or a final instance class.
2377   // In such cases, an array built on this ary must have no subclasses.
2378   if (_elem == BOTTOM)      return false;  // general array not exact
2379   if (_elem == TOP   )      return false;  // inverted general array not exact
2380   const TypeOopPtr*  toop = NULL;
2381   if (UseCompressedOops &amp;&amp; _elem-&gt;isa_narrowoop()) {
2382     toop = _elem-&gt;make_ptr()-&gt;isa_oopptr();
2383   } else {
2384     toop = _elem-&gt;isa_oopptr();
2385   }
2386   if (!toop)                return true;   // a primitive type, like int
2387   ciKlass* tklass = toop-&gt;klass();
2388   if (tklass == NULL)       return false;  // unloaded class
2389   if (!tklass-&gt;is_loaded()) return false;  // unloaded class
2390   const TypeInstPtr* tinst;
2391   if (_elem-&gt;isa_narrowoop())
2392     tinst = _elem-&gt;make_ptr()-&gt;isa_instptr();
2393   else
2394     tinst = _elem-&gt;isa_instptr();
<span class="line-modified">2395   if (tinst) {</span>
<span class="line-modified">2396     // [V? has a subtype: [V. So even though V is final, [V? is not exact.</span>
<span class="line-removed">2397     if (tklass-&gt;as_instance_klass()-&gt;is_final()) {</span>
<span class="line-removed">2398       if (tinst-&gt;is_valuetypeptr() &amp;&amp; (tinst-&gt;ptr() == TypePtr::BotPTR || tinst-&gt;ptr() == TypePtr::TopPTR)) {</span>
<span class="line-removed">2399         return false;</span>
<span class="line-removed">2400       }</span>
<span class="line-removed">2401       return true;</span>
<span class="line-removed">2402     }</span>
<span class="line-removed">2403     return false;</span>
<span class="line-removed">2404   }</span>
2405   const TypeAryPtr*  tap;
2406   if (_elem-&gt;isa_narrowoop())
2407     tap = _elem-&gt;make_ptr()-&gt;isa_aryptr();
2408   else
2409     tap = _elem-&gt;isa_aryptr();
2410   if (tap)
2411     return tap-&gt;ary()-&gt;ary_must_be_exact();
2412   return false;
2413 }
2414 
2415 //==============================TypeValueType=======================================
2416 
2417 const TypeValueType *TypeValueType::BOTTOM;
2418 
2419 //------------------------------make-------------------------------------------
2420 const TypeValueType* TypeValueType::make(ciValueKlass* vk, bool larval) {
2421   return (TypeValueType*)(new TypeValueType(vk, larval))-&gt;hashcons();
2422 }
2423 
2424 //------------------------------meet-------------------------------------------
</pre>
<hr />
<pre>
3466         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3467         if (sub != NULL) {
3468           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3469           klass = ik = sub;
3470           klass_is_exact = sub-&gt;is_final();
3471         }
3472       }
3473       if (!klass_is_exact &amp;&amp; try_for_exact
3474           &amp;&amp; deps != NULL &amp;&amp; UseExactTypes) {
3475         if (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3476           // Add a dependence; if concrete subclass added we need to recompile
3477           deps-&gt;assert_leaf_type(ik);
3478           klass_is_exact = true;
3479         }
3480       }
3481     }
3482     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0), klass-&gt;flatten_array());
3483   } else if (klass-&gt;is_obj_array_klass()) {
3484     // Element is an object or value array. Recursively call ourself.
3485     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ false, try_for_exact);
<span class="line-modified">3486     bool null_free = klass-&gt;is_loaded() &amp;&amp; klass-&gt;as_array_klass()-&gt;storage_properties().is_null_free();</span>
<span class="line-removed">3487     if (null_free) {</span>
<span class="line-removed">3488       assert(etype-&gt;is_valuetypeptr(), &quot;must be a valuetypeptr&quot;);</span>
3489       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3490     }
<span class="line-modified">3491     // [V? has a subtype: [V. So even though V is final, [V? is not exact.</span>
<span class="line-modified">3492     bool xk = etype-&gt;klass_is_exact() &amp;&amp; (!etype-&gt;is_valuetypeptr() || null_free);</span>
<span class="line-modified">3493 </span>
<span class="line-modified">3494     // Use exact element type to determine null-free/flattened properties</span>
<span class="line-modified">3495     const TypeOopPtr* exact_etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ true, try_for_exact);</span>

3496     bool not_null_free = !exact_etype-&gt;can_be_value_type();
<span class="line-removed">3497     assert(!(not_null_free &amp;&amp; null_free), &quot;inconsistent null-free information&quot;);</span>
3498     bool not_flat = !ValueArrayFlatten || not_null_free || (exact_etype-&gt;is_valuetypeptr() &amp;&amp; !exact_etype-&gt;value_klass()-&gt;flatten_array());
3499 

3500     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);
3501     // We used to pass NotNull in here, asserting that the sub-arrays
3502     // are all not-null.  This is not true in generally, as code can
3503     // slam NULLs down in the subarrays.
3504     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, Offset(0));
3505     return arr;
3506   } else if (klass-&gt;is_type_array_klass()) {
3507     // Element is an typeArray
3508     const Type* etype = get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3509     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS,
3510                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);
3511     // We used to pass NotNull in here, asserting that the array pointer
3512     // is not-null. That was not true in general.
3513     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
3514     return arr;
3515   } else if (klass-&gt;is_value_array_klass()) {
3516     ciValueKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_value_klass();
3517     const TypeAry* arr0 = TypeAry::make(TypeValueType::make(vk), TypeInt::POS);
3518     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
3519     return arr;
</pre>
<hr />
<pre>
3524 }
3525 
3526 //------------------------------make_from_constant-----------------------------
3527 // Make a java pointer from an oop constant
3528 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3529   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3530 
3531   const bool make_constant = require_constant || o-&gt;should_be_constant();
3532 
3533   ciKlass* klass = o-&gt;klass();
3534   if (klass-&gt;is_instance_klass() || klass-&gt;is_valuetype()) {
3535     // Element is an instance or value type
3536     if (make_constant) {
3537       return TypeInstPtr::make(o);
3538     } else {
3539       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0), klass-&gt;flatten_array());
3540     }
3541   } else if (klass-&gt;is_obj_array_klass()) {
3542     // Element is an object array. Recursively call ourself.
3543     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass-&gt;as_array_klass()-&gt;element_klass());
<span class="line-modified">3544     bool null_free = klass-&gt;is_loaded() &amp;&amp; klass-&gt;as_array_klass()-&gt;storage_properties().is_null_free();</span>
<span class="line-modified">3545     if (null_free) {</span>
<span class="line-modified">3546       assert(etype-&gt;is_valuetypeptr(), &quot;must be a valuetypeptr&quot;);</span>
3547       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3548     }
3549     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
3550                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ !null_free);
3551     // We used to pass NotNull in here, asserting that the sub-arrays
3552     // are all not-null.  This is not true in generally, as code can
3553     // slam NULLs down in the subarrays.
3554     if (make_constant) {
3555       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3556     } else {
3557       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3558     }
3559   } else if (klass-&gt;is_type_array_klass()) {
3560     // Element is an typeArray
3561     const Type* etype = (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3562     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
3563                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);
3564     // We used to pass NotNull in here, asserting that the array pointer
3565     // is not-null. That was not true in general.
3566     if (make_constant) {
</pre>
<hr />
<pre>
3964   default:                      // All else is a mistake
3965     typerr(t);
3966 
3967   case MetadataPtr:
3968   case KlassPtr:
3969   case RawPtr: return TypePtr::BOTTOM;
3970 
3971   case AryPtr: {                // All arrays inherit from Object class
3972     const TypeAryPtr *tp = t-&gt;is_aryptr();
3973     Offset offset = meet_offset(tp-&gt;offset());
3974     PTR ptr = meet_ptr(tp-&gt;ptr());
3975     int instance_id = meet_instance_id(tp-&gt;instance_id());
3976     const TypePtr* speculative = xmeet_speculative(tp);
3977     int depth = meet_inline_depth(tp-&gt;inline_depth());
3978     switch (ptr) {
3979     case TopPTR:
3980     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
3981       // For instances when a subclass meets a superclass we fall
3982       // below the centerline when the superclass is exact. We need to
3983       // do the same here.
<span class="line-modified">3984       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {</span>
3985         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
3986       } else {
3987         // cannot subclass, so the meet has to fall badly below the centerline
3988         ptr = NotNull;
3989         instance_id = InstanceBot;
3990         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
3991       }
3992     case Constant:
3993     case NotNull:
3994     case BotPTR:                // Fall down to object klass
3995       // LCA is object_klass, but if we subclass from the top we can do better
3996       if( above_centerline(_ptr) ) { // if( _ptr == TopPTR || _ptr == AnyNull )
3997         // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
3998         // then we can subclass in the Java class hierarchy.
3999         // For instances when a subclass meets a superclass we fall
4000         // below the centerline when the superclass is exact. We need
4001         // to do the same here.
<span class="line-modified">4002         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {</span>
4003           // that is, tp&#39;s array type is a subtype of my klass
4004           return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
4005                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
4006         }
4007       }
4008       // The other case cannot happen, since I cannot be a subtype of an array.
4009       // The meet falls down to Object class below centerline.
4010       if( ptr == Constant )
4011          ptr = NotNull;
4012       instance_id = InstanceBot;
4013       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4014     default: typerr(t);
4015     }
4016   }
4017 
4018   case OopPtr: {                // Meeting to OopPtrs
4019     // Found a OopPtr type vs self-InstPtr type
4020     const TypeOopPtr *tp = t-&gt;is_oopptr();
4021     Offset offset = meet_offset(tp-&gt;offset());
4022     PTR ptr = meet_ptr(tp-&gt;ptr());
</pre>
<hr />
<pre>
4277       }
4278     } else {
4279       PTR ptr = this-&gt;_ptr;
4280       if (ptr == Constant) {
4281         ptr = NotNull;
4282       }
4283       if (tv-&gt;value_klass()-&gt;is_subtype_of(_klass)) {
4284         return TypeInstPtr::make(ptr, _klass);
4285       } else {
4286         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());
4287       }
4288     }
4289   }
4290 
4291   } // End of switch
4292   return this;                  // Return the double constant
4293 }
4294 
4295 
4296 //------------------------java_mirror_type--------------------------------------
<span class="line-modified">4297 ciType* TypeInstPtr::java_mirror_type(bool* is_indirect_type) const {</span>
4298   // must be a singleton type
4299   if( const_oop() == NULL )  return NULL;
4300 
4301   // must be of type java.lang.Class
4302   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;
<span class="line-modified">4303 </span>
<span class="line-removed">4304   return const_oop()-&gt;as_instance()-&gt;java_mirror_type(is_indirect_type);</span>
4305 }
4306 
4307 
4308 //------------------------------xdual------------------------------------------
4309 // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
4310 // inheritance mechanism.
4311 const Type *TypeInstPtr::xdual() const {
4312   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), flat_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());
4313 }
4314 
4315 //------------------------------eq---------------------------------------------
4316 // Structural equality check for Type representations
4317 bool TypeInstPtr::eq( const Type *t ) const {
4318   const TypeInstPtr *p = t-&gt;is_instptr();
4319   return
4320     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
4321     flat_array() == p-&gt;flat_array() &amp;&amp;
4322     TypeOopPtr::eq(p);          // Check sub-type stuff
4323 }
4324 
</pre>
<hr />
<pre>
4705         // This must fall to bottom, not (int[-128..65535])[int+].
4706         instance_id = InstanceBot;
4707         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4708       }
4709     } else // Non integral arrays.
4710       // Must fall to bottom if exact klasses in upper lattice
4711       // are not equal or super klass is exact.
4712       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4713           // meet with top[] and bottom[] are processed further down:
4714           tap-&gt;_klass != NULL &amp;&amp; this-&gt;_klass != NULL &amp;&amp;
4715           // both are exact and not equal:
4716           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4717            // &#39;tap&#39; is exact and super or unrelated:
4718            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4719            // &#39;this&#39; is exact and super or unrelated:
4720            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4721       if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
4722         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4723       }
4724       return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);
<span class="line-modified">4725     } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp;</span>
<span class="line-modified">4726                klass()-&gt;as_array_klass()-&gt;storage_properties().value() != tap-&gt;klass()-&gt;as_array_klass()-&gt;storage_properties().value()) {</span>
<span class="line-removed">4727       // Meeting value type arrays with conflicting storage properties</span>
4728       if (tary-&gt;_elem-&gt;isa_valuetype()) {
4729         // Result is flattened
4730         off = Offset(elem()-&gt;isa_valuetype() ? offset() : tap-&gt;offset());
4731         field_off = elem()-&gt;isa_valuetype() ? field_offset() : tap-&gt;field_offset();
4732       } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {
4733         // Result is non-flattened
4734         off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));
4735         field_off = Offset::bottom;
4736       }
4737     }
4738 
4739     bool xk = false;
4740     switch (tap-&gt;ptr()) {
4741     case AnyNull:
4742     case TopPTR:
4743       // Compute new klass on demand, do not use tap-&gt;_klass
4744       if (below_centerline(this-&gt;_ptr)) {
4745         xk = this-&gt;_klass_is_exact;
4746       } else {
4747         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
</pre>
<hr />
<pre>
4776               (klass() == tap-&gt;klass()); // Only precise for identical arrays
4777       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4778     default: ShouldNotReachHere();
4779     }
4780   }
4781 
4782   // All arrays inherit from Object class
4783   case InstPtr: {
4784     const TypeInstPtr *tp = t-&gt;is_instptr();
4785     Offset offset = meet_offset(tp-&gt;offset());
4786     PTR ptr = meet_ptr(tp-&gt;ptr());
4787     int instance_id = meet_instance_id(tp-&gt;instance_id());
4788     const TypePtr* speculative = xmeet_speculative(tp);
4789     int depth = meet_inline_depth(tp-&gt;inline_depth());
4790     switch (ptr) {
4791     case TopPTR:
4792     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
4793       // For instances when a subclass meets a superclass we fall
4794       // below the centerline when the superclass is exact. We need to
4795       // do the same here.
<span class="line-modified">4796       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {</span>
4797         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4798       } else {
4799         // cannot subclass, so the meet has to fall badly below the centerline
4800         ptr = NotNull;
4801         instance_id = InstanceBot;
4802         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4803       }
4804     case Constant:
4805     case NotNull:
4806     case BotPTR:                // Fall down to object klass
4807       // LCA is object_klass, but if we subclass from the top we can do better
4808       if (above_centerline(tp-&gt;ptr())) {
4809         // If &#39;tp&#39;  is above the centerline and it is Object class
4810         // then we can subclass in the Java class hierarchy.
4811         // For instances when a subclass meets a superclass we fall
4812         // below the centerline when the superclass is exact. We need
4813         // to do the same here.
<span class="line-modified">4814         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {</span>
4815           // that is, my array type is a subtype of &#39;tp&#39; klass
4816           return make(ptr, (ptr == Constant ? const_oop() : NULL),
4817                       _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4818         }
4819       }
4820       // The other case cannot happen, since t cannot be a subtype of an array.
4821       // The meet falls down to Object class below centerline.
4822       if( ptr == Constant )
4823          ptr = NotNull;
4824       instance_id = InstanceBot;
4825       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4826     default: typerr(t);
4827     }
4828   }
4829 
4830   case ValueType: {
4831     const TypeValueType* tv = t-&gt;is_valuetype();
4832     if (above_centerline(ptr())) {
4833       return TypeInstPtr::NOTNULL;
4834     } else {
</pre>
<hr />
<pre>
5422     return ktkp-&gt;cast_to_ptr_type(ftkp-&gt;ptr());
5423   }
5424 
5425   return ft;
5426 }
5427 
5428 //----------------------compute_klass------------------------------------------
5429 // Compute the defining klass for this class
5430 ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {
5431   // Compute _klass based on element type.
5432   ciKlass* k_ary = NULL;
5433   const TypeAryPtr *tary;
5434   const Type* el = elem();
5435   if (el-&gt;isa_narrowoop()) {
5436     el = el-&gt;make_ptr();
5437   }
5438 
5439   // Get element klass
5440   if (el-&gt;isa_instptr()) {
5441     // Compute object array klass from element klass
<span class="line-modified">5442     bool null_free = el-&gt;is_valuetypeptr() &amp;&amp; el-&gt;isa_instptr()-&gt;ptr() != TypePtr::TopPTR &amp;&amp; !el-&gt;isa_instptr()-&gt;maybe_null();</span>
<span class="line-removed">5443     k_ary = ciArrayKlass::make(el-&gt;is_oopptr()-&gt;klass(), null_free);</span>
5444   } else if (el-&gt;isa_valuetype()) {

5445     if (el-&gt;value_klass() != NULL) {
<span class="line-modified">5446       k_ary = ciArrayKlass::make(el-&gt;value_klass(), /* null_free */ true);</span>
5447     }
5448   } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
5449     // Compute array klass from element klass
5450     ciKlass* k_elem = tary-&gt;klass();
5451     // If element type is something like bottom[], k_elem will be null.
5452     if (k_elem != NULL)
5453       k_ary = ciObjArrayKlass::make(k_elem);
5454   } else if ((el-&gt;base() == Type::Top) ||
5455              (el-&gt;base() == Type::Bottom)) {
5456     // element type of Bottom occurs from meet of basic type
5457     // and object; Top occurs when doing join on Bottom.
5458     // Leave k_ary at NULL.
5459   } else {
5460     // Cannot compute array klass directly from basic type,
5461     // since subtypes of TypeInt all have basic type T_INT.
5462 #ifdef ASSERT
5463     if (verify &amp;&amp; el-&gt;isa_int()) {
5464       // Check simple cases when verifying klass.
5465       BasicType bt = T_ILLEGAL;
5466       if (el == TypeInt::BYTE) {
</pre>
</td>
<td>
<hr />
<pre>
2375   // This logic looks at the element type of an array, and returns true
2376   // if the element type is either a primitive or a final instance class.
2377   // In such cases, an array built on this ary must have no subclasses.
2378   if (_elem == BOTTOM)      return false;  // general array not exact
2379   if (_elem == TOP   )      return false;  // inverted general array not exact
2380   const TypeOopPtr*  toop = NULL;
2381   if (UseCompressedOops &amp;&amp; _elem-&gt;isa_narrowoop()) {
2382     toop = _elem-&gt;make_ptr()-&gt;isa_oopptr();
2383   } else {
2384     toop = _elem-&gt;isa_oopptr();
2385   }
2386   if (!toop)                return true;   // a primitive type, like int
2387   ciKlass* tklass = toop-&gt;klass();
2388   if (tklass == NULL)       return false;  // unloaded class
2389   if (!tklass-&gt;is_loaded()) return false;  // unloaded class
2390   const TypeInstPtr* tinst;
2391   if (_elem-&gt;isa_narrowoop())
2392     tinst = _elem-&gt;make_ptr()-&gt;isa_instptr();
2393   else
2394     tinst = _elem-&gt;isa_instptr();
<span class="line-modified">2395   if (tinst)</span>
<span class="line-modified">2396     return tklass-&gt;as_instance_klass()-&gt;is_final();</span>








2397   const TypeAryPtr*  tap;
2398   if (_elem-&gt;isa_narrowoop())
2399     tap = _elem-&gt;make_ptr()-&gt;isa_aryptr();
2400   else
2401     tap = _elem-&gt;isa_aryptr();
2402   if (tap)
2403     return tap-&gt;ary()-&gt;ary_must_be_exact();
2404   return false;
2405 }
2406 
2407 //==============================TypeValueType=======================================
2408 
2409 const TypeValueType *TypeValueType::BOTTOM;
2410 
2411 //------------------------------make-------------------------------------------
2412 const TypeValueType* TypeValueType::make(ciValueKlass* vk, bool larval) {
2413   return (TypeValueType*)(new TypeValueType(vk, larval))-&gt;hashcons();
2414 }
2415 
2416 //------------------------------meet-------------------------------------------
</pre>
<hr />
<pre>
3458         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3459         if (sub != NULL) {
3460           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3461           klass = ik = sub;
3462           klass_is_exact = sub-&gt;is_final();
3463         }
3464       }
3465       if (!klass_is_exact &amp;&amp; try_for_exact
3466           &amp;&amp; deps != NULL &amp;&amp; UseExactTypes) {
3467         if (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3468           // Add a dependence; if concrete subclass added we need to recompile
3469           deps-&gt;assert_leaf_type(ik);
3470           klass_is_exact = true;
3471         }
3472       }
3473     }
3474     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0), klass-&gt;flatten_array());
3475   } else if (klass-&gt;is_obj_array_klass()) {
3476     // Element is an object or value array. Recursively call ourself.
3477     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ false, try_for_exact);
<span class="line-modified">3478     if (etype-&gt;is_valuetypeptr()) {</span>


3479       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3480     }
<span class="line-modified">3481     // Determine null-free/flattened properties</span>
<span class="line-modified">3482     const TypeOopPtr* exact_etype = etype;</span>
<span class="line-modified">3483     if (etype-&gt;can_be_value_type()) {</span>
<span class="line-modified">3484       // Use exact type if element can be a value type</span>
<span class="line-modified">3485       exact_etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ true, /* try_for_exact= */ true);</span>
<span class="line-added">3486     }</span>
3487     bool not_null_free = !exact_etype-&gt;can_be_value_type();

3488     bool not_flat = !ValueArrayFlatten || not_null_free || (exact_etype-&gt;is_valuetypeptr() &amp;&amp; !exact_etype-&gt;value_klass()-&gt;flatten_array());
3489 
<span class="line-added">3490     bool xk = etype-&gt;klass_is_exact();</span>
3491     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);
3492     // We used to pass NotNull in here, asserting that the sub-arrays
3493     // are all not-null.  This is not true in generally, as code can
3494     // slam NULLs down in the subarrays.
3495     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, Offset(0));
3496     return arr;
3497   } else if (klass-&gt;is_type_array_klass()) {
3498     // Element is an typeArray
3499     const Type* etype = get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3500     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS,
3501                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);
3502     // We used to pass NotNull in here, asserting that the array pointer
3503     // is not-null. That was not true in general.
3504     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
3505     return arr;
3506   } else if (klass-&gt;is_value_array_klass()) {
3507     ciValueKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_value_klass();
3508     const TypeAry* arr0 = TypeAry::make(TypeValueType::make(vk), TypeInt::POS);
3509     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
3510     return arr;
</pre>
<hr />
<pre>
3515 }
3516 
3517 //------------------------------make_from_constant-----------------------------
3518 // Make a java pointer from an oop constant
3519 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3520   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3521 
3522   const bool make_constant = require_constant || o-&gt;should_be_constant();
3523 
3524   ciKlass* klass = o-&gt;klass();
3525   if (klass-&gt;is_instance_klass() || klass-&gt;is_valuetype()) {
3526     // Element is an instance or value type
3527     if (make_constant) {
3528       return TypeInstPtr::make(o);
3529     } else {
3530       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0), klass-&gt;flatten_array());
3531     }
3532   } else if (klass-&gt;is_obj_array_klass()) {
3533     // Element is an object array. Recursively call ourself.
3534     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass-&gt;as_array_klass()-&gt;element_klass());
<span class="line-modified">3535     bool null_free = false;</span>
<span class="line-modified">3536     if (etype-&gt;is_valuetypeptr()) {</span>
<span class="line-modified">3537       null_free = true;</span>
3538       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3539     }
3540     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
3541                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ !null_free);
3542     // We used to pass NotNull in here, asserting that the sub-arrays
3543     // are all not-null.  This is not true in generally, as code can
3544     // slam NULLs down in the subarrays.
3545     if (make_constant) {
3546       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3547     } else {
3548       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3549     }
3550   } else if (klass-&gt;is_type_array_klass()) {
3551     // Element is an typeArray
3552     const Type* etype = (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3553     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
3554                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);
3555     // We used to pass NotNull in here, asserting that the array pointer
3556     // is not-null. That was not true in general.
3557     if (make_constant) {
</pre>
<hr />
<pre>
3955   default:                      // All else is a mistake
3956     typerr(t);
3957 
3958   case MetadataPtr:
3959   case KlassPtr:
3960   case RawPtr: return TypePtr::BOTTOM;
3961 
3962   case AryPtr: {                // All arrays inherit from Object class
3963     const TypeAryPtr *tp = t-&gt;is_aryptr();
3964     Offset offset = meet_offset(tp-&gt;offset());
3965     PTR ptr = meet_ptr(tp-&gt;ptr());
3966     int instance_id = meet_instance_id(tp-&gt;instance_id());
3967     const TypePtr* speculative = xmeet_speculative(tp);
3968     int depth = meet_inline_depth(tp-&gt;inline_depth());
3969     switch (ptr) {
3970     case TopPTR:
3971     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
3972       // For instances when a subclass meets a superclass we fall
3973       // below the centerline when the superclass is exact. We need to
3974       // do the same here.
<span class="line-modified">3975       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flat_array()) {</span>
3976         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
3977       } else {
3978         // cannot subclass, so the meet has to fall badly below the centerline
3979         ptr = NotNull;
3980         instance_id = InstanceBot;
3981         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
3982       }
3983     case Constant:
3984     case NotNull:
3985     case BotPTR:                // Fall down to object klass
3986       // LCA is object_klass, but if we subclass from the top we can do better
3987       if( above_centerline(_ptr) ) { // if( _ptr == TopPTR || _ptr == AnyNull )
3988         // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
3989         // then we can subclass in the Java class hierarchy.
3990         // For instances when a subclass meets a superclass we fall
3991         // below the centerline when the superclass is exact. We need
3992         // to do the same here.
<span class="line-modified">3993         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flat_array()) {</span>
3994           // that is, tp&#39;s array type is a subtype of my klass
3995           return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
3996                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
3997         }
3998       }
3999       // The other case cannot happen, since I cannot be a subtype of an array.
4000       // The meet falls down to Object class below centerline.
4001       if( ptr == Constant )
4002          ptr = NotNull;
4003       instance_id = InstanceBot;
4004       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4005     default: typerr(t);
4006     }
4007   }
4008 
4009   case OopPtr: {                // Meeting to OopPtrs
4010     // Found a OopPtr type vs self-InstPtr type
4011     const TypeOopPtr *tp = t-&gt;is_oopptr();
4012     Offset offset = meet_offset(tp-&gt;offset());
4013     PTR ptr = meet_ptr(tp-&gt;ptr());
</pre>
<hr />
<pre>
4268       }
4269     } else {
4270       PTR ptr = this-&gt;_ptr;
4271       if (ptr == Constant) {
4272         ptr = NotNull;
4273       }
4274       if (tv-&gt;value_klass()-&gt;is_subtype_of(_klass)) {
4275         return TypeInstPtr::make(ptr, _klass);
4276       } else {
4277         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());
4278       }
4279     }
4280   }
4281 
4282   } // End of switch
4283   return this;                  // Return the double constant
4284 }
4285 
4286 
4287 //------------------------java_mirror_type--------------------------------------
<span class="line-modified">4288 ciType* TypeInstPtr::java_mirror_type() const {</span>
4289   // must be a singleton type
4290   if( const_oop() == NULL )  return NULL;
4291 
4292   // must be of type java.lang.Class
4293   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;
<span class="line-modified">4294   return const_oop()-&gt;as_instance()-&gt;java_mirror_type();</span>

4295 }
4296 
4297 
4298 //------------------------------xdual------------------------------------------
4299 // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
4300 // inheritance mechanism.
4301 const Type *TypeInstPtr::xdual() const {
4302   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), flat_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());
4303 }
4304 
4305 //------------------------------eq---------------------------------------------
4306 // Structural equality check for Type representations
4307 bool TypeInstPtr::eq( const Type *t ) const {
4308   const TypeInstPtr *p = t-&gt;is_instptr();
4309   return
4310     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
4311     flat_array() == p-&gt;flat_array() &amp;&amp;
4312     TypeOopPtr::eq(p);          // Check sub-type stuff
4313 }
4314 
</pre>
<hr />
<pre>
4695         // This must fall to bottom, not (int[-128..65535])[int+].
4696         instance_id = InstanceBot;
4697         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4698       }
4699     } else // Non integral arrays.
4700       // Must fall to bottom if exact klasses in upper lattice
4701       // are not equal or super klass is exact.
4702       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4703           // meet with top[] and bottom[] are processed further down:
4704           tap-&gt;_klass != NULL &amp;&amp; this-&gt;_klass != NULL &amp;&amp;
4705           // both are exact and not equal:
4706           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4707            // &#39;tap&#39; is exact and super or unrelated:
4708            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4709            // &#39;this&#39; is exact and super or unrelated:
4710            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4711       if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
4712         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4713       }
4714       return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);
<span class="line-modified">4715     } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp; klass()-&gt;is_value_array_klass() != tap-&gt;klass()-&gt;is_value_array_klass()) {</span>
<span class="line-modified">4716       // Meeting flattened value type array with non-flattened array. Adjust (field) offset accordingly.</span>

4717       if (tary-&gt;_elem-&gt;isa_valuetype()) {
4718         // Result is flattened
4719         off = Offset(elem()-&gt;isa_valuetype() ? offset() : tap-&gt;offset());
4720         field_off = elem()-&gt;isa_valuetype() ? field_offset() : tap-&gt;field_offset();
4721       } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {
4722         // Result is non-flattened
4723         off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));
4724         field_off = Offset::bottom;
4725       }
4726     }
4727 
4728     bool xk = false;
4729     switch (tap-&gt;ptr()) {
4730     case AnyNull:
4731     case TopPTR:
4732       // Compute new klass on demand, do not use tap-&gt;_klass
4733       if (below_centerline(this-&gt;_ptr)) {
4734         xk = this-&gt;_klass_is_exact;
4735       } else {
4736         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
</pre>
<hr />
<pre>
4765               (klass() == tap-&gt;klass()); // Only precise for identical arrays
4766       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4767     default: ShouldNotReachHere();
4768     }
4769   }
4770 
4771   // All arrays inherit from Object class
4772   case InstPtr: {
4773     const TypeInstPtr *tp = t-&gt;is_instptr();
4774     Offset offset = meet_offset(tp-&gt;offset());
4775     PTR ptr = meet_ptr(tp-&gt;ptr());
4776     int instance_id = meet_instance_id(tp-&gt;instance_id());
4777     const TypePtr* speculative = xmeet_speculative(tp);
4778     int depth = meet_inline_depth(tp-&gt;inline_depth());
4779     switch (ptr) {
4780     case TopPTR:
4781     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
4782       // For instances when a subclass meets a superclass we fall
4783       // below the centerline when the superclass is exact. We need to
4784       // do the same here.
<span class="line-modified">4785       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flat_array()) {</span>
4786         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4787       } else {
4788         // cannot subclass, so the meet has to fall badly below the centerline
4789         ptr = NotNull;
4790         instance_id = InstanceBot;
4791         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4792       }
4793     case Constant:
4794     case NotNull:
4795     case BotPTR:                // Fall down to object klass
4796       // LCA is object_klass, but if we subclass from the top we can do better
4797       if (above_centerline(tp-&gt;ptr())) {
4798         // If &#39;tp&#39;  is above the centerline and it is Object class
4799         // then we can subclass in the Java class hierarchy.
4800         // For instances when a subclass meets a superclass we fall
4801         // below the centerline when the superclass is exact. We need
4802         // to do the same here.
<span class="line-modified">4803         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flat_array()) {</span>
4804           // that is, my array type is a subtype of &#39;tp&#39; klass
4805           return make(ptr, (ptr == Constant ? const_oop() : NULL),
4806                       _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4807         }
4808       }
4809       // The other case cannot happen, since t cannot be a subtype of an array.
4810       // The meet falls down to Object class below centerline.
4811       if( ptr == Constant )
4812          ptr = NotNull;
4813       instance_id = InstanceBot;
4814       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4815     default: typerr(t);
4816     }
4817   }
4818 
4819   case ValueType: {
4820     const TypeValueType* tv = t-&gt;is_valuetype();
4821     if (above_centerline(ptr())) {
4822       return TypeInstPtr::NOTNULL;
4823     } else {
</pre>
<hr />
<pre>
5411     return ktkp-&gt;cast_to_ptr_type(ftkp-&gt;ptr());
5412   }
5413 
5414   return ft;
5415 }
5416 
5417 //----------------------compute_klass------------------------------------------
5418 // Compute the defining klass for this class
5419 ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {
5420   // Compute _klass based on element type.
5421   ciKlass* k_ary = NULL;
5422   const TypeAryPtr *tary;
5423   const Type* el = elem();
5424   if (el-&gt;isa_narrowoop()) {
5425     el = el-&gt;make_ptr();
5426   }
5427 
5428   // Get element klass
5429   if (el-&gt;isa_instptr()) {
5430     // Compute object array klass from element klass
<span class="line-modified">5431     k_ary = ciArrayKlass::make(el-&gt;is_oopptr()-&gt;klass());</span>

5432   } else if (el-&gt;isa_valuetype()) {
<span class="line-added">5433     // If element type is TypeValueType::BOTTOM, value_klass() will be null.</span>
5434     if (el-&gt;value_klass() != NULL) {
<span class="line-modified">5435       k_ary = ciArrayKlass::make(el-&gt;value_klass());</span>
5436     }
5437   } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
5438     // Compute array klass from element klass
5439     ciKlass* k_elem = tary-&gt;klass();
5440     // If element type is something like bottom[], k_elem will be null.
5441     if (k_elem != NULL)
5442       k_ary = ciObjArrayKlass::make(k_elem);
5443   } else if ((el-&gt;base() == Type::Top) ||
5444              (el-&gt;base() == Type::Bottom)) {
5445     // element type of Bottom occurs from meet of basic type
5446     // and object; Top occurs when doing join on Bottom.
5447     // Leave k_ary at NULL.
5448   } else {
5449     // Cannot compute array klass directly from basic type,
5450     // since subtypes of TypeInt all have basic type T_INT.
5451 #ifdef ASSERT
5452     if (verify &amp;&amp; el-&gt;isa_int()) {
5453       // Check simple cases when verifying klass.
5454       BasicType bt = T_ILLEGAL;
5455       if (el == TypeInt::BYTE) {
</pre>
</td>
</tr>
</table>
<center><a href="subnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/type.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="type.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/lang/Class.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/type.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1133   // Convenience common pre-built type.
1134   static const TypeOopPtr *BOTTOM;
1135 #ifndef PRODUCT
1136   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1137 #endif
1138 };
1139 
1140 //------------------------------TypeInstPtr------------------------------------
1141 // Class of Java object pointers, pointing either to non-array Java instances
1142 // or to a Klass* (including array klasses).
1143 class TypeInstPtr : public TypeOopPtr {
1144   TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
1145               bool is_value, int instance_id, const TypePtr* speculative,
1146               int inline_depth);
1147   virtual bool eq( const Type *t ) const;
1148   virtual int  hash() const;             // Type specific hashing
1149 
1150   ciSymbol*  _name;        // class name
1151   bool _flat_array;
1152 
<span class="line-removed">1153   bool meet_flat_array(bool other_flat_array) const {</span>
<span class="line-removed">1154     return (_flat_array &amp;&amp; other_flat_array) ? true : false;</span>
<span class="line-removed">1155   }</span>
<span class="line-removed">1156 </span>
1157  public:
1158   ciSymbol* name()         const { return _name; }
1159 
1160   bool  is_loaded() const { return _klass-&gt;is_loaded(); }
1161 
1162   // Make a pointer to a constant oop.
1163   static const TypeInstPtr *make(ciObject* o) {
1164     return make(TypePtr::Constant, o-&gt;klass(), true, o, Offset(0), o-&gt;klass()-&gt;is_valuetype() &amp;&amp; o-&gt;klass()-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);
1165   }
1166   // Make a pointer to a constant oop with offset.
1167   static const TypeInstPtr* make(ciObject* o, Offset offset) {
1168     return make(TypePtr::Constant, o-&gt;klass(), true, o, offset, o-&gt;klass()-&gt;is_valuetype() &amp;&amp; o-&gt;klass()-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);
1169   }
1170 
1171   // Make a pointer to some value of type klass.
1172   static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {
1173     return make(ptr, klass, false, NULL, Offset(0), klass-&gt;is_valuetype() &amp;&amp; klass-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);
1174   }
1175 
1176   // Make a pointer to some non-polymorphic value of exactly type klass.
</pre>
<hr />
<pre>
1179   }
1180 
1181   // Make a pointer to some value of type klass with offset.
1182   static const TypeInstPtr *make(PTR ptr, ciKlass* klass, Offset offset) {
1183     return make(ptr, klass, false, NULL, offset, klass-&gt;is_valuetype() &amp;&amp; klass-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);
1184   }
1185 
1186   // Make a pointer to an oop.
1187   static const TypeInstPtr* make(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
1188                                  bool flat_array,
1189                                  int instance_id = InstanceBot,
1190                                  const TypePtr* speculative = NULL,
1191                                  int inline_depth = InlineDepthBottom);
1192 
1193   /** Create constant type for a constant boxed value */
1194   const Type* get_const_boxed_value() const;
1195 
1196   // If this is a java.lang.Class constant, return the type for it or NULL.
1197   // Pass to Type::get_const_type to turn it to a type, which will usually
1198   // be a TypeInstPtr, but may also be a TypeInt::INT for int.class, etc.
<span class="line-modified">1199   ciType* java_mirror_type(bool* is_indirect_type = NULL) const;</span>
1200 
1201   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1202 
1203   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1204 
1205   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1206 
1207   virtual const TypePtr *add_offset( intptr_t offset ) const;
1208 
1209   // Speculative type helper methods.
1210   virtual const Type* remove_speculative() const;
1211   virtual const TypePtr* with_inline_depth(int depth) const;
1212   virtual const TypePtr* with_instance_id(int instance_id) const;
1213 
1214   virtual const TypeInstPtr* cast_to_flat_array() const;
1215   virtual bool flat_array() const {
1216     assert(!klass()-&gt;is_valuetype() || !klass()-&gt;as_value_klass()-&gt;flatten_array() || _flat_array, &quot;incorrect value bit&quot;);
1217     assert(!_flat_array || can_be_value_type(), &quot;incorrect value bit&quot;);
1218     return _flat_array;
1219   }
</pre>
</td>
<td>
<hr />
<pre>
1133   // Convenience common pre-built type.
1134   static const TypeOopPtr *BOTTOM;
1135 #ifndef PRODUCT
1136   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1137 #endif
1138 };
1139 
1140 //------------------------------TypeInstPtr------------------------------------
1141 // Class of Java object pointers, pointing either to non-array Java instances
1142 // or to a Klass* (including array klasses).
1143 class TypeInstPtr : public TypeOopPtr {
1144   TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
1145               bool is_value, int instance_id, const TypePtr* speculative,
1146               int inline_depth);
1147   virtual bool eq( const Type *t ) const;
1148   virtual int  hash() const;             // Type specific hashing
1149 
1150   ciSymbol*  _name;        // class name
1151   bool _flat_array;
1152 




1153  public:
1154   ciSymbol* name()         const { return _name; }
1155 
1156   bool  is_loaded() const { return _klass-&gt;is_loaded(); }
1157 
1158   // Make a pointer to a constant oop.
1159   static const TypeInstPtr *make(ciObject* o) {
1160     return make(TypePtr::Constant, o-&gt;klass(), true, o, Offset(0), o-&gt;klass()-&gt;is_valuetype() &amp;&amp; o-&gt;klass()-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);
1161   }
1162   // Make a pointer to a constant oop with offset.
1163   static const TypeInstPtr* make(ciObject* o, Offset offset) {
1164     return make(TypePtr::Constant, o-&gt;klass(), true, o, offset, o-&gt;klass()-&gt;is_valuetype() &amp;&amp; o-&gt;klass()-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);
1165   }
1166 
1167   // Make a pointer to some value of type klass.
1168   static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {
1169     return make(ptr, klass, false, NULL, Offset(0), klass-&gt;is_valuetype() &amp;&amp; klass-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);
1170   }
1171 
1172   // Make a pointer to some non-polymorphic value of exactly type klass.
</pre>
<hr />
<pre>
1175   }
1176 
1177   // Make a pointer to some value of type klass with offset.
1178   static const TypeInstPtr *make(PTR ptr, ciKlass* klass, Offset offset) {
1179     return make(ptr, klass, false, NULL, offset, klass-&gt;is_valuetype() &amp;&amp; klass-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);
1180   }
1181 
1182   // Make a pointer to an oop.
1183   static const TypeInstPtr* make(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
1184                                  bool flat_array,
1185                                  int instance_id = InstanceBot,
1186                                  const TypePtr* speculative = NULL,
1187                                  int inline_depth = InlineDepthBottom);
1188 
1189   /** Create constant type for a constant boxed value */
1190   const Type* get_const_boxed_value() const;
1191 
1192   // If this is a java.lang.Class constant, return the type for it or NULL.
1193   // Pass to Type::get_const_type to turn it to a type, which will usually
1194   // be a TypeInstPtr, but may also be a TypeInt::INT for int.class, etc.
<span class="line-modified">1195   ciType* java_mirror_type() const;</span>
1196 
1197   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1198 
1199   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1200 
1201   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1202 
1203   virtual const TypePtr *add_offset( intptr_t offset ) const;
1204 
1205   // Speculative type helper methods.
1206   virtual const Type* remove_speculative() const;
1207   virtual const TypePtr* with_inline_depth(int depth) const;
1208   virtual const TypePtr* with_instance_id(int instance_id) const;
1209 
1210   virtual const TypeInstPtr* cast_to_flat_array() const;
1211   virtual bool flat_array() const {
1212     assert(!klass()-&gt;is_valuetype() || !klass()-&gt;as_value_klass()-&gt;flatten_array() || _flat_array, &quot;incorrect value bit&quot;);
1213     assert(!_flat_array || can_be_value_type(), &quot;incorrect value bit&quot;);
1214     return _flat_array;
1215   }
</pre>
</td>
</tr>
</table>
<center><a href="type.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/lang/Class.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
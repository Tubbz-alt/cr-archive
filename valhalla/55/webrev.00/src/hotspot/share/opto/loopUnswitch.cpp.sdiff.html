<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/loopUnswitch.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="library_call.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopnode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopUnswitch.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 65     return false;
 66   }
 67 
 68   // If nodes are depleted, some transform has miscalculated its needs.
 69   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);
 70 
 71   // check for vectorized loops, any unswitching was already applied
 72   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;is_unroll_only()) {
 73     return false;
 74   }
 75 
 76   LoopNode* head = _head-&gt;as_Loop();
 77   if (head-&gt;unswitch_count() + 1 &gt; head-&gt;unswitch_max()) {
 78     return false;
 79   }
 80 
 81   if (head-&gt;is_flattened_arrays()) {
 82     return false;
 83   }
 84 
<span class="line-modified"> 85   Node_List flattened_checks;</span>
<span class="line-modified"> 86   if (phase-&gt;find_unswitching_candidate(this, flattened_checks) == NULL &amp;&amp; flattened_checks.size() == 0) {</span>
 87     return false;
 88   }
 89 
 90   // Too speculative if running low on nodes.
 91   return phase-&gt;may_require_nodes(est_loop_clone_sz(2));
 92 }
 93 
 94 //------------------------------find_unswitching_candidate-----------------------------
 95 // Find candidate &quot;if&quot; for unswitching
<span class="line-modified"> 96 IfNode* PhaseIdealLoop::find_unswitching_candidate(const IdealLoopTree *loop, Node_List&amp; flattened_checks) const {</span>
 97 
 98   // Find first invariant test that doesn&#39;t exit the loop
 99   LoopNode *head = loop-&gt;_head-&gt;as_Loop();
100   IfNode* unswitch_iff = NULL;
101   Node* n = head-&gt;in(LoopNode::LoopBackControl);
102   while (n != head) {
103     Node* n_dom = idom(n);
104     if (n-&gt;is_Region()) {
105       if (n_dom-&gt;is_If()) {
106         IfNode* iff = n_dom-&gt;as_If();
107         if (iff-&gt;in(1)-&gt;is_Bool()) {
108           BoolNode* bol = iff-&gt;in(1)-&gt;as_Bool();
109           if (bol-&gt;in(1)-&gt;is_Cmp()) {
110             // If condition is invariant and not a loop exit,
111             // then found reason to unswitch.
112             if (loop-&gt;is_invariant(bol) &amp;&amp; !loop-&gt;is_loop_exit(iff)) {
113               unswitch_iff = iff;
114             }
115           }
116         }
117       }
118     }
119     n = n_dom;
120   }



121 
<span class="line-modified">122   Node* array;</span>
<span class="line-modified">123   if (unswitch_iff == NULL || unswitch_iff-&gt;is_flattened_array_check(&amp;_igvn, array)) {</span>
<span class="line-modified">124     // collect all flattened array checks</span>
125     for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
<span class="line-modified">126       Node* n = loop-&gt;_body.at(i);</span>
<span class="line-modified">127       if (n-&gt;is_If() &amp;&amp; n-&gt;as_If()-&gt;is_flattened_array_check(&amp;_igvn, array) &amp;&amp;</span>
<span class="line-modified">128           loop-&gt;is_invariant(n-&gt;in(1)) &amp;&amp;</span>
<span class="line-modified">129           !loop-&gt;is_loop_exit(n)) {</span>
<span class="line-modified">130         flattened_checks.push(n);</span>


131       }
132     }
<span class="line-removed">133     if (flattened_checks.size() &gt; 1) {</span>
<span class="line-removed">134       unswitch_iff = NULL;</span>
<span class="line-removed">135     } else {</span>
<span class="line-removed">136       flattened_checks.clear();</span>
<span class="line-removed">137     }</span>
138   }
<span class="line-removed">139 </span>
140   return unswitch_iff;
141 }
142 
143 //------------------------------do_unswitching-----------------------------
144 // Clone loop with an invariant test (that does not exit) and
145 // insert a clone of the test that selects which version to
146 // execute.
147 void PhaseIdealLoop::do_unswitching(IdealLoopTree *loop, Node_List &amp;old_new) {
148 
149   LoopNode *head = loop-&gt;_head-&gt;as_Loop();
150   Node* entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
151   if (find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check) != NULL
152       || (UseProfiledLoopPredicate &amp;&amp; find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate) != NULL)
153       || (UseLoopPredicate &amp;&amp; find_predicate_insertion_point(entry, Deoptimization::Reason_predicate) != NULL)) {
154     assert(entry-&gt;is_IfProj(), &quot;sanity - must be ifProj since there is at least one predicate&quot;);
155     if (entry-&gt;outcnt() &gt; 1) {
156       // Bailout if there are loop predicates from which there are additional control dependencies (i.e. from
157       // loop entry &#39;entry&#39;) to previously partially peeled statements since this case is not handled and can lead
158       // to wrong execution. Remove this bailout, once this is fixed.
159       return;
160     }
161   }
162   // Find first invariant test that doesn&#39;t exit the loop
<span class="line-modified">163   Node_List flattened_checks;</span>
<span class="line-modified">164   IfNode* unswitch_iff = find_unswitching_candidate((const IdealLoopTree *)loop, flattened_checks);</span>
<span class="line-modified">165   assert(unswitch_iff != NULL || flattened_checks.size() &gt; 0, &quot;should be at least one&quot;);</span>
<span class="line-removed">166   if (unswitch_iff == NULL) {</span>
<span class="line-removed">167     unswitch_iff = flattened_checks.at(0)-&gt;as_If();</span>
<span class="line-removed">168   }</span>
169 
170 #ifndef PRODUCT
171   if (TraceLoopOpts) {
172     tty-&gt;print(&quot;Unswitch   %d &quot;, head-&gt;unswitch_count()+1);
173     loop-&gt;dump_head();




174   }
175 #endif
176 
177   // Need to revert back to normal loop
178   if (head-&gt;is_CountedLoop() &amp;&amp; !head-&gt;as_CountedLoop()-&gt;is_normal_loop()) {
179     head-&gt;as_CountedLoop()-&gt;set_normal_loop();
180   }
181 
182   ProjNode* proj_true = create_slow_version_of_loop(loop, old_new, unswitch_iff-&gt;Opcode(), CloneIncludesStripMined);
183 
184 #ifdef ASSERT
185   assert(proj_true-&gt;is_IfTrue(), &quot;must be true projection&quot;);
186   entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
187   Node* predicate = find_predicate(entry);
188   if (predicate == NULL) {
189     // No empty predicate
190     Node* uniqc = proj_true-&gt;unique_ctrl_out();
191     assert((uniqc == head &amp;&amp; !head-&gt;is_strip_mined()) || (uniqc == head-&gt;in(LoopNode::EntryControl)
192            &amp;&amp; head-&gt;is_strip_mined()), &quot;must hold by construction if no predicates&quot;);
193   } else {
</pre>
<hr />
<pre>
197     if (UseProfiledLoopPredicate) {
198       predicate = find_predicate(proj_before_first_empty_predicate);
199       if (predicate != NULL) {
200         proj_before_first_empty_predicate = skip_loop_predicates(predicate);
201       }
202     }
203     if (UseLoopPredicate) {
204       predicate = find_predicate(proj_before_first_empty_predicate);
205       if (predicate != NULL) {
206         proj_before_first_empty_predicate = skip_loop_predicates(predicate);
207       }
208     }
209     assert(proj_true == proj_before_first_empty_predicate, &quot;must hold by construction if at least one predicate&quot;);
210   }
211 #endif
212   // Increment unswitch count
213   LoopNode* head_clone = old_new[head-&gt;_idx]-&gt;as_Loop();
214   int nct = head-&gt;unswitch_count() + 1;
215   head-&gt;set_unswitch_count(nct);
216   head_clone-&gt;set_unswitch_count(nct);
<span class="line-removed">217   if (flattened_checks.size() &gt; 0) {</span>
<span class="line-removed">218     head-&gt;mark_flattened_arrays();</span>
<span class="line-removed">219   }</span>
220 
221   // Add test to new &quot;if&quot; outside of loop
222   IfNode* invar_iff   = proj_true-&gt;in(0)-&gt;as_If();
223   Node* invar_iff_c   = invar_iff-&gt;in(0);
224   invar_iff-&gt;_prob    = unswitch_iff-&gt;_prob;
<span class="line-modified">225   if (flattened_checks.size() &gt; 0) {</span>
<span class="line-modified">226     // Flattened array checks are used in</span>
<span class="line-modified">227     // Parse::array_store()/Parse::array_load() to switch between a</span>
<span class="line-modified">228     // legacy object array access and a flattened value array</span>
229     // access. We want the performance impact on legacy accesses to be
<span class="line-modified">230     // as small as possible so we make 2 copies of the loops: a fast</span>
231     // one where all accesses are known to be legacy, a slow one where
232     // some accesses are to flattened arrays. Flattened array checks
<span class="line-modified">233     // can be removed from the first one but not from the second one</span>
234     // as it can have a mix of flattened/legacy accesses.
<span class="line-modified">235     BoolNode* bol       = unswitch_iff-&gt;in(1)-&gt;clone()-&gt;as_Bool();</span>
236     register_new_node(bol, invar_iff-&gt;in(0));
237     Node* cmp = bol-&gt;in(1)-&gt;clone();
238     register_new_node(cmp, invar_iff-&gt;in(0));
239     bol-&gt;set_req(1, cmp);

240     Node* in1 = NULL;
<span class="line-modified">241     for (uint i = 0; i &lt; flattened_checks.size(); i++) {</span>
<span class="line-modified">242       Node* v = flattened_checks.at(i)-&gt;in(1)-&gt;in(1)-&gt;in(1);</span>


243       if (in1 == NULL) {
<span class="line-modified">244         in1 = v;</span>
245       } else {
<span class="line-modified">246         if (cmp-&gt;Opcode() == Op_CmpL) {</span>
<span class="line-removed">247           in1 = new OrLNode(in1, v);</span>
<span class="line-removed">248         } else {</span>
<span class="line-removed">249           in1 = new OrINode(in1, v);</span>
<span class="line-removed">250         }</span>
251         register_new_node(in1, invar_iff-&gt;in(0));
252       }
253     }
254     cmp-&gt;set_req(1, in1);
<span class="line-removed">255     invar_iff-&gt;set_req(1, bol);</span>
<span class="line-removed">256   } else {</span>
<span class="line-removed">257     BoolNode* bol       = unswitch_iff-&gt;in(1)-&gt;as_Bool();</span>
<span class="line-removed">258     invar_iff-&gt;set_req(1, bol);</span>
259   }

260 
<span class="line-modified">261   ProjNode* proj_false = invar_iff-&gt;proj_out(0)-&gt;as_Proj();</span>
<span class="line-removed">262 </span>
<span class="line-removed">263   // Hoist invariant casts out of each loop to the appropriate</span>
<span class="line-removed">264   // control projection.</span>
<span class="line-removed">265 </span>
266   Node_List worklist;
<span class="line-modified">267 </span>
<span class="line-modified">268   if (flattened_checks.size() &gt; 0) {</span>
<span class="line-modified">269     for (uint i = 0; i &lt; flattened_checks.size(); i++) {</span>
<span class="line-modified">270       IfNode* iff = flattened_checks.at(i)-&gt;as_If();</span>
<span class="line-removed">271       ProjNode* proj= iff-&gt;proj_out(0)-&gt;as_Proj();</span>
272       // Copy to a worklist for easier manipulation
273       for (DUIterator_Fast jmax, j = proj-&gt;fast_outs(jmax); j &lt; jmax; j++) {
274         Node* use = proj-&gt;fast_out(j);
275         if (use-&gt;Opcode() == Op_CheckCastPP &amp;&amp; loop-&gt;is_invariant(use-&gt;in(1))) {
276           worklist.push(use);
277         }
278       }
279       ProjNode* invar_proj = invar_iff-&gt;proj_out(proj-&gt;_con)-&gt;as_Proj();
280       while (worklist.size() &gt; 0) {
281         Node* use = worklist.pop();
282         Node* nuse = use-&gt;clone();
283         nuse-&gt;set_req(0, invar_proj);
284         _igvn.replace_input_of(use, 1, nuse);
285         register_new_node(nuse, invar_proj);
<span class="line-modified">286         // Same for the clone</span>
<span class="line-modified">287         Node* use_clone = old_new[use-&gt;_idx];</span>
<span class="line-modified">288         _igvn.replace_input_of(use_clone, 1, nuse);</span>
<span class="line-modified">289       }</span>
<span class="line-removed">290     }</span>
<span class="line-removed">291   } else {</span>
<span class="line-removed">292     for (DUIterator_Fast imax, i = unswitch_iff-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">293       ProjNode* proj= unswitch_iff-&gt;fast_out(i)-&gt;as_Proj();</span>
<span class="line-removed">294       // Copy to a worklist for easier manipulation</span>
<span class="line-removed">295       for (DUIterator_Fast jmax, j = proj-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-removed">296         Node* use = proj-&gt;fast_out(j);</span>
<span class="line-removed">297         if (use-&gt;Opcode() == Op_CheckCastPP &amp;&amp; loop-&gt;is_invariant(use-&gt;in(1))) {</span>
<span class="line-removed">298           worklist.push(use);</span>
299         }
300       }
<span class="line-removed">301       ProjNode* invar_proj = invar_iff-&gt;proj_out(proj-&gt;_con)-&gt;as_Proj();</span>
<span class="line-removed">302       while (worklist.size() &gt; 0) {</span>
<span class="line-removed">303         Node* use = worklist.pop();</span>
<span class="line-removed">304         Node* nuse = use-&gt;clone();</span>
<span class="line-removed">305         nuse-&gt;set_req(0, invar_proj);</span>
<span class="line-removed">306         _igvn.replace_input_of(use, 1, nuse);</span>
<span class="line-removed">307         register_new_node(nuse, invar_proj);</span>
<span class="line-removed">308         // Same for the clone</span>
<span class="line-removed">309         Node* use_clone = old_new[use-&gt;_idx];</span>
<span class="line-removed">310         _igvn.replace_input_of(use_clone, 1, nuse);</span>
<span class="line-removed">311       }</span>
312     }
313   }
314 






315   IfNode* unswitch_iff_clone = old_new[unswitch_iff-&gt;_idx]-&gt;as_If();
<span class="line-modified">316   if (flattened_checks.size() &gt; 0) {</span>
<span class="line-modified">317     for (uint i = 0; i &lt; flattened_checks.size(); i++) {</span>
<span class="line-removed">318       IfNode* iff = flattened_checks.at(i)-&gt;as_If();</span>
<span class="line-removed">319       _igvn.rehash_node_delayed(iff);</span>
<span class="line-removed">320       dominated_by(proj_false, old_new[iff-&gt;_idx]-&gt;as_If(), false, false);</span>
<span class="line-removed">321     }</span>
<span class="line-removed">322   } else {</span>
<span class="line-removed">323     // Hardwire the control paths in the loops into if(true) and if(false)</span>
<span class="line-removed">324     _igvn.rehash_node_delayed(unswitch_iff);</span>
<span class="line-removed">325     dominated_by(proj_true, unswitch_iff, false, false);</span>
<span class="line-removed">326 </span>
<span class="line-removed">327     IfNode* unswitch_iff_clone = old_new[unswitch_iff-&gt;_idx]-&gt;as_If();</span>
328     _igvn.rehash_node_delayed(unswitch_iff_clone);
329     dominated_by(proj_false, unswitch_iff_clone, false, false);




330   }
331 
332   // Reoptimize loops
333   loop-&gt;record_for_igvn();
334   for(int i = loop-&gt;_body.size() - 1; i &gt;= 0 ; i--) {
335     Node *n = loop-&gt;_body[i];
336     Node *n_clone = old_new[n-&gt;_idx];
337     _igvn._worklist.push(n_clone);
338   }
339 
340 #ifndef PRODUCT
341   if (TraceLoopUnswitching) {
<span class="line-modified">342     tty-&gt;print_cr(&quot;Loop unswitching orig: %d @ %d  new: %d @ %d&quot;,</span>
<span class="line-modified">343                   head-&gt;_idx,                unswitch_iff-&gt;_idx,</span>
<span class="line-modified">344                   old_new[head-&gt;_idx]-&gt;_idx, unswitch_iff_clone-&gt;_idx);</span>


345   }
346 #endif
347 
348   C-&gt;set_major_progress();
349 }
350 
351 //-------------------------create_slow_version_of_loop------------------------
352 // Create a slow version of the loop by cloning the loop
353 // and inserting an if to select fast-slow versions.
354 // Return control projection of the entry to the fast version.
355 ProjNode* PhaseIdealLoop::create_slow_version_of_loop(IdealLoopTree *loop,
356                                                       Node_List &amp;old_new,
357                                                       int opcode,
358                                                       CloneLoopMode mode) {
359   LoopNode* head  = loop-&gt;_head-&gt;as_Loop();
360   bool counted_loop = head-&gt;is_CountedLoop();
361   Node*     entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
362   _igvn.rehash_node_delayed(entry);
363   IdealLoopTree* outer_loop = loop-&gt;_parent;
364 
</pre>
</td>
<td>
<hr />
<pre>
 65     return false;
 66   }
 67 
 68   // If nodes are depleted, some transform has miscalculated its needs.
 69   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);
 70 
 71   // check for vectorized loops, any unswitching was already applied
 72   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;is_unroll_only()) {
 73     return false;
 74   }
 75 
 76   LoopNode* head = _head-&gt;as_Loop();
 77   if (head-&gt;unswitch_count() + 1 &gt; head-&gt;unswitch_max()) {
 78     return false;
 79   }
 80 
 81   if (head-&gt;is_flattened_arrays()) {
 82     return false;
 83   }
 84 
<span class="line-modified"> 85   Node_List unswitch_iffs;</span>
<span class="line-modified"> 86   if (phase-&gt;find_unswitching_candidate(this, unswitch_iffs) == NULL) {</span>
 87     return false;
 88   }
 89 
 90   // Too speculative if running low on nodes.
 91   return phase-&gt;may_require_nodes(est_loop_clone_sz(2));
 92 }
 93 
 94 //------------------------------find_unswitching_candidate-----------------------------
 95 // Find candidate &quot;if&quot; for unswitching
<span class="line-modified"> 96 IfNode* PhaseIdealLoop::find_unswitching_candidate(const IdealLoopTree *loop, Node_List&amp; unswitch_iffs) const {</span>
 97 
 98   // Find first invariant test that doesn&#39;t exit the loop
 99   LoopNode *head = loop-&gt;_head-&gt;as_Loop();
100   IfNode* unswitch_iff = NULL;
101   Node* n = head-&gt;in(LoopNode::LoopBackControl);
102   while (n != head) {
103     Node* n_dom = idom(n);
104     if (n-&gt;is_Region()) {
105       if (n_dom-&gt;is_If()) {
106         IfNode* iff = n_dom-&gt;as_If();
107         if (iff-&gt;in(1)-&gt;is_Bool()) {
108           BoolNode* bol = iff-&gt;in(1)-&gt;as_Bool();
109           if (bol-&gt;in(1)-&gt;is_Cmp()) {
110             // If condition is invariant and not a loop exit,
111             // then found reason to unswitch.
112             if (loop-&gt;is_invariant(bol) &amp;&amp; !loop-&gt;is_loop_exit(iff)) {
113               unswitch_iff = iff;
114             }
115           }
116         }
117       }
118     }
119     n = n_dom;
120   }
<span class="line-added">121   if (unswitch_iff != NULL) {</span>
<span class="line-added">122     unswitch_iffs.push(unswitch_iff);</span>
<span class="line-added">123   }</span>
124 
<span class="line-modified">125   // Collect all non-flattened array checks for unswitching to create a fast loop</span>
<span class="line-modified">126   // without checks (only non-flattened array accesses) and a slow loop with checks.</span>
<span class="line-modified">127   if (unswitch_iff == NULL || unswitch_iff-&gt;is_non_flattened_array_check(&amp;_igvn)) {</span>
128     for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
<span class="line-modified">129       IfNode* n = loop-&gt;_body.at(i)-&gt;isa_If();</span>
<span class="line-modified">130       if (n != NULL &amp;&amp; n != unswitch_iff &amp;&amp; n-&gt;is_non_flattened_array_check(&amp;_igvn) &amp;&amp;</span>
<span class="line-modified">131           loop-&gt;is_invariant(n-&gt;in(1)) &amp;&amp; !loop-&gt;is_loop_exit(n)) {</span>
<span class="line-modified">132         unswitch_iffs.push(n);</span>
<span class="line-modified">133         if (unswitch_iff == NULL) {</span>
<span class="line-added">134           unswitch_iff = n;</span>
<span class="line-added">135         }</span>
136       }
137     }





138   }

139   return unswitch_iff;
140 }
141 
142 //------------------------------do_unswitching-----------------------------
143 // Clone loop with an invariant test (that does not exit) and
144 // insert a clone of the test that selects which version to
145 // execute.
146 void PhaseIdealLoop::do_unswitching(IdealLoopTree *loop, Node_List &amp;old_new) {
147 
148   LoopNode *head = loop-&gt;_head-&gt;as_Loop();
149   Node* entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
150   if (find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check) != NULL
151       || (UseProfiledLoopPredicate &amp;&amp; find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate) != NULL)
152       || (UseLoopPredicate &amp;&amp; find_predicate_insertion_point(entry, Deoptimization::Reason_predicate) != NULL)) {
153     assert(entry-&gt;is_IfProj(), &quot;sanity - must be ifProj since there is at least one predicate&quot;);
154     if (entry-&gt;outcnt() &gt; 1) {
155       // Bailout if there are loop predicates from which there are additional control dependencies (i.e. from
156       // loop entry &#39;entry&#39;) to previously partially peeled statements since this case is not handled and can lead
157       // to wrong execution. Remove this bailout, once this is fixed.
158       return;
159     }
160   }
161   // Find first invariant test that doesn&#39;t exit the loop
<span class="line-modified">162   Node_List unswitch_iffs;</span>
<span class="line-modified">163   IfNode* unswitch_iff = find_unswitching_candidate((const IdealLoopTree *)loop, unswitch_iffs);</span>
<span class="line-modified">164   assert(unswitch_iff != NULL &amp;&amp; unswitch_iffs.size() &gt; 0, &quot;should be at least one&quot;);</span>



165 
166 #ifndef PRODUCT
167   if (TraceLoopOpts) {
168     tty-&gt;print(&quot;Unswitch   %d &quot;, head-&gt;unswitch_count()+1);
169     loop-&gt;dump_head();
<span class="line-added">170     for (uint i = 0; i &lt; unswitch_iffs.size(); i++) {</span>
<span class="line-added">171       unswitch_iffs.at(i)-&gt;dump(3);</span>
<span class="line-added">172       tty-&gt;cr();</span>
<span class="line-added">173     }</span>
174   }
175 #endif
176 
177   // Need to revert back to normal loop
178   if (head-&gt;is_CountedLoop() &amp;&amp; !head-&gt;as_CountedLoop()-&gt;is_normal_loop()) {
179     head-&gt;as_CountedLoop()-&gt;set_normal_loop();
180   }
181 
182   ProjNode* proj_true = create_slow_version_of_loop(loop, old_new, unswitch_iff-&gt;Opcode(), CloneIncludesStripMined);
183 
184 #ifdef ASSERT
185   assert(proj_true-&gt;is_IfTrue(), &quot;must be true projection&quot;);
186   entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
187   Node* predicate = find_predicate(entry);
188   if (predicate == NULL) {
189     // No empty predicate
190     Node* uniqc = proj_true-&gt;unique_ctrl_out();
191     assert((uniqc == head &amp;&amp; !head-&gt;is_strip_mined()) || (uniqc == head-&gt;in(LoopNode::EntryControl)
192            &amp;&amp; head-&gt;is_strip_mined()), &quot;must hold by construction if no predicates&quot;);
193   } else {
</pre>
<hr />
<pre>
197     if (UseProfiledLoopPredicate) {
198       predicate = find_predicate(proj_before_first_empty_predicate);
199       if (predicate != NULL) {
200         proj_before_first_empty_predicate = skip_loop_predicates(predicate);
201       }
202     }
203     if (UseLoopPredicate) {
204       predicate = find_predicate(proj_before_first_empty_predicate);
205       if (predicate != NULL) {
206         proj_before_first_empty_predicate = skip_loop_predicates(predicate);
207       }
208     }
209     assert(proj_true == proj_before_first_empty_predicate, &quot;must hold by construction if at least one predicate&quot;);
210   }
211 #endif
212   // Increment unswitch count
213   LoopNode* head_clone = old_new[head-&gt;_idx]-&gt;as_Loop();
214   int nct = head-&gt;unswitch_count() + 1;
215   head-&gt;set_unswitch_count(nct);
216   head_clone-&gt;set_unswitch_count(nct);



217 
218   // Add test to new &quot;if&quot; outside of loop
219   IfNode* invar_iff   = proj_true-&gt;in(0)-&gt;as_If();
220   Node* invar_iff_c   = invar_iff-&gt;in(0);
221   invar_iff-&gt;_prob    = unswitch_iff-&gt;_prob;
<span class="line-modified">222   BoolNode* bol       = unswitch_iff-&gt;in(1)-&gt;as_Bool();</span>
<span class="line-modified">223   if (unswitch_iffs.size() &gt; 1) {</span>
<span class="line-modified">224     // Flattened array checks are used on array access to switch between</span>
<span class="line-modified">225     // a legacy object array access and a flattened value type array</span>
226     // access. We want the performance impact on legacy accesses to be
<span class="line-modified">227     // as small as possible so we make two copies of the loop: a fast</span>
228     // one where all accesses are known to be legacy, a slow one where
229     // some accesses are to flattened arrays. Flattened array checks
<span class="line-modified">230     // can be removed from the fast loop but not from the slow loop</span>
231     // as it can have a mix of flattened/legacy accesses.
<span class="line-modified">232     bol = bol-&gt;clone()-&gt;as_Bool();</span>
233     register_new_node(bol, invar_iff-&gt;in(0));
234     Node* cmp = bol-&gt;in(1)-&gt;clone();
235     register_new_node(cmp, invar_iff-&gt;in(0));
236     bol-&gt;set_req(1, cmp);
<span class="line-added">237     // Combine all checks into a single one that fails if one array is flattened</span>
238     Node* in1 = NULL;
<span class="line-modified">239     for (uint i = 0; i &lt; unswitch_iffs.size(); i++) {</span>
<span class="line-modified">240       Node* array_tag = unswitch_iffs.at(i)-&gt;in(1)-&gt;in(1)-&gt;in(1);</span>
<span class="line-added">241       array_tag = new AndINode(array_tag, _igvn.intcon(Klass::_lh_array_tag_vt_value));</span>
<span class="line-added">242       register_new_node(array_tag, invar_iff-&gt;in(0));</span>
243       if (in1 == NULL) {
<span class="line-modified">244         in1 = array_tag;</span>
245       } else {
<span class="line-modified">246         in1 = new OrINode(in1, array_tag);</span>




247         register_new_node(in1, invar_iff-&gt;in(0));
248       }
249     }
250     cmp-&gt;set_req(1, in1);




251   }
<span class="line-added">252   invar_iff-&gt;set_req(1, bol);</span>
253 
<span class="line-modified">254   // Hoist invariant casts out of each loop to the appropriate control projection.</span>




255   Node_List worklist;
<span class="line-modified">256   for (uint i = 0; i &lt; unswitch_iffs.size(); i++) {</span>
<span class="line-modified">257     IfNode* iff = unswitch_iffs.at(i)-&gt;as_If();</span>
<span class="line-modified">258     for (DUIterator_Fast imax, i = iff-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-modified">259       ProjNode* proj = iff-&gt;fast_out(i)-&gt;as_Proj();</span>

260       // Copy to a worklist for easier manipulation
261       for (DUIterator_Fast jmax, j = proj-&gt;fast_outs(jmax); j &lt; jmax; j++) {
262         Node* use = proj-&gt;fast_out(j);
263         if (use-&gt;Opcode() == Op_CheckCastPP &amp;&amp; loop-&gt;is_invariant(use-&gt;in(1))) {
264           worklist.push(use);
265         }
266       }
267       ProjNode* invar_proj = invar_iff-&gt;proj_out(proj-&gt;_con)-&gt;as_Proj();
268       while (worklist.size() &gt; 0) {
269         Node* use = worklist.pop();
270         Node* nuse = use-&gt;clone();
271         nuse-&gt;set_req(0, invar_proj);
272         _igvn.replace_input_of(use, 1, nuse);
273         register_new_node(nuse, invar_proj);
<span class="line-modified">274         // Same for the clone if we are removing checks from the slow loop</span>
<span class="line-modified">275         if (unswitch_iffs.size() == 1) {</span>
<span class="line-modified">276           Node* use_clone = old_new[use-&gt;_idx];</span>
<span class="line-modified">277           _igvn.replace_input_of(use_clone, 1, nuse);</span>









278         }
279       }











280     }
281   }
282 
<span class="line-added">283   // Hardwire the control paths in the loops into if(true) and if(false)</span>
<span class="line-added">284   for (uint i = 0; i &lt; unswitch_iffs.size(); i++) {</span>
<span class="line-added">285     IfNode* iff = unswitch_iffs.at(i)-&gt;as_If();</span>
<span class="line-added">286     _igvn.rehash_node_delayed(iff);</span>
<span class="line-added">287     dominated_by(proj_true, iff, false, false);</span>
<span class="line-added">288   }</span>
289   IfNode* unswitch_iff_clone = old_new[unswitch_iff-&gt;_idx]-&gt;as_If();
<span class="line-modified">290   if (unswitch_iffs.size() == 1) {</span>
<span class="line-modified">291     ProjNode* proj_false = invar_iff-&gt;proj_out(0)-&gt;as_Proj();</span>










292     _igvn.rehash_node_delayed(unswitch_iff_clone);
293     dominated_by(proj_false, unswitch_iff_clone, false, false);
<span class="line-added">294   } else {</span>
<span class="line-added">295     // Leave the flattened array checks in the slow loop and</span>
<span class="line-added">296     // prevent it from being unswitched again based on these checks.</span>
<span class="line-added">297     head_clone-&gt;mark_flattened_arrays();</span>
298   }
299 
300   // Reoptimize loops
301   loop-&gt;record_for_igvn();
302   for(int i = loop-&gt;_body.size() - 1; i &gt;= 0 ; i--) {
303     Node *n = loop-&gt;_body[i];
304     Node *n_clone = old_new[n-&gt;_idx];
305     _igvn._worklist.push(n_clone);
306   }
307 
308 #ifndef PRODUCT
309   if (TraceLoopUnswitching) {
<span class="line-modified">310     for (uint i = 0; i &lt; unswitch_iffs.size(); i++) {</span>
<span class="line-modified">311       tty-&gt;print_cr(&quot;Loop unswitching orig: %d @ %d  new: %d @ %d&quot;,</span>
<span class="line-modified">312                     head-&gt;_idx,                unswitch_iffs.at(i)-&gt;_idx,</span>
<span class="line-added">313                     old_new[head-&gt;_idx]-&gt;_idx, old_new[unswitch_iffs.at(i)-&gt;_idx]-&gt;_idx);</span>
<span class="line-added">314     }</span>
315   }
316 #endif
317 
318   C-&gt;set_major_progress();
319 }
320 
321 //-------------------------create_slow_version_of_loop------------------------
322 // Create a slow version of the loop by cloning the loop
323 // and inserting an if to select fast-slow versions.
324 // Return control projection of the entry to the fast version.
325 ProjNode* PhaseIdealLoop::create_slow_version_of_loop(IdealLoopTree *loop,
326                                                       Node_List &amp;old_new,
327                                                       int opcode,
328                                                       CloneLoopMode mode) {
329   LoopNode* head  = loop-&gt;_head-&gt;as_Loop();
330   bool counted_loop = head-&gt;is_CountedLoop();
331   Node*     entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
332   _igvn.rehash_node_delayed(entry);
333   IdealLoopTree* outer_loop = loop-&gt;_parent;
334 
</pre>
</td>
</tr>
</table>
<center><a href="library_call.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopnode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/ci/ciTypeFlow.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciConstant.hpp&quot;
  27 #include &quot;ci/ciField.hpp&quot;
  28 #include &quot;ci/ciMethod.hpp&quot;
  29 #include &quot;ci/ciMethodData.hpp&quot;
  30 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  31 #include &quot;ci/ciStreams.hpp&quot;
  32 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  33 #include &quot;ci/ciTypeFlow.hpp&quot;
  34 #include &quot;ci/ciValueKlass.hpp&quot;
  35 #include &quot;compiler/compileLog.hpp&quot;
  36 #include &quot;interpreter/bytecode.hpp&quot;
  37 #include &quot;interpreter/bytecodes.hpp&quot;
  38 #include &quot;memory/allocation.inline.hpp&quot;
  39 #include &quot;memory/resourceArea.hpp&quot;
  40 #include &quot;oops/oop.inline.hpp&quot;
  41 #include &quot;opto/compile.hpp&quot;
  42 #include &quot;opto/node.hpp&quot;
  43 #include &quot;runtime/deoptimization.hpp&quot;
  44 #include &quot;utilities/growableArray.hpp&quot;
  45 
  46 // ciTypeFlow::JsrSet
  47 //
  48 // A JsrSet represents some set of JsrRecords.  This class
  49 // is used to record a set of all jsr routines which we permit
  50 // execution to return (ret) from.
  51 //
  52 // During abstract interpretation, JsrSets are used to determine
  53 // whether two paths which reach a given block are unique, and
  54 // should be cloned apart, or are compatible, and should merge
  55 // together.
  56 
  57 // ------------------------------------------------------------------
  58 // ciTypeFlow::JsrSet::JsrSet
  59 ciTypeFlow::JsrSet::JsrSet(Arena* arena, int default_len) {
  60   if (arena != NULL) {
  61     // Allocate growable array in Arena.
  62     _set = new (arena) GrowableArray&lt;JsrRecord*&gt;(arena, default_len, 0, NULL);
  63   } else {
  64     // Allocate growable array in current ResourceArea.
  65     _set = new GrowableArray&lt;JsrRecord*&gt;(4, 0, NULL, false);
  66   }
  67 }
  68 
  69 // ------------------------------------------------------------------
  70 // ciTypeFlow::JsrSet::copy_into
  71 void ciTypeFlow::JsrSet::copy_into(JsrSet* jsrs) {
  72   int len = size();
  73   jsrs-&gt;_set-&gt;clear();
  74   for (int i = 0; i &lt; len; i++) {
  75     jsrs-&gt;_set-&gt;append(_set-&gt;at(i));
  76   }
  77 }
  78 
  79 // ------------------------------------------------------------------
  80 // ciTypeFlow::JsrSet::is_compatible_with
  81 //
  82 // !!!! MISGIVINGS ABOUT THIS... disregard
  83 //
  84 // Is this JsrSet compatible with some other JsrSet?
  85 //
  86 // In set-theoretic terms, a JsrSet can be viewed as a partial function
  87 // from entry addresses to return addresses.  Two JsrSets A and B are
  88 // compatible iff
  89 //
  90 //   For any x,
  91 //   A(x) defined and B(x) defined implies A(x) == B(x)
  92 //
  93 // Less formally, two JsrSets are compatible when they have identical
  94 // return addresses for any entry addresses they share in common.
  95 bool ciTypeFlow::JsrSet::is_compatible_with(JsrSet* other) {
  96   // Walk through both sets in parallel.  If the same entry address
  97   // appears in both sets, then the return address must match for
  98   // the sets to be compatible.
  99   int size1 = size();
 100   int size2 = other-&gt;size();
 101 
 102   // Special case.  If nothing is on the jsr stack, then there can
 103   // be no ret.
 104   if (size2 == 0) {
 105     return true;
 106   } else if (size1 != size2) {
 107     return false;
 108   } else {
 109     for (int i = 0; i &lt; size1; i++) {
 110       JsrRecord* record1 = record_at(i);
 111       JsrRecord* record2 = other-&gt;record_at(i);
 112       if (record1-&gt;entry_address() != record2-&gt;entry_address() ||
 113           record1-&gt;return_address() != record2-&gt;return_address()) {
 114         return false;
 115       }
 116     }
 117     return true;
 118   }
 119 
 120 #if 0
 121   int pos1 = 0;
 122   int pos2 = 0;
 123   int size1 = size();
 124   int size2 = other-&gt;size();
 125   while (pos1 &lt; size1 &amp;&amp; pos2 &lt; size2) {
 126     JsrRecord* record1 = record_at(pos1);
 127     JsrRecord* record2 = other-&gt;record_at(pos2);
 128     int entry1 = record1-&gt;entry_address();
 129     int entry2 = record2-&gt;entry_address();
 130     if (entry1 &lt; entry2) {
 131       pos1++;
 132     } else if (entry1 &gt; entry2) {
 133       pos2++;
 134     } else {
 135       if (record1-&gt;return_address() == record2-&gt;return_address()) {
 136         pos1++;
 137         pos2++;
 138       } else {
 139         // These two JsrSets are incompatible.
 140         return false;
 141       }
 142     }
 143   }
 144   // The two JsrSets agree.
 145   return true;
 146 #endif
 147 }
 148 
 149 // ------------------------------------------------------------------
 150 // ciTypeFlow::JsrSet::insert_jsr_record
 151 //
 152 // Insert the given JsrRecord into the JsrSet, maintaining the order
 153 // of the set and replacing any element with the same entry address.
 154 void ciTypeFlow::JsrSet::insert_jsr_record(JsrRecord* record) {
 155   int len = size();
 156   int entry = record-&gt;entry_address();
 157   int pos = 0;
 158   for ( ; pos &lt; len; pos++) {
 159     JsrRecord* current = record_at(pos);
 160     if (entry == current-&gt;entry_address()) {
 161       // Stomp over this entry.
 162       _set-&gt;at_put(pos, record);
 163       assert(size() == len, &quot;must be same size&quot;);
 164       return;
 165     } else if (entry &lt; current-&gt;entry_address()) {
 166       break;
 167     }
 168   }
 169 
 170   // Insert the record into the list.
 171   JsrRecord* swap = record;
 172   JsrRecord* temp = NULL;
 173   for ( ; pos &lt; len; pos++) {
 174     temp = _set-&gt;at(pos);
 175     _set-&gt;at_put(pos, swap);
 176     swap = temp;
 177   }
 178   _set-&gt;append(swap);
 179   assert(size() == len+1, &quot;must be larger&quot;);
 180 }
 181 
 182 // ------------------------------------------------------------------
 183 // ciTypeFlow::JsrSet::remove_jsr_record
 184 //
 185 // Remove the JsrRecord with the given return address from the JsrSet.
 186 void ciTypeFlow::JsrSet::remove_jsr_record(int return_address) {
 187   int len = size();
 188   for (int i = 0; i &lt; len; i++) {
 189     if (record_at(i)-&gt;return_address() == return_address) {
 190       // We have found the proper entry.  Remove it from the
 191       // JsrSet and exit.
 192       for (int j = i+1; j &lt; len ; j++) {
 193         _set-&gt;at_put(j-1, _set-&gt;at(j));
 194       }
 195       _set-&gt;trunc_to(len-1);
 196       assert(size() == len-1, &quot;must be smaller&quot;);
 197       return;
 198     }
 199   }
 200   assert(false, &quot;verify: returning from invalid subroutine&quot;);
 201 }
 202 
 203 // ------------------------------------------------------------------
 204 // ciTypeFlow::JsrSet::apply_control
 205 //
 206 // Apply the effect of a control-flow bytecode on the JsrSet.  The
 207 // only bytecodes that modify the JsrSet are jsr and ret.
 208 void ciTypeFlow::JsrSet::apply_control(ciTypeFlow* analyzer,
 209                                        ciBytecodeStream* str,
 210                                        ciTypeFlow::StateVector* state) {
 211   Bytecodes::Code code = str-&gt;cur_bc();
 212   if (code == Bytecodes::_jsr) {
 213     JsrRecord* record =
 214       analyzer-&gt;make_jsr_record(str-&gt;get_dest(), str-&gt;next_bci());
 215     insert_jsr_record(record);
 216   } else if (code == Bytecodes::_jsr_w) {
 217     JsrRecord* record =
 218       analyzer-&gt;make_jsr_record(str-&gt;get_far_dest(), str-&gt;next_bci());
 219     insert_jsr_record(record);
 220   } else if (code == Bytecodes::_ret) {
 221     Cell local = state-&gt;local(str-&gt;get_index());
 222     ciType* return_address = state-&gt;type_at(local);
 223     assert(return_address-&gt;is_return_address(), &quot;verify: wrong type&quot;);
 224     if (size() == 0) {
 225       // Ret-state underflow:  Hit a ret w/o any previous jsrs.  Bail out.
 226       // This can happen when a loop is inside a finally clause (4614060).
 227       analyzer-&gt;record_failure(&quot;OSR in finally clause&quot;);
 228       return;
 229     }
 230     remove_jsr_record(return_address-&gt;as_return_address()-&gt;bci());
 231   }
 232 }
 233 
 234 #ifndef PRODUCT
 235 // ------------------------------------------------------------------
 236 // ciTypeFlow::JsrSet::print_on
 237 void ciTypeFlow::JsrSet::print_on(outputStream* st) const {
 238   st-&gt;print(&quot;{ &quot;);
 239   int num_elements = size();
 240   if (num_elements &gt; 0) {
 241     int i = 0;
 242     for( ; i &lt; num_elements - 1; i++) {
 243       _set-&gt;at(i)-&gt;print_on(st);
 244       st-&gt;print(&quot;, &quot;);
 245     }
 246     _set-&gt;at(i)-&gt;print_on(st);
 247     st-&gt;print(&quot; &quot;);
 248   }
 249   st-&gt;print(&quot;}&quot;);
 250 }
 251 #endif
 252 
 253 // ciTypeFlow::StateVector
 254 //
 255 // A StateVector summarizes the type information at some point in
 256 // the program.
 257 
 258 // ------------------------------------------------------------------
 259 // ciTypeFlow::StateVector::type_meet
 260 //
 261 // Meet two types.
 262 //
 263 // The semi-lattice of types use by this analysis are modeled on those
 264 // of the verifier.  The lattice is as follows:
 265 //
 266 //        top_type() &gt;= all non-extremal types &gt;= bottom_type
 267 //                             and
 268 //   Every primitive type is comparable only with itself.  The meet of
 269 //   reference types is determined by their kind: instance class,
 270 //   interface, or array class.  The meet of two types of the same
 271 //   kind is their least common ancestor.  The meet of two types of
 272 //   different kinds is always java.lang.Object.
 273 ciType* ciTypeFlow::StateVector::type_meet_internal(ciType* t1, ciType* t2, ciTypeFlow* analyzer) {
 274   assert(t1 != t2, &quot;checked in caller&quot;);
 275   if (t1-&gt;equals(top_type())) {
 276     return t2;
 277   } else if (t2-&gt;equals(top_type())) {
 278     return t1;
 279   }
 280 
 281   // Unwrap after saving nullness information and handling top meets
 282   bool never_null1 = t1-&gt;is_never_null();
 283   bool never_null2 = t2-&gt;is_never_null();
 284   if (t1-&gt;unwrap() == t2-&gt;unwrap() &amp;&amp; never_null1 == never_null2) {
 285     return t1;
 286   }
 287   t1 = t1-&gt;unwrap();
 288   t2 = t2-&gt;unwrap();
 289 
 290   if (t1-&gt;is_primitive_type() || t2-&gt;is_primitive_type()) {
 291     // Special case null_type.  null_type meet any reference type T
 292     // is T.  null_type meet null_type is null_type.
 293     if (t1-&gt;equals(null_type())) {
 294       if (!t2-&gt;is_primitive_type() || t2-&gt;equals(null_type())) {
 295         return t2;
 296       }
 297     } else if (t2-&gt;equals(null_type())) {
 298       if (!t1-&gt;is_primitive_type()) {
 299         return t1;
 300       }
 301     }
 302 
 303     // At least one of the two types is a non-top primitive type.
 304     // The other type is not equal to it.  Fall to bottom.
 305     return bottom_type();
 306   }
 307 
 308   // Both types are non-top non-primitive types.  That is,
 309   // both types are either instanceKlasses or arrayKlasses.
 310   ciKlass* object_klass = analyzer-&gt;env()-&gt;Object_klass();
 311   ciKlass* k1 = t1-&gt;as_klass();
 312   ciKlass* k2 = t2-&gt;as_klass();
 313   if (k1-&gt;equals(object_klass) || k2-&gt;equals(object_klass)) {
 314     return object_klass;
 315   } else if (!k1-&gt;is_loaded() || !k2-&gt;is_loaded()) {
 316     // Unloaded classes fall to java.lang.Object at a merge.
 317     return object_klass;
 318   } else if (k1-&gt;is_interface() != k2-&gt;is_interface()) {
 319     // When an interface meets a non-interface, we get Object;
 320     // This is what the verifier does.
 321     return object_klass;
 322   } else if (k1-&gt;is_array_klass() || k2-&gt;is_array_klass()) {
 323     // When an array meets a non-array, we get Object.
 324     // When (obj/value)Array meets typeArray, we also get Object.
 325     // And when typeArray meets different typeArray, we again get Object.
<a name="1" id="anc1"></a><span class="line-modified"> 326     // But when (obj/value)Array meets (obj/value)Array, we look carefully at element types and storage properties.</span>
 327     if ((k1-&gt;is_obj_array_klass() || k1-&gt;is_value_array_klass()) &amp;&amp;
 328         (k2-&gt;is_obj_array_klass() || k2-&gt;is_value_array_klass())) {
<a name="2" id="anc2"></a><span class="line-removed"> 329       bool prop_mismatch = k1-&gt;as_array_klass()-&gt;storage_properties().value() !=</span>
<span class="line-removed"> 330                            k2-&gt;as_array_klass()-&gt;storage_properties().value();</span>
<span class="line-removed"> 331       bool never_null = k1-&gt;as_array_klass()-&gt;storage_properties().is_null_free() &amp;&amp;</span>
<span class="line-removed"> 332                         k2-&gt;as_array_klass()-&gt;storage_properties().is_null_free();</span>
 333       ciType* elem1 = k1-&gt;as_array_klass()-&gt;element_klass();
 334       ciType* elem2 = k2-&gt;as_array_klass()-&gt;element_klass();
 335       ciType* elem = elem1;
 336       if (elem1 != elem2) {
 337         elem = type_meet_internal(elem1, elem2, analyzer)-&gt;as_klass();
 338       }
 339       // Do an easy shortcut if one type is a super of the other.
<a name="3" id="anc3"></a><span class="line-modified"> 340       if (elem == elem1 &amp;&amp; !prop_mismatch) {</span>
<span class="line-modified"> 341         assert(k1 == ciArrayKlass::make(elem, never_null), &quot;shortcut is OK&quot;);</span>
 342         return k1;
<a name="4" id="anc4"></a><span class="line-modified"> 343       } else if (elem == elem2 &amp;&amp; !prop_mismatch) {</span>
<span class="line-modified"> 344         assert(k2 == ciArrayKlass::make(elem, never_null), &quot;shortcut is OK&quot;);</span>
 345         return k2;
 346       } else {
<a name="5" id="anc5"></a><span class="line-modified"> 347         return ciArrayKlass::make(elem, never_null);</span>
 348       }
 349     } else {
 350       return object_klass;
 351     }
 352   } else {
 353     // Must be two plain old instance klasses.
 354     assert(k1-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);
 355     assert(k2-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);
 356     ciType* result = k1-&gt;least_common_ancestor(k2);
 357     if (never_null1 &amp;&amp; never_null2 &amp;&amp; result-&gt;is_valuetype()) {
 358       // Both value types are never null, mark the result as never null
 359       result = analyzer-&gt;mark_as_never_null(result);
 360     }
 361     return result;
 362   }
 363 }
 364 
 365 
 366 // ------------------------------------------------------------------
 367 // ciTypeFlow::StateVector::StateVector
 368 //
 369 // Build a new state vector
 370 ciTypeFlow::StateVector::StateVector(ciTypeFlow* analyzer) {
 371   _outer = analyzer;
 372   _stack_size = -1;
 373   _monitor_count = -1;
 374   // Allocate the _types array
 375   int max_cells = analyzer-&gt;max_cells();
 376   _types = (ciType**)analyzer-&gt;arena()-&gt;Amalloc(sizeof(ciType*) * max_cells);
 377   for (int i=0; i&lt;max_cells; i++) {
 378     _types[i] = top_type();
 379   }
 380   _trap_bci = -1;
 381   _trap_index = 0;
 382   _def_locals.clear();
 383 }
 384 
 385 
 386 // ------------------------------------------------------------------
 387 // ciTypeFlow::get_start_state
 388 //
 389 // Set this vector to the method entry state.
 390 const ciTypeFlow::StateVector* ciTypeFlow::get_start_state() {
 391   StateVector* state = new StateVector(this);
 392   if (is_osr_flow()) {
 393     ciTypeFlow* non_osr_flow = method()-&gt;get_flow_analysis();
 394     if (non_osr_flow-&gt;failing()) {
 395       record_failure(non_osr_flow-&gt;failure_reason());
 396       return NULL;
 397     }
 398     JsrSet* jsrs = new JsrSet(NULL, 16);
 399     Block* non_osr_block = non_osr_flow-&gt;existing_block_at(start_bci(), jsrs);
 400     if (non_osr_block == NULL) {
 401       record_failure(&quot;cannot reach OSR point&quot;);
 402       return NULL;
 403     }
 404     // load up the non-OSR state at this point
 405     non_osr_block-&gt;copy_state_into(state);
 406     int non_osr_start = non_osr_block-&gt;start();
 407     if (non_osr_start != start_bci()) {
 408       // must flow forward from it
 409       if (CITraceTypeFlow) {
 410         tty-&gt;print_cr(&quot;&gt;&gt; Interpreting pre-OSR block %d:&quot;, non_osr_start);
 411       }
 412       Block* block = block_at(non_osr_start, jsrs);
 413       assert(block-&gt;limit() == start_bci(), &quot;must flow forward to start&quot;);
 414       flow_block(block, state, jsrs);
 415     }
 416     return state;
 417     // Note:  The code below would be an incorrect for an OSR flow,
 418     // even if it were possible for an OSR entry point to be at bci zero.
 419   }
 420   // &quot;Push&quot; the method signature into the first few locals.
 421   state-&gt;set_stack_size(-max_locals());
 422   if (!method()-&gt;is_static()) {
 423     ciType* holder = method()-&gt;holder();
 424     if (holder-&gt;is_valuetype()) {
 425       // The receiver is never null
 426       holder = mark_as_never_null(holder);
 427     }
 428     state-&gt;push(holder);
 429     assert(state-&gt;tos() == state-&gt;local(0), &quot;&quot;);
 430   }
 431   for (ciSignatureStream str(method()-&gt;signature());
 432        !str.at_return_type();
 433        str.next()) {
 434     ciType* arg = str.type();
 435     if (str.is_never_null()) {
 436       arg = mark_as_never_null(arg);
 437     }
 438     state-&gt;push_translate(arg);
 439   }
 440   // Set the rest of the locals to bottom.
 441   Cell cell = state-&gt;next_cell(state-&gt;tos());
 442   state-&gt;set_stack_size(0);
 443   int limit = state-&gt;limit_cell();
 444   for (; cell &lt; limit; cell = state-&gt;next_cell(cell)) {
 445     state-&gt;set_type_at(cell, state-&gt;bottom_type());
 446   }
 447   // Lock an object, if necessary.
 448   state-&gt;set_monitor_count(method()-&gt;is_synchronized() ? 1 : 0);
 449   return state;
 450 }
 451 
 452 // ------------------------------------------------------------------
 453 // ciTypeFlow::StateVector::copy_into
 454 //
 455 // Copy our value into some other StateVector
 456 void ciTypeFlow::StateVector::copy_into(ciTypeFlow::StateVector* copy)
 457 const {
 458   copy-&gt;set_stack_size(stack_size());
 459   copy-&gt;set_monitor_count(monitor_count());
 460   Cell limit = limit_cell();
 461   for (Cell c = start_cell(); c &lt; limit; c = next_cell(c)) {
 462     copy-&gt;set_type_at(c, type_at(c));
 463   }
 464 }
 465 
 466 // ------------------------------------------------------------------
 467 // ciTypeFlow::StateVector::meet
 468 //
 469 // Meets this StateVector with another, destructively modifying this
 470 // one.  Returns true if any modification takes place.
 471 bool ciTypeFlow::StateVector::meet(const ciTypeFlow::StateVector* incoming) {
 472   if (monitor_count() == -1) {
 473     set_monitor_count(incoming-&gt;monitor_count());
 474   }
 475   assert(monitor_count() == incoming-&gt;monitor_count(), &quot;monitors must match&quot;);
 476 
 477   if (stack_size() == -1) {
 478     set_stack_size(incoming-&gt;stack_size());
 479     Cell limit = limit_cell();
 480     #ifdef ASSERT
 481     { for (Cell c = start_cell(); c &lt; limit; c = next_cell(c)) {
 482         assert(type_at(c) == top_type(), &quot;&quot;);
 483     } }
 484     #endif
 485     // Make a simple copy of the incoming state.
 486     for (Cell c = start_cell(); c &lt; limit; c = next_cell(c)) {
 487       set_type_at(c, incoming-&gt;type_at(c));
 488     }
 489     return true;  // it is always different the first time
 490   }
 491 #ifdef ASSERT
 492   if (stack_size() != incoming-&gt;stack_size()) {
 493     _outer-&gt;method()-&gt;print_codes();
 494     tty-&gt;print_cr(&quot;!!!! Stack size conflict&quot;);
 495     tty-&gt;print_cr(&quot;Current state:&quot;);
 496     print_on(tty);
 497     tty-&gt;print_cr(&quot;Incoming state:&quot;);
 498     ((StateVector*)incoming)-&gt;print_on(tty);
 499   }
 500 #endif
 501   assert(stack_size() == incoming-&gt;stack_size(), &quot;sanity&quot;);
 502 
 503   bool different = false;
 504   Cell limit = limit_cell();
 505   for (Cell c = start_cell(); c &lt; limit; c = next_cell(c)) {
 506     ciType* t1 = type_at(c);
 507     ciType* t2 = incoming-&gt;type_at(c);
 508     if (!t1-&gt;equals(t2)) {
 509       ciType* new_type = type_meet(t1, t2);
 510       if (!t1-&gt;equals(new_type)) {
 511         set_type_at(c, new_type);
 512         different = true;
 513       }
 514     }
 515   }
 516   return different;
 517 }
 518 
 519 // ------------------------------------------------------------------
 520 // ciTypeFlow::StateVector::meet_exception
 521 //
 522 // Meets this StateVector with another, destructively modifying this
 523 // one.  The incoming state is coming via an exception.  Returns true
 524 // if any modification takes place.
 525 bool ciTypeFlow::StateVector::meet_exception(ciInstanceKlass* exc,
 526                                      const ciTypeFlow::StateVector* incoming) {
 527   if (monitor_count() == -1) {
 528     set_monitor_count(incoming-&gt;monitor_count());
 529   }
 530   assert(monitor_count() == incoming-&gt;monitor_count(), &quot;monitors must match&quot;);
 531 
 532   if (stack_size() == -1) {
 533     set_stack_size(1);
 534   }
 535 
 536   assert(stack_size() ==  1, &quot;must have one-element stack&quot;);
 537 
 538   bool different = false;
 539 
 540   // Meet locals from incoming array.
 541   Cell limit = local(_outer-&gt;max_locals()-1);
 542   for (Cell c = start_cell(); c &lt;= limit; c = next_cell(c)) {
 543     ciType* t1 = type_at(c);
 544     ciType* t2 = incoming-&gt;type_at(c);
 545     if (!t1-&gt;equals(t2)) {
 546       ciType* new_type = type_meet(t1, t2);
 547       if (!t1-&gt;equals(new_type)) {
 548         set_type_at(c, new_type);
 549         different = true;
 550       }
 551     }
 552   }
 553 
 554   // Handle stack separately.  When an exception occurs, the
 555   // only stack entry is the exception instance.
 556   ciType* tos_type = type_at_tos();
 557   if (!tos_type-&gt;equals(exc)) {
 558     ciType* new_type = type_meet(tos_type, exc);
 559     if (!tos_type-&gt;equals(new_type)) {
 560       set_type_at_tos(new_type);
 561       different = true;
 562     }
 563   }
 564 
 565   return different;
 566 }
 567 
 568 // ------------------------------------------------------------------
 569 // ciTypeFlow::StateVector::push_translate
 570 void ciTypeFlow::StateVector::push_translate(ciType* type) {
 571   BasicType basic_type = type-&gt;basic_type();
 572   if (basic_type == T_BOOLEAN || basic_type == T_CHAR ||
 573       basic_type == T_BYTE    || basic_type == T_SHORT) {
 574     push_int();
 575   } else {
 576     push(type);
 577     if (type-&gt;is_two_word()) {
 578       push(half_type(type));
 579     }
 580   }
 581 }
 582 
 583 // ------------------------------------------------------------------
 584 // ciTypeFlow::StateVector::do_aload
 585 void ciTypeFlow::StateVector::do_aload(ciBytecodeStream* str) {
 586   pop_int();
 587   ciArrayKlass* array_klass = pop_objOrValueArray();
 588   if (array_klass == NULL) {
 589     // Did aload on a null reference; push a null and ignore the exception.
 590     // This instruction will never continue normally.  All we have to do
 591     // is report a value that will meet correctly with any downstream
 592     // reference types on paths that will truly be executed.  This null type
 593     // meets with any reference type to yield that same reference type.
 594     // (The compiler will generate an unconditional exception here.)
 595     push(null_type());
 596     return;
 597   }
 598   if (!array_klass-&gt;is_loaded()) {
 599     // Only fails for some -Xcomp runs
 600     trap(str, array_klass,
 601          Deoptimization::make_trap_request
 602          (Deoptimization::Reason_unloaded,
 603           Deoptimization::Action_reinterpret));
 604     return;
 605   }
 606   ciKlass* element_klass = array_klass-&gt;element_klass();
 607   if (!element_klass-&gt;is_loaded() &amp;&amp; element_klass-&gt;is_instance_klass()) {
 608     Untested(&quot;unloaded array element class in ciTypeFlow&quot;);
 609     trap(str, element_klass,
 610          Deoptimization::make_trap_request
 611          (Deoptimization::Reason_unloaded,
 612           Deoptimization::Action_reinterpret));
 613   } else {
<a name="6" id="anc6"></a><span class="line-modified"> 614     if (array_klass-&gt;storage_properties().is_null_free()) {</span>
 615       // Value type array elements are never null
<a name="7" id="anc7"></a><span class="line-removed"> 616       assert(element_klass-&gt;is_valuetype(), &quot;must be a value type array&quot;);</span>
 617       push(outer()-&gt;mark_as_never_null(element_klass));
 618     } else {
 619       push_object(element_klass);
 620     }
 621   }
 622 }
 623 
 624 
 625 // ------------------------------------------------------------------
 626 // ciTypeFlow::StateVector::do_checkcast
 627 void ciTypeFlow::StateVector::do_checkcast(ciBytecodeStream* str) {
 628   bool will_link;
 629   ciKlass* klass = str-&gt;get_klass(will_link);
 630   bool never_null = str-&gt;is_klass_never_null();
 631   if (!will_link) {
 632     if (never_null) {
 633       trap(str, klass,
 634            Deoptimization::make_trap_request
 635            (Deoptimization::Reason_unloaded,
 636             Deoptimization::Action_reinterpret));
 637     } else {
 638       // VM&#39;s interpreter will not load &#39;klass&#39; if object is NULL.
 639       // Type flow after this block may still be needed in two situations:
 640       // 1) C2 uses do_null_assert() and continues compilation for later blocks
 641       // 2) C2 does an OSR compile in a later block (see bug 4778368).
 642       pop_object();
 643       do_null_assert(klass);
 644     }
 645   } else {
 646     ciType* type = pop_value();
 647     if (klass-&gt;is_valuetype() &amp;&amp; (never_null || type-&gt;is_never_null())) {
 648       // Casting to a Q-Type contains a NULL check
 649       push(outer()-&gt;mark_as_never_null(klass));
 650     } else {
 651       push_object(klass);
 652     }
 653   }
 654 }
 655 
 656 // ------------------------------------------------------------------
 657 // ciTypeFlow::StateVector::do_getfield
 658 void ciTypeFlow::StateVector::do_getfield(ciBytecodeStream* str) {
 659   // could add assert here for type of object.
 660   pop_object();
 661   do_getstatic(str);
 662 }
 663 
 664 // ------------------------------------------------------------------
 665 // ciTypeFlow::StateVector::do_getstatic
 666 void ciTypeFlow::StateVector::do_getstatic(ciBytecodeStream* str) {
 667   bool will_link;
 668   ciField* field = str-&gt;get_field(will_link);
 669   if (!will_link) {
 670     trap(str, field-&gt;holder(), str-&gt;get_field_holder_index());
 671   } else {
 672     ciType* field_type = field-&gt;type();
 673     if (!field_type-&gt;is_loaded()) {
 674       // Normally, we need the field&#39;s type to be loaded if we are to
 675       // do anything interesting with its value.
 676       // We used to do this:  trap(str, str-&gt;get_field_signature_index());
 677       //
 678       // There is one good reason not to trap here.  Execution can
 679       // get past this &quot;getfield&quot; or &quot;getstatic&quot; if the value of
 680       // the field is null.  As long as the value is null, the class
 681       // does not need to be loaded!  The compiler must assume that
 682       // the value of the unloaded class reference is null; if the code
 683       // ever sees a non-null value, loading has occurred.
 684       //
 685       // This actually happens often enough to be annoying.  If the
 686       // compiler throws an uncommon trap at this bytecode, you can
 687       // get an endless loop of recompilations, when all the code
 688       // needs to do is load a series of null values.  Also, a trap
 689       // here can make an OSR entry point unreachable, triggering the
 690       // assert on non_osr_block in ciTypeFlow::get_start_state.
 691       // (See bug 4379915.)
 692       do_null_assert(field_type-&gt;as_klass());
 693     } else {
 694       if (field-&gt;is_flattenable()) {
 695         // A flattenable field is never null
 696         field_type = outer()-&gt;mark_as_never_null(field_type);
 697       }
 698       push_translate(field_type);
 699     }
 700   }
 701 }
 702 
 703 // ------------------------------------------------------------------
 704 // ciTypeFlow::StateVector::do_invoke
 705 void ciTypeFlow::StateVector::do_invoke(ciBytecodeStream* str,
 706                                         bool has_receiver) {
 707   bool will_link;
 708   ciSignature* declared_signature = NULL;
 709   ciMethod* callee = str-&gt;get_method(will_link, &amp;declared_signature);
 710   assert(declared_signature != NULL, &quot;cannot be null&quot;);
 711   if (!will_link) {
 712     // We weren&#39;t able to find the method.
 713     if (str-&gt;cur_bc() == Bytecodes::_invokedynamic) {
 714       trap(str, NULL,
 715            Deoptimization::make_trap_request
 716            (Deoptimization::Reason_uninitialized,
 717             Deoptimization::Action_reinterpret));
 718     } else {
 719       ciKlass* unloaded_holder = callee-&gt;holder();
 720       trap(str, unloaded_holder, str-&gt;get_method_holder_index());
 721     }
 722   } else {
 723     // We are using the declared signature here because it might be
 724     // different from the callee signature (Cf. invokedynamic and
 725     // invokehandle).
 726     ciSignatureStream sigstr(declared_signature);
 727     const int arg_size = declared_signature-&gt;size();
 728     const int stack_base = stack_size() - arg_size;
 729     int i = 0;
 730     for( ; !sigstr.at_return_type(); sigstr.next()) {
 731       ciType* type = sigstr.type();
 732       ciType* stack_type = type_at(stack(stack_base + i++));
 733       // Do I want to check this type?
 734       // assert(stack_type-&gt;is_subtype_of(type), &quot;bad type for field value&quot;);
 735       if (type-&gt;is_two_word()) {
 736         ciType* stack_type2 = type_at(stack(stack_base + i++));
 737         assert(stack_type2-&gt;equals(half_type(type)), &quot;must be 2nd half&quot;);
 738       }
 739     }
 740     assert(arg_size == i, &quot;must match&quot;);
 741     for (int j = 0; j &lt; arg_size; j++) {
 742       pop();
 743     }
 744     if (has_receiver) {
 745       // Check this?
 746       pop_object();
 747     }
 748     assert(!sigstr.is_done(), &quot;must have return type&quot;);
 749     ciType* return_type = sigstr.type();
 750     if (!return_type-&gt;is_void()) {
 751       if (!return_type-&gt;is_loaded()) {
 752         // As in do_getstatic(), generally speaking, we need the return type to
 753         // be loaded if we are to do anything interesting with its value.
 754         // We used to do this:  trap(str, str-&gt;get_method_signature_index());
 755         //
 756         // We do not trap here since execution can get past this invoke if
 757         // the return value is null.  As long as the value is null, the class
 758         // does not need to be loaded!  The compiler must assume that
 759         // the value of the unloaded class reference is null; if the code
 760         // ever sees a non-null value, loading has occurred.
 761         //
 762         // See do_getstatic() for similar explanation, as well as bug 4684993.
 763         do_null_assert(return_type-&gt;as_klass());
 764       } else {
 765         if (sigstr.is_never_null()) {
 766           return_type = outer()-&gt;mark_as_never_null(return_type);
 767         }
 768         push_translate(return_type);
 769       }
 770     }
 771   }
 772 }
 773 
 774 // ------------------------------------------------------------------
 775 // ciTypeFlow::StateVector::do_jsr
 776 void ciTypeFlow::StateVector::do_jsr(ciBytecodeStream* str) {
 777   push(ciReturnAddress::make(str-&gt;next_bci()));
 778 }
 779 
 780 // ------------------------------------------------------------------
 781 // ciTypeFlow::StateVector::do_ldc
 782 void ciTypeFlow::StateVector::do_ldc(ciBytecodeStream* str) {
 783   ciConstant con = str-&gt;get_constant();
 784   BasicType basic_type = con.basic_type();
 785   if (basic_type == T_ILLEGAL) {
 786     // OutOfMemoryError in the CI while loading constant
 787     push_null();
 788     outer()-&gt;record_failure(&quot;ldc did not link&quot;);
 789     return;
 790   }
 791   if (is_reference_type(basic_type)) {
 792     ciObject* obj = con.as_object();
 793     if (obj-&gt;is_null_object()) {
 794       push_null();
 795     } else {
 796       assert(obj-&gt;is_instance() || obj-&gt;is_array(), &quot;must be java_mirror of klass&quot;);
 797       ciType* type = obj-&gt;klass();
 798       if (type-&gt;is_valuetype()) {
 799         type = outer()-&gt;mark_as_never_null(type);
 800       }
 801       push(type);
 802     }
 803   } else {
 804     push_translate(ciType::make(basic_type));
 805   }
 806 }
 807 
 808 // ------------------------------------------------------------------
 809 // ciTypeFlow::StateVector::do_multianewarray
 810 void ciTypeFlow::StateVector::do_multianewarray(ciBytecodeStream* str) {
 811   int dimensions = str-&gt;get_dimensions();
 812   bool will_link;
 813   ciArrayKlass* array_klass = str-&gt;get_klass(will_link)-&gt;as_array_klass();
 814   if (!will_link) {
 815     trap(str, array_klass, str-&gt;get_klass_index());
 816   } else {
 817     for (int i = 0; i &lt; dimensions; i++) {
 818       pop_int();
 819     }
 820     push_object(array_klass);
 821   }
 822 }
 823 
 824 // ------------------------------------------------------------------
 825 // ciTypeFlow::StateVector::do_new
 826 void ciTypeFlow::StateVector::do_new(ciBytecodeStream* str) {
 827   bool will_link;
 828   ciKlass* klass = str-&gt;get_klass(will_link);
 829   if (!will_link || str-&gt;is_unresolved_klass()) {
 830     trap(str, klass, str-&gt;get_klass_index());
 831   } else {
 832     push_object(klass);
 833   }
 834 }
 835 
 836 // ------------------------------------------------------------------
 837 // ciTypeFlow::StateVector::do_defaultvalue
 838 void ciTypeFlow::StateVector::do_defaultvalue(ciBytecodeStream* str) {
 839   bool will_link;
 840   ciKlass* klass = str-&gt;get_klass(will_link);
 841   if (!will_link) {
 842     trap(str, klass, str-&gt;get_klass_index());
 843   } else {
 844     // The default value type is never null
 845     push(outer()-&gt;mark_as_never_null(klass));
 846   }
 847 }
 848 
 849 // ------------------------------------------------------------------
 850 // ciTypeFlow::StateVector::do_withfield
 851 void ciTypeFlow::StateVector::do_withfield(ciBytecodeStream* str) {
 852   bool will_link;
 853   ciField* field = str-&gt;get_field(will_link);
 854   ciKlass* klass = field-&gt;holder();
 855   if (!will_link) {
 856     trap(str, klass, str-&gt;get_field_holder_index());
 857   } else {
 858     ciType* type = pop_value();
 859     ciType* field_type = field-&gt;type();
 860     assert(field_type-&gt;is_loaded(), &quot;field type must be loaded&quot;);
 861     if (field_type-&gt;is_two_word()) {
 862       ciType* type2 = pop_value();
 863       assert(type2-&gt;is_two_word(), &quot;must be 2nd half&quot;);
 864       assert(type == half_type(type2), &quot;must be 2nd half&quot;);
 865     }
 866     pop_object();
 867     // The newly created value type can never be null
 868     push(outer()-&gt;mark_as_never_null(klass));
 869   }
 870 }
 871 
 872 // ------------------------------------------------------------------
 873 // ciTypeFlow::StateVector::do_newarray
 874 void ciTypeFlow::StateVector::do_newarray(ciBytecodeStream* str) {
 875   pop_int();
 876   ciKlass* klass = ciTypeArrayKlass::make((BasicType)str-&gt;get_index());
 877   push_object(klass);
 878 }
 879 
 880 // ------------------------------------------------------------------
 881 // ciTypeFlow::StateVector::do_putfield
 882 void ciTypeFlow::StateVector::do_putfield(ciBytecodeStream* str) {
 883   do_putstatic(str);
 884   if (_trap_bci != -1)  return;  // unloaded field holder, etc.
 885   // could add assert here for type of object.
 886   pop_object();
 887 }
 888 
 889 // ------------------------------------------------------------------
 890 // ciTypeFlow::StateVector::do_putstatic
 891 void ciTypeFlow::StateVector::do_putstatic(ciBytecodeStream* str) {
 892   bool will_link;
 893   ciField* field = str-&gt;get_field(will_link);
 894   if (!will_link) {
 895     trap(str, field-&gt;holder(), str-&gt;get_field_holder_index());
 896   } else {
 897     ciType* field_type = field-&gt;type();
 898     ciType* type = pop_value();
 899     // Do I want to check this type?
 900     //      assert(type-&gt;is_subtype_of(field_type), &quot;bad type for field value&quot;);
 901     if (field_type-&gt;is_two_word()) {
 902       ciType* type2 = pop_value();
 903       assert(type2-&gt;is_two_word(), &quot;must be 2nd half&quot;);
 904       assert(type == half_type(type2), &quot;must be 2nd half&quot;);
 905     }
 906   }
 907 }
 908 
 909 // ------------------------------------------------------------------
 910 // ciTypeFlow::StateVector::do_ret
 911 void ciTypeFlow::StateVector::do_ret(ciBytecodeStream* str) {
 912   Cell index = local(str-&gt;get_index());
 913 
 914   ciType* address = type_at(index);
 915   assert(address-&gt;is_return_address(), &quot;bad return address&quot;);
 916   set_type_at(index, bottom_type());
 917 }
 918 
 919 // ------------------------------------------------------------------
 920 // ciTypeFlow::StateVector::trap
 921 //
 922 // Stop interpretation of this path with a trap.
 923 void ciTypeFlow::StateVector::trap(ciBytecodeStream* str, ciKlass* klass, int index) {
 924   _trap_bci = str-&gt;cur_bci();
 925   _trap_index = index;
 926 
 927   // Log information about this trap:
 928   CompileLog* log = outer()-&gt;env()-&gt;log();
 929   if (log != NULL) {
 930     int mid = log-&gt;identify(outer()-&gt;method());
 931     int kid = (klass == NULL)? -1: log-&gt;identify(klass);
 932     log-&gt;begin_elem(&quot;uncommon_trap method=&#39;%d&#39; bci=&#39;%d&#39;&quot;, mid, str-&gt;cur_bci());
 933     char buf[100];
 934     log-&gt;print(&quot; %s&quot;, Deoptimization::format_trap_request(buf, sizeof(buf),
 935                                                           index));
 936     if (kid &gt;= 0)
 937       log-&gt;print(&quot; klass=&#39;%d&#39;&quot;, kid);
 938     log-&gt;end_elem();
 939   }
 940 }
 941 
 942 // ------------------------------------------------------------------
 943 // ciTypeFlow::StateVector::do_null_assert
 944 // Corresponds to graphKit::do_null_assert.
 945 void ciTypeFlow::StateVector::do_null_assert(ciKlass* unloaded_klass) {
 946   if (unloaded_klass-&gt;is_loaded()) {
 947     // We failed to link, but we can still compute with this class,
 948     // since it is loaded somewhere.  The compiler will uncommon_trap
 949     // if the object is not null, but the typeflow pass can not assume
 950     // that the object will be null, otherwise it may incorrectly tell
 951     // the parser that an object is known to be null. 4761344, 4807707
 952     push_object(unloaded_klass);
 953   } else {
 954     // The class is not loaded anywhere.  It is safe to model the
 955     // null in the typestates, because we can compile in a null check
 956     // which will deoptimize us if someone manages to load the
 957     // class later.
 958     push_null();
 959   }
 960 }
 961 
 962 
 963 // ------------------------------------------------------------------
 964 // ciTypeFlow::StateVector::apply_one_bytecode
 965 //
 966 // Apply the effect of one bytecode to this StateVector
 967 bool ciTypeFlow::StateVector::apply_one_bytecode(ciBytecodeStream* str) {
 968   _trap_bci = -1;
 969   _trap_index = 0;
 970 
 971   if (CITraceTypeFlow) {
 972     tty-&gt;print_cr(&quot;&gt;&gt; Interpreting bytecode %d:%s&quot;, str-&gt;cur_bci(),
 973                   Bytecodes::name(str-&gt;cur_bc()));
 974   }
 975 
 976   switch(str-&gt;cur_bc()) {
 977   case Bytecodes::_aaload: do_aload(str);                           break;
 978 
 979   case Bytecodes::_aastore:
 980     {
 981       pop_object();
 982       pop_int();
 983       pop_objOrValueArray();
 984       break;
 985     }
 986   case Bytecodes::_aconst_null:
 987     {
 988       push_null();
 989       break;
 990     }
 991   case Bytecodes::_aload:   load_local_object(str-&gt;get_index());    break;
 992   case Bytecodes::_aload_0: load_local_object(0);                   break;
 993   case Bytecodes::_aload_1: load_local_object(1);                   break;
 994   case Bytecodes::_aload_2: load_local_object(2);                   break;
 995   case Bytecodes::_aload_3: load_local_object(3);                   break;
 996 
 997   case Bytecodes::_anewarray:
 998     {
 999       pop_int();
1000       bool will_link;
1001       ciKlass* element_klass = str-&gt;get_klass(will_link);
1002       if (!will_link) {
1003         trap(str, element_klass, str-&gt;get_klass_index());
1004       } else {
<a name="8" id="anc8"></a><span class="line-modified">1005         bool never_null = str-&gt;is_klass_never_null();</span>
<span class="line-removed">1006         push_object(ciArrayKlass::make(element_klass, never_null));</span>
1007       }
1008       break;
1009     }
1010   case Bytecodes::_areturn:
1011   case Bytecodes::_ifnonnull:
1012   case Bytecodes::_ifnull:
1013     {
1014       pop_object();
1015       break;
1016     }
1017   case Bytecodes::_monitorenter:
1018     {
1019       pop_object();
1020       set_monitor_count(monitor_count() + 1);
1021       break;
1022     }
1023   case Bytecodes::_monitorexit:
1024     {
1025       pop_object();
1026       assert(monitor_count() &gt; 0, &quot;must be a monitor to exit from&quot;);
1027       set_monitor_count(monitor_count() - 1);
1028       break;
1029     }
1030   case Bytecodes::_arraylength:
1031     {
1032       pop_array();
1033       push_int();
1034       break;
1035     }
1036   case Bytecodes::_astore:   store_local_object(str-&gt;get_index());  break;
1037   case Bytecodes::_astore_0: store_local_object(0);                 break;
1038   case Bytecodes::_astore_1: store_local_object(1);                 break;
1039   case Bytecodes::_astore_2: store_local_object(2);                 break;
1040   case Bytecodes::_astore_3: store_local_object(3);                 break;
1041 
1042   case Bytecodes::_athrow:
1043     {
1044       NEEDS_CLEANUP;
1045       pop_object();
1046       break;
1047     }
1048   case Bytecodes::_baload:
1049   case Bytecodes::_caload:
1050   case Bytecodes::_iaload:
1051   case Bytecodes::_saload:
1052     {
1053       pop_int();
1054       ciTypeArrayKlass* array_klass = pop_typeArray();
1055       // Put assert here for right type?
1056       push_int();
1057       break;
1058     }
1059   case Bytecodes::_bastore:
1060   case Bytecodes::_castore:
1061   case Bytecodes::_iastore:
1062   case Bytecodes::_sastore:
1063     {
1064       pop_int();
1065       pop_int();
1066       pop_typeArray();
1067       // assert here?
1068       break;
1069     }
1070   case Bytecodes::_bipush:
1071   case Bytecodes::_iconst_m1:
1072   case Bytecodes::_iconst_0:
1073   case Bytecodes::_iconst_1:
1074   case Bytecodes::_iconst_2:
1075   case Bytecodes::_iconst_3:
1076   case Bytecodes::_iconst_4:
1077   case Bytecodes::_iconst_5:
1078   case Bytecodes::_sipush:
1079     {
1080       push_int();
1081       break;
1082     }
1083   case Bytecodes::_checkcast: do_checkcast(str);                  break;
1084 
1085   case Bytecodes::_d2f:
1086     {
1087       pop_double();
1088       push_float();
1089       break;
1090     }
1091   case Bytecodes::_d2i:
1092     {
1093       pop_double();
1094       push_int();
1095       break;
1096     }
1097   case Bytecodes::_d2l:
1098     {
1099       pop_double();
1100       push_long();
1101       break;
1102     }
1103   case Bytecodes::_dadd:
1104   case Bytecodes::_ddiv:
1105   case Bytecodes::_dmul:
1106   case Bytecodes::_drem:
1107   case Bytecodes::_dsub:
1108     {
1109       pop_double();
1110       pop_double();
1111       push_double();
1112       break;
1113     }
1114   case Bytecodes::_daload:
1115     {
1116       pop_int();
1117       ciTypeArrayKlass* array_klass = pop_typeArray();
1118       // Put assert here for right type?
1119       push_double();
1120       break;
1121     }
1122   case Bytecodes::_dastore:
1123     {
1124       pop_double();
1125       pop_int();
1126       pop_typeArray();
1127       // assert here?
1128       break;
1129     }
1130   case Bytecodes::_dcmpg:
1131   case Bytecodes::_dcmpl:
1132     {
1133       pop_double();
1134       pop_double();
1135       push_int();
1136       break;
1137     }
1138   case Bytecodes::_dconst_0:
1139   case Bytecodes::_dconst_1:
1140     {
1141       push_double();
1142       break;
1143     }
1144   case Bytecodes::_dload:   load_local_double(str-&gt;get_index());    break;
1145   case Bytecodes::_dload_0: load_local_double(0);                   break;
1146   case Bytecodes::_dload_1: load_local_double(1);                   break;
1147   case Bytecodes::_dload_2: load_local_double(2);                   break;
1148   case Bytecodes::_dload_3: load_local_double(3);                   break;
1149 
1150   case Bytecodes::_dneg:
1151     {
1152       pop_double();
1153       push_double();
1154       break;
1155     }
1156   case Bytecodes::_dreturn:
1157     {
1158       pop_double();
1159       break;
1160     }
1161   case Bytecodes::_dstore:   store_local_double(str-&gt;get_index());  break;
1162   case Bytecodes::_dstore_0: store_local_double(0);                 break;
1163   case Bytecodes::_dstore_1: store_local_double(1);                 break;
1164   case Bytecodes::_dstore_2: store_local_double(2);                 break;
1165   case Bytecodes::_dstore_3: store_local_double(3);                 break;
1166 
1167   case Bytecodes::_dup:
1168     {
1169       push(type_at_tos());
1170       break;
1171     }
1172   case Bytecodes::_dup_x1:
1173     {
1174       ciType* value1 = pop_value();
1175       ciType* value2 = pop_value();
1176       push(value1);
1177       push(value2);
1178       push(value1);
1179       break;
1180     }
1181   case Bytecodes::_dup_x2:
1182     {
1183       ciType* value1 = pop_value();
1184       ciType* value2 = pop_value();
1185       ciType* value3 = pop_value();
1186       push(value1);
1187       push(value3);
1188       push(value2);
1189       push(value1);
1190       break;
1191     }
1192   case Bytecodes::_dup2:
1193     {
1194       ciType* value1 = pop_value();
1195       ciType* value2 = pop_value();
1196       push(value2);
1197       push(value1);
1198       push(value2);
1199       push(value1);
1200       break;
1201     }
1202   case Bytecodes::_dup2_x1:
1203     {
1204       ciType* value1 = pop_value();
1205       ciType* value2 = pop_value();
1206       ciType* value3 = pop_value();
1207       push(value2);
1208       push(value1);
1209       push(value3);
1210       push(value2);
1211       push(value1);
1212       break;
1213     }
1214   case Bytecodes::_dup2_x2:
1215     {
1216       ciType* value1 = pop_value();
1217       ciType* value2 = pop_value();
1218       ciType* value3 = pop_value();
1219       ciType* value4 = pop_value();
1220       push(value2);
1221       push(value1);
1222       push(value4);
1223       push(value3);
1224       push(value2);
1225       push(value1);
1226       break;
1227     }
1228   case Bytecodes::_f2d:
1229     {
1230       pop_float();
1231       push_double();
1232       break;
1233     }
1234   case Bytecodes::_f2i:
1235     {
1236       pop_float();
1237       push_int();
1238       break;
1239     }
1240   case Bytecodes::_f2l:
1241     {
1242       pop_float();
1243       push_long();
1244       break;
1245     }
1246   case Bytecodes::_fadd:
1247   case Bytecodes::_fdiv:
1248   case Bytecodes::_fmul:
1249   case Bytecodes::_frem:
1250   case Bytecodes::_fsub:
1251     {
1252       pop_float();
1253       pop_float();
1254       push_float();
1255       break;
1256     }
1257   case Bytecodes::_faload:
1258     {
1259       pop_int();
1260       ciTypeArrayKlass* array_klass = pop_typeArray();
1261       // Put assert here.
1262       push_float();
1263       break;
1264     }
1265   case Bytecodes::_fastore:
1266     {
1267       pop_float();
1268       pop_int();
1269       ciTypeArrayKlass* array_klass = pop_typeArray();
1270       // Put assert here.
1271       break;
1272     }
1273   case Bytecodes::_fcmpg:
1274   case Bytecodes::_fcmpl:
1275     {
1276       pop_float();
1277       pop_float();
1278       push_int();
1279       break;
1280     }
1281   case Bytecodes::_fconst_0:
1282   case Bytecodes::_fconst_1:
1283   case Bytecodes::_fconst_2:
1284     {
1285       push_float();
1286       break;
1287     }
1288   case Bytecodes::_fload:   load_local_float(str-&gt;get_index());     break;
1289   case Bytecodes::_fload_0: load_local_float(0);                    break;
1290   case Bytecodes::_fload_1: load_local_float(1);                    break;
1291   case Bytecodes::_fload_2: load_local_float(2);                    break;
1292   case Bytecodes::_fload_3: load_local_float(3);                    break;
1293 
1294   case Bytecodes::_fneg:
1295     {
1296       pop_float();
1297       push_float();
1298       break;
1299     }
1300   case Bytecodes::_freturn:
1301     {
1302       pop_float();
1303       break;
1304     }
1305   case Bytecodes::_fstore:    store_local_float(str-&gt;get_index());   break;
1306   case Bytecodes::_fstore_0:  store_local_float(0);                  break;
1307   case Bytecodes::_fstore_1:  store_local_float(1);                  break;
1308   case Bytecodes::_fstore_2:  store_local_float(2);                  break;
1309   case Bytecodes::_fstore_3:  store_local_float(3);                  break;
1310 
1311   case Bytecodes::_getfield:  do_getfield(str);                      break;
1312   case Bytecodes::_getstatic: do_getstatic(str);                     break;
1313 
1314   case Bytecodes::_goto:
1315   case Bytecodes::_goto_w:
1316   case Bytecodes::_nop:
1317   case Bytecodes::_return:
1318     {
1319       // do nothing.
1320       break;
1321     }
1322   case Bytecodes::_i2b:
1323   case Bytecodes::_i2c:
1324   case Bytecodes::_i2s:
1325   case Bytecodes::_ineg:
1326     {
1327       pop_int();
1328       push_int();
1329       break;
1330     }
1331   case Bytecodes::_i2d:
1332     {
1333       pop_int();
1334       push_double();
1335       break;
1336     }
1337   case Bytecodes::_i2f:
1338     {
1339       pop_int();
1340       push_float();
1341       break;
1342     }
1343   case Bytecodes::_i2l:
1344     {
1345       pop_int();
1346       push_long();
1347       break;
1348     }
1349   case Bytecodes::_iadd:
1350   case Bytecodes::_iand:
1351   case Bytecodes::_idiv:
1352   case Bytecodes::_imul:
1353   case Bytecodes::_ior:
1354   case Bytecodes::_irem:
1355   case Bytecodes::_ishl:
1356   case Bytecodes::_ishr:
1357   case Bytecodes::_isub:
1358   case Bytecodes::_iushr:
1359   case Bytecodes::_ixor:
1360     {
1361       pop_int();
1362       pop_int();
1363       push_int();
1364       break;
1365     }
1366   case Bytecodes::_if_acmpeq:
1367   case Bytecodes::_if_acmpne:
1368     {
1369       pop_object();
1370       pop_object();
1371       break;
1372     }
1373   case Bytecodes::_if_icmpeq:
1374   case Bytecodes::_if_icmpge:
1375   case Bytecodes::_if_icmpgt:
1376   case Bytecodes::_if_icmple:
1377   case Bytecodes::_if_icmplt:
1378   case Bytecodes::_if_icmpne:
1379     {
1380       pop_int();
1381       pop_int();
1382       break;
1383     }
1384   case Bytecodes::_ifeq:
1385   case Bytecodes::_ifle:
1386   case Bytecodes::_iflt:
1387   case Bytecodes::_ifge:
1388   case Bytecodes::_ifgt:
1389   case Bytecodes::_ifne:
1390   case Bytecodes::_ireturn:
1391   case Bytecodes::_lookupswitch:
1392   case Bytecodes::_tableswitch:
1393     {
1394       pop_int();
1395       break;
1396     }
1397   case Bytecodes::_iinc:
1398     {
1399       int lnum = str-&gt;get_index();
1400       check_int(local(lnum));
1401       store_to_local(lnum);
1402       break;
1403     }
1404   case Bytecodes::_iload:   load_local_int(str-&gt;get_index()); break;
1405   case Bytecodes::_iload_0: load_local_int(0);                      break;
1406   case Bytecodes::_iload_1: load_local_int(1);                      break;
1407   case Bytecodes::_iload_2: load_local_int(2);                      break;
1408   case Bytecodes::_iload_3: load_local_int(3);                      break;
1409 
1410   case Bytecodes::_instanceof:
1411     {
1412       // Check for uncommon trap:
1413       do_checkcast(str);
1414       pop_object();
1415       push_int();
1416       break;
1417     }
1418   case Bytecodes::_invokeinterface: do_invoke(str, true);           break;
1419   case Bytecodes::_invokespecial:   do_invoke(str, true);           break;
1420   case Bytecodes::_invokestatic:    do_invoke(str, false);          break;
1421   case Bytecodes::_invokevirtual:   do_invoke(str, true);           break;
1422   case Bytecodes::_invokedynamic:   do_invoke(str, false);          break;
1423 
1424   case Bytecodes::_istore:   store_local_int(str-&gt;get_index());     break;
1425   case Bytecodes::_istore_0: store_local_int(0);                    break;
1426   case Bytecodes::_istore_1: store_local_int(1);                    break;
1427   case Bytecodes::_istore_2: store_local_int(2);                    break;
1428   case Bytecodes::_istore_3: store_local_int(3);                    break;
1429 
1430   case Bytecodes::_jsr:
1431   case Bytecodes::_jsr_w: do_jsr(str);                              break;
1432 
1433   case Bytecodes::_l2d:
1434     {
1435       pop_long();
1436       push_double();
1437       break;
1438     }
1439   case Bytecodes::_l2f:
1440     {
1441       pop_long();
1442       push_float();
1443       break;
1444     }
1445   case Bytecodes::_l2i:
1446     {
1447       pop_long();
1448       push_int();
1449       break;
1450     }
1451   case Bytecodes::_ladd:
1452   case Bytecodes::_land:
1453   case Bytecodes::_ldiv:
1454   case Bytecodes::_lmul:
1455   case Bytecodes::_lor:
1456   case Bytecodes::_lrem:
1457   case Bytecodes::_lsub:
1458   case Bytecodes::_lxor:
1459     {
1460       pop_long();
1461       pop_long();
1462       push_long();
1463       break;
1464     }
1465   case Bytecodes::_laload:
1466     {
1467       pop_int();
1468       ciTypeArrayKlass* array_klass = pop_typeArray();
1469       // Put assert here for right type?
1470       push_long();
1471       break;
1472     }
1473   case Bytecodes::_lastore:
1474     {
1475       pop_long();
1476       pop_int();
1477       pop_typeArray();
1478       // assert here?
1479       break;
1480     }
1481   case Bytecodes::_lcmp:
1482     {
1483       pop_long();
1484       pop_long();
1485       push_int();
1486       break;
1487     }
1488   case Bytecodes::_lconst_0:
1489   case Bytecodes::_lconst_1:
1490     {
1491       push_long();
1492       break;
1493     }
1494   case Bytecodes::_ldc:
1495   case Bytecodes::_ldc_w:
1496   case Bytecodes::_ldc2_w:
1497     {
1498       do_ldc(str);
1499       break;
1500     }
1501 
1502   case Bytecodes::_lload:   load_local_long(str-&gt;get_index());      break;
1503   case Bytecodes::_lload_0: load_local_long(0);                     break;
1504   case Bytecodes::_lload_1: load_local_long(1);                     break;
1505   case Bytecodes::_lload_2: load_local_long(2);                     break;
1506   case Bytecodes::_lload_3: load_local_long(3);                     break;
1507 
1508   case Bytecodes::_lneg:
1509     {
1510       pop_long();
1511       push_long();
1512       break;
1513     }
1514   case Bytecodes::_lreturn:
1515     {
1516       pop_long();
1517       break;
1518     }
1519   case Bytecodes::_lshl:
1520   case Bytecodes::_lshr:
1521   case Bytecodes::_lushr:
1522     {
1523       pop_int();
1524       pop_long();
1525       push_long();
1526       break;
1527     }
1528   case Bytecodes::_lstore:   store_local_long(str-&gt;get_index());    break;
1529   case Bytecodes::_lstore_0: store_local_long(0);                   break;
1530   case Bytecodes::_lstore_1: store_local_long(1);                   break;
1531   case Bytecodes::_lstore_2: store_local_long(2);                   break;
1532   case Bytecodes::_lstore_3: store_local_long(3);                   break;
1533 
1534   case Bytecodes::_multianewarray: do_multianewarray(str);          break;
1535 
1536   case Bytecodes::_new:      do_new(str);                           break;
1537 
1538   case Bytecodes::_defaultvalue: do_defaultvalue(str);              break;
1539   case Bytecodes::_withfield: do_withfield(str);                    break;
1540 
1541   case Bytecodes::_newarray: do_newarray(str);                      break;
1542 
1543   case Bytecodes::_pop:
1544     {
1545       pop();
1546       break;
1547     }
1548   case Bytecodes::_pop2:
1549     {
1550       pop();
1551       pop();
1552       break;
1553     }
1554 
1555   case Bytecodes::_putfield:       do_putfield(str);                 break;
1556   case Bytecodes::_putstatic:      do_putstatic(str);                break;
1557 
1558   case Bytecodes::_ret: do_ret(str);                                 break;
1559 
1560   case Bytecodes::_swap:
1561     {
1562       ciType* value1 = pop_value();
1563       ciType* value2 = pop_value();
1564       push(value1);
1565       push(value2);
1566       break;
1567     }
1568 
1569   case Bytecodes::_wide:
1570   default:
1571     {
1572       // The iterator should skip this.
1573       ShouldNotReachHere();
1574       break;
1575     }
1576   }
1577 
1578   if (CITraceTypeFlow) {
1579     print_on(tty);
1580   }
1581 
1582   return (_trap_bci != -1);
1583 }
1584 
1585 #ifndef PRODUCT
1586 // ------------------------------------------------------------------
1587 // ciTypeFlow::StateVector::print_cell_on
1588 void ciTypeFlow::StateVector::print_cell_on(outputStream* st, Cell c) const {
1589   ciType* type = type_at(c);
1590   if (type == top_type()) {
1591     st-&gt;print(&quot;top&quot;);
1592   } else if (type == bottom_type()) {
1593     st-&gt;print(&quot;bottom&quot;);
1594   } else if (type == null_type()) {
1595     st-&gt;print(&quot;null&quot;);
1596   } else if (type == long2_type()) {
1597     st-&gt;print(&quot;long2&quot;);
1598   } else if (type == double2_type()) {
1599     st-&gt;print(&quot;double2&quot;);
1600   } else if (is_int(type)) {
1601     st-&gt;print(&quot;int&quot;);
1602   } else if (is_long(type)) {
1603     st-&gt;print(&quot;long&quot;);
1604   } else if (is_float(type)) {
1605     st-&gt;print(&quot;float&quot;);
1606   } else if (is_double(type)) {
1607     st-&gt;print(&quot;double&quot;);
1608   } else if (type-&gt;is_return_address()) {
1609     st-&gt;print(&quot;address(%d)&quot;, type-&gt;as_return_address()-&gt;bci());
1610   } else {
1611     if (type-&gt;is_klass()) {
1612       type-&gt;as_klass()-&gt;name()-&gt;print_symbol_on(st);
1613     } else {
1614       st-&gt;print(&quot;UNEXPECTED TYPE&quot;);
1615       type-&gt;print();
1616     }
1617   }
1618 }
1619 
1620 // ------------------------------------------------------------------
1621 // ciTypeFlow::StateVector::print_on
1622 void ciTypeFlow::StateVector::print_on(outputStream* st) const {
1623   int num_locals   = _outer-&gt;max_locals();
1624   int num_stack    = stack_size();
1625   int num_monitors = monitor_count();
1626   st-&gt;print_cr(&quot;  State : locals %d, stack %d, monitors %d&quot;, num_locals, num_stack, num_monitors);
1627   if (num_stack &gt;= 0) {
1628     int i;
1629     for (i = 0; i &lt; num_locals; i++) {
1630       st-&gt;print(&quot;    local %2d : &quot;, i);
1631       print_cell_on(st, local(i));
1632       st-&gt;cr();
1633     }
1634     for (i = 0; i &lt; num_stack; i++) {
1635       st-&gt;print(&quot;    stack %2d : &quot;, i);
1636       print_cell_on(st, stack(i));
1637       st-&gt;cr();
1638     }
1639   }
1640 }
1641 #endif
1642 
1643 
1644 // ------------------------------------------------------------------
1645 // ciTypeFlow::SuccIter::next
1646 //
1647 void ciTypeFlow::SuccIter::next() {
1648   int succ_ct = _pred-&gt;successors()-&gt;length();
1649   int next = _index + 1;
1650   if (next &lt; succ_ct) {
1651     _index = next;
1652     _succ = _pred-&gt;successors()-&gt;at(next);
1653     return;
1654   }
1655   for (int i = next - succ_ct; i &lt; _pred-&gt;exceptions()-&gt;length(); i++) {
1656     // Do not compile any code for unloaded exception types.
1657     // Following compiler passes are responsible for doing this also.
1658     ciInstanceKlass* exception_klass = _pred-&gt;exc_klasses()-&gt;at(i);
1659     if (exception_klass-&gt;is_loaded()) {
1660       _index = next;
1661       _succ = _pred-&gt;exceptions()-&gt;at(i);
1662       return;
1663     }
1664     next++;
1665   }
1666   _index = -1;
1667   _succ = NULL;
1668 }
1669 
1670 // ------------------------------------------------------------------
1671 // ciTypeFlow::SuccIter::set_succ
1672 //
1673 void ciTypeFlow::SuccIter::set_succ(Block* succ) {
1674   int succ_ct = _pred-&gt;successors()-&gt;length();
1675   if (_index &lt; succ_ct) {
1676     _pred-&gt;successors()-&gt;at_put(_index, succ);
1677   } else {
1678     int idx = _index - succ_ct;
1679     _pred-&gt;exceptions()-&gt;at_put(idx, succ);
1680   }
1681 }
1682 
1683 // ciTypeFlow::Block
1684 //
1685 // A basic block.
1686 
1687 // ------------------------------------------------------------------
1688 // ciTypeFlow::Block::Block
1689 ciTypeFlow::Block::Block(ciTypeFlow* outer,
1690                          ciBlock *ciblk,
1691                          ciTypeFlow::JsrSet* jsrs) {
1692   _ciblock = ciblk;
1693   _exceptions = NULL;
1694   _exc_klasses = NULL;
1695   _successors = NULL;
1696   _predecessors = new (outer-&gt;arena()) GrowableArray&lt;Block*&gt;(outer-&gt;arena(), 1, 0, NULL);
1697   _state = new (outer-&gt;arena()) StateVector(outer);
1698   JsrSet* new_jsrs =
1699     new (outer-&gt;arena()) JsrSet(outer-&gt;arena(), jsrs-&gt;size());
1700   jsrs-&gt;copy_into(new_jsrs);
1701   _jsrs = new_jsrs;
1702   _next = NULL;
1703   _on_work_list = false;
1704   _backedge_copy = false;
1705   _has_monitorenter = false;
1706   _trap_bci = -1;
1707   _trap_index = 0;
1708   df_init();
1709 
1710   if (CITraceTypeFlow) {
1711     tty-&gt;print_cr(&quot;&gt;&gt; Created new block&quot;);
1712     print_on(tty);
1713   }
1714 
1715   assert(this-&gt;outer() == outer, &quot;outer link set up&quot;);
1716   assert(!outer-&gt;have_block_count(), &quot;must not have mapped blocks yet&quot;);
1717 }
1718 
1719 // ------------------------------------------------------------------
1720 // ciTypeFlow::Block::df_init
1721 void ciTypeFlow::Block::df_init() {
1722   _pre_order = -1; assert(!has_pre_order(), &quot;&quot;);
1723   _post_order = -1; assert(!has_post_order(), &quot;&quot;);
1724   _loop = NULL;
1725   _irreducible_entry = false;
1726   _rpo_next = NULL;
1727 }
1728 
1729 // ------------------------------------------------------------------
1730 // ciTypeFlow::Block::successors
1731 //
1732 // Get the successors for this Block.
1733 GrowableArray&lt;ciTypeFlow::Block*&gt;*
1734 ciTypeFlow::Block::successors(ciBytecodeStream* str,
1735                               ciTypeFlow::StateVector* state,
1736                               ciTypeFlow::JsrSet* jsrs) {
1737   if (_successors == NULL) {
1738     if (CITraceTypeFlow) {
1739       tty-&gt;print(&quot;&gt;&gt; Computing successors for block &quot;);
1740       print_value_on(tty);
1741       tty-&gt;cr();
1742     }
1743 
1744     ciTypeFlow* analyzer = outer();
1745     Arena* arena = analyzer-&gt;arena();
1746     Block* block = NULL;
1747     bool has_successor = !has_trap() &amp;&amp;
1748                          (control() != ciBlock::fall_through_bci || limit() &lt; analyzer-&gt;code_size());
1749     if (!has_successor) {
1750       _successors =
1751         new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1752       // No successors
1753     } else if (control() == ciBlock::fall_through_bci) {
1754       assert(str-&gt;cur_bci() == limit(), &quot;bad block end&quot;);
1755       // This block simply falls through to the next.
1756       _successors =
1757         new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1758 
1759       Block* block = analyzer-&gt;block_at(limit(), _jsrs);
1760       assert(_successors-&gt;length() == FALL_THROUGH, &quot;&quot;);
1761       _successors-&gt;append(block);
1762     } else {
1763       int current_bci = str-&gt;cur_bci();
1764       int next_bci = str-&gt;next_bci();
1765       int branch_bci = -1;
1766       Block* target = NULL;
1767       assert(str-&gt;next_bci() == limit(), &quot;bad block end&quot;);
1768       // This block is not a simple fall-though.  Interpret
1769       // the current bytecode to find our successors.
1770       switch (str-&gt;cur_bc()) {
1771       case Bytecodes::_ifeq:         case Bytecodes::_ifne:
1772       case Bytecodes::_iflt:         case Bytecodes::_ifge:
1773       case Bytecodes::_ifgt:         case Bytecodes::_ifle:
1774       case Bytecodes::_if_icmpeq:    case Bytecodes::_if_icmpne:
1775       case Bytecodes::_if_icmplt:    case Bytecodes::_if_icmpge:
1776       case Bytecodes::_if_icmpgt:    case Bytecodes::_if_icmple:
1777       case Bytecodes::_if_acmpeq:    case Bytecodes::_if_acmpne:
1778       case Bytecodes::_ifnull:       case Bytecodes::_ifnonnull:
1779         // Our successors are the branch target and the next bci.
1780         branch_bci = str-&gt;get_dest();
1781         _successors =
1782           new (arena) GrowableArray&lt;Block*&gt;(arena, 2, 0, NULL);
1783         assert(_successors-&gt;length() == IF_NOT_TAKEN, &quot;&quot;);
1784         _successors-&gt;append(analyzer-&gt;block_at(next_bci, jsrs));
1785         assert(_successors-&gt;length() == IF_TAKEN, &quot;&quot;);
1786         _successors-&gt;append(analyzer-&gt;block_at(branch_bci, jsrs));
1787         break;
1788 
1789       case Bytecodes::_goto:
1790         branch_bci = str-&gt;get_dest();
1791         _successors =
1792           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1793         assert(_successors-&gt;length() == GOTO_TARGET, &quot;&quot;);
1794         _successors-&gt;append(analyzer-&gt;block_at(branch_bci, jsrs));
1795         break;
1796 
1797       case Bytecodes::_jsr:
1798         branch_bci = str-&gt;get_dest();
1799         _successors =
1800           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1801         assert(_successors-&gt;length() == GOTO_TARGET, &quot;&quot;);
1802         _successors-&gt;append(analyzer-&gt;block_at(branch_bci, jsrs));
1803         break;
1804 
1805       case Bytecodes::_goto_w:
1806       case Bytecodes::_jsr_w:
1807         _successors =
1808           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1809         assert(_successors-&gt;length() == GOTO_TARGET, &quot;&quot;);
1810         _successors-&gt;append(analyzer-&gt;block_at(str-&gt;get_far_dest(), jsrs));
1811         break;
1812 
1813       case Bytecodes::_tableswitch:  {
1814         Bytecode_tableswitch tableswitch(str);
1815 
1816         int len = tableswitch.length();
1817         _successors =
1818           new (arena) GrowableArray&lt;Block*&gt;(arena, len+1, 0, NULL);
1819         int bci = current_bci + tableswitch.default_offset();
1820         Block* block = analyzer-&gt;block_at(bci, jsrs);
1821         assert(_successors-&gt;length() == SWITCH_DEFAULT, &quot;&quot;);
1822         _successors-&gt;append(block);
1823         while (--len &gt;= 0) {
1824           int bci = current_bci + tableswitch.dest_offset_at(len);
1825           block = analyzer-&gt;block_at(bci, jsrs);
1826           assert(_successors-&gt;length() &gt;= SWITCH_CASES, &quot;&quot;);
1827           _successors-&gt;append_if_missing(block);
1828         }
1829         break;
1830       }
1831 
1832       case Bytecodes::_lookupswitch: {
1833         Bytecode_lookupswitch lookupswitch(str);
1834 
1835         int npairs = lookupswitch.number_of_pairs();
1836         _successors =
1837           new (arena) GrowableArray&lt;Block*&gt;(arena, npairs+1, 0, NULL);
1838         int bci = current_bci + lookupswitch.default_offset();
1839         Block* block = analyzer-&gt;block_at(bci, jsrs);
1840         assert(_successors-&gt;length() == SWITCH_DEFAULT, &quot;&quot;);
1841         _successors-&gt;append(block);
1842         while(--npairs &gt;= 0) {
1843           LookupswitchPair pair = lookupswitch.pair_at(npairs);
1844           int bci = current_bci + pair.offset();
1845           Block* block = analyzer-&gt;block_at(bci, jsrs);
1846           assert(_successors-&gt;length() &gt;= SWITCH_CASES, &quot;&quot;);
1847           _successors-&gt;append_if_missing(block);
1848         }
1849         break;
1850       }
1851 
1852       case Bytecodes::_athrow:
1853       case Bytecodes::_ireturn:
1854       case Bytecodes::_lreturn:
1855       case Bytecodes::_freturn:
1856       case Bytecodes::_dreturn:
1857       case Bytecodes::_areturn:
1858       case Bytecodes::_return:
1859         _successors =
1860           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1861         // No successors
1862         break;
1863 
1864       case Bytecodes::_ret: {
1865         _successors =
1866           new (arena) GrowableArray&lt;Block*&gt;(arena, 1, 0, NULL);
1867 
1868         Cell local = state-&gt;local(str-&gt;get_index());
1869         ciType* return_address = state-&gt;type_at(local);
1870         assert(return_address-&gt;is_return_address(), &quot;verify: wrong type&quot;);
1871         int bci = return_address-&gt;as_return_address()-&gt;bci();
1872         assert(_successors-&gt;length() == GOTO_TARGET, &quot;&quot;);
1873         _successors-&gt;append(analyzer-&gt;block_at(bci, jsrs));
1874         break;
1875       }
1876 
1877       case Bytecodes::_wide:
1878       default:
1879         ShouldNotReachHere();
1880         break;
1881       }
1882     }
1883 
1884     // Set predecessor information
1885     for (int i = 0; i &lt; _successors-&gt;length(); i++) {
1886       Block* block = _successors-&gt;at(i);
1887       block-&gt;predecessors()-&gt;append(this);
1888     }
1889   }
1890   return _successors;
1891 }
1892 
1893 // ------------------------------------------------------------------
1894 // ciTypeFlow::Block:compute_exceptions
1895 //
1896 // Compute the exceptional successors and types for this Block.
1897 void ciTypeFlow::Block::compute_exceptions() {
1898   assert(_exceptions == NULL &amp;&amp; _exc_klasses == NULL, &quot;repeat&quot;);
1899 
1900   if (CITraceTypeFlow) {
1901     tty-&gt;print(&quot;&gt;&gt; Computing exceptions for block &quot;);
1902     print_value_on(tty);
1903     tty-&gt;cr();
1904   }
1905 
1906   ciTypeFlow* analyzer = outer();
1907   Arena* arena = analyzer-&gt;arena();
1908 
1909   // Any bci in the block will do.
1910   ciExceptionHandlerStream str(analyzer-&gt;method(), start());
1911 
1912   // Allocate our growable arrays.
1913   int exc_count = str.count();
1914   _exceptions = new (arena) GrowableArray&lt;Block*&gt;(arena, exc_count, 0, NULL);
1915   _exc_klasses = new (arena) GrowableArray&lt;ciInstanceKlass*&gt;(arena, exc_count,
1916                                                              0, NULL);
1917 
1918   for ( ; !str.is_done(); str.next()) {
1919     ciExceptionHandler* handler = str.handler();
1920     int bci = handler-&gt;handler_bci();
1921     ciInstanceKlass* klass = NULL;
1922     if (bci == -1) {
1923       // There is no catch all.  It is possible to exit the method.
1924       break;
1925     }
1926     if (handler-&gt;is_catch_all()) {
1927       klass = analyzer-&gt;env()-&gt;Throwable_klass();
1928     } else {
1929       klass = handler-&gt;catch_klass();
1930     }
1931     Block* block = analyzer-&gt;block_at(bci, _jsrs);
1932     _exceptions-&gt;append(block);
1933     block-&gt;predecessors()-&gt;append(this);
1934     _exc_klasses-&gt;append(klass);
1935   }
1936 }
1937 
1938 // ------------------------------------------------------------------
1939 // ciTypeFlow::Block::set_backedge_copy
1940 // Use this only to make a pre-existing public block into a backedge copy.
1941 void ciTypeFlow::Block::set_backedge_copy(bool z) {
1942   assert(z || (z == is_backedge_copy()), &quot;cannot make a backedge copy public&quot;);
1943   _backedge_copy = z;
1944 }
1945 
1946 // ------------------------------------------------------------------
1947 // ciTypeFlow::Block::is_clonable_exit
1948 //
1949 // At most 2 normal successors, one of which continues looping,
1950 // and all exceptional successors must exit.
1951 bool ciTypeFlow::Block::is_clonable_exit(ciTypeFlow::Loop* lp) {
1952   int normal_cnt  = 0;
1953   int in_loop_cnt = 0;
1954   for (SuccIter iter(this); !iter.done(); iter.next()) {
1955     Block* succ = iter.succ();
1956     if (iter.is_normal_ctrl()) {
1957       if (++normal_cnt &gt; 2) return false;
1958       if (lp-&gt;contains(succ-&gt;loop())) {
1959         if (++in_loop_cnt &gt; 1) return false;
1960       }
1961     } else {
1962       if (lp-&gt;contains(succ-&gt;loop())) return false;
1963     }
1964   }
1965   return in_loop_cnt == 1;
1966 }
1967 
1968 // ------------------------------------------------------------------
1969 // ciTypeFlow::Block::looping_succ
1970 //
1971 ciTypeFlow::Block* ciTypeFlow::Block::looping_succ(ciTypeFlow::Loop* lp) {
1972   assert(successors()-&gt;length() &lt;= 2, &quot;at most 2 normal successors&quot;);
1973   for (SuccIter iter(this); !iter.done(); iter.next()) {
1974     Block* succ = iter.succ();
1975     if (lp-&gt;contains(succ-&gt;loop())) {
1976       return succ;
1977     }
1978   }
1979   return NULL;
1980 }
1981 
1982 #ifndef PRODUCT
1983 // ------------------------------------------------------------------
1984 // ciTypeFlow::Block::print_value_on
1985 void ciTypeFlow::Block::print_value_on(outputStream* st) const {
1986   if (has_pre_order()) st-&gt;print(&quot;#%-2d &quot;, pre_order());
1987   if (has_rpo())       st-&gt;print(&quot;rpo#%-2d &quot;, rpo());
1988   st-&gt;print(&quot;[%d - %d)&quot;, start(), limit());
1989   if (is_loop_head()) st-&gt;print(&quot; lphd&quot;);
1990   if (is_irreducible_entry()) st-&gt;print(&quot; irred&quot;);
1991   if (_jsrs-&gt;size() &gt; 0) { st-&gt;print(&quot;/&quot;);  _jsrs-&gt;print_on(st); }
1992   if (is_backedge_copy())  st-&gt;print(&quot;/backedge_copy&quot;);
1993 }
1994 
1995 // ------------------------------------------------------------------
1996 // ciTypeFlow::Block::print_on
1997 void ciTypeFlow::Block::print_on(outputStream* st) const {
1998   if ((Verbose || WizardMode) &amp;&amp; (limit() &gt;= 0)) {
1999     // Don&#39;t print &#39;dummy&#39; blocks (i.e. blocks with limit() &#39;-1&#39;)
2000     outer()-&gt;method()-&gt;print_codes_on(start(), limit(), st);
2001   }
2002   st-&gt;print_cr(&quot;  ====================================================  &quot;);
2003   st-&gt;print (&quot;  &quot;);
2004   print_value_on(st);
2005   st-&gt;print(&quot; Stored locals: &quot;); def_locals()-&gt;print_on(st, outer()-&gt;method()-&gt;max_locals()); tty-&gt;cr();
2006   if (loop() &amp;&amp; loop()-&gt;parent() != NULL) {
2007     st-&gt;print(&quot; loops:&quot;);
2008     Loop* lp = loop();
2009     do {
2010       st-&gt;print(&quot; %d&lt;-%d&quot;, lp-&gt;head()-&gt;pre_order(),lp-&gt;tail()-&gt;pre_order());
2011       if (lp-&gt;is_irreducible()) st-&gt;print(&quot;(ir)&quot;);
2012       lp = lp-&gt;parent();
2013     } while (lp-&gt;parent() != NULL);
2014   }
2015   st-&gt;cr();
2016   _state-&gt;print_on(st);
2017   if (_successors == NULL) {
2018     st-&gt;print_cr(&quot;  No successor information&quot;);
2019   } else {
2020     int num_successors = _successors-&gt;length();
2021     st-&gt;print_cr(&quot;  Successors : %d&quot;, num_successors);
2022     for (int i = 0; i &lt; num_successors; i++) {
2023       Block* successor = _successors-&gt;at(i);
2024       st-&gt;print(&quot;    &quot;);
2025       successor-&gt;print_value_on(st);
2026       st-&gt;cr();
2027     }
2028   }
2029   if (_predecessors == NULL) {
2030     st-&gt;print_cr(&quot;  No predecessor information&quot;);
2031   } else {
2032     int num_predecessors = _predecessors-&gt;length();
2033     st-&gt;print_cr(&quot;  Predecessors : %d&quot;, num_predecessors);
2034     for (int i = 0; i &lt; num_predecessors; i++) {
2035       Block* predecessor = _predecessors-&gt;at(i);
2036       st-&gt;print(&quot;    &quot;);
2037       predecessor-&gt;print_value_on(st);
2038       st-&gt;cr();
2039     }
2040   }
2041   if (_exceptions == NULL) {
2042     st-&gt;print_cr(&quot;  No exception information&quot;);
2043   } else {
2044     int num_exceptions = _exceptions-&gt;length();
2045     st-&gt;print_cr(&quot;  Exceptions : %d&quot;, num_exceptions);
2046     for (int i = 0; i &lt; num_exceptions; i++) {
2047       Block* exc_succ = _exceptions-&gt;at(i);
2048       ciInstanceKlass* exc_klass = _exc_klasses-&gt;at(i);
2049       st-&gt;print(&quot;    &quot;);
2050       exc_succ-&gt;print_value_on(st);
2051       st-&gt;print(&quot; -- &quot;);
2052       exc_klass-&gt;name()-&gt;print_symbol_on(st);
2053       st-&gt;cr();
2054     }
2055   }
2056   if (has_trap()) {
2057     st-&gt;print_cr(&quot;  Traps on %d with trap index %d&quot;, trap_bci(), trap_index());
2058   }
2059   st-&gt;print_cr(&quot;  ====================================================  &quot;);
2060 }
2061 #endif
2062 
2063 #ifndef PRODUCT
2064 // ------------------------------------------------------------------
2065 // ciTypeFlow::LocalSet::print_on
2066 void ciTypeFlow::LocalSet::print_on(outputStream* st, int limit) const {
2067   st-&gt;print(&quot;{&quot;);
2068   for (int i = 0; i &lt; max; i++) {
2069     if (test(i)) st-&gt;print(&quot; %d&quot;, i);
2070   }
2071   if (limit &gt; max) {
2072     st-&gt;print(&quot; %d..%d &quot;, max, limit);
2073   }
2074   st-&gt;print(&quot; }&quot;);
2075 }
2076 #endif
2077 
2078 // ciTypeFlow
2079 //
2080 // This is a pass over the bytecodes which computes the following:
2081 //   basic block structure
2082 //   interpreter type-states (a la the verifier)
2083 
2084 // ------------------------------------------------------------------
2085 // ciTypeFlow::ciTypeFlow
2086 ciTypeFlow::ciTypeFlow(ciEnv* env, ciMethod* method, int osr_bci) {
2087   _env = env;
2088   _method = method;
2089   _methodBlocks = method-&gt;get_method_blocks();
2090   _max_locals = method-&gt;max_locals();
2091   _max_stack = method-&gt;max_stack();
2092   _code_size = method-&gt;code_size();
2093   _has_irreducible_entry = false;
2094   _osr_bci = osr_bci;
2095   _failure_reason = NULL;
2096   assert(0 &lt;= start_bci() &amp;&amp; start_bci() &lt; code_size() , &quot;correct osr_bci argument: 0 &lt;= %d &lt; %d&quot;, start_bci(), code_size());
2097   _work_list = NULL;
2098 
2099   _ciblock_count = _methodBlocks-&gt;num_blocks();
2100   _idx_to_blocklist = NEW_ARENA_ARRAY(arena(), GrowableArray&lt;Block*&gt;*, _ciblock_count);
2101   for (int i = 0; i &lt; _ciblock_count; i++) {
2102     _idx_to_blocklist[i] = NULL;
2103   }
2104   _block_map = NULL;  // until all blocks are seen
2105   _jsr_count = 0;
2106   _jsr_records = NULL;
2107 }
2108 
2109 // ------------------------------------------------------------------
2110 // ciTypeFlow::work_list_next
2111 //
2112 // Get the next basic block from our work list.
2113 ciTypeFlow::Block* ciTypeFlow::work_list_next() {
2114   assert(!work_list_empty(), &quot;work list must not be empty&quot;);
2115   Block* next_block = _work_list;
2116   _work_list = next_block-&gt;next();
2117   next_block-&gt;set_next(NULL);
2118   next_block-&gt;set_on_work_list(false);
2119   return next_block;
2120 }
2121 
2122 // ------------------------------------------------------------------
2123 // ciTypeFlow::add_to_work_list
2124 //
2125 // Add a basic block to our work list.
2126 // List is sorted by decreasing postorder sort (same as increasing RPO)
2127 void ciTypeFlow::add_to_work_list(ciTypeFlow::Block* block) {
2128   assert(!block-&gt;is_on_work_list(), &quot;must not already be on work list&quot;);
2129 
2130   if (CITraceTypeFlow) {
2131     tty-&gt;print(&quot;&gt;&gt; Adding block &quot;);
2132     block-&gt;print_value_on(tty);
2133     tty-&gt;print_cr(&quot; to the work list : &quot;);
2134   }
2135 
2136   block-&gt;set_on_work_list(true);
2137 
2138   // decreasing post order sort
2139 
2140   Block* prev = NULL;
2141   Block* current = _work_list;
2142   int po = block-&gt;post_order();
2143   while (current != NULL) {
2144     if (!current-&gt;has_post_order() || po &gt; current-&gt;post_order())
2145       break;
2146     prev = current;
2147     current = current-&gt;next();
2148   }
2149   if (prev == NULL) {
2150     block-&gt;set_next(_work_list);
2151     _work_list = block;
2152   } else {
2153     block-&gt;set_next(current);
2154     prev-&gt;set_next(block);
2155   }
2156 
2157   if (CITraceTypeFlow) {
2158     tty-&gt;cr();
2159   }
2160 }
2161 
2162 // ------------------------------------------------------------------
2163 // ciTypeFlow::block_at
2164 //
2165 // Return the block beginning at bci which has a JsrSet compatible
2166 // with jsrs.
2167 ciTypeFlow::Block* ciTypeFlow::block_at(int bci, ciTypeFlow::JsrSet* jsrs, CreateOption option) {
2168   // First find the right ciBlock.
2169   if (CITraceTypeFlow) {
2170     tty-&gt;print(&quot;&gt;&gt; Requesting block for %d/&quot;, bci);
2171     jsrs-&gt;print_on(tty);
2172     tty-&gt;cr();
2173   }
2174 
2175   ciBlock* ciblk = _methodBlocks-&gt;block_containing(bci);
2176   assert(ciblk-&gt;start_bci() == bci, &quot;bad ciBlock boundaries&quot;);
2177   Block* block = get_block_for(ciblk-&gt;index(), jsrs, option);
2178 
2179   assert(block == NULL? (option == no_create): block-&gt;is_backedge_copy() == (option == create_backedge_copy), &quot;create option consistent with result&quot;);
2180 
2181   if (CITraceTypeFlow) {
2182     if (block != NULL) {
2183       tty-&gt;print(&quot;&gt;&gt; Found block &quot;);
2184       block-&gt;print_value_on(tty);
2185       tty-&gt;cr();
2186     } else {
2187       tty-&gt;print_cr(&quot;&gt;&gt; No such block.&quot;);
2188     }
2189   }
2190 
2191   return block;
2192 }
2193 
2194 // ------------------------------------------------------------------
2195 // ciTypeFlow::make_jsr_record
2196 //
2197 // Make a JsrRecord for a given (entry, return) pair, if such a record
2198 // does not already exist.
2199 ciTypeFlow::JsrRecord* ciTypeFlow::make_jsr_record(int entry_address,
2200                                                    int return_address) {
2201   if (_jsr_records == NULL) {
2202     _jsr_records = new (arena()) GrowableArray&lt;JsrRecord*&gt;(arena(),
2203                                                            _jsr_count,
2204                                                            0,
2205                                                            NULL);
2206   }
2207   JsrRecord* record = NULL;
2208   int len = _jsr_records-&gt;length();
2209   for (int i = 0; i &lt; len; i++) {
2210     JsrRecord* record = _jsr_records-&gt;at(i);
2211     if (record-&gt;entry_address() == entry_address &amp;&amp;
2212         record-&gt;return_address() == return_address) {
2213       return record;
2214     }
2215   }
2216 
2217   record = new (arena()) JsrRecord(entry_address, return_address);
2218   _jsr_records-&gt;append(record);
2219   return record;
2220 }
2221 
2222 // ------------------------------------------------------------------
2223 // ciTypeFlow::flow_exceptions
2224 //
2225 // Merge the current state into all exceptional successors at the
2226 // current point in the code.
2227 void ciTypeFlow::flow_exceptions(GrowableArray&lt;ciTypeFlow::Block*&gt;* exceptions,
2228                                  GrowableArray&lt;ciInstanceKlass*&gt;* exc_klasses,
2229                                  ciTypeFlow::StateVector* state) {
2230   int len = exceptions-&gt;length();
2231   assert(exc_klasses-&gt;length() == len, &quot;must have same length&quot;);
2232   for (int i = 0; i &lt; len; i++) {
2233     Block* block = exceptions-&gt;at(i);
2234     ciInstanceKlass* exception_klass = exc_klasses-&gt;at(i);
2235 
2236     if (!exception_klass-&gt;is_loaded()) {
2237       // Do not compile any code for unloaded exception types.
2238       // Following compiler passes are responsible for doing this also.
2239       continue;
2240     }
2241 
2242     if (block-&gt;meet_exception(exception_klass, state)) {
2243       // Block was modified and has PO.  Add it to the work list.
2244       if (block-&gt;has_post_order() &amp;&amp;
2245           !block-&gt;is_on_work_list()) {
2246         add_to_work_list(block);
2247       }
2248     }
2249   }
2250 }
2251 
2252 // ------------------------------------------------------------------
2253 // ciTypeFlow::flow_successors
2254 //
2255 // Merge the current state into all successors at the current point
2256 // in the code.
2257 void ciTypeFlow::flow_successors(GrowableArray&lt;ciTypeFlow::Block*&gt;* successors,
2258                                  ciTypeFlow::StateVector* state) {
2259   int len = successors-&gt;length();
2260   for (int i = 0; i &lt; len; i++) {
2261     Block* block = successors-&gt;at(i);
2262     if (block-&gt;meet(state)) {
2263       // Block was modified and has PO.  Add it to the work list.
2264       if (block-&gt;has_post_order() &amp;&amp;
2265           !block-&gt;is_on_work_list()) {
2266         add_to_work_list(block);
2267       }
2268     }
2269   }
2270 }
2271 
2272 // ------------------------------------------------------------------
2273 // ciTypeFlow::can_trap
2274 //
2275 // Tells if a given instruction is able to generate an exception edge.
2276 bool ciTypeFlow::can_trap(ciBytecodeStream&amp; str) {
2277   // Cf. GenerateOopMap::do_exception_edge.
2278   if (!Bytecodes::can_trap(str.cur_bc()))  return false;
2279 
2280   switch (str.cur_bc()) {
2281     // %%% FIXME: ldc of Class can generate an exception
2282     case Bytecodes::_ldc:
2283     case Bytecodes::_ldc_w:
2284     case Bytecodes::_ldc2_w:
2285     case Bytecodes::_aload_0:
2286       // These bytecodes can trap for rewriting.  We need to assume that
2287       // they do not throw exceptions to make the monitor analysis work.
2288       return false;
2289 
2290     case Bytecodes::_ireturn:
2291     case Bytecodes::_lreturn:
2292     case Bytecodes::_freturn:
2293     case Bytecodes::_dreturn:
2294     case Bytecodes::_areturn:
2295     case Bytecodes::_return:
2296       // We can assume the monitor stack is empty in this analysis.
2297       return false;
2298 
2299     case Bytecodes::_monitorexit:
2300       // We can assume monitors are matched in this analysis.
2301       return false;
2302 
2303     default:
2304       return true;
2305   }
2306 }
2307 
2308 // ------------------------------------------------------------------
2309 // ciTypeFlow::clone_loop_heads
2310 //
2311 // Clone the loop heads
2312 bool ciTypeFlow::clone_loop_heads(Loop* lp, StateVector* temp_vector, JsrSet* temp_set) {
2313   bool rslt = false;
2314   for (PreorderLoops iter(loop_tree_root()); !iter.done(); iter.next()) {
2315     lp = iter.current();
2316     Block* head = lp-&gt;head();
2317     if (lp == loop_tree_root() ||
2318         lp-&gt;is_irreducible() ||
2319         !head-&gt;is_clonable_exit(lp))
2320       continue;
2321 
2322     // Avoid BoxLock merge.
2323     if (EliminateNestedLocks &amp;&amp; head-&gt;has_monitorenter())
2324       continue;
2325 
2326     // check not already cloned
2327     if (head-&gt;backedge_copy_count() != 0)
2328       continue;
2329 
2330     // Don&#39;t clone head of OSR loop to get correct types in start block.
2331     if (is_osr_flow() &amp;&amp; head-&gt;start() == start_bci())
2332       continue;
2333 
2334     // check _no_ shared head below us
2335     Loop* ch;
2336     for (ch = lp-&gt;child(); ch != NULL &amp;&amp; ch-&gt;head() != head; ch = ch-&gt;sibling());
2337     if (ch != NULL)
2338       continue;
2339 
2340     // Clone head
2341     Block* new_head = head-&gt;looping_succ(lp);
2342     Block* clone = clone_loop_head(lp, temp_vector, temp_set);
2343     // Update lp&#39;s info
2344     clone-&gt;set_loop(lp);
2345     lp-&gt;set_head(new_head);
2346     lp-&gt;set_tail(clone);
2347     // And move original head into outer loop
2348     head-&gt;set_loop(lp-&gt;parent());
2349 
2350     rslt = true;
2351   }
2352   return rslt;
2353 }
2354 
2355 // ------------------------------------------------------------------
2356 // ciTypeFlow::clone_loop_head
2357 //
2358 // Clone lp&#39;s head and replace tail&#39;s successors with clone.
2359 //
2360 //  |
2361 //  v
2362 // head &lt;-&gt; body
2363 //  |
2364 //  v
2365 // exit
2366 //
2367 // new_head
2368 //
2369 //  |
2370 //  v
2371 // head ----------\
2372 //  |             |
2373 //  |             v
2374 //  |  clone &lt;-&gt; body
2375 //  |    |
2376 //  | /--/
2377 //  | |
2378 //  v v
2379 // exit
2380 //
2381 ciTypeFlow::Block* ciTypeFlow::clone_loop_head(Loop* lp, StateVector* temp_vector, JsrSet* temp_set) {
2382   Block* head = lp-&gt;head();
2383   Block* tail = lp-&gt;tail();
2384   if (CITraceTypeFlow) {
2385     tty-&gt;print(&quot;&gt;&gt; Requesting clone of loop head &quot;); head-&gt;print_value_on(tty);
2386     tty-&gt;print(&quot;  for predecessor &quot;);                tail-&gt;print_value_on(tty);
2387     tty-&gt;cr();
2388   }
2389   Block* clone = block_at(head-&gt;start(), head-&gt;jsrs(), create_backedge_copy);
2390   assert(clone-&gt;backedge_copy_count() == 1, &quot;one backedge copy for all back edges&quot;);
2391 
2392   assert(!clone-&gt;has_pre_order(), &quot;just created&quot;);
2393   clone-&gt;set_next_pre_order();
2394 
2395   // Insert clone after (orig) tail in reverse post order
2396   clone-&gt;set_rpo_next(tail-&gt;rpo_next());
2397   tail-&gt;set_rpo_next(clone);
2398 
2399   // tail-&gt;head becomes tail-&gt;clone
2400   for (SuccIter iter(tail); !iter.done(); iter.next()) {
2401     if (iter.succ() == head) {
2402       iter.set_succ(clone);
2403       // Update predecessor information
2404       head-&gt;predecessors()-&gt;remove(tail);
2405       clone-&gt;predecessors()-&gt;append(tail);
2406     }
2407   }
2408   flow_block(tail, temp_vector, temp_set);
2409   if (head == tail) {
2410     // For self-loops, clone-&gt;head becomes clone-&gt;clone
2411     flow_block(clone, temp_vector, temp_set);
2412     for (SuccIter iter(clone); !iter.done(); iter.next()) {
2413       if (iter.succ() == head) {
2414         iter.set_succ(clone);
2415         // Update predecessor information
2416         head-&gt;predecessors()-&gt;remove(clone);
2417         clone-&gt;predecessors()-&gt;append(clone);
2418         break;
2419       }
2420     }
2421   }
2422   flow_block(clone, temp_vector, temp_set);
2423 
2424   return clone;
2425 }
2426 
2427 // ------------------------------------------------------------------
2428 // ciTypeFlow::flow_block
2429 //
2430 // Interpret the effects of the bytecodes on the incoming state
2431 // vector of a basic block.  Push the changed state to succeeding
2432 // basic blocks.
2433 void ciTypeFlow::flow_block(ciTypeFlow::Block* block,
2434                             ciTypeFlow::StateVector* state,
2435                             ciTypeFlow::JsrSet* jsrs) {
2436   if (CITraceTypeFlow) {
2437     tty-&gt;print(&quot;\n&gt;&gt; ANALYZING BLOCK : &quot;);
2438     tty-&gt;cr();
2439     block-&gt;print_on(tty);
2440   }
2441   assert(block-&gt;has_pre_order(), &quot;pre-order is assigned before 1st flow&quot;);
2442 
2443   int start = block-&gt;start();
2444   int limit = block-&gt;limit();
2445   int control = block-&gt;control();
2446   if (control != ciBlock::fall_through_bci) {
2447     limit = control;
2448   }
2449 
2450   // Grab the state from the current block.
2451   block-&gt;copy_state_into(state);
2452   state-&gt;def_locals()-&gt;clear();
2453 
2454   GrowableArray&lt;Block*&gt;*           exceptions = block-&gt;exceptions();
2455   GrowableArray&lt;ciInstanceKlass*&gt;* exc_klasses = block-&gt;exc_klasses();
2456   bool has_exceptions = exceptions-&gt;length() &gt; 0;
2457 
2458   bool exceptions_used = false;
2459 
2460   ciBytecodeStream str(method());
2461   str.reset_to_bci(start);
2462   Bytecodes::Code code;
2463   while ((code = str.next()) != ciBytecodeStream::EOBC() &amp;&amp;
2464          str.cur_bci() &lt; limit) {
2465     // Check for exceptional control flow from this point.
2466     if (has_exceptions &amp;&amp; can_trap(str)) {
2467       flow_exceptions(exceptions, exc_klasses, state);
2468       exceptions_used = true;
2469     }
2470     // Apply the effects of the current bytecode to our state.
2471     bool res = state-&gt;apply_one_bytecode(&amp;str);
2472 
2473     // Watch for bailouts.
2474     if (failing())  return;
2475 
2476     if (str.cur_bc() == Bytecodes::_monitorenter) {
2477       block-&gt;set_has_monitorenter();
2478     }
2479 
2480     if (res) {
2481 
2482       // We have encountered a trap.  Record it in this block.
2483       block-&gt;set_trap(state-&gt;trap_bci(), state-&gt;trap_index());
2484 
2485       if (CITraceTypeFlow) {
2486         tty-&gt;print_cr(&quot;&gt;&gt; Found trap&quot;);
2487         block-&gt;print_on(tty);
2488       }
2489 
2490       // Save set of locals defined in this block
2491       block-&gt;def_locals()-&gt;add(state-&gt;def_locals());
2492 
2493       // Record (no) successors.
2494       block-&gt;successors(&amp;str, state, jsrs);
2495 
2496       assert(!has_exceptions || exceptions_used, &quot;Not removing exceptions&quot;);
2497 
2498       // Discontinue interpretation of this Block.
2499       return;
2500     }
2501   }
2502 
2503   GrowableArray&lt;Block*&gt;* successors = NULL;
2504   if (control != ciBlock::fall_through_bci) {
2505     // Check for exceptional control flow from this point.
2506     if (has_exceptions &amp;&amp; can_trap(str)) {
2507       flow_exceptions(exceptions, exc_klasses, state);
2508       exceptions_used = true;
2509     }
2510 
2511     // Fix the JsrSet to reflect effect of the bytecode.
2512     block-&gt;copy_jsrs_into(jsrs);
2513     jsrs-&gt;apply_control(this, &amp;str, state);
2514 
2515     // Find successor edges based on old state and new JsrSet.
2516     successors = block-&gt;successors(&amp;str, state, jsrs);
2517 
2518     // Apply the control changes to the state.
2519     state-&gt;apply_one_bytecode(&amp;str);
2520   } else {
2521     // Fall through control
2522     successors = block-&gt;successors(&amp;str, NULL, NULL);
2523   }
2524 
2525   // Save set of locals defined in this block
2526   block-&gt;def_locals()-&gt;add(state-&gt;def_locals());
2527 
2528   // Remove untaken exception paths
2529   if (!exceptions_used)
2530     exceptions-&gt;clear();
2531 
2532   // Pass our state to successors.
2533   flow_successors(successors, state);
2534 }
2535 
2536 // ------------------------------------------------------------------
2537 // ciTypeFlow::PreOrderLoops::next
2538 //
2539 // Advance to next loop tree using a preorder, left-to-right traversal.
2540 void ciTypeFlow::PreorderLoops::next() {
2541   assert(!done(), &quot;must not be done.&quot;);
2542   if (_current-&gt;child() != NULL) {
2543     _current = _current-&gt;child();
2544   } else if (_current-&gt;sibling() != NULL) {
2545     _current = _current-&gt;sibling();
2546   } else {
2547     while (_current != _root &amp;&amp; _current-&gt;sibling() == NULL) {
2548       _current = _current-&gt;parent();
2549     }
2550     if (_current == _root) {
2551       _current = NULL;
2552       assert(done(), &quot;must be done.&quot;);
2553     } else {
2554       assert(_current-&gt;sibling() != NULL, &quot;must be more to do&quot;);
2555       _current = _current-&gt;sibling();
2556     }
2557   }
2558 }
2559 
2560 // ------------------------------------------------------------------
2561 // ciTypeFlow::Loop::sorted_merge
2562 //
2563 // Merge the branch lp into this branch, sorting on the loop head
2564 // pre_orders. Returns the leaf of the merged branch.
2565 // Child and sibling pointers will be setup later.
2566 // Sort is (looking from leaf towards the root)
2567 //  descending on primary key: loop head&#39;s pre_order, and
2568 //  ascending  on secondary key: loop tail&#39;s pre_order.
2569 ciTypeFlow::Loop* ciTypeFlow::Loop::sorted_merge(Loop* lp) {
2570   Loop* leaf = this;
2571   Loop* prev = NULL;
2572   Loop* current = leaf;
2573   while (lp != NULL) {
2574     int lp_pre_order = lp-&gt;head()-&gt;pre_order();
2575     // Find insertion point for &quot;lp&quot;
2576     while (current != NULL) {
2577       if (current == lp)
2578         return leaf; // Already in list
2579       if (current-&gt;head()-&gt;pre_order() &lt; lp_pre_order)
2580         break;
2581       if (current-&gt;head()-&gt;pre_order() == lp_pre_order &amp;&amp;
2582           current-&gt;tail()-&gt;pre_order() &gt; lp-&gt;tail()-&gt;pre_order()) {
2583         break;
2584       }
2585       prev = current;
2586       current = current-&gt;parent();
2587     }
2588     Loop* next_lp = lp-&gt;parent(); // Save future list of items to insert
2589     // Insert lp before current
2590     lp-&gt;set_parent(current);
2591     if (prev != NULL) {
2592       prev-&gt;set_parent(lp);
2593     } else {
2594       leaf = lp;
2595     }
2596     prev = lp;     // Inserted item is new prev[ious]
2597     lp = next_lp;  // Next item to insert
2598   }
2599   return leaf;
2600 }
2601 
2602 // ------------------------------------------------------------------
2603 // ciTypeFlow::build_loop_tree
2604 //
2605 // Incrementally build loop tree.
2606 void ciTypeFlow::build_loop_tree(Block* blk) {
2607   assert(!blk-&gt;is_post_visited(), &quot;precondition&quot;);
2608   Loop* innermost = NULL; // merge of loop tree branches over all successors
2609 
2610   for (SuccIter iter(blk); !iter.done(); iter.next()) {
2611     Loop*  lp   = NULL;
2612     Block* succ = iter.succ();
2613     if (!succ-&gt;is_post_visited()) {
2614       // Found backedge since predecessor post visited, but successor is not
2615       assert(succ-&gt;pre_order() &lt;= blk-&gt;pre_order(), &quot;should be backedge&quot;);
2616 
2617       // Create a LoopNode to mark this loop.
2618       lp = new (arena()) Loop(succ, blk);
2619       if (succ-&gt;loop() == NULL)
2620         succ-&gt;set_loop(lp);
2621       // succ-&gt;loop will be updated to innermost loop on a later call, when blk==succ
2622 
2623     } else {  // Nested loop
2624       lp = succ-&gt;loop();
2625 
2626       // If succ is loop head, find outer loop.
2627       while (lp != NULL &amp;&amp; lp-&gt;head() == succ) {
2628         lp = lp-&gt;parent();
2629       }
2630       if (lp == NULL) {
2631         // Infinite loop, it&#39;s parent is the root
2632         lp = loop_tree_root();
2633       }
2634     }
2635 
2636     // Check for irreducible loop.
2637     // Successor has already been visited. If the successor&#39;s loop head
2638     // has already been post-visited, then this is another entry into the loop.
2639     while (lp-&gt;head()-&gt;is_post_visited() &amp;&amp; lp != loop_tree_root()) {
2640       _has_irreducible_entry = true;
2641       lp-&gt;set_irreducible(succ);
2642       if (!succ-&gt;is_on_work_list()) {
2643         // Assume irreducible entries need more data flow
2644         add_to_work_list(succ);
2645       }
2646       Loop* plp = lp-&gt;parent();
2647       if (plp == NULL) {
2648         // This only happens for some irreducible cases.  The parent
2649         // will be updated during a later pass.
2650         break;
2651       }
2652       lp = plp;
2653     }
2654 
2655     // Merge loop tree branch for all successors.
2656     innermost = innermost == NULL ? lp : innermost-&gt;sorted_merge(lp);
2657 
2658   } // end loop
2659 
2660   if (innermost == NULL) {
2661     assert(blk-&gt;successors()-&gt;length() == 0, &quot;CFG exit&quot;);
2662     blk-&gt;set_loop(loop_tree_root());
2663   } else if (innermost-&gt;head() == blk) {
2664     // If loop header, complete the tree pointers
2665     if (blk-&gt;loop() != innermost) {
2666 #ifdef ASSERT
2667       assert(blk-&gt;loop()-&gt;head() == innermost-&gt;head(), &quot;same head&quot;);
2668       Loop* dl;
2669       for (dl = innermost; dl != NULL &amp;&amp; dl != blk-&gt;loop(); dl = dl-&gt;parent());
2670       assert(dl == blk-&gt;loop(), &quot;blk-&gt;loop() already in innermost list&quot;);
2671 #endif
2672       blk-&gt;set_loop(innermost);
2673     }
2674     innermost-&gt;def_locals()-&gt;add(blk-&gt;def_locals());
2675     Loop* l = innermost;
2676     Loop* p = l-&gt;parent();
2677     while (p &amp;&amp; l-&gt;head() == blk) {
2678       l-&gt;set_sibling(p-&gt;child());  // Put self on parents &#39;next child&#39;
2679       p-&gt;set_child(l);             // Make self the first child of parent
2680       p-&gt;def_locals()-&gt;add(l-&gt;def_locals());
2681       l = p;                       // Walk up the parent chain
2682       p = l-&gt;parent();
2683     }
2684   } else {
2685     blk-&gt;set_loop(innermost);
2686     innermost-&gt;def_locals()-&gt;add(blk-&gt;def_locals());
2687   }
2688 }
2689 
2690 // ------------------------------------------------------------------
2691 // ciTypeFlow::Loop::contains
2692 //
2693 // Returns true if lp is nested loop.
2694 bool ciTypeFlow::Loop::contains(ciTypeFlow::Loop* lp) const {
2695   assert(lp != NULL, &quot;&quot;);
2696   if (this == lp || head() == lp-&gt;head()) return true;
2697   int depth1 = depth();
2698   int depth2 = lp-&gt;depth();
2699   if (depth1 &gt; depth2)
2700     return false;
2701   while (depth1 &lt; depth2) {
2702     depth2--;
2703     lp = lp-&gt;parent();
2704   }
2705   return this == lp;
2706 }
2707 
2708 // ------------------------------------------------------------------
2709 // ciTypeFlow::Loop::depth
2710 //
2711 // Loop depth
2712 int ciTypeFlow::Loop::depth() const {
2713   int dp = 0;
2714   for (Loop* lp = this-&gt;parent(); lp != NULL; lp = lp-&gt;parent())
2715     dp++;
2716   return dp;
2717 }
2718 
2719 #ifndef PRODUCT
2720 // ------------------------------------------------------------------
2721 // ciTypeFlow::Loop::print
2722 void ciTypeFlow::Loop::print(outputStream* st, int indent) const {
2723   for (int i = 0; i &lt; indent; i++) st-&gt;print(&quot; &quot;);
2724   st-&gt;print(&quot;%d&lt;-%d %s&quot;,
2725             is_root() ? 0 : this-&gt;head()-&gt;pre_order(),
2726             is_root() ? 0 : this-&gt;tail()-&gt;pre_order(),
2727             is_irreducible()?&quot; irr&quot;:&quot;&quot;);
2728   st-&gt;print(&quot; defs: &quot;);
2729   def_locals()-&gt;print_on(st, _head-&gt;outer()-&gt;method()-&gt;max_locals());
2730   st-&gt;cr();
2731   for (Loop* ch = child(); ch != NULL; ch = ch-&gt;sibling())
2732     ch-&gt;print(st, indent+2);
2733 }
2734 #endif
2735 
2736 // ------------------------------------------------------------------
2737 // ciTypeFlow::df_flow_types
2738 //
2739 // Perform the depth first type flow analysis. Helper for flow_types.
2740 void ciTypeFlow::df_flow_types(Block* start,
2741                                bool do_flow,
2742                                StateVector* temp_vector,
2743                                JsrSet* temp_set) {
2744   int dft_len = 100;
2745   GrowableArray&lt;Block*&gt; stk(dft_len);
2746 
2747   ciBlock* dummy = _methodBlocks-&gt;make_dummy_block();
2748   JsrSet* root_set = new JsrSet(NULL, 0);
2749   Block* root_head = new (arena()) Block(this, dummy, root_set);
2750   Block* root_tail = new (arena()) Block(this, dummy, root_set);
2751   root_head-&gt;set_pre_order(0);
2752   root_head-&gt;set_post_order(0);
2753   root_tail-&gt;set_pre_order(max_jint);
2754   root_tail-&gt;set_post_order(max_jint);
2755   set_loop_tree_root(new (arena()) Loop(root_head, root_tail));
2756 
2757   stk.push(start);
2758 
2759   _next_pre_order = 0;  // initialize pre_order counter
2760   _rpo_list = NULL;
2761   int next_po = 0;      // initialize post_order counter
2762 
2763   // Compute RPO and the control flow graph
2764   int size;
2765   while ((size = stk.length()) &gt; 0) {
2766     Block* blk = stk.top(); // Leave node on stack
2767     if (!blk-&gt;is_visited()) {
2768       // forward arc in graph
2769       assert (!blk-&gt;has_pre_order(), &quot;&quot;);
2770       blk-&gt;set_next_pre_order();
2771 
2772       if (_next_pre_order &gt;= (int)Compile::current()-&gt;max_node_limit() / 2) {
2773         // Too many basic blocks.  Bail out.
2774         // This can happen when try/finally constructs are nested to depth N,
2775         // and there is O(2**N) cloning of jsr bodies.  See bug 4697245!
2776         // &quot;MaxNodeLimit / 2&quot; is used because probably the parser will
2777         // generate at least twice that many nodes and bail out.
2778         record_failure(&quot;too many basic blocks&quot;);
2779         return;
2780       }
2781       if (do_flow) {
2782         flow_block(blk, temp_vector, temp_set);
2783         if (failing()) return; // Watch for bailouts.
2784       }
2785     } else if (!blk-&gt;is_post_visited()) {
2786       // cross or back arc
2787       for (SuccIter iter(blk); !iter.done(); iter.next()) {
2788         Block* succ = iter.succ();
2789         if (!succ-&gt;is_visited()) {
2790           stk.push(succ);
2791         }
2792       }
2793       if (stk.length() == size) {
2794         // There were no additional children, post visit node now
2795         stk.pop(); // Remove node from stack
2796 
2797         build_loop_tree(blk);
2798         blk-&gt;set_post_order(next_po++);   // Assign post order
2799         prepend_to_rpo_list(blk);
2800         assert(blk-&gt;is_post_visited(), &quot;&quot;);
2801 
2802         if (blk-&gt;is_loop_head() &amp;&amp; !blk-&gt;is_on_work_list()) {
2803           // Assume loop heads need more data flow
2804           add_to_work_list(blk);
2805         }
2806       }
2807     } else {
2808       stk.pop(); // Remove post-visited node from stack
2809     }
2810   }
2811 }
2812 
2813 // ------------------------------------------------------------------
2814 // ciTypeFlow::flow_types
2815 //
2816 // Perform the type flow analysis, creating and cloning Blocks as
2817 // necessary.
2818 void ciTypeFlow::flow_types() {
2819   ResourceMark rm;
2820   StateVector* temp_vector = new StateVector(this);
2821   JsrSet* temp_set = new JsrSet(NULL, 16);
2822 
2823   // Create the method entry block.
2824   Block* start = block_at(start_bci(), temp_set);
2825 
2826   // Load the initial state into it.
2827   const StateVector* start_state = get_start_state();
2828   if (failing())  return;
2829   start-&gt;meet(start_state);
2830 
2831   // Depth first visit
2832   df_flow_types(start, true /*do flow*/, temp_vector, temp_set);
2833 
2834   if (failing())  return;
2835   assert(_rpo_list == start, &quot;must be start&quot;);
2836 
2837   // Any loops found?
2838   if (loop_tree_root()-&gt;child() != NULL &amp;&amp;
2839       env()-&gt;comp_level() &gt;= CompLevel_full_optimization) {
2840       // Loop optimizations are not performed on Tier1 compiles.
2841 
2842     bool changed = clone_loop_heads(loop_tree_root(), temp_vector, temp_set);
2843 
2844     // If some loop heads were cloned, recompute postorder and loop tree
2845     if (changed) {
2846       loop_tree_root()-&gt;set_child(NULL);
2847       for (Block* blk = _rpo_list; blk != NULL;) {
2848         Block* next = blk-&gt;rpo_next();
2849         blk-&gt;df_init();
2850         blk = next;
2851       }
2852       df_flow_types(start, false /*no flow*/, temp_vector, temp_set);
2853     }
2854   }
2855 
2856   if (CITraceTypeFlow) {
2857     tty-&gt;print_cr(&quot;\nLoop tree&quot;);
2858     loop_tree_root()-&gt;print();
2859   }
2860 
2861   // Continue flow analysis until fixed point reached
2862 
2863   debug_only(int max_block = _next_pre_order;)
2864 
2865   while (!work_list_empty()) {
2866     Block* blk = work_list_next();
2867     assert (blk-&gt;has_post_order(), &quot;post order assigned above&quot;);
2868 
2869     flow_block(blk, temp_vector, temp_set);
2870 
2871     assert (max_block == _next_pre_order, &quot;no new blocks&quot;);
2872     assert (!failing(), &quot;no more bailouts&quot;);
2873   }
2874 }
2875 
2876 // ------------------------------------------------------------------
2877 // ciTypeFlow::map_blocks
2878 //
2879 // Create the block map, which indexes blocks in reverse post-order.
2880 void ciTypeFlow::map_blocks() {
2881   assert(_block_map == NULL, &quot;single initialization&quot;);
2882   int block_ct = _next_pre_order;
2883   _block_map = NEW_ARENA_ARRAY(arena(), Block*, block_ct);
2884   assert(block_ct == block_count(), &quot;&quot;);
2885 
2886   Block* blk = _rpo_list;
2887   for (int m = 0; m &lt; block_ct; m++) {
2888     int rpo = blk-&gt;rpo();
2889     assert(rpo == m, &quot;should be sequential&quot;);
2890     _block_map[rpo] = blk;
2891     blk = blk-&gt;rpo_next();
2892   }
2893   assert(blk == NULL, &quot;should be done&quot;);
2894 
2895   for (int j = 0; j &lt; block_ct; j++) {
2896     assert(_block_map[j] != NULL, &quot;must not drop any blocks&quot;);
2897     Block* block = _block_map[j];
2898     // Remove dead blocks from successor lists:
2899     for (int e = 0; e &lt;= 1; e++) {
2900       GrowableArray&lt;Block*&gt;* l = e? block-&gt;exceptions(): block-&gt;successors();
2901       for (int k = 0; k &lt; l-&gt;length(); k++) {
2902         Block* s = l-&gt;at(k);
2903         if (!s-&gt;has_post_order()) {
2904           if (CITraceTypeFlow) {
2905             tty-&gt;print(&quot;Removing dead %s successor of #%d: &quot;, (e? &quot;exceptional&quot;:  &quot;normal&quot;), block-&gt;pre_order());
2906             s-&gt;print_value_on(tty);
2907             tty-&gt;cr();
2908           }
2909           l-&gt;remove(s);
2910           --k;
2911         }
2912       }
2913     }
2914   }
2915 }
2916 
2917 // ------------------------------------------------------------------
2918 // ciTypeFlow::get_block_for
2919 //
2920 // Find a block with this ciBlock which has a compatible JsrSet.
2921 // If no such block exists, create it, unless the option is no_create.
2922 // If the option is create_backedge_copy, always create a fresh backedge copy.
2923 ciTypeFlow::Block* ciTypeFlow::get_block_for(int ciBlockIndex, ciTypeFlow::JsrSet* jsrs, CreateOption option) {
2924   Arena* a = arena();
2925   GrowableArray&lt;Block*&gt;* blocks = _idx_to_blocklist[ciBlockIndex];
2926   if (blocks == NULL) {
2927     // Query only?
2928     if (option == no_create)  return NULL;
2929 
2930     // Allocate the growable array.
2931     blocks = new (a) GrowableArray&lt;Block*&gt;(a, 4, 0, NULL);
2932     _idx_to_blocklist[ciBlockIndex] = blocks;
2933   }
2934 
2935   if (option != create_backedge_copy) {
2936     int len = blocks-&gt;length();
2937     for (int i = 0; i &lt; len; i++) {
2938       Block* block = blocks-&gt;at(i);
2939       if (!block-&gt;is_backedge_copy() &amp;&amp; block-&gt;is_compatible_with(jsrs)) {
2940         return block;
2941       }
2942     }
2943   }
2944 
2945   // Query only?
2946   if (option == no_create)  return NULL;
2947 
2948   // We did not find a compatible block.  Create one.
2949   Block* new_block = new (a) Block(this, _methodBlocks-&gt;block(ciBlockIndex), jsrs);
2950   if (option == create_backedge_copy)  new_block-&gt;set_backedge_copy(true);
2951   blocks-&gt;append(new_block);
2952   return new_block;
2953 }
2954 
2955 // ------------------------------------------------------------------
2956 // ciTypeFlow::backedge_copy_count
2957 //
2958 int ciTypeFlow::backedge_copy_count(int ciBlockIndex, ciTypeFlow::JsrSet* jsrs) const {
2959   GrowableArray&lt;Block*&gt;* blocks = _idx_to_blocklist[ciBlockIndex];
2960 
2961   if (blocks == NULL) {
2962     return 0;
2963   }
2964 
2965   int count = 0;
2966   int len = blocks-&gt;length();
2967   for (int i = 0; i &lt; len; i++) {
2968     Block* block = blocks-&gt;at(i);
2969     if (block-&gt;is_backedge_copy() &amp;&amp; block-&gt;is_compatible_with(jsrs)) {
2970       count++;
2971     }
2972   }
2973 
2974   return count;
2975 }
2976 
2977 // ------------------------------------------------------------------
2978 // ciTypeFlow::do_flow
2979 //
2980 // Perform type inference flow analysis.
2981 void ciTypeFlow::do_flow() {
2982   if (CITraceTypeFlow) {
2983     tty-&gt;print_cr(&quot;\nPerforming flow analysis on method&quot;);
2984     method()-&gt;print();
2985     if (is_osr_flow())  tty-&gt;print(&quot; at OSR bci %d&quot;, start_bci());
2986     tty-&gt;cr();
2987     method()-&gt;print_codes();
2988   }
2989   if (CITraceTypeFlow) {
2990     tty-&gt;print_cr(&quot;Initial CI Blocks&quot;);
2991     print_on(tty);
2992   }
2993   flow_types();
2994   // Watch for bailouts.
2995   if (failing()) {
2996     return;
2997   }
2998 
2999   map_blocks();
3000 
3001   if (CIPrintTypeFlow || CITraceTypeFlow) {
3002     rpo_print_on(tty);
3003   }
3004 }
3005 
3006 // ------------------------------------------------------------------
3007 // ciTypeFlow::is_dominated_by
3008 //
3009 // Determine if the instruction at bci is dominated by the instruction at dom_bci.
3010 bool ciTypeFlow::is_dominated_by(int bci, int dom_bci) {
3011   assert(!method()-&gt;has_jsrs(), &quot;jsrs are not supported&quot;);
3012 
3013   ResourceMark rm;
3014   JsrSet* jsrs = new ciTypeFlow::JsrSet(NULL);
3015   int        index = _methodBlocks-&gt;block_containing(bci)-&gt;index();
3016   int    dom_index = _methodBlocks-&gt;block_containing(dom_bci)-&gt;index();
3017   Block*     block = get_block_for(index, jsrs, ciTypeFlow::no_create);
3018   Block* dom_block = get_block_for(dom_index, jsrs, ciTypeFlow::no_create);
3019 
3020   // Start block dominates all other blocks
3021   if (start_block()-&gt;rpo() == dom_block-&gt;rpo()) {
3022     return true;
3023   }
3024 
3025   // Dominated[i] is true if block i is dominated by dom_block
3026   int num_blocks = block_count();
3027   bool* dominated = NEW_RESOURCE_ARRAY(bool, num_blocks);
3028   for (int i = 0; i &lt; num_blocks; ++i) {
3029     dominated[i] = true;
3030   }
3031   dominated[start_block()-&gt;rpo()] = false;
3032 
3033   // Iterative dominator algorithm
3034   bool changed = true;
3035   while (changed) {
3036     changed = false;
3037     // Use reverse postorder iteration
3038     for (Block* blk = _rpo_list; blk != NULL; blk = blk-&gt;rpo_next()) {
3039       if (blk-&gt;is_start()) {
3040         // Ignore start block
3041         continue;
3042       }
3043       // The block is dominated if it is the dominating block
3044       // itself or if all predecessors are dominated.
3045       int index = blk-&gt;rpo();
3046       bool dom = (index == dom_block-&gt;rpo());
3047       if (!dom) {
3048         // Check if all predecessors are dominated
3049         dom = true;
3050         for (int i = 0; i &lt; blk-&gt;predecessors()-&gt;length(); ++i) {
3051           Block* pred = blk-&gt;predecessors()-&gt;at(i);
3052           if (!dominated[pred-&gt;rpo()]) {
3053             dom = false;
3054             break;
3055           }
3056         }
3057       }
3058       // Update dominator information
3059       if (dominated[index] != dom) {
3060         changed = true;
3061         dominated[index] = dom;
3062       }
3063     }
3064   }
3065   // block dominated by dom_block?
3066   return dominated[block-&gt;rpo()];
3067 }
3068 
3069 // ------------------------------------------------------------------
3070 // ciTypeFlow::record_failure()
3071 // The ciTypeFlow object keeps track of failure reasons separately from the ciEnv.
3072 // This is required because there is not a 1-1 relation between the ciEnv and
3073 // the TypeFlow passes within a compilation task.  For example, if the compiler
3074 // is considering inlining a method, it will request a TypeFlow.  If that fails,
3075 // the compilation as a whole may continue without the inlining.  Some TypeFlow
3076 // requests are not optional; if they fail the requestor is responsible for
3077 // copying the failure reason up to the ciEnv.  (See Parse::Parse.)
3078 void ciTypeFlow::record_failure(const char* reason) {
3079   if (env()-&gt;log() != NULL) {
3080     env()-&gt;log()-&gt;elem(&quot;failure reason=&#39;%s&#39; phase=&#39;typeflow&#39;&quot;, reason);
3081   }
3082   if (_failure_reason == NULL) {
3083     // Record the first failure reason.
3084     _failure_reason = reason;
3085   }
3086 }
3087 
3088 ciType* ciTypeFlow::mark_as_never_null(ciType* type) {
3089   // Wrap the type to carry the information that it is never null
3090   return env()-&gt;make_never_null_wrapper(type);
3091 }
3092 
3093 #ifndef PRODUCT
3094 // ------------------------------------------------------------------
3095 // ciTypeFlow::print_on
3096 void ciTypeFlow::print_on(outputStream* st) const {
3097   // Walk through CI blocks
3098   st-&gt;print_cr(&quot;********************************************************&quot;);
3099   st-&gt;print   (&quot;TypeFlow for &quot;);
3100   method()-&gt;name()-&gt;print_symbol_on(st);
3101   int limit_bci = code_size();
3102   st-&gt;print_cr(&quot;  %d bytes&quot;, limit_bci);
3103   ciMethodBlocks  *mblks = _methodBlocks;
3104   ciBlock* current = NULL;
3105   for (int bci = 0; bci &lt; limit_bci; bci++) {
3106     ciBlock* blk = mblks-&gt;block_containing(bci);
3107     if (blk != NULL &amp;&amp; blk != current) {
3108       current = blk;
3109       current-&gt;print_on(st);
3110 
3111       GrowableArray&lt;Block*&gt;* blocks = _idx_to_blocklist[blk-&gt;index()];
3112       int num_blocks = (blocks == NULL) ? 0 : blocks-&gt;length();
3113 
3114       if (num_blocks == 0) {
3115         st-&gt;print_cr(&quot;  No Blocks&quot;);
3116       } else {
3117         for (int i = 0; i &lt; num_blocks; i++) {
3118           Block* block = blocks-&gt;at(i);
3119           block-&gt;print_on(st);
3120         }
3121       }
3122       st-&gt;print_cr(&quot;--------------------------------------------------------&quot;);
3123       st-&gt;cr();
3124     }
3125   }
3126   st-&gt;print_cr(&quot;********************************************************&quot;);
3127   st-&gt;cr();
3128 }
3129 
3130 void ciTypeFlow::rpo_print_on(outputStream* st) const {
3131   st-&gt;print_cr(&quot;********************************************************&quot;);
3132   st-&gt;print   (&quot;TypeFlow for &quot;);
3133   method()-&gt;name()-&gt;print_symbol_on(st);
3134   int limit_bci = code_size();
3135   st-&gt;print_cr(&quot;  %d bytes&quot;, limit_bci);
3136   for (Block* blk = _rpo_list; blk != NULL; blk = blk-&gt;rpo_next()) {
3137     blk-&gt;print_on(st);
3138     st-&gt;print_cr(&quot;--------------------------------------------------------&quot;);
3139     st-&gt;cr();
3140   }
3141   st-&gt;print_cr(&quot;********************************************************&quot;);
3142   st-&gt;cr();
3143 }
3144 #endif
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
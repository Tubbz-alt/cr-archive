<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciTypeFlow.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciObjArrayKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciValueArrayKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciTypeFlow.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 306   }
 307 
 308   // Both types are non-top non-primitive types.  That is,
 309   // both types are either instanceKlasses or arrayKlasses.
 310   ciKlass* object_klass = analyzer-&gt;env()-&gt;Object_klass();
 311   ciKlass* k1 = t1-&gt;as_klass();
 312   ciKlass* k2 = t2-&gt;as_klass();
 313   if (k1-&gt;equals(object_klass) || k2-&gt;equals(object_klass)) {
 314     return object_klass;
 315   } else if (!k1-&gt;is_loaded() || !k2-&gt;is_loaded()) {
 316     // Unloaded classes fall to java.lang.Object at a merge.
 317     return object_klass;
 318   } else if (k1-&gt;is_interface() != k2-&gt;is_interface()) {
 319     // When an interface meets a non-interface, we get Object;
 320     // This is what the verifier does.
 321     return object_klass;
 322   } else if (k1-&gt;is_array_klass() || k2-&gt;is_array_klass()) {
 323     // When an array meets a non-array, we get Object.
 324     // When (obj/value)Array meets typeArray, we also get Object.
 325     // And when typeArray meets different typeArray, we again get Object.
<span class="line-modified"> 326     // But when (obj/value)Array meets (obj/value)Array, we look carefully at element types and storage properties.</span>
 327     if ((k1-&gt;is_obj_array_klass() || k1-&gt;is_value_array_klass()) &amp;&amp;
 328         (k2-&gt;is_obj_array_klass() || k2-&gt;is_value_array_klass())) {
<span class="line-removed"> 329       bool prop_mismatch = k1-&gt;as_array_klass()-&gt;storage_properties().value() !=</span>
<span class="line-removed"> 330                            k2-&gt;as_array_klass()-&gt;storage_properties().value();</span>
<span class="line-removed"> 331       bool never_null = k1-&gt;as_array_klass()-&gt;storage_properties().is_null_free() &amp;&amp;</span>
<span class="line-removed"> 332                         k2-&gt;as_array_klass()-&gt;storage_properties().is_null_free();</span>
 333       ciType* elem1 = k1-&gt;as_array_klass()-&gt;element_klass();
 334       ciType* elem2 = k2-&gt;as_array_klass()-&gt;element_klass();
 335       ciType* elem = elem1;
 336       if (elem1 != elem2) {
 337         elem = type_meet_internal(elem1, elem2, analyzer)-&gt;as_klass();
 338       }
 339       // Do an easy shortcut if one type is a super of the other.
<span class="line-modified"> 340       if (elem == elem1 &amp;&amp; !prop_mismatch) {</span>
<span class="line-modified"> 341         assert(k1 == ciArrayKlass::make(elem, never_null), &quot;shortcut is OK&quot;);</span>
 342         return k1;
<span class="line-modified"> 343       } else if (elem == elem2 &amp;&amp; !prop_mismatch) {</span>
<span class="line-modified"> 344         assert(k2 == ciArrayKlass::make(elem, never_null), &quot;shortcut is OK&quot;);</span>
 345         return k2;
 346       } else {
<span class="line-modified"> 347         return ciArrayKlass::make(elem, never_null);</span>
 348       }
 349     } else {
 350       return object_klass;
 351     }
 352   } else {
 353     // Must be two plain old instance klasses.
 354     assert(k1-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);
 355     assert(k2-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);
 356     ciType* result = k1-&gt;least_common_ancestor(k2);
 357     if (never_null1 &amp;&amp; never_null2 &amp;&amp; result-&gt;is_valuetype()) {
 358       // Both value types are never null, mark the result as never null
 359       result = analyzer-&gt;mark_as_never_null(result);
 360     }
 361     return result;
 362   }
 363 }
 364 
 365 
 366 // ------------------------------------------------------------------
 367 // ciTypeFlow::StateVector::StateVector
</pre>
<hr />
<pre>
 594     // (The compiler will generate an unconditional exception here.)
 595     push(null_type());
 596     return;
 597   }
 598   if (!array_klass-&gt;is_loaded()) {
 599     // Only fails for some -Xcomp runs
 600     trap(str, array_klass,
 601          Deoptimization::make_trap_request
 602          (Deoptimization::Reason_unloaded,
 603           Deoptimization::Action_reinterpret));
 604     return;
 605   }
 606   ciKlass* element_klass = array_klass-&gt;element_klass();
 607   if (!element_klass-&gt;is_loaded() &amp;&amp; element_klass-&gt;is_instance_klass()) {
 608     Untested(&quot;unloaded array element class in ciTypeFlow&quot;);
 609     trap(str, element_klass,
 610          Deoptimization::make_trap_request
 611          (Deoptimization::Reason_unloaded,
 612           Deoptimization::Action_reinterpret));
 613   } else {
<span class="line-modified"> 614     if (array_klass-&gt;storage_properties().is_null_free()) {</span>
 615       // Value type array elements are never null
<span class="line-removed"> 616       assert(element_klass-&gt;is_valuetype(), &quot;must be a value type array&quot;);</span>
 617       push(outer()-&gt;mark_as_never_null(element_klass));
 618     } else {
 619       push_object(element_klass);
 620     }
 621   }
 622 }
 623 
 624 
 625 // ------------------------------------------------------------------
 626 // ciTypeFlow::StateVector::do_checkcast
 627 void ciTypeFlow::StateVector::do_checkcast(ciBytecodeStream* str) {
 628   bool will_link;
 629   ciKlass* klass = str-&gt;get_klass(will_link);
 630   bool never_null = str-&gt;is_klass_never_null();
 631   if (!will_link) {
 632     if (never_null) {
 633       trap(str, klass,
 634            Deoptimization::make_trap_request
 635            (Deoptimization::Reason_unloaded,
 636             Deoptimization::Action_reinterpret));
</pre>
<hr />
<pre>
 985     }
 986   case Bytecodes::_aconst_null:
 987     {
 988       push_null();
 989       break;
 990     }
 991   case Bytecodes::_aload:   load_local_object(str-&gt;get_index());    break;
 992   case Bytecodes::_aload_0: load_local_object(0);                   break;
 993   case Bytecodes::_aload_1: load_local_object(1);                   break;
 994   case Bytecodes::_aload_2: load_local_object(2);                   break;
 995   case Bytecodes::_aload_3: load_local_object(3);                   break;
 996 
 997   case Bytecodes::_anewarray:
 998     {
 999       pop_int();
1000       bool will_link;
1001       ciKlass* element_klass = str-&gt;get_klass(will_link);
1002       if (!will_link) {
1003         trap(str, element_klass, str-&gt;get_klass_index());
1004       } else {
<span class="line-modified">1005         bool never_null = str-&gt;is_klass_never_null();</span>
<span class="line-removed">1006         push_object(ciArrayKlass::make(element_klass, never_null));</span>
1007       }
1008       break;
1009     }
1010   case Bytecodes::_areturn:
1011   case Bytecodes::_ifnonnull:
1012   case Bytecodes::_ifnull:
1013     {
1014       pop_object();
1015       break;
1016     }
1017   case Bytecodes::_monitorenter:
1018     {
1019       pop_object();
1020       set_monitor_count(monitor_count() + 1);
1021       break;
1022     }
1023   case Bytecodes::_monitorexit:
1024     {
1025       pop_object();
1026       assert(monitor_count() &gt; 0, &quot;must be a monitor to exit from&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 306   }
 307 
 308   // Both types are non-top non-primitive types.  That is,
 309   // both types are either instanceKlasses or arrayKlasses.
 310   ciKlass* object_klass = analyzer-&gt;env()-&gt;Object_klass();
 311   ciKlass* k1 = t1-&gt;as_klass();
 312   ciKlass* k2 = t2-&gt;as_klass();
 313   if (k1-&gt;equals(object_klass) || k2-&gt;equals(object_klass)) {
 314     return object_klass;
 315   } else if (!k1-&gt;is_loaded() || !k2-&gt;is_loaded()) {
 316     // Unloaded classes fall to java.lang.Object at a merge.
 317     return object_klass;
 318   } else if (k1-&gt;is_interface() != k2-&gt;is_interface()) {
 319     // When an interface meets a non-interface, we get Object;
 320     // This is what the verifier does.
 321     return object_klass;
 322   } else if (k1-&gt;is_array_klass() || k2-&gt;is_array_klass()) {
 323     // When an array meets a non-array, we get Object.
 324     // When (obj/value)Array meets typeArray, we also get Object.
 325     // And when typeArray meets different typeArray, we again get Object.
<span class="line-modified"> 326     // But when (obj/value)Array meets (obj/value)Array, we look carefully at element types.</span>
 327     if ((k1-&gt;is_obj_array_klass() || k1-&gt;is_value_array_klass()) &amp;&amp;
 328         (k2-&gt;is_obj_array_klass() || k2-&gt;is_value_array_klass())) {




 329       ciType* elem1 = k1-&gt;as_array_klass()-&gt;element_klass();
 330       ciType* elem2 = k2-&gt;as_array_klass()-&gt;element_klass();
 331       ciType* elem = elem1;
 332       if (elem1 != elem2) {
 333         elem = type_meet_internal(elem1, elem2, analyzer)-&gt;as_klass();
 334       }
 335       // Do an easy shortcut if one type is a super of the other.
<span class="line-modified"> 336       if (elem == elem1) {</span>
<span class="line-modified"> 337         assert(k1 == ciArrayKlass::make(elem), &quot;shortcut is OK&quot;);</span>
 338         return k1;
<span class="line-modified"> 339       } else if (elem == elem2) {</span>
<span class="line-modified"> 340         assert(k2 == ciArrayKlass::make(elem), &quot;shortcut is OK&quot;);</span>
 341         return k2;
 342       } else {
<span class="line-modified"> 343         return ciArrayKlass::make(elem);</span>
 344       }
 345     } else {
 346       return object_klass;
 347     }
 348   } else {
 349     // Must be two plain old instance klasses.
 350     assert(k1-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);
 351     assert(k2-&gt;is_instance_klass(), &quot;previous cases handle non-instances&quot;);
 352     ciType* result = k1-&gt;least_common_ancestor(k2);
 353     if (never_null1 &amp;&amp; never_null2 &amp;&amp; result-&gt;is_valuetype()) {
 354       // Both value types are never null, mark the result as never null
 355       result = analyzer-&gt;mark_as_never_null(result);
 356     }
 357     return result;
 358   }
 359 }
 360 
 361 
 362 // ------------------------------------------------------------------
 363 // ciTypeFlow::StateVector::StateVector
</pre>
<hr />
<pre>
 590     // (The compiler will generate an unconditional exception here.)
 591     push(null_type());
 592     return;
 593   }
 594   if (!array_klass-&gt;is_loaded()) {
 595     // Only fails for some -Xcomp runs
 596     trap(str, array_klass,
 597          Deoptimization::make_trap_request
 598          (Deoptimization::Reason_unloaded,
 599           Deoptimization::Action_reinterpret));
 600     return;
 601   }
 602   ciKlass* element_klass = array_klass-&gt;element_klass();
 603   if (!element_klass-&gt;is_loaded() &amp;&amp; element_klass-&gt;is_instance_klass()) {
 604     Untested(&quot;unloaded array element class in ciTypeFlow&quot;);
 605     trap(str, element_klass,
 606          Deoptimization::make_trap_request
 607          (Deoptimization::Reason_unloaded,
 608           Deoptimization::Action_reinterpret));
 609   } else {
<span class="line-modified"> 610     if (element_klass-&gt;is_valuetype()) {</span>
 611       // Value type array elements are never null

 612       push(outer()-&gt;mark_as_never_null(element_klass));
 613     } else {
 614       push_object(element_klass);
 615     }
 616   }
 617 }
 618 
 619 
 620 // ------------------------------------------------------------------
 621 // ciTypeFlow::StateVector::do_checkcast
 622 void ciTypeFlow::StateVector::do_checkcast(ciBytecodeStream* str) {
 623   bool will_link;
 624   ciKlass* klass = str-&gt;get_klass(will_link);
 625   bool never_null = str-&gt;is_klass_never_null();
 626   if (!will_link) {
 627     if (never_null) {
 628       trap(str, klass,
 629            Deoptimization::make_trap_request
 630            (Deoptimization::Reason_unloaded,
 631             Deoptimization::Action_reinterpret));
</pre>
<hr />
<pre>
 980     }
 981   case Bytecodes::_aconst_null:
 982     {
 983       push_null();
 984       break;
 985     }
 986   case Bytecodes::_aload:   load_local_object(str-&gt;get_index());    break;
 987   case Bytecodes::_aload_0: load_local_object(0);                   break;
 988   case Bytecodes::_aload_1: load_local_object(1);                   break;
 989   case Bytecodes::_aload_2: load_local_object(2);                   break;
 990   case Bytecodes::_aload_3: load_local_object(3);                   break;
 991 
 992   case Bytecodes::_anewarray:
 993     {
 994       pop_int();
 995       bool will_link;
 996       ciKlass* element_klass = str-&gt;get_klass(will_link);
 997       if (!will_link) {
 998         trap(str, element_klass, str-&gt;get_klass_index());
 999       } else {
<span class="line-modified">1000         push_object(ciArrayKlass::make(element_klass));</span>

1001       }
1002       break;
1003     }
1004   case Bytecodes::_areturn:
1005   case Bytecodes::_ifnonnull:
1006   case Bytecodes::_ifnull:
1007     {
1008       pop_object();
1009       break;
1010     }
1011   case Bytecodes::_monitorenter:
1012     {
1013       pop_object();
1014       set_monitor_count(monitor_count() + 1);
1015       break;
1016     }
1017   case Bytecodes::_monitorexit:
1018     {
1019       pop_object();
1020       assert(monitor_count() &gt; 0, &quot;must be a monitor to exit from&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="ciObjArrayKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciValueArrayKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/c1/c1_Instruction.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_IR.hpp&quot;
  27 #include &quot;c1/c1_Instruction.hpp&quot;
  28 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  29 #include &quot;c1/c1_ValueStack.hpp&quot;
  30 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  31 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  32 #include &quot;ci/ciValueArrayKlass.hpp&quot;
  33 #include &quot;ci/ciValueKlass.hpp&quot;
  34 #include &quot;utilities/bitMap.inline.hpp&quot;
  35 
  36 
  37 // Implementation of Instruction
  38 
  39 
  40 int Instruction::dominator_depth() {
  41   int result = -1;
  42   if (block()) {
  43     result = block()-&gt;dominator_depth();
  44   }
  45   assert(result != -1 || this-&gt;as_Local(), &quot;Only locals have dominator depth -1&quot;);
  46   return result;
  47 }
  48 
  49 Instruction::Condition Instruction::mirror(Condition cond) {
  50   switch (cond) {
  51     case eql: return eql;
  52     case neq: return neq;
  53     case lss: return gtr;
  54     case leq: return geq;
  55     case gtr: return lss;
  56     case geq: return leq;
  57     case aeq: return beq;
  58     case beq: return aeq;
  59   }
  60   ShouldNotReachHere();
  61   return eql;
  62 }
  63 
  64 
  65 Instruction::Condition Instruction::negate(Condition cond) {
  66   switch (cond) {
  67     case eql: return neq;
  68     case neq: return eql;
  69     case lss: return geq;
  70     case leq: return gtr;
  71     case gtr: return leq;
  72     case geq: return lss;
  73     case aeq: assert(false, &quot;Above equal cannot be negated&quot;);
  74     case beq: assert(false, &quot;Below equal cannot be negated&quot;);
  75   }
  76   ShouldNotReachHere();
  77   return eql;
  78 }
  79 
  80 void Instruction::update_exception_state(ValueStack* state) {
  81   if (state != NULL &amp;&amp; (state-&gt;kind() == ValueStack::EmptyExceptionState || state-&gt;kind() == ValueStack::ExceptionState)) {
  82     assert(state-&gt;kind() == ValueStack::EmptyExceptionState || Compilation::current()-&gt;env()-&gt;should_retain_local_variables(), &quot;unexpected state kind&quot;);
  83     _exception_state = state;
  84   } else {
  85     _exception_state = NULL;
  86   }
  87 }
  88 
  89 // Prev without need to have BlockBegin
  90 Instruction* Instruction::prev() {
  91   Instruction* p = NULL;
  92   Instruction* q = block();
  93   while (q != this) {
  94     assert(q != NULL, &quot;this is not in the block&#39;s instruction list&quot;);
  95     p = q; q = q-&gt;next();
  96   }
  97   return p;
  98 }
  99 
 100 
 101 void Instruction::state_values_do(ValueVisitor* f) {
 102   if (state_before() != NULL) {
 103     state_before()-&gt;values_do(f);
 104   }
 105   if (exception_state() != NULL){
 106     exception_state()-&gt;values_do(f);
 107   }
 108 }
 109 
 110 ciType* Instruction::exact_type() const {
 111   ciType* t =  declared_type();
 112   if (t != NULL &amp;&amp; t-&gt;is_klass()) {
 113     return t-&gt;as_klass()-&gt;exact_klass();
 114   }
 115   return NULL;
 116 }
 117 
 118 ciKlass* Instruction::as_loaded_klass_or_null() const {
 119   ciType* type = declared_type();
 120   if (type != NULL &amp;&amp; type-&gt;is_klass()) {
 121     ciKlass* klass = type-&gt;as_klass();
 122     if (klass-&gt;is_loaded()) {
 123       return klass;
 124     }
 125   }
 126   return NULL;
 127 }
 128 
 129 bool Instruction::is_loaded_flattened_array() const {
 130   if (ValueArrayFlatten) {
 131     ciType* type = declared_type();
 132     if (type != NULL &amp;&amp; type-&gt;is_value_array_klass()) {
 133       ciValueArrayKlass* vak = type-&gt;as_value_array_klass();
 134       ArrayStorageProperties props = vak-&gt;storage_properties();
 135       return (!props.is_empty() &amp;&amp; props.is_null_free() &amp;&amp; props.is_flattened());
 136     }
 137   }
 138 
 139   return false;
 140 }
 141 
 142 bool Instruction::maybe_flattened_array() {
 143   if (ValueArrayFlatten) {
 144     ciType* type = declared_type();
 145     if (type != NULL) {
 146       if (type-&gt;is_obj_array_klass()) {
 147         // Due to array covariance, the runtime type might be a flattened array.
 148         ciKlass* element_klass = type-&gt;as_obj_array_klass()-&gt;element_klass();
 149         if (element_klass-&gt;can_be_value_klass() &amp;&amp; (!element_klass-&gt;is_valuetype() || element_klass-&gt;as_value_klass()-&gt;flatten_array())) {
 150           // We will add a runtime check for flat-ness.
 151           return true;
 152         }
 153       } else if (type-&gt;is_value_array_klass()) {
 154         ciKlass* element_klass = type-&gt;as_value_array_klass()-&gt;element_klass();
 155         if (!element_klass-&gt;is_loaded() ||
 156             (element_klass-&gt;is_valuetype() &amp;&amp; element_klass-&gt;as_value_klass()-&gt;flatten_array())) {
 157           // We will add a runtime check for flat-ness.
 158           return true;
 159         }
 160       } else if (type-&gt;is_klass() &amp;&amp; type-&gt;as_klass()-&gt;is_java_lang_Object()) {
 161         // This can happen as a parameter to System.arraycopy()
 162         return true;
 163       }
 164     } else {
 165       // Type info gets lost during Phi merging (Phi, IfOp, etc), but we might be storing into a
 166       // flattened array, so we should do a runtime check.
 167       return true;
 168     }
 169   }
 170   return false;
 171 }
 172 
 173 bool Instruction::maybe_null_free_array() {
 174   ciType* type = declared_type();
 175   if (type != NULL) {
 176     if (type-&gt;is_obj_array_klass()) {
 177       // Due to array covariance, the runtime type might be a null-free array.
 178       ciKlass* element_klass = type-&gt;as_obj_array_klass()-&gt;element_klass();
 179       if (element_klass-&gt;can_be_value_klass()) {
 180           // We will add a runtime check for null-free-ness.
 181           return true;
 182       }
 183     }
 184   } else {
 185     // Type info gets lost during Phi merging (Phi, IfOp, etc), but we might be storing into a
 186     // null-free array, so we should do a runtime check.
 187     return true;
 188   }
 189   return false;
 190 }
 191 
 192 #ifndef PRODUCT
 193 void Instruction::check_state(ValueStack* state) {
 194   if (state != NULL) {
 195     state-&gt;verify();
 196   }
 197 }
 198 
 199 
 200 void Instruction::print() {
 201   InstructionPrinter ip;
 202   print(ip);
 203 }
 204 
 205 
 206 void Instruction::print_line() {
 207   InstructionPrinter ip;
 208   ip.print_line(this);
 209 }
 210 
 211 
 212 void Instruction::print(InstructionPrinter&amp; ip) {
 213   ip.print_head();
 214   ip.print_line(this);
 215   tty-&gt;cr();
 216 }
 217 #endif // PRODUCT
 218 
 219 
 220 // perform constant and interval tests on index value
 221 bool AccessIndexed::compute_needs_range_check() {
 222   if (length()) {
 223     Constant* clength = length()-&gt;as_Constant();
 224     Constant* cindex = index()-&gt;as_Constant();
 225     if (clength &amp;&amp; cindex) {
 226       IntConstant* l = clength-&gt;type()-&gt;as_IntConstant();
 227       IntConstant* i = cindex-&gt;type()-&gt;as_IntConstant();
 228       if (l &amp;&amp; i &amp;&amp; i-&gt;value() &lt; l-&gt;value() &amp;&amp; i-&gt;value() &gt;= 0) {
 229         return false;
 230       }
 231     }
 232   }
 233 
 234   if (!this-&gt;check_flag(NeedsRangeCheckFlag)) {
 235     return false;
 236   }
 237 
 238   return true;
 239 }
 240 
 241 
 242 ciType* Constant::exact_type() const {
 243   if (type()-&gt;is_object() &amp;&amp; type()-&gt;as_ObjectType()-&gt;is_loaded()) {
 244     return type()-&gt;as_ObjectType()-&gt;exact_type();
 245   }
 246   return NULL;
 247 }
 248 
 249 ciType* LoadIndexed::exact_type() const {
 250   ciType* array_type = array()-&gt;exact_type();
 251   if (array_type != NULL) {
 252     assert(array_type-&gt;is_array_klass(), &quot;what else?&quot;);
 253     ciArrayKlass* ak = (ciArrayKlass*)array_type;
 254 
 255     if (ak-&gt;element_type()-&gt;is_instance_klass()) {
 256       ciInstanceKlass* ik = (ciInstanceKlass*)ak-&gt;element_type();
 257       if (ik-&gt;is_loaded() &amp;&amp; ik-&gt;is_final()) {
 258         return ik;
 259       }
 260     }
 261   }
 262   return Instruction::exact_type();
 263 }
 264 
 265 
 266 ciType* LoadIndexed::declared_type() const {
 267   ciType* array_type = array()-&gt;declared_type();
 268   if (array_type == NULL || !array_type-&gt;is_loaded()) {
 269     return NULL;
 270   }
 271   assert(array_type-&gt;is_array_klass(), &quot;what else?&quot;);
 272   ciArrayKlass* ak = (ciArrayKlass*)array_type;
 273   return ak-&gt;element_type();
 274 }
 275 
 276 bool StoreIndexed::is_exact_flattened_array_store() const {
 277   if (array()-&gt;is_loaded_flattened_array() &amp;&amp; value()-&gt;as_Constant() == NULL &amp;&amp; value()-&gt;declared_type() != NULL) {
 278     ciKlass* element_klass = array()-&gt;declared_type()-&gt;as_value_array_klass()-&gt;element_klass();
 279     ciKlass* actual_klass = value()-&gt;declared_type()-&gt;as_klass();
 280 
 281     // The following check can fail with inlining:
 282     //     void test45_inline(Object[] oa, Object o, int index) { oa[index] = o; }
 283     //     void test45(MyValue1[] va, int index, MyValue2 v) { test45_inline(va, v, index); }
 284     if (element_klass == actual_klass) {
 285       return true;
 286     }
 287   }
 288   return false;
 289 }
 290 
 291 ciType* LoadField::declared_type() const {
 292   return field()-&gt;type();
 293 }
 294 
 295 
 296 ciType* NewTypeArray::exact_type() const {
 297   return ciTypeArrayKlass::make(elt_type());
 298 }
 299 
 300 ciType* NewObjectArray::exact_type() const {
 301   ciKlass* element_klass = klass();
 302   if (is_never_null() &amp;&amp; element_klass-&gt;is_valuetype()) {
 303     if (element_klass-&gt;as_value_klass()-&gt;flatten_array()) {
 304       return ciValueArrayKlass::make(element_klass);
 305     } else {
 306       return ciObjArrayKlass::make(element_klass, /*never_null =*/true);
 307     }
 308   } else {
 309     return ciObjArrayKlass::make(element_klass);
 310   }
 311 }
 312 
 313 ciType* NewMultiArray::exact_type() const {
 314   return _klass;
 315 }
 316 
 317 ciType* NewArray::declared_type() const {
 318   return exact_type();
 319 }
 320 
 321 ciType* NewInstance::exact_type() const {
 322   return klass();
 323 }
 324 
 325 ciType* NewInstance::declared_type() const {
 326   return exact_type();
 327 }
 328 
 329 Value NewValueTypeInstance::depends_on() {
 330   if (_depends_on != this) {
 331     if (_depends_on-&gt;as_NewValueTypeInstance() != NULL) {
 332       return _depends_on-&gt;as_NewValueTypeInstance()-&gt;depends_on();
 333     }
 334   }
 335   return _depends_on;
 336 }
 337 
 338 ciType* NewValueTypeInstance::exact_type() const {
 339   return klass();
 340 }
 341 
 342 ciType* NewValueTypeInstance::declared_type() const {
 343   return exact_type();
 344 }
 345 
 346 ciType* CheckCast::declared_type() const {
 347   return klass();
 348 }
 349 
 350 // Implementation of ArithmeticOp
 351 
 352 bool ArithmeticOp::is_commutative() const {
 353   switch (op()) {
 354     case Bytecodes::_iadd: // fall through
 355     case Bytecodes::_ladd: // fall through
 356     case Bytecodes::_fadd: // fall through
 357     case Bytecodes::_dadd: // fall through
 358     case Bytecodes::_imul: // fall through
 359     case Bytecodes::_lmul: // fall through
 360     case Bytecodes::_fmul: // fall through
 361     case Bytecodes::_dmul: return true;
 362     default              : return false;
 363   }
 364 }
 365 
 366 
 367 bool ArithmeticOp::can_trap() const {
 368   switch (op()) {
 369     case Bytecodes::_idiv: // fall through
 370     case Bytecodes::_ldiv: // fall through
 371     case Bytecodes::_irem: // fall through
 372     case Bytecodes::_lrem: return true;
 373     default              : return false;
 374   }
 375 }
 376 
 377 
 378 // Implementation of LogicOp
 379 
 380 bool LogicOp::is_commutative() const {
 381 #ifdef ASSERT
 382   switch (op()) {
 383     case Bytecodes::_iand: // fall through
 384     case Bytecodes::_land: // fall through
 385     case Bytecodes::_ior : // fall through
 386     case Bytecodes::_lor : // fall through
 387     case Bytecodes::_ixor: // fall through
 388     case Bytecodes::_lxor: break;
 389     default              : ShouldNotReachHere(); break;
 390   }
 391 #endif
 392   // all LogicOps are commutative
 393   return true;
 394 }
 395 
 396 
 397 // Implementation of IfOp
 398 
 399 bool IfOp::is_commutative() const {
 400   return cond() == eql || cond() == neq;
 401 }
 402 
 403 
 404 // Implementation of StateSplit
 405 
 406 void StateSplit::substitute(BlockList&amp; list, BlockBegin* old_block, BlockBegin* new_block) {
 407   NOT_PRODUCT(bool assigned = false;)
 408   for (int i = 0; i &lt; list.length(); i++) {
 409     BlockBegin** b = list.adr_at(i);
 410     if (*b == old_block) {
 411       *b = new_block;
 412       NOT_PRODUCT(assigned = true;)
 413     }
 414   }
 415   assert(assigned == true, &quot;should have assigned at least once&quot;);
 416 }
 417 
 418 
 419 IRScope* StateSplit::scope() const {
 420   return _state-&gt;scope();
 421 }
 422 
 423 
 424 void StateSplit::state_values_do(ValueVisitor* f) {
 425   Instruction::state_values_do(f);
 426   if (state() != NULL) state()-&gt;values_do(f);
 427 }
 428 
 429 
 430 void BlockBegin::state_values_do(ValueVisitor* f) {
 431   StateSplit::state_values_do(f);
 432 
 433   if (is_set(BlockBegin::exception_entry_flag)) {
 434     for (int i = 0; i &lt; number_of_exception_states(); i++) {
 435       exception_state_at(i)-&gt;values_do(f);
 436     }
 437   }
 438 }
 439 
 440 
 441 // Implementation of Invoke
 442 
 443 
 444 Invoke::Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
 445                int vtable_index, ciMethod* target, ValueStack* state_before, bool never_null)
 446   : StateSplit(result_type, state_before)
 447   , _code(code)
 448   , _recv(recv)
 449   , _args(args)
 450   , _vtable_index(vtable_index)
 451   , _target(target)
 452 {
 453   set_flag(TargetIsLoadedFlag,   target-&gt;is_loaded());
 454   set_flag(TargetIsFinalFlag,    target_is_loaded() &amp;&amp; target-&gt;is_final_method());
 455   set_flag(TargetIsStrictfpFlag, target_is_loaded() &amp;&amp; target-&gt;is_strict());
 456   set_never_null(never_null);
 457 
 458   assert(args != NULL, &quot;args must exist&quot;);
 459 #ifdef ASSERT
 460   AssertValues assert_value;
 461   values_do(&amp;assert_value);
 462 #endif
 463 
 464   // provide an initial guess of signature size.
 465   _signature = new BasicTypeList(number_of_arguments() + (has_receiver() ? 1 : 0));
 466   if (has_receiver()) {
 467     _signature-&gt;append(as_BasicType(receiver()-&gt;type()));
 468   }
 469   for (int i = 0; i &lt; number_of_arguments(); i++) {
 470     ValueType* t = argument_at(i)-&gt;type();
 471     BasicType bt = as_BasicType(t);
 472     _signature-&gt;append(bt);
 473   }
 474 }
 475 
 476 
 477 void Invoke::state_values_do(ValueVisitor* f) {
 478   StateSplit::state_values_do(f);
 479   if (state_before() != NULL) state_before()-&gt;values_do(f);
 480   if (state()        != NULL) state()-&gt;values_do(f);
 481 }
 482 
 483 ciType* Invoke::declared_type() const {
 484   ciSignature* declared_signature = state()-&gt;scope()-&gt;method()-&gt;get_declared_signature_at_bci(state()-&gt;bci());
 485   ciType *t = declared_signature-&gt;return_type();
 486   assert(t-&gt;basic_type() != T_VOID, &quot;need return value of void method?&quot;);
 487   return t;
 488 }
 489 
 490 // Implementation of Contant
 491 intx Constant::hash() const {
 492   if (state_before() == NULL) {
 493     switch (type()-&gt;tag()) {
 494     case intTag:
 495       return HASH2(name(), type()-&gt;as_IntConstant()-&gt;value());
 496     case addressTag:
 497       return HASH2(name(), type()-&gt;as_AddressConstant()-&gt;value());
 498     case longTag:
 499       {
 500         jlong temp = type()-&gt;as_LongConstant()-&gt;value();
 501         return HASH3(name(), high(temp), low(temp));
 502       }
 503     case floatTag:
 504       return HASH2(name(), jint_cast(type()-&gt;as_FloatConstant()-&gt;value()));
 505     case doubleTag:
 506       {
 507         jlong temp = jlong_cast(type()-&gt;as_DoubleConstant()-&gt;value());
 508         return HASH3(name(), high(temp), low(temp));
 509       }
 510     case objectTag:
 511       assert(type()-&gt;as_ObjectType()-&gt;is_loaded(), &quot;can&#39;t handle unloaded values&quot;);
 512       return HASH2(name(), type()-&gt;as_ObjectType()-&gt;constant_value());
 513     case metaDataTag:
 514       assert(type()-&gt;as_MetadataType()-&gt;is_loaded(), &quot;can&#39;t handle unloaded values&quot;);
 515       return HASH2(name(), type()-&gt;as_MetadataType()-&gt;constant_value());
 516     default:
 517       ShouldNotReachHere();
 518     }
 519   }
 520   return 0;
 521 }
 522 
 523 bool Constant::is_equal(Value v) const {
 524   if (v-&gt;as_Constant() == NULL) return false;
 525 
 526   switch (type()-&gt;tag()) {
 527     case intTag:
 528       {
 529         IntConstant* t1 =    type()-&gt;as_IntConstant();
 530         IntConstant* t2 = v-&gt;type()-&gt;as_IntConstant();
 531         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 532                 t1-&gt;value() == t2-&gt;value());
 533       }
 534     case longTag:
 535       {
 536         LongConstant* t1 =    type()-&gt;as_LongConstant();
 537         LongConstant* t2 = v-&gt;type()-&gt;as_LongConstant();
 538         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 539                 t1-&gt;value() == t2-&gt;value());
 540       }
 541     case floatTag:
 542       {
 543         FloatConstant* t1 =    type()-&gt;as_FloatConstant();
 544         FloatConstant* t2 = v-&gt;type()-&gt;as_FloatConstant();
 545         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 546                 jint_cast(t1-&gt;value()) == jint_cast(t2-&gt;value()));
 547       }
 548     case doubleTag:
 549       {
 550         DoubleConstant* t1 =    type()-&gt;as_DoubleConstant();
 551         DoubleConstant* t2 = v-&gt;type()-&gt;as_DoubleConstant();
 552         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 553                 jlong_cast(t1-&gt;value()) == jlong_cast(t2-&gt;value()));
 554       }
 555     case objectTag:
 556       {
 557         ObjectType* t1 =    type()-&gt;as_ObjectType();
 558         ObjectType* t2 = v-&gt;type()-&gt;as_ObjectType();
 559         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 560                 t1-&gt;is_loaded() &amp;&amp; t2-&gt;is_loaded() &amp;&amp;
 561                 t1-&gt;constant_value() == t2-&gt;constant_value());
 562       }
 563     case metaDataTag:
 564       {
 565         MetadataType* t1 =    type()-&gt;as_MetadataType();
 566         MetadataType* t2 = v-&gt;type()-&gt;as_MetadataType();
 567         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 568                 t1-&gt;is_loaded() &amp;&amp; t2-&gt;is_loaded() &amp;&amp;
 569                 t1-&gt;constant_value() == t2-&gt;constant_value());
 570       }
 571     default:
 572       return false;
 573   }
 574 }
 575 
 576 Constant::CompareResult Constant::compare(Instruction::Condition cond, Value right) const {
 577   Constant* rc = right-&gt;as_Constant();
 578   // other is not a constant
 579   if (rc == NULL) return not_comparable;
 580 
 581   ValueType* lt = type();
 582   ValueType* rt = rc-&gt;type();
 583   // different types
 584   if (lt-&gt;base() != rt-&gt;base()) return not_comparable;
 585   switch (lt-&gt;tag()) {
 586   case intTag: {
 587     int x = lt-&gt;as_IntConstant()-&gt;value();
 588     int y = rt-&gt;as_IntConstant()-&gt;value();
 589     switch (cond) {
 590     case If::eql: return x == y ? cond_true : cond_false;
 591     case If::neq: return x != y ? cond_true : cond_false;
 592     case If::lss: return x &lt;  y ? cond_true : cond_false;
 593     case If::leq: return x &lt;= y ? cond_true : cond_false;
 594     case If::gtr: return x &gt;  y ? cond_true : cond_false;
 595     case If::geq: return x &gt;= y ? cond_true : cond_false;
 596     default     : break;
 597     }
 598     break;
 599   }
 600   case longTag: {
 601     jlong x = lt-&gt;as_LongConstant()-&gt;value();
 602     jlong y = rt-&gt;as_LongConstant()-&gt;value();
 603     switch (cond) {
 604     case If::eql: return x == y ? cond_true : cond_false;
 605     case If::neq: return x != y ? cond_true : cond_false;
 606     case If::lss: return x &lt;  y ? cond_true : cond_false;
 607     case If::leq: return x &lt;= y ? cond_true : cond_false;
 608     case If::gtr: return x &gt;  y ? cond_true : cond_false;
 609     case If::geq: return x &gt;= y ? cond_true : cond_false;
 610     default     : break;
 611     }
 612     break;
 613   }
 614   case objectTag: {
 615     ciObject* xvalue = lt-&gt;as_ObjectType()-&gt;constant_value();
 616     ciObject* yvalue = rt-&gt;as_ObjectType()-&gt;constant_value();
 617     assert(xvalue != NULL &amp;&amp; yvalue != NULL, &quot;not constants&quot;);
 618     if (xvalue-&gt;is_loaded() &amp;&amp; yvalue-&gt;is_loaded()) {
 619       switch (cond) {
 620       case If::eql: return xvalue == yvalue ? cond_true : cond_false;
 621       case If::neq: return xvalue != yvalue ? cond_true : cond_false;
 622       default     : break;
 623       }
 624     }
 625     break;
 626   }
 627   case metaDataTag: {
 628     ciMetadata* xvalue = lt-&gt;as_MetadataType()-&gt;constant_value();
 629     ciMetadata* yvalue = rt-&gt;as_MetadataType()-&gt;constant_value();
 630     assert(xvalue != NULL &amp;&amp; yvalue != NULL, &quot;not constants&quot;);
 631     if (xvalue-&gt;is_loaded() &amp;&amp; yvalue-&gt;is_loaded()) {
 632       switch (cond) {
 633       case If::eql: return xvalue == yvalue ? cond_true : cond_false;
 634       case If::neq: return xvalue != yvalue ? cond_true : cond_false;
 635       default     : break;
 636       }
 637     }
 638     break;
 639   }
 640   default:
 641     break;
 642   }
 643   return not_comparable;
 644 }
 645 
 646 
 647 // Implementation of BlockBegin
 648 
 649 void BlockBegin::set_end(BlockEnd* end) {
 650   assert(end != NULL, &quot;should not reset block end to NULL&quot;);
 651   if (end == _end) {
 652     return;
 653   }
 654   clear_end();
 655 
 656   // Set the new end
 657   _end = end;
 658 
 659   _successors.clear();
 660   // Now reset successors list based on BlockEnd
 661   for (int i = 0; i &lt; end-&gt;number_of_sux(); i++) {
 662     BlockBegin* sux = end-&gt;sux_at(i);
 663     _successors.append(sux);
 664     sux-&gt;_predecessors.append(this);
 665   }
 666   _end-&gt;set_begin(this);
 667 }
 668 
 669 
 670 void BlockBegin::clear_end() {
 671   // Must make the predecessors/successors match up with the
 672   // BlockEnd&#39;s notion.
 673   if (_end != NULL) {
 674     // disconnect from the old end
 675     _end-&gt;set_begin(NULL);
 676 
 677     // disconnect this block from it&#39;s current successors
 678     for (int i = 0; i &lt; _successors.length(); i++) {
 679       _successors.at(i)-&gt;remove_predecessor(this);
 680     }
 681     _end = NULL;
 682   }
 683 }
 684 
 685 
 686 void BlockBegin::disconnect_edge(BlockBegin* from, BlockBegin* to) {
 687   // disconnect any edges between from and to
 688 #ifndef PRODUCT
 689   if (PrintIR &amp;&amp; Verbose) {
 690     tty-&gt;print_cr(&quot;Disconnected edge B%d -&gt; B%d&quot;, from-&gt;block_id(), to-&gt;block_id());
 691   }
 692 #endif
 693   for (int s = 0; s &lt; from-&gt;number_of_sux();) {
 694     BlockBegin* sux = from-&gt;sux_at(s);
 695     if (sux == to) {
 696       int index = sux-&gt;_predecessors.find(from);
 697       if (index &gt;= 0) {
 698         sux-&gt;_predecessors.remove_at(index);
 699       }
 700       from-&gt;_successors.remove_at(s);
 701     } else {
 702       s++;
 703     }
 704   }
 705 }
 706 
 707 
 708 void BlockBegin::disconnect_from_graph() {
 709   // disconnect this block from all other blocks
 710   for (int p = 0; p &lt; number_of_preds(); p++) {
 711     pred_at(p)-&gt;remove_successor(this);
 712   }
 713   for (int s = 0; s &lt; number_of_sux(); s++) {
 714     sux_at(s)-&gt;remove_predecessor(this);
 715   }
 716 }
 717 
 718 void BlockBegin::substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux) {
 719   // modify predecessors before substituting successors
 720   for (int i = 0; i &lt; number_of_sux(); i++) {
 721     if (sux_at(i) == old_sux) {
 722       // remove old predecessor before adding new predecessor
 723       // otherwise there is a dead predecessor in the list
 724       new_sux-&gt;remove_predecessor(old_sux);
 725       new_sux-&gt;add_predecessor(this);
 726     }
 727   }
 728   old_sux-&gt;remove_predecessor(this);
 729   end()-&gt;substitute_sux(old_sux, new_sux);
 730 }
 731 
 732 
 733 
 734 // In general it is not possible to calculate a value for the field &quot;depth_first_number&quot;
 735 // of the inserted block, without recomputing the values of the other blocks
 736 // in the CFG. Therefore the value of &quot;depth_first_number&quot; in BlockBegin becomes meaningless.
 737 BlockBegin* BlockBegin::insert_block_between(BlockBegin* sux) {
 738   int bci = sux-&gt;bci();
 739   // critical edge splitting may introduce a goto after a if and array
 740   // bound check elimination may insert a predicate between the if and
 741   // goto. The bci of the goto can&#39;t be the one of the if otherwise
 742   // the state and bci are inconsistent and a deoptimization triggered
 743   // by the predicate would lead to incorrect execution/a crash.
 744   BlockBegin* new_sux = new BlockBegin(bci);
 745 
 746   // mark this block (special treatment when block order is computed)
 747   new_sux-&gt;set(critical_edge_split_flag);
 748 
 749   // This goto is not a safepoint.
 750   Goto* e = new Goto(sux, false);
 751   new_sux-&gt;set_next(e, bci);
 752   new_sux-&gt;set_end(e);
 753   // setup states
 754   ValueStack* s = end()-&gt;state();
 755   new_sux-&gt;set_state(s-&gt;copy(s-&gt;kind(), bci));
 756   e-&gt;set_state(s-&gt;copy(s-&gt;kind(), bci));
 757   assert(new_sux-&gt;state()-&gt;locals_size() == s-&gt;locals_size(), &quot;local size mismatch!&quot;);
 758   assert(new_sux-&gt;state()-&gt;stack_size() == s-&gt;stack_size(), &quot;stack size mismatch!&quot;);
 759   assert(new_sux-&gt;state()-&gt;locks_size() == s-&gt;locks_size(), &quot;locks size mismatch!&quot;);
 760 
 761   // link predecessor to new block
 762   end()-&gt;substitute_sux(sux, new_sux);
 763 
 764   // The ordering needs to be the same, so remove the link that the
 765   // set_end call above added and substitute the new_sux for this
 766   // block.
 767   sux-&gt;remove_predecessor(new_sux);
 768 
 769   // the successor could be the target of a switch so it might have
 770   // multiple copies of this predecessor, so substitute the new_sux
 771   // for the first and delete the rest.
 772   bool assigned = false;
 773   BlockList&amp; list = sux-&gt;_predecessors;
 774   for (int i = 0; i &lt; list.length(); i++) {
 775     BlockBegin** b = list.adr_at(i);
 776     if (*b == this) {
 777       if (assigned) {
 778         list.remove_at(i);
 779         // reprocess this index
 780         i--;
 781       } else {
 782         assigned = true;
 783         *b = new_sux;
 784       }
 785       // link the new block back to it&#39;s predecessors.
 786       new_sux-&gt;add_predecessor(this);
 787     }
 788   }
 789   assert(assigned == true, &quot;should have assigned at least once&quot;);
 790   return new_sux;
 791 }
 792 
 793 
 794 void BlockBegin::remove_successor(BlockBegin* pred) {
 795   int idx;
 796   while ((idx = _successors.find(pred)) &gt;= 0) {
 797     _successors.remove_at(idx);
 798   }
 799 }
 800 
 801 
 802 void BlockBegin::add_predecessor(BlockBegin* pred) {
 803   _predecessors.append(pred);
 804 }
 805 
 806 
 807 void BlockBegin::remove_predecessor(BlockBegin* pred) {
 808   int idx;
 809   while ((idx = _predecessors.find(pred)) &gt;= 0) {
 810     _predecessors.remove_at(idx);
 811   }
 812 }
 813 
 814 
 815 void BlockBegin::add_exception_handler(BlockBegin* b) {
 816   assert(b != NULL &amp;&amp; (b-&gt;is_set(exception_entry_flag)), &quot;exception handler must exist&quot;);
 817   // add only if not in the list already
 818   if (!_exception_handlers.contains(b)) _exception_handlers.append(b);
 819 }
 820 
 821 int BlockBegin::add_exception_state(ValueStack* state) {
 822   assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;);
 823   if (_exception_states == NULL) {
 824     _exception_states = new ValueStackStack(4);
 825   }
 826   _exception_states-&gt;append(state);
 827   return _exception_states-&gt;length() - 1;
 828 }
 829 
 830 
 831 void BlockBegin::iterate_preorder(boolArray&amp; mark, BlockClosure* closure) {
 832   if (!mark.at(block_id())) {
 833     mark.at_put(block_id(), true);
 834     closure-&gt;block_do(this);
 835     BlockEnd* e = end(); // must do this after block_do because block_do may change it!
 836     { for (int i = number_of_exception_handlers() - 1; i &gt;= 0; i--) exception_handler_at(i)-&gt;iterate_preorder(mark, closure); }
 837     { for (int i = e-&gt;number_of_sux            () - 1; i &gt;= 0; i--) e-&gt;sux_at           (i)-&gt;iterate_preorder(mark, closure); }
 838   }
 839 }
 840 
 841 
 842 void BlockBegin::iterate_postorder(boolArray&amp; mark, BlockClosure* closure) {
 843   if (!mark.at(block_id())) {
 844     mark.at_put(block_id(), true);
 845     BlockEnd* e = end();
 846     { for (int i = number_of_exception_handlers() - 1; i &gt;= 0; i--) exception_handler_at(i)-&gt;iterate_postorder(mark, closure); }
 847     { for (int i = e-&gt;number_of_sux            () - 1; i &gt;= 0; i--) e-&gt;sux_at           (i)-&gt;iterate_postorder(mark, closure); }
 848     closure-&gt;block_do(this);
 849   }
 850 }
 851 
 852 
 853 void BlockBegin::iterate_preorder(BlockClosure* closure) {
 854   int mark_len = number_of_blocks();
 855   boolArray mark(mark_len, mark_len, false);
 856   iterate_preorder(mark, closure);
 857 }
 858 
 859 
 860 void BlockBegin::iterate_postorder(BlockClosure* closure) {
 861   int mark_len = number_of_blocks();
 862   boolArray mark(mark_len, mark_len, false);
 863   iterate_postorder(mark, closure);
 864 }
 865 
 866 
 867 void BlockBegin::block_values_do(ValueVisitor* f) {
 868   for (Instruction* n = this; n != NULL; n = n-&gt;next()) n-&gt;values_do(f);
 869 }
 870 
 871 
 872 #ifndef PRODUCT
 873    #define TRACE_PHI(code) if (PrintPhiFunctions) { code; }
 874 #else
 875    #define TRACE_PHI(coce)
 876 #endif
 877 
 878 
 879 bool BlockBegin::try_merge(ValueStack* new_state) {
 880   TRACE_PHI(tty-&gt;print_cr(&quot;********** try_merge for block B%d&quot;, block_id()));
 881 
 882   // local variables used for state iteration
 883   int index;
 884   Value new_value, existing_value;
 885 
 886   ValueStack* existing_state = state();
 887   if (existing_state == NULL) {
 888     TRACE_PHI(tty-&gt;print_cr(&quot;first call of try_merge for this block&quot;));
 889 
 890     if (is_set(BlockBegin::was_visited_flag)) {
 891       // this actually happens for complicated jsr/ret structures
 892       return false; // BAILOUT in caller
 893     }
 894 
 895     // copy state because it is altered
 896     new_state = new_state-&gt;copy(ValueStack::BlockBeginState, bci());
 897 
 898     // Use method liveness to invalidate dead locals
 899     MethodLivenessResult liveness = new_state-&gt;scope()-&gt;method()-&gt;liveness_at_bci(bci());
 900     if (liveness.is_valid()) {
 901       assert((int)liveness.size() == new_state-&gt;locals_size(), &quot;error in use of liveness&quot;);
 902 
 903       for_each_local_value(new_state, index, new_value) {
 904         if (!liveness.at(index) || new_value-&gt;type()-&gt;is_illegal()) {
 905           new_state-&gt;invalidate_local(index);
 906           TRACE_PHI(tty-&gt;print_cr(&quot;invalidating dead local %d&quot;, index));
 907         }
 908       }
 909     }
 910 
 911     if (is_set(BlockBegin::parser_loop_header_flag)) {
 912       TRACE_PHI(tty-&gt;print_cr(&quot;loop header block, initializing phi functions&quot;));
 913 
 914       for_each_stack_value(new_state, index, new_value) {
 915         new_state-&gt;setup_phi_for_stack(this, index);
 916         TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for stack %d&quot;, new_state-&gt;stack_at(index)-&gt;type()-&gt;tchar(), new_state-&gt;stack_at(index)-&gt;id(), index));
 917       }
 918 
 919       BitMap&amp; requires_phi_function = new_state-&gt;scope()-&gt;requires_phi_function();
 920 
 921       for_each_local_value(new_state, index, new_value) {
 922         bool requires_phi = requires_phi_function.at(index) || (new_value-&gt;type()-&gt;is_double_word() &amp;&amp; requires_phi_function.at(index + 1));
 923         if (requires_phi || !SelectivePhiFunctions) {
 924           new_state-&gt;setup_phi_for_local(this, index);
 925           TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for local %d&quot;, new_state-&gt;local_at(index)-&gt;type()-&gt;tchar(), new_state-&gt;local_at(index)-&gt;id(), index));
 926         }
 927       }
 928     }
 929 
 930     // initialize state of block
 931     set_state(new_state);
 932 
 933   } else if (existing_state-&gt;is_same(new_state)) {
 934     TRACE_PHI(tty-&gt;print_cr(&quot;exisiting state found&quot;));
 935 
 936     assert(existing_state-&gt;scope() == new_state-&gt;scope(), &quot;not matching&quot;);
 937     assert(existing_state-&gt;locals_size() == new_state-&gt;locals_size(), &quot;not matching&quot;);
 938     assert(existing_state-&gt;stack_size() == new_state-&gt;stack_size(), &quot;not matching&quot;);
 939 
 940     if (is_set(BlockBegin::was_visited_flag)) {
 941       TRACE_PHI(tty-&gt;print_cr(&quot;loop header block, phis must be present&quot;));
 942 
 943       if (!is_set(BlockBegin::parser_loop_header_flag)) {
 944         // this actually happens for complicated jsr/ret structures
 945         return false; // BAILOUT in caller
 946       }
 947 
 948       for_each_local_value(existing_state, index, existing_value) {
 949         Value new_value = new_state-&gt;local_at(index);
 950         if (new_value == NULL || new_value-&gt;type()-&gt;tag() != existing_value-&gt;type()-&gt;tag()) {
 951           Phi* existing_phi = existing_value-&gt;as_Phi();
 952           if (existing_phi == NULL) {
 953             return false; // BAILOUT in caller
 954           }
 955           // Invalidate the phi function here. This case is very rare except for
 956           // JVMTI capability &quot;can_access_local_variables&quot;.
 957           // In really rare cases we will bail out in LIRGenerator::move_to_phi.
 958           existing_phi-&gt;make_illegal();
 959           existing_state-&gt;invalidate_local(index);
 960           TRACE_PHI(tty-&gt;print_cr(&quot;invalidating local %d because of type mismatch&quot;, index));
 961         }
 962       }
 963 
 964 #ifdef ASSERT
 965       // check that all necessary phi functions are present
 966       for_each_stack_value(existing_state, index, existing_value) {
 967         assert(existing_value-&gt;as_Phi() != NULL &amp;&amp; existing_value-&gt;as_Phi()-&gt;block() == this, &quot;phi function required&quot;);
 968       }
 969       for_each_local_value(existing_state, index, existing_value) {
 970         assert(existing_value == new_state-&gt;local_at(index) || (existing_value-&gt;as_Phi() != NULL &amp;&amp; existing_value-&gt;as_Phi()-&gt;as_Phi()-&gt;block() == this), &quot;phi function required&quot;);
 971       }
 972 #endif
 973 
 974     } else {
 975       TRACE_PHI(tty-&gt;print_cr(&quot;creating phi functions on demand&quot;));
 976 
 977       // create necessary phi functions for stack
 978       for_each_stack_value(existing_state, index, existing_value) {
 979         Value new_value = new_state-&gt;stack_at(index);
 980         Phi* existing_phi = existing_value-&gt;as_Phi();
 981 
 982         if (new_value != existing_value &amp;&amp; (existing_phi == NULL || existing_phi-&gt;block() != this)) {
 983           existing_state-&gt;setup_phi_for_stack(this, index);
 984           TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for stack %d&quot;, existing_state-&gt;stack_at(index)-&gt;type()-&gt;tchar(), existing_state-&gt;stack_at(index)-&gt;id(), index));
 985         }
 986       }
 987 
 988       // create necessary phi functions for locals
 989       for_each_local_value(existing_state, index, existing_value) {
 990         Value new_value = new_state-&gt;local_at(index);
 991         Phi* existing_phi = existing_value-&gt;as_Phi();
 992 
 993         if (new_value == NULL || new_value-&gt;type()-&gt;tag() != existing_value-&gt;type()-&gt;tag()) {
 994           existing_state-&gt;invalidate_local(index);
 995           TRACE_PHI(tty-&gt;print_cr(&quot;invalidating local %d because of type mismatch&quot;, index));
 996         } else if (new_value != existing_value &amp;&amp; (existing_phi == NULL || existing_phi-&gt;block() != this)) {
 997           existing_state-&gt;setup_phi_for_local(this, index);
 998           TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for local %d&quot;, existing_state-&gt;local_at(index)-&gt;type()-&gt;tchar(), existing_state-&gt;local_at(index)-&gt;id(), index));
 999         }
1000       }
1001     }
1002 
1003     assert(existing_state-&gt;caller_state() == new_state-&gt;caller_state(), &quot;caller states must be equal&quot;);
1004 
1005   } else {
1006     assert(false, &quot;stack or locks not matching (invalid bytecodes)&quot;);
1007     return false;
1008   }
1009 
1010   TRACE_PHI(tty-&gt;print_cr(&quot;********** try_merge for block B%d successful&quot;, block_id()));
1011 
1012   return true;
1013 }
1014 
1015 
1016 #ifndef PRODUCT
1017 void BlockBegin::print_block() {
1018   InstructionPrinter ip;
1019   print_block(ip, false);
1020 }
1021 
1022 
1023 void BlockBegin::print_block(InstructionPrinter&amp; ip, bool live_only) {
1024   ip.print_instr(this); tty-&gt;cr();
1025   ip.print_stack(this-&gt;state()); tty-&gt;cr();
1026   ip.print_inline_level(this);
1027   ip.print_head();
1028   for (Instruction* n = next(); n != NULL; n = n-&gt;next()) {
1029     if (!live_only || n-&gt;is_pinned() || n-&gt;use_count() &gt; 0) {
1030       ip.print_line(n);
1031     }
1032   }
1033   tty-&gt;cr();
1034 }
1035 #endif // PRODUCT
1036 
1037 
1038 // Implementation of BlockList
1039 
1040 void BlockList::iterate_forward (BlockClosure* closure) {
1041   const int l = length();
1042   for (int i = 0; i &lt; l; i++) closure-&gt;block_do(at(i));
1043 }
1044 
1045 
1046 void BlockList::iterate_backward(BlockClosure* closure) {
1047   for (int i = length() - 1; i &gt;= 0; i--) closure-&gt;block_do(at(i));
1048 }
1049 
1050 
1051 void BlockList::blocks_do(void f(BlockBegin*)) {
1052   for (int i = length() - 1; i &gt;= 0; i--) f(at(i));
1053 }
1054 
1055 
1056 void BlockList::values_do(ValueVisitor* f) {
1057   for (int i = length() - 1; i &gt;= 0; i--) at(i)-&gt;block_values_do(f);
1058 }
1059 
1060 
1061 #ifndef PRODUCT
1062 void BlockList::print(bool cfg_only, bool live_only) {
1063   InstructionPrinter ip;
1064   for (int i = 0; i &lt; length(); i++) {
1065     BlockBegin* block = at(i);
1066     if (cfg_only) {
1067       ip.print_instr(block); tty-&gt;cr();
1068     } else {
1069       block-&gt;print_block(ip, live_only);
1070     }
1071   }
1072 }
1073 #endif // PRODUCT
1074 
1075 
1076 // Implementation of BlockEnd
1077 
1078 void BlockEnd::set_begin(BlockBegin* begin) {
1079   BlockList* sux = NULL;
1080   if (begin != NULL) {
1081     sux = begin-&gt;successors();
1082   } else if (this-&gt;begin() != NULL) {
1083     // copy our sux list
1084     BlockList* sux = new BlockList(this-&gt;begin()-&gt;number_of_sux());
1085     for (int i = 0; i &lt; this-&gt;begin()-&gt;number_of_sux(); i++) {
1086       sux-&gt;append(this-&gt;begin()-&gt;sux_at(i));
1087     }
1088   }
1089   _sux = sux;
1090 }
1091 
1092 
1093 void BlockEnd::substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux) {
1094   substitute(*_sux, old_sux, new_sux);
1095 }
1096 
1097 
1098 // Implementation of Phi
1099 
1100 // Normal phi functions take their operands from the last instruction of the
1101 // predecessor. Special handling is needed for xhanlder entries because there
1102 // the state of arbitrary instructions are needed.
1103 
1104 Value Phi::operand_at(int i) const {
1105   ValueStack* state;
1106   if (_block-&gt;is_set(BlockBegin::exception_entry_flag)) {
1107     state = _block-&gt;exception_state_at(i);
1108   } else {
1109     state = _block-&gt;pred_at(i)-&gt;end()-&gt;state();
1110   }
1111   assert(state != NULL, &quot;&quot;);
1112 
1113   if (is_local()) {
1114     return state-&gt;local_at(local_index());
1115   } else {
1116     return state-&gt;stack_at(stack_index());
1117   }
1118 }
1119 
1120 
1121 int Phi::operand_count() const {
1122   if (_block-&gt;is_set(BlockBegin::exception_entry_flag)) {
1123     return _block-&gt;number_of_exception_states();
1124   } else {
1125     return _block-&gt;number_of_preds();
1126   }
1127 }
1128 
1129 #ifdef ASSERT
1130 // Constructor of Assert
1131 Assert::Assert(Value x, Condition cond, bool unordered_is_true, Value y) : Instruction(illegalType)
1132   , _x(x)
1133   , _cond(cond)
1134   , _y(y)
1135 {
1136   set_flag(UnorderedIsTrueFlag, unordered_is_true);
1137   assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1138   pin();
1139 
1140   stringStream strStream;
1141   Compilation::current()-&gt;method()-&gt;print_name(&amp;strStream);
1142 
1143   stringStream strStream1;
1144   InstructionPrinter ip1(1, &amp;strStream1);
1145   ip1.print_instr(x);
1146 
1147   stringStream strStream2;
1148   InstructionPrinter ip2(1, &amp;strStream2);
1149   ip2.print_instr(y);
1150 
1151   stringStream ss;
1152   ss.print(&quot;Assertion %s %s %s in method %s&quot;, strStream1.as_string(), ip2.cond_name(cond), strStream2.as_string(), strStream.as_string());
1153 
1154   _message = ss.as_string();
1155 }
1156 #endif
1157 
1158 void RangeCheckPredicate::check_state() {
1159   assert(state()-&gt;kind() != ValueStack::EmptyExceptionState &amp;&amp; state()-&gt;kind() != ValueStack::ExceptionState, &quot;will deopt with empty state&quot;);
1160 }
1161 
1162 void ProfileInvoke::state_values_do(ValueVisitor* f) {
1163   if (state() != NULL) state()-&gt;values_do(f);
1164 }
    </pre>
  </body>
</html>
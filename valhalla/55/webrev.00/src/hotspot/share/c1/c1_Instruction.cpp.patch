diff a/src/hotspot/share/c1/c1_Instruction.cpp b/src/hotspot/share/c1/c1_Instruction.cpp
--- a/src/hotspot/share/c1/c1_Instruction.cpp
+++ b/src/hotspot/share/c1/c1_Instruction.cpp
@@ -127,17 +127,12 @@
 }
 
 bool Instruction::is_loaded_flattened_array() const {
   if (ValueArrayFlatten) {
     ciType* type = declared_type();
-    if (type != NULL && type->is_value_array_klass()) {
-      ciValueArrayKlass* vak = type->as_value_array_klass();
-      ArrayStorageProperties props = vak->storage_properties();
-      return (!props.is_empty() && props.is_null_free() && props.is_flattened());
-    }
+    return type != NULL && type->is_value_array_klass();
   }
-
   return false;
 }
 
 bool Instruction::maybe_flattened_array() {
   if (ValueArrayFlatten) {
@@ -145,20 +140,16 @@
     if (type != NULL) {
       if (type->is_obj_array_klass()) {
         // Due to array covariance, the runtime type might be a flattened array.
         ciKlass* element_klass = type->as_obj_array_klass()->element_klass();
         if (element_klass->can_be_value_klass() && (!element_klass->is_valuetype() || element_klass->as_value_klass()->flatten_array())) {
-          // We will add a runtime check for flat-ness.
           return true;
         }
       } else if (type->is_value_array_klass()) {
         ciKlass* element_klass = type->as_value_array_klass()->element_klass();
-        if (!element_klass->is_loaded() ||
-            (element_klass->is_valuetype() && element_klass->as_value_klass()->flatten_array())) {
-          // We will add a runtime check for flat-ness.
-          return true;
-        }
+        assert(!element_klass->is_loaded() || element_klass->as_value_klass()->flatten_array(), "must be flattened");
+        return true;
       } else if (type->is_klass() && type->as_klass()->is_java_lang_Object()) {
         // This can happen as a parameter to System.arraycopy()
         return true;
       }
     } else {
@@ -175,12 +166,11 @@
   if (type != NULL) {
     if (type->is_obj_array_klass()) {
       // Due to array covariance, the runtime type might be a null-free array.
       ciKlass* element_klass = type->as_obj_array_klass()->element_klass();
       if (element_klass->can_be_value_klass()) {
-          // We will add a runtime check for null-free-ness.
-          return true;
+        return true;
       }
     }
   } else {
     // Type info gets lost during Phi merging (Phi, IfOp, etc), but we might be storing into a
     // null-free array, so we should do a runtime check.
@@ -296,20 +286,11 @@
 ciType* NewTypeArray::exact_type() const {
   return ciTypeArrayKlass::make(elt_type());
 }
 
 ciType* NewObjectArray::exact_type() const {
-  ciKlass* element_klass = klass();
-  if (is_never_null() && element_klass->is_valuetype()) {
-    if (element_klass->as_value_klass()->flatten_array()) {
-      return ciValueArrayKlass::make(element_klass);
-    } else {
-      return ciObjArrayKlass::make(element_klass, /*never_null =*/true);
-    }
-  } else {
-    return ciObjArrayKlass::make(element_klass);
-  }
+  return ciArrayKlass::make(klass());
 }
 
 ciType* NewMultiArray::exact_type() const {
   return _klass;
 }

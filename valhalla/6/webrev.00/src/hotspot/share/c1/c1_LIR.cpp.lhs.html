<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_LIR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  27 #include &quot;c1/c1_LIR.hpp&quot;
  28 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  29 #include &quot;c1/c1_ValueStack.hpp&quot;
  30 #include &quot;ci/ciInstance.hpp&quot;
  31 #include &quot;ci/ciValueKlass.hpp&quot;
  32 #include &quot;runtime/sharedRuntime.hpp&quot;
  33 
  34 Register LIR_OprDesc::as_register() const {
  35   return FrameMap::cpu_rnr2reg(cpu_regnr());
  36 }
  37 
  38 Register LIR_OprDesc::as_register_lo() const {
  39   return FrameMap::cpu_rnr2reg(cpu_regnrLo());
  40 }
  41 
  42 Register LIR_OprDesc::as_register_hi() const {
  43   return FrameMap::cpu_rnr2reg(cpu_regnrHi());
  44 }
  45 
  46 LIR_Opr LIR_OprFact::illegalOpr = LIR_OprFact::illegal();
  47 
  48 LIR_Opr LIR_OprFact::value_type(ValueType* type) {
  49   ValueTag tag = type-&gt;tag();
  50   switch (tag) {
  51   case metaDataTag : {
  52     ClassConstant* c = type-&gt;as_ClassConstant();
  53     if (c != NULL &amp;&amp; !c-&gt;value()-&gt;is_loaded()) {
  54       return LIR_OprFact::metadataConst(NULL);
  55     } else if (c != NULL) {
  56       return LIR_OprFact::metadataConst(c-&gt;value()-&gt;constant_encoding());
  57     } else {
  58       MethodConstant* m = type-&gt;as_MethodConstant();
  59       assert (m != NULL, &quot;not a class or a method?&quot;);
  60       return LIR_OprFact::metadataConst(m-&gt;value()-&gt;constant_encoding());
  61     }
  62   }
  63   case objectTag : {
  64       return LIR_OprFact::oopConst(type-&gt;as_ObjectType()-&gt;encoding());
  65     }
  66   case addressTag: return LIR_OprFact::addressConst(type-&gt;as_AddressConstant()-&gt;value());
  67   case intTag    : return LIR_OprFact::intConst(type-&gt;as_IntConstant()-&gt;value());
  68   case floatTag  : return LIR_OprFact::floatConst(type-&gt;as_FloatConstant()-&gt;value());
  69   case longTag   : return LIR_OprFact::longConst(type-&gt;as_LongConstant()-&gt;value());
  70   case doubleTag : return LIR_OprFact::doubleConst(type-&gt;as_DoubleConstant()-&gt;value());
  71   default: ShouldNotReachHere(); return LIR_OprFact::intConst(-1);
  72   }
  73 }
  74 
  75 
  76 LIR_Opr LIR_OprFact::dummy_value_type(ValueType* type) {
  77   switch (type-&gt;tag()) {
  78     case objectTag: return LIR_OprFact::oopConst(NULL);
  79     case addressTag:return LIR_OprFact::addressConst(0);
  80     case intTag:    return LIR_OprFact::intConst(0);
  81     case floatTag:  return LIR_OprFact::floatConst(0.0);
  82     case longTag:   return LIR_OprFact::longConst(0);
  83     case doubleTag: return LIR_OprFact::doubleConst(0.0);
  84     default:        ShouldNotReachHere(); return LIR_OprFact::intConst(-1);
  85   }
  86   return illegalOpr;
  87 }
  88 
  89 
  90 
  91 //---------------------------------------------------
  92 
  93 
  94 LIR_Address::Scale LIR_Address::scale(BasicType type) {
  95   int elem_size = type2aelembytes(type);
  96   switch (elem_size) {
  97   case 1: return LIR_Address::times_1;
  98   case 2: return LIR_Address::times_2;
  99   case 4: return LIR_Address::times_4;
 100   case 8: return LIR_Address::times_8;
 101   }
 102   ShouldNotReachHere();
 103   return LIR_Address::times_1;
 104 }
 105 
 106 //---------------------------------------------------
 107 
 108 char LIR_OprDesc::type_char(BasicType t) {
 109   switch (t) {
 110     case T_ARRAY:
 111     case T_VALUETYPE:
 112       t = T_OBJECT;
 113     case T_BOOLEAN:
 114     case T_CHAR:
 115     case T_FLOAT:
 116     case T_DOUBLE:
 117     case T_BYTE:
 118     case T_SHORT:
 119     case T_INT:
 120     case T_LONG:
 121     case T_OBJECT:
 122     case T_ADDRESS:
 123     case T_VOID:
 124       return ::type2char(t);
 125     case T_METADATA:
 126       return &#39;M&#39;;
 127     case T_ILLEGAL:
 128       return &#39;?&#39;;
 129 
 130     default:
 131       ShouldNotReachHere();
 132       return &#39;?&#39;;
 133   }
 134 }
 135 
 136 #ifndef PRODUCT
 137 void LIR_OprDesc::validate_type() const {
 138 
 139 #ifdef ASSERT
 140   if (!is_pointer() &amp;&amp; !is_illegal()) {
 141     OprKind kindfield = kind_field(); // Factored out because of compiler bug, see 8002160
 142     switch (as_BasicType(type_field())) {
 143     case T_LONG:
 144       assert((kindfield == cpu_register || kindfield == stack_value) &amp;&amp;
 145              size_field() == double_size, &quot;must match&quot;);
 146       break;
 147     case T_FLOAT:
 148       // FP return values can be also in CPU registers on ARM and PPC32 (softfp ABI)
 149       assert((kindfield == fpu_register || kindfield == stack_value
 150              ARM_ONLY(|| kindfield == cpu_register)
 151              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 152              size_field() == single_size, &quot;must match&quot;);
 153       break;
 154     case T_DOUBLE:
 155       // FP return values can be also in CPU registers on ARM and PPC32 (softfp ABI)
 156       assert((kindfield == fpu_register || kindfield == stack_value
 157              ARM_ONLY(|| kindfield == cpu_register)
 158              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 159              size_field() == double_size, &quot;must match&quot;);
 160       break;
 161     case T_BOOLEAN:
 162     case T_CHAR:
 163     case T_BYTE:
 164     case T_SHORT:
 165     case T_INT:
 166     case T_ADDRESS:
 167     case T_OBJECT:
 168     case T_METADATA:
 169     case T_ARRAY:
 170     case T_VALUETYPE:
 171       assert((kindfield == cpu_register || kindfield == stack_value) &amp;&amp;
 172              size_field() == single_size, &quot;must match&quot;);
 173       break;
 174 
 175     case T_ILLEGAL:
 176       // XXX TKR also means unknown right now
 177       // assert(is_illegal(), &quot;must match&quot;);
 178       break;
 179 
 180     default:
 181       ShouldNotReachHere();
 182     }
 183   }
 184 #endif
 185 
 186 }
 187 #endif // PRODUCT
 188 
 189 
 190 bool LIR_OprDesc::is_oop() const {
 191   if (is_pointer()) {
 192     return pointer()-&gt;is_oop_pointer();
 193   } else {
 194     OprType t= type_field();
 195     assert(t != unknown_type, &quot;not set&quot;);
 196     return t == object_type;
 197   }
 198 }
 199 
 200 
 201 
 202 void LIR_Op2::verify() const {
 203 #ifdef ASSERT
 204   switch (code()) {
 205     case lir_cmove:
 206     case lir_xchg:
 207       break;
 208 
 209     default:
 210       assert(!result_opr()-&gt;is_register() || !result_opr()-&gt;is_oop_register(),
 211              &quot;can&#39;t produce oops from arith&quot;);
 212   }
 213 
 214   if (TwoOperandLIRForm) {
 215 
 216 #ifdef ASSERT
 217     bool threeOperandForm = false;
 218 #ifdef S390
 219     // There are 3 operand shifts on S390 (see LIR_Assembler::shift_op()).
 220     threeOperandForm =
 221       code() == lir_shl ||
 222       ((code() == lir_shr || code() == lir_ushr) &amp;&amp; (result_opr()-&gt;is_double_cpu() || in_opr1()-&gt;type() == T_OBJECT));
 223 #endif
 224 #endif
 225 
 226     switch (code()) {
 227     case lir_add:
 228     case lir_sub:
 229     case lir_mul:
 230     case lir_mul_strictfp:
 231     case lir_div:
 232     case lir_div_strictfp:
 233     case lir_rem:
 234     case lir_logic_and:
 235     case lir_logic_or:
 236     case lir_logic_xor:
 237     case lir_shl:
 238     case lir_shr:
 239       assert(in_opr1() == result_opr() || threeOperandForm, &quot;opr1 and result must match&quot;);
 240       assert(in_opr1()-&gt;is_valid() &amp;&amp; in_opr2()-&gt;is_valid(), &quot;must be valid&quot;);
 241       break;
 242 
 243     // special handling for lir_ushr because of write barriers
 244     case lir_ushr:
 245       assert(in_opr1() == result_opr() || in_opr2()-&gt;is_constant() || threeOperandForm, &quot;opr1 and result must match or shift count is constant&quot;);
 246       assert(in_opr1()-&gt;is_valid() &amp;&amp; in_opr2()-&gt;is_valid(), &quot;must be valid&quot;);
 247       break;
 248 
 249     default:
 250       break;
 251     }
 252   }
 253 #endif
 254 }
 255 
 256 
 257 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BasicType type, BlockBegin* block)
 258   : LIR_Op(lir_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 259   , _cond(cond)
 260   , _type(type)
 261   , _label(block-&gt;label())
 262   , _block(block)
 263   , _ublock(NULL)
 264   , _stub(NULL) {
 265 }
 266 
 267 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BasicType type, CodeStub* stub) :
 268   LIR_Op(lir_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 269   , _cond(cond)
 270   , _type(type)
 271   , _label(stub-&gt;entry())
 272   , _block(NULL)
 273   , _ublock(NULL)
 274   , _stub(stub) {
 275 }
 276 
 277 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BasicType type, BlockBegin* block, BlockBegin* ublock)
 278   : LIR_Op(lir_cond_float_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 279   , _cond(cond)
 280   , _type(type)
 281   , _label(block-&gt;label())
 282   , _block(block)
 283   , _ublock(ublock)
 284   , _stub(NULL)
 285 {
 286 }
 287 
 288 void LIR_OpBranch::change_block(BlockBegin* b) {
 289   assert(_block != NULL, &quot;must have old block&quot;);
 290   assert(_block-&gt;label() == label(), &quot;must be equal&quot;);
 291 
 292   _block = b;
 293   _label = b-&gt;label();
 294 }
 295 
 296 void LIR_OpBranch::change_ublock(BlockBegin* b) {
 297   assert(_ublock != NULL, &quot;must have old block&quot;);
 298   _ublock = b;
 299 }
 300 
 301 void LIR_OpBranch::negate_cond() {
 302   switch (_cond) {
 303     case lir_cond_equal:        _cond = lir_cond_notEqual;     break;
 304     case lir_cond_notEqual:     _cond = lir_cond_equal;        break;
 305     case lir_cond_less:         _cond = lir_cond_greaterEqual; break;
 306     case lir_cond_lessEqual:    _cond = lir_cond_greater;      break;
 307     case lir_cond_greaterEqual: _cond = lir_cond_less;         break;
 308     case lir_cond_greater:      _cond = lir_cond_lessEqual;    break;
 309     default: ShouldNotReachHere();
 310   }
 311 }
 312 
 313 
 314 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr result, LIR_Opr object, ciKlass* klass,
 315                                  LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
 316                                  bool fast_check, CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch,
 317                                  CodeStub* stub, bool need_null_check)
 318 
 319   : LIR_Op(code, result, NULL)
 320   , _object(object)
 321   , _array(LIR_OprFact::illegalOpr)
 322   , _klass(klass)
 323   , _tmp1(tmp1)
 324   , _tmp2(tmp2)
 325   , _tmp3(tmp3)
 326   , _fast_check(fast_check)
 327   , _info_for_patch(info_for_patch)
 328   , _info_for_exception(info_for_exception)
 329   , _stub(stub)
 330   , _profiled_method(NULL)
 331   , _profiled_bci(-1)
 332   , _should_profile(false)
 333   , _need_null_check(need_null_check)
 334 {
 335   if (code == lir_checkcast) {
 336     assert(info_for_exception != NULL, &quot;checkcast throws exceptions&quot;);
 337   } else if (code == lir_instanceof) {
 338     assert(info_for_exception == NULL, &quot;instanceof throws no exceptions&quot;);
 339   } else {
 340     ShouldNotReachHere();
 341   }
 342 }
 343 
 344 
 345 
 346 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception)
 347   : LIR_Op(code, LIR_OprFact::illegalOpr, NULL)
 348   , _object(object)
 349   , _array(array)
 350   , _klass(NULL)
 351   , _tmp1(tmp1)
 352   , _tmp2(tmp2)
 353   , _tmp3(tmp3)
 354   , _fast_check(false)
 355   , _info_for_patch(NULL)
 356   , _info_for_exception(info_for_exception)
 357   , _stub(NULL)
 358   , _profiled_method(NULL)
 359   , _profiled_bci(-1)
 360   , _should_profile(false)
 361   , _need_null_check(true)
 362 {
 363   if (code == lir_store_check) {
 364     _stub = new ArrayStoreExceptionStub(object, info_for_exception);
 365     assert(info_for_exception != NULL, &quot;store_check throws exceptions&quot;);
 366   } else {
 367     ShouldNotReachHere();
 368   }
 369 }
 370 
 371 LIR_OpFlattenedArrayCheck::LIR_OpFlattenedArrayCheck(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub)
 372   : LIR_Op(lir_flattened_array_check, LIR_OprFact::illegalOpr, NULL)
 373   , _array(array)
 374   , _value(value)
 375   , _tmp(tmp)
 376   , _stub(stub) {}
 377 
 378 
 379 LIR_OpNullFreeArrayCheck::LIR_OpNullFreeArrayCheck(LIR_Opr array, LIR_Opr tmp)
 380   : LIR_Op(lir_null_free_array_check, LIR_OprFact::illegalOpr, NULL)
 381   , _array(array)
 382   , _tmp(tmp) {}
 383 
 384 
 385 LIR_OpSubstitutabilityCheck::LIR_OpSubstitutabilityCheck(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,
 386                                                          LIR_Opr tmp1, LIR_Opr tmp2,
 387                                                          ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,
 388                                                          CodeEmitInfo* info, CodeStub* stub)
 389   : LIR_Op(lir_substitutability_check, result, info)
 390   , _left(left)
 391   , _right(right)
 392   , _equal_result(equal_result)
 393   , _not_equal_result(not_equal_result)
 394   , _tmp1(tmp1)
 395   , _tmp2(tmp2)
 396   , _left_klass(left_klass)
 397   , _right_klass(right_klass)
 398   , _left_klass_op(left_klass_op)
 399   , _right_klass_op(right_klass_op)
 400   , _stub(stub) {}
 401 
 402 
 403 LIR_OpArrayCopy::LIR_OpArrayCopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length,
 404                                  LIR_Opr tmp, ciArrayKlass* expected_type, int flags, CodeEmitInfo* info)
 405   : LIR_Op(lir_arraycopy, LIR_OprFact::illegalOpr, info)
 406   , _src(src)
 407   , _src_pos(src_pos)
 408   , _dst(dst)
 409   , _dst_pos(dst_pos)
 410   , _length(length)
 411   , _tmp(tmp)
 412   , _expected_type(expected_type)
 413   , _flags(flags) {
 414   _stub = new ArrayCopyStub(this);
 415 }
 416 
 417 LIR_OpUpdateCRC32::LIR_OpUpdateCRC32(LIR_Opr crc, LIR_Opr val, LIR_Opr res)
 418   : LIR_Op(lir_updatecrc32, res, NULL)
 419   , _crc(crc)
 420   , _val(val) {
 421 }
 422 
 423 //-------------------verify--------------------------
 424 
 425 void LIR_Op1::verify() const {
 426   switch(code()) {
 427   case lir_move:
 428     assert(in_opr()-&gt;is_valid() &amp;&amp; result_opr()-&gt;is_valid(), &quot;must be&quot;);
 429     break;
 430   case lir_null_check:
 431     assert(in_opr()-&gt;is_register(), &quot;must be&quot;);
 432     break;
 433   case lir_return:
 434     assert(in_opr()-&gt;is_register() || in_opr()-&gt;is_illegal(), &quot;must be&quot;);
 435     break;
 436   default:
 437     break;
 438   }
 439 }
 440 
 441 void LIR_OpRTCall::verify() const {
 442   assert(strcmp(Runtime1::name_for_address(addr()), &quot;&lt;unknown function&gt;&quot;) != 0, &quot;unknown function&quot;);
 443 }
 444 
 445 //-------------------visits--------------------------
 446 
 447 // complete rework of LIR instruction visitor.
 448 // The virtual call for each instruction type is replaced by a big
 449 // switch that adds the operands for each instruction
 450 
 451 void LIR_OpVisitState::visit(LIR_Op* op) {
 452   // copy information from the LIR_Op
 453   reset();
 454   set_op(op);
 455 
 456   switch (op-&gt;code()) {
 457 
 458 // LIR_Op0
 459     case lir_word_align:               // result and info always invalid
 460     case lir_backwardbranch_target:    // result and info always invalid
 461     case lir_build_frame:              // result and info always invalid
 462     case lir_fpop_raw:                 // result and info always invalid
 463     case lir_breakpoint:               // result and info always invalid
 464     case lir_membar:                   // result and info always invalid
 465     case lir_membar_acquire:           // result and info always invalid
 466     case lir_membar_release:           // result and info always invalid
 467     case lir_membar_loadload:          // result and info always invalid
 468     case lir_membar_storestore:        // result and info always invalid
 469     case lir_membar_loadstore:         // result and info always invalid
 470     case lir_membar_storeload:         // result and info always invalid
<a name="1" id="anc1"></a>
 471     case lir_on_spin_wait:
 472     {
 473       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 474       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 475       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 476       break;
 477     }
 478 
 479     case lir_nop:                      // may have info, result always invalid
 480     case lir_std_entry:                // may have result, info always invalid
 481     case lir_osr_entry:                // may have result, info always invalid
 482     case lir_get_thread:               // may have result, info always invalid
 483     {
 484       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 485       if (op-&gt;_info != NULL)           do_info(op-&gt;_info);
 486       if (op-&gt;_result-&gt;is_valid())     do_output(op-&gt;_result);
 487       break;
 488     }
 489 
 490 
 491 // LIR_OpLabel
 492     case lir_label:                    // result and info always invalid
 493     {
 494       assert(op-&gt;as_OpLabel() != NULL, &quot;must be&quot;);
 495       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 496       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 497       break;
 498     }
 499 
 500 
 501 // LIR_Op1
 502     case lir_fxch:           // input always valid, result and info always invalid
 503     case lir_fld:            // input always valid, result and info always invalid
 504     case lir_push:           // input always valid, result and info always invalid
 505     case lir_pop:            // input always valid, result and info always invalid
 506     case lir_return:         // input always valid, result and info always invalid
 507     case lir_leal:           // input and result always valid, info always invalid
 508     case lir_monaddr:        // input and result always valid, info always invalid
 509     case lir_null_check:     // input and info always valid, result always invalid
 510     case lir_move:           // input and result always valid, may have info
 511     case lir_pack64:         // input and result always valid
 512     case lir_unpack64:       // input and result always valid
 513     {
 514       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 515       LIR_Op1* op1 = (LIR_Op1*)op;
 516 
 517       if (op1-&gt;_info)                  do_info(op1-&gt;_info);
 518       if (op1-&gt;_opr-&gt;is_valid())       do_input(op1-&gt;_opr);
 519       if (op1-&gt;_result-&gt;is_valid())    do_output(op1-&gt;_result);
 520 
 521       break;
 522     }
 523 
 524     case lir_safepoint:
 525     {
 526       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 527       LIR_Op1* op1 = (LIR_Op1*)op;
 528 
 529       assert(op1-&gt;_info != NULL, &quot;&quot;);  do_info(op1-&gt;_info);
 530       if (op1-&gt;_opr-&gt;is_valid())       do_temp(op1-&gt;_opr); // safepoints on SPARC need temporary register
 531       assert(op1-&gt;_result-&gt;is_illegal(), &quot;safepoint does not produce value&quot;);
 532 
 533       break;
 534     }
 535 
 536 // LIR_OpConvert;
 537     case lir_convert:        // input and result always valid, info always invalid
 538     {
 539       assert(op-&gt;as_OpConvert() != NULL, &quot;must be&quot;);
 540       LIR_OpConvert* opConvert = (LIR_OpConvert*)op;
 541 
 542       assert(opConvert-&gt;_info == NULL, &quot;must be&quot;);
 543       if (opConvert-&gt;_opr-&gt;is_valid())       do_input(opConvert-&gt;_opr);
 544       if (opConvert-&gt;_result-&gt;is_valid())    do_output(opConvert-&gt;_result);
 545 #ifdef PPC32
 546       if (opConvert-&gt;_tmp1-&gt;is_valid())      do_temp(opConvert-&gt;_tmp1);
 547       if (opConvert-&gt;_tmp2-&gt;is_valid())      do_temp(opConvert-&gt;_tmp2);
 548 #endif
 549       do_stub(opConvert-&gt;_stub);
 550 
 551       break;
 552     }
 553 
 554 // LIR_OpBranch;
 555     case lir_branch:                   // may have info, input and result register always invalid
 556     case lir_cond_float_branch:        // may have info, input and result register always invalid
 557     {
 558       assert(op-&gt;as_OpBranch() != NULL, &quot;must be&quot;);
 559       LIR_OpBranch* opBranch = (LIR_OpBranch*)op;
 560 
 561       if (opBranch-&gt;_info != NULL)     do_info(opBranch-&gt;_info);
 562       assert(opBranch-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 563       if (opBranch-&gt;_stub != NULL)     opBranch-&gt;stub()-&gt;visit(this);
 564 
 565       break;
 566     }
 567 
 568 
 569 // LIR_OpAllocObj
 570     case lir_alloc_object:
 571     {
 572       assert(op-&gt;as_OpAllocObj() != NULL, &quot;must be&quot;);
 573       LIR_OpAllocObj* opAllocObj = (LIR_OpAllocObj*)op;
 574 
 575       if (opAllocObj-&gt;_info)                     do_info(opAllocObj-&gt;_info);
 576       if (opAllocObj-&gt;_opr-&gt;is_valid()) {        do_input(opAllocObj-&gt;_opr);
 577                                                  do_temp(opAllocObj-&gt;_opr);
 578                                         }
 579       if (opAllocObj-&gt;_tmp1-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp1);
 580       if (opAllocObj-&gt;_tmp2-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp2);
 581       if (opAllocObj-&gt;_tmp3-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp3);
 582       if (opAllocObj-&gt;_tmp4-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp4);
 583       if (opAllocObj-&gt;_result-&gt;is_valid())       do_output(opAllocObj-&gt;_result);
 584                                                  do_stub(opAllocObj-&gt;_stub);
 585       break;
 586     }
 587 
 588 
 589 // LIR_OpRoundFP;
 590     case lir_roundfp: {
 591       assert(op-&gt;as_OpRoundFP() != NULL, &quot;must be&quot;);
 592       LIR_OpRoundFP* opRoundFP = (LIR_OpRoundFP*)op;
 593 
 594       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 595       assert(opRoundFP-&gt;_tmp-&gt;is_illegal(), &quot;not used&quot;);
 596       do_input(opRoundFP-&gt;_opr);
 597       do_output(opRoundFP-&gt;_result);
 598 
 599       break;
 600     }
 601 
 602 
 603 // LIR_Op2
 604     case lir_cmp:
 605     case lir_cmp_l2i:
 606     case lir_ucmp_fd2i:
 607     case lir_cmp_fd2i:
 608     case lir_add:
 609     case lir_sub:
 610     case lir_mul:
 611     case lir_div:
 612     case lir_rem:
 613     case lir_sqrt:
 614     case lir_abs:
 615     case lir_neg:
 616     case lir_logic_and:
 617     case lir_logic_or:
 618     case lir_logic_xor:
 619     case lir_shl:
 620     case lir_shr:
 621     case lir_ushr:
 622     case lir_xadd:
 623     case lir_xchg:
 624     case lir_assert:
 625     {
 626       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 627       LIR_Op2* op2 = (LIR_Op2*)op;
 628       assert(op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp;
 629              op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 630 
 631       if (op2-&gt;_info)                     do_info(op2-&gt;_info);
 632       if (op2-&gt;_opr1-&gt;is_valid())         do_input(op2-&gt;_opr1);
 633       if (op2-&gt;_opr2-&gt;is_valid())         do_input(op2-&gt;_opr2);
 634       if (op2-&gt;_tmp1-&gt;is_valid())         do_temp(op2-&gt;_tmp1);
 635       if (op2-&gt;_result-&gt;is_valid())       do_output(op2-&gt;_result);
 636       if (op-&gt;code() == lir_xchg || op-&gt;code() == lir_xadd) {
 637         // on ARM and PPC, return value is loaded first so could
 638         // destroy inputs. On other platforms that implement those
 639         // (x86, sparc), the extra constrainsts are harmless.
 640         if (op2-&gt;_opr1-&gt;is_valid())       do_temp(op2-&gt;_opr1);
 641         if (op2-&gt;_opr2-&gt;is_valid())       do_temp(op2-&gt;_opr2);
 642       }
 643 
 644       break;
 645     }
 646 
 647     // special handling for cmove: right input operand must not be equal
 648     // to the result operand, otherwise the backend fails
 649     case lir_cmove:
 650     {
 651       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 652       LIR_Op2* op2 = (LIR_Op2*)op;
 653 
 654       assert(op2-&gt;_info == NULL &amp;&amp; op2-&gt;_tmp1-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp;
 655              op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 656       assert(op2-&gt;_opr1-&gt;is_valid() &amp;&amp; op2-&gt;_opr2-&gt;is_valid() &amp;&amp; op2-&gt;_result-&gt;is_valid(), &quot;used&quot;);
 657 
 658       do_input(op2-&gt;_opr1);
 659       do_input(op2-&gt;_opr2);
 660       do_temp(op2-&gt;_opr2);
 661       do_output(op2-&gt;_result);
 662 
 663       break;
 664     }
 665 
 666     // vspecial handling for strict operations: register input operands
 667     // as temp to guarantee that they do not overlap with other
 668     // registers
 669     case lir_mul_strictfp:
 670     case lir_div_strictfp:
 671     {
 672       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 673       LIR_Op2* op2 = (LIR_Op2*)op;
 674 
 675       assert(op2-&gt;_info == NULL, &quot;not used&quot;);
 676       assert(op2-&gt;_opr1-&gt;is_valid(), &quot;used&quot;);
 677       assert(op2-&gt;_opr2-&gt;is_valid(), &quot;used&quot;);
 678       assert(op2-&gt;_result-&gt;is_valid(), &quot;used&quot;);
 679       assert(op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp;
 680              op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 681 
 682       do_input(op2-&gt;_opr1); do_temp(op2-&gt;_opr1);
 683       do_input(op2-&gt;_opr2); do_temp(op2-&gt;_opr2);
 684       if (op2-&gt;_tmp1-&gt;is_valid()) do_temp(op2-&gt;_tmp1);
 685       do_output(op2-&gt;_result);
 686 
 687       break;
 688     }
 689 
 690     case lir_throw: {
 691       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 692       LIR_Op2* op2 = (LIR_Op2*)op;
 693 
 694       if (op2-&gt;_info)                     do_info(op2-&gt;_info);
 695       if (op2-&gt;_opr1-&gt;is_valid())         do_temp(op2-&gt;_opr1);
 696       if (op2-&gt;_opr2-&gt;is_valid())         do_input(op2-&gt;_opr2); // exception object is input parameter
 697       assert(op2-&gt;_result-&gt;is_illegal(), &quot;no result&quot;);
 698       assert(op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp;
 699              op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 700 
 701       break;
 702     }
 703 
 704     case lir_unwind: {
 705       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 706       LIR_Op1* op1 = (LIR_Op1*)op;
 707 
 708       assert(op1-&gt;_info == NULL, &quot;no info&quot;);
 709       assert(op1-&gt;_opr-&gt;is_valid(), &quot;exception oop&quot;);         do_input(op1-&gt;_opr);
 710       assert(op1-&gt;_result-&gt;is_illegal(), &quot;no result&quot;);
 711 
 712       break;
 713     }
 714 
 715 // LIR_Op3
 716     case lir_idiv:
 717     case lir_irem: {
 718       assert(op-&gt;as_Op3() != NULL, &quot;must be&quot;);
 719       LIR_Op3* op3= (LIR_Op3*)op;
 720 
 721       if (op3-&gt;_info)                     do_info(op3-&gt;_info);
 722       if (op3-&gt;_opr1-&gt;is_valid())         do_input(op3-&gt;_opr1);
 723 
 724       // second operand is input and temp, so ensure that second operand
 725       // and third operand get not the same register
 726       if (op3-&gt;_opr2-&gt;is_valid())         do_input(op3-&gt;_opr2);
 727       if (op3-&gt;_opr2-&gt;is_valid())         do_temp(op3-&gt;_opr2);
 728       if (op3-&gt;_opr3-&gt;is_valid())         do_temp(op3-&gt;_opr3);
 729 
 730       if (op3-&gt;_result-&gt;is_valid())       do_output(op3-&gt;_result);
 731 
 732       break;
 733     }
 734 
 735     case lir_fmad:
 736     case lir_fmaf: {
 737       assert(op-&gt;as_Op3() != NULL, &quot;must be&quot;);
 738       LIR_Op3* op3= (LIR_Op3*)op;
 739       assert(op3-&gt;_info == NULL, &quot;no info&quot;);
 740       do_input(op3-&gt;_opr1);
 741       do_input(op3-&gt;_opr2);
 742       do_input(op3-&gt;_opr3);
 743       do_output(op3-&gt;_result);
 744       break;
 745     }
 746 
 747 // LIR_OpJavaCall
 748     case lir_static_call:
 749     case lir_optvirtual_call:
 750     case lir_icvirtual_call:
 751     case lir_virtual_call:
 752     case lir_dynamic_call: {
 753       LIR_OpJavaCall* opJavaCall = op-&gt;as_OpJavaCall();
 754       assert(opJavaCall != NULL, &quot;must be&quot;);
 755 
 756       if (opJavaCall-&gt;_receiver-&gt;is_valid())     do_input(opJavaCall-&gt;_receiver);
 757 
 758       // only visit register parameters
 759       int n = opJavaCall-&gt;_arguments-&gt;length();
 760       for (int i = opJavaCall-&gt;_receiver-&gt;is_valid() ? 1 : 0; i &lt; n; i++) {
 761         if (!opJavaCall-&gt;_arguments-&gt;at(i)-&gt;is_pointer()) {
 762           do_input(*opJavaCall-&gt;_arguments-&gt;adr_at(i));
 763         }
 764       }
 765 
 766       if (opJavaCall-&gt;_info)                     do_info(opJavaCall-&gt;_info);
 767       if (FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr &amp;&amp;
 768           opJavaCall-&gt;is_method_handle_invoke()) {
 769         opJavaCall-&gt;_method_handle_invoke_SP_save_opr = FrameMap::method_handle_invoke_SP_save_opr();
 770         do_temp(opJavaCall-&gt;_method_handle_invoke_SP_save_opr);
 771       }
 772       do_call();
 773       if (opJavaCall-&gt;_result-&gt;is_valid())       do_output(opJavaCall-&gt;_result);
 774 
 775       break;
 776     }
 777 
 778 
 779 // LIR_OpRTCall
 780     case lir_rtcall: {
 781       assert(op-&gt;as_OpRTCall() != NULL, &quot;must be&quot;);
 782       LIR_OpRTCall* opRTCall = (LIR_OpRTCall*)op;
 783 
 784       // only visit register parameters
 785       int n = opRTCall-&gt;_arguments-&gt;length();
 786       for (int i = 0; i &lt; n; i++) {
 787         if (!opRTCall-&gt;_arguments-&gt;at(i)-&gt;is_pointer()) {
 788           do_input(*opRTCall-&gt;_arguments-&gt;adr_at(i));
 789         }
 790       }
 791       if (opRTCall-&gt;_info)                     do_info(opRTCall-&gt;_info);
 792       if (opRTCall-&gt;_tmp-&gt;is_valid())          do_temp(opRTCall-&gt;_tmp);
 793       do_call();
 794       if (opRTCall-&gt;_result-&gt;is_valid())       do_output(opRTCall-&gt;_result);
 795 
 796       break;
 797     }
 798 
 799 
 800 // LIR_OpArrayCopy
 801     case lir_arraycopy: {
 802       assert(op-&gt;as_OpArrayCopy() != NULL, &quot;must be&quot;);
 803       LIR_OpArrayCopy* opArrayCopy = (LIR_OpArrayCopy*)op;
 804 
 805       assert(opArrayCopy-&gt;_result-&gt;is_illegal(), &quot;unused&quot;);
 806       assert(opArrayCopy-&gt;_src-&gt;is_valid(), &quot;used&quot;);          do_input(opArrayCopy-&gt;_src);     do_temp(opArrayCopy-&gt;_src);
 807       assert(opArrayCopy-&gt;_src_pos-&gt;is_valid(), &quot;used&quot;);      do_input(opArrayCopy-&gt;_src_pos); do_temp(opArrayCopy-&gt;_src_pos);
 808       assert(opArrayCopy-&gt;_dst-&gt;is_valid(), &quot;used&quot;);          do_input(opArrayCopy-&gt;_dst);     do_temp(opArrayCopy-&gt;_dst);
 809       assert(opArrayCopy-&gt;_dst_pos-&gt;is_valid(), &quot;used&quot;);      do_input(opArrayCopy-&gt;_dst_pos); do_temp(opArrayCopy-&gt;_dst_pos);
 810       assert(opArrayCopy-&gt;_length-&gt;is_valid(), &quot;used&quot;);       do_input(opArrayCopy-&gt;_length);  do_temp(opArrayCopy-&gt;_length);
 811       assert(opArrayCopy-&gt;_tmp-&gt;is_valid(), &quot;used&quot;);          do_temp(opArrayCopy-&gt;_tmp);
 812       if (opArrayCopy-&gt;_info)                     do_info(opArrayCopy-&gt;_info);
 813 
 814       // the implementation of arraycopy always has a call into the runtime
 815       do_call();
 816 
 817       break;
 818     }
 819 
 820 
 821 // LIR_OpUpdateCRC32
 822     case lir_updatecrc32: {
 823       assert(op-&gt;as_OpUpdateCRC32() != NULL, &quot;must be&quot;);
 824       LIR_OpUpdateCRC32* opUp = (LIR_OpUpdateCRC32*)op;
 825 
 826       assert(opUp-&gt;_crc-&gt;is_valid(), &quot;used&quot;);          do_input(opUp-&gt;_crc);     do_temp(opUp-&gt;_crc);
 827       assert(opUp-&gt;_val-&gt;is_valid(), &quot;used&quot;);          do_input(opUp-&gt;_val);     do_temp(opUp-&gt;_val);
 828       assert(opUp-&gt;_result-&gt;is_valid(), &quot;used&quot;);       do_output(opUp-&gt;_result);
 829       assert(opUp-&gt;_info == NULL, &quot;no info for LIR_OpUpdateCRC32&quot;);
 830 
 831       break;
 832     }
 833 
 834 
 835 // LIR_OpLock
 836     case lir_lock:
 837     case lir_unlock: {
 838       assert(op-&gt;as_OpLock() != NULL, &quot;must be&quot;);
 839       LIR_OpLock* opLock = (LIR_OpLock*)op;
 840 
 841       if (opLock-&gt;_info)                          do_info(opLock-&gt;_info);
 842 
 843       // TODO: check if these operands really have to be temp
 844       // (or if input is sufficient). This may have influence on the oop map!
 845       assert(opLock-&gt;_lock-&gt;is_valid(), &quot;used&quot;);  do_temp(opLock-&gt;_lock);
 846       assert(opLock-&gt;_hdr-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_hdr);
 847       assert(opLock-&gt;_obj-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_obj);
 848 
 849       if (opLock-&gt;_scratch-&gt;is_valid())           do_temp(opLock-&gt;_scratch);
 850       assert(opLock-&gt;_result-&gt;is_illegal(), &quot;unused&quot;);
 851 
 852       do_stub(opLock-&gt;_stub);
 853       do_stub(opLock-&gt;_throw_imse_stub);
 854 
 855       break;
 856     }
 857 
 858 
 859 // LIR_OpDelay
 860     case lir_delay_slot: {
 861       assert(op-&gt;as_OpDelay() != NULL, &quot;must be&quot;);
 862       LIR_OpDelay* opDelay = (LIR_OpDelay*)op;
 863 
 864       visit(opDelay-&gt;delay_op());
 865       break;
 866     }
 867 
 868 // LIR_OpTypeCheck
 869     case lir_instanceof:
 870     case lir_checkcast:
 871     case lir_store_check: {
 872       assert(op-&gt;as_OpTypeCheck() != NULL, &quot;must be&quot;);
 873       LIR_OpTypeCheck* opTypeCheck = (LIR_OpTypeCheck*)op;
 874 
 875       if (opTypeCheck-&gt;_info_for_exception)       do_info(opTypeCheck-&gt;_info_for_exception);
 876       if (opTypeCheck-&gt;_info_for_patch)           do_info(opTypeCheck-&gt;_info_for_patch);
 877       if (opTypeCheck-&gt;_object-&gt;is_valid())       do_input(opTypeCheck-&gt;_object);
 878       if (op-&gt;code() == lir_store_check &amp;&amp; opTypeCheck-&gt;_object-&gt;is_valid()) {
 879         do_temp(opTypeCheck-&gt;_object);
 880       }
 881       if (opTypeCheck-&gt;_array-&gt;is_valid())        do_input(opTypeCheck-&gt;_array);
 882       if (opTypeCheck-&gt;_tmp1-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp1);
 883       if (opTypeCheck-&gt;_tmp2-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp2);
 884       if (opTypeCheck-&gt;_tmp3-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp3);
 885       if (opTypeCheck-&gt;_result-&gt;is_valid())       do_output(opTypeCheck-&gt;_result);
 886                                                   do_stub(opTypeCheck-&gt;_stub);
 887       break;
 888     }
 889 
 890 // LIR_OpFlattenedArrayCheck
 891     case lir_flattened_array_check: {
 892       assert(op-&gt;as_OpFlattenedArrayCheck() != NULL, &quot;must be&quot;);
 893       LIR_OpFlattenedArrayCheck* opFlattenedArrayCheck = (LIR_OpFlattenedArrayCheck*)op;
 894 
 895       if (opFlattenedArrayCheck-&gt;_array-&gt;is_valid()) do_input(opFlattenedArrayCheck-&gt;_array);
 896       if (opFlattenedArrayCheck-&gt;_value-&gt;is_valid()) do_input(opFlattenedArrayCheck-&gt;_value);
 897       if (opFlattenedArrayCheck-&gt;_tmp-&gt;is_valid())   do_temp(opFlattenedArrayCheck-&gt;_tmp);
 898                                                      do_stub(opFlattenedArrayCheck-&gt;_stub);
 899 
 900       break;
 901     }
 902 
 903 // LIR_OpNullFreeArrayCheck
 904     case lir_null_free_array_check: {
 905       assert(op-&gt;as_OpNullFreeArrayCheck() != NULL, &quot;must be&quot;);
 906       LIR_OpNullFreeArrayCheck* opNullFreeArrayCheck = (LIR_OpNullFreeArrayCheck*)op;
 907 
 908       if (opNullFreeArrayCheck-&gt;_array-&gt;is_valid()) do_input(opNullFreeArrayCheck-&gt;_array);
 909       if (opNullFreeArrayCheck-&gt;_tmp-&gt;is_valid())   do_temp(opNullFreeArrayCheck-&gt;_tmp);
 910       break;
 911     }
 912 
 913 // LIR_OpSubstitutabilityCheck
 914     case lir_substitutability_check: {
 915       assert(op-&gt;as_OpSubstitutabilityCheck() != NULL, &quot;must be&quot;);
 916       LIR_OpSubstitutabilityCheck* opSubstitutabilityCheck = (LIR_OpSubstitutabilityCheck*)op;
 917                                                                 do_input(opSubstitutabilityCheck-&gt;_left);
 918                                                                 do_temp (opSubstitutabilityCheck-&gt;_left);
 919                                                                 do_input(opSubstitutabilityCheck-&gt;_right);
 920                                                                 do_temp (opSubstitutabilityCheck-&gt;_right);
 921                                                                 do_input(opSubstitutabilityCheck-&gt;_equal_result);
 922                                                                 do_temp (opSubstitutabilityCheck-&gt;_equal_result);
 923                                                                 do_input(opSubstitutabilityCheck-&gt;_not_equal_result);
 924                                                                 do_temp (opSubstitutabilityCheck-&gt;_not_equal_result);
 925       if (opSubstitutabilityCheck-&gt;_tmp1-&gt;is_valid())           do_temp(opSubstitutabilityCheck-&gt;_tmp1);
 926       if (opSubstitutabilityCheck-&gt;_tmp2-&gt;is_valid())           do_temp(opSubstitutabilityCheck-&gt;_tmp2);
 927       if (opSubstitutabilityCheck-&gt;_left_klass_op-&gt;is_valid())  do_temp(opSubstitutabilityCheck-&gt;_left_klass_op);
 928       if (opSubstitutabilityCheck-&gt;_right_klass_op-&gt;is_valid()) do_temp(opSubstitutabilityCheck-&gt;_right_klass_op);
 929       if (opSubstitutabilityCheck-&gt;_result-&gt;is_valid())         do_output(opSubstitutabilityCheck-&gt;_result);
 930                                                                 do_info(opSubstitutabilityCheck-&gt;_info);
 931                                                                 do_stub(opSubstitutabilityCheck-&gt;_stub);
 932       break;
 933     }
 934 
 935 // LIR_OpCompareAndSwap
 936     case lir_cas_long:
 937     case lir_cas_obj:
 938     case lir_cas_int: {
 939       assert(op-&gt;as_OpCompareAndSwap() != NULL, &quot;must be&quot;);
 940       LIR_OpCompareAndSwap* opCompareAndSwap = (LIR_OpCompareAndSwap*)op;
 941 
 942       assert(opCompareAndSwap-&gt;_addr-&gt;is_valid(),      &quot;used&quot;);
 943       assert(opCompareAndSwap-&gt;_cmp_value-&gt;is_valid(), &quot;used&quot;);
 944       assert(opCompareAndSwap-&gt;_new_value-&gt;is_valid(), &quot;used&quot;);
 945       if (opCompareAndSwap-&gt;_info)                    do_info(opCompareAndSwap-&gt;_info);
 946                                                       do_input(opCompareAndSwap-&gt;_addr);
 947                                                       do_temp(opCompareAndSwap-&gt;_addr);
 948                                                       do_input(opCompareAndSwap-&gt;_cmp_value);
 949                                                       do_temp(opCompareAndSwap-&gt;_cmp_value);
 950                                                       do_input(opCompareAndSwap-&gt;_new_value);
 951                                                       do_temp(opCompareAndSwap-&gt;_new_value);
 952       if (opCompareAndSwap-&gt;_tmp1-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp1);
 953       if (opCompareAndSwap-&gt;_tmp2-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp2);
 954       if (opCompareAndSwap-&gt;_result-&gt;is_valid())      do_output(opCompareAndSwap-&gt;_result);
 955 
 956       break;
 957     }
 958 
 959 
 960 // LIR_OpAllocArray;
 961     case lir_alloc_array: {
 962       assert(op-&gt;as_OpAllocArray() != NULL, &quot;must be&quot;);
 963       LIR_OpAllocArray* opAllocArray = (LIR_OpAllocArray*)op;
 964 
 965       if (opAllocArray-&gt;_info)                        do_info(opAllocArray-&gt;_info);
 966       if (opAllocArray-&gt;_klass-&gt;is_valid())           do_input(opAllocArray-&gt;_klass); do_temp(opAllocArray-&gt;_klass);
 967       if (opAllocArray-&gt;_len-&gt;is_valid())             do_input(opAllocArray-&gt;_len);   do_temp(opAllocArray-&gt;_len);
 968       if (opAllocArray-&gt;_tmp1-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp1);
 969       if (opAllocArray-&gt;_tmp2-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp2);
 970       if (opAllocArray-&gt;_tmp3-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp3);
 971       if (opAllocArray-&gt;_tmp4-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp4);
 972       if (opAllocArray-&gt;_result-&gt;is_valid())          do_output(opAllocArray-&gt;_result);
 973                                                       do_stub(opAllocArray-&gt;_stub);
 974       break;
 975     }
 976 
 977 // LIR_OpProfileCall:
 978     case lir_profile_call: {
 979       assert(op-&gt;as_OpProfileCall() != NULL, &quot;must be&quot;);
 980       LIR_OpProfileCall* opProfileCall = (LIR_OpProfileCall*)op;
 981 
 982       if (opProfileCall-&gt;_recv-&gt;is_valid())              do_temp(opProfileCall-&gt;_recv);
 983       assert(opProfileCall-&gt;_mdo-&gt;is_valid(), &quot;used&quot;);   do_temp(opProfileCall-&gt;_mdo);
 984       assert(opProfileCall-&gt;_tmp1-&gt;is_valid(), &quot;used&quot;);  do_temp(opProfileCall-&gt;_tmp1);
 985       break;
 986     }
 987 
 988 // LIR_OpProfileType:
 989     case lir_profile_type: {
 990       assert(op-&gt;as_OpProfileType() != NULL, &quot;must be&quot;);
 991       LIR_OpProfileType* opProfileType = (LIR_OpProfileType*)op;
 992 
 993       do_input(opProfileType-&gt;_mdp); do_temp(opProfileType-&gt;_mdp);
 994       do_input(opProfileType-&gt;_obj);
 995       do_temp(opProfileType-&gt;_tmp);
 996       break;
 997     }
 998   default:
 999     op-&gt;visit(this);
1000   }
1001 }
1002 
1003 void LIR_Op::visit(LIR_OpVisitState* state) {
1004   ShouldNotReachHere();
1005 }
1006 
1007 void LIR_OpVisitState::do_stub(CodeStub* stub) {
1008   if (stub != NULL) {
1009     stub-&gt;visit(this);
1010   }
1011 }
1012 
1013 XHandlers* LIR_OpVisitState::all_xhandler() {
1014   XHandlers* result = NULL;
1015 
1016   int i;
1017   for (i = 0; i &lt; info_count(); i++) {
1018     if (info_at(i)-&gt;exception_handlers() != NULL) {
1019       result = info_at(i)-&gt;exception_handlers();
1020       break;
1021     }
1022   }
1023 
1024 #ifdef ASSERT
1025   for (i = 0; i &lt; info_count(); i++) {
1026     assert(info_at(i)-&gt;exception_handlers() == NULL ||
1027            info_at(i)-&gt;exception_handlers() == result,
1028            &quot;only one xhandler list allowed per LIR-operation&quot;);
1029   }
1030 #endif
1031 
1032   if (result != NULL) {
1033     return result;
1034   } else {
1035     return new XHandlers();
1036   }
1037 
1038   return result;
1039 }
1040 
1041 
1042 #ifdef ASSERT
1043 bool LIR_OpVisitState::no_operands(LIR_Op* op) {
1044   visit(op);
1045 
1046   return opr_count(inputMode) == 0 &amp;&amp;
1047          opr_count(outputMode) == 0 &amp;&amp;
1048          opr_count(tempMode) == 0 &amp;&amp;
1049          info_count() == 0 &amp;&amp;
1050          !has_call() &amp;&amp;
1051          !has_slow_case();
1052 }
1053 #endif
1054 
1055 //---------------------------------------------------
1056 
1057 
1058 void LIR_OpJavaCall::emit_code(LIR_Assembler* masm) {
1059   masm-&gt;emit_call(this);
1060 }
1061 
1062 bool LIR_OpJavaCall::maybe_return_as_fields(ciValueKlass** vk_ret) const {
1063   if (ValueTypeReturnedAsFields) {
1064     if (method()-&gt;signature()-&gt;maybe_returns_never_null()) {
1065       ciType* return_type = method()-&gt;return_type();
1066       if (return_type-&gt;is_valuetype()) {
1067         ciValueKlass* vk = return_type-&gt;as_value_klass();
1068         if (vk-&gt;can_be_returned_as_fields()) {
1069           if (vk_ret != NULL) {
1070             *vk_ret = vk;
1071           }
1072           return true;
1073         }
1074       } else {
1075         assert(return_type-&gt;is_instance_klass() &amp;&amp; !return_type-&gt;as_instance_klass()-&gt;is_loaded(), &quot;must be&quot;);
1076         if (vk_ret != NULL) {
1077           *vk_ret = NULL;
1078         }
1079         return true;
1080       }
1081     } else if (is_method_handle_invoke()) {
1082       BasicType bt = method()-&gt;return_type()-&gt;basic_type();
1083       if (bt == T_OBJECT || bt == T_VALUETYPE) {
1084         // A value type might be returned from the call but we don&#39;t know its
1085         // type. Either we get a buffered value (and nothing needs to be done)
1086         // or one of the values being returned is the klass of the value type
1087         // (RAX on x64, with LSB set to 1) and we need to allocate a value
1088         // type instance of that type and initialize it with other values being
1089         // returned (in other registers).
1090         // type.
1091         if (vk_ret != NULL) {
1092           *vk_ret = NULL;
1093         }
1094         return true;
1095       }
1096     }
1097   }
1098   return false;
1099 }
1100 
1101 void LIR_OpRTCall::emit_code(LIR_Assembler* masm) {
1102   masm-&gt;emit_rtcall(this);
1103 }
1104 
1105 void LIR_OpLabel::emit_code(LIR_Assembler* masm) {
1106   masm-&gt;emit_opLabel(this);
1107 }
1108 
1109 void LIR_OpArrayCopy::emit_code(LIR_Assembler* masm) {
1110   masm-&gt;emit_arraycopy(this);
1111   masm-&gt;append_code_stub(stub());
1112 }
1113 
1114 void LIR_OpUpdateCRC32::emit_code(LIR_Assembler* masm) {
1115   masm-&gt;emit_updatecrc32(this);
1116 }
1117 
1118 void LIR_Op0::emit_code(LIR_Assembler* masm) {
1119   masm-&gt;emit_op0(this);
1120 }
1121 
1122 void LIR_Op1::emit_code(LIR_Assembler* masm) {
1123   masm-&gt;emit_op1(this);
1124 }
1125 
1126 void LIR_OpAllocObj::emit_code(LIR_Assembler* masm) {
1127   masm-&gt;emit_alloc_obj(this);
1128   masm-&gt;append_code_stub(stub());
1129 }
1130 
1131 void LIR_OpBranch::emit_code(LIR_Assembler* masm) {
1132   masm-&gt;emit_opBranch(this);
1133   if (stub()) {
1134     masm-&gt;append_code_stub(stub());
1135   }
1136 }
1137 
1138 void LIR_OpConvert::emit_code(LIR_Assembler* masm) {
1139   masm-&gt;emit_opConvert(this);
1140   if (stub() != NULL) {
1141     masm-&gt;append_code_stub(stub());
1142   }
1143 }
1144 
1145 void LIR_Op2::emit_code(LIR_Assembler* masm) {
1146   masm-&gt;emit_op2(this);
1147 }
1148 
1149 void LIR_OpAllocArray::emit_code(LIR_Assembler* masm) {
1150   masm-&gt;emit_alloc_array(this);
1151   masm-&gt;append_code_stub(stub());
1152 }
1153 
1154 void LIR_OpTypeCheck::emit_code(LIR_Assembler* masm) {
1155   masm-&gt;emit_opTypeCheck(this);
1156   if (stub()) {
1157     masm-&gt;append_code_stub(stub());
1158   }
1159 }
1160 
1161 void LIR_OpFlattenedArrayCheck::emit_code(LIR_Assembler* masm) {
1162   masm-&gt;emit_opFlattenedArrayCheck(this);
1163   if (stub() != NULL) {
1164     masm-&gt;append_code_stub(stub());
1165   }
1166 }
1167 
1168 void LIR_OpNullFreeArrayCheck::emit_code(LIR_Assembler* masm) {
1169   masm-&gt;emit_opNullFreeArrayCheck(this);
1170 }
1171 
1172 void LIR_OpSubstitutabilityCheck::emit_code(LIR_Assembler* masm) {
1173   masm-&gt;emit_opSubstitutabilityCheck(this);
1174   if (stub() != NULL) {
1175     masm-&gt;append_code_stub(stub());
1176   }
1177 }
1178 
1179 void LIR_OpCompareAndSwap::emit_code(LIR_Assembler* masm) {
1180   masm-&gt;emit_compare_and_swap(this);
1181 }
1182 
1183 void LIR_Op3::emit_code(LIR_Assembler* masm) {
1184   masm-&gt;emit_op3(this);
1185 }
1186 
1187 void LIR_OpLock::emit_code(LIR_Assembler* masm) {
1188   masm-&gt;emit_lock(this);
1189   if (stub()) {
1190     masm-&gt;append_code_stub(stub());
1191   }
1192   if (throw_imse_stub()) {
1193     masm-&gt;append_code_stub(throw_imse_stub());
1194   }
1195 }
1196 
1197 #ifdef ASSERT
1198 void LIR_OpAssert::emit_code(LIR_Assembler* masm) {
1199   masm-&gt;emit_assert(this);
1200 }
1201 #endif
1202 
1203 void LIR_OpDelay::emit_code(LIR_Assembler* masm) {
1204   masm-&gt;emit_delay(this);
1205 }
1206 
1207 void LIR_OpProfileCall::emit_code(LIR_Assembler* masm) {
1208   masm-&gt;emit_profile_call(this);
1209 }
1210 
1211 void LIR_OpProfileType::emit_code(LIR_Assembler* masm) {
1212   masm-&gt;emit_profile_type(this);
1213 }
1214 
1215 // LIR_List
1216 LIR_List::LIR_List(Compilation* compilation, BlockBegin* block)
1217   : _operations(8)
1218   , _compilation(compilation)
1219 #ifndef PRODUCT
1220   , _block(block)
1221 #endif
1222 #ifdef ASSERT
1223   , _file(NULL)
1224   , _line(0)
1225 #endif
1226 { }
1227 
1228 
1229 #ifdef ASSERT
1230 void LIR_List::set_file_and_line(const char * file, int line) {
1231   const char * f = strrchr(file, &#39;/&#39;);
1232   if (f == NULL) f = strrchr(file, &#39;\\&#39;);
1233   if (f == NULL) {
1234     f = file;
1235   } else {
1236     f++;
1237   }
1238   _file = f;
1239   _line = line;
1240 }
1241 #endif
1242 
1243 
1244 void LIR_List::append(LIR_InsertionBuffer* buffer) {
1245   assert(this == buffer-&gt;lir_list(), &quot;wrong lir list&quot;);
1246   const int n = _operations.length();
1247 
1248   if (buffer-&gt;number_of_ops() &gt; 0) {
1249     // increase size of instructions list
1250     _operations.at_grow(n + buffer-&gt;number_of_ops() - 1, NULL);
1251     // insert ops from buffer into instructions list
1252     int op_index = buffer-&gt;number_of_ops() - 1;
1253     int ip_index = buffer-&gt;number_of_insertion_points() - 1;
1254     int from_index = n - 1;
1255     int to_index = _operations.length() - 1;
1256     for (; ip_index &gt;= 0; ip_index --) {
1257       int index = buffer-&gt;index_at(ip_index);
1258       // make room after insertion point
1259       while (index &lt; from_index) {
1260         _operations.at_put(to_index --, _operations.at(from_index --));
1261       }
1262       // insert ops from buffer
1263       for (int i = buffer-&gt;count_at(ip_index); i &gt; 0; i --) {
1264         _operations.at_put(to_index --, buffer-&gt;op_at(op_index --));
1265       }
1266     }
1267   }
1268 
1269   buffer-&gt;finish();
1270 }
1271 
1272 
1273 void LIR_List::oop2reg_patch(jobject o, LIR_Opr reg, CodeEmitInfo* info) {
1274   assert(reg-&gt;type() == T_OBJECT, &quot;bad reg&quot;);
1275   append(new LIR_Op1(lir_move, LIR_OprFact::oopConst(o),  reg, T_OBJECT, lir_patch_normal, info));
1276 }
1277 
1278 void LIR_List::klass2reg_patch(Metadata* o, LIR_Opr reg, CodeEmitInfo* info) {
1279   assert(reg-&gt;type() == T_METADATA, &quot;bad reg&quot;);
1280   append(new LIR_Op1(lir_move, LIR_OprFact::metadataConst(o), reg, T_METADATA, lir_patch_normal, info));
1281 }
1282 
1283 void LIR_List::load(LIR_Address* addr, LIR_Opr src, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1284   append(new LIR_Op1(
1285             lir_move,
1286             LIR_OprFact::address(addr),
1287             src,
1288             addr-&gt;type(),
1289             patch_code,
1290             info));
1291 }
1292 
1293 
1294 void LIR_List::volatile_load_mem_reg(LIR_Address* address, LIR_Opr dst, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1295   append(new LIR_Op1(
1296             lir_move,
1297             LIR_OprFact::address(address),
1298             dst,
1299             address-&gt;type(),
1300             patch_code,
1301             info, lir_move_volatile));
1302 }
1303 
1304 void LIR_List::volatile_load_unsafe_reg(LIR_Opr base, LIR_Opr offset, LIR_Opr dst, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1305   append(new LIR_Op1(
1306             lir_move,
1307             LIR_OprFact::address(new LIR_Address(base, offset, type)),
1308             dst,
1309             type,
1310             patch_code,
1311             info, lir_move_volatile));
1312 }
1313 
1314 
1315 void LIR_List::store_mem_int(jint v, LIR_Opr base, int offset_in_bytes, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1316   append(new LIR_Op1(
1317             lir_move,
1318             LIR_OprFact::intConst(v),
1319             LIR_OprFact::address(new LIR_Address(base, offset_in_bytes, type)),
1320             type,
1321             patch_code,
1322             info));
1323 }
1324 
1325 
1326 void LIR_List::store_mem_oop(jobject o, LIR_Opr base, int offset_in_bytes, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1327   append(new LIR_Op1(
1328             lir_move,
1329             LIR_OprFact::oopConst(o),
1330             LIR_OprFact::address(new LIR_Address(base, offset_in_bytes, type)),
1331             type,
1332             patch_code,
1333             info));
1334 }
1335 
1336 
1337 void LIR_List::store(LIR_Opr src, LIR_Address* addr, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1338   append(new LIR_Op1(
1339             lir_move,
1340             src,
1341             LIR_OprFact::address(addr),
1342             addr-&gt;type(),
1343             patch_code,
1344             info));
1345 }
1346 
1347 
1348 void LIR_List::volatile_store_mem_reg(LIR_Opr src, LIR_Address* addr, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1349   append(new LIR_Op1(
1350             lir_move,
1351             src,
1352             LIR_OprFact::address(addr),
1353             addr-&gt;type(),
1354             patch_code,
1355             info,
1356             lir_move_volatile));
1357 }
1358 
1359 void LIR_List::volatile_store_unsafe_reg(LIR_Opr src, LIR_Opr base, LIR_Opr offset, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1360   append(new LIR_Op1(
1361             lir_move,
1362             src,
1363             LIR_OprFact::address(new LIR_Address(base, offset, type)),
1364             type,
1365             patch_code,
1366             info, lir_move_volatile));
1367 }
1368 
1369 
1370 void LIR_List::idiv(LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1371   append(new LIR_Op3(
1372                     lir_idiv,
1373                     left,
1374                     right,
1375                     tmp,
1376                     res,
1377                     info));
1378 }
1379 
1380 
1381 void LIR_List::idiv(LIR_Opr left, int right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1382   append(new LIR_Op3(
1383                     lir_idiv,
1384                     left,
1385                     LIR_OprFact::intConst(right),
1386                     tmp,
1387                     res,
1388                     info));
1389 }
1390 
1391 
1392 void LIR_List::irem(LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1393   append(new LIR_Op3(
1394                     lir_irem,
1395                     left,
1396                     right,
1397                     tmp,
1398                     res,
1399                     info));
1400 }
1401 
1402 
1403 void LIR_List::irem(LIR_Opr left, int right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1404   append(new LIR_Op3(
1405                     lir_irem,
1406                     left,
1407                     LIR_OprFact::intConst(right),
1408                     tmp,
1409                     res,
1410                     info));
1411 }
1412 
1413 
1414 void LIR_List::cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info) {
1415   append(new LIR_Op2(
1416                     lir_cmp,
1417                     condition,
1418                     LIR_OprFact::address(new LIR_Address(base, disp, T_INT)),
1419                     LIR_OprFact::intConst(c),
1420                     info));
1421 }
1422 
1423 
1424 void LIR_List::cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Address* addr, CodeEmitInfo* info) {
1425   append(new LIR_Op2(
1426                     lir_cmp,
1427                     condition,
1428                     reg,
1429                     LIR_OprFact::address(addr),
1430                     info));
1431 }
1432 
1433 void LIR_List::allocate_object(LIR_Opr dst, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4,
1434                                int header_size, int object_size, LIR_Opr klass, bool init_check, CodeStub* stub) {
1435   append(new LIR_OpAllocObj(
1436                            klass,
1437                            dst,
1438                            t1,
1439                            t2,
1440                            t3,
1441                            t4,
1442                            header_size,
1443                            object_size,
1444                            init_check,
1445                            stub));
1446 }
1447 
1448 void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub) {
1449   append(new LIR_OpAllocArray(
1450                            klass,
1451                            len,
1452                            dst,
1453                            t1,
1454                            t2,
1455                            t3,
1456                            t4,
1457                            type,
1458                            stub));
1459 }
1460 
1461 void LIR_List::shift_left(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1462  append(new LIR_Op2(
1463                     lir_shl,
1464                     value,
1465                     count,
1466                     dst,
1467                     tmp));
1468 }
1469 
1470 void LIR_List::shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1471  append(new LIR_Op2(
1472                     lir_shr,
1473                     value,
1474                     count,
1475                     dst,
1476                     tmp));
1477 }
1478 
1479 
1480 void LIR_List::unsigned_shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1481  append(new LIR_Op2(
1482                     lir_ushr,
1483                     value,
1484                     count,
1485                     dst,
1486                     tmp));
1487 }
1488 
1489 void LIR_List::fcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst, bool is_unordered_less) {
1490   append(new LIR_Op2(is_unordered_less ? lir_ucmp_fd2i : lir_cmp_fd2i,
1491                      left,
1492                      right,
1493                      dst));
1494 }
1495 
1496 void LIR_List::lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info, CodeStub* throw_imse_stub) {
1497   append(new LIR_OpLock(
1498                     lir_lock,
1499                     hdr,
1500                     obj,
1501                     lock,
1502                     scratch,
1503                     stub,
1504                     info,
1505                     throw_imse_stub));
1506 }
1507 
1508 void LIR_List::unlock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub) {
1509   append(new LIR_OpLock(
1510                     lir_unlock,
1511                     hdr,
1512                     obj,
1513                     lock,
1514                     scratch,
1515                     stub,
1516                     NULL));
1517 }
1518 
1519 
1520 void check_LIR() {
1521   // cannot do the proper checking as PRODUCT and other modes return different results
1522   // guarantee(sizeof(LIR_OprDesc) == wordSize, &quot;may not have a v-table&quot;);
1523 }
1524 
1525 
1526 
1527 void LIR_List::checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
1528                           LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
1529                           CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
1530                           ciMethod* profiled_method, int profiled_bci, bool is_never_null) {
1531   // If klass is non-nullable,  LIRGenerator::do_CheckCast has already performed null-check
1532   // on the object.
1533   bool need_null_check = !is_never_null;
1534   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_checkcast, result, object, klass,
1535                                            tmp1, tmp2, tmp3, fast_check, info_for_exception, info_for_patch, stub,
1536                                            need_null_check);
1537   if (profiled_method != NULL) {
1538     c-&gt;set_profiled_method(profiled_method);
1539     c-&gt;set_profiled_bci(profiled_bci);
1540     c-&gt;set_should_profile(true);
1541   }
1542   append(c);
1543 }
1544 
1545 void LIR_List::instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci) {
1546   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, fast_check, NULL, info_for_patch, NULL);
1547   if (profiled_method != NULL) {
1548     c-&gt;set_profiled_method(profiled_method);
1549     c-&gt;set_profiled_bci(profiled_bci);
1550     c-&gt;set_should_profile(true);
1551   }
1552   append(c);
1553 }
1554 
1555 
1556 void LIR_List::store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
1557                            CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci) {
1558   // FIXME -- if the types of the array and/or the object are known statically, we can avoid loading the klass
1559   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_store_check, object, array, tmp1, tmp2, tmp3, info_for_exception);
1560   if (profiled_method != NULL) {
1561     c-&gt;set_profiled_method(profiled_method);
1562     c-&gt;set_profiled_bci(profiled_bci);
1563     c-&gt;set_should_profile(true);
1564   }
1565   append(c);
1566 }
1567 
1568 void LIR_List::null_check(LIR_Opr opr, CodeEmitInfo* info, bool deoptimize_on_null) {
1569   if (deoptimize_on_null) {
1570     // Emit an explicit null check and deoptimize if opr is null
1571     CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_null_check, Deoptimization::Action_none);
1572     cmp(lir_cond_equal, opr, LIR_OprFact::oopConst(NULL));
1573     branch(lir_cond_equal, T_OBJECT, deopt);
1574   } else {
1575     // Emit an implicit null check
1576     append(new LIR_Op1(lir_null_check, opr, info));
1577   }
1578 }
1579 
1580 void LIR_List::check_flattened_array(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub) {
1581   LIR_OpFlattenedArrayCheck* c = new LIR_OpFlattenedArrayCheck(array, value, tmp, stub);
1582   append(c);
1583 }
1584 
1585 void LIR_List::check_null_free_array(LIR_Opr array, LIR_Opr tmp) {
1586   LIR_OpNullFreeArrayCheck* c = new LIR_OpNullFreeArrayCheck(array, tmp);
1587   append(c);
1588 }
1589 
1590 void LIR_List::substitutability_check(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,
1591                                       LIR_Opr tmp1, LIR_Opr tmp2,
1592                                       ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,
1593                                       CodeEmitInfo* info, CodeStub* stub) {
1594   LIR_OpSubstitutabilityCheck* c = new LIR_OpSubstitutabilityCheck(result, left, right, equal_result, not_equal_result,
1595                                                                    tmp1, tmp2,
1596                                                                    left_klass, right_klass, left_klass_op, right_klass_op,
1597                                                                    info, stub);
1598   append(c);
1599 }
1600 
1601 void LIR_List::cas_long(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1602                         LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1603   append(new LIR_OpCompareAndSwap(lir_cas_long, addr, cmp_value, new_value, t1, t2, result));
1604 }
1605 
1606 void LIR_List::cas_obj(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1607                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1608   append(new LIR_OpCompareAndSwap(lir_cas_obj, addr, cmp_value, new_value, t1, t2, result));
1609 }
1610 
1611 void LIR_List::cas_int(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1612                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1613   append(new LIR_OpCompareAndSwap(lir_cas_int, addr, cmp_value, new_value, t1, t2, result));
1614 }
1615 
1616 
1617 #ifdef PRODUCT
1618 
1619 void print_LIR(BlockList* blocks) {
1620 }
1621 
1622 #else
1623 // LIR_OprDesc
1624 void LIR_OprDesc::print() const {
1625   print(tty);
1626 }
1627 
1628 void LIR_OprDesc::print(outputStream* out) const {
1629   if (is_illegal()) {
1630     return;
1631   }
1632 
1633   out-&gt;print(&quot;[&quot;);
1634   if (is_pointer()) {
1635     pointer()-&gt;print_value_on(out);
1636   } else if (is_single_stack()) {
1637     out-&gt;print(&quot;stack:%d&quot;, single_stack_ix());
1638   } else if (is_double_stack()) {
1639     out-&gt;print(&quot;dbl_stack:%d&quot;,double_stack_ix());
1640   } else if (is_virtual()) {
1641     out-&gt;print(&quot;R%d&quot;, vreg_number());
1642   } else if (is_single_cpu()) {
1643     out-&gt;print(&quot;%s&quot;, as_register()-&gt;name());
1644   } else if (is_double_cpu()) {
1645     out-&gt;print(&quot;%s&quot;, as_register_hi()-&gt;name());
1646     out-&gt;print(&quot;%s&quot;, as_register_lo()-&gt;name());
1647 #if defined(X86)
1648   } else if (is_single_xmm()) {
1649     out-&gt;print(&quot;%s&quot;, as_xmm_float_reg()-&gt;name());
1650   } else if (is_double_xmm()) {
1651     out-&gt;print(&quot;%s&quot;, as_xmm_double_reg()-&gt;name());
1652   } else if (is_single_fpu()) {
1653     out-&gt;print(&quot;fpu%d&quot;, fpu_regnr());
1654   } else if (is_double_fpu()) {
1655     out-&gt;print(&quot;fpu%d&quot;, fpu_regnrLo());
1656 #elif defined(AARCH64)
1657   } else if (is_single_fpu()) {
1658     out-&gt;print(&quot;fpu%d&quot;, fpu_regnr());
1659   } else if (is_double_fpu()) {
1660     out-&gt;print(&quot;fpu%d&quot;, fpu_regnrLo());
1661 #elif defined(ARM)
1662   } else if (is_single_fpu()) {
1663     out-&gt;print(&quot;s%d&quot;, fpu_regnr());
1664   } else if (is_double_fpu()) {
1665     out-&gt;print(&quot;d%d&quot;, fpu_regnrLo() &gt;&gt; 1);
1666 #else
1667   } else if (is_single_fpu()) {
1668     out-&gt;print(&quot;%s&quot;, as_float_reg()-&gt;name());
1669   } else if (is_double_fpu()) {
1670     out-&gt;print(&quot;%s&quot;, as_double_reg()-&gt;name());
1671 #endif
1672 
1673   } else if (is_illegal()) {
1674     out-&gt;print(&quot;-&quot;);
1675   } else {
1676     out-&gt;print(&quot;Unknown Operand&quot;);
1677   }
1678   if (!is_illegal()) {
1679     out-&gt;print(&quot;|%c&quot;, type_char());
1680   }
1681   if (is_register() &amp;&amp; is_last_use()) {
1682     out-&gt;print(&quot;(last_use)&quot;);
1683   }
1684   out-&gt;print(&quot;]&quot;);
1685 }
1686 
1687 
1688 // LIR_Address
1689 void LIR_Const::print_value_on(outputStream* out) const {
1690   switch (type()) {
1691     case T_ADDRESS:out-&gt;print(&quot;address:%d&quot;,as_jint());          break;
1692     case T_INT:    out-&gt;print(&quot;int:%d&quot;,   as_jint());           break;
1693     case T_LONG:   out-&gt;print(&quot;lng:&quot; JLONG_FORMAT, as_jlong()); break;
1694     case T_FLOAT:  out-&gt;print(&quot;flt:%f&quot;,   as_jfloat());         break;
1695     case T_DOUBLE: out-&gt;print(&quot;dbl:%f&quot;,   as_jdouble());        break;
1696     case T_OBJECT: out-&gt;print(&quot;obj:&quot; INTPTR_FORMAT, p2i(as_jobject()));        break;
1697     case T_METADATA: out-&gt;print(&quot;metadata:&quot; INTPTR_FORMAT, p2i(as_metadata()));break;
1698     default:       out-&gt;print(&quot;%3d:0x&quot; UINT64_FORMAT_X, type(), (uint64_t)as_jlong()); break;
1699   }
1700 }
1701 
1702 // LIR_Address
1703 void LIR_Address::print_value_on(outputStream* out) const {
1704   out-&gt;print(&quot;Base:&quot;); _base-&gt;print(out);
1705   if (!_index-&gt;is_illegal()) {
1706     out-&gt;print(&quot; Index:&quot;); _index-&gt;print(out);
1707     switch (scale()) {
1708     case times_1: break;
1709     case times_2: out-&gt;print(&quot; * 2&quot;); break;
1710     case times_4: out-&gt;print(&quot; * 4&quot;); break;
1711     case times_8: out-&gt;print(&quot; * 8&quot;); break;
1712     }
1713   }
1714   out-&gt;print(&quot; Disp: &quot; INTX_FORMAT, _disp);
1715 }
1716 
1717 // debug output of block header without InstructionPrinter
1718 //       (because phi functions are not necessary for LIR)
1719 static void print_block(BlockBegin* x) {
1720   // print block id
1721   BlockEnd* end = x-&gt;end();
1722   tty-&gt;print(&quot;B%d &quot;, x-&gt;block_id());
1723 
1724   // print flags
1725   if (x-&gt;is_set(BlockBegin::std_entry_flag))               tty-&gt;print(&quot;std &quot;);
1726   if (x-&gt;is_set(BlockBegin::osr_entry_flag))               tty-&gt;print(&quot;osr &quot;);
1727   if (x-&gt;is_set(BlockBegin::exception_entry_flag))         tty-&gt;print(&quot;ex &quot;);
1728   if (x-&gt;is_set(BlockBegin::subroutine_entry_flag))        tty-&gt;print(&quot;jsr &quot;);
1729   if (x-&gt;is_set(BlockBegin::backward_branch_target_flag))  tty-&gt;print(&quot;bb &quot;);
1730   if (x-&gt;is_set(BlockBegin::linear_scan_loop_header_flag)) tty-&gt;print(&quot;lh &quot;);
1731   if (x-&gt;is_set(BlockBegin::linear_scan_loop_end_flag))    tty-&gt;print(&quot;le &quot;);
1732 
1733   // print block bci range
1734   tty-&gt;print(&quot;[%d, %d] &quot;, x-&gt;bci(), (end == NULL ? -1 : end-&gt;printable_bci()));
1735 
1736   // print predecessors and successors
1737   if (x-&gt;number_of_preds() &gt; 0) {
1738     tty-&gt;print(&quot;preds: &quot;);
1739     for (int i = 0; i &lt; x-&gt;number_of_preds(); i ++) {
1740       tty-&gt;print(&quot;B%d &quot;, x-&gt;pred_at(i)-&gt;block_id());
1741     }
1742   }
1743 
1744   if (x-&gt;number_of_sux() &gt; 0) {
1745     tty-&gt;print(&quot;sux: &quot;);
1746     for (int i = 0; i &lt; x-&gt;number_of_sux(); i ++) {
1747       tty-&gt;print(&quot;B%d &quot;, x-&gt;sux_at(i)-&gt;block_id());
1748     }
1749   }
1750 
1751   // print exception handlers
1752   if (x-&gt;number_of_exception_handlers() &gt; 0) {
1753     tty-&gt;print(&quot;xhandler: &quot;);
1754     for (int i = 0; i &lt; x-&gt;number_of_exception_handlers();  i++) {
1755       tty-&gt;print(&quot;B%d &quot;, x-&gt;exception_handler_at(i)-&gt;block_id());
1756     }
1757   }
1758 
1759   tty-&gt;cr();
1760 }
1761 
1762 void print_LIR(BlockList* blocks) {
1763   tty-&gt;print_cr(&quot;LIR:&quot;);
1764   int i;
1765   for (i = 0; i &lt; blocks-&gt;length(); i++) {
1766     BlockBegin* bb = blocks-&gt;at(i);
1767     print_block(bb);
1768     tty-&gt;print(&quot;__id_Instruction___________________________________________&quot;); tty-&gt;cr();
1769     bb-&gt;lir()-&gt;print_instructions();
1770   }
1771 }
1772 
1773 void LIR_List::print_instructions() {
1774   for (int i = 0; i &lt; _operations.length(); i++) {
1775     _operations.at(i)-&gt;print(); tty-&gt;cr();
1776   }
1777   tty-&gt;cr();
1778 }
1779 
1780 // LIR_Ops printing routines
1781 // LIR_Op
1782 void LIR_Op::print_on(outputStream* out) const {
1783   if (id() != -1 || PrintCFGToFile) {
1784     out-&gt;print(&quot;%4d &quot;, id());
1785   } else {
1786     out-&gt;print(&quot;     &quot;);
1787   }
1788   out-&gt;print(&quot;%s &quot;, name());
1789   print_instr(out);
1790   if (info() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, info()-&gt;stack()-&gt;bci());
1791 #ifdef ASSERT
1792   if (Verbose &amp;&amp; _file != NULL) {
1793     out-&gt;print(&quot; (%s:%d)&quot;, _file, _line);
1794   }
1795 #endif
1796 }
1797 
1798 const char * LIR_Op::name() const {
1799   const char* s = NULL;
1800   switch(code()) {
1801      // LIR_Op0
1802      case lir_membar:                s = &quot;membar&quot;;        break;
1803      case lir_membar_acquire:        s = &quot;membar_acquire&quot;; break;
1804      case lir_membar_release:        s = &quot;membar_release&quot;; break;
1805      case lir_membar_loadload:       s = &quot;membar_loadload&quot;;   break;
1806      case lir_membar_storestore:     s = &quot;membar_storestore&quot;; break;
1807      case lir_membar_loadstore:      s = &quot;membar_loadstore&quot;;  break;
1808      case lir_membar_storeload:      s = &quot;membar_storeload&quot;;  break;
1809      case lir_word_align:            s = &quot;word_align&quot;;    break;
1810      case lir_label:                 s = &quot;label&quot;;         break;
1811      case lir_nop:                   s = &quot;nop&quot;;           break;
1812      case lir_on_spin_wait:          s = &quot;on_spin_wait&quot;;  break;
1813      case lir_backwardbranch_target: s = &quot;backbranch&quot;;    break;
1814      case lir_std_entry:             s = &quot;std_entry&quot;;     break;
1815      case lir_osr_entry:             s = &quot;osr_entry&quot;;     break;
1816      case lir_build_frame:           s = &quot;build_frm&quot;;     break;
1817      case lir_fpop_raw:              s = &quot;fpop_raw&quot;;      break;
1818      case lir_breakpoint:            s = &quot;breakpoint&quot;;    break;
1819      case lir_get_thread:            s = &quot;get_thread&quot;;    break;
<a name="2" id="anc2"></a>
1820      // LIR_Op1
1821      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1822      case lir_fld:                   s = &quot;fld&quot;;           break;
1823      case lir_push:                  s = &quot;push&quot;;          break;
1824      case lir_pop:                   s = &quot;pop&quot;;           break;
1825      case lir_null_check:            s = &quot;null_check&quot;;    break;
1826      case lir_return:                s = &quot;return&quot;;        break;
1827      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1828      case lir_leal:                  s = &quot;leal&quot;;          break;
1829      case lir_branch:                s = &quot;branch&quot;;        break;
1830      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1831      case lir_move:                  s = &quot;move&quot;;          break;
1832      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1833      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1834      case lir_throw:                 s = &quot;throw&quot;;         break;
1835      case lir_unwind:                s = &quot;unwind&quot;;        break;
1836      case lir_convert:               s = &quot;convert&quot;;       break;
1837      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1838      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;
1839      case lir_pack64:                s = &quot;pack64&quot;;        break;
1840      case lir_unpack64:              s = &quot;unpack64&quot;;      break;
1841      // LIR_Op2
1842      case lir_cmp:                   s = &quot;cmp&quot;;           break;
1843      case lir_cmp_l2i:               s = &quot;cmp_l2i&quot;;       break;
1844      case lir_ucmp_fd2i:             s = &quot;ucomp_fd2i&quot;;    break;
1845      case lir_cmp_fd2i:              s = &quot;comp_fd2i&quot;;     break;
1846      case lir_cmove:                 s = &quot;cmove&quot;;         break;
1847      case lir_add:                   s = &quot;add&quot;;           break;
1848      case lir_sub:                   s = &quot;sub&quot;;           break;
1849      case lir_mul:                   s = &quot;mul&quot;;           break;
1850      case lir_mul_strictfp:          s = &quot;mul_strictfp&quot;;  break;
1851      case lir_div:                   s = &quot;div&quot;;           break;
1852      case lir_div_strictfp:          s = &quot;div_strictfp&quot;;  break;
1853      case lir_rem:                   s = &quot;rem&quot;;           break;
1854      case lir_abs:                   s = &quot;abs&quot;;           break;
1855      case lir_neg:                   s = &quot;neg&quot;;           break;
1856      case lir_sqrt:                  s = &quot;sqrt&quot;;          break;
1857      case lir_logic_and:             s = &quot;logic_and&quot;;     break;
1858      case lir_logic_or:              s = &quot;logic_or&quot;;      break;
1859      case lir_logic_xor:             s = &quot;logic_xor&quot;;     break;
1860      case lir_shl:                   s = &quot;shift_left&quot;;    break;
1861      case lir_shr:                   s = &quot;shift_right&quot;;   break;
1862      case lir_ushr:                  s = &quot;ushift_right&quot;;  break;
1863      case lir_alloc_array:           s = &quot;alloc_array&quot;;   break;
1864      case lir_xadd:                  s = &quot;xadd&quot;;          break;
1865      case lir_xchg:                  s = &quot;xchg&quot;;          break;
1866      // LIR_Op3
1867      case lir_idiv:                  s = &quot;idiv&quot;;          break;
1868      case lir_irem:                  s = &quot;irem&quot;;          break;
1869      case lir_fmad:                  s = &quot;fmad&quot;;          break;
1870      case lir_fmaf:                  s = &quot;fmaf&quot;;          break;
1871      // LIR_OpJavaCall
1872      case lir_static_call:           s = &quot;static&quot;;        break;
1873      case lir_optvirtual_call:       s = &quot;optvirtual&quot;;    break;
1874      case lir_icvirtual_call:        s = &quot;icvirtual&quot;;     break;
1875      case lir_virtual_call:          s = &quot;virtual&quot;;       break;
1876      case lir_dynamic_call:          s = &quot;dynamic&quot;;       break;
1877      // LIR_OpArrayCopy
1878      case lir_arraycopy:             s = &quot;arraycopy&quot;;     break;
1879      // LIR_OpUpdateCRC32
1880      case lir_updatecrc32:           s = &quot;updatecrc32&quot;;   break;
1881      // LIR_OpLock
1882      case lir_lock:                  s = &quot;lock&quot;;          break;
1883      case lir_unlock:                s = &quot;unlock&quot;;        break;
1884      // LIR_OpDelay
1885      case lir_delay_slot:            s = &quot;delay&quot;;         break;
1886      // LIR_OpTypeCheck
1887      case lir_instanceof:            s = &quot;instanceof&quot;;    break;
1888      case lir_checkcast:             s = &quot;checkcast&quot;;     break;
1889      case lir_store_check:           s = &quot;store_check&quot;;   break;
1890      // LIR_OpFlattenedArrayCheck
1891      case lir_flattened_array_check: s = &quot;flattened_array_check&quot;; break;
1892      // LIR_OpNullFreeArrayCheck
1893      case lir_null_free_array_check: s = &quot;null_free_array_check&quot;; break;
1894      // LIR_OpSubstitutabilityCheck
1895      case lir_substitutability_check: s = &quot;substitutability_check&quot;; break;
1896      // LIR_OpCompareAndSwap
1897      case lir_cas_long:              s = &quot;cas_long&quot;;      break;
1898      case lir_cas_obj:               s = &quot;cas_obj&quot;;      break;
1899      case lir_cas_int:               s = &quot;cas_int&quot;;      break;
1900      // LIR_OpProfileCall
1901      case lir_profile_call:          s = &quot;profile_call&quot;;  break;
1902      // LIR_OpProfileType
1903      case lir_profile_type:          s = &quot;profile_type&quot;;  break;
1904      // LIR_OpAssert
1905 #ifdef ASSERT
1906      case lir_assert:                s = &quot;assert&quot;;        break;
1907 #endif
1908      case lir_none:                  ShouldNotReachHere();break;
1909     default:                         s = &quot;illegal_op&quot;;    break;
1910   }
1911   return s;
1912 }
1913 
1914 // LIR_OpJavaCall
1915 void LIR_OpJavaCall::print_instr(outputStream* out) const {
1916   out-&gt;print(&quot;call: &quot;);
1917   out-&gt;print(&quot;[addr: &quot; INTPTR_FORMAT &quot;]&quot;, p2i(address()));
1918   if (receiver()-&gt;is_valid()) {
1919     out-&gt;print(&quot; [recv: &quot;);   receiver()-&gt;print(out);   out-&gt;print(&quot;]&quot;);
1920   }
1921   if (result_opr()-&gt;is_valid()) {
1922     out-&gt;print(&quot; [result: &quot;); result_opr()-&gt;print(out); out-&gt;print(&quot;]&quot;);
1923   }
1924 }
1925 
1926 // LIR_OpLabel
1927 void LIR_OpLabel::print_instr(outputStream* out) const {
1928   out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(_label));
1929 }
1930 
1931 // LIR_OpArrayCopy
1932 void LIR_OpArrayCopy::print_instr(outputStream* out) const {
1933   src()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1934   src_pos()-&gt;print(out); out-&gt;print(&quot; &quot;);
1935   dst()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1936   dst_pos()-&gt;print(out); out-&gt;print(&quot; &quot;);
1937   length()-&gt;print(out);  out-&gt;print(&quot; &quot;);
1938   tmp()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1939 }
1940 
1941 // LIR_OpUpdateCRC32
1942 void LIR_OpUpdateCRC32::print_instr(outputStream* out) const {
1943   crc()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1944   val()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1945   result_opr()-&gt;print(out); out-&gt;print(&quot; &quot;);
1946 }
1947 
1948 // LIR_OpCompareAndSwap
1949 void LIR_OpCompareAndSwap::print_instr(outputStream* out) const {
1950   addr()-&gt;print(out);      out-&gt;print(&quot; &quot;);
1951   cmp_value()-&gt;print(out); out-&gt;print(&quot; &quot;);
1952   new_value()-&gt;print(out); out-&gt;print(&quot; &quot;);
1953   tmp1()-&gt;print(out);      out-&gt;print(&quot; &quot;);
1954   tmp2()-&gt;print(out);      out-&gt;print(&quot; &quot;);
1955 
1956 }
1957 
1958 // LIR_Op0
1959 void LIR_Op0::print_instr(outputStream* out) const {
1960   result_opr()-&gt;print(out);
1961 }
1962 
1963 // LIR_Op1
1964 const char * LIR_Op1::name() const {
1965   if (code() == lir_move) {
1966     switch (move_kind()) {
1967     case lir_move_normal:
1968       return &quot;move&quot;;
1969     case lir_move_unaligned:
1970       return &quot;unaligned move&quot;;
1971     case lir_move_volatile:
1972       return &quot;volatile_move&quot;;
1973     case lir_move_wide:
1974       return &quot;wide_move&quot;;
1975     default:
1976       ShouldNotReachHere();
1977     return &quot;illegal_op&quot;;
1978     }
1979   } else {
1980     return LIR_Op::name();
1981   }
1982 }
1983 
1984 
1985 void LIR_Op1::print_instr(outputStream* out) const {
1986   _opr-&gt;print(out);         out-&gt;print(&quot; &quot;);
1987   result_opr()-&gt;print(out); out-&gt;print(&quot; &quot;);
1988   print_patch_code(out, patch_code());
1989 }
1990 
1991 
1992 // LIR_Op1
1993 void LIR_OpRTCall::print_instr(outputStream* out) const {
1994   intx a = (intx)addr();
1995   out-&gt;print(&quot;%s&quot;, Runtime1::name_for_address(addr()));
1996   out-&gt;print(&quot; &quot;);
1997   tmp()-&gt;print(out);
1998 }
1999 
2000 void LIR_Op1::print_patch_code(outputStream* out, LIR_PatchCode code) {
2001   switch(code) {
2002     case lir_patch_none:                                 break;
2003     case lir_patch_low:    out-&gt;print(&quot;[patch_low]&quot;);    break;
2004     case lir_patch_high:   out-&gt;print(&quot;[patch_high]&quot;);   break;
2005     case lir_patch_normal: out-&gt;print(&quot;[patch_normal]&quot;); break;
2006     default: ShouldNotReachHere();
2007   }
2008 }
2009 
2010 // LIR_OpBranch
2011 void LIR_OpBranch::print_instr(outputStream* out) const {
2012   print_condition(out, cond());             out-&gt;print(&quot; &quot;);
2013   if (block() != NULL) {
2014     out-&gt;print(&quot;[B%d] &quot;, block()-&gt;block_id());
2015   } else if (stub() != NULL) {
2016     out-&gt;print(&quot;[&quot;);
2017     stub()-&gt;print_name(out);
2018     out-&gt;print(&quot;: &quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()));
2019     if (stub()-&gt;info() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, stub()-&gt;info()-&gt;stack()-&gt;bci());
2020   } else {
2021     out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;] &quot;, p2i(label()));
2022   }
2023   if (ublock() != NULL) {
2024     out-&gt;print(&quot;unordered: [B%d] &quot;, ublock()-&gt;block_id());
2025   }
2026 }
2027 
2028 void LIR_Op::print_condition(outputStream* out, LIR_Condition cond) {
2029   switch(cond) {
2030     case lir_cond_equal:           out-&gt;print(&quot;[EQ]&quot;);      break;
2031     case lir_cond_notEqual:        out-&gt;print(&quot;[NE]&quot;);      break;
2032     case lir_cond_less:            out-&gt;print(&quot;[LT]&quot;);      break;
2033     case lir_cond_lessEqual:       out-&gt;print(&quot;[LE]&quot;);      break;
2034     case lir_cond_greaterEqual:    out-&gt;print(&quot;[GE]&quot;);      break;
2035     case lir_cond_greater:         out-&gt;print(&quot;[GT]&quot;);      break;
2036     case lir_cond_belowEqual:      out-&gt;print(&quot;[BE]&quot;);      break;
2037     case lir_cond_aboveEqual:      out-&gt;print(&quot;[AE]&quot;);      break;
2038     case lir_cond_always:          out-&gt;print(&quot;[AL]&quot;);      break;
2039     default:                       out-&gt;print(&quot;[%d]&quot;,cond); break;
2040   }
2041 }
2042 
2043 // LIR_OpConvert
2044 void LIR_OpConvert::print_instr(outputStream* out) const {
2045   print_bytecode(out, bytecode());
2046   in_opr()-&gt;print(out);                  out-&gt;print(&quot; &quot;);
2047   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);
2048 #ifdef PPC32
2049   if(tmp1()-&gt;is_valid()) {
2050     tmp1()-&gt;print(out); out-&gt;print(&quot; &quot;);
2051     tmp2()-&gt;print(out); out-&gt;print(&quot; &quot;);
2052   }
2053 #endif
2054 }
2055 
2056 void LIR_OpConvert::print_bytecode(outputStream* out, Bytecodes::Code code) {
2057   switch(code) {
2058     case Bytecodes::_d2f: out-&gt;print(&quot;[d2f] &quot;); break;
2059     case Bytecodes::_d2i: out-&gt;print(&quot;[d2i] &quot;); break;
2060     case Bytecodes::_d2l: out-&gt;print(&quot;[d2l] &quot;); break;
2061     case Bytecodes::_f2d: out-&gt;print(&quot;[f2d] &quot;); break;
2062     case Bytecodes::_f2i: out-&gt;print(&quot;[f2i] &quot;); break;
2063     case Bytecodes::_f2l: out-&gt;print(&quot;[f2l] &quot;); break;
2064     case Bytecodes::_i2b: out-&gt;print(&quot;[i2b] &quot;); break;
2065     case Bytecodes::_i2c: out-&gt;print(&quot;[i2c] &quot;); break;
2066     case Bytecodes::_i2d: out-&gt;print(&quot;[i2d] &quot;); break;
2067     case Bytecodes::_i2f: out-&gt;print(&quot;[i2f] &quot;); break;
2068     case Bytecodes::_i2l: out-&gt;print(&quot;[i2l] &quot;); break;
2069     case Bytecodes::_i2s: out-&gt;print(&quot;[i2s] &quot;); break;
2070     case Bytecodes::_l2i: out-&gt;print(&quot;[l2i] &quot;); break;
2071     case Bytecodes::_l2f: out-&gt;print(&quot;[l2f] &quot;); break;
2072     case Bytecodes::_l2d: out-&gt;print(&quot;[l2d] &quot;); break;
2073     default:
2074       out-&gt;print(&quot;[?%d]&quot;,code);
2075     break;
2076   }
2077 }
2078 
2079 void LIR_OpAllocObj::print_instr(outputStream* out) const {
2080   klass()-&gt;print(out);                      out-&gt;print(&quot; &quot;);
2081   obj()-&gt;print(out);                        out-&gt;print(&quot; &quot;);
2082   tmp1()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
2083   tmp2()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
2084   tmp3()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
2085   tmp4()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
2086   out-&gt;print(&quot;[hdr:%d]&quot;, header_size()); out-&gt;print(&quot; &quot;);
2087   out-&gt;print(&quot;[obj:%d]&quot;, object_size()); out-&gt;print(&quot; &quot;);
2088   out-&gt;print(&quot;[lbl:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2089 }
2090 
2091 void LIR_OpRoundFP::print_instr(outputStream* out) const {
2092   _opr-&gt;print(out);         out-&gt;print(&quot; &quot;);
2093   tmp()-&gt;print(out);        out-&gt;print(&quot; &quot;);
2094   result_opr()-&gt;print(out); out-&gt;print(&quot; &quot;);
2095 }
2096 
2097 // LIR_Op2
2098 void LIR_Op2::print_instr(outputStream* out) const {
2099   if (code() == lir_cmove || code() == lir_cmp) {
2100     print_condition(out, condition());         out-&gt;print(&quot; &quot;);
2101   }
2102   in_opr1()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2103   in_opr2()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2104   if (tmp1_opr()-&gt;is_valid()) { tmp1_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
2105   if (tmp2_opr()-&gt;is_valid()) { tmp2_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
2106   if (tmp3_opr()-&gt;is_valid()) { tmp3_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
2107   if (tmp4_opr()-&gt;is_valid()) { tmp4_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
2108   if (tmp5_opr()-&gt;is_valid()) { tmp5_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
2109   result_opr()-&gt;print(out);
2110 }
2111 
2112 void LIR_OpAllocArray::print_instr(outputStream* out) const {
2113   klass()-&gt;print(out);                   out-&gt;print(&quot; &quot;);
2114   len()-&gt;print(out);                     out-&gt;print(&quot; &quot;);
2115   obj()-&gt;print(out);                     out-&gt;print(&quot; &quot;);
2116   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2117   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2118   tmp3()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2119   tmp4()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2120   out-&gt;print(&quot;[type:0x%x]&quot;, type());     out-&gt;print(&quot; &quot;);
2121   out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2122 }
2123 
2124 
2125 void LIR_OpTypeCheck::print_instr(outputStream* out) const {
2126   object()-&gt;print(out);                  out-&gt;print(&quot; &quot;);
2127   if (code() == lir_store_check) {
2128     array()-&gt;print(out);                 out-&gt;print(&quot; &quot;);
2129   }
2130   if (code() != lir_store_check) {
2131     klass()-&gt;print_name_on(out);         out-&gt;print(&quot; &quot;);
2132     if (fast_check())                 out-&gt;print(&quot;fast_check &quot;);
2133   }
2134   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2135   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2136   tmp3()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2137   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);
2138   if (info_for_exception() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, info_for_exception()-&gt;stack()-&gt;bci());
2139 }
2140 
2141 void LIR_OpFlattenedArrayCheck::print_instr(outputStream* out) const {
2142   array()-&gt;print(out);                   out-&gt;print(&quot; &quot;);
2143   value()-&gt;print(out);                   out-&gt;print(&quot; &quot;);
2144   tmp()-&gt;print(out);                     out-&gt;print(&quot; &quot;);
2145   if (stub() != NULL) {
2146     out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2147   }
2148 }
2149 
2150 void LIR_OpNullFreeArrayCheck::print_instr(outputStream* out) const {
2151   array()-&gt;print(out);                   out-&gt;print(&quot; &quot;);
2152   tmp()-&gt;print(out);                     out-&gt;print(&quot; &quot;);
2153 }
2154 
2155 void LIR_OpSubstitutabilityCheck::print_instr(outputStream* out) const {
2156   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);
2157   left()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2158   right()-&gt;print(out);                   out-&gt;print(&quot; &quot;);
2159   equal_result()-&gt;print(out);            out-&gt;print(&quot; &quot;);
2160   not_equal_result()-&gt;print(out);        out-&gt;print(&quot; &quot;);
2161   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2162   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2163   left_klass()-&gt;print(out);              out-&gt;print(&quot; &quot;);
2164   right_klass()-&gt;print(out);             out-&gt;print(&quot; &quot;);
2165   left_klass_op()-&gt;print(out);           out-&gt;print(&quot; &quot;);
2166   right_klass_op()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2167   if (stub() != NULL) {
2168     out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2169   }
2170 }
2171 
2172 // LIR_Op3
2173 void LIR_Op3::print_instr(outputStream* out) const {
2174   in_opr1()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2175   in_opr2()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2176   in_opr3()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2177   result_opr()-&gt;print(out);
2178 }
2179 
2180 
2181 void LIR_OpLock::print_instr(outputStream* out) const {
2182   hdr_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
2183   obj_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
2184   lock_opr()-&gt;print(out);  out-&gt;print(&quot; &quot;);
2185   if (_scratch-&gt;is_valid()) {
2186     _scratch-&gt;print(out);  out-&gt;print(&quot; &quot;);
2187   }
2188   out-&gt;print(&quot;[lbl:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2189 }
2190 
2191 #ifdef ASSERT
2192 void LIR_OpAssert::print_instr(outputStream* out) const {
2193   print_condition(out, condition()); out-&gt;print(&quot; &quot;);
2194   in_opr1()-&gt;print(out);             out-&gt;print(&quot; &quot;);
2195   in_opr2()-&gt;print(out);             out-&gt;print(&quot;, \&quot;&quot;);
2196   out-&gt;print(&quot;%s&quot;, msg());          out-&gt;print(&quot;\&quot;&quot;);
2197 }
2198 #endif
2199 
2200 
2201 void LIR_OpDelay::print_instr(outputStream* out) const {
2202   _op-&gt;print_on(out);
2203 }
2204 
2205 
2206 // LIR_OpProfileCall
2207 void LIR_OpProfileCall::print_instr(outputStream* out) const {
2208   profiled_method()-&gt;name()-&gt;print_symbol_on(out);
2209   out-&gt;print(&quot;.&quot;);
2210   profiled_method()-&gt;holder()-&gt;name()-&gt;print_symbol_on(out);
2211   out-&gt;print(&quot; @ %d &quot;, profiled_bci());
2212   mdo()-&gt;print(out);           out-&gt;print(&quot; &quot;);
2213   recv()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2214   tmp1()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2215 }
2216 
2217 // LIR_OpProfileType
2218 void LIR_OpProfileType::print_instr(outputStream* out) const {
2219   out-&gt;print(&quot;exact = &quot;);
2220   if  (exact_klass() == NULL) {
2221     out-&gt;print(&quot;unknown&quot;);
2222   } else {
2223     exact_klass()-&gt;print_name_on(out);
2224   }
2225   out-&gt;print(&quot; current = &quot;); ciTypeEntries::print_ciklass(out, current_klass());
2226   out-&gt;print(&quot; &quot;);
2227   mdp()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2228   obj()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2229   tmp()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2230 }
2231 
2232 #endif // PRODUCT
2233 
2234 // Implementation of LIR_InsertionBuffer
2235 
2236 void LIR_InsertionBuffer::append(int index, LIR_Op* op) {
2237   assert(_index_and_count.length() % 2 == 0, &quot;must have a count for each index&quot;);
2238 
2239   int i = number_of_insertion_points() - 1;
2240   if (i &lt; 0 || index_at(i) &lt; index) {
2241     append_new(index, 1);
2242   } else {
2243     assert(index_at(i) == index, &quot;can append LIR_Ops in ascending order only&quot;);
2244     assert(count_at(i) &gt; 0, &quot;check&quot;);
2245     set_count_at(i, count_at(i) + 1);
2246   }
2247   _ops.push(op);
2248 
2249   DEBUG_ONLY(verify());
2250 }
2251 
2252 #ifdef ASSERT
2253 void LIR_InsertionBuffer::verify() {
2254   int sum = 0;
2255   int prev_idx = -1;
2256 
2257   for (int i = 0; i &lt; number_of_insertion_points(); i++) {
2258     assert(prev_idx &lt; index_at(i), &quot;index must be ordered ascending&quot;);
2259     sum += count_at(i);
2260   }
2261   assert(sum == number_of_ops(), &quot;wrong total sum&quot;);
2262 }
2263 #endif
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_FrameMap.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/x86/frame_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_FrameMap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
199   int   num_spills                  () const     { assert(_num_spills &gt;= 0, &quot;not set&quot;); return _num_spills; }
200   int   argcount              () const     { assert(_argcount &gt;= 0, &quot;not set&quot;); return _argcount; }
201 
202   int oop_map_arg_count() const { return _oop_map_arg_count; }
203 
204   CallingConvention* incoming_arguments() const  { return _incoming_arguments; }
205 
206   // convenience routines
207   Address address_for_slot(int index, int sp_adjust = 0) const {
208     return make_new_address(sp_offset_for_slot(index) + in_ByteSize(sp_adjust));
209   }
210   Address address_for_double_slot(int index, int sp_adjust = 0) const {
211     return make_new_address(sp_offset_for_double_slot(index) + in_ByteSize(sp_adjust));
212   }
213   Address address_for_monitor_lock(int monitor_index) const {
214     return make_new_address(sp_offset_for_monitor_lock(monitor_index));
215   }
216   Address address_for_monitor_object(int monitor_index) const {
217     return make_new_address(sp_offset_for_monitor_object(monitor_index));
218   }



219 
220   // Creates Location describing desired slot and returns it via pointer
221   // to Location object. Returns true if the stack frame offset was legal
222   // (as defined by Location::legal_offset_in_bytes()), false otherwise.
223   // Do not use the returned location if this returns false.
224   bool location_for_sp_offset(ByteSize byte_offset_from_sp,
225                               Location::Type loc_type, Location* loc) const;
226 
227   bool location_for_monitor_lock  (int monitor_index, Location* loc) const {
228     return location_for_sp_offset(sp_offset_for_monitor_lock(monitor_index), Location::normal, loc);
229   }
230   bool location_for_monitor_object(int monitor_index, Location* loc) const {
231     return location_for_sp_offset(sp_offset_for_monitor_object(monitor_index), Location::oop, loc);
232   }
233   bool locations_for_slot  (int index, Location::Type loc_type,
234                             Location* loc, Location* second = NULL) const;
235 
236   VMReg slot_regname(int index) const {
237     return sp_offset2vmreg(sp_offset_for_slot(index));
238   }
</pre>
</td>
<td>
<hr />
<pre>
199   int   num_spills                  () const     { assert(_num_spills &gt;= 0, &quot;not set&quot;); return _num_spills; }
200   int   argcount              () const     { assert(_argcount &gt;= 0, &quot;not set&quot;); return _argcount; }
201 
202   int oop_map_arg_count() const { return _oop_map_arg_count; }
203 
204   CallingConvention* incoming_arguments() const  { return _incoming_arguments; }
205 
206   // convenience routines
207   Address address_for_slot(int index, int sp_adjust = 0) const {
208     return make_new_address(sp_offset_for_slot(index) + in_ByteSize(sp_adjust));
209   }
210   Address address_for_double_slot(int index, int sp_adjust = 0) const {
211     return make_new_address(sp_offset_for_double_slot(index) + in_ByteSize(sp_adjust));
212   }
213   Address address_for_monitor_lock(int monitor_index) const {
214     return make_new_address(sp_offset_for_monitor_lock(monitor_index));
215   }
216   Address address_for_monitor_object(int monitor_index) const {
217     return make_new_address(sp_offset_for_monitor_object(monitor_index));
218   }
<span class="line-added">219   Address address_for_orig_pc_addr() const {</span>
<span class="line-added">220     return make_new_address(sp_offset_for_monitor_base(_num_monitors));</span>
<span class="line-added">221   }</span>
222 
223   // Creates Location describing desired slot and returns it via pointer
224   // to Location object. Returns true if the stack frame offset was legal
225   // (as defined by Location::legal_offset_in_bytes()), false otherwise.
226   // Do not use the returned location if this returns false.
227   bool location_for_sp_offset(ByteSize byte_offset_from_sp,
228                               Location::Type loc_type, Location* loc) const;
229 
230   bool location_for_monitor_lock  (int monitor_index, Location* loc) const {
231     return location_for_sp_offset(sp_offset_for_monitor_lock(monitor_index), Location::normal, loc);
232   }
233   bool location_for_monitor_object(int monitor_index, Location* loc) const {
234     return location_for_sp_offset(sp_offset_for_monitor_object(monitor_index), Location::oop, loc);
235   }
236   bool locations_for_slot  (int index, Location::Type loc_type,
237                             Location* loc, Location* second = NULL) const;
238 
239   VMReg slot_regname(int index) const {
240     return sp_offset2vmreg(sp_offset_for_slot(index));
241   }
</pre>
</td>
</tr>
</table>
<center><a href="../../cpu/x86/frame_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_LIR.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_C1_C1_LIR_HPP
  26 #define SHARE_C1_C1_LIR_HPP
  27 
  28 #include &quot;c1/c1_Defs.hpp&quot;
  29 #include &quot;c1/c1_ValueType.hpp&quot;
  30 #include &quot;oops/method.hpp&quot;
  31 #include &quot;utilities/globalDefinitions.hpp&quot;
  32 
  33 class BlockBegin;
  34 class BlockList;
  35 class LIR_Assembler;
  36 class CodeEmitInfo;
  37 class CodeStub;
  38 class CodeStubList;
  39 class ArrayCopyStub;
  40 class LIR_Op;
  41 class ciType;
  42 class ValueType;
  43 class LIR_OpVisitState;
  44 class FpuStackSim;
  45 
  46 //---------------------------------------------------------------------
  47 //                 LIR Operands
  48 //  LIR_OprDesc
  49 //    LIR_OprPtr
  50 //      LIR_Const
  51 //      LIR_Address
  52 //---------------------------------------------------------------------
  53 class LIR_OprDesc;
  54 class LIR_OprPtr;
  55 class LIR_Const;
  56 class LIR_Address;
  57 class LIR_OprVisitor;
  58 
  59 
  60 typedef LIR_OprDesc* LIR_Opr;
  61 typedef int          RegNr;
  62 
  63 typedef GrowableArray&lt;LIR_Opr&gt; LIR_OprList;
  64 typedef GrowableArray&lt;LIR_Op*&gt; LIR_OpArray;
  65 typedef GrowableArray&lt;LIR_Op*&gt; LIR_OpList;
  66 
  67 // define LIR_OprPtr early so LIR_OprDesc can refer to it
  68 class LIR_OprPtr: public CompilationResourceObj {
  69  public:
  70   bool is_oop_pointer() const                    { return (type() == T_OBJECT); }
  71   bool is_float_kind() const                     { BasicType t = type(); return (t == T_FLOAT) || (t == T_DOUBLE); }
  72 
  73   virtual LIR_Const*  as_constant()              { return NULL; }
  74   virtual LIR_Address* as_address()              { return NULL; }
  75   virtual BasicType type() const                 = 0;
  76   virtual void print_value_on(outputStream* out) const = 0;
  77 };
  78 
  79 
  80 
  81 // LIR constants
  82 class LIR_Const: public LIR_OprPtr {
  83  private:
  84   JavaValue _value;
  85 
  86   void type_check(BasicType t) const   { assert(type() == t, &quot;type check&quot;); }
  87   void type_check(BasicType t1, BasicType t2) const   { assert(type() == t1 || type() == t2, &quot;type check&quot;); }
  88   void type_check(BasicType t1, BasicType t2, BasicType t3) const   { assert(type() == t1 || type() == t2 || type() == t3, &quot;type check&quot;); }
  89 
  90  public:
  91   LIR_Const(jint i, bool is_address=false)       { _value.set_type(is_address?T_ADDRESS:T_INT); _value.set_jint(i); }
  92   LIR_Const(jlong l)                             { _value.set_type(T_LONG);    _value.set_jlong(l); }
  93   LIR_Const(jfloat f)                            { _value.set_type(T_FLOAT);   _value.set_jfloat(f); }
  94   LIR_Const(jdouble d)                           { _value.set_type(T_DOUBLE);  _value.set_jdouble(d); }
  95   LIR_Const(jobject o)                           { _value.set_type(T_OBJECT);  _value.set_jobject(o); }
  96   LIR_Const(void* p) {
  97 #ifdef _LP64
  98     assert(sizeof(jlong) &gt;= sizeof(p), &quot;too small&quot;);;
  99     _value.set_type(T_LONG);    _value.set_jlong((jlong)p);
 100 #else
 101     assert(sizeof(jint) &gt;= sizeof(p), &quot;too small&quot;);;
 102     _value.set_type(T_INT);     _value.set_jint((jint)p);
 103 #endif
 104   }
 105   LIR_Const(Metadata* m) {
 106     _value.set_type(T_METADATA);
 107 #ifdef _LP64
 108     _value.set_jlong((jlong)m);
 109 #else
 110     _value.set_jint((jint)m);
 111 #endif // _LP64
 112   }
 113 
 114   virtual BasicType type()       const { return _value.get_type(); }
 115   virtual LIR_Const* as_constant()     { return this; }
 116 
 117   jint      as_jint()    const         { type_check(T_INT, T_ADDRESS); return _value.get_jint(); }
 118   jlong     as_jlong()   const         { type_check(T_LONG  ); return _value.get_jlong(); }
 119   jfloat    as_jfloat()  const         { type_check(T_FLOAT ); return _value.get_jfloat(); }
 120   jdouble   as_jdouble() const         { type_check(T_DOUBLE); return _value.get_jdouble(); }
 121   jobject   as_jobject() const         { type_check(T_OBJECT); return _value.get_jobject(); }
 122   jint      as_jint_lo() const         { type_check(T_LONG  ); return low(_value.get_jlong()); }
 123   jint      as_jint_hi() const         { type_check(T_LONG  ); return high(_value.get_jlong()); }
 124 
 125 #ifdef _LP64
 126   address   as_pointer() const         { type_check(T_LONG  ); return (address)_value.get_jlong(); }
 127   Metadata* as_metadata() const        { type_check(T_METADATA); return (Metadata*)_value.get_jlong(); }
 128 #else
 129   address   as_pointer() const         { type_check(T_INT   ); return (address)_value.get_jint(); }
 130   Metadata* as_metadata() const        { type_check(T_METADATA); return (Metadata*)_value.get_jint(); }
 131 #endif
 132 
 133 
 134   jint      as_jint_bits() const       { type_check(T_FLOAT, T_INT, T_ADDRESS); return _value.get_jint(); }
 135   jint      as_jint_lo_bits() const    {
 136     if (type() == T_DOUBLE) {
 137       return low(jlong_cast(_value.get_jdouble()));
 138     } else {
 139       return as_jint_lo();
 140     }
 141   }
 142   jint      as_jint_hi_bits() const    {
 143     if (type() == T_DOUBLE) {
 144       return high(jlong_cast(_value.get_jdouble()));
 145     } else {
 146       return as_jint_hi();
 147     }
 148   }
 149   jlong      as_jlong_bits() const    {
 150     if (type() == T_DOUBLE) {
 151       return jlong_cast(_value.get_jdouble());
 152     } else {
 153       return as_jlong();
 154     }
 155   }
 156 
 157   virtual void print_value_on(outputStream* out) const PRODUCT_RETURN;
 158 
 159 
 160   bool is_zero_float() {
 161     jfloat f = as_jfloat();
 162     jfloat ok = 0.0f;
 163     return jint_cast(f) == jint_cast(ok);
 164   }
 165 
 166   bool is_one_float() {
 167     jfloat f = as_jfloat();
 168     return !g_isnan(f) &amp;&amp; g_isfinite(f) &amp;&amp; f == 1.0;
 169   }
 170 
 171   bool is_zero_double() {
 172     jdouble d = as_jdouble();
 173     jdouble ok = 0.0;
 174     return jlong_cast(d) == jlong_cast(ok);
 175   }
 176 
 177   bool is_one_double() {
 178     jdouble d = as_jdouble();
 179     return !g_isnan(d) &amp;&amp; g_isfinite(d) &amp;&amp; d == 1.0;
 180   }
 181 };
 182 
 183 
 184 //---------------------LIR Operand descriptor------------------------------------
 185 //
 186 // The class LIR_OprDesc represents a LIR instruction operand;
 187 // it can be a register (ALU/FPU), stack location or a constant;
 188 // Constants and addresses are represented as resource area allocated
 189 // structures (see above).
 190 // Registers and stack locations are inlined into the this pointer
 191 // (see value function).
 192 
 193 class LIR_OprDesc: public CompilationResourceObj {
 194  public:
 195   // value structure:
 196   //     data       opr-type opr-kind
 197   // +--------------+-------+-------+
 198   // [max...........|7 6 5 4|3 2 1 0]
 199   //                               ^
 200   //                         is_pointer bit
 201   //
 202   // lowest bit cleared, means it is a structure pointer
 203   // we need  4 bits to represent types
 204 
 205  private:
 206   friend class LIR_OprFact;
 207 
 208   // Conversion
 209   intptr_t value() const                         { return (intptr_t) this; }
 210 
 211   bool check_value_mask(intptr_t mask, intptr_t masked_value) const {
 212     return (value() &amp; mask) == masked_value;
 213   }
 214 
 215   enum OprKind {
 216       pointer_value      = 0
 217     , stack_value        = 1
 218     , cpu_register       = 3
 219     , fpu_register       = 5
 220     , illegal_value      = 7
 221   };
 222 
 223   enum OprBits {
 224       pointer_bits   = 1
 225     , kind_bits      = 3
 226     , type_bits      = 4
 227     , size_bits      = 2
 228     , destroys_bits  = 1
 229     , virtual_bits   = 1
 230     , is_xmm_bits    = 1
 231     , last_use_bits  = 1
 232     , is_fpu_stack_offset_bits = 1        // used in assertion checking on x86 for FPU stack slot allocation
 233     , non_data_bits  = kind_bits + type_bits + size_bits + destroys_bits + last_use_bits +
 234                        is_fpu_stack_offset_bits + virtual_bits + is_xmm_bits
 235     , data_bits      = BitsPerInt - non_data_bits
 236     , reg_bits       = data_bits / 2      // for two registers in one value encoding
 237   };
 238 
 239   enum OprShift {
 240       kind_shift     = 0
 241     , type_shift     = kind_shift     + kind_bits
 242     , size_shift     = type_shift     + type_bits
 243     , destroys_shift = size_shift     + size_bits
 244     , last_use_shift = destroys_shift + destroys_bits
 245     , is_fpu_stack_offset_shift = last_use_shift + last_use_bits
 246     , virtual_shift  = is_fpu_stack_offset_shift + is_fpu_stack_offset_bits
 247     , is_xmm_shift   = virtual_shift + virtual_bits
 248     , data_shift     = is_xmm_shift + is_xmm_bits
 249     , reg1_shift = data_shift
 250     , reg2_shift = data_shift + reg_bits
 251 
 252   };
 253 
 254   enum OprSize {
 255       single_size = 0 &lt;&lt; size_shift
 256     , double_size = 1 &lt;&lt; size_shift
 257   };
 258 
 259   enum OprMask {
 260       kind_mask      = right_n_bits(kind_bits)
 261     , type_mask      = right_n_bits(type_bits) &lt;&lt; type_shift
 262     , size_mask      = right_n_bits(size_bits) &lt;&lt; size_shift
 263     , last_use_mask  = right_n_bits(last_use_bits) &lt;&lt; last_use_shift
 264     , is_fpu_stack_offset_mask = right_n_bits(is_fpu_stack_offset_bits) &lt;&lt; is_fpu_stack_offset_shift
 265     , virtual_mask   = right_n_bits(virtual_bits) &lt;&lt; virtual_shift
 266     , is_xmm_mask    = right_n_bits(is_xmm_bits) &lt;&lt; is_xmm_shift
 267     , pointer_mask   = right_n_bits(pointer_bits)
 268     , lower_reg_mask = right_n_bits(reg_bits)
 269     , no_type_mask   = (int)(~(type_mask | last_use_mask | is_fpu_stack_offset_mask))
 270   };
 271 
 272   uintptr_t data() const                         { return value() &gt;&gt; data_shift; }
 273   int lo_reg_half() const                        { return data() &amp; lower_reg_mask; }
 274   int hi_reg_half() const                        { return (data() &gt;&gt; reg_bits) &amp; lower_reg_mask; }
 275   OprKind kind_field() const                     { return (OprKind)(value() &amp; kind_mask); }
 276   OprSize size_field() const                     { return (OprSize)(value() &amp; size_mask); }
 277 
 278   static char type_char(BasicType t);
 279 
 280  public:
 281   enum {
 282     vreg_base = ConcreteRegisterImpl::number_of_registers,
 283     vreg_max = (1 &lt;&lt; data_bits) - 1
 284   };
 285 
 286   static inline LIR_Opr illegalOpr();
 287 
 288   enum OprType {
 289       unknown_type  = 0 &lt;&lt; type_shift    // means: not set (catch uninitialized types)
 290     , int_type      = 1 &lt;&lt; type_shift
 291     , long_type     = 2 &lt;&lt; type_shift
 292     , object_type   = 3 &lt;&lt; type_shift
 293     , address_type  = 4 &lt;&lt; type_shift
 294     , float_type    = 5 &lt;&lt; type_shift
 295     , double_type   = 6 &lt;&lt; type_shift
 296     , metadata_type = 7 &lt;&lt; type_shift
 297   };
 298   friend OprType as_OprType(BasicType t);
 299   friend BasicType as_BasicType(OprType t);
 300 
 301   OprType type_field_valid() const               { assert(is_register() || is_stack(), &quot;should not be called otherwise&quot;); return (OprType)(value() &amp; type_mask); }
 302   OprType type_field() const                     { return is_illegal() ? unknown_type : (OprType)(value() &amp; type_mask); }
 303 
 304   static OprSize size_for(BasicType t) {
 305     switch (t) {
 306       case T_LONG:
 307       case T_DOUBLE:
 308         return double_size;
 309         break;
 310 
 311       case T_FLOAT:
 312       case T_BOOLEAN:
 313       case T_CHAR:
 314       case T_BYTE:
 315       case T_SHORT:
 316       case T_INT:
 317       case T_ADDRESS:
 318       case T_OBJECT:
 319       case T_VALUETYPE:
 320       case T_ARRAY:
 321       case T_METADATA:
 322         return single_size;
 323         break;
 324 
 325       default:
 326         ShouldNotReachHere();
 327         return single_size;
 328       }
 329   }
 330 
 331 
 332   void validate_type() const PRODUCT_RETURN;
 333 
 334   BasicType type() const {
 335     if (is_pointer()) {
 336       return pointer()-&gt;type();
 337     }
 338     return as_BasicType(type_field());
 339   }
 340 
 341 
 342   ValueType* value_type() const                  { return as_ValueType(type()); }
 343 
 344   char type_char() const                         { return type_char((is_pointer()) ? pointer()-&gt;type() : type()); }
 345 
 346   bool is_equal(LIR_Opr opr) const         { return this == opr; }
 347   // checks whether types are same
 348   bool is_same_type(LIR_Opr opr) const     {
 349     assert(type_field() != unknown_type &amp;&amp;
 350            opr-&gt;type_field() != unknown_type, &quot;shouldn&#39;t see unknown_type&quot;);
 351     return type_field() == opr-&gt;type_field();
 352   }
 353   bool is_same_register(LIR_Opr opr) {
 354     return (is_register() &amp;&amp; opr-&gt;is_register() &amp;&amp;
 355             kind_field() == opr-&gt;kind_field() &amp;&amp;
 356             (value() &amp; no_type_mask) == (opr-&gt;value() &amp; no_type_mask));
 357   }
 358 
 359   bool is_pointer() const      { return check_value_mask(pointer_mask, pointer_value); }
 360   bool is_illegal() const      { return kind_field() == illegal_value; }
 361   bool is_valid() const        { return kind_field() != illegal_value; }
 362 
 363   bool is_register() const     { return is_cpu_register() || is_fpu_register(); }
 364   bool is_virtual() const      { return is_virtual_cpu()  || is_virtual_fpu();  }
 365 
 366   bool is_constant() const     { return is_pointer() &amp;&amp; pointer()-&gt;as_constant() != NULL; }
 367   bool is_address() const      { return is_pointer() &amp;&amp; pointer()-&gt;as_address() != NULL; }
 368 
 369   bool is_float_kind() const   { return is_pointer() ? pointer()-&gt;is_float_kind() : (kind_field() == fpu_register); }
 370   bool is_oop() const;
 371 
 372   // semantic for fpu- and xmm-registers:
 373   // * is_float and is_double return true for xmm_registers
 374   //   (so is_single_fpu and is_single_xmm are true)
 375   // * So you must always check for is_???_xmm prior to is_???_fpu to
 376   //   distinguish between fpu- and xmm-registers
 377 
 378   bool is_stack() const        { validate_type(); return check_value_mask(kind_mask,                stack_value);                 }
 379   bool is_single_stack() const { validate_type(); return check_value_mask(kind_mask | size_mask,    stack_value  | single_size);  }
 380   bool is_double_stack() const { validate_type(); return check_value_mask(kind_mask | size_mask,    stack_value  | double_size);  }
 381 
 382   bool is_cpu_register() const { validate_type(); return check_value_mask(kind_mask,                cpu_register);                }
 383   bool is_virtual_cpu() const  { validate_type(); return check_value_mask(kind_mask | virtual_mask, cpu_register | virtual_mask); }
 384   bool is_fixed_cpu() const    { validate_type(); return check_value_mask(kind_mask | virtual_mask, cpu_register);                }
 385   bool is_single_cpu() const   { validate_type(); return check_value_mask(kind_mask | size_mask,    cpu_register | single_size);  }
 386   bool is_double_cpu() const   { validate_type(); return check_value_mask(kind_mask | size_mask,    cpu_register | double_size);  }
 387 
 388   bool is_fpu_register() const { validate_type(); return check_value_mask(kind_mask,                fpu_register);                }
 389   bool is_virtual_fpu() const  { validate_type(); return check_value_mask(kind_mask | virtual_mask, fpu_register | virtual_mask); }
 390   bool is_fixed_fpu() const    { validate_type(); return check_value_mask(kind_mask | virtual_mask, fpu_register);                }
 391   bool is_single_fpu() const   { validate_type(); return check_value_mask(kind_mask | size_mask,    fpu_register | single_size);  }
 392   bool is_double_fpu() const   { validate_type(); return check_value_mask(kind_mask | size_mask,    fpu_register | double_size);  }
 393 
 394   bool is_xmm_register() const { validate_type(); return check_value_mask(kind_mask | is_xmm_mask,             fpu_register | is_xmm_mask); }
 395   bool is_single_xmm() const   { validate_type(); return check_value_mask(kind_mask | size_mask | is_xmm_mask, fpu_register | single_size | is_xmm_mask); }
 396   bool is_double_xmm() const   { validate_type(); return check_value_mask(kind_mask | size_mask | is_xmm_mask, fpu_register | double_size | is_xmm_mask); }
 397 
 398   // fast accessor functions for special bits that do not work for pointers
 399   // (in this functions, the check for is_pointer() is omitted)
 400   bool is_single_word() const      { assert(is_register() || is_stack(), &quot;type check&quot;); return check_value_mask(size_mask, single_size); }
 401   bool is_double_word() const      { assert(is_register() || is_stack(), &quot;type check&quot;); return check_value_mask(size_mask, double_size); }
 402   bool is_virtual_register() const { assert(is_register(),               &quot;type check&quot;); return check_value_mask(virtual_mask, virtual_mask); }
 403   bool is_oop_register() const     { assert(is_register() || is_stack(), &quot;type check&quot;); return type_field_valid() == object_type; }
 404   BasicType type_register() const  { assert(is_register() || is_stack(), &quot;type check&quot;); return as_BasicType(type_field_valid());  }
 405 
 406   bool is_last_use() const         { assert(is_register(), &quot;only works for registers&quot;); return (value() &amp; last_use_mask) != 0; }
 407   bool is_fpu_stack_offset() const { assert(is_register(), &quot;only works for registers&quot;); return (value() &amp; is_fpu_stack_offset_mask) != 0; }
 408   LIR_Opr make_last_use()          { assert(is_register(), &quot;only works for registers&quot;); return (LIR_Opr)(value() | last_use_mask); }
 409   LIR_Opr make_fpu_stack_offset()  { assert(is_register(), &quot;only works for registers&quot;); return (LIR_Opr)(value() | is_fpu_stack_offset_mask); }
 410 
 411 
 412   int single_stack_ix() const  { assert(is_single_stack() &amp;&amp; !is_virtual(), &quot;type check&quot;); return (int)data(); }
 413   int double_stack_ix() const  { assert(is_double_stack() &amp;&amp; !is_virtual(), &quot;type check&quot;); return (int)data(); }
 414   RegNr cpu_regnr() const      { assert(is_single_cpu()   &amp;&amp; !is_virtual(), &quot;type check&quot;); return (RegNr)data(); }
 415   RegNr cpu_regnrLo() const    { assert(is_double_cpu()   &amp;&amp; !is_virtual(), &quot;type check&quot;); return (RegNr)lo_reg_half(); }
 416   RegNr cpu_regnrHi() const    { assert(is_double_cpu()   &amp;&amp; !is_virtual(), &quot;type check&quot;); return (RegNr)hi_reg_half(); }
 417   RegNr fpu_regnr() const      { assert(is_single_fpu()   &amp;&amp; !is_virtual(), &quot;type check&quot;); return (RegNr)data(); }
 418   RegNr fpu_regnrLo() const    { assert(is_double_fpu()   &amp;&amp; !is_virtual(), &quot;type check&quot;); return (RegNr)lo_reg_half(); }
 419   RegNr fpu_regnrHi() const    { assert(is_double_fpu()   &amp;&amp; !is_virtual(), &quot;type check&quot;); return (RegNr)hi_reg_half(); }
 420   RegNr xmm_regnr() const      { assert(is_single_xmm()   &amp;&amp; !is_virtual(), &quot;type check&quot;); return (RegNr)data(); }
 421   RegNr xmm_regnrLo() const    { assert(is_double_xmm()   &amp;&amp; !is_virtual(), &quot;type check&quot;); return (RegNr)lo_reg_half(); }
 422   RegNr xmm_regnrHi() const    { assert(is_double_xmm()   &amp;&amp; !is_virtual(), &quot;type check&quot;); return (RegNr)hi_reg_half(); }
 423   int   vreg_number() const    { assert(is_virtual(),                       &quot;type check&quot;); return (RegNr)data(); }
 424 
 425   LIR_OprPtr* pointer()  const                   { assert(is_pointer(), &quot;type check&quot;);      return (LIR_OprPtr*)this; }
 426   LIR_Const* as_constant_ptr() const             { return pointer()-&gt;as_constant(); }
 427   LIR_Address* as_address_ptr() const            { return pointer()-&gt;as_address(); }
 428 
 429   Register as_register()    const;
 430   Register as_register_lo() const;
 431   Register as_register_hi() const;
 432 
 433   Register as_pointer_register() {
 434 #ifdef _LP64
 435     if (is_double_cpu()) {
 436       assert(as_register_lo() == as_register_hi(), &quot;should be a single register&quot;);
 437       return as_register_lo();
 438     }
 439 #endif
 440     return as_register();
 441   }
 442 
 443   FloatRegister as_float_reg   () const;
 444   FloatRegister as_double_reg  () const;
 445 #ifdef X86
 446   XMMRegister as_xmm_float_reg () const;
 447   XMMRegister as_xmm_double_reg() const;
 448   // for compatibility with RInfo
 449   int fpu() const { return lo_reg_half(); }
 450 #endif
 451 
 452   jint      as_jint()    const { return as_constant_ptr()-&gt;as_jint(); }
 453   jlong     as_jlong()   const { return as_constant_ptr()-&gt;as_jlong(); }
 454   jfloat    as_jfloat()  const { return as_constant_ptr()-&gt;as_jfloat(); }
 455   jdouble   as_jdouble() const { return as_constant_ptr()-&gt;as_jdouble(); }
 456   jobject   as_jobject() const { return as_constant_ptr()-&gt;as_jobject(); }
 457 
 458   void print() const PRODUCT_RETURN;
 459   void print(outputStream* out) const PRODUCT_RETURN;
 460 };
 461 
 462 
 463 inline LIR_OprDesc::OprType as_OprType(BasicType type) {
 464   switch (type) {
 465   case T_INT:      return LIR_OprDesc::int_type;
 466   case T_LONG:     return LIR_OprDesc::long_type;
 467   case T_FLOAT:    return LIR_OprDesc::float_type;
 468   case T_DOUBLE:   return LIR_OprDesc::double_type;
 469   case T_OBJECT:
 470   case T_VALUETYPE:
 471   case T_ARRAY:    return LIR_OprDesc::object_type;
 472   case T_ADDRESS:  return LIR_OprDesc::address_type;
 473   case T_METADATA: return LIR_OprDesc::metadata_type;
 474   case T_ILLEGAL:  // fall through
 475   default: ShouldNotReachHere(); return LIR_OprDesc::unknown_type;
 476   }
 477 }
 478 
 479 inline BasicType as_BasicType(LIR_OprDesc::OprType t) {
 480   switch (t) {
 481   case LIR_OprDesc::int_type:     return T_INT;
 482   case LIR_OprDesc::long_type:    return T_LONG;
 483   case LIR_OprDesc::float_type:   return T_FLOAT;
 484   case LIR_OprDesc::double_type:  return T_DOUBLE;
 485   case LIR_OprDesc::object_type:  return T_OBJECT;
 486   case LIR_OprDesc::address_type: return T_ADDRESS;
 487   case LIR_OprDesc::metadata_type:return T_METADATA;
 488   case LIR_OprDesc::unknown_type: // fall through
 489   default: ShouldNotReachHere();  return T_ILLEGAL;
 490   }
 491 }
 492 
 493 
 494 // LIR_Address
 495 class LIR_Address: public LIR_OprPtr {
 496  friend class LIR_OpVisitState;
 497 
 498  public:
 499   // NOTE: currently these must be the log2 of the scale factor (and
 500   // must also be equivalent to the ScaleFactor enum in
 501   // assembler_i486.hpp)
 502   enum Scale {
 503     times_1  =  0,
 504     times_2  =  1,
 505     times_4  =  2,
 506     times_8  =  3
 507   };
 508 
 509  private:
 510   LIR_Opr   _base;
 511   LIR_Opr   _index;
 512   Scale     _scale;
 513   intx      _disp;
 514   BasicType _type;
 515 
 516  public:
 517   LIR_Address(LIR_Opr base, LIR_Opr index, BasicType type):
 518        _base(base)
 519      , _index(index)
 520      , _scale(times_1)
 521      , _disp(0)
 522      , _type(type) { verify(); }
 523 
 524   LIR_Address(LIR_Opr base, intx disp, BasicType type):
 525        _base(base)
 526      , _index(LIR_OprDesc::illegalOpr())
 527      , _scale(times_1)
 528      , _disp(disp)
 529      , _type(type) { verify(); }
 530 
 531   LIR_Address(LIR_Opr base, BasicType type):
 532        _base(base)
 533      , _index(LIR_OprDesc::illegalOpr())
 534      , _scale(times_1)
 535      , _disp(0)
 536      , _type(type) { verify(); }
 537 
 538   LIR_Address(LIR_Opr base, LIR_Opr index, intx disp, BasicType type):
 539        _base(base)
 540      , _index(index)
 541      , _scale(times_1)
 542      , _disp(disp)
 543      , _type(type) { verify(); }
 544 
 545   LIR_Address(LIR_Opr base, LIR_Opr index, Scale scale, intx disp, BasicType type):
 546        _base(base)
 547      , _index(index)
 548      , _scale(scale)
 549      , _disp(disp)
 550      , _type(type) { verify(); }
 551 
 552   LIR_Opr base()  const                          { return _base;  }
 553   LIR_Opr index() const                          { return _index; }
 554   Scale   scale() const                          { return _scale; }
 555   intx    disp()  const                          { return _disp;  }
 556 
 557   bool equals(LIR_Address* other) const          { return base() == other-&gt;base() &amp;&amp; index() == other-&gt;index() &amp;&amp; disp() == other-&gt;disp() &amp;&amp; scale() == other-&gt;scale(); }
 558 
 559   virtual LIR_Address* as_address()              { return this;   }
 560   virtual BasicType type() const                 { return _type; }
 561   virtual void print_value_on(outputStream* out) const PRODUCT_RETURN;
 562 
 563   void verify() const PRODUCT_RETURN;
 564 
 565   static Scale scale(BasicType type);
 566 };
 567 
 568 
 569 // operand factory
 570 class LIR_OprFact: public AllStatic {
 571  public:
 572 
 573   static LIR_Opr illegalOpr;
 574 
 575   static LIR_Opr single_cpu(int reg) {
 576     return (LIR_Opr)(intptr_t)((reg  &lt;&lt; LIR_OprDesc::reg1_shift) |
 577                                LIR_OprDesc::int_type             |
 578                                LIR_OprDesc::cpu_register         |
 579                                LIR_OprDesc::single_size);
 580   }
 581   static LIR_Opr single_cpu_oop(int reg) {
 582     return (LIR_Opr)(intptr_t)((reg  &lt;&lt; LIR_OprDesc::reg1_shift) |
 583                                LIR_OprDesc::object_type          |
 584                                LIR_OprDesc::cpu_register         |
 585                                LIR_OprDesc::single_size);
 586   }
 587   static LIR_Opr single_cpu_address(int reg) {
 588     return (LIR_Opr)(intptr_t)((reg  &lt;&lt; LIR_OprDesc::reg1_shift) |
 589                                LIR_OprDesc::address_type         |
 590                                LIR_OprDesc::cpu_register         |
 591                                LIR_OprDesc::single_size);
 592   }
 593   static LIR_Opr single_cpu_metadata(int reg) {
 594     return (LIR_Opr)(intptr_t)((reg  &lt;&lt; LIR_OprDesc::reg1_shift) |
 595                                LIR_OprDesc::metadata_type        |
 596                                LIR_OprDesc::cpu_register         |
 597                                LIR_OprDesc::single_size);
 598   }
 599   static LIR_Opr double_cpu(int reg1, int reg2) {
 600     LP64_ONLY(assert(reg1 == reg2, &quot;must be identical&quot;));
 601     return (LIR_Opr)(intptr_t)((reg1 &lt;&lt; LIR_OprDesc::reg1_shift) |
 602                                (reg2 &lt;&lt; LIR_OprDesc::reg2_shift) |
 603                                LIR_OprDesc::long_type            |
 604                                LIR_OprDesc::cpu_register         |
 605                                LIR_OprDesc::double_size);
 606   }
 607 
 608   static LIR_Opr single_fpu(int reg) {
 609     return (LIR_Opr)(intptr_t)((reg  &lt;&lt; LIR_OprDesc::reg1_shift) |
 610                                LIR_OprDesc::float_type           |
 611                                LIR_OprDesc::fpu_register         |
 612                                LIR_OprDesc::single_size);
 613   }
 614 
 615   // Platform dependant.
 616   static LIR_Opr double_fpu(int reg1, int reg2 = -1 /*fnoreg*/);
 617 
 618 #ifdef ARM32
 619   static LIR_Opr single_softfp(int reg) {
 620     return (LIR_Opr)(intptr_t)((reg  &lt;&lt; LIR_OprDesc::reg1_shift) |
 621                                LIR_OprDesc::float_type           |
 622                                LIR_OprDesc::cpu_register         |
 623                                LIR_OprDesc::single_size);
 624   }
 625   static LIR_Opr double_softfp(int reg1, int reg2) {
 626     return (LIR_Opr)(intptr_t)((reg1 &lt;&lt; LIR_OprDesc::reg1_shift) |
 627                                (reg2 &lt;&lt; LIR_OprDesc::reg2_shift) |
 628                                LIR_OprDesc::double_type          |
 629                                LIR_OprDesc::cpu_register         |
 630                                LIR_OprDesc::double_size);
 631   }
 632 #endif // ARM32
 633 
 634 #if defined(X86)
 635   static LIR_Opr single_xmm(int reg) {
 636     return (LIR_Opr)(intptr_t)((reg &lt;&lt; LIR_OprDesc::reg1_shift) |
 637                                LIR_OprDesc::float_type          |
 638                                LIR_OprDesc::fpu_register        |
 639                                LIR_OprDesc::single_size         |
 640                                LIR_OprDesc::is_xmm_mask);
 641   }
 642   static LIR_Opr double_xmm(int reg) {
 643     return (LIR_Opr)(intptr_t)((reg &lt;&lt; LIR_OprDesc::reg1_shift) |
 644                                (reg &lt;&lt; LIR_OprDesc::reg2_shift) |
 645                                LIR_OprDesc::double_type         |
 646                                LIR_OprDesc::fpu_register        |
 647                                LIR_OprDesc::double_size         |
 648                                LIR_OprDesc::is_xmm_mask);
 649   }
 650 #endif // X86
 651 
 652   static LIR_Opr virtual_register(int index, BasicType type) {
 653     LIR_Opr res;
 654     switch (type) {
 655       case T_OBJECT: // fall through
 656       case T_VALUETYPE: // fall through
 657       case T_ARRAY:
 658         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift)  |
 659                                             LIR_OprDesc::object_type  |
 660                                             LIR_OprDesc::cpu_register |
 661                                             LIR_OprDesc::single_size  |
 662                                             LIR_OprDesc::virtual_mask);
 663         break;
 664 
 665       case T_METADATA:
 666         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift)  |
 667                                             LIR_OprDesc::metadata_type|
 668                                             LIR_OprDesc::cpu_register |
 669                                             LIR_OprDesc::single_size  |
 670                                             LIR_OprDesc::virtual_mask);
 671         break;
 672 
 673       case T_INT:
 674         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 675                                   LIR_OprDesc::int_type              |
 676                                   LIR_OprDesc::cpu_register          |
 677                                   LIR_OprDesc::single_size           |
 678                                   LIR_OprDesc::virtual_mask);
 679         break;
 680 
 681       case T_ADDRESS:
 682         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 683                                   LIR_OprDesc::address_type          |
 684                                   LIR_OprDesc::cpu_register          |
 685                                   LIR_OprDesc::single_size           |
 686                                   LIR_OprDesc::virtual_mask);
 687         break;
 688 
 689       case T_LONG:
 690         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 691                                   LIR_OprDesc::long_type             |
 692                                   LIR_OprDesc::cpu_register          |
 693                                   LIR_OprDesc::double_size           |
 694                                   LIR_OprDesc::virtual_mask);
 695         break;
 696 
 697 #ifdef __SOFTFP__
 698       case T_FLOAT:
 699         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 700                                   LIR_OprDesc::float_type  |
 701                                   LIR_OprDesc::cpu_register |
 702                                   LIR_OprDesc::single_size |
 703                                   LIR_OprDesc::virtual_mask);
 704         break;
 705       case T_DOUBLE:
 706         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 707                                   LIR_OprDesc::double_type |
 708                                   LIR_OprDesc::cpu_register |
 709                                   LIR_OprDesc::double_size |
 710                                   LIR_OprDesc::virtual_mask);
 711         break;
 712 #else // __SOFTFP__
 713       case T_FLOAT:
 714         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 715                                   LIR_OprDesc::float_type           |
 716                                   LIR_OprDesc::fpu_register         |
 717                                   LIR_OprDesc::single_size          |
 718                                   LIR_OprDesc::virtual_mask);
 719         break;
 720 
 721       case
 722         T_DOUBLE: res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 723                                             LIR_OprDesc::double_type           |
 724                                             LIR_OprDesc::fpu_register          |
 725                                             LIR_OprDesc::double_size           |
 726                                             LIR_OprDesc::virtual_mask);
 727         break;
 728 #endif // __SOFTFP__
 729       default:       ShouldNotReachHere(); res = illegalOpr;
 730     }
 731 
 732 #ifdef ASSERT
 733     res-&gt;validate_type();
 734     assert(res-&gt;vreg_number() == index, &quot;conversion check&quot;);
 735     assert(index &gt;= LIR_OprDesc::vreg_base, &quot;must start at vreg_base&quot;);
 736     assert(index &lt;= (max_jint &gt;&gt; LIR_OprDesc::data_shift), &quot;index is too big&quot;);
 737 
 738     // old-style calculation; check if old and new method are equal
 739     LIR_OprDesc::OprType t = as_OprType(type);
 740 #ifdef __SOFTFP__
 741     LIR_Opr old_res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 742                                t |
 743                                LIR_OprDesc::cpu_register |
 744                                LIR_OprDesc::size_for(type) | LIR_OprDesc::virtual_mask);
 745 #else // __SOFTFP__
 746     LIR_Opr old_res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) | t |
 747                                           ((type == T_FLOAT || type == T_DOUBLE) ?  LIR_OprDesc::fpu_register : LIR_OprDesc::cpu_register) |
 748                                LIR_OprDesc::size_for(type) | LIR_OprDesc::virtual_mask);
 749     assert(res == old_res, &quot;old and new method not equal&quot;);
 750 #endif // __SOFTFP__
 751 #endif // ASSERT
 752 
 753     return res;
 754   }
 755 
 756   // &#39;index&#39; is computed by FrameMap::local_stack_pos(index); do not use other parameters as
 757   // the index is platform independent; a double stack useing indeces 2 and 3 has always
 758   // index 2.
 759   static LIR_Opr stack(int index, BasicType type) {
 760     LIR_Opr res;
 761     switch (type) {
 762       case T_VALUETYPE: // fall through
 763       case T_OBJECT: // fall through
 764       case T_ARRAY:
 765         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 766                                   LIR_OprDesc::object_type           |
 767                                   LIR_OprDesc::stack_value           |
 768                                   LIR_OprDesc::single_size);
 769         break;
 770 
 771       case T_METADATA:
 772         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 773                                   LIR_OprDesc::metadata_type         |
 774                                   LIR_OprDesc::stack_value           |
 775                                   LIR_OprDesc::single_size);
 776         break;
 777       case T_INT:
 778         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 779                                   LIR_OprDesc::int_type              |
 780                                   LIR_OprDesc::stack_value           |
 781                                   LIR_OprDesc::single_size);
 782         break;
 783 
 784       case T_ADDRESS:
 785         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 786                                   LIR_OprDesc::address_type          |
 787                                   LIR_OprDesc::stack_value           |
 788                                   LIR_OprDesc::single_size);
 789         break;
 790 
 791       case T_LONG:
 792         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 793                                   LIR_OprDesc::long_type             |
 794                                   LIR_OprDesc::stack_value           |
 795                                   LIR_OprDesc::double_size);
 796         break;
 797 
 798       case T_FLOAT:
 799         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 800                                   LIR_OprDesc::float_type            |
 801                                   LIR_OprDesc::stack_value           |
 802                                   LIR_OprDesc::single_size);
 803         break;
 804       case T_DOUBLE:
 805         res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 806                                   LIR_OprDesc::double_type           |
 807                                   LIR_OprDesc::stack_value           |
 808                                   LIR_OprDesc::double_size);
 809         break;
 810 
 811       default:       ShouldNotReachHere(); res = illegalOpr;
 812     }
 813 
 814 #ifdef ASSERT
 815     assert(index &gt;= 0, &quot;index must be positive&quot;);
 816     assert(index &lt;= (max_jint &gt;&gt; LIR_OprDesc::data_shift), &quot;index is too big&quot;);
 817 
 818     LIR_Opr old_res = (LIR_Opr)(intptr_t)((index &lt;&lt; LIR_OprDesc::data_shift) |
 819                                           LIR_OprDesc::stack_value           |
 820                                           as_OprType(type)                   |
 821                                           LIR_OprDesc::size_for(type));
 822     assert(res == old_res, &quot;old and new method not equal&quot;);
 823 #endif
 824 
 825     return res;
 826   }
 827 
 828   static LIR_Opr intConst(jint i)                { return (LIR_Opr)(new LIR_Const(i)); }
 829   static LIR_Opr longConst(jlong l)              { return (LIR_Opr)(new LIR_Const(l)); }
 830   static LIR_Opr floatConst(jfloat f)            { return (LIR_Opr)(new LIR_Const(f)); }
 831   static LIR_Opr doubleConst(jdouble d)          { return (LIR_Opr)(new LIR_Const(d)); }
 832   static LIR_Opr oopConst(jobject o)             { return (LIR_Opr)(new LIR_Const(o)); }
 833   static LIR_Opr address(LIR_Address* a)         { return (LIR_Opr)a; }
 834   static LIR_Opr intptrConst(void* p)            { return (LIR_Opr)(new LIR_Const(p)); }
 835   static LIR_Opr intptrConst(intptr_t v)         { return (LIR_Opr)(new LIR_Const((void*)v)); }
 836   static LIR_Opr illegal()                       { return (LIR_Opr)-1; }
 837   static LIR_Opr addressConst(jint i)            { return (LIR_Opr)(new LIR_Const(i, true)); }
 838   static LIR_Opr metadataConst(Metadata* m)      { return (LIR_Opr)(new LIR_Const(m)); }
 839 
 840   static LIR_Opr value_type(ValueType* type);
 841   static LIR_Opr dummy_value_type(ValueType* type);
 842 };
 843 
 844 
 845 //-------------------------------------------------------------------------------
 846 //                   LIR Instructions
 847 //-------------------------------------------------------------------------------
 848 //
 849 // Note:
 850 //  - every instruction has a result operand
 851 //  - every instruction has an CodeEmitInfo operand (can be revisited later)
 852 //  - every instruction has a LIR_OpCode operand
 853 //  - LIR_OpN, means an instruction that has N input operands
 854 //
 855 // class hierarchy:
 856 //
 857 class  LIR_Op;
 858 class    LIR_Op0;
 859 class      LIR_OpLabel;
 860 class    LIR_Op1;
 861 class      LIR_OpBranch;
 862 class      LIR_OpConvert;
 863 class      LIR_OpAllocObj;
 864 class      LIR_OpRoundFP;
 865 class    LIR_Op2;
 866 class    LIR_OpDelay;
 867 class    LIR_Op3;
 868 class      LIR_OpAllocArray;
 869 class    LIR_OpCall;
 870 class      LIR_OpJavaCall;
 871 class      LIR_OpRTCall;
 872 class    LIR_OpArrayCopy;
 873 class    LIR_OpUpdateCRC32;
 874 class    LIR_OpLock;
 875 class    LIR_OpTypeCheck;
 876 class    LIR_OpFlattenedArrayCheck;
 877 class    LIR_OpNullFreeArrayCheck;
 878 class    LIR_OpSubstitutabilityCheck;
 879 class    LIR_OpCompareAndSwap;
 880 class    LIR_OpProfileCall;
 881 class    LIR_OpProfileType;
 882 #ifdef ASSERT
 883 class    LIR_OpAssert;
 884 #endif
 885 
 886 // LIR operation codes
 887 enum LIR_Code {
 888     lir_none
 889   , begin_op0
 890       , lir_word_align
 891       , lir_label
 892       , lir_nop
 893       , lir_backwardbranch_target
 894       , lir_std_entry
 895       , lir_osr_entry
 896       , lir_build_frame
 897       , lir_fpop_raw
 898       , lir_breakpoint
 899       , lir_rtcall
 900       , lir_membar
 901       , lir_membar_acquire
 902       , lir_membar_release
 903       , lir_membar_loadload
 904       , lir_membar_storestore
 905       , lir_membar_loadstore
 906       , lir_membar_storeload
 907       , lir_get_thread
 908       , lir_on_spin_wait
<a name="1" id="anc1"></a><span class="line-added"> 909       , lir_check_orig_pc</span>
 910   , end_op0
 911   , begin_op1
 912       , lir_fxch
 913       , lir_fld
 914       , lir_push
 915       , lir_pop
 916       , lir_null_check
 917       , lir_return
 918       , lir_leal
 919       , lir_branch
 920       , lir_cond_float_branch
 921       , lir_move
 922       , lir_convert
 923       , lir_alloc_object
 924       , lir_monaddr
 925       , lir_roundfp
 926       , lir_safepoint
 927       , lir_pack64
 928       , lir_unpack64
 929       , lir_unwind
 930   , end_op1
 931   , begin_op2
 932       , lir_cmp
 933       , lir_cmp_l2i
 934       , lir_ucmp_fd2i
 935       , lir_cmp_fd2i
 936       , lir_cmove
 937       , lir_add
 938       , lir_sub
 939       , lir_mul
 940       , lir_mul_strictfp
 941       , lir_div
 942       , lir_div_strictfp
 943       , lir_rem
 944       , lir_sqrt
 945       , lir_abs
 946       , lir_neg
 947       , lir_tan
 948       , lir_log10
 949       , lir_logic_and
 950       , lir_logic_or
 951       , lir_logic_xor
 952       , lir_shl
 953       , lir_shr
 954       , lir_ushr
 955       , lir_alloc_array
 956       , lir_throw
 957       , lir_xadd
 958       , lir_xchg
 959   , end_op2
 960   , begin_op3
 961       , lir_idiv
 962       , lir_irem
 963       , lir_fmad
 964       , lir_fmaf
 965   , end_op3
 966   , begin_opJavaCall
 967       , lir_static_call
 968       , lir_optvirtual_call
 969       , lir_icvirtual_call
 970       , lir_virtual_call
 971       , lir_dynamic_call
 972   , end_opJavaCall
 973   , begin_opArrayCopy
 974       , lir_arraycopy
 975   , end_opArrayCopy
 976   , begin_opUpdateCRC32
 977       , lir_updatecrc32
 978   , end_opUpdateCRC32
 979   , begin_opLock
 980     , lir_lock
 981     , lir_unlock
 982   , end_opLock
 983   , begin_delay_slot
 984     , lir_delay_slot
 985   , end_delay_slot
 986   , begin_opTypeCheck
 987     , lir_instanceof
 988     , lir_checkcast
 989     , lir_store_check
 990   , end_opTypeCheck
 991   , begin_opFlattenedArrayCheck
 992     , lir_flattened_array_check
 993   , end_opFlattenedArrayCheck
 994   , begin_opNullFreeArrayCheck
 995     , lir_null_free_array_check
 996   , end_opNullFreeArrayCheck
 997   , begin_opSubstitutabilityCheck
 998     , lir_substitutability_check
 999   , end_opSubstitutabilityCheck
1000   , begin_opCompareAndSwap
1001     , lir_cas_long
1002     , lir_cas_obj
1003     , lir_cas_int
1004   , end_opCompareAndSwap
1005   , begin_opMDOProfile
1006     , lir_profile_call
1007     , lir_profile_type
1008   , end_opMDOProfile
1009   , begin_opAssert
1010     , lir_assert
1011   , end_opAssert
1012 };
1013 
1014 
1015 enum LIR_Condition {
1016     lir_cond_equal
1017   , lir_cond_notEqual
1018   , lir_cond_less
1019   , lir_cond_lessEqual
1020   , lir_cond_greaterEqual
1021   , lir_cond_greater
1022   , lir_cond_belowEqual
1023   , lir_cond_aboveEqual
1024   , lir_cond_always
1025   , lir_cond_unknown = -1
1026 };
1027 
1028 
1029 enum LIR_PatchCode {
1030   lir_patch_none,
1031   lir_patch_low,
1032   lir_patch_high,
1033   lir_patch_normal
1034 };
1035 
1036 
1037 enum LIR_MoveKind {
1038   lir_move_normal,
1039   lir_move_volatile,
1040   lir_move_unaligned,
1041   lir_move_wide,
1042   lir_move_max_flag
1043 };
1044 
1045 
1046 // --------------------------------------------------
1047 // LIR_Op
1048 // --------------------------------------------------
1049 class LIR_Op: public CompilationResourceObj {
1050  friend class LIR_OpVisitState;
1051 
1052 #ifdef ASSERT
1053  private:
1054   const char *  _file;
1055   int           _line;
1056 #endif
1057 
1058  protected:
1059   LIR_Opr       _result;
1060   unsigned short _code;
1061   unsigned short _flags;
1062   CodeEmitInfo* _info;
1063   int           _id;     // value id for register allocation
1064   int           _fpu_pop_count;
1065   Instruction*  _source; // for debugging
1066 
1067   static void print_condition(outputStream* out, LIR_Condition cond) PRODUCT_RETURN;
1068 
1069  protected:
1070   static bool is_in_range(LIR_Code test, LIR_Code start, LIR_Code end)  { return start &lt; test &amp;&amp; test &lt; end; }
1071 
1072  public:
1073   LIR_Op()
1074     :
1075 #ifdef ASSERT
1076       _file(NULL)
1077     , _line(0),
1078 #endif
1079       _result(LIR_OprFact::illegalOpr)
1080     , _code(lir_none)
1081     , _flags(0)
1082     , _info(NULL)
1083     , _id(-1)
1084     , _fpu_pop_count(0)
1085     , _source(NULL) {}
1086 
1087   LIR_Op(LIR_Code code, LIR_Opr result, CodeEmitInfo* info)
1088     :
1089 #ifdef ASSERT
1090       _file(NULL)
1091     , _line(0),
1092 #endif
1093       _result(result)
1094     , _code(code)
1095     , _flags(0)
1096     , _info(info)
1097     , _id(-1)
1098     , _fpu_pop_count(0)
1099     , _source(NULL) {}
1100 
1101   CodeEmitInfo* info() const                  { return _info;   }
1102   LIR_Code code()      const                  { return (LIR_Code)_code;   }
1103   LIR_Opr result_opr() const                  { return _result; }
1104   void    set_result_opr(LIR_Opr opr)         { _result = opr;  }
1105 
1106 #ifdef ASSERT
1107   void set_file_and_line(const char * file, int line) {
1108     _file = file;
1109     _line = line;
1110   }
1111 #endif
1112 
1113   virtual const char * name() const PRODUCT_RETURN0;
1114   virtual void visit(LIR_OpVisitState* state);
1115 
1116   int id()             const                  { return _id;     }
1117   void set_id(int id)                         { _id = id; }
1118 
1119   // FPU stack simulation helpers -- only used on Intel
1120   void set_fpu_pop_count(int count)           { assert(count &gt;= 0 &amp;&amp; count &lt;= 1, &quot;currently only 0 and 1 are valid&quot;); _fpu_pop_count = count; }
1121   int  fpu_pop_count() const                  { return _fpu_pop_count; }
1122   bool pop_fpu_stack()                        { return _fpu_pop_count &gt; 0; }
1123 
1124   Instruction* source() const                 { return _source; }
1125   void set_source(Instruction* ins)           { _source = ins; }
1126 
1127   virtual void emit_code(LIR_Assembler* masm) = 0;
1128   virtual void print_instr(outputStream* out) const   = 0;
1129   virtual void print_on(outputStream* st) const PRODUCT_RETURN;
1130 
1131   virtual bool is_patching() { return false; }
1132   virtual LIR_OpCall* as_OpCall() { return NULL; }
1133   virtual LIR_OpJavaCall* as_OpJavaCall() { return NULL; }
1134   virtual LIR_OpLabel* as_OpLabel() { return NULL; }
1135   virtual LIR_OpDelay* as_OpDelay() { return NULL; }
1136   virtual LIR_OpLock* as_OpLock() { return NULL; }
1137   virtual LIR_OpAllocArray* as_OpAllocArray() { return NULL; }
1138   virtual LIR_OpAllocObj* as_OpAllocObj() { return NULL; }
1139   virtual LIR_OpRoundFP* as_OpRoundFP() { return NULL; }
1140   virtual LIR_OpBranch* as_OpBranch() { return NULL; }
1141   virtual LIR_OpRTCall* as_OpRTCall() { return NULL; }
1142   virtual LIR_OpConvert* as_OpConvert() { return NULL; }
1143   virtual LIR_Op0* as_Op0() { return NULL; }
1144   virtual LIR_Op1* as_Op1() { return NULL; }
1145   virtual LIR_Op2* as_Op2() { return NULL; }
1146   virtual LIR_Op3* as_Op3() { return NULL; }
1147   virtual LIR_OpArrayCopy* as_OpArrayCopy() { return NULL; }
1148   virtual LIR_OpUpdateCRC32* as_OpUpdateCRC32() { return NULL; }
1149   virtual LIR_OpTypeCheck* as_OpTypeCheck() { return NULL; }
1150   virtual LIR_OpFlattenedArrayCheck* as_OpFlattenedArrayCheck() { return NULL; }
1151   virtual LIR_OpNullFreeArrayCheck* as_OpNullFreeArrayCheck() { return NULL; }
1152   virtual LIR_OpSubstitutabilityCheck* as_OpSubstitutabilityCheck() { return NULL; }
1153   virtual LIR_OpCompareAndSwap* as_OpCompareAndSwap() { return NULL; }
1154   virtual LIR_OpProfileCall* as_OpProfileCall() { return NULL; }
1155   virtual LIR_OpProfileType* as_OpProfileType() { return NULL; }
1156 #ifdef ASSERT
1157   virtual LIR_OpAssert* as_OpAssert() { return NULL; }
1158 #endif
1159 
1160   virtual void verify() const {}
1161 };
1162 
1163 // for calls
1164 class LIR_OpCall: public LIR_Op {
1165  friend class LIR_OpVisitState;
1166 
1167  protected:
1168   address      _addr;
1169   LIR_OprList* _arguments;
1170  protected:
1171   LIR_OpCall(LIR_Code code, address addr, LIR_Opr result,
1172              LIR_OprList* arguments, CodeEmitInfo* info = NULL)
1173     : LIR_Op(code, result, info)
1174     , _addr(addr)
1175     , _arguments(arguments) {}
1176 
1177  public:
1178   address addr() const                           { return _addr; }
1179   const LIR_OprList* arguments() const           { return _arguments; }
1180   virtual LIR_OpCall* as_OpCall()                { return this; }
1181 };
1182 
1183 
1184 // --------------------------------------------------
1185 // LIR_OpJavaCall
1186 // --------------------------------------------------
1187 class LIR_OpJavaCall: public LIR_OpCall {
1188  friend class LIR_OpVisitState;
1189 
1190  private:
1191   ciMethod* _method;
1192   LIR_Opr   _receiver;
1193   LIR_Opr   _method_handle_invoke_SP_save_opr;  // Used in LIR_OpVisitState::visit to store the reference to FrameMap::method_handle_invoke_SP_save_opr.
1194 
1195  public:
1196   LIR_OpJavaCall(LIR_Code code, ciMethod* method,
1197                  LIR_Opr receiver, LIR_Opr result,
1198                  address addr, LIR_OprList* arguments,
1199                  CodeEmitInfo* info)
1200   : LIR_OpCall(code, addr, result, arguments, info)
1201   , _method(method)
1202   , _receiver(receiver)
1203   , _method_handle_invoke_SP_save_opr(LIR_OprFact::illegalOpr)
1204   { assert(is_in_range(code, begin_opJavaCall, end_opJavaCall), &quot;code check&quot;); }
1205 
1206   LIR_OpJavaCall(LIR_Code code, ciMethod* method,
1207                  LIR_Opr receiver, LIR_Opr result, intptr_t vtable_offset,
1208                  LIR_OprList* arguments, CodeEmitInfo* info)
1209   : LIR_OpCall(code, (address)vtable_offset, result, arguments, info)
1210   , _method(method)
1211   , _receiver(receiver)
1212   , _method_handle_invoke_SP_save_opr(LIR_OprFact::illegalOpr)
1213   { assert(is_in_range(code, begin_opJavaCall, end_opJavaCall), &quot;code check&quot;); }
1214 
1215   LIR_Opr receiver() const                       { return _receiver; }
1216   ciMethod* method() const                       { return _method;   }
1217 
1218   // JSR 292 support.
1219   bool is_invokedynamic() const                  { return code() == lir_dynamic_call; }
1220   bool is_method_handle_invoke() const {
1221     return method()-&gt;is_compiled_lambda_form() ||   // Java-generated lambda form
1222            method()-&gt;is_method_handle_intrinsic();  // JVM-generated MH intrinsic
1223   }
1224 
1225   intptr_t vtable_offset() const {
1226     assert(_code == lir_virtual_call, &quot;only have vtable for real vcall&quot;);
1227     return (intptr_t) addr();
1228   }
1229 
1230   virtual void emit_code(LIR_Assembler* masm);
1231   virtual LIR_OpJavaCall* as_OpJavaCall() { return this; }
1232   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
1233 
1234   bool maybe_return_as_fields(ciValueKlass** vk = NULL) const;
1235 };
1236 
1237 // --------------------------------------------------
1238 // LIR_OpLabel
1239 // --------------------------------------------------
1240 // Location where a branch can continue
1241 class LIR_OpLabel: public LIR_Op {
1242  friend class LIR_OpVisitState;
1243 
1244  private:
1245   Label* _label;
1246  public:
1247   LIR_OpLabel(Label* lbl)
1248    : LIR_Op(lir_label, LIR_OprFact::illegalOpr, NULL)
1249    , _label(lbl)                                 {}
1250   Label* label() const                           { return _label; }
1251 
1252   virtual void emit_code(LIR_Assembler* masm);
1253   virtual LIR_OpLabel* as_OpLabel() { return this; }
1254   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
1255 };
1256 
1257 // LIR_OpArrayCopy
1258 class LIR_OpArrayCopy: public LIR_Op {
1259  friend class LIR_OpVisitState;
1260 
1261  private:
1262   ArrayCopyStub*  _stub;
1263   LIR_Opr   _src;
1264   LIR_Opr   _src_pos;
1265   LIR_Opr   _dst;
1266   LIR_Opr   _dst_pos;
1267   LIR_Opr   _length;
1268   LIR_Opr   _tmp;
1269   ciArrayKlass* _expected_type;
1270   int       _flags;
1271 
1272 public:
1273   enum Flags {
1274     src_null_check         = 1 &lt;&lt; 0,
1275     dst_null_check         = 1 &lt;&lt; 1,
1276     src_pos_positive_check = 1 &lt;&lt; 2,
1277     dst_pos_positive_check = 1 &lt;&lt; 3,
1278     length_positive_check  = 1 &lt;&lt; 4,
1279     src_range_check        = 1 &lt;&lt; 5,
1280     dst_range_check        = 1 &lt;&lt; 6,
1281     type_check             = 1 &lt;&lt; 7,
1282     overlapping            = 1 &lt;&lt; 8,
1283     unaligned              = 1 &lt;&lt; 9,
1284     src_objarray           = 1 &lt;&lt; 10,
1285     dst_objarray           = 1 &lt;&lt; 11,
1286     always_slow_path       = 1 &lt;&lt; 12,
1287     src_valuetype_check    = 1 &lt;&lt; 13,
1288     dst_valuetype_check    = 1 &lt;&lt; 14,
1289     all_flags              = (1 &lt;&lt; 15) - 1
1290   };
1291 
1292   LIR_OpArrayCopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length, LIR_Opr tmp,
1293                   ciArrayKlass* expected_type, int flags, CodeEmitInfo* info);
1294 
1295   LIR_Opr src() const                            { return _src; }
1296   LIR_Opr src_pos() const                        { return _src_pos; }
1297   LIR_Opr dst() const                            { return _dst; }
1298   LIR_Opr dst_pos() const                        { return _dst_pos; }
1299   LIR_Opr length() const                         { return _length; }
1300   LIR_Opr tmp() const                            { return _tmp; }
1301   int flags() const                              { return _flags; }
1302   ciArrayKlass* expected_type() const            { return _expected_type; }
1303   ArrayCopyStub* stub() const                    { return _stub; }
1304 
1305   virtual void emit_code(LIR_Assembler* masm);
1306   virtual LIR_OpArrayCopy* as_OpArrayCopy() { return this; }
1307   void print_instr(outputStream* out) const PRODUCT_RETURN;
1308 };
1309 
1310 // LIR_OpUpdateCRC32
1311 class LIR_OpUpdateCRC32: public LIR_Op {
1312   friend class LIR_OpVisitState;
1313 
1314 private:
1315   LIR_Opr   _crc;
1316   LIR_Opr   _val;
1317 
1318 public:
1319 
1320   LIR_OpUpdateCRC32(LIR_Opr crc, LIR_Opr val, LIR_Opr res);
1321 
1322   LIR_Opr crc() const                            { return _crc; }
1323   LIR_Opr val() const                            { return _val; }
1324 
1325   virtual void emit_code(LIR_Assembler* masm);
1326   virtual LIR_OpUpdateCRC32* as_OpUpdateCRC32()  { return this; }
1327   void print_instr(outputStream* out) const PRODUCT_RETURN;
1328 };
1329 
1330 // --------------------------------------------------
1331 // LIR_Op0
1332 // --------------------------------------------------
1333 class LIR_Op0: public LIR_Op {
1334  friend class LIR_OpVisitState;
1335 
1336  public:
1337   LIR_Op0(LIR_Code code)
1338    : LIR_Op(code, LIR_OprFact::illegalOpr, NULL)  { assert(is_in_range(code, begin_op0, end_op0), &quot;code check&quot;); }
1339   LIR_Op0(LIR_Code code, LIR_Opr result, CodeEmitInfo* info = NULL)
1340    : LIR_Op(code, result, info)  { assert(is_in_range(code, begin_op0, end_op0), &quot;code check&quot;); }
1341 
1342   virtual void emit_code(LIR_Assembler* masm);
1343   virtual LIR_Op0* as_Op0() { return this; }
1344   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
1345 };
1346 
1347 
1348 // --------------------------------------------------
1349 // LIR_Op1
1350 // --------------------------------------------------
1351 
1352 class LIR_Op1: public LIR_Op {
1353  friend class LIR_OpVisitState;
1354 
1355  protected:
1356   LIR_Opr         _opr;   // input operand
1357   BasicType       _type;  // Operand types
1358   LIR_PatchCode   _patch; // only required with patchin (NEEDS_CLEANUP: do we want a special instruction for patching?)
1359 
1360   static void print_patch_code(outputStream* out, LIR_PatchCode code);
1361 
1362   void set_kind(LIR_MoveKind kind) {
1363     assert(code() == lir_move, &quot;must be&quot;);
1364     _flags = kind;
1365   }
1366 
1367  public:
1368   LIR_Op1(LIR_Code code, LIR_Opr opr, LIR_Opr result = LIR_OprFact::illegalOpr, BasicType type = T_ILLEGAL, LIR_PatchCode patch = lir_patch_none, CodeEmitInfo* info = NULL)
1369     : LIR_Op(code, result, info)
1370     , _opr(opr)
1371     , _type(type)
1372     , _patch(patch)                    { assert(is_in_range(code, begin_op1, end_op1), &quot;code check&quot;); }
1373 
1374   LIR_Op1(LIR_Code code, LIR_Opr opr, LIR_Opr result, BasicType type, LIR_PatchCode patch, CodeEmitInfo* info, LIR_MoveKind kind)
1375     : LIR_Op(code, result, info)
1376     , _opr(opr)
1377     , _type(type)
1378     , _patch(patch)                    {
1379     assert(code == lir_move, &quot;must be&quot;);
1380     set_kind(kind);
1381   }
1382 
1383   LIR_Op1(LIR_Code code, LIR_Opr opr, CodeEmitInfo* info)
1384     : LIR_Op(code, LIR_OprFact::illegalOpr, info)
1385     , _opr(opr)
1386     , _type(T_ILLEGAL)
1387     , _patch(lir_patch_none)           { assert(is_in_range(code, begin_op1, end_op1), &quot;code check&quot;); }
1388 
1389   LIR_Opr in_opr()           const               { return _opr;   }
1390   LIR_PatchCode patch_code() const               { return _patch; }
1391   BasicType type()           const               { return _type;  }
1392 
1393   LIR_MoveKind move_kind() const {
1394     assert(code() == lir_move, &quot;must be&quot;);
1395     return (LIR_MoveKind)_flags;
1396   }
1397 
1398   virtual bool is_patching() { return _patch != lir_patch_none; }
1399   virtual void emit_code(LIR_Assembler* masm);
1400   virtual LIR_Op1* as_Op1() { return this; }
1401   virtual const char * name() const PRODUCT_RETURN0;
1402 
1403   void set_in_opr(LIR_Opr opr) { _opr = opr; }
1404 
1405   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
1406   virtual void verify() const;
1407 };
1408 
1409 
1410 // for runtime calls
1411 class LIR_OpRTCall: public LIR_OpCall {
1412  friend class LIR_OpVisitState;
1413 
1414  private:
1415   LIR_Opr _tmp;
1416  public:
1417   LIR_OpRTCall(address addr, LIR_Opr tmp,
1418                LIR_Opr result, LIR_OprList* arguments, CodeEmitInfo* info = NULL)
1419     : LIR_OpCall(lir_rtcall, addr, result, arguments, info)
1420     , _tmp(tmp) {}
1421 
1422   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
1423   virtual void emit_code(LIR_Assembler* masm);
1424   virtual LIR_OpRTCall* as_OpRTCall() { return this; }
1425 
1426   LIR_Opr tmp() const                            { return _tmp; }
1427 
1428   virtual void verify() const;
1429 };
1430 
1431 
1432 class LIR_OpBranch: public LIR_Op {
1433  friend class LIR_OpVisitState;
1434 
1435  private:
1436   LIR_Condition _cond;
1437   BasicType     _type;
1438   Label*        _label;
1439   BlockBegin*   _block;  // if this is a branch to a block, this is the block
1440   BlockBegin*   _ublock; // if this is a float-branch, this is the unorderd block
1441   CodeStub*     _stub;   // if this is a branch to a stub, this is the stub
1442 
1443  public:
1444   LIR_OpBranch(LIR_Condition cond, BasicType type, Label* lbl)
1445     : LIR_Op(lir_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*) NULL)
1446     , _cond(cond)
1447     , _type(type)
1448     , _label(lbl)
1449     , _block(NULL)
1450     , _ublock(NULL)
1451     , _stub(NULL) { }
1452 
1453   LIR_OpBranch(LIR_Condition cond, BasicType type, BlockBegin* block);
1454   LIR_OpBranch(LIR_Condition cond, BasicType type, CodeStub* stub);
1455 
1456   // for unordered comparisons
1457   LIR_OpBranch(LIR_Condition cond, BasicType type, BlockBegin* block, BlockBegin* ublock);
1458 
1459   LIR_Condition cond()        const              { return _cond;        }
1460   BasicType     type()        const              { return _type;        }
1461   Label*        label()       const              { return _label;       }
1462   BlockBegin*   block()       const              { return _block;       }
1463   BlockBegin*   ublock()      const              { return _ublock;      }
1464   CodeStub*     stub()        const              { return _stub;       }
1465 
1466   void          change_block(BlockBegin* b);
1467   void          change_ublock(BlockBegin* b);
1468   void          negate_cond();
1469 
1470   virtual void emit_code(LIR_Assembler* masm);
1471   virtual LIR_OpBranch* as_OpBranch() { return this; }
1472   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
1473 };
1474 
1475 
1476 class ConversionStub;
1477 
1478 class LIR_OpConvert: public LIR_Op1 {
1479  friend class LIR_OpVisitState;
1480 
1481  private:
1482    Bytecodes::Code _bytecode;
1483    ConversionStub* _stub;
1484 
1485  public:
1486    LIR_OpConvert(Bytecodes::Code code, LIR_Opr opr, LIR_Opr result, ConversionStub* stub)
1487      : LIR_Op1(lir_convert, opr, result)
1488      , _bytecode(code)
1489      , _stub(stub)                               {}
1490 
1491   Bytecodes::Code bytecode() const               { return _bytecode; }
1492   ConversionStub* stub() const                   { return _stub; }
1493 
1494   virtual void emit_code(LIR_Assembler* masm);
1495   virtual LIR_OpConvert* as_OpConvert() { return this; }
1496   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
1497 
1498   static void print_bytecode(outputStream* out, Bytecodes::Code code) PRODUCT_RETURN;
1499 };
1500 
1501 
1502 // LIR_OpAllocObj
1503 class LIR_OpAllocObj : public LIR_Op1 {
1504  friend class LIR_OpVisitState;
1505 
1506  private:
1507   LIR_Opr _tmp1;
1508   LIR_Opr _tmp2;
1509   LIR_Opr _tmp3;
1510   LIR_Opr _tmp4;
1511   int     _hdr_size;
1512   int     _obj_size;
1513   CodeStub* _stub;
1514   bool    _init_check;
1515 
1516  public:
1517   LIR_OpAllocObj(LIR_Opr klass, LIR_Opr result,
1518                  LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4,
1519                  int hdr_size, int obj_size, bool init_check, CodeStub* stub)
1520     : LIR_Op1(lir_alloc_object, klass, result)
1521     , _tmp1(t1)
1522     , _tmp2(t2)
1523     , _tmp3(t3)
1524     , _tmp4(t4)
1525     , _hdr_size(hdr_size)
1526     , _obj_size(obj_size)
1527     , _stub(stub)
1528     , _init_check(init_check)                    { }
1529 
1530   LIR_Opr klass()        const                   { return in_opr();     }
1531   LIR_Opr obj()          const                   { return result_opr(); }
1532   LIR_Opr tmp1()         const                   { return _tmp1;        }
1533   LIR_Opr tmp2()         const                   { return _tmp2;        }
1534   LIR_Opr tmp3()         const                   { return _tmp3;        }
1535   LIR_Opr tmp4()         const                   { return _tmp4;        }
1536   int     header_size()  const                   { return _hdr_size;    }
1537   int     object_size()  const                   { return _obj_size;    }
1538   bool    init_check()   const                   { return _init_check;  }
1539   CodeStub* stub()       const                   { return _stub;        }
1540 
1541   virtual void emit_code(LIR_Assembler* masm);
1542   virtual LIR_OpAllocObj * as_OpAllocObj () { return this; }
1543   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
1544 };
1545 
1546 
1547 // LIR_OpRoundFP
1548 class LIR_OpRoundFP : public LIR_Op1 {
1549  friend class LIR_OpVisitState;
1550 
1551  private:
1552   LIR_Opr _tmp;
1553 
1554  public:
1555   LIR_OpRoundFP(LIR_Opr reg, LIR_Opr stack_loc_temp, LIR_Opr result)
1556     : LIR_Op1(lir_roundfp, reg, result)
1557     , _tmp(stack_loc_temp) {}
1558 
1559   LIR_Opr tmp() const                            { return _tmp; }
1560   virtual LIR_OpRoundFP* as_OpRoundFP()          { return this; }
1561   void print_instr(outputStream* out) const PRODUCT_RETURN;
1562 };
1563 
1564 // LIR_OpTypeCheck
1565 class LIR_OpTypeCheck: public LIR_Op {
1566  friend class LIR_OpVisitState;
1567 
1568  private:
1569   LIR_Opr       _object;
1570   LIR_Opr       _array;
1571   ciKlass*      _klass;
1572   LIR_Opr       _tmp1;
1573   LIR_Opr       _tmp2;
1574   LIR_Opr       _tmp3;
1575   bool          _fast_check;
1576   CodeEmitInfo* _info_for_patch;
1577   CodeEmitInfo* _info_for_exception;
1578   CodeStub*     _stub;
1579   ciMethod*     _profiled_method;
1580   int           _profiled_bci;
1581   bool          _should_profile;
1582   bool          _need_null_check;
1583 
1584 public:
1585   LIR_OpTypeCheck(LIR_Code code, LIR_Opr result, LIR_Opr object, ciKlass* klass,
1586                   LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
1587                   CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub, bool need_null_check = true);
1588   LIR_OpTypeCheck(LIR_Code code, LIR_Opr object, LIR_Opr array,
1589                   LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception);
1590 
1591   LIR_Opr object() const                         { return _object;         }
1592   LIR_Opr array() const                          { assert(code() == lir_store_check, &quot;not valid&quot;); return _array;         }
1593   LIR_Opr tmp1() const                           { return _tmp1;           }
1594   LIR_Opr tmp2() const                           { return _tmp2;           }
1595   LIR_Opr tmp3() const                           { return _tmp3;           }
1596   ciKlass* klass() const                         { assert(code() == lir_instanceof || code() == lir_checkcast, &quot;not valid&quot;); return _klass;          }
1597   bool fast_check() const                        { assert(code() == lir_instanceof || code() == lir_checkcast, &quot;not valid&quot;); return _fast_check;     }
1598   CodeEmitInfo* info_for_patch() const           { return _info_for_patch;  }
1599   CodeEmitInfo* info_for_exception() const       { return _info_for_exception; }
1600   CodeStub* stub() const                         { return _stub;           }
1601 
1602   // MethodData* profiling
1603   void set_profiled_method(ciMethod *method)     { _profiled_method = method; }
1604   void set_profiled_bci(int bci)                 { _profiled_bci = bci;       }
1605   void set_should_profile(bool b)                { _should_profile = b;       }
1606   ciMethod* profiled_method() const              { return _profiled_method;   }
1607   int       profiled_bci() const                 { return _profiled_bci;      }
1608   bool      should_profile() const               { return _should_profile;    }
1609   bool      need_null_check() const              { return _need_null_check;   }
1610   virtual bool is_patching() { return _info_for_patch != NULL; }
1611   virtual void emit_code(LIR_Assembler* masm);
1612   virtual LIR_OpTypeCheck* as_OpTypeCheck() { return this; }
1613   void print_instr(outputStream* out) const PRODUCT_RETURN;
1614 };
1615 
1616 // LIR_OpFlattenedArrayCheck
1617 class LIR_OpFlattenedArrayCheck: public LIR_Op {
1618  friend class LIR_OpVisitState;
1619 
1620  private:
1621   LIR_Opr       _array;
1622   LIR_Opr       _value;
1623   LIR_Opr       _tmp;
1624   CodeStub*     _stub;
1625 public:
1626   LIR_OpFlattenedArrayCheck(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub);
1627   LIR_Opr array() const                          { return _array;         }
1628   LIR_Opr value() const                          { return _value;         }
1629   LIR_Opr tmp() const                            { return _tmp;           }
1630   CodeStub* stub() const                         { return _stub;          }
1631 
1632   virtual void emit_code(LIR_Assembler* masm);
1633   virtual LIR_OpFlattenedArrayCheck* as_OpFlattenedArrayCheck() { return this; }
1634   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
1635 };
1636 
1637 // LIR_OpNullFreeArrayCheck
1638 class LIR_OpNullFreeArrayCheck: public LIR_Op {
1639  friend class LIR_OpVisitState;
1640 
1641  private:
1642   LIR_Opr       _array;
1643   LIR_Opr       _tmp;
1644 public:
1645   LIR_OpNullFreeArrayCheck(LIR_Opr array, LIR_Opr tmp);
1646   LIR_Opr array() const                          { return _array;         }
1647   LIR_Opr tmp() const                            { return _tmp;           }
1648 
1649   virtual void emit_code(LIR_Assembler* masm);
1650   virtual LIR_OpNullFreeArrayCheck* as_OpNullFreeArrayCheck() { return this; }
1651   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
1652 };
1653 
1654 class LIR_OpSubstitutabilityCheck: public LIR_Op {
1655  friend class LIR_OpVisitState;
1656 
1657  private:
1658   LIR_Opr       _left;
1659   LIR_Opr       _right;
1660   LIR_Opr       _equal_result;
1661   LIR_Opr       _not_equal_result;
1662   LIR_Opr       _tmp1;
1663   LIR_Opr       _tmp2;
1664   ciKlass*      _left_klass;
1665   ciKlass*      _right_klass;
1666   LIR_Opr       _left_klass_op;
1667   LIR_Opr       _right_klass_op;
1668   CodeStub*     _stub;
1669 public:
1670   LIR_OpSubstitutabilityCheck(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,
1671                               LIR_Opr tmp1, LIR_Opr tmp2,
1672                               ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,
1673                               CodeEmitInfo* info, CodeStub* stub);
1674 
1675   LIR_Opr left() const             { return _left; }
1676   LIR_Opr right() const            { return _right; }
1677   LIR_Opr equal_result() const     { return _equal_result; }
1678   LIR_Opr not_equal_result() const { return _not_equal_result; }
1679   LIR_Opr tmp1() const             { return _tmp1; }
1680   LIR_Opr tmp2() const             { return _tmp2; }
1681   ciKlass* left_klass() const      { return _left_klass; }
1682   ciKlass* right_klass() const     { return _right_klass; }
1683   LIR_Opr left_klass_op() const    { return _left_klass_op; }
1684   LIR_Opr right_klass_op() const   { return _right_klass_op; }
1685   CodeStub* stub() const           { return _stub; }
1686 
1687   virtual void emit_code(LIR_Assembler* masm);
1688   virtual LIR_OpSubstitutabilityCheck* as_OpSubstitutabilityCheck() { return this; }
1689   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
1690 };
1691 
1692 // LIR_Op2
1693 class LIR_Op2: public LIR_Op {
1694  friend class LIR_OpVisitState;
1695 
1696   int  _fpu_stack_size; // for sin/cos implementation on Intel
1697 
1698  protected:
1699   LIR_Opr   _opr1;
1700   LIR_Opr   _opr2;
1701   BasicType _type;
1702   LIR_Opr   _tmp1;
1703   LIR_Opr   _tmp2;
1704   LIR_Opr   _tmp3;
1705   LIR_Opr   _tmp4;
1706   LIR_Opr   _tmp5;
1707   LIR_Condition _condition;
1708 
1709   void verify() const;
1710 
1711  public:
1712   LIR_Op2(LIR_Code code, LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, CodeEmitInfo* info = NULL)
1713     : LIR_Op(code, LIR_OprFact::illegalOpr, info)
1714     , _fpu_stack_size(0)
1715     , _opr1(opr1)
1716     , _opr2(opr2)
1717     , _type(T_ILLEGAL)
1718     , _tmp1(LIR_OprFact::illegalOpr)
1719     , _tmp2(LIR_OprFact::illegalOpr)
1720     , _tmp3(LIR_OprFact::illegalOpr)
1721     , _tmp4(LIR_OprFact::illegalOpr)
1722     , _tmp5(LIR_OprFact::illegalOpr)
1723     , _condition(condition) {
1724     assert(code == lir_cmp || code == lir_assert, &quot;code check&quot;);
1725   }
1726 
1727   LIR_Op2(LIR_Code code, LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type)
1728     : LIR_Op(code, result, NULL)
1729     , _fpu_stack_size(0)
1730     , _opr1(opr1)
1731     , _opr2(opr2)
1732     , _type(type)
1733     , _tmp1(LIR_OprFact::illegalOpr)
1734     , _tmp2(LIR_OprFact::illegalOpr)
1735     , _tmp3(LIR_OprFact::illegalOpr)
1736     , _tmp4(LIR_OprFact::illegalOpr)
1737     , _tmp5(LIR_OprFact::illegalOpr)
1738     , _condition(condition) {
1739     assert(code == lir_cmove, &quot;code check&quot;);
1740     assert(type != T_ILLEGAL, &quot;cmove should have type&quot;);
1741   }
1742 
1743   LIR_Op2(LIR_Code code, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result = LIR_OprFact::illegalOpr,
1744           CodeEmitInfo* info = NULL, BasicType type = T_ILLEGAL)
1745     : LIR_Op(code, result, info)
1746     , _fpu_stack_size(0)
1747     , _opr1(opr1)
1748     , _opr2(opr2)
1749     , _type(type)
1750     , _tmp1(LIR_OprFact::illegalOpr)
1751     , _tmp2(LIR_OprFact::illegalOpr)
1752     , _tmp3(LIR_OprFact::illegalOpr)
1753     , _tmp4(LIR_OprFact::illegalOpr)
1754     , _tmp5(LIR_OprFact::illegalOpr)
1755     , _condition(lir_cond_unknown) {
1756     assert(code != lir_cmp &amp;&amp; is_in_range(code, begin_op2, end_op2), &quot;code check&quot;);
1757   }
1758 
1759   LIR_Op2(LIR_Code code, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, LIR_Opr tmp1, LIR_Opr tmp2 = LIR_OprFact::illegalOpr,
1760           LIR_Opr tmp3 = LIR_OprFact::illegalOpr, LIR_Opr tmp4 = LIR_OprFact::illegalOpr, LIR_Opr tmp5 = LIR_OprFact::illegalOpr)
1761     : LIR_Op(code, result, NULL)
1762     , _fpu_stack_size(0)
1763     , _opr1(opr1)
1764     , _opr2(opr2)
1765     , _type(T_ILLEGAL)
1766     , _tmp1(tmp1)
1767     , _tmp2(tmp2)
1768     , _tmp3(tmp3)
1769     , _tmp4(tmp4)
1770     , _tmp5(tmp5)
1771     , _condition(lir_cond_unknown) {
1772     assert(code != lir_cmp &amp;&amp; is_in_range(code, begin_op2, end_op2), &quot;code check&quot;);
1773   }
1774 
1775   LIR_Opr in_opr1() const                        { return _opr1; }
1776   LIR_Opr in_opr2() const                        { return _opr2; }
1777   BasicType type()  const                        { return _type; }
1778   LIR_Opr tmp1_opr() const                       { return _tmp1; }
1779   LIR_Opr tmp2_opr() const                       { return _tmp2; }
1780   LIR_Opr tmp3_opr() const                       { return _tmp3; }
1781   LIR_Opr tmp4_opr() const                       { return _tmp4; }
1782   LIR_Opr tmp5_opr() const                       { return _tmp5; }
1783   LIR_Condition condition() const  {
1784     assert(code() == lir_cmp || code() == lir_cmove || code() == lir_assert, &quot;only valid for cmp and cmove and assert&quot;); return _condition;
1785   }
1786   void set_condition(LIR_Condition condition) {
1787     assert(code() == lir_cmp || code() == lir_cmove, &quot;only valid for cmp and cmove&quot;);  _condition = condition;
1788   }
1789 
1790   void set_fpu_stack_size(int size)              { _fpu_stack_size = size; }
1791   int  fpu_stack_size() const                    { return _fpu_stack_size; }
1792 
1793   void set_in_opr1(LIR_Opr opr)                  { _opr1 = opr; }
1794   void set_in_opr2(LIR_Opr opr)                  { _opr2 = opr; }
1795 
1796   virtual void emit_code(LIR_Assembler* masm);
1797   virtual LIR_Op2* as_Op2() { return this; }
1798   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
1799 };
1800 
1801 class LIR_OpAllocArray : public LIR_Op {
1802  friend class LIR_OpVisitState;
1803 
1804  private:
1805   LIR_Opr   _klass;
1806   LIR_Opr   _len;
1807   LIR_Opr   _tmp1;
1808   LIR_Opr   _tmp2;
1809   LIR_Opr   _tmp3;
1810   LIR_Opr   _tmp4;
1811   BasicType _type;
1812   CodeStub* _stub;
1813 
1814  public:
1815   LIR_OpAllocArray(LIR_Opr klass, LIR_Opr len, LIR_Opr result, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4, BasicType type, CodeStub* stub)
1816     : LIR_Op(lir_alloc_array, result, NULL)
1817     , _klass(klass)
1818     , _len(len)
1819     , _tmp1(t1)
1820     , _tmp2(t2)
1821     , _tmp3(t3)
1822     , _tmp4(t4)
1823     , _type(type)
1824     , _stub(stub) {}
1825 
1826   LIR_Opr   klass()   const                      { return _klass;       }
1827   LIR_Opr   len()     const                      { return _len;         }
1828   LIR_Opr   obj()     const                      { return result_opr(); }
1829   LIR_Opr   tmp1()    const                      { return _tmp1;        }
1830   LIR_Opr   tmp2()    const                      { return _tmp2;        }
1831   LIR_Opr   tmp3()    const                      { return _tmp3;        }
1832   LIR_Opr   tmp4()    const                      { return _tmp4;        }
1833   BasicType type()    const                      { return _type;        }
1834   CodeStub* stub()    const                      { return _stub;        }
1835 
1836   virtual void emit_code(LIR_Assembler* masm);
1837   virtual LIR_OpAllocArray * as_OpAllocArray () { return this; }
1838   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
1839 };
1840 
1841 
1842 class LIR_Op3: public LIR_Op {
1843  friend class LIR_OpVisitState;
1844 
1845  private:
1846   LIR_Opr _opr1;
1847   LIR_Opr _opr2;
1848   LIR_Opr _opr3;
1849  public:
1850   LIR_Op3(LIR_Code code, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr opr3, LIR_Opr result, CodeEmitInfo* info = NULL)
1851     : LIR_Op(code, result, info)
1852     , _opr1(opr1)
1853     , _opr2(opr2)
1854     , _opr3(opr3)                                { assert(is_in_range(code, begin_op3, end_op3), &quot;code check&quot;); }
1855   LIR_Opr in_opr1() const                        { return _opr1; }
1856   LIR_Opr in_opr2() const                        { return _opr2; }
1857   LIR_Opr in_opr3() const                        { return _opr3; }
1858 
1859   virtual void emit_code(LIR_Assembler* masm);
1860   virtual LIR_Op3* as_Op3() { return this; }
1861   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
1862 };
1863 
1864 
1865 //--------------------------------
1866 class LabelObj: public CompilationResourceObj {
1867  private:
1868   Label _label;
1869  public:
1870   LabelObj()                                     {}
1871   Label* label()                                 { return &amp;_label; }
1872 };
1873 
1874 
1875 class LIR_OpLock: public LIR_Op {
1876  friend class LIR_OpVisitState;
1877 
1878  private:
1879   LIR_Opr _hdr;
1880   LIR_Opr _obj;
1881   LIR_Opr _lock;
1882   LIR_Opr _scratch;
1883   CodeStub* _stub;
1884   CodeStub* _throw_imse_stub;
1885  public:
1886   LIR_OpLock(LIR_Code code, LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info, CodeStub* throw_imse_stub=NULL)
1887     : LIR_Op(code, LIR_OprFact::illegalOpr, info)
1888     , _hdr(hdr)
1889     , _obj(obj)
1890     , _lock(lock)
1891     , _scratch(scratch)
1892     , _stub(stub)
1893     , _throw_imse_stub(throw_imse_stub)                    {}
1894 
1895   LIR_Opr hdr_opr() const                        { return _hdr; }
1896   LIR_Opr obj_opr() const                        { return _obj; }
1897   LIR_Opr lock_opr() const                       { return _lock; }
1898   LIR_Opr scratch_opr() const                    { return _scratch; }
1899   CodeStub* stub() const                         { return _stub; }
1900   CodeStub* throw_imse_stub() const              { return _throw_imse_stub; }
1901 
1902   virtual void emit_code(LIR_Assembler* masm);
1903   virtual LIR_OpLock* as_OpLock() { return this; }
1904   void print_instr(outputStream* out) const PRODUCT_RETURN;
1905 };
1906 
1907 
1908 class LIR_OpDelay: public LIR_Op {
1909  friend class LIR_OpVisitState;
1910 
1911  private:
1912   LIR_Op* _op;
1913 
1914  public:
1915   LIR_OpDelay(LIR_Op* op, CodeEmitInfo* info):
1916     LIR_Op(lir_delay_slot, LIR_OprFact::illegalOpr, info),
1917     _op(op) {
1918     assert(op-&gt;code() == lir_nop || LIRFillDelaySlots, &quot;should be filling with nops&quot;);
1919   }
1920   virtual void emit_code(LIR_Assembler* masm);
1921   virtual LIR_OpDelay* as_OpDelay() { return this; }
1922   void print_instr(outputStream* out) const PRODUCT_RETURN;
1923   LIR_Op* delay_op() const { return _op; }
1924   CodeEmitInfo* call_info() const { return info(); }
1925 };
1926 
1927 #ifdef ASSERT
1928 // LIR_OpAssert
1929 class LIR_OpAssert : public LIR_Op2 {
1930  friend class LIR_OpVisitState;
1931 
1932  private:
1933   const char* _msg;
1934   bool        _halt;
1935 
1936  public:
1937   LIR_OpAssert(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, const char* msg, bool halt)
1938     : LIR_Op2(lir_assert, condition, opr1, opr2)
1939     , _msg(msg)
1940     , _halt(halt) {
1941   }
1942 
1943   const char* msg() const                        { return _msg; }
1944   bool        halt() const                       { return _halt; }
1945 
1946   virtual void emit_code(LIR_Assembler* masm);
1947   virtual LIR_OpAssert* as_OpAssert()            { return this; }
1948   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
1949 };
1950 #endif
1951 
1952 // LIR_OpCompareAndSwap
1953 class LIR_OpCompareAndSwap : public LIR_Op {
1954  friend class LIR_OpVisitState;
1955 
1956  private:
1957   LIR_Opr _addr;
1958   LIR_Opr _cmp_value;
1959   LIR_Opr _new_value;
1960   LIR_Opr _tmp1;
1961   LIR_Opr _tmp2;
1962 
1963  public:
1964   LIR_OpCompareAndSwap(LIR_Code code, LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1965                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result)
1966     : LIR_Op(code, result, NULL)  // no result, no info
1967     , _addr(addr)
1968     , _cmp_value(cmp_value)
1969     , _new_value(new_value)
1970     , _tmp1(t1)
1971     , _tmp2(t2)                                  { }
1972 
1973   LIR_Opr addr()        const                    { return _addr;  }
1974   LIR_Opr cmp_value()   const                    { return _cmp_value; }
1975   LIR_Opr new_value()   const                    { return _new_value; }
1976   LIR_Opr tmp1()        const                    { return _tmp1;      }
1977   LIR_Opr tmp2()        const                    { return _tmp2;      }
1978 
1979   virtual void emit_code(LIR_Assembler* masm);
1980   virtual LIR_OpCompareAndSwap * as_OpCompareAndSwap () { return this; }
1981   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
1982 };
1983 
1984 // LIR_OpProfileCall
1985 class LIR_OpProfileCall : public LIR_Op {
1986  friend class LIR_OpVisitState;
1987 
1988  private:
1989   ciMethod* _profiled_method;
1990   int       _profiled_bci;
1991   ciMethod* _profiled_callee;
1992   LIR_Opr   _mdo;
1993   LIR_Opr   _recv;
1994   LIR_Opr   _tmp1;
1995   ciKlass*  _known_holder;
1996 
1997  public:
1998   // Destroys recv
1999   LIR_OpProfileCall(ciMethod* profiled_method, int profiled_bci, ciMethod* profiled_callee, LIR_Opr mdo, LIR_Opr recv, LIR_Opr t1, ciKlass* known_holder)
2000     : LIR_Op(lir_profile_call, LIR_OprFact::illegalOpr, NULL)  // no result, no info
2001     , _profiled_method(profiled_method)
2002     , _profiled_bci(profiled_bci)
2003     , _profiled_callee(profiled_callee)
2004     , _mdo(mdo)
2005     , _recv(recv)
2006     , _tmp1(t1)
2007     , _known_holder(known_holder)                { }
2008 
2009   ciMethod* profiled_method() const              { return _profiled_method;  }
2010   int       profiled_bci()    const              { return _profiled_bci;     }
2011   ciMethod* profiled_callee() const              { return _profiled_callee;  }
2012   LIR_Opr   mdo()             const              { return _mdo;              }
2013   LIR_Opr   recv()            const              { return _recv;             }
2014   LIR_Opr   tmp1()            const              { return _tmp1;             }
2015   ciKlass*  known_holder()    const              { return _known_holder;     }
2016 
2017   virtual void emit_code(LIR_Assembler* masm);
2018   virtual LIR_OpProfileCall* as_OpProfileCall() { return this; }
2019   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
2020   bool should_profile_receiver_type() const {
2021     bool callee_is_static = _profiled_callee-&gt;is_loaded() &amp;&amp; _profiled_callee-&gt;is_static();
2022     Bytecodes::Code bc = _profiled_method-&gt;java_code_at_bci(_profiled_bci);
2023     bool call_is_virtual = (bc == Bytecodes::_invokevirtual &amp;&amp; !_profiled_callee-&gt;can_be_statically_bound()) || bc == Bytecodes::_invokeinterface;
2024     return C1ProfileVirtualCalls &amp;&amp; call_is_virtual &amp;&amp; !callee_is_static;
2025   }
2026 };
2027 
2028 // LIR_OpProfileType
2029 class LIR_OpProfileType : public LIR_Op {
2030  friend class LIR_OpVisitState;
2031 
2032  private:
2033   LIR_Opr      _mdp;
2034   LIR_Opr      _obj;
2035   LIR_Opr      _tmp;
2036   ciKlass*     _exact_klass;   // non NULL if we know the klass statically (no need to load it from _obj)
2037   intptr_t     _current_klass; // what the profiling currently reports
2038   bool         _not_null;      // true if we know statically that _obj cannot be null
2039   bool         _no_conflict;   // true if we&#39;re profling parameters, _exact_klass is not NULL and we know
2040                                // _exact_klass it the only possible type for this parameter in any context.
2041 
2042  public:
2043   // Destroys recv
2044   LIR_OpProfileType(LIR_Opr mdp, LIR_Opr obj, ciKlass* exact_klass, intptr_t current_klass, LIR_Opr tmp, bool not_null, bool no_conflict)
2045     : LIR_Op(lir_profile_type, LIR_OprFact::illegalOpr, NULL)  // no result, no info
2046     , _mdp(mdp)
2047     , _obj(obj)
2048     , _tmp(tmp)
2049     , _exact_klass(exact_klass)
2050     , _current_klass(current_klass)
2051     , _not_null(not_null)
2052     , _no_conflict(no_conflict) { }
2053 
2054   LIR_Opr      mdp()              const             { return _mdp;              }
2055   LIR_Opr      obj()              const             { return _obj;              }
2056   LIR_Opr      tmp()              const             { return _tmp;              }
2057   ciKlass*     exact_klass()      const             { return _exact_klass;      }
2058   intptr_t     current_klass()    const             { return _current_klass;    }
2059   bool         not_null()         const             { return _not_null;         }
2060   bool         no_conflict()      const             { return _no_conflict;      }
2061 
2062   virtual void emit_code(LIR_Assembler* masm);
2063   virtual LIR_OpProfileType* as_OpProfileType() { return this; }
2064   virtual void print_instr(outputStream* out) const PRODUCT_RETURN;
2065 };
2066 
2067 class LIR_InsertionBuffer;
2068 
2069 //--------------------------------LIR_List---------------------------------------------------
2070 // Maintains a list of LIR instructions (one instance of LIR_List per basic block)
2071 // The LIR instructions are appended by the LIR_List class itself;
2072 //
2073 // Notes:
2074 // - all offsets are(should be) in bytes
2075 // - local positions are specified with an offset, with offset 0 being local 0
2076 
2077 class LIR_List: public CompilationResourceObj {
2078  private:
2079   LIR_OpList  _operations;
2080 
2081   Compilation*  _compilation;
2082 #ifndef PRODUCT
2083   BlockBegin*   _block;
2084 #endif
2085 #ifdef ASSERT
2086   const char *  _file;
2087   int           _line;
2088 #endif
2089 
2090  public:
2091   void append(LIR_Op* op) {
2092     if (op-&gt;source() == NULL)
2093       op-&gt;set_source(_compilation-&gt;current_instruction());
2094 #ifndef PRODUCT
2095     if (PrintIRWithLIR) {
2096       _compilation-&gt;maybe_print_current_instruction();
2097       op-&gt;print(); tty-&gt;cr();
2098     }
2099 #endif // PRODUCT
2100 
2101     _operations.append(op);
2102 
2103 #ifdef ASSERT
2104     op-&gt;verify();
2105     op-&gt;set_file_and_line(_file, _line);
2106     _file = NULL;
2107     _line = 0;
2108 #endif
2109   }
2110 
2111   LIR_List(Compilation* compilation, BlockBegin* block = NULL);
2112 
2113 #ifdef ASSERT
2114   void set_file_and_line(const char * file, int line);
2115 #endif
2116 
2117   //---------- accessors ---------------
2118   LIR_OpList* instructions_list()                { return &amp;_operations; }
2119   int         length() const                     { return _operations.length(); }
2120   LIR_Op*     at(int i) const                    { return _operations.at(i); }
2121 
2122   NOT_PRODUCT(BlockBegin* block() const          { return _block; });
2123 
2124   // insert LIR_Ops in buffer to right places in LIR_List
2125   void append(LIR_InsertionBuffer* buffer);
2126 
2127   //---------- mutators ---------------
2128   void insert_before(int i, LIR_List* op_list)   { _operations.insert_before(i, op_list-&gt;instructions_list()); }
2129   void insert_before(int i, LIR_Op* op)          { _operations.insert_before(i, op); }
2130   void remove_at(int i)                          { _operations.remove_at(i); }
2131 
2132   //---------- printing -------------
2133   void print_instructions() PRODUCT_RETURN;
2134 
2135 
2136   //---------- instructions -------------
2137   void call_opt_virtual(ciMethod* method, LIR_Opr receiver, LIR_Opr result,
2138                         address dest, LIR_OprList* arguments,
2139                         CodeEmitInfo* info) {
2140     append(new LIR_OpJavaCall(lir_optvirtual_call, method, receiver, result, dest, arguments, info));
2141   }
2142   void call_static(ciMethod* method, LIR_Opr result,
2143                    address dest, LIR_OprList* arguments, CodeEmitInfo* info) {
2144     append(new LIR_OpJavaCall(lir_static_call, method, LIR_OprFact::illegalOpr, result, dest, arguments, info));
2145   }
2146   void call_icvirtual(ciMethod* method, LIR_Opr receiver, LIR_Opr result,
2147                       address dest, LIR_OprList* arguments, CodeEmitInfo* info) {
2148     append(new LIR_OpJavaCall(lir_icvirtual_call, method, receiver, result, dest, arguments, info));
2149   }
2150   void call_virtual(ciMethod* method, LIR_Opr receiver, LIR_Opr result,
2151                     intptr_t vtable_offset, LIR_OprList* arguments, CodeEmitInfo* info) {
2152     append(new LIR_OpJavaCall(lir_virtual_call, method, receiver, result, vtable_offset, arguments, info));
2153   }
2154   void call_dynamic(ciMethod* method, LIR_Opr receiver, LIR_Opr result,
2155                     address dest, LIR_OprList* arguments, CodeEmitInfo* info) {
2156     append(new LIR_OpJavaCall(lir_dynamic_call, method, receiver, result, dest, arguments, info));
2157   }
2158 
2159   void get_thread(LIR_Opr result)                { append(new LIR_Op0(lir_get_thread, result)); }
2160   void word_align()                              { append(new LIR_Op0(lir_word_align)); }
2161   void membar()                                  { append(new LIR_Op0(lir_membar)); }
2162   void membar_acquire()                          { append(new LIR_Op0(lir_membar_acquire)); }
2163   void membar_release()                          { append(new LIR_Op0(lir_membar_release)); }
2164   void membar_loadload()                         { append(new LIR_Op0(lir_membar_loadload)); }
2165   void membar_storestore()                       { append(new LIR_Op0(lir_membar_storestore)); }
2166   void membar_loadstore()                        { append(new LIR_Op0(lir_membar_loadstore)); }
2167   void membar_storeload()                        { append(new LIR_Op0(lir_membar_storeload)); }
2168 
2169   void nop()                                     { append(new LIR_Op0(lir_nop)); }
2170   void build_frame()                             { append(new LIR_Op0(lir_build_frame)); }
2171 
2172   void std_entry(LIR_Opr receiver)               { append(new LIR_Op0(lir_std_entry, receiver)); }
2173   void osr_entry(LIR_Opr osrPointer)             { append(new LIR_Op0(lir_osr_entry, osrPointer)); }
2174 
2175   void on_spin_wait()                            { append(new LIR_Op0(lir_on_spin_wait)); }
2176 
2177   void branch_destination(Label* lbl)            { append(new LIR_OpLabel(lbl)); }
2178 
2179   void leal(LIR_Opr from, LIR_Opr result_reg, LIR_PatchCode patch_code = lir_patch_none, CodeEmitInfo* info = NULL) { append(new LIR_Op1(lir_leal, from, result_reg, T_ILLEGAL, patch_code, info)); }
2180 
2181   // result is a stack location for old backend and vreg for UseLinearScan
2182   // stack_loc_temp is an illegal register for old backend
2183   void roundfp(LIR_Opr reg, LIR_Opr stack_loc_temp, LIR_Opr result) { append(new LIR_OpRoundFP(reg, stack_loc_temp, result)); }
2184   void unaligned_move(LIR_Address* src, LIR_Opr dst) { append(new LIR_Op1(lir_move, LIR_OprFact::address(src), dst, dst-&gt;type(), lir_patch_none, NULL, lir_move_unaligned)); }
2185   void unaligned_move(LIR_Opr src, LIR_Address* dst) { append(new LIR_Op1(lir_move, src, LIR_OprFact::address(dst), src-&gt;type(), lir_patch_none, NULL, lir_move_unaligned)); }
2186   void unaligned_move(LIR_Opr src, LIR_Opr dst) { append(new LIR_Op1(lir_move, src, dst, dst-&gt;type(), lir_patch_none, NULL, lir_move_unaligned)); }
2187   void move(LIR_Opr src, LIR_Opr dst, CodeEmitInfo* info = NULL) { append(new LIR_Op1(lir_move, src, dst, dst-&gt;type(), lir_patch_none, info)); }
2188   void move(LIR_Address* src, LIR_Opr dst, CodeEmitInfo* info = NULL) { append(new LIR_Op1(lir_move, LIR_OprFact::address(src), dst, src-&gt;type(), lir_patch_none, info)); }
2189   void move(LIR_Opr src, LIR_Address* dst, CodeEmitInfo* info = NULL) { append(new LIR_Op1(lir_move, src, LIR_OprFact::address(dst), dst-&gt;type(), lir_patch_none, info)); }
2190   void move_wide(LIR_Address* src, LIR_Opr dst, CodeEmitInfo* info = NULL) {
2191     if (UseCompressedOops) {
2192       append(new LIR_Op1(lir_move, LIR_OprFact::address(src), dst, src-&gt;type(), lir_patch_none, info, lir_move_wide));
2193     } else {
2194       move(src, dst, info);
2195     }
2196   }
2197   void move_wide(LIR_Opr src, LIR_Address* dst, CodeEmitInfo* info = NULL) {
2198     if (UseCompressedOops) {
2199       append(new LIR_Op1(lir_move, src, LIR_OprFact::address(dst), dst-&gt;type(), lir_patch_none, info, lir_move_wide));
2200     } else {
2201       move(src, dst, info);
2202     }
2203   }
2204   void volatile_move(LIR_Opr src, LIR_Opr dst, BasicType type, CodeEmitInfo* info = NULL, LIR_PatchCode patch_code = lir_patch_none) { append(new LIR_Op1(lir_move, src, dst, type, patch_code, info, lir_move_volatile)); }
2205 
2206   void oop2reg  (jobject o, LIR_Opr reg)         { assert(reg-&gt;type() == T_OBJECT, &quot;bad reg&quot;); append(new LIR_Op1(lir_move, LIR_OprFact::oopConst(o),    reg));   }
2207   void oop2reg_patch(jobject o, LIR_Opr reg, CodeEmitInfo* info);
2208 
2209   void metadata2reg  (Metadata* o, LIR_Opr reg)  { assert(reg-&gt;type() == T_METADATA, &quot;bad reg&quot;); append(new LIR_Op1(lir_move, LIR_OprFact::metadataConst(o), reg));   }
2210   void klass2reg_patch(Metadata* o, LIR_Opr reg, CodeEmitInfo* info);
2211 
2212   void return_op(LIR_Opr result)                 { append(new LIR_Op1(lir_return, result)); }
2213 
2214   void safepoint(LIR_Opr tmp, CodeEmitInfo* info)  { append(new LIR_Op1(lir_safepoint, tmp, info)); }
2215 
2216   void convert(Bytecodes::Code code, LIR_Opr left, LIR_Opr dst, ConversionStub* stub = NULL/*, bool is_32bit = false*/) { append(new LIR_OpConvert(code, left, dst, stub)); }
2217 
2218   void logical_and (LIR_Opr left, LIR_Opr right, LIR_Opr dst) { append(new LIR_Op2(lir_logic_and,  left, right, dst)); }
2219   void logical_or  (LIR_Opr left, LIR_Opr right, LIR_Opr dst) { append(new LIR_Op2(lir_logic_or,   left, right, dst)); }
2220   void logical_xor (LIR_Opr left, LIR_Opr right, LIR_Opr dst) { append(new LIR_Op2(lir_logic_xor,  left, right, dst)); }
2221 
2222   void   pack64(LIR_Opr src, LIR_Opr dst) { append(new LIR_Op1(lir_pack64,   src, dst, T_LONG, lir_patch_none, NULL)); }
2223   void unpack64(LIR_Opr src, LIR_Opr dst) { append(new LIR_Op1(lir_unpack64, src, dst, T_LONG, lir_patch_none, NULL)); }
2224 
2225   void null_check(LIR_Opr opr, CodeEmitInfo* info, bool deoptimize_on_null = false);
2226   void throw_exception(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
2227     append(new LIR_Op2(lir_throw, exceptionPC, exceptionOop, LIR_OprFact::illegalOpr, info));
2228   }
2229   void unwind_exception(LIR_Opr exceptionOop) {
2230     append(new LIR_Op1(lir_unwind, exceptionOop));
2231   }
2232 
2233   void push(LIR_Opr opr)                                   { append(new LIR_Op1(lir_push, opr)); }
2234   void pop(LIR_Opr reg)                                    { append(new LIR_Op1(lir_pop,  reg)); }
2235 
2236   void cmp(LIR_Condition condition, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info = NULL) {
2237     append(new LIR_Op2(lir_cmp, condition, left, right, info));
2238   }
2239   void cmp(LIR_Condition condition, LIR_Opr left, int right, CodeEmitInfo* info = NULL) {
2240     cmp(condition, left, LIR_OprFact::intConst(right), info);
2241   }
2242 
2243   void cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info);
2244   void cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Address* addr, CodeEmitInfo* info);
2245 
2246   void cmove(LIR_Condition condition, LIR_Opr src1, LIR_Opr src2, LIR_Opr dst, BasicType type) {
2247     append(new LIR_Op2(lir_cmove, condition, src1, src2, dst, type));
2248   }
2249 
2250   void cas_long(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
2251                 LIR_Opr t1, LIR_Opr t2, LIR_Opr result = LIR_OprFact::illegalOpr);
2252   void cas_obj(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
2253                LIR_Opr t1, LIR_Opr t2, LIR_Opr result = LIR_OprFact::illegalOpr);
2254   void cas_int(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
2255                LIR_Opr t1, LIR_Opr t2, LIR_Opr result = LIR_OprFact::illegalOpr);
2256 
2257   void abs (LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_abs , from, tmp, to)); }
2258   void negate(LIR_Opr from, LIR_Opr to, LIR_Opr tmp = LIR_OprFact::illegalOpr)              { append(new LIR_Op2(lir_neg, from, tmp, to)); }
2259   void sqrt(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_sqrt, from, tmp, to)); }
2260   void fmad(LIR_Opr from, LIR_Opr from1, LIR_Opr from2, LIR_Opr to) { append(new LIR_Op3(lir_fmad, from, from1, from2, to)); }
2261   void fmaf(LIR_Opr from, LIR_Opr from1, LIR_Opr from2, LIR_Opr to) { append(new LIR_Op3(lir_fmaf, from, from1, from2, to)); }
2262   void log10 (LIR_Opr from, LIR_Opr to, LIR_Opr tmp)              { append(new LIR_Op2(lir_log10, from, LIR_OprFact::illegalOpr, to, tmp)); }
2263   void tan (LIR_Opr from, LIR_Opr to, LIR_Opr tmp1, LIR_Opr tmp2) { append(new LIR_Op2(lir_tan , from, tmp1, to, tmp2)); }
2264 
2265   void add (LIR_Opr left, LIR_Opr right, LIR_Opr res)      { append(new LIR_Op2(lir_add, left, right, res)); }
2266   void sub (LIR_Opr left, LIR_Opr right, LIR_Opr res, CodeEmitInfo* info = NULL) { append(new LIR_Op2(lir_sub, left, right, res, info)); }
2267   void mul (LIR_Opr left, LIR_Opr right, LIR_Opr res) { append(new LIR_Op2(lir_mul, left, right, res)); }
2268   void mul_strictfp (LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_mul_strictfp, left, right, res, tmp)); }
2269   void div (LIR_Opr left, LIR_Opr right, LIR_Opr res, CodeEmitInfo* info = NULL)      { append(new LIR_Op2(lir_div, left, right, res, info)); }
2270   void div_strictfp (LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_div_strictfp, left, right, res, tmp)); }
2271   void rem (LIR_Opr left, LIR_Opr right, LIR_Opr res, CodeEmitInfo* info = NULL)      { append(new LIR_Op2(lir_rem, left, right, res, info)); }
2272 
2273   void volatile_load_mem_reg(LIR_Address* address, LIR_Opr dst, CodeEmitInfo* info, LIR_PatchCode patch_code = lir_patch_none);
2274   void volatile_load_unsafe_reg(LIR_Opr base, LIR_Opr offset, LIR_Opr dst, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code);
2275 
2276   void load(LIR_Address* addr, LIR_Opr src, CodeEmitInfo* info = NULL, LIR_PatchCode patch_code = lir_patch_none);
2277 
2278   void store_mem_int(jint v,    LIR_Opr base, int offset_in_bytes, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code = lir_patch_none);
2279   void store_mem_oop(jobject o, LIR_Opr base, int offset_in_bytes, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code = lir_patch_none);
2280   void store(LIR_Opr src, LIR_Address* addr, CodeEmitInfo* info = NULL, LIR_PatchCode patch_code = lir_patch_none);
2281   void volatile_store_mem_reg(LIR_Opr src, LIR_Address* address, CodeEmitInfo* info, LIR_PatchCode patch_code = lir_patch_none);
2282   void volatile_store_unsafe_reg(LIR_Opr src, LIR_Opr base, LIR_Opr offset, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code);
2283 
2284   void idiv(LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info);
2285   void idiv(LIR_Opr left, int   right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info);
2286   void irem(LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info);
2287   void irem(LIR_Opr left, int   right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info);
2288 
2289   void allocate_object(LIR_Opr dst, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4, int header_size, int object_size, LIR_Opr klass, bool init_check, CodeStub* stub);
2290   void allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub);
2291 
2292   // jump is an unconditional branch
2293   void jump(BlockBegin* block) {
2294     append(new LIR_OpBranch(lir_cond_always, T_ILLEGAL, block));
2295   }
2296   void jump(CodeStub* stub) {
2297     append(new LIR_OpBranch(lir_cond_always, T_ILLEGAL, stub));
2298   }
2299   void branch(LIR_Condition cond, BasicType type, Label* lbl)        { append(new LIR_OpBranch(cond, type, lbl)); }
2300   void branch(LIR_Condition cond, BasicType type, BlockBegin* block) {
2301     assert(type != T_FLOAT &amp;&amp; type != T_DOUBLE, &quot;no fp comparisons&quot;);
2302     append(new LIR_OpBranch(cond, type, block));
2303   }
2304   void branch(LIR_Condition cond, BasicType type, CodeStub* stub)    {
2305     assert(type != T_FLOAT &amp;&amp; type != T_DOUBLE, &quot;no fp comparisons&quot;);
2306     append(new LIR_OpBranch(cond, type, stub));
2307   }
2308   void branch(LIR_Condition cond, BasicType type, BlockBegin* block, BlockBegin* unordered) {
2309     assert(type == T_FLOAT || type == T_DOUBLE, &quot;fp comparisons only&quot;);
2310     append(new LIR_OpBranch(cond, type, block, unordered));
2311   }
2312 
2313   void shift_left(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp);
2314   void shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp);
2315   void unsigned_shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp);
2316 
2317   void shift_left(LIR_Opr value, int count, LIR_Opr dst)       { shift_left(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2318   void shift_right(LIR_Opr value, int count, LIR_Opr dst)      { shift_right(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2319   void unsigned_shift_right(LIR_Opr value, int count, LIR_Opr dst) { unsigned_shift_right(value, LIR_OprFact::intConst(count), dst, LIR_OprFact::illegalOpr); }
2320 
2321   void lcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst)        { append(new LIR_Op2(lir_cmp_l2i,  left, right, dst)); }
2322   void fcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst, bool is_unordered_less);
2323 
2324   void call_runtime_leaf(address routine, LIR_Opr tmp, LIR_Opr result, LIR_OprList* arguments) {
2325     append(new LIR_OpRTCall(routine, tmp, result, arguments));
2326   }
2327 
2328   void call_runtime(address routine, LIR_Opr tmp, LIR_Opr result,
2329                     LIR_OprList* arguments, CodeEmitInfo* info) {
2330     append(new LIR_OpRTCall(routine, tmp, result, arguments, info));
2331   }
2332 
2333   void load_stack_address_monitor(int monitor_ix, LIR_Opr dst)  { append(new LIR_Op1(lir_monaddr, LIR_OprFact::intConst(monitor_ix), dst)); }
2334   void unlock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub);
2335   void lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info, CodeStub* throw_imse_stub=NULL);
2336 
2337   void breakpoint()                                                  { append(new LIR_Op0(lir_breakpoint)); }
2338 
2339   void arraycopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length, LIR_Opr tmp, ciArrayKlass* expected_type, int flags, CodeEmitInfo* info) { append(new LIR_OpArrayCopy(src, src_pos, dst, dst_pos, length, tmp, expected_type, flags, info)); }
2340 
2341   void update_crc32(LIR_Opr crc, LIR_Opr val, LIR_Opr res)  { append(new LIR_OpUpdateCRC32(crc, val, res)); }
2342 
2343   void fpop_raw()                                { append(new LIR_Op0(lir_fpop_raw)); }
2344 
2345   void instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci);
2346   void store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci);
2347   void check_flattened_array(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub);
2348   void check_null_free_array(LIR_Opr array, LIR_Opr tmp);
2349   void substitutability_check(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,
2350                               LIR_Opr tmp1, LIR_Opr tmp2,
2351                               ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,
2352                               CodeEmitInfo* info, CodeStub* stub);
2353 
2354   void checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
2355                   LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
2356                   CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
2357                   ciMethod* profiled_method, int profiled_bci, bool is_never_null);
2358   // MethodData* profiling
2359   void profile_call(ciMethod* method, int bci, ciMethod* callee, LIR_Opr mdo, LIR_Opr recv, LIR_Opr t1, ciKlass* cha_klass) {
2360     append(new LIR_OpProfileCall(method, bci, callee, mdo, recv, t1, cha_klass));
2361   }
2362   void profile_type(LIR_Address* mdp, LIR_Opr obj, ciKlass* exact_klass, intptr_t current_klass, LIR_Opr tmp, bool not_null, bool no_conflict) {
2363     append(new LIR_OpProfileType(LIR_OprFact::address(mdp), obj, exact_klass, current_klass, tmp, not_null, no_conflict));
2364   }
2365 
2366   void xadd(LIR_Opr src, LIR_Opr add, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_xadd, src, add, res, tmp)); }
2367   void xchg(LIR_Opr src, LIR_Opr set, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_xchg, src, set, res, tmp)); }
2368 #ifdef ASSERT
2369   void lir_assert(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, const char* msg, bool halt) { append(new LIR_OpAssert(condition, opr1, opr2, msg, halt)); }
2370 #endif
2371 };
2372 
2373 void print_LIR(BlockList* blocks);
2374 
2375 class LIR_InsertionBuffer : public CompilationResourceObj {
2376  private:
2377   LIR_List*   _lir;   // the lir list where ops of this buffer should be inserted later (NULL when uninitialized)
2378 
2379   // list of insertion points. index and count are stored alternately:
2380   // _index_and_count[i * 2]:     the index into lir list where &quot;count&quot; ops should be inserted
2381   // _index_and_count[i * 2 + 1]: the number of ops to be inserted at index
2382   intStack    _index_and_count;
2383 
2384   // the LIR_Ops to be inserted
2385   LIR_OpList  _ops;
2386 
2387   void append_new(int index, int count)  { _index_and_count.append(index); _index_and_count.append(count); }
2388   void set_index_at(int i, int value)    { _index_and_count.at_put((i &lt;&lt; 1),     value); }
2389   void set_count_at(int i, int value)    { _index_and_count.at_put((i &lt;&lt; 1) + 1, value); }
2390 
2391 #ifdef ASSERT
2392   void verify();
2393 #endif
2394  public:
2395   LIR_InsertionBuffer() : _lir(NULL), _index_and_count(8), _ops(8) { }
2396 
2397   // must be called before using the insertion buffer
2398   void init(LIR_List* lir)  { assert(!initialized(), &quot;already initialized&quot;); _lir = lir; _index_and_count.clear(); _ops.clear(); }
2399   bool initialized() const  { return _lir != NULL; }
2400   // called automatically when the buffer is appended to the LIR_List
2401   void finish()             { _lir = NULL; }
2402 
2403   // accessors
2404   LIR_List*  lir_list() const             { return _lir; }
2405   int number_of_insertion_points() const  { return _index_and_count.length() &gt;&gt; 1; }
2406   int index_at(int i) const               { return _index_and_count.at((i &lt;&lt; 1));     }
2407   int count_at(int i) const               { return _index_and_count.at((i &lt;&lt; 1) + 1); }
2408 
2409   int number_of_ops() const               { return _ops.length(); }
2410   LIR_Op* op_at(int i) const              { return _ops.at(i); }
2411 
2412   // append an instruction to the buffer
2413   void append(int index, LIR_Op* op);
2414 
2415   // instruction
2416   void move(int index, LIR_Opr src, LIR_Opr dst, CodeEmitInfo* info = NULL) { append(index, new LIR_Op1(lir_move, src, dst, dst-&gt;type(), lir_patch_none, info)); }
2417 };
2418 
2419 
2420 //
2421 // LIR_OpVisitState is used for manipulating LIR_Ops in an abstract way.
2422 // Calling a LIR_Op&#39;s visit function with a LIR_OpVisitState causes
2423 // information about the input, output and temporaries used by the
2424 // op to be recorded.  It also records whether the op has call semantics
2425 // and also records all the CodeEmitInfos used by this op.
2426 //
2427 
2428 
2429 class LIR_OpVisitState: public StackObj {
2430  public:
2431   typedef enum { inputMode, firstMode = inputMode, tempMode, outputMode, numModes, invalidMode = -1 } OprMode;
2432 
2433   enum {
2434     maxNumberOfOperands = 20,
2435     maxNumberOfInfos = 4
2436   };
2437 
2438  private:
2439   LIR_Op*          _op;
2440 
2441   // optimization: the operands and infos are not stored in a variable-length
2442   //               list, but in a fixed-size array to save time of size checks and resizing
2443   int              _oprs_len[numModes];
2444   LIR_Opr*         _oprs_new[numModes][maxNumberOfOperands];
2445   int _info_len;
2446   CodeEmitInfo*    _info_new[maxNumberOfInfos];
2447 
2448   bool             _has_call;
2449   bool             _has_slow_case;
2450 
2451 
2452   // only include register operands
2453   // addresses are decomposed to the base and index registers
2454   // constants and stack operands are ignored
2455   void append(LIR_Opr&amp; opr, OprMode mode) {
2456     assert(opr-&gt;is_valid(), &quot;should not call this otherwise&quot;);
2457     assert(mode &gt;= 0 &amp;&amp; mode &lt; numModes, &quot;bad mode&quot;);
2458 
2459     if (opr-&gt;is_register()) {
2460        assert(_oprs_len[mode] &lt; maxNumberOfOperands, &quot;array overflow&quot;);
2461       _oprs_new[mode][_oprs_len[mode]++] = &amp;opr;
2462 
2463     } else if (opr-&gt;is_pointer()) {
2464       LIR_Address* address = opr-&gt;as_address_ptr();
2465       if (address != NULL) {
2466         // special handling for addresses: add base and index register of the address
2467         // both are always input operands or temp if we want to extend
2468         // their liveness!
2469         if (mode == outputMode) {
2470           mode = inputMode;
2471         }
2472         assert (mode == inputMode || mode == tempMode, &quot;input or temp only for addresses&quot;);
2473         if (address-&gt;_base-&gt;is_valid()) {
2474           assert(address-&gt;_base-&gt;is_register(), &quot;must be&quot;);
2475           assert(_oprs_len[mode] &lt; maxNumberOfOperands, &quot;array overflow&quot;);
2476           _oprs_new[mode][_oprs_len[mode]++] = &amp;address-&gt;_base;
2477         }
2478         if (address-&gt;_index-&gt;is_valid()) {
2479           assert(address-&gt;_index-&gt;is_register(), &quot;must be&quot;);
2480           assert(_oprs_len[mode] &lt; maxNumberOfOperands, &quot;array overflow&quot;);
2481           _oprs_new[mode][_oprs_len[mode]++] = &amp;address-&gt;_index;
2482         }
2483 
2484       } else {
2485         assert(opr-&gt;is_constant(), &quot;constant operands are not processed&quot;);
2486       }
2487     } else {
2488       assert(opr-&gt;is_stack(), &quot;stack operands are not processed&quot;);
2489     }
2490   }
2491 
2492   void append(CodeEmitInfo* info) {
2493     assert(info != NULL, &quot;should not call this otherwise&quot;);
2494     assert(_info_len &lt; maxNumberOfInfos, &quot;array overflow&quot;);
2495     _info_new[_info_len++] = info;
2496   }
2497 
2498  public:
2499   LIR_OpVisitState()         { reset(); }
2500 
2501   LIR_Op* op() const         { return _op; }
2502   void set_op(LIR_Op* op)    { reset(); _op = op; }
2503 
2504   bool has_call() const      { return _has_call; }
2505   bool has_slow_case() const { return _has_slow_case; }
2506 
2507   void reset() {
2508     _op = NULL;
2509     _has_call = false;
2510     _has_slow_case = false;
2511 
2512     _oprs_len[inputMode] = 0;
2513     _oprs_len[tempMode] = 0;
2514     _oprs_len[outputMode] = 0;
2515     _info_len = 0;
2516   }
2517 
2518 
2519   int opr_count(OprMode mode) const {
2520     assert(mode &gt;= 0 &amp;&amp; mode &lt; numModes, &quot;bad mode&quot;);
2521     return _oprs_len[mode];
2522   }
2523 
2524   LIR_Opr opr_at(OprMode mode, int index) const {
2525     assert(mode &gt;= 0 &amp;&amp; mode &lt; numModes, &quot;bad mode&quot;);
2526     assert(index &gt;= 0 &amp;&amp; index &lt; _oprs_len[mode], &quot;index out of bound&quot;);
2527     return *_oprs_new[mode][index];
2528   }
2529 
2530   void set_opr_at(OprMode mode, int index, LIR_Opr opr) const {
2531     assert(mode &gt;= 0 &amp;&amp; mode &lt; numModes, &quot;bad mode&quot;);
2532     assert(index &gt;= 0 &amp;&amp; index &lt; _oprs_len[mode], &quot;index out of bound&quot;);
2533     *_oprs_new[mode][index] = opr;
2534   }
2535 
2536   int info_count() const {
2537     return _info_len;
2538   }
2539 
2540   CodeEmitInfo* info_at(int index) const {
2541     assert(index &lt; _info_len, &quot;index out of bounds&quot;);
2542     return _info_new[index];
2543   }
2544 
2545   XHandlers* all_xhandler();
2546 
2547   // collects all register operands of the instruction
2548   void visit(LIR_Op* op);
2549 
2550 #ifdef ASSERT
2551   // check that an operation has no operands
2552   bool no_operands(LIR_Op* op);
2553 #endif
2554 
2555   // LIR_Op visitor functions use these to fill in the state
2556   void do_input(LIR_Opr&amp; opr)             { append(opr, LIR_OpVisitState::inputMode); }
2557   void do_output(LIR_Opr&amp; opr)            { append(opr, LIR_OpVisitState::outputMode); }
2558   void do_temp(LIR_Opr&amp; opr)              { append(opr, LIR_OpVisitState::tempMode); }
2559   void do_info(CodeEmitInfo* info)        { append(info); }
2560 
2561   void do_stub(CodeStub* stub);
2562   void do_call()                          { _has_call = true; }
2563   void do_slow_case()                     { _has_slow_case = true; }
2564   void do_slow_case(CodeEmitInfo* info) {
2565     _has_slow_case = true;
2566     append(info);
2567   }
2568 };
2569 
2570 
2571 inline LIR_Opr LIR_OprDesc::illegalOpr()   { return LIR_OprFact::illegalOpr; };
2572 
2573 #endif // SHARE_C1_C1_LIR_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LIR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_FrameMap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIR.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 451 void LIR_OpVisitState::visit(LIR_Op* op) {
 452   // copy information from the LIR_Op
 453   reset();
 454   set_op(op);
 455 
 456   switch (op-&gt;code()) {
 457 
 458 // LIR_Op0
 459     case lir_word_align:               // result and info always invalid
 460     case lir_backwardbranch_target:    // result and info always invalid
 461     case lir_build_frame:              // result and info always invalid
 462     case lir_fpop_raw:                 // result and info always invalid
 463     case lir_breakpoint:               // result and info always invalid
 464     case lir_membar:                   // result and info always invalid
 465     case lir_membar_acquire:           // result and info always invalid
 466     case lir_membar_release:           // result and info always invalid
 467     case lir_membar_loadload:          // result and info always invalid
 468     case lir_membar_storestore:        // result and info always invalid
 469     case lir_membar_loadstore:         // result and info always invalid
 470     case lir_membar_storeload:         // result and info always invalid

 471     case lir_on_spin_wait:
 472     {
 473       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 474       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 475       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 476       break;
 477     }
 478 
 479     case lir_nop:                      // may have info, result always invalid
 480     case lir_std_entry:                // may have result, info always invalid
 481     case lir_osr_entry:                // may have result, info always invalid
 482     case lir_get_thread:               // may have result, info always invalid
 483     {
 484       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 485       if (op-&gt;_info != NULL)           do_info(op-&gt;_info);
 486       if (op-&gt;_result-&gt;is_valid())     do_output(op-&gt;_result);
 487       break;
 488     }
 489 
 490 
</pre>
<hr />
<pre>
1800   switch(code()) {
1801      // LIR_Op0
1802      case lir_membar:                s = &quot;membar&quot;;        break;
1803      case lir_membar_acquire:        s = &quot;membar_acquire&quot;; break;
1804      case lir_membar_release:        s = &quot;membar_release&quot;; break;
1805      case lir_membar_loadload:       s = &quot;membar_loadload&quot;;   break;
1806      case lir_membar_storestore:     s = &quot;membar_storestore&quot;; break;
1807      case lir_membar_loadstore:      s = &quot;membar_loadstore&quot;;  break;
1808      case lir_membar_storeload:      s = &quot;membar_storeload&quot;;  break;
1809      case lir_word_align:            s = &quot;word_align&quot;;    break;
1810      case lir_label:                 s = &quot;label&quot;;         break;
1811      case lir_nop:                   s = &quot;nop&quot;;           break;
1812      case lir_on_spin_wait:          s = &quot;on_spin_wait&quot;;  break;
1813      case lir_backwardbranch_target: s = &quot;backbranch&quot;;    break;
1814      case lir_std_entry:             s = &quot;std_entry&quot;;     break;
1815      case lir_osr_entry:             s = &quot;osr_entry&quot;;     break;
1816      case lir_build_frame:           s = &quot;build_frm&quot;;     break;
1817      case lir_fpop_raw:              s = &quot;fpop_raw&quot;;      break;
1818      case lir_breakpoint:            s = &quot;breakpoint&quot;;    break;
1819      case lir_get_thread:            s = &quot;get_thread&quot;;    break;

1820      // LIR_Op1
1821      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1822      case lir_fld:                   s = &quot;fld&quot;;           break;
1823      case lir_push:                  s = &quot;push&quot;;          break;
1824      case lir_pop:                   s = &quot;pop&quot;;           break;
1825      case lir_null_check:            s = &quot;null_check&quot;;    break;
1826      case lir_return:                s = &quot;return&quot;;        break;
1827      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1828      case lir_leal:                  s = &quot;leal&quot;;          break;
1829      case lir_branch:                s = &quot;branch&quot;;        break;
1830      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1831      case lir_move:                  s = &quot;move&quot;;          break;
1832      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1833      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1834      case lir_throw:                 s = &quot;throw&quot;;         break;
1835      case lir_unwind:                s = &quot;unwind&quot;;        break;
1836      case lir_convert:               s = &quot;convert&quot;;       break;
1837      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1838      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;
1839      case lir_pack64:                s = &quot;pack64&quot;;        break;
</pre>
</td>
<td>
<hr />
<pre>
 451 void LIR_OpVisitState::visit(LIR_Op* op) {
 452   // copy information from the LIR_Op
 453   reset();
 454   set_op(op);
 455 
 456   switch (op-&gt;code()) {
 457 
 458 // LIR_Op0
 459     case lir_word_align:               // result and info always invalid
 460     case lir_backwardbranch_target:    // result and info always invalid
 461     case lir_build_frame:              // result and info always invalid
 462     case lir_fpop_raw:                 // result and info always invalid
 463     case lir_breakpoint:               // result and info always invalid
 464     case lir_membar:                   // result and info always invalid
 465     case lir_membar_acquire:           // result and info always invalid
 466     case lir_membar_release:           // result and info always invalid
 467     case lir_membar_loadload:          // result and info always invalid
 468     case lir_membar_storestore:        // result and info always invalid
 469     case lir_membar_loadstore:         // result and info always invalid
 470     case lir_membar_storeload:         // result and info always invalid
<span class="line-added"> 471     case lir_check_orig_pc:            // result and info always invalid</span>
 472     case lir_on_spin_wait:
 473     {
 474       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 475       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 476       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 477       break;
 478     }
 479 
 480     case lir_nop:                      // may have info, result always invalid
 481     case lir_std_entry:                // may have result, info always invalid
 482     case lir_osr_entry:                // may have result, info always invalid
 483     case lir_get_thread:               // may have result, info always invalid
 484     {
 485       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 486       if (op-&gt;_info != NULL)           do_info(op-&gt;_info);
 487       if (op-&gt;_result-&gt;is_valid())     do_output(op-&gt;_result);
 488       break;
 489     }
 490 
 491 
</pre>
<hr />
<pre>
1801   switch(code()) {
1802      // LIR_Op0
1803      case lir_membar:                s = &quot;membar&quot;;        break;
1804      case lir_membar_acquire:        s = &quot;membar_acquire&quot;; break;
1805      case lir_membar_release:        s = &quot;membar_release&quot;; break;
1806      case lir_membar_loadload:       s = &quot;membar_loadload&quot;;   break;
1807      case lir_membar_storestore:     s = &quot;membar_storestore&quot;; break;
1808      case lir_membar_loadstore:      s = &quot;membar_loadstore&quot;;  break;
1809      case lir_membar_storeload:      s = &quot;membar_storeload&quot;;  break;
1810      case lir_word_align:            s = &quot;word_align&quot;;    break;
1811      case lir_label:                 s = &quot;label&quot;;         break;
1812      case lir_nop:                   s = &quot;nop&quot;;           break;
1813      case lir_on_spin_wait:          s = &quot;on_spin_wait&quot;;  break;
1814      case lir_backwardbranch_target: s = &quot;backbranch&quot;;    break;
1815      case lir_std_entry:             s = &quot;std_entry&quot;;     break;
1816      case lir_osr_entry:             s = &quot;osr_entry&quot;;     break;
1817      case lir_build_frame:           s = &quot;build_frm&quot;;     break;
1818      case lir_fpop_raw:              s = &quot;fpop_raw&quot;;      break;
1819      case lir_breakpoint:            s = &quot;breakpoint&quot;;    break;
1820      case lir_get_thread:            s = &quot;get_thread&quot;;    break;
<span class="line-added">1821      case lir_check_orig_pc:         s = &quot;check_orig_pc&quot;; break;</span>
1822      // LIR_Op1
1823      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1824      case lir_fld:                   s = &quot;fld&quot;;           break;
1825      case lir_push:                  s = &quot;push&quot;;          break;
1826      case lir_pop:                   s = &quot;pop&quot;;           break;
1827      case lir_null_check:            s = &quot;null_check&quot;;    break;
1828      case lir_return:                s = &quot;return&quot;;        break;
1829      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1830      case lir_leal:                  s = &quot;leal&quot;;          break;
1831      case lir_branch:                s = &quot;branch&quot;;        break;
1832      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1833      case lir_move:                  s = &quot;move&quot;;          break;
1834      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1835      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1836      case lir_throw:                 s = &quot;throw&quot;;         break;
1837      case lir_unwind:                s = &quot;unwind&quot;;        break;
1838      case lir_convert:               s = &quot;convert&quot;;       break;
1839      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1840      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;
1841      case lir_pack64:                s = &quot;pack64&quot;;        break;
</pre>
</td>
</tr>
</table>
<center><a href="c1_FrameMap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
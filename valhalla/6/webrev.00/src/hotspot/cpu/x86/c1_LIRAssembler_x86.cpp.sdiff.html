<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="c1_MacroAssembler_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 266   return as_Address(addr);
 267 }
 268 
 269 
 270 void LIR_Assembler::osr_entry() {
 271   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 272   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 273   ValueStack* entry_state = osr_entry-&gt;state();
 274   int number_of_locks = entry_state-&gt;locks_size();
 275 
 276   // we jump here if osr happens with the interpreter
 277   // state set up to continue at the beginning of the
 278   // loop that triggered osr - in particular, we have
 279   // the following registers setup:
 280   //
 281   // rcx: osr buffer
 282   //
 283 
 284   // build frame
 285   ciMethod* m = compilation()-&gt;method();
<span class="line-modified"> 286   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes(),</span>
<span class="line-removed"> 287                  needs_stack_repair(), NULL);</span>
 288 
 289   // OSR buffer is
 290   //
 291   // locals[nlocals-1..0]
 292   // monitors[0..number_of_locks]
 293   //
 294   // locals is a direct copy of the interpreter frame so in the osr buffer
 295   // so first slot in the local array is the last local from the interpreter
 296   // and last slot is local[0] (receiver) from the interpreter
 297   //
 298   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 299   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 300   // in the interpreter frame (the method lock if a sync method)
 301 
 302   // Initialize monitors in the compiled activation.
 303   //   rcx: pointer to osr buffer
 304   //
 305   // All other registers are dead at this point and the locals will be
 306   // copied into place by code emitted in the IR.
 307 
</pre>
<hr />
<pre>
4252 }
4253 
4254 void LIR_Assembler::membar_storeload() {
4255   __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
4256 }
4257 
4258 void LIR_Assembler::on_spin_wait() {
4259   __ pause ();
4260 }
4261 
4262 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
4263   assert(result_reg-&gt;is_register(), &quot;check&quot;);
4264 #ifdef _LP64
4265   // __ get_thread(result_reg-&gt;as_register_lo());
4266   __ mov(result_reg-&gt;as_register(), r15_thread);
4267 #else
4268   __ get_thread(result_reg-&gt;as_register());
4269 #endif // _LP64
4270 }
4271 



4272 
4273 void LIR_Assembler::peephole(LIR_List*) {
4274   // do nothing for now
4275 }
4276 
4277 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
4278   assert(data == dest, &quot;xchg/xadd uses only 2 operands&quot;);
4279 
4280   if (data-&gt;type() == T_INT) {
4281     if (code == lir_xadd) {
4282       __ lock();
4283       __ xaddl(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register());
4284     } else {
4285       __ xchgl(data-&gt;as_register(), as_Address(src-&gt;as_address_ptr()));
4286     }
4287   } else if (data-&gt;is_oop()) {
4288     assert (code == lir_xchg, &quot;xadd for oops&quot;);
4289     Register obj = data-&gt;as_register();
4290 #ifdef _LP64
4291     if (UseCompressedOops) {
</pre>
</td>
<td>
<hr />
<pre>
 266   return as_Address(addr);
 267 }
 268 
 269 
 270 void LIR_Assembler::osr_entry() {
 271   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 272   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 273   ValueStack* entry_state = osr_entry-&gt;state();
 274   int number_of_locks = entry_state-&gt;locks_size();
 275 
 276   // we jump here if osr happens with the interpreter
 277   // state set up to continue at the beginning of the
 278   // loop that triggered osr - in particular, we have
 279   // the following registers setup:
 280   //
 281   // rcx: osr buffer
 282   //
 283 
 284   // build frame
 285   ciMethod* m = compilation()-&gt;method();
<span class="line-modified"> 286   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());</span>

 287 
 288   // OSR buffer is
 289   //
 290   // locals[nlocals-1..0]
 291   // monitors[0..number_of_locks]
 292   //
 293   // locals is a direct copy of the interpreter frame so in the osr buffer
 294   // so first slot in the local array is the last local from the interpreter
 295   // and last slot is local[0] (receiver) from the interpreter
 296   //
 297   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 298   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 299   // in the interpreter frame (the method lock if a sync method)
 300 
 301   // Initialize monitors in the compiled activation.
 302   //   rcx: pointer to osr buffer
 303   //
 304   // All other registers are dead at this point and the locals will be
 305   // copied into place by code emitted in the IR.
 306 
</pre>
<hr />
<pre>
4251 }
4252 
4253 void LIR_Assembler::membar_storeload() {
4254   __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
4255 }
4256 
4257 void LIR_Assembler::on_spin_wait() {
4258   __ pause ();
4259 }
4260 
4261 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
4262   assert(result_reg-&gt;is_register(), &quot;check&quot;);
4263 #ifdef _LP64
4264   // __ get_thread(result_reg-&gt;as_register_lo());
4265   __ mov(result_reg-&gt;as_register(), r15_thread);
4266 #else
4267   __ get_thread(result_reg-&gt;as_register());
4268 #endif // _LP64
4269 }
4270 
<span class="line-added">4271 void LIR_Assembler::check_orig_pc() {</span>
<span class="line-added">4272   __ cmpptr(frame_map()-&gt;address_for_orig_pc_addr(), (int32_t)NULL_WORD);</span>
<span class="line-added">4273 }</span>
4274 
4275 void LIR_Assembler::peephole(LIR_List*) {
4276   // do nothing for now
4277 }
4278 
4279 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
4280   assert(data == dest, &quot;xchg/xadd uses only 2 operands&quot;);
4281 
4282   if (data-&gt;type() == T_INT) {
4283     if (code == lir_xadd) {
4284       __ lock();
4285       __ xaddl(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register());
4286     } else {
4287       __ xchgl(data-&gt;as_register(), as_Address(src-&gt;as_address_ptr()));
4288     }
4289   } else if (data-&gt;is_oop()) {
4290     assert (code == lir_xchg, &quot;xadd for oops&quot;);
4291     Register obj = data-&gt;as_register();
4292 #ifdef _LP64
4293     if (UseCompressedOops) {
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="c1_MacroAssembler_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/frame_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_MacroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/c1/c1_FrameMap.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/frame_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
455   sender_sp = repair_sender_sp(sender_sp, saved_fp_addr);
456 
457   // On Intel the return_address is always the word on the stack
458   address sender_pc = (address) *(sender_sp-1);
459 
460 #ifdef ASSERT
461   if (sender_pc != sender_pc_copy) {
462     // When extending the stack in the callee method entry to make room for unpacking of value
463     // type args, we keep a copy of the sender pc at the expected location in the callee frame.
464     // If the sender pc is patched due to deoptimization, the copy is not consistent anymore.
465     nmethod* nm = CodeCache::find_blob(sender_pc)-&gt;as_nmethod();
466     assert(sender_pc == nm-&gt;deopt_mh_handler_begin() || sender_pc == nm-&gt;deopt_handler_begin(), &quot;unexpected sender pc&quot;);
467   }
468 #endif
469 
470   if (map-&gt;update_map()) {
471     // Tell GC to use argument oopmaps for some runtime stubs that need it.
472     // For C1, the runtime stub might not have oop maps, so set this flag
473     // outside of update_register_map.
474     bool caller_args = _cb-&gt;caller_must_gc_arguments(map-&gt;thread());

475     if (!caller_args) {
476       nmethod* nm = _cb-&gt;as_nmethod_or_null();
<span class="line-modified">477       if (nm != NULL &amp;&amp; nm-&gt;is_compiled_by_c1() &amp;&amp;</span>
<span class="line-removed">478           nm-&gt;method()-&gt;has_scalarized_args() &amp;&amp;</span>
479           pc() &lt; nm-&gt;verified_value_entry_point()) {
480         // The VEP and VVEP(RO) of C1-compiled methods call buffer_value_args_xxx
481         // before doing any argument shuffling, so we need to scan the oops
482         // as the caller passes them.


483         NativeCall* call = nativeCall_before(pc());
484         address dest = call-&gt;destination();
<span class="line-modified">485         if (dest == Runtime1::entry_for(Runtime1::buffer_value_args_no_receiver_id) ||</span>
<span class="line-modified">486             dest == Runtime1::entry_for(Runtime1::buffer_value_args_id)) {</span>
<span class="line-modified">487           caller_args = true;</span>
<span class="line-removed">488         }</span>
489       }
490     }

491     map-&gt;set_include_argument_oops(caller_args);
492     if (_cb-&gt;oop_maps() != NULL) {
493       OopMapSet::update_register_map(this, map);
494     }
495 
496     // Since the prolog does the save and restore of EBP there is no oopmap
497     // for it so we must fill in its location as if there was an oopmap entry
498     // since if our caller was compiled code there could be live jvm state in it.
499     update_map_with_saved_link(map, saved_fp_addr);
500   }
501 
502   assert(sender_sp != sp(), &quot;must have changed&quot;);
503   return frame(sender_sp, sender_sp, *saved_fp_addr, sender_pc);
504 }
505 
506 
507 //------------------------------------------------------------------------------
508 // frame::sender
509 frame frame::sender(RegisterMap* map) const {
510   // Default is we don&#39;t have to follow them. The sender_for_xxx will
</pre>
</td>
<td>
<hr />
<pre>
455   sender_sp = repair_sender_sp(sender_sp, saved_fp_addr);
456 
457   // On Intel the return_address is always the word on the stack
458   address sender_pc = (address) *(sender_sp-1);
459 
460 #ifdef ASSERT
461   if (sender_pc != sender_pc_copy) {
462     // When extending the stack in the callee method entry to make room for unpacking of value
463     // type args, we keep a copy of the sender pc at the expected location in the callee frame.
464     // If the sender pc is patched due to deoptimization, the copy is not consistent anymore.
465     nmethod* nm = CodeCache::find_blob(sender_pc)-&gt;as_nmethod();
466     assert(sender_pc == nm-&gt;deopt_mh_handler_begin() || sender_pc == nm-&gt;deopt_handler_begin(), &quot;unexpected sender pc&quot;);
467   }
468 #endif
469 
470   if (map-&gt;update_map()) {
471     // Tell GC to use argument oopmaps for some runtime stubs that need it.
472     // For C1, the runtime stub might not have oop maps, so set this flag
473     // outside of update_register_map.
474     bool caller_args = _cb-&gt;caller_must_gc_arguments(map-&gt;thread());
<span class="line-added">475 #ifdef COMPILER1</span>
476     if (!caller_args) {
477       nmethod* nm = _cb-&gt;as_nmethod_or_null();
<span class="line-modified">478       if (nm != NULL &amp;&amp; nm-&gt;is_compiled_by_c1() &amp;&amp; nm-&gt;method()-&gt;has_scalarized_args() &amp;&amp;</span>

479           pc() &lt; nm-&gt;verified_value_entry_point()) {
480         // The VEP and VVEP(RO) of C1-compiled methods call buffer_value_args_xxx
481         // before doing any argument shuffling, so we need to scan the oops
482         // as the caller passes them.
<span class="line-added">483         caller_args = true;</span>
<span class="line-added">484 #ifdef ASSERT</span>
485         NativeCall* call = nativeCall_before(pc());
486         address dest = call-&gt;destination();
<span class="line-modified">487         assert(dest == Runtime1::entry_for(Runtime1::buffer_value_args_no_receiver_id) ||</span>
<span class="line-modified">488                dest == Runtime1::entry_for(Runtime1::buffer_value_args_id), &quot;unexpected safepoint in entry point&quot;);</span>
<span class="line-modified">489 #endif</span>

490       }
491     }
<span class="line-added">492 #endif</span>
493     map-&gt;set_include_argument_oops(caller_args);
494     if (_cb-&gt;oop_maps() != NULL) {
495       OopMapSet::update_register_map(this, map);
496     }
497 
498     // Since the prolog does the save and restore of EBP there is no oopmap
499     // for it so we must fill in its location as if there was an oopmap entry
500     // since if our caller was compiled code there could be live jvm state in it.
501     update_map_with_saved_link(map, saved_fp_addr);
502   }
503 
504   assert(sender_sp != sp(), &quot;must have changed&quot;);
505   return frame(sender_sp, sender_sp, *saved_fp_addr, sender_pc);
506 }
507 
508 
509 //------------------------------------------------------------------------------
510 // frame::sender
511 frame frame::sender(RegisterMap* map) const {
512   // Default is we don&#39;t have to follow them. The sender_for_xxx will
</pre>
</td>
</tr>
</table>
<center><a href="c1_MacroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/c1/c1_FrameMap.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java
@@ -2251,10 +2251,19 @@
                 //when 292 issue is fixed we should remove this and change the backend
                 //code to always generate a method handle to an accessible method
                 return tree.ownerAccessible;
             }
 
+            /* Per our interim inline class translation scheme, the reference projection classes
+               are completely empty, so we want the methods in the value class to be invoked instead.
+               As the lambda meta factory isn't clued into this, it will try to invoke the method in
+               C$ref.class and fail with a NoSuchMethodError. we need to workaround it ourselves.
+            */
+            boolean receiverIsReferenceProjection() {
+                return tree.sym.kind == MTH && tree.sym.owner.isReferenceProjection();
+            }
+
             /**
              * The VM does not support access across nested classes (8010319).
              * Were that ever to change, this should be removed.
              */
             boolean isPrivateInOtherClass() {
@@ -2305,10 +2314,11 @@
                         needsVarArgsConversion() ||
                         isArrayOp() ||
                         isPrivateInOtherClass() ||
                         isProtectedInSuperClassOfEnclosingClassInOtherPackage() ||
                         !receiverAccessible() ||
+                        receiverIsReferenceProjection() ||
                         (tree.getMode() == ReferenceMode.NEW &&
                           tree.kind != ReferenceKind.ARRAY_CTOR &&
                           (tree.sym.owner.isLocal() || tree.sym.owner.isInner() || tree.sym.owner.isValue()));
             }
 
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/TransValues.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/TransValues.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/TransValues.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/TransValues.java
@@ -339,11 +339,11 @@
                     case MTH:
                     case VAR:
                         fieldAccess.selected =
                                 make.TypeCast(types.erasure(selectedType.valueProjection().type), fieldAccess.selected);
                         if (sym.owner.isReferenceProjection()) // is an empty class file.
-                            sym = sym.valueProjection();
+                            TreeInfo.setSymbol(fieldAccess, sym.valueProjection());
                         break;
                     case TYP:
                         fieldAccess.selected = make.Type(types.erasure(selectedType.valueProjection().type));
                         break;
                 }
diff a/test/jdk/valhalla/valuetypes/StreamTest.java b/test/jdk/valhalla/valuetypes/StreamTest.java
--- a/test/jdk/valhalla/valuetypes/StreamTest.java
+++ b/test/jdk/valhalla/valuetypes/StreamTest.java
@@ -52,16 +52,16 @@
     }
 
     @Test
     public void testInlineType() {
         Arrays.stream(values)
-                .map(Value::point)
+                .map(Value.ref::point)
                 .filter(p -> p.x >= 5)
                 .forEach(System.out::println);
 
         Arrays.stream(values)
-                .map(Value::nullablePoint)
+                .map(Value.ref::nullablePoint)
                 .filter(p -> p != null)
                 .forEach(System.out::println);
     }
 
     static inline class Value {
diff a/test/langtools/tools/javac/valhalla/lworld-values/StreamsTest.java b/test/langtools/tools/javac/valhalla/lworld-values/StreamsTest.java
--- /dev/null
+++ b/test/langtools/tools/javac/valhalla/lworld-values/StreamsTest.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8244982
+ * @summary Javac has trouble compiling method references
+ * @run main StreamsTest
+ */
+
+import java.util.Arrays;
+
+public class StreamsTest {
+
+    public static inline class X {
+
+        String data;
+
+        X(String data) {
+            this.data = data;
+        }
+
+        String data() { return data; }
+
+        static String accumulate = "";
+
+        static void accumulate(String s) {
+            accumulate += s;
+        }
+
+        static String streamedData() {
+
+            X [] xs = new X[] {
+                                 new X("Streams "),
+                                 new X("test "),
+                                 new X("passed OK!")
+                      };
+
+            Arrays.stream(xs)
+                        .map(X.ref::data)
+                        .filter(p -> p != null)
+                        .forEach(X::accumulate);
+
+            return accumulate;
+        }
+    }
+
+    public static void main(String [] args) {
+        if (!X.streamedData().equals("Streams test passed OK!"))
+            throw new AssertionError("Unexpected data in stream");
+    }
+}

diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/TransValues.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/TransValues.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/TransValues.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/TransValues.java
@@ -61,10 +61,11 @@
 import java.util.HashMap;
 import java.util.Map;
 
 import static com.sun.tools.javac.code.Flags.STATIC;
 import static com.sun.tools.javac.code.Kinds.Kind.MTH;
+import static com.sun.tools.javac.code.Kinds.Kind.TYP;
 import static com.sun.tools.javac.code.Kinds.Kind.VAR;
 import static com.sun.tools.javac.tree.JCTree.Tag.APPLY;
 import static com.sun.tools.javac.tree.JCTree.Tag.EXEC;
 import static com.sun.tools.javac.tree.JCTree.Tag.IDENT;
 
@@ -327,23 +328,31 @@
                     result = make.Select(facHandle, symbol);
                     return;
                 }
             }
         }
-        // Rewrite any accesses of the form V.ref.member to ((V) V.ref).member
+        /* Rewrite any accesses of the form V.ref.member to ((V) V.ref).member OR
+           if a static member is being selected via a V.ref as a TYP, rewrite
+           V.ref.member to V.member
+        */
         fieldAccess.selected = translate(fieldAccess.selected);
         if (fieldAccess.name != names._class && fieldAccess.name != names._default) {  // TODO: this and super ??
             Symbol sym = TreeInfo.symbol(fieldAccess);
+            Symbol sitesym = TreeInfo.symbol(fieldAccess.selected);
             TypeSymbol selectedType = fieldAccess.selected.type.tsym;
             if (selectedType.isReferenceProjection()) {
                 switch (sym.kind) {
                     case MTH:
                     case VAR:
-                        fieldAccess.selected =
-                                make.TypeCast(types.erasure(selectedType.valueProjection().type), fieldAccess.selected);
-                        if (sym.owner.isReferenceProjection()) // is an empty class file.
-                            TreeInfo.setSymbol(fieldAccess, sym.valueProjection());
+                        if (sym.isStatic() && sitesym != null && sitesym.kind == TYP) {
+                            fieldAccess.selected = make.Type(types.erasure(selectedType.valueProjection().type));
+                        } else {
+                            fieldAccess.selected =
+                                    make.TypeCast(types.erasure(selectedType.valueProjection().type), fieldAccess.selected);
+                            if (sym.owner.isReferenceProjection()) // is an empty class file.
+                                TreeInfo.setSymbol(fieldAccess, sym.valueProjection());
+                        }
                         break;
                     case TYP:
                         fieldAccess.selected = make.Type(types.erasure(selectedType.valueProjection().type));
                         break;
                 }
diff a/test/langtools/tools/javac/valhalla/lworld-values/StaticSelectedThroughProjection.java b/test/langtools/tools/javac/valhalla/lworld-values/StaticSelectedThroughProjection.java
--- /dev/null
+++ b/test/langtools/tools/javac/valhalla/lworld-values/StaticSelectedThroughProjection.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8247567
+ * @summary Javac chokes on static member selection via the reference projection.
+ * @run main StaticSelectedThroughProjection
+ */
+
+public class StaticSelectedThroughProjection {
+    static inline class MyValue {
+        int x = 42;
+        static String test() {
+            return "OK";
+        };
+    }
+    public static void main(String[] args) {
+        if (!MyValue.ref.test().equals("OK"))
+            throw new AssertionError("Broken");
+    }
+}

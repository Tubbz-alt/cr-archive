diff a/src/hotspot/share/c1/c1_Runtime1.cpp b/src/hotspot/share/c1/c1_Runtime1.cpp
--- a/src/hotspot/share/c1/c1_Runtime1.cpp
+++ b/src/hotspot/share/c1/c1_Runtime1.cpp
@@ -1092,11 +1092,11 @@
         break;
       case Bytecodes::_anewarray:
         { Bytecode_anewarray anew(caller_method(), caller_method->bcp_from(bci));
           Klass* ek = caller_method->constants()->klass_at(anew.index(), CHECK);
           if (ek->is_value() && caller_method->constants()->klass_at_noresolve(anew.index())->is_Q_signature()) {
-            k = ek->array_klass(ArrayStorageProperties::flattened_and_null_free, 1, CHECK);
+            k = ek->array_klass(1, CHECK);
             assert(ArrayKlass::cast(k)->storage_properties().is_null_free(), "Expect a null-free array class here");
           } else {
             k = ek->array_klass(CHECK);
           }
         }
diff a/src/hotspot/share/ci/ciObjArrayKlass.cpp b/src/hotspot/share/ci/ciObjArrayKlass.cpp
--- a/src/hotspot/share/ci/ciObjArrayKlass.cpp
+++ b/src/hotspot/share/ci/ciObjArrayKlass.cpp
@@ -136,14 +136,12 @@
 // Implementation of make.
 ciObjArrayKlass* ciObjArrayKlass::make_impl(ciKlass* element_klass, bool never_null) {
   if (element_klass->is_loaded()) {
     EXCEPTION_CONTEXT;
     // The element klass is loaded
-    ArrayStorageProperties props = never_null ? ArrayStorageProperties::flattened_and_null_free : ArrayStorageProperties::empty;
-    Klass* array = element_klass->get_Klass()->array_klass(props, THREAD);
+    Klass* array = element_klass->get_Klass()->array_klass(THREAD);
     if (element_klass->is_valuetype()) {
-      assert(!ObjArrayKlass::cast(array)->storage_properties().is_flattened(), "should not be flattened");
       assert(ObjArrayKlass::cast(array)->storage_properties().is_null_free() == never_null, "wrong nullability storage property");
     }
     if (HAS_PENDING_EXCEPTION) {
       CLEAR_PENDING_EXCEPTION;
       CURRENT_THREAD_ENV->record_out_of_memory_failure();
diff a/src/hotspot/share/ci/ciValueArrayKlass.cpp b/src/hotspot/share/ci/ciValueArrayKlass.cpp
--- a/src/hotspot/share/ci/ciValueArrayKlass.cpp
+++ b/src/hotspot/share/ci/ciValueArrayKlass.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -131,12 +131,11 @@
   assert(element_klass->is_valuetype(), "element type must be value type");
   assert(element_klass->is_loaded(), "unloaded Q klasses are represented by ciInstanceKlass");
   {
     EXCEPTION_CONTEXT;
     // The element klass is loaded
-    Klass* array = element_klass->get_Klass()->array_klass(ArrayStorageProperties::flattened_and_null_free, 1, THREAD);
-    assert(ValueArrayKlass::cast(array)->storage_properties().is_flattened(), "should be flattened");
+    Klass* array = element_klass->get_Klass()->array_klass(1, THREAD);
     assert(ValueArrayKlass::cast(array)->storage_properties().is_null_free(), "should be null free");
     if (HAS_PENDING_EXCEPTION) {
       CLEAR_PENDING_EXCEPTION;
       CURRENT_THREAD_ENV->record_out_of_memory_failure();
       // TODO handle this
diff a/src/hotspot/share/classfile/systemDictionary.cpp b/src/hotspot/share/classfile/systemDictionary.cpp
--- a/src/hotspot/share/classfile/systemDictionary.cpp
+++ b/src/hotspot/share/classfile/systemDictionary.cpp
@@ -287,15 +287,15 @@
     k = SystemDictionary::resolve_instance_class_or_null(obj_class,
                                                          class_loader,
                                                          protection_domain,
                                                          CHECK_NULL);
     if (k != NULL) {
-      k = k->array_klass(ArrayStorageProperties::for_signature(class_name), ndims, CHECK_NULL);
+      k = k->array_klass(ndims, CHECK_NULL);
     }
   } else {
     k = Universe::typeArrayKlassObj(t);
-    k = TypeArrayKlass::cast(k)->array_klass(ArrayStorageProperties::empty, ndims, CHECK_NULL);
+    k = TypeArrayKlass::cast(k)->array_klass(ndims, CHECK_NULL);
   }
   return k;
 }
 
 // Must be called for any super-class or super-interface resolution
@@ -1017,11 +1017,11 @@
       k = Universe::typeArrayKlassObj(t);
     } else {
       k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);
     }
     if (k != NULL) {
-      k = k->array_klass_or_null(ArrayStorageProperties::for_signature(class_name), ndims);
+      k = k->array_klass_or_null(ndims);
     }
   } else {
     k = find(class_name, class_loader, protection_domain, THREAD);
   }
   return k;
@@ -2281,11 +2281,11 @@
       MutexLocker mu(THREAD, SystemDictionary_lock);
       klass = constraints()->find_constrained_klass(ss.as_symbol(), class_loader);
     }
     // If element class already loaded, allocate array klass
     if (klass != NULL) {
-      klass = klass->array_klass_or_null(ArrayStorageProperties::for_signature(class_name), ndims);
+      klass = klass->array_klass_or_null(ndims);
     }
   } else {
     MutexLocker mu(THREAD, SystemDictionary_lock);
     // Non-array classes are easy: simply check the constraint table.
     klass = constraints()->find_constrained_klass(class_name, class_loader);
diff a/src/hotspot/share/memory/oopFactory.cpp b/src/hotspot/share/memory/oopFactory.cpp
--- a/src/hotspot/share/memory/oopFactory.cpp
+++ b/src/hotspot/share/memory/oopFactory.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -134,11 +134,11 @@
 }
 
 arrayOop oopFactory::new_valueArray(Klass* klass, int length, TRAPS) {
   assert(klass->is_value(), "Klass must be value type");
   // Request flattened, but we might not actually get it...either way "null-free" are the aaload/aastore semantics
-  Klass* array_klass = klass->array_klass(ArrayStorageProperties::flattened_and_null_free, 1, CHECK_NULL);
+  Klass* array_klass = klass->array_klass(1, CHECK_NULL);
   assert(ArrayKlass::cast(array_klass)->storage_properties().is_null_free(), "Expect a null-free array class here");
 
   arrayOop oop;
   if (array_klass->is_valueArray_klass()) {
     oop = (arrayOop) ValueArrayKlass::cast(array_klass)->allocate(length, THREAD);
@@ -150,11 +150,11 @@
 }
 
 objArrayHandle oopFactory::copy_valueArray_to_objArray(valueArrayHandle array, TRAPS) {
   int len = array->length();
   ValueArrayKlass* vak = ValueArrayKlass::cast(array->klass());
-  objArrayHandle oarray = new_objArray_handle(vak->element_klass(),
+  objArrayHandle oarray = new_objArray_handle(vak->element_klass()->super(),
                                               array->length(), CHECK_(objArrayHandle()));
   vak->copy_array(array(), 0, oarray(), 0, len, CHECK_(objArrayHandle()));
   return oarray;
 }
 
diff a/src/hotspot/share/memory/oopFactory.hpp b/src/hotspot/share/memory/oopFactory.hpp
--- a/src/hotspot/share/memory/oopFactory.hpp
+++ b/src/hotspot/share/memory/oopFactory.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -58,14 +58,14 @@
   static objArrayOop     new_objArray(Klass* klass, int length, TRAPS);
 
   // Value arrays...
   // LWorld:
   //    - Q-type signature allocation should use this path.
-  //    - L-type signature allocation should use new_objArray (even with value type elements)
+  //    - L-type signature allocation should use new_objArray
   //
-  // Method specifically creates ArrayStorageProperties::null_free and possibly flattened if possible
-  // i.e. valueArrayOop if flattening can be done, else objArrayOop with "null free" storage properties
+  // Method specifically null free and possibly flattened if possible
+  // i.e. valueArrayOop if flattening can be done, else "null free" objArrayOop
   static arrayOop        new_valueArray(Klass* klass, int length, TRAPS);
 
   // Helper conversions from value to obj array...
   static objArrayHandle  copy_valueArray_to_objArray(valueArrayHandle array, TRAPS);
   static objArrayHandle  ensure_objArray(oop array, TRAPS); // copy into new objArray if not already an objArray
diff a/src/hotspot/share/oops/arrayKlass.cpp b/src/hotspot/share/oops/arrayKlass.cpp
--- a/src/hotspot/share/oops/arrayKlass.cpp
+++ b/src/hotspot/share/oops/arrayKlass.cpp
@@ -97,12 +97,13 @@
     set_layout_helper(Klass::_lh_neutral_value);
     set_is_cloneable(); // All arrays are considered to be cloneable (See JLS 20.1.5)
     JFR_ONLY(INIT_ID(this);)
 }
 
-Symbol* ArrayKlass::create_element_klass_array_name(bool is_qtype, Klass* element_klass, TRAPS) {
+Symbol* ArrayKlass::create_element_klass_array_name(Klass* element_klass, TRAPS) {
   Symbol* name = NULL;
+  bool is_qtype = element_klass->is_value();
   if (!element_klass->is_instance_klass() || is_qtype ||
       (name = InstanceKlass::cast(element_klass)->array_name()) == NULL) {
 
     ResourceMark rm(THREAD);
     char *name_str = element_klass->name()->as_C_string();
@@ -121,14 +122,14 @@
     idx += len;
     if (element_klass->is_instance_klass()) {
       new_str[idx++] = JVM_SIGNATURE_ENDCLASS;
     }
     new_str[idx++] = '\0';
-    name = SymbolTable::new_permanent_symbol(new_str);
-    if (element_klass->is_instance_klass() && (!is_qtype)) {
+    name = SymbolTable::new_symbol(new_str);
+    if (element_klass->is_instance_klass()) {
       InstanceKlass* ik = InstanceKlass::cast(element_klass);
-      ik->set_array_name(name); // CMH: only cache and deref array_name for L-type...missing for Q-type
+      ik->set_array_name(name);
     }
   }
 
   return name;
 }
@@ -159,11 +160,11 @@
 }
 
 objArrayOop ArrayKlass::allocate_arrayArray(int n, int length, TRAPS) {
   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_ARRAY), CHECK_NULL);
   int size = objArrayOopDesc::object_size(length);
-  Klass* k = array_klass(ArrayStorageProperties::for_signature(name()), n+dimension(), CHECK_NULL);
+  Klass* k = array_klass(n+dimension(), CHECK_NULL);
   ArrayKlass* ak = ArrayKlass::cast(k);
   objArrayOop o = (objArrayOop)Universe::heap()->array_allocate(ak, size, length,
                                                                 /* do_zero */ true, CHECK_NULL);
   // initialization to NULL not necessary, area already cleared
   return o;
diff a/src/hotspot/share/oops/arrayKlass.hpp b/src/hotspot/share/oops/arrayKlass.hpp
--- a/src/hotspot/share/oops/arrayKlass.hpp
+++ b/src/hotspot/share/oops/arrayKlass.hpp
@@ -24,10 +24,11 @@
 
 #ifndef SHARE_OOPS_ARRAYKLASS_HPP
 #define SHARE_OOPS_ARRAYKLASS_HPP
 
 #include "oops/klass.hpp"
+#include "oops/arrayStorageProperties.hpp"
 
 class fieldDescriptor;
 class klassVtable;
 
 // ArrayKlass is the abstract baseclass for all array classes
@@ -53,12 +54,12 @@
   // The constructor with the Symbol argument does the real array
   // initialization, the other is a dummy
   ArrayKlass(Symbol* name, KlassID id);
   ArrayKlass() { assert(DumpSharedSpaces || UseSharedSpaces, "only for cds"); }
 
-  // Create array_name for element klass, creates a permanent symbol, returns result
-  static Symbol* create_element_klass_array_name(bool is_qtype, Klass* element_klass, TRAPS);
+  // Create array_name for element klass
+  static Symbol* create_element_klass_array_name(Klass* element_klass, TRAPS);
 
  public:
   // Instance variables
   virtual Klass* element_klass() const      { return _element_klass; }
   virtual void set_element_klass(Klass* k)  { _element_klass = k; }
diff a/src/hotspot/share/oops/arrayStorageProperties.hpp b/src/hotspot/share/oops/arrayStorageProperties.hpp
--- a/src/hotspot/share/oops/arrayStorageProperties.hpp
+++ b/src/hotspot/share/oops/arrayStorageProperties.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
diff a/src/hotspot/share/oops/instanceKlass.cpp b/src/hotspot/share/oops/instanceKlass.cpp
--- a/src/hotspot/share/oops/instanceKlass.cpp
+++ b/src/hotspot/share/oops/instanceKlass.cpp
@@ -1447,12 +1447,11 @@
     THROW_MSG(throwError ? vmSymbols::java_lang_IllegalAccessError()
               : vmSymbols::java_lang_IllegalAccessException(), external_name());
   }
 }
 
-Klass* InstanceKlass::array_klass_impl(ArrayStorageProperties storage_props, bool or_null, int n, TRAPS) {
-  assert(storage_props.is_empty(), "Unexpected");
+Klass* InstanceKlass::array_klass_impl(bool or_null, int n, TRAPS) {
   // Need load-acquire for lock-free read
   if (array_klasses_acquire() == NULL) {
     if (or_null) return NULL;
 
     ResourceMark rm(THREAD);
@@ -1461,26 +1460,26 @@
       // Atomic creation of array_klasses
       MutexLocker ma(THREAD, MultiArray_lock);
 
       // Check if update has already taken place
       if (array_klasses() == NULL) {
-        Klass*    k = ObjArrayKlass::allocate_objArray_klass(storage_props, 1, this, CHECK_NULL);
+        Klass*    k = ObjArrayKlass::allocate_objArray_klass(1, this, CHECK_NULL);
         // use 'release' to pair with lock-free load
         release_set_array_klasses(k);
       }
     }
   }
   // _this will always be set at this point
   ObjArrayKlass* oak = (ObjArrayKlass*)array_klasses();
   if (or_null) {
-    return oak->array_klass_or_null(storage_props, n);
+    return oak->array_klass_or_null(n);
   }
-  return oak->array_klass(storage_props, n, THREAD);
+  return oak->array_klass(n, THREAD);
 }
 
-Klass* InstanceKlass::array_klass_impl(ArrayStorageProperties storage_props, bool or_null, TRAPS) {
-  return array_klass_impl(storage_props, or_null, 1, THREAD);
+Klass* InstanceKlass::array_klass_impl(bool or_null, TRAPS) {
+  return array_klass_impl(or_null, 1, THREAD);
 }
 
 static int call_class_initializer_counter = 0;   // for debugging
 
 Method* InstanceKlass::class_initializer() const {
diff a/src/hotspot/share/oops/instanceKlass.hpp b/src/hotspot/share/oops/instanceKlass.hpp
--- a/src/hotspot/share/oops/instanceKlass.hpp
+++ b/src/hotspot/share/oops/instanceKlass.hpp
@@ -1452,14 +1452,14 @@
   void eager_initialize_impl                     ();
   /* jni_id_for_impl for jfieldID only */
   JNIid* jni_id_for_impl                         (int offset);
 protected:
   // Returns the array class for the n'th dimension
-  virtual Klass* array_klass_impl(ArrayStorageProperties storage_props, bool or_null, int n, TRAPS);
+  virtual Klass* array_klass_impl(bool or_null, int n, TRAPS);
 
   // Returns the array class with this class as element type
-  virtual Klass* array_klass_impl(ArrayStorageProperties storage_props, bool or_null, TRAPS);
+  virtual Klass* array_klass_impl(bool or_null, TRAPS);
 
 private:
 
   // find a local method (returns NULL if not found)
   Method* find_method_impl(const Symbol* name,
diff a/src/hotspot/share/oops/klass.cpp b/src/hotspot/share/oops/klass.cpp
--- a/src/hotspot/share/oops/klass.cpp
+++ b/src/hotspot/share/oops/klass.cpp
@@ -629,33 +629,33 @@
   assert(DumpSharedSpaces, "called only during runtime");
   _archived_mirror = CompressedOops::encode(m);
 }
 #endif // INCLUDE_CDS_JAVA_HEAP
 
-Klass* Klass::array_klass_or_null(ArrayStorageProperties storage_props, int rank) {
+Klass* Klass::array_klass_or_null(int rank) {
   EXCEPTION_MARK;
   // No exception can be thrown by array_klass_impl when called with or_null == true.
   // (In anycase, the execption mark will fail if it do so)
-  return array_klass_impl(storage_props, true, rank, THREAD);
+  return array_klass_impl(true, rank, THREAD);
 }
 
 
-Klass* Klass::array_klass_or_null(ArrayStorageProperties storage_props) {
+Klass* Klass::array_klass_or_null() {
   EXCEPTION_MARK;
   // No exception can be thrown by array_klass_impl when called with or_null == true.
   // (In anycase, the execption mark will fail if it do so)
-  return array_klass_impl(storage_props, true, THREAD);
+  return array_klass_impl(true, THREAD);
 }
 
 
-Klass* Klass::array_klass_impl(ArrayStorageProperties storage_props, bool or_null, int rank, TRAPS) {
+Klass* Klass::array_klass_impl(bool or_null, int rank, TRAPS) {
   fatal("array_klass should be dispatched to InstanceKlass, ObjArrayKlass or TypeArrayKlass");
   return NULL;
 }
 
 
-Klass* Klass::array_klass_impl(ArrayStorageProperties storage_props, bool or_null, TRAPS) {
+Klass* Klass::array_klass_impl(bool or_null, TRAPS) {
   fatal("array_klass should be dispatched to InstanceKlass, ObjArrayKlass or TypeArrayKlass");
   return NULL;
 }
 
 void Klass::check_array_allocation_length(int length, int max_length, TRAPS) {
@@ -741,20 +741,10 @@
      // print header
      obj->mark().print_on(st);
      st->cr();
      st->print(BULLET"prototype_header: " INTPTR_FORMAT, _prototype_header.value());
      st->cr();
-     ArrayStorageProperties props = obj->array_storage_properties();
-     if (props.value() != 0) {
-       st->print(" - array storage properties: ");
-       if (props.is_flattened()) {
-         st->print(" flat");
-       }
-       if (props.is_null_free()) {
-         st->print(" non nullable");
-       }
-     }
   }
 
   // print class
   st->print(BULLET"klass: ");
   obj->klass()->print_value_on(st);
diff a/src/hotspot/share/oops/klass.hpp b/src/hotspot/share/oops/klass.hpp
--- a/src/hotspot/share/oops/klass.hpp
+++ b/src/hotspot/share/oops/klass.hpp
@@ -26,11 +26,10 @@
 #define SHARE_OOPS_KLASS_HPP
 
 #include "classfile/classLoaderData.hpp"
 #include "memory/iterator.hpp"
 #include "memory/memRegion.hpp"
-#include "oops/arrayStorageProperties.hpp"
 #include "oops/markWord.hpp"
 #include "oops/metadata.hpp"
 #include "oops/oop.hpp"
 #include "oops/oopHandle.hpp"
 #include "utilities/accessFlags.hpp"
@@ -478,31 +477,19 @@
   Method* lookup_method(const Symbol* name, const Symbol* signature) const {
     return uncached_lookup_method(name, signature, find_overpass);
   }
 
   // array class with specific rank
-  Klass* array_klass(int rank, TRAPS) {
-    return array_klass_impl(ArrayStorageProperties::empty, false, rank, THREAD);
-  }
-
-  Klass* array_klass(ArrayStorageProperties storage_props, int rank, TRAPS) {
-    return array_klass_impl(storage_props, false, rank, THREAD);
-  }
+  Klass* array_klass(int rank, TRAPS)         {  return array_klass_impl(false, rank, THREAD); }
 
   // array class with this klass as element type
-  Klass* array_klass(TRAPS) {
-    return array_klass_impl(ArrayStorageProperties::empty, false, THREAD);
-  }
-
-  Klass* array_klass(ArrayStorageProperties storage_props, TRAPS) {
-    return array_klass_impl(storage_props, false, THREAD);
-  }
+   Klass* array_klass(TRAPS)                   {  return array_klass_impl(false, THREAD); }
 
   // These will return NULL instead of allocating on the heap:
   // NB: these can block for a mutex, like other functions with TRAPS arg.
-  Klass* array_klass_or_null(ArrayStorageProperties storage_props, int rank);
-  Klass* array_klass_or_null(ArrayStorageProperties storage_props);
+  Klass* array_klass_or_null(int rank);
+  Klass* array_klass_or_null();
 
   virtual oop protection_domain() const = 0;
 
   oop class_loader() const;
 
@@ -511,12 +498,12 @@
   // be used safely.  All uses of klass_holder need to apply the appropriate barriers,
   // except during GC.
   oop klass_holder() const { return class_loader_data()->holder_phantom(); }
 
  protected:
-  virtual Klass* array_klass_impl(ArrayStorageProperties storage_props, bool or_null, int rank, TRAPS);
-  virtual Klass* array_klass_impl(ArrayStorageProperties storage_props, bool or_null, TRAPS);
+  virtual Klass* array_klass_impl(bool or_null, int rank, TRAPS);
+  virtual Klass* array_klass_impl(bool or_null, TRAPS);
 
   // Error handling when length > max_length or length < 0
   static void check_array_allocation_length(int length, int max_length, TRAPS);
 
   void set_vtable_length(int len) { _vtable_len= len; }
diff a/src/hotspot/share/oops/objArrayKlass.cpp b/src/hotspot/share/oops/objArrayKlass.cpp
--- a/src/hotspot/share/oops/objArrayKlass.cpp
+++ b/src/hotspot/share/oops/objArrayKlass.cpp
@@ -53,36 +53,25 @@
   int size = ArrayKlass::static_size(ObjArrayKlass::header_size());
 
   return new (loader_data, size, THREAD) ObjArrayKlass(n, k, name);
 }
 
-Klass* ObjArrayKlass::allocate_objArray_klass(ArrayStorageProperties storage_props,
-                                              int n, Klass* element_klass, TRAPS) {
+Klass* ObjArrayKlass::allocate_objArray_klass(int n, Klass* element_klass, TRAPS) {
   // Eagerly allocate the direct array supertype.
   Klass* super_klass = NULL;
-  if (storage_props.is_null_free()) {
-    assert(!Universe::is_bootstrapping(), "Need bootstrap");
-    // Arrange null ok as direct super
-    super_klass = element_klass->array_klass_or_null(ArrayStorageProperties::empty, n);
-    if (super_klass == NULL) { // allocate super...need to drop the lock
-      MutexUnlocker mu(MultiArray_lock);
-      element_klass->array_klass(ArrayStorageProperties::empty, n, CHECK_NULL);
-      // retry, start from the beginning since lock dropped...
-      return element_klass->array_klass(storage_props, n, CHECK_NULL);
-    }
-  } else if (!Universe::is_bootstrapping() || SystemDictionary::Object_klass_loaded()) {
+  if (!Universe::is_bootstrapping() || SystemDictionary::Object_klass_loaded()) {
     Klass* element_super = element_klass->super();
     if (element_super != NULL) {
       // The element type has a direct super.  E.g., String[] has direct super of Object[].
-      super_klass = element_super->array_klass_or_null(ArrayStorageProperties::empty);
+      super_klass = element_super->array_klass_or_null();
       bool supers_exist = super_klass != NULL;
       // Also, see if the element has secondary supertypes.
       // We need an array type for each.
       const Array<Klass*>* element_supers = element_klass->secondary_supers();
       for( int i = element_supers->length()-1; i >= 0; i-- ) {
         Klass* elem_super = element_supers->at(i);
-        if (elem_super->array_klass_or_null(ArrayStorageProperties::empty) == NULL) {
+        if (elem_super->array_klass_or_null() == NULL) {
           supers_exist = false;
           break;
         }
       }
       if (!supers_exist) {
@@ -94,22 +83,22 @@
           for( int i = element_supers->length()-1; i >= 0; i-- ) {
             Klass* elem_super = element_supers->at(i);
             elem_super->array_klass(CHECK_NULL);
           }
           // Now retry from the beginning
-          ek = element_klass->array_klass(storage_props, n, CHECK_NULL);
+          ek = element_klass->array_klass(n, CHECK_NULL);
         }  // re-lock
         return ek;
       }
     } else {
       // The element type is already Object.  Object[] has direct super of Object.
       super_klass = SystemDictionary::Object_klass();
     }
   }
 
   // Create type name for klass.
-  Symbol* name = ArrayKlass::create_element_klass_array_name(storage_props.is_null_free(), element_klass, CHECK_NULL);
+  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, CHECK_NULL);
 
   // Initialize instance variables
   ClassLoaderData* loader_data = element_klass->class_loader_data();
   ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, CHECK_NULL);
 
@@ -332,12 +321,11 @@
     do_copy(s, src_offset, d, dst_offset, length, CHECK);
   }
 }
 
 
-Klass* ObjArrayKlass::array_klass_impl(ArrayStorageProperties storage_props, bool or_null, int n, TRAPS) {
-  assert(!storage_props.is_flattened() || n > 1, "Cannot flatten");
+Klass* ObjArrayKlass::array_klass_impl(bool or_null, int n, TRAPS) {
   assert(dimension() <= n, "check order of chain");
   int dim = dimension();
   if (dim == n) return this;
 
   // lock-free read needs acquire semantics
@@ -351,11 +339,11 @@
 
       // Check if another thread beat us
       if (higher_dimension() == NULL) {
 
         // Create multi-dim klass object and link them together
-        Klass* k = ObjArrayKlass::allocate_objArray_klass(storage_props, dim + 1, this, CHECK_NULL);
+        Klass* k = ObjArrayKlass::allocate_objArray_klass(dim + 1, this, CHECK_NULL);
         ObjArrayKlass* ak = ObjArrayKlass::cast(k);
         ak->set_lower_dimension(this);
         // use 'release' to pair with lock-free load
         release_set_higher_dimension(ak);
         assert(ak->is_objArray_klass(), "incorrect initialization of ObjArrayKlass");
@@ -363,18 +351,18 @@
     }
   }
 
   ObjArrayKlass *ak = ObjArrayKlass::cast(higher_dimension());
   if (or_null) {
-    return ak->array_klass_or_null(storage_props, n);
+    return ak->array_klass_or_null(n);
   }
   THREAD->check_possible_safepoint();
-  return ak->array_klass(storage_props, n, THREAD);
+  return ak->array_klass(n, THREAD);
 }
 
-Klass* ObjArrayKlass::array_klass_impl(ArrayStorageProperties storage_props, bool or_null, TRAPS) {
-  return array_klass_impl(storage_props, or_null, dimension() +  1, THREAD);
+Klass* ObjArrayKlass::array_klass_impl(bool or_null, TRAPS) {
+  return array_klass_impl(or_null, dimension() +  1, THREAD);
 }
 
 bool ObjArrayKlass::can_be_primary_super_slow() const {
   if (!bottom_klass()->can_be_primary_super())
     // array of interfaces
@@ -398,11 +386,11 @@
     GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(num_elem_supers+2);
     secondaries->push(SystemDictionary::Cloneable_klass());
     secondaries->push(SystemDictionary::Serializable_klass());
     for (int i = 0; i < num_elem_supers; i++) {
       Klass* elem_super = elem_supers->at(i);
-      Klass* array_super = elem_super->array_klass_or_null(ArrayStorageProperties::empty);
+      Klass* array_super = elem_super->array_klass_or_null();
       assert(array_super != NULL, "must already have been created");
       secondaries->push(array_super);
     }
     return secondaries;
   }
diff a/src/hotspot/share/oops/objArrayKlass.hpp b/src/hotspot/share/oops/objArrayKlass.hpp
--- a/src/hotspot/share/oops/objArrayKlass.hpp
+++ b/src/hotspot/share/oops/objArrayKlass.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -67,12 +67,11 @@
                                                   Array<InstanceKlass*>* transitive_interfaces);
   DEBUG_ONLY(bool is_objArray_klass_slow()  const  { return true; })
   int oop_size(oop obj) const;
 
   // Allocation
-  static Klass* allocate_objArray_klass(ArrayStorageProperties storage_props,
-                                          int n, Klass* element_klass, TRAPS);
+  static Klass* allocate_objArray_klass(int n, Klass* element_klass, TRAPS);
 
   objArrayOop allocate(int length, TRAPS);
   oop multi_allocate(int rank, jint* sizes, TRAPS);
 
   // Copying
@@ -89,14 +88,14 @@
   void do_copy(arrayOop s, size_t src_offset,
                arrayOop d, size_t dst_offset,
                int length, TRAPS);
  protected:
   // Returns the ObjArrayKlass for n'th dimension.
-  virtual Klass* array_klass_impl(ArrayStorageProperties storage_props, bool or_null, int n, TRAPS);
+  virtual Klass* array_klass_impl(bool or_null, int n, TRAPS);
 
   // Returns the array class with this class as element type.
-  virtual Klass* array_klass_impl(ArrayStorageProperties storage_props, bool or_null, TRAPS);
+  virtual Klass* array_klass_impl(bool or_null, TRAPS);
 
  public:
 
   static ObjArrayKlass* cast(Klass* k) {
     return const_cast<ObjArrayKlass*>(cast(const_cast<const Klass*>(k)));
diff a/src/hotspot/share/oops/typeArrayKlass.cpp b/src/hotspot/share/oops/typeArrayKlass.cpp
--- a/src/hotspot/share/oops/typeArrayKlass.cpp
+++ b/src/hotspot/share/oops/typeArrayKlass.cpp
@@ -169,12 +169,11 @@
   size_t dst_offset = arrayOopDesc::base_offset_in_bytes(element_type()) + ((size_t)dst_pos << l2es);
   ArrayAccess<ARRAYCOPY_ATOMIC>::arraycopy<void>(s, src_offset, d, dst_offset, (size_t)length << l2es);
 }
 
 // create a klass of array holding typeArrays
-Klass* TypeArrayKlass::array_klass_impl(ArrayStorageProperties storage_props, bool or_null, int n, TRAPS) {
-  assert(storage_props.is_empty(), "Didn't expect storage properties");
+Klass* TypeArrayKlass::array_klass_impl(bool or_null, int n, TRAPS) {
   int dim = dimension();
   assert(dim <= n, "check order of chain");
     if (dim == n)
       return this;
 
@@ -186,12 +185,11 @@
     {
       // Atomic create higher dimension and link into list
       MutexLocker mu(THREAD, MultiArray_lock);
 
       if (higher_dimension() == NULL) {
-        Klass* oak = ObjArrayKlass::allocate_objArray_klass(
-              ArrayStorageProperties::empty, dim + 1, this, CHECK_NULL);
+        Klass* oak = ObjArrayKlass::allocate_objArray_klass(dim + 1, this, CHECK_NULL);
         ObjArrayKlass* h_ak = ObjArrayKlass::cast(oak);
         h_ak->set_lower_dimension(this);
         // use 'release' to pair with lock-free load
         release_set_higher_dimension(h_ak);
         assert(h_ak->is_objArray_klass(), "incorrect initialization of ObjArrayKlass");
@@ -199,18 +197,18 @@
     }
   }
 
   ObjArrayKlass* h_ak = ObjArrayKlass::cast(higher_dimension());
   if (or_null) {
-    return h_ak->array_klass_or_null(storage_props, n);
+    return h_ak->array_klass_or_null(n);
   }
   THREAD->check_possible_safepoint();
-  return h_ak->array_klass(storage_props, n, THREAD);
+  return h_ak->array_klass(n, THREAD);
 }
 
-Klass* TypeArrayKlass::array_klass_impl(ArrayStorageProperties storage_props, bool or_null, TRAPS) {
-  return array_klass_impl(storage_props, or_null, dimension() +  1, THREAD);
+Klass* TypeArrayKlass::array_klass_impl(bool or_null, TRAPS) {
+  return array_klass_impl(or_null, dimension() +  1, THREAD);
 }
 
 int TypeArrayKlass::oop_size(oop obj) const {
   assert(obj->is_typeArray(),"must be a type array");
   typeArrayOop t = typeArrayOop(obj);
diff a/src/hotspot/share/oops/typeArrayKlass.hpp b/src/hotspot/share/oops/typeArrayKlass.hpp
--- a/src/hotspot/share/oops/typeArrayKlass.hpp
+++ b/src/hotspot/share/oops/typeArrayKlass.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -92,14 +92,14 @@
   template <typename T, typename OopClosureType>
   inline void oop_oop_iterate_reverse(oop obj, OopClosureType* closure);
 
  protected:
   // Find n'th dimensional array
-  virtual Klass* array_klass_impl(ArrayStorageProperties storage_props, bool or_null, int n, TRAPS);
+  virtual Klass* array_klass_impl(bool or_null, int n, TRAPS);
 
   // Returns the array class with this class as element type
-  virtual Klass* array_klass_impl(ArrayStorageProperties storage_props, bool or_null, TRAPS);
+  virtual Klass* array_klass_impl(bool or_null, TRAPS);
 
  public:
   static TypeArrayKlass* cast(Klass* k) {
     return const_cast<TypeArrayKlass*>(cast(const_cast<const Klass*>(k)));
   }
diff a/src/hotspot/share/oops/valueArrayKlass.cpp b/src/hotspot/share/oops/valueArrayKlass.cpp
--- a/src/hotspot/share/oops/valueArrayKlass.cpp
+++ b/src/hotspot/share/oops/valueArrayKlass.cpp
@@ -80,45 +80,66 @@
 void ValueArrayKlass::set_element_klass(Klass* k) {
   _element_klass = k;
 }
 
 ValueArrayKlass* ValueArrayKlass::allocate_klass(Klass* element_klass, TRAPS) {
+  guarantee((!Universe::is_bootstrapping() || SystemDictionary::Object_klass_loaded()), "Really ?!");
   assert(ValueArrayFlatten, "Flatten array required");
   assert(ValueKlass::cast(element_klass)->is_naturally_atomic() || (!ValueArrayAtomicAccess), "Atomic by-default");
 
   /*
    *  MVT->LWorld, now need to allocate secondaries array types, just like objArrayKlass...
    *  ...so now we are trying out covariant array types, just copy objArrayKlass
    *  TODO refactor any remaining commonality
+   *
    */
-
-  // Eagerly allocate the direct array supertype, which would be "[L<vt>;" for this "[Q<vt>;"
-  Klass* super_klass = element_klass->array_klass_or_null(ArrayStorageProperties::empty);
-  if (super_klass == NULL) {
-    MutexUnlocker mu(MultiArray_lock);
-    // allocate super...need to drop the lock
-    element_klass->array_klass(ArrayStorageProperties::empty, 1, CHECK_NULL);
-    // retry, start from the beginning since lock dropped...
-    Klass* ak = element_klass->array_klass(ArrayStorageProperties::flattened_and_null_free, 1, CHECK_NULL);
-    return ValueArrayKlass::cast(ak);
+  // Eagerly allocate the direct array supertype.
+  Klass* super_klass = NULL;
+  Klass* element_super = element_klass->super();
+  if (element_super != NULL) {
+    // The element type has a direct super.  E.g., String[] has direct super of Object[].
+    super_klass = element_super->array_klass_or_null();
+    bool supers_exist = super_klass != NULL;
+    // Also, see if the element has secondary supertypes.
+    // We need an array type for each.
+    const Array<Klass*>* element_supers = element_klass->secondary_supers();
+    for( int i = element_supers->length()-1; i >= 0; i-- ) {
+      Klass* elem_super = element_supers->at(i);
+      if (elem_super->array_klass_or_null() == NULL) {
+        supers_exist = false;
+        break;
+      }
+    }
+    if (!supers_exist) {
+      // Oops.  Not allocated yet.  Back out, allocate it, and retry.
+      Klass* ek = NULL;
+      {
+        MutexUnlocker mu(MultiArray_lock);
+        super_klass = element_super->array_klass(CHECK_NULL);
+        for( int i = element_supers->length()-1; i >= 0; i-- ) {
+          Klass* elem_super = element_supers->at(i);
+          elem_super->array_klass(CHECK_NULL);
+        }
+        // Now retry from the beginning
+        ek = element_klass->array_klass(CHECK_NULL);
+      }  // re-lock
+      return ValueArrayKlass::cast(ek);
+    }
   }
 
-  Symbol* name = ArrayKlass::create_element_klass_array_name(true, element_klass, CHECK_NULL);
+  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, CHECK_NULL);
   ClassLoaderData* loader_data = element_klass->class_loader_data();
   int size = ArrayKlass::static_size(ValueArrayKlass::header_size());
   ValueArrayKlass* vak = new (loader_data, size, THREAD) ValueArrayKlass(element_klass, name);
-  loader_data->add_class(vak);
 
   ModuleEntry* module = vak->module();
   assert(module != NULL, "No module entry for array");
   complete_create_array_klass(vak, super_klass, module, CHECK_NULL);
-  return vak;
-}
 
-ValueArrayKlass* ValueArrayKlass::allocate_klass(ArrayStorageProperties storage_props, Klass* element_klass, TRAPS) {
-  assert(storage_props.is_flattened(), "Expected flat storage");
-  return allocate_klass(element_klass, THREAD);
+  loader_data->add_class(vak);
+
+  return vak;
 }
 
 void ValueArrayKlass::initialize(TRAPS) {
   element_klass()->initialize(THREAD);
 }
@@ -308,12 +329,11 @@
      }
    }
 }
 
 
-Klass* ValueArrayKlass::array_klass_impl(ArrayStorageProperties storage_props, bool or_null, int n, TRAPS) {
-  assert(storage_props.is_flattened() || n > 1, "Expected flat storage");
+Klass* ValueArrayKlass::array_klass_impl(bool or_null, int n, TRAPS) {
   assert(dimension() <= n, "check order of chain");
   int dim = dimension();
   if (dim == n) return this;
 
   if (higher_dimension_acquire() == NULL) {
@@ -327,11 +347,11 @@
       // Check if another thread beat us
       if (higher_dimension() == NULL) {
 
         // Create multi-dim klass object and link them together
         Klass* k =
-          ObjArrayKlass::allocate_objArray_klass(storage_props, dim + 1, this, CHECK_NULL);
+          ObjArrayKlass::allocate_objArray_klass(dim + 1, this, CHECK_NULL);
         ObjArrayKlass* ak = ObjArrayKlass::cast(k);
         ak->set_lower_dimension(this);
         OrderAccess::storestore();
         release_set_higher_dimension(ak);
         assert(ak->is_objArray_klass(), "incorrect initialization of ObjArrayKlass");
@@ -341,17 +361,17 @@
     CHECK_UNHANDLED_OOPS_ONLY(Thread::current()->clear_unhandled_oops());
   }
 
   ObjArrayKlass *ak = ObjArrayKlass::cast(higher_dimension());
   if (or_null) {
-    return ak->array_klass_or_null(storage_props, n);
+    return ak->array_klass_or_null(n);
   }
-  return ak->array_klass(storage_props, n, THREAD);
+  return ak->array_klass(n, THREAD);
 }
 
-Klass* ValueArrayKlass::array_klass_impl(ArrayStorageProperties storage_props, bool or_null, TRAPS) {
-  return array_klass_impl(storage_props, or_null, dimension() +  1, THREAD);
+Klass* ValueArrayKlass::array_klass_impl(bool or_null, TRAPS) {
+  return array_klass_impl(or_null, dimension() +  1, THREAD);
 }
 
 ModuleEntry* ValueArrayKlass::module() const {
   assert(element_klass() != NULL, "ValueArrayKlass returned unexpected NULL bottom_klass");
   // The array is defined in the module of its bottom class
@@ -382,11 +402,11 @@
     GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(num_elem_supers+2);
     secondaries->push(SystemDictionary::Cloneable_klass());
     secondaries->push(SystemDictionary::Serializable_klass());
     for (int i = 0; i < num_elem_supers; i++) {
       Klass* elem_super = (Klass*) elem_supers->at(i);
-      Klass* array_super = elem_super->array_klass_or_null(ArrayStorageProperties::empty);
+      Klass* array_super = elem_super->array_klass_or_null();
       assert(array_super != NULL, "must already have been created");
       secondaries->push(array_super);
     }
     return secondaries;
   }
diff a/src/hotspot/share/oops/valueArrayKlass.hpp b/src/hotspot/share/oops/valueArrayKlass.hpp
--- a/src/hotspot/share/oops/valueArrayKlass.hpp
+++ b/src/hotspot/share/oops/valueArrayKlass.hpp
@@ -41,17 +41,16 @@
 
  private:
   // Constructor
   ValueArrayKlass(Klass* element_klass, Symbol* name);
 
-  static ValueArrayKlass* allocate_klass(Klass* element_klass, TRAPS);
  protected:
   // Returns the ArrayKlass for n'th dimension.
-  Klass* array_klass_impl(ArrayStorageProperties storage_props, bool or_null, int n, TRAPS);
+  Klass* array_klass_impl(bool or_null, int n, TRAPS);
 
   // Returns the array class with this class as element type.
-  Klass* array_klass_impl(ArrayStorageProperties storage_props, bool or_null, TRAPS);
+  Klass* array_klass_impl(bool or_null, TRAPS);
 
  public:
 
   ValueArrayKlass() {}
 
@@ -66,11 +65,11 @@
     assert(k->is_valueArray_klass(), "cast to ValueArrayKlass");
     return (ValueArrayKlass*) k;
   }
 
   // klass allocation
-  static ValueArrayKlass* allocate_klass(ArrayStorageProperties storage_props, Klass* element_klass, TRAPS);
+  static ValueArrayKlass* allocate_klass(Klass* element_klass, TRAPS);
 
   void initialize(TRAPS);
 
   ModuleEntry* module() const;
   PackageEntry* package() const;
diff a/src/hotspot/share/oops/valueKlass.cpp b/src/hotspot/share/oops/valueKlass.cpp
--- a/src/hotspot/share/oops/valueKlass.cpp
+++ b/src/hotspot/share/oops/valueKlass.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -178,26 +178,27 @@
 
 bool ValueKlass::flatten_array() {
   if (!ValueArrayFlatten) {
     return false;
   }
-
-  int elem_bytes = raw_value_byte_size();
   // Too big
+  int elem_bytes = raw_value_byte_size();
   if ((ValueArrayElemMaxFlatSize >= 0) && (elem_bytes > ValueArrayElemMaxFlatSize)) {
     return false;
   }
   // Too many embedded oops
   if ((ValueArrayElemMaxFlatOops >= 0) && (nonstatic_oop_count() > ValueArrayElemMaxFlatOops)) {
     return false;
   }
-
   // Declared atomic but not naturally atomic.
   if (is_declared_atomic() && !is_naturally_atomic()) {
     return false;
   }
-
+  // VM enforcing ValueArrayAtomicAccess only...
+  if (ValueArrayAtomicAccess && (!is_naturally_atomic())) {
+    return false;
+  }
   return true;
 }
 
 void ValueKlass::remove_unshareable_info() {
   InstanceKlass::remove_unshareable_info();
@@ -216,23 +217,23 @@
   oop val = allocate_instance(CHECK);
   set_default_value(val);
 }
 
 
-Klass* ValueKlass::array_klass_impl(ArrayStorageProperties storage_props, bool or_null, int n, TRAPS) {
-  if (storage_props.is_null_free()) {
-    return value_array_klass(storage_props, or_null, n, THREAD);
+Klass* ValueKlass::array_klass_impl(bool or_null, int n, TRAPS) {
+  if (flatten_array()) {
+    return value_array_klass(or_null, n, THREAD);
   } else {
-    return InstanceKlass::array_klass_impl(storage_props, or_null, n, THREAD);
+    return InstanceKlass::array_klass_impl(or_null, n, THREAD);
   }
 }
 
-Klass* ValueKlass::array_klass_impl(ArrayStorageProperties storage_props, bool or_null, TRAPS) {
-  return array_klass_impl(storage_props, or_null, 1, THREAD);
+Klass* ValueKlass::array_klass_impl(bool or_null, TRAPS) {
+  return array_klass_impl(or_null, 1, THREAD);
 }
 
-Klass* ValueKlass::value_array_klass(ArrayStorageProperties storage_props, bool or_null, int rank, TRAPS) {
+Klass* ValueKlass::value_array_klass(bool or_null, int rank, TRAPS) {
   Klass* vak = acquire_value_array_klass();
   if (vak == NULL) {
     if (or_null) return NULL;
     ResourceMark rm;
     {
@@ -242,24 +243,21 @@
         vak = allocate_value_array_klass(CHECK_NULL);
         Atomic::release_store((Klass**)adr_value_array_klass(), vak);
       }
     }
   }
-  if (!vak->is_valueArray_klass()) {
-    storage_props.clear_flattened();
-  }
   if (or_null) {
-    return vak->array_klass_or_null(storage_props, rank);
+    return vak->array_klass_or_null(rank);
   }
-  return vak->array_klass(storage_props, rank, THREAD);
+  return vak->array_klass(rank, THREAD);
 }
 
 Klass* ValueKlass::allocate_value_array_klass(TRAPS) {
-  if (flatten_array() && (is_naturally_atomic() || (!ValueArrayAtomicAccess))) {
-    return ValueArrayKlass::allocate_klass(ArrayStorageProperties::flattened_and_null_free, this, THREAD);
+  if (flatten_array()) {
+    return ValueArrayKlass::allocate_klass(this, THREAD);
   }
-  return ObjArrayKlass::allocate_objArray_klass(ArrayStorageProperties::null_free, 1, this, THREAD);
+  return ObjArrayKlass::allocate_objArray_klass(1, this, THREAD);
 }
 
 void ValueKlass::array_klasses_do(void f(Klass* k)) {
   InstanceKlass::array_klasses_do(f);
   if (get_value_array_klass() != NULL)
diff a/src/hotspot/share/oops/valueKlass.hpp b/src/hotspot/share/oops/valueKlass.hpp
--- a/src/hotspot/share/oops/valueKlass.hpp
+++ b/src/hotspot/share/oops/valueKlass.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -169,17 +169,17 @@
   void cleanup_blobs();
 
 
  protected:
   // Returns the array class for the n'th dimension
-  Klass* array_klass_impl(ArrayStorageProperties storage_props, bool or_null, int n, TRAPS);
+  Klass* array_klass_impl(bool or_null, int n, TRAPS);
 
   // Returns the array class with this class as element type
-  Klass* array_klass_impl(ArrayStorageProperties storage_props, bool or_null, TRAPS);
+  Klass* array_klass_impl(bool or_null, TRAPS);
 
   // Specifically flat array klass
-  Klass* value_array_klass(ArrayStorageProperties storage_props, bool or_null, int rank, TRAPS);
+  Klass* value_array_klass(bool or_null, int rank, TRAPS);
 
  public:
   // Type testing
   bool is_value_slow() const        { return true; }
 
diff a/src/hotspot/share/prims/jvmtiGetLoadedClasses.cpp b/src/hotspot/share/prims/jvmtiGetLoadedClasses.cpp
--- a/src/hotspot/share/prims/jvmtiGetLoadedClasses.cpp
+++ b/src/hotspot/share/prims/jvmtiGetLoadedClasses.cpp
@@ -73,11 +73,11 @@
     // Collect all jclasses
     _classStack.push((jclass) _env->jni_reference(Handle(_cur_thread, k->java_mirror())));
     if (_dictionary_walk) {
       // Collect array classes this way when walking the dictionary (because array classes are
       // not in the dictionary).
-      for (Klass* l = k->array_klass_or_null(ArrayStorageProperties::empty); l != NULL; l = l->array_klass_or_null(ArrayStorageProperties::empty)) {
+      for (Klass* l = k->array_klass_or_null(); l != NULL; l = l->array_klass_or_null()) {
         _classStack.push((jclass) _env->jni_reference(Handle(_cur_thread, l->java_mirror())));
       }
       // CMH flat arrays (ValueKlass)
     }
   }
diff a/src/hotspot/share/runtime/reflection.cpp b/src/hotspot/share/runtime/reflection.cpp
--- a/src/hotspot/share/runtime/reflection.cpp
+++ b/src/hotspot/share/runtime/reflection.cpp
@@ -391,12 +391,11 @@
         THROW_0(vmSymbols::java_lang_IllegalArgumentException());
       }
       dim += k_dim;
     }
   }
-  ArrayStorageProperties storage_props = ArrayStorageProperties::for_signature(klass->name());
-  klass = klass->array_klass(storage_props, dim, CHECK_NULL);
+  klass = klass->array_klass(dim, CHECK_NULL);
   oop obj = ArrayKlass::cast(klass)->multi_allocate(len, dimensions, CHECK_NULL);
   assert(obj->is_array(), "just checking");
   return arrayOop(obj);
 }
 
diff a/src/hotspot/share/services/heapDumper.cpp b/src/hotspot/share/services/heapDumper.cpp
--- a/src/hotspot/share/services/heapDumper.cpp
+++ b/src/hotspot/share/services/heapDumper.cpp
@@ -1073,11 +1073,11 @@
   dump_instance_field_descriptors(writer, ik);
 
   writer->end_sub_record();
 
   // array classes
-  k = k->array_klass_or_null(ArrayStorageProperties::empty);
+  k = k->array_klass_or_null();
   while (k != NULL) {
     assert(k->is_objArray_klass(), "not an ObjArrayKlass");
 
     u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + 2;
     writer->start_sub_record(HPROF_GC_CLASS_DUMP, size);
@@ -1101,11 +1101,11 @@
     writer->write_u2(0);             // instance fields
 
     writer->end_sub_record();
 
     // get the array class for the next rank
-    k = k->array_klass_or_null(ArrayStorageProperties::empty);
+    k = k->array_klass_or_null();
   }
 }
 
 // creates HPROF_GC_CLASS_DUMP record for a given primitive array
 // class (and each multi-dimensional array class too)
@@ -1136,11 +1136,11 @@
     writer->write_u2(0);             // instance fields
 
     writer->end_sub_record();
 
     // get the array class for the next rank
-    k = klass->array_klass_or_null(ArrayStorageProperties::empty);
+    k = klass->array_klass_or_null();
   }
 }
 
 // Hprof uses an u4 as record length field,
 // which means we need to truncate arrays that are too long.
@@ -1635,11 +1635,11 @@
     // class name ID
     Symbol* name = klass->name();
     writer()->write_symbolID(name);
 
     // write a LOAD_CLASS record for the array type (if it exists)
-    k = klass->array_klass_or_null(ArrayStorageProperties::empty);
+    k = klass->array_klass_or_null();
   } while (k != NULL);
 }
 
 // writes a HPROF_GC_CLASS_DUMP record for the given class
 void VM_HeapDumper::do_class_dump(Klass* k) {
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeArray.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeArray.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeArray.java
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeArray.java
@@ -63,20 +63,17 @@
 
         testValueArrayOom();
     }
 
     void testClassForName() {
-        String arrayClsName = "[Lruntime.valhalla.valuetypes.Point;";
+        String arrayClsName = "[Lruntime.valhalla.valuetypes.Point$ref;";
         String qarrayClsName = "[Qruntime.valhalla.valuetypes.Point;";
         try {
             // L-type..
             Class<?> arrayCls = Class.forName(arrayClsName);
             assertTrue(arrayCls.isArray(), "Expected an array class");
 
-            assertTrue(arrayCls.getComponentType() == Point.class.asIndirectType(),
-                       "Expected component type of Point.class got: " + arrayCls.getComponentType());
-
             arrayClsName = "[" + arrayClsName;
             Class<?> mulArrayCls = Class.forName(arrayClsName);
             assertTrue(mulArrayCls.isArray());
             assertTrue(mulArrayCls.getComponentType() == arrayCls);
 

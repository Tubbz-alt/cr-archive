<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/arrayKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../memory/oopFactory.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arrayKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/arrayKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 82   // super klass of an array, (j.l.Object) should not have
 83   // any overpass methods present.
 84   return super()-&gt;uncached_lookup_method(name, signature, Klass::skip_overpass, private_mode);
 85 }
 86 
 87 ArrayKlass::ArrayKlass(Symbol* name, KlassID id) :
 88   Klass(id),
 89   _dimension(1),
 90   _higher_dimension(NULL),
 91   _lower_dimension(NULL) {
 92     // Arrays don&#39;t add any new methods, so their vtable is the same size as
 93     // the vtable of klass Object.
 94     set_vtable_length(Universe::base_vtable_size());
 95     set_name(name);
 96     set_super(Universe::is_bootstrapping() ? NULL : SystemDictionary::Object_klass());
 97     set_layout_helper(Klass::_lh_neutral_value);
 98     set_is_cloneable(); // All arrays are considered to be cloneable (See JLS 20.1.5)
 99     JFR_ONLY(INIT_ID(this);)
100 }
101 
<span class="line-modified">102 Symbol* ArrayKlass::create_element_klass_array_name(bool is_qtype, Klass* element_klass, TRAPS) {</span>
103   Symbol* name = NULL;

104   if (!element_klass-&gt;is_instance_klass() || is_qtype ||
105       (name = InstanceKlass::cast(element_klass)-&gt;array_name()) == NULL) {
106 
107     ResourceMark rm(THREAD);
108     char *name_str = element_klass-&gt;name()-&gt;as_C_string();
109     int len = element_klass-&gt;name()-&gt;utf8_length();
110     char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);
111     int idx = 0;
112     new_str[idx++] = JVM_SIGNATURE_ARRAY;
113     if (element_klass-&gt;is_instance_klass()) { // it could be an array or simple type
114       if (is_qtype) {
115         new_str[idx++] = JVM_SIGNATURE_VALUETYPE;
116       } else {
117         new_str[idx++] = JVM_SIGNATURE_CLASS;
118       }
119     }
120     memcpy(&amp;new_str[idx], name_str, len * sizeof(char));
121     idx += len;
122     if (element_klass-&gt;is_instance_klass()) {
123       new_str[idx++] = JVM_SIGNATURE_ENDCLASS;
124     }
125     new_str[idx++] = &#39;\0&#39;;
<span class="line-modified">126     name = SymbolTable::new_permanent_symbol(new_str);</span>
<span class="line-modified">127     if (element_klass-&gt;is_instance_klass() &amp;&amp; (!is_qtype)) {</span>
128       InstanceKlass* ik = InstanceKlass::cast(element_klass);
<span class="line-modified">129       ik-&gt;set_array_name(name); // CMH: only cache and deref array_name for L-type...missing for Q-type</span>
130     }
131   }
132 
133   return name;
134 }
135 
136 // Initialization of vtables and mirror object is done separatly from base_create_array_klass,
137 // since a GC can happen. At this point all instance variables of the ArrayKlass must be setup.
138 void ArrayKlass::complete_create_array_klass(ArrayKlass* k, Klass* super_klass, ModuleEntry* module_entry, TRAPS) {
139   k-&gt;initialize_supers(super_klass, NULL, CHECK);
140   k-&gt;vtable().initialize_vtable(false, CHECK);
141 
142   // During bootstrapping, before java.base is defined, the module_entry may not be present yet.
143   // These classes will be put on a fixup list and their module fields will be patched once
144   // java.base is defined.
145   assert((module_entry != NULL) || ((module_entry == NULL) &amp;&amp; !ModuleEntryTable::javabase_defined()),
146          &quot;module entry not available post &quot; JAVA_BASE_NAME &quot; definition&quot;);
147   oop module = (module_entry != NULL) ? module_entry-&gt;module() : (oop)NULL;
148   java_lang_Class::create_mirror(k, Handle(THREAD, k-&gt;class_loader()), Handle(THREAD, module), Handle(), CHECK);
149 }
150 
151 GrowableArray&lt;Klass*&gt;* ArrayKlass::compute_secondary_supers(int num_extra_slots,
152                                                             Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
153   // interfaces = { cloneable_klass, serializable_klass };
154   assert(num_extra_slots == 0, &quot;sanity of primitive array type&quot;);
155   assert(transitive_interfaces == NULL, &quot;sanity&quot;);
156   // Must share this for correct bootstrapping!
157   set_secondary_supers(Universe::the_array_interfaces_array());
158   return NULL;
159 }
160 
161 objArrayOop ArrayKlass::allocate_arrayArray(int n, int length, TRAPS) {
162   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_ARRAY), CHECK_NULL);
163   int size = objArrayOopDesc::object_size(length);
<span class="line-modified">164   Klass* k = array_klass(ArrayStorageProperties::for_signature(name()), n+dimension(), CHECK_NULL);</span>
165   ArrayKlass* ak = ArrayKlass::cast(k);
166   objArrayOop o = (objArrayOop)Universe::heap()-&gt;array_allocate(ak, size, length,
167                                                                 /* do_zero */ true, CHECK_NULL);
168   // initialization to NULL not necessary, area already cleared
169   return o;
170 }
171 
172 void ArrayKlass::array_klasses_do(void f(Klass* k)) {
173   Klass* k = this;
174   // Iterate over this array klass and all higher dimensions
175   while (k != NULL) {
176     f(k);
177     k = ArrayKlass::cast(k)-&gt;higher_dimension();
178   }
179 }
180 
181 oop ArrayKlass::component_mirror() const {
182   return java_lang_Class::component_mirror(java_mirror());
183 }
184 
</pre>
</td>
<td>
<hr />
<pre>
 82   // super klass of an array, (j.l.Object) should not have
 83   // any overpass methods present.
 84   return super()-&gt;uncached_lookup_method(name, signature, Klass::skip_overpass, private_mode);
 85 }
 86 
 87 ArrayKlass::ArrayKlass(Symbol* name, KlassID id) :
 88   Klass(id),
 89   _dimension(1),
 90   _higher_dimension(NULL),
 91   _lower_dimension(NULL) {
 92     // Arrays don&#39;t add any new methods, so their vtable is the same size as
 93     // the vtable of klass Object.
 94     set_vtable_length(Universe::base_vtable_size());
 95     set_name(name);
 96     set_super(Universe::is_bootstrapping() ? NULL : SystemDictionary::Object_klass());
 97     set_layout_helper(Klass::_lh_neutral_value);
 98     set_is_cloneable(); // All arrays are considered to be cloneable (See JLS 20.1.5)
 99     JFR_ONLY(INIT_ID(this);)
100 }
101 
<span class="line-modified">102 Symbol* ArrayKlass::create_element_klass_array_name(Klass* element_klass, TRAPS) {</span>
103   Symbol* name = NULL;
<span class="line-added">104   bool is_qtype = element_klass-&gt;is_value();</span>
105   if (!element_klass-&gt;is_instance_klass() || is_qtype ||
106       (name = InstanceKlass::cast(element_klass)-&gt;array_name()) == NULL) {
107 
108     ResourceMark rm(THREAD);
109     char *name_str = element_klass-&gt;name()-&gt;as_C_string();
110     int len = element_klass-&gt;name()-&gt;utf8_length();
111     char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);
112     int idx = 0;
113     new_str[idx++] = JVM_SIGNATURE_ARRAY;
114     if (element_klass-&gt;is_instance_klass()) { // it could be an array or simple type
115       if (is_qtype) {
116         new_str[idx++] = JVM_SIGNATURE_VALUETYPE;
117       } else {
118         new_str[idx++] = JVM_SIGNATURE_CLASS;
119       }
120     }
121     memcpy(&amp;new_str[idx], name_str, len * sizeof(char));
122     idx += len;
123     if (element_klass-&gt;is_instance_klass()) {
124       new_str[idx++] = JVM_SIGNATURE_ENDCLASS;
125     }
126     new_str[idx++] = &#39;\0&#39;;
<span class="line-modified">127     name = SymbolTable::new_symbol(new_str);</span>
<span class="line-modified">128     if (element_klass-&gt;is_instance_klass()) {</span>
129       InstanceKlass* ik = InstanceKlass::cast(element_klass);
<span class="line-modified">130       ik-&gt;set_array_name(name);</span>
131     }
132   }
133 
134   return name;
135 }
136 
137 // Initialization of vtables and mirror object is done separatly from base_create_array_klass,
138 // since a GC can happen. At this point all instance variables of the ArrayKlass must be setup.
139 void ArrayKlass::complete_create_array_klass(ArrayKlass* k, Klass* super_klass, ModuleEntry* module_entry, TRAPS) {
140   k-&gt;initialize_supers(super_klass, NULL, CHECK);
141   k-&gt;vtable().initialize_vtable(false, CHECK);
142 
143   // During bootstrapping, before java.base is defined, the module_entry may not be present yet.
144   // These classes will be put on a fixup list and their module fields will be patched once
145   // java.base is defined.
146   assert((module_entry != NULL) || ((module_entry == NULL) &amp;&amp; !ModuleEntryTable::javabase_defined()),
147          &quot;module entry not available post &quot; JAVA_BASE_NAME &quot; definition&quot;);
148   oop module = (module_entry != NULL) ? module_entry-&gt;module() : (oop)NULL;
149   java_lang_Class::create_mirror(k, Handle(THREAD, k-&gt;class_loader()), Handle(THREAD, module), Handle(), CHECK);
150 }
151 
152 GrowableArray&lt;Klass*&gt;* ArrayKlass::compute_secondary_supers(int num_extra_slots,
153                                                             Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
154   // interfaces = { cloneable_klass, serializable_klass };
155   assert(num_extra_slots == 0, &quot;sanity of primitive array type&quot;);
156   assert(transitive_interfaces == NULL, &quot;sanity&quot;);
157   // Must share this for correct bootstrapping!
158   set_secondary_supers(Universe::the_array_interfaces_array());
159   return NULL;
160 }
161 
162 objArrayOop ArrayKlass::allocate_arrayArray(int n, int length, TRAPS) {
163   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_ARRAY), CHECK_NULL);
164   int size = objArrayOopDesc::object_size(length);
<span class="line-modified">165   Klass* k = array_klass(n+dimension(), CHECK_NULL);</span>
166   ArrayKlass* ak = ArrayKlass::cast(k);
167   objArrayOop o = (objArrayOop)Universe::heap()-&gt;array_allocate(ak, size, length,
168                                                                 /* do_zero */ true, CHECK_NULL);
169   // initialization to NULL not necessary, area already cleared
170   return o;
171 }
172 
173 void ArrayKlass::array_klasses_do(void f(Klass* k)) {
174   Klass* k = this;
175   // Iterate over this array klass and all higher dimensions
176   while (k != NULL) {
177     f(k);
178     k = ArrayKlass::cast(k)-&gt;higher_dimension();
179   }
180 }
181 
182 oop ArrayKlass::component_mirror() const {
183   return java_lang_Class::component_mirror(java_mirror());
184 }
185 
</pre>
</td>
</tr>
</table>
<center><a href="../memory/oopFactory.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arrayKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
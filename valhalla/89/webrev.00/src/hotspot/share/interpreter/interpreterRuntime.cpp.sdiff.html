<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/interpreterRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../classfile/verifier.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="linkResolver.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/interpreterRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 217   thread-&gt;set_vm_result(result);
 218   if (!is_fast_aldc) {
 219     // Tell the interpreter how to unbox the primitive.
 220     guarantee(java_lang_boxing_object::is_instance(result, type), &quot;&quot;);
 221     int offset = java_lang_boxing_object::value_offset(type);
 222     intptr_t flags = ((as_TosState(type) &lt;&lt; ConstantPoolCacheEntry::tos_state_shift)
 223                       | (offset &amp; ConstantPoolCacheEntry::field_index_mask));
 224     thread-&gt;set_vm_result_2((Metadata*)flags);
 225   }
 226 }
 227 JRT_END
 228 
 229 
 230 //------------------------------------------------------------------------------------------------------------------------
 231 // Allocation
 232 
 233 JRT_ENTRY(void, InterpreterRuntime::_new(JavaThread* thread, ConstantPool* pool, int index))
 234   Klass* k = pool-&gt;klass_at(index, CHECK);
 235   InstanceKlass* klass = InstanceKlass::cast(k);
 236 
<span class="line-modified"> 237   if (klass-&gt;is_value()) {</span>
 238     THROW(vmSymbols::java_lang_InstantiationError());
 239   }
 240 
 241   // Make sure we are not instantiating an abstract klass
 242   klass-&gt;check_valid_for_instantiation(true, CHECK);
 243 
 244   // Make sure klass is initialized
 245   klass-&gt;initialize(CHECK);
 246 
 247   // At this point the class may not be fully initialized
 248   // because of recursive initialization. If it is fully
 249   // initialized &amp; has_finalized is not set, we rewrite
 250   // it into its fast version (Note: no locking is needed
 251   // here since this is an atomic byte write and can be
 252   // done more than once).
 253   //
 254   // Note: In case of classes with has_finalized we don&#39;t
 255   //       rewrite since that saves us an extra check in
 256   //       the fast version which then would call the
 257   //       slow version anyway (and do a call back into
</pre>
<hr />
<pre>
 284     break;
 285   case T_INT:
 286     instance()-&gt;int_field_put(offset, (jint)*((int*)addr));
 287     break;
 288   case T_LONG:
 289     instance()-&gt;long_field_put(offset, (jlong)*((long long*)addr));
 290     break;
 291   case T_OBJECT:
 292   case T_ARRAY:
 293   case T_VALUETYPE:
 294     fatal(&quot;Should not be handled with this method&quot;);
 295     break;
 296   default:
 297     fatal(&quot;Unsupported BasicType&quot;);
 298   }
 299 }
 300 
 301 JRT_ENTRY(void, InterpreterRuntime::defaultvalue(JavaThread* thread, ConstantPool* pool, int index))
 302   // Getting the ValueKlass
 303   Klass* k = pool-&gt;klass_at(index, CHECK);
<span class="line-modified"> 304   if (!k-&gt;is_value()) {</span>
 305     // inconsistency with &#39;new&#39; which throws an InstantiationError
 306     // in the future, defaultvalue will just return null instead of throwing an exception
 307     THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
 308   }
<span class="line-modified"> 309   assert(k-&gt;is_value(), &quot;defaultvalue argument must be the value type class&quot;);</span>
 310   ValueKlass* vklass = ValueKlass::cast(k);
 311 
 312   vklass-&gt;initialize(THREAD);
 313   oop res = vklass-&gt;default_value();
 314   thread-&gt;set_vm_result(res);
 315 JRT_END
 316 
 317 JRT_ENTRY(int, InterpreterRuntime::withfield(JavaThread* thread, ConstantPoolCache* cp_cache))
 318   LastFrameAccessor last_frame(thread);
 319   // Getting the ValueKlass
 320   int index = ConstantPool::decode_cpcache_index(last_frame.get_index_u2_cpcache(Bytecodes::_withfield));
 321   ConstantPoolCacheEntry* cp_entry = cp_cache-&gt;entry_at(index);
 322   assert(cp_entry-&gt;is_resolved(Bytecodes::_withfield), &quot;Should have been resolved&quot;);
 323   Klass* klass = cp_entry-&gt;f1_as_klass();
<span class="line-modified"> 324   assert(klass-&gt;is_value(), &quot;withfield only applies to value types&quot;);</span>
 325   ValueKlass* vklass = ValueKlass::cast(klass);
 326 
 327   // Getting Field information
 328   int offset = cp_entry-&gt;f2_as_index();
 329   int field_index = cp_entry-&gt;field_index();
 330   int field_offset = cp_entry-&gt;f2_as_offset();
 331   Symbol* field_signature = vklass-&gt;field_signature(field_index);
 332   BasicType field_type = Signature::basic_type(field_signature);
 333   int return_offset = (type2size[field_type] + type2size[T_OBJECT]) * AbstractInterpreter::stackElementSize;
 334 
 335   // Getting old value
 336   frame&amp; f = last_frame.get_frame();
 337   jint tos_idx = f.interpreter_frame_expression_stack_size() - 1;
 338   int vt_offset = type2size[field_type];
 339   oop old_value = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx - vt_offset);
<span class="line-modified"> 340   assert(old_value != NULL &amp;&amp; oopDesc::is_oop(old_value) &amp;&amp; old_value-&gt;is_value(),&quot;Verifying receiver&quot;);</span>
 341   Handle old_value_h(THREAD, old_value);
 342 
 343   // Creating new value by copying the one passed in argument
 344   instanceOop new_value = vklass-&gt;allocate_instance(
 345       CHECK_((type2size[field_type]) * AbstractInterpreter::stackElementSize));
 346   Handle new_value_h = Handle(THREAD, new_value);
 347   vklass-&gt;value_copy_oop_to_new_oop(old_value_h(), new_value_h());
 348 
 349   // Updating the field specified in arguments
 350   if (field_type == T_ARRAY || field_type == T_OBJECT) {
 351     oop aoop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
 352     assert(aoop == NULL || oopDesc::is_oop(aoop),&quot;argument must be a reference type&quot;);
 353     new_value_h()-&gt;obj_field_put(field_offset, aoop);
 354   } else if (field_type == T_VALUETYPE) {
 355     if (cp_entry-&gt;is_inlined()) {
 356       oop vt_oop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
<span class="line-modified"> 357       assert(vt_oop != NULL &amp;&amp; oopDesc::is_oop(vt_oop) &amp;&amp; vt_oop-&gt;is_value(),&quot;argument must be a value type&quot;);</span>
 358       ValueKlass* field_vk = ValueKlass::cast(vklass-&gt;get_value_field_klass(field_index));
 359       assert(vt_oop != NULL &amp;&amp; field_vk == vt_oop-&gt;klass(), &quot;Must match&quot;);
 360       field_vk-&gt;write_inlined_field(new_value_h(), offset, vt_oop, CHECK_(return_offset));
 361     } else { // not inlined
 362       oop voop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
 363       if (voop == NULL &amp;&amp; cp_entry-&gt;is_inline_type()) {
 364         THROW_(vmSymbols::java_lang_NullPointerException(), return_offset);
 365       }
 366       assert(voop == NULL || oopDesc::is_oop(voop),&quot;checking argument&quot;);
 367       new_value_h()-&gt;obj_field_put(field_offset, voop);
 368     }
 369   } else { // not T_OBJECT nor T_ARRAY nor T_VALUETYPE
 370     intptr_t* addr = f.interpreter_frame_expression_stack_at(tos_idx);
 371     copy_primitive_argument(addr, new_value_h, field_offset, field_type);
 372   }
 373 
 374   // returning result
 375   thread-&gt;set_vm_result(new_value_h());
 376   return return_offset;
 377 JRT_END
</pre>
<hr />
<pre>
 909                &quot;Class %s does not implement the requested interface %s&quot;,
 910                recvKlass ? recvKlass-&gt;external_name() : &quot;NULL&quot;,
 911                interfaceKlass ? interfaceKlass-&gt;external_name() : &quot;NULL&quot;);
 912   THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 913 JRT_END
 914 
 915 //------------------------------------------------------------------------------------------------------------------------
 916 // Fields
 917 //
 918 
 919 void InterpreterRuntime::resolve_get_put(JavaThread* thread, Bytecodes::Code bytecode) {
 920   Thread* THREAD = thread;
 921   // resolve field
 922   fieldDescriptor info;
 923   LastFrameAccessor last_frame(thread);
 924   constantPoolHandle pool(thread, last_frame.method()-&gt;constants());
 925   methodHandle m(thread, last_frame.method());
 926   bool is_put    = (bytecode == Bytecodes::_putfield  || bytecode == Bytecodes::_nofast_putfield ||
 927                     bytecode == Bytecodes::_putstatic || bytecode == Bytecodes::_withfield);
 928   bool is_static = (bytecode == Bytecodes::_getstatic || bytecode == Bytecodes::_putstatic);
<span class="line-modified"> 929   bool is_value  = bytecode == Bytecodes::_withfield;</span>
 930 
 931   {
 932     JvmtiHideSingleStepping jhss(thread);
 933     LinkResolver::resolve_field_access(info, pool, last_frame.get_index_u2_cpcache(bytecode),
 934                                        m, bytecode, CHECK);
 935   } // end JvmtiHideSingleStepping
 936 
 937   // check if link resolution caused cpCache to be updated
 938   ConstantPoolCacheEntry* cp_cache_entry = last_frame.cache_entry();
 939   if (cp_cache_entry-&gt;is_resolved(bytecode)) return;
 940 
 941   // compute auxiliary field attributes
 942   TosState state  = as_TosState(info.field_type());
 943 
 944   // Resolution of put instructions on final fields is delayed. That is required so that
 945   // exceptions are thrown at the correct place (when the instruction is actually invoked).
 946   // If we do not resolve an instruction in the current pass, leaving the put_code
 947   // set to zero will cause the next put instruction to the same field to reresolve.
 948 
 949   // Resolution of put instructions to final instance fields with invalid updates (i.e.,
</pre>
<hr />
<pre>
 958   // and the required IllegalAccessError would not be thrown.
 959   //
 960   // Also, we need to delay resolving getstatic and putstatic instructions until the
 961   // class is initialized.  This is required so that access to the static
 962   // field will call the initialization function every time until the class
 963   // is completely initialized ala. in 2.17.5 in JVM Specification.
 964   InstanceKlass* klass = info.field_holder();
 965   bool uninitialized_static = is_static &amp;&amp; !klass-&gt;is_initialized();
 966   bool has_initialized_final_update = info.field_holder()-&gt;major_version() &gt;= 53 &amp;&amp;
 967                                       info.has_initialized_final_update();
 968   assert(!(has_initialized_final_update &amp;&amp; !info.access_flags().is_final()), &quot;Fields with initialized final updates must be final&quot;);
 969 
 970   Bytecodes::Code get_code = (Bytecodes::Code)0;
 971   Bytecodes::Code put_code = (Bytecodes::Code)0;
 972   if (!uninitialized_static) {
 973     if (is_static) {
 974       get_code = Bytecodes::_getstatic;
 975     } else {
 976       get_code = Bytecodes::_getfield;
 977     }
<span class="line-modified"> 978     if (is_put &amp;&amp; is_value) {</span>
 979         put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_withfield);
 980     } else if ((is_put &amp;&amp; !has_initialized_final_update) || !info.access_flags().is_final()) {
 981         put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_putfield);
 982     }
 983   }
 984 
 985   cp_cache_entry-&gt;set_field(
 986     get_code,
 987     put_code,
 988     info.field_holder(),
 989     info.index(),
 990     info.offset(),
 991     state,
 992     info.access_flags().is_final(),
 993     info.access_flags().is_volatile(),
 994     info.is_inlined(),
 995     info.is_inline_type(),
 996     pool-&gt;pool_holder()
 997   );
 998 }
</pre>
</td>
<td>
<hr />
<pre>
 217   thread-&gt;set_vm_result(result);
 218   if (!is_fast_aldc) {
 219     // Tell the interpreter how to unbox the primitive.
 220     guarantee(java_lang_boxing_object::is_instance(result, type), &quot;&quot;);
 221     int offset = java_lang_boxing_object::value_offset(type);
 222     intptr_t flags = ((as_TosState(type) &lt;&lt; ConstantPoolCacheEntry::tos_state_shift)
 223                       | (offset &amp; ConstantPoolCacheEntry::field_index_mask));
 224     thread-&gt;set_vm_result_2((Metadata*)flags);
 225   }
 226 }
 227 JRT_END
 228 
 229 
 230 //------------------------------------------------------------------------------------------------------------------------
 231 // Allocation
 232 
 233 JRT_ENTRY(void, InterpreterRuntime::_new(JavaThread* thread, ConstantPool* pool, int index))
 234   Klass* k = pool-&gt;klass_at(index, CHECK);
 235   InstanceKlass* klass = InstanceKlass::cast(k);
 236 
<span class="line-modified"> 237   if (klass-&gt;is_inline_klass()) {</span>
 238     THROW(vmSymbols::java_lang_InstantiationError());
 239   }
 240 
 241   // Make sure we are not instantiating an abstract klass
 242   klass-&gt;check_valid_for_instantiation(true, CHECK);
 243 
 244   // Make sure klass is initialized
 245   klass-&gt;initialize(CHECK);
 246 
 247   // At this point the class may not be fully initialized
 248   // because of recursive initialization. If it is fully
 249   // initialized &amp; has_finalized is not set, we rewrite
 250   // it into its fast version (Note: no locking is needed
 251   // here since this is an atomic byte write and can be
 252   // done more than once).
 253   //
 254   // Note: In case of classes with has_finalized we don&#39;t
 255   //       rewrite since that saves us an extra check in
 256   //       the fast version which then would call the
 257   //       slow version anyway (and do a call back into
</pre>
<hr />
<pre>
 284     break;
 285   case T_INT:
 286     instance()-&gt;int_field_put(offset, (jint)*((int*)addr));
 287     break;
 288   case T_LONG:
 289     instance()-&gt;long_field_put(offset, (jlong)*((long long*)addr));
 290     break;
 291   case T_OBJECT:
 292   case T_ARRAY:
 293   case T_VALUETYPE:
 294     fatal(&quot;Should not be handled with this method&quot;);
 295     break;
 296   default:
 297     fatal(&quot;Unsupported BasicType&quot;);
 298   }
 299 }
 300 
 301 JRT_ENTRY(void, InterpreterRuntime::defaultvalue(JavaThread* thread, ConstantPool* pool, int index))
 302   // Getting the ValueKlass
 303   Klass* k = pool-&gt;klass_at(index, CHECK);
<span class="line-modified"> 304   if (!k-&gt;is_inline_klass()) {</span>
 305     // inconsistency with &#39;new&#39; which throws an InstantiationError
 306     // in the future, defaultvalue will just return null instead of throwing an exception
 307     THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
 308   }
<span class="line-modified"> 309   assert(k-&gt;is_inline_klass(), &quot;defaultvalue argument must be the inline type class&quot;);</span>
 310   ValueKlass* vklass = ValueKlass::cast(k);
 311 
 312   vklass-&gt;initialize(THREAD);
 313   oop res = vklass-&gt;default_value();
 314   thread-&gt;set_vm_result(res);
 315 JRT_END
 316 
 317 JRT_ENTRY(int, InterpreterRuntime::withfield(JavaThread* thread, ConstantPoolCache* cp_cache))
 318   LastFrameAccessor last_frame(thread);
 319   // Getting the ValueKlass
 320   int index = ConstantPool::decode_cpcache_index(last_frame.get_index_u2_cpcache(Bytecodes::_withfield));
 321   ConstantPoolCacheEntry* cp_entry = cp_cache-&gt;entry_at(index);
 322   assert(cp_entry-&gt;is_resolved(Bytecodes::_withfield), &quot;Should have been resolved&quot;);
 323   Klass* klass = cp_entry-&gt;f1_as_klass();
<span class="line-modified"> 324   assert(klass-&gt;is_inline_klass(), &quot;withfield only applies to inline types&quot;);</span>
 325   ValueKlass* vklass = ValueKlass::cast(klass);
 326 
 327   // Getting Field information
 328   int offset = cp_entry-&gt;f2_as_index();
 329   int field_index = cp_entry-&gt;field_index();
 330   int field_offset = cp_entry-&gt;f2_as_offset();
 331   Symbol* field_signature = vklass-&gt;field_signature(field_index);
 332   BasicType field_type = Signature::basic_type(field_signature);
 333   int return_offset = (type2size[field_type] + type2size[T_OBJECT]) * AbstractInterpreter::stackElementSize;
 334 
 335   // Getting old value
 336   frame&amp; f = last_frame.get_frame();
 337   jint tos_idx = f.interpreter_frame_expression_stack_size() - 1;
 338   int vt_offset = type2size[field_type];
 339   oop old_value = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx - vt_offset);
<span class="line-modified"> 340   assert(old_value != NULL &amp;&amp; oopDesc::is_oop(old_value) &amp;&amp; old_value-&gt;is_inline_type(),&quot;Verifying receiver&quot;);</span>
 341   Handle old_value_h(THREAD, old_value);
 342 
 343   // Creating new value by copying the one passed in argument
 344   instanceOop new_value = vklass-&gt;allocate_instance(
 345       CHECK_((type2size[field_type]) * AbstractInterpreter::stackElementSize));
 346   Handle new_value_h = Handle(THREAD, new_value);
 347   vklass-&gt;value_copy_oop_to_new_oop(old_value_h(), new_value_h());
 348 
 349   // Updating the field specified in arguments
 350   if (field_type == T_ARRAY || field_type == T_OBJECT) {
 351     oop aoop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
 352     assert(aoop == NULL || oopDesc::is_oop(aoop),&quot;argument must be a reference type&quot;);
 353     new_value_h()-&gt;obj_field_put(field_offset, aoop);
 354   } else if (field_type == T_VALUETYPE) {
 355     if (cp_entry-&gt;is_inlined()) {
 356       oop vt_oop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
<span class="line-modified"> 357       assert(vt_oop != NULL &amp;&amp; oopDesc::is_oop(vt_oop) &amp;&amp; vt_oop-&gt;is_inline_type(),&quot;argument must be an inline type&quot;);</span>
 358       ValueKlass* field_vk = ValueKlass::cast(vklass-&gt;get_value_field_klass(field_index));
 359       assert(vt_oop != NULL &amp;&amp; field_vk == vt_oop-&gt;klass(), &quot;Must match&quot;);
 360       field_vk-&gt;write_inlined_field(new_value_h(), offset, vt_oop, CHECK_(return_offset));
 361     } else { // not inlined
 362       oop voop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
 363       if (voop == NULL &amp;&amp; cp_entry-&gt;is_inline_type()) {
 364         THROW_(vmSymbols::java_lang_NullPointerException(), return_offset);
 365       }
 366       assert(voop == NULL || oopDesc::is_oop(voop),&quot;checking argument&quot;);
 367       new_value_h()-&gt;obj_field_put(field_offset, voop);
 368     }
 369   } else { // not T_OBJECT nor T_ARRAY nor T_VALUETYPE
 370     intptr_t* addr = f.interpreter_frame_expression_stack_at(tos_idx);
 371     copy_primitive_argument(addr, new_value_h, field_offset, field_type);
 372   }
 373 
 374   // returning result
 375   thread-&gt;set_vm_result(new_value_h());
 376   return return_offset;
 377 JRT_END
</pre>
<hr />
<pre>
 909                &quot;Class %s does not implement the requested interface %s&quot;,
 910                recvKlass ? recvKlass-&gt;external_name() : &quot;NULL&quot;,
 911                interfaceKlass ? interfaceKlass-&gt;external_name() : &quot;NULL&quot;);
 912   THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 913 JRT_END
 914 
 915 //------------------------------------------------------------------------------------------------------------------------
 916 // Fields
 917 //
 918 
 919 void InterpreterRuntime::resolve_get_put(JavaThread* thread, Bytecodes::Code bytecode) {
 920   Thread* THREAD = thread;
 921   // resolve field
 922   fieldDescriptor info;
 923   LastFrameAccessor last_frame(thread);
 924   constantPoolHandle pool(thread, last_frame.method()-&gt;constants());
 925   methodHandle m(thread, last_frame.method());
 926   bool is_put    = (bytecode == Bytecodes::_putfield  || bytecode == Bytecodes::_nofast_putfield ||
 927                     bytecode == Bytecodes::_putstatic || bytecode == Bytecodes::_withfield);
 928   bool is_static = (bytecode == Bytecodes::_getstatic || bytecode == Bytecodes::_putstatic);
<span class="line-modified"> 929   bool is_inline_type  = bytecode == Bytecodes::_withfield;</span>
 930 
 931   {
 932     JvmtiHideSingleStepping jhss(thread);
 933     LinkResolver::resolve_field_access(info, pool, last_frame.get_index_u2_cpcache(bytecode),
 934                                        m, bytecode, CHECK);
 935   } // end JvmtiHideSingleStepping
 936 
 937   // check if link resolution caused cpCache to be updated
 938   ConstantPoolCacheEntry* cp_cache_entry = last_frame.cache_entry();
 939   if (cp_cache_entry-&gt;is_resolved(bytecode)) return;
 940 
 941   // compute auxiliary field attributes
 942   TosState state  = as_TosState(info.field_type());
 943 
 944   // Resolution of put instructions on final fields is delayed. That is required so that
 945   // exceptions are thrown at the correct place (when the instruction is actually invoked).
 946   // If we do not resolve an instruction in the current pass, leaving the put_code
 947   // set to zero will cause the next put instruction to the same field to reresolve.
 948 
 949   // Resolution of put instructions to final instance fields with invalid updates (i.e.,
</pre>
<hr />
<pre>
 958   // and the required IllegalAccessError would not be thrown.
 959   //
 960   // Also, we need to delay resolving getstatic and putstatic instructions until the
 961   // class is initialized.  This is required so that access to the static
 962   // field will call the initialization function every time until the class
 963   // is completely initialized ala. in 2.17.5 in JVM Specification.
 964   InstanceKlass* klass = info.field_holder();
 965   bool uninitialized_static = is_static &amp;&amp; !klass-&gt;is_initialized();
 966   bool has_initialized_final_update = info.field_holder()-&gt;major_version() &gt;= 53 &amp;&amp;
 967                                       info.has_initialized_final_update();
 968   assert(!(has_initialized_final_update &amp;&amp; !info.access_flags().is_final()), &quot;Fields with initialized final updates must be final&quot;);
 969 
 970   Bytecodes::Code get_code = (Bytecodes::Code)0;
 971   Bytecodes::Code put_code = (Bytecodes::Code)0;
 972   if (!uninitialized_static) {
 973     if (is_static) {
 974       get_code = Bytecodes::_getstatic;
 975     } else {
 976       get_code = Bytecodes::_getfield;
 977     }
<span class="line-modified"> 978     if (is_put &amp;&amp; is_inline_type) {</span>
 979         put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_withfield);
 980     } else if ((is_put &amp;&amp; !has_initialized_final_update) || !info.access_flags().is_final()) {
 981         put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_putfield);
 982     }
 983   }
 984 
 985   cp_cache_entry-&gt;set_field(
 986     get_code,
 987     put_code,
 988     info.field_holder(),
 989     info.index(),
 990     info.offset(),
 991     state,
 992     info.access_flags().is_final(),
 993     info.access_flags().is_volatile(),
 994     info.is_inlined(),
 995     info.is_inline_type(),
 996     pool-&gt;pool_holder()
 997   );
 998 }
</pre>
</td>
</tr>
</table>
<center><a href="../classfile/verifier.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="linkResolver.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
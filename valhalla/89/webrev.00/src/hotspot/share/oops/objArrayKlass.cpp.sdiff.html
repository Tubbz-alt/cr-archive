<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/objArrayKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="klass.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oop.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/objArrayKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
119   return oak;
120 }
121 
122 ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {
123   set_dimension(n);
124   set_element_klass(element_klass);
125 
126   Klass* bk;
127   if (element_klass-&gt;is_objArray_klass()) {
128     bk = ObjArrayKlass::cast(element_klass)-&gt;bottom_klass();
129   } else if (element_klass-&gt;is_valueArray_klass()) {
130     bk = ValueArrayKlass::cast(element_klass)-&gt;element_klass();
131   } else {
132     bk = element_klass;
133   }
134   assert(bk != NULL &amp;&amp; (bk-&gt;is_instance_klass() || bk-&gt;is_typeArray_klass()), &quot;invalid bottom klass&quot;);
135   set_bottom_klass(bk);
136   set_class_loader_data(bk-&gt;class_loader_data());
137 
138   jint lh = array_layout_helper(T_OBJECT);
<span class="line-modified">139   if (element_klass-&gt;is_value()) {</span>
140     lh = layout_helper_set_null_free(lh);
141   }
142   set_layout_helper(lh);
143   assert(is_array_klass(), &quot;sanity&quot;);
144   assert(is_objArray_klass(), &quot;sanity&quot;);
145 }
146 
147 int ObjArrayKlass::oop_size(oop obj) const {
148   assert(obj-&gt;is_objArray(), &quot;must be object array&quot;);
149   return objArrayOop(obj)-&gt;object_size();
150 }
151 
152 objArrayOop ObjArrayKlass::allocate(int length, TRAPS) {
153   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);
154   int size = objArrayOopDesc::object_size(length);
155   bool populate_null_free = is_null_free_array_klass();
156   objArrayOop array =  (objArrayOop)Universe::heap()-&gt;array_allocate(this, size, length,
157                                                        /* do_zero */ true, THREAD);
158   if (populate_null_free) {
159     assert(dimension() == 1, &quot;Can only populate the final dimension&quot;);
<span class="line-modified">160     assert(element_klass()-&gt;is_value(), &quot;Unexpected&quot;);</span>
161     assert(!element_klass()-&gt;is_array_klass(), &quot;ArrayKlass unexpected here&quot;);
162     assert(!ValueKlass::cast(element_klass())-&gt;flatten_array(), &quot;Expected valueArrayOop allocation&quot;);
163     element_klass()-&gt;initialize(CHECK_NULL);
164     // Populate default values...
165     objArrayHandle array_h(THREAD, array);
166     instanceOop value = (instanceOop) ValueKlass::cast(element_klass())-&gt;default_value();
167     for (int i = 0; i &lt; length; i++) {
168       array_h-&gt;obj_at_put(i, value);
169     }
170   }
171   return array;
172 }
173 
174 oop ObjArrayKlass::multi_allocate(int rank, jint* sizes, TRAPS) {
175   int length = *sizes;
176   if (rank == 1) { // last dim may be valueArray, check if we have any special storage requirements
<span class="line-modified">177     if (element_klass()-&gt;is_value()) {</span>
178       return oopFactory::new_valueArray(element_klass(), length, CHECK_NULL);
179     } else {
180       return oopFactory::new_objArray(element_klass(), length, CHECK_NULL);
181     }
182   }
183   guarantee(rank &gt; 1, &quot;Rank below 1&quot;);
184   // Call to lower_dimension uses this pointer, so most be called before a
185   // possible GC
186   Klass* ld_klass = lower_dimension();
187   // If length &lt; 0 allocate will throw an exception.
188   objArrayOop array = allocate(length, CHECK_NULL);
189   objArrayHandle h_array (THREAD, array);
190   if (length != 0) {
191     for (int index = 0; index &lt; length; index++) {
192       ArrayKlass* ak = ArrayKlass::cast(ld_klass);
193       oop sub_array = ak-&gt;multi_allocate(rank-1, &amp;sizes[1], CHECK_NULL);
194       h_array-&gt;obj_at_put(index, sub_array);
195     }
196   } else {
197     // Since this array dimension has zero length, nothing will be
</pre>
</td>
<td>
<hr />
<pre>
119   return oak;
120 }
121 
122 ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {
123   set_dimension(n);
124   set_element_klass(element_klass);
125 
126   Klass* bk;
127   if (element_klass-&gt;is_objArray_klass()) {
128     bk = ObjArrayKlass::cast(element_klass)-&gt;bottom_klass();
129   } else if (element_klass-&gt;is_valueArray_klass()) {
130     bk = ValueArrayKlass::cast(element_klass)-&gt;element_klass();
131   } else {
132     bk = element_klass;
133   }
134   assert(bk != NULL &amp;&amp; (bk-&gt;is_instance_klass() || bk-&gt;is_typeArray_klass()), &quot;invalid bottom klass&quot;);
135   set_bottom_klass(bk);
136   set_class_loader_data(bk-&gt;class_loader_data());
137 
138   jint lh = array_layout_helper(T_OBJECT);
<span class="line-modified">139   if (element_klass-&gt;is_inline_klass()) {</span>
140     lh = layout_helper_set_null_free(lh);
141   }
142   set_layout_helper(lh);
143   assert(is_array_klass(), &quot;sanity&quot;);
144   assert(is_objArray_klass(), &quot;sanity&quot;);
145 }
146 
147 int ObjArrayKlass::oop_size(oop obj) const {
148   assert(obj-&gt;is_objArray(), &quot;must be object array&quot;);
149   return objArrayOop(obj)-&gt;object_size();
150 }
151 
152 objArrayOop ObjArrayKlass::allocate(int length, TRAPS) {
153   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);
154   int size = objArrayOopDesc::object_size(length);
155   bool populate_null_free = is_null_free_array_klass();
156   objArrayOop array =  (objArrayOop)Universe::heap()-&gt;array_allocate(this, size, length,
157                                                        /* do_zero */ true, THREAD);
158   if (populate_null_free) {
159     assert(dimension() == 1, &quot;Can only populate the final dimension&quot;);
<span class="line-modified">160     assert(element_klass()-&gt;is_inline_klass(), &quot;Unexpected&quot;);</span>
161     assert(!element_klass()-&gt;is_array_klass(), &quot;ArrayKlass unexpected here&quot;);
162     assert(!ValueKlass::cast(element_klass())-&gt;flatten_array(), &quot;Expected valueArrayOop allocation&quot;);
163     element_klass()-&gt;initialize(CHECK_NULL);
164     // Populate default values...
165     objArrayHandle array_h(THREAD, array);
166     instanceOop value = (instanceOop) ValueKlass::cast(element_klass())-&gt;default_value();
167     for (int i = 0; i &lt; length; i++) {
168       array_h-&gt;obj_at_put(i, value);
169     }
170   }
171   return array;
172 }
173 
174 oop ObjArrayKlass::multi_allocate(int rank, jint* sizes, TRAPS) {
175   int length = *sizes;
176   if (rank == 1) { // last dim may be valueArray, check if we have any special storage requirements
<span class="line-modified">177     if (element_klass()-&gt;is_inline_klass()) {</span>
178       return oopFactory::new_valueArray(element_klass(), length, CHECK_NULL);
179     } else {
180       return oopFactory::new_objArray(element_klass(), length, CHECK_NULL);
181     }
182   }
183   guarantee(rank &gt; 1, &quot;Rank below 1&quot;);
184   // Call to lower_dimension uses this pointer, so most be called before a
185   // possible GC
186   Klass* ld_klass = lower_dimension();
187   // If length &lt; 0 allocate will throw an exception.
188   objArrayOop array = allocate(length, CHECK_NULL);
189   objArrayHandle h_array (THREAD, array);
190   if (length != 0) {
191     for (int index = 0; index &lt; length; index++) {
192       ArrayKlass* ak = ArrayKlass::cast(ld_klass);
193       oop sub_array = ak-&gt;multi_allocate(rank-1, &amp;sizes[1], CHECK_NULL);
194       h_array-&gt;obj_at_put(index, sub_array);
195     }
196   } else {
197     // Since this array dimension has zero length, nothing will be
</pre>
</td>
</tr>
</table>
<center><a href="klass.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oop.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/oops/generateOopMap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;interpreter/bytecodeStream.hpp&quot;
  27 #include &quot;logging/log.hpp&quot;
  28 #include &quot;logging/logStream.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;oops/constantPool.hpp&quot;
  31 #include &quot;oops/generateOopMap.hpp&quot;
  32 #include &quot;oops/oop.inline.hpp&quot;
  33 #include &quot;oops/symbol.hpp&quot;
  34 #include &quot;runtime/handles.inline.hpp&quot;
  35 #include &quot;runtime/java.hpp&quot;
  36 #include &quot;runtime/os.hpp&quot;
  37 #include &quot;runtime/relocator.hpp&quot;
  38 #include &quot;runtime/timerTrace.hpp&quot;
  39 #include &quot;utilities/bitMap.inline.hpp&quot;
  40 #include &quot;utilities/ostream.hpp&quot;
  41 
  42 //
  43 //
  44 // Compute stack layouts for each instruction in method.
  45 //
  46 //  Problems:
  47 //  - What to do about jsr with different types of local vars?
  48 //  Need maps that are conditional on jsr path?
  49 //  - Jsr and exceptions should be done more efficiently (the retAddr stuff)
  50 //
  51 //  Alternative:
  52 //  - Could extend verifier to provide this information.
  53 //    For: one fewer abstract interpreter to maintain. Against: the verifier
  54 //    solves a bigger problem so slower (undesirable to force verification of
  55 //    everything?).
  56 //
  57 //  Algorithm:
  58 //    Partition bytecodes into basic blocks
  59 //    For each basic block: store entry state (vars, stack). For instructions
  60 //    inside basic blocks we do not store any state (instead we recompute it
  61 //    from state produced by previous instruction).
  62 //
  63 //    Perform abstract interpretation of bytecodes over this lattice:
  64 //
  65 //                _--&#39;#&#39;--_
  66 //               /  /  \   \
  67 //             /   /     \   \
  68 //            /    |     |     \
  69 //          &#39;r&#39;   &#39;v&#39;   &#39;p&#39;   &#39; &#39;
  70 //           \     |     |     /
  71 //            \    \     /    /
  72 //              \   \   /    /
  73 //                -- &#39;@&#39; --
  74 //
  75 //    &#39;#&#39;  top, result of conflict merge
  76 //    &#39;r&#39;  reference type
  77 //    &#39;v&#39;  value type
  78 //    &#39;p&#39;  pc type for jsr/ret
  79 //    &#39; &#39;  uninitialized; never occurs on operand stack in Java
  80 //    &#39;@&#39;  bottom/unexecuted; initial state each bytecode.
  81 //
  82 //    Basic block headers are the only merge points. We use this iteration to
  83 //    compute the information:
  84 //
  85 //    find basic blocks;
  86 //    initialize them with uninitialized state;
  87 //    initialize first BB according to method signature;
  88 //    mark first BB changed
  89 //    while (some BB is changed) do {
  90 //      perform abstract interpration of all bytecodes in BB;
  91 //      merge exit state of BB into entry state of all successor BBs,
  92 //      noting if any of these change;
  93 //    }
  94 //
  95 //  One additional complication is necessary. The jsr instruction pushes
  96 //  a return PC on the stack (a &#39;p&#39; type in the abstract interpretation).
  97 //  To be able to process &quot;ret&quot; bytecodes, we keep track of these return
  98 //  PC&#39;s in a &#39;retAddrs&#39; structure in abstract interpreter context (when
  99 //  processing a &quot;ret&quot; bytecodes, it is not sufficient to know that it gets
 100 //  an argument of the right type &#39;p&#39;; we need to know which address it
 101 //  returns to).
 102 //
 103 // (Note this comment is borrowed form the original author of the algorithm)
 104 
 105 // ComputeCallStack
 106 //
 107 // Specialization of SignatureIterator - compute the effects of a call
 108 //
 109 class ComputeCallStack : public SignatureIterator {
 110   CellTypeState *_effect;
 111   int _idx;
 112 
 113   void setup();
 114   void set(CellTypeState state)         { _effect[_idx++] = state; }
 115   int  length()                         { return _idx; };
 116 
 117   friend class SignatureIterator;  // so do_parameters_on can call do_type
 118   void do_type(BasicType type, bool for_return = false) {
 119     if (for_return &amp;&amp; type == T_VOID) {
 120       set(CellTypeState::bottom);
 121     } else if (is_reference_type(type)) {
 122       set(CellTypeState::ref);
 123     } else {
 124       assert(is_java_primitive(type), &quot;&quot;);
 125       set(CellTypeState::value);
 126       if (is_double_word_type(type)) {
 127         set(CellTypeState::value);
 128       }
 129     }
 130   }
 131 
 132  public:
 133   ComputeCallStack(Symbol* signature) : SignatureIterator(signature) {};
 134 
 135   // Compute methods
 136   int compute_for_parameters(bool is_static, CellTypeState *effect) {
 137     _idx    = 0;
 138     _effect = effect;
 139 
 140     if (!is_static) {
 141       effect[_idx++] = CellTypeState::ref;
 142     }
 143 
 144     do_parameters_on(this);
 145 
 146     return length();
 147   };
 148 
 149   int compute_for_returntype(CellTypeState *effect) {
 150     _idx    = 0;
 151     _effect = effect;
 152     do_type(return_type(), true);
 153     set(CellTypeState::bottom);  // Always terminate with a bottom state, so ppush works
 154 
 155     return length();
 156   }
 157 };
 158 
 159 //=========================================================================================
 160 // ComputeEntryStack
 161 //
 162 // Specialization of SignatureIterator - in order to set up first stack frame
 163 //
 164 class ComputeEntryStack : public SignatureIterator {
 165   CellTypeState *_effect;
 166   int _idx;
 167 
 168   void setup();
 169   void set(CellTypeState state)         { _effect[_idx++] = state; }
 170   int  length()                         { return _idx; };
 171 
 172   friend class SignatureIterator;  // so do_parameters_on can call do_type
 173   void do_type(BasicType type, bool for_return = false) {
 174     if (for_return &amp;&amp; type == T_VOID) {
 175       set(CellTypeState::bottom);
 176     } else if (is_reference_type(type)) {
 177       set(CellTypeState::make_slot_ref(_idx));
 178     } else {
 179       assert(is_java_primitive(type), &quot;&quot;);
 180       set(CellTypeState::value);
 181       if (is_double_word_type(type)) {
 182         set(CellTypeState::value);
 183       }
 184     }
 185   }
 186 
 187  public:
 188   ComputeEntryStack(Symbol* signature) : SignatureIterator(signature) {};
 189 
 190   // Compute methods
 191   int compute_for_parameters(bool is_static, CellTypeState *effect) {
 192     _idx    = 0;
 193     _effect = effect;
 194 
 195     if (!is_static)
 196       effect[_idx++] = CellTypeState::make_slot_ref(0);
 197 
 198     do_parameters_on(this);
 199 
 200     return length();
 201   };
 202 
 203   int compute_for_returntype(CellTypeState *effect) {
 204     _idx    = 0;
 205     _effect = effect;
 206     do_type(return_type(), true);
 207     set(CellTypeState::bottom);  // Always terminate with a bottom state, so ppush works
 208 
 209     return length();
 210   }
 211 };
 212 
 213 //=====================================================================================
 214 //
 215 // Implementation of RetTable/RetTableEntry
 216 //
 217 // Contains function to itereate through all bytecodes
 218 // and find all return entry points
 219 //
 220 int RetTable::_init_nof_entries = 10;
 221 int RetTableEntry::_init_nof_jsrs = 5;
 222 
 223 RetTableEntry::RetTableEntry(int target, RetTableEntry *next) {
 224   _target_bci = target;
 225   _jsrs = new GrowableArray&lt;intptr_t&gt;(_init_nof_jsrs);
 226   _next = next;
 227 }
 228 
 229 void RetTableEntry::add_delta(int bci, int delta) {
 230   if (_target_bci &gt; bci) _target_bci += delta;
 231 
 232   for (int k = 0; k &lt; _jsrs-&gt;length(); k++) {
 233     int jsr = _jsrs-&gt;at(k);
 234     if (jsr &gt; bci) _jsrs-&gt;at_put(k, jsr+delta);
 235   }
 236 }
 237 
 238 void RetTable::compute_ret_table(const methodHandle&amp; method) {
 239   BytecodeStream i(method);
 240   Bytecodes::Code bytecode;
 241 
 242   while( (bytecode = i.next()) &gt;= 0) {
 243     switch (bytecode) {
 244       case Bytecodes::_jsr:
 245         add_jsr(i.next_bci(), i.dest());
 246         break;
 247       case Bytecodes::_jsr_w:
 248         add_jsr(i.next_bci(), i.dest_w());
 249         break;
 250       default:
 251         break;
 252     }
 253   }
 254 }
 255 
 256 void RetTable::add_jsr(int return_bci, int target_bci) {
 257   RetTableEntry* entry = _first;
 258 
 259   // Scan table for entry
 260   for (;entry &amp;&amp; entry-&gt;target_bci() != target_bci; entry = entry-&gt;next());
 261 
 262   if (!entry) {
 263     // Allocate new entry and put in list
 264     entry = new RetTableEntry(target_bci, _first);
 265     _first = entry;
 266   }
 267 
 268   // Now &quot;entry&quot; is set.  Make sure that the entry is initialized
 269   // and has room for the new jsr.
 270   entry-&gt;add_jsr(return_bci);
 271 }
 272 
 273 RetTableEntry* RetTable::find_jsrs_for_target(int targBci) {
 274   RetTableEntry *cur = _first;
 275 
 276   while(cur) {
 277     assert(cur-&gt;target_bci() != -1, &quot;sanity check&quot;);
 278     if (cur-&gt;target_bci() == targBci)  return cur;
 279     cur = cur-&gt;next();
 280   }
 281   ShouldNotReachHere();
 282   return NULL;
 283 }
 284 
 285 // The instruction at bci is changing size by &quot;delta&quot;.  Update the return map.
 286 void RetTable::update_ret_table(int bci, int delta) {
 287   RetTableEntry *cur = _first;
 288   while(cur) {
 289     cur-&gt;add_delta(bci, delta);
 290     cur = cur-&gt;next();
 291   }
 292 }
 293 
 294 //
 295 // Celltype state
 296 //
 297 
 298 CellTypeState CellTypeState::bottom      = CellTypeState::make_bottom();
 299 CellTypeState CellTypeState::uninit      = CellTypeState::make_any(uninit_value);
 300 CellTypeState CellTypeState::ref         = CellTypeState::make_any(ref_conflict);
 301 CellTypeState CellTypeState::value       = CellTypeState::make_any(val_value);
 302 CellTypeState CellTypeState::refUninit   = CellTypeState::make_any(ref_conflict | uninit_value);
 303 CellTypeState CellTypeState::top         = CellTypeState::make_top();
 304 CellTypeState CellTypeState::addr        = CellTypeState::make_any(addr_conflict);
 305 
 306 // Commonly used constants
 307 static CellTypeState epsilonCTS[1] = { CellTypeState::bottom };
 308 static CellTypeState   refCTS   = CellTypeState::ref;
 309 static CellTypeState   valCTS   = CellTypeState::value;
 310 static CellTypeState    vCTS[2] = { CellTypeState::value, CellTypeState::bottom };
 311 static CellTypeState    rCTS[2] = { CellTypeState::ref,   CellTypeState::bottom };
 312 static CellTypeState   rrCTS[3] = { CellTypeState::ref,   CellTypeState::ref,   CellTypeState::bottom };
 313 static CellTypeState   vrCTS[3] = { CellTypeState::value, CellTypeState::ref,   CellTypeState::bottom };
 314 static CellTypeState   vvCTS[3] = { CellTypeState::value, CellTypeState::value, CellTypeState::bottom };
 315 static CellTypeState  rvrCTS[4] = { CellTypeState::ref,   CellTypeState::value, CellTypeState::ref,   CellTypeState::bottom };
 316 static CellTypeState  vvrCTS[4] = { CellTypeState::value, CellTypeState::value, CellTypeState::ref,   CellTypeState::bottom };
 317 static CellTypeState  vvvCTS[4] = { CellTypeState::value, CellTypeState::value, CellTypeState::value, CellTypeState::bottom };
 318 static CellTypeState vvvrCTS[5] = { CellTypeState::value, CellTypeState::value, CellTypeState::value, CellTypeState::ref,   CellTypeState::bottom };
 319 static CellTypeState vvvvCTS[5] = { CellTypeState::value, CellTypeState::value, CellTypeState::value, CellTypeState::value, CellTypeState::bottom };
 320 
 321 char CellTypeState::to_char() const {
 322   if (can_be_reference()) {
 323     if (can_be_value() || can_be_address())
 324       return &#39;#&#39;;    // Conflict that needs to be rewritten
 325     else
 326       return &#39;r&#39;;
 327   } else if (can_be_value())
 328     return &#39;v&#39;;
 329   else if (can_be_address())
 330     return &#39;p&#39;;
 331   else if (can_be_uninit())
 332     return &#39; &#39;;
 333   else
 334     return &#39;@&#39;;
 335 }
 336 
 337 
 338 // Print a detailed CellTypeState.  Indicate all bits that are set.  If
 339 // the CellTypeState represents an address or a reference, print the
 340 // value of the additional information.
 341 void CellTypeState::print(outputStream *os) {
 342   if (can_be_address()) {
 343     os-&gt;print(&quot;(p&quot;);
 344   } else {
 345     os-&gt;print(&quot;( &quot;);
 346   }
 347   if (can_be_reference()) {
 348     os-&gt;print(&quot;r&quot;);
 349   } else {
 350     os-&gt;print(&quot; &quot;);
 351   }
 352   if (can_be_value()) {
 353     os-&gt;print(&quot;v&quot;);
 354   } else {
 355     os-&gt;print(&quot; &quot;);
 356   }
 357   if (can_be_uninit()) {
 358     os-&gt;print(&quot;u|&quot;);
 359   } else {
 360     os-&gt;print(&quot; |&quot;);
 361   }
 362   if (is_info_top()) {
 363     os-&gt;print(&quot;Top)&quot;);
 364   } else if (is_info_bottom()) {
 365     os-&gt;print(&quot;Bot)&quot;);
 366   } else {
 367     if (is_reference()) {
 368       int info = get_info();
 369       int data = info &amp; ~(ref_not_lock_bit | ref_slot_bit);
 370       if (info &amp; ref_not_lock_bit) {
 371         // Not a monitor lock reference.
 372         if (info &amp; ref_slot_bit) {
 373           // slot
 374           os-&gt;print(&quot;slot%d)&quot;, data);
 375         } else {
 376           // line
 377           os-&gt;print(&quot;line%d)&quot;, data);
 378         }
 379       } else {
 380         // lock
 381         os-&gt;print(&quot;lock%d)&quot;, data);
 382       }
 383     } else {
 384       os-&gt;print(&quot;%d)&quot;, get_info());
 385     }
 386   }
 387 }
 388 
 389 //
 390 // Basicblock handling methods
 391 //
 392 
 393 void GenerateOopMap::initialize_bb() {
 394   _gc_points = 0;
 395   _bb_count  = 0;
 396   _bb_hdr_bits.reinitialize(method()-&gt;code_size());
 397 }
 398 
 399 void GenerateOopMap::bb_mark_fct(GenerateOopMap *c, int bci, int *data) {
 400   assert(bci&gt;= 0 &amp;&amp; bci &lt; c-&gt;method()-&gt;code_size(), &quot;index out of bounds&quot;);
 401   if (c-&gt;is_bb_header(bci))
 402      return;
 403 
 404   if (TraceNewOopMapGeneration) {
 405      tty-&gt;print_cr(&quot;Basicblock#%d begins at: %d&quot;, c-&gt;_bb_count, bci);
 406   }
 407   c-&gt;set_bbmark_bit(bci);
 408   c-&gt;_bb_count++;
 409 }
 410 
 411 
 412 void GenerateOopMap::mark_bbheaders_and_count_gc_points() {
 413   initialize_bb();
 414 
 415   bool fellThrough = false;  // False to get first BB marked.
 416 
 417   // First mark all exception handlers as start of a basic-block
 418   ExceptionTable excps(method());
 419   for(int i = 0; i &lt; excps.length(); i ++) {
 420     bb_mark_fct(this, excps.handler_pc(i), NULL);
 421   }
 422 
 423   // Then iterate through the code
 424   BytecodeStream bcs(_method);
 425   Bytecodes::Code bytecode;
 426 
 427   while( (bytecode = bcs.next()) &gt;= 0) {
 428     int bci = bcs.bci();
 429 
 430     if (!fellThrough)
 431         bb_mark_fct(this, bci, NULL);
 432 
 433     fellThrough = jump_targets_do(&amp;bcs, &amp;GenerateOopMap::bb_mark_fct, NULL);
 434 
 435      /* We will also mark successors of jsr&#39;s as basic block headers. */
 436     switch (bytecode) {
 437       case Bytecodes::_jsr:
 438         assert(!fellThrough, &quot;should not happen&quot;);
 439         bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), NULL);
 440         break;
 441       case Bytecodes::_jsr_w:
 442         assert(!fellThrough, &quot;should not happen&quot;);
 443         bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), NULL);
 444         break;
 445       default:
 446         break;
 447     }
 448 
 449     if (possible_gc_point(&amp;bcs))
 450       _gc_points++;
 451   }
 452 }
 453 
 454 void GenerateOopMap::set_bbmark_bit(int bci) {
 455   _bb_hdr_bits.at_put(bci, true);
 456 }
 457 
 458 void GenerateOopMap::reachable_basicblock(GenerateOopMap *c, int bci, int *data) {
 459   assert(bci&gt;= 0 &amp;&amp; bci &lt; c-&gt;method()-&gt;code_size(), &quot;index out of bounds&quot;);
 460   BasicBlock* bb = c-&gt;get_basic_block_at(bci);
 461   if (bb-&gt;is_dead()) {
 462     bb-&gt;mark_as_alive();
 463     *data = 1; // Mark basicblock as changed
 464   }
 465 }
 466 
 467 
 468 void GenerateOopMap::mark_reachable_code() {
 469   int change = 1; // int to get function pointers to work
 470 
 471   // Mark entry basic block as alive and all exception handlers
 472   _basic_blocks[0].mark_as_alive();
 473   ExceptionTable excps(method());
 474   for(int i = 0; i &lt; excps.length(); i++) {
 475     BasicBlock *bb = get_basic_block_at(excps.handler_pc(i));
 476     // If block is not already alive (due to multiple exception handlers to same bb), then
 477     // make it alive
 478     if (bb-&gt;is_dead()) bb-&gt;mark_as_alive();
 479   }
 480 
 481   BytecodeStream bcs(_method);
 482 
 483   // Iterate through all basic blocks until we reach a fixpoint
 484   while (change) {
 485     change = 0;
 486 
 487     for (int i = 0; i &lt; _bb_count; i++) {
 488       BasicBlock *bb = &amp;_basic_blocks[i];
 489       if (bb-&gt;is_alive()) {
 490         // Position bytecodestream at last bytecode in basicblock
 491         bcs.set_start(bb-&gt;_end_bci);
 492         bcs.next();
 493         Bytecodes::Code bytecode = bcs.code();
 494         int bci = bcs.bci();
 495         assert(bci == bb-&gt;_end_bci, &quot;wrong bci&quot;);
 496 
 497         bool fell_through = jump_targets_do(&amp;bcs, &amp;GenerateOopMap::reachable_basicblock, &amp;change);
 498 
 499         // We will also mark successors of jsr&#39;s as alive.
 500         switch (bytecode) {
 501           case Bytecodes::_jsr:
 502           case Bytecodes::_jsr_w:
 503             assert(!fell_through, &quot;should not happen&quot;);
 504             reachable_basicblock(this, bci + Bytecodes::length_for(bytecode), &amp;change);
 505             break;
 506           default:
 507             break;
 508         }
 509         if (fell_through) {
 510           // Mark successor as alive
 511           if (bb[1].is_dead()) {
 512             bb[1].mark_as_alive();
 513             change = 1;
 514           }
 515         }
 516       }
 517     }
 518   }
 519 }
 520 
 521 /* If the current instruction in &quot;c&quot; has no effect on control flow,
 522    returns &quot;true&quot;.  Otherwise, calls &quot;jmpFct&quot; one or more times, with
 523    &quot;c&quot;, an appropriate &quot;pcDelta&quot;, and &quot;data&quot; as arguments, then
 524    returns &quot;false&quot;.  There is one exception: if the current
 525    instruction is a &quot;ret&quot;, returns &quot;false&quot; without calling &quot;jmpFct&quot;.
 526    Arrangements for tracking the control flow of a &quot;ret&quot; must be made
 527    externally. */
 528 bool GenerateOopMap::jump_targets_do(BytecodeStream *bcs, jmpFct_t jmpFct, int *data) {
 529   int bci = bcs-&gt;bci();
 530 
 531   switch (bcs-&gt;code()) {
 532     case Bytecodes::_ifeq:
 533     case Bytecodes::_ifne:
 534     case Bytecodes::_iflt:
 535     case Bytecodes::_ifge:
 536     case Bytecodes::_ifgt:
 537     case Bytecodes::_ifle:
 538     case Bytecodes::_if_icmpeq:
 539     case Bytecodes::_if_icmpne:
 540     case Bytecodes::_if_icmplt:
 541     case Bytecodes::_if_icmpge:
 542     case Bytecodes::_if_icmpgt:
 543     case Bytecodes::_if_icmple:
 544     case Bytecodes::_if_acmpeq:
 545     case Bytecodes::_if_acmpne:
 546     case Bytecodes::_ifnull:
 547     case Bytecodes::_ifnonnull:
 548       (*jmpFct)(this, bcs-&gt;dest(), data);
 549       (*jmpFct)(this, bci + 3, data);
 550       break;
 551 
 552     case Bytecodes::_goto:
 553       (*jmpFct)(this, bcs-&gt;dest(), data);
 554       break;
 555     case Bytecodes::_goto_w:
 556       (*jmpFct)(this, bcs-&gt;dest_w(), data);
 557       break;
 558     case Bytecodes::_tableswitch:
 559       { Bytecode_tableswitch tableswitch(method(), bcs-&gt;bcp());
 560         int len = tableswitch.length();
 561 
 562         (*jmpFct)(this, bci + tableswitch.default_offset(), data); /* Default. jump address */
 563         while (--len &gt;= 0) {
 564           (*jmpFct)(this, bci + tableswitch.dest_offset_at(len), data);
 565         }
 566         break;
 567       }
 568 
 569     case Bytecodes::_lookupswitch:
 570       { Bytecode_lookupswitch lookupswitch(method(), bcs-&gt;bcp());
 571         int npairs = lookupswitch.number_of_pairs();
 572         (*jmpFct)(this, bci + lookupswitch.default_offset(), data); /* Default. */
 573         while(--npairs &gt;= 0) {
 574           LookupswitchPair pair = lookupswitch.pair_at(npairs);
 575           (*jmpFct)(this, bci + pair.offset(), data);
 576         }
 577         break;
 578       }
 579     case Bytecodes::_jsr:
 580       assert(bcs-&gt;is_wide()==false, &quot;sanity check&quot;);
 581       (*jmpFct)(this, bcs-&gt;dest(), data);
 582 
 583 
 584 
 585       break;
 586     case Bytecodes::_jsr_w:
 587       (*jmpFct)(this, bcs-&gt;dest_w(), data);
 588       break;
 589     case Bytecodes::_wide:
 590       ShouldNotReachHere();
 591       return true;
 592       break;
 593     case Bytecodes::_athrow:
 594     case Bytecodes::_ireturn:
 595     case Bytecodes::_lreturn:
 596     case Bytecodes::_freturn:
 597     case Bytecodes::_dreturn:
 598     case Bytecodes::_areturn:
 599     case Bytecodes::_return:
 600     case Bytecodes::_ret:
 601       break;
 602     default:
 603       return true;
 604   }
 605   return false;
 606 }
 607 
 608 /* Requires &quot;pc&quot; to be the head of a basic block; returns that basic
 609    block. */
 610 BasicBlock *GenerateOopMap::get_basic_block_at(int bci) const {
 611   BasicBlock* bb = get_basic_block_containing(bci);
 612   assert(bb-&gt;_bci == bci, &quot;should have found BB&quot;);
 613   return bb;
 614 }
 615 
 616 // Requires &quot;pc&quot; to be the start of an instruction; returns the basic
 617 //   block containing that instruction. */
 618 BasicBlock  *GenerateOopMap::get_basic_block_containing(int bci) const {
 619   BasicBlock *bbs = _basic_blocks;
 620   int lo = 0, hi = _bb_count - 1;
 621 
 622   while (lo &lt;= hi) {
 623     int m = (lo + hi) / 2;
 624     int mbci = bbs[m]._bci;
 625     int nbci;
 626 
 627     if ( m == _bb_count-1) {
 628       assert( bci &gt;= mbci &amp;&amp; bci &lt; method()-&gt;code_size(), &quot;sanity check failed&quot;);
 629       return bbs+m;
 630     } else {
 631       nbci = bbs[m+1]._bci;
 632     }
 633 
 634     if ( mbci &lt;= bci &amp;&amp; bci &lt; nbci) {
 635       return bbs+m;
 636     } else if (mbci &lt; bci) {
 637       lo = m + 1;
 638     } else {
 639       assert(mbci &gt; bci, &quot;sanity check&quot;);
 640       hi = m - 1;
 641     }
 642   }
 643 
 644   fatal(&quot;should have found BB&quot;);
 645   return NULL;
 646 }
 647 
 648 void GenerateOopMap::restore_state(BasicBlock *bb)
 649 {
 650   memcpy(_state, bb-&gt;_state, _state_len*sizeof(CellTypeState));
 651   _stack_top = bb-&gt;_stack_top;
 652   _monitor_top = bb-&gt;_monitor_top;
 653 }
 654 
 655 int GenerateOopMap::next_bb_start_pc(BasicBlock *bb) {
 656  int bbNum = bb - _basic_blocks + 1;
 657  if (bbNum == _bb_count)
 658     return method()-&gt;code_size();
 659 
 660  return _basic_blocks[bbNum]._bci;
 661 }
 662 
 663 //
 664 // CellType handling methods
 665 //
 666 
 667 // Allocate memory and throw LinkageError if failure.
 668 #define ALLOC_RESOURCE_ARRAY(var, type, count) \
 669   var = NEW_RESOURCE_ARRAY_RETURN_NULL(type, count);              \
 670   if (var == NULL) {                                              \
 671     report_error(&quot;Cannot reserve enough memory to analyze this method&quot;); \
 672     return;                                                       \
 673   }
 674 
 675 
 676 void GenerateOopMap::init_state() {
 677   _state_len     = _max_locals + _max_stack + _max_monitors;
 678   ALLOC_RESOURCE_ARRAY(_state, CellTypeState, _state_len);
 679   memset(_state, 0, _state_len * sizeof(CellTypeState));
 680   int count = MAX3(_max_locals, _max_stack, _max_monitors) + 1/*for null terminator char */;
 681   ALLOC_RESOURCE_ARRAY(_state_vec_buf, char, count);
 682 }
 683 
 684 void GenerateOopMap::make_context_uninitialized() {
 685   CellTypeState* vs = vars();
 686 
 687   for (int i = 0; i &lt; _max_locals; i++)
 688       vs[i] = CellTypeState::uninit;
 689 
 690   _stack_top = 0;
 691   _monitor_top = 0;
 692 }
 693 
 694 int GenerateOopMap::methodsig_to_effect(Symbol* signature, bool is_static, CellTypeState* effect) {
 695   ComputeEntryStack ces(signature);
 696   return ces.compute_for_parameters(is_static, effect);
 697 }
 698 
 699 // Return result of merging cts1 and cts2.
 700 CellTypeState CellTypeState::merge(CellTypeState cts, int slot) const {
 701   CellTypeState result;
 702 
 703   assert(!is_bottom() &amp;&amp; !cts.is_bottom(),
 704          &quot;merge of bottom values is handled elsewhere&quot;);
 705 
 706   result._state = _state | cts._state;
 707 
 708   // If the top bit is set, we don&#39;t need to do any more work.
 709   if (!result.is_info_top()) {
 710     assert((result.can_be_address() || result.can_be_reference()),
 711            &quot;only addresses and references have non-top info&quot;);
 712 
 713     if (!equal(cts)) {
 714       // The two values being merged are different.  Raise to top.
 715       if (result.is_reference()) {
 716         result = CellTypeState::make_slot_ref(slot);
 717       } else {
 718         result._state |= info_conflict;
 719       }
 720     }
 721   }
 722   assert(result.is_valid_state(), &quot;checking that CTS merge maintains legal state&quot;);
 723 
 724   return result;
 725 }
 726 
 727 // Merge the variable state for locals and stack from cts into bbts.
 728 bool GenerateOopMap::merge_local_state_vectors(CellTypeState* cts,
 729                                                CellTypeState* bbts) {
 730   int i;
 731   int len = _max_locals + _stack_top;
 732   bool change = false;
 733 
 734   for (i = len - 1; i &gt;= 0; i--) {
 735     CellTypeState v = cts[i].merge(bbts[i], i);
 736     change = change || !v.equal(bbts[i]);
 737     bbts[i] = v;
 738   }
 739 
 740   return change;
 741 }
 742 
 743 // Merge the monitor stack state from cts into bbts.
 744 bool GenerateOopMap::merge_monitor_state_vectors(CellTypeState* cts,
 745                                                  CellTypeState* bbts) {
 746   bool change = false;
 747   if (_max_monitors &gt; 0 &amp;&amp; _monitor_top != bad_monitors) {
 748     // If there are no monitors in the program, or there has been
 749     // a monitor matching error before this point in the program,
 750     // then we do not merge in the monitor state.
 751 
 752     int base = _max_locals + _max_stack;
 753     int len = base + _monitor_top;
 754     for (int i = len - 1; i &gt;= base; i--) {
 755       CellTypeState v = cts[i].merge(bbts[i], i);
 756 
 757       // Can we prove that, when there has been a change, it will already
 758       // have been detected at this point?  That would make this equal
 759       // check here unnecessary.
 760       change = change || !v.equal(bbts[i]);
 761       bbts[i] = v;
 762     }
 763   }
 764 
 765   return change;
 766 }
 767 
 768 void GenerateOopMap::copy_state(CellTypeState *dst, CellTypeState *src) {
 769   int len = _max_locals + _stack_top;
 770   for (int i = 0; i &lt; len; i++) {
 771     if (src[i].is_nonlock_reference()) {
 772       dst[i] = CellTypeState::make_slot_ref(i);
 773     } else {
 774       dst[i] = src[i];
 775     }
 776   }
 777   if (_max_monitors &gt; 0 &amp;&amp; _monitor_top != bad_monitors) {
 778     int base = _max_locals + _max_stack;
 779     len = base + _monitor_top;
 780     for (int i = base; i &lt; len; i++) {
 781       dst[i] = src[i];
 782     }
 783   }
 784 }
 785 
 786 
 787 // Merge the states for the current block and the next.  As long as a
 788 // block is reachable the locals and stack must be merged.  If the
 789 // stack heights don&#39;t match then this is a verification error and
 790 // it&#39;s impossible to interpret the code.  Simultaneously monitor
 791 // states are being check to see if they nest statically.  If monitor
 792 // depths match up then their states are merged.  Otherwise the
 793 // mismatch is simply recorded and interpretation continues since
 794 // monitor matching is purely informational and doesn&#39;t say anything
 795 // about the correctness of the code.
 796 void GenerateOopMap::merge_state_into_bb(BasicBlock *bb) {
 797   guarantee(bb != NULL, &quot;null basicblock&quot;);
 798   assert(bb-&gt;is_alive(), &quot;merging state into a dead basicblock&quot;);
 799 
 800   if (_stack_top == bb-&gt;_stack_top) {
 801     // always merge local state even if monitors don&#39;t match.
 802     if (merge_local_state_vectors(_state, bb-&gt;_state)) {
 803       bb-&gt;set_changed(true);
 804     }
 805     if (_monitor_top == bb-&gt;_monitor_top) {
 806       // monitors still match so continue merging monitor states.
 807       if (merge_monitor_state_vectors(_state, bb-&gt;_state)) {
 808         bb-&gt;set_changed(true);
 809       }
 810     } else {
 811       if (log_is_enabled(Info, monitormismatch)) {
 812         report_monitor_mismatch(&quot;monitor stack height merge conflict&quot;);
 813       }
 814       // When the monitor stacks are not matched, we set _monitor_top to
 815       // bad_monitors.  This signals that, from here on, the monitor stack cannot
 816       // be trusted.  In particular, monitorexit bytecodes may throw
 817       // exceptions.  We mark this block as changed so that the change
 818       // propagates properly.
 819       bb-&gt;_monitor_top = bad_monitors;
 820       bb-&gt;set_changed(true);
 821       _monitor_safe = false;
 822     }
 823   } else if (!bb-&gt;is_reachable()) {
 824     // First time we look at this  BB
 825     copy_state(bb-&gt;_state, _state);
 826     bb-&gt;_stack_top = _stack_top;
 827     bb-&gt;_monitor_top = _monitor_top;
 828     bb-&gt;set_changed(true);
 829   } else {
 830     verify_error(&quot;stack height conflict: %d vs. %d&quot;,  _stack_top, bb-&gt;_stack_top);
 831   }
 832 }
 833 
 834 void GenerateOopMap::merge_state(GenerateOopMap *gom, int bci, int* data) {
 835    gom-&gt;merge_state_into_bb(gom-&gt;get_basic_block_at(bci));
 836 }
 837 
 838 void GenerateOopMap::set_var(int localNo, CellTypeState cts) {
 839   assert(cts.is_reference() || cts.is_inline_type() || cts.is_address(),
 840          &quot;wrong celltypestate&quot;);
 841   if (localNo &lt; 0 || localNo &gt; _max_locals) {
 842     verify_error(&quot;variable write error: r%d&quot;, localNo);
 843     return;
 844   }
 845   vars()[localNo] = cts;
 846 }
 847 
 848 CellTypeState GenerateOopMap::get_var(int localNo) {
 849   assert(localNo &lt; _max_locals + _nof_refval_conflicts, &quot;variable read error&quot;);
 850   if (localNo &lt; 0 || localNo &gt; _max_locals) {
 851     verify_error(&quot;variable read error: r%d&quot;, localNo);
 852     return valCTS; // just to pick something;
 853   }
 854   return vars()[localNo];
 855 }
 856 
 857 CellTypeState GenerateOopMap::pop() {
 858   if ( _stack_top &lt;= 0) {
 859     verify_error(&quot;stack underflow&quot;);
 860     return valCTS; // just to pick something
 861   }
 862   return  stack()[--_stack_top];
 863 }
 864 
 865 void GenerateOopMap::push(CellTypeState cts) {
 866   if ( _stack_top &gt;= _max_stack) {
 867     verify_error(&quot;stack overflow&quot;);
 868     return;
 869   }
 870   stack()[_stack_top++] = cts;
 871 }
 872 
 873 CellTypeState GenerateOopMap::monitor_pop() {
 874   assert(_monitor_top != bad_monitors, &quot;monitor_pop called on error monitor stack&quot;);
 875   if (_monitor_top == 0) {
 876     // We have detected a pop of an empty monitor stack.
 877     _monitor_safe = false;
 878      _monitor_top = bad_monitors;
 879 
 880     if (log_is_enabled(Info, monitormismatch)) {
 881       report_monitor_mismatch(&quot;monitor stack underflow&quot;);
 882     }
 883     return CellTypeState::ref; // just to keep the analysis going.
 884   }
 885   return  monitors()[--_monitor_top];
 886 }
 887 
 888 void GenerateOopMap::monitor_push(CellTypeState cts) {
 889   assert(_monitor_top != bad_monitors, &quot;monitor_push called on error monitor stack&quot;);
 890   if (_monitor_top &gt;= _max_monitors) {
 891     // Some monitorenter is being executed more than once.
 892     // This means that the monitor stack cannot be simulated.
 893     _monitor_safe = false;
 894     _monitor_top = bad_monitors;
 895 
 896     if (log_is_enabled(Info, monitormismatch)) {
 897       report_monitor_mismatch(&quot;monitor stack overflow&quot;);
 898     }
 899     return;
 900   }
 901   monitors()[_monitor_top++] = cts;
 902 }
 903 
 904 //
 905 // Interpretation handling methods
 906 //
 907 
 908 void GenerateOopMap::do_interpretation()
 909 {
 910   // &quot;i&quot; is just for debugging, so we can detect cases where this loop is
 911   // iterated more than once.
 912   int i = 0;
 913   do {
 914 #ifndef PRODUCT
 915     if (TraceNewOopMapGeneration) {
 916       tty-&gt;print(&quot;\n\nIteration #%d of do_interpretation loop, method:\n&quot;, i);
 917       method()-&gt;print_name(tty);
 918       tty-&gt;print(&quot;\n\n&quot;);
 919     }
 920 #endif
 921     _conflict = false;
 922     _monitor_safe = true;
 923     // init_state is now called from init_basic_blocks.  The length of a
 924     // state vector cannot be determined until we have made a pass through
 925     // the bytecodes counting the possible monitor entries.
 926     if (!_got_error) init_basic_blocks();
 927     if (!_got_error) setup_method_entry_state();
 928     if (!_got_error) interp_all();
 929     if (!_got_error) rewrite_refval_conflicts();
 930     i++;
 931   } while (_conflict &amp;&amp; !_got_error);
 932 }
 933 
 934 void GenerateOopMap::init_basic_blocks() {
 935   // Note: Could consider reserving only the needed space for each BB&#39;s state
 936   // (entry stack may not be of maximal height for every basic block).
 937   // But cumbersome since we don&#39;t know the stack heights yet.  (Nor the
 938   // monitor stack heights...)
 939 
 940   ALLOC_RESOURCE_ARRAY(_basic_blocks, BasicBlock, _bb_count);
 941 
 942   // Make a pass through the bytecodes.  Count the number of monitorenters.
 943   // This can be used an upper bound on the monitor stack depth in programs
 944   // which obey stack discipline with their monitor usage.  Initialize the
 945   // known information about basic blocks.
 946   BytecodeStream j(_method);
 947   Bytecodes::Code bytecode;
 948 
 949   int bbNo = 0;
 950   int monitor_count = 0;
 951   int prev_bci = -1;
 952   while( (bytecode = j.next()) &gt;= 0) {
 953     if (j.code() == Bytecodes::_monitorenter) {
 954       monitor_count++;
 955     }
 956 
 957     int bci = j.bci();
 958     if (is_bb_header(bci)) {
 959       // Initialize the basicblock structure
 960       BasicBlock *bb   = _basic_blocks + bbNo;
 961       bb-&gt;_bci         = bci;
 962       bb-&gt;_max_locals  = _max_locals;
 963       bb-&gt;_max_stack   = _max_stack;
 964       bb-&gt;set_changed(false);
 965       bb-&gt;_stack_top   = BasicBlock::_dead_basic_block; // Initialize all basicblocks are dead.
 966       bb-&gt;_monitor_top = bad_monitors;
 967 
 968       if (bbNo &gt; 0) {
 969         _basic_blocks[bbNo - 1]._end_bci = prev_bci;
 970       }
 971 
 972       bbNo++;
 973     }
 974     // Remember prevous bci.
 975     prev_bci = bci;
 976   }
 977   // Set
 978   _basic_blocks[bbNo-1]._end_bci = prev_bci;
 979 
 980 
 981   // Check that the correct number of basicblocks was found
 982   if (bbNo !=_bb_count) {
 983     if (bbNo &lt; _bb_count) {
 984       verify_error(&quot;jump into the middle of instruction?&quot;);
 985       return;
 986     } else {
 987       verify_error(&quot;extra basic blocks - should not happen?&quot;);
 988       return;
 989     }
 990   }
 991 
 992   _max_monitors = monitor_count;
 993 
 994   // Now that we have a bound on the depth of the monitor stack, we can
 995   // initialize the CellTypeState-related information.
 996   init_state();
 997 
 998   // We allocate space for all state-vectors for all basicblocks in one huge
 999   // chunk.  Then in the next part of the code, we set a pointer in each
1000   // _basic_block that points to each piece.
1001 
1002   // The product of bbNo and _state_len can get large if there are lots of
1003   // basic blocks and stack/locals/monitors.  Need to check to make sure
1004   // we don&#39;t overflow the capacity of a pointer.
1005   if ((unsigned)bbNo &gt; UINTPTR_MAX / sizeof(CellTypeState) / _state_len) {
1006     report_error(&quot;The amount of memory required to analyze this method &quot;
1007                  &quot;exceeds addressable range&quot;);
1008     return;
1009   }
1010 
1011   CellTypeState *basicBlockState;
1012   ALLOC_RESOURCE_ARRAY(basicBlockState, CellTypeState, bbNo * _state_len);
1013   memset(basicBlockState, 0, bbNo * _state_len * sizeof(CellTypeState));
1014 
1015   // Make a pass over the basicblocks and assign their state vectors.
1016   for (int blockNum=0; blockNum &lt; bbNo; blockNum++) {
1017     BasicBlock *bb = _basic_blocks + blockNum;
1018     bb-&gt;_state = basicBlockState + blockNum * _state_len;
1019 
1020 #ifdef ASSERT
1021     if (blockNum + 1 &lt; bbNo) {
1022       address bcp = _method-&gt;bcp_from(bb-&gt;_end_bci);
1023       int bc_len = Bytecodes::java_length_at(_method(), bcp);
1024       assert(bb-&gt;_end_bci + bc_len == bb[1]._bci, &quot;unmatched bci info in basicblock&quot;);
1025     }
1026 #endif
1027   }
1028 #ifdef ASSERT
1029   { BasicBlock *bb = &amp;_basic_blocks[bbNo-1];
1030     address bcp = _method-&gt;bcp_from(bb-&gt;_end_bci);
1031     int bc_len = Bytecodes::java_length_at(_method(), bcp);
1032     assert(bb-&gt;_end_bci + bc_len == _method-&gt;code_size(), &quot;wrong end bci&quot;);
1033   }
1034 #endif
1035 
1036   // Mark all alive blocks
1037   mark_reachable_code();
1038 }
1039 
1040 void GenerateOopMap::setup_method_entry_state() {
1041 
1042     // Initialize all locals to &#39;uninit&#39; and set stack-height to 0
1043     make_context_uninitialized();
1044 
1045     // Initialize CellState type of arguments
1046     methodsig_to_effect(method()-&gt;signature(), method()-&gt;is_static(), vars());
1047 
1048     // If some references must be pre-assigned to null, then set that up
1049     initialize_vars();
1050 
1051     // This is the start state
1052     merge_state_into_bb(&amp;_basic_blocks[0]);
1053 
1054     assert(_basic_blocks[0].changed(), &quot;we are not getting off the ground&quot;);
1055 }
1056 
1057 // The instruction at bci is changing size by &quot;delta&quot;.  Update the basic blocks.
1058 void GenerateOopMap::update_basic_blocks(int bci, int delta,
1059                                          int new_method_size) {
1060   assert(new_method_size &gt;= method()-&gt;code_size() + delta,
1061          &quot;new method size is too small&quot;);
1062 
1063   _bb_hdr_bits.reinitialize(new_method_size);
1064 
1065   for(int k = 0; k &lt; _bb_count; k++) {
1066     if (_basic_blocks[k]._bci &gt; bci) {
1067       _basic_blocks[k]._bci     += delta;
1068       _basic_blocks[k]._end_bci += delta;
1069     }
1070     _bb_hdr_bits.at_put(_basic_blocks[k]._bci, true);
1071   }
1072 }
1073 
1074 //
1075 // Initvars handling
1076 //
1077 
1078 void GenerateOopMap::initialize_vars() {
1079   for (int k = 0; k &lt; _init_vars-&gt;length(); k++)
1080     _state[_init_vars-&gt;at(k)] = CellTypeState::make_slot_ref(k);
1081 }
1082 
1083 void GenerateOopMap::add_to_ref_init_set(int localNo) {
1084 
1085   if (TraceNewOopMapGeneration)
1086     tty-&gt;print_cr(&quot;Added init vars: %d&quot;, localNo);
1087 
1088   // Is it already in the set?
1089   if (_init_vars-&gt;contains(localNo) )
1090     return;
1091 
1092    _init_vars-&gt;append(localNo);
1093 }
1094 
1095 //
1096 // Interpreration code
1097 //
1098 
1099 void GenerateOopMap::interp_all() {
1100   bool change = true;
1101 
1102   while (change &amp;&amp; !_got_error) {
1103     change = false;
1104     for (int i = 0; i &lt; _bb_count &amp;&amp; !_got_error; i++) {
1105       BasicBlock *bb = &amp;_basic_blocks[i];
1106       if (bb-&gt;changed()) {
1107          if (_got_error) return;
1108          change = true;
1109          bb-&gt;set_changed(false);
1110          interp_bb(bb);
1111       }
1112     }
1113   }
1114 }
1115 
1116 void GenerateOopMap::interp_bb(BasicBlock *bb) {
1117 
1118   // We do not want to do anything in case the basic-block has not been initialized. This
1119   // will happen in the case where there is dead-code hang around in a method.
1120   assert(bb-&gt;is_reachable(), &quot;should be reachable or deadcode exist&quot;);
1121   restore_state(bb);
1122 
1123   BytecodeStream itr(_method);
1124 
1125   // Set iterator interval to be the current basicblock
1126   int lim_bci = next_bb_start_pc(bb);
1127   itr.set_interval(bb-&gt;_bci, lim_bci);
1128   assert(lim_bci != bb-&gt;_bci, &quot;must be at least one instruction in a basicblock&quot;);
1129   itr.next(); // read first instruction
1130 
1131   // Iterates through all bytecodes except the last in a basic block.
1132   // We handle the last one special, since there is controlflow change.
1133   while(itr.next_bci() &lt; lim_bci &amp;&amp; !_got_error) {
1134     if (_has_exceptions || _monitor_top != 0) {
1135       // We do not need to interpret the results of exceptional
1136       // continuation from this instruction when the method has no
1137       // exception handlers and the monitor stack is currently
1138       // empty.
1139       do_exception_edge(&amp;itr);
1140     }
1141     interp1(&amp;itr);
1142     itr.next();
1143   }
1144 
1145   // Handle last instruction.
1146   if (!_got_error) {
1147     assert(itr.next_bci() == lim_bci, &quot;must point to end&quot;);
1148     if (_has_exceptions || _monitor_top != 0) {
1149       do_exception_edge(&amp;itr);
1150     }
1151     interp1(&amp;itr);
1152 
1153     bool fall_through = jump_targets_do(&amp;itr, GenerateOopMap::merge_state, NULL);
1154     if (_got_error)  return;
1155 
1156     if (itr.code() == Bytecodes::_ret) {
1157       assert(!fall_through, &quot;cannot be set if ret instruction&quot;);
1158       // Automatically handles &#39;wide&#39; ret indicies
1159       ret_jump_targets_do(&amp;itr, GenerateOopMap::merge_state, itr.get_index(), NULL);
1160     } else if (fall_through) {
1161      // Hit end of BB, but the instr. was a fall-through instruction,
1162      // so perform transition as if the BB ended in a &quot;jump&quot;.
1163      if (lim_bci != bb[1]._bci) {
1164        verify_error(&quot;bytecodes fell through last instruction&quot;);
1165        return;
1166      }
1167      merge_state_into_bb(bb + 1);
1168     }
1169   }
1170 }
1171 
1172 void GenerateOopMap::do_exception_edge(BytecodeStream* itr) {
1173   // Only check exception edge, if bytecode can trap
1174   if (!Bytecodes::can_trap(itr-&gt;code())) return;
1175   switch (itr-&gt;code()) {
1176     case Bytecodes::_aload_0:
1177       // These bytecodes can trap for rewriting.  We need to assume that
1178       // they do not throw exceptions to make the monitor analysis work.
1179       return;
1180 
1181     case Bytecodes::_ireturn:
1182     case Bytecodes::_lreturn:
1183     case Bytecodes::_freturn:
1184     case Bytecodes::_dreturn:
1185     case Bytecodes::_areturn:
1186     case Bytecodes::_return:
1187       // If the monitor stack height is not zero when we leave the method,
1188       // then we are either exiting with a non-empty stack or we have
1189       // found monitor trouble earlier in our analysis.  In either case,
1190       // assume an exception could be taken here.
1191       if (_monitor_top == 0) {
1192         return;
1193       }
1194       break;
1195 
1196     case Bytecodes::_monitorexit:
1197       // If the monitor stack height is bad_monitors, then we have detected a
1198       // monitor matching problem earlier in the analysis.  If the
1199       // monitor stack height is 0, we are about to pop a monitor
1200       // off of an empty stack.  In either case, the bytecode
1201       // could throw an exception.
1202       if (_monitor_top != bad_monitors &amp;&amp; _monitor_top != 0) {
1203         return;
1204       }
1205       break;
1206 
1207     default:
1208       break;
1209   }
1210 
1211   if (_has_exceptions) {
1212     int bci = itr-&gt;bci();
1213     ExceptionTable exct(method());
1214     for(int i = 0; i&lt; exct.length(); i++) {
1215       int start_pc   = exct.start_pc(i);
1216       int end_pc     = exct.end_pc(i);
1217       int handler_pc = exct.handler_pc(i);
1218       int catch_type = exct.catch_type_index(i);
1219 
1220       if (start_pc &lt;= bci &amp;&amp; bci &lt; end_pc) {
1221         BasicBlock *excBB = get_basic_block_at(handler_pc);
1222         guarantee(excBB != NULL, &quot;no basic block for exception&quot;);
1223         CellTypeState *excStk = excBB-&gt;stack();
1224         CellTypeState *cOpStck = stack();
1225         CellTypeState cOpStck_0 = cOpStck[0];
1226         int cOpStackTop = _stack_top;
1227 
1228         // Exception stacks are always the same.
1229         assert(method()-&gt;max_stack() &gt; 0, &quot;sanity check&quot;);
1230 
1231         // We remembered the size and first element of &quot;cOpStck&quot;
1232         // above; now we temporarily set them to the appropriate
1233         // values for an exception handler. */
1234         cOpStck[0] = CellTypeState::make_slot_ref(_max_locals);
1235         _stack_top = 1;
1236 
1237         merge_state_into_bb(excBB);
1238 
1239         // Now undo the temporary change.
1240         cOpStck[0] = cOpStck_0;
1241         _stack_top = cOpStackTop;
1242 
1243         // If this is a &quot;catch all&quot; handler, then we do not need to
1244         // consider any additional handlers.
1245         if (catch_type == 0) {
1246           return;
1247         }
1248       }
1249     }
1250   }
1251 
1252   // It is possible that none of the exception handlers would have caught
1253   // the exception.  In this case, we will exit the method.  We must
1254   // ensure that the monitor stack is empty in this case.
1255   if (_monitor_top == 0) {
1256     return;
1257   }
1258 
1259   // We pessimistically assume that this exception can escape the
1260   // method. (It is possible that it will always be caught, but
1261   // we don&#39;t care to analyse the types of the catch clauses.)
1262 
1263   // We don&#39;t set _monitor_top to bad_monitors because there are no successors
1264   // to this exceptional exit.
1265 
1266   if (log_is_enabled(Info, monitormismatch) &amp;&amp; _monitor_safe) {
1267     // We check _monitor_safe so that we only report the first mismatched
1268     // exceptional exit.
1269     report_monitor_mismatch(&quot;non-empty monitor stack at exceptional exit&quot;);
1270   }
1271   _monitor_safe = false;
1272 
1273 }
1274 
1275 void GenerateOopMap::report_monitor_mismatch(const char *msg) {
1276   ResourceMark rm;
1277   LogStream ls(Log(monitormismatch)::info());
1278   ls.print(&quot;Monitor mismatch in method &quot;);
1279   method()-&gt;print_short_name(&amp;ls);
1280   ls.print_cr(&quot;: %s&quot;, msg);
1281 }
1282 
1283 void GenerateOopMap::print_states(outputStream *os,
1284                                   CellTypeState* vec, int num) {
1285   for (int i = 0; i &lt; num; i++) {
1286     vec[i].print(tty);
1287   }
1288 }
1289 
1290 // Print the state values at the current bytecode.
1291 void GenerateOopMap::print_current_state(outputStream   *os,
1292                                          BytecodeStream *currentBC,
1293                                          bool            detailed) {
1294   if (detailed) {
1295     os-&gt;print(&quot;     %4d vars     = &quot;, currentBC-&gt;bci());
1296     print_states(os, vars(), _max_locals);
1297     os-&gt;print(&quot;    %s&quot;, Bytecodes::name(currentBC-&gt;code()));
1298   } else {
1299     os-&gt;print(&quot;    %4d  vars = &#39;%s&#39; &quot;, currentBC-&gt;bci(),  state_vec_to_string(vars(), _max_locals));
1300     os-&gt;print(&quot;     stack = &#39;%s&#39; &quot;, state_vec_to_string(stack(), _stack_top));
1301     if (_monitor_top != bad_monitors) {
1302       os-&gt;print(&quot;  monitors = &#39;%s&#39;  \t%s&quot;, state_vec_to_string(monitors(), _monitor_top), Bytecodes::name(currentBC-&gt;code()));
1303     } else {
1304       os-&gt;print(&quot;  [bad monitor stack]&quot;);
1305     }
1306   }
1307 
1308   switch(currentBC-&gt;code()) {
1309     case Bytecodes::_invokevirtual:
1310     case Bytecodes::_invokespecial:
1311     case Bytecodes::_invokestatic:
1312     case Bytecodes::_invokedynamic:
1313     case Bytecodes::_invokeinterface: {
1314       int idx = currentBC-&gt;has_index_u4() ? currentBC-&gt;get_index_u4() : currentBC-&gt;get_index_u2_cpcache();
1315       ConstantPool* cp      = method()-&gt;constants();
1316       int nameAndTypeIdx    = cp-&gt;name_and_type_ref_index_at(idx);
1317       int signatureIdx      = cp-&gt;signature_ref_index_at(nameAndTypeIdx);
1318       Symbol* signature     = cp-&gt;symbol_at(signatureIdx);
1319       os-&gt;print(&quot;%s&quot;, signature-&gt;as_C_string());
1320     }
1321     default:
1322       break;
1323   }
1324 
1325   if (detailed) {
1326     os-&gt;cr();
1327     os-&gt;print(&quot;          stack    = &quot;);
1328     print_states(os, stack(), _stack_top);
1329     os-&gt;cr();
1330     if (_monitor_top != bad_monitors) {
1331       os-&gt;print(&quot;          monitors = &quot;);
1332       print_states(os, monitors(), _monitor_top);
1333     } else {
1334       os-&gt;print(&quot;          [bad monitor stack]&quot;);
1335     }
1336   }
1337 
1338   os-&gt;cr();
1339 }
1340 
1341 // Sets the current state to be the state after executing the
1342 // current instruction, starting in the current state.
1343 void GenerateOopMap::interp1(BytecodeStream *itr) {
1344   if (TraceNewOopMapGeneration) {
1345     print_current_state(tty, itr, TraceNewOopMapGenerationDetailed);
1346   }
1347 
1348   // Should we report the results? Result is reported *before* the instruction at the current bci is executed.
1349   // However, not for calls. For calls we do not want to include the arguments, so we postpone the reporting until
1350   // they have been popped (in method ppl).
1351   if (_report_result == true) {
1352     switch(itr-&gt;code()) {
1353       case Bytecodes::_invokevirtual:
1354       case Bytecodes::_invokespecial:
1355       case Bytecodes::_invokestatic:
1356       case Bytecodes::_invokedynamic:
1357       case Bytecodes::_invokeinterface:
1358         _itr_send = itr;
1359         _report_result_for_send = true;
1360         break;
1361       default:
1362        fill_stackmap_for_opcodes(itr, vars(), stack(), _stack_top);
1363        break;
1364     }
1365   }
1366 
1367   // abstract interpretation of current opcode
1368   switch(itr-&gt;code()) {
1369     case Bytecodes::_nop:                                           break;
1370     case Bytecodes::_goto:                                          break;
1371     case Bytecodes::_goto_w:                                        break;
1372     case Bytecodes::_iinc:                                          break;
1373     case Bytecodes::_return:            do_return_monitor_check();
1374                                         break;
1375 
1376     case Bytecodes::_aconst_null:
1377     case Bytecodes::_new:               ppush1(CellTypeState::make_line_ref(itr-&gt;bci()));
1378                                         break;
1379 
1380     case Bytecodes::_defaultvalue:      ppush1(CellTypeState::make_line_ref(itr-&gt;bci())); break;
1381     case Bytecodes::_withfield:         do_withfield(itr-&gt;get_index_u2_cpcache(), itr-&gt;bci()); break;
1382 
1383     case Bytecodes::_iconst_m1:
1384     case Bytecodes::_iconst_0:
1385     case Bytecodes::_iconst_1:
1386     case Bytecodes::_iconst_2:
1387     case Bytecodes::_iconst_3:
1388     case Bytecodes::_iconst_4:
1389     case Bytecodes::_iconst_5:
1390     case Bytecodes::_fconst_0:
1391     case Bytecodes::_fconst_1:
1392     case Bytecodes::_fconst_2:
1393     case Bytecodes::_bipush:
1394     case Bytecodes::_sipush:            ppush1(valCTS);             break;
1395 
1396     case Bytecodes::_lconst_0:
1397     case Bytecodes::_lconst_1:
1398     case Bytecodes::_dconst_0:
1399     case Bytecodes::_dconst_1:          ppush(vvCTS);               break;
1400 
1401     case Bytecodes::_ldc2_w:            ppush(vvCTS);               break;
1402 
1403     case Bytecodes::_ldc:               // fall through:
1404     case Bytecodes::_ldc_w:             do_ldc(itr-&gt;bci());         break;
1405 
1406     case Bytecodes::_iload:
1407     case Bytecodes::_fload:             ppload(vCTS, itr-&gt;get_index()); break;
1408 
1409     case Bytecodes::_lload:
1410     case Bytecodes::_dload:             ppload(vvCTS,itr-&gt;get_index()); break;
1411 
1412     case Bytecodes::_aload:             ppload(rCTS, itr-&gt;get_index()); break;
1413 
1414     case Bytecodes::_iload_0:
1415     case Bytecodes::_fload_0:           ppload(vCTS, 0);            break;
1416     case Bytecodes::_iload_1:
1417     case Bytecodes::_fload_1:           ppload(vCTS, 1);            break;
1418     case Bytecodes::_iload_2:
1419     case Bytecodes::_fload_2:           ppload(vCTS, 2);            break;
1420     case Bytecodes::_iload_3:
1421     case Bytecodes::_fload_3:           ppload(vCTS, 3);            break;
1422 
1423     case Bytecodes::_lload_0:
1424     case Bytecodes::_dload_0:           ppload(vvCTS, 0);           break;
1425     case Bytecodes::_lload_1:
1426     case Bytecodes::_dload_1:           ppload(vvCTS, 1);           break;
1427     case Bytecodes::_lload_2:
1428     case Bytecodes::_dload_2:           ppload(vvCTS, 2);           break;
1429     case Bytecodes::_lload_3:
1430     case Bytecodes::_dload_3:           ppload(vvCTS, 3);           break;
1431 
1432     case Bytecodes::_aload_0:           ppload(rCTS, 0);            break;
1433     case Bytecodes::_aload_1:           ppload(rCTS, 1);            break;
1434     case Bytecodes::_aload_2:           ppload(rCTS, 2);            break;
1435     case Bytecodes::_aload_3:           ppload(rCTS, 3);            break;
1436 
1437     case Bytecodes::_iaload:
1438     case Bytecodes::_faload:
1439     case Bytecodes::_baload:
1440     case Bytecodes::_caload:
1441     case Bytecodes::_saload:            pp(vrCTS, vCTS); break;
1442 
1443     case Bytecodes::_laload:            pp(vrCTS, vvCTS);  break;
1444     case Bytecodes::_daload:            pp(vrCTS, vvCTS); break;
1445 
1446     case Bytecodes::_aaload:            pp_new_ref(vrCTS, itr-&gt;bci()); break;
1447 
1448     case Bytecodes::_istore:
1449     case Bytecodes::_fstore:            ppstore(vCTS, itr-&gt;get_index()); break;
1450 
1451     case Bytecodes::_lstore:
1452     case Bytecodes::_dstore:            ppstore(vvCTS, itr-&gt;get_index()); break;
1453 
1454     case Bytecodes::_astore:            do_astore(itr-&gt;get_index());     break;
1455 
1456     case Bytecodes::_istore_0:
1457     case Bytecodes::_fstore_0:          ppstore(vCTS, 0);           break;
1458     case Bytecodes::_istore_1:
1459     case Bytecodes::_fstore_1:          ppstore(vCTS, 1);           break;
1460     case Bytecodes::_istore_2:
1461     case Bytecodes::_fstore_2:          ppstore(vCTS, 2);           break;
1462     case Bytecodes::_istore_3:
1463     case Bytecodes::_fstore_3:          ppstore(vCTS, 3);           break;
1464 
1465     case Bytecodes::_lstore_0:
1466     case Bytecodes::_dstore_0:          ppstore(vvCTS, 0);          break;
1467     case Bytecodes::_lstore_1:
1468     case Bytecodes::_dstore_1:          ppstore(vvCTS, 1);          break;
1469     case Bytecodes::_lstore_2:
1470     case Bytecodes::_dstore_2:          ppstore(vvCTS, 2);          break;
1471     case Bytecodes::_lstore_3:
1472     case Bytecodes::_dstore_3:          ppstore(vvCTS, 3);          break;
1473 
1474     case Bytecodes::_astore_0:          do_astore(0);               break;
1475     case Bytecodes::_astore_1:          do_astore(1);               break;
1476     case Bytecodes::_astore_2:          do_astore(2);               break;
1477     case Bytecodes::_astore_3:          do_astore(3);               break;
1478 
1479     case Bytecodes::_iastore:
1480     case Bytecodes::_fastore:
1481     case Bytecodes::_bastore:
1482     case Bytecodes::_castore:
1483     case Bytecodes::_sastore:           ppop(vvrCTS);               break;
1484     case Bytecodes::_lastore:
1485     case Bytecodes::_dastore:           ppop(vvvrCTS);              break;
1486     case Bytecodes::_aastore:           ppop(rvrCTS);               break;
1487 
1488     case Bytecodes::_pop:               ppop_any(1);                break;
1489     case Bytecodes::_pop2:              ppop_any(2);                break;
1490 
1491     case Bytecodes::_dup:               ppdupswap(1, &quot;11&quot;);         break;
1492     case Bytecodes::_dup_x1:            ppdupswap(2, &quot;121&quot;);        break;
1493     case Bytecodes::_dup_x2:            ppdupswap(3, &quot;1321&quot;);       break;
1494     case Bytecodes::_dup2:              ppdupswap(2, &quot;2121&quot;);       break;
1495     case Bytecodes::_dup2_x1:           ppdupswap(3, &quot;21321&quot;);      break;
1496     case Bytecodes::_dup2_x2:           ppdupswap(4, &quot;214321&quot;);     break;
1497     case Bytecodes::_swap:              ppdupswap(2, &quot;12&quot;);         break;
1498 
1499     case Bytecodes::_iadd:
1500     case Bytecodes::_fadd:
1501     case Bytecodes::_isub:
1502     case Bytecodes::_fsub:
1503     case Bytecodes::_imul:
1504     case Bytecodes::_fmul:
1505     case Bytecodes::_idiv:
1506     case Bytecodes::_fdiv:
1507     case Bytecodes::_irem:
1508     case Bytecodes::_frem:
1509     case Bytecodes::_ishl:
1510     case Bytecodes::_ishr:
1511     case Bytecodes::_iushr:
1512     case Bytecodes::_iand:
1513     case Bytecodes::_ior:
1514     case Bytecodes::_ixor:
1515     case Bytecodes::_l2f:
1516     case Bytecodes::_l2i:
1517     case Bytecodes::_d2f:
1518     case Bytecodes::_d2i:
1519     case Bytecodes::_fcmpl:
1520     case Bytecodes::_fcmpg:             pp(vvCTS, vCTS); break;
1521 
1522     case Bytecodes::_ladd:
1523     case Bytecodes::_dadd:
1524     case Bytecodes::_lsub:
1525     case Bytecodes::_dsub:
1526     case Bytecodes::_lmul:
1527     case Bytecodes::_dmul:
1528     case Bytecodes::_ldiv:
1529     case Bytecodes::_ddiv:
1530     case Bytecodes::_lrem:
1531     case Bytecodes::_drem:
1532     case Bytecodes::_land:
1533     case Bytecodes::_lor:
1534     case Bytecodes::_lxor:              pp(vvvvCTS, vvCTS); break;
1535 
1536     case Bytecodes::_ineg:
1537     case Bytecodes::_fneg:
1538     case Bytecodes::_i2f:
1539     case Bytecodes::_f2i:
1540     case Bytecodes::_i2c:
1541     case Bytecodes::_i2s:
1542     case Bytecodes::_i2b:               pp(vCTS, vCTS); break;
1543 
1544     case Bytecodes::_lneg:
1545     case Bytecodes::_dneg:
1546     case Bytecodes::_l2d:
1547     case Bytecodes::_d2l:               pp(vvCTS, vvCTS); break;
1548 
1549     case Bytecodes::_lshl:
1550     case Bytecodes::_lshr:
1551     case Bytecodes::_lushr:             pp(vvvCTS, vvCTS); break;
1552 
1553     case Bytecodes::_i2l:
1554     case Bytecodes::_i2d:
1555     case Bytecodes::_f2l:
1556     case Bytecodes::_f2d:               pp(vCTS, vvCTS); break;
1557 
1558     case Bytecodes::_lcmp:              pp(vvvvCTS, vCTS); break;
1559     case Bytecodes::_dcmpl:
1560     case Bytecodes::_dcmpg:             pp(vvvvCTS, vCTS); break;
1561 
1562     case Bytecodes::_ifeq:
1563     case Bytecodes::_ifne:
1564     case Bytecodes::_iflt:
1565     case Bytecodes::_ifge:
1566     case Bytecodes::_ifgt:
1567     case Bytecodes::_ifle:
1568     case Bytecodes::_tableswitch:       ppop1(valCTS);
1569                                         break;
1570     case Bytecodes::_ireturn:
1571     case Bytecodes::_freturn:           do_return_monitor_check();
1572                                         ppop1(valCTS);
1573                                         break;
1574     case Bytecodes::_if_icmpeq:
1575     case Bytecodes::_if_icmpne:
1576     case Bytecodes::_if_icmplt:
1577     case Bytecodes::_if_icmpge:
1578     case Bytecodes::_if_icmpgt:
1579     case Bytecodes::_if_icmple:         ppop(vvCTS);
1580                                         break;
1581 
1582     case Bytecodes::_lreturn:           do_return_monitor_check();
1583                                         ppop(vvCTS);
1584                                         break;
1585 
1586     case Bytecodes::_dreturn:           do_return_monitor_check();
1587                                         ppop(vvCTS);
1588                                         break;
1589 
1590     case Bytecodes::_if_acmpeq:
1591     case Bytecodes::_if_acmpne:         ppop(rrCTS);                 break;
1592 
1593     case Bytecodes::_jsr:               do_jsr(itr-&gt;dest());         break;
1594     case Bytecodes::_jsr_w:             do_jsr(itr-&gt;dest_w());       break;
1595 
1596     case Bytecodes::_getstatic:         do_field(true,  true, itr-&gt;get_index_u2_cpcache(), itr-&gt;bci()); break;
1597     case Bytecodes::_putstatic:         do_field(false, true, itr-&gt;get_index_u2_cpcache(), itr-&gt;bci()); break;
1598     case Bytecodes::_getfield:          do_field(true,  false, itr-&gt;get_index_u2_cpcache(), itr-&gt;bci()); break;
1599     case Bytecodes::_putfield:          do_field(false, false, itr-&gt;get_index_u2_cpcache(), itr-&gt;bci()); break;
1600 
1601     case Bytecodes::_invokeinterface:
1602     case Bytecodes::_invokevirtual:
1603     case Bytecodes::_invokespecial:     do_method(false, itr-&gt;get_index_u2_cpcache(), itr-&gt;bci()); break;
1604     case Bytecodes::_invokestatic:      do_method(true , itr-&gt;get_index_u2_cpcache(), itr-&gt;bci()); break;
1605     case Bytecodes::_invokedynamic:     do_method(true , itr-&gt;get_index_u4(),         itr-&gt;bci()); break;
1606     case Bytecodes::_newarray:
1607     case Bytecodes::_anewarray:         pp_new_ref(vCTS, itr-&gt;bci()); break;
1608     case Bytecodes::_checkcast:         do_checkcast(); break;
1609     case Bytecodes::_arraylength:
1610     case Bytecodes::_instanceof:        pp(rCTS, vCTS); break;
1611     case Bytecodes::_monitorenter:      do_monitorenter(itr-&gt;bci()); break;
1612     case Bytecodes::_monitorexit:       do_monitorexit(itr-&gt;bci()); break;
1613 
1614     case Bytecodes::_athrow:            // handled by do_exception_edge() BUT ...
1615                                         // vlh(apple): do_exception_edge() does not get
1616                                         // called if method has no exception handlers
1617                                         if ((!_has_exceptions) &amp;&amp; (_monitor_top &gt; 0)) {
1618                                           _monitor_safe = false;
1619                                         }
1620                                         break;
1621 
1622     case Bytecodes::_areturn:           do_return_monitor_check();
1623                                         ppop1(refCTS);
1624                                         break;
1625 
1626     case Bytecodes::_ifnull:
1627     case Bytecodes::_ifnonnull:         ppop1(refCTS); break;
1628     case Bytecodes::_multianewarray:    do_multianewarray(*(itr-&gt;bcp()+3), itr-&gt;bci()); break;
1629 
1630     case Bytecodes::_wide:              fatal(&quot;Iterator should skip this bytecode&quot;); break;
1631     case Bytecodes::_ret:                                           break;
1632 
1633     // Java opcodes
1634     case Bytecodes::_lookupswitch:      ppop1(valCTS);             break;
1635 
1636     default:
1637          tty-&gt;print(&quot;unexpected opcode: %d\n&quot;, itr-&gt;code());
1638          ShouldNotReachHere();
1639     break;
1640   }
1641 }
1642 
1643 void GenerateOopMap::check_type(CellTypeState expected, CellTypeState actual) {
1644   if (!expected.equal_kind(actual)) {
1645     verify_error(&quot;wrong type on stack (found: %c expected: %c)&quot;, actual.to_char(), expected.to_char());
1646   }
1647 }
1648 
1649 void GenerateOopMap::ppstore(CellTypeState *in, int loc_no) {
1650   while(!(*in).is_bottom()) {
1651     CellTypeState expected =*in++;
1652     CellTypeState actual   = pop();
1653     check_type(expected, actual);
1654     assert(loc_no &gt;= 0, &quot;sanity check&quot;);
1655     set_var(loc_no++, actual);
1656   }
1657 }
1658 
1659 void GenerateOopMap::ppload(CellTypeState *out, int loc_no) {
1660   while(!(*out).is_bottom()) {
1661     CellTypeState out1 = *out++;
1662     CellTypeState vcts = get_var(loc_no);
1663     assert(out1.can_be_reference() || out1.can_be_value(),
1664            &quot;can only load refs. and values.&quot;);
1665     if (out1.is_reference()) {
1666       assert(loc_no&gt;=0, &quot;sanity check&quot;);
1667       if (!vcts.is_reference()) {
1668         // We were asked to push a reference, but the type of the
1669         // variable can be something else
1670         _conflict = true;
1671         if (vcts.can_be_uninit()) {
1672           // It is a ref-uninit conflict (at least). If there are other
1673           // problems, we&#39;ll get them in the next round
1674           add_to_ref_init_set(loc_no);
1675           vcts = out1;
1676         } else {
1677           // It wasn&#39;t a ref-uninit conflict. So must be a
1678           // ref-val or ref-pc conflict. Split the variable.
1679           record_refval_conflict(loc_no);
1680           vcts = out1;
1681         }
1682         push(out1); // recover...
1683       } else {
1684         push(vcts); // preserve reference.
1685       }
1686       // Otherwise it is a conflict, but one that verification would
1687       // have caught if illegal. In particular, it can&#39;t be a topCTS
1688       // resulting from mergeing two difference pcCTS&#39;s since the verifier
1689       // would have rejected any use of such a merge.
1690     } else {
1691       push(out1); // handle val/init conflict
1692     }
1693     loc_no++;
1694   }
1695 }
1696 
1697 void GenerateOopMap::ppdupswap(int poplen, const char *out) {
1698   CellTypeState actual[5];
1699   assert(poplen &lt; 5, &quot;this must be less than length of actual vector&quot;);
1700 
1701   // Pop all arguments.
1702   for (int i = 0; i &lt; poplen; i++) {
1703     actual[i] = pop();
1704   }
1705   // Field _state is uninitialized when calling push.
1706   for (int i = poplen; i &lt; 5; i++) {
1707     actual[i] = CellTypeState::uninit;
1708   }
1709 
1710   // put them back
1711   char push_ch = *out++;
1712   while (push_ch != &#39;\0&#39;) {
1713     int idx = push_ch - &#39;1&#39;;
1714     assert(idx &gt;= 0 &amp;&amp; idx &lt; poplen, &quot;wrong arguments&quot;);
1715     push(actual[idx]);
1716     push_ch = *out++;
1717   }
1718 }
1719 
1720 void GenerateOopMap::ppop1(CellTypeState out) {
1721   CellTypeState actual = pop();
1722   check_type(out, actual);
1723 }
1724 
1725 void GenerateOopMap::ppop(CellTypeState *out) {
1726   while (!(*out).is_bottom()) {
1727     ppop1(*out++);
1728   }
1729 }
1730 
1731 void GenerateOopMap::ppush1(CellTypeState in) {
1732   assert(in.is_reference() || in.is_inline_type(), &quot;sanity check&quot;);
1733   push(in);
1734 }
1735 
1736 void GenerateOopMap::ppush(CellTypeState *in) {
1737   while (!(*in).is_bottom()) {
1738     ppush1(*in++);
1739   }
1740 }
1741 
1742 void GenerateOopMap::pp(CellTypeState *in, CellTypeState *out) {
1743   ppop(in);
1744   ppush(out);
1745 }
1746 
1747 void GenerateOopMap::pp_new_ref(CellTypeState *in, int bci) {
1748   ppop(in);
1749   ppush1(CellTypeState::make_line_ref(bci));
1750 }
1751 
1752 void GenerateOopMap::ppop_any(int poplen) {
1753   if (_stack_top &gt;= poplen) {
1754     _stack_top -= poplen;
1755   } else {
1756     verify_error(&quot;stack underflow&quot;);
1757   }
1758 }
1759 
1760 // Replace all occurences of the state &#39;match&#39; with the state &#39;replace&#39;
1761 // in our current state vector.
1762 void GenerateOopMap::replace_all_CTS_matches(CellTypeState match,
1763                                              CellTypeState replace) {
1764   int i;
1765   int len = _max_locals + _stack_top;
1766   bool change = false;
1767 
1768   for (i = len - 1; i &gt;= 0; i--) {
1769     if (match.equal(_state[i])) {
1770       _state[i] = replace;
1771     }
1772   }
1773 
1774   if (_monitor_top &gt; 0) {
1775     int base = _max_locals + _max_stack;
1776     len = base + _monitor_top;
1777     for (i = len - 1; i &gt;= base; i--) {
1778       if (match.equal(_state[i])) {
1779         _state[i] = replace;
1780       }
1781     }
1782   }
1783 }
1784 
1785 void GenerateOopMap::do_checkcast() {
1786   CellTypeState actual = pop();
1787   check_type(refCTS, actual);
1788   push(actual);
1789 }
1790 
1791 void GenerateOopMap::do_monitorenter(int bci) {
1792   CellTypeState actual = pop();
1793   if (_monitor_top == bad_monitors) {
1794     return;
1795   }
1796 
1797   // Bail out when we get repeated locks on an identical monitor.  This case
1798   // isn&#39;t too hard to handle and can be made to work if supporting nested
1799   // redundant synchronized statements becomes a priority.
1800   //
1801   // See also &quot;Note&quot; in do_monitorexit(), below.
1802   if (actual.is_lock_reference()) {
1803     _monitor_top = bad_monitors;
1804     _monitor_safe = false;
1805 
1806     if (log_is_enabled(Info, monitormismatch)) {
1807       report_monitor_mismatch(&quot;nested redundant lock -- bailout...&quot;);
1808     }
1809     return;
1810   }
1811 
1812   CellTypeState lock = CellTypeState::make_lock_ref(bci);
1813   check_type(refCTS, actual);
1814   if (!actual.is_info_top()) {
1815     replace_all_CTS_matches(actual, lock);
1816     monitor_push(lock);
1817   }
1818 }
1819 
1820 void GenerateOopMap::do_monitorexit(int bci) {
1821   CellTypeState actual = pop();
1822   if (_monitor_top == bad_monitors) {
1823     return;
1824   }
1825   check_type(refCTS, actual);
1826   CellTypeState expected = monitor_pop();
1827   if (!actual.is_lock_reference() || !expected.equal(actual)) {
1828     // The monitor we are exiting is not verifiably the one
1829     // on the top of our monitor stack.  This causes a monitor
1830     // mismatch.
1831     _monitor_top = bad_monitors;
1832     _monitor_safe = false;
1833 
1834     // We need to mark this basic block as changed so that
1835     // this monitorexit will be visited again.  We need to
1836     // do this to ensure that we have accounted for the
1837     // possibility that this bytecode will throw an
1838     // exception.
1839     BasicBlock* bb = get_basic_block_containing(bci);
1840     guarantee(bb != NULL, &quot;no basic block for bci&quot;);
1841     bb-&gt;set_changed(true);
1842     bb-&gt;_monitor_top = bad_monitors;
1843 
1844     if (log_is_enabled(Info, monitormismatch)) {
1845       report_monitor_mismatch(&quot;improper monitor pair&quot;);
1846     }
1847   } else {
1848     // This code is a fix for the case where we have repeated
1849     // locking of the same object in straightline code.  We clear
1850     // out the lock when it is popped from the monitor stack
1851     // and replace it with an unobtrusive reference value that can
1852     // be locked again.
1853     //
1854     // Note: when generateOopMap is fixed to properly handle repeated,
1855     //       nested, redundant locks on the same object, then this
1856     //       fix will need to be removed at that time.
1857     replace_all_CTS_matches(actual, CellTypeState::make_line_ref(bci));
1858   }
1859 }
1860 
1861 void GenerateOopMap::do_return_monitor_check() {
1862   if (_monitor_top &gt; 0) {
1863     // The monitor stack must be empty when we leave the method
1864     // for the monitors to be properly matched.
1865     _monitor_safe = false;
1866 
1867     // Since there are no successors to the *return bytecode, it
1868     // isn&#39;t necessary to set _monitor_top to bad_monitors.
1869 
1870     if (log_is_enabled(Info, monitormismatch)) {
1871       report_monitor_mismatch(&quot;non-empty monitor stack at return&quot;);
1872     }
1873   }
1874 }
1875 
1876 void GenerateOopMap::do_jsr(int targ_bci) {
1877   push(CellTypeState::make_addr(targ_bci));
1878 }
1879 
1880 
1881 
1882 void GenerateOopMap::do_ldc(int bci) {
1883   Bytecode_loadconstant ldc(methodHandle(Thread::current(), method()), bci);
1884   ConstantPool* cp  = method()-&gt;constants();
1885   constantTag tag = cp-&gt;tag_at(ldc.pool_index()); // idx is index in resolved_references
1886   BasicType       bt  = ldc.result_type();
1887 #ifdef ASSERT
1888   BasicType   tag_bt = (tag.is_dynamic_constant() || tag.is_dynamic_constant_in_error()) ? bt : tag.basic_type();
1889   assert(bt == tag_bt, &quot;same result&quot;);
1890 #endif
1891   CellTypeState   cts;
1892   if (is_reference_type(bt)) {  // could be T_ARRAY with condy
1893     assert(!tag.is_string_index() &amp;&amp; !tag.is_klass_index(), &quot;Unexpected index tag&quot;);
1894     cts = CellTypeState::make_line_ref(bci);
1895   } else {
1896     cts = valCTS;
1897   }
1898   ppush1(cts);
1899 }
1900 
1901 void GenerateOopMap::do_multianewarray(int dims, int bci) {
1902   assert(dims &gt;= 1, &quot;sanity check&quot;);
1903   for(int i = dims -1; i &gt;=0; i--) {
1904     ppop1(valCTS);
1905   }
1906   ppush1(CellTypeState::make_line_ref(bci));
1907 }
1908 
1909 void GenerateOopMap::do_astore(int idx) {
1910   CellTypeState r_or_p = pop();
1911   if (!r_or_p.is_address() &amp;&amp; !r_or_p.is_reference()) {
1912     // We actually expected ref or pc, but we only report that we expected a ref. It does not
1913     // really matter (at least for now)
1914     verify_error(&quot;wrong type on stack (found: %c, expected: {pr})&quot;, r_or_p.to_char());
1915     return;
1916   }
1917   set_var(idx, r_or_p);
1918 }
1919 
1920 // Copies bottom/zero terminated CTS string from &quot;src&quot; into &quot;dst&quot;.
1921 //   Does NOT terminate with a bottom. Returns the number of cells copied.
1922 int GenerateOopMap::copy_cts(CellTypeState *dst, CellTypeState *src) {
1923   int idx = 0;
1924   while (!src[idx].is_bottom()) {
1925     dst[idx] = src[idx];
1926     idx++;
1927   }
1928   return idx;
1929 }
1930 
1931 void GenerateOopMap::do_field(int is_get, int is_static, int idx, int bci) {
1932   // Dig up signature for field in constant pool
1933   ConstantPool* cp     = method()-&gt;constants();
1934   int nameAndTypeIdx     = cp-&gt;name_and_type_ref_index_at(idx);
1935   int signatureIdx       = cp-&gt;signature_ref_index_at(nameAndTypeIdx);
1936   Symbol* signature      = cp-&gt;symbol_at(signatureIdx);
1937 
1938   CellTypeState temp[4];
1939   CellTypeState *eff  = signature_to_effect(signature, bci, temp);
1940 
1941   CellTypeState in[4];
1942   CellTypeState *out;
1943   int i =  0;
1944 
1945   if (is_get) {
1946     out = eff;
1947   } else {
1948     out = epsilonCTS;
1949     i   = copy_cts(in, eff);
1950   }
1951   if (!is_static) {
1952     in[i++] = CellTypeState::ref;
1953   }
1954   in[i] = CellTypeState::bottom;
1955   assert(i&lt;=3, &quot;sanity check&quot;);
1956   pp(in, out);
1957 }
1958 
1959 void GenerateOopMap::do_method(int is_static, int idx, int bci) {
1960  // Dig up signature for field in constant pool
1961   ConstantPool* cp  = _method-&gt;constants();
1962   Symbol* signature   = cp-&gt;signature_ref_at(idx);
1963 
1964   // Parse method signature
1965   CellTypeState out[4];
1966   CellTypeState in[MAXARGSIZE+1];   // Includes result
1967   ComputeCallStack cse(signature);
1968 
1969   // Compute return type
1970   int res_length=  cse.compute_for_returntype(out);
1971 
1972   // Temporary hack.
1973   if (out[0].equal(CellTypeState::ref) &amp;&amp; out[1].equal(CellTypeState::bottom)) {
1974     out[0] = CellTypeState::make_line_ref(bci);
1975   }
1976 
1977   assert(res_length&lt;=4, &quot;max value should be vv&quot;);
1978 
1979   // Compute arguments
1980   int arg_length = cse.compute_for_parameters(is_static != 0, in);
1981   assert(arg_length&lt;=MAXARGSIZE, &quot;too many locals&quot;);
1982 
1983   // Pop arguments
1984   for (int i = arg_length - 1; i &gt;= 0; i--) ppop1(in[i]);// Do args in reverse order.
1985 
1986   // Report results
1987   if (_report_result_for_send == true) {
1988      fill_stackmap_for_opcodes(_itr_send, vars(), stack(), _stack_top);
1989      _report_result_for_send = false;
1990   }
1991 
1992   // Push return address
1993   ppush(out);
1994 }
1995 
1996 void GenerateOopMap::do_withfield(int idx, int bci) {
1997   // Dig up signature for field in constant pool
1998   ConstantPool* cp = method()-&gt;constants();
1999   int nameAndTypeIdx = cp-&gt;name_and_type_ref_index_at(idx);
2000   int signatureIdx = cp-&gt;signature_ref_index_at(nameAndTypeIdx);
2001   Symbol* signature = cp-&gt;symbol_at(signatureIdx);
2002 
2003   // Parse signature (especially simple for fields)
2004   assert(signature-&gt;utf8_length() &gt; 0,
2005       &quot;field signatures cannot have zero length&quot;);
2006   // The signature is UFT8 encoded, but the first char is always ASCII for signatures.
2007   CellTypeState temp[4];
2008   CellTypeState *eff = signature_to_effect(signature, bci, temp);
2009 
2010   CellTypeState in[4];
2011   int i = copy_cts(in, eff);
2012   in[i++] = CellTypeState::ref;
2013   in[i] = CellTypeState::bottom;
2014   assert(i &lt;= 3, &quot;sanity check&quot;);
2015 
2016   CellTypeState out[2];
2017   out[0] = CellTypeState::ref;
2018   out[1] = CellTypeState::bottom;
2019 
2020   pp(in, out);
2021 }
2022 
2023 // This is used to parse the signature for fields, since they are very simple...
2024 CellTypeState *GenerateOopMap::signature_to_effect(const Symbol* sig, int bci, CellTypeState *out) {
2025   // Object and array
2026   BasicType bt = Signature::basic_type(sig);
2027   if (is_reference_type(bt)) {
2028     out[0] = CellTypeState::make_line_ref(bci);
2029     out[1] = CellTypeState::bottom;
2030     return out;
2031   }
2032   if (is_double_word_type(bt)) return vvCTS; // Long and Double
2033   if (bt == T_VOID) return epsilonCTS;       // Void
2034   return vCTS;                               // Otherwise
2035 }
2036 
2037 long GenerateOopMap::_total_byte_count = 0;
2038 elapsedTimer GenerateOopMap::_total_oopmap_time;
2039 
2040 // This function assumes &quot;bcs&quot; is at a &quot;ret&quot; instruction and that the vars
2041 // state is valid for that instruction. Furthermore, the ret instruction
2042 // must be the last instruction in &quot;bb&quot; (we store information about the
2043 // &quot;ret&quot; in &quot;bb&quot;).
2044 void GenerateOopMap::ret_jump_targets_do(BytecodeStream *bcs, jmpFct_t jmpFct, int varNo, int *data) {
2045   CellTypeState ra = vars()[varNo];
2046   if (!ra.is_good_address()) {
2047     verify_error(&quot;ret returns from two jsr subroutines?&quot;);
2048     return;
2049   }
2050   int target = ra.get_info();
2051 
2052   RetTableEntry* rtEnt = _rt.find_jsrs_for_target(target);
2053   int bci = bcs-&gt;bci();
2054   for (int i = 0; i &lt; rtEnt-&gt;nof_jsrs(); i++) {
2055     int target_bci = rtEnt-&gt;jsrs(i);
2056     // Make sure a jrtRet does not set the changed bit for dead basicblock.
2057     BasicBlock* jsr_bb    = get_basic_block_containing(target_bci - 1);
2058     debug_only(BasicBlock* target_bb = &amp;jsr_bb[1];)
2059     assert(target_bb  == get_basic_block_at(target_bci), &quot;wrong calc. of successor basicblock&quot;);
2060     bool alive = jsr_bb-&gt;is_alive();
2061     if (TraceNewOopMapGeneration) {
2062       tty-&gt;print(&quot;pc = %d, ret -&gt; %d alive: %s\n&quot;, bci, target_bci, alive ? &quot;true&quot; : &quot;false&quot;);
2063     }
2064     if (alive) jmpFct(this, target_bci, data);
2065   }
2066 }
2067 
2068 //
2069 // Debug method
2070 //
2071 char* GenerateOopMap::state_vec_to_string(CellTypeState* vec, int len) {
2072 #ifdef ASSERT
2073   int checklen = MAX3(_max_locals, _max_stack, _max_monitors) + 1;
2074   assert(len &lt; checklen, &quot;state_vec_buf overflow&quot;);
2075 #endif
2076   for (int i = 0; i &lt; len; i++) _state_vec_buf[i] = vec[i].to_char();
2077   _state_vec_buf[len] = 0;
2078   return _state_vec_buf;
2079 }
2080 
2081 void GenerateOopMap::print_time() {
2082   tty-&gt;print_cr (&quot;Accumulated oopmap times:&quot;);
2083   tty-&gt;print_cr (&quot;---------------------------&quot;);
2084   tty-&gt;print_cr (&quot;  Total : %3.3f sec.&quot;, GenerateOopMap::_total_oopmap_time.seconds());
2085   tty-&gt;print_cr (&quot;  (%3.0f bytecodes per sec) &quot;,
2086   GenerateOopMap::_total_byte_count / GenerateOopMap::_total_oopmap_time.seconds());
2087 }
2088 
2089 //
2090 //  ============ Main Entry Point ===========
2091 //
2092 GenerateOopMap::GenerateOopMap(const methodHandle&amp; method) {
2093   // We have to initialize all variables here, that can be queried directly
2094   _method = method;
2095   _max_locals=0;
2096   _init_vars = NULL;
2097 
2098 #ifndef PRODUCT
2099   // If we are doing a detailed trace, include the regular trace information.
2100   if (TraceNewOopMapGenerationDetailed) {
2101     TraceNewOopMapGeneration = true;
2102   }
2103 #endif
2104 }
2105 
2106 void GenerateOopMap::compute_map(TRAPS) {
2107 #ifndef PRODUCT
2108   if (TimeOopMap2) {
2109     method()-&gt;print_short_name(tty);
2110     tty-&gt;print(&quot;  &quot;);
2111   }
2112   if (TimeOopMap) {
2113     _total_byte_count += method()-&gt;code_size();
2114   }
2115 #endif
2116   TraceTime t_single(&quot;oopmap time&quot;, TimeOopMap2);
2117   TraceTime t_all(NULL, &amp;_total_oopmap_time, TimeOopMap);
2118 
2119   // Initialize values
2120   _got_error      = false;
2121   _conflict       = false;
2122   _max_locals     = method()-&gt;max_locals();
2123   _max_stack      = method()-&gt;max_stack();
2124   _has_exceptions = (method()-&gt;has_exception_handler());
2125   _nof_refval_conflicts = 0;
2126   _init_vars      = new GrowableArray&lt;intptr_t&gt;(5);  // There are seldom more than 5 init_vars
2127   _report_result  = false;
2128   _report_result_for_send = false;
2129   _new_var_map    = NULL;
2130   _ret_adr_tos    = new GrowableArray&lt;intptr_t&gt;(5);  // 5 seems like a good number;
2131   _did_rewriting  = false;
2132   _did_relocation = false;
2133 
2134   if (TraceNewOopMapGeneration) {
2135     tty-&gt;print(&quot;Method name: %s\n&quot;, method()-&gt;name()-&gt;as_C_string());
2136     if (Verbose) {
2137       _method-&gt;print_codes();
2138       tty-&gt;print_cr(&quot;Exception table:&quot;);
2139       ExceptionTable excps(method());
2140       for(int i = 0; i &lt; excps.length(); i ++) {
2141         tty-&gt;print_cr(&quot;[%d - %d] -&gt; %d&quot;,
2142                       excps.start_pc(i), excps.end_pc(i), excps.handler_pc(i));
2143       }
2144     }
2145   }
2146 
2147   // if no code - do nothing
2148   // compiler needs info
2149   if (method()-&gt;code_size() == 0 || _max_locals + method()-&gt;max_stack() == 0) {
2150     fill_stackmap_prolog(0);
2151     fill_stackmap_epilog();
2152     return;
2153   }
2154   // Step 1: Compute all jump targets and their return value
2155   if (!_got_error)
2156     _rt.compute_ret_table(_method);
2157 
2158   // Step 2: Find all basic blocks and count GC points
2159   if (!_got_error)
2160     mark_bbheaders_and_count_gc_points();
2161 
2162   // Step 3: Calculate stack maps
2163   if (!_got_error)
2164     do_interpretation();
2165 
2166   // Step 4:Return results
2167   if (!_got_error &amp;&amp; report_results())
2168      report_result();
2169 
2170   if (_got_error) {
2171     THROW_HANDLE(_exception);
2172   }
2173 }
2174 
2175 // Error handling methods
2176 // These methods create an exception for the current thread which is thrown
2177 // at the bottom of the call stack, when it returns to compute_map().  The
2178 // _got_error flag controls execution.  NOT TODO: The VM exception propagation
2179 // mechanism using TRAPS/CHECKs could be used here instead but it would need
2180 // to be added as a parameter to every function and checked for every call.
2181 // The tons of extra code it would generate didn&#39;t seem worth the change.
2182 //
2183 void GenerateOopMap::error_work(const char *format, va_list ap) {
2184   _got_error = true;
2185   char msg_buffer[512];
2186   os::vsnprintf(msg_buffer, sizeof(msg_buffer), format, ap);
2187   // Append method name
2188   char msg_buffer2[512];
2189   os::snprintf(msg_buffer2, sizeof(msg_buffer2), &quot;%s in method %s&quot;, msg_buffer, method()-&gt;name()-&gt;as_C_string());
2190   if (Thread::current()-&gt;can_call_java()) {
2191     _exception = Exceptions::new_exception(Thread::current(),
2192                   vmSymbols::java_lang_LinkageError(), msg_buffer2);
2193   } else {
2194     // We cannot instantiate an exception object from a compiler thread.
2195     // Exit the VM with a useful error message.
2196     fatal(&quot;%s&quot;, msg_buffer2);
2197   }
2198 }
2199 
2200 void GenerateOopMap::report_error(const char *format, ...) {
2201   va_list ap;
2202   va_start(ap, format);
2203   error_work(format, ap);
2204 }
2205 
2206 void GenerateOopMap::verify_error(const char *format, ...) {
2207   // We do not distinguish between different types of errors for verification
2208   // errors.  Let the verifier give a better message.
2209   report_error(&quot;Illegal class file encountered. Try running with -Xverify:all&quot;);
2210 }
2211 
2212 //
2213 // Report result opcodes
2214 //
2215 void GenerateOopMap::report_result() {
2216 
2217   if (TraceNewOopMapGeneration) tty-&gt;print_cr(&quot;Report result pass&quot;);
2218 
2219   // We now want to report the result of the parse
2220   _report_result = true;
2221 
2222   // Prolog code
2223   fill_stackmap_prolog(_gc_points);
2224 
2225    // Mark everything changed, then do one interpretation pass.
2226   for (int i = 0; i&lt;_bb_count; i++) {
2227     if (_basic_blocks[i].is_reachable()) {
2228       _basic_blocks[i].set_changed(true);
2229       interp_bb(&amp;_basic_blocks[i]);
2230     }
2231   }
2232 
2233   // Note: Since we are skipping dead-code when we are reporting results, then
2234   // the no. of encountered gc-points might be fewer than the previously number
2235   // we have counted. (dead-code is a pain - it should be removed before we get here)
2236   fill_stackmap_epilog();
2237 
2238   // Report initvars
2239   fill_init_vars(_init_vars);
2240 
2241   _report_result = false;
2242 }
2243 
2244 void GenerateOopMap::result_for_basicblock(int bci) {
2245  if (TraceNewOopMapGeneration) tty-&gt;print_cr(&quot;Report result pass for basicblock&quot;);
2246 
2247   // We now want to report the result of the parse
2248   _report_result = true;
2249 
2250   // Find basicblock and report results
2251   BasicBlock* bb = get_basic_block_containing(bci);
2252   guarantee(bb != NULL, &quot;no basic block for bci&quot;);
2253   assert(bb-&gt;is_reachable(), &quot;getting result from unreachable basicblock&quot;);
2254   bb-&gt;set_changed(true);
2255   interp_bb(bb);
2256 }
2257 
2258 //
2259 // Conflict handling code
2260 //
2261 
2262 void GenerateOopMap::record_refval_conflict(int varNo) {
2263   assert(varNo&gt;=0 &amp;&amp; varNo&lt; _max_locals, &quot;index out of range&quot;);
2264 
2265   if (TraceOopMapRewrites) {
2266      tty-&gt;print(&quot;### Conflict detected (local no: %d)\n&quot;, varNo);
2267   }
2268 
2269   if (!_new_var_map) {
2270     _new_var_map = NEW_RESOURCE_ARRAY(int, _max_locals);
2271     for (int k = 0; k &lt; _max_locals; k++)  _new_var_map[k] = k;
2272   }
2273 
2274   if ( _new_var_map[varNo] == varNo) {
2275     // Check if max. number of locals has been reached
2276     if (_max_locals + _nof_refval_conflicts &gt;= MAX_LOCAL_VARS) {
2277       report_error(&quot;Rewriting exceeded local variable limit&quot;);
2278       return;
2279     }
2280     _new_var_map[varNo] = _max_locals + _nof_refval_conflicts;
2281     _nof_refval_conflicts++;
2282   }
2283 }
2284 
2285 void GenerateOopMap::rewrite_refval_conflicts()
2286 {
2287   // We can get here two ways: Either a rewrite conflict was detected, or
2288   // an uninitialize reference was detected. In the second case, we do not
2289   // do any rewriting, we just want to recompute the reference set with the
2290   // new information
2291 
2292   int nof_conflicts = 0;              // Used for debugging only
2293 
2294   if ( _nof_refval_conflicts == 0 )
2295      return;
2296 
2297   // Check if rewrites are allowed in this parse.
2298   if (!allow_rewrites() &amp;&amp; !IgnoreRewrites) {
2299     fatal(&quot;Rewriting method not allowed at this stage&quot;);
2300   }
2301 
2302 
2303   // This following flag is to tempoary supress rewrites. The locals that might conflict will
2304   // all be set to contain values. This is UNSAFE - however, until the rewriting has been completely
2305   // tested it is nice to have.
2306   if (IgnoreRewrites) {
2307     if (Verbose) {
2308        tty-&gt;print(&quot;rewrites suppressed for local no. &quot;);
2309        for (int l = 0; l &lt; _max_locals; l++) {
2310          if (_new_var_map[l] != l) {
2311            tty-&gt;print(&quot;%d &quot;, l);
2312            vars()[l] = CellTypeState::value;
2313          }
2314        }
2315        tty-&gt;cr();
2316     }
2317 
2318     // That was that...
2319     _new_var_map = NULL;
2320     _nof_refval_conflicts = 0;
2321     _conflict = false;
2322 
2323     return;
2324   }
2325 
2326   // Tracing flag
2327   _did_rewriting = true;
2328 
2329   if (TraceOopMapRewrites) {
2330     tty-&gt;print_cr(&quot;ref/value conflict for method %s - bytecodes are getting rewritten&quot;, method()-&gt;name()-&gt;as_C_string());
2331     method()-&gt;print();
2332     method()-&gt;print_codes();
2333   }
2334 
2335   assert(_new_var_map!=NULL, &quot;nothing to rewrite&quot;);
2336   assert(_conflict==true, &quot;We should not be here&quot;);
2337 
2338   compute_ret_adr_at_TOS();
2339   if (!_got_error) {
2340     for (int k = 0; k &lt; _max_locals &amp;&amp; !_got_error; k++) {
2341       if (_new_var_map[k] != k) {
2342         if (TraceOopMapRewrites) {
2343           tty-&gt;print_cr(&quot;Rewriting: %d -&gt; %d&quot;, k, _new_var_map[k]);
2344         }
2345         rewrite_refval_conflict(k, _new_var_map[k]);
2346         if (_got_error) return;
2347         nof_conflicts++;
2348       }
2349     }
2350   }
2351 
2352   assert(nof_conflicts == _nof_refval_conflicts, &quot;sanity check&quot;);
2353 
2354   // Adjust the number of locals
2355   method()-&gt;set_max_locals(_max_locals+_nof_refval_conflicts);
2356   _max_locals += _nof_refval_conflicts;
2357 
2358   // That was that...
2359   _new_var_map = NULL;
2360   _nof_refval_conflicts = 0;
2361 }
2362 
2363 void GenerateOopMap::rewrite_refval_conflict(int from, int to) {
2364   bool startOver;
2365   do {
2366     // Make sure that the BytecodeStream is constructed in the loop, since
2367     // during rewriting a new method oop is going to be used, and the next time
2368     // around we want to use that.
2369     BytecodeStream bcs(_method);
2370     startOver = false;
2371 
2372     while( !startOver &amp;&amp; !_got_error &amp;&amp;
2373            // test bcs in case method changed and it became invalid
2374            bcs.next() &gt;=0) {
2375       startOver = rewrite_refval_conflict_inst(&amp;bcs, from, to);
2376     }
2377   } while (startOver &amp;&amp; !_got_error);
2378 }
2379 
2380 /* If the current instruction is one that uses local variable &quot;from&quot;
2381    in a ref way, change it to use &quot;to&quot;. There&#39;s a subtle reason why we
2382    renumber the ref uses and not the non-ref uses: non-ref uses may be
2383    2 slots wide (double, long) which would necessitate keeping track of
2384    whether we should add one or two variables to the method. If the change
2385    affected the width of some instruction, returns &quot;TRUE&quot;; otherwise, returns &quot;FALSE&quot;.
2386    Another reason for moving ref&#39;s value is for solving (addr, ref) conflicts, which
2387    both uses aload/astore methods.
2388 */
2389 bool GenerateOopMap::rewrite_refval_conflict_inst(BytecodeStream *itr, int from, int to) {
2390   Bytecodes::Code bc = itr-&gt;code();
2391   int index;
2392   int bci = itr-&gt;bci();
2393 
2394   if (is_aload(itr, &amp;index) &amp;&amp; index == from) {
2395     if (TraceOopMapRewrites) {
2396       tty-&gt;print_cr(&quot;Rewriting aload at bci: %d&quot;, bci);
2397     }
2398     return rewrite_load_or_store(itr, Bytecodes::_aload, Bytecodes::_aload_0, to);
2399   }
2400 
2401   if (is_astore(itr, &amp;index) &amp;&amp; index == from) {
2402     if (!stack_top_holds_ret_addr(bci)) {
2403       if (TraceOopMapRewrites) {
2404         tty-&gt;print_cr(&quot;Rewriting astore at bci: %d&quot;, bci);
2405       }
2406       return rewrite_load_or_store(itr, Bytecodes::_astore, Bytecodes::_astore_0, to);
2407     } else {
2408       if (TraceOopMapRewrites) {
2409         tty-&gt;print_cr(&quot;Supress rewriting of astore at bci: %d&quot;, bci);
2410       }
2411     }
2412   }
2413 
2414   return false;
2415 }
2416 
2417 // The argument to this method is:
2418 // bc : Current bytecode
2419 // bcN : either _aload or _astore
2420 // bc0 : either _aload_0 or _astore_0
2421 bool GenerateOopMap::rewrite_load_or_store(BytecodeStream *bcs, Bytecodes::Code bcN, Bytecodes::Code bc0, unsigned int varNo) {
2422   assert(bcN == Bytecodes::_astore   || bcN == Bytecodes::_aload,   &quot;wrong argument (bcN)&quot;);
2423   assert(bc0 == Bytecodes::_astore_0 || bc0 == Bytecodes::_aload_0, &quot;wrong argument (bc0)&quot;);
2424   int ilen = Bytecodes::length_at(_method(), bcs-&gt;bcp());
2425   int newIlen;
2426 
2427   if (ilen == 4) {
2428     // Original instruction was wide; keep it wide for simplicity
2429     newIlen = 4;
2430   } else if (varNo &lt; 4)
2431      newIlen = 1;
2432   else if (varNo &gt;= 256)
2433      newIlen = 4;
2434   else
2435      newIlen = 2;
2436 
2437   // If we need to relocate in order to patch the byte, we
2438   // do the patching in a temp. buffer, that is passed to the reloc.
2439   // The patching of the bytecode stream is then done by the Relocator.
2440   // This is neccesary, since relocating the instruction at a certain bci, might
2441   // also relocate that instruction, e.g., if a _goto before it gets widen to a _goto_w.
2442   // Hence, we do not know which bci to patch after relocation.
2443 
2444   assert(newIlen &lt;= 4, &quot;sanity check&quot;);
2445   u_char inst_buffer[4]; // Max. instruction size is 4.
2446   address bcp;
2447 
2448   if (newIlen != ilen) {
2449     // Relocation needed do patching in temp. buffer
2450     bcp = (address)inst_buffer;
2451   } else {
2452     bcp = _method-&gt;bcp_from(bcs-&gt;bci());
2453   }
2454 
2455   // Patch either directly in Method* or in temp. buffer
2456   if (newIlen == 1) {
2457     assert(varNo &lt; 4, &quot;varNo too large&quot;);
2458     *bcp = bc0 + varNo;
2459   } else if (newIlen == 2) {
2460     assert(varNo &lt; 256, &quot;2-byte index needed!&quot;);
2461     *(bcp + 0) = bcN;
2462     *(bcp + 1) = varNo;
2463   } else {
2464     assert(newIlen == 4, &quot;Wrong instruction length&quot;);
2465     *(bcp + 0) = Bytecodes::_wide;
2466     *(bcp + 1) = bcN;
2467     Bytes::put_Java_u2(bcp+2, varNo);
2468   }
2469 
2470   if (newIlen != ilen) {
2471     expand_current_instr(bcs-&gt;bci(), ilen, newIlen, inst_buffer);
2472   }
2473 
2474 
2475   return (newIlen != ilen);
2476 }
2477 
2478 class RelocCallback : public RelocatorListener {
2479  private:
2480   GenerateOopMap* _gom;
2481  public:
2482    RelocCallback(GenerateOopMap* gom) { _gom = gom; };
2483 
2484   // Callback method
2485   virtual void relocated(int bci, int delta, int new_code_length) {
2486     _gom-&gt;update_basic_blocks  (bci, delta, new_code_length);
2487     _gom-&gt;update_ret_adr_at_TOS(bci, delta);
2488     _gom-&gt;_rt.update_ret_table (bci, delta);
2489   }
2490 };
2491 
2492 // Returns true if expanding was succesful. Otherwise, reports an error and
2493 // returns false.
2494 void GenerateOopMap::expand_current_instr(int bci, int ilen, int newIlen, u_char inst_buffer[]) {
2495   Thread *THREAD = Thread::current();  // Could really have TRAPS argument.
2496   RelocCallback rcb(this);
2497   Relocator rc(_method, &amp;rcb);
2498   methodHandle m= rc.insert_space_at(bci, newIlen, inst_buffer, THREAD);
2499   if (m.is_null() || HAS_PENDING_EXCEPTION) {
2500     report_error(&quot;could not rewrite method - exception occurred or bytecode buffer overflow&quot;);
2501     return;
2502   }
2503 
2504   // Relocator returns a new method oop.
2505   _did_relocation = true;
2506   _method = m;
2507 }
2508 
2509 
2510 bool GenerateOopMap::is_astore(BytecodeStream *itr, int *index) {
2511   Bytecodes::Code bc = itr-&gt;code();
2512   switch(bc) {
2513     case Bytecodes::_astore_0:
2514     case Bytecodes::_astore_1:
2515     case Bytecodes::_astore_2:
2516     case Bytecodes::_astore_3:
2517       *index = bc - Bytecodes::_astore_0;
2518       return true;
2519     case Bytecodes::_astore:
2520       *index = itr-&gt;get_index();
2521       return true;
2522     default:
2523       return false;
2524   }
2525 }
2526 
2527 bool GenerateOopMap::is_aload(BytecodeStream *itr, int *index) {
2528   Bytecodes::Code bc = itr-&gt;code();
2529   switch(bc) {
2530     case Bytecodes::_aload_0:
2531     case Bytecodes::_aload_1:
2532     case Bytecodes::_aload_2:
2533     case Bytecodes::_aload_3:
2534       *index = bc - Bytecodes::_aload_0;
2535       return true;
2536 
2537     case Bytecodes::_aload:
2538       *index = itr-&gt;get_index();
2539       return true;
2540 
2541     default:
2542       return false;
2543   }
2544 }
2545 
2546 
2547 // Return true iff the top of the operand stack holds a return address at
2548 // the current instruction
2549 bool GenerateOopMap::stack_top_holds_ret_addr(int bci) {
2550   for(int i = 0; i &lt; _ret_adr_tos-&gt;length(); i++) {
2551     if (_ret_adr_tos-&gt;at(i) == bci)
2552       return true;
2553   }
2554 
2555   return false;
2556 }
2557 
2558 void GenerateOopMap::compute_ret_adr_at_TOS() {
2559   assert(_ret_adr_tos != NULL, &quot;must be initialized&quot;);
2560   _ret_adr_tos-&gt;clear();
2561 
2562   for (int i = 0; i &lt; bb_count(); i++) {
2563     BasicBlock* bb = &amp;_basic_blocks[i];
2564 
2565     // Make sure to only check basicblocks that are reachable
2566     if (bb-&gt;is_reachable()) {
2567 
2568       // For each Basic block we check all instructions
2569       BytecodeStream bcs(_method);
2570       bcs.set_interval(bb-&gt;_bci, next_bb_start_pc(bb));
2571 
2572       restore_state(bb);
2573 
2574       while (bcs.next()&gt;=0 &amp;&amp; !_got_error) {
2575         // TDT: should this be is_good_address() ?
2576         if (_stack_top &gt; 0 &amp;&amp; stack()[_stack_top-1].is_address()) {
2577           _ret_adr_tos-&gt;append(bcs.bci());
2578           if (TraceNewOopMapGeneration) {
2579             tty-&gt;print_cr(&quot;Ret_adr TOS at bci: %d&quot;, bcs.bci());
2580           }
2581         }
2582         interp1(&amp;bcs);
2583       }
2584     }
2585   }
2586 }
2587 
2588 void GenerateOopMap::update_ret_adr_at_TOS(int bci, int delta) {
2589   for(int i = 0; i &lt; _ret_adr_tos-&gt;length(); i++) {
2590     int v = _ret_adr_tos-&gt;at(i);
2591     if (v &gt; bci)  _ret_adr_tos-&gt;at_put(i, v + delta);
2592   }
2593 }
2594 
2595 // ===================================================================
2596 
2597 #ifndef PRODUCT
2598 int ResolveOopMapConflicts::_nof_invocations  = 0;
2599 int ResolveOopMapConflicts::_nof_rewrites     = 0;
2600 int ResolveOopMapConflicts::_nof_relocations  = 0;
2601 #endif
2602 
2603 methodHandle ResolveOopMapConflicts::do_potential_rewrite(TRAPS) {
2604   compute_map(CHECK_(methodHandle()));
2605 
2606 #ifndef PRODUCT
2607   // Tracking and statistics
2608   if (PrintRewrites) {
2609     _nof_invocations++;
2610     if (did_rewriting()) {
2611       _nof_rewrites++;
2612       if (did_relocation()) _nof_relocations++;
2613       tty-&gt;print(&quot;Method was rewritten %s: &quot;, (did_relocation()) ? &quot;and relocated&quot; : &quot;&quot;);
2614       method()-&gt;print_value(); tty-&gt;cr();
2615       tty-&gt;print_cr(&quot;Cand.: %d rewrts: %d (%d%%) reloc.: %d (%d%%)&quot;,
2616           _nof_invocations,
2617           _nof_rewrites,    (_nof_rewrites    * 100) / _nof_invocations,
2618           _nof_relocations, (_nof_relocations * 100) / _nof_invocations);
2619     }
2620   }
2621 #endif
2622   return methodHandle(THREAD, method());
2623 }
    </pre>
  </body>
</html>
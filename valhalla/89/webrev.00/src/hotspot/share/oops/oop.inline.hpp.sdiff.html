<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/oop.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="oop.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueArrayKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/oop.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
230       // disjunct below to fail if the two comparands are computed across such
231       // a concurrent change.
232       assert((s == klass-&gt;oop_size(this)) ||
233              (Universe::heap()-&gt;is_gc_active() &amp;&amp; is_objArray() &amp;&amp; is_forwarded() &amp;&amp; (UseParallelGC || UseG1GC)),
234              &quot;wrong array object size&quot;);
235     } else {
236       // Must be zero, so bite the bullet and take the virtual call.
237       s = klass-&gt;oop_size(this);
238     }
239   }
240 
241   assert(s &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, s);
242   assert(is_object_aligned(s), &quot;Oop size is not properly aligned: %d&quot;, s);
243   return s;
244 }
245 
246 bool oopDesc::is_instance()  const { return klass()-&gt;is_instance_klass();  }
247 bool oopDesc::is_array()     const { return klass()-&gt;is_array_klass();     }
248 bool oopDesc::is_objArray()  const { return klass()-&gt;is_objArray_klass();  }
249 bool oopDesc::is_typeArray() const { return klass()-&gt;is_typeArray_klass(); }
<span class="line-modified">250 bool oopDesc::is_value()     const { return klass()-&gt;is_value(); }</span>
251 bool oopDesc::is_valueArray()  const { return klass()-&gt;is_valueArray_klass(); }
252 
253 void*    oopDesc::field_addr_raw(int offset)     const { return reinterpret_cast&lt;void*&gt;(cast_from_oop&lt;intptr_t&gt;(as_oop()) + offset); }
254 void*    oopDesc::field_addr(int offset)         const { return Access&lt;&gt;::resolve(as_oop())-&gt;field_addr_raw(offset); }
255 
256 template &lt;class T&gt;
257 T*       oopDesc::obj_field_addr_raw(int offset) const { return (T*) field_addr_raw(offset); }
258 
259 template &lt;typename T&gt;
260 size_t   oopDesc::field_offset(T* p) const { return pointer_delta((void*)p, (void*)this, 1); }
261 
262 template &lt;DecoratorSet decorators&gt;
263 inline oop  oopDesc::obj_field_access(int offset) const             { return HeapAccess&lt;decorators&gt;::oop_load_at(as_oop(), offset); }
264 inline oop  oopDesc::obj_field(int offset) const                    { return HeapAccess&lt;&gt;::oop_load_at(as_oop(), offset);  }
265 
266 inline void oopDesc::obj_field_put(int offset, oop value)           { HeapAccess&lt;&gt;::oop_store_at(as_oop(), offset, value); }
267 
268 inline jbyte oopDesc::byte_field(int offset) const                  { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
269 inline void  oopDesc::byte_field_put(int offset, jbyte value)       { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
270 
</pre>
</td>
<td>
<hr />
<pre>
230       // disjunct below to fail if the two comparands are computed across such
231       // a concurrent change.
232       assert((s == klass-&gt;oop_size(this)) ||
233              (Universe::heap()-&gt;is_gc_active() &amp;&amp; is_objArray() &amp;&amp; is_forwarded() &amp;&amp; (UseParallelGC || UseG1GC)),
234              &quot;wrong array object size&quot;);
235     } else {
236       // Must be zero, so bite the bullet and take the virtual call.
237       s = klass-&gt;oop_size(this);
238     }
239   }
240 
241   assert(s &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, s);
242   assert(is_object_aligned(s), &quot;Oop size is not properly aligned: %d&quot;, s);
243   return s;
244 }
245 
246 bool oopDesc::is_instance()  const { return klass()-&gt;is_instance_klass();  }
247 bool oopDesc::is_array()     const { return klass()-&gt;is_array_klass();     }
248 bool oopDesc::is_objArray()  const { return klass()-&gt;is_objArray_klass();  }
249 bool oopDesc::is_typeArray() const { return klass()-&gt;is_typeArray_klass(); }
<span class="line-modified">250 bool oopDesc::is_inline_type() const { return klass()-&gt;is_inline_klass(); }</span>
251 bool oopDesc::is_valueArray()  const { return klass()-&gt;is_valueArray_klass(); }
252 
253 void*    oopDesc::field_addr_raw(int offset)     const { return reinterpret_cast&lt;void*&gt;(cast_from_oop&lt;intptr_t&gt;(as_oop()) + offset); }
254 void*    oopDesc::field_addr(int offset)         const { return Access&lt;&gt;::resolve(as_oop())-&gt;field_addr_raw(offset); }
255 
256 template &lt;class T&gt;
257 T*       oopDesc::obj_field_addr_raw(int offset) const { return (T*) field_addr_raw(offset); }
258 
259 template &lt;typename T&gt;
260 size_t   oopDesc::field_offset(T* p) const { return pointer_delta((void*)p, (void*)this, 1); }
261 
262 template &lt;DecoratorSet decorators&gt;
263 inline oop  oopDesc::obj_field_access(int offset) const             { return HeapAccess&lt;decorators&gt;::oop_load_at(as_oop(), offset); }
264 inline oop  oopDesc::obj_field(int offset) const                    { return HeapAccess&lt;&gt;::oop_load_at(as_oop(), offset);  }
265 
266 inline void oopDesc::obj_field_put(int offset, oop value)           { HeapAccess&lt;&gt;::oop_store_at(as_oop(), offset, value); }
267 
268 inline jbyte oopDesc::byte_field(int offset) const                  { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
269 inline void  oopDesc::byte_field_put(int offset, jbyte value)       { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
270 
</pre>
</td>
</tr>
</table>
<center><a href="oop.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueArrayKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
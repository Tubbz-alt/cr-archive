<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/generateOopMap.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="generateOopMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/generateOopMap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
184   bool is_bottom() const                { return _state == 0; }
185   bool is_live() const                  { return ((_state &amp; live_bits_mask) != 0); }
186   bool is_valid_state() const {
187     // Uninitialized and value cells must contain no data in their info field:
188     if ((can_be_uninit() || can_be_value()) &amp;&amp; !is_info_top()) {
189       return false;
190     }
191     // The top bit is only set when all info bits are set:
192     if (is_info_top() &amp;&amp; ((_state &amp; info_mask) != info_mask)) {
193       return false;
194     }
195     // The not_bottom_bit must be set when any other info bit is set:
196     if (is_info_bottom() &amp;&amp; ((_state &amp; info_mask) != 0)) {
197       return false;
198     }
199     return true;
200   }
201 
202   bool is_address() const               { return ((_state &amp; bits_mask) == addr_bit); }
203   bool is_reference() const             { return ((_state &amp; bits_mask) == ref_bit); }
<span class="line-modified">204   bool is_value() const                 { return ((_state &amp; bits_mask) == val_bit); }</span>
205   bool is_uninit() const                { return ((_state &amp; bits_mask) == (uint)uninit_bit); }
206 
207   bool can_be_address() const           { return ((_state &amp; addr_bit) != 0); }
208   bool can_be_reference() const         { return ((_state &amp; ref_bit) != 0); }
209   bool can_be_value() const             { return ((_state &amp; val_bit) != 0); }
210   bool can_be_uninit() const            { return ((_state &amp; uninit_bit) != 0); }
211 
212   bool is_info_bottom() const           { return ((_state &amp; not_bottom_info_bit) == 0); }
213   bool is_info_top() const              { return ((_state &amp; top_info_bit) != 0); }
214   int  get_info() const {
215     assert((!is_info_top() &amp;&amp; !is_info_bottom()),
216            &quot;check to make sure top/bottom info is not used&quot;);
217     return (_state &amp; info_data_mask);
218   }
219 
220   bool is_good_address() const          { return is_address() &amp;&amp; !is_info_top(); }
221   bool is_lock_reference() const {
222     return ((_state &amp; (bits_mask | top_info_bit | ref_not_lock_bit)) == ref_bit);
223   }
224   bool is_nonlock_reference() const {
</pre>
</td>
<td>
<hr />
<pre>
184   bool is_bottom() const                { return _state == 0; }
185   bool is_live() const                  { return ((_state &amp; live_bits_mask) != 0); }
186   bool is_valid_state() const {
187     // Uninitialized and value cells must contain no data in their info field:
188     if ((can_be_uninit() || can_be_value()) &amp;&amp; !is_info_top()) {
189       return false;
190     }
191     // The top bit is only set when all info bits are set:
192     if (is_info_top() &amp;&amp; ((_state &amp; info_mask) != info_mask)) {
193       return false;
194     }
195     // The not_bottom_bit must be set when any other info bit is set:
196     if (is_info_bottom() &amp;&amp; ((_state &amp; info_mask) != 0)) {
197       return false;
198     }
199     return true;
200   }
201 
202   bool is_address() const               { return ((_state &amp; bits_mask) == addr_bit); }
203   bool is_reference() const             { return ((_state &amp; bits_mask) == ref_bit); }
<span class="line-modified">204   bool is_inline_type() const           { return ((_state &amp; bits_mask) == val_bit); }</span>
205   bool is_uninit() const                { return ((_state &amp; bits_mask) == (uint)uninit_bit); }
206 
207   bool can_be_address() const           { return ((_state &amp; addr_bit) != 0); }
208   bool can_be_reference() const         { return ((_state &amp; ref_bit) != 0); }
209   bool can_be_value() const             { return ((_state &amp; val_bit) != 0); }
210   bool can_be_uninit() const            { return ((_state &amp; uninit_bit) != 0); }
211 
212   bool is_info_bottom() const           { return ((_state &amp; not_bottom_info_bit) == 0); }
213   bool is_info_top() const              { return ((_state &amp; top_info_bit) != 0); }
214   int  get_info() const {
215     assert((!is_info_top() &amp;&amp; !is_info_bottom()),
216            &quot;check to make sure top/bottom info is not used&quot;);
217     return (_state &amp; info_data_mask);
218   }
219 
220   bool is_good_address() const          { return is_address() &amp;&amp; !is_info_top(); }
221   bool is_lock_reference() const {
222     return ((_state &amp; (bits_mask | top_info_bit | ref_not_lock_bit)) == ref_bit);
223   }
224   bool is_nonlock_reference() const {
</pre>
</td>
</tr>
</table>
<center><a href="generateOopMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="generateOopMap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1000   {
1001     ResourceMark rm(THREAD);
1002     for (int i = 0; i &lt; methods()-&gt;length(); i++) {
1003       Method* m = methods()-&gt;at(i);
1004       for (SignatureStream ss(m-&gt;signature()); !ss.is_done(); ss.next()) {
1005         if (ss.is_reference()) {
1006           if (ss.is_array()) {
1007             ss.skip_array_prefix();
1008           }
1009           if (ss.type() == T_VALUETYPE) {
1010             Symbol* symb = ss.as_symbol();
1011 
1012             oop loader = class_loader();
1013             oop protection_domain = this-&gt;protection_domain();
1014             Klass* klass = SystemDictionary::resolve_or_fail(symb,
1015                                                              Handle(THREAD, loader), Handle(THREAD, protection_domain), true,
1016                                                              CHECK_false);
1017             if (klass == NULL) {
1018               THROW_(vmSymbols::java_lang_LinkageError(), false);
1019             }
<span class="line-modified">1020             if (!klass-&gt;is_value()) {</span>
1021               Exceptions::fthrow(
1022                 THREAD_AND_LOCATION,
1023                 vmSymbols::java_lang_IncompatibleClassChangeError(),
1024                 &quot;class %s is not an inline type&quot;,
1025                 klass-&gt;external_name());
1026             }
1027           }
1028         }
1029       }
1030     }
1031   }
1032 
1033   // in case the class is linked in the process of linking its superclasses
1034   if (is_linked()) {
1035     return true;
1036   }
1037 
1038   // trace only the link time for this klass that includes
1039   // the verification time
1040   PerfClassTraceTime vmtimer(ClassLoader::perf_class_link_time(),
</pre>
<hr />
<pre>
1253       DTRACE_CLASSINIT_PROBE_WAIT(super__failed, -1, wait);
1254       THROW_OOP(e());
1255     }
1256   }
1257 
1258   // Step 8
1259   // Initialize classes of inline fields
1260   {
1261     for (AllFieldStream fs(this); !fs.done(); fs.next()) {
1262       if (Signature::basic_type(fs.signature()) == T_VALUETYPE) {
1263         Klass* klass = this-&gt;get_value_field_klass_or_null(fs.index());
1264         if (klass == NULL) {
1265           assert(fs.access_flags().is_static(), &quot;Otherwise should have been pre-loaded&quot;);
1266           klass = SystemDictionary::resolve_or_fail(field_signature(fs.index())-&gt;fundamental_name(THREAD),
1267               Handle(THREAD, class_loader()),
1268               Handle(THREAD, protection_domain()),
1269               true, CHECK);
1270           if (klass == NULL) {
1271             THROW(vmSymbols::java_lang_NoClassDefFoundError());
1272           }
<span class="line-modified">1273           if (!klass-&gt;is_value()) {</span>
1274             THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
1275           }
1276           this-&gt;set_value_field_klass(fs.index(), klass);
1277         }
1278         InstanceKlass::cast(klass)-&gt;initialize(CHECK);
1279         if (fs.access_flags().is_static()) {
1280           if (java_mirror()-&gt;obj_field(fs.offset()) == NULL) {
1281             java_mirror()-&gt;obj_field_put(fs.offset(), ValueKlass::cast(klass)-&gt;default_value());
1282           }
1283         }
1284       }
1285     }
1286   }
1287 
1288 
1289   // Look for aot compiled methods for this klass, including class initializer.
1290   AOTLoader::load_for_klass(this, THREAD);
1291 
1292   // Step 9
1293   {
</pre>
<hr />
<pre>
1703 Klass* InstanceKlass::find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const {
1704   // search order according to newest JVM spec (5.4.3.2, p.167).
1705   // 1) search for field in current klass
1706   if (find_local_field(name, sig, fd)) {
1707     if (fd-&gt;is_static() == is_static) return const_cast&lt;InstanceKlass*&gt;(this);
1708   }
1709   // 2) search for field recursively in direct superinterfaces
1710   if (is_static) {
1711     Klass* intf = find_interface_field(name, sig, fd);
1712     if (intf != NULL) return intf;
1713   }
1714   // 3) apply field lookup recursively if superclass exists
1715   { Klass* supr = super();
1716     if (supr != NULL) return InstanceKlass::cast(supr)-&gt;find_field(name, sig, is_static, fd);
1717   }
1718   // 4) otherwise field lookup fails
1719   return NULL;
1720 }
1721 
1722 bool InstanceKlass::contains_field_offset(int offset) {
<span class="line-modified">1723   if (this-&gt;is_value()) {</span>
1724     ValueKlass* vk = ValueKlass::cast(this);
1725     return offset &gt;= vk-&gt;first_field_offset() &amp;&amp; offset &lt; (vk-&gt;first_field_offset() + vk-&gt;get_exact_size_in_bytes());
1726   } else {
1727     fieldDescriptor fd;
1728     return find_field_from_offset(offset, false, &amp;fd);
1729   }
1730 }
1731 
1732 bool InstanceKlass::find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1733   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1734     if (fs.offset() == offset) {
1735       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1736       if (fd-&gt;is_static() == is_static) return true;
1737     }
1738   }
1739   return false;
1740 }
1741 
1742 
1743 bool InstanceKlass::find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
</pre>
<hr />
<pre>
2680 }
2681 
2682 void InstanceKlass::remove_java_mirror() {
2683   Klass::remove_java_mirror();
2684 
2685   // do array classes also.
2686   if (array_klasses() != NULL) {
2687     array_klasses()-&gt;remove_java_mirror();
2688   }
2689 }
2690 
2691 void InstanceKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain,
2692                                              PackageEntry* pkg_entry, TRAPS) {
2693   // SystemDictionary::add_to_hierarchy() sets the init_state to loaded
2694   // before the InstanceKlass is added to the SystemDictionary. Make
2695   // sure the current state is &lt;loaded.
2696   assert(!is_loaded(), &quot;invalid init state&quot;);
2697   set_package(loader_data, pkg_entry, CHECK);
2698   Klass::restore_unshareable_info(loader_data, protection_domain, CHECK);
2699 
<span class="line-modified">2700   if (is_value()) {</span>
2701     ValueKlass::cast(this)-&gt;initialize_calling_convention(CHECK);
2702   }
2703 
2704   Array&lt;Method*&gt;* methods = this-&gt;methods();
2705   int num_methods = methods-&gt;length();
2706   for (int index = 0; index &lt; num_methods; ++index) {
2707     methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
2708   }
2709   if (JvmtiExport::has_redefined_a_class()) {
2710     // Reinitialize vtable because RedefineClasses may have changed some
2711     // entries in this vtable for super classes so the CDS vtable might
2712     // point to old or obsolete entries.  RedefineClasses doesn&#39;t fix up
2713     // vtables in the shared system dictionary, only the main one.
2714     // It also redefines the itable too so fix that too.
2715     vtable().initialize_vtable(false, CHECK);
2716     itable().initialize_itable(false, CHECK);
2717   }
2718 
2719   // restore constant pool resolved references
2720   constants()-&gt;restore_unshareable_info(CHECK);
2721 
2722   if (array_klasses() != NULL) {
2723     // Array classes have null protection domain.
2724     // --&gt; see ArrayKlass::complete_create_array_klass()
2725     array_klasses()-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);
2726   }
2727 
2728   // Initialize current biased locking state.
<span class="line-modified">2729   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled() &amp;&amp; !is_value()) {</span>
2730     set_prototype_header(markWord::biased_locking_prototype());
2731   }
2732 }
2733 
2734 void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
2735   switch (loader_type) {
2736   case ClassLoader::BOOT_LOADER:
2737     _misc_flags |= _misc_is_shared_boot_class;
2738     break;
2739   case ClassLoader::PLATFORM_LOADER:
2740     _misc_flags |= _misc_is_shared_platform_class;
2741     break;
2742   case ClassLoader::APP_LOADER:
2743     _misc_flags |= _misc_is_shared_app_class;
2744     break;
2745   default:
2746     ShouldNotReachHere();
2747     break;
2748   }
2749 }
</pre>
<hr />
<pre>
2876 
2877 const char* InstanceKlass::signature_name() const {
2878   int hash_len = 0;
2879   char hash_buf[40];
2880 
2881   // If this is an unsafe anonymous class, append a hash to make the name unique
2882   if (is_unsafe_anonymous()) {
2883     intptr_t hash = (java_mirror() != NULL) ? java_mirror()-&gt;identity_hash() : 0;
2884     jio_snprintf(hash_buf, sizeof(hash_buf), &quot;/&quot; UINTX_FORMAT, (uintx)hash);
2885     hash_len = (int)strlen(hash_buf);
2886   }
2887 
2888   // Get the internal name as a c string
2889   const char* src = (const char*) (name()-&gt;as_C_string());
2890   const int src_length = (int)strlen(src);
2891 
2892   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
2893 
2894   // Add L or Q as type indicator
2895   int dest_index = 0;
<span class="line-modified">2896   dest[dest_index++] = is_value() ? JVM_SIGNATURE_INLINE_TYPE : JVM_SIGNATURE_CLASS;</span>
2897 
2898   // Add the actual class name
2899   for (int src_index = 0; src_index &lt; src_length; ) {
2900     dest[dest_index++] = src[src_index++];
2901   }
2902 
2903   if (is_hidden()) { // Replace the last &#39;+&#39; with a &#39;.&#39;.
2904     for (int index = (int)src_length; index &gt; 0; index--) {
2905       if (dest[index] == &#39;+&#39;) {
2906         dest[index] = JVM_SIGNATURE_DOT;
2907         break;
2908       }
2909     }
2910   }
2911 
2912   // If we have a hash, append it
2913   for (int hash_index = 0; hash_index &lt; hash_len; ) {
2914     dest[dest_index++] = hash_buf[hash_index++];
2915   }
2916 
</pre>
</td>
<td>
<hr />
<pre>
1000   {
1001     ResourceMark rm(THREAD);
1002     for (int i = 0; i &lt; methods()-&gt;length(); i++) {
1003       Method* m = methods()-&gt;at(i);
1004       for (SignatureStream ss(m-&gt;signature()); !ss.is_done(); ss.next()) {
1005         if (ss.is_reference()) {
1006           if (ss.is_array()) {
1007             ss.skip_array_prefix();
1008           }
1009           if (ss.type() == T_VALUETYPE) {
1010             Symbol* symb = ss.as_symbol();
1011 
1012             oop loader = class_loader();
1013             oop protection_domain = this-&gt;protection_domain();
1014             Klass* klass = SystemDictionary::resolve_or_fail(symb,
1015                                                              Handle(THREAD, loader), Handle(THREAD, protection_domain), true,
1016                                                              CHECK_false);
1017             if (klass == NULL) {
1018               THROW_(vmSymbols::java_lang_LinkageError(), false);
1019             }
<span class="line-modified">1020             if (!klass-&gt;is_inline_klass()) {</span>
1021               Exceptions::fthrow(
1022                 THREAD_AND_LOCATION,
1023                 vmSymbols::java_lang_IncompatibleClassChangeError(),
1024                 &quot;class %s is not an inline type&quot;,
1025                 klass-&gt;external_name());
1026             }
1027           }
1028         }
1029       }
1030     }
1031   }
1032 
1033   // in case the class is linked in the process of linking its superclasses
1034   if (is_linked()) {
1035     return true;
1036   }
1037 
1038   // trace only the link time for this klass that includes
1039   // the verification time
1040   PerfClassTraceTime vmtimer(ClassLoader::perf_class_link_time(),
</pre>
<hr />
<pre>
1253       DTRACE_CLASSINIT_PROBE_WAIT(super__failed, -1, wait);
1254       THROW_OOP(e());
1255     }
1256   }
1257 
1258   // Step 8
1259   // Initialize classes of inline fields
1260   {
1261     for (AllFieldStream fs(this); !fs.done(); fs.next()) {
1262       if (Signature::basic_type(fs.signature()) == T_VALUETYPE) {
1263         Klass* klass = this-&gt;get_value_field_klass_or_null(fs.index());
1264         if (klass == NULL) {
1265           assert(fs.access_flags().is_static(), &quot;Otherwise should have been pre-loaded&quot;);
1266           klass = SystemDictionary::resolve_or_fail(field_signature(fs.index())-&gt;fundamental_name(THREAD),
1267               Handle(THREAD, class_loader()),
1268               Handle(THREAD, protection_domain()),
1269               true, CHECK);
1270           if (klass == NULL) {
1271             THROW(vmSymbols::java_lang_NoClassDefFoundError());
1272           }
<span class="line-modified">1273           if (!klass-&gt;is_inline_klass()) {</span>
1274             THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
1275           }
1276           this-&gt;set_value_field_klass(fs.index(), klass);
1277         }
1278         InstanceKlass::cast(klass)-&gt;initialize(CHECK);
1279         if (fs.access_flags().is_static()) {
1280           if (java_mirror()-&gt;obj_field(fs.offset()) == NULL) {
1281             java_mirror()-&gt;obj_field_put(fs.offset(), ValueKlass::cast(klass)-&gt;default_value());
1282           }
1283         }
1284       }
1285     }
1286   }
1287 
1288 
1289   // Look for aot compiled methods for this klass, including class initializer.
1290   AOTLoader::load_for_klass(this, THREAD);
1291 
1292   // Step 9
1293   {
</pre>
<hr />
<pre>
1703 Klass* InstanceKlass::find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const {
1704   // search order according to newest JVM spec (5.4.3.2, p.167).
1705   // 1) search for field in current klass
1706   if (find_local_field(name, sig, fd)) {
1707     if (fd-&gt;is_static() == is_static) return const_cast&lt;InstanceKlass*&gt;(this);
1708   }
1709   // 2) search for field recursively in direct superinterfaces
1710   if (is_static) {
1711     Klass* intf = find_interface_field(name, sig, fd);
1712     if (intf != NULL) return intf;
1713   }
1714   // 3) apply field lookup recursively if superclass exists
1715   { Klass* supr = super();
1716     if (supr != NULL) return InstanceKlass::cast(supr)-&gt;find_field(name, sig, is_static, fd);
1717   }
1718   // 4) otherwise field lookup fails
1719   return NULL;
1720 }
1721 
1722 bool InstanceKlass::contains_field_offset(int offset) {
<span class="line-modified">1723   if (this-&gt;is_inline_klass()) {</span>
1724     ValueKlass* vk = ValueKlass::cast(this);
1725     return offset &gt;= vk-&gt;first_field_offset() &amp;&amp; offset &lt; (vk-&gt;first_field_offset() + vk-&gt;get_exact_size_in_bytes());
1726   } else {
1727     fieldDescriptor fd;
1728     return find_field_from_offset(offset, false, &amp;fd);
1729   }
1730 }
1731 
1732 bool InstanceKlass::find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1733   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1734     if (fs.offset() == offset) {
1735       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1736       if (fd-&gt;is_static() == is_static) return true;
1737     }
1738   }
1739   return false;
1740 }
1741 
1742 
1743 bool InstanceKlass::find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
</pre>
<hr />
<pre>
2680 }
2681 
2682 void InstanceKlass::remove_java_mirror() {
2683   Klass::remove_java_mirror();
2684 
2685   // do array classes also.
2686   if (array_klasses() != NULL) {
2687     array_klasses()-&gt;remove_java_mirror();
2688   }
2689 }
2690 
2691 void InstanceKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain,
2692                                              PackageEntry* pkg_entry, TRAPS) {
2693   // SystemDictionary::add_to_hierarchy() sets the init_state to loaded
2694   // before the InstanceKlass is added to the SystemDictionary. Make
2695   // sure the current state is &lt;loaded.
2696   assert(!is_loaded(), &quot;invalid init state&quot;);
2697   set_package(loader_data, pkg_entry, CHECK);
2698   Klass::restore_unshareable_info(loader_data, protection_domain, CHECK);
2699 
<span class="line-modified">2700   if (is_inline_klass()) {</span>
2701     ValueKlass::cast(this)-&gt;initialize_calling_convention(CHECK);
2702   }
2703 
2704   Array&lt;Method*&gt;* methods = this-&gt;methods();
2705   int num_methods = methods-&gt;length();
2706   for (int index = 0; index &lt; num_methods; ++index) {
2707     methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
2708   }
2709   if (JvmtiExport::has_redefined_a_class()) {
2710     // Reinitialize vtable because RedefineClasses may have changed some
2711     // entries in this vtable for super classes so the CDS vtable might
2712     // point to old or obsolete entries.  RedefineClasses doesn&#39;t fix up
2713     // vtables in the shared system dictionary, only the main one.
2714     // It also redefines the itable too so fix that too.
2715     vtable().initialize_vtable(false, CHECK);
2716     itable().initialize_itable(false, CHECK);
2717   }
2718 
2719   // restore constant pool resolved references
2720   constants()-&gt;restore_unshareable_info(CHECK);
2721 
2722   if (array_klasses() != NULL) {
2723     // Array classes have null protection domain.
2724     // --&gt; see ArrayKlass::complete_create_array_klass()
2725     array_klasses()-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);
2726   }
2727 
2728   // Initialize current biased locking state.
<span class="line-modified">2729   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled() &amp;&amp; !is_inline_klass()) {</span>
2730     set_prototype_header(markWord::biased_locking_prototype());
2731   }
2732 }
2733 
2734 void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
2735   switch (loader_type) {
2736   case ClassLoader::BOOT_LOADER:
2737     _misc_flags |= _misc_is_shared_boot_class;
2738     break;
2739   case ClassLoader::PLATFORM_LOADER:
2740     _misc_flags |= _misc_is_shared_platform_class;
2741     break;
2742   case ClassLoader::APP_LOADER:
2743     _misc_flags |= _misc_is_shared_app_class;
2744     break;
2745   default:
2746     ShouldNotReachHere();
2747     break;
2748   }
2749 }
</pre>
<hr />
<pre>
2876 
2877 const char* InstanceKlass::signature_name() const {
2878   int hash_len = 0;
2879   char hash_buf[40];
2880 
2881   // If this is an unsafe anonymous class, append a hash to make the name unique
2882   if (is_unsafe_anonymous()) {
2883     intptr_t hash = (java_mirror() != NULL) ? java_mirror()-&gt;identity_hash() : 0;
2884     jio_snprintf(hash_buf, sizeof(hash_buf), &quot;/&quot; UINTX_FORMAT, (uintx)hash);
2885     hash_len = (int)strlen(hash_buf);
2886   }
2887 
2888   // Get the internal name as a c string
2889   const char* src = (const char*) (name()-&gt;as_C_string());
2890   const int src_length = (int)strlen(src);
2891 
2892   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
2893 
2894   // Add L or Q as type indicator
2895   int dest_index = 0;
<span class="line-modified">2896   dest[dest_index++] = is_inline_klass() ? JVM_SIGNATURE_INLINE_TYPE : JVM_SIGNATURE_CLASS;</span>
2897 
2898   // Add the actual class name
2899   for (int src_index = 0; src_index &lt; src_length; ) {
2900     dest[dest_index++] = src[src_index++];
2901   }
2902 
2903   if (is_hidden()) { // Replace the last &#39;+&#39; with a &#39;.&#39;.
2904     for (int index = (int)src_length; index &gt; 0; index--) {
2905       if (dest[index] == &#39;+&#39;) {
2906         dest[index] = JVM_SIGNATURE_DOT;
2907         break;
2908       }
2909     }
2910   }
2911 
2912   // If we have a hash, append it
2913   for (int hash_index = 0; hash_index &lt; hash_len; ) {
2914     dest[dest_index++] = hash_buf[hash_index++];
2915   }
2916 
</pre>
</td>
</tr>
</table>
<center><a href="generateOopMap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/valueKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="valueArrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/valueKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 50   // Constructor
 51 ValueKlass::ValueKlass(const ClassFileParser&amp; parser)
 52     : InstanceKlass(parser, InstanceKlass::_kind_inline_type, InstanceKlass::ID) {
 53   _adr_valueklass_fixed_block = valueklass_static_block();
 54   // Addresses used for value type calling convention
 55   *((Array&lt;SigEntry&gt;**)adr_extended_sig()) = NULL;
 56   *((Array&lt;VMRegPair&gt;**)adr_return_regs()) = NULL;
 57   *((address*)adr_pack_handler()) = NULL;
 58   *((address*)adr_pack_handler_jobject()) = NULL;
 59   *((address*)adr_unpack_handler()) = NULL;
 60   assert(pack_handler() == NULL, &quot;pack handler not null&quot;);
 61   *((int*)adr_default_value_offset()) = 0;
 62   *((Klass**)adr_value_array_klass()) = NULL;
 63   set_prototype_header(markWord::always_locked_prototype());
 64   assert(is_inline_type_klass(), &quot;invariant&quot;);
 65 }
 66 
 67 oop ValueKlass::default_value() {
 68   oop val = java_mirror()-&gt;obj_field_acquire(default_value_offset());
 69   assert(oopDesc::is_oop(val), &quot;Sanity check&quot;);
<span class="line-modified"> 70   assert(val-&gt;is_value(), &quot;Sanity check&quot;);</span>
 71   assert(val-&gt;klass() == this, &quot;sanity check&quot;);
 72   return val;
 73 }
 74 
 75 int ValueKlass::first_field_offset_old() {
 76 #ifdef ASSERT
 77   int first_offset = INT_MAX;
 78   for (AllFieldStream fs(this); !fs.done(); fs.next()) {
 79     if (fs.offset() &lt; first_offset) first_offset= fs.offset();
 80   }
 81 #endif
 82   int base_offset = instanceOopDesc::base_offset_in_bytes();
 83   // The first field of value types is aligned on a long boundary
 84   base_offset = align_up(base_offset, BytesPerLong);
 85   assert(base_offset == first_offset, &quot;inconsistent offsets&quot;);
 86   return base_offset;
 87 }
 88 
 89 int ValueKlass::raw_value_byte_size() {
 90   int heapOopAlignedSize = nonstatic_field_size() &lt;&lt; LogBytesPerHeapOop;
</pre>
</td>
<td>
<hr />
<pre>
 50   // Constructor
 51 ValueKlass::ValueKlass(const ClassFileParser&amp; parser)
 52     : InstanceKlass(parser, InstanceKlass::_kind_inline_type, InstanceKlass::ID) {
 53   _adr_valueklass_fixed_block = valueklass_static_block();
 54   // Addresses used for value type calling convention
 55   *((Array&lt;SigEntry&gt;**)adr_extended_sig()) = NULL;
 56   *((Array&lt;VMRegPair&gt;**)adr_return_regs()) = NULL;
 57   *((address*)adr_pack_handler()) = NULL;
 58   *((address*)adr_pack_handler_jobject()) = NULL;
 59   *((address*)adr_unpack_handler()) = NULL;
 60   assert(pack_handler() == NULL, &quot;pack handler not null&quot;);
 61   *((int*)adr_default_value_offset()) = 0;
 62   *((Klass**)adr_value_array_klass()) = NULL;
 63   set_prototype_header(markWord::always_locked_prototype());
 64   assert(is_inline_type_klass(), &quot;invariant&quot;);
 65 }
 66 
 67 oop ValueKlass::default_value() {
 68   oop val = java_mirror()-&gt;obj_field_acquire(default_value_offset());
 69   assert(oopDesc::is_oop(val), &quot;Sanity check&quot;);
<span class="line-modified"> 70   assert(val-&gt;is_inline_type(), &quot;Sanity check&quot;);</span>
 71   assert(val-&gt;klass() == this, &quot;sanity check&quot;);
 72   return val;
 73 }
 74 
 75 int ValueKlass::first_field_offset_old() {
 76 #ifdef ASSERT
 77   int first_offset = INT_MAX;
 78   for (AllFieldStream fs(this); !fs.done(); fs.next()) {
 79     if (fs.offset() &lt; first_offset) first_offset= fs.offset();
 80   }
 81 #endif
 82   int base_offset = instanceOopDesc::base_offset_in_bytes();
 83   // The first field of value types is aligned on a long boundary
 84   base_offset = align_up(base_offset, BytesPerLong);
 85   assert(base_offset == first_offset, &quot;inconsistent offsets&quot;);
 86   return base_offset;
 87 }
 88 
 89 int ValueKlass::raw_value_byte_size() {
 90   int heapOopAlignedSize = nonstatic_field_size() &lt;&lt; LogBytesPerHeapOop;
</pre>
</td>
</tr>
</table>
<center><a href="valueArrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoaderData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stackMapFrame.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 992   // Class_klass has to be loaded because it is used to allocate
 993   // the mirror.
 994   if (SystemDictionary::Class_klass_loaded()) {
 995     // Allocate mirror (java.lang.Class instance)
 996     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 997     Handle mirror(THREAD, mirror_oop);
 998     Handle comp_mirror;
 999 
1000     // Setup indirection from mirror-&gt;klass
1001     java_lang_Class::set_klass(mirror(), k);
1002 
1003     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
1004     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
1005 
1006     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
1007 
1008     // It might also have a component mirror.  This mirror must already exist.
1009     if (k-&gt;is_array_klass()) {
1010       if (k-&gt;is_valueArray_klass()) {
1011         Klass* element_klass = (Klass*) ValueArrayKlass::cast(k)-&gt;element_klass();
<span class="line-modified">1012         assert(element_klass-&gt;is_value(), &quot;Must be value type component&quot;);</span>
1013         ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(element_klass));
1014         comp_mirror = Handle(THREAD, vk-&gt;java_mirror());
1015       } else if (k-&gt;is_typeArray_klass()) {
1016         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
1017         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
1018       } else {
1019         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
1020         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1021         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1022         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
1023       }
1024       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
1025 
1026       // Two-way link between the array klass and its component mirror:
1027       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
1028       set_component_mirror(mirror(), comp_mirror());
1029       // See below for ordering dependencies between field array_klass in component mirror
1030       // and java_mirror in this klass.
1031     } else {
1032       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
</pre>
<hr />
<pre>
1043     }
1044 
1045     // set the classLoader field in the java_lang_Class instance
1046     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1047     set_class_loader(mirror(), class_loader());
1048 
1049     // Setup indirection from klass-&gt;mirror
1050     // after any exceptions can happen during allocations.
1051     k-&gt;set_java_mirror(mirror);
1052 
1053     // Set the module field in the java_lang_Class instance.  This must be done
1054     // after the mirror is set.
1055     set_mirror_module_field(k, mirror, module, THREAD);
1056 
1057     if (comp_mirror() != NULL) {
1058       // Set after k-&gt;java_mirror() is published, because compiled code running
1059       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1060       release_set_array_klass(comp_mirror(), k);
1061     }
1062 
<span class="line-modified">1063     if (k-&gt;is_value()) {</span>
1064       InstanceKlass* super = k-&gt;java_super();
1065       set_val_type_mirror(mirror(), mirror());
1066 
1067       // if the supertype is a restricted abstract class
1068       if (super != SystemDictionary::Object_klass()) {
1069         assert(super-&gt;access_flags().is_abstract(), &quot;must be an abstract class&quot;);
1070         oop ref_type_oop = super-&gt;java_mirror();
1071         // set the reference projection type
1072         set_ref_type_mirror(mirror(), ref_type_oop);
1073 
1074         // set the value and reference projection types
1075         set_val_type_mirror(ref_type_oop, mirror());
1076         set_ref_type_mirror(ref_type_oop, ref_type_oop);
1077       }
1078     }
1079   } else {
1080     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1081     fixup_mirror_list()-&gt;push(k);
1082   }
1083 }
</pre>
<hr />
<pre>
1215 
1216   // No mirror
1217   oop mirror = k-&gt;java_mirror();
1218   if (mirror == NULL) {
1219     return NULL;
1220   }
1221 
1222   if (k-&gt;is_instance_klass()) {
1223     InstanceKlass *ik = InstanceKlass::cast(k);
1224     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1225 
1226     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1227           ik-&gt;is_shared_app_class())) {
1228       // Archiving mirror for classes from non-builtin loaders is not
1229       // supported. Clear the _java_mirror within the archived class.
1230       k-&gt;set_java_mirror_handle(OopHandle());
1231       return NULL;
1232     }
1233   }
1234 
<span class="line-modified">1235   if (k-&gt;is_value()) {</span>
<span class="line-modified">1236     // Values have a val type mirror and a ref type mirror. Don&#39;t handle this for now. TODO:CDS</span>
1237     k-&gt;set_java_mirror_handle(OopHandle());
1238     return NULL;
1239   }
1240 
1241   // Now start archiving the mirror object
1242   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1243   if (archived_mirror == NULL) {
1244     return NULL;
1245   }
1246 
1247   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1248   if (archived_mirror == NULL) {
1249     return NULL;
1250   }
1251 
1252   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1253 
1254   k-&gt;set_has_raw_archived_mirror();
1255 
1256   ResourceMark rm;
</pre>
<hr />
<pre>
1574   return k;
1575 }
1576 
1577 
1578 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1579   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1580   java_class-&gt;metadata_field_put(_klass_offset, klass);
1581 }
1582 
1583 
1584 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1585   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1586   Symbol* name = NULL;
1587   bool is_instance = false;
1588   bool is_value = false;
1589   if (is_primitive(java_class)) {
1590     name = vmSymbols::type_signature(primitive_type(java_class));
1591   } else {
1592     Klass* k = as_Klass(java_class);
1593     is_instance = k-&gt;is_instance_klass();
<span class="line-modified">1594     is_value = k-&gt;is_value();</span>
1595     name = k-&gt;name();
1596   }
1597   if (name == NULL) {
1598     st-&gt;print(&quot;&lt;null&gt;&quot;);
1599     return;
1600   }
1601   if (is_instance)  {
1602     if (is_value) {
1603       st-&gt;print(&quot;Q&quot;);
1604     } else {
1605       st-&gt;print(&quot;L&quot;);
1606     }
1607   }
1608   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1609   if (is_instance)  st-&gt;print(&quot;;&quot;);
1610 }
1611 
1612 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1613   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1614   Symbol* name;
</pre>
</td>
<td>
<hr />
<pre>
 992   // Class_klass has to be loaded because it is used to allocate
 993   // the mirror.
 994   if (SystemDictionary::Class_klass_loaded()) {
 995     // Allocate mirror (java.lang.Class instance)
 996     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 997     Handle mirror(THREAD, mirror_oop);
 998     Handle comp_mirror;
 999 
1000     // Setup indirection from mirror-&gt;klass
1001     java_lang_Class::set_klass(mirror(), k);
1002 
1003     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
1004     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
1005 
1006     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
1007 
1008     // It might also have a component mirror.  This mirror must already exist.
1009     if (k-&gt;is_array_klass()) {
1010       if (k-&gt;is_valueArray_klass()) {
1011         Klass* element_klass = (Klass*) ValueArrayKlass::cast(k)-&gt;element_klass();
<span class="line-modified">1012         assert(element_klass-&gt;is_inline_klass(), &quot;Must be inline type component&quot;);</span>
1013         ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(element_klass));
1014         comp_mirror = Handle(THREAD, vk-&gt;java_mirror());
1015       } else if (k-&gt;is_typeArray_klass()) {
1016         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
1017         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
1018       } else {
1019         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
1020         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1021         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1022         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
1023       }
1024       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
1025 
1026       // Two-way link between the array klass and its component mirror:
1027       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
1028       set_component_mirror(mirror(), comp_mirror());
1029       // See below for ordering dependencies between field array_klass in component mirror
1030       // and java_mirror in this klass.
1031     } else {
1032       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
</pre>
<hr />
<pre>
1043     }
1044 
1045     // set the classLoader field in the java_lang_Class instance
1046     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1047     set_class_loader(mirror(), class_loader());
1048 
1049     // Setup indirection from klass-&gt;mirror
1050     // after any exceptions can happen during allocations.
1051     k-&gt;set_java_mirror(mirror);
1052 
1053     // Set the module field in the java_lang_Class instance.  This must be done
1054     // after the mirror is set.
1055     set_mirror_module_field(k, mirror, module, THREAD);
1056 
1057     if (comp_mirror() != NULL) {
1058       // Set after k-&gt;java_mirror() is published, because compiled code running
1059       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1060       release_set_array_klass(comp_mirror(), k);
1061     }
1062 
<span class="line-modified">1063     if (k-&gt;is_inline_klass()) {</span>
1064       InstanceKlass* super = k-&gt;java_super();
1065       set_val_type_mirror(mirror(), mirror());
1066 
1067       // if the supertype is a restricted abstract class
1068       if (super != SystemDictionary::Object_klass()) {
1069         assert(super-&gt;access_flags().is_abstract(), &quot;must be an abstract class&quot;);
1070         oop ref_type_oop = super-&gt;java_mirror();
1071         // set the reference projection type
1072         set_ref_type_mirror(mirror(), ref_type_oop);
1073 
1074         // set the value and reference projection types
1075         set_val_type_mirror(ref_type_oop, mirror());
1076         set_ref_type_mirror(ref_type_oop, ref_type_oop);
1077       }
1078     }
1079   } else {
1080     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1081     fixup_mirror_list()-&gt;push(k);
1082   }
1083 }
</pre>
<hr />
<pre>
1215 
1216   // No mirror
1217   oop mirror = k-&gt;java_mirror();
1218   if (mirror == NULL) {
1219     return NULL;
1220   }
1221 
1222   if (k-&gt;is_instance_klass()) {
1223     InstanceKlass *ik = InstanceKlass::cast(k);
1224     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1225 
1226     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1227           ik-&gt;is_shared_app_class())) {
1228       // Archiving mirror for classes from non-builtin loaders is not
1229       // supported. Clear the _java_mirror within the archived class.
1230       k-&gt;set_java_mirror_handle(OopHandle());
1231       return NULL;
1232     }
1233   }
1234 
<span class="line-modified">1235   if (k-&gt;is_inline_klass()) {</span>
<span class="line-modified">1236     // Inline types have a val type mirror and a ref type mirror. Don&#39;t handle this for now. TODO:CDS</span>
1237     k-&gt;set_java_mirror_handle(OopHandle());
1238     return NULL;
1239   }
1240 
1241   // Now start archiving the mirror object
1242   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1243   if (archived_mirror == NULL) {
1244     return NULL;
1245   }
1246 
1247   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1248   if (archived_mirror == NULL) {
1249     return NULL;
1250   }
1251 
1252   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1253 
1254   k-&gt;set_has_raw_archived_mirror();
1255 
1256   ResourceMark rm;
</pre>
<hr />
<pre>
1574   return k;
1575 }
1576 
1577 
1578 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1579   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1580   java_class-&gt;metadata_field_put(_klass_offset, klass);
1581 }
1582 
1583 
1584 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1585   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1586   Symbol* name = NULL;
1587   bool is_instance = false;
1588   bool is_value = false;
1589   if (is_primitive(java_class)) {
1590     name = vmSymbols::type_signature(primitive_type(java_class));
1591   } else {
1592     Klass* k = as_Klass(java_class);
1593     is_instance = k-&gt;is_instance_klass();
<span class="line-modified">1594     is_value = k-&gt;is_inline_klass();</span>
1595     name = k-&gt;name();
1596   }
1597   if (name == NULL) {
1598     st-&gt;print(&quot;&lt;null&gt;&quot;);
1599     return;
1600   }
1601   if (is_instance)  {
1602     if (is_value) {
1603       st-&gt;print(&quot;Q&quot;);
1604     } else {
1605       st-&gt;print(&quot;L&quot;);
1606     }
1607   }
1608   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1609   if (is_instance)  st-&gt;print(&quot;;&quot;);
1610 }
1611 
1612 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1613   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1614   Symbol* name;
</pre>
</td>
</tr>
</table>
<center><a href="classLoaderData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stackMapFrame.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/verificationType.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="verificationType.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="verifier.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/verificationType.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
136   static VerificationType top_type() { return bogus_type(); } // alias
137   static VerificationType null_type() { return VerificationType(Null); }
138   static VerificationType integer_type() { return VerificationType(Integer); }
139   static VerificationType float_type() { return VerificationType(Float); }
140   static VerificationType long_type() { return VerificationType(Long); }
141   static VerificationType long2_type() { return VerificationType(Long_2nd); }
142   static VerificationType double_type() { return VerificationType(Double); }
143   static VerificationType boolean_type() { return VerificationType(Boolean); }
144   static VerificationType byte_type() { return VerificationType(Byte); }
145   static VerificationType char_type() { return VerificationType(Char); }
146   static VerificationType short_type() { return VerificationType(Short); }
147   static VerificationType double2_type()
148     { return VerificationType(Double_2nd); }
149 
150   // &quot;check&quot; types are used for queries.  A &quot;check&quot; type is not assignable
151   // to anything, but the specified types are assignable to a &quot;check&quot;.  For
152   // example, any category1 primitive is assignable to category1_check and
153   // any reference is assignable to reference_check.
154   static VerificationType reference_check()
155     { return VerificationType(ReferenceQuery); }
<span class="line-modified">156   static VerificationType inlinetype_check()</span>
157     { return VerificationType(InlineTypeQuery); }
158   static VerificationType category1_check()
159     { return VerificationType(Category1Query); }
160   static VerificationType category2_check()
161     { return VerificationType(Category2Query); }
162   static VerificationType category2_2nd_check()
163     { return VerificationType(Category2_2ndQuery); }
164   static VerificationType nonscalar_check()
165     { return VerificationType(NonScalarQuery); }
166 
167   // For reference types, store the actual Symbol
168   static VerificationType reference_type(Symbol* sh) {
169       assert(((uintptr_t)sh &amp; TypeMask) == 0, &quot;Symbols must be aligned&quot;);
170       // If the above assert fails in the future because oop* isn&#39;t aligned,
171       // then this type encoding system will have to change to have a tag value
172       // to discriminate between oops and primitives.
173       return VerificationType((uintptr_t)sh);
174   }
175   static VerificationType uninitialized_type(u2 bci)
176     { return VerificationType(bci &lt;&lt; 1 * BitsPerByte | Uninitialized); }
177   static VerificationType uninitialized_this_type()
178     { return uninitialized_type(BciForThis); }
179 
180   // For inline types, store the actual Symbol* and set the 3rd bit.
181   // Provides a way for an inline type to be distinguished from a reference type.
<span class="line-modified">182   static VerificationType inlinetype_type(Symbol* sh) {</span>
183       assert(((uintptr_t)sh &amp; TypeMask) == 0, &quot;Symbols must be aligned&quot;);
184       assert((uintptr_t)sh != 0, &quot;Null is not a valid inline type&quot;);
185       // If the above assert fails in the future because oop* isn&#39;t aligned,
186       // then this type encoding system will have to change to have a tag value
187       // to discriminate between oops and primitives.
188       return VerificationType((uintptr_t)sh | InlineType);
189   }
190 
191   // Create based on u1 read from classfile
192   static VerificationType from_tag(u1 tag);
193 
194   bool is_bogus() const     { return (_u._data == Bogus); }
195   bool is_null() const      { return (_u._data == Null); }
196   bool is_boolean() const   { return (_u._data == Boolean); }
197   bool is_byte() const      { return (_u._data == Byte); }
198   bool is_char() const      { return (_u._data == Char); }
199   bool is_short() const     { return (_u._data == Short); }
200   bool is_integer() const   { return (_u._data == Integer); }
201   bool is_long() const      { return (_u._data == Long); }
202   bool is_float() const     { return (_u._data == Float); }
203   bool is_double() const    { return (_u._data == Double); }
204   bool is_long2() const     { return (_u._data == Long_2nd); }
205   bool is_double2() const   { return (_u._data == Double_2nd); }
<span class="line-modified">206   bool is_reference() const { return (((_u._data &amp; TypeMask) == Reference) &amp;&amp; !is_inlinetype_check()); }</span>
<span class="line-modified">207   bool is_inlinetype() const { return ((_u._data &amp; TypeMask) == InlineType); }</span>
208   bool is_category1() const {
209     // This should return true for all one-word types, which are category1
210     // primitives, references (including uninitialized refs) and inline types.
211     // Though the &#39;query&#39; types should technically return &#39;false&#39; here, if we
212     // allow this to return true, we can perform the test using only
213     // 2 operations rather than 8 (3 masks, 3 compares and 2 logical &#39;ands&#39;).
214     // Since noone should call this on a query type anyway, this is ok.
215     assert(!is_check(), &quot;Must not be a check type (wrong value returned)&quot;);
216     return ((_u._data &amp; Category1) != Primitive);
217     // should only return false if it&#39;s a primitive, and the category1 flag
218     // is not set.
219   }
220   bool is_category2() const { return ((_u._data &amp; Category2) == Category2); }
221   bool is_category2_2nd() const {
222     return ((_u._data &amp; Category2_2nd) == Category2_2nd);
223   }
224   bool is_reference_check() const { return _u._data == ReferenceQuery; }
<span class="line-modified">225   bool is_inlinetype_check() const { return _u._data == InlineTypeQuery; }</span>
226   bool is_nonscalar_check() const { return _u._data == NonScalarQuery; }
227   bool is_category1_check() const { return _u._data == Category1Query; }
228   bool is_category2_check() const { return _u._data == Category2Query; }
229   bool is_category2_2nd_check() const { return _u._data == Category2_2ndQuery; }
230   bool is_check() const { return (_u._data &amp; TypeQuery) == TypeQuery; }
231 
232   bool is_x_array(char sig) const {
233     return is_null() || (is_array() &amp;&amp; (name()-&gt;char_at(1) == sig));
234   }
235   bool is_int_array() const { return is_x_array(JVM_SIGNATURE_INT); }
236   bool is_byte_array() const { return is_x_array(JVM_SIGNATURE_BYTE); }
237   bool is_bool_array() const { return is_x_array(JVM_SIGNATURE_BOOLEAN); }
238   bool is_char_array() const { return is_x_array(JVM_SIGNATURE_CHAR); }
239   bool is_short_array() const { return is_x_array(JVM_SIGNATURE_SHORT); }
240   bool is_long_array() const { return is_x_array(JVM_SIGNATURE_LONG); }
241   bool is_float_array() const { return is_x_array(JVM_SIGNATURE_FLOAT); }
242   bool is_double_array() const { return is_x_array(JVM_SIGNATURE_DOUBLE); }
243   bool is_object_array() const { return is_x_array(JVM_SIGNATURE_CLASS); }
244   bool is_array_array() const { return is_x_array(JVM_SIGNATURE_ARRAY); }
<span class="line-modified">245   bool is_inline_array() const { return is_x_array(JVM_SIGNATURE_INLINE_TYPE); }</span>
246   bool is_reference_array() const
247     { return is_object_array() || is_array_array(); }
248   bool is_nonscalar_array() const
<span class="line-modified">249     { return is_object_array() || is_array_array() || is_inline_array(); }</span>
250   bool is_object() const
251     { return (is_reference() &amp;&amp; !is_null() &amp;&amp; name()-&gt;utf8_length() &gt;= 1 &amp;&amp;
252               name()-&gt;char_at(0) != JVM_SIGNATURE_ARRAY); }
253   bool is_array() const
254     { return (is_reference() &amp;&amp; !is_null() &amp;&amp; name()-&gt;utf8_length() &gt;= 2 &amp;&amp;
255               name()-&gt;char_at(0) == JVM_SIGNATURE_ARRAY); }
256   bool is_uninitialized() const
257     { return ((_u._data &amp; Uninitialized) == Uninitialized); }
258   bool is_uninitialized_this() const
259     { return is_uninitialized() &amp;&amp; bci() == BciForThis; }
260 
261   VerificationType to_category2_2nd() const {
262     assert(is_category2(), &quot;Must be a double word&quot;);
263     return VerificationType(is_long() ? Long_2nd : Double_2nd);
264   }
265 
<span class="line-modified">266   static VerificationType change_ref_to_inlinetype(VerificationType ref) {</span>
267     assert(ref.is_reference(), &quot;Bad arg&quot;);
268     assert(!ref.is_null(), &quot;Unexpected NULL&quot;);
<span class="line-modified">269     return inlinetype_type(ref.name());</span>
270   }
271 
272   u2 bci() const {
273     assert(is_uninitialized(), &quot;Must be uninitialized type&quot;);
274     return ((_u._data &amp; BciMask) &gt;&gt; 1 * BitsPerByte);
275   }
276 
277   Symbol* name() const {
<span class="line-modified">278     assert(!is_null() &amp;&amp; (is_reference() || is_inlinetype()), &quot;Must be a non-null reference or an inline type&quot;);</span>
279     return (is_reference() ? _u._sym : ((Symbol*)(_u._data &amp; ~(uintptr_t)InlineType)));
280   }
281 
282   bool equals(const VerificationType&amp; t) const {
283     return (_u._data == t._u._data ||
284             (((is_reference() &amp;&amp; t.is_reference()) ||
<span class="line-modified">285              (is_inlinetype() &amp;&amp; t.is_inlinetype())) &amp;&amp;</span>
286               !is_null() &amp;&amp; !t.is_null() &amp;&amp; name() == t.name()));
287 
288   }
289 
290   bool operator ==(const VerificationType&amp; t) const {
291     return equals(t);
292   }
293 
294   bool operator !=(const VerificationType&amp; t) const {
295     return !equals(t);
296   }
297 
298   // The whole point of this type system - check to see if one type
299   // is assignable to another.  Returns true if one can assign &#39;from&#39; to
300   // this.
301   bool is_assignable_from(
302       const VerificationType&amp; from, ClassVerifier* context,
303       bool from_field_is_protected, TRAPS) const {
304     if (equals(from) || is_bogus()) {
305       return true;
306     } else {
307       switch(_u._data) {
308         case Category1Query:
309           return from.is_category1();
310         case Category2Query:
311           return from.is_category2();
312         case Category2_2ndQuery:
313           return from.is_category2_2nd();
314         case ReferenceQuery:
315           return from.is_reference() || from.is_uninitialized();
316         case NonScalarQuery:
317           return from.is_reference() || from.is_uninitialized() ||
<span class="line-modified">318                  from.is_inlinetype();</span>
319         case InlineTypeQuery:
<span class="line-modified">320           return from.is_inlinetype();</span>
321         case Boolean:
322         case Byte:
323         case Char:
324         case Short:
325           // An int can be assigned to boolean, byte, char or short values.
326           return from.is_integer();
327         default:
<span class="line-modified">328           if (is_inlinetype()) {</span>
<span class="line-modified">329             return is_inlinetype_assignable_from(from);</span>
<span class="line-modified">330           } else if (is_reference() &amp;&amp; from.is_inlinetype()) {</span>
331             return is_ref_assignable_from_inline_type(from, context, THREAD);
332           } else if (is_reference() &amp;&amp; from.is_reference()) {
333             return is_reference_assignable_from(from, context,
334                                                 from_field_is_protected,
335                                                 THREAD);
336           } else {
337             return false;
338           }
339       }
340     }
341   }
342 
343   // Check to see if one array component type is assignable to another.
344   // Same as is_assignable_from() except int primitives must be identical.
345   bool is_component_assignable_from(
346       const VerificationType&amp; from, ClassVerifier* context,
347       bool from_field_is_protected, TRAPS) const {
348     if (equals(from) || is_bogus()) {
349       return true;
350     } else {
</pre>
<hr />
<pre>
360     }
361   }
362 
363   VerificationType get_component(ClassVerifier* context, TRAPS) const;
364 
365   int dimensions() const {
366     assert(is_array(), &quot;Must be an array&quot;);
367     int index = 0;
368     while (name()-&gt;char_at(index) == JVM_SIGNATURE_ARRAY) index++;
369     return index;
370   }
371 
372   void print_on(outputStream* st) const;
373 
374  private:
375 
376   bool is_reference_assignable_from(
377     const VerificationType&amp;, ClassVerifier*, bool from_field_is_protected,
378     TRAPS) const;
379 
<span class="line-modified">380   bool is_inlinetype_assignable_from(const VerificationType&amp; from) const;</span>
381 
382   bool is_ref_assignable_from_inline_type(const VerificationType&amp; from, ClassVerifier* context, TRAPS) const;
383 
384 
385  public:
386   static bool resolve_and_check_assignability(InstanceKlass* klass, Symbol* name,
387                                               Symbol* from_name, bool from_field_is_protected,
388                                               bool from_is_array, bool from_is_object,
389                                               TRAPS);
390 };
391 
392 #endif // SHARE_CLASSFILE_VERIFICATIONTYPE_HPP
</pre>
</td>
<td>
<hr />
<pre>
136   static VerificationType top_type() { return bogus_type(); } // alias
137   static VerificationType null_type() { return VerificationType(Null); }
138   static VerificationType integer_type() { return VerificationType(Integer); }
139   static VerificationType float_type() { return VerificationType(Float); }
140   static VerificationType long_type() { return VerificationType(Long); }
141   static VerificationType long2_type() { return VerificationType(Long_2nd); }
142   static VerificationType double_type() { return VerificationType(Double); }
143   static VerificationType boolean_type() { return VerificationType(Boolean); }
144   static VerificationType byte_type() { return VerificationType(Byte); }
145   static VerificationType char_type() { return VerificationType(Char); }
146   static VerificationType short_type() { return VerificationType(Short); }
147   static VerificationType double2_type()
148     { return VerificationType(Double_2nd); }
149 
150   // &quot;check&quot; types are used for queries.  A &quot;check&quot; type is not assignable
151   // to anything, but the specified types are assignable to a &quot;check&quot;.  For
152   // example, any category1 primitive is assignable to category1_check and
153   // any reference is assignable to reference_check.
154   static VerificationType reference_check()
155     { return VerificationType(ReferenceQuery); }
<span class="line-modified">156   static VerificationType inline_type_check()</span>
157     { return VerificationType(InlineTypeQuery); }
158   static VerificationType category1_check()
159     { return VerificationType(Category1Query); }
160   static VerificationType category2_check()
161     { return VerificationType(Category2Query); }
162   static VerificationType category2_2nd_check()
163     { return VerificationType(Category2_2ndQuery); }
164   static VerificationType nonscalar_check()
165     { return VerificationType(NonScalarQuery); }
166 
167   // For reference types, store the actual Symbol
168   static VerificationType reference_type(Symbol* sh) {
169       assert(((uintptr_t)sh &amp; TypeMask) == 0, &quot;Symbols must be aligned&quot;);
170       // If the above assert fails in the future because oop* isn&#39;t aligned,
171       // then this type encoding system will have to change to have a tag value
172       // to discriminate between oops and primitives.
173       return VerificationType((uintptr_t)sh);
174   }
175   static VerificationType uninitialized_type(u2 bci)
176     { return VerificationType(bci &lt;&lt; 1 * BitsPerByte | Uninitialized); }
177   static VerificationType uninitialized_this_type()
178     { return uninitialized_type(BciForThis); }
179 
180   // For inline types, store the actual Symbol* and set the 3rd bit.
181   // Provides a way for an inline type to be distinguished from a reference type.
<span class="line-modified">182   static VerificationType inline_type(Symbol* sh) {</span>
183       assert(((uintptr_t)sh &amp; TypeMask) == 0, &quot;Symbols must be aligned&quot;);
184       assert((uintptr_t)sh != 0, &quot;Null is not a valid inline type&quot;);
185       // If the above assert fails in the future because oop* isn&#39;t aligned,
186       // then this type encoding system will have to change to have a tag value
187       // to discriminate between oops and primitives.
188       return VerificationType((uintptr_t)sh | InlineType);
189   }
190 
191   // Create based on u1 read from classfile
192   static VerificationType from_tag(u1 tag);
193 
194   bool is_bogus() const     { return (_u._data == Bogus); }
195   bool is_null() const      { return (_u._data == Null); }
196   bool is_boolean() const   { return (_u._data == Boolean); }
197   bool is_byte() const      { return (_u._data == Byte); }
198   bool is_char() const      { return (_u._data == Char); }
199   bool is_short() const     { return (_u._data == Short); }
200   bool is_integer() const   { return (_u._data == Integer); }
201   bool is_long() const      { return (_u._data == Long); }
202   bool is_float() const     { return (_u._data == Float); }
203   bool is_double() const    { return (_u._data == Double); }
204   bool is_long2() const     { return (_u._data == Long_2nd); }
205   bool is_double2() const   { return (_u._data == Double_2nd); }
<span class="line-modified">206   bool is_reference() const { return (((_u._data &amp; TypeMask) == Reference) &amp;&amp; !is_inline_type_check()); }</span>
<span class="line-modified">207   bool is_inline_type() const { return ((_u._data &amp; TypeMask) == InlineType); }</span>
208   bool is_category1() const {
209     // This should return true for all one-word types, which are category1
210     // primitives, references (including uninitialized refs) and inline types.
211     // Though the &#39;query&#39; types should technically return &#39;false&#39; here, if we
212     // allow this to return true, we can perform the test using only
213     // 2 operations rather than 8 (3 masks, 3 compares and 2 logical &#39;ands&#39;).
214     // Since noone should call this on a query type anyway, this is ok.
215     assert(!is_check(), &quot;Must not be a check type (wrong value returned)&quot;);
216     return ((_u._data &amp; Category1) != Primitive);
217     // should only return false if it&#39;s a primitive, and the category1 flag
218     // is not set.
219   }
220   bool is_category2() const { return ((_u._data &amp; Category2) == Category2); }
221   bool is_category2_2nd() const {
222     return ((_u._data &amp; Category2_2nd) == Category2_2nd);
223   }
224   bool is_reference_check() const { return _u._data == ReferenceQuery; }
<span class="line-modified">225   bool is_inline_type_check() const { return _u._data == InlineTypeQuery; }</span>
226   bool is_nonscalar_check() const { return _u._data == NonScalarQuery; }
227   bool is_category1_check() const { return _u._data == Category1Query; }
228   bool is_category2_check() const { return _u._data == Category2Query; }
229   bool is_category2_2nd_check() const { return _u._data == Category2_2ndQuery; }
230   bool is_check() const { return (_u._data &amp; TypeQuery) == TypeQuery; }
231 
232   bool is_x_array(char sig) const {
233     return is_null() || (is_array() &amp;&amp; (name()-&gt;char_at(1) == sig));
234   }
235   bool is_int_array() const { return is_x_array(JVM_SIGNATURE_INT); }
236   bool is_byte_array() const { return is_x_array(JVM_SIGNATURE_BYTE); }
237   bool is_bool_array() const { return is_x_array(JVM_SIGNATURE_BOOLEAN); }
238   bool is_char_array() const { return is_x_array(JVM_SIGNATURE_CHAR); }
239   bool is_short_array() const { return is_x_array(JVM_SIGNATURE_SHORT); }
240   bool is_long_array() const { return is_x_array(JVM_SIGNATURE_LONG); }
241   bool is_float_array() const { return is_x_array(JVM_SIGNATURE_FLOAT); }
242   bool is_double_array() const { return is_x_array(JVM_SIGNATURE_DOUBLE); }
243   bool is_object_array() const { return is_x_array(JVM_SIGNATURE_CLASS); }
244   bool is_array_array() const { return is_x_array(JVM_SIGNATURE_ARRAY); }
<span class="line-modified">245   bool is_inline_type_array() const { return is_x_array(JVM_SIGNATURE_INLINE_TYPE); }</span>
246   bool is_reference_array() const
247     { return is_object_array() || is_array_array(); }
248   bool is_nonscalar_array() const
<span class="line-modified">249     { return is_object_array() || is_array_array() || is_inline_type_array(); }</span>
250   bool is_object() const
251     { return (is_reference() &amp;&amp; !is_null() &amp;&amp; name()-&gt;utf8_length() &gt;= 1 &amp;&amp;
252               name()-&gt;char_at(0) != JVM_SIGNATURE_ARRAY); }
253   bool is_array() const
254     { return (is_reference() &amp;&amp; !is_null() &amp;&amp; name()-&gt;utf8_length() &gt;= 2 &amp;&amp;
255               name()-&gt;char_at(0) == JVM_SIGNATURE_ARRAY); }
256   bool is_uninitialized() const
257     { return ((_u._data &amp; Uninitialized) == Uninitialized); }
258   bool is_uninitialized_this() const
259     { return is_uninitialized() &amp;&amp; bci() == BciForThis; }
260 
261   VerificationType to_category2_2nd() const {
262     assert(is_category2(), &quot;Must be a double word&quot;);
263     return VerificationType(is_long() ? Long_2nd : Double_2nd);
264   }
265 
<span class="line-modified">266   static VerificationType change_ref_to_inline_type(VerificationType ref) {</span>
267     assert(ref.is_reference(), &quot;Bad arg&quot;);
268     assert(!ref.is_null(), &quot;Unexpected NULL&quot;);
<span class="line-modified">269     return inline_type(ref.name());</span>
270   }
271 
272   u2 bci() const {
273     assert(is_uninitialized(), &quot;Must be uninitialized type&quot;);
274     return ((_u._data &amp; BciMask) &gt;&gt; 1 * BitsPerByte);
275   }
276 
277   Symbol* name() const {
<span class="line-modified">278     assert(!is_null() &amp;&amp; (is_reference() || is_inline_type()), &quot;Must be a non-null reference or an inline type&quot;);</span>
279     return (is_reference() ? _u._sym : ((Symbol*)(_u._data &amp; ~(uintptr_t)InlineType)));
280   }
281 
282   bool equals(const VerificationType&amp; t) const {
283     return (_u._data == t._u._data ||
284             (((is_reference() &amp;&amp; t.is_reference()) ||
<span class="line-modified">285              (is_inline_type() &amp;&amp; t.is_inline_type())) &amp;&amp;</span>
286               !is_null() &amp;&amp; !t.is_null() &amp;&amp; name() == t.name()));
287 
288   }
289 
290   bool operator ==(const VerificationType&amp; t) const {
291     return equals(t);
292   }
293 
294   bool operator !=(const VerificationType&amp; t) const {
295     return !equals(t);
296   }
297 
298   // The whole point of this type system - check to see if one type
299   // is assignable to another.  Returns true if one can assign &#39;from&#39; to
300   // this.
301   bool is_assignable_from(
302       const VerificationType&amp; from, ClassVerifier* context,
303       bool from_field_is_protected, TRAPS) const {
304     if (equals(from) || is_bogus()) {
305       return true;
306     } else {
307       switch(_u._data) {
308         case Category1Query:
309           return from.is_category1();
310         case Category2Query:
311           return from.is_category2();
312         case Category2_2ndQuery:
313           return from.is_category2_2nd();
314         case ReferenceQuery:
315           return from.is_reference() || from.is_uninitialized();
316         case NonScalarQuery:
317           return from.is_reference() || from.is_uninitialized() ||
<span class="line-modified">318                  from.is_inline_type();</span>
319         case InlineTypeQuery:
<span class="line-modified">320           return from.is_inline_type();</span>
321         case Boolean:
322         case Byte:
323         case Char:
324         case Short:
325           // An int can be assigned to boolean, byte, char or short values.
326           return from.is_integer();
327         default:
<span class="line-modified">328           if (is_inline_type()) {</span>
<span class="line-modified">329             return is_inline_type_assignable_from(from);</span>
<span class="line-modified">330           } else if (is_reference() &amp;&amp; from.is_inline_type()) {</span>
331             return is_ref_assignable_from_inline_type(from, context, THREAD);
332           } else if (is_reference() &amp;&amp; from.is_reference()) {
333             return is_reference_assignable_from(from, context,
334                                                 from_field_is_protected,
335                                                 THREAD);
336           } else {
337             return false;
338           }
339       }
340     }
341   }
342 
343   // Check to see if one array component type is assignable to another.
344   // Same as is_assignable_from() except int primitives must be identical.
345   bool is_component_assignable_from(
346       const VerificationType&amp; from, ClassVerifier* context,
347       bool from_field_is_protected, TRAPS) const {
348     if (equals(from) || is_bogus()) {
349       return true;
350     } else {
</pre>
<hr />
<pre>
360     }
361   }
362 
363   VerificationType get_component(ClassVerifier* context, TRAPS) const;
364 
365   int dimensions() const {
366     assert(is_array(), &quot;Must be an array&quot;);
367     int index = 0;
368     while (name()-&gt;char_at(index) == JVM_SIGNATURE_ARRAY) index++;
369     return index;
370   }
371 
372   void print_on(outputStream* st) const;
373 
374  private:
375 
376   bool is_reference_assignable_from(
377     const VerificationType&amp;, ClassVerifier*, bool from_field_is_protected,
378     TRAPS) const;
379 
<span class="line-modified">380   bool is_inline_type_assignable_from(const VerificationType&amp; from) const;</span>
381 
382   bool is_ref_assignable_from_inline_type(const VerificationType&amp; from, ClassVerifier* context, TRAPS) const;
383 
384 
385  public:
386   static bool resolve_and_check_assignability(InstanceKlass* klass, Symbol* name,
387                                               Symbol* from_name, bool from_field_is_protected,
388                                               bool from_is_array, bool from_is_object,
389                                               TRAPS);
390 };
391 
392 #endif // SHARE_CLASSFILE_VERIFICATIONTYPE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="verificationType.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="verifier.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classLoaderData.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoaderData.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
360       assert(m-&gt;is_a(SystemDictionary::Class_klass()), &quot;invalid mirror&quot;);
361 #endif
362       klass_closure-&gt;do_klass(k);
363     }
364   }
365 }
366 
367 void ClassLoaderData::classes_do(void f(InstanceKlass*)) {
368   // Lock-free access requires load_acquire
369   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
370     if (k-&gt;is_instance_klass()) {
371       f(InstanceKlass::cast(k));
372     }
373     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
374   }
375 }
376 
377 void ClassLoaderData::value_classes_do(void f(ValueKlass*)) {
378   // Lock-free access requires load_acquire
379   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
<span class="line-modified">380     if (k-&gt;is_value()) {</span>
381       f(ValueKlass::cast(k));
382     }
383     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
384   }
385 }
386 
387 void ClassLoaderData::modules_do(void f(ModuleEntry*)) {
388   assert_locked_or_safepoint(Module_lock);
389   if (_unnamed_module != NULL) {
390     f(_unnamed_module);
391   }
392   if (_modules != NULL) {
393     for (int i = 0; i &lt; _modules-&gt;table_size(); i++) {
394       for (ModuleEntry* entry = _modules-&gt;bucket(i);
395            entry != NULL;
396            entry = entry-&gt;next()) {
397         f(entry);
398       }
399     }
400   }
</pre>
<hr />
<pre>
829 void ClassLoaderData::free_deallocate_list() {
830   // This must be called at a safepoint because it depends on metadata walking at
831   // safepoint cleanup time.
832   assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);
833   assert(!is_unloading(), &quot;only called for ClassLoaderData that are not unloading&quot;);
834   if (_deallocate_list == NULL) {
835     return;
836   }
837   // Go backwards because this removes entries that are freed.
838   for (int i = _deallocate_list-&gt;length() - 1; i &gt;= 0; i--) {
839     Metadata* m = _deallocate_list-&gt;at(i);
840     if (!m-&gt;on_stack()) {
841       _deallocate_list-&gt;remove_at(i);
842       // There are only three types of metadata that we deallocate directly.
843       // Cast them so they can be used by the template function.
844       if (m-&gt;is_method()) {
845         MetadataFactory::free_metadata(this, (Method*)m);
846       } else if (m-&gt;is_constantPool()) {
847         MetadataFactory::free_metadata(this, (ConstantPool*)m);
848       } else if (m-&gt;is_klass()) {
<span class="line-modified">849         if (!((Klass*)m)-&gt;is_value()) {</span>
850           MetadataFactory::free_metadata(this, (InstanceKlass*)m);
851         } else {
852           MetadataFactory::free_metadata(this, (ValueKlass*)m);
853         }
854       } else {
855         ShouldNotReachHere();
856       }
857     } else {
858       // Metadata is alive.
859       // If scratch_class is on stack then it shouldn&#39;t be on this list!
860       assert(!m-&gt;is_klass() || !((InstanceKlass*)m)-&gt;is_scratch_class(),
861              &quot;scratch classes on this list should be dead&quot;);
862       // Also should assert that other metadata on the list was found in handles.
863       // Some cleaning remains.
864       ClassLoaderDataGraph::set_should_clean_deallocate_lists();
865     }
866   }
867 }
868 
869 // This is distinct from free_deallocate_list.  For class loader data that are
</pre>
</td>
<td>
<hr />
<pre>
360       assert(m-&gt;is_a(SystemDictionary::Class_klass()), &quot;invalid mirror&quot;);
361 #endif
362       klass_closure-&gt;do_klass(k);
363     }
364   }
365 }
366 
367 void ClassLoaderData::classes_do(void f(InstanceKlass*)) {
368   // Lock-free access requires load_acquire
369   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
370     if (k-&gt;is_instance_klass()) {
371       f(InstanceKlass::cast(k));
372     }
373     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
374   }
375 }
376 
377 void ClassLoaderData::value_classes_do(void f(ValueKlass*)) {
378   // Lock-free access requires load_acquire
379   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
<span class="line-modified">380     if (k-&gt;is_inline_klass()) {</span>
381       f(ValueKlass::cast(k));
382     }
383     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
384   }
385 }
386 
387 void ClassLoaderData::modules_do(void f(ModuleEntry*)) {
388   assert_locked_or_safepoint(Module_lock);
389   if (_unnamed_module != NULL) {
390     f(_unnamed_module);
391   }
392   if (_modules != NULL) {
393     for (int i = 0; i &lt; _modules-&gt;table_size(); i++) {
394       for (ModuleEntry* entry = _modules-&gt;bucket(i);
395            entry != NULL;
396            entry = entry-&gt;next()) {
397         f(entry);
398       }
399     }
400   }
</pre>
<hr />
<pre>
829 void ClassLoaderData::free_deallocate_list() {
830   // This must be called at a safepoint because it depends on metadata walking at
831   // safepoint cleanup time.
832   assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);
833   assert(!is_unloading(), &quot;only called for ClassLoaderData that are not unloading&quot;);
834   if (_deallocate_list == NULL) {
835     return;
836   }
837   // Go backwards because this removes entries that are freed.
838   for (int i = _deallocate_list-&gt;length() - 1; i &gt;= 0; i--) {
839     Metadata* m = _deallocate_list-&gt;at(i);
840     if (!m-&gt;on_stack()) {
841       _deallocate_list-&gt;remove_at(i);
842       // There are only three types of metadata that we deallocate directly.
843       // Cast them so they can be used by the template function.
844       if (m-&gt;is_method()) {
845         MetadataFactory::free_metadata(this, (Method*)m);
846       } else if (m-&gt;is_constantPool()) {
847         MetadataFactory::free_metadata(this, (ConstantPool*)m);
848       } else if (m-&gt;is_klass()) {
<span class="line-modified">849         if (!((Klass*)m)-&gt;is_inline_klass()) {</span>
850           MetadataFactory::free_metadata(this, (InstanceKlass*)m);
851         } else {
852           MetadataFactory::free_metadata(this, (ValueKlass*)m);
853         }
854       } else {
855         ShouldNotReachHere();
856       }
857     } else {
858       // Metadata is alive.
859       // If scratch_class is on stack then it shouldn&#39;t be on this list!
860       assert(!m-&gt;is_klass() || !((InstanceKlass*)m)-&gt;is_scratch_class(),
861              &quot;scratch classes on this list should be dead&quot;);
862       // Also should assert that other metadata on the list was found in handles.
863       // Some cleaning remains.
864       ClassLoaderDataGraph::set_should_clean_deallocate_lists();
865     }
866   }
867 }
868 
869 // This is distinct from free_deallocate_list.  For class loader data that are
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
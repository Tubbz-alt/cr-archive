<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/verifier.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="verificationType.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="verifier.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/verifier.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 571     stack_map_frame* sm_frame = sm_table-&gt;entries();
 572     streamIndentor si2(ss);
 573     int current_offset = -1;
 574     address end_of_sm_table = (address)sm_table + method-&gt;stackmap_data()-&gt;length();
 575     for (u2 i = 0; i &lt; sm_table-&gt;number_of_entries(); ++i) {
 576       ss-&gt;indent();
 577       if (!sm_frame-&gt;verify((address)sm_frame, end_of_sm_table)) {
 578         sm_frame-&gt;print_truncated(ss, current_offset);
 579         return;
 580       }
 581       sm_frame-&gt;print_on(ss, current_offset);
 582       ss-&gt;cr();
 583       current_offset += sm_frame-&gt;offset_delta();
 584       sm_frame = sm_frame-&gt;next();
 585     }
 586   }
 587 }
 588 
 589 // Methods in ClassVerifier
 590 
<span class="line-modified"> 591 VerificationType reference_or_inlinetype(InstanceKlass* klass) {</span>
<span class="line-modified"> 592   if (klass-&gt;is_value()) {</span>
<span class="line-modified"> 593     return VerificationType::inlinetype_type(klass-&gt;name());</span>
 594   } else {
 595     return VerificationType::reference_type(klass-&gt;name());
 596   }
 597 }
 598 
 599 ClassVerifier::ClassVerifier(
 600     InstanceKlass* klass, TRAPS)
 601     : _thread(THREAD), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),
 602       _message(NULL), _method_signatures_table(NULL), _klass(klass) {
<span class="line-modified"> 603   _this_type = reference_or_inlinetype(klass);</span>
 604 }
 605 
 606 ClassVerifier::~ClassVerifier() {
 607   // Decrement the reference count for any symbols created.
 608   if (_symbols != NULL) {
 609     for (int i = 0; i &lt; _symbols-&gt;length(); i++) {
 610       Symbol* s = _symbols-&gt;at(i);
 611       s-&gt;decrement_refcount();
 612     }
 613   }
 614 }
 615 
 616 VerificationType ClassVerifier::object_type() const {
 617   return VerificationType::reference_type(vmSymbols::java_lang_Object());
 618 }
 619 
 620 TypeOrigin ClassVerifier::ref_ctx(const char* sig) {
 621   VerificationType vt = VerificationType::reference_type(
 622                          create_temporary_symbol(sig, (int)strlen(sig)));
 623   return TypeOrigin::implicit(vt);
</pre>
<hr />
<pre>
1744           no_control_flow = false; break;
1745         }
1746         case Bytecodes::_defaultvalue :
1747         {
1748           if (_klass-&gt;major_version() &lt; INLINE_TYPE_MAJOR_VERSION) {
1749             class_format_error(
1750               &quot;defaultvalue not supported by this class file version (%d.%d), class %s&quot;,
1751               _klass-&gt;major_version(), _klass-&gt;minor_version(), _klass-&gt;external_name());
1752             return;
1753           }
1754           index = bcs.get_index_u2();
1755           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1756           VerificationType ref_type = cp_index_to_type(index, cp, CHECK_VERIFY(this));
1757           if (!ref_type.is_object()) {
1758             verify_error(ErrorContext::bad_type(bci,
1759                 TypeOrigin::cp(index, ref_type)),
1760                 &quot;Illegal defaultvalue instruction&quot;);
1761             return;
1762           }
1763           VerificationType inline_type =
<span class="line-modified">1764             VerificationType::change_ref_to_inlinetype(ref_type);</span>
1765           current_frame.push_stack(inline_type, CHECK_VERIFY(this));
1766           no_control_flow = false; break;
1767         }
1768         case Bytecodes::_newarray :
1769           type = get_newarray_type(bcs.get_index(), bci, CHECK_VERIFY(this));
1770           current_frame.pop_stack(
1771             VerificationType::integer_type(),  CHECK_VERIFY(this));
1772           current_frame.push_stack(type, CHECK_VERIFY(this));
1773           no_control_flow = false; break;
1774         case Bytecodes::_anewarray :
1775           verify_anewarray(
1776             bci, bcs.get_index_u2(), cp, &amp;current_frame, CHECK_VERIFY(this));
1777           no_control_flow = false; break;
1778         case Bytecodes::_arraylength :
1779           type = current_frame.pop_stack(
1780             VerificationType::reference_check(), CHECK_VERIFY(this));
1781           if (!(type.is_null() || type.is_array())) {
1782             verify_error(ErrorContext::bad_type(
1783                 bci, current_frame.stack_top_ctx()),
1784                 bad_type_msg, &quot;arraylength&quot;);
</pre>
<hr />
<pre>
2385   bool is_assignable;
2386   switch (bcs-&gt;raw_code()) {
2387     case Bytecodes::_getstatic: {
2388       for (int i = 0; i &lt; n; i++) {
2389         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
2390       }
2391       break;
2392     }
2393     case Bytecodes::_putstatic: {
2394       for (int i = n - 1; i &gt;= 0; i--) {
2395         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2396       }
2397       break;
2398     }
2399     case Bytecodes::_withfield: {
2400       for (int i = n - 1; i &gt;= 0; i--) {
2401         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2402       }
2403       // stack_object_type and target_class_type must be the same inline type.
2404       stack_object_type =
<span class="line-modified">2405         current_frame-&gt;pop_stack(VerificationType::inlinetype_check(), CHECK_VERIFY(this));</span>
2406       VerificationType target_inline_type =
<span class="line-modified">2407         VerificationType::change_ref_to_inlinetype(target_class_type);</span>
2408       if (!stack_object_type.equals(target_inline_type)) {
2409         verify_error(ErrorContext::bad_inline_type(bci,
2410             current_frame-&gt;stack_top_ctx(),
2411             TypeOrigin::cp(index, target_class_type)),
2412             &quot;Invalid type on operand stack in withfield instruction&quot;);
2413         return;
2414       }
2415       current_frame-&gt;push_stack(target_inline_type, CHECK_VERIFY(this));
2416       break;
2417     }
2418     case Bytecodes::_getfield: {
2419       stack_object_type = current_frame-&gt;pop_stack(
2420         target_class_type, CHECK_VERIFY(this));
2421       for (int i = 0; i &lt; n; i++) {
2422         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
2423       }
2424       goto check_protected;
2425     }
2426     case Bytecodes::_putfield: {
2427       for (int i = n - 1; i &gt;= 0; i--) {
</pre>
<hr />
<pre>
2924     // Make sure &lt;init&gt; can only be invoked by invokespecial or invokestatic.
2925     // The allowed invocation mode of &lt;init&gt; depends on its signature.
2926     if ((opcode != Bytecodes::_invokespecial &amp;&amp;
2927          opcode != Bytecodes::_invokestatic) ||
2928         method_name != vmSymbols::object_initializer_name()) {
2929       verify_error(ErrorContext::bad_code(bci),
2930           &quot;Illegal call to internal method&quot;);
2931       return;
2932     }
2933   } else if (opcode == Bytecodes::_invokespecial
2934              &amp;&amp; !is_same_or_direct_interface(current_class(), current_type(), ref_class_type)
2935              &amp;&amp; !ref_class_type.equals(VerificationType::reference_type(
2936                   current_class()-&gt;super()-&gt;name()))) { // super() can never be an inline_type.
2937     bool subtype = false;
2938     bool have_imr_indirect = cp-&gt;tag_at(index).value() == JVM_CONSTANT_InterfaceMethodref;
2939     if (!current_class()-&gt;is_unsafe_anonymous()) {
2940       subtype = ref_class_type.is_assignable_from(
2941                  current_type(), this, false, CHECK_VERIFY(this));
2942     } else {
2943       InstanceKlass* unsafe_host = current_class()-&gt;unsafe_anonymous_host();
<span class="line-modified">2944       VerificationType unsafe_anonymous_host_type = reference_or_inlinetype(unsafe_host);</span>
2945       subtype = ref_class_type.is_assignable_from(unsafe_anonymous_host_type, this, false, CHECK_VERIFY(this));
2946 
2947       // If invokespecial of IMR, need to recheck for same or
2948       // direct interface relative to the host class
2949       have_imr_indirect = (have_imr_indirect &amp;&amp;
2950                            !is_same_or_direct_interface(
2951                              unsafe_host,
2952                              unsafe_anonymous_host_type, ref_class_type));
2953     }
2954     if (!subtype) {
2955       verify_error(ErrorContext::bad_code(bci),
2956           &quot;Bad invokespecial instruction: &quot;
2957           &quot;current class isn&#39;t assignable to reference class.&quot;);
2958        return;
2959     } else if (have_imr_indirect) {
2960       verify_error(ErrorContext::bad_code(bci),
2961           &quot;Bad invokespecial instruction: &quot;
2962           &quot;interface method reference is in an indirect superinterface.&quot;);
2963       return;
2964     }
</pre>
<hr />
<pre>
2978   if (opcode != Bytecodes::_invokestatic &amp;&amp;
2979       opcode != Bytecodes::_invokedynamic) {
2980     if (method_name == vmSymbols::object_initializer_name()) {  // &lt;init&gt; method
2981       // (use of &lt;init&gt; as a static factory is handled under invokestatic)
2982       verify_invoke_init(bcs, index, ref_class_type, current_frame,
2983         code_length, in_try_block, this_uninit, cp, stackmap_table,
2984         CHECK_VERIFY(this));
2985       if (was_recursively_verified()) return;
2986     } else {   // other methods
2987       // Ensures that target class is assignable to method class.
2988       if (opcode == Bytecodes::_invokespecial) {
2989         if (!current_class()-&gt;is_unsafe_anonymous()) {
2990           current_frame-&gt;pop_stack(current_type(), CHECK_VERIFY(this));
2991         } else {
2992           // anonymous class invokespecial calls: check if the
2993           // objectref is a subtype of the unsafe_anonymous_host of the current class
2994           // to allow an anonymous class to reference methods in the unsafe_anonymous_host
2995           VerificationType top = current_frame-&gt;pop_stack(CHECK_VERIFY(this));
2996 
2997           InstanceKlass* unsafe_host = current_class()-&gt;unsafe_anonymous_host();
<span class="line-modified">2998           VerificationType host_type = reference_or_inlinetype(unsafe_host);</span>
2999           bool subtype = host_type.is_assignable_from(top, this, false, CHECK_VERIFY(this));
3000           if (!subtype) {
3001             verify_error( ErrorContext::bad_type(current_frame-&gt;offset(),
3002               current_frame-&gt;stack_top_ctx(),
3003               TypeOrigin::implicit(top)),
3004               &quot;Bad type on operand stack&quot;);
3005             return;
3006           }
3007         }
3008       } else if (opcode == Bytecodes::_invokevirtual) {
3009         VerificationType stack_object_type =
3010           current_frame-&gt;pop_stack(ref_class_type, CHECK_VERIFY(this));
3011         if (current_type() != stack_object_type) {
3012           if (was_recursively_verified()) return;
3013           assert(cp-&gt;cache() == NULL, &quot;not rewritten yet&quot;);
3014           Symbol* ref_class_name =
3015             cp-&gt;klass_name_at(cp-&gt;klass_ref_index_at(index));
3016           // See the comments in verify_field_instructions() for
3017           // the rationale behind this.
3018           if (name_in_supers(ref_class_name, current_class())) {
</pre>
<hr />
<pre>
3102     cp_index_to_type(index, cp, CHECK_VERIFY(this));
3103   int length;
3104   char* arr_sig_str;
3105   if (component_type.is_array()) {     // it&#39;s an array
3106     const char* component_name = component_type.name()-&gt;as_utf8();
3107     // Check for more than MAX_ARRAY_DIMENSIONS
3108     length = (int)strlen(component_name);
3109     if (length &gt; MAX_ARRAY_DIMENSIONS &amp;&amp;
3110         component_name[MAX_ARRAY_DIMENSIONS - 1] == JVM_SIGNATURE_ARRAY) {
3111       verify_error(ErrorContext::bad_code(bci),
3112         &quot;Illegal anewarray instruction, array has more than 255 dimensions&quot;);
3113     }
3114     // add one dimension to component
3115     length++;
3116     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3117     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%s&quot;,
3118                          JVM_SIGNATURE_ARRAY, component_name);
3119     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3120   } else {         // it&#39;s an object or interface
3121     const char* component_name = component_type.name()-&gt;as_utf8();
<span class="line-modified">3122     char Q_or_L = component_type.is_inlinetype() ? JVM_SIGNATURE_INLINE_TYPE : JVM_SIGNATURE_CLASS;</span>
3123     // add one dimension to component with &#39;L&#39; or &#39;Q&#39; prepended and &#39;;&#39; appended.
3124     length = (int)strlen(component_name) + 3;
3125     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3126     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%c%s;&quot;,
3127                          JVM_SIGNATURE_ARRAY, Q_or_L, component_name);
3128     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3129   }
3130   Symbol* arr_sig = create_temporary_symbol(arr_sig_str, length);
3131   VerificationType new_array_type = VerificationType::reference_type(arr_sig);
3132   current_frame-&gt;push_stack(new_array_type, CHECK_VERIFY(this));
3133 }
3134 
3135 void ClassVerifier::verify_iload(u2 index, StackMapFrame* current_frame, TRAPS) {
3136   current_frame-&gt;get_local(
3137     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3138   current_frame-&gt;push_stack(
3139     VerificationType::integer_type(), CHECK_VERIFY(this));
3140 }
3141 
3142 void ClassVerifier::verify_lload(u2 index, StackMapFrame* current_frame, TRAPS) {
</pre>
</td>
<td>
<hr />
<pre>
 571     stack_map_frame* sm_frame = sm_table-&gt;entries();
 572     streamIndentor si2(ss);
 573     int current_offset = -1;
 574     address end_of_sm_table = (address)sm_table + method-&gt;stackmap_data()-&gt;length();
 575     for (u2 i = 0; i &lt; sm_table-&gt;number_of_entries(); ++i) {
 576       ss-&gt;indent();
 577       if (!sm_frame-&gt;verify((address)sm_frame, end_of_sm_table)) {
 578         sm_frame-&gt;print_truncated(ss, current_offset);
 579         return;
 580       }
 581       sm_frame-&gt;print_on(ss, current_offset);
 582       ss-&gt;cr();
 583       current_offset += sm_frame-&gt;offset_delta();
 584       sm_frame = sm_frame-&gt;next();
 585     }
 586   }
 587 }
 588 
 589 // Methods in ClassVerifier
 590 
<span class="line-modified"> 591 VerificationType reference_or_inline_type(InstanceKlass* klass) {</span>
<span class="line-modified"> 592   if (klass-&gt;is_inline_klass()) {</span>
<span class="line-modified"> 593     return VerificationType::inline_type(klass-&gt;name());</span>
 594   } else {
 595     return VerificationType::reference_type(klass-&gt;name());
 596   }
 597 }
 598 
 599 ClassVerifier::ClassVerifier(
 600     InstanceKlass* klass, TRAPS)
 601     : _thread(THREAD), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),
 602       _message(NULL), _method_signatures_table(NULL), _klass(klass) {
<span class="line-modified"> 603   _this_type = reference_or_inline_type(klass);</span>
 604 }
 605 
 606 ClassVerifier::~ClassVerifier() {
 607   // Decrement the reference count for any symbols created.
 608   if (_symbols != NULL) {
 609     for (int i = 0; i &lt; _symbols-&gt;length(); i++) {
 610       Symbol* s = _symbols-&gt;at(i);
 611       s-&gt;decrement_refcount();
 612     }
 613   }
 614 }
 615 
 616 VerificationType ClassVerifier::object_type() const {
 617   return VerificationType::reference_type(vmSymbols::java_lang_Object());
 618 }
 619 
 620 TypeOrigin ClassVerifier::ref_ctx(const char* sig) {
 621   VerificationType vt = VerificationType::reference_type(
 622                          create_temporary_symbol(sig, (int)strlen(sig)));
 623   return TypeOrigin::implicit(vt);
</pre>
<hr />
<pre>
1744           no_control_flow = false; break;
1745         }
1746         case Bytecodes::_defaultvalue :
1747         {
1748           if (_klass-&gt;major_version() &lt; INLINE_TYPE_MAJOR_VERSION) {
1749             class_format_error(
1750               &quot;defaultvalue not supported by this class file version (%d.%d), class %s&quot;,
1751               _klass-&gt;major_version(), _klass-&gt;minor_version(), _klass-&gt;external_name());
1752             return;
1753           }
1754           index = bcs.get_index_u2();
1755           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1756           VerificationType ref_type = cp_index_to_type(index, cp, CHECK_VERIFY(this));
1757           if (!ref_type.is_object()) {
1758             verify_error(ErrorContext::bad_type(bci,
1759                 TypeOrigin::cp(index, ref_type)),
1760                 &quot;Illegal defaultvalue instruction&quot;);
1761             return;
1762           }
1763           VerificationType inline_type =
<span class="line-modified">1764             VerificationType::change_ref_to_inline_type(ref_type);</span>
1765           current_frame.push_stack(inline_type, CHECK_VERIFY(this));
1766           no_control_flow = false; break;
1767         }
1768         case Bytecodes::_newarray :
1769           type = get_newarray_type(bcs.get_index(), bci, CHECK_VERIFY(this));
1770           current_frame.pop_stack(
1771             VerificationType::integer_type(),  CHECK_VERIFY(this));
1772           current_frame.push_stack(type, CHECK_VERIFY(this));
1773           no_control_flow = false; break;
1774         case Bytecodes::_anewarray :
1775           verify_anewarray(
1776             bci, bcs.get_index_u2(), cp, &amp;current_frame, CHECK_VERIFY(this));
1777           no_control_flow = false; break;
1778         case Bytecodes::_arraylength :
1779           type = current_frame.pop_stack(
1780             VerificationType::reference_check(), CHECK_VERIFY(this));
1781           if (!(type.is_null() || type.is_array())) {
1782             verify_error(ErrorContext::bad_type(
1783                 bci, current_frame.stack_top_ctx()),
1784                 bad_type_msg, &quot;arraylength&quot;);
</pre>
<hr />
<pre>
2385   bool is_assignable;
2386   switch (bcs-&gt;raw_code()) {
2387     case Bytecodes::_getstatic: {
2388       for (int i = 0; i &lt; n; i++) {
2389         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
2390       }
2391       break;
2392     }
2393     case Bytecodes::_putstatic: {
2394       for (int i = n - 1; i &gt;= 0; i--) {
2395         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2396       }
2397       break;
2398     }
2399     case Bytecodes::_withfield: {
2400       for (int i = n - 1; i &gt;= 0; i--) {
2401         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2402       }
2403       // stack_object_type and target_class_type must be the same inline type.
2404       stack_object_type =
<span class="line-modified">2405         current_frame-&gt;pop_stack(VerificationType::inline_type_check(), CHECK_VERIFY(this));</span>
2406       VerificationType target_inline_type =
<span class="line-modified">2407         VerificationType::change_ref_to_inline_type(target_class_type);</span>
2408       if (!stack_object_type.equals(target_inline_type)) {
2409         verify_error(ErrorContext::bad_inline_type(bci,
2410             current_frame-&gt;stack_top_ctx(),
2411             TypeOrigin::cp(index, target_class_type)),
2412             &quot;Invalid type on operand stack in withfield instruction&quot;);
2413         return;
2414       }
2415       current_frame-&gt;push_stack(target_inline_type, CHECK_VERIFY(this));
2416       break;
2417     }
2418     case Bytecodes::_getfield: {
2419       stack_object_type = current_frame-&gt;pop_stack(
2420         target_class_type, CHECK_VERIFY(this));
2421       for (int i = 0; i &lt; n; i++) {
2422         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
2423       }
2424       goto check_protected;
2425     }
2426     case Bytecodes::_putfield: {
2427       for (int i = n - 1; i &gt;= 0; i--) {
</pre>
<hr />
<pre>
2924     // Make sure &lt;init&gt; can only be invoked by invokespecial or invokestatic.
2925     // The allowed invocation mode of &lt;init&gt; depends on its signature.
2926     if ((opcode != Bytecodes::_invokespecial &amp;&amp;
2927          opcode != Bytecodes::_invokestatic) ||
2928         method_name != vmSymbols::object_initializer_name()) {
2929       verify_error(ErrorContext::bad_code(bci),
2930           &quot;Illegal call to internal method&quot;);
2931       return;
2932     }
2933   } else if (opcode == Bytecodes::_invokespecial
2934              &amp;&amp; !is_same_or_direct_interface(current_class(), current_type(), ref_class_type)
2935              &amp;&amp; !ref_class_type.equals(VerificationType::reference_type(
2936                   current_class()-&gt;super()-&gt;name()))) { // super() can never be an inline_type.
2937     bool subtype = false;
2938     bool have_imr_indirect = cp-&gt;tag_at(index).value() == JVM_CONSTANT_InterfaceMethodref;
2939     if (!current_class()-&gt;is_unsafe_anonymous()) {
2940       subtype = ref_class_type.is_assignable_from(
2941                  current_type(), this, false, CHECK_VERIFY(this));
2942     } else {
2943       InstanceKlass* unsafe_host = current_class()-&gt;unsafe_anonymous_host();
<span class="line-modified">2944       VerificationType unsafe_anonymous_host_type = reference_or_inline_type(unsafe_host);</span>
2945       subtype = ref_class_type.is_assignable_from(unsafe_anonymous_host_type, this, false, CHECK_VERIFY(this));
2946 
2947       // If invokespecial of IMR, need to recheck for same or
2948       // direct interface relative to the host class
2949       have_imr_indirect = (have_imr_indirect &amp;&amp;
2950                            !is_same_or_direct_interface(
2951                              unsafe_host,
2952                              unsafe_anonymous_host_type, ref_class_type));
2953     }
2954     if (!subtype) {
2955       verify_error(ErrorContext::bad_code(bci),
2956           &quot;Bad invokespecial instruction: &quot;
2957           &quot;current class isn&#39;t assignable to reference class.&quot;);
2958        return;
2959     } else if (have_imr_indirect) {
2960       verify_error(ErrorContext::bad_code(bci),
2961           &quot;Bad invokespecial instruction: &quot;
2962           &quot;interface method reference is in an indirect superinterface.&quot;);
2963       return;
2964     }
</pre>
<hr />
<pre>
2978   if (opcode != Bytecodes::_invokestatic &amp;&amp;
2979       opcode != Bytecodes::_invokedynamic) {
2980     if (method_name == vmSymbols::object_initializer_name()) {  // &lt;init&gt; method
2981       // (use of &lt;init&gt; as a static factory is handled under invokestatic)
2982       verify_invoke_init(bcs, index, ref_class_type, current_frame,
2983         code_length, in_try_block, this_uninit, cp, stackmap_table,
2984         CHECK_VERIFY(this));
2985       if (was_recursively_verified()) return;
2986     } else {   // other methods
2987       // Ensures that target class is assignable to method class.
2988       if (opcode == Bytecodes::_invokespecial) {
2989         if (!current_class()-&gt;is_unsafe_anonymous()) {
2990           current_frame-&gt;pop_stack(current_type(), CHECK_VERIFY(this));
2991         } else {
2992           // anonymous class invokespecial calls: check if the
2993           // objectref is a subtype of the unsafe_anonymous_host of the current class
2994           // to allow an anonymous class to reference methods in the unsafe_anonymous_host
2995           VerificationType top = current_frame-&gt;pop_stack(CHECK_VERIFY(this));
2996 
2997           InstanceKlass* unsafe_host = current_class()-&gt;unsafe_anonymous_host();
<span class="line-modified">2998           VerificationType host_type = reference_or_inline_type(unsafe_host);</span>
2999           bool subtype = host_type.is_assignable_from(top, this, false, CHECK_VERIFY(this));
3000           if (!subtype) {
3001             verify_error( ErrorContext::bad_type(current_frame-&gt;offset(),
3002               current_frame-&gt;stack_top_ctx(),
3003               TypeOrigin::implicit(top)),
3004               &quot;Bad type on operand stack&quot;);
3005             return;
3006           }
3007         }
3008       } else if (opcode == Bytecodes::_invokevirtual) {
3009         VerificationType stack_object_type =
3010           current_frame-&gt;pop_stack(ref_class_type, CHECK_VERIFY(this));
3011         if (current_type() != stack_object_type) {
3012           if (was_recursively_verified()) return;
3013           assert(cp-&gt;cache() == NULL, &quot;not rewritten yet&quot;);
3014           Symbol* ref_class_name =
3015             cp-&gt;klass_name_at(cp-&gt;klass_ref_index_at(index));
3016           // See the comments in verify_field_instructions() for
3017           // the rationale behind this.
3018           if (name_in_supers(ref_class_name, current_class())) {
</pre>
<hr />
<pre>
3102     cp_index_to_type(index, cp, CHECK_VERIFY(this));
3103   int length;
3104   char* arr_sig_str;
3105   if (component_type.is_array()) {     // it&#39;s an array
3106     const char* component_name = component_type.name()-&gt;as_utf8();
3107     // Check for more than MAX_ARRAY_DIMENSIONS
3108     length = (int)strlen(component_name);
3109     if (length &gt; MAX_ARRAY_DIMENSIONS &amp;&amp;
3110         component_name[MAX_ARRAY_DIMENSIONS - 1] == JVM_SIGNATURE_ARRAY) {
3111       verify_error(ErrorContext::bad_code(bci),
3112         &quot;Illegal anewarray instruction, array has more than 255 dimensions&quot;);
3113     }
3114     // add one dimension to component
3115     length++;
3116     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3117     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%s&quot;,
3118                          JVM_SIGNATURE_ARRAY, component_name);
3119     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3120   } else {         // it&#39;s an object or interface
3121     const char* component_name = component_type.name()-&gt;as_utf8();
<span class="line-modified">3122     char Q_or_L = component_type.is_inline_type() ? JVM_SIGNATURE_INLINE_TYPE : JVM_SIGNATURE_CLASS;</span>
3123     // add one dimension to component with &#39;L&#39; or &#39;Q&#39; prepended and &#39;;&#39; appended.
3124     length = (int)strlen(component_name) + 3;
3125     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3126     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%c%s;&quot;,
3127                          JVM_SIGNATURE_ARRAY, Q_or_L, component_name);
3128     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3129   }
3130   Symbol* arr_sig = create_temporary_symbol(arr_sig_str, length);
3131   VerificationType new_array_type = VerificationType::reference_type(arr_sig);
3132   current_frame-&gt;push_stack(new_array_type, CHECK_VERIFY(this));
3133 }
3134 
3135 void ClassVerifier::verify_iload(u2 index, StackMapFrame* current_frame, TRAPS) {
3136   current_frame-&gt;get_local(
3137     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3138   current_frame-&gt;push_stack(
3139     VerificationType::integer_type(), CHECK_VERIFY(this));
3140 }
3141 
3142 void ClassVerifier::verify_lload(u2 index, StackMapFrame* current_frame, TRAPS) {
</pre>
</td>
</tr>
</table>
<center><a href="verificationType.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="verifier.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
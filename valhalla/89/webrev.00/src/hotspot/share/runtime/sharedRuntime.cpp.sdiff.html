<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/sharedRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="reflection.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sharedRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1090           if (attached_method-&gt;method_holder()-&gt;is_interface()) {
1091             bc = Bytecodes::_invokeinterface;
1092           }
1093           break;
1094         case Bytecodes::_invokeinterface:
1095           if (!attached_method-&gt;method_holder()-&gt;is_interface()) {
1096             bc = Bytecodes::_invokevirtual;
1097           }
1098           break;
1099         case Bytecodes::_invokehandle:
1100           if (!MethodHandles::is_signature_polymorphic_method(attached_method())) {
1101             bc = attached_method-&gt;is_static() ? Bytecodes::_invokestatic
1102                                               : Bytecodes::_invokevirtual;
1103           }
1104           break;
1105         default:
1106           break;
1107       }
1108     } else {
1109       assert(attached_method-&gt;has_scalarized_args(), &quot;invalid use of attached method&quot;);
<span class="line-modified">1110       if (!attached_method-&gt;method_holder()-&gt;is_value()) {</span>
1111         // Ignore the attached method in this case to not confuse below code
1112         attached_method = methodHandle(thread, NULL);
1113       }
1114     }
1115   }
1116 
1117   assert(bc != Bytecodes::_illegal, &quot;not initialized&quot;);
1118 
1119   bool has_receiver = bc != Bytecodes::_invokestatic &amp;&amp;
1120                       bc != Bytecodes::_invokedynamic &amp;&amp;
1121                       bc != Bytecodes::_invokehandle;
1122   bool check_null_and_abstract = true;
1123 
1124   // Find receiver for non-static call
1125   if (has_receiver) {
1126     // This register map must be update since we need to find the receiver for
1127     // compiled frames. The receiver might be in a register.
1128     RegisterMap reg_map2(thread);
1129     frame stubFrame   = thread-&gt;last_frame();
1130     // Caller-frame is a compiled frame
1131     frame callerFrame = stubFrame.sender(&amp;reg_map2);
1132     bool caller_is_c1 = false;
1133 
1134     if (callerFrame.is_compiled_frame() &amp;&amp; !callerFrame.is_deoptimized_frame()) {
1135       caller_is_c1 = callerFrame.cb()-&gt;is_compiled_by_c1();
1136     }
1137 
1138     Method* callee = attached_method();
1139     if (callee == NULL) {
1140       callee = bytecode.static_target(CHECK_NH);
1141       if (callee == NULL) {
1142         THROW_(vmSymbols::java_lang_NoSuchMethodException(), nullHandle);
1143       }
1144     }
<span class="line-modified">1145     if (!caller_is_c1 &amp;&amp; callee-&gt;has_scalarized_args() &amp;&amp; callee-&gt;method_holder()-&gt;is_value()) {</span>
1146       // If the receiver is a value type that is passed as fields, no oop is available.
1147       // Resolve the call without receiver null checking.
1148       assert(attached_method.not_null() &amp;&amp; !attached_method-&gt;is_abstract(), &quot;must have non-abstract attached method&quot;);
1149       if (bc == Bytecodes::_invokeinterface) {
1150         bc = Bytecodes::_invokevirtual; // C2 optimistically replaces interface calls by virtual calls
1151       }
1152       check_null_and_abstract = false;
1153     } else {
1154       // Retrieve from a compiled argument list
1155       receiver = Handle(THREAD, callerFrame.retrieve_receiver(&amp;reg_map2));
1156       if (receiver.is_null()) {
1157         THROW_(vmSymbols::java_lang_NullPointerException(), nullHandle);
1158       }
1159     }
1160   }
1161 
1162   // Resolve method
1163   if (attached_method.not_null()) {
1164     // Parameterized by attached method.
1165     LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, check_null_and_abstract, CHECK_NH);
</pre>
<hr />
<pre>
1268   CompiledMethod* callee = callee_method-&gt;code();
1269 
1270   if (callee != NULL) {
1271     assert(callee-&gt;is_compiled(), &quot;must be nmethod for patching&quot;);
1272   }
1273 
1274   if (callee != NULL &amp;&amp; !callee-&gt;is_in_use()) {
1275     // Patch call site to C2I adapter if callee nmethod is deoptimized or unloaded.
1276     callee = NULL;
1277   }
1278   nmethodLocker nl_callee(callee);
1279 #ifdef ASSERT
1280   address dest_entry_point = callee == NULL ? 0 : callee-&gt;entry_point(); // used below
1281 #endif
1282 
1283   bool is_nmethod = caller_nm-&gt;is_nmethod();
1284   bool caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();
1285 
1286   if (is_virtual) {
1287     Klass* receiver_klass = NULL;
<span class="line-modified">1288     if (InlineTypePassFieldsAsArgs &amp;&amp; !caller_is_c1 &amp;&amp; callee_method-&gt;method_holder()-&gt;is_value()) {</span>
1289       // If the receiver is an inline type that is passed as fields, no oop is available
1290       receiver_klass = callee_method-&gt;method_holder();
1291     } else {
1292       assert(receiver.not_null() || invoke_code == Bytecodes::_invokehandle, &quot;sanity check&quot;);
1293       receiver_klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver-&gt;klass();
1294     }
1295     bool static_bound = call_info.resolved_method()-&gt;can_be_statically_bound();
1296     CompiledIC::compute_monomorphic_entry(callee_method, receiver_klass,
1297                      is_optimized, static_bound, is_nmethod, caller_is_c1, virtual_call_info,
1298                      CHECK_false);
1299   } else {
1300     // static call
1301     CompiledStaticCall::compute_entry(callee_method, caller_nm, static_call_info);
1302   }
1303 
1304   // grab lock, check for deoptimization and potentially patch caller
1305   {
1306     CompiledICLocker ml(caller_nm);
1307 
1308     // Lock blocks for safepoint during which both nmethods can change state.
</pre>
<hr />
<pre>
2729   }
2730 
2731   return entry;
2732 }
2733 
2734 
2735 CompiledEntrySignature::CompiledEntrySignature(Method* method) :
2736   _method(method), _num_value_args(0), _has_value_recv(false),
2737   _sig_cc(NULL), _sig_cc_ro(NULL), _regs(NULL), _regs_cc(NULL), _regs_cc_ro(NULL),
2738   _args_on_stack(0), _args_on_stack_cc(0), _args_on_stack_cc_ro(0),
2739   _c1_needs_stack_repair(false), _c2_needs_stack_repair(false), _has_scalarized_args(false) {
2740   _has_reserved_entries = false;
2741   _sig = new GrowableArray&lt;SigEntry&gt;(method-&gt;size_of_parameters());
2742 
2743 }
2744 
2745 int CompiledEntrySignature::compute_scalarized_cc(GrowableArray&lt;SigEntry&gt;*&amp; sig_cc, VMRegPair*&amp; regs_cc, bool scalar_receiver) {
2746   InstanceKlass* holder = _method-&gt;method_holder();
2747   sig_cc = new GrowableArray&lt;SigEntry&gt;(_method-&gt;size_of_parameters());
2748   if (!_method-&gt;is_static()) {
<span class="line-modified">2749     if (holder-&gt;is_value() &amp;&amp; scalar_receiver &amp;&amp; ValueKlass::cast(holder)-&gt;is_scalarizable()) {</span>
2750       sig_cc-&gt;appendAll(ValueKlass::cast(holder)-&gt;extended_sig());
2751     } else {
2752       SigEntry::add_entry(sig_cc, T_OBJECT);
2753     }
2754   }
2755   Thread* THREAD = Thread::current();
2756   for (SignatureStream ss(_method-&gt;signature()); !ss.at_return_type(); ss.next()) {
2757     if (ss.type() == T_VALUETYPE) {
2758       ValueKlass* vk = ss.as_value_klass(holder);
2759       if (vk-&gt;is_scalarizable()) {
2760         sig_cc-&gt;appendAll(vk-&gt;extended_sig());
2761       } else {
2762         SigEntry::add_entry(sig_cc, T_OBJECT);
2763       }
2764     } else {
2765       SigEntry::add_entry(sig_cc, ss.type());
2766     }
2767   }
2768   regs_cc = NEW_RESOURCE_ARRAY(VMRegPair, sig_cc-&gt;length() + 2);
2769   return SharedRuntime::java_calling_convention(sig_cc, regs_cc);
</pre>
<hr />
<pre>
2816       return CodeOffsets::Verified_Value_Entry_RO;
2817     }
2818   }
2819 
2820   // Either a static method, or &lt;this&gt; is not a value type
2821   if (args_on_stack_cc() != args_on_stack_cc_ro() || _has_reserved_entries) {
2822     // No sharing:
2823     // Some arguments are passed on the stack, and we have inserted reserved entries
2824     // into the VEP, but we never insert reserved entries into the VVEP(RO).
2825     return CodeOffsets::Verified_Value_Entry_RO;
2826   } else {
2827     // Share same entry for VEP and VVEP(RO).
2828     return CodeOffsets::Verified_Entry;
2829   }
2830 }
2831 
2832 
2833 void CompiledEntrySignature::compute_calling_conventions() {
2834   // Get the (non-scalarized) signature and check for value type arguments
2835   if (!_method-&gt;is_static()) {
<span class="line-modified">2836     if (_method-&gt;method_holder()-&gt;is_value() &amp;&amp; ValueKlass::cast(_method-&gt;method_holder())-&gt;is_scalarizable()) {</span>
2837       _has_value_recv = true;
2838       _num_value_args++;
2839     }
2840     SigEntry::add_entry(_sig, T_OBJECT);
2841   }
2842   for (SignatureStream ss(_method-&gt;signature()); !ss.at_return_type(); ss.next()) {
2843     BasicType bt = ss.type();
2844     if (bt == T_VALUETYPE) {
2845       if (ss.as_value_klass(_method-&gt;method_holder())-&gt;is_scalarizable()) {
2846         _num_value_args++;
2847       }
2848       bt = T_OBJECT;
2849     }
2850     SigEntry::add_entry(_sig, bt);
2851   }
2852   if (_method-&gt;is_abstract() &amp;&amp; !(InlineTypePassFieldsAsArgs &amp;&amp; has_value_arg())) {
2853     return;
2854   }
2855 
2856   // Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage
</pre>
<hr />
<pre>
3579   // this object in the future without emitting card-marks, so
3580   // GC may take any compensating steps.
3581 
3582   oop new_obj = thread-&gt;vm_result();
3583   if (new_obj == NULL) return;
3584 
3585   BarrierSet *bs = BarrierSet::barrier_set();
3586   bs-&gt;on_slowpath_allocation_exit(thread, new_obj);
3587 }
3588 
3589 // We are at a compiled code to interpreter call. We need backing
3590 // buffers for all value type arguments. Allocate an object array to
3591 // hold them (convenient because once we&#39;re done with it we don&#39;t have
3592 // to worry about freeing it).
3593 oop SharedRuntime::allocate_value_types_impl(JavaThread* thread, methodHandle callee, bool allocate_receiver, TRAPS) {
3594   assert(InlineTypePassFieldsAsArgs, &quot;no reason to call this&quot;);
3595   ResourceMark rm;
3596 
3597   int nb_slots = 0;
3598   InstanceKlass* holder = callee-&gt;method_holder();
<span class="line-modified">3599   allocate_receiver &amp;= !callee-&gt;is_static() &amp;&amp; holder-&gt;is_value();</span>
3600   if (allocate_receiver) {
3601     nb_slots++;
3602   }
3603   for (SignatureStream ss(callee-&gt;signature()); !ss.at_return_type(); ss.next()) {
3604     if (ss.type() == T_VALUETYPE) {
3605       nb_slots++;
3606     }
3607   }
3608   objArrayOop array_oop = oopFactory::new_objectArray(nb_slots, CHECK_NULL);
3609   objArrayHandle array(THREAD, array_oop);
3610   int i = 0;
3611   if (allocate_receiver) {
3612     ValueKlass* vk = ValueKlass::cast(holder);
3613     oop res = vk-&gt;allocate_instance(CHECK_NULL);
3614     array-&gt;obj_at_put(i, res);
3615     i++;
3616   }
3617   for (SignatureStream ss(callee-&gt;signature()); !ss.at_return_type(); ss.next()) {
3618     if (ss.type() == T_VALUETYPE) {
3619       ValueKlass* vk = ss.as_value_klass(holder);
</pre>
<hr />
<pre>
3644     ValueKlass* vk = ValueKlass::cast(valueOop-&gt;klass());
3645     if (vk-&gt;contains_oops()) {
3646       const address dst_oop_addr = ((address) (void*) valueOop);
3647       OopMapBlock* map = vk-&gt;start_of_nonstatic_oop_maps();
3648       OopMapBlock* const end = map + vk-&gt;nonstatic_oop_map_count();
3649       while (map != end) {
3650         address doop_address = dst_oop_addr + map-&gt;offset();
3651         barrier_set_cast&lt;ModRefBarrierSet&gt;(BarrierSet::barrier_set())-&gt;
3652           write_ref_array((HeapWord*) doop_address, map-&gt;count());
3653         map++;
3654       }
3655     }
3656   }
3657 }
3658 JRT_END
3659 
3660 // We&#39;re returning from an interpreted method: load each field into a
3661 // register following the calling convention
3662 JRT_LEAF(void, SharedRuntime::load_value_type_fields_in_regs(JavaThread* thread, oopDesc* res))
3663 {
<span class="line-modified">3664   assert(res-&gt;klass()-&gt;is_value(), &quot;only value types here&quot;);</span>
3665   ResourceMark rm;
3666   RegisterMap reg_map(thread);
3667   frame stubFrame = thread-&gt;last_frame();
3668   frame callerFrame = stubFrame.sender(&amp;reg_map);
3669   assert(callerFrame.is_interpreted_frame(), &quot;should be coming from interpreter&quot;);
3670 
3671   ValueKlass* vk = ValueKlass::cast(res-&gt;klass());
3672 
3673   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();
3674   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();
3675 
3676   if (regs == NULL) {
3677     // The fields of the value klass don&#39;t fit in registers, bail out
3678     return;
3679   }
3680 
3681   int j = 1;
3682   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
3683     BasicType bt = sig_vk-&gt;at(i)._bt;
3684     if (bt == T_VALUETYPE) {
</pre>
</td>
<td>
<hr />
<pre>
1090           if (attached_method-&gt;method_holder()-&gt;is_interface()) {
1091             bc = Bytecodes::_invokeinterface;
1092           }
1093           break;
1094         case Bytecodes::_invokeinterface:
1095           if (!attached_method-&gt;method_holder()-&gt;is_interface()) {
1096             bc = Bytecodes::_invokevirtual;
1097           }
1098           break;
1099         case Bytecodes::_invokehandle:
1100           if (!MethodHandles::is_signature_polymorphic_method(attached_method())) {
1101             bc = attached_method-&gt;is_static() ? Bytecodes::_invokestatic
1102                                               : Bytecodes::_invokevirtual;
1103           }
1104           break;
1105         default:
1106           break;
1107       }
1108     } else {
1109       assert(attached_method-&gt;has_scalarized_args(), &quot;invalid use of attached method&quot;);
<span class="line-modified">1110       if (!attached_method-&gt;method_holder()-&gt;is_inline_klass()) {</span>
1111         // Ignore the attached method in this case to not confuse below code
1112         attached_method = methodHandle(thread, NULL);
1113       }
1114     }
1115   }
1116 
1117   assert(bc != Bytecodes::_illegal, &quot;not initialized&quot;);
1118 
1119   bool has_receiver = bc != Bytecodes::_invokestatic &amp;&amp;
1120                       bc != Bytecodes::_invokedynamic &amp;&amp;
1121                       bc != Bytecodes::_invokehandle;
1122   bool check_null_and_abstract = true;
1123 
1124   // Find receiver for non-static call
1125   if (has_receiver) {
1126     // This register map must be update since we need to find the receiver for
1127     // compiled frames. The receiver might be in a register.
1128     RegisterMap reg_map2(thread);
1129     frame stubFrame   = thread-&gt;last_frame();
1130     // Caller-frame is a compiled frame
1131     frame callerFrame = stubFrame.sender(&amp;reg_map2);
1132     bool caller_is_c1 = false;
1133 
1134     if (callerFrame.is_compiled_frame() &amp;&amp; !callerFrame.is_deoptimized_frame()) {
1135       caller_is_c1 = callerFrame.cb()-&gt;is_compiled_by_c1();
1136     }
1137 
1138     Method* callee = attached_method();
1139     if (callee == NULL) {
1140       callee = bytecode.static_target(CHECK_NH);
1141       if (callee == NULL) {
1142         THROW_(vmSymbols::java_lang_NoSuchMethodException(), nullHandle);
1143       }
1144     }
<span class="line-modified">1145     if (!caller_is_c1 &amp;&amp; callee-&gt;has_scalarized_args() &amp;&amp; callee-&gt;method_holder()-&gt;is_inline_klass()) {</span>
1146       // If the receiver is a value type that is passed as fields, no oop is available.
1147       // Resolve the call without receiver null checking.
1148       assert(attached_method.not_null() &amp;&amp; !attached_method-&gt;is_abstract(), &quot;must have non-abstract attached method&quot;);
1149       if (bc == Bytecodes::_invokeinterface) {
1150         bc = Bytecodes::_invokevirtual; // C2 optimistically replaces interface calls by virtual calls
1151       }
1152       check_null_and_abstract = false;
1153     } else {
1154       // Retrieve from a compiled argument list
1155       receiver = Handle(THREAD, callerFrame.retrieve_receiver(&amp;reg_map2));
1156       if (receiver.is_null()) {
1157         THROW_(vmSymbols::java_lang_NullPointerException(), nullHandle);
1158       }
1159     }
1160   }
1161 
1162   // Resolve method
1163   if (attached_method.not_null()) {
1164     // Parameterized by attached method.
1165     LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, check_null_and_abstract, CHECK_NH);
</pre>
<hr />
<pre>
1268   CompiledMethod* callee = callee_method-&gt;code();
1269 
1270   if (callee != NULL) {
1271     assert(callee-&gt;is_compiled(), &quot;must be nmethod for patching&quot;);
1272   }
1273 
1274   if (callee != NULL &amp;&amp; !callee-&gt;is_in_use()) {
1275     // Patch call site to C2I adapter if callee nmethod is deoptimized or unloaded.
1276     callee = NULL;
1277   }
1278   nmethodLocker nl_callee(callee);
1279 #ifdef ASSERT
1280   address dest_entry_point = callee == NULL ? 0 : callee-&gt;entry_point(); // used below
1281 #endif
1282 
1283   bool is_nmethod = caller_nm-&gt;is_nmethod();
1284   bool caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();
1285 
1286   if (is_virtual) {
1287     Klass* receiver_klass = NULL;
<span class="line-modified">1288     if (InlineTypePassFieldsAsArgs &amp;&amp; !caller_is_c1 &amp;&amp; callee_method-&gt;method_holder()-&gt;is_inline_klass()) {</span>
1289       // If the receiver is an inline type that is passed as fields, no oop is available
1290       receiver_klass = callee_method-&gt;method_holder();
1291     } else {
1292       assert(receiver.not_null() || invoke_code == Bytecodes::_invokehandle, &quot;sanity check&quot;);
1293       receiver_klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver-&gt;klass();
1294     }
1295     bool static_bound = call_info.resolved_method()-&gt;can_be_statically_bound();
1296     CompiledIC::compute_monomorphic_entry(callee_method, receiver_klass,
1297                      is_optimized, static_bound, is_nmethod, caller_is_c1, virtual_call_info,
1298                      CHECK_false);
1299   } else {
1300     // static call
1301     CompiledStaticCall::compute_entry(callee_method, caller_nm, static_call_info);
1302   }
1303 
1304   // grab lock, check for deoptimization and potentially patch caller
1305   {
1306     CompiledICLocker ml(caller_nm);
1307 
1308     // Lock blocks for safepoint during which both nmethods can change state.
</pre>
<hr />
<pre>
2729   }
2730 
2731   return entry;
2732 }
2733 
2734 
2735 CompiledEntrySignature::CompiledEntrySignature(Method* method) :
2736   _method(method), _num_value_args(0), _has_value_recv(false),
2737   _sig_cc(NULL), _sig_cc_ro(NULL), _regs(NULL), _regs_cc(NULL), _regs_cc_ro(NULL),
2738   _args_on_stack(0), _args_on_stack_cc(0), _args_on_stack_cc_ro(0),
2739   _c1_needs_stack_repair(false), _c2_needs_stack_repair(false), _has_scalarized_args(false) {
2740   _has_reserved_entries = false;
2741   _sig = new GrowableArray&lt;SigEntry&gt;(method-&gt;size_of_parameters());
2742 
2743 }
2744 
2745 int CompiledEntrySignature::compute_scalarized_cc(GrowableArray&lt;SigEntry&gt;*&amp; sig_cc, VMRegPair*&amp; regs_cc, bool scalar_receiver) {
2746   InstanceKlass* holder = _method-&gt;method_holder();
2747   sig_cc = new GrowableArray&lt;SigEntry&gt;(_method-&gt;size_of_parameters());
2748   if (!_method-&gt;is_static()) {
<span class="line-modified">2749     if (holder-&gt;is_inline_klass() &amp;&amp; scalar_receiver &amp;&amp; ValueKlass::cast(holder)-&gt;is_scalarizable()) {</span>
2750       sig_cc-&gt;appendAll(ValueKlass::cast(holder)-&gt;extended_sig());
2751     } else {
2752       SigEntry::add_entry(sig_cc, T_OBJECT);
2753     }
2754   }
2755   Thread* THREAD = Thread::current();
2756   for (SignatureStream ss(_method-&gt;signature()); !ss.at_return_type(); ss.next()) {
2757     if (ss.type() == T_VALUETYPE) {
2758       ValueKlass* vk = ss.as_value_klass(holder);
2759       if (vk-&gt;is_scalarizable()) {
2760         sig_cc-&gt;appendAll(vk-&gt;extended_sig());
2761       } else {
2762         SigEntry::add_entry(sig_cc, T_OBJECT);
2763       }
2764     } else {
2765       SigEntry::add_entry(sig_cc, ss.type());
2766     }
2767   }
2768   regs_cc = NEW_RESOURCE_ARRAY(VMRegPair, sig_cc-&gt;length() + 2);
2769   return SharedRuntime::java_calling_convention(sig_cc, regs_cc);
</pre>
<hr />
<pre>
2816       return CodeOffsets::Verified_Value_Entry_RO;
2817     }
2818   }
2819 
2820   // Either a static method, or &lt;this&gt; is not a value type
2821   if (args_on_stack_cc() != args_on_stack_cc_ro() || _has_reserved_entries) {
2822     // No sharing:
2823     // Some arguments are passed on the stack, and we have inserted reserved entries
2824     // into the VEP, but we never insert reserved entries into the VVEP(RO).
2825     return CodeOffsets::Verified_Value_Entry_RO;
2826   } else {
2827     // Share same entry for VEP and VVEP(RO).
2828     return CodeOffsets::Verified_Entry;
2829   }
2830 }
2831 
2832 
2833 void CompiledEntrySignature::compute_calling_conventions() {
2834   // Get the (non-scalarized) signature and check for value type arguments
2835   if (!_method-&gt;is_static()) {
<span class="line-modified">2836     if (_method-&gt;method_holder()-&gt;is_inline_klass() &amp;&amp; ValueKlass::cast(_method-&gt;method_holder())-&gt;is_scalarizable()) {</span>
2837       _has_value_recv = true;
2838       _num_value_args++;
2839     }
2840     SigEntry::add_entry(_sig, T_OBJECT);
2841   }
2842   for (SignatureStream ss(_method-&gt;signature()); !ss.at_return_type(); ss.next()) {
2843     BasicType bt = ss.type();
2844     if (bt == T_VALUETYPE) {
2845       if (ss.as_value_klass(_method-&gt;method_holder())-&gt;is_scalarizable()) {
2846         _num_value_args++;
2847       }
2848       bt = T_OBJECT;
2849     }
2850     SigEntry::add_entry(_sig, bt);
2851   }
2852   if (_method-&gt;is_abstract() &amp;&amp; !(InlineTypePassFieldsAsArgs &amp;&amp; has_value_arg())) {
2853     return;
2854   }
2855 
2856   // Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage
</pre>
<hr />
<pre>
3579   // this object in the future without emitting card-marks, so
3580   // GC may take any compensating steps.
3581 
3582   oop new_obj = thread-&gt;vm_result();
3583   if (new_obj == NULL) return;
3584 
3585   BarrierSet *bs = BarrierSet::barrier_set();
3586   bs-&gt;on_slowpath_allocation_exit(thread, new_obj);
3587 }
3588 
3589 // We are at a compiled code to interpreter call. We need backing
3590 // buffers for all value type arguments. Allocate an object array to
3591 // hold them (convenient because once we&#39;re done with it we don&#39;t have
3592 // to worry about freeing it).
3593 oop SharedRuntime::allocate_value_types_impl(JavaThread* thread, methodHandle callee, bool allocate_receiver, TRAPS) {
3594   assert(InlineTypePassFieldsAsArgs, &quot;no reason to call this&quot;);
3595   ResourceMark rm;
3596 
3597   int nb_slots = 0;
3598   InstanceKlass* holder = callee-&gt;method_holder();
<span class="line-modified">3599   allocate_receiver &amp;= !callee-&gt;is_static() &amp;&amp; holder-&gt;is_inline_klass();</span>
3600   if (allocate_receiver) {
3601     nb_slots++;
3602   }
3603   for (SignatureStream ss(callee-&gt;signature()); !ss.at_return_type(); ss.next()) {
3604     if (ss.type() == T_VALUETYPE) {
3605       nb_slots++;
3606     }
3607   }
3608   objArrayOop array_oop = oopFactory::new_objectArray(nb_slots, CHECK_NULL);
3609   objArrayHandle array(THREAD, array_oop);
3610   int i = 0;
3611   if (allocate_receiver) {
3612     ValueKlass* vk = ValueKlass::cast(holder);
3613     oop res = vk-&gt;allocate_instance(CHECK_NULL);
3614     array-&gt;obj_at_put(i, res);
3615     i++;
3616   }
3617   for (SignatureStream ss(callee-&gt;signature()); !ss.at_return_type(); ss.next()) {
3618     if (ss.type() == T_VALUETYPE) {
3619       ValueKlass* vk = ss.as_value_klass(holder);
</pre>
<hr />
<pre>
3644     ValueKlass* vk = ValueKlass::cast(valueOop-&gt;klass());
3645     if (vk-&gt;contains_oops()) {
3646       const address dst_oop_addr = ((address) (void*) valueOop);
3647       OopMapBlock* map = vk-&gt;start_of_nonstatic_oop_maps();
3648       OopMapBlock* const end = map + vk-&gt;nonstatic_oop_map_count();
3649       while (map != end) {
3650         address doop_address = dst_oop_addr + map-&gt;offset();
3651         barrier_set_cast&lt;ModRefBarrierSet&gt;(BarrierSet::barrier_set())-&gt;
3652           write_ref_array((HeapWord*) doop_address, map-&gt;count());
3653         map++;
3654       }
3655     }
3656   }
3657 }
3658 JRT_END
3659 
3660 // We&#39;re returning from an interpreted method: load each field into a
3661 // register following the calling convention
3662 JRT_LEAF(void, SharedRuntime::load_value_type_fields_in_regs(JavaThread* thread, oopDesc* res))
3663 {
<span class="line-modified">3664   assert(res-&gt;klass()-&gt;is_inline_klass(), &quot;only inline types here&quot;);</span>
3665   ResourceMark rm;
3666   RegisterMap reg_map(thread);
3667   frame stubFrame = thread-&gt;last_frame();
3668   frame callerFrame = stubFrame.sender(&amp;reg_map);
3669   assert(callerFrame.is_interpreted_frame(), &quot;should be coming from interpreter&quot;);
3670 
3671   ValueKlass* vk = ValueKlass::cast(res-&gt;klass());
3672 
3673   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();
3674   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();
3675 
3676   if (regs == NULL) {
3677     // The fields of the value klass don&#39;t fit in registers, bail out
3678     return;
3679   }
3680 
3681   int j = 1;
3682   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
3683     BasicType bt = sig_vk-&gt;at(i)._bt;
3684     if (bt == T_VALUETYPE) {
</pre>
</td>
</tr>
</table>
<center><a href="reflection.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
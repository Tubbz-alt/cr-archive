diff a/src/hotspot/share/runtime/javaCalls.cpp b/src/hotspot/share/runtime/javaCalls.cpp
--- a/src/hotspot/share/runtime/javaCalls.cpp
+++ b/src/hotspot/share/runtime/javaCalls.cpp
@@ -301,20 +301,20 @@
 Handle JavaCalls::construct_new_instance(InstanceKlass* klass, Symbol* constructor_signature, JavaCallArguments* args, TRAPS) {
   klass->initialize(CHECK_NH); // Quick no-op if already initialized.
 
   // Special case for factory methods
   if (!constructor_signature->is_void_method_signature()) {
-    assert(klass->is_value(), "inline classes must use factory methods");
+    assert(klass->is_inline_klass(), "inline classes must use factory methods");
     JavaValue factory_result(T_OBJECT);
     JavaCalls::call_static(&factory_result, klass,
                            vmSymbols::object_initializer_name(),
                            constructor_signature, args, CHECK_NH);
     return Handle(THREAD, (oop)factory_result.get_jobject());
   }
 
   // main branch of code creates a non-inline object:
-  assert(!klass->is_value(), "classic constructors are only for non-inline classes");
+  assert(!klass->is_inline_klass(), "classic constructors are only for non-inline classes");
   Handle obj = klass->allocate_instance_handle(CHECK_NH);
   JavaValue void_result(T_VOID);
   args->set_receiver(obj); // inserts <obj> as the first argument.
   JavaCalls::call_special(&void_result, klass,
                           vmSymbols::object_initializer_name(),

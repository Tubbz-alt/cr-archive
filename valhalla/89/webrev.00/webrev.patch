diff a/src/hotspot/share/asm/macroAssembler_common.cpp b/src/hotspot/share/asm/macroAssembler_common.cpp
--- a/src/hotspot/share/asm/macroAssembler_common.cpp
+++ b/src/hotspot/share/asm/macroAssembler_common.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -146,11 +146,11 @@
       }
     }
   } else {
     // Only unpack the receiver, all other arguments are already scalarized
     InstanceKlass* holder = method->method_holder();
-    int rec_len = holder->is_value() ? ValueKlass::cast(holder)->extended_sig()->length() : 1;
+    int rec_len = holder->is_inline_klass() ? ValueKlass::cast(holder)->extended_sig()->length() : 1;
     // Copy scalarized signature but skip receiver, value type delimiters and reserved entries
     for (int i = 0; i < sig_cc->length(); i++) {
       if (!SigEntry::is_reserved_entry(sig_cc, i)) {
         if (SigEntry::skip_value_delimiters(sig_cc, i) && rec_len <= 0) {
           sig_bt[args_passed++] = sig_cc->at(i)._bt;
diff a/src/hotspot/share/c1/c1_Runtime1.cpp b/src/hotspot/share/c1/c1_Runtime1.cpp
--- a/src/hotspot/share/c1/c1_Runtime1.cpp
+++ b/src/hotspot/share/c1/c1_Runtime1.cpp
@@ -420,11 +420,11 @@
   //       anymore after new_objArray() and no GC can happen before.
   //       (This may have to change if this code changes!)
   assert(array_klass->is_klass(), "not a class");
   Handle holder(THREAD, array_klass->klass_holder()); // keep the klass alive
   Klass* elem_klass = ArrayKlass::cast(array_klass)->element_klass();
-  assert(elem_klass->is_value(), "must be");
+  assert(elem_klass->is_inline_klass(), "must be");
   // Logically creates elements, ensure klass init
   elem_klass->initialize(CHECK);
   arrayOop obj = oopFactory::new_valueArray(elem_klass, length, CHECK);
   thread->set_vm_result(obj);
   // This is pretty rare but this runtime patch is stressful to deoptimization
diff a/src/hotspot/share/ci/ciMethodType.cpp b/src/hotspot/share/ci/ciMethodType.cpp
--- a/src/hotspot/share/ci/ciMethodType.cpp
+++ b/src/hotspot/share/ci/ciMethodType.cpp
@@ -39,11 +39,11 @@
 }
 
 ciType* ciMethodType::rtype(bool& never_null) const {
   GUARDED_VM_ENTRY(
     oop rtype = java_lang_invoke_MethodType::rtype(get_oop());
-    never_null = (java_lang_Class::as_Klass(rtype)->is_value());
+    never_null = (java_lang_Class::as_Klass(rtype)->is_inline_klass());
     return class_to_citype(rtype);
   )
 }
 
 int ciMethodType::ptype_count() const {
@@ -55,9 +55,9 @@
 }
 
 ciType* ciMethodType::ptype_at(int index, bool& never_null) const {
   GUARDED_VM_ENTRY(
     oop ptype = java_lang_invoke_MethodType::ptype(get_oop(), index);
-    never_null = (java_lang_Class::as_Klass(ptype)->is_value());
+    never_null = (java_lang_Class::as_Klass(ptype)->is_inline_klass());
     return class_to_citype(ptype);
   )
 }
diff a/src/hotspot/share/ci/ciObjectFactory.cpp b/src/hotspot/share/ci/ciObjectFactory.cpp
--- a/src/hotspot/share/ci/ciObjectFactory.cpp
+++ b/src/hotspot/share/ci/ciObjectFactory.cpp
@@ -386,11 +386,11 @@
 ciMetadata* ciObjectFactory::create_new_metadata(Metadata* o) {
   EXCEPTION_CONTEXT;
 
   if (o->is_klass()) {
     Klass* k = (Klass*)o;
-    if (k->is_value()) {
+    if (k->is_inline_klass()) {
       return new (arena()) ciValueKlass(k);
     } else if (k->is_instance_klass()) {
       return new (arena()) ciInstanceKlass(k);
     } else if (k->is_valueArray_klass()) {
       return new (arena()) ciValueArrayKlass(k);
diff a/src/hotspot/share/ci/ciType.cpp b/src/hotspot/share/ci/ciType.cpp
--- a/src/hotspot/share/ci/ciType.cpp
+++ b/src/hotspot/share/ci/ciType.cpp
@@ -44,11 +44,11 @@
   assert(basic_type >= T_BOOLEAN && basic_type <= T_CONFLICT, "range check");
   _basic_type = basic_type;
 }
 
 ciType::ciType(Klass* k) : ciMetadata(k) {
-  _basic_type = k->is_array_klass() ? T_ARRAY : (k->is_value() ? T_VALUETYPE : T_OBJECT);
+  _basic_type = k->is_array_klass() ? T_ARRAY : (k->is_inline_klass() ? T_VALUETYPE : T_OBJECT);
 }
 
 
 // ------------------------------------------------------------------
 // ciType::is_subtype_of
diff a/src/hotspot/share/classfile/classFileParser.cpp b/src/hotspot/share/classfile/classFileParser.cpp
--- a/src/hotspot/share/classfile/classFileParser.cpp
+++ b/src/hotspot/share/classfile/classFileParser.cpp
@@ -4994,11 +4994,11 @@
 #endif
 
   // Check if this klass supports the java.lang.Cloneable interface
   if (SystemDictionary::Cloneable_klass_loaded()) {
     if (ik->is_subtype_of(SystemDictionary::Cloneable_klass())) {
-      if (ik->is_value()) {
+      if (ik->is_inline_klass()) {
         Thread *THREAD = Thread::current();
         throwInlineTypeLimitation(THREAD_AND_LOCATION, "Inline Types do not support Cloneable");
         return;
       }
       ik->set_is_cloneable();
@@ -6172,11 +6172,11 @@
       log_info(class, fingerprint)("%s :  expected = " PTR64_FORMAT " actual = " PTR64_FORMAT,
                                  ik->external_name(), aot_fp, _stream->compute_fingerprint());
     }
   }
 
-  if (ik->is_value()) {
+  if (ik->is_inline_klass()) {
     ValueKlass* vk = ValueKlass::cast(ik);
     oop val = ik->allocate_instance(CHECK_NULL);
     vk->set_default_value(val);
   }
 
@@ -6247,11 +6247,11 @@
   ik->set_should_verify_class(_need_verify);
 
   // Not yet: supers are done below to support the new subtype-checking fields
   ik->set_nonstatic_field_size(_field_info->_nonstatic_field_size);
   ik->set_has_nonstatic_fields(_field_info->_has_nonstatic_fields);
-  if (_field_info->_is_naturally_atomic && ik->is_value()) {
+  if (_field_info->_is_naturally_atomic && ik->is_inline_klass()) {
     ik->set_is_naturally_atomic();
   }
   if (_is_empty_inline_type) {
     ik->set_is_empty_inline_type();
   }
@@ -6428,11 +6428,11 @@
       JvmtiExport::add_default_read_edges(module_handle, THREAD);
     }
   }
 
   int nfields = ik->java_fields_count();
-  if (ik->is_value()) nfields++;
+  if (ik->is_inline_klass()) nfields++;
   for (int i = 0; i < nfields; i++) {
     if (ik->field_is_inline_type(i)) {
       Symbol* klass_name = ik->field_signature(i)->fundamental_name(CHECK);
       // Inline classes for instance fields must have been pre-loaded
       // Inline classes for static fields might not have been loaded yet
diff a/src/hotspot/share/classfile/classLoaderData.cpp b/src/hotspot/share/classfile/classLoaderData.cpp
--- a/src/hotspot/share/classfile/classLoaderData.cpp
+++ b/src/hotspot/share/classfile/classLoaderData.cpp
@@ -375,11 +375,11 @@
 }
 
 void ClassLoaderData::value_classes_do(void f(ValueKlass*)) {
   // Lock-free access requires load_acquire
   for (Klass* k = Atomic::load_acquire(&_klasses); k != NULL; k = k->next_link()) {
-    if (k->is_value()) {
+    if (k->is_inline_klass()) {
       f(ValueKlass::cast(k));
     }
     assert(k != k->next_link(), "no loops!");
   }
 }
@@ -844,11 +844,11 @@
       if (m->is_method()) {
         MetadataFactory::free_metadata(this, (Method*)m);
       } else if (m->is_constantPool()) {
         MetadataFactory::free_metadata(this, (ConstantPool*)m);
       } else if (m->is_klass()) {
-        if (!((Klass*)m)->is_value()) {
+        if (!((Klass*)m)->is_inline_klass()) {
           MetadataFactory::free_metadata(this, (InstanceKlass*)m);
         } else {
           MetadataFactory::free_metadata(this, (ValueKlass*)m);
         }
       } else {
diff a/src/hotspot/share/classfile/javaClasses.cpp b/src/hotspot/share/classfile/javaClasses.cpp
--- a/src/hotspot/share/classfile/javaClasses.cpp
+++ b/src/hotspot/share/classfile/javaClasses.cpp
@@ -1007,11 +1007,11 @@
 
     // It might also have a component mirror.  This mirror must already exist.
     if (k->is_array_klass()) {
       if (k->is_valueArray_klass()) {
         Klass* element_klass = (Klass*) ValueArrayKlass::cast(k)->element_klass();
-        assert(element_klass->is_value(), "Must be value type component");
+        assert(element_klass->is_inline_klass(), "Must be inline type component");
         ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(element_klass));
         comp_mirror = Handle(THREAD, vk->java_mirror());
       } else if (k->is_typeArray_klass()) {
         BasicType type = TypeArrayKlass::cast(k)->element_type();
         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
@@ -1058,11 +1058,11 @@
       // Set after k->java_mirror() is published, because compiled code running
       // concurrently doesn't expect a k to have a null java_mirror.
       release_set_array_klass(comp_mirror(), k);
     }
 
-    if (k->is_value()) {
+    if (k->is_inline_klass()) {
       InstanceKlass* super = k->java_super();
       set_val_type_mirror(mirror(), mirror());
 
       // if the supertype is a restricted abstract class
       if (super != SystemDictionary::Object_klass()) {
@@ -1230,12 +1230,12 @@
       k->set_java_mirror_handle(OopHandle());
       return NULL;
     }
   }
 
-  if (k->is_value()) {
-    // Values have a val type mirror and a ref type mirror. Don't handle this for now. TODO:CDS
+  if (k->is_inline_klass()) {
+    // Inline types have a val type mirror and a ref type mirror. Don't handle this for now. TODO:CDS
     k->set_java_mirror_handle(OopHandle());
     return NULL;
   }
 
   // Now start archiving the mirror object
@@ -1589,11 +1589,11 @@
   if (is_primitive(java_class)) {
     name = vmSymbols::type_signature(primitive_type(java_class));
   } else {
     Klass* k = as_Klass(java_class);
     is_instance = k->is_instance_klass();
-    is_value = k->is_value();
+    is_value = k->is_inline_klass();
     name = k->name();
   }
   if (name == NULL) {
     st->print("<null>");
     return;
diff a/src/hotspot/share/classfile/stackMapFrame.cpp b/src/hotspot/share/classfile/stackMapFrame.cpp
--- a/src/hotspot/share/classfile/stackMapFrame.cpp
+++ b/src/hotspot/share/classfile/stackMapFrame.cpp
@@ -110,11 +110,11 @@
           verifier()->create_temporary_symbol(sig);
         assert(sig_copy == sig, "symbols don't match");
         sig = sig_copy;
       }
       if (ss.type() == T_VALUETYPE) {
-        return VerificationType::inlinetype_type(sig);
+        return VerificationType::inline_type(sig);
       }
       return VerificationType::reference_type(sig);
     }
     case T_INT:     return VerificationType::integer_type();
     case T_BYTE:    return VerificationType::byte_type();
diff a/src/hotspot/share/classfile/stackMapTable.cpp b/src/hotspot/share/classfile/stackMapTable.cpp
--- a/src/hotspot/share/classfile/stackMapTable.cpp
+++ b/src/hotspot/share/classfile/stackMapTable.cpp
@@ -192,11 +192,11 @@
       Symbol* fund_name = klass_name->fundamental_name(THREAD);
       if (fund_name == NULL) {
         _stream->stackmap_format_error("TBD something bad happened", THREAD);
         return VerificationType::bogus_type();
       }
-      return VerificationType::inlinetype_type(fund_name);
+      return VerificationType::inline_type(fund_name);
     } else {
       return VerificationType::reference_type(klass_name);
     }
   }
   if (tag == ITEM_UninitializedThis) {
diff a/src/hotspot/share/classfile/verificationType.cpp b/src/hotspot/share/classfile/verificationType.cpp
--- a/src/hotspot/share/classfile/verificationType.cpp
+++ b/src/hotspot/share/classfile/verificationType.cpp
@@ -126,11 +126,11 @@
 
 /*
     // This code implements non-covariance between inline type arrays and both
     // arrays of objects and arrays of interface types.  If covariance is
     // supported for inline type arrays then this code should be removed.
-    if (comp_from.is_inlinetype() && !comp_this.is_null() && comp_this.is_reference()) {
+    if (comp_from.is_inline_type() && !comp_this.is_null() && comp_this.is_reference()) {
       // An array of inline types is not assignable to an array of java.lang.Objects.
       if (comp_this.name() == vmSymbols::java_lang_Object()) {
         return false;
       }
 
@@ -158,15 +158,15 @@
     }
   }
   return false;
 }
 
-bool VerificationType::is_inlinetype_assignable_from(const VerificationType& from) const {
+bool VerificationType::is_inline_type_assignable_from(const VerificationType& from) const {
   // Check that 'from' is not null, is an inline type, and is the same inline type.
-  assert(is_inlinetype(), "called with a non-inlinetype type");
-  assert(!is_null(), "inlinetype is not null");
-  return (!from.is_null() && from.is_inlinetype() && name() == from.name());
+  assert(is_inline_type(), "called with a non-inline type");
+  assert(!is_null(), "inline type is not null");
+  return (!from.is_null() && from.is_inline_type() && name() == from.name());
 }
 
 bool VerificationType::is_ref_assignable_from_inline_type(const VerificationType& from, ClassVerifier* context, TRAPS) const {
   assert(!from.is_null(), "Inline type should not be null");
   if (!is_null() && (name()->is_same_fundamental_type(from.name()) ||
@@ -219,11 +219,11 @@
       Symbol* component = ss.as_symbol();
       // Create another symbol to save as signature stream unreferences this symbol.
       Symbol* component_copy = context->create_temporary_symbol(component);
       assert(component_copy == component, "symbols don't match");
       return (ss.type() == T_VALUETYPE) ?
-        VerificationType::inlinetype_type(component_copy) :
+        VerificationType::inline_type(component_copy) :
         VerificationType::reference_type(component_copy);
    }
    default:
      // Met an invalid type signature, e.g. [X
      return VerificationType::bogus_type();
@@ -256,11 +256,11 @@
     default:
       if (is_uninitialized_this()) {
         st->print("uninitializedThis");
       } else if (is_uninitialized()) {
         st->print("uninitialized %d", bci());
-      } else if (is_inlinetype()) {
+      } else if (is_inline_type()) {
         name()->print_Qvalue_on(st);
       } else {
         if (name() != NULL) {
           name()->print_value_on(st);
         } else {
diff a/src/hotspot/share/classfile/verificationType.hpp b/src/hotspot/share/classfile/verificationType.hpp
--- a/src/hotspot/share/classfile/verificationType.hpp
+++ b/src/hotspot/share/classfile/verificationType.hpp
@@ -151,11 +151,11 @@
   // to anything, but the specified types are assignable to a "check".  For
   // example, any category1 primitive is assignable to category1_check and
   // any reference is assignable to reference_check.
   static VerificationType reference_check()
     { return VerificationType(ReferenceQuery); }
-  static VerificationType inlinetype_check()
+  static VerificationType inline_type_check()
     { return VerificationType(InlineTypeQuery); }
   static VerificationType category1_check()
     { return VerificationType(Category1Query); }
   static VerificationType category2_check()
     { return VerificationType(Category2Query); }
@@ -177,11 +177,11 @@
   static VerificationType uninitialized_this_type()
     { return uninitialized_type(BciForThis); }
 
   // For inline types, store the actual Symbol* and set the 3rd bit.
   // Provides a way for an inline type to be distinguished from a reference type.
-  static VerificationType inlinetype_type(Symbol* sh) {
+  static VerificationType inline_type(Symbol* sh) {
       assert(((uintptr_t)sh & TypeMask) == 0, "Symbols must be aligned");
       assert((uintptr_t)sh != 0, "Null is not a valid inline type");
       // If the above assert fails in the future because oop* isn't aligned,
       // then this type encoding system will have to change to have a tag value
       // to discriminate between oops and primitives.
@@ -201,12 +201,12 @@
   bool is_long() const      { return (_u._data == Long); }
   bool is_float() const     { return (_u._data == Float); }
   bool is_double() const    { return (_u._data == Double); }
   bool is_long2() const     { return (_u._data == Long_2nd); }
   bool is_double2() const   { return (_u._data == Double_2nd); }
-  bool is_reference() const { return (((_u._data & TypeMask) == Reference) && !is_inlinetype_check()); }
-  bool is_inlinetype() const { return ((_u._data & TypeMask) == InlineType); }
+  bool is_reference() const { return (((_u._data & TypeMask) == Reference) && !is_inline_type_check()); }
+  bool is_inline_type() const { return ((_u._data & TypeMask) == InlineType); }
   bool is_category1() const {
     // This should return true for all one-word types, which are category1
     // primitives, references (including uninitialized refs) and inline types.
     // Though the 'query' types should technically return 'false' here, if we
     // allow this to return true, we can perform the test using only
@@ -220,11 +220,11 @@
   bool is_category2() const { return ((_u._data & Category2) == Category2); }
   bool is_category2_2nd() const {
     return ((_u._data & Category2_2nd) == Category2_2nd);
   }
   bool is_reference_check() const { return _u._data == ReferenceQuery; }
-  bool is_inlinetype_check() const { return _u._data == InlineTypeQuery; }
+  bool is_inline_type_check() const { return _u._data == InlineTypeQuery; }
   bool is_nonscalar_check() const { return _u._data == NonScalarQuery; }
   bool is_category1_check() const { return _u._data == Category1Query; }
   bool is_category2_check() const { return _u._data == Category2Query; }
   bool is_category2_2nd_check() const { return _u._data == Category2_2ndQuery; }
   bool is_check() const { return (_u._data & TypeQuery) == TypeQuery; }
@@ -240,15 +240,15 @@
   bool is_long_array() const { return is_x_array(JVM_SIGNATURE_LONG); }
   bool is_float_array() const { return is_x_array(JVM_SIGNATURE_FLOAT); }
   bool is_double_array() const { return is_x_array(JVM_SIGNATURE_DOUBLE); }
   bool is_object_array() const { return is_x_array(JVM_SIGNATURE_CLASS); }
   bool is_array_array() const { return is_x_array(JVM_SIGNATURE_ARRAY); }
-  bool is_inline_array() const { return is_x_array(JVM_SIGNATURE_INLINE_TYPE); }
+  bool is_inline_type_array() const { return is_x_array(JVM_SIGNATURE_INLINE_TYPE); }
   bool is_reference_array() const
     { return is_object_array() || is_array_array(); }
   bool is_nonscalar_array() const
-    { return is_object_array() || is_array_array() || is_inline_array(); }
+    { return is_object_array() || is_array_array() || is_inline_type_array(); }
   bool is_object() const
     { return (is_reference() && !is_null() && name()->utf8_length() >= 1 &&
               name()->char_at(0) != JVM_SIGNATURE_ARRAY); }
   bool is_array() const
     { return (is_reference() && !is_null() && name()->utf8_length() >= 2 &&
@@ -261,30 +261,30 @@
   VerificationType to_category2_2nd() const {
     assert(is_category2(), "Must be a double word");
     return VerificationType(is_long() ? Long_2nd : Double_2nd);
   }
 
-  static VerificationType change_ref_to_inlinetype(VerificationType ref) {
+  static VerificationType change_ref_to_inline_type(VerificationType ref) {
     assert(ref.is_reference(), "Bad arg");
     assert(!ref.is_null(), "Unexpected NULL");
-    return inlinetype_type(ref.name());
+    return inline_type(ref.name());
   }
 
   u2 bci() const {
     assert(is_uninitialized(), "Must be uninitialized type");
     return ((_u._data & BciMask) >> 1 * BitsPerByte);
   }
 
   Symbol* name() const {
-    assert(!is_null() && (is_reference() || is_inlinetype()), "Must be a non-null reference or an inline type");
+    assert(!is_null() && (is_reference() || is_inline_type()), "Must be a non-null reference or an inline type");
     return (is_reference() ? _u._sym : ((Symbol*)(_u._data & ~(uintptr_t)InlineType)));
   }
 
   bool equals(const VerificationType& t) const {
     return (_u._data == t._u._data ||
             (((is_reference() && t.is_reference()) ||
-             (is_inlinetype() && t.is_inlinetype())) &&
+             (is_inline_type() && t.is_inline_type())) &&
               !is_null() && !t.is_null() && name() == t.name()));
 
   }
 
   bool operator ==(const VerificationType& t) const {
@@ -313,23 +313,23 @@
           return from.is_category2_2nd();
         case ReferenceQuery:
           return from.is_reference() || from.is_uninitialized();
         case NonScalarQuery:
           return from.is_reference() || from.is_uninitialized() ||
-                 from.is_inlinetype();
+                 from.is_inline_type();
         case InlineTypeQuery:
-          return from.is_inlinetype();
+          return from.is_inline_type();
         case Boolean:
         case Byte:
         case Char:
         case Short:
           // An int can be assigned to boolean, byte, char or short values.
           return from.is_integer();
         default:
-          if (is_inlinetype()) {
-            return is_inlinetype_assignable_from(from);
-          } else if (is_reference() && from.is_inlinetype()) {
+          if (is_inline_type()) {
+            return is_inline_type_assignable_from(from);
+          } else if (is_reference() && from.is_inline_type()) {
             return is_ref_assignable_from_inline_type(from, context, THREAD);
           } else if (is_reference() && from.is_reference()) {
             return is_reference_assignable_from(from, context,
                                                 from_field_is_protected,
                                                 THREAD);
@@ -375,11 +375,11 @@
 
   bool is_reference_assignable_from(
     const VerificationType&, ClassVerifier*, bool from_field_is_protected,
     TRAPS) const;
 
-  bool is_inlinetype_assignable_from(const VerificationType& from) const;
+  bool is_inline_type_assignable_from(const VerificationType& from) const;
 
   bool is_ref_assignable_from_inline_type(const VerificationType& from, ClassVerifier* context, TRAPS) const;
 
 
  public:
diff a/src/hotspot/share/classfile/verifier.cpp b/src/hotspot/share/classfile/verifier.cpp
--- a/src/hotspot/share/classfile/verifier.cpp
+++ b/src/hotspot/share/classfile/verifier.cpp
@@ -586,23 +586,23 @@
   }
 }
 
 // Methods in ClassVerifier
 
-VerificationType reference_or_inlinetype(InstanceKlass* klass) {
-  if (klass->is_value()) {
-    return VerificationType::inlinetype_type(klass->name());
+VerificationType reference_or_inline_type(InstanceKlass* klass) {
+  if (klass->is_inline_klass()) {
+    return VerificationType::inline_type(klass->name());
   } else {
     return VerificationType::reference_type(klass->name());
   }
 }
 
 ClassVerifier::ClassVerifier(
     InstanceKlass* klass, TRAPS)
     : _thread(THREAD), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),
       _message(NULL), _method_signatures_table(NULL), _klass(klass) {
-  _this_type = reference_or_inlinetype(klass);
+  _this_type = reference_or_inline_type(klass);
 }
 
 ClassVerifier::~ClassVerifier() {
   // Decrement the reference count for any symbols created.
   if (_symbols != NULL) {
@@ -1759,11 +1759,11 @@
                 TypeOrigin::cp(index, ref_type)),
                 "Illegal defaultvalue instruction");
             return;
           }
           VerificationType inline_type =
-            VerificationType::change_ref_to_inlinetype(ref_type);
+            VerificationType::change_ref_to_inline_type(ref_type);
           current_frame.push_stack(inline_type, CHECK_VERIFY(this));
           no_control_flow = false; break;
         }
         case Bytecodes::_newarray :
           type = get_newarray_type(bcs.get_index(), bci, CHECK_VERIFY(this));
@@ -2400,13 +2400,13 @@
       for (int i = n - 1; i >= 0; i--) {
         current_frame->pop_stack(field_type[i], CHECK_VERIFY(this));
       }
       // stack_object_type and target_class_type must be the same inline type.
       stack_object_type =
-        current_frame->pop_stack(VerificationType::inlinetype_check(), CHECK_VERIFY(this));
+        current_frame->pop_stack(VerificationType::inline_type_check(), CHECK_VERIFY(this));
       VerificationType target_inline_type =
-        VerificationType::change_ref_to_inlinetype(target_class_type);
+        VerificationType::change_ref_to_inline_type(target_class_type);
       if (!stack_object_type.equals(target_inline_type)) {
         verify_error(ErrorContext::bad_inline_type(bci,
             current_frame->stack_top_ctx(),
             TypeOrigin::cp(index, target_class_type)),
             "Invalid type on operand stack in withfield instruction");
@@ -2939,11 +2939,11 @@
     if (!current_class()->is_unsafe_anonymous()) {
       subtype = ref_class_type.is_assignable_from(
                  current_type(), this, false, CHECK_VERIFY(this));
     } else {
       InstanceKlass* unsafe_host = current_class()->unsafe_anonymous_host();
-      VerificationType unsafe_anonymous_host_type = reference_or_inlinetype(unsafe_host);
+      VerificationType unsafe_anonymous_host_type = reference_or_inline_type(unsafe_host);
       subtype = ref_class_type.is_assignable_from(unsafe_anonymous_host_type, this, false, CHECK_VERIFY(this));
 
       // If invokespecial of IMR, need to recheck for same or
       // direct interface relative to the host class
       have_imr_indirect = (have_imr_indirect &&
@@ -2993,11 +2993,11 @@
           // objectref is a subtype of the unsafe_anonymous_host of the current class
           // to allow an anonymous class to reference methods in the unsafe_anonymous_host
           VerificationType top = current_frame->pop_stack(CHECK_VERIFY(this));
 
           InstanceKlass* unsafe_host = current_class()->unsafe_anonymous_host();
-          VerificationType host_type = reference_or_inlinetype(unsafe_host);
+          VerificationType host_type = reference_or_inline_type(unsafe_host);
           bool subtype = host_type.is_assignable_from(top, this, false, CHECK_VERIFY(this));
           if (!subtype) {
             verify_error( ErrorContext::bad_type(current_frame->offset(),
               current_frame->stack_top_ctx(),
               TypeOrigin::implicit(top)),
@@ -3117,11 +3117,11 @@
     int n = os::snprintf(arr_sig_str, length + 1, "%c%s",
                          JVM_SIGNATURE_ARRAY, component_name);
     assert(n == length, "Unexpected number of characters in string");
   } else {         // it's an object or interface
     const char* component_name = component_type.name()->as_utf8();
-    char Q_or_L = component_type.is_inlinetype() ? JVM_SIGNATURE_INLINE_TYPE : JVM_SIGNATURE_CLASS;
+    char Q_or_L = component_type.is_inline_type() ? JVM_SIGNATURE_INLINE_TYPE : JVM_SIGNATURE_CLASS;
     // add one dimension to component with 'L' or 'Q' prepended and ';' appended.
     length = (int)strlen(component_name) + 3;
     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
     int n = os::snprintf(arr_sig_str, length + 1, "%c%c%s;",
                          JVM_SIGNATURE_ARRAY, Q_or_L, component_name);
diff a/src/hotspot/share/classfile/verifier.hpp b/src/hotspot/share/classfile/verifier.hpp
--- a/src/hotspot/share/classfile/verifier.hpp
+++ b/src/hotspot/share/classfile/verifier.hpp
@@ -456,11 +456,11 @@
     Symbol* name = cp->klass_name_at(index);
     if (name->is_Q_signature()) {
       // Remove the Q and ;
       // TBD need error msg if fundamental_name() returns NULL?
       Symbol* fund_name = name->fundamental_name(CHECK_(VerificationType::bogus_type()));
-      return VerificationType::inlinetype_type(fund_name);
+      return VerificationType::inline_type(fund_name);
     }
     return VerificationType::reference_type(name);
   }
 
   // Keep a list of temporary symbols created during verification because
@@ -505,11 +505,11 @@
       {
         Symbol* vname = sig_type->as_symbol();
         // Create another symbol to save as signature stream unreferences this symbol.
         Symbol* vname_copy = create_temporary_symbol(vname);
         assert(vname_copy == vname, "symbols don't match");
-        *inference_type = VerificationType::inlinetype_type(vname_copy);
+        *inference_type = VerificationType::inline_type(vname_copy);
         return 1;
       }
     case T_LONG:
       *inference_type = VerificationType::long_type();
       *++inference_type = VerificationType::long2_type();
diff a/src/hotspot/share/interpreter/interpreterRuntime.cpp b/src/hotspot/share/interpreter/interpreterRuntime.cpp
--- a/src/hotspot/share/interpreter/interpreterRuntime.cpp
+++ b/src/hotspot/share/interpreter/interpreterRuntime.cpp
@@ -232,11 +232,11 @@
 
 JRT_ENTRY(void, InterpreterRuntime::_new(JavaThread* thread, ConstantPool* pool, int index))
   Klass* k = pool->klass_at(index, CHECK);
   InstanceKlass* klass = InstanceKlass::cast(k);
 
-  if (klass->is_value()) {
+  if (klass->is_inline_klass()) {
     THROW(vmSymbols::java_lang_InstantiationError());
   }
 
   // Make sure we are not instantiating an abstract klass
   klass->check_valid_for_instantiation(true, CHECK);
@@ -299,16 +299,16 @@
 }
 
 JRT_ENTRY(void, InterpreterRuntime::defaultvalue(JavaThread* thread, ConstantPool* pool, int index))
   // Getting the ValueKlass
   Klass* k = pool->klass_at(index, CHECK);
-  if (!k->is_value()) {
+  if (!k->is_inline_klass()) {
     // inconsistency with 'new' which throws an InstantiationError
     // in the future, defaultvalue will just return null instead of throwing an exception
     THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
   }
-  assert(k->is_value(), "defaultvalue argument must be the value type class");
+  assert(k->is_inline_klass(), "defaultvalue argument must be the inline type class");
   ValueKlass* vklass = ValueKlass::cast(k);
 
   vklass->initialize(THREAD);
   oop res = vklass->default_value();
   thread->set_vm_result(res);
@@ -319,11 +319,11 @@
   // Getting the ValueKlass
   int index = ConstantPool::decode_cpcache_index(last_frame.get_index_u2_cpcache(Bytecodes::_withfield));
   ConstantPoolCacheEntry* cp_entry = cp_cache->entry_at(index);
   assert(cp_entry->is_resolved(Bytecodes::_withfield), "Should have been resolved");
   Klass* klass = cp_entry->f1_as_klass();
-  assert(klass->is_value(), "withfield only applies to value types");
+  assert(klass->is_inline_klass(), "withfield only applies to inline types");
   ValueKlass* vklass = ValueKlass::cast(klass);
 
   // Getting Field information
   int offset = cp_entry->f2_as_index();
   int field_index = cp_entry->field_index();
@@ -335,11 +335,11 @@
   // Getting old value
   frame& f = last_frame.get_frame();
   jint tos_idx = f.interpreter_frame_expression_stack_size() - 1;
   int vt_offset = type2size[field_type];
   oop old_value = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx - vt_offset);
-  assert(old_value != NULL && oopDesc::is_oop(old_value) && old_value->is_value(),"Verifying receiver");
+  assert(old_value != NULL && oopDesc::is_oop(old_value) && old_value->is_inline_type(),"Verifying receiver");
   Handle old_value_h(THREAD, old_value);
 
   // Creating new value by copying the one passed in argument
   instanceOop new_value = vklass->allocate_instance(
       CHECK_((type2size[field_type]) * AbstractInterpreter::stackElementSize));
@@ -352,11 +352,11 @@
     assert(aoop == NULL || oopDesc::is_oop(aoop),"argument must be a reference type");
     new_value_h()->obj_field_put(field_offset, aoop);
   } else if (field_type == T_VALUETYPE) {
     if (cp_entry->is_inlined()) {
       oop vt_oop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
-      assert(vt_oop != NULL && oopDesc::is_oop(vt_oop) && vt_oop->is_value(),"argument must be a value type");
+      assert(vt_oop != NULL && oopDesc::is_oop(vt_oop) && vt_oop->is_inline_type(),"argument must be an inline type");
       ValueKlass* field_vk = ValueKlass::cast(vklass->get_value_field_klass(field_index));
       assert(vt_oop != NULL && field_vk == vt_oop->klass(), "Must match");
       field_vk->write_inlined_field(new_value_h(), offset, vt_oop, CHECK_(return_offset));
     } else { // not inlined
       oop voop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
@@ -924,11 +924,11 @@
   constantPoolHandle pool(thread, last_frame.method()->constants());
   methodHandle m(thread, last_frame.method());
   bool is_put    = (bytecode == Bytecodes::_putfield  || bytecode == Bytecodes::_nofast_putfield ||
                     bytecode == Bytecodes::_putstatic || bytecode == Bytecodes::_withfield);
   bool is_static = (bytecode == Bytecodes::_getstatic || bytecode == Bytecodes::_putstatic);
-  bool is_value  = bytecode == Bytecodes::_withfield;
+  bool is_inline_type  = bytecode == Bytecodes::_withfield;
 
   {
     JvmtiHideSingleStepping jhss(thread);
     LinkResolver::resolve_field_access(info, pool, last_frame.get_index_u2_cpcache(bytecode),
                                        m, bytecode, CHECK);
@@ -973,11 +973,11 @@
     if (is_static) {
       get_code = Bytecodes::_getstatic;
     } else {
       get_code = Bytecodes::_getfield;
     }
-    if (is_put && is_value) {
+    if (is_put && is_inline_type) {
         put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_withfield);
     } else if ((is_put && !has_initialized_final_update) || !info.access_flags().is_final()) {
         put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_putfield);
     }
   }
diff a/src/hotspot/share/interpreter/linkResolver.cpp b/src/hotspot/share/interpreter/linkResolver.cpp
--- a/src/hotspot/share/interpreter/linkResolver.cpp
+++ b/src/hotspot/share/interpreter/linkResolver.cpp
@@ -1017,11 +1017,11 @@
 
       if (sel_klass != current_klass) {
       // If byte code is a withfield check if they are nestmates.
       bool are_nestmates = false;
       if (sel_klass->is_instance_klass() &&
-          InstanceKlass::cast(sel_klass)->is_value() &&
+          InstanceKlass::cast(sel_klass)->is_inline_klass() &&
           current_klass->is_instance_klass()) {
         are_nestmates = InstanceKlass::cast(link_info.current_klass())->has_nestmate_access_to(
                                                         InstanceKlass::cast(sel_klass), THREAD);
       }
       if (!are_nestmates) {
diff a/src/hotspot/share/memory/heapInspection.cpp b/src/hotspot/share/memory/heapInspection.cpp
--- a/src/hotspot/share/memory/heapInspection.cpp
+++ b/src/hotspot/share/memory/heapInspection.cpp
@@ -547,11 +547,11 @@
       is_inline_type ? " // inline type " : "",
       inlined_msg);
 }
 
 static void print_inlined_field(outputStream* st, int level, int offset, InstanceKlass* klass) {
-  assert(klass->is_value(), "Only inline types can be inlined");
+  assert(klass->is_inline_klass(), "Only inline types can be inlined");
   ValueKlass* vklass = ValueKlass::cast(klass);
   GrowableArray<FieldDesc>* fields = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<FieldDesc>(100, true);
   for (FieldStream fd(klass, false, false); !fd.eos(); fd.next()) {
     if (!fd.access_flags().is_static()) {
       fields->append(FieldDesc(fd.field_descriptor()));
diff a/src/hotspot/share/memory/metaspaceShared.cpp b/src/hotspot/share/memory/metaspaceShared.cpp
--- a/src/hotspot/share/memory/metaspaceShared.cpp
+++ b/src/hotspot/share/memory/metaspaceShared.cpp
@@ -956,11 +956,11 @@
     break;
   case MetaspaceObj::ClassType:
     {
       Klass* k = (Klass*)obj;
       assert(k->is_klass(), "must be");
-      if (k->is_value()) {
+      if (k->is_inline_klass()) {
         kind = ValueKlass_Kind;
       } else if (k->is_instance_klass()) {
         InstanceKlass* ik = InstanceKlass::cast(k);
         if (ik->is_class_loader_instance_klass()) {
           kind = InstanceClassLoaderKlass_Kind;
diff a/src/hotspot/share/memory/oopFactory.cpp b/src/hotspot/share/memory/oopFactory.cpp
--- a/src/hotspot/share/memory/oopFactory.cpp
+++ b/src/hotspot/share/memory/oopFactory.cpp
@@ -128,11 +128,11 @@
     return InstanceKlass::cast(klass)->allocate_objArray(1, length, THREAD);
   }
 }
 
 arrayOop oopFactory::new_valueArray(Klass* klass, int length, TRAPS) {
-  assert(klass->is_value(), "Klass must be value type");
+  assert(klass->is_inline_klass(), "Klass must be inline type");
   // Request flattened, but we might not actually get it...either way "null-free" are the aaload/aastore semantics
   Klass* array_klass = klass->array_klass(1, CHECK_NULL);
   assert(array_klass->is_null_free_array_klass(), "Expect a null-free array class here");
 
   arrayOop oop;
diff a/src/hotspot/share/oops/arrayKlass.cpp b/src/hotspot/share/oops/arrayKlass.cpp
--- a/src/hotspot/share/oops/arrayKlass.cpp
+++ b/src/hotspot/share/oops/arrayKlass.cpp
@@ -100,11 +100,11 @@
 }
 
 Symbol* ArrayKlass::create_element_klass_array_name(Klass* element_klass, TRAPS) {
   ResourceMark rm(THREAD);
   Symbol* name = NULL;
-  bool is_qtype = element_klass->is_value();
+  bool is_qtype = element_klass->is_inline_klass();
   char *name_str = element_klass->name()->as_C_string();
   int len = element_klass->name()->utf8_length();
   char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);
   int idx = 0;
   new_str[idx++] = JVM_SIGNATURE_ARRAY;
diff a/src/hotspot/share/oops/constantPool.cpp b/src/hotspot/share/oops/constantPool.cpp
--- a/src/hotspot/share/oops/constantPool.cpp
+++ b/src/hotspot/share/oops/constantPool.cpp
@@ -478,11 +478,11 @@
     }
   }
 }
 
 void check_is_inline_type(Klass* k, TRAPS) {
-  if (!k->is_value()) {
+  if (!k->is_inline_klass()) {
     THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
   }
 }
 
 Klass* ConstantPool::klass_at_impl(const constantPoolHandle& this_cp, int which,
diff a/src/hotspot/share/oops/generateOopMap.cpp b/src/hotspot/share/oops/generateOopMap.cpp
--- a/src/hotspot/share/oops/generateOopMap.cpp
+++ b/src/hotspot/share/oops/generateOopMap.cpp
@@ -834,11 +834,11 @@
 void GenerateOopMap::merge_state(GenerateOopMap *gom, int bci, int* data) {
    gom->merge_state_into_bb(gom->get_basic_block_at(bci));
 }
 
 void GenerateOopMap::set_var(int localNo, CellTypeState cts) {
-  assert(cts.is_reference() || cts.is_value() || cts.is_address(),
+  assert(cts.is_reference() || cts.is_inline_type() || cts.is_address(),
          "wrong celltypestate");
   if (localNo < 0 || localNo > _max_locals) {
     verify_error("variable write error: r%d", localNo);
     return;
   }
@@ -1727,11 +1727,11 @@
     ppop1(*out++);
   }
 }
 
 void GenerateOopMap::ppush1(CellTypeState in) {
-  assert(in.is_reference() || in.is_value(), "sanity check");
+  assert(in.is_reference() || in.is_inline_type(), "sanity check");
   push(in);
 }
 
 void GenerateOopMap::ppush(CellTypeState *in) {
   while (!(*in).is_bottom()) {
diff a/src/hotspot/share/oops/generateOopMap.hpp b/src/hotspot/share/oops/generateOopMap.hpp
--- a/src/hotspot/share/oops/generateOopMap.hpp
+++ b/src/hotspot/share/oops/generateOopMap.hpp
@@ -199,11 +199,11 @@
     return true;
   }
 
   bool is_address() const               { return ((_state & bits_mask) == addr_bit); }
   bool is_reference() const             { return ((_state & bits_mask) == ref_bit); }
-  bool is_value() const                 { return ((_state & bits_mask) == val_bit); }
+  bool is_inline_type() const           { return ((_state & bits_mask) == val_bit); }
   bool is_uninit() const                { return ((_state & bits_mask) == (uint)uninit_bit); }
 
   bool can_be_address() const           { return ((_state & addr_bit) != 0); }
   bool can_be_reference() const         { return ((_state & ref_bit) != 0); }
   bool can_be_value() const             { return ((_state & val_bit) != 0); }
diff a/src/hotspot/share/oops/instanceKlass.cpp b/src/hotspot/share/oops/instanceKlass.cpp
--- a/src/hotspot/share/oops/instanceKlass.cpp
+++ b/src/hotspot/share/oops/instanceKlass.cpp
@@ -1015,11 +1015,11 @@
                                                              Handle(THREAD, loader), Handle(THREAD, protection_domain), true,
                                                              CHECK_false);
             if (klass == NULL) {
               THROW_(vmSymbols::java_lang_LinkageError(), false);
             }
-            if (!klass->is_value()) {
+            if (!klass->is_inline_klass()) {
               Exceptions::fthrow(
                 THREAD_AND_LOCATION,
                 vmSymbols::java_lang_IncompatibleClassChangeError(),
                 "class %s is not an inline type",
                 klass->external_name());
@@ -1268,11 +1268,11 @@
               Handle(THREAD, protection_domain()),
               true, CHECK);
           if (klass == NULL) {
             THROW(vmSymbols::java_lang_NoClassDefFoundError());
           }
-          if (!klass->is_value()) {
+          if (!klass->is_inline_klass()) {
             THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
           }
           this->set_value_field_klass(fs.index(), klass);
         }
         InstanceKlass::cast(klass)->initialize(CHECK);
@@ -1718,11 +1718,11 @@
   // 4) otherwise field lookup fails
   return NULL;
 }
 
 bool InstanceKlass::contains_field_offset(int offset) {
-  if (this->is_value()) {
+  if (this->is_inline_klass()) {
     ValueKlass* vk = ValueKlass::cast(this);
     return offset >= vk->first_field_offset() && offset < (vk->first_field_offset() + vk->get_exact_size_in_bytes());
   } else {
     fieldDescriptor fd;
     return find_field_from_offset(offset, false, &fd);
@@ -2695,11 +2695,11 @@
   // sure the current state is <loaded.
   assert(!is_loaded(), "invalid init state");
   set_package(loader_data, pkg_entry, CHECK);
   Klass::restore_unshareable_info(loader_data, protection_domain, CHECK);
 
-  if (is_value()) {
+  if (is_inline_klass()) {
     ValueKlass::cast(this)->initialize_calling_convention(CHECK);
   }
 
   Array<Method*>* methods = this->methods();
   int num_methods = methods->length();
@@ -2724,11 +2724,11 @@
     // --> see ArrayKlass::complete_create_array_klass()
     array_klasses()->restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);
   }
 
   // Initialize current biased locking state.
-  if (UseBiasedLocking && BiasedLocking::enabled() && !is_value()) {
+  if (UseBiasedLocking && BiasedLocking::enabled() && !is_inline_klass()) {
     set_prototype_header(markWord::biased_locking_prototype());
   }
 }
 
 void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
@@ -2891,11 +2891,11 @@
 
   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
 
   // Add L or Q as type indicator
   int dest_index = 0;
-  dest[dest_index++] = is_value() ? JVM_SIGNATURE_INLINE_TYPE : JVM_SIGNATURE_CLASS;
+  dest[dest_index++] = is_inline_klass() ? JVM_SIGNATURE_INLINE_TYPE : JVM_SIGNATURE_CLASS;
 
   // Add the actual class name
   for (int src_index = 0; src_index < src_length; ) {
     dest[dest_index++] = src[src_index++];
   }
diff a/src/hotspot/share/oops/instanceKlass.hpp b/src/hotspot/share/oops/instanceKlass.hpp
--- a/src/hotspot/share/oops/instanceKlass.hpp
+++ b/src/hotspot/share/oops/instanceKlass.hpp
@@ -1216,11 +1216,11 @@
                                                nonstatic_oop_map_size(),
                                                is_interface(),
                                                is_unsafe_anonymous(),
                                                has_stored_fingerprint(),
                                                has_inline_fields() ? java_fields_count() : 0,
-                                               is_value());
+                                               is_inline_klass());
   }
 
   intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }
   intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }
 
@@ -1303,18 +1303,18 @@
 
   Klass* get_value_field_klass(int idx) const {
     assert(has_inline_fields(), "Sanity checking");
     Klass* k = ((Klass**)adr_value_fields_klasses())[idx];
     assert(k != NULL, "Should always be set before being read");
-    assert(k->is_value(), "Must be a inline type");
+    assert(k->is_inline_klass(), "Must be a inline type");
     return k;
   }
 
   Klass* get_value_field_klass_or_null(int idx) const {
     assert(has_inline_fields(), "Sanity checking");
     Klass* k = ((Klass**)adr_value_fields_klasses())[idx];
-    assert(k == NULL || k->is_value(), "Must be a inline type");
+    assert(k == NULL || k->is_inline_klass(), "Must be a inline type");
     return k;
   }
 
   void set_value_field_klass(int idx, Klass* k) {
     assert(has_inline_fields(), "Sanity checking");
diff a/src/hotspot/share/oops/klass.hpp b/src/hotspot/share/oops/klass.hpp
--- a/src/hotspot/share/oops/klass.hpp
+++ b/src/hotspot/share/oops/klass.hpp
@@ -603,11 +603,11 @@
   virtual bool is_objArray_klass_slow()     const { return false; }
   virtual bool is_typeArray_klass_slow()    const { return false; }
   virtual bool is_valueArray_klass_slow()   const { return false; }
 #endif // ASSERT
   // current implementation uses this method even in non debug builds
-  virtual bool is_value_slow()          const { return false; }
+  virtual bool is_inline_klass_slow()       const { return false; }
  public:
 
   // Fast non-virtual versions
   #ifndef ASSERT
   #define assert_same_query(xval, xcheck) xval
@@ -629,11 +629,11 @@
                                                     layout_helper_is_objArray(layout_helper()),
                                                     is_objArray_klass_slow()); }
   inline  bool is_typeArray_klass()           const { return assert_same_query(
                                                     layout_helper_is_typeArray(layout_helper()),
                                                     is_typeArray_klass_slow()); }
-  inline  bool is_value()                     const { return is_value_slow(); } //temporary hack
+  inline  bool is_inline_klass()              const { return is_inline_klass_slow(); } //temporary hack
   inline  bool is_valueArray_klass()          const { return assert_same_query(
                                                     layout_helper_is_valueArray(layout_helper()),
                                                     is_valueArray_klass_slow()); }
 
   #undef assert_same_query
diff a/src/hotspot/share/oops/klass.inline.hpp b/src/hotspot/share/oops/klass.inline.hpp
--- a/src/hotspot/share/oops/klass.inline.hpp
+++ b/src/hotspot/share/oops/klass.inline.hpp
@@ -30,11 +30,11 @@
 #include "oops/klass.hpp"
 #include "oops/markWord.hpp"
 #include "oops/oopHandle.inline.hpp"
 
 inline void Klass::set_prototype_header(markWord header) {
-  assert(!is_value() || header.is_always_locked(), "Unexpected prototype");
+  assert(!is_inline_klass() || header.is_always_locked(), "Unexpected prototype");
   assert(!header.has_bias_pattern() || is_instance_klass(), "biased locking currently only supported for Java instances");
   _prototype_header = header;
 }
 
 inline oop Klass::java_mirror() const {
diff a/src/hotspot/share/oops/objArrayKlass.cpp b/src/hotspot/share/oops/objArrayKlass.cpp
--- a/src/hotspot/share/oops/objArrayKlass.cpp
+++ b/src/hotspot/share/oops/objArrayKlass.cpp
@@ -134,11 +134,11 @@
   assert(bk != NULL && (bk->is_instance_klass() || bk->is_typeArray_klass()), "invalid bottom klass");
   set_bottom_klass(bk);
   set_class_loader_data(bk->class_loader_data());
 
   jint lh = array_layout_helper(T_OBJECT);
-  if (element_klass->is_value()) {
+  if (element_klass->is_inline_klass()) {
     lh = layout_helper_set_null_free(lh);
   }
   set_layout_helper(lh);
   assert(is_array_klass(), "sanity");
   assert(is_objArray_klass(), "sanity");
@@ -155,11 +155,11 @@
   bool populate_null_free = is_null_free_array_klass();
   objArrayOop array =  (objArrayOop)Universe::heap()->array_allocate(this, size, length,
                                                        /* do_zero */ true, THREAD);
   if (populate_null_free) {
     assert(dimension() == 1, "Can only populate the final dimension");
-    assert(element_klass()->is_value(), "Unexpected");
+    assert(element_klass()->is_inline_klass(), "Unexpected");
     assert(!element_klass()->is_array_klass(), "ArrayKlass unexpected here");
     assert(!ValueKlass::cast(element_klass())->flatten_array(), "Expected valueArrayOop allocation");
     element_klass()->initialize(CHECK_NULL);
     // Populate default values...
     objArrayHandle array_h(THREAD, array);
@@ -172,11 +172,11 @@
 }
 
 oop ObjArrayKlass::multi_allocate(int rank, jint* sizes, TRAPS) {
   int length = *sizes;
   if (rank == 1) { // last dim may be valueArray, check if we have any special storage requirements
-    if (element_klass()->is_value()) {
+    if (element_klass()->is_inline_klass()) {
       return oopFactory::new_valueArray(element_klass(), length, CHECK_NULL);
     } else {
       return oopFactory::new_objArray(element_klass(), length, CHECK_NULL);
     }
   }
diff a/src/hotspot/share/oops/oop.cpp b/src/hotspot/share/oops/oop.cpp
--- a/src/hotspot/share/oops/oop.cpp
+++ b/src/hotspot/share/oops/oop.cpp
@@ -135,11 +135,11 @@
 // type test operations that doesn't require inclusion of oop.inline.hpp.
 bool oopDesc::is_instance_noinline()          const { return is_instance();            }
 bool oopDesc::is_array_noinline()             const { return is_array();               }
 bool oopDesc::is_objArray_noinline()          const { return is_objArray();            }
 bool oopDesc::is_typeArray_noinline()         const { return is_typeArray();           }
-bool oopDesc::is_value_noinline()             const { return is_value();               }
+bool oopDesc::is_value_noinline()             const { return is_inline_type();         }
 bool oopDesc::is_valueArray_noinline()        const { return is_valueArray();          }
 
 bool oopDesc::has_klass_gap() {
   // Only has a klass gap when compressed class pointers are used.
   return UseCompressedClassPointers;
diff a/src/hotspot/share/oops/oop.hpp b/src/hotspot/share/oops/oop.hpp
--- a/src/hotspot/share/oops/oop.hpp
+++ b/src/hotspot/share/oops/oop.hpp
@@ -119,11 +119,11 @@
   // type test operations (inlined in oop.inline.hpp)
   inline bool is_instance()            const;
   inline bool is_array()               const;
   inline bool is_objArray()            const;
   inline bool is_typeArray()           const;
-  inline bool is_value()               const;
+  inline bool is_inline_type()         const;
   inline bool is_valueArray()          const;
 
   // type test operations that don't require inclusion of oop.inline.hpp.
   bool is_instance_noinline()          const;
   bool is_array_noinline()             const;
diff a/src/hotspot/share/oops/oop.inline.hpp b/src/hotspot/share/oops/oop.inline.hpp
--- a/src/hotspot/share/oops/oop.inline.hpp
+++ b/src/hotspot/share/oops/oop.inline.hpp
@@ -245,11 +245,11 @@
 
 bool oopDesc::is_instance()  const { return klass()->is_instance_klass();  }
 bool oopDesc::is_array()     const { return klass()->is_array_klass();     }
 bool oopDesc::is_objArray()  const { return klass()->is_objArray_klass();  }
 bool oopDesc::is_typeArray() const { return klass()->is_typeArray_klass(); }
-bool oopDesc::is_value()     const { return klass()->is_value(); }
+bool oopDesc::is_inline_type() const { return klass()->is_inline_klass(); }
 bool oopDesc::is_valueArray()  const { return klass()->is_valueArray_klass(); }
 
 void*    oopDesc::field_addr_raw(int offset)     const { return reinterpret_cast<void*>(cast_from_oop<intptr_t>(as_oop()) + offset); }
 void*    oopDesc::field_addr(int offset)         const { return Access<>::resolve(as_oop())->field_addr_raw(offset); }
 
diff a/src/hotspot/share/oops/valueArrayKlass.cpp b/src/hotspot/share/oops/valueArrayKlass.cpp
--- a/src/hotspot/share/oops/valueArrayKlass.cpp
+++ b/src/hotspot/share/oops/valueArrayKlass.cpp
@@ -54,11 +54,11 @@
 #include "oops/valueArrayKlass.hpp"
 
 // Allocation...
 
 ValueArrayKlass::ValueArrayKlass(Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {
-  assert(element_klass->is_value(), "Expected Value");
+  assert(element_klass->is_inline_klass(), "Expected Inline");
 
   set_element_klass(ValueKlass::cast(element_klass));
   set_class_loader_data(element_klass->class_loader_data());
   set_layout_helper(array_layout_helper(ValueKlass::cast(element_klass)));
 
@@ -495,7 +495,7 @@
   }
 }
 
 void ValueArrayKlass::verify_on(outputStream* st) {
   ArrayKlass::verify_on(st);
-  guarantee(element_klass()->is_value(), "should be value type klass");
+  guarantee(element_klass()->is_inline_klass(), "should be inline type klass");
 }
diff a/src/hotspot/share/oops/valueKlass.cpp b/src/hotspot/share/oops/valueKlass.cpp
--- a/src/hotspot/share/oops/valueKlass.cpp
+++ b/src/hotspot/share/oops/valueKlass.cpp
@@ -65,11 +65,11 @@
 }
 
 oop ValueKlass::default_value() {
   oop val = java_mirror()->obj_field_acquire(default_value_offset());
   assert(oopDesc::is_oop(val), "Sanity check");
-  assert(val->is_value(), "Sanity check");
+  assert(val->is_inline_type(), "Sanity check");
   assert(val->klass() == this, "sanity check");
   return val;
 }
 
 int ValueKlass::first_field_offset_old() {
diff a/src/hotspot/share/oops/valueKlass.hpp b/src/hotspot/share/oops/valueKlass.hpp
--- a/src/hotspot/share/oops/valueKlass.hpp
+++ b/src/hotspot/share/oops/valueKlass.hpp
@@ -179,11 +179,11 @@
   // Specifically flat array klass
   Klass* value_array_klass(bool or_null, int rank, TRAPS);
 
  public:
   // Type testing
-  bool is_value_slow() const        { return true; }
+  bool is_inline_klass_slow() const        { return true; }
 
   // Casting from Klass*
   static ValueKlass* cast(Klass* k);
 
   // Use this to return the size of an instance in heap words
diff a/src/hotspot/share/oops/valueKlass.inline.hpp b/src/hotspot/share/oops/valueKlass.inline.hpp
--- a/src/hotspot/share/oops/valueKlass.inline.hpp
+++ b/src/hotspot/share/oops/valueKlass.inline.hpp
@@ -30,11 +30,11 @@
 #include "oops/oop.inline.hpp"
 #include "oops/valueKlass.hpp"
 #include "utilities/macros.hpp"
 
 inline ValueKlass* ValueKlass::cast(Klass* k) {
-  assert(k->is_value(), "cast to ValueKlass");
+  assert(k->is_inline_klass(), "cast to ValueKlass");
   return (ValueKlass*) k;
 }
 
 inline address ValueKlass::data_for_oop(oop o) const {
   return ((address) (void*) o) + first_field_offset();
diff a/src/hotspot/share/prims/jni.cpp b/src/hotspot/share/prims/jni.cpp
--- a/src/hotspot/share/prims/jni.cpp
+++ b/src/hotspot/share/prims/jni.cpp
@@ -1078,11 +1078,11 @@
   if (k == NULL) {
     ResourceMark rm(THREAD);
     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
   }
 
-  if (!k->is_value()) {
+  if (!k->is_inline_klass()) {
     instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);
     obj = JNIHandles::make_local(env, i);
     JavaValue jvalue(T_VOID);
     JNI_ArgumentPusherArray ap(methodID, args);
     jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);
@@ -1112,11 +1112,11 @@
   if (k == NULL) {
     ResourceMark rm(THREAD);
     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
   }
 
-  if (!k->is_value()) {
+  if (!k->is_inline_klass()) {
     instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);
     obj = JNIHandles::make_local(env, i);
     JavaValue jvalue(T_VOID);
     JNI_ArgumentPusherVaArg ap(methodID, args);
     jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);
@@ -1146,11 +1146,11 @@
   if (k == NULL) {
     ResourceMark rm(THREAD);
     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
   }
 
-  if (!k->is_value()) {
+  if (!k->is_inline_klass()) {
     instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);
     obj = JNIHandles::make_local(env, i);
     va_list args;
     va_start(args, methodID);
     JavaValue jvalue(T_VOID);
@@ -3444,11 +3444,11 @@
 JNI_ENTRY(jsize, jni_GetFieldOffsetInFlattenedLayout(JNIEnv* env, jclass clazz, const char *name, const char *signature, jboolean* is_inlined))
   JNIWrapper("jni_GetFieldOffsetInFlattenedLayout");
 
   oop mirror = JNIHandles::resolve_non_null(clazz);
   Klass* k = java_lang_Class::as_Klass(mirror);
-  if (!k->is_value()) {
+  if (!k->is_inline_klass()) {
     ResourceMark rm;
         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("%s has not flattened layout", k->external_name()));
   }
   ValueKlass* vk = ValueKlass::cast(k);
 
@@ -3511,11 +3511,11 @@
   if (!is_inlined) {
     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "SubElement is not inlined");
   }
   oop semirror = jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct);
   Klass* k = java_lang_Class::as_Klass(semirror);
-  if (!k->is_value()) {
+  if (!k->is_inline_klass()) {
     ResourceMark rm;
         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("%s is not an inline type", k->external_name()));
   }
   ValueKlass* vk = ValueKlass::cast(k);
   assert(vk->is_initialized(), "If a flattened array has been created, the element klass must have been initialized");
diff a/src/hotspot/share/prims/jvm.cpp b/src/hotspot/share/prims/jvm.cpp
--- a/src/hotspot/share/prims/jvm.cpp
+++ b/src/hotspot/share/prims/jvm.cpp
@@ -712,11 +712,11 @@
 
   // Check if class of obj supports the Cloneable interface.
   // All arrays are considered to be cloneable (See JLS 20.1.5).
   // All j.l.r.Reference classes are considered non-cloneable.
   if (!klass->is_cloneable() ||
-       klass->is_value() ||
+       klass->is_inline_klass() ||
       (klass->is_instance_klass() &&
        InstanceKlass::cast(klass)->reference_type() != REF_NONE)) {
     ResourceMark rm(THREAD);
     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass->external_name());
   }
diff a/src/hotspot/share/prims/unsafe.cpp b/src/hotspot/share/prims/unsafe.cpp
--- a/src/hotspot/share/prims/unsafe.cpp
+++ b/src/hotspot/share/prims/unsafe.cpp
@@ -235,11 +235,11 @@
   void put(T x) {
     if (_obj == NULL) {
       GuardUnsafeAccess guard(_thread);
       RawAccess<>::store(addr(), normalize_for_write(x));
     } else {
-      assert(!_obj->is_value() || _obj->mark().is_larval_state(), "must be an object instance or a larval value");
+      assert(!_obj->is_inline_type() || _obj->mark().is_larval_state(), "must be an object instance or a larval inline type");
       HeapAccess<>::store_at(_obj, _offset, normalize_for_write(x));
     }
   }
 
   T get_volatile() {
@@ -337,11 +337,11 @@
 
 UNSAFE_ENTRY(void, Unsafe_PutReference(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject x_h)) {
   oop x = JNIHandles::resolve(x_h);
   oop p = JNIHandles::resolve(obj);
   assert_field_offset_sane(p, offset);
-  assert(!p->is_value() || p->mark().is_larval_state(), "must be an object instance or a larval value");
+  assert(!p->is_inline_type() || p->mark().is_larval_state(), "must be an object instance or a larval inline type");
   HeapAccess<ON_UNKNOWN_OOP_REF>::oop_store_at(p, offset, x);
 } UNSAFE_END
 
 UNSAFE_ENTRY(jlong, Unsafe_ValueHeaderSize(JNIEnv *env, jobject unsafe, jclass c)) {
   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(c));
@@ -373,19 +373,19 @@
 
 UNSAFE_ENTRY(void, Unsafe_PutValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jclass vc, jobject value)) {
   oop base = JNIHandles::resolve(obj);
   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));
   ValueKlass* vk = ValueKlass::cast(k);
-  assert(!base->is_value() || base->mark().is_larval_state(), "must be an object instance or a larval value");
+  assert(!base->is_inline_type() || base->mark().is_larval_state(), "must be an object instance or a larval inline type");
   assert_and_log_unsafe_value_access(base, offset, vk);
   oop v = JNIHandles::resolve(value);
   vk->write_inlined_field(base, offset, v, CHECK);
 } UNSAFE_END
 
 UNSAFE_ENTRY(jobject, Unsafe_MakePrivateBuffer(JNIEnv *env, jobject unsafe, jobject value)) {
   oop v = JNIHandles::resolve_non_null(value);
-  assert(v->is_value(), "must be a value instance");
+  assert(v->is_inline_type(), "must be an inline type instance");
   Handle vh(THREAD, v);
   ValueKlass* vk = ValueKlass::cast(v->klass());
   instanceOop new_value = vk->allocate_instance(CHECK_NULL);
   vk->value_copy_oop_to_new_oop(vh(),  new_value);
   markWord mark = new_value->mark();
diff a/src/hotspot/share/prims/whitebox.cpp b/src/hotspot/share/prims/whitebox.cpp
--- a/src/hotspot/share/prims/whitebox.cpp
+++ b/src/hotspot/share/prims/whitebox.cpp
@@ -1911,11 +1911,11 @@
     return (jobjectArray)JNIHandles::make_local(env, create_results(THREAD));
   }
 
   void add_oop(oop o) {
     // Value might be oop, but JLS can't see as Object, just iterate through it...
-    if (o != NULL && o->is_value()) {
+    if (o != NULL && o->is_inline_type()) {
       o->oop_iterate(this);
     } else {
       array->append(Handle(Thread::current(), o));
     }
   }
diff a/src/hotspot/share/runtime/biasedLocking.cpp b/src/hotspot/share/runtime/biasedLocking.cpp
--- a/src/hotspot/share/runtime/biasedLocking.cpp
+++ b/src/hotspot/share/runtime/biasedLocking.cpp
@@ -49,11 +49,11 @@
 
 static GrowableArray<Handle>*   _preserved_oop_stack  = NULL;
 static GrowableArray<markWord>* _preserved_mark_stack = NULL;
 
 static void enable_biased_locking(InstanceKlass* k) {
-  if (!k->is_value()) {
+  if (!k->is_inline_klass()) {
     k->set_prototype_header(markWord::biased_locking_prototype());
   }
 }
 
 static void enable_biased_locking() {
diff a/src/hotspot/share/runtime/javaCalls.cpp b/src/hotspot/share/runtime/javaCalls.cpp
--- a/src/hotspot/share/runtime/javaCalls.cpp
+++ b/src/hotspot/share/runtime/javaCalls.cpp
@@ -301,20 +301,20 @@
 Handle JavaCalls::construct_new_instance(InstanceKlass* klass, Symbol* constructor_signature, JavaCallArguments* args, TRAPS) {
   klass->initialize(CHECK_NH); // Quick no-op if already initialized.
 
   // Special case for factory methods
   if (!constructor_signature->is_void_method_signature()) {
-    assert(klass->is_value(), "inline classes must use factory methods");
+    assert(klass->is_inline_klass(), "inline classes must use factory methods");
     JavaValue factory_result(T_OBJECT);
     JavaCalls::call_static(&factory_result, klass,
                            vmSymbols::object_initializer_name(),
                            constructor_signature, args, CHECK_NH);
     return Handle(THREAD, (oop)factory_result.get_jobject());
   }
 
   // main branch of code creates a non-inline object:
-  assert(!klass->is_value(), "classic constructors are only for non-inline classes");
+  assert(!klass->is_inline_klass(), "classic constructors are only for non-inline classes");
   Handle obj = klass->allocate_instance_handle(CHECK_NH);
   JavaValue void_result(T_VOID);
   args->set_receiver(obj); // inserts <obj> as the first argument.
   JavaCalls::call_special(&void_result, klass,
                           vmSymbols::object_initializer_name(),
diff a/src/hotspot/share/runtime/reflection.cpp b/src/hotspot/share/runtime/reflection.cpp
--- a/src/hotspot/share/runtime/reflection.cpp
+++ b/src/hotspot/share/runtime/reflection.cpp
@@ -346,11 +346,11 @@
   } else {
     Klass* k = java_lang_Class::as_Klass(element_mirror);
     if (k->is_array_klass() && ArrayKlass::cast(k)->dimension() >= MAX_DIM) {
       THROW_0(vmSymbols::java_lang_IllegalArgumentException());
     }
-    if (k->is_value()) {
+    if (k->is_inline_klass()) {
       return oopFactory::new_valueArray(k, length, THREAD);
     } else {
       return oopFactory::new_objArray(k, length, THREAD);
     }
   }
@@ -1179,11 +1179,11 @@
 
   oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);
   BasicType rtype;
   if (java_lang_Class::is_primitive(return_type_mirror)) {
     rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);
-  } else if (java_lang_Class::as_Klass(return_type_mirror)->is_value()) {
+  } else if (java_lang_Class::as_Klass(return_type_mirror)->is_inline_klass()) {
     rtype = T_VALUETYPE;
   } else {
     rtype = T_OBJECT;
   }
 
@@ -1218,17 +1218,17 @@
   // Create new instance (the receiver)
   klass->check_valid_for_instantiation(false, CHECK_NULL);
 
   // Special case for factory methods
   if (!method->signature()->is_void_method_signature()) {
-    assert(klass->is_value(), "inline classes must use factory methods");
+    assert(klass->is_inline_klass(), "inline classes must use factory methods");
     Handle no_receiver; // null instead of receiver
     return invoke(klass, method, no_receiver, override, ptypes, T_VALUETYPE, args, false, CHECK_NULL);
   }
 
   // main branch of code creates a non-inline object:
-  assert(!klass->is_value(), "classic constructors are only for non-inline classes");
+  assert(!klass->is_inline_klass(), "classic constructors are only for non-inline classes");
   Handle receiver = klass->allocate_instance_handle(CHECK_NULL);
 
   // Ignore result from call and return receiver
   invoke(klass, method, receiver, override, ptypes, T_VOID, args, false, CHECK_NULL);
   return receiver();
diff a/src/hotspot/share/runtime/sharedRuntime.cpp b/src/hotspot/share/runtime/sharedRuntime.cpp
--- a/src/hotspot/share/runtime/sharedRuntime.cpp
+++ b/src/hotspot/share/runtime/sharedRuntime.cpp
@@ -1105,11 +1105,11 @@
         default:
           break;
       }
     } else {
       assert(attached_method->has_scalarized_args(), "invalid use of attached method");
-      if (!attached_method->method_holder()->is_value()) {
+      if (!attached_method->method_holder()->is_inline_klass()) {
         // Ignore the attached method in this case to not confuse below code
         attached_method = methodHandle(thread, NULL);
       }
     }
   }
@@ -1140,11 +1140,11 @@
       callee = bytecode.static_target(CHECK_NH);
       if (callee == NULL) {
         THROW_(vmSymbols::java_lang_NoSuchMethodException(), nullHandle);
       }
     }
-    if (!caller_is_c1 && callee->has_scalarized_args() && callee->method_holder()->is_value()) {
+    if (!caller_is_c1 && callee->has_scalarized_args() && callee->method_holder()->is_inline_klass()) {
       // If the receiver is a value type that is passed as fields, no oop is available.
       // Resolve the call without receiver null checking.
       assert(attached_method.not_null() && !attached_method->is_abstract(), "must have non-abstract attached method");
       if (bc == Bytecodes::_invokeinterface) {
         bc = Bytecodes::_invokevirtual; // C2 optimistically replaces interface calls by virtual calls
@@ -1283,11 +1283,11 @@
   bool is_nmethod = caller_nm->is_nmethod();
   bool caller_is_c1 = caller_nm->is_compiled_by_c1();
 
   if (is_virtual) {
     Klass* receiver_klass = NULL;
-    if (InlineTypePassFieldsAsArgs && !caller_is_c1 && callee_method->method_holder()->is_value()) {
+    if (InlineTypePassFieldsAsArgs && !caller_is_c1 && callee_method->method_holder()->is_inline_klass()) {
       // If the receiver is an inline type that is passed as fields, no oop is available
       receiver_klass = callee_method->method_holder();
     } else {
       assert(receiver.not_null() || invoke_code == Bytecodes::_invokehandle, "sanity check");
       receiver_klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver->klass();
@@ -2744,11 +2744,11 @@
 
 int CompiledEntrySignature::compute_scalarized_cc(GrowableArray<SigEntry>*& sig_cc, VMRegPair*& regs_cc, bool scalar_receiver) {
   InstanceKlass* holder = _method->method_holder();
   sig_cc = new GrowableArray<SigEntry>(_method->size_of_parameters());
   if (!_method->is_static()) {
-    if (holder->is_value() && scalar_receiver && ValueKlass::cast(holder)->is_scalarizable()) {
+    if (holder->is_inline_klass() && scalar_receiver && ValueKlass::cast(holder)->is_scalarizable()) {
       sig_cc->appendAll(ValueKlass::cast(holder)->extended_sig());
     } else {
       SigEntry::add_entry(sig_cc, T_OBJECT);
     }
   }
@@ -2831,11 +2831,11 @@
 
 
 void CompiledEntrySignature::compute_calling_conventions() {
   // Get the (non-scalarized) signature and check for value type arguments
   if (!_method->is_static()) {
-    if (_method->method_holder()->is_value() && ValueKlass::cast(_method->method_holder())->is_scalarizable()) {
+    if (_method->method_holder()->is_inline_klass() && ValueKlass::cast(_method->method_holder())->is_scalarizable()) {
       _has_value_recv = true;
       _num_value_args++;
     }
     SigEntry::add_entry(_sig, T_OBJECT);
   }
@@ -3594,11 +3594,11 @@
   assert(InlineTypePassFieldsAsArgs, "no reason to call this");
   ResourceMark rm;
 
   int nb_slots = 0;
   InstanceKlass* holder = callee->method_holder();
-  allocate_receiver &= !callee->is_static() && holder->is_value();
+  allocate_receiver &= !callee->is_static() && holder->is_inline_klass();
   if (allocate_receiver) {
     nb_slots++;
   }
   for (SignatureStream ss(callee->signature()); !ss.at_return_type(); ss.next()) {
     if (ss.type() == T_VALUETYPE) {
@@ -3659,11 +3659,11 @@
 
 // We're returning from an interpreted method: load each field into a
 // register following the calling convention
 JRT_LEAF(void, SharedRuntime::load_value_type_fields_in_regs(JavaThread* thread, oopDesc* res))
 {
-  assert(res->klass()->is_value(), "only value types here");
+  assert(res->klass()->is_inline_klass(), "only inline types here");
   ResourceMark rm;
   RegisterMap reg_map(thread);
   frame stubFrame = thread->last_frame();
   frame callerFrame = stubFrame.sender(&reg_map);
   assert(callerFrame.is_interpreted_frame(), "should be coming from interpreter");
diff a/src/hotspot/share/runtime/synchronizer.cpp b/src/hotspot/share/runtime/synchronizer.cpp
--- a/src/hotspot/share/runtime/synchronizer.cpp
+++ b/src/hotspot/share/runtime/synchronizer.cpp
@@ -448,11 +448,11 @@
   assert(!SafepointSynchronize::is_at_safepoint(), "invariant");
   assert(self->is_Java_thread(), "invariant");
   assert(((JavaThread *) self)->thread_state() == _thread_in_Java, "invariant");
   NoSafepointVerifier nsv;
   if (obj == NULL) return false;  // slow-path for invalid obj
-  assert(!EnableValhalla || !obj->klass()->is_value(), "monitor op on value type");
+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), "monitor op on inline type");
   const markWord mark = obj->mark();
 
   if (mark.has_locker() && self->is_lock_owned((address)mark.locker())) {
     // Degenerate notify
     // stack-locked by caller so by definition the implied waitset is empty.
@@ -499,11 +499,11 @@
   assert(!SafepointSynchronize::is_at_safepoint(), "invariant");
   assert(self->is_Java_thread(), "invariant");
   assert(((JavaThread *) self)->thread_state() == _thread_in_Java, "invariant");
   NoSafepointVerifier nsv;
   if (obj == NULL) return false;       // Need to throw NPE
-  assert(!EnableValhalla || !obj->klass()->is_value(), "monitor op on value type");
+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), "monitor op on inline type");
   const markWord mark = obj->mark();
 
   if (mark.has_monitor()) {
     ObjectMonitor* const m = mark.monitor();
     if (AsyncDeflateIdleMonitors) {
@@ -610,11 +610,11 @@
 void ObjectSynchronizer::exit(oop object, BasicLock* lock, TRAPS) {
   markWord mark = object->mark();
   if (EnableValhalla && mark.is_always_locked()) {
     return;
   }
-  assert(!EnableValhalla || !object->klass()->is_value(), "monitor op on value type");
+  assert(!EnableValhalla || !object->klass()->is_inline_klass(), "monitor op on inline type");
   // We cannot check for Biased Locking if we are racing an inflation.
   assert(mark == markWord::INFLATING() ||
          !mark.has_bias_pattern(), "should not see bias pattern here");
 
   markWord dhw = lock->displaced_header();
@@ -674,11 +674,11 @@
 //  3) when notified on lock2, unlock lock2
 //  4) reenter lock1 with original recursion count
 //  5) lock lock2
 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 intx ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {
-  assert(!EnableValhalla || !obj->klass()->is_value(), "monitor op on value type");
+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), "monitor op on inline type");
   if (UseBiasedLocking) {
     BiasedLocking::revoke(obj, THREAD);
     assert(!obj->mark().has_bias_pattern(), "biases should be revoked by now");
   }
 
@@ -689,11 +689,11 @@
   return ret_code;
 }
 
 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 void ObjectSynchronizer::reenter(Handle obj, intx recursions, TRAPS) {
-  assert(!EnableValhalla || !obj->klass()->is_value(), "monitor op on value type");
+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), "monitor op on inline type");
   if (UseBiasedLocking) {
     BiasedLocking::revoke(obj, THREAD);
     assert(!obj->mark().has_bias_pattern(), "biases should be revoked by now");
   }
 
@@ -1010,12 +1010,12 @@
   assert(value != markWord::no_hash, "invariant");
   return value;
 }
 
 intptr_t ObjectSynchronizer::FastHashCode(Thread* self, oop obj) {
-  if (EnableValhalla && obj->klass()->is_value()) {
-    // Expected tooling to override hashCode for value type, just don't crash
+  if (EnableValhalla && obj->klass()->is_inline_klass()) {
+    // Expected tooling to override hashCode for inline type, just don't crash
     if (log_is_enabled(Debug, monitorinflation)) {
       ResourceMark rm;
       log_debug(monitorinflation)("FastHashCode for value type: %s", obj->klass()->external_name());
     }
     return obj->klass()->java_mirror()->identity_hash();
@@ -1809,11 +1809,11 @@
   // Relaxing assertion for bug 6320749.
   assert(Universe::verify_in_progress() ||
          !SafepointSynchronize::is_at_safepoint(), "invariant");
 
   if (EnableValhalla) {
-    guarantee(!object->klass()->is_value(), "Attempt to inflate value type");
+    guarantee(!object->klass()->is_inline_klass(), "Attempt to inflate inline type");
   }
 
   EventJavaMonitorInflate event;
 
   for (;;) {

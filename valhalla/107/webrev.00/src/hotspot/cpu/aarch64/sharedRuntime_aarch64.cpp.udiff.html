<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_aarch64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_aarch64.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -289,11 +289,11 @@</span>
        assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
        // fall through
      case T_OBJECT:
      case T_ARRAY:
      case T_ADDRESS:
<span class="udiff-line-modified-removed">-     case T_VALUETYPE:</span>
<span class="udiff-line-modified-added">+     case T_INLINE_TYPE:</span>
        if (int_args &lt; Argument::n_int_register_parameters_j) {
          regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
        } else {
          regs[i].set2(VMRegImpl::stack2reg(stk_args));
          stk_args += 2;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -373,11 +373,11 @@</span>
      case T_OBJECT:
      case T_ARRAY:
      case T_ADDRESS:
        // Should T_METADATA be added to java_calling_convention as well ?
      case T_METADATA:
<span class="udiff-line-modified-removed">-     case T_VALUETYPE:</span>
<span class="udiff-line-modified-added">+     case T_INLINE_TYPE:</span>
        if (int_args &lt; SharedRuntime::java_return_convention_max_int) {
          regs[i].set2(INT_ArgReg[int_args]-&gt;as_VMReg());
          int_args ++;
        } else {
          return -1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -448,27 +448,27 @@</span>
    if (InlineTypePassFieldsAsArgs) {
       for (int i = 0; i &lt; sig_extended-&gt;length(); i++) {
         BasicType bt = sig_extended-&gt;at(i)._bt;
         if (SigEntry::is_reserved_entry(sig_extended, i)) {
           // Ignore reserved entry
<span class="udiff-line-modified-removed">-        } else if (bt == T_VALUETYPE) {</span>
<span class="udiff-line-modified-added">+        } else if (bt == T_INLINE_TYPE) {</span>
           // In sig_extended, a value type argument starts with:
<span class="udiff-line-modified-removed">-          // T_VALUETYPE, followed by the types of the fields of the</span>
<span class="udiff-line-modified-added">+          // T_INLINE_TYPE, followed by the types of the fields of the</span>
           // value type and T_VOID to mark the end of the value
           // type. Value types are flattened so, for instance, in the
           // case of a value type with an int field and a value type
           // field that itself has 2 fields, an int and a long:
<span class="udiff-line-modified-removed">-          // T_VALUETYPE T_INT T_VALUETYPE T_INT T_LONG T_VOID (second</span>
<span class="udiff-line-modified-removed">-          // slot for the T_LONG) T_VOID (inner T_VALUETYPE) T_VOID</span>
<span class="udiff-line-modified-removed">-          // (outer T_VALUETYPE)</span>
<span class="udiff-line-modified-added">+          // T_INLINE_TYPE T_INT T_INLINE_TYPE T_INT T_LONG T_VOID (second</span>
<span class="udiff-line-modified-added">+          // slot for the T_LONG) T_VOID (inner T_INLINE_TYPE) T_VOID</span>
<span class="udiff-line-modified-added">+          // (outer T_INLINE_TYPE)</span>
           total_args_passed++;
           int vt = 1;
           do {
             i++;
             BasicType bt = sig_extended-&gt;at(i)._bt;
             BasicType prev_bt = sig_extended-&gt;at(i-1)._bt;
<span class="udiff-line-modified-removed">-            if (bt == T_VALUETYPE) {</span>
<span class="udiff-line-modified-added">+            if (bt == T_INLINE_TYPE) {</span>
               vt++;
             } else if (bt == T_VOID &amp;&amp;
                        prev_bt != T_LONG &amp;&amp;
                        prev_bt != T_DOUBLE) {
               vt--;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -486,11 +486,11 @@</span>
  }
  
  
  static void gen_c2i_adapter_helper(MacroAssembler* masm, BasicType bt, const VMRegPair&amp; reg_pair, int extraspace, const Address&amp; to) {
  
<span class="udiff-line-modified-removed">-     assert(bt != T_VALUETYPE || !InlineTypePassFieldsAsArgs, &quot;no inline type here&quot;);</span>
<span class="udiff-line-modified-added">+     assert(bt != T_INLINE_TYPE || !InlineTypePassFieldsAsArgs, &quot;no inline type here&quot;);</span>
  
      // Say 4 args:
      // i   st_off
      // 0   32 T_LONG
      // 1   24 T_VOID
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -562,11 +562,11 @@</span>
    bool has_value_argument = false;
  
    if (InlineTypePassFieldsAsArgs) {
        // Is there an inline type argument?
       for (int i = 0; i &lt; sig_extended-&gt;length() &amp;&amp; !has_value_argument; i++) {
<span class="udiff-line-modified-removed">-        has_value_argument = (sig_extended-&gt;at(i)._bt == T_VALUETYPE);</span>
<span class="udiff-line-modified-added">+        has_value_argument = (sig_extended-&gt;at(i)._bt == T_INLINE_TYPE);</span>
       }
       if (has_value_argument) {
        // There is at least a value type argument: we&#39;re coming from
        // compiled code so we have no buffers to back the value
        // types. Allocate the buffers here with a runtime call.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -629,11 +629,11 @@</span>
    for (int next_arg_comp = 0; next_arg_comp &lt; total_args_passed; next_arg_comp++) {
      BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
      // offset to start parameters
      int st_off   = (total_args_passed - next_arg_int - 1) * Interpreter::stackElementSize;
  
<span class="udiff-line-modified-removed">-     if (!InlineTypePassFieldsAsArgs || bt != T_VALUETYPE) {</span>
<span class="udiff-line-modified-added">+     if (!InlineTypePassFieldsAsArgs || bt != T_INLINE_TYPE) {</span>
  
              if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
                 continue; // Ignore reserved entry
              }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -649,11 +649,11 @@</span>
               gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp], extraspace, Address(sp, offset));
               next_arg_int ++;
     } else {
         ignored++;
        // get the buffer from the just allocated pool of buffers
<span class="udiff-line-modified-removed">-       int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_VALUETYPE);</span>
<span class="udiff-line-modified-added">+       int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_INLINE_TYPE);</span>
        __ load_heap_oop(rscratch1, Address(r10, index));
        next_vt_arg++;
        next_arg_int++;
        int vt = 1;
        // write fields we get from compiled code in registers/stack
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -664,11 +664,11 @@</span>
        // sig_extended contains a field offset in the buffer.
        do {
          next_arg_comp++;
          BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
          BasicType prev_bt = sig_extended-&gt;at(next_arg_comp - 1)._bt;
<span class="udiff-line-modified-removed">-         if (bt == T_VALUETYPE) {</span>
<span class="udiff-line-modified-added">+         if (bt == T_INLINE_TYPE) {</span>
            vt++;
            ignored++;
          } else if (bt == T_VOID &amp;&amp; prev_bt != T_LONG &amp;&amp; prev_bt != T_DOUBLE) {
            vt--;
            ignored++;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -801,11 +801,11 @@</span>
  
    // Now generate the shuffle code.
    for (int i = 0; i &lt; total_args_passed; i++) {
      BasicType bt = sig-&gt;at(i)._bt;
  
<span class="udiff-line-modified-removed">-     assert(bt != T_VALUETYPE, &quot;i2c adapter doesn&#39;t unpack value args&quot;);</span>
<span class="udiff-line-modified-added">+     assert(bt != T_INLINE_TYPE, &quot;i2c adapter doesn&#39;t unpack value args&quot;);</span>
      if (bt == T_VOID) {
        assert(i &gt; 0 &amp;&amp; (sig-&gt;at(i - 1)._bt == T_LONG || sig-&gt;at(i - 1)._bt == T_DOUBLE), &quot;missing half&quot;);
        continue;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1055,11 +1055,11 @@</span>
        case T_LONG:
          assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
          // fall through
        case T_OBJECT:
        case T_ARRAY:
<span class="udiff-line-modified-removed">-       case T_VALUETYPE:</span>
<span class="udiff-line-modified-added">+       case T_INLINE_TYPE:</span>
        case T_ADDRESS:
        case T_METADATA:
          if (int_args &lt; Argument::n_int_register_parameters_c) {
            regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
          } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1907,11 +1907,11 @@</span>
            }
  #endif
            int_args++;
            break;
          }
<span class="udiff-line-modified-removed">-       case T_VALUETYPE:</span>
<span class="udiff-line-modified-added">+       case T_INLINE_TYPE:</span>
        case T_OBJECT:
          assert(!is_critical_native, &quot;no oop arguments&quot;);
          object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
                      ((i == 0) &amp;&amp; (!is_static)),
                      &amp;receiver_offset);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2095,11 +2095,11 @@</span>
    case T_DOUBLE :
    case T_FLOAT  :
      // Result is in v0 we&#39;ll save as needed
      break;
    case T_ARRAY:                 // Really a handle
<span class="udiff-line-modified-removed">-   case T_VALUETYPE:</span>
<span class="udiff-line-modified-added">+   case T_INLINE_TYPE:</span>
    case T_OBJECT:                // Really a handle
        break; // can&#39;t de-handlize until after safepoint check
    case T_VOID: break;
    case T_LONG: break;
    default       : ShouldNotReachHere();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3340,11 +3340,11 @@</span>
    int pack_fields_off = __ offset();
  
    int j = 1;
    for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
      BasicType bt = sig_vk-&gt;at(i)._bt;
<span class="udiff-line-modified-removed">-     if (bt == T_VALUETYPE) {</span>
<span class="udiff-line-modified-added">+     if (bt == T_INLINE_TYPE) {</span>
        continue;
      }
      if (bt == T_VOID) {
        if (sig_vk-&gt;at(i-1)._bt == T_LONG ||
            sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3387,11 +3387,11 @@</span>
    int unpack_fields_off = __ offset();
  
    j = 1;
    for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
      BasicType bt = sig_vk-&gt;at(i)._bt;
<span class="udiff-line-modified-removed">-     if (bt == T_VALUETYPE) {</span>
<span class="udiff-line-modified-added">+     if (bt == T_INLINE_TYPE) {</span>
        continue;
      }
      if (bt == T_VOID) {
        if (sig_vk-&gt;at(i-1)._bt == T_LONG ||
            sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {
</pre>
<center><a href="macroAssembler_aarch64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_aarch64.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
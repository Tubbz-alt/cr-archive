<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="abstractInterpreter_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 555 
 556   switch (c-&gt;type()) {
 557     case T_INT: {
 558       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 559       __ movw(dest-&gt;as_register(), c-&gt;as_jint());
 560       break;
 561     }
 562 
 563     case T_ADDRESS: {
 564       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 565       __ mov(dest-&gt;as_register(), c-&gt;as_jint());
 566       break;
 567     }
 568 
 569     case T_LONG: {
 570       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 571       __ mov(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 572       break;
 573     }
 574 
<span class="line-modified"> 575     case T_VALUETYPE:</span>
 576     case T_OBJECT: {
 577         if (patch_code != lir_patch_none) {
 578           jobject2reg_with_patching(dest-&gt;as_register(), info);
 579         } else {
 580           jobject2reg(c-&gt;as_jobject(), dest-&gt;as_register());
 581         }
 582       break;
 583     }
 584 
 585     case T_METADATA: {
 586       if (patch_code != lir_patch_none) {
 587         klass2reg_with_patching(dest-&gt;as_register(), info);
 588       } else {
 589         __ mov_metadata(dest-&gt;as_register(), c-&gt;as_metadata());
 590       }
 591       break;
 592     }
 593 
 594     case T_FLOAT: {
 595       if (__ operand_valid_for_float_immediate(c-&gt;as_jfloat())) {
</pre>
<hr />
<pre>
 602     }
 603 
 604     case T_DOUBLE: {
 605       if (__ operand_valid_for_float_immediate(c-&gt;as_jdouble())) {
 606         __ fmovd(dest-&gt;as_double_reg(), (c-&gt;as_jdouble()));
 607       } else {
 608         __ adr(rscratch1, InternalAddress(double_constant(c-&gt;as_jdouble())));
 609         __ ldrd(dest-&gt;as_double_reg(), Address(rscratch1));
 610       }
 611       break;
 612     }
 613 
 614     default:
 615       ShouldNotReachHere();
 616   }
 617 }
 618 
 619 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 620   LIR_Const* c = src-&gt;as_constant_ptr();
 621   switch (c-&gt;type()) {
<span class="line-modified"> 622   case T_VALUETYPE:</span>
 623   case T_OBJECT:
 624     {
 625       if (! c-&gt;as_jobject())
 626         __ str(zr, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 627       else {
 628         const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);
 629         reg2stack(FrameMap::rscratch1_opr, dest, c-&gt;type(), false);
 630       }
 631     }
 632     break;
 633   case T_ADDRESS:
 634     {
 635       const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);
 636       reg2stack(FrameMap::rscratch1_opr, dest, c-&gt;type(), false);
 637     }
 638   case T_INT:
 639   case T_FLOAT:
 640     {
 641       Register reg = zr;
 642       if (c-&gt;as_jint_bits() == 0)
</pre>
<hr />
<pre>
 669 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 670   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 671   LIR_Const* c = src-&gt;as_constant_ptr();
 672   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 673 
 674   void (Assembler::* insn)(Register Rt, const Address &amp;adr);
 675 
 676   switch (type) {
 677   case T_ADDRESS:
 678     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 679     insn = &amp;Assembler::str;
 680     break;
 681   case T_LONG:
 682     assert(c-&gt;as_jlong() == 0, &quot;should be&quot;);
 683     insn = &amp;Assembler::str;
 684     break;
 685   case T_INT:
 686     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 687     insn = &amp;Assembler::strw;
 688     break;
<span class="line-modified"> 689   case T_VALUETYPE:</span>
 690   case T_OBJECT:
 691   case T_ARRAY:
 692     // Non-null case is not handled on aarch64 but handled on x86
 693     // FIXME: do we need to add it here?
 694     assert(c-&gt;as_jobject() == 0, &quot;should be&quot;);
 695     if (UseCompressedOops &amp;&amp; !wide) {
 696       insn = &amp;Assembler::strw;
 697     } else {
 698       insn = &amp;Assembler::str;
 699     }
 700     break;
 701   case T_CHAR:
 702   case T_SHORT:
 703     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 704     insn = &amp;Assembler::strh;
 705     break;
 706   case T_BOOLEAN:
 707   case T_BYTE:
 708     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 709     insn = &amp;Assembler::strb;
</pre>
<hr />
<pre>
 712     ShouldNotReachHere();
 713     insn = &amp;Assembler::str;  // unreachable
 714   }
 715 
 716   if (info) add_debug_info_for_null_check_here(info);
 717   (_masm-&gt;*insn)(zr, as_Address(to_addr, rscratch1));
 718 }
 719 
 720 void LIR_Assembler::reg2reg(LIR_Opr src, LIR_Opr dest) {
 721   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 722   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 723 
 724   // move between cpu-registers
 725   if (dest-&gt;is_single_cpu()) {
 726     if (src-&gt;type() == T_LONG) {
 727       // Can do LONG -&gt; OBJECT
 728       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
 729       return;
 730     }
 731     assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
<span class="line-modified"> 732     if (src-&gt;type() == T_OBJECT || src-&gt;type() == T_VALUETYPE) {</span>
 733       __ verify_oop(src-&gt;as_register());
 734     }
 735     move_regs(src-&gt;as_register(), dest-&gt;as_register());
 736 
 737   } else if (dest-&gt;is_double_cpu()) {
 738     if (is_reference_type(src-&gt;type())) {
 739       // Surprising to me but we can see move of a long to t_object
 740       __ verify_oop(src-&gt;as_register());
 741       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
 742       return;
 743     }
 744     assert(src-&gt;is_double_cpu(), &quot;must match&quot;);
 745     Register f_lo = src-&gt;as_register_lo();
 746     Register f_hi = src-&gt;as_register_hi();
 747     Register t_lo = dest-&gt;as_register_lo();
 748     Register t_hi = dest-&gt;as_register_hi();
 749     assert(f_hi == f_lo, &quot;must be same&quot;);
 750     assert(t_hi == t_lo, &quot;must be same&quot;);
 751     move_regs(f_lo, t_lo);
 752 
</pre>
<hr />
<pre>
 806 
 807     if (UseCompressedOops &amp;&amp; !wide) {
 808       __ encode_heap_oop(compressed_src, src-&gt;as_register());
 809     } else {
 810       compressed_src = src-&gt;as_register();
 811     }
 812   }
 813 
 814   int null_check_here = code_offset();
 815   switch (type) {
 816     case T_FLOAT: {
 817       __ strs(src-&gt;as_float_reg(), as_Address(to_addr));
 818       break;
 819     }
 820 
 821     case T_DOUBLE: {
 822       __ strd(src-&gt;as_double_reg(), as_Address(to_addr));
 823       break;
 824     }
 825 
<span class="line-modified"> 826     case T_VALUETYPE: // fall through</span>
 827     case T_ARRAY:   // fall through
 828     case T_OBJECT:  // fall through
 829       if (UseCompressedOops &amp;&amp; !wide) {
 830         __ strw(compressed_src, as_Address(to_addr, rscratch2));
 831       } else {
 832          __ str(compressed_src, as_Address(to_addr));
 833       }
 834       break;
 835     case T_METADATA:
 836       // We get here to store a method pointer to the stack to pass to
 837       // a dtrace runtime call. This can&#39;t work on 64 bit with
 838       // compressed klass ptrs: T_METADATA can be a compressed klass
 839       // ptr or a 64 bit method pointer.
 840       ShouldNotReachHere();
 841       __ str(src-&gt;as_register(), as_Address(to_addr));
 842       break;
 843     case T_ADDRESS:
 844       __ str(src-&gt;as_register(), as_Address(to_addr));
 845       break;
 846     case T_INT:
</pre>
<hr />
<pre>
 932   add_call_info_here(info);
 933 }
 934 
 935 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
 936 
 937   LIR_Opr temp;
 938   if (type == T_LONG || type == T_DOUBLE)
 939     temp = FrameMap::rscratch1_long_opr;
 940   else
 941     temp = FrameMap::rscratch1_opr;
 942 
 943   stack2reg(src, temp, src-&gt;type());
 944   reg2stack(temp, dest, dest-&gt;type(), false);
 945 }
 946 
 947 
 948 void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool /* unaligned */) {
 949   LIR_Address* addr = src-&gt;as_address_ptr();
 950   LIR_Address* from_addr = src-&gt;as_address_ptr();
 951 
<span class="line-modified"> 952   if (addr-&gt;base()-&gt;type() == T_OBJECT || addr-&gt;base()-&gt;type() == T_VALUETYPE) {</span>
 953     __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
 954   }
 955 
 956   if (patch_code != lir_patch_none) {
 957     deoptimize_trap(info);
 958     return;
 959   }
 960 
 961   if (info != NULL) {
 962     add_debug_info_for_null_check_here(info);
 963   }
 964   int null_check_here = code_offset();
 965   switch (type) {
 966     case T_FLOAT: {
 967       __ ldrs(dest-&gt;as_float_reg(), as_Address(from_addr));
 968       break;
 969     }
 970 
 971     case T_DOUBLE: {
 972       __ ldrd(dest-&gt;as_double_reg(), as_Address(from_addr));
 973       break;
 974     }
 975 
<span class="line-modified"> 976     case T_VALUETYPE: // fall through</span>
 977     case T_ARRAY:   // fall through
 978     case T_OBJECT:  // fall through
 979       if (UseCompressedOops &amp;&amp; !wide) {
 980         __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
 981       } else {
 982          __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 983       }
 984       break;
 985     case T_METADATA:
 986       // We get here to store a method pointer to the stack to pass to
 987       // a dtrace runtime call. This can&#39;t work on 64 bit with
 988       // compressed klass ptrs: T_METADATA can be a compressed klass
 989       // ptr or a 64 bit method pointer.
 990       ShouldNotReachHere();
 991       __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 992       break;
 993     case T_ADDRESS:
 994       // FIXME: OMG this is a horrible kludge.  Any offset from an
 995       // address that matches klass_offset_in_bytes() will be loaded
 996       // as a word, not a long.
</pre>
<hr />
<pre>
1235     __ ldrb(rscratch1, Address(op-&gt;klass()-&gt;as_register(),
1236                                InstanceKlass::init_state_offset()));
1237     __ cmpw(rscratch1, InstanceKlass::fully_initialized);
1238     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
1239     __ br(Assembler::NE, *op-&gt;stub()-&gt;entry());
1240   }
1241   __ allocate_object(op-&gt;obj()-&gt;as_register(),
1242                      op-&gt;tmp1()-&gt;as_register(),
1243                      op-&gt;tmp2()-&gt;as_register(),
1244                      op-&gt;header_size(),
1245                      op-&gt;object_size(),
1246                      op-&gt;klass()-&gt;as_register(),
1247                      *op-&gt;stub()-&gt;entry());
1248   __ bind(*op-&gt;stub()-&gt;continuation());
1249 }
1250 
1251 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
1252   Register len =  op-&gt;len()-&gt;as_register();
1253   __ uxtw(len, len);
1254 
<span class="line-modified">1255   if (UseSlowPath || op-&gt;type() == T_VALUETYPE ||</span>
1256       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
1257       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
1258     __ b(*op-&gt;stub()-&gt;entry());
1259   } else {
1260     Register tmp1 = op-&gt;tmp1()-&gt;as_register();
1261     Register tmp2 = op-&gt;tmp2()-&gt;as_register();
1262     Register tmp3 = op-&gt;tmp3()-&gt;as_register();
1263     if (len == tmp1) {
1264       tmp1 = tmp3;
1265     } else if (len == tmp2) {
1266       tmp2 = tmp3;
1267     } else if (len == tmp3) {
1268       // everything is ok
1269     } else {
1270       __ mov(tmp3, len);
1271     }
1272     __ allocate_array(op-&gt;obj()-&gt;as_register(),
1273                       len,
1274                       tmp1,
1275                       tmp2,
</pre>
<hr />
<pre>
2112     }
2113 
2114     if (opr2-&gt;is_constant()) {
2115       bool is_32bit = false; // width of register operand
2116       jlong imm;
2117 
2118       switch(opr2-&gt;type()) {
2119       case T_INT:
2120         imm = opr2-&gt;as_constant_ptr()-&gt;as_jint();
2121         is_32bit = true;
2122         break;
2123       case T_LONG:
2124         imm = opr2-&gt;as_constant_ptr()-&gt;as_jlong();
2125         break;
2126       case T_ADDRESS:
2127         imm = opr2-&gt;as_constant_ptr()-&gt;as_jint();
2128         break;
2129       case T_METADATA:
2130         imm = (intptr_t)(opr2-&gt;as_constant_ptr()-&gt;as_metadata());
2131         break;
<span class="line-modified">2132       case T_VALUETYPE:</span>
2133       case T_OBJECT:
2134       case T_ARRAY:
2135         jobject2reg(opr2-&gt;as_constant_ptr()-&gt;as_jobject(), rscratch1);
2136         __ cmpoop(reg1, rscratch1);
2137         return;
2138       default:
2139         ShouldNotReachHere();
2140         imm = 0;  // unreachable
2141         break;
2142       }
2143 
2144       if (Assembler::operand_valid_for_add_sub_immediate(imm)) {
2145         if (is_32bit)
2146           __ cmpw(reg1, imm);
2147         else
2148           __ subs(zr, reg1, imm);
2149         return;
2150       } else {
2151         __ mov(rscratch1, imm);
2152         if (is_32bit)
</pre>
<hr />
<pre>
2279   __ b(_unwind_handler_entry);
2280 }
2281 
2282 
2283 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2284   Register lreg = left-&gt;is_single_cpu() ? left-&gt;as_register() : left-&gt;as_register_lo();
2285   Register dreg = dest-&gt;is_single_cpu() ? dest-&gt;as_register() : dest-&gt;as_register_lo();
2286 
2287   switch (left-&gt;type()) {
2288     case T_INT: {
2289       switch (code) {
2290       case lir_shl:  __ lslvw (dreg, lreg, count-&gt;as_register()); break;
2291       case lir_shr:  __ asrvw (dreg, lreg, count-&gt;as_register()); break;
2292       case lir_ushr: __ lsrvw (dreg, lreg, count-&gt;as_register()); break;
2293       default:
2294         ShouldNotReachHere();
2295         break;
2296       }
2297       break;
2298     case T_LONG:
<span class="line-modified">2299     case T_VALUETYPE:</span>
2300     case T_ADDRESS:
2301     case T_OBJECT:
2302       switch (code) {
2303       case lir_shl:  __ lslv (dreg, lreg, count-&gt;as_register()); break;
2304       case lir_shr:  __ asrv (dreg, lreg, count-&gt;as_register()); break;
2305       case lir_ushr: __ lsrv (dreg, lreg, count-&gt;as_register()); break;
2306       default:
2307         ShouldNotReachHere();
2308         break;
2309       }
2310       break;
2311     default:
2312       ShouldNotReachHere();
2313       break;
2314     }
2315   }
2316 }
2317 
2318 
2319 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
2320   Register dreg = dest-&gt;is_single_cpu() ? dest-&gt;as_register() : dest-&gt;as_register_lo();
2321   Register lreg = left-&gt;is_single_cpu() ? left-&gt;as_register() : left-&gt;as_register_lo();
2322 
2323   switch (left-&gt;type()) {
2324     case T_INT: {
2325       switch (code) {
2326       case lir_shl:  __ lslw (dreg, lreg, count); break;
2327       case lir_shr:  __ asrw (dreg, lreg, count); break;
2328       case lir_ushr: __ lsrw (dreg, lreg, count); break;
2329       default:
2330         ShouldNotReachHere();
2331         break;
2332       }
2333       break;
2334     case T_LONG:
2335     case T_ADDRESS:
<span class="line-modified">2336     case T_VALUETYPE:</span>
2337     case T_OBJECT:
2338       switch (code) {
2339       case lir_shl:  __ lsl (dreg, lreg, count); break;
2340       case lir_shr:  __ asr (dreg, lreg, count); break;
2341       case lir_ushr: __ lsr (dreg, lreg, count); break;
2342       default:
2343         ShouldNotReachHere();
2344         break;
2345       }
2346       break;
2347     default:
2348       ShouldNotReachHere();
2349       break;
2350     }
2351   }
2352 }
2353 
2354 
2355 void LIR_Assembler::store_parameter(Register r, int offset_from_rsp_in_words) {
2356   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
</pre>
<hr />
<pre>
3311 #endif
3312 }
3313 
3314 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp_op) {
3315   Address addr = as_Address(src-&gt;as_address_ptr());
3316   BasicType type = src-&gt;type();
3317   bool is_oop = is_reference_type(type);
3318 
3319   void (MacroAssembler::* add)(Register prev, RegisterOrConstant incr, Register addr);
3320   void (MacroAssembler::* xchg)(Register prev, Register newv, Register addr);
3321 
3322   switch(type) {
3323   case T_INT:
3324     xchg = &amp;MacroAssembler::atomic_xchgalw;
3325     add = &amp;MacroAssembler::atomic_addalw;
3326     break;
3327   case T_LONG:
3328     xchg = &amp;MacroAssembler::atomic_xchgal;
3329     add = &amp;MacroAssembler::atomic_addal;
3330     break;
<span class="line-modified">3331   case T_VALUETYPE:</span>
3332   case T_OBJECT:
3333   case T_ARRAY:
3334     if (UseCompressedOops) {
3335       xchg = &amp;MacroAssembler::atomic_xchgalw;
3336       add = &amp;MacroAssembler::atomic_addalw;
3337     } else {
3338       xchg = &amp;MacroAssembler::atomic_xchgal;
3339       add = &amp;MacroAssembler::atomic_addal;
3340     }
3341     break;
3342   default:
3343     ShouldNotReachHere();
3344     xchg = &amp;MacroAssembler::atomic_xchgal;
3345     add = &amp;MacroAssembler::atomic_addal; // unreachable
3346   }
3347 
3348   switch (code) {
3349   case lir_xadd:
3350     {
3351       RegisterOrConstant inc;
</pre>
</td>
<td>
<hr />
<pre>
 555 
 556   switch (c-&gt;type()) {
 557     case T_INT: {
 558       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 559       __ movw(dest-&gt;as_register(), c-&gt;as_jint());
 560       break;
 561     }
 562 
 563     case T_ADDRESS: {
 564       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 565       __ mov(dest-&gt;as_register(), c-&gt;as_jint());
 566       break;
 567     }
 568 
 569     case T_LONG: {
 570       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 571       __ mov(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 572       break;
 573     }
 574 
<span class="line-modified"> 575     case T_INLINE_TYPE:</span>
 576     case T_OBJECT: {
 577         if (patch_code != lir_patch_none) {
 578           jobject2reg_with_patching(dest-&gt;as_register(), info);
 579         } else {
 580           jobject2reg(c-&gt;as_jobject(), dest-&gt;as_register());
 581         }
 582       break;
 583     }
 584 
 585     case T_METADATA: {
 586       if (patch_code != lir_patch_none) {
 587         klass2reg_with_patching(dest-&gt;as_register(), info);
 588       } else {
 589         __ mov_metadata(dest-&gt;as_register(), c-&gt;as_metadata());
 590       }
 591       break;
 592     }
 593 
 594     case T_FLOAT: {
 595       if (__ operand_valid_for_float_immediate(c-&gt;as_jfloat())) {
</pre>
<hr />
<pre>
 602     }
 603 
 604     case T_DOUBLE: {
 605       if (__ operand_valid_for_float_immediate(c-&gt;as_jdouble())) {
 606         __ fmovd(dest-&gt;as_double_reg(), (c-&gt;as_jdouble()));
 607       } else {
 608         __ adr(rscratch1, InternalAddress(double_constant(c-&gt;as_jdouble())));
 609         __ ldrd(dest-&gt;as_double_reg(), Address(rscratch1));
 610       }
 611       break;
 612     }
 613 
 614     default:
 615       ShouldNotReachHere();
 616   }
 617 }
 618 
 619 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 620   LIR_Const* c = src-&gt;as_constant_ptr();
 621   switch (c-&gt;type()) {
<span class="line-modified"> 622   case T_INLINE_TYPE:</span>
 623   case T_OBJECT:
 624     {
 625       if (! c-&gt;as_jobject())
 626         __ str(zr, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 627       else {
 628         const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);
 629         reg2stack(FrameMap::rscratch1_opr, dest, c-&gt;type(), false);
 630       }
 631     }
 632     break;
 633   case T_ADDRESS:
 634     {
 635       const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);
 636       reg2stack(FrameMap::rscratch1_opr, dest, c-&gt;type(), false);
 637     }
 638   case T_INT:
 639   case T_FLOAT:
 640     {
 641       Register reg = zr;
 642       if (c-&gt;as_jint_bits() == 0)
</pre>
<hr />
<pre>
 669 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 670   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 671   LIR_Const* c = src-&gt;as_constant_ptr();
 672   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 673 
 674   void (Assembler::* insn)(Register Rt, const Address &amp;adr);
 675 
 676   switch (type) {
 677   case T_ADDRESS:
 678     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 679     insn = &amp;Assembler::str;
 680     break;
 681   case T_LONG:
 682     assert(c-&gt;as_jlong() == 0, &quot;should be&quot;);
 683     insn = &amp;Assembler::str;
 684     break;
 685   case T_INT:
 686     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 687     insn = &amp;Assembler::strw;
 688     break;
<span class="line-modified"> 689   case T_INLINE_TYPE:</span>
 690   case T_OBJECT:
 691   case T_ARRAY:
 692     // Non-null case is not handled on aarch64 but handled on x86
 693     // FIXME: do we need to add it here?
 694     assert(c-&gt;as_jobject() == 0, &quot;should be&quot;);
 695     if (UseCompressedOops &amp;&amp; !wide) {
 696       insn = &amp;Assembler::strw;
 697     } else {
 698       insn = &amp;Assembler::str;
 699     }
 700     break;
 701   case T_CHAR:
 702   case T_SHORT:
 703     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 704     insn = &amp;Assembler::strh;
 705     break;
 706   case T_BOOLEAN:
 707   case T_BYTE:
 708     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 709     insn = &amp;Assembler::strb;
</pre>
<hr />
<pre>
 712     ShouldNotReachHere();
 713     insn = &amp;Assembler::str;  // unreachable
 714   }
 715 
 716   if (info) add_debug_info_for_null_check_here(info);
 717   (_masm-&gt;*insn)(zr, as_Address(to_addr, rscratch1));
 718 }
 719 
 720 void LIR_Assembler::reg2reg(LIR_Opr src, LIR_Opr dest) {
 721   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 722   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 723 
 724   // move between cpu-registers
 725   if (dest-&gt;is_single_cpu()) {
 726     if (src-&gt;type() == T_LONG) {
 727       // Can do LONG -&gt; OBJECT
 728       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
 729       return;
 730     }
 731     assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
<span class="line-modified"> 732     if (src-&gt;type() == T_OBJECT || src-&gt;type() == T_INLINE_TYPE) {</span>
 733       __ verify_oop(src-&gt;as_register());
 734     }
 735     move_regs(src-&gt;as_register(), dest-&gt;as_register());
 736 
 737   } else if (dest-&gt;is_double_cpu()) {
 738     if (is_reference_type(src-&gt;type())) {
 739       // Surprising to me but we can see move of a long to t_object
 740       __ verify_oop(src-&gt;as_register());
 741       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
 742       return;
 743     }
 744     assert(src-&gt;is_double_cpu(), &quot;must match&quot;);
 745     Register f_lo = src-&gt;as_register_lo();
 746     Register f_hi = src-&gt;as_register_hi();
 747     Register t_lo = dest-&gt;as_register_lo();
 748     Register t_hi = dest-&gt;as_register_hi();
 749     assert(f_hi == f_lo, &quot;must be same&quot;);
 750     assert(t_hi == t_lo, &quot;must be same&quot;);
 751     move_regs(f_lo, t_lo);
 752 
</pre>
<hr />
<pre>
 806 
 807     if (UseCompressedOops &amp;&amp; !wide) {
 808       __ encode_heap_oop(compressed_src, src-&gt;as_register());
 809     } else {
 810       compressed_src = src-&gt;as_register();
 811     }
 812   }
 813 
 814   int null_check_here = code_offset();
 815   switch (type) {
 816     case T_FLOAT: {
 817       __ strs(src-&gt;as_float_reg(), as_Address(to_addr));
 818       break;
 819     }
 820 
 821     case T_DOUBLE: {
 822       __ strd(src-&gt;as_double_reg(), as_Address(to_addr));
 823       break;
 824     }
 825 
<span class="line-modified"> 826     case T_INLINE_TYPE: // fall through</span>
 827     case T_ARRAY:   // fall through
 828     case T_OBJECT:  // fall through
 829       if (UseCompressedOops &amp;&amp; !wide) {
 830         __ strw(compressed_src, as_Address(to_addr, rscratch2));
 831       } else {
 832          __ str(compressed_src, as_Address(to_addr));
 833       }
 834       break;
 835     case T_METADATA:
 836       // We get here to store a method pointer to the stack to pass to
 837       // a dtrace runtime call. This can&#39;t work on 64 bit with
 838       // compressed klass ptrs: T_METADATA can be a compressed klass
 839       // ptr or a 64 bit method pointer.
 840       ShouldNotReachHere();
 841       __ str(src-&gt;as_register(), as_Address(to_addr));
 842       break;
 843     case T_ADDRESS:
 844       __ str(src-&gt;as_register(), as_Address(to_addr));
 845       break;
 846     case T_INT:
</pre>
<hr />
<pre>
 932   add_call_info_here(info);
 933 }
 934 
 935 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
 936 
 937   LIR_Opr temp;
 938   if (type == T_LONG || type == T_DOUBLE)
 939     temp = FrameMap::rscratch1_long_opr;
 940   else
 941     temp = FrameMap::rscratch1_opr;
 942 
 943   stack2reg(src, temp, src-&gt;type());
 944   reg2stack(temp, dest, dest-&gt;type(), false);
 945 }
 946 
 947 
 948 void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool /* unaligned */) {
 949   LIR_Address* addr = src-&gt;as_address_ptr();
 950   LIR_Address* from_addr = src-&gt;as_address_ptr();
 951 
<span class="line-modified"> 952   if (addr-&gt;base()-&gt;type() == T_OBJECT || addr-&gt;base()-&gt;type() == T_INLINE_TYPE) {</span>
 953     __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
 954   }
 955 
 956   if (patch_code != lir_patch_none) {
 957     deoptimize_trap(info);
 958     return;
 959   }
 960 
 961   if (info != NULL) {
 962     add_debug_info_for_null_check_here(info);
 963   }
 964   int null_check_here = code_offset();
 965   switch (type) {
 966     case T_FLOAT: {
 967       __ ldrs(dest-&gt;as_float_reg(), as_Address(from_addr));
 968       break;
 969     }
 970 
 971     case T_DOUBLE: {
 972       __ ldrd(dest-&gt;as_double_reg(), as_Address(from_addr));
 973       break;
 974     }
 975 
<span class="line-modified"> 976     case T_INLINE_TYPE: // fall through</span>
 977     case T_ARRAY:   // fall through
 978     case T_OBJECT:  // fall through
 979       if (UseCompressedOops &amp;&amp; !wide) {
 980         __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
 981       } else {
 982          __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 983       }
 984       break;
 985     case T_METADATA:
 986       // We get here to store a method pointer to the stack to pass to
 987       // a dtrace runtime call. This can&#39;t work on 64 bit with
 988       // compressed klass ptrs: T_METADATA can be a compressed klass
 989       // ptr or a 64 bit method pointer.
 990       ShouldNotReachHere();
 991       __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 992       break;
 993     case T_ADDRESS:
 994       // FIXME: OMG this is a horrible kludge.  Any offset from an
 995       // address that matches klass_offset_in_bytes() will be loaded
 996       // as a word, not a long.
</pre>
<hr />
<pre>
1235     __ ldrb(rscratch1, Address(op-&gt;klass()-&gt;as_register(),
1236                                InstanceKlass::init_state_offset()));
1237     __ cmpw(rscratch1, InstanceKlass::fully_initialized);
1238     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
1239     __ br(Assembler::NE, *op-&gt;stub()-&gt;entry());
1240   }
1241   __ allocate_object(op-&gt;obj()-&gt;as_register(),
1242                      op-&gt;tmp1()-&gt;as_register(),
1243                      op-&gt;tmp2()-&gt;as_register(),
1244                      op-&gt;header_size(),
1245                      op-&gt;object_size(),
1246                      op-&gt;klass()-&gt;as_register(),
1247                      *op-&gt;stub()-&gt;entry());
1248   __ bind(*op-&gt;stub()-&gt;continuation());
1249 }
1250 
1251 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
1252   Register len =  op-&gt;len()-&gt;as_register();
1253   __ uxtw(len, len);
1254 
<span class="line-modified">1255   if (UseSlowPath || op-&gt;type() == T_INLINE_TYPE ||</span>
1256       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
1257       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
1258     __ b(*op-&gt;stub()-&gt;entry());
1259   } else {
1260     Register tmp1 = op-&gt;tmp1()-&gt;as_register();
1261     Register tmp2 = op-&gt;tmp2()-&gt;as_register();
1262     Register tmp3 = op-&gt;tmp3()-&gt;as_register();
1263     if (len == tmp1) {
1264       tmp1 = tmp3;
1265     } else if (len == tmp2) {
1266       tmp2 = tmp3;
1267     } else if (len == tmp3) {
1268       // everything is ok
1269     } else {
1270       __ mov(tmp3, len);
1271     }
1272     __ allocate_array(op-&gt;obj()-&gt;as_register(),
1273                       len,
1274                       tmp1,
1275                       tmp2,
</pre>
<hr />
<pre>
2112     }
2113 
2114     if (opr2-&gt;is_constant()) {
2115       bool is_32bit = false; // width of register operand
2116       jlong imm;
2117 
2118       switch(opr2-&gt;type()) {
2119       case T_INT:
2120         imm = opr2-&gt;as_constant_ptr()-&gt;as_jint();
2121         is_32bit = true;
2122         break;
2123       case T_LONG:
2124         imm = opr2-&gt;as_constant_ptr()-&gt;as_jlong();
2125         break;
2126       case T_ADDRESS:
2127         imm = opr2-&gt;as_constant_ptr()-&gt;as_jint();
2128         break;
2129       case T_METADATA:
2130         imm = (intptr_t)(opr2-&gt;as_constant_ptr()-&gt;as_metadata());
2131         break;
<span class="line-modified">2132       case T_INLINE_TYPE:</span>
2133       case T_OBJECT:
2134       case T_ARRAY:
2135         jobject2reg(opr2-&gt;as_constant_ptr()-&gt;as_jobject(), rscratch1);
2136         __ cmpoop(reg1, rscratch1);
2137         return;
2138       default:
2139         ShouldNotReachHere();
2140         imm = 0;  // unreachable
2141         break;
2142       }
2143 
2144       if (Assembler::operand_valid_for_add_sub_immediate(imm)) {
2145         if (is_32bit)
2146           __ cmpw(reg1, imm);
2147         else
2148           __ subs(zr, reg1, imm);
2149         return;
2150       } else {
2151         __ mov(rscratch1, imm);
2152         if (is_32bit)
</pre>
<hr />
<pre>
2279   __ b(_unwind_handler_entry);
2280 }
2281 
2282 
2283 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2284   Register lreg = left-&gt;is_single_cpu() ? left-&gt;as_register() : left-&gt;as_register_lo();
2285   Register dreg = dest-&gt;is_single_cpu() ? dest-&gt;as_register() : dest-&gt;as_register_lo();
2286 
2287   switch (left-&gt;type()) {
2288     case T_INT: {
2289       switch (code) {
2290       case lir_shl:  __ lslvw (dreg, lreg, count-&gt;as_register()); break;
2291       case lir_shr:  __ asrvw (dreg, lreg, count-&gt;as_register()); break;
2292       case lir_ushr: __ lsrvw (dreg, lreg, count-&gt;as_register()); break;
2293       default:
2294         ShouldNotReachHere();
2295         break;
2296       }
2297       break;
2298     case T_LONG:
<span class="line-modified">2299     case T_INLINE_TYPE:</span>
2300     case T_ADDRESS:
2301     case T_OBJECT:
2302       switch (code) {
2303       case lir_shl:  __ lslv (dreg, lreg, count-&gt;as_register()); break;
2304       case lir_shr:  __ asrv (dreg, lreg, count-&gt;as_register()); break;
2305       case lir_ushr: __ lsrv (dreg, lreg, count-&gt;as_register()); break;
2306       default:
2307         ShouldNotReachHere();
2308         break;
2309       }
2310       break;
2311     default:
2312       ShouldNotReachHere();
2313       break;
2314     }
2315   }
2316 }
2317 
2318 
2319 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
2320   Register dreg = dest-&gt;is_single_cpu() ? dest-&gt;as_register() : dest-&gt;as_register_lo();
2321   Register lreg = left-&gt;is_single_cpu() ? left-&gt;as_register() : left-&gt;as_register_lo();
2322 
2323   switch (left-&gt;type()) {
2324     case T_INT: {
2325       switch (code) {
2326       case lir_shl:  __ lslw (dreg, lreg, count); break;
2327       case lir_shr:  __ asrw (dreg, lreg, count); break;
2328       case lir_ushr: __ lsrw (dreg, lreg, count); break;
2329       default:
2330         ShouldNotReachHere();
2331         break;
2332       }
2333       break;
2334     case T_LONG:
2335     case T_ADDRESS:
<span class="line-modified">2336     case T_INLINE_TYPE:</span>
2337     case T_OBJECT:
2338       switch (code) {
2339       case lir_shl:  __ lsl (dreg, lreg, count); break;
2340       case lir_shr:  __ asr (dreg, lreg, count); break;
2341       case lir_ushr: __ lsr (dreg, lreg, count); break;
2342       default:
2343         ShouldNotReachHere();
2344         break;
2345       }
2346       break;
2347     default:
2348       ShouldNotReachHere();
2349       break;
2350     }
2351   }
2352 }
2353 
2354 
2355 void LIR_Assembler::store_parameter(Register r, int offset_from_rsp_in_words) {
2356   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
</pre>
<hr />
<pre>
3311 #endif
3312 }
3313 
3314 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp_op) {
3315   Address addr = as_Address(src-&gt;as_address_ptr());
3316   BasicType type = src-&gt;type();
3317   bool is_oop = is_reference_type(type);
3318 
3319   void (MacroAssembler::* add)(Register prev, RegisterOrConstant incr, Register addr);
3320   void (MacroAssembler::* xchg)(Register prev, Register newv, Register addr);
3321 
3322   switch(type) {
3323   case T_INT:
3324     xchg = &amp;MacroAssembler::atomic_xchgalw;
3325     add = &amp;MacroAssembler::atomic_addalw;
3326     break;
3327   case T_LONG:
3328     xchg = &amp;MacroAssembler::atomic_xchgal;
3329     add = &amp;MacroAssembler::atomic_addal;
3330     break;
<span class="line-modified">3331   case T_INLINE_TYPE:</span>
3332   case T_OBJECT:
3333   case T_ARRAY:
3334     if (UseCompressedOops) {
3335       xchg = &amp;MacroAssembler::atomic_xchgalw;
3336       add = &amp;MacroAssembler::atomic_addalw;
3337     } else {
3338       xchg = &amp;MacroAssembler::atomic_xchgal;
3339       add = &amp;MacroAssembler::atomic_addal;
3340     }
3341     break;
3342   default:
3343     ShouldNotReachHere();
3344     xchg = &amp;MacroAssembler::atomic_xchgal;
3345     add = &amp;MacroAssembler::atomic_addal; // unreachable
3346   }
3347 
3348   switch (code) {
3349   case lir_xadd:
3350     {
3351       RegisterOrConstant inc;
</pre>
</td>
</tr>
</table>
<center><a href="abstractInterpreter_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
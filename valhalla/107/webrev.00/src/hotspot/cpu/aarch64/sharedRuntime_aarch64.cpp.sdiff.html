<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 274     case T_SHORT:
 275     case T_INT:
 276       if (int_args &lt; Argument::n_int_register_parameters_j) {
 277         regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 278       } else {
 279         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 280         stk_args += 2;
 281       }
 282       break;
 283     case T_VOID:
 284       // halves of T_LONG or T_DOUBLE
 285       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 286       regs[i].set_bad();
 287       break;
 288     case T_LONG:
 289       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 290       // fall through
 291     case T_OBJECT:
 292     case T_ARRAY:
 293     case T_ADDRESS:
<span class="line-modified"> 294     case T_VALUETYPE:</span>
 295       if (int_args &lt; Argument::n_int_register_parameters_j) {
 296         regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 297       } else {
 298         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 299         stk_args += 2;
 300       }
 301       break;
 302     case T_FLOAT:
 303       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 304         regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 305       } else {
 306         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 307         stk_args += 2;
 308       }
 309       break;
 310     case T_DOUBLE:
 311       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 312       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 313         regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 314       } else {
</pre>
<hr />
<pre>
 358         regs[i].set1(INT_ArgReg[int_args]-&gt;as_VMReg());
 359         int_args ++;
 360       } else {
 361         // Should we have gurantee here?
 362         return -1;
 363       }
 364       break;
 365     case T_VOID:
 366       // halves of T_LONG or T_DOUBLE
 367       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 368       regs[i].set_bad();
 369       break;
 370     case T_LONG:
 371       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 372       // fall through
 373     case T_OBJECT:
 374     case T_ARRAY:
 375     case T_ADDRESS:
 376       // Should T_METADATA be added to java_calling_convention as well ?
 377     case T_METADATA:
<span class="line-modified"> 378     case T_VALUETYPE:</span>
 379       if (int_args &lt; SharedRuntime::java_return_convention_max_int) {
 380         regs[i].set2(INT_ArgReg[int_args]-&gt;as_VMReg());
 381         int_args ++;
 382       } else {
 383         return -1;
 384       }
 385       break;
 386     case T_FLOAT:
 387       if (fp_args &lt; SharedRuntime::java_return_convention_max_float) {
 388         regs[i].set1(FP_ArgReg[fp_args]-&gt;as_VMReg());
 389         fp_args ++;
 390       } else {
 391         return -1;
 392       }
 393       break;
 394     case T_DOUBLE:
 395       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 396       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 397         regs[i].set2(FP_ArgReg[fp_args]-&gt;as_VMReg());
 398         fp_args ++;
</pre>
<hr />
<pre>
 433   __ blr(rscratch1);
 434   __ maybe_isb();
 435 
 436   __ pop_CPU_state();
 437   // restore sp
 438   __ leave();
 439   __ bind(L);
 440 }
 441 
 442 // For each value type argument, sig includes the list of fields of
 443 // the value type. This utility function computes the number of
 444 // arguments for the call if value types are passed by reference (the
 445 // calling convention the interpreter expects).
 446 static int compute_total_args_passed_int(const GrowableArray&lt;SigEntry&gt;* sig_extended) {
 447   int total_args_passed = 0;
 448   if (InlineTypePassFieldsAsArgs) {
 449      for (int i = 0; i &lt; sig_extended-&gt;length(); i++) {
 450        BasicType bt = sig_extended-&gt;at(i)._bt;
 451        if (SigEntry::is_reserved_entry(sig_extended, i)) {
 452          // Ignore reserved entry
<span class="line-modified"> 453        } else if (bt == T_VALUETYPE) {</span>
 454          // In sig_extended, a value type argument starts with:
<span class="line-modified"> 455          // T_VALUETYPE, followed by the types of the fields of the</span>
 456          // value type and T_VOID to mark the end of the value
 457          // type. Value types are flattened so, for instance, in the
 458          // case of a value type with an int field and a value type
 459          // field that itself has 2 fields, an int and a long:
<span class="line-modified"> 460          // T_VALUETYPE T_INT T_VALUETYPE T_INT T_LONG T_VOID (second</span>
<span class="line-modified"> 461          // slot for the T_LONG) T_VOID (inner T_VALUETYPE) T_VOID</span>
<span class="line-modified"> 462          // (outer T_VALUETYPE)</span>
 463          total_args_passed++;
 464          int vt = 1;
 465          do {
 466            i++;
 467            BasicType bt = sig_extended-&gt;at(i)._bt;
 468            BasicType prev_bt = sig_extended-&gt;at(i-1)._bt;
<span class="line-modified"> 469            if (bt == T_VALUETYPE) {</span>
 470              vt++;
 471            } else if (bt == T_VOID &amp;&amp;
 472                       prev_bt != T_LONG &amp;&amp;
 473                       prev_bt != T_DOUBLE) {
 474              vt--;
 475            }
 476          } while (vt != 0);
 477        } else {
 478          total_args_passed++;
 479        }
 480      }
 481   } else {
 482     total_args_passed = sig_extended-&gt;length();
 483   }
 484 
 485   return total_args_passed;
 486 }
 487 
 488 
 489 static void gen_c2i_adapter_helper(MacroAssembler* masm, BasicType bt, const VMRegPair&amp; reg_pair, int extraspace, const Address&amp; to) {
 490 
<span class="line-modified"> 491     assert(bt != T_VALUETYPE || !InlineTypePassFieldsAsArgs, &quot;no inline type here&quot;);</span>
 492 
 493     // Say 4 args:
 494     // i   st_off
 495     // 0   32 T_LONG
 496     // 1   24 T_VOID
 497     // 2   16 T_OBJECT
 498     // 3    8 T_BOOL
 499     // -    0 return address
 500     //
 501     // However to make thing extra confusing. Because we can fit a long/double in
 502     // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
 503     // leaves one slot empty and only stores to a single slot. In this case the
 504     // slot that is occupied is the T_VOID slot. See I said it was confusing.
 505 
 506     // int next_off = st_off - Interpreter::stackElementSize;
 507 
 508     VMReg r_1 = reg_pair.first();
 509     VMReg r_2 = reg_pair.second();
 510 
 511     if (!r_1-&gt;is_valid()) {
</pre>
<hr />
<pre>
 547                             address start,
 548                             OopMapSet* oop_maps,
 549                             int&amp; frame_complete,
 550                             int&amp; frame_size_in_words,
 551                             bool alloc_value_receiver) {
 552 
 553   // Before we get into the guts of the C2I adapter, see if we should be here
 554   // at all.  We&#39;ve come from compiled code and are attempting to jump to the
 555   // interpreter, which means the caller made a static call to get here
 556   // (vcalls always get a compiled target if there is one).  Check for a
 557   // compiled target.  If there is one, we need to patch the caller&#39;s call.
 558   patch_callers_callsite(masm);
 559 
 560   __ bind(skip_fixup);
 561 
 562   bool has_value_argument = false;
 563 
 564   if (InlineTypePassFieldsAsArgs) {
 565       // Is there an inline type argument?
 566      for (int i = 0; i &lt; sig_extended-&gt;length() &amp;&amp; !has_value_argument; i++) {
<span class="line-modified"> 567        has_value_argument = (sig_extended-&gt;at(i)._bt == T_VALUETYPE);</span>
 568      }
 569      if (has_value_argument) {
 570       // There is at least a value type argument: we&#39;re coming from
 571       // compiled code so we have no buffers to back the value
 572       // types. Allocate the buffers here with a runtime call.
 573       OopMap* map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
 574 
 575       frame_complete = __ offset();
 576       address the_pc = __ pc();
 577 
 578       __ set_last_Java_frame(noreg, noreg, the_pc, rscratch1);
 579 
 580       __ mov(c_rarg0, rthread);
 581       __ mov(c_rarg1, r1);
 582       __ mov(c_rarg2, (int64_t)alloc_value_receiver);
 583 
 584       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::allocate_value_types)));
 585       __ blr(rscratch1);
 586 
 587       oop_maps-&gt;add_gc_map((int)(__ pc() - start), map);
</pre>
<hr />
<pre>
 614   int extraspace = (total_args_passed * Interpreter::stackElementSize) + wordSize;
 615 
 616   // stack is aligned, keep it that way
 617   extraspace = align_up(extraspace, 2 * wordSize);
 618 
 619   __ mov(r13, sp);
 620 
 621   if (extraspace)
 622     __ sub(sp, sp, extraspace);
 623 
 624   // Now write the args into the outgoing interpreter space
 625 
 626   int ignored = 0, next_vt_arg = 0, next_arg_int = 0;
 627   bool has_oop_field = false;
 628 
 629   for (int next_arg_comp = 0; next_arg_comp &lt; total_args_passed; next_arg_comp++) {
 630     BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 631     // offset to start parameters
 632     int st_off   = (total_args_passed - next_arg_int - 1) * Interpreter::stackElementSize;
 633 
<span class="line-modified"> 634     if (!InlineTypePassFieldsAsArgs || bt != T_VALUETYPE) {</span>
 635 
 636             if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 637                continue; // Ignore reserved entry
 638             }
 639 
 640             if (bt == T_VOID) {
 641                assert(next_arg_comp &gt; 0 &amp;&amp; (sig_extended-&gt;at(next_arg_comp - 1)._bt == T_LONG || sig_extended-&gt;at(next_arg_comp - 1)._bt == T_DOUBLE), &quot;missing half&quot;);
 642                next_arg_int ++;
 643                continue;
 644              }
 645 
 646              int next_off = st_off - Interpreter::stackElementSize;
 647              int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;
 648 
 649              gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp], extraspace, Address(sp, offset));
 650              next_arg_int ++;
 651    } else {
 652        ignored++;
 653       // get the buffer from the just allocated pool of buffers
<span class="line-modified"> 654       int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_VALUETYPE);</span>
 655       __ load_heap_oop(rscratch1, Address(r10, index));
 656       next_vt_arg++;
 657       next_arg_int++;
 658       int vt = 1;
 659       // write fields we get from compiled code in registers/stack
 660       // slots to the buffer: we know we are done with that value type
 661       // argument when we hit the T_VOID that acts as an end of value
 662       // type delimiter for this value type. Value types are flattened
 663       // so we might encounter embedded value types. Each entry in
 664       // sig_extended contains a field offset in the buffer.
 665       do {
 666         next_arg_comp++;
 667         BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 668         BasicType prev_bt = sig_extended-&gt;at(next_arg_comp - 1)._bt;
<span class="line-modified"> 669         if (bt == T_VALUETYPE) {</span>
 670           vt++;
 671           ignored++;
 672         } else if (bt == T_VOID &amp;&amp; prev_bt != T_LONG &amp;&amp; prev_bt != T_DOUBLE) {
 673           vt--;
 674           ignored++;
 675         } else if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 676           // Ignore reserved entry
 677         } else {
 678           int off = sig_extended-&gt;at(next_arg_comp)._offset;
 679           assert(off &gt; 0, &quot;offset in object should be positive&quot;);
 680 
 681           bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);
 682           has_oop_field = has_oop_field || is_oop;
 683 
 684           gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp - ignored], extraspace, Address(r11, off));
 685         }
 686       } while (vt != 0);
 687       // pass the buffer to the interpreter
 688       __ str(rscratch1, Address(sp, st_off));
 689    }
</pre>
<hr />
<pre>
 786   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_offset())));
 787 
 788 #if INCLUDE_JVMCI
 789   if (EnableJVMCI || UseAOT) {
 790     // check if this call should be routed towards a specific entry point
 791     __ ldr(rscratch2, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 792     Label no_alternative_target;
 793     __ cbz(rscratch2, no_alternative_target);
 794     __ mov(rscratch1, rscratch2);
 795     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 796     __ bind(no_alternative_target);
 797   }
 798 #endif // INCLUDE_JVMCI
 799 
 800   int total_args_passed = sig-&gt;length();
 801 
 802   // Now generate the shuffle code.
 803   for (int i = 0; i &lt; total_args_passed; i++) {
 804     BasicType bt = sig-&gt;at(i)._bt;
 805 
<span class="line-modified"> 806     assert(bt != T_VALUETYPE, &quot;i2c adapter doesn&#39;t unpack value args&quot;);</span>
 807     if (bt == T_VOID) {
 808       assert(i &gt; 0 &amp;&amp; (sig-&gt;at(i - 1)._bt == T_LONG || sig-&gt;at(i - 1)._bt == T_DOUBLE), &quot;missing half&quot;);
 809       continue;
 810     }
 811 
 812     // Pick up 0, 1 or 2 words from SP+offset.
 813     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(), &quot;scrambled load targets?&quot;);
 814 
 815     // Load in argument order going down.
 816     int ld_off = (total_args_passed - i - 1) * Interpreter::stackElementSize;
 817     // Point to interpreter value (vs. tag)
 818     int next_off = ld_off - Interpreter::stackElementSize;
 819     //
 820     //
 821     //
 822     VMReg r_1 = regs[i].first();
 823     VMReg r_2 = regs[i].second();
 824     if (!r_1-&gt;is_valid()) {
 825       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 826       continue;
</pre>
<hr />
<pre>
1040 
1041     for (int i = 0; i &lt; total_args_passed; i++) {
1042       switch (sig_bt[i]) {
1043       case T_BOOLEAN:
1044       case T_CHAR:
1045       case T_BYTE:
1046       case T_SHORT:
1047       case T_INT:
1048         if (int_args &lt; Argument::n_int_register_parameters_c) {
1049           regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
1050         } else {
1051           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1052           stk_args += 2;
1053         }
1054         break;
1055       case T_LONG:
1056         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1057         // fall through
1058       case T_OBJECT:
1059       case T_ARRAY:
<span class="line-modified">1060       case T_VALUETYPE:</span>
1061       case T_ADDRESS:
1062       case T_METADATA:
1063         if (int_args &lt; Argument::n_int_register_parameters_c) {
1064           regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
1065         } else {
1066           regs[i].set2(VMRegImpl::stack2reg(stk_args));
1067           stk_args += 2;
1068         }
1069         break;
1070       case T_FLOAT:
1071         if (fp_args &lt; Argument::n_float_register_parameters_c) {
1072           regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
1073         } else {
1074           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1075           stk_args += 2;
1076         }
1077         break;
1078       case T_DOUBLE:
1079         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1080         if (fp_args &lt; Argument::n_float_register_parameters_c) {
</pre>
<hr />
<pre>
1892       reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1893     } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1894       freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1895     }
1896 #endif /* ASSERT */
1897     switch (in_sig_bt[i]) {
1898       case T_ARRAY:
1899         if (is_critical_native) {
1900           unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
1901           c_arg++;
1902 #ifdef ASSERT
1903           if (out_regs[c_arg].first()-&gt;is_Register()) {
1904             reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1905           } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1906             freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1907           }
1908 #endif
1909           int_args++;
1910           break;
1911         }
<span class="line-modified">1912       case T_VALUETYPE:</span>
1913       case T_OBJECT:
1914         assert(!is_critical_native, &quot;no oop arguments&quot;);
1915         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
1916                     ((i == 0) &amp;&amp; (!is_static)),
1917                     &amp;receiver_offset);
1918         int_args++;
1919         break;
1920       case T_VOID:
1921         break;
1922 
1923       case T_FLOAT:
1924         float_move(masm, in_regs[i], out_regs[c_arg]);
1925         float_args++;
1926         break;
1927 
1928       case T_DOUBLE:
1929         assert( i + 1 &lt; total_in_args &amp;&amp;
1930                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
1931                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
1932         double_move(masm, in_regs[i], out_regs[c_arg]);
</pre>
<hr />
<pre>
2080 
2081   rt_call(masm, native_func);
2082 
2083   __ bind(native_return);
2084 
2085   intptr_t return_pc = (intptr_t) __ pc();
2086   oop_maps-&gt;add_gc_map(return_pc - start, map);
2087 
2088   // Unpack native results.
2089   switch (ret_type) {
2090   case T_BOOLEAN: __ c2bool(r0);                     break;
2091   case T_CHAR   : __ ubfx(r0, r0, 0, 16);            break;
2092   case T_BYTE   : __ sbfx(r0, r0, 0, 8);             break;
2093   case T_SHORT  : __ sbfx(r0, r0, 0, 16);            break;
2094   case T_INT    : __ sbfx(r0, r0, 0, 32);            break;
2095   case T_DOUBLE :
2096   case T_FLOAT  :
2097     // Result is in v0 we&#39;ll save as needed
2098     break;
2099   case T_ARRAY:                 // Really a handle
<span class="line-modified">2100   case T_VALUETYPE:</span>
2101   case T_OBJECT:                // Really a handle
2102       break; // can&#39;t de-handlize until after safepoint check
2103   case T_VOID: break;
2104   case T_LONG: break;
2105   default       : ShouldNotReachHere();
2106   }
2107 
2108   // Switch thread to &quot;native transition&quot; state before reading the synchronization state.
2109   // This additional state is necessary because reading and testing the synchronization
2110   // state is not atomic w.r.t. GC, as this scenario demonstrates:
2111   //     Java thread A, in _thread_in_native state, loads _not_synchronized and is preempted.
2112   //     VM thread changes sync state to synchronizing and suspends threads for GC.
2113   //     Thread A is resumed to finish this native method, but doesn&#39;t block here since it
2114   //     didn&#39;t see any synchronization is progress, and escapes.
2115   __ mov(rscratch1, _thread_in_native_trans);
2116 
2117   __ strw(rscratch1, Address(rthread, JavaThread::thread_state_offset()));
2118 
2119   // Force this write out before the read below
2120   __ dmb(Assembler::ISH);
</pre>
<hr />
<pre>
3325 }
3326 
3327 BufferedValueTypeBlob* SharedRuntime::generate_buffered_value_type_adapter(const ValueKlass* vk) {
3328   BufferBlob* buf = BufferBlob::create(&quot;value types pack/unpack&quot;, 16 * K);
3329   CodeBuffer buffer(buf);
3330   short buffer_locs[20];
3331   buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,
3332                                          sizeof(buffer_locs)/sizeof(relocInfo));
3333 
3334   MacroAssembler _masm(&amp;buffer);
3335   MacroAssembler* masm = &amp;_masm;
3336 
3337   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();
3338   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();
3339 
3340   int pack_fields_off = __ offset();
3341 
3342   int j = 1;
3343   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
3344     BasicType bt = sig_vk-&gt;at(i)._bt;
<span class="line-modified">3345     if (bt == T_VALUETYPE) {</span>
3346       continue;
3347     }
3348     if (bt == T_VOID) {
3349       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||
3350           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {
3351         j++;
3352       }
3353       continue;
3354     }
3355     int off = sig_vk-&gt;at(i)._offset;
3356     VMRegPair pair = regs-&gt;at(j);
3357     VMReg r_1 = pair.first();
3358     VMReg r_2 = pair.second();
3359     Address to(r0, off);
3360     if (bt == T_FLOAT) {
3361       __ strs(r_1-&gt;as_FloatRegister(), to);
3362     } else if (bt == T_DOUBLE) {
3363       __ strd(r_1-&gt;as_FloatRegister(), to);
3364     } else if (bt == T_OBJECT || bt == T_ARRAY) {
3365       Register val = r_1-&gt;as_Register();
</pre>
<hr />
<pre>
3372       } else {
3373         __ str(val, to);
3374       }
3375     } else {
3376       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);
3377       assert_different_registers(r0, r_1-&gt;as_Register());
3378       size_t size_in_bytes = type2aelembytes(bt);
3379       __ store_sized_value(to, r_1-&gt;as_Register(), size_in_bytes);
3380     }
3381     j++;
3382   }
3383   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
3384 
3385   __ ret(lr);
3386 
3387   int unpack_fields_off = __ offset();
3388 
3389   j = 1;
3390   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
3391     BasicType bt = sig_vk-&gt;at(i)._bt;
<span class="line-modified">3392     if (bt == T_VALUETYPE) {</span>
3393       continue;
3394     }
3395     if (bt == T_VOID) {
3396       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||
3397           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {
3398         j++;
3399       }
3400       continue;
3401     }
3402     int off = sig_vk-&gt;at(i)._offset;
3403     VMRegPair pair = regs-&gt;at(j);
3404     VMReg r_1 = pair.first();
3405     VMReg r_2 = pair.second();
3406     Address from(r0, off);
3407     if (bt == T_FLOAT) {
3408       __ ldrs(r_1-&gt;as_FloatRegister(), from);
3409     } else if (bt == T_DOUBLE) {
3410       __ ldrd(r_1-&gt;as_FloatRegister(), from);
3411     } else if (bt == T_OBJECT || bt == T_ARRAY) {
3412        assert_different_registers(r0, r_1-&gt;as_Register());
</pre>
</td>
<td>
<hr />
<pre>
 274     case T_SHORT:
 275     case T_INT:
 276       if (int_args &lt; Argument::n_int_register_parameters_j) {
 277         regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 278       } else {
 279         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 280         stk_args += 2;
 281       }
 282       break;
 283     case T_VOID:
 284       // halves of T_LONG or T_DOUBLE
 285       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 286       regs[i].set_bad();
 287       break;
 288     case T_LONG:
 289       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 290       // fall through
 291     case T_OBJECT:
 292     case T_ARRAY:
 293     case T_ADDRESS:
<span class="line-modified"> 294     case T_INLINE_TYPE:</span>
 295       if (int_args &lt; Argument::n_int_register_parameters_j) {
 296         regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 297       } else {
 298         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 299         stk_args += 2;
 300       }
 301       break;
 302     case T_FLOAT:
 303       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 304         regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 305       } else {
 306         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 307         stk_args += 2;
 308       }
 309       break;
 310     case T_DOUBLE:
 311       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 312       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 313         regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 314       } else {
</pre>
<hr />
<pre>
 358         regs[i].set1(INT_ArgReg[int_args]-&gt;as_VMReg());
 359         int_args ++;
 360       } else {
 361         // Should we have gurantee here?
 362         return -1;
 363       }
 364       break;
 365     case T_VOID:
 366       // halves of T_LONG or T_DOUBLE
 367       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 368       regs[i].set_bad();
 369       break;
 370     case T_LONG:
 371       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 372       // fall through
 373     case T_OBJECT:
 374     case T_ARRAY:
 375     case T_ADDRESS:
 376       // Should T_METADATA be added to java_calling_convention as well ?
 377     case T_METADATA:
<span class="line-modified"> 378     case T_INLINE_TYPE:</span>
 379       if (int_args &lt; SharedRuntime::java_return_convention_max_int) {
 380         regs[i].set2(INT_ArgReg[int_args]-&gt;as_VMReg());
 381         int_args ++;
 382       } else {
 383         return -1;
 384       }
 385       break;
 386     case T_FLOAT:
 387       if (fp_args &lt; SharedRuntime::java_return_convention_max_float) {
 388         regs[i].set1(FP_ArgReg[fp_args]-&gt;as_VMReg());
 389         fp_args ++;
 390       } else {
 391         return -1;
 392       }
 393       break;
 394     case T_DOUBLE:
 395       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 396       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 397         regs[i].set2(FP_ArgReg[fp_args]-&gt;as_VMReg());
 398         fp_args ++;
</pre>
<hr />
<pre>
 433   __ blr(rscratch1);
 434   __ maybe_isb();
 435 
 436   __ pop_CPU_state();
 437   // restore sp
 438   __ leave();
 439   __ bind(L);
 440 }
 441 
 442 // For each value type argument, sig includes the list of fields of
 443 // the value type. This utility function computes the number of
 444 // arguments for the call if value types are passed by reference (the
 445 // calling convention the interpreter expects).
 446 static int compute_total_args_passed_int(const GrowableArray&lt;SigEntry&gt;* sig_extended) {
 447   int total_args_passed = 0;
 448   if (InlineTypePassFieldsAsArgs) {
 449      for (int i = 0; i &lt; sig_extended-&gt;length(); i++) {
 450        BasicType bt = sig_extended-&gt;at(i)._bt;
 451        if (SigEntry::is_reserved_entry(sig_extended, i)) {
 452          // Ignore reserved entry
<span class="line-modified"> 453        } else if (bt == T_INLINE_TYPE) {</span>
 454          // In sig_extended, a value type argument starts with:
<span class="line-modified"> 455          // T_INLINE_TYPE, followed by the types of the fields of the</span>
 456          // value type and T_VOID to mark the end of the value
 457          // type. Value types are flattened so, for instance, in the
 458          // case of a value type with an int field and a value type
 459          // field that itself has 2 fields, an int and a long:
<span class="line-modified"> 460          // T_INLINE_TYPE T_INT T_INLINE_TYPE T_INT T_LONG T_VOID (second</span>
<span class="line-modified"> 461          // slot for the T_LONG) T_VOID (inner T_INLINE_TYPE) T_VOID</span>
<span class="line-modified"> 462          // (outer T_INLINE_TYPE)</span>
 463          total_args_passed++;
 464          int vt = 1;
 465          do {
 466            i++;
 467            BasicType bt = sig_extended-&gt;at(i)._bt;
 468            BasicType prev_bt = sig_extended-&gt;at(i-1)._bt;
<span class="line-modified"> 469            if (bt == T_INLINE_TYPE) {</span>
 470              vt++;
 471            } else if (bt == T_VOID &amp;&amp;
 472                       prev_bt != T_LONG &amp;&amp;
 473                       prev_bt != T_DOUBLE) {
 474              vt--;
 475            }
 476          } while (vt != 0);
 477        } else {
 478          total_args_passed++;
 479        }
 480      }
 481   } else {
 482     total_args_passed = sig_extended-&gt;length();
 483   }
 484 
 485   return total_args_passed;
 486 }
 487 
 488 
 489 static void gen_c2i_adapter_helper(MacroAssembler* masm, BasicType bt, const VMRegPair&amp; reg_pair, int extraspace, const Address&amp; to) {
 490 
<span class="line-modified"> 491     assert(bt != T_INLINE_TYPE || !InlineTypePassFieldsAsArgs, &quot;no inline type here&quot;);</span>
 492 
 493     // Say 4 args:
 494     // i   st_off
 495     // 0   32 T_LONG
 496     // 1   24 T_VOID
 497     // 2   16 T_OBJECT
 498     // 3    8 T_BOOL
 499     // -    0 return address
 500     //
 501     // However to make thing extra confusing. Because we can fit a long/double in
 502     // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
 503     // leaves one slot empty and only stores to a single slot. In this case the
 504     // slot that is occupied is the T_VOID slot. See I said it was confusing.
 505 
 506     // int next_off = st_off - Interpreter::stackElementSize;
 507 
 508     VMReg r_1 = reg_pair.first();
 509     VMReg r_2 = reg_pair.second();
 510 
 511     if (!r_1-&gt;is_valid()) {
</pre>
<hr />
<pre>
 547                             address start,
 548                             OopMapSet* oop_maps,
 549                             int&amp; frame_complete,
 550                             int&amp; frame_size_in_words,
 551                             bool alloc_value_receiver) {
 552 
 553   // Before we get into the guts of the C2I adapter, see if we should be here
 554   // at all.  We&#39;ve come from compiled code and are attempting to jump to the
 555   // interpreter, which means the caller made a static call to get here
 556   // (vcalls always get a compiled target if there is one).  Check for a
 557   // compiled target.  If there is one, we need to patch the caller&#39;s call.
 558   patch_callers_callsite(masm);
 559 
 560   __ bind(skip_fixup);
 561 
 562   bool has_value_argument = false;
 563 
 564   if (InlineTypePassFieldsAsArgs) {
 565       // Is there an inline type argument?
 566      for (int i = 0; i &lt; sig_extended-&gt;length() &amp;&amp; !has_value_argument; i++) {
<span class="line-modified"> 567        has_value_argument = (sig_extended-&gt;at(i)._bt == T_INLINE_TYPE);</span>
 568      }
 569      if (has_value_argument) {
 570       // There is at least a value type argument: we&#39;re coming from
 571       // compiled code so we have no buffers to back the value
 572       // types. Allocate the buffers here with a runtime call.
 573       OopMap* map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
 574 
 575       frame_complete = __ offset();
 576       address the_pc = __ pc();
 577 
 578       __ set_last_Java_frame(noreg, noreg, the_pc, rscratch1);
 579 
 580       __ mov(c_rarg0, rthread);
 581       __ mov(c_rarg1, r1);
 582       __ mov(c_rarg2, (int64_t)alloc_value_receiver);
 583 
 584       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::allocate_value_types)));
 585       __ blr(rscratch1);
 586 
 587       oop_maps-&gt;add_gc_map((int)(__ pc() - start), map);
</pre>
<hr />
<pre>
 614   int extraspace = (total_args_passed * Interpreter::stackElementSize) + wordSize;
 615 
 616   // stack is aligned, keep it that way
 617   extraspace = align_up(extraspace, 2 * wordSize);
 618 
 619   __ mov(r13, sp);
 620 
 621   if (extraspace)
 622     __ sub(sp, sp, extraspace);
 623 
 624   // Now write the args into the outgoing interpreter space
 625 
 626   int ignored = 0, next_vt_arg = 0, next_arg_int = 0;
 627   bool has_oop_field = false;
 628 
 629   for (int next_arg_comp = 0; next_arg_comp &lt; total_args_passed; next_arg_comp++) {
 630     BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 631     // offset to start parameters
 632     int st_off   = (total_args_passed - next_arg_int - 1) * Interpreter::stackElementSize;
 633 
<span class="line-modified"> 634     if (!InlineTypePassFieldsAsArgs || bt != T_INLINE_TYPE) {</span>
 635 
 636             if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 637                continue; // Ignore reserved entry
 638             }
 639 
 640             if (bt == T_VOID) {
 641                assert(next_arg_comp &gt; 0 &amp;&amp; (sig_extended-&gt;at(next_arg_comp - 1)._bt == T_LONG || sig_extended-&gt;at(next_arg_comp - 1)._bt == T_DOUBLE), &quot;missing half&quot;);
 642                next_arg_int ++;
 643                continue;
 644              }
 645 
 646              int next_off = st_off - Interpreter::stackElementSize;
 647              int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;
 648 
 649              gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp], extraspace, Address(sp, offset));
 650              next_arg_int ++;
 651    } else {
 652        ignored++;
 653       // get the buffer from the just allocated pool of buffers
<span class="line-modified"> 654       int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_INLINE_TYPE);</span>
 655       __ load_heap_oop(rscratch1, Address(r10, index));
 656       next_vt_arg++;
 657       next_arg_int++;
 658       int vt = 1;
 659       // write fields we get from compiled code in registers/stack
 660       // slots to the buffer: we know we are done with that value type
 661       // argument when we hit the T_VOID that acts as an end of value
 662       // type delimiter for this value type. Value types are flattened
 663       // so we might encounter embedded value types. Each entry in
 664       // sig_extended contains a field offset in the buffer.
 665       do {
 666         next_arg_comp++;
 667         BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 668         BasicType prev_bt = sig_extended-&gt;at(next_arg_comp - 1)._bt;
<span class="line-modified"> 669         if (bt == T_INLINE_TYPE) {</span>
 670           vt++;
 671           ignored++;
 672         } else if (bt == T_VOID &amp;&amp; prev_bt != T_LONG &amp;&amp; prev_bt != T_DOUBLE) {
 673           vt--;
 674           ignored++;
 675         } else if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 676           // Ignore reserved entry
 677         } else {
 678           int off = sig_extended-&gt;at(next_arg_comp)._offset;
 679           assert(off &gt; 0, &quot;offset in object should be positive&quot;);
 680 
 681           bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);
 682           has_oop_field = has_oop_field || is_oop;
 683 
 684           gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp - ignored], extraspace, Address(r11, off));
 685         }
 686       } while (vt != 0);
 687       // pass the buffer to the interpreter
 688       __ str(rscratch1, Address(sp, st_off));
 689    }
</pre>
<hr />
<pre>
 786   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_offset())));
 787 
 788 #if INCLUDE_JVMCI
 789   if (EnableJVMCI || UseAOT) {
 790     // check if this call should be routed towards a specific entry point
 791     __ ldr(rscratch2, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 792     Label no_alternative_target;
 793     __ cbz(rscratch2, no_alternative_target);
 794     __ mov(rscratch1, rscratch2);
 795     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 796     __ bind(no_alternative_target);
 797   }
 798 #endif // INCLUDE_JVMCI
 799 
 800   int total_args_passed = sig-&gt;length();
 801 
 802   // Now generate the shuffle code.
 803   for (int i = 0; i &lt; total_args_passed; i++) {
 804     BasicType bt = sig-&gt;at(i)._bt;
 805 
<span class="line-modified"> 806     assert(bt != T_INLINE_TYPE, &quot;i2c adapter doesn&#39;t unpack value args&quot;);</span>
 807     if (bt == T_VOID) {
 808       assert(i &gt; 0 &amp;&amp; (sig-&gt;at(i - 1)._bt == T_LONG || sig-&gt;at(i - 1)._bt == T_DOUBLE), &quot;missing half&quot;);
 809       continue;
 810     }
 811 
 812     // Pick up 0, 1 or 2 words from SP+offset.
 813     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(), &quot;scrambled load targets?&quot;);
 814 
 815     // Load in argument order going down.
 816     int ld_off = (total_args_passed - i - 1) * Interpreter::stackElementSize;
 817     // Point to interpreter value (vs. tag)
 818     int next_off = ld_off - Interpreter::stackElementSize;
 819     //
 820     //
 821     //
 822     VMReg r_1 = regs[i].first();
 823     VMReg r_2 = regs[i].second();
 824     if (!r_1-&gt;is_valid()) {
 825       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 826       continue;
</pre>
<hr />
<pre>
1040 
1041     for (int i = 0; i &lt; total_args_passed; i++) {
1042       switch (sig_bt[i]) {
1043       case T_BOOLEAN:
1044       case T_CHAR:
1045       case T_BYTE:
1046       case T_SHORT:
1047       case T_INT:
1048         if (int_args &lt; Argument::n_int_register_parameters_c) {
1049           regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
1050         } else {
1051           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1052           stk_args += 2;
1053         }
1054         break;
1055       case T_LONG:
1056         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1057         // fall through
1058       case T_OBJECT:
1059       case T_ARRAY:
<span class="line-modified">1060       case T_INLINE_TYPE:</span>
1061       case T_ADDRESS:
1062       case T_METADATA:
1063         if (int_args &lt; Argument::n_int_register_parameters_c) {
1064           regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
1065         } else {
1066           regs[i].set2(VMRegImpl::stack2reg(stk_args));
1067           stk_args += 2;
1068         }
1069         break;
1070       case T_FLOAT:
1071         if (fp_args &lt; Argument::n_float_register_parameters_c) {
1072           regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
1073         } else {
1074           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1075           stk_args += 2;
1076         }
1077         break;
1078       case T_DOUBLE:
1079         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1080         if (fp_args &lt; Argument::n_float_register_parameters_c) {
</pre>
<hr />
<pre>
1892       reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1893     } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1894       freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1895     }
1896 #endif /* ASSERT */
1897     switch (in_sig_bt[i]) {
1898       case T_ARRAY:
1899         if (is_critical_native) {
1900           unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
1901           c_arg++;
1902 #ifdef ASSERT
1903           if (out_regs[c_arg].first()-&gt;is_Register()) {
1904             reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1905           } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1906             freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1907           }
1908 #endif
1909           int_args++;
1910           break;
1911         }
<span class="line-modified">1912       case T_INLINE_TYPE:</span>
1913       case T_OBJECT:
1914         assert(!is_critical_native, &quot;no oop arguments&quot;);
1915         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
1916                     ((i == 0) &amp;&amp; (!is_static)),
1917                     &amp;receiver_offset);
1918         int_args++;
1919         break;
1920       case T_VOID:
1921         break;
1922 
1923       case T_FLOAT:
1924         float_move(masm, in_regs[i], out_regs[c_arg]);
1925         float_args++;
1926         break;
1927 
1928       case T_DOUBLE:
1929         assert( i + 1 &lt; total_in_args &amp;&amp;
1930                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
1931                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
1932         double_move(masm, in_regs[i], out_regs[c_arg]);
</pre>
<hr />
<pre>
2080 
2081   rt_call(masm, native_func);
2082 
2083   __ bind(native_return);
2084 
2085   intptr_t return_pc = (intptr_t) __ pc();
2086   oop_maps-&gt;add_gc_map(return_pc - start, map);
2087 
2088   // Unpack native results.
2089   switch (ret_type) {
2090   case T_BOOLEAN: __ c2bool(r0);                     break;
2091   case T_CHAR   : __ ubfx(r0, r0, 0, 16);            break;
2092   case T_BYTE   : __ sbfx(r0, r0, 0, 8);             break;
2093   case T_SHORT  : __ sbfx(r0, r0, 0, 16);            break;
2094   case T_INT    : __ sbfx(r0, r0, 0, 32);            break;
2095   case T_DOUBLE :
2096   case T_FLOAT  :
2097     // Result is in v0 we&#39;ll save as needed
2098     break;
2099   case T_ARRAY:                 // Really a handle
<span class="line-modified">2100   case T_INLINE_TYPE:</span>
2101   case T_OBJECT:                // Really a handle
2102       break; // can&#39;t de-handlize until after safepoint check
2103   case T_VOID: break;
2104   case T_LONG: break;
2105   default       : ShouldNotReachHere();
2106   }
2107 
2108   // Switch thread to &quot;native transition&quot; state before reading the synchronization state.
2109   // This additional state is necessary because reading and testing the synchronization
2110   // state is not atomic w.r.t. GC, as this scenario demonstrates:
2111   //     Java thread A, in _thread_in_native state, loads _not_synchronized and is preempted.
2112   //     VM thread changes sync state to synchronizing and suspends threads for GC.
2113   //     Thread A is resumed to finish this native method, but doesn&#39;t block here since it
2114   //     didn&#39;t see any synchronization is progress, and escapes.
2115   __ mov(rscratch1, _thread_in_native_trans);
2116 
2117   __ strw(rscratch1, Address(rthread, JavaThread::thread_state_offset()));
2118 
2119   // Force this write out before the read below
2120   __ dmb(Assembler::ISH);
</pre>
<hr />
<pre>
3325 }
3326 
3327 BufferedValueTypeBlob* SharedRuntime::generate_buffered_value_type_adapter(const ValueKlass* vk) {
3328   BufferBlob* buf = BufferBlob::create(&quot;value types pack/unpack&quot;, 16 * K);
3329   CodeBuffer buffer(buf);
3330   short buffer_locs[20];
3331   buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,
3332                                          sizeof(buffer_locs)/sizeof(relocInfo));
3333 
3334   MacroAssembler _masm(&amp;buffer);
3335   MacroAssembler* masm = &amp;_masm;
3336 
3337   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();
3338   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();
3339 
3340   int pack_fields_off = __ offset();
3341 
3342   int j = 1;
3343   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
3344     BasicType bt = sig_vk-&gt;at(i)._bt;
<span class="line-modified">3345     if (bt == T_INLINE_TYPE) {</span>
3346       continue;
3347     }
3348     if (bt == T_VOID) {
3349       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||
3350           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {
3351         j++;
3352       }
3353       continue;
3354     }
3355     int off = sig_vk-&gt;at(i)._offset;
3356     VMRegPair pair = regs-&gt;at(j);
3357     VMReg r_1 = pair.first();
3358     VMReg r_2 = pair.second();
3359     Address to(r0, off);
3360     if (bt == T_FLOAT) {
3361       __ strs(r_1-&gt;as_FloatRegister(), to);
3362     } else if (bt == T_DOUBLE) {
3363       __ strd(r_1-&gt;as_FloatRegister(), to);
3364     } else if (bt == T_OBJECT || bt == T_ARRAY) {
3365       Register val = r_1-&gt;as_Register();
</pre>
<hr />
<pre>
3372       } else {
3373         __ str(val, to);
3374       }
3375     } else {
3376       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);
3377       assert_different_registers(r0, r_1-&gt;as_Register());
3378       size_t size_in_bytes = type2aelembytes(bt);
3379       __ store_sized_value(to, r_1-&gt;as_Register(), size_in_bytes);
3380     }
3381     j++;
3382   }
3383   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
3384 
3385   __ ret(lr);
3386 
3387   int unpack_fields_off = __ offset();
3388 
3389   j = 1;
3390   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
3391     BasicType bt = sig_vk-&gt;at(i)._bt;
<span class="line-modified">3392     if (bt == T_INLINE_TYPE) {</span>
3393       continue;
3394     }
3395     if (bt == T_VOID) {
3396       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||
3397           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {
3398         j++;
3399       }
3400       continue;
3401     }
3402     int off = sig_vk-&gt;at(i)._offset;
3403     VMRegPair pair = regs-&gt;at(j);
3404     VMReg r_1 = pair.first();
3405     VMReg r_2 = pair.second();
3406     Address from(r0, off);
3407     if (bt == T_FLOAT) {
3408       __ ldrs(r_1-&gt;as_FloatRegister(), from);
3409     } else if (bt == T_DOUBLE) {
3410       __ ldrd(r_1-&gt;as_FloatRegister(), from);
3411     } else if (bt == T_OBJECT || bt == T_ARRAY) {
3412        assert_different_registers(r0, r_1-&gt;as_Register());
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
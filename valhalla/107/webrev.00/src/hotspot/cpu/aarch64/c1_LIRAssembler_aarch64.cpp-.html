<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;asm/assembler.hpp&quot;
  29 #include &quot;c1/c1_CodeStubs.hpp&quot;
  30 #include &quot;c1/c1_Compilation.hpp&quot;
  31 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  32 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  33 #include &quot;c1/c1_Runtime1.hpp&quot;
  34 #include &quot;c1/c1_ValueStack.hpp&quot;
  35 #include &quot;ci/ciArrayKlass.hpp&quot;
  36 #include &quot;ci/ciInstance.hpp&quot;
  37 #include &quot;ci/ciValueKlass.hpp&quot;
  38 #include &quot;code/compiledIC.hpp&quot;
  39 #include &quot;gc/shared/collectedHeap.hpp&quot;
  40 #include &quot;nativeInst_aarch64.hpp&quot;
  41 #include &quot;oops/objArrayKlass.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;runtime/frame.inline.hpp&quot;
  44 #include &quot;runtime/sharedRuntime.hpp&quot;
  45 #include &quot;utilities/powerOfTwo.hpp&quot;
  46 #include &quot;vmreg_aarch64.inline.hpp&quot;
  47 
  48 
  49 #ifndef PRODUCT
  50 #define COMMENT(x)   do { __ block_comment(x); } while (0)
  51 #else
  52 #define COMMENT(x)
  53 #endif
  54 
  55 NEEDS_CLEANUP // remove this definitions ?
  56 const Register IC_Klass    = rscratch2;   // where the IC klass is cached
  57 const Register SYNC_header = r0;   // synchronization header
  58 const Register SHIFT_count = r0;   // where count for shift operations must be
  59 
  60 #define __ _masm-&gt;
  61 
  62 
  63 static void select_different_registers(Register preserve,
  64                                        Register extra,
  65                                        Register &amp;tmp1,
  66                                        Register &amp;tmp2) {
  67   if (tmp1 == preserve) {
  68     assert_different_registers(tmp1, tmp2, extra);
  69     tmp1 = extra;
  70   } else if (tmp2 == preserve) {
  71     assert_different_registers(tmp1, tmp2, extra);
  72     tmp2 = extra;
  73   }
  74   assert_different_registers(preserve, tmp1, tmp2);
  75 }
  76 
  77 
  78 
  79 static void select_different_registers(Register preserve,
  80                                        Register extra,
  81                                        Register &amp;tmp1,
  82                                        Register &amp;tmp2,
  83                                        Register &amp;tmp3) {
  84   if (tmp1 == preserve) {
  85     assert_different_registers(tmp1, tmp2, tmp3, extra);
  86     tmp1 = extra;
  87   } else if (tmp2 == preserve) {
  88     assert_different_registers(tmp1, tmp2, tmp3, extra);
  89     tmp2 = extra;
  90   } else if (tmp3 == preserve) {
  91     assert_different_registers(tmp1, tmp2, tmp3, extra);
  92     tmp3 = extra;
  93   }
  94   assert_different_registers(preserve, tmp1, tmp2, tmp3);
  95 }
  96 
  97 
  98 bool LIR_Assembler::is_small_constant(LIR_Opr opr) { Unimplemented(); return false; }
  99 
 100 
 101 LIR_Opr LIR_Assembler::receiverOpr() {
 102   return FrameMap::receiver_opr;
 103 }
 104 
 105 LIR_Opr LIR_Assembler::osrBufferPointer() {
 106   return FrameMap::as_pointer_opr(receiverOpr()-&gt;as_register());
 107 }
 108 
 109 //--------------fpu register translations-----------------------
 110 
 111 
 112 address LIR_Assembler::float_constant(float f) {
 113   address const_addr = __ float_constant(f);
 114   if (const_addr == NULL) {
 115     bailout(&quot;const section overflow&quot;);
 116     return __ code()-&gt;consts()-&gt;start();
 117   } else {
 118     return const_addr;
 119   }
 120 }
 121 
 122 
 123 address LIR_Assembler::double_constant(double d) {
 124   address const_addr = __ double_constant(d);
 125   if (const_addr == NULL) {
 126     bailout(&quot;const section overflow&quot;);
 127     return __ code()-&gt;consts()-&gt;start();
 128   } else {
 129     return const_addr;
 130   }
 131 }
 132 
 133 address LIR_Assembler::int_constant(jlong n) {
 134   address const_addr = __ long_constant(n);
 135   if (const_addr == NULL) {
 136     bailout(&quot;const section overflow&quot;);
 137     return __ code()-&gt;consts()-&gt;start();
 138   } else {
 139     return const_addr;
 140   }
 141 }
 142 
 143 void LIR_Assembler::breakpoint() { Unimplemented(); }
 144 
 145 void LIR_Assembler::push(LIR_Opr opr) { Unimplemented(); }
 146 
 147 void LIR_Assembler::pop(LIR_Opr opr) { Unimplemented(); }
 148 
 149 bool LIR_Assembler::is_literal_address(LIR_Address* addr) { Unimplemented(); return false; }
 150 //-------------------------------------------
 151 
 152 static Register as_reg(LIR_Opr op) {
 153   return op-&gt;is_double_cpu() ? op-&gt;as_register_lo() : op-&gt;as_register();
 154 }
 155 
 156 static jlong as_long(LIR_Opr data) {
 157   jlong result;
 158   switch (data-&gt;type()) {
 159   case T_INT:
 160     result = (data-&gt;as_jint());
 161     break;
 162   case T_LONG:
 163     result = (data-&gt;as_jlong());
 164     break;
 165   default:
 166     ShouldNotReachHere();
 167     result = 0;  // unreachable
 168   }
 169   return result;
 170 }
 171 
 172 Address LIR_Assembler::as_Address(LIR_Address* addr, Register tmp) {
 173   Register base = addr-&gt;base()-&gt;as_pointer_register();
 174   LIR_Opr opr = addr-&gt;index();
 175   if (opr-&gt;is_cpu_register()) {
 176     Register index;
 177     if (opr-&gt;is_single_cpu())
 178       index = opr-&gt;as_register();
 179     else
 180       index = opr-&gt;as_register_lo();
 181     assert(addr-&gt;disp() == 0, &quot;must be&quot;);
 182     switch(opr-&gt;type()) {
 183       case T_INT:
 184         return Address(base, index, Address::sxtw(addr-&gt;scale()));
 185       case T_LONG:
 186         return Address(base, index, Address::lsl(addr-&gt;scale()));
 187       default:
 188         ShouldNotReachHere();
 189       }
 190   } else  {
 191     intptr_t addr_offset = intptr_t(addr-&gt;disp());
 192     if (Address::offset_ok_for_immed(addr_offset, addr-&gt;scale()))
 193       return Address(base, addr_offset, Address::lsl(addr-&gt;scale()));
 194     else {
 195       __ mov(tmp, addr_offset);
 196       return Address(base, tmp, Address::lsl(addr-&gt;scale()));
 197     }
 198   }
 199   return Address();
 200 }
 201 
 202 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
 203   ShouldNotReachHere();
 204   return Address();
 205 }
 206 
 207 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 208   return as_Address(addr, rscratch1);
 209 }
 210 
 211 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 212   return as_Address(addr, rscratch1);  // Ouch
 213   // FIXME: This needs to be much more clever.  See x86.
 214 }
 215 
 216 
 217 void LIR_Assembler::osr_entry() {
 218   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 219   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 220   ValueStack* entry_state = osr_entry-&gt;state();
 221   int number_of_locks = entry_state-&gt;locks_size();
 222 
 223   // we jump here if osr happens with the interpreter
 224   // state set up to continue at the beginning of the
 225   // loop that triggered osr - in particular, we have
 226   // the following registers setup:
 227   //
 228   // r2: osr buffer
 229   //
 230 
 231   // build frame
 232   ciMethod* m = compilation()-&gt;method();
 233   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes(), needs_stack_repair(), NULL);
 234 
 235   // OSR buffer is
 236   //
 237   // locals[nlocals-1..0]
 238   // monitors[0..number_of_locks]
 239   //
 240   // locals is a direct copy of the interpreter frame so in the osr buffer
 241   // so first slot in the local array is the last local from the interpreter
 242   // and last slot is local[0] (receiver) from the interpreter
 243   //
 244   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 245   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 246   // in the interpreter frame (the method lock if a sync method)
 247 
 248   // Initialize monitors in the compiled activation.
 249   //   r2: pointer to osr buffer
 250   //
 251   // All other registers are dead at this point and the locals will be
 252   // copied into place by code emitted in the IR.
 253 
 254   Register OSR_buf = osrBufferPointer()-&gt;as_pointer_register();
 255   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 256     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 257       (2 * BytesPerWord) * (number_of_locks - 1);
 258     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 259     // the OSR buffer using 2 word entries: first the lock and then
 260     // the oop.
 261     for (int i = 0; i &lt; number_of_locks; i++) {
 262       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 263 #ifdef ASSERT
 264       // verify the interpreter&#39;s monitor has a non-null object
 265       {
 266         Label L;
 267         __ ldr(rscratch1, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 268         __ cbnz(rscratch1, L);
 269         __ stop(&quot;locked object is NULL&quot;);
 270         __ bind(L);
 271       }
 272 #endif
 273       __ ldr(r19, Address(OSR_buf, slot_offset + 0));
 274       __ str(r19, frame_map()-&gt;address_for_monitor_lock(i));
 275       __ ldr(r19, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 276       __ str(r19, frame_map()-&gt;address_for_monitor_object(i));
 277     }
 278   }
 279 }
 280 
 281 
 282 // inline cache check; done before the frame is built.
 283 int LIR_Assembler::check_icache() {
 284   Register receiver = FrameMap::receiver_opr-&gt;as_register();
 285   Register ic_klass = IC_Klass;
 286   int start_offset = __ offset();
 287   __ inline_cache_check(receiver, ic_klass);
 288 
 289   // if icache check fails, then jump to runtime routine
 290   // Note: RECEIVER must still contain the receiver!
 291   Label dont;
 292   __ br(Assembler::EQ, dont);
 293   __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 294 
 295   // We align the verified entry point unless the method body
 296   // (including its inline cache check) will fit in a single 64-byte
 297   // icache line.
 298   if (! method()-&gt;is_accessor() || __ offset() - start_offset &gt; 4 * 4) {
 299     // force alignment after the cache check.
 300     __ align(CodeEntryAlignment);
 301   }
 302 
 303   __ bind(dont);
 304   return start_offset;
 305 }
 306 
 307 void LIR_Assembler::clinit_barrier(ciMethod* method) {
 308   assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
 309   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 310 
 311   Label L_skip_barrier;
 312 
 313   __ mov_metadata(rscratch2, method-&gt;holder()-&gt;constant_encoding());
 314   __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier /*L_fast_path*/);
 315   __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
 316   __ bind(L_skip_barrier);
 317 }
 318 
 319 void LIR_Assembler::jobject2reg(jobject o, Register reg) {
 320   if (o == NULL) {
 321     __ mov(reg, zr);
 322   } else {
 323     __ movoop(reg, o, /*immediate*/true);
 324   }
 325 }
 326 
 327 void LIR_Assembler::deoptimize_trap(CodeEmitInfo *info) {
 328   address target = NULL;
 329   relocInfo::relocType reloc_type = relocInfo::none;
 330 
 331   switch (patching_id(info)) {
 332   case PatchingStub::access_field_id:
 333     target = Runtime1::entry_for(Runtime1::access_field_patching_id);
 334     reloc_type = relocInfo::section_word_type;
 335     break;
 336   case PatchingStub::load_klass_id:
 337     target = Runtime1::entry_for(Runtime1::load_klass_patching_id);
 338     reloc_type = relocInfo::metadata_type;
 339     break;
 340   case PatchingStub::load_mirror_id:
 341     target = Runtime1::entry_for(Runtime1::load_mirror_patching_id);
 342     reloc_type = relocInfo::oop_type;
 343     break;
 344   case PatchingStub::load_appendix_id:
 345     target = Runtime1::entry_for(Runtime1::load_appendix_patching_id);
 346     reloc_type = relocInfo::oop_type;
 347     break;
 348   default: ShouldNotReachHere();
 349   }
 350 
 351   __ far_call(RuntimeAddress(target));
 352   add_call_info_here(info);
 353 }
 354 
 355 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo *info) {
 356   deoptimize_trap(info);
 357 }
 358 
 359 
 360 // This specifies the rsp decrement needed to build the frame
 361 int LIR_Assembler::initial_frame_size_in_bytes() const {
 362   // if rounding, must let FrameMap know!
 363 
 364   // The frame_map records size in slots (32bit word)
 365 
 366   // subtract two words to account for return address and link
 367   return (frame_map()-&gt;framesize() - (2*VMRegImpl::slots_per_word))  * VMRegImpl::stack_slot_size;
 368 }
 369 
 370 
 371 int LIR_Assembler::emit_exception_handler() {
 372   // if the last instruction is a call (typically to do a throw which
 373   // is coming at the end after block reordering) the return address
 374   // must still point into the code area in order to avoid assertion
 375   // failures when searching for the corresponding bci =&gt; add a nop
 376   // (was bug 5/14/1999 - gri)
 377   __ nop();
 378 
 379   // generate code for exception handler
 380   address handler_base = __ start_a_stub(exception_handler_size());
 381   if (handler_base == NULL) {
 382     // not enough space left for the handler
 383     bailout(&quot;exception handler overflow&quot;);
 384     return -1;
 385   }
 386 
 387   int offset = code_offset();
 388 
 389   // the exception oop and pc are in r0, and r3
 390   // no other registers need to be preserved, so invalidate them
 391   __ invalidate_registers(false, true, true, false, true, true);
 392 
 393   // check that there is really an exception
 394   __ verify_not_null_oop(r0);
 395 
 396   // search an exception handler (r0: exception oop, r3: throwing pc)
 397   __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id)));  __ should_not_reach_here();
 398   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 399   __ end_a_stub();
 400 
 401   return offset;
 402 }
 403 
 404 
 405 // Emit the code to remove the frame from the stack in the exception
 406 // unwind path.
 407 int LIR_Assembler::emit_unwind_handler() {
 408 #ifndef PRODUCT
 409   if (CommentedAssembly) {
 410     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 411   }
 412 #endif
 413 
 414   int offset = code_offset();
 415 
 416   // Fetch the exception from TLS and clear out exception related thread state
 417   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
 418   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
 419   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
 420 
 421   __ bind(_unwind_handler_entry);
 422   __ verify_not_null_oop(r0);
 423   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 424     __ mov(r19, r0);  // Preserve the exception
 425   }
 426 
 427   // Preform needed unlocking
 428   MonitorExitStub* stub = NULL;
 429   if (method()-&gt;is_synchronized()) {
 430     monitor_address(0, FrameMap::r0_opr);
 431     stub = new MonitorExitStub(FrameMap::r0_opr, true, 0);
 432     __ unlock_object(r5, r4, r0, *stub-&gt;entry());
 433     __ bind(*stub-&gt;continuation());
 434   }
 435 
 436   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 437     __ mov(c_rarg0, rthread);
 438     __ mov_metadata(c_rarg1, method()-&gt;constant_encoding());
 439     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), c_rarg0, c_rarg1);
 440   }
 441 
 442   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 443     __ mov(r0, r19);  // Restore the exception
 444   }
 445 
 446   // remove the activation and dispatch to the unwind handler
 447   __ block_comment(&quot;remove_frame and dispatch to the unwind handler&quot;);
 448   __ remove_frame(initial_frame_size_in_bytes(), needs_stack_repair());
 449   __ far_jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
 450 
 451   // Emit the slow path assembly
 452   if (stub != NULL) {
 453     stub-&gt;emit_code(this);
 454   }
 455 
 456   return offset;
 457 }
 458 
 459 
 460 int LIR_Assembler::emit_deopt_handler() {
 461   // if the last instruction is a call (typically to do a throw which
 462   // is coming at the end after block reordering) the return address
 463   // must still point into the code area in order to avoid assertion
 464   // failures when searching for the corresponding bci =&gt; add a nop
 465   // (was bug 5/14/1999 - gri)
 466   __ nop();
 467 
 468   // generate code for exception handler
 469   address handler_base = __ start_a_stub(deopt_handler_size());
 470   if (handler_base == NULL) {
 471     // not enough space left for the handler
 472     bailout(&quot;deopt handler overflow&quot;);
 473     return -1;
 474   }
 475 
 476   int offset = code_offset();
 477 
 478   __ adr(lr, pc());
 479   __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()-&gt;unpack()));
 480   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 481   __ end_a_stub();
 482 
 483   return offset;
 484 }
 485 
 486 void LIR_Assembler::add_debug_info_for_branch(address adr, CodeEmitInfo* info) {
 487   _masm-&gt;code_section()-&gt;relocate(adr, relocInfo::poll_type);
 488   int pc_offset = code_offset();
 489   flush_debug_info(pc_offset);
 490   info-&gt;record_debug_info(compilation()-&gt;debug_info_recorder(), pc_offset);
 491   if (info-&gt;exception_handlers() != NULL) {
 492     compilation()-&gt;add_exception_handlers_for_pco(pc_offset, info-&gt;exception_handlers());
 493   }
 494 }
 495 
 496 void LIR_Assembler::return_op(LIR_Opr result) {
 497   assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == r0, &quot;word returns are in r0,&quot;);
 498 
 499   ciMethod* method = compilation()-&gt;method();
 500 
 501   if (InlineTypeReturnedAsFields &amp;&amp; method-&gt;signature()-&gt;returns_never_null()) {
 502     ciType* return_type = method-&gt;return_type();
 503     if (return_type-&gt;is_valuetype()) {
 504       ciValueKlass* vk = return_type-&gt;as_value_klass();
 505       if (vk-&gt;can_be_returned_as_fields()) {
 506         address unpack_handler = vk-&gt;unpack_handler();
 507         assert(unpack_handler != NULL, &quot;must be&quot;);
 508         __ far_call(RuntimeAddress(unpack_handler));
 509         // At this point, rax points to the value object (for interpreter or C1 caller).
 510         // The fields of the object are copied into registers (for C2 caller).
 511       }
 512     }
 513   }
 514 
 515   // Pop the stack before the safepoint code
 516   __ remove_frame(initial_frame_size_in_bytes(), needs_stack_repair());
 517 
 518   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 519     __ reserved_stack_check();
 520   }
 521 
 522   __ fetch_and_read_polling_page(rscratch1, relocInfo::poll_return_type);
 523   __ ret(lr);
 524 }
 525 
 526 int LIR_Assembler::store_value_type_fields_to_buf(ciValueKlass* vk) {
 527   return (__ store_value_type_fields_to_buf(vk, false));
 528 }
 529 
 530 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 531   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 532   __ get_polling_page(rscratch1, relocInfo::poll_type);
 533   add_debug_info_for_branch(info);  // This isn&#39;t just debug info:
 534                                     // it&#39;s the oop map
 535   __ read_polling_page(rscratch1, relocInfo::poll_type);
 536   return __ offset();
 537 }
 538 
 539 
 540 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 541   if (from_reg == r31_sp)
 542     from_reg = sp;
 543   if (to_reg == r31_sp)
 544     to_reg = sp;
 545   __ mov(to_reg, from_reg);
 546 }
 547 
 548 void LIR_Assembler::swap_reg(Register a, Register b) { Unimplemented(); }
 549 
 550 
 551 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 552   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 553   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 554   LIR_Const* c = src-&gt;as_constant_ptr();
 555 
 556   switch (c-&gt;type()) {
 557     case T_INT: {
 558       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 559       __ movw(dest-&gt;as_register(), c-&gt;as_jint());
 560       break;
 561     }
 562 
 563     case T_ADDRESS: {
 564       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 565       __ mov(dest-&gt;as_register(), c-&gt;as_jint());
 566       break;
 567     }
 568 
 569     case T_LONG: {
 570       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 571       __ mov(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 572       break;
 573     }
 574 
 575     case T_VALUETYPE:
 576     case T_OBJECT: {
 577         if (patch_code != lir_patch_none) {
 578           jobject2reg_with_patching(dest-&gt;as_register(), info);
 579         } else {
 580           jobject2reg(c-&gt;as_jobject(), dest-&gt;as_register());
 581         }
 582       break;
 583     }
 584 
 585     case T_METADATA: {
 586       if (patch_code != lir_patch_none) {
 587         klass2reg_with_patching(dest-&gt;as_register(), info);
 588       } else {
 589         __ mov_metadata(dest-&gt;as_register(), c-&gt;as_metadata());
 590       }
 591       break;
 592     }
 593 
 594     case T_FLOAT: {
 595       if (__ operand_valid_for_float_immediate(c-&gt;as_jfloat())) {
 596         __ fmovs(dest-&gt;as_float_reg(), (c-&gt;as_jfloat()));
 597       } else {
 598         __ adr(rscratch1, InternalAddress(float_constant(c-&gt;as_jfloat())));
 599         __ ldrs(dest-&gt;as_float_reg(), Address(rscratch1));
 600       }
 601       break;
 602     }
 603 
 604     case T_DOUBLE: {
 605       if (__ operand_valid_for_float_immediate(c-&gt;as_jdouble())) {
 606         __ fmovd(dest-&gt;as_double_reg(), (c-&gt;as_jdouble()));
 607       } else {
 608         __ adr(rscratch1, InternalAddress(double_constant(c-&gt;as_jdouble())));
 609         __ ldrd(dest-&gt;as_double_reg(), Address(rscratch1));
 610       }
 611       break;
 612     }
 613 
 614     default:
 615       ShouldNotReachHere();
 616   }
 617 }
 618 
 619 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 620   LIR_Const* c = src-&gt;as_constant_ptr();
 621   switch (c-&gt;type()) {
 622   case T_VALUETYPE:
 623   case T_OBJECT:
 624     {
 625       if (! c-&gt;as_jobject())
 626         __ str(zr, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 627       else {
 628         const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);
 629         reg2stack(FrameMap::rscratch1_opr, dest, c-&gt;type(), false);
 630       }
 631     }
 632     break;
 633   case T_ADDRESS:
 634     {
 635       const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);
 636       reg2stack(FrameMap::rscratch1_opr, dest, c-&gt;type(), false);
 637     }
 638   case T_INT:
 639   case T_FLOAT:
 640     {
 641       Register reg = zr;
 642       if (c-&gt;as_jint_bits() == 0)
 643         __ strw(zr, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 644       else {
 645         __ movw(rscratch1, c-&gt;as_jint_bits());
 646         __ strw(rscratch1, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 647       }
 648     }
 649     break;
 650   case T_LONG:
 651   case T_DOUBLE:
 652     {
 653       Register reg = zr;
 654       if (c-&gt;as_jlong_bits() == 0)
 655         __ str(zr, frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 656                                                  lo_word_offset_in_bytes));
 657       else {
 658         __ mov(rscratch1, (intptr_t)c-&gt;as_jlong_bits());
 659         __ str(rscratch1, frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 660                                                         lo_word_offset_in_bytes));
 661       }
 662     }
 663     break;
 664   default:
 665     ShouldNotReachHere();
 666   }
 667 }
 668 
 669 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 670   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 671   LIR_Const* c = src-&gt;as_constant_ptr();
 672   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 673 
 674   void (Assembler::* insn)(Register Rt, const Address &amp;adr);
 675 
 676   switch (type) {
 677   case T_ADDRESS:
 678     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 679     insn = &amp;Assembler::str;
 680     break;
 681   case T_LONG:
 682     assert(c-&gt;as_jlong() == 0, &quot;should be&quot;);
 683     insn = &amp;Assembler::str;
 684     break;
 685   case T_INT:
 686     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 687     insn = &amp;Assembler::strw;
 688     break;
 689   case T_VALUETYPE:
 690   case T_OBJECT:
 691   case T_ARRAY:
 692     // Non-null case is not handled on aarch64 but handled on x86
 693     // FIXME: do we need to add it here?
 694     assert(c-&gt;as_jobject() == 0, &quot;should be&quot;);
 695     if (UseCompressedOops &amp;&amp; !wide) {
 696       insn = &amp;Assembler::strw;
 697     } else {
 698       insn = &amp;Assembler::str;
 699     }
 700     break;
 701   case T_CHAR:
 702   case T_SHORT:
 703     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 704     insn = &amp;Assembler::strh;
 705     break;
 706   case T_BOOLEAN:
 707   case T_BYTE:
 708     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 709     insn = &amp;Assembler::strb;
 710     break;
 711   default:
 712     ShouldNotReachHere();
 713     insn = &amp;Assembler::str;  // unreachable
 714   }
 715 
 716   if (info) add_debug_info_for_null_check_here(info);
 717   (_masm-&gt;*insn)(zr, as_Address(to_addr, rscratch1));
 718 }
 719 
 720 void LIR_Assembler::reg2reg(LIR_Opr src, LIR_Opr dest) {
 721   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 722   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 723 
 724   // move between cpu-registers
 725   if (dest-&gt;is_single_cpu()) {
 726     if (src-&gt;type() == T_LONG) {
 727       // Can do LONG -&gt; OBJECT
 728       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
 729       return;
 730     }
 731     assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
 732     if (src-&gt;type() == T_OBJECT || src-&gt;type() == T_VALUETYPE) {
 733       __ verify_oop(src-&gt;as_register());
 734     }
 735     move_regs(src-&gt;as_register(), dest-&gt;as_register());
 736 
 737   } else if (dest-&gt;is_double_cpu()) {
 738     if (is_reference_type(src-&gt;type())) {
 739       // Surprising to me but we can see move of a long to t_object
 740       __ verify_oop(src-&gt;as_register());
 741       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
 742       return;
 743     }
 744     assert(src-&gt;is_double_cpu(), &quot;must match&quot;);
 745     Register f_lo = src-&gt;as_register_lo();
 746     Register f_hi = src-&gt;as_register_hi();
 747     Register t_lo = dest-&gt;as_register_lo();
 748     Register t_hi = dest-&gt;as_register_hi();
 749     assert(f_hi == f_lo, &quot;must be same&quot;);
 750     assert(t_hi == t_lo, &quot;must be same&quot;);
 751     move_regs(f_lo, t_lo);
 752 
 753   } else if (dest-&gt;is_single_fpu()) {
 754     __ fmovs(dest-&gt;as_float_reg(), src-&gt;as_float_reg());
 755 
 756   } else if (dest-&gt;is_double_fpu()) {
 757     __ fmovd(dest-&gt;as_double_reg(), src-&gt;as_double_reg());
 758 
 759   } else {
 760     ShouldNotReachHere();
 761   }
 762 }
 763 
 764 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
 765   if (src-&gt;is_single_cpu()) {
 766     if (is_reference_type(type)) {
 767       __ str(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 768       __ verify_oop(src-&gt;as_register());
 769     } else if (type == T_METADATA || type == T_DOUBLE || type == T_ADDRESS) {
 770       __ str(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 771     } else {
 772       __ strw(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 773     }
 774 
 775   } else if (src-&gt;is_double_cpu()) {
 776     Address dest_addr_LO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), lo_word_offset_in_bytes);
 777     __ str(src-&gt;as_register_lo(), dest_addr_LO);
 778 
 779   } else if (src-&gt;is_single_fpu()) {
 780     Address dest_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 781     __ strs(src-&gt;as_float_reg(), dest_addr);
 782 
 783   } else if (src-&gt;is_double_fpu()) {
 784     Address dest_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 785     __ strd(src-&gt;as_double_reg(), dest_addr);
 786 
 787   } else {
 788     ShouldNotReachHere();
 789   }
 790 
 791 }
 792 
 793 
 794 void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
 795   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 796   PatchingStub* patch = NULL;
 797   Register compressed_src = rscratch1;
 798 
 799   if (patch_code != lir_patch_none) {
 800     deoptimize_trap(info);
 801     return;
 802   }
 803 
 804   if (is_reference_type(type)) {
 805     __ verify_oop(src-&gt;as_register());
 806 
 807     if (UseCompressedOops &amp;&amp; !wide) {
 808       __ encode_heap_oop(compressed_src, src-&gt;as_register());
 809     } else {
 810       compressed_src = src-&gt;as_register();
 811     }
 812   }
 813 
 814   int null_check_here = code_offset();
 815   switch (type) {
 816     case T_FLOAT: {
 817       __ strs(src-&gt;as_float_reg(), as_Address(to_addr));
 818       break;
 819     }
 820 
 821     case T_DOUBLE: {
 822       __ strd(src-&gt;as_double_reg(), as_Address(to_addr));
 823       break;
 824     }
 825 
 826     case T_VALUETYPE: // fall through
 827     case T_ARRAY:   // fall through
 828     case T_OBJECT:  // fall through
 829       if (UseCompressedOops &amp;&amp; !wide) {
 830         __ strw(compressed_src, as_Address(to_addr, rscratch2));
 831       } else {
 832          __ str(compressed_src, as_Address(to_addr));
 833       }
 834       break;
 835     case T_METADATA:
 836       // We get here to store a method pointer to the stack to pass to
 837       // a dtrace runtime call. This can&#39;t work on 64 bit with
 838       // compressed klass ptrs: T_METADATA can be a compressed klass
 839       // ptr or a 64 bit method pointer.
 840       ShouldNotReachHere();
 841       __ str(src-&gt;as_register(), as_Address(to_addr));
 842       break;
 843     case T_ADDRESS:
 844       __ str(src-&gt;as_register(), as_Address(to_addr));
 845       break;
 846     case T_INT:
 847       __ strw(src-&gt;as_register(), as_Address(to_addr));
 848       break;
 849 
 850     case T_LONG: {
 851       __ str(src-&gt;as_register_lo(), as_Address_lo(to_addr));
 852       break;
 853     }
 854 
 855     case T_BYTE:    // fall through
 856     case T_BOOLEAN: {
 857       __ strb(src-&gt;as_register(), as_Address(to_addr));
 858       break;
 859     }
 860 
 861     case T_CHAR:    // fall through
 862     case T_SHORT:
 863       __ strh(src-&gt;as_register(), as_Address(to_addr));
 864       break;
 865 
 866     default:
 867       ShouldNotReachHere();
 868   }
 869   if (info != NULL) {
 870     add_debug_info_for_null_check(null_check_here, info);
 871   }
 872 }
 873 
 874 
 875 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
 876   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
 877   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 878 
 879   if (dest-&gt;is_single_cpu()) {
 880     if (is_reference_type(type)) {
 881       __ ldr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
 882       __ verify_oop(dest-&gt;as_register());
 883     } else if (type == T_METADATA || type == T_ADDRESS) {
 884       __ ldr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
 885     } else {
 886       __ ldrw(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
 887     }
 888 
 889   } else if (dest-&gt;is_double_cpu()) {
 890     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), lo_word_offset_in_bytes);
 891     __ ldr(dest-&gt;as_register_lo(), src_addr_LO);
 892 
 893   } else if (dest-&gt;is_single_fpu()) {
 894     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
 895     __ ldrs(dest-&gt;as_float_reg(), src_addr);
 896 
 897   } else if (dest-&gt;is_double_fpu()) {
 898     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
 899     __ ldrd(dest-&gt;as_double_reg(), src_addr);
 900 
 901   } else {
 902     ShouldNotReachHere();
 903   }
 904 }
 905 
 906 
 907 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo* info) {
 908   address target = NULL;
 909   relocInfo::relocType reloc_type = relocInfo::none;
 910 
 911   switch (patching_id(info)) {
 912   case PatchingStub::access_field_id:
 913     target = Runtime1::entry_for(Runtime1::access_field_patching_id);
 914     reloc_type = relocInfo::section_word_type;
 915     break;
 916   case PatchingStub::load_klass_id:
 917     target = Runtime1::entry_for(Runtime1::load_klass_patching_id);
 918     reloc_type = relocInfo::metadata_type;
 919     break;
 920   case PatchingStub::load_mirror_id:
 921     target = Runtime1::entry_for(Runtime1::load_mirror_patching_id);
 922     reloc_type = relocInfo::oop_type;
 923     break;
 924   case PatchingStub::load_appendix_id:
 925     target = Runtime1::entry_for(Runtime1::load_appendix_patching_id);
 926     reloc_type = relocInfo::oop_type;
 927     break;
 928   default: ShouldNotReachHere();
 929   }
 930 
 931   __ far_call(RuntimeAddress(target));
 932   add_call_info_here(info);
 933 }
 934 
 935 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
 936 
 937   LIR_Opr temp;
 938   if (type == T_LONG || type == T_DOUBLE)
 939     temp = FrameMap::rscratch1_long_opr;
 940   else
 941     temp = FrameMap::rscratch1_opr;
 942 
 943   stack2reg(src, temp, src-&gt;type());
 944   reg2stack(temp, dest, dest-&gt;type(), false);
 945 }
 946 
 947 
 948 void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool /* unaligned */) {
 949   LIR_Address* addr = src-&gt;as_address_ptr();
 950   LIR_Address* from_addr = src-&gt;as_address_ptr();
 951 
 952   if (addr-&gt;base()-&gt;type() == T_OBJECT || addr-&gt;base()-&gt;type() == T_VALUETYPE) {
 953     __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
 954   }
 955 
 956   if (patch_code != lir_patch_none) {
 957     deoptimize_trap(info);
 958     return;
 959   }
 960 
 961   if (info != NULL) {
 962     add_debug_info_for_null_check_here(info);
 963   }
 964   int null_check_here = code_offset();
 965   switch (type) {
 966     case T_FLOAT: {
 967       __ ldrs(dest-&gt;as_float_reg(), as_Address(from_addr));
 968       break;
 969     }
 970 
 971     case T_DOUBLE: {
 972       __ ldrd(dest-&gt;as_double_reg(), as_Address(from_addr));
 973       break;
 974     }
 975 
 976     case T_VALUETYPE: // fall through
 977     case T_ARRAY:   // fall through
 978     case T_OBJECT:  // fall through
 979       if (UseCompressedOops &amp;&amp; !wide) {
 980         __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
 981       } else {
 982          __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 983       }
 984       break;
 985     case T_METADATA:
 986       // We get here to store a method pointer to the stack to pass to
 987       // a dtrace runtime call. This can&#39;t work on 64 bit with
 988       // compressed klass ptrs: T_METADATA can be a compressed klass
 989       // ptr or a 64 bit method pointer.
 990       ShouldNotReachHere();
 991       __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 992       break;
 993     case T_ADDRESS:
 994       // FIXME: OMG this is a horrible kludge.  Any offset from an
 995       // address that matches klass_offset_in_bytes() will be loaded
 996       // as a word, not a long.
 997       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
 998         __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
 999       } else {
1000         __ ldr(dest-&gt;as_register(), as_Address(from_addr));
1001       }
1002       break;
1003     case T_INT:
1004       __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
1005       break;
1006 
1007     case T_LONG: {
1008       __ ldr(dest-&gt;as_register_lo(), as_Address_lo(from_addr));
1009       break;
1010     }
1011 
1012     case T_BYTE:
1013       __ ldrsb(dest-&gt;as_register(), as_Address(from_addr));
1014       break;
1015     case T_BOOLEAN: {
1016       __ ldrb(dest-&gt;as_register(), as_Address(from_addr));
1017       break;
1018     }
1019 
1020     case T_CHAR:
1021       __ ldrh(dest-&gt;as_register(), as_Address(from_addr));
1022       break;
1023     case T_SHORT:
1024       __ ldrsh(dest-&gt;as_register(), as_Address(from_addr));
1025       break;
1026 
1027     default:
1028       ShouldNotReachHere();
1029   }
1030 
1031   if (is_reference_type(type)) {
1032     if (UseCompressedOops &amp;&amp; !wide) {
1033       __ decode_heap_oop(dest-&gt;as_register());
1034     }
1035 
1036     if (!UseZGC) {
1037       // Load barrier has not yet been applied, so ZGC can&#39;t verify the oop here
1038       __ verify_oop(dest-&gt;as_register());
1039     }
1040   } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1041     if (UseCompressedClassPointers) {
1042       __ andr(dest-&gt;as_register(), dest-&gt;as_register(), oopDesc::compressed_klass_mask());
1043       __ decode_klass_not_null(dest-&gt;as_register());
1044     } else {
1045       __   ubfm(dest-&gt;as_register(), dest-&gt;as_register(), 0, 63 - oopDesc::storage_props_nof_bits);
1046     }
1047   }
1048 }
1049 
1050 void LIR_Assembler::move(LIR_Opr src, LIR_Opr dst) {
1051   assert(dst-&gt;is_cpu_register(), &quot;must be&quot;);
1052   assert(dst-&gt;type() == src-&gt;type(), &quot;must be&quot;);
1053 
1054   if (src-&gt;is_cpu_register()) {
1055     reg2reg(src, dst);
1056   } else if (src-&gt;is_stack()) {
1057     stack2reg(src, dst, dst-&gt;type());
1058   } else if (src-&gt;is_constant()) {
1059     const2reg(src, dst, lir_patch_none, NULL);
1060   } else {
1061     ShouldNotReachHere();
1062   }
1063 }
1064 
1065 int LIR_Assembler::array_element_size(BasicType type) const {
1066   int elem_size = type2aelembytes(type);
1067   return exact_log2(elem_size);
1068 }
1069 
1070 
1071 void LIR_Assembler::emit_op3(LIR_Op3* op) {
1072   switch (op-&gt;code()) {
1073   case lir_idiv:
1074   case lir_irem:
1075     arithmetic_idiv(op-&gt;code(),
1076                     op-&gt;in_opr1(),
1077                     op-&gt;in_opr2(),
1078                     op-&gt;in_opr3(),
1079                     op-&gt;result_opr(),
1080                     op-&gt;info());
1081     break;
1082   case lir_fmad:
1083     __ fmaddd(op-&gt;result_opr()-&gt;as_double_reg(),
1084               op-&gt;in_opr1()-&gt;as_double_reg(),
1085               op-&gt;in_opr2()-&gt;as_double_reg(),
1086               op-&gt;in_opr3()-&gt;as_double_reg());
1087     break;
1088   case lir_fmaf:
1089     __ fmadds(op-&gt;result_opr()-&gt;as_float_reg(),
1090               op-&gt;in_opr1()-&gt;as_float_reg(),
1091               op-&gt;in_opr2()-&gt;as_float_reg(),
1092               op-&gt;in_opr3()-&gt;as_float_reg());
1093     break;
1094   default:      ShouldNotReachHere(); break;
1095   }
1096 }
1097 
1098 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
1099 #ifdef ASSERT
1100   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
1101   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
1102   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
1103 #endif
1104 
1105   if (op-&gt;cond() == lir_cond_always) {
1106     if (op-&gt;info() != NULL) add_debug_info_for_branch(op-&gt;info());
1107     __ b(*(op-&gt;label()));
1108   } else {
1109     Assembler::Condition acond;
1110     if (op-&gt;code() == lir_cond_float_branch) {
1111       bool is_unordered = (op-&gt;ublock() == op-&gt;block());
1112       // Assembler::EQ does not permit unordered branches, so we add
1113       // another branch here.  Likewise, Assembler::NE does not permit
1114       // ordered branches.
1115       if ((is_unordered &amp;&amp; op-&gt;cond() == lir_cond_equal)
1116           || (!is_unordered &amp;&amp; op-&gt;cond() == lir_cond_notEqual))
1117         __ br(Assembler::VS, *(op-&gt;ublock()-&gt;label()));
1118       switch(op-&gt;cond()) {
1119       case lir_cond_equal:        acond = Assembler::EQ; break;
1120       case lir_cond_notEqual:     acond = Assembler::NE; break;
1121       case lir_cond_less:         acond = (is_unordered ? Assembler::LT : Assembler::LO); break;
1122       case lir_cond_lessEqual:    acond = (is_unordered ? Assembler::LE : Assembler::LS); break;
1123       case lir_cond_greaterEqual: acond = (is_unordered ? Assembler::HS : Assembler::GE); break;
1124       case lir_cond_greater:      acond = (is_unordered ? Assembler::HI : Assembler::GT); break;
1125       default:                    ShouldNotReachHere();
1126         acond = Assembler::EQ;  // unreachable
1127       }
1128     } else {
1129       switch (op-&gt;cond()) {
1130         case lir_cond_equal:        acond = Assembler::EQ; break;
1131         case lir_cond_notEqual:     acond = Assembler::NE; break;
1132         case lir_cond_less:         acond = Assembler::LT; break;
1133         case lir_cond_lessEqual:    acond = Assembler::LE; break;
1134         case lir_cond_greaterEqual: acond = Assembler::GE; break;
1135         case lir_cond_greater:      acond = Assembler::GT; break;
1136         case lir_cond_belowEqual:   acond = Assembler::LS; break;
1137         case lir_cond_aboveEqual:   acond = Assembler::HS; break;
1138         default:                    ShouldNotReachHere();
1139           acond = Assembler::EQ;  // unreachable
1140       }
1141     }
1142     __ br(acond,*(op-&gt;label()));
1143   }
1144 }
1145 
1146 
1147 
1148 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
1149   LIR_Opr src  = op-&gt;in_opr();
1150   LIR_Opr dest = op-&gt;result_opr();
1151 
1152   switch (op-&gt;bytecode()) {
1153     case Bytecodes::_i2f:
1154       {
1155         __ scvtfws(dest-&gt;as_float_reg(), src-&gt;as_register());
1156         break;
1157       }
1158     case Bytecodes::_i2d:
1159       {
1160         __ scvtfwd(dest-&gt;as_double_reg(), src-&gt;as_register());
1161         break;
1162       }
1163     case Bytecodes::_l2d:
1164       {
1165         __ scvtfd(dest-&gt;as_double_reg(), src-&gt;as_register_lo());
1166         break;
1167       }
1168     case Bytecodes::_l2f:
1169       {
1170         __ scvtfs(dest-&gt;as_float_reg(), src-&gt;as_register_lo());
1171         break;
1172       }
1173     case Bytecodes::_f2d:
1174       {
1175         __ fcvts(dest-&gt;as_double_reg(), src-&gt;as_float_reg());
1176         break;
1177       }
1178     case Bytecodes::_d2f:
1179       {
1180         __ fcvtd(dest-&gt;as_float_reg(), src-&gt;as_double_reg());
1181         break;
1182       }
1183     case Bytecodes::_i2c:
1184       {
1185         __ ubfx(dest-&gt;as_register(), src-&gt;as_register(), 0, 16);
1186         break;
1187       }
1188     case Bytecodes::_i2l:
1189       {
1190         __ sxtw(dest-&gt;as_register_lo(), src-&gt;as_register());
1191         break;
1192       }
1193     case Bytecodes::_i2s:
1194       {
1195         __ sxth(dest-&gt;as_register(), src-&gt;as_register());
1196         break;
1197       }
1198     case Bytecodes::_i2b:
1199       {
1200         __ sxtb(dest-&gt;as_register(), src-&gt;as_register());
1201         break;
1202       }
1203     case Bytecodes::_l2i:
1204       {
1205         _masm-&gt;block_comment(&quot;FIXME: This could be a no-op&quot;);
1206         __ uxtw(dest-&gt;as_register(), src-&gt;as_register_lo());
1207         break;
1208       }
1209     case Bytecodes::_d2l:
1210       {
1211         __ fcvtzd(dest-&gt;as_register_lo(), src-&gt;as_double_reg());
1212         break;
1213       }
1214     case Bytecodes::_f2i:
1215       {
1216         __ fcvtzsw(dest-&gt;as_register(), src-&gt;as_float_reg());
1217         break;
1218       }
1219     case Bytecodes::_f2l:
1220       {
1221         __ fcvtzs(dest-&gt;as_register_lo(), src-&gt;as_float_reg());
1222         break;
1223       }
1224     case Bytecodes::_d2i:
1225       {
1226         __ fcvtzdw(dest-&gt;as_register(), src-&gt;as_double_reg());
1227         break;
1228       }
1229     default: ShouldNotReachHere();
1230   }
1231 }
1232 
1233 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
1234   if (op-&gt;init_check()) {
1235     __ ldrb(rscratch1, Address(op-&gt;klass()-&gt;as_register(),
1236                                InstanceKlass::init_state_offset()));
1237     __ cmpw(rscratch1, InstanceKlass::fully_initialized);
1238     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
1239     __ br(Assembler::NE, *op-&gt;stub()-&gt;entry());
1240   }
1241   __ allocate_object(op-&gt;obj()-&gt;as_register(),
1242                      op-&gt;tmp1()-&gt;as_register(),
1243                      op-&gt;tmp2()-&gt;as_register(),
1244                      op-&gt;header_size(),
1245                      op-&gt;object_size(),
1246                      op-&gt;klass()-&gt;as_register(),
1247                      *op-&gt;stub()-&gt;entry());
1248   __ bind(*op-&gt;stub()-&gt;continuation());
1249 }
1250 
1251 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
1252   Register len =  op-&gt;len()-&gt;as_register();
1253   __ uxtw(len, len);
1254 
1255   if (UseSlowPath || op-&gt;type() == T_VALUETYPE ||
1256       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
1257       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
1258     __ b(*op-&gt;stub()-&gt;entry());
1259   } else {
1260     Register tmp1 = op-&gt;tmp1()-&gt;as_register();
1261     Register tmp2 = op-&gt;tmp2()-&gt;as_register();
1262     Register tmp3 = op-&gt;tmp3()-&gt;as_register();
1263     if (len == tmp1) {
1264       tmp1 = tmp3;
1265     } else if (len == tmp2) {
1266       tmp2 = tmp3;
1267     } else if (len == tmp3) {
1268       // everything is ok
1269     } else {
1270       __ mov(tmp3, len);
1271     }
1272     __ allocate_array(op-&gt;obj()-&gt;as_register(),
1273                       len,
1274                       tmp1,
1275                       tmp2,
1276                       arrayOopDesc::header_size(op-&gt;type()),
1277                       array_element_size(op-&gt;type()),
1278                       op-&gt;klass()-&gt;as_register(),
1279                       *op-&gt;stub()-&gt;entry());
1280   }
1281   __ bind(*op-&gt;stub()-&gt;continuation());
1282 }
1283 
1284 void LIR_Assembler::type_profile_helper(Register mdo,
1285                                         ciMethodData *md, ciProfileData *data,
1286                                         Register recv, Label* update_done) {
1287   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1288     Label next_test;
1289     // See if the receiver is receiver[n].
1290     __ lea(rscratch2, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1291     __ ldr(rscratch1, Address(rscratch2));
1292     __ cmp(recv, rscratch1);
1293     __ br(Assembler::NE, next_test);
1294     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));
1295     __ addptr(data_addr, DataLayout::counter_increment);
1296     __ b(*update_done);
1297     __ bind(next_test);
1298   }
1299 
1300   // Didn&#39;t find receiver; find next empty slot and fill it in
1301   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1302     Label next_test;
1303     __ lea(rscratch2,
1304            Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1305     Address recv_addr(rscratch2);
1306     __ ldr(rscratch1, recv_addr);
1307     __ cbnz(rscratch1, next_test);
1308     __ str(recv, recv_addr);
1309     __ mov(rscratch1, DataLayout::counter_increment);
1310     __ lea(rscratch2, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))));
1311     __ str(rscratch1, Address(rscratch2));
1312     __ b(*update_done);
1313     __ bind(next_test);
1314   }
1315 }
1316 
1317 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
1318   // we always need a stub for the failure case.
1319   CodeStub* stub = op-&gt;stub();
1320   Register obj = op-&gt;object()-&gt;as_register();
1321   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1322   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1323   Register dst = op-&gt;result_opr()-&gt;as_register();
1324   ciKlass* k = op-&gt;klass();
1325   Register Rtmp1 = noreg;
1326 
1327   // check if it needs to be profiled
1328   ciMethodData* md;
1329   ciProfileData* data;
1330 
1331   const bool should_profile = op-&gt;should_profile();
1332 
1333   if (should_profile) {
1334     ciMethod* method = op-&gt;profiled_method();
1335     assert(method != NULL, &quot;Should have method&quot;);
1336     int bci = op-&gt;profiled_bci();
1337     md = method-&gt;method_data_or_null();
1338     assert(md != NULL, &quot;Sanity&quot;);
1339     data = md-&gt;bci_to_data(bci);
1340     assert(data != NULL,                &quot;need data for type check&quot;);
1341     assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1342   }
1343   Label profile_cast_success, profile_cast_failure;
1344   Label *success_target = should_profile ? &amp;profile_cast_success : success;
1345   Label *failure_target = should_profile ? &amp;profile_cast_failure : failure;
1346 
1347   if (obj == k_RInfo) {
1348     k_RInfo = dst;
1349   } else if (obj == klass_RInfo) {
1350     klass_RInfo = dst;
1351   }
1352   if (k-&gt;is_loaded() &amp;&amp; !UseCompressedClassPointers) {
1353     select_different_registers(obj, dst, k_RInfo, klass_RInfo);
1354   } else {
1355     Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1356     select_different_registers(obj, dst, k_RInfo, klass_RInfo, Rtmp1);
1357   }
1358 
1359   assert_different_registers(obj, k_RInfo, klass_RInfo);
1360 
1361     if (should_profile) {
1362       Label not_null;
1363       __ cbnz(obj, not_null);
1364       // Object is null; update MDO and exit
1365       Register mdo  = klass_RInfo;
1366       __ mov_metadata(mdo, md-&gt;constant_encoding());
1367       Address data_addr
1368         = __ form_address(rscratch2, mdo,
1369                           md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()),
1370                           0);
1371       __ ldrb(rscratch1, data_addr);
1372       __ orr(rscratch1, rscratch1, BitData::null_seen_byte_constant());
1373       __ strb(rscratch1, data_addr);
1374       __ b(*obj_is_null);
1375       __ bind(not_null);
1376     } else {
1377       __ cbz(obj, *obj_is_null);
1378     }
1379 
1380   if (!k-&gt;is_loaded()) {
1381     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
1382   } else {
1383     __ mov_metadata(k_RInfo, k-&gt;constant_encoding());
1384   }
1385   __ verify_oop(obj);
1386 
1387   if (op-&gt;fast_check()) {
1388     // get object class
1389     // not a safepoint as obj null check happens earlier
1390     __ load_klass(rscratch1, obj);
1391     __ cmp( rscratch1, k_RInfo);
1392 
1393     __ br(Assembler::NE, *failure_target);
1394     // successful cast, fall through to profile or jump
1395   } else {
1396     // get object class
1397     // not a safepoint as obj null check happens earlier
1398     __ load_klass(klass_RInfo, obj);
1399     if (k-&gt;is_loaded()) {
1400       // See if we get an immediate positive hit
1401       __ ldr(rscratch1, Address(klass_RInfo, long(k-&gt;super_check_offset())));
1402       __ cmp(k_RInfo, rscratch1);
1403       if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k-&gt;super_check_offset()) {
1404         __ br(Assembler::NE, *failure_target);
1405         // successful cast, fall through to profile or jump
1406       } else {
1407         // See if we get an immediate positive hit
1408         __ br(Assembler::EQ, *success_target);
1409         // check for self
1410         __ cmp(klass_RInfo, k_RInfo);
1411         __ br(Assembler::EQ, *success_target);
1412 
1413         __ stp(klass_RInfo, k_RInfo, Address(__ pre(sp, -2 * wordSize)));
1414         __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1415         __ ldr(klass_RInfo, Address(__ post(sp, 2 * wordSize)));
1416         // result is a boolean
1417         __ cbzw(klass_RInfo, *failure_target);
1418         // successful cast, fall through to profile or jump
1419       }
1420     } else {
1421       // perform the fast part of the checking logic
1422       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1423       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1424       __ stp(klass_RInfo, k_RInfo, Address(__ pre(sp, -2 * wordSize)));
1425       __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1426       __ ldp(k_RInfo, klass_RInfo, Address(__ post(sp, 2 * wordSize)));
1427       // result is a boolean
1428       __ cbz(k_RInfo, *failure_target);
1429       // successful cast, fall through to profile or jump
1430     }
1431   }
1432   if (should_profile) {
1433     Register mdo  = klass_RInfo, recv = k_RInfo;
1434     __ bind(profile_cast_success);
1435     __ mov_metadata(mdo, md-&gt;constant_encoding());
1436     __ load_klass(recv, obj);
1437     Label update_done;
1438     type_profile_helper(mdo, md, data, recv, success);
1439     __ b(*success);
1440 
1441     __ bind(profile_cast_failure);
1442     __ mov_metadata(mdo, md-&gt;constant_encoding());
1443     Address counter_addr
1444       = __ form_address(rscratch2, mdo,
1445                         md-&gt;byte_offset_of_slot(data, CounterData::count_offset()),
1446                         0);
1447     __ ldr(rscratch1, counter_addr);
1448     __ sub(rscratch1, rscratch1, DataLayout::counter_increment);
1449     __ str(rscratch1, counter_addr);
1450     __ b(*failure);
1451   }
1452   __ b(*success);
1453 }
1454 
1455 
1456 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
1457   const bool should_profile = op-&gt;should_profile();
1458 
1459   LIR_Code code = op-&gt;code();
1460   if (code == lir_store_check) {
1461     Register value = op-&gt;object()-&gt;as_register();
1462     Register array = op-&gt;array()-&gt;as_register();
1463     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1464     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1465     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1466 
1467     CodeStub* stub = op-&gt;stub();
1468 
1469     // check if it needs to be profiled
1470     ciMethodData* md;
1471     ciProfileData* data;
1472 
1473     if (should_profile) {
1474       ciMethod* method = op-&gt;profiled_method();
1475       assert(method != NULL, &quot;Should have method&quot;);
1476       int bci = op-&gt;profiled_bci();
1477       md = method-&gt;method_data_or_null();
1478       assert(md != NULL, &quot;Sanity&quot;);
1479       data = md-&gt;bci_to_data(bci);
1480       assert(data != NULL,                &quot;need data for type check&quot;);
1481       assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1482     }
1483     Label profile_cast_success, profile_cast_failure, done;
1484     Label *success_target = should_profile ? &amp;profile_cast_success : &amp;done;
1485     Label *failure_target = should_profile ? &amp;profile_cast_failure : stub-&gt;entry();
1486 
1487     if (should_profile) {
1488       Label not_null;
1489       __ cbnz(value, not_null);
1490       // Object is null; update MDO and exit
1491       Register mdo  = klass_RInfo;
1492       __ mov_metadata(mdo, md-&gt;constant_encoding());
1493       Address data_addr
1494         = __ form_address(rscratch2, mdo,
1495                           md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()),
1496                           0);
1497       __ ldrb(rscratch1, data_addr);
1498       __ orr(rscratch1, rscratch1, BitData::null_seen_byte_constant());
1499       __ strb(rscratch1, data_addr);
1500       __ b(done);
1501       __ bind(not_null);
1502     } else {
1503       __ cbz(value, done);
1504     }
1505 
1506     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
1507     __ load_klass(k_RInfo, array);
1508     __ load_klass(klass_RInfo, value);
1509 
1510     // get instance klass (it&#39;s already uncompressed)
1511     __ ldr(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
1512     // perform the fast part of the checking logic
1513     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1514     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1515     __ stp(klass_RInfo, k_RInfo, Address(__ pre(sp, -2 * wordSize)));
1516     __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1517     __ ldp(k_RInfo, klass_RInfo, Address(__ post(sp, 2 * wordSize)));
1518     // result is a boolean
1519     __ cbzw(k_RInfo, *failure_target);
1520     // fall through to the success case
1521 
1522     if (should_profile) {
1523       Register mdo  = klass_RInfo, recv = k_RInfo;
1524       __ bind(profile_cast_success);
1525       __ mov_metadata(mdo, md-&gt;constant_encoding());
1526       __ load_klass(recv, value);
1527       Label update_done;
1528       type_profile_helper(mdo, md, data, recv, &amp;done);
1529       __ b(done);
1530 
1531       __ bind(profile_cast_failure);
1532       __ mov_metadata(mdo, md-&gt;constant_encoding());
1533       Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1534       __ lea(rscratch2, counter_addr);
1535       __ ldr(rscratch1, Address(rscratch2));
1536       __ sub(rscratch1, rscratch1, DataLayout::counter_increment);
1537       __ str(rscratch1, Address(rscratch2));
1538       __ b(*stub-&gt;entry());
1539     }
1540 
1541     __ bind(done);
1542   } else if (code == lir_checkcast) {
1543     Register obj = op-&gt;object()-&gt;as_register();
1544     Register dst = op-&gt;result_opr()-&gt;as_register();
1545     Label success;
1546     emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
1547     __ bind(success);
1548     if (dst != obj) {
1549       __ mov(dst, obj);
1550     }
1551   } else if (code == lir_instanceof) {
1552     Register obj = op-&gt;object()-&gt;as_register();
1553     Register dst = op-&gt;result_opr()-&gt;as_register();
1554     Label success, failure, done;
1555     emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
1556     __ bind(failure);
1557     __ mov(dst, zr);
1558     __ b(done);
1559     __ bind(success);
1560     __ mov(dst, 1);
1561     __ bind(done);
1562   } else {
1563     ShouldNotReachHere();
1564   }
1565 }
1566 
1567 void LIR_Assembler::emit_opFlattenedArrayCheck(LIR_OpFlattenedArrayCheck* op) {
1568   // We are loading/storing an array that *may* be a flattened array (the declared type
1569   // Object[], interface[], or VT?[]). If this array is flattened, take slow path.
1570 
1571   __ load_storage_props(op-&gt;tmp()-&gt;as_register(), op-&gt;array()-&gt;as_register());
1572   __ tst(op-&gt;tmp()-&gt;as_register(), ArrayStorageProperties::flattened_value);
1573   __ br(Assembler::NE, *op-&gt;stub()-&gt;entry());
1574   if (!op-&gt;value()-&gt;is_illegal()) {
1575     // We are storing into the array.
1576     Label skip;
1577     __ tst(op-&gt;tmp()-&gt;as_register(), ArrayStorageProperties::null_free_value);
1578     __ br(Assembler::EQ, skip);
1579     // The array is not flattened, but it is null_free. If we are storing
1580     // a null, take the slow path (which will throw NPE).
1581     __ cbz(op-&gt;value()-&gt;as_register(), *op-&gt;stub()-&gt;entry());
1582     __ bind(skip);
1583   }
1584 
1585 }
1586 
1587 void LIR_Assembler::emit_opNullFreeArrayCheck(LIR_OpNullFreeArrayCheck* op) {
1588   // This is called when we use aastore into a an array declared as &quot;[LVT;&quot;,
1589   // where we know VT is not flattenable (due to InlineArrayElemMaxFlatSize, etc).
1590   // However, we need to do a NULL check if the actual array is a &quot;[QVT;&quot;.
1591 
1592   __ load_storage_props(op-&gt;tmp()-&gt;as_register(), op-&gt;array()-&gt;as_register());
1593   __ mov(rscratch1, (uint64_t) ArrayStorageProperties::null_free_value);
1594   __ cmp(op-&gt;tmp()-&gt;as_register(), rscratch1);
1595 }
1596 
1597 void LIR_Assembler::emit_opSubstitutabilityCheck(LIR_OpSubstitutabilityCheck* op) {
1598   Label L_oops_equal;
1599   Label L_oops_not_equal;
1600   Label L_end;
1601 
1602   Register left  = op-&gt;left()-&gt;as_register();
1603   Register right = op-&gt;right()-&gt;as_register();
1604 
1605   __ cmp(left, right);
1606   __ br(Assembler::EQ, L_oops_equal);
1607 
1608   // (1) Null check -- if one of the operands is null, the other must not be null (because
1609   //     the two references are not equal), so they are not substitutable,
1610   //     FIXME: do null check only if the operand is nullable
1611   {
1612     __ cbz(left, L_oops_not_equal);
1613     __ cbz(right, L_oops_not_equal);
1614   }
1615 
1616 
1617   ciKlass* left_klass = op-&gt;left_klass();
1618   ciKlass* right_klass = op-&gt;right_klass();
1619 
1620   // (2) Value object check -- if either of the operands is not a value object,
1621   //     they are not substitutable. We do this only if we are not sure that the
1622   //     operands are value objects
1623   if ((left_klass == NULL || right_klass == NULL) ||// The klass is still unloaded, or came from a Phi node.
1624       !left_klass-&gt;is_valuetype() || !right_klass-&gt;is_valuetype()) {
1625     Register tmp1  = rscratch1; /* op-&gt;tmp1()-&gt;as_register(); */
1626     Register tmp2  = rscratch2; /* op-&gt;tmp2()-&gt;as_register(); */
1627 
1628     __ mov(tmp1, (intptr_t)markWord::always_locked_pattern);
1629 
1630     __ ldr(tmp2, Address(left, oopDesc::mark_offset_in_bytes()));
1631     __ andr(tmp1, tmp1, tmp2);
1632 
1633     __ ldr(tmp2, Address(right, oopDesc::mark_offset_in_bytes()));
1634     __ andr(tmp1, tmp1, tmp2);
1635 
1636     __ mov(tmp2, (intptr_t)markWord::always_locked_pattern);
1637     __ cmp(tmp1, tmp2);
1638     __ br(Assembler::NE, L_oops_not_equal);
1639   }
1640 
1641   // (3) Same klass check: if the operands are of different klasses, they are not substitutable.
1642   if (left_klass != NULL &amp;&amp; left_klass-&gt;is_valuetype() &amp;&amp; left_klass == right_klass) {
1643     // No need to load klass -- the operands are statically known to be the same value klass.
1644     __ b(*op-&gt;stub()-&gt;entry());
1645   } else {
1646     Register left_klass_op = op-&gt;left_klass_op()-&gt;as_register();
1647     Register right_klass_op = op-&gt;right_klass_op()-&gt;as_register();
1648 
1649     if (UseCompressedOops) {
1650       __ ldrw(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));
1651       __ ldrw(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));
1652       __ cmpw(left_klass_op, right_klass_op);
1653     } else {
1654       __ ldr(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));
1655       __ ldr(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));
1656       __ cmp(left_klass_op, right_klass_op);
1657     }
1658 
1659     __ br(Assembler::EQ, *op-&gt;stub()-&gt;entry()); // same klass -&gt; do slow check
1660     // fall through to L_oops_not_equal
1661   }
1662 
1663   __ bind(L_oops_not_equal);
1664   move(op-&gt;not_equal_result(), op-&gt;result_opr());
1665   __ b(L_end);
1666 
1667   __ bind(L_oops_equal);
1668   move(op-&gt;equal_result(), op-&gt;result_opr());
1669   __ b(L_end);
1670 
1671   // We&#39;ve returned from the stub. op-&gt;result_opr() contains 0x0 IFF the two
1672   // operands are not substitutable. (Don&#39;t compare against 0x1 in case the
1673   // C compiler is naughty)
1674   __ bind(*op-&gt;stub()-&gt;continuation());
1675 
1676   if (op-&gt;result_opr()-&gt;type() == T_LONG) {
1677     __ cbzw(op-&gt;result_opr()-&gt;as_register(), L_oops_not_equal); // (call_stub() == 0x0) -&gt; not_equal
1678   } else {
1679     __ cbz(op-&gt;result_opr()-&gt;as_register(), L_oops_not_equal); // (call_stub() == 0x0) -&gt; not_equal
1680   }
1681 
1682   move(op-&gt;equal_result(), op-&gt;result_opr()); // (call_stub() != 0x0) -&gt; equal
1683   // fall-through
1684   __ bind(L_end);
1685 
1686 }
1687 
1688 
1689 void LIR_Assembler::casw(Register addr, Register newval, Register cmpval) {
1690   __ cmpxchg(addr, cmpval, newval, Assembler::word, /* acquire*/ true, /* release*/ true, /* weak*/ false, rscratch1);
1691   __ cset(rscratch1, Assembler::NE);
1692   __ membar(__ AnyAny);
1693 }
1694 
1695 void LIR_Assembler::casl(Register addr, Register newval, Register cmpval) {
1696   __ cmpxchg(addr, cmpval, newval, Assembler::xword, /* acquire*/ true, /* release*/ true, /* weak*/ false, rscratch1);
1697   __ cset(rscratch1, Assembler::NE);
1698   __ membar(__ AnyAny);
1699 }
1700 
1701 
1702 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
1703   assert(VM_Version::supports_cx8(), &quot;wrong machine&quot;);
1704   Register addr;
1705   if (op-&gt;addr()-&gt;is_register()) {
1706     addr = as_reg(op-&gt;addr());
1707   } else {
1708     assert(op-&gt;addr()-&gt;is_address(), &quot;what else?&quot;);
1709     LIR_Address* addr_ptr = op-&gt;addr()-&gt;as_address_ptr();
1710     assert(addr_ptr-&gt;disp() == 0, &quot;need 0 disp&quot;);
1711     assert(addr_ptr-&gt;index() == LIR_OprDesc::illegalOpr(), &quot;need 0 index&quot;);
1712     addr = as_reg(addr_ptr-&gt;base());
1713   }
1714   Register newval = as_reg(op-&gt;new_value());
1715   Register cmpval = as_reg(op-&gt;cmp_value());
1716 
1717   if (op-&gt;code() == lir_cas_obj) {
1718     if (UseCompressedOops) {
1719       Register t1 = op-&gt;tmp1()-&gt;as_register();
1720       assert(op-&gt;tmp1()-&gt;is_valid(), &quot;must be&quot;);
1721       __ encode_heap_oop(t1, cmpval);
1722       cmpval = t1;
1723       __ encode_heap_oop(rscratch2, newval);
1724       newval = rscratch2;
1725       casw(addr, newval, cmpval);
1726     } else {
1727       casl(addr, newval, cmpval);
1728     }
1729   } else if (op-&gt;code() == lir_cas_int) {
1730     casw(addr, newval, cmpval);
1731   } else {
1732     casl(addr, newval, cmpval);
1733   }
1734 }
1735 
1736 
1737 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
1738 
1739   Assembler::Condition acond, ncond;
1740   switch (condition) {
1741   case lir_cond_equal:        acond = Assembler::EQ; ncond = Assembler::NE; break;
1742   case lir_cond_notEqual:     acond = Assembler::NE; ncond = Assembler::EQ; break;
1743   case lir_cond_less:         acond = Assembler::LT; ncond = Assembler::GE; break;
1744   case lir_cond_lessEqual:    acond = Assembler::LE; ncond = Assembler::GT; break;
1745   case lir_cond_greaterEqual: acond = Assembler::GE; ncond = Assembler::LT; break;
1746   case lir_cond_greater:      acond = Assembler::GT; ncond = Assembler::LE; break;
1747   case lir_cond_belowEqual:
1748   case lir_cond_aboveEqual:
1749   default:                    ShouldNotReachHere();
1750     acond = Assembler::EQ; ncond = Assembler::NE;  // unreachable
1751   }
1752 
1753   assert(result-&gt;is_single_cpu() || result-&gt;is_double_cpu(),
1754          &quot;expect single register for result&quot;);
1755   if (opr1-&gt;is_constant() &amp;&amp; opr2-&gt;is_constant()
1756       &amp;&amp; opr1-&gt;type() == T_INT &amp;&amp; opr2-&gt;type() == T_INT) {
1757     jint val1 = opr1-&gt;as_jint();
1758     jint val2 = opr2-&gt;as_jint();
1759     if (val1 == 0 &amp;&amp; val2 == 1) {
1760       __ cset(result-&gt;as_register(), ncond);
1761       return;
1762     } else if (val1 == 1 &amp;&amp; val2 == 0) {
1763       __ cset(result-&gt;as_register(), acond);
1764       return;
1765     }
1766   }
1767 
1768   if (opr1-&gt;is_constant() &amp;&amp; opr2-&gt;is_constant()
1769       &amp;&amp; opr1-&gt;type() == T_LONG &amp;&amp; opr2-&gt;type() == T_LONG) {
1770     jlong val1 = opr1-&gt;as_jlong();
1771     jlong val2 = opr2-&gt;as_jlong();
1772     if (val1 == 0 &amp;&amp; val2 == 1) {
1773       __ cset(result-&gt;as_register_lo(), ncond);
1774       return;
1775     } else if (val1 == 1 &amp;&amp; val2 == 0) {
1776       __ cset(result-&gt;as_register_lo(), acond);
1777       return;
1778     }
1779   }
1780 
1781   if (opr1-&gt;is_stack()) {
1782     stack2reg(opr1, FrameMap::rscratch1_opr, result-&gt;type());
1783     opr1 = FrameMap::rscratch1_opr;
1784   } else if (opr1-&gt;is_constant()) {
1785     LIR_Opr tmp
1786       = opr1-&gt;type() == T_LONG ? FrameMap::rscratch1_long_opr : FrameMap::rscratch1_opr;
1787     const2reg(opr1, tmp, lir_patch_none, NULL);
1788     opr1 = tmp;
1789   }
1790 
1791   if (opr2-&gt;is_stack()) {
1792     stack2reg(opr2, FrameMap::rscratch2_opr, result-&gt;type());
1793     opr2 = FrameMap::rscratch2_opr;
1794   } else if (opr2-&gt;is_constant()) {
1795     LIR_Opr tmp
1796       = opr2-&gt;type() == T_LONG ? FrameMap::rscratch2_long_opr : FrameMap::rscratch2_opr;
1797     const2reg(opr2, tmp, lir_patch_none, NULL);
1798     opr2 = tmp;
1799   }
1800 
1801   if (result-&gt;type() == T_LONG)
1802     __ csel(result-&gt;as_register_lo(), opr1-&gt;as_register_lo(), opr2-&gt;as_register_lo(), acond);
1803   else
1804     __ csel(result-&gt;as_register(), opr1-&gt;as_register(), opr2-&gt;as_register(), acond);
1805 }
1806 
1807 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
1808   assert(info == NULL, &quot;should never be used, idiv/irem and ldiv/lrem not handled by this method&quot;);
1809 
1810   if (left-&gt;is_single_cpu()) {
1811     Register lreg = left-&gt;as_register();
1812     Register dreg = as_reg(dest);
1813 
1814     if (right-&gt;is_single_cpu()) {
1815       // cpu register - cpu register
1816 
1817       assert(left-&gt;type() == T_INT &amp;&amp; right-&gt;type() == T_INT &amp;&amp; dest-&gt;type() == T_INT,
1818              &quot;should be&quot;);
1819       Register rreg = right-&gt;as_register();
1820       switch (code) {
1821       case lir_add: __ addw (dest-&gt;as_register(), lreg, rreg); break;
1822       case lir_sub: __ subw (dest-&gt;as_register(), lreg, rreg); break;
1823       case lir_mul: __ mulw (dest-&gt;as_register(), lreg, rreg); break;
1824       default:      ShouldNotReachHere();
1825       }
1826 
1827     } else if (right-&gt;is_double_cpu()) {
1828       Register rreg = right-&gt;as_register_lo();
1829       // single_cpu + double_cpu: can happen with obj+long
1830       assert(code == lir_add || code == lir_sub, &quot;mismatched arithmetic op&quot;);
1831       switch (code) {
1832       case lir_add: __ add(dreg, lreg, rreg); break;
1833       case lir_sub: __ sub(dreg, lreg, rreg); break;
1834       default: ShouldNotReachHere();
1835       }
1836     } else if (right-&gt;is_constant()) {
1837       // cpu register - constant
1838       jlong c;
1839 
1840       // FIXME.  This is fugly: we really need to factor all this logic.
1841       switch(right-&gt;type()) {
1842       case T_LONG:
1843         c = right-&gt;as_constant_ptr()-&gt;as_jlong();
1844         break;
1845       case T_INT:
1846       case T_ADDRESS:
1847         c = right-&gt;as_constant_ptr()-&gt;as_jint();
1848         break;
1849       default:
1850         ShouldNotReachHere();
1851         c = 0;  // unreachable
1852         break;
1853       }
1854 
1855       assert(code == lir_add || code == lir_sub, &quot;mismatched arithmetic op&quot;);
1856       if (c == 0 &amp;&amp; dreg == lreg) {
1857         COMMENT(&quot;effective nop elided&quot;);
1858         return;
1859       }
1860       switch(left-&gt;type()) {
1861       case T_INT:
1862         switch (code) {
1863         case lir_add: __ addw(dreg, lreg, c); break;
1864         case lir_sub: __ subw(dreg, lreg, c); break;
1865         default: ShouldNotReachHere();
1866         }
1867         break;
1868       case T_OBJECT:
1869       case T_ADDRESS:
1870         switch (code) {
1871         case lir_add: __ add(dreg, lreg, c); break;
1872         case lir_sub: __ sub(dreg, lreg, c); break;
1873         default: ShouldNotReachHere();
1874         }
1875         break;
1876       default:
1877         ShouldNotReachHere();
1878       }
1879     } else {
1880       ShouldNotReachHere();
1881     }
1882 
1883   } else if (left-&gt;is_double_cpu()) {
1884     Register lreg_lo = left-&gt;as_register_lo();
1885 
1886     if (right-&gt;is_double_cpu()) {
1887       // cpu register - cpu register
1888       Register rreg_lo = right-&gt;as_register_lo();
1889       switch (code) {
1890       case lir_add: __ add (dest-&gt;as_register_lo(), lreg_lo, rreg_lo); break;
1891       case lir_sub: __ sub (dest-&gt;as_register_lo(), lreg_lo, rreg_lo); break;
1892       case lir_mul: __ mul (dest-&gt;as_register_lo(), lreg_lo, rreg_lo); break;
1893       case lir_div: __ corrected_idivq(dest-&gt;as_register_lo(), lreg_lo, rreg_lo, false, rscratch1); break;
1894       case lir_rem: __ corrected_idivq(dest-&gt;as_register_lo(), lreg_lo, rreg_lo, true, rscratch1); break;
1895       default:
1896         ShouldNotReachHere();
1897       }
1898 
1899     } else if (right-&gt;is_constant()) {
1900       jlong c = right-&gt;as_constant_ptr()-&gt;as_jlong();
1901       Register dreg = as_reg(dest);
1902       switch (code) {
1903         case lir_add:
1904         case lir_sub:
1905           if (c == 0 &amp;&amp; dreg == lreg_lo) {
1906             COMMENT(&quot;effective nop elided&quot;);
1907             return;
1908           }
1909           code == lir_add ? __ add(dreg, lreg_lo, c) : __ sub(dreg, lreg_lo, c);
1910           break;
1911         case lir_div:
1912           assert(c &gt; 0 &amp;&amp; is_power_of_2(c), &quot;divisor must be power-of-2 constant&quot;);
1913           if (c == 1) {
1914             // move lreg_lo to dreg if divisor is 1
1915             __ mov(dreg, lreg_lo);
1916           } else {
1917             unsigned int shift = exact_log2_long(c);
1918             // use rscratch1 as intermediate result register
1919             __ asr(rscratch1, lreg_lo, 63);
1920             __ add(rscratch1, lreg_lo, rscratch1, Assembler::LSR, 64 - shift);
1921             __ asr(dreg, rscratch1, shift);
1922           }
1923           break;
1924         case lir_rem:
1925           assert(c &gt; 0 &amp;&amp; is_power_of_2(c), &quot;divisor must be power-of-2 constant&quot;);
1926           if (c == 1) {
1927             // move 0 to dreg if divisor is 1
1928             __ mov(dreg, zr);
1929           } else {
1930             // use rscratch1 as intermediate result register
1931             __ negs(rscratch1, lreg_lo);
1932             __ andr(dreg, lreg_lo, c - 1);
1933             __ andr(rscratch1, rscratch1, c - 1);
1934             __ csneg(dreg, dreg, rscratch1, Assembler::MI);
1935           }
1936           break;
1937         default:
1938           ShouldNotReachHere();
1939       }
1940     } else {
1941       ShouldNotReachHere();
1942     }
1943   } else if (left-&gt;is_single_fpu()) {
1944     assert(right-&gt;is_single_fpu(), &quot;right hand side of float arithmetics needs to be float register&quot;);
1945     switch (code) {
1946     case lir_add: __ fadds (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1947     case lir_sub: __ fsubs (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1948     case lir_mul_strictfp: // fall through
1949     case lir_mul: __ fmuls (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1950     case lir_div_strictfp: // fall through
1951     case lir_div: __ fdivs (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1952     default:
1953       ShouldNotReachHere();
1954     }
1955   } else if (left-&gt;is_double_fpu()) {
1956     if (right-&gt;is_double_fpu()) {
1957       // fpu register - fpu register
1958       switch (code) {
1959       case lir_add: __ faddd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1960       case lir_sub: __ fsubd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1961       case lir_mul_strictfp: // fall through
1962       case lir_mul: __ fmuld (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1963       case lir_div_strictfp: // fall through
1964       case lir_div: __ fdivd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1965       default:
1966         ShouldNotReachHere();
1967       }
1968     } else {
1969       if (right-&gt;is_constant()) {
1970         ShouldNotReachHere();
1971       }
1972       ShouldNotReachHere();
1973     }
1974   } else if (left-&gt;is_single_stack() || left-&gt;is_address()) {
1975     assert(left == dest, &quot;left and dest must be equal&quot;);
1976     ShouldNotReachHere();
1977   } else {
1978     ShouldNotReachHere();
1979   }
1980 }
1981 
1982 void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) { Unimplemented(); }
1983 
1984 
1985 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr unused, LIR_Opr dest, LIR_Op* op) {
1986   switch(code) {
1987   case lir_abs : __ fabsd(dest-&gt;as_double_reg(), value-&gt;as_double_reg()); break;
1988   case lir_sqrt: __ fsqrtd(dest-&gt;as_double_reg(), value-&gt;as_double_reg()); break;
1989   default      : ShouldNotReachHere();
1990   }
1991 }
1992 
1993 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst) {
1994 
1995   assert(left-&gt;is_single_cpu() || left-&gt;is_double_cpu(), &quot;expect single or double register&quot;);
1996   Register Rleft = left-&gt;is_single_cpu() ? left-&gt;as_register() :
1997                                            left-&gt;as_register_lo();
1998    if (dst-&gt;is_single_cpu()) {
1999      Register Rdst = dst-&gt;as_register();
2000      if (right-&gt;is_constant()) {
2001        switch (code) {
2002          case lir_logic_and: __ andw (Rdst, Rleft, right-&gt;as_jint()); break;
2003          case lir_logic_or:  __ orrw (Rdst, Rleft, right-&gt;as_jint()); break;
2004          case lir_logic_xor: __ eorw (Rdst, Rleft, right-&gt;as_jint()); break;
2005          default: ShouldNotReachHere(); break;
2006        }
2007      } else {
2008        Register Rright = right-&gt;is_single_cpu() ? right-&gt;as_register() :
2009                                                   right-&gt;as_register_lo();
2010        switch (code) {
2011          case lir_logic_and: __ andw (Rdst, Rleft, Rright); break;
2012          case lir_logic_or:  __ orrw (Rdst, Rleft, Rright); break;
2013          case lir_logic_xor: __ eorw (Rdst, Rleft, Rright); break;
2014          default: ShouldNotReachHere(); break;
2015        }
2016      }
2017    } else {
2018      Register Rdst = dst-&gt;as_register_lo();
2019      if (right-&gt;is_constant()) {
2020        switch (code) {
2021          case lir_logic_and: __ andr (Rdst, Rleft, right-&gt;as_jlong()); break;
2022          case lir_logic_or:  __ orr (Rdst, Rleft, right-&gt;as_jlong()); break;
2023          case lir_logic_xor: __ eor (Rdst, Rleft, right-&gt;as_jlong()); break;
2024          default: ShouldNotReachHere(); break;
2025        }
2026      } else {
2027        Register Rright = right-&gt;is_single_cpu() ? right-&gt;as_register() :
2028                                                   right-&gt;as_register_lo();
2029        switch (code) {
2030          case lir_logic_and: __ andr (Rdst, Rleft, Rright); break;
2031          case lir_logic_or:  __ orr (Rdst, Rleft, Rright); break;
2032          case lir_logic_xor: __ eor (Rdst, Rleft, Rright); break;
2033          default: ShouldNotReachHere(); break;
2034        }
2035      }
2036    }
2037 }
2038 
2039 
2040 
2041 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr illegal, LIR_Opr result, CodeEmitInfo* info) {
2042 
2043   // opcode check
2044   assert((code == lir_idiv) || (code == lir_irem), &quot;opcode must be idiv or irem&quot;);
2045   bool is_irem = (code == lir_irem);
2046 
2047   // operand check
2048   assert(left-&gt;is_single_cpu(),   &quot;left must be register&quot;);
2049   assert(right-&gt;is_single_cpu() || right-&gt;is_constant(),  &quot;right must be register or constant&quot;);
2050   assert(result-&gt;is_single_cpu(), &quot;result must be register&quot;);
2051   Register lreg = left-&gt;as_register();
2052   Register dreg = result-&gt;as_register();
2053 
2054   // power-of-2 constant check and codegen
2055   if (right-&gt;is_constant()) {
2056     int c = right-&gt;as_constant_ptr()-&gt;as_jint();
2057     assert(c &gt; 0 &amp;&amp; is_power_of_2(c), &quot;divisor must be power-of-2 constant&quot;);
2058     if (is_irem) {
2059       if (c == 1) {
2060         // move 0 to dreg if divisor is 1
2061         __ movw(dreg, zr);
2062       } else {
2063         // use rscratch1 as intermediate result register
2064         __ negsw(rscratch1, lreg);
2065         __ andw(dreg, lreg, c - 1);
2066         __ andw(rscratch1, rscratch1, c - 1);
2067         __ csnegw(dreg, dreg, rscratch1, Assembler::MI);
2068       }
2069     } else {
2070       if (c == 1) {
2071         // move lreg to dreg if divisor is 1
2072         __ movw(dreg, lreg);
2073       } else {
2074         unsigned int shift = exact_log2(c);
2075         // use rscratch1 as intermediate result register
2076         __ asrw(rscratch1, lreg, 31);
2077         __ addw(rscratch1, lreg, rscratch1, Assembler::LSR, 32 - shift);
2078         __ asrw(dreg, rscratch1, shift);
2079       }
2080     }
2081   } else {
2082     Register rreg = right-&gt;as_register();
2083     __ corrected_idivl(dreg, lreg, rreg, is_irem, rscratch1);
2084   }
2085 }
2086 
2087 
2088 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
2089   if (opr1-&gt;is_constant() &amp;&amp; opr2-&gt;is_single_cpu()) {
2090     // tableswitch
2091     Register reg = as_reg(opr2);
2092     struct tableswitch &amp;table = switches[opr1-&gt;as_constant_ptr()-&gt;as_jint()];
2093     __ tableswitch(reg, table._first_key, table._last_key, table._branches, table._after);
2094   } else if (opr1-&gt;is_single_cpu() || opr1-&gt;is_double_cpu()) {
2095     Register reg1 = as_reg(opr1);
2096     if (opr2-&gt;is_single_cpu()) {
2097       // cpu register - cpu register
2098       Register reg2 = opr2-&gt;as_register();
2099       if (is_reference_type(opr1-&gt;type())) {
2100         __ cmpoop(reg1, reg2);
2101       } else {
2102         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);
2103         __ cmpw(reg1, reg2);
2104       }
2105       return;
2106     }
2107     if (opr2-&gt;is_double_cpu()) {
2108       // cpu register - cpu register
2109       Register reg2 = opr2-&gt;as_register_lo();
2110       __ cmp(reg1, reg2);
2111       return;
2112     }
2113 
2114     if (opr2-&gt;is_constant()) {
2115       bool is_32bit = false; // width of register operand
2116       jlong imm;
2117 
2118       switch(opr2-&gt;type()) {
2119       case T_INT:
2120         imm = opr2-&gt;as_constant_ptr()-&gt;as_jint();
2121         is_32bit = true;
2122         break;
2123       case T_LONG:
2124         imm = opr2-&gt;as_constant_ptr()-&gt;as_jlong();
2125         break;
2126       case T_ADDRESS:
2127         imm = opr2-&gt;as_constant_ptr()-&gt;as_jint();
2128         break;
2129       case T_METADATA:
2130         imm = (intptr_t)(opr2-&gt;as_constant_ptr()-&gt;as_metadata());
2131         break;
2132       case T_VALUETYPE:
2133       case T_OBJECT:
2134       case T_ARRAY:
2135         jobject2reg(opr2-&gt;as_constant_ptr()-&gt;as_jobject(), rscratch1);
2136         __ cmpoop(reg1, rscratch1);
2137         return;
2138       default:
2139         ShouldNotReachHere();
2140         imm = 0;  // unreachable
2141         break;
2142       }
2143 
2144       if (Assembler::operand_valid_for_add_sub_immediate(imm)) {
2145         if (is_32bit)
2146           __ cmpw(reg1, imm);
2147         else
2148           __ subs(zr, reg1, imm);
2149         return;
2150       } else {
2151         __ mov(rscratch1, imm);
2152         if (is_32bit)
2153           __ cmpw(reg1, rscratch1);
2154         else
2155           __ cmp(reg1, rscratch1);
2156         return;
2157       }
2158     } else
2159       ShouldNotReachHere();
2160   } else if (opr1-&gt;is_single_fpu()) {
2161     FloatRegister reg1 = opr1-&gt;as_float_reg();
2162     assert(opr2-&gt;is_single_fpu(), &quot;expect single float register&quot;);
2163     FloatRegister reg2 = opr2-&gt;as_float_reg();
2164     __ fcmps(reg1, reg2);
2165   } else if (opr1-&gt;is_double_fpu()) {
2166     FloatRegister reg1 = opr1-&gt;as_double_reg();
2167     assert(opr2-&gt;is_double_fpu(), &quot;expect double float register&quot;);
2168     FloatRegister reg2 = opr2-&gt;as_double_reg();
2169     __ fcmpd(reg1, reg2);
2170   } else {
2171     ShouldNotReachHere();
2172   }
2173 }
2174 
2175 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op){
2176   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
2177     bool is_unordered_less = (code == lir_ucmp_fd2i);
2178     if (left-&gt;is_single_fpu()) {
2179       __ float_cmp(true, is_unordered_less ? -1 : 1, left-&gt;as_float_reg(), right-&gt;as_float_reg(), dst-&gt;as_register());
2180     } else if (left-&gt;is_double_fpu()) {
2181       __ float_cmp(false, is_unordered_less ? -1 : 1, left-&gt;as_double_reg(), right-&gt;as_double_reg(), dst-&gt;as_register());
2182     } else {
2183       ShouldNotReachHere();
2184     }
2185   } else if (code == lir_cmp_l2i) {
2186     Label done;
2187     __ cmp(left-&gt;as_register_lo(), right-&gt;as_register_lo());
2188     __ mov(dst-&gt;as_register(), (u_int64_t)-1L);
2189     __ br(Assembler::LT, done);
2190     __ csinc(dst-&gt;as_register(), zr, zr, Assembler::EQ);
2191     __ bind(done);
2192   } else {
2193     ShouldNotReachHere();
2194   }
2195 }
2196 
2197 
2198 void LIR_Assembler::align_call(LIR_Code code) {  }
2199 
2200 
2201 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
2202   address call = __ trampoline_call(Address(op-&gt;addr(), rtype));
2203   if (call == NULL) {
2204     bailout(&quot;trampoline stub overflow&quot;);
2205     return;
2206   }
2207   add_call_info(code_offset(), op-&gt;info());
2208 }
2209 
2210 
2211 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
2212   address call = __ ic_call(op-&gt;addr());
2213   if (call == NULL) {
2214     bailout(&quot;trampoline stub overflow&quot;);
2215     return;
2216   }
2217   add_call_info(code_offset(), op-&gt;info());
2218 }
2219 
2220 
2221 /* Currently, vtable-dispatch is only enabled for sparc platforms */
2222 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
2223   ShouldNotReachHere();
2224 }
2225 
2226 
2227 void LIR_Assembler::emit_static_call_stub() {
2228   address call_pc = __ pc();
2229   address stub = __ start_a_stub(call_stub_size());
2230   if (stub == NULL) {
2231     bailout(&quot;static call stub overflow&quot;);
2232     return;
2233   }
2234 
2235   int start = __ offset();
2236 
2237   __ relocate(static_stub_Relocation::spec(call_pc));
2238   __ emit_static_call_stub();
2239 
2240   assert(__ offset() - start + CompiledStaticCall::to_trampoline_stub_size()
2241         &lt;= call_stub_size(), &quot;stub too big&quot;);
2242   __ end_a_stub();
2243 }
2244 
2245 
2246 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
2247   assert(exceptionOop-&gt;as_register() == r0, &quot;must match&quot;);
2248   assert(exceptionPC-&gt;as_register() == r3, &quot;must match&quot;);
2249 
2250   // exception object is not added to oop map by LinearScan
2251   // (LinearScan assumes that no oops are in fixed registers)
2252   info-&gt;add_register_oop(exceptionOop);
2253   Runtime1::StubID unwind_id;
2254 
2255   // get current pc information
2256   // pc is only needed if the method has an exception handler, the unwind code does not need it.
2257   int pc_for_athrow_offset = __ offset();
2258   InternalAddress pc_for_athrow(__ pc());
2259   __ adr(exceptionPC-&gt;as_register(), pc_for_athrow);
2260   add_call_info(pc_for_athrow_offset, info); // for exception handler
2261 
2262   __ verify_not_null_oop(r0);
2263   // search an exception handler (r0: exception oop, r3: throwing pc)
2264   if (compilation()-&gt;has_fpu_code()) {
2265     unwind_id = Runtime1::handle_exception_id;
2266   } else {
2267     unwind_id = Runtime1::handle_exception_nofpu_id;
2268   }
2269   __ far_call(RuntimeAddress(Runtime1::entry_for(unwind_id)));
2270 
2271   // FIXME: enough room for two byte trap   ????
2272   __ nop();
2273 }
2274 
2275 
2276 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
2277   assert(exceptionOop-&gt;as_register() == r0, &quot;must match&quot;);
2278 
2279   __ b(_unwind_handler_entry);
2280 }
2281 
2282 
2283 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2284   Register lreg = left-&gt;is_single_cpu() ? left-&gt;as_register() : left-&gt;as_register_lo();
2285   Register dreg = dest-&gt;is_single_cpu() ? dest-&gt;as_register() : dest-&gt;as_register_lo();
2286 
2287   switch (left-&gt;type()) {
2288     case T_INT: {
2289       switch (code) {
2290       case lir_shl:  __ lslvw (dreg, lreg, count-&gt;as_register()); break;
2291       case lir_shr:  __ asrvw (dreg, lreg, count-&gt;as_register()); break;
2292       case lir_ushr: __ lsrvw (dreg, lreg, count-&gt;as_register()); break;
2293       default:
2294         ShouldNotReachHere();
2295         break;
2296       }
2297       break;
2298     case T_LONG:
2299     case T_VALUETYPE:
2300     case T_ADDRESS:
2301     case T_OBJECT:
2302       switch (code) {
2303       case lir_shl:  __ lslv (dreg, lreg, count-&gt;as_register()); break;
2304       case lir_shr:  __ asrv (dreg, lreg, count-&gt;as_register()); break;
2305       case lir_ushr: __ lsrv (dreg, lreg, count-&gt;as_register()); break;
2306       default:
2307         ShouldNotReachHere();
2308         break;
2309       }
2310       break;
2311     default:
2312       ShouldNotReachHere();
2313       break;
2314     }
2315   }
2316 }
2317 
2318 
2319 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
2320   Register dreg = dest-&gt;is_single_cpu() ? dest-&gt;as_register() : dest-&gt;as_register_lo();
2321   Register lreg = left-&gt;is_single_cpu() ? left-&gt;as_register() : left-&gt;as_register_lo();
2322 
2323   switch (left-&gt;type()) {
2324     case T_INT: {
2325       switch (code) {
2326       case lir_shl:  __ lslw (dreg, lreg, count); break;
2327       case lir_shr:  __ asrw (dreg, lreg, count); break;
2328       case lir_ushr: __ lsrw (dreg, lreg, count); break;
2329       default:
2330         ShouldNotReachHere();
2331         break;
2332       }
2333       break;
2334     case T_LONG:
2335     case T_ADDRESS:
2336     case T_VALUETYPE:
2337     case T_OBJECT:
2338       switch (code) {
2339       case lir_shl:  __ lsl (dreg, lreg, count); break;
2340       case lir_shr:  __ asr (dreg, lreg, count); break;
2341       case lir_ushr: __ lsr (dreg, lreg, count); break;
2342       default:
2343         ShouldNotReachHere();
2344         break;
2345       }
2346       break;
2347     default:
2348       ShouldNotReachHere();
2349       break;
2350     }
2351   }
2352 }
2353 
2354 
2355 void LIR_Assembler::store_parameter(Register r, int offset_from_rsp_in_words) {
2356   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2357   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2358   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2359   __ str (r, Address(sp, offset_from_rsp_in_bytes));
2360 }
2361 
2362 
2363 void LIR_Assembler::store_parameter(jint c,     int offset_from_rsp_in_words) {
2364   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2365   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2366   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2367   __ mov (rscratch1, c);
2368   __ str (rscratch1, Address(sp, offset_from_rsp_in_bytes));
2369 }
2370 
2371 
2372 void LIR_Assembler::store_parameter(jobject o,  int offset_from_rsp_in_words) {
2373   ShouldNotReachHere();
2374   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2375   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2376   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2377   __ lea(rscratch1, __ constant_oop_address(o));
2378   __ str(rscratch1, Address(sp, offset_from_rsp_in_bytes));
2379 }
2380 
2381 void LIR_Assembler::arraycopy_valuetype_check(Register obj, Register tmp, CodeStub* slow_path, bool is_dest) {
2382   __ load_storage_props(tmp, obj);
2383   if (is_dest) {
2384     // We also take slow path if it&#39;s a null_free destination array, just in case the source array
2385     // contains NULLs.
2386     __ tst(tmp, ArrayStorageProperties::flattened_value | ArrayStorageProperties::null_free_value);
2387   } else {
2388     __ tst(tmp, ArrayStorageProperties::flattened_value);
2389   }
2390   __ br(Assembler::NE, *slow_path-&gt;entry());
2391 }
2392 
2393 
2394 
2395 // This code replaces a call to arraycopy; no exception may
2396 // be thrown in this code, they must be thrown in the System.arraycopy
2397 // activation frame; we could save some checks if this would not be the case
2398 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
2399   ciArrayKlass* default_type = op-&gt;expected_type();
2400   Register src = op-&gt;src()-&gt;as_register();
2401   Register dst = op-&gt;dst()-&gt;as_register();
2402   Register src_pos = op-&gt;src_pos()-&gt;as_register();
2403   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
2404   Register length  = op-&gt;length()-&gt;as_register();
2405   Register tmp = op-&gt;tmp()-&gt;as_register();
2406 
2407   __ resolve(ACCESS_READ, src);
2408   __ resolve(ACCESS_WRITE, dst);
2409 
2410   CodeStub* stub = op-&gt;stub();
2411   int flags = op-&gt;flags();
2412   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
2413   if (is_reference_type(basic_type)) basic_type = T_OBJECT;
2414 
2415   if (flags &amp; LIR_OpArrayCopy::always_slow_path) {
2416     __ b(*stub-&gt;entry());
2417     __ bind(*stub-&gt;continuation());
2418     return;
2419   }
2420 
2421   if (flags &amp; LIR_OpArrayCopy::src_valuetype_check) {
2422     arraycopy_valuetype_check(src, tmp, stub, false);
2423   }
2424 
2425   if (flags &amp; LIR_OpArrayCopy::dst_valuetype_check) {
2426     arraycopy_valuetype_check(dst, tmp, stub, true);
2427   }
2428 
2429 
2430 
2431   // if we don&#39;t know anything, just go through the generic arraycopy
2432   if (default_type == NULL // || basic_type == T_OBJECT
2433       ) {
2434     Label done;
2435     assert(src == r1 &amp;&amp; src_pos == r2, &quot;mismatch in calling convention&quot;);
2436 
2437     // Save the arguments in case the generic arraycopy fails and we
2438     // have to fall back to the JNI stub
2439     __ stp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2440     __ stp(length,  src_pos, Address(sp, 2*BytesPerWord));
2441     __ str(src,              Address(sp, 4*BytesPerWord));
2442 
2443     address copyfunc_addr = StubRoutines::generic_arraycopy();
2444     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
2445 
2446     // The arguments are in java calling convention so we shift them
2447     // to C convention
2448     assert_different_registers(c_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4);
2449     __ mov(c_rarg0, j_rarg0);
2450     assert_different_registers(c_rarg1, j_rarg2, j_rarg3, j_rarg4);
2451     __ mov(c_rarg1, j_rarg1);
2452     assert_different_registers(c_rarg2, j_rarg3, j_rarg4);
2453     __ mov(c_rarg2, j_rarg2);
2454     assert_different_registers(c_rarg3, j_rarg4);
2455     __ mov(c_rarg3, j_rarg3);
2456     __ mov(c_rarg4, j_rarg4);
2457 #ifndef PRODUCT
2458     if (PrintC1Statistics) {
2459       __ incrementw(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
2460     }
2461 #endif
2462     __ far_call(RuntimeAddress(copyfunc_addr));
2463 
2464     __ cbz(r0, *stub-&gt;continuation());
2465 
2466     // Reload values from the stack so they are where the stub
2467     // expects them.
2468     __ ldp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2469     __ ldp(length,  src_pos, Address(sp, 2*BytesPerWord));
2470     __ ldr(src,              Address(sp, 4*BytesPerWord));
2471 
2472     // r0 is -1^K where K == partial copied count
2473     __ eonw(rscratch1, r0, zr);
2474     // adjust length down and src/end pos up by partial copied count
2475     __ subw(length, length, rscratch1);
2476     __ addw(src_pos, src_pos, rscratch1);
2477     __ addw(dst_pos, dst_pos, rscratch1);
2478     __ b(*stub-&gt;entry());
2479 
2480     __ bind(*stub-&gt;continuation());
2481     return;
2482   }
2483 
2484   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass() &amp;&amp; default_type-&gt;is_loaded(), &quot;must be true at this point&quot;);
2485 
2486   int elem_size = type2aelembytes(basic_type);
2487   int shift_amount;
2488   int scale = exact_log2(elem_size);
2489 
2490   Address src_length_addr = Address(src, arrayOopDesc::length_offset_in_bytes());
2491   Address dst_length_addr = Address(dst, arrayOopDesc::length_offset_in_bytes());
2492   Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());
2493   Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());
2494 
2495   // test for NULL
2496   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
2497     __ cbz(src, *stub-&gt;entry());
2498   }
2499   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
2500     __ cbz(dst, *stub-&gt;entry());
2501   }
2502 
2503   // If the compiler was not able to prove that exact type of the source or the destination
2504   // of the arraycopy is an array type, check at runtime if the source or the destination is
2505   // an instance type.
2506   if (flags &amp; LIR_OpArrayCopy::type_check) {
2507     if (!(flags &amp; LIR_OpArrayCopy::LIR_OpArrayCopy::dst_objarray)) {
2508       __ load_klass(tmp, dst);
2509       __ ldrw(rscratch1, Address(tmp, in_bytes(Klass::layout_helper_offset())));
2510       __ cmpw(rscratch1, Klass::_lh_neutral_value);
2511       __ br(Assembler::GE, *stub-&gt;entry());
2512     }
2513 
2514     if (!(flags &amp; LIR_OpArrayCopy::LIR_OpArrayCopy::src_objarray)) {
2515       __ load_klass(tmp, src);
2516       __ ldrw(rscratch1, Address(tmp, in_bytes(Klass::layout_helper_offset())));
2517       __ cmpw(rscratch1, Klass::_lh_neutral_value);
2518       __ br(Assembler::GE, *stub-&gt;entry());
2519     }
2520   }
2521 
2522   // check if negative
2523   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
2524     __ cmpw(src_pos, 0);
2525     __ br(Assembler::LT, *stub-&gt;entry());
2526   }
2527   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
2528     __ cmpw(dst_pos, 0);
2529     __ br(Assembler::LT, *stub-&gt;entry());
2530   }
2531 
2532   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
2533     __ cmpw(length, 0);
2534     __ br(Assembler::LT, *stub-&gt;entry());
2535   }
2536 
2537   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
2538     __ addw(tmp, src_pos, length);
2539     __ ldrw(rscratch1, src_length_addr);
2540     __ cmpw(tmp, rscratch1);
2541     __ br(Assembler::HI, *stub-&gt;entry());
2542   }
2543   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
2544     __ addw(tmp, dst_pos, length);
2545     __ ldrw(rscratch1, dst_length_addr);
2546     __ cmpw(tmp, rscratch1);
2547     __ br(Assembler::HI, *stub-&gt;entry());
2548   }
2549 
2550   if (flags &amp; LIR_OpArrayCopy::type_check) {
2551     // We don&#39;t know the array types are compatible
2552     if (basic_type != T_OBJECT) {
2553       // Simple test for basic type arrays
2554       if (UseCompressedClassPointers) {
2555         __ ldrw(tmp, src_klass_addr);
2556         __ ldrw(rscratch1, dst_klass_addr);
2557         __ cmpw(tmp, rscratch1);
2558       } else {
2559         __ ldr(tmp, src_klass_addr);
2560         __ ldr(rscratch1, dst_klass_addr);
2561         __ cmp(tmp, rscratch1);
2562       }
2563       __ br(Assembler::NE, *stub-&gt;entry());
2564     } else {
2565       // For object arrays, if src is a sub class of dst then we can
2566       // safely do the copy.
2567       Label cont, slow;
2568 
2569 #define PUSH(r1, r2)                                    \
2570       stp(r1, r2, __ pre(sp, -2 * wordSize));
2571 
2572 #define POP(r1, r2)                                     \
2573       ldp(r1, r2, __ post(sp, 2 * wordSize));
2574 
2575       __ PUSH(src, dst);
2576 
2577       __ load_klass(src, src);
2578       __ load_klass(dst, dst);
2579 
2580       __ check_klass_subtype_fast_path(src, dst, tmp, &amp;cont, &amp;slow, NULL);
2581 
2582       __ PUSH(src, dst);
2583       __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
2584       __ POP(src, dst);
2585 
2586       __ cbnz(src, cont);
2587 
2588       __ bind(slow);
2589       __ POP(src, dst);
2590 
2591       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
2592       if (copyfunc_addr != NULL) { // use stub if available
2593         // src is not a sub class of dst so we have to do a
2594         // per-element check.
2595 
2596         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
2597         if ((flags &amp; mask) != mask) {
2598           // Check that at least both of them object arrays.
2599           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
2600 
2601           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2602             __ load_klass(tmp, src);
2603           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2604             __ load_klass(tmp, dst);
2605           }
2606           int lh_offset = in_bytes(Klass::layout_helper_offset());
2607           Address klass_lh_addr(tmp, lh_offset);
2608           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2609           __ ldrw(rscratch1, klass_lh_addr);
2610           __ mov(rscratch2, objArray_lh);
2611           __ eorw(rscratch1, rscratch1, rscratch2);
2612           __ cbnzw(rscratch1, *stub-&gt;entry());
2613         }
2614 
2615        // Spill because stubs can use any register they like and it&#39;s
2616        // easier to restore just those that we care about.
2617         __ stp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2618         __ stp(length,  src_pos, Address(sp, 2*BytesPerWord));
2619         __ str(src,              Address(sp, 4*BytesPerWord));
2620 
2621         __ lea(c_rarg0, Address(src, src_pos, Address::uxtw(scale)));
2622         __ add(c_rarg0, c_rarg0, arrayOopDesc::base_offset_in_bytes(basic_type));
2623         assert_different_registers(c_rarg0, dst, dst_pos, length);
2624         __ lea(c_rarg1, Address(dst, dst_pos, Address::uxtw(scale)));
2625         __ add(c_rarg1, c_rarg1, arrayOopDesc::base_offset_in_bytes(basic_type));
2626         assert_different_registers(c_rarg1, dst, length);
2627         __ uxtw(c_rarg2, length);
2628         assert_different_registers(c_rarg2, dst);
2629 
2630         __ load_klass(c_rarg4, dst);
2631         __ ldr(c_rarg4, Address(c_rarg4, ObjArrayKlass::element_klass_offset()));
2632         __ ldrw(c_rarg3, Address(c_rarg4, Klass::super_check_offset_offset()));
2633         __ far_call(RuntimeAddress(copyfunc_addr));
2634 
2635 #ifndef PRODUCT
2636         if (PrintC1Statistics) {
2637           Label failed;
2638           __ cbnz(r0, failed);
2639           __ incrementw(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_cnt));
2640           __ bind(failed);
2641         }
2642 #endif
2643 
2644         __ cbz(r0, *stub-&gt;continuation());
2645 
2646 #ifndef PRODUCT
2647         if (PrintC1Statistics) {
2648           __ incrementw(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt));
2649         }
2650 #endif
2651         assert_different_registers(dst, dst_pos, length, src_pos, src, r0, rscratch1);
2652 
2653         // Restore previously spilled arguments
2654         __ ldp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2655         __ ldp(length,  src_pos, Address(sp, 2*BytesPerWord));
2656         __ ldr(src,              Address(sp, 4*BytesPerWord));
2657 
2658         // return value is -1^K where K is partial copied count
2659         __ eonw(rscratch1, r0, zr);
2660         // adjust length down and src/end pos up by partial copied count
2661         __ subw(length, length, rscratch1);
2662         __ addw(src_pos, src_pos, rscratch1);
2663         __ addw(dst_pos, dst_pos, rscratch1);
2664       }
2665 
2666       __ b(*stub-&gt;entry());
2667 
2668       __ bind(cont);
2669       __ POP(src, dst);
2670     }
2671   }
2672 
2673 #ifdef ASSERT
2674   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
2675     // Sanity check the known type with the incoming class.  For the
2676     // primitive case the types must match exactly with src.klass and
2677     // dst.klass each exactly matching the default type.  For the
2678     // object array case, if no type check is needed then either the
2679     // dst type is exactly the expected type and the src type is a
2680     // subtype which we can&#39;t check or src is the same array as dst
2681     // but not necessarily exactly of type default_type.
2682     Label known_ok, halt;
2683     __ mov_metadata(tmp, default_type-&gt;constant_encoding());
2684     if (UseCompressedClassPointers) {
2685       __ encode_klass_not_null(tmp);
2686     }
2687 
2688     if (basic_type != T_OBJECT) {
2689 
2690       if (UseCompressedClassPointers) {
2691         __ ldrw(rscratch1, dst_klass_addr);
2692         __ cmpw(tmp, rscratch1);
2693       } else {
2694         __ ldr(rscratch1, dst_klass_addr);
2695         __ cmp(tmp, rscratch1);
2696       }
2697       __ br(Assembler::NE, halt);
2698       if (UseCompressedClassPointers) {
2699         __ ldrw(rscratch1, src_klass_addr);
2700         __ cmpw(tmp, rscratch1);
2701       } else {
2702         __ ldr(rscratch1, src_klass_addr);
2703         __ cmp(tmp, rscratch1);
2704       }
2705       __ br(Assembler::EQ, known_ok);
2706     } else {
2707       if (UseCompressedClassPointers) {
2708         __ ldrw(rscratch1, dst_klass_addr);
2709         __ cmpw(tmp, rscratch1);
2710       } else {
2711         __ ldr(rscratch1, dst_klass_addr);
2712         __ cmp(tmp, rscratch1);
2713       }
2714       __ br(Assembler::EQ, known_ok);
2715       __ cmp(src, dst);
2716       __ br(Assembler::EQ, known_ok);
2717     }
2718     __ bind(halt);
2719     __ stop(&quot;incorrect type information in arraycopy&quot;);
2720     __ bind(known_ok);
2721   }
2722 #endif
2723 
2724 #ifndef PRODUCT
2725   if (PrintC1Statistics) {
2726     __ incrementw(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)));
2727   }
2728 #endif
2729 
2730   __ lea(c_rarg0, Address(src, src_pos, Address::uxtw(scale)));
2731   __ add(c_rarg0, c_rarg0, arrayOopDesc::base_offset_in_bytes(basic_type));
2732   assert_different_registers(c_rarg0, dst, dst_pos, length);
2733   __ lea(c_rarg1, Address(dst, dst_pos, Address::uxtw(scale)));
2734   __ add(c_rarg1, c_rarg1, arrayOopDesc::base_offset_in_bytes(basic_type));
2735   assert_different_registers(c_rarg1, dst, length);
2736   __ uxtw(c_rarg2, length);
2737   assert_different_registers(c_rarg2, dst);
2738 
2739   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
2740   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
2741   const char *name;
2742   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
2743 
2744  CodeBlob *cb = CodeCache::find_blob(entry);
2745  if (cb) {
2746    __ far_call(RuntimeAddress(entry));
2747  } else {
2748    __ call_VM_leaf(entry, 3);
2749  }
2750 
2751   __ bind(*stub-&gt;continuation());
2752 }
2753 
2754 
2755 
2756 
2757 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
2758   Register obj = op-&gt;obj_opr()-&gt;as_register();  // may not be an oop
2759   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
2760   Register lock = op-&gt;lock_opr()-&gt;as_register();
2761   if (!UseFastLocking) {
2762     __ b(*op-&gt;stub()-&gt;entry());
2763   } else if (op-&gt;code() == lir_lock) {
2764     Register scratch = noreg;
2765     if (UseBiasedLocking) {
2766       scratch = op-&gt;scratch_opr()-&gt;as_register();
2767     }
2768     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2769     __ resolve(ACCESS_READ | ACCESS_WRITE, obj);
2770     // add debug info for NullPointerException only if one is possible
2771     int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op-&gt;stub()-&gt;entry());
2772     if (op-&gt;info() != NULL) {
2773       add_debug_info_for_null_check(null_check_offset, op-&gt;info());
2774     }
2775     // done
2776   } else if (op-&gt;code() == lir_unlock) {
2777     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2778     __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
2779   } else {
2780     Unimplemented();
2781   }
2782   __ bind(*op-&gt;stub()-&gt;continuation());
2783 }
2784 
2785 
2786 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
2787   ciMethod* method = op-&gt;profiled_method();
2788   int bci          = op-&gt;profiled_bci();
2789   ciMethod* callee = op-&gt;profiled_callee();
2790 
2791   // Update counter for all call types
2792   ciMethodData* md = method-&gt;method_data_or_null();
2793   assert(md != NULL, &quot;Sanity&quot;);
2794   ciProfileData* data = md-&gt;bci_to_data(bci);
2795   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
2796   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
2797   Register mdo  = op-&gt;mdo()-&gt;as_register();
2798   __ mov_metadata(mdo, md-&gt;constant_encoding());
2799   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
2800   // Perform additional virtual call profiling for invokevirtual and
2801   // invokeinterface bytecodes
2802   if (op-&gt;should_profile_receiver_type()) {
2803     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
2804     Register recv = op-&gt;recv()-&gt;as_register();
2805     assert_different_registers(mdo, recv);
2806     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
2807     ciKlass* known_klass = op-&gt;known_holder();
2808     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
2809       // We know the type that will be seen at this call site; we can
2810       // statically update the MethodData* rather than needing to do
2811       // dynamic tests on the receiver type
2812 
2813       // NOTE: we should probably put a lock around this search to
2814       // avoid collisions by concurrent compilations
2815       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
2816       uint i;
2817       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2818         ciKlass* receiver = vc_data-&gt;receiver(i);
2819         if (known_klass-&gt;equals(receiver)) {
2820           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
2821           __ addptr(data_addr, DataLayout::counter_increment);
2822           return;
2823         }
2824       }
2825 
2826       // Receiver type not found in profile data; select an empty slot
2827 
2828       // Note that this is less efficient than it should be because it
2829       // always does a write to the receiver part of the
2830       // VirtualCallData rather than just the first time
2831       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2832         ciKlass* receiver = vc_data-&gt;receiver(i);
2833         if (receiver == NULL) {
2834           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));
2835           __ mov_metadata(rscratch1, known_klass-&gt;constant_encoding());
2836           __ lea(rscratch2, recv_addr);
2837           __ str(rscratch1, Address(rscratch2));
2838           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
2839           __ addptr(data_addr, DataLayout::counter_increment);
2840           return;
2841         }
2842       }
2843     } else {
2844       __ load_klass(recv, recv);
2845       Label update_done;
2846       type_profile_helper(mdo, md, data, recv, &amp;update_done);
2847       // Receiver did not match any saved receiver and there is no empty row for it.
2848       // Increment total counter to indicate polymorphic case.
2849       __ addptr(counter_addr, DataLayout::counter_increment);
2850 
2851       __ bind(update_done);
2852     }
2853   } else {
2854     // Static call
2855     __ addptr(counter_addr, DataLayout::counter_increment);
2856   }
2857 }
2858 
2859 
2860 void LIR_Assembler::emit_delay(LIR_OpDelay*) {
2861   Unimplemented();
2862 }
2863 
2864 
2865 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst) {
2866   __ lea(dst-&gt;as_register(), frame_map()-&gt;address_for_monitor_lock(monitor_no));
2867 }
2868 
2869 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
2870   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
2871   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
2872   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
2873   Register crc = op-&gt;crc()-&gt;as_register();
2874   Register val = op-&gt;val()-&gt;as_register();
2875   Register res = op-&gt;result_opr()-&gt;as_register();
2876 
2877   assert_different_registers(val, crc, res);
2878   unsigned long offset;
2879   __ adrp(res, ExternalAddress(StubRoutines::crc_table_addr()), offset);
2880   if (offset) __ add(res, res, offset);
2881 
2882   __ mvnw(crc, crc); // ~crc
2883   __ update_byte_crc32(crc, val, res);
2884   __ mvnw(res, crc); // ~crc
2885 }
2886 
2887 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
2888   COMMENT(&quot;emit_profile_type {&quot;);
2889   Register obj = op-&gt;obj()-&gt;as_register();
2890   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
2891   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
2892   ciKlass* exact_klass = op-&gt;exact_klass();
2893   intptr_t current_klass = op-&gt;current_klass();
2894   bool not_null = op-&gt;not_null();
2895   bool no_conflict = op-&gt;no_conflict();
2896 
2897   Label update, next, none;
2898 
2899   bool do_null = !not_null;
2900   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
2901   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
2902 
2903   assert(do_null || do_update, &quot;why are we here?&quot;);
2904   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
2905   assert(mdo_addr.base() != rscratch1, &quot;wrong register&quot;);
2906 
2907   __ verify_oop(obj);
2908 
2909   if (tmp != obj) {
2910     __ mov(tmp, obj);
2911   }
2912   if (do_null) {
2913     __ cbnz(tmp, update);
2914     if (!TypeEntries::was_null_seen(current_klass)) {
2915       __ ldr(rscratch2, mdo_addr);
2916       __ orr(rscratch2, rscratch2, TypeEntries::null_seen);
2917       __ str(rscratch2, mdo_addr);
2918     }
2919     if (do_update) {
2920 #ifndef ASSERT
2921       __ b(next);
2922     }
2923 #else
2924       __ b(next);
2925     }
2926   } else {
2927     __ cbnz(tmp, update);
2928     __ stop(&quot;unexpected null obj&quot;);
2929 #endif
2930   }
2931 
2932   __ bind(update);
2933 
2934   if (do_update) {
2935 #ifdef ASSERT
2936     if (exact_klass != NULL) {
2937       Label ok;
2938       __ load_klass(tmp, tmp);
2939       __ mov_metadata(rscratch1, exact_klass-&gt;constant_encoding());
2940       __ eor(rscratch1, tmp, rscratch1);
2941       __ cbz(rscratch1, ok);
2942       __ stop(&quot;exact klass and actual klass differ&quot;);
2943       __ bind(ok);
2944     }
2945 #endif
2946     if (!no_conflict) {
2947       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
2948         if (exact_klass != NULL) {
2949           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
2950         } else {
2951           __ load_klass(tmp, tmp);
2952         }
2953 
2954         __ ldr(rscratch2, mdo_addr);
2955         __ eor(tmp, tmp, rscratch2);
2956         __ andr(rscratch1, tmp, TypeEntries::type_klass_mask);
2957         // klass seen before, nothing to do. The unknown bit may have been
2958         // set already but no need to check.
2959         __ cbz(rscratch1, next);
2960 
2961         __ tbnz(tmp, exact_log2(TypeEntries::type_unknown), next); // already unknown. Nothing to do anymore.
2962 
2963         if (TypeEntries::is_type_none(current_klass)) {
2964           __ cbz(rscratch2, none);
2965           __ cmp(rscratch2, (u1)TypeEntries::null_seen);
2966           __ br(Assembler::EQ, none);
2967           // There is a chance that the checks above (re-reading profiling
2968           // data from memory) fail if another thread has just set the
2969           // profiling to this obj&#39;s klass
2970           __ dmb(Assembler::ISHLD);
2971           __ ldr(rscratch2, mdo_addr);
2972           __ eor(tmp, tmp, rscratch2);
2973           __ andr(rscratch1, tmp, TypeEntries::type_klass_mask);
2974           __ cbz(rscratch1, next);
2975         }
2976       } else {
2977         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
2978                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
2979 
2980         __ ldr(tmp, mdo_addr);
2981         __ tbnz(tmp, exact_log2(TypeEntries::type_unknown), next); // already unknown. Nothing to do anymore.
2982       }
2983 
2984       // different than before. Cannot keep accurate profile.
2985       __ ldr(rscratch2, mdo_addr);
2986       __ orr(rscratch2, rscratch2, TypeEntries::type_unknown);
2987       __ str(rscratch2, mdo_addr);
2988 
2989       if (TypeEntries::is_type_none(current_klass)) {
2990         __ b(next);
2991 
2992         __ bind(none);
2993         // first time here. Set profile type.
2994         __ str(tmp, mdo_addr);
2995       }
2996     } else {
2997       // There&#39;s a single possible klass at this profile point
2998       assert(exact_klass != NULL, &quot;should be&quot;);
2999       if (TypeEntries::is_type_none(current_klass)) {
3000         __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3001         __ ldr(rscratch2, mdo_addr);
3002         __ eor(tmp, tmp, rscratch2);
3003         __ andr(rscratch1, tmp, TypeEntries::type_klass_mask);
3004         __ cbz(rscratch1, next);
3005 #ifdef ASSERT
3006         {
3007           Label ok;
3008           __ ldr(rscratch1, mdo_addr);
3009           __ cbz(rscratch1, ok);
3010           __ cmp(rscratch1, (u1)TypeEntries::null_seen);
3011           __ br(Assembler::EQ, ok);
3012           // may have been set by another thread
3013           __ dmb(Assembler::ISHLD);
3014           __ mov_metadata(rscratch1, exact_klass-&gt;constant_encoding());
3015           __ ldr(rscratch2, mdo_addr);
3016           __ eor(rscratch2, rscratch1, rscratch2);
3017           __ andr(rscratch2, rscratch2, TypeEntries::type_mask);
3018           __ cbz(rscratch2, ok);
3019 
3020           __ stop(&quot;unexpected profiling mismatch&quot;);
3021           __ bind(ok);
3022         }
3023 #endif
3024         // first time here. Set profile type.
3025         __ ldr(tmp, mdo_addr);
3026       } else {
3027         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3028                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
3029 
3030         __ ldr(tmp, mdo_addr);
3031         __ tbnz(tmp, exact_log2(TypeEntries::type_unknown), next); // already unknown. Nothing to do anymore.
3032 
3033         __ orr(tmp, tmp, TypeEntries::type_unknown);
3034         __ str(tmp, mdo_addr);
3035         // FIXME: Write barrier needed here?
3036       }
3037     }
3038 
3039     __ bind(next);
3040   }
3041   COMMENT(&quot;} emit_profile_type&quot;);
3042 }
3043 
3044 
3045 void LIR_Assembler::align_backward_branch_target() {
3046 }
3047 
3048 
3049 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
3050   // tmp must be unused
3051   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
3052 
3053   if (left-&gt;is_single_cpu()) {
3054     assert(dest-&gt;is_single_cpu(), &quot;expect single result reg&quot;);
3055     __ negw(dest-&gt;as_register(), left-&gt;as_register());
3056   } else if (left-&gt;is_double_cpu()) {
3057     assert(dest-&gt;is_double_cpu(), &quot;expect double result reg&quot;);
3058     __ neg(dest-&gt;as_register_lo(), left-&gt;as_register_lo());
3059   } else if (left-&gt;is_single_fpu()) {
3060     assert(dest-&gt;is_single_fpu(), &quot;expect single float result reg&quot;);
3061     __ fnegs(dest-&gt;as_float_reg(), left-&gt;as_float_reg());
3062   } else {
3063     assert(left-&gt;is_double_fpu(), &quot;expect double float operand reg&quot;);
3064     assert(dest-&gt;is_double_fpu(), &quot;expect double float result reg&quot;);
3065     __ fnegd(dest-&gt;as_double_reg(), left-&gt;as_double_reg());
3066   }
3067 }
3068 
3069 
3070 void LIR_Assembler::leal(LIR_Opr addr, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
3071   if (patch_code != lir_patch_none) {
3072     deoptimize_trap(info);
3073     return;
3074   }
3075 
3076   __ lea(dest-&gt;as_register_lo(), as_Address(addr-&gt;as_address_ptr()));
3077 }
3078 
3079 
3080 void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
3081   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
3082 
3083   CodeBlob *cb = CodeCache::find_blob(dest);
3084   if (cb) {
3085     __ far_call(RuntimeAddress(dest));
3086   } else {
3087     __ mov(rscratch1, RuntimeAddress(dest));
3088     __ blr(rscratch1);
3089   }
3090 
3091   if (info != NULL) {
3092     add_call_info_here(info);
3093   }
3094   __ maybe_isb();
3095 }
3096 
3097 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
3098   if (dest-&gt;is_address() || src-&gt;is_address()) {
3099     move_op(src, dest, type, lir_patch_none, info,
3100             /*pop_fpu_stack*/false, /*unaligned*/false, /*wide*/false);
3101   } else {
3102     ShouldNotReachHere();
3103   }
3104 }
3105 
3106 #ifdef ASSERT
3107 // emit run-time assertion
3108 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
3109   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
3110 
3111   if (op-&gt;in_opr1()-&gt;is_valid()) {
3112     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
3113     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
3114   } else {
3115     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
3116     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
3117   }
3118 
3119   Label ok;
3120   if (op-&gt;condition() != lir_cond_always) {
3121     Assembler::Condition acond = Assembler::AL;
3122     switch (op-&gt;condition()) {
3123       case lir_cond_equal:        acond = Assembler::EQ;  break;
3124       case lir_cond_notEqual:     acond = Assembler::NE;  break;
3125       case lir_cond_less:         acond = Assembler::LT;  break;
3126       case lir_cond_lessEqual:    acond = Assembler::LE;  break;
3127       case lir_cond_greaterEqual: acond = Assembler::GE;  break;
3128       case lir_cond_greater:      acond = Assembler::GT;  break;
3129       case lir_cond_belowEqual:   acond = Assembler::LS;  break;
3130       case lir_cond_aboveEqual:   acond = Assembler::HS;  break;
3131       default:                    ShouldNotReachHere();
3132     }
3133     __ br(acond, ok);
3134   }
3135   if (op-&gt;halt()) {
3136     const char* str = __ code_string(op-&gt;msg());
3137     __ stop(str);
3138   } else {
3139     breakpoint();
3140   }
3141   __ bind(ok);
3142 }
3143 #endif
3144 
3145 #ifndef PRODUCT
3146 #define COMMENT(x)   do { __ block_comment(x); } while (0)
3147 #else
3148 #define COMMENT(x)
3149 #endif
3150 
3151 void LIR_Assembler::membar() {
3152   COMMENT(&quot;membar&quot;);
3153   __ membar(MacroAssembler::AnyAny);
3154 }
3155 
3156 void LIR_Assembler::membar_acquire() {
3157   __ membar(Assembler::LoadLoad|Assembler::LoadStore);
3158 }
3159 
3160 void LIR_Assembler::membar_release() {
3161   __ membar(Assembler::LoadStore|Assembler::StoreStore);
3162 }
3163 
3164 void LIR_Assembler::membar_loadload() {
3165   __ membar(Assembler::LoadLoad);
3166 }
3167 
3168 void LIR_Assembler::membar_storestore() {
3169   __ membar(MacroAssembler::StoreStore);
3170 }
3171 
3172 void LIR_Assembler::membar_loadstore() { __ membar(MacroAssembler::LoadStore); }
3173 
3174 void LIR_Assembler::membar_storeload() { __ membar(MacroAssembler::StoreLoad); }
3175 
3176 void LIR_Assembler::on_spin_wait() {
3177   Unimplemented();
3178 }
3179 
3180 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
3181   __ mov(result_reg-&gt;as_register(), rthread);
3182 }
3183 
3184 
3185 void LIR_Assembler::peephole(LIR_List *lir) {
3186 #if 0
3187   if (tableswitch_count &gt;= max_tableswitches)
3188     return;
3189 
3190   /*
3191     This finite-state automaton recognizes sequences of compare-and-
3192     branch instructions.  We will turn them into a tableswitch.  You
3193     could argue that C1 really shouldn&#39;t be doing this sort of
3194     optimization, but without it the code is really horrible.
3195   */
3196 
3197   enum { start_s, cmp1_s, beq_s, cmp_s } state;
3198   int first_key, last_key = -2147483648;
3199   int next_key = 0;
3200   int start_insn = -1;
3201   int last_insn = -1;
3202   Register reg = noreg;
3203   LIR_Opr reg_opr;
3204   state = start_s;
3205 
3206   LIR_OpList* inst = lir-&gt;instructions_list();
3207   for (int i = 0; i &lt; inst-&gt;length(); i++) {
3208     LIR_Op* op = inst-&gt;at(i);
3209     switch (state) {
3210     case start_s:
3211       first_key = -1;
3212       start_insn = i;
3213       switch (op-&gt;code()) {
3214       case lir_cmp:
3215         LIR_Opr opr1 = op-&gt;as_Op2()-&gt;in_opr1();
3216         LIR_Opr opr2 = op-&gt;as_Op2()-&gt;in_opr2();
3217         if (opr1-&gt;is_cpu_register() &amp;&amp; opr1-&gt;is_single_cpu()
3218             &amp;&amp; opr2-&gt;is_constant()
3219             &amp;&amp; opr2-&gt;type() == T_INT) {
3220           reg_opr = opr1;
3221           reg = opr1-&gt;as_register();
3222           first_key = opr2-&gt;as_constant_ptr()-&gt;as_jint();
3223           next_key = first_key + 1;
3224           state = cmp_s;
3225           goto next_state;
3226         }
3227         break;
3228       }
3229       break;
3230     case cmp_s:
3231       switch (op-&gt;code()) {
3232       case lir_branch:
3233         if (op-&gt;as_OpBranch()-&gt;cond() == lir_cond_equal) {
3234           state = beq_s;
3235           last_insn = i;
3236           goto next_state;
3237         }
3238       }
3239       state = start_s;
3240       break;
3241     case beq_s:
3242       switch (op-&gt;code()) {
3243       case lir_cmp: {
3244         LIR_Opr opr1 = op-&gt;as_Op2()-&gt;in_opr1();
3245         LIR_Opr opr2 = op-&gt;as_Op2()-&gt;in_opr2();
3246         if (opr1-&gt;is_cpu_register() &amp;&amp; opr1-&gt;is_single_cpu()
3247             &amp;&amp; opr1-&gt;as_register() == reg
3248             &amp;&amp; opr2-&gt;is_constant()
3249             &amp;&amp; opr2-&gt;type() == T_INT
3250             &amp;&amp; opr2-&gt;as_constant_ptr()-&gt;as_jint() == next_key) {
3251           last_key = next_key;
3252           next_key++;
3253           state = cmp_s;
3254           goto next_state;
3255         }
3256       }
3257       }
3258       last_key = next_key;
3259       state = start_s;
3260       break;
3261     default:
3262       assert(false, &quot;impossible state&quot;);
3263     }
3264     if (state == start_s) {
3265       if (first_key &lt; last_key - 5L &amp;&amp; reg != noreg) {
3266         {
3267           // printf(&quot;found run register %d starting at insn %d low value %d high value %d\n&quot;,
3268           //        reg-&gt;encoding(),
3269           //        start_insn, first_key, last_key);
3270           //   for (int i = 0; i &lt; inst-&gt;length(); i++) {
3271           //     inst-&gt;at(i)-&gt;print();
3272           //     tty-&gt;print(&quot;\n&quot;);
3273           //   }
3274           //   tty-&gt;print(&quot;\n&quot;);
3275         }
3276 
3277         struct tableswitch *sw = &amp;switches[tableswitch_count];
3278         sw-&gt;_insn_index = start_insn, sw-&gt;_first_key = first_key,
3279           sw-&gt;_last_key = last_key, sw-&gt;_reg = reg;
3280         inst-&gt;insert_before(last_insn + 1, new LIR_OpLabel(&amp;sw-&gt;_after));
3281         {
3282           // Insert the new table of branches
3283           int offset = last_insn;
3284           for (int n = first_key; n &lt; last_key; n++) {
3285             inst-&gt;insert_before
3286               (last_insn + 1,
3287                new LIR_OpBranch(lir_cond_always, T_ILLEGAL,
3288                                 inst-&gt;at(offset)-&gt;as_OpBranch()-&gt;label()));
3289             offset -= 2, i++;
3290           }
3291         }
3292         // Delete all the old compare-and-branch instructions
3293         for (int n = first_key; n &lt; last_key; n++) {
3294           inst-&gt;remove_at(start_insn);
3295           inst-&gt;remove_at(start_insn);
3296         }
3297         // Insert the tableswitch instruction
3298         inst-&gt;insert_before(start_insn,
3299                             new LIR_Op2(lir_cmp, lir_cond_always,
3300                                         LIR_OprFact::intConst(tableswitch_count),
3301                                         reg_opr));
3302         inst-&gt;insert_before(start_insn + 1, new LIR_OpLabel(&amp;sw-&gt;_branches));
3303         tableswitch_count++;
3304       }
3305       reg = noreg;
3306       last_key = -2147483648;
3307     }
3308   next_state:
3309     ;
3310   }
3311 #endif
3312 }
3313 
3314 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp_op) {
3315   Address addr = as_Address(src-&gt;as_address_ptr());
3316   BasicType type = src-&gt;type();
3317   bool is_oop = is_reference_type(type);
3318 
3319   void (MacroAssembler::* add)(Register prev, RegisterOrConstant incr, Register addr);
3320   void (MacroAssembler::* xchg)(Register prev, Register newv, Register addr);
3321 
3322   switch(type) {
3323   case T_INT:
3324     xchg = &amp;MacroAssembler::atomic_xchgalw;
3325     add = &amp;MacroAssembler::atomic_addalw;
3326     break;
3327   case T_LONG:
3328     xchg = &amp;MacroAssembler::atomic_xchgal;
3329     add = &amp;MacroAssembler::atomic_addal;
3330     break;
3331   case T_VALUETYPE:
3332   case T_OBJECT:
3333   case T_ARRAY:
3334     if (UseCompressedOops) {
3335       xchg = &amp;MacroAssembler::atomic_xchgalw;
3336       add = &amp;MacroAssembler::atomic_addalw;
3337     } else {
3338       xchg = &amp;MacroAssembler::atomic_xchgal;
3339       add = &amp;MacroAssembler::atomic_addal;
3340     }
3341     break;
3342   default:
3343     ShouldNotReachHere();
3344     xchg = &amp;MacroAssembler::atomic_xchgal;
3345     add = &amp;MacroAssembler::atomic_addal; // unreachable
3346   }
3347 
3348   switch (code) {
3349   case lir_xadd:
3350     {
3351       RegisterOrConstant inc;
3352       Register tmp = as_reg(tmp_op);
3353       Register dst = as_reg(dest);
3354       if (data-&gt;is_constant()) {
3355         inc = RegisterOrConstant(as_long(data));
3356         assert_different_registers(dst, addr.base(), tmp,
3357                                    rscratch1, rscratch2);
3358       } else {
3359         inc = RegisterOrConstant(as_reg(data));
3360         assert_different_registers(inc.as_register(), dst, addr.base(), tmp,
3361                                    rscratch1, rscratch2);
3362       }
3363       __ lea(tmp, addr);
3364       (_masm-&gt;*add)(dst, inc, tmp);
3365       break;
3366     }
3367   case lir_xchg:
3368     {
3369       Register tmp = tmp_op-&gt;as_register();
3370       Register obj = as_reg(data);
3371       Register dst = as_reg(dest);
3372       if (is_oop &amp;&amp; UseCompressedOops) {
3373         __ encode_heap_oop(rscratch2, obj);
3374         obj = rscratch2;
3375       }
3376       assert_different_registers(obj, addr.base(), tmp, rscratch1, dst);
3377       __ lea(tmp, addr);
3378       (_masm-&gt;*xchg)(dst, obj, tmp);
3379       if (is_oop &amp;&amp; UseCompressedOops) {
3380         __ decode_heap_oop(dst);
3381       }
3382     }
3383     break;
3384   default:
3385     ShouldNotReachHere();
3386   }
3387   __ membar(__ AnyAny);
3388 }
3389 
3390 #undef __
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime_x86_32.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 477     case T_SHORT:
 478     case T_INT:
 479       if (int_args &lt; Argument::n_int_register_parameters_j) {
 480         regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 481       } else {
 482         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 483         stk_args += 2;
 484       }
 485       break;
 486     case T_VOID:
 487       // halves of T_LONG or T_DOUBLE
 488       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 489       regs[i].set_bad();
 490       break;
 491     case T_LONG:
 492       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 493       // fall through
 494     case T_OBJECT:
 495     case T_ARRAY:
 496     case T_ADDRESS:
<span class="line-modified"> 497     case T_VALUETYPE:</span>
 498       if (int_args &lt; Argument::n_int_register_parameters_j) {
 499         regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 500       } else {
 501         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 502         stk_args += 2;
 503       }
 504       break;
 505     case T_FLOAT:
 506       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 507         regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 508       } else {
 509         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 510         stk_args += 2;
 511       }
 512       break;
 513     case T_DOUBLE:
 514       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 515       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 516         regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 517       } else {
</pre>
<hr />
<pre>
 556     case T_CHAR:
 557     case T_BYTE:
 558     case T_SHORT:
 559     case T_INT:
 560       if (int_args &lt; Argument::n_int_register_parameters_j+1) {
 561         regs[i].set1(INT_ArgReg[int_args]-&gt;as_VMReg());
 562         int_args++;
 563       } else {
 564         return -1;
 565       }
 566       break;
 567     case T_VOID:
 568       // halves of T_LONG or T_DOUBLE
 569       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 570       regs[i].set_bad();
 571       break;
 572     case T_LONG:
 573       assert(sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 574       // fall through
 575     case T_OBJECT:
<span class="line-modified"> 576     case T_VALUETYPE:</span>
 577     case T_ARRAY:
 578     case T_ADDRESS:
 579     case T_METADATA:
 580       if (int_args &lt; Argument::n_int_register_parameters_j+1) {
 581         regs[i].set2(INT_ArgReg[int_args]-&gt;as_VMReg());
 582         int_args++;
 583       } else {
 584         return -1;
 585       }
 586       break;
 587     case T_FLOAT:
 588       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 589         regs[i].set1(FP_ArgReg[fp_args]-&gt;as_VMReg());
 590         fp_args++;
 591       } else {
 592         return -1;
 593       }
 594       break;
 595     case T_DOUBLE:
 596       assert(sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
</pre>
<hr />
<pre>
 646   }
 647 
 648   __ vzeroupper();
 649   __ pop_CPU_state();
 650   // restore sp
 651   __ mov(rsp, r13);
 652   __ bind(L);
 653 }
 654 
 655 // For each value type argument, sig includes the list of fields of
 656 // the value type. This utility function computes the number of
 657 // arguments for the call if value types are passed by reference (the
 658 // calling convention the interpreter expects).
 659 static int compute_total_args_passed_int(const GrowableArray&lt;SigEntry&gt;* sig_extended) {
 660   int total_args_passed = 0;
 661   if (InlineTypePassFieldsAsArgs) {
 662     for (int i = 0; i &lt; sig_extended-&gt;length(); i++) {
 663       BasicType bt = sig_extended-&gt;at(i)._bt;
 664       if (SigEntry::is_reserved_entry(sig_extended, i)) {
 665         // Ignore reserved entry
<span class="line-modified"> 666       } else if (bt == T_VALUETYPE) {</span>
 667         // In sig_extended, a value type argument starts with:
<span class="line-modified"> 668         // T_VALUETYPE, followed by the types of the fields of the</span>
 669         // value type and T_VOID to mark the end of the value
 670         // type. Value types are flattened so, for instance, in the
 671         // case of a value type with an int field and a value type
 672         // field that itself has 2 fields, an int and a long:
<span class="line-modified"> 673         // T_VALUETYPE T_INT T_VALUETYPE T_INT T_LONG T_VOID (second</span>
<span class="line-modified"> 674         // slot for the T_LONG) T_VOID (inner T_VALUETYPE) T_VOID</span>
<span class="line-modified"> 675         // (outer T_VALUETYPE)</span>
 676         total_args_passed++;
 677         int vt = 1;
 678         do {
 679           i++;
 680           BasicType bt = sig_extended-&gt;at(i)._bt;
 681           BasicType prev_bt = sig_extended-&gt;at(i-1)._bt;
<span class="line-modified"> 682           if (bt == T_VALUETYPE) {</span>
 683             vt++;
 684           } else if (bt == T_VOID &amp;&amp;
 685                      prev_bt != T_LONG &amp;&amp;
 686                      prev_bt != T_DOUBLE) {
 687             vt--;
 688           }
 689         } while (vt != 0);
 690       } else {
 691         total_args_passed++;
 692       }
 693     }
 694   } else {
 695     total_args_passed = sig_extended-&gt;length();
 696   }
 697   return total_args_passed;
 698 }
 699 
 700 
 701 static void gen_c2i_adapter_helper(MacroAssembler* masm,
 702                                    BasicType bt,
 703                                    BasicType prev_bt,
 704                                    size_t size_in_bytes,
 705                                    const VMRegPair&amp; reg_pair,
 706                                    const Address&amp; to,
 707                                    int extraspace,
 708                                    bool is_oop) {
<span class="line-modified"> 709   assert(bt != T_VALUETYPE || !InlineTypePassFieldsAsArgs, &quot;no inline type here&quot;);</span>
 710   if (bt == T_VOID) {
 711     assert(prev_bt == T_LONG || prev_bt == T_DOUBLE, &quot;missing half&quot;);
 712     return;
 713   }
 714 
 715   // Say 4 args:
 716   // i   st_off
 717   // 0   32 T_LONG
 718   // 1   24 T_VOID
 719   // 2   16 T_OBJECT
 720   // 3    8 T_BOOL
 721   // -    0 return address
 722   //
 723   // However to make thing extra confusing. Because we can fit a long/double in
 724   // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
 725   // leaves one slot empty and only stores to a single slot. In this case the
 726   // slot that is occupied is the T_VOID slot. See I said it was confusing.
 727 
 728   bool wide = (size_in_bytes == wordSize);
 729   VMReg r_1 = reg_pair.first();
</pre>
<hr />
<pre>
 766                             const VMRegPair *regs,
 767                             Label&amp; skip_fixup,
 768                             address start,
 769                             OopMapSet* oop_maps,
 770                             int&amp; frame_complete,
 771                             int&amp; frame_size_in_words,
 772                             bool alloc_value_receiver) {
 773   // Before we get into the guts of the C2I adapter, see if we should be here
 774   // at all.  We&#39;ve come from compiled code and are attempting to jump to the
 775   // interpreter, which means the caller made a static call to get here
 776   // (vcalls always get a compiled target if there is one).  Check for a
 777   // compiled target.  If there is one, we need to patch the caller&#39;s call.
 778   patch_callers_callsite(masm);
 779 
 780   __ bind(skip_fixup);
 781 
 782   if (InlineTypePassFieldsAsArgs) {
 783     // Is there an inline type argument?
 784     bool has_value_argument = false;
 785     for (int i = 0; i &lt; sig_extended-&gt;length() &amp;&amp; !has_value_argument; i++) {
<span class="line-modified"> 786       has_value_argument = (sig_extended-&gt;at(i)._bt == T_VALUETYPE);</span>
 787     }
 788     if (has_value_argument) {
 789       // There is at least a value type argument: we&#39;re coming from
 790       // compiled code so we have no buffers to back the value
 791       // types. Allocate the buffers here with a runtime call.
 792       OopMap* map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
 793 
 794       frame_complete = __ offset();
 795 
 796       __ set_last_Java_frame(noreg, noreg, NULL);
 797 
 798       __ mov(c_rarg0, r15_thread);
 799       __ mov(c_rarg1, rbx);
 800       __ mov64(c_rarg2, (int64_t)alloc_value_receiver);
 801       __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::allocate_value_types)));
 802 
 803       oop_maps-&gt;add_gc_map((int)(__ pc() - start), map);
 804       __ reset_last_Java_frame(false);
 805 
 806       RegisterSaver::restore_live_registers(masm);
</pre>
<hr />
<pre>
 829   int extraspace = (total_args_passed * Interpreter::stackElementSize) + wordSize;
 830 
 831   // stack is aligned, keep it that way
 832   extraspace = align_up(extraspace, 2*wordSize);
 833 
 834   // Get return address
 835   __ pop(rax);
 836 
 837   // set senderSP value
 838   __ mov(r13, rsp);
 839 
 840   __ subptr(rsp, extraspace);
 841 
 842   // Store the return address in the expected location
 843   __ movptr(Address(rsp, 0), rax);
 844 
 845   // Now write the args into the outgoing interpreter space
 846 
 847   // next_arg_comp is the next argument from the compiler point of
 848   // view (value type fields are passed in registers/on the stack). In
<span class="line-modified"> 849   // sig_extended, a value type argument starts with: T_VALUETYPE,</span>
 850   // followed by the types of the fields of the value type and T_VOID
 851   // to mark the end of the value type. ignored counts the number of
<span class="line-modified"> 852   // T_VALUETYPE/T_VOID. next_vt_arg is the next value type argument:</span>
 853   // used to get the buffer for that argument from the pool of buffers
 854   // we allocated above and want to pass to the
 855   // interpreter. next_arg_int is the next argument from the
 856   // interpreter point of view (value types are passed by reference).
 857   for (int next_arg_comp = 0, ignored = 0, next_vt_arg = 0, next_arg_int = 0;
 858        next_arg_comp &lt; sig_extended-&gt;length(); next_arg_comp++) {
 859     assert(ignored &lt;= next_arg_comp, &quot;shouldn&#39;t skip over more slots than there are arguments&quot;);
 860     assert(next_arg_int &lt;= total_args_passed, &quot;more arguments for the interpreter than expected?&quot;);
 861     BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 862     int st_off = (total_args_passed - next_arg_int) * Interpreter::stackElementSize;
<span class="line-modified"> 863     if (!InlineTypePassFieldsAsArgs || bt != T_VALUETYPE) {</span>
 864       if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 865         continue; // Ignore reserved entry
 866       }
 867       int next_off = st_off - Interpreter::stackElementSize;
 868       const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;
 869       const VMRegPair reg_pair = regs[next_arg_comp-ignored];
 870       size_t size_in_bytes = reg_pair.second()-&gt;is_valid() ? 8 : 4;
 871       gen_c2i_adapter_helper(masm, bt, next_arg_comp &gt; 0 ? sig_extended-&gt;at(next_arg_comp-1)._bt : T_ILLEGAL,
 872                              size_in_bytes, reg_pair, Address(rsp, offset), extraspace, false);
 873       next_arg_int++;
 874 #ifdef ASSERT
 875       if (bt == T_LONG || bt == T_DOUBLE) {
 876         // Overwrite the unused slot with known junk
 877         __ mov64(rax, CONST64(0xdeadffffdeadaaaa));
 878         __ movptr(Address(rsp, st_off), rax);
 879       }
 880 #endif /* ASSERT */
 881     } else {
 882       ignored++;
 883       // get the buffer from the just allocated pool of buffers
<span class="line-modified"> 884       int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_VALUETYPE);</span>
 885       __ load_heap_oop(r14, Address(rscratch2, index));
 886       next_vt_arg++; next_arg_int++;
 887       int vt = 1;
 888       // write fields we get from compiled code in registers/stack
 889       // slots to the buffer: we know we are done with that value type
 890       // argument when we hit the T_VOID that acts as an end of value
 891       // type delimiter for this value type. Value types are flattened
 892       // so we might encounter embedded value types. Each entry in
 893       // sig_extended contains a field offset in the buffer.
 894       do {
 895         next_arg_comp++;
 896         BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 897         BasicType prev_bt = sig_extended-&gt;at(next_arg_comp-1)._bt;
<span class="line-modified"> 898         if (bt == T_VALUETYPE) {</span>
 899           vt++;
 900           ignored++;
 901         } else if (bt == T_VOID &amp;&amp;
 902                    prev_bt != T_LONG &amp;&amp;
 903                    prev_bt != T_DOUBLE) {
 904           vt--;
 905           ignored++;
 906         } else if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 907           // Ignore reserved entry
 908         } else {
 909           int off = sig_extended-&gt;at(next_arg_comp)._offset;
 910           assert(off &gt; 0, &quot;offset in object should be positive&quot;);
 911           size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;
 912           bool is_oop = is_reference_type(bt);
 913           gen_c2i_adapter_helper(masm, bt, next_arg_comp &gt; 0 ? sig_extended-&gt;at(next_arg_comp-1)._bt : T_ILLEGAL,
 914                                  size_in_bytes, regs[next_arg_comp-ignored], Address(r14, off), extraspace, is_oop);
 915         }
 916       } while (vt != 0);
 917       // pass the buffer to the interpreter
 918       __ movptr(Address(rsp, st_off), r14);
</pre>
<hr />
<pre>
1034   __ movptr(r11, Address(rbx, in_bytes(Method::from_compiled_value_offset())));
1035 
1036 #if INCLUDE_JVMCI
1037   if (EnableJVMCI || UseAOT) {
1038     // check if this call should be routed towards a specific entry point
1039     __ cmpptr(Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())), 0);
1040     Label no_alternative_target;
1041     __ jcc(Assembler::equal, no_alternative_target);
1042     __ movptr(r11, Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
1043     __ movptr(Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())), 0);
1044     __ bind(no_alternative_target);
1045   }
1046 #endif // INCLUDE_JVMCI
1047 
1048   int total_args_passed = sig-&gt;length();
1049 
1050   // Now generate the shuffle code.  Pick up all register args and move the
1051   // rest through the floating point stack top.
1052   for (int i = 0; i &lt; total_args_passed; i++) {
1053     BasicType bt = sig-&gt;at(i)._bt;
<span class="line-modified">1054     assert(bt != T_VALUETYPE, &quot;i2c adapter doesn&#39;t unpack value args&quot;);</span>
1055     if (bt == T_VOID) {
1056       // Longs and doubles are passed in native word order, but misaligned
1057       // in the 32-bit build.
1058       BasicType prev_bt = (i &gt; 0) ? sig-&gt;at(i-1)._bt : T_ILLEGAL;
1059       assert(i &gt; 0 &amp;&amp; (prev_bt == T_LONG || prev_bt == T_DOUBLE), &quot;missing half&quot;);
1060       continue;
1061     }
1062 
1063     // Pick up 0, 1 or 2 words from SP+offset.
1064 
1065     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(),
1066             &quot;scrambled load targets?&quot;);
1067     // Load in argument order going down.
1068     int ld_off = (total_args_passed - i)*Interpreter::stackElementSize;
1069     // Point to interpreter value (vs. tag)
1070     int next_off = ld_off - Interpreter::stackElementSize;
1071     //
1072     //
1073     //
1074     VMReg r_1 = regs[i].first();
</pre>
<hr />
<pre>
1305       case T_BYTE:
1306       case T_SHORT:
1307       case T_INT:
1308         if (int_args &lt; Argument::n_int_register_parameters_c) {
1309           regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
1310 #ifdef _WIN64
1311           fp_args++;
1312           // Allocate slots for callee to stuff register args the stack.
1313           stk_args += 2;
1314 #endif
1315         } else {
1316           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1317           stk_args += 2;
1318         }
1319         break;
1320       case T_LONG:
1321         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1322         // fall through
1323       case T_OBJECT:
1324       case T_ARRAY:
<span class="line-modified">1325       case T_VALUETYPE:</span>
1326       case T_ADDRESS:
1327       case T_METADATA:
1328         if (int_args &lt; Argument::n_int_register_parameters_c) {
1329           regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
1330 #ifdef _WIN64
1331           fp_args++;
1332           stk_args += 2;
1333 #endif
1334         } else {
1335           regs[i].set2(VMRegImpl::stack2reg(stk_args));
1336           stk_args += 2;
1337         }
1338         break;
1339       case T_FLOAT:
1340         if (fp_args &lt; Argument::n_float_register_parameters_c) {
1341           regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
1342 #ifdef _WIN64
1343           int_args++;
1344           // Allocate slots for callee to stuff register args the stack.
1345           stk_args += 2;
</pre>
<hr />
<pre>
1690 
1691       // Value is in an input register pass we must flush it to the stack
1692       const Register reg = in_regs[i].first()-&gt;as_Register();
1693       switch (in_sig_bt[i]) {
1694         case T_BOOLEAN:
1695         case T_CHAR:
1696         case T_BYTE:
1697         case T_SHORT:
1698         case T_INT:
1699           if (map != NULL) {
1700             __ movl(Address(rsp, offset), reg);
1701           } else {
1702             __ movl(reg, Address(rsp, offset));
1703           }
1704           break;
1705         case T_ARRAY:
1706         case T_LONG:
1707           // handled above
1708           break;
1709         case T_OBJECT:
<span class="line-modified">1710         case T_VALUETYPE:</span>
1711         default: ShouldNotReachHere();
1712       }
1713     } else if (in_regs[i].first()-&gt;is_XMMRegister()) {
1714       if (in_sig_bt[i] == T_FLOAT) {
1715         int offset = slot * VMRegImpl::stack_slot_size;
1716         slot++;
1717         assert(slot &lt;= stack_slots, &quot;overflow&quot;);
1718         if (map != NULL) {
1719           __ movflt(Address(rsp, offset), in_regs[i].first()-&gt;as_XMMRegister());
1720         } else {
1721           __ movflt(in_regs[i].first()-&gt;as_XMMRegister(), Address(rsp, offset));
1722         }
1723       }
1724     } else if (in_regs[i].first()-&gt;is_stack()) {
1725       if (in_sig_bt[i] == T_ARRAY &amp;&amp; map != NULL) {
1726         int offset_in_older_frame = in_regs[i].first()-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
1727         map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + stack_slots));
1728       }
1729     }
1730   }
</pre>
<hr />
<pre>
2604             VMRegPair result_reg;
2605             result_reg.set_ptr(rax-&gt;as_VMReg());
2606             move_ptr(masm, result_reg, in_regs[i]);
2607             if (!in_regs[i].first()-&gt;is_stack()) {
2608               assert(pinned_slot &lt;= stack_slots, &quot;overflow&quot;);
2609               move_ptr(masm, result_reg, VMRegImpl::stack2reg(pinned_slot));
2610               pinned_slot += VMRegImpl::slots_per_word;
2611             }
2612           }
2613           unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
2614           c_arg++;
2615 #ifdef ASSERT
2616           if (out_regs[c_arg].first()-&gt;is_Register()) {
2617             reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
2618           } else if (out_regs[c_arg].first()-&gt;is_XMMRegister()) {
2619             freg_destroyed[out_regs[c_arg].first()-&gt;as_XMMRegister()-&gt;encoding()] = true;
2620           }
2621 #endif
2622           break;
2623         }
<span class="line-modified">2624       case T_VALUETYPE:</span>
2625       case T_OBJECT:
2626         assert(!is_critical_native, &quot;no oop arguments&quot;);
2627         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
2628                     ((i == 0) &amp;&amp; (!is_static)),
2629                     &amp;receiver_offset);
2630         break;
2631       case T_VOID:
2632         break;
2633 
2634       case T_FLOAT:
2635         float_move(masm, in_regs[i], out_regs[c_arg]);
2636           break;
2637 
2638       case T_DOUBLE:
2639         assert( i + 1 &lt; total_in_args &amp;&amp;
2640                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
2641                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
2642         double_move(masm, in_regs[i], out_regs[c_arg]);
2643         break;
2644 
</pre>
<hr />
<pre>
2805   // Now set thread in native
2806   __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);
2807 
2808   __ call(RuntimeAddress(native_func));
2809 
2810   // Verify or restore cpu control state after JNI call
2811   __ restore_cpu_control_state_after_jni();
2812 
2813   // Unpack native results.
2814   switch (ret_type) {
2815   case T_BOOLEAN: __ c2bool(rax);            break;
2816   case T_CHAR   : __ movzwl(rax, rax);      break;
2817   case T_BYTE   : __ sign_extend_byte (rax); break;
2818   case T_SHORT  : __ sign_extend_short(rax); break;
2819   case T_INT    : /* nothing to do */        break;
2820   case T_DOUBLE :
2821   case T_FLOAT  :
2822     // Result is in xmm0 we&#39;ll save as needed
2823     break;
2824   case T_ARRAY:                 // Really a handle
<span class="line-modified">2825   case T_VALUETYPE:             // Really a handle</span>
2826   case T_OBJECT:                // Really a handle
2827       break; // can&#39;t de-handlize until after safepoint check
2828   case T_VOID: break;
2829   case T_LONG: break;
2830   default       : ShouldNotReachHere();
2831   }
2832 
2833   // unpin pinned arguments
2834   pinned_slot = oop_handle_offset;
2835   if (pinned_args.length() &gt; 0) {
2836     // save return value that may be overwritten otherwise.
2837     save_native_result(masm, ret_type, stack_slots);
2838     for (int index = 0; index &lt; pinned_args.length(); index ++) {
2839       int i = pinned_args.at(index);
2840       assert(pinned_slot &lt;= stack_slots, &quot;overflow&quot;);
2841       if (!in_regs[i].first()-&gt;is_stack()) {
2842         int offset = pinned_slot * VMRegImpl::stack_slot_size;
2843         __ movq(in_regs[i].first()-&gt;as_Register(), Address(rsp, offset));
2844         pinned_slot += VMRegImpl::slots_per_word;
2845       }
</pre>
<hr />
<pre>
4332 
4333   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
4334 
4335   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();
4336   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();
4337 
4338   int pack_fields_jobject_off = __ offset();
4339   // Resolve pre-allocated buffer from JNI handle.
4340   // We cannot do this in generate_call_stub() because it requires GC code to be initialized.
4341   __ movptr(rax, Address(r13, 0));
4342   __ resolve_jobject(rax /* value */,
4343                      r15_thread /* thread */,
4344                      r12 /* tmp */);
4345   __ movptr(Address(r13, 0), rax);
4346 
4347   int pack_fields_off = __ offset();
4348 
4349   int j = 1;
4350   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
4351     BasicType bt = sig_vk-&gt;at(i)._bt;
<span class="line-modified">4352     if (bt == T_VALUETYPE) {</span>
4353       continue;
4354     }
4355     if (bt == T_VOID) {
4356       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||
4357           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {
4358         j++;
4359       }
4360       continue;
4361     }
4362     int off = sig_vk-&gt;at(i)._offset;
4363     assert(off &gt; 0, &quot;offset in object should be positive&quot;);
4364     VMRegPair pair = regs-&gt;at(j);
4365     VMReg r_1 = pair.first();
4366     VMReg r_2 = pair.second();
4367     Address to(rax, off);
4368     if (bt == T_FLOAT) {
4369       __ movflt(to, r_1-&gt;as_XMMRegister());
4370     } else if (bt == T_DOUBLE) {
4371       __ movdbl(to, r_1-&gt;as_XMMRegister());
4372     } else {
4373       Register val = r_1-&gt;as_Register();
4374       assert_different_registers(to.base(), val, r14, r13, rbx, rscratch1);
4375       if (is_reference_type(bt)) {
4376         __ store_heap_oop(to, val, r14, r13, rbx, IN_HEAP | ACCESS_WRITE | IS_DEST_UNINITIALIZED);
4377       } else {
4378         __ store_sized_value(to, r_1-&gt;as_Register(), type2aelembytes(bt));
4379       }
4380     }
4381     j++;
4382   }
4383   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
4384 
4385   __ ret(0);
4386 
4387   int unpack_fields_off = __ offset();
4388 
4389   j = 1;
4390   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
4391     BasicType bt = sig_vk-&gt;at(i)._bt;
<span class="line-modified">4392     if (bt == T_VALUETYPE) {</span>
4393       continue;
4394     }
4395     if (bt == T_VOID) {
4396       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||
4397           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {
4398         j++;
4399       }
4400       continue;
4401     }
4402     int off = sig_vk-&gt;at(i)._offset;
4403     assert(off &gt; 0, &quot;offset in object should be positive&quot;);
4404     VMRegPair pair = regs-&gt;at(j);
4405     VMReg r_1 = pair.first();
4406     VMReg r_2 = pair.second();
4407     Address from(rax, off);
4408     if (bt == T_FLOAT) {
4409       __ movflt(r_1-&gt;as_XMMRegister(), from);
4410     } else if (bt == T_DOUBLE) {
4411       __ movdbl(r_1-&gt;as_XMMRegister(), from);
4412     } else if (bt == T_OBJECT || bt == T_ARRAY) {
</pre>
</td>
<td>
<hr />
<pre>
 477     case T_SHORT:
 478     case T_INT:
 479       if (int_args &lt; Argument::n_int_register_parameters_j) {
 480         regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 481       } else {
 482         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 483         stk_args += 2;
 484       }
 485       break;
 486     case T_VOID:
 487       // halves of T_LONG or T_DOUBLE
 488       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 489       regs[i].set_bad();
 490       break;
 491     case T_LONG:
 492       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 493       // fall through
 494     case T_OBJECT:
 495     case T_ARRAY:
 496     case T_ADDRESS:
<span class="line-modified"> 497     case T_INLINE_TYPE:</span>
 498       if (int_args &lt; Argument::n_int_register_parameters_j) {
 499         regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 500       } else {
 501         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 502         stk_args += 2;
 503       }
 504       break;
 505     case T_FLOAT:
 506       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 507         regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 508       } else {
 509         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 510         stk_args += 2;
 511       }
 512       break;
 513     case T_DOUBLE:
 514       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 515       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 516         regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 517       } else {
</pre>
<hr />
<pre>
 556     case T_CHAR:
 557     case T_BYTE:
 558     case T_SHORT:
 559     case T_INT:
 560       if (int_args &lt; Argument::n_int_register_parameters_j+1) {
 561         regs[i].set1(INT_ArgReg[int_args]-&gt;as_VMReg());
 562         int_args++;
 563       } else {
 564         return -1;
 565       }
 566       break;
 567     case T_VOID:
 568       // halves of T_LONG or T_DOUBLE
 569       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 570       regs[i].set_bad();
 571       break;
 572     case T_LONG:
 573       assert(sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 574       // fall through
 575     case T_OBJECT:
<span class="line-modified"> 576     case T_INLINE_TYPE:</span>
 577     case T_ARRAY:
 578     case T_ADDRESS:
 579     case T_METADATA:
 580       if (int_args &lt; Argument::n_int_register_parameters_j+1) {
 581         regs[i].set2(INT_ArgReg[int_args]-&gt;as_VMReg());
 582         int_args++;
 583       } else {
 584         return -1;
 585       }
 586       break;
 587     case T_FLOAT:
 588       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 589         regs[i].set1(FP_ArgReg[fp_args]-&gt;as_VMReg());
 590         fp_args++;
 591       } else {
 592         return -1;
 593       }
 594       break;
 595     case T_DOUBLE:
 596       assert(sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
</pre>
<hr />
<pre>
 646   }
 647 
 648   __ vzeroupper();
 649   __ pop_CPU_state();
 650   // restore sp
 651   __ mov(rsp, r13);
 652   __ bind(L);
 653 }
 654 
 655 // For each value type argument, sig includes the list of fields of
 656 // the value type. This utility function computes the number of
 657 // arguments for the call if value types are passed by reference (the
 658 // calling convention the interpreter expects).
 659 static int compute_total_args_passed_int(const GrowableArray&lt;SigEntry&gt;* sig_extended) {
 660   int total_args_passed = 0;
 661   if (InlineTypePassFieldsAsArgs) {
 662     for (int i = 0; i &lt; sig_extended-&gt;length(); i++) {
 663       BasicType bt = sig_extended-&gt;at(i)._bt;
 664       if (SigEntry::is_reserved_entry(sig_extended, i)) {
 665         // Ignore reserved entry
<span class="line-modified"> 666       } else if (bt == T_INLINE_TYPE) {</span>
 667         // In sig_extended, a value type argument starts with:
<span class="line-modified"> 668         // T_INLINE_TYPE, followed by the types of the fields of the</span>
 669         // value type and T_VOID to mark the end of the value
 670         // type. Value types are flattened so, for instance, in the
 671         // case of a value type with an int field and a value type
 672         // field that itself has 2 fields, an int and a long:
<span class="line-modified"> 673         // T_INLINE_TYPE T_INT T_INLINE_TYPE T_INT T_LONG T_VOID (second</span>
<span class="line-modified"> 674         // slot for the T_LONG) T_VOID (inner T_INLINE_TYPE) T_VOID</span>
<span class="line-modified"> 675         // (outer T_INLINE_TYPE)</span>
 676         total_args_passed++;
 677         int vt = 1;
 678         do {
 679           i++;
 680           BasicType bt = sig_extended-&gt;at(i)._bt;
 681           BasicType prev_bt = sig_extended-&gt;at(i-1)._bt;
<span class="line-modified"> 682           if (bt == T_INLINE_TYPE) {</span>
 683             vt++;
 684           } else if (bt == T_VOID &amp;&amp;
 685                      prev_bt != T_LONG &amp;&amp;
 686                      prev_bt != T_DOUBLE) {
 687             vt--;
 688           }
 689         } while (vt != 0);
 690       } else {
 691         total_args_passed++;
 692       }
 693     }
 694   } else {
 695     total_args_passed = sig_extended-&gt;length();
 696   }
 697   return total_args_passed;
 698 }
 699 
 700 
 701 static void gen_c2i_adapter_helper(MacroAssembler* masm,
 702                                    BasicType bt,
 703                                    BasicType prev_bt,
 704                                    size_t size_in_bytes,
 705                                    const VMRegPair&amp; reg_pair,
 706                                    const Address&amp; to,
 707                                    int extraspace,
 708                                    bool is_oop) {
<span class="line-modified"> 709   assert(bt != T_INLINE_TYPE || !InlineTypePassFieldsAsArgs, &quot;no inline type here&quot;);</span>
 710   if (bt == T_VOID) {
 711     assert(prev_bt == T_LONG || prev_bt == T_DOUBLE, &quot;missing half&quot;);
 712     return;
 713   }
 714 
 715   // Say 4 args:
 716   // i   st_off
 717   // 0   32 T_LONG
 718   // 1   24 T_VOID
 719   // 2   16 T_OBJECT
 720   // 3    8 T_BOOL
 721   // -    0 return address
 722   //
 723   // However to make thing extra confusing. Because we can fit a long/double in
 724   // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
 725   // leaves one slot empty and only stores to a single slot. In this case the
 726   // slot that is occupied is the T_VOID slot. See I said it was confusing.
 727 
 728   bool wide = (size_in_bytes == wordSize);
 729   VMReg r_1 = reg_pair.first();
</pre>
<hr />
<pre>
 766                             const VMRegPair *regs,
 767                             Label&amp; skip_fixup,
 768                             address start,
 769                             OopMapSet* oop_maps,
 770                             int&amp; frame_complete,
 771                             int&amp; frame_size_in_words,
 772                             bool alloc_value_receiver) {
 773   // Before we get into the guts of the C2I adapter, see if we should be here
 774   // at all.  We&#39;ve come from compiled code and are attempting to jump to the
 775   // interpreter, which means the caller made a static call to get here
 776   // (vcalls always get a compiled target if there is one).  Check for a
 777   // compiled target.  If there is one, we need to patch the caller&#39;s call.
 778   patch_callers_callsite(masm);
 779 
 780   __ bind(skip_fixup);
 781 
 782   if (InlineTypePassFieldsAsArgs) {
 783     // Is there an inline type argument?
 784     bool has_value_argument = false;
 785     for (int i = 0; i &lt; sig_extended-&gt;length() &amp;&amp; !has_value_argument; i++) {
<span class="line-modified"> 786       has_value_argument = (sig_extended-&gt;at(i)._bt == T_INLINE_TYPE);</span>
 787     }
 788     if (has_value_argument) {
 789       // There is at least a value type argument: we&#39;re coming from
 790       // compiled code so we have no buffers to back the value
 791       // types. Allocate the buffers here with a runtime call.
 792       OopMap* map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
 793 
 794       frame_complete = __ offset();
 795 
 796       __ set_last_Java_frame(noreg, noreg, NULL);
 797 
 798       __ mov(c_rarg0, r15_thread);
 799       __ mov(c_rarg1, rbx);
 800       __ mov64(c_rarg2, (int64_t)alloc_value_receiver);
 801       __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::allocate_value_types)));
 802 
 803       oop_maps-&gt;add_gc_map((int)(__ pc() - start), map);
 804       __ reset_last_Java_frame(false);
 805 
 806       RegisterSaver::restore_live_registers(masm);
</pre>
<hr />
<pre>
 829   int extraspace = (total_args_passed * Interpreter::stackElementSize) + wordSize;
 830 
 831   // stack is aligned, keep it that way
 832   extraspace = align_up(extraspace, 2*wordSize);
 833 
 834   // Get return address
 835   __ pop(rax);
 836 
 837   // set senderSP value
 838   __ mov(r13, rsp);
 839 
 840   __ subptr(rsp, extraspace);
 841 
 842   // Store the return address in the expected location
 843   __ movptr(Address(rsp, 0), rax);
 844 
 845   // Now write the args into the outgoing interpreter space
 846 
 847   // next_arg_comp is the next argument from the compiler point of
 848   // view (value type fields are passed in registers/on the stack). In
<span class="line-modified"> 849   // sig_extended, a value type argument starts with: T_INLINE_TYPE,</span>
 850   // followed by the types of the fields of the value type and T_VOID
 851   // to mark the end of the value type. ignored counts the number of
<span class="line-modified"> 852   // T_INLINE_TYPE/T_VOID. next_vt_arg is the next value type argument:</span>
 853   // used to get the buffer for that argument from the pool of buffers
 854   // we allocated above and want to pass to the
 855   // interpreter. next_arg_int is the next argument from the
 856   // interpreter point of view (value types are passed by reference).
 857   for (int next_arg_comp = 0, ignored = 0, next_vt_arg = 0, next_arg_int = 0;
 858        next_arg_comp &lt; sig_extended-&gt;length(); next_arg_comp++) {
 859     assert(ignored &lt;= next_arg_comp, &quot;shouldn&#39;t skip over more slots than there are arguments&quot;);
 860     assert(next_arg_int &lt;= total_args_passed, &quot;more arguments for the interpreter than expected?&quot;);
 861     BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 862     int st_off = (total_args_passed - next_arg_int) * Interpreter::stackElementSize;
<span class="line-modified"> 863     if (!InlineTypePassFieldsAsArgs || bt != T_INLINE_TYPE) {</span>
 864       if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 865         continue; // Ignore reserved entry
 866       }
 867       int next_off = st_off - Interpreter::stackElementSize;
 868       const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;
 869       const VMRegPair reg_pair = regs[next_arg_comp-ignored];
 870       size_t size_in_bytes = reg_pair.second()-&gt;is_valid() ? 8 : 4;
 871       gen_c2i_adapter_helper(masm, bt, next_arg_comp &gt; 0 ? sig_extended-&gt;at(next_arg_comp-1)._bt : T_ILLEGAL,
 872                              size_in_bytes, reg_pair, Address(rsp, offset), extraspace, false);
 873       next_arg_int++;
 874 #ifdef ASSERT
 875       if (bt == T_LONG || bt == T_DOUBLE) {
 876         // Overwrite the unused slot with known junk
 877         __ mov64(rax, CONST64(0xdeadffffdeadaaaa));
 878         __ movptr(Address(rsp, st_off), rax);
 879       }
 880 #endif /* ASSERT */
 881     } else {
 882       ignored++;
 883       // get the buffer from the just allocated pool of buffers
<span class="line-modified"> 884       int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_INLINE_TYPE);</span>
 885       __ load_heap_oop(r14, Address(rscratch2, index));
 886       next_vt_arg++; next_arg_int++;
 887       int vt = 1;
 888       // write fields we get from compiled code in registers/stack
 889       // slots to the buffer: we know we are done with that value type
 890       // argument when we hit the T_VOID that acts as an end of value
 891       // type delimiter for this value type. Value types are flattened
 892       // so we might encounter embedded value types. Each entry in
 893       // sig_extended contains a field offset in the buffer.
 894       do {
 895         next_arg_comp++;
 896         BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 897         BasicType prev_bt = sig_extended-&gt;at(next_arg_comp-1)._bt;
<span class="line-modified"> 898         if (bt == T_INLINE_TYPE) {</span>
 899           vt++;
 900           ignored++;
 901         } else if (bt == T_VOID &amp;&amp;
 902                    prev_bt != T_LONG &amp;&amp;
 903                    prev_bt != T_DOUBLE) {
 904           vt--;
 905           ignored++;
 906         } else if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 907           // Ignore reserved entry
 908         } else {
 909           int off = sig_extended-&gt;at(next_arg_comp)._offset;
 910           assert(off &gt; 0, &quot;offset in object should be positive&quot;);
 911           size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;
 912           bool is_oop = is_reference_type(bt);
 913           gen_c2i_adapter_helper(masm, bt, next_arg_comp &gt; 0 ? sig_extended-&gt;at(next_arg_comp-1)._bt : T_ILLEGAL,
 914                                  size_in_bytes, regs[next_arg_comp-ignored], Address(r14, off), extraspace, is_oop);
 915         }
 916       } while (vt != 0);
 917       // pass the buffer to the interpreter
 918       __ movptr(Address(rsp, st_off), r14);
</pre>
<hr />
<pre>
1034   __ movptr(r11, Address(rbx, in_bytes(Method::from_compiled_value_offset())));
1035 
1036 #if INCLUDE_JVMCI
1037   if (EnableJVMCI || UseAOT) {
1038     // check if this call should be routed towards a specific entry point
1039     __ cmpptr(Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())), 0);
1040     Label no_alternative_target;
1041     __ jcc(Assembler::equal, no_alternative_target);
1042     __ movptr(r11, Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
1043     __ movptr(Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())), 0);
1044     __ bind(no_alternative_target);
1045   }
1046 #endif // INCLUDE_JVMCI
1047 
1048   int total_args_passed = sig-&gt;length();
1049 
1050   // Now generate the shuffle code.  Pick up all register args and move the
1051   // rest through the floating point stack top.
1052   for (int i = 0; i &lt; total_args_passed; i++) {
1053     BasicType bt = sig-&gt;at(i)._bt;
<span class="line-modified">1054     assert(bt != T_INLINE_TYPE, &quot;i2c adapter doesn&#39;t unpack value args&quot;);</span>
1055     if (bt == T_VOID) {
1056       // Longs and doubles are passed in native word order, but misaligned
1057       // in the 32-bit build.
1058       BasicType prev_bt = (i &gt; 0) ? sig-&gt;at(i-1)._bt : T_ILLEGAL;
1059       assert(i &gt; 0 &amp;&amp; (prev_bt == T_LONG || prev_bt == T_DOUBLE), &quot;missing half&quot;);
1060       continue;
1061     }
1062 
1063     // Pick up 0, 1 or 2 words from SP+offset.
1064 
1065     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(),
1066             &quot;scrambled load targets?&quot;);
1067     // Load in argument order going down.
1068     int ld_off = (total_args_passed - i)*Interpreter::stackElementSize;
1069     // Point to interpreter value (vs. tag)
1070     int next_off = ld_off - Interpreter::stackElementSize;
1071     //
1072     //
1073     //
1074     VMReg r_1 = regs[i].first();
</pre>
<hr />
<pre>
1305       case T_BYTE:
1306       case T_SHORT:
1307       case T_INT:
1308         if (int_args &lt; Argument::n_int_register_parameters_c) {
1309           regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
1310 #ifdef _WIN64
1311           fp_args++;
1312           // Allocate slots for callee to stuff register args the stack.
1313           stk_args += 2;
1314 #endif
1315         } else {
1316           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1317           stk_args += 2;
1318         }
1319         break;
1320       case T_LONG:
1321         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1322         // fall through
1323       case T_OBJECT:
1324       case T_ARRAY:
<span class="line-modified">1325       case T_INLINE_TYPE:</span>
1326       case T_ADDRESS:
1327       case T_METADATA:
1328         if (int_args &lt; Argument::n_int_register_parameters_c) {
1329           regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
1330 #ifdef _WIN64
1331           fp_args++;
1332           stk_args += 2;
1333 #endif
1334         } else {
1335           regs[i].set2(VMRegImpl::stack2reg(stk_args));
1336           stk_args += 2;
1337         }
1338         break;
1339       case T_FLOAT:
1340         if (fp_args &lt; Argument::n_float_register_parameters_c) {
1341           regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
1342 #ifdef _WIN64
1343           int_args++;
1344           // Allocate slots for callee to stuff register args the stack.
1345           stk_args += 2;
</pre>
<hr />
<pre>
1690 
1691       // Value is in an input register pass we must flush it to the stack
1692       const Register reg = in_regs[i].first()-&gt;as_Register();
1693       switch (in_sig_bt[i]) {
1694         case T_BOOLEAN:
1695         case T_CHAR:
1696         case T_BYTE:
1697         case T_SHORT:
1698         case T_INT:
1699           if (map != NULL) {
1700             __ movl(Address(rsp, offset), reg);
1701           } else {
1702             __ movl(reg, Address(rsp, offset));
1703           }
1704           break;
1705         case T_ARRAY:
1706         case T_LONG:
1707           // handled above
1708           break;
1709         case T_OBJECT:
<span class="line-modified">1710         case T_INLINE_TYPE:</span>
1711         default: ShouldNotReachHere();
1712       }
1713     } else if (in_regs[i].first()-&gt;is_XMMRegister()) {
1714       if (in_sig_bt[i] == T_FLOAT) {
1715         int offset = slot * VMRegImpl::stack_slot_size;
1716         slot++;
1717         assert(slot &lt;= stack_slots, &quot;overflow&quot;);
1718         if (map != NULL) {
1719           __ movflt(Address(rsp, offset), in_regs[i].first()-&gt;as_XMMRegister());
1720         } else {
1721           __ movflt(in_regs[i].first()-&gt;as_XMMRegister(), Address(rsp, offset));
1722         }
1723       }
1724     } else if (in_regs[i].first()-&gt;is_stack()) {
1725       if (in_sig_bt[i] == T_ARRAY &amp;&amp; map != NULL) {
1726         int offset_in_older_frame = in_regs[i].first()-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
1727         map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + stack_slots));
1728       }
1729     }
1730   }
</pre>
<hr />
<pre>
2604             VMRegPair result_reg;
2605             result_reg.set_ptr(rax-&gt;as_VMReg());
2606             move_ptr(masm, result_reg, in_regs[i]);
2607             if (!in_regs[i].first()-&gt;is_stack()) {
2608               assert(pinned_slot &lt;= stack_slots, &quot;overflow&quot;);
2609               move_ptr(masm, result_reg, VMRegImpl::stack2reg(pinned_slot));
2610               pinned_slot += VMRegImpl::slots_per_word;
2611             }
2612           }
2613           unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
2614           c_arg++;
2615 #ifdef ASSERT
2616           if (out_regs[c_arg].first()-&gt;is_Register()) {
2617             reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
2618           } else if (out_regs[c_arg].first()-&gt;is_XMMRegister()) {
2619             freg_destroyed[out_regs[c_arg].first()-&gt;as_XMMRegister()-&gt;encoding()] = true;
2620           }
2621 #endif
2622           break;
2623         }
<span class="line-modified">2624       case T_INLINE_TYPE:</span>
2625       case T_OBJECT:
2626         assert(!is_critical_native, &quot;no oop arguments&quot;);
2627         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
2628                     ((i == 0) &amp;&amp; (!is_static)),
2629                     &amp;receiver_offset);
2630         break;
2631       case T_VOID:
2632         break;
2633 
2634       case T_FLOAT:
2635         float_move(masm, in_regs[i], out_regs[c_arg]);
2636           break;
2637 
2638       case T_DOUBLE:
2639         assert( i + 1 &lt; total_in_args &amp;&amp;
2640                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
2641                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
2642         double_move(masm, in_regs[i], out_regs[c_arg]);
2643         break;
2644 
</pre>
<hr />
<pre>
2805   // Now set thread in native
2806   __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);
2807 
2808   __ call(RuntimeAddress(native_func));
2809 
2810   // Verify or restore cpu control state after JNI call
2811   __ restore_cpu_control_state_after_jni();
2812 
2813   // Unpack native results.
2814   switch (ret_type) {
2815   case T_BOOLEAN: __ c2bool(rax);            break;
2816   case T_CHAR   : __ movzwl(rax, rax);      break;
2817   case T_BYTE   : __ sign_extend_byte (rax); break;
2818   case T_SHORT  : __ sign_extend_short(rax); break;
2819   case T_INT    : /* nothing to do */        break;
2820   case T_DOUBLE :
2821   case T_FLOAT  :
2822     // Result is in xmm0 we&#39;ll save as needed
2823     break;
2824   case T_ARRAY:                 // Really a handle
<span class="line-modified">2825   case T_INLINE_TYPE:           // Really a handle</span>
2826   case T_OBJECT:                // Really a handle
2827       break; // can&#39;t de-handlize until after safepoint check
2828   case T_VOID: break;
2829   case T_LONG: break;
2830   default       : ShouldNotReachHere();
2831   }
2832 
2833   // unpin pinned arguments
2834   pinned_slot = oop_handle_offset;
2835   if (pinned_args.length() &gt; 0) {
2836     // save return value that may be overwritten otherwise.
2837     save_native_result(masm, ret_type, stack_slots);
2838     for (int index = 0; index &lt; pinned_args.length(); index ++) {
2839       int i = pinned_args.at(index);
2840       assert(pinned_slot &lt;= stack_slots, &quot;overflow&quot;);
2841       if (!in_regs[i].first()-&gt;is_stack()) {
2842         int offset = pinned_slot * VMRegImpl::stack_slot_size;
2843         __ movq(in_regs[i].first()-&gt;as_Register(), Address(rsp, offset));
2844         pinned_slot += VMRegImpl::slots_per_word;
2845       }
</pre>
<hr />
<pre>
4332 
4333   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
4334 
4335   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();
4336   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();
4337 
4338   int pack_fields_jobject_off = __ offset();
4339   // Resolve pre-allocated buffer from JNI handle.
4340   // We cannot do this in generate_call_stub() because it requires GC code to be initialized.
4341   __ movptr(rax, Address(r13, 0));
4342   __ resolve_jobject(rax /* value */,
4343                      r15_thread /* thread */,
4344                      r12 /* tmp */);
4345   __ movptr(Address(r13, 0), rax);
4346 
4347   int pack_fields_off = __ offset();
4348 
4349   int j = 1;
4350   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
4351     BasicType bt = sig_vk-&gt;at(i)._bt;
<span class="line-modified">4352     if (bt == T_INLINE_TYPE) {</span>
4353       continue;
4354     }
4355     if (bt == T_VOID) {
4356       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||
4357           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {
4358         j++;
4359       }
4360       continue;
4361     }
4362     int off = sig_vk-&gt;at(i)._offset;
4363     assert(off &gt; 0, &quot;offset in object should be positive&quot;);
4364     VMRegPair pair = regs-&gt;at(j);
4365     VMReg r_1 = pair.first();
4366     VMReg r_2 = pair.second();
4367     Address to(rax, off);
4368     if (bt == T_FLOAT) {
4369       __ movflt(to, r_1-&gt;as_XMMRegister());
4370     } else if (bt == T_DOUBLE) {
4371       __ movdbl(to, r_1-&gt;as_XMMRegister());
4372     } else {
4373       Register val = r_1-&gt;as_Register();
4374       assert_different_registers(to.base(), val, r14, r13, rbx, rscratch1);
4375       if (is_reference_type(bt)) {
4376         __ store_heap_oop(to, val, r14, r13, rbx, IN_HEAP | ACCESS_WRITE | IS_DEST_UNINITIALIZED);
4377       } else {
4378         __ store_sized_value(to, r_1-&gt;as_Register(), type2aelembytes(bt));
4379       }
4380     }
4381     j++;
4382   }
4383   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
4384 
4385   __ ret(0);
4386 
4387   int unpack_fields_off = __ offset();
4388 
4389   j = 1;
4390   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
4391     BasicType bt = sig_vk-&gt;at(i)._bt;
<span class="line-modified">4392     if (bt == T_INLINE_TYPE) {</span>
4393       continue;
4394     }
4395     if (bt == T_VOID) {
4396       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||
4397           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {
4398         j++;
4399       }
4400       continue;
4401     }
4402     int off = sig_vk-&gt;at(i)._offset;
4403     assert(off &gt; 0, &quot;offset in object should be positive&quot;);
4404     VMRegPair pair = regs-&gt;at(j);
4405     VMReg r_1 = pair.first();
4406     VMReg r_2 = pair.second();
4407     Address from(rax, off);
4408     if (bt == T_FLOAT) {
4409       __ movflt(r_1-&gt;as_XMMRegister(), from);
4410     } else if (bt == T_DOUBLE) {
4411       __ movdbl(r_1-&gt;as_XMMRegister(), from);
4412     } else if (bt == T_OBJECT || bt == T_ARRAY) {
</pre>
</td>
</tr>
</table>
<center><a href="sharedRuntime_x86_32.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
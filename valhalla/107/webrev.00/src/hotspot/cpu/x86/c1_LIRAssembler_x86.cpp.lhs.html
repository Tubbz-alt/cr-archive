<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;ci/ciValueKlass.hpp&quot;
  36 #include &quot;gc/shared/collectedHeap.hpp&quot;
  37 #include &quot;nativeInst_x86.hpp&quot;
  38 #include &quot;oops/oop.inline.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;runtime/frame.inline.hpp&quot;
  41 #include &quot;runtime/safepointMechanism.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;utilities/powerOfTwo.hpp&quot;
  44 #include &quot;vmreg_x86.inline.hpp&quot;
  45 
  46 
  47 // These masks are used to provide 128-bit aligned bitmasks to the XMM
  48 // instructions, to allow sign-masking or sign-bit flipping.  They allow
  49 // fast versions of NegF/NegD and AbsF/AbsD.
  50 
  51 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
  52 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
  53   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
  54   // of 128-bits operands for SSE instructions.
  55   jlong *operand = (jlong*)(((intptr_t)adr) &amp; ((intptr_t)(~0xF)));
  56   // Store the value to a 128-bits operand.
  57   operand[0] = lo;
  58   operand[1] = hi;
  59   return operand;
  60 }
  61 
  62 // Buffer for 128-bits masks used by SSE instructions.
  63 static jlong fp_signmask_pool[(4+1)*2]; // 4*128bits(data) + 128bits(alignment)
  64 
  65 // Static initialization during VM startup.
  66 static jlong *float_signmask_pool  = double_quadword(&amp;fp_signmask_pool[1*2],         CONST64(0x7FFFFFFF7FFFFFFF),         CONST64(0x7FFFFFFF7FFFFFFF));
  67 static jlong *double_signmask_pool = double_quadword(&amp;fp_signmask_pool[2*2],         CONST64(0x7FFFFFFFFFFFFFFF),         CONST64(0x7FFFFFFFFFFFFFFF));
  68 static jlong *float_signflip_pool  = double_quadword(&amp;fp_signmask_pool[3*2], (jlong)UCONST64(0x8000000080000000), (jlong)UCONST64(0x8000000080000000));
  69 static jlong *double_signflip_pool = double_quadword(&amp;fp_signmask_pool[4*2], (jlong)UCONST64(0x8000000000000000), (jlong)UCONST64(0x8000000000000000));
  70 
  71 
  72 NEEDS_CLEANUP // remove this definitions ?
  73 const Register IC_Klass    = rax;   // where the IC klass is cached
  74 const Register SYNC_header = rax;   // synchronization header
  75 const Register SHIFT_count = rcx;   // where count for shift operations must be
  76 
  77 #define __ _masm-&gt;
  78 
  79 
  80 static void select_different_registers(Register preserve,
  81                                        Register extra,
  82                                        Register &amp;tmp1,
  83                                        Register &amp;tmp2) {
  84   if (tmp1 == preserve) {
  85     assert_different_registers(tmp1, tmp2, extra);
  86     tmp1 = extra;
  87   } else if (tmp2 == preserve) {
  88     assert_different_registers(tmp1, tmp2, extra);
  89     tmp2 = extra;
  90   }
  91   assert_different_registers(preserve, tmp1, tmp2);
  92 }
  93 
  94 
  95 
  96 static void select_different_registers(Register preserve,
  97                                        Register extra,
  98                                        Register &amp;tmp1,
  99                                        Register &amp;tmp2,
 100                                        Register &amp;tmp3) {
 101   if (tmp1 == preserve) {
 102     assert_different_registers(tmp1, tmp2, tmp3, extra);
 103     tmp1 = extra;
 104   } else if (tmp2 == preserve) {
 105     assert_different_registers(tmp1, tmp2, tmp3, extra);
 106     tmp2 = extra;
 107   } else if (tmp3 == preserve) {
 108     assert_different_registers(tmp1, tmp2, tmp3, extra);
 109     tmp3 = extra;
 110   }
 111   assert_different_registers(preserve, tmp1, tmp2, tmp3);
 112 }
 113 
 114 
 115 
 116 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
 117   if (opr-&gt;is_constant()) {
 118     LIR_Const* constant = opr-&gt;as_constant_ptr();
 119     switch (constant-&gt;type()) {
 120       case T_INT: {
 121         return true;
 122       }
 123 
 124       default:
 125         return false;
 126     }
 127   }
 128   return false;
 129 }
 130 
 131 
 132 LIR_Opr LIR_Assembler::receiverOpr() {
 133   return FrameMap::receiver_opr;
 134 }
 135 
 136 LIR_Opr LIR_Assembler::osrBufferPointer() {
 137   return FrameMap::as_pointer_opr(receiverOpr()-&gt;as_register());
 138 }
 139 
 140 //--------------fpu register translations-----------------------
 141 
 142 
 143 address LIR_Assembler::float_constant(float f) {
 144   address const_addr = __ float_constant(f);
 145   if (const_addr == NULL) {
 146     bailout(&quot;const section overflow&quot;);
 147     return __ code()-&gt;consts()-&gt;start();
 148   } else {
 149     return const_addr;
 150   }
 151 }
 152 
 153 
 154 address LIR_Assembler::double_constant(double d) {
 155   address const_addr = __ double_constant(d);
 156   if (const_addr == NULL) {
 157     bailout(&quot;const section overflow&quot;);
 158     return __ code()-&gt;consts()-&gt;start();
 159   } else {
 160     return const_addr;
 161   }
 162 }
 163 
 164 #ifndef _LP64
 165 void LIR_Assembler::fpop() {
 166   __ fpop();
 167 }
 168 
 169 void LIR_Assembler::fxch(int i) {
 170   __ fxch(i);
 171 }
 172 
 173 void LIR_Assembler::fld(int i) {
 174   __ fld_s(i);
 175 }
 176 
 177 void LIR_Assembler::ffree(int i) {
 178   __ ffree(i);
 179 }
 180 #endif // !_LP64
 181 
 182 void LIR_Assembler::breakpoint() {
 183   __ int3();
 184 }
 185 
 186 void LIR_Assembler::push(LIR_Opr opr) {
 187   if (opr-&gt;is_single_cpu()) {
 188     __ push_reg(opr-&gt;as_register());
 189   } else if (opr-&gt;is_double_cpu()) {
 190     NOT_LP64(__ push_reg(opr-&gt;as_register_hi()));
 191     __ push_reg(opr-&gt;as_register_lo());
 192   } else if (opr-&gt;is_stack()) {
 193     __ push_addr(frame_map()-&gt;address_for_slot(opr-&gt;single_stack_ix()));
 194   } else if (opr-&gt;is_constant()) {
 195     LIR_Const* const_opr = opr-&gt;as_constant_ptr();
<a name="1" id="anc1"></a><span class="line-modified"> 196     if (const_opr-&gt;type() == T_OBJECT || const_opr-&gt;type() == T_VALUETYPE) {</span>
 197       __ push_oop(const_opr-&gt;as_jobject());
 198     } else if (const_opr-&gt;type() == T_INT) {
 199       __ push_jint(const_opr-&gt;as_jint());
 200     } else {
 201       ShouldNotReachHere();
 202     }
 203 
 204   } else {
 205     ShouldNotReachHere();
 206   }
 207 }
 208 
 209 void LIR_Assembler::pop(LIR_Opr opr) {
 210   if (opr-&gt;is_single_cpu()) {
 211     __ pop_reg(opr-&gt;as_register());
 212   } else {
 213     ShouldNotReachHere();
 214   }
 215 }
 216 
 217 bool LIR_Assembler::is_literal_address(LIR_Address* addr) {
 218   return addr-&gt;base()-&gt;is_illegal() &amp;&amp; addr-&gt;index()-&gt;is_illegal();
 219 }
 220 
 221 //-------------------------------------------
 222 
 223 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 224   return as_Address(addr, rscratch1);
 225 }
 226 
 227 Address LIR_Assembler::as_Address(LIR_Address* addr, Register tmp) {
 228   if (addr-&gt;base()-&gt;is_illegal()) {
 229     assert(addr-&gt;index()-&gt;is_illegal(), &quot;must be illegal too&quot;);
 230     AddressLiteral laddr((address)addr-&gt;disp(), relocInfo::none);
 231     if (! __ reachable(laddr)) {
 232       __ movptr(tmp, laddr.addr());
 233       Address res(tmp, 0);
 234       return res;
 235     } else {
 236       return __ as_Address(laddr);
 237     }
 238   }
 239 
 240   Register base = addr-&gt;base()-&gt;as_pointer_register();
 241 
 242   if (addr-&gt;index()-&gt;is_illegal()) {
 243     return Address( base, addr-&gt;disp());
 244   } else if (addr-&gt;index()-&gt;is_cpu_register()) {
 245     Register index = addr-&gt;index()-&gt;as_pointer_register();
 246     return Address(base, index, (Address::ScaleFactor) addr-&gt;scale(), addr-&gt;disp());
 247   } else if (addr-&gt;index()-&gt;is_constant()) {
 248     intptr_t addr_offset = (addr-&gt;index()-&gt;as_constant_ptr()-&gt;as_jint() &lt;&lt; addr-&gt;scale()) + addr-&gt;disp();
 249     assert(Assembler::is_simm32(addr_offset), &quot;must be&quot;);
 250 
 251     return Address(base, addr_offset);
 252   } else {
 253     Unimplemented();
 254     return Address();
 255   }
 256 }
 257 
 258 
 259 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
 260   Address base = as_Address(addr);
 261   return Address(base._base, base._index, base._scale, base._disp + BytesPerWord);
 262 }
 263 
 264 
 265 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 266   return as_Address(addr);
 267 }
 268 
 269 
 270 void LIR_Assembler::osr_entry() {
 271   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 272   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 273   ValueStack* entry_state = osr_entry-&gt;state();
 274   int number_of_locks = entry_state-&gt;locks_size();
 275 
 276   // we jump here if osr happens with the interpreter
 277   // state set up to continue at the beginning of the
 278   // loop that triggered osr - in particular, we have
 279   // the following registers setup:
 280   //
 281   // rcx: osr buffer
 282   //
 283 
 284   // build frame
 285   ciMethod* m = compilation()-&gt;method();
 286   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 287 
 288   // OSR buffer is
 289   //
 290   // locals[nlocals-1..0]
 291   // monitors[0..number_of_locks]
 292   //
 293   // locals is a direct copy of the interpreter frame so in the osr buffer
 294   // so first slot in the local array is the last local from the interpreter
 295   // and last slot is local[0] (receiver) from the interpreter
 296   //
 297   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 298   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 299   // in the interpreter frame (the method lock if a sync method)
 300 
 301   // Initialize monitors in the compiled activation.
 302   //   rcx: pointer to osr buffer
 303   //
 304   // All other registers are dead at this point and the locals will be
 305   // copied into place by code emitted in the IR.
 306 
 307   Register OSR_buf = osrBufferPointer()-&gt;as_pointer_register();
 308   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 309     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 310       (BasicObjectLock::size() * BytesPerWord) * (number_of_locks - 1);
 311     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 312     // the OSR buffer using 2 word entries: first the lock and then
 313     // the oop.
 314     for (int i = 0; i &lt; number_of_locks; i++) {
 315       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 316 #ifdef ASSERT
 317       // verify the interpreter&#39;s monitor has a non-null object
 318       {
 319         Label L;
 320         __ cmpptr(Address(OSR_buf, slot_offset + 1*BytesPerWord), (int32_t)NULL_WORD);
 321         __ jcc(Assembler::notZero, L);
 322         __ stop(&quot;locked object is NULL&quot;);
 323         __ bind(L);
 324       }
 325 #endif
 326       __ movptr(rbx, Address(OSR_buf, slot_offset + 0));
 327       __ movptr(frame_map()-&gt;address_for_monitor_lock(i), rbx);
 328       __ movptr(rbx, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 329       __ movptr(frame_map()-&gt;address_for_monitor_object(i), rbx);
 330     }
 331   }
 332 }
 333 
 334 
 335 // inline cache check; done before the frame is built.
 336 int LIR_Assembler::check_icache() {
 337   Register receiver = FrameMap::receiver_opr-&gt;as_register();
 338   Register ic_klass = IC_Klass;
 339   const int ic_cmp_size = LP64_ONLY(10) NOT_LP64(9);
 340   const bool do_post_padding = VerifyOops || UseCompressedClassPointers;
 341   if (!do_post_padding) {
 342     // insert some nops so that the verified entry point is aligned on CodeEntryAlignment
 343     __ align(CodeEntryAlignment, __ offset() + ic_cmp_size);
 344   }
 345   int offset = __ offset();
 346   __ inline_cache_check(receiver, IC_Klass);
 347   assert(__ offset() % CodeEntryAlignment == 0 || do_post_padding, &quot;alignment must be correct&quot;);
 348   if (do_post_padding) {
 349     // force alignment after the cache check.
 350     // It&#39;s been verified to be aligned if !VerifyOops
 351     __ align(CodeEntryAlignment);
 352   }
 353   return offset;
 354 }
 355 
 356 void LIR_Assembler::clinit_barrier(ciMethod* method) {
 357   assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
 358   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 359 
 360   Label L_skip_barrier;
 361   Register klass = rscratch1;
 362   Register thread = LP64_ONLY( r15_thread ) NOT_LP64( noreg );
 363   assert(thread != noreg, &quot;x86_32 not implemented&quot;);
 364 
 365   __ mov_metadata(klass, method-&gt;holder()-&gt;constant_encoding());
 366   __ clinit_barrier(klass, thread, &amp;L_skip_barrier /*L_fast_path*/);
 367 
 368   __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
 369 
 370   __ bind(L_skip_barrier);
 371 }
 372 
 373 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo* info) {
 374   jobject o = NULL;
 375   PatchingStub* patch = new PatchingStub(_masm, patching_id(info));
 376   __ movoop(reg, o);
 377   patching_epilog(patch, lir_patch_normal, reg, info);
 378 }
 379 
 380 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo* info) {
 381   Metadata* o = NULL;
 382   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id);
 383   __ mov_metadata(reg, o);
 384   patching_epilog(patch, lir_patch_normal, reg, info);
 385 }
 386 
 387 // This specifies the rsp decrement needed to build the frame
 388 int LIR_Assembler::initial_frame_size_in_bytes() const {
 389   // if rounding, must let FrameMap know!
 390 
 391   // The frame_map records size in slots (32bit word)
 392 
 393   // subtract two words to account for return address and link
 394   return (frame_map()-&gt;framesize() - (2*VMRegImpl::slots_per_word))  * VMRegImpl::stack_slot_size;
 395 }
 396 
 397 
 398 int LIR_Assembler::emit_exception_handler() {
 399   // if the last instruction is a call (typically to do a throw which
 400   // is coming at the end after block reordering) the return address
 401   // must still point into the code area in order to avoid assertion
 402   // failures when searching for the corresponding bci =&gt; add a nop
 403   // (was bug 5/14/1999 - gri)
 404   __ nop();
 405 
 406   // generate code for exception handler
 407   address handler_base = __ start_a_stub(exception_handler_size());
 408   if (handler_base == NULL) {
 409     // not enough space left for the handler
 410     bailout(&quot;exception handler overflow&quot;);
 411     return -1;
 412   }
 413 
 414   int offset = code_offset();
 415 
 416   // the exception oop and pc are in rax, and rdx
 417   // no other registers need to be preserved, so invalidate them
 418   __ invalidate_registers(false, true, true, false, true, true);
 419 
 420   // check that there is really an exception
 421   __ verify_not_null_oop(rax);
 422 
 423   // search an exception handler (rax: exception oop, rdx: throwing pc)
 424   __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id)));
 425   __ should_not_reach_here();
 426   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 427   __ end_a_stub();
 428 
 429   return offset;
 430 }
 431 
 432 
 433 // Emit the code to remove the frame from the stack in the exception
 434 // unwind path.
 435 int LIR_Assembler::emit_unwind_handler() {
 436 #ifndef PRODUCT
 437   if (CommentedAssembly) {
 438     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 439   }
 440 #endif
 441 
 442   int offset = code_offset();
 443 
 444   // Fetch the exception from TLS and clear out exception related thread state
 445   Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
 446   NOT_LP64(__ get_thread(rsi));
 447   __ movptr(rax, Address(thread, JavaThread::exception_oop_offset()));
 448   __ movptr(Address(thread, JavaThread::exception_oop_offset()), (intptr_t)NULL_WORD);
 449   __ movptr(Address(thread, JavaThread::exception_pc_offset()), (intptr_t)NULL_WORD);
 450 
 451   __ bind(_unwind_handler_entry);
 452   __ verify_not_null_oop(rax);
 453   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 454     __ mov(rbx, rax);  // Preserve the exception (rbx is always callee-saved)
 455   }
 456 
 457   // Preform needed unlocking
 458   MonitorExitStub* stub = NULL;
 459   if (method()-&gt;is_synchronized()) {
 460     monitor_address(0, FrameMap::rax_opr);
 461     stub = new MonitorExitStub(FrameMap::rax_opr, true, 0);
 462     __ unlock_object(rdi, rsi, rax, *stub-&gt;entry());
 463     __ bind(*stub-&gt;continuation());
 464   }
 465 
 466   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 467 #ifdef _LP64
 468     __ mov(rdi, r15_thread);
 469     __ mov_metadata(rsi, method()-&gt;constant_encoding());
 470 #else
 471     __ get_thread(rax);
 472     __ movptr(Address(rsp, 0), rax);
 473     __ mov_metadata(Address(rsp, sizeof(void*)), method()-&gt;constant_encoding());
 474 #endif
 475     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit)));
 476   }
 477 
 478   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 479     __ mov(rax, rbx);  // Restore the exception
 480   }
 481 
 482   // remove the activation and dispatch to the unwind handler
 483   int initial_framesize = initial_frame_size_in_bytes();
 484   __ remove_frame(initial_framesize, needs_stack_repair(), initial_framesize - wordSize);
 485   __ jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
 486 
 487   // Emit the slow path assembly
 488   if (stub != NULL) {
 489     stub-&gt;emit_code(this);
 490   }
 491 
 492   return offset;
 493 }
 494 
 495 
 496 int LIR_Assembler::emit_deopt_handler() {
 497   // if the last instruction is a call (typically to do a throw which
 498   // is coming at the end after block reordering) the return address
 499   // must still point into the code area in order to avoid assertion
 500   // failures when searching for the corresponding bci =&gt; add a nop
 501   // (was bug 5/14/1999 - gri)
 502   __ nop();
 503 
 504   // generate code for exception handler
 505   address handler_base = __ start_a_stub(deopt_handler_size());
 506   if (handler_base == NULL) {
 507     // not enough space left for the handler
 508     bailout(&quot;deopt handler overflow&quot;);
 509     return -1;
 510   }
 511 
 512   int offset = code_offset();
 513   InternalAddress here(__ pc());
 514 
 515   __ pushptr(here.addr());
 516   __ jump(RuntimeAddress(SharedRuntime::deopt_blob()-&gt;unpack()));
 517   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 518   __ end_a_stub();
 519 
 520   return offset;
 521 }
 522 
 523 
 524 void LIR_Assembler::return_op(LIR_Opr result) {
 525   assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == rax, &quot;word returns are in rax,&quot;);
 526   if (!result-&gt;is_illegal() &amp;&amp; result-&gt;is_float_kind() &amp;&amp; !result-&gt;is_xmm_register()) {
 527     assert(result-&gt;fpu() == 0, &quot;result must already be on TOS&quot;);
 528   }
 529 
 530   ciMethod* method = compilation()-&gt;method();
 531   if (InlineTypeReturnedAsFields &amp;&amp; method-&gt;signature()-&gt;returns_never_null()) {
 532     ciType* return_type = method-&gt;return_type();
 533     if (return_type-&gt;is_valuetype()) {
 534       ciValueKlass* vk = return_type-&gt;as_value_klass();
 535       if (vk-&gt;can_be_returned_as_fields()) {
 536 #ifndef _LP64
 537         Unimplemented();
 538 #else
 539         address unpack_handler = vk-&gt;unpack_handler();
 540         assert(unpack_handler != NULL, &quot;must be&quot;);
 541         __ call(RuntimeAddress(unpack_handler));
 542         // At this point, rax points to the value object (for interpreter or C1 caller).
 543         // The fields of the object are copied into registers (for C2 caller).
 544 #endif
 545       }
 546     }
 547   }
 548 
 549   // Pop the stack before the safepoint code
 550   int initial_framesize = initial_frame_size_in_bytes();
 551   __ remove_frame(initial_framesize, needs_stack_repair(), initial_framesize - wordSize);
 552 
 553   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 554     __ reserved_stack_check();
 555   }
 556 
 557   bool result_is_oop = result-&gt;is_valid() ? result-&gt;is_oop() : false;
 558 
 559   // Note: we do not need to round double result; float result has the right precision
 560   // the poll sets the condition code, but no data registers
 561 
 562 #ifdef _LP64
 563   const Register poll_addr = rscratch1;
 564   __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 565 #else
 566   const Register poll_addr = rbx;
 567   assert(FrameMap::is_caller_save_register(poll_addr), &quot;will overwrite&quot;);
 568   __ get_thread(poll_addr);
 569   __ movptr(poll_addr, Address(poll_addr, Thread::polling_page_offset()));
 570 #endif
 571   __ relocate(relocInfo::poll_return_type);
 572   __ testl(rax, Address(poll_addr, 0));
 573   __ ret(0);
 574 }
 575 
 576 
 577 int LIR_Assembler::store_value_type_fields_to_buf(ciValueKlass* vk) {
 578   return (__ store_value_type_fields_to_buf(vk, false));
 579 }
 580 
 581 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 582   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 583   int offset = __ offset();
 584 #ifdef _LP64
 585   const Register poll_addr = rscratch1;
 586   __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 587 #else
 588   assert(tmp-&gt;is_cpu_register(), &quot;needed&quot;);
 589   const Register poll_addr = tmp-&gt;as_register();
 590   __ get_thread(poll_addr);
 591   __ movptr(poll_addr, Address(poll_addr, in_bytes(Thread::polling_page_offset())));
 592 #endif
 593   add_debug_info_for_branch(info);
 594   __ relocate(relocInfo::poll_type);
 595   address pre_pc = __ pc();
 596   __ testl(rax, Address(poll_addr, 0));
 597   address post_pc = __ pc();
 598   guarantee(pointer_delta(post_pc, pre_pc, 1) == 2 LP64_ONLY(+1), &quot;must be exact length&quot;);
 599   return offset;
 600 }
 601 
 602 
 603 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 604   if (from_reg != to_reg) __ mov(to_reg, from_reg);
 605 }
 606 
 607 void LIR_Assembler::swap_reg(Register a, Register b) {
 608   __ xchgptr(a, b);
 609 }
 610 
 611 
 612 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 613   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 614   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 615   LIR_Const* c = src-&gt;as_constant_ptr();
 616 
 617   switch (c-&gt;type()) {
 618     case T_INT: {
 619       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 620       __ movl(dest-&gt;as_register(), c-&gt;as_jint());
 621       break;
 622     }
 623 
 624     case T_ADDRESS: {
 625       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 626       __ movptr(dest-&gt;as_register(), c-&gt;as_jint());
 627       break;
 628     }
 629 
 630     case T_LONG: {
 631       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 632 #ifdef _LP64
 633       __ movptr(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 634 #else
 635       __ movptr(dest-&gt;as_register_lo(), c-&gt;as_jint_lo());
 636       __ movptr(dest-&gt;as_register_hi(), c-&gt;as_jint_hi());
 637 #endif // _LP64
 638       break;
 639     }
 640 
<a name="2" id="anc2"></a><span class="line-modified"> 641     case T_VALUETYPE: // Fall through</span>
 642     case T_OBJECT: {
 643       if (patch_code != lir_patch_none) {
 644         jobject2reg_with_patching(dest-&gt;as_register(), info);
 645       } else {
 646         __ movoop(dest-&gt;as_register(), c-&gt;as_jobject());
 647       }
 648       break;
 649     }
 650 
 651     case T_METADATA: {
 652       if (patch_code != lir_patch_none) {
 653         klass2reg_with_patching(dest-&gt;as_register(), info);
 654       } else {
 655         __ mov_metadata(dest-&gt;as_register(), c-&gt;as_metadata());
 656       }
 657       break;
 658     }
 659 
 660     case T_FLOAT: {
 661       if (dest-&gt;is_single_xmm()) {
 662         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_float()) {
 663           __ xorps(dest-&gt;as_xmm_float_reg(), dest-&gt;as_xmm_float_reg());
 664         } else {
 665           __ movflt(dest-&gt;as_xmm_float_reg(),
 666                    InternalAddress(float_constant(c-&gt;as_jfloat())));
 667         }
 668       } else {
 669 #ifndef _LP64
 670         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
 671         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
 672         if (c-&gt;is_zero_float()) {
 673           __ fldz();
 674         } else if (c-&gt;is_one_float()) {
 675           __ fld1();
 676         } else {
 677           __ fld_s (InternalAddress(float_constant(c-&gt;as_jfloat())));
 678         }
 679 #else
 680         ShouldNotReachHere();
 681 #endif // !_LP64
 682       }
 683       break;
 684     }
 685 
 686     case T_DOUBLE: {
 687       if (dest-&gt;is_double_xmm()) {
 688         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_double()) {
 689           __ xorpd(dest-&gt;as_xmm_double_reg(), dest-&gt;as_xmm_double_reg());
 690         } else {
 691           __ movdbl(dest-&gt;as_xmm_double_reg(),
 692                     InternalAddress(double_constant(c-&gt;as_jdouble())));
 693         }
 694       } else {
 695 #ifndef _LP64
 696         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
 697         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
 698         if (c-&gt;is_zero_double()) {
 699           __ fldz();
 700         } else if (c-&gt;is_one_double()) {
 701           __ fld1();
 702         } else {
 703           __ fld_d (InternalAddress(double_constant(c-&gt;as_jdouble())));
 704         }
 705 #else
 706         ShouldNotReachHere();
 707 #endif // !_LP64
 708       }
 709       break;
 710     }
 711 
 712     default:
 713       ShouldNotReachHere();
 714   }
 715 }
 716 
 717 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 718   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 719   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 720   LIR_Const* c = src-&gt;as_constant_ptr();
 721 
 722   switch (c-&gt;type()) {
 723     case T_INT:  // fall through
 724     case T_FLOAT:
 725       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 726       break;
 727 
 728     case T_ADDRESS:
 729       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 730       break;
 731 
<a name="3" id="anc3"></a><span class="line-modified"> 732     case T_VALUETYPE: // Fall through</span>
 733     case T_OBJECT:
 734       __ movoop(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jobject());
 735       break;
 736 
 737     case T_LONG:  // fall through
 738     case T_DOUBLE:
 739 #ifdef _LP64
 740       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 741                                             lo_word_offset_in_bytes), (intptr_t)c-&gt;as_jlong_bits());
 742 #else
 743       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 744                                               lo_word_offset_in_bytes), c-&gt;as_jint_lo_bits());
 745       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 746                                               hi_word_offset_in_bytes), c-&gt;as_jint_hi_bits());
 747 #endif // _LP64
 748       break;
 749 
 750     default:
 751       ShouldNotReachHere();
 752   }
 753 }
 754 
 755 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 756   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 757   assert(dest-&gt;is_address(), &quot;should not call otherwise&quot;);
 758   LIR_Const* c = src-&gt;as_constant_ptr();
 759   LIR_Address* addr = dest-&gt;as_address_ptr();
 760 
 761   int null_check_here = code_offset();
 762   switch (type) {
 763     case T_INT:    // fall through
 764     case T_FLOAT:
 765       __ movl(as_Address(addr), c-&gt;as_jint_bits());
 766       break;
 767 
 768     case T_ADDRESS:
 769       __ movptr(as_Address(addr), c-&gt;as_jint_bits());
 770       break;
 771 
<a name="4" id="anc4"></a><span class="line-modified"> 772     case T_VALUETYPE: // fall through</span>
 773     case T_OBJECT:  // fall through
 774     case T_ARRAY:
 775       if (c-&gt;as_jobject() == NULL) {
 776         if (UseCompressedOops &amp;&amp; !wide) {
 777           __ movl(as_Address(addr), (int32_t)NULL_WORD);
 778         } else {
 779 #ifdef _LP64
 780           __ xorptr(rscratch1, rscratch1);
 781           null_check_here = code_offset();
 782           __ movptr(as_Address(addr), rscratch1);
 783 #else
 784           __ movptr(as_Address(addr), NULL_WORD);
 785 #endif
 786         }
 787       } else {
 788         if (is_literal_address(addr)) {
 789           ShouldNotReachHere();
 790           __ movoop(as_Address(addr, noreg), c-&gt;as_jobject());
 791         } else {
 792 #ifdef _LP64
 793           __ movoop(rscratch1, c-&gt;as_jobject());
 794           if (UseCompressedOops &amp;&amp; !wide) {
 795             __ encode_heap_oop(rscratch1);
 796             null_check_here = code_offset();
 797             __ movl(as_Address_lo(addr), rscratch1);
 798           } else {
 799             null_check_here = code_offset();
 800             __ movptr(as_Address_lo(addr), rscratch1);
 801           }
 802 #else
 803           __ movoop(as_Address(addr), c-&gt;as_jobject());
 804 #endif
 805         }
 806       }
 807       break;
 808 
 809     case T_LONG:    // fall through
 810     case T_DOUBLE:
 811 #ifdef _LP64
 812       if (is_literal_address(addr)) {
 813         ShouldNotReachHere();
 814         __ movptr(as_Address(addr, r15_thread), (intptr_t)c-&gt;as_jlong_bits());
 815       } else {
 816         __ movptr(r10, (intptr_t)c-&gt;as_jlong_bits());
 817         null_check_here = code_offset();
 818         __ movptr(as_Address_lo(addr), r10);
 819       }
 820 #else
 821       // Always reachable in 32bit so this doesn&#39;t produce useless move literal
 822       __ movptr(as_Address_hi(addr), c-&gt;as_jint_hi_bits());
 823       __ movptr(as_Address_lo(addr), c-&gt;as_jint_lo_bits());
 824 #endif // _LP64
 825       break;
 826 
 827     case T_BOOLEAN: // fall through
 828     case T_BYTE:
 829       __ movb(as_Address(addr), c-&gt;as_jint() &amp; 0xFF);
 830       break;
 831 
 832     case T_CHAR:    // fall through
 833     case T_SHORT:
 834       __ movw(as_Address(addr), c-&gt;as_jint() &amp; 0xFFFF);
 835       break;
 836 
 837     default:
 838       ShouldNotReachHere();
 839   };
 840 
 841   if (info != NULL) {
 842     add_debug_info_for_null_check(null_check_here, info);
 843   }
 844 }
 845 
 846 
 847 void LIR_Assembler::reg2reg(LIR_Opr src, LIR_Opr dest) {
 848   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 849   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 850 
 851   // move between cpu-registers
 852   if (dest-&gt;is_single_cpu()) {
 853 #ifdef _LP64
 854     if (src-&gt;type() == T_LONG) {
 855       // Can do LONG -&gt; OBJECT
 856       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
 857       return;
 858     }
 859 #endif
 860     assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
<a name="5" id="anc5"></a><span class="line-modified"> 861     if (src-&gt;type() == T_OBJECT || src-&gt;type() == T_VALUETYPE) {</span>
 862       __ verify_oop(src-&gt;as_register());
 863     }
 864     move_regs(src-&gt;as_register(), dest-&gt;as_register());
 865 
 866   } else if (dest-&gt;is_double_cpu()) {
 867 #ifdef _LP64
 868     if (is_reference_type(src-&gt;type())) {
 869       // Surprising to me but we can see move of a long to t_object
 870       __ verify_oop(src-&gt;as_register());
 871       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
 872       return;
 873     }
 874 #endif
 875     assert(src-&gt;is_double_cpu(), &quot;must match&quot;);
 876     Register f_lo = src-&gt;as_register_lo();
 877     Register f_hi = src-&gt;as_register_hi();
 878     Register t_lo = dest-&gt;as_register_lo();
 879     Register t_hi = dest-&gt;as_register_hi();
 880 #ifdef _LP64
 881     assert(f_hi == f_lo, &quot;must be same&quot;);
 882     assert(t_hi == t_lo, &quot;must be same&quot;);
 883     move_regs(f_lo, t_lo);
 884 #else
 885     assert(f_lo != f_hi &amp;&amp; t_lo != t_hi, &quot;invalid register allocation&quot;);
 886 
 887 
 888     if (f_lo == t_hi &amp;&amp; f_hi == t_lo) {
 889       swap_reg(f_lo, f_hi);
 890     } else if (f_hi == t_lo) {
 891       assert(f_lo != t_hi, &quot;overwriting register&quot;);
 892       move_regs(f_hi, t_hi);
 893       move_regs(f_lo, t_lo);
 894     } else {
 895       assert(f_hi != t_lo, &quot;overwriting register&quot;);
 896       move_regs(f_lo, t_lo);
 897       move_regs(f_hi, t_hi);
 898     }
 899 #endif // LP64
 900 
 901 #ifndef _LP64
 902     // special moves from fpu-register to xmm-register
 903     // necessary for method results
 904   } else if (src-&gt;is_single_xmm() &amp;&amp; !dest-&gt;is_single_xmm()) {
 905     __ movflt(Address(rsp, 0), src-&gt;as_xmm_float_reg());
 906     __ fld_s(Address(rsp, 0));
 907   } else if (src-&gt;is_double_xmm() &amp;&amp; !dest-&gt;is_double_xmm()) {
 908     __ movdbl(Address(rsp, 0), src-&gt;as_xmm_double_reg());
 909     __ fld_d(Address(rsp, 0));
 910   } else if (dest-&gt;is_single_xmm() &amp;&amp; !src-&gt;is_single_xmm()) {
 911     __ fstp_s(Address(rsp, 0));
 912     __ movflt(dest-&gt;as_xmm_float_reg(), Address(rsp, 0));
 913   } else if (dest-&gt;is_double_xmm() &amp;&amp; !src-&gt;is_double_xmm()) {
 914     __ fstp_d(Address(rsp, 0));
 915     __ movdbl(dest-&gt;as_xmm_double_reg(), Address(rsp, 0));
 916 #endif // !_LP64
 917 
 918     // move between xmm-registers
 919   } else if (dest-&gt;is_single_xmm()) {
 920     assert(src-&gt;is_single_xmm(), &quot;must match&quot;);
 921     __ movflt(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_float_reg());
 922   } else if (dest-&gt;is_double_xmm()) {
 923     assert(src-&gt;is_double_xmm(), &quot;must match&quot;);
 924     __ movdbl(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_double_reg());
 925 
 926 #ifndef _LP64
 927     // move between fpu-registers (no instruction necessary because of fpu-stack)
 928   } else if (dest-&gt;is_single_fpu() || dest-&gt;is_double_fpu()) {
 929     assert(src-&gt;is_single_fpu() || src-&gt;is_double_fpu(), &quot;must match&quot;);
 930     assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;currently should be nothing to do&quot;);
 931 #endif // !_LP64
 932 
 933   } else {
 934     ShouldNotReachHere();
 935   }
 936 }
 937 
 938 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
 939   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 940   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 941 
 942   if (src-&gt;is_single_cpu()) {
 943     Address dst = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 944     if (is_reference_type(type)) {
 945       __ verify_oop(src-&gt;as_register());
 946       __ movptr (dst, src-&gt;as_register());
 947     } else if (type == T_METADATA || type == T_ADDRESS) {
 948       __ movptr (dst, src-&gt;as_register());
 949     } else {
 950       __ movl (dst, src-&gt;as_register());
 951     }
 952 
 953   } else if (src-&gt;is_double_cpu()) {
 954     Address dstLO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), lo_word_offset_in_bytes);
 955     Address dstHI = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), hi_word_offset_in_bytes);
 956     __ movptr (dstLO, src-&gt;as_register_lo());
 957     NOT_LP64(__ movptr (dstHI, src-&gt;as_register_hi()));
 958 
 959   } else if (src-&gt;is_single_xmm()) {
 960     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 961     __ movflt(dst_addr, src-&gt;as_xmm_float_reg());
 962 
 963   } else if (src-&gt;is_double_xmm()) {
 964     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 965     __ movdbl(dst_addr, src-&gt;as_xmm_double_reg());
 966 
 967 #ifndef _LP64
 968   } else if (src-&gt;is_single_fpu()) {
 969     assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
 970     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 971     if (pop_fpu_stack)     __ fstp_s (dst_addr);
 972     else                   __ fst_s  (dst_addr);
 973 
 974   } else if (src-&gt;is_double_fpu()) {
 975     assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
 976     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 977     if (pop_fpu_stack)     __ fstp_d (dst_addr);
 978     else                   __ fst_d  (dst_addr);
 979 #endif // !_LP64
 980 
 981   } else {
 982     ShouldNotReachHere();
 983   }
 984 }
 985 
 986 
 987 void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
 988   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 989   PatchingStub* patch = NULL;
 990   Register compressed_src = rscratch1;
 991 
 992   if (is_reference_type(type)) {
 993     __ verify_oop(src-&gt;as_register());
 994 #ifdef _LP64
 995     if (UseCompressedOops &amp;&amp; !wide) {
 996       __ movptr(compressed_src, src-&gt;as_register());
 997       __ encode_heap_oop(compressed_src);
 998       if (patch_code != lir_patch_none) {
 999         info-&gt;oop_map()-&gt;set_narrowoop(compressed_src-&gt;as_VMReg());
1000       }
1001     }
1002 #endif
1003   }
1004 
1005   if (patch_code != lir_patch_none) {
1006     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1007     Address toa = as_Address(to_addr);
1008     assert(toa.disp() != 0, &quot;must have&quot;);
1009   }
1010 
1011   int null_check_here = code_offset();
1012   switch (type) {
1013     case T_FLOAT: {
1014 #ifdef _LP64
1015       assert(src-&gt;is_single_xmm(), &quot;not a float&quot;);
1016       __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
1017 #else
1018       if (src-&gt;is_single_xmm()) {
1019         __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
1020       } else {
1021         assert(src-&gt;is_single_fpu(), &quot;must be&quot;);
1022         assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
1023         if (pop_fpu_stack)      __ fstp_s(as_Address(to_addr));
1024         else                    __ fst_s (as_Address(to_addr));
1025       }
1026 #endif // _LP64
1027       break;
1028     }
1029 
1030     case T_DOUBLE: {
1031 #ifdef _LP64
1032       assert(src-&gt;is_double_xmm(), &quot;not a double&quot;);
1033       __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1034 #else
1035       if (src-&gt;is_double_xmm()) {
1036         __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1037       } else {
1038         assert(src-&gt;is_double_fpu(), &quot;must be&quot;);
1039         assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
1040         if (pop_fpu_stack)      __ fstp_d(as_Address(to_addr));
1041         else                    __ fst_d (as_Address(to_addr));
1042       }
1043 #endif // _LP64
1044       break;
1045     }
1046 
<a name="6" id="anc6"></a><span class="line-modified">1047     case T_VALUETYPE: // fall through</span>
1048     case T_ARRAY:   // fall through
1049     case T_OBJECT:  // fall through
1050       if (UseCompressedOops &amp;&amp; !wide) {
1051         __ movl(as_Address(to_addr), compressed_src);
1052       } else {
1053         __ movptr(as_Address(to_addr), src-&gt;as_register());
1054       }
1055       break;
1056     case T_METADATA:
1057       // We get here to store a method pointer to the stack to pass to
1058       // a dtrace runtime call. This can&#39;t work on 64 bit with
1059       // compressed klass ptrs: T_METADATA can be a compressed klass
1060       // ptr or a 64 bit method pointer.
1061       LP64_ONLY(ShouldNotReachHere());
1062       __ movptr(as_Address(to_addr), src-&gt;as_register());
1063       break;
1064     case T_ADDRESS:
1065       __ movptr(as_Address(to_addr), src-&gt;as_register());
1066       break;
1067     case T_INT:
1068       __ movl(as_Address(to_addr), src-&gt;as_register());
1069       break;
1070 
1071     case T_LONG: {
1072       Register from_lo = src-&gt;as_register_lo();
1073       Register from_hi = src-&gt;as_register_hi();
1074 #ifdef _LP64
1075       __ movptr(as_Address_lo(to_addr), from_lo);
1076 #else
1077       Register base = to_addr-&gt;base()-&gt;as_register();
1078       Register index = noreg;
1079       if (to_addr-&gt;index()-&gt;is_register()) {
1080         index = to_addr-&gt;index()-&gt;as_register();
1081       }
1082       if (base == from_lo || index == from_lo) {
1083         assert(base != from_hi, &quot;can&#39;t be&quot;);
1084         assert(index == noreg || (index != base &amp;&amp; index != from_hi), &quot;can&#39;t handle this&quot;);
1085         __ movl(as_Address_hi(to_addr), from_hi);
1086         if (patch != NULL) {
1087           patching_epilog(patch, lir_patch_high, base, info);
1088           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1089           patch_code = lir_patch_low;
1090         }
1091         __ movl(as_Address_lo(to_addr), from_lo);
1092       } else {
1093         assert(index == noreg || (index != base &amp;&amp; index != from_lo), &quot;can&#39;t handle this&quot;);
1094         __ movl(as_Address_lo(to_addr), from_lo);
1095         if (patch != NULL) {
1096           patching_epilog(patch, lir_patch_low, base, info);
1097           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1098           patch_code = lir_patch_high;
1099         }
1100         __ movl(as_Address_hi(to_addr), from_hi);
1101       }
1102 #endif // _LP64
1103       break;
1104     }
1105 
1106     case T_BYTE:    // fall through
1107     case T_BOOLEAN: {
1108       Register src_reg = src-&gt;as_register();
1109       Address dst_addr = as_Address(to_addr);
1110       assert(VM_Version::is_P6() || src_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1111       __ movb(dst_addr, src_reg);
1112       break;
1113     }
1114 
1115     case T_CHAR:    // fall through
1116     case T_SHORT:
1117       __ movw(as_Address(to_addr), src-&gt;as_register());
1118       break;
1119 
1120     default:
1121       ShouldNotReachHere();
1122   }
1123   if (info != NULL) {
1124     add_debug_info_for_null_check(null_check_here, info);
1125   }
1126 
1127   if (patch_code != lir_patch_none) {
1128     patching_epilog(patch, patch_code, to_addr-&gt;base()-&gt;as_register(), info);
1129   }
1130 }
1131 
1132 
1133 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1134   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
1135   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1136 
1137   if (dest-&gt;is_single_cpu()) {
1138     if (is_reference_type(type)) {
1139       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1140       __ verify_oop(dest-&gt;as_register());
1141     } else if (type == T_METADATA || type == T_ADDRESS) {
1142       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1143     } else {
1144       __ movl(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1145     }
1146 
1147   } else if (dest-&gt;is_double_cpu()) {
1148     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), lo_word_offset_in_bytes);
1149     Address src_addr_HI = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), hi_word_offset_in_bytes);
1150     __ movptr(dest-&gt;as_register_lo(), src_addr_LO);
1151     NOT_LP64(__ movptr(dest-&gt;as_register_hi(), src_addr_HI));
1152 
1153   } else if (dest-&gt;is_single_xmm()) {
1154     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1155     __ movflt(dest-&gt;as_xmm_float_reg(), src_addr);
1156 
1157   } else if (dest-&gt;is_double_xmm()) {
1158     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1159     __ movdbl(dest-&gt;as_xmm_double_reg(), src_addr);
1160 
1161 #ifndef _LP64
1162   } else if (dest-&gt;is_single_fpu()) {
1163     assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1164     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1165     __ fld_s(src_addr);
1166 
1167   } else if (dest-&gt;is_double_fpu()) {
1168     assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1169     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1170     __ fld_d(src_addr);
1171 #endif // _LP64
1172 
1173   } else {
1174     ShouldNotReachHere();
1175   }
1176 }
1177 
1178 
1179 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
1180   if (src-&gt;is_single_stack()) {
1181     if (is_reference_type(type)) {
1182       __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1183       __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1184     } else {
1185 #ifndef _LP64
1186       __ pushl(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1187       __ popl (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1188 #else
1189       //no pushl on 64bits
1190       __ movl(rscratch1, frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1191       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), rscratch1);
1192 #endif
1193     }
1194 
1195   } else if (src-&gt;is_double_stack()) {
1196 #ifdef _LP64
1197     __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix()));
1198     __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
1199 #else
1200     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 0));
1201     // push and pop the part at src + wordSize, adding wordSize for the previous push
1202     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 2 * wordSize));
1203     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 2 * wordSize));
1204     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 0));
1205 #endif // _LP64
1206 
1207   } else {
1208     ShouldNotReachHere();
1209   }
1210 }
1211 
1212 
1213 void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool /* unaligned */) {
1214   assert(src-&gt;is_address(), &quot;should not call otherwise&quot;);
1215   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1216 
1217   LIR_Address* addr = src-&gt;as_address_ptr();
1218   Address from_addr = as_Address(addr);
1219   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
1220 
<a name="7" id="anc7"></a><span class="line-modified">1221   if (addr-&gt;base()-&gt;type() == T_OBJECT || addr-&gt;base()-&gt;type() == T_VALUETYPE) {</span>
1222     __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
1223   }
1224 
1225   switch (type) {
1226     case T_BOOLEAN: // fall through
1227     case T_BYTE:    // fall through
1228     case T_CHAR:    // fall through
1229     case T_SHORT:
1230       if (!VM_Version::is_P6() &amp;&amp; !from_addr.uses(dest-&gt;as_register())) {
1231         // on pre P6 processors we may get partial register stalls
1232         // so blow away the value of to_rinfo before loading a
1233         // partial word into it.  Do it here so that it precedes
1234         // the potential patch point below.
1235         __ xorptr(dest-&gt;as_register(), dest-&gt;as_register());
1236       }
1237       break;
1238    default:
1239      break;
1240   }
1241 
1242   PatchingStub* patch = NULL;
1243   if (patch_code != lir_patch_none) {
1244     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1245     assert(from_addr.disp() != 0, &quot;must have&quot;);
1246   }
1247   if (info != NULL) {
1248     add_debug_info_for_null_check_here(info);
1249   }
1250 
1251   switch (type) {
1252     case T_FLOAT: {
1253       if (dest-&gt;is_single_xmm()) {
1254         __ movflt(dest-&gt;as_xmm_float_reg(), from_addr);
1255       } else {
1256 #ifndef _LP64
1257         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
1258         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1259         __ fld_s(from_addr);
1260 #else
1261         ShouldNotReachHere();
1262 #endif // !LP64
1263       }
1264       break;
1265     }
1266 
1267     case T_DOUBLE: {
1268       if (dest-&gt;is_double_xmm()) {
1269         __ movdbl(dest-&gt;as_xmm_double_reg(), from_addr);
1270       } else {
1271 #ifndef _LP64
1272         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
1273         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1274         __ fld_d(from_addr);
1275 #else
1276         ShouldNotReachHere();
1277 #endif // !LP64
1278       }
1279       break;
1280     }
1281 
<a name="8" id="anc8"></a><span class="line-modified">1282     case T_VALUETYPE: // fall through</span>
1283     case T_OBJECT:  // fall through
1284     case T_ARRAY:   // fall through
1285       if (UseCompressedOops &amp;&amp; !wide) {
1286         __ movl(dest-&gt;as_register(), from_addr);
1287       } else {
1288         __ movptr(dest-&gt;as_register(), from_addr);
1289       }
1290       break;
1291 
1292     case T_ADDRESS:
1293       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1294         __ movl(dest-&gt;as_register(), from_addr);
1295       } else {
1296         __ movptr(dest-&gt;as_register(), from_addr);
1297       }
1298       break;
1299     case T_INT:
1300       __ movl(dest-&gt;as_register(), from_addr);
1301       break;
1302 
1303     case T_LONG: {
1304       Register to_lo = dest-&gt;as_register_lo();
1305       Register to_hi = dest-&gt;as_register_hi();
1306 #ifdef _LP64
1307       __ movptr(to_lo, as_Address_lo(addr));
1308 #else
1309       Register base = addr-&gt;base()-&gt;as_register();
1310       Register index = noreg;
1311       if (addr-&gt;index()-&gt;is_register()) {
1312         index = addr-&gt;index()-&gt;as_register();
1313       }
1314       if ((base == to_lo &amp;&amp; index == to_hi) ||
1315           (base == to_hi &amp;&amp; index == to_lo)) {
1316         // addresses with 2 registers are only formed as a result of
1317         // array access so this code will never have to deal with
1318         // patches or null checks.
1319         assert(info == NULL &amp;&amp; patch == NULL, &quot;must be&quot;);
1320         __ lea(to_hi, as_Address(addr));
1321         __ movl(to_lo, Address(to_hi, 0));
1322         __ movl(to_hi, Address(to_hi, BytesPerWord));
1323       } else if (base == to_lo || index == to_lo) {
1324         assert(base != to_hi, &quot;can&#39;t be&quot;);
1325         assert(index == noreg || (index != base &amp;&amp; index != to_hi), &quot;can&#39;t handle this&quot;);
1326         __ movl(to_hi, as_Address_hi(addr));
1327         if (patch != NULL) {
1328           patching_epilog(patch, lir_patch_high, base, info);
1329           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1330           patch_code = lir_patch_low;
1331         }
1332         __ movl(to_lo, as_Address_lo(addr));
1333       } else {
1334         assert(index == noreg || (index != base &amp;&amp; index != to_lo), &quot;can&#39;t handle this&quot;);
1335         __ movl(to_lo, as_Address_lo(addr));
1336         if (patch != NULL) {
1337           patching_epilog(patch, lir_patch_low, base, info);
1338           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1339           patch_code = lir_patch_high;
1340         }
1341         __ movl(to_hi, as_Address_hi(addr));
1342       }
1343 #endif // _LP64
1344       break;
1345     }
1346 
1347     case T_BOOLEAN: // fall through
1348     case T_BYTE: {
1349       Register dest_reg = dest-&gt;as_register();
1350       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1351       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1352         __ movsbl(dest_reg, from_addr);
1353       } else {
1354         __ movb(dest_reg, from_addr);
1355         __ shll(dest_reg, 24);
1356         __ sarl(dest_reg, 24);
1357       }
1358       break;
1359     }
1360 
1361     case T_CHAR: {
1362       Register dest_reg = dest-&gt;as_register();
1363       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1364       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1365         __ movzwl(dest_reg, from_addr);
1366       } else {
1367         __ movw(dest_reg, from_addr);
1368       }
1369       break;
1370     }
1371 
1372     case T_SHORT: {
1373       Register dest_reg = dest-&gt;as_register();
1374       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1375         __ movswl(dest_reg, from_addr);
1376       } else {
1377         __ movw(dest_reg, from_addr);
1378         __ shll(dest_reg, 16);
1379         __ sarl(dest_reg, 16);
1380       }
1381       break;
1382     }
1383 
1384     default:
1385       ShouldNotReachHere();
1386   }
1387 
1388   if (patch != NULL) {
1389     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
1390   }
1391 
1392   if (is_reference_type(type)) {
1393 #ifdef _LP64
1394     if (UseCompressedOops &amp;&amp; !wide) {
1395       __ decode_heap_oop(dest-&gt;as_register());
1396     }
1397 #endif
1398 
1399     // Load barrier has not yet been applied, so ZGC can&#39;t verify the oop here
1400     if (!UseZGC) {
1401       __ verify_oop(dest-&gt;as_register());
1402     }
1403   } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1404 #ifdef _LP64
1405     if (UseCompressedClassPointers) {
1406       __ decode_klass_not_null(dest-&gt;as_register(), tmp_load_klass);
1407     }
1408 #endif
1409   }
1410 }
1411 
1412 
1413 NEEDS_CLEANUP; // This could be static?
1414 Address::ScaleFactor LIR_Assembler::array_element_size(BasicType type) const {
1415   int elem_size = type2aelembytes(type);
1416   switch (elem_size) {
1417     case 1: return Address::times_1;
1418     case 2: return Address::times_2;
1419     case 4: return Address::times_4;
1420     case 8: return Address::times_8;
1421   }
1422   ShouldNotReachHere();
1423   return Address::no_scale;
1424 }
1425 
1426 
1427 void LIR_Assembler::emit_op3(LIR_Op3* op) {
1428   switch (op-&gt;code()) {
1429     case lir_idiv:
1430     case lir_irem:
1431       arithmetic_idiv(op-&gt;code(),
1432                       op-&gt;in_opr1(),
1433                       op-&gt;in_opr2(),
1434                       op-&gt;in_opr3(),
1435                       op-&gt;result_opr(),
1436                       op-&gt;info());
1437       break;
1438     case lir_fmad:
1439       __ fmad(op-&gt;result_opr()-&gt;as_xmm_double_reg(),
1440               op-&gt;in_opr1()-&gt;as_xmm_double_reg(),
1441               op-&gt;in_opr2()-&gt;as_xmm_double_reg(),
1442               op-&gt;in_opr3()-&gt;as_xmm_double_reg());
1443       break;
1444     case lir_fmaf:
1445       __ fmaf(op-&gt;result_opr()-&gt;as_xmm_float_reg(),
1446               op-&gt;in_opr1()-&gt;as_xmm_float_reg(),
1447               op-&gt;in_opr2()-&gt;as_xmm_float_reg(),
1448               op-&gt;in_opr3()-&gt;as_xmm_float_reg());
1449       break;
1450     default:      ShouldNotReachHere(); break;
1451   }
1452 }
1453 
1454 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
1455 #ifdef ASSERT
1456   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
1457   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
1458   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
1459 #endif
1460 
1461   if (op-&gt;cond() == lir_cond_always) {
1462     if (op-&gt;info() != NULL) add_debug_info_for_branch(op-&gt;info());
1463     __ jmp (*(op-&gt;label()));
1464   } else {
1465     Assembler::Condition acond = Assembler::zero;
1466     if (op-&gt;code() == lir_cond_float_branch) {
1467       assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
1468       __ jcc(Assembler::parity, *(op-&gt;ublock()-&gt;label()));
1469       switch(op-&gt;cond()) {
1470         case lir_cond_equal:        acond = Assembler::equal;      break;
1471         case lir_cond_notEqual:     acond = Assembler::notEqual;   break;
1472         case lir_cond_less:         acond = Assembler::below;      break;
1473         case lir_cond_lessEqual:    acond = Assembler::belowEqual; break;
1474         case lir_cond_greaterEqual: acond = Assembler::aboveEqual; break;
1475         case lir_cond_greater:      acond = Assembler::above;      break;
1476         default:                         ShouldNotReachHere();
1477       }
1478     } else {
1479       switch (op-&gt;cond()) {
1480         case lir_cond_equal:        acond = Assembler::equal;       break;
1481         case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
1482         case lir_cond_less:         acond = Assembler::less;        break;
1483         case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
1484         case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
1485         case lir_cond_greater:      acond = Assembler::greater;     break;
1486         case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
1487         case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
1488         default:                         ShouldNotReachHere();
1489       }
1490     }
1491     __ jcc(acond,*(op-&gt;label()));
1492   }
1493 }
1494 
1495 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
1496   LIR_Opr src  = op-&gt;in_opr();
1497   LIR_Opr dest = op-&gt;result_opr();
1498 
1499   switch (op-&gt;bytecode()) {
1500     case Bytecodes::_i2l:
1501 #ifdef _LP64
1502       __ movl2ptr(dest-&gt;as_register_lo(), src-&gt;as_register());
1503 #else
1504       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
1505       move_regs(src-&gt;as_register(), dest-&gt;as_register_hi());
1506       __ sarl(dest-&gt;as_register_hi(), 31);
1507 #endif // LP64
1508       break;
1509 
1510     case Bytecodes::_l2i:
1511 #ifdef _LP64
1512       __ movl(dest-&gt;as_register(), src-&gt;as_register_lo());
1513 #else
1514       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
1515 #endif
1516       break;
1517 
1518     case Bytecodes::_i2b:
1519       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1520       __ sign_extend_byte(dest-&gt;as_register());
1521       break;
1522 
1523     case Bytecodes::_i2c:
1524       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1525       __ andl(dest-&gt;as_register(), 0xFFFF);
1526       break;
1527 
1528     case Bytecodes::_i2s:
1529       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1530       __ sign_extend_short(dest-&gt;as_register());
1531       break;
1532 
1533 
1534 #ifdef _LP64
1535     case Bytecodes::_f2d:
1536       __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1537       break;
1538 
1539     case Bytecodes::_d2f:
1540       __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1541       break;
1542 
1543     case Bytecodes::_i2f:
1544       __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1545       break;
1546 
1547     case Bytecodes::_i2d:
1548       __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1549       break;
1550 
1551     case Bytecodes::_l2f:
1552       __ cvtsi2ssq(dest-&gt;as_xmm_float_reg(), src-&gt;as_register_lo());
1553       break;
1554 
1555     case Bytecodes::_l2d:
1556       __ cvtsi2sdq(dest-&gt;as_xmm_double_reg(), src-&gt;as_register_lo());
1557       break;
1558 
1559     case Bytecodes::_f2i:
1560       __ convert_f2i(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1561       break;
1562 
1563     case Bytecodes::_d2i:
1564       __ convert_d2i(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1565       break;
1566 
1567     case Bytecodes::_f2l:
1568       __ convert_f2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_float_reg());
1569       break;
1570 
1571     case Bytecodes::_d2l:
1572       __ convert_d2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
1573       break;
1574 #else
1575     case Bytecodes::_f2d:
1576     case Bytecodes::_d2f:
1577       if (dest-&gt;is_single_xmm()) {
1578         __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1579       } else if (dest-&gt;is_double_xmm()) {
1580         __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1581       } else {
1582         assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;register must be equal&quot;);
1583         // do nothing (float result is rounded later through spilling)
1584       }
1585       break;
1586 
1587     case Bytecodes::_i2f:
1588     case Bytecodes::_i2d:
1589       if (dest-&gt;is_single_xmm()) {
1590         __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1591       } else if (dest-&gt;is_double_xmm()) {
1592         __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1593       } else {
1594         assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1595         __ movl(Address(rsp, 0), src-&gt;as_register());
1596         __ fild_s(Address(rsp, 0));
1597       }
1598       break;
1599 
1600     case Bytecodes::_l2f:
1601     case Bytecodes::_l2d:
1602       assert(!dest-&gt;is_xmm_register(), &quot;result in xmm register not supported (no SSE instruction present)&quot;);
1603       assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1604       __ movptr(Address(rsp, 0),          src-&gt;as_register_lo());
1605       __ movl(Address(rsp, BytesPerWord), src-&gt;as_register_hi());
1606       __ fild_d(Address(rsp, 0));
1607       // float result is rounded later through spilling
1608       break;
1609 
1610     case Bytecodes::_f2i:
1611     case Bytecodes::_d2i:
1612       if (src-&gt;is_single_xmm()) {
1613         __ cvttss2sil(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1614       } else if (src-&gt;is_double_xmm()) {
1615         __ cvttsd2sil(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1616       } else {
1617         assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1618         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
1619         __ fist_s(Address(rsp, 0));
1620         __ movl(dest-&gt;as_register(), Address(rsp, 0));
1621         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
1622       }
1623       // IA32 conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
1624       assert(op-&gt;stub() != NULL, &quot;stub required&quot;);
1625       __ cmpl(dest-&gt;as_register(), 0x80000000);
1626       __ jcc(Assembler::equal, *op-&gt;stub()-&gt;entry());
1627       __ bind(*op-&gt;stub()-&gt;continuation());
1628       break;
1629 
1630     case Bytecodes::_f2l:
1631     case Bytecodes::_d2l:
1632       assert(!src-&gt;is_xmm_register(), &quot;input in xmm register not supported (no SSE instruction present)&quot;);
1633       assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1634       assert(dest == FrameMap::long0_opr, &quot;runtime stub places result in these registers&quot;);
1635 
1636       // instruction sequence too long to inline it here
1637       {
1638         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::fpu2long_stub_id)));
1639       }
1640       break;
1641 #endif // _LP64
1642 
1643     default: ShouldNotReachHere();
1644   }
1645 }
1646 
1647 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
1648   if (op-&gt;init_check()) {
1649     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
1650     __ cmpb(Address(op-&gt;klass()-&gt;as_register(),
1651                     InstanceKlass::init_state_offset()),
1652                     InstanceKlass::fully_initialized);
1653     __ jcc(Assembler::notEqual, *op-&gt;stub()-&gt;entry());
1654   }
1655   __ allocate_object(op-&gt;obj()-&gt;as_register(),
1656                      op-&gt;tmp1()-&gt;as_register(),
1657                      op-&gt;tmp2()-&gt;as_register(),
1658                      op-&gt;header_size(),
1659                      op-&gt;object_size(),
1660                      op-&gt;klass()-&gt;as_register(),
1661                      *op-&gt;stub()-&gt;entry());
1662   __ bind(*op-&gt;stub()-&gt;continuation());
1663 }
1664 
1665 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
1666   Register len =  op-&gt;len()-&gt;as_register();
1667   LP64_ONLY( __ movslq(len, len); )
1668 
<a name="9" id="anc9"></a><span class="line-modified">1669   if (UseSlowPath || op-&gt;type() == T_VALUETYPE ||</span>
1670       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
1671       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
1672     __ jmp(*op-&gt;stub()-&gt;entry());
1673   } else {
1674     Register tmp1 = op-&gt;tmp1()-&gt;as_register();
1675     Register tmp2 = op-&gt;tmp2()-&gt;as_register();
1676     Register tmp3 = op-&gt;tmp3()-&gt;as_register();
1677     if (len == tmp1) {
1678       tmp1 = tmp3;
1679     } else if (len == tmp2) {
1680       tmp2 = tmp3;
1681     } else if (len == tmp3) {
1682       // everything is ok
1683     } else {
1684       __ mov(tmp3, len);
1685     }
1686     __ allocate_array(op-&gt;obj()-&gt;as_register(),
1687                       len,
1688                       tmp1,
1689                       tmp2,
1690                       arrayOopDesc::header_size(op-&gt;type()),
1691                       array_element_size(op-&gt;type()),
1692                       op-&gt;klass()-&gt;as_register(),
1693                       *op-&gt;stub()-&gt;entry());
1694   }
1695   __ bind(*op-&gt;stub()-&gt;continuation());
1696 }
1697 
1698 void LIR_Assembler::type_profile_helper(Register mdo,
1699                                         ciMethodData *md, ciProfileData *data,
1700                                         Register recv, Label* update_done) {
1701   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1702     Label next_test;
1703     // See if the receiver is receiver[n].
1704     __ cmpptr(recv, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1705     __ jccb(Assembler::notEqual, next_test);
1706     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));
1707     __ addptr(data_addr, DataLayout::counter_increment);
1708     __ jmp(*update_done);
1709     __ bind(next_test);
1710   }
1711 
1712   // Didn&#39;t find receiver; find next empty slot and fill it in
1713   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1714     Label next_test;
1715     Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)));
1716     __ cmpptr(recv_addr, (intptr_t)NULL_WORD);
1717     __ jccb(Assembler::notEqual, next_test);
1718     __ movptr(recv_addr, recv);
1719     __ movptr(Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))), DataLayout::counter_increment);
1720     __ jmp(*update_done);
1721     __ bind(next_test);
1722   }
1723 }
1724 
1725 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
1726   // we always need a stub for the failure case.
1727   CodeStub* stub = op-&gt;stub();
1728   Register obj = op-&gt;object()-&gt;as_register();
1729   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1730   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1731   Register dst = op-&gt;result_opr()-&gt;as_register();
1732   ciKlass* k = op-&gt;klass();
1733   Register Rtmp1 = noreg;
1734   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
1735 
1736   // check if it needs to be profiled
1737   ciMethodData* md = NULL;
1738   ciProfileData* data = NULL;
1739 
1740   if (op-&gt;should_profile()) {
1741     ciMethod* method = op-&gt;profiled_method();
1742     assert(method != NULL, &quot;Should have method&quot;);
1743     int bci = op-&gt;profiled_bci();
1744     md = method-&gt;method_data_or_null();
1745     assert(md != NULL, &quot;Sanity&quot;);
1746     data = md-&gt;bci_to_data(bci);
1747     assert(data != NULL,                &quot;need data for type check&quot;);
1748     assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1749   }
1750   Label profile_cast_success, profile_cast_failure;
1751   Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : success;
1752   Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : failure;
1753 
1754   if (obj == k_RInfo) {
1755     k_RInfo = dst;
1756   } else if (obj == klass_RInfo) {
1757     klass_RInfo = dst;
1758   }
1759   if (k-&gt;is_loaded() &amp;&amp; !UseCompressedClassPointers) {
1760     select_different_registers(obj, dst, k_RInfo, klass_RInfo);
1761   } else {
1762     Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1763     select_different_registers(obj, dst, k_RInfo, klass_RInfo, Rtmp1);
1764   }
1765 
1766   assert_different_registers(obj, k_RInfo, klass_RInfo);
1767 
1768   if (op-&gt;need_null_check()) {
1769     __ cmpptr(obj, (int32_t)NULL_WORD);
1770     if (op-&gt;should_profile()) {
1771       Label not_null;
1772       __ jccb(Assembler::notEqual, not_null);
1773       // Object is null; update MDO and exit
1774       Register mdo  = klass_RInfo;
1775       __ mov_metadata(mdo, md-&gt;constant_encoding());
1776       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1777       int header_bits = BitData::null_seen_byte_constant();
1778       __ orb(data_addr, header_bits);
1779       __ jmp(*obj_is_null);
1780       __ bind(not_null);
1781     } else {
1782       __ jcc(Assembler::equal, *obj_is_null);
1783     }
1784   }
1785 
1786   if (!k-&gt;is_loaded()) {
1787     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
1788   } else {
1789 #ifdef _LP64
1790     __ mov_metadata(k_RInfo, k-&gt;constant_encoding());
1791 #endif // _LP64
1792   }
1793   __ verify_oop(obj);
1794 
1795   if (op-&gt;fast_check()) {
1796     // get object class
1797     // not a safepoint as obj null check happens earlier
1798 #ifdef _LP64
1799     if (UseCompressedClassPointers) {
1800       __ load_klass(Rtmp1, obj, tmp_load_klass);
1801       __ cmpptr(k_RInfo, Rtmp1);
1802     } else {
1803       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1804     }
1805 #else
1806     if (k-&gt;is_loaded()) {
1807       __ cmpklass(Address(obj, oopDesc::klass_offset_in_bytes()), k-&gt;constant_encoding());
1808     } else {
1809       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1810     }
1811 #endif
1812     __ jcc(Assembler::notEqual, *failure_target);
1813     // successful cast, fall through to profile or jump
1814   } else {
1815     // get object class
1816     // not a safepoint as obj null check happens earlier
1817     __ load_klass(klass_RInfo, obj, tmp_load_klass);
1818     if (k-&gt;is_loaded()) {
1819       // See if we get an immediate positive hit
1820 #ifdef _LP64
1821       __ cmpptr(k_RInfo, Address(klass_RInfo, k-&gt;super_check_offset()));
1822 #else
1823       __ cmpklass(Address(klass_RInfo, k-&gt;super_check_offset()), k-&gt;constant_encoding());
1824 #endif // _LP64
1825       if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k-&gt;super_check_offset()) {
1826         __ jcc(Assembler::notEqual, *failure_target);
1827         // successful cast, fall through to profile or jump
1828       } else {
1829         // See if we get an immediate positive hit
1830         __ jcc(Assembler::equal, *success_target);
1831         // check for self
1832 #ifdef _LP64
1833         __ cmpptr(klass_RInfo, k_RInfo);
1834 #else
1835         __ cmpklass(klass_RInfo, k-&gt;constant_encoding());
1836 #endif // _LP64
1837         __ jcc(Assembler::equal, *success_target);
1838 
1839         __ push(klass_RInfo);
1840 #ifdef _LP64
1841         __ push(k_RInfo);
1842 #else
1843         __ pushklass(k-&gt;constant_encoding());
1844 #endif // _LP64
1845         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1846         __ pop(klass_RInfo);
1847         __ pop(klass_RInfo);
1848         // result is a boolean
1849         __ cmpl(klass_RInfo, 0);
1850         __ jcc(Assembler::equal, *failure_target);
1851         // successful cast, fall through to profile or jump
1852       }
1853     } else {
1854       // perform the fast part of the checking logic
1855       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1856       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1857       __ push(klass_RInfo);
1858       __ push(k_RInfo);
1859       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1860       __ pop(klass_RInfo);
1861       __ pop(k_RInfo);
1862       // result is a boolean
1863       __ cmpl(k_RInfo, 0);
1864       __ jcc(Assembler::equal, *failure_target);
1865       // successful cast, fall through to profile or jump
1866     }
1867   }
1868   if (op-&gt;should_profile()) {
1869     Register mdo  = klass_RInfo, recv = k_RInfo;
1870     __ bind(profile_cast_success);
1871     __ mov_metadata(mdo, md-&gt;constant_encoding());
1872     __ load_klass(recv, obj, tmp_load_klass);
1873     type_profile_helper(mdo, md, data, recv, success);
1874     __ jmp(*success);
1875 
1876     __ bind(profile_cast_failure);
1877     __ mov_metadata(mdo, md-&gt;constant_encoding());
1878     Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1879     __ subptr(counter_addr, DataLayout::counter_increment);
1880     __ jmp(*failure);
1881   }
1882   __ jmp(*success);
1883 }
1884 
1885 
1886 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
1887   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
1888   LIR_Code code = op-&gt;code();
1889   if (code == lir_store_check) {
1890     Register value = op-&gt;object()-&gt;as_register();
1891     Register array = op-&gt;array()-&gt;as_register();
1892     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1893     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1894     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1895 
1896     CodeStub* stub = op-&gt;stub();
1897 
1898     // check if it needs to be profiled
1899     ciMethodData* md = NULL;
1900     ciProfileData* data = NULL;
1901 
1902     if (op-&gt;should_profile()) {
1903       ciMethod* method = op-&gt;profiled_method();
1904       assert(method != NULL, &quot;Should have method&quot;);
1905       int bci = op-&gt;profiled_bci();
1906       md = method-&gt;method_data_or_null();
1907       assert(md != NULL, &quot;Sanity&quot;);
1908       data = md-&gt;bci_to_data(bci);
1909       assert(data != NULL,                &quot;need data for type check&quot;);
1910       assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1911     }
1912     Label profile_cast_success, profile_cast_failure, done;
1913     Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : &amp;done;
1914     Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : stub-&gt;entry();
1915 
1916     __ cmpptr(value, (int32_t)NULL_WORD);
1917     if (op-&gt;should_profile()) {
1918       Label not_null;
1919       __ jccb(Assembler::notEqual, not_null);
1920       // Object is null; update MDO and exit
1921       Register mdo  = klass_RInfo;
1922       __ mov_metadata(mdo, md-&gt;constant_encoding());
1923       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1924       int header_bits = BitData::null_seen_byte_constant();
1925       __ orb(data_addr, header_bits);
1926       __ jmp(done);
1927       __ bind(not_null);
1928     } else {
1929       __ jcc(Assembler::equal, done);
1930     }
1931 
1932     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
1933     __ load_klass(k_RInfo, array, tmp_load_klass);
1934     __ load_klass(klass_RInfo, value, tmp_load_klass);
1935 
1936     // get instance klass (it&#39;s already uncompressed)
1937     __ movptr(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
1938     // perform the fast part of the checking logic
1939     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1940     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1941     __ push(klass_RInfo);
1942     __ push(k_RInfo);
1943     __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1944     __ pop(klass_RInfo);
1945     __ pop(k_RInfo);
1946     // result is a boolean
1947     __ cmpl(k_RInfo, 0);
1948     __ jcc(Assembler::equal, *failure_target);
1949     // fall through to the success case
1950 
1951     if (op-&gt;should_profile()) {
1952       Register mdo  = klass_RInfo, recv = k_RInfo;
1953       __ bind(profile_cast_success);
1954       __ mov_metadata(mdo, md-&gt;constant_encoding());
1955       __ load_klass(recv, value, tmp_load_klass);
1956       type_profile_helper(mdo, md, data, recv, &amp;done);
1957       __ jmpb(done);
1958 
1959       __ bind(profile_cast_failure);
1960       __ mov_metadata(mdo, md-&gt;constant_encoding());
1961       Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1962       __ subptr(counter_addr, DataLayout::counter_increment);
1963       __ jmp(*stub-&gt;entry());
1964     }
1965 
1966     __ bind(done);
1967   } else
1968     if (code == lir_checkcast) {
1969       Register obj = op-&gt;object()-&gt;as_register();
1970       Register dst = op-&gt;result_opr()-&gt;as_register();
1971       Label success;
1972       emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
1973       __ bind(success);
1974       if (dst != obj) {
1975         __ mov(dst, obj);
1976       }
1977     } else
1978       if (code == lir_instanceof) {
1979         Register obj = op-&gt;object()-&gt;as_register();
1980         Register dst = op-&gt;result_opr()-&gt;as_register();
1981         Label success, failure, done;
1982         emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
1983         __ bind(failure);
1984         __ xorptr(dst, dst);
1985         __ jmpb(done);
1986         __ bind(success);
1987         __ movptr(dst, 1);
1988         __ bind(done);
1989       } else {
1990         ShouldNotReachHere();
1991       }
1992 
1993 }
1994 
1995 void LIR_Assembler::emit_opFlattenedArrayCheck(LIR_OpFlattenedArrayCheck* op) {
1996   // We are loading/storing from/to an array that *may* be flattened (the
1997   // declared type is Object[], abstract[], interface[] or VT.ref[]).
1998   // If this array is flattened, take the slow path.
1999   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
2000   Register klass = op-&gt;tmp()-&gt;as_register();
2001   __ load_klass(klass, op-&gt;array()-&gt;as_register(), tmp_load_klass);
2002   __ movl(klass, Address(klass, Klass::layout_helper_offset()));
2003   __ testl(klass, Klass::_lh_array_tag_vt_value_bit_inplace);
2004   __ jcc(Assembler::notZero, *op-&gt;stub()-&gt;entry());
2005   if (!op-&gt;value()-&gt;is_illegal()) {
2006     // The array is not flattened, but it might be null-free. If we are storing
2007     // a null into a null-free array, take the slow path (which will throw NPE).
2008     Label skip;
2009     __ cmpptr(op-&gt;value()-&gt;as_register(), (int32_t)NULL_WORD);
2010     __ jcc(Assembler::notEqual, skip);
2011     __ testl(klass, Klass::_lh_null_free_bit_inplace);
2012     __ jcc(Assembler::notZero, *op-&gt;stub()-&gt;entry());
2013     __ bind(skip);
2014   }
2015 }
2016 
2017 void LIR_Assembler::emit_opNullFreeArrayCheck(LIR_OpNullFreeArrayCheck* op) {
2018   // We are storing into an array that *may* be null-free (the declared type is
2019   // Object[], abstract[], interface[] or VT.ref[]).
2020   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
2021   Register klass = op-&gt;tmp()-&gt;as_register();
2022   __ load_klass(klass, op-&gt;array()-&gt;as_register(), tmp_load_klass);
2023   __ movl(klass, Address(klass, Klass::layout_helper_offset()));
2024   __ testl(klass, Klass::_lh_null_free_bit_inplace);
2025 }
2026 
2027 void LIR_Assembler::emit_opSubstitutabilityCheck(LIR_OpSubstitutabilityCheck* op) {
2028   Label L_oops_equal;
2029   Label L_oops_not_equal;
2030   Label L_end;
2031 
2032   Register left  = op-&gt;left()-&gt;as_register();
2033   Register right = op-&gt;right()-&gt;as_register();
2034 
2035   __ cmpptr(left, right);
2036   __ jcc(Assembler::equal, L_oops_equal);
2037 
2038   // (1) Null check -- if one of the operands is null, the other must not be null (because
2039   //     the two references are not equal), so they are not substitutable,
2040   //     FIXME: do null check only if the operand is nullable
2041   {
2042     __ cmpptr(left, (int32_t)NULL_WORD);
2043     __ jcc(Assembler::equal, L_oops_not_equal);
2044 
2045     __ cmpptr(right, (int32_t)NULL_WORD);
2046     __ jcc(Assembler::equal, L_oops_not_equal);
2047   }
2048 
2049   ciKlass* left_klass = op-&gt;left_klass();
2050   ciKlass* right_klass = op-&gt;right_klass();
2051 
2052   // (2) Value object check -- if either of the operands is not a value object,
2053   //     they are not substitutable. We do this only if we are not sure that the
2054   //     operands are value objects
2055   if ((left_klass == NULL || right_klass == NULL) ||// The klass is still unloaded, or came from a Phi node.
2056       !left_klass-&gt;is_valuetype() || !right_klass-&gt;is_valuetype()) {
2057     Register tmp1  = op-&gt;tmp1()-&gt;as_register();
2058     __ movptr(tmp1, (intptr_t)markWord::always_locked_pattern);
2059     __ andl(tmp1, Address(left, oopDesc::mark_offset_in_bytes()));
2060     __ andl(tmp1, Address(right, oopDesc::mark_offset_in_bytes()));
2061     __ cmpptr(tmp1, (intptr_t)markWord::always_locked_pattern);
2062     __ jcc(Assembler::notEqual, L_oops_not_equal);
2063   }
2064 
2065   // (3) Same klass check: if the operands are of different klasses, they are not substitutable.
2066   if (left_klass != NULL &amp;&amp; left_klass-&gt;is_valuetype() &amp;&amp; left_klass == right_klass) {
2067     // No need to load klass -- the operands are statically known to be the same value klass.
2068     __ jmp(*op-&gt;stub()-&gt;entry());
2069   } else {
2070     Register left_klass_op = op-&gt;left_klass_op()-&gt;as_register();
2071     Register right_klass_op = op-&gt;right_klass_op()-&gt;as_register();
2072 
2073     if (UseCompressedOops) {
2074       __ movl(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));
2075       __ movl(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));
2076       __ cmpl(left_klass_op, right_klass_op);
2077     } else {
2078       __ movptr(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));
2079       __ movptr(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));
2080       __ cmpptr(left_klass_op, right_klass_op);
2081     }
2082 
2083     __ jcc(Assembler::equal, *op-&gt;stub()-&gt;entry()); // same klass -&gt; do slow check
2084     // fall through to L_oops_not_equal
2085   }
2086 
2087   __ bind(L_oops_not_equal);
2088   move(op-&gt;not_equal_result(), op-&gt;result_opr());
2089   __ jmp(L_end);
2090 
2091   __ bind(L_oops_equal);
2092   move(op-&gt;equal_result(), op-&gt;result_opr());
2093   __ jmp(L_end);
2094 
2095   // We&#39;ve returned from the stub. RAX contains 0x0 IFF the two
2096   // operands are not substitutable. (Don&#39;t compare against 0x1 in case the
2097   // C compiler is naughty)
2098   __ bind(*op-&gt;stub()-&gt;continuation());
2099   __ cmpl(rax, 0);
2100   __ jcc(Assembler::equal, L_oops_not_equal); // (call_stub() == 0x0) -&gt; not_equal
2101   move(op-&gt;equal_result(), op-&gt;result_opr()); // (call_stub() != 0x0) -&gt; equal
2102   // fall-through
2103   __ bind(L_end);
2104 }
2105 
2106 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
2107   if (LP64_ONLY(false &amp;&amp;) op-&gt;code() == lir_cas_long &amp;&amp; VM_Version::supports_cx8()) {
2108     assert(op-&gt;cmp_value()-&gt;as_register_lo() == rax, &quot;wrong register&quot;);
2109     assert(op-&gt;cmp_value()-&gt;as_register_hi() == rdx, &quot;wrong register&quot;);
2110     assert(op-&gt;new_value()-&gt;as_register_lo() == rbx, &quot;wrong register&quot;);
2111     assert(op-&gt;new_value()-&gt;as_register_hi() == rcx, &quot;wrong register&quot;);
2112     Register addr = op-&gt;addr()-&gt;as_register();
2113     __ lock();
2114     NOT_LP64(__ cmpxchg8(Address(addr, 0)));
2115 
2116   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj ) {
2117     NOT_LP64(assert(op-&gt;addr()-&gt;is_single_cpu(), &quot;must be single&quot;);)
2118     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
2119     Register newval = op-&gt;new_value()-&gt;as_register();
2120     Register cmpval = op-&gt;cmp_value()-&gt;as_register();
2121     assert(cmpval == rax, &quot;wrong register&quot;);
2122     assert(newval != NULL, &quot;new val must be register&quot;);
2123     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
2124     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
2125     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
2126 
2127     if ( op-&gt;code() == lir_cas_obj) {
2128 #ifdef _LP64
2129       if (UseCompressedOops) {
2130         __ encode_heap_oop(cmpval);
2131         __ mov(rscratch1, newval);
2132         __ encode_heap_oop(rscratch1);
2133         __ lock();
2134         // cmpval (rax) is implicitly used by this instruction
2135         __ cmpxchgl(rscratch1, Address(addr, 0));
2136       } else
2137 #endif
2138       {
2139         __ lock();
2140         __ cmpxchgptr(newval, Address(addr, 0));
2141       }
2142     } else {
2143       assert(op-&gt;code() == lir_cas_int, &quot;lir_cas_int expected&quot;);
2144       __ lock();
2145       __ cmpxchgl(newval, Address(addr, 0));
2146     }
2147 #ifdef _LP64
2148   } else if (op-&gt;code() == lir_cas_long) {
2149     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
2150     Register newval = op-&gt;new_value()-&gt;as_register_lo();
2151     Register cmpval = op-&gt;cmp_value()-&gt;as_register_lo();
2152     assert(cmpval == rax, &quot;wrong register&quot;);
2153     assert(newval != NULL, &quot;new val must be register&quot;);
2154     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
2155     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
2156     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
2157     __ lock();
2158     __ cmpxchgq(newval, Address(addr, 0));
2159 #endif // _LP64
2160   } else {
2161     Unimplemented();
2162   }
2163 }
2164 
2165 void LIR_Assembler::move(LIR_Opr src, LIR_Opr dst) {
2166   assert(dst-&gt;is_cpu_register(), &quot;must be&quot;);
2167   assert(dst-&gt;type() == src-&gt;type(), &quot;must be&quot;);
2168 
2169   if (src-&gt;is_cpu_register()) {
2170     reg2reg(src, dst);
2171   } else if (src-&gt;is_stack()) {
2172     stack2reg(src, dst, dst-&gt;type());
2173   } else if (src-&gt;is_constant()) {
2174     const2reg(src, dst, lir_patch_none, NULL);
2175   } else {
2176     ShouldNotReachHere();
2177   }
2178 }
2179 
2180 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
2181   Assembler::Condition acond, ncond;
2182   switch (condition) {
2183     case lir_cond_equal:        acond = Assembler::equal;        ncond = Assembler::notEqual;     break;
2184     case lir_cond_notEqual:     acond = Assembler::notEqual;     ncond = Assembler::equal;        break;
2185     case lir_cond_less:         acond = Assembler::less;         ncond = Assembler::greaterEqual; break;
2186     case lir_cond_lessEqual:    acond = Assembler::lessEqual;    ncond = Assembler::greater;      break;
2187     case lir_cond_greaterEqual: acond = Assembler::greaterEqual; ncond = Assembler::less;         break;
2188     case lir_cond_greater:      acond = Assembler::greater;      ncond = Assembler::lessEqual;    break;
2189     case lir_cond_belowEqual:   acond = Assembler::belowEqual;   ncond = Assembler::above;        break;
2190     case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;   ncond = Assembler::below;        break;
2191     default:                    acond = Assembler::equal;        ncond = Assembler::notEqual;
2192                                 ShouldNotReachHere();
2193   }
2194 
2195   if (opr1-&gt;is_cpu_register()) {
2196     reg2reg(opr1, result);
2197   } else if (opr1-&gt;is_stack()) {
2198     stack2reg(opr1, result, result-&gt;type());
2199   } else if (opr1-&gt;is_constant()) {
2200     const2reg(opr1, result, lir_patch_none, NULL);
2201   } else {
2202     ShouldNotReachHere();
2203   }
2204 
2205   if (VM_Version::supports_cmov() &amp;&amp; !opr2-&gt;is_constant()) {
2206     // optimized version that does not require a branch
2207     if (opr2-&gt;is_single_cpu()) {
2208       assert(opr2-&gt;cpu_regnr() != result-&gt;cpu_regnr(), &quot;opr2 already overwritten by previous move&quot;);
2209       __ cmov(ncond, result-&gt;as_register(), opr2-&gt;as_register());
2210     } else if (opr2-&gt;is_double_cpu()) {
2211       assert(opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
2212       assert(opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
2213       __ cmovptr(ncond, result-&gt;as_register_lo(), opr2-&gt;as_register_lo());
2214       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), opr2-&gt;as_register_hi());)
2215     } else if (opr2-&gt;is_single_stack()) {
2216       __ cmovl(ncond, result-&gt;as_register(), frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2217     } else if (opr2-&gt;is_double_stack()) {
2218       __ cmovptr(ncond, result-&gt;as_register_lo(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), lo_word_offset_in_bytes));
2219       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), hi_word_offset_in_bytes));)
2220     } else {
2221       ShouldNotReachHere();
2222     }
2223 
2224   } else {
2225     Label skip;
2226     __ jcc (acond, skip);
2227     if (opr2-&gt;is_cpu_register()) {
2228       reg2reg(opr2, result);
2229     } else if (opr2-&gt;is_stack()) {
2230       stack2reg(opr2, result, result-&gt;type());
2231     } else if (opr2-&gt;is_constant()) {
2232       const2reg(opr2, result, lir_patch_none, NULL);
2233     } else {
2234       ShouldNotReachHere();
2235     }
2236     __ bind(skip);
2237   }
2238 }
2239 
2240 
2241 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
2242   assert(info == NULL, &quot;should never be used, idiv/irem and ldiv/lrem not handled by this method&quot;);
2243 
2244   if (left-&gt;is_single_cpu()) {
2245     assert(left == dest, &quot;left and dest must be equal&quot;);
2246     Register lreg = left-&gt;as_register();
2247 
2248     if (right-&gt;is_single_cpu()) {
2249       // cpu register - cpu register
2250       Register rreg = right-&gt;as_register();
2251       switch (code) {
2252         case lir_add: __ addl (lreg, rreg); break;
2253         case lir_sub: __ subl (lreg, rreg); break;
2254         case lir_mul: __ imull(lreg, rreg); break;
2255         default:      ShouldNotReachHere();
2256       }
2257 
2258     } else if (right-&gt;is_stack()) {
2259       // cpu register - stack
2260       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2261       switch (code) {
2262         case lir_add: __ addl(lreg, raddr); break;
2263         case lir_sub: __ subl(lreg, raddr); break;
2264         default:      ShouldNotReachHere();
2265       }
2266 
2267     } else if (right-&gt;is_constant()) {
2268       // cpu register - constant
2269       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2270       switch (code) {
2271         case lir_add: {
2272           __ incrementl(lreg, c);
2273           break;
2274         }
2275         case lir_sub: {
2276           __ decrementl(lreg, c);
2277           break;
2278         }
2279         default: ShouldNotReachHere();
2280       }
2281 
2282     } else {
2283       ShouldNotReachHere();
2284     }
2285 
2286   } else if (left-&gt;is_double_cpu()) {
2287     assert(left == dest, &quot;left and dest must be equal&quot;);
2288     Register lreg_lo = left-&gt;as_register_lo();
2289     Register lreg_hi = left-&gt;as_register_hi();
2290 
2291     if (right-&gt;is_double_cpu()) {
2292       // cpu register - cpu register
2293       Register rreg_lo = right-&gt;as_register_lo();
2294       Register rreg_hi = right-&gt;as_register_hi();
2295       NOT_LP64(assert_different_registers(lreg_lo, lreg_hi, rreg_lo, rreg_hi));
2296       LP64_ONLY(assert_different_registers(lreg_lo, rreg_lo));
2297       switch (code) {
2298         case lir_add:
2299           __ addptr(lreg_lo, rreg_lo);
2300           NOT_LP64(__ adcl(lreg_hi, rreg_hi));
2301           break;
2302         case lir_sub:
2303           __ subptr(lreg_lo, rreg_lo);
2304           NOT_LP64(__ sbbl(lreg_hi, rreg_hi));
2305           break;
2306         case lir_mul:
2307 #ifdef _LP64
2308           __ imulq(lreg_lo, rreg_lo);
2309 #else
2310           assert(lreg_lo == rax &amp;&amp; lreg_hi == rdx, &quot;must be&quot;);
2311           __ imull(lreg_hi, rreg_lo);
2312           __ imull(rreg_hi, lreg_lo);
2313           __ addl (rreg_hi, lreg_hi);
2314           __ mull (rreg_lo);
2315           __ addl (lreg_hi, rreg_hi);
2316 #endif // _LP64
2317           break;
2318         default:
2319           ShouldNotReachHere();
2320       }
2321 
2322     } else if (right-&gt;is_constant()) {
2323       // cpu register - constant
2324 #ifdef _LP64
2325       jlong c = right-&gt;as_constant_ptr()-&gt;as_jlong_bits();
2326       __ movptr(r10, (intptr_t) c);
2327       switch (code) {
2328         case lir_add:
2329           __ addptr(lreg_lo, r10);
2330           break;
2331         case lir_sub:
2332           __ subptr(lreg_lo, r10);
2333           break;
2334         default:
2335           ShouldNotReachHere();
2336       }
2337 #else
2338       jint c_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2339       jint c_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2340       switch (code) {
2341         case lir_add:
2342           __ addptr(lreg_lo, c_lo);
2343           __ adcl(lreg_hi, c_hi);
2344           break;
2345         case lir_sub:
2346           __ subptr(lreg_lo, c_lo);
2347           __ sbbl(lreg_hi, c_hi);
2348           break;
2349         default:
2350           ShouldNotReachHere();
2351       }
2352 #endif // _LP64
2353 
2354     } else {
2355       ShouldNotReachHere();
2356     }
2357 
2358   } else if (left-&gt;is_single_xmm()) {
2359     assert(left == dest, &quot;left and dest must be equal&quot;);
2360     XMMRegister lreg = left-&gt;as_xmm_float_reg();
2361 
2362     if (right-&gt;is_single_xmm()) {
2363       XMMRegister rreg = right-&gt;as_xmm_float_reg();
2364       switch (code) {
2365         case lir_add: __ addss(lreg, rreg);  break;
2366         case lir_sub: __ subss(lreg, rreg);  break;
2367         case lir_mul_strictfp: // fall through
2368         case lir_mul: __ mulss(lreg, rreg);  break;
2369         case lir_div_strictfp: // fall through
2370         case lir_div: __ divss(lreg, rreg);  break;
2371         default: ShouldNotReachHere();
2372       }
2373     } else {
2374       Address raddr;
2375       if (right-&gt;is_single_stack()) {
2376         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2377       } else if (right-&gt;is_constant()) {
2378         // hack for now
2379         raddr = __ as_Address(InternalAddress(float_constant(right-&gt;as_jfloat())));
2380       } else {
2381         ShouldNotReachHere();
2382       }
2383       switch (code) {
2384         case lir_add: __ addss(lreg, raddr);  break;
2385         case lir_sub: __ subss(lreg, raddr);  break;
2386         case lir_mul_strictfp: // fall through
2387         case lir_mul: __ mulss(lreg, raddr);  break;
2388         case lir_div_strictfp: // fall through
2389         case lir_div: __ divss(lreg, raddr);  break;
2390         default: ShouldNotReachHere();
2391       }
2392     }
2393 
2394   } else if (left-&gt;is_double_xmm()) {
2395     assert(left == dest, &quot;left and dest must be equal&quot;);
2396 
2397     XMMRegister lreg = left-&gt;as_xmm_double_reg();
2398     if (right-&gt;is_double_xmm()) {
2399       XMMRegister rreg = right-&gt;as_xmm_double_reg();
2400       switch (code) {
2401         case lir_add: __ addsd(lreg, rreg);  break;
2402         case lir_sub: __ subsd(lreg, rreg);  break;
2403         case lir_mul_strictfp: // fall through
2404         case lir_mul: __ mulsd(lreg, rreg);  break;
2405         case lir_div_strictfp: // fall through
2406         case lir_div: __ divsd(lreg, rreg);  break;
2407         default: ShouldNotReachHere();
2408       }
2409     } else {
2410       Address raddr;
2411       if (right-&gt;is_double_stack()) {
2412         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2413       } else if (right-&gt;is_constant()) {
2414         // hack for now
2415         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2416       } else {
2417         ShouldNotReachHere();
2418       }
2419       switch (code) {
2420         case lir_add: __ addsd(lreg, raddr);  break;
2421         case lir_sub: __ subsd(lreg, raddr);  break;
2422         case lir_mul_strictfp: // fall through
2423         case lir_mul: __ mulsd(lreg, raddr);  break;
2424         case lir_div_strictfp: // fall through
2425         case lir_div: __ divsd(lreg, raddr);  break;
2426         default: ShouldNotReachHere();
2427       }
2428     }
2429 
2430 #ifndef _LP64
2431   } else if (left-&gt;is_single_fpu()) {
2432     assert(dest-&gt;is_single_fpu(),  &quot;fpu stack allocation required&quot;);
2433 
2434     if (right-&gt;is_single_fpu()) {
2435       arith_fpu_implementation(code, left-&gt;fpu_regnr(), right-&gt;fpu_regnr(), dest-&gt;fpu_regnr(), pop_fpu_stack);
2436 
2437     } else {
2438       assert(left-&gt;fpu_regnr() == 0, &quot;left must be on TOS&quot;);
2439       assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be on TOS&quot;);
2440 
2441       Address raddr;
2442       if (right-&gt;is_single_stack()) {
2443         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2444       } else if (right-&gt;is_constant()) {
2445         address const_addr = float_constant(right-&gt;as_jfloat());
2446         assert(const_addr != NULL, &quot;incorrect float/double constant maintainance&quot;);
2447         // hack for now
2448         raddr = __ as_Address(InternalAddress(const_addr));
2449       } else {
2450         ShouldNotReachHere();
2451       }
2452 
2453       switch (code) {
2454         case lir_add: __ fadd_s(raddr); break;
2455         case lir_sub: __ fsub_s(raddr); break;
2456         case lir_mul_strictfp: // fall through
2457         case lir_mul: __ fmul_s(raddr); break;
2458         case lir_div_strictfp: // fall through
2459         case lir_div: __ fdiv_s(raddr); break;
2460         default:      ShouldNotReachHere();
2461       }
2462     }
2463 
2464   } else if (left-&gt;is_double_fpu()) {
2465     assert(dest-&gt;is_double_fpu(),  &quot;fpu stack allocation required&quot;);
2466 
2467     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2468       // Double values require special handling for strictfp mul/div on x86
2469       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));
2470       __ fmulp(left-&gt;fpu_regnrLo() + 1);
2471     }
2472 
2473     if (right-&gt;is_double_fpu()) {
2474       arith_fpu_implementation(code, left-&gt;fpu_regnrLo(), right-&gt;fpu_regnrLo(), dest-&gt;fpu_regnrLo(), pop_fpu_stack);
2475 
2476     } else {
2477       assert(left-&gt;fpu_regnrLo() == 0, &quot;left must be on TOS&quot;);
2478       assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be on TOS&quot;);
2479 
2480       Address raddr;
2481       if (right-&gt;is_double_stack()) {
2482         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2483       } else if (right-&gt;is_constant()) {
2484         // hack for now
2485         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2486       } else {
2487         ShouldNotReachHere();
2488       }
2489 
2490       switch (code) {
2491         case lir_add: __ fadd_d(raddr); break;
2492         case lir_sub: __ fsub_d(raddr); break;
2493         case lir_mul_strictfp: // fall through
2494         case lir_mul: __ fmul_d(raddr); break;
2495         case lir_div_strictfp: // fall through
2496         case lir_div: __ fdiv_d(raddr); break;
2497         default: ShouldNotReachHere();
2498       }
2499     }
2500 
2501     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2502       // Double values require special handling for strictfp mul/div on x86
2503       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));
2504       __ fmulp(dest-&gt;fpu_regnrLo() + 1);
2505     }
2506 #endif // !_LP64
2507 
2508   } else if (left-&gt;is_single_stack() || left-&gt;is_address()) {
2509     assert(left == dest, &quot;left and dest must be equal&quot;);
2510 
2511     Address laddr;
2512     if (left-&gt;is_single_stack()) {
2513       laddr = frame_map()-&gt;address_for_slot(left-&gt;single_stack_ix());
2514     } else if (left-&gt;is_address()) {
2515       laddr = as_Address(left-&gt;as_address_ptr());
2516     } else {
2517       ShouldNotReachHere();
2518     }
2519 
2520     if (right-&gt;is_single_cpu()) {
2521       Register rreg = right-&gt;as_register();
2522       switch (code) {
2523         case lir_add: __ addl(laddr, rreg); break;
2524         case lir_sub: __ subl(laddr, rreg); break;
2525         default:      ShouldNotReachHere();
2526       }
2527     } else if (right-&gt;is_constant()) {
2528       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2529       switch (code) {
2530         case lir_add: {
2531           __ incrementl(laddr, c);
2532           break;
2533         }
2534         case lir_sub: {
2535           __ decrementl(laddr, c);
2536           break;
2537         }
2538         default: ShouldNotReachHere();
2539       }
2540     } else {
2541       ShouldNotReachHere();
2542     }
2543 
2544   } else {
2545     ShouldNotReachHere();
2546   }
2547 }
2548 
2549 #ifndef _LP64
2550 void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) {
2551   assert(pop_fpu_stack  || (left_index     == dest_index || right_index     == dest_index), &quot;invalid LIR&quot;);
2552   assert(!pop_fpu_stack || (left_index - 1 == dest_index || right_index - 1 == dest_index), &quot;invalid LIR&quot;);
2553   assert(left_index == 0 || right_index == 0, &quot;either must be on top of stack&quot;);
2554 
2555   bool left_is_tos = (left_index == 0);
2556   bool dest_is_tos = (dest_index == 0);
2557   int non_tos_index = (left_is_tos ? right_index : left_index);
2558 
2559   switch (code) {
2560     case lir_add:
2561       if (pop_fpu_stack)       __ faddp(non_tos_index);
2562       else if (dest_is_tos)    __ fadd (non_tos_index);
2563       else                     __ fadda(non_tos_index);
2564       break;
2565 
2566     case lir_sub:
2567       if (left_is_tos) {
2568         if (pop_fpu_stack)     __ fsubrp(non_tos_index);
2569         else if (dest_is_tos)  __ fsub  (non_tos_index);
2570         else                   __ fsubra(non_tos_index);
2571       } else {
2572         if (pop_fpu_stack)     __ fsubp (non_tos_index);
2573         else if (dest_is_tos)  __ fsubr (non_tos_index);
2574         else                   __ fsuba (non_tos_index);
2575       }
2576       break;
2577 
2578     case lir_mul_strictfp: // fall through
2579     case lir_mul:
2580       if (pop_fpu_stack)       __ fmulp(non_tos_index);
2581       else if (dest_is_tos)    __ fmul (non_tos_index);
2582       else                     __ fmula(non_tos_index);
2583       break;
2584 
2585     case lir_div_strictfp: // fall through
2586     case lir_div:
2587       if (left_is_tos) {
2588         if (pop_fpu_stack)     __ fdivrp(non_tos_index);
2589         else if (dest_is_tos)  __ fdiv  (non_tos_index);
2590         else                   __ fdivra(non_tos_index);
2591       } else {
2592         if (pop_fpu_stack)     __ fdivp (non_tos_index);
2593         else if (dest_is_tos)  __ fdivr (non_tos_index);
2594         else                   __ fdiva (non_tos_index);
2595       }
2596       break;
2597 
2598     case lir_rem:
2599       assert(left_is_tos &amp;&amp; dest_is_tos &amp;&amp; right_index == 1, &quot;must be guaranteed by FPU stack allocation&quot;);
2600       __ fremr(noreg);
2601       break;
2602 
2603     default:
2604       ShouldNotReachHere();
2605   }
2606 }
2607 #endif // _LP64
2608 
2609 
2610 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr tmp, LIR_Opr dest, LIR_Op* op) {
2611   if (value-&gt;is_double_xmm()) {
2612     switch(code) {
2613       case lir_abs :
2614         {
2615 #ifdef _LP64
2616           if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
2617             assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
2618             __ vpandn(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg(), 2);
2619           } else
2620 #endif
2621           {
2622             if (dest-&gt;as_xmm_double_reg() != value-&gt;as_xmm_double_reg()) {
2623               __ movdbl(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg());
2624             }
2625             assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
2626             __ andpd(dest-&gt;as_xmm_double_reg(),
2627                      ExternalAddress((address)double_signmask_pool));
2628           }
2629         }
2630         break;
2631 
2632       case lir_sqrt: __ sqrtsd(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg()); break;
2633       // all other intrinsics are not available in the SSE instruction set, so FPU is used
2634       default      : ShouldNotReachHere();
2635     }
2636 
2637 #ifndef _LP64
2638   } else if (value-&gt;is_double_fpu()) {
2639     assert(value-&gt;fpu_regnrLo() == 0 &amp;&amp; dest-&gt;fpu_regnrLo() == 0, &quot;both must be on TOS&quot;);
2640     switch(code) {
2641       case lir_abs   : __ fabs() ; break;
2642       case lir_sqrt  : __ fsqrt(); break;
2643       default      : ShouldNotReachHere();
2644     }
2645 #endif // !_LP64
2646   } else {
2647     Unimplemented();
2648   }
2649 }
2650 
2651 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst) {
2652   // assert(left-&gt;destroys_register(), &quot;check&quot;);
2653   if (left-&gt;is_single_cpu()) {
2654     Register reg = left-&gt;as_register();
2655     if (right-&gt;is_constant()) {
2656       int val = right-&gt;as_constant_ptr()-&gt;as_jint();
2657       switch (code) {
2658         case lir_logic_and: __ andl (reg, val); break;
2659         case lir_logic_or:  __ orl  (reg, val); break;
2660         case lir_logic_xor: __ xorl (reg, val); break;
2661         default: ShouldNotReachHere();
2662       }
2663     } else if (right-&gt;is_stack()) {
2664       // added support for stack operands
2665       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2666       switch (code) {
2667         case lir_logic_and: __ andl (reg, raddr); break;
2668         case lir_logic_or:  __ orl  (reg, raddr); break;
2669         case lir_logic_xor: __ xorl (reg, raddr); break;
2670         default: ShouldNotReachHere();
2671       }
2672     } else {
2673       Register rright = right-&gt;as_register();
2674       switch (code) {
2675         case lir_logic_and: __ andptr (reg, rright); break;
2676         case lir_logic_or : __ orptr  (reg, rright); break;
2677         case lir_logic_xor: __ xorptr (reg, rright); break;
2678         default: ShouldNotReachHere();
2679       }
2680     }
2681     move_regs(reg, dst-&gt;as_register());
2682   } else {
2683     Register l_lo = left-&gt;as_register_lo();
2684     Register l_hi = left-&gt;as_register_hi();
2685     if (right-&gt;is_constant()) {
2686 #ifdef _LP64
2687       __ mov64(rscratch1, right-&gt;as_constant_ptr()-&gt;as_jlong());
2688       switch (code) {
2689         case lir_logic_and:
2690           __ andq(l_lo, rscratch1);
2691           break;
2692         case lir_logic_or:
2693           __ orq(l_lo, rscratch1);
2694           break;
2695         case lir_logic_xor:
2696           __ xorq(l_lo, rscratch1);
2697           break;
2698         default: ShouldNotReachHere();
2699       }
2700 #else
2701       int r_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2702       int r_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2703       switch (code) {
2704         case lir_logic_and:
2705           __ andl(l_lo, r_lo);
2706           __ andl(l_hi, r_hi);
2707           break;
2708         case lir_logic_or:
2709           __ orl(l_lo, r_lo);
2710           __ orl(l_hi, r_hi);
2711           break;
2712         case lir_logic_xor:
2713           __ xorl(l_lo, r_lo);
2714           __ xorl(l_hi, r_hi);
2715           break;
2716         default: ShouldNotReachHere();
2717       }
2718 #endif // _LP64
2719     } else {
2720 #ifdef _LP64
2721       Register r_lo;
2722       if (is_reference_type(right-&gt;type())) {
2723         r_lo = right-&gt;as_register();
2724       } else {
2725         r_lo = right-&gt;as_register_lo();
2726       }
2727 #else
2728       Register r_lo = right-&gt;as_register_lo();
2729       Register r_hi = right-&gt;as_register_hi();
2730       assert(l_lo != r_hi, &quot;overwriting registers&quot;);
2731 #endif
2732       switch (code) {
2733         case lir_logic_and:
2734           __ andptr(l_lo, r_lo);
2735           NOT_LP64(__ andptr(l_hi, r_hi);)
2736           break;
2737         case lir_logic_or:
2738           __ orptr(l_lo, r_lo);
2739           NOT_LP64(__ orptr(l_hi, r_hi);)
2740           break;
2741         case lir_logic_xor:
2742           __ xorptr(l_lo, r_lo);
2743           NOT_LP64(__ xorptr(l_hi, r_hi);)
2744           break;
2745         default: ShouldNotReachHere();
2746       }
2747     }
2748 
2749     Register dst_lo = dst-&gt;as_register_lo();
2750     Register dst_hi = dst-&gt;as_register_hi();
2751 
2752 #ifdef _LP64
2753     move_regs(l_lo, dst_lo);
2754 #else
2755     if (dst_lo == l_hi) {
2756       assert(dst_hi != l_lo, &quot;overwriting registers&quot;);
2757       move_regs(l_hi, dst_hi);
2758       move_regs(l_lo, dst_lo);
2759     } else {
2760       assert(dst_lo != l_hi, &quot;overwriting registers&quot;);
2761       move_regs(l_lo, dst_lo);
2762       move_regs(l_hi, dst_hi);
2763     }
2764 #endif // _LP64
2765   }
2766 }
2767 
2768 
2769 // we assume that rax, and rdx can be overwritten
2770 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
2771 
2772   assert(left-&gt;is_single_cpu(),   &quot;left must be register&quot;);
2773   assert(right-&gt;is_single_cpu() || right-&gt;is_constant(),  &quot;right must be register or constant&quot;);
2774   assert(result-&gt;is_single_cpu(), &quot;result must be register&quot;);
2775 
2776   //  assert(left-&gt;destroys_register(), &quot;check&quot;);
2777   //  assert(right-&gt;destroys_register(), &quot;check&quot;);
2778 
2779   Register lreg = left-&gt;as_register();
2780   Register dreg = result-&gt;as_register();
2781 
2782   if (right-&gt;is_constant()) {
2783     jint divisor = right-&gt;as_constant_ptr()-&gt;as_jint();
2784     assert(divisor &gt; 0 &amp;&amp; is_power_of_2(divisor), &quot;must be&quot;);
2785     if (code == lir_idiv) {
2786       assert(lreg == rax, &quot;must be rax,&quot;);
2787       assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2788       __ cdql(); // sign extend into rdx:rax
2789       if (divisor == 2) {
2790         __ subl(lreg, rdx);
2791       } else {
2792         __ andl(rdx, divisor - 1);
2793         __ addl(lreg, rdx);
2794       }
2795       __ sarl(lreg, log2_jint(divisor));
2796       move_regs(lreg, dreg);
2797     } else if (code == lir_irem) {
2798       Label done;
2799       __ mov(dreg, lreg);
2800       __ andl(dreg, 0x80000000 | (divisor - 1));
2801       __ jcc(Assembler::positive, done);
2802       __ decrement(dreg);
2803       __ orl(dreg, ~(divisor - 1));
2804       __ increment(dreg);
2805       __ bind(done);
2806     } else {
2807       ShouldNotReachHere();
2808     }
2809   } else {
2810     Register rreg = right-&gt;as_register();
2811     assert(lreg == rax, &quot;left register must be rax,&quot;);
2812     assert(rreg != rdx, &quot;right register must not be rdx&quot;);
2813     assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2814 
2815     move_regs(lreg, rax);
2816 
2817     int idivl_offset = __ corrected_idivl(rreg);
2818     if (ImplicitDiv0Checks) {
2819       add_debug_info_for_div0(idivl_offset, info);
2820     }
2821     if (code == lir_irem) {
2822       move_regs(rdx, dreg); // result is in rdx
2823     } else {
2824       move_regs(rax, dreg);
2825     }
2826   }
2827 }
2828 
2829 
2830 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
2831   if (opr1-&gt;is_single_cpu()) {
2832     Register reg1 = opr1-&gt;as_register();
2833     if (opr2-&gt;is_single_cpu()) {
2834       // cpu register - cpu register
2835       if (is_reference_type(opr1-&gt;type())) {
2836         __ cmpoop(reg1, opr2-&gt;as_register());
2837       } else {
2838         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);
2839         __ cmpl(reg1, opr2-&gt;as_register());
2840       }
2841     } else if (opr2-&gt;is_stack()) {
2842       // cpu register - stack
2843       if (is_reference_type(opr1-&gt;type())) {
2844         __ cmpoop(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2845       } else {
2846         __ cmpl(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2847       }
2848     } else if (opr2-&gt;is_constant()) {
2849       // cpu register - constant
2850       LIR_Const* c = opr2-&gt;as_constant_ptr();
2851       if (c-&gt;type() == T_INT) {
2852         __ cmpl(reg1, c-&gt;as_jint());
2853       } else if (c-&gt;type() == T_METADATA) {
2854         // All we need for now is a comparison with NULL for equality.
2855         assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
2856         Metadata* m = c-&gt;as_metadata();
2857         if (m == NULL) {
2858           __ cmpptr(reg1, (int32_t)0);
2859         } else {
2860           ShouldNotReachHere();
2861         }
2862       } else if (is_reference_type(c-&gt;type())) {
2863         // In 64bit oops are single register
2864         jobject o = c-&gt;as_jobject();
2865         if (o == NULL) {
2866           __ cmpptr(reg1, (int32_t)NULL_WORD);
2867         } else {
2868           __ cmpoop(reg1, o);
2869         }
2870       } else {
2871         fatal(&quot;unexpected type: %s&quot;, basictype_to_str(c-&gt;type()));
2872       }
2873       // cpu register - address
2874     } else if (opr2-&gt;is_address()) {
2875       if (op-&gt;info() != NULL) {
2876         add_debug_info_for_null_check_here(op-&gt;info());
2877       }
2878       __ cmpl(reg1, as_Address(opr2-&gt;as_address_ptr()));
2879     } else {
2880       ShouldNotReachHere();
2881     }
2882 
2883   } else if(opr1-&gt;is_double_cpu()) {
2884     Register xlo = opr1-&gt;as_register_lo();
2885     Register xhi = opr1-&gt;as_register_hi();
2886     if (opr2-&gt;is_double_cpu()) {
2887 #ifdef _LP64
2888       __ cmpptr(xlo, opr2-&gt;as_register_lo());
2889 #else
2890       // cpu register - cpu register
2891       Register ylo = opr2-&gt;as_register_lo();
2892       Register yhi = opr2-&gt;as_register_hi();
2893       __ subl(xlo, ylo);
2894       __ sbbl(xhi, yhi);
2895       if (condition == lir_cond_equal || condition == lir_cond_notEqual) {
2896         __ orl(xhi, xlo);
2897       }
2898 #endif // _LP64
2899     } else if (opr2-&gt;is_constant()) {
2900       // cpu register - constant 0
2901       assert(opr2-&gt;as_jlong() == (jlong)0, &quot;only handles zero&quot;);
2902 #ifdef _LP64
2903       __ cmpptr(xlo, (int32_t)opr2-&gt;as_jlong());
2904 #else
2905       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;only handles equals case&quot;);
2906       __ orl(xhi, xlo);
2907 #endif // _LP64
2908     } else {
2909       ShouldNotReachHere();
2910     }
2911 
2912   } else if (opr1-&gt;is_single_xmm()) {
2913     XMMRegister reg1 = opr1-&gt;as_xmm_float_reg();
2914     if (opr2-&gt;is_single_xmm()) {
2915       // xmm register - xmm register
2916       __ ucomiss(reg1, opr2-&gt;as_xmm_float_reg());
2917     } else if (opr2-&gt;is_stack()) {
2918       // xmm register - stack
2919       __ ucomiss(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2920     } else if (opr2-&gt;is_constant()) {
2921       // xmm register - constant
2922       __ ucomiss(reg1, InternalAddress(float_constant(opr2-&gt;as_jfloat())));
2923     } else if (opr2-&gt;is_address()) {
2924       // xmm register - address
2925       if (op-&gt;info() != NULL) {
2926         add_debug_info_for_null_check_here(op-&gt;info());
2927       }
2928       __ ucomiss(reg1, as_Address(opr2-&gt;as_address_ptr()));
2929     } else {
2930       ShouldNotReachHere();
2931     }
2932 
2933   } else if (opr1-&gt;is_double_xmm()) {
2934     XMMRegister reg1 = opr1-&gt;as_xmm_double_reg();
2935     if (opr2-&gt;is_double_xmm()) {
2936       // xmm register - xmm register
2937       __ ucomisd(reg1, opr2-&gt;as_xmm_double_reg());
2938     } else if (opr2-&gt;is_stack()) {
2939       // xmm register - stack
2940       __ ucomisd(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix()));
2941     } else if (opr2-&gt;is_constant()) {
2942       // xmm register - constant
2943       __ ucomisd(reg1, InternalAddress(double_constant(opr2-&gt;as_jdouble())));
2944     } else if (opr2-&gt;is_address()) {
2945       // xmm register - address
2946       if (op-&gt;info() != NULL) {
2947         add_debug_info_for_null_check_here(op-&gt;info());
2948       }
2949       __ ucomisd(reg1, as_Address(opr2-&gt;pointer()-&gt;as_address()));
2950     } else {
2951       ShouldNotReachHere();
2952     }
2953 
2954 #ifndef _LP64
2955   } else if(opr1-&gt;is_single_fpu() || opr1-&gt;is_double_fpu()) {
2956     assert(opr1-&gt;is_fpu_register() &amp;&amp; opr1-&gt;fpu() == 0, &quot;currently left-hand side must be on TOS (relax this restriction)&quot;);
2957     assert(opr2-&gt;is_fpu_register(), &quot;both must be registers&quot;);
2958     __ fcmp(noreg, opr2-&gt;fpu(), op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
2959 #endif // LP64
2960 
2961   } else if (opr1-&gt;is_address() &amp;&amp; opr2-&gt;is_constant()) {
2962     LIR_Const* c = opr2-&gt;as_constant_ptr();
2963 #ifdef _LP64
2964     if (is_reference_type(c-&gt;type())) {
2965       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;need to reverse&quot;);
2966       __ movoop(rscratch1, c-&gt;as_jobject());
2967     }
2968 #endif // LP64
2969     if (op-&gt;info() != NULL) {
2970       add_debug_info_for_null_check_here(op-&gt;info());
2971     }
2972     // special case: address - constant
2973     LIR_Address* addr = opr1-&gt;as_address_ptr();
2974     if (c-&gt;type() == T_INT) {
2975       __ cmpl(as_Address(addr), c-&gt;as_jint());
2976     } else if (is_reference_type(c-&gt;type())) {
2977 #ifdef _LP64
2978       // %%% Make this explode if addr isn&#39;t reachable until we figure out a
2979       // better strategy by giving noreg as the temp for as_Address
2980       __ cmpoop(rscratch1, as_Address(addr, noreg));
2981 #else
2982       __ cmpoop(as_Address(addr), c-&gt;as_jobject());
2983 #endif // _LP64
2984     } else {
2985       ShouldNotReachHere();
2986     }
2987 
2988   } else {
2989     ShouldNotReachHere();
2990   }
2991 }
2992 
2993 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op) {
2994   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
2995     if (left-&gt;is_single_xmm()) {
2996       assert(right-&gt;is_single_xmm(), &quot;must match&quot;);
2997       __ cmpss2int(left-&gt;as_xmm_float_reg(), right-&gt;as_xmm_float_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
2998     } else if (left-&gt;is_double_xmm()) {
2999       assert(right-&gt;is_double_xmm(), &quot;must match&quot;);
3000       __ cmpsd2int(left-&gt;as_xmm_double_reg(), right-&gt;as_xmm_double_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
3001 
3002     } else {
3003 #ifdef _LP64
3004       ShouldNotReachHere();
3005 #else
3006       assert(left-&gt;is_single_fpu() || left-&gt;is_double_fpu(), &quot;must be&quot;);
3007       assert(right-&gt;is_single_fpu() || right-&gt;is_double_fpu(), &quot;must match&quot;);
3008 
3009       assert(left-&gt;fpu() == 0, &quot;left must be on TOS&quot;);
3010       __ fcmp2int(dst-&gt;as_register(), code == lir_ucmp_fd2i, right-&gt;fpu(),
3011                   op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
3012 #endif // LP64
3013     }
3014   } else {
3015     assert(code == lir_cmp_l2i, &quot;check&quot;);
3016 #ifdef _LP64
3017     Label done;
3018     Register dest = dst-&gt;as_register();
3019     __ cmpptr(left-&gt;as_register_lo(), right-&gt;as_register_lo());
3020     __ movl(dest, -1);
3021     __ jccb(Assembler::less, done);
3022     __ set_byte_if_not_zero(dest);
3023     __ movzbl(dest, dest);
3024     __ bind(done);
3025 #else
3026     __ lcmp2int(left-&gt;as_register_hi(),
3027                 left-&gt;as_register_lo(),
3028                 right-&gt;as_register_hi(),
3029                 right-&gt;as_register_lo());
3030     move_regs(left-&gt;as_register_hi(), dst-&gt;as_register());
3031 #endif // _LP64
3032   }
3033 }
3034 
3035 
3036 void LIR_Assembler::align_call(LIR_Code code) {
3037   // make sure that the displacement word of the call ends up word aligned
3038   int offset = __ offset();
3039   switch (code) {
3040   case lir_static_call:
3041   case lir_optvirtual_call:
3042   case lir_dynamic_call:
3043     offset += NativeCall::displacement_offset;
3044     break;
3045   case lir_icvirtual_call:
3046     offset += NativeCall::displacement_offset + NativeMovConstReg::instruction_size;
3047     break;
3048   case lir_virtual_call:  // currently, sparc-specific for niagara
3049   default: ShouldNotReachHere();
3050   }
3051   __ align(BytesPerWord, offset);
3052 }
3053 
3054 
3055 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
3056   assert((__ offset() + NativeCall::displacement_offset) % BytesPerWord == 0,
3057          &quot;must be aligned&quot;);
3058   __ call(AddressLiteral(op-&gt;addr(), rtype));
3059   add_call_info(code_offset(), op-&gt;info(), op-&gt;maybe_return_as_fields());
3060 }
3061 
3062 
3063 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
3064   __ ic_call(op-&gt;addr());
3065   add_call_info(code_offset(), op-&gt;info(), op-&gt;maybe_return_as_fields());
3066   assert((__ offset() - NativeCall::instruction_size + NativeCall::displacement_offset) % BytesPerWord == 0,
3067          &quot;must be aligned&quot;);
3068 }
3069 
3070 
3071 /* Currently, vtable-dispatch is only enabled for sparc platforms */
3072 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
3073   ShouldNotReachHere();
3074 }
3075 
3076 
3077 void LIR_Assembler::emit_static_call_stub() {
3078   address call_pc = __ pc();
3079   address stub = __ start_a_stub(call_stub_size());
3080   if (stub == NULL) {
3081     bailout(&quot;static call stub overflow&quot;);
3082     return;
3083   }
3084 
3085   int start = __ offset();
3086 
3087   // make sure that the displacement word of the call ends up word aligned
3088   __ align(BytesPerWord, __ offset() + NativeMovConstReg::instruction_size + NativeCall::displacement_offset);
3089   __ relocate(static_stub_Relocation::spec(call_pc, false /* is_aot */));
3090   __ mov_metadata(rbx, (Metadata*)NULL);
3091   // must be set to -1 at code generation time
3092   assert(((__ offset() + 1) % BytesPerWord) == 0, &quot;must be aligned&quot;);
3093   // On 64bit this will die since it will take a movq &amp; jmp, must be only a jmp
3094   __ jump(RuntimeAddress(__ pc()));
3095 
3096   if (UseAOT) {
3097     // Trampoline to aot code
3098     __ relocate(static_stub_Relocation::spec(call_pc, true /* is_aot */));
3099 #ifdef _LP64
3100     __ mov64(rax, CONST64(0));  // address is zapped till fixup time.
3101 #else
3102     __ movl(rax, 0xdeadffff);  // address is zapped till fixup time.
3103 #endif
3104     __ jmp(rax);
3105   }
3106   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);
3107   __ end_a_stub();
3108 }
3109 
3110 
3111 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
3112   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
3113   assert(exceptionPC-&gt;as_register() == rdx, &quot;must match&quot;);
3114 
3115   // exception object is not added to oop map by LinearScan
3116   // (LinearScan assumes that no oops are in fixed registers)
3117   info-&gt;add_register_oop(exceptionOop);
3118   Runtime1::StubID unwind_id;
3119 
3120   // get current pc information
3121   // pc is only needed if the method has an exception handler, the unwind code does not need it.
3122   int pc_for_athrow_offset = __ offset();
3123   InternalAddress pc_for_athrow(__ pc());
3124   __ lea(exceptionPC-&gt;as_register(), pc_for_athrow);
3125   add_call_info(pc_for_athrow_offset, info); // for exception handler
3126 
3127   __ verify_not_null_oop(rax);
3128   // search an exception handler (rax: exception oop, rdx: throwing pc)
3129   if (compilation()-&gt;has_fpu_code()) {
3130     unwind_id = Runtime1::handle_exception_id;
3131   } else {
3132     unwind_id = Runtime1::handle_exception_nofpu_id;
3133   }
3134   __ call(RuntimeAddress(Runtime1::entry_for(unwind_id)));
3135 
3136   // enough room for two byte trap
3137   __ nop();
3138 }
3139 
3140 
3141 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
3142   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
3143 
3144   __ jmp(_unwind_handler_entry);
3145 }
3146 
3147 
3148 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
3149 
3150   // optimized version for linear scan:
3151   // * count must be already in ECX (guaranteed by LinearScan)
3152   // * left and dest must be equal
3153   // * tmp must be unused
3154   assert(count-&gt;as_register() == SHIFT_count, &quot;count must be in ECX&quot;);
3155   assert(left == dest, &quot;left and dest must be equal&quot;);
3156   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
3157 
3158   if (left-&gt;is_single_cpu()) {
3159     Register value = left-&gt;as_register();
3160     assert(value != SHIFT_count, &quot;left cannot be ECX&quot;);
3161 
3162     switch (code) {
3163       case lir_shl:  __ shll(value); break;
3164       case lir_shr:  __ sarl(value); break;
3165       case lir_ushr: __ shrl(value); break;
3166       default: ShouldNotReachHere();
3167     }
3168   } else if (left-&gt;is_double_cpu()) {
3169     Register lo = left-&gt;as_register_lo();
3170     Register hi = left-&gt;as_register_hi();
3171     assert(lo != SHIFT_count &amp;&amp; hi != SHIFT_count, &quot;left cannot be ECX&quot;);
3172 #ifdef _LP64
3173     switch (code) {
3174       case lir_shl:  __ shlptr(lo);        break;
3175       case lir_shr:  __ sarptr(lo);        break;
3176       case lir_ushr: __ shrptr(lo);        break;
3177       default: ShouldNotReachHere();
3178     }
3179 #else
3180 
3181     switch (code) {
3182       case lir_shl:  __ lshl(hi, lo);        break;
3183       case lir_shr:  __ lshr(hi, lo, true);  break;
3184       case lir_ushr: __ lshr(hi, lo, false); break;
3185       default: ShouldNotReachHere();
3186     }
3187 #endif // LP64
3188   } else {
3189     ShouldNotReachHere();
3190   }
3191 }
3192 
3193 
3194 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
3195   if (dest-&gt;is_single_cpu()) {
3196     // first move left into dest so that left is not destroyed by the shift
3197     Register value = dest-&gt;as_register();
3198     count = count &amp; 0x1F; // Java spec
3199 
3200     move_regs(left-&gt;as_register(), value);
3201     switch (code) {
3202       case lir_shl:  __ shll(value, count); break;
3203       case lir_shr:  __ sarl(value, count); break;
3204       case lir_ushr: __ shrl(value, count); break;
3205       default: ShouldNotReachHere();
3206     }
3207   } else if (dest-&gt;is_double_cpu()) {
3208 #ifndef _LP64
3209     Unimplemented();
3210 #else
3211     // first move left into dest so that left is not destroyed by the shift
3212     Register value = dest-&gt;as_register_lo();
3213     count = count &amp; 0x1F; // Java spec
3214 
3215     move_regs(left-&gt;as_register_lo(), value);
3216     switch (code) {
3217       case lir_shl:  __ shlptr(value, count); break;
3218       case lir_shr:  __ sarptr(value, count); break;
3219       case lir_ushr: __ shrptr(value, count); break;
3220       default: ShouldNotReachHere();
3221     }
3222 #endif // _LP64
3223   } else {
3224     ShouldNotReachHere();
3225   }
3226 }
3227 
3228 
3229 void LIR_Assembler::store_parameter(Register r, int offset_from_rsp_in_words) {
3230   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3231   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3232   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3233   __ movptr (Address(rsp, offset_from_rsp_in_bytes), r);
3234 }
3235 
3236 
3237 void LIR_Assembler::store_parameter(jint c,     int offset_from_rsp_in_words) {
3238   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3239   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3240   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3241   __ movptr (Address(rsp, offset_from_rsp_in_bytes), c);
3242 }
3243 
3244 
3245 void LIR_Assembler::store_parameter(jobject o,  int offset_from_rsp_in_words) {
3246   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3247   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3248   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3249   __ movoop (Address(rsp, offset_from_rsp_in_bytes), o);
3250 }
3251 
3252 
3253 void LIR_Assembler::store_parameter(Metadata* m,  int offset_from_rsp_in_words) {
3254   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3255   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3256   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3257   __ mov_metadata(Address(rsp, offset_from_rsp_in_bytes), m);
3258 }
3259 
3260 
3261 void LIR_Assembler::arraycopy_valuetype_check(Register obj, Register tmp, CodeStub* slow_path, bool is_dest, bool null_check) {
3262   if (null_check) {
3263     __ testptr(obj, obj);
3264     __ jcc(Assembler::zero, *slow_path-&gt;entry());
3265   }
3266   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
3267   __ load_klass(tmp, obj, tmp_load_klass);
3268   __ movl(tmp, Address(tmp, Klass::layout_helper_offset()));
3269   if (is_dest) {
3270     // We also take slow path if it&#39;s a null_free destination array, just in case the source array
3271     // contains NULLs.
3272     __ testl(tmp, Klass::_lh_null_free_bit_inplace);
3273   } else {
3274     __ testl(tmp, Klass::_lh_array_tag_vt_value_bit_inplace);
3275   }
3276   __ jcc(Assembler::notZero, *slow_path-&gt;entry());
3277 }
3278 
3279 
3280 // This code replaces a call to arraycopy; no exception may
3281 // be thrown in this code, they must be thrown in the System.arraycopy
3282 // activation frame; we could save some checks if this would not be the case
3283 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
3284   ciArrayKlass* default_type = op-&gt;expected_type();
3285   Register src = op-&gt;src()-&gt;as_register();
3286   Register dst = op-&gt;dst()-&gt;as_register();
3287   Register src_pos = op-&gt;src_pos()-&gt;as_register();
3288   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
3289   Register length  = op-&gt;length()-&gt;as_register();
3290   Register tmp = op-&gt;tmp()-&gt;as_register();
3291   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
3292 
3293   __ resolve(ACCESS_READ, src);
3294   __ resolve(ACCESS_WRITE, dst);
3295 
3296   CodeStub* stub = op-&gt;stub();
3297   int flags = op-&gt;flags();
3298   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
3299   if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3300 
3301   if (flags &amp; LIR_OpArrayCopy::always_slow_path) {
3302     __ jmp(*stub-&gt;entry());
3303     __ bind(*stub-&gt;continuation());
3304     return;
3305   }
3306 
3307   if (flags &amp; LIR_OpArrayCopy::src_valuetype_check) {
3308     arraycopy_valuetype_check(src, tmp, stub, false, (flags &amp; LIR_OpArrayCopy::src_null_check));
3309   }
3310 
3311   if (flags &amp; LIR_OpArrayCopy::dst_valuetype_check) {
3312     arraycopy_valuetype_check(dst, tmp, stub, true, (flags &amp; LIR_OpArrayCopy::dst_null_check));
3313   }
3314 
3315   // if we don&#39;t know anything, just go through the generic arraycopy
3316   if (default_type == NULL) {
3317     // save outgoing arguments on stack in case call to System.arraycopy is needed
3318     // HACK ALERT. This code used to push the parameters in a hardwired fashion
3319     // for interpreter calling conventions. Now we have to do it in new style conventions.
3320     // For the moment until C1 gets the new register allocator I just force all the
3321     // args to the right place (except the register args) and then on the back side
3322     // reload the register args properly if we go slow path. Yuck
3323 
3324     // These are proper for the calling convention
3325     store_parameter(length, 2);
3326     store_parameter(dst_pos, 1);
3327     store_parameter(dst, 0);
3328 
3329     // these are just temporary placements until we need to reload
3330     store_parameter(src_pos, 3);
3331     store_parameter(src, 4);
3332     NOT_LP64(assert(src == rcx &amp;&amp; src_pos == rdx, &quot;mismatch in calling convention&quot;);)
3333 
3334     address copyfunc_addr = StubRoutines::generic_arraycopy();
3335     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
3336 
3337     // pass arguments: may push as this is not a safepoint; SP must be fix at each safepoint
3338 #ifdef _LP64
3339     // The arguments are in java calling convention so we can trivially shift them to C
3340     // convention
3341     assert_different_registers(c_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4);
3342     __ mov(c_rarg0, j_rarg0);
3343     assert_different_registers(c_rarg1, j_rarg2, j_rarg3, j_rarg4);
3344     __ mov(c_rarg1, j_rarg1);
3345     assert_different_registers(c_rarg2, j_rarg3, j_rarg4);
3346     __ mov(c_rarg2, j_rarg2);
3347     assert_different_registers(c_rarg3, j_rarg4);
3348     __ mov(c_rarg3, j_rarg3);
3349 #ifdef _WIN64
3350     // Allocate abi space for args but be sure to keep stack aligned
3351     __ subptr(rsp, 6*wordSize);
3352     store_parameter(j_rarg4, 4);
3353 #ifndef PRODUCT
3354     if (PrintC1Statistics) {
3355       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3356     }
3357 #endif
3358     __ call(RuntimeAddress(copyfunc_addr));
3359     __ addptr(rsp, 6*wordSize);
3360 #else
3361     __ mov(c_rarg4, j_rarg4);
3362 #ifndef PRODUCT
3363     if (PrintC1Statistics) {
3364       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3365     }
3366 #endif
3367     __ call(RuntimeAddress(copyfunc_addr));
3368 #endif // _WIN64
3369 #else
3370     __ push(length);
3371     __ push(dst_pos);
3372     __ push(dst);
3373     __ push(src_pos);
3374     __ push(src);
3375 
3376 #ifndef PRODUCT
3377     if (PrintC1Statistics) {
3378       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3379     }
3380 #endif
3381     __ call_VM_leaf(copyfunc_addr, 5); // removes pushed parameter from the stack
3382 
3383 #endif // _LP64
3384 
3385     __ cmpl(rax, 0);
3386     __ jcc(Assembler::equal, *stub-&gt;continuation());
3387 
3388     __ mov(tmp, rax);
3389     __ xorl(tmp, -1);
3390 
3391     // Reload values from the stack so they are where the stub
3392     // expects them.
3393     __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3394     __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3395     __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3396     __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3397     __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3398 
3399     __ subl(length, tmp);
3400     __ addl(src_pos, tmp);
3401     __ addl(dst_pos, tmp);
3402     __ jmp(*stub-&gt;entry());
3403 
3404     __ bind(*stub-&gt;continuation());
3405     return;
3406   }
3407 
3408   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass() &amp;&amp; default_type-&gt;is_loaded(), &quot;must be true at this point&quot;);
3409 
3410   int elem_size = type2aelembytes(basic_type);
3411   Address::ScaleFactor scale;
3412 
3413   switch (elem_size) {
3414     case 1 :
3415       scale = Address::times_1;
3416       break;
3417     case 2 :
3418       scale = Address::times_2;
3419       break;
3420     case 4 :
3421       scale = Address::times_4;
3422       break;
3423     case 8 :
3424       scale = Address::times_8;
3425       break;
3426     default:
3427       scale = Address::no_scale;
3428       ShouldNotReachHere();
3429   }
3430 
3431   Address src_length_addr = Address(src, arrayOopDesc::length_offset_in_bytes());
3432   Address dst_length_addr = Address(dst, arrayOopDesc::length_offset_in_bytes());
3433   Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());
3434   Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());
3435 
3436   // length and pos&#39;s are all sign extended at this point on 64bit
3437 
3438   // test for NULL
3439   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
3440     __ testptr(src, src);
3441     __ jcc(Assembler::zero, *stub-&gt;entry());
3442   }
3443   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
3444     __ testptr(dst, dst);
3445     __ jcc(Assembler::zero, *stub-&gt;entry());
3446   }
3447 
3448   // If the compiler was not able to prove that exact type of the source or the destination
3449   // of the arraycopy is an array type, check at runtime if the source or the destination is
3450   // an instance type.
3451   if (flags &amp; LIR_OpArrayCopy::type_check) {
3452     if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
3453       __ load_klass(tmp, dst, tmp_load_klass);
3454       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3455       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3456     }
3457 
3458     if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
3459       __ load_klass(tmp, src, tmp_load_klass);
3460       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3461       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3462     }
3463   }
3464 
3465   // check if negative
3466   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
3467     __ testl(src_pos, src_pos);
3468     __ jcc(Assembler::less, *stub-&gt;entry());
3469   }
3470   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
3471     __ testl(dst_pos, dst_pos);
3472     __ jcc(Assembler::less, *stub-&gt;entry());
3473   }
3474 
3475   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
3476     __ lea(tmp, Address(src_pos, length, Address::times_1, 0));
3477     __ cmpl(tmp, src_length_addr);
3478     __ jcc(Assembler::above, *stub-&gt;entry());
3479   }
3480   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
3481     __ lea(tmp, Address(dst_pos, length, Address::times_1, 0));
3482     __ cmpl(tmp, dst_length_addr);
3483     __ jcc(Assembler::above, *stub-&gt;entry());
3484   }
3485 
3486   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
3487     __ testl(length, length);
3488     __ jcc(Assembler::less, *stub-&gt;entry());
3489   }
3490 
3491 #ifdef _LP64
3492   __ movl2ptr(src_pos, src_pos); //higher 32bits must be null
3493   __ movl2ptr(dst_pos, dst_pos); //higher 32bits must be null
3494 #endif
3495 
3496   if (flags &amp; LIR_OpArrayCopy::type_check) {
3497     // We don&#39;t know the array types are compatible
3498     if (basic_type != T_OBJECT) {
3499       // Simple test for basic type arrays
3500       if (UseCompressedClassPointers) {
3501         __ movl(tmp, src_klass_addr);
3502         __ cmpl(tmp, dst_klass_addr);
3503       } else {
3504         __ movptr(tmp, src_klass_addr);
3505         __ cmpptr(tmp, dst_klass_addr);
3506       }
3507       __ jcc(Assembler::notEqual, *stub-&gt;entry());
3508     } else {
3509       // For object arrays, if src is a sub class of dst then we can
3510       // safely do the copy.
3511       Label cont, slow;
3512 
3513       __ push(src);
3514       __ push(dst);
3515 
3516       __ load_klass(src, src, tmp_load_klass);
3517       __ load_klass(dst, dst, tmp_load_klass);
3518 
3519       __ check_klass_subtype_fast_path(src, dst, tmp, &amp;cont, &amp;slow, NULL);
3520 
3521       __ push(src);
3522       __ push(dst);
3523       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
3524       __ pop(dst);
3525       __ pop(src);
3526 
3527       __ cmpl(src, 0);
3528       __ jcc(Assembler::notEqual, cont);
3529 
3530       __ bind(slow);
3531       __ pop(dst);
3532       __ pop(src);
3533 
3534       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
3535       if (copyfunc_addr != NULL) { // use stub if available
3536         // src is not a sub class of dst so we have to do a
3537         // per-element check.
3538 
3539         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
3540         if ((flags &amp; mask) != mask) {
3541           // Check that at least both of them object arrays.
3542           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
3543 
3544           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
3545             __ load_klass(tmp, src, tmp_load_klass);
3546           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
3547             __ load_klass(tmp, dst, tmp_load_klass);
3548           }
3549           int lh_offset = in_bytes(Klass::layout_helper_offset());
3550           Address klass_lh_addr(tmp, lh_offset);
3551           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
3552           __ cmpl(klass_lh_addr, objArray_lh);
3553           __ jcc(Assembler::notEqual, *stub-&gt;entry());
3554         }
3555 
3556        // Spill because stubs can use any register they like and it&#39;s
3557        // easier to restore just those that we care about.
3558        store_parameter(dst, 0);
3559        store_parameter(dst_pos, 1);
3560        store_parameter(length, 2);
3561        store_parameter(src_pos, 3);
3562        store_parameter(src, 4);
3563 
3564 #ifndef _LP64
3565         __ movptr(tmp, dst_klass_addr);
3566         __ movptr(tmp, Address(tmp, ObjArrayKlass::element_klass_offset()));
3567         __ push(tmp);
3568         __ movl(tmp, Address(tmp, Klass::super_check_offset_offset()));
3569         __ push(tmp);
3570         __ push(length);
3571         __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3572         __ push(tmp);
3573         __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3574         __ push(tmp);
3575 
3576         __ call_VM_leaf(copyfunc_addr, 5);
3577 #else
3578         __ movl2ptr(length, length); //higher 32bits must be null
3579 
3580         __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3581         assert_different_registers(c_rarg0, dst, dst_pos, length);
3582         __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3583         assert_different_registers(c_rarg1, dst, length);
3584 
3585         __ mov(c_rarg2, length);
3586         assert_different_registers(c_rarg2, dst);
3587 
3588 #ifdef _WIN64
3589         // Allocate abi space for args but be sure to keep stack aligned
3590         __ subptr(rsp, 6*wordSize);
3591         __ load_klass(c_rarg3, dst, tmp_load_klass);
3592         __ movptr(c_rarg3, Address(c_rarg3, ObjArrayKlass::element_klass_offset()));
3593         store_parameter(c_rarg3, 4);
3594         __ movl(c_rarg3, Address(c_rarg3, Klass::super_check_offset_offset()));
3595         __ call(RuntimeAddress(copyfunc_addr));
3596         __ addptr(rsp, 6*wordSize);
3597 #else
3598         __ load_klass(c_rarg4, dst, tmp_load_klass);
3599         __ movptr(c_rarg4, Address(c_rarg4, ObjArrayKlass::element_klass_offset()));
3600         __ movl(c_rarg3, Address(c_rarg4, Klass::super_check_offset_offset()));
3601         __ call(RuntimeAddress(copyfunc_addr));
3602 #endif
3603 
3604 #endif
3605 
3606 #ifndef PRODUCT
3607         if (PrintC1Statistics) {
3608           Label failed;
3609           __ testl(rax, rax);
3610           __ jcc(Assembler::notZero, failed);
3611           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_cnt));
3612           __ bind(failed);
3613         }
3614 #endif
3615 
3616         __ testl(rax, rax);
3617         __ jcc(Assembler::zero, *stub-&gt;continuation());
3618 
3619 #ifndef PRODUCT
3620         if (PrintC1Statistics) {
3621           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt));
3622         }
3623 #endif
3624 
3625         __ mov(tmp, rax);
3626 
3627         __ xorl(tmp, -1);
3628 
3629         // Restore previously spilled arguments
3630         __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3631         __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3632         __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3633         __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3634         __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3635 
3636 
3637         __ subl(length, tmp);
3638         __ addl(src_pos, tmp);
3639         __ addl(dst_pos, tmp);
3640       }
3641 
3642       __ jmp(*stub-&gt;entry());
3643 
3644       __ bind(cont);
3645       __ pop(dst);
3646       __ pop(src);
3647     }
3648   }
3649 
3650 #ifdef ASSERT
3651   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
3652     // Sanity check the known type with the incoming class.  For the
3653     // primitive case the types must match exactly with src.klass and
3654     // dst.klass each exactly matching the default type.  For the
3655     // object array case, if no type check is needed then either the
3656     // dst type is exactly the expected type and the src type is a
3657     // subtype which we can&#39;t check or src is the same array as dst
3658     // but not necessarily exactly of type default_type.
3659     Label known_ok, halt;
3660     __ mov_metadata(tmp, default_type-&gt;constant_encoding());
3661 #ifdef _LP64
3662     if (UseCompressedClassPointers) {
3663       __ encode_klass_not_null(tmp, rscratch1);
3664     }
3665 #endif
3666 
3667     if (basic_type != T_OBJECT) {
3668 
3669       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3670       else                   __ cmpptr(tmp, dst_klass_addr);
3671       __ jcc(Assembler::notEqual, halt);
3672       if (UseCompressedClassPointers)          __ cmpl(tmp, src_klass_addr);
3673       else                   __ cmpptr(tmp, src_klass_addr);
3674       __ jcc(Assembler::equal, known_ok);
3675     } else {
3676       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3677       else                   __ cmpptr(tmp, dst_klass_addr);
3678       __ jcc(Assembler::equal, known_ok);
3679       __ cmpptr(src, dst);
3680       __ jcc(Assembler::equal, known_ok);
3681     }
3682     __ bind(halt);
3683     __ stop(&quot;incorrect type information in arraycopy&quot;);
3684     __ bind(known_ok);
3685   }
3686 #endif
3687 
3688 #ifndef PRODUCT
3689   if (PrintC1Statistics) {
3690     __ incrementl(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)));
3691   }
3692 #endif
3693 
3694 #ifdef _LP64
3695   assert_different_registers(c_rarg0, dst, dst_pos, length);
3696   __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3697   assert_different_registers(c_rarg1, length);
3698   __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3699   __ mov(c_rarg2, length);
3700 
3701 #else
3702   __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3703   store_parameter(tmp, 0);
3704   __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3705   store_parameter(tmp, 1);
3706   store_parameter(length, 2);
3707 #endif // _LP64
3708 
3709   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
3710   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
3711   const char *name;
3712   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
3713   __ call_VM_leaf(entry, 0);
3714 
3715   __ bind(*stub-&gt;continuation());
3716 }
3717 
3718 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
3719   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
3720   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
3721   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
3722   Register crc = op-&gt;crc()-&gt;as_register();
3723   Register val = op-&gt;val()-&gt;as_register();
3724   Register res = op-&gt;result_opr()-&gt;as_register();
3725 
3726   assert_different_registers(val, crc, res);
3727 
3728   __ lea(res, ExternalAddress(StubRoutines::crc_table_addr()));
3729   __ notl(crc); // ~crc
3730   __ update_byte_crc32(crc, val, res);
3731   __ notl(crc); // ~crc
3732   __ mov(res, crc);
3733 }
3734 
3735 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
3736   Register obj = op-&gt;obj_opr()-&gt;as_register();  // may not be an oop
3737   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
3738   Register lock = op-&gt;lock_opr()-&gt;as_register();
3739   if (!UseFastLocking) {
3740     __ jmp(*op-&gt;stub()-&gt;entry());
3741   } else if (op-&gt;code() == lir_lock) {
3742     Register scratch = noreg;
3743     if (UseBiasedLocking) {
3744       scratch = op-&gt;scratch_opr()-&gt;as_register();
3745     }
3746     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3747     __ resolve(ACCESS_READ | ACCESS_WRITE, obj);
3748     // add debug info for NullPointerException only if one is possible
3749     int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op-&gt;stub()-&gt;entry());
3750     if (op-&gt;info() != NULL) {
3751       add_debug_info_for_null_check(null_check_offset, op-&gt;info());
3752     }
3753     // done
3754   } else if (op-&gt;code() == lir_unlock) {
3755     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3756     __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
3757   } else {
3758     Unimplemented();
3759   }
3760   __ bind(*op-&gt;stub()-&gt;continuation());
3761 }
3762 
3763 
3764 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
3765   ciMethod* method = op-&gt;profiled_method();
3766   int bci          = op-&gt;profiled_bci();
3767   ciMethod* callee = op-&gt;profiled_callee();
3768   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
3769 
3770   // Update counter for all call types
3771   ciMethodData* md = method-&gt;method_data_or_null();
3772   assert(md != NULL, &quot;Sanity&quot;);
3773   ciProfileData* data = md-&gt;bci_to_data(bci);
3774   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
3775   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
3776   Register mdo  = op-&gt;mdo()-&gt;as_register();
3777   __ mov_metadata(mdo, md-&gt;constant_encoding());
3778   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
3779   // Perform additional virtual call profiling for invokevirtual and
3780   // invokeinterface bytecodes
3781   if (op-&gt;should_profile_receiver_type()) {
3782     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
3783     Register recv = op-&gt;recv()-&gt;as_register();
3784     assert_different_registers(mdo, recv);
3785     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
3786     ciKlass* known_klass = op-&gt;known_holder();
3787     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
3788       // We know the type that will be seen at this call site; we can
3789       // statically update the MethodData* rather than needing to do
3790       // dynamic tests on the receiver type
3791 
3792       // NOTE: we should probably put a lock around this search to
3793       // avoid collisions by concurrent compilations
3794       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
3795       uint i;
3796       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3797         ciKlass* receiver = vc_data-&gt;receiver(i);
3798         if (known_klass-&gt;equals(receiver)) {
3799           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3800           __ addptr(data_addr, DataLayout::counter_increment);
3801           return;
3802         }
3803       }
3804 
3805       // Receiver type not found in profile data; select an empty slot
3806 
3807       // Note that this is less efficient than it should be because it
3808       // always does a write to the receiver part of the
3809       // VirtualCallData rather than just the first time
3810       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3811         ciKlass* receiver = vc_data-&gt;receiver(i);
3812         if (receiver == NULL) {
3813           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));
3814           __ mov_metadata(recv_addr, known_klass-&gt;constant_encoding());
3815           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3816           __ addptr(data_addr, DataLayout::counter_increment);
3817           return;
3818         }
3819       }
3820     } else {
3821       __ load_klass(recv, recv, tmp_load_klass);
3822       Label update_done;
3823       type_profile_helper(mdo, md, data, recv, &amp;update_done);
3824       // Receiver did not match any saved receiver and there is no empty row for it.
3825       // Increment total counter to indicate polymorphic case.
3826       __ addptr(counter_addr, DataLayout::counter_increment);
3827 
3828       __ bind(update_done);
3829     }
3830   } else {
3831     // Static call
3832     __ addptr(counter_addr, DataLayout::counter_increment);
3833   }
3834 }
3835 
3836 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
3837   Register obj = op-&gt;obj()-&gt;as_register();
3838   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
3839   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
3840   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
3841   ciKlass* exact_klass = op-&gt;exact_klass();
3842   intptr_t current_klass = op-&gt;current_klass();
3843   bool not_null = op-&gt;not_null();
3844   bool no_conflict = op-&gt;no_conflict();
3845 
3846   Label update, next, none;
3847 
3848   bool do_null = !not_null;
3849   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
3850   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
3851 
3852   assert(do_null || do_update, &quot;why are we here?&quot;);
3853   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
3854 
3855   __ verify_oop(obj);
3856 
3857   if (tmp != obj) {
3858     __ mov(tmp, obj);
3859   }
3860   if (do_null) {
3861     __ testptr(tmp, tmp);
3862     __ jccb(Assembler::notZero, update);
3863     if (!TypeEntries::was_null_seen(current_klass)) {
3864       __ orptr(mdo_addr, TypeEntries::null_seen);
3865     }
3866     if (do_update) {
3867 #ifndef ASSERT
3868       __ jmpb(next);
3869     }
3870 #else
3871       __ jmp(next);
3872     }
3873   } else {
3874     __ testptr(tmp, tmp);
3875     __ jcc(Assembler::notZero, update);
3876     __ stop(&quot;unexpect null obj&quot;);
3877 #endif
3878   }
3879 
3880   __ bind(update);
3881 
3882   if (do_update) {
3883 #ifdef ASSERT
3884     if (exact_klass != NULL) {
3885       Label ok;
3886       __ load_klass(tmp, tmp, tmp_load_klass);
3887       __ push(tmp);
3888       __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3889       __ cmpptr(tmp, Address(rsp, 0));
3890       __ jcc(Assembler::equal, ok);
3891       __ stop(&quot;exact klass and actual klass differ&quot;);
3892       __ bind(ok);
3893       __ pop(tmp);
3894     }
3895 #endif
3896     if (!no_conflict) {
3897       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
3898         if (exact_klass != NULL) {
3899           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3900         } else {
3901           __ load_klass(tmp, tmp, tmp_load_klass);
3902         }
3903 
3904         __ xorptr(tmp, mdo_addr);
3905         __ testptr(tmp, TypeEntries::type_klass_mask);
3906         // klass seen before, nothing to do. The unknown bit may have been
3907         // set already but no need to check.
3908         __ jccb(Assembler::zero, next);
3909 
3910         __ testptr(tmp, TypeEntries::type_unknown);
3911         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3912 
3913         if (TypeEntries::is_type_none(current_klass)) {
3914           __ cmpptr(mdo_addr, 0);
3915           __ jccb(Assembler::equal, none);
3916           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3917           __ jccb(Assembler::equal, none);
3918           // There is a chance that the checks above (re-reading profiling
3919           // data from memory) fail if another thread has just set the
3920           // profiling to this obj&#39;s klass
3921           __ xorptr(tmp, mdo_addr);
3922           __ testptr(tmp, TypeEntries::type_klass_mask);
3923           __ jccb(Assembler::zero, next);
3924         }
3925       } else {
3926         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3927                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
3928 
3929         __ movptr(tmp, mdo_addr);
3930         __ testptr(tmp, TypeEntries::type_unknown);
3931         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3932       }
3933 
3934       // different than before. Cannot keep accurate profile.
3935       __ orptr(mdo_addr, TypeEntries::type_unknown);
3936 
3937       if (TypeEntries::is_type_none(current_klass)) {
3938         __ jmpb(next);
3939 
3940         __ bind(none);
3941         // first time here. Set profile type.
3942         __ movptr(mdo_addr, tmp);
3943       }
3944     } else {
3945       // There&#39;s a single possible klass at this profile point
3946       assert(exact_klass != NULL, &quot;should be&quot;);
3947       if (TypeEntries::is_type_none(current_klass)) {
3948         __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3949         __ xorptr(tmp, mdo_addr);
3950         __ testptr(tmp, TypeEntries::type_klass_mask);
3951 #ifdef ASSERT
3952         __ jcc(Assembler::zero, next);
3953 
3954         {
3955           Label ok;
3956           __ push(tmp);
3957           __ cmpptr(mdo_addr, 0);
3958           __ jcc(Assembler::equal, ok);
3959           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3960           __ jcc(Assembler::equal, ok);
3961           // may have been set by another thread
3962           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3963           __ xorptr(tmp, mdo_addr);
3964           __ testptr(tmp, TypeEntries::type_mask);
3965           __ jcc(Assembler::zero, ok);
3966 
3967           __ stop(&quot;unexpected profiling mismatch&quot;);
3968           __ bind(ok);
3969           __ pop(tmp);
3970         }
3971 #else
3972         __ jccb(Assembler::zero, next);
3973 #endif
3974         // first time here. Set profile type.
3975         __ movptr(mdo_addr, tmp);
3976       } else {
3977         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3978                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
3979 
3980         __ movptr(tmp, mdo_addr);
3981         __ testptr(tmp, TypeEntries::type_unknown);
3982         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3983 
3984         __ orptr(mdo_addr, TypeEntries::type_unknown);
3985       }
3986     }
3987 
3988     __ bind(next);
3989   }
3990 }
3991 
3992 void LIR_Assembler::emit_delay(LIR_OpDelay*) {
3993   Unimplemented();
3994 }
3995 
3996 
3997 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst) {
3998   __ lea(dst-&gt;as_register(), frame_map()-&gt;address_for_monitor_lock(monitor_no));
3999 }
4000 
4001 
4002 void LIR_Assembler::align_backward_branch_target() {
4003   __ align(BytesPerWord);
4004 }
4005 
4006 
4007 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
4008   if (left-&gt;is_single_cpu()) {
4009     __ negl(left-&gt;as_register());
4010     move_regs(left-&gt;as_register(), dest-&gt;as_register());
4011 
4012   } else if (left-&gt;is_double_cpu()) {
4013     Register lo = left-&gt;as_register_lo();
4014 #ifdef _LP64
4015     Register dst = dest-&gt;as_register_lo();
4016     __ movptr(dst, lo);
4017     __ negptr(dst);
4018 #else
4019     Register hi = left-&gt;as_register_hi();
4020     __ lneg(hi, lo);
4021     if (dest-&gt;as_register_lo() == hi) {
4022       assert(dest-&gt;as_register_hi() != lo, &quot;destroying register&quot;);
4023       move_regs(hi, dest-&gt;as_register_hi());
4024       move_regs(lo, dest-&gt;as_register_lo());
4025     } else {
4026       move_regs(lo, dest-&gt;as_register_lo());
4027       move_regs(hi, dest-&gt;as_register_hi());
4028     }
4029 #endif // _LP64
4030 
4031   } else if (dest-&gt;is_single_xmm()) {
4032 #ifdef _LP64
4033     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
4034       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
4035       assert_different_registers(left-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg());
4036       __ vpxor(dest-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg(), 2);
4037     }
4038     else
4039 #endif
4040     {
4041       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
4042       if (left-&gt;as_xmm_float_reg() != dest-&gt;as_xmm_float_reg()) {
4043         __ movflt(dest-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg());
4044       }
4045       __ xorps(dest-&gt;as_xmm_float_reg(),
4046                ExternalAddress((address)float_signflip_pool));
4047     }
4048   } else if (dest-&gt;is_double_xmm()) {
4049 #ifdef _LP64
4050     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
4051       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
4052       assert_different_registers(left-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg());
4053       __ vpxor(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg(), 2);
4054     }
4055     else
4056 #endif
4057     {
4058       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
4059       if (left-&gt;as_xmm_double_reg() != dest-&gt;as_xmm_double_reg()) {
4060         __ movdbl(dest-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg());
4061       }
4062       __ xorpd(dest-&gt;as_xmm_double_reg(),
4063                ExternalAddress((address)double_signflip_pool));
4064     }
4065 #ifndef _LP64
4066   } else if (left-&gt;is_single_fpu() || left-&gt;is_double_fpu()) {
4067     assert(left-&gt;fpu() == 0, &quot;arg must be on TOS&quot;);
4068     assert(dest-&gt;fpu() == 0, &quot;dest must be TOS&quot;);
4069     __ fchs();
4070 #endif // !_LP64
4071 
4072   } else {
4073     ShouldNotReachHere();
4074   }
4075 }
4076 
4077 
4078 void LIR_Assembler::leal(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
4079   assert(src-&gt;is_address(), &quot;must be an address&quot;);
4080   assert(dest-&gt;is_register(), &quot;must be a register&quot;);
4081 
4082   PatchingStub* patch = NULL;
4083   if (patch_code != lir_patch_none) {
4084     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
4085   }
4086 
4087   Register reg = dest-&gt;as_pointer_register();
4088   LIR_Address* addr = src-&gt;as_address_ptr();
4089   __ lea(reg, as_Address(addr));
4090 
4091   if (patch != NULL) {
4092     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
4093   }
4094 }
4095 
4096 
4097 
4098 void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
4099   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
4100   __ call(RuntimeAddress(dest));
4101   if (info != NULL) {
4102     add_call_info_here(info);
4103   }
4104 }
4105 
4106 
4107 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
4108   assert(type == T_LONG, &quot;only for volatile long fields&quot;);
4109 
4110   if (info != NULL) {
4111     add_debug_info_for_null_check_here(info);
4112   }
4113 
4114   if (src-&gt;is_double_xmm()) {
4115     if (dest-&gt;is_double_cpu()) {
4116 #ifdef _LP64
4117       __ movdq(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
4118 #else
4119       __ movdl(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
4120       __ psrlq(src-&gt;as_xmm_double_reg(), 32);
4121       __ movdl(dest-&gt;as_register_hi(), src-&gt;as_xmm_double_reg());
4122 #endif // _LP64
4123     } else if (dest-&gt;is_double_stack()) {
4124       __ movdbl(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()), src-&gt;as_xmm_double_reg());
4125     } else if (dest-&gt;is_address()) {
4126       __ movdbl(as_Address(dest-&gt;as_address_ptr()), src-&gt;as_xmm_double_reg());
4127     } else {
4128       ShouldNotReachHere();
4129     }
4130 
4131   } else if (dest-&gt;is_double_xmm()) {
4132     if (src-&gt;is_double_stack()) {
4133       __ movdbl(dest-&gt;as_xmm_double_reg(), frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
4134     } else if (src-&gt;is_address()) {
4135       __ movdbl(dest-&gt;as_xmm_double_reg(), as_Address(src-&gt;as_address_ptr()));
4136     } else {
4137       ShouldNotReachHere();
4138     }
4139 
4140 #ifndef _LP64
4141   } else if (src-&gt;is_double_fpu()) {
4142     assert(src-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
4143     if (dest-&gt;is_double_stack()) {
4144       __ fistp_d(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
4145     } else if (dest-&gt;is_address()) {
4146       __ fistp_d(as_Address(dest-&gt;as_address_ptr()));
4147     } else {
4148       ShouldNotReachHere();
4149     }
4150 
4151   } else if (dest-&gt;is_double_fpu()) {
4152     assert(dest-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
4153     if (src-&gt;is_double_stack()) {
4154       __ fild_d(frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
4155     } else if (src-&gt;is_address()) {
4156       __ fild_d(as_Address(src-&gt;as_address_ptr()));
4157     } else {
4158       ShouldNotReachHere();
4159     }
4160 #endif // !_LP64
4161 
4162   } else {
4163     ShouldNotReachHere();
4164   }
4165 }
4166 
4167 #ifdef ASSERT
4168 // emit run-time assertion
4169 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
4170   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
4171 
4172   if (op-&gt;in_opr1()-&gt;is_valid()) {
4173     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
4174     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
4175   } else {
4176     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
4177     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
4178   }
4179 
4180   Label ok;
4181   if (op-&gt;condition() != lir_cond_always) {
4182     Assembler::Condition acond = Assembler::zero;
4183     switch (op-&gt;condition()) {
4184       case lir_cond_equal:        acond = Assembler::equal;       break;
4185       case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
4186       case lir_cond_less:         acond = Assembler::less;        break;
4187       case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
4188       case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
4189       case lir_cond_greater:      acond = Assembler::greater;     break;
4190       case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
4191       case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
4192       default:                    ShouldNotReachHere();
4193     }
4194     __ jcc(acond, ok);
4195   }
4196   if (op-&gt;halt()) {
4197     const char* str = __ code_string(op-&gt;msg());
4198     __ stop(str);
4199   } else {
4200     breakpoint();
4201   }
4202   __ bind(ok);
4203 }
4204 #endif
4205 
4206 void LIR_Assembler::membar() {
4207   // QQQ sparc TSO uses this,
4208   __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad));
4209 }
4210 
4211 void LIR_Assembler::membar_acquire() {
4212   // No x86 machines currently require load fences
4213 }
4214 
4215 void LIR_Assembler::membar_release() {
4216   // No x86 machines currently require store fences
4217 }
4218 
4219 void LIR_Assembler::membar_loadload() {
4220   // no-op
4221   //__ membar(Assembler::Membar_mask_bits(Assembler::loadload));
4222 }
4223 
4224 void LIR_Assembler::membar_storestore() {
4225   // no-op
4226   //__ membar(Assembler::Membar_mask_bits(Assembler::storestore));
4227 }
4228 
4229 void LIR_Assembler::membar_loadstore() {
4230   // no-op
4231   //__ membar(Assembler::Membar_mask_bits(Assembler::loadstore));
4232 }
4233 
4234 void LIR_Assembler::membar_storeload() {
4235   __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
4236 }
4237 
4238 void LIR_Assembler::on_spin_wait() {
4239   __ pause ();
4240 }
4241 
4242 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
4243   assert(result_reg-&gt;is_register(), &quot;check&quot;);
4244 #ifdef _LP64
4245   // __ get_thread(result_reg-&gt;as_register_lo());
4246   __ mov(result_reg-&gt;as_register(), r15_thread);
4247 #else
4248   __ get_thread(result_reg-&gt;as_register());
4249 #endif // _LP64
4250 }
4251 
4252 void LIR_Assembler::check_orig_pc() {
4253   __ cmpptr(frame_map()-&gt;address_for_orig_pc_addr(), (int32_t)NULL_WORD);
4254 }
4255 
4256 void LIR_Assembler::peephole(LIR_List*) {
4257   // do nothing for now
4258 }
4259 
4260 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
4261   assert(data == dest, &quot;xchg/xadd uses only 2 operands&quot;);
4262 
4263   if (data-&gt;type() == T_INT) {
4264     if (code == lir_xadd) {
4265       __ lock();
4266       __ xaddl(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register());
4267     } else {
4268       __ xchgl(data-&gt;as_register(), as_Address(src-&gt;as_address_ptr()));
4269     }
4270   } else if (data-&gt;is_oop()) {
4271     assert (code == lir_xchg, &quot;xadd for oops&quot;);
4272     Register obj = data-&gt;as_register();
4273 #ifdef _LP64
4274     if (UseCompressedOops) {
4275       __ encode_heap_oop(obj);
4276       __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
4277       __ decode_heap_oop(obj);
4278     } else {
4279       __ xchgptr(obj, as_Address(src-&gt;as_address_ptr()));
4280     }
4281 #else
4282     __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
4283 #endif
4284   } else if (data-&gt;type() == T_LONG) {
4285 #ifdef _LP64
4286     assert(data-&gt;as_register_lo() == data-&gt;as_register_hi(), &quot;should be a single register&quot;);
4287     if (code == lir_xadd) {
4288       __ lock();
4289       __ xaddq(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register_lo());
4290     } else {
4291       __ xchgq(data-&gt;as_register_lo(), as_Address(src-&gt;as_address_ptr()));
4292     }
4293 #else
4294     ShouldNotReachHere();
4295 #endif
4296   } else {
4297     ShouldNotReachHere();
4298   }
4299 }
4300 
4301 #undef __
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
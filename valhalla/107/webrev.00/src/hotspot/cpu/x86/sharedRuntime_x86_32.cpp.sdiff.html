<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/sharedRuntime_x86_32.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/sharedRuntime_x86_32.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 449       else if( freg_arg1 == fltarg_flt_dbl ) freg_arg1 = i;
 450       else // Else double is passed low on the stack to be aligned.
 451         stack += 2;
 452     } else if( sig_bt[i] == T_LONG ) {
 453       stack += 2;
 454     }
 455   }
 456   int dstack = 0;             // Separate counter for placing doubles
 457 
 458   // Now pick where all else goes.
 459   for( i = 0; i &lt; total_args_passed; i++) {
 460     // From the type and the argument number (count) compute the location
 461     switch( sig_bt[i] ) {
 462     case T_SHORT:
 463     case T_CHAR:
 464     case T_BYTE:
 465     case T_BOOLEAN:
 466     case T_INT:
 467     case T_ARRAY:
 468     case T_OBJECT:
<span class="line-modified"> 469     case T_VALUETYPE:</span>
 470     case T_ADDRESS:
 471       if( reg_arg0 == 9999 )  {
 472         reg_arg0 = i;
 473         regs[i].set1(rcx-&gt;as_VMReg());
 474       } else if( reg_arg1 == 9999 )  {
 475         reg_arg1 = i;
 476         regs[i].set1(rdx-&gt;as_VMReg());
 477       } else {
 478         regs[i].set1(VMRegImpl::stack2reg(stack++));
 479       }
 480       break;
 481     case T_FLOAT:
 482       if( freg_arg0 == fltarg_flt_dbl || freg_arg0 == fltarg_float_only ) {
 483         freg_arg0 = i;
 484         regs[i].set1(xmm0-&gt;as_VMReg());
 485       } else if( freg_arg1 == fltarg_flt_dbl || freg_arg1 == fltarg_float_only ) {
 486         freg_arg1 = i;
 487         regs[i].set1(xmm1-&gt;as_VMReg());
 488       } else {
 489         regs[i].set1(VMRegImpl::stack2reg(stack++));
</pre>
<hr />
<pre>
1005 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
1006                                          VMRegPair *regs,
1007                                          VMRegPair *regs2,
1008                                          int total_args_passed) {
1009   assert(regs2 == NULL, &quot;not needed on x86&quot;);
1010 // We return the amount of VMRegImpl stack slots we need to reserve for all
1011 // the arguments NOT counting out_preserve_stack_slots.
1012 
1013   uint    stack = 0;        // All arguments on stack
1014 
1015   for( int i = 0; i &lt; total_args_passed; i++) {
1016     // From the type and the argument number (count) compute the location
1017     switch( sig_bt[i] ) {
1018     case T_BOOLEAN:
1019     case T_CHAR:
1020     case T_FLOAT:
1021     case T_BYTE:
1022     case T_SHORT:
1023     case T_INT:
1024     case T_OBJECT:
<span class="line-modified">1025     case T_VALUETYPE:</span>
1026     case T_ARRAY:
1027     case T_ADDRESS:
1028     case T_METADATA:
1029       regs[i].set1(VMRegImpl::stack2reg(stack++));
1030       break;
1031     case T_LONG:
1032     case T_DOUBLE: // The stack numbering is reversed from Java
1033       // Since C arguments do not get reversed, the ordering for
1034       // doubles on the stack must be opposite the Java convention
1035       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i+1] == T_VOID, &quot;missing Half&quot; );
1036       regs[i].set2(VMRegImpl::stack2reg(stack));
1037       stack += 2;
1038       break;
1039     case T_VOID: regs[i].set_bad(); break;
1040     default:
1041       ShouldNotReachHere();
1042       break;
1043     }
1044   }
1045   return stack;
</pre>
<hr />
<pre>
1287       switch (in_sig_bt[i]) {
1288         case T_ARRAY:
1289           if (map != NULL) {
1290             __ movptr(Address(rsp, offset), reg);
1291           } else {
1292             __ movptr(reg, Address(rsp, offset));
1293           }
1294           break;
1295         case T_BOOLEAN:
1296         case T_CHAR:
1297         case T_BYTE:
1298         case T_SHORT:
1299         case T_INT:
1300           if (map != NULL) {
1301             __ movl(Address(rsp, offset), reg);
1302           } else {
1303             __ movl(reg, Address(rsp, offset));
1304           }
1305           break;
1306         case T_OBJECT:
<span class="line-modified">1307         case T_VALUETYPE:</span>
1308         default: ShouldNotReachHere();
1309       }
1310     } else if (in_regs[i].first()-&gt;is_XMMRegister()) {
1311       if (in_sig_bt[i] == T_FLOAT) {
1312         int slot = handle_index++ * VMRegImpl::slots_per_word + arg_save_area;
1313         int offset = slot * VMRegImpl::stack_slot_size;
1314         assert(handle_index &lt;= stack_slots, &quot;overflow&quot;);
1315         if (map != NULL) {
1316           __ movflt(Address(rsp, offset), in_regs[i].first()-&gt;as_XMMRegister());
1317         } else {
1318           __ movflt(in_regs[i].first()-&gt;as_XMMRegister(), Address(rsp, offset));
1319         }
1320       }
1321     } else if (in_regs[i].first()-&gt;is_stack()) {
1322       if (in_sig_bt[i] == T_ARRAY &amp;&amp; map != NULL) {
1323         int offset_in_older_frame = in_regs[i].first()-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
1324         map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + stack_slots));
1325       }
1326     }
1327   }
</pre>
<hr />
<pre>
2005             pinned_args.append(i);
2006 
2007             // rax has pinned array
2008             VMRegPair result_reg(rax-&gt;as_VMReg());
2009             if (!in_arg.first()-&gt;is_stack()) {
2010               assert(pinned_slot &lt;= stack_slots, &quot;overflow&quot;);
2011               simple_move32(masm, result_reg, VMRegImpl::stack2reg(pinned_slot));
2012               pinned_slot += VMRegImpl::slots_per_word;
2013             } else {
2014               // Write back pinned value, it will be used to unpin this argument
2015               __ movptr(Address(rbp, reg2offset_in(in_arg.first())), result_reg.first()-&gt;as_Register());
2016             }
2017             // We have the array in register, use it
2018             in_arg = result_reg;
2019           }
2020 
2021           unpack_array_argument(masm, in_arg, in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
2022           c_arg++;
2023           break;
2024         }
<span class="line-modified">2025       case T_VALUETYPE:</span>
2026       case T_OBJECT:
2027         assert(!is_critical_native, &quot;no oop arguments&quot;);
2028         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
2029                     ((i == 0) &amp;&amp; (!is_static)),
2030                     &amp;receiver_offset);
2031         break;
2032       case T_VOID:
2033         break;
2034 
2035       case T_FLOAT:
2036         float_move(masm, in_regs[i], out_regs[c_arg]);
2037           break;
2038 
2039       case T_DOUBLE:
2040         assert( i + 1 &lt; total_in_args &amp;&amp;
2041                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
2042                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
2043         double_move(masm, in_regs[i], out_regs[c_arg]);
2044         break;
2045 
</pre>
<hr />
<pre>
2188   // Verify or restore cpu control state after JNI call
2189   __ restore_cpu_control_state_after_jni();
2190 
2191   // WARNING - on Windows Java Natives use pascal calling convention and pop the
2192   // arguments off of the stack. We could just re-adjust the stack pointer here
2193   // and continue to do SP relative addressing but we instead switch to FP
2194   // relative addressing.
2195 
2196   // Unpack native results.
2197   switch (ret_type) {
2198   case T_BOOLEAN: __ c2bool(rax);            break;
2199   case T_CHAR   : __ andptr(rax, 0xFFFF);    break;
2200   case T_BYTE   : __ sign_extend_byte (rax); break;
2201   case T_SHORT  : __ sign_extend_short(rax); break;
2202   case T_INT    : /* nothing to do */        break;
2203   case T_DOUBLE :
2204   case T_FLOAT  :
2205     // Result is in st0 we&#39;ll save as needed
2206     break;
2207   case T_ARRAY:                 // Really a handle
<span class="line-modified">2208   case T_VALUETYPE:             // Really a handle</span>
2209   case T_OBJECT:                // Really a handle
2210       break; // can&#39;t de-handlize until after safepoint check
2211   case T_VOID: break;
2212   case T_LONG: break;
2213   default       : ShouldNotReachHere();
2214   }
2215 
2216   // unpin pinned arguments
2217   pinned_slot = oop_handle_offset;
2218   if (pinned_args.length() &gt; 0) {
2219     // save return value that may be overwritten otherwise.
2220     save_native_result(masm, ret_type, stack_slots);
2221     for (int index = 0; index &lt; pinned_args.length(); index ++) {
2222       int i = pinned_args.at(index);
2223       assert(pinned_slot &lt;= stack_slots, &quot;overflow&quot;);
2224       if (!in_regs[i].first()-&gt;is_stack()) {
2225         int offset = pinned_slot * VMRegImpl::stack_slot_size;
2226         __ movl(in_regs[i].first()-&gt;as_Register(), Address(rsp, offset));
2227         pinned_slot += VMRegImpl::slots_per_word;
2228       }
</pre>
</td>
<td>
<hr />
<pre>
 449       else if( freg_arg1 == fltarg_flt_dbl ) freg_arg1 = i;
 450       else // Else double is passed low on the stack to be aligned.
 451         stack += 2;
 452     } else if( sig_bt[i] == T_LONG ) {
 453       stack += 2;
 454     }
 455   }
 456   int dstack = 0;             // Separate counter for placing doubles
 457 
 458   // Now pick where all else goes.
 459   for( i = 0; i &lt; total_args_passed; i++) {
 460     // From the type and the argument number (count) compute the location
 461     switch( sig_bt[i] ) {
 462     case T_SHORT:
 463     case T_CHAR:
 464     case T_BYTE:
 465     case T_BOOLEAN:
 466     case T_INT:
 467     case T_ARRAY:
 468     case T_OBJECT:
<span class="line-modified"> 469     case T_INLINE_TYPE:</span>
 470     case T_ADDRESS:
 471       if( reg_arg0 == 9999 )  {
 472         reg_arg0 = i;
 473         regs[i].set1(rcx-&gt;as_VMReg());
 474       } else if( reg_arg1 == 9999 )  {
 475         reg_arg1 = i;
 476         regs[i].set1(rdx-&gt;as_VMReg());
 477       } else {
 478         regs[i].set1(VMRegImpl::stack2reg(stack++));
 479       }
 480       break;
 481     case T_FLOAT:
 482       if( freg_arg0 == fltarg_flt_dbl || freg_arg0 == fltarg_float_only ) {
 483         freg_arg0 = i;
 484         regs[i].set1(xmm0-&gt;as_VMReg());
 485       } else if( freg_arg1 == fltarg_flt_dbl || freg_arg1 == fltarg_float_only ) {
 486         freg_arg1 = i;
 487         regs[i].set1(xmm1-&gt;as_VMReg());
 488       } else {
 489         regs[i].set1(VMRegImpl::stack2reg(stack++));
</pre>
<hr />
<pre>
1005 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
1006                                          VMRegPair *regs,
1007                                          VMRegPair *regs2,
1008                                          int total_args_passed) {
1009   assert(regs2 == NULL, &quot;not needed on x86&quot;);
1010 // We return the amount of VMRegImpl stack slots we need to reserve for all
1011 // the arguments NOT counting out_preserve_stack_slots.
1012 
1013   uint    stack = 0;        // All arguments on stack
1014 
1015   for( int i = 0; i &lt; total_args_passed; i++) {
1016     // From the type and the argument number (count) compute the location
1017     switch( sig_bt[i] ) {
1018     case T_BOOLEAN:
1019     case T_CHAR:
1020     case T_FLOAT:
1021     case T_BYTE:
1022     case T_SHORT:
1023     case T_INT:
1024     case T_OBJECT:
<span class="line-modified">1025     case T_INLINE_TYPE:</span>
1026     case T_ARRAY:
1027     case T_ADDRESS:
1028     case T_METADATA:
1029       regs[i].set1(VMRegImpl::stack2reg(stack++));
1030       break;
1031     case T_LONG:
1032     case T_DOUBLE: // The stack numbering is reversed from Java
1033       // Since C arguments do not get reversed, the ordering for
1034       // doubles on the stack must be opposite the Java convention
1035       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i+1] == T_VOID, &quot;missing Half&quot; );
1036       regs[i].set2(VMRegImpl::stack2reg(stack));
1037       stack += 2;
1038       break;
1039     case T_VOID: regs[i].set_bad(); break;
1040     default:
1041       ShouldNotReachHere();
1042       break;
1043     }
1044   }
1045   return stack;
</pre>
<hr />
<pre>
1287       switch (in_sig_bt[i]) {
1288         case T_ARRAY:
1289           if (map != NULL) {
1290             __ movptr(Address(rsp, offset), reg);
1291           } else {
1292             __ movptr(reg, Address(rsp, offset));
1293           }
1294           break;
1295         case T_BOOLEAN:
1296         case T_CHAR:
1297         case T_BYTE:
1298         case T_SHORT:
1299         case T_INT:
1300           if (map != NULL) {
1301             __ movl(Address(rsp, offset), reg);
1302           } else {
1303             __ movl(reg, Address(rsp, offset));
1304           }
1305           break;
1306         case T_OBJECT:
<span class="line-modified">1307         case T_INLINE_TYPE:</span>
1308         default: ShouldNotReachHere();
1309       }
1310     } else if (in_regs[i].first()-&gt;is_XMMRegister()) {
1311       if (in_sig_bt[i] == T_FLOAT) {
1312         int slot = handle_index++ * VMRegImpl::slots_per_word + arg_save_area;
1313         int offset = slot * VMRegImpl::stack_slot_size;
1314         assert(handle_index &lt;= stack_slots, &quot;overflow&quot;);
1315         if (map != NULL) {
1316           __ movflt(Address(rsp, offset), in_regs[i].first()-&gt;as_XMMRegister());
1317         } else {
1318           __ movflt(in_regs[i].first()-&gt;as_XMMRegister(), Address(rsp, offset));
1319         }
1320       }
1321     } else if (in_regs[i].first()-&gt;is_stack()) {
1322       if (in_sig_bt[i] == T_ARRAY &amp;&amp; map != NULL) {
1323         int offset_in_older_frame = in_regs[i].first()-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
1324         map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + stack_slots));
1325       }
1326     }
1327   }
</pre>
<hr />
<pre>
2005             pinned_args.append(i);
2006 
2007             // rax has pinned array
2008             VMRegPair result_reg(rax-&gt;as_VMReg());
2009             if (!in_arg.first()-&gt;is_stack()) {
2010               assert(pinned_slot &lt;= stack_slots, &quot;overflow&quot;);
2011               simple_move32(masm, result_reg, VMRegImpl::stack2reg(pinned_slot));
2012               pinned_slot += VMRegImpl::slots_per_word;
2013             } else {
2014               // Write back pinned value, it will be used to unpin this argument
2015               __ movptr(Address(rbp, reg2offset_in(in_arg.first())), result_reg.first()-&gt;as_Register());
2016             }
2017             // We have the array in register, use it
2018             in_arg = result_reg;
2019           }
2020 
2021           unpack_array_argument(masm, in_arg, in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
2022           c_arg++;
2023           break;
2024         }
<span class="line-modified">2025       case T_INLINE_TYPE:</span>
2026       case T_OBJECT:
2027         assert(!is_critical_native, &quot;no oop arguments&quot;);
2028         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
2029                     ((i == 0) &amp;&amp; (!is_static)),
2030                     &amp;receiver_offset);
2031         break;
2032       case T_VOID:
2033         break;
2034 
2035       case T_FLOAT:
2036         float_move(masm, in_regs[i], out_regs[c_arg]);
2037           break;
2038 
2039       case T_DOUBLE:
2040         assert( i + 1 &lt; total_in_args &amp;&amp;
2041                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
2042                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
2043         double_move(masm, in_regs[i], out_regs[c_arg]);
2044         break;
2045 
</pre>
<hr />
<pre>
2188   // Verify or restore cpu control state after JNI call
2189   __ restore_cpu_control_state_after_jni();
2190 
2191   // WARNING - on Windows Java Natives use pascal calling convention and pop the
2192   // arguments off of the stack. We could just re-adjust the stack pointer here
2193   // and continue to do SP relative addressing but we instead switch to FP
2194   // relative addressing.
2195 
2196   // Unpack native results.
2197   switch (ret_type) {
2198   case T_BOOLEAN: __ c2bool(rax);            break;
2199   case T_CHAR   : __ andptr(rax, 0xFFFF);    break;
2200   case T_BYTE   : __ sign_extend_byte (rax); break;
2201   case T_SHORT  : __ sign_extend_short(rax); break;
2202   case T_INT    : /* nothing to do */        break;
2203   case T_DOUBLE :
2204   case T_FLOAT  :
2205     // Result is in st0 we&#39;ll save as needed
2206     break;
2207   case T_ARRAY:                 // Really a handle
<span class="line-modified">2208   case T_INLINE_TYPE:           // Really a handle</span>
2209   case T_OBJECT:                // Really a handle
2210       break; // can&#39;t de-handlize until after safepoint check
2211   case T_VOID: break;
2212   case T_LONG: break;
2213   default       : ShouldNotReachHere();
2214   }
2215 
2216   // unpin pinned arguments
2217   pinned_slot = oop_handle_offset;
2218   if (pinned_args.length() &gt; 0) {
2219     // save return value that may be overwritten otherwise.
2220     save_native_result(masm, ret_type, stack_slots);
2221     for (int index = 0; index &lt; pinned_args.length(); index ++) {
2222       int i = pinned_args.at(index);
2223       assert(pinned_slot &lt;= stack_slots, &quot;overflow&quot;);
2224       if (!in_regs[i].first()-&gt;is_stack()) {
2225         int offset = pinned_slot * VMRegImpl::stack_slot_size;
2226         __ movl(in_regs[i].first()-&gt;as_Register(), Address(rsp, offset));
2227         pinned_slot += VMRegImpl::slots_per_word;
2228       }
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
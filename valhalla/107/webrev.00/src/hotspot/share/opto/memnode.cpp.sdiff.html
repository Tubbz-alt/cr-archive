<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/memnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroArrayCopy.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse1.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/memnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 816          &quot;use LoadKlassNode instead&quot;);
 817   assert(!(adr_type-&gt;isa_aryptr() &amp;&amp;
 818            adr_type-&gt;offset() == arrayOopDesc::length_offset_in_bytes()),
 819          &quot;use LoadRangeNode instead&quot;);
 820   // Check control edge of raw loads
 821   assert( ctl != NULL || C-&gt;get_alias_index(adr_type) != Compile::AliasIdxRaw ||
 822           // oop will be recorded in oop map if load crosses safepoint
 823           rt-&gt;isa_oopptr() || is_immutable_value(adr),
 824           &quot;raw memory operations should have control edge&quot;);
 825   LoadNode* load = NULL;
 826   switch (bt) {
 827   case T_BOOLEAN: load = new LoadUBNode(ctl, mem, adr, adr_type, rt-&gt;is_int(),  mo, control_dependency); break;
 828   case T_BYTE:    load = new LoadBNode (ctl, mem, adr, adr_type, rt-&gt;is_int(),  mo, control_dependency); break;
 829   case T_INT:     load = new LoadINode (ctl, mem, adr, adr_type, rt-&gt;is_int(),  mo, control_dependency); break;
 830   case T_CHAR:    load = new LoadUSNode(ctl, mem, adr, adr_type, rt-&gt;is_int(),  mo, control_dependency); break;
 831   case T_SHORT:   load = new LoadSNode (ctl, mem, adr, adr_type, rt-&gt;is_int(),  mo, control_dependency); break;
 832   case T_LONG:    load = new LoadLNode (ctl, mem, adr, adr_type, rt-&gt;is_long(), mo, control_dependency); break;
 833   case T_FLOAT:   load = new LoadFNode (ctl, mem, adr, adr_type, rt,            mo, control_dependency); break;
 834   case T_DOUBLE:  load = new LoadDNode (ctl, mem, adr, adr_type, rt,            mo, control_dependency); break;
 835   case T_ADDRESS: load = new LoadPNode (ctl, mem, adr, adr_type, rt-&gt;is_ptr(),  mo, control_dependency); break;
<span class="line-modified"> 836   case T_VALUETYPE:</span>
 837   case T_OBJECT:
 838 #ifdef _LP64
 839     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
 840       load = new LoadNNode(ctl, mem, adr, adr_type, rt-&gt;make_narrowoop(), mo, control_dependency);
 841     } else
 842 #endif
 843     {
 844       assert(!adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() &amp;&amp; !adr-&gt;bottom_type()-&gt;is_ptr_to_narrowklass(), &quot;should have got back a narrow oop&quot;);
 845       load = new LoadPNode(ctl, mem, adr, adr_type, rt-&gt;is_ptr(), mo, control_dependency);
 846     }
 847     break;
 848   default:
 849     ShouldNotReachHere();
 850     break;
 851   }
 852   assert(load != NULL, &quot;LoadNode should have been created&quot;);
 853   if (unaligned) {
 854     load-&gt;set_unaligned_access();
 855   }
 856   if (mismatched) {
</pre>
<hr />
<pre>
1078         // the same pointer-and-offset that we stored to.
1079         // Casted version may carry a dependency and it is respected.
1080         // Thus, we are able to replace L by V.
1081       }
1082       // Now prove that we have a LoadQ matched to a StoreQ, for some Q.
1083       if (store_Opcode() != st-&gt;Opcode())
1084         return NULL;
1085       return st-&gt;in(MemNode::ValueIn);
1086     }
1087 
1088     // A load from a freshly-created object always returns zero.
1089     // (This can happen after LoadNode::Ideal resets the load&#39;s memory input
1090     // to find_captured_store, which returned InitializeNode::zero_memory.)
1091     if (st-&gt;is_Proj() &amp;&amp; st-&gt;in(0)-&gt;is_Allocate() &amp;&amp;
1092         (st-&gt;in(0) == ld_alloc) &amp;&amp;
1093         (ld_off &gt;= st-&gt;in(0)-&gt;as_Allocate()-&gt;minimum_header_size())) {
1094       // return a zero value for the load&#39;s basic type
1095       // (This is one of the few places where a generic PhaseTransform
1096       // can create new nodes.  Think of it as lazily manifesting
1097       // virtually pre-existing constants.)
<span class="line-modified">1098       assert(memory_type() != T_VALUETYPE, &quot;should not be used for value types&quot;);</span>
1099       Node* default_value = ld_alloc-&gt;in(AllocateNode::DefaultValue);
1100       if (default_value != NULL) {
1101         return default_value;
1102       }
1103       assert(ld_alloc-&gt;in(AllocateNode::RawDefaultValue) == NULL, &quot;default value may not be null&quot;);
1104       return phase-&gt;zerocon(memory_type());
1105     }
1106 
1107     // A load from an initialization barrier can match a captured store.
1108     if (st-&gt;is_Proj() &amp;&amp; st-&gt;in(0)-&gt;is_Initialize()) {
1109       InitializeNode* init = st-&gt;in(0)-&gt;as_Initialize();
1110       AllocateNode* alloc = init-&gt;allocation();
1111       if ((alloc != NULL) &amp;&amp; (alloc == ld_alloc)) {
1112         // examine a captured store value
1113         st = init-&gt;find_captured_store(ld_off, memory_size(), phase);
1114         if (st != NULL) {
1115           continue;             // take one more trip around
1116         }
1117       }
1118     }
</pre>
<hr />
<pre>
2523 //=============================================================================
2524 //---------------------------StoreNode::make-----------------------------------
2525 // Polymorphic factory method:
2526 StoreNode* StoreNode::make(PhaseGVN&amp; gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, BasicType bt, MemOrd mo) {
2527   assert((mo == unordered || mo == release), &quot;unexpected&quot;);
2528   Compile* C = gvn.C;
2529   assert(C-&gt;get_alias_index(adr_type) != Compile::AliasIdxRaw ||
2530          ctl != NULL, &quot;raw memory operations should have control edge&quot;);
2531 
2532   switch (bt) {
2533   case T_BOOLEAN: val = gvn.transform(new AndINode(val, gvn.intcon(0x1))); // Fall through to T_BYTE case
2534   case T_BYTE:    return new StoreBNode(ctl, mem, adr, adr_type, val, mo);
2535   case T_INT:     return new StoreINode(ctl, mem, adr, adr_type, val, mo);
2536   case T_CHAR:
2537   case T_SHORT:   return new StoreCNode(ctl, mem, adr, adr_type, val, mo);
2538   case T_LONG:    return new StoreLNode(ctl, mem, adr, adr_type, val, mo);
2539   case T_FLOAT:   return new StoreFNode(ctl, mem, adr, adr_type, val, mo);
2540   case T_DOUBLE:  return new StoreDNode(ctl, mem, adr, adr_type, val, mo);
2541   case T_METADATA:
2542   case T_ADDRESS:
<span class="line-modified">2543   case T_VALUETYPE:</span>
2544   case T_OBJECT:
2545 #ifdef _LP64
2546     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
2547       val = gvn.transform(new EncodePNode(val, val-&gt;bottom_type()-&gt;make_narrowoop()));
2548       return new StoreNNode(ctl, mem, adr, adr_type, val, mo);
2549     } else if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowklass() ||
2550                (UseCompressedClassPointers &amp;&amp; val-&gt;bottom_type()-&gt;isa_klassptr() &amp;&amp;
2551                 adr-&gt;bottom_type()-&gt;isa_rawptr())) {
2552       val = gvn.transform(new EncodePKlassNode(val, val-&gt;bottom_type()-&gt;make_narrowklass()));
2553       return new StoreNKlassNode(ctl, mem, adr, adr_type, val, mo);
2554     }
2555 #endif
2556     {
2557       return new StorePNode(ctl, mem, adr, adr_type, val, mo);
2558     }
2559   default:
2560     ShouldNotReachHere();
2561     return (StoreNode*)NULL;
2562   }
2563 }
</pre>
</td>
<td>
<hr />
<pre>
 816          &quot;use LoadKlassNode instead&quot;);
 817   assert(!(adr_type-&gt;isa_aryptr() &amp;&amp;
 818            adr_type-&gt;offset() == arrayOopDesc::length_offset_in_bytes()),
 819          &quot;use LoadRangeNode instead&quot;);
 820   // Check control edge of raw loads
 821   assert( ctl != NULL || C-&gt;get_alias_index(adr_type) != Compile::AliasIdxRaw ||
 822           // oop will be recorded in oop map if load crosses safepoint
 823           rt-&gt;isa_oopptr() || is_immutable_value(adr),
 824           &quot;raw memory operations should have control edge&quot;);
 825   LoadNode* load = NULL;
 826   switch (bt) {
 827   case T_BOOLEAN: load = new LoadUBNode(ctl, mem, adr, adr_type, rt-&gt;is_int(),  mo, control_dependency); break;
 828   case T_BYTE:    load = new LoadBNode (ctl, mem, adr, adr_type, rt-&gt;is_int(),  mo, control_dependency); break;
 829   case T_INT:     load = new LoadINode (ctl, mem, adr, adr_type, rt-&gt;is_int(),  mo, control_dependency); break;
 830   case T_CHAR:    load = new LoadUSNode(ctl, mem, adr, adr_type, rt-&gt;is_int(),  mo, control_dependency); break;
 831   case T_SHORT:   load = new LoadSNode (ctl, mem, adr, adr_type, rt-&gt;is_int(),  mo, control_dependency); break;
 832   case T_LONG:    load = new LoadLNode (ctl, mem, adr, adr_type, rt-&gt;is_long(), mo, control_dependency); break;
 833   case T_FLOAT:   load = new LoadFNode (ctl, mem, adr, adr_type, rt,            mo, control_dependency); break;
 834   case T_DOUBLE:  load = new LoadDNode (ctl, mem, adr, adr_type, rt,            mo, control_dependency); break;
 835   case T_ADDRESS: load = new LoadPNode (ctl, mem, adr, adr_type, rt-&gt;is_ptr(),  mo, control_dependency); break;
<span class="line-modified"> 836   case T_INLINE_TYPE:</span>
 837   case T_OBJECT:
 838 #ifdef _LP64
 839     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
 840       load = new LoadNNode(ctl, mem, adr, adr_type, rt-&gt;make_narrowoop(), mo, control_dependency);
 841     } else
 842 #endif
 843     {
 844       assert(!adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() &amp;&amp; !adr-&gt;bottom_type()-&gt;is_ptr_to_narrowklass(), &quot;should have got back a narrow oop&quot;);
 845       load = new LoadPNode(ctl, mem, adr, adr_type, rt-&gt;is_ptr(), mo, control_dependency);
 846     }
 847     break;
 848   default:
 849     ShouldNotReachHere();
 850     break;
 851   }
 852   assert(load != NULL, &quot;LoadNode should have been created&quot;);
 853   if (unaligned) {
 854     load-&gt;set_unaligned_access();
 855   }
 856   if (mismatched) {
</pre>
<hr />
<pre>
1078         // the same pointer-and-offset that we stored to.
1079         // Casted version may carry a dependency and it is respected.
1080         // Thus, we are able to replace L by V.
1081       }
1082       // Now prove that we have a LoadQ matched to a StoreQ, for some Q.
1083       if (store_Opcode() != st-&gt;Opcode())
1084         return NULL;
1085       return st-&gt;in(MemNode::ValueIn);
1086     }
1087 
1088     // A load from a freshly-created object always returns zero.
1089     // (This can happen after LoadNode::Ideal resets the load&#39;s memory input
1090     // to find_captured_store, which returned InitializeNode::zero_memory.)
1091     if (st-&gt;is_Proj() &amp;&amp; st-&gt;in(0)-&gt;is_Allocate() &amp;&amp;
1092         (st-&gt;in(0) == ld_alloc) &amp;&amp;
1093         (ld_off &gt;= st-&gt;in(0)-&gt;as_Allocate()-&gt;minimum_header_size())) {
1094       // return a zero value for the load&#39;s basic type
1095       // (This is one of the few places where a generic PhaseTransform
1096       // can create new nodes.  Think of it as lazily manifesting
1097       // virtually pre-existing constants.)
<span class="line-modified">1098       assert(memory_type() != T_INLINE_TYPE, &quot;should not be used for value types&quot;);</span>
1099       Node* default_value = ld_alloc-&gt;in(AllocateNode::DefaultValue);
1100       if (default_value != NULL) {
1101         return default_value;
1102       }
1103       assert(ld_alloc-&gt;in(AllocateNode::RawDefaultValue) == NULL, &quot;default value may not be null&quot;);
1104       return phase-&gt;zerocon(memory_type());
1105     }
1106 
1107     // A load from an initialization barrier can match a captured store.
1108     if (st-&gt;is_Proj() &amp;&amp; st-&gt;in(0)-&gt;is_Initialize()) {
1109       InitializeNode* init = st-&gt;in(0)-&gt;as_Initialize();
1110       AllocateNode* alloc = init-&gt;allocation();
1111       if ((alloc != NULL) &amp;&amp; (alloc == ld_alloc)) {
1112         // examine a captured store value
1113         st = init-&gt;find_captured_store(ld_off, memory_size(), phase);
1114         if (st != NULL) {
1115           continue;             // take one more trip around
1116         }
1117       }
1118     }
</pre>
<hr />
<pre>
2523 //=============================================================================
2524 //---------------------------StoreNode::make-----------------------------------
2525 // Polymorphic factory method:
2526 StoreNode* StoreNode::make(PhaseGVN&amp; gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, BasicType bt, MemOrd mo) {
2527   assert((mo == unordered || mo == release), &quot;unexpected&quot;);
2528   Compile* C = gvn.C;
2529   assert(C-&gt;get_alias_index(adr_type) != Compile::AliasIdxRaw ||
2530          ctl != NULL, &quot;raw memory operations should have control edge&quot;);
2531 
2532   switch (bt) {
2533   case T_BOOLEAN: val = gvn.transform(new AndINode(val, gvn.intcon(0x1))); // Fall through to T_BYTE case
2534   case T_BYTE:    return new StoreBNode(ctl, mem, adr, adr_type, val, mo);
2535   case T_INT:     return new StoreINode(ctl, mem, adr, adr_type, val, mo);
2536   case T_CHAR:
2537   case T_SHORT:   return new StoreCNode(ctl, mem, adr, adr_type, val, mo);
2538   case T_LONG:    return new StoreLNode(ctl, mem, adr, adr_type, val, mo);
2539   case T_FLOAT:   return new StoreFNode(ctl, mem, adr, adr_type, val, mo);
2540   case T_DOUBLE:  return new StoreDNode(ctl, mem, adr, adr_type, val, mo);
2541   case T_METADATA:
2542   case T_ADDRESS:
<span class="line-modified">2543   case T_INLINE_TYPE:</span>
2544   case T_OBJECT:
2545 #ifdef _LP64
2546     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
2547       val = gvn.transform(new EncodePNode(val, val-&gt;bottom_type()-&gt;make_narrowoop()));
2548       return new StoreNNode(ctl, mem, adr, adr_type, val, mo);
2549     } else if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowklass() ||
2550                (UseCompressedClassPointers &amp;&amp; val-&gt;bottom_type()-&gt;isa_klassptr() &amp;&amp;
2551                 adr-&gt;bottom_type()-&gt;isa_rawptr())) {
2552       val = gvn.transform(new EncodePKlassNode(val, val-&gt;bottom_type()-&gt;make_narrowklass()));
2553       return new StoreNKlassNode(ctl, mem, adr, adr_type, val, mo);
2554     }
2555 #endif
2556     {
2557       return new StorePNode(ctl, mem, adr, adr_type, val, mo);
2558     }
2559   default:
2560     ShouldNotReachHere();
2561     return (StoreNode*)NULL;
2562   }
2563 }
</pre>
</td>
</tr>
</table>
<center><a href="macroArrayCopy.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse1.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="parseHelper.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valuetypenode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/type.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 111 
 112 #if defined(PPC64)
 113   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 114   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 115   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 116   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 117   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 118 #elif defined(S390)
 119   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 120   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 121   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
 122   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 123   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 124 #else // all other
 125   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, Op_VecS,              relocInfo::none          },  // VectorS
 126   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
 127   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 128   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
 129   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
 130 #endif
<span class="line-modified"> 131   { Bad,             T_VALUETYPE,  &quot;value:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // ValueType</span>
 132   { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
 133   { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
 134   { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
 135   { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
 136   { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
 137   { Bad,             T_METADATA,   &quot;metadata:&quot;,     false, Op_RegP,              relocInfo::metadata_type },  // MetadataPtr
 138   { Bad,             T_METADATA,   &quot;klass:&quot;,        false, Op_RegP,              relocInfo::metadata_type },  // KlassPtr
 139   { Bad,             T_OBJECT,     &quot;func&quot;,          false, 0,                    relocInfo::none          },  // Function
 140   { Abio,            T_ILLEGAL,    &quot;abIO&quot;,          false, 0,                    relocInfo::none          },  // Abio
 141   { Return_Address,  T_ADDRESS,    &quot;return_address&quot;,false, Op_RegP,              relocInfo::none          },  // Return_Address
 142   { Memory,          T_ILLEGAL,    &quot;memory&quot;,        false, 0,                    relocInfo::none          },  // Memory
 143   { FloatBot,        T_FLOAT,      &quot;float_top&quot;,     false, Op_RegF,              relocInfo::none          },  // FloatTop
 144   { FloatCon,        T_FLOAT,      &quot;ftcon:&quot;,        false, Op_RegF,              relocInfo::none          },  // FloatCon
 145   { FloatTop,        T_FLOAT,      &quot;float&quot;,         false, Op_RegF,              relocInfo::none          },  // FloatBot
 146   { DoubleBot,       T_DOUBLE,     &quot;double_top&quot;,    false, Op_RegD,              relocInfo::none          },  // DoubleTop
 147   { DoubleCon,       T_DOUBLE,     &quot;dblcon:&quot;,       false, Op_RegD,              relocInfo::none          },  // DoubleCon
 148   { DoubleTop,       T_DOUBLE,     &quot;double&quot;,        false, Op_RegD,              relocInfo::none          },  // DoubleBot
 149   { Top,             T_ILLEGAL,    &quot;bottom&quot;,        false, 0,                    relocInfo::none          }   // Bottom
 150 };
 151 
</pre>
<hr />
<pre>
 242   case ciTypeFlow::StateVector::T_NULL:
 243     assert(type == ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 244     return TypePtr::NULL_PTR;
 245 
 246   case ciTypeFlow::StateVector::T_LONG2:
 247     // The ciTypeFlow pass pushes a long, then the half.
 248     // We do the same.
 249     assert(type == ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 250     return TypeInt::TOP;
 251 
 252   case ciTypeFlow::StateVector::T_DOUBLE2:
 253     // The ciTypeFlow pass pushes double, then the half.
 254     // Our convention is the same.
 255     assert(type == ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 256     return Type::TOP;
 257 
 258   case T_ADDRESS:
 259     assert(type-&gt;is_return_address(), &quot;&quot;);
 260     return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
 261 
<span class="line-modified"> 262   case T_VALUETYPE: {</span>
 263     bool is_never_null = type-&gt;is_never_null();
 264     ciValueKlass* vk = type-&gt;unwrap()-&gt;as_value_klass();
 265     if (vk-&gt;is_scalarizable() &amp;&amp; is_never_null) {
 266       return TypeValueType::make(vk);
 267     } else {
 268       return TypeOopPtr::make_from_klass(vk)-&gt;join_speculative(is_never_null ? TypePtr::NOTNULL : TypePtr::BOTTOM);
 269     }
 270   }
 271 
 272   default:
 273     // make sure we did not mix up the cases:
 274     assert(type != ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 275     assert(type != ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 276     assert(type != ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 277     assert(type != ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 278     assert(type != ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 279     assert(!type-&gt;is_return_address(), &quot;&quot;);
 280 
 281     return Type::get_const_type(type);
 282   }
 283 }
 284 
 285 
 286 //-----------------------make_from_constant------------------------------------
 287 const Type* Type::make_from_constant(ciConstant constant, bool require_constant,
 288                                      int stable_dimension, bool is_narrow_oop,
 289                                      bool is_autobox_cache) {
 290   switch (constant.basic_type()) {
 291     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
 292     case T_CHAR:     return TypeInt::make(constant.as_char());
 293     case T_BYTE:     return TypeInt::make(constant.as_byte());
 294     case T_SHORT:    return TypeInt::make(constant.as_short());
 295     case T_INT:      return TypeInt::make(constant.as_int());
 296     case T_LONG:     return TypeLong::make(constant.as_long());
 297     case T_FLOAT:    return TypeF::make(constant.as_float());
 298     case T_DOUBLE:   return TypeD::make(constant.as_double());
 299     case T_ARRAY:
<span class="line-modified"> 300     case T_VALUETYPE:</span>
 301     case T_OBJECT: {
 302         const Type* con_type = NULL;
 303         ciObject* oop_constant = constant.as_object();
 304         if (oop_constant-&gt;is_null_object()) {
 305           con_type = Type::get_zero_type(T_OBJECT);
 306         } else {
 307           guarantee(require_constant || oop_constant-&gt;should_be_constant(), &quot;con_type must get computed&quot;);
 308           con_type = TypeOopPtr::make_from_constant(oop_constant, require_constant);
 309           if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; is_autobox_cache) {
 310             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_autobox_cache(true);
 311           }
 312           if (stable_dimension &gt; 0) {
 313             assert(FoldStableValues, &quot;sanity&quot;);
 314             assert(!con_type-&gt;is_zero_type(), &quot;default value for stable field&quot;);
 315             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_stable(true, stable_dimension);
 316           }
 317         }
 318         if (is_narrow_oop) {
 319           con_type = con_type-&gt;make_narrowoop();
 320         }
 321         return con_type;
 322       }
 323     case T_ILLEGAL:
 324       // Invalid ciConstant returned due to OutOfMemoryError in the CI
 325       assert(Compile::current()-&gt;env()-&gt;failing(), &quot;otherwise should not see this&quot;);
 326       return NULL;
 327     default:
 328       // Fall through to failure
 329       return NULL;
 330   }
 331 }
 332 
 333 static ciConstant check_mismatched_access(ciConstant con, BasicType loadbt, bool is_unsigned) {
 334   BasicType conbt = con.basic_type();
 335   switch (conbt) {
 336     case T_BOOLEAN: conbt = T_BYTE;   break;
 337     case T_ARRAY:   conbt = T_OBJECT; break;
<span class="line-modified"> 338     case T_VALUETYPE: conbt = T_OBJECT; break;</span>
 339     default:                          break;
 340   }
 341   switch (loadbt) {
 342     case T_BOOLEAN:   loadbt = T_BYTE;   break;
 343     case T_NARROWOOP: loadbt = T_OBJECT; break;
 344     case T_ARRAY:     loadbt = T_OBJECT; break;
<span class="line-modified"> 345     case T_VALUETYPE: loadbt = T_OBJECT; break;</span>
 346     case T_ADDRESS:   loadbt = T_OBJECT; break;
 347     default:                             break;
 348   }
 349   if (conbt == loadbt) {
 350     if (is_unsigned &amp;&amp; conbt == T_BYTE) {
 351       // LoadB (T_BYTE) with a small mask (&lt;=8-bit) is converted to LoadUB (T_BYTE).
 352       return ciConstant(T_INT, con.as_int() &amp; 0xFF);
 353     } else {
 354       return con;
 355     }
 356   }
 357   if (conbt == T_SHORT &amp;&amp; loadbt == T_CHAR) {
 358     // LoadS (T_SHORT) with a small mask (&lt;=16-bit) is converted to LoadUS (T_CHAR).
 359     return ciConstant(T_INT, con.as_int() &amp; 0xFFFF);
 360   }
 361   return ciConstant(); // T_ILLEGAL
 362 }
 363 
 364 // Try to constant-fold a stable array element.
 365 const Type* Type::make_constant_from_array_element(ciArray* array, int off, int stable_dimension,
</pre>
<hr />
<pre>
 622     assert(TypeAryPtr::NARROWOOPS-&gt;is_ptr_to_narrowoop(), &quot;array of narrow oops must be ptr to narrow oop&quot;);
 623     TypeAryPtr::OOPS  = TypeAryPtr::NARROWOOPS;
 624   } else
 625 #endif
 626   {
 627     // There is no shared klass for Object[].  See note in TypeAryPtr::klass().
 628     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);
 629   }
 630   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Offset::bottom);
 631   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Offset::bottom);
 632   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Offset::bottom);
 633   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);
 634   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);
 635   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);
 636   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);
 637   TypeAryPtr::VALUES  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeValueType::BOTTOM,TypeInt::POS), NULL, false,  Offset::bottom);
 638 
 639   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 640   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 641   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
<span class="line-modified"> 642   TypeAryPtr::_array_body_type[T_VALUETYPE] = TypeAryPtr::OOPS;</span>
 643   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 644   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 645   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 646   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 647   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 648   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 649   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 650   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 651   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 652 
 653   TypeKlassPtr::OBJECT = TypeKlassPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), Offset(0), false);
 654   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make(TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), Offset(0), false);
 655 
 656   const Type **fi2c = TypeTuple::fields(2);
 657   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
 658   fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
 659   TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
 660 
 661   const Type **intpair = TypeTuple::fields(2);
 662   intpair[0] = TypeInt::INT;
</pre>
<hr />
<pre>
 673   intccpair[1] = TypeInt::CC;
 674   TypeTuple::INT_CC_PAIR = TypeTuple::make(2, intccpair);
 675 
 676   const Type **longccpair = TypeTuple::fields(2);
 677   longccpair[0] = TypeLong::LONG;
 678   longccpair[1] = TypeInt::CC;
 679   TypeTuple::LONG_CC_PAIR = TypeTuple::make(2, longccpair);
 680 
 681   _const_basic_type[T_NARROWOOP]   = TypeNarrowOop::BOTTOM;
 682   _const_basic_type[T_NARROWKLASS] = Type::BOTTOM;
 683   _const_basic_type[T_BOOLEAN]     = TypeInt::BOOL;
 684   _const_basic_type[T_CHAR]        = TypeInt::CHAR;
 685   _const_basic_type[T_BYTE]        = TypeInt::BYTE;
 686   _const_basic_type[T_SHORT]       = TypeInt::SHORT;
 687   _const_basic_type[T_INT]         = TypeInt::INT;
 688   _const_basic_type[T_LONG]        = TypeLong::LONG;
 689   _const_basic_type[T_FLOAT]       = Type::FLOAT;
 690   _const_basic_type[T_DOUBLE]      = Type::DOUBLE;
 691   _const_basic_type[T_OBJECT]      = TypeInstPtr::BOTTOM;
 692   _const_basic_type[T_ARRAY]       = TypeInstPtr::BOTTOM; // there is no separate bottom for arrays
<span class="line-modified"> 693   _const_basic_type[T_VALUETYPE]   = TypeInstPtr::BOTTOM;</span>
 694   _const_basic_type[T_VOID]        = TypePtr::NULL_PTR;   // reflection represents void this way
 695   _const_basic_type[T_ADDRESS]     = TypeRawPtr::BOTTOM;  // both interpreter return addresses &amp; random raw ptrs
 696   _const_basic_type[T_CONFLICT]    = Type::BOTTOM;        // why not?
 697 
 698   _zero_type[T_NARROWOOP]   = TypeNarrowOop::NULL_PTR;
 699   _zero_type[T_NARROWKLASS] = TypeNarrowKlass::NULL_PTR;
 700   _zero_type[T_BOOLEAN]     = TypeInt::ZERO;     // false == 0
 701   _zero_type[T_CHAR]        = TypeInt::ZERO;     // &#39;\0&#39; == 0
 702   _zero_type[T_BYTE]        = TypeInt::ZERO;     // 0x00 == 0
 703   _zero_type[T_SHORT]       = TypeInt::ZERO;     // 0x0000 == 0
 704   _zero_type[T_INT]         = TypeInt::ZERO;
 705   _zero_type[T_LONG]        = TypeLong::ZERO;
 706   _zero_type[T_FLOAT]       = TypeF::ZERO;
 707   _zero_type[T_DOUBLE]      = TypeD::ZERO;
 708   _zero_type[T_OBJECT]      = TypePtr::NULL_PTR;
 709   _zero_type[T_ARRAY]       = TypePtr::NULL_PTR; // null array is null oop
<span class="line-modified"> 710   _zero_type[T_VALUETYPE]   = TypePtr::NULL_PTR;</span>
 711   _zero_type[T_ADDRESS]     = TypePtr::NULL_PTR; // raw pointers use the same null
 712   _zero_type[T_VOID]        = Type::TOP;         // the only void value is no value at all
 713 
 714   // get_zero_type() should not happen for T_CONFLICT
 715   _zero_type[T_CONFLICT]= NULL;
 716 
 717   // Vector predefined types, it needs initialized _const_basic_type[].
 718   if (Matcher::vector_size_supported(T_BYTE,4)) {
 719     TypeVect::VECTS = TypeVect::make(T_BYTE,4);
 720   }
 721   if (Matcher::vector_size_supported(T_FLOAT,2)) {
 722     TypeVect::VECTD = TypeVect::make(T_FLOAT,2);
 723   }
 724   if (Matcher::vector_size_supported(T_FLOAT,4)) {
 725     TypeVect::VECTX = TypeVect::make(T_FLOAT,4);
 726   }
 727   if (Matcher::vector_size_supported(T_FLOAT,8)) {
 728     TypeVect::VECTY = TypeVect::make(T_FLOAT,8);
 729   }
 730   if (Matcher::vector_size_supported(T_FLOAT,16)) {
</pre>
<hr />
<pre>
1984   const Type **field_array = fields(arg_cnt);
1985   switch (return_type-&gt;basic_type()) {
1986   case T_LONG:
1987     field_array[TypeFunc::Parms]   = TypeLong::LONG;
1988     field_array[TypeFunc::Parms+1] = Type::HALF;
1989     break;
1990   case T_DOUBLE:
1991     field_array[TypeFunc::Parms]   = Type::DOUBLE;
1992     field_array[TypeFunc::Parms+1] = Type::HALF;
1993     break;
1994   case T_OBJECT:
1995   case T_ARRAY:
1996   case T_BOOLEAN:
1997   case T_CHAR:
1998   case T_FLOAT:
1999   case T_BYTE:
2000   case T_SHORT:
2001   case T_INT:
2002     field_array[TypeFunc::Parms] = get_const_type(return_type);
2003     break;
<span class="line-modified">2004   case T_VALUETYPE:</span>
2005     if (ret_vt_fields) {
2006       uint pos = TypeFunc::Parms;
2007       field_array[pos] = TypePtr::BOTTOM;
2008       pos++;
2009       ExtendedSignature sig = ExtendedSignature(NULL, SigEntryFilter());
2010       collect_value_fields(return_type-&gt;as_value_klass(), field_array, pos, sig);
2011     } else {
2012       field_array[TypeFunc::Parms] = get_const_type(return_type)-&gt;join_speculative(sig-&gt;returns_never_null() ? TypePtr::NOTNULL : TypePtr::BOTTOM);
2013     }
2014     break;
2015   case T_VOID:
2016     break;
2017   default:
2018     ShouldNotReachHere();
2019   }
2020   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
2021 }
2022 
2023 // Make a TypeTuple from the domain of a method signature
2024 const TypeTuple *TypeTuple::make_domain(ciMethod* method, bool vt_fields_as_args) {
</pre>
<hr />
<pre>
2057     case T_LONG:
2058       field_array[pos++] = TypeLong::LONG;
2059       field_array[pos++] = Type::HALF;
2060       break;
2061     case T_DOUBLE:
2062       field_array[pos++] = Type::DOUBLE;
2063       field_array[pos++] = Type::HALF;
2064       break;
2065     case T_OBJECT:
2066     case T_ARRAY:
2067     case T_FLOAT:
2068     case T_INT:
2069       field_array[pos++] = get_const_type(type);
2070       break;
2071     case T_BOOLEAN:
2072     case T_CHAR:
2073     case T_BYTE:
2074     case T_SHORT:
2075       field_array[pos++] = TypeInt::INT;
2076       break;
<span class="line-modified">2077     case T_VALUETYPE: {</span>
2078       bool never_null = sig-&gt;is_never_null_at(i);
2079       if (vt_fields_as_args &amp;&amp; type-&gt;as_value_klass()-&gt;can_be_passed_as_fields() &amp;&amp; never_null) {
2080         is_flattened = true;
2081         collect_value_fields(type-&gt;as_value_klass(), field_array, pos, sig_cc);
2082       } else {
2083         field_array[pos++] = get_const_type(type)-&gt;join_speculative(never_null ? TypePtr::NOTNULL : TypePtr::BOTTOM);
2084       }
2085       break;
2086     }
2087     default:
2088       ShouldNotReachHere();
2089     }
2090     // Skip reserved arguments
2091     while (!is_flattened &amp;&amp; SigEntry::next_is_reserved(sig_cc, bt)) {
2092       field_array[pos++] = Type::get_const_basic_type(bt);
2093       if (type2size[bt] == 2) {
2094         field_array[pos++] = Type::HALF;
2095       }
2096     }
2097     i++;
</pre>
<hr />
<pre>
3239     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset.get());
3240   }
3241 #ifdef _LP64
3242   if (this-&gt;offset() &gt; 0 || this-&gt;offset() == Type::OffsetTop || this-&gt;offset() == Type::OffsetBot) {
3243     if (this-&gt;offset() == oopDesc::klass_offset_in_bytes()) {
3244       _is_ptr_to_narrowklass = UseCompressedClassPointers;
3245     } else if (klass() == NULL) {
3246       // Array with unknown body type
3247       assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
3248       _is_ptr_to_narrowoop = UseCompressedOops;
3249     } else if (UseCompressedOops &amp;&amp; this-&gt;isa_aryptr() &amp;&amp; this-&gt;offset() != arrayOopDesc::length_offset_in_bytes()) {
3250       if (klass()-&gt;is_obj_array_klass()) {
3251         _is_ptr_to_narrowoop = true;
3252       } else if (klass()-&gt;is_value_array_klass() &amp;&amp; field_offset != Offset::top &amp;&amp; field_offset != Offset::bottom) {
3253         // Check if the field of the value type array element contains oops
3254         ciValueKlass* vk = klass()-&gt;as_value_array_klass()-&gt;element_klass()-&gt;as_value_klass();
3255         int foffset = field_offset.get() + vk-&gt;first_field_offset();
3256         ciField* field = vk-&gt;get_field_by_offset(foffset, false);
3257         assert(field != NULL, &quot;missing field&quot;);
3258         BasicType bt = field-&gt;layout_type();
<span class="line-modified">3259         _is_ptr_to_narrowoop = (bt == T_OBJECT || bt == T_ARRAY || T_VALUETYPE);</span>
3260       }
3261     } else if (klass()-&gt;is_instance_klass()) {
3262       if (this-&gt;isa_klassptr()) {
3263         // Perm objects don&#39;t use compressed references
3264       } else if (_offset == Offset::bottom || _offset == Offset::top) {
3265         // unsafe access
3266         _is_ptr_to_narrowoop = UseCompressedOops;
3267       } else { // exclude unsafe ops
3268         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3269         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3270             (this-&gt;offset() == java_lang_Class::klass_offset() ||
3271              this-&gt;offset() == java_lang_Class::array_klass_offset())) {
3272           // Special hidden fields from the Class.
3273           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3274           _is_ptr_to_narrowoop = false;
3275         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3276                    this-&gt;offset() &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
3277           // Static fields
3278           assert(o != NULL, &quot;must be constant&quot;);
3279           ciInstanceKlass* ik = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
3280           BasicType basic_elem_type;
3281           if (ik-&gt;is_valuetype() &amp;&amp; this-&gt;offset() == ik-&gt;as_value_klass()-&gt;default_value_offset()) {
3282             // Special hidden field that contains the oop of the default value type
<span class="line-modified">3283             basic_elem_type = T_VALUETYPE;</span>
3284           } else {
3285             ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), true);
3286             assert(field != NULL, &quot;missing field&quot;);
3287             basic_elem_type = field-&gt;layout_type();
3288           }
3289           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3290         } else {
3291           // Instance fields which contains a compressed oop references.
3292           ciInstanceKlass* ik = klass()-&gt;as_instance_klass();
3293           ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), false);
3294           if (field != NULL) {
3295             BasicType basic_elem_type = field-&gt;layout_type();
3296             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3297           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3298             // Compile::find_alias_type() cast exactness on all types to verify
3299             // that it does not affect alias type.
3300             _is_ptr_to_narrowoop = UseCompressedOops;
3301           } else {
3302             // Type for the copy start in LibraryCallKit::inline_native_clone().
3303             _is_ptr_to_narrowoop = UseCompressedOops;
</pre>
</td>
<td>
<hr />
<pre>
 111 
 112 #if defined(PPC64)
 113   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 114   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 115   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 116   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 117   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 118 #elif defined(S390)
 119   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 120   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 121   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
 122   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 123   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 124 #else // all other
 125   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, Op_VecS,              relocInfo::none          },  // VectorS
 126   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
 127   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 128   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
 129   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
 130 #endif
<span class="line-modified"> 131   { Bad,             T_INLINE_TYPE, &quot;value:&quot;,       false, Node::NotAMachineReg, relocInfo::none          },  // ValueType</span>
 132   { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
 133   { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
 134   { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
 135   { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
 136   { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
 137   { Bad,             T_METADATA,   &quot;metadata:&quot;,     false, Op_RegP,              relocInfo::metadata_type },  // MetadataPtr
 138   { Bad,             T_METADATA,   &quot;klass:&quot;,        false, Op_RegP,              relocInfo::metadata_type },  // KlassPtr
 139   { Bad,             T_OBJECT,     &quot;func&quot;,          false, 0,                    relocInfo::none          },  // Function
 140   { Abio,            T_ILLEGAL,    &quot;abIO&quot;,          false, 0,                    relocInfo::none          },  // Abio
 141   { Return_Address,  T_ADDRESS,    &quot;return_address&quot;,false, Op_RegP,              relocInfo::none          },  // Return_Address
 142   { Memory,          T_ILLEGAL,    &quot;memory&quot;,        false, 0,                    relocInfo::none          },  // Memory
 143   { FloatBot,        T_FLOAT,      &quot;float_top&quot;,     false, Op_RegF,              relocInfo::none          },  // FloatTop
 144   { FloatCon,        T_FLOAT,      &quot;ftcon:&quot;,        false, Op_RegF,              relocInfo::none          },  // FloatCon
 145   { FloatTop,        T_FLOAT,      &quot;float&quot;,         false, Op_RegF,              relocInfo::none          },  // FloatBot
 146   { DoubleBot,       T_DOUBLE,     &quot;double_top&quot;,    false, Op_RegD,              relocInfo::none          },  // DoubleTop
 147   { DoubleCon,       T_DOUBLE,     &quot;dblcon:&quot;,       false, Op_RegD,              relocInfo::none          },  // DoubleCon
 148   { DoubleTop,       T_DOUBLE,     &quot;double&quot;,        false, Op_RegD,              relocInfo::none          },  // DoubleBot
 149   { Top,             T_ILLEGAL,    &quot;bottom&quot;,        false, 0,                    relocInfo::none          }   // Bottom
 150 };
 151 
</pre>
<hr />
<pre>
 242   case ciTypeFlow::StateVector::T_NULL:
 243     assert(type == ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 244     return TypePtr::NULL_PTR;
 245 
 246   case ciTypeFlow::StateVector::T_LONG2:
 247     // The ciTypeFlow pass pushes a long, then the half.
 248     // We do the same.
 249     assert(type == ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 250     return TypeInt::TOP;
 251 
 252   case ciTypeFlow::StateVector::T_DOUBLE2:
 253     // The ciTypeFlow pass pushes double, then the half.
 254     // Our convention is the same.
 255     assert(type == ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 256     return Type::TOP;
 257 
 258   case T_ADDRESS:
 259     assert(type-&gt;is_return_address(), &quot;&quot;);
 260     return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
 261 
<span class="line-modified"> 262   case T_INLINE_TYPE: {</span>
 263     bool is_never_null = type-&gt;is_never_null();
 264     ciValueKlass* vk = type-&gt;unwrap()-&gt;as_value_klass();
 265     if (vk-&gt;is_scalarizable() &amp;&amp; is_never_null) {
 266       return TypeValueType::make(vk);
 267     } else {
 268       return TypeOopPtr::make_from_klass(vk)-&gt;join_speculative(is_never_null ? TypePtr::NOTNULL : TypePtr::BOTTOM);
 269     }
 270   }
 271 
 272   default:
 273     // make sure we did not mix up the cases:
 274     assert(type != ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 275     assert(type != ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 276     assert(type != ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 277     assert(type != ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 278     assert(type != ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 279     assert(!type-&gt;is_return_address(), &quot;&quot;);
 280 
 281     return Type::get_const_type(type);
 282   }
 283 }
 284 
 285 
 286 //-----------------------make_from_constant------------------------------------
 287 const Type* Type::make_from_constant(ciConstant constant, bool require_constant,
 288                                      int stable_dimension, bool is_narrow_oop,
 289                                      bool is_autobox_cache) {
 290   switch (constant.basic_type()) {
 291     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
 292     case T_CHAR:     return TypeInt::make(constant.as_char());
 293     case T_BYTE:     return TypeInt::make(constant.as_byte());
 294     case T_SHORT:    return TypeInt::make(constant.as_short());
 295     case T_INT:      return TypeInt::make(constant.as_int());
 296     case T_LONG:     return TypeLong::make(constant.as_long());
 297     case T_FLOAT:    return TypeF::make(constant.as_float());
 298     case T_DOUBLE:   return TypeD::make(constant.as_double());
 299     case T_ARRAY:
<span class="line-modified"> 300     case T_INLINE_TYPE:</span>
 301     case T_OBJECT: {
 302         const Type* con_type = NULL;
 303         ciObject* oop_constant = constant.as_object();
 304         if (oop_constant-&gt;is_null_object()) {
 305           con_type = Type::get_zero_type(T_OBJECT);
 306         } else {
 307           guarantee(require_constant || oop_constant-&gt;should_be_constant(), &quot;con_type must get computed&quot;);
 308           con_type = TypeOopPtr::make_from_constant(oop_constant, require_constant);
 309           if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; is_autobox_cache) {
 310             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_autobox_cache(true);
 311           }
 312           if (stable_dimension &gt; 0) {
 313             assert(FoldStableValues, &quot;sanity&quot;);
 314             assert(!con_type-&gt;is_zero_type(), &quot;default value for stable field&quot;);
 315             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_stable(true, stable_dimension);
 316           }
 317         }
 318         if (is_narrow_oop) {
 319           con_type = con_type-&gt;make_narrowoop();
 320         }
 321         return con_type;
 322       }
 323     case T_ILLEGAL:
 324       // Invalid ciConstant returned due to OutOfMemoryError in the CI
 325       assert(Compile::current()-&gt;env()-&gt;failing(), &quot;otherwise should not see this&quot;);
 326       return NULL;
 327     default:
 328       // Fall through to failure
 329       return NULL;
 330   }
 331 }
 332 
 333 static ciConstant check_mismatched_access(ciConstant con, BasicType loadbt, bool is_unsigned) {
 334   BasicType conbt = con.basic_type();
 335   switch (conbt) {
 336     case T_BOOLEAN: conbt = T_BYTE;   break;
 337     case T_ARRAY:   conbt = T_OBJECT; break;
<span class="line-modified"> 338     case T_INLINE_TYPE: conbt = T_OBJECT; break;</span>
 339     default:                          break;
 340   }
 341   switch (loadbt) {
 342     case T_BOOLEAN:   loadbt = T_BYTE;   break;
 343     case T_NARROWOOP: loadbt = T_OBJECT; break;
 344     case T_ARRAY:     loadbt = T_OBJECT; break;
<span class="line-modified"> 345     case T_INLINE_TYPE: loadbt = T_OBJECT; break;</span>
 346     case T_ADDRESS:   loadbt = T_OBJECT; break;
 347     default:                             break;
 348   }
 349   if (conbt == loadbt) {
 350     if (is_unsigned &amp;&amp; conbt == T_BYTE) {
 351       // LoadB (T_BYTE) with a small mask (&lt;=8-bit) is converted to LoadUB (T_BYTE).
 352       return ciConstant(T_INT, con.as_int() &amp; 0xFF);
 353     } else {
 354       return con;
 355     }
 356   }
 357   if (conbt == T_SHORT &amp;&amp; loadbt == T_CHAR) {
 358     // LoadS (T_SHORT) with a small mask (&lt;=16-bit) is converted to LoadUS (T_CHAR).
 359     return ciConstant(T_INT, con.as_int() &amp; 0xFFFF);
 360   }
 361   return ciConstant(); // T_ILLEGAL
 362 }
 363 
 364 // Try to constant-fold a stable array element.
 365 const Type* Type::make_constant_from_array_element(ciArray* array, int off, int stable_dimension,
</pre>
<hr />
<pre>
 622     assert(TypeAryPtr::NARROWOOPS-&gt;is_ptr_to_narrowoop(), &quot;array of narrow oops must be ptr to narrow oop&quot;);
 623     TypeAryPtr::OOPS  = TypeAryPtr::NARROWOOPS;
 624   } else
 625 #endif
 626   {
 627     // There is no shared klass for Object[].  See note in TypeAryPtr::klass().
 628     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);
 629   }
 630   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Offset::bottom);
 631   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Offset::bottom);
 632   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Offset::bottom);
 633   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);
 634   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);
 635   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);
 636   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);
 637   TypeAryPtr::VALUES  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeValueType::BOTTOM,TypeInt::POS), NULL, false,  Offset::bottom);
 638 
 639   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 640   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 641   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
<span class="line-modified"> 642   TypeAryPtr::_array_body_type[T_INLINE_TYPE] = TypeAryPtr::OOPS;</span>
 643   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 644   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 645   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 646   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 647   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 648   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 649   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 650   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 651   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 652 
 653   TypeKlassPtr::OBJECT = TypeKlassPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), Offset(0), false);
 654   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make(TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), Offset(0), false);
 655 
 656   const Type **fi2c = TypeTuple::fields(2);
 657   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
 658   fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
 659   TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
 660 
 661   const Type **intpair = TypeTuple::fields(2);
 662   intpair[0] = TypeInt::INT;
</pre>
<hr />
<pre>
 673   intccpair[1] = TypeInt::CC;
 674   TypeTuple::INT_CC_PAIR = TypeTuple::make(2, intccpair);
 675 
 676   const Type **longccpair = TypeTuple::fields(2);
 677   longccpair[0] = TypeLong::LONG;
 678   longccpair[1] = TypeInt::CC;
 679   TypeTuple::LONG_CC_PAIR = TypeTuple::make(2, longccpair);
 680 
 681   _const_basic_type[T_NARROWOOP]   = TypeNarrowOop::BOTTOM;
 682   _const_basic_type[T_NARROWKLASS] = Type::BOTTOM;
 683   _const_basic_type[T_BOOLEAN]     = TypeInt::BOOL;
 684   _const_basic_type[T_CHAR]        = TypeInt::CHAR;
 685   _const_basic_type[T_BYTE]        = TypeInt::BYTE;
 686   _const_basic_type[T_SHORT]       = TypeInt::SHORT;
 687   _const_basic_type[T_INT]         = TypeInt::INT;
 688   _const_basic_type[T_LONG]        = TypeLong::LONG;
 689   _const_basic_type[T_FLOAT]       = Type::FLOAT;
 690   _const_basic_type[T_DOUBLE]      = Type::DOUBLE;
 691   _const_basic_type[T_OBJECT]      = TypeInstPtr::BOTTOM;
 692   _const_basic_type[T_ARRAY]       = TypeInstPtr::BOTTOM; // there is no separate bottom for arrays
<span class="line-modified"> 693   _const_basic_type[T_INLINE_TYPE] = TypeInstPtr::BOTTOM;</span>
 694   _const_basic_type[T_VOID]        = TypePtr::NULL_PTR;   // reflection represents void this way
 695   _const_basic_type[T_ADDRESS]     = TypeRawPtr::BOTTOM;  // both interpreter return addresses &amp; random raw ptrs
 696   _const_basic_type[T_CONFLICT]    = Type::BOTTOM;        // why not?
 697 
 698   _zero_type[T_NARROWOOP]   = TypeNarrowOop::NULL_PTR;
 699   _zero_type[T_NARROWKLASS] = TypeNarrowKlass::NULL_PTR;
 700   _zero_type[T_BOOLEAN]     = TypeInt::ZERO;     // false == 0
 701   _zero_type[T_CHAR]        = TypeInt::ZERO;     // &#39;\0&#39; == 0
 702   _zero_type[T_BYTE]        = TypeInt::ZERO;     // 0x00 == 0
 703   _zero_type[T_SHORT]       = TypeInt::ZERO;     // 0x0000 == 0
 704   _zero_type[T_INT]         = TypeInt::ZERO;
 705   _zero_type[T_LONG]        = TypeLong::ZERO;
 706   _zero_type[T_FLOAT]       = TypeF::ZERO;
 707   _zero_type[T_DOUBLE]      = TypeD::ZERO;
 708   _zero_type[T_OBJECT]      = TypePtr::NULL_PTR;
 709   _zero_type[T_ARRAY]       = TypePtr::NULL_PTR; // null array is null oop
<span class="line-modified"> 710   _zero_type[T_INLINE_TYPE] = TypePtr::NULL_PTR;</span>
 711   _zero_type[T_ADDRESS]     = TypePtr::NULL_PTR; // raw pointers use the same null
 712   _zero_type[T_VOID]        = Type::TOP;         // the only void value is no value at all
 713 
 714   // get_zero_type() should not happen for T_CONFLICT
 715   _zero_type[T_CONFLICT]= NULL;
 716 
 717   // Vector predefined types, it needs initialized _const_basic_type[].
 718   if (Matcher::vector_size_supported(T_BYTE,4)) {
 719     TypeVect::VECTS = TypeVect::make(T_BYTE,4);
 720   }
 721   if (Matcher::vector_size_supported(T_FLOAT,2)) {
 722     TypeVect::VECTD = TypeVect::make(T_FLOAT,2);
 723   }
 724   if (Matcher::vector_size_supported(T_FLOAT,4)) {
 725     TypeVect::VECTX = TypeVect::make(T_FLOAT,4);
 726   }
 727   if (Matcher::vector_size_supported(T_FLOAT,8)) {
 728     TypeVect::VECTY = TypeVect::make(T_FLOAT,8);
 729   }
 730   if (Matcher::vector_size_supported(T_FLOAT,16)) {
</pre>
<hr />
<pre>
1984   const Type **field_array = fields(arg_cnt);
1985   switch (return_type-&gt;basic_type()) {
1986   case T_LONG:
1987     field_array[TypeFunc::Parms]   = TypeLong::LONG;
1988     field_array[TypeFunc::Parms+1] = Type::HALF;
1989     break;
1990   case T_DOUBLE:
1991     field_array[TypeFunc::Parms]   = Type::DOUBLE;
1992     field_array[TypeFunc::Parms+1] = Type::HALF;
1993     break;
1994   case T_OBJECT:
1995   case T_ARRAY:
1996   case T_BOOLEAN:
1997   case T_CHAR:
1998   case T_FLOAT:
1999   case T_BYTE:
2000   case T_SHORT:
2001   case T_INT:
2002     field_array[TypeFunc::Parms] = get_const_type(return_type);
2003     break;
<span class="line-modified">2004   case T_INLINE_TYPE:</span>
2005     if (ret_vt_fields) {
2006       uint pos = TypeFunc::Parms;
2007       field_array[pos] = TypePtr::BOTTOM;
2008       pos++;
2009       ExtendedSignature sig = ExtendedSignature(NULL, SigEntryFilter());
2010       collect_value_fields(return_type-&gt;as_value_klass(), field_array, pos, sig);
2011     } else {
2012       field_array[TypeFunc::Parms] = get_const_type(return_type)-&gt;join_speculative(sig-&gt;returns_never_null() ? TypePtr::NOTNULL : TypePtr::BOTTOM);
2013     }
2014     break;
2015   case T_VOID:
2016     break;
2017   default:
2018     ShouldNotReachHere();
2019   }
2020   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
2021 }
2022 
2023 // Make a TypeTuple from the domain of a method signature
2024 const TypeTuple *TypeTuple::make_domain(ciMethod* method, bool vt_fields_as_args) {
</pre>
<hr />
<pre>
2057     case T_LONG:
2058       field_array[pos++] = TypeLong::LONG;
2059       field_array[pos++] = Type::HALF;
2060       break;
2061     case T_DOUBLE:
2062       field_array[pos++] = Type::DOUBLE;
2063       field_array[pos++] = Type::HALF;
2064       break;
2065     case T_OBJECT:
2066     case T_ARRAY:
2067     case T_FLOAT:
2068     case T_INT:
2069       field_array[pos++] = get_const_type(type);
2070       break;
2071     case T_BOOLEAN:
2072     case T_CHAR:
2073     case T_BYTE:
2074     case T_SHORT:
2075       field_array[pos++] = TypeInt::INT;
2076       break;
<span class="line-modified">2077     case T_INLINE_TYPE: {</span>
2078       bool never_null = sig-&gt;is_never_null_at(i);
2079       if (vt_fields_as_args &amp;&amp; type-&gt;as_value_klass()-&gt;can_be_passed_as_fields() &amp;&amp; never_null) {
2080         is_flattened = true;
2081         collect_value_fields(type-&gt;as_value_klass(), field_array, pos, sig_cc);
2082       } else {
2083         field_array[pos++] = get_const_type(type)-&gt;join_speculative(never_null ? TypePtr::NOTNULL : TypePtr::BOTTOM);
2084       }
2085       break;
2086     }
2087     default:
2088       ShouldNotReachHere();
2089     }
2090     // Skip reserved arguments
2091     while (!is_flattened &amp;&amp; SigEntry::next_is_reserved(sig_cc, bt)) {
2092       field_array[pos++] = Type::get_const_basic_type(bt);
2093       if (type2size[bt] == 2) {
2094         field_array[pos++] = Type::HALF;
2095       }
2096     }
2097     i++;
</pre>
<hr />
<pre>
3239     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset.get());
3240   }
3241 #ifdef _LP64
3242   if (this-&gt;offset() &gt; 0 || this-&gt;offset() == Type::OffsetTop || this-&gt;offset() == Type::OffsetBot) {
3243     if (this-&gt;offset() == oopDesc::klass_offset_in_bytes()) {
3244       _is_ptr_to_narrowklass = UseCompressedClassPointers;
3245     } else if (klass() == NULL) {
3246       // Array with unknown body type
3247       assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
3248       _is_ptr_to_narrowoop = UseCompressedOops;
3249     } else if (UseCompressedOops &amp;&amp; this-&gt;isa_aryptr() &amp;&amp; this-&gt;offset() != arrayOopDesc::length_offset_in_bytes()) {
3250       if (klass()-&gt;is_obj_array_klass()) {
3251         _is_ptr_to_narrowoop = true;
3252       } else if (klass()-&gt;is_value_array_klass() &amp;&amp; field_offset != Offset::top &amp;&amp; field_offset != Offset::bottom) {
3253         // Check if the field of the value type array element contains oops
3254         ciValueKlass* vk = klass()-&gt;as_value_array_klass()-&gt;element_klass()-&gt;as_value_klass();
3255         int foffset = field_offset.get() + vk-&gt;first_field_offset();
3256         ciField* field = vk-&gt;get_field_by_offset(foffset, false);
3257         assert(field != NULL, &quot;missing field&quot;);
3258         BasicType bt = field-&gt;layout_type();
<span class="line-modified">3259         _is_ptr_to_narrowoop = (bt == T_OBJECT || bt == T_ARRAY || T_INLINE_TYPE);</span>
3260       }
3261     } else if (klass()-&gt;is_instance_klass()) {
3262       if (this-&gt;isa_klassptr()) {
3263         // Perm objects don&#39;t use compressed references
3264       } else if (_offset == Offset::bottom || _offset == Offset::top) {
3265         // unsafe access
3266         _is_ptr_to_narrowoop = UseCompressedOops;
3267       } else { // exclude unsafe ops
3268         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3269         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3270             (this-&gt;offset() == java_lang_Class::klass_offset() ||
3271              this-&gt;offset() == java_lang_Class::array_klass_offset())) {
3272           // Special hidden fields from the Class.
3273           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3274           _is_ptr_to_narrowoop = false;
3275         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3276                    this-&gt;offset() &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
3277           // Static fields
3278           assert(o != NULL, &quot;must be constant&quot;);
3279           ciInstanceKlass* ik = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
3280           BasicType basic_elem_type;
3281           if (ik-&gt;is_valuetype() &amp;&amp; this-&gt;offset() == ik-&gt;as_value_klass()-&gt;default_value_offset()) {
3282             // Special hidden field that contains the oop of the default value type
<span class="line-modified">3283             basic_elem_type = T_INLINE_TYPE;</span>
3284           } else {
3285             ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), true);
3286             assert(field != NULL, &quot;missing field&quot;);
3287             basic_elem_type = field-&gt;layout_type();
3288           }
3289           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3290         } else {
3291           // Instance fields which contains a compressed oop references.
3292           ciInstanceKlass* ik = klass()-&gt;as_instance_klass();
3293           ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), false);
3294           if (field != NULL) {
3295             BasicType basic_elem_type = field-&gt;layout_type();
3296             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3297           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3298             // Compile::find_alias_type() cast exactness on all types to verify
3299             // that it does not affect alias type.
3300             _is_ptr_to_narrowoop = UseCompressedOops;
3301           } else {
3302             // Type for the copy start in LibraryCallKit::inline_native_clone().
3303             _is_ptr_to_narrowoop = UseCompressedOops;
</pre>
</td>
</tr>
</table>
<center><a href="parseHelper.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valuetypenode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
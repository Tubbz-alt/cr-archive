<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/arraycopynode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../oops/valueKlass.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="doCall.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/arraycopynode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 268,35 ***</span>
      }
  
      BasicType src_elem  = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
      BasicType dest_elem = ary_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
      if (src_elem  == T_ARRAY ||
<span class="line-modified">!         (src_elem == T_VALUETYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass())) {</span>
        src_elem  = T_OBJECT;
      }
      if (dest_elem == T_ARRAY ||
<span class="line-modified">!         (dest_elem == T_VALUETYPE &amp;&amp; ary_dest-&gt;klass()-&gt;is_obj_array_klass())) {</span>
        dest_elem = T_OBJECT;
      }
  
      if (src_elem != dest_elem || dest_elem == T_VOID) {
        // We don&#39;t know if arguments are arrays of the same type
        return false;
      }
  
      BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
      if (bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), dest_elem, false, BarrierSetC2::Optimization) ||
<span class="line-modified">!         (src_elem == T_VALUETYPE &amp;&amp; ary_src-&gt;elem()-&gt;value_klass()-&gt;contains_oops() &amp;&amp;</span>
           bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), T_OBJECT, false, BarrierSetC2::Optimization))) {
        // It&#39;s an object array copy but we can&#39;t emit the card marking that is needed
        return false;
      }
  
      value_type = ary_src-&gt;elem();
  
      uint shift  = exact_log2(type2aelembytes(dest_elem));
<span class="line-modified">!     if (dest_elem == T_VALUETYPE) {</span>
        ciValueArrayKlass* vak = ary_src-&gt;klass()-&gt;as_value_array_klass();
        shift = vak-&gt;log2_element_size();
      }
      uint header = arrayOopDesc::base_offset_in_bytes(dest_elem);
  
<span class="line-new-header">--- 268,35 ---</span>
      }
  
      BasicType src_elem  = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
      BasicType dest_elem = ary_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
      if (src_elem  == T_ARRAY ||
<span class="line-modified">!         (src_elem == T_INLINE_TYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass())) {</span>
        src_elem  = T_OBJECT;
      }
      if (dest_elem == T_ARRAY ||
<span class="line-modified">!         (dest_elem == T_INLINE_TYPE &amp;&amp; ary_dest-&gt;klass()-&gt;is_obj_array_klass())) {</span>
        dest_elem = T_OBJECT;
      }
  
      if (src_elem != dest_elem || dest_elem == T_VOID) {
        // We don&#39;t know if arguments are arrays of the same type
        return false;
      }
  
      BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
      if (bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), dest_elem, false, BarrierSetC2::Optimization) ||
<span class="line-modified">!         (src_elem == T_INLINE_TYPE &amp;&amp; ary_src-&gt;elem()-&gt;value_klass()-&gt;contains_oops() &amp;&amp;</span>
           bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), T_OBJECT, false, BarrierSetC2::Optimization))) {
        // It&#39;s an object array copy but we can&#39;t emit the card marking that is needed
        return false;
      }
  
      value_type = ary_src-&gt;elem();
  
      uint shift  = exact_log2(type2aelembytes(dest_elem));
<span class="line-modified">!     if (dest_elem == T_INLINE_TYPE) {</span>
        ciValueArrayKlass* vak = ary_src-&gt;klass()-&gt;as_value_array_klass();
        shift = vak-&gt;log2_element_size();
      }
      uint header = arrayOopDesc::base_offset_in_bytes(dest_elem);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 331,17 ***</span>
      adr_src  = phase-&gt;transform(new AddPNode(base_src, base_src, src_offset));
      adr_dest = phase-&gt;transform(new AddPNode(base_dest, base_dest, dest_offset));
  
      BasicType elem = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
      if (elem == T_ARRAY ||
<span class="line-modified">!         (elem == T_VALUETYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass())) {</span>
        elem = T_OBJECT;
      }
  
      BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
      if (bs-&gt;array_copy_requires_gc_barriers(true, elem, true, BarrierSetC2::Optimization) ||
<span class="line-modified">!         (elem == T_VALUETYPE &amp;&amp; ary_src-&gt;elem()-&gt;value_klass()-&gt;contains_oops() &amp;&amp;</span>
           bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization))) {
        return false;
      }
  
      // The address is offseted to an aligned address where a raw copy would start.
<span class="line-new-header">--- 331,17 ---</span>
      adr_src  = phase-&gt;transform(new AddPNode(base_src, base_src, src_offset));
      adr_dest = phase-&gt;transform(new AddPNode(base_dest, base_dest, dest_offset));
  
      BasicType elem = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
      if (elem == T_ARRAY ||
<span class="line-modified">!         (elem == T_INLINE_TYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass())) {</span>
        elem = T_OBJECT;
      }
  
      BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
      if (bs-&gt;array_copy_requires_gc_barriers(true, elem, true, BarrierSetC2::Optimization) ||
<span class="line-modified">!         (elem == T_INLINE_TYPE &amp;&amp; ary_src-&gt;elem()-&gt;value_klass()-&gt;contains_oops() &amp;&amp;</span>
           bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization))) {
        return false;
      }
  
      // The address is offseted to an aligned address where a raw copy would start.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 397,21 ***</span>
                           Node* adr_dest,
                           BasicType copy_type,
                           const Type* value_type) {
    BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
    Node* ctl = kit.control();
<span class="line-modified">!   if (copy_type == T_VALUETYPE) {</span>
      ciValueArrayKlass* vak = atp_src-&gt;klass()-&gt;as_value_array_klass();
      ciValueKlass* vk = vak-&gt;element_klass()-&gt;as_value_klass();
      for (int j = 0; j &lt; vk-&gt;nof_nonstatic_fields(); j++) {
        ciField* field = vk-&gt;nonstatic_field_at(j);
        int off_in_vt = field-&gt;offset() - vk-&gt;first_field_offset();
        Node* off  = kit.MakeConX(off_in_vt + i * vak-&gt;element_byte_size());
        ciType* ft = field-&gt;type();
        BasicType bt = type2field[ft-&gt;basic_type()];
        assert(!field-&gt;is_flattened(), &quot;flattened field encountered&quot;);
<span class="line-modified">!       if (bt == T_VALUETYPE) {</span>
          bt = T_OBJECT;
        }
        const Type* rt = Type::get_const_type(ft);
        const TypePtr* adr_type = atp_src-&gt;with_field_offset(off_in_vt)-&gt;add_offset(Type::OffsetBot);
        assert(!bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), bt, false, BarrierSetC2::Optimization), &quot;GC barriers required&quot;);
<span class="line-new-header">--- 397,21 ---</span>
                           Node* adr_dest,
                           BasicType copy_type,
                           const Type* value_type) {
    BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
    Node* ctl = kit.control();
<span class="line-modified">!   if (copy_type == T_INLINE_TYPE) {</span>
      ciValueArrayKlass* vak = atp_src-&gt;klass()-&gt;as_value_array_klass();
      ciValueKlass* vk = vak-&gt;element_klass()-&gt;as_value_klass();
      for (int j = 0; j &lt; vk-&gt;nof_nonstatic_fields(); j++) {
        ciField* field = vk-&gt;nonstatic_field_at(j);
        int off_in_vt = field-&gt;offset() - vk-&gt;first_field_offset();
        Node* off  = kit.MakeConX(off_in_vt + i * vak-&gt;element_byte_size());
        ciType* ft = field-&gt;type();
        BasicType bt = type2field[ft-&gt;basic_type()];
        assert(!field-&gt;is_flattened(), &quot;flattened field encountered&quot;);
<span class="line-modified">!       if (bt == T_INLINE_TYPE) {</span>
          bt = T_OBJECT;
        }
        const Type* rt = Type::get_const_type(ft);
        const TypePtr* adr_type = atp_src-&gt;with_field_offset(off_in_vt)-&gt;add_offset(Type::OffsetBot);
        assert(!bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), bt, false, BarrierSetC2::Optimization), &quot;GC barriers required&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 536,11 ***</span>
        const Type* src_type = phase-&gt;type(src);
        const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();
        BasicType elem = ary_src != NULL ? ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type() : T_CONFLICT;
        BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
        assert(!is_clonebasic() || bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization) ||
<span class="line-modified">!              (ary_src != NULL &amp;&amp; elem == T_VALUETYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass()), &quot;added control for clone?&quot;);</span>
  #endif
        assert(!is_clonebasic() || UseShenandoahGC, &quot;added control for clone?&quot;);
        phase-&gt;record_for_igvn(this);
        return false;
      }
<span class="line-new-header">--- 536,11 ---</span>
        const Type* src_type = phase-&gt;type(src);
        const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();
        BasicType elem = ary_src != NULL ? ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type() : T_CONFLICT;
        BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
        assert(!is_clonebasic() || bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization) ||
<span class="line-modified">!              (ary_src != NULL &amp;&amp; elem == T_INLINE_TYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass()), &quot;added control for clone?&quot;);</span>
  #endif
        assert(!is_clonebasic() || UseShenandoahGC, &quot;added control for clone?&quot;);
        phase-&gt;record_for_igvn(this);
        return false;
      }
</pre>
<center><a href="../oops/valueKlass.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="doCall.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
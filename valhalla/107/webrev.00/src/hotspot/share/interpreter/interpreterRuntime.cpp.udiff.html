<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/interpreter/interpreterRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../gc/g1/c2/g1BarrierSetC2.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateInterpreterGenerator.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/interpreterRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -288,11 +288,11 @@</span>
    case T_LONG:
      instance()-&gt;long_field_put(offset, (jlong)*((long long*)addr));
      break;
    case T_OBJECT:
    case T_ARRAY:
<span class="udiff-line-modified-removed">-   case T_VALUETYPE:</span>
<span class="udiff-line-modified-added">+   case T_INLINE_TYPE:</span>
      fatal(&quot;Should not be handled with this method&quot;);
      break;
    default:
      fatal(&quot;Unsupported BasicType&quot;);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -349,11 +349,11 @@</span>
    // Updating the field specified in arguments
    if (field_type == T_ARRAY || field_type == T_OBJECT) {
      oop aoop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
      assert(aoop == NULL || oopDesc::is_oop(aoop),&quot;argument must be a reference type&quot;);
      new_value_h()-&gt;obj_field_put(field_offset, aoop);
<span class="udiff-line-modified-removed">-   } else if (field_type == T_VALUETYPE) {</span>
<span class="udiff-line-modified-added">+   } else if (field_type == T_INLINE_TYPE) {</span>
      if (cp_entry-&gt;is_inlined()) {
        oop vt_oop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
        assert(vt_oop != NULL &amp;&amp; oopDesc::is_oop(vt_oop) &amp;&amp; vt_oop-&gt;is_inline_type(),&quot;argument must be an inline type&quot;);
        ValueKlass* field_vk = ValueKlass::cast(vklass-&gt;get_inline_type_field_klass(field_index));
        assert(vt_oop != NULL &amp;&amp; field_vk == vt_oop-&gt;klass(), &quot;Must match&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -364,11 +364,11 @@</span>
          THROW_(vmSymbols::java_lang_NullPointerException(), return_offset);
        }
        assert(voop == NULL || oopDesc::is_oop(voop),&quot;checking argument&quot;);
        new_value_h()-&gt;obj_field_put(field_offset, voop);
      }
<span class="udiff-line-modified-removed">-   } else { // not T_OBJECT nor T_ARRAY nor T_VALUETYPE</span>
<span class="udiff-line-modified-added">+   } else { // not T_OBJECT nor T_ARRAY nor T_INLINE_TYPE</span>
      intptr_t* addr = f.interpreter_frame_expression_stack_at(tos_idx);
      copy_primitive_argument(addr, new_value_h, field_offset, field_type);
    }
  
    // returning result
</pre>
<center><a href="../gc/g1/c2/g1BarrierSetC2.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateInterpreterGenerator.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
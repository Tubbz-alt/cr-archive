<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/interpreterRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../gc/g1/c2/g1BarrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateInterpreterGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/interpreterRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 273   case T_FLOAT:
 274     instance()-&gt;float_field_put(offset, (jfloat)*((float*)addr));
 275     break;
 276   case T_DOUBLE:
 277     instance()-&gt;double_field_put(offset, (jdouble)*((double*)addr));
 278     break;
 279   case T_BYTE:
 280     instance()-&gt;byte_field_put(offset, (jbyte)*((int*)addr));
 281     break;
 282   case T_SHORT:
 283     instance()-&gt;short_field_put(offset, (jshort)*((int*)addr));
 284     break;
 285   case T_INT:
 286     instance()-&gt;int_field_put(offset, (jint)*((int*)addr));
 287     break;
 288   case T_LONG:
 289     instance()-&gt;long_field_put(offset, (jlong)*((long long*)addr));
 290     break;
 291   case T_OBJECT:
 292   case T_ARRAY:
<span class="line-modified"> 293   case T_VALUETYPE:</span>
 294     fatal(&quot;Should not be handled with this method&quot;);
 295     break;
 296   default:
 297     fatal(&quot;Unsupported BasicType&quot;);
 298   }
 299 }
 300 
 301 JRT_ENTRY(void, InterpreterRuntime::defaultvalue(JavaThread* thread, ConstantPool* pool, int index))
 302   // Getting the ValueKlass
 303   Klass* k = pool-&gt;klass_at(index, CHECK);
 304   if (!k-&gt;is_inline_klass()) {
 305     // inconsistency with &#39;new&#39; which throws an InstantiationError
 306     // in the future, defaultvalue will just return null instead of throwing an exception
 307     THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
 308   }
 309   assert(k-&gt;is_inline_klass(), &quot;defaultvalue argument must be the inline type class&quot;);
 310   ValueKlass* vklass = ValueKlass::cast(k);
 311 
 312   vklass-&gt;initialize(THREAD);
 313   oop res = vklass-&gt;default_value();
</pre>
<hr />
<pre>
 334 
 335   // Getting old value
 336   frame&amp; f = last_frame.get_frame();
 337   jint tos_idx = f.interpreter_frame_expression_stack_size() - 1;
 338   int vt_offset = type2size[field_type];
 339   oop old_value = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx - vt_offset);
 340   assert(old_value != NULL &amp;&amp; oopDesc::is_oop(old_value) &amp;&amp; old_value-&gt;is_inline_type(),&quot;Verifying receiver&quot;);
 341   Handle old_value_h(THREAD, old_value);
 342 
 343   // Creating new value by copying the one passed in argument
 344   instanceOop new_value = vklass-&gt;allocate_instance(
 345       CHECK_((type2size[field_type]) * AbstractInterpreter::stackElementSize));
 346   Handle new_value_h = Handle(THREAD, new_value);
 347   vklass-&gt;value_copy_oop_to_new_oop(old_value_h(), new_value_h());
 348 
 349   // Updating the field specified in arguments
 350   if (field_type == T_ARRAY || field_type == T_OBJECT) {
 351     oop aoop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
 352     assert(aoop == NULL || oopDesc::is_oop(aoop),&quot;argument must be a reference type&quot;);
 353     new_value_h()-&gt;obj_field_put(field_offset, aoop);
<span class="line-modified"> 354   } else if (field_type == T_VALUETYPE) {</span>
 355     if (cp_entry-&gt;is_inlined()) {
 356       oop vt_oop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
 357       assert(vt_oop != NULL &amp;&amp; oopDesc::is_oop(vt_oop) &amp;&amp; vt_oop-&gt;is_inline_type(),&quot;argument must be an inline type&quot;);
 358       ValueKlass* field_vk = ValueKlass::cast(vklass-&gt;get_inline_type_field_klass(field_index));
 359       assert(vt_oop != NULL &amp;&amp; field_vk == vt_oop-&gt;klass(), &quot;Must match&quot;);
 360       field_vk-&gt;write_inlined_field(new_value_h(), offset, vt_oop, CHECK_(return_offset));
 361     } else { // not inlined
 362       oop voop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
 363       if (voop == NULL &amp;&amp; cp_entry-&gt;is_inline_type()) {
 364         THROW_(vmSymbols::java_lang_NullPointerException(), return_offset);
 365       }
 366       assert(voop == NULL || oopDesc::is_oop(voop),&quot;checking argument&quot;);
 367       new_value_h()-&gt;obj_field_put(field_offset, voop);
 368     }
<span class="line-modified"> 369   } else { // not T_OBJECT nor T_ARRAY nor T_VALUETYPE</span>
 370     intptr_t* addr = f.interpreter_frame_expression_stack_at(tos_idx);
 371     copy_primitive_argument(addr, new_value_h, field_offset, field_type);
 372   }
 373 
 374   // returning result
 375   thread-&gt;set_vm_result(new_value_h());
 376   return return_offset;
 377 JRT_END
 378 
 379 JRT_ENTRY(void, InterpreterRuntime::uninitialized_static_value_field(JavaThread* thread, oopDesc* mirror, int index))
 380   // The interpreter tries to access an inline static field that has not been initialized.
 381   // This situation can happen in different scenarios:
 382   //   1 - if the load or initialization of the field failed during step 8 of
 383   //       the initialization of the holder of the field, in this case the access to the field
 384   //       must fail
 385   //   2 - it can also happen when the initialization of the holder class triggered the initialization of
 386   //       another class which accesses this field in its static initializer, in this case the
 387   //       access must succeed to allow circularity
 388   // The code below tries to load and initialize the field&#39;s class again before returning the default value.
 389   // If the field was not initialized because of an error, a exception should be thrown.
</pre>
</td>
<td>
<hr />
<pre>
 273   case T_FLOAT:
 274     instance()-&gt;float_field_put(offset, (jfloat)*((float*)addr));
 275     break;
 276   case T_DOUBLE:
 277     instance()-&gt;double_field_put(offset, (jdouble)*((double*)addr));
 278     break;
 279   case T_BYTE:
 280     instance()-&gt;byte_field_put(offset, (jbyte)*((int*)addr));
 281     break;
 282   case T_SHORT:
 283     instance()-&gt;short_field_put(offset, (jshort)*((int*)addr));
 284     break;
 285   case T_INT:
 286     instance()-&gt;int_field_put(offset, (jint)*((int*)addr));
 287     break;
 288   case T_LONG:
 289     instance()-&gt;long_field_put(offset, (jlong)*((long long*)addr));
 290     break;
 291   case T_OBJECT:
 292   case T_ARRAY:
<span class="line-modified"> 293   case T_INLINE_TYPE:</span>
 294     fatal(&quot;Should not be handled with this method&quot;);
 295     break;
 296   default:
 297     fatal(&quot;Unsupported BasicType&quot;);
 298   }
 299 }
 300 
 301 JRT_ENTRY(void, InterpreterRuntime::defaultvalue(JavaThread* thread, ConstantPool* pool, int index))
 302   // Getting the ValueKlass
 303   Klass* k = pool-&gt;klass_at(index, CHECK);
 304   if (!k-&gt;is_inline_klass()) {
 305     // inconsistency with &#39;new&#39; which throws an InstantiationError
 306     // in the future, defaultvalue will just return null instead of throwing an exception
 307     THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
 308   }
 309   assert(k-&gt;is_inline_klass(), &quot;defaultvalue argument must be the inline type class&quot;);
 310   ValueKlass* vklass = ValueKlass::cast(k);
 311 
 312   vklass-&gt;initialize(THREAD);
 313   oop res = vklass-&gt;default_value();
</pre>
<hr />
<pre>
 334 
 335   // Getting old value
 336   frame&amp; f = last_frame.get_frame();
 337   jint tos_idx = f.interpreter_frame_expression_stack_size() - 1;
 338   int vt_offset = type2size[field_type];
 339   oop old_value = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx - vt_offset);
 340   assert(old_value != NULL &amp;&amp; oopDesc::is_oop(old_value) &amp;&amp; old_value-&gt;is_inline_type(),&quot;Verifying receiver&quot;);
 341   Handle old_value_h(THREAD, old_value);
 342 
 343   // Creating new value by copying the one passed in argument
 344   instanceOop new_value = vklass-&gt;allocate_instance(
 345       CHECK_((type2size[field_type]) * AbstractInterpreter::stackElementSize));
 346   Handle new_value_h = Handle(THREAD, new_value);
 347   vklass-&gt;value_copy_oop_to_new_oop(old_value_h(), new_value_h());
 348 
 349   // Updating the field specified in arguments
 350   if (field_type == T_ARRAY || field_type == T_OBJECT) {
 351     oop aoop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
 352     assert(aoop == NULL || oopDesc::is_oop(aoop),&quot;argument must be a reference type&quot;);
 353     new_value_h()-&gt;obj_field_put(field_offset, aoop);
<span class="line-modified"> 354   } else if (field_type == T_INLINE_TYPE) {</span>
 355     if (cp_entry-&gt;is_inlined()) {
 356       oop vt_oop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
 357       assert(vt_oop != NULL &amp;&amp; oopDesc::is_oop(vt_oop) &amp;&amp; vt_oop-&gt;is_inline_type(),&quot;argument must be an inline type&quot;);
 358       ValueKlass* field_vk = ValueKlass::cast(vklass-&gt;get_inline_type_field_klass(field_index));
 359       assert(vt_oop != NULL &amp;&amp; field_vk == vt_oop-&gt;klass(), &quot;Must match&quot;);
 360       field_vk-&gt;write_inlined_field(new_value_h(), offset, vt_oop, CHECK_(return_offset));
 361     } else { // not inlined
 362       oop voop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
 363       if (voop == NULL &amp;&amp; cp_entry-&gt;is_inline_type()) {
 364         THROW_(vmSymbols::java_lang_NullPointerException(), return_offset);
 365       }
 366       assert(voop == NULL || oopDesc::is_oop(voop),&quot;checking argument&quot;);
 367       new_value_h()-&gt;obj_field_put(field_offset, voop);
 368     }
<span class="line-modified"> 369   } else { // not T_OBJECT nor T_ARRAY nor T_INLINE_TYPE</span>
 370     intptr_t* addr = f.interpreter_frame_expression_stack_at(tos_idx);
 371     copy_primitive_argument(addr, new_value_h, field_offset, field_type);
 372   }
 373 
 374   // returning result
 375   thread-&gt;set_vm_result(new_value_h());
 376   return return_offset;
 377 JRT_END
 378 
 379 JRT_ENTRY(void, InterpreterRuntime::uninitialized_static_value_field(JavaThread* thread, oopDesc* mirror, int index))
 380   // The interpreter tries to access an inline static field that has not been initialized.
 381   // This situation can happen in different scenarios:
 382   //   1 - if the load or initialization of the field failed during step 8 of
 383   //       the initialization of the holder of the field, in this case the access to the field
 384   //       must fail
 385   //   2 - it can also happen when the initialization of the holder class triggered the initialization of
 386   //       another class which accesses this field in its static initializer, in this case the
 387   //       access must succeed to allow circularity
 388   // The code below tries to load and initialize the field&#39;s class again before returning the default value.
 389   // If the field was not initialized because of an error, a exception should be thrown.
</pre>
</td>
</tr>
</table>
<center><a href="../gc/g1/c2/g1BarrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateInterpreterGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
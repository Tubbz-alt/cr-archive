diff a/src/hotspot/share/runtime/signature.cpp b/src/hotspot/share/runtime/signature.cpp
--- a/src/hotspot/share/runtime/signature.cpp
+++ b/src/hotspot/share/runtime/signature.cpp
@@ -216,11 +216,11 @@
   int end = _end;
   int limit = _limit;
   const u1* tem;
   switch (type) {
   case T_OBJECT:
-  case T_VALUETYPE:
+  case T_INLINE_TYPE:
     tem = (const u1*) memchr(&base[end], JVM_SIGNATURE_ENDCLASS, limit - end);
     return (tem == NULL ? limit : tem + 1 - base);
 
   case T_ARRAY:
     while ((end < limit) && ((char)base[end] == JVM_SIGNATURE_ARRAY)) { end++; }
@@ -576,11 +576,11 @@
   }
 }
 
 // Inserts a reserved argument at position 'i'
 void SigEntry::insert_reserved_entry(GrowableArray<SigEntry>* sig, int i, BasicType bt) {
-  if (bt == T_OBJECT || bt == T_ARRAY || bt == T_VALUETYPE) {
+  if (bt == T_OBJECT || bt == T_ARRAY || bt == T_INLINE_TYPE) {
     // Treat this as INT to not confuse the GC
     bt = T_INT;
   } else if (bt == T_LONG || bt == T_DOUBLE) {
     // Longs and doubles take two stack slots
     sig->insert_before(i, SigEntry(T_VOID, SigEntry::ReservedOffset));
@@ -593,11 +593,11 @@
   return sig->at(i)._offset == SigEntry::ReservedOffset;
 }
 
 // Returns true if the argument at index 'i' is not a value type delimiter
 bool SigEntry::skip_value_delimiters(const GrowableArray<SigEntry>* sig, int i) {
-  return (sig->at(i)._bt != T_VALUETYPE &&
+  return (sig->at(i)._bt != T_INLINE_TYPE &&
           (sig->at(i)._bt != T_VOID || sig->at(i-1)._bt == T_LONG || sig->at(i-1)._bt == T_DOUBLE));
 }
 
 // Fill basic type array from signature array
 int SigEntry::fill_sig_bt(const GrowableArray<SigEntry>* sig, BasicType* sig_bt) {
@@ -617,11 +617,11 @@
   char* sig_str = NEW_RESOURCE_ARRAY(char, 2*length + 3);
   int idx = 0;
   sig_str[idx++] = '(';
   for (int i = 0; i < length; i++) {
     BasicType bt = sig->at(i)._bt;
-    if (bt == T_VALUETYPE || bt == T_VOID) {
+    if (bt == T_INLINE_TYPE || bt == T_VOID) {
       // Ignore
     } else {
       if (bt == T_ARRAY) {
         bt = T_OBJECT; // We don't know the element type, treat as Object
       }

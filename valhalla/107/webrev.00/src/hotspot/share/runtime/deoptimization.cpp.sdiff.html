<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/deoptimization.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../prims/jvmtiImpl.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldDescriptor.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/deoptimization.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1264     _klass = NULL;
1265   }
1266 };
1267 
1268 int compare(ReassignedField* left, ReassignedField* right) {
1269   return left-&gt;_offset - right-&gt;_offset;
1270 }
1271 
1272 // Restore fields of an eliminated instance object using the same field order
1273 // returned by HotSpotResolvedObjectTypeImpl.getInstanceFields(true)
1274 static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool skip_internal, int base_offset, TRAPS) {
1275 
1276   GrowableArray&lt;ReassignedField&gt;* fields = new GrowableArray&lt;ReassignedField&gt;();
1277   InstanceKlass* ik = klass;
1278   while (ik != NULL) {
1279     for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
1280       if (!fs.access_flags().is_static() &amp;&amp; (!skip_internal || !fs.access_flags().is_internal())) {
1281         ReassignedField field;
1282         field._offset = fs.offset();
1283         field._type = Signature::basic_type(fs.signature());
<span class="line-modified">1284         if (field._type == T_VALUETYPE) {</span>
1285           field._type = T_OBJECT;
1286         }
1287         if (fs.is_inlined()) {
1288           // Resolve klass of flattened value type field
1289           Klass* vk = klass-&gt;get_inline_type_field_klass(fs.index());
1290           field._klass = ValueKlass::cast(vk);
<span class="line-modified">1291           field._type = T_VALUETYPE;</span>
1292         }
1293         fields-&gt;append(field);
1294       }
1295     }
1296     ik = ik-&gt;superklass();
1297   }
1298   fields-&gt;sort(compare);
1299   for (int i = 0; i &lt; fields-&gt;length(); i++) {
1300     intptr_t val;
1301     ScopeValue* scope_field = sv-&gt;field_at(svIndex);
1302     StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);
1303     int offset = base_offset + fields-&gt;at(i)._offset;
1304     BasicType type = fields-&gt;at(i)._type;
1305     switch (type) {
1306       case T_OBJECT:
1307       case T_ARRAY:
1308         assert(value-&gt;type() == T_OBJECT, &quot;Agreement.&quot;);
1309         obj-&gt;obj_field_put(offset, value-&gt;get_obj()());
1310         break;
1311 
<span class="line-modified">1312       case T_VALUETYPE: {</span>
1313         // Recursively re-assign flattened value type fields
1314         InstanceKlass* vk = fields-&gt;at(i)._klass;
1315         assert(vk != NULL, &quot;must be resolved&quot;);
1316         offset -= ValueKlass::cast(vk)-&gt;first_field_offset(); // Adjust offset to omit oop header
1317         svIndex = reassign_fields_by_klass(vk, fr, reg_map, sv, svIndex, obj, skip_internal, offset, CHECK_0);
1318         continue; // Continue because we don&#39;t need to increment svIndex
1319       }
1320 
1321       // Have to cast to INT (32 bits) pointer to avoid little/big-endian problem.
1322       case T_INT: case T_FLOAT: { // 4 bytes.
1323         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1324         bool big_value = false;
1325         if (i+1 &lt; fields-&gt;length() &amp;&amp; fields-&gt;at(i+1)._type == T_INT) {
1326           if (scope_field-&gt;is_location()) {
1327             Location::Type type = ((LocationValue*) scope_field)-&gt;location().type();
1328             if (type == Location::dbl || type == Location::lng) {
1329               big_value = true;
1330             }
1331           }
1332           if (scope_field-&gt;is_constant_int()) {
</pre>
<hr />
<pre>
1381 
1382       case T_BOOLEAN:
1383         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1384         val = value-&gt;get_int();
1385         obj-&gt;bool_field_put(offset, (jboolean)*((jint*)&amp;val));
1386         break;
1387 
1388       default:
1389         ShouldNotReachHere();
1390     }
1391     svIndex++;
1392   }
1393   return svIndex;
1394 }
1395 
1396 // restore fields of an eliminated value type array
1397 void Deoptimization::reassign_value_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, valueArrayOop obj, ValueArrayKlass* vak, TRAPS) {
1398   ValueKlass* vk = vak-&gt;element_klass();
1399   assert(vk-&gt;flatten_array(), &quot;should only be used for flattened value type arrays&quot;);
1400   // Adjust offset to omit oop header
<span class="line-modified">1401   int base_offset = arrayOopDesc::base_offset_in_bytes(T_VALUETYPE) - ValueKlass::cast(vk)-&gt;first_field_offset();</span>
1402   // Initialize all elements of the flattened value type array
1403   for (int i = 0; i &lt; sv-&gt;field_size(); i++) {
1404     ScopeValue* val = sv-&gt;field_at(i);
1405     int offset = base_offset + (i &lt;&lt; Klass::layout_helper_log2_element_size(vak-&gt;layout_helper()));
1406     reassign_fields_by_klass(vk, fr, reg_map, val-&gt;as_ObjectValue(), 0, (oop)obj, false /* skip_internal */, offset, CHECK);
1407   }
1408 }
1409 
1410 // restore fields of all eliminated objects and arrays
1411 void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures, bool skip_internal, TRAPS) {
1412   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1413     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1414     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
1415     Handle obj = sv-&gt;value();
1416     assert(obj.not_null() || realloc_failures, &quot;reallocation was missed&quot;);
1417     if (PrintDeoptimizationDetails) {
1418       tty-&gt;print_cr(&quot;reassign fields for object of type %s!&quot;, k-&gt;name()-&gt;as_C_string());
1419     }
1420     if (obj.is_null()) {
1421       continue;
</pre>
</td>
<td>
<hr />
<pre>
1264     _klass = NULL;
1265   }
1266 };
1267 
1268 int compare(ReassignedField* left, ReassignedField* right) {
1269   return left-&gt;_offset - right-&gt;_offset;
1270 }
1271 
1272 // Restore fields of an eliminated instance object using the same field order
1273 // returned by HotSpotResolvedObjectTypeImpl.getInstanceFields(true)
1274 static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool skip_internal, int base_offset, TRAPS) {
1275 
1276   GrowableArray&lt;ReassignedField&gt;* fields = new GrowableArray&lt;ReassignedField&gt;();
1277   InstanceKlass* ik = klass;
1278   while (ik != NULL) {
1279     for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
1280       if (!fs.access_flags().is_static() &amp;&amp; (!skip_internal || !fs.access_flags().is_internal())) {
1281         ReassignedField field;
1282         field._offset = fs.offset();
1283         field._type = Signature::basic_type(fs.signature());
<span class="line-modified">1284         if (field._type == T_INLINE_TYPE) {</span>
1285           field._type = T_OBJECT;
1286         }
1287         if (fs.is_inlined()) {
1288           // Resolve klass of flattened value type field
1289           Klass* vk = klass-&gt;get_inline_type_field_klass(fs.index());
1290           field._klass = ValueKlass::cast(vk);
<span class="line-modified">1291           field._type = T_INLINE_TYPE;</span>
1292         }
1293         fields-&gt;append(field);
1294       }
1295     }
1296     ik = ik-&gt;superklass();
1297   }
1298   fields-&gt;sort(compare);
1299   for (int i = 0; i &lt; fields-&gt;length(); i++) {
1300     intptr_t val;
1301     ScopeValue* scope_field = sv-&gt;field_at(svIndex);
1302     StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);
1303     int offset = base_offset + fields-&gt;at(i)._offset;
1304     BasicType type = fields-&gt;at(i)._type;
1305     switch (type) {
1306       case T_OBJECT:
1307       case T_ARRAY:
1308         assert(value-&gt;type() == T_OBJECT, &quot;Agreement.&quot;);
1309         obj-&gt;obj_field_put(offset, value-&gt;get_obj()());
1310         break;
1311 
<span class="line-modified">1312       case T_INLINE_TYPE: {</span>
1313         // Recursively re-assign flattened value type fields
1314         InstanceKlass* vk = fields-&gt;at(i)._klass;
1315         assert(vk != NULL, &quot;must be resolved&quot;);
1316         offset -= ValueKlass::cast(vk)-&gt;first_field_offset(); // Adjust offset to omit oop header
1317         svIndex = reassign_fields_by_klass(vk, fr, reg_map, sv, svIndex, obj, skip_internal, offset, CHECK_0);
1318         continue; // Continue because we don&#39;t need to increment svIndex
1319       }
1320 
1321       // Have to cast to INT (32 bits) pointer to avoid little/big-endian problem.
1322       case T_INT: case T_FLOAT: { // 4 bytes.
1323         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1324         bool big_value = false;
1325         if (i+1 &lt; fields-&gt;length() &amp;&amp; fields-&gt;at(i+1)._type == T_INT) {
1326           if (scope_field-&gt;is_location()) {
1327             Location::Type type = ((LocationValue*) scope_field)-&gt;location().type();
1328             if (type == Location::dbl || type == Location::lng) {
1329               big_value = true;
1330             }
1331           }
1332           if (scope_field-&gt;is_constant_int()) {
</pre>
<hr />
<pre>
1381 
1382       case T_BOOLEAN:
1383         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1384         val = value-&gt;get_int();
1385         obj-&gt;bool_field_put(offset, (jboolean)*((jint*)&amp;val));
1386         break;
1387 
1388       default:
1389         ShouldNotReachHere();
1390     }
1391     svIndex++;
1392   }
1393   return svIndex;
1394 }
1395 
1396 // restore fields of an eliminated value type array
1397 void Deoptimization::reassign_value_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, valueArrayOop obj, ValueArrayKlass* vak, TRAPS) {
1398   ValueKlass* vk = vak-&gt;element_klass();
1399   assert(vk-&gt;flatten_array(), &quot;should only be used for flattened value type arrays&quot;);
1400   // Adjust offset to omit oop header
<span class="line-modified">1401   int base_offset = arrayOopDesc::base_offset_in_bytes(T_INLINE_TYPE) - ValueKlass::cast(vk)-&gt;first_field_offset();</span>
1402   // Initialize all elements of the flattened value type array
1403   for (int i = 0; i &lt; sv-&gt;field_size(); i++) {
1404     ScopeValue* val = sv-&gt;field_at(i);
1405     int offset = base_offset + (i &lt;&lt; Klass::layout_helper_log2_element_size(vak-&gt;layout_helper()));
1406     reassign_fields_by_klass(vk, fr, reg_map, val-&gt;as_ObjectValue(), 0, (oop)obj, false /* skip_internal */, offset, CHECK);
1407   }
1408 }
1409 
1410 // restore fields of all eliminated objects and arrays
1411 void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures, bool skip_internal, TRAPS) {
1412   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1413     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1414     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
1415     Handle obj = sv-&gt;value();
1416     assert(obj.not_null() || realloc_failures, &quot;reallocation was missed&quot;);
1417     if (PrintDeoptimizationDetails) {
1418       tty-&gt;print_cr(&quot;reassign fields for object of type %s!&quot;, k-&gt;name()-&gt;as_C_string());
1419     }
1420     if (obj.is_null()) {
1421       continue;
</pre>
</td>
</tr>
</table>
<center><a href="../prims/jvmtiImpl.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldDescriptor.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
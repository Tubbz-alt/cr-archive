<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arrayOop.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 139 
 140 static inline bool is_class_loader(const Symbol* class_name,
 141                                    const ClassFileParser&amp; parser) {
 142   assert(class_name != NULL, &quot;invariant&quot;);
 143 
 144   if (class_name == vmSymbols::java_lang_ClassLoader()) {
 145     return true;
 146   }
 147 
 148   if (SystemDictionary::ClassLoader_klass_loaded()) {
 149     const Klass* const super_klass = parser.super_klass();
 150     if (super_klass != NULL) {
 151       if (super_klass-&gt;is_subtype_of(SystemDictionary::ClassLoader_klass())) {
 152         return true;
 153       }
 154     }
 155   }
 156   return false;
 157 }
 158 
<span class="line-modified"> 159 bool InstanceKlass::field_is_inline_type(int index) const { return Signature::basic_type(field(index)-&gt;signature(constants())) == T_VALUETYPE; }</span>
 160 
 161 // private: called to verify that k is a static member of this nest.
 162 // We know that k is an instance class in the same package and hence the
 163 // same classloader.
 164 bool InstanceKlass::has_nest_member(InstanceKlass* k, TRAPS) const {
 165   assert(!is_hidden(), &quot;unexpected hidden class&quot;);
 166   if (_nest_members == NULL || _nest_members == Universe::the_empty_short_array()) {
 167     if (log_is_enabled(Trace, class, nestmates)) {
 168       ResourceMark rm(THREAD);
 169       log_trace(class, nestmates)(&quot;Checked nest membership of %s in non-nest-host class %s&quot;,
 170                                   k-&gt;external_name(), this-&gt;external_name());
 171     }
 172     return false;
 173   }
 174 
 175   if (log_is_enabled(Trace, class, nestmates)) {
 176     ResourceMark rm(THREAD);
 177     log_trace(class, nestmates)(&quot;Checking nest membership of %s in %s&quot;,
 178                                 k-&gt;external_name(), this-&gt;external_name());
 179   }
</pre>
<hr />
<pre>
 989 
 990 
 991   // Note:
 992   // Inline class types are loaded during
 993   // the loading phase (see ClassFileParser::post_process_parsed_stream()).
 994   // Inline class types used as element types for array creation
 995   // are not pre-loaded. Their loading is triggered by either anewarray
 996   // or multianewarray bytecodes.
 997 
 998   // Could it be possible to do the following processing only if the
 999   // class uses inline types?
1000   {
1001     ResourceMark rm(THREAD);
1002     for (int i = 0; i &lt; methods()-&gt;length(); i++) {
1003       Method* m = methods()-&gt;at(i);
1004       for (SignatureStream ss(m-&gt;signature()); !ss.is_done(); ss.next()) {
1005         if (ss.is_reference()) {
1006           if (ss.is_array()) {
1007             ss.skip_array_prefix();
1008           }
<span class="line-modified">1009           if (ss.type() == T_VALUETYPE) {</span>
1010             Symbol* symb = ss.as_symbol();
1011 
1012             oop loader = class_loader();
1013             oop protection_domain = this-&gt;protection_domain();
1014             Klass* klass = SystemDictionary::resolve_or_fail(symb,
1015                                                              Handle(THREAD, loader), Handle(THREAD, protection_domain), true,
1016                                                              CHECK_false);
1017             if (klass == NULL) {
1018               THROW_(vmSymbols::java_lang_LinkageError(), false);
1019             }
1020             if (!klass-&gt;is_inline_klass()) {
1021               Exceptions::fthrow(
1022                 THREAD_AND_LOCATION,
1023                 vmSymbols::java_lang_IncompatibleClassChangeError(),
1024                 &quot;class %s is not an inline type&quot;,
1025                 klass-&gt;external_name());
1026             }
1027           }
1028         }
1029       }
</pre>
<hr />
<pre>
1242 
1243     // If any exceptions, complete abruptly, throwing the same exception as above.
1244     if (HAS_PENDING_EXCEPTION) {
1245       Handle e(THREAD, PENDING_EXCEPTION);
1246       CLEAR_PENDING_EXCEPTION;
1247       {
1248         EXCEPTION_MARK;
1249         // Locks object, set state, and notify all waiting threads
1250         set_initialization_state_and_notify(initialization_error, THREAD);
1251         CLEAR_PENDING_EXCEPTION;
1252       }
1253       DTRACE_CLASSINIT_PROBE_WAIT(super__failed, -1, wait);
1254       THROW_OOP(e());
1255     }
1256   }
1257 
1258   // Step 8
1259   // Initialize classes of inline fields
1260   {
1261     for (AllFieldStream fs(this); !fs.done(); fs.next()) {
<span class="line-modified">1262       if (Signature::basic_type(fs.signature()) == T_VALUETYPE) {</span>
1263         Klass* klass = get_inline_type_field_klass_or_null(fs.index());
1264         if (fs.access_flags().is_static() &amp;&amp; klass == NULL) {
1265           klass = SystemDictionary::resolve_or_fail(field_signature(fs.index())-&gt;fundamental_name(THREAD),
1266               Handle(THREAD, class_loader()),
1267               Handle(THREAD, protection_domain()),
1268               true, CHECK);
1269           if (klass == NULL) {
1270             THROW(vmSymbols::java_lang_NoClassDefFoundError());
1271           }
1272           if (!klass-&gt;is_inline_klass()) {
1273             THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
1274           }
1275           set_inline_type_field_klass(fs.index(), klass);
1276         }
1277         InstanceKlass::cast(klass)-&gt;initialize(CHECK);
1278         if (fs.access_flags().is_static()) {
1279           if (java_mirror()-&gt;obj_field(fs.offset()) == NULL) {
1280             java_mirror()-&gt;obj_field_put(fs.offset(), ValueKlass::cast(klass)-&gt;default_value());
1281           }
1282         }
</pre>
<hr />
<pre>
2648 
2649   { // Otherwise this needs to take out the Compile_lock.
2650     assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);
2651     init_implementor();
2652   }
2653 
2654   constants()-&gt;remove_unshareable_info();
2655 
2656   for (int i = 0; i &lt; methods()-&gt;length(); i++) {
2657     Method* m = methods()-&gt;at(i);
2658     m-&gt;remove_unshareable_info();
2659   }
2660 
2661   // do array classes also.
2662   if (array_klasses() != NULL) {
2663     array_klasses()-&gt;remove_unshareable_info();
2664   }
2665 
2666   if (has_inline_type_fields()) {
2667     for (AllFieldStream fs(fields(), constants()); !fs.done(); fs.next()) {
<span class="line-modified">2668       if (Signature::basic_type(fs.signature()) == T_VALUETYPE) {</span>
2669         reset_inline_type_field_klass(fs.index());
2670       }
2671     }
2672   }
2673 
2674   // These are not allocated from metaspace. They are safe to set to NULL.
2675   _source_debug_extension = NULL;
2676   _dep_context = NULL;
2677   _osr_nmethods_head = NULL;
2678 #if INCLUDE_JVMTI
2679   _breakpoints = NULL;
2680   _previous_versions = NULL;
2681   _cached_class_file = NULL;
2682   _jvmti_cached_class_field_map = NULL;
2683 #endif
2684 
2685   _init_thread = NULL;
2686   _methods_jmethod_ids = NULL;
2687   _jni_ids = NULL;
2688   _oop_map_cache = NULL;
</pre>
</td>
<td>
<hr />
<pre>
 139 
 140 static inline bool is_class_loader(const Symbol* class_name,
 141                                    const ClassFileParser&amp; parser) {
 142   assert(class_name != NULL, &quot;invariant&quot;);
 143 
 144   if (class_name == vmSymbols::java_lang_ClassLoader()) {
 145     return true;
 146   }
 147 
 148   if (SystemDictionary::ClassLoader_klass_loaded()) {
 149     const Klass* const super_klass = parser.super_klass();
 150     if (super_klass != NULL) {
 151       if (super_klass-&gt;is_subtype_of(SystemDictionary::ClassLoader_klass())) {
 152         return true;
 153       }
 154     }
 155   }
 156   return false;
 157 }
 158 
<span class="line-modified"> 159 bool InstanceKlass::field_is_inline_type(int index) const { return Signature::basic_type(field(index)-&gt;signature(constants())) == T_INLINE_TYPE; }</span>
 160 
 161 // private: called to verify that k is a static member of this nest.
 162 // We know that k is an instance class in the same package and hence the
 163 // same classloader.
 164 bool InstanceKlass::has_nest_member(InstanceKlass* k, TRAPS) const {
 165   assert(!is_hidden(), &quot;unexpected hidden class&quot;);
 166   if (_nest_members == NULL || _nest_members == Universe::the_empty_short_array()) {
 167     if (log_is_enabled(Trace, class, nestmates)) {
 168       ResourceMark rm(THREAD);
 169       log_trace(class, nestmates)(&quot;Checked nest membership of %s in non-nest-host class %s&quot;,
 170                                   k-&gt;external_name(), this-&gt;external_name());
 171     }
 172     return false;
 173   }
 174 
 175   if (log_is_enabled(Trace, class, nestmates)) {
 176     ResourceMark rm(THREAD);
 177     log_trace(class, nestmates)(&quot;Checking nest membership of %s in %s&quot;,
 178                                 k-&gt;external_name(), this-&gt;external_name());
 179   }
</pre>
<hr />
<pre>
 989 
 990 
 991   // Note:
 992   // Inline class types are loaded during
 993   // the loading phase (see ClassFileParser::post_process_parsed_stream()).
 994   // Inline class types used as element types for array creation
 995   // are not pre-loaded. Their loading is triggered by either anewarray
 996   // or multianewarray bytecodes.
 997 
 998   // Could it be possible to do the following processing only if the
 999   // class uses inline types?
1000   {
1001     ResourceMark rm(THREAD);
1002     for (int i = 0; i &lt; methods()-&gt;length(); i++) {
1003       Method* m = methods()-&gt;at(i);
1004       for (SignatureStream ss(m-&gt;signature()); !ss.is_done(); ss.next()) {
1005         if (ss.is_reference()) {
1006           if (ss.is_array()) {
1007             ss.skip_array_prefix();
1008           }
<span class="line-modified">1009           if (ss.type() == T_INLINE_TYPE) {</span>
1010             Symbol* symb = ss.as_symbol();
1011 
1012             oop loader = class_loader();
1013             oop protection_domain = this-&gt;protection_domain();
1014             Klass* klass = SystemDictionary::resolve_or_fail(symb,
1015                                                              Handle(THREAD, loader), Handle(THREAD, protection_domain), true,
1016                                                              CHECK_false);
1017             if (klass == NULL) {
1018               THROW_(vmSymbols::java_lang_LinkageError(), false);
1019             }
1020             if (!klass-&gt;is_inline_klass()) {
1021               Exceptions::fthrow(
1022                 THREAD_AND_LOCATION,
1023                 vmSymbols::java_lang_IncompatibleClassChangeError(),
1024                 &quot;class %s is not an inline type&quot;,
1025                 klass-&gt;external_name());
1026             }
1027           }
1028         }
1029       }
</pre>
<hr />
<pre>
1242 
1243     // If any exceptions, complete abruptly, throwing the same exception as above.
1244     if (HAS_PENDING_EXCEPTION) {
1245       Handle e(THREAD, PENDING_EXCEPTION);
1246       CLEAR_PENDING_EXCEPTION;
1247       {
1248         EXCEPTION_MARK;
1249         // Locks object, set state, and notify all waiting threads
1250         set_initialization_state_and_notify(initialization_error, THREAD);
1251         CLEAR_PENDING_EXCEPTION;
1252       }
1253       DTRACE_CLASSINIT_PROBE_WAIT(super__failed, -1, wait);
1254       THROW_OOP(e());
1255     }
1256   }
1257 
1258   // Step 8
1259   // Initialize classes of inline fields
1260   {
1261     for (AllFieldStream fs(this); !fs.done(); fs.next()) {
<span class="line-modified">1262       if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE) {</span>
1263         Klass* klass = get_inline_type_field_klass_or_null(fs.index());
1264         if (fs.access_flags().is_static() &amp;&amp; klass == NULL) {
1265           klass = SystemDictionary::resolve_or_fail(field_signature(fs.index())-&gt;fundamental_name(THREAD),
1266               Handle(THREAD, class_loader()),
1267               Handle(THREAD, protection_domain()),
1268               true, CHECK);
1269           if (klass == NULL) {
1270             THROW(vmSymbols::java_lang_NoClassDefFoundError());
1271           }
1272           if (!klass-&gt;is_inline_klass()) {
1273             THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
1274           }
1275           set_inline_type_field_klass(fs.index(), klass);
1276         }
1277         InstanceKlass::cast(klass)-&gt;initialize(CHECK);
1278         if (fs.access_flags().is_static()) {
1279           if (java_mirror()-&gt;obj_field(fs.offset()) == NULL) {
1280             java_mirror()-&gt;obj_field_put(fs.offset(), ValueKlass::cast(klass)-&gt;default_value());
1281           }
1282         }
</pre>
<hr />
<pre>
2648 
2649   { // Otherwise this needs to take out the Compile_lock.
2650     assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);
2651     init_implementor();
2652   }
2653 
2654   constants()-&gt;remove_unshareable_info();
2655 
2656   for (int i = 0; i &lt; methods()-&gt;length(); i++) {
2657     Method* m = methods()-&gt;at(i);
2658     m-&gt;remove_unshareable_info();
2659   }
2660 
2661   // do array classes also.
2662   if (array_klasses() != NULL) {
2663     array_klasses()-&gt;remove_unshareable_info();
2664   }
2665 
2666   if (has_inline_type_fields()) {
2667     for (AllFieldStream fs(fields(), constants()); !fs.done(); fs.next()) {
<span class="line-modified">2668       if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE) {</span>
2669         reset_inline_type_field_klass(fs.index());
2670       }
2671     }
2672   }
2673 
2674   // These are not allocated from metaspace. They are safe to set to NULL.
2675   _source_debug_extension = NULL;
2676   _dep_context = NULL;
2677   _osr_nmethods_head = NULL;
2678 #if INCLUDE_JVMTI
2679   _breakpoints = NULL;
2680   _previous_versions = NULL;
2681   _cached_class_file = NULL;
2682   _jvmti_cached_class_field_map = NULL;
2683 #endif
2684 
2685   _init_thread = NULL;
2686   _methods_jmethod_ids = NULL;
2687   _jni_ids = NULL;
2688   _oop_map_cache = NULL;
</pre>
</td>
</tr>
</table>
<center><a href="arrayOop.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
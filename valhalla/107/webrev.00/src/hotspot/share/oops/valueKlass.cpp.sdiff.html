<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/valueKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="valueArrayOop.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/arraycopynode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/valueKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 91   // If bigger than 64 bits or needs oop alignment, then use jlong aligned
 92   // which for values should be jlong aligned, asserts in raw_field_copy otherwise
 93   if (heapOopAlignedSize &gt;= longSize || contains_oops()) {
 94     return heapOopAlignedSize;
 95   }
 96   // Small primitives...
 97   // If a few small basic type fields, return the actual size, i.e.
 98   // 1 byte = 1
 99   // 2 byte = 2
100   // 3 byte = 4, because pow2 needed for element stores
101   int first_offset = first_field_offset();
102   int last_offset  = 0; // find the last offset, add basic type size
103   int last_tsz     = 0;
104   for (AllFieldStream fs(this); !fs.done(); fs.next()) {
105     if (fs.access_flags().is_static()) {
106       continue;
107     } else if (fs.offset() &gt; last_offset) {
108       BasicType type = Signature::basic_type(fs.signature());
109       if (is_java_primitive(type)) {
110         last_tsz = type2aelembytes(type);
<span class="line-modified">111       } else if (type == T_VALUETYPE) {</span>
112         // Not just primitives. Layout aligns embedded value, so use jlong aligned it is
113         return heapOopAlignedSize;
114       } else {
115         guarantee(0, &quot;Unknown type %d&quot;, type);
116       }
117       assert(last_tsz != 0, &quot;Invariant&quot;);
118       last_offset = fs.offset();
119     }
120   }
121   // Assumes VT with no fields are meaningless and illegal
122   last_offset += last_tsz;
123   assert(last_offset &gt; first_offset &amp;&amp; last_tsz, &quot;Invariant&quot;);
124   return 1 &lt;&lt; upper_log2(last_offset - first_offset);
125 }
126 
127 instanceOop ValueKlass::allocate_instance(TRAPS) {
128   int size = size_helper();  // Query before forming handle.
129 
130   instanceOop oop = (instanceOop)Universe::heap()-&gt;obj_allocate(this, size, CHECK_NULL);
131   assert(oop-&gt;mark().is_always_locked(), &quot;Unlocked value type&quot;);
</pre>
<hr />
<pre>
261   InstanceKlass::array_klasses_do(f, THREAD);
262   if (get_value_array_klass() != NULL)
263     ArrayKlass::cast(get_value_array_klass())-&gt;array_klasses_do(f, THREAD);
264 }
265 
266 void ValueKlass::array_klasses_do(void f(Klass* k)) {
267   InstanceKlass::array_klasses_do(f);
268   if (get_value_array_klass() != NULL)
269     ArrayKlass::cast(get_value_array_klass())-&gt;array_klasses_do(f);
270 }
271 
272 // Value type arguments are not passed by reference, instead each
273 // field of the value type is passed as an argument. This helper
274 // function collects the inlined field (recursively)
275 // in a list. Included with the field&#39;s type is
276 // the offset of each field in the inline type: i2c and c2i adapters
277 // need that to load or store fields. Finally, the list of fields is
278 // sorted in order of increasing offsets: the adapters and the
279 // compiled code need to agree upon the order of fields.
280 //
<span class="line-modified">281 // The list of basic types that is returned starts with a T_VALUETYPE</span>
<span class="line-modified">282 // and ends with an extra T_VOID. T_VALUETYPE/T_VOID pairs are used as</span>
283 // delimiters. Every entry between the two is a field of the value
284 // type. If there&#39;s an embedded inline type in the list, it also starts
<span class="line-modified">285 // with a T_VALUETYPE and ends with a T_VOID. This is so we can</span>
286 // generate a unique fingerprint for the method&#39;s adapters and we can
287 // generate the list of basic types from the interpreter point of view
288 // (value types passed as reference: iterate on the list until a
<span class="line-modified">289 // T_VALUETYPE, drop everything until and including the closing</span>
290 // T_VOID) or the compiler point of view (each field of the value
<span class="line-modified">291 // types is an argument: drop all T_VALUETYPE/T_VOID from the list).</span>
292 int ValueKlass::collect_fields(GrowableArray&lt;SigEntry&gt;* sig, int base_off) {
293   int count = 0;
<span class="line-modified">294   SigEntry::add_entry(sig, T_VALUETYPE, base_off);</span>
295   for (AllFieldStream fs(this); !fs.done(); fs.next()) {
296     if (fs.access_flags().is_static()) continue;
297     int offset = base_off + fs.offset() - (base_off &gt; 0 ? first_field_offset() : 0);
298     if (fs.is_inlined()) {
299       // Resolve klass of inlined field and recursively collect fields
300       Klass* vk = get_inline_type_field_klass(fs.index());
301       count += ValueKlass::cast(vk)-&gt;collect_fields(sig, offset);
302     } else {
303       BasicType bt = Signature::basic_type(fs.signature());
<span class="line-modified">304       if (bt == T_VALUETYPE) {</span>
305         bt = T_OBJECT;
306       }
307       SigEntry::add_entry(sig, bt, offset);
308       count += type2size[bt];
309     }
310   }
311   int offset = base_off + size_helper()*HeapWordSize - (base_off &gt; 0 ? first_field_offset() : 0);
312   SigEntry::add_entry(sig, T_VOID, offset);
313   if (base_off == 0) {
314     sig-&gt;sort(SigEntry::compare);
315   }
<span class="line-modified">316   assert(sig-&gt;at(0)._bt == T_VALUETYPE &amp;&amp; sig-&gt;at(sig-&gt;length()-1)._bt == T_VOID, &quot;broken structure&quot;);</span>
317   return count;
318 }
319 
320 void ValueKlass::initialize_calling_convention(TRAPS) {
321   // Because the pack and unpack handler addresses need to be loadable from generated code,
322   // they are stored at a fixed offset in the klass metadata. Since value type klasses do
323   // not have a vtable, the vtable offset is used to store these addresses.
324   if (InlineTypeReturnedAsFields || InlineTypePassFieldsAsArgs) {
325     ResourceMark rm;
326     GrowableArray&lt;SigEntry&gt; sig_vk;
327     int nb_fields = collect_fields(&amp;sig_vk);
328     Array&lt;SigEntry&gt;* extended_sig = MetadataFactory::new_array&lt;SigEntry&gt;(class_loader_data(), sig_vk.length(), CHECK);
329     *((Array&lt;SigEntry&gt;**)adr_extended_sig()) = extended_sig;
330     for (int i = 0; i &lt; sig_vk.length(); i++) {
331       extended_sig-&gt;at_put(i, sig_vk.at(i));
332     }
333     if (can_be_returned_as_fields(/* init= */ true)) {
334       nb_fields++;
335       BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, nb_fields);
336       sig_bt[0] = T_METADATA;
</pre>
<hr />
<pre>
401   return InlineTypeReturnedAsFields &amp;&amp; is_scalarizable() &amp;&amp; !is_empty_inline_type() &amp;&amp; (init || return_regs() != NULL);
402 }
403 
404 // Create handles for all oop fields returned in registers that are going to be live across a safepoint
405 void ValueKlass::save_oop_fields(const RegisterMap&amp; reg_map, GrowableArray&lt;Handle&gt;&amp; handles) const {
406   Thread* thread = Thread::current();
407   const Array&lt;SigEntry&gt;* sig_vk = extended_sig();
408   const Array&lt;VMRegPair&gt;* regs = return_regs();
409   int j = 1;
410 
411   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
412     BasicType bt = sig_vk-&gt;at(i)._bt;
413     if (bt == T_OBJECT || bt == T_ARRAY) {
414       VMRegPair pair = regs-&gt;at(j);
415       address loc = reg_map.location(pair.first());
416       oop v = *(oop*)loc;
417       assert(v == NULL || oopDesc::is_oop(v), &quot;not an oop?&quot;);
418       assert(Universe::heap()-&gt;is_in_or_null(v), &quot;must be heap pointer&quot;);
419       handles.push(Handle(thread, v));
420     }
<span class="line-modified">421     if (bt == T_VALUETYPE) {</span>
422       continue;
423     }
424     if (bt == T_VOID &amp;&amp;
425         sig_vk-&gt;at(i-1)._bt != T_LONG &amp;&amp;
426         sig_vk-&gt;at(i-1)._bt != T_DOUBLE) {
427       continue;
428     }
429     j++;
430   }
431   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
432 }
433 
434 // Update oop fields in registers from handles after a safepoint
435 void ValueKlass::restore_oop_results(RegisterMap&amp; reg_map, GrowableArray&lt;Handle&gt;&amp; handles) const {
436   assert(InlineTypeReturnedAsFields, &quot;inconsistent&quot;);
437   const Array&lt;SigEntry&gt;* sig_vk = extended_sig();
438   const Array&lt;VMRegPair&gt;* regs = return_regs();
439   assert(regs != NULL, &quot;inconsistent&quot;);
440 
441   int j = 1;
442   for (int i = 0, k = 0; i &lt; sig_vk-&gt;length(); i++) {
443     BasicType bt = sig_vk-&gt;at(i)._bt;
444     if (bt == T_OBJECT || bt == T_ARRAY) {
445       VMRegPair pair = regs-&gt;at(j);
446       address loc = reg_map.location(pair.first());
447       *(oop*)loc = handles.at(k++)();
448     }
<span class="line-modified">449     if (bt == T_VALUETYPE) {</span>
450       continue;
451     }
452     if (bt == T_VOID &amp;&amp;
453         sig_vk-&gt;at(i-1)._bt != T_LONG &amp;&amp;
454         sig_vk-&gt;at(i-1)._bt != T_DOUBLE) {
455       continue;
456     }
457     j++;
458   }
459   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
460 }
461 
462 // Fields are in registers. Create an instance of the value type and
463 // initialize it with the values of the fields.
464 oop ValueKlass::realloc_result(const RegisterMap&amp; reg_map, const GrowableArray&lt;Handle&gt;&amp; handles, TRAPS) {
465   oop new_vt = allocate_instance(CHECK_NULL);
466   const Array&lt;SigEntry&gt;* sig_vk = extended_sig();
467   const Array&lt;VMRegPair&gt;* regs = return_regs();
468 
469   int j = 1;
470   int k = 0;
471   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
472     BasicType bt = sig_vk-&gt;at(i)._bt;
<span class="line-modified">473     if (bt == T_VALUETYPE) {</span>
474       continue;
475     }
476     if (bt == T_VOID) {
477       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||
478           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {
479         j++;
480       }
481       continue;
482     }
483     int off = sig_vk-&gt;at(i)._offset;
484     assert(off &gt; 0, &quot;offset in object should be positive&quot;);
485     VMRegPair pair = regs-&gt;at(j);
486     address loc = reg_map.location(pair.first());
487     switch(bt) {
488     case T_BOOLEAN: {
489       new_vt-&gt;bool_field_put(off, *(jboolean*)loc);
490       break;
491     }
492     case T_CHAR: {
493       new_vt-&gt;char_field_put(off, *(jchar*)loc);
</pre>
</td>
<td>
<hr />
<pre>
 91   // If bigger than 64 bits or needs oop alignment, then use jlong aligned
 92   // which for values should be jlong aligned, asserts in raw_field_copy otherwise
 93   if (heapOopAlignedSize &gt;= longSize || contains_oops()) {
 94     return heapOopAlignedSize;
 95   }
 96   // Small primitives...
 97   // If a few small basic type fields, return the actual size, i.e.
 98   // 1 byte = 1
 99   // 2 byte = 2
100   // 3 byte = 4, because pow2 needed for element stores
101   int first_offset = first_field_offset();
102   int last_offset  = 0; // find the last offset, add basic type size
103   int last_tsz     = 0;
104   for (AllFieldStream fs(this); !fs.done(); fs.next()) {
105     if (fs.access_flags().is_static()) {
106       continue;
107     } else if (fs.offset() &gt; last_offset) {
108       BasicType type = Signature::basic_type(fs.signature());
109       if (is_java_primitive(type)) {
110         last_tsz = type2aelembytes(type);
<span class="line-modified">111       } else if (type == T_INLINE_TYPE) {</span>
112         // Not just primitives. Layout aligns embedded value, so use jlong aligned it is
113         return heapOopAlignedSize;
114       } else {
115         guarantee(0, &quot;Unknown type %d&quot;, type);
116       }
117       assert(last_tsz != 0, &quot;Invariant&quot;);
118       last_offset = fs.offset();
119     }
120   }
121   // Assumes VT with no fields are meaningless and illegal
122   last_offset += last_tsz;
123   assert(last_offset &gt; first_offset &amp;&amp; last_tsz, &quot;Invariant&quot;);
124   return 1 &lt;&lt; upper_log2(last_offset - first_offset);
125 }
126 
127 instanceOop ValueKlass::allocate_instance(TRAPS) {
128   int size = size_helper();  // Query before forming handle.
129 
130   instanceOop oop = (instanceOop)Universe::heap()-&gt;obj_allocate(this, size, CHECK_NULL);
131   assert(oop-&gt;mark().is_always_locked(), &quot;Unlocked value type&quot;);
</pre>
<hr />
<pre>
261   InstanceKlass::array_klasses_do(f, THREAD);
262   if (get_value_array_klass() != NULL)
263     ArrayKlass::cast(get_value_array_klass())-&gt;array_klasses_do(f, THREAD);
264 }
265 
266 void ValueKlass::array_klasses_do(void f(Klass* k)) {
267   InstanceKlass::array_klasses_do(f);
268   if (get_value_array_klass() != NULL)
269     ArrayKlass::cast(get_value_array_klass())-&gt;array_klasses_do(f);
270 }
271 
272 // Value type arguments are not passed by reference, instead each
273 // field of the value type is passed as an argument. This helper
274 // function collects the inlined field (recursively)
275 // in a list. Included with the field&#39;s type is
276 // the offset of each field in the inline type: i2c and c2i adapters
277 // need that to load or store fields. Finally, the list of fields is
278 // sorted in order of increasing offsets: the adapters and the
279 // compiled code need to agree upon the order of fields.
280 //
<span class="line-modified">281 // The list of basic types that is returned starts with a T_INLINE_TYPE</span>
<span class="line-modified">282 // and ends with an extra T_VOID. T_INLINE_TYPE/T_VOID pairs are used as</span>
283 // delimiters. Every entry between the two is a field of the value
284 // type. If there&#39;s an embedded inline type in the list, it also starts
<span class="line-modified">285 // with a T_INLINE_TYPE and ends with a T_VOID. This is so we can</span>
286 // generate a unique fingerprint for the method&#39;s adapters and we can
287 // generate the list of basic types from the interpreter point of view
288 // (value types passed as reference: iterate on the list until a
<span class="line-modified">289 // T_INLINE_TYPE, drop everything until and including the closing</span>
290 // T_VOID) or the compiler point of view (each field of the value
<span class="line-modified">291 // types is an argument: drop all T_INLINE_TYPE/T_VOID from the list).</span>
292 int ValueKlass::collect_fields(GrowableArray&lt;SigEntry&gt;* sig, int base_off) {
293   int count = 0;
<span class="line-modified">294   SigEntry::add_entry(sig, T_INLINE_TYPE, base_off);</span>
295   for (AllFieldStream fs(this); !fs.done(); fs.next()) {
296     if (fs.access_flags().is_static()) continue;
297     int offset = base_off + fs.offset() - (base_off &gt; 0 ? first_field_offset() : 0);
298     if (fs.is_inlined()) {
299       // Resolve klass of inlined field and recursively collect fields
300       Klass* vk = get_inline_type_field_klass(fs.index());
301       count += ValueKlass::cast(vk)-&gt;collect_fields(sig, offset);
302     } else {
303       BasicType bt = Signature::basic_type(fs.signature());
<span class="line-modified">304       if (bt == T_INLINE_TYPE) {</span>
305         bt = T_OBJECT;
306       }
307       SigEntry::add_entry(sig, bt, offset);
308       count += type2size[bt];
309     }
310   }
311   int offset = base_off + size_helper()*HeapWordSize - (base_off &gt; 0 ? first_field_offset() : 0);
312   SigEntry::add_entry(sig, T_VOID, offset);
313   if (base_off == 0) {
314     sig-&gt;sort(SigEntry::compare);
315   }
<span class="line-modified">316   assert(sig-&gt;at(0)._bt == T_INLINE_TYPE &amp;&amp; sig-&gt;at(sig-&gt;length()-1)._bt == T_VOID, &quot;broken structure&quot;);</span>
317   return count;
318 }
319 
320 void ValueKlass::initialize_calling_convention(TRAPS) {
321   // Because the pack and unpack handler addresses need to be loadable from generated code,
322   // they are stored at a fixed offset in the klass metadata. Since value type klasses do
323   // not have a vtable, the vtable offset is used to store these addresses.
324   if (InlineTypeReturnedAsFields || InlineTypePassFieldsAsArgs) {
325     ResourceMark rm;
326     GrowableArray&lt;SigEntry&gt; sig_vk;
327     int nb_fields = collect_fields(&amp;sig_vk);
328     Array&lt;SigEntry&gt;* extended_sig = MetadataFactory::new_array&lt;SigEntry&gt;(class_loader_data(), sig_vk.length(), CHECK);
329     *((Array&lt;SigEntry&gt;**)adr_extended_sig()) = extended_sig;
330     for (int i = 0; i &lt; sig_vk.length(); i++) {
331       extended_sig-&gt;at_put(i, sig_vk.at(i));
332     }
333     if (can_be_returned_as_fields(/* init= */ true)) {
334       nb_fields++;
335       BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, nb_fields);
336       sig_bt[0] = T_METADATA;
</pre>
<hr />
<pre>
401   return InlineTypeReturnedAsFields &amp;&amp; is_scalarizable() &amp;&amp; !is_empty_inline_type() &amp;&amp; (init || return_regs() != NULL);
402 }
403 
404 // Create handles for all oop fields returned in registers that are going to be live across a safepoint
405 void ValueKlass::save_oop_fields(const RegisterMap&amp; reg_map, GrowableArray&lt;Handle&gt;&amp; handles) const {
406   Thread* thread = Thread::current();
407   const Array&lt;SigEntry&gt;* sig_vk = extended_sig();
408   const Array&lt;VMRegPair&gt;* regs = return_regs();
409   int j = 1;
410 
411   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
412     BasicType bt = sig_vk-&gt;at(i)._bt;
413     if (bt == T_OBJECT || bt == T_ARRAY) {
414       VMRegPair pair = regs-&gt;at(j);
415       address loc = reg_map.location(pair.first());
416       oop v = *(oop*)loc;
417       assert(v == NULL || oopDesc::is_oop(v), &quot;not an oop?&quot;);
418       assert(Universe::heap()-&gt;is_in_or_null(v), &quot;must be heap pointer&quot;);
419       handles.push(Handle(thread, v));
420     }
<span class="line-modified">421     if (bt == T_INLINE_TYPE) {</span>
422       continue;
423     }
424     if (bt == T_VOID &amp;&amp;
425         sig_vk-&gt;at(i-1)._bt != T_LONG &amp;&amp;
426         sig_vk-&gt;at(i-1)._bt != T_DOUBLE) {
427       continue;
428     }
429     j++;
430   }
431   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
432 }
433 
434 // Update oop fields in registers from handles after a safepoint
435 void ValueKlass::restore_oop_results(RegisterMap&amp; reg_map, GrowableArray&lt;Handle&gt;&amp; handles) const {
436   assert(InlineTypeReturnedAsFields, &quot;inconsistent&quot;);
437   const Array&lt;SigEntry&gt;* sig_vk = extended_sig();
438   const Array&lt;VMRegPair&gt;* regs = return_regs();
439   assert(regs != NULL, &quot;inconsistent&quot;);
440 
441   int j = 1;
442   for (int i = 0, k = 0; i &lt; sig_vk-&gt;length(); i++) {
443     BasicType bt = sig_vk-&gt;at(i)._bt;
444     if (bt == T_OBJECT || bt == T_ARRAY) {
445       VMRegPair pair = regs-&gt;at(j);
446       address loc = reg_map.location(pair.first());
447       *(oop*)loc = handles.at(k++)();
448     }
<span class="line-modified">449     if (bt == T_INLINE_TYPE) {</span>
450       continue;
451     }
452     if (bt == T_VOID &amp;&amp;
453         sig_vk-&gt;at(i-1)._bt != T_LONG &amp;&amp;
454         sig_vk-&gt;at(i-1)._bt != T_DOUBLE) {
455       continue;
456     }
457     j++;
458   }
459   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
460 }
461 
462 // Fields are in registers. Create an instance of the value type and
463 // initialize it with the values of the fields.
464 oop ValueKlass::realloc_result(const RegisterMap&amp; reg_map, const GrowableArray&lt;Handle&gt;&amp; handles, TRAPS) {
465   oop new_vt = allocate_instance(CHECK_NULL);
466   const Array&lt;SigEntry&gt;* sig_vk = extended_sig();
467   const Array&lt;VMRegPair&gt;* regs = return_regs();
468 
469   int j = 1;
470   int k = 0;
471   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
472     BasicType bt = sig_vk-&gt;at(i)._bt;
<span class="line-modified">473     if (bt == T_INLINE_TYPE) {</span>
474       continue;
475     }
476     if (bt == T_VOID) {
477       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||
478           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {
479         j++;
480       }
481       continue;
482     }
483     int off = sig_vk-&gt;at(i)._offset;
484     assert(off &gt; 0, &quot;offset in object should be positive&quot;);
485     VMRegPair pair = regs-&gt;at(j);
486     address loc = reg_map.location(pair.first());
487     switch(bt) {
488     case T_BOOLEAN: {
489       new_vt-&gt;bool_field_put(off, *(jboolean*)loc);
490       break;
491     }
492     case T_CHAR: {
493       new_vt-&gt;char_field_put(off, *(jchar*)loc);
</pre>
</td>
</tr>
</table>
<center><a href="valueArrayOop.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/arraycopynode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
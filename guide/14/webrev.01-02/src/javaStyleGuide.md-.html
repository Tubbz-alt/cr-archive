<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/javaStyleGuide.md</title>
    <link rel="stylesheet" href="../style.css" />
  </head>
  <body>
    <pre>
   1 % Java Style Guide
   2 
   3 ::: {.NavBit}
   4 [« Previous](mailinglists.html) • [TOC](index.html) • [Next »](changePlanning.html)
   5 :::
   6 
   7 While this section covers a lot of ground, it should be noted that no style guide can answer all questions for us, and developers will always need to use good judgment towards the end of producing code that is correct, readable, maintainable, debuggable, consistently formatted, and aesthetically pleasing.
   8 
   9 Examples in this section are non-normative; While they intend to illustrate correct way of formatting the code, there may be other ways to correctly format the code. This is a general principle: There may be several ways to format the code, all adhering to the guidelines in this section.
  10 
  11 Tool support is nice, but ultimately each IDE and style checking tool can handle different sets of rules, and support for rules that can’t be handled today might be added in future versions. So, whether a rule plays well with tools or not can be a factor, but it’s secondary to the above principles.
  12 
  13 ## Overview
  14 
  15 - [Java Source Files](#java-source-files)  
  16   - [Special Characters](#special-characters)  
  17 - [Formatting](#formatting)  
  18   - [Copyright notice](#copyright-notice)  
  19   - [Package declaration](#package-declaration)  
  20   - [Import statements](#import-statements)  
  21   - [Class Structure](#class-structure)  
  22   - [Modifiers](#modifiers)  
  23   - [Braces](#braces)  
  24   - [Indentation](#indentation)  
  25   - [Wrapping Lines](#wrapping-lines)  
  26   - [Whitespace](#whitespace)  
  27   - [Variable Declarations](#variable-declarations)  
  28   - [Annotations](#annotations)  
  29   - [Lambda Expressions](#lambda-expressions)  
  30   - [Redundant Parentheses](#redundant-parentheses)  
  31   - [Literals](#literals)  
  32   - [Javadoc](#javadoc)  
  33 - [Naming](#naming)  
  34   - [Package Names](#package-names)  
  35   - [Class, Interface and Enum Names](#class-interface-and-enum-names)  
  36   - [Method Names](#method-names)  
  37   - [Variables](#variables)  
  38   - [Type Variables](#type-variables)  
  39   - [Constants](#constants)  
  40 - [Programming Practices](#programming-practices)  
  41   - [Commenting Code](#commenting-code)  
  42 - [When to reformat code](#when-to-reformat-code)  
  43 - [Cases not covered](#cases-not-covered)  
  44 
  45 ## Java Source Files
  46 This section concerns ordinary `.java` files only. Rules do not necessarily apply to other source files such as `.jasm`, `.sh` or `.gmk`.
  47 
  48 ::: conventions
  49 - Source files must be encoded in 7-bit ASCII.
  50 - All lines must be terminated with a line feed character (`LF`, ASCII value 10) and *not* for instance `CR` or `CR`+`LF`.
  51 - There may be no trailing white space at the end of a line.
  52 - The name of a source file must equal the name of the class it contains followed by the `.java` extension, even for files that only contain a package private class. This does not apply to files that do not contain any class declarations, such as `package-info.java`.
  53 :::
  54 
  55 ::: box
  56 [Motivation]{.boxheader}
  57 7-bit ASCII reduces errors due to confusion of characters since there are no invisible spaces, characters that look like minus signs but are really dashes, etc. It also ensures packages and classes are named in such way that the corresponding directories and source files are portable across different filesystems.
  58   
  59 Agreeing on a common line delimiter character is important since different operating systems have different defaults. Editing a file on Windows that was originally written on Linux, may cause all `LF` to be saved back as `CR`+`LF`. This creates unnecessarily big patches and may not display correctly in the text editor it was originally written in. A single line feed character is default for Unix-like systems and supported by all common text editors and IDEs.
  60 
  61 Trailing white space is nothing but unnecessary cruft. It’s easy to remove and agreeing on doing so consistently minimizes diffs.
  62 
  63 Not using the name of the class as filename can be confusing. Also, unless the file is given explicitly to the compiler, the class it contains may not be resolved correctly.
  64 :::
  65 
  66 ### Special Characters
  67 ::: conventions
  68 - Apart from `LF` the only allowed white space character is Space (ASCII value 32). Note that this implies that other white space characters (in, for instance, string and character literals) must be written in escaped form.
  69 - `\&#39;`, `\&quot;`, `\\`, `\t`, `\b`, `\r`, `\f`, and `\n` should be preferred over corresponding octal (e.g. `\047`) or Unicode (e.g. `\u0027`) escaped characters.
  70 - Should there be a need to go against the above rules for the sake of testing, the test should generate the required source.
  71 :::
  72 
  73 ::: box
  74 [Motivation]{.boxheader}
  75 Having any white space character but space and `LF` in the source code can be a source of confusion.
  76 
  77 The short forms (e.g. `\t`) are commonly used and easier to recognize than the corresponding longer forms (`\011`, `\u0009`).
  78 :::
  79 
  80 ## Formatting
  81 ::: conventions
  82 - A Java source file should be structured as follows:
  83   1. The copyright notice
  84   1. Package declaration
  85   1. Import statements
  86   1. Class declaration
  87 - There may be only one top level class declaration per file.
  88 :::
  89 
  90 ### Copyright notice
  91 ::: conventions
  92 - All source files should have an appropriate copyright notice at the top of the file.
  93 
  94 - For files under Oracle copyright, the copyright notice must follow the standard wording and format. In particular the first two lines should be
  95 
  96   ~~~java
  97   /*
  98    * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
  99   ~~~
 100 
 101   or
 102 
 103   ~~~java
 104   /*
 105    * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
 106   ~~~
 107 
 108   where the first year is the year the file was created and the second year is the year the file was last edited.
 109 :::
 110 
 111 For questions regarding Oracle copyright or license notices, please contact [iris.clark@oracle.com](mailto:iris.clark@oracle.com).
 112 
 113 ### Package declaration
 114 ::: conventions
 115 - The package declaration should not be line wrapped, regardless of whether it exceeds the recommended maximum length of a line. (See section on [Wrapping Lines](#wrapping-lines).)
 116 :::
 117 
 118 ### Import statements
 119 ::: conventions
 120 - Import statements should be sorted…
 121   - …primarily by non-static / static with non-static imports first.
 122   - …secondarily by package origin according to the following order
 123     - `java` packages
 124     - `javax` packages
 125     - external packages (e.g. `org.xml`)
 126     - internal packages (e.g. `com.sun`)
 127   - …tertiary by package and class identifier in lexicographical order
 128 - Import statements should not be line wrapped, regardless of whether it exceeds the recommended maximum length of a line.
 129 - No unused imports should be present.
 130 :::
 131 
 132 #### Wildcard Imports
 133 ::: conventions
 134 - Wildcard imports should in general not be used.
 135 - When importing a large number of closely-related classes (such as implementing a visitor over a tree with dozens of distinct “node” classes), a wildcard import may be used.
 136 - In any case, no more than one wildcard import per file should be used.
 137 :::
 138 
 139 ::: box
 140 [Motivation]{.boxheader}
 141 Wildcard imports makes it unclear what actually needs to be imported.
 142 
 143 Having more than one wildcard import makes the code fragile since adding a new class in one of the imported packages can introduce a name clash.
 144 
 145 An unused import gives a false impression of a dependency. Also, many IDEs list such import statements as warnings which clutters the list of problems.
 146 :::
 147 
 148 ### Class Structure
 149 ::: conventions
 150 - The recommended order of class members is the following:
 151   1. Fields
 152   1. Constructors
 153   1. Factory methods
 154   1. Other Methods
 155 - Related fields should be grouped together. Ordering fields primarily according to access modifiers or identifier is not required. The same applies to methods.
 156 - Nested types should be grouped at the top of the class, or else defined before first use.
 157 :::
 158 
 159 #### Order of Constructors and Overloaded Methods
 160 ::: conventions
 161 - Constructors and overloaded methods should be grouped together by functionality and ordered with increasing arity. This implies that delegation among these constructs flow downward in the code.
 162 - Constructors and overloaded methods should generally not be split apart by other members.
 163 :::
 164 
 165 ::: leftcol
 166 ::: box
 167 [Dos]{.boxheader .dos}
 168 
 169 ~~~java
 170 public HashSet() {
 171     this(DEFAULT_INITIAL_CAPACITY);
 172 }
 173 
 174 public HashSet(int capacity) {
 175     this(capacity, DEFAULT_LOAD_FACTOR);
 176 }
 177 
 178 public HashSet(int capacity, double loadFactor) {
 179     …
 180 }
 181 ~~~
 182 
 183 :::
 184 :::
 185 
 186 ::: rightcol
 187 ::: box
 188 [Don’ts]{.boxheader .donts}
 189 
 190 ~~~java
 191 // Overloaded methods should not be split apart
 192 void logValue(int i) {
 193     log(&quot;Int: %d&quot;, i);
 194 }
 195 
 196 void setValue(int i) {
 197     val = i;
 198 }
 199 
 200 void logValue(double d) {
 201     log(&quot;Double: %.2d&quot;, d);
 202 }
 203 
 204 void setValue(double d) {
 205     val = d;
 206 }
 207 ~~~
 208 
 209 :::
 210 :::
 211 
 212 ::: box
 213 [Motivation]{.boxheader}
 214 This order puts the most generally applicable versions first. Also, making sure delegation is always done downwards in the file makes the code easier to follow.
 215 :::
 216 
 217 ### Modifiers
 218 ::: conventions
 219 - Modifiers should go in the following order
 220   1. Access modifier (`public` / `private` / `protected`)
 221   1. `abstract`
 222   1. `static`
 223   1. `final`
 224   1. `transient`
 225   1. `volatile`
 226   1. `default`
 227   1. `synchronized`
 228   1. `native`
 229   1. `strictfp`
 230 - Modifiers should not be written out when they are implicit. For example, interface methods should neither be declared public nor abstract, and nested enums and interfaces should not be declared static.
 231 - Method parameters and local variables should not be declared final unless it improves readability or documents an actual design decision.
 232 - Fields should be declared final unless there is a compelling reason to make them mutable.
 233 :::
 234 
 235 ::: box
 236 [Motivation]{.boxheader}
 237 Writing out modifiers where they are implicit clutters the code and learning which modifiers are implicit where is easy.
 238 
 239 Although method parameters should typically not be mutated, consistently marking all parameters in every methods as `final` is an exaggeration.
 240 
 241 Making fields immutable where possible is good programming practice. Refer to *Effective Java, Item 15: Minimize Mutability* for details.
 242 :::
 243 
 244 ### Braces
 245 ::: conventions
 246 - Opening braces should be put on the end of the current line rather than on a line by its own.
 247 - There should be a new line in front of a closing brace unless the block is empty (see [Short Forms](#short-forms) below)
 248 - Braces are recommended even where the language makes them optional, such as single-line if and loop bodies.
 249   - If a block spans more than one line (including comments) it must have braces.
 250   - If one of the blocks in a if / else statement has braces, the other block must too.
 251   - If the block comes last in an enclosing block, it must have braces.
 252 - The `else`,&amp;nbsp;`catch` and the `while` keyword in `do`…`while` loops go on the same line as the closing brace of the preceding block.
 253 :::
 254 
 255 ::: leftcol
 256 ::: box
 257 [Dos]{.boxheader .dos}
 258 
 259 ~~~java
 260 void method() {
 261     …
 262 }
 263 ~~~
 264 
 265 ~~~java
 266 try {
 267     something();
 268 } catch (AnException e) {
 269     …
 270 }
 271 ~~~
 272 
 273 ~~~java
 274 for (int[] row : matrix) {
 275     for (int val : row) {
 276         sum += val;
 277     }
 278 }
 279 ~~~
 280 
 281 :::
 282 :::
 283 
 284 ::: rightcol
 285 ::: box
 286 [Don’ts]{.boxheader .donts}
 287 
 288 ~~~java
 289 // Wrong placement of opening brace
 290 void method()
 291 {
 292     …
 293 }
 294 ~~~
 295 
 296 ~~~java
 297 // Newline in front of catch should be avoided
 298 try {
 299     something();
 300 }
 301 catch (AnException e) {
 302     …
 303 }
 304 ~~~
 305 
 306 ~~~java
 307 // Braces should be used
 308 if (flag)
 309     // Restore x
 310     x = 1;
 311 ~~~
 312 
 313 ~~~java
 314 // Use braces if block comes last in enclosing block
 315 // to avoid accidentally indenting the closing brace.
 316 for (int[] row : matrix) {
 317     for (int val : row)
 318         sum += val;
 319 }
 320 ~~~
 321 
 322 :::
 323 :::
 324 
 325 ::: box
 326 [Motivation]{.boxheader}
 327 Putting opening braces on the end of the line (as opposed to on a line of its own) is a long standing Java convention. This style is also suitable for Java, considering that it’s common to have small blocks (in for instance anonymous classes and lambda expressions) and having opening braces on a separate line creates an unnecessary amount of white space in such situations.
 328 
 329 Omitting braces is error prone and can lead to mistakes in the indentation and hard to detect bugs.
 330 :::
 331 
 332 #### Short Forms
 333 ::: conventions
 334 - The above recommendations are intended to improve uniformity (and thus increase familiarity / readability). In some cases “short forms” that deviate from the above guidelines are just as readable and may be used instead. These cases include for instance simple enum declarations and trivial methods and lambda expressions.
 335 :::
 336 
 337 
 338 ::: leftcol
 339 ::: box
 340 [Dos]{.boxheader .dos}
 341 
 342 ~~~java
 343 enum Response { YES, NO, MAYBE }
 344 ~~~
 345 
 346 ~~~java
 347 public boolean isReference() { return true; }
 348 ~~~
 349 
 350 :::
 351 :::
 352 
 353 ::: rightcol
 354 ::: box
 355 [Don’ts]{.boxheader .donts}
 356 
 357 ~~~java
 358 public boolean getResult() { int value = getValue(); return value &lt; 0 ? 0 : value; }
 359 ~~~
 360 
 361 ~~~java
 362 for (int i = 0; i &lt; size; i++) { sum += data[i]; }
 363 ~~~
 364 
 365 :::
 366 :::
 367 
 368 
 369 ### Indentation
 370 ::: conventions
 371 - Indentation level is four spaces.
 372 - Only space characters may be used for indentation. No tabs.
 373 - Empty lines must not be indented. (This is implied by the no trailing white space rule.)
 374 - `case` lines should be indented with four spaces, and statements within the case should be indented with another four spaces.
 375 :::
 376 Refer to Section&amp;nbsp;[Wrapping Lines](#wrapping-lines)&amp;nbsp;for guidelines on how to indent continuation lines.
 377 
 378 ::: leftcol
 379 ::: box
 380 [Dos]{.boxheader .dos}
 381 
 382 ~~~java
 383 switch (var) {
 384     case TWO:
 385         setChoice(&quot;two&quot;);
 386         break;
 387     case THREE:
 388         setChoice(&quot;three&quot;);
 389         break;
 390     default:
 391         throw new IllegalArgumentException();
 392 }
 393 ~~~
 394 
 395 :::
 396 :::
 397 
 398 ::: rightcol
 399 ::: box
 400 [Don’ts]{.boxheader .donts}
 401 
 402 ~~~java
 403 switch (var) {
 404 case TWO:
 405     setChoice(&quot;two&quot;);
 406     break;
 407 case THREE:
 408     setChoice(&quot;three&quot;);
 409     break;
 410 default:
 411     throw new IllegalArgumentException();
 412 }
 413 ~~~
 414 
 415 :::
 416 :::
 417 
 418 
 419 ::: box
 420 [Motivation]{.boxheader}
 421 By using spaces for indentation, problems regarding different default settings for tab stops in various editors are avoided.
 422 :::
 423 
 424 ### Wrapping Lines
 425 ::: conventions
 426 - Source code and comments should generally not exceed 80 characters per line and rarely if ever exceed 100 characters per line, including indentation.
 427 
 428   ::: box
 429   ::: boxheader
 430   Note
 431   :::
 432   The character limit must be judged on a case by case basis. What really matters is the semantical “density” and readability of the line. Making lines gratuitously long makes them hard to read; similarly, making “heroic attempts” to fit them into 80 columns can also make them hard to read. The flexibility outlined here aims to enable developers to avoid these extremes, not to maximize use of monitor real-estate.
 433   :::
 434 
 435   ::: leftcol
 436   ::: box
 437   ::: {.boxheader .dos}
 438   Dos
 439   :::
 440   
 441   ~~~java
 442   // Ok even though it might exceed the character limit when indented.
 443   Error e = isTypeParam
 444           ? Errors.InvalidRepeatableAnnotationNotApplicable(targetContainerType, on)
 445           : Errors.InvalidRepeatableAnnotationNotApplicableInContext(targetContainerType));
 446   ~~~
 447   
 448   ~~~java
 449   String pretty = Stream.of(args)
 450                         .map(Argument::prettyPrint)
 451                         .collectors(joining(&quot;, &quot;));
 452   ~~~
 453 
 454   :::
 455   :::
 456 
 457   ::: rightcol
 458   ::: box
 459   ::: {.boxheader .donts}
 460   Don’ts
 461   :::
 462 
 463   ~~~java
 464   // Too strict interpretation of the character limit. Readability suffers.
 465   Error e = isTypeParam
 466         ? Errors.InvalidRepeatableAnnotationNotApplicable(
 467                 targetContainerType, on)
 468         : Errors.InvalidRepeatableAnnotationNotApplicableInContext(
 469                 targetContainerType);
 470   ~~~
 471 
 472   ~~~java
 473   // Should be wrapped even though it fits within the character limit
 474   String pretty = Stream.of(args).map(Argument::prettyPrint).collectors(joining(&quot;, &quot;));
 475   ~~~
 476 
 477   :::
 478   :::
 479 
 480   ::: clear-floats
 481   :::
 482 
 483 - URLs or example commands should not be wrapped.
 484 - Wrapping at a higher syntactical level is preferred over wrapping at a lower syntactical level.
 485 
 486   ::: leftcol
 487   ::: box
 488   ::: {.boxheader .dos}
 489   Dos
 490   :::
 491 
 492   ~~~java
 493   aMethodCall(withMany(arguments, that, needs),
 494           to(be, (wrapped - to) * avoid / veryLong - lines));
 495   ~~~
 496 
 497   :::
 498   :::
 499 
 500   ::: rightcol
 501   ::: box
 502   ::: {.boxheader .donts}
 503   Don’ts
 504   :::
 505 
 506   ~~~java
 507   aMethodCall(withMany(arguments, that, needs), to(be, (wrapped
 508           - to) * avoid / veryLong - lines));
 509   ~~~
 510 
 511   :::
 512   :::
 513 
 514   ::: clear-floats
 515   :::
 516 
 517 - There should be at most 1 statement per line.
 518 
 519   ::: leftcol
 520   ::: box
 521   ::: {.boxheader .dos}
 522   Dos
 523   :::
 524 
 525   ~~~java
 526   i += j;
 527   j += k;
 528   ~~~
 529 
 530   ~~~java
 531   if (condition) {
 532       return expression;
 533   }
 534   ~~~
 535 
 536   :::
 537   :::
 538 
 539   ::: rightcol
 540   ::: box
 541   ::: {.boxheader .donts}
 542   Don’ts
 543   :::
 544 
 545   ~~~java
 546   i += j; j += k;
 547   ~~~
 548 
 549   ~~~java
 550   if (condition) { return expression; }
 551   ~~~
 552 
 553   :::
 554   :::
 555 
 556   ::: clear-floats
 557   :::
 558 
 559 - A continuation line should be indented in one of the following four ways
 560   - **Variant 1:** With 8 extra spaces relative to the indentation of the previous line.
 561   - **Variant 2:** With 8 extra spaces relative to the starting column of the wrapped expression.
 562   - **Variant 3:** Aligned with previous sibling expression (as long as it is clear that it’s a continuation line)
 563   - **Variant 4:** Aligned with previous method call in a chained expression.
 564 
 565   ::: leftcol
 566   ::: box
 567   ::: {.boxheader .dos}
 568   Dos
 569   :::
 570 
 571   ~~~java
 572   // Variant 1
 573   int anInteger = aMethod(that, takes,
 574           a, lengthy, list, of, arguments);
 575   ~~~
 576 
 577   ~~~java
 578   // Variant 2
 579   int anInteger = that * (is + computed) / using
 580                           + a * complex - expression;
 581   ~~~
 582 
 583   ~~~java
 584   // Variant 3
 585   int anInteger = aMethod(thatTakes,
 586                           aLongList,
 587                           ofArguments);
 588   ~~~
 589 
 590   ~~~java
 591   // Variant 4
 592   int anInteger = IntStream.of(numbers)
 593                            .map(Math::sqrt)
 594                            .sum();
 595   ~~~
 596 
 597   :::
 598   :::
 599 
 600   ::: rightcol
 601   ::: box
 602   ::: {.boxheader .donts}
 603   Don’ts
 604   :::
 605 
 606   ~~~java
 607   // Mixing of wrapping variants (unless there
 608   // is a logical grouping of arguments)
 609   int anInteger = aMethod(that,
 610                           takes,
 611                           a, lengthy, list,
 612                           of, arguments);
 613   ~~~
 614 
 615   ~~~java
 616   // Don&#39;t align with sibling expression if the
 617   // continuation line can be confused with a block
 618   // indentation
 619   if (somePredicate() ||
 620       someOtherPredicate()) {
 621       System.out.println(&quot;Avoid&quot;);
 622   }
 623   ~~~
 624 
 625   :::
 626   :::
 627 
 628   ::: clear-floats
 629   :::
 630 :::
 631 
 632 #### Wrapping Class Declarations
 633 ::: conventions
 634 - A class header should not be wrapped unless it approaches the maximum column limit.
 635 - If it does, it may be wrapped before `extends` and/or `implements` keywords.
 636 - Declarations of type parameters may, if necessary, be wrapped the same way as method arguments
 637 :::
 638 
 639 ::: leftcol
 640 ::: box
 641 [Dos]{.boxheader .dos}
 642 
 643 ~~~java
 644 public class MyGenericClass&lt;T, S&gt;
 645         extends HashMap&lt;T, S&gt;
 646         implements Comparable&lt;T&gt; {
 647     …
 648 }
 649 ~~~
 650 
 651 ~~~java
 652 public class AnotherClass&lt;K, R&gt; implements Collector&lt;T extends K,
 653                                                      Set&lt;? extends R&gt;,
 654                                                      List&lt;R&gt;&gt; {
 655     …
 656 }
 657 ~~~
 658 
 659 ~~~java
 660 public class AnotherClass&lt;K, R&gt; implements Collector&lt;T extends K,
 661                                                      Set&lt;? extends R&gt;,
 662                                                      List&lt;R&gt;&gt; {
 663     …
 664 }
 665 ~~~
 666 
 667 :::
 668 :::
 669 
 670 ::: rightcol
 671 ::: box
 672 [Don’ts]{.boxheader .donts}
 673 
 674 ~~~java
 675 public class MyGenericClass&lt;T&gt; implements Comparable&lt;T&gt;,
 676         Predicate&lt;T&gt; {
 677     …
 678 }
 679 ~~~
 680 
 681 :::
 682 :::
 683 
 684 
 685 #### Wrapping Method Declarations
 686 ::: conventions
 687 - Method declarations can be formatted by listing the arguments vertically, or by a new line and +8 extra spaces
 688 - If a throws clause needs to be wrapped, put the line break in front of the throws clause and make sure it stands out from the argument list, either by indenting +8 relative to the function declaration, or +8 relative to the previous line.
 689 :::
 690 
 691 ::: leftcol
 692 ::: box
 693 [Dos]{.boxheader .dos}
 694 
 695 ~~~java
 696 int someMethod(String aString,
 697                List&lt;Integer&gt; aList,
 698                Map&lt;String, String&gt; aMap,
 699                int anInt,
 700                long aLong,
 701                Set&lt;Number&gt; aSet,
 702                double aDouble) {
 703     …
 704 }
 705 ~~~
 706 
 707 ~~~java
 708 int someMethod(String aString, List&lt;Integer&gt; aList,
 709         Map&lt;String, String&gt; aMap, int anInt, long aLong,
 710         double aDouble, long aLong) {
 711     …
 712 }
 713 ~~~
 714 
 715 ~~~java
 716 int someMethod(String aString,
 717                List&lt;Map&lt;Integer, StringBuffer&gt;&gt; aListOfMaps,
 718                Map&lt;String, String&gt; aMap)
 719         throws IllegalArgumentException {
 720     …
 721 }
 722 ~~~
 723 
 724 ~~~java
 725 int someMethod(String aString, List&lt;Integer&gt; aList,
 726         Map&lt;String, String&gt; aMap, int anInt)
 727                 throws IllegalArgumentException {
 728     …
 729 }
 730 ~~~
 731 
 732 :::
 733 :::
 734 
 735 ::: rightcol
 736 ::: box
 737 [Don’ts]{.boxheader .donts}
 738 
 739 ~~~java
 740 // If aligning the parameters vertically, don&#39;t put two
 741 // parameters on one line
 742 int someMethod(String aString,
 743                List&lt;Integer&gt; aList,
 744                Map&lt;String, String&gt; aMap,
 745                int anInt, long aLong,
 746                Set&lt;Number&gt; aSet,
 747                double aDouble) {
 748     …
 749 }
 750 ~~~
 751 
 752 ~~~java
 753 int someMethod(String aString,
 754                List&lt;Map&lt;Integer, StringBuffer&gt;&gt; aListOfMaps,
 755                Map&lt;String, String&gt; aMap) throws InterruptedException {
 756     …
 757 }
 758 ~~~
 759 
 760 ~~~java
 761 int someMethod(String aString,
 762                List&lt;Integer&gt; aList,
 763                Map&lt;String, String&gt; aMap)
 764                throws IllegalArgumentException {
 765     …
 766 }
 767 ~~~
 768 
 769 :::
 770 :::
 771 
 772 
 773 #### Wrapping Expressions
 774 ::: conventions
 775 - If a line approaches the maximum character limit, always consider breaking it down into multiple statements / expressions instead of wrapping the line.
 776 - Break before operators.
 777 - Break before the `.` in chained method calls.
 778 :::
 779 
 780 ::: leftcol
 781 ::: box
 782 [Dos]{.boxheader .dos}
 783 
 784 ~~~java
 785 methodCall(a * simple - formula,
 786            some + complex - formula * spanning
 787                         + multiple - lines * may
 788                         + look - as * follows);
 789 ~~~
 790 
 791 ~~~java
 792 popupMsg(&quot;Inbox notification: You have &quot;
 793         + newMsgs + &quot; new messages&quot;);
 794 ~~~
 795 
 796 ~~~java
 797 people.stream()
 798       .map(Person::getName)
 799       .forEach(System.out::println);
 800 ~~~
 801 
 802 :::
 803 :::
 804 
 805 ::: rightcol
 806 ::: box
 807 [Don’ts]{.boxheader .donts}
 808 
 809 ~~~java
 810 // Arity unclear
 811 methodCall(a * simple - formula,
 812            some + complex - formula * spanning +
 813            multiple - lines * should + not *
 814            look - as * follows);
 815 ~~~
 816 
 817 ~~~java
 818 // Looks like two arguments
 819 popupMsg(&quot;Inbox notification: You have &quot; +
 820          newMsgs + &quot; new messages&quot;);
 821 ~~~
 822 
 823 ~~~java
 824 people.stream().
 825        map(Person::getName).
 826        forEach(System.out::println);
 827 ~~~
 828 
 829 :::
 830 :::
 831 
 832     
 833 ### Whitespace
 834 #### Vertical Whitespace
 835 ::: conventions
 836 - A single blank line should be used to separate…
 837   - Copyright notice
 838   - Package declaration
 839   - Class declarations
 840   - Constructors
 841   - Methods
 842   - Static initializers
 843   - Instance initializers
 844 
 845   …and may be used to separate logical groups of
 846 
 847   - import statements
 848   - fields
 849   - statements
 850 - Multiple consecutive blank lines should only be used to separate groups of related members and not as the standard inter-member spacing.
 851 :::
 852 
 853 #### Horizontal Whitespace
 854 ::: conventions
 855 - A single space should be used…
 856   - To separate keywords from neighboring opening or closing brackets and braces
 857   - Before and after all binary operators and operator like symbols such as arrows in lambda expressions and the colon in enhanced for loops (but not before the colon of a label)
 858   - After `//` that starts a comment.
 859   - After commas separating arguments and semicolons separating the parts of a for loop.
 860   - After the closing parenthesis of a cast.
 861 - In variable declarations it is not recommended to align types and variables.
 862 :::
 863 
 864 ::: leftcol
 865 ::: box
 866 [Dos]{.boxheader .dos}
 867 
 868 ~~~java
 869 int someInt;
 870 String myString;
 871 char aChar;
 872 long sixtyfourFlags;
 873 ~~~
 874 
 875 ~~~java
 876 if (isFlagSet(GO)) {
 877     …
 878 }
 879 ~~~
 880 
 881 ~~~java
 882 IntUnaryOperator inc = x -&gt; x + 1;
 883 ~~~
 884 
 885 ~~~java
 886 init: {
 887     …
 888 }
 889 ~~~
 890 
 891 :::
 892 :::
 893 
 894 ::: rightcol
 895 ::: box
 896 [Don’ts]{.boxheader .donts}
 897 
 898 ~~~java
 899 int    someInt;
 900 String myString;
 901 char   aChar;
 902 long   sixtyfourFlags;
 903 ~~~
 904 
 905 ~~~java
 906 if( isFlagSet( GO ) ) {
 907     …
 908 }
 909 ~~~
 910 
 911 ~~~java
 912 IntUnaryOperator inc = x-&gt;x + 1;
 913 ~~~
 914 
 915 ~~~java
 916 init : {
 917     …
 918 }
 919 ~~~
 920 
 921 :::
 922 :::
 923 
 924 
 925 ::: box
 926 [Motivation]{.boxheader}
 927 The improvement in readability when aligning variable names is negligible compared to the efforts needed to keep them aligned as the code evolves. Realigning all variables when one of the types change also causes unnecessarily complicated patches to review.
 928 :::
 929 
 930 ### Variable Declarations
 931 ::: conventions
 932 - One variable per declaration (and at most one declaration per line)
 933 - Square brackets of arrays should be at the type (`String[] args`) and not on the variable (`String args[]`).
 934 - Declare a local variable right before it is first used, and initialize it as close to the declaration as possible.
 935 :::
 936 
 937 ### Annotations
 938 ::: conventions
 939 - Declaration annotations should be put on a separate line from the declaration being annotated.
 940 - Few/short annotations annotating a single-line method may however be put on the same line as the method if it improves readability.
 941 - Either all annotations should be put on the same line or each annotation should be put on a separate line.
 942 :::
 943 
 944 ::: leftcol
 945 ::: box
 946 [Dos]{.boxheader .dos}
 947 
 948 ~~~java
 949 @Deprecated
 950 @Override
 951 public void foo() {
 952     …
 953 }
 954 ~~~
 955 
 956 ~~~java
 957 @Deprecated @Override
 958 public void foo() {
 959     …
 960 }
 961 ~~~
 962 
 963 ~~~java
 964 addListener(new Listener() {
 965  
 966     // Ignored events
 967     @Override public void event1() { }
 968     @Override public void event2() { }
 969     @Override public void event3() { }
 970  
 971     // Important event
 972     @Override
 973     public void event4() {
 974         …
 975     }
 976 });
 977 ~~~
 978 
 979 :::
 980 :::
 981 
 982 ::: rightcol
 983 ::: box
 984 [Don’ts]{.boxheader .donts}
 985 
 986 ~~~java
 987 @Override @Deprecated public void foo() {
 988     …
 989 }
 990 ~~~
 991 
 992 ~~~java
 993 @Override @Deprecated
 994 @SafeVarargs
 995 public void foo() {
 996     …
 997 }
 998 ~~~
 999 
1000 :::
1001 :::
1002 
1003 
1004 ### Lambda Expressions
1005 ::: conventions
1006 - Expression lambdas are preferred over single-line block lambdas.
1007 - Method references should generally be preferred over lambda expressions.&lt;br /&gt;&lt;br /&gt;
1008   For bound instance method references, or methods with arity greater than one, a lambda expression may be easier to understand and therefore preferred. Especially if the behavior of the method is not clear from the context.
1009 - The parameter types should be omitted unless they improve readability.
1010 - If a lambda expression stretches over more than a few lines, consider creating a method.
1011 :::
1012 
1013 ::: leftcol
1014 ::: box
1015 [Dos]{.boxheader .dos}
1016 
1017 ~~~java
1018 Runnable r = () -&gt; System.out.println(&quot;Hello World&quot;);
1019 ~~~
1020 
1021 ~~~java
1022 Supplier&lt;String&gt; c = () -&gt; &quot;Hello World&quot;;
1023 ~~~
1024 
1025 ~~~java
1026 // Collection::contains is a simple unary method and its behavior is
1027 // clear from the context. A method reference is preferred here.
1028 appendFilter(goodStrings::contains);
1029 ~~~
1030 
1031 ~~~java
1032 // A lambda expression is more readable in this case
1033 // (cf. corresponding example in Don&#39;ts section)
1034 trackTemperature((time, temp) -&gt; tempMap.put(time, temp));
1035 ~~~
1036 
1037 ~~~java
1038 Function&lt;Person, String&gt; nameFunc = p -&gt; p.getFirstName() + &quot; &quot; + p.getLastName();
1039 ~~~
1040 
1041 ~~~java
1042 class Util {
1043     private static String getCapitalizedFirstName(Person p) {
1044         String first = p.getFirstName();
1045         char initial = Character.toUpperCase(first.charAt(0));
1046         return initial + first.substring(1);
1047     }
1048  
1049     static void printAllPeople(List&lt;Person&gt; people) {
1050         people.stream()
1051               .map(Util::getCapitalizedFirstName)
1052               .forEach(System.out::println);
1053     }
1054 }
1055 ~~~
1056 
1057 :::
1058 :::
1059 
1060 ::: rightcol
1061 ::: box
1062 [Don’ts]{.boxheader .donts}
1063 
1064 ~~~java
1065 Runnable r = () -&gt; { System.out.println(&quot;Hello World&quot;); };
1066 ~~~
1067 
1068 ~~~java
1069 Supplier&lt;String&gt; s = () -&gt; { return &quot;Hello World&quot;; };
1070 ~~~
1071 
1072 ~~~java
1073 // A lambda expression is not needed here
1074 appendFilter(s -&gt; goodStrings.contains(s));
1075 ~~~
1076 
1077 ~~~java
1078 // Map::put is a binary function, and it’s not clear from context what type
1079 // of argument trackTemperature accepts. A lambda expression is better here.
1080 trackTemperature(tempMap::put);
1081 ~~~
1082 
1083 ~~~java
1084 // Unnecessary parameter type
1085 Function&lt;Person, String&gt; nameFunc = (Person p) -&gt; p.getFirstName() + &quot; &quot; + p.getLastName();
1086 ~~~
1087 
1088 ~~~java
1089 class Util {
1090     static void printAllPeople(List&lt;Person&gt; people) {
1091         people.stream()
1092               .map(p -&gt; {
1093                   String first = p.getFirstName();
1094                   char initial = Character.toTitleCase(first.charAt(0));
1095                   return initial + first.substring(1);
1096               })
1097               .forEach(System.out::println);
1098     }
1099 }
1100 ~~~
1101 
1102 :::
1103 :::
1104 
1105 
1106 ### Redundant Parentheses
1107 ::: conventions
1108 - Redundant grouping parentheses (i.e. parentheses that does not affect evaluation) may be used if they improve readability.
1109 - Redundant grouping parentheses should typically be left out in shorter expressions involving common operators but included in longer expressions or expressions involving operators whose precedence and associativity is unclear without parentheses. Ternary expressions with non-trivial conditions belong to the latter.
1110 - The entire expression following a return keyword must not be surrounded by parentheses.
1111 :::
1112 
1113 ::: leftcol
1114 ::: box
1115 [Dos]{.boxheader .dos}
1116 
1117 ~~~java
1118 return flag ? &quot;yes&quot; : &quot;no&quot;;
1119 ~~~
1120 
1121 ~~~java
1122 String cmp = (flag1 != flag2) ? &quot;not equal&quot; : &quot;equal&quot;;
1123 ~~~
1124 
1125 :::
1126 :::
1127 
1128 ::: rightcol
1129 ::: box
1130 [Don’ts]{.boxheader .donts}
1131 
1132 ~~~java
1133 return (flag ? &quot;yes&quot; : &quot;no&quot;);
1134 ~~~
1135 
1136 :::
1137 :::
1138 
1139 
1140 ### Literals
1141 ::: conventions
1142 - `long` literals should use the upper case letter `L` suffix.
1143 - Hexadecimal literals should use upper case letters `A`-`F`.
1144 - All other numerical prefixes, infixes, and suffixes should use lowercase letters.
1145 :::
1146 
1147 ::: leftcol
1148 ::: box
1149 [Dos]{.boxheader .dos}
1150 
1151 ~~~java
1152 long l = 5432L;
1153 int i = 0x123 + 0xABC;
1154 byte b = 0b1010;
1155 float f1 = 1 / 5432f;
1156 float f2 = 0.123e4f;
1157 double d1 = 1 / 5432d;  // or 1 / 5432.0
1158 double d2 = 0x1.3p2;
1159 ~~~
1160 
1161 :::
1162 :::
1163 
1164 ::: rightcol
1165 ::: box
1166 [Don’ts]{.boxheader .donts}
1167 
1168 ~~~java
1169 long l = 5432l;
1170 int i = 0X123 + 0xabc;
1171 byte b = 0B1010;
1172 float f1 = 1 / 5432F;
1173 float f2 = 0.123E4f;
1174 double d1 = 1 / 5432D;
1175 double d2 = 0x1.3P2;
1176 ~~~
1177 
1178 :::
1179 :::
1180 
1181 
1182 ::: box
1183 [Motivation]{.boxheader}
1184 Lower case L resembles a 1 in many monospace fonts which means that the literal `5432l` can be confused with `54321`. Using upper case `L` suffix avoids this. The lowercase `0x`, `0b`, `e`, `p`, `f`, and `d` characters are easier to spot in a long sequence of digits, and they avoid confusion with the hexadecimal digits `A`-`F`.
1185 :::
1186 
1187 ## Naming
1188 ::: conventions
1189 - Avoid hiding/shadowing methods, variables and type variables in outer scopes.
1190 - Let the verbosity of the name correlate to the size of the scope. (For instance, use descriptive names for fields of large classes and brief names for local short-lived variables.)
1191 - When naming public static members, let the identifier be self descriptive if you believe they will be statically imported.
1192 :::
1193 
1194 ### Package Names
1195 ::: conventions
1196 - Package names should be all lower case without underscores or other special characters.
1197 - Don’t use plural form. Follow the convention of the standard API which uses for instance `java.lang.annotation` and not `java.lang.annotations`.
1198 :::
1199 
1200 ### Class, Interface and Enum Names
1201 ::: conventions
1202 - Class and enum names should typically be nouns.
1203 - Interface names should typically be nouns or adjectives ending with *…able*.
1204 - Use mixed case with the first letter in each word in upper case.
1205 - Use whole words and avoid using abbreviations unless the abbreviation is more widely used than the long form.
1206 - Format an abbreviation as a word if the it is part of a longer class name.
1207 :::
1208 
1209 ::: leftcol
1210 ::: box
1211 [Dos]{.boxheader .dos}
1212 
1213 ~~~java
1214 class EmptyCell {
1215     …
1216 }
1217 ~~~
1218 
1219 ~~~java
1220 class RunningMode {
1221     …
1222 }
1223 ~~~
1224 
1225 ~~~java
1226 interface Expandable {
1227     …
1228 }
1229 ~~~
1230 
1231 ~~~java
1232 class XmlParser {
1233     …
1234 }
1235 ~~~
1236 
1237 :::
1238 :::
1239 
1240 ::: rightcol
1241 ::: box
1242 [Don’ts]{.boxheader .donts}
1243 
1244 ~~~java
1245 class Empty {
1246     …
1247 }
1248 ~~~
1249 
1250 ~~~java
1251 class Running {
1252     …
1253 }
1254 ~~~
1255 
1256 ~~~java
1257 class Expandable {
1258     …
1259 }
1260 ~~~
1261 
1262 ~~~java
1263 // Abbreviation should be formatted as &#39;Xml&#39;
1264 class XMLParser {
1265     …
1266 }
1267 ~~~
1268 
1269 :::
1270 :::
1271 
1272         
1273 ### Method Names
1274 ::: conventions
1275 - Method names should typically be verbs or other descriptions of actions.
1276 - Use mixed case with the first letter in lower case.
1277 :::
1278 
1279 ::: leftcol
1280 ::: box
1281 [Dos]{.boxheader .dos}
1282 
1283 ~~~java
1284 public void expand() {
1285     …
1286 }
1287 ~~~
1288 
1289 ~~~java
1290 public boolean isExpanding() {
1291     …
1292 }
1293 ~~~
1294 
1295 ~~~java
1296 public State getState() {
1297     …
1298 }
1299 ~~~
1300 
1301 :::
1302 :::
1303 
1304 ::: rightcol
1305 ::: box
1306 [Don’ts]{.boxheader .donts}
1307 
1308 ~~~java
1309 public boolean expanding() {
1310     …
1311 }
1312 ~~~
1313 
1314 ~~~java
1315 public State GetState() {
1316     …
1317 }
1318 ~~~
1319 
1320 ~~~java
1321 public int get_index() {
1322     …
1323 }
1324 ~~~
1325 
1326 :::
1327 :::
1328 
1329 
1330 
1331 ### Variables
1332 ::: conventions
1333 - Variable names should be in mixed case with the first letter in lower case.
1334 :::
1335 
1336 ::: leftcol
1337 ::: box
1338 [Dos]{.boxheader .dos}
1339 
1340 ~~~java
1341 int currentIndex;
1342 boolean dataAvailable;
1343 ~~~
1344 
1345 :::
1346 :::
1347 
1348 ::: rightcol
1349 ::: box
1350 [Don’ts]{.boxheader .donts}
1351 
1352 ~~~java
1353 int current_index;
1354 boolean DataAvailable;
1355 ~~~
1356 
1357 :::
1358 :::
1359 
1360 
1361 ### Type Variables
1362 ::: conventions
1363 - For simple cases where there are few type variables involved use a single upper case letter.
1364 - If one letter is more descriptive than another (such as `K` and `V` for keys and values in maps or `R` for a function return type) use that, otherwise use `T`.
1365 - For complex cases where single letter type variables become confusing, use longer names written in all capital letters and use underscore (`_`) to separate words.
1366 :::
1367 
1368 ::: leftcol
1369 ::: box
1370 [Dos]{.boxheader .dos}
1371 
1372 ~~~java
1373 interface SpecialMap&lt;K, V&gt; extends Map&lt;K, V&gt; {
1374     …
1375 }
1376 ~~~
1377 
1378 ~~~java
1379 class GraphMapper&lt;SRC_VERTEX, SRC_EDGE, DST_VERTEX, DST_EDGE&gt; {
1380     …
1381 }
1382 ~~~
1383 
1384 :::
1385 :::
1386 
1387 ::: rightcol
1388 ::: box
1389 [Don’ts]{.boxheader .donts}
1390 
1391 ~~~java
1392 interface SpecialMap&lt;Key, Value&gt; extends Map&lt;Key, Value&gt; {
1393     …
1394 }
1395 ~~~
1396 
1397 ~~~java
1398 class GraphMapper&lt;S, T, U, V&gt; {
1399     …
1400 }
1401 ~~~
1402 
1403 :::
1404 :::
1405 
1406 
1407 ### Constants
1408 ::: conventions
1409 - Constants (static final fields whose content is immutable, by language rules or by convention) should be named with all capital letters and underscore (`_`) to separate words.
1410 :::
1411 
1412 ::: leftcol
1413 ::: box
1414 [Dos]{.boxheader .dos}
1415 
1416 ~~~java
1417 public static final int BUFFER_SIZE = 1024;
1418 ~~~
1419 
1420 ~~~java
1421 enum ApplicationMode { RUNNING, PAUSED, TERMINATED }
1422 ~~~
1423 
1424 :::
1425 :::
1426 
1427 ::: rightcol
1428 ::: box
1429 [Don’ts]{.boxheader .donts}
1430 
1431 ~~~java
1432 public final List&lt;String&gt; CURRENT_WORDS = new ArrayList&lt;&gt;();
1433 ~~~
1434 
1435 ~~~java
1436 enum ApplicationMode { Running, Paused, Terminated }
1437 ~~~
1438 
1439 :::
1440 :::
1441 
1442 
1443 ## Programming Practices
1444 The focus of the guidelines in this section is on style. General guidelines on best programming practices, use of design patterns, how to structure programs etc is thus out of scope.&amp;nbsp;A few “low level” practices that are easy to pin down is however good to agree upon.
1445 
1446 ::: conventions
1447 - Always use `@Override` where it is possible to do so.
1448 - Document any non-obvious pre and post conditions (also for private methods). In particular, all parameters / return values are assumed to be non-null unless explicitly stated otherwise.
1449 - Avoid checking in “`TODO`” comments. If the missing code doesn’t affect correctness or performance, skip the comment, otherwise file an issue for it.
1450 - Avoid checking in dead code.
1451 - Static mutable state should be used judiciously. In particular enums should not have mutable state, and any public static variable must also be final.
1452 - Static methods and fields that are accessed out of scope should be qualified with the identifier of the class that declares them and not with a subclass or an instance variable.
1453 - Fall through on non-empty cases in switch statements should be documented, typically with a “`// fall through`” comment.
1454 - Mutating method parameters is discouraged. This is because parameters are typically associated with the input values and by mutating these the code may be harder to understand, especially when only looking at parts of the method below the mutation.
1455 - Keep methods short. Consider splitting up long methods into smaller ones to limit variable scopes and simplify structure of the code.
1456 :::
1457 
1458 ### Commenting Code
1459 ::: conventions
1460 - First and foremost, try to make the code simple enough that it’s self explanatory. While comments explaining the code are good, not having to explain the code is better.
1461 - For single line comments, use end-of-line comments (`//`) otherwise use multiline comments (`/* … */`).
1462 - Avoid comments that run the risk of getting out of sync as the code evolves. (If a comment runs the risk of getting out of sync, it’s often a sign that it comments how the code works rather than what the code achieves.)
1463 - Small well documented methods are preferred over longer methods with comments in the body of the method.
1464 - Don’t check in code that’s commented out.
1465 - IDE/tool-specific comments should be avoided wherever possible, especially when there are reasonable alternatives, such as external settings files, etc.
1466 - Comments should be grammatically correct and follow general recommendations of technical writing.
1467 - Start longer Javadoc comments with a short summarizing sentence since Javadoc includes this in the method summary table.
1468 - Prefer inline tags (such as `{@code …}` and `{@link …}` etc) over corresponding HTML tags (`&lt;code&gt;…&lt;/code&gt;`, `&lt;a href=&quot;…&quot;&gt;…&lt;/a&gt;` etc).
1469 - Use `&lt;p&gt;` to separate paragraphs (closing `&lt;/p&gt;` tags are not needed and should not be used)
1470 :::
1471 
1472 ::: leftcol
1473 ::: box
1474 [Dos]{.boxheader .dos}
1475 
1476 ~~~java
1477 /** A short javadoc comment */
1478 ~~~
1479 
1480 ~~~java
1481 /**
1482  * …
1483  *
1484  * &lt;blockquote&gt;{@code
1485  *     List&lt;String&gt; names;
1486  * }&lt;/blockquote&gt;
1487  */
1488 ~~~
1489 
1490 :::
1491 :::
1492 
1493 ::: rightcol
1494 ::: box
1495 [Don’ts]{.boxheader .donts}
1496 
1497 ~~~java
1498 /** put on single line instead
1499  */
1500 ~~~
1501 
1502 ~~~java
1503 /**
1504  * The &lt;String&gt; below may interfere with the HTML!
1505  *
1506  * &lt;blockquote&gt;&lt;pre&gt;
1507  *     List&lt;String&gt; names;
1508  * &lt;/pre&gt;&lt;/blockquote&gt;
1509  */
1510 ~~~
1511 
1512 :::
1513 :::
1514 
1515 For a complete Javadoc reference refer to &amp;nbsp;[How to Write Doc Comments for the Javadoc Tool](http://www.oracle.com/technetwork/articles/java/index-137868.html).
1516 
1517 ## When to reformat code
1518 ::: conventions
1519 - Do not reformat code in files unrelated to the current changeset, even if the code doesn’t adhere to the guidelines.
1520 - Minor cleanups in files that are already touched for other reasons are fine. Put the cleanups in a separate patch if you think it will simplify the review process. Large cleanups should always go in a separate changeset.
1521 :::
1522 
1523 ::: box
1524 [Motivation]{.boxheader}
1525 Cleaning up code that’s unrelated to the patch may…
1526 - Complicate the review of the patch in which case correctness may suffer
1527 - Run the risk of breaking existing code
1528 - Have a downstream impact, e.g. affect ports to other versions.
1529 - Trigger an unnecessary debate (perhaps the original formatting was intentional).
1530 :::
1531 
1532 ## Cases not covered
1533 ::: conventions
1534 - If some aspect is not covered by these guidelines one should fall back on the style of the surrounding code within the same file, within the package or within the project in that order.
1535 :::
1536 
1537 ::: {.NavBit}
1538 [« Previous](mailinglists.html) • [TOC](index.html) • [Next »](changePlanning.html)
1539 :::
    </pre>
  </body>
</html>
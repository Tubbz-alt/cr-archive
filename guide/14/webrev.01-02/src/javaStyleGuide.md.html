<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/javaStyleGuide.md</title>
    <link rel="stylesheet" href="../style.css" />
  </head>
  <body>
    <pre>
   1 % Java Style Guide
   2 
   3 ::: {.NavBit}
   4 [« Previous](mailinglists.html) • [TOC](index.html) • [Next »](changePlanning.html)
   5 :::
   6 
   7 ## Overview
   8 
   9 - [Java Source Files](#java-source-files)  
  10   - [Special Characters](#special-characters)  
  11 - [Formatting](#formatting)  
  12   - [Copyright notice](#copyright-notice)  
  13   - [Package declaration](#package-declaration)  
  14   - [Import statements](#import-statements)  
  15   - [Class Structure](#class-structure)  
  16   - [Modifiers](#modifiers)  
  17   - [Braces](#braces)  
  18   - [Indentation](#indentation)  
  19   - [Wrapping Lines](#wrapping-lines)  
  20   - [Whitespace](#whitespace)  
  21   - [Variable Declarations](#variable-declarations)  
  22   - [Annotations](#annotations)  
  23   - [Lambda Expressions](#lambda-expressions)  
  24   - [Redundant Parentheses](#redundant-parentheses)  
  25   - [Literals](#literals)  
  26 - [Naming](#naming)  
  27   - [Package Names](#package-names)  
  28   - [Class, Interface and Enum Names](#class-interface-and-enum-names)  
  29   - [Method Names](#method-names)  
  30   - [Variables](#variables)  
  31   - [Type Variables](#type-variables)  
  32   - [Constants](#constants)  
  33 - [Programming Practices](#programming-practices)  
  34   - [Commenting Code](#commenting-code)  
  35 - [When to reformat code](#when-to-reformat-code)  
  36 - [Cases not covered](#cases-not-covered)  
  37 
  38 ## Java Source Files
  39 
  40 ::: conventions
  41 - Source files must be encoded in 7-bit ASCII.
  42 - All lines must be terminated with a line feed character (`LF`, ASCII value 10) and *not* for instance `CR` or `CR`+`LF`.
  43 - There may be no trailing white space at the end of a line.
  44 - The name of a source file must equal the name of the class it contains followed by the `.java` extension, even for files that only contain a package private class. This does not apply to files that do not contain any class declarations, such as `package-info.java`.
  45 :::
  46 
  47 ::: box
  48 [Motivation]{.boxheader}
  49 7-bit ASCII reduces errors due to confusion of characters since there are no invisible spaces, characters that look like minus signs but are really dashes, etc. It also ensures packages and classes are named in such way that the corresponding directories and source files are portable across different filesystems.
  50   
  51 Agreeing on a common line delimiter character is important since different operating systems have different defaults. Editing a file on Windows that was originally written on Linux, may cause all `LF` to be saved back as `CR`+`LF`. This creates unnecessarily big patches and may not display correctly in the text editor it was originally written in. A single line feed character is default for Unix-like systems and supported by all common text editors and IDEs.
  52 
  53 Trailing white space is nothing but unnecessary cruft. It’s easy to remove and agreeing on doing so consistently minimizes diffs.
  54 
  55 Not using the name of the class as filename can be confusing. Also, unless the file is given explicitly to the compiler, the class it contains may not be resolved correctly.
  56 :::
  57 
  58 ### Special Characters
  59 ::: conventions
  60 - Apart from `LF` the only allowed white space character is Space (ASCII value 32). Note that this implies that other white space characters (in, for instance, string and character literals) must be written in escaped form.
  61 - `\&#39;`, `\&quot;`, `\\`, `\t`, `\b`, `\r`, `\f`, and `\n` should be preferred over corresponding octal (e.g. `\047`) or Unicode (e.g. `\u0027`) escaped characters.
  62 - Should there be a need to go against the above rules for the sake of testing, the test should generate the required source.
  63 :::
  64 
  65 ::: box
  66 [Motivation]{.boxheader}
  67 Having any white space character but space and `LF` in the source code can be a source of confusion.
  68 
  69 The short forms (e.g. `\t`) are commonly used and easier to recognize than the corresponding longer forms (`\011`, `\u0009`).
  70 :::
  71 
  72 ## Formatting
  73 ::: conventions
  74 - A Java source file should be structured as follows:
  75   1. The copyright notice
  76   1. Package declaration
  77   1. Import statements
  78   1. Class declaration
  79 - There may be only one top level class declaration per file.
  80 :::
  81 
  82 ### Copyright notice
  83 ::: conventions
  84 - All source files should have an appropriate copyright notice at the top of the file.
  85 
  86 - For files under Oracle copyright, the copyright notice must follow the standard wording and format. In particular the first two lines should be
  87 
  88   ~~~java
  89   /*
  90    * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
  91   ~~~
  92 
  93   or
  94 
  95   ~~~java
  96   /*
  97    * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
  98   ~~~
  99 
 100   where the first year is the year the file was created and the second year is the year the file was last edited.
 101 :::
 102 
 103 For questions regarding Oracle copyright or license notices, please contact [iris.clark@oracle.com](mailto:iris.clark@oracle.com).
 104 
 105 ### Package declaration
 106 ::: conventions
 107 - The package declaration should not be line wrapped, regardless of whether it exceeds the recommended maximum length of a line. (See section on [Wrapping Lines](#wrapping-lines).)
 108 :::
 109 
 110 ### Import statements
 111 ::: conventions
 112 - Import statements should be sorted…
 113   - …primarily by non-static / static with non-static imports first.
 114   - …secondarily by package origin according to the following order
 115     - `java` packages
 116     - `javax` packages
 117     - external packages (e.g. `org.xml`)
 118     - internal packages (e.g. `com.sun`)
 119   - …tertiary by package and class identifier in lexicographical order
 120 - Import statements should not be line wrapped, regardless of whether it exceeds the recommended maximum length of a line.
 121 - No unused imports should be present.
 122 :::
 123 
 124 #### Wildcard Imports
 125 ::: conventions
 126 - Wildcard imports should in general not be used.
 127 - When importing a large number of closely-related classes (such as implementing a visitor over a tree with dozens of distinct “node” classes), a wildcard import may be used.
 128 - In any case, no more than one wildcard import per file should be used.
 129 :::
 130 
 131 ::: box
 132 [Motivation]{.boxheader}
 133 Wildcard imports makes it unclear what actually needs to be imported.
 134 
 135 Having more than one wildcard import makes the code fragile since adding a new class in one of the imported packages can introduce a name clash.
 136 
 137 An unused import gives a false impression of a dependency. Also, many IDEs list such import statements as warnings which clutters the list of problems.
 138 :::
 139 
 140 ### Class Structure
 141 ::: conventions
 142 - The recommended order of class members is the following:
 143   1. Fields
 144   1. Constructors
 145   1. Factory methods
 146   1. Other Methods
 147 - Related fields should be grouped together. Ordering fields primarily according to access modifiers or identifier is not required. The same applies to methods.
 148 - Nested types should be grouped at the top of the class, or else defined before first use.
 149 :::
 150 
 151 #### Order of Constructors and Overloaded Methods
 152 ::: conventions
 153 - Constructors and overloaded methods should be grouped together by functionality and ordered with increasing arity. This implies that delegation among these constructs flow downward in the code.
 154 - Constructors and overloaded methods should generally not be split apart by other members.
 155 :::
 156 
 157 ::: leftcol
 158 ::: box
 159 [Dos]{.boxheader .dos}
 160 
 161 ~~~java
 162 public HashSet() {
 163     this(DEFAULT_INITIAL_CAPACITY);
 164 }
 165 
 166 public HashSet(int capacity) {
 167     this(capacity, DEFAULT_LOAD_FACTOR);
 168 }
 169 
 170 public HashSet(int capacity, double loadFactor) {
 171     …
 172 }
 173 ~~~
 174 
 175 :::
 176 :::
 177 
 178 ::: rightcol
 179 ::: box
 180 [Don’ts]{.boxheader .donts}
 181 
 182 ~~~java
 183 // Overloaded methods should not be split apart
 184 void logValue(int i) {
 185     log(&quot;Int: %d&quot;, i);
 186 }
 187 
 188 void setValue(int i) {
 189     val = i;
 190 }
 191 
 192 void logValue(double d) {
 193     log(&quot;Double: %.2d&quot;, d);
 194 }
 195 
 196 void setValue(double d) {
 197     val = d;
 198 }
 199 ~~~
 200 
 201 :::
 202 :::
 203 
 204 ::: box
 205 [Motivation]{.boxheader}
 206 This order puts the most generally applicable versions first. Also, making sure delegation is always done downwards in the file makes the code easier to follow.
 207 :::
 208 
 209 ### Modifiers
 210 ::: conventions
 211 - Modifiers should go in the following order
 212   1. Access modifier (`public` / `private` / `protected`)
 213   1. `abstract`
 214   1. `static`
 215   1. `final`
 216   1. `transient`
 217   1. `volatile`
 218   1. `default`
 219   1. `synchronized`
 220   1. `native`
 221   1. `strictfp`
 222 - Modifiers should not be written out when they are implicit. For example, interface methods should neither be declared public nor abstract, and nested enums and interfaces should not be declared static.
 223 - Method parameters and local variables should not be declared final unless it improves readability or documents an actual design decision.
 224 - Fields should be declared final unless there is a compelling reason to make them mutable.
 225 :::
 226 
 227 ::: box
 228 [Motivation]{.boxheader}
 229 Writing out modifiers where they are implicit clutters the code and learning which modifiers are implicit where is easy.
 230 
 231 Although method parameters should typically not be mutated, consistently marking all parameters in every methods as `final` is an exaggeration.
 232 
 233 Making fields immutable where possible is good programming practice. Refer to *Effective Java, Item 15: Minimize Mutability* for details.
 234 :::
 235 
 236 ### Braces
 237 ::: conventions
 238 - Opening braces should be put on the end of the current line rather than on a line by its own.
 239 - There should be a new line in front of a closing brace unless the block is empty (see [Short Forms](#short-forms) below)
 240 - Braces are recommended even where the language makes them optional, such as single-line if and loop bodies.
 241   - If a block spans more than one line (including comments) it must have braces.
 242   - If one of the blocks in a if / else statement has braces, the other block must too.
 243   - If the block comes last in an enclosing block, it must have braces.
 244 - The `else`,&amp;nbsp;`catch` and the `while` keyword in `do`…`while` loops go on the same line as the closing brace of the preceding block.
 245 :::
 246 
 247 ::: leftcol
 248 ::: box
 249 [Dos]{.boxheader .dos}
 250 
 251 ~~~java
 252 void method() {
 253     …
 254 }
 255 ~~~
 256 
 257 ~~~java
 258 try {
 259     something();
 260 } catch (AnException e) {
 261     …
 262 }
 263 ~~~
 264 
 265 ~~~java
 266 for (int[] row : matrix) {
 267     for (int val : row) {
 268         sum += val;
 269     }
 270 }
 271 ~~~
 272 
 273 :::
 274 :::
 275 
 276 ::: rightcol
 277 ::: box
 278 [Don’ts]{.boxheader .donts}
 279 
 280 ~~~java
 281 // Wrong placement of opening brace
 282 void method()
 283 {
 284     …
 285 }
 286 ~~~
 287 
 288 ~~~java
 289 // Newline in front of catch should be avoided
 290 try {
 291     something();
 292 }
 293 catch (AnException e) {
 294     …
 295 }
 296 ~~~
 297 
 298 ~~~java
 299 // Braces should be used
 300 if (flag)
 301     // Restore x
 302     x = 1;
 303 ~~~
 304 
 305 ~~~java
 306 // Use braces if block comes last in enclosing block
 307 // to avoid accidentally indenting the closing brace.
 308 for (int[] row : matrix) {
 309     for (int val : row)
 310         sum += val;
 311 }
 312 ~~~
 313 
 314 :::
 315 :::
 316 
 317 ::: box
 318 [Motivation]{.boxheader}
 319 Putting opening braces on the end of the line (as opposed to on a line of its own) is a long standing Java convention. This style is also suitable for Java, considering that it’s common to have small blocks (in for instance anonymous classes and lambda expressions) and having opening braces on a separate line creates an unnecessary amount of white space in such situations.
 320 
 321 Omitting braces is error prone and can lead to mistakes in the indentation and hard to detect bugs.
 322 :::
 323 
 324 #### Short Forms
 325 ::: conventions
 326 - The above recommendations are intended to improve uniformity (and thus increase familiarity / readability). In some cases “short forms” that deviate from the above guidelines are just as readable and may be used instead. These cases include for instance simple enum declarations and trivial methods and lambda expressions.
 327 :::
 328 
 329 
 330 ::: leftcol
 331 ::: box
 332 [Dos]{.boxheader .dos}
 333 
 334 ~~~java
 335 enum Response { YES, NO, MAYBE }
 336 ~~~
 337 
 338 ~~~java
 339 public boolean isReference() { return true; }
 340 ~~~
 341 
 342 :::
 343 :::
 344 
 345 ::: rightcol
 346 ::: box
 347 [Don’ts]{.boxheader .donts}
 348 
 349 ~~~java
 350 public boolean getResult() { int value = getValue(); return value &lt; 0 ? 0 : value; }
 351 ~~~
 352 
 353 ~~~java
 354 for (int i = 0; i &lt; size; i++) { sum += data[i]; }
 355 ~~~
 356 
 357 :::
 358 :::
 359 
 360 
 361 ### Indentation
 362 ::: conventions
 363 - Indentation level is four spaces.
 364 - Only space characters may be used for indentation. No tabs.
 365 - Empty lines must not be indented. (This is implied by the no trailing white space rule.)
 366 - `case` lines should be indented with four spaces, and statements within the case should be indented with another four spaces.
 367 :::
 368 Refer to Section&amp;nbsp;[Wrapping Lines](#wrapping-lines)&amp;nbsp;for guidelines on how to indent continuation lines.
 369 
 370 ::: leftcol
 371 ::: box
 372 [Dos]{.boxheader .dos}
 373 
 374 ~~~java
 375 switch (var) {
 376     case TWO:
 377         setChoice(&quot;two&quot;);
 378         break;
 379     case THREE:
 380         setChoice(&quot;three&quot;);
 381         break;
 382     default:
 383         throw new IllegalArgumentException();
 384 }
 385 ~~~
 386 
 387 :::
 388 :::
 389 
 390 ::: rightcol
 391 ::: box
 392 [Don’ts]{.boxheader .donts}
 393 
 394 ~~~java
 395 switch (var) {
 396 case TWO:
 397     setChoice(&quot;two&quot;);
 398     break;
 399 case THREE:
 400     setChoice(&quot;three&quot;);
 401     break;
 402 default:
 403     throw new IllegalArgumentException();
 404 }
 405 ~~~
 406 
 407 :::
 408 :::
 409 
 410 
 411 ::: box
 412 [Motivation]{.boxheader}
 413 By using spaces for indentation, problems regarding different default settings for tab stops in various editors are avoided.
 414 :::
 415 
 416 ### Wrapping Lines
 417 ::: conventions
 418 - Source code and comments should generally not exceed 80 characters per line and rarely if ever exceed 100 characters per line, including indentation.
 419 
 420   ::: box
 421   ::: boxheader
 422   Note
 423   :::
 424   The character limit must be judged on a case by case basis. What really matters is the semantical “density” and readability of the line. Making lines gratuitously long makes them hard to read; similarly, making “heroic attempts” to fit them into 80 columns can also make them hard to read. The flexibility outlined here aims to enable developers to avoid these extremes, not to maximize use of monitor real-estate.
 425   :::
 426 
 427   ::: leftcol
 428   ::: box
 429   ::: {.boxheader .dos}
 430   Dos
 431   :::
 432   
 433   ~~~java
 434   // Ok even though it might exceed the character limit when indented.
 435   Error e = isTypeParam
 436           ? Errors.InvalidRepeatableAnnotationNotApplicable(targetContainerType, on)
 437           : Errors.InvalidRepeatableAnnotationNotApplicableInContext(targetContainerType));
 438   ~~~
 439   
 440   ~~~java
 441   String pretty = Stream.of(args)
 442                         .map(Argument::prettyPrint)
 443                         .collectors(joining(&quot;, &quot;));
 444   ~~~
 445 
 446   :::
 447   :::
 448 
 449   ::: rightcol
 450   ::: box
 451   ::: {.boxheader .donts}
 452   Don’ts
 453   :::
 454 
 455   ~~~java
 456   // Too strict interpretation of the character limit. Readability suffers.
 457   Error e = isTypeParam
 458         ? Errors.InvalidRepeatableAnnotationNotApplicable(
 459                 targetContainerType, on)
 460         : Errors.InvalidRepeatableAnnotationNotApplicableInContext(
 461                 targetContainerType);
 462   ~~~
 463 
 464   ~~~java
 465   // Should be wrapped even though it fits within the character limit
 466   String pretty = Stream.of(args).map(Argument::prettyPrint).collectors(joining(&quot;, &quot;));
 467   ~~~
 468 
 469   :::
 470   :::
 471 
 472   ::: clear-floats
 473   :::
 474 
 475 - URLs or example commands should not be wrapped.
 476 - Wrapping at a higher syntactical level is preferred over wrapping at a lower syntactical level.
 477 
 478   ::: leftcol
 479   ::: box
 480   ::: {.boxheader .dos}
 481   Dos
 482   :::
 483 
 484   ~~~java
 485   aMethodCall(withMany(arguments, that, needs),
 486           to(be, (wrapped - to) * avoid / veryLong - lines));
 487   ~~~
 488 
 489   :::
 490   :::
 491 
 492   ::: rightcol
 493   ::: box
 494   ::: {.boxheader .donts}
 495   Don’ts
 496   :::
 497 
 498   ~~~java
 499   aMethodCall(withMany(arguments, that, needs), to(be, (wrapped
 500           - to) * avoid / veryLong - lines));
 501   ~~~
 502 
 503   :::
 504   :::
 505 
 506   ::: clear-floats
 507   :::
 508 
 509 - There should be at most 1 statement per line.
 510 
 511   ::: leftcol
 512   ::: box
 513   ::: {.boxheader .dos}
 514   Dos
 515   :::
 516 
 517   ~~~java
 518   i += j;
 519   j += k;
 520   ~~~
 521 
 522   ~~~java
 523   if (condition) {
 524       return expression;
 525   }
 526   ~~~
 527 
 528   :::
 529   :::
 530 
 531   ::: rightcol
 532   ::: box
 533   ::: {.boxheader .donts}
 534   Don’ts
 535   :::
 536 
 537   ~~~java
 538   i += j; j += k;
 539   ~~~
 540 
 541   ~~~java
 542   if (condition) { return expression; }
 543   ~~~
 544 
 545   :::
 546   :::
 547 
 548   ::: clear-floats
 549   :::
 550 
 551 - A continuation line should be indented in one of the following four ways
 552   - **Variant 1:** With 8 extra spaces relative to the indentation of the previous line.
 553   - **Variant 2:** With 8 extra spaces relative to the starting column of the wrapped expression.
 554   - **Variant 3:** Aligned with previous sibling expression (as long as it is clear that it’s a continuation line)
 555   - **Variant 4:** Aligned with previous method call in a chained expression.
 556 
 557   ::: leftcol
 558   ::: box
 559   ::: {.boxheader .dos}
 560   Dos
 561   :::
 562 
 563   ~~~java
 564   // Variant 1
 565   int anInteger = aMethod(that, takes,
 566           a, lengthy, list, of, arguments);
 567   ~~~
 568 
 569   ~~~java
 570   // Variant 2
 571   int anInteger = that * (is + computed) / using
 572                           + a * complex - expression;
 573   ~~~
 574 
 575   ~~~java
 576   // Variant 3
 577   int anInteger = aMethod(thatTakes,
 578                           aLongList,
 579                           ofArguments);
 580   ~~~
 581 
 582   ~~~java
 583   // Variant 4
 584   int anInteger = IntStream.of(numbers)
 585                            .map(Math::sqrt)
 586                            .sum();
 587   ~~~
 588 
 589   :::
 590   :::
 591 
 592   ::: rightcol
 593   ::: box
 594   ::: {.boxheader .donts}
 595   Don’ts
 596   :::
 597 
 598   ~~~java
 599   // Mixing of wrapping variants (unless there
 600   // is a logical grouping of arguments)
 601   int anInteger = aMethod(that,
 602                           takes,
 603                           a, lengthy, list,
 604                           of, arguments);
 605   ~~~
 606 
 607   ~~~java
 608   // Don&#39;t align with sibling expression if the
 609   // continuation line can be confused with a block
 610   // indentation
 611   if (somePredicate() ||
 612       someOtherPredicate()) {
 613       System.out.println(&quot;Avoid&quot;);
 614   }
 615   ~~~
 616 
 617   :::
 618   :::
 619 
 620   ::: clear-floats
 621   :::
 622 :::
 623 
 624 #### Wrapping Class Declarations
 625 ::: conventions
 626 - A class header should not be wrapped unless it approaches the maximum column limit.
 627 - If it does, it may be wrapped before `extends` and/or `implements` keywords.
 628 - Declarations of type parameters may, if necessary, be wrapped the same way as method arguments
 629 :::
 630 
 631 ::: leftcol
 632 ::: box
 633 [Dos]{.boxheader .dos}
 634 
 635 ~~~java
 636 public class MyGenericClass&lt;T, S&gt;
 637         extends HashMap&lt;T, S&gt;
 638         implements Comparable&lt;T&gt; {
 639     …
 640 }
 641 ~~~
 642 
 643 ~~~java
 644 public class AnotherClass&lt;K, R&gt; implements Collector&lt;T extends K,
 645                                                      Set&lt;? extends R&gt;,
 646                                                      List&lt;R&gt;&gt; {
 647     …
 648 }
 649 ~~~
 650 
 651 ~~~java
 652 public class AnotherClass&lt;K, R&gt; implements Collector&lt;T extends K,
 653                                                      Set&lt;? extends R&gt;,
 654                                                      List&lt;R&gt;&gt; {
 655     …
 656 }
 657 ~~~
 658 
 659 :::
 660 :::
 661 
 662 ::: rightcol
 663 ::: box
 664 [Don’ts]{.boxheader .donts}
 665 
 666 ~~~java
 667 public class MyGenericClass&lt;T&gt; implements Comparable&lt;T&gt;,
 668         Predicate&lt;T&gt; {
 669     …
 670 }
 671 ~~~
 672 
 673 :::
 674 :::
 675 
 676 
 677 #### Wrapping Method Declarations
 678 ::: conventions
 679 - Method declarations can be formatted by listing the arguments vertically, or by a new line and +8 extra spaces
 680 - If a throws clause needs to be wrapped, put the line break in front of the throws clause and make sure it stands out from the argument list, either by indenting +8 relative to the function declaration, or +8 relative to the previous line.
 681 :::
 682 
 683 ::: leftcol
 684 ::: box
 685 [Dos]{.boxheader .dos}
 686 
 687 ~~~java
 688 int someMethod(String aString,
 689                List&lt;Integer&gt; aList,
 690                Map&lt;String, String&gt; aMap,
 691                int anInt,
 692                long aLong,
 693                Set&lt;Number&gt; aSet,
 694                double aDouble) {
 695     …
 696 }
 697 ~~~
 698 
 699 ~~~java
 700 int someMethod(String aString, List&lt;Integer&gt; aList,
 701         Map&lt;String, String&gt; aMap, int anInt, long aLong,
 702         double aDouble, long aLong) {
 703     …
 704 }
 705 ~~~
 706 
 707 ~~~java
 708 int someMethod(String aString,
 709                List&lt;Map&lt;Integer, StringBuffer&gt;&gt; aListOfMaps,
 710                Map&lt;String, String&gt; aMap)
 711         throws IllegalArgumentException {
 712     …
 713 }
 714 ~~~
 715 
 716 ~~~java
 717 int someMethod(String aString, List&lt;Integer&gt; aList,
 718         Map&lt;String, String&gt; aMap, int anInt)
 719                 throws IllegalArgumentException {
 720     …
 721 }
 722 ~~~
 723 
 724 :::
 725 :::
 726 
 727 ::: rightcol
 728 ::: box
 729 [Don’ts]{.boxheader .donts}
 730 
 731 ~~~java
 732 // If aligning the parameters vertically, don&#39;t put two
 733 // parameters on one line
 734 int someMethod(String aString,
 735                List&lt;Integer&gt; aList,
 736                Map&lt;String, String&gt; aMap,
 737                int anInt, long aLong,
 738                Set&lt;Number&gt; aSet,
 739                double aDouble) {
 740     …
 741 }
 742 ~~~
 743 
 744 ~~~java
 745 int someMethod(String aString,
 746                List&lt;Map&lt;Integer, StringBuffer&gt;&gt; aListOfMaps,
 747                Map&lt;String, String&gt; aMap) throws InterruptedException {
 748     …
 749 }
 750 ~~~
 751 
 752 ~~~java
 753 int someMethod(String aString,
 754                List&lt;Integer&gt; aList,
 755                Map&lt;String, String&gt; aMap)
 756                throws IllegalArgumentException {
 757     …
 758 }
 759 ~~~
 760 
 761 :::
 762 :::
 763 
 764 
 765 #### Wrapping Expressions
 766 ::: conventions
 767 - If a line approaches the maximum character limit, always consider breaking it down into multiple statements / expressions instead of wrapping the line.
 768 - Break before operators.
 769 - Break before the `.` in chained method calls.
 770 :::
 771 
 772 ::: leftcol
 773 ::: box
 774 [Dos]{.boxheader .dos}
 775 
 776 ~~~java
 777 methodCall(a * simple - formula,
 778            some + complex - formula * spanning
 779                         + multiple - lines * may
 780                         + look - as * follows);
 781 ~~~
 782 
 783 ~~~java
 784 popupMsg(&quot;Inbox notification: You have &quot;
 785         + newMsgs + &quot; new messages&quot;);
 786 ~~~
 787 
 788 ~~~java
 789 people.stream()
 790       .map(Person::getName)
 791       .forEach(System.out::println);
 792 ~~~
 793 
 794 :::
 795 :::
 796 
 797 ::: rightcol
 798 ::: box
 799 [Don’ts]{.boxheader .donts}
 800 
 801 ~~~java
 802 // Arity unclear
 803 methodCall(a * simple - formula,
 804            some + complex - formula * spanning +
 805            multiple - lines * should + not *
 806            look - as * follows);
 807 ~~~
 808 
 809 ~~~java
 810 // Looks like two arguments
 811 popupMsg(&quot;Inbox notification: You have &quot; +
 812          newMsgs + &quot; new messages&quot;);
 813 ~~~
 814 
 815 ~~~java
 816 people.stream().
 817        map(Person::getName).
 818        forEach(System.out::println);
 819 ~~~
 820 
 821 :::
 822 :::
 823 
 824     
 825 ### Whitespace
 826 #### Vertical Whitespace
 827 ::: conventions
 828 - A single blank line should be used to separate…
 829   - Copyright notice
 830   - Package declaration
 831   - Class declarations
 832   - Constructors
 833   - Methods
 834   - Static initializers
 835   - Instance initializers
 836 
 837   …and may be used to separate logical groups of
 838 
 839   - import statements
 840   - fields
 841   - statements
 842 - Multiple consecutive blank lines should only be used to separate groups of related members and not as the standard inter-member spacing.
 843 :::
 844 
 845 #### Horizontal Whitespace
 846 ::: conventions
 847 - A single space should be used…
 848   - To separate keywords from neighboring opening or closing brackets and braces
 849   - Before and after all binary operators and operator like symbols such as arrows in lambda expressions and the colon in enhanced for loops (but not before the colon of a label)
 850   - After `//` that starts a comment.
 851   - After commas separating arguments and semicolons separating the parts of a for loop.
 852   - After the closing parenthesis of a cast.
 853 - In variable declarations it is not recommended to align types and variables.
 854 :::
 855 
 856 ::: leftcol
 857 ::: box
 858 [Dos]{.boxheader .dos}
 859 
 860 ~~~java
 861 int someInt;
 862 String myString;
 863 char aChar;
 864 long sixtyfourFlags;
 865 ~~~
 866 
 867 ~~~java
 868 if (isFlagSet(GO)) {
 869     …
 870 }
 871 ~~~
 872 
 873 ~~~java
 874 IntUnaryOperator inc = x -&gt; x + 1;
 875 ~~~
 876 
 877 ~~~java
 878 init: {
 879     …
 880 }
 881 ~~~
 882 
 883 :::
 884 :::
 885 
 886 ::: rightcol
 887 ::: box
 888 [Don’ts]{.boxheader .donts}
 889 
 890 ~~~java
 891 int    someInt;
 892 String myString;
 893 char   aChar;
 894 long   sixtyfourFlags;
 895 ~~~
 896 
 897 ~~~java
 898 if( isFlagSet( GO ) ) {
 899     …
 900 }
 901 ~~~
 902 
 903 ~~~java
 904 IntUnaryOperator inc = x-&gt;x + 1;
 905 ~~~
 906 
 907 ~~~java
 908 init : {
 909     …
 910 }
 911 ~~~
 912 
 913 :::
 914 :::
 915 
 916 
 917 ::: box
 918 [Motivation]{.boxheader}
 919 The improvement in readability when aligning variable names is negligible compared to the efforts needed to keep them aligned as the code evolves. Realigning all variables when one of the types change also causes unnecessarily complicated patches to review.
 920 :::
 921 
 922 ### Variable Declarations
 923 ::: conventions
 924 - One variable per declaration (and at most one declaration per line)
 925 - Square brackets of arrays should be at the type (`String[] args`) and not on the variable (`String args[]`).
 926 - Declare a local variable right before it is first used, and initialize it as close to the declaration as possible.
 927 :::
 928 
 929 ### Annotations
 930 ::: conventions
 931 - Declaration annotations should be put on a separate line from the declaration being annotated.
 932 - Few/short annotations annotating a single-line method may however be put on the same line as the method if it improves readability.
 933 - Either all annotations should be put on the same line or each annotation should be put on a separate line.
 934 :::
 935 
 936 ::: leftcol
 937 ::: box
 938 [Dos]{.boxheader .dos}
 939 
 940 ~~~java
 941 @Deprecated
 942 @Override
 943 public void foo() {
 944     …
 945 }
 946 ~~~
 947 
 948 ~~~java
 949 @Deprecated @Override
 950 public void foo() {
 951     …
 952 }
 953 ~~~
 954 
 955 ~~~java
 956 addListener(new Listener() {
 957  
 958     // Ignored events
 959     @Override public void event1() { }
 960     @Override public void event2() { }
 961     @Override public void event3() { }
 962  
 963     // Important event
 964     @Override
 965     public void event4() {
 966         …
 967     }
 968 });
 969 ~~~
 970 
 971 :::
 972 :::
 973 
 974 ::: rightcol
 975 ::: box
 976 [Don’ts]{.boxheader .donts}
 977 
 978 ~~~java
 979 @Override @Deprecated public void foo() {
 980     …
 981 }
 982 ~~~
 983 
 984 ~~~java
 985 @Override @Deprecated
 986 @SafeVarargs
 987 public void foo() {
 988     …
 989 }
 990 ~~~
 991 
 992 :::
 993 :::
 994 
 995 
 996 ### Lambda Expressions
 997 ::: conventions
 998 - Expression lambdas are preferred over single-line block lambdas.
 999 - Method references should generally be preferred over lambda expressions.&lt;br /&gt;&lt;br /&gt;
1000   For bound instance method references, or methods with arity greater than one, a lambda expression may be easier to understand and therefore preferred. Especially if the behavior of the method is not clear from the context.
1001 - The parameter types should be omitted unless they improve readability.
1002 - If a lambda expression stretches over more than a few lines, consider creating a method.
1003 :::
1004 
1005 ::: leftcol
1006 ::: box
1007 [Dos]{.boxheader .dos}
1008 
1009 ~~~java
1010 Runnable r = () -&gt; System.out.println(&quot;Hello World&quot;);
1011 ~~~
1012 
1013 ~~~java
1014 Supplier&lt;String&gt; c = () -&gt; &quot;Hello World&quot;;
1015 ~~~
1016 
1017 ~~~java
1018 // Collection::contains is a simple unary method and its behavior is
1019 // clear from the context. A method reference is preferred here.
1020 appendFilter(goodStrings::contains);
1021 ~~~
1022 
1023 ~~~java
1024 // A lambda expression is more readable in this case
1025 // (cf. corresponding example in Don&#39;ts section)
1026 trackTemperature((time, temp) -&gt; tempMap.put(time, temp));
1027 ~~~
1028 
1029 ~~~java
1030 Function&lt;Person, String&gt; nameFunc = p -&gt; p.getFirstName() + &quot; &quot; + p.getLastName();
1031 ~~~
1032 
1033 ~~~java
1034 class Util {
1035     private static String getCapitalizedFirstName(Person p) {
1036         String first = p.getFirstName();
1037         char initial = Character.toUpperCase(first.charAt(0));
1038         return initial + first.substring(1);
1039     }
1040  
1041     static void printAllPeople(List&lt;Person&gt; people) {
1042         people.stream()
1043               .map(Util::getCapitalizedFirstName)
1044               .forEach(System.out::println);
1045     }
1046 }
1047 ~~~
1048 
1049 :::
1050 :::
1051 
1052 ::: rightcol
1053 ::: box
1054 [Don’ts]{.boxheader .donts}
1055 
1056 ~~~java
1057 Runnable r = () -&gt; { System.out.println(&quot;Hello World&quot;); };
1058 ~~~
1059 
1060 ~~~java
1061 Supplier&lt;String&gt; s = () -&gt; { return &quot;Hello World&quot;; };
1062 ~~~
1063 
1064 ~~~java
1065 // A lambda expression is not needed here
1066 appendFilter(s -&gt; goodStrings.contains(s));
1067 ~~~
1068 
1069 ~~~java
1070 // Map::put is a binary function, and it’s not clear from context what type
1071 // of argument trackTemperature accepts. A lambda expression is better here.
1072 trackTemperature(tempMap::put);
1073 ~~~
1074 
1075 ~~~java
1076 // Unnecessary parameter type
1077 Function&lt;Person, String&gt; nameFunc = (Person p) -&gt; p.getFirstName() + &quot; &quot; + p.getLastName();
1078 ~~~
1079 
1080 ~~~java
1081 class Util {
1082     static void printAllPeople(List&lt;Person&gt; people) {
1083         people.stream()
1084               .map(p -&gt; {
1085                   String first = p.getFirstName();
1086                   char initial = Character.toTitleCase(first.charAt(0));
1087                   return initial + first.substring(1);
1088               })
1089               .forEach(System.out::println);
1090     }
1091 }
1092 ~~~
1093 
1094 :::
1095 :::
1096 
1097 
1098 ### Redundant Parentheses
1099 ::: conventions
1100 - Redundant grouping parentheses (i.e. parentheses that does not affect evaluation) may be used if they improve readability.
1101 - Redundant grouping parentheses should typically be left out in shorter expressions involving common operators but included in longer expressions or expressions involving operators whose precedence and associativity is unclear without parentheses. Ternary expressions with non-trivial conditions belong to the latter.
1102 - The entire expression following a return keyword must not be surrounded by parentheses.
1103 :::
1104 
1105 ::: leftcol
1106 ::: box
1107 [Dos]{.boxheader .dos}
1108 
1109 ~~~java
1110 return flag ? &quot;yes&quot; : &quot;no&quot;;
1111 ~~~
1112 
1113 ~~~java
1114 String cmp = (flag1 != flag2) ? &quot;not equal&quot; : &quot;equal&quot;;
1115 ~~~
1116 
1117 :::
1118 :::
1119 
1120 ::: rightcol
1121 ::: box
1122 [Don’ts]{.boxheader .donts}
1123 
1124 ~~~java
1125 return (flag ? &quot;yes&quot; : &quot;no&quot;);
1126 ~~~
1127 
1128 :::
1129 :::
1130 
1131 
1132 ### Literals
1133 ::: conventions
1134 - `long` literals should use the upper case letter `L` suffix.
1135 - Hexadecimal literals should use upper case letters `A`-`F`.
1136 - All other numerical prefixes, infixes, and suffixes should use lowercase letters.
1137 :::
1138 
1139 ::: leftcol
1140 ::: box
1141 [Dos]{.boxheader .dos}
1142 
1143 ~~~java
1144 long l = 5432L;
1145 int i = 0x123 + 0xABC;
1146 byte b = 0b1010;
1147 float f1 = 1 / 5432f;
1148 float f2 = 0.123e4f;
1149 double d1 = 1 / 5432d;  // or 1 / 5432.0
1150 double d2 = 0x1.3p2;
1151 ~~~
1152 
1153 :::
1154 :::
1155 
1156 ::: rightcol
1157 ::: box
1158 [Don’ts]{.boxheader .donts}
1159 
1160 ~~~java
1161 long l = 5432l;
1162 int i = 0X123 + 0xabc;
1163 byte b = 0B1010;
1164 float f1 = 1 / 5432F;
1165 float f2 = 0.123E4f;
1166 double d1 = 1 / 5432D;
1167 double d2 = 0x1.3P2;
1168 ~~~
1169 
1170 :::
1171 :::
1172 
1173 
1174 ::: box
1175 [Motivation]{.boxheader}
1176 Lower case L resembles a 1 in many monospace fonts which means that the literal `5432l` can be confused with `54321`. Using upper case `L` suffix avoids this. The lowercase `0x`, `0b`, `e`, `p`, `f`, and `d` characters are easier to spot in a long sequence of digits, and they avoid confusion with the hexadecimal digits `A`-`F`.
1177 :::
1178 
1179 ## Naming
1180 ::: conventions
1181 - Avoid hiding/shadowing methods, variables and type variables in outer scopes.
1182 - Let the verbosity of the name correlate to the size of the scope. (For instance, use descriptive names for fields of large classes and brief names for local short-lived variables.)
1183 - When naming public static members, let the identifier be self descriptive if you believe they will be statically imported.
1184 :::
1185 
1186 ### Package Names
1187 ::: conventions
1188 - Package names should be all lower case without underscores or other special characters.
1189 - Don’t use plural form. Follow the convention of the standard API which uses for instance `java.lang.annotation` and not `java.lang.annotations`.
1190 :::
1191 
1192 ### Class, Interface and Enum Names
1193 ::: conventions
1194 - Class and enum names should typically be nouns.
1195 - Interface names should typically be nouns or adjectives ending with *…able*.
1196 - Use mixed case with the first letter in each word in upper case.
1197 - Use whole words and avoid using abbreviations unless the abbreviation is more widely used than the long form.
1198 - Format an abbreviation as a word if the it is part of a longer class name.
1199 :::
1200 
1201 ::: leftcol
1202 ::: box
1203 [Dos]{.boxheader .dos}
1204 
1205 ~~~java
1206 class EmptyCell {
1207     …
1208 }
1209 ~~~
1210 
1211 ~~~java
1212 class RunningMode {
1213     …
1214 }
1215 ~~~
1216 
1217 ~~~java
1218 interface Expandable {
1219     …
1220 }
1221 ~~~
1222 
1223 ~~~java
1224 class XmlParser {
1225     …
1226 }
1227 ~~~
1228 
1229 :::
1230 :::
1231 
1232 ::: rightcol
1233 ::: box
1234 [Don’ts]{.boxheader .donts}
1235 
1236 ~~~java
1237 class Empty {
1238     …
1239 }
1240 ~~~
1241 
1242 ~~~java
1243 class Running {
1244     …
1245 }
1246 ~~~
1247 
1248 ~~~java
1249 class Expandable {
1250     …
1251 }
1252 ~~~
1253 
1254 ~~~java
1255 // Abbreviation should be formatted as &#39;Xml&#39;
1256 class XMLParser {
1257     …
1258 }
1259 ~~~
1260 
1261 :::
1262 :::
1263 
1264         
1265 ### Method Names
1266 ::: conventions
1267 - Method names should typically be verbs or other descriptions of actions.
1268 - Use mixed case with the first letter in lower case.
1269 :::
1270 
1271 ::: leftcol
1272 ::: box
1273 [Dos]{.boxheader .dos}
1274 
1275 ~~~java
1276 public void expand() {
1277     …
1278 }
1279 ~~~
1280 
1281 ~~~java
1282 public boolean isExpanding() {
1283     …
1284 }
1285 ~~~
1286 
1287 ~~~java
1288 public State getState() {
1289     …
1290 }
1291 ~~~
1292 
1293 :::
1294 :::
1295 
1296 ::: rightcol
1297 ::: box
1298 [Don’ts]{.boxheader .donts}
1299 
1300 ~~~java
1301 public boolean expanding() {
1302     …
1303 }
1304 ~~~
1305 
1306 ~~~java
1307 public State GetState() {
1308     …
1309 }
1310 ~~~
1311 
1312 ~~~java
1313 public int get_index() {
1314     …
1315 }
1316 ~~~
1317 
1318 :::
1319 :::
1320 
1321 
1322 
1323 ### Variables
1324 ::: conventions
1325 - Variable names should be in mixed case with the first letter in lower case.
1326 :::
1327 
1328 ::: leftcol
1329 ::: box
1330 [Dos]{.boxheader .dos}
1331 
1332 ~~~java
1333 int currentIndex;
1334 boolean dataAvailable;
1335 ~~~
1336 
1337 :::
1338 :::
1339 
1340 ::: rightcol
1341 ::: box
1342 [Don’ts]{.boxheader .donts}
1343 
1344 ~~~java
1345 int current_index;
1346 boolean DataAvailable;
1347 ~~~
1348 
1349 :::
1350 :::
1351 
1352 
1353 ### Type Variables
1354 ::: conventions
1355 - For simple cases where there are few type variables involved use a single upper case letter.
1356 - If one letter is more descriptive than another (such as `K` and `V` for keys and values in maps or `R` for a function return type) use that, otherwise use `T`.
1357 - For complex cases where single letter type variables become confusing, use longer names written in all capital letters and use underscore (`_`) to separate words.
1358 :::
1359 
1360 ::: leftcol
1361 ::: box
1362 [Dos]{.boxheader .dos}
1363 
1364 ~~~java
1365 interface SpecialMap&lt;K, V&gt; extends Map&lt;K, V&gt; {
1366     …
1367 }
1368 ~~~
1369 
1370 ~~~java
1371 class GraphMapper&lt;SRC_VERTEX, SRC_EDGE, DST_VERTEX, DST_EDGE&gt; {
1372     …
1373 }
1374 ~~~
1375 
1376 :::
1377 :::
1378 
1379 ::: rightcol
1380 ::: box
1381 [Don’ts]{.boxheader .donts}
1382 
1383 ~~~java
1384 interface SpecialMap&lt;Key, Value&gt; extends Map&lt;Key, Value&gt; {
1385     …
1386 }
1387 ~~~
1388 
1389 ~~~java
1390 class GraphMapper&lt;S, T, U, V&gt; {
1391     …
1392 }
1393 ~~~
1394 
1395 :::
1396 :::
1397 
1398 
1399 ### Constants
1400 ::: conventions
1401 - Constants (static final fields whose content is immutable, by language rules or by convention) should be named with all capital letters and underscore (`_`) to separate words.
1402 :::
1403 
1404 ::: leftcol
1405 ::: box
1406 [Dos]{.boxheader .dos}
1407 
1408 ~~~java
1409 public static final int BUFFER_SIZE = 1024;
1410 ~~~
1411 
1412 ~~~java
1413 enum ApplicationMode { RUNNING, PAUSED, TERMINATED }
1414 ~~~
1415 
1416 :::
1417 :::
1418 
1419 ::: rightcol
1420 ::: box
1421 [Don’ts]{.boxheader .donts}
1422 
1423 ~~~java
1424 public final List&lt;String&gt; CURRENT_WORDS = new ArrayList&lt;&gt;();
1425 ~~~
1426 
1427 ~~~java
1428 enum ApplicationMode { Running, Paused, Terminated }
1429 ~~~
1430 
1431 :::
1432 :::
1433 
1434 
1435 ## Programming Practices
1436 The focus of the guidelines in this section is on style. General guidelines on best programming practices, use of design patterns, how to structure programs etc is thus out of scope.&amp;nbsp;A few “low level” practices that are easy to pin down is however good to agree upon.
1437 
1438 ::: conventions
1439 - Always use `@Override` where it is possible to do so.
1440 - Document any non-obvious pre and post conditions (also for private methods). In particular, all parameters / return values are assumed to be non-null unless explicitly stated otherwise.
1441 - Avoid checking in “`TODO`” comments. If the missing code doesn’t affect correctness or performance, skip the comment, otherwise file an issue for it.
1442 - Avoid checking in dead code.
1443 - Static mutable state should be used judiciously. In particular enums should not have mutable state, and any public static variable must also be final.
1444 - Static methods and fields that are accessed out of scope should be qualified with the identifier of the class that declares them and not with a subclass or an instance variable.
1445 - Fall through on non-empty cases in switch statements should be documented, typically with a “`// fall through`” comment.
1446 - Mutating method parameters is discouraged. This is because parameters are typically associated with the input values and by mutating these the code may be harder to understand, especially when only looking at parts of the method below the mutation.
1447 - Keep methods short. Consider splitting up long methods into smaller ones to limit variable scopes and simplify structure of the code.
1448 :::
1449 
1450 ### Commenting Code
1451 ::: conventions
1452 - First and foremost, try to make the code simple enough that it’s self explanatory. While comments explaining the code are good, not having to explain the code is better.
1453 - For single line comments, use end-of-line comments (`//`) otherwise use multiline comments (`/* … */`).
1454 - Avoid comments that run the risk of getting out of sync as the code evolves. (If a comment runs the risk of getting out of sync, it’s often a sign that it comments how the code works rather than what the code achieves.)
1455 - Small well documented methods are preferred over longer methods with comments in the body of the method.
1456 - Don’t check in code that’s commented out.
1457 - IDE/tool-specific comments should be avoided wherever possible, especially when there are reasonable alternatives, such as external settings files, etc.
1458 - Comments should be grammatically correct and follow general recommendations of technical writing.
1459 - Start longer Javadoc comments with a short summarizing sentence since Javadoc includes this in the method summary table.
1460 - Prefer inline tags (such as `{@code …}` and `{@link …}` etc) over corresponding HTML tags (`&lt;code&gt;…&lt;/code&gt;`, `&lt;a href=&quot;…&quot;&gt;…&lt;/a&gt;` etc).
1461 - Use `&lt;p&gt;` to separate paragraphs (closing `&lt;/p&gt;` tags are not needed and should not be used)
1462 :::
1463 
1464 ::: leftcol
1465 ::: box
1466 [Dos]{.boxheader .dos}
1467 
1468 ~~~java
1469 /** A short javadoc comment */
1470 ~~~
1471 
1472 ~~~java
1473 /**
1474  * …
1475  *
1476  * &lt;blockquote&gt;{@code
1477  *     List&lt;String&gt; names;
1478  * }&lt;/blockquote&gt;
1479  */
1480 ~~~
1481 
1482 :::
1483 :::
1484 
1485 ::: rightcol
1486 ::: box
1487 [Don’ts]{.boxheader .donts}
1488 
1489 ~~~java
1490 /** put on single line instead
1491  */
1492 ~~~
1493 
1494 ~~~java
1495 /**
1496  * The &lt;String&gt; below may interfere with the HTML!
1497  *
1498  * &lt;blockquote&gt;&lt;pre&gt;
1499  *     List&lt;String&gt; names;
1500  * &lt;/pre&gt;&lt;/blockquote&gt;
1501  */
1502 ~~~
1503 
1504 :::
1505 :::
1506 
1507 For a complete Javadoc reference refer to &amp;nbsp;[How to Write Doc Comments for the Javadoc Tool](http://www.oracle.com/technetwork/articles/java/index-137868.html).
1508 
1509 ## When to reformat code
1510 ::: conventions
1511 - Do not reformat code in files unrelated to the current changeset, even if the code doesn’t adhere to the guidelines.
1512 - Minor cleanups in files that are already touched for other reasons are fine. Put the cleanups in a separate patch if you think it will simplify the review process. Large cleanups should always go in a separate changeset.
1513 :::
1514 
1515 ::: box
1516 [Motivation]{.boxheader}
1517 Cleaning up code that’s unrelated to the patch may…
1518 - Complicate the review of the patch in which case correctness may suffer
1519 - Run the risk of breaking existing code
1520 - Have a downstream impact, e.g. affect ports to other versions.
1521 - Trigger an unnecessary debate (perhaps the original formatting was intentional).
1522 :::
1523 
1524 ## Cases not covered
1525 ::: conventions
1526 - If some aspect is not covered by these guidelines one should fall back on the style of the surrounding code within the same file, within the package or within the project in that order.
1527 :::
1528 
1529 ::: {.NavBit}
1530 [« Previous](mailinglists.html) • [TOC](index.html) • [Next »](changePlanning.html)
1531 :::
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/javaStyleGuide.md</title>
    <link rel="stylesheet" href="../style.css" />
  </head>
  <body>
    <pre>
   1 % Java Style Guide
   2 
   3 ::: {.NavBit}
   4 [« Previous](mailinglists.html) • [TOC](index.html) • [Next »](changePlanning.html)
   5 :::
   6 
   7 While this document covers a lot of ground, it should be noted that no style guide can answer all questions for us, and developers will always need to use good judgment towards the end of producing code that is correct, readable, maintainable, debuggable, consistently formatted, and aesthetically pleasing.
   8 
   9 Examples in this document are non-normative; While they intend to illustrate correct way of formatting the code, there may be other ways to correctly format the code. This is a general principle: There may be several ways to format the code, all adhering to the guidelines in this document.
  10 
  11 Tool support is nice, but ultimately each IDE and style checking tool can handle different sets of rules, and support for rules that can’t be handled today might be added in future versions. So, whether a rule plays well with tools or not can be a factor, but it’s secondary to the above principles.
  12 
  13 ## Overview
  14 
  15 - [Java Source Files](#java-source-files)  
  16   - [Special Characters](#special-characters)  
  17 - [Formatting](#formatting)  
  18   - [Copyright notice](#copyright-notice)  
  19   - [Package declaration](#package-declaration)  
  20   - [Import statements](#import-statements)  
  21   - [Class Structure](#class-structure)  
  22   - [Modifiers](#modifiers)  
  23   - [Braces](#braces)  
  24   - [Indentation](#indentation)  
  25   - [Wrapping Lines](#wrapping-lines)  
  26   - [Whitespace](#whitespace)  
  27   - [Variable Declarations](#variable-declarations)  
  28   - [Annotations](#annotations)  
  29   - [Lambda Expressions](#lambda-expressions)  
  30   - [Redundant Parentheses](#redundant-parentheses)  
  31   - [Literals](#literals)  
  32   - [Javadoc](#javadoc)  
  33 - [Naming](#naming)  
  34   - [Package Names](#package-names)  
  35   - [Class, Interface and Enum Names](#class-interface-and-enum-names)  
  36   - [Method Names](#method-names)  
  37   - [Variables](#variables)  
  38   - [Type Variables](#type-variables)  
  39   - [Constants](#constants)  
  40 - [Programming Practices](#programming-practices)  
  41   - [Commenting Code](#commenting-code)  
  42 - [When to reformat code](#when-to-reformat-code)  
  43 - [Cases not covered](#cases-not-covered)  
  44 
  45 ## Java Source Files
  46 This section concerns ordinary `.java` files only. Rules do not necessarily apply to other source files such as `.jasm`, `.sh` or `.gmk`.
  47 
  48 ::: conventions
  49 - Source files must be encoded in 7-bit ASCII.
  50 - All lines must be terminated with a line feed character (`LF`, ASCII value 10) and *not* for instance `CR` or `CR`+`LF`.
  51 - There may be no trailing white space at the end of a line.
  52 - The name of a source file must equal the name of the class it contains followed by the `.java` extension, even for files that only contain a package private class. This does not apply to files that do not contain any class declarations, such as `package-info.java`.
  53 :::
  54 
  55 ::: box
  56 [Motivation]{.boxheader}
  57 7-bit ASCII reduces errors due to confusion of characters since there are no invisible spaces, characters that look like minus signs but are really dashes, etc. It also ensures packages and classes are named in such way that the corresponding directories and source files are portable across different filesystems.
  58   
  59 Agreeing on a common line delimiter character is important since different operating systems have different defaults. Editing a file on Windows that was originally written on Linux, may cause all `LF` to be saved back as `CR`+`LF`. This creates unnecessarily big patches and may not display correctly in the text editor it was originally written in. A single line feed character is default for Unix-like systems and supported by all common text editors and IDEs.
  60 
  61 Trailing white space is nothing but unnecessary cruft. It’s easy to remove and agreeing on doing so consistently minimizes diffs.
  62 
  63 Not using the name of the class as filename can be confusing. Also, unless the file is given explicitly to the compiler, the class it contains may not be resolved correctly.
  64 :::
  65 
  66 ### Special Characters
  67 ::: conventions
  68 - Apart from `LF` the only allowed white space character is Space (ASCII value 32). Note that this implies that other white space characters (in, for instance, string and character literals) must be written in escaped form.
  69 - `\&#39;`, `\&quot;`, `\\`, `\t`, `\b`, `\r`, `\f`, and `\n` should be preferred over corresponding octal (e.g. `\047`) or Unicode (e.g. `\u0027`) escaped characters.
  70 - Should there be a need to go against the above rules for the sake of testing, the test should generate the required source.
  71 :::
  72 
  73 ::: box
  74 [Motivation]{.boxheader}
  75 Having any white space character but space and `LF` in the source code can be a source of confusion.
  76 
  77 The short forms (e.g. `\t`) are commonly used and easier to recognize than the corresponding longer forms (`\011`, `\u0009`).
  78 :::
  79 
  80 ## Formatting
  81 ::: conventions
  82 - A Java source file should be structured as follows:
  83   1. The copyright notice
  84   1. Package declaration
  85   1. Import statements
  86   1. Class declaration
  87 - There may be only one top level class declaration per file.
  88 :::
  89 
  90 ### Copyright notice
  91 ::: conventions
  92 - All source files should have an appropriate copyright notice at the top of the file.
  93 
  94 - For files under Oracle copyright, the copyright notice must follow the standard wording and format. In particular the first two lines should be
  95 
  96   ```java
  97   /*
  98    * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
  99   ```
 100   or
 101   ```java
 102   /*
 103    * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
 104   ```
 105   where the first year is the year the file was created and the second year is the year the file was last edited.
 106 :::
 107 
 108 For questions regarding Oracle copyright or license notices, please contact [iris.clark@oracle.com](mailto:iris.clark@oracle.com).
 109 
 110 ### Package declaration
 111 ::: conventions
 112 - The package declaration should not be line wrapped, regardless of whether it exceeds the recommended maximum length of a line. (See section on [Wrapping Lines](#wrapping-lines).)
 113 :::
 114 
 115 ### Import statements
 116 ::: conventions
 117 - Import statements should be sorted…
 118   - …primarily by non-static / static with non-static imports first.
 119   - …secondarily by package origin according to the following order
 120     - `java` packages
 121     - `javax` packages
 122     - external packages (e.g. `org.xml`)
 123     - internal packages (e.g. `com.sun`)
 124   - …tertiary by package and class identifier in lexicographical order
 125 - Import statements should not be line wrapped, regardless of whether it exceeds the recommended maximum length of a line.
 126 - No unused imports should be present.
 127 :::
 128 
 129 #### Wildcard Imports
 130 ::: conventions
 131 - Wildcard imports should in general not be used.
 132 - When importing a large number of closely-related classes (such as implementing a visitor over a tree with dozens of distinct “node” classes), a wildcard import may be used.
 133 - In any case, no more than one wildcard import per file should be used.
 134 :::
 135 
 136 ::: box
 137 [Motivation]{.boxheader}
 138 Wildcard imports makes it unclear what actually needs to be imported.
 139 
 140 Having more than one wildcard import makes the code fragile since adding a new class in one of the imported packages can introduce a name clash.
 141 
 142 An unused import gives a false impression of a dependency. Also, many IDEs list such import statements as warnings which clutters the list of problems.
 143 :::
 144 
 145 ### Class Structure
 146 ::: conventions
 147 - The recommended order of class members is the following:
 148   1. Fields
 149   1. Constructors
 150   1. Factory methods
 151   1. Other Methods
 152 - Related fields should be grouped together. Ordering fields primarily according to access modifiers or identifier is not required. The same applies to methods.
 153 - Nested types should be grouped at the top of the class, or else defined before first use.
 154 :::
 155 
 156 #### Order of Constructors and Overloaded Methods
 157 ::: conventions
 158 - Constructors and overloaded methods should be grouped together by functionality and ordered with increasing arity. This implies that delegation among these constructs flow downward in the code.
 159 - Constructors and overloaded methods should generally not be split apart by other members.
 160 :::
 161 
 162 ::: leftcol
 163 ::: box
 164 [Dos]{.boxheader .dos}
 165 ```java
 166 public HashSet() {
 167     this(DEFAULT_INITIAL_CAPACITY);
 168 }
 169 
 170 public HashSet(int capacity) {
 171     this(capacity, DEFAULT_LOAD_FACTOR);
 172 }
 173 
 174 public HashSet(int capacity, double loadFactor) {
 175     …
 176 }
 177 ```
 178 :::
 179 :::
 180 
 181 ::: rightcol
 182 ::: box
 183 [Don’ts]{.boxheader .donts}
 184 ```java
 185 // Overloaded methods should not be split apart
 186 void logValue(int i) {
 187     log(&quot;Int: %d&quot;, i);
 188 }
 189 
 190 void setValue(int i) {
 191     val = i;
 192 }
 193 
 194 void logValue(double d) {
 195     log(&quot;Double: %.2d&quot;, d);
 196 }
 197 
 198 void setValue(double d) {
 199     val = d;
 200 }
 201 ```
 202 :::
 203 :::
 204 
 205 ::: box
 206 [Motivation]{.boxheader}
 207 This order puts the most generally applicable versions first. Also, making sure delegation is always done downwards in the file makes the code easier to follow.
 208 :::
 209 
 210 ### Modifiers
 211 ::: conventions
 212 - Modifiers should go in the following order
 213   1. Access modifier (`public` / `private` / `protected`)
 214   1. `abstract`
 215   1. `static`
 216   1. `final`
 217   1. `transient`
 218   1. `volatile`
 219   1. `default`
 220   1. `synchronized`
 221   1. `native`
 222   1. `strictfp`
 223 - Modifiers should not be written out when they are implicit. For example, interface methods should neither be declared public nor abstract, and nested enums and interfaces should not be declared static.
 224 - Method parameters and local variables should not be declared final unless it improves readability or documents an actual design decision.
 225 - Fields should be declared final unless there is a compelling reason to make them mutable.
 226 :::
 227 
 228 ::: box
 229 [Motivation]{.boxheader}
 230 Writing out modifiers where they are implicit clutters the code and learning which modifiers are implicit where is easy.
 231 
 232 Although method parameters should typically not be mutated, consistently marking all parameters in every methods as `final` is an exaggeration.
 233 
 234 Making fields immutable where possible is good programming practice. Refer to *Effective Java, Item 15: Minimize Mutability* for details.
 235 :::
 236 
 237 ### Braces
 238 ::: conventions
 239 - Opening braces should be put on the end of the current line rather than on a line by its own.
 240 - There should be a new line in front of a closing brace unless the block is empty (see [Short Forms](#short-forms) below)
 241 - Braces are recommended even where the language makes them optional, such as single-line if and loop bodies.
 242   - If a block spans more than one line (including comments) it must have braces.
 243   - If one of the blocks in a if / else statement has braces, the other block must too.
 244   - If the block comes last in an enclosing block, it must have braces.
 245 - The `else`,&amp;nbsp;`catch` and the `while` keyword in `do`…`while` loops go on the same line as the closing brace of the preceding block.
 246 :::
 247 
 248 ::: leftcol
 249 ::: box
 250 [Dos]{.boxheader .dos}
 251 ```java
 252 void method() {
 253     …
 254 }
 255 ```
 256 ```java
 257 try {
 258     something();
 259 } catch (AnException e) {
 260     …
 261 }
 262 ```
 263 ```java
 264 for (int[] row : matrix) {
 265     for (int val : row) {
 266         sum += val;
 267     }
 268 }
 269 ```
 270 :::
 271 :::
 272 
 273 ::: rightcol
 274 ::: box
 275 [Don’ts]{.boxheader .donts}
 276 ```java
 277 // Wrong placement of opening brace
 278 void method()
 279 {
 280     …
 281 }
 282 ```
 283 ```java
 284 // Newline in front of catch should be avoided
 285 try {
 286     something();
 287 }
 288 catch (AnException e) {
 289     …
 290 }
 291 ```
 292 ```java
 293 // Braces should be used
 294 if (flag)
 295     // Restore x
 296     x = 1;
 297 ```
 298 ```java
 299 // Use braces if block comes last in enclosing block
 300 // to avoid accidentally indenting the closing brace.
 301 for (int[] row : matrix) {
 302     for (int val : row)
 303         sum += val;
 304 }
 305 ```
 306 :::
 307 :::
 308 
 309 ::: box
 310 [Motivation]{.boxheader}
 311 Putting opening braces on the end of the line (as opposed to on a line of its own) is a long standing Java convention. This style is also suitable for Java, considering that it’s common to have small blocks (in for instance anonymous classes and lambda expressions) and having opening braces on a separate line creates an unnecessary amount of white space in such situations.
 312 
 313 Omitting braces is error prone and can lead to mistakes in the indentation and hard to detect bugs.
 314 :::
 315 
 316 #### Short Forms
 317 ::: conventions
 318 - The above recommendations are intended to improve uniformity (and thus increase familiarity / readability). In some cases “short forms” that deviate from the above guidelines are just as readable and may be used instead. These cases include for instance simple enum declarations and trivial methods and lambda expressions.
 319 :::
 320 
 321 
 322 ::: leftcol
 323 ::: box
 324 [Dos]{.boxheader .dos}
 325 ```java
 326 enum Response { YES, NO, MAYBE }
 327 ```
 328 ```java
 329 public boolean isReference() { return true; }
 330 ```
 331 :::
 332 :::
 333 
 334 ::: rightcol
 335 ::: box
 336 [Don’ts]{.boxheader .donts}
 337 ```java
 338 public boolean getResult() { int value = getValue(); return value &lt; 0 ? 0 : value; }
 339 ```
 340 ```java
 341 for (int i = 0; i &lt; size; i++) { sum += data[i]; }
 342 ```
 343 :::
 344 :::
 345 
 346 
 347 ### Indentation
 348 ::: conventions
 349 - Indentation level is four spaces.
 350 - Only space characters may be used for indentation. No tabs.
 351 - Empty lines must not be indented. (This is implied by the no trailing white space rule.)
 352 - `case` lines should be indented with four spaces, and statements within the case should be indented with another four spaces.
 353 :::
 354 Refer to Section&amp;nbsp;[Wrapping Lines](#wrapping-lines)&amp;nbsp;for guidelines on how to indent continuation lines.
 355 
 356 ::: leftcol
 357 ::: box
 358 [Dos]{.boxheader .dos}
 359 ```java
 360 switch (var) {
 361     case TWO:
 362         setChoice(&quot;two&quot;);
 363         break;
 364     case THREE:
 365         setChoice(&quot;three&quot;);
 366         break;
 367     default:
 368         throw new IllegalArgumentException();
 369 }
 370 ```
 371 :::
 372 :::
 373 
 374 ::: rightcol
 375 ::: box
 376 [Don’ts]{.boxheader .donts}
 377 ```java
 378 switch (var) {
 379 case TWO:
 380     setChoice(&quot;two&quot;);
 381     break;
 382 case THREE:
 383     setChoice(&quot;three&quot;);
 384     break;
 385 default:
 386     throw new IllegalArgumentException();
 387 }
 388 ```
 389 :::
 390 :::
 391 
 392 
 393 ::: box
 394 [Motivation]{.boxheader}
 395 By using spaces for indentation, problems regarding different default settings for tab stops in various editors are avoided.
 396 :::
 397 
 398 ### Wrapping Lines
 399 ::: conventions
 400 - Source code and comments should generally not exceed 80 characters per line and rarely if ever exceed 100 characters per line, including indentation.
 401 
 402   ::: box
 403   ::: boxheader
 404   Note
 405   :::
 406   The character limit must be judged on a case by case basis. What really matters is the semantical “density” and readability of the line. Making lines gratuitously long makes them hard to read; similarly, making “heroic attempts” to fit them into 80 columns can also make them hard to read. The flexibility outlined here aims to enable developers to avoid these extremes, not to maximize use of monitor real-estate.
 407   :::
 408 
 409   ::: leftcol
 410   ::: box
 411   ::: {.boxheader .dos}
 412   Dos
 413   :::
 414   ```java
 415   // Ok even though it might exceed the character limit when indented.
 416   Error e = isTypeParam
 417           ? Errors.InvalidRepeatableAnnotationNotApplicable(targetContainerType, on)
 418           : Errors.InvalidRepeatableAnnotationNotApplicableInContext(targetContainerType));
 419   ```
 420   ```java
 421   String pretty = Stream.of(args)
 422                         .map(Argument::prettyPrint)
 423                         .collectors(joining(&quot;, &quot;));
 424   ```
 425   :::
 426   :::
 427 
 428   ::: rightcol
 429   ::: box
 430   ::: {.boxheader .donts}
 431   Don’ts
 432   :::
 433   ```java
 434   // Too strict interpretation of the character limit. Readability suffers.
 435   Error e = isTypeParam
 436         ? Errors.InvalidRepeatableAnnotationNotApplicable(
 437                 targetContainerType, on)
 438         : Errors.InvalidRepeatableAnnotationNotApplicableInContext(
 439                 targetContainerType);
 440   ```
 441   ```java
 442   // Should be wrapped even though it fits within the character limit
 443   String pretty = Stream.of(args).map(Argument::prettyPrint).collectors(joining(&quot;, &quot;));
 444   ```
 445   :::
 446   :::
 447 
 448   ::: clear-floats
 449   :::
 450 
 451 - URLs or example commands should not be wrapped.
 452 - Wrapping at a higher syntactical level is preferred over wrapping at a lower syntactical level.
 453 
 454   ::: leftcol
 455   ::: box
 456   ::: {.boxheader .dos}
 457   Dos
 458   :::
 459   ```java
 460   aMethodCall(withMany(arguments, that, needs),
 461           to(be, (wrapped - to) * avoid / veryLong - lines));
 462   ```
 463   :::
 464   :::
 465 
 466   ::: rightcol
 467   ::: box
 468   ::: {.boxheader .donts}
 469   Don’ts
 470   :::
 471   ```java
 472   aMethodCall(withMany(arguments, that, needs), to(be, (wrapped
 473           - to) * avoid / veryLong - lines));
 474   ```
 475   :::
 476   :::
 477 
 478   ::: clear-floats
 479   :::
 480 
 481 - There should be at most 1 statement per line.
 482 
 483   ::: leftcol
 484   ::: box
 485   ::: {.boxheader .dos}
 486   Dos
 487   :::
 488   ```java
 489   i += j;
 490   j += k;
 491   ```
 492   ```java
 493   if (condition) {
 494       return expression;
 495   }
 496   ```
 497   :::
 498   :::
 499 
 500   ::: rightcol
 501   ::: box
 502   ::: {.boxheader .donts}
 503   Don’ts
 504   :::
 505   ```java
 506   i += j; j += k;
 507   ```
 508   ```java
 509   if (condition) { return expression; }
 510   ```
 511   :::
 512   :::
 513 
 514   ::: clear-floats
 515   :::
 516 
 517 - A continuation line should be indented in one of the following four ways
 518   - **Variant 1:** With 8 extra spaces relative to the indentation of the previous line.
 519   - **Variant 2:** With 8 extra spaces relative to the starting column of the wrapped expression.
 520   - **Variant 3:** Aligned with previous sibling expression (as long as it is clear that it’s a continuation line)
 521   - **Variant 4:** Aligned with previous method call in a chained expression.
 522 
 523   ::: leftcol
 524   ::: box
 525   ::: {.boxheader .dos}
 526   Dos
 527   :::
 528   ```java
 529   // Variant 1
 530   int anInteger = aMethod(that, takes,
 531           a, lengthy, list, of, arguments);
 532   ```
 533   ```java
 534   // Variant 2
 535   int anInteger = that * (is + computed) / using
 536                           + a * complex - expression;
 537   ```
 538   ```java
 539   // Variant 3
 540   int anInteger = aMethod(thatTakes,
 541                           aLongList,
 542                           ofArguments);
 543   ```
 544   ```java
 545   // Variant 4
 546   int anInteger = IntStream.of(numbers)
 547                            .map(Math::sqrt)
 548                            .sum();
 549   ```
 550   :::
 551   :::
 552 
 553   ::: rightcol
 554   ::: box
 555   ::: {.boxheader .donts}
 556   Don’ts
 557   :::
 558   ```java
 559   // Mixing of wrapping variants (unless there
 560   // is a logical grouping of arguments)
 561   int anInteger = aMethod(that,
 562                           takes,
 563                           a, lengthy, list,
 564                           of, arguments);
 565   ```
 566   ```java
 567   // Don&#39;t align with sibling expression if the
 568   // continuation line can be confused with a block
 569   // indentation
 570   if (somePredicate() ||
 571       someOtherPredicate()) {
 572       System.out.println(&quot;Avoid&quot;);
 573   }
 574   ```
 575   :::
 576   :::
 577 
 578   ::: clear-floats
 579   :::
 580 :::
 581 
 582 #### Wrapping Class Declarations
 583 ::: conventions
 584 - A class header should not be wrapped unless it approaches the maximum column limit.
 585 - If it does, it may be wrapped before `extends` and/or `implements` keywords.
 586 - Declarations of type parameters may, if necessary, be wrapped the same way as method arguments
 587 :::
 588 
 589 ::: leftcol
 590 ::: box
 591 [Dos]{.boxheader .dos}
 592 ```java
 593 public class MyGenericClass&lt;T, S&gt;
 594         extends HashMap&lt;T, S&gt;
 595         implements Comparable&lt;T&gt; {
 596     …
 597 }
 598 ```
 599 ```java
 600 public class AnotherClass&lt;K, R&gt; implements Collector&lt;T extends K,
 601                                                      Set&lt;? extends R&gt;,
 602                                                      List&lt;R&gt;&gt; {
 603     …
 604 }
 605 ```
 606 ```java
 607 public class AnotherClass&lt;K, R&gt; implements Collector&lt;T extends K,
 608                                                      Set&lt;? extends R&gt;,
 609                                                      List&lt;R&gt;&gt; {
 610     …
 611 }
 612 ```
 613 :::
 614 :::
 615 
 616 ::: rightcol
 617 ::: box
 618 [Don’ts]{.boxheader .donts}
 619 ```java
 620 public class MyGenericClass&lt;T&gt; implements Comparable&lt;T&gt;,
 621         Predicate&lt;T&gt; {
 622     …
 623 }
 624 ```
 625 :::
 626 :::
 627 
 628 
 629 #### Wrapping Method Declarations
 630 ::: conventions
 631 - Method declarations can be formatted by listing the arguments vertically, or by a new line and +8 extra spaces
 632 - If a throws clause needs to be wrapped, put the line break in front of the throws clause and make sure it stands out from the argument list, either by indenting +8 relative to the function declaration, or +8 relative to the previous line.
 633 :::
 634 
 635 ::: leftcol
 636 ::: box
 637 [Dos]{.boxheader .dos}
 638 ```java
 639 int someMethod(String aString,
 640                List&lt;Integer&gt; aList,
 641                Map&lt;String, String&gt; aMap,
 642                int anInt,
 643                long aLong,
 644                Set&lt;Number&gt; aSet,
 645                double aDouble) {
 646     …
 647 }
 648 ```
 649 ```java
 650 int someMethod(String aString, List&lt;Integer&gt; aList,
 651         Map&lt;String, String&gt; aMap, int anInt, long aLong,
 652         double aDouble, long aLong) {
 653     …
 654 }
 655 ```
 656 ```java
 657 int someMethod(String aString,
 658                List&lt;Map&lt;Integer, StringBuffer&gt;&gt; aListOfMaps,
 659                Map&lt;String, String&gt; aMap)
 660         throws IllegalArgumentException {
 661     …
 662 }
 663 ```
 664 ```java
 665 int someMethod(String aString, List&lt;Integer&gt; aList,
 666         Map&lt;String, String&gt; aMap, int anInt)
 667                 throws IllegalArgumentException {
 668     …
 669 }
 670 ```
 671 :::
 672 :::
 673 
 674 ::: rightcol
 675 ::: box
 676 [Don’ts]{.boxheader .donts}
 677 ```java
 678 // If aligning the parameters vertically, don&#39;t put two
 679 // parameters on one line
 680 int someMethod(String aString,
 681                List&lt;Integer&gt; aList,
 682                Map&lt;String, String&gt; aMap,
 683                int anInt, long aLong,
 684                Set&lt;Number&gt; aSet,
 685                double aDouble) {
 686     …
 687 }
 688 ```
 689 ```java
 690 int someMethod(String aString,
 691                List&lt;Map&lt;Integer, StringBuffer&gt;&gt; aListOfMaps,
 692                Map&lt;String, String&gt; aMap) throws InterruptedException {
 693     …
 694 }
 695 ```
 696 ```java
 697 int someMethod(String aString,
 698                List&lt;Integer&gt; aList,
 699                Map&lt;String, String&gt; aMap)
 700                throws IllegalArgumentException {
 701     …
 702 }
 703 ```
 704 :::
 705 :::
 706 
 707 
 708 #### Wrapping Expressions
 709 ::: conventions
 710 - If a line approaches the maximum character limit, always consider breaking it down into multiple statements / expressions instead of wrapping the line.
 711 - Break before operators.
 712 - Break before the `.` in chained method calls.
 713 :::
 714 
 715 ::: leftcol
 716 ::: box
 717 [Dos]{.boxheader .dos}
 718 ```java
 719 methodCall(a * simple - formula,
 720            some + complex - formula * spanning
 721                         + multiple - lines * may
 722                         + look - as * follows);
 723 ```
 724 ```java
 725 popupMsg(&quot;Inbox notification: You have &quot;
 726         + newMsgs + &quot; new messages&quot;);
 727 ```
 728 ```java
 729 people.stream()
 730       .map(Person::getName)
 731       .forEach(System.out::println);
 732 ```
 733 :::
 734 :::
 735 
 736 ::: rightcol
 737 ::: box
 738 [Don’ts]{.boxheader .donts}
 739 ```java
 740 // Arity unclear
 741 methodCall(a * simple - formula,
 742            some + complex - formula * spanning +
 743            multiple - lines * should + not *
 744            look - as * follows);
 745 ```
 746 ```java
 747 // Looks like two arguments
 748 popupMsg(&quot;Inbox notification: You have &quot; +
 749          newMsgs + &quot; new messages&quot;);
 750 ```
 751 ```java
 752 people.stream().
 753        map(Person::getName).
 754        forEach(System.out::println);
 755 ```
 756 :::
 757 :::
 758 
 759     
 760 ### Whitespace
 761 #### Vertical Whitespace
 762 ::: conventions
 763 - A single blank line should be used to separate…
 764   - Copyright notice
 765   - Package declaration
 766   - Class declarations
 767   - Constructors
 768   - Methods
 769   - Static initializers
 770   - Instance initializers
 771 
 772   …and may be used to separate logical groups of
 773 
 774   - import statements
 775   - fields
 776   - statements
 777 - Multiple consecutive blank lines should only be used to separate groups of related members and not as the standard inter-member spacing.
 778 :::
 779 
 780 #### Horizontal Whitespace
 781 ::: conventions
 782 - A single space should be used…
 783   - To separate keywords from neighboring opening or closing brackets and braces
 784   - Before and after all binary operators and operator like symbols such as arrows in lambda expressions and the colon in enhanced for loops (but not before the colon of a label)
 785   - After `//` that starts a comment.
 786   - After commas separating arguments and semicolons separating the parts of a for loop.
 787   - After the closing parenthesis of a cast.
 788 - In variable declarations it is not recommended to align types and variables.
 789 :::
 790 
 791 ::: leftcol
 792 ::: box
 793 [Dos]{.boxheader .dos}
 794 ```java
 795 int someInt;
 796 String myString;
 797 char aChar;
 798 long sixtyfourFlags;
 799 ```
 800 ```java
 801 if (isFlagSet(GO)) {
 802     …
 803 }
 804 ```
 805 ```java
 806 IntUnaryOperator inc = x -&gt; x + 1;
 807 ```
 808 ```java
 809 init: {
 810     …
 811 }
 812 ```
 813 :::
 814 :::
 815 
 816 ::: rightcol
 817 ::: box
 818 [Don’ts]{.boxheader .donts}
 819 ```java
 820 int    someInt;
 821 String myString;
 822 char   aChar;
 823 long   sixtyfourFlags;
 824 ```
 825 ```java
 826 if( isFlagSet( GO ) ) {
 827     …
 828 }
 829 ```
 830 ```java
 831 IntUnaryOperator inc = x-&gt;x + 1;
 832 ```
 833 ```java
 834 init : {
 835     …
 836 }
 837 ```
 838 :::
 839 :::
 840 
 841 
 842 ::: box
 843 [Motivation]{.boxheader}
 844 The improvement in readability when aligning variable names is negligible compared to the efforts needed to keep them aligned as the code evolves. Realigning all variables when one of the types change also causes unnecessarily complicated patches to review.
 845 :::
 846 
 847 ### Variable Declarations
 848 ::: conventions
 849 - One variable per declaration (and at most one declaration per line)
 850 - Square brackets of arrays should be at the type (`String[] args`) and not on the variable (`String args[]`).
 851 - Declare a local variable right before it is first used, and initialize it as close to the declaration as possible.
 852 :::
 853 
 854 ### Annotations
 855 ::: conventions
 856 - Declaration annotations should be put on a separate line from the declaration being annotated.
 857 - Few/short annotations annotating a single-line method may however be put on the same line as the method if it improves readability.
 858 - Either all annotations should be put on the same line or each annotation should be put on a separate line.
 859 :::
 860 
 861 ::: leftcol
 862 ::: box
 863 [Dos]{.boxheader .dos}
 864 ```java
 865 @Deprecated
 866 @Override
 867 public void foo() {
 868     …
 869 }
 870 ```
 871 ```java
 872 @Deprecated @Override
 873 public void foo() {
 874     …
 875 }
 876 ```
 877 ```java
 878 addListener(new Listener() {
 879  
 880     // Ignored events
 881     @Override public void event1() { }
 882     @Override public void event2() { }
 883     @Override public void event3() { }
 884  
 885     // Important event
 886     @Override
 887     public void event4() {
 888         …
 889     }
 890 });
 891 ```
 892 :::
 893 :::
 894 
 895 ::: rightcol
 896 ::: box
 897 [Don’ts]{.boxheader .donts}
 898 ```java
 899 @Override @Deprecated public void foo() {
 900     …
 901 }
 902 ```
 903 ```java
 904 @Override @Deprecated
 905 @SafeVarargs
 906 public void foo() {
 907     …
 908 }
 909 ```
 910 :::
 911 :::
 912 
 913 
 914 ### Lambda Expressions
 915 ::: conventions
 916 - Expression lambdas are preferred over single-line block lambdas.
 917 - Method references should generally be preferred over lambda expressions.&lt;br /&gt;&lt;br /&gt;
 918   For bound instance method references, or methods with arity greater than one, a lambda expression may be easier to understand and therefore preferred. Especially if the behavior of the method is not clear from the context.
 919 - The parameter types should be omitted unless they improve readability.
 920 - If a lambda expression stretches over more than a few lines, consider creating a method.
 921 :::
 922 
 923 ::: leftcol
 924 ::: box
 925 [Dos]{.boxheader .dos}
 926 ```java
 927 Runnable r = () -&gt; System.out.println(&quot;Hello World&quot;);
 928 ```
 929 ```java
 930 Supplier&lt;String&gt; c = () -&gt; &quot;Hello World&quot;;
 931 ```
 932 ```java
 933 // Collection::contains is a simple unary method and its behavior is
 934 // clear from the context. A method reference is preferred here.
 935 appendFilter(goodStrings::contains);
 936 ```
 937 ```java
 938 // A lambda expression is more readable in this case
 939 // (cf. corresponding example in Don&#39;ts section)
 940 trackTemperature((time, temp) -&gt; tempMap.put(time, temp));
 941 ```
 942 ```java
 943 Function&lt;Person, String&gt; nameFunc = p -&gt; p.getFirstName() + &quot; &quot; + p.getLastName();
 944 ```
 945 ```java
 946 class Util {
 947     private static String getCapitalizedFirstName(Person p) {
 948         String first = p.getFirstName();
 949         char initial = Character.toUpperCase(first.charAt(0));
 950         return initial + first.substring(1);
 951     }
 952  
 953     static void printAllPeople(List&lt;Person&gt; people) {
 954         people.stream()
 955               .map(Util::getCapitalizedFirstName)
 956               .forEach(System.out::println);
 957     }
 958 }
 959 ```
 960 :::
 961 :::
 962 
 963 ::: rightcol
 964 ::: box
 965 [Don’ts]{.boxheader .donts}
 966 ```java
 967 Runnable r = () -&gt; { System.out.println(&quot;Hello World&quot;); };
 968 ```
 969 ```java
 970 Supplier&lt;String&gt; s = () -&gt; { return &quot;Hello World&quot;; };
 971 ```
 972 ```java
 973 // A lambda expression is not needed here
 974 appendFilter(s -&gt; goodStrings.contains(s));
 975 ```
 976 ```java
 977 // Map::put is a binary function, and it’s not clear from context what type
 978 // of argument trackTemperature accepts. A lambda expression is better here.
 979 trackTemperature(tempMap::put);
 980 ```
 981 ```java
 982 // Unnecessary parameter type
 983 Function&lt;Person, String&gt; nameFunc = (Person p) -&gt; p.getFirstName() + &quot; &quot; + p.getLastName();
 984 ```
 985 ```java
 986 class Util {
 987     static void printAllPeople(List&lt;Person&gt; people) {
 988         people.stream()
 989               .map(p -&gt; {
 990                   String first = p.getFirstName();
 991                   char initial = Character.toTitleCase(first.charAt(0));
 992                   return initial + first.substring(1);
 993               })
 994               .forEach(System.out::println);
 995     }
 996 }
 997 ```
 998 :::
 999 :::
1000 
1001 
1002 ### Redundant Parentheses
1003 ::: conventions
1004 - Redundant grouping parentheses (i.e. parentheses that does not affect evaluation) may be used if they improve readability.
1005 - Redundant grouping parentheses should typically be left out in shorter expressions involving common operators but included in longer expressions or expressions involving operators whose precedence and associativity is unclear without parentheses. Ternary expressions with non-trivial conditions belong to the latter.
1006 - The entire expression following a return keyword must not be surrounded by parentheses.
1007 :::
1008 
1009 ::: leftcol
1010 ::: box
1011 [Dos]{.boxheader .dos}
1012 ```java
1013 return flag ? &quot;yes&quot; : &quot;no&quot;;
1014 ```
1015 ```java
1016 String cmp = (flag1 != flag2) ? &quot;not equal&quot; : &quot;equal&quot;;
1017 ```
1018 :::
1019 :::
1020 
1021 ::: rightcol
1022 ::: box
1023 [Don’ts]{.boxheader .donts}
1024 ```java
1025 return (flag ? &quot;yes&quot; : &quot;no&quot;);
1026 ```
1027 :::
1028 :::
1029 
1030 
1031 ### Literals
1032 ::: conventions
1033 - `long` literals should use the upper case letter `L` suffix.
1034 - Hexadecimal literals should use upper case letters `A`-`F`.
1035 - All other numerical prefixes, infixes, and suffixes should use lowercase letters.
1036 :::
1037 
1038 ::: leftcol
1039 ::: box
1040 [Dos]{.boxheader .dos}
1041 ```java
1042 long l = 5432L;
1043 int i = 0x123 + 0xABC;
1044 byte b = 0b1010;
1045 float f1 = 1 / 5432f;
1046 float f2 = 0.123e4f;
1047 double d1 = 1 / 5432d;  // or 1 / 5432.0
1048 double d2 = 0x1.3p2;
1049 ```
1050 :::
1051 :::
1052 
1053 ::: rightcol
1054 ::: box
1055 [Don’ts]{.boxheader .donts}
1056 ```java
1057 long l = 5432l;
1058 int i = 0X123 + 0xabc;
1059 byte b = 0B1010;
1060 float f1 = 1 / 5432F;
1061 float f2 = 0.123E4f;
1062 double d1 = 1 / 5432D;
1063 double d2 = 0x1.3P2;
1064 ```
1065 :::
1066 :::
1067 
1068 
1069 ::: box
1070 [Motivation]{.boxheader}
1071 Lower case L resembles a 1 in many monospace fonts which means that the literal `5432l` can be confused with `54321`. Using upper case `L` suffix avoids this. The lowercase `0x`, `0b`, `e`, `p`, `f`, and `d` characters are easier to spot in a long sequence of digits, and they avoid confusion with the hexadecimal digits `A`-`F`.
1072 :::
1073 
1074 ### Javadoc
1075 This section only covers basic Javadoc formatting. For a complete reference refer to &amp;nbsp;[How to Write Doc Comments for the Javadoc Tool](http://www.oracle.com/technetwork/articles/java/index-137868.html).
1076 
1077 ::: conventions
1078 - Start longer comments with a short summarizing sentence since Javadoc includes this in the method summary table.
1079 - Prefer inline tags (such as `{@code …}` and `{@link …}` etc) over corresponding HTML tags (`&lt;code&gt;…&lt;/code&gt;`, `&lt;a href=&quot;…&quot;&gt;…&lt;/a&gt;` etc).
1080 - Use `&lt;p&gt;` to separate paragraphs (closing `&lt;/p&gt;` tags are not needed and should not be used)
1081 :::
1082 
1083 ::: leftcol
1084 ::: box
1085 [Dos]{.boxheader .dos}
1086 ```java
1087 /** A short javadoc comment */
1088 ```
1089 ```java
1090 /**
1091  * …
1092  *
1093  * &lt;blockquote&gt;{@code
1094  *     List&lt;String&gt; names;
1095  * }&lt;/blockquote&gt;
1096  */
1097 ```
1098 :::
1099 :::
1100 
1101 ::: rightcol
1102 ::: box
1103 [Don’ts]{.boxheader .donts}
1104 ```java
1105 /** put on single line instead
1106  */
1107 ```
1108 ```java
1109 /**
1110  * The &lt;String&gt; below may interfere with the HTML!
1111  *
1112  * &lt;blockquote&gt;&lt;pre&gt;
1113  *     List&lt;String&gt; names;
1114  * &lt;/pre&gt;&lt;/blockquote&gt;
1115  */
1116 ```
1117 :::
1118 :::
1119 
1120 
1121 ## Naming
1122 ::: conventions
1123 - Avoid hiding/shadowing methods, variables and type variables in outer scopes.
1124 - Let the verbosity of the name correlate to the size of the scope. (For instance, use descriptive names for fields of large classes and brief names for local short-lived variables.)
1125 - When naming public static members, let the identifier be self descriptive if you believe they will be statically imported.
1126 :::
1127 
1128 ### Package Names
1129 ::: conventions
1130 - Package names should be all lower case without underscores or other special characters.
1131 - Don’t use plural form. Follow the convention of the standard API which uses for instance `java.lang.annotation` and not `java.lang.annotations`.
1132 :::
1133 
1134 ### Class, Interface and Enum Names
1135 ::: conventions
1136 - Class and enum names should typically be nouns.
1137 - Interface names should typically be nouns or adjectives ending with *…able*.
1138 - Use mixed case with the first letter in each word in upper case.
1139 - Use whole words and avoid using abbreviations unless the abbreviation is more widely used than the long form.
1140 - Format an abbreviation as a word if the it is part of a longer class name.
1141 :::
1142 
1143 ::: leftcol
1144 ::: box
1145 [Dos]{.boxheader .dos}
1146 ```java
1147 class EmptyCell {
1148     …
1149 }
1150 ```
1151 ```java
1152 class RunningMode {
1153     …
1154 }
1155 ```
1156 ```java
1157 interface Expandable {
1158     …
1159 }
1160 ```
1161 ```java
1162 class XmlParser {
1163     …
1164 }
1165 ```
1166 :::
1167 :::
1168 
1169 ::: rightcol
1170 ::: box
1171 [Don’ts]{.boxheader .donts}
1172 ```java
1173 class Empty {
1174     …
1175 }
1176 ```
1177 ```java
1178 class Running {
1179     …
1180 }
1181 ```
1182 ```java
1183 class Expandable {
1184     …
1185 }
1186 ```
1187 ```java
1188 // Abbreviation should be formatted as &#39;Xml&#39;
1189 class XMLParser {
1190     …
1191 }
1192 ```
1193 :::
1194 :::
1195 
1196         
1197 ### Method Names
1198 ::: conventions
1199 - Method names should typically be verbs or other descriptions of actions.
1200 - Use mixed case with the first letter in lower case.
1201 :::
1202 
1203 ::: leftcol
1204 ::: box
1205 [Dos]{.boxheader .dos}
1206 ```java
1207 public void expand() {
1208     …
1209 }
1210 ```
1211 ```java
1212 public boolean isExpanding() {
1213     …
1214 }
1215 ```
1216 ```java
1217 public State getState() {
1218     …
1219 }
1220 ```
1221 :::
1222 :::
1223 
1224 ::: rightcol
1225 ::: box
1226 [Don’ts]{.boxheader .donts}
1227 ```java
1228 public boolean expanding() {
1229     …
1230 }
1231 ```
1232 ```java
1233 public State GetState() {
1234     …
1235 }
1236 ```
1237 ```java
1238 public int get_index() {
1239     …
1240 }
1241 ```
1242 :::
1243 :::
1244 
1245 
1246 
1247 ### Variables
1248 ::: conventions
1249 - Variable names should be in mixed case with the first letter in lower case.
1250 :::
1251 
1252 ::: leftcol
1253 ::: box
1254 [Dos]{.boxheader .dos}
1255 ```java
1256 int currentIndex;
1257 boolean dataAvailable;
1258 ```
1259 :::
1260 :::
1261 
1262 ::: rightcol
1263 ::: box
1264 [Don’ts]{.boxheader .donts}
1265 ```java
1266 int current_index;
1267 boolean DataAvailable;
1268 ```
1269 :::
1270 :::
1271 
1272 
1273 ### Type Variables
1274 ::: conventions
1275 - For simple cases where there are few type variables involved use a single upper case letter.
1276 - If one letter is more descriptive than another (such as `K` and `V` for keys and values in maps or `R` for a function return type) use that, otherwise use `T`.
1277 - For complex cases where single letter type variables become confusing, use longer names written in all capital letters and use underscore (`_`) to separate words.
1278 :::
1279 
1280 ::: leftcol
1281 ::: box
1282 [Dos]{.boxheader .dos}
1283 ```java
1284 interface SpecialMap&lt;K, V&gt; extends Map&lt;K, V&gt; {
1285     …
1286 }
1287 ```
1288 ```java
1289 class GraphMapper&lt;SRC_VERTEX, SRC_EDGE, DST_VERTEX, DST_EDGE&gt; {
1290     …
1291 }
1292 ```
1293 :::
1294 :::
1295 
1296 ::: rightcol
1297 ::: box
1298 [Don’ts]{.boxheader .donts}
1299 ```java
1300 interface SpecialMap&lt;Key, Value&gt; extends Map&lt;Key, Value&gt; {
1301     …
1302 }
1303 ```
1304 ```java
1305 class GraphMapper&lt;S, T, U, V&gt; {
1306     …
1307 }
1308 ```
1309 :::
1310 :::
1311 
1312 
1313 ### Constants
1314 ::: conventions
1315 - Constants (static final fields whose content is immutable, by language rules or by convention) should be named with all capital letters and underscore (`_`) to separate words.
1316 :::
1317 
1318 ::: leftcol
1319 ::: box
1320 [Dos]{.boxheader .dos}
1321 ```java
1322 public static final int BUFFER_SIZE = 1024;
1323 ```
1324 ```java
1325 enum ApplicationMode { RUNNING, PAUSED, TERMINATED }
1326 ```
1327 :::
1328 :::
1329 
1330 ::: rightcol
1331 ::: box
1332 [Don’ts]{.boxheader .donts}
1333 ```java
1334 public final List&lt;String&gt; CURRENT_WORDS = new ArrayList&lt;&gt;();
1335 ```
1336 ```java
1337 enum ApplicationMode { Running, Paused, Terminated }
1338 ```
1339 :::
1340 :::
1341 
1342 
1343 ## Programming Practices
1344 The focus of the guidelines in this document is on style. General guidelines on best programming practices, use of design patterns, how to structure programs etc is thus out of scope.&amp;nbsp;A few “low level” practices that are easy to pin down is however good to agree upon.
1345 
1346 ::: conventions
1347 - Always use `@Override` where it is possible to do so.
1348 - Document any non-obvious pre and post conditions (also for private methods). In particular, all parameters / return values are assumed to be non-null unless explicitly stated otherwise.
1349 - Avoid checking in “`TODO`” comments. If the missing code doesn’t affect correctness or performance, skip the comment, otherwise file an issue for it.
1350 - Avoid checking in dead code.
1351 - Static mutable state should be used judiciously. In particular enums should not have mutable state, and any public static variable must also be final.
1352 - Static methods and fields that are accessed out of scope should be qualified with the identifier of the class that declares them and not with a subclass or an instance variable.
1353 - Fall through on non-empty cases in switch statements should be documented, typically with a “`// fall through`” comment.
1354 - Mutating method parameters is discouraged. This is because parameters are typically associated with the input values and by mutating these the code may be harder to understand, especially when only looking at parts of the method below the mutation.
1355 - Keep methods short. Consider splitting up long methods into smaller ones to limit variable scopes and simplify structure of the code.
1356 :::
1357 
1358 ### Commenting Code
1359 ::: conventions
1360 - First and foremost, try to make the code simple enough that it’s self explanatory. While comments explaining the code are good, not having to explain the code is better.
1361 - For single line comments, use end-of-line comments (`//`) otherwise use multiline comments (`/* … */`).
1362 - Avoid comments that run the risk of getting out of sync as the code evolves. (If a comment runs the risk of getting out of sync, it’s often a sign that it comments how the code works rather than what the code achieves.)
1363 - Small well documented methods are preferred over longer methods with comments in the body of the method.
1364 - Don’t check in code that’s commented out.
1365 - IDE/tool-specific comments should be avoided wherever possible, especially when there are reasonable alternatives, such as external settings files, etc.
1366 - Comments should be grammatically correct and follow general recommendations of technical writing.
1367 :::
1368     
1369 ## When to reformat code
1370 ::: conventions
1371 - Do not reformat code in files unrelated to the current changeset, even if the code doesn’t adhere to the guidelines.
1372 - Minor cleanups in files that are already touched for other reasons are fine. Put the cleanups in a separate patch if you think it will simplify the review process. Large cleanups should always go in a separate changeset.
1373 :::
1374 
1375 ::: box
1376 [Motivation]{.boxheader}
1377 Cleaning up code that’s unrelated to the patch may…
1378 - Complicate the review of the patch in which case correctness may suffer
1379 - Run the risk of breaking existing code
1380 - Have a downstream impact, e.g. affect ports to other versions.
1381 - Trigger an unnecessary debate (perhaps the original formatting was intentional).
1382 :::
1383 
1384 ## Cases not covered
1385 ::: conventions
1386 - If some aspect is not covered by these guidelines one should fall back on the style of the surrounding code within the same file, within the package or within the project in that order.
1387 :::
1388 
1389 ::: {.NavBit}
1390 [« Previous](mailinglists.html) • [TOC](index.html) • [Next »](changePlanning.html)
1391 :::
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/z/zCollectedHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
 26 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 27 #include &quot;gc/z/zCollectedHeap.hpp&quot;
 28 #include &quot;gc/z/zDirector.hpp&quot;
 29 #include &quot;gc/z/zDriver.hpp&quot;
 30 #include &quot;gc/z/zGlobals.hpp&quot;
 31 #include &quot;gc/z/zHeap.inline.hpp&quot;
 32 #include &quot;gc/z/zNMethod.hpp&quot;
 33 #include &quot;gc/z/zObjArrayAllocator.hpp&quot;
 34 #include &quot;gc/z/zOop.inline.hpp&quot;
 35 #include &quot;gc/z/zServiceability.hpp&quot;
 36 #include &quot;gc/z/zStat.hpp&quot;
 37 #include &quot;gc/z/zUtils.inline.hpp&quot;
 38 #include &quot;memory/iterator.hpp&quot;
 39 #include &quot;memory/universe.hpp&quot;
 40 #include &quot;runtime/mutexLocker.hpp&quot;
 41 #include &quot;utilities/align.hpp&quot;
 42 
 43 ZCollectedHeap* ZCollectedHeap::heap() {
 44   return named_heap&lt;ZCollectedHeap&gt;(CollectedHeap::Z);
 45 }
 46 
 47 ZCollectedHeap::ZCollectedHeap() :
 48     _soft_ref_policy(),
 49     _barrier_set(),
 50     _initialize(&amp;_barrier_set),
 51     _heap(),
 52     _director(new ZDirector()),
 53     _driver(new ZDriver()),
 54     _stat(new ZStat()),
 55     _runtime_workers() {}
 56 
 57 CollectedHeap::Name ZCollectedHeap::kind() const {
 58   return CollectedHeap::Z;
 59 }
 60 
 61 const char* ZCollectedHeap::name() const {
 62   return ZName;
 63 }
 64 
 65 jint ZCollectedHeap::initialize() {
 66   if (!_heap.is_initialized()) {
 67     return JNI_ENOMEM;
 68   }
 69 
 70   Universe::calculate_verify_data((HeapWord*)0, (HeapWord*)UINTPTR_MAX);
 71 
 72   return JNI_OK;
 73 }
 74 
 75 void ZCollectedHeap::initialize_serviceability() {
 76   _heap.serviceability_initialize();
 77 }
 78 
 79 class ZStopConcurrentGCThreadClosure : public ThreadClosure {
 80 public:
 81   virtual void do_thread(Thread* thread) {
 82     if (thread-&gt;is_ConcurrentGC_thread() &amp;&amp;
 83         !thread-&gt;is_GC_task_thread()) {
 84       static_cast&lt;ConcurrentGCThread*&gt;(thread)-&gt;stop();
 85     }
 86   }
 87 };
 88 
 89 void ZCollectedHeap::stop() {
 90   ZStopConcurrentGCThreadClosure cl;
 91   gc_threads_do(&amp;cl);
 92 }
 93 
 94 SoftRefPolicy* ZCollectedHeap::soft_ref_policy() {
 95   return &amp;_soft_ref_policy;
 96 }
 97 
 98 size_t ZCollectedHeap::max_capacity() const {
 99   return _heap.max_capacity();
100 }
101 
102 size_t ZCollectedHeap::capacity() const {
103   return _heap.capacity();
104 }
105 
106 size_t ZCollectedHeap::used() const {
107   return _heap.used();
108 }
109 
110 size_t ZCollectedHeap::unused() const {
111   return _heap.unused();
112 }
113 
114 bool ZCollectedHeap::is_maximal_no_gc() const {
115   // Not supported
116   ShouldNotReachHere();
117   return false;
118 }
119 
120 bool ZCollectedHeap::is_in(const void* p) const {
121   return _heap.is_in((uintptr_t)p);
122 }
123 
124 bool ZCollectedHeap::requires_barriers(oop obj) const {
125   return !_heap.is_allocating(cast_from_oop&lt;uintptr_t&gt;(obj));
126 }
127 
128 uint32_t ZCollectedHeap::hash_oop(oop obj) const {
129   return _heap.hash_oop(ZOop::to_address(obj));
130 }
131 
132 HeapWord* ZCollectedHeap::allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size) {
133   const size_t size_in_bytes = ZUtils::words_to_bytes(align_object_size(requested_size));
134   const uintptr_t addr = _heap.alloc_tlab(size_in_bytes);
135 
136   if (addr != 0) {
137     *actual_size = requested_size;
138   }
139 
140   return (HeapWord*)addr;
141 }
142 
143 oop ZCollectedHeap::array_allocate(Klass* klass, int size, int length, bool do_zero, TRAPS) {
144   if (!do_zero) {
145     return CollectedHeap::array_allocate(klass, size, length, false /* do_zero */, THREAD);
146   }
147 
148   ZObjArrayAllocator allocator(klass, size, length, THREAD);
149   return allocator.allocate();
150 }
151 
152 HeapWord* ZCollectedHeap::mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) {
153   const size_t size_in_bytes = ZUtils::words_to_bytes(align_object_size(size));
154   return (HeapWord*)_heap.alloc_object(size_in_bytes);
155 }
156 
157 MetaWord* ZCollectedHeap::satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
158                                                              size_t size,
159                                                              Metaspace::MetadataType mdtype) {
160   MetaWord* result;
161 
162   // Start asynchronous GC
163   collect(GCCause::_metadata_GC_threshold);
164 
165   // Expand and retry allocation
166   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
167   if (result != NULL) {
168     return result;
169   }
170 
171   // Start synchronous GC
172   collect(GCCause::_metadata_GC_clear_soft_refs);
173 
174   // Retry allocation
175   result = loader_data-&gt;metaspace_non_null()-&gt;allocate(size, mdtype);
176   if (result != NULL) {
177     return result;
178   }
179 
180   // Expand and retry allocation
181   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
182   if (result != NULL) {
183     return result;
184   }
185 
186   // Out of memory
187   return NULL;
188 }
189 
190 void ZCollectedHeap::collect(GCCause::Cause cause) {
191   _driver-&gt;collect(cause);
192 }
193 
194 void ZCollectedHeap::collect_as_vm_thread(GCCause::Cause cause) {
195   // These collection requests are ignored since ZGC can&#39;t run a synchronous
196   // GC cycle from within the VM thread. This is considered benign, since the
197   // only GC causes coming in here should be heap dumper and heap inspector.
198   // However, neither the heap dumper nor the heap inspector really need a GC
199   // to happen, but the result of their heap iterations might in that case be
200   // less accurate since they might include objects that would otherwise have
201   // been collected by a GC.
202   assert(Thread::current()-&gt;is_VM_thread(), &quot;Should be the VM thread&quot;);
203   guarantee(cause == GCCause::_heap_dump ||
204             cause == GCCause::_heap_inspection, &quot;Invalid cause&quot;);
205 }
206 
207 void ZCollectedHeap::do_full_collection(bool clear_all_soft_refs) {
208   // Not supported
209   ShouldNotReachHere();
210 }
211 
212 bool ZCollectedHeap::supports_tlab_allocation() const {
213   return true;
214 }
215 
216 size_t ZCollectedHeap::tlab_capacity(Thread* ignored) const {
217   return _heap.tlab_capacity();
218 }
219 
220 size_t ZCollectedHeap::tlab_used(Thread* ignored) const {
221   return _heap.tlab_used();
222 }
223 
224 size_t ZCollectedHeap::max_tlab_size() const {
225   return _heap.max_tlab_size();
226 }
227 
228 size_t ZCollectedHeap::unsafe_max_tlab_alloc(Thread* ignored) const {
229   return _heap.unsafe_max_tlab_alloc();
230 }
231 
232 bool ZCollectedHeap::can_elide_tlab_store_barriers() const {
233   return false;
234 }
235 
236 bool ZCollectedHeap::can_elide_initializing_store_barrier(oop new_obj) {
237   // Not supported
238   ShouldNotReachHere();
239   return true;
240 }
241 
242 bool ZCollectedHeap::card_mark_must_follow_store() const {
243   // Not supported
244   ShouldNotReachHere();
245   return false;
246 }
247 
248 GrowableArray&lt;GCMemoryManager*&gt; ZCollectedHeap::memory_managers() {
249   return GrowableArray&lt;GCMemoryManager*&gt;(1, 1, _heap.serviceability_memory_manager());
250 }
251 
252 GrowableArray&lt;MemoryPool*&gt; ZCollectedHeap::memory_pools() {
253   return GrowableArray&lt;MemoryPool*&gt;(1, 1, _heap.serviceability_memory_pool());
254 }
255 
256 void ZCollectedHeap::object_iterate(ObjectClosure* cl) {
257   _heap.object_iterate(cl, true /* visit_weaks */);
258 }
259 
260 void ZCollectedHeap::keep_alive(oop obj) {
261   _heap.keep_alive(obj);
262 }
263 
264 void ZCollectedHeap::register_nmethod(nmethod* nm) {
265   ZNMethod::register_nmethod(nm);
266 }
267 
268 void ZCollectedHeap::unregister_nmethod(nmethod* nm) {
269   ZNMethod::unregister_nmethod(nm);
270 }
271 
272 void ZCollectedHeap::flush_nmethod(nmethod* nm) {
273   ZNMethod::flush_nmethod(nm);
274 }
275 
276 void ZCollectedHeap::verify_nmethod(nmethod* nm) {
277   // Does nothing
278 }
279 
280 WorkGang* ZCollectedHeap::get_safepoint_workers() {
281   return _runtime_workers.workers();
282 }
283 
284 jlong ZCollectedHeap::millis_since_last_gc() {
285   return ZStatCycle::time_since_last() / MILLIUNITS;
286 }
287 
288 void ZCollectedHeap::gc_threads_do(ThreadClosure* tc) const {
289   tc-&gt;do_thread(_director);
290   tc-&gt;do_thread(_driver);
291   tc-&gt;do_thread(_stat);
292   _heap.threads_do(tc);
293   _runtime_workers.threads_do(tc);
294 }
295 
296 VirtualSpaceSummary ZCollectedHeap::create_heap_space_summary() {
297   return VirtualSpaceSummary((HeapWord*)0, (HeapWord*)capacity(), (HeapWord*)max_capacity());
298 }
299 
300 void ZCollectedHeap::safepoint_synchronize_begin() {
301   SuspendibleThreadSet::synchronize();
302 }
303 
304 void ZCollectedHeap::safepoint_synchronize_end() {
305   SuspendibleThreadSet::desynchronize();
306 }
307 
308 void ZCollectedHeap::prepare_for_verify() {
309   // Does nothing
310 }
311 
312 void ZCollectedHeap::print_on(outputStream* st) const {
313   _heap.print_on(st);
314 }
315 
316 void ZCollectedHeap::print_on_error(outputStream* st) const {
317   st-&gt;print_cr(&quot;ZGC Globals:&quot;);
318   st-&gt;print_cr(&quot; GlobalPhase:       %u (%s)&quot;, ZGlobalPhase, ZGlobalPhaseToString());
319   st-&gt;print_cr(&quot; GlobalSeqNum:      %u&quot;, ZGlobalSeqNum);
320   st-&gt;print_cr(&quot; Offset Max:        &quot; SIZE_FORMAT &quot;%s (&quot; PTR_FORMAT &quot;)&quot;,
321                byte_size_in_exact_unit(ZAddressOffsetMax),
322                exact_unit_for_byte_size(ZAddressOffsetMax),
323                ZAddressOffsetMax);
324   st-&gt;print_cr(&quot; Page Size Small:   &quot; SIZE_FORMAT &quot;M&quot;, ZPageSizeSmall / M);
325   st-&gt;print_cr(&quot; Page Size Medium:  &quot; SIZE_FORMAT &quot;M&quot;, ZPageSizeMedium / M);
326   st-&gt;cr();
327   st-&gt;print_cr(&quot;ZGC Metadata Bits:&quot;);
328   st-&gt;print_cr(&quot; Good:              &quot; PTR_FORMAT, ZAddressGoodMask);
329   st-&gt;print_cr(&quot; Bad:               &quot; PTR_FORMAT, ZAddressBadMask);
330   st-&gt;print_cr(&quot; WeakBad:           &quot; PTR_FORMAT, ZAddressWeakBadMask);
331   st-&gt;print_cr(&quot; Marked:            &quot; PTR_FORMAT, ZAddressMetadataMarked);
332   st-&gt;print_cr(&quot; Remapped:          &quot; PTR_FORMAT, ZAddressMetadataRemapped);
333   st-&gt;cr();
334   CollectedHeap::print_on_error(st);
335 }
336 
337 void ZCollectedHeap::print_extended_on(outputStream* st) const {
338   _heap.print_extended_on(st);
339 }
340 
341 void ZCollectedHeap::print_tracing_info() const {
342   // Does nothing
343 }
344 
345 bool ZCollectedHeap::print_location(outputStream* st, void* addr) const {
346   return _heap.print_location(st, (uintptr_t)addr);
347 }
348 
349 void ZCollectedHeap::verify(VerifyOption option /* ignored */) {
350   _heap.verify();
351 }
352 
353 bool ZCollectedHeap::is_oop(oop object) const {
354   return _heap.is_oop(ZOop::to_address(object));
355 }
356 
357 bool ZCollectedHeap::supports_concurrent_gc_breakpoints() const {
358   return true;
359 }
    </pre>
  </body>
</html>
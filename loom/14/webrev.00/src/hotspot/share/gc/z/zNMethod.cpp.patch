diff a/src/hotspot/share/gc/z/zNMethod.cpp b/src/hotspot/share/gc/z/zNMethod.cpp
--- a/src/hotspot/share/gc/z/zNMethod.cpp
+++ b/src/hotspot/share/gc/z/zNMethod.cpp
@@ -20,10 +20,11 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 #include "precompiled.hpp"
+#include "code/compiledMethod.inline.hpp"
 #include "code/relocInfo.hpp"
 #include "code/nmethod.hpp"
 #include "code/icBuffer.hpp"
 #include "gc/shared/barrierSet.hpp"
 #include "gc/shared/barrierSetNMethod.hpp"
@@ -210,11 +211,18 @@
   if (bs != NULL) {
     bs->disarm(nm);
   }
 }
 
-void ZNMethod::nmethod_oops_do(nmethod* nm, OopClosure* cl) {
+void ZNMethod::arm(nmethod* nm, int arm_value) {
+  BarrierSetNMethod* const bs = BarrierSet::barrier_set()->barrier_set_nmethod();
+  if (bs != NULL) {
+    bs->arm(nm, arm_value);
+  }
+}
+
+void ZNMethod::nmethod_oops_do(nmethod* nm, OopClosure* cl, bool keepalive_is_strong) {
   // Process oops table
   {
     oop* const begin = nm->oops_begin();
     oop* const end = nm->oops_end();
     for (oop* p = begin; p < end; p++) {
@@ -239,22 +247,31 @@
 
   // Process non-immediate oops
   if (oops->has_non_immediates()) {
     nm->fix_oop_relocations();
   }
+
+  if (keepalive_is_strong) {
+    oop* obj_ptr = nm->get_keepalive();
+    if (obj_ptr != NULL) {
+      cl->do_oop(obj_ptr);
+    }
+  }
 }
 
 class ZNMethodToOopsDoClosure : public NMethodClosure {
 private:
   OopClosure* _cl;
+  bool        _keepalive_is_strong;
 
 public:
-  ZNMethodToOopsDoClosure(OopClosure* cl) :
-      _cl(cl) {}
+  ZNMethodToOopsDoClosure(OopClosure* cl, bool keepalive_is_strong) :
+      _cl(cl),
+      _keepalive_is_strong(keepalive_is_strong) {}
 
   virtual void do_nmethod(nmethod* nm) {
-    ZNMethod::nmethod_oops_do(nm, _cl);
+    ZNMethod::nmethod_oops_do(nm, _cl, _keepalive_is_strong);
   }
 };
 
 void ZNMethod::oops_do_begin() {
   ZNMethodTable::nmethods_do_begin();
@@ -262,12 +279,12 @@
 
 void ZNMethod::oops_do_end() {
   ZNMethodTable::nmethods_do_end();
 }
 
-void ZNMethod::oops_do(OopClosure* cl) {
-  ZNMethodToOopsDoClosure nmethod_cl(cl);
+void ZNMethod::oops_do(OopClosure* cl, bool keepalive_is_strong) {
+  ZNMethodToOopsDoClosure nmethod_cl(cl, keepalive_is_strong);
   ZNMethodTable::nmethods_do(&nmethod_cl);
 }
 
 class ZNMethodUnlinkClosure : public NMethodClosure {
 private:
@@ -320,12 +337,12 @@
     ZLocker<ZReentrantLock> locker(ZNMethod::lock_for_nmethod(nm));
 
     if (ZNMethod::is_armed(nm)) {
       // Heal oops and disarm
       ZNMethodOopClosure cl;
-      ZNMethod::nmethod_oops_do(nm, &cl);
-      ZNMethod::disarm(nm);
+      ZNMethod::nmethod_oops_do(nm, &cl, false /* keepalive_is_strong */);
+      ZNMethod::arm(nm, 0);
     }
 
     // Clear compiled ICs and exception caches
     if (!nm->unload_nmethod_caches(_unloading_occurred)) {
       set_failed();

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zRootsIterator.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zNMethod.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zUnload.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zRootsIterator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
129     (_iter-&gt;*F)(is_alive, cl);
130     if (!_completed) {
131       _completed = true;
132     }
133   }
134 }
135 
136 class ZRootsIteratorCodeBlobClosure : public CodeBlobClosure {
137 private:
138   ZRootsIteratorClosure* const _cl;
139   const bool                   _should_disarm_nmethods;
140 
141 public:
142   ZRootsIteratorCodeBlobClosure(ZRootsIteratorClosure* cl) :
143       _cl(cl),
144       _should_disarm_nmethods(cl-&gt;should_disarm_nmethods()) {}
145 
146   virtual void do_code_blob(CodeBlob* cb) {
147     nmethod* const nm = cb-&gt;as_nmethod_or_null();
148     if (nm != NULL &amp;&amp; nm-&gt;oops_do_try_claim()) {
<span class="line-modified">149       ZNMethod::nmethod_oops_do(nm, _cl);</span>

150       assert(!ZNMethod::supports_entry_barrier(nm) ||
151              ZNMethod::is_armed(nm) == _should_disarm_nmethods, &quot;Invalid state&quot;);
152       if (_should_disarm_nmethods) {
153         ZNMethod::disarm(nm);
154       }
155     }
156   }
157 };
158 
159 class ZRootsIteratorThreadClosure : public ThreadClosure {
160 private:
161   ZRootsIteratorClosure* const _cl;
162   ResourceMark                 _rm;
163 
164 public:
165   ZRootsIteratorThreadClosure(ZRootsIteratorClosure* cl) :
166       _cl(cl) {}
167 
168   virtual void do_thread(Thread* thread) {
169     ZRootsIteratorCodeBlobClosure code_cl(_cl);
</pre>
<hr />
<pre>
230 void ZRootsIterator::do_jvmti_weak_export(ZRootsIteratorClosure* cl) {
231   ZStatTimer timer(ZSubPhasePauseRootsJVMTIWeakExport);
232   AlwaysTrueClosure always_alive;
233   JvmtiExport::weak_oops_do(&amp;always_alive, cl);
234 }
235 
236 void ZRootsIterator::do_vm_thread(ZRootsIteratorClosure* cl) {
237   ZStatTimer timer(ZSubPhasePauseRootsVMThread);
238   ZRootsIteratorThreadClosure thread_cl(cl);
239   thread_cl.do_thread(VMThread::vm_thread());
240 }
241 
242 void ZRootsIterator::do_java_threads(ZRootsIteratorClosure* cl) {
243   ZStatTimer timer(ZSubPhasePauseRootsJavaThreads);
244   ZRootsIteratorThreadClosure thread_cl(cl);
245   _java_threads_iter.threads_do(&amp;thread_cl);
246 }
247 
248 void ZRootsIterator::do_code_cache(ZRootsIteratorClosure* cl) {
249   ZStatTimer timer(ZSubPhasePauseRootsCodeCache);
<span class="line-modified">250   ZNMethod::oops_do(cl);</span>
251 }
252 
253 void ZRootsIterator::oops_do(ZRootsIteratorClosure* cl) {
254   ZStatTimer timer(ZSubPhasePauseRoots);
255   _universe.oops_do(cl);
256   _object_synchronizer.oops_do(cl);
257   _vm_thread.oops_do(cl);
258   _java_threads.oops_do(cl);
259   if (!ClassUnloading) {
260     _code_cache.oops_do(cl);
261   }
262   if (_visit_jvmti_weak_export) {
263     _jvmti_weak_export.oops_do(cl);
264   }
265 }
266 
267 ZConcurrentRootsIterator::ZConcurrentRootsIterator(int cld_claim) :
268     _oop_storage_set_iter(),
269     _cld_claim(cld_claim),
270     _oop_storage_set(this),
</pre>
</td>
<td>
<hr />
<pre>
129     (_iter-&gt;*F)(is_alive, cl);
130     if (!_completed) {
131       _completed = true;
132     }
133   }
134 }
135 
136 class ZRootsIteratorCodeBlobClosure : public CodeBlobClosure {
137 private:
138   ZRootsIteratorClosure* const _cl;
139   const bool                   _should_disarm_nmethods;
140 
141 public:
142   ZRootsIteratorCodeBlobClosure(ZRootsIteratorClosure* cl) :
143       _cl(cl),
144       _should_disarm_nmethods(cl-&gt;should_disarm_nmethods()) {}
145 
146   virtual void do_code_blob(CodeBlob* cb) {
147     nmethod* const nm = cb-&gt;as_nmethod_or_null();
148     if (nm != NULL &amp;&amp; nm-&gt;oops_do_try_claim()) {
<span class="line-modified">149       ZNMethod::nmethod_oops_do(nm, _cl, _should_disarm_nmethods);</span>
<span class="line-added">150       nm-&gt;mark_as_maybe_on_continuation();</span>
151       assert(!ZNMethod::supports_entry_barrier(nm) ||
152              ZNMethod::is_armed(nm) == _should_disarm_nmethods, &quot;Invalid state&quot;);
153       if (_should_disarm_nmethods) {
154         ZNMethod::disarm(nm);
155       }
156     }
157   }
158 };
159 
160 class ZRootsIteratorThreadClosure : public ThreadClosure {
161 private:
162   ZRootsIteratorClosure* const _cl;
163   ResourceMark                 _rm;
164 
165 public:
166   ZRootsIteratorThreadClosure(ZRootsIteratorClosure* cl) :
167       _cl(cl) {}
168 
169   virtual void do_thread(Thread* thread) {
170     ZRootsIteratorCodeBlobClosure code_cl(_cl);
</pre>
<hr />
<pre>
231 void ZRootsIterator::do_jvmti_weak_export(ZRootsIteratorClosure* cl) {
232   ZStatTimer timer(ZSubPhasePauseRootsJVMTIWeakExport);
233   AlwaysTrueClosure always_alive;
234   JvmtiExport::weak_oops_do(&amp;always_alive, cl);
235 }
236 
237 void ZRootsIterator::do_vm_thread(ZRootsIteratorClosure* cl) {
238   ZStatTimer timer(ZSubPhasePauseRootsVMThread);
239   ZRootsIteratorThreadClosure thread_cl(cl);
240   thread_cl.do_thread(VMThread::vm_thread());
241 }
242 
243 void ZRootsIterator::do_java_threads(ZRootsIteratorClosure* cl) {
244   ZStatTimer timer(ZSubPhasePauseRootsJavaThreads);
245   ZRootsIteratorThreadClosure thread_cl(cl);
246   _java_threads_iter.threads_do(&amp;thread_cl);
247 }
248 
249 void ZRootsIterator::do_code_cache(ZRootsIteratorClosure* cl) {
250   ZStatTimer timer(ZSubPhasePauseRootsCodeCache);
<span class="line-modified">251   ZNMethod::oops_do(cl, true /* keepalive_is_strong */);</span>
252 }
253 
254 void ZRootsIterator::oops_do(ZRootsIteratorClosure* cl) {
255   ZStatTimer timer(ZSubPhasePauseRoots);
256   _universe.oops_do(cl);
257   _object_synchronizer.oops_do(cl);
258   _vm_thread.oops_do(cl);
259   _java_threads.oops_do(cl);
260   if (!ClassUnloading) {
261     _code_cache.oops_do(cl);
262   }
263   if (_visit_jvmti_weak_export) {
264     _jvmti_weak_export.oops_do(cl);
265   }
266 }
267 
268 ZConcurrentRootsIterator::ZConcurrentRootsIterator(int cld_claim) :
269     _oop_storage_set_iter(),
270     _cld_claim(cld_claim),
271     _oop_storage_set(this),
</pre>
</td>
</tr>
</table>
<center><a href="zNMethod.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zUnload.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zCollectedHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zBarrierSetNMethod.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zCollectedHeap.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zCollectedHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
174   // Retry allocation
175   result = loader_data-&gt;metaspace_non_null()-&gt;allocate(size, mdtype);
176   if (result != NULL) {
177     return result;
178   }
179 
180   // Expand and retry allocation
181   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
182   if (result != NULL) {
183     return result;
184   }
185 
186   // Out of memory
187   return NULL;
188 }
189 
190 void ZCollectedHeap::collect(GCCause::Cause cause) {
191   _driver-&gt;collect(cause);
192 }
193 





194 void ZCollectedHeap::collect_as_vm_thread(GCCause::Cause cause) {
195   // These collection requests are ignored since ZGC can&#39;t run a synchronous
196   // GC cycle from within the VM thread. This is considered benign, since the
197   // only GC causes coming in here should be heap dumper and heap inspector.
198   // However, neither the heap dumper nor the heap inspector really need a GC
199   // to happen, but the result of their heap iterations might in that case be
200   // less accurate since they might include objects that would otherwise have
201   // been collected by a GC.
202   assert(Thread::current()-&gt;is_VM_thread(), &quot;Should be the VM thread&quot;);
203   guarantee(cause == GCCause::_heap_dump ||
204             cause == GCCause::_heap_inspection, &quot;Invalid cause&quot;);
205 }
206 
207 void ZCollectedHeap::do_full_collection(bool clear_all_soft_refs) {
208   // Not supported
209   ShouldNotReachHere();
210 }
211 
212 bool ZCollectedHeap::supports_tlab_allocation() const {
213   return true;
</pre>
</td>
<td>
<hr />
<pre>
174   // Retry allocation
175   result = loader_data-&gt;metaspace_non_null()-&gt;allocate(size, mdtype);
176   if (result != NULL) {
177     return result;
178   }
179 
180   // Expand and retry allocation
181   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
182   if (result != NULL) {
183     return result;
184   }
185 
186   // Out of memory
187   return NULL;
188 }
189 
190 void ZCollectedHeap::collect(GCCause::Cause cause) {
191   _driver-&gt;collect(cause);
192 }
193 
<span class="line-added">194 void ZCollectedHeap::collect_for_codecache() {</span>
<span class="line-added">195   // Start synchronous GC</span>
<span class="line-added">196   collect(GCCause::_codecache_GC_threshold);</span>
<span class="line-added">197 }</span>
<span class="line-added">198 </span>
199 void ZCollectedHeap::collect_as_vm_thread(GCCause::Cause cause) {
200   // These collection requests are ignored since ZGC can&#39;t run a synchronous
201   // GC cycle from within the VM thread. This is considered benign, since the
202   // only GC causes coming in here should be heap dumper and heap inspector.
203   // However, neither the heap dumper nor the heap inspector really need a GC
204   // to happen, but the result of their heap iterations might in that case be
205   // less accurate since they might include objects that would otherwise have
206   // been collected by a GC.
207   assert(Thread::current()-&gt;is_VM_thread(), &quot;Should be the VM thread&quot;);
208   guarantee(cause == GCCause::_heap_dump ||
209             cause == GCCause::_heap_inspection, &quot;Invalid cause&quot;);
210 }
211 
212 void ZCollectedHeap::do_full_collection(bool clear_all_soft_refs) {
213   // Not supported
214   ShouldNotReachHere();
215 }
216 
217 bool ZCollectedHeap::supports_tlab_allocation() const {
218   return true;
</pre>
</td>
</tr>
</table>
<center><a href="zBarrierSetNMethod.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zCollectedHeap.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
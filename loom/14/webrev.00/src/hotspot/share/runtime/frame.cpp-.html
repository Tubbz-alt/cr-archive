<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/frame.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/moduleEntry.hpp&quot;
  27 #include &quot;code/codeCache.hpp&quot;
  28 #include &quot;code/scopeDesc.hpp&quot;
  29 #include &quot;code/vmreg.inline.hpp&quot;
  30 #include &quot;compiler/abstractCompiler.hpp&quot;
  31 #include &quot;compiler/disassembler.hpp&quot;
  32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;interpreter/oopMapCache.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;memory/universe.hpp&quot;
  38 #include &quot;oops/markWord.hpp&quot;
  39 #include &quot;oops/method.hpp&quot;
  40 #include &quot;oops/methodData.hpp&quot;
  41 #include &quot;oops/oop.inline.hpp&quot;
  42 #include &quot;oops/verifyOopClosure.hpp&quot;
  43 #include &quot;prims/methodHandles.hpp&quot;
  44 #include &quot;runtime/continuation.hpp&quot;
  45 #include &quot;runtime/frame.inline.hpp&quot;
  46 #include &quot;runtime/handles.inline.hpp&quot;
  47 #include &quot;runtime/javaCalls.hpp&quot;
  48 #include &quot;runtime/monitorChunk.hpp&quot;
  49 #include &quot;runtime/os.hpp&quot;
  50 #include &quot;runtime/sharedRuntime.hpp&quot;
  51 #include &quot;runtime/signature.hpp&quot;
  52 #include &quot;runtime/stackValue.hpp&quot;
  53 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  54 #include &quot;runtime/stubRoutines.hpp&quot;
  55 #include &quot;runtime/thread.inline.hpp&quot;
  56 #include &quot;utilities/debug.hpp&quot;
  57 #include &quot;utilities/decoder.hpp&quot;
  58 #include &quot;utilities/formatBuffer.hpp&quot;
  59 
  60 RegisterMap::RegisterMap(JavaThread *thread, bool update_map, bool walk_cont, bool validate_oops) 
  61   : _cont(Handle()) {
  62   _thread         = thread;
  63   _update_map     = update_map;
  64   _validate_oops  = validate_oops;
  65   _walk_cont      = walk_cont;
  66   DEBUG_ONLY(_skip_missing = false;)
  67   clear();
  68   debug_only(_update_for_id = NULL;)
  69 
  70   _on_hstack = false;
  71   _in_chunk = false;
  72   if (walk_cont) {
  73     // we allocate the handle now (rather than in set_cont) because sometimes (StackWalker) the handle must live across HandleMarks
  74     if (thread != NULL &amp;&amp; thread-&gt;cont_entry() != NULL) {
  75       _cont = Handle(Thread::current(), thread-&gt;last_continuation());
  76       *(_cont.raw_value()) = NULL; // TODO UGLY : we just need to allocate a NULL handle
  77     } else {
  78       _cont = Handle();
  79     }
  80   }
  81 
  82 #ifndef PRODUCT
  83   for (int i = 0; i &lt; reg_count ; i++ ) _location[i] = NULL;
  84 #endif /* PRODUCT */
  85 }
  86 
  87 RegisterMap::RegisterMap(const RegisterMap* map) {
  88   assert(map != this, &quot;bad initialization parameter&quot;);
  89   assert(map != NULL, &quot;RegisterMap must be present&quot;);
  90   _thread                = map-&gt;thread();
  91   _update_map            = map-&gt;update_map();
  92   _include_argument_oops = map-&gt;include_argument_oops();
  93   debug_only(_update_for_id = map-&gt;_update_for_id;)
  94   _validate_oops = map-&gt;_validate_oops;
  95   _walk_cont     = map-&gt;_walk_cont;
  96   DEBUG_ONLY(_skip_missing = map-&gt;_skip_missing;)
  97 
  98   _cont = map-&gt;_cont;
  99   _on_hstack = map-&gt;_on_hstack;
 100   _in_chunk = map-&gt;_in_chunk;
 101 
 102   pd_initialize_from(map);
 103   if (update_map()) {
 104     for(int i = 0; i &lt; location_valid_size; i++) {
 105       LocationValidType bits = map-&gt;_location_valid[i];
 106       _location_valid[i] = bits;
 107       // for whichever bits are set, pull in the corresponding map-&gt;_location
 108       int j = i*location_valid_type_size;
 109       while (bits != 0) {
 110         if ((bits &amp; 1) != 0) {
 111           assert(0 &lt;= j &amp;&amp; j &lt; reg_count, &quot;range check&quot;);
 112           _location[j] = map-&gt;_location[j];
 113         }
 114         bits &gt;&gt;= 1;
 115         j += 1;
 116       }
 117     }
 118   }
 119 }
 120 
 121 void RegisterMap::set_in_cont(bool on_hstack, bool in_chunk) {
 122    assert (_walk_cont, &quot;&quot;); 
 123    assert (!in_chunk || on_hstack, &quot;&quot;);
 124    _on_hstack = (int)on_hstack;
 125    _in_chunk = (int)in_chunk;
 126 }
 127 
 128 void RegisterMap::set_cont(Handle cont) {
 129   assert (_walk_cont, &quot;&quot;);
 130   _cont = cont;
 131 }
 132 
 133 void RegisterMap::set_cont(oop cont) {
 134   assert (_walk_cont, &quot;&quot;);
 135   if (cont != NULL) {
 136     assert (_cont.not_null(), &quot;&quot;);
 137     *(_cont.raw_value()) = cont; // reuse handle. see comment above in the constructor
 138   } else {
 139     _cont = Handle();
 140   }
 141 }
 142 
 143 void RegisterMap::clear() {
 144   set_include_argument_oops(true);
 145   if (update_map()) {
 146     for(int i = 0; i &lt; location_valid_size; i++) {
 147       _location_valid[i] = 0;
 148     }
 149     pd_clear();
 150   } else {
 151     pd_initialize();
 152   }
 153 }
 154 
 155 #ifndef PRODUCT
 156 
 157 VMReg RegisterMap::find_register_spilled_here(void* p) {
 158   for(int i = 0; i &lt; RegisterMap::reg_count; i++) {
 159     VMReg r = VMRegImpl::as_VMReg(i);
 160     if (p == location(r)) return r;
 161   }
 162   return NULL;
 163 }
 164 
 165 void RegisterMap::print_on(outputStream* st) const {
 166   st-&gt;print_cr(&quot;Register map&quot;);
 167   for(int i = 0; i &lt; reg_count; i++) {
 168 
 169     VMReg r = VMRegImpl::as_VMReg(i);
 170     intptr_t* src = (intptr_t*) location(r);
 171     if (src != NULL) {
 172 
 173       r-&gt;print_on(st);
 174       st-&gt;print(&quot; [&quot; INTPTR_FORMAT &quot;] = &quot;, p2i(src));
 175       if (((uintptr_t)src &amp; (sizeof(*src)-1)) != 0) {
 176         st-&gt;print_cr(&quot;&lt;misaligned&gt;&quot;);
 177       } else {
 178         st-&gt;print_cr(INTPTR_FORMAT, *src);
 179       }
 180     }
 181   }
 182 }
 183 
 184 void RegisterMap::print() const {
 185   print_on(tty);
 186 }
 187 
 188 #endif
 189 // This returns the pc that if you were in the debugger you&#39;d see. Not
 190 // the idealized value in the frame object. This undoes the magic conversion
 191 // that happens for deoptimized frames. In addition it makes the value the
 192 // hardware would want to see in the native frame. The only user (at this point)
 193 // is deoptimization. It likely no one else should ever use it.
 194 
 195 address frame::raw_pc() const {
 196   // if (Continuation::is_continuation_entry_frame(*this)) {
 197   //   return StubRoutines::cont_returnBarrier();
 198   // }
 199   if (is_deoptimized_frame()) {
 200     CompiledMethod* cm = cb()-&gt;as_compiled_method_or_null();
 201     if (cm-&gt;is_method_handle_return(pc()))
 202       return cm-&gt;deopt_mh_handler_begin() - pc_return_offset;
 203     else
 204       return cm-&gt;deopt_handler_begin() - pc_return_offset;
 205   } else {
 206     return (pc() - pc_return_offset);
 207   }
 208 }
 209 
 210 // Change the pc in a frame object. This does not change the actual pc in
 211 // actual frame. To do that use patch_pc.
 212 //
 213 void frame::set_pc(address   newpc ) {
 214 #ifdef ASSERT
 215   if (_cb != NULL &amp;&amp; _cb-&gt;is_nmethod()) {
 216     assert(!((nmethod*)_cb)-&gt;is_deopt_pc(_pc), &quot;invariant violation&quot;);
 217   }
 218 #endif // ASSERT
 219 
 220   // Unsafe to use the is_deoptimzed tester after changing pc
 221   _deopt_state = unknown;
 222   _pc = newpc;
 223   _cb = CodeCache::find_blob_unsafe(_pc);
 224 
 225 }
 226 
 227 void frame::set_pc_preserve_deopt(address newpc) {
 228   set_pc_preserve_deopt(newpc, CodeCache::find_blob_unsafe(newpc));
 229 }
 230 
 231 void frame::set_pc_preserve_deopt(address newpc, CodeBlob* cb) {
 232 #ifdef ASSERT
 233   if (_cb != NULL &amp;&amp; _cb-&gt;is_nmethod()) {
 234     assert(!((nmethod*)_cb)-&gt;is_deopt_pc(_pc), &quot;invariant violation&quot;);
 235   }
 236 #endif // ASSERT
 237 
 238   _pc = newpc;
 239   _cb = cb;
 240 }
 241 
 242 // type testers
 243 bool frame::is_ignored_frame() const {
 244   return false;  // FIXME: some LambdaForm frames should be ignored
 245 }
 246 
 247 bool frame::is_native_frame() const {
 248   return (_cb != NULL &amp;&amp;
 249           _cb-&gt;is_nmethod() &amp;&amp;
 250           ((nmethod*)_cb)-&gt;is_native_method());
 251 }
 252 
 253 bool frame::is_java_frame() const {
 254   if (is_interpreted_frame()) return true;
 255   if (is_compiled_frame())    return true;
 256   return false;
 257 }
 258 
 259 bool frame::is_runtime_frame() const {
 260   return (_cb != NULL &amp;&amp; _cb-&gt;is_runtime_stub());
 261 }
 262 
 263 bool frame::is_safepoint_blob_frame() const {
 264   return (_cb != NULL &amp;&amp; _cb-&gt;is_safepoint_stub());
 265 }
 266 
 267 // testers
 268 
 269 bool frame::is_first_java_frame() const {
 270   RegisterMap map(JavaThread::current(), false); // No update
 271   frame s;
 272   for (s = sender(&amp;map); !(s.is_java_frame() || s.is_first_frame()); s = s.sender(&amp;map));
 273   return s.is_first_frame();
 274 }
 275 
 276 
 277 bool frame::entry_frame_is_first() const {
 278   return entry_frame_call_wrapper()-&gt;is_first_frame();
 279 }
 280 
 281 JavaCallWrapper* frame::entry_frame_call_wrapper_if_safe(JavaThread* thread) const {
 282   JavaCallWrapper** jcw = entry_frame_call_wrapper_addr();
 283   address addr = (address) jcw;
 284 
 285   // addr must be within the usable part of the stack
 286   if (thread-&gt;is_in_usable_stack(addr)) {
 287     return *jcw;
 288   }
 289 
 290   return NULL;
 291 }
 292 
 293 bool frame::is_entry_frame_valid(JavaThread* thread) const {
 294   // Validate the JavaCallWrapper an entry frame must have
 295   address jcw = (address)entry_frame_call_wrapper();
 296   if (!thread-&gt;is_in_stack_range_excl(jcw, (address)fp())) {
 297     return false;
 298   }
 299 
 300   // Validate sp saved in the java frame anchor
 301   JavaFrameAnchor* jfa = entry_frame_call_wrapper()-&gt;anchor();
 302   return (jfa-&gt;last_Java_sp() &gt; sp());
 303 }
 304 
 305 bool frame::should_be_deoptimized() const {
 306   if (_deopt_state == is_deoptimized ||
 307       !is_compiled_frame() ) return false;
 308   assert(_cb != NULL &amp;&amp; _cb-&gt;is_compiled(), &quot;must be an nmethod&quot;);
 309   CompiledMethod* nm = (CompiledMethod *)_cb;
 310   if (TraceDependencies) {
 311     tty-&gt;print(&quot;checking (%s) &quot;, nm-&gt;is_marked_for_deoptimization() ? &quot;true&quot; : &quot;false&quot;);
 312     nm-&gt;print_value_on(tty);
 313     tty-&gt;cr();
 314   }
 315 
 316   if( !nm-&gt;is_marked_for_deoptimization() )
 317     return false;
 318 
 319   // If at the return point, then the frame has already been popped, and
 320   // only the return needs to be executed. Don&#39;t deoptimize here.
 321   return !nm-&gt;is_at_poll_return(pc());
 322 }
 323 
 324 bool frame::can_be_deoptimized() const {
 325   if (!is_compiled_frame()) return false;
 326   CompiledMethod* nm = (CompiledMethod*)_cb;
 327 
 328   if( !nm-&gt;can_be_deoptimized() )
 329     return false;
 330 
 331   // address* pc_addr = &amp;(((address*) sp())[-1]); // TODO: PLATFORM
 332   // if (Continuation::is_return_barrier_entry(*pc_addr)) {
 333   //   log_trace(jvmcont)(&quot;Can&#39;t deopt entry:&quot;);
 334   //   if (log_is_enabled(Trace, jvmcont)) {
 335   //     print_value_on(tty, NULL);
 336   //   }
 337   //   return false;
 338   // }
 339 
 340   return !nm-&gt;is_at_poll_return(pc());
 341 }
 342 
 343 void frame::deoptimize(JavaThread* thread) {
 344   // tty-&gt;print_cr(&quot;&gt;&gt;&gt; frame::deoptimize&quot;);
 345   // print_on(tty);
 346   assert(thread-&gt;frame_anchor()-&gt;has_last_Java_frame() &amp;&amp;
 347          thread-&gt;frame_anchor()-&gt;walkable(), &quot;must be&quot;);
 348   // Schedule deoptimization of an nmethod activation with this frame.
 349   assert(_cb != NULL &amp;&amp; _cb-&gt;is_compiled(), &quot;must be&quot;);
 350 
 351   // log_develop_trace(jvmcont)(&quot;&gt;&gt;&gt;&gt; frame::deoptimize %ld&quot;, os::current_thread_id());
 352   // tty-&gt;print_cr(&quot;&gt;&gt;&gt;&gt; frame::deoptimize: %ld&quot;, os::current_thread_id()); print_on(tty);
 353 
 354   // If the call site is a MethodHandle call site use the MH deopt
 355   // handler.
 356   CompiledMethod* cm = (CompiledMethod*) _cb;
 357   address deopt = cm-&gt;is_method_handle_return(pc()) ?
 358                         cm-&gt;deopt_mh_handler_begin() :
 359                         cm-&gt;deopt_handler_begin();
 360 
 361   // Save the original pc before we patch in the new one
 362   cm-&gt;set_original_pc(this, pc());
 363   patch_pc(thread, deopt);
 364   assert(is_deoptimized_frame(), &quot;must be&quot;);
 365 
 366 #ifdef ASSERT
 367   {
 368     frame check = thread-&gt;last_frame();
 369     if (is_older(check.id())) {
 370       RegisterMap map(thread, false);
 371       while (id() != check.id()) {
 372         check = check.sender(&amp;map);
 373       }
 374       assert(check.is_deoptimized_frame(), &quot;missed deopt&quot;);
 375     }
 376   }
 377 #endif // ASSERT
 378 }
 379 
 380 frame frame::java_sender() const {
 381   RegisterMap map(JavaThread::current(), false);
 382   frame s;
 383   for (s = sender(&amp;map); !(s.is_java_frame() || s.is_first_frame()); s = s.sender(&amp;map)) ;
 384   guarantee(s.is_java_frame(), &quot;tried to get caller of first java frame&quot;);
 385   return s;
 386 }
 387 
 388 frame frame::real_sender(RegisterMap* map) const {
 389   frame result = sender(map);
 390   while (result.is_runtime_frame() ||
 391          result.is_ignored_frame()) {
 392     result = result.sender(map);
 393   }
 394   return result;
 395 }
 396 
 397 // Interpreter frames
 398 
 399 
 400 void frame::interpreter_frame_set_locals(intptr_t* locs)  {
 401   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
 402   *interpreter_frame_locals_addr() = locs;
 403 }
 404 
 405 Method* frame::interpreter_frame_method() const {
 406   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
 407   Method* m = *interpreter_frame_method_addr();
 408   assert(m-&gt;is_method(), &quot;not a Method*&quot;);
 409   return m;
 410 }
 411 
 412 void frame::interpreter_frame_set_method(Method* method) {
 413   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
 414   *interpreter_frame_method_addr() = method;
 415 }
 416 
 417 void frame::interpreter_frame_set_mirror(oop mirror) {
 418   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
 419   *interpreter_frame_mirror_addr() = mirror;
 420 }
 421 
 422 jint frame::interpreter_frame_bci() const {
 423   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
 424   address bcp = interpreter_frame_bcp();
 425   return interpreter_frame_method()-&gt;bci_from(bcp);
 426 }
 427 
 428 address frame::interpreter_frame_bcp() const {
 429   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
 430   address bcp = (address)*interpreter_frame_bcp_addr();
 431   return interpreter_frame_method()-&gt;bcp_from(bcp);
 432 }
 433 
 434 void frame::interpreter_frame_set_bcp(address bcp) {
 435   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
 436   *interpreter_frame_bcp_addr() = (intptr_t)bcp;
 437 }
 438 
 439 address frame::interpreter_frame_mdp() const {
 440   assert(ProfileInterpreter, &quot;must be profiling interpreter&quot;);
 441   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
 442   return (address)*interpreter_frame_mdp_addr();
 443 }
 444 
 445 void frame::interpreter_frame_set_mdp(address mdp) {
 446   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
 447   assert(ProfileInterpreter, &quot;must be profiling interpreter&quot;);
 448   *interpreter_frame_mdp_addr() = (intptr_t)mdp;
 449 }
 450 
 451 BasicObjectLock* frame::next_monitor_in_interpreter_frame(BasicObjectLock* current) const {
 452   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
 453 #ifdef ASSERT
 454   interpreter_frame_verify_monitor(current);
 455 #endif
 456   BasicObjectLock* next = (BasicObjectLock*) (((intptr_t*) current) + interpreter_frame_monitor_size());
 457   return next;
 458 }
 459 
 460 BasicObjectLock* frame::previous_monitor_in_interpreter_frame(BasicObjectLock* current) const {
 461   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
 462 #ifdef ASSERT
 463 //   // This verification needs to be checked before being enabled
 464 //   interpreter_frame_verify_monitor(current);
 465 #endif
 466   BasicObjectLock* previous = (BasicObjectLock*) (((intptr_t*) current) - interpreter_frame_monitor_size());
 467   return previous;
 468 }
 469 
 470 // Interpreter locals and expression stack locations.
 471 
 472 intptr_t* frame::interpreter_frame_local_at(int index) const {
 473   const int n = Interpreter::local_offset_in_bytes(index)/wordSize;
 474   return &amp;((*interpreter_frame_locals_addr())[n]);
 475 }
 476 
 477 intptr_t* frame::interpreter_frame_expression_stack_at(jint offset) const {
 478   const int i = offset * interpreter_frame_expression_stack_direction();
 479   const int n = i * Interpreter::stackElementWords;
 480   return &amp;(interpreter_frame_expression_stack()[n]);
 481 }
 482 
 483 jint frame::interpreter_frame_expression_stack_size() const {
 484   // Number of elements on the interpreter expression stack
 485   // Callers should span by stackElementWords
 486   int element_size = Interpreter::stackElementWords;
 487   size_t stack_size = 0;
 488   if (frame::interpreter_frame_expression_stack_direction() &lt; 0) {
 489     stack_size = (interpreter_frame_expression_stack() -
 490                   interpreter_frame_tos_address() + 1)/element_size;
 491   } else {
 492     stack_size = (interpreter_frame_tos_address() -
 493                   interpreter_frame_expression_stack() + 1)/element_size;
 494   }
 495   assert( stack_size &lt;= (size_t)max_jint, &quot;stack size too big&quot;);
 496   return ((jint)stack_size);
 497 }
 498 
 499 
 500 // (frame::interpreter_frame_sender_sp accessor is in frame_&lt;arch&gt;.cpp)
 501 
 502 const char* frame::print_name() const {
 503   if (is_native_frame())      return &quot;Native&quot;;
 504   if (is_interpreted_frame()) return &quot;Interpreted&quot;;
 505   if (is_compiled_frame()) {
 506     if (is_deoptimized_frame()) return &quot;Deoptimized&quot;;
 507     return &quot;Compiled&quot;;
 508   }
 509   if (sp() == NULL)            return &quot;Empty&quot;;
 510   return &quot;C&quot;;
 511 }
 512 
 513 void frame::print_value_on(outputStream* st, JavaThread *thread) const {
 514   NOT_PRODUCT(address begin = pc()-40;)
 515   NOT_PRODUCT(address end   = NULL;)
 516 
 517   st-&gt;print(&quot;%s frame (sp=&quot; INTPTR_FORMAT &quot; unextended sp=&quot; INTPTR_FORMAT, print_name(), p2i(sp()), p2i(unextended_sp()));
 518   if (sp() != NULL)
 519     st-&gt;print(&quot;, fp=&quot; INTPTR_FORMAT &quot;, real_fp=&quot; INTPTR_FORMAT &quot;, pc=&quot; INTPTR_FORMAT,
 520               p2i(fp()), p2i(real_fp()), p2i(pc()));
 521 
 522   if (StubRoutines::contains(pc())) {
 523     st-&gt;print_cr(&quot;)&quot;);
 524     st-&gt;print(&quot;(&quot;);
 525     StubCodeDesc* desc = StubCodeDesc::desc_for(pc());
 526     st-&gt;print(&quot;~Stub::%s&quot;, desc-&gt;name());
 527     NOT_PRODUCT(begin = desc-&gt;begin(); end = desc-&gt;end();)
 528   } else if (Interpreter::contains(pc())) {
 529     st-&gt;print_cr(&quot;)&quot;);
 530     st-&gt;print(&quot;(&quot;);
 531     InterpreterCodelet* desc = Interpreter::codelet_containing(pc());
 532     if (desc != NULL) {
 533       st-&gt;print(&quot;~&quot;);
 534       desc-&gt;print_on(st);
 535       NOT_PRODUCT(begin = desc-&gt;code_begin(); end = desc-&gt;code_end();)
 536     } else {
 537       st-&gt;print(&quot;~interpreter&quot;);
 538     }
 539   }
 540   st-&gt;print_cr(&quot;)&quot;);
 541 
 542   if (_cb != NULL) {
 543     st-&gt;print(&quot;     &quot;);
 544     _cb-&gt;print_value_on(st);
 545     st-&gt;cr();
 546 #ifndef PRODUCT
 547     if (end == NULL) {
 548       begin = _cb-&gt;code_begin();
 549       end   = _cb-&gt;code_end();
 550     }
 551 #endif
 552   }
 553   NOT_PRODUCT(if (WizardMode &amp;&amp; Verbose) Disassembler::decode(begin, end);)
 554 }
 555 
 556 
 557 void frame::print_on(outputStream* st) const {
 558   print_value_on(st,NULL);
 559   if (is_interpreted_frame()) {
 560     interpreter_frame_print_on(st);
 561   }
 562 }
 563 
 564 
 565 void frame::interpreter_frame_print_on(outputStream* st) const {
 566 #ifndef PRODUCT
 567   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
 568   jint i;
 569   for (i = 0; i &lt; interpreter_frame_method()-&gt;max_locals(); i++ ) {
 570     intptr_t x = *interpreter_frame_local_at(i);
 571     st-&gt;print(&quot; - local  [&quot; INTPTR_FORMAT &quot;]&quot;, x);
 572     st-&gt;fill_to(23);
 573     st-&gt;print_cr(&quot;; #%d&quot;, i);
 574   }
 575   for (i = interpreter_frame_expression_stack_size() - 1; i &gt;= 0; --i ) {
 576     intptr_t x = *interpreter_frame_expression_stack_at(i);
 577     st-&gt;print(&quot; - stack  [&quot; INTPTR_FORMAT &quot;]&quot;, x);
 578     st-&gt;fill_to(23);
 579     st-&gt;print_cr(&quot;; #%d&quot;, i);
 580   }
 581   // locks for synchronization
 582   for (BasicObjectLock* current = interpreter_frame_monitor_end();
 583        current &lt; interpreter_frame_monitor_begin();
 584        current = next_monitor_in_interpreter_frame(current)) {
 585     st-&gt;print(&quot; - obj    [&quot;);
 586     current-&gt;obj()-&gt;print_value_on(st);
 587     st-&gt;print_cr(&quot;]&quot;);
 588     st-&gt;print(&quot; - lock   [&quot;);
 589     current-&gt;lock()-&gt;print_on(st);
 590     st-&gt;print_cr(&quot;]&quot;);
 591   }
 592   // monitor
 593   st-&gt;print_cr(&quot; - monitor[&quot; INTPTR_FORMAT &quot;]&quot;, p2i(interpreter_frame_monitor_begin()));
 594   // bcp
 595   st-&gt;print(&quot; - bcp    [&quot; INTPTR_FORMAT &quot;]&quot;, p2i(interpreter_frame_bcp()));
 596   st-&gt;fill_to(23);
 597   st-&gt;print_cr(&quot;; @%d&quot;, interpreter_frame_bci());
 598   // locals
 599   st-&gt;print_cr(&quot; - locals [&quot; INTPTR_FORMAT &quot;]&quot;, p2i(interpreter_frame_local_at(0)));
 600   // method
 601   st-&gt;print(&quot; - method [&quot; INTPTR_FORMAT &quot;]&quot;, p2i(interpreter_frame_method()));
 602   st-&gt;fill_to(23);
 603   st-&gt;print(&quot;; &quot;);
 604   interpreter_frame_method()-&gt;print_name(st);
 605   st-&gt;cr();
 606 #endif
 607 }
 608 
 609 // Print whether the frame is in the VM or OS indicating a HotSpot problem.
 610 // Otherwise, it&#39;s likely a bug in the native library that the Java code calls,
 611 // hopefully indicating where to submit bugs.
 612 void frame::print_C_frame(outputStream* st, char* buf, int buflen, address pc) {
 613   // C/C++ frame
 614   bool in_vm = os::address_is_in_vm(pc);
 615   st-&gt;print(in_vm ? &quot;V&quot; : &quot;C&quot;);
 616 
 617   int offset;
 618   bool found;
 619 
 620   // libname
 621   found = os::dll_address_to_library_name(pc, buf, buflen, &amp;offset);
 622   if (found) {
 623     // skip directory names
 624     const char *p1, *p2;
 625     p1 = buf;
 626     int len = (int)strlen(os::file_separator());
 627     while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;
 628     st-&gt;print(&quot;  [%s+0x%x]&quot;, p1, offset);
 629   } else {
 630     st-&gt;print(&quot;  &quot; PTR_FORMAT, p2i(pc));
 631   }
 632 
 633   found = os::dll_address_to_function_name(pc, buf, buflen, &amp;offset);
 634   if (found) {
 635     st-&gt;print(&quot;  %s+0x%x&quot;, buf, offset);
 636   }
 637 }
 638 
 639 // frame::print_on_error() is called by fatal error handler. Notice that we may
 640 // crash inside this function if stack frame is corrupted. The fatal error
 641 // handler can catch and handle the crash. Here we assume the frame is valid.
 642 //
 643 // First letter indicates type of the frame:
 644 //    J: Java frame (compiled)
 645 //    A: Java frame (aot compiled)
 646 //    j: Java frame (interpreted)
 647 //    V: VM frame (C/C++)
 648 //    v: Other frames running VM generated code (e.g. stubs, adapters, etc.)
 649 //    C: C/C++ frame
 650 //
 651 // We don&#39;t need detailed frame type as that in frame::print_name(). &quot;C&quot;
 652 // suggests the problem is in user lib; everything else is likely a VM bug.
 653 
 654 void frame::print_on_error(outputStream* st, char* buf, int buflen, bool verbose) const {
 655   if (_cb != NULL) {
 656     if (Interpreter::contains(pc())) {
 657       Method* m = this-&gt;interpreter_frame_method();
 658       if (m != NULL) {
 659         m-&gt;name_and_sig_as_C_string(buf, buflen);
 660         st-&gt;print(&quot;j  %s&quot;, buf);
 661         st-&gt;print(&quot;+%d&quot;, this-&gt;interpreter_frame_bci());
 662         ModuleEntry* module = m-&gt;method_holder()-&gt;module();
 663         if (module-&gt;is_named()) {
 664           module-&gt;name()-&gt;as_C_string(buf, buflen);
 665           st-&gt;print(&quot; %s&quot;, buf);
 666           if (module-&gt;version() != NULL) {
 667             module-&gt;version()-&gt;as_C_string(buf, buflen);
 668             st-&gt;print(&quot;@%s&quot;, buf);
 669           }
 670         }
 671       } else {
 672         st-&gt;print(&quot;j  &quot; PTR_FORMAT, p2i(pc()));
 673       }
 674     } else if (StubRoutines::contains(pc())) {
 675       StubCodeDesc* desc = StubCodeDesc::desc_for(pc());
 676       if (desc != NULL) {
 677         st-&gt;print(&quot;v  ~StubRoutines::%s &quot; PTR_FORMAT, desc-&gt;name(), p2i(pc()));
 678       } else {
 679         st-&gt;print(&quot;v  ~StubRoutines::&quot; PTR_FORMAT, p2i(pc()));
 680       }
 681     } else if (_cb-&gt;is_buffer_blob()) {
 682       st-&gt;print(&quot;v  ~BufferBlob::%s &quot; PTR_FORMAT, ((BufferBlob *)_cb)-&gt;name(), p2i(pc()));
 683     } else if (_cb-&gt;is_compiled()) {
 684       CompiledMethod* cm = (CompiledMethod*)_cb;
 685       Method* m = cm-&gt;method();
 686       if (m != NULL) {
 687         if (cm-&gt;is_aot()) {
 688           st-&gt;print(&quot;A %d &quot;, cm-&gt;compile_id());
 689         } else if (cm-&gt;is_nmethod()) {
 690           nmethod* nm = cm-&gt;as_nmethod();
 691           st-&gt;print(&quot;J %d%s&quot;, nm-&gt;compile_id(), (nm-&gt;is_osr_method() ? &quot;%&quot; : &quot;&quot;));
 692           st-&gt;print(&quot; %s&quot;, nm-&gt;compiler_name());
 693         }
 694         m-&gt;name_and_sig_as_C_string(buf, buflen);
 695         st-&gt;print(&quot; %s&quot;, buf);
 696         ModuleEntry* module = m-&gt;method_holder()-&gt;module();
 697         if (module-&gt;is_named()) {
 698           module-&gt;name()-&gt;as_C_string(buf, buflen);
 699           st-&gt;print(&quot; %s&quot;, buf);
 700           if (module-&gt;version() != NULL) {
 701             module-&gt;version()-&gt;as_C_string(buf, buflen);
 702             st-&gt;print(&quot;@%s&quot;, buf);
 703           }
 704         }
 705         st-&gt;print(&quot; (%d bytes) @ &quot; PTR_FORMAT &quot; [&quot; PTR_FORMAT &quot;+&quot; INTPTR_FORMAT &quot;]&quot;,
 706                   m-&gt;code_size(), p2i(_pc), p2i(_cb-&gt;code_begin()), _pc - _cb-&gt;code_begin());
 707 #if INCLUDE_JVMCI
 708         if (cm-&gt;is_nmethod()) {
 709           nmethod* nm = cm-&gt;as_nmethod();
 710           const char* jvmciName = nm-&gt;jvmci_name();
 711           if (jvmciName != NULL) {
 712             st-&gt;print(&quot; (%s)&quot;, jvmciName);
 713           }
 714         }
 715 #endif
 716       } else {
 717         st-&gt;print(&quot;J  &quot; PTR_FORMAT, p2i(pc()));
 718       }
 719     } else if (_cb-&gt;is_runtime_stub()) {
 720       st-&gt;print(&quot;v  ~RuntimeStub::%s &quot; PTR_FORMAT, ((RuntimeStub *)_cb)-&gt;name(), p2i(pc()));
 721     } else if (_cb-&gt;is_deoptimization_stub()) {
 722       st-&gt;print(&quot;v  ~DeoptimizationBlob &quot; PTR_FORMAT, p2i(pc()));
 723     } else if (_cb-&gt;is_exception_stub()) {
 724       st-&gt;print(&quot;v  ~ExceptionBlob &quot; PTR_FORMAT, p2i(pc()));
 725     } else if (_cb-&gt;is_safepoint_stub()) {
 726       st-&gt;print(&quot;v  ~SafepointBlob &quot; PTR_FORMAT, p2i(pc()));
 727     } else if (_cb-&gt;is_adapter_blob()) {
 728       st-&gt;print(&quot;v  ~AdapterBlob &quot; PTR_FORMAT, p2i(pc()));
 729     } else if (_cb-&gt;is_vtable_blob()) {
 730       st-&gt;print(&quot;v  ~VtableBlob &quot; PTR_FORMAT, p2i(pc()));
 731     } else if (_cb-&gt;is_method_handles_adapter_blob()) {
 732       st-&gt;print(&quot;v  ~MethodHandlesAdapterBlob &quot; PTR_FORMAT, p2i(pc()));
 733     } else if (_cb-&gt;is_uncommon_trap_stub()) {
 734       st-&gt;print(&quot;v  ~UncommonTrapBlob &quot; PTR_FORMAT, p2i(pc()));
 735     } else {
 736       st-&gt;print(&quot;v  blob &quot; PTR_FORMAT, p2i(pc()));
 737     }
 738   } else {
 739     print_C_frame(st, buf, buflen, pc());
 740   }
 741 }
 742 
 743 
 744 /*
 745   The interpreter_frame_expression_stack_at method in the case of SPARC needs the
 746   max_stack value of the method in order to compute the expression stack address.
 747   It uses the Method* in order to get the max_stack value but during GC this
 748   Method* value saved on the frame is changed by reverse_and_push and hence cannot
 749   be used. So we save the max_stack value in the FrameClosure object and pass it
 750   down to the interpreter_frame_expression_stack_at method
 751 */
 752 class InterpreterFrameClosure : public OffsetClosure {
 753  private:
 754   frame* _fr;
 755   OopClosure* _f;
 756   int    _max_locals;
 757   int    _max_stack;
 758 
 759  public:
 760   InterpreterFrameClosure(frame* fr, int max_locals, int max_stack,
 761                           OopClosure* f) {
 762     _fr         = fr;
 763     _max_locals = max_locals;
 764     _max_stack  = max_stack;
 765     _f          = f;
 766   }
 767 
 768   void offset_do(int offset) {
 769     oop* addr;
 770     if (offset &lt; _max_locals) {
 771       addr = (oop*) _fr-&gt;interpreter_frame_local_at(offset);
 772       assert((intptr_t*)addr &gt;= _fr-&gt;sp(), &quot;must be inside the frame&quot;);
 773       _f-&gt;do_oop(addr);
 774     } else {
 775       addr = (oop*) _fr-&gt;interpreter_frame_expression_stack_at((offset - _max_locals));
 776       // In case of exceptions, the expression stack is invalid and the esp will be reset to express
 777       // this condition. Therefore, we call f only if addr is &#39;inside&#39; the stack (i.e., addr &gt;= esp for Intel).
 778       bool in_stack;
 779       if (frame::interpreter_frame_expression_stack_direction() &gt; 0) {
 780         in_stack = (intptr_t*)addr &lt;= _fr-&gt;interpreter_frame_tos_address();
 781       } else {
 782         in_stack = (intptr_t*)addr &gt;= _fr-&gt;interpreter_frame_tos_address();
 783       }
 784       if (in_stack) {
 785         _f-&gt;do_oop(addr);
 786       }
 787     }
 788   }
 789 
 790   int max_locals()  { return _max_locals; }
 791   frame* fr()       { return _fr; }
 792 };
 793 
 794 
 795 class InterpretedArgumentOopFinder: public SignatureIterator {
 796  private:
 797   OopClosure* _f;        // Closure to invoke
 798   int    _offset;        // TOS-relative offset, decremented with each argument
 799   bool   _has_receiver;  // true if the callee has a receiver
 800   frame* _fr;
 801 
 802   friend class SignatureIterator;  // so do_parameters_on can call do_type
 803   void do_type(BasicType type) {
 804     _offset -= parameter_type_word_count(type);
 805     if (is_reference_type(type)) oop_offset_do();
 806    }
 807 
 808   void oop_offset_do() {
 809     oop* addr;
 810     addr = (oop*)_fr-&gt;interpreter_frame_tos_at(_offset);
 811     _f-&gt;do_oop(addr);
 812   }
 813 
 814  public:
 815   InterpretedArgumentOopFinder(Symbol* signature, bool has_receiver, frame* fr, OopClosure* f) : SignatureIterator(signature), _has_receiver(has_receiver) {
 816     // compute size of arguments
 817     int args_size = ArgumentSizeComputer(signature).size() + (has_receiver ? 1 : 0);
 818     assert(!fr-&gt;is_interpreted_frame() ||
 819            args_size &lt;= fr-&gt;interpreter_frame_expression_stack_size(),
 820             &quot;args cannot be on stack anymore&quot;);
 821     // initialize InterpretedArgumentOopFinder
 822     _f         = f;
 823     _fr        = fr;
 824     _offset    = args_size;
 825   }
 826 
 827   void oops_do() {
 828     if (_has_receiver) {
 829       --_offset;
 830       oop_offset_do();
 831     }
 832     do_parameters_on(this);
 833   }
 834 };
 835 
 836 
 837 // Entry frame has following form (n arguments)
 838 //         +-----------+
 839 //   sp -&gt; |  last arg |
 840 //         +-----------+
 841 //         :    :::    :
 842 //         +-----------+
 843 // (sp+n)-&gt;|  first arg|
 844 //         +-----------+
 845 
 846 
 847 
 848 // visits and GC&#39;s all the arguments in entry frame
 849 class EntryFrameOopFinder: public SignatureIterator {
 850  private:
 851   bool   _is_static;
 852   int    _offset;
 853   frame* _fr;
 854   OopClosure* _f;
 855 
 856   friend class SignatureIterator;  // so do_parameters_on can call do_type
 857   void do_type(BasicType type) {
 858     // decrement offset before processing the type
 859     _offset -= parameter_type_word_count(type);
 860     assert (_offset &gt;= 0, &quot;illegal offset&quot;);
 861     if (is_reference_type(type))  oop_at_offset_do(_offset);
 862  }
 863 
 864   void oop_at_offset_do(int offset) {
 865     assert (offset &gt;= 0, &quot;illegal offset&quot;);
 866     oop* addr = (oop*) _fr-&gt;entry_frame_argument_at(offset);
 867     _f-&gt;do_oop(addr);
 868   }
 869 
 870  public:
 871   EntryFrameOopFinder(frame* frame, Symbol* signature, bool is_static) : SignatureIterator(signature) {
 872     _f = NULL; // will be set later
 873     _fr = frame;
 874     _is_static = is_static;
 875     _offset = ArgumentSizeComputer(signature).size();  // pre-decremented down to zero
 876   }
 877 
 878   void arguments_do(OopClosure* f) {
 879     _f = f;
 880     if (!_is_static)  oop_at_offset_do(_offset); // do the receiver
 881     do_parameters_on(this);
 882   }
 883 
 884 };
 885 
 886 oop* frame::interpreter_callee_receiver_addr(Symbol* signature) {
 887   ArgumentSizeComputer asc(signature);
 888   int size = asc.size();
 889   return (oop *)interpreter_frame_tos_at(size);
 890 }
 891 
 892 void frame::oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache) {
 893   Thread *thread = Thread::current();
 894   methodHandle m (thread, interpreter_frame_method());
 895   jint bci = interpreter_frame_bci();
 896 
 897   InterpreterOopMap mask;
 898   if (query_oop_map_cache) {
 899     m-&gt;mask_for(bci, &amp;mask);
 900   } else {
 901     OopMapCache::compute_one_oop_map(m, bci, &amp;mask);
 902   }
 903   
 904   oops_interpreted_do0(f, map, m, bci, mask);
 905 }
 906 
 907 void frame::oops_interpreted_do(OopClosure* f, const RegisterMap* map, const InterpreterOopMap&amp; mask) {
 908   Thread *thread = Thread::current();
 909   methodHandle m (thread, interpreter_frame_method());
 910   jint bci = interpreter_frame_bci();
 911   oops_interpreted_do0(f, map, m, bci, mask);
 912 }
 913 
 914 void frame::oops_interpreted_do0(OopClosure* f, const RegisterMap* map, methodHandle m, jint bci, const InterpreterOopMap&amp; mask) {
 915   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
 916   // assert(map != NULL, &quot;map must be set&quot;);
 917 
 918   assert(!Universe::heap()-&gt;is_in(m()),
 919           &quot;must be valid oop&quot;);
 920   assert(m-&gt;is_method(), &quot;checking frame value&quot;);
 921   assert((m-&gt;is_native() &amp;&amp; bci == 0)  ||
 922          (!m-&gt;is_native() &amp;&amp; bci &gt;= 0 &amp;&amp; bci &lt; m-&gt;code_size()),
 923          &quot;invalid bci value&quot;);
 924 
 925   // Handle the monitor elements in the activation
 926   for (
 927     BasicObjectLock* current = interpreter_frame_monitor_end();
 928     current &lt; interpreter_frame_monitor_begin();
 929     current = next_monitor_in_interpreter_frame(current)
 930   ) {
 931 #ifdef ASSERT
 932     interpreter_frame_verify_monitor(current);
 933 #endif
 934     current-&gt;oops_do(f);
 935   }
 936 
 937   if (m-&gt;is_native()) {
 938     f-&gt;do_oop(interpreter_frame_temp_oop_addr());
 939   }
 940 
 941   // The method pointer in the frame might be the only path to the method&#39;s
 942   // klass, and the klass needs to be kept alive while executing. The GCs
 943   // don&#39;t trace through method pointers, so the mirror of the method&#39;s klass
 944   // is installed as a GC root.
 945   f-&gt;do_oop(interpreter_frame_mirror_addr());
 946 
 947   int max_locals = m-&gt;is_native() ? m-&gt;size_of_parameters() : m-&gt;max_locals();
 948 
 949   Symbol* signature = NULL;
 950   bool has_receiver = false;
 951 
 952   // Process a callee&#39;s arguments if we are at a call site
 953   // (i.e., if we are at an invoke bytecode)
 954   // This is used sometimes for calling into the VM, not for another
 955   // interpreted or compiled frame.
 956   if (!m-&gt;is_native()) {
 957     Bytecode_invoke call = Bytecode_invoke_check(m, bci);
 958     if (call.is_valid()) {
 959       signature = call.signature();
 960       has_receiver = call.has_receiver();
 961       if (map != NULL &amp;&amp; map-&gt;include_argument_oops() &amp;&amp;
 962           interpreter_frame_expression_stack_size() &gt; 0) {
 963         // ResourceMark rm(thread);  // is this right ???
 964         // we are at a call site &amp; the expression stack is not empty
 965         // =&gt; process callee&#39;s arguments
 966         //
 967         // Note: The expression stack can be empty if an exception
 968         //       occurred during method resolution/execution. In all
 969         //       cases we empty the expression stack completely be-
 970         //       fore handling the exception (the exception handling
 971         //       code in the interpreter calls a blocking runtime
 972         //       routine which can cause this code to be executed).
 973         //       (was bug gri 7/27/98)
 974         oops_interpreted_arguments_do(signature, has_receiver, f);
 975       }
 976     }
 977   }
 978 
 979   InterpreterFrameClosure blk(this, max_locals, m-&gt;max_stack(), f);
 980 
 981   // process locals &amp; expression stack
 982   // mask.print();
 983   mask.iterate_oop(&amp;blk);
 984 }
 985 
 986 
 987 void frame::oops_interpreted_arguments_do(Symbol* signature, bool has_receiver, OopClosure* f) {
 988   InterpretedArgumentOopFinder finder(signature, has_receiver, this, f);
 989   finder.oops_do();
 990 }
 991 
 992 void frame::oops_code_blob_do(OopClosure* f, CodeBlobClosure* cf, DerivedOopClosure* df, const RegisterMap* reg_map) {
 993   assert(_cb != NULL, &quot;sanity check&quot;);
 994   assert((oop_map() == NULL) == (_cb-&gt;oop_maps() == NULL), &quot;frame and _cb must agree that oopmap is set or not&quot;);
 995   if (oop_map() != NULL) {
 996     _oop_map-&gt;oops_do(this, reg_map, f, df);
 997 
 998     // Preserve potential arguments for a callee. We handle this by dispatching
 999     // on the codeblob. For c2i, we do
1000     if (reg_map-&gt;include_argument_oops()) {
1001       _cb-&gt;preserve_callee_argument_oops(*this, reg_map, f);
1002     }
1003   }
1004   // In cases where perm gen is collected, GC will want to mark
1005   // oops referenced from nmethods active on thread stacks so as to
1006   // prevent them from being collected. However, this visit should be
1007   // restricted to certain phases of the collection only. The
1008   // closure decides how it wants nmethods to be traced.
1009   if (cf != NULL)
1010     cf-&gt;do_code_blob(_cb);
1011 }
1012 
1013 class CompiledArgumentOopFinder: public SignatureIterator {
1014  protected:
1015   OopClosure*     _f;
1016   int             _offset;        // the current offset, incremented with each argument
1017   bool            _has_receiver;  // true if the callee has a receiver
1018   bool            _has_appendix;  // true if the call has an appendix
1019   frame           _fr;
1020   RegisterMap*    _reg_map;
1021   int             _arg_size;
1022   VMRegPair*      _regs;        // VMReg list of arguments
1023 
1024   friend class SignatureIterator;  // so do_parameters_on can call do_type
1025   void do_type(BasicType type) {
1026     if (is_reference_type(type))  handle_oop_offset();
1027     _offset += parameter_type_word_count(type);
1028   }
1029 
1030   virtual void handle_oop_offset() {
1031     // Extract low order register number from register array.
1032     // In LP64-land, the high-order bits are valid but unhelpful.
1033     VMReg reg = _regs[_offset].first();
1034     oop *loc = _fr.oopmapreg_to_location(reg, _reg_map);
1035   #ifdef ASSERT
1036     if (loc == NULL) {
1037       if (_reg_map-&gt;should_skip_missing())
1038         return;
1039       tty-&gt;print_cr(&quot;Error walking frame oops:&quot;);
1040       _fr.print_on(tty);
1041       assert(loc != NULL, &quot;reg: &quot; INTPTR_FORMAT &quot; %s loc: &quot; INTPTR_FORMAT, reg-&gt;value(), reg-&gt;name(), p2i(loc));
1042     }
1043   #endif
1044     _f-&gt;do_oop(loc);
1045   }
1046 
1047  public:
1048   CompiledArgumentOopFinder(Symbol* signature, bool has_receiver, bool has_appendix, OopClosure* f, frame fr, const RegisterMap* reg_map)
1049     : SignatureIterator(signature) {
1050 
1051     // initialize CompiledArgumentOopFinder
1052     _f         = f;
1053     _offset    = 0;
1054     _has_receiver = has_receiver;
1055     _has_appendix = has_appendix;
1056     _fr        = fr;
1057     _reg_map   = (RegisterMap*)reg_map;
1058     _arg_size  = ArgumentSizeComputer(signature).size() + (has_receiver ? 1 : 0) + (has_appendix ? 1 : 0);
1059 
1060     int arg_size;
1061     _regs = SharedRuntime::find_callee_arguments(signature, has_receiver, has_appendix, &amp;arg_size);
1062     assert(arg_size == _arg_size, &quot;wrong arg size&quot;);
1063   }
1064 
1065   void oops_do() {
1066     if (_has_receiver) {
1067       handle_oop_offset();
1068       _offset++;
1069     }
1070     do_parameters_on(this);
1071     if (_has_appendix) {
1072       handle_oop_offset();
1073       _offset++;
1074     }
1075   }
1076 };
1077 
1078 void frame::oops_compiled_arguments_do(Symbol* signature, bool has_receiver, bool has_appendix,
1079                                        const RegisterMap* reg_map, OopClosure* f) {
1080   // ResourceMark rm;
1081   CompiledArgumentOopFinder finder(signature, has_receiver, has_appendix, f, *this, reg_map);
1082   finder.oops_do();
1083 }
1084 
1085 // Get receiver out of callers frame, i.e. find parameter 0 in callers
1086 // frame.  Consult ADLC for where parameter 0 is to be found.  Then
1087 // check local reg_map for it being a callee-save register or argument
1088 // register, both of which are saved in the local frame.  If not found
1089 // there, it must be an in-stack argument of the caller.
1090 // Note: caller.sp() points to callee-arguments
1091 oop frame::retrieve_receiver(RegisterMap* reg_map) {
1092   frame caller = *this;
1093 
1094   // First consult the ADLC on where it puts parameter 0 for this signature.
1095   VMReg reg = SharedRuntime::name_for_receiver();
1096   oop* oop_adr = caller.oopmapreg_to_location(reg, reg_map);
1097   if (oop_adr == NULL) {
1098     guarantee(oop_adr != NULL, &quot;bad register save location&quot;);
1099     return NULL;
1100   }
1101   oop r = *oop_adr;
1102   assert(Universe::heap()-&gt;is_in_or_null(r), &quot;bad receiver: &quot; INTPTR_FORMAT &quot; (&quot; INTX_FORMAT &quot;)&quot;, p2i(r), p2i(r));
1103   return r;
1104 }
1105 
1106 
1107 BasicLock* frame::get_native_monitor() {
1108   nmethod* nm = (nmethod*)_cb;
1109   assert(_cb != NULL &amp;&amp; _cb-&gt;is_nmethod() &amp;&amp; nm-&gt;method()-&gt;is_native(),
1110          &quot;Should not call this unless it&#39;s a native nmethod&quot;);
1111   int byte_offset = in_bytes(nm-&gt;native_basic_lock_sp_offset());
1112   assert(byte_offset &gt;= 0, &quot;should not see invalid offset&quot;);
1113   return (BasicLock*) &amp;sp()[byte_offset / wordSize];
1114 }
1115 
1116 oop frame::get_native_receiver() {
1117   nmethod* nm = (nmethod*)_cb;
1118   assert(_cb != NULL &amp;&amp; _cb-&gt;is_nmethod() &amp;&amp; nm-&gt;method()-&gt;is_native(),
1119          &quot;Should not call this unless it&#39;s a native nmethod&quot;);
1120   int byte_offset = in_bytes(nm-&gt;native_receiver_sp_offset());
1121   assert(byte_offset &gt;= 0, &quot;should not see invalid offset&quot;);
1122   oop owner = ((oop*) sp())[byte_offset / wordSize];
1123   assert( Universe::heap()-&gt;is_in(owner), &quot;bad receiver&quot; );
1124   return owner;
1125 }
1126 
1127 void frame::oops_entry_do(OopClosure* f, const RegisterMap* map) {
1128   assert(map != NULL, &quot;map must be set&quot;);
1129   if (map-&gt;include_argument_oops()) {
1130     // must collect argument oops, as nobody else is doing it
1131     Thread *thread = Thread::current();
1132     methodHandle m (thread, entry_frame_call_wrapper()-&gt;callee_method());
1133     EntryFrameOopFinder finder(this, m-&gt;signature(), m-&gt;is_static());
1134     finder.arguments_do(f);
1135   }
1136   // Traverse the Handle Block saved in the entry frame
1137   entry_frame_call_wrapper()-&gt;oops_do(f);
1138 }
1139 
1140 
1141 void frame::oops_do_internal(OopClosure* f, CodeBlobClosure* cf, DerivedOopClosure* df, const RegisterMap* map, bool use_interpreter_oop_map_cache) {
1142 #ifndef PRODUCT
1143   // simulate GC crash here to dump java thread in error report
1144   if (CrashGCForDumpingJavaThread) {
1145     char *t = NULL;
1146     *t = &#39;c&#39;;
1147   }
1148 #endif
1149   if (is_interpreted_frame()) {
1150     oops_interpreted_do(f, map, use_interpreter_oop_map_cache);
1151   } else if (is_entry_frame()) {
1152     oops_entry_do(f, map);
1153   } else if (CodeCache::contains(pc())) {
1154     oops_code_blob_do(f, cf, df, map);
1155   } else {
1156     ShouldNotReachHere();
1157   }
1158 }
1159 
1160 void frame::nmethods_do(CodeBlobClosure* cf) {
1161   if (_cb != NULL &amp;&amp; _cb-&gt;is_nmethod()) {
1162     cf-&gt;do_code_blob(_cb);
1163   }
1164 }
1165 
1166 
1167 // Call f closure on the interpreted Method*s in the stack.
1168 void frame::metadata_do(MetadataClosure* f) {
1169   ResourceMark rm;
1170   if (is_interpreted_frame()) {
1171     Method* m = this-&gt;interpreter_frame_method();
1172     assert(m != NULL, &quot;expecting a method in this frame&quot;);
1173     f-&gt;do_metadata(m);
1174   }
1175 }
1176 
1177 void frame::verify(const RegisterMap* map) {
1178 #ifndef PRODUCT
1179   if (TraceCodeBlobStacks) {
1180     tty-&gt;print_cr(&quot;*** verify&quot;);
1181     print_on(tty);
1182   }
1183 #endif
1184 
1185   // for now make sure receiver type is correct
1186   if (is_interpreted_frame()) {
1187     Method* method = interpreter_frame_method();
1188     guarantee(method-&gt;is_method(), &quot;method is wrong in frame::verify&quot;);
1189     if (!method-&gt;is_static()) {
1190       // fetch the receiver
1191       oop* p = (oop*) interpreter_frame_local_at(0);
1192       // make sure we have the right receiver type
1193     }
1194   }
1195 #if COMPILER2_OR_JVMCI
1196   assert(DerivedPointerTable::is_empty(), &quot;must be empty before verify&quot;);
1197 #endif
1198   oops_do_internal(&amp;VerifyOopClosure::verify_oop, NULL, NULL, (RegisterMap*)map, false);
1199 }
1200 
1201 
1202 #ifdef ASSERT
1203 bool frame::verify_return_pc(address x) {
1204   if (StubRoutines::returns_to_call_stub(x)) {
1205     return true;
1206   }
1207   if (CodeCache::contains(x)) {
1208     return true;
1209   }
1210   if (Interpreter::contains(x)) {
1211     return true;
1212   }
1213   return false;
1214 }
1215 #endif
1216 
1217 #ifdef ASSERT
1218 void frame::interpreter_frame_verify_monitor(BasicObjectLock* value) const {
1219   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
1220   // verify that the value is in the right part of the frame
1221   address low_mark  = (address) interpreter_frame_monitor_end();
1222   address high_mark = (address) interpreter_frame_monitor_begin();
1223   address current   = (address) value;
1224 
1225   const int monitor_size = frame::interpreter_frame_monitor_size();
1226   guarantee((high_mark - current) % monitor_size  ==  0         , &quot;Misaligned top of BasicObjectLock*&quot;);
1227   guarantee( high_mark &gt; current                                , &quot;Current BasicObjectLock* higher than high_mark&quot;);
1228 
1229   guarantee((current - low_mark) % monitor_size  ==  0         , &quot;Misaligned bottom of BasicObjectLock*&quot;);
1230   guarantee( current &gt;= low_mark                               , &quot;Current BasicObjectLock* below than low_mark&quot;);
1231 }
1232 #endif
1233 
1234 #ifndef PRODUCT
1235 
1236 class FrameValuesOopClosure: public OopClosure, public DerivedOopClosure {
1237 private:
1238   FrameValues&amp; _values;
1239   int _frame_no;
1240 public:
1241   FrameValuesOopClosure(FrameValues&amp; values, int frame_no) : _values(values), _frame_no(frame_no) {}
1242   virtual void do_oop(oop* p)       { _values.describe(_frame_no, (intptr_t*)p, err_msg(&quot;oop for #%d&quot;, _frame_no)); }
1243   virtual void do_oop(narrowOop* p) { _values.describe(_frame_no, (intptr_t*)p, err_msg(&quot;narrow oop for #%d&quot;, _frame_no)); }
1244   virtual void do_derived_oop(oop *base, oop *derived) { 
1245     _values.describe(_frame_no, (intptr_t*)derived, err_msg(&quot;derived pointer (base: &quot; INTPTR_FORMAT &quot;) for #%d&quot;, p2i(base), _frame_no));
1246   }
1247 };
1248 
1249 class FrameValuesOopMapClosure: public OopMapClosure {
1250 private:
1251   const frame* _fr;
1252   const RegisterMap* _reg_map;
1253   FrameValues&amp; _values;
1254   int _frame_no;
1255 public:
1256   FrameValuesOopMapClosure(const frame* fr, const RegisterMap* reg_map, FrameValues&amp; values, int frame_no)
1257    : _fr(fr), _reg_map(reg_map), _values(values), _frame_no(frame_no) {}
1258 
1259   virtual void do_value(VMReg reg, OopMapValue::oop_types type) {
1260     intptr_t* p = (intptr_t*)_fr-&gt;oopmapreg_to_location(reg, _reg_map);
1261     if (p != NULL &amp;&amp; (((intptr_t)p &amp; WordAlignmentMask) == 0)) {
1262       const char* type_name = NULL;
1263       switch(type) {
1264         case OopMapValue::oop_value:          type_name = &quot;oop&quot;;          break;
1265         case OopMapValue::narrowoop_value:    type_name = &quot;narrow oop&quot;;   break;
1266         case OopMapValue::callee_saved_value: type_name = &quot;callee-saved&quot;; break;
1267         case OopMapValue::derived_oop_value:  type_name = &quot;derived&quot;;      break;
1268         // case OopMapValue::live_value:         type_name = &quot;live&quot;;         break;
1269         default: break;
1270       }
1271       if (type_name != NULL)
1272         _values.describe(_frame_no, p, err_msg(&quot;%s for #%d&quot;, type_name, _frame_no));
1273     }
1274   }
1275 };
1276 
1277 void frame::describe(FrameValues&amp; values, int frame_no, const RegisterMap* reg_map) {
1278   // boundaries: sp and the &#39;real&#39; frame pointer
1279   values.describe(-1, sp(), err_msg(&quot;sp for #%d&quot;, frame_no), 0);
1280   intptr_t* frame_pointer = real_fp(); // Note: may differ from fp()
1281 
1282   // print frame info at the highest boundary
1283   intptr_t* info_address = MAX2(sp(), frame_pointer);
1284 
1285   if (info_address != frame_pointer) {
1286     // print frame_pointer explicitly if not marked by the frame info
1287     values.describe(-1, frame_pointer, err_msg(&quot;frame pointer for #%d&quot;, frame_no), 1);
1288   }
1289 
1290   if (is_entry_frame() || is_compiled_frame() || is_interpreted_frame() || is_native_frame()) {
1291     // Label values common to most frames
1292     values.describe(-1, unextended_sp(), err_msg(&quot;unextended_sp for #%d&quot;, frame_no), 0);
1293   }
1294 
1295   if (is_interpreted_frame()) {
1296     Method* m = interpreter_frame_method();
1297     int bci = interpreter_frame_bci();
1298     InterpreterCodelet* desc = Interpreter::codelet_containing(pc());
1299 
1300     // Label the method and current bci
1301     values.describe(-1, info_address,
1302                     FormatBuffer&lt;1024&gt;(&quot;#%d method %s @ %d&quot;, frame_no, m-&gt;name_and_sig_as_C_string(), bci), 3);
1303     if (desc != NULL) {
1304       values.describe(-1, info_address, err_msg(&quot;- %s codelet: %s&quot;, 
1305         desc-&gt;bytecode()    &gt;= 0    ? Bytecodes::name(desc-&gt;bytecode()) : &quot;&quot;,
1306         desc-&gt;description() != NULL ? desc-&gt;description()               : &quot;?&quot;), 2);
1307     }
1308     values.describe(-1, info_address,
1309                     err_msg(&quot;- %d locals %d max stack&quot;, m-&gt;max_locals(), m-&gt;max_stack()), 2);
1310     values.describe(frame_no, (intptr_t*)sender_pc_addr(), Continuation::is_return_barrier_entry(*sender_pc_addr()) ? &quot;return address (return barrier)&quot; : &quot;return address&quot;);
1311 
1312     if (m-&gt;max_locals() &gt; 0) {
1313       intptr_t* l0 = interpreter_frame_local_at(0);
1314       intptr_t* ln = interpreter_frame_local_at(m-&gt;max_locals() - 1);
1315       values.describe(-1, MAX2(l0, ln), err_msg(&quot;locals for #%d&quot;, frame_no), 2);
1316       // Report each local and mark as owned by this frame
1317       for (int l = 0; l &lt; m-&gt;max_locals(); l++) {
1318         intptr_t* l0 = interpreter_frame_local_at(l);
1319         values.describe(frame_no, l0, err_msg(&quot;local %d&quot;, l), 1);
1320       }
1321     }
1322 
1323     if (interpreter_frame_monitor_begin() != interpreter_frame_monitor_end()) {
1324       values.describe(frame_no, (intptr_t*)interpreter_frame_monitor_begin(), &quot;monitors begin&quot;);
1325       values.describe(frame_no, (intptr_t*)interpreter_frame_monitor_end(), &quot;monitors end&quot;);
1326     }
1327 
1328     // Compute the actual expression stack size
1329     InterpreterOopMap mask;
1330     OopMapCache::compute_one_oop_map(methodHandle(Thread::current(), m), bci, &amp;mask);
1331     intptr_t* tos = NULL;
1332     // Report each stack element and mark as owned by this frame
1333     for (int e = 0; e &lt; mask.expression_stack_size(); e++) {
1334       tos = MAX2(tos, interpreter_frame_expression_stack_at(e));
1335       values.describe(frame_no, interpreter_frame_expression_stack_at(e),
1336                       err_msg(&quot;stack %d&quot;, e), 1);
1337     }
1338     if (tos != NULL) {
1339       values.describe(-1, tos, err_msg(&quot;expression stack for #%d&quot;, frame_no), 2);
1340     }
1341 
1342     if (reg_map != NULL) {
1343       FrameValuesOopClosure oopsFn(values, frame_no);
1344       oops_do(&amp;oopsFn, NULL, &amp;oopsFn, reg_map);
1345     }
1346   } else if (is_entry_frame()) {
1347     // For now just label the frame
1348     values.describe(-1, info_address, err_msg(&quot;#%d entry frame&quot;, frame_no), 2);
1349   } else if (cb()-&gt;is_compiled()) {
1350     // For now just label the frame
1351     CompiledMethod* cm = cb()-&gt;as_compiled_method();
1352     values.describe(-1, info_address,
1353                     FormatBuffer&lt;1024&gt;(&quot;#%d nmethod &quot; INTPTR_FORMAT &quot; for method %s%s%s&quot;, frame_no,
1354                                        p2i(cm),
1355                                        (cm-&gt;is_aot() ? &quot;A &quot;: &quot;J &quot;),
1356                                        cm-&gt;method()-&gt;name_and_sig_as_C_string(),
1357                                        (_deopt_state == is_deoptimized) ?
1358                                        &quot; (deoptimized)&quot; :
1359                                        ((_deopt_state == unknown) ? &quot; (state unknown)&quot; : &quot;&quot;)),
1360                     3);
1361 
1362     { // mark arguments (see nmethod::print_nmethod_labels)
1363       Method* m = cm-&gt;method();
1364 
1365       int stack_slot_offset = cm-&gt;frame_size() * wordSize; // offset, in bytes, to caller sp
1366       int sizeargs = m-&gt;size_of_parameters();
1367 
1368       BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sizeargs);
1369       VMRegPair* regs   = NEW_RESOURCE_ARRAY(VMRegPair, sizeargs);
1370       {
1371         int sig_index = 0;
1372         if (!m-&gt;is_static()) sig_bt[sig_index++] = T_OBJECT; // &#39;this&#39;
1373         for (SignatureStream ss(m-&gt;signature()); !ss.at_return_type(); ss.next()) {
1374           BasicType t = ss.type();
1375           assert(type2size[t] == 1 || type2size[t] == 2, &quot;size is 1 or 2&quot;);
1376           sig_bt[sig_index++] = t;
1377           if (type2size[t] == 2) sig_bt[sig_index++] = T_VOID;
1378         }
1379         assert(sig_index == sizeargs, &quot;&quot;);
1380       }
1381       int out_preserve = SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs, false);
1382       assert (out_preserve ==  m-&gt;num_stack_arg_slots(), &quot;&quot;);
1383       int sig_index = 0;
1384       int arg_index = (m-&gt;is_static() ? 0 : -1);
1385       for (SignatureStream ss(m-&gt;signature()); !ss.at_return_type(); ) {
1386         bool at_this = (arg_index == -1);
1387         bool at_old_sp = false;
1388         BasicType t = (at_this ? T_OBJECT : ss.type());
1389         assert(t == sig_bt[sig_index], &quot;sigs in sync&quot;);
1390         VMReg fst = regs[sig_index].first();
1391         if (fst-&gt;is_stack()) {
1392           assert (((int)fst-&gt;reg2stack()) &gt;= 0, &quot;reg2stack: %lu | %d&quot;, fst-&gt;reg2stack(), (int)fst-&gt;reg2stack());
1393           int offset = fst-&gt;reg2stack() * VMRegImpl::stack_slot_size + stack_slot_offset;
1394           intptr_t* stack_address = (intptr_t*)((address)sp() + offset);
1395           if (at_this)
1396             values.describe(frame_no, stack_address, err_msg(&quot;this for #%d&quot;, frame_no), 1);
1397           else
1398             values.describe(frame_no, stack_address, err_msg(&quot;param %d %s for #%d&quot;, arg_index, type2name(t), frame_no), 1);
1399         }
1400         sig_index += type2size[t];
1401         arg_index += 1;
1402         if (!at_this) ss.next();
1403       }
1404     }
1405 
1406     if (reg_map != NULL &amp;&amp; is_java_frame()) {
1407       int scope_no = 0;
1408       for (ScopeDesc* scope = cm-&gt;scope_desc_at(pc()); scope != NULL; scope = scope-&gt;sender(), scope_no++) {
1409         Method* m = scope-&gt;method();
1410         int  bci = scope-&gt;bci();
1411         values.describe(-1, info_address, err_msg(&quot;- #%d scope %s @ %d&quot;, scope_no, m-&gt;name_and_sig_as_C_string(), bci), 2);
1412 
1413         { // mark locals
1414           GrowableArray&lt;ScopeValue*&gt;* scvs = scope-&gt;locals();
1415           int scvs_length = scvs != NULL ? scvs-&gt;length() : 0;
1416           for (int i = 0; i &lt; scvs_length; i++) {
1417             intptr_t* stack_address = (intptr_t*)StackValue::stack_value_address(this, reg_map, scvs-&gt;at(i));
1418             if (stack_address != NULL)
1419               values.describe(frame_no, stack_address, err_msg(&quot;local %d for #%d (scope %d)&quot;, i, frame_no, scope_no), 1);
1420           }
1421         }
1422         { // mark expression stack
1423           GrowableArray&lt;ScopeValue*&gt;* scvs = scope-&gt;expressions();
1424           int scvs_length = scvs != NULL ? scvs-&gt;length() : 0;
1425           for (int i = 0; i &lt; scvs_length; i++) {
1426             intptr_t* stack_address = (intptr_t*)StackValue::stack_value_address(this, reg_map, scvs-&gt;at(i));
1427             if (stack_address != NULL)
1428               values.describe(frame_no, stack_address, err_msg(&quot;stack %d for #%d (scope %d)&quot;, i, frame_no, scope_no), 1);
1429           }
1430         }
1431       }
1432 
1433       FrameValuesOopClosure oopsFn(values, frame_no);
1434       oops_do(&amp;oopsFn, NULL, &amp;oopsFn, reg_map);
1435 
1436       if (oop_map() != NULL) {
1437         FrameValuesOopMapClosure valuesFn(this, reg_map, values, frame_no);
1438         // also OopMapValue::live_value ??
1439         oop_map()-&gt;all_type_do(this, OopMapValue::callee_saved_value, &amp;valuesFn);
1440       }
1441     }
1442 
1443     if (cm-&gt;method()-&gt;is_continuation_enter_intrinsic()) {
1444       address usp = (address)unextended_sp();
1445       values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::parent_offset())), &quot;parent&quot;);
1446       values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::cont_offset())),   &quot;continuation&quot;);
1447       values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::chunk_offset())),   &quot;chunk&quot;);
1448       values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::argsize_offset())), &quot;argsize&quot;);
1449       // values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::parent_cont_fastpath_offset())),      &quot;parent fastpath&quot;);
1450       // values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::parent_held_monitor_count_offset())), &quot;parent held monitor count&quot;);
1451     }
1452   } else if (is_native_frame()) {
1453     // For now just label the frame
1454     nmethod* nm = cb()-&gt;as_nmethod_or_null();
1455     values.describe(-1, info_address,
1456                     FormatBuffer&lt;1024&gt;(&quot;#%d nmethod &quot; INTPTR_FORMAT &quot; for native method %s&quot;, frame_no,
1457                                        p2i(nm), nm-&gt;method()-&gt;name_and_sig_as_C_string()), 2);
1458   } else {
1459     // provide default info if not handled before
1460     char *info = (char *) &quot;special frame&quot;;
1461     if ((_cb != NULL) &amp;&amp;
1462         (_cb-&gt;name() != NULL)) {
1463       info = (char *)_cb-&gt;name();
1464     }
1465     values.describe(-1, info_address, err_msg(&quot;#%d &lt;%s&gt;&quot;, frame_no, info), 2);
1466   }
1467 
1468   // platform dependent additional data
1469   describe_pd(values, frame_no);
1470 }
1471 
1472 #endif
1473 
1474 
1475 //-----------------------------------------------------------------------------------
1476 // StackFrameStream implementation
1477 
1478 StackFrameStream::StackFrameStream(JavaThread *thread, bool update, bool allow_missing_reg) : _reg_map(thread, update) {
1479   assert(thread-&gt;has_last_Java_frame(), &quot;sanity check&quot;);
1480   _fr = thread-&gt;last_frame();
1481   _is_done = false;
1482 #ifndef PRODUCT
1483   if (allow_missing_reg) {
1484     _reg_map.set_skip_missing(true);
1485   }
1486 #endif
1487 }
1488 
1489 
1490 #ifndef PRODUCT
1491 
1492 void FrameValues::describe(int owner, intptr_t* location, const char* description, int priority) {
1493   FrameValue fv;
1494   fv.location = location;
1495   fv.owner = owner;
1496   fv.priority = priority;
1497   fv.description = NEW_RESOURCE_ARRAY(char, strlen(description) + 1);
1498   strcpy(fv.description, description);
1499   _values.append(fv);
1500 }
1501 
1502 
1503 #ifdef ASSERT
1504 void FrameValues::validate() {
1505   _values.sort(compare);
1506   bool error = false;
1507   FrameValue prev;
1508   prev.owner = -1;
1509   for (int i = _values.length() - 1; i &gt;= 0; i--) {
1510     FrameValue fv = _values.at(i);
1511     if (fv.owner == -1) continue;
1512     if (prev.owner == -1) {
1513       prev = fv;
1514       continue;
1515     }
1516     if (prev.location == fv.location) {
1517       if (fv.owner != prev.owner) {
1518         tty-&gt;print_cr(&quot;overlapping storage&quot;);
1519         tty-&gt;print_cr(&quot; &quot; INTPTR_FORMAT &quot;: &quot; INTPTR_FORMAT &quot; %s&quot;, p2i(prev.location), *prev.location, prev.description);
1520         tty-&gt;print_cr(&quot; &quot; INTPTR_FORMAT &quot;: &quot; INTPTR_FORMAT &quot; %s&quot;, p2i(fv.location), *fv.location, fv.description);
1521         error = true;
1522       }
1523     } else {
1524       prev = fv;
1525     }
1526   }
1527   assert(!error, &quot;invalid layout&quot;);
1528 }
1529 #endif // ASSERT
1530 
1531 void FrameValues::print(JavaThread* thread) {
1532   _values.sort(compare);
1533 
1534   // Sometimes values like the fp can be invalid values if the
1535   // register map wasn&#39;t updated during the walk.  Trim out values
1536   // that aren&#39;t actually in the stack of the thread.
1537   int min_index = 0;
1538   int max_index = _values.length() - 1;
1539   intptr_t* v0 = _values.at(min_index).location;
1540   intptr_t* v1 = _values.at(max_index).location;
1541 
1542   if (thread == Thread::current()) {
1543     while (!thread-&gt;is_in_live_stack((address)v0)) {
1544       v0 = _values.at(++min_index).location;
1545     }
1546     while (!thread-&gt;is_in_live_stack((address)v1)) {
1547       v1 = _values.at(--max_index).location;
1548     }
1549   } else {
1550     while (!thread-&gt;is_in_full_stack((address)v0)) {
1551       v0 = _values.at(++min_index).location;
1552     }
1553     while (!thread-&gt;is_in_full_stack((address)v1)) {
1554       v1 = _values.at(--max_index).location;
1555     }
1556   }
1557   intptr_t* min = MIN2(v0, v1);
1558   intptr_t* max = MAX2(v0, v1);
1559   intptr_t* cur = max;
1560   intptr_t* last = NULL;
1561   for (int i = max_index; i &gt;= min_index; i--) {
1562     FrameValue fv = _values.at(i);
1563     while (cur &gt; fv.location) {
1564       tty-&gt;print_cr(&quot; &quot; INTPTR_FORMAT &quot;: &quot; INTPTR_FORMAT, p2i(cur), *cur);
1565       cur--;
1566     }
1567     if (last == fv.location) {
1568       const char* spacer = &quot;          &quot; LP64_ONLY(&quot;        &quot;);
1569       tty-&gt;print_cr(&quot; %s  %s %s&quot;, spacer, spacer, fv.description);
1570     } else {
1571       tty-&gt;print_cr(&quot; &quot; INTPTR_FORMAT &quot;: &quot; INTPTR_FORMAT &quot; %s&quot;, p2i(fv.location), *fv.location, fv.description);
1572       last = fv.location;
1573       cur--;
1574     }
1575   }
1576 }
1577 
1578 #endif // ndef PRODUCT
    </pre>
  </body>
</html>
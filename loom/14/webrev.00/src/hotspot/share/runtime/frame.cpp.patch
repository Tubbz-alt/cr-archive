diff a/src/hotspot/share/runtime/frame.cpp b/src/hotspot/share/runtime/frame.cpp
--- a/src/hotspot/share/runtime/frame.cpp
+++ b/src/hotspot/share/runtime/frame.cpp
@@ -887,10 +887,17 @@
   ArgumentSizeComputer asc(signature);
   int size = asc.size();
   return (oop *)interpreter_frame_tos_at(size);
 }
 
+oop frame::interpreter_callee_receiver(Symbol* signature) {
+  // TODO: Erik: remove after integration with concurrent stack scanning
+  oop r = *interpreter_callee_receiver_addr(signature);
+  r = NativeAccess<>::oop_load(&r);
+  return r;
+}
+
 void frame::oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache) {
   Thread *thread = Thread::current();
   methodHandle m (thread, interpreter_frame_method());
   jint bci = interpreter_frame_bci();
 
@@ -1097,10 +1104,12 @@
   if (oop_adr == NULL) {
     guarantee(oop_adr != NULL, "bad register save location");
     return NULL;
   }
   oop r = *oop_adr;
+  // TODO: Erik: remove after integration with concurrent stack scanning
+  r = NativeAccess<>::oop_load(&r);
   assert(Universe::heap()->is_in_or_null(r), "bad receiver: " INTPTR_FORMAT " (" INTX_FORMAT ")", p2i(r), p2i(r));
   return r;
 }
 
 
@@ -1118,10 +1127,12 @@
   assert(_cb != NULL && _cb->is_nmethod() && nm->method()->is_native(),
          "Should not call this unless it's a native nmethod");
   int byte_offset = in_bytes(nm->native_receiver_sp_offset());
   assert(byte_offset >= 0, "should not see invalid offset");
   oop owner = ((oop*) sp())[byte_offset / wordSize];
+  // TODO: Erik: remove after integration with concurrent stack scanning
+  owner = NativeAccess<>::oop_load(&owner);
   assert( Universe::heap()->is_in(owner), "bad receiver" );
   return owner;
 }
 
 void frame::oops_entry_do(OopClosure* f, const RegisterMap* map) {

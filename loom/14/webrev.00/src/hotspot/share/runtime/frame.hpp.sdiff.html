<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/frame.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="frame.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/frame.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
269   // byte code pointer
270   address interpreter_frame_bcp() const;
271   void    interpreter_frame_set_bcp(address bcp);
272 
273   // method data pointer
274   address interpreter_frame_mdp() const;
275   void    interpreter_frame_set_mdp(address dp);
276 
277   // Find receiver out of caller&#39;s (compiled) argument list
278   oop retrieve_receiver(RegisterMap *reg_map);
279 
280   // Return the monitor owner and BasicLock for compiled synchronized
281   // native methods so that biased locking can revoke the receiver&#39;s
282   // bias if necessary.  This is also used by JVMTI&#39;s GetLocalInstance method
283   // (via VM_GetReceiver) to retrieve the receiver from a native wrapper frame.
284   BasicLock* get_native_monitor();
285   oop        get_native_receiver();
286 
287   // Find receiver for an invoke when arguments are just pushed on stack (i.e., callee stack-frame is
288   // not setup)
<span class="line-modified">289   oop interpreter_callee_receiver(Symbol* signature)     { return *interpreter_callee_receiver_addr(signature); }</span>
290 
291 
292   oop* interpreter_callee_receiver_addr(Symbol* signature);
293 
294 
295   // expression stack (may go up or down, direction == 1 or -1)
296  public:
297   intptr_t* interpreter_frame_expression_stack() const;
298 
299   // The _at version returns a pointer because the address is used for GC.
300   intptr_t* interpreter_frame_expression_stack_at(jint offset) const;
301 
302   // top of expression stack
303   intptr_t* interpreter_frame_tos_at(jint offset) const;
304   intptr_t* interpreter_frame_tos_address() const;
305 
306 
307   jint  interpreter_frame_expression_stack_size() const;
308 
309   intptr_t* interpreter_frame_sender_sp() const;
</pre>
</td>
<td>
<hr />
<pre>
269   // byte code pointer
270   address interpreter_frame_bcp() const;
271   void    interpreter_frame_set_bcp(address bcp);
272 
273   // method data pointer
274   address interpreter_frame_mdp() const;
275   void    interpreter_frame_set_mdp(address dp);
276 
277   // Find receiver out of caller&#39;s (compiled) argument list
278   oop retrieve_receiver(RegisterMap *reg_map);
279 
280   // Return the monitor owner and BasicLock for compiled synchronized
281   // native methods so that biased locking can revoke the receiver&#39;s
282   // bias if necessary.  This is also used by JVMTI&#39;s GetLocalInstance method
283   // (via VM_GetReceiver) to retrieve the receiver from a native wrapper frame.
284   BasicLock* get_native_monitor();
285   oop        get_native_receiver();
286 
287   // Find receiver for an invoke when arguments are just pushed on stack (i.e., callee stack-frame is
288   // not setup)
<span class="line-modified">289   oop interpreter_callee_receiver(Symbol* signature);</span>
290 
291 
292   oop* interpreter_callee_receiver_addr(Symbol* signature);
293 
294 
295   // expression stack (may go up or down, direction == 1 or -1)
296  public:
297   intptr_t* interpreter_frame_expression_stack() const;
298 
299   // The _at version returns a pointer because the address is used for GC.
300   intptr_t* interpreter_frame_expression_stack_at(jint offset) const;
301 
302   // top of expression stack
303   intptr_t* interpreter_frame_tos_at(jint offset) const;
304   intptr_t* interpreter_frame_tos_address() const;
305 
306 
307   jint  interpreter_frame_expression_stack_size() const;
308 
309   intptr_t* interpreter_frame_sender_sp() const;
</pre>
</td>
</tr>
</table>
<center><a href="frame.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
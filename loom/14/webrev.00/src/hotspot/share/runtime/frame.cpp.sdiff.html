<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/frame.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="continuation.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="frame.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/frame.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 872     _f = NULL; // will be set later
 873     _fr = frame;
 874     _is_static = is_static;
 875     _offset = ArgumentSizeComputer(signature).size();  // pre-decremented down to zero
 876   }
 877 
 878   void arguments_do(OopClosure* f) {
 879     _f = f;
 880     if (!_is_static)  oop_at_offset_do(_offset); // do the receiver
 881     do_parameters_on(this);
 882   }
 883 
 884 };
 885 
 886 oop* frame::interpreter_callee_receiver_addr(Symbol* signature) {
 887   ArgumentSizeComputer asc(signature);
 888   int size = asc.size();
 889   return (oop *)interpreter_frame_tos_at(size);
 890 }
 891 







 892 void frame::oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache) {
 893   Thread *thread = Thread::current();
 894   methodHandle m (thread, interpreter_frame_method());
 895   jint bci = interpreter_frame_bci();
 896 
 897   InterpreterOopMap mask;
 898   if (query_oop_map_cache) {
 899     m-&gt;mask_for(bci, &amp;mask);
 900   } else {
 901     OopMapCache::compute_one_oop_map(m, bci, &amp;mask);
 902   }
 903   
 904   oops_interpreted_do0(f, map, m, bci, mask);
 905 }
 906 
 907 void frame::oops_interpreted_do(OopClosure* f, const RegisterMap* map, const InterpreterOopMap&amp; mask) {
 908   Thread *thread = Thread::current();
 909   methodHandle m (thread, interpreter_frame_method());
 910   jint bci = interpreter_frame_bci();
 911   oops_interpreted_do0(f, map, m, bci, mask);
</pre>
<hr />
<pre>
1082   finder.oops_do();
1083 }
1084 
1085 // Get receiver out of callers frame, i.e. find parameter 0 in callers
1086 // frame.  Consult ADLC for where parameter 0 is to be found.  Then
1087 // check local reg_map for it being a callee-save register or argument
1088 // register, both of which are saved in the local frame.  If not found
1089 // there, it must be an in-stack argument of the caller.
1090 // Note: caller.sp() points to callee-arguments
1091 oop frame::retrieve_receiver(RegisterMap* reg_map) {
1092   frame caller = *this;
1093 
1094   // First consult the ADLC on where it puts parameter 0 for this signature.
1095   VMReg reg = SharedRuntime::name_for_receiver();
1096   oop* oop_adr = caller.oopmapreg_to_location(reg, reg_map);
1097   if (oop_adr == NULL) {
1098     guarantee(oop_adr != NULL, &quot;bad register save location&quot;);
1099     return NULL;
1100   }
1101   oop r = *oop_adr;


1102   assert(Universe::heap()-&gt;is_in_or_null(r), &quot;bad receiver: &quot; INTPTR_FORMAT &quot; (&quot; INTX_FORMAT &quot;)&quot;, p2i(r), p2i(r));
1103   return r;
1104 }
1105 
1106 
1107 BasicLock* frame::get_native_monitor() {
1108   nmethod* nm = (nmethod*)_cb;
1109   assert(_cb != NULL &amp;&amp; _cb-&gt;is_nmethod() &amp;&amp; nm-&gt;method()-&gt;is_native(),
1110          &quot;Should not call this unless it&#39;s a native nmethod&quot;);
1111   int byte_offset = in_bytes(nm-&gt;native_basic_lock_sp_offset());
1112   assert(byte_offset &gt;= 0, &quot;should not see invalid offset&quot;);
1113   return (BasicLock*) &amp;sp()[byte_offset / wordSize];
1114 }
1115 
1116 oop frame::get_native_receiver() {
1117   nmethod* nm = (nmethod*)_cb;
1118   assert(_cb != NULL &amp;&amp; _cb-&gt;is_nmethod() &amp;&amp; nm-&gt;method()-&gt;is_native(),
1119          &quot;Should not call this unless it&#39;s a native nmethod&quot;);
1120   int byte_offset = in_bytes(nm-&gt;native_receiver_sp_offset());
1121   assert(byte_offset &gt;= 0, &quot;should not see invalid offset&quot;);
1122   oop owner = ((oop*) sp())[byte_offset / wordSize];


1123   assert( Universe::heap()-&gt;is_in(owner), &quot;bad receiver&quot; );
1124   return owner;
1125 }
1126 
1127 void frame::oops_entry_do(OopClosure* f, const RegisterMap* map) {
1128   assert(map != NULL, &quot;map must be set&quot;);
1129   if (map-&gt;include_argument_oops()) {
1130     // must collect argument oops, as nobody else is doing it
1131     Thread *thread = Thread::current();
1132     methodHandle m (thread, entry_frame_call_wrapper()-&gt;callee_method());
1133     EntryFrameOopFinder finder(this, m-&gt;signature(), m-&gt;is_static());
1134     finder.arguments_do(f);
1135   }
1136   // Traverse the Handle Block saved in the entry frame
1137   entry_frame_call_wrapper()-&gt;oops_do(f);
1138 }
1139 
1140 
1141 void frame::oops_do_internal(OopClosure* f, CodeBlobClosure* cf, DerivedOopClosure* df, const RegisterMap* map, bool use_interpreter_oop_map_cache) {
1142 #ifndef PRODUCT
</pre>
</td>
<td>
<hr />
<pre>
 872     _f = NULL; // will be set later
 873     _fr = frame;
 874     _is_static = is_static;
 875     _offset = ArgumentSizeComputer(signature).size();  // pre-decremented down to zero
 876   }
 877 
 878   void arguments_do(OopClosure* f) {
 879     _f = f;
 880     if (!_is_static)  oop_at_offset_do(_offset); // do the receiver
 881     do_parameters_on(this);
 882   }
 883 
 884 };
 885 
 886 oop* frame::interpreter_callee_receiver_addr(Symbol* signature) {
 887   ArgumentSizeComputer asc(signature);
 888   int size = asc.size();
 889   return (oop *)interpreter_frame_tos_at(size);
 890 }
 891 
<span class="line-added"> 892 oop frame::interpreter_callee_receiver(Symbol* signature) {</span>
<span class="line-added"> 893   // TODO: Erik: remove after integration with concurrent stack scanning</span>
<span class="line-added"> 894   oop r = *interpreter_callee_receiver_addr(signature);</span>
<span class="line-added"> 895   r = NativeAccess&lt;&gt;::oop_load(&amp;r);</span>
<span class="line-added"> 896   return r;</span>
<span class="line-added"> 897 }</span>
<span class="line-added"> 898 </span>
 899 void frame::oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache) {
 900   Thread *thread = Thread::current();
 901   methodHandle m (thread, interpreter_frame_method());
 902   jint bci = interpreter_frame_bci();
 903 
 904   InterpreterOopMap mask;
 905   if (query_oop_map_cache) {
 906     m-&gt;mask_for(bci, &amp;mask);
 907   } else {
 908     OopMapCache::compute_one_oop_map(m, bci, &amp;mask);
 909   }
 910   
 911   oops_interpreted_do0(f, map, m, bci, mask);
 912 }
 913 
 914 void frame::oops_interpreted_do(OopClosure* f, const RegisterMap* map, const InterpreterOopMap&amp; mask) {
 915   Thread *thread = Thread::current();
 916   methodHandle m (thread, interpreter_frame_method());
 917   jint bci = interpreter_frame_bci();
 918   oops_interpreted_do0(f, map, m, bci, mask);
</pre>
<hr />
<pre>
1089   finder.oops_do();
1090 }
1091 
1092 // Get receiver out of callers frame, i.e. find parameter 0 in callers
1093 // frame.  Consult ADLC for where parameter 0 is to be found.  Then
1094 // check local reg_map for it being a callee-save register or argument
1095 // register, both of which are saved in the local frame.  If not found
1096 // there, it must be an in-stack argument of the caller.
1097 // Note: caller.sp() points to callee-arguments
1098 oop frame::retrieve_receiver(RegisterMap* reg_map) {
1099   frame caller = *this;
1100 
1101   // First consult the ADLC on where it puts parameter 0 for this signature.
1102   VMReg reg = SharedRuntime::name_for_receiver();
1103   oop* oop_adr = caller.oopmapreg_to_location(reg, reg_map);
1104   if (oop_adr == NULL) {
1105     guarantee(oop_adr != NULL, &quot;bad register save location&quot;);
1106     return NULL;
1107   }
1108   oop r = *oop_adr;
<span class="line-added">1109   // TODO: Erik: remove after integration with concurrent stack scanning</span>
<span class="line-added">1110   r = NativeAccess&lt;&gt;::oop_load(&amp;r);</span>
1111   assert(Universe::heap()-&gt;is_in_or_null(r), &quot;bad receiver: &quot; INTPTR_FORMAT &quot; (&quot; INTX_FORMAT &quot;)&quot;, p2i(r), p2i(r));
1112   return r;
1113 }
1114 
1115 
1116 BasicLock* frame::get_native_monitor() {
1117   nmethod* nm = (nmethod*)_cb;
1118   assert(_cb != NULL &amp;&amp; _cb-&gt;is_nmethod() &amp;&amp; nm-&gt;method()-&gt;is_native(),
1119          &quot;Should not call this unless it&#39;s a native nmethod&quot;);
1120   int byte_offset = in_bytes(nm-&gt;native_basic_lock_sp_offset());
1121   assert(byte_offset &gt;= 0, &quot;should not see invalid offset&quot;);
1122   return (BasicLock*) &amp;sp()[byte_offset / wordSize];
1123 }
1124 
1125 oop frame::get_native_receiver() {
1126   nmethod* nm = (nmethod*)_cb;
1127   assert(_cb != NULL &amp;&amp; _cb-&gt;is_nmethod() &amp;&amp; nm-&gt;method()-&gt;is_native(),
1128          &quot;Should not call this unless it&#39;s a native nmethod&quot;);
1129   int byte_offset = in_bytes(nm-&gt;native_receiver_sp_offset());
1130   assert(byte_offset &gt;= 0, &quot;should not see invalid offset&quot;);
1131   oop owner = ((oop*) sp())[byte_offset / wordSize];
<span class="line-added">1132   // TODO: Erik: remove after integration with concurrent stack scanning</span>
<span class="line-added">1133   owner = NativeAccess&lt;&gt;::oop_load(&amp;owner);</span>
1134   assert( Universe::heap()-&gt;is_in(owner), &quot;bad receiver&quot; );
1135   return owner;
1136 }
1137 
1138 void frame::oops_entry_do(OopClosure* f, const RegisterMap* map) {
1139   assert(map != NULL, &quot;map must be set&quot;);
1140   if (map-&gt;include_argument_oops()) {
1141     // must collect argument oops, as nobody else is doing it
1142     Thread *thread = Thread::current();
1143     methodHandle m (thread, entry_frame_call_wrapper()-&gt;callee_method());
1144     EntryFrameOopFinder finder(this, m-&gt;signature(), m-&gt;is_static());
1145     finder.arguments_do(f);
1146   }
1147   // Traverse the Handle Block saved in the entry frame
1148   entry_frame_call_wrapper()-&gt;oops_do(f);
1149 }
1150 
1151 
1152 void frame::oops_do_internal(OopClosure* f, CodeBlobClosure* cf, DerivedOopClosure* df, const RegisterMap* map, bool use_interpreter_oop_map_cache) {
1153 #ifndef PRODUCT
</pre>
</td>
</tr>
</table>
<center><a href="continuation.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="frame.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
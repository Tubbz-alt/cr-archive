<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2331     _methods = new_methods();
2332     _bcis = new_bcis();
2333     _mirrors = new_mirrors();
2334     _names  = new_names();
2335     _conts  = new_conts();
2336     _index = 0;
2337   }
2338 
2339   oop backtrace() {
2340     return _backtrace();
2341   }
2342 
2343   inline void push(Method* method, int bci, oop contScopeName, TRAPS) {
2344     // Smear the -1 bci to 0 since the array only holds unsigned
2345     // shorts.  The later line number lookup would just smear the -1
2346     // to a 0 even if it could be recorded.
2347     if (bci == SynchronizationEntryBCI) bci = 0;
2348 
2349     if (_index &gt;= trace_chunk_size) {
2350       methodHandle mhandle(THREAD, method);

2351       expand(CHECK);
2352       method = mhandle();

2353     }
2354 
2355     _methods-&gt;ushort_at_put(_index, method-&gt;orig_method_idnum());
2356     _bcis-&gt;int_at_put(_index, Backtrace::merge_bci_and_version(bci, method-&gt;constants()-&gt;version()));
2357 
2358     // Note:this doesn&#39;t leak symbols because the mirror in the backtrace keeps the
2359     // klass owning the symbols alive so their refcounts aren&#39;t decremented.
2360     Symbol* name = method-&gt;name();
2361     _names-&gt;symbol_at_put(_index, name);
2362 
2363     // We need to save the mirrors in the backtrace to keep the class
2364     // from being unloaded while we still have this stack trace.
2365     assert(method-&gt;method_holder()-&gt;java_mirror() != NULL, &quot;never push null for mirror&quot;);
2366     _mirrors-&gt;obj_at_put(_index, method-&gt;method_holder()-&gt;java_mirror());
2367 
2368     _conts-&gt;obj_at_put(_index, contScopeName);
2369 
2370     _index++;
2371   }
2372 
</pre>
<hr />
<pre>
2579 
2580 /**
2581  * Print the throwable stack trace by calling the Java method java.lang.Throwable.printStackTrace().
2582  */
2583 void java_lang_Throwable::java_printStackTrace(Handle throwable, TRAPS) {
2584   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;Throwable instance expected&quot;);
2585   JavaValue result(T_VOID);
2586   JavaCalls::call_virtual(&amp;result,
2587                           throwable,
2588                           SystemDictionary::Throwable_klass(),
2589                           vmSymbols::printStackTrace_name(),
2590                           vmSymbols::void_method_signature(),
2591                           THREAD);
2592 }
2593 
2594 extern &quot;C&quot; void pfl();
2595 
2596 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, Handle contScope, const methodHandle&amp; method, TRAPS) {
2597   if (!StackTraceInThrowable) return;
2598   ResourceMark rm(THREAD);

2599 
2600   // Start out by clearing the backtrace for this object, in case the VM
2601   // runs out of memory while allocating the stack trace
2602   set_backtrace(throwable(), NULL);
2603   // Clear lazily constructed Java level stacktrace if refilling occurs
2604   // This is unnecessary in 1.7+ but harmless
2605   clear_stacktrace(throwable());
2606 
2607   int max_depth = MaxJavaStackTraceDepth;
2608   JavaThread* thread = (JavaThread*)THREAD;
2609 
2610   BacktraceBuilder bt(CHECK);
2611 
2612   // If there is no Java frame just return the method that was being called
2613   // with bci 0
2614   if (!thread-&gt;has_last_Java_frame()) {
2615     if (max_depth &gt;= 1 &amp;&amp; method() != NULL) {
2616       bt.push(method(), 0, NULL, CHECK);
2617       log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), 1);
2618       set_depth(throwable(), 1);
</pre>
<hr />
<pre>
2621     return;
2622   }
2623 
2624   // Instead of using vframe directly, this version of fill_in_stack_trace
2625   // basically handles everything by hand. This significantly improved the
2626   // speed of this method call up to 28.5% on Solaris sparc. 27.1% on Windows.
2627   // See bug 6333838 for  more details.
2628   // The &quot;ASSERT&quot; here is to verify this method generates the exactly same stack
2629   // trace as utilizing vframe.
2630 #ifdef ASSERT
2631   vframeStream st(thread, contScope);
2632 #endif
2633   int total_count = 0;
2634   RegisterMap map(thread, false, true);
2635   int decode_offset = 0;
2636   CompiledMethod* nm = NULL;
2637   bool skip_fillInStackTrace_check = false;
2638   bool skip_throwableInit_check = false;
2639   bool skip_hidden = !ShowHiddenFrames;
2640   bool is_last = false;
<span class="line-modified">2641   oop cont = thread-&gt;last_continuation();</span>
2642   for (frame fr = thread-&gt;last_frame(); max_depth == 0 || max_depth != total_count;) {
2643     Method* method = NULL;
2644     int bci = 0;
<span class="line-modified">2645     oop contScopeName = (cont != NULL) ? java_lang_ContinuationScope::name(java_lang_Continuation::scope(cont)) : (oop)NULL;</span>
2646 
2647     // Compiled java method case.
2648     if (decode_offset != 0) {
2649       DebugInfoReadStream stream(nm, decode_offset);
2650       decode_offset = stream.read_int();
2651       method = (Method*)nm-&gt;metadata_at(stream.read_int());
2652       bci = stream.read_bci();
2653     } else {
2654       if (fr.is_first_frame()) break;
2655 
<span class="line-modified">2656       assert (contScope.is_null() || cont != NULL, &quot;must be&quot;);</span>
<span class="line-modified">2657       if (cont != NULL &amp;&amp; Continuation::is_continuation_entry_frame(fr, &amp;map)) {</span>
<span class="line-modified">2658         oop scope = java_lang_Continuation::scope(cont);</span>
2659         if (contScope.not_null() &amp;&amp; (scope == contScope())) {
2660           is_last = true;
2661         } else {
2662           // if (!Continuation::is_frame_in_continuation(fr, cont)) {
2663           //   tty-&gt;print_cr(&quot;&gt;&gt;&gt;&gt;&gt;&quot;);
2664           //   fr.print_on(tty);
2665           //   tty-&gt;print_cr(&quot;&lt;&lt;&lt;&lt;&lt;&quot;);
2666           //   pfl();
2667           // }
<span class="line-modified">2668           assert (Continuation::is_frame_in_continuation(fr, cont), &quot;must be&quot;);</span>
<span class="line-modified">2669           cont = java_lang_Continuation::parent(cont);</span>

2670         }
2671       }
2672 
2673       address pc = fr.pc();
2674       if (fr.is_interpreted_frame()) {
2675         address bcp;
2676         if (!map.in_cont()) {
2677           bcp = fr.interpreter_frame_bcp();
2678           method = fr.interpreter_frame_method();
2679         } else {
2680           bcp = Continuation::interpreter_frame_bcp(fr, &amp;map);
2681           method = Continuation::interpreter_frame_method(fr, &amp;map);
2682         }
2683         bci =  method-&gt;bci_from(bcp);
2684         fr = fr.sender(&amp;map);
2685       } else {
2686         CodeBlob* cb = fr.cb();
2687         // HMMM QQQ might be nice to have frame return nm as NULL if cb is non-NULL
2688         // but non nmethod
2689         fr = fr.sender(&amp;map);
</pre>
<hr />
<pre>
3008   int version = method-&gt;constants()-&gt;version();
3009   InstanceKlass* holder = method-&gt;method_holder();
3010   Handle java_class(THREAD, holder-&gt;java_mirror());
3011   decode_file_and_line(java_class, holder, version, method, bci, filename, source_file, line_number, CHECK);
3012 }
3013 #endif // INCLUDE_JVMCI
3014 
3015 Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
3016   HandleMark hm(THREAD);
3017   Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
3018   Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
3019   // we should expand MemberName::name when Throwable uses StackTrace
3020   // MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);
3021   return method;
3022 }
3023 
3024 void java_lang_StackFrameInfo::set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, oop cont, TRAPS) {
3025   // set Method* or mid/cpref
3026   HandleMark hm(THREAD);
3027   Handle mname(Thread::current(), stackFrame-&gt;obj_field(_memberName_offset));

3028   InstanceKlass* ik = method-&gt;method_holder();
3029   CallInfo info(method(), ik, CHECK);
3030   MethodHandles::init_method_MemberName(mname, info);
3031   // set bci
3032   java_lang_StackFrameInfo::set_bci(stackFrame(), bci);
3033   // method may be redefined; store the version
3034   int version = method-&gt;constants()-&gt;version();
3035   assert((jushort)version == version, &quot;version should be short&quot;);
3036   java_lang_StackFrameInfo::set_version(stackFrame(), (short)version);
3037 
<span class="line-modified">3038   oop contScope = cont != NULL ? java_lang_Continuation::scope(cont) : (oop)NULL;</span>
3039   java_lang_StackFrameInfo::set_contScope(stackFrame(), contScope);
3040 }
3041 
3042 void java_lang_StackFrameInfo::to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS) {
3043   ResourceMark rm(THREAD);
3044   HandleMark hm(THREAD);
3045   Handle mname(THREAD, stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_memberName_offset));
3046   Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
3047   InstanceKlass* holder = InstanceKlass::cast(clazz);
3048   Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);
3049   oop contScope = stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_contScope_offset);
3050   Handle contScopeName(THREAD, contScope != (oop)NULL ? java_lang_ContinuationScope::name(contScope) : (oop)NULL);
3051 
3052   short version = stackFrame-&gt;short_field(_version_offset);
3053   int bci = stackFrame-&gt;int_field(_bci_offset);
3054   Symbol* name = method-&gt;name();
3055   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, methodHandle(THREAD, method), version, bci, name, contScopeName, CHECK);
3056 }
3057 
3058 #define STACKFRAMEINFO_FIELDS_DO(macro) \
</pre>
</td>
<td>
<hr />
<pre>
2331     _methods = new_methods();
2332     _bcis = new_bcis();
2333     _mirrors = new_mirrors();
2334     _names  = new_names();
2335     _conts  = new_conts();
2336     _index = 0;
2337   }
2338 
2339   oop backtrace() {
2340     return _backtrace();
2341   }
2342 
2343   inline void push(Method* method, int bci, oop contScopeName, TRAPS) {
2344     // Smear the -1 bci to 0 since the array only holds unsigned
2345     // shorts.  The later line number lookup would just smear the -1
2346     // to a 0 even if it could be recorded.
2347     if (bci == SynchronizationEntryBCI) bci = 0;
2348 
2349     if (_index &gt;= trace_chunk_size) {
2350       methodHandle mhandle(THREAD, method);
<span class="line-added">2351       Handle chandle(THREAD, contScopeName);</span>
2352       expand(CHECK);
2353       method = mhandle();
<span class="line-added">2354       contScopeName = chandle();</span>
2355     }
2356 
2357     _methods-&gt;ushort_at_put(_index, method-&gt;orig_method_idnum());
2358     _bcis-&gt;int_at_put(_index, Backtrace::merge_bci_and_version(bci, method-&gt;constants()-&gt;version()));
2359 
2360     // Note:this doesn&#39;t leak symbols because the mirror in the backtrace keeps the
2361     // klass owning the symbols alive so their refcounts aren&#39;t decremented.
2362     Symbol* name = method-&gt;name();
2363     _names-&gt;symbol_at_put(_index, name);
2364 
2365     // We need to save the mirrors in the backtrace to keep the class
2366     // from being unloaded while we still have this stack trace.
2367     assert(method-&gt;method_holder()-&gt;java_mirror() != NULL, &quot;never push null for mirror&quot;);
2368     _mirrors-&gt;obj_at_put(_index, method-&gt;method_holder()-&gt;java_mirror());
2369 
2370     _conts-&gt;obj_at_put(_index, contScopeName);
2371 
2372     _index++;
2373   }
2374 
</pre>
<hr />
<pre>
2581 
2582 /**
2583  * Print the throwable stack trace by calling the Java method java.lang.Throwable.printStackTrace().
2584  */
2585 void java_lang_Throwable::java_printStackTrace(Handle throwable, TRAPS) {
2586   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;Throwable instance expected&quot;);
2587   JavaValue result(T_VOID);
2588   JavaCalls::call_virtual(&amp;result,
2589                           throwable,
2590                           SystemDictionary::Throwable_klass(),
2591                           vmSymbols::printStackTrace_name(),
2592                           vmSymbols::void_method_signature(),
2593                           THREAD);
2594 }
2595 
2596 extern &quot;C&quot; void pfl();
2597 
2598 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, Handle contScope, const methodHandle&amp; method, TRAPS) {
2599   if (!StackTraceInThrowable) return;
2600   ResourceMark rm(THREAD);
<span class="line-added">2601   HandleMark hm(THREAD);</span>
2602 
2603   // Start out by clearing the backtrace for this object, in case the VM
2604   // runs out of memory while allocating the stack trace
2605   set_backtrace(throwable(), NULL);
2606   // Clear lazily constructed Java level stacktrace if refilling occurs
2607   // This is unnecessary in 1.7+ but harmless
2608   clear_stacktrace(throwable());
2609 
2610   int max_depth = MaxJavaStackTraceDepth;
2611   JavaThread* thread = (JavaThread*)THREAD;
2612 
2613   BacktraceBuilder bt(CHECK);
2614 
2615   // If there is no Java frame just return the method that was being called
2616   // with bci 0
2617   if (!thread-&gt;has_last_Java_frame()) {
2618     if (max_depth &gt;= 1 &amp;&amp; method() != NULL) {
2619       bt.push(method(), 0, NULL, CHECK);
2620       log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), 1);
2621       set_depth(throwable(), 1);
</pre>
<hr />
<pre>
2624     return;
2625   }
2626 
2627   // Instead of using vframe directly, this version of fill_in_stack_trace
2628   // basically handles everything by hand. This significantly improved the
2629   // speed of this method call up to 28.5% on Solaris sparc. 27.1% on Windows.
2630   // See bug 6333838 for  more details.
2631   // The &quot;ASSERT&quot; here is to verify this method generates the exactly same stack
2632   // trace as utilizing vframe.
2633 #ifdef ASSERT
2634   vframeStream st(thread, contScope);
2635 #endif
2636   int total_count = 0;
2637   RegisterMap map(thread, false, true);
2638   int decode_offset = 0;
2639   CompiledMethod* nm = NULL;
2640   bool skip_fillInStackTrace_check = false;
2641   bool skip_throwableInit_check = false;
2642   bool skip_hidden = !ShowHiddenFrames;
2643   bool is_last = false;
<span class="line-modified">2644   Handle cont_h(THREAD, thread-&gt;last_continuation());</span>
2645   for (frame fr = thread-&gt;last_frame(); max_depth == 0 || max_depth != total_count;) {
2646     Method* method = NULL;
2647     int bci = 0;
<span class="line-modified">2648     oop contScopeName = (cont_h() != NULL) ? java_lang_ContinuationScope::name(java_lang_Continuation::scope(cont_h())) : (oop)NULL;</span>
2649 
2650     // Compiled java method case.
2651     if (decode_offset != 0) {
2652       DebugInfoReadStream stream(nm, decode_offset);
2653       decode_offset = stream.read_int();
2654       method = (Method*)nm-&gt;metadata_at(stream.read_int());
2655       bci = stream.read_bci();
2656     } else {
2657       if (fr.is_first_frame()) break;
2658 
<span class="line-modified">2659       assert (contScope.is_null() || cont_h() != NULL, &quot;must be&quot;);</span>
<span class="line-modified">2660       if (cont_h() != NULL &amp;&amp; Continuation::is_continuation_entry_frame(fr, &amp;map)) {</span>
<span class="line-modified">2661         oop scope = java_lang_Continuation::scope(cont_h());</span>
2662         if (contScope.not_null() &amp;&amp; (scope == contScope())) {
2663           is_last = true;
2664         } else {
2665           // if (!Continuation::is_frame_in_continuation(fr, cont)) {
2666           //   tty-&gt;print_cr(&quot;&gt;&gt;&gt;&gt;&gt;&quot;);
2667           //   fr.print_on(tty);
2668           //   tty-&gt;print_cr(&quot;&lt;&lt;&lt;&lt;&lt;&quot;);
2669           //   pfl();
2670           // }
<span class="line-modified">2671           assert (Continuation::is_frame_in_continuation(fr, cont_h()), &quot;must be&quot;);</span>
<span class="line-modified">2672           Handle parent_h(THREAD, java_lang_Continuation::parent(cont_h()));</span>
<span class="line-added">2673           cont_h =  parent_h;</span>
2674         }
2675       }
2676 
2677       address pc = fr.pc();
2678       if (fr.is_interpreted_frame()) {
2679         address bcp;
2680         if (!map.in_cont()) {
2681           bcp = fr.interpreter_frame_bcp();
2682           method = fr.interpreter_frame_method();
2683         } else {
2684           bcp = Continuation::interpreter_frame_bcp(fr, &amp;map);
2685           method = Continuation::interpreter_frame_method(fr, &amp;map);
2686         }
2687         bci =  method-&gt;bci_from(bcp);
2688         fr = fr.sender(&amp;map);
2689       } else {
2690         CodeBlob* cb = fr.cb();
2691         // HMMM QQQ might be nice to have frame return nm as NULL if cb is non-NULL
2692         // but non nmethod
2693         fr = fr.sender(&amp;map);
</pre>
<hr />
<pre>
3012   int version = method-&gt;constants()-&gt;version();
3013   InstanceKlass* holder = method-&gt;method_holder();
3014   Handle java_class(THREAD, holder-&gt;java_mirror());
3015   decode_file_and_line(java_class, holder, version, method, bci, filename, source_file, line_number, CHECK);
3016 }
3017 #endif // INCLUDE_JVMCI
3018 
3019 Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
3020   HandleMark hm(THREAD);
3021   Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
3022   Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
3023   // we should expand MemberName::name when Throwable uses StackTrace
3024   // MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);
3025   return method;
3026 }
3027 
3028 void java_lang_StackFrameInfo::set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, oop cont, TRAPS) {
3029   // set Method* or mid/cpref
3030   HandleMark hm(THREAD);
3031   Handle mname(Thread::current(), stackFrame-&gt;obj_field(_memberName_offset));
<span class="line-added">3032   Handle cont_h (THREAD, cont);</span>
3033   InstanceKlass* ik = method-&gt;method_holder();
3034   CallInfo info(method(), ik, CHECK);
3035   MethodHandles::init_method_MemberName(mname, info);
3036   // set bci
3037   java_lang_StackFrameInfo::set_bci(stackFrame(), bci);
3038   // method may be redefined; store the version
3039   int version = method-&gt;constants()-&gt;version();
3040   assert((jushort)version == version, &quot;version should be short&quot;);
3041   java_lang_StackFrameInfo::set_version(stackFrame(), (short)version);
3042 
<span class="line-modified">3043   oop contScope = cont_h() != NULL ? java_lang_Continuation::scope(cont_h()) : (oop)NULL;</span>
3044   java_lang_StackFrameInfo::set_contScope(stackFrame(), contScope);
3045 }
3046 
3047 void java_lang_StackFrameInfo::to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS) {
3048   ResourceMark rm(THREAD);
3049   HandleMark hm(THREAD);
3050   Handle mname(THREAD, stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_memberName_offset));
3051   Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
3052   InstanceKlass* holder = InstanceKlass::cast(clazz);
3053   Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);
3054   oop contScope = stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_contScope_offset);
3055   Handle contScopeName(THREAD, contScope != (oop)NULL ? java_lang_ContinuationScope::name(contScope) : (oop)NULL);
3056 
3057   short version = stackFrame-&gt;short_field(_version_offset);
3058   int bci = stackFrame-&gt;int_field(_bci_offset);
3059   Symbol* name = method-&gt;name();
3060   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, methodHandle(THREAD, method), version, bci, name, contScopeName, CHECK);
3061 }
3062 
3063 #define STACKFRAMEINFO_FIELDS_DO(macro) \
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
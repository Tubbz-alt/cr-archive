<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/altHashing.hpp&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
  47 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  48 #include &quot;oops/klass.hpp&quot;
  49 #include &quot;oops/method.inline.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/symbol.hpp&quot;
  53 #include &quot;oops/recordComponent.hpp&quot;
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  55 #include &quot;prims/jvmtiExport.hpp&quot;
  56 #include &quot;prims/resolvedMethodTable.hpp&quot;
  57 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  58 #include &quot;runtime/frame.inline.hpp&quot;
  59 #include &quot;runtime/handles.inline.hpp&quot;
  60 #include &quot;runtime/init.hpp&quot;
  61 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  62 #include &quot;runtime/java.hpp&quot;
  63 #include &quot;runtime/javaCalls.hpp&quot;
  64 #include &quot;runtime/jniHandles.inline.hpp&quot;
  65 #include &quot;runtime/safepoint.hpp&quot;
  66 #include &quot;runtime/safepointVerifiers.hpp&quot;
  67 #include &quot;runtime/thread.inline.hpp&quot;
  68 #include &quot;runtime/vframe.inline.hpp&quot;
  69 #include &quot;runtime/vm_version.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/preserveException.hpp&quot;
  72 #include &quot;utilities/utf8.hpp&quot;
  73 #if INCLUDE_JVMCI
  74 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  75 #endif
  76 
  77 #define INJECTED_FIELD_COMPUTE_OFFSET(klass, name, signature, may_be_java)    \
  78   klass::_##name##_offset = JavaClasses::compute_injected_offset(JavaClasses::klass##_##name##_enum);
  79 
  80 #if INCLUDE_CDS
  81 #define INJECTED_FIELD_SERIALIZE_OFFSET(klass, name, signature, may_be_java) \
  82   f-&gt;do_u4((u4*)&amp;_##name##_offset);
  83 #endif
  84 
  85 #define DECLARE_INJECTED_FIELD(klass, name, signature, may_be_java)           \
  86   { SystemDictionary::WK_KLASS_ENUM_NAME(klass), vmSymbols::VM_SYMBOL_ENUM_NAME(name##_name), vmSymbols::VM_SYMBOL_ENUM_NAME(signature), may_be_java },
  87 
  88 InjectedField JavaClasses::_injected_fields[] = {
  89   ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD)
  90 };
  91 
  92 // Register native methods of Object
  93 void java_lang_Object::register_natives(TRAPS) {
  94   InstanceKlass* obj = SystemDictionary::Object_klass();
  95   Method::register_native(obj, vmSymbols::hashCode_name(),
  96                           vmSymbols::void_int_signature(), (address) &amp;JVM_IHashCode, CHECK);
  97   Method::register_native(obj, vmSymbols::wait_name(),
  98                           vmSymbols::long_void_signature(), (address) &amp;JVM_MonitorWait, CHECK);
  99   Method::register_native(obj, vmSymbols::notify_name(),
 100                           vmSymbols::void_method_signature(), (address) &amp;JVM_MonitorNotify, CHECK);
 101   Method::register_native(obj, vmSymbols::notifyAll_name(),
 102                           vmSymbols::void_method_signature(), (address) &amp;JVM_MonitorNotifyAll, CHECK);
 103   Method::register_native(obj, vmSymbols::clone_name(),
 104                           vmSymbols::void_object_signature(), (address) &amp;JVM_Clone, THREAD);
 105 }
 106 
 107 int JavaClasses::compute_injected_offset(InjectedFieldID id) {
 108   return _injected_fields[id].compute_offset();
 109 }
 110 
 111 InjectedField* JavaClasses::get_injected(Symbol* class_name, int* field_count) {
 112   *field_count = 0;
 113 
 114   vmSymbols::SID sid = vmSymbols::find_sid(class_name);
 115   if (sid == vmSymbols::NO_SID) {
 116     // Only well known classes can inject fields
 117     return NULL;
 118   }
 119 
 120   int count = 0;
 121   int start = -1;
 122 
 123 #define LOOKUP_INJECTED_FIELD(klass, name, signature, may_be_java) \
 124   if (sid == vmSymbols::VM_SYMBOL_ENUM_NAME(klass)) {              \
 125     count++;                                                       \
 126     if (start == -1) start = klass##_##name##_enum;                \
 127   }
 128   ALL_INJECTED_FIELDS(LOOKUP_INJECTED_FIELD);
 129 #undef LOOKUP_INJECTED_FIELD
 130 
 131   if (start != -1) {
 132     *field_count = count;
 133     return _injected_fields + start;
 134   }
 135   return NULL;
 136 }
 137 
 138 
 139 // Helpful routine for computing field offsets at run time rather than hardcoding them
 140 // Finds local fields only, including static fields.  Static field offsets are from the
 141 // beginning of the mirror.
 142 static void compute_offset(int &amp;dest_offset,
 143                            InstanceKlass* ik, Symbol* name_symbol, Symbol* signature_symbol,
 144                            bool is_static = false) {
 145   fieldDescriptor fd;
 146   if (ik == NULL) {
 147     ResourceMark rm;
 148     log_error(class)(&quot;Mismatch JDK version for field: %s type: %s&quot;, name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string());
 149     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;);
 150   }
 151 
 152   if (!ik-&gt;find_local_field(name_symbol, signature_symbol, &amp;fd) || fd.is_static() != is_static) {
 153     ResourceMark rm;
 154     log_error(class)(&quot;Invalid layout of %s field: %s type: %s&quot;, ik-&gt;external_name(),
 155                      name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string());
 156 #ifndef PRODUCT
 157     // Prints all fields and offsets
 158     Log(class) lt;
 159     LogStream ls(lt.error());
 160     ik-&gt;print_on(&amp;ls);
 161 #endif //PRODUCT
 162     vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
 163   }
 164   dest_offset = fd.offset();
 165 }
 166 
 167 // Overloading to pass name as a string.
 168 static void compute_offset(int&amp; dest_offset, InstanceKlass* ik,
 169                            const char* name_string, Symbol* signature_symbol,
 170                            bool is_static = false) {
 171   TempNewSymbol name = SymbolTable::probe(name_string, (int)strlen(name_string));
 172   if (name == NULL) {
 173     ResourceMark rm;
 174     log_error(class)(&quot;Name %s should be in the SymbolTable since its class is loaded&quot;, name_string);
 175     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;, ik-&gt;external_name());
 176   }
 177   compute_offset(dest_offset, ik, name, signature_symbol, is_static);
 178 }
 179 
 180 int java_lang_String::value_offset  = 0;
 181 int java_lang_String::hash_offset   = 0;
 182 int java_lang_String::hashIsZero_offset = 0;
 183 int java_lang_String::coder_offset  = 0;
 184 
 185 bool java_lang_String::initialized  = false;
 186 
 187 bool java_lang_String::is_instance(oop obj) {
 188   return is_instance_inlined(obj);
 189 }
 190 
 191 #if INCLUDE_CDS
 192 #define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \
 193   f-&gt;do_u4((u4*)&amp;offset)
 194 #endif
 195 
 196 #define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \
 197   compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
 198 
 199 #define STRING_FIELDS_DO(macro) \
 200   macro(value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \
 201   macro(hash_offset,  k, &quot;hash&quot;,                  int_signature,        false); \
 202   macro(hashIsZero_offset, k, &quot;hashIsZero&quot;,       bool_signature,       false); \
 203   macro(coder_offset, k, &quot;coder&quot;,                 byte_signature,       false);
 204 
 205 void java_lang_String::compute_offsets() {
 206   if (initialized) {
 207     return;
 208   }
 209 
 210   InstanceKlass* k = SystemDictionary::String_klass();
 211   STRING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 212 
 213   initialized = true;
 214 }
 215 
 216 #if INCLUDE_CDS
 217 void java_lang_String::serialize_offsets(SerializeClosure* f) {
 218   STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 219   f-&gt;do_bool(&amp;initialized);
 220 }
 221 #endif
 222 
 223 class CompactStringsFixup : public FieldClosure {
 224 private:
 225   bool _value;
 226 
 227 public:
 228   CompactStringsFixup(bool value) : _value(value) {}
 229 
 230   void do_field(fieldDescriptor* fd) {
 231     if (fd-&gt;name() == vmSymbols::compact_strings_name()) {
 232       oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
 233       assert(fd-&gt;field_holder() == SystemDictionary::String_klass(), &quot;Should be String&quot;);
 234       assert(mirror != NULL, &quot;String must have mirror already&quot;);
 235       mirror-&gt;bool_field_put(fd-&gt;offset(), _value);
 236     }
 237   }
 238 };
 239 
 240 void java_lang_String::set_compact_strings(bool value) {
 241   CompactStringsFixup fix(value);
 242   SystemDictionary::String_klass()-&gt;do_local_static_fields(&amp;fix);
 243 }
 244 
 245 Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
 246   assert(initialized, &quot;Must be initialized&quot;);
 247   assert(CompactStrings || !is_latin1, &quot;Must be UTF16 without CompactStrings&quot;);
 248 
 249   // Create the String object first, so there&#39;s a chance that the String
 250   // and the char array it points to end up in the same cache line.
 251   oop obj;
 252   obj = SystemDictionary::String_klass()-&gt;allocate_instance(CHECK_NH);
 253 
 254   // Create the char array.  The String object must be handlized here
 255   // because GC can happen as a result of the allocation attempt.
 256   Handle h_obj(THREAD, obj);
 257   int arr_length = is_latin1 ? length : length &lt;&lt; 1; // 2 bytes per UTF16.
 258   typeArrayOop buffer = oopFactory::new_byteArray(arr_length, CHECK_NH);;
 259 
 260   // Point the String at the char array
 261   obj = h_obj();
 262   set_value(obj, buffer);
 263   // No need to zero the offset, allocation zero&#39;ed the entire String object
 264   set_coder(obj, is_latin1 ? CODER_LATIN1 : CODER_UTF16);
 265   return h_obj;
 266 }
 267 
 268 Handle java_lang_String::create_from_unicode(const jchar* unicode, int length, TRAPS) {
 269   bool is_latin1 = CompactStrings &amp;&amp; UNICODE::is_latin1(unicode, length);
 270   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 271   typeArrayOop buffer = value(h_obj());
 272   assert(TypeArrayKlass::cast(buffer-&gt;klass())-&gt;element_type() == T_BYTE, &quot;only byte[]&quot;);
 273   if (is_latin1) {
 274     for (int index = 0; index &lt; length; index++) {
 275       buffer-&gt;byte_at_put(index, (jbyte)unicode[index]);
 276     }
 277   } else {
 278     for (int index = 0; index &lt; length; index++) {
 279       buffer-&gt;char_at_put(index, unicode[index]);
 280     }
 281   }
 282 
 283 #ifdef ASSERT
 284   {
 285     ResourceMark rm;
 286     char* expected = UNICODE::as_utf8(unicode, length);
 287     char* actual = as_utf8_string(h_obj());
 288     if (strcmp(expected, actual) != 0) {
 289       tty-&gt;print_cr(&quot;Unicode conversion failure: %s --&gt; %s&quot;, expected, actual);
 290       ShouldNotReachHere();
 291     }
 292   }
 293 #endif
 294 
 295   return h_obj;
 296 }
 297 
 298 oop java_lang_String::create_oop_from_unicode(const jchar* unicode, int length, TRAPS) {
 299   Handle h_obj = create_from_unicode(unicode, length, CHECK_NULL);
 300   return h_obj();
 301 }
 302 
 303 Handle java_lang_String::create_from_str(const char* utf8_str, TRAPS) {
 304   if (utf8_str == NULL) {
 305     return Handle();
 306   }
 307   bool has_multibyte, is_latin1;
 308   int length = UTF8::unicode_length(utf8_str, is_latin1, has_multibyte);
 309   if (!CompactStrings) {
 310     has_multibyte = true;
 311     is_latin1 = false;
 312   }
 313 
 314   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 315   if (length &gt; 0) {
 316     if (!has_multibyte) {
 317       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 318       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 319     } else if (is_latin1) {
 320       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 321     } else {
 322       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 323     }
 324   }
 325 
 326 #ifdef ASSERT
 327   // This check is too strict because the input string is not necessarily valid UTF8.
 328   // For example, it may be created with arbitrary content via jni_NewStringUTF.
 329   /*
 330   {
 331     ResourceMark rm;
 332     const char* expected = utf8_str;
 333     char* actual = as_utf8_string(h_obj());
 334     if (strcmp(expected, actual) != 0) {
 335       tty-&gt;print_cr(&quot;String conversion failure: %s --&gt; %s&quot;, expected, actual);
 336       ShouldNotReachHere();
 337     }
 338   }
 339   */
 340 #endif
 341 
 342   return h_obj;
 343 }
 344 
 345 oop java_lang_String::create_oop_from_str(const char* utf8_str, TRAPS) {
 346   Handle h_obj = create_from_str(utf8_str, CHECK_NULL);
 347   return h_obj();
 348 }
 349 
 350 Handle java_lang_String::create_from_symbol(Symbol* symbol, TRAPS) {
 351   const char* utf8_str = (char*)symbol-&gt;bytes();
 352   int utf8_len = symbol-&gt;utf8_length();
 353 
 354   bool has_multibyte, is_latin1;
 355   int length = UTF8::unicode_length(utf8_str, utf8_len, is_latin1, has_multibyte);
 356   if (!CompactStrings) {
 357     has_multibyte = true;
 358     is_latin1 = false;
 359   }
 360 
 361   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 362   if (length &gt; 0) {
 363     if (!has_multibyte) {
 364       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 365       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 366     } else if (is_latin1) {
 367       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 368     } else {
 369       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 370     }
 371   }
 372 
 373 #ifdef ASSERT
 374   {
 375     ResourceMark rm;
 376     const char* expected = symbol-&gt;as_utf8();
 377     char* actual = as_utf8_string(h_obj());
 378     if (strncmp(expected, actual, utf8_len) != 0) {
 379       tty-&gt;print_cr(&quot;Symbol conversion failure: %s --&gt; %s&quot;, expected, actual);
 380       ShouldNotReachHere();
 381     }
 382   }
 383 #endif
 384 
 385   return h_obj;
 386 }
 387 
 388 // Converts a C string to a Java String based on current encoding
 389 Handle java_lang_String::create_from_platform_dependent_str(const char* str, TRAPS) {
 390   assert(str != NULL, &quot;bad arguments&quot;);
 391 
 392   typedef jstring (JNICALL *to_java_string_fn_t)(JNIEnv*, const char *);
 393   static to_java_string_fn_t _to_java_string_fn = NULL;
 394 
 395   if (_to_java_string_fn == NULL) {
 396     void *lib_handle = os::native_java_library();
 397     _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;JNU_NewStringPlatform&quot;));
 398 #if defined(_WIN32) &amp;&amp; !defined(_WIN64)
 399     if (_to_java_string_fn == NULL) {
 400       // On 32 bit Windows, also try __stdcall decorated name
 401       _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;_JNU_NewStringPlatform@8&quot;));
 402     }
 403 #endif
 404     if (_to_java_string_fn == NULL) {
 405       fatal(&quot;JNU_NewStringPlatform missing&quot;);
 406     }
 407   }
 408 
 409   jstring js = NULL;
 410   {
 411     assert(THREAD-&gt;is_Java_thread(), &quot;must be java thread&quot;);
 412     JavaThread* thread = (JavaThread*)THREAD;
 413     HandleMark hm(thread);
 414     ThreadToNativeFromVM ttn(thread);
 415     js = (_to_java_string_fn)(thread-&gt;jni_environment(), str);
 416   }
 417 
 418   Handle native_platform_string(THREAD, JNIHandles::resolve(js));
 419   JNIHandles::destroy_local(js);  // destroy local JNIHandle.
 420   return native_platform_string;
 421 }
 422 
 423 // Converts a Java String to a native C string that can be used for
 424 // native OS calls.
 425 char* java_lang_String::as_platform_dependent_str(Handle java_string, TRAPS) {
 426   typedef char* (*to_platform_string_fn_t)(JNIEnv*, jstring, bool*);
 427   static to_platform_string_fn_t _to_platform_string_fn = NULL;
 428 
 429   if (_to_platform_string_fn == NULL) {
 430     void *lib_handle = os::native_java_library();
 431     _to_platform_string_fn = CAST_TO_FN_PTR(to_platform_string_fn_t, os::dll_lookup(lib_handle, &quot;GetStringPlatformChars&quot;));
 432     if (_to_platform_string_fn == NULL) {
 433       fatal(&quot;GetStringPlatformChars missing&quot;);
 434     }
 435   }
 436 
 437   char *native_platform_string;
 438   { JavaThread* thread = (JavaThread*)THREAD;
 439     assert(thread-&gt;is_Java_thread(), &quot;must be java thread&quot;);
 440     JNIEnv *env = thread-&gt;jni_environment();
 441     jstring js = (jstring) JNIHandles::make_local(env, java_string());
 442     bool is_copy;
 443     HandleMark hm(thread);
 444     ThreadToNativeFromVM ttn(thread);
 445     native_platform_string = (_to_platform_string_fn)(env, js, &amp;is_copy);
 446     assert(is_copy == JNI_TRUE, &quot;is_copy value changed&quot;);
 447     JNIHandles::destroy_local(js);
 448   }
 449   return native_platform_string;
 450 }
 451 
 452 Handle java_lang_String::char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS) {
 453   oop          obj    = java_string();
 454   // Typical usage is to convert all &#39;/&#39; to &#39;.&#39; in string.
 455   typeArrayOop value  = java_lang_String::value(obj);
 456   int          length = java_lang_String::length(obj, value);
 457   bool      is_latin1 = java_lang_String::is_latin1(obj);
 458 
 459   // First check if any from_char exist
 460   int index; // Declared outside, used later
 461   for (index = 0; index &lt; length; index++) {
 462     jchar c = !is_latin1 ? value-&gt;char_at(index) :
 463                   ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 464     if (c == from_char) {
 465       break;
 466     }
 467   }
 468   if (index == length) {
 469     // No from_char, so do not copy.
 470     return java_string;
 471   }
 472 
 473   // Check if result string will be latin1
 474   bool to_is_latin1 = false;
 475 
 476   // Replacement char must be latin1
 477   if (CompactStrings &amp;&amp; UNICODE::is_latin1(to_char)) {
 478     if (is_latin1) {
 479       // Source string is latin1 as well
 480       to_is_latin1 = true;
 481     } else if (!UNICODE::is_latin1(from_char)) {
 482       // We are replacing an UTF16 char. Scan string to
 483       // check if result can be latin1 encoded.
 484       to_is_latin1 = true;
 485       for (index = 0; index &lt; length; index++) {
 486         jchar c = value-&gt;char_at(index);
 487         if (c != from_char &amp;&amp; !UNICODE::is_latin1(c)) {
 488           to_is_latin1 = false;
 489           break;
 490         }
 491       }
 492     }
 493   }
 494 
 495   // Create new UNICODE (or byte) buffer. Must handlize value because GC
 496   // may happen during String and char array creation.
 497   typeArrayHandle h_value(THREAD, value);
 498   Handle string = basic_create(length, to_is_latin1, CHECK_NH);
 499   typeArrayOop from_buffer = h_value();
 500   typeArrayOop to_buffer = java_lang_String::value(string());
 501 
 502   // Copy contents
 503   for (index = 0; index &lt; length; index++) {
 504     jchar c = (!is_latin1) ? from_buffer-&gt;char_at(index) :
 505                     ((jchar) from_buffer-&gt;byte_at(index)) &amp; 0xff;
 506     if (c == from_char) {
 507       c = to_char;
 508     }
 509     if (!to_is_latin1) {
 510       to_buffer-&gt;char_at_put(index, c);
 511     } else {
 512       to_buffer-&gt;byte_at_put(index, (jbyte) c);
 513     }
 514   }
 515   return string;
 516 }
 517 
 518 jchar* java_lang_String::as_unicode_string(oop java_string, int&amp; length, TRAPS) {
 519   typeArrayOop value  = java_lang_String::value(java_string);
 520                length = java_lang_String::length(java_string, value);
 521   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 522 
 523   jchar* result = NEW_RESOURCE_ARRAY_RETURN_NULL(jchar, length);
 524   if (result != NULL) {
 525     if (!is_latin1) {
 526       for (int index = 0; index &lt; length; index++) {
 527         result[index] = value-&gt;char_at(index);
 528       }
 529     } else {
 530       for (int index = 0; index &lt; length; index++) {
 531         result[index] = ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 532       }
 533     }
 534   } else {
 535     THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), &quot;could not allocate Unicode string&quot;);
 536   }
 537   return result;
 538 }
 539 
 540 unsigned int java_lang_String::hash_code(oop java_string) {
 541   // The hash and hashIsZero fields are subject to a benign data race,
 542   // making it crucial to ensure that any observable result of the
 543   // calculation in this method stays correct under any possible read of
 544   // these fields. Necessary restrictions to allow this to be correct
 545   // without explicit memory fences or similar concurrency primitives is
 546   // that we can ever only write to one of these two fields for a given
 547   // String instance, and that the computation is idempotent and derived
 548   // from immutable state
 549   assert(initialized &amp;&amp; (hash_offset &gt; 0) &amp;&amp; (hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);
 550   if (java_lang_String::hash_is_set(java_string)) {
 551     return java_string-&gt;int_field(hash_offset);
 552   }
 553 
 554   typeArrayOop value = java_lang_String::value(java_string);
 555   int         length = java_lang_String::length(java_string, value);
 556   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 557 
 558   unsigned int hash = 0;
 559   if (length &gt; 0) {
 560     if (is_latin1) {
 561       hash = java_lang_String::hash_code(value-&gt;byte_at_addr(0), length);
 562     } else {
 563       hash = java_lang_String::hash_code(value-&gt;char_at_addr(0), length);
 564     }
 565   }
 566 
 567   if (hash != 0) {
 568     java_string-&gt;int_field_put(hash_offset, hash);
 569   } else {
 570     java_string-&gt;bool_field_put(hashIsZero_offset, true);
 571   }
 572   return hash;
 573 }
 574 
 575 char* java_lang_String::as_quoted_ascii(oop java_string) {
 576   typeArrayOop value  = java_lang_String::value(java_string);
 577   int          length = java_lang_String::length(java_string, value);
 578   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 579 
 580   if (length == 0) return NULL;
 581 
 582   char* result;
 583   int result_length;
 584   if (!is_latin1) {
 585     jchar* base = value-&gt;char_at_addr(0);
 586     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 587     result = NEW_RESOURCE_ARRAY(char, result_length);
 588     UNICODE::as_quoted_ascii(base, length, result, result_length);
 589   } else {
 590     jbyte* base = value-&gt;byte_at_addr(0);
 591     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 592     result = NEW_RESOURCE_ARRAY(char, result_length);
 593     UNICODE::as_quoted_ascii(base, length, result, result_length);
 594   }
 595   assert(result_length &gt;= length + 1, &quot;must not be shorter&quot;);
 596   assert(result_length == (int)strlen(result) + 1, &quot;must match&quot;);
 597   return result;
 598 }
 599 
 600 Symbol* java_lang_String::as_symbol(oop java_string) {
 601   typeArrayOop value  = java_lang_String::value(java_string);
 602   int          length = java_lang_String::length(java_string, value);
 603   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 604   if (!is_latin1) {
 605     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 606     Symbol* sym = SymbolTable::new_symbol(base, length);
 607     return sym;
 608   } else {
 609     ResourceMark rm;
 610     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 611     const char* base = UNICODE::as_utf8(position, length);
 612     Symbol* sym = SymbolTable::new_symbol(base, length);
 613     return sym;
 614   }
 615 }
 616 
 617 Symbol* java_lang_String::as_symbol_or_null(oop java_string) {
 618   typeArrayOop value  = java_lang_String::value(java_string);
 619   int          length = java_lang_String::length(java_string, value);
 620   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 621   if (!is_latin1) {
 622     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 623     return SymbolTable::probe_unicode(base, length);
 624   } else {
 625     ResourceMark rm;
 626     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 627     const char* base = UNICODE::as_utf8(position, length);
 628     return SymbolTable::probe(base, length);
 629   }
 630 }
 631 
 632 int java_lang_String::utf8_length(oop java_string, typeArrayOop value) {
 633   assert(value_equals(value, java_lang_String::value(java_string)),
 634          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 635   int length = java_lang_String::length(java_string, value);
 636   if (length == 0) {
 637     return 0;
 638   }
 639   if (!java_lang_String::is_latin1(java_string)) {
 640     return UNICODE::utf8_length(value-&gt;char_at_addr(0), length);
 641   } else {
 642     return UNICODE::utf8_length(value-&gt;byte_at_addr(0), length);
 643   }
 644 }
 645 
 646 int java_lang_String::utf8_length(oop java_string) {
 647   typeArrayOop value = java_lang_String::value(java_string);
 648   return utf8_length(java_string, value);
 649 }
 650 
 651 char* java_lang_String::as_utf8_string(oop java_string) {
 652   typeArrayOop value  = java_lang_String::value(java_string);
 653   int          length = java_lang_String::length(java_string, value);
 654   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 655   if (!is_latin1) {
 656     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 657     return UNICODE::as_utf8(position, length);
 658   } else {
 659     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 660     return UNICODE::as_utf8(position, length);
 661   }
 662 }
 663 
 664 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen) {
 665   assert(value_equals(value, java_lang_String::value(java_string)),
 666          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 667   int     length = java_lang_String::length(java_string, value);
 668   bool is_latin1 = java_lang_String::is_latin1(java_string);
 669   if (!is_latin1) {
 670     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 671     return UNICODE::as_utf8(position, length, buf, buflen);
 672   } else {
 673     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 674     return UNICODE::as_utf8(position, length, buf, buflen);
 675   }
 676 }
 677 
 678 char* java_lang_String::as_utf8_string(oop java_string, char* buf, int buflen) {
 679   typeArrayOop value = java_lang_String::value(java_string);
 680   return as_utf8_string(java_string, value, buf, buflen);
 681 }
 682 
 683 char* java_lang_String::as_utf8_string(oop java_string, int start, int len) {
 684   typeArrayOop value  = java_lang_String::value(java_string);
 685   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 686   assert(start + len &lt;= java_lang_String::length(java_string), &quot;just checking&quot;);
 687   if (!is_latin1) {
 688     jchar* position = value-&gt;char_at_addr(start);
 689     return UNICODE::as_utf8(position, len);
 690   } else {
 691     jbyte* position = value-&gt;byte_at_addr(start);
 692     return UNICODE::as_utf8(position, len);
 693   }
 694 }
 695 
 696 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen) {
 697   assert(value_equals(value, java_lang_String::value(java_string)),
 698          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 699   assert(start + len &lt;= java_lang_String::length(java_string), &quot;just checking&quot;);
 700   bool is_latin1 = java_lang_String::is_latin1(java_string);
 701   if (!is_latin1) {
 702     jchar* position = value-&gt;char_at_addr(start);
 703     return UNICODE::as_utf8(position, len, buf, buflen);
 704   } else {
 705     jbyte* position = value-&gt;byte_at_addr(start);
 706     return UNICODE::as_utf8(position, len, buf, buflen);
 707   }
 708 }
 709 
 710 bool java_lang_String::equals(oop java_string, const jchar* chars, int len) {
 711   assert(java_string-&gt;klass() == SystemDictionary::String_klass(),
 712          &quot;must be java_string&quot;);
 713   typeArrayOop value = java_lang_String::value_no_keepalive(java_string);
 714   int length = java_lang_String::length(java_string, value);
 715   if (length != len) {
 716     return false;
 717   }
 718   bool is_latin1 = java_lang_String::is_latin1(java_string);
 719   if (!is_latin1) {
 720     for (int i = 0; i &lt; len; i++) {
 721       if (value-&gt;char_at(i) != chars[i]) {
 722         return false;
 723       }
 724     }
 725   } else {
 726     for (int i = 0; i &lt; len; i++) {
 727       if ((((jchar) value-&gt;byte_at(i)) &amp; 0xff) != chars[i]) {
 728         return false;
 729       }
 730     }
 731   }
 732   return true;
 733 }
 734 
 735 bool java_lang_String::equals(oop str1, oop str2) {
 736   assert(str1-&gt;klass() == SystemDictionary::String_klass(),
 737          &quot;must be java String&quot;);
 738   assert(str2-&gt;klass() == SystemDictionary::String_klass(),
 739          &quot;must be java String&quot;);
 740   typeArrayOop value1    = java_lang_String::value_no_keepalive(str1);
 741   bool         is_latin1 = java_lang_String::is_latin1(str1);
 742   typeArrayOop value2    = java_lang_String::value_no_keepalive(str2);
 743   bool         is_latin2 = java_lang_String::is_latin1(str2);
 744 
 745   if (is_latin1 != is_latin2) {
 746     // Strings with different coders are never equal.
 747     return false;
 748   }
 749   return value_equals(value1, value2);
 750 }
 751 
 752 void java_lang_String::print(oop java_string, outputStream* st) {
 753   assert(java_string-&gt;klass() == SystemDictionary::String_klass(), &quot;must be java_string&quot;);
 754   typeArrayOop value  = java_lang_String::value_no_keepalive(java_string);
 755 
 756   if (value == NULL) {
 757     // This can happen if, e.g., printing a String
 758     // object before its initializer has been called
 759     st-&gt;print(&quot;NULL&quot;);
 760     return;
 761   }
 762 
 763   int length = java_lang_String::length(java_string, value);
 764   bool is_latin1 = java_lang_String::is_latin1(java_string);
 765 
 766   st-&gt;print(&quot;\&quot;&quot;);
 767   for (int index = 0; index &lt; length; index++) {
 768     st-&gt;print(&quot;%c&quot;, (!is_latin1) ?  value-&gt;char_at(index) :
 769                            ((jchar) value-&gt;byte_at(index)) &amp; 0xff );
 770   }
 771   st-&gt;print(&quot;\&quot;&quot;);
 772 }
 773 
 774 
 775 static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
 776   assert(mirror.not_null() &amp;&amp; fd-&gt;is_static(), &quot;just checking&quot;);
 777   if (fd-&gt;has_initial_value()) {
 778     BasicType t = fd-&gt;field_type();
 779     switch (t) {
 780       case T_BYTE:
 781         mirror()-&gt;byte_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 782               break;
 783       case T_BOOLEAN:
 784         mirror()-&gt;bool_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 785               break;
 786       case T_CHAR:
 787         mirror()-&gt;char_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 788               break;
 789       case T_SHORT:
 790         mirror()-&gt;short_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 791               break;
 792       case T_INT:
 793         mirror()-&gt;int_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 794         break;
 795       case T_FLOAT:
 796         mirror()-&gt;float_field_put(fd-&gt;offset(), fd-&gt;float_initial_value());
 797         break;
 798       case T_DOUBLE:
 799         mirror()-&gt;double_field_put(fd-&gt;offset(), fd-&gt;double_initial_value());
 800         break;
 801       case T_LONG:
 802         mirror()-&gt;long_field_put(fd-&gt;offset(), fd-&gt;long_initial_value());
 803         break;
 804       case T_OBJECT:
 805         {
 806           assert(fd-&gt;signature() == vmSymbols::string_signature(),
 807                  &quot;just checking&quot;);
 808           if (DumpSharedSpaces &amp;&amp; HeapShared::is_archived_object(mirror())) {
 809             // Archive the String field and update the pointer.
 810             oop s = mirror()-&gt;obj_field(fd-&gt;offset());
 811             oop archived_s = StringTable::create_archived_string(s, CHECK);
 812             mirror()-&gt;obj_field_put(fd-&gt;offset(), archived_s);
 813           } else {
 814             oop string = fd-&gt;string_initial_value(CHECK);
 815             mirror()-&gt;obj_field_put(fd-&gt;offset(), string);
 816           }
 817         }
 818         break;
 819       default:
 820         THROW_MSG(vmSymbols::java_lang_ClassFormatError(),
 821                   &quot;Illegal ConstantValue attribute in class file&quot;);
 822     }
 823   }
 824 }
 825 
 826 
 827 void java_lang_Class::fixup_mirror(Klass* k, TRAPS) {
 828   assert(InstanceMirrorKlass::offset_of_static_fields() != 0, &quot;must have been computed already&quot;);
 829 
 830   // If the offset was read from the shared archive, it was fixed up already
 831   if (!k-&gt;is_shared()) {
 832     if (k-&gt;is_instance_klass()) {
 833       // During bootstrap, java.lang.Class wasn&#39;t loaded so static field
 834       // offsets were computed without the size added it.  Go back and
 835       // update all the static field offsets to included the size.
 836       for (JavaFieldStream fs(InstanceKlass::cast(k)); !fs.done(); fs.next()) {
 837         if (fs.access_flags().is_static()) {
 838           int real_offset = fs.offset() + InstanceMirrorKlass::offset_of_static_fields();
 839           fs.set_offset(real_offset);
 840         }
 841       }
 842     }
 843   }
 844 
 845   if (k-&gt;is_shared() &amp;&amp; k-&gt;has_raw_archived_mirror()) {
 846     if (HeapShared::open_archive_heap_region_mapped()) {
 847       bool present = restore_archived_mirror(k, Handle(), Handle(), Handle(), CHECK);
 848       assert(present, &quot;Missing archived mirror for %s&quot;, k-&gt;external_name());
 849       return;
 850     } else {
 851       k-&gt;set_java_mirror_handle(NULL);
 852       k-&gt;clear_has_raw_archived_mirror();
 853     }
 854   }
 855   create_mirror(k, Handle(), Handle(), Handle(), CHECK);
 856 }
 857 
 858 void java_lang_Class::initialize_mirror_fields(Klass* k,
 859                                                Handle mirror,
 860                                                Handle protection_domain,
 861                                                TRAPS) {
 862   // Allocate a simple java object for a lock.
 863   // This needs to be a java object because during class initialization
 864   // it can be held across a java call.
 865   typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);
 866   set_init_lock(mirror(), r);
 867 
 868   // Set protection domain also
 869   set_protection_domain(mirror(), protection_domain());
 870 
 871   // Initialize static fields
 872   InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;initialize_static_field, mirror, CHECK);
 873 }
 874 
 875 // Set the java.lang.Module module field in the java_lang_Class mirror
 876 void java_lang_Class::set_mirror_module_field(Klass* k, Handle mirror, Handle module, TRAPS) {
 877   if (module.is_null()) {
 878     // During startup, the module may be NULL only if java.base has not been defined yet.
 879     // Put the class on the fixup_module_list to patch later when the java.lang.Module
 880     // for java.base is known. But note that since we captured the NULL module another
 881     // thread may have completed that initialization.
 882 
 883     bool javabase_was_defined = false;
 884     {
 885       MutexLocker m1(THREAD, Module_lock);
 886       // Keep list of classes needing java.base module fixup
 887       if (!ModuleEntryTable::javabase_defined()) {
 888         assert(k-&gt;java_mirror() != NULL, &quot;Class&#39;s mirror is null&quot;);
 889         k-&gt;class_loader_data()-&gt;inc_keep_alive();
 890         assert(fixup_module_field_list() != NULL, &quot;fixup_module_field_list not initialized&quot;);
 891         fixup_module_field_list()-&gt;push(k);
 892       } else {
 893         javabase_was_defined = true;
 894       }
 895     }
 896 
 897     // If java.base was already defined then patch this particular class with java.base.
 898     if (javabase_was_defined) {
 899       ModuleEntry *javabase_entry = ModuleEntryTable::javabase_moduleEntry();
 900       assert(javabase_entry != NULL &amp;&amp; javabase_entry-&gt;module() != NULL,
 901              &quot;Setting class module field, &quot; JAVA_BASE_NAME &quot; should be defined&quot;);
 902       Handle javabase_handle(THREAD, javabase_entry-&gt;module());
 903       set_module(mirror(), javabase_handle());
 904     }
 905   } else {
 906     assert(Universe::is_module_initialized() ||
 907            (ModuleEntryTable::javabase_defined() &amp;&amp;
 908             (module() == ModuleEntryTable::javabase_moduleEntry()-&gt;module())),
 909            &quot;Incorrect java.lang.Module specification while creating mirror&quot;);
 910     set_module(mirror(), module());
 911   }
 912 }
 913 
 914 // Statically allocate fixup lists because they always get created.
 915 void java_lang_Class::allocate_fixup_lists() {
 916   GrowableArray&lt;Klass*&gt;* mirror_list =
 917     new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Klass*&gt;(40, true);
 918   set_fixup_mirror_list(mirror_list);
 919 
 920   GrowableArray&lt;Klass*&gt;* module_list =
 921     new (ResourceObj::C_HEAP, mtModule) GrowableArray&lt;Klass*&gt;(500, true);
 922   set_fixup_module_field_list(module_list);
 923 }
 924 
 925 void java_lang_Class::create_mirror(Klass* k, Handle class_loader,
 926                                     Handle module, Handle protection_domain, TRAPS) {
 927   assert(k != NULL, &quot;Use create_basic_type_mirror for primitive types&quot;);
 928   assert(k-&gt;java_mirror() == NULL, &quot;should only assign mirror once&quot;);
 929 
 930   // Use this moment of initialization to cache modifier_flags also,
 931   // to support Class.getModifiers().  Instance classes recalculate
 932   // the cached flags after the class file is parsed, but before the
 933   // class is put into the system dictionary.
 934   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 935   k-&gt;set_modifier_flags(computed_modifiers);
 936   // Class_klass has to be loaded because it is used to allocate
 937   // the mirror.
 938   if (SystemDictionary::Class_klass_loaded()) {
 939     // Allocate mirror (java.lang.Class instance)
 940     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 941     Handle mirror(THREAD, mirror_oop);
 942     Handle comp_mirror;
 943 
 944     // Setup indirection from mirror-&gt;klass
 945     java_lang_Class::set_klass(mirror(), k);
 946 
 947     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
 948     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
 949 
 950     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
 951 
 952     // It might also have a component mirror.  This mirror must already exist.
 953     if (k-&gt;is_array_klass()) {
 954       if (k-&gt;is_typeArray_klass()) {
 955         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
 956         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
 957       } else {
 958         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
 959         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
 960         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
 961         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
 962       }
 963       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
 964 
 965       // Two-way link between the array klass and its component mirror:
 966       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
 967       set_component_mirror(mirror(), comp_mirror());
 968       // See below for ordering dependencies between field array_klass in component mirror
 969       // and java_mirror in this klass.
 970     } else {
 971       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
 972 
 973       initialize_mirror_fields(k, mirror, protection_domain, THREAD);
 974       if (HAS_PENDING_EXCEPTION) {
 975         // If any of the fields throws an exception like OOM remove the klass field
 976         // from the mirror so GC doesn&#39;t follow it after the klass has been deallocated.
 977         // This mirror looks like a primitive type, which logically it is because it
 978         // it represents no class.
 979         java_lang_Class::set_klass(mirror(), NULL);
 980         return;
 981       }
 982     }
 983 
 984     // set the classLoader field in the java_lang_Class instance
 985     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
 986     set_class_loader(mirror(), class_loader());
 987 
 988     // Setup indirection from klass-&gt;mirror
 989     // after any exceptions can happen during allocations.
 990     k-&gt;set_java_mirror(mirror);
 991 
 992     // Set the module field in the java_lang_Class instance.  This must be done
 993     // after the mirror is set.
 994     set_mirror_module_field(k, mirror, module, THREAD);
 995 
 996     if (comp_mirror() != NULL) {
 997       // Set after k-&gt;java_mirror() is published, because compiled code running
 998       // concurrently doesn&#39;t expect a k to have a null java_mirror.
 999       release_set_array_klass(comp_mirror(), k);
1000     }
1001   } else {
1002     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1003     fixup_mirror_list()-&gt;push(k);
1004   }
1005 }
1006 
1007 #if INCLUDE_CDS_JAVA_HEAP
1008 // Clears mirror fields. Static final fields with initial values are reloaded
1009 // from constant pool. The object identity hash is in the object header and is
1010 // not affected.
1011 class ResetMirrorField: public FieldClosure {
1012  private:
1013   Handle _m;
1014 
1015  public:
1016   ResetMirrorField(Handle mirror) : _m(mirror) {}
1017 
1018   void do_field(fieldDescriptor* fd) {
1019     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1020     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
1021 
1022     if (fd-&gt;is_static() &amp;&amp; fd-&gt;has_initial_value()) {
1023       initialize_static_field(fd, _m, Thread::current());
1024       return;
1025     }
1026 
1027     BasicType ft = fd-&gt;field_type();
1028     switch (ft) {
1029       case T_BYTE:
1030         _m()-&gt;byte_field_put(fd-&gt;offset(), 0);
1031         break;
1032       case T_CHAR:
1033         _m()-&gt;char_field_put(fd-&gt;offset(), 0);
1034         break;
1035       case T_DOUBLE:
1036         _m()-&gt;double_field_put(fd-&gt;offset(), 0);
1037         break;
1038       case T_FLOAT:
1039         _m()-&gt;float_field_put(fd-&gt;offset(), 0);
1040         break;
1041       case T_INT:
1042         _m()-&gt;int_field_put(fd-&gt;offset(), 0);
1043         break;
1044       case T_LONG:
1045         _m()-&gt;long_field_put(fd-&gt;offset(), 0);
1046         break;
1047       case T_SHORT:
1048         _m()-&gt;short_field_put(fd-&gt;offset(), 0);
1049         break;
1050       case T_BOOLEAN:
1051         _m()-&gt;bool_field_put(fd-&gt;offset(), false);
1052         break;
1053       case T_ARRAY:
1054       case T_OBJECT: {
1055         // It might be useful to cache the String field, but
1056         // for now just clear out any reference field
1057         oop o = _m()-&gt;obj_field(fd-&gt;offset());
1058         _m()-&gt;obj_field_put(fd-&gt;offset(), NULL);
1059         break;
1060       }
1061       default:
1062         ShouldNotReachHere();
1063         break;
1064      }
1065   }
1066 };
1067 
1068 void java_lang_Class::archive_basic_type_mirrors(TRAPS) {
1069   assert(HeapShared::is_heap_object_archiving_allowed(),
1070          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1071 
1072   for (int t = 0; t &lt;= T_VOID; t++) {
1073     oop m = Universe::_mirrors[t];
1074     if (m != NULL) {
1075       // Update the field at _array_klass_offset to point to the relocated array klass.
1076       oop archived_m = HeapShared::archive_heap_object(m, THREAD);
1077       assert(archived_m != NULL, &quot;sanity&quot;);
1078       Klass *ak = (Klass*)(archived_m-&gt;metadata_field(_array_klass_offset));
1079       assert(ak != NULL || t == T_VOID, &quot;should not be NULL&quot;);
1080       if (ak != NULL) {
1081         Klass *reloc_ak = MetaspaceShared::get_relocated_klass(ak, true);
1082         archived_m-&gt;metadata_field_put(_array_klass_offset, reloc_ak);
1083       }
1084 
1085       // Clear the fields. Just to be safe
1086       Klass *k = m-&gt;klass();
1087       Handle archived_mirror_h(THREAD, archived_m);
1088       ResetMirrorField reset(archived_mirror_h);
1089       InstanceKlass::cast(k)-&gt;do_nonstatic_fields(&amp;reset);
1090 
1091       log_trace(cds, heap, mirror)(
1092         &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1093         type2name((BasicType)t), p2i(Universe::_mirrors[t]), p2i(archived_m));
1094 
1095       Universe::_mirrors[t] = archived_m;
1096     }
1097   }
1098 
1099   assert(Universe::_mirrors[T_INT] != NULL &amp;&amp;
1100          Universe::_mirrors[T_FLOAT] != NULL &amp;&amp;
1101          Universe::_mirrors[T_DOUBLE] != NULL &amp;&amp;
1102          Universe::_mirrors[T_BYTE] != NULL &amp;&amp;
1103          Universe::_mirrors[T_BOOLEAN] != NULL &amp;&amp;
1104          Universe::_mirrors[T_CHAR] != NULL &amp;&amp;
1105          Universe::_mirrors[T_LONG] != NULL &amp;&amp;
1106          Universe::_mirrors[T_SHORT] != NULL &amp;&amp;
1107          Universe::_mirrors[T_VOID] != NULL, &quot;sanity&quot;);
1108 
1109   Universe::set_int_mirror(Universe::_mirrors[T_INT]);
1110   Universe::set_float_mirror(Universe::_mirrors[T_FLOAT]);
1111   Universe::set_double_mirror(Universe::_mirrors[T_DOUBLE]);
1112   Universe::set_byte_mirror(Universe::_mirrors[T_BYTE]);
1113   Universe::set_bool_mirror(Universe::_mirrors[T_BOOLEAN]);
1114   Universe::set_char_mirror(Universe::_mirrors[T_CHAR]);
1115   Universe::set_long_mirror(Universe::_mirrors[T_LONG]);
1116   Universe::set_short_mirror(Universe::_mirrors[T_SHORT]);
1117   Universe::set_void_mirror(Universe::_mirrors[T_VOID]);
1118 }
1119 
1120 //
1121 // After the mirror object is successfully archived, the archived
1122 // klass is set with _has_archived_raw_mirror flag.
1123 //
1124 // The _has_archived_raw_mirror flag is cleared at runtime when the
1125 // archived mirror is restored. If archived java heap data cannot
1126 // be used at runtime, new mirror object is created for the shared
1127 // class. The _has_archived_raw_mirror is cleared also during the process.
1128 oop java_lang_Class::archive_mirror(Klass* k, TRAPS) {
1129   assert(HeapShared::is_heap_object_archiving_allowed(),
1130          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1131 
1132   // Mirror is already archived
1133   if (k-&gt;has_raw_archived_mirror()) {
1134     assert(k-&gt;archived_java_mirror_raw() != NULL, &quot;no archived mirror&quot;);
1135     return k-&gt;archived_java_mirror_raw();
1136   }
1137 
1138   // No mirror
1139   oop mirror = k-&gt;java_mirror();
1140   if (mirror == NULL) {
1141     return NULL;
1142   }
1143 
1144   if (k-&gt;is_instance_klass()) {
1145     InstanceKlass *ik = InstanceKlass::cast(k);
1146     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1147 
1148     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1149           ik-&gt;is_shared_app_class())) {
1150       // Archiving mirror for classes from non-builtin loaders is not
1151       // supported. Clear the _java_mirror within the archived class.
1152       k-&gt;set_java_mirror_handle(NULL);
1153       return NULL;
1154     }
1155   }
1156 
1157   // Now start archiving the mirror object
1158   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1159   if (archived_mirror == NULL) {
1160     return NULL;
1161   }
1162 
1163   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1164   if (archived_mirror == NULL) {
1165     return NULL;
1166   }
1167 
1168   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1169 
1170   k-&gt;set_has_raw_archived_mirror();
1171 
1172   ResourceMark rm;
1173   log_trace(cds, heap, mirror)(
1174     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1175     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1176 
1177   return archived_mirror;
1178 }
1179 
1180 // The process is based on create_mirror().
1181 oop java_lang_Class::process_archived_mirror(Klass* k, oop mirror,
1182                                              oop archived_mirror,
1183                                              Thread *THREAD) {
1184   // Clear nonstatic fields in archived mirror. Some of the fields will be set
1185   // to archived metadata and objects below.
1186   Klass *c = archived_mirror-&gt;klass();
1187   Handle archived_mirror_h(THREAD, archived_mirror);
1188   ResetMirrorField reset(archived_mirror_h);
1189   InstanceKlass::cast(c)-&gt;do_nonstatic_fields(&amp;reset);
1190 
1191   if (k-&gt;is_array_klass()) {
1192     oop archived_comp_mirror;
1193     if (k-&gt;is_typeArray_klass()) {
1194       // The primitive type mirrors are already archived. Get the archived mirror.
1195       oop comp_mirror = java_lang_Class::component_mirror(mirror);
1196       archived_comp_mirror = HeapShared::find_archived_heap_object(comp_mirror);
1197       assert(archived_comp_mirror != NULL, &quot;Must be&quot;);
1198     } else {
1199       assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
1200       Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1201       assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1202       archived_comp_mirror = archive_mirror(element_klass, THREAD);
1203       if (archived_comp_mirror == NULL) {
1204         return NULL;
1205       }
1206     }
1207     java_lang_Class::set_component_mirror(archived_mirror, archived_comp_mirror);
1208   } else {
1209     assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1210 
1211     // Reset local static fields in the mirror
1212     InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;reset);
1213 
1214     java_lang_Class:set_init_lock(archived_mirror, NULL);
1215 
1216     set_protection_domain(archived_mirror, NULL);
1217   }
1218 
1219   // clear class loader and mirror_module_field
1220   set_class_loader(archived_mirror, NULL);
1221   set_module(archived_mirror, NULL);
1222 
1223   // The archived mirror&#39;s field at _klass_offset is still pointing to the original
1224   // klass. Updated the field in the archived mirror to point to the relocated
1225   // klass in the archive.
1226   Klass *reloc_k = MetaspaceShared::get_relocated_klass(as_Klass(mirror), true);
1227   log_debug(cds, heap, mirror)(
1228     &quot;Relocate mirror metadata field at _klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1229     p2i(as_Klass(mirror)), p2i(reloc_k));
1230   archived_mirror-&gt;metadata_field_put(_klass_offset, reloc_k);
1231 
1232   // The field at _array_klass_offset is pointing to the original one dimension
1233   // higher array klass if exists. Relocate the pointer.
1234   Klass *arr = array_klass_acquire(mirror);
1235   if (arr != NULL) {
1236     Klass *reloc_arr = MetaspaceShared::get_relocated_klass(arr, true);
1237     log_debug(cds, heap, mirror)(
1238       &quot;Relocate mirror metadata field at _array_klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1239       p2i(arr), p2i(reloc_arr));
1240     archived_mirror-&gt;metadata_field_put(_array_klass_offset, reloc_arr);
1241   }
1242   return archived_mirror;
1243 }
1244 
1245 void java_lang_Class::update_archived_primitive_mirror_native_pointers(oop archived_mirror) {
1246   if (MetaspaceShared::relocation_delta() != 0) {
1247     assert(archived_mirror-&gt;metadata_field(_klass_offset) == NULL, &quot;must be for primitive class&quot;);
1248 
1249     Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));
1250     if (ak != NULL) {
1251       archived_mirror-&gt;metadata_field_put(_array_klass_offset,
1252           (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));
1253     }
1254   }
1255 }
1256 
1257 void java_lang_Class::update_archived_mirror_native_pointers(oop archived_mirror) {
1258   if (MetaspaceShared::relocation_delta() != 0) {
1259     Klass* k = ((Klass*)archived_mirror-&gt;metadata_field(_klass_offset));
1260     archived_mirror-&gt;metadata_field_put(_klass_offset,
1261         (Klass*)(address(k) + MetaspaceShared::relocation_delta()));
1262 
1263     Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));
1264     if (ak != NULL) {
1265       archived_mirror-&gt;metadata_field_put(_array_klass_offset,
1266           (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));
1267     }
1268   }
1269 }
1270 
1271 
1272 // Returns true if the mirror is updated, false if no archived mirror
1273 // data is present. After the archived mirror object is restored, the
1274 // shared klass&#39; _has_raw_archived_mirror flag is cleared.
1275 bool java_lang_Class::restore_archived_mirror(Klass *k,
1276                                               Handle class_loader, Handle module,
1277                                               Handle protection_domain, TRAPS) {
1278   // Postpone restoring archived mirror until java.lang.Class is loaded. Please
1279   // see more details in SystemDictionary::resolve_well_known_classes().
1280   if (!SystemDictionary::Class_klass_loaded()) {
1281     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1282     fixup_mirror_list()-&gt;push(k);
1283     return true;
1284   }
1285 
1286   oop m = HeapShared::materialize_archived_object(k-&gt;archived_java_mirror_raw_narrow());
1287   if (m == NULL) {
1288     return false;
1289   }
1290 
1291   // mirror is archived, restore
1292   log_debug(cds, mirror)(&quot;Archived mirror is: &quot; PTR_FORMAT, p2i(m));
1293   assert(HeapShared::is_archived_object(m), &quot;must be archived mirror object&quot;);
1294   update_archived_mirror_native_pointers(m);
1295   assert(as_Klass(m) == k, &quot;must be&quot;);
1296   Handle mirror(THREAD, m);
1297 
1298   if (!k-&gt;is_array_klass()) {
1299     // - local static final fields with initial values were initialized at dump time
1300 
1301     // create the init_lock
1302     typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));
1303     set_init_lock(mirror(), r);
1304 
1305     if (protection_domain.not_null()) {
1306       set_protection_domain(mirror(), protection_domain());
1307     }
1308   }
1309 
1310   assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1311   if (class_loader.not_null()) {
1312     set_class_loader(mirror(), class_loader());
1313   }
1314 
1315   k-&gt;set_java_mirror(mirror);
1316   k-&gt;clear_has_raw_archived_mirror();
1317 
1318   set_mirror_module_field(k, mirror, module, THREAD);
1319 
1320   if (log_is_enabled(Trace, cds, heap, mirror)) {
1321     ResourceMark rm(THREAD);
1322     log_trace(cds, heap, mirror)(
1323         &quot;Restored %s archived mirror &quot; PTR_FORMAT, k-&gt;external_name(), p2i(mirror()));
1324   }
1325 
1326   return true;
1327 }
1328 #endif // INCLUDE_CDS_JAVA_HEAP
1329 
1330 void java_lang_Class::fixup_module_field(Klass* k, Handle module) {
1331   assert(_module_offset != 0, &quot;must have been computed already&quot;);
1332   java_lang_Class::set_module(k-&gt;java_mirror(), module());
1333 }
1334 
1335 int  java_lang_Class::oop_size(oop java_class) {
1336   assert(_oop_size_offset != 0, &quot;must be set&quot;);
1337   int size = java_class-&gt;int_field(_oop_size_offset);
1338   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
1339   return size;
1340 }
1341 
1342 
1343 void java_lang_Class::set_oop_size(HeapWord* java_class, int size) {
1344   assert(_oop_size_offset != 0, &quot;must be set&quot;);
1345   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
1346   *(int*)(((char*)java_class) + _oop_size_offset) = size;
1347 }
1348 
1349 int  java_lang_Class::static_oop_field_count(oop java_class) {
1350   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1351   return java_class-&gt;int_field(_static_oop_field_count_offset);
1352 }
1353 
1354 int  java_lang_Class::static_oop_field_count_raw(oop java_class) {
1355   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1356   return java_class-&gt;int_field_raw(_static_oop_field_count_offset);
1357 }
1358 
1359 void java_lang_Class::set_static_oop_field_count(oop java_class, int size) {
1360   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1361   java_class-&gt;int_field_put(_static_oop_field_count_offset, size);
1362 }
1363 
1364 oop java_lang_Class::protection_domain(oop java_class) {
1365   assert(_protection_domain_offset != 0, &quot;must be set&quot;);
1366   return java_class-&gt;obj_field(_protection_domain_offset);
1367 }
1368 void java_lang_Class::set_protection_domain(oop java_class, oop pd) {
1369   assert(_protection_domain_offset != 0, &quot;must be set&quot;);
1370   java_class-&gt;obj_field_put(_protection_domain_offset, pd);
1371 }
1372 
1373 void java_lang_Class::set_component_mirror(oop java_class, oop comp_mirror) {
1374   assert(_component_mirror_offset != 0, &quot;must be set&quot;);
1375     java_class-&gt;obj_field_put(_component_mirror_offset, comp_mirror);
1376   }
1377 oop java_lang_Class::component_mirror(oop java_class) {
1378   assert(_component_mirror_offset != 0, &quot;must be set&quot;);
1379   return java_class-&gt;obj_field(_component_mirror_offset);
1380 }
1381 
1382 oop java_lang_Class::init_lock(oop java_class) {
1383   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1384   return java_class-&gt;obj_field(_init_lock_offset);
1385 }
1386 void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {
1387   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1388   java_class-&gt;obj_field_put(_init_lock_offset, init_lock);
1389 }
1390 
1391 objArrayOop java_lang_Class::signers(oop java_class) {
1392   assert(_signers_offset != 0, &quot;must be set&quot;);
1393   return (objArrayOop)java_class-&gt;obj_field(_signers_offset);
1394 }
1395 void java_lang_Class::set_signers(oop java_class, objArrayOop signers) {
1396   assert(_signers_offset != 0, &quot;must be set&quot;);
1397   java_class-&gt;obj_field_put(_signers_offset, (oop)signers);
1398 }
1399 
1400 
1401 void java_lang_Class::set_class_loader(oop java_class, oop loader) {
1402   assert(_class_loader_offset != 0, &quot;offsets should have been initialized&quot;);
1403   java_class-&gt;obj_field_put(_class_loader_offset, loader);
1404 }
1405 
1406 oop java_lang_Class::class_loader(oop java_class) {
1407   assert(_class_loader_offset != 0, &quot;must be set&quot;);
1408   return java_class-&gt;obj_field(_class_loader_offset);
1409 }
1410 
1411 oop java_lang_Class::module(oop java_class) {
1412   assert(_module_offset != 0, &quot;must be set&quot;);
1413   return java_class-&gt;obj_field(_module_offset);
1414 }
1415 
1416 void java_lang_Class::set_module(oop java_class, oop module) {
1417   assert(_module_offset != 0, &quot;must be set&quot;);
1418   java_class-&gt;obj_field_put(_module_offset, module);
1419 }
1420 
1421 oop java_lang_Class::name(Handle java_class, TRAPS) {
1422   assert(_name_offset != 0, &quot;must be set&quot;);
1423   oop o = java_class-&gt;obj_field(_name_offset);
1424   if (o == NULL) {
1425     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1426     java_class-&gt;obj_field_put(_name_offset, o);
1427   }
1428   return o;
1429 }
1430 
1431 oop java_lang_Class::source_file(oop java_class) {
1432   assert(_source_file_offset != 0, &quot;must be set&quot;);
1433   return java_class-&gt;obj_field(_source_file_offset);
1434 }
1435 
1436 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1437   assert(_source_file_offset != 0, &quot;must be set&quot;);
1438   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1439 }
1440 
1441 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1442   // This should be improved by adding a field at the Java level or by
1443   // introducing a new VM klass (see comment in ClassFileParser)
1444   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1445   if (type != T_VOID) {
1446     Klass* aklass = Universe::typeArrayKlassObj(type);
1447     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1448     release_set_array_klass(java_class, aklass);
1449   }
1450 #ifdef ASSERT
1451   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1452   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1453 #endif
1454   return java_class;
1455 }
1456 
1457 
1458 Klass* java_lang_Class::as_Klass(oop java_class) {
1459   //%note memory_2
1460   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1461   Klass* k = ((Klass*)java_class-&gt;metadata_field(_klass_offset));
1462   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1463   return k;
1464 }
1465 
1466 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1467   //%note memory_2
1468   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1469   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1470   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1471   return k;
1472 }
1473 
1474 
1475 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1476   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1477   java_class-&gt;metadata_field_put(_klass_offset, klass);
1478 }
1479 
1480 
1481 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1482   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1483   Symbol* name = NULL;
1484   bool is_instance = false;
1485   if (is_primitive(java_class)) {
1486     name = vmSymbols::type_signature(primitive_type(java_class));
1487   } else {
1488     Klass* k = as_Klass(java_class);
1489     is_instance = k-&gt;is_instance_klass();
1490     name = k-&gt;name();
1491   }
1492   if (name == NULL) {
1493     st-&gt;print(&quot;&lt;null&gt;&quot;);
1494     return;
1495   }
1496   if (is_instance)  st-&gt;print(&quot;L&quot;);
1497   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1498   if (is_instance)  st-&gt;print(&quot;;&quot;);
1499 }
1500 
1501 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1502   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1503   Symbol* name;
1504   if (is_primitive(java_class)) {
1505     name = vmSymbols::type_signature(primitive_type(java_class));
1506     // Because this can create a new symbol, the caller has to decrement
1507     // the refcount, so make adjustment here and below for symbols returned
1508     // that are not created or incremented due to a successful lookup.
1509     name-&gt;increment_refcount();
1510   } else {
1511     Klass* k = as_Klass(java_class);
1512     if (!k-&gt;is_instance_klass()) {
1513       name = k-&gt;name();
1514       name-&gt;increment_refcount();
1515     } else {
1516       ResourceMark rm;
1517       const char* sigstr = k-&gt;signature_name();
1518       int         siglen = (int) strlen(sigstr);
1519       if (!intern_if_not_found) {
1520         name = SymbolTable::probe(sigstr, siglen);
1521       } else {
1522         name = SymbolTable::new_symbol(sigstr, siglen);
1523       }
1524     }
1525   }
1526   return name;
1527 }
1528 
1529 // Returns the Java name for this Java mirror (Resource allocated)
1530 // See Klass::external_name().
1531 // For primitive type Java mirrors, its type name is returned.
1532 const char* java_lang_Class::as_external_name(oop java_class) {
1533   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1534   const char* name = NULL;
1535   if (is_primitive(java_class)) {
1536     name = type2name(primitive_type(java_class));
1537   } else {
1538     name = as_Klass(java_class)-&gt;external_name();
1539   }
1540   if (name == NULL) {
1541     name = &quot;&lt;null&gt;&quot;;
1542   }
1543   return name;
1544 }
1545 
1546 Klass* java_lang_Class::array_klass_acquire(oop java_class) {
1547   Klass* k = ((Klass*)java_class-&gt;metadata_field_acquire(_array_klass_offset));
1548   assert(k == NULL || k-&gt;is_klass() &amp;&amp; k-&gt;is_array_klass(), &quot;should be array klass&quot;);
1549   return k;
1550 }
1551 
1552 
1553 void java_lang_Class::release_set_array_klass(oop java_class, Klass* klass) {
1554   assert(klass-&gt;is_klass() &amp;&amp; klass-&gt;is_array_klass(), &quot;should be array klass&quot;);
1555   java_class-&gt;release_metadata_field_put(_array_klass_offset, klass);
1556 }
1557 
1558 
1559 BasicType java_lang_Class::primitive_type(oop java_class) {
1560   assert(java_lang_Class::is_primitive(java_class), &quot;just checking&quot;);
1561   Klass* ak = ((Klass*)java_class-&gt;metadata_field(_array_klass_offset));
1562   BasicType type = T_VOID;
1563   if (ak != NULL) {
1564     // Note: create_basic_type_mirror above initializes ak to a non-null value.
1565     type = ArrayKlass::cast(ak)-&gt;element_type();
1566   } else {
1567     assert(java_class == Universe::void_mirror(), &quot;only valid non-array primitive&quot;);
1568   }
1569   assert(Universe::java_mirror(type) == java_class, &quot;must be consistent&quot;);
1570   return type;
1571 }
1572 
1573 BasicType java_lang_Class::as_BasicType(oop java_class, Klass** reference_klass) {
1574   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1575   if (is_primitive(java_class)) {
1576     if (reference_klass != NULL)
1577       (*reference_klass) = NULL;
1578     return primitive_type(java_class);
1579   } else {
1580     if (reference_klass != NULL)
1581       (*reference_klass) = as_Klass(java_class);
1582     return T_OBJECT;
1583   }
1584 }
1585 
1586 
1587 oop java_lang_Class::primitive_mirror(BasicType t) {
1588   oop mirror = Universe::java_mirror(t);
1589   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1590   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1591   return mirror;
1592 }
1593 
1594 bool java_lang_Class::offsets_computed = false;
1595 int  java_lang_Class::classRedefinedCount_offset = -1;
1596 
1597 #define CLASS_FIELDS_DO(macro) \
1598   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1599   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
1600   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
1601   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
1602   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \
1603 
1604 void java_lang_Class::compute_offsets() {
1605   if (offsets_computed) {
1606     return;
1607   }
1608 
1609   offsets_computed = true;
1610 
1611   InstanceKlass* k = SystemDictionary::Class_klass();
1612   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1613 
1614   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1615   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1616   // GC treats them the same.
1617   _init_lock_offset = _component_mirror_offset;
1618 
1619   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1620 }
1621 
1622 #if INCLUDE_CDS
1623 void java_lang_Class::serialize_offsets(SerializeClosure* f) {
1624   f-&gt;do_bool(&amp;offsets_computed);
1625   f-&gt;do_u4((u4*)&amp;_init_lock_offset);
1626 
1627   CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1628 
1629   CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
1630 }
1631 #endif
1632 
1633 int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
1634   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);
1635   return the_class_mirror-&gt;int_field(classRedefinedCount_offset);
1636 }
1637 
1638 void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
1639   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);
1640   the_class_mirror-&gt;int_field_put(classRedefinedCount_offset, value);
1641 }
1642 
1643 
1644 // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
1645 //       platform thread structure, and a eetop offset which was used for thread
1646 //       local storage (and unused by the HotSpot VM). In JDK1.2 the two structures
1647 //       merged, so in the HotSpot VM we just use the eetop field for the thread
1648 //       instead of the privateInfo_offset.
1649 //
1650 // Note: The stackSize field is only present starting in 1.4.
1651 
1652 int java_lang_Thread_FieldHolder::_group_offset = 0;
1653 int java_lang_Thread_FieldHolder::_priority_offset = 0;
1654 int java_lang_Thread_FieldHolder::_stackSize_offset = 0;
1655 int java_lang_Thread_FieldHolder::_stillborn_offset = 0;
1656 int java_lang_Thread_FieldHolder::_daemon_offset = 0;
1657 int java_lang_Thread_FieldHolder::_thread_status_offset = 0;
1658 
1659 #define THREAD_FIELD_HOLDER_FIELDS_DO(macro) \
1660   macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
1661   macro(_priority_offset,      k, vmSymbols::priority_name(), int_signature, false); \
1662   macro(_stackSize_offset,     k, &quot;stackSize&quot;, long_signature, false); \
1663   macro(_stillborn_offset,     k, &quot;stillborn&quot;, bool_signature, false); \
1664   macro(_daemon_offset,        k, vmSymbols::daemon_name(), bool_signature, false); \
1665   macro(_thread_status_offset, k, &quot;threadStatus&quot;, int_signature, false)
1666 
1667 void java_lang_Thread_FieldHolder::compute_offsets() {
1668   assert(_group_offset == 0, &quot;offsets should be initialized only once&quot;);
1669 
1670   InstanceKlass* k = SystemDictionary::Thread_FieldHolder_klass();
1671   THREAD_FIELD_HOLDER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1672 }
1673 
1674 #if INCLUDE_CDS
1675 void java_lang_Thread_FieldHolder::serialize_offsets(SerializeClosure* f) {
1676   THREAD_FIELD_HOLDER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1677 }
1678 #endif
1679 
1680 oop java_lang_Thread_FieldHolder::threadGroup(oop holder) {
1681   return holder-&gt;obj_field(_group_offset);
1682 }
1683 
1684 ThreadPriority java_lang_Thread_FieldHolder::priority(oop holder) {
1685   return (ThreadPriority)holder-&gt;int_field(_priority_offset);
1686 }
1687 
1688 void java_lang_Thread_FieldHolder::set_priority(oop holder, ThreadPriority priority) {
1689   holder-&gt;int_field_put(_priority_offset, priority);
1690 }
1691 
1692 jlong java_lang_Thread_FieldHolder::stackSize(oop holder) {
1693   return holder-&gt;long_field(_stackSize_offset);
1694 }
1695 
1696 bool java_lang_Thread_FieldHolder::is_stillborn(oop holder) {
1697   return holder-&gt;bool_field(_stillborn_offset) != 0;
1698 }
1699 
1700 void java_lang_Thread_FieldHolder::set_stillborn(oop holder) {
1701   holder-&gt;bool_field_put(_stillborn_offset, true);
1702 }
1703 
1704 bool java_lang_Thread_FieldHolder::is_daemon(oop holder) {
1705   return holder-&gt;bool_field(_daemon_offset) != 0;
1706 }
1707 
1708 void java_lang_Thread_FieldHolder::set_daemon(oop holder) {
1709   holder-&gt;bool_field_put(_daemon_offset, true);
1710 }
1711 
1712 void java_lang_Thread_FieldHolder::set_thread_status(oop holder, java_lang_Thread::ThreadStatus status) {
1713   holder-&gt;int_field_put(_thread_status_offset, status);
1714 }
1715 
1716 java_lang_Thread::ThreadStatus java_lang_Thread_FieldHolder::get_thread_status(oop holder) {
1717   return (java_lang_Thread::ThreadStatus)holder-&gt;int_field(_thread_status_offset);
1718 }
1719 
1720 
1721 int java_lang_Thread_VirtualThreads::_static_THREAD_GROUP_offset = 0;
1722 
1723 #define THREAD_VIRTUAL_THREADS_STATIC_FIELDS_DO(macro) \
1724   macro(_static_THREAD_GROUP_offset, k, &quot;THREAD_GROUP&quot;, threadgroup_signature, true);
1725 
1726 void java_lang_Thread_VirtualThreads::compute_offsets() {
1727   assert(_static_THREAD_GROUP_offset == 0, &quot;offsets should be initialized only once&quot;);
1728 
1729   InstanceKlass* k = SystemDictionary::Thread_VirtualThreads_klass();
1730   THREAD_VIRTUAL_THREADS_STATIC_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1731 }
1732 
1733 #if INCLUDE_CDS
1734 void java_lang_Thread_VirtualThreads::serialize_offsets(SerializeClosure* f) {
1735   THREAD_VIRTUAL_THREADS_STATIC_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1736 }
1737 #endif
1738 
1739 oop java_lang_Thread_VirtualThreads::get_THREAD_GROUP() {
1740   InstanceKlass* k = SystemDictionary::Thread_VirtualThreads_klass();
1741   oop base = k-&gt;static_field_base_raw();
1742   return base-&gt;obj_field(_static_THREAD_GROUP_offset);
1743 }
1744 
1745 
1746 int java_lang_Thread::_holder_offset = 0;
1747 int java_lang_Thread::_name_offset = 0;
1748 int java_lang_Thread::_contextClassLoader_offset = 0;
1749 int java_lang_Thread::_inheritedAccessControlContext_offset = 0;
1750 int java_lang_Thread::_eetop_offset = 0;
1751 int java_lang_Thread::_interrupted_offset = 0;
1752 int java_lang_Thread::_tid_offset = 0;
1753 int java_lang_Thread::_continuation_offset = 0;
1754 int java_lang_Thread::_vthread_offset = 0;
1755 int java_lang_Thread::_park_blocker_offset = 0;
1756 
1757 #define THREAD_FIELDS_DO(macro) \
1758   macro(_holder_offset,        k, &quot;holder&quot;, thread_fieldholder_signature, false); \
1759   macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
1760   macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
1761   macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \
1762   macro(_eetop_offset,         k, &quot;eetop&quot;, long_signature, false); \
1763   macro(_interrupted_offset,   k, &quot;interrupted&quot;, bool_signature, false); \
1764   macro(_tid_offset,           k, &quot;tid&quot;, long_signature, false); \
1765   macro(_park_blocker_offset,  k, &quot;parkBlocker&quot;, object_signature, false); \
1766   macro(_continuation_offset,  k, &quot;cont&quot;, continuation_signature, false); \
1767   macro(_vthread_offset,       k, &quot;vthread&quot;, vthread_signature, false)
1768 
1769 void java_lang_Thread::compute_offsets() {
1770   assert(_holder_offset == 0, &quot;offsets should be initialized only once&quot;);
1771 
1772   InstanceKlass* k = SystemDictionary::Thread_klass();
1773   THREAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1774 }
1775 
1776 #if INCLUDE_CDS
1777 void java_lang_Thread::serialize_offsets(SerializeClosure* f) {
1778   THREAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1779 }
1780 #endif
1781 
1782 JavaThread* java_lang_Thread::thread(oop java_thread) {
1783   return (JavaThread*)java_thread-&gt;address_field(_eetop_offset);
1784 }
1785 
1786 
1787 void java_lang_Thread::set_thread(oop java_thread, JavaThread* thread) {
1788   java_thread-&gt;address_field_put(_eetop_offset, (address)thread);
1789 }
1790 
1791 oop java_lang_Thread::holder(oop java_thread) {
1792     return java_thread-&gt;obj_field(_holder_offset);
1793 }
1794 
1795 bool java_lang_Thread::interrupted(oop java_thread) {
1796   // Make sure the caller can safely access oops.
1797   assert(Thread::current()-&gt;is_VM_thread() ||
1798          (JavaThread::current()-&gt;thread_state() != _thread_blocked &amp;&amp;
1799           JavaThread::current()-&gt;thread_state() != _thread_in_native),
1800          &quot;Unsafe access to oop&quot;);
1801   return java_thread-&gt;bool_field_volatile(_interrupted_offset);
1802 }
1803 
1804 void java_lang_Thread::set_interrupted(oop java_thread, bool val) {
1805   // Make sure the caller can safely access oops.
1806   assert(Thread::current()-&gt;is_VM_thread() ||
1807          (JavaThread::current()-&gt;thread_state() != _thread_blocked &amp;&amp;
1808           JavaThread::current()-&gt;thread_state() != _thread_in_native),
1809          &quot;Unsafe access to oop&quot;);
1810   java_thread-&gt;bool_field_put_volatile(_interrupted_offset, val);
1811 }
1812 
1813 
1814 oop java_lang_Thread::name(oop java_thread) {
1815   return java_thread-&gt;obj_field(_name_offset);
1816 }
1817 
1818 
1819 void java_lang_Thread::set_name(oop java_thread, oop name) {
1820   java_thread-&gt;obj_field_put(_name_offset, name);
1821 }
1822 
1823 
1824 ThreadPriority java_lang_Thread::priority(oop java_thread) {
1825   oop holder = java_lang_Thread::holder(java_thread);
1826   return java_lang_Thread_FieldHolder::priority(holder);
1827 }
1828 
1829 
1830 void java_lang_Thread::set_priority(oop java_thread, ThreadPriority priority) {
1831   oop holder = java_lang_Thread::holder(java_thread);
1832   java_lang_Thread_FieldHolder::set_priority(holder, priority);
1833 }
1834 
1835 
1836 oop java_lang_Thread::threadGroup(oop java_thread) {
1837   oop holder = java_lang_Thread::holder(java_thread);
1838   return java_lang_Thread_FieldHolder::threadGroup(holder);
1839 }
1840 
1841 
1842 bool java_lang_Thread::is_stillborn(oop java_thread) {
1843   oop holder = java_lang_Thread::holder(java_thread);
1844   return java_lang_Thread_FieldHolder::is_stillborn(holder);
1845 }
1846 
1847 
1848 // We never have reason to turn the stillborn bit off
1849 void java_lang_Thread::set_stillborn(oop java_thread) {
1850   oop holder = java_lang_Thread::holder(java_thread);
1851   java_lang_Thread_FieldHolder::set_stillborn(holder);
1852 }
1853 
1854 
1855 bool java_lang_Thread::is_alive(oop java_thread) {
1856   JavaThread* thr = java_lang_Thread::thread(java_thread);
1857   return (thr != NULL);
1858 }
1859 
1860 
1861 bool java_lang_Thread::is_daemon(oop java_thread) {
1862   oop holder = java_lang_Thread::holder(java_thread);
1863   return java_lang_Thread_FieldHolder::is_daemon(holder);
1864 }
1865 
1866 void java_lang_Thread::set_daemon(oop java_thread) {
1867   oop holder = java_lang_Thread::holder(java_thread);
1868   java_lang_Thread_FieldHolder::set_daemon(holder);
1869 }
1870 
1871 oop java_lang_Thread::context_class_loader(oop java_thread) {
1872   return java_thread-&gt;obj_field(_contextClassLoader_offset);
1873 }
1874 
1875 oop java_lang_Thread::inherited_access_control_context(oop java_thread) {
1876   return java_thread-&gt;obj_field(_inheritedAccessControlContext_offset);
1877 }
1878 
1879 
1880 jlong java_lang_Thread::stackSize(oop java_thread) {
1881   oop holder = java_lang_Thread::holder(java_thread);
1882   return java_lang_Thread_FieldHolder::stackSize(holder);
1883 }
1884 
1885 // Write the thread status value to threadStatus field in java.lang.Thread java class.
1886 void java_lang_Thread::set_thread_status(oop java_thread,
1887                                          java_lang_Thread::ThreadStatus status) {
1888   oop holder = java_lang_Thread::holder(java_thread);
1889   java_lang_Thread_FieldHolder::set_thread_status(holder, status);
1890 }
1891 
1892 // Read thread status value from threadStatus field in java.lang.Thread java class.
1893 java_lang_Thread::ThreadStatus java_lang_Thread::get_thread_status(oop java_thread) {
1894   // Make sure the caller is operating on behalf of the VM or is
1895   // running VM code (state == _thread_in_vm).
1896   assert(Threads_lock-&gt;owned_by_self() || Thread::current()-&gt;is_VM_thread() ||
1897          JavaThread::current()-&gt;thread_state() == _thread_in_vm,
1898          &quot;Java Thread is not running in vm&quot;);
1899   oop holder = java_lang_Thread::holder(java_thread);
1900   return java_lang_Thread_FieldHolder::get_thread_status(holder);
1901 }
1902 
1903 jlong java_lang_Thread::thread_id(oop java_thread) {
1904   // The 16 most significant bits can be used for tracing
1905   // so these bits are excluded using a mask.
1906   static const jlong tid_mask = (((jlong)1) &lt;&lt; 48) - 1;
1907   return java_thread-&gt;long_field(_tid_offset) &amp; tid_mask;
1908 }
1909 
1910 ByteSize java_lang_Thread::thread_id_offset() {
1911   return in_ByteSize(_tid_offset);
1912 }
1913 
1914 oop java_lang_Thread::continuation(oop java_thread) {
1915   return java_thread-&gt;obj_field(_continuation_offset);
1916 }
1917 
1918 void java_lang_Thread::set_continuation(oop java_thread, oop continuation) {
1919   tty-&gt;print_cr(&quot;&gt;&gt;&gt; java_lang_Thread::set_continuation %p&quot;, (oopDesc*)continuation);
1920   return java_thread-&gt;obj_field_put(_continuation_offset, continuation);
1921 }
1922 
1923 oop java_lang_Thread::vthread(oop java_thread) {
1924   return java_thread-&gt;obj_field(_vthread_offset);
1925 }
1926 
1927 oop java_lang_Thread::park_blocker(oop java_thread) {
1928   return java_thread-&gt;obj_field(_park_blocker_offset);
1929 }
1930 
1931 const char* java_lang_Thread::thread_status_name(oop java_thread) {
1932   oop holder = java_lang_Thread::holder(java_thread);
1933   ThreadStatus status = java_lang_Thread_FieldHolder::get_thread_status(holder);
1934   switch (status) {
1935     case NEW                      : return &quot;NEW&quot;;
1936     case RUNNABLE                 : return &quot;RUNNABLE&quot;;
1937     case SLEEPING                 : return &quot;TIMED_WAITING (sleeping)&quot;;
1938     case IN_OBJECT_WAIT           : return &quot;WAITING (on object monitor)&quot;;
1939     case IN_OBJECT_WAIT_TIMED     : return &quot;TIMED_WAITING (on object monitor)&quot;;
1940     case PARKED                   : return &quot;WAITING (parking)&quot;;
1941     case PARKED_TIMED             : return &quot;TIMED_WAITING (parking)&quot;;
1942     case BLOCKED_ON_MONITOR_ENTER : return &quot;BLOCKED (on object monitor)&quot;;
1943     case TERMINATED               : return &quot;TERMINATED&quot;;
1944     default                       : return &quot;UNKNOWN&quot;;
1945   };
1946 }
1947 int java_lang_ThreadGroup::_parent_offset = 0;
1948 int java_lang_ThreadGroup::_name_offset = 0;
1949 int java_lang_ThreadGroup::_threads_offset = 0;
1950 int java_lang_ThreadGroup::_groups_offset = 0;
1951 int java_lang_ThreadGroup::_maxPriority_offset = 0;
1952 int java_lang_ThreadGroup::_destroyed_offset = 0;
1953 int java_lang_ThreadGroup::_daemon_offset = 0;
1954 int java_lang_ThreadGroup::_nthreads_offset = 0;
1955 int java_lang_ThreadGroup::_ngroups_offset = 0;
1956 
1957 oop  java_lang_ThreadGroup::parent(oop java_thread_group) {
1958   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1959   return java_thread_group-&gt;obj_field(_parent_offset);
1960 }
1961 
1962 // (&quot;name as oop&quot; accessor is not necessary)
1963 
1964 const char* java_lang_ThreadGroup::name(oop java_thread_group) {
1965   oop name = java_thread_group-&gt;obj_field(_name_offset);
1966   // ThreadGroup.name can be null
1967   if (name != NULL) {
1968     return java_lang_String::as_utf8_string(name);
1969   }
1970   return NULL;
1971 }
1972 
1973 int java_lang_ThreadGroup::nthreads(oop java_thread_group) {
1974   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1975   return java_thread_group-&gt;int_field(_nthreads_offset);
1976 }
1977 
1978 objArrayOop java_lang_ThreadGroup::threads(oop java_thread_group) {
1979   oop threads = java_thread_group-&gt;obj_field(_threads_offset);
1980   assert(threads != NULL, &quot;threadgroups should have threads&quot;);
1981   assert(threads-&gt;is_objArray(), &quot;just checking&quot;); // Todo: Add better type checking code
1982   return objArrayOop(threads);
1983 }
1984 
1985 int java_lang_ThreadGroup::ngroups(oop java_thread_group) {
1986   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1987   return java_thread_group-&gt;int_field(_ngroups_offset);
1988 }
1989 
1990 objArrayOop java_lang_ThreadGroup::groups(oop java_thread_group) {
1991   oop groups = java_thread_group-&gt;obj_field(_groups_offset);
1992   assert(groups == NULL || groups-&gt;is_objArray(), &quot;just checking&quot;); // Todo: Add better type checking code
1993   return objArrayOop(groups);
1994 }
1995 
1996 ThreadPriority java_lang_ThreadGroup::maxPriority(oop java_thread_group) {
1997   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1998   return (ThreadPriority) java_thread_group-&gt;int_field(_maxPriority_offset);
1999 }
2000 
2001 bool java_lang_ThreadGroup::is_destroyed(oop java_thread_group) {
2002   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
2003   return java_thread_group-&gt;bool_field(_destroyed_offset) != 0;
2004 }
2005 
2006 bool java_lang_ThreadGroup::is_daemon(oop java_thread_group) {
2007   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
2008   return java_thread_group-&gt;bool_field(_daemon_offset) != 0;
2009 }
2010 
2011 #define THREADGROUP_FIELDS_DO(macro) \
2012   macro(_parent_offset,      k, vmSymbols::parent_name(),      threadgroup_signature,       false); \
2013   macro(_name_offset,        k, vmSymbols::name_name(),        string_signature,            false); \
2014   macro(_threads_offset,     k, vmSymbols::threads_name(),     thread_array_signature,      false); \
2015   macro(_groups_offset,      k, vmSymbols::groups_name(),      threadgroup_array_signature, false); \
2016   macro(_maxPriority_offset, k, vmSymbols::maxPriority_name(), int_signature,               false); \
2017   macro(_destroyed_offset,   k, vmSymbols::destroyed_name(),   bool_signature,              false); \
2018   macro(_daemon_offset,      k, vmSymbols::daemon_name(),      bool_signature,              false); \
2019   macro(_nthreads_offset,    k, vmSymbols::nthreads_name(),    int_signature,               false); \
2020   macro(_ngroups_offset,     k, vmSymbols::ngroups_name(),     int_signature,               false)
2021 
2022 void java_lang_ThreadGroup::compute_offsets() {
2023   assert(_parent_offset == 0, &quot;offsets should be initialized only once&quot;);
2024 
2025   InstanceKlass* k = SystemDictionary::ThreadGroup_klass();
2026   THREADGROUP_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2027 }
2028 
2029 #if INCLUDE_CDS
2030 void java_lang_ThreadGroup::serialize_offsets(SerializeClosure* f) {
2031   THREADGROUP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2032 }
2033 #endif
2034 
2035 
2036 // java_lang_VirtualThread
2037 int java_lang_VirtualThread::static_notify_jvmti_events_offset = 0;
2038 int java_lang_VirtualThread::_carrierThread_offset = 0;
2039 int java_lang_VirtualThread::_continuation_offset = 0;
2040 int java_lang_VirtualThread::_state_offset = 0;
2041 
2042 #define VTHREAD_FIELDS_DO(macro) \
2043   macro(static_notify_jvmti_events_offset,  k, &quot;notifyJvmtiEvents&quot;,  bool_signature, true); \
2044   macro(_carrierThread_offset,  k, &quot;carrierThread&quot;,  thread_signature, false); \
2045   macro(_continuation_offset,  k, &quot;cont&quot;,  continuation_signature, false); \
2046   macro(_state_offset,  k, &quot;state&quot;,  short_signature, false)
2047 
2048 static jboolean vthread_notify_jvmti_events = JNI_FALSE;
2049 
2050 void java_lang_VirtualThread::compute_offsets() {
2051   InstanceKlass* k = SystemDictionary::VirtualThread_klass();
2052   VTHREAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2053 }
2054 
2055 void java_lang_VirtualThread::init_static_notify_jvmti_events() {
2056   if (vthread_notify_jvmti_events) {
2057     InstanceKlass* ik = SystemDictionary::VirtualThread_klass();
2058     oop base = ik-&gt;static_field_base_raw();
2059     base-&gt;release_bool_field_put(static_notify_jvmti_events_offset, vthread_notify_jvmti_events);
2060   }
2061 }
2062 
2063 bool java_lang_VirtualThread::is_instance(oop obj) {
2064   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
2065 }
2066 
2067 oop java_lang_VirtualThread::carrier_thread(oop vthread) {
2068   oop thread = vthread-&gt;obj_field(_carrierThread_offset);
2069   return thread;
2070 }
2071 
2072 oop java_lang_VirtualThread::continuation(oop vthread) {
2073   oop cont = vthread-&gt;obj_field(_continuation_offset);
2074   return cont;
2075 }
2076 
2077 jshort java_lang_VirtualThread::state(oop vthread) {
2078   return vthread-&gt;short_field_acquire(_state_offset);
2079 }
2080 
2081 java_lang_Thread::ThreadStatus java_lang_VirtualThread::map_state_to_thread_status(jshort state) {
2082   java_lang_Thread::ThreadStatus status = java_lang_Thread::NEW;
2083   switch (state) {
2084     case NEW :
2085       status = java_lang_Thread::NEW;
2086       break;
2087     case STARTED :
2088     case RUNNABLE :
2089     case RUNNING :
2090     case PARKING :
2091       status = java_lang_Thread::RUNNABLE;
2092       break;
2093     case PARKED :
2094     case PINNED :
2095     case WALKINGSTACK :
2096       status = java_lang_Thread::PARKED;
2097       break;
2098     case TERMINATED :
2099       status = java_lang_Thread::TERMINATED;
2100       break;
2101     default:
2102       ShouldNotReachHere();
2103   }
2104   return status;
2105 }
2106 
2107 #if INCLUDE_CDS
2108 void java_lang_VirtualThread::serialize_offsets(SerializeClosure* f) {
2109    VTHREAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2110 }
2111 #endif
2112 
2113 void java_lang_VirtualThread::set_notify_jvmti_events(jboolean enable) {
2114   vthread_notify_jvmti_events = enable;
2115 }
2116 
2117 
2118 #define THROWABLE_FIELDS_DO(macro) \
2119   macro(backtrace_offset,     k, &quot;backtrace&quot;,     object_signature,                  false); \
2120   macro(detailMessage_offset, k, &quot;detailMessage&quot;, string_signature,                  false); \
2121   macro(stackTrace_offset,    k, &quot;stackTrace&quot;,    java_lang_StackTraceElement_array, false); \
2122   macro(depth_offset,         k, &quot;depth&quot;,         int_signature,                     false); \
2123   macro(static_unassigned_stacktrace_offset, k, &quot;UNASSIGNED_STACK&quot;, java_lang_StackTraceElement_array, true)
2124 
2125 void java_lang_Throwable::compute_offsets() {
2126   InstanceKlass* k = SystemDictionary::Throwable_klass();
2127   THROWABLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2128 }
2129 
2130 #if INCLUDE_CDS
2131 void java_lang_Throwable::serialize_offsets(SerializeClosure* f) {
2132   THROWABLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2133 }
2134 #endif
2135 
2136 oop java_lang_Throwable::unassigned_stacktrace() {
2137   InstanceKlass* ik = SystemDictionary::Throwable_klass();
2138   oop base = ik-&gt;static_field_base_raw();
2139   return base-&gt;obj_field(static_unassigned_stacktrace_offset);
2140 }
2141 
2142 oop java_lang_Throwable::backtrace(oop throwable) {
2143   return throwable-&gt;obj_field_acquire(backtrace_offset);
2144 }
2145 
2146 
2147 void java_lang_Throwable::set_backtrace(oop throwable, oop value) {
2148   throwable-&gt;release_obj_field_put(backtrace_offset, value);
2149 }
2150 
2151 int java_lang_Throwable::depth(oop throwable) {
2152   return throwable-&gt;int_field(depth_offset);
2153 }
2154 
2155 void java_lang_Throwable::set_depth(oop throwable, int value) {
2156   throwable-&gt;int_field_put(depth_offset, value);
2157 }
2158 
2159 oop java_lang_Throwable::message(oop throwable) {
2160   return throwable-&gt;obj_field(detailMessage_offset);
2161 }
2162 
2163 
2164 // Return Symbol for detailed_message or NULL
2165 Symbol* java_lang_Throwable::detail_message(oop throwable) {
2166   PRESERVE_EXCEPTION_MARK;  // Keep original exception
2167   oop detailed_message = java_lang_Throwable::message(throwable);
2168   if (detailed_message != NULL) {
2169     return java_lang_String::as_symbol(detailed_message);
2170   }
2171   return NULL;
2172 }
2173 
2174 void java_lang_Throwable::set_message(oop throwable, oop value) {
2175   throwable-&gt;obj_field_put(detailMessage_offset, value);
2176 }
2177 
2178 
2179 void java_lang_Throwable::set_stacktrace(oop throwable, oop st_element_array) {
2180   throwable-&gt;obj_field_put(stackTrace_offset, st_element_array);
2181 }
2182 
2183 void java_lang_Throwable::clear_stacktrace(oop throwable) {
2184   set_stacktrace(throwable, NULL);
2185 }
2186 
2187 
2188 void java_lang_Throwable::print(oop throwable, outputStream* st) {
2189   ResourceMark rm;
2190   Klass* k = throwable-&gt;klass();
2191   assert(k != NULL, &quot;just checking&quot;);
2192   st-&gt;print(&quot;%s&quot;, k-&gt;external_name());
2193   oop msg = message(throwable);
2194   if (msg != NULL) {
2195     st-&gt;print(&quot;: %s&quot;, java_lang_String::as_utf8_string(msg));
2196   }
2197 }
2198 
2199 // After this many redefines, the stack trace is unreliable.
2200 const int MAX_VERSION = USHRT_MAX;
2201 
2202 static inline bool version_matches(Method* method, int version) {
2203   assert(version &lt; MAX_VERSION, &quot;version is too big&quot;);
2204   return method != NULL &amp;&amp; (method-&gt;constants()-&gt;version() == version);
2205 }
2206 
2207 // This class provides a simple wrapper over the internal structure of
2208 // exception backtrace to insulate users of the backtrace from needing
2209 // to know what it looks like.
2210 // The code of this class is not GC safe. Allocations can only happen
2211 // in expand().
2212 class BacktraceBuilder: public StackObj {
2213  friend class BacktraceIterator;
2214  private:
2215   Handle          _backtrace;
2216   objArrayOop     _head;
2217   typeArrayOop    _methods;
2218   typeArrayOop    _bcis;
2219   objArrayOop     _mirrors;
2220   typeArrayOop    _names; // Needed to insulate method name against redefinition.
2221   objArrayOop     _conts;
2222   // True if the top frame of the backtrace is omitted because it shall be hidden.
2223   bool            _has_hidden_top_frame;
2224   int             _index;
2225   NoSafepointVerifier _nsv;
2226 
2227   enum {
2228     trace_methods_offset = java_lang_Throwable::trace_methods_offset,
2229     trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,
2230     trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,
2231     trace_names_offset   = java_lang_Throwable::trace_names_offset,
2232     trace_conts_offset   = java_lang_Throwable::trace_conts_offset,
2233     trace_next_offset    = java_lang_Throwable::trace_next_offset,
2234     trace_hidden_offset  = java_lang_Throwable::trace_hidden_offset,
2235     trace_size           = java_lang_Throwable::trace_size,
2236     trace_chunk_size     = java_lang_Throwable::trace_chunk_size
2237   };
2238 
2239   // get info out of chunks
2240   static typeArrayOop get_methods(objArrayHandle chunk) {
2241     typeArrayOop methods = typeArrayOop(chunk-&gt;obj_at(trace_methods_offset));
2242     assert(methods != NULL, &quot;method array should be initialized in backtrace&quot;);
2243     return methods;
2244   }
2245   static typeArrayOop get_bcis(objArrayHandle chunk) {
2246     typeArrayOop bcis = typeArrayOop(chunk-&gt;obj_at(trace_bcis_offset));
2247     assert(bcis != NULL, &quot;bci array should be initialized in backtrace&quot;);
2248     return bcis;
2249   }
2250   static objArrayOop get_mirrors(objArrayHandle chunk) {
2251     objArrayOop mirrors = objArrayOop(chunk-&gt;obj_at(trace_mirrors_offset));
2252     assert(mirrors != NULL, &quot;mirror array should be initialized in backtrace&quot;);
2253     return mirrors;
2254   }
2255   static typeArrayOop get_names(objArrayHandle chunk) {
2256     typeArrayOop names = typeArrayOop(chunk-&gt;obj_at(trace_names_offset));
2257     assert(names != NULL, &quot;names array should be initialized in backtrace&quot;);
2258     return names;
2259   }
2260   static objArrayOop get_conts(objArrayHandle chunk) {
2261     objArrayOop conts = objArrayOop(chunk-&gt;obj_at(trace_conts_offset));
2262     assert(conts != NULL, &quot;conts array should be initialized in backtrace&quot;);
2263     return conts;
2264   }
2265   static bool has_hidden_top_frame(objArrayHandle chunk) {
2266     oop hidden = chunk-&gt;obj_at(trace_hidden_offset);
2267     return hidden != NULL;
2268   }
2269 
2270  public:
2271 
2272   // constructor for new backtrace
2273   BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _conts(NULL), _has_hidden_top_frame(false) {
2274     expand(CHECK);
2275     _backtrace = Handle(THREAD, _head);
2276     _index = 0;
2277   }
2278 
2279   BacktraceBuilder(Thread* thread, objArrayHandle backtrace) {
2280     _methods = get_methods(backtrace);
2281     _bcis = get_bcis(backtrace);
2282     _mirrors = get_mirrors(backtrace);
2283     _names = get_names(backtrace);
2284     _conts = get_conts(backtrace);
2285     _has_hidden_top_frame = has_hidden_top_frame(backtrace);
2286     assert(_methods-&gt;length() == _bcis-&gt;length() &amp;&amp;
2287            _methods-&gt;length() == _mirrors-&gt;length() &amp;&amp;
2288            _mirrors-&gt;length() == _names-&gt;length() &amp;&amp;
2289            _names-&gt;length() == _conts-&gt;length(),
2290            &quot;method and source information arrays should match&quot;);
2291 
2292     // head is the preallocated backtrace
2293     _head = backtrace();
2294     _backtrace = Handle(thread, _head);
2295     _index = 0;
2296   }
2297 
2298   void expand(TRAPS) {
2299     objArrayHandle old_head(THREAD, _head);
2300     PauseNoSafepointVerifier pnsv(&amp;_nsv);
2301 
2302     objArrayOop head = oopFactory::new_objectArray(trace_size, CHECK);
2303     objArrayHandle new_head(THREAD, head);
2304 
2305     typeArrayOop methods = oopFactory::new_shortArray(trace_chunk_size, CHECK);
2306     typeArrayHandle new_methods(THREAD, methods);
2307 
2308     typeArrayOop bcis = oopFactory::new_intArray(trace_chunk_size, CHECK);
2309     typeArrayHandle new_bcis(THREAD, bcis);
2310 
2311     objArrayOop mirrors = oopFactory::new_objectArray(trace_chunk_size, CHECK);
2312     objArrayHandle new_mirrors(THREAD, mirrors);
2313 
2314     typeArrayOop names = oopFactory::new_symbolArray(trace_chunk_size, CHECK);
2315     typeArrayHandle new_names(THREAD, names);
2316 
2317     objArrayOop conts = oopFactory::new_objectArray(trace_chunk_size, CHECK);
2318     objArrayHandle new_conts(THREAD, conts);
2319 
2320     if (!old_head.is_null()) {
2321       old_head-&gt;obj_at_put(trace_next_offset, new_head());
2322     }
2323     new_head-&gt;obj_at_put(trace_methods_offset, new_methods());
2324     new_head-&gt;obj_at_put(trace_bcis_offset, new_bcis());
2325     new_head-&gt;obj_at_put(trace_mirrors_offset, new_mirrors());
2326     new_head-&gt;obj_at_put(trace_names_offset, new_names());
2327     new_head-&gt;obj_at_put(trace_conts_offset, new_conts());
2328     new_head-&gt;obj_at_put(trace_hidden_offset, NULL);
2329 
2330     _head    = new_head();
2331     _methods = new_methods();
2332     _bcis = new_bcis();
2333     _mirrors = new_mirrors();
2334     _names  = new_names();
2335     _conts  = new_conts();
2336     _index = 0;
2337   }
2338 
2339   oop backtrace() {
2340     return _backtrace();
2341   }
2342 
2343   inline void push(Method* method, int bci, oop contScopeName, TRAPS) {
2344     // Smear the -1 bci to 0 since the array only holds unsigned
2345     // shorts.  The later line number lookup would just smear the -1
2346     // to a 0 even if it could be recorded.
2347     if (bci == SynchronizationEntryBCI) bci = 0;
2348 
2349     if (_index &gt;= trace_chunk_size) {
2350       methodHandle mhandle(THREAD, method);
2351       Handle chandle(THREAD, contScopeName);
2352       expand(CHECK);
2353       method = mhandle();
2354       contScopeName = chandle();
2355     }
2356 
2357     _methods-&gt;ushort_at_put(_index, method-&gt;orig_method_idnum());
2358     _bcis-&gt;int_at_put(_index, Backtrace::merge_bci_and_version(bci, method-&gt;constants()-&gt;version()));
2359 
2360     // Note:this doesn&#39;t leak symbols because the mirror in the backtrace keeps the
2361     // klass owning the symbols alive so their refcounts aren&#39;t decremented.
2362     Symbol* name = method-&gt;name();
2363     _names-&gt;symbol_at_put(_index, name);
2364 
2365     // We need to save the mirrors in the backtrace to keep the class
2366     // from being unloaded while we still have this stack trace.
2367     assert(method-&gt;method_holder()-&gt;java_mirror() != NULL, &quot;never push null for mirror&quot;);
2368     _mirrors-&gt;obj_at_put(_index, method-&gt;method_holder()-&gt;java_mirror());
2369 
2370     _conts-&gt;obj_at_put(_index, contScopeName);
2371 
2372     _index++;
2373   }
2374 
2375   void set_has_hidden_top_frame(TRAPS) {
2376     if (!_has_hidden_top_frame) {
2377       // It would be nice to add java/lang/Boolean::TRUE here
2378       // to indicate that this backtrace has a hidden top frame.
2379       // But this code is used before TRUE is allocated.
2380       // Therefore let&#39;s just use an arbitrary legal oop
2381       // available right here. _methods is a short[].
2382       assert(_methods != NULL, &quot;we need a legal oop&quot;);
2383       _has_hidden_top_frame = true;
2384       _head-&gt;obj_at_put(trace_hidden_offset, _methods);
2385     }
2386   }
2387 };
2388 
2389 struct BacktraceElement : public StackObj {
2390   int _method_id;
2391   int _bci;
2392   int _version;
2393   Symbol* _name;
2394   Handle _mirror;
2395   Handle _cont; // the continuation scope name (String)
2396   BacktraceElement(Handle mirror, int mid, int version, int bci, Symbol* name, Handle cont) :
2397                    _method_id(mid), _bci(bci), _version(version), _name(name), _mirror(mirror), _cont(cont) {}
2398 };
2399 
2400 class BacktraceIterator : public StackObj {
2401   int _index;
2402   objArrayHandle  _result;
2403   objArrayHandle  _mirrors;
2404   typeArrayHandle _methods;
2405   typeArrayHandle _bcis;
2406   typeArrayHandle _names;
2407   objArrayHandle  _conts;
2408 
2409   void init(objArrayHandle result, Thread* thread) {
2410     // Get method id, bci, version and mirror from chunk
2411     _result = result;
2412     if (_result.not_null()) {
2413       _methods = typeArrayHandle(thread, BacktraceBuilder::get_methods(_result));
2414       _bcis = typeArrayHandle(thread, BacktraceBuilder::get_bcis(_result));
2415       _mirrors = objArrayHandle(thread, BacktraceBuilder::get_mirrors(_result));
2416       _names = typeArrayHandle(thread, BacktraceBuilder::get_names(_result));
2417       _conts = objArrayHandle(thread, BacktraceBuilder::get_conts(_result));
2418       _index = 0;
2419     }
2420   }
2421  public:
2422   BacktraceIterator(objArrayHandle result, Thread* thread) {
2423     init(result, thread);
2424     assert(_methods.is_null() || _methods-&gt;length() == java_lang_Throwable::trace_chunk_size, &quot;lengths don&#39;t match&quot;);
2425   }
2426 
2427   BacktraceElement next(Thread* thread) {
2428     BacktraceElement e (Handle(thread, _mirrors-&gt;obj_at(_index)),
2429                         _methods-&gt;ushort_at(_index),
2430                         Backtrace::version_at(_bcis-&gt;int_at(_index)),
2431                         Backtrace::bci_at(_bcis-&gt;int_at(_index)),
2432                         _names-&gt;symbol_at(_index),
2433                         Handle(thread, _conts-&gt;obj_at(_index)));
2434     _index++;
2435 
2436     if (_index &gt;= java_lang_Throwable::trace_chunk_size) {
2437       int next_offset = java_lang_Throwable::trace_next_offset;
2438       // Get next chunk
2439       objArrayHandle result (thread, objArrayOop(_result-&gt;obj_at(next_offset)));
2440       init(result, thread);
2441     }
2442     return e;
2443   }
2444 
2445   bool repeat() {
2446     return _result.not_null() &amp;&amp; _mirrors-&gt;obj_at(_index) != NULL;
2447   }
2448 };
2449 
2450 
2451 // Print stack trace element to resource allocated buffer
2452 static void print_stack_element_to_stream(outputStream* st, Handle mirror, int method_id,
2453                                           int version, int bci, Symbol* name) {
2454   ResourceMark rm;
2455 
2456   // Get strings and string lengths
2457   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(mirror()));
2458   const char* klass_name  = holder-&gt;external_name();
2459   int buf_len = (int)strlen(klass_name);
2460 
2461   char* method_name = name-&gt;as_C_string();
2462   buf_len += (int)strlen(method_name);
2463 
2464   char* source_file_name = NULL;
2465   Symbol* source = Backtrace::get_source_file_name(holder, version);
2466   if (source != NULL) {
2467     source_file_name = source-&gt;as_C_string();
2468     buf_len += (int)strlen(source_file_name);
2469   }
2470 
2471   char *module_name = NULL, *module_version = NULL;
2472   ModuleEntry* module = holder-&gt;module();
2473   if (module-&gt;is_named()) {
2474     module_name = module-&gt;name()-&gt;as_C_string();
2475     buf_len += (int)strlen(module_name);
2476     if (module-&gt;version() != NULL) {
2477       module_version = module-&gt;version()-&gt;as_C_string();
2478       buf_len += (int)strlen(module_version);
2479     }
2480   }
2481 
2482   // Allocate temporary buffer with extra space for formatting and line number
2483   char* buf = NEW_RESOURCE_ARRAY(char, buf_len + 64);
2484 
2485   // Print stack trace line in buffer
2486   sprintf(buf, &quot;\tat %s.%s(&quot;, klass_name, method_name);
2487 
2488   // Print module information
2489   if (module_name != NULL) {
2490     if (module_version != NULL) {
2491       sprintf(buf + (int)strlen(buf), &quot;%s@%s/&quot;, module_name, module_version);
2492     } else {
2493       sprintf(buf + (int)strlen(buf), &quot;%s/&quot;, module_name);
2494     }
2495   }
2496 
2497   // The method can be NULL if the requested class version is gone
2498   Method* method = holder-&gt;method_with_orig_idnum(method_id, version);
2499   if (!version_matches(method, version)) {
2500     strcat(buf, &quot;Redefined)&quot;);
2501   } else {
2502     int line_number = Backtrace::get_line_number(method, bci);
2503     if (line_number == -2) {
2504       strcat(buf, &quot;Native Method)&quot;);
2505     } else {
2506       if (source_file_name != NULL &amp;&amp; (line_number != -1)) {
2507         // Sourcename and linenumber
2508         sprintf(buf + (int)strlen(buf), &quot;%s:%d)&quot;, source_file_name, line_number);
2509       } else if (source_file_name != NULL) {
2510         // Just sourcename
2511         sprintf(buf + (int)strlen(buf), &quot;%s)&quot;, source_file_name);
2512       } else {
2513         // Neither sourcename nor linenumber
2514         sprintf(buf + (int)strlen(buf), &quot;Unknown Source)&quot;);
2515       }
2516       CompiledMethod* nm = method-&gt;code();
2517       if (WizardMode &amp;&amp; nm != NULL) {
2518         sprintf(buf + (int)strlen(buf), &quot;(nmethod &quot; INTPTR_FORMAT &quot;)&quot;, (intptr_t)nm);
2519       }
2520     }
2521   }
2522 
2523   st-&gt;print_cr(&quot;%s&quot;, buf);
2524 }
2525 
2526 void java_lang_Throwable::print_stack_element(outputStream *st, Method* method, int bci) {
2527   Handle mirror (Thread::current(),  method-&gt;method_holder()-&gt;java_mirror());
2528   int method_id = method-&gt;orig_method_idnum();
2529   int version = method-&gt;constants()-&gt;version();
2530   print_stack_element_to_stream(st, mirror, method_id, version, bci, method-&gt;name());
2531 }
2532 
2533 /**
2534  * Print the throwable message and its stack trace plus all causes by walking the
2535  * cause chain.  The output looks the same as of Throwable.printStackTrace().
2536  */
2537 void java_lang_Throwable::print_stack_trace(Handle throwable, outputStream* st) {
2538   // First, print the message.
2539   print(throwable(), st);
2540   st-&gt;cr();
2541 
2542   // Now print the stack trace.
2543   Thread* THREAD = Thread::current();
2544   while (throwable.not_null()) {
2545     objArrayHandle result (THREAD, objArrayOop(backtrace(throwable())));
2546     if (result.is_null()) {
2547       st-&gt;print_raw_cr(&quot;\t&lt;&lt;no stack trace available&gt;&gt;&quot;);
2548       return;
2549     }
2550     BacktraceIterator iter(result, THREAD);
2551 
2552     while (iter.repeat()) {
2553       BacktraceElement bte = iter.next(THREAD);
2554       print_stack_element_to_stream(st, bte._mirror, bte._method_id, bte._version, bte._bci, bte._name);
2555     }
2556     {
2557       // Call getCause() which doesn&#39;t necessarily return the _cause field.
2558       EXCEPTION_MARK;
2559       JavaValue cause(T_OBJECT);
2560       JavaCalls::call_virtual(&amp;cause,
2561                               throwable,
2562                               throwable-&gt;klass(),
2563                               vmSymbols::getCause_name(),
2564                               vmSymbols::void_throwable_signature(),
2565                               THREAD);
2566       // Ignore any exceptions. we are in the middle of exception handling. Same as classic VM.
2567       if (HAS_PENDING_EXCEPTION) {
2568         CLEAR_PENDING_EXCEPTION;
2569         throwable = Handle();
2570       } else {
2571         throwable = Handle(THREAD, (oop) cause.get_jobject());
2572         if (throwable.not_null()) {
2573           st-&gt;print(&quot;Caused by: &quot;);
2574           print(throwable(), st);
2575           st-&gt;cr();
2576         }
2577       }
2578     }
2579   }
2580 }
2581 
2582 /**
2583  * Print the throwable stack trace by calling the Java method java.lang.Throwable.printStackTrace().
2584  */
2585 void java_lang_Throwable::java_printStackTrace(Handle throwable, TRAPS) {
2586   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;Throwable instance expected&quot;);
2587   JavaValue result(T_VOID);
2588   JavaCalls::call_virtual(&amp;result,
2589                           throwable,
2590                           SystemDictionary::Throwable_klass(),
2591                           vmSymbols::printStackTrace_name(),
2592                           vmSymbols::void_method_signature(),
2593                           THREAD);
2594 }
2595 
2596 extern &quot;C&quot; void pfl();
2597 
2598 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, Handle contScope, const methodHandle&amp; method, TRAPS) {
2599   if (!StackTraceInThrowable) return;
2600   ResourceMark rm(THREAD);
2601   HandleMark hm(THREAD);
2602 
2603   // Start out by clearing the backtrace for this object, in case the VM
2604   // runs out of memory while allocating the stack trace
2605   set_backtrace(throwable(), NULL);
2606   // Clear lazily constructed Java level stacktrace if refilling occurs
2607   // This is unnecessary in 1.7+ but harmless
2608   clear_stacktrace(throwable());
2609 
2610   int max_depth = MaxJavaStackTraceDepth;
2611   JavaThread* thread = (JavaThread*)THREAD;
2612 
2613   BacktraceBuilder bt(CHECK);
2614 
2615   // If there is no Java frame just return the method that was being called
2616   // with bci 0
2617   if (!thread-&gt;has_last_Java_frame()) {
2618     if (max_depth &gt;= 1 &amp;&amp; method() != NULL) {
2619       bt.push(method(), 0, NULL, CHECK);
2620       log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), 1);
2621       set_depth(throwable(), 1);
2622       set_backtrace(throwable(), bt.backtrace());
2623     }
2624     return;
2625   }
2626 
2627   // Instead of using vframe directly, this version of fill_in_stack_trace
2628   // basically handles everything by hand. This significantly improved the
2629   // speed of this method call up to 28.5% on Solaris sparc. 27.1% on Windows.
2630   // See bug 6333838 for  more details.
2631   // The &quot;ASSERT&quot; here is to verify this method generates the exactly same stack
2632   // trace as utilizing vframe.
2633 #ifdef ASSERT
2634   vframeStream st(thread, contScope);
2635 #endif
2636   int total_count = 0;
2637   RegisterMap map(thread, false, true);
2638   int decode_offset = 0;
2639   CompiledMethod* nm = NULL;
2640   bool skip_fillInStackTrace_check = false;
2641   bool skip_throwableInit_check = false;
2642   bool skip_hidden = !ShowHiddenFrames;
2643   bool is_last = false;
2644   Handle cont_h(THREAD, thread-&gt;last_continuation());
2645   for (frame fr = thread-&gt;last_frame(); max_depth == 0 || max_depth != total_count;) {
2646     Method* method = NULL;
2647     int bci = 0;
2648     oop contScopeName = (cont_h() != NULL) ? java_lang_ContinuationScope::name(java_lang_Continuation::scope(cont_h())) : (oop)NULL;
2649 
2650     // Compiled java method case.
2651     if (decode_offset != 0) {
2652       DebugInfoReadStream stream(nm, decode_offset);
2653       decode_offset = stream.read_int();
2654       method = (Method*)nm-&gt;metadata_at(stream.read_int());
2655       bci = stream.read_bci();
2656     } else {
2657       if (fr.is_first_frame()) break;
2658 
2659       assert (contScope.is_null() || cont_h() != NULL, &quot;must be&quot;);
2660       if (cont_h() != NULL &amp;&amp; Continuation::is_continuation_entry_frame(fr, &amp;map)) {
2661         oop scope = java_lang_Continuation::scope(cont_h());
2662         if (contScope.not_null() &amp;&amp; (scope == contScope())) {
2663           is_last = true;
2664         } else {
2665           // if (!Continuation::is_frame_in_continuation(fr, cont)) {
2666           //   tty-&gt;print_cr(&quot;&gt;&gt;&gt;&gt;&gt;&quot;);
2667           //   fr.print_on(tty);
2668           //   tty-&gt;print_cr(&quot;&lt;&lt;&lt;&lt;&lt;&quot;);
2669           //   pfl();
2670           // }
2671           assert (Continuation::is_frame_in_continuation(fr, cont_h()), &quot;must be&quot;);
2672           Handle parent_h(THREAD, java_lang_Continuation::parent(cont_h()));
2673           cont_h =  parent_h;
2674         }
2675       }
2676 
2677       address pc = fr.pc();
2678       if (fr.is_interpreted_frame()) {
2679         address bcp;
2680         if (!map.in_cont()) {
2681           bcp = fr.interpreter_frame_bcp();
2682           method = fr.interpreter_frame_method();
2683         } else {
2684           bcp = Continuation::interpreter_frame_bcp(fr, &amp;map);
2685           method = Continuation::interpreter_frame_method(fr, &amp;map);
2686         }
2687         bci =  method-&gt;bci_from(bcp);
2688         fr = fr.sender(&amp;map);
2689       } else {
2690         CodeBlob* cb = fr.cb();
2691         // HMMM QQQ might be nice to have frame return nm as NULL if cb is non-NULL
2692         // but non nmethod
2693         fr = fr.sender(&amp;map);
2694         if (cb == NULL || !cb-&gt;is_compiled()) {
2695           continue;
2696         }
2697         nm = cb-&gt;as_compiled_method();
2698         assert (nm-&gt;method() != NULL, &quot;must be&quot;);
2699         if (nm-&gt;method()-&gt;is_native()) {
2700           method = nm-&gt;method();
2701           bci = 0;
2702         } else {
2703           PcDesc* pd = nm-&gt;pc_desc_at(pc);
2704           decode_offset = pd-&gt;scope_decode_offset();
2705           // if decode_offset is not equal to 0, it will execute the
2706           // &quot;compiled java method case&quot; at the beginning of the loop.
2707           continue;
2708         }
2709       }
2710     }
2711 #ifdef ASSERT
2712     assert(st.method() == method &amp;&amp; st.bci() == bci, &quot;Wrong stack trace&quot;);
2713     st.next();
2714 #endif
2715 
2716     // the format of the stacktrace will be:
2717     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2718     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2719     // - rest of the stack
2720 
2721     if (!skip_fillInStackTrace_check) {
2722       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2723           throwable-&gt;is_a(method-&gt;method_holder())) {
2724         continue;
2725       }
2726       else {
2727         skip_fillInStackTrace_check = true; // gone past them all
2728       }
2729     }
2730     if (!skip_throwableInit_check) {
2731       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2732 
2733       // skip &lt;init&gt; methods of the exception class and superclasses
2734       // This is simlar to classic VM.
2735       if (method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
2736           throwable-&gt;is_a(method-&gt;method_holder())) {
2737         continue;
2738       } else {
2739         // there are none or we&#39;ve seen them all - either way stop checking
2740         skip_throwableInit_check = true;
2741       }
2742     }
2743     if (method-&gt;is_hidden()) {
2744       if (skip_hidden) {
2745         if (total_count == 0) {
2746           // The top frame will be hidden from the stack trace.
2747           bt.set_has_hidden_top_frame(CHECK);
2748         }
2749         continue;
2750       }
2751     }
2752 
2753     bt.push(method, bci, contScopeName, CHECK);
2754     total_count++;
2755     if (is_last) break;
2756   }
2757 
2758   log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), total_count);
2759 
2760   // Put completed stack trace into throwable object
2761   set_backtrace(throwable(), bt.backtrace());
2762   set_depth(throwable(), total_count);
2763 }
2764 
2765 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, Handle contScope, const methodHandle&amp; method) {
2766   // No-op if stack trace is disabled
2767   if (!StackTraceInThrowable) {
2768     return;
2769   }
2770 
2771   // Disable stack traces for some preallocated out of memory errors
2772   if (!Universe::should_fill_in_stack_trace(throwable)) {
2773     return;
2774   }
2775 
2776   PRESERVE_EXCEPTION_MARK;
2777 
2778   JavaThread* thread = JavaThread::active();
2779   fill_in_stack_trace(throwable, contScope, method, thread);
2780   // ignore exceptions thrown during stack trace filling
2781   CLEAR_PENDING_EXCEPTION;
2782 }
2783 
2784 void java_lang_Throwable::allocate_backtrace(Handle throwable, TRAPS) {
2785   // Allocate stack trace - backtrace is created but not filled in
2786 
2787   // No-op if stack trace is disabled
2788   if (!StackTraceInThrowable) return;
2789   BacktraceBuilder bt(CHECK);   // creates a backtrace
2790   set_backtrace(throwable(), bt.backtrace());
2791 }
2792 
2793 
2794 void java_lang_Throwable::fill_in_stack_trace_of_preallocated_backtrace(Handle throwable) {
2795   // Fill in stack trace into preallocated backtrace (no GC)
2796 
2797   // No-op if stack trace is disabled
2798   if (!StackTraceInThrowable) return;
2799 
2800   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;sanity check&quot;);
2801 
2802   JavaThread* THREAD = JavaThread::current();
2803 
2804   objArrayHandle backtrace (THREAD, (objArrayOop)java_lang_Throwable::backtrace(throwable()));
2805   assert(backtrace.not_null(), &quot;backtrace should have been preallocated&quot;);
2806 
2807   ResourceMark rm(THREAD);
2808   vframeStream st(THREAD);
2809 
2810   BacktraceBuilder bt(THREAD, backtrace);
2811 
2812   // Unlike fill_in_stack_trace we do not skip fillInStackTrace or throwable init
2813   // methods as preallocated errors aren&#39;t created by &quot;java&quot; code.
2814 
2815   // fill in as much stack trace as possible
2816   int chunk_count = 0;
2817   for (;!st.at_end(); st.next()) {
2818     bt.push(st.method(), st.bci(), NULL, CHECK);
2819     chunk_count++;
2820 
2821     // Bail-out for deep stacks
2822     if (chunk_count &gt;= trace_chunk_size) break;
2823   }
2824   set_depth(throwable(), chunk_count);
2825   log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), chunk_count);
2826 
2827   // We support the Throwable immutability protocol defined for Java 7.
2828   java_lang_Throwable::set_stacktrace(throwable(), java_lang_Throwable::unassigned_stacktrace());
2829   assert(java_lang_Throwable::unassigned_stacktrace() != NULL, &quot;not initialized&quot;);
2830 }
2831 
2832 void java_lang_Throwable::get_stack_trace_elements(Handle throwable,
2833                                                    objArrayHandle stack_trace_array_h, TRAPS) {
2834 
2835   if (throwable.is_null() || stack_trace_array_h.is_null()) {
2836     THROW(vmSymbols::java_lang_NullPointerException());
2837   }
2838 
2839   assert(stack_trace_array_h-&gt;is_objArray(), &quot;Stack trace array should be an array of StackTraceElenent&quot;);
2840 
2841   if (stack_trace_array_h-&gt;length() != depth(throwable())) {
2842     THROW(vmSymbols::java_lang_IndexOutOfBoundsException());
2843   }
2844 
2845   objArrayHandle result(THREAD, objArrayOop(backtrace(throwable())));
2846   BacktraceIterator iter(result, THREAD);
2847 
2848   int index = 0;
2849   while (iter.repeat()) {
2850     BacktraceElement bte = iter.next(THREAD);
2851 
2852     Handle stack_trace_element(THREAD, stack_trace_array_h-&gt;obj_at(index++));
2853 
2854     if (stack_trace_element.is_null()) {
2855       THROW(vmSymbols::java_lang_NullPointerException());
2856     }
2857 
2858     InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2859     methodHandle method (THREAD, holder-&gt;method_with_orig_idnum(bte._method_id, bte._version));
2860 
2861     java_lang_StackTraceElement::fill_in(stack_trace_element, holder,
2862                                          method,
2863                                          bte._version,
2864                                          bte._bci,
2865                                          bte._name,
2866                                          bte._cont,
2867                                          CHECK);
2868   }
2869 }
2870 
2871 bool java_lang_Throwable::get_top_method_and_bci(oop throwable, Method** method, int* bci) {
2872   Thread* THREAD = Thread::current();
2873   objArrayHandle result(THREAD, objArrayOop(backtrace(throwable)));
2874   BacktraceIterator iter(result, THREAD);
2875   // No backtrace available.
2876   if (!iter.repeat()) return false;
2877 
2878   // If the exception happened in a frame that has been hidden, i.e.,
2879   // omitted from the back trace, we can not compute the message.
2880   oop hidden = ((objArrayOop)backtrace(throwable))-&gt;obj_at(trace_hidden_offset);
2881   if (hidden != NULL) {
2882     return false;
2883   }
2884 
2885   // Get first backtrace element.
2886   BacktraceElement bte = iter.next(THREAD);
2887 
2888   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2889   assert(holder != NULL, &quot;first element should be non-null&quot;);
2890   Method* m = holder-&gt;method_with_orig_idnum(bte._method_id, bte._version);
2891 
2892   // Original version is no longer available.
2893   if (m == NULL || !version_matches(m, bte._version)) {
2894     return false;
2895   }
2896 
2897   *method = m;
2898   *bci = bte._bci;
2899   return true;
2900 }
2901 
2902 oop java_lang_StackTraceElement::create(const methodHandle&amp; method, int bci, Handle contScope, TRAPS) {
2903   // Allocate java.lang.StackTraceElement instance
2904   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
2905   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
2906   if (k-&gt;should_be_initialized()) {
2907     k-&gt;initialize(CHECK_NULL);
2908   }
2909 
2910   Handle element = k-&gt;allocate_instance_handle(CHECK_NULL);
2911 
2912   int version = method-&gt;constants()-&gt;version();
2913   fill_in(element, method-&gt;method_holder(), method, version, bci, method-&gt;name(), contScope, CHECK_NULL);
2914   return element();
2915 }
2916 
2917 void java_lang_StackTraceElement::fill_in(Handle element,
2918                                           InstanceKlass* holder, const methodHandle&amp; method,
2919                                           int version, int bci, Symbol* name, Handle contScopeName, TRAPS) {
2920   assert(element-&gt;is_a(SystemDictionary::StackTraceElement_klass()), &quot;sanity check&quot;);
2921 
2922   ResourceMark rm(THREAD);
2923   HandleMark hm(THREAD);
2924 
2925   // Fill in class name
2926   Handle java_class(THREAD, holder-&gt;java_mirror());
2927   oop classname = java_lang_Class::name(java_class, CHECK);
2928   java_lang_StackTraceElement::set_declaringClass(element(), classname);
2929   java_lang_StackTraceElement::set_declaringClassObject(element(), java_class());
2930 
2931   oop loader = holder-&gt;class_loader();
2932   if (loader != NULL) {
2933     oop loader_name = java_lang_ClassLoader::name(loader);
2934     if (loader_name != NULL)
2935       java_lang_StackTraceElement::set_classLoaderName(element(), loader_name);
2936   }
2937 
2938   // Fill in method name
2939   oop methodname = StringTable::intern(name, CHECK);
2940   java_lang_StackTraceElement::set_methodName(element(), methodname);
2941 
2942   // Fill in module name and version
2943   ModuleEntry* module = holder-&gt;module();
2944   if (module-&gt;is_named()) {
2945     oop module_name = StringTable::intern(module-&gt;name(), CHECK);
2946     java_lang_StackTraceElement::set_moduleName(element(), module_name);
2947     oop module_version;
2948     if (module-&gt;version() != NULL) {
2949       module_version = StringTable::intern(module-&gt;version(), CHECK);
2950     } else {
2951       module_version = NULL;
2952     }
2953     java_lang_StackTraceElement::set_moduleVersion(element(), module_version);
2954   }
2955 
2956   if (method() == NULL || !version_matches(method(), version)) {
2957     // The method was redefined, accurate line number information isn&#39;t available
2958     java_lang_StackTraceElement::set_fileName(element(), NULL);
2959     java_lang_StackTraceElement::set_lineNumber(element(), -1);
2960   } else {
2961     Symbol* source;
2962     oop source_file;
2963     int line_number;
2964     decode_file_and_line(java_class, holder, version, method, bci, source, source_file, line_number, CHECK);
2965 
2966     java_lang_StackTraceElement::set_fileName(element(), source_file);
2967     java_lang_StackTraceElement::set_lineNumber(element(), line_number);
2968   }
2969 
2970   // Fill in continuation scope
2971   java_lang_StackTraceElement::set_contScopeName(element(), contScopeName());
2972 }
2973 
2974 void java_lang_StackTraceElement::decode_file_and_line(Handle java_class,
2975                                                        InstanceKlass* holder,
2976                                                        int version,
2977                                                        const methodHandle&amp; method,
2978                                                        int bci,
2979                                                        Symbol*&amp; source,
2980                                                        oop&amp; source_file,
2981                                                        int&amp; line_number, TRAPS) {
2982   // Fill in source file name and line number.
2983   source = Backtrace::get_source_file_name(holder, version);
2984   source_file = java_lang_Class::source_file(java_class());
2985   if (source != NULL) {
2986     // Class was not redefined. We can trust its cache if set,
2987     // else we have to initialize it.
2988     if (source_file == NULL) {
2989       source_file = StringTable::intern(source, CHECK);
2990       java_lang_Class::set_source_file(java_class(), source_file);
2991     }
2992   } else {
2993     // Class was redefined. Dump the cache if it was set.
2994     if (source_file != NULL) {
2995       source_file = NULL;
2996       java_lang_Class::set_source_file(java_class(), source_file);
2997     }
2998   }
2999   line_number = Backtrace::get_line_number(method(), bci);
3000 }
3001 
3002 #if INCLUDE_JVMCI
3003 void java_lang_StackTraceElement::decode(const methodHandle&amp; method, int bci,
3004                                          Symbol*&amp; filename, int&amp; line_number, TRAPS) {
3005   ResourceMark rm(THREAD);
3006   HandleMark hm(THREAD);
3007 
3008   filename = NULL;
3009   line_number = -1;
3010 
3011   oop source_file;
3012   int version = method-&gt;constants()-&gt;version();
3013   InstanceKlass* holder = method-&gt;method_holder();
3014   Handle java_class(THREAD, holder-&gt;java_mirror());
3015   decode_file_and_line(java_class, holder, version, method, bci, filename, source_file, line_number, CHECK);
3016 }
3017 #endif // INCLUDE_JVMCI
3018 
3019 Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
3020   HandleMark hm(THREAD);
3021   Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
3022   Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
3023   // we should expand MemberName::name when Throwable uses StackTrace
3024   // MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);
3025   return method;
3026 }
3027 
3028 void java_lang_StackFrameInfo::set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, oop cont, TRAPS) {
3029   // set Method* or mid/cpref
3030   HandleMark hm(THREAD);
3031   Handle mname(Thread::current(), stackFrame-&gt;obj_field(_memberName_offset));
3032   Handle cont_h (THREAD, cont);
3033   InstanceKlass* ik = method-&gt;method_holder();
3034   CallInfo info(method(), ik, CHECK);
3035   MethodHandles::init_method_MemberName(mname, info);
3036   // set bci
3037   java_lang_StackFrameInfo::set_bci(stackFrame(), bci);
3038   // method may be redefined; store the version
3039   int version = method-&gt;constants()-&gt;version();
3040   assert((jushort)version == version, &quot;version should be short&quot;);
3041   java_lang_StackFrameInfo::set_version(stackFrame(), (short)version);
3042 
3043   oop contScope = cont_h() != NULL ? java_lang_Continuation::scope(cont_h()) : (oop)NULL;
3044   java_lang_StackFrameInfo::set_contScope(stackFrame(), contScope);
3045 }
3046 
3047 void java_lang_StackFrameInfo::to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS) {
3048   ResourceMark rm(THREAD);
3049   HandleMark hm(THREAD);
3050   Handle mname(THREAD, stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_memberName_offset));
3051   Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
3052   InstanceKlass* holder = InstanceKlass::cast(clazz);
3053   Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);
3054   oop contScope = stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_contScope_offset);
3055   Handle contScopeName(THREAD, contScope != (oop)NULL ? java_lang_ContinuationScope::name(contScope) : (oop)NULL);
3056 
3057   short version = stackFrame-&gt;short_field(_version_offset);
3058   int bci = stackFrame-&gt;int_field(_bci_offset);
3059   Symbol* name = method-&gt;name();
3060   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, methodHandle(THREAD, method), version, bci, name, contScopeName, CHECK);
3061 }
3062 
3063 #define STACKFRAMEINFO_FIELDS_DO(macro) \
3064   macro(_memberName_offset,     k, &quot;memberName&quot;,  object_signature, false); \
3065   macro(_bci_offset,            k, &quot;bci&quot;,         int_signature,    false); \
3066   macro(_contScope_offset,      k, &quot;contScope&quot;,   continuationscope_signature, false)
3067 
3068 void java_lang_StackFrameInfo::compute_offsets() {
3069   InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();
3070   STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3071   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3072 }
3073 
3074 #if INCLUDE_CDS
3075 void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {
3076   STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3077   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3078 }
3079 #endif
3080 
3081 #define LIVESTACKFRAMEINFO_FIELDS_DO(macro) \
3082   macro(_monitors_offset,   k, &quot;monitors&quot;,    object_array_signature, false); \
3083   macro(_locals_offset,     k, &quot;locals&quot;,      object_array_signature, false); \
3084   macro(_operands_offset,   k, &quot;operands&quot;,    object_array_signature, false); \
3085   macro(_mode_offset,       k, &quot;mode&quot;,        int_signature,          false)
3086 
3087 void java_lang_LiveStackFrameInfo::compute_offsets() {
3088   InstanceKlass* k = SystemDictionary::LiveStackFrameInfo_klass();
3089   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3090 }
3091 
3092 #if INCLUDE_CDS
3093 void java_lang_LiveStackFrameInfo::serialize_offsets(SerializeClosure* f) {
3094   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3095 }
3096 #endif
3097 
3098 #define ACCESSIBLEOBJECT_FIELDS_DO(macro) \
3099   macro(override_offset, k, &quot;override&quot;, bool_signature, false)
3100 
3101 void java_lang_reflect_AccessibleObject::compute_offsets() {
3102   InstanceKlass* k = SystemDictionary::reflect_AccessibleObject_klass();
3103   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3104 }
3105 
3106 #if INCLUDE_CDS
3107 void java_lang_reflect_AccessibleObject::serialize_offsets(SerializeClosure* f) {
3108   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3109 }
3110 #endif
3111 
3112 jboolean java_lang_reflect_AccessibleObject::override(oop reflect) {
3113   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3114   return (jboolean) reflect-&gt;bool_field(override_offset);
3115 }
3116 
3117 void java_lang_reflect_AccessibleObject::set_override(oop reflect, jboolean value) {
3118   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3119   reflect-&gt;bool_field_put(override_offset, (int) value);
3120 }
3121 
3122 #define METHOD_FIELDS_DO(macro) \
3123   macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
3124   macro(name_offset,           k, vmSymbols::name_name(),           string_signature,      false); \
3125   macro(returnType_offset,     k, vmSymbols::returnType_name(),     class_signature,       false); \
3126   macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
3127   macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
3128   macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
3129   macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
3130   macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
3131   macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
3132   macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false); \
3133   macro(annotation_default_offset,    k, vmSymbols::annotation_default_name(),    byte_array_signature, false);
3134 
3135 void java_lang_reflect_Method::compute_offsets() {
3136   InstanceKlass* k = SystemDictionary::reflect_Method_klass();
3137   METHOD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3138 }
3139 
3140 #if INCLUDE_CDS
3141 void java_lang_reflect_Method::serialize_offsets(SerializeClosure* f) {
3142   METHOD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3143 }
3144 #endif
3145 
3146 Handle java_lang_reflect_Method::create(TRAPS) {
3147   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3148   Klass* klass = SystemDictionary::reflect_Method_klass();
3149   // This class is eagerly initialized during VM initialization, since we keep a refence
3150   // to one of the methods
3151   assert(InstanceKlass::cast(klass)-&gt;is_initialized(), &quot;must be initialized&quot;);
3152   return InstanceKlass::cast(klass)-&gt;allocate_instance_handle(THREAD);
3153 }
3154 
3155 oop java_lang_reflect_Method::clazz(oop reflect) {
3156   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3157   return reflect-&gt;obj_field(clazz_offset);
3158 }
3159 
3160 void java_lang_reflect_Method::set_clazz(oop reflect, oop value) {
3161   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3162    reflect-&gt;obj_field_put(clazz_offset, value);
3163 }
3164 
3165 int java_lang_reflect_Method::slot(oop reflect) {
3166   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3167   return reflect-&gt;int_field(slot_offset);
3168 }
3169 
3170 void java_lang_reflect_Method::set_slot(oop reflect, int value) {
3171   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3172   reflect-&gt;int_field_put(slot_offset, value);
3173 }
3174 
3175 void java_lang_reflect_Method::set_name(oop method, oop value) {
3176   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3177   method-&gt;obj_field_put(name_offset, value);
3178 }
3179 
3180 oop java_lang_reflect_Method::return_type(oop method) {
3181   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3182   return method-&gt;obj_field(returnType_offset);
3183 }
3184 
3185 void java_lang_reflect_Method::set_return_type(oop method, oop value) {
3186   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3187   method-&gt;obj_field_put(returnType_offset, value);
3188 }
3189 
3190 oop java_lang_reflect_Method::parameter_types(oop method) {
3191   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3192   return method-&gt;obj_field(parameterTypes_offset);
3193 }
3194 
3195 void java_lang_reflect_Method::set_parameter_types(oop method, oop value) {
3196   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3197   method-&gt;obj_field_put(parameterTypes_offset, value);
3198 }
3199 
3200 void java_lang_reflect_Method::set_exception_types(oop method, oop value) {
3201   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3202   method-&gt;obj_field_put(exceptionTypes_offset, value);
3203 }
3204 
3205 void java_lang_reflect_Method::set_modifiers(oop method, int value) {
3206   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3207   method-&gt;int_field_put(modifiers_offset, value);
3208 }
3209 
3210 void java_lang_reflect_Method::set_signature(oop method, oop value) {
3211   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3212   method-&gt;obj_field_put(signature_offset, value);
3213 }
3214 
3215 void java_lang_reflect_Method::set_annotations(oop method, oop value) {
3216   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3217   method-&gt;obj_field_put(annotations_offset, value);
3218 }
3219 
3220 void java_lang_reflect_Method::set_parameter_annotations(oop method, oop value) {
3221   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3222   method-&gt;obj_field_put(parameter_annotations_offset, value);
3223 }
3224 
3225 void java_lang_reflect_Method::set_annotation_default(oop method, oop value) {
3226   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3227   method-&gt;obj_field_put(annotation_default_offset, value);
3228 }
3229 
3230 #define CONSTRUCTOR_FIELDS_DO(macro) \
3231   macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
3232   macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
3233   macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
3234   macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
3235   macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
3236   macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
3237   macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
3238   macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false);
3239 
3240 void java_lang_reflect_Constructor::compute_offsets() {
3241   InstanceKlass* k = SystemDictionary::reflect_Constructor_klass();
3242   CONSTRUCTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3243 }
3244 
3245 #if INCLUDE_CDS
3246 void java_lang_reflect_Constructor::serialize_offsets(SerializeClosure* f) {
3247   CONSTRUCTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3248 }
3249 #endif
3250 
3251 Handle java_lang_reflect_Constructor::create(TRAPS) {
3252   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3253   Symbol* name = vmSymbols::java_lang_reflect_Constructor();
3254   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3255   InstanceKlass* ik = InstanceKlass::cast(k);
3256   // Ensure it is initialized
3257   ik-&gt;initialize(CHECK_NH);
3258   return ik-&gt;allocate_instance_handle(THREAD);
3259 }
3260 
3261 oop java_lang_reflect_Constructor::clazz(oop reflect) {
3262   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3263   return reflect-&gt;obj_field(clazz_offset);
3264 }
3265 
3266 void java_lang_reflect_Constructor::set_clazz(oop reflect, oop value) {
3267   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3268    reflect-&gt;obj_field_put(clazz_offset, value);
3269 }
3270 
3271 oop java_lang_reflect_Constructor::parameter_types(oop constructor) {
3272   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3273   return constructor-&gt;obj_field(parameterTypes_offset);
3274 }
3275 
3276 void java_lang_reflect_Constructor::set_parameter_types(oop constructor, oop value) {
3277   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3278   constructor-&gt;obj_field_put(parameterTypes_offset, value);
3279 }
3280 
3281 void java_lang_reflect_Constructor::set_exception_types(oop constructor, oop value) {
3282   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3283   constructor-&gt;obj_field_put(exceptionTypes_offset, value);
3284 }
3285 
3286 int java_lang_reflect_Constructor::slot(oop reflect) {
3287   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3288   return reflect-&gt;int_field(slot_offset);
3289 }
3290 
3291 void java_lang_reflect_Constructor::set_slot(oop reflect, int value) {
3292   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3293   reflect-&gt;int_field_put(slot_offset, value);
3294 }
3295 
3296 void java_lang_reflect_Constructor::set_modifiers(oop constructor, int value) {
3297   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3298   constructor-&gt;int_field_put(modifiers_offset, value);
3299 }
3300 
3301 void java_lang_reflect_Constructor::set_signature(oop constructor, oop value) {
3302   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3303   constructor-&gt;obj_field_put(signature_offset, value);
3304 }
3305 
3306 void java_lang_reflect_Constructor::set_annotations(oop constructor, oop value) {
3307   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3308   constructor-&gt;obj_field_put(annotations_offset, value);
3309 }
3310 
3311 void java_lang_reflect_Constructor::set_parameter_annotations(oop method, oop value) {
3312   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3313   method-&gt;obj_field_put(parameter_annotations_offset, value);
3314 }
3315 
3316 #define FIELD_FIELDS_DO(macro) \
3317   macro(clazz_offset,     k, vmSymbols::clazz_name(),     class_signature,  false); \
3318   macro(name_offset,      k, vmSymbols::name_name(),      string_signature, false); \
3319   macro(type_offset,      k, vmSymbols::type_name(),      class_signature,  false); \
3320   macro(slot_offset,      k, vmSymbols::slot_name(),      int_signature,    false); \
3321   macro(modifiers_offset, k, vmSymbols::modifiers_name(), int_signature,    false); \
3322   macro(signature_offset,        k, vmSymbols::signature_name(),        string_signature,     false); \
3323   macro(annotations_offset,      k, vmSymbols::annotations_name(),      byte_array_signature, false);
3324 
3325 void java_lang_reflect_Field::compute_offsets() {
3326   InstanceKlass* k = SystemDictionary::reflect_Field_klass();
3327   FIELD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3328 }
3329 
3330 #if INCLUDE_CDS
3331 void java_lang_reflect_Field::serialize_offsets(SerializeClosure* f) {
3332   FIELD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3333 }
3334 #endif
3335 
3336 Handle java_lang_reflect_Field::create(TRAPS) {
3337   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3338   Symbol* name = vmSymbols::java_lang_reflect_Field();
3339   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3340   InstanceKlass* ik = InstanceKlass::cast(k);
3341   // Ensure it is initialized
3342   ik-&gt;initialize(CHECK_NH);
3343   return ik-&gt;allocate_instance_handle(THREAD);
3344 }
3345 
3346 oop java_lang_reflect_Field::clazz(oop reflect) {
3347   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3348   return reflect-&gt;obj_field(clazz_offset);
3349 }
3350 
3351 void java_lang_reflect_Field::set_clazz(oop reflect, oop value) {
3352   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3353    reflect-&gt;obj_field_put(clazz_offset, value);
3354 }
3355 
3356 oop java_lang_reflect_Field::name(oop field) {
3357   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3358   return field-&gt;obj_field(name_offset);
3359 }
3360 
3361 void java_lang_reflect_Field::set_name(oop field, oop value) {
3362   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3363   field-&gt;obj_field_put(name_offset, value);
3364 }
3365 
3366 oop java_lang_reflect_Field::type(oop field) {
3367   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3368   return field-&gt;obj_field(type_offset);
3369 }
3370 
3371 void java_lang_reflect_Field::set_type(oop field, oop value) {
3372   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3373   field-&gt;obj_field_put(type_offset, value);
3374 }
3375 
3376 int java_lang_reflect_Field::slot(oop reflect) {
3377   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3378   return reflect-&gt;int_field(slot_offset);
3379 }
3380 
3381 void java_lang_reflect_Field::set_slot(oop reflect, int value) {
3382   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3383   reflect-&gt;int_field_put(slot_offset, value);
3384 }
3385 
3386 int java_lang_reflect_Field::modifiers(oop field) {
3387   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3388   return field-&gt;int_field(modifiers_offset);
3389 }
3390 
3391 void java_lang_reflect_Field::set_modifiers(oop field, int value) {
3392   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3393   field-&gt;int_field_put(modifiers_offset, value);
3394 }
3395 
3396 void java_lang_reflect_Field::set_signature(oop field, oop value) {
3397   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3398   field-&gt;obj_field_put(signature_offset, value);
3399 }
3400 
3401 void java_lang_reflect_Field::set_annotations(oop field, oop value) {
3402   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3403   field-&gt;obj_field_put(annotations_offset, value);
3404 }
3405 
3406 oop java_lang_reflect_RecordComponent::create(InstanceKlass* holder, RecordComponent* component, TRAPS) {
3407   // Allocate java.lang.reflect.RecordComponent instance
3408   HandleMark hm(THREAD);
3409   InstanceKlass* ik = SystemDictionary::RecordComponent_klass();
3410   assert(ik != NULL, &quot;must be loaded&quot;);
3411   ik-&gt;initialize(CHECK_NULL);
3412 
3413   Handle element = ik-&gt;allocate_instance_handle(CHECK_NULL);
3414 
3415   Handle decl_class(THREAD, holder-&gt;java_mirror());
3416   java_lang_reflect_RecordComponent::set_clazz(element(), decl_class());
3417 
3418   Symbol* name = holder-&gt;constants()-&gt;symbol_at(component-&gt;name_index()); // name_index is a utf8
3419   oop component_name = StringTable::intern(name, CHECK_NULL);
3420   java_lang_reflect_RecordComponent::set_name(element(), component_name);
3421 
3422   Symbol* type = holder-&gt;constants()-&gt;symbol_at(component-&gt;descriptor_index());
3423   Handle component_type_h =
3424     SystemDictionary::find_java_mirror_for_type(type, holder, SignatureStream::NCDFError, CHECK_NULL);
3425   java_lang_reflect_RecordComponent::set_type(element(), component_type_h());
3426 
3427   Method* accessor_method = NULL;
3428   {
3429     // Prepend &quot;()&quot; to type to create the full method signature.
3430     ResourceMark rm(THREAD);
3431     int sig_len = type-&gt;utf8_length() + 3; // &quot;()&quot; and null char
3432     char* sig = NEW_RESOURCE_ARRAY(char, sig_len);
3433     jio_snprintf(sig, sig_len, &quot;%c%c%s&quot;, JVM_SIGNATURE_FUNC, JVM_SIGNATURE_ENDFUNC, type-&gt;as_C_string());
3434     TempNewSymbol full_sig = SymbolTable::new_symbol(sig);
3435     accessor_method = holder-&gt;find_instance_method(name, full_sig);
3436   }
3437 
3438   if (accessor_method != NULL) {
3439     methodHandle method(THREAD, accessor_method);
3440     oop m = Reflection::new_method(method, false, CHECK_NULL);
3441     java_lang_reflect_RecordComponent::set_accessor(element(), m);
3442   } else {
3443     java_lang_reflect_RecordComponent::set_accessor(element(), NULL);
3444   }
3445 
3446   int sig_index = component-&gt;generic_signature_index();
3447   if (sig_index &gt; 0) {
3448     Symbol* sig = holder-&gt;constants()-&gt;symbol_at(sig_index); // sig_index is a utf8
3449     oop component_sig = StringTable::intern(sig, CHECK_NULL);
3450     java_lang_reflect_RecordComponent::set_signature(element(), component_sig);
3451   } else {
3452     java_lang_reflect_RecordComponent::set_signature(element(), NULL);
3453   }
3454 
3455   typeArrayOop annotation_oop = Annotations::make_java_array(component-&gt;annotations(), CHECK_NULL);
3456   java_lang_reflect_RecordComponent::set_annotations(element(), annotation_oop);
3457 
3458   typeArrayOop type_annotation_oop = Annotations::make_java_array(component-&gt;type_annotations(), CHECK_NULL);
3459   java_lang_reflect_RecordComponent::set_typeAnnotations(element(), type_annotation_oop);
3460 
3461   return element();
3462 }
3463 
3464 #define CONSTANTPOOL_FIELDS_DO(macro) \
3465   macro(_oop_offset, k, &quot;constantPoolOop&quot;, object_signature, false)
3466 
3467 void reflect_ConstantPool::compute_offsets() {
3468   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3469   // The field is called ConstantPool* in the sun.reflect.ConstantPool class.
3470   CONSTANTPOOL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3471 }
3472 
3473 #if INCLUDE_CDS
3474 void reflect_ConstantPool::serialize_offsets(SerializeClosure* f) {
3475   CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3476 }
3477 #endif
3478 
3479 #define PARAMETER_FIELDS_DO(macro) \
3480   macro(name_offset,        k, vmSymbols::name_name(),        string_signature, false); \
3481   macro(modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \
3482   macro(index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \
3483   macro(executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)
3484 
3485 void java_lang_reflect_Parameter::compute_offsets() {
3486   InstanceKlass* k = SystemDictionary::reflect_Parameter_klass();
3487   PARAMETER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3488 }
3489 
3490 #if INCLUDE_CDS
3491 void java_lang_reflect_Parameter::serialize_offsets(SerializeClosure* f) {
3492   PARAMETER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3493 }
3494 #endif
3495 
3496 Handle java_lang_reflect_Parameter::create(TRAPS) {
3497   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3498   Symbol* name = vmSymbols::java_lang_reflect_Parameter();
3499   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3500   InstanceKlass* ik = InstanceKlass::cast(k);
3501   // Ensure it is initialized
3502   ik-&gt;initialize(CHECK_NH);
3503   return ik-&gt;allocate_instance_handle(THREAD);
3504 }
3505 
3506 oop java_lang_reflect_Parameter::name(oop param) {
3507   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3508   return param-&gt;obj_field(name_offset);
3509 }
3510 
3511 void java_lang_reflect_Parameter::set_name(oop param, oop value) {
3512   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3513   param-&gt;obj_field_put(name_offset, value);
3514 }
3515 
3516 int java_lang_reflect_Parameter::modifiers(oop param) {
3517   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3518   return param-&gt;int_field(modifiers_offset);
3519 }
3520 
3521 void java_lang_reflect_Parameter::set_modifiers(oop param, int value) {
3522   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3523   param-&gt;int_field_put(modifiers_offset, value);
3524 }
3525 
3526 int java_lang_reflect_Parameter::index(oop param) {
3527   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3528   return param-&gt;int_field(index_offset);
3529 }
3530 
3531 void java_lang_reflect_Parameter::set_index(oop param, int value) {
3532   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3533   param-&gt;int_field_put(index_offset, value);
3534 }
3535 
3536 oop java_lang_reflect_Parameter::executable(oop param) {
3537   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3538   return param-&gt;obj_field(executable_offset);
3539 }
3540 
3541 void java_lang_reflect_Parameter::set_executable(oop param, oop value) {
3542   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3543   param-&gt;obj_field_put(executable_offset, value);
3544 }
3545 
3546 
3547 int java_lang_Module::loader_offset;
3548 int java_lang_Module::name_offset;
3549 int java_lang_Module::_module_entry_offset = -1;
3550 
3551 Handle java_lang_Module::create(Handle loader, Handle module_name, TRAPS) {
3552   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3553   return JavaCalls::construct_new_instance(SystemDictionary::Module_klass(),
3554                           vmSymbols::java_lang_module_init_signature(),
3555                           loader, module_name, CHECK_NH);
3556 }
3557 
3558 #define MODULE_FIELDS_DO(macro) \
3559   macro(loader_offset,  k, vmSymbols::loader_name(),  classloader_signature, false); \
3560   macro(name_offset,    k, vmSymbols::name_name(),    string_signature,      false)
3561 
3562 void java_lang_Module::compute_offsets() {
3563   InstanceKlass* k = SystemDictionary::Module_klass();
3564   MODULE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3565   MODULE_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3566 }
3567 
3568 #if INCLUDE_CDS
3569 void java_lang_Module::serialize_offsets(SerializeClosure* f) {
3570   MODULE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3571   MODULE_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3572 }
3573 #endif
3574 
3575 oop java_lang_Module::loader(oop module) {
3576   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3577   return module-&gt;obj_field(loader_offset);
3578 }
3579 
3580 void java_lang_Module::set_loader(oop module, oop value) {
3581   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3582   module-&gt;obj_field_put(loader_offset, value);
3583 }
3584 
3585 oop java_lang_Module::name(oop module) {
3586   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3587   return module-&gt;obj_field(name_offset);
3588 }
3589 
3590 void java_lang_Module::set_name(oop module, oop value) {
3591   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3592   module-&gt;obj_field_put(name_offset, value);
3593 }
3594 
3595 ModuleEntry* java_lang_Module::module_entry(oop module) {
3596   assert(_module_entry_offset != -1, &quot;Uninitialized module_entry_offset&quot;);
3597   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3598   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3599 
3600   ModuleEntry* module_entry = (ModuleEntry*)module-&gt;address_field(_module_entry_offset);
3601   if (module_entry == NULL) {
3602     // If the inject field containing the ModuleEntry* is null then return the
3603     // class loader&#39;s unnamed module.
3604     oop loader = java_lang_Module::loader(module);
3605     Handle h_loader = Handle(Thread::current(), loader);
3606     ClassLoaderData* loader_cld = SystemDictionary::register_loader(h_loader);
3607     return loader_cld-&gt;unnamed_module();
3608   }
3609   return module_entry;
3610 }
3611 
3612 void java_lang_Module::set_module_entry(oop module, ModuleEntry* module_entry) {
3613   assert(_module_entry_offset != -1, &quot;Uninitialized module_entry_offset&quot;);
3614   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3615   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3616   module-&gt;address_field_put(_module_entry_offset, (address)module_entry);
3617 }
3618 
3619 Handle reflect_ConstantPool::create(TRAPS) {
3620   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3621   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3622   // Ensure it is initialized
3623   k-&gt;initialize(CHECK_NH);
3624   return k-&gt;allocate_instance_handle(THREAD);
3625 }
3626 
3627 
3628 void reflect_ConstantPool::set_cp(oop reflect, ConstantPool* value) {
3629   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3630   oop mirror = value-&gt;pool_holder()-&gt;java_mirror();
3631   // Save the mirror to get back the constant pool.
3632   reflect-&gt;obj_field_put(_oop_offset, mirror);
3633 }
3634 
3635 ConstantPool* reflect_ConstantPool::get_cp(oop reflect) {
3636   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3637 
3638   oop mirror = reflect-&gt;obj_field(_oop_offset);
3639   Klass* k = java_lang_Class::as_Klass(mirror);
3640   assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
3641 
3642   // Get the constant pool back from the klass.  Since class redefinition
3643   // merges the new constant pool into the old, this is essentially the
3644   // same constant pool as the original.  If constant pool merging is
3645   // no longer done in the future, this will have to change to save
3646   // the original.
3647   return InstanceKlass::cast(k)-&gt;constants();
3648 }
3649 
3650 #define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \
3651   macro(_base_offset, k, &quot;base&quot;, object_signature, false)
3652 
3653 void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
3654   InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
3655   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3656 }
3657 
3658 #if INCLUDE_CDS
3659 void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {
3660   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3661 }
3662 #endif
3663 
3664 oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
3665   Klass* k = SystemDictionary::box_klass(type);
3666   if (k == NULL)  return NULL;
3667   InstanceKlass* ik = InstanceKlass::cast(k);
3668   if (!ik-&gt;is_initialized())  ik-&gt;initialize(CHECK_NULL);
3669   return ik-&gt;allocate_instance(THREAD);
3670 }
3671 
3672 
3673 oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
3674   oop box = initialize_and_allocate(type, CHECK_NULL);
3675   if (box == NULL)  return NULL;
3676   switch (type) {
3677     case T_BOOLEAN:
3678       box-&gt;bool_field_put(value_offset, value-&gt;z);
3679       break;
3680     case T_CHAR:
3681       box-&gt;char_field_put(value_offset, value-&gt;c);
3682       break;
3683     case T_FLOAT:
3684       box-&gt;float_field_put(value_offset, value-&gt;f);
3685       break;
3686     case T_DOUBLE:
3687       box-&gt;double_field_put(long_value_offset, value-&gt;d);
3688       break;
3689     case T_BYTE:
3690       box-&gt;byte_field_put(value_offset, value-&gt;b);
3691       break;
3692     case T_SHORT:
3693       box-&gt;short_field_put(value_offset, value-&gt;s);
3694       break;
3695     case T_INT:
3696       box-&gt;int_field_put(value_offset, value-&gt;i);
3697       break;
3698     case T_LONG:
3699       box-&gt;long_field_put(long_value_offset, value-&gt;j);
3700       break;
3701     default:
3702       return NULL;
3703   }
3704   return box;
3705 }
3706 
3707 
3708 BasicType java_lang_boxing_object::basic_type(oop box) {
3709   if (box == NULL)  return T_ILLEGAL;
3710   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3711   if (type == T_OBJECT)         // &#39;unknown&#39; value returned by SD::bkt
3712     return T_ILLEGAL;
3713   return type;
3714 }
3715 
3716 
3717 BasicType java_lang_boxing_object::get_value(oop box, jvalue* value) {
3718   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3719   switch (type) {
3720   case T_BOOLEAN:
3721     value-&gt;z = box-&gt;bool_field(value_offset);
3722     break;
3723   case T_CHAR:
3724     value-&gt;c = box-&gt;char_field(value_offset);
3725     break;
3726   case T_FLOAT:
3727     value-&gt;f = box-&gt;float_field(value_offset);
3728     break;
3729   case T_DOUBLE:
3730     value-&gt;d = box-&gt;double_field(long_value_offset);
3731     break;
3732   case T_BYTE:
3733     value-&gt;b = box-&gt;byte_field(value_offset);
3734     break;
3735   case T_SHORT:
3736     value-&gt;s = box-&gt;short_field(value_offset);
3737     break;
3738   case T_INT:
3739     value-&gt;i = box-&gt;int_field(value_offset);
3740     break;
3741   case T_LONG:
3742     value-&gt;j = box-&gt;long_field(long_value_offset);
3743     break;
3744   default:
3745     return T_ILLEGAL;
3746   } // end switch
3747   return type;
3748 }
3749 
3750 
3751 BasicType java_lang_boxing_object::set_value(oop box, jvalue* value) {
3752   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3753   switch (type) {
3754   case T_BOOLEAN:
3755     box-&gt;bool_field_put(value_offset, value-&gt;z);
3756     break;
3757   case T_CHAR:
3758     box-&gt;char_field_put(value_offset, value-&gt;c);
3759     break;
3760   case T_FLOAT:
3761     box-&gt;float_field_put(value_offset, value-&gt;f);
3762     break;
3763   case T_DOUBLE:
3764     box-&gt;double_field_put(long_value_offset, value-&gt;d);
3765     break;
3766   case T_BYTE:
3767     box-&gt;byte_field_put(value_offset, value-&gt;b);
3768     break;
3769   case T_SHORT:
3770     box-&gt;short_field_put(value_offset, value-&gt;s);
3771     break;
3772   case T_INT:
3773     box-&gt;int_field_put(value_offset, value-&gt;i);
3774     break;
3775   case T_LONG:
3776     box-&gt;long_field_put(long_value_offset, value-&gt;j);
3777     break;
3778   default:
3779     return T_ILLEGAL;
3780   } // end switch
3781   return type;
3782 }
3783 
3784 
3785 void java_lang_boxing_object::print(BasicType type, jvalue* value, outputStream* st) {
3786   switch (type) {
3787   case T_BOOLEAN:   st-&gt;print(&quot;%s&quot;, value-&gt;z ? &quot;true&quot; : &quot;false&quot;);   break;
3788   case T_CHAR:      st-&gt;print(&quot;%d&quot;, value-&gt;c);                      break;
3789   case T_BYTE:      st-&gt;print(&quot;%d&quot;, value-&gt;b);                      break;
3790   case T_SHORT:     st-&gt;print(&quot;%d&quot;, value-&gt;s);                      break;
3791   case T_INT:       st-&gt;print(&quot;%d&quot;, value-&gt;i);                      break;
3792   case T_LONG:      st-&gt;print(JLONG_FORMAT, value-&gt;j);              break;
3793   case T_FLOAT:     st-&gt;print(&quot;%f&quot;, value-&gt;f);                      break;
3794   case T_DOUBLE:    st-&gt;print(&quot;%lf&quot;, value-&gt;d);                     break;
3795   default:          st-&gt;print(&quot;type %d?&quot;, type);                    break;
3796   }
3797 }
3798 
3799 // Support for java_lang_ref_Reference
3800 
3801 bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {
3802   assert(obj != NULL, &quot;sanity&quot;);
3803   if (offset != java_lang_ref_Reference::referent_offset) {
3804     return false;
3805   }
3806 
3807   Klass* k = obj-&gt;klass();
3808   if (!k-&gt;is_instance_klass()) {
3809     return false;
3810   }
3811 
3812   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());
3813   bool is_reference = ik-&gt;reference_type() != REF_NONE;
3814   assert(!is_reference || ik-&gt;is_subclass_of(SystemDictionary::Reference_klass()), &quot;sanity&quot;);
3815   return is_reference;
3816 }
3817 
3818 // Support for java_lang_ref_SoftReference
3819 //
3820 
3821 #define SOFTREFERENCE_FIELDS_DO(macro) \
3822   macro(timestamp_offset,    k, &quot;timestamp&quot;, long_signature, false); \
3823   macro(static_clock_offset, k, &quot;clock&quot;,     long_signature, true)
3824 
3825 void java_lang_ref_SoftReference::compute_offsets() {
3826   InstanceKlass* k = SystemDictionary::SoftReference_klass();
3827   SOFTREFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3828 }
3829 
3830 #if INCLUDE_CDS
3831 void java_lang_ref_SoftReference::serialize_offsets(SerializeClosure* f) {
3832   SOFTREFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3833 }
3834 #endif
3835 
3836 jlong java_lang_ref_SoftReference::timestamp(oop ref) {
3837   return ref-&gt;long_field(timestamp_offset);
3838 }
3839 
3840 jlong java_lang_ref_SoftReference::clock() {
3841   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3842   oop base = ik-&gt;static_field_base_raw();
3843   return base-&gt;long_field(static_clock_offset);
3844 }
3845 
3846 void java_lang_ref_SoftReference::set_clock(jlong value) {
3847   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3848   oop base = ik-&gt;static_field_base_raw();
3849   base-&gt;long_field_put(static_clock_offset, value);
3850 }
3851 
3852 // Support for java_lang_invoke_DirectMethodHandle
3853 
3854 int java_lang_invoke_DirectMethodHandle::_member_offset;
3855 
3856 oop java_lang_invoke_DirectMethodHandle::member(oop dmh) {
3857   oop member_name = NULL;
3858   assert(oopDesc::is_oop(dmh) &amp;&amp; java_lang_invoke_DirectMethodHandle::is_instance(dmh),
3859          &quot;a DirectMethodHandle oop is expected&quot;);
3860   return dmh-&gt;obj_field(member_offset_in_bytes());
3861 }
3862 
3863 #define DIRECTMETHODHANDLE_FIELDS_DO(macro) \
3864   macro(_member_offset, k, &quot;member&quot;, java_lang_invoke_MemberName_signature, false)
3865 
3866 void java_lang_invoke_DirectMethodHandle::compute_offsets() {
3867   InstanceKlass* k = SystemDictionary::DirectMethodHandle_klass();
3868   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3869 }
3870 
3871 #if INCLUDE_CDS
3872 void java_lang_invoke_DirectMethodHandle::serialize_offsets(SerializeClosure* f) {
3873   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3874 }
3875 #endif
3876 
3877 // Support for java_lang_invoke_MethodHandle
3878 
3879 int java_lang_invoke_MethodHandle::_type_offset;
3880 int java_lang_invoke_MethodHandle::_form_offset;
3881 
3882 int java_lang_invoke_MemberName::_clazz_offset;
3883 int java_lang_invoke_MemberName::_name_offset;
3884 int java_lang_invoke_MemberName::_type_offset;
3885 int java_lang_invoke_MemberName::_flags_offset;
3886 int java_lang_invoke_MemberName::_method_offset;
3887 int java_lang_invoke_MemberName::_vmindex_offset;
3888 
3889 int java_lang_invoke_ResolvedMethodName::_vmtarget_offset;
3890 int java_lang_invoke_ResolvedMethodName::_vmholder_offset;
3891 
3892 int java_lang_invoke_LambdaForm::_vmentry_offset;
3893 
3894 #define METHODHANDLE_FIELDS_DO(macro) \
3895   macro(_type_offset, k, vmSymbols::type_name(), java_lang_invoke_MethodType_signature, false); \
3896   macro(_form_offset, k, &quot;form&quot;,                 java_lang_invoke_LambdaForm_signature, false)
3897 
3898 void java_lang_invoke_MethodHandle::compute_offsets() {
3899   InstanceKlass* k = SystemDictionary::MethodHandle_klass();
3900   METHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3901 }
3902 
3903 #if INCLUDE_CDS
3904 void java_lang_invoke_MethodHandle::serialize_offsets(SerializeClosure* f) {
3905   METHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3906 }
3907 #endif
3908 
3909 #define MEMBERNAME_FIELDS_DO(macro) \
3910   macro(_clazz_offset,   k, vmSymbols::clazz_name(),   class_signature,  false); \
3911   macro(_name_offset,    k, vmSymbols::name_name(),    string_signature, false); \
3912   macro(_type_offset,    k, vmSymbols::type_name(),    object_signature, false); \
3913   macro(_flags_offset,   k, vmSymbols::flags_name(),   int_signature,    false); \
3914   macro(_method_offset,  k, vmSymbols::method_name(),  java_lang_invoke_ResolvedMethodName_signature, false)
3915 
3916 void java_lang_invoke_MemberName::compute_offsets() {
3917   InstanceKlass* k = SystemDictionary::MemberName_klass();
3918   MEMBERNAME_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3919   MEMBERNAME_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3920 }
3921 
3922 #if INCLUDE_CDS
3923 void java_lang_invoke_MemberName::serialize_offsets(SerializeClosure* f) {
3924   MEMBERNAME_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3925   MEMBERNAME_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3926 }
3927 #endif
3928 
3929 void java_lang_invoke_ResolvedMethodName::compute_offsets() {
3930   InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();
3931   assert(k != NULL, &quot;jdk mismatch&quot;);
3932   RESOLVEDMETHOD_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3933 }
3934 
3935 #if INCLUDE_CDS
3936 void java_lang_invoke_ResolvedMethodName::serialize_offsets(SerializeClosure* f) {
3937   RESOLVEDMETHOD_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3938 }
3939 #endif
3940 
3941 #define LAMBDAFORM_FIELDS_DO(macro) \
3942   macro(_vmentry_offset, k, &quot;vmentry&quot;, java_lang_invoke_MemberName_signature, false)
3943 
3944 void java_lang_invoke_LambdaForm::compute_offsets() {
3945   InstanceKlass* k = SystemDictionary::LambdaForm_klass();
3946   assert (k != NULL, &quot;jdk mismatch&quot;);
3947   LAMBDAFORM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3948 }
3949 
3950 #if INCLUDE_CDS
3951 void java_lang_invoke_LambdaForm::serialize_offsets(SerializeClosure* f) {
3952   LAMBDAFORM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3953 }
3954 #endif
3955 
3956 bool java_lang_invoke_LambdaForm::is_instance(oop obj) {
3957   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
3958 }
3959 
3960 
3961 oop java_lang_invoke_MethodHandle::type(oop mh) {
3962   return mh-&gt;obj_field(_type_offset);
3963 }
3964 
3965 void java_lang_invoke_MethodHandle::set_type(oop mh, oop mtype) {
3966   mh-&gt;obj_field_put(_type_offset, mtype);
3967 }
3968 
3969 oop java_lang_invoke_MethodHandle::form(oop mh) {
3970   assert(_form_offset != 0, &quot;&quot;);
3971   return mh-&gt;obj_field(_form_offset);
3972 }
3973 
3974 void java_lang_invoke_MethodHandle::set_form(oop mh, oop lform) {
3975   assert(_form_offset != 0, &quot;&quot;);
3976   mh-&gt;obj_field_put(_form_offset, lform);
3977 }
3978 
3979 /// MemberName accessors
3980 
3981 oop java_lang_invoke_MemberName::clazz(oop mname) {
3982   assert(is_instance(mname), &quot;wrong type&quot;);
3983   return mname-&gt;obj_field(_clazz_offset);
3984 }
3985 
3986 void java_lang_invoke_MemberName::set_clazz(oop mname, oop clazz) {
3987   assert(is_instance(mname), &quot;wrong type&quot;);
3988   mname-&gt;obj_field_put(_clazz_offset, clazz);
3989 }
3990 
3991 oop java_lang_invoke_MemberName::name(oop mname) {
3992   assert(is_instance(mname), &quot;wrong type&quot;);
3993   return mname-&gt;obj_field(_name_offset);
3994 }
3995 
3996 void java_lang_invoke_MemberName::set_name(oop mname, oop name) {
3997   assert(is_instance(mname), &quot;wrong type&quot;);
3998   mname-&gt;obj_field_put(_name_offset, name);
3999 }
4000 
4001 oop java_lang_invoke_MemberName::type(oop mname) {
4002   assert(is_instance(mname), &quot;wrong type&quot;);
4003   return mname-&gt;obj_field(_type_offset);
4004 }
4005 
4006 void java_lang_invoke_MemberName::set_type(oop mname, oop type) {
4007   assert(is_instance(mname), &quot;wrong type&quot;);
4008   mname-&gt;obj_field_put(_type_offset, type);
4009 }
4010 
4011 int java_lang_invoke_MemberName::flags(oop mname) {
4012   assert(is_instance(mname), &quot;wrong type&quot;);
4013   return mname-&gt;int_field(_flags_offset);
4014 }
4015 
4016 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
4017   assert(is_instance(mname), &quot;wrong type&quot;);
4018   mname-&gt;int_field_put(_flags_offset, flags);
4019 }
4020 
4021 
4022 // Return vmtarget from ResolvedMethodName method field through indirection
4023 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
4024   assert(is_instance(mname), &quot;wrong type&quot;);
4025   oop method = mname-&gt;obj_field(_method_offset);
4026   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
4027 }
4028 
4029 bool java_lang_invoke_MemberName::is_method(oop mname) {
4030   assert(is_instance(mname), &quot;must be MemberName&quot;);
4031   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_CONSTRUCTOR)) &gt; 0;
4032 }
4033 
4034 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
4035   assert(is_instance(mname), &quot;wrong type&quot;);
4036   mname-&gt;obj_field_put(_method_offset, resolved_method);
4037 }
4038 
4039 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
4040   assert(is_instance(mname), &quot;wrong type&quot;);
4041   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
4042 }
4043 
4044 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
4045   assert(is_instance(mname), &quot;wrong type&quot;);
4046   mname-&gt;address_field_put(_vmindex_offset, (address) index);
4047 }
4048 
4049 
4050 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
4051   assert(is_instance(resolved_method), &quot;wrong type&quot;);
4052   Method* m = (Method*)resolved_method-&gt;address_field(_vmtarget_offset);
4053   assert(m-&gt;is_method(), &quot;must be&quot;);
4054   return m;
4055 }
4056 
4057 // Used by redefinition to change Method* to new Method* with same hash (name, signature)
4058 void java_lang_invoke_ResolvedMethodName::set_vmtarget(oop resolved_method, Method* m) {
4059   assert(is_instance(resolved_method), &quot;wrong type&quot;);
4060   resolved_method-&gt;address_field_put(_vmtarget_offset, (address)m);
4061 }
4062 
4063 void java_lang_invoke_ResolvedMethodName::set_vmholder(oop resolved_method, oop holder) {
4064   assert(is_instance(resolved_method), &quot;wrong type&quot;);
4065   resolved_method-&gt;obj_field_put(_vmholder_offset, holder);
4066 }
4067 
4068 oop java_lang_invoke_ResolvedMethodName::find_resolved_method(const methodHandle&amp; m, TRAPS) {
4069   const Method* method = m();
4070 
4071   // lookup ResolvedMethod oop in the table, or create a new one and intern it
4072   oop resolved_method = ResolvedMethodTable::find_method(method);
4073   if (resolved_method != NULL) {
4074     return resolved_method;
4075   }
4076 
4077   InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();
4078   if (!k-&gt;is_initialized()) {
4079     k-&gt;initialize(CHECK_NULL);
4080   }
4081 
4082   oop new_resolved_method = k-&gt;allocate_instance(CHECK_NULL);
4083 
4084   NoSafepointVerifier nsv;
4085 
4086   if (method-&gt;is_old()) {
4087     method = (method-&gt;is_deleted()) ? Universe::throw_no_such_method_error() :
4088                                       method-&gt;get_new_method();
4089   }
4090 
4091   InstanceKlass* holder = method-&gt;method_holder();
4092 
4093   set_vmtarget(new_resolved_method, const_cast&lt;Method*&gt;(method));
4094   // Add a reference to the loader (actually mirror because unsafe anonymous classes will not have
4095   // distinct loaders) to ensure the metadata is kept alive.
4096   // This mirror may be different than the one in clazz field.
4097   set_vmholder(new_resolved_method, holder-&gt;java_mirror());
4098 
4099   // Set flag in class to indicate this InstanceKlass has entries in the table
4100   // to avoid walking table during redefinition if none of the redefined classes
4101   // have any membernames in the table.
4102   holder-&gt;set_has_resolved_methods();
4103 
4104   return ResolvedMethodTable::add_method(method, Handle(THREAD, new_resolved_method));
4105 }
4106 
4107 oop java_lang_invoke_LambdaForm::vmentry(oop lform) {
4108   assert(is_instance(lform), &quot;wrong type&quot;);
4109   return lform-&gt;obj_field(_vmentry_offset);
4110 }
4111 
4112 
4113 // Support for java_lang_invoke_MethodType
4114 
4115 int java_lang_invoke_MethodType::_rtype_offset;
4116 int java_lang_invoke_MethodType::_ptypes_offset;
4117 
4118 #define METHODTYPE_FIELDS_DO(macro) \
4119   macro(_rtype_offset,  k, &quot;rtype&quot;,  class_signature,       false); \
4120   macro(_ptypes_offset, k, &quot;ptypes&quot;, class_array_signature, false)
4121 
4122 void java_lang_invoke_MethodType::compute_offsets() {
4123   InstanceKlass* k = SystemDictionary::MethodType_klass();
4124   METHODTYPE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4125 }
4126 
4127 #if INCLUDE_CDS
4128 void java_lang_invoke_MethodType::serialize_offsets(SerializeClosure* f) {
4129   METHODTYPE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4130 }
4131 #endif
4132 
4133 void java_lang_invoke_MethodType::print_signature(oop mt, outputStream* st) {
4134   st-&gt;print(&quot;(&quot;);
4135   objArrayOop pts = ptypes(mt);
4136   for (int i = 0, limit = pts-&gt;length(); i &lt; limit; i++) {
4137     java_lang_Class::print_signature(pts-&gt;obj_at(i), st);
4138   }
4139   st-&gt;print(&quot;)&quot;);
4140   java_lang_Class::print_signature(rtype(mt), st);
4141 }
4142 
4143 Symbol* java_lang_invoke_MethodType::as_signature(oop mt, bool intern_if_not_found) {
4144   ResourceMark rm;
4145   stringStream buffer(128);
4146   print_signature(mt, &amp;buffer);
4147   const char* sigstr =       buffer.base();
4148   int         siglen = (int) buffer.size();
4149   Symbol *name;
4150   if (!intern_if_not_found) {
4151     name = SymbolTable::probe(sigstr, siglen);
4152   } else {
4153     name = SymbolTable::new_symbol(sigstr, siglen);
4154   }
4155   return name;
4156 }
4157 
4158 bool java_lang_invoke_MethodType::equals(oop mt1, oop mt2) {
4159   if (mt1 == mt2)
4160     return true;
4161   if (rtype(mt1) != rtype(mt2))
4162     return false;
4163   if (ptype_count(mt1) != ptype_count(mt2))
4164     return false;
4165   for (int i = ptype_count(mt1) - 1; i &gt;= 0; i--) {
4166     if (ptype(mt1, i) != ptype(mt2, i))
4167       return false;
4168   }
4169   return true;
4170 }
4171 
4172 oop java_lang_invoke_MethodType::rtype(oop mt) {
4173   assert(is_instance(mt), &quot;must be a MethodType&quot;);
4174   return mt-&gt;obj_field(_rtype_offset);
4175 }
4176 
4177 objArrayOop java_lang_invoke_MethodType::ptypes(oop mt) {
4178   assert(is_instance(mt), &quot;must be a MethodType&quot;);
4179   return (objArrayOop) mt-&gt;obj_field(_ptypes_offset);
4180 }
4181 
4182 oop java_lang_invoke_MethodType::ptype(oop mt, int idx) {
4183   return ptypes(mt)-&gt;obj_at(idx);
4184 }
4185 
4186 int java_lang_invoke_MethodType::ptype_count(oop mt) {
4187   return ptypes(mt)-&gt;length();
4188 }
4189 
4190 int java_lang_invoke_MethodType::ptype_slot_count(oop mt) {
4191   objArrayOop pts = ptypes(mt);
4192   int count = pts-&gt;length();
4193   int slots = 0;
4194   for (int i = 0; i &lt; count; i++) {
4195     BasicType bt = java_lang_Class::as_BasicType(pts-&gt;obj_at(i));
4196     slots += type2size[bt];
4197   }
4198   return slots;
4199 }
4200 
4201 int java_lang_invoke_MethodType::rtype_slot_count(oop mt) {
4202   BasicType bt = java_lang_Class::as_BasicType(rtype(mt));
4203   return type2size[bt];
4204 }
4205 
4206 
4207 // Support for java_lang_invoke_CallSite
4208 
4209 int java_lang_invoke_CallSite::_target_offset;
4210 int java_lang_invoke_CallSite::_context_offset;
4211 
4212 #define CALLSITE_FIELDS_DO(macro) \
4213   macro(_target_offset,  k, &quot;target&quot;, java_lang_invoke_MethodHandle_signature, false); \
4214   macro(_context_offset, k, &quot;context&quot;, java_lang_invoke_MethodHandleNatives_CallSiteContext_signature, false)
4215 
4216 void java_lang_invoke_CallSite::compute_offsets() {
4217   InstanceKlass* k = SystemDictionary::CallSite_klass();
4218   CALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4219 }
4220 
4221 #if INCLUDE_CDS
4222 void java_lang_invoke_CallSite::serialize_offsets(SerializeClosure* f) {
4223   CALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4224 }
4225 #endif
4226 
4227 oop java_lang_invoke_CallSite::context_no_keepalive(oop call_site) {
4228   assert(java_lang_invoke_CallSite::is_instance(call_site), &quot;&quot;);
4229 
4230   oop dep_oop = call_site-&gt;obj_field_access&lt;AS_NO_KEEPALIVE&gt;(_context_offset);
4231   return dep_oop;
4232 }
4233 
4234 // Support for java_lang_invoke_ConstantCallSite
4235 
4236 int java_lang_invoke_ConstantCallSite::_is_frozen_offset;
4237 
4238 #define CONSTANTCALLSITE_FIELDS_DO(macro) \
4239   macro(_is_frozen_offset, k, &quot;isFrozen&quot;, bool_signature, false)
4240 
4241 void java_lang_invoke_ConstantCallSite::compute_offsets() {
4242   InstanceKlass* k = SystemDictionary::ConstantCallSite_klass();
4243   CONSTANTCALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4244 }
4245 
4246 #if INCLUDE_CDS
4247 void java_lang_invoke_ConstantCallSite::serialize_offsets(SerializeClosure* f) {
4248   CONSTANTCALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4249 }
4250 #endif
4251 
4252 // Support for java_lang_invoke_MethodHandleNatives_CallSiteContext
4253 
4254 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_vmdependencies_offset;
4255 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_last_cleanup_offset;
4256 
4257 void java_lang_invoke_MethodHandleNatives_CallSiteContext::compute_offsets() {
4258   InstanceKlass* k = SystemDictionary::Context_klass();
4259   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4260 }
4261 
4262 #if INCLUDE_CDS
4263 void java_lang_invoke_MethodHandleNatives_CallSiteContext::serialize_offsets(SerializeClosure* f) {
4264   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4265 }
4266 #endif
4267 
4268 DependencyContext java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(oop call_site) {
4269   assert(java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(call_site), &quot;&quot;);
4270   nmethodBucket* volatile* vmdeps_addr = (nmethodBucket* volatile*)call_site-&gt;field_addr(_vmdependencies_offset);
4271   volatile uint64_t* last_cleanup_addr = (volatile uint64_t*)call_site-&gt;field_addr(_last_cleanup_offset);
4272   DependencyContext dep_ctx(vmdeps_addr, last_cleanup_addr);
4273   return dep_ctx;
4274 }
4275 
4276 // Support for java_security_AccessControlContext
4277 
4278 int java_security_AccessControlContext::_context_offset = 0;
4279 int java_security_AccessControlContext::_privilegedContext_offset = 0;
4280 int java_security_AccessControlContext::_isPrivileged_offset = 0;
4281 int java_security_AccessControlContext::_isAuthorized_offset = -1;
4282 
4283 #define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \
4284   macro(_context_offset,           k, &quot;context&quot;,      protectiondomain_signature, false); \
4285   macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
4286   macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
4287   macro(_isAuthorized_offset,      k, &quot;isAuthorized&quot;, bool_signature, false)
4288 
4289 void java_security_AccessControlContext::compute_offsets() {
4290   assert(_isPrivileged_offset == 0, &quot;offsets should be initialized only once&quot;);
4291   InstanceKlass* k = SystemDictionary::AccessControlContext_klass();
4292   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4293 }
4294 
4295 #if INCLUDE_CDS
4296 void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {
4297   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4298 }
4299 #endif
4300 
4301 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
4302   assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
4303   assert(_isAuthorized_offset != -1, &quot;offsets should have been initialized&quot;);
4304   // Ensure klass is initialized
4305   SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_NULL);
4306   // Allocate result
4307   oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_NULL);
4308   // Fill in values
4309   result-&gt;obj_field_put(_context_offset, context());
4310   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
4311   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
4312   // whitelist AccessControlContexts created by the JVM
4313   result-&gt;bool_field_put(_isAuthorized_offset, true);
4314   return result;
4315 }
4316 
4317 
4318 // Support for java_lang_ClassLoader
4319 
4320 bool java_lang_ClassLoader::offsets_computed = false;
4321 int  java_lang_ClassLoader::_loader_data_offset = -1;
4322 int  java_lang_ClassLoader::parallelCapable_offset = -1;
4323 int  java_lang_ClassLoader::name_offset = -1;
4324 int  java_lang_ClassLoader::nameAndId_offset = -1;
4325 int  java_lang_ClassLoader::unnamedModule_offset = -1;
4326 
4327 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
4328   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4329   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4330   return HeapAccess&lt;MO_ACQUIRE&gt;::load_at(loader, _loader_data_offset);
4331 }
4332 
4333 ClassLoaderData* java_lang_ClassLoader::loader_data_raw(oop loader) {
4334   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4335   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4336   return RawAccess&lt;&gt;::load_at(loader, _loader_data_offset);
4337 }
4338 
4339 void java_lang_ClassLoader::release_set_loader_data(oop loader, ClassLoaderData* new_data) {
4340   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4341   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4342   HeapAccess&lt;MO_RELEASE&gt;::store_at(loader, _loader_data_offset, new_data);
4343 }
4344 
4345 #define CLASSLOADER_FIELDS_DO(macro) \
4346   macro(parallelCapable_offset, k1, &quot;parallelLockMap&quot;,      concurrenthashmap_signature, false); \
4347   macro(name_offset,            k1, vmSymbols::name_name(), string_signature, false); \
4348   macro(nameAndId_offset,       k1, &quot;nameAndId&quot;,            string_signature, false); \
4349   macro(unnamedModule_offset,   k1, &quot;unnamedModule&quot;,        module_signature, false); \
4350   macro(parent_offset,          k1, &quot;parent&quot;,               classloader_signature, false)
4351 
4352 void java_lang_ClassLoader::compute_offsets() {
4353   assert(!offsets_computed, &quot;offsets should be initialized only once&quot;);
4354   offsets_computed = true;
4355 
4356   InstanceKlass* k1 = SystemDictionary::ClassLoader_klass();
4357   CLASSLOADER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4358 
4359   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4360 }
4361 
4362 #if INCLUDE_CDS
4363 void java_lang_ClassLoader::serialize_offsets(SerializeClosure* f) {
4364   CLASSLOADER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4365   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4366 }
4367 #endif
4368 
4369 oop java_lang_ClassLoader::parent(oop loader) {
4370   assert(is_instance(loader), &quot;loader must be oop&quot;);
4371   return loader-&gt;obj_field(parent_offset);
4372 }
4373 
4374 // Returns the name field of this class loader.  If the name field has not
4375 // been set, null will be returned.
4376 oop java_lang_ClassLoader::name(oop loader) {
4377   assert(is_instance(loader), &quot;loader must be oop&quot;);
4378   return loader-&gt;obj_field(name_offset);
4379 }
4380 
4381 // Returns the nameAndId field of this class loader. The format is
4382 // as follows:
4383 //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
4384 //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
4385 //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
4386 // Use ClassLoader::loader_name_id() to obtain this String as a char*.
4387 oop java_lang_ClassLoader::nameAndId(oop loader) {
4388   assert(is_instance(loader), &quot;loader must be oop&quot;);
4389   return loader-&gt;obj_field(nameAndId_offset);
4390 }
4391 
4392 bool java_lang_ClassLoader::isAncestor(oop loader, oop cl) {
4393   assert(is_instance(loader), &quot;loader must be oop&quot;);
4394   assert(cl == NULL || is_instance(cl), &quot;cl argument must be oop&quot;);
4395   oop acl = loader;
4396   debug_only(jint loop_count = 0);
4397   // This loop taken verbatim from ClassLoader.java:
4398   do {
4399     acl = parent(acl);
4400     if (cl == acl) {
4401       return true;
4402     }
4403     assert(++loop_count &gt; 0, &quot;loop_count overflow&quot;);
4404   } while (acl != NULL);
4405   return false;
4406 }
4407 
4408 bool java_lang_ClassLoader::is_instance(oop obj) {
4409   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
4410 }
4411 
4412 
4413 // For class loader classes, parallelCapable defined
4414 // based on non-null field
4415 // Written to by java.lang.ClassLoader, vm only reads this field, doesn&#39;t set it
4416 bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
4417   assert(parallelCapable_offset != -1, &quot;offsets should have been initialized&quot;);
4418   return (class_loader-&gt;obj_field(parallelCapable_offset) != NULL);
4419 }
4420 
4421 bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
4422   // Fix for 4474172; see evaluation for more details
4423   loader = non_reflection_class_loader(loader);
4424 
4425   oop cl = SystemDictionary::java_system_loader();
4426   while(cl != NULL) {
4427     if (cl == loader) return true;
4428     cl = parent(cl);
4429   }
4430   return false;
4431 }
4432 
4433 // Return true if this is one of the class loaders associated with
4434 // the generated bytecodes for reflection.
4435 bool java_lang_ClassLoader::is_reflection_class_loader(oop loader) {
4436   if (loader != NULL) {
4437     Klass* delegating_cl_class = SystemDictionary::reflect_DelegatingClassLoader_klass();
4438     // This might be null in non-1.4 JDKs
4439     return (delegating_cl_class != NULL &amp;&amp; loader-&gt;is_a(delegating_cl_class));
4440   }
4441   return false;
4442 }
4443 
4444 oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {
4445   // See whether this is one of the class loaders associated with
4446   // the generated bytecodes for reflection, and if so, &quot;magically&quot;
4447   // delegate to its parent to prevent class loading from occurring
4448   // in places where applications using reflection didn&#39;t expect it.
4449   if (is_reflection_class_loader(loader)) {
4450     return parent(loader);
4451   }
4452   return loader;
4453 }
4454 
4455 oop java_lang_ClassLoader::unnamedModule(oop loader) {
4456   assert(is_instance(loader), &quot;loader must be oop&quot;);
4457   return loader-&gt;obj_field(unnamedModule_offset);
4458 }
4459 
4460 // Support for java_lang_System
4461 //
4462 #define SYSTEM_FIELDS_DO(macro) \
4463   macro(static_in_offset,  k, &quot;in&quot;,  input_stream_signature, true); \
4464   macro(static_out_offset, k, &quot;out&quot;, print_stream_signature, true); \
4465   macro(static_err_offset, k, &quot;err&quot;, print_stream_signature, true); \
4466   macro(static_security_offset, k, &quot;security&quot;, security_manager_signature, true)
4467 
4468 void java_lang_System::compute_offsets() {
4469   InstanceKlass* k = SystemDictionary::System_klass();
4470   SYSTEM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4471 }
4472 
4473 #if INCLUDE_CDS
4474 void java_lang_System::serialize_offsets(SerializeClosure* f) {
4475    SYSTEM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4476 }
4477 #endif
4478 
4479 int java_lang_System::in_offset_in_bytes() { return static_in_offset; }
4480 int java_lang_System::out_offset_in_bytes() { return static_out_offset; }
4481 int java_lang_System::err_offset_in_bytes() { return static_err_offset; }
4482 
4483 // Support for jdk_internal_misc_UnsafeConstants
4484 //
4485 class UnsafeConstantsFixup : public FieldClosure {
4486 private:
4487   int _address_size;
4488   int _page_size;
4489   bool _big_endian;
4490   bool _use_unaligned_access;
4491   int _data_cache_line_flush_size;
4492 public:
4493   UnsafeConstantsFixup() {
4494     // round up values for all static final fields
4495     _address_size = sizeof(void*);
4496     _page_size = os::vm_page_size();
4497     _big_endian = LITTLE_ENDIAN_ONLY(false) BIG_ENDIAN_ONLY(true);
4498     _use_unaligned_access = UseUnalignedAccesses;
4499     _data_cache_line_flush_size = (int)VM_Version::data_cache_line_flush_size();
4500   }
4501 
4502   void do_field(fieldDescriptor* fd) {
4503     oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
4504     assert(mirror != NULL, &quot;UnsafeConstants must have mirror already&quot;);
4505     assert(fd-&gt;field_holder() == SystemDictionary::UnsafeConstants_klass(), &quot;Should be UnsafeConstants&quot;);
4506     assert(fd-&gt;is_final(), &quot;fields of UnsafeConstants must be final&quot;);
4507     assert(fd-&gt;is_static(), &quot;fields of UnsafeConstants must be static&quot;);
4508     if (fd-&gt;name() == vmSymbols::address_size_name()) {
4509       mirror-&gt;int_field_put(fd-&gt;offset(), _address_size);
4510     } else if (fd-&gt;name() == vmSymbols::page_size_name()) {
4511       mirror-&gt;int_field_put(fd-&gt;offset(), _page_size);
4512     } else if (fd-&gt;name() == vmSymbols::big_endian_name()) {
4513       mirror-&gt;bool_field_put(fd-&gt;offset(), _big_endian);
4514     } else if (fd-&gt;name() == vmSymbols::use_unaligned_access_name()) {
4515       mirror-&gt;bool_field_put(fd-&gt;offset(), _use_unaligned_access);
4516     } else if (fd-&gt;name() == vmSymbols::data_cache_line_flush_size_name()) {
4517       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4518     } else if (fd-&gt;name() == vmSymbols::scoped_cache_shift_name()) {
4519       mirror-&gt;int_field_put(fd-&gt;offset(), ScopedCacheSize ? exact_log2(ScopedCacheSize) : -1);
4520     } else {
4521       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4522     }
4523   }
4524 };
4525 
4526 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4527   UnsafeConstantsFixup fixup;
4528   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4529 }
4530 
4531 int java_lang_Class::_klass_offset;
4532 int java_lang_Class::_array_klass_offset;
4533 int java_lang_Class::_oop_size_offset;
4534 int java_lang_Class::_static_oop_field_count_offset;
4535 int java_lang_Class::_class_loader_offset;
4536 int java_lang_Class::_module_offset;
4537 int java_lang_Class::_protection_domain_offset;
4538 int java_lang_Class::_component_mirror_offset;
4539 int java_lang_Class::_init_lock_offset;
4540 int java_lang_Class::_signers_offset;
4541 int java_lang_Class::_name_offset;
4542 int java_lang_Class::_source_file_offset;
4543 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
4544 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
4545 int java_lang_Throwable::backtrace_offset;
4546 int java_lang_Throwable::detailMessage_offset;
4547 int java_lang_Throwable::stackTrace_offset;
4548 int java_lang_Throwable::depth_offset;
4549 int java_lang_Throwable::static_unassigned_stacktrace_offset;
4550 int java_lang_reflect_AccessibleObject::override_offset;
4551 int java_lang_reflect_Method::clazz_offset;
4552 int java_lang_reflect_Method::name_offset;
4553 int java_lang_reflect_Method::returnType_offset;
4554 int java_lang_reflect_Method::parameterTypes_offset;
4555 int java_lang_reflect_Method::exceptionTypes_offset;
4556 int java_lang_reflect_Method::slot_offset;
4557 int java_lang_reflect_Method::modifiers_offset;
4558 int java_lang_reflect_Method::signature_offset;
4559 int java_lang_reflect_Method::annotations_offset;
4560 int java_lang_reflect_Method::parameter_annotations_offset;
4561 int java_lang_reflect_Method::annotation_default_offset;
4562 int java_lang_reflect_Constructor::clazz_offset;
4563 int java_lang_reflect_Constructor::parameterTypes_offset;
4564 int java_lang_reflect_Constructor::exceptionTypes_offset;
4565 int java_lang_reflect_Constructor::slot_offset;
4566 int java_lang_reflect_Constructor::modifiers_offset;
4567 int java_lang_reflect_Constructor::signature_offset;
4568 int java_lang_reflect_Constructor::annotations_offset;
4569 int java_lang_reflect_Constructor::parameter_annotations_offset;
4570 int java_lang_reflect_Field::clazz_offset;
4571 int java_lang_reflect_Field::name_offset;
4572 int java_lang_reflect_Field::type_offset;
4573 int java_lang_reflect_Field::slot_offset;
4574 int java_lang_reflect_Field::modifiers_offset;
4575 int java_lang_reflect_Field::signature_offset;
4576 int java_lang_reflect_Field::annotations_offset;
4577 int java_lang_reflect_Parameter::name_offset;
4578 int java_lang_reflect_Parameter::modifiers_offset;
4579 int java_lang_reflect_Parameter::index_offset;
4580 int java_lang_reflect_Parameter::executable_offset;
4581 int java_lang_boxing_object::value_offset;
4582 int java_lang_boxing_object::long_value_offset;
4583 int java_lang_ref_Reference::referent_offset;
4584 int java_lang_ref_Reference::queue_offset;
4585 int java_lang_ref_Reference::next_offset;
4586 int java_lang_ref_Reference::discovered_offset;
4587 int java_lang_ref_SoftReference::timestamp_offset;
4588 int java_lang_ref_SoftReference::static_clock_offset;
4589 int java_lang_ContinuationScope::_name_offset;
4590 int java_lang_Continuation::_scope_offset;
4591 int java_lang_Continuation::_target_offset;
4592 int java_lang_Continuation::_stack_offset;
4593 int java_lang_Continuation::_tail_offset;
4594 int java_lang_Continuation::_maxSize_offset;
4595 int java_lang_Continuation::_numFrames_offset;
4596 int java_lang_Continuation::_numInterpretedFrames_offset;
4597 int java_lang_Continuation::_refStack_offset;
4598 int java_lang_Continuation::_parent_offset;
4599 int java_lang_Continuation::_yieldInfo_offset;
4600 int java_lang_Continuation::_entrySP_offset;
4601 int java_lang_Continuation::_entryFP_offset;
4602 int java_lang_Continuation::_entryPC_offset;
4603 int java_lang_Continuation::_fp_offset;
4604 int java_lang_Continuation::_sp_offset;
4605 int java_lang_Continuation::_pc_offset;
4606 int java_lang_Continuation::_refSP_offset;
4607 int java_lang_Continuation::_cs_offset;
4608 int java_lang_Continuation::_flags_offset;
4609 int java_lang_Continuation::_reset_offset;
4610 int java_lang_Continuation::_mounted_offset;
4611 int java_lang_Continuation::_done_offset;
4612 int jdk_internal_misc_StackChunk::_parent_offset;
4613 int jdk_internal_misc_StackChunk::_size_offset;
4614 int jdk_internal_misc_StackChunk::_sp_offset;
4615 int jdk_internal_misc_StackChunk::_pc_offset;
4616 int jdk_internal_misc_StackChunk::_argsize_offset;
4617 int jdk_internal_misc_StackChunk::_mode_offset;
4618 int jdk_internal_misc_StackChunk::_numFrames_offset;
4619 int jdk_internal_misc_StackChunk::_numOops_offset;
4620 int jdk_internal_misc_StackChunk::_cont_offset;
4621 int java_lang_ClassLoader::parent_offset;
4622 int java_lang_System::static_in_offset;
4623 int java_lang_System::static_out_offset;
4624 int java_lang_System::static_err_offset;
4625 int java_lang_System::static_security_offset;
4626 int java_lang_StackTraceElement::methodName_offset;
4627 int java_lang_StackTraceElement::fileName_offset;
4628 int java_lang_StackTraceElement::lineNumber_offset;
4629 int java_lang_StackTraceElement::moduleName_offset;
4630 int java_lang_StackTraceElement::moduleVersion_offset;
4631 int java_lang_StackTraceElement::classLoaderName_offset;
4632 int java_lang_StackTraceElement::declaringClass_offset;
4633 int java_lang_StackTraceElement::declaringClassObject_offset;
4634 int java_lang_StackTraceElement::contScope_offset;
4635 int java_lang_StackFrameInfo::_memberName_offset;
4636 int java_lang_StackFrameInfo::_bci_offset;
4637 int java_lang_StackFrameInfo::_version_offset;
4638 int java_lang_StackFrameInfo::_contScope_offset;
4639 int java_lang_LiveStackFrameInfo::_monitors_offset;
4640 int java_lang_LiveStackFrameInfo::_locals_offset;
4641 int java_lang_LiveStackFrameInfo::_operands_offset;
4642 int java_lang_LiveStackFrameInfo::_mode_offset;
4643 int java_lang_AssertionStatusDirectives::classes_offset;
4644 int java_lang_AssertionStatusDirectives::classEnabled_offset;
4645 int java_lang_AssertionStatusDirectives::packages_offset;
4646 int java_lang_AssertionStatusDirectives::packageEnabled_offset;
4647 int java_lang_AssertionStatusDirectives::deflt_offset;
4648 int java_nio_Buffer::_limit_offset;
4649 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
4650 int reflect_ConstantPool::_oop_offset;
4651 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
4652 int java_lang_Integer_IntegerCache::_static_cache_offset;
4653 int java_lang_Long_LongCache::_static_cache_offset;
4654 int java_lang_Character_CharacterCache::_static_cache_offset;
4655 int java_lang_Short_ShortCache::_static_cache_offset;
4656 int java_lang_Byte_ByteCache::_static_cache_offset;
4657 int java_lang_Boolean::_static_TRUE_offset;
4658 int java_lang_Boolean::_static_FALSE_offset;
4659 int java_lang_reflect_RecordComponent::clazz_offset;
4660 int java_lang_reflect_RecordComponent::name_offset;
4661 int java_lang_reflect_RecordComponent::type_offset;
4662 int java_lang_reflect_RecordComponent::accessor_offset;
4663 int java_lang_reflect_RecordComponent::signature_offset;
4664 int java_lang_reflect_RecordComponent::annotations_offset;
4665 int java_lang_reflect_RecordComponent::typeAnnotations_offset;
4666 
4667 
4668 
4669 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
4670   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
4671   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
4672   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \
4673   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \
4674   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \
4675   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \
4676   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \
4677   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false); \
4678   macro(contScope_offset,       k, &quot;contScopeName&quot;,   string_signature, false)
4679 
4680 // Support for java_lang_StackTraceElement
4681 void java_lang_StackTraceElement::compute_offsets() {
4682   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4683   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4684 }
4685 
4686 #if INCLUDE_CDS
4687 void java_lang_StackTraceElement::serialize_offsets(SerializeClosure* f) {
4688   STACKTRACEELEMENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4689 }
4690 #endif
4691 
4692 void java_lang_StackTraceElement::set_fileName(oop element, oop value) {
4693   element-&gt;obj_field_put(fileName_offset, value);
4694 }
4695 
4696 void java_lang_StackTraceElement::set_declaringClass(oop element, oop value) {
4697   element-&gt;obj_field_put(declaringClass_offset, value);
4698 }
4699 
4700 void java_lang_StackTraceElement::set_methodName(oop element, oop value) {
4701   element-&gt;obj_field_put(methodName_offset, value);
4702 }
4703 
4704 void java_lang_StackTraceElement::set_lineNumber(oop element, int value) {
4705   element-&gt;int_field_put(lineNumber_offset, value);
4706 }
4707 
4708 void java_lang_StackTraceElement::set_moduleName(oop element, oop value) {
4709   element-&gt;obj_field_put(moduleName_offset, value);
4710 }
4711 
4712 void java_lang_StackTraceElement::set_moduleVersion(oop element, oop value) {
4713   element-&gt;obj_field_put(moduleVersion_offset, value);
4714 }
4715 
4716 void java_lang_StackTraceElement::set_classLoaderName(oop element, oop value) {
4717   element-&gt;obj_field_put(classLoaderName_offset, value);
4718 }
4719 
4720 void java_lang_StackTraceElement::set_declaringClassObject(oop element, oop value) {
4721   element-&gt;obj_field_put(declaringClassObject_offset, value);
4722 }
4723 
4724 void java_lang_StackTraceElement::set_contScopeName(oop element, oop value) {
4725   element-&gt;obj_field_put(contScope_offset, value);
4726 }
4727 
4728 void java_lang_StackFrameInfo::set_version(oop element, short value) {
4729   element-&gt;short_field_put(_version_offset, value);
4730 }
4731 
4732 void java_lang_StackFrameInfo::set_bci(oop element, int value) {
4733   assert(value &gt;= 0 &amp;&amp; value &lt; max_jushort, &quot;must be a valid bci value&quot;);
4734   element-&gt;int_field_put(_bci_offset, value);
4735 }
4736 
4737 void java_lang_StackFrameInfo::set_contScope(oop element, oop value) {
4738   element-&gt;obj_field_put(_contScope_offset, value);
4739 }
4740 
4741 void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {
4742   element-&gt;obj_field_put(_monitors_offset, value);
4743 }
4744 
4745 void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {
4746   element-&gt;obj_field_put(_locals_offset, value);
4747 }
4748 
4749 void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {
4750   element-&gt;obj_field_put(_operands_offset, value);
4751 }
4752 
4753 void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {
4754   element-&gt;int_field_put(_mode_offset, value);
4755 }
4756 
4757 // Support for java Assertions - java_lang_AssertionStatusDirectives.
4758 #define ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(macro) \
4759   macro(classes_offset,        k, &quot;classes&quot;,        string_array_signature, false); \
4760   macro(classEnabled_offset,   k, &quot;classEnabled&quot;,   bool_array_signature, false); \
4761   macro(packages_offset,       k, &quot;packages&quot;,       string_array_signature, false); \
4762   macro(packageEnabled_offset, k, &quot;packageEnabled&quot;, bool_array_signature,   false); \
4763   macro(deflt_offset,          k, &quot;deflt&quot;,          bool_signature,         false)
4764 
4765 void java_lang_AssertionStatusDirectives::compute_offsets() {
4766   InstanceKlass* k = SystemDictionary::AssertionStatusDirectives_klass();
4767   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4768 }
4769 
4770 #if INCLUDE_CDS
4771 void java_lang_AssertionStatusDirectives::serialize_offsets(SerializeClosure* f) {
4772   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4773 }
4774 #endif
4775 
4776 void java_lang_AssertionStatusDirectives::set_classes(oop o, oop val) {
4777   o-&gt;obj_field_put(classes_offset, val);
4778 }
4779 
4780 void java_lang_AssertionStatusDirectives::set_classEnabled(oop o, oop val) {
4781   o-&gt;obj_field_put(classEnabled_offset, val);
4782 }
4783 
4784 void java_lang_AssertionStatusDirectives::set_packages(oop o, oop val) {
4785   o-&gt;obj_field_put(packages_offset, val);
4786 }
4787 
4788 void java_lang_AssertionStatusDirectives::set_packageEnabled(oop o, oop val) {
4789   o-&gt;obj_field_put(packageEnabled_offset, val);
4790 }
4791 
4792 void java_lang_AssertionStatusDirectives::set_deflt(oop o, bool val) {
4793   o-&gt;bool_field_put(deflt_offset, val);
4794 }
4795 
4796 // Support for java.lang.ContinuationScope
4797 
4798 #define CONTINUATIONSCOPE_FIELDS_DO(macro) \
4799   macro(_name_offset, k, vmSymbols::name_name(), string_signature, false);
4800 
4801 void java_lang_ContinuationScope::compute_offsets() {
4802   InstanceKlass* k = SystemDictionary::ContinuationScope_klass();
4803   CONTINUATIONSCOPE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4804 }
4805 
4806 #if INCLUDE_CDS
4807 void java_lang_ContinuationScope::serialize_offsets(SerializeClosure* f) {
4808   CONTINUATIONSCOPE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4809 }
4810 #endif
4811 
4812 // Support for java.lang.Continuation
4813 
4814 #define CONTINUATION_FIELDS_DO(macro) \
4815   macro(_scope_offset,     k, vmSymbols::scope_name(),     continuationscope_signature, false); \
4816   macro(_target_offset,    k, vmSymbols::target_name(),    runnable_signature,          false); \
4817   macro(_parent_offset,    k, vmSymbols::parent_name(),    continuation_signature,      false); \
4818   macro(_yieldInfo_offset, k, vmSymbols::yieldInfo_name(), object_signature,            false); \
4819   macro(_tail_offset,      k, vmSymbols::tail_name(),      stackchunk_signature,        false); \
4820   macro(_stack_offset,     k, vmSymbols::stack_name(),     int_array_signature,         false); \
4821   macro(_maxSize_offset,   k, vmSymbols::maxSize_name(),   int_signature,               false); \
4822   macro(_refStack_offset,  k, vmSymbols::refStack_name(),  object_array_signature,      false); \
4823   macro(_entrySP_offset,   k, vmSymbols::entrySP_name(),   long_signature,              false); \
4824   macro(_entryFP_offset,   k, vmSymbols::entryFP_name(),   long_signature,              false); \
4825   macro(_entryPC_offset,   k, vmSymbols::entryPC_name(),   long_signature,              false); \
4826   macro(_fp_offset,        k, vmSymbols::fp_name(),        long_signature,              false); \
4827   macro(_sp_offset,        k, vmSymbols::sp_name(),        int_signature,               false); \
4828   macro(_pc_offset,        k, vmSymbols::pc_name(),        long_signature,              false); \
4829   macro(_refSP_offset,     k, vmSymbols::refSP_name(),     int_signature,               false); \
4830   macro(_flags_offset,     k, vmSymbols::flags_name(),     byte_signature,              false); \
4831   macro(_cs_offset,        k, vmSymbols::cs_name(),        short_signature,             false); \
4832   macro(_reset_offset,     k, vmSymbols::reset_name(),     bool_signature,              false); \
4833   macro(_mounted_offset,   k, vmSymbols::mounted_name(),   bool_signature,              false); \
4834   macro(_done_offset,      k, vmSymbols::done_name(),      bool_signature,              false); \
4835   macro(_numFrames_offset, k, vmSymbols::numFrames_name(), short_signature,             false); \
4836   macro(_numInterpretedFrames_offset, k, vmSymbols::numInterpretedFrames_name(), short_signature, false);
4837 
4838 void java_lang_Continuation::compute_offsets() {
4839   InstanceKlass* k = SystemDictionary::Continuation_klass();
4840   CONTINUATION_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4841 }
4842 
4843 #if INCLUDE_CDS
4844 void java_lang_Continuation::serialize_offsets(SerializeClosure* f) {
4845   CONTINUATION_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4846 }
4847 #endif
4848 
4849 // Support for jdk.internal.misc.StackChunk
4850 
4851 #define STACKCHUNK_FIELDS_DO(macro) \
4852   macro(_parent_offset,    k, vmSymbols::parent_name(),    stackchunk_signature, false); \
4853   macro(_size_offset,      k, vmSymbols::size_name(),      int_signature,        false); \
4854   macro(_sp_offset,        k, vmSymbols::sp_name(),        int_signature,        false); \
4855   macro(_pc_offset,        k, vmSymbols::pc_name(),        long_signature,       false); \
4856   macro(_argsize_offset,   k, vmSymbols::argsize_name(),   int_signature,        false); \
4857   macro(_mode_offset,      k, vmSymbols::mode_name(),      bool_signature,       false); \
4858   macro(_numFrames_offset, k, vmSymbols::numFrames_name(), int_signature,        false); \
4859   macro(_numOops_offset,   k, vmSymbols::numOops_name(),   int_signature,        false); \
4860   macro(_cont_offset,      k, &quot;cont&quot;,                      continuation_signature, false);
4861 
4862 void jdk_internal_misc_StackChunk::compute_offsets() {
4863   InstanceKlass* k = SystemDictionary::StackChunk_klass();
4864   STACKCHUNK_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4865 }
4866 
4867 #if INCLUDE_CDS
4868 void jdk_internal_misc_StackChunk::serialize_offsets(SerializeClosure* f) {
4869   STACKCHUNK_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4870 }
4871 #endif
4872 
4873 bool java_lang_Continuation::on_local_stack(oop ref, address adr) {
4874   arrayOop s = stack(ref);
4875   void* base = s-&gt;base(T_INT);
4876   return adr &gt;= base &amp;&amp; (char*)adr &lt; ((char*)base + (s-&gt;length() * 4));
4877 }
4878 
4879 bool java_lang_Continuation::is_mounted(oop ref) {
4880   return ref-&gt;bool_field(_mounted_offset) != 0;
4881 }
4882 
4883 
4884 // Support for intrinsification of java.nio.Buffer.checkIndex
4885 int java_nio_Buffer::limit_offset() {
4886   return _limit_offset;
4887 }
4888 
4889 #define BUFFER_FIELDS_DO(macro) \
4890   macro(_limit_offset, k, &quot;limit&quot;, int_signature, false)
4891 
4892 void java_nio_Buffer::compute_offsets() {
4893   InstanceKlass* k = SystemDictionary::nio_Buffer_klass();
4894   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
4895   BUFFER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4896 }
4897 
4898 #if INCLUDE_CDS
4899 void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {
4900   BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4901 }
4902 #endif
4903 
4904 #define AOS_FIELDS_DO(macro) \
4905   macro(_owner_offset, k, &quot;exclusiveOwnerThread&quot;, thread_signature, false)
4906 
4907 void java_util_concurrent_locks_AbstractOwnableSynchronizer::compute_offsets() {
4908   InstanceKlass* k = SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass();
4909   AOS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4910 }
4911 
4912 oop java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(oop obj) {
4913   assert(_owner_offset != 0, &quot;Must be initialized&quot;);
4914   return obj-&gt;obj_field(_owner_offset);
4915 }
4916 
4917 #if INCLUDE_CDS
4918 void java_util_concurrent_locks_AbstractOwnableSynchronizer::serialize_offsets(SerializeClosure* f) {
4919   AOS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4920 }
4921 #endif
4922 
4923 #define INTEGER_CACHE_FIELDS_DO(macro) \
4924   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Integer_array_signature, true)
4925 
4926 void java_lang_Integer_IntegerCache::compute_offsets(InstanceKlass *k) {
4927   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4928   INTEGER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4929 }
4930 
4931 objArrayOop java_lang_Integer_IntegerCache::cache(InstanceKlass *ik) {
4932   oop base = ik-&gt;static_field_base_raw();
4933   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4934 }
4935 
4936 Symbol* java_lang_Integer_IntegerCache::symbol() {
4937   return vmSymbols::java_lang_Integer_IntegerCache();
4938 }
4939 
4940 #if INCLUDE_CDS
4941 void java_lang_Integer_IntegerCache::serialize_offsets(SerializeClosure* f) {
4942   INTEGER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4943 }
4944 #endif
4945 #undef INTEGER_CACHE_FIELDS_DO
4946 
4947 jint java_lang_Integer::value(oop obj) {
4948    jvalue v;
4949    java_lang_boxing_object::get_value(obj, &amp;v);
4950    return v.i;
4951 }
4952 
4953 #define LONG_CACHE_FIELDS_DO(macro) \
4954   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Long_array_signature, true)
4955 
4956 void java_lang_Long_LongCache::compute_offsets(InstanceKlass *k) {
4957   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4958   LONG_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4959 }
4960 
4961 objArrayOop java_lang_Long_LongCache::cache(InstanceKlass *ik) {
4962   oop base = ik-&gt;static_field_base_raw();
4963   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4964 }
4965 
4966 Symbol* java_lang_Long_LongCache::symbol() {
4967   return vmSymbols::java_lang_Long_LongCache();
4968 }
4969 
4970 #if INCLUDE_CDS
4971 void java_lang_Long_LongCache::serialize_offsets(SerializeClosure* f) {
4972   LONG_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4973 }
4974 #endif
4975 #undef LONG_CACHE_FIELDS_DO
4976 
4977 jlong java_lang_Long::value(oop obj) {
4978    jvalue v;
4979    java_lang_boxing_object::get_value(obj, &amp;v);
4980    return v.j;
4981 }
4982 
4983 #define CHARACTER_CACHE_FIELDS_DO(macro) \
4984   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Character_array_signature, true)
4985 
4986 void java_lang_Character_CharacterCache::compute_offsets(InstanceKlass *k) {
4987   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4988   CHARACTER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4989 }
4990 
4991 objArrayOop java_lang_Character_CharacterCache::cache(InstanceKlass *ik) {
4992   oop base = ik-&gt;static_field_base_raw();
4993   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4994 }
4995 
4996 Symbol* java_lang_Character_CharacterCache::symbol() {
4997   return vmSymbols::java_lang_Character_CharacterCache();
4998 }
4999 
5000 #if INCLUDE_CDS
5001 void java_lang_Character_CharacterCache::serialize_offsets(SerializeClosure* f) {
5002   CHARACTER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
5003 }
5004 #endif
5005 #undef CHARACTER_CACHE_FIELDS_DO
5006 
5007 jchar java_lang_Character::value(oop obj) {
5008    jvalue v;
5009    java_lang_boxing_object::get_value(obj, &amp;v);
5010    return v.c;
5011 }
5012 
5013 #define SHORT_CACHE_FIELDS_DO(macro) \
5014   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Short_array_signature, true)
5015 
5016 void java_lang_Short_ShortCache::compute_offsets(InstanceKlass *k) {
5017   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
5018   SHORT_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
5019 }
5020 
5021 objArrayOop java_lang_Short_ShortCache::cache(InstanceKlass *ik) {
5022   oop base = ik-&gt;static_field_base_raw();
5023   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
5024 }
5025 
5026 Symbol* java_lang_Short_ShortCache::symbol() {
5027   return vmSymbols::java_lang_Short_ShortCache();
5028 }
5029 
5030 #if INCLUDE_CDS
5031 void java_lang_Short_ShortCache::serialize_offsets(SerializeClosure* f) {
5032   SHORT_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
5033 }
5034 #endif
5035 #undef SHORT_CACHE_FIELDS_DO
5036 
5037 jshort java_lang_Short::value(oop obj) {
5038    jvalue v;
5039    java_lang_boxing_object::get_value(obj, &amp;v);
5040    return v.s;
5041 }
5042 
5043 #define BYTE_CACHE_FIELDS_DO(macro) \
5044   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Byte_array_signature, true)
5045 
5046 void java_lang_Byte_ByteCache::compute_offsets(InstanceKlass *k) {
5047   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
5048   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
5049 }
5050 
5051 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
5052   oop base = ik-&gt;static_field_base_raw();
5053   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
5054 }
5055 
5056 Symbol* java_lang_Byte_ByteCache::symbol() {
5057   return vmSymbols::java_lang_Byte_ByteCache();
5058 }
5059 
5060 #if INCLUDE_CDS
5061 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
5062   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
5063 }
5064 #endif
5065 #undef BYTE_CACHE_FIELDS_DO
5066 
5067 jbyte java_lang_Byte::value(oop obj) {
5068    jvalue v;
5069    java_lang_boxing_object::get_value(obj, &amp;v);
5070    return v.b;
5071 }
5072 #define BOOLEAN_FIELDS_DO(macro) \
5073   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
5074   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
5075 
5076 
5077 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
5078   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
5079   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
5080 }
5081 
5082 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
5083   oop base = ik-&gt;static_field_base_raw();
5084   return base-&gt;obj_field(_static_TRUE_offset);
5085 }
5086 
5087 oop java_lang_Boolean::get_FALSE(InstanceKlass *ik) {
5088   oop base = ik-&gt;static_field_base_raw();
5089   return base-&gt;obj_field(_static_FALSE_offset);
5090 }
5091 
5092 Symbol* java_lang_Boolean::symbol() {
5093   return vmSymbols::java_lang_Boolean();
5094 }
5095 
5096 #if INCLUDE_CDS
5097 void java_lang_Boolean::serialize_offsets(SerializeClosure* f) {
5098   BOOLEAN_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
5099 }
5100 #endif
5101 #undef BOOLEAN_CACHE_FIELDS_DO
5102 
5103 jboolean java_lang_Boolean::value(oop obj) {
5104    jvalue v;
5105    java_lang_boxing_object::get_value(obj, &amp;v);
5106    return v.z;
5107 }
5108 
5109 static int member_offset(int hardcoded_offset) {
5110   return (hardcoded_offset * heapOopSize) + instanceOopDesc::base_offset_in_bytes();
5111 }
5112 
5113 #define RECORDCOMPONENT_FIELDS_DO(macro) \
5114   macro(clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \
5115   macro(name_offset,        k, &quot;name&quot;,        string_signature, false); \
5116   macro(type_offset,        k, &quot;type&quot;,        class_signature,  false); \
5117   macro(accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \
5118   macro(signature_offset,   k, &quot;signature&quot;,   string_signature, false); \
5119   macro(annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \
5120   macro(typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);
5121 
5122 // Support for java_lang_reflect_RecordComponent
5123 void java_lang_reflect_RecordComponent::compute_offsets() {
5124   InstanceKlass* k = SystemDictionary::RecordComponent_klass();
5125   RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
5126 }
5127 
5128 #if INCLUDE_CDS
5129 void java_lang_reflect_RecordComponent::serialize_offsets(SerializeClosure* f) {
5130   RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
5131 }
5132 #endif
5133 
5134 void java_lang_reflect_RecordComponent::set_clazz(oop element, oop value) {
5135   element-&gt;obj_field_put(clazz_offset, value);
5136 }
5137 
5138 void java_lang_reflect_RecordComponent::set_name(oop element, oop value) {
5139   element-&gt;obj_field_put(name_offset, value);
5140 }
5141 
5142 void java_lang_reflect_RecordComponent::set_type(oop element, oop value) {
5143   element-&gt;obj_field_put(type_offset, value);
5144 }
5145 
5146 void java_lang_reflect_RecordComponent::set_accessor(oop element, oop value) {
5147   element-&gt;obj_field_put(accessor_offset, value);
5148 }
5149 
5150 void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {
5151   element-&gt;obj_field_put(signature_offset, value);
5152 }
5153 
5154 void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {
5155   element-&gt;obj_field_put(annotations_offset, value);
5156 }
5157 
5158 void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {
5159   element-&gt;obj_field_put(typeAnnotations_offset, value);
5160 }
5161 
5162 // Compute hard-coded offsets
5163 // Invoked before SystemDictionary::initialize, so pre-loaded classes
5164 // are not available to determine the offset_of_static_fields.
5165 void JavaClasses::compute_hard_coded_offsets() {
5166 
5167   // java_lang_boxing_object
5168   java_lang_boxing_object::value_offset      = member_offset(java_lang_boxing_object::hc_value_offset);
5169   java_lang_boxing_object::long_value_offset = align_up(member_offset(java_lang_boxing_object::hc_value_offset), BytesPerLong);
5170 
5171   // java_lang_ref_Reference
5172   java_lang_ref_Reference::referent_offset    = member_offset(java_lang_ref_Reference::hc_referent_offset);
5173   java_lang_ref_Reference::queue_offset       = member_offset(java_lang_ref_Reference::hc_queue_offset);
5174   java_lang_ref_Reference::next_offset        = member_offset(java_lang_ref_Reference::hc_next_offset);
5175   java_lang_ref_Reference::discovered_offset  = member_offset(java_lang_ref_Reference::hc_discovered_offset);
5176 }
5177 
5178 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
5179 
5180 // Compute non-hard-coded field offsets of all the classes in this file
5181 void JavaClasses::compute_offsets() {
5182   if (UseSharedSpaces) {
5183     JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
5184                                                          JvmtiExport::has_early_class_hook_env()),
5185                       &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));
5186     // None of the classes used by the rest of this function can be replaced by
5187     // JMVTI ClassFileLoadHook.
5188     // We are safe to use the archived offsets, which have already been restored
5189     // by JavaClasses::serialize_offsets, without computing the offsets again.
5190     return;
5191   }
5192 
5193   // We have already called the compute_offsets() of the
5194   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String and java_lang_Class)
5195   // earlier inside SystemDictionary::resolve_well_known_classes()
5196   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
5197 }
5198 
5199 #if INCLUDE_CDS
5200 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
5201 
5202 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
5203   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
5204 }
5205 #endif
5206 
5207 #if INCLUDE_CDS_JAVA_HEAP
5208 bool JavaClasses::is_supported_for_archiving(oop obj) {
5209   Klass* klass = obj-&gt;klass();
5210 
5211   if (klass == SystemDictionary::ClassLoader_klass() ||  // ClassLoader::loader_data is malloc&#39;ed.
5212       klass == SystemDictionary::Module_klass() ||       // Module::module_entry is malloc&#39;ed
5213       // The next 3 classes are used to implement java.lang.invoke, and are not used directly in
5214       // regular Java code. The implementation of java.lang.invoke uses generated anonymoys classes
5215       // (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.
5216       // So for now we cannot not support these classes for archiving.
5217       //
5218       // These objects typically are not referenced by static fields, but rather by resolved
5219       // constant pool entries, so excluding them shouldn&#39;t affect the archiving of static fields.
5220       klass == SystemDictionary::ResolvedMethodName_klass() ||
5221       klass == SystemDictionary::MemberName_klass() ||
5222       klass == SystemDictionary::Context_klass()) {
5223     return false;
5224   }
5225 
5226   return true;
5227 }
5228 #endif
5229 
5230 #ifndef PRODUCT
5231 
5232 // These functions exist to assert the validity of hard-coded field offsets to guard
5233 // against changes in the class files
5234 
5235 bool JavaClasses::check_offset(const char *klass_name, int hardcoded_offset, const char *field_name, const char* field_sig) {
5236   EXCEPTION_MARK;
5237   fieldDescriptor fd;
5238   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name);
5239   Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
5240   InstanceKlass* ik = InstanceKlass::cast(k);
5241   TempNewSymbol f_name = SymbolTable::new_symbol(field_name);
5242   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig);
5243   if (!ik-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
5244     tty-&gt;print_cr(&quot;Nonstatic field %s.%s not found&quot;, klass_name, field_name);
5245     return false;
5246   }
5247   if (fd.is_static()) {
5248     tty-&gt;print_cr(&quot;Nonstatic field %s.%s appears to be static&quot;, klass_name, field_name);
5249     return false;
5250   }
5251   if (fd.offset() == hardcoded_offset ) {
5252     return true;
5253   } else {
5254     tty-&gt;print_cr(&quot;Offset of nonstatic field %s.%s is hardcoded as %d but should really be %d.&quot;,
5255                   klass_name, field_name, hardcoded_offset, fd.offset());
5256     return false;
5257   }
5258 }
5259 
5260 // Check the hard-coded field offsets of all the classes in this file
5261 
5262 void JavaClasses::check_offsets() {
5263   bool valid = true;
5264 
5265 #define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
5266   valid &amp;= check_offset(klass_name, cpp_klass_name :: field_name ## _offset, #field_name, field_sig)
5267 
5268 #define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
5269   valid &amp;= check_offset(klass_name, cpp_klass_name :: long_ ## field_name ## _offset, #field_name, field_sig)
5270 
5271   // Boxed primitive objects (java_lang_boxing_object)
5272 
5273   CHECK_OFFSET(&quot;java/lang/Boolean&quot;,   java_lang_boxing_object, value, &quot;Z&quot;);
5274   CHECK_OFFSET(&quot;java/lang/Character&quot;, java_lang_boxing_object, value, &quot;C&quot;);
5275   CHECK_OFFSET(&quot;java/lang/Float&quot;,     java_lang_boxing_object, value, &quot;F&quot;);
5276   CHECK_LONG_OFFSET(&quot;java/lang/Double&quot;, java_lang_boxing_object, value, &quot;D&quot;);
5277   CHECK_OFFSET(&quot;java/lang/Byte&quot;,      java_lang_boxing_object, value, &quot;B&quot;);
5278   CHECK_OFFSET(&quot;java/lang/Short&quot;,     java_lang_boxing_object, value, &quot;S&quot;);
5279   CHECK_OFFSET(&quot;java/lang/Integer&quot;,   java_lang_boxing_object, value, &quot;I&quot;);
5280   CHECK_LONG_OFFSET(&quot;java/lang/Long&quot;, java_lang_boxing_object, value, &quot;J&quot;);
5281 
5282   // java.lang.ref.Reference
5283 
5284   CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, referent, &quot;Ljava/lang/Object;&quot;);
5285   CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, queue, &quot;Ljava/lang/ref/ReferenceQueue;&quot;);
5286   CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, next, &quot;Ljava/lang/ref/Reference;&quot;);
5287   // Fake field
5288   //CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, discovered, &quot;Ljava/lang/ref/Reference;&quot;);
5289 
5290   // java.lang.Continuation
5291 
5292   // CHECK_OFFSET(&quot;java/lang/Continuation&quot;, java_lang_Continuation, target,   &quot;Ljava/lang/Runnable;&quot;);
5293   // CHECK_OFFSET(&quot;java/lang/Continuation&quot;, java_lang_Continuation, stack,    &quot;[I&quot;);
5294   // CHECK_OFFSET(&quot;java/lang/Continuation&quot;, java_lang_Continuation, parent,   &quot;Ljava/lang/Continuation;&quot;);
5295   // CHECK_OFFSET(&quot;java/lang/Continuation&quot;, java_lang_Continuation, entrySP,  &quot;J&quot;);
5296   // CHECK_OFFSET(&quot;java/lang/Continuation&quot;, java_lang_Continuation, entryFP,  &quot;J&quot;);
5297   // CHECK_OFFSET(&quot;java/lang/Continuation&quot;, java_lang_Continuation, entryPC,  &quot;J&quot;);
5298   // CHECK_OFFSET(&quot;java/lang/Continuation&quot;, java_lang_Continuation, lastFP,   &quot;I&quot;);
5299   // CHECK_OFFSET(&quot;java/lang/Continuation&quot;, java_lang_Continuation, lastSP,   &quot;I&quot;);
5300 
5301   if (!valid) vm_exit_during_initialization(&quot;Hard-coded field offset verification failed&quot;);
5302 }
5303 
5304 #endif // PRODUCT
5305 
5306 int InjectedField::compute_offset() {
5307   InstanceKlass* ik = InstanceKlass::cast(klass());
5308   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
5309     if (!may_be_java &amp;&amp; !fs.access_flags().is_internal()) {
5310       // Only look at injected fields
5311       continue;
5312     }
5313     if (fs.name() == name() &amp;&amp; fs.signature() == signature()) {
5314       return fs.offset();
5315     }
5316   }
5317   ResourceMark rm;
5318   tty-&gt;print_cr(&quot;Invalid layout of %s at %s/%s%s&quot;, ik-&gt;external_name(), name()-&gt;as_C_string(), signature()-&gt;as_C_string(), may_be_java ? &quot; (may_be_java)&quot; : &quot;&quot;);
5319 #ifndef PRODUCT
5320   ik-&gt;print();
5321   tty-&gt;print_cr(&quot;all fields:&quot;);
5322   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
5323     tty-&gt;print_cr(&quot;  name: %s, sig: %s, flags: %08x&quot;, fs.name()-&gt;as_C_string(), fs.signature()-&gt;as_C_string(), fs.access_flags().as_int());
5324   }
5325 #endif //PRODUCT
5326   vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
5327   return -1;
5328 }
5329 
5330 void javaClasses_init() {
5331   JavaClasses::compute_offsets();
5332   JavaClasses::check_offsets();
5333   java_lang_VirtualThread::init_static_notify_jvmti_events();
5334   FilteredFieldsMap::initialize();  // must be done after computing offsets.
5335 }
    </pre>
  </body>
</html>
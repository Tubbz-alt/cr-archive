<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/lib/jdk/test/lib/process/ProcessTools.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-added">  1 </span>
  2 /*
  3  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 package jdk.test.lib.process;
 26 
 27 import java.io.File;
 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 import java.io.OutputStream;
 31 import java.io.PrintStream;
 32 import java.nio.charset.Charset;
<a name="2" id="anc2"></a><span class="line-added"> 33 import java.lang.reflect.Method;</span>
 34 import java.nio.file.Paths;
 35 import java.util.ArrayList;
 36 import java.util.Arrays;
 37 import java.util.Collections;
 38 import java.util.concurrent.CountDownLatch;
 39 import java.util.Map;
 40 import java.util.concurrent.ExecutionException;
 41 import java.util.concurrent.Future;
 42 import java.util.concurrent.TimeUnit;
 43 import java.util.concurrent.TimeoutException;
 44 import java.util.function.Predicate;
 45 import java.util.function.Consumer;
 46 import java.util.stream.Collectors;
 47 import java.security.AccessController;
 48 import java.security.PrivilegedActionException;
 49 import java.security.PrivilegedExceptionAction;
 50 
 51 import jdk.test.lib.JDKToolFinder;
 52 import jdk.test.lib.Platform;
 53 import jdk.test.lib.Utils;
 54 
 55 public final class ProcessTools {
 56     private static final class LineForwarder extends StreamPumper.LinePump {
 57         private final PrintStream ps;
 58         private final String prefix;
 59         LineForwarder(String prefix, PrintStream os) {
 60             this.ps = os;
 61             this.prefix = prefix;
 62         }
 63         @Override
 64         protected void processLine(String line) {
 65             ps.println(&quot;[&quot; + prefix + &quot;] &quot; + line);
 66         }
 67     }
 68 
 69     private ProcessTools() {
 70     }
 71 
 72     /**
 73      * &lt;p&gt;Starts a process from its builder.&lt;/p&gt;
 74      * &lt;span&gt;The default redirects of STDOUT and STDERR are started&lt;/span&gt;
 75      * @param name The process name
 76      * @param processBuilder The process builder
 77      * @return Returns the initialized process
 78      * @throws IOException
 79      */
 80     public static Process startProcess(String name,
 81                                        ProcessBuilder processBuilder)
 82     throws IOException {
 83         return startProcess(name, processBuilder, (Consumer&lt;String&gt;)null);
 84     }
 85 
 86     /**
 87      * &lt;p&gt;Starts a process from its builder.&lt;/p&gt;
 88      * &lt;span&gt;The default redirects of STDOUT and STDERR are started&lt;/span&gt;
 89      * &lt;p&gt;It is possible to monitor the in-streams via the provided {@code consumer}
 90      * @param name The process name
 91      * @param consumer {@linkplain Consumer} instance to process the in-streams
 92      * @param processBuilder The process builder
 93      * @return Returns the initialized process
 94      * @throws IOException
 95      */
 96     @SuppressWarnings(&quot;overloads&quot;)
 97     public static Process startProcess(String name,
 98                                        ProcessBuilder processBuilder,
 99                                        Consumer&lt;String&gt; consumer)
100     throws IOException {
101         try {
102             return startProcess(name, processBuilder, consumer, null, -1, TimeUnit.NANOSECONDS);
103         } catch (InterruptedException | TimeoutException e) {
104             // will never happen
105             throw new RuntimeException(e);
106         }
107     }
108 
109     /**
110      * &lt;p&gt;Starts a process from its builder.&lt;/p&gt;
111      * &lt;span&gt;The default redirects of STDOUT and STDERR are started&lt;/span&gt;
112      * &lt;p&gt;
113      * It is possible to wait for the process to get to a warmed-up state
114      * via {@linkplain Predicate} condition on the STDOUT
115      * &lt;/p&gt;
116      * @param name The process name
117      * @param processBuilder The process builder
118      * @param linePredicate The {@linkplain Predicate} to use on the STDOUT
119      *                      Used to determine the moment the target app is
120      *                      properly warmed-up.
121      *                      It can be null - in that case the warmup is skipped.
122      * @param timeout The timeout for the warmup waiting; -1 = no wait; 0 = wait forever
123      * @param unit The timeout {@linkplain TimeUnit}
124      * @return Returns the initialized {@linkplain Process}
125      * @throws IOException
126      * @throws InterruptedException
127      * @throws TimeoutException
128      */
129     public static Process startProcess(String name,
130                                        ProcessBuilder processBuilder,
131                                        final Predicate&lt;String&gt; linePredicate,
132                                        long timeout,
133                                        TimeUnit unit)
134     throws IOException, InterruptedException, TimeoutException {
135         return startProcess(name, processBuilder, null, linePredicate, timeout, unit);
136     }
137 
138     /**
139      * &lt;p&gt;Starts a process from its builder.&lt;/p&gt;
140      * &lt;span&gt;The default redirects of STDOUT and STDERR are started&lt;/span&gt;
141      * &lt;p&gt;
142      * It is possible to wait for the process to get to a warmed-up state
143      * via {@linkplain Predicate} condition on the STDOUT and monitor the
144      * in-streams via the provided {@linkplain Consumer}
145      * &lt;/p&gt;
146      * @param name The process name
147      * @param processBuilder The process builder
148      * @param lineConsumer  The {@linkplain Consumer} the lines will be forwarded to
149      * @param linePredicate The {@linkplain Predicate} to use on the STDOUT
150      *                      Used to determine the moment the target app is
151      *                      properly warmed-up.
152      *                      It can be null - in that case the warmup is skipped.
153      * @param timeout The timeout for the warmup waiting; -1 = no wait; 0 = wait forever
154      * @param unit The timeout {@linkplain TimeUnit}
155      * @return Returns the initialized {@linkplain Process}
156      * @throws IOException
157      * @throws InterruptedException
158      * @throws TimeoutException
159      */
160     public static Process startProcess(String name,
161                                        ProcessBuilder processBuilder,
162                                        final Consumer&lt;String&gt; lineConsumer,
163                                        final Predicate&lt;String&gt; linePredicate,
164                                        long timeout,
165                                        TimeUnit unit)
166     throws IOException, InterruptedException, TimeoutException {
167         System.out.println(&quot;[&quot;+name+&quot;]:&quot; + processBuilder.command().stream().collect(Collectors.joining(&quot; &quot;)));
168         Process p = privilegedStart(processBuilder);
169         StreamPumper stdout = new StreamPumper(p.getInputStream());
170         StreamPumper stderr = new StreamPumper(p.getErrorStream());
171 
172         stdout.addPump(new LineForwarder(name, System.out));
173         stderr.addPump(new LineForwarder(name, System.err));
174         if (lineConsumer != null) {
175             StreamPumper.LinePump pump = new StreamPumper.LinePump() {
176                 @Override
177                 protected void processLine(String line) {
178                     lineConsumer.accept(line);
179                 }
180             };
181             stdout.addPump(pump);
182             stderr.addPump(pump);
183         }
184 
185 
186         CountDownLatch latch = new CountDownLatch(1);
187         if (linePredicate != null) {
188             StreamPumper.LinePump pump = new StreamPumper.LinePump() {
189                 @Override
190                 protected void processLine(String line) {
191                     if (latch.getCount() &gt; 0 &amp;&amp; linePredicate.test(line)) {
192                         latch.countDown();
193                     }
194                 }
195             };
196             stdout.addPump(pump);
197             stderr.addPump(pump);
198         } else {
199             latch.countDown();
200         }
201         final Future&lt;Void&gt; stdoutTask = stdout.process();
202         final Future&lt;Void&gt; stderrTask = stderr.process();
203 
204         try {
205             if (timeout &gt; -1) {
206                 if (timeout == 0) {
207                     latch.await();
208                 } else {
209                     if (!latch.await(Utils.adjustTimeout(timeout), unit)) {
210                         throw new TimeoutException();
211                     }
212                 }
213             }
214         } catch (TimeoutException | InterruptedException e) {
215             System.err.println(&quot;Failed to start a process (thread dump follows)&quot;);
216             for(Map.Entry&lt;Thread, StackTraceElement[]&gt; s : Thread.getAllStackTraces().entrySet()) {
217                 printStack(s.getKey(), s.getValue());
218             }
219 
220             if (p.isAlive()) {
221                 p.destroyForcibly();
222             }
223 
224             stdoutTask.cancel(true);
225             stderrTask.cancel(true);
226             throw e;
227         }
228 
229         return new ProcessImpl(p, stdoutTask, stderrTask);
230     }
231 
232     /**
233      * &lt;p&gt;Starts a process from its builder.&lt;/p&gt;
234      * &lt;span&gt;The default redirects of STDOUT and STDERR are started&lt;/span&gt;
235      * &lt;p&gt;
236      * It is possible to wait for the process to get to a warmed-up state
237      * via {@linkplain Predicate} condition on the STDOUT. The warm-up will
238      * wait indefinitely.
239      * &lt;/p&gt;
240      * @param name The process name
241      * @param processBuilder The process builder
242      * @param linePredicate The {@linkplain Predicate} to use on the STDOUT
243      *                      Used to determine the moment the target app is
244      *                      properly warmed-up.
245      *                      It can be null - in that case the warmup is skipped.
246      * @return Returns the initialized {@linkplain Process}
247      * @throws IOException
248      * @throws InterruptedException
249      * @throws TimeoutException
250      */
251     @SuppressWarnings(&quot;overloads&quot;)
252     public static Process startProcess(String name,
253                                        ProcessBuilder processBuilder,
254                                        final Predicate&lt;String&gt; linePredicate)
255     throws IOException, InterruptedException, TimeoutException {
256         return startProcess(name, processBuilder, linePredicate, 0, TimeUnit.SECONDS);
257     }
258 
259     /**
260      * Get the process id of the current running Java process
261      *
262      * @return Process id
263      */
264     public static long getProcessId() throws Exception {
265         return ProcessHandle.current().pid();
266     }
267 
268 
269 
270     /**
271      * Create ProcessBuilder using the java launcher from the jdk to be tested and
272      * with any platform specific arguments prepended
273      */
274     public static ProcessBuilder createJavaProcessBuilder(String... command) {
275         return createJavaProcessBuilder(false, command);
276     }
277 
278     /**
279      * Create ProcessBuilder using the java launcher from the jdk to be tested,
280      * and with any platform specific arguments prepended.
281      *
282      * @param addTestVmAndJavaOptions If true, adds test.vm.opts and test.java.opts
283      *        to the java arguments.
284      * @param command Arguments to pass to the java command.
285      * @return The ProcessBuilder instance representing the java command.
286      */
287     public static ProcessBuilder createJavaProcessBuilder(boolean addTestVmAndJavaOptions, String... command) {
288         String javapath = JDKToolFinder.getJDKTool(&quot;java&quot;);
289 
290         ArrayList&lt;String&gt; args = new ArrayList&lt;&gt;();
291         args.add(javapath);
292 
293         args.add(&quot;-cp&quot;);
294         args.add(System.getProperty(&quot;java.class.path&quot;));
295 
296         if (addTestVmAndJavaOptions) {
297             Collections.addAll(args, Utils.getTestJavaOpts());
298         }
299 
<a name="3" id="anc3"></a><span class="line-modified">300         boolean noModule = true;</span>
<span class="line-added">301         for (String cmd: command) {</span>
<span class="line-added">302             if (cmd.equals(&quot;-m&quot;)) {</span>
<span class="line-added">303                 noModule = false;</span>
<span class="line-added">304             }</span>
<span class="line-added">305         }</span>
<span class="line-added">306 </span>
<span class="line-added">307         String[] doubleWordArgs = {&quot;-cp&quot;, &quot;-classpath&quot;, &quot;--add-opens&quot;, &quot;--class-path&quot;, &quot;--upgrade-module-path&quot;,</span>
<span class="line-added">308                                    &quot;--add-modules&quot;, &quot;-d&quot;, &quot;--add-exports&quot;, &quot;--patch-module&quot;, &quot;--module-path&quot;};</span>
<span class="line-added">309 </span>
<span class="line-added">310         if (noModule &amp;&amp; System.getProperty(&quot;main.wrapper&quot;) != null) {</span>
<span class="line-added">311             boolean skipNext = false;</span>
<span class="line-added">312             boolean added = false;</span>
<span class="line-added">313             for (String cmd : command) {</span>
<span class="line-added">314                 if (added) {</span>
<span class="line-added">315                     args.add(cmd);</span>
<span class="line-added">316                     continue;</span>
<span class="line-added">317                 }</span>
<span class="line-added">318 </span>
<span class="line-added">319                 if (skipNext) {</span>
<span class="line-added">320                     skipNext = false;</span>
<span class="line-added">321                     args.add(cmd);</span>
<span class="line-added">322                     continue;</span>
<span class="line-added">323                 }</span>
<span class="line-added">324                 for (String dWArg : doubleWordArgs) {</span>
<span class="line-added">325                     if (cmd.equals(dWArg)) {</span>
<span class="line-added">326                         skipNext = true;</span>
<span class="line-added">327                         args.add(cmd);</span>
<span class="line-added">328                         continue;</span>
<span class="line-added">329                     }</span>
<span class="line-added">330                 }</span>
<span class="line-added">331                 if (skipNext) {</span>
<span class="line-added">332                     continue;</span>
<span class="line-added">333                 }</span>
<span class="line-added">334                 if (cmd.startsWith(&quot;-cp&quot;)) {</span>
<span class="line-added">335                     skipNext = true;</span>
<span class="line-added">336                     args.add(cmd);</span>
<span class="line-added">337                     continue;</span>
<span class="line-added">338                 }</span>
<span class="line-added">339                 if (cmd.startsWith(&quot;--add-exports&quot;)) {</span>
<span class="line-added">340                     skipNext = true;</span>
<span class="line-added">341                     args.add(cmd);</span>
<span class="line-added">342                     continue;</span>
<span class="line-added">343                 }</span>
<span class="line-added">344                 if (cmd.startsWith(&quot;--patch-module&quot;)) {</span>
<span class="line-added">345                     skipNext = true;</span>
<span class="line-added">346                     args.add(cmd);</span>
<span class="line-added">347                     continue;</span>
<span class="line-added">348                 }</span>
<span class="line-added">349                 if (cmd.startsWith(&quot;-&quot;)) {</span>
<span class="line-added">350                     args.add(cmd);</span>
<span class="line-added">351                     continue;</span>
<span class="line-added">352                 }</span>
<span class="line-added">353                 args.add(&quot;jdk.test.lib.process.ProcessTools&quot;);</span>
<span class="line-added">354                 args.add(System.getProperty(&quot;main.wrapper&quot;));</span>
<span class="line-added">355                 added = true;</span>
<span class="line-added">356                 // Should be main</span>
<span class="line-added">357                 // System.out.println(&quot;Wrapped TOFIND: &quot; + cmd);</span>
<span class="line-added">358                 args.add(cmd);</span>
<span class="line-added">359             }</span>
<span class="line-added">360         } else {</span>
<span class="line-added">361             Collections.addAll(args, command);</span>
<span class="line-added">362         }</span>
363 
364         // Reporting
365         StringBuilder cmdLine = new StringBuilder();
366         for (String cmd : args)
367             cmdLine.append(cmd).append(&#39; &#39;);
368         System.out.println(&quot;Command line: [&quot; + cmdLine.toString() + &quot;]&quot;);
369 
370         return new ProcessBuilder(args.toArray(new String[args.size()]));
371     }
372 
373     private static void printStack(Thread t, StackTraceElement[] stack) {
374         System.out.println(&quot;\t&quot; +  t +
375                            &quot; stack: (length = &quot; + stack.length + &quot;)&quot;);
376         if (t != null) {
377             for (StackTraceElement stack1 : stack) {
378                 System.out.println(&quot;\t&quot; + stack1);
379             }
380             System.out.println();
381         }
382     }
383 
384     /**
385      * Executes a test jvm process, waits for it to finish and returns the process output.
386      * The default jvm options from jtreg, test.vm.opts and test.java.opts, are added.
387      * The java from the test.jdk is used to execute the command.
388      *
389      * The command line will be like:
390      * {test.jdk}/bin/java {test.vm.opts} {test.java.opts} cmds
391      *
392      * The jvm process will have exited before this method returns.
393      *
394      * @param cmds User specified arguments.
395      * @return The output from the process.
396      */
397     public static OutputAnalyzer executeTestJvm(String... cmds) throws Exception {
398         ProcessBuilder pb = createJavaProcessBuilder(Utils.addTestJavaOpts(cmds));
399         return executeProcess(pb);
400     }
401 
402     /**
403      * @see #executeTestJvm(String...)
404      * @param cmds User specified arguments.
405      * @return The output from the process.
406      */
407     public static OutputAnalyzer executeTestJava(String... cmds) throws Exception {
408         return executeTestJvm(cmds);
409     }
410 
411     /**
412      * Executes a process, waits for it to finish and returns the process output.
413      * The process will have exited before this method returns.
414      * @param pb The ProcessBuilder to execute.
415      * @return The {@linkplain OutputAnalyzer} instance wrapping the process.
416      */
417     public static OutputAnalyzer executeProcess(ProcessBuilder pb) throws Exception {
418         return executeProcess(pb, null);
419     }
420 
421     /**
422      * Executes a process, pipe some text into its STDIN, waits for it
423      * to finish and returns the process output. The process will have exited
424      * before this method returns.
425      * @param pb The ProcessBuilder to execute.
426      * @param input The text to pipe into STDIN. Can be null.
427      * @return The {@linkplain OutputAnalyzer} instance wrapping the process.
428      */
429     public static OutputAnalyzer executeProcess(ProcessBuilder pb, String input) throws Exception {
430         return executeProcess(pb, input, null);
431     }
432 
433     /**
434      * Executes a process, pipe some text into its STDIN, waits for it
435      * to finish and returns the process output. The process will have exited
436      * before this method returns.
437      * @param pb The ProcessBuilder to execute.
438      * @param input The text to pipe into STDIN. Can be null.
439      * @param cs The charset used to convert from bytes to chars or null for
440      *           the default charset.
441      * @return The {@linkplain OutputAnalyzer} instance wrapping the process.
442      */
443     public static OutputAnalyzer executeProcess(ProcessBuilder pb, String input,
444             Charset cs) throws Exception {
445         OutputAnalyzer output = null;
446         Process p = null;
447         boolean failed = false;
448         try {
449             p = privilegedStart(pb);
450             if (input != null) {
451                try (PrintStream ps = new PrintStream(p.getOutputStream())) {
452                    ps.print(input);
453                }
454             }
455 
456             output = new OutputAnalyzer(p, cs);
457             p.waitFor();
458 
459             return output;
460         } catch (Throwable t) {
461             if (p != null) {
462                 p.destroyForcibly().waitFor();
463             }
464 
465             failed = true;
466             System.out.println(&quot;executeProcess() failed: &quot; + t);
467             throw t;
468         } finally {
469             if (failed) {
470                 System.err.println(getProcessLog(pb, output));
471             }
472         }
473     }
474 
475     /**
476      * Executes a process, waits for it to finish and returns the process output.
477      *
478      * The process will have exited before this method returns.
479      *
480      * @param cmds The command line to execute.
481      * @return The output from the process.
482      */
483     public static OutputAnalyzer executeProcess(String... cmds) throws Throwable {
484         return executeProcess(new ProcessBuilder(cmds));
485     }
486 
487     /**
488      * Used to log command line, stdout, stderr and exit code from an executed process.
489      * @param pb The executed process.
490      * @param output The output from the process.
491      */
492     public static String getProcessLog(ProcessBuilder pb, OutputAnalyzer output) {
493         String stderr = output == null ? &quot;null&quot; : output.getStderr();
494         String stdout = output == null ? &quot;null&quot; : output.getStdout();
495         String exitValue = output == null ? &quot;null&quot;: Integer.toString(output.getExitValue());
496         StringBuilder logMsg = new StringBuilder();
497         final String nl = System.getProperty(&quot;line.separator&quot;);
498         logMsg.append(&quot;--- ProcessLog ---&quot; + nl);
499         logMsg.append(&quot;cmd: &quot; + getCommandLine(pb) + nl);
500         logMsg.append(&quot;exitvalue: &quot; + exitValue + nl);
501         logMsg.append(&quot;stderr: &quot; + stderr + nl);
502         logMsg.append(&quot;stdout: &quot; + stdout + nl);
503 
504         return logMsg.toString();
505     }
506 
507     /**
508      * @return The full command line for the ProcessBuilder.
509      */
510     public static String getCommandLine(ProcessBuilder pb) {
511         if (pb == null) {
512             return &quot;null&quot;;
513         }
514         StringBuilder cmd = new StringBuilder();
515         for (String s : pb.command()) {
516             cmd.append(s).append(&quot; &quot;);
517         }
518         return cmd.toString().trim();
519     }
520 
521     /**
522      * Executes a process, waits for it to finish, prints the process output
523      * to stdout, and returns the process output.
524      *
525      * The process will have exited before this method returns.
526      *
527      * @param cmds The command line to execute.
528      * @return The {@linkplain OutputAnalyzer} instance wrapping the process.
529      */
530     public static OutputAnalyzer executeCommand(String... cmds)
531             throws Throwable {
532         String cmdLine = Arrays.stream(cmds).collect(Collectors.joining(&quot; &quot;));
533         System.out.println(&quot;Command line: [&quot; + cmdLine + &quot;]&quot;);
534         OutputAnalyzer analyzer = ProcessTools.executeProcess(cmds);
535         System.out.println(analyzer.getOutput());
536         return analyzer;
537     }
538 
539     /**
540      * Executes a process, waits for it to finish, prints the process output
541      * to stdout and returns the process output.
542      *
543      * The process will have exited before this method returns.
544      *
545      * @param pb The ProcessBuilder to execute.
546      * @return The {@linkplain OutputAnalyzer} instance wrapping the process.
547      */
548     public static OutputAnalyzer executeCommand(ProcessBuilder pb)
549             throws Throwable {
550         String cmdLine = pb.command().stream()
551                 .map(x -&gt; (x.contains(&quot; &quot;) || x.contains(&quot;$&quot;))
552                         ? (&quot;&#39;&quot; + x + &quot;&#39;&quot;) : x)
553                 .collect(Collectors.joining(&quot; &quot;));
554         System.out.println(&quot;Command line: [&quot; + cmdLine + &quot;]&quot;);
555         OutputAnalyzer analyzer = ProcessTools.executeProcess(pb);
556         System.out.println(analyzer.getOutput());
557         return analyzer;
558     }
559 
560     /**
561      * Helper method to create a process builder for launching native executable
562      * test that uses/loads JVM.
563      *
564      * @param executableName The name of an executable to be launched.
565      * @param args Arguments for the executable.
566      * @return New ProcessBuilder instance representing the command.
567      */
568     public static ProcessBuilder createNativeTestProcessBuilder(String executableName,
569                                                                 String... args) throws Exception {
570         executableName = Platform.isWindows() ? executableName + &quot;.exe&quot; : executableName;
571         String executable = Paths.get(System.getProperty(&quot;test.nativepath&quot;), executableName)
572             .toAbsolutePath()
573             .toString();
574 
575         ProcessBuilder pb = new ProcessBuilder(executable);
576         pb.command().addAll(Arrays.asList(args));
577         addJvmLib(pb);
578         return pb;
579     }
580 
581     /**
582      * Adds JVM library path to the native library path.
583      *
584      * @param pb ProcessBuilder to be updated with JVM library path.
585      * @return pb Update ProcessBuilder instance.
586      */
587     public static ProcessBuilder addJvmLib(ProcessBuilder pb) throws Exception {
588         String jvmLibDir = Platform.jvmLibDir().toString();
589         String libPathVar = Platform.sharedLibraryPathVariableName();
590         String currentLibPath = pb.environment().get(libPathVar);
591 
592         String newLibPath = jvmLibDir;
593         if ( (currentLibPath != null) &amp;&amp; !currentLibPath.isEmpty() ) {
594             newLibPath = currentLibPath + File.pathSeparator + jvmLibDir;
595         }
596 
597         pb.environment().put(libPathVar, newLibPath);
598 
599         return pb;
600     }
601 
602     private static Process privilegedStart(ProcessBuilder pb) throws IOException {
603         try {
604             return AccessController.doPrivileged(
605                 (PrivilegedExceptionAction&lt;Process&gt;) () -&gt; pb.start());
606         } catch (PrivilegedActionException e) {
607             IOException t = (IOException) e.getException();
608             throw t;
609         }
610     }
611 
612     private static class ProcessImpl extends Process {
613 
614         private final Process p;
615         private final Future&lt;Void&gt; stdoutTask;
616         private final Future&lt;Void&gt; stderrTask;
617 
618         public ProcessImpl(Process p, Future&lt;Void&gt; stdoutTask, Future&lt;Void&gt; stderrTask) {
619             this.p = p;
620             this.stdoutTask = stdoutTask;
621             this.stderrTask = stderrTask;
622         }
623 
624         @Override
625         public OutputStream getOutputStream() {
626             return p.getOutputStream();
627         }
628 
629         @Override
630         public InputStream getInputStream() {
631             return p.getInputStream();
632         }
633 
634         @Override
635         public InputStream getErrorStream() {
636             return p.getErrorStream();
637         }
638 
639         @Override
640         public int waitFor() throws InterruptedException {
641             int rslt = p.waitFor();
642             waitForStreams();
643             return rslt;
644         }
645 
646         @Override
647         public int exitValue() {
648             return p.exitValue();
649         }
650 
651         @Override
652         public void destroy() {
653             p.destroy();
654         }
655 
656         @Override
657         public long pid() {
658             return p.pid();
659         }
660 
661         @Override
662         public boolean isAlive() {
663             return p.isAlive();
664         }
665 
666         @Override
667         public Process destroyForcibly() {
668             return p.destroyForcibly();
669         }
670 
671         @Override
672         public boolean waitFor(long timeout, TimeUnit unit) throws InterruptedException {
673             boolean rslt = p.waitFor(timeout, unit);
674             if (rslt) {
675                 waitForStreams();
676             }
677             return rslt;
678         }
679 
680         private void waitForStreams() throws InterruptedException {
681             try {
682                 stdoutTask.get();
683             } catch (ExecutionException e) {
684             }
685             try {
686                 stderrTask.get();
687             } catch (ExecutionException e) {
688             }
689         }
690     }
<a name="4" id="anc4"></a><span class="line-added">691 </span>
<span class="line-added">692     // ProcessTools as a wrapper</span>
<span class="line-added">693     public static void main(String[] args) throws Throwable {</span>
<span class="line-added">694         String wrapper = args[0];</span>
<span class="line-added">695         String className = args[1];</span>
<span class="line-added">696         String[] classArgs = new String[args.length - 2];</span>
<span class="line-added">697         System.arraycopy(args, 2, classArgs, 0, args.length - 2);</span>
<span class="line-added">698         Class c = Class.forName(className);</span>
<span class="line-added">699         Method mainMethod = c.getMethod(&quot;main&quot;, new Class[] { String[].class });</span>
<span class="line-added">700 </span>
<span class="line-added">701         if (wrapper.equals(&quot;Virtual&quot;)) {</span>
<span class="line-added">702             MainThreadGroup tg = new MainThreadGroup();</span>
<span class="line-added">703             // TODO fix to set virtual scheduler group when become available</span>
<span class="line-added">704             Thread vthread = Thread.builder().virtual().task(() -&gt; {</span>
<span class="line-added">705                     try {</span>
<span class="line-added">706                         mainMethod.invoke(null, new Object[] { classArgs });</span>
<span class="line-added">707                     } catch (Throwable error) {</span>
<span class="line-added">708                         tg.uncaughtThrowable = error;</span>
<span class="line-added">709                     }</span>
<span class="line-added">710                 }).build();</span>
<span class="line-added">711             vthread.start();</span>
<span class="line-added">712             vthread.join();</span>
<span class="line-added">713         } else if (wrapper.equals(&quot;Kernel&quot;)) {</span>
<span class="line-added">714             MainThreadGroup tg = new MainThreadGroup();</span>
<span class="line-added">715             Thread t = new Thread(tg, () -&gt; {</span>
<span class="line-added">716                     try {</span>
<span class="line-added">717                         mainMethod.invoke(null, new Object[] { classArgs });</span>
<span class="line-added">718                     } catch (Throwable error) {</span>
<span class="line-added">719                         tg.uncaughtThrowable = error;</span>
<span class="line-added">720                     }</span>
<span class="line-added">721                 });</span>
<span class="line-added">722             t.start();</span>
<span class="line-added">723             t.join();</span>
<span class="line-added">724             if (tg.uncaughtThrowable != null) {</span>
<span class="line-added">725                 throw new RuntimeException(tg.uncaughtThrowable);</span>
<span class="line-added">726             }</span>
<span class="line-added">727         } else {</span>
<span class="line-added">728             mainMethod.invoke(null, new Object[] { classArgs });</span>
<span class="line-added">729         }</span>
<span class="line-added">730     }</span>
<span class="line-added">731 </span>
<span class="line-added">732     static class MainThreadGroup extends ThreadGroup {</span>
<span class="line-added">733         MainThreadGroup() {</span>
<span class="line-added">734             super(&quot;MainThreadGroup&quot;);</span>
<span class="line-added">735         }</span>
<span class="line-added">736 </span>
<span class="line-added">737         public void uncaughtException(Thread t, Throwable e) {</span>
<span class="line-added">738             if (e instanceof ThreadDeath) {</span>
<span class="line-added">739                 return;</span>
<span class="line-added">740             }</span>
<span class="line-added">741             e.printStackTrace(System.err);</span>
<span class="line-added">742             uncaughtThrowable = e;</span>
<span class="line-added">743         }</span>
<span class="line-added">744         Throwable uncaughtThrowable = null;</span>
<span class="line-added">745     }</span>
746 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
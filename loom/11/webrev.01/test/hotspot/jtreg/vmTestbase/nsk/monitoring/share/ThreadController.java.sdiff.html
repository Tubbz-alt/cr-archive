<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/monitoring/share/ThreadController.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="thread/LockingThreads.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/monitoring/share/ThreadController.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
587 }
588 
589 class WaitingThread extends BaseThread {
590 
591     private static final Thread.State STATE = Thread.State.WAITING;
592     public State getState() {
593         return STATE;
594     }
595 
596     private ThreadsGroupLocks threadsGroupLocks;
597 
598     public WaitingThread(ThreadController controller, String name, Log log, ThreadsGroupLocks threadsGroupLocks) {
599         super(controller, name, log, threadsGroupLocks);
600 
601         this.threadsGroupLocks = threadsGroupLocks;
602 
603         expectedLength += 4;
604 
605         expectedMethods.add(ThreadsGroupLocks.PlainCountDownLatch.class.getName() + &quot;.await&quot;);
606         expectedMethods.add(Object.class.getName() + &quot;.wait&quot;);

607 
608         switch (controller.invocationType) {
609             case ThreadController.JAVA_TYPE:
610                 expectedMethods.add(WaitingThread.class.getName() + &quot;.bringState&quot;);
611                 break;
612             case ThreadController.NATIVE_TYPE:
613                 expectedMethods.add(WaitingThread.class.getName() + &quot;.nativeBringState&quot;);
614                 break;
615             case ThreadController.MIXED_TYPE:
616                 expectedMethods.add(WaitingThread.class.getName() + &quot;.bringState&quot;);
617 
618         }
619     }
620 
621 
622     protected void bringState() {
623         ThreadsGroupLocks.PlainCountDownLatch barrier = threadsGroupLocks.getBarrier(STATE);
624         try {
625             logger.trace(controller.THREAD_TRACE_LEVEL, &quot;waiting on a monitor&quot;);
626             threadsGroupLocks.getBarrier(getState()).countDown();
</pre>
<hr />
<pre>
635     public boolean checkState(Thread.State state) {
636         return state == STATE;
637     }
638 
639 }
640 
641 class SleepingThread extends BaseThread {
642     private static final Thread.State STATE = State.TIMED_WAITING;
643 
644     public State getState() {
645         return STATE;
646     }
647 
648     private ThreadsGroupLocks threadsGroupLocks;
649 
650     public SleepingThread(ThreadController controller, String name, Log log, ThreadsGroupLocks threadsGroupLocks) {
651         super(controller, name, log, threadsGroupLocks);
652 
653         this.threadsGroupLocks = threadsGroupLocks;
654 
<span class="line-modified">655         expectedLength += 3;</span>
656 
657         expectedMethods.add(Thread.class.getName() + &quot;.sleep&quot;);










658         expectedMethods.add(SleepingThread.class.getName() + &quot;.run&quot;);
659 
660         switch (controller.invocationType) {
661             case ThreadController.JAVA_TYPE:
662                 expectedMethods.add(SleepingThread.class.getName() + &quot;.bringState&quot;);
663                 break;
664             case ThreadController.NATIVE_TYPE:
665                  expectedMethods.add(SleepingThread.class.getName() + &quot;.nativeBringState&quot;);
666                 break;
667             case ThreadController.MIXED_TYPE:
668                  expectedMethods.add(SleepingThread.class.getName() + &quot;.bringState&quot;);
669         }
670 
671     }
672 
673     protected void bringState() {
674         try {
675             threadsGroupLocks.getBarrier(getState()).countDown();
676             Thread.sleep(3600 * 1000);
677         } catch (InterruptedException e) {
</pre>
<hr />
<pre>
702             logger.trace(controller.THREAD_TRACE_LEVEL, &quot;thread finished&quot;);
703         } catch (StackOverflowError e) {
704             logger.complain(e.toString());
705             throw new RuntimeException(e);
706         }
707     }
708 }
709 
710 class RunningThread extends BaseThread {
711     public State getState() {
712         return STATE;
713     }
714 
715     private static final Thread.State STATE = Thread.State.RUNNABLE;
716     private ThreadsGroupLocks threadsGroupLocks;
717 
718     public RunningThread(ThreadController controller, String name, Log log, ThreadsGroupLocks threadsGroupLocks) {
719         super(controller, name, log, threadsGroupLocks);
720         this.threadsGroupLocks = threadsGroupLocks;
721 
<span class="line-modified">722         expectedLength += 2;</span>
723 
724         expectedMethods.add(Thread.class.getName() + &quot;.yield&quot;);





725 
726         switch (controller.invocationType) {
727             case ThreadController.JAVA_TYPE:
728                 expectedMethods.add(RunningThread.class.getName() + &quot;.bringState&quot;);
729                 break;
730             case ThreadController.NATIVE_TYPE:
731                 expectedMethods.add(RunningThread.class.getName() + &quot;.nativeBringState&quot;);
732                 break;
733             case ThreadController.MIXED_TYPE:
734                 expectedMethods.add(RunningThread.class.getName() + &quot;.bringState&quot;);
735         }
736     }
737 
738     protected void bringState() {
739         logger.trace(controller.THREAD_TRACE_LEVEL, &quot;running loop&quot;);
740         threadsGroupLocks.getBarrier(getState()).countDown();
741         while (!threadsGroupLocks.runnableCanExit) {
742             Thread.yield();
743         }
744     }
</pre>
</td>
<td>
<hr />
<pre>
587 }
588 
589 class WaitingThread extends BaseThread {
590 
591     private static final Thread.State STATE = Thread.State.WAITING;
592     public State getState() {
593         return STATE;
594     }
595 
596     private ThreadsGroupLocks threadsGroupLocks;
597 
598     public WaitingThread(ThreadController controller, String name, Log log, ThreadsGroupLocks threadsGroupLocks) {
599         super(controller, name, log, threadsGroupLocks);
600 
601         this.threadsGroupLocks = threadsGroupLocks;
602 
603         expectedLength += 4;
604 
605         expectedMethods.add(ThreadsGroupLocks.PlainCountDownLatch.class.getName() + &quot;.await&quot;);
606         expectedMethods.add(Object.class.getName() + &quot;.wait&quot;);
<span class="line-added">607         expectedMethods.add(Object.class.getName() + &quot;.wait0&quot;);</span>
608 
609         switch (controller.invocationType) {
610             case ThreadController.JAVA_TYPE:
611                 expectedMethods.add(WaitingThread.class.getName() + &quot;.bringState&quot;);
612                 break;
613             case ThreadController.NATIVE_TYPE:
614                 expectedMethods.add(WaitingThread.class.getName() + &quot;.nativeBringState&quot;);
615                 break;
616             case ThreadController.MIXED_TYPE:
617                 expectedMethods.add(WaitingThread.class.getName() + &quot;.bringState&quot;);
618 
619         }
620     }
621 
622 
623     protected void bringState() {
624         ThreadsGroupLocks.PlainCountDownLatch barrier = threadsGroupLocks.getBarrier(STATE);
625         try {
626             logger.trace(controller.THREAD_TRACE_LEVEL, &quot;waiting on a monitor&quot;);
627             threadsGroupLocks.getBarrier(getState()).countDown();
</pre>
<hr />
<pre>
636     public boolean checkState(Thread.State state) {
637         return state == STATE;
638     }
639 
640 }
641 
642 class SleepingThread extends BaseThread {
643     private static final Thread.State STATE = State.TIMED_WAITING;
644 
645     public State getState() {
646         return STATE;
647     }
648 
649     private ThreadsGroupLocks threadsGroupLocks;
650 
651     public SleepingThread(ThreadController controller, String name, Log log, ThreadsGroupLocks threadsGroupLocks) {
652         super(controller, name, log, threadsGroupLocks);
653 
654         this.threadsGroupLocks = threadsGroupLocks;
655 
<span class="line-modified">656         expectedLength += 4;</span>
657 
658         expectedMethods.add(Thread.class.getName() + &quot;.sleep&quot;);
<span class="line-added">659         expectedMethods.add(Thread.class.getName() + &quot;.sleep0&quot;);</span>
<span class="line-added">660         expectedMethods.add(Thread.class.getName() + &quot;.getVirtualThread&quot;);</span>
<span class="line-added">661         expectedMethods.add(Thread.class.getName() + &quot;.currentCarrierThread&quot;);</span>
<span class="line-added">662         expectedMethods.add(Thread.class.getName() + &quot;.currentThread&quot;);</span>
<span class="line-added">663         expectedMethods.add(Thread.class.getName() + &quot;.currentThread0&quot;);</span>
<span class="line-added">664         expectedMethods.add(Thread.class.getName() + &quot;.sleepMillis&quot;);</span>
<span class="line-added">665         // jdk.internal.event.ThreadSleepEvent not accessible</span>
<span class="line-added">666         expectedMethods.add(&quot;jdk.internal.event.ThreadSleepEvent.&lt;clinit&gt;&quot;);</span>
<span class="line-added">667         expectedMethods.add(&quot;jdk.internal.event.ThreadSleepEvent.isEnabled&quot;);</span>
<span class="line-added">668         expectedMethods.add(&quot;jdk.internal.event.ThreadSleepEvent.isTurnedOn&quot;);</span>
669         expectedMethods.add(SleepingThread.class.getName() + &quot;.run&quot;);
670 
671         switch (controller.invocationType) {
672             case ThreadController.JAVA_TYPE:
673                 expectedMethods.add(SleepingThread.class.getName() + &quot;.bringState&quot;);
674                 break;
675             case ThreadController.NATIVE_TYPE:
676                  expectedMethods.add(SleepingThread.class.getName() + &quot;.nativeBringState&quot;);
677                 break;
678             case ThreadController.MIXED_TYPE:
679                  expectedMethods.add(SleepingThread.class.getName() + &quot;.bringState&quot;);
680         }
681 
682     }
683 
684     protected void bringState() {
685         try {
686             threadsGroupLocks.getBarrier(getState()).countDown();
687             Thread.sleep(3600 * 1000);
688         } catch (InterruptedException e) {
</pre>
<hr />
<pre>
713             logger.trace(controller.THREAD_TRACE_LEVEL, &quot;thread finished&quot;);
714         } catch (StackOverflowError e) {
715             logger.complain(e.toString());
716             throw new RuntimeException(e);
717         }
718     }
719 }
720 
721 class RunningThread extends BaseThread {
722     public State getState() {
723         return STATE;
724     }
725 
726     private static final Thread.State STATE = Thread.State.RUNNABLE;
727     private ThreadsGroupLocks threadsGroupLocks;
728 
729     public RunningThread(ThreadController controller, String name, Log log, ThreadsGroupLocks threadsGroupLocks) {
730         super(controller, name, log, threadsGroupLocks);
731         this.threadsGroupLocks = threadsGroupLocks;
732 
<span class="line-modified">733         expectedLength += 3;</span>
734 
735         expectedMethods.add(Thread.class.getName() + &quot;.yield&quot;);
<span class="line-added">736         expectedMethods.add(Thread.class.getName() + &quot;.getVirtualThread&quot;);</span>
<span class="line-added">737         expectedMethods.add(Thread.class.getName() + &quot;.currentCarrierThread&quot;);</span>
<span class="line-added">738         expectedMethods.add(Thread.class.getName() + &quot;.currentThread&quot;);</span>
<span class="line-added">739         expectedMethods.add(Thread.class.getName() + &quot;.currentThread0&quot;);</span>
<span class="line-added">740         expectedMethods.add(Thread.class.getName() + &quot;.yield0&quot;);</span>
741 
742         switch (controller.invocationType) {
743             case ThreadController.JAVA_TYPE:
744                 expectedMethods.add(RunningThread.class.getName() + &quot;.bringState&quot;);
745                 break;
746             case ThreadController.NATIVE_TYPE:
747                 expectedMethods.add(RunningThread.class.getName() + &quot;.nativeBringState&quot;);
748                 break;
749             case ThreadController.MIXED_TYPE:
750                 expectedMethods.add(RunningThread.class.getName() + &quot;.bringState&quot;);
751         }
752     }
753 
754     protected void bringState() {
755         logger.trace(controller.THREAD_TRACE_LEVEL, &quot;running loop&quot;);
756         threadsGroupLocks.getBarrier(getState()).countDown();
757         while (!threadsGroupLocks.runnableCanExit) {
758             Thread.yield();
759         }
760     }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="thread/LockingThreads.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
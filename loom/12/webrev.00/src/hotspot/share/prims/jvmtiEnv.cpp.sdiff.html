<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiEnv.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="../../../../test/hotspot/jtreg/vmTestbase/nsk/jvmti/GetThreadInfo/thrinfo001.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiEnv.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1232       // We have a valid thread_oop so we can return some thread info.
1233     }
1234   }
1235 
1236   Handle thread_obj(current_thread, thread_oop);
1237   Handle name;
1238   ThreadPriority priority;
1239   Handle     thread_group;
1240   Handle context_class_loader;
1241   bool          is_daemon;
1242 
1243   name = Handle(current_thread, java_lang_Thread::name(thread_obj()));
1244 
1245   // Support for virtual threads
1246   if (java_lang_VirtualThread::is_instance(thread_obj())) {
1247     if (!get_capabilities()-&gt;can_support_virtual_threads) {
1248       return JVMTI_ERROR_MUST_POSSESS_CAPABILITY;
1249     }
1250     priority = (ThreadPriority)JVMTI_THREAD_NORM_PRIORITY;
1251     is_daemon = true;
<span class="line-modified">1252     thread_group = Handle(current_thread, java_lang_Thread_VirtualThreads::get_THREAD_GROUP());</span>




1253   } else {
1254     priority = java_lang_Thread::priority(thread_obj());
1255     is_daemon = java_lang_Thread::is_daemon(thread_obj());
<span class="line-modified">1256     thread_group = Handle(current_thread, java_lang_Thread::threadGroup(thread_obj()));</span>




1257   }
1258 
1259   oop loader = java_lang_Thread::context_class_loader(thread_obj());
1260   context_class_loader = Handle(current_thread, loader);
1261 
1262   { const char *n;
1263 
1264     if (name() != NULL) {
1265       n = java_lang_String::as_utf8_string(name());
1266     } else {
1267       int utf8_length = 0;
1268       n = UNICODE::as_utf8((jchar*) NULL, utf8_length);
1269     }
1270 
1271     info_ptr-&gt;name = (char *) jvmtiMalloc(strlen(n)+1);
1272     if (info_ptr-&gt;name == NULL)
1273       return JVMTI_ERROR_OUT_OF_MEMORY;
1274 
1275     strcpy(info_ptr-&gt;name, n);
1276   }
</pre>
<hr />
<pre>
2304 jvmtiError
2305 JvmtiEnv::GetLocalInstance(jthread thread, jint depth, jobject* value_ptr){
2306   jvmtiError err = JVMTI_ERROR_NONE;
2307   JavaThread* java_thread = NULL;
2308   JavaThread* current_thread = JavaThread::current();
2309   // rm object is created to clean up the javaVFrame created in
2310   // doit_prologue(), but after doit() is finished with it.
2311   ResourceMark rm(current_thread);
2312   HandleMark hm(current_thread);
2313   oop thread_obj = JNIHandles::resolve_external_guard(thread);
2314 
2315   if (java_lang_VirtualThread::is_instance(thread_obj)) {
2316     // Support for virtual threads
2317     if (!get_capabilities()-&gt;can_support_virtual_threads) {
2318       return JVMTI_ERROR_MUST_POSSESS_CAPABILITY;
2319     }
2320     VM_VirtualThreadGetReceiver op(this, Handle(current_thread, thread_obj),
2321                                  current_thread, depth);
2322     VMThread::execute(&amp;op);
2323     err = op.result();
<span class="line-modified">2324     if (err == JVMTI_ERROR_NONE) { </span>
2325       *value_ptr = op.value().l;
2326     }
2327   } else {
2328     // Support for ordinary threads
2329     ThreadsListHandle tlh(current_thread);
2330     err = get_JavaThread(tlh.list(), thread, &amp;java_thread);
2331     if (err != JVMTI_ERROR_NONE) {
2332       return err;
2333     }
2334     VM_GetReceiver op(java_thread, current_thread, depth);
2335     VMThread::execute(&amp;op);
2336     err = op.result();
<span class="line-modified">2337     if (err == JVMTI_ERROR_NONE) { </span>
2338       *value_ptr = op.value().l;
2339     }
2340   }
2341   return err;
2342 } /* end GetLocalInstance */
2343 
2344 
2345 // Threads_lock NOT held
2346 // thread - NOT pre-checked
2347 // depth - pre-checked as non-negative
2348 // value_ptr - pre-checked for NULL
2349 jvmtiError
2350 JvmtiEnv::GetLocalInt(jthread thread, jint depth, jint slot, jint* value_ptr) {
2351   jvmtiError err = JVMTI_ERROR_NONE;
2352   JavaThread* java_thread = NULL;
2353   JavaThread* current_thread = JavaThread::current();
2354   // rm object is created to clean up the javaVFrame created in
2355   // doit_prologue(), but after doit() is finished with it.
2356   ResourceMark rm(current_thread);
2357   HandleMark hm(current_thread);
</pre>
</td>
<td>
<hr />
<pre>
1232       // We have a valid thread_oop so we can return some thread info.
1233     }
1234   }
1235 
1236   Handle thread_obj(current_thread, thread_oop);
1237   Handle name;
1238   ThreadPriority priority;
1239   Handle     thread_group;
1240   Handle context_class_loader;
1241   bool          is_daemon;
1242 
1243   name = Handle(current_thread, java_lang_Thread::name(thread_obj()));
1244 
1245   // Support for virtual threads
1246   if (java_lang_VirtualThread::is_instance(thread_obj())) {
1247     if (!get_capabilities()-&gt;can_support_virtual_threads) {
1248       return JVMTI_ERROR_MUST_POSSESS_CAPABILITY;
1249     }
1250     priority = (ThreadPriority)JVMTI_THREAD_NORM_PRIORITY;
1251     is_daemon = true;
<span class="line-modified">1252     if (java_lang_VirtualThread::state(thread_obj()) == java_lang_VirtualThread::TERMINATED) {</span>
<span class="line-added">1253       thread_group = Handle(current_thread, NULL);</span>
<span class="line-added">1254     } else {</span>
<span class="line-added">1255       thread_group = Handle(current_thread, java_lang_Thread_VirtualThreads::get_THREAD_GROUP());</span>
<span class="line-added">1256     }</span>
1257   } else {
1258     priority = java_lang_Thread::priority(thread_obj());
1259     is_daemon = java_lang_Thread::is_daemon(thread_obj());
<span class="line-modified">1260     if (java_lang_Thread::get_thread_status(thread_obj()) == java_lang_Thread::TERMINATED) {</span>
<span class="line-added">1261       thread_group = Handle(current_thread, NULL);</span>
<span class="line-added">1262     } else {</span>
<span class="line-added">1263       thread_group = Handle(current_thread, java_lang_Thread::threadGroup(thread_obj()));</span>
<span class="line-added">1264     }</span>
1265   }
1266 
1267   oop loader = java_lang_Thread::context_class_loader(thread_obj());
1268   context_class_loader = Handle(current_thread, loader);
1269 
1270   { const char *n;
1271 
1272     if (name() != NULL) {
1273       n = java_lang_String::as_utf8_string(name());
1274     } else {
1275       int utf8_length = 0;
1276       n = UNICODE::as_utf8((jchar*) NULL, utf8_length);
1277     }
1278 
1279     info_ptr-&gt;name = (char *) jvmtiMalloc(strlen(n)+1);
1280     if (info_ptr-&gt;name == NULL)
1281       return JVMTI_ERROR_OUT_OF_MEMORY;
1282 
1283     strcpy(info_ptr-&gt;name, n);
1284   }
</pre>
<hr />
<pre>
2312 jvmtiError
2313 JvmtiEnv::GetLocalInstance(jthread thread, jint depth, jobject* value_ptr){
2314   jvmtiError err = JVMTI_ERROR_NONE;
2315   JavaThread* java_thread = NULL;
2316   JavaThread* current_thread = JavaThread::current();
2317   // rm object is created to clean up the javaVFrame created in
2318   // doit_prologue(), but after doit() is finished with it.
2319   ResourceMark rm(current_thread);
2320   HandleMark hm(current_thread);
2321   oop thread_obj = JNIHandles::resolve_external_guard(thread);
2322 
2323   if (java_lang_VirtualThread::is_instance(thread_obj)) {
2324     // Support for virtual threads
2325     if (!get_capabilities()-&gt;can_support_virtual_threads) {
2326       return JVMTI_ERROR_MUST_POSSESS_CAPABILITY;
2327     }
2328     VM_VirtualThreadGetReceiver op(this, Handle(current_thread, thread_obj),
2329                                  current_thread, depth);
2330     VMThread::execute(&amp;op);
2331     err = op.result();
<span class="line-modified">2332     if (err == JVMTI_ERROR_NONE) {</span>
2333       *value_ptr = op.value().l;
2334     }
2335   } else {
2336     // Support for ordinary threads
2337     ThreadsListHandle tlh(current_thread);
2338     err = get_JavaThread(tlh.list(), thread, &amp;java_thread);
2339     if (err != JVMTI_ERROR_NONE) {
2340       return err;
2341     }
2342     VM_GetReceiver op(java_thread, current_thread, depth);
2343     VMThread::execute(&amp;op);
2344     err = op.result();
<span class="line-modified">2345     if (err == JVMTI_ERROR_NONE) {</span>
2346       *value_ptr = op.value().l;
2347     }
2348   }
2349   return err;
2350 } /* end GetLocalInstance */
2351 
2352 
2353 // Threads_lock NOT held
2354 // thread - NOT pre-checked
2355 // depth - pre-checked as non-negative
2356 // value_ptr - pre-checked for NULL
2357 jvmtiError
2358 JvmtiEnv::GetLocalInt(jthread thread, jint depth, jint slot, jint* value_ptr) {
2359   jvmtiError err = JVMTI_ERROR_NONE;
2360   JavaThread* java_thread = NULL;
2361   JavaThread* current_thread = JavaThread::current();
2362   // rm object is created to clean up the javaVFrame created in
2363   // doit_prologue(), but after doit() is finished with it.
2364   ResourceMark rm(current_thread);
2365   HandleMark hm(current_thread);
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="../../../../test/hotspot/jtreg/vmTestbase/nsk/jvmti/GetThreadInfo/thrinfo001.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/com/sun/javatest/TestResult.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * $Id$
   3  *
   4  * Copyright (c) 1996, 2016, Oracle and/or its affiliates. All rights reserved.
   5  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   6  *
   7  * This code is free software; you can redistribute it and/or modify it
   8  * under the terms of the GNU General Public License version 2 only, as
   9  * published by the Free Software Foundation.  Oracle designates this
  10  * particular file as subject to the &quot;Classpath&quot; exception as provided
  11  * by Oracle in the LICENSE file that accompanied this code.
  12  *
  13  * This code is distributed in the hope that it will be useful, but WITHOUT
  14  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  15  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  16  * version 2 for more details (a copy is included in the LICENSE file that
  17  * accompanied this code).
  18  *
  19  * You should have received a copy of the GNU General Public License version
  20  * 2 along with this work; if not, write to the Free Software Foundation,
  21  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  22  *
  23  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  24  * or visit www.oracle.com if you need additional information or have any
  25  * questions.
  26  */
  27 package com.sun.javatest;
  28 
  29 import com.sun.javatest.util.BackupPolicy;
  30 import com.sun.javatest.util.DynamicArray;
  31 import com.sun.javatest.util.I18NResourceBundle;
  32 import com.sun.javatest.util.PropertyArray;
  33 import com.sun.javatest.util.PropertyUtils;
  34 import com.sun.javatest.util.StringArray;
  35 
  36 import java.io.BufferedReader;
  37 import java.io.BufferedWriter;
  38 import java.io.File;
  39 import java.io.FileInputStream;
  40 import java.io.FileNotFoundException;
  41 import java.io.FileOutputStream;
  42 import java.io.IOException;
  43 import java.io.InputStreamReader;
  44 import java.io.OutputStreamWriter;
  45 import java.io.PrintWriter;
  46 import java.io.Reader;
  47 import java.io.StringReader;
  48 import java.io.Writer;
  49 import java.lang.ref.WeakReference;
  50 import java.nio.charset.StandardCharsets;
  51 import java.text.DateFormat;
  52 import java.text.ParseException;
  53 import java.text.SimpleDateFormat;
  54 import java.util.Arrays;
  55 import java.util.Collections;
  56 import java.util.Date;
  57 import java.util.Enumeration;
  58 import java.util.HashMap;
  59 import java.util.Hashtable;
  60 import java.util.Iterator;
  61 import java.util.LinkedList;
  62 import java.util.List;
  63 import java.util.Locale;
  64 import java.util.Map;
  65 import java.util.Objects;
  66 import java.util.Vector;
  67 
  68 /**
  69  * The TestResult object encapsulates the results from a test.
  70  * Test results are formatted in sections of command output,
  71  * comments and sometimes &quot;streams&quot; of output (stdout for example).
  72  * Each of these sections is represented by a (@link TestResult.Section Section).
  73  * Instances of this class are mutable until the result of the section is
  74  * set or until the result of the test itself is set.
  75  * &lt;p&gt;
  76  * Test results are stored in a structured text files.
  77  * The TestResult class serves as the API for accessing the various
  78  * components that make up the result of running a test.
  79  * The status is cached as its size is small and it is accessed often.
  80  * &lt;p&gt;
  81  * This class and inner classes will throw IllegalStateExceptions if an
  82  * attempt is made to modify the any part of the object that has been
  83  * marked immutable.
  84  */
  85 
  86 public class TestResult {
  87     /**
  88      * A code indicating that no checksum was found in a .jtr file.
  89      *
  90      * @see #getChecksumState
  91      */
  92     public static final int NO_CHECKSUM = 0;
  93     /**
  94      * A code indicating that an invalid checksum was found in a .jtr file.
  95      *
  96      * @see #getChecksumState
  97      */
  98     public static final int BAD_CHECKSUM = 1;
  99     /**
 100      * A code indicating that a good checksum was found in a .jtr file.
 101      *
 102      * @see #getChecksumState
 103      */
 104     public static final int GOOD_CHECKSUM = 2;
 105     /**
 106      * The number of different checksum states (none, good, bad).
 107      */
 108     public static final int NUM_CHECKSUM_STATES = 3;
 109     /**
 110      * The name of the default output that all Sections are equipped with.
 111      */
 112     public static final String MESSAGE_OUTPUT_NAME = &quot;messages&quot;;
 113     /**
 114      * The name of the default section that all TestResult objects are equipped with.
 115      */
 116     public static final String MSG_SECTION_NAME = &quot;script_messages&quot;;
 117     /**
 118      * The name of the property that defines the test description file.
 119      */
 120     public static final String DESCRIPTION = &quot;description&quot;;
 121 
 122 
 123     // ------------------------- PUBLIC CONSTRUCTORS -------------------------
 124     /**
 125      * The name of the property that defines the time at which the test
 126      * execution finished.
 127      */
 128     public static final String END = &quot;end&quot;;
 129     /**
 130      * The name of the property that defines the environment name.
 131      */
 132     public static final String ENVIRONMENT = &quot;environment&quot;;
 133     /**
 134      * The name of the property that defines the test execution status.
 135      */
 136     public static final String EXEC_STATUS = &quot;execStatus&quot;;
 137     /**
 138      * The name of the property that defines the OS on which JT Harness
 139      * was running when the test was run.
 140      */
 141     public static final String JAVATEST_OS = &quot;javatestOS&quot;;
 142     /**
 143      * The name of the property that defines the script that ran the test.
 144      */
 145     public static final String SCRIPT = &quot;script&quot;;
 146     /**
 147      * The name of the property that defines the test output sections
 148      * that were recorded when the test ran.
 149      */
 150     public static final String SECTIONS = &quot;sections&quot;;
 151 
 152     //------------------------ MODIFIER METHODS ------------------------------
 153     /**
 154      * The name of the property that defines the time at which the test
 155      * execution started.
 156      */
 157     public static final String START = &quot;start&quot;;
 158     /**
 159      * The name of the property that defines the test for which this is
 160      * the result object.
 161      */
 162     public static final String TEST = &quot;test&quot;;
 163     /**
 164      * The name of the property that defines which version of JT Harness
 165      * was used to run the test.
 166      */
 167     public static final String VERSION = &quot;javatestVersion&quot;;
 168     /**
 169      * The name of the property that defines the work directory for the test.
 170      */
 171     public static final String WORK = &quot;work&quot;;
 172     /**
 173      * The name of the property that defines the variety of harness in use.
 174      * Generally the full harness or the lite version.
 175      */
 176     public static final String VARIETY = &quot;harnessVariety&quot;;
 177     /**
 178      * The name of the property that defines the type of class loader used when
 179      * running the harness (classpath mode or module mode generally).
 180      */
 181     public static final String LOADER = &quot;harnessLoaderMode&quot;;
 182 
 183     //----------ACCESS FUNCTIONS (MISC)-----------------------------------------
 184     /**
 185      * DateFormat, that is used to store date into TestResult
 186      */
 187     public static final DateFormat dateFormat =
 188             new SimpleDateFormat(&quot;EEE MMM dd HH:mm:ss zzz yyyy&quot;, Locale.US);
 189     static final String EXTN = &quot;.jtr&quot;;
 190     private static final Status
 191             filesSame = Status.passed(&quot;Output file and reference file matched&quot;),
 192             filesDifferent = Status.failed(&quot;Output file and reference file were different&quot;),
 193             fileError = Status.failed(&quot;Error occurred during comparison&quot;),
 194             interrupted = Status.failed(&quot;interrupted&quot;),
 195             inProgress = Status.notRun(&quot;Test running...&quot;),
 196             incomplete = Status.notRun(&quot;Section not closed, may be incomplete&quot;),
 197             tdMismatch = Status.notRun(&quot;Old test flushed, new test description located&quot;),
 198             notRunStatus = Status.notRun(&quot;&quot;);
 199     private static final String[] emptyStringArray = new String[0];
 200     private static final Section[] emptySectionArray = new Section[0];
 201     private static final String defaultClassDir = &quot;classes&quot;;
 202     // info for reading/writing JTR files (version 1)
 203     private static final String JTR_V1_HEADER = &quot;#Test Results&quot;;
 204     private static final String JTR_V1_SECTRESULT = &quot;command result:&quot;;
 205     private static final String JTR_V1_TSTRESULT = &quot;test result:&quot;;
 206     // info for reading/writing JTR files (version 2)
 207     private static final String JTR_V2_HEADER = &quot;#Test Results (version 2)&quot;;
 208 
 209     /*
 210      * Get the title of this test. This info originally comes from the test
 211      * description, but is saved in the .jtr file as well.
 212      *
 213      * @deprecated Please query the test description for info.
 214     public String getTitle() {
 215         // hmm slight copout; would like to make sure never null in the first place
 216         String title = desc.getParameter(&quot;title&quot;);
 217         if (title == null)
 218             title = td.getRootRelativeURL();
 219     }
 220      */
 221     private static final String JTR_V2_SECTION = &quot;#section:&quot;;
 222     private static final String JTR_V2_CHECKSUM = &quot;#checksum:&quot;;
 223     private static final String JTR_V2_TESTDESC = &quot;#-----testdescription-----&quot;;
 224     private static final String JTR_V2_RESPROPS = &quot;#-----testresult-----&quot;;
 225     private static final String JTR_V2_ENVIRONMENT = &quot;#-----environment-----&quot;;
 226     private static final String JTR_V2_SECTRESULT = &quot;result: &quot;;
 227     private static final String JTR_V2_TSTRESULT = &quot;test result: &quot;;
 228     private static final String JTR_V2_SECTSTREAM = &quot;----------&quot;;
 229     private static final String lineSeparator = System.getProperty(&quot;line.separator&quot;);
 230     private static final int DEFAULT_MAX_SHRINK_LIST_SIZE = 128;
 231     private static final int maxShrinkListSize =
 232             Integer.getInteger(&quot;javatest.numCachedResults&quot;, DEFAULT_MAX_SHRINK_LIST_SIZE).intValue();
 233 
 234     //----------ACCESS FUNCTIONS (TEST STATUS)----------------------------------
 235     private static final int DEFAULT_MAX_OUTPUT_SIZE = 100000;
 236     private static final int commonOutputSize =
 237             Integer.getInteger(&quot;javatest.maxOutputSize&quot;, DEFAULT_MAX_OUTPUT_SIZE).intValue();
 238 
 239     //----------ACCESS METHODS (TEST OUTPUT)----------------------------------
 240     // because so few test results will typically be observed (e.g. at most one)
 241     // we don&#39;t use a per-instance array of observers, but instead associate any
 242     // such arrays here.
 243     private static Map&lt;TestResult, Observer[]&gt; observersTable = new Hashtable&lt;&gt;(16);
 244     private static LinkedList&lt;WeakReference&lt;TestResult&gt;&gt; shrinkList = new LinkedList&lt;&gt;();
 245     private static I18NResourceBundle i18n = I18NResourceBundle.getBundleForClass(TestResult.class);
 246     private static boolean debug = Boolean.getBoolean(&quot;debug.&quot; + TestResult.class.getName());
 247     // the following fields should be valid for all test results
 248     private File resultsFile;           // if set, location where test results are stored
 249     private Status execStatus;          // pre-compare result
 250     private String testURL;             // URL for this test, equal to the one in TD.getRootRelativeURL
 251 
 252     // -----observer methods ---------------------------------------------------
 253     private long endTime = -1;          // when test finished
 254     private byte checksumState;         // checksum state
 255     // the following fields are candidates for shrinking although not currently done
 256     private TestDescription desc;       // test description for which this is the result
 257     private String[] props;             // table of values written during test execution
 258     private String[] env;
 259 
 260     // ----- PACKAGE METHODS ---------------------------------------------------
 261 
 262     /**
 263      * Read a single minimal TestResult from a .jts stream.
 264      * The stream is not closed.
 265      * @deprecated JTS files are no longer supported
 266     TestResult(WorkDirectory workDir, DataInputStream in) throws IOException {
 267     workRelativePath = in.readUTF();
 268 
 269     // ** temp. fix ** XXX
 270     // make sure the path is in URL form with forward slashes
 271     // in the future all paths should already be of this form (TestDescription)
 272     int index = workRelativePath.indexOf(&#39;/&#39;);
 273     if (index == -1) workRelativePath = workRelativePath.replace(&#39;\\&#39;, &#39;/&#39;);
 274 
 275     resultsFile = workDir.getFile(workRelativePath.replace(&#39;/&#39;, File.separatorChar));
 276     title = in.readUTF();
 277     int esc = in.readByte();
 278     String esr = in.readUTF();
 279     execStatus = new Status(esc, esr);
 280     boolean defIsExec = in.readBoolean();
 281     if (!defIsExec) {
 282     // have to read these, per protocol
 283     int dsc = in.readByte();
 284     String dsr = in.readUTF();
 285     //ignore dsc, dsr; they used to go in defStatus
 286     }
 287     }
 288      */
 289     // this field is cleared when the test result is shrunk
 290     @java.lang.Deprecated
 291     private Section[] sections;         // sections of output written during test execution
 292     private int maxTROutputSize = 0;    // maximum output size for this test result
 293     // only valid when this TR is in a TRT, should remain when shrunk
 294     private TestResultTable.TreeNode parent;
 295 
 296     /*
 297      * @deprecated JTS files no longer supported
 298     void writeSummary(DataOutputStream out) throws IOException {
 299         out.writeUTF(workRelativePath);
 300         out.writeUTF(title);
 301         out.writeByte(execStatus.getType());
 302         out.writeUTF(execStatus.getReason());
 303         out.writeBoolean(true); // defStatus == execStatus
 304     }
 305     */
 306 
 307     /**
 308      * Construct a test result object that will be built as the test runs.
 309      * The status string will be &quot;running...&quot; rather than &quot;not run&quot;.
 310      *
 311      * @param td The test description to base this new object on.  Cannot be
 312      *           null.
 313      */
 314     public TestResult(TestDescription td) {
 315         desc = td;
 316         execStatus = inProgress;
 317         testURL = desc.getRootRelativeURL();
 318 
 319         createSection(MSG_SECTION_NAME);
 320 
 321         props = emptyStringArray;  // null implies it was discarded, not empty
 322     }
 323 
 324     /**
 325      * Reconstruct the results of a previously run test.
 326      *
 327      * @param workDir Work directory in which the tests were run
 328      * @param td      Description of the test that was run
 329      * @throws TestResult.Fault if there is a problem recreating the results
 330      *                          from the appropriate file in the work directory
 331      */
 332     public TestResult(TestDescription td, WorkDirectory workDir)
 333             throws Fault {
 334         desc = td;
 335         testURL = desc.getRootRelativeURL();
 336         execStatus = inProgress;
 337 
 338         reloadFromWorkDir(workDir);
 339     }
 340 
 341     // ----- PRIVATE METHODS ---------------------------------------------------
 342 
 343     /**
 344      * Reconstruct the results of a previously run test.
 345      *
 346      * @param file File that the results have been stored into.
 347      * @throws TestResult.ReloadFault             if there is a problem recreating the results
 348      *                                            from the given file
 349      * @throws TestResult.ResultFileNotFoundFault if there is a problem locating
 350      *                                            the given file
 351      */
 352     public TestResult(File file)
 353             throws ResultFileNotFoundFault, ReloadFault {
 354         resultsFile = file;
 355         reload();
 356 
 357         testURL = desc.getRootRelativeURL();
 358 
 359         execStatus = Status.parse(PropertyArray.get(props, EXEC_STATUS));
 360     }
 361 
 362     /**
 363      * Reconstruct the results of a previously run test.
 364      *
 365      * @param workDir          The work directory where previous results for the guven
 366      *                         test can be found.
 367      * @param workRelativePath The path to the JTR to reload, relative to the
 368      *                         workdir.
 369      * @throws TestResult.Fault if there is a problem recreating the results
 370      *                          from the given file
 371      */
 372     public TestResult(WorkDirectory workDir, String workRelativePath) throws Fault {
 373         //resultsFile = workDir.getFile(workRelativePath.replace(&#39;/&#39;, File.separatorChar));
 374         resultsFile = workDir.getFile(workRelativePath);
 375         reload();
 376 
 377         testURL = desc.getRootRelativeURL();
 378         execStatus = Status.parse(PropertyArray.get(props, EXEC_STATUS));
 379     }
 380 
 381     /**
 382      * Create a temporary test result for which can be handed around
 383      * in situations where a reasonable test result can&#39;t be created.
 384      *
 385      * @param td Description of the test
 386      * @param s  Status to associate with running the test... presumed
 387      *           to be of the Status.FAILED type.
 388      */
 389     public TestResult(TestDescription td, Status s) {
 390         desc = td;
 391         testURL = desc.getRootRelativeURL();
 392         resultsFile = null;
 393         execStatus = s;
 394         props = emptyStringArray;
 395     }
 396 
 397     /**
 398      * Read a single minimal TestResult which is capable of reloading itself.
 399      * None of the parameters may be null.
 400      *
 401      * @param url     The full URL of this test, including test id.
 402      * @param workDir The work directory location, platform specfic path.
 403      * @param status  The status that will be found in the JTR.
 404      * @throws JavaTestError Will be thrown if any params are null.
 405      */
 406     TestResult(String url, WorkDirectory workDir, Status status) {
 407         if (url == null) {
 408             throw new JavaTestError(i18n, &quot;rslt.badTestUrl&quot;);
 409         }
 410 
 411         if (workDir == null) {
 412             throw new JavaTestError(i18n, &quot;rslt.badWorkdir&quot;);
 413         }
 414 
 415         if (status == null) {
 416             throw new JavaTestError(i18n, &quot;rslt.badStatus&quot;);
 417         }
 418 
 419         testURL = url;
 420         resultsFile = workDir.getFile(getWorkRelativePath());
 421         execStatus = status;
 422     }
 423 
 424     /**
 425      * Read a single minimal TestResult which is capable of reloading itself.
 426      * None of the parameters may be null.
 427      *
 428      * @param url     The full URL of this test, including test id.
 429      * @param workDir The work directory location, platform specific path.
 430      * @param status  The status that will be found in the JTR.
 431      * @param endTime The time when that test finished execution.
 432      * @throws JavaTestError Will be thrown if any params are null.
 433      * @see #getEndTime()
 434      */
 435     TestResult(String url, WorkDirectory workDir, Status status, long endTime) {
 436         if (url == null) {
 437             throw new JavaTestError(i18n, &quot;rslt.badTestUrl&quot;);
 438         }
 439 
 440         if (workDir == null) {
 441             throw new JavaTestError(i18n, &quot;rslt.badWorkdir&quot;);
 442         }
 443 
 444         if (status == null) {
 445             throw new JavaTestError(i18n, &quot;rslt.badStatus&quot;);
 446         }
 447 
 448         testURL = url;
 449         resultsFile = workDir.getFile(getWorkRelativePath());
 450         execStatus = status;
 451         this.endTime = endTime;
 452     }
 453 
 454     /**
 455      * Create a placeholder TestResult for a test that has not yet been run.
 456      *
 457      * @param td The test description for the test
 458      * @return A test result that indicates that the test has not yet been run
 459      */
 460     public static TestResult notRun(TestDescription td) {
 461         return new TestResult(td, notRunStatus);
 462     }
 463 
 464     /**
 465      * Get the path name for the results file for a test, relative to the
 466      * work directory.  The internal separator is &#39;/&#39;.
 467      *
 468      * @param td the test description for the test in question
 469      * @return the path name for the results file for a test, relative to the
 470      * work directory
 471      */
 472     public static String getWorkRelativePath(TestDescription td) {
 473         String baseURL = td.getRootRelativePath();
 474 
 475         // add in uniquifying id if
 476         String id = td.getParameter(&quot;id&quot;);
 477         return getWorkRelativePath(baseURL, id);
 478     }
 479 
 480     /**
 481      * Get the path name for the results file for a test, relative to the
 482      * work directory.  The internal separator is &#39;/&#39;.
 483      *
 484      * @param testURL May not be null;
 485      * @return The work relative path of the JTR for this test.  Null if the
 486      * given URL is null.
 487      */
 488     public static String getWorkRelativePath(String testURL) {
 489         int pound = testURL.lastIndexOf(&#39;#&#39;);
 490         if (pound == -1)        // no test id
 491         {
 492             return getWorkRelativePath(testURL, null);
 493         } else {
 494             return getWorkRelativePath(testURL.substring(0, pound),
 495                     testURL.substring(pound + 1));
 496         }
 497     }
 498 
 499     /**
 500      * Get the path name for the results file for a test, relative to the
 501      * work directory.  The internal separator is &#39;/&#39;.
 502      *
 503      * @param baseURL May not be null;
 504      * @param testId  The test identifier that goes with the URL.  This may be null.
 505      * @return The work relative path of the JTR for this test.  Null if the
 506      * given URL is null.
 507      */
 508     public static String getWorkRelativePath(String baseURL, String testId) {
 509         StringBuilder sb = new StringBuilder(baseURL);
 510 
 511         // strip off extension
 512         stripExtn:
 513         for (int i = sb.length() - 1; i &gt;= 0; i--) {
 514             switch (sb.charAt(i)) {
 515                 case &#39;.&#39;:
 516                     sb.setLength(i);
 517                     break stripExtn;
 518                 case &#39;/&#39;:
 519                     break stripExtn;
 520             }
 521         }
 522 
 523         // add in uniquifying id if
 524         if (testId != null) {
 525             sb.append(&#39;_&#39;);
 526             sb.append(testId);
 527         }
 528 
 529         sb.append(EXTN);
 530 
 531         return sb.toString();
 532     }
 533 
 534     /**
 535      * Check if this file is or appears to be a result (.jtr) file,
 536      * according to its filename extension.
 537      *
 538      * @param f the file to be checked
 539      * @return true if this file is or appears to be a result (.jtr) file.
 540      */
 541     public static boolean isResultFile(File f) {
 542         String p = f.getPath();
 543         return p.endsWith(EXTN);
 544     }
 545 
 546     /**
 547      * Parse the date format used for timestamps, such as the start/stop timestamp.
 548      *
 549      * @param s The string containing the date to be restored.
 550      * @see #formatDate
 551      */
 552     public static synchronized Date parseDate(String s) throws ParseException {
 553         return dateFormat.parse(s);
 554     }
 555 
 556     /**
 557      * Format the date format used for timestamps, such as the start/stop timestamp.
 558      *
 559      * @param d The date object to be formatted into a string.
 560      * @see #parseDate
 561      */
 562     public static synchronized String formatDate(Date d) {
 563         return dateFormat.format(d);
 564     }
 565 
 566     /**
 567      * @deprecated Use the Section API to accomplish your task.
 568      */
 569     @java.lang.Deprecated
 570     private static Reader getLastRefOutput(TestResult tr) {
 571         try {
 572             Section lastBlk = tr.getSection(tr.getSectionCount() - 1);
 573             return new StringReader(lastBlk.getOutput(&quot;ref&quot;));
 574         } catch (ReloadFault f) {
 575             // not the best, but this method is deprecated and hopefully never
 576             // called
 577             return null;
 578         }
 579     }
 580 
 581     private static long computeChecksum(TestDescription td) {
 582         long cs = 0;
 583         for (Iterator&lt;String&gt; i = td.getParameterKeys(); i.hasNext(); ) {
 584             // don&#39;t rely on enumeration in a particular order
 585             // so simply add the checksum products together
 586             String key = i.next();
 587             cs += computeChecksum(key) * computeChecksum(td.getParameter(key));
 588         }
 589         return cs;
 590     }
 591 
 592     private static long computeChecksum(Section... sections) {
 593         long cs = sections.length;
 594         for (Section section : sections) {
 595             cs = cs * 37 + computeChecksum(section);
 596         }
 597         return cs;
 598     }
 599 
 600     private static long computeChecksum(Section s) {
 601         long cs = computeChecksum(s.getTitle());
 602         String[] names = s.getOutputNames();
 603         for (String name : names) {
 604             cs = cs * 37 + computeChecksum(name);
 605             cs = cs * 37 + computeChecksum(s.getOutput(name));
 606         }
 607         return cs;
 608     }
 609 
 610     private static long computeChecksum(String... strings) {
 611         long cs = strings.length;
 612         for (String string : strings) {
 613             cs = cs * 37 + computeChecksum(string);
 614         }
 615         return cs;
 616     }
 617 
 618     // ------------------------ OBSERVER MAINTENANCE -------------------------
 619 
 620     private static long computeChecksum(String s) {
 621         long cs = 0;
 622         for (int i = 0; i &lt; s.length(); i++) {
 623             char c = s.charAt(i);
 624             //if (!Character.isISOControl(c) || c == &#39;\n&#39;)
 625             cs = cs * 37 + c;
 626         }
 627         return cs;
 628     }
 629 
 630     private static boolean compare(Reader left, Reader right)
 631             throws Fault {
 632         try {
 633             try {
 634                 for (; ; ) {
 635                     int l = left.read(), r = right.read();
 636                     if (l != r) {
 637                         return false; // different content found
 638                     }
 639                     if (l == -1) {
 640                         return true;
 641                     }
 642                 }
 643             } finally {
 644                 left.close();
 645                 right.close();
 646             }
 647         } catch (IOException e) {
 648             throw new Fault(i18n, &quot;rslt.badCompare&quot;, e);
 649         }
 650     }
 651 
 652     private static Status shareStatus(List&lt;Map&lt;String, Status&gt;&gt; tables, Status s) {
 653         int type = s.getType();
 654         String reason = s.getReason();
 655         Status result = tables.get(type).get(reason);
 656         if (result == null) {
 657             tables.get(type).put(reason, s);
 658             result = s;
 659         }
 660 
 661         return result;
 662     }
 663 
 664     /**
 665      * Create a new section inside this test result.
 666      *
 667      * @param name The symbolic name for this new section.
 668      * @return The new section that was created.
 669      */
 670     public synchronized TestResult.Section createSection(String name) {
 671         if (!isMutable()) {
 672             throw new IllegalStateException(
 673                     &quot;This TestResult is no longer mutable!&quot;);
 674         }
 675 
 676         Section section = new Section(name);
 677         sections = DynamicArray.append(sections, section);
 678         notifyCreatedSection(section);
 679         // avoid creating output (which will cause observer messages)
 680         // before the createdSection has been notified
 681         section.createOutput(TestResult.MESSAGE_OUTPUT_NAME);
 682 
 683         return section;
 684     }
 685 
 686     /**
 687      * Add a new property value to this TestResult.
 688      *
 689      * @param name  The name of the property to be updated.
 690      * @param value The new value of the specified property.
 691      */
 692     public synchronized void putProperty(String name, String value) {
 693         // check mutability
 694         if (!isMutable()) {
 695             throw new IllegalStateException(
 696                     &quot;Cannot put property, the TestResult is no longer mutable!&quot;);
 697         }
 698 
 699         props = PropertyArray.put(props, name, value);
 700         notifyUpdatedProperty(name, value);
 701     }
 702 
 703     /**
 704      * Sets the maximum output size for the current TestResult.
 705      * The value will be used instead of the value specified
 706      * by the system property javatest.maxOutputSize.
 707      *
 708      * @param size the maximum number of characters.
 709      */
 710     public synchronized void setMaxOutputSize(int size) {
 711         if (!isMutable()) {
 712             throw new IllegalStateException(
 713                     &quot;This TestResult is no longer mutable!&quot;);
 714         }
 715         maxTROutputSize = size;
 716     }
 717 
 718     /**
 719      * Reconstruct the results of a previously run test.
 720      *
 721      * @param workDir Work directory in which the tests were run
 722      * @throws TestResult.Fault if an error occurs while reloading the results
 723      */
 724     public void reloadFromWorkDir(WorkDirectory workDir) throws Fault {
 725         // check mutability
 726         if (!isMutable()) {
 727             throw new IllegalStateException(
 728                     &quot;Cannot reload results, the TestResult is no longer mutable!&quot;);
 729         }
 730 
 731 
 732         try {
 733             resultsFile = workDir.getFile(getWorkRelativePath());
 734             props = null;
 735             sections = null;
 736             execStatus = null;
 737 
 738             reload(new InputStreamReader(new FileInputStream(resultsFile), StandardCharsets.UTF_8));
 739 
 740             // this next line is dubious since the execStatus should have
 741             // been set during the reload
 742             execStatus = Status.parse(PropertyArray.get(props, EXEC_STATUS));
 743         } catch (FileNotFoundException e) {
 744             props = emptyStringArray;
 745             env = emptyStringArray;
 746             sections = emptySectionArray;
 747             execStatus = Status.notRun(&quot;no test result file found&quot;);
 748         } catch (IOException e) {
 749             props = emptyStringArray;
 750             env = emptyStringArray;
 751             sections = emptySectionArray;
 752             execStatus = Status.error(&quot;error opening result file: &quot; + e);
 753             throw new Fault(i18n, &quot;rslt.badFile&quot;, e.toString());
 754         } catch (Fault f) {
 755             props = emptyStringArray;
 756             env = emptyStringArray;
 757             sections = emptySectionArray;
 758             execStatus = Status.error(f.getMessage());
 759             throw f;
 760         }
 761 
 762     }
 763 
 764     /**
 765      * Get info about the checksum in this object.
 766      *
 767      * @return a value indicating the validity or otherwise of the checksum
 768      * found while reading this result object.
 769      * @see #NO_CHECKSUM
 770      * @see #BAD_CHECKSUM
 771      * @see #GOOD_CHECKSUM
 772      */
 773     public byte getChecksumState() {
 774         return checksumState;
 775     }
 776 
 777     /**
 778      * A way to write comments about the test execution into the results.
 779      *
 780      * @return If this is null, then the object is in a state in which it
 781      * does not accept new messages.
 782      */
 783     public PrintWriter getTestCommentWriter() {
 784         return sections[0].getMessageWriter();
 785     }
 786 
 787     /**
 788      * Get the test name, as given by the test URL defined by
 789      * TestDescription.getRootRelativeURL().  This method &lt;em&gt;always&lt;/em&gt;
 790      * returns a useful string, representing the test name.
 791      *
 792      * @return the name of the test for which this is the result object
 793      * @see TestDescription#getRootRelativeURL
 794      */
 795     public String getTestName() {
 796         return testURL;
 797     }
 798 
 799     /**
 800      * Check whether this test result can be reloaded from a file.
 801      * This method does not validate the contents of the file.
 802      *
 803      * @return true if the result file for this object can be read
 804      */
 805     public boolean isReloadable() {
 806         return resultsFile != null &amp;&amp; resultsFile.canRead();
 807     }
 808 
 809     /**
 810      * Check whether this object has been &quot;shrunk&quot; to reduce its
 811      * memory footprint. If it has, some or all of the data will have
 812      * to be reloaded.  This method is somewhat
 813      * orthogonal to {@code isReloadable()} and should not be used as a
 814      * substitute.
 815      *
 816      * @return True if this object is currently incomplete, false otherwise.
 817      * @see #isReloadable
 818      */
 819     public boolean isShrunk() {
 820         if (!isMutable() &amp;&amp;
 821                 (desc == null ||
 822                         props == null ||
 823                         env == null ||
 824                         (sections == null &amp;&amp; execStatus != inProgress))) {
 825             return true;
 826         } else {
 827             return false;
 828         }
 829     }
 830 
 831     /**
 832      * Get the description of the test from which this result was created.
 833      * Depending on how the test result was created, this information may
 834      * not be immediately available, and may be recreated from the test
 835      * result file.
 836      *
 837      * @return the test description for this test result object
 838      * @throws TestResult.Fault if there is a problem recreating the description
 839      *                          from the results file.
 840      */
 841     public synchronized TestDescription getDescription()
 842             throws Fault {
 843         if (desc == null) {
 844             // reconstitute description (probably from file)
 845             reload();
 846         }
 847         return desc;
 848     }
 849 
 850     /**
 851      * Get the path name for the results file for this test, relative to the
 852      * work directory.  The internal separator is &#39;/&#39;.
 853      *
 854      * @return the path name for the results file for this test,
 855      * relative to the work directory
 856      */
 857     public String getWorkRelativePath() {
 858         return getWorkRelativePath(testURL);
 859     }
 860 
 861     /**
 862      * Get the name, if any, for the result file for this object.
 863      * The path information contains platform specific path separators.
 864      *
 865      * @return the name, if any, for the result file for this object
 866      */
 867     public File getFile() {
 868         return resultsFile;
 869     }
 870 
 871     public void resetFile() {
 872         resultsFile = null;
 873     }
 874 
 875     /**
 876      * Get the keys of the properties that this object has stored.
 877      *
 878      * @return the keys of the properties that this object has stored
 879      */
 880     public synchronized Enumeration&lt;String&gt; getPropertyNames() {
 881         return PropertyArray.enumerate(props);
 882     }
 883 
 884     /**
 885      * Get the value of a property of this test result.
 886      *
 887      * @param name The name of the property to be retrieved.
 888      * @return The value corresponding to the property name, null if not
 889      * found.
 890      * @throws TestResult.Fault if there is a problem
 891      *                          recreating data from the results file.
 892      */
 893     public synchronized String getProperty(String name)
 894             throws Fault {
 895         if (props == null) {
 896             // reconstitute properties
 897             // this may result in a Fault, which is okay
 898             reload();
 899         }
 900 
 901         return PropertyArray.get(props, name);
 902     }
 903 
 904     /**
 905      * Get a copy of the environment that this object has stored.
 906      *
 907      * @return a copy of the environment that this object has stored
 908      * @throws TestResult.Fault if there is a problem
 909      *                          recreating data from the results file.
 910      * @see #setEnvironment
 911      */
 912     public synchronized Map&lt;String, String&gt; getEnvironment() throws Fault {
 913         if (env == null) {
 914             // reconstitute environment
 915             // this may result in a Fault, which is okay
 916             reload();
 917         }
 918         return PropertyArray.getProperties(env);
 919     }
 920 
 921     /**
 922      * Set the environment used by this test. When the test is run,
 923      * those entries in the environment that are referenced are noted;
 924      * those entries will be recorded here in the test result object.
 925      *
 926      * @param environment the test environment used by this test.
 927      * @see #getEnvironment
 928      */
 929     public synchronized void setEnvironment(TestEnvironment environment) {
 930         if (!isMutable()) {
 931             throw new IllegalStateException(
 932                     &quot;This TestResult is no longer mutable!&quot;);
 933         }
 934         for (TestEnvironment.Element elem : environment.elementsUsed()) {
 935             // this is stunningly inefficient and should be fixed
 936             env = PropertyArray.put(env, elem.getKey(), elem.getValue());
 937         }
 938     }
 939 
 940     /**
 941      * Get the parent node in the test result table that
 942      * contains this test result object.
 943      *
 944      * @return the parent node in the test result table that
 945      * contains this test result object.
 946      */
 947     public TestResultTable.TreeNode getParent() {
 948         return parent;
 949     }
 950 
 951     /**
 952      * Set the parent node in the test result table that
 953      * contains this test result object.
 954      *
 955      * @param p the parent node in the test result table that
 956      *          contains this test result object.
 957      * @see #getParent
 958      */
 959     void setParent(TestResultTable.TreeNode p) {
 960         parent = p;
 961     }
 962 
 963     /**
 964      * Determine if the test result object is still mutable.
 965      * Test results are only mutable while they are being created, up to
 966      * the point that the final status is set.
 967      *
 968      * @return true if the test result object is still mutable,
 969      * and false otherwise
 970      */
 971     public synchronized boolean isMutable() {
 972         // must be mutable during reload (internal operation)
 973         // mutable as long as possible, to allow max time for writing log messages
 974         return execStatus == inProgress;
 975     }
 976 
 977     /**
 978      * Get the status for this test.
 979      *
 980      * @return the status for this test
 981      * @see #setStatus
 982      */
 983     public synchronized Status getStatus() {
 984         return execStatus;
 985     }
 986 
 987     /**
 988      * Set the result of this test.  This action makes this object immutable.
 989      * If a result comparison is needed, it will be done in here.
 990      *
 991      * @param stat A status object representing the outcome of the test
 992      * @see #getStatus
 993      */
 994     public synchronized void setStatus(Status stat) {
 995         if (!isMutable()) {
 996             throw new IllegalStateException(
 997                     &quot;This TestResult is no longer mutable!&quot;);
 998         }
 999 
1000         if (stat == null) {
1001             throw new IllegalArgumentException(
1002                     &quot;TestResult status cannot be set to null!&quot;);
1003         }
1004 
1005         // close out message section
1006         sections[0].setStatus(null);
1007 
1008         execStatus = stat;
1009 
1010         if (execStatus == inProgress) {
1011             execStatus = interrupted;
1012         }
1013 
1014         // verify integrity of status in all sections
1015         for (Section section : sections) {
1016             if (section.isMutable()) {
1017                 section.setStatus(incomplete);
1018             }
1019         }
1020 
1021         props = PropertyArray.put(props, SECTIONS,
1022                 StringArray.join(getSectionTitles()));
1023         props = PropertyArray.put(props, EXEC_STATUS,
1024                 execStatus.toString());
1025 
1026         // end time now required
1027         // mainly for writing in the TRC for the Last Run Filter
1028         if (PropertyArray.get(props, END) == null) {
1029             props = PropertyArray.put(props, END, formatDate(new Date()));
1030         }
1031 
1032         // this object is now immutable
1033         notifyCompleted();
1034     }
1035 
1036     /**
1037      * Find out how many sections this test result contains.
1038      *
1039      * @return The number of sections in this result.
1040      */
1041     public synchronized int getSectionCount() {
1042         if (sections != null) {
1043             return sections.length;
1044         } else if (PropertyArray.get(props, SECTIONS) != null) {
1045             return parseSectionCount(PropertyArray.get(props, SECTIONS));
1046         } else {
1047             // hum, test props are never discarded, so we have no sections
1048             return 0;
1049         }
1050     }
1051 
1052     /**
1053      * Get the section specified by index.
1054      * Remember that index 0 is the default message section.
1055      *
1056      * @param index The index of the section to be retrieved.
1057      * @return The requested section.  Will be null if the section does not exist.
1058      * @throws TestResult.ReloadFault Will occur if an error is encountered when reloading
1059      *                                JTR data.  This may be the result of a corrupt or missing JTR file.
1060      * @see #MSG_SECTION_NAME
1061      */
1062     public synchronized Section getSection(int index) throws ReloadFault {
1063         Section target;
1064 
1065         if (sections == null &amp;&amp; execStatus != inProgress) {
1066             // try to reload from file
1067             try {
1068                 reload();
1069             } catch (ReloadFault f) {
1070                 throw f;
1071             } catch (Fault f) {
1072                 throw new ReloadFault(i18n, &quot;rslt.badFile&quot;, f.getMessage());
1073             }
1074         }
1075 
1076         if (index &gt;= sections.length) {
1077             target = null;
1078         } else {
1079             target = sections[index];
1080         }
1081 
1082         return target;
1083     }
1084 
1085     /**
1086      * Get the titles of all sections in this test result.
1087      * A null result probably indicates that there are no sections.  This is
1088      * improbable since most test result object automatically have one section.
1089      *
1090      * @return The titles, one at a time in the array.  Null if the titles
1091      * do not exist or could not be determined.
1092      */
1093     public synchronized String[] getSectionTitles() {
1094         if (props == null) {
1095             try {
1096                 reload();
1097             } catch (Fault f) {
1098                 // should this maybe be a JavaTestError?
1099                 return null;
1100             }
1101         }
1102 
1103         // look for what we need from easiest to hardest source
1104         String names = PropertyArray.get(props, SECTIONS);
1105 
1106         if (names != null) {
1107             // it is cached
1108             return StringArray.split(names);
1109         } else if (sections != null) {
1110             // TR is not immutable yet, probably
1111             int numSections = getSectionCount();
1112             String[] data = new String[numSections];
1113 
1114             for (int i = 0; i &lt; numSections; i++) {
1115                 data[i] = sections[i].getTitle();
1116             }
1117 
1118             return data;
1119         } else {
1120             // hum, bad.  No sections exist and this data isn&#39;t cached
1121             // the test probably has not run
1122             return null;
1123         }
1124     }
1125 
1126     /**
1127      * Writes the TestResult into a version 2 jtr file.
1128      *
1129      * @param workDir      The work directory in which to write the results
1130      * @param backupPolicy a policy object defining what to do if a file
1131      *                     already exists with the same name as that which is about to be written.
1132      * @throws IllegalStateException This will occur if you attempt to write a result
1133      *                               which is still mutable.
1134      * @throws IOException           Occurs when the output file cannot be created or written to.
1135      *                               Under this condition, this object will change it status to an error.
1136      */
1137     public synchronized void writeResults(WorkDirectory workDir, BackupPolicy backupPolicy)
1138             throws IOException {
1139         if (isMutable()) {
1140             throw new IllegalStateException(&quot;This TestResult is still mutable - set the status!&quot;);
1141         }
1142 
1143         // could attempt a reload() I suppose
1144         if (props == null) {
1145             props = emptyStringArray;
1146         }
1147 
1148         String wrp = getWorkRelativePath(desc).replace(&#39;/&#39;, File.separatorChar);
1149         resultsFile = workDir.getFile(wrp);
1150 
1151         File resultsDir = resultsFile.getParentFile();
1152         resultsDir.mkdirs(); // ensure directory created for .jtr file
1153 
1154         File tempFile = createTempFile(workDir, backupPolicy);
1155         try {
1156             writeResults(tempFile, backupPolicy);
1157         } finally {
1158             if (tempFile.exists()) {
1159                 tempFile.delete();
1160             }
1161         }
1162     }
1163 
1164     /**
1165      * Create a temporary file to which the results can be written, before being renamed
1166      * to its real name.
1167      */
1168     // don&#39;t use File.createTempFile because of issues with the internal locking there
1169     private File createTempFile(WorkDirectory workDir, BackupPolicy backupPolicy)
1170             throws IOException {
1171         int MAX_TRIES = 100; // absurdly big limit, but a limit nonetheless
1172         for (int i = 0; i &lt; MAX_TRIES; i++) {
1173             File tempFile = new File(resultsFile.getPath() + &quot;.&quot; + i + &quot;.tmp&quot;);
1174             if (tempFile.createNewFile()) {
1175                 return tempFile;
1176             }
1177         }
1178         throw new IOException(&quot;could not create temp file for &quot; + resultsFile + &quot;: too many tries&quot;);
1179     }
1180 
1181     /**
1182      * Write the results to a temporary file, and when done, rename it to resultsFile
1183      */
1184     private void writeResults(File tempFile, BackupPolicy backupPolicy)
1185             throws IOException {
1186         Writer out;
1187         try {
1188             out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile), StandardCharsets.UTF_8));
1189         } catch (IOException e) {
1190             execStatus = Status.error(&quot;Problem writing result file for test: &quot; + getTestName());
1191             resultsFile = null; // file not successfully written after all
1192             throw e;
1193         }
1194 
1195         try {
1196             // redundant, is done in setResult
1197             // needed though if setResult isn&#39;t being called
1198             props = PropertyArray.put(props, EXEC_STATUS, execStatus.toString());
1199 
1200             // file header
1201             out.write(JTR_V2_HEADER);
1202             out.write(lineSeparator);
1203 
1204             // date and time
1205             out.write(&quot;#&quot; + new Date().toString());
1206             out.write(lineSeparator);
1207 
1208             // checksum header and data
1209             //out.write(JTR_V2_CHECKSUM);
1210             //out.write(Long.toHexString(computeChecksum()));
1211             //out.write(lineSeparator);
1212  /*
1213             if (debug) {  // debugging code
1214                 out.write(&quot;# debug: test desc checksum: &quot;);
1215                 out.write(Long.toHexString(computeChecksum(desc)));
1216                 out.write(lineSeparator);
1217 
1218                 for (Iterator iter = desc.getParameterKeys(); iter.hasNext(); ) {
1219                     // don&#39;t rely on enumeration in a particular order
1220                     // so simply add the checksum products together
1221                     String KEY = (String) (iter.next());
1222                     out.write(&quot;# debug: test desc checksum key &quot; + KEY + &quot;: &quot;);
1223                     out.write(Long.toHexString(computeChecksum(KEY) * computeChecksum(desc.getParameter(KEY))));
1224                     out.write(lineSeparator);
1225                 }
1226 
1227                 out.write(&quot;# debug: test env checksum: &quot;);
1228                 if (env == null)
1229                     out.write(&quot;null&quot;);
1230                 else
1231                     out.write(Long.toHexString(computeChecksum(env)));
1232                 out.write(lineSeparator);
1233 
1234                 out.write(&quot;# debug: test props checksum: &quot;);
1235                 out.write(Long.toHexString(computeChecksum(props)));
1236                 out.write(lineSeparator);
1237 
1238                 out.write(&quot;# debug: test sections checksum: &quot;);
1239                 out.write(Long.toHexString(computeChecksum(sections)));
1240                 out.write(lineSeparator);
1241 
1242                 for (int I = 0; I &lt; sections.length; I++) {
1243                     out.write(&quot;# debug: test section[&quot; + I + &quot;] checksum: &quot;);
1244                     out.write(Long.toHexString(computeChecksum(sections[I])));
1245                     out.write(lineSeparator);
1246 
1247                     String[] NAMES = sections[I].getOutputNames();
1248                     for (int J = 0; J &lt; NAMES.length; J++) {
1249                         out.write(&quot;# debug: test section[&quot; + I + &quot;] name=&quot; + NAMES[J] + &quot; checksum: &quot;);
1250                         out.write(Long.toHexString(computeChecksum(NAMES[J])));
1251                         out.write(lineSeparator);
1252 
1253                         out.write(&quot;# debug: test section[&quot; + I + &quot;] name=&quot; + NAMES[J] + &quot; output checksum: &quot;);
1254                         out.write(Long.toHexString(computeChecksum(sections[I].getOutput(NAMES[J]))));
1255                         out.write(lineSeparator);
1256                     }
1257                 }
1258             }*/
1259 
1260             // description header and data
1261             out.write(JTR_V2_TESTDESC);
1262             out.write(lineSeparator);
1263 
1264             Map&lt;String, String&gt; tdProps = new HashMap&lt;&gt;();
1265             desc.save(tdProps);
1266             PropertyArray.save(PropertyArray.getArray(tdProps), out);
1267             out.write(lineSeparator);
1268 
1269             // test environment header and data
1270             if (env != null) {
1271                 out.write(JTR_V2_ENVIRONMENT);
1272                 out.write(lineSeparator);
1273                 PropertyArray.save(env, out);
1274                 out.write(lineSeparator);
1275             }
1276 
1277             // test result props header and data
1278             out.write(JTR_V2_RESPROPS);
1279             out.write(lineSeparator);
1280             PropertyArray.save(props, out);
1281             out.write(lineSeparator);
1282 
1283             // get sections into memory
1284             // I hope the out stream is not the same as the resultFile!
1285             if (sections == null) {
1286                 throw new JavaTestError(&quot;Cannot write test result - it contains no sections.&quot;);
1287             }
1288 
1289             for (Section section : sections) {
1290                 section.save(out);
1291             }
1292 
1293             out.write(lineSeparator);
1294             out.write(JTR_V2_TSTRESULT);
1295             out.write(execStatus.toString());
1296             out.write(lineSeparator);
1297             out.close();
1298         }   // try
1299         catch (IOException e) {
1300             // This exception could be raised when trying to create the directory
1301             // for the test results; opening the results file, or closing it.
1302             execStatus = Status.error(&quot;Write to temp. JTR file failed (old JTR intact): &quot; +
1303                     tempFile.getPath());
1304             resultsFile = null; // file not successfully written after all
1305             throw e;
1306         }   // catch
1307 
1308         try {
1309             backupPolicy.backupAndRename(tempFile, resultsFile);
1310 
1311             // now that it has been successfully written out, make the object
1312             // a candidate for shrinking
1313             addToShrinkList();
1314         }   // try
1315         catch (IOException e) {
1316             // This exception could be raised when trying to create the directory
1317             // for the test results; opening the results file, or closing it.
1318             execStatus = Status.error(&quot;Problem writing result file: &quot; +
1319                     resultsFile.getPath());
1320             resultsFile = null; // file not successfully written after all
1321             throw e;
1322         }   // catch
1323     }
1324 
1325     /**
1326      * Add an observer to watch this test result for changes.
1327      *
1328      * @param obs the observer to be added
1329      */
1330     public synchronized void addObserver(Observer obs) {
1331         if (isMutable()) {
1332             Observer[] observers = observersTable.get(this);
1333 
1334             if (observers == null) {
1335                 observers = new Observer[0];
1336             }
1337 
1338             observers = DynamicArray.append(observers, obs);
1339             observersTable.put(this, observers);
1340         }
1341     }
1342 
1343     /**
1344      * Remove an observer that was previously added.
1345      *
1346      * @param obs the observer to be removed
1347      */
1348     public synchronized void removeObserver(Observer obs) {
1349         Observer[] observers = observersTable.get(this);
1350         if (observers == null) {
1351             return;
1352         }
1353 
1354         observers = DynamicArray.remove(observers, obs);
1355         if (observers == null) {
1356             observersTable.remove(this);
1357         } else {
1358             observersTable.put(this, observers);
1359         }
1360     }
1361 
1362     /**
1363      * Gets the time when the test was completed, or at least the time
1364      * when it&#39;s final status was set.  Be aware that if the information is
1365      * not available in memory, it will be loaded from disk.
1366      *
1367      * @return Time when this test acquired its final status setting.
1368      * @see #setStatus
1369      * @see java.util.Date
1370      */
1371     public long getEndTime() {
1372         if (endTime &lt; 0) {
1373             try {
1374                 String datestr = PropertyArray.get(props, END);
1375 
1376                 if (datestr == null) {
1377                     // this may be more expensive because it can cause a
1378                     // reload from disk
1379                     try {
1380                         datestr = getProperty(END);
1381                     } catch (Fault f) {
1382                     }
1383                 }
1384 
1385                 if (datestr != null) {
1386                     Date date = parseDate(datestr);
1387                     endTime = date.getTime();
1388                 } else {
1389                     // info not available
1390                 }
1391             } catch (ParseException e) {
1392             }
1393         }
1394 
1395         return endTime;
1396     }
1397 
1398     void shareStatus(List&lt;Map&lt;String, Status&gt;&gt; tables) {
1399         execStatus = shareStatus(tables, execStatus);
1400     }
1401 
1402     String[] getTags() {
1403         // Script or someone else could possibly do this w/the observer
1404         if (sections == null) {
1405             return null;
1406         }
1407 
1408         Vector&lt;String&gt; tagV = new Vector&lt;&gt;(sections.length * 2);
1409 
1410         for (Section section : sections) {
1411             String[] names = section.getOutputNames();
1412 
1413             Collections.addAll(tagV, names);
1414         } // outer for
1415 
1416         return tagV.toArray(new String[tagV.size()]);
1417     }
1418 
1419     /**
1420      * Insert a test description into this test results.
1421      * This will only work if the test description is currently not available.
1422      * The name in the test description must match the name of this test.
1423      *
1424      * @param td The new test description, a null value will have no effect.
1425      * @throws IllegalStateException If the state of this object fobiu
1426      * @see #isShrunk()
1427      */
1428     void setTestDescription(TestDescription td) {
1429         if (td == null) {
1430             return;
1431         }
1432 
1433         String name = td.getRootRelativeURL();
1434         if (!testURL.equals(name)) {
1435             throw new IllegalStateException();
1436         }
1437 
1438         if (desc != null) {             // compare if possible
1439             if (!desc.equals(td)) {     // test descriptions are not the same
1440                 // accept new TD, reset this TR
1441                 // reset status to a special one
1442                 execStatus = tdMismatch;
1443                 desc = td;
1444 
1445                 props = emptyStringArray;
1446                 resultsFile = null;
1447                 env = emptyStringArray;
1448                 sections = emptySectionArray;
1449 
1450                 if (isMutable()) {
1451                     createSection(MSG_SECTION_NAME);
1452                 }
1453             } else {
1454                 // TDs are equal, no action, drop thru and return
1455             }
1456         } else {
1457             desc = td;
1458         }
1459     }
1460 
1461     private long computeChecksum() {
1462         long cs = 0;
1463         cs = cs * 37 + computeChecksum(desc);
1464         // in JT2.1.1a, environment was not included in checksum,
1465         // so allow that for backward compatibility
1466         String jtv = PropertyArray.get(props, VERSION);
1467         if (env != null) {
1468             if (jtv == null || !jtv.equals(&quot;JT_2.1.1a&quot;)) {
1469                 cs = cs * 37 + computeChecksum(env);
1470             }
1471         }
1472         cs = cs * 37 + computeChecksum(props);
1473         if (sections != null) {
1474             cs = cs * 37 + computeChecksum(sections);
1475         }
1476         cs = cs * 37 + execStatus.getType() + computeChecksum(execStatus.getReason());
1477         return Math.abs(cs);  // ensure +ve, to avoid sign issues!
1478     }
1479 
1480     /**
1481      * @throws ResultFileNotFoundFault May be thrown if the JTR file cannot be found.
1482      * @throws ReloadFault             Generally describes any error which is encountered while
1483      *                                 reading or processing the input file.
1484      */
1485     private synchronized void reload()
1486             throws ResultFileNotFoundFault, ReloadFault {
1487         if (resultsFile == null) {
1488             throw new ReloadFault(i18n, &quot;rslt.noResultFile&quot;);
1489         }
1490 
1491         if (isMutable()) {
1492             throw new IllegalStateException(&quot;Cannot do a reload of this object.&quot;);
1493         }
1494 
1495         try {
1496             reload(new BufferedReader(new InputStreamReader(new FileInputStream(resultsFile), StandardCharsets.UTF_8)));
1497 
1498             // Well, we have successfully reloaded it, so the object is now taking
1499             // up a big footprint again ... put it back on the list to be shrunk again
1500             addToShrinkList();
1501         } catch (FileNotFoundException e) {
1502             throw new ResultFileNotFoundFault(i18n, &quot;rslt.fileNotFound&quot;, resultsFile);
1503         } catch (IOException e) {
1504             throw new ReloadFault(i18n, &quot;rslt.badFile&quot;, e);
1505         }
1506     }
1507 
1508     /**
1509      * @throws ReloadFault Generally describes any error which is encountered while
1510      *                     reading or processing the input file.  This may indicate
1511      *                     an empty file or incorrectly formatted file.
1512      */
1513     private void reload(Reader r)
1514             throws ReloadFault, IOException {
1515         try {
1516             BufferedReader br = new BufferedReader(r);
1517             String line = br.readLine();
1518 
1519             // determine JTR version
1520             if (line == null) {
1521                 throw new ReloadFault(i18n, &quot;rslt.empty&quot;, resultsFile);
1522             }
1523             if (line.equals(JTR_V2_HEADER)) {
1524                 reloadVersion2(br);
1525             } else if (line.equals(JTR_V1_HEADER)) {
1526                 reloadVersion1(br);
1527             } else {
1528                 throw new ReloadFault(i18n, &quot;rslt.badHeader&quot;, resultsFile);
1529             }
1530         } catch (RuntimeException e) {
1531             throw new ReloadFault(i18n, &quot;rslt.badRuntimeErr&quot;, resultsFile.getPath(), e.getLocalizedMessage());
1532         } finally {
1533             r.close();
1534         }
1535     }
1536 
1537     private void reloadVersion1(BufferedReader in)
1538             throws ReloadFault, IOException {
1539         // grab property info
1540         StringBuffer buff = new StringBuffer();
1541         String line = in.readLine();
1542         while (!(line == null) &amp;&amp; !(line.isEmpty())) {
1543             buff.append(line);
1544             buff.append(lineSeparator);
1545             line = in.readLine();
1546         }
1547 
1548         // store if needed
1549         Map&lt;String, String&gt; pairs = new HashMap&lt;&gt;();
1550         if (props == null || desc == null) {
1551             StringReader sr = new StringReader(buff.toString());
1552             buff = null;
1553             line = null;
1554 
1555             pairs = PropertyUtils.load(sr);
1556         }
1557 
1558         if (props == null) {
1559             // reload test result properties
1560             props = PropertyArray.getArray(pairs);
1561         }
1562 
1563         pairs = null;
1564 
1565         if (desc == null) {
1566             File path = new File(PropertyArray.get(props, &quot;testsuite&quot;));
1567             if (!path.isDirectory()) {
1568                 path = new File(path.getParent());
1569             }
1570             File file = new File(PropertyArray.get(props, &quot;file&quot;));
1571 
1572             uniquifyStrings(props);
1573 
1574             desc = new TestDescription(path, file,
1575                     PropertyArray.getProperties(props));
1576         }
1577 
1578         buff = new StringBuffer();
1579         line = in.readLine();
1580         while (!(line == null)) {
1581             if (line.startsWith(&quot;command: &quot;)) {
1582                 // a section
1583                 Section blk = processOldSection(line, in);
1584 
1585                 if (blk != null) {
1586                     sections = DynamicArray.append(sections, blk);
1587                 }
1588             } else if (line.startsWith(JTR_V1_TSTRESULT)) {
1589                 // test result
1590                 if (line == null) {
1591                     // couldn&#39;t get the status text for some reason
1592                 } else {
1593                     line = extractSlice(line, JTR_V1_TSTRESULT.length(), &quot; &quot;, null);
1594                     execStatus = Status.parse(line);
1595                 }   // inner else
1596 
1597                 break;
1598             } else {
1599                 // message text
1600                 buff.append(line);
1601                 buff.append(lineSeparator);
1602             }   // else
1603 
1604             line = in.readLine();
1605         }   // while
1606 
1607         // create the test message section and put first in the array
1608         Section blk = new Section(MSG_SECTION_NAME);
1609         blk.reloadOutput(MESSAGE_OUTPUT_NAME, buff.toString());
1610         Section[] tempBlks = new Section[sections.length + 1];
1611         tempBlks[0] = blk;
1612         System.arraycopy(sections, 0, tempBlks, 1, sections.length);
1613         sections = tempBlks;
1614     }
1615 
1616     private Section processOldSection(String line1, BufferedReader in)
1617             throws ReloadFault, IOException {
1618         StringBuilder sb = new StringBuilder();         // message stream
1619         Section section = null;
1620         String line = line1;
1621         while (!(line == null)) {
1622             if (line.startsWith(&quot;----------&quot;)) {
1623                 String streamName = null;
1624                 String sectionName = null;
1625                 StringBuilder buff = new StringBuilder();
1626                 int lines = 0;
1627                 int chars = 0;
1628                 try {
1629                     streamName = extractSlice(line, 10, null, &quot;:&quot;);
1630                     sectionName = extractSlice(line, 10, &quot;:&quot;, &quot;(&quot;);
1631                     lines = Integer.parseInt(extractSlice(line, 10, &quot;(&quot;, &quot;/&quot;));
1632                     chars = Integer.parseInt(extractSlice(line, 10, &quot;/&quot;, &quot;)&quot;));
1633 
1634                     for (int count = 0; count &lt; lines; count++) {
1635                         buff.append(in.readLine());
1636                     }
1637                 } catch (NumberFormatException e) {
1638                     // confused!
1639                     throw new ReloadFault(i18n, &quot;rslt.badFile&quot;, e);
1640                 }
1641 
1642                 if (section == null) {
1643                     section = new Section(sectionName);
1644                 }
1645 
1646                 section.reloadOutput(streamName, buff.toString());
1647             } else if (line.startsWith(JTR_V1_SECTRESULT)) {
1648                 // set result
1649                 if (section == null) {
1650                     section = new Section(&quot;&quot;);
1651                 }
1652 
1653                 // get the Status text
1654                 line = extractSlice(line, JTR_V1_SECTRESULT.length(), &quot; &quot;, null);
1655 
1656                 if (line == null)
1657                 // couldn&#39;t get the status text for some reason
1658                 {
1659                     throw new ReloadFault(i18n, &quot;rslt.noSectionResult&quot;);
1660                 } else {
1661                     section.reloadStatus(Status.parse(line));
1662                 }
1663 
1664                 break;
1665             } else {
1666                 // just a plain message
1667                 sb.append(line);
1668                 sb.append(lineSeparator);
1669             }
1670 
1671             line = in.readLine();
1672         }
1673 
1674         if (section != null) {
1675             section.reloadOutput(MESSAGE_OUTPUT_NAME, sb.toString());
1676         }
1677 
1678         return section;
1679     }
1680 
1681     private void reloadVersion2(BufferedReader in)
1682             throws ReloadFault, IOException {
1683         //String checksumText = null;
1684         String line;
1685 
1686         // look for optional checksum and then test description,
1687         // skipping comments
1688         while ((line = in.readLine()) != null) {
1689             if (line.equals(JTR_V2_TESTDESC)) {
1690                 break;
1691             }
1692             //else if (line.startsWith(JTR_V2_CHECKSUM)) {
1693             //checksumText = line.substring(JTR_V2_CHECKSUM.length());
1694             //}
1695             else if (!line.startsWith(&quot;#&quot;)) {
1696                 throw new ReloadFault(i18n, &quot;rslt.badLine&quot;, line);
1697             }
1698         }
1699 
1700         // this probably won&#39;t work with a normal Properties object
1701         String[] tdProps = PropertyArray.load(in);
1702 
1703         if (desc == null) {
1704             uniquifyStrings(tdProps);
1705             desc = TestDescription.load(tdProps);
1706         }
1707         tdProps = null;                // dump it
1708 
1709         // XXX compare to TD
1710 
1711         // remove comment lines and look for test env props
1712         while ((line = in.readLine()) != null) {
1713             if (line.startsWith(JTR_V2_RESPROPS)) {
1714                 break;
1715             } else if (line.startsWith(JTR_V2_ENVIRONMENT)) {
1716                 env = PropertyArray.load(in);
1717                 uniquifyStrings(env);
1718             } else if (!line.startsWith(&quot;#&quot;)) {
1719                 throw new ReloadFault(i18n, &quot;rslt.badLine&quot;, line);
1720             }
1721         }
1722 
1723         if (env == null) {
1724             env = new String[]{};
1725         }
1726 
1727         if (line == null) {
1728             throw new ReloadFault(i18n, &quot;rslt.badFormat&quot;);
1729         }
1730 
1731         String[] trProps = PropertyArray.load(in);
1732 
1733         if (props == null) {
1734             // restore the properties of this result
1735             uniquifyStrings(trProps);
1736             props = trProps;
1737         }
1738 
1739         trProps = null;             // dump it
1740 
1741         // read the sections
1742         int sectionCount = parseSectionCount(PropertyArray.get(props, SECTIONS));
1743         sections = new Section[sectionCount];
1744         for (int i = 0; i &lt; getSectionCount(); i++) {
1745             sections[i] = new Section(in);
1746         }
1747 
1748         // get the final test status
1749         while ((line = in.readLine()) != null) {
1750             if (line.startsWith(JTR_V2_TSTRESULT)) {
1751                 execStatus = Status.parse(line.substring(JTR_V2_TSTRESULT.length()));
1752                 break;
1753             }
1754         }
1755 
1756         if (execStatus == null) {
1757             execStatus = Status.error(&quot;NO STATUS RECORDED IN FILE&quot;);
1758         }
1759 
1760         // checksum support removed
1761         checksumState = NO_CHECKSUM;
1762     }
1763 
1764     /**
1765      * This method tolerates null.  It expects a list of section names - basically
1766      * a space separated list and returns the number of items there.
1767      *
1768      * @param s The section name list string to parse and count.  May be null.
1769      * @return Number of sections listed in the string.  Will be zero if the
1770      * input was null.
1771      */
1772     int parseSectionCount(String s) {
1773         if (s == null || s.isEmpty()) {
1774             return 0;
1775         }
1776 
1777         return StringArray.split(s).length;
1778     }
1779 
1780     void uniquifyStrings(String... data) {
1781         for (int i = 0; i &lt; data.length; i++)
1782         // don&#39;t do this for large strings
1783         {
1784             if (data[i] != null &amp;&amp; data[i].length() &lt; 30) {
1785                 data[i] = data[i].intern();
1786             }
1787         }
1788     }
1789 
1790     /**
1791      * Extract a substring specified by a start and end pattern (string).
1792      * The start and end strings must be single chars.
1793      *
1794      * @param s     String to do this operation on
1795      * @param where Position in the string to start at
1796      * @param start Beginning pattern for the slice, exclusive.
1797      * @param end   Ending pattern for the slice, exclusive.  Null means
1798      *              to-end-of-string.
1799      * @return The requested substring or null if error.
1800      */
1801     String extractSlice(String s, int where, String start, String end) {
1802         int startInd;
1803         int endInd;
1804 
1805         if (start == null) {
1806             startInd = where;
1807         } else {
1808             int i = s.indexOf(start, where);
1809             if (i &lt; 0) {
1810                 return null;
1811             }
1812             startInd = i + start.length();
1813         }
1814 
1815         if (end == null) {
1816             endInd = s.length();
1817         } else {
1818             endInd = s.indexOf(end, startInd);
1819             if (endInd == -1) {
1820                 return null;
1821             }
1822         }
1823 
1824         try {
1825             return s.substring(startInd, endInd);
1826         } catch (StringIndexOutOfBoundsException e) {
1827             return null;
1828         }
1829     }
1830 
1831     /**
1832      * Notify observers that a new section has been created.
1833      *
1834      * @param section The section that was created.
1835      */
1836     private synchronized void notifyCreatedSection(Section section) {
1837         Observer[] observers = observersTable.get(this);
1838         if (observers != null) {
1839             for (Observer observer : observers) {
1840                 observer.createdSection(this, section);
1841             }
1842         }
1843     }
1844 
1845     /**
1846      * Notify observers that a section has been completed.
1847      *
1848      * @param section The section that was completed.
1849      */
1850     private synchronized void notifyCompletedSection(Section section) {
1851         Observer[] observers = observersTable.get(this);
1852         if (observers != null) {
1853             for (Observer observer : observers) {
1854                 observer.completedSection(this, section);
1855             }
1856         }
1857     }
1858 
1859     /**
1860      * Notify observers that new output is being created.
1861      *
1862      * @param section    The section that was created.
1863      * @param outputName The name of the output.
1864      */
1865     private synchronized void notifyCreatedOutput(Section section, String outputName) {
1866         Observer[] observers = observersTable.get(this);
1867         if (observers != null) {
1868             for (Observer observer : observers) {
1869                 observer.createdOutput(this, section, outputName);
1870             }
1871         }
1872     }
1873 
1874     /**
1875      * Notify observers that a particular output has been completed.
1876      *
1877      * @param section    The section that was completed.
1878      * @param outputName The name of the output.
1879      */
1880     private synchronized void notifyCompletedOutput(Section section, String outputName) {
1881         Observer[] observers = observersTable.get(this);
1882         if (observers != null) {
1883             for (Observer observer : observers) {
1884                 observer.completedOutput(this, section, outputName);
1885             }
1886         }
1887     }
1888 
1889     /**
1890      * Notify all observers that new data has been written to some output.
1891      *
1892      * @param section    The section being modified.
1893      * @param outputName The stream of the section that is being modified.
1894      * @param text       The text that was added (appended).
1895      */
1896     private synchronized void notifyUpdatedOutput(Section section, String outputName, int start, int end, String text) {
1897         Observer[] observers = observersTable.get(this);
1898         if (observers != null) {
1899             for (Observer observer : observers) {
1900                 observer.updatedOutput(this, section, outputName, start, end, text);
1901             }
1902         }
1903     }
1904 
1905     /**
1906      * Notify all observers that new data has been written to some output.
1907      *
1908      * @param section    The section being modified.
1909      * @param outputName The stream of the section that is being modified.
1910      */
1911     private synchronized void notifyUpdatedOutput(Section section, String outputName, int start, int end,
1912                                                   char[] buf, int offset, int len) {
1913         Observer[] observers = observersTable.get(this);
1914         if (observers != null) {
1915             // only create string if there are really observers who want to see it
1916             String text = new String(buf, offset, len);
1917             for (Observer observer : observers) {
1918                 observer.updatedOutput(this, section, outputName, start, end, text);
1919             }
1920         }
1921     }
1922 
1923     /**
1924      * Notify all observers that a property has been updated.
1925      *
1926      * @param key   The key for the property that was modified.
1927      * @param value The new value for the property.
1928      */
1929     private synchronized void notifyUpdatedProperty(String key, String value) {
1930         Observer[] observers = observersTable.get(this);
1931         if (observers != null) {
1932             for (Observer observer : observers) {
1933                 observer.updatedProperty(this, key, value);
1934             }
1935         }
1936     }
1937 
1938     /**
1939      * Notify observers the test has completed.
1940      */
1941     private synchronized void notifyCompleted() {
1942         // since there will be no more observer messages after this, there
1943         // is no need to keep any observers registered after we finish here
1944         // so get the observers one last time, and at the same time
1945         // remove them from the table
1946         Observer[] observers = observersTable.remove(this);
1947         if (observers != null) {
1948             for (Observer observer : observers) {
1949                 observer.completed(this);
1950             }
1951             observersTable.remove(this);
1952         }
1953 
1954     }
1955 
1956     /**
1957      * @return Position of the specified section, or -1 if not found.
1958      */
1959     private synchronized int findSection(String name) {
1960         int location;
1961 
1962         if (sections == null || sections.length == 0) {
1963             return -1;
1964         }
1965 
1966         for (location = 0; location &lt; sections.length; location++) {
1967             if (sections[location].getTitle().equals(name)) {
1968                 // found
1969                 break;
1970             }
1971         }   // for
1972 
1973         // loop exited because of counter, not a hit
1974         if (location == sections.length) {
1975             location = -1;
1976         }
1977 
1978         return location;
1979     }
1980 
1981     private void addToShrinkList() {
1982         synchronized (shrinkList) {
1983             // if this object is in the list; remove it;
1984             // if there are dead weak refs, remove them
1985             for (Iterator&lt;WeakReference&lt;TestResult&gt;&gt; iter = shrinkList.iterator(); iter.hasNext(); ) {
1986                 WeakReference&lt;TestResult&gt; wref = iter.next();
1987                 Object o = wref.get();
1988                 if (o == null || o == this) {
1989                     iter.remove();
1990                 }
1991             }
1992             while (shrinkList.size() &gt;= maxShrinkListSize) {
1993                 WeakReference&lt;TestResult&gt; wref = shrinkList.removeFirst();
1994                 TestResult tr = wref.get();
1995                 if (tr != null) {
1996                     tr.shrink();
1997                 }
1998             }
1999             shrinkList.addLast(new WeakReference&lt;&gt;(this));
2000         }
2001     }
2002 
2003     /**
2004      * Tells the object that it can optimize itself for a small memory footprint.
2005      * Doing this may sacrifice performance when accessing object data.  This
2006      * only works on results that are immutable.
2007      */
2008     private synchronized void shrink() {
2009         if (isMutable()) {
2010             throw new IllegalStateException(&quot;Can&#39;t shrink a mutable test result!&quot;);
2011         }
2012 
2013         // Should ensure we have a resultsFile.
2014         sections = null;
2015 
2016         // NOTE: if either of these are discarded, it may be a good idea to
2017         //       optimize reload() to not read the section/stream data since
2018         //       a small property lookup could incur a huge overhead
2019         //props = null;         // works, may or may-not improve memory usage
2020         //desc = null;          // doesn&#39;t work in current implementation
2021     }
2022 
2023     /**
2024      * An interface to observe activity in a TestResult as it is created.
2025      */
2026     public interface Observer {
2027         /**
2028          * A new section has been created in the test result.
2029          *
2030          * @param tr      The test result in which the section was created.
2031          * @param section The section that has been created
2032          */
2033         void createdSection(TestResult tr, Section section);
2034 
2035         /**
2036          * A section has been been completed in the test result.
2037          *
2038          * @param tr      The test result containing the section.
2039          * @param section The section that has been completed.
2040          */
2041         void completedSection(TestResult tr, Section section);
2042 
2043         /**
2044          * New output has been created in a section of the test result.
2045          *
2046          * @param tr         The test result containing the output.
2047          * @param section    The section in which the output has been created.
2048          * @param outputName The name of the output.
2049          */
2050         void createdOutput(TestResult tr, Section section, String outputName);
2051 
2052         /**
2053          * Output has been completed in a section of the test result.
2054          *
2055          * @param tr         The test result containing the output.
2056          * @param section    The section in which the output has been completed.
2057          * @param outputName The name of the output.
2058          */
2059         void completedOutput(TestResult tr, Section section, String outputName);
2060 
2061         /**
2062          * The output for a section has been updated.
2063          *
2064          * @param tr         The test result object being modified.
2065          * @param section    The section in which the output is being produced.
2066          * @param outputName The name of the output.
2067          * @param start      the start offset of the text that was changed
2068          * @param end        the end offset of the text that was changed
2069          * @param text       the text that replaced the specified range.
2070          */
2071         void updatedOutput(TestResult tr, Section section, String outputName, int start, int end, String text);
2072 
2073         /**
2074          * A property of the test result has been updated.
2075          *
2076          * @param tr    The test result containing the property that was modified.
2077          * @param name  The key for the property that was modified.
2078          * @param value The new value for the property.
2079          */
2080         void updatedProperty(TestResult tr, String name, String value);
2081 
2082         /**
2083          * The test has completed, and the results are now immutable.
2084          * There will be no further observer calls.
2085          *
2086          * @param tr The test result that has been completed.
2087          */
2088         void completed(TestResult tr);
2089 
2090     }
2091     // Conceptually, this belongs in Section, but that is not legal Java.
2092     // (It is accepted in  1.1.x; rejected by 1.2)
2093     private interface OutputBuffer {
2094         String getName();
2095 
2096         String getOutput();
2097 
2098         PrintWriter getPrintWriter();
2099     }
2100 
2101     @Override
2102     public String toString() {
2103         return &quot;TestResult{&quot; +
2104                 &quot;resultsFile=&quot; + resultsFile +
2105                 &quot;, execStatus=&quot; + execStatus +
2106                 &quot;, testURL=&#39;&quot; + testURL + &#39;\&#39;&#39; +
2107                 &quot;, endTime=&quot; + endTime +
2108                 &quot;, checksumState=&quot; + checksumState +
2109                 &quot;, desc=&quot; + desc +
2110                 &quot;, props=&quot; + Arrays.toString(props) +
2111                 &quot;, env=&quot; + Arrays.toString(env) +
2112                 &quot;, sections=&quot; + Arrays.toString(sections) +
2113                 &quot;, maxTROutputSize=&quot; + maxTROutputSize +
2114                 &quot;, parent=&quot; + parent +
2115                 &#39;}&#39;;
2116     }
2117 
2118     /**
2119      * This exception is to report problems using TestResult objects.
2120      */
2121     public static class Fault extends Exception {
2122         Fault(I18NResourceBundle i18n, String key) {
2123             super(i18n.getString(key));
2124         }
2125 
2126         Fault(I18NResourceBundle i18n, String key, Object arg) {
2127             super(i18n.getString(key, arg));
2128         }
2129 
2130         Fault(I18NResourceBundle i18n, String key, Object... args) {
2131             super(i18n.getString(key, args));
2132         }
2133     }
2134 
2135     /**
2136      * This exception is thrown if the JTR file cannot be found.
2137      */
2138     public static class ResultFileNotFoundFault extends Fault {
2139         ResultFileNotFoundFault(I18NResourceBundle i18n, String key) {
2140             super(i18n, key);
2141         }
2142 
2143         ResultFileNotFoundFault(I18NResourceBundle i18n, String key, Object arg) {
2144             super(i18n, key, arg);
2145         }
2146 
2147         ResultFileNotFoundFault(I18NResourceBundle i18n, String key, Object... args) {
2148             super(i18n, key, args);
2149         }
2150     }
2151 
2152     /**
2153      * This exception ay occur anytime the JTR file is being read from the filesystem.
2154      * To optimize memory usage, the contents of a TestResult object are sometimes
2155      * discarded and then loaded on demand from the JTR file.  If a fault occurs
2156      * when reading the JTR file, this fault may occur.
2157      *
2158      * @see TestResult.ResultFileNotFoundFault
2159      */
2160     public static class ReloadFault extends Fault {
2161         ReloadFault(I18NResourceBundle i18n, String key) {
2162             super(i18n, key);
2163         }
2164 
2165         ReloadFault(I18NResourceBundle i18n, String key, Object arg) {
2166             super(i18n, key, arg);
2167         }
2168 
2169         ReloadFault(I18NResourceBundle i18n, String key, Object... args) {
2170             super(i18n, key, args);
2171         }
2172     }
2173 
2174     private static class LockedWriter extends PrintWriter {
2175         public LockedWriter(Writer out, Object theLock) {
2176             super(out);
2177             lock = theLock;
2178         }
2179     }
2180 
2181     /**
2182      * This &quot;section&quot; is the logical combination of a single action during test
2183      * execution.  It is designed to hold multiple (or none) buffers of
2184      * output from test execution, such as stdout and stderr.  In addition,
2185      * it has a &quot;comment&quot; field for tracking the test run itself (progress).
2186      * This output is identified by the MSG_SECTION_NAME identifier.
2187      */
2188     public class Section {
2189         private OutputBuffer[] buffers = new OutputBuffer[0];
2190         private String title;
2191         private Status result;
2192 
2193         public Section(String title) {
2194             if (title == null) {
2195                 throw new NullPointerException();
2196             }
2197             if (title.indexOf(&#39; &#39;) != -1) {
2198                 throw new IllegalArgumentException(&quot;space invalid in section title&quot;);
2199             }
2200 
2201             this.title = title;
2202             result = inProgress;
2203         }
2204 
2205         /**
2206          * Could be used to reconstruct the section from a stream.
2207          * Reads from the source until it finds a section header.  This is a JTR
2208          * version 2 method, don&#39;t use it for version 1 files.  The object
2209          * immediately immutable upon return from this constructor.
2210          *
2211          * @throws ReloadFault Probably an error while parsing the input stream.
2212          */
2213         Section(BufferedReader in) throws IOException, ReloadFault {
2214             String line = in.readLine();
2215             // find top of section and process it
2216             while (line != null) {
2217                 if (line.startsWith(JTR_V2_SECTION)) {
2218                     title = extractSlice(line, 0, &quot;:&quot;, null);
2219                     break;
2220                 } else
2221                 // don&#39;t know what this line is, may be empty
2222                 {
2223                     line = in.readLine();
2224                 }
2225             }
2226 
2227             if (title == null) {
2228                 throw new ReloadFault(i18n, &quot;rslt.noSectionTitle&quot;);
2229             }
2230 
2231             if (title.equals(MSG_SECTION_NAME)) {
2232                 // use standard internal copy of string
2233                 title = MSG_SECTION_NAME;
2234             }
2235 
2236             while ((line = in.readLine()).startsWith(JTR_V2_SECTSTREAM)) {
2237                 OutputBuffer b = new FixedOutputBuffer(line, in);
2238                 buffers = DynamicArray.append(buffers, b);
2239             }
2240 
2241             // if not in the message section, line should have the section result
2242             if (!Objects.equals(title, MSG_SECTION_NAME)) {
2243                 if (line != null) {
2244                     if (line.startsWith(JTR_V2_SECTRESULT)) {
2245                         result = Status.parse(line.substring(JTR_V2_SECTRESULT.length()));
2246                     } else {
2247                         throw new ReloadFault(i18n, &quot;rslt.badLine&quot;, line);
2248                     }
2249                 }
2250                 if (result == null)
2251                 // no test result
2252                 {
2253                     throw new ReloadFault(i18n, &quot;rslt.noSectionResult&quot;);
2254                 }
2255             }
2256         }
2257 
2258         /**
2259          * Query if the section is still writable or not.
2260          *
2261          * @return true if the section is still writable, and false otherwise
2262          */
2263         public boolean isMutable() {
2264             synchronized (TestResult.this) {
2265                 synchronized (this) {
2266                     return TestResult.this.isMutable() &amp;&amp;
2267                             this.result == inProgress;
2268                 }
2269             }
2270         }
2271 
2272         /**
2273          * Find out what the result of the execution of this section was.
2274          *
2275          * @return the result of the execution of this section
2276          * @see #setStatus
2277          */
2278         public Status getStatus() {
2279             return result;
2280         }
2281 
2282         /**
2283          * Set the result of this section.  This action makes this section
2284          * immutable.
2285          *
2286          * @param result The status to set as the result of this section of the test
2287          * @see #getStatus
2288          */
2289         public void setStatus(Status result) {
2290             synchronized (TestResult.this) {
2291                 synchronized (this) {
2292                     checkMutable();
2293                     for (OutputBuffer b : buffers) {
2294                         if (b instanceof WritableOutputBuffer) {
2295                             WritableOutputBuffer wb = (WritableOutputBuffer) b;
2296                             wb.getPrintWriter().close();
2297                         }
2298                     }
2299                     if (env == null) {
2300                         env = emptyStringArray;
2301                     }
2302                     this.result = result;
2303                     if (env == null) {
2304                         env = emptyStringArray;
2305                     }
2306                     notifyCompletedSection(this);
2307                 }
2308             }
2309         }
2310 
2311         /**
2312          * Get the title of this section, specified when the section
2313          * was created.
2314          *
2315          * @return the title of this section
2316          */
2317         public String getTitle() {
2318             return title;
2319         }
2320 
2321         /**
2322          * Get the appropriate to writer to access the default message field.
2323          *
2324          * @return a Writer to access the default message field
2325          */
2326         public PrintWriter getMessageWriter() {
2327             synchronized (TestResult.this) {
2328                 synchronized (this) {
2329                     checkMutable();
2330                     // if it is mutable, it must have a message stream,
2331                     // which will be the first entry
2332                     return buffers[0].getPrintWriter();
2333                 }
2334             }
2335         }
2336 
2337         // ---------- PACKAGE PRIVATE ----------
2338 
2339         /**
2340          * Find out how many output buffers this section has inside it.
2341          *
2342          * @return The number of output buffers in use (&amp;gt;=0).
2343          */
2344         public synchronized int getOutputCount() {
2345             return buffers.length;
2346         }
2347 
2348         /**
2349          * Add a new output buffer to the section; get PrintWriter access to it.
2350          *
2351          * @param name The symbolic name that will identify this new stream.
2352          * @return A PrintWriter that gives access to the new stream.
2353          */
2354         public PrintWriter createOutput(String name) {
2355             if (name == null) {
2356                 throw new NullPointerException();
2357             }
2358 
2359             synchronized (TestResult.this) {
2360                 synchronized (this) {
2361                     checkMutable();
2362 
2363                     OutputBuffer b = new WritableOutputBuffer(name);
2364                     buffers = DynamicArray.append(buffers, b);
2365 
2366                     notifyCreatedOutput(this, name);
2367 
2368                     return b.getPrintWriter();
2369                 }
2370             }
2371         }
2372 
2373         /**
2374          * Get the content that was written to a specified output stream.
2375          *
2376          * @param name the name of the stream in question
2377          * @return All the data that was written to the specified output,
2378          * or null if nothing has been written.
2379          */
2380         public String getOutput(String name) {
2381             if (name == null) {
2382                 throw new NullPointerException();
2383             }
2384 
2385             synchronized (TestResult.this) {
2386                 synchronized (this) {
2387                     OutputBuffer b = findOutputBuffer(name);
2388                     return b == null ? null : b.getOutput();
2389                 }
2390             }
2391         }
2392 
2393         /**
2394          * Find out the symbolic names of all the streams in this section.  You
2395          * can use getOutputCount to discover the number of items in
2396          * this enumeration (not a thread safe activity in the strictest
2397          * sense of course).
2398          *
2399          * @return A list of strings which are the symbolic names of the streams in this section.
2400          * @see #getOutputCount
2401          */
2402         public synchronized String[] getOutputNames() {
2403             String[] names = new String[buffers.length];
2404 
2405             for (int i = 0; i &lt; buffers.length; i++) {
2406                 names[i] = buffers[i].getName();
2407                 if (names[i] == null) {
2408                     throw new IllegalStateException(&quot;BUFFER IS BROKEN&quot;);
2409                 }
2410             }
2411 
2412             return names;
2413         }
2414 
2415         /**
2416          * Removes any data added to the named output up to this point, resetting
2417          * it to an empty state.
2418          *
2419          * @param name The output name to erase the content of.
2420          * @since 4.2.1
2421          */
2422         public synchronized void deleteOutputData(String name) {
2423             if (name == null) {
2424                 throw new NullPointerException();
2425             }
2426 
2427             synchronized (TestResult.this) {
2428                 synchronized (this) {
2429                     OutputBuffer b = findOutputBuffer(name);
2430                     if (b != null &amp;&amp; b instanceof WritableOutputBuffer) {
2431                         ((WritableOutputBuffer) b).deleteAllOutput();
2432                     }
2433                 }
2434             }
2435         }
2436 
2437         // ---------- PRIVATE ----------
2438 
2439         void save(Writer out) throws IOException {
2440             out.write(JTR_V2_SECTION + getTitle());
2441             out.write(lineSeparator);
2442 
2443             for (OutputBuffer buffer : buffers) {
2444                 String text = buffer.getOutput();
2445                 TextScanResult scanRes = TextScanResult.scan(text);
2446 
2447                 out.write(JTR_V2_SECTSTREAM);
2448                 out.write(buffer.getName());
2449                 out.write(&quot;:&quot;);
2450                 out.write(&#39;(&#39;);
2451                 out.write(String.valueOf(scanRes.numLines));
2452                 out.write(&#39;/&#39;);
2453                 if (scanRes.needsEscape) {
2454                     // count one per character, plus an additional one per \ (written as &quot;\ \&quot;) and an
2455                     // additional 5 per nonASCII (written as &quot;\ u x x x x&quot;)
2456                     out.write(String.valueOf(text.length() + scanRes.numBackslashes + 5 * scanRes.numNonASCII));
2457                 } else {
2458                     out.write(String.valueOf(text.length()));
2459                 }
2460                 out.write(&#39;)&#39;);
2461                 if (scanRes.needsEscape) {
2462                     out.write(&#39;*&#39;);
2463                 }
2464                 out.write(JTR_V2_SECTSTREAM);
2465                 out.write(lineSeparator);
2466 
2467                 if (scanRes.needsEscape) {
2468                     for (int i = 0; i &lt; text.length(); i++) {
2469                         char c = text.charAt(i);
2470                         if (32 &lt;= c &amp;&amp; c &lt; 127 &amp;&amp; c != &#39;\\&#39;) {
2471                             out.write(c);
2472                         } else {
2473                             switch (c) {
2474                                 case &#39;\n&#39;:
2475                                 case &#39;\r&#39;:
2476                                 case &#39;\t&#39;:
2477                                     out.write(c);
2478                                     break;
2479                                 case &#39;\\&#39;:
2480                                     out.write(&quot;\\\\&quot;);
2481                                     break;
2482                                 default:
2483                                     out.write(&quot;\\u&quot;);
2484                                     out.write(Character.forDigit((c &gt;&gt; 12) &amp; 0xF, 16));
2485                                     out.write(Character.forDigit((c &gt;&gt; 8) &amp; 0xF, 16));
2486                                     out.write(Character.forDigit((c &gt;&gt; 4) &amp; 0xF, 16));
2487                                     out.write(Character.forDigit((c &gt;&gt; 0) &amp; 0xF, 16));
2488                                     break;
2489                             }
2490                         }
2491                     }
2492                 } else {
2493                     out.write(text);
2494                 }
2495 
2496                 if (scanRes.needsFinalNewline) {
2497                     out.write(lineSeparator);
2498                 }
2499             }
2500 
2501             // the default message section does not need a result line
2502             if (!Objects.equals(getTitle(), MSG_SECTION_NAME)) {
2503                 out.write(JTR_V2_SECTRESULT + result.toString());
2504                 out.write(lineSeparator);
2505             }
2506 
2507             out.write(lineSeparator);
2508         }
2509 
2510         /**
2511          * Reload an output block. This method is called while reloading
2512          * a test result and so bypasses the normal immutability checks.
2513          */
2514         synchronized void reloadOutput(String name, String data) {
2515             if (name.equals(MESSAGE_OUTPUT_NAME)) {
2516                 name = MESSAGE_OUTPUT_NAME;
2517             }
2518             OutputBuffer b = new FixedOutputBuffer(name, data);
2519             buffers = DynamicArray.append(buffers, b);
2520         }
2521 
2522         /**
2523          * Reload the status. This method is called while reloading
2524          * a test result and so bypasses the normal immutability checks.
2525          */
2526         synchronized void reloadStatus(Status s) {
2527             result = s;
2528         }
2529 
2530         private void checkMutable() {
2531             if (!isMutable()) {
2532                 throw new IllegalStateException(&quot;This section of the test result is now immutable.&quot;);
2533             }
2534         }
2535 
2536         private synchronized void makeOutputImmutable(OutputBuffer b, String name, String output) {
2537             for (int i = 0; i &lt; buffers.length; i++) {
2538                 if (buffers[i] == b) {
2539                     buffers[i] = new FixedOutputBuffer(name, output);
2540                     return;
2541                 }
2542             }
2543         }
2544 
2545         private synchronized OutputBuffer findOutputBuffer(String name) {
2546             // search backwards
2547             // may help in some backward compatibility cases since the most
2548             // recent stream with that name will be found
2549             // performance of the search will still be constant
2550             for (int i = buffers.length - 1; i &gt;= 0; i--) {
2551                 if (name.equals(buffers[i].getName())) {
2552                     return buffers[i];
2553                 }
2554             }
2555 
2556             return null;
2557         }
2558 
2559         private class FixedOutputBuffer implements OutputBuffer {
2560             private final String name;
2561             private final String output;
2562 
2563             FixedOutputBuffer(String name, String output) {
2564                 if (name == null || output == null) {
2565                     throw new NullPointerException();
2566                 }
2567 
2568                 this.name = name;
2569                 this.output = output;
2570             }
2571 
2572             FixedOutputBuffer(String header, BufferedReader in) throws ReloadFault {
2573                 String nm = extractSlice(header, JTR_V2_SECTSTREAM.length(), null, &quot;:&quot;);
2574                 if (nm == null) {
2575                     throw new ReloadFault(i18n, &quot;rslt.noOutputTitle&quot;);
2576                 }
2577 
2578                 if (nm.equals(MESSAGE_OUTPUT_NAME)) {
2579                     nm = MESSAGE_OUTPUT_NAME;
2580                 }
2581 
2582                 try {
2583                     int lines;
2584                     int chars;
2585                     boolean needsEscape;
2586 
2587                     try {
2588                         int start = JTR_V2_SECTSTREAM.length();
2589                         lines = Integer.parseInt(extractSlice(header, start, &quot;(&quot;, &quot;/&quot;));
2590                         chars = Integer.parseInt(extractSlice(header, start, &quot;/&quot;, &quot;)&quot;));
2591                         int rp = header.indexOf(&#39;)&#39;, start);
2592                         if (rp &gt;= 0 &amp;&amp; rp &lt; header.length() - 2) {
2593                             needsEscape = header.charAt(rp + 1) == &#39;*&#39;;
2594                         } else {
2595                             needsEscape = false;
2596                         }
2597                     } catch (NumberFormatException e) {
2598                         // fatal parsing error
2599                         throw new ReloadFault(i18n, &quot;rslt.badHeaderVersion&quot;, e);
2600                     }
2601 
2602                     StringBuilder buff = new StringBuilder(chars);
2603 
2604                     if (needsEscape) {
2605                         for (int i = 0; i &lt; chars; i++) {
2606                             int c = in.read();
2607                             if (c == -1) {
2608                                 throw new ReloadFault(i18n, &quot;rslt.badEOF&quot;);
2609                             } else if (c == &#39;\\&#39;) {
2610                                 c = in.read();
2611                                 i++;
2612                                 if (c == &#39;u&#39;) {
2613                                     c = Character.digit((char) in.read(), 16) &lt;&lt; 12;
2614                                     c += Character.digit((char) in.read(), 16) &lt;&lt; 8;
2615                                     c += Character.digit((char) in.read(), 16) &lt;&lt; 4;
2616                                     c += Character.digit((char) in.read(), 16);
2617                                     i += 4;
2618                                 }
2619                                 // else drop through (for \\)
2620                             }
2621                             buff.append((char) c);
2622                         }
2623                     } else {
2624                         char[] data = new char[Math.min(4096, chars)];
2625                         int charsRead = 0;
2626                         while (charsRead &lt; chars) {
2627                             int n = in.read(data, 0, Math.min(data.length, chars - charsRead));
2628 
2629                             // sanity check, may be truncated file
2630                             if (n &lt; 0) {
2631                                 throw new ReloadFault(i18n, &quot;rslt.badRuntimeErr&quot;, resultsFile, Integer.toString(n));
2632                             }
2633 
2634                             buff.append(data, 0, n);
2635                             charsRead += n;
2636                         }
2637                     }
2638 
2639                     /*NEW
2640                     while (true) {
2641                         int c = in.read();
2642                         switch (c) {
2643                         case -1:
2644                             throw new ReloadFault(i18n, &quot;rslt.badEOF&quot;);
2645 
2646                         case &#39;\\&#39;:
2647                             if (needEscape) {
2648                                 c = in.read();
2649                                 if (c == &#39;u&#39;) {
2650                                     c =  Character.digit((char)in.read(), 16) &lt;&lt; 12;
2651                                     c += Character.digit((char)in.read(), 16) &lt;&lt;  8;
2652                                     c += Character.digit((char)in.read(), 16) &lt;&lt;  4;
2653                                     c += Character.digit((char)in.read(), 16);
2654                                 }
2655                                 // else drop through (for \\)
2656                             }
2657                             buff.append((char)c);
2658                         }
2659                     }
2660                     */
2661 
2662                     name = nm;
2663                     output = buff.toString();
2664 
2665                     if (buff.length() &gt; 0 &amp;&amp; buff.charAt(buff.length() - 1) != &#39;\n&#39;) {
2666                         int c = in.read();
2667                         if (c == &#39;\r&#39;) {
2668                             c = in.read();
2669                         }
2670                         if (c != &#39;\n&#39;) {
2671                             System.err.println(&quot;TR.badChars: output=&quot; + (output.length() &lt; 32 ? output : output.substring(0, 9) + &quot; ... &quot; + output.substring(output.length() - 10)));
2672                             System.err.println(&quot;TR.badChars: &#39;&quot; + (char) c + &quot;&#39; (&quot; + c + &quot;)&quot;);
2673                             throw new ReloadFault(i18n, &quot;rslt.badChars&quot;, name);
2674                         }
2675                     }
2676                 } catch (IOException e) {
2677                     // not enough data probably fatal parsing error
2678                     throw new ReloadFault(i18n, &quot;rslt.badFile&quot;, e);
2679                 }
2680             }
2681 
2682             @Override
2683             public String getName() {
2684                 return name;
2685             }
2686 
2687             @Override
2688             public String getOutput() {
2689                 return output;
2690             }
2691 
2692             @Override
2693             public PrintWriter getPrintWriter() {
2694                 throw new IllegalStateException(&quot;This section is immutable&quot;);
2695             }
2696         }
2697 
2698         private class WritableOutputBuffer extends Writer implements OutputBuffer {
2699             private final String name;
2700             private final PrintWriter pw;
2701             private boolean overflowed;
2702             private int overflowStart;
2703             private /*final*/ StringBuffer output; // can&#39;t easily be final in JDK 1.1 because need to reassign to it
2704 
2705             WritableOutputBuffer(String name) {
2706                 super(TestResult.this);
2707                 if (name == null) {
2708                     throw new NullPointerException();
2709                 }
2710 
2711                 this.name = name;
2712                 output = new StringBuffer();
2713                 pw = new LockedWriter(this, TestResult.this);
2714             }
2715 
2716             @Override
2717             public String getName() {
2718                 return name;
2719             }
2720 
2721             @Override
2722             public String getOutput() {
2723                 return new String(output);
2724             }
2725 
2726             @Override
2727             public PrintWriter getPrintWriter() {
2728                 return pw;
2729             }
2730 
2731             @Override
2732             public void write(char[] buf, int offset, int len) throws IOException {
2733                 if (output == null) {
2734                     throw new IOException(&quot;stream has been closed&quot;);
2735                 }
2736 
2737                 int end = output.length();
2738                 output.append(buf, offset, len);
2739                 // want to avoid creating the string buf(offset..len)
2740                 // since likely case is no observers
2741                 notifyUpdatedOutput(Section.this, name, end, end, buf, offset, len);
2742 
2743                 int maxOutputSize = maxTROutputSize &gt; 0 ? maxTROutputSize : commonOutputSize;
2744                 if (output.length() &gt; maxOutputSize) {
2745                     int overflowEnd = maxOutputSize / 3;
2746                     if (overflowed) {
2747                         // output.delete(overflowStart, overflowEnd);
2748                         // JDK 1.1--start
2749                         String s = output.toString();
2750                         output = new StringBuffer(s.substring(0, overflowStart) + s.substring(output.length() - overflowEnd));
2751                         // JDK 1.1--end
2752                         notifyUpdatedOutput(Section.this, name, overflowStart, overflowEnd, &quot;&quot;);
2753                     } else {
2754                         String OVERFLOW_MESSAGE =
2755                                 &quot;\n\n...\n&quot;
2756                                         + &quot;Output overflow:\n&quot;
2757                                         + &quot;JT Harness has limited the test output to the text\n&quot;
2758                                         + &quot;at the beginning and the end, so that you can see how the\n&quot;
2759                                         + &quot;test began, and how it completed.\n&quot;
2760                                         + &quot;\n&quot;
2761                                         + &quot;If you need to see more of the output from the test,\n&quot;
2762                                         + &quot;set the system property javatest.maxOutputSize to a higher\n&quot;
2763                                         + &quot;value. The current value is &quot; + maxOutputSize
2764                                         + &quot;\n...\n\n&quot;;
2765                         overflowStart = maxOutputSize / 3;
2766                         //output.replace(overflowStart, maxOutputSize*2/3, OVERFLOW_MESSAGE);
2767                         // JDK 1.1--start
2768                         String s = output.toString();
2769                         output = new StringBuffer(s.substring(0, overflowStart) + OVERFLOW_MESSAGE + s.substring(overflowEnd));
2770                         // JDK 1.1--end
2771                         notifyUpdatedOutput(Section.this, name, overflowStart, overflowEnd, OVERFLOW_MESSAGE);
2772                         overflowStart += OVERFLOW_MESSAGE.length();
2773                         overflowed = true;
2774                     }
2775                 }
2776             }
2777 
2778             @Override
2779             public void flush() {
2780                 //no-op
2781             }
2782 
2783             public void deleteAllOutput() {
2784                 pw.flush();
2785                 output.setLength(0);
2786                 overflowStart = -1;
2787                 overflowed = false;
2788             }
2789 
2790             @Override
2791             public void close() {
2792                 makeOutputImmutable(this, name, new String(output));
2793                 notifyCompletedOutput(Section.this, name);
2794             }
2795         }
2796     }
2797 
2798     /**
2799      * Encapsulates info needed for a proper writing of the given piece of text.
2800      */
2801     static class TextScanResult {
2802         int numLines;
2803         int numBackslashes;
2804         int numNonASCII;
2805         boolean needsFinalNewline;
2806         boolean needsEscape;
2807 
2808         public static TextScanResult scan(String text) {
2809             TextScanResult tsr = new TextScanResult();
2810 
2811             tsr.numLines = 0;
2812             tsr.numBackslashes = 0;
2813             tsr.numNonASCII = 0;
2814             tsr.needsFinalNewline = false;
2815 
2816             // scan for newlines and characters requiring escapes
2817             for (int i = 0; i &lt; text.length(); i++) {
2818                 char c = text.charAt(i);
2819                 if (c &lt; 32) {
2820                     if (c == &#39;\n&#39;) {
2821                         tsr.numLines++;
2822                     } else if (c != &#39;\t&#39; &amp;&amp; c != &#39;\r&#39;) {
2823                         tsr.numNonASCII++;
2824                     }
2825                 } else if (c &lt; 127) {
2826                     if (c == &#39;\\&#39;) {
2827                         tsr.numBackslashes++;
2828                     }
2829                 } else {
2830                     tsr.numNonASCII++;
2831                 }
2832             }
2833 
2834             tsr.needsEscape = tsr.numBackslashes &gt; 0 || tsr.numNonASCII &gt; 0;
2835 
2836             // Check the text ends with a final newline (&#39;\n&#39;, not line.separator)
2837             // Note this must match the check when reading the text back in,
2838             // when we also check for just &#39;\n&#39; and not line.separator, because
2839             // line.separator now, and line.separator then, might be different.
2840             if (!text.isEmpty() &amp;&amp; !text.endsWith(&quot;\n&quot;)) {
2841                 tsr.needsFinalNewline = true;
2842                 tsr.numLines++;
2843             }
2844             return tsr;
2845         }
2846     }
2847 
2848 }
    </pre>
  </body>
</html>